{"id": "1401.3897", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Interpolable Formulas in Equilibrium Logic and Answer Set Programming", "abstract": "implicit interpolation is an important fundamental property of classical and then many non - classical logics that now has been shown externally to have interesting philosophical applications in early computer science and contemporary ai. here we we study the interpolation universal property, for modifying the the non - interacting monotonic equilibrium system semantics of equilibrium logic, establishing weaker or partially stronger forms theory of uniform interpolation depending chiefly on maintaining the original precise interpretation of such the linear inference relation. these proven results also yield potentially a canonical form of interpolation for objective ground breaking logic programs assuming under - the intuitive answer sets semantics. remarkably for disjunctive logic programs we also study the random property phenomenon of uniform interpolation that, is closely being related further to the formal concept of variable forgetting. the first - 3rd order bounded version of equilibrium logic has analogous interpolation properties whenever satisfying the default collection of equilibrium models is ( first - order ) definable. since this is the necessary case for so - called usually safe logical programs lists and theories, tonight it arguably applies inevitably to the usual nonlinear situations that all arise in objective practical answer set programming.", "histories": [["v1", "Thu, 16 Jan 2014 05:18:24 GMT  (263kb)", "http://arxiv.org/abs/1401.3897v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["dov gabbay", "david pearce", "agust\\'in valverde"], "accepted": false, "id": "1401.3897"}, "pdf": {"name": "1401.3897.pdf", "metadata": {"source": "CRF", "title": "Interpolable Formulas in Equilibrium Logic and Answer Set Programming", "authors": ["Dov Gabbay", "David Pearce"], "emails": ["dov.gabbay@kcl.ac.uk", "david.pearce@upm.es", "valverde@ctima.uma.es"], "sections": [{"heading": "1. Introduction", "text": "The interpolation property is an important and much discussed topic in logical systems, both classical and non-classical (Gabbay & Maksimova, 2005). Its importance in computer science is also becoming recognised nowadays. The interpolation property has been applied in various areas of computer science, for example in software specification (Diaconescu, Goguen, & Stefaneas, 1993; Bicarregui, Dimitrakos, Gabbay, & Maibaum, 2001), in the construction of formal ontologies (Kontchakov, Wolter, & Zakharyaschev, 2008) and in model checking and related subareas (McMillan, 2005). In the first two areas interpolation is important as a metatheoretical property, in particular it may provide a basis for the modular composition and decomposition of theories; for instance, for Kontchakov et al. (2008) it plays a key role in the study of the modular decomposition of ontologies. In other cases, interpolants themselves play a role as special formulas applied in automated deduction (McMillan, 2005).\nTo date interpolation has received much less attention in systems of non-monotonic reasoning and logic programming, despite their importance in AI and computer science. In this note we study the interpolation property for the system of nonmonotonic reasoning known as equilibrium logic (Pearce, 2006). Since this in turn can be regarded as a logical foundation for stable model reasoning and answer set programming (ASP), our results transfer immediately to the sphere of ASP. We shall focus here mainly on interpolation as a\nc\u00a92011 AI Access Foundation. All rights reserved.\nmetatheoretical property and our primary interest is in establishing this property for certain cases of interest. Although in Section 8 we consider a case where an interpolant (actually a uniform interpolant) is explicitly constructed, we are mainly concerned here with pure existence theorems. Discussion of complexity issues as well as possible applications of the interpolation property in ASP are left to future work. However, it seems likely that, as in the case of studies involving formal ontologies (Konev, Walther, & Wolter, 2009), interpolation may be a useful property for applications of ASP in knowledge representation. In a previous paper (Pearce & Valverde, 2012), the interpolation and Beth properties of the underlying, monotonic logic of ASP were used to characterise strong kinds of intertheory relations. To capture weaker kinds of intertheory relations it may be important to be able to rely on interpolation holding in the extended, non-monotonic logic. We plan to explore this avenue in the future.\nTo introduce the property of interpolation, let us start with some notation and terminology. Let us assume the syntax of first-order logic with formulas denoted by lower case Greek letters and predicates by lower case Latin letters.\nLet \u22a2 be a monotonic inference relation and suppose that \u03b1 \u22a2 \u03b2. An interpolant for (\u03b1, \u03b2) is a formula \u03b3 such that\n\u03b1 \u22a2 \u03b3 & \u03b3 \u22a2 \u03b2 (1)\nwhere \u03b3 contains only predicate and constant symbols that belong to both \u03b1 and \u03b2. A logic L with inference relation \u22a2L is said to have the interpolation property if an interpolant exists for every pair of formulas (\u03b1, \u03b2) such that \u03b1 \u22a2L \u03b2. As is well-known, classical logic as well as many non-classical logics possess interpolation.\nSuppose now we deal with a non-monotonic logical system with an inference relation |\u223c. To express the idea that a formula is an interpolant it will not generally suffice simply to replace \u22a2 by |\u223c in (1). One problem is that, since |\u223c is non-monotonic, it is in general not transitive. Instead, following the idea of Gabbay and Maksimova (2005), we can modify condition (1) and proceed in a two-stage fashion. We make use of the fact that nonmonotonic consequence can be defined in terms of minimal models in some monotonic logical system, say that the consequence relation |\u223c is appropriately captured by means of minimal models in a logic L with consequence relation |=L. Now suppose that \u03b1 |\u223c\u03b2. Then as an interpolant for (\u03b1, \u03b2) we look for a formula \u03b3 such that\n\u03b1 |\u223c \u03b3 & \u03b3 |=L \u03b2 (2)\nwhere all predicate and constant symbols of \u03b3 occur in both \u03b1 and \u03b2. Since |\u223c is to be defined via a subclass of minimal L-models, we already assume that |=L\u2286 |\u223c. Moreover we should assume too that L is a well-behaved sublogic in the sense that L-equivalent formulas have the same |\u223c-consequences and that the L-consequences of |\u223c-consequences are themselves |\u223c-consequences (so e.g. from (2) we can derive \u03b1 |\u223c \u03b2). In non-monotonic reasoning these last two properties are known as left and right absorption, respectively. Given these conditions, it follows at once from (2) that any formula in the language of \u03b3 that is L-equivalent to \u03b3 will also be an interpolant for (\u03b1, \u03b2). Likewise if \u03b3 is an interpolant for (\u03b1, \u03b2) and \u03b2 |=L \u03b4 then \u03b1 |\u223c \u03b4 and \u03b3 is an interpolant for (\u03b1, \u03b4).\nNow, to find an interpolant for (\u03b1, \u03b2) satisfying (2), or to prove that one always exists, we can proceed as follows. We look for an L-formula \u03b1\u2032 say, that precisely L-defines the\nminimal models of \u03b1. Since \u03b1 |\u223c \u03b2 it follows that \u03b1\u2032 |=L \u03b2. Now, if L has the interpolation property as defined earlier, we apply this theorem to obtain or infer the existence of an L-interpolant \u03b3 in the sense of (1) for (\u03b1\u2032, \u03b2). Hence (2) follows.\nNotice that this two-stage procedure relies on three key features: (i) that we can identify a suitable monotonic sublogic L for |\u223c, (ii) that a formula\u2019s minimal models are L-definable, and (iii) that L has the interpolation property. These conditions are prima facie independent. As we shall see, we may have (i) and (iii) but lack (ii). The situation with respect to equilibrium logic is as follows. In the propositional case all three conditions are met, so we can establish the interpolation property in the general case. The situation for quantified equilibrium logic is more complicated. In the general case, we lack condition (ii). More precisely, we have an appropriate monotonic sublogic L and this logic has the interpolation property, but the equilibrium models of a formula need not be first-order definable in L. So the procedure outlined does not yield interpolants in all cases. However some recent results on a generalised concept of (first-order) stable model imply that there are interesting classes of interpolable formulas: we shall consider in more detail one such class, that of safe formulas. In particular, if \u03b1 is a safe formula and \u03b1 |\u223c \u03b2, then there exists an interpolant \u03b3 such that (2) holds. Other classes of interpolable formulas are so-called tight formulas, and formulas possessing a finite, complete set of what are called loops.\nSafety, tightness and loop formulas have been studied at some length in answer set programming (ASP). The implications of these results for ASP can be summarised as follows. In the case of (finite) ground programs the interpolation property holds. In the first-order or non-ground case, interpolation holds for finite, safe programs without function symbols, and hence practically for all finite programs currently admitted by answer set solvers. Moreover, since safety is now defined for arbitrary formulas in a function-free language, the class of safe formulas in this sense goes beyond the class of expressions normally admitted in ASP, even if auxiliary concepts like weight constraints and aggregates are included."}, {"heading": "2. Logical Preliminaries", "text": "We work with standard propositional and predicate languages, where the latter may in the general case contain constant and function symbols. Propositional languages are based on a set V of propositional variables, and formulas are built-up in the usual way using the logical constants \u2227, \u2228, \u2192, \u00ac, standing respectively for conjunction, disjunction, implication and negation. If \u03d5 is a propositional formula, we denote by V (\u03d5) the set of propositional variables appearing in \u03d5.\nA first-order language L = \u3008C,F, P \u3009 consists of a set of constants C, function symbols F and predicate symbols P ; each function symbol f in F and predicate symbol p \u2208 P has an assigned arity. Moreover, we assume a fixed countably infinite set of variables, the symbols \u2018\u2192\u2019, \u2018\u2228\u2019, \u2018\u2227\u2019, \u2018\u00ac\u2019, \u2018\u2203\u2019, \u2018\u2200\u2019, and auxiliary parentheses \u2018(\u2019, \u2018)\u2019. Atoms, terms and formulas are constructed as usual; closed formulas, or sentences, are those where each variable is bound by some quantifier. If \u03d5 is a (first-order) formula, L(\u03d5) denotes the language associated with \u03d5, i.e. the set of constants, function and predicate symbols occuring in it.\nWe make use of the following notation and terminology. Boldface x stands for a tuple of variables, x = (x1, . . . , xn), while \u03d5(x) = \u03d5(x1, . . . , xn) is a formula whose free variables\nare x1,. . . , xn, and \u2200x = \u2200x1 . . . \u2200xn. If ti are terms, then t = (t1, . . . , tn) denotes a vector of terms. A theory \u03a0 is a set of sentences. Variable-free terms, atoms, formulas, or theories are also called ground.\nAs usual the symbols \u22a2 and |=, possibly with subscripts, are used to denote logical inference and consequence relations, respectively. A logic L is said to be monotonic if its inference relation \u22a2L satisfies the monotonicity property:\n\u03a0 \u22a2L \u03d5 & \u03a0 \u2286 \u03a0 \u2032 \u21d2 \u03a0\u2032 \u22a2L \u03d5\nTo distinguish non-monotonic from monotonic inference relations, we use |\u223c to symbolise the former. In most cases a non-monotonic logic can be understood in terms of an inference relation that extends a suitable monotonic logic. When this extension is well-behaved we say that the monotonic logic forms a deductive base1 (Pearce, 2006) for it. This can be made precise as follows.\nDefinition 1 Let |\u223c be any nonmonotonic inference relation. We say that a logic L with monotonic inference relation \u22a2L is a deductive base for |\u223c iff (i) \u22a2L\u2286 |\u223c; (ii) If \u03a01 \u2261L \u03a02 then \u03a01 \u2248 \u03a02; (iii) If \u03a0 |\u223c \u03d5 and \u03d5 \u22a2L \u03c8, then \u03a0 |\u223c \u03c8.\nHere \u2261L denotes ordinary logical equivalence in L, while \u2248 denotes non-monotonic equivalence, i.e. \u03a01 \u2248 \u03a02 means that \u03a01 and \u03a02 have the same non-monotonic consequences. Furthermore, we say that a deductive base is strong if it satisfies the additional condition:\n\u03a01 6\u2261L \u03a02 \u21d2 there exists \u0393 such that \u03a01 \u222a \u0393 6\u2248 \u03a02 \u222a \u0393.\nIn terms of nonmonotonic consequence operations, (ii) and (iii) correspond to conditions known as left absorption and right absorption respectively (Makinson, 1994)."}, {"heading": "2.1 Interpolation", "text": "We now turn to the interpolation property.\nDefinition 2 A logic L with inference relation \u22a2L is said to have the interpolation property if whenever\n\u22a2L \u03d5\u2192 \u03c8\nthere exists a sentence \u03be (the interpolant) such that\n\u22a2L \u03d5\u2192 \u03be & \u22a2L \u03be \u2192 \u03c8\nwhere all predicate, function and constant symbols of \u03be are contained in both \u03d5 and \u03c8, i.e. L(\u03be) \u2286 L(\u03d5) \u2229 L(\u03c8). In the case of propositional logic, the requirement is that V (\u03be) \u2286 V (\u03d5) \u2229 V (\u03c8).\nAs explained in the introduction, for non-monotonic logics we can consider two forms of interpolation, one weaker one stronger. The stronger form makes use of an underlying monotonic logic.\n1. It is close to the concept of fully absorbing inferential frame used by Dietrich (1994).\nDefinition 3 Suppose that \u03b1 |\u223c\u03b2. A (|\u223c,\u22a2L) interpolant for (\u03b1, \u03b2) is a formula \u03b3 such that\n\u03b1 |\u223c \u03b3 & \u03b3 \u22a2L \u03b2 (3)\nwhere L is a deductive base for |\u223c and \u03b3 contains only predicate, function and constant symbols that belong to both \u03b1 and \u03b2. A non-monotonic logic with inference relation |\u223c is said to have the (|\u223c,\u22a2) interpolation property if for a suitable deductive base logic L an (|\u223c,\u22a2L) interpolant exists for every pair of formulas (\u03b1, \u03b2) such that \u03b1 |\u223c \u03b2.\nThe requirement that L form a deductive base ensures that some desirable properties of interpolation are met.\nProposition 1 Let \u03b3 be a (|\u223c,\u22a2L) interpolant for (\u03b1, \u03b2). (a) For any \u03c8 such that \u03c8 \u2261L \u03b3, \u03c8 is a (|\u223c,\u22a2L) interpolant for (\u03b1, \u03b2). (b) For any \u03b1\u2032 such that \u03b1 \u2261L \u03b1 \u2032, and any \u03b2\u2032 such that \u03b2 \u22a2L \u03b2 \u2032, \u03b3 is a (|\u223c,\u22a2L) interpolant for (\u03b1\u2032, \u03b2\u2032).\nThe property of deductive base also guarantees that the (|\u223c,\u22a2L) relation is transitive in the sense that if (3) holds for any \u03b1, \u03b2, \u03b3, then also \u03b1 |\u223c\u03b2. This last property will not necessarily hold for the second, weaker form of interpolation that we call (|\u223c, |\u223c) interpolation.\nDefinition 4 Suppose that \u03b1 |\u223c\u03b2. A (|\u223c, |\u223c) interpolant for (\u03b1, \u03b2) is a formula \u03b3 such that\n\u03b1 |\u223c \u03b3 & \u03b3 |\u223c \u03b2 (4)\nwhere \u03b3 contains only predicate, function and constant symbols that belong to both \u03b1 and \u03b2. In the case of propositional logic, the requirement is that V (\u03be) \u2286 V (\u03d5) \u2229 V (\u03c8).\nAnalogous to the previous case, we say that a non-monotonic logic with inference relation |\u223c has the (|\u223c, |\u223c) interpolation property if a (|\u223c, |\u223c) interpolant exists for every pair of formulas (\u03b1, \u03b2) such that \u03b1 |\u223c \u03b2. Notice that (|\u223c,\u22a2) is the stronger form of interpolation because if a logic has (|\u223c,\u22a2) interpolation it must also have (|\u223c, |\u223c) interpolation, again as a consequence of the deductive base requirement (first clause).\nEvidently the properties expressed in Proposition 1 are not directly applicable to the second form of interpolation that does not refer to any underlying base logic. Nevertheless an important feature of the interpolation properties we shall establish below is that we can formulate and prove analogous properties even for (|\u223c, |\u223c) interpolation.\nWe can also consider restricted variants of interpolation when the property holds for certain types of formulas, in other words, when there is an interpolant for (\u03b1, \u03b2) given \u03b1 |\u223c \u03b2 whenever \u03b1 and \u03b2 belong to specific syntactic classes. In such cases we can refer to interpolable formulas. Later on we shall consider both kinds of restrictions, where \u03b1 belongs to a specific class or alternatively when \u03b2 does."}, {"heading": "2.2 Review of the Logic of Here-and-There", "text": "Equilibrium logic is based on the nonclassical logic of here-and-there, which we denote by HT in the propositional case. In the quantified or first-order case we denote the logic by QHT, with subscripts/superscripts to denote specific variants.\nIn both propositional and quantified cases the logic is based on the axioms and rules of intuitionistic logic and is captured by the usual Kripke semantics for intuitionistic logic (van Dalen, 1997). However the additional axioms of HT and QHT mean that we can use very simple kinds of Kripke structures. In the first-order case we regard these structures as sets of atoms built over arbitrary non-empty domains D; we denote by At(D,F, P ) the set of atomic sentences of \u3008D,F, P \u3009 (if D = C, we obtain the set of atomic sentence of the language L = \u3008C,F, P \u3009);2 and we denote by T (D,F ) the set of ground terms of \u3008D,F, P \u3009. If L = \u3008C,F, P \u3009 and L\u2032 = \u3008C \u2032, F \u2032, P \u2032\u3009, we write L \u2286 L\u2032 if C \u2286 C \u2032, F \u2286 F \u2032 and P \u2286 P \u2032.\nBy an L-interpretation over a set D we mean a subset of At(D,F, P ). A classical Lstructure can be regarded as a tuple I = \u3008(D, I), I\u2217\u3009 where I\u2217 is an L-interpretation over D and I : T (C \u222aD,F ) \u2192 D, called the assignment, verifies that I(d) = d for all d \u2208 D and is recursively defined.3 If D = T (C,F ) and I = id, I is known as an Herbrand structure. On the other hand, a here-and-there L-structure with static domains, or QHTs(L)-structure, is a tuple I = \u3008(D, I), Ih, It\u3009 where \u3008(D, I), Ih\u3009 and \u3008(D, I), It\u3009 are classical L-structures such that Ih \u2286 It.\nThus we can think of a here-and-there structure I as similar to a first-order classical model, but having two parts, or components, h and t that correspond to two different points or \u201cworlds\u201d, \u2018here\u2019 and \u2018there\u2019, in the sense of Kripke semantics for intuitionistic logic, where the worlds are ordered by h \u2264 t. At each world w \u2208 {h, t} one verifies a set of atoms Iw in the expanded language for the domain D. We call the model static, since, in contrast to say intuitionistic logic, the same domain serves each of the worlds. Since h < t, whatever is verified at h remains true at t. The satisfaction relation for I is defined so as to reflect the two different components, so we write I, w |= \u03d5 to denote that \u03d5 is true in I with respect to the w component. Although we only need to define the satisfaction relation in L = \u3008C,P \u3009, the recursive definition forces us to consider formulas from \u3008C \u222a D,F, P \u3009. In particular, if p(t1, . . . , tn) \u2208 At(C \u222a D,F, P ) then I, w |= p(t1, . . . , tn) iff p(I(t1), . . . , I(tn)) \u2208 I\nw for every t1, . . . , tn \u2208 T (C \u222aD,F ). Then |= is extended recursively as follows 4:\n\u2022 I, w |= \u03d5 \u2227 \u03c8 iff I, w |= \u03d5 and I, w |= \u03c8.\n\u2022 I, w |= \u03d5 \u2228 \u03c8 iff I, w |= \u03d5 or I, w |= \u03c8.\n\u2022 I, t |= \u03d5\u2192 \u03c8 iff I, t 6|= \u03d5 or I, t |= \u03c8.\n\u2022 I, h |= \u03d5\u2192 \u03c8 iff I, t |= \u03d5\u2192 \u03c8 and I, h 6|= \u03d5 or I, h |= \u03c8.\n\u2022 I, w |= \u00ac\u03d5 iff I, t 6|= \u03d5.\n\u2022 I, t |= \u2200x\u03d5(x) iff I, t |= \u03d5(d) for all d \u2208 D.\n\u2022 I, h |= \u2200x\u03d5(x) iff I, t |= \u2200x\u03d5(x) and I, h |= \u03d5(d) for all d \u2208 D.\n\u2022 I, w |= \u2203x\u03d5(x) iff I, w |= \u03d5(d) for some d \u2208 D.\n2. We can think of the objects in D as additional constants; this approach allow us to use a simplified notation where the objects are not distinguished from their names. 3. That is, for every a \u2208 C, I(a) \u2208 D and for every f \u2208 F with arity n, a mapping fI : Dn \u2192 D is defined; so the recursive definition is given by I(f(t1, . . . , tn)) = f\nI(I(t1), . . . , I(tn)). 4. The following corresponds to the usual Kripke semantics for intuitionistic logic given our assumptions\nabout the two worlds h and t and the single domain D,\nTruth of a sentence in a model is defined as follows: I |= \u03d5 iff I, w |= \u03d5 for each w \u2208 {h, t}. A sentence \u03d5 is valid if it is true in all models, denoted by |= \u03d5. A sentence \u03d5 is a consequence of a set of sentences \u03a0, denoted \u03a0 |= \u03d5, if every model of \u03a0 is a model of \u03d5.\nThe resulting logic is called Quantified Here-and-There Logic with static domains (Lifschitz, Pearce, & Valverde, 2007) denoted by QHTs. In terms of satisfiability and validity this logic is equivalent to the logic introduced by Pearce and Valverde (2005).\nA complete axiomatisation of QHTs can be obtained as follows (Lifschitz et al., 2007). We take the axioms and rules of first-order intuitionistic logic and add the axiom of Hosoi\n\u03b1 \u2228 (\u00ac\u03b2 \u2228 (\u03b1\u2192 \u03b2)) (5)\nwhich determines 2-element here-and-there models in the propositional case, together with the axiom:\n\u2203x(\u03b1(x) \u2192 \u2200x\u03b1(x)).\nWe also consider the equality predicate, . = 6\u2208 P , interpreted by the following condition for every w \u2208 {h, t}\n\u2022 I, w |= t1 . = t2 iff I(t1) = I(t2).\nTo obtain a complete axiomatisation, we then need to add the axiom of \u201cdecidible equality\u201d\n\u2200x\u2200y(x . = y \u2228 x 6 . = y).\nWe denote the resulting logic by QHTs= (Lifschitz et al., 2007) and its inference relation by \u22a2. By compactness a strong form of completeness can be established such that \u03a0 |= \u03d5 if and only if \u03a0 \u22a2 \u03d5.\nIn the context of logic programs, the following assumptions often play a role. In the case of both classical and QHTs= models, we say that the parameter names assumption (PNA) applies in case I|T (C,F ) is surjective, i.e. there are no unnamed individuals in D; the unique names assumption (UNA) applies in case I|T (C,F ) is injective; in case both the PNA and UNA apply, the standard names assumption (SNA) applies, i.e. I|T (C,F ) is a bijection.\nAs usual in first order logic, satisfiability and validity are independent of the signature. If I = \u3008(D, I), Ih, It\u3009 is an L\u2032-structure and L\u2032 \u2283 L, we denote by I|L the restriction of I to the sublanguage L:\nI|L = \u3008(D, I|L), I h|L, I t|L\u3009\nProposition 2 Suppose that L\u2032 \u2283 L, \u03a0 is a theory in L and M is an L\u2032-model of \u03a0. Then M|L is a L-model of \u03a0.\nProposition 3 Suppose that L\u2032 \u2283 L and \u03d5 \u2208 L. Then \u03d5 is valid (resp. satisfiable) in QHTs=(L) if and only if is valid (resp. satisfiable) in QHT s =(L \u2032).\nThis proposition allows us to omit reference to the signature in the logic so it can be denoted simply by QHTs=.\nTo simplify notation we also symbolise a QHTs= structure I = \u3008(D, I), I h, It\u3009 by \u3008U,H, T \u3009, where U = (D, I) is the universe, and H, T respectively are the sets of atoms Ih, It. In the case of propositional HT logic, Kripke structures can be regarded as pairs \u3008H,T \u3009 of set of atoms in the obvious way. A (strongly) complete axiomatisation for HT is obtained from intuitionistic logic by adding just the Hosoi axiom (5)."}, {"heading": "2.3 Interpolation in the Logic of Here-and-There", "text": "An important and useful property of HT is the fact that it is the strongest propositional intermediate logic (i.e. strengthening of intuitionistic logic) that is properly contained in classical logic. Moreover it in turn properly contains all other such intermediate logics. In addition HT is one of precisely seven superintuitionistic propositional logics possessing the interpolation property (Maksimova, 1977; Gabbay & Maksimova, 2005).\nFor languages without function symbols Ono showed that interpolation holds in the logic QHTs of quantified here-and-there with constant domains (Ono, 1983).5 In addition, Maksimova (1997, 1998) showed that adding pure equality axioms, e.g. the decidible equality axiom, to any superintuitionistic logic preserves the interpolation property (Gabbay & Maksimova, 2005). We conclude therefore\nProposition 4 The logic QHTs= possesses the interpolation property.\nNote that by the strong completeness theorem for QHTs= we can work equivalently with \u22a2 or with |=.\nHere we can make the further observation that interpolation continues to hold for languages that include function symbols. This can be established using the following property.\nProposition 5 For every formula \u03d5, it is possible to build a formula \u03c8, such that \u03d5 \u2261 \u03c8, and the atoms of \u03c8 are of one of the following types:\n\u2022 x . = a for some a \u2208 C,\n\u2022 f(x1, . . . xn) . = y for some f \u2208 F (where every xi and y are variables),\n\u2022 p(t1, . . . , tm) (where every xi and y are variables).\nTheorem 1 Let L be a language containing function symbols. Then QHTs=(L) has the interpolation property.\nProof sketch: Let us assume that \u22a2 \u03d5\u2192 \u03c8; from the previous proposition, we can assume, without loss of generality, that the function symbols in \u03d5 and \u03c8 are in atoms of type f(x1, . . . xn) . = y. Now, we consider a language L\u2032 obtained from L by replacing every function symbol f by a fresh predicate symbol, Pf , such that the Arity(Pf ) = 1+Arity(f). Let \u03d5\u2032 and \u03c8\u2032 be formulas in L\u2032 build from \u03d5 and \u03c8 respectivelly, by replacing every atom f(x1, . . . xn) . = y by Pf (x1, . . . xn, y). Trivially, \u22a2 \u03d5\n\u2032 \u2192 \u03c8\u2032 and, for the interpolation property of QHTs=(L\n\u2032), there exists an interpolant \u03b2\u2032: \u22a2 \u03d5\u2032 \u2192 \u03b2\u2032, \u22a2 \u03b2\u2032 \u2192 \u03c8\u2032. If we replace in \u03b2\u2032 the predicates Pf (t1, . . . , tn, tn+1) by atoms f(t1, . . . tn) . = tn+1 we obtain the interpolant \u03b2 for the initial pair of formulas.\n5. Ono\u2019s axiomatisation of QHTs uses the constant domains axiom \u2200x(\u03b1(x)\u2228\u03b2) \u2192 (\u2200x\u03b1(x)\u2228\u03b2), as well as alternative axioms for propositional here-and-there, viz. p\u2228 (p \u2192 (q\u2228\u00acq)) and (p \u2192 q)\u2228 (q \u2192 p)\u2228 (p \u2194 \u00acq). However, the axioms given here are equivalent to Ono\u2019s."}, {"heading": "2.4 Equilibrium Logic", "text": "Equilibrium logic is a non-monotonic logic based on certain kinds of minimal models in QHTs= or HT. We give the definition for QHT s =; the propositional version is easily obtained from it.\nDefinition 5 Among quantified here-and-there structures we define the order E as follows:\n\u3008(D, I), Ih, It\u3009E \u3008(D\u2032, J), Jh, J t\u3009 if D = D\u2032, I = J, It = J t, Ih \u2286 Jh.\nIf the subset relation holds strictly, we write \u2018\u22b3\u2019.\nDefinition 6 (Equilibrium model) Let \u03a0 be a theory and I = \u3008(D, I), Ih, It\u3009 a model of \u03a0.\n1. I is said to be total if Ih = It.\n2. I is said to be an equilibrium model of \u03a0 (or short, we say: \u201cI is in equilibrium\u201d) if it is minimal under E among models of \u03a0, and it is total.\nIn other words, equilibrium models are total models for which there is no \u2018smaller\u2019 non-total model. Evidently a total QHTs= model of a theory \u0393 can be equivalently regarded as a classical first order model of \u0393; and in what follows we make tacit use of this equivalence. In the propositional case, equilibrium models are defined in the same way, where now the ordering is between propositional HT models. In the usual way a formula or theory is said to be consistent if it has a QHTs= model and additionally we say that it is coherent if it has an equilibrium model.\nThe following definition give a preliminary notion of equilibrium entailment, which agrees with standard versions of equilibrium logic (Pearce, 2006).\nDefinition 7 The relation |\u223c, called equilibrium entailment, is defined as follows. Let \u03a0 be a set of formulas.\n1. If \u03a0 is non-empty and coherent (has equilibrium models), then \u03a0 |\u223c\u03d5 if every equilibrium model of \u03a0 is a model of \u03d5 in QHTs= (respectively HT).\n2. If either \u03a0 is empty or has no equilibrium models, then \u03a0 |\u223c \u03d5 if \u03a0 \u22a2 \u03d5.\nNotice that unless we need to distinguish propositional from first-order reasoning we use the symbols \u2018|\u223c\u2019, \u2018\u22a2\u2019 and \u2018|=\u2019 for either version.\nA few words may help to explain the concept of equilibrium entailment. First, we define the basic notion of entailment as truth in every intended (equilibrium) model. In nonmonotonic reasoning this is a common approach and sometimes called a skeptical or cautious notion of entailment or inference; its counterpart brave reasoning being defined via truth in some intended model. Since equilibrium logic is intended to provide a logical foundation for the answer set semantics of logic programs, the cautious variant of entailment is the natural one to choose: the standard consequence relation associated with answer sets is given by truth in all answer sets of a program. Note however that in ASP as a programming paradigm each answer set may correspond to a particular solution of the problem being modelled and is therefore of interest in its own right.\nSecondly, it is useful to have a nonmonotonic consequence or entailment relation that is non-trivially defined for all consistent theories. As we shall see below, however, not all such theories possess equilibrium models. For such cases it is natural to use monotonic consequence as the entailment relation. In particular in the propositional case HT is a maximal logic with the property that logically equivalent theories have the same equilibrium models. Evidently situation 2 also handles correctly the cases that \u03a0 is empty or inconsistent.\nDespite these qualifications, there remains an ambiguity in the concept of equilibrium entailment that we now need to settle. Suppose that L\u2032 \u2283 L, \u03a0 is a theory in L and \u03d5 is a sentence in L\u2032 (i.e. L\u2032 = L(\u03d5)). How should we understand the expression \u2018\u03a0 |\u223c \u03d5\u2019?\nEvidently, if we fix a language in advance, say as the language L\u2032, then we can simply consider the equilibrium models of \u03a0 in L\u2032. But if \u03a0 represents a knowledge base or a logic program, for instance, we may also take the view that L(\u03a0) is the appropriate signature to work with. In that case, the query \u03d5 is as such not fully interpreted as it contains some terms not in the theory language L(\u03a0).\nFor any language L and theory \u03a0 whose language is contained in L, let EML(\u03a0) be the collection of all equilibrium models of \u03a0 in QHTs=(L). Now consider the following two variants of entailment.\nDefinition 8 (Equilibrium entailment) Assume \u03a0 is a theory in L, is non-empty and has equilibrium models, then: (i) Let us write \u03a0|\u223ccw\u03d5 if and only if M |= \u03d5 for each M \u2208 EML\u2032(\u03a0), where L \u2032 = L\u222aL(\u03d5): (ii) let us write \u03a0 |\u223cow \u03d5 if and only if M |= \u03d5 for each M \u2208 EML(\u03a0) \u21be L(\u03d5), where in general EML(\u03a0) \u21be L\u2032 denotes the collection of all expansions of elements of EML(\u03a0) to models in L \u222a L\u2032, i.e. where the vocabulary of L\u2032 \\ L is interpreted arbitrarily. (iii) If either \u03a0 is empty or has no equilibrium models, then \u03a0 |\u223ccw \u03d5 iff \u03a0 |\u223cow \u03d5 iff \u03a0 \u22a2 \u03d5.\nA simple example will illustrate the difference between |\u223ccw and |\u223cow. Let \u03c8 be an L-sentence and let q(x) be a predicate not in L. Let a be a constant in L and let L\u2032 be the language L \u222a {q}. By the first method we have \u03c8 |\u223ccw \u03c8 \u2227 (q(a) \u2228 \u00acq(a)). In fact we have the stronger entailment \u03c8 |\u223ccw \u03c8 \u2227\u00acq(a). The reason is that when we form the equilibrium models of \u03c8 in L\u2032, q(a) will be false in each as an effect of taking minimal models. On the other hand, if we expand equilibrium models of \u03c8 in QHTs=(L) to QHT s =(L\n\u2032), the new predicate q receives an arbitrary interpretation in QHTs=(L\n\u2032). Since this logic is 3-valued we do not obtain \u03a0 |\u223cow q(a) \u2228 \u00acq(a).\nFor standard, monotonic logics, there is no difference between these two forms of entailment. If in Definition 8 we replace everywhere equilibrium model by simply model (in QHTs=), variants (i) and (ii) give the same result.\nIn the context of logic programming and deductive databases the more orthodox view is that reasoning is based on a closed world assumption (CWA). Accordingly a ground atomic query like q(a)?, where the predicate q does not belong to the language of the program or database, would simply be assigned the value false. This is also the case with the first kind of equilibrium entailment and we use the label |\u223ccw since this variant appears closer to a closed world form of reasoning. On the other hand, there may be legitimate cases where we do not want to apply the CWA and where unknown values should be assigned to an atom that is not expressed in the theory language. Then the second form of entailment, |\u223cow,\nnearer to open world reasoning, may be more appropriate. For present purposes, however, the suffices \u2018cw\u2019 and \u2018ow\u2019 should be thought of merely as mnemonic labels.\nA thorough analysis of closed world versus open world reasoning in this context would lead us to consider assumptions such as UNA or SNA and is outside the scope of this paper. However, it has been observed in logic programming that the use of CWA can lead to certain apparent anomalies. Notably this occurs with programs that are unsafe (see Section 5 below), such as the following, formulated in traditional notation for logic programs:6\nq(x, y) : \u2212 not p(x, y). p(x, x).\nGiven restrictions such as SNA or Herbrand models, the query ?\u2212 q(a, z). yields no answer for z because it cannot be satisfied in models with only a single domain element a, while the query\n?\u2212 q(a, b). is satisfiable, given the new constant b. In logic programming, where these restrictions are usually assumed, different solutions to this problem have been proposed (Gelder, Ross, & Schlipf, 1991; Kunen, 1987; Maher, 1988). Here we would like to point out that for equilibrium logic generally speaking this kind of program or theory does not create any special difficulties. Neither the query\n?\u2212 q(a, z). which is understood as \u2203zq(a, z), nor the query\n?\u2212 q(a, b). is true in all equilibrium models. In particular, in an equilibrium model whose domain is a singleton element, even q(a, b) need not be true; evidently in the general case that UNA for instance does not apply. On the other hand in answer set programming, where UNA is often assumed, it is also typically assumed that programs are safe. By the safety condition the above program is excluded because variables appearing in the head of a rule do not appear in its positive body and this makes answer sets sensitive to the set of constants appearing in the language or those that are used for grounding the program. In this paper, where the application of interpolation in ASP is concerned, we restrict attention to safe programs and theories complying with a generalised form of safety (Section 5 below)."}, {"heading": "3. Interpolation in Propositional Equilibrium Logic", "text": "In this section we deal with interpolation in propositional equilibrium logic. It is clear that by its semantic construction propositional equilibrium logic has HT as a deductive base. This base is actually maximal.\nProposition 6 HT is a strong and maximal deductive base for (propositional) equilibrium entailment.\nThe first property is precisely the strong equivalence theorem of Lifschitz, Pearce and Valverde (2001). Maximality follows from the fact that any logic strictly stronger than HT would have to contain classical logic which is easily seen not to be a deductive base, e.g. violating condition (ii) of Definition 1. We have:\n6. We are grateful to an anonymous referee for raising this point and the example.\nLemma 1 Let \u03b1 be a coherent HT-formula and EM(\u03b1) its set of equilibrium models. Then there is formula \u03b1\u2032 of HT in v(\u03b1) that defines EM(\u03b1) in the sense that M \u2208 EM(\u03b1) if and only if M |= \u03b1\u2032.\nProof. Suppose that \u03b1 is coherent. and let\nM1 = \u3008T1, T1\u3009, M2 = \u3008T2, T2\u3009, . . . , Mn = \u3008Tn, Tn\u3009\nbe an enumeration of its equilibrium models. We show how to define EM(\u03b1). Suppose each Ti, has ki elements and denote them by A i 1, . . . , A i j , . . . , A i ki . Let Ti be the complement of Ti; then we can list its members as A i k1+1 , . . . Ail . . . , A i |v(\u03b1)|. Set\n\u03b4i = \u2227\nj=1,...,ki\nAij \u2227 \u00ac( \u2228\nl=ki+1,...,|v(\u03b1)|\nAil), and \u03b1 \u2032 =\n\u2228\ni=1,...,n\n\u03b4i\nWe claim that M |= \u03b1\u2032 if and only if M = Mi for some i = 1, . . . , n, i.e. the models of \u03b1 \u2032 are precisely M1, . . . ,Mn. To verify this claim, note that each Mi |= \u03b4 i and so Mi |= \u03b1\n\u2032. Conversely, suppose that M |= \u03b1\u2032. From the semantics of HT it is clear that M |= \u03d5\u2228\u03c8 iff M |= \u03d5 orM |= \u03c8, so in particular M |= \u03b1\u2032 implies M |= \u03b4i for some i = 1, . . . , n. However, each \u03b4i defines a complete theory whose models are total. It follows that if M |= \u03b4i, then M = Mi. This establishes the claim.\nAlthough we shall now demonstrate interpolation in the (|\u223c, |\u223c) form for the relation |\u223ccw, we actually establish a stronger result. One consequence of this is that if we are concerned with |\u223cow entailment then the (|\u223c,\u22a2) form of interpolation actually holds.\nProposition 7 (|\u223c, |\u223c-Interpolation) Let \u03b1, \u03b2 be formulas and set v = v(\u03b1) \u222a v(\u03b2) and v\u2032 = v(\u03b2) \\ v(\u03b1) and suppose that B1, . . . Bn is an enumeration of v\n\u2032. If \u03b1 |\u223ccw \u03b2, there is a formula \u03b3 such that v(\u03b3) \u2286 v(\u03b1) \u2229 v(\u03b2), \u03b1 |\u223c \u03b3, and \u03b3 \u2227 \u00acB1 \u2227 . . . \u2227 \u00acBn |= \u03b2. Hence in particular \u03b3 |\u223ccw \u03b2.\nProof. Let \u03b1, \u03b2 and v, v\u2032 be as in the statement of the proposition, and suppose that \u03b1|\u223ccw\u03b2. Then \u03b2 holds in all equilibrium models of \u03b1 in the language v. Case (i): suppose that \u03b1 is coherent and form its set of equilibrium models, EMv(\u03b1).\nBy the equilibrium construction it is easy to see that in each model M \u2208 EMv(\u03b1) each atom Bi is false, for i = 1, n. Construct the formulas \u03b4i and the formula \u03b1\n\u2032 exactly as in the proof of Lemma 1. Now consider the formula (\u00acB1 \u2227 . . . \u2227 \u00acBn) \u2227 \u03b1\n\u2032. Clearly this formula defines the set of equilibrium models of \u03b1 inHT(v). Consequently, (\u00acB1\u2227. . .\u2227\u00acBn)\u2227\u03b1\n\u2032 |= \u03b2 and so \u03b1\u2032 \u22a2 (\u00acB1 \u2227 . . . \u2227 \u00acBn) \u2192 \u03b2. We can now apply the interpolation theorem for HT to infer that there is a formula \u03b3 such that \u03b1\u2032 \u22a2 \u03b3 and \u03b3 \u22a2 (\u00acB1 \u2227 . . . \u2227 \u00acBn) \u2192 \u03b2, where v(\u03b3) \u2286 v(\u03b1\u2032) \u2229 v(\u03b2) and hence v(\u03b3) \u2286 v(\u03b1) \u2229 v(\u03b2). Since HT is a deductive base, we conclude that\n\u03b1 |\u223c \u03b3 & \u03b3 \u2227 \u00acB1 \u2227 . . . \u2227 \u00acBn \u22a2 \u03b2.\nNow, since v(\u03b3) \u2286 v(\u03b1) \u2229 v(\u03b2), Bi 6\u2208 v(\u03b3) for i = 1, n. It follows that in HT(v(\u03b2)), each Bi is false in every equilibrium model of \u03b3. So each such model M satisfies (\u00acB1\u2227 . . .\u2227\u00acBn). 7 Since each also satisfies \u03b2, we have \u03b3 |\u223ccw \u03b2.\n7. Notice that in this case adding to \u03b3 the sentence (\u00acB1\u2227 . . .\u2227\u00acBn) does not change its set of equilibrium models.\nCase (ii). If \u03b1 has no equilibrium models then the hypothesis is that \u03b1 \u22a2 \u03b2. In that case we simply choose an interpolant \u03b3 for (\u03b1, \u03b2).\nCorollary 1 (|\u223c,\u22a2-Interpolation) Let \u03b1, \u03b2 be formulas such that \u03b1 |\u223ccw \u03b2 and v(\u03b2) \u2286 v(\u03b1). There is a formula \u03b3 such that v(\u03b3) \u2286 v(\u03b1) \u2229 v(\u03b2) and \u03b1 |\u223ccw \u03b3 and \u03b3 \u22a2 \u03b2.\nProof. Immediate from Proposition 7 by the fact that v(\u03b2) \\ v(\u03b1) = \u2205.\nProposition 8 (|\u223c,\u22a2-Interpolation) Let \u03b1, \u03b2 be formulas and set v = v(\u03b1) \u222a v(\u03b2) and v\u2032 = v(\u03b2) \\ v(\u03b1). If \u03b1 |\u223cow \u03b2, there is a formula \u03b3 such that v(\u03b3) \u2286 v(\u03b1) \u2229 v(\u03b2), \u03b1 |\u223c \u03b3, and \u03b3 \u22a2 \u03b2.\nProof. Let \u03b1, \u03b2 and v, v\u2032 be as in the statement of the proposition and suppose that \u03b1 |\u223cow\u03b2. Then \u03b2 holds in all expansions of elements of EMv(\u03b1)(\u03b1) to the language v. Case (i): suppose that \u03b1 is coherent and consider EMv(\u03b1)(\u03b1).\nAgain construct the formulas \u03b4i and the formula \u03b1 \u2032 exactly as in the proof of Lemma 1. Now consider \u03b1\u2032 which defines the set EMv(\u03b1)(\u03b1). Then \u03b2 holds in all expansions of models of \u03b1\u2032 to v. Hence \u03b1\u2032 |= \u03b2 and therefore \u03b1\u2032 \u22a2 \u03b2 We can now apply the interpolation theorem for HT to infer that there is a formula \u03b3 such that \u03b1\u2032 \u22a2 \u03b3 and \u03b3 \u22a2 \u03b2, where v(\u03b3) \u2286 v(\u03b1\u2032) \u2229 v(\u03b2) and hence v(\u03b3) \u2286 v(\u03b1) \u2229 v(\u03b2). Since \u03b1 |\u223cow \u03b1\n\u2032 and HT is a deductive base we conclude that\n\u03b1 |\u223cow \u03b3 & \u03b3 \u22a2 \u03b2.\nCase (ii). If \u03b1 has no equilibrium models, choose \u03b3 as an interpolant for (\u03b1, \u03b2)."}, {"heading": "4. Interpolation in Quantified Equilibrium Logic", "text": "We now turn to first-order logic. Given inferences of the form \u03b1 |\u223c \u03b2, a key element in the proofs of Propositions 7 and 8 is the existence of a formula \u03b1\u2032 that defines the collection EMv(\u03b1)(\u03b1) of equilibrium models. In the propositional case we have seen how the existence of such an \u03b1\u2032 can be established. In the first-order case, on the other hand, such an \u03b1\u2032 need not exist. In other words, EML(\u03b1)(\u03b1) need not be first-order definable for arbitrary \u03b1. This fact is not hard to show. As Ferraris et al. (2007) have pointed out, in the general form of answer set programming where first-order formulas are allowed, and a fortiori in quantified equilibrium logic, the property of transitive closure is expressible. Yet this property is not definable in classical first-order logic and therefore it also cannot be defined in QHTs=.\nIn the usual way we say that a collection K of QHTs=(L) models is (QHT s =) definable if there is an L-sentence, \u03d5, such that M \u2208 K \u21d4 M |= \u03d5. It is easy to see that whenever the class EML(\u03b1)(\u03b1) is first-order definable in QHT s = we do obtain first-order analogs of Propositions 7 and 8. The method of proof is essentially the same as before. For completeness we outline the main steps for the case of (|\u223c, |\u223c)-interpolation.\nProposition 9 (|\u223c, |\u223c-Interpolation) Let \u03b1, \u03b2 be formulas such that the collection of equilibrium models of \u03b1 is QHTs=- definable. Set L = L(\u03b1) \u222a L(\u03b2) and L\n\u2032 = L(\u03b2) \\ L(\u03b1). Let {pi : i = 1, n} be the (finite, possibly empty) set of predicates in L \u2032 and suppose for each i\nthat pi is of arity ki. If \u03b1 |\u223ccw \u03b2, there is a formula \u03b3 such that L(\u03b3) \u2286 L(\u03b1)\u2229L(\u03b2), \u03b1 |\u223c \u03b3, and\n\u03b3 \u2227 \u2227\ni=1,n\n\u2200x\u00acpi(x) |= \u03b2\nHence in particular \u03b3 |\u223ccw \u03b2.\nProof. Assume the hypotheses. Then \u03b2 holds in all equilibrium models of \u03b1 in the language L. We treat just the case where \u03b1 is coherent and has a non-empty collection of equilibrium models, EML(\u03b1)(\u03b1). By assumption this collection is definable by aQHT s =(L(\u03b1))-sentence, \u03b1\u2032, say. Now consider the equilibrium models of \u03b1 in the expanded language L, i.e. the collection EML(\u03b1). By the equilibrium construction we claim that EML(\u03b1) |= \u2200x\u00acpi(x), for all i = 1, n. Since we are now working with the first-order semantics, let us rehearse briefly the argument for this. If it were not true there would be a model \u3008U, T, T \u3009 \u2208 EML(\u03b1), a predicate symbol pi \u2208 L\n\u2032 and some tuple a of elements in the domain of \u3008U, T, T \u3009, such that \u3008U, T, T \u3009 |= pi(a), ie pi(a) \u2208 T . However, since \u03b1 does not refer to the relation pi, the structure \u3008U,H, T \u3009 with H = T \\ pi(a) must also be a model of \u03b1, contradicting that \u3008U, T, T \u3009 is in equilibrium. So EML(\u03b1) |= \u03b1 \u2032 \u2227 \u2227 i=1,n \u2200x\u00acpi(x) and since \u03b1 \u2032 defines EML(\u03b1)(\u03b1) clearly \u03b1 \u2032 \u2227 \u2227 i=1,n \u2200x\u00acpi(x) defines EML(\u03b1).\nNow we proceed as in the propositional case. \u03b1\u2032 \u2227 \u2227\ni=1,n \u2200x\u00acpi(x) \u22a2 \u03b2, so\n\u03b1\u2032 \u22a2 \u2227\ni=1,n\n\u2200x\u00acpi(x) \u2192 \u03b2.\nBy the interpolation theorem for QHTs= there is a formula \u03b3 such that L(\u03b3) \u2286 L(\u03b1)\u2229L(\u03b2), \u03b1\u2032 \u22a2 \u03b3 and \u03b3 \u22a2 \u2227 i=1,n \u2200x\u00acpi(x) \u2192 \u03b2. Consequently we also have\n\u03b1 |\u223c \u03b3 & \u03b3 \u2227 \u2227\ni=1,n\n\u2200x\u00acpi(x) \u22a2 \u03b2\nBy the same token as in the propositional case, we infer that \u03b3 |\u223ccw \u03b2. The case of (|\u223c,\u22a2)-interpolation for |\u223cow is analogous and we state the main property without proof.\nProposition 10 (|\u223c,\u22a2-Interpolation) Let \u03b1, \u03b2 be formulas such that the collection of equilibrium models of \u03b1 is QHTs=- definable. If \u03b1 |\u223cow \u03b2, there is a formula \u03b3 such that L(\u03b3) \u2286 L(\u03b1) \u2229 L(\u03b2), \u03b1 |\u223c \u03b3 and \u03b3 \u22a2 \u03b2."}, {"heading": "5. An Illustration: Interpolation for Safe Formulas", "text": "How restrictive is the definability assumption? Is it often met in practice? Actually in mainstream answer set programming, whose language equilibrium logic captures and extends (see the next section), non-definable classes of answers sets play no significant role. The reason is that for query answering existing solvers rely on grounders that instantiate all or parts of a program before computing the intended models or solutions. The grounding process essentially eliminates variables and reduces the original program to propositional form. In such practical cases, then, the collection of stable or equilibrium models will be definable.\nFor this computational approach to work in general, syntactic restrictions need to be imposed on admissible programs or theories. The most common form of restriction is called safety. For standard types of logic programs based on rules one regards a rule as safe if every variable appearing in rule\u2019s head also appears in its body. For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class. More recently Cabalar, Pearce and Valverde (2009) have generalised both these approaches and suggested a safety concept for arbitrary function-free formulas in equilibrium logic. Since this new concept of safety defines a quite broad class of interpolable formulas, let us review here its main features. In the following section we will mention some other kinds of interpolable formulas that may arise in answer set programming."}, {"heading": "5.1 General Concept of Safety", "text": "For the remainder of this section we assume that all languages are function-free. As usual a sentence is said to be in prenex form if it has the following shape, for some n \u2265 0:\nQ1x1 . . . Qnxn\u03b1\nwhere Qi is \u2200 or \u2203 and \u03b1 is quantifier-free. A sentence is said to be universal if it is in prenex form and all quantifiers are universal. A universal theory is a set of universal sentences. The safety concept is defined for prenex formulas which provide a normal form for QHTs= (Pearce & Valverde, 2005).\nWe first introduce a concept called semi-safety. The main property of semi-safety formulas will be that their equilibrium models only refer to objects from their language. Note that for the remainder of this section we use the fact that negation can be treated as a defined operator, by \u00ac\u03d5 \u2261 \u03d5 \u2192 \u22a5, and do not consider additional semantic clauses for negation.\nDefinition 9 (Semi-safety) A quantifier free formula \u03d5 is semi-safe it is has not nonsemi-safe variable; that is, NSS(\u03d5) = \u2205, where the NSS operator is recursively defined as follows:\n\u2022 If \u03d5 is an atom, NSS(\u03d5) is the set of variables in \u03d5;\n\u2022 NSS(\u03d51 \u2227 \u03d52) = NSS(\u03d51) \u222aNSS(\u03d52);\n\u2022 NSS(\u03d51 \u2228 \u03d52) = NSS(\u03d51) \u222aNSS(\u03d52);\n\u2022 NSS(\u03d51 \u2192 \u03d52) = NSS(\u03d52)r RV(\u03d51),\nwhere operator RV computes the restricted variables as follows:\n\u2022 For atomic \u03d5, if \u03d5 is an equality between two variables then RV(\u03d5) = \u2205; otherwise, RV(\u03d5) is the set of all variables occurring in \u03d5;\n\u2022 RV(\u22a5) = \u2205;\n\u2022 RV(\u03d51 \u2227 \u03d52) = RV(\u03d51) \u222a RV(\u03d52);\n\u2022 RV(\u03d51 \u2228 \u03d52) = RV(\u03d51) \u2229 RV(\u03d52);\n\u2022 RV(\u03d51 \u2192 \u03d52) = \u2205.\nThis definition of semi-safe formulas was introduced by Cabalar, Pearce and Valverde (2009) and generalises the former definition of Lee, Lifschitz and Palla (2008b). In short, a variable x is semi-safe in \u03d5 if every occurrence is inside some subformula \u03b1 \u2192 \u03b2 such that, either x \u2208 RV(\u03b1) or x is semi-safe in \u03b2.\nSome examples of semi-safe formulas are, for instance:\n\u00acp(x) \u2192 (q(x) \u2192 r(x))\np(x) \u2228 q \u2192 \u00acr(x) (6)\nNote how in (6), x is not restricted in p(x) \u2228 q but the consequent \u00acr(x) is semi-safe and thus the formula itself. On the contrary, the following formulas are not semi-safe:\np(x) \u2228 q \u2192 r(x)\n\u00ac\u00acp(x) \u2227 \u00acr(x) \u2192 q(x)\nThe following results set the previously referred property for semi-safe formulas: their equilibrium models only include objects from the language.\nProposition 11 (Cabalar et al., 2009) If \u03d5 is function free, semi-safe, and \u3008(D, I), T, T \u3009 |= \u03d5, then \u3008(D, I), T |C , T \u3009 |= \u03d5.\nTheorem 2 (Cabalar et al., 2009) If \u03d5 is function free, semi-safe, and \u3008(D, I), T, T \u3009 is an equilibrium model of \u03d5, then T |C = T .\nThe equilibrium models of semi-safe formulas only refer to objects from the language, however a model could be or not in equilibrium depending of the considered domain. To guarantee the independence from the domain, we need an additional property to the semisafety. Specifically, we need to analyse whether the unnamed elements could modify an interpretation of the formula. To do that, we use the assignments of the Kleene\u2019s threevalued logic; the three-valued interpretation \u03bd : At \u2192 {0, 1/2, 1}, are extended to evaluate arbitrary formulas \u03bd(\u03d5) as follows:\n\u03bd(\u03d5 \u2227 \u03c8) = min(\u03bd(\u03d5), \u03bd(\u03c8)) \u03bd(\u22a5) = 0 \u03bd(\u03d5 \u2228 \u03c8) = max(\u03bd(\u03d5), \u03bd(\u03c8)) \u03bd(\u03d5\u2192 \u03c8) = max(1\u2212 \u03bd(\u03d5), \u03bd(\u03c8))\nFor every variable x, we are going to use the Kleene\u2019s interpretations \u03bdx, defined as follows: \u03bdx(\u03b1) = 0 if x occurs in the atom \u03b1 and \u03bdx(\u03b1) = 1/2 otherwise. Intuitively, \u03bdx(\u03d5) fixes all atoms containing the variable x to 0 (falsity) leaving all the rest undefined and then evaluates \u03d5 using Kleene\u2019s three-valued operators, that is nothing else but exploiting the defined values 1 (true) and 0 (false) as much as possible.\nAn occurrence of a variable x in Qx \u03d5 is weakly-restricted if it occurs in a subformula \u03c8 of \u03d5 such that:\n\u2022 Q = \u2200, \u03c8 is positive8 and \u03bdx(\u03c8) = 1\n\u2022 Q = \u2200, \u03c8 is negative and \u03bdx(\u03c8) = 0\n\u2022 Q = \u2203, \u03c8 is positive and \u03bdx(\u03c8) = 0\n\u2022 Q = \u2203, \u03c8 is negative and \u03bdx(\u03c8) = 1\nIn all cases, we further say that \u03c8 makes the ocurrence weakly restricted in \u03d5. This property is added to the semi-safety condition to complete the definition of safety.\nDefinition 10 A semi-safe sentence is said to be safe if all its positive occurrences of universally quantified variables, and all its negative occurrences of existentially quantified variables are weakly restricted.\nFor instance, the formula \u03d5 = \u2200x(\u00acq(x) \u2192 (r \u2228 \u00acp(x))) is safe: the occurrence of x in p(x) is negative, whereas the occurrence in q(x) is inside a positive subformula, \u03d5 itself, for which x is weakly-restricted, since \u03bdx(\u03d5) = \u00ac0 \u2192 (1/2\u2228\u00ac0) = 1. Another example of a safe formula is \u2200x((\u00ac\u00acp(x) \u2227 q(x)) \u2192 r).\nProposition 12 (Cabalar et al., 2009) If \u03d5 is function free, safe, and prenex formula, then: \u3008(D, I), T, T \u3009 is an equilibrium model of \u03d5 if and only if it is an equilibrium model of GrC(\u03d5) (the grounding of \u03d5 over C)."}, {"heading": "5.2 Interpolation", "text": "On the basis of Proposition 12 we could already establish interpolation theorems for safe formulas in prenex form, essentially by replacing such formulas by their ground versions and working in propositional logic. However, we can also apply Propositions 9 and 10 directly by noting the property shown by Cabalar et al. (2009) that safe prenex formulas have definable classes of equilibrium models.\nTheorem 3 (interpolation for safe formulas) Safe formulas in prenex form have QHTs=-definable classes of equilibrium models. Therefore for such formulas (|\u223c, |\u223c)-interpolation for |\u223ccw inference holds as in Proposition 9 and (|\u223c,\u22a2)-interpolation holds for |\u223cow inference as in Proposition 10."}, {"heading": "6. Interpolation in Answer Set Semantics", "text": "Answer set programming (ASP) has become an established form of declarative, logic-based programming and its basic ideas are now well-known. For a textbook treatment the reader is referred to Baral\u2019s book (2003). As is also well-known, the origins of ASP lie in the stable model and answer set semantics for logic programs introduced by Gelfond and Lifschitz (1988, 1990, 1991). This semantics made use of a fixpoint condition involving a certain \u2018reduct\u2019 operator. Subsequent extensions of the concept to cover more general kinds of rules\n8. Recall that a subexpression of a formula is said to be positive in it if the number of implications that contain that subexpression in the antecedent is even, and negative if it is odd. Here we also consider that \u00ac\u03d5 is defined as \u03d5 \u2192 \u22a5.\nalso relied on a reduct operator of similar sort. For the original definitions, the reader is referred to the various papers cited.\nThe correspondence between answer set semantics and equilibrium logic is also wellestablished and has been discussed in many publications, beginning with Pearce (1997), who first showed how the answer sets of disjunctive programs can be regarded as equilibrium models (Lifschitz et al., 2001, 2007; Ferraris et al., 2007; Pearce & Valverde, 2005, 2006, 2008). For our purposes it will suffice to recall just two important syntactic classes of programs and the main features of the correspondence with equilibrium logic.\nAt one extreme we have ground, disjunctive logic programs; we treat them here without strong negation, so their answer sets are simply collections of atoms. These programs consist of sets of ground rules of the form\nK1 \u2228 . . . \u2228Kk \u2190 L1, . . . Lm, notLm+1, . . . , notLn (7)\nwhere the Li and Kj are atoms. The \u2018translation\u2019 from the syntax of programs to HT propositional formulas is the trivial one, viz. (7) corresponds to the HT sentence\nL1 \u2227 . . . \u2227 Lm \u2227 \u00acLm+1 \u2227 . . . \u2227 \u00acLn \u2192 K1 \u2228 . . . \u2228Kk (8)\nUnder this translation the correspondence between the answer sets and the equilibrium models of ground disjunctive programs is also the direct one:\nProposition 13 Let \u03a0 be a disjunctive logic program. Then \u3008T, T \u3009 is an equilibrium model of \u03a0 if and only if T is an answer set of \u03a0.\nThis was first shown by Pearce (1997) but the basic equivalence was later shown to hold for more general classes of programs by Pearce, P. de Guzman and Valverde (2000).\nIt is also common to treat non-ground rules of form (7) where variables may appear. These variables are thought of as being universally quantified, so the corresponding translation into a logical formula would simply be the universal closure of formula (8).\nAt the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas. In this case the property of being a stable model is defined syntactically via a second-order condition that resembles parallel circumscription. However they also showed that the new notion of stable model is equivalent to that of equilibrium model as defined here for first-order languages. In a sequel to this paper, Lee, Lifschitz and Palla (2008a) have applied the new definition and made the following refinements. The stable models of a formula are defined as Ferraris et al. (2007) were, while the answer sets of a formula are those Herbrand models of the formula that are stable in the sense of Ferraris et al. Using this new terminology, it follows that in general stable models and equilibrium models coincide, while answer sets are equivalent to SNA-QHT models that are equilibrium models.\nIn between these two extremes many syntactically different kinds of programs have been considered and several variations in the concept of answer set have been proposed. However all the main varieties display a similar correspondence to equilibrium logic. It is merely necessary in some cases to restrict attention to specific kinds of equilibrium models, e.g. Herbrand models, UNA-models or SNA-models. It is important to notice also that this correspondence extends to many of the additional constructs that have been introduced\nin ASP, such as cardinality and weight constraints and even general forms of aggregates (Lee & Meng, 2009). All these can be accommodated in equilibrium logic by translation into logical formulas.\nIn ASP the main emphasis is on finding answer sets and this is what most answer set solvers compute. Less attention is placed on implementing a non-monotonic inference relation or a query answering mechanism. However there is a standard, skeptical concept of inference or entailment associated with answer set semantics. This notion of entailment or consequence for programs under the answer set semantics is that a query Q is entailed by a program \u03a0 if Q is true in all answer sets of \u03a0 (Balduccini, Gelfond, & Nogueira, 2000). Let us denote this entailment or consequence relation by |\u223cAS . Evidently atoms are true in an answer set if and only if they belong to it. Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000). Sometimes, queries of the form not a, or in logical notation \u00aca, are not explicitly dealt with (Balduccini et al., 2000). However it seems to be in keeping with the semantics to regard a formula of form not \u03b1 or \u00ac\u03b1 to be true in an answer set if and only if \u03b1 is not true. Another way to express this would be to say that an answer set satisfies \u00ac\u03b1 if it does not violate the constraint {\u2190 \u03b1}, understanding constraint violation as Lifschitz, Tang and Turner (1999).9 In this way we would say that \u03a0 |\u223cAS \u00acA if no answer set of \u03a0 contains A. Similarly, the interpretation of queries containing quantifiers in answer set semantics should also conform to that of equilibrium logic, taking account of any specific restrictions, such as Herbrand models, that might be imposed.\nWe can therefore transfer interpolation properties from equilibrium logic to answer set semantics and ASP. It remains to consider whether |\u223cAS is best identified with the closed world version of inference, |\u223ccw, or the more open world version, |\u223cow. Again, since ASP solvers do not generally implement inference engines, the difference is largely a theoretical one. In traditional logic programming, however, a query that does not belong to the language of the program is usually answered false. It also seems quite natural in an ASP context that, given a program \u03a0 and a query Q, one should consider the stable models of \u03a0 in the language L(\u03a0)\u222aL(Q) even if this is a proper extension of the language of \u03a0.10 So in general |\u223ccw seems a natural choice for answer set inference. On the other hand, there are contexts where answer set semantics is used in a more open world setting, for example in the setting of hybrid knowledge bases (Rosati, 2005) where non-monotonic rules are combined with ontologies formalised in description logics. For such systems a semantics in terms of equilibrium logic was provided by de Bruijn, Pearce, Polleres and Valverde (2007). Here an entailment relation in the style of |\u223cow might sometimes be more appropriate.\nIn general answer set semantics is defined only for coherent programs or theories. For these, by identifying |\u223cAS with |\u223ccw, we can apply Proposition 9 directly:\nCorollary 2 For coherent formulas \u03b1, (|\u223c, |\u223c)-interpolation in the form of Proposition 9 holds for entailment |\u223cAS in answer set semantics.\n9. In logical terms this constraint would be written \u03b1 \u2192 \u22a5. 10. Notice that by Proposition 12 if a program consists of safe formulas, an atomic query q(a) is automatically\nfalse if a does not belong to the language of the program (even if q does), simply because grounding with the program constants is sufficient to generate all answer sets."}, {"heading": "7. An Application of Interpolation", "text": "The Interpolation property has been applied in various areas of computer science, notably in software specification (Bicarregui et al., 2001) and in the construction of formal ontologies (Lutz & Wolter, 2010). In both areas it is relevant to modularity issues. Here we discuss a simple application related to a concept described by Lutz and Wolter that we can adapt to the case of nonmonotonic logic programs.\nOne way to compare two theories is via their nonmonotonic consequence relations. When two theories produce the same answers for a given query language, we can call them inseparable; this term is used in mathematical logic and also in the study of formal ontologies (Lutz & Wolter, 2010).\nLet us say therefore that \u03a01 and \u03a02 are L-inseparable if for any \u03d5 such that V (\u03d5) \u2286 L, \u03a01 |\u223c \u03d5\u21d4 \u03a02 |\u223c \u03d5.\nProposition 14 Let \u03a01 and \u03a02 be L-inseparable theories such that V (\u03a01) = V (\u03a02) = V , say. Then for any L\u2032 \u2283 L such that V \u2229 L\u2032 \u2286 L, \u03a01 and \u03a02 are L \u2032-inseparable.\nProof. Assume that \u03a01 and \u03a02 are L-inseparable and that L \u2032 is an extension of L such that V \u2229 L\u2032 \u2286 L. Suppose \u03a01 |\u223c \u03d5, where V (\u03d5) = L \u2032. Suppose L\u2032 \\ V = {B1, . . . Bn}. By Proposition 7 there is an interpolant \u03b3 for (\u03a01, \u03d5) such that \u03b3 |= \u00acB1\u2227. . .\u2227\u00acBn \u2192 \u03d5. Since \u03a01 |\u223c \u03b3 and V (\u03b3) \u2286 L, by L-inseparability we have \u03a02 |\u223c \u03b3. By right absorption therefore \u03a02 |\u223c \u00acB1 \u2227 . . . \u2227 \u00acBn \u2192 \u03d5. However it is clear that B1, . . . Bn are false in all equilibrium models of \u03a02, so \u03a02 |\u223c\u03d5. Repeating this argument with \u03a01 and \u03a02 interchanged shows that the theories are L\u2032-inseparable.\nThe above proof is similar to the argument given by Lutz and Wolter (2010) for Theorem 7 of that paper, applied to TBoxes in description logics. The property described is called there robustness under signature extensions. Notice however that, since |\u223c is not in general transitive we cannot immediately infer from \u03a02 |\u223c \u03b3 and \u03b3 |\u223c \u03d5 that also \u03a02 |\u223c \u03d5. This highlights the added strength of using explicitly the set {B1, . . . Bn} and the property that HT forms a deductive basis for |\u223c.\nIn the study of modularity and logical relations between programs in ASP, it is more common to compare their sets of answer sets rather than their consequence classes. However it turns out that the notion of inseparability is very close to a concept that has already been studied in ASP. Two theories or programs are said to be projectively equivalent if the projections of their answer sets onto a common sublanguage agree (Eiter, Tompits, & Woltran, 2005). Formally, let \u03a01,\u03a02 be theories and L be a signature such that L \u2286 V (\u03a01) \u2229 V (\u03a02). Then \u03a01 and \u03a02 are said to be projectively equivalent relative to L if E(\u03a01)\u21beL = E(\u03a02)\u21beL, where for any class of models K, K\u21beL = {M\u21beL : M \u2208 K}.\nProposition 15 Let \u03a01,\u03a02 be theories and L a signature such that L \u2286 V (\u03a01) \u2229 V (\u03a02). \u03a01 and \u03a02 are projectively equivalent relative to L if and only if they are L-inseparable.\nIn other words these two concepts agree whenever L is a common sublanguage of \u03a01,\u03a02. The main advantage of L-inseparability is that it seems the more natural one to use if we want to consider signatures that extend the language of either program or theory."}, {"heading": "8. Uniform Interpolation and Forgetting", "text": "A stronger form of interpolation known as uniform interpolation is also important for certain applications in computer science (Konev et al., 2009). As usual, given \u03b1, \u03b2 with \u03b1 \u22a2 \u03b2, we are interested in interpolants \u03b3 such that\n\u03b1 \u22a2 \u03b3 & \u03b3 \u22a2 \u03b2 (9)\nwhere \u03b3 contains only predicate and constant symbols that belong to both \u03b1 and \u03b2. The difference now is that \u03b3 is said to be a uniform interpolant if (9) holds for any \u03b2 in the same signature such that \u03b1 \u22a2 \u03b2. A logic is said to have the uniform interpolation property if such uniform interpolants exist for all \u03b1, \u03b2.\nIn classical propositional logic, the uniform interpolation holds, however it fails in first order classical logic and in many non-classical logics. It may hold when certain restrictions are placed on the theory language in which \u03b1 is formulated and on the query language containing \u03b2. For example it has been shown to hold for some description logics (Kontchakov et al., 2008) where such syntactic restrictions apply. Even in ASP it turns out that a form of uniform interpolation holds for a very restricted query language, essentially one that allows just instance retrieval. We can show this by using some known results in ASP about the concept of forgetting (Eiter & Wang, 2008) that is quite closely related to interpolation.\nVariable forgetting, as studied by Eiter and Wang (2008), is concerned with the following problem. Given a disjunctive logic program \u03a0 and a certain atom a occurring in \u03a0, construct a new program, to be denoted by forget(\u03a0, a), that does not contain a but whose answer sets are in other respects as close as possible to those of \u03a0. For the precise notion of closeness the reader is referred to paper of Eiter and Wang, however some consequences will be evident shortly. Eiter and Wang define forget(\u03a0, a) (as a generic term), show that such programs exist whenever \u03a0 is coherent, and provide different algorithms to compute such programs.\nGiven coherent \u03a0 and a in \u03a0, the results forget(\u03a0, a), of forgetting about a in \u03a0 may be different but are always answer set equivalent. Moreover for our purposes they satisfy the following key property, where \u03a0 is coherent, a, b are distinct atoms in \u03a0 and as usual |\u223c denotes nonmonotonic consequence,\n\u03a0 |\u223c b \u21d4 forget(\u03a0, a) |\u223c b. (10)\nshowing that indeed the answer sets of \u03a0 and forget(\u03a0, a) are closely related. To establish a version of uniform interpolation for the case of disjunctive programs and simple, atomic queries, we need to show that we can always find a \u03a0\u2032 = forget(\u03a0, a) such that \u03a0 |\u223c\u03a0\u2032. For this we can examine the first algorithm of Eiter and Wang for computing forget(\u03a0, a); this is also the simplest of the three algorithms presented. Let \u03a0 be a coherent program with rules of form (7) that we write as formulas of form (8) and let a be an atom in \u03a0. The method for constructing a \u03a0\u2032 = forget(\u03a0, a) is as follows.\n1. Compute the equilibrium models E(\u03a0).\n2. Let E\u2032 be the result of removing a from each M \u2208 E(\u03a0).\n3. Remove from E\u2032 any model that is non-minimal to form E\u2032\u2032(= {A1, . . . , Am}, say).\n4. Construct a program \u03a0\u2032 whose answer sets are precisely {A1, . . . , Am} as follows:\n\u2022 for each Ai, set \u03a0i = {\u00acAi \u2192 a \u2032 : a\u2032 \u2208 Ai}, where Ai = V (\u03a0) \\ Ai. \u2022 Set \u03a0\u2032 = \u03a01 \u222a . . . \u222a\u03a0m.\nWe can now verify the desired property. Let L be the simple query language composed of conjunctions of literals.\nProposition 16 In equilibrium logic (or answer set programming) uniform interpolation holds for (coherent) disjunctive programs and queries in L(V (\u03a0)).\nProof. To prove the claim we shall show the following. Let \u03a0 be a coherent disjunctive program and let L = L(V ) for some V \u2286 V (\u03a0). Then there is a program \u03a0\u2032 such that V (\u03a0\u2032) = V and for any \u03d5 \u2208 L,\n\u03a0 |\u223c \u03d5\u21d2 (\u03a0 |\u223c\u03a0\u2032 & \u03a0\u2032 |\u223c \u03d5)\nTo begin, let \u03a0 and \u03d5 be as above with \u03a0 |\u223c\u03d5. Let X = {a1, . . . , an} = V (\u03a0) \\V . Then we choose \u03a0\u2032 to be the result of forgetting about X in \u03a0, defined by Eiter and Wang (2008) as follows:\nforget(\u03a0,X) := forget(forget(forget(\u03a0, a1), a2), . . . , an),\nand it is shown there that the order of the atoms in X does not matter. Now we know by (10) that for any atom a \u2208 V and any i = 1, n,\n\u03a0 |\u223c a\u21d4 forget(\u03a0, ai) |\u223c a, (11)\ntherefore \u03a0 |\u223c a\u21d2 forget(\u03a0,X) |\u223c a. (12)\nLet \u03a0\u2032 be forget(\u03a0,X) as determined by algorithm 1 of Eiter and Wang (2008) described above. It is easy to see by (11) and the semantics of |\u223c that (12) continues to hold where a is replaced by a negated atom \u00acb and therefore also by any conjunction of literals since a conjunction is entailed only if each element holds in every equilibrium model.11 So it remains to show that \u03a0 |\u223c \u03a0\u2032. Again, it will suffice to show this entailment for one member of the sequence forget(\u03a0, ai) and since the order is irrelevant wlog we can choose the first element forget(\u03a0, a1) and show that \u03a0 |\u223c forget(\u03a0, a1). We compute the programs \u03a01, . . . ,\u03a0m as in the algorithm. Then we need to check that \u03a0 |\u223c \u03a0i for any i = 1, n, i.e. that for each M \u2208 E(\u03a0), M |= {\u00acAi \u2192 a\n\u2032 : a\u2032 \u2208 Ai}. Consider M \u2208 E(\u03a0) where M = \u3008T, T \u3009. We distinguish two cases. (i) Ai \u2286 T . Then M |= a\u2032 for each a\u2032 \u2208 Ai. It follows that M |= \u00acAi \u2192 a \u2032 for each a\u2032 \u2208 Ai and so M |= {\u00acAi \u2192 a \u2032 : a\u2032 \u2208 Ai}. Case (ii) Ai 6\u2286 T . Then T and Ai are incomparable. In particular we cannot have T \u2282 Ai by the minimality property of Ai obtained in step 3. Hence T \u2229Ai 6= \u2205. Choose a \u2032\u2032 \u2208 T \u2229Ai. Then M |= a \u2032\u2032, so M 6|= \u00aca\u2032\u2032 and hence M 6|= \u00acAi. Consequently, for any a\u2032, M |= \u00acAi \u2192 a \u2032 and so M |= {\u00acAi \u2192 a\n\u2032 : a\u2032 \u2208 Ai}. It follows that for any i, \u03a0 |\u223c\u03a0i and so by construction \u03a0 |\u223c\u03a0 \u2032, which establishes the proposition.\n11. As Eiter and Wang (2008) point out, if an atom b is true in some answer set of forget(\u03a0, a), then it must also be true in some answer set of \u03a0, showing that (12) holds for literals."}, {"heading": "8.1 Extending the Query Language", "text": "If we establish uniform interpolation in ASP using the method of forgetting, as defined by Eiter and Wang (2008), it seems clear that we cannot extend in a non-trivial way the expressive power of the query language L. Since the method of forgetting a in \u03a0 removes non-minimal sets from E(\u03a0) (once a has been removed), an atom b might be true in some equilibrium model of \u03a0 but not in any equilibrium model of forget(\u03a0, a). Hence we might have a disjunction, say a \u2228 b, derivable from \u03a0 but not from forget(\u03a0, a). Likewise, if we consider programs with variables in a first-order setting, we cannot in general extend L to include existential queries.\nOn the other hand, the property of uniform interpolation certainly holds for any L(V ) even without the condition that V \u2286 V (\u03a0). Suppose that \u03a0 |\u223c \u03d5 where V (\u03d5) \\ V (\u03a0) 6= \u2205, say V (\u03d5) \\ V (\u03a0) = {b1, . . . , bk}. Then b1, . . . , bk are false in all equilibrium models of \u03a0. Trivially, if b is not in V (\u03a0) we can regard the result of forgetting about b in \u03a0 as just \u03a0. So we can repeat the proof of Proposition 16, but now setting X = {V (\u03a0) \\ V } \u222a {V \\ V (\u03a0)}. All the relevant properties will continue to hold.\nAn interesting open question is whether we can extend the theory language to include more general kinds of program rules such as those allowing negation in the head. Accommodating these kinds of formulas would constitute an important generalisation since they amount to a normal form in equilibrium logic. However, the answer sets of such programs do not satisfy the minimality property that holds for the answer sets of disjunctive programs, so it is clear that the definition of forgetting would need to be appropriately modified - a task that we do not attempt here."}, {"heading": "9. Literature and Related Work", "text": "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Schu\u0308tte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation. A modern, comprehensive treatment of interpolation in modal and intuitionistic logics can be found in the monograph of Gabbay and Maksimova (2005).\nIn non-monotonic logics, interpolation has received little attention. A notable exception is an article (Amir, 2002) establishing some interpolation properties for circumscription and default logic. By the well-known relation between the answer sets of disjunctive programs and the extensions of corresponding default theories, he also derives a form of interpolation for ASP. With regard to answer set semantics, the approach of Amir is quite different from ours. Since it is founded on an analysis of default logic, it uses classical logic as an underlying base. So Amir\u2019s version of interpolation is a form of (3) where L is classical logic; there is no requirement that \u22a2L form a well-behaved sublogic of |\u223c, e.g. a deductive base. As Amir remarks, one cannot deduce in general from property (4) that \u03b1|\u223c\u03b2. However if L is classical logic one cannot even deduce \u03b1 |\u223c \u03b2 from (3). More generally, there is no counterpart to our Proposition 1 in this case. Another difference with respect to our approach is that Amir does not discuss the nature of the |\u223c relation for ASP in detail, in particular how to understand \u03a0 |\u223c \u03d5 in case \u03d5 contains atoms not present in the program \u03a0. In fact, if we interpret |\u223cAS as in Section 6 above, it is easy to refute (|\u223c,\u22a2L)-interpolation where L is classical logic. Let \u03a0 be the program B \u2190 \u00acA and q the query B \u2227 \u00acC. Then clearly\n\u03a0 |\u223cAS q, but there is no formula in the vocabulary B that would classically entail \u00acC. Under any interpretation of answer set inference such that atoms not in the program are regarded as false, (|\u223c,\u22a2L)-interpolation would be refuted."}, {"heading": "10. Conclusions", "text": "We have discussed two kinds of interpolation properties for non-monotonic inference relations and shown that these properties hold in turn for the two different inference relations that we can associate with propositional equilibrium logic. In each case we use the fact that the collection of equilibrium models is definable in the logic HT of here-and-there and that this logic possesses the usual form of interpolation. One of the forms of inference studied seems to be in many cases an appropriate concept to associate with answer set programming, although in general ASP systems are not tailored to query answering or deduction. Using results of Eiter and Wang (2008) about variable forgetting in ASP, we could also show how the property of uniform interpolation holds for disjunctive programs and a restricted query language.\nWe have also discussed the interpolation property for first-order equilibrium logic based on a quantified version QHT of the logic of here-and-there, obtaining analogous results as for the propositional case whenever the collection of equilibrium models is definable. These positive results transfer to answer set programming under the assumption usually made in ASP systems that programs are safe and therefore have definable collections of answer sets. As we saw, the notion of safety can be quite generally defined for theories and is not limited to normal or disjunctive programs."}, {"heading": "Acknowledgments", "text": "David Pearce is partially supported by MEC projects TIN2009-14562-C05-02 and CSD200700022. Agust\u0301\u0131n Valverde is partially supported by MEC project TIN2009-14562-C05-01, and Junta de Andalucia projects P09-FQM-05233 and TIC-115. The authors are grateful to the anonymous referees for helpful comments."}], "references": [{"title": "Interpolation theorems for nonmonotonic reasoning systems", "author": ["E. Amir"], "venue": "In Proceedings of NMR\u201902,", "citeRegEx": "Amir,? \\Q2002\\E", "shortCiteRegEx": "Amir", "year": 2002}, {"title": "A-prolog as a tool for declarative programming", "author": ["M. Balduccini", "M. Gelfond", "M. Nogueira"], "venue": "In Proc. of SEKE", "citeRegEx": "Balduccini et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Balduccini et al\\.", "year": 2000}, {"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": "Cambridge University Press.", "citeRegEx": "Baral,? 2003", "shortCiteRegEx": "Baral", "year": 2003}, {"title": "Interpolation in practical formal development", "author": ["J. Bicarregui", "T. Dimitrakos", "D.M. Gabbay", "T.S.E. Maibaum"], "venue": "Logic Journal of the IGPL,", "citeRegEx": "Bicarregui et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Bicarregui et al\\.", "year": 2001}, {"title": "Normal form nested programs", "author": ["A. Bria", "W. Faber", "N. Leone"], "venue": "Proc. of JELIA\u201908,", "citeRegEx": "Bria et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Bria et al\\.", "year": 2008}, {"title": "A revised concept of safety for general answer set programs", "author": ["P. Cabalar", "D. Pearce", "A. Valverde"], "venue": "Proc. of LPNMR\u201909,", "citeRegEx": "Cabalar et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Cabalar et al\\.", "year": 2009}, {"title": "Linear reasoning", "author": ["W. Craig"], "venue": "a new form of the herbrand-gentzen theorem.. J. Symb. Logic, 22, 250\u2013268.", "citeRegEx": "Craig,? 1957", "shortCiteRegEx": "Craig", "year": 1957}, {"title": "Quantified equilibrium logic and hybrid rules", "author": ["J. de Bruijn", "D. Pearce", "A. Polleres", "A. Valverde"], "venue": "Proc. of RR\u201907,", "citeRegEx": "Bruijn et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bruijn et al\\.", "year": 2007}, {"title": "Logical support for modularisation", "author": ["R. Diaconescu", "J. Goguen", "P. Stefaneas"], "venue": "In Logical Environments,", "citeRegEx": "Diaconescu et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Diaconescu et al\\.", "year": 1993}, {"title": "Deductive bases of nonmonononic inference operations", "author": ["J. Dietrich"], "venue": "Ntz report, University of Leipzig.", "citeRegEx": "Dietrich,? 1994", "shortCiteRegEx": "Dietrich", "year": 1994}, {"title": "On solution correspondences in answer-set programming", "author": ["T. Eiter", "H. Tompits", "S. Woltran"], "venue": "Proc. of IJCAI\u201905,", "citeRegEx": "Eiter et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2005}, {"title": "Semantic forgetting in answer set programming", "author": ["T. Eiter", "K. Wang"], "venue": "Artificial Intelligence,", "citeRegEx": "Eiter and Wang,? \\Q2008\\E", "shortCiteRegEx": "Eiter and Wang", "year": 2008}, {"title": "Logic programs with propositional connectives and aggregates", "author": ["P. Ferraris"], "venue": "CoRR, abs/0812.1462.", "citeRegEx": "Ferraris,? 2008", "shortCiteRegEx": "Ferraris", "year": 2008}, {"title": "A new perspective on stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Proc. of IJCAI\u201907,", "citeRegEx": "Ferraris et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2007}, {"title": "Interpolation and Definability: Modal and Intuitionistic Logic", "author": ["D.M. Gabbay", "L. Maksimova"], "venue": null, "citeRegEx": "Gabbay and Maksimova,? \\Q2005\\E", "shortCiteRegEx": "Gabbay and Maksimova", "year": 2005}, {"title": "The well-founded semantics for general logic programs", "author": ["A.V. Gelder", "K.A. Ross", "J.S. Schlipf"], "venue": "Journal of ACM,", "citeRegEx": "Gelder et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proc. of ICLP\u201988,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Logic programs with classical negation", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proc. of ICLP\u201990,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1990\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1990}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1991\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1991}, {"title": "Forgetting and uniform interpolation in largescale description logic terminologies", "author": ["B. Konev", "D. Walther", "F. Wolter"], "venue": "Proc. of IJCAI\u201909,", "citeRegEx": "Konev et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Konev et al\\.", "year": 2009}, {"title": "Can you tell the difference between dl-lite ontologies", "author": ["R. Kontchakov", "F. Wolter", "M. Zakharyaschev"], "venue": "Principles of Knowledge Representation and Reasoning: Proc. of KR\u201908,", "citeRegEx": "Kontchakov et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2008}, {"title": "Negation in logic programming", "author": ["K. Kunen"], "venue": "Journal of Logic Programming, 4 (4), 289\u2013308.", "citeRegEx": "Kunen,? 1987", "shortCiteRegEx": "Kunen", "year": 1987}, {"title": "A reductive semantics for counting and choice in answer set programming", "author": ["J. Lee", "V. Lifschitz", "R. Palla"], "venue": "Proc. of AAAI\u201908,", "citeRegEx": "Lee et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2008}, {"title": "Safe formulas in the general theory of stable models (preliminary report)", "author": ["J. Lee", "V. Lifschitz", "R. Palla"], "venue": "Proc. of ICLP\u201908,", "citeRegEx": "Lee et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2008}, {"title": "On reductive semantics of aggregates in answer set programming", "author": ["J. Lee", "Y. Meng"], "venue": "Proc. of LPNMR\u201909,", "citeRegEx": "Lee and Meng,? \\Q2009\\E", "shortCiteRegEx": "Lee and Meng", "year": 2009}, {"title": "Strongly equivalent logic programs", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Lifschitz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "A characterization of strong equivalence for logic programs with variables", "author": ["V. Lifschitz", "D. Pearce", "A. Valverde"], "venue": "Proc. of LPNMR\u201907,", "citeRegEx": "Lifschitz et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2007}, {"title": "Nested expressions in logic programs", "author": ["V. Lifschitz", "L.R. Tang", "H. Turner"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Lifschitz et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 1999}, {"title": "Deciding inseparability and conservative extensions in the description logic el", "author": ["C. Lutz", "F. Wolter"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "Lutz and Wolter,? \\Q2010\\E", "shortCiteRegEx": "Lutz and Wolter", "year": 2010}, {"title": "Equivalences of logic programs", "author": ["M.J. Maher"], "venue": "Foundations of Deductive Databases and Logic Programming., pp. 627\u2013658. Morgan Kaufmann.", "citeRegEx": "Maher,? 1988", "shortCiteRegEx": "Maher", "year": 1988}, {"title": "General patterns in nonmonotonic reasoning, pp", "author": ["D. Makinson"], "venue": "35\u2013110. Oxford University Press, Inc.", "citeRegEx": "Makinson,? 1994", "shortCiteRegEx": "Makinson", "year": 1994}, {"title": "Interpolation in superintuitionistic predicate logics with equality", "author": ["L. Maksimova"], "venue": "Algebra and Logic, 36, 543\u2013561.", "citeRegEx": "Maksimova,? 1997", "shortCiteRegEx": "Maksimova", "year": 1997}, {"title": "Interpolation in superintuitionistic and modal predicate logics with equality", "author": ["L. Maksimova"], "venue": "M.Kracht, de Rijke, M., Wansing, H., & Zakharyaschev, M. (Eds.), Advances in Modal Logic, Vol. I, pp. 133\u2013141. CSLI Publications.", "citeRegEx": "Maksimova,? 1998", "shortCiteRegEx": "Maksimova", "year": 1998}, {"title": "Craig\u2019s interpolation theorem and amalgamable varieties", "author": ["L. Maksimova"], "venue": "Doklady Akademii Nauk SSSR, 237 (6), 1281\u20131284.", "citeRegEx": "Maksimova,? 1977", "shortCiteRegEx": "Maksimova", "year": 1977}, {"title": "Applications of craig interpolants in model checking", "author": ["K.L. McMillan"], "venue": "Halbwachs, N., & Zuck, L. D. (Eds.), Proc. of TACAS\u201905, Vol. 3440 of LNCS, pp. 1\u201312. Springer.", "citeRegEx": "McMillan,? 2005", "shortCiteRegEx": "McMillan", "year": 2005}, {"title": "Model extension theorem and craig\u2019s interpolation theorem for intermediate predicate logics", "author": ["H. Ono"], "venue": "Reports on Mathematical Logic, 15, 41\u201358.", "citeRegEx": "Ono,? 1983", "shortCiteRegEx": "Ono", "year": 1983}, {"title": "A new logical characterization of stable models and answer sets", "author": ["D. Pearce"], "venue": "Dix, J., Pereira, L. M., & Przymusinski, T. C. (Eds.), Proc. of NMELP\u201996, Vol. 1216 of LNCS, pp. 57\u201370. Springer.", "citeRegEx": "Pearce,? 1997", "shortCiteRegEx": "Pearce", "year": 1997}, {"title": "Equilibrium logic", "author": ["D. Pearce"], "venue": "Annals of Mathematics and Artificial Intelligence, 47 (1-2), 3\u201341.", "citeRegEx": "Pearce,? 2006", "shortCiteRegEx": "Pearce", "year": 2006}, {"title": "Computing equilibrium models using signed formulas", "author": ["D. Pearce", "I.P. de Guzm\u00e1n", "A. Valverde"], "venue": "In Proc. of CL2000,", "citeRegEx": "Pearce et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Pearce et al\\.", "year": 2000}, {"title": "A first order nonmonotonic extension of constructive logic", "author": ["D. Pearce", "A. Valverde"], "venue": "Studia Logica,", "citeRegEx": "Pearce and Valverde,? \\Q2005\\E", "shortCiteRegEx": "Pearce and Valverde", "year": 2005}, {"title": "Quantified equilibrium logic", "author": ["D. Pearce", "A. Valverde"], "venue": "Technical report, Universidad Rey Juan Carlos. (http://www.matap.uma.es/investigacion/tr/ma06_02. pdf)", "citeRegEx": "Pearce and Valverde,? \\Q2006\\E", "shortCiteRegEx": "Pearce and Valverde", "year": 2006}, {"title": "Quantified equilibrium logic and foundations for answer set programs", "author": ["D. Pearce", "A. Valverde"], "venue": "Proc. of ICLP\u201908,", "citeRegEx": "Pearce and Valverde,? \\Q2008\\E", "shortCiteRegEx": "Pearce and Valverde", "year": 2008}, {"title": "Synonymous theories and knowledge representations in answer set programming", "author": ["D. Pearce", "A. Valverde"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Pearce and Valverde,? \\Q2012\\E", "shortCiteRegEx": "Pearce and Valverde", "year": 2012}, {"title": "Semantic and computational advantages of the safe integration of ontologies and rules", "author": ["R. Rosati"], "venue": "Fages, F., & Soliman, S. (Eds.), Proc. of PPSWR\u201905, Vol. 3703 of LNCS, pp. 50\u201364. Springer.", "citeRegEx": "Rosati,? 2005", "shortCiteRegEx": "Rosati", "year": 2005}, {"title": "Der interpolationsatz der intuitionistischen pr\u00e4dikatenlogik", "author": ["K. Sch\u00fctte"], "venue": "Math. Ann.,", "citeRegEx": "Sch\u00fctte,? \\Q1962\\E", "shortCiteRegEx": "Sch\u00fctte", "year": 1962}, {"title": "Logic and Structure (3th", "author": ["D. van Dalen"], "venue": null, "citeRegEx": "Dalen,? \\Q1997\\E", "shortCiteRegEx": "Dalen", "year": 1997}], "referenceMentions": [{"referenceID": 34, "context": "The interpolation property has been applied in various areas of computer science, for example in software specification (Diaconescu, Goguen, & Stefaneas, 1993; Bicarregui, Dimitrakos, Gabbay, & Maibaum, 2001), in the construction of formal ontologies (Kontchakov, Wolter, & Zakharyaschev, 2008) and in model checking and related subareas (McMillan, 2005).", "startOffset": 338, "endOffset": 354}, {"referenceID": 34, "context": "In other cases, interpolants themselves play a role as special formulas applied in automated deduction (McMillan, 2005).", "startOffset": 103, "endOffset": 119}, {"referenceID": 37, "context": "In this note we study the interpolation property for the system of nonmonotonic reasoning known as equilibrium logic (Pearce, 2006).", "startOffset": 117, "endOffset": 131}, {"referenceID": 20, "context": "In the first two areas interpolation is important as a metatheoretical property, in particular it may provide a basis for the modular composition and decomposition of theories; for instance, for Kontchakov et al. (2008) it plays a key role in the study of the modular decomposition of ontologies.", "startOffset": 195, "endOffset": 220}, {"referenceID": 14, "context": "Instead, following the idea of Gabbay and Maksimova (2005), we can modify condition (1) and proceed in a two-stage fashion.", "startOffset": 31, "endOffset": 59}, {"referenceID": 37, "context": "When this extension is well-behaved we say that the monotonic logic forms a deductive base1 (Pearce, 2006) for it.", "startOffset": 92, "endOffset": 106}, {"referenceID": 30, "context": "In terms of nonmonotonic consequence operations, (ii) and (iii) correspond to conditions known as left absorption and right absorption respectively (Makinson, 1994).", "startOffset": 148, "endOffset": 164}, {"referenceID": 9, "context": "It is close to the concept of fully absorbing inferential frame used by Dietrich (1994).", "startOffset": 72, "endOffset": 88}, {"referenceID": 26, "context": "A complete axiomatisation of QHT can be obtained as follows (Lifschitz et al., 2007).", "startOffset": 60, "endOffset": 84}, {"referenceID": 33, "context": "The resulting logic is called Quantified Here-and-There Logic with static domains (Lifschitz, Pearce, & Valverde, 2007) denoted by QHT. In terms of satisfiability and validity this logic is equivalent to the logic introduced by Pearce and Valverde (2005). A complete axiomatisation of QHT can be obtained as follows (Lifschitz et al.", "startOffset": 94, "endOffset": 255}, {"referenceID": 26, "context": "We denote the resulting logic by QHT= (Lifschitz et al., 2007) and its inference relation by \u22a2.", "startOffset": 38, "endOffset": 62}, {"referenceID": 33, "context": "In addition HT is one of precisely seven superintuitionistic propositional logics possessing the interpolation property (Maksimova, 1977; Gabbay & Maksimova, 2005).", "startOffset": 120, "endOffset": 163}, {"referenceID": 35, "context": "For languages without function symbols Ono showed that interpolation holds in the logic QHT of quantified here-and-there with constant domains (Ono, 1983).", "startOffset": 143, "endOffset": 154}, {"referenceID": 37, "context": "The following definition give a preliminary notion of equilibrium entailment, which agrees with standard versions of equilibrium logic (Pearce, 2006).", "startOffset": 135, "endOffset": 149}, {"referenceID": 21, "context": "In logic programming, where these restrictions are usually assumed, different solutions to this problem have been proposed (Gelder, Ross, & Schlipf, 1991; Kunen, 1987; Maher, 1988).", "startOffset": 123, "endOffset": 180}, {"referenceID": 29, "context": "In logic programming, where these restrictions are usually assumed, different solutions to this problem have been proposed (Gelder, Ross, & Schlipf, 1991; Kunen, 1987; Maher, 1988).", "startOffset": 123, "endOffset": 180}, {"referenceID": 36, "context": "The first property is precisely the strong equivalence theorem of Lifschitz, Pearce and Valverde (2001). Maximality follows from the fact that any logic strictly stronger than HT would have to contain classical logic which is easily seen not to be a deductive base, e.", "startOffset": 77, "endOffset": 104}, {"referenceID": 12, "context": "As Ferraris et al. (2007) have pointed out, in the general form of answer set programming where first-order formulas are allowed, and a fortiori in quantified equilibrium logic, the property of transitive closure is expressible.", "startOffset": 3, "endOffset": 26}, {"referenceID": 13, "context": "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised.", "startOffset": 103, "endOffset": 142}, {"referenceID": 12, "context": "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised.", "startOffset": 103, "endOffset": 142}, {"referenceID": 12, "context": "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class.", "startOffset": 104, "endOffset": 272}, {"referenceID": 12, "context": "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class.", "startOffset": 104, "endOffset": 341}, {"referenceID": 12, "context": "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class. More recently Cabalar, Pearce and Valverde (2009) have generalised both these approaches and suggested a safety concept for arbitrary function-free formulas in equilibrium logic.", "startOffset": 104, "endOffset": 430}, {"referenceID": 36, "context": "This definition of semi-safe formulas was introduced by Cabalar, Pearce and Valverde (2009) and generalises the former definition of Lee, Lifschitz and Palla (2008b).", "startOffset": 65, "endOffset": 92}, {"referenceID": 36, "context": "This definition of semi-safe formulas was introduced by Cabalar, Pearce and Valverde (2009) and generalises the former definition of Lee, Lifschitz and Palla (2008b). In short, a variable x is semi-safe in \u03c6 if every occurrence is inside some subformula \u03b1 \u2192 \u03b2 such that, either x \u2208 RV(\u03b1) or x is semi-safe in \u03b2.", "startOffset": 65, "endOffset": 166}, {"referenceID": 5, "context": "Proposition 11 (Cabalar et al., 2009) If \u03c6 is function free, semi-safe, and \u3008(D, I), T, T \u3009 |= \u03c6, then \u3008(D, I), T |C , T \u3009 |= \u03c6.", "startOffset": 15, "endOffset": 37}, {"referenceID": 5, "context": "Theorem 2 (Cabalar et al., 2009) If \u03c6 is function free, semi-safe, and \u3008(D, I), T, T \u3009 is an equilibrium model of \u03c6, then T |C = T .", "startOffset": 10, "endOffset": 32}, {"referenceID": 5, "context": "Proposition 12 (Cabalar et al., 2009) If \u03c6 is function free, safe, and prenex formula, then: \u3008(D, I), T, T \u3009 is an equilibrium model of \u03c6 if and only if it is an equilibrium model of GrC(\u03c6) (the grounding of \u03c6 over C).", "startOffset": 15, "endOffset": 37}, {"referenceID": 5, "context": "However, we can also apply Propositions 9 and 10 directly by noting the property shown by Cabalar et al. (2009) that safe prenex formulas have definable classes of equilibrium models.", "startOffset": 90, "endOffset": 112}, {"referenceID": 2, "context": "For a textbook treatment the reader is referred to Baral\u2019s book (2003). As is also well-known, the origins of ASP lie in the stable model and answer set semantics for logic programs introduced by Gelfond and Lifschitz (1988, 1990, 1991).", "startOffset": 51, "endOffset": 71}, {"referenceID": 13, "context": "The correspondence between answer set semantics and equilibrium logic is also wellestablished and has been discussed in many publications, beginning with Pearce (1997), who first showed how the answer sets of disjunctive programs can be regarded as equilibrium models (Lifschitz et al., 2001, 2007; Ferraris et al., 2007; Pearce & Valverde, 2005, 2006, 2008).", "startOffset": 268, "endOffset": 358}, {"referenceID": 31, "context": "The correspondence between answer set semantics and equilibrium logic is also wellestablished and has been discussed in many publications, beginning with Pearce (1997), who first showed how the answer sets of disjunctive programs can be regarded as equilibrium models (Lifschitz et al.", "startOffset": 154, "endOffset": 168}, {"referenceID": 34, "context": "This was first shown by Pearce (1997) but the basic equivalence was later shown to hold for more general classes of programs by Pearce, P.", "startOffset": 24, "endOffset": 38}, {"referenceID": 34, "context": "This was first shown by Pearce (1997) but the basic equivalence was later shown to hold for more general classes of programs by Pearce, P. de Guzman and Valverde (2000). It is also common to treat non-ground rules of form (7) where variables may appear.", "startOffset": 24, "endOffset": 169}, {"referenceID": 12, "context": "At the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas.", "startOffset": 22, "endOffset": 57}, {"referenceID": 12, "context": "At the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas. In this case the property of being a stable model is defined syntactically via a second-order condition that resembles parallel circumscription. However they also showed that the new notion of stable model is equivalent to that of equilibrium model as defined here for first-order languages. In a sequel to this paper, Lee, Lifschitz and Palla (2008a) have applied the new definition and made the following refinements.", "startOffset": 22, "endOffset": 487}, {"referenceID": 12, "context": "At the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas. In this case the property of being a stable model is defined syntactically via a second-order condition that resembles parallel circumscription. However they also showed that the new notion of stable model is equivalent to that of equilibrium model as defined here for first-order languages. In a sequel to this paper, Lee, Lifschitz and Palla (2008a) have applied the new definition and made the following refinements. The stable models of a formula are defined as Ferraris et al. (2007) were, while the answer sets of a formula are those Herbrand models of the formula that are stable in the sense of Ferraris et al.", "startOffset": 22, "endOffset": 624}, {"referenceID": 1, "context": "Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000).", "startOffset": 61, "endOffset": 119}, {"referenceID": 1, "context": "Sometimes, queries of the form not a, or in logical notation \u00aca, are not explicitly dealt with (Balduccini et al., 2000).", "startOffset": 95, "endOffset": 120}, {"referenceID": 43, "context": "On the other hand, there are contexts where answer set semantics is used in a more open world setting, for example in the setting of hybrid knowledge bases (Rosati, 2005) where non-monotonic rules are combined with ontologies formalised in description logics.", "startOffset": 156, "endOffset": 170}, {"referenceID": 1, "context": "Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000). Sometimes, queries of the form not a, or in logical notation \u00aca, are not explicitly dealt with (Balduccini et al., 2000). However it seems to be in keeping with the semantics to regard a formula of form not \u03b1 or \u00ac\u03b1 to be true in an answer set if and only if \u03b1 is not true. Another way to express this would be to say that an answer set satisfies \u00ac\u03b1 if it does not violate the constraint {\u2190 \u03b1}, understanding constraint violation as Lifschitz, Tang and Turner (1999).9 In this way we would say that \u03a0 |\u223cAS \u00acA if no answer set of \u03a0 contains A.", "startOffset": 95, "endOffset": 587}, {"referenceID": 1, "context": "Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000). Sometimes, queries of the form not a, or in logical notation \u00aca, are not explicitly dealt with (Balduccini et al., 2000). However it seems to be in keeping with the semantics to regard a formula of form not \u03b1 or \u00ac\u03b1 to be true in an answer set if and only if \u03b1 is not true. Another way to express this would be to say that an answer set satisfies \u00ac\u03b1 if it does not violate the constraint {\u2190 \u03b1}, understanding constraint violation as Lifschitz, Tang and Turner (1999).9 In this way we would say that \u03a0 |\u223cAS \u00acA if no answer set of \u03a0 contains A. Similarly, the interpretation of queries containing quantifiers in answer set semantics should also conform to that of equilibrium logic, taking account of any specific restrictions, such as Herbrand models, that might be imposed. We can therefore transfer interpolation properties from equilibrium logic to answer set semantics and ASP. It remains to consider whether |\u223cAS is best identified with the closed world version of inference, |\u223ccw, or the more open world version, |\u223cow. Again, since ASP solvers do not generally implement inference engines, the difference is largely a theoretical one. In traditional logic programming, however, a query that does not belong to the language of the program is usually answered false. It also seems quite natural in an ASP context that, given a program \u03a0 and a query Q, one should consider the stable models of \u03a0 in the language L(\u03a0)\u222aL(Q) even if this is a proper extension of the language of \u03a0.10 So in general |\u223ccw seems a natural choice for answer set inference. On the other hand, there are contexts where answer set semantics is used in a more open world setting, for example in the setting of hybrid knowledge bases (Rosati, 2005) where non-monotonic rules are combined with ontologies formalised in description logics. For such systems a semantics in terms of equilibrium logic was provided by de Bruijn, Pearce, Polleres and Valverde (2007). Here an entailment relation in the style of |\u223cow might sometimes be more appropriate.", "startOffset": 95, "endOffset": 2054}, {"referenceID": 3, "context": "The Interpolation property has been applied in various areas of computer science, notably in software specification (Bicarregui et al., 2001) and in the construction of formal ontologies (Lutz & Wolter, 2010).", "startOffset": 116, "endOffset": 141}, {"referenceID": 28, "context": "The above proof is similar to the argument given by Lutz and Wolter (2010) for Theorem 7 of that paper, applied to TBoxes in description logics.", "startOffset": 52, "endOffset": 75}, {"referenceID": 19, "context": "A stronger form of interpolation known as uniform interpolation is also important for certain applications in computer science (Konev et al., 2009).", "startOffset": 127, "endOffset": 147}, {"referenceID": 20, "context": "For example it has been shown to hold for some description logics (Kontchakov et al., 2008) where such syntactic restrictions apply.", "startOffset": 66, "endOffset": 91}, {"referenceID": 11, "context": "Variable forgetting, as studied by Eiter and Wang (2008), is concerned with the following problem.", "startOffset": 35, "endOffset": 57}, {"referenceID": 11, "context": "Then we choose \u03a0\u2032 to be the result of forgetting about X in \u03a0, defined by Eiter and Wang (2008) as follows: forget(\u03a0,X) := forget(forget(forget(\u03a0, a1), a2), .", "startOffset": 74, "endOffset": 96}, {"referenceID": 11, "context": "(12) Let \u03a0\u2032 be forget(\u03a0,X) as determined by algorithm 1 of Eiter and Wang (2008) described above.", "startOffset": 59, "endOffset": 81}, {"referenceID": 11, "context": "As Eiter and Wang (2008) point out, if an atom b is true in some answer set of forget(\u03a0, a), then it must also be true in some answer set of \u03a0, showing that (12) holds for literals.", "startOffset": 3, "endOffset": 25}, {"referenceID": 11, "context": "If we establish uniform interpolation in ASP using the method of forgetting, as defined by Eiter and Wang (2008), it seems clear that we cannot extend in a non-trivial way the expressive power of the query language L.", "startOffset": 91, "endOffset": 113}, {"referenceID": 0, "context": "A notable exception is an article (Amir, 2002) establishing some interpolation properties for circumscription and default logic.", "startOffset": 34, "endOffset": 46}, {"referenceID": 5, "context": "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Sch\u00fctte (1962).", "startOffset": 56, "endOffset": 69}, {"referenceID": 5, "context": "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Sch\u00fctte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation.", "startOffset": 56, "endOffset": 127}, {"referenceID": 5, "context": "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Sch\u00fctte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation.", "startOffset": 56, "endOffset": 145}, {"referenceID": 5, "context": "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Sch\u00fctte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation. A modern, comprehensive treatment of interpolation in modal and intuitionistic logics can be found in the monograph of Gabbay and Maksimova (2005). In non-monotonic logics, interpolation has received little attention.", "startOffset": 56, "endOffset": 378}, {"referenceID": 11, "context": "Using results of Eiter and Wang (2008) about variable forgetting in ASP, we could also show how the property of uniform interpolation holds for disjunctive programs and a restricted query language.", "startOffset": 17, "endOffset": 39}], "year": 2011, "abstractText": "Interpolation is an important property of classical and many non-classical logics that has been shown to have interesting applications in computer science and AI. Here we study the Interpolation Property for the the non-monotonic system of equilibrium logic, establishing weaker or stronger forms of interpolation depending on the precise interpretation of the inference relation. These results also yield a form of interpolation for ground logic programs under the answer sets semantics. For disjunctive logic programs we also study the property of uniform interpolation that is closely related to the concept of variable forgetting. The first-order version of equilibrium logic has analogous Interpolation properties whenever the collection of equilibrium models is (first-order) definable. Since this is the case for so-called safe programs and theories, it applies to the usual situations that arise in practical answer set programming.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}