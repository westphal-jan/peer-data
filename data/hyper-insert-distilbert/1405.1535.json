{"id": "1405.1535", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-May-2014", "title": "Learning Boolean Halfspaces with Small Weights from Membership Queries", "abstract": "we thus consider doing the crucial problem of proper learning constructing a boolean weight halfspace named with integer low weights $ \\ { 0, 1, \\ ldots, t \\ } $ \u03b1 from membership b queries then only. consider the best known mathematical algorithm for this problem is obviously an adaptive probability algorithm that therefore asks $ n ^ { o ( index t ^ 5 ) } $ membership \u2020 queries v where the best lower bound for providing the shortest number of membership... queries is $ n ^ t t $ [ random learning variable threshold functions compiled with possibly small weights measured using membership * queries. colt \uff08 1999 ]", "histories": [["v1", "Wed, 7 May 2014 09:06:28 GMT  (12kb)", "http://arxiv.org/abs/1405.1535v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["hasan abasi", "ali z abdi", "nader h bshouty"], "accepted": false, "id": "1405.1535"}, "pdf": {"name": "1405.1535.pdf", "metadata": {"source": "CRF", "title": "Learning Boolean Halfspaces with Small Weights from Membership Queries", "authors": ["Hasan Abasi", "Ali Z. Abdi"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n15 35\nv1 [\n5) membership queries where the best lower bound for the number of membership queries is nt [4].\nIn this paper we close this gap and give an adaptive proper learning algorithm with two rounds that asks nO(t) membership queries. We also give a non-adaptive proper learning algorithm that asks nO(t 3) membership queries."}, {"heading": "1 Introduction", "text": "We study the problem of learnability of boolean halfspace functions from membership queries [2, 1]. Boolean halfspace is a function f = [w1x1 + \u00b7 \u00b7 \u00b7+wnxn \u2265 u] from {0, 1}\nn to {0, 1} where the weights w1, . . . , wn and the threshold u are integers. The function is 1 if the arithmetic sum w1x1 + \u00b7 \u00b7 \u00b7 + wnxn is greater or equal to u and zero otherwise. In the membership query model [2, 1] the learning algorithm has access to a membership oracle Of , for some target function f , that receives an assignment a \u2208 {0, 1}\nn and returns f(a). A proper learning algorithm for a class of functions C is an algorithm that has access to Of where f \u2208 C asks membership queries and returns a function g in C that is equivalent to f .\nThe problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].\nAnother scenario that motivate the problem of learning Halfspaces is the following. Given a set of n similar looking objects of unknown weights (or any other measure), but from some class of weights W . Suppose we have a scale (or a measure instrument) that can only indicate whether the weight of any set of objects exceeds some unknown fixed threshold (or capacity). How many weighing do one needs in order to find the weights (or all possible weights) of the objects.\nIn this paper we study the problem of proper learnability of boolean halfspace functions with t+ 1 different non-negative weights W = {0, 1, . . . , t} from membership queries. The best known algorithm for this problem is an adaptive algorithm that asks nO(t\n5) membership queries where the best lower bound for the number of membership queries is nt [4].\nIn this paper we close the above gap and give an adaptive proper learning algorithm with two rounds that asks nO(t) membership queries. We also give a non-adaptive proper learning algorithm that asks nO(t\n3) membership queries. All the algorithms in this paper runs in time that is linear in the membership query complexity.\nExtending such result to non-positive weights is impossible. In [4] Abboud et. al. showed that in order to learn boolean Halfspace functions with weights W = {\u22121, 0, 1}, we need at least O(2n\u2212o(n)) membership queries. Therefore the algorithm that asks all the 2n queries in {0, 1}n is optimal for this case. Shevchenko and Zolotykh [14] studied halfspace function over the domain {0, 1, . . . , k \u2212 1}n and no constraints on the coefficients. They gave the lower bound \u2126(logn\u22122 k) lower bound for learning this class from membership queries. Hegedu\u0308s [12] prove the upper bound O(logn k/ log log n). For fixed n Shevchenko and Zolotykh [15] gave a polynomial time algorithm (in log k) for this class.\nThis paper is organized as follows. In Section 2 we give some definitions and preliminary results. In Section 3 we show that any boolean halfspace with polynomially bounded coefficients can be expressed by an Automaton of polynomial size. A result that will be used in Section 4. In Section 4 we give the two round learning algorithm and the non-adaptive algorithm."}, {"heading": "2 Definitions and Preliminary Results", "text": "In this section we give some definitions and preliminary results that will be used throughout the paper"}, {"heading": "2.1 Main Lemma", "text": "In this subsection we prove two main results that will be frequently used in this paper\nFor integers t < r we denote [t] := {1, 2, . . . , t}, [t]0 = {0, 1, . . . , t} and [t, r] = {t, t+ 1, . . . , r}.\nWe first prove the following\nLemma 1. Let w1, . . . , wm \u2208 [\u2212t, t] where at least one wj 6\u2208 {\u2212t, 0, t} and\nm \u2211\ni=1\nwi = r \u2208 [\u2212t+ 1, t\u2212 1].\nThere is a permutation \u03c6 : [m] \u2192 [m] such that for every j \u2208 [m], Wj := \u2211j\ni=1 w\u03c6(i) \u2208 [\u2212t+ 1, t\u2212 1].\nProof. Since there is j such that wj \u2208 [\u2212t+1, t\u22121]\\{0} we can take \u03c6(1) = j. Then W1 = wj \u2208 [\u2212t + 1, t \u2212 1]. If there is j1, j2 such that wj1 = t and wj2 = \u2212t we set \u03c6(2) = j1, \u03c6(3) = j2 if W1 < 0 and \u03c6(2) = j2, \u03c6(3) = j1 if W1 > 0. We repeat the latter until there are either no more t or no more \u2212t in the rest of the elements.\nAssume that we have chosen \u03c6(1), . . . , \u03c6(k\u22121) such that Wj \u2208 [\u2212t+1, t\u2212 1] for j \u2208 [k \u2212 1]. We now show how to determine \u03c6(k) so that Wk \u2208 [\u2212t+ 1, t\u22121]. If Wk\u22121 = \u2211k\u22121 i=1 w\u03c6(i) > 0 and there is q 6\u2208 {\u03c6(1), . . . , \u03c6(k\u22121)} such that wq < 0 then we take \u03c6(k) := q. Then Wk = Wk\u22121+wq \u2208 [\u2212t+1, t\u22121]. If Wk\u22121 < 0 and there is q 6\u2208 {\u03c6(1), . . . , \u03c6(k \u2212 1)} such that wq > 0 then we take \u03c6(k) := q. Then Wk = Wk\u22121 + wq \u2208 [\u2212t + 1, t \u2212 1]. If for every q 6\u2208 {\u03c6(1), . . . , \u03c6(k\u22121)}, wq > 0 (resp. wq < 0) then we can take an arbitrary order of the other elements and we get Wk\u22121 < Wk < Wk+1 < \u00b7 \u00b7 \u00b7 < Wm = r (resp. Wk\u22121 > Wk > Wk+1 > \u00b7 \u00b7 \u00b7 > Wm = r). If Wk\u22121 = 0 then there must be q 6\u2208 {\u03c6(1), . . . , \u03c6(k \u2212 1)} such that wq \u2208 [\u2212t + 1, t \u2212 1]. This is because not both t and \u2212t exist in the elements that are not assigned yet. We then take \u03c6(k) := q.\nThis completes the proof.\nWe now prove the first main lemma\nLemma 2. Let w1, . . . , wm \u2208 [\u2212t, t] and\nm \u2211\ni=1\nwi = r \u2208 [\u2212t+ 1, t\u2212 1].\nThere is a partition S1, S2, . . . , Sq of [m] such that\n1. For every j \u2208 [q \u2212 1], \u2211\ni\u2208Sj wi = 0.\n2. \u2211\ni\u2208Sq wi = r.\n3. For every j \u2208 [q], |Sj | \u2264 2t\u2212 1.\n4. If r 6= 0 then |Sq| \u2264 2t\u2212 2.\nProof. If w1, . . . , wm \u2208 {\u2212t, 0, t} then r must be zero, and the number of non-zero elements is even and half of them are equal to t and the other half are equal to \u2212t. Then we can take Si = {\u2212t, t} or Si = {0} for all i. Therefore we may assume that at least one wj 6\u2208 {\u2212t, 0, t}.\nBy Lemma 1 we may assume w.l.o.g (by reordering the elements) that such that Wj := \u2211j i=1wi \u2208 [\u2212t + 1, t \u2212 1] for all j \u2208 [m]. Let W0 = 0. Consider W0,W1,W2, . . . ,W2t\u22121. By the pigeonhole principle there is 0 \u2264 j1 < j2 \u2264 2t\u22121 such that Wj2 = Wj1 and then Wj2\u2212Wj1 = \u2211j2 i=j1+1\nwi = 0. We then take S1 = {j1 + 1, . . . , j2}. Notice that |S1| = j2 \u2212 j1 \u2264 2t\u2212 1.\nSince \u2211\ni 6\u2208S1 wi = r we can repeat the above to find S2, S3, \u00b7 \u00b7 \u00b7 . This can\nbe repeated as long as |[m]\\(S1 \u222aS2 \u222a \u00b7 \u00b7 \u00b7 \u222aSh)| \u2265 2t\u2212 1. This proves 1\u2212 3. We now prove 4. If g := |[m]\\(S1 \u222a S2 \u222a \u00b7 \u00b7 \u00b7 \u222a Sh)| < 2t \u2212 1 then define Sh+1 = [m]\\(S1 \u222a S2 \u222a \u00b7 \u00b7 \u00b7 \u222a Sh) and we get 4 for q = h + 1. If g = 2t \u2212 1 then W0 = 0,W1,W2, . . . ,W2t\u22121 = r and since r 6= 0 we must have 0 \u2264 j1 < j2 \u2264 2t \u2212 1 and j2 \u2212 j1 < 2t \u2212 1 such that Wj2 = Wj1 . Then define Sh+1 = {j1 + 1, . . . , j2}, Sh+2 = [m]\\(S1 \u222a S2 \u222a \u00b7 \u00b7 \u00b7 \u222a Sh+1) and q = h + 2. Then |Sh+2| \u2264 2t \u2212 2, \u2211\ni\u2208Sh+1 wi = Wj2 \u2212 Wj1 = 0 and\n\u2211\ni\u2208Sh+2 wi = r.\nThe following example shows that the bound 2t\u2212 2 for the size of set in Lemma 2 is tight. Consider the 2t \u2212 2 elements w1 = w2 = \u00b7 \u00b7 \u00b7 = wt\u22121 = t and wt = wt+1 = \u00b7 \u00b7 \u00b7 = w2t\u22122 = \u2212(t\u22121). The sum of any subset of elements is distinct. By adding the element w2t\u22121 = \u2212(t\u2212 1) it is easy to show that the bound 2t\u2212 1 in the lemma is also tight.\nLemma 3. Let (w1, v1), . . . , (wm, vm) \u2208 [\u2212t, t] 2 and\nm \u2211\ni=1\n(wi, vi) = (r, s) \u2208 [\u2212t+ 1, t\u2212 1] 2.\nThere is M \u2286 [m] such that\n1. \u2211\ni\u2208M (wi, vi) = (r, s).\n2. |M | \u2264 8t3 \u2212 4t2 \u2212 2t+ 1.\nProof. Since w1, . . . , wm \u2208 [\u2212t, t] and \u2211m\ni=1 wi = r \u2208 [\u2212t + 1, t \u2212 1], by Lemma 2, there is a partition S1, . . . , Sq of [m] that satisfies the conditions 1\u2212 4 given in the lemma. Let Vj = \u2211\ni\u2208Sj vi for j = 1, . . . , q. We have\nVj \u2208 [\u2212t|Sj|, t|Sj |] \u2286 [\u2212t(2t\u2212 1), t(2t \u2212 1)] \u2282 [\u22122t 2, 2t2]\nfor j = 1, . . . , q and\nq\u22121 \u2211\ni=1\nVi = s\u2212 Vq \u2208 [\u22122t 2 + 1, 2t2 \u2212 1].\nIf s\u2212 Vq = 0 then for M = Sq we have |M | = |Sq| \u2264 2t\u2212 1 \u2264 8t 3 \u2212 4t2 \u2212\n2t+ 1 and \u2211\ni\u2208M\n(wi, vi) = \u2211\ni\u2208Sq\n(wi, vi) = (r, Vq) = (r, s).\nTherefore we may assume that s\u2212 Vq 6= 0. Consider V1, V2, . . . , Vq\u22121. By 4 in Lemma 2 there is a set Q \u2286 [q \u2212 1] of size at most 2(2t2)\u2212 2 = 4t2 \u2212 2 such that \u2211\ni\u2208Q Vi = s\u2212 Vq. Then for\nM = Sq \u222a \u22c3\ni\u2208Q\nSi\nwe have\n|M | \u2264 (2t\u2212 1) + (4t2 \u2212 2)(2t \u2212 1) = 8t3 \u2212 4t2 \u2212 2t+ 1\nand \u2211\ni\u2208M\n(wi, vi) = \u2211\ni\u2208Sq\n(wi, vi) + \u2211\nj\u2208Q\n\u2211\ni\u2208Sj\n(wi, vi)\n= (r, Vq) + \u2211\nj\u2208Q\n(0, Vj)\n= (r, Vq) + (0, s \u2212 Vq) = (r, s)."}, {"heading": "2.2 Boolean Functions", "text": "For a boolean function f(x1, . . . , xn) : {0, 1} n \u2192 {0, 1}, 1 \u2264 i1 < i2 < \u00b7 \u00b7 \u00b7 < ik \u2264 n and \u03c31, . . . , \u03c3k \u2208 {0, 1} we denote by\nf |xi1=\u03c31,xi2=\u03c32,\u00b7\u00b7\u00b7 ,xik=\u03c3k\nthe function f when fixing the variables xij to \u03c3j for all j \u2208 [k]. For a \u2208 {0, 1}n we denote by a|xi1=\u03c31,xi2=\u03c32,\u00b7\u00b7\u00b7 ,xik=\u03c3k the assignment a where each aij is replaced by \u03c3j for all j \u2208 [k]. We note here (and throughout the paper) that f |xi1=\u03c31,xi2=\u03c32,\u00b7\u00b7\u00b7 ,xik=\u03c3k is a function from {0, 1}\nn \u2192 {0, 1} with same variables x1, . . . , xn of f . Obviously\nf |xi1=\u03c31,xi2=\u03c32,\u00b7\u00b7\u00b7 ,xik=\u03c3k(a) = f(a|xi1=\u03c31,xi2=\u03c32,\u00b7\u00b7\u00b7 ,xik=\u03c3k).\nWhen \u03c31 = \u00b7 \u00b7 \u00b7 = \u03c3k = \u03be and S = {xi1 , . . . , xik} we denote\nf |S\u2190\u03be = f |xi1=\u03be,xi2=\u03be,\u00b7\u00b7\u00b7 ,xik=\u03be.\nIn the same way we define a|S\u2190\u03be. We denote by 0 n = (0, 0, . . . , 0) \u2208 {0, 1}n and 1n = (1, 1, . . . , 1) \u2208 {0, 1}n. For two assignments a \u2208 {0, 1}k and b \u2208 {0, 1}j we denote by ab \u2208 {0, 1}k+j the concatenation of the two assignments.\nFor two assignments a, b \u2208 {0, 1}n we write a \u2264 b if for every i, ai \u2264 bi. A boolean function f : {0, 1}n \u2192 {0, 1} is monotone if for every two assignments a, b \u2208 {0, 1}n, if a \u2264 b then f(a) \u2264 f(b). Recall that every monotone boolean function f has a unique representation as a reduced monotone DNF. That is, f = M1 \u2228M2 \u2228 \u00b7 \u00b7 \u00b7 \u2228Ms where each monomial Mi is an ANDs of input variables and for every monomial Mi there is a unique assignment a(i) \u2208 {0, 1}n such that f(a(i)) = 1 and for every j \u2208 [n] where a (i) j = 1 we have f(a(i)|xj=0) = 0. We call such assignment a minterm of the function f . Notice that every monotone DNF can be uniquely determined by its minterms.\nWe say that xi is relevant in f if f |xi=0 6\u2261 f |xi=1. Obviously, if f is monotone then xi is relevant in f if there is an assignment a such that f(a|xi=0) = 0 and f(a|xi=1) = 1. We say that a is a semiminterm of f if for every ai = 1 either f(a|xi=0) = 0 or xi is not relevant in f .\nFor two assignments a, b \u2208 {0, 1}n we define the distance between a and b as wt(a+b) where wt is the Hamming weight and + is the bitwise exclusive or of assignments. The set B(a; d) is the set of all assignments that are of distance at most d from a \u2208 {0, 1}n."}, {"heading": "2.3 Symmetric and Nonsymmetric", "text": "We say that a boolean function f is symmetric in xi and xj if for any \u03be1, \u03be2 \u2208 {0, 1} we have f |xi=\u03be1,xj=\u03be2 \u2261 f |xi=\u03be2,xj=\u03be1 . Obviously, this is equivalent to f |xi=0,xj=1 \u2261 f |xi=1,xj=0. We say that f is nonsymmetric in xi and xj if it is not symmetric in xi and xj . This is equivalent to f |xi=0,xj=1 6\u2261 f |xi=1,xj=0. We now prove\nLemma 4. Let f be a monotone function. Then f is nonsymmetric in xi and xj if and only if there is a minterm a of f such that ai + aj = 1 (one is 0 and the other is 1) where f(a|xi=0,xj=1) 6= f(a|xi=1,xj=0).\nProof. Since f is nonsymmetric in xi and xj we have f |xi=0,xj=1 6\u2261 f |xi=1,xj=0 and therefore there is an assignment a\u2032 such that f |xi=0,xj=1(a \u2032) 6= f |xi=1,xj=0(a \u2032). Suppose w.l.o.g. f |xi=0,xj=1(a \u2032) = 0 and f |xi=1,xj=0(a\n\u2032) = 1. Take a minterm a \u2264 a\u2032 of f |xi=1,xj=0. Notice that ai = aj = 0. Otherwise we can flip them to 0 without changing the value of the function f |xi=1,xj=0 and then a is not a minterm. Then f |xi=1,xj=0(a) = 1 and since a \u2264 a\n\u2032, f |xi=0,xj=1(a) = 0. We now prove that b = a|xi=1,xj=0 is a minterm of f . Since b|xi=0 =\na|xi=0,xj=0 < a|xi=0,xj=1 we have f(b|xi=0) < f(a|xi=0,xj=1) = f |xi=0,xj=1(a) = 0 and therefore f(b|xi=0) = 0. For any bk = 1 where k 6= i, since a is a minterm for f |xi=1,xj=0, we have f(b|xk=0) = f |xi=1,xj=0(a|xk=0) = 0. Therefore b is a minterm of f .\nWe write xi \u223cf xj when f is symmetric in xi and xj and call \u223cf the symmetric relation of f . The following folklore result is proved for completeness\nLemma 5. The relation \u223cf is an equivalence relation.\nProof. Obviously, xi \u223cf xi and if xi \u223cf xj then xj \u223cf xi. Now if xi \u223cf xj and xj \u223cf xk then f |xi=\u03be1,xj=\u03be2,xk=\u03be3 \u2261 f |xi=\u03be2,xj=\u03be1,xk=\u03be3 \u2261 f |xi=\u03be2,xj=\u03be3,xk=\u03be1 \u2261 f |xi=\u03be3,xj=\u03be2,xk=\u03be1 and therefore xi \u223cf xk."}, {"heading": "2.4 Properties of Boolean Halfspaces", "text": "A Boolean Halfspace function is a boolean function f : {0, 1}n \u2192 {0, 1}, f = [w1x1+w2x2+ \u00b7 \u00b7 \u00b7+wnxn \u2265 u] where w1, . . . , wn, u are integers, defined as f(x1, . . . , xn) = 1 if w1x1 +w2x2 + \u00b7 \u00b7 \u00b7+wnxn \u2265 u and 0 otherwise. The numbers wi, i \u2208 [n] are called the weights and u is called the threshold. The class HS is the class of all Boolean Halfspace functions. The class HSt is the class of all Boolean Halfspace functions with weights wi \u2208 [t]0 and the\nclass HS[\u2212t,t] is the class of all Boolean Halfspace functions with weights wi \u2208 [\u2212t, t]. The representation of the above Boolean Halfspaces are not unique. For example, [3x1 +2x2 \u2265 2] is equivalent to [x1 + x2 \u2265 1]. We will assume that\nThere is an assignment a \u2208 {0, 1}n such that w1a1 + \u00b7 \u00b7 \u00b7+ wnan = b (1)\nOtherwise we can replace b by the minimum integer w1a1+ \u00b7 \u00b7 \u00b7+wnan where f(a) = 1 and get an equivalent function. Such a is called a strong assignment of f . If in addition a is a minterm then it is called a strong minterm.\nThe following lemma follows from the above definitions\nLemma 6. Let f \u2208 HSt. We have\n1. If a is strong assignment of f then a is semiminterm of f .\n2. If all the variables in f are relevant then any semiminterm of f is a minterm of f .\nWe now prove\nLemma 7. Let f = [w1x1 + w2x2 + \u00b7 \u00b7 \u00b7+ wnxn \u2265 u] \u2208 HSt. Then\n1. If w1 = w2 then f is symmetric in x1 and x2.\n2. If f is symmetric in x1 and x2 then there are w \u2032 1 and w \u2032 2 such that\n|w\u20321 \u2212w \u2032 2| \u2264 1 and f \u2261 [w \u2032 1x1 + w \u2032 2x2 + w3x3 \u00b7 \u00b7 \u00b7+ wnxn \u2265 u] \u2208 HSt.\nProof. If w1 = w2 then for any assignment z = (z1, z2, . . . , zn) we have w1z1+w2z2+\u00b7 \u00b7 \u00b7+wnzn = w1z2+w2z1+\u00b7 \u00b7 \u00b7+wnzn. Therefore, f(0, 1, x3, . . . , xn) \u2261 f(1, 0, x3, . . . , xn).\nSuppose w1 > w2. It is enough to show that f \u2261 g := [(w1\u22121)x1+(w2+ 1)x2 + w3x3 \u00b7 \u00b7 \u00b7 + wnxn \u2265 u]. Obviously, f(x) = g(x) when x1 = x2 = 1 or x1 = x2 = 0. If f(0, 1, x3, . . . , xn) \u2261 f(1, 0, x3, . . . , xn) then w1 + w3x3 + w4x4+ \u00b7 \u00b7 \u00b7+wnxn \u2265 u if and only if w2+w3x3+w4x4+ \u00b7 \u00b7 \u00b7+wnxn \u2265 u and therefore w1+w3x3+w4x4+ \u00b7 \u00b7 \u00b7+wnxn \u2265 u if and only if (w1\u22121)+w3x3+ w4x4 + \u00b7 \u00b7 \u00b7+wnxn \u2265 u if and only if (w2 +1)+w3x3 +w4x4 + \u00b7 \u00b7 \u00b7+wnxn \u2265 u.\nWe now prove\nLemma 8. Let f \u2208 HSt. Let a be any assignment such that f(a) = 1 and f(a|xi=0) = 0 for some i \u2208 [n]. There is a strong assignment of f in B(a, 2t\u2212 2).\nProof. Let f = [w1x1 + \u00b7 \u00b7 \u00b7 + wnxn \u2265 u]. Since f(a) = 1 and f |xi=0(a) = 0, ai = 1 and we have w1a1 +w2a2 + \u00b7 \u00b7 \u00b7+wnan = u+u\n\u2032 where t\u2212 1 \u2265 u\u2032 \u2265 0. If u\u2032 = 0 then a \u2208 B(a, 2t \u2212 2) is a strong assignment. So we may assume that u\u2032 6= 0.\nBy (1) there is an assignment b where w1b1 + w2b2 + \u00b7 \u00b7 \u00b7 + wnbn = u. Therefore w1(b1 \u2212 a1) + w2(b2 \u2212 a2) + \u00b7 \u00b7 \u00b7 + wn(bn \u2212 an) = \u2212u\n\u2032. Since wi(bi \u2212 ai) \u2208 [\u2212t, t], by Lemma 2 there is S \u2286 [n] of size at most 2t\u2212 2 such that \u2211\ni\u2208S wi(bi \u2212 ai) = \u2212u \u2032. Therefore\nu = \u2212u\u2032 + (u+ u\u2032) = \u2211\ni\u2208S\nwi(bi \u2212 ai) + n \u2211\ni=1\nwiai = \u2211\ni\u2208S\nwibi + \u2211\ni 6\u2208S\nwiai.\nThus the assignment c where ci = bi for i \u2208 S and ci = ai for i 6\u2208 S is a strong assignment of f and c \u2208 B(a, 2t\u2212 2).\nThe following will be used to find the relevant variables\nLemma 9. Let f \u2208 HSt. Suppose xk is relevant in f . Let a be any assignment such that ak = 1, f(a) = 1 and f(a|xj=0) = 0 for some j, k \u2208 [n]. There is c \u2208 B(a, 2t\u2212 2) such that ck = 1, f(c) = 1 and f(c|xk=0) = 0.\nProof. Let f = [w1x1 + \u00b7 \u00b7 \u00b7 + wnxn \u2265 u]. Since f(a) = 1 and f(a|xj=0) = 0 we have aj = 1 and w1a1+w2a2+ \u00b7 \u00b7 \u00b7+wnan = u+u\n\u2032 where t\u2212 1 \u2265 u\u2032 \u2265 0. Let b a minterm of f such that bk = 1. Since b is a minterm we have w1b1+w2b2+\u00b7 \u00b7 \u00b7+wnbn = u+u\n\u2032\u2032 where t\u22121 \u2265 u\u2032\u2032 \u2265 0 and since f(b|xk=0) = 0 we also have u\u2032\u2032 \u2212wk < 0. If u\n\u2032\u2032 = u\u2032 then we may take c = a. Therefore we may assume that u\u2032\u2032 6= u\u2032.\nHence \u2211n i=1,i 6=k wi(bi \u2212 ai) = u \u2032\u2032 \u2212 u\u2032 \u2208 [\u2212t+1, t\u2212 1]\\{0}. By Lemma 2\nthere is S \u2286 [n]\\{k} of size at most 2t\u22122 such that \u2211 i\u2208S wi(bi\u2212ai) = u \u2032\u2032\u2212u\u2032. Therefore\nu+ u\u2032\u2032 = \u2211\ni\u2208S\nwi(bi \u2212 ai) + n \u2211\ni=1\nwiai = \u2211\ni\u2208S\nwibi + \u2211\ni 6\u2208S\nwiai.\nThus the assignment c where ci = bi for i \u2208 S and ci = ai for i 6\u2208 S satisfies ck = ak = 1 and c \u2208 B(a, 2t\u2212 2). Since \u2211n i=1,i 6=k wici = u+ u\n\u2032\u2032 \u2212 bk < u we have f(c|xk=0) = 0.\nThe following will be used to find the order of the weights\nLemma 10. Let f \u2208 HSt be antisymmetric in x1 and x2. For any minterm a of f of weight at least 2 there is b \u2208 B(a, 2t+1) such that b1 + b2 = 1 and f |x1=0,x2=1(b) 6= f |x1=1,x2=0(b).\nProof. Let f = [w1x1 + \u00b7 \u00b7 \u00b7 + wnxn \u2265 u]. Assume w.l.o.g w1 > w2. By Lemma 4 there is a minterm c = (1, 0, c3, . . . , cn) such that f(c) = 1 and f(0, 1, c3, . . . , cn) = 0. Then W1 := w1 + w3c3 + \u00b7 \u00b7 \u00b7 + wncn = u + v where 0 \u2264 v \u2264 t \u2212 1 and W2 := w2 + w3c3 + \u00b7 \u00b7 \u00b7 + wncn = u \u2212 z where 1 \u2264 z \u2264 t \u2212 1. In fact \u2212z = v \u2212 w1 + w2. Since a is a minterm we have W3 := w1a1 + \u00b7 \u00b7 \u00b7+wnan = u+ h where 0 \u2264 h \u2264 t\u2212 1. It is now enough to find b \u2208 B(a, 2t\u2212 2) such that either\n1. b1 = 1, b2 = 0 and w1b1 + \u00b7 \u00b7 \u00b7+ wnbn = u+ v, or\n2. b1 = 0, b2 = 1 and w1b1 + \u00b7 \u00b7 \u00b7+ wnbn = u\u2212 z.\nThis is because if b1 = 1, b2 = 0 and w1b1 + \u00b7 \u00b7 \u00b7 + wnbn = u + v (the other case is similar) then f(1, 0, b2, . . . , bn) = 1 and since w1 \u00b7 0 + w2 \u00b7 1 + w3 \u00b7 a3 \u00b7 \u00b7 \u00b7+ wnan = u+ v \u2212 w1 + w2 = u\u2212 z we have f(0, 1, b2, . . . , bn) = 0.\nWe now have four cases Case I. a1 = 1 and a2 = 0: ThenW1\u2212W3 = w3(c3\u2212a3)+\u00b7 \u00b7 \u00b7+wn(cn\u2212an) = v \u2212 h \u2208 [\u2212t+ 1, t \u2212 1]\\{0}. By Lemma 2 there is S \u2286 [3, n] of size at most 2t\u2212 1 such that \u2211\ni\u2208S wi(ci \u2212 ai) = v \u2212 h. Therefore\nu+ v = v \u2212 h+W3 = \u2211\ni\u2208S\nwi(ci \u2212 ai) + n \u2211\ni=1\nwiai = \u2211\ni\u2208S\nwici + n \u2211\ni 6\u2208S\nwiai.\nNow define b to be bi = ci for i \u2208 S and bi = ai for i 6\u2208 S. Since 1, 2 6\u2208 S b1 = a1 = 1 and b2 = a2 = 0. Since b \u2208 B(a, 2t \u2212 1) \u2282 B(a, 2t + 1) and b satisfies 1. the result follows for this case. Case II. a1 = 0 and a2 = 1: Since a is of weight at least 2, we may assume w.l.o.g that a3 = 1. Since a is a minterm f(a) = 1 and f(a|x3=0) = 0 and therefore for a\u2032 = a|x3=0 we have W4 := w1a \u2032 1 +w2a \u2032 2 + \u00b7 \u00b7 \u00b7+ wna \u2032 n = u\u2212 h \u2032 where 1 \u2264 h\u2032 \u2264 t \u2212 1. Then W2 \u2212 W4 = \u2211n i=3 wi(ci \u2212 a \u2032 i) = h\n\u2032 \u2212 z \u2208 [\u2212t + 1, t \u2212 1]. By Lemma 2 there is S \u2286 [3, n] of size at most 2t \u2212 1 such that \u2211\ni\u2208S wi(ci \u2212 a \u2032 i) = h \u2032 \u2212 z. Therefore\nu\u2212 z = h\u2032 \u2212 z +W4 = \u2211\ni\u2208S\nwi(ci \u2212 a \u2032 i) +\nn \u2211\ni=1\nwia \u2032 i =\n\u2211\ni\u2208S\nwici + n \u2211\ni 6\u2208S\nwia \u2032 i.\nNow define b to be bi = ci for i \u2208 S and bi = a \u2032 i for i 6\u2208 S. Since 1, 2 6\u2208 S b1 = a \u2032 1 = 0 and b2 = a \u2032 2 = 1. Since b \u2208 B(a\n\u2032, 2t \u2212 1) \u2282 B(a, 2t + 1) and b satisfies 2. the result follows for this case. Case III. a1 = 1 and a2 = 1: Since a is a minterm f(a) = 1 and f(a|x1=0) = 0 and therefore for a\u2032 = a|x1=0 we have W4 := w1a \u2032 1 + w2a \u2032 2 + \u00b7 \u00b7 \u00b7+ wna \u2032 n = u\u2212 h\u2032 where 1 \u2264 h\u2032 \u2264 t\u2212 1. We now proceed exactly as in Case II.\nCase IV. a1 = 0 and a2 = 0: Since a is of weight at least 2 we may assume w.l.o.g that a3 = 1. Since a is a minterm f(a) = 1 and f(a|x3=0) = 0 and therefore for a\u2032 = a|x3=0 we have W4 := a \u2032 1w1 + a \u2032 2w2 + \u00b7 \u00b7 \u00b7+ a \u2032 nwn = u\u2212 h \u2032 where 1 \u2264 h\u2032 \u2264 t \u2212 1. If f(a\u2032|x2=1) = 0 then proceed as in Case II to get b \u2208 B(a, 2t+1) that satisfies 2. If f(a\u2032|x1=1) = 1 then proceed as in Case I. Now the case where f(a\u2032|x2=1) = 1 and f(a\n\u2032|x1=1) = 0 cannot happen since w1 > w2.\nThe following will be used for the non-adaptive algorithm\nLemma 11. Let f, g \u2208 HSt be such that f 6\u21d2 g. For any minterm b of f there is c \u2208 B(b, 8t3 +O(t2)) such that f(c) + g(c) = 1.\nProof. Let f = [w1x1 + \u00b7 \u00b7 \u00b7 + wnxn \u2265 u] and g = [w \u2032 1x1 + \u00b7 \u00b7 \u00b7 + w \u2032 nxn \u2265 u \u2032]. Since f 6\u21d2 g, there is a\u2032 \u2208 {0, 1}n such that f(a\u2032) = 1 and g(a\u2032) = 0. Let a \u2264 a\u2032 be a minterm of f . Then f(a) = 1 and since a \u2264 a\u2032 we also have g(a) = 0. Therefore w1a1 + \u00b7 \u00b7 \u00b7 + wnan = u + r where 0 \u2264 r \u2264 t \u2212 1 and w\u20321a1 + \u00b7 \u00b7 \u00b7 + w \u2032 nan = u\n\u2032 \u2212 s for some integer s \u2265 1. Since b is a minterm of f we have w1b1 + \u00b7 \u00b7 \u00b7 + wnbn = u + r\n\u2032 where 0 \u2264 r\u2032 \u2264 t \u2212 1. If g(b) = 0 then take c = b. Otherwise, if for some bi = 1, g(b|xi=0) = 1 then take c = b|xi=0. Therefore we may assume that b is also a minterm of g. Thus w\u20321b1 + \u00b7 \u00b7 \u00b7 + w \u2032 nbn = u+ s\n\u2032 where 0 \u2264 s\u2032 \u2264 t\u2212 1. Consider the sequence Zi, i = 1, . . . , n + s \u2212 1 where Zi = (wi(ai \u2212 bi), w \u2032 i(ai \u2212 bi)) for i = 1, . . . , n and Zi = (0, 1) for i = n+ 1, . . . , n + s \u2212 1. Then n+s\u22121 \u2211\ni=1\nZi = (r \u2212 r \u2032,\u22121\u2212 s\u2032) \u2208 [\u2212t, t]2.\nBy Lemma 3 there is a set S \u2286 [n + s \u2212 1] of size 8t3 + O(t2) such that \u2211\ni\u2208S Zi = (r \u2212 r \u2032,\u22121 \u2212 s\u2032). Therefore, there is a set T \u2286 [n] of size at\nmost 8t3 + O(t2) such that \u2211 i\u2208T Zi = (r \u2212 r \u2032,\u2212\u2113 \u2212 1 \u2212 s\u2032) for some \u2113 > 0. Therefore\n\u2211\ni\u2208T\nwi(ai \u2212 bi) = r \u2212 r \u2032 and\n\u2211\ni\u2208T\nw\u2032i(ai \u2212 bi) = \u2212\u2113\u2212 1\u2212 s \u2032.\nDefine c such that ci = ai for i \u2208 T and ci = bi for i 6\u2208 T . Then\nn \u2211\ni=1\nwici = u+ r \u2265 u and n \u2211\ni=1\nw\u2032ici = u \u2032 \u2212 \u2113\u2212 1 < u\u2032.\nTherefore f(c) = 1 and g(c) = 0. This gives the result."}, {"heading": "3 Boolean Halfspace and Automata", "text": "In this section we show that functions in HS[\u2212t,t] has an automaton representation of poly(n, t) size.\nLemma 12. Let f1, f2, . . . , fk \u2208 HS[\u2212t,t] and g : {0, 1} k \u2192 {0, 1}. Then g(f1, . . . , fk) can be represented with an Automaton of size (2t) knk+1.\nProof. Let fi = [wi,1x1 + \u00b7 \u00b7 \u00b7 + wi,nxn \u2265 ui], i = 1, . . . , k. Define the following automaton: The alphabet of the automaton is {0, 1}. The states are S \u2286 [n]0 \u00d7 [\u2212tn, tn]\nk. The automaton has n + 1 levels. States in level i are connected only to states in level i + 1 for all i \u2208 [n]0. We denote by Si the states in level i. We also have Si \u2286 {i} \u00d7 [\u2212tn, tn]\nk so the first entry of the state indicates the level that the state belongs to. The state (0, (0, 0, . . . , 0)) is the initial state and is the only state in level 0. That is S0 = {(0, (0, 0, . . . , 0))}. We now show how to connect states in level i to states in level i+1. Given a state s = (i, (W1,W2, . . . ,Wk)) in Si. Then the transition function for this state is\n\u03b4((i, (W1,W2, . . . ,Wk)), 0) = (i+ 1, (W1,W2, . . . ,Wk))\nand\n\u03b4((i, (W1,W2, . . . ,Wk)), 1) = (i+1, (W1+w1,i+1,W2+w2,i+1, . . . ,Wk+wk,i+1)).\nThe accept states (where the output of the automaton is 1) are all the states (n, (W1, . . . ,Wk)) where g([W1 \u2265 u1], [W2 \u2265 u2], . . . , [Wn \u2265 un]) = 1. Here [Wi \u2265 ui] = 1 if Wi \u2265 ui and zero otherwise. All other states are nonaccept states (output 0).\nWe now claim that the above automaton is equivalent to g(f1, . . . , fk). The proof is by induction on n. The claim we want to prove is that the subautomaton that starts from state s = (i, (W1,W2, . . . ,Wk)) computes a function gs that is equivalent to the function g(f i 1, . . . , f i k) where f i j = [wj,i+1xi+1 + \u00b7 \u00b7 \u00b7 + wj,nxn \u2265 uj \u2212 Wj]. This immediately follows from the fact that\ngs|xi+1=0 \u2261 g\u03b4(s,0), and gs|xi+1=1 \u2261 g\u03b4(s,1).\nIt remains to prove the result for level n. The claim is true for the states at level n because\ng(fn1 , . . . , f n k ) = g([0 \u2265 u1 \u2212W1], . . . , [0 \u2265 un \u2212Wn])\n= g([W1 \u2265 u1], [W2 \u2265 u2], . . . , [Wn \u2265 un]).\nThis completes the proof.\nNow the following will be used in the sequel\nLemma 13. Let f1, f2 \u2208 HS[\u2212t,t]. There is an algorithm that runs in time t2n3 and decides whether f1 \u2261 f2. If f1 6\u2261 f2 then the algorithm finds an assignment a such that f1(a) 6= f2(a).\nProof. We build an automaton for f1 + f2. If there is no accept state then f1 \u2261 f2. If there is, then any path from the start state to an accept state defines an assignment a such that f1(a) 6= f2(a)."}, {"heading": "4 Two Rounds and Non-adaptive Algorithm", "text": "In this section we give a two rounds algorithm for learning HSt that uses n O(t) membership queries. Let f = [w1x1+ . . .+wnxn \u2265 u]. If there is a minterm of weight one then 0 \u2264 u \u2264 t and then all the minterms of f are of weight at most t. In this case we can find all the minterms in one round by asking all the assignments in B(0, t) (all other assignments gives 0), finding all the relevant variables and the antisymmetric variables and move to the second round. Therefore we may assume that all the minterms of f are of weight at least two.\nConsider the set\nAm = n \u22c3\ni,j=0\nB(0i1n\u2212i\u2212j0j,m).\nwe now prove\nLemma 14. Let f \u2208 HSt. The variable xk is relevant in f if and only if there is a \u2208 A2t\u22122 such that ak = 1, a|xk=0 \u2208 A2t\u22121 and f(a) 6= f(a|xk=0).\nProof. If xk is relevant in f then f 6\u2261 0, 1 and therefore f(0 n) = 0 and f(1n) = 1. Therefore there is an element a in the following sequence\n0n, 0k\u2212110n\u2212k, 0k\u22121120n\u2212k\u22121, . . . , 0k\u221211n\u2212k+1, 0k\u221221n\u2212k+2, . . . , 01n\u22121, 1n\nand j \u2208 [n] such that f(a) = 1 and f(a|xj=0) = 0. Notice that ak = 1 and therefore by Lemma 9 there is c \u2208 B(a, 2t \u2212 2) such that ck = 1, f(c) = 1 and f(c|xk=0) = 0. Since c|xk=0 \u2208 B(a, 2t\u2212 1), the result follows.\nTherefore from the assignments in A2t\u22121 one can determine the relevant variables in f . This implies that we may assume w.l.o.g that all the variables are relevant. This can be done by just ignoring all the nonrelevant variables and projecting the relevant variables to new distinct variables y1, . . . , ym.\nWe now show\nLemma 15. If all the variables in f \u2208 HSt are relevant then there is a strong minterm a \u2208 A2t\u22122 of f .\nProof. Follows from Lemma 8 and Lemma 6.\nLemma 16. Let f \u2208 HSt and suppose all the variables in f are relevant. Suppose f is antisymmetric in xj and xk. There is b \u2208 B(a, 4t \u2212 1) such that b1 + b2 = 1 and f |xj=0,xk=1(b) 6= f |xj=1,xk=0(b).\nProof. By Lemma 15 there is a minterm a \u2208 A2t\u22122 of f . Since wt(a) > 1, by Lemma 10 there is b \u2208 B(a, 2t\u22121) such that b1+b2 = 1 and f |xj=0,xk=1(b) 6= f |xj=1,xk=0(b). Since b \u2208 B(a, 2t+ 1) \u2286 A4t\u22121 the result follows.\nTherefore from the assignments in A4t\u22123 one can find a permutation \u03c6 of the variables in f such that f\u03c6 = [w\u20321x1 + w \u2032 2x2 + \u00b7 \u00b7 \u00b7 + w \u2032 nxn \u2265 u] and w\u20321 \u2264 w \u2032 2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 w \u2032 n.\nThis completes the first round. We now may assume w.l.o.g that f = [w1x1 + \u00b7 \u00b7 \u00b7 + wnxn \u2265 u] and 1 \u2264 w1 \u2264 w2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 wn \u2264 t and all the variables are relevant. The goal of the second round is to find wi \u2208 [1, t] and u \u2208 [0, nt]. Since we know that 1 \u2264 w1 \u2264 w2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 wn \u2264 t we have\n(\nn+ t\u2212 1\nt\u2212 1\n)\nnt \u2264 nt+1\nchoices. That is at most nt+1 possible functions in HSt. For every two such functions f1, f2 we use Lemma 13 to find out if f1 \u2261 f2 and if not to find an assignment a such that f1(a) 6= f2(a). This takes time\n(\nnt+1\n2\n)\nt2n3 \u2264 n2t+7.\nLet B the set of all such assignments. Then |B| \u2264 n2t+2. In the second round we ask membership queries with all the assignments in B.\nNow notice that if f1(a) 6= f2(a) then either f(a) 6= f1(a) or f(a) 6= f2(a). This shows that the assignments in B eliminates all the functions that are not equivalent to the target and all the remaining functions are equivalent to the target.\nNow using Lemma 11 one can replace the set B by B(b, 8t3 +O(t2)) for any minterm b of f . This change the algorithm to a non-adaptive algorithm."}], "references": [{"title": "Combinatorial Search", "author": ["M. Aigner"], "venue": "Wiley Teubner Series on Applicable Theory in Computer Science. Teubner, Stuttgart", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1988}, {"title": "Queries and Concept Learning", "author": ["D. Angluin"], "venue": "Machine Learning", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1987}, {"title": "Learning a Hidden Subgraph", "author": ["A. Alon", "V. Asodi"], "venue": "SIAM J. Discrete Math", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "Learning Threshold Functions with Small Weights Using Membership Queries", "author": ["E. Abboud", "N. Agha", "N.H. Bshouty", "N. Radwan", "F. Saleh"], "venue": "COLT", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1999}, {"title": "Learning a Hidden Matching", "author": ["N. Alon", "R. Beigel", "S. Kasif", "S. Rudich", "B. Sudakov"], "venue": "SIAM J. Comput", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2004}, {"title": "Learning a Hidden Hypergraph", "author": ["D. Angluin", "J. Chen"], "venue": "Journal of Machine Learning Research", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2006}, {"title": "Learning a hidden graph using O(log n) queries per edge", "author": ["D. Angluin", "J. Chen"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2008}, {"title": "An optimal procedure for gap closing in whole genome shotgun sequencing", "author": ["R. Beigel", "N. Alon", "S. Kasif", "M. Serkan Apaydin", "L. Fortnow"], "venue": "RECOMB", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2001}, {"title": "Multiple Access Channels: Theory and Practice", "author": ["E. Biglieri", "L. Gyorfi"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "Optimal query complexity bounds for finding graphs", "author": ["S-S. Choi", "J.H. Kim"], "venue": "Artif. Intell", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "Reconstructing a Hamiltonian Cycle by Querying the Graph: Application to DNA Physical Mapping", "author": ["V. Grebinski", "G. Kucherov"], "venue": "Discrete Applied Mathematics", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1998}, {"title": "Generalized teaching dimensions and the query complexity of learning", "author": ["T. Heged\u00fcs"], "venue": "Proceedings of the 8th Annual ACM Conference on Computational Learning Theory (COLT\u201995). ACM Press New York,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1995}, {"title": "Lower Bounds for the Complexity of Learning Half-Spaces with Membership Queries", "author": ["V.N. Shevchenko", "N. Yu. Zolotykh"], "venue": "ALT", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1998}, {"title": "Deciphering threshold functions of k-valued logic. Discrete Analysis and Operations Research. Novosibirsk", "author": ["N.Yu. Zolotykh", "V.N. Shevchenko"], "venue": "Operations Research and Discrete Analysis. Kluwer Ac. Publ. Netherlands", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1995}], "referenceMentions": [{"referenceID": 3, "context": "The best known algorithm for this problem is an adaptive algorithm that asks n ) membership queries where the best lower bound for the number of membership queries is n [4].", "startOffset": 169, "endOffset": 172}, {"referenceID": 1, "context": "We study the problem of learnability of boolean halfspace functions from membership queries [2, 1].", "startOffset": 92, "endOffset": 98}, {"referenceID": 0, "context": "We study the problem of learnability of boolean halfspace functions from membership queries [2, 1].", "startOffset": 92, "endOffset": 98}, {"referenceID": 1, "context": "In the membership query model [2, 1] the learning algorithm has access to a membership oracle Of , for some target function f , that receives an assignment a \u2208 {0, 1} n and returns f(a).", "startOffset": 30, "endOffset": 36}, {"referenceID": 0, "context": "In the membership query model [2, 1] the learning algorithm has access to a membership oracle Of , for some target function f , that receives an assignment a \u2208 {0, 1} n and returns f(a).", "startOffset": 30, "endOffset": 36}, {"referenceID": 7, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 197, "endOffset": 207}, {"referenceID": 4, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 197, "endOffset": 207}, {"referenceID": 9, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 197, "endOffset": 207}, {"referenceID": 10, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 285, "endOffset": 289}, {"referenceID": 9, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 345, "endOffset": 349}, {"referenceID": 2, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 377, "endOffset": 386}, {"referenceID": 5, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 377, "endOffset": 386}, {"referenceID": 6, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 377, "endOffset": 386}, {"referenceID": 8, "context": "The problem of learning classes from membership queries only were motivated from many problems in different areas such as computational biology that arises in whole-genome (DNA) shotgun sequencing [8, 5, 10], DNA library screening [13], multiplex PCR method of genome physical mapping [11], linkage discovery problems of artificial intelligence [10], chemical reaction problem [3, 6, 7] and signature coding problem for the multiple access adder channels [9].", "startOffset": 455, "endOffset": 458}, {"referenceID": 3, "context": "The best known algorithm for this problem is an adaptive algorithm that asks nO(t ) membership queries where the best lower bound for the number of membership queries is n [4].", "startOffset": 172, "endOffset": 175}, {"referenceID": 3, "context": "In [4] Abboud et.", "startOffset": 3, "endOffset": 6}, {"referenceID": 12, "context": "Shevchenko and Zolotykh [14] studied halfspace function over the domain {0, 1, .", "startOffset": 24, "endOffset": 28}, {"referenceID": 11, "context": "Heged\u00fcs [12] prove the upper bound O(log k/ log log n).", "startOffset": 8, "endOffset": 12}, {"referenceID": 13, "context": "For fixed n Shevchenko and Zolotykh [15] gave a polynomial time algorithm (in log k) for this class.", "startOffset": 36, "endOffset": 40}], "year": 2014, "abstractText": "We consider the problem of proper learning a Boolean Halfspace with integer weights {0, 1, . . . , t} from membership queries only. The best known algorithm for this problem is an adaptive algorithm that asks n ) membership queries where the best lower bound for the number of membership queries is n [4]. In this paper we close this gap and give an adaptive proper learning algorithm with two rounds that asks n membership queries. We also give a non-adaptive proper learning algorithm that asks n ) membership queries.", "creator": "LaTeX with hyperref package"}}}