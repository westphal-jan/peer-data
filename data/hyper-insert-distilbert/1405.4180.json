{"id": "1405.4180", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-May-2014", "title": "Algorithm for Adapting Cases Represented in a Tractable Description Logic", "abstract": "mapping case - based fuzzy reasoning ( now cbr ) based logic on description value logics ( dls ) } has unexpectedly gained a lot worth of attention particularly lately. reducing adaptation is a potentially basic task paradigm in the main cbr inference that patterns can traditionally be modeled effectively as the knowledge base revision problem and later solved in propositional field logic. however, indeed in most dls, optimization it is now still a challenge problem problem applied since whereas existing revision operators only work well for strictly extremely restricted dls of preserving the \\ power emph { dl - lite } 1 family, 0 and it is difficult instead to duplicate design within a future revision algorithms algorithm such which is syntax - independent and fine - depth grained. in this paper, we present yourselves a brief new alignment method for adaptation based on the base dl $ \\ planet mathcal { el _ { \\ mundo bot } } $. following the canonical idea of adaptation as revision, thus we am firstly presented extend the logical basis for naturally describing these cases from propositional pattern logic to the dl $ \\ mathcal {. el _ { \\ bot } } $, briefly and promptly present a temporal formalism requiring for adaptation based again on $ \\ ni mathcal { el _ { \\ global bot } } $. b then we respectively present himself an adaptation algorithm aiming for this arbitrary formalism ( and firstly demonstrate that our algorithm is declared syntax - bit independent and fine - sc grained. our work statement provides explicitly a logical basis for creating adaptation in cbr based systems where cases and domain knowledge extensions are best described successfully by checking the tractable dl $ \\ n mathcal { [ el _ { \\ bot } } $.", "histories": [["v1", "Fri, 16 May 2014 14:24:42 GMT  (39kb)", "http://arxiv.org/abs/1405.4180v1", "21 pages. ICCBR 2014"]], "COMMENTS": "21 pages. ICCBR 2014", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["liang chang", "uli sattler", "tianlong gu"], "accepted": false, "id": "1405.4180"}, "pdf": {"name": "1405.4180.pdf", "metadata": {"source": "CRF", "title": "Algorithm for Adapting Cases Represented in a Tractable Description Logic", "authors": ["Liang Chang", "Uli Sattler", "Tianlong Gu"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n41 80\nv1 [\ncs .A\nI] 1\n6 M\nay 2\n01 4"}, {"heading": "1 Introduction", "text": "Description logic (DL) is a family of logics for representing and reasoning about knowledge of static application domains [2]. It is playing a central role in the Semantic Web, serving as the basis of the W3C-recommended Web ontology language OWL [10]. The main strength of DLs is that they offer considerable expressive power often going far beyond propositional logic, while reasoning is still decidable. Furthermore, DLs have well-defined semantics and are supported by many efficient reasoners.\nIn the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18]. CBR is a type of analogical reasoning in which new problem is solved by reusing past experiences called source cases. There are two basic tasks in the CBR inference: retrieval and adaptation. Retrieval aims at selecting a source case that is similar to the new problem according to some similarity criterion. Adaptation aims at generating a solution for the new problem by adapting the solution contained in the source case. At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].\nIn comparison to retrieval, adaptation is often considered to be the more difficult task. One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12]. In propositional logic, there are many revision operators which satisfy the AGM postulates and can be applied to complete the adaptation task [16]. However, in DLs, it is very difficult to design revision operators and algorithms that satisfy the AGM postulates [8]. Especially, it is a great challenge to design revision algorithms that are independent of the syntactical forms of KBs and fine-grained for the minimal change principle.\nThere are two kinds of revision operators and algorithms in the literature: model-based approaches (MBAs) and formula-based approaches (FBAs). Revision operators of MBAs can be treated as DL-based extensions of the classical revision operators in propositional logic, in that the semantics of minimal change is defined by measuring the distance between models [13]. MBAs are syntax-independent and fine-grained, but at present they only work for DLs of the DL-Lite family. In FBAs, the semantics of minimal change is reflected in the minimality of formulas removed by the revision process. There are two FBAs in the literature. One is based on the deductive closure of a KB [4,15]; it is syntax-independent and fine-grained, but again only works for DLs of the DLLite family. Another is based on justifications [20]; although it is applicable to DLs such as SHOIN , it is syntax-dependent and not fine-grained.\nDLs of the EL family are popular for building large-scale ontologies [3]. Some important medical ontologies and life science ontologies are built in EL, such as the SNOMED CT [19] and the Gene Ontology [6]. A feature of this family of DLs is that they allow for reasoning in polynomial time, while being able to describe \u201crelational structures\u201d. They are promising DLs for CBR since they are, on the one hand, of interesting expressive power (orthogonal to DL-Lite) and, on the other hand, restricted enough so that we can hope for a practical adaptation approach. In the literature, some good results on introducing DLs of the EL family into the retrieval of source cases have been presented [18]; the problem of measuring the similarity of concepts in these DLs is also well-studied [14]. However, adaptation based on these DLs is still an open problem. The reason is that existing revision operators, to the best of our knowledge, are not syntax-independent and fine-grained.\nIn this paper we present a new method for adaptation in the DL EL\u22a5 of the EL family. Our contributions regard three aspects. Firstly, we extend the logical basis for describing cases from propositional logic to the DL EL\u22a5, with a powerful way of describing cases as ABoxes in DL. Secondly, we extend the \u201cadaptation as KB revision\u201d view from [16] to the above setting and get a formalism for adaptation based on EL\u22a5. Finally, for the adaptation setting we provide an adaptation algorithm. Our algorithm is syntax-independent and fine-grained, and satisfies the requirements on revision operators."}, {"heading": "2 The Description Logic EL\u22a5", "text": "The DL EL\u22a5 extends EL with bottom concept (and consequently disjointness statements) [3]. Let NC , NR and NI be disjoint sets of concept names, role names and individual names, respectively. EL\u22a5-concepts are built according to the following syntax rule C ::= \u22a4 | \u22a5 |A | C \u2293D | \u2203r.C, where A \u2208 NC , r \u2208 NR, and C,D range over EL\u22a5-concepts.\nA TBox T is a finite set of general concept inclusions (GCIs) of the form C \u2291 D, where C and D are concepts. An ABox A is a finite set of concept assertions of the form C(a) and role assertions of the form r(a, b), where a, b \u2208 NI , r \u2208 NR, and C is a concept. A knowledge base (KB) is a pair K = \u3008T ,A\u3009.\nExample 1. Consider the example on breast cancer treatment discussed in [16]. We add some background knowledge to it and describe the knowledge by the following GCIs in a TBox T :\nTamoxifen \u2291 Anti-oestrogen, Anti-aromatases \u2291 Anti-oestrogen,\nTamoxifen \u2291 \u2203metabolizedTo.(Compounds\u2293 \u2203bindto.OestrogenReceptor),\n(\u2203hasGene.CY P2D6) \u2293 (\u2203TreatBy.Tamoxifen) \u2291 \u22a5.\nThese GCIs state that both tamoxifen and anti-aromatases are anti-estrogens; tamoxifen can be metabolized into compounds which will bind to the oestrogen receptor; and tamoxifen is contraindicated for people with the gene CYP2D6.\nSuppose Mary is a patient with the gene CYP2D6 and with some symptom captured by a concept Symp. Then we can describe these information by an ABox N = {Symp(Mary), \u2203hasGene.CY P2D6(Mary)}. \u2293\u2294\nThe semantics is defined by means of an interpretation I = (\u2206I , \u00b7I), where the interpretation domain \u2206I is a non-empty set composed of individuals, and \u00b7I is a function which maps each concept name A \u2208 NC to a set AI \u2286 \u2206I , maps each role name r \u2208 NR to a binary relation rI \u2286 \u2206I \u00d7\u2206I , and maps each individual name a \u2208 NI to an individual aI \u2208 \u2206I . The function \u00b7I is inductively extended to arbitrary concepts as follows:\n\u2013 \u22a4 := \u2206I , \u2013 \u22a5 := \u2205, \u2013 (C \u2293D)I := CI \u2229DI , and \u2013 (\u2203r.C)I := {x \u2208 \u2206I | there exists y \u2208 \u2206I such that (x, y) \u2208 rI and y \u2208 CI}.\nThe satisfaction relation \u201c|=\u201d between any interpretation I and any GCI C \u2291 D, concept assertion C(a), role assertion r(a, b), TBox T or ABox A is defined inductively as follows: I |= C \u2291 D iff CI \u2286 DI ; I |= C(a) iff aI \u2208 CI ; I |= r(a, b) iff (aI , bI) \u2208 rI ; I |= T iff I |= X for every X \u2208 T ; and I |= A iff I |= X for every X \u2208 A.\nI is a model of a KB K = \u3008T ,A\u3009 if I |= T and I |= A. We use mod(K) to denote the set of models of KB K. Two KBs K1 and K2 are equivalent (written K1 \u2261 K2) iff mod(K1) = mod(K2).\nThere are many inference problems on DLs. Here we only introduce consistency and entailment. A KB K = \u3008T ,A\u3009 is consistent (or A is consistent w.r.t. T ) ifmod(K) 6= \u2205. K entails a GCI, assertion or ABox X (written K |= X) if I |= X for every I \u2208 mod(K). For these two inference problems the following results hold: a KB K is inconsistent iff K |= \u22a4 \u2291 \u22a5 iff K |= \u22a5(a) for some individual name a occurring in K. If K is inconsistent, then we say that K entails a clash.\nExample 2. Consider the TBox T and ABoxN presented in Example 1. Suppose there is an ABox A = {TreatBy(Mary, y), T amoxifen(y)} and a KB K = \u3008T ,A\u222aN\u3009. It is obvious that K is inconsistent and entails a clash. More precisely, we have that K |= \u22a4 \u2291 \u22a5 and K |= \u22a5(Mary). \u2293\u2294\nLet X be a concept, GCI, assertion, TBox, ABox or KB. Then NXC (resp., NXR , N X I ) is the set of concept names (resp., role names, individual names) occurring in X , and sig(X) = NXC \u222aN X R \u222aN X I .\nFor any concept C, the role depth rd(C) is the maximal nesting depth of \u2203 in C. Let X be a GCI, assertion, TBox, ABox or KB. Then sub(X) is the set of all subconcepts occurring in X , and depth(X) = max{rd(C) | C \u2208 sub(X)}."}, {"heading": "3 Formalization of Adaptation Based on EL\u22a5", "text": "In this section we present a formalism for adaptation based on EL\u22a5. There are many different approaches for the formalization of adaptation in CBR. Here we follow the approach presented in [16] to formulate adaptation as knowledge base revision, with the difference that our formalism is based on the DL EL\u22a5 instead of propositional logic.\nThe basic idea of CBR is to solve similar problems with similar solutions. The new problem that needs to be solved is called target problem. The problems which have been solved and stored are called source problems. Each source problem srce has a solution solsrce, and the pair (srce, solsrce) is called a source case. A finite set of source cases forms a case base. Given a target problem tgt, the retrieval step of CBR will pick out a source case (srce, solsrce) according to the similarity between target problem and source problem, and the adaptation step will generate a solution soltgt for tgt by adapting solsrce.\nIn [16], the adaptation process is modeled as KB revision in propositional logic. More precisely, let two formulas kb1 = srce \u2227 solsrce and kb2 = tgt, then the solution soltgt is generated by calculating (dk \u2227 kb1) \u25e6 (dk \u2227 kb2), where dk is the domain knowledge, and \u25e6 is a revision operator that satisfies the AGM postulates in propositional logic.\nHere, after introducing the DL EL\u22a5 into CBR, knowledge in a CBR system is composed of three parts:\n\u2013 the domain or background knowledge which is represented as a TBox T ; \u2013 the knowledge about case base in which each source case is described by a\npair of ABoxes (srce, sol), where srce describes the source problem and sol describes the solution;\n\u2013 the knowledge about target problem described by an ABox tgt.\nWith such a framework, given a target problem tgt, we can make use of similarity-measuring algorithms presented in the literature [18,14] to select a source case (srce, sol) such that, by treating individual names occurring in srce as variables, there exists a substitution \u03c3 such that \u03c3(srce) and tgt has the maximum similarity. The retrieval algorithm applies \u03c3 on sol and return \u03c3(sol) as a possible solution for the target problem. Since retrieval algorithm is not the topic of this paper, we do not discuss it in detail here.\nNow suppose a possible solution has been returned by the retrieval algorithm, we defined adaptation setting as follows.\nDefinition 1. An adaptation setting based on EL\u22a5 is a triple AS = (T ,A,N ), where T is a TBox describing the domain knowledge of the CBR system, N is an ABox describing the target problem, and A is an ABox describing the possible solution returned by retrieval algorithm.\nAn ABox A\u2032 is a solution for an adaptation setting AS = (T ,A,N ) if it satisfies the following requirements:\n(R1) \u3008T ,A\u2032\u3009 |= N ; (R2) A\u2032 = A\u222aN if A \u222aN is consistent w.r.t. T ; (R3) if N is consistent w.r.t. T then A\u2032 is also consistent w.r.t. T .\nThe adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12]. More precisely, R1 specifies that a revision result must entail the new information N ; R2 states that the revision operator should not change the KB \u3008T ,A\u222aN\u3009 if there is no conflict; R3 states that the revision operator must preserve the consistency of KBs.\nFrom the point of view of adaptation, the requirements on solutions are explained as follows [16]. If R1 is violated, then it means that the adaptation process failed to solve the target problem. R2 states that if the possible solution does not contradict the target problem w.r.t. the background knowledge, then it can be applied directly to the target problem. R3 states that whenever the description of the target problem is consistent w.r.t. the domain knowledge, the adaptation process provides satisfiable result.\nIn the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20]. However, in practice, besides these three necessary requirements, we hope that the adaptation algorithm satisfies two more requirements.\nFirstly, the adaptation algorithm should be syntax-independent. More precisely, if the descriptions of two target problems are essentially the same w.r.t. the domain knowledge, then we hope that the adaptation process will generate the same solution for these two problems. Under the framework of adaptation setting, we formalize this requirement as follows:\n(R4) for any adaptation setting AS1 = (T ,A1,N1) satisfying \u3008T ,A1\u3009 \u2261 \u3008T ,A\u3009 and \u3008T ,N1\u3009 \u2261 \u3008T ,N\u3009, there always exists a solution A\u20321 such that \u3008T ,A \u2032 1\u3009 \u2261\n\u3008T ,A\u2032\u3009.\nSecondly, the adaptation algorithm should guarantee a minimal change so that the experience contained in the solution of source cases is preserved as much as possible. Taking the adaptation setting AS = (T ,A,N ) as an example, if we do not introduce the requirement on minimal change, then in the case that A \u222a N is inconsistent w.r.t. T , the ABox N is a solution according to the definition. However, it is not a good solution obviously, since information contained in A is completely lost.\nWe hope to specify the requirement on minimal change formally. However, it is non-trivial to do it in a framework based on DLs. One reason is that there are different approaches to define minimality, and it is well-accepted that there is no general notion of minimality that will do the right thing under all circumstances [4]. Therefore, under the framework of adaptation setting, we only specify this requirement as follows:\n(R5) the change from the KB \u3008T ,A\u3009 to the KB \u3008T ,A\u2032\u3009 is minimal.\nTo sum up, given an adaptation setting, we hope to generate a solution which not only satisfies R1-R3 specified in Definition 1, but also satisfies R4 and some reading of R5.\nBefore the end of this section, we look an example of adaptation setting.\nExample 3. Consider the TBox T and ABox N presented in Example 1. Suppose N is a description of the target problem. Suppose many successful treatment cases are recorded in the case base, and from them a possible solution A = {TreatBy(Mary, y), T amoxifen(y)} is returned by the retrieval algorithm. Then we get an adaptation setting AS = (T ,A,N ). \u2293\u2294"}, {"heading": "4 Existing Approaches to Instance-Level Revision", "text": "As we mentioned in Section 1, there exist two groups of revision operators and algorithms for DLs in the literature. In this section, we show that they either do not support the DL EL\u22a5 or do not satisfy R4 and R5."}, {"heading": "4.1 Model-based Approaches", "text": "MBAs define revision operators over the distance between interpretations [13]. In propositional logic, it is easy to measure the distance between interpretations and to calculate the revision results based on the distance [12], since each interpretation is only a truth assignment on propositional symbols. However, in DLs, it becomes very complex.\nFor an adaptation setting AS = (T ,A,N ), let M be the set of all interpretations that satisfy both the solutions and the TBox T . Then, with MBAs, M is the set of models of \u3008T ,N\u3009 that are minimally distant from the models of \u3008T ,A\u3009 [13], i.e.,\nM = {J \u2208 mod(\u3008T ,N\u3009) | there exists I \u2208 mod(\u3008T ,A\u3009) such that dist(I,J ) =\nmin{dist(I \u2032,J \u2032) | I \u2032 \u2208 mod(\u3008T ,A\u3009),J \u2032 \u2208 mod(\u3008T ,N\u3009)} }.\nLet \u03a3 be the set of concept names and role names occurring in AS. There are four different approaches for measuring the distance dist(I,J ):\n\u2013 dists\u266f(I,J ) = \u266f{X \u2208 \u03a3 | X I 6= XJ }, \u2013 dists\u2286(I,J ) = {X \u2208 \u03a3 | X I 6= XJ }, \u2013 dista\u266f (I,J ) = sum X\u2208\u03a3 \u266f(XI \u2296XJ ), \u2013 dista\u2286(I,J , X) = X I \u2296XJ for every X \u2208 \u03a3,\nwhere XI\u2296XJ = (XI\u2212XJ )\u222a(XJ \u2212XI). Distances under dists\u266f and dist a \u266f are natural numbers and are compared in the standard way. Distances under dists\u2286 are sets and are compared by set inclusion. Distances under dista\u2286 are compared as follows: dista\u2286(I1,J1) \u2264 dist a \u2286(I2,J2) iff dist a \u2286(I1,J1, X) \u2286 dist a \u2286(I2,J2, X) for every X \u2208 \u03a3. It is assumed that the interpretations of individual names are fixed. In [13], the above four different semantics for MBAs are denoted as Gs\u266f , Gs\u2286, G a \u266f , and G a \u2286 respectively.\nUnder the framework of adaptation setting, we need to find a finite number of ABoxes A\u2032i (1 \u2264 i \u2264 n) such that sig(A \u2032 i) \u2286 sig(T ) \u222a sig(A) \u222a sig(N ) and M = \u22c3\n1\u2264i\u2264n\nmod(\u3008T ,A\u2032i\u3009).\nExample 4. Consider an adaptation setting AS1 = (T1,A1,N1), where\nT1 = {A \u2291 \u2203R.A, A \u2291 C, E \u2293 \u2203R.A \u2291 \u22a5}, A1 = {A(a)}, N1 = {E(a)}.\nLet \u03a3 = {A,C,E,R}. Firstly, we investigate the semantics Gs\u2286 and G s \u266f . It is obvious that, for any interpretations I \u2208 mod(\u3008T1,A1\u3009) and J \u2208 mod(\u3008T1,N1\u3009), it must be AI 6= AJ and EI 6= EJ . Therefore, {A,E} is the minimal set of signatures whose interpretations must be changed. So, under both Gs\u2286 and G s \u266f , we have that"}, {"heading": "M = {J \u2208 mod(\u3008T1,N1\u3009) | there exists I \u2208 mod(\u3008T1,A1\u3009) such that", "text": "XI = XJ for any X \u2208 \u03a3 \\ {A,E}}.\nNow, for every positive integer k, let us construct an interpretation Ik = (\u2206Ik , \u00b7Ik) as \u2206Ik = {p1, ..., pk}, a Ik = p1, A Ik = \u2205, EIk = {p1}, C\nIk = {p1, ..., pk}, and RIk = {(p1, p2), ..., (pk\u22121, pk), (pk, pk)}. At the same time, be corresponding to each Ik, construct another interpretation I \u2032k = (\u2206 I\u2032 k , \u00b7I \u2032 k) as \u2206I \u2032 k = \u2206Ik , aI \u2032 k = p1, A I\u2032 k = {p1, ..., pk}, EI \u2032 k = \u2205, CI \u2032 k = CIk , and RI \u2032\nk = RIk . Then, it is obvious that Ik \u2208 mod(\u3008T1,N1\u3009), I \u2032 k \u2208 mod(\u3008T1,A1\u3009), and Ik \u2208 M.\nIn the case that k = 1, we can construct an ABox A\u20321 = {E(a), C(a), R(a, a)} so that I1 is contained in mod(\u3008T1,A\u20321\u3009). However, for any k \u2265 2, it is impossible to find an ABox A\u2032i such that sig(A \u2032 i) \u2286 \u03a3 \u222a {a} and Ik \u2208 mod(\u3008T1,A \u2032 i\u3009). So, solutions of adaptation under Gs\u2286 and G s \u266f is not expressible.\nSecondly, we investigate the semantics Ga\u2286 and G a \u266f . It is obvious that, for any interpretations I \u2208 mod(\u3008T1,A1\u3009) and J \u2208 mod(\u3008T1,N1\u3009), it must be aI /\u2208\nEI and aJ /\u2208 AJ . Therefore {A(a), E(a)} is the minimal set of atoms whose interpretations must be changed. So, under both Ga\u2286 and G a \u266f , we have that\nM = {J \u2208 mod(\u3008T1,N1\u3009) | there exists I \u2208 mod(\u3008T1,A1\u3009) such that\nAI \u2296AJ = EI \u2296 EJ = {aI}, and\nXI = XJ for any X \u2208 \u03a3 \\ {A,E}}.\nFrom M we can construct an ABox A\u20321 = {E(a), C(a), R(a, a)} so that M = mod(\u3008T1,A\u20321\u3009). Therefore, under both G a \u2286 and G a \u266f , A \u2032 1 is a solution for the adaptation setting. This result is very strange, since during the adaptation process there seems to be no \u201cgood\u201d reason to enforce the assertion R(a, a) to hold. \u2293\u2294\nTo sum up, there are four notions of computing models in existing MBAs. For the adaptation based on EL\u22a5, two notions suffer from inexpressibility and the other two notions are semantically questionable."}, {"heading": "4.2 Formula-based Approaches", "text": "In the literature there are two typical formula-based approaches for instance-level revision in DLs.\nThe first one is based on deductive closures [4,15]. Under the framework studied in our paper, given an adaptation setting AS = (T ,A,N ), this approach will firstly calculates the deductive closure of A w.r.t. T (denoted clT (A)); then it computes a maximal subsetAm of clT (A) that does not conflict withN and T ; and finally returns Am \u222a N as a solution. Such an approach behaves well in DLs of the DL-Lite family, where clT (A) is finite and can be calculated effectively. However, it does not work in EL\u22a5, since clT (A) is infinite in EL\u22a5 and can not be calculated directly. Therefore, it can not be applied for solving our problem.\nThe second FBA is based on justifications (also known as MinAs or kernel) [20]. Under the framework studied here, given an adaptation setting AS = (T ,A,N ), this approach will firstly construct a KB K0 = \u3008T ,A\u222aN\u3009, and find all the minimal subsets of K0 that entail a clash (i.e., all justifications for clashes); then it will compute a minimal set R \u2286 A which contains at least one element from each justification (such a set is also called a repair); and finally returns (A\u222aN ) \\R as a solution. This approach is applicable to DLs such as SHOIN , and obviously can deal with EL\u22a5. However, as shown by the following examples, it is syntax-dependent and not fine-grained, and therefore does not satisfy our requirements specified by R4 and R5.\nExample 5. Consider the adaptation setting AS1 = (T1,A1,N1) described in the previous example. It is obvious that \u3008T1,A1 \u222a N1\u3009 |= \u22a5(a) and for which there is only one justification J = {A \u2291 \u2203R.A,E \u2293 \u2203R.A \u2291 \u22a5, A(a), E(a)}.\nSince T1 is fixed and E(a) \u2208 N1, the only choice is to remove A(a) from A1 \u222a N1 and get the solution A\u20321 = {E(a)}. This result is not so good, since it loses many information which is entailed by the KB \u3008T1,A1\u3009 and not conflicted with N1, such as the concept assertions C(a) and \u2203R.C(a). In other words, this result does not satisfy R5. \u2293\u2294\nExample 6. Consider another adaptation setting AS2 = (T2,A2,N2), where T2 = T1, N2 = N1 and A2 = {A(a), C(a), \u2203R.C(a)}. It is obvious that \u3008T1,A1\u3009 \u2261 \u3008T2,A2\u3009 and \u3008T1,N1\u3009 \u2261 \u3008T2,N2\u3009.\nNow, apply the FBA based on justifications again, we will get a solution A\u20322 = {E(a), C(a), \u2203R.C(a)}. This solution is essentially different from the solution A\u20321 = {E(a)} of AS1, since \u3008T1,A \u2032 1\u3009 6\u2261 \u3008T2,A \u2032 2\u3009. So, the FBA based on justifications does not satisfy R4. It is unhelpful that we get two different solutions for two target problems which are essentially the same. \u2293\u2294\nTo sum up, for the adaptation based on EL\u22a5, existing FBAs either can not be applied directly, or can be applied but is syntax-dependent and not fine-grained."}, {"heading": "5 Our Approach for Adaptation Based on EL\u22a5", "text": "In this section we present an algorithm for adaptation based on EL\u22a5. Our algorithm is based on a structure named revision graph, which is close to the completion graph used in classical tableau decision algorithms of DLs [11]. We firstly introduce some notions and operations on this structure, then present the algorithm, and finally discuss two examples."}, {"heading": "5.1 Notions and Operations on Revision Graph", "text": "A revision graph for EL\u22a5 is a directed graph G = (V,E,L), where\n\u2013 V is a finite set of nodes composed of individual names and variables; \u2013 E \u2286 V \u00d7 V is a set of edges satisfying:\n\u2022 there is no edge from variables to individual names, and \u2022 for each variable y \u2208 V , there is at most one node x with \u3008x, y\u3009 \u2208 E;\n\u2013 each node x \u2208 V is labelled with a set of concepts L(x); and \u2013 each edge \u3008x, y\u3009 \u2208 E is labelled with a set of role names L(\u3008x, y\u3009); further-\nmore, if y is a variable then \u266fL(\u3008x, y\u3009) = 1.\nFor each edge \u3008x, y\u3009 \u2208 E, we call y a successor of x and x a predecessor of y. Descendant is the transitive closure of successor.\nFor any node x \u2208 V , we use level(x) to denote the level of x in the graph, and define it inductively as follows: level(x) = 0 if x is an individual name, and level(x) = level(y) + 1 if x is a variable with a predecessor y.\nA graph B = (V \u2032, E\u2032,L\u2032) is a branch of G if B is a tree and a subgraph of G. A branch B1 = (V1, E1,L1) is subsumed by another branch B2 = (V2, E2,L2) if B1 and B2 have the same root node, \u266f(V1 \u2229 V2) = 1, and there is a function f : V1 \u2192 V2 such that: f(x) = x if x is the root node, L1(x) \u2286 L2(f(x)) for every node x \u2208 V1, \u3008f(x), f(y)\u3009 \u2208 E2 for every edge \u3008x, y\u3009 \u2208 E1, and L1(\u3008x, y\u3009) \u2286 L2(\u3008f(x), f(y)\u3009) for every edge \u3008x, y\u3009 \u2208 E1.\nA branch B is redundant in G if every node in B except the root is a variable, and B is subsumed by another branch in G.\nRevision graphs can be seen as ABoxes with variables. Given a revision graph G = (V,E,L), we call AG = \u22c3\nx\u2208V\n{C(x) | C \u2208 L(x)} \u222a \u22c3\n\u3008x,y\u3009\u2208E\n{R(x, y) | R \u2208\nL(\u3008x, y\u3009)} as the ABox representation of G, and call G as the revision-graph representation of AG .\nGiven a KB K = \u3008T ,A\u3009 and a non-negative integer k, we use procedure B-MW(K, k) to construct a revision graph for them.\nProcedure B-MW(K, k)\nInput: a KB K = \u3008T ,A\u3009 and a non-negative integer k. Output: a revision graph G = (V,E,L).\n1 Initialize the revision graph G = (V,E,L) as\n\u2013 V = NKI , \u2013 L(a) = {C | C(a) \u2208 A} for each node a \u2208 V , \u2013 E = {\u3008a, b\u3009 | there is some R with R(a, b) \u2208 A}, \u2013 L(\u3008a, b\u3009) = {R | R(a, b) \u2208 A} for each edge \u3008a, b\u3009 \u2208 E.\n2 while there exists an expansion rule in Fig. 1 that is applicable to G do expand G by applying this rule.\n3 for each node x \u2208 V do L(x) = {C \u2208 L(x) | C is a concept name }.\n4 while there exists a redundant branch B = (VB, EB,LB) in G do E = E \\ EB; V = V \\ (VB \\ {xB}), where xB is the root of B.\n5 Return G = (V,E,L).\nIt is easy to prove the following property.\nProposition 1. Given a KB K and a non-negative integer k, let G = B-MW(K, k), and let AG be the ABox representation of G. Then, for any ABox assertion \u03b1 with sig(\u03b1) \u2286 sig(K) and depth(\u03b1) \u2264 k, K |= \u03b1 iff \u3008\u2205,AG\u3009 |= \u03b1.\nBased on this property, given an adaptation setting AS = (T ,A,N ), we can firstly construct a revision graph G = B-MW(\u3008T ,A\u3009, k) for some well selected integer k, and then realize adaptation by computing a maximal subset Am of AG that does not conflict with N .\nBecause Am is an ABox that may contain variables, we use the following procedure to roll up variables contained in it.\nProcedure Rolling(Am, T )\nInput: an ABox Am that may contain variables, and a TBox T . Output: an ABox A0 without variables.\n1 Transform Am into its revision-graph representation G = (V,E,L). 2 Delete from V the variables which are not descendants of any individual name. 3 while there exists variable in V do\nselect a variable y \u2208 V that has no successor; x = the predecessor of y; if L(y) 6= \u2205 then Cy = d\nC\u2208L(y)"}, {"heading": "C else Cy = \u22a4;", "text": "R = the role name contained in L(\u3008x, y\u3009); if \u3008T , {D(x) | D \u2208 L(x)}\u3009 6|= (\u2203R.Cy)(x) then L(x) = L(x) \u222a {\u2203R.Cy}; E = E \\ {\u3008x, y\u3009}; V = V \\ {y}.\n4 Return A0 = \u22c3\nx\u2208V\n{C(x) | C \u2208 L(x)} \u222a \u22c3\n\u3008x,y\u3009\u2208E\n{R(x, y) | R \u2208 L(\u3008x, y\u3009)}."}, {"heading": "5.2 The Revision Algorithm", "text": "Let T be a TBox, and let A, N be two ABoxes. If \u3008T ,A\u222aN\u3009 |= \u22a4 \u2291 \u22a5, then:\n\u2013 a set J \u2286 A is a (A,N )-justification for a clash w.r.t. T if \u3008T ,J \u222a N\u3009 |= \u22a4 \u2291 \u22a5 and \u3008T ,J \u2032 \u222a N\u3009 6|= \u22a4 \u2291 \u22a5 for every J \u2032 \u2282 J ; \u2013 a set R \u2286 A is a (A,N )-repair for clashes w.r.t. T if \u266f(R\u2229J ) = 1 for every (A,N )-justification J .\nNow we are ready to present our algorithm for adaptation based on EL\u22a5.\nAlgorithm 1: Adaptation(AS, k)\nInput: an adaptation setting AS = (T ,A,N ), and a non-negative integer k. Output: a finite number of pairs (A\u2032\u20321 ,R1), ..., (A \u2032\u2032 n,Rn), where A \u2032\u2032 i is a solution and Ri records the information been removed. if A \u222a N is consistent w.r.t. T then\nreturn (A \u222aN , \u2205); else\nG = B-MW(\u3008T ,A\u3009, k); AG = the ABox representation of G; SR = {R1, ...,Rn} all the (AG ,N )-repairs for a clash w.r.t. T ; for i \u2190 1 to n do\nAi = AG \\ Ri; A\u2032i = Rolling(Ai, T );\nreturn (A\u20321 \u222a N ,R1), ..., (A \u2032 n \u222aN ,Rn).\nGiven an adaptation setting AS = (T ,A,N ), our algorithm will firstly construct a revision graph G according to the KB \u3008T ,A\u3009 and some integer k, where\nk is required to be greater than the role depthes of all the concepts occurring in the adaptation setting. Secondly, a revision process based on justifications will be carried out on the ABox representation AG of G. Thirdly, for each maximal subset Ai of AG that does not conflict with N and T , the procedure Rolling(Ai, T ) will be used to roll up variables and get an ABox A\u2032i. Finally, the ABox A \u2032 i \u222a N will be returned as a solution for the adaptation setting; together with the solution, an ABox Ri which records the information been removed from the solution of source problem is also displayed, so that the user can determine the best solution according to it.\nThe following theorems state that our algorithm satisfies R1-R4.\nTheorem 1. Let (A\u2032\u2032i ,Ri) (1 \u2264 i \u2264 n) be the pairs returned by Adaptation(AS , k) for AS = (T ,A,N ). Then the following statements hold for every 1 \u2264 i \u2264 n: (1) \u3008T ,A\u2032\u2032i \u3009 |= N ; (2) A \u2032\u2032 i = A \u222a N if A \u222a N is consistent w.r.t. T ; and (3) if N is consistent w.r.t. T then A\u2032\u2032i is also consistent w.r.t. T .\nTheorem 2. Given two adaptation settings ASi = (T ,Ai,Ni) (i = 1, 2) and an integer k satisfying k \u2265 depth(T ), k \u2265 depth(Ai), and k \u2265 depth(Ni) (i = 1, 2). Let (A\u2032\u20321 ,R1) be a pair returned by Adaptation(AS1, k). If \u3008T ,A1\u3009 \u2261 \u3008T ,A2\u3009 and \u3008T ,N1\u3009 \u2261 \u3008T ,N2\u3009, then there must be a pair (A\u2032\u20322 ,R2) returned by Adaptation(AS2, k) such that \u3008T ,A\u2032\u20321 \u3009 \u2261 \u3008T ,A \u2032\u2032 2 \u3009 and R2 = \u03c3(R1) for some substitution \u03c3 of variables.\nTheorem 2 is based on the following fact: let Gi = B-MW(\u3008T ,Ai\u3009, k) (i = 1, 2), then G1 and G2 are identical up to variable renaming in the case that k is sufficiently large. There is no requirement on the value of k in Theorem 1.\nIn our algorithm, the revision graph G constructed by the procedure BMW(\u3008T ,A\u3009, k) is in fact a non-redundant k-depth-bounded model for the KB \u3008T ,A\u3009. Therefore, our revision process works on fine-grained representation of models and guarantees the minimal change principle in a fine-grained level. So, our algorithm satisfies the property specified by R5.\nThe following theorem states that our algorithm is in exponential time.\nTheorem 3. For any adaptation setting AS = (T ,A,N ), assume the role depth of every concept occurring in AS is bounded by some integer k, then the algorithm Adaptation(AS , k) runs in time exponential with respect to the size of AS."}, {"heading": "5.3 Examples", "text": "Example 7. Consider the adaptation setting AS1 = (T1,A1,N1) described in Example 4. Since max{depth(T1), depth(A1), depth(N1)} = 1, we let k=1 and execute the algorithm Adaptation(AS1, k).\nFirstly we call the procedure B-MW(\u3008T1,A1\u3009, k) to construct a revision graph G. Two variables x1, x2 are introduced during this procedure. By treating G as an ABox, we getAG = {A(a), C(a), R(a, x1), A(x1), C(x1), R(x1, x2), A(x2), C(x2)}.\nSecondly, for the clash AG \u222a N1 |=T1 \u22a4 \u2291 \u22a5, there are two (AG ,N1)justifications J1 = {A \u2291 \u2203R.A, E \u2293 \u2203R.A \u2291 \u22a5, E(a), A(a)} and J2 = {E \u2293\n\u2203R.A \u2291 \u22a5, E(a), A(a), R(a, x1), A(x1)}. Based on them we get two (AG ,N1)repairs R1 = {A(a), A(x1)} and R2 = {A(a), R(a, x1)}.\nThirdly, from R1 we get A1 = AG \\R1 = {C(a), R(a, x1), C(x1), R(x1, x2), A(x2), C(x2)}, and then get A \u2032 1 = Rolling(A1, T1) = {C(a), \u2203R.(C\u2293\u2203R.A)(a)}. From R2, we get A2 = AG \\R2 = {C(a), A(x1), C(x1), R(x1, x2), A(x2), C(x2)} and A\u20322 = Rolling(A2, T1) = {C(a)}.\nFinally, the algorithm returns (A\u20321 \u222a N1,R1) and (A \u2032 2 \u222a N1,R2).\nNow R2 contains a role assertion R(a, x1) which indicates that all the information related to x1 is lost in A\u20322 \u222aN1, hence A \u2032 2 is rather weak (in fact weaker than A\u20321). Thus the user should select (A \u2032 1 \u222a N1,R1) and get a solution A \u2032\u2032 1 = A\u20321 \u222a N1 = {E(a), C(a), \u2203R.(C \u2293 \u2203R.A)(a)}. \u2293\u2294\nLooking back Example 4 and Example 5, given the same adaptation setting AS1 = (T1,A1,N1), the solution generated by MBAs under the semantics Ga\u2286 and Ga\u266f is A \u2032 1 = {E(a), C(a), R(a, a)}; the solution generated by the FBA based on justifications is A\u20321 = {E(a)}. Obviously, our algorithm is more fine-grained.\nExample 8. Consider the adaptation setting AS = (T ,A,N ) constructed in Example 1. Since max{depth(T ), depth(A), depth(N )} = 2, we let k = 2 and execute the algorithm Adaptation(AS, k).\nBy this algorithm we will get two results (A\u2032\u20321 ,R1) and (A \u2032\u2032 2 ,R2), where R1\n= {Tamoxifen(y)}, A\u2032\u20321 = {C(Mary), \u2203hasGene.CY P2D6(Mary), \u2203TreatBy. (Anti-oestrogen \u2293 \u2203metabolizedTo.(Compounds\u2293\u2203bindto.OestrogenReceptor)) (Mary)},R2 = {TreatBy(Mary, y)}, andA\u2032\u20322 = {C(Mary), \u2203hasGene.CY P2D6 (Mary)}. Since R2 contains a role assertion TreatBy(Mary, y) which indicates that all the information related to y is lost in A\u2032\u20322 , the user should select (A \u2032\u2032 1 ,R1) and get a solution described by A\u2032\u20321 . \u2293\u2294"}, {"heading": "6 Discussion and Related Work", "text": "The idea of applying KB revision theory to adaptation in CBR was proposed by Lieber [16]. Based on a classical revision operator in propositional logic, a framework for adaptation was presented and it was demonstrated that the adaptation process should satisfy the AGM postulates. This idea was extended by Cojan and Lieber [5] to deal with adaptation based on the DL ALC. Based on an extension of the classical tableau method used for deductive inferences in ALC, an algorithm for adapting cases represented in ALC was proposed. It was shown that, except for the requirements on syntax-independence and minimality of change (i.e., R4 and R5 in our paper), all the other requirements specified by the AGM postulates (i.e., R1-R3 in our paper) are satisfied by their algorithm.\nFrom the point of view of KB revision in DLs, it is a great challenge to design revision operators or algorithms that satisfy the requirements specified by the AGM postulates [8]. In the literature, there are two kinds of approaches, i.e., MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs. As we analyzed in Section 4, they either do not satisfy the requirements specified by R4 and R5, or only work well for DLs of the DL-Lite family.\nOur method can be viewed as a combination of MBAs and FBAs. On the one hand, in our algorithm, the revision graph G constructed by the procedure B-MW(\u3008T ,A\u3009, k) can be seen as a non-redundant, k-depth-bounded model for the KB \u3008T ,A\u3009, and therefore our revision process essentially works on models. On the other hand, our revision process makes use of (AG ,N )-repairs which inherits some ideas of FMAs based on justifications. As a result, our algorithm not only satisfies the requirements R4 and R5, but also works for the DL EL\u22a5.\nFor the adaptation setting AS = (T ,A,N ) defined in this paper, A only contains knowledge on the solution of the selected source case. We can define A to contain knowledge on the problem description of the source case also, and the algorithm still works for such a new definition.\nGiven an adaptation setting, our algorithm will return a finite number of pairs (A\u2032\u2032i ,Ri) (1 \u2264 i \u2264 n), and it is left to the user to select the best solution according to the sets Ri. We can extend the algorithm to recommend solutions automatically. For example, if some Ri contains role assertions, then the corresponding solution A\u2032\u2032i will be the last one to be considered. Furthermore, we can define a selection function according to the user\u2019s selection criteria, and enable our algorithm to return only one best solution."}, {"heading": "7 Conclusion and Future Work", "text": "We studied the adaptation problem of CBR in the DL EL\u22a5. A formalism for adaptation based on EL\u22a5 was presented, and in this formalism the adaptation task was modeled as the instance-level KB revision problem in EL\u22a5. We have illustrated that existing revision operators and algorithms in DLs did not work for the adaptation setting based on EL\u22a5. By combining MBAs and FBAs, we presented a new algorithm for the adaptation problem, and showed that our algorithm behaves well for EL\u22a5 in that it satisfies the requirements proposed in the literature for revision operators.\nFor future work, we will extend our method to support adaptation based on EL++ [3]. Another work is to implement and optimize our algorithm and test its feasibility in practice."}, {"heading": "Appendix. Proofs for Propositions and Theorems", "text": "We introduce a lemma for proving Proposition 1.\nLemma 1. Given a KB K = \u3008T ,A\u3009 and a non-negative integer k, let G = (V,E,L) be the revision graph generated after executing Step 2 of the procedure B-MW(K, k), and let AG be the ABox representation of G. Then, for any ABox assertion \u03b1 with sig(\u03b1) \u2286 sig(K) and depth(\u03b1) \u2264 k, K |= \u03b1 iff \u3008\u2205,AG\u3009 |= \u03b1.\nProof. (The If direction) Suppose \u3008\u2205,AG\u3009 |= \u03b1. It is obvious that \u3008T ,AG\u3009 |= \u03b1. We need to show that \u3008T ,A\u3009 |= \u03b1.\nIf A is inconsistent w.r.t. T , then the result is trivial. Now suppose A is consistent w.r.t. T . Let I = (\u25b3I , \u00b7I) be any interpretation with I |= T and I |= A. Let G0 be the revision graph constructed in Step 1 of the procedure B-MW(K, k). Let n be the number of times of applying expansion rules in Step 2, and let Gk (1 \u2264 k \u2264 n) be the revision graph after the i-th expansion. Let Ak (0 \u2264 k \u2264 n) be the ABox representation of Gi. Then we have A0 = A and An = AG .\nFirstly, by induction on k (0 \u2264 k \u2264 n), we show that for each Ak there exists some interpretation Ik = (\u25b3Ik , \u00b7Ik) with\n\u2013 Ik |= T , \u2013 Ik |= Ak, \u2013 \u25b3Ik = \u25b3I , and \u2013 XIk = XI for any X \u2208 sig(K).\n(Base case.) If k = 0, then we can construct I0 = I and get the interpretation we want.\n(Inductive step.) Let Ik = (\u25b3Ik , \u00b7Ik) be an interpretation satisfying the above property. There are two cases to be investigated.\n(Case 1.) Suppose the revision graph Gk+1 is generated by applying the GCIInd-rule, GCIV ar-rule or \u2293-rule on the graph Gk. Then it is obvious that Ik |= Ak+1. Construct Ik+1 = Ik. Then Ik+1 is the interpretation we want.\n(Case 2.) Suppose Gk+1 is generated by applying the \u2203-rule for some node x in Gk and some concept \u2203R.C \u2208 L(x). Let z be the new variable introduced by applying this rule. Since Ik |= Ak, we have Ik |= (\u2203R.C)(x). Therefore, there exists some p \u2208 \u25b3Ik with \u3008xIk , p\u3009 \u2208 RIk and p \u2208 CIk . Construct an interpretation Ik+1 = (\u25b3Ik+1 , \u00b7Ik+1) as follows:\n\u2013 \u25b3Ik+1 = \u25b3Ik , \u2013 XIk+1 = XIk for any X \u2208 sig(T ) \u222a sig(Ak), and \u2013 zIk+1 = p.\nIt is obvious that Ik+1 |= Ak+1 and Ik+1 is the interpretation we want. Secondly, from In |= An, In |= T , An = AG and \u3008T ,AG\u3009 |= \u03b1, we have In |= \u03b1. Furthermore, since sig(\u03b1) \u2286 sig(K) and XIn = XI for any X \u2208 sig(K), we have I |= \u03b1. Therefore, we have \u3008T ,A\u3009 |= \u03b1.\n(The Only-if direction) Suppose \u3008T ,A\u3009 |= \u03b1. We need to show that \u3008\u2205,AG\u3009 |= \u03b1.\nIf AG is inconsistent, then the result is trivial. Now suppose AG is consistent. Let I = (\u25b3\nI , \u00b7I) be any interpretation with I |= AG . Construct a revision graph G\u2032 = (V \u2032, E\u2032,L\u2032) as follows:\n1. Initialize G\u2032 = G. 2. Expand G\u2032 by applying the following rules, until none of these rules is appli-\ncable: \u2013 if C \u2291 D \u2208 T , D /\u2208 L\u2032(x), x /\u2208 NKI , and \u3008T , {E(x) | E \u2208 L\n\u2032(x)}\u3009 |= C(x), then set L\u2032(x) = L\u2032(x) \u222a {D}; \u2013 if C1 \u2293 C2 \u2208 L\u2032(x), and {C1, C2} * L\u2032(x), then set L\u2032(x) = L\u2032(x) \u222a {C1, C2}; \u2013 if \u2203R.C \u2208 L\u2032(x), x has no successor z with C \u2208 L\u2032(z), then introduce a new variable z, set V \u2032 = V \u2032 \u222a {z}, E\u2032 = E\u2032 \u222a {\u3008x, z\u3009}, L\u2032(z) = {C}, and L\u2032(\u3008x, z\u3009) = {R}.\nLet AG\u2032 be the ABox representation of G\u2032. Based on I and G\u2032, construct an interpretation I \u2032 = (\u25b3I \u2032 , \u00b7I \u2032 ) as follows:\n1. Initialize I \u2032 = I. 2. For every x \u2208 V \u2032 \\ V , expand I \u2032 as follows:\n\u2013 set \u25b3I \u2032 = \u25b3I \u2032\n\u222a {x}; \u2013 set xI \u2032\n= x; \u2013 let C1, ..., Cm be all the concept names contained in L\u2032(x), then set CI \u2032\ni\n= CI \u2032\ni \u222a {x} for each 1 \u2264 i \u2264 m; \u2013 let y be the predecessor of x in graph G\u2032, and let R be the concept name\ncontained in L\u2032(\u3008y, x\u3009), then set RI \u2032 = RI \u2032 \u222a {\u3008y, x\u3009}.\nAccording to the above constructions, it is obvious that I \u2032 |= AG\u2032 and I \u2032 |= T . At the same time, we have A \u2286 AG \u2286 AG\u2032 and consequently I \u2032 |= A. Therefore, from \u3008T ,A\u3009 |= \u03b1, we can get I \u2032 |= \u03b1.\nBy investigating the relationship between I and I \u2032, we have the following results:\n\u2013 aI = aI \u2032\nfor every individual name a \u2208 sig(K); \u2013 for every concept name C \u2208 sig(K), x \u2208 CI \u2032\n\\ CI only if level(x) > k, and \u2013 for every role name R \u2208 sig(K), \u3008x, y\u3009 \u2208 RI \u2032 \\RI only if level(y) > k.\nSince sig(\u03b1) \u2286 sig(K) and depth(\u03b1) \u2264 k, from I \u2032 |= \u03b1 we have I |= \u03b1. Therefore, we have \u3008\u2205,AG\u3009 |= \u03b1. \u2293\u2294\nProof of Proposition 1. Let G0 = (V0, E0,L0) be the revision graph generated after executing Step 2 of the procedure B-MW(K, k), and let AG0 be the ABox representation of G0. By Lemma 1, we have K |= \u03b1 iff \u3008\u2205,AG0\u3009 |= \u03b1.\nLet G1 = (V1, E1,L1) be the graph generated by Step 3 of the procedure, and let AG1 be the ABox representation of G1. Based on the expansion rules in Fig. 1, it is obvious that \u3008\u2205,AG0\u3009 |= \u03b1 iff \u3008\u2205,AG1\u3009 |= \u03b1.\nLet G2 = (V2, E2,L2), ..., Gm = (Vm, Em,Lm) be the sequence of all graphs generated during the execution of Step 4 of the procedure B-MW(K, k). Let Gi = (Vi, Ei,Li) (2 \u2264 i \u2264 m) is generated by dropping a redundant branch Bi = (VBi , EBi ,LBi) for which the root node is xi. Let AGi (2 \u2264 i \u2264 m) be the ABox representation of Gi. Then we have Gm = G and AGm = AG .\nFor any concept assertion C(xi) with rd(C) \u2264 k\u2212 level(xi), it is obvious that AGi |= C(xi) iff AGi\u22121 |= C(xi). So, we have \u3008\u2205,AGi\u22121\u3009 |= \u03b1 iff \u3008\u2205,AGi\u3009 |= \u03b1.\nTo sum up, we have K |= \u03b1 iff \u3008\u2205,AG\u3009 |= \u03b1. \u2293\u2294\nWe introduce two lemmas for proving Theorem 1 and Theorem 2.\nLemma 2. Let K = \u3008T ,A\u3009 and K\u2032 = \u3008T ,A\u2032\u3009 be two consistent KBs, let k be an integer with k \u2265 depth(K) and k \u2265 depth(K\u2032). Let G = (V,E,L) and G\u2032 = (V \u2032, E\u2032,L\u2032) be the revision graphs returned by B-MW(K, k) and B-MW(K\u2032, k) respectively. If K \u2261 K\u2032, then there exists a bijection f : V \u2192 V \u2032 such that\n\u2013 f(x) = x if x is an individual name, \u2013 L(x) = L\u2032(f(x)) for every node x \u2208 V , \u2013 \u3008x, y\u3009 \u2208 E iff \u3008f(x), f(y)\u3009 \u2208 E\u2032 for every pair of nodes x, y, and \u2013 L(\u3008x, y\u3009) = L\u2032(\u3008f(x), f(y)\u3009) for every edge \u3008x, y\u3009 \u2208 E.\nProof. We prove the result by constructing the function f : V \u2192 V \u2032. Let AG , AG\u2032 be the ABox representation of G and G\n\u2032 respectively. Then AG and AG\u2032 only contains of role assertions and concept assertions of the form C(x) with C \u2208 NKC . Furthermore, for every individual name x, we have x \u2208 V iff x \u2208 V\n\u2032. Firstly, set f(x) = x for every individual name x in V . Let a be any individual name in V , and let C be any concept name in L(a). By the construction of AG , we have C(a) \u2208 AG and consequently \u3008\u2205,AG\u3009 |= C(a). By Proposition 1, we have \u3008T ,A\u3009 |= C(a). Since K \u2261 K\u2032, we have \u3008T ,A\u2032\u3009 |= C(a). By Proposition 1 again, we have \u3008\u2205,AG\u2032\u3009 |= C(a) and consequently C(a) \u2208 AG\u2032 . By the construction of AG\u2032 , we have C \u2208 L\u2032(a). Therefore, we have L(a) \u2286 L\u2032(a), i.e., L(a) \u2286 L\u2032(f(a)). Similarly, we can get L\u2032(f(a)) \u2286 L(a).\nLet \u3008a, b\u3009 be any edge in E with a, b individual names, and let r be any role name in L(\u3008a, b\u3009). By the construction of AG , we have r(a, b) \u2208 AG and consequently \u3008\u2205,AG\u3009 |= r(a, b). By Proposition 1, we have \u3008T ,A\u3009 |= r(a, b). Since K \u2261 K\u2032, we have \u3008T ,A\u2032\u3009 |= r(a, b). By Proposition 1 again, we have \u3008\u2205,AG\u2032\u3009 |= r(a, b) and consequently r(a, b) \u2208 AG\u2032 . By the construction of AG\u2032 , we have \u3008a, b\u3009 \u2208 E\u2032 and r \u2208 L\u2032(\u3008a, b\u3009). Therefore, we have L(\u3008a, b\u3009) \u2286 L\u2032(\u3008f(a), f(b)\u3009). Similarly, we can get L\u2032(\u3008f(a), f(b)\u3009) \u2286 L(\u3008a, b\u3009).\nTo sum up, we have L(a) = L\u2032(f(a)) for every individual name a. Furthermore, for every pair of individual names a and b, we have \u3008a, b\u3009 \u2208 E iff \u3008f(a), f(b)\u3009 \u2208 E\u2032, and L(\u3008a, b\u3009) = L\u2032(\u3008f(a), f(b)\u3009).\nSecondly, let a1, ..., am be all the individual names contained in V and V \u2032. Let Vi \u2286 V (1 \u2264 i \u2264 m) be a set composed of ai and all the variables which are descendants of ai in G, and let V \u2032i \u2286 V\n\u2032 (1 \u2264 i \u2264 m) be a set composed of ai and all the variables which are descendants of ai in G\u2032. Let Gi (1 \u2264 i \u2264 m) be the subgraph induced on G by the vertex subset Vi, and let G\u2032i (1 \u2264 i \u2264 m)\nbe the subgraph induced on G\u2032 by the vertex subset V \u2032i . For any node x of Gi (1 \u2264 i \u2264 m), let Roll(x) be a concept constructed inductively as follows:\n\u2013 if x has no successor, then Roll(x) = d\nC\u2208L(x)\nC, else\n\u2013 Roll(x) = \u2203r1.Roll(y1) \u2293 ... \u2293 \u2203rt.Roll(yt) \u2293 d\nC\u2208L(x)\nC, where y1, ..., yt are\nall the successors of x in G, and ri (1 \u2264 i \u2264 t) is the role name contained in L(\u3008x, yi\u3009).\nSimilarly, for any node x of G\u2032i (1 \u2264 i \u2264 m), let Roll \u2032(x) be a concept constructed inductively as follows:\n\u2013 if x has no successor, then Roll\u2032(x) = d\nC\u2208L\u2032(x)\nC, else\n\u2013 Roll\u2032(x) = \u2203r1.Roll\u2032(y1) \u2293 ... \u2293 \u2203rt.Roll\u2032(yt) \u2293 d\nC\u2208L\u2032(x)\nC, where y1, ..., yt are\nall the successors of x in G\u2032, and ri (1 \u2264 i \u2264 t) is the role name contained in L\u2032(\u3008x, yi\u3009).\nFor each individual name ai (1 \u2264 i \u2264 m), let Roll(ai) be of the form \u2203r1.Roll(y1) \u2293 ... \u2293 \u2203rt.Roll(yt) \u2293 d\nC\u2208L(ai)\nC, and let Roll\u2032(ai) be of the form\n\u2203r\u20321.Roll \u2032(y\u20321) \u2293 ... \u2293 \u2203r \u2032 s.Roll \u2032(y\u2032s) \u2293 d\nC\u2208L\u2032(ai)\nC. Then we have \u3008\u2205,AG\u3009 |=Roll(ai)(ai)\nand \u3008\u2205,AG\u2032\u3009 |= Roll \u2032(ai)(ai). By Proposition 1, we have \u3008T ,A\u3009 |= Roll(ai)(ai) and \u3008T ,A\u2032\u3009 |= Roll\u2032(ai)(ai). Since K \u2261 K\u2032, we have \u3008T ,A\u2032\u3009 |= Roll(ai)(ai) and \u3008T ,A\u3009 |= Roll\u2032(ai)(ai). By Proposition 1 again, we have \u3008\u2205,AG\u2032\u3009 |= Roll(ai)(ai) and \u3008\u2205,AG\u3009 |= Roll\u2032(ai)(ai). Therefore, it must be t = s. Furthermore, there must be a one-to-one correspondence from {y1, ..., yt} to {y\u20321, ..., y \u2032 s} (w.l.o.g. we assume yi is corresponding to y \u2032 i) such that \u3008\u2205,AG\u2032\u3009 |= Roll(yk)(y \u2032 k), \u3008\u2205,AG\u3009 |= Roll\u2032(y\u2032k)(yk), rk = r \u2032 k, and L(yk) = L\n\u2032(y\u2032k) for every 1 \u2264 k \u2264 t. So, we can continue the construction of the function f , and set f(yk) = y \u2032 k for each node yk (1 \u2264 k \u2264 t). Now, for each node yk (1 \u2264 k \u2264 t), let Roll(yk) be of the form \u2203rk,1.Roll(yk,1) \u2293 ... \u2293 \u2203rk,u.Roll(yk,u) \u2293 d\nC\u2208L(yk)\nC, and let Roll\u2032(y\u2032k) be of the form \u2203r \u2032 k,1.\nRoll\u2032(y\u2032k,1) \u2293 ... \u2293 \u2203r \u2032 k,v.Roll \u2032(y\u2032k,v) \u2293 d\nC\u2208L\u2032(y\u2032 k )\nC. From \u3008\u2205,AG\u2032\u3009 |= Roll(yk)(y \u2032 k)\nand \u3008\u2205,AG\u3009 |= Roll\u2032(y\u2032k)(yk), it must be u = v. Furthermore, there must be a oneto-one correspondence from {yk,1, ..., yk,u} to {y \u2032 k,1, ..., y \u2032 k,v} (w.l.o.g. we assume yk,i is corresponding to y \u2032 k,i) such that \u3008\u2205,AG\u2032\u3009 |= Roll(yk,j)(y \u2032 k,j), \u3008\u2205,AG\u3009 |= Roll\u2032(y\u2032k,j)(yk,j), rk,j = r \u2032 k,j , and L(yk,j) = L\n\u2032(y\u2032k,j) for every 1 \u2264 j \u2264 u. So, we can continue the construction of the function f , and set f(yk,j) = y \u2032 k,j for each node yk,j (1 \u2264 j \u2264 u). Repeat the above process, we can finish the construction of the function f : V \u2192 V \u2032 which satisfies the property stated by the lemma. \u2293\u2294\nLemma 3. For any ABox AG and TBox T , let A be the ABox returned by the procedure Rolling(AG , T ). Then, \u3008T ,AG\u3009 |= A.\nProof. Let G = (V,E,L) be the revision-graph representation of AG . Let G0 = (V0, E0,L0) be the revision graph generated by Step 2 of the procedure. Let n be the number of variables contained in V0, and let Gi = (Vi, Ei,Li) (1 \u2264 i \u2264 n) be the revision graph generated after removing k variables from G0 in Step 3. Let Ai (0 \u2264 i \u2264 n) be the ABox representation of Gi. Then we have An = A.\nIf AG is inconsistent w.r.t. T , then the result trivial. Now suppose AG is consistent w.r.t. T . Let I be any interpretation with I |= T and I |= AG . It is obvious that I |= A0. According to the operations of Step 3, we can get I |= Ai (1 \u2264 i \u2264 n) from I |= T and I |= Ai\u22121. Therefore we have I |= An, i.e., I |= A. So, we have \u3008T ,AG\u3009 |= A. \u2293\u2294\nProof of Theorem 1. The first two statements are obvious. Here we prove the third one.\nSuppose N is consistent w.r.t. T . Then the set SR of (AG ,N )-repairs constructed in Algorithm 1 is not empty. For any Ri \u2208 SR, let Ai = AG \\Ri, then, by the definition of (AG ,N )-repairs, we have that Ai \u222a N is consistent w.r.t. T . Let A\u2032i = Rolling(Ai, T ). By Lemma 3, We have Amin |=T A0. Therefore, A\u2032i \u222a N is also consistent w.r.t. T . So, for each pair (A \u2032\u2032 i ,Ri) returned by the algorithm, A\u2032\u2032i is consistent w.r.t. T . \u2293\u2294\nProof of Theorem 2. Let Gi = B-MW(\u3008T ,Ai\u3009, k), and let AGi be the ABox representation of Gi (i = 1, 2). Since k \u2265 max{depth(T ), depth(A1), depth(N1), depth(A2), depth(N2)}, we know that between G1 and G2 there exists an isomorphism relationship specified by Lemma 2. In other words, there exists a substitution \u03c3 of variables such that \u03c3(AG1 ) = AG2 .\nLet J1 \u2286 AG1 be any (AG1 ,N1)-justification for a clash w.r.t. T , and let J2 = \u03c3(J1). From \u3008T ,N1\u3009 \u2261 \u3008T ,N2\u3009 and \u03c3(AG1) = AG2 , we have that J2 \u2286 AG2 and J2 is a (AG2 ,N2)-justification for a clash w.r.t. T .\nLet R2 = \u03c3(R1). Since R1 is a (AG1 ,N1)-repair for clashes w.r.t. T , from \u3008T ,N1\u3009 \u2261 \u3008T ,N2\u3009 and \u03c3(AG1) = AG2 , we have that R2 \u2286 AG2 and R2 is a (AG2 ,N2)-repair for clashes w.r.t. T .\nLet A1 = AG1 \\ R1 and A2 = AG2 \\ R2. Then we have that A2 = \u03c3(A1). Let A\u20321 = Rolling(A1, T ) and A \u2032 2 = Rolling(A2, T ). Then we have that A \u2032 1 = A\u20322 and A \u2032\u2032 1 = A \u2032 1 \u222a N1.\nNow construct a set A\u2032\u20322 = A \u2032 2 \u222a N2. Then the pair (A \u2032\u2032 2 ,R2) will be returned by Adaptation(AS2, k). Furthermore, since A\u20321 = A \u2032 2 and \u3008T ,N1\u3009 \u2261 \u3008T ,N2\u3009, we have that \u3008T ,A\u2032\u20321 \u3009 \u2261 \u3008T ,A \u2032\u2032 2 \u3009. \u2293\u2294\nProof of Theorem 3. Let k = max{depth(T ),A), depth(N )}. Let T \u2032 be a normal form of T such that there is no conjunction in the right hand side of every GCI contained in it, and let m = |T \u2032|. It is obvious that m is linearly bounded by |T |.\nFor the revision graph G returned by the procedure B-MW(\u3008T ,A\u3009, k), the number of nodes is bounded by |NKI | \u00d7 m\nk+1. Therefore, for the ABox representation AG of G, |AG | is bounded by |A|+ |NKC | \u00d7 |N K I | \u00d7m k+1. Since every\n(AG ,N )-justification and every (AG ,N )-repair is a subset of AG , together with the fact that KB consistency problem is polynomial time in EL\u22a5, we can conclude that the time complexity of Algorithm 1 is O(2|N K C |\u00d7|NK I |\u00d7mk+1). Since k is bounded by some constant, we get the result stated by the theorem. \u2293\u2294"}], "references": [{"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["C.E. Alchourr\u00f3n", "P. G\u00e4rdenfors", "D. Makinson"], "venue": "J. Symb. Log, 50(2), 510-530", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1985}, {"title": "The Description Logic Handbook: Theory, Implementation and Applications", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": "Cambridge University Press, Cambridge", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2003}, {"title": "Pushing the EL envelope", "author": ["F. Baader", "S. Brandt", "C. Lutz"], "venue": "Proc. of the 19th International Joint Conference on Artificial Intelligence, pp. 364-369. Morgan Kaufmann", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2005}, {"title": "Evolution of DL-lite knowledge bases", "author": ["D. Calvanese", "E. Kharlamov", "W. Nutt", "D. Zheleznyakov"], "venue": "Patel-Schneider, P.F., Pan, Y., Hitzler, P., Mika, P., Zhang,  Adapting Cases Represented in a Tractable Description Logic 15 L., Pan, J.Z., Horrocks, I., Glimm, B. (eds.) ISWC 2010. LNCS, vol. 6496, pp. 112-128. Springer, Heidelberg", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2010}, {"title": "An algorithm for adapting cases represented in an expressive description logic", "author": ["J. Cojan", "J. Lieber"], "venue": "Bichindaritz, I., Montani, S. (eds.) ICCBR 2010. LNCS, vol. 6176, pp. 51-65. Springer, Heidelberg", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Gene Ontology: Tool for the unification of biology", "author": ["T.G.O. Consortium"], "venue": "Nature Genetics, 25, 25-29", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2000}, {"title": "Decentralized case-based reasoning for the semantic web", "author": ["M. d\u2019Aquin", "J. Lieber", "A. Napoli"], "venue": "Gil, Y., Motta, E., Benjamins, V.R., Musen, M.A. (eds.) ISWC 2005. LNCS, vol. 3729, pp. 142-155. Springer, Heidelberg", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2005}, {"title": "On applying the AGM theory to DLs and OWL", "author": ["G. Flouris", "D. Plexousakis", "G. Antoniou"], "venue": "Gil, Y., Motta, E., Benjamins, V.R., Musen, M.A. (eds.) ISWC 2005. LNCS, vol. 3729, pp. 216-231. Springer, Heidelberg", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2005}, {"title": "Modelling the CBR life cycle using description logics", "author": ["M. G\u00f3mez-Albarr\u00e1n", "P.A. Gonz\u00e1lez-Calero", "B. D\u00edaz-Agudo", "C. Fern\u00e1ndez-Conde"], "venue": "Althoff, K.-D., Bergmann, R., Karl Branting, L. (eds.) ICCBR 1999. LNCS, vol. 1650, pp. 147-161. Springer, Heidelberg", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1999}, {"title": "From SHIQ and RDF to OWL: the making of a web ontology language", "author": ["I. Horrocks", "P.F. Patel-Schneider", "F.V. Harmelen"], "venue": "J. Web Semantics, 1(1), 7-26", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}, {"title": "A tableau decision procedure for SHOIQ", "author": ["I. Horrocks", "U Sattler"], "venue": "J. Autom. Reasoning, 39(3), 249-276", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2007}, {"title": "Propositional knowledge base revision and minimal change", "author": ["H. Katsuno", "A.O. Mendelzon"], "venue": "Artificial Intelligence, 52(3), 263-294", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1991}, {"title": "Capturing model-based ontology evolution at the instance level: The case of DL-Lite", "author": ["E. Kharlamov", "D. Zheleznyakov", "D Calvanese"], "venue": "J. Comput. Syst. Sci., 79(6), 835-872", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2013}, {"title": "A Framework for Semantic-Based Similarity Measures for ELH -Concepts", "author": ["K. Lehmann", "A.Y. Turhan"], "venue": "Cerro, L.F., Herzig, A., Mengin, J. (eds.) JELIA 2012. LNCS, vol. 7519, pp. 307-319. Springer, Heidelberg", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "On the evolution of the instance level of DL-Lite knowledge bases", "author": ["M. Lenzerini", "D.F. Savo"], "venue": "Proc. of the 24th International Workshop on Description Logics", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2011}, {"title": "Application of the revision theory to adaptation in case-based reasoning: the conservative adaptation", "author": ["J. Lieber"], "venue": "Weber, R.O.,Richter, M.M. (eds.) ICCBR 2007. LNCS, vol. 4626, pp. 239-253. Springer, Heidelberg", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2007}, {"title": "Study and formalization of a case-based reasoning system using a description logic", "author": ["S. Salotti", "V. Ventos"], "venue": "Smyth, B., Cunningham, P. (eds.) EWCBR 1998. LNCS, vol. 1488, pp. 286-297. Springer, Heidelberg", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1998}, {"title": "Measuring similarity in description logics using refinement operators", "author": ["A.A. S\u00e1nchez-Ruiz-Granados", "S. Onta\u00f1\u00f3n", "P.A. Gonz\u00e1lez-Calero", "E. Plaza"], "venue": "Ram, A., Wiratunga, N. (eds.) ICCBR 2011. LNCS, vol. 6880, pp. 289-303. Springer, Heidelberg", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2011}, {"title": "Managing clinical terminology hierarchies using algorithmic calculation of subsumption: Experience with SNOMED-RT", "author": ["K. Spackman"], "venue": "J. American Medical Informatics Assoc., Fall Symposium Special Issue", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2000}, {"title": "Belief base revision for expressive description logics", "author": ["C.H. Wiener", "Y. Katz", "B. Parsia"], "venue": "Proc. of the 4th International Workshop on OWL: Experiences and Directions", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}], "referenceMentions": [{"referenceID": 1, "context": "Description logic (DL) is a family of logics for representing and reasoning about knowledge of static application domains [2].", "startOffset": 122, "endOffset": 125}, {"referenceID": 9, "context": "It is playing a central role in the Semantic Web, serving as the basis of the W3C-recommended Web ontology language OWL [10].", "startOffset": 120, "endOffset": 124}, {"referenceID": 6, "context": "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].", "startOffset": 132, "endOffset": 143}, {"referenceID": 8, "context": "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].", "startOffset": 132, "endOffset": 143}, {"referenceID": 16, "context": "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].", "startOffset": 132, "endOffset": 143}, {"referenceID": 17, "context": "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].", "startOffset": 132, "endOffset": 143}, {"referenceID": 6, "context": "At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].", "startOffset": 93, "endOffset": 102}, {"referenceID": 16, "context": "At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].", "startOffset": 93, "endOffset": 102}, {"referenceID": 17, "context": "At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].", "startOffset": 93, "endOffset": 102}, {"referenceID": 15, "context": "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].", "startOffset": 111, "endOffset": 117}, {"referenceID": 4, "context": "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].", "startOffset": 111, "endOffset": 117}, {"referenceID": 0, "context": "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].", "startOffset": 211, "endOffset": 217}, {"referenceID": 11, "context": "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].", "startOffset": 211, "endOffset": 217}, {"referenceID": 15, "context": "In propositional logic, there are many revision operators which satisfy the AGM postulates and can be applied to complete the adaptation task [16].", "startOffset": 142, "endOffset": 146}, {"referenceID": 7, "context": "However, in DLs, it is very difficult to design revision operators and algorithms that satisfy the AGM postulates [8].", "startOffset": 114, "endOffset": 117}, {"referenceID": 12, "context": "Revision operators of MBAs can be treated as DL-based extensions of the classical revision operators in propositional logic, in that the semantics of minimal change is defined by measuring the distance between models [13].", "startOffset": 217, "endOffset": 221}, {"referenceID": 3, "context": "One is based on the deductive closure of a KB [4,15]; it is syntax-independent and fine-grained, but again only works for DLs of the DLLite family.", "startOffset": 46, "endOffset": 52}, {"referenceID": 14, "context": "One is based on the deductive closure of a KB [4,15]; it is syntax-independent and fine-grained, but again only works for DLs of the DLLite family.", "startOffset": 46, "endOffset": 52}, {"referenceID": 19, "context": "Another is based on justifications [20]; although it is applicable to DLs such as SHOIN , it is syntax-dependent and not fine-grained.", "startOffset": 35, "endOffset": 39}, {"referenceID": 2, "context": "DLs of the EL family are popular for building large-scale ontologies [3].", "startOffset": 69, "endOffset": 72}, {"referenceID": 18, "context": "Some important medical ontologies and life science ontologies are built in EL, such as the SNOMED CT [19] and the Gene Ontology [6].", "startOffset": 101, "endOffset": 105}, {"referenceID": 5, "context": "Some important medical ontologies and life science ontologies are built in EL, such as the SNOMED CT [19] and the Gene Ontology [6].", "startOffset": 128, "endOffset": 131}, {"referenceID": 17, "context": "In the literature, some good results on introducing DLs of the EL family into the retrieval of source cases have been presented [18]; the problem of measuring the similarity of concepts in these DLs is also well-studied [14].", "startOffset": 128, "endOffset": 132}, {"referenceID": 13, "context": "In the literature, some good results on introducing DLs of the EL family into the retrieval of source cases have been presented [18]; the problem of measuring the similarity of concepts in these DLs is also well-studied [14].", "startOffset": 220, "endOffset": 224}, {"referenceID": 15, "context": "Secondly, we extend the \u201cadaptation as KB revision\u201d view from [16] to the above setting and get a formalism for adaptation based on EL\u22a5.", "startOffset": 62, "endOffset": 66}, {"referenceID": 2, "context": "The DL EL\u22a5 extends EL with bottom concept (and consequently disjointness statements) [3].", "startOffset": 85, "endOffset": 88}, {"referenceID": 15, "context": "Consider the example on breast cancer treatment discussed in [16].", "startOffset": 61, "endOffset": 65}, {"referenceID": 15, "context": "Here we follow the approach presented in [16] to formulate adaptation as knowledge base revision, with the difference that our formalism is based on the DL EL\u22a5 instead of propositional logic.", "startOffset": 41, "endOffset": 45}, {"referenceID": 15, "context": "In [16], the adaptation process is modeled as KB revision in propositional logic.", "startOffset": 3, "endOffset": 7}, {"referenceID": 17, "context": "With such a framework, given a target problem tgt, we can make use of similarity-measuring algorithms presented in the literature [18,14] to select a source case (srce, sol) such that, by treating individual names occurring in srce as variables, there exists a substitution \u03c3 such that \u03c3(srce) and tgt has the maximum similarity.", "startOffset": 130, "endOffset": 137}, {"referenceID": 13, "context": "With such a framework, given a target problem tgt, we can make use of similarity-measuring algorithms presented in the literature [18,14] to select a source case (srce, sol) such that, by treating individual names occurring in srce as variables, there exists a substitution \u03c3 such that \u03c3(srce) and tgt has the maximum similarity.", "startOffset": 130, "endOffset": 137}, {"referenceID": 3, "context": "The adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12].", "startOffset": 100, "endOffset": 103}, {"referenceID": 0, "context": "The adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12].", "startOffset": 197, "endOffset": 203}, {"referenceID": 11, "context": "The adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12].", "startOffset": 197, "endOffset": 203}, {"referenceID": 15, "context": "From the point of view of adaptation, the requirements on solutions are explained as follows [16].", "startOffset": 93, "endOffset": 97}, {"referenceID": 3, "context": "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].", "startOffset": 139, "endOffset": 153}, {"referenceID": 7, "context": "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].", "startOffset": 139, "endOffset": 153}, {"referenceID": 12, "context": "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].", "startOffset": 139, "endOffset": 153}, {"referenceID": 14, "context": "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].", "startOffset": 139, "endOffset": 153}, {"referenceID": 19, "context": "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].", "startOffset": 139, "endOffset": 153}, {"referenceID": 3, "context": "One reason is that there are different approaches to define minimality, and it is well-accepted that there is no general notion of minimality that will do the right thing under all circumstances [4].", "startOffset": 195, "endOffset": 198}, {"referenceID": 12, "context": "MBAs define revision operators over the distance between interpretations [13].", "startOffset": 73, "endOffset": 77}, {"referenceID": 11, "context": "In propositional logic, it is easy to measure the distance between interpretations and to calculate the revision results based on the distance [12], since each interpretation is only a truth assignment on propositional symbols.", "startOffset": 143, "endOffset": 147}, {"referenceID": 12, "context": "Then, with MBAs, M is the set of models of \u3008T ,N\u3009 that are minimally distant from the models of \u3008T ,A\u3009 [13], i.", "startOffset": 103, "endOffset": 107}, {"referenceID": 12, "context": "In [13], the above four different semantics for MBAs are denoted as G \u266f , G \u2286, G a \u266f , and G a \u2286 respectively.", "startOffset": 3, "endOffset": 7}, {"referenceID": 3, "context": "The first one is based on deductive closures [4,15].", "startOffset": 45, "endOffset": 51}, {"referenceID": 14, "context": "The first one is based on deductive closures [4,15].", "startOffset": 45, "endOffset": 51}, {"referenceID": 19, "context": "The second FBA is based on justifications (also known as MinAs or kernel) [20].", "startOffset": 74, "endOffset": 78}, {"referenceID": 10, "context": "Our algorithm is based on a structure named revision graph, which is close to the completion graph used in classical tableau decision algorithms of DLs [11].", "startOffset": 152, "endOffset": 156}, {"referenceID": 15, "context": "The idea of applying KB revision theory to adaptation in CBR was proposed by Lieber [16].", "startOffset": 84, "endOffset": 88}, {"referenceID": 4, "context": "This idea was extended by Cojan and Lieber [5] to deal with adaptation based on the DL ALC.", "startOffset": 43, "endOffset": 46}, {"referenceID": 7, "context": "From the point of view of KB revision in DLs, it is a great challenge to design revision operators or algorithms that satisfy the requirements specified by the AGM postulates [8].", "startOffset": 175, "endOffset": 178}, {"referenceID": 12, "context": ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.", "startOffset": 7, "endOffset": 11}, {"referenceID": 3, "context": ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.", "startOffset": 21, "endOffset": 30}, {"referenceID": 14, "context": ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.", "startOffset": 21, "endOffset": 30}, {"referenceID": 19, "context": ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.", "startOffset": 21, "endOffset": 30}, {"referenceID": 2, "context": "For future work, we will extend our method to support adaptation based on EL [3].", "startOffset": 77, "endOffset": 80}], "year": 2014, "abstractText": "Case-based reasoning (CBR) based on description logics (DLs) has gained a lot of attention lately. Adaptation is a basic task in CBR that can be modeled as a knowledge base revision problem which has been solved in propositional logic. However, in DLs, adaptation is still a challenge problem since existing revision operators only work well for DLs of the DL-Lite family. It is difficult to design revision algorithms that are syntax-independent and fine-grained. In this paper, we present a new method for adaptation based on the tractable DL EL\u22a5. Following the idea of adaptation as revision, we firstly extend the logical basis for describing cases from propositional logic to the DL EL\u22a5, and then present a formalism for adaptation based on EL\u22a5. With this formalism, we show that existing revision operators and algorithms in DLs do not work for it, and then present our adaptation algorithm. Our algorithm is syntax-independent and fine-grained, and satisfies the requirements on revision operators.", "creator": "LaTeX with hyperref package"}}}