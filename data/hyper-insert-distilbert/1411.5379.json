{"id": "1411.5379", "review": {"conference": "HLT-NAACL", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Nov-2014", "title": "Type-Driven Incremental Semantic Parsing with Polymorphism", "abstract": "semantic map parsing is a burgeoning field, but most very current semantic link parsers are naturally extremely slow ( like cky - flow based ) processing and too rather intensely primitive in representation ( simply plain typed lambda mapping calculus ). internally we introduce two new techniques to tackle tackle these problems. first, we design a linear - time, type - model driven, reverse incremental parsing algorithm approaches that use descriptive type checking to reduce beyond the allocated search size space, scaling which is orders much of magnitude faster than conventional cubic - time bottom - up semantic parsers, and also also eliminates basically the core need specifically for a formal grammar such machines as ccg. now second, secondly to fully correctly exploit the power bases of type - driven primary semantic domain parsing models beyond historically simple types ( such as entities and common truth values ), we continuously introduce a greatly sophisticated subtype hierarchy and parametric transformation polymorphism procedures to the system, so that the classical type detection system design is powerful enough actually to better guide out the logical parsing. looking together again with these max - flow violation and perceptron training, modeling our information system learns very accurate physical parses syntax in geoquery, sophisticated jobs design and semantic atis system domains.", "histories": [["v1", "Wed, 19 Nov 2014 21:06:15 GMT  (182kb,D)", "https://arxiv.org/abs/1411.5379v1", null], ["v2", "Sat, 13 Dec 2014 21:35:32 GMT  (40kb,D)", "http://arxiv.org/abs/1411.5379v2", null], ["v3", "Tue, 16 Dec 2014 16:41:48 GMT  (57kb,D)", "http://arxiv.org/abs/1411.5379v3", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["kai zhao", "liang huang 0001"], "accepted": true, "id": "1411.5379"}, "pdf": {"name": "1411.5379.pdf", "metadata": {"source": "CRF", "title": "Type-Driven Incremental Semantic Parsing with Polymorphism", "authors": ["Kai Zhao", "Liang Huang"], "emails": ["kzhao.hf@gmail.com", "liang.huang.sh@gmail.com"], "sections": [{"heading": "1 Introduction", "text": "Most existing semantic parsing efforts employ a CKY-style bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus Zettlemoyer and Collins (2005); Lu and Ng (2011) or its variants Wong and Mooney (2007); Liang et al. (2011). Although these works led to fairly accurate semantic parsers, there are two major drawbacks: efficiency and expressiveness.\nFirst, as many researches in syntactic parsing Nivre (2008); Zhang and Clark (2011) have shown, compared to cubic-time CKY-style parsing, incremental parsing can achieve comparable accuracies while being linear-time, which means orders of magnitude faster in practice. We therefore introduce the first incremental parsing algorithm for semantic parsing. More interestingly, unlike syntactic parsing, our incremental semantic parsing algorithm, being strictly type-driven, directly employs type checking to automatically determine the direction of function application on-the-fly, thus reducing the search space and eliminating the need for a syntactic grammar such as CCG which explicitly encodes the direction of function application.\nHowever, to fully exploit the power of type-driven incremental parsing, we need a more sophisticated type system than simply typed lambda calculus. We argue that it is beneficial to incorporate an explicit subtype hierarchy, such that ambiguous terms can be grounded based on context in a more explicit and declarative fashion. Compare the following two phrases:\n(1) the mayor of New York?\n(2) the capital of New York?\nIf we know that mayor is a function from city to person, then the first New York can only be of type city; similarly knowing capital maps states to cities disambiguates the second New York to be of type state. This can not be done using a simple type system with just entities and booleans.\nNow let us consider a more complex question which will be our running example in this paper:\n(3) What is the capital of the largest state by area?\nar X\niv :1\n41 1.\n53 79\nv3 [\ncs .C\nL ]\n1 6\nD ec\n2 01\n4\nSince we know capital takes a state as input, we expect the largest state by area to return a state. But does largest always return a state type? Notice that it is polymorphic, for example, largest city by population, or largest lake by perimeter. So there is no unique type for largest: its return type should depend on the type of its first argument (city, state, or lake). This observation motivates us to introduce the powerful mechanism of parametric polymorphism from programming languages into the type system for natural language. For example, we can define the type of largest to be a template\nlargest : ('a\u2192t)\u2192('a\u2192i)\u2192'a\nwhere 'a is a type variable that can match any type (for formal details see Section 3). Just like in functional programming languages such as ML or Haskell, type variables can be bound to a real type (or a range of types) during function application, using the technique of type inference. In the above example, when largest is applied to city, we know that type variable 'a is bound to type city (or its subtype), so that largest would eventually return a city.\nWe make the following contributions:\n\u2022 We design a linear-time incremental semantic parsing algorithm (Section 2), which is much more efficient than the majority of existing semantic parsers that are cubic-time CKY-based.\n\u2022 In line with classical Montague theory Heim and Kratzer (1998), our parser is type-driven parsing instead of syntax-driven as in CCG-based efforts Zettlemoyer and Collins (2005); Kwiatkowski et al. (2011); Krishnamurthy and Mitchell (2014) (Section 2.3).\n\u2022 We introduce parametric polymorphism into natural language semantics (Section 3), along with proper treatment of subtype polymorphism, and implement Hindley-Milner style type inference (Pierce, 2005, Chap. 10) during parsing (Section 3.2).1\n\u2022 We adapt the latent-variable max-violation perceptron training from machine translation Yu et al. (2013), which is a perfect fit for semantic parsing due to its huge search space (Section 4).\nExperiments on GEOQUERY, JOBS and ATIS domains show close to state-of-the-art performances, and demonstrate the advantage of a powerful type system."}, {"heading": "2 Type-Driven Incremental Parsing", "text": "We start with the simplest meaning representation (MR), untyped lambda calculus, and then introduce typing and the incremental parsing algorithm for it. Later in Section 3, we add subtyping and type polymorphism to enrich the system."}, {"heading": "2.1 Meaning Representation with Types", "text": "The untyped MR for the running example is:\nQ: What is the capital of the largest state by area?\nMR: (capital (argmax state size))\nNote the binary function argmax(\u00b7, \u00b7) is a higher-order function that takes two other functions as input: the first argument is a \u201cdomain\u201d function that defines the set to search for, and second argument is an \u201cevaluation\u201d function that returns a integer for an element in that domain. In other words\nargmax(f, g) = argmax x:f(x) g(x).\n1There are three kinds of polymorphisms in programming languages: parametric (e.g., C++ templates), subtyping, and ad-hoc (e.g., operator overloading). See (Pierce, 2002, Chap. 15) for details.\nstep action stack after action queue 0 - \u03c6 what ... 1\u20133 skip \u03c6 capital ... 4 shcapital capital:e\u2192e of ... 7 shlargest capital:e\u2192e argmax:(e\u2192t)\u2192(e\u2192i)\u2192e state ... 8 shstate capital:e\u2192e argmax:(e\u2192t)\u2192(e\u2192i)\u2192e state:e\u2192t by ... 9 rey capital:e\u2192e (argmax state):(e\u2192i)\u2192e by ... 11 sh area capital:e\u2192e (argmax state):(e\u2192i)\u2192e size:e\u2192i ? 12 rey capital:e\u2192e (argmax state size):e ? 13 rey (capital (argmax state size)):e ?\n(a) type-driven incremental parsing with simple types (entities e, truth values t, and integers i); see Section 2.\nstep action stack after action queue typing 0 - \u03c6 what... 1\u20133 skip \u03c6 capital... 4 shcapital capital:st\u2192ct of... 7 shlargest capital:st\u2192ct argmax : ('a\u2192t)\u2192('a\u2192i)\u2192'a state... 8 shstate capital:st\u2192ct argmax : ('a\u2192t)\u2192('a\u2192i)\u2192'a state :st\u2192t by... 9 rey capital:st\u2192ct (argmax state) : (st\u2192i)\u2192st by... binding: 'a = st 11 sh area capital:st\u2192ct (argmax state) : (st\u2192i)\u2192st size : lo\u2192i ? 12 rey capital:st\u2192ct (argmax state size) :st ? st <: lo\u21d2 (lo\u2192i)<: (st\u2192i) 13 rey (capital (argmax state size)) :ct ?\n(b) type-driven incremental parsing with subtyping (<:) and type polymorphism (e.g., type variable 'a); see Section 3.2.\nFigure 1: Type-driven Incremental Semantic Parsing (TISP) with (a) simple types and (b) subtyping+polymorphism on the example question: \u201cwhat is the capital of the largest state by area?\u201d. Steps 5\u20136 and 10 are skip actions and thus omitted. The stack and queue in each row are the results after each action.\nThe simply typed lambda calculus Heim and Kratzer (1998); Lu and Ng (2011) augments the system with types, including base types (entities e, truth values t, or numbers i), and function types (e.g., e\u2192t). So function capital is of type e\u2192e, state is of type e\u2192t, and size is of type e\u2192i. The argmax function is of type (e\u2192t)\u2192(e\u2192i)\u2192e.2 The simply typed MR is now written as\n(capital :e\u2192e (argmax :(e\u2192t)\u2192(e\u2192i)\u2192e state :e\u2192t size :e\u2192i)))."}, {"heading": "2.2 Incremental Semantic Parsing: An Example", "text": "We use the above running example to explain our type-driven incremental semantic parsing algorithm. Figure 1 (a) illustrates the full derivation.\nSimilar to a standard shift-reduce parser, we maintain a stack and a queue. The queue contains words to be parsed, while the stack contains subexpressions of the final MR, where each subexpression is a valid typed lambda expression. At each step, the parser choose to shift or reduce, but unlike standard shift-reduce parser, there is also a third possible action, skip, which skips a semantically vacuous word (e.g., \u201cthe\u201d, \u201cof\u201d, \u201cis\u201d, etc.). For example, the first three words of the example question \u201cWhat is the ...\u201d are all skipped (steps 1\u20133 in Figure 1 (a)).\nThe parser then shifts the next word, \u201ccapital\u201d, from the queue to the stack. But unlike incremental syntactic parsing where the word itself is moved onto the stack, here we need to find a grounded\n2Note that the type notation is always curried, i.e., we represent a binary function as a unary function that returns another unary function. Also the type notation is always right-associative, so (e\u2192t)\u2192((e\u2192i)\u2192e) is also written as (e\u2192t)\u2192(e\u2192i)\u2192e.\npredicate in the GeoQuery domain for the current word. In this example we find the predicate:\ncapital :e\u2192e\nand put it on the stack (step 4). Next, words \u201cof the\u201d are skipped (steps 5\u20136). Then for word \u201clargest\u201d, we shift the predicate\nargmax : (e\u2192t)\u2192(e\u2192i)\u2192e\nonto the stack (step 7), which becomes\ncapital :e\u2192e argmax : (e\u2192t)\u2192(e\u2192i)\u2192e.\nAt this step we have two expressions on the stack and we could attempt to reduce. But type checking fails because for left reduce, argmax expects an argument (its \u201cdomain\u201d function) of type (e\u2192t) which is different from capital\u2019s type (e\u2192e), so is the case for right reduce.\nSo we have to shift again. This time for word \u201cstate\u201d we shift the predicate\nstate :e\u2192t\nonto the stack, which becomes:\ncapital :e\u2192e argmax : (e\u2192t)\u2192(e\u2192i)\u2192e state :e\u2192t."}, {"heading": "2.3 Type-Driven Reduce", "text": "At this step we can finally perform a reduce action, since the top two expressions on the stack pass the type-checking for rightward function application (a partial application): argmax expects an (e\u2192t) argument, which is exactly the type of state. So we conduct a right-reduce, applying argmax on state, and the resulting expression is:\n(argmax state) : (e\u2192i)\u2192e\nwhile the stack becomes (step 9)\ncapital :e\u2192e (argmax state) : (e\u2192i)\u2192e\nNow if we want to continue reduction, it does not type check for either left or right reduction, so we have to shift again.\nSo we move on to shift the final word \u201carea\u201d with the grounded predicate in GeoQuery database:\nsize :e\u2192i\nand the stack becomes (step 11):\ncapital :e\u2192e (argmax state) : (e\u2192i)\u2192e size :e\u2192i.\nNow apparently we can do a right reduce supported by type checking (step 12):\ncapital :e\u2192e (argmax state size) :e\nfollowed by another, final, right reduce (step 13):\n(capital (argmax state size)) :e.\nHere we can see the novelty of our shift-reduce parser: its decisions are largely driven by the type system. When we attempt a reduce, at most one of the two reduce actions (left, right) is possible thanks to type checking, and when neither is allowed, we have to shift (or skip). This observation suggests\nthat our incremental parser is more deterministic than those syntactic incremental parsers whose each step always faces a three-way decision (shift, left-reduce, right-reduce). We also note that this typechecking mechanism, inspired by the classical type-driven theory in linguistics Heim and Kratzer (1998), eliminates the need for an explicit encoding of direction as in CCG, which makes our formalism much simpler than the synchronous syntactic-semantic ones in most other semantic parsing efforts Zettlemoyer and Collins (2005, 2007); Wong and Mooney (2007).\nAs a side note, besides function application, reduce also occurs when the top two expressions on the stack can be combined to represent a more specific meaning, which we call union.\nFor example, when parsing the phrase \u201cmajor city\u201d, we have the top two expressions on the stack\nmajor :e\u2192t city :e\u2192t\nWe can combine the two expressions using predicate and since their types match, and get\n\u03bbx :e . (and : t\u2192t\u2192t (major :e\u2192t x) (city :e\u2192t x)),\nwhere type t\u2192t\u2192t takes two booleans and return one (again, using currying notation)."}, {"heading": "3 Subtype and Type Polymorphisms", "text": "As mentioned in Section 1, simply typed lambda calculus representation can not distinguish between Mississippi the river and Mississippi the state since they both have the same type e. Furthermore, currently function capital can apply to any entity type, for example capital(boston), which should have been disallowed by the type checker. So we need a more sophisticated type system that helps ground terms to real-world entities, and this refined type system will in turn help type-driven parsing."}, {"heading": "3.1 Augmenting MR with Subtyping", "text": "We first augment the meaning representation with a type hierarchy which is domain specific. For example Figure 2 shows a (slightly simplified) version of the type hierarchy for GEOQUERY domain. Here the root type top has a subtype of locations, lo, which consists of two different kinds of locations, administrative units (au) including states (st) and cities (ct), and nature units (nu) including rivers (rv) and lakes (lk). We use <: to denote the (transitive, reflexive, and antisymmetric) subtyping relation between types; for example in GEOQUERY we have st <: lo, rv <: nu, and T <: top for any type T.\nIn addition we have an integer type i derived from the root type top. The boolean type t does not belong to the type hierarchy, because it does not represent the semantics from the task domain.\nEach constant in the GEOQUERY domain is well typed. For example, there are states (mississippi:st), cities (boston:ct), rivers (mississippi:rv), and lakes (tahoe:lk). Note that the names like mississippi appears twice for two different entities. The fact that we can distinguish them by type is a crucial advantage of a typed semantic formalism.\nSimilarly each predicate is also typed. For example, we can query the length of a river, len:rv\u2192i, or the population of some administrative unit, population:au\u2192i. Notice that population(\u00b7) can be applied to both states and cities, since they are subtypes of administrative unit, i.e., st <: au and ct <: au. This is because, as in Java and C++, a function that expects a type T argument can always take an argument of another type S which is a subtype of T. More formally:\ne2 : S S <: T\n(\u03bbx :T . e1) e2\u2192 [x 7\u2192 e2]e1 , (4)\nwhere [x 7\u2192 e2]e1 means substituting all occurrences of variable x in expression e1 with expression e2. For example, we can query whether two locations are adjacent, using next_to:lo\u2192(lo\u2192t), and similarly the next_to(\u00b7, \u00b7) function can be applied to two states, or to a river and a city, etc.\nThe above type system works smoothly for first-order functions (i.e., predicates taking atomic type arguments), but the situation with higher-order functions (i.e., predicates that take functions as input) is more involved. What is the type of argmax? One possibility is to define it to be as general as possible, as in the simply typed version (and many conventional semantic parsers):\nargmax : (top\u2192t)\u2192(top\u2192i)\u2192top.\nBut this actually no longer works for our sophisticated type system for the following reason. Intuitively, remember that capital:st\u2192ct is now a function that takes a state as input, so the return type of argmax must be a state or its subtype, rather than top which is a supertype of st. But we can not simply replace top by st, since argmax can also be applied in other scenarios such as \u201cthe largest city\u201d or \u201cthe longest river\u201d. In other words, argmax is a polymorphic function, and to assign a correct type for it we have to introduce type variables (widely used in functional programming languages such as Haskell and ML, and also in C++ templates). We define\nargmax : ('a\u2192t)\u2192('a\u2192i)\u2192'a\nwhere the type variable 'a is a place-holder for \u201cany type\u201d. Before we move on, there is an important consequence of polymorphism worth mentioning here. For the types of unary predicates such as city(\u00b7) and state(\u00b7) that characterize its argument, we define theirs argument types to be the required type, i.e., city : ct\u2192t, and state : st\u2192t. This might look a little weird since everything in the domain of those functions are always mapped to true; i.e., f(x) is either undefined or true, and never false for such f \u2019s. This is different from classical simply-typed Montague semantics Heim and Kratzer (1998) which defines such predicates as type top\u2192t so that city(mississippi : st) returns false. The reason for our design is, again, due to subtyping and polymorphism: capital takes a state type as input, so argmax must returns a state, and therefore its first argument, the state function, must have type st\u2192t so that the matched type variable 'a will be bound to st. This more refined design will also help prune unnecessary argument matching using type checking."}, {"heading": "3.2 Parsing with Subtype Polymorphism and Parametric Polymorphism", "text": "We modify the previous incremental parsing algorithm with simple types (Section 2) to accommodate subtyping and polymorphic types. Figure 1 (b) shows the derivation of the running example using the new parsing algorithm. Below we focus on the differences brought by the new algorithm.\nIn step 4, unlike capital : e\u2192e, we shift the predicate\ncapital : st\u2192ct\nand in step 7, we shift the polymorphic expression for \u201clargest\u201d\nargmax : ('a\u2192t)\u2192('a\u2192i)\u2192'a\nAnd after the shift in step 8, the stack becomes\ncapital :st\u2192ct argmax : ('a\u2192t)\u2192('a\u2192i)\u2192'a state :st\u2192t\nAt step 9, in order to apply argmax onto state : st\u2192t, we simply bind type variable 'a to type st, i.e.,\nargmax : (st\u2192t)\u2192(st\u2192i)\u2192st state :st\u2192t\nresults in (argmax state) : (st\u2192i)\u2192st\nAfter the shift in step 11, the stack becomes:\ncapital :st\u2192ct (argmax state) : (st\u2192i)\u2192st size : lo\u2192i.\nCan we still apply right reduce here? According to the subtyping rule (Eq. 4), we want\nlo\u2192i <: st\u2192i\nto hold, knowing that st <: lo. Luckily, there is a rule about function types in type theory that exactly fits here:\nA <: B\nB\u2192C <: A\u2192C (5)\nwhich states the input side is reversed (contravariant). This might look counterintuitive at the first glance, but the intuition is that, it is safe to allow the function size of type lo\u2192i to be used in the context where another type st\u2192i is expected, since in that context the argument passed to size will be state type (st), which is a subtype of location type (lo) that size expects, which in turn will not surprise size. See the classical type theory textbook (Pierce, 2002, Chap. 15.2) for details. See Figure 1 (b) for the full derivation."}, {"heading": "4 Training: Latent Variable Perceptron", "text": "We follow the Latent Variable Violation-Fixing Perceptron framework Huang et al. (2012); Yu et al. (2013) for the training."}, {"heading": "4.1 Framework", "text": "The key challenge in the training is that, for each question, there might be many different unknown derivations that lead to its annotated MR, which is known as the spurious ambiguity. In our type-driven incremental semantic parsing task, the spurious ambiguity is caused by how the expression templates are chosen and grounded during the shift step, and the different reduce orders that lead to the same result. We treat this unknown information as latent variable.\nMore formally, we denote D(x) to be the set of all partial and full parsing derivations for an input sentence x, and mr(d) to be the MR yielded by a full derivation d. Then we define the sets of (partial and full) reference derivations as:\ngood i(x, y) \u2206 = {d \u2208 D(x) | |d| = i,\u2203full derivation d\u2032 s.t.\nd is a prefix of d\u2032,mr(d\u2032) = y},\nThose \u201cbad\u201d partial and full derivations that do not lead to the annotated MR can be defined as:\nbad i(x, y) \u2206 = {d \u2208 D(x) | d 6\u2208 good i(x, y), |d| = i}.\nAt step i, the best reference partial derivation is\nd+i (x, y) \u2206 = argmax\nd\u2208goodi(x,y) w \u00b7\u03a6(x, d), (6)\nwhile the Viterbi partial derivation is\nd\u2212i (x, y) \u2206 = argmax\nd\u2208badi(x,y) w \u00b7\u03a6(x, d), (7)\nwhere \u03a6(x, d) is the defined feature set for derivation d. In practice, to compute Eq. 7 exactly is intractable, and we resort to beam search. Following Yu et al. (2013), we then find the step i\u2217 with the maximal score difference between the best reference partial derivation and the Viterbi partial derivation:\ni\u2217 \u2206 = argmax i w \u00b7\u2206\u03a6(x, d+i (x, y), d \u2212 i (x, y)),\nand do update: w\u2190 w + \u2206\u03a6(x, d+i\u2217(x, y), d \u2212 i\u2217(x, y))\nwhere \u2206\u03a6(x, d, d\u2032) \u2206= \u03a6(x, d)\u2212\u03a6(x, d\u2032)."}, {"heading": "4.2 Forced Decoding", "text": "We use forced decoding to retrieve the reference derivations good i(x, y) for each question/MR pair (x, y) in Eq. 6.\nUnlike syntactic incremental parsing, where the forced decoding can be done in polynomial time Goldberg et al. (2014), we do not have an algorithm designed for efficient forced decoding. We apply exponential-time brute-force search to calculate good(x, y), during which we do pruning based on the predicate application orders.\nHowever, this requires heavy computation we can not afford. In practice we choose multi-pass forced decoding. First we use brute-force search to decode, but with a time limit. Then we train a Perceptron using successfully decoded reference derivations, and use the trained Perceptron to decode the unfinished questions with a large beam. We then add the reference derivations newly discovered into the next step training."}, {"heading": "5 Experiments", "text": "We implement our type-driven incremental semantic parser (TISP) using Python, and evaluate its performance of both speed and accuracy on GEOQUERY and JOBS datasets.\nOur feature design is inspired by the very effective Word-Edge features in syntactic parsing Charniak and Johnson (2005) and MT He et al. (2008). From each parsing state, we collect atomic features including the types and the leftmost and rightmost words of the span of the top 3 MR expressions on the stack, the top 3 words on the queue, the grounded predicate names and the ID of the expression template used in the shift action.\nTo ease the overfitting problem caused by the feature sparsity, we assign different budgets to different kinds of features and only generate feature combinations within a budget limit. We get 84 combined feature templates in total.\nFor evaluation, we follow Zettlemoyer and Collins (2005) to use precision and recall, where\nPrecision = # of correctly parsed questions\n# of successfully parsed questions ,\nand Recall =\n# of correctly parsed questions # of questions ."}, {"heading": "5.1 Evaluation on GEOQUERY Dataset", "text": "We first evaluate TISP on GEOQUERY dataset. Following the scheme of Zettlemoyer and Collins (2007), we use the first 600 sentences of Geo880 as the training set and the rest 280 sentences as the testing set. Note that we do not have a separate development set, due to the relatively small size of Geo880. So to find the best number of iterations to stop the training, we do a 10-fold cross-validation training over the training set, and choose to train 20 iterations and then evaluate.\nWe use two-pass forced decoding. In the initial brute-force pass we set the time limit to 1,200 seconds, and find the reference derivations for 530 of the total 600 training sentences, a coverage of\u223c 88%. In the second pass we set beam size to 16,384 and get 581 sentences covered (\u223c 97%).\nIn the training and evaluating time, we use a very small beam size of 16, which gives us very fast decoding. In serial mode, our parser takes\u223c83s to decode the 280 sentences (2,147 words) in the testing set, which means \u223c0.3s per sentence, or \u223c0.04s per word.\nWe compare the our accuracy performance with existing methods in Table 1. Given that all other methods use CKY-style parsing, our method is well balanced between accuracy and speed.\nIn addition, to unveil the helpfulness of our type system, we train a parser with only simple types. (Table 1) In this setting, the predicates only have primitive types of location lo, integer i, and boolean t, while the constants still keep their types. It still has the type system, but it is weaker than the polymorphic one. Its accuracy is lower than the standard one, mostly caused by that the type system can not help pruning the wrong applications like\n(population:au\u2192i mississippi:rv)."}, {"heading": "5.2 Evaluations on JOBS and ATIS Datasets", "text": "The JOBS domain contains descriptions about required and desired qualifications of a job. The qualifications include programming language (la), years of experience (ye), diplomat degree (de), area of fields (ar), platform (pa), title of the job (ti), etc. We show a simplified version of the type hierarchy for JOBS in Figure 3.\nFollowing the splitting scheme of Zettlemoyer and Collins (2005), we use 500 sentences as training set and 140 sentences as testing set.\nTable 1 shows that our algorithm achieves significantly higher recall than existing method of Zettlemoyer and Collins (2005), although our precision is not as high as theirs. This is actually because our method parses a lot more questions in the dataset, as the column of the percentage of successfully parsed sentences suggests.\nWe also evaluate the performance of TISP on ATIS dataset as in Table 1. ATIS dataset contains more than 5,000 examples and is a lot larger than GEOQUERY and JOBS. Our method achieves comparable performance on this dataset. Due to space constraints, we do not show its type hierarchy here."}, {"heading": "6 Related Work", "text": "Zettlemoyer and Collins (2005) introduce a type hierarchy to semantic parsing and parse with typed lambda calculus combined with CCG. However, simply introducing subtyped predicates without polymorphism will cause type checking failures in handling high-order functions, as shown in Section 3. Furthermore, our system, being type-driven, almost completely rely on the types of MR expressions to guide parsing (except for some simple POS tag triggers) while their system is heavily CCG-based and syntax-driven.\nKwiatkowski et al. (2013) use \u201con-the-fly\u201d matching to fetch the most possible predicate in the dataset for some MR subexpression. The matching happens at the end of parsing, and is constrained by the type of the subexpression. We do matching and parsing jointly, both of which are constrained by the typing, and affect the typing, which is more similar to how human do semantic parsing, i.e., we parse part of the sentence and bind that part to some specific meaning, and continue parsing using grounded meaning.\nWong and Mooney (2007) also use type information to help reduce unnecessary tree joining in decoding. However, their types are static, while our type system is stronger so that we can infer type from polymorphism, which gives use better search quality in decoding."}, {"heading": "7 Conclusions and Future Work", "text": "We have presented an incremental semantic parser that is guided by a powerful type system of subtyping and parametric polymorphism. This polymorphism greatly reduced the number of templates and effectively pruned search space during the parsing. Our parser is competitive with state-of-the-art accuracies, but, being linear-time, is orders of magnitude faster than CKY-based parsers in theory and in practice.\nFor future work, we would like to work on weakly supervised learning that learn from questionanswer pairs instead of question-MR pairs, where the datasets are larger, and TISP should benefit more on such problems."}], "references": [{"title": "Coarse-to-fine n-best parsing and maxent discriminative reranking", "author": ["E. Charniak", "M. Johnson", "June"], "venue": "In Proceedings of ACL, Ann Arbor, Michigan,", "citeRegEx": "Charniak et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Charniak et al\\.", "year": 2005}, {"title": "A tabular method for dynamic oracles in transition-based parsing", "author": ["Y. Goldberg", "F. Sartorio", "G. Satta"], "venue": null, "citeRegEx": "Goldberg et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Goldberg et al\\.", "year": 2014}, {"title": "Semantics in Generative Grammar", "author": ["I. Heim", "A. Kratzer"], "venue": null, "citeRegEx": "Heim and Kratzer,? \\Q1998\\E", "shortCiteRegEx": "Heim and Kratzer", "year": 1998}, {"title": "Structured perceptron with inexact search", "author": ["L. Huang", "S. Fayong", "Y. Guo"], "venue": "In Proceedings of NAACL", "citeRegEx": "Huang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2012}, {"title": "Joint syntactic and semantic parsing with combinatory categorial grammar", "author": ["J. Krishnamurthy", "T.M. Mitchell"], "venue": null, "citeRegEx": "Krishnamurthy and Mitchell,? \\Q2014\\E", "shortCiteRegEx": "Krishnamurthy and Mitchell", "year": 2014}, {"title": "Scaling semantic parsers with on-the-fly ontology matching", "author": ["T. Kwiatkowski", "E. Choi", "Y. Artzi", "L. Zettlemoyer"], "venue": null, "citeRegEx": "Kwiatkowski et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Kwiatkowski et al\\.", "year": 2013}, {"title": "Lexical generalization in ccg grammar induction for semantic parsing", "author": ["T. Kwiatkowski", "L. Zettlemoyer", "S. Goldwater", "M. Steedman"], "venue": "In Proceedings of EMNLP,", "citeRegEx": "Kwiatkowski et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Kwiatkowski et al\\.", "year": 2011}, {"title": "Learning dependency-based compositional semantics", "author": ["P. Liang", "M.I. Jordan", "D. Klein"], "venue": "In Association for Computational Linguistics (ACL),", "citeRegEx": "Liang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Liang et al\\.", "year": 2011}, {"title": "A probabilistic forest-to-string model for language generation from typed lambda calculus expressions", "author": ["W. Lu", "H.T. Ng"], "venue": "In Proceedings of EMNLP", "citeRegEx": "Lu and Ng,? \\Q2011\\E", "shortCiteRegEx": "Lu and Ng", "year": 2011}, {"title": "Algorithms for deterministic incremental dependency parsing", "author": ["J. Nivre"], "venue": "Computational Linguistics", "citeRegEx": "Nivre,? \\Q2008\\E", "shortCiteRegEx": "Nivre", "year": 2008}, {"title": "Advanced Topics in Types and Programming Languages", "author": ["B. Pierce"], "venue": null, "citeRegEx": "Pierce,? \\Q2005\\E", "shortCiteRegEx": "Pierce", "year": 2005}, {"title": "Types and Programming Languages", "author": ["B.C. Pierce"], "venue": null, "citeRegEx": "Pierce,? \\Q2002\\E", "shortCiteRegEx": "Pierce", "year": 2002}, {"title": "Learning synchronous grammars for semantic parsing with lambda calculus", "author": ["Y.W. Wong", "R.J. Mooney"], "venue": "In Annual Meeting-Association for computational Linguistics,", "citeRegEx": "Wong and Mooney,? \\Q2007\\E", "shortCiteRegEx": "Wong and Mooney", "year": 2007}, {"title": "Max-violation perceptron and forced decoding for scalable mt training", "author": ["H. Yu", "L. Huang", "H. Mi", "K. Zhao"], "venue": "In Proceedings of EMNLP", "citeRegEx": "Yu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Yu et al\\.", "year": 2013}, {"title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars", "author": ["L. Zettlemoyer", "M. Collins"], "venue": "In Proceedings of UAI", "citeRegEx": "Zettlemoyer and Collins,? \\Q2005\\E", "shortCiteRegEx": "Zettlemoyer and Collins", "year": 2005}, {"title": "Online learning of relaxed ccg grammars for parsing to logical form", "author": ["L.S. Zettlemoyer", "M. Collins"], "venue": "Proceedings of EMNLP-CoNLL-2007. Citeseer", "citeRegEx": "Zettlemoyer and Collins,? \\Q2007\\E", "shortCiteRegEx": "Zettlemoyer and Collins", "year": 2007}, {"title": "Shift-reduce ccg parsing", "author": ["Y. Zhang", "S. Clark"], "venue": "In Proceedings of ACL", "citeRegEx": "Zhang and Clark,? \\Q2011\\E", "shortCiteRegEx": "Zhang and Clark", "year": 2011}], "referenceMentions": [{"referenceID": 10, "context": "Most existing semantic parsing efforts employ a CKY-style bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus Zettlemoyer and Collins (2005); Lu and Ng (2011) or its variants Wong and Mooney (2007); Liang et al.", "startOffset": 154, "endOffset": 185}, {"referenceID": 7, "context": "Most existing semantic parsing efforts employ a CKY-style bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus Zettlemoyer and Collins (2005); Lu and Ng (2011) or its variants Wong and Mooney (2007); Liang et al.", "startOffset": 186, "endOffset": 203}, {"referenceID": 7, "context": "Most existing semantic parsing efforts employ a CKY-style bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus Zettlemoyer and Collins (2005); Lu and Ng (2011) or its variants Wong and Mooney (2007); Liang et al.", "startOffset": 186, "endOffset": 242}, {"referenceID": 7, "context": "Most existing semantic parsing efforts employ a CKY-style bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus Zettlemoyer and Collins (2005); Lu and Ng (2011) or its variants Wong and Mooney (2007); Liang et al. (2011). Although these works led to fairly accurate semantic parsers, there are two major drawbacks: efficiency and expressiveness.", "startOffset": 243, "endOffset": 263}, {"referenceID": 7, "context": "Most existing semantic parsing efforts employ a CKY-style bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus Zettlemoyer and Collins (2005); Lu and Ng (2011) or its variants Wong and Mooney (2007); Liang et al. (2011). Although these works led to fairly accurate semantic parsers, there are two major drawbacks: efficiency and expressiveness. First, as many researches in syntactic parsing Nivre (2008); Zhang and Clark (2011) have shown, compared to cubic-time CKY-style parsing, incremental parsing can achieve comparable accuracies while being linear-time, which means orders of magnitude faster in practice.", "startOffset": 243, "endOffset": 448}, {"referenceID": 7, "context": "Most existing semantic parsing efforts employ a CKY-style bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus Zettlemoyer and Collins (2005); Lu and Ng (2011) or its variants Wong and Mooney (2007); Liang et al. (2011). Although these works led to fairly accurate semantic parsers, there are two major drawbacks: efficiency and expressiveness. First, as many researches in syntactic parsing Nivre (2008); Zhang and Clark (2011) have shown, compared to cubic-time CKY-style parsing, incremental parsing can achieve comparable accuracies while being linear-time, which means orders of magnitude faster in practice.", "startOffset": 243, "endOffset": 472}, {"referenceID": 2, "context": "\u2022 In line with classical Montague theory Heim and Kratzer (1998), our parser is type-driven parsing instead of syntax-driven as in CCG-based efforts Zettlemoyer and Collins (2005); Kwiatkowski et al.", "startOffset": 41, "endOffset": 65}, {"referenceID": 2, "context": "\u2022 In line with classical Montague theory Heim and Kratzer (1998), our parser is type-driven parsing instead of syntax-driven as in CCG-based efforts Zettlemoyer and Collins (2005); Kwiatkowski et al.", "startOffset": 41, "endOffset": 180}, {"referenceID": 2, "context": "\u2022 In line with classical Montague theory Heim and Kratzer (1998), our parser is type-driven parsing instead of syntax-driven as in CCG-based efforts Zettlemoyer and Collins (2005); Kwiatkowski et al. (2011); Krishnamurthy and Mitchell (2014) (Section 2.", "startOffset": 41, "endOffset": 207}, {"referenceID": 2, "context": "\u2022 In line with classical Montague theory Heim and Kratzer (1998), our parser is type-driven parsing instead of syntax-driven as in CCG-based efforts Zettlemoyer and Collins (2005); Kwiatkowski et al. (2011); Krishnamurthy and Mitchell (2014) (Section 2.", "startOffset": 41, "endOffset": 242}, {"referenceID": 2, "context": "\u2022 In line with classical Montague theory Heim and Kratzer (1998), our parser is type-driven parsing instead of syntax-driven as in CCG-based efforts Zettlemoyer and Collins (2005); Kwiatkowski et al. (2011); Krishnamurthy and Mitchell (2014) (Section 2.3). \u2022 We introduce parametric polymorphism into natural language semantics (Section 3), along with proper treatment of subtype polymorphism, and implement Hindley-Milner style type inference (Pierce, 2005, Chap. 10) during parsing (Section 3.2).1 \u2022 We adapt the latent-variable max-violation perceptron training from machine translation Yu et al. (2013), which is a perfect fit for semantic parsing due to its huge search space (Section 4).", "startOffset": 41, "endOffset": 607}, {"referenceID": 2, "context": "The simply typed lambda calculus Heim and Kratzer (1998); Lu and Ng (2011) augments the system with types, including base types (entities e, truth values t, or numbers i), and function types (e.", "startOffset": 33, "endOffset": 57}, {"referenceID": 2, "context": "The simply typed lambda calculus Heim and Kratzer (1998); Lu and Ng (2011) augments the system with types, including base types (entities e, truth values t, or numbers i), and function types (e.", "startOffset": 33, "endOffset": 75}, {"referenceID": 2, "context": "We also note that this typechecking mechanism, inspired by the classical type-driven theory in linguistics Heim and Kratzer (1998), eliminates the need for an explicit encoding of direction as in CCG, which makes our formalism much simpler than the synchronous syntactic-semantic ones in most other semantic parsing efforts Zettlemoyer and Collins (2005, 2007); Wong and Mooney (2007).", "startOffset": 107, "endOffset": 131}, {"referenceID": 2, "context": "We also note that this typechecking mechanism, inspired by the classical type-driven theory in linguistics Heim and Kratzer (1998), eliminates the need for an explicit encoding of direction as in CCG, which makes our formalism much simpler than the synchronous syntactic-semantic ones in most other semantic parsing efforts Zettlemoyer and Collins (2005, 2007); Wong and Mooney (2007).", "startOffset": 107, "endOffset": 385}, {"referenceID": 2, "context": "This is different from classical simply-typed Montague semantics Heim and Kratzer (1998) which defines such predicates as type top\u2192t so that city(mississippi : st) returns false.", "startOffset": 65, "endOffset": 89}, {"referenceID": 3, "context": "We follow the Latent Variable Violation-Fixing Perceptron framework Huang et al. (2012); Yu et al.", "startOffset": 68, "endOffset": 88}, {"referenceID": 3, "context": "We follow the Latent Variable Violation-Fixing Perceptron framework Huang et al. (2012); Yu et al. (2013) for the training.", "startOffset": 68, "endOffset": 106}, {"referenceID": 13, "context": "Following Yu et al. (2013), we then find the step i\u2217 with the maximal score difference between the best reference partial derivation and the Viterbi partial derivation: i\u2217 \u2206 = argmax i w \u00b7\u2206\u03a6(x, di (x, y), d \u2212 i (x, y)),", "startOffset": 10, "endOffset": 27}, {"referenceID": 1, "context": "Unlike syntactic incremental parsing, where the forced decoding can be done in polynomial time Goldberg et al. (2014), we do not have an algorithm designed for efficient forced decoding.", "startOffset": 95, "endOffset": 118}, {"referenceID": 14, "context": "For evaluation, we follow Zettlemoyer and Collins (2005) to use precision and recall, where", "startOffset": 26, "endOffset": 57}, {"referenceID": 14, "context": "Following the scheme of Zettlemoyer and Collins (2007), we use the first 600 sentences of Geo880 as the training set and the rest 280 sentences as the testing set.", "startOffset": 24, "endOffset": 55}, {"referenceID": 14, "context": "Following the splitting scheme of Zettlemoyer and Collins (2005), we use 500 sentences as training set and 140 sentences as testing set.", "startOffset": 34, "endOffset": 65}, {"referenceID": 14, "context": "Following the splitting scheme of Zettlemoyer and Collins (2005), we use 500 sentences as training set and 140 sentences as testing set. Table 1 shows that our algorithm achieves significantly higher recall than existing method of Zettlemoyer and Collins (2005), although our precision is not as high as theirs.", "startOffset": 34, "endOffset": 262}, {"referenceID": 5, "context": "Kwiatkowski et al. (2013) use \u201con-the-fly\u201d matching to fetch the most possible predicate in the dataset for some MR subexpression.", "startOffset": 0, "endOffset": 26}, {"referenceID": 5, "context": "Kwiatkowski et al. (2013) use \u201con-the-fly\u201d matching to fetch the most possible predicate in the dataset for some MR subexpression. The matching happens at the end of parsing, and is constrained by the type of the subexpression. We do matching and parsing jointly, both of which are constrained by the typing, and affect the typing, which is more similar to how human do semantic parsing, i.e., we parse part of the sentence and bind that part to some specific meaning, and continue parsing using grounded meaning. Wong and Mooney (2007) also use type information to help reduce unnecessary tree joining in decoding.", "startOffset": 0, "endOffset": 537}], "year": 2014, "abstractText": "Semantic parsing has made significant progress, but most current semantic parsers are extremely slow (CKY-based) and rather primitive in representation. We introduce three new techniques to tackle these problems. First, we design the first linear-time incremental shift-reduce-style semantic parsing algorithm which is more efficient than conventional cubic-time bottom-up semantic parsers. Second, our parser, being type-driven instead of syntax-driven, uses type-checking to decide the direction of reduction, which eliminates the need for a syntactic grammar such as CCG. Third, to fully exploit the power of type-driven semantic parsing beyond simple types (such as entities and truth values), we borrow from programming language theory the concepts of subtype polymorphism and parametric polymorphism to enrich the type system in order to better guide the parsing. Our system learns very accurate parses in GEOQUERY, JOBS and ATIS domains.", "creator": "LaTeX with hyperref package"}}}