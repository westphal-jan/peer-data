{"id": "1412.3633", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Dec-2014", "title": "Logic of temporal attribute implications", "abstract": "we efficiently study logic for precision reasoning with if - then consistent formulas describing because dependencies existed between attributes of objects which are automatically observed already in continuous consecutive points in normal time. we therefore introduce correct semantic entailment structures of the formulas, tools show improve its fixed - point approximation characterization, investigate simple closure properties arise of a model classes, models present resolve an axiomatization challenge and prove its truth completeness, complete and partially investigate finite alternative axiomatizations \u2014 and project normalized proofs. we greatly investigate decidability and complexity issues inside of the geometric logic statements and easily prove np - th hardness of the entailment requirement problem. we show that by restricting these to predictive formulas, the entailment problem is decidable even in long pseudo - linear time.", "histories": [["v1", "Thu, 11 Dec 2014 12:41:51 GMT  (32kb)", "https://arxiv.org/abs/1412.3633v1", null], ["v2", "Mon, 4 May 2015 08:01:28 GMT  (33kb)", "http://arxiv.org/abs/1412.3633v2", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.DB", "authors": ["jan triska", "vilem vychodil"], "accepted": false, "id": "1412.3633"}, "pdf": {"name": "1412.3633.pdf", "metadata": {"source": "CRF", "title": "Logic of temporal attribute implications", "authors": ["Jan Triska", "Vilem Vychodil"], "emails": ["jan.triska@upol.cz,"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 2.\n36 33\nv2 [\ncs .L\nO ]\nWe study logic for reasoning with if-then formulas describing dependencies between attributes of objects which are observed in consecutive points in time. We introduce semantic entailment of the formulas, show its fixed-point characterization, investigate closure properties of model classes, present an axiomatization and prove its completeness, and investigate alternative axiomatizations and normalized proofs. We investigate decidability and complexity issues of the logic and prove that the entailment problem is NP-hard and belongs to EXPSPACE. We show that by restricting to predictive formulas, the entailment problem is decidable in pseudo-linear time.\nKeywords: attribute implication, complete axiomatization, entailment problem, fixed point, functional dependency, temporal semantics"}, {"heading": "1 Introduction", "text": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications. In these disciplines, the rules often appear under different names (e.g., attribute implications, functional dependencies, or\n\u2217e-mail: jan.triska@upol.cz, phone: +420 585 634 715, fax: +420 585 411 643\nsimply \u201crules\u201d) with semantics defined in various structures (e.g., transactional data, boolean matrices, or n-ary relations) but as it has been shown in [21], the rules may be seen as propositional formulas with the semantic entailment defined as in the propositional logic, possibly extended by additional measures of interestingness. The rules are popular because of their easy readability for non-expert users and tractability of the entailment problem which is decidable in linear time [6]. Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].\nIn this paper, we introduce if-then formulas which express presence of attributes relatively in time and the formulas are evaluated in data where the presence or absence of attributes changes in time. In our approach, we adopt the notion of a discrete time, i.e., the data are observed at distinct points in time. We consider a formula valid in data changing over time if the if-then dependency prescribed by the formula holds in all time points. We introduce the formulas as expressions\n{ yi11 , . . . , y im m } \u21d2 { z j1 1 , . . . , z jn n } , (1)\nwhere y1, . . . , ym and z1, . . . , zn are attributes which may be viewed as propositional variables, and i1, . . . , im, j1, . . . , jn are integers annotating the attributes by relative time points with the following meaning: 0 denotes the present time point, 1 is its immediate successor, \u22121 is the immediate predecessor of 0, 2 is the immediate successor of 1, etc. With this interpretation of time points and considering, for instance, the unit of time \u201ca day\u201d, formula {x\u22121, y0} \u21d2 {z1} prescribes the following dependency: \u201cIf x was present yesterday and y is present today, then z will be present tomorrow.\u201d From our perspective, a classic if-then formula\n{ y1, . . . , ym } \u21d2 { z1, . . . , zn } , (2)\nmay be seen as a particular case of (1), where all the relative time points\ni1, . . . , im, j1, . . . , jn are equal to 0, and the data in which the formula is evaluated is constant in all time points.\nWe provide answers to several questions which emerge with formulas like (1). First, we define the notion of semantic entailment of the formulas, investigate closure structures of models of theories consisting of such formulas, and show that the problem of checking whether a formula is semantically entailed by a set of formulas can be reduced to checking its validity in a single model. Second, we prove that the semantic entailment has a complete axiomatization. That is, we show a notion of provability of formulas like (1) and show that it coincides with the semantic entailment. We discuss several possible axiomatizations, including ones that can be used to consider proofs in particular normal forms. Third, based on our insight into the properties of the semantic entailment and provability, we derive results on decidability and complexity of the entailment problem. Fourth, we include notes on the relationship of the formulas to formulas appearing in modal logics [9] and triadic formal concept analysis [34]. Similar rules as we consider in this paper appeared as inter-transaction association rules [52] inferred from time-changing transactional data. Despite the popularity of the rules in data mining, a logical analysis of the entailment of the rules and related properties is missing\u2014providing the logical foundations is a goal of our paper.\nOur paper is organized as follows. In Section 2 and Section 3, we present a survey of related work and short preliminaries. We introduce the formulas and present the results on their semantic entailment in Section 4. In Section 5 we give complete axiomatizations and in Section 6 we deal with the related computational issues. Finally, in Section 7, we present a conclusion."}, {"heading": "2 Related Work", "text": "In database systems and knowledge engineering, there appeared isolated approaches which propose temporal semantics of if-then rules. We present here a short survey of the approaches and highlight the differences between our ap-\nproach and the existing ones.\nFormulas called temporal functional dependencies emerged in databases with time granularities [7]. In this approach, a time granularity is a general partition of time like seconds, weeks, years, etc., and a time granularity is associated to each relational schema. In addition, each tuple in a relation is associated with a part (so-called granule) of granularity. In this setting, temporal functional dependencies are like the ordinary functional dependencies [21] with a time granularity as an additional component. The concept of validity of temporal functional dependencies is defined in much the same way as its classic counterpart and includes an additional condition that granules of tuples need to be covered by any granule from granularity of the temporal functional dependency. Thus, [7] uses an ordinary notion of validity of functional dependencies which is restricted to some time segments. This is conceptually very different from the problem we deal with in this paper.\nSeveral approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46]. In these approaches, the input data is in the form of transactions (i.e., subsets of items) where each transaction occurred at some point in time and the interest of the papers lies in extracting association rules from data which occur during a specified time cycle. For instance, one may be interested in extracting rules which are valid in \u201cevery spring month of a year\u201d, \u201cevery Monday in every year\u201d, etc. As in the case of the temporal functional dependencies, the temporal association rules may be understood as classic association rules occurring during specified time cycles.\nOther results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches. The papers propose algorithms to extract, given an input transactional data and a measure of interestingness (based on levels of minimal support and confidence), if-then rules which are preserved over a given period of time. From this point of view, the rules can be seen as formulas studied in this paper restricted to so-called predictive rules (see Definition 33 in Sec-\ntion 6) whose validity is considered with respect to the additional parameter of interestingness. As a consequence, the inter-transaction association rules are related to the rules in our approach in the same way as the ordinary association rules [1] are related to the ordinary attribute implications [26]. The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic. In contrast, the problems of entailment of rules are central to this paper and we show there is reasonably strong logic for reasoning with such rules. Our observations may stimulate further development in the field of inter-transaction association rules and similar formulas and their applications in various domains [23, 30].\nThe formulas studied in this paper are also related to particular program rules which appear in Datalog extensions dealing with flow of time and related phenomena [10, 11, 12] such as DatalognS (Datalog with n successors). The formulas we consider in our paper correspond to a fragment of rules which appear in such Datalog extensions. Despite the similar form of our formulas and the program rules, there does not seem to be a direct relationship (or a reduction) of the entailment problem of our formulas and the recognition problem of DatalognS programs."}, {"heading": "3 Preliminaries", "text": "In this section, we present the basic notions of closure systems (also known as Moore families) and closure operators which are used further in the paper. More details can be found in [8, 18].\nIf Y is a set, we denote by 2Y its power set. A closure operator on Y is a\nmap c : 2Y \u2192 2Y such that\nA \u2286 c(A), (3)\nA \u2286 B implies c(A) \u2286 c(B), (4)\nc(c(A)) \u2286 c(A), (5)\nfor all A,B \u2286 Y . The conditions (3)\u2013(5) are called the extensivity, monotony, and idempotency of c, respectively. Note that (3) and (5) yield c(A) = c(c(A)) for all A \u2286 Y . A closure operator c : 2Y \u2192 2Y is called an algebraic closure operator whenever\nc(A) = \u22c3 {c(B) |B \u2286 A and B is finite} (6)\nfor all A \u2286 Y . Moreover, A \u2286 Y is called a fixed point of c whenever c(A) = A.\nA system S \u2286 2Y is called a closure system on Y if it is closed under arbitrary intersections, i.e., \u22c2 A \u2208 S for any A \u2286 S. In the paper we utilize the wellknown correspondence between closure systems and closure operators on Y . In particular, if c is an algebraic closure operator on Y , we call the closure system of all its fixed points the algebraic closure system induced by c."}, {"heading": "4 Formulas, Models, and Semantic Entailment", "text": "In this section, we present a formalization of the formulas, their interpretation, and semantic entailment. Let us assume that Y is a non-empty and finite set of symbols called attributes. Furthermore, we use integers in order to denote time points. We put\nTY = { yi | y \u2208 Y and i \u2208 Z } (7)\nand interpret each yi \u2208 TY as \u201cattribute y observed in time i\u201d (technically, TY can be seen as the Cartesian product Y \u00d7Z). Under this notation, we may now formalize rules like (1) as follows:\nDefinition 1. An attribute implication over Y annotated by time points in Z is a formula of the form A\u21d2 B, where A,B are finite subsets of TY .\nAs we have outlined in the introduction, the purpose of time points encoded by integers which appear in antecedents and consequents of the considered formulas is to express points in time relatively to a current time point. Hence, the intended meaning of (1) abbreviated by A \u21d2 B is the following: \u201cFor all time\npoints t, if an object has all the attributes from A considering t as the current time point, then it must have all the attributes from B considering t as the current time point\u201d. In what follows, we formalize the interpretation of A\u21d2 B in this sense.\nSince we wish to define formulas being true in all time points (we are interested in formulas preserved over time), we need to shift relative times expressed in antecedents and consequents in formulas with respect to a changing time point. For that purpose, for each M \u2286 TY and i \u2208 Z, we may introduce a subset M + j of TY by\nM + j = { yi+j | yi \u2208M } (8)\nand call it a time shift of M by j (shortly, a j-shift of M). In the paper, we utilize the following properties of time shifts.\nProposition 2. For all M,N \u2286 TY , {Nk \u2286 TY | k \u2208 K}, and i, j \u2208 Z, we get\nif M \u2286 N then M + i \u2286 N + i, (9)\n(M + i) + j =M + (i+ j), (10) \u22c3\nk\u2208K(Nk + i) = \u22c3 k\u2208K Nk + i, (11)\n\u22c2 k\u2208K(Nk + i) = \u22c2 k\u2208K Nk + i. (12)\nProof. All (9)\u2013(12) follow directly from (8).\nBased on (10), we may omit parentheses and write M + j + i instead of\n(M + i) + j. Also, we write M \u2212 i to denote M + (\u2212i).\nAttribute implications annotated by time points are formulas, i.e., syntactic\nnotions for which we define their semantics (interpretation) as follows.\nDefinition 3. A formula A\u21d2 B is true in M \u2286 TY whenever, for each i \u2208 Z,\nif A+ i \u2286M , then B + i \u2286M (13)\nand we denote the fact by M |= A\u21d2 B.\nRemark 1. (a) The value of i in the definition may be understood as a sliding time point. Moreover, A + i and B + i represent sets of attributes annotated by absolute time points considering i as the current time point. Note that using (8), the condition (13) can be equivalently restated as \u201cA \u2286M \u2212 i implies B \u2286 M \u2212 i,\u201d i.e., instead of shifting the antecedents and consequents of the formula, we may shift the set M .\n(b) Observe that A \u21d2 B is trivially true in M whenever B \u2286 A because in that case (13) trivially holds for any i. By definition, A\u21d2 B is not true in M , written M 6|= A \u21d2 B iff there is i such that A + i \u2286 M and B + i * M . In words, in the time point i, M has all the attributes of A but does not have an attribute in B, i.e., the time point i serves as a counterexample.\nExample 1. One particular example of a subsetM of TY can be a daily weather observation from an airport station. For instance, we can consider Y as\nY = {rn, rl, rm, tv, tc, tm, wl, wm, ws},\nwhere the attributes have the following meaning: \u201cno rainfall\u201d (denoted rn), \u201clight rainfall\u201d (denoted rl), \u201cmoderate rainfall\u201d (denoted rm), \u201ctemperature\nis very cold\u201d, (denoted tv), \u201ctemperature is cold\u201d, (denoted tc) \u201ctemperate is mild\u201d, (denoted tm) \u201clight wind\u201d (denoted wl), \u201cmoderate wind\u201d (denoted wm), and \u201cstrong wind\u201d (denoted ws). A subset of TY may be depicted as a two-dimensional table with rows corresponding to time points, columns corresponding to attributes in Y , and crosses and blanks in the table, indicating whether attributes annotated by time points belong to the subset. For instance, if M is given by the table in Figure 4, then rn15 \u2208 M , rl15 6\u2208 M , etc1. In this case, we haveM |= {wl0, wm1} \u21d2 {tc3}. On the other hand, M 6|= {wm0, wl1} \u21d2 {tc3, rm3, tc4} because for i = 22, we have {wm0, wl1}+22 = {wm22, wl23} \u2286M and {tc3, rm3, tc4}+ 22 = {tc25, rm25, tc26} *M .\nWe consider the following notions of a theory and a model:\nDefinition 4. Let \u03a3 be a set of formulas (called a theory). A subset M \u2286 TY is called a model of \u03a3 if M |= A \u21d2 B for all A \u21d2 B \u2208 \u03a3. The system of all models of \u03a3 is denoted by Mod(\u03a3), i.e.,\nMod(\u03a3) = { M \u2286 TY |M |= A\u21d2 B for all A\u21d2 B \u2208 \u03a3 } . (14)\nIn general, Mod(\u03a3) is infinite and there may be theories that do not have\nany finite model. For instance, consider a theory containing \u2205 \u21d2 {y0}.\nWe now turn our attention to the structure of systems of all models of attribute implications annotated by time points. In case of the ordinary attribute implications, it is well known that systems of their models are exactly closure systems in Y . Interestingly, the systems of models in our case are exactly the algebraic closure systems which are closed under time shifts. This additional closure property is introduced by the following definition.\nDefinition 5. A system S \u2286 2TY of subsets of TY is called closed under time shifts whenever M + i \u2208 S for all M \u2208 S and i \u2208 Z.\nWe first show that Mod(\u03a3) is a closure system closed under time shifts:\n1The data is based on discretization of real meteorological information for Aug 14 which\ncan be found at http://www.bom.gov.au/climate/dwo/IDCJDW0100.shtml .\nTheorem 6. Let \u03a3 be a theory. Then, Mod(\u03a3) is closed under arbitrary intersections and time shifts.\nProof. The fact that Mod(\u03a3) is closed under arbitrary intersections follows by analogous arguments as in the case of ordinary attribute implications taking into account that (13) must hold for all i \u2208 Z. That is, for any M \u2286 Mod(\u03a3) and arbitrary A \u21d2 B \u2208 \u03a3, we reason as follows. If A + i \u2286 \u22c2 M, then A + i \u2286 M for all M \u2208 M and thus B + i \u2286 M for all M \u2208 M because M \u2286 Mod(\u03a3). Therefore, B+ i \u2286 \u22c2 M, proving \u22c2 M |= A\u21d2 B which further gives \u22c2 M \u2208 Mod(\u03a3) since A\u21d2 B \u2208 \u03a3 was arbitrary.\nIn order to show that Mod(\u03a3) is closed under time shifts, takeM \u2208 Mod(\u03a3) and j \u2208 Z. It suffices to prove that M + j \u2208 Mod(\u03a3). In order to see that, take A\u21d2 B \u2208 \u03a3. If A+ i \u2286M + j, then A+ (i\u2212 j) \u2286M and thus B + (i\u2212 j) \u2286M because M \u2208 Mod(\u03a3) and A \u21d2 B \u2208 \u03a3. Therefore, B + i \u2286 M + j, i.e., M + j |= A\u21d2 B for arbitrary A\u21d2 B \u2208 \u03a3, showing M + j \u2208 Mod(\u03a3).\nTaking into account Theorem 6, for each theory \u03a3, we may consider a closure operator induced by Mod(\u03a3) which maps each M \u2286 TY to the least model of \u03a3 containing M .\nDefinition 7. Let \u03a3 be a theory. For each M \u2286 TY , we put\n[M ]\u03a3 = \u22c2 {N \u2208 Mod(\u03a3) |M \u2286 N} (15)\nand call [M ]\u03a3 the semantic closure of M under \u03a3.\nUsing the well-known relationship between closure operators and closure systems, [\u00b7 \u00b7 \u00b7]\u03a3 defined by (15) is indeed a closure operator. Note that in general, [M ]\u03a3 is infinite even if Y andM are finite. This is in contrast with the ordinary attribute implications using finite Y . Nevertheless, in our setting we can prove that even if [M ]\u03a3 is infinite, it can be obtained as a union of finitely generated elements of Mod(\u03a3), showing that Mod(\u03a3) is in fact an algebraic closure system.\nTheorem 8. Let \u03a3 be a theory. For each M \u2286 TY , we have\n[M ]\u03a3 = \u22c3 {[N ]\u03a3 |N is finite subset of M}. (16)\nProof. Observe that the monotony of [\u00b7 \u00b7 \u00b7]\u03a3 yields [N ]\u03a3 \u2286 [M ]\u03a3 for any finite N \u2286M and thus the \u201c\u2287\u201d-part of (16) is obvious.\nFor brevity, put M = {[N ]\u03a3 |N is finite subset of M}. In order to prove the \u201c\u2286\u201d-part of (16), it suffices to show that \u22c3 M is a model of \u03a3 which containsM because [M ]\u03a3 is the least model of \u03a3 containing M . For any y i \u2208 M , we have [{yi}]\u03a3 \u2208 M and thus yi \u2208 [{yi}]\u03a3 \u2286 \u22c3 M by the extensivity of [\u00b7 \u00b7 \u00b7]\u03a3 which proves M \u2286 \u22c3 M.\nNow, take any A \u21d2 B \u2208 \u03a3 and suppose that A + i \u2286 \u22c3 M. Observe that for every yj \u2208 A+ i there is [Nyj ]\u03a3 \u2208 M such that y j \u2208 [Nyj ]\u03a3. Moreover, the fact that A+ i is finite yields that \u22c3 {Nyj | y\nj \u2208 A+ i} is finite and we thus have [\u22c3\n{Nyj | y j \u2208 A+ i}\n]\n\u03a3 \u2208 M. Clearly, A+ i \u2286\n[\u22c3 {Nyj | y j \u2208 A+ i} ]\n\u03a3 and thus\nit follows that B + i \u2286 [\u22c3\n{Nyj | y j \u2208 A + i}\n]\n\u03a3 \u2286\n\u22c3 M because A \u21d2 B \u2208 \u03a3.\nAltogether, \u22c3 M |= A\u21d2 B and so \u22c3 M \u2208 Mod(\u03a3).\nUsing Theorem 8, we may establish that each algebraic closure system closed under time shifts is a system of models of some theory consisting of attribute implications annotated by time points. Before we go to the proof, we show how the property of being closed under time shifts can be formulated in terms of closure operators.\nLemma 9. Let S be a closure system which is closed under arbitrary time shifts and let CS be the induced closure operator. For each M \u2286 TY and i \u2208 Z,\nCS(M + i) = CS(M) + i. (17)\nProof. \u201c\u2286\u201d: Since S is closed under time shifts, we get CS(M) + i \u2208 S. In addition, M + i \u2286 CS(M) + i on account of the extensivity of CS and (9). Therefore, CS(M + i) \u2286 CS(M) + i by monotony and idempotency of CS .\n\u201c\u2287\u201d: The extensivity of CS gives M + i \u2286 CS(M + i) and thus M \u2286 CS(M + i) \u2212 i. Moreover, CS(M + i) \u2212 i \u2208 S because S is closed under time shifts and thus CS(M) \u2286 CS(M+i)\u2212i which gives CS(M)+i \u2286 CS(M+i).\nLemma 10. Let C be a closure operator satisfying C(M + i) = C(M) + i for\neach M \u2286 TY and i \u2208 Z. Then, the system SC of all fixed points of C is closed under arbitrary time shifts.\nProof. TakeM \u2208 SC and any i \u2208 Z, i.e.,M \u2286 TY such thatM = C(M). Clearly, M + i = C(M) + i and since C(M) + i = C(M + i), we get M + i = C(M + i), proving that M + i \u2208 SC.\nThe previous two lemmas give the following consequence.\nCorollary 11. A closure system S is closed under arbitrary time shifts iff the corresponding closure operator CS satisfies (17).\nBased on our previous observations, we may now establish the connection between systems of models of attribute implications annotated by time points and algebraic closure systems closed under time shifts.\nTheorem 12. Let S \u2286 2TY be an algebraic closure system which is closed under time shifts. Then, there is a theory \u03a3 such that S = Mod(\u03a3).\nProof. Assume that CS is the closure operator induced by S and put\n\u03a3 = {A\u21d2 B |A \u2286 TY , B \u2286 CS(A), and A,B are finite}.\nWe show that S = Mod(\u03a3) by proving that both inclusions hold.\n\u201c\u2286\u201d: Take M \u2208 S and a finite B \u2286 CS(A) for a finite A \u2286 TY . We now check thatM |= A\u21d2 B. Assume that A+ i \u2286M . Then, A \u2286M \u2212 i and by the monotony of CS and utilizing (17), we have CS(A) \u2286 CS(M\u2212i) = CS(M)\u2212i = M \u2212 i which yields that B \u2286M \u2212 i, i.e., B+ i \u2286M , showing M |= A\u21d2 B. As a consequence, S \u2286 Mod(\u03a3).\n\u201c\u2287\u201d: We letM \u2208 Mod(\u03a3) and prove thatM \u2208 S which means to prove that CS(M) = M . Since S is an algebraic closure system, it suffices to check that CS(A) \u2286M for each finite A \u2286M . Assuming that A \u2286M and A is finite, take any finite B \u2286 CS(A). By definition, A \u21d2 B \u2208 \u03a3 and since M \u2208 Mod(\u03a3), we get that for i = 0, A+0 \u2286M implies B+0 \u2286M . Since A+0 = A and A \u2286M , we therefore obtain B = B + 0 \u2286M . Since B was an arbitrary finite subset of CS(A), we conclude that CS(A) \u2286M .\nWe now define semantic entailment of formulas and explore its properties. The notion is defined the usual way using the notion of a model introduced before.\nDefinition 13. Let \u03a3 be a theory. Formula A\u21d2 B is semantically entailed by \u03a3 if M |= A\u21d2 B for each M \u2208 Mod(\u03a3).\nThe following lemma justifies the description of time points in attribute implications as relative time points. Namely, it states that each A\u21d2 B semantically entails all formulas resulting by shifting the antecedent and consequent of A\u21d2 B by a constant factor.\nLemma 14. {A\u21d2 B} |= A+ i\u21d2 B + i.\nProof. TakeM \u2208 Mod({A\u21d2 B}) and let (A+ i)+j \u2286M . Then, A+ i \u2286M\u2212j and by Theorem 6, we getM \u2212 j \u2208 Mod({A\u21d2 B}) which yields B+ i \u2286M \u2212 j and thus (B + i) + j \u2286M , proving M |= A+ i\u21d2 B + i\nAnalogously as for the classic attribute implications, the semantic entailment of A \u21d2 B by a theory \u03a3 can be checked using the least model of \u03a3 generated by A as it is shown in the following theorem.\nTheorem 15. For any \u03a3 and A\u21d2 B, the following conditions are equivalent:\n(i) \u03a3 |= A\u21d2 B,\n(ii) [A]\u03a3 |= A\u21d2 B,\n(iii) B \u2286 [A]\u03a3.\nProof. Clearly, (i) implies (ii) since [A]\u03a3 \u2208 Mod(\u03a3); (ii) implies (iii) because A + 0 \u2286 [A]\u03a3. Assume that (iii) holds and take M \u2208 Mod(\u03a3) and i \u2208 Z such that A+ i \u2286 M . Then, A \u2286 M \u2212 i and thus B \u2286 [A]\u03a3 \u2286 [M \u2212 i]\u03a3 = [M ]\u03a3 \u2212 i by (17) from which it follows that B + i \u2286 [M ]\u03a3 =M , proving (i).\nWe conclude this section by notes on the propositional semantics of our formulas. The classic attribute implications on finite Y can be understood as\npropositional formulas. Namely, an attribute implication of the from (2) can be seen as a propositional formula\n( y1N \u00b7 \u00b7 \u00b7N ym ) \u21d2 ( z1 N \u00b7 \u00b7 \u00b7N zn ) , (18)\nwhere N is the symbol for conjunction and y1, . . . , ym, z1, . . . , zn are propositional variables. Thus, (18) may be called a propositional counterpart of (2). Obviously, there are in general several propositional counterparts of (2) since formulas equivalent to (18) in sense of the propositional logic result, e.g., by rearranging the propositional variables y1, . . . , ym, z1, . . . , zn in a different order. We neglect this aspect and always consider a fixed propositional counterpart of each attribute implication. It can be shown that if one takes the propositional counterparts of attribute implications, then their semantic entailment in sense of the propositional logic coincides with the semantic entailment as it is defined for attribute implications. We now show that an analogous correspondence can also be established in our case.\nWe start by considering the following notation. For any finite A,B \u2286 TY\nand for any M \u2286 TY , we put M |=PL A \u21d2 B whenever A * M or B \u2286 M . That is, M |=PL A\u21d2 B means that A\u21d2 B is true in M as a classical attribute implication. Clearly, M |=PL A\u21d2 B does not imply that M |= A\u21d2 B in sense of Definition 3. Moreover, we may introduce the set of models of \u03a3 in the classic sense:\nModPL(\u03a3) = { M \u2286 TY |M |=PL A\u21d2 B for all A\u21d2 B \u2208 \u03a3 } (19)\nand put \u03a3 |=PL A \u21d2 B whenever M |=PL A \u21d2 B for all M \u2208 Mod PL(\u03a3). Therefore, |=PL denotes the semantic entailment of attribute implications in the classic sense. Again, |=PL is in general different from |= introduced in Definition 13 but we can establish the following characterization:\nTheorem 16. Let \u03a3 be a theory and let\n\u03a3PL = {A+ i\u21d2 B + i |A\u21d2 B \u2208 \u03a3 and i \u2208 Z}. (20)\nThen Mod(\u03a3) = ModPL(\u03a3PL). As a consequence, for each A \u21d2 B, we have \u03a3 |= A\u21d2 B iff \u03a3PL |=PL A\u21d2 B.\nProof. The first part of the claim is easy to see. Indeed, for each A\u21d2 B we have M \u2208 Mod({A\u21d2 B}) iff for each i \u2208 Z, we have A+ i \u2286M implies B + i \u2286M which is true iff M \u2208 ModPL({A + i \u21d2 B + i | i \u2208 Z}). Hence, it follows that Mod(\u03a3) = ModPL(\u03a3PL).\nNow, assume that \u03a3 |= A \u21d2 B and take M \u2208 ModPL(\u03a3PL) such that A \u2286M . Then A+0 \u2286M and M \u2208 Mod(\u03a3) and thus B = B+0 \u2286M , proving that \u03a3PL |=PL A \u21d2 B. Conversely, let \u03a3PL |=PL A \u21d2 B and A + i \u2286 M for M \u2208 Mod(\u03a3). That is, we have A \u2286 M \u2212 i and, owing to Theorem 6, M \u2212 i \u2208 Mod(\u03a3) = ModPL(\u03a3PL). As a consequence of M \u2212 i |=PL A \u21d2 B, we get B \u2286 M \u2212 i and thus B + i \u2286 M , showing \u03a3 |= A \u21d2 B. Altogether, \u03a3 |= A\u21d2 B iff \u03a3PL |=PL A\u21d2 B.\nNow, based on Theorem 16, we may argue that for each \u03a3 there is a set of propositional formulas \u03a3\u2032 such that the propositional counterpart of A\u21d2 B follows by \u03a3\u2032 in sense of the propositional logic. Indeed, \u03a3\u2032 can be taken as the set of propositional counterparts to all formulas in \u03a3PL: Owing to Theorem 16, A \u21d2 B follows by \u03a3PL as a classic attribute implication over (a denumerable set of attributes) TY and thus the propositional counterpart of A \u21d2 B follows by the propositional counterparts to all formulas in \u03a3PL."}, {"heading": "5 Deduction Systems and Complete Axiomatizations", "text": "In this section, we present a deduction system for our formulas and a related notion of provability which represents the syntactic entailment of formulas. The provability is based on an extension of the Armstrong axiomatic system [3] which is well known mainly in database systems [42]. The extension we propose accommodates the fact that time points in formulas are relative. The deductive system we use consists of the following deduction rules.\nDefinition 17. We introduce the following deduction rules :\n(Ax) infer A\u222aB \u21d2 A,\n(Cut) from A\u21d2 B and B\u222aC \u21d2 D infer A\u222aC \u21d2 D,\n(Shf) from A\u21d2 B infer A+ i\u21d2 B + i,\nwhere i \u2208 Z and A,B,C,D are arbitrary finite subsets of TY .\nRemark 2. (a) Note that there are several equivalent systems which are called the Armstrong systems [42]. In our presentation, the rule (Ax) can be seen as a nullary deduction rule which is an axiom scheme, i.e., each A\u222aB \u21d2 A may be called an axiom. (Cut) and (Shf) are binary and unary deduction rules, respectively. In the classic case, (Ax) and (Cut) form a system which is equivalent to that from [3]. We call the additional rule (Shf) the rule of \u201ctime shifts.\u201d Also note that in the database literature, (Cut) is also referred to as the rule of pseudo-transitivity [42].\n(b) The rules in Definition 17 can be written as fractions with hypotheses (formulas preceding \u201cinfer\u201d) above the conclusion (formula following \u201cinfer\u201d) as\nA\u222aB \u21d2 A (Ax),\nA\u21d2 B, B\u222aC \u21d2 D\nA\u222aC \u21d2 D (Cut),\nA\u21d2 B\nA+ i\u21d2 B + i (Shf).\nAlthough we are going to use (Ax), (Cut), and (Shf) as the basic deduction rules in our system, we define the notion of provability relatively to a collection of deduction rules because we later investigate systems consisting of other rules. Thus, a general deduction system is a set R of n-ary rules of the form \u201cfrom \u03d51, . . . , \u03d5n, infer \u03c8\u201d.\nDefinition 18. Let R be a deduction system. An R-proof of A\u21d2 B by \u03a3 is a finite sequence \u03b41, . . . , \u03b4n such that \u03b4n equals A \u21d2 B and for each i = 1, . . . , n we have\n(i) \u03b4i \u2208 \u03a3, or\n(ii) R contains a rule \u201cfrom \u03d51, . . . , \u03d5n infer \u03c8\u201d such that \u03c8 is equal to \u03b4i and\nwe have {\u03d51, . . . , \u03d5n} \u2286 {\u03b4j | j < i}.\nWe say that A \u21d2 B is R-provable by \u03a3, denoted \u03a3 \u22a2R A \u21d2 B, if there is an R-proof of A\u21d2 B by \u03a3.\nIf R consists solely of (Ax), (Cut), and (Shf), we write just \u03a3 \u22a2 A\u21d2 B and call A \u21d2 B provable by \u03a3. Analogously, we use the term \u201cproof\u201d instead of \u201cR-proof\u201d. In the paper, we use the following properties of provability.\nProposition 19. For every finite A,B,C,D \u2286 TY , we have\n(Ref) \u22a2 A\u21d2 A,\n(Wea) {A\u21d2 C} \u22a2 A\u222aB \u21d2 C,\n(Acc) {A\u21d2 B\u222aC,C \u21d2 D\u222aE} \u22a2 A\u21d2 B\u222aC\u222aD,\n(Add) {A\u21d2 B,A\u21d2 C} \u22a2 A\u21d2 B\u222aC,\n(Aug) {B \u21d2 C} \u22a2 A\u222aB \u21d2 A\u222aC,\n(Pro) {A\u21d2 B\u222aC} \u22a2 A\u21d2 B,\n(Tra) {A\u21d2 B,B \u21d2 C} \u22a2 A\u21d2 C.\nProof. The laws hold because our system is an extension of the Armstrong system in which the laws hold as well, see [3, 42].\nOur inference system is sound in the usual sense:\nTheorem 20 (soundness). If \u03a3 \u22a2 A\u21d2 B then \u03a3 |= A\u21d2 B.\nProof. The proof goes by induction on the length of a proof, considering the facts that each axiom is true in all models, (Cut) is a sound deduction rule [42], and (Shf) is sound on account of Lemma 14. In a more detail, let \u03b41, . . . , \u03b4n be a proof by \u03a3 and let \u03a3 |= \u03b4i for all i < j. Then, if \u03b4j results by \u03b4i using (Shf) for some i < j, then \u03a3 |= \u03b4i yields that M |= \u03b4i for all M \u2208 Mod(\u03a3) and thus, using Lemma 14, M |= \u03b4j for all M \u2208 Mod(\u03a3), showing \u03a3 |= \u03b4j . The rest follows as in the classic case.\nIn the proof of completeness, we utilize the notion of a syntactic closure\nwhich is introduced as follows.\nDefinition 21. Let \u03a3 be a theory. For each M \u2286 TY , we put\nM0\u03a3 =M, (21)\nMn+1\u03a3 =M n \u03a3 \u222a \u22c3{ F + i |E \u21d2 F \u2208 \u03a3 and E + i \u2286Mn\u03a3 } , (22)\nM\u03c9\u03a3 = \u22c3\u221e n=0M n \u03a3. (23)\nand call M\u03c9\u03a3 the syntactic closure of M under \u03a3.\nBy the Tarski fixpoint theorem [51], the operator which maps M to M\u03c9\u03a3 defined by (23) is indeed a closure operator, so the term \u201cclosure\u201d in the name syntactic closure is appropriate. The following observation shows that the term \u201csyntactic\u201d is also appropriate since closures are directly related to provability.\nLemma 22. Let A,B \u2286 TY be finite. Then, B \u2286 A\u03c9\u03a3 iff \u03a3 \u22a2 A\u21d2 B.\nProof. Suppose that B \u2286 A\u03c9\u03a3. Since B is finite, there is m such that B \u2286 A m \u03a3 . Thus, in order to show that \u03a3 \u22a2 A\u21d2 B, it suffices to check that for every n and every finite D \u2286 An\u03a3, we have \u03a3 \u22a2 A \u21d2 D since then the claim readily follows for D = B and n = m. By induction, assume the claim holds for n and all finite D \u2286 An\u03a3. Consider n+ 1 and take a finite D \u2286 A n+1 \u03a3 . Now, consider a finite\nD\u2032 = {\u3008E \u21d2 F, i\u3009 |E \u21d2 F \u2208 \u03a3 and E + i \u2286 An\u03a3}\nsuch that\nD \u2286 An\u03a3 \u222a \u22c3 {F + i | \u3008E \u21d2 F, i\u3009 \u2208 D\u2032} \u2286 An+1\u03a3 .\nNotice that since we assume D finite, such finite D\u2032 always exists. Now, by induction hypothesis, for each \u3008E \u21d2 F, i\u3009 \u2208 D\u2032, we have \u03a3 \u22a2 A \u21d2 E + i owing to E + i \u2286 An\u03a3 \u2286 A \u03c9 \u03a3. Furthermore, for E \u21d2 F \u2208 \u03a3, we have \u03a3 \u22a2 E + i\u21d2 F + i using (Shf). Thus, (Tra) gives \u03a3 \u22a2 A \u21d2 F + i for each \u3008E \u21d2 F, i\u3009 \u2208 D\u2032. In addition to that, D \u2229 An\u03a3 \u2286 A n \u03a3 and thus \u03a3 \u22a2 A \u21d2 D \u2229 A n \u03a3. Since D \u2032 is finite and D \u2286 (D \u2229An\u03a3)\u222a \u22c3 {F + i | \u3008E \u21d2 F, i\u3009 \u2208 D\u2032}, \u03a3 \u22a2 A\u21d2 D follows by finitely many applications of (Add) and (Pro). As a consequence, \u03a3 \u22a2 A\u21d2 B.\nConversely, assume that \u03a3 \u22a2 A \u21d2 B. By Theorem 20, \u03a3 |= A \u21d2 B. We show that A\u03c9\u03a3 \u2208 Mod(\u03a3). Take E \u21d2 F \u2208 \u03a3, i \u2208 Z and let E + i \u2286 A \u03c9 \u03a3. Since\nE+i is finite, there must be n such that E+i \u2286 An\u03a3 and thus F+i \u2286 A n+1 \u03a3 \u2286 A \u03c9 \u03a3, proving that A\u03c9\u03a3 \u2208 Mod(\u03a3). Now, \u03a3 |= A\u21d2 B and A+0 = A \u2286 A \u03c9 \u03a3 yields that B + 0 = B \u2286 A\u03c9\u03a3.\nNote that Lemma 22 is in fact a syntactic counterpart of Theorem 15. Now,\nusing previous observations, we derive that our logic is complete:\nTheorem 23 (completeness). \u03a3 \u22a2 A\u21d2 B iff \u03a3 |= A\u21d2 B.\nProof. If \u03a3 0 A\u21d2 B, we prove that there is M \u2208 Mod(\u03a3) such that M 6|= A\u21d2 B. Indeed, we show that one can take A\u03c9\u03a3 for M . By Lemma 22, \u03a3 0 A \u21d2 B yields B * A\u03c9\u03a3. So, for i = 0, we have that A+i = A \u2286 A \u03c9 \u03a3 and B+i = B * A \u03c9 \u03a3, i.e., A\u03c9\u03a3 6|= A\u21d2 B. In addition to that, if E+ i \u2286 A \u03c9 \u03a3 for E \u21d2 F \u2208 \u03a3 and i \u2208 Z, then \u03a3 \u22a2 A\u21d2 E+ i by Lemma 22 and so \u03a3 \u22a2 A\u21d2 F + i using (Shf) and (Tra). Using Lemma 22 again, F + i \u2286 A\u03c9\u03a3 which proves A \u03c9 \u03a3 \u2208 Mod(\u03a3). The rest is a consequence of Theorem 20.\nAs a corollary of the previous observations, we get the following assertion\nshowing that both the syntactic and semantic closures coincide.\nTheorem 24. For every M \u2286 TY , we have [M ]\u03a3 =M\u03c9\u03a3 .\nProof. We get [M ]\u03a3 \u2286 M \u03c9 \u03a3 since [M ]\u03a3 is the least model of \u03a3 containing M . Conversely, observe that for any N \u2208 Mod(\u03a3) such that M \u2286 N , it follows that M\u03c9\u03a3 \u2286 N \u03c9 \u03a3 = N . Hence, for N being [M ]\u03a3, we get M \u03c9 \u03a3 \u2286 [M ]\u03a3.\nRemark 3. Let us stress that the notions of semantic and syntactic entailment we have considered in our paper are different from their classic counterparts. Indeed, each attribute implication annotated by time points can also be seen as a classic attribute implication per se because the sets A and B in A \u21d2 B are subsets of TY . Therefore, in addition to the semantic entailment from Definition 13, we may consider the ordinary one which disregards the special role of time points. The same applies to the provability\u2014the classic notion is obtained by omitting the rule (Shf). For instance, \u03a3 = {{x1} \u21d2 {y2}, {y5} \u21d2\n{z2}} proves {x4} \u21d2 {y5} by (Shf) and thus {x4} \u21d2 {z2} by (Tra). On the other hand, \u03a3 does not prove {x4} \u21d2 {z2} without (Shf).\nRemark 4. (a) We can show that our system of deduction rules consisting of (Ax), (Cut), and (Shf) is non-redundant, i.e., all the rules in the system are independent. Indeed, no formulas are provable by \u03a3 = \u2205 using only (Cut) and (Shf) and thus (Ax) is independent. Moreover, (Cut) is independent since all formulas provable by \u03a3 = \u2205 using only (Ax) and (Shf) are exactly all instances of (Ax). The independence of (Shf) follows by Remark 3.\n(b) Let us note that the deductive system in Definition 17 is not minimal in terms of the number of deduction rules. Indeed, we may replace (Cut) and (Shf) by a single deduction rule\nA\u21d2 B + i, B\u222aC \u21d2 D\nA \u222a (C + i) \u21d2 D + i (Cuti). (24)\nIndeed, observe that (Cut) is a particular case of (Cuti) for i = 0 and (Shf) results by (Cuti) and (Ax) for A = B = \u2205. Conversely, {A \u21d2 B + i, B\u222aC \u21d2 D} \u22a2 A\u222a(C + i) \u21d2 D + i because using (11), the sequence\nA\u21d2 B + i, B\u222aC \u21d2 D, (B + i)\u222a(C + i) \u21d2 D + i, A\u222a(C + i) \u21d2 D + i\nis a proof of A\u222a(C + i) \u21d2 D + i using (Cut) and (Shf). As a consequence, the system consisting of (Ax), (Cut), and (Shf) is equivalent to (Ax) and (Cuti).\n(c) An alternative deduction system for our logic can be based on (Ref) instead of (Ax) and a single rule which is a modification of a simplification deduction rule [15]. First, it is easily seen that (Ax) and (Cut) may be equivalently replaced by the following rule and (Ref):\nA\u21d2 B, C \u21d2 D\nA \u222a (C \\B) \u21d2 D (Sim). (25)\nIndeed, (Sim) is a rule derivable by (Ax) and (Cut) because the sequence\nA\u21d2 B,B\u222aC \u21d2 C,C \u21d2 D,B\u222aC \u21d2 D,A\u222a(C\\B) \u21d2 D,\nis a proof of A\u222a(C\\B) \u21d2 D by {A\u21d2 B,C \u21d2 D} using (Ax) and (Cut); apply the rule twice and observe that B \u222a C = B \u222a (C \\B). Conversely, observe first that (Ax) is derivable by (Ref) and (Sim) because from B \u21d2 B and A \u21d2 A it follows that B\u222a(A\\B) \u21d2 A that is, A\u222aB \u21d2 A. Moreover, (Cut) is derivable by (Ref) and (Sim) because the following sequence\nC \u21d2 C, \u2205 \u21d2 \u2205, C \u21d2 \u2205, A\u21d2 B,B\u222aC \u21d2 D,A\u222a((B\u222aC)\\B) \u21d2 D,A\u222aC \u21d2 D,\nis a proof of A\u222aC \u21d2 D by {A \u21d2 B,B\u222aC \u21d2 D} in which we have used (Sim) three times and utilized the fact that C \u222a ((A \u222a ((B \u222a C) \\ B)) \\ \u2205) = A\u222aC. Altogether, (Ax) and (Cut) can indeed be replaced by (Ref) and (Sim). Note that (Sim) may be perceived even more natural than (Cut) because it is applicable to any two input formulas. Note that a rule analogous to (Sim) with the inferred formula being A \u222a (C \\ B) \u21d2 B \u222a D was first proposed by Darwen [16, page 140]. Now, we may consider an extension of (Sim) which involves time shifts:\nA\u21d2 B + i, C \u21d2 D\nA \u222a ((C \\B) + i) \u21d2 D + i (Simi). (26)\nAnalogously as in the case of (Cuti), (Sim) is a particular case of (Simi) for i = 0 and (Shf) results by (Simi) and (Ref) for A = B = \u2205. Therefore, the deductive system in Definition 17 can be replaced by (Ref) and (Simi).\nWe now focus on the order in which the deduction rules may be applied in proofs. We show that each proof may be transformed into a normalized proof which involves applications of deduction rules in a special order. First, we show that (Shf) commutes with the other rules. Formally, we introduce the property for a general deduction rule R as follows:\nLet R be a deduction rule of the form \u201cfrom \u03d51, . . . , \u03d5n infer \u03c8\u201d. We say that (Shf) commutes with R if for any formula \u03c7 which results by \u03c8 using (Shf) there are \u03d5\u20321, . . . , \u03d5 \u2032 n which result by \u03d51, . . . , \u03d5n using (Shf), respectively, such that \u03c7 is provable by {\u03d5\u20321, . . . , \u03d5 \u2032 n} using R.\nLemma 25. (Shf) commutes with (Ax), (Cut), and (Shf).\nProof. Clearly, (Shf) commutes with (Ax) because the result of application of (Shf) to an instance of (Ax) is again an instance of (Ax). Moreover, (Shf) commutes with itself since (A + i) + j equals A + (i + j) for any A \u2286 TY and i, j \u2208 Z. Therefore, it remains to check that (Shf) commutes with (Cut). Consider formulas A \u21d2 B and B\u222aC \u21d2 D and the formula A\u222aC \u21d2 D which results by (Cut) and formula (A\u222aC)+i\u21d2 D+i which results by (Shf). Clearly, if we apply (Shf) to A\u21d2 B and B\u222aC \u21d2 D for i, we obtain A+ i\u21d2 B + i and (B\u222aC)+ i\u21d2 D+ i, respectively. The second formula equals (B+ i)\u222a(C + i) \u21d2 D + i and thus we may apply (Cut) to obtain (A+ i) \u222a (C + i) \u21d2 D + i which equals (A\u222aC) + i\u21d2 D + i, proving that (Shf) commutes with (Cut).\nTheorem 26. \u03a3 \u22a2 A\u21d2 B iff there is a finite \u03a3\u2032 \u2286 \u03a3PL such that \u03a3\u2032 \u22a2R A\u21d2 B for R containing (Ax) and (Cut).\nProof. In order to see the only-if part, assume that \u03a3 \u22a2 A \u21d2 B which means there is a proof of A\u21d2 B by \u03a3. The proofs contains only finitely many formulas in \u03a3 and thus, we may consider a finite \u03a3\u2032\u2032 \u2286 \u03a3 such that \u03a3\u2032\u2032 \u22a2 A \u21d2 B. Moreover, the proof contains only finitely many applications of (Shf) and, using Lemma 25, there is a proof of A \u21d2 B by \u03a3\u2032\u2032 which starts by formulas in \u03a3\u2032\u2032, then continues with applications of (Shf), and terminates with formulas derived without using (Shf). Therefore, there is a finite \u03a3\u2032 \u2286 (\u03a3\u2032\u2032)PL \u2286 \u03a3PL such that A\u21d2 B is provable by \u03a3\u2032 using only (Ax) and (Cut). The if-part of the assertion is easy to see.\nThe previous observation allows us to introduce special derivation sequences which represent proofs in a normalized form in that all utilized deduction rules are applied in a particular order. The proofs are constructed using deduction rules (Ref), (Shf), (Acc), and (Pro), see Proposition 19.\nDefinition 27. A finite sequence of formulas \u03d51, . . . , \u03d5n is called a normalized derivation sequence of A\u21d2 B using formulas in \u03a3 if the sequence\n(i) starts with finitely many formulas in \u03a3;\n(ii) continues by formulas obtained using (Shf) applied to formulas in (i);\n(iii) continues by A\u21d2 A;\n(iv) continues by formulas obtained using (Acc) whose first argument is the\npreceding formula and the second argument is a formula in (i) or (ii);\n(v) terminates with A\u21d2 B which results by the preceding formula by (Pro).\nNormalized derivation sequences are sufficient and adequate means for de-\ntermining provability of formulas:\nTheorem 28. \u03a3 \u22a2 A \u21d2 B iff there is a normalized derivation sequence of A\u21d2 B using formulas in \u03a3.\nProof. The if-part follows directly by the fact that a normalized derivation sequence of A \u21d2 B using formulas in \u03a3 is a proof of A \u21d2 B by \u03a3 using (Ref), (Shf), (Acc), and (Pro). Since all of them are rules derivable by (Ax), (Cut), and (Shf), see Proposition 19, we get \u03a3 \u22a2 A\u21d2 B.\nConversely, by Theorem 26 we get that A \u21d2 B is provable by a finite \u03a3\u2032 \u2286 \u03a3PL using only (Ref) and (Cut). Therefore, we may form the (i) and (ii)parts of the derivation sequence using the formulas in \u03a3\u2032 followed by A \u21d2 A. Next, observe that there is a finite sequence A0, . . . , An of subsets of TY such that A0 = A, Ai = Ai\u22121 \u222a F for some E \u21d2 F \u2208 \u03a3\u2032 satisfying E \u2286 Ai\u22121, and An \u2287 B. In order to see that, consider (22) and the fact that A\u21d2 B is provable by \u03a3\u2032 without using (Shf). By moment\u2019s reflection, we can see that the (iv)-part of the derivation sequence is formed of formulas A\u21d2 Ai (i = 0, . . . , n), and the sequence is terminated by a single application of (Pro) to obtain A\u21d2 B.\nWe conclude the section by showing further properties of provability. The\nnext assertion may be viewed as a type of a deduction theorem.\nTheorem 29. Let \u03a3 be a theory and A,B \u2286 TY be finite. Then the following statements are equivalent:\n(i) \u03a3 \u222a {\u2205 \u21d2 A} \u22a2 \u2205 \u21d2 B,\n(ii) there are i1, . . . , in \u2208 Z such that \u03a3 \u22a2 \u22c3n m=1(A+ im) \u21d2 B.\nProof. \u201c(i)\u21d2 (ii)\u201d: Let A1 \u21d2 B1, . . . , An \u21d2 Bn be a proof of \u2205 \u21d2 B by \u03a3 \u222a {\u2205 \u21d2 A}. For each p = 1, . . . , n, we show that there are i1, . . . , ipn \u2208 Z for which \u03a3 \u22a2 Ap \u222a \u22c3pn m=1(A+ im) \u21d2 Bp. The proof goes by induction on p. Thus, take p = 1, . . . , n and assume the claim holds for all q < p. We distinguish the following cases:\n\u2013 Ap \u21d2 Bp is an instance of (Ax). Then, we let pn = 1, i1 = 0, and thus\nAp \u222a \u22c3pn m=1(A+ im) equals Ap \u222aA, i.e., Ap \u222aA\u21d2 Bp follows using (Ax).\n\u2013 Ap \u21d2 Bp \u2208 \u03a3. As in the previous case, for pn = 1 and i1 = 0 using (Wea)\nwe infer Ap \u222a A\u21d2 Bp, showing \u03a3 \u22a2 Ap \u222a A\u21d2 Bp.\n\u2013 Let Ap \u21d2 Bp result by Aq \u21d2 Bq and Ar \u21d2 Br using (Cut). In this\ncase, there is C such that Ar = Bq \u222a C, Bp = Br, and Ap = Aq \u222a C. By induction hypothesis, there are i1, . . . , iqn \u2208 Z and i \u2032 1, . . . , i \u2032 qr \u2208 Z such that \u03a3 \u22a2 Aq\u222a \u22c3qn m=1(A+im) \u21d2 Bq and \u03a3 \u22a2 Bq\u222aC\u222a \u22c3qr m=1(A+i \u2032 m) \u21d2 Br. Therefore, using (Cut), \u03a3 \u22a2 Aq\u222a \u22c3qn m=1(A+im)\u222aC\u222a \u22c3qr m=1(A+i \u2032 m) \u21d2 Bp. Hence, for i\u2032\u20321 = i1, . . . , i \u2032\u2032 qn = iqn , i \u2032\u2032 qn+1 = i\u20321, . . . , i \u2032\u2032 qn+qr = i \u2032 qr it follows that \u03a3 \u22a2 Aq \u222aC \u222a \u22c3qn+qr m=1 (A+ i \u2032\u2032 m) \u21d2 Bp, i.e., \u03a3 \u22a2 Ap \u222a \u22c3qn+qr m=1 (A+ i \u2032\u2032 m) \u21d2 Bp.\n\u2013 Let Ap \u21d2 Bp result by Aq \u21d2 Bq using (Shf). Then, Ap = Aq + i and\nBp = Bq+ i for some i \u2208 Z. By induction hypotheses, there are i1, . . . , iqn such that \u03a3 \u22a2 Aq \u222a \u22c3qn m=1(A + im) \u21d2 Bq. Using (Shf), we get \u03a3 \u22a2 ( Aq \u222a \u22c3qn m=1(A+ im) ) + i\u21d2 Bq+ i. Now, observe that ( Aq \u222a \u22c3qn m=1(A+ im) ) + i equals (Aq+ i)\u222a \u22c3qn m=1(A+ im+ i). Therefore, the claim holds for integers i1 + i, . . . , iqn + i.\nAs a special case for p = n, we get (ii) because An = \u2205.\n\u201c(ii)\u21d2 (i)\u201d: Let \u03a3 \u22a2 \u22c3n\nm=1(A + im) \u21d2 B for some i1, . . . , in \u2208 Z. From\nthe monotony of provability, we get that \u03a3 \u222a {\u2205 \u21d2 A} \u22a2 \u22c3n\nm=1(A + im) \u21d2 B.\nMoreover, for each m = 1, . . . , n we get \u03a3\u222a {\u2205 \u21d2 A} \u22a2 \u2205 \u21d2 A+ im using (Shf). Hence, \u03a3\u222a{\u2205 \u21d2 A} \u22a2 \u2205 \u21d2 \u22c3n\nm=1A+ im by finitely many applications of (Add)\nand (Tra) gives \u03a3 \u222a {\u2205 \u21d2 A} \u22a2 \u2205 \u21d2 B.\nExample 2. Let us observe that a direct counterpart of the classic deduction\ntheorem does not hold in our system. For instance, we may take a theory \u03a3 = {\u2205 \u21d2 {x1}}. Then, using (Shf) for i = 1, we easily see that \u03a3 \u22a2 \u2205 \u21d2 {x2}. On the other hand, we have 0 {x1} \u21d2 {x2} and thus in general \u03a3\u222a {\u2205 \u21d2 A} \u22a2 \u2205 \u21d2 B does not imply that \u03a3 \u22a2 A\u21d2 B which holds in the classic case.\nExample 3. One of the classic laws about provability that apply to attribute implications and can be formulated in terms of attribute implications as formulas with limited expressive power compared to general propositional formulas is the principle of the proof by cases. Formally, if R consists only of (Ax) and (Cut), then the following are equivalent:\n\u2022 \u03a3 \u22a2R A\u21d2 B;\n\u2022 \u03a3 \u222a {C \u21d2 D} \u22a2R A\u21d2 B and \u03a3 \u222a {D \u21d2 C} \u22a2R A\u21d2 B.\nThis follows immediately by the fact that in this case, \u22a2R becomes the classic propositional provability. The law does not apply in our system where R contains the additional rule (Shf). For instance, consider the following theory\n\u03a3 = {{x0} \u21d2 {c1}, {x0} \u21d2 {d2}, {c2} \u21d2 {y0}, {d1} \u21d2 {y0}}.\nObviously, we have \u03a3 \u222a {{c0} \u21d2 {d0}} \u22a2 {x0} \u21d2 {y0} using (Shf) and two applications of (Cut). Analogously, we get \u03a3 \u222a {{d0} \u21d2 {c0}} \u22a2 {x0} \u21d2 {y0}. On the other hand, we can show that \u03a3 0 {x0} \u21d2 {y0}, i.e., the principle of the proof by cases does not hold. In order to see that \u03a3 0 {x0} \u21d2 {y0}, observe that [{x0}]\u03a3 = {y\u22121, x0, c1, y1, d2} for which [{x0}]\u03a3 6|= {x0} \u21d2 {y0}. Thus, since our logic is sound and [{x0}]\u03a3 \u2208 Mod(\u03a3), we indeed have \u03a3 0 {x0} \u21d2 {y0}.\nRemark 5. We may say that \u03a3\u2032 is a completion of \u03a3 if \u03a3 \u2286 \u03a3\u2032 and for any finite C,D \u2286 TY , we have either \u03a3\u2032 \u22a2 C \u21d2 D or \u03a3\u2032 \u22a2 D \u21d2 C. Let us note that analogous notions of completions play an important role in completeness proofs of various logics, cf. [29]. Namely, if a given theory does not prove a formula it is often desirable to find its completion which does not prove the formula as well. As a consequence of Example 3, we observe that this is not possible in our logic. Namely, the example shows a particular case where \u03a3 0 {x0} \u21d2 {y0} and there\nis no completion \u03a3\u2032 such that \u03a3\u2032 0 {x0} \u21d2 {y0}. Indeed, each completion \u03a3\u2032 proves either {c0} \u21d2 {d0} or {d0} \u21d2 {c0} and thus it also proves {x0} \u21d2 {y0}. Nevertheless, we were able to prove Theorem 23 without having this property."}, {"heading": "6 Computational Issues", "text": "In this section, we show bounds on the computational complexity of deciding whether an attribute implication over attributes annotated by time points is provable by a finite set \u03a3 of other attribute implications. Then, we focus on a subproblem which typically appears in applications. For the subproblem we provide a pseudo-polynomial time [27] decision algorithm.\nWe formalize the decision problem of entailment as a language of encodings\nof finitely many formulas, i.e., we put\nLENT = {\u3008\u03a3, A\u21d2 B\u3009 |\u03a3 is a finite theory and \u03a3 \u22a2 A\u21d2 B}, (27)\nconsidering a fixed TY . In order to show the lower bound of the time complexity of LENT, we utilize a reduction of decision problems [45] which involves the unbounded subset sum problem. The decision variant of the unbounded subset sum problem is formulated as follows: An instance of the problem is given by n non-negative integers j1, . . . , jn and a target value z; the answer to the instance is \u201cyes\u201d iff there are non-negative integers c1, . . . , cn such that\n\u2211n i=1 ciji = z. (28)\nThe unbounded subset sum decision problem is NP-complete, see [32, Proposition A.4.1].\nLet us note that in the case of the ordinary attribute implications and functional dependencies, the problem of determining whether a given formula follows by a finite set of formulas is easy and there exist efficient linear time decision algorithms [6]. In contrast, the corresponding decision problem in our setting is hard:\nTheorem 30 (lower bound). LENT is NP-hard.\nProof. We prove the claim by showing that the unbounded subset sum problem (see Section 3) is polynomial time reducible to LENT. Consider an instance of the unbounded subset sum problem given by non-negative integers j1, . . . , jn and z. For the integers we consider\n\u03a3 = { {y0} \u21d2 {yji} | i = 1, . . . , n } (29)\nand put A = {y0}, B = {yz}. We now prove that \u2211n\ni=1 ciji = z holds true\nfor some non-negative integers c1, . . . , cn iff \u03a3 \u22a2 {y0} \u21d2 {yz} by proving both implications.\nIn order to prove the if-part, assume that \u03a3 \u22a2 {y0} \u21d2 {yz}. Using Theorem 28, it follows there is a normalized derivation sequence \u03d51, . . . , \u03d5k of {y0} \u21d2 {yz} using formulas in \u03a3. In the proof, we utilize a part of the sequence which results by applications of (Acc), see Definition 27 (iv). All formulas in this part of the sequence can be written as\n{y0} \u21d2 Ai \ufe38 \ufe37\ufe37 \ufe38\n\u03d5i\n, {y0} \u21d2 Ai+1 \ufe38 \ufe37\ufe37 \ufe38\n\u03d5i+1\n, . . . , {y0} \u21d2 Ak\u22121 \ufe38 \ufe37\ufe37 \ufe38\n\u03d5k\u22121\n,\nwhere Ai, . . . , Ak\u22121 are finite subsets of TY , Ai = {y0}, and yz \u2208 Ak\u22121 because \u03d5k results from \u03d5k\u22121 by (Pro), cf. Definition 27. By induction, we show for every Al (i \u2264 l \u2264 k \u2212 1) that the following property is satisfied:\nIf yw \u2208 Al, then there are non-negative integers c1, . . . , cn such that w = \u2211n\ni=1 ciji.\nNotice the property is satisfied for l = i since in that case we have Al = Ai = {y0} and thus, we may put c1 = c2 = \u00b7 \u00b7 \u00b7 = cn = 0. Assuming the claim holds for l, we prove it for l + 1 as follows. Inspecting Definition 27 (iv), it follows that {y0} \u21d2 Al+1 results from {y0} \u21d2 Al and {y0} + t \u21d2 {yjm} + t using (Acc) where t \u2208 Z and 1 \u2264 m \u2264 n. As a consequence {y0} + t \u2286 Al and thus, by induction hypothesis, there are non-negative integers d1, . . . , dn such that t = 0+ t = \u2211n\ni=1 diji. Then, jm+ t = jm+ \u2211n i=1 diji and so jm+ t = \u2211n i=1 ciji\nfor non-negative integers c1, . . . , cn defined by\nci =\n \n\ndi + 1, if i = m, di, otherwise.\nNow, since we have Al+1 \u2286 Al \u222a {yjm+t}, the property holds for Al+1. As a particular case, for {yz} \u2286 Ak\u22121 we conclude there are non-negative integers c1, . . . , cn for which \u2211n i=1 ciji = z which concludes the first part of the proof of Theorem 30.\nConversely, let \u2211n\ni=1 ciji = z for some non-negative integers c1, . . . , cn. By\ninduction, we show that \u03a3 \u22a2 {y0} \u21d2 {yzk} for every zk = \u2211k i=1 ciji where k = 0, . . . , n. As a particular case for k = n, we obtain the desired fact that \u03a3 \u22a2 {y0} \u21d2 {yz} because zn = z.\nObserve that for k = 0, the claim follows trivially by (Ax). Now, suppose the claim holds for k < n. By induction hypothesis, \u03a3 \u22a2 {y0} \u21d2 {yzk}. Moreover, we have \u03a3 \u22a2 {y0} \u21d2 {yjk+1} because {y0} \u21d2 {yjk+1} \u2208 \u03a3. Using (Shf), we also get \u03a3 \u22a2 {y0} + jk+1 \u21d2 {yjk+1} + jk+1, i.e., using (Cut), it follows that \u03a3 \u22a2 {y0} \u21d2 {y2jk+1}. Repeating the last argument ck+1-times, we obtain \u03a3 \u22a2 {y0} \u21d2 {yck+1jk+1}. Now, using (Shf), we get \u03a3 \u22a2 {y0}+zk \u21d2 {yck+1jk+1}+zk, i.e., \u03a3 \u22a2 {yzk} \u21d2 {yck+1jk+1+zk}. Hence, \u03a3 \u22a2 {y0} \u21d2 {yzk+1} follows by (Cut) using the fact that zk+1 = zk + ck+1jk+1, which finishes the proof.\nThe reduction involved in Theorem 30 is illustrated in the following example.\nExample 4. Let us show a particular instance of the unbounded subset sum problem and its reduction to LENT. We consider integers 5, 7, 11, and a target number 31 as an instance of the problem. The answer to this instance is \u201cyes\u201d because for numbers 4, 0, and 1, the sum 4 \u00b7 5+ 0 \u00b7 7+ 1 \u00b7 11 is equal to 31. The corresponding theory \u03a3, see the proof of Theorem 30, is\n\u03a3 = {{y0} \u21d2 {y5}, {y0} \u21d2 {y7}, {y0} \u21d2 {y11}}.\nIn this case, {y0} \u21d2 {y31} is provable from \u03a3 because we may chain four shifted instances of {y0} \u21d2 {y5} and a single shifted instance of {y0} \u21d2 {y11} by using\n(Cut). It corresponds with the sum 4 \u00b7 5 + 0 \u00b7 7 + 1 \u00b7 11. In a more detail, the corresponding proof of {y0} \u21d2 {y31} by \u03a3 is the following sequence of formulas:\n1. {y0} \u21d2 {y5} formula in \u03a3\n2. {y0}+ 5 \u21d2 {y5}+ 5 using (Shf) on 1.\n3. {y0} \u21d2 {y10} using (Cut) on 1. and 2.\n4. {y0}+ 10 \u21d2 {y5}+ 10 using (Shf) on 1.\n5. {y0} \u21d2 {y15} using (Cut) on 3. and 4.\n6. {y0}+ 15 \u21d2 {y5}+ 15 using (Shf) on 1.\n7. {y0} \u21d2 {y20} using (Cut) on 5. and 6.\n8. {y0} \u21d2 {y11} formula in \u03a3\n9. {y0}+ 20 \u21d2 {y11}+ 20 using (Shf) on 8.\n10. {y0} \u21d2 {y31} using (Cut) on 7. and 9.\nRemark 6. The entailment problem is closely related to the existence of nonnegative solutions of linear Diophantine equations. Indeed, for a theory \u03a3 which consists of formulas of the form {y0} \u21d2 {yji} for i = 1, . . . , n, by inspecting the proof of Theorem 30, we can see that \u03a3 \u22a2 {y0} \u21d2 {yz} iff the linear Diophantine equation j1x1 + \u00b7 \u00b7 \u00b7+ jnxn = z has a non-negative solution.\nOur observations on the upper bound of computational complexity involve additional classes of decision problems. In order to establish an upper bound, we utilize the fact that the satisfiability problem of temporal logic with \u201cuntil\u201d and \u201csince\u201d operators over a linear flow of time is decidable in polynomial space [47]. For the purpose of our proof, we use the linear temporal logic over \u3008Z, <\u3009 with the unary temporal operators (always), \u25e6F (next time), and \u25e6P (previous time) because these operators are definable using operators \u201cuntil\u201d and \u201csince\u201d, see [4] for details.\nFrom now on, we consider Y (the set of attributes) as (a subset of) the set of propositional variables. Recall that formulas of the temporal logic with the above-mentioned operators are defined as follows: Each y \u2208 Y is a formula; if \u03d5\nand \u03c8 are formulas, then \u00ac\u03d5, \u03d5N\u03c8, \u03d5\u21d2 \u03c8, \u03d5, \u25e6F \u03d5, and \u25e6P \u03d5 are formulas. In order to interpret the formulas we consider a standard structureK = \u3008W, e, r\u3009 where W = Z, r is the genuine ordering < on Z, and e is an evaluation such that e(w, y) \u2208 {0, 1} for all w \u2208 Z and y \u2208 Y . Given K and w \u2208 Z, we interpret the formulas as usual: We put\n(i) K, w |= y whenever e(w, y) = 1;\n(ii) K, w |= \u00ac\u03d5 whenever K, w 6|= \u03d5;\n(iii) K, w |= \u03d5N\u03c8 whenever K, w |= \u03d5 and K, w |= \u03c8;\n(iv) K, w |= \u03d5\u21d2 \u03c8 whenever K, w 6|= \u03d5 or K, w |= \u03c8;\n(v) K, w |= \u03d5 whenever K, w\u2032 |= \u03d5 for all w\u2032 \u2208 Z;\n(vi) K, w |= \u25e6F \u03d5 whenever K, w\u2032 |= \u03d5 for w\u2032 \u2208 Z such that w < w\u2032 and there\ndoes not exist z \u2208 Z such that w < z < w\u2032;\n(vii) K, w |= \u25e6P \u03d5 whenever K, w\u2032 |= \u03d5 for w\u2032 \u2208 Z such that w\u2032 < w and there\ndoes not exist z \u2208 Z such that w\u2032 < z < w.\nWe say that \u03d5 is true in K whenever K, w |= \u03d5 for all w \u2208 Z. Moreover, we say that \u03d5 is satisfiable whenever there is a structure K such that K, 0 |= \u03d5. Moreover for each formula of the form (1), we consider its counterpart in the considered temporal logic\n(( \u25b3i1y1 N \u00b7 \u00b7 \u00b7N\u25b3 imym ) \u21d2 ( \u25b3j1z1 N \u00b7 \u00b7 \u00b7N\u25b3 jnzn )) , (30)\nwhere \u25b3i is defined as follows:\n\u25b3iy =\n \n\ny, if i = 0, \u25e6F\u25b3i\u22121y, if i > 0, \u25e6P\u25b3i+1y, if i < 0.\n(31)\nNote that the construction of \u25b3iy from yi requires space which is linear in (the absolute value of) i \u2208 Z, i.e., it is exponential in the length of the encoding of i.\nTheorem 31. LENT is reducible in exponential space to the satisfiability problem of the linear temporal logic over \u3008Z, <\u3009 with unary temporal operators \u201calways\u201d, \u201cnext time\u201d, and \u201cprevious time\u201d.\nProof. First, observe that for each subset of TY we may consider a corresponding structure which makes the same formulas true\u2014any A\u21d2 B is true in the subset of TY iff its counterpart given by (30) is true in the corresponding structure. Namely, for M \u2286 TY , we may consider KM = \u3008W, e, r\u3009, where e(w, y) = 1 if yw \u2208M and e(w, y) = 0 otherwise. Conversely, for K = \u3008W, e, r\u3009, we putMK = {yw | e(w, y) = 1}. Now, for any w \u2208 W , it is easy to see that M |= A \u21d2 B iff KM , w |= \u03d5 where \u03d5 is the counterpart to A\u21d2 B given by (30). From now on, we tacitly identify attribute implications with their counterparts. Furthermore, we have K, w |= A\u21d2 B iff MK |= A\u21d2 B.\nNow, for a given \u03a3 = {A1 \u21d2 B1, . . . , Am \u21d2 Bm} and A \u21d2 B we may\nconsider formula A1 \u21d2 B1 N \u00b7 \u00b7 \u00b7NAm \u21d2 Bm N\u00ac ( A \u21d2 B ) whose construction requires exponential space. From the previous observation, it is obvious that the formula is satisfiable iff \u03a3 6|= A\u21d2 B.\nCorollary 32 (upper bound). LENT belongs to EXPSPACE.\nProof. The decision procedure reduces the input of LENT to the satisfiability problem of linear temporal logic over \u3008Z, <\u3009 with unary temporal operators \u201calways\u201d, \u201cnext time\u201d, and \u201cprevious time\u201d in exponential space, see Theorem 31. Then, the input is reduced to the satisfiability problem of the linear temporal logic over \u3008Z, <\u3009 with binary temporal operators \u201cuntil\u201d and \u201csince\u201d in linear space [4] which we can decide in polynomial space [47]. Altogether, the decision procedure decides LENT in exponential space.\nRemark 7. Note that the results of Theorem 31 and Corollary 32 can also be interpreted so that LENT is decidable in a pseudo-polynomial space because we reduce an instance of LENT to an instance (of the satisfiability problem of the above-mentioned temporal logic) the length of which is bounded from above by the numeric value encoded in the original input. With respect to the new instance, the decision procedure works in polynomial space.\nWe now turn our attention to issues of entailment of formulas which typically appear in applications in prediction. The restriction on particular formulas\nallows us to improve the complexity of the entailment problem. Based on the time points present in antecedents and consequents of attribute implications, we may consider formulas which describe presence of attributes in future time points. That is, based on the presence of attributes in the past, the formulas indicate which attributes are present in future time points. Technically, such formulas can be seen as attribute implications where all the time points in the antecedents are smaller (i.e., denote earlier time points) than all the time points in the consequents which denote later time points. We call such formulas predictive and define the notion as follows.\nDefinition 33. An attribute implication A \u21d2 B over Y annotated by time points in Z is called predictive whenever A 6= \u2205, B 6= \u2205, and for each xi \u2208 A and yj \u2208 B, we have i \u2264 j. A theory \u03a3 is called predictive whenever all its formulas are predictive.\nRemark 8. Note that the deduction rules (Shf) and (Cut) preserve the property of being predictive. That is, if A \u21d2 B is provable by a predictive theory \u03a3 without using (Ax), then A \u21d2 B is predictive. General instances of (Ax) are not predictive formulas.\nIn the next assertion, we utilize lower and upper time bounds of finite non-\nempty subsets of TY : For a finite non-empty M \u2286 TY , put\nl(M) = min{i \u2208 Z | yi \u2208M}, (32)\nu(M) = max{i \u2208 Z | yi \u2208M}. (33)\nThus, l(M) and u(M) are the lowest and greatest time points which appear in M , respectively. Clearly, A \u21d2 B is predictive iff both A and B are nonempty and u(A) \u2264 l(B).\nTheorem 34. Let \u03a3 and A\u21d2 B be predictive. Then, for\n\u03a3BA = {E + i\u21d2 F + i |E \u21d2 F \u2208 \u03a3 and l(A)\u2212 l(E) \u2264 i \u2264 u(B)\u2212 l(F )} (34)\nwe have \u03a3 \u22a2 A\u21d2 B iff \u03a3BA \u22a2R A\u21d2 B for R containing (Ax) and (Cut).\nProof. Observe that the if-part of the claim is trivial. In order to prove the only-if part, assume that \u03a3 \u22a2 A\u21d2 B. That is, B \u2286 [A]\u03a3 owing to Theorem 22 and Theorem 15. Note that \u03a3BA \u22a2R A \u21d2 B for R containing (Ax) and (Cut) means that A\u21d2 B is provable by \u03a3BA as an ordinary attribute implication. Let A\u25e6 denote the least subset of TY with the following properties:\n(i) A \u2286 A\u25e6, and\n(ii) for each E \u21d2 F \u2208 \u03a3BA : if E \u2286 A \u25e6 then F \u2286 A\u25e6.\nSince A\u25e6 is in fact the syntactic closure of A with respect to R, \u03a3BA \u22a2R A\u21d2 B iff B \u2286 A\u25e6. That is, in order to prove the desired claim, it suffices to show that A\u25e6 \u2229 T = [A]\u03a3 \u2229 T for\nT = {yi \u2208 TY | l(A) \u2264 i \u2264 u(B)}.\nTrivially, we get that A\u25e6\u2229T \u2286 [A]\u03a3\u2229T . In order to prove the converse inclusion, according to Theorem 24, it suffices to check that An\u03a3 \u2229 T \u2286 A \u25e6 \u2229 T for each non-negative integer n. By induction, assume that An\u03a3 \u2229 T \u2286 A \u25e6 \u2229 T and take yj \u2208 (An+1\u03a3 \u2229 T ) \\ (A n \u03a3 \u2229 T ) = (A n+1 \u03a3 \\ A n \u03a3) \u2229 T . The fact y j \u2208 An+1\u03a3 \\ A n \u03a3 yields there is E \u21d2 F \u2208 \u03a3 and i \u2208 Z such that E + i \u2286 An\u03a3 and y j \u2208 F + i. It can be shown that E + i \u21d2 F + i \u2208 \u03a3BA . Indeed, since \u03a3 is predictive, observe that l(E) + i = l(E + i) \u2265 l(An\u03a3) = l(A) and thus i \u2265 l(A) \u2212 l(E). Moreover, yj \u2208 F + i yields l(F + i) = l(F ) + i \u2264 j and thus i \u2264 j \u2212 l(F ) which gives i \u2264 u(B) \u2212 l(F ) on account of j \u2264 u(B) since yj \u2208 T . As a consequence, E + i \u21d2 F + i \u2208 \u03a3BA . Furthermore, E + i \u2286 A n \u03a3 and the fact that E \u21d2 F is predictive give E+i = (E+i)\u2229T \u2286 An\u03a3\u2229T . By induction hypothesis, E+i \u2286 A \u25e6 and thus F + i \u2286 A\u25e6 by (ii). Hence, yj \u2208 A\u25e6 and so An+1\u03a3 \u2229 T \u2286 A \u25e6 \u2229 T .\nLet LPRE be the language consisting of encodings of pairs of all finite pre-\ndictive theories and predictive formulas, i.e.,\nLPRE = {\u3008\u03a3, A\u21d2 B\u3009 |\u03a3 is finite and \u03a3 and A\u21d2 B are predictive}. (35)\nBased on Theorem 34, we establish the following observation on the time complexity of deciding whether a predictive formula is provable by a finite predictive\ntheory.\nTheorem 35. LENT \u2229 LPRE is decidable in a pseudo-polynomial time.\nProof. Take a finite predictive \u03a3 and a predictive formula A\u21d2 B. The theory \u03a3BA given by (34) is finite. According to Theorem 34, the problem of deciding \u03a3 \u22a2 A\u21d2 B is reducible to the problem of deciding whether \u03a3BA entails A\u21d2 B without using (Shf), i.e., in the sense of the entailment of ordinary attribute implications. Therefore, the problem is decidable in a time which is polynomial with respect to the size of \u03a3BA [6, 26, 42]. Now, observe that the size of (the encoding of) \u03a3BA may be bounded from above by the size of (the encoding of) \u03a3 multiplied by\nn = max{max(0, u(B) + l(E)\u2212 l(A)\u2212 l(F ) + 1) |E \u21d2 F \u2208 \u03a3}, (36)\ni.e., the size of \u03a3BA is polynomial in the numeric value encoded in the input \u03a3 and hence LENT \u2229 LPRE is decidable in a pseudo-polynomial time.\nRemark 9. (a) By considering only LENT \u2229LPRE, we have improved the upper bound since pseudo-polynomial time algorithms belong to EXPTIME [27] which is believed to be better than EXPSPACE. Observe that LENT \u2229 LPRE is also NP-hard because we can use the same reduction as in Theorem 30.\n(b) Because of the complexity issues, in applications it is reasonable to consider attribute implications annotated by time points with small difference between lower and upper time bounds (maxspan [23]) since LENT \u2229 LPRE is decidable in pseudo-linear time with respect to n given by (36).\nAn explicit procedure for deciding LENT \u2229 LPRE in a pseudo-linear time is described in Algorithm 1. It is a generalization of LinClosure [6], cf. also [42], which incorporates applicable time shifts of formulas in \u03a3. The algorithm accepts three arguments:\n1. a finite predictive theory \u03a3,\n2. a finite A \u2286 TY , and\nAlgorithm 1: PseudoLinClosure (\u03a3, A,Max )\n1 forall the E \u21d2 F \u2208 \u03a3 do 2 for i from l(A)\u2212 l(E) to Max \u2212 l(F ) do 3 set count [E \u21d2 F, i] to |E|; 4 forall the yj \u2208 E do 5 add \u3008E \u21d2 F, i\u3009 to list [yi+j ]; 6 end\n7 end\n8 end 9 set M to A;\n10 set update to A; 11 while update 6= \u2205 do 12 choose yi from update; 13 set update to update \\{yi}; 14 forall the \u3008E \u21d2 F, j\u3009 \u2208 list[yi] do 15 set count [E \u21d2 F, j] to count [E \u21d2 F, j]\u2212 1; 16 if count[E \u21d2 F, j] = 0 then 17 set new to F + j \\M ; 18 set M to M \u222a new ; 19 set update to update \u222anew ;"}, {"heading": "20 end", "text": ""}, {"heading": "21 end", "text": ""}, {"heading": "22 end", "text": "23 return M\n3. a non-negative number Max \u2265 u(A),\nand it returns a subset M \u2286 [A]\u03a3 such that M \u2229 T = [A]\u03a3 \u2229 T for\nT = {yi \u2208 TY | l(A) \u2264 i \u2264 Max}. (37)\nThe soundness of the algorithm is justified by the following observation:\nTheorem 36. Let \u03a3 and A \u21d2 B be predictive and let \u03a3 be finite. Then, Algorithm 1 executed with arguments \u03a3, A, and u(B), terminates after finitely many steps and for the returned value M we have \u03a3 \u22a2 A\u21d2 B iff B \u2286M .\nProof. The arguments are fully analogous to those in case of the classic LinClosure, so we present here comments on issues arising only in the context of attributes annotated by time points. Technical details can be found in [6]. Notice that Algorithm 1 uses auxiliary structure count and list to store information about formulas. The structure count can be seen as an associative array indexed by (pointers to) formulas in \u03a3 and integers i representing time shifts. The value of count [E \u21d2 F, i] is initially set to the number of attributes in the antecedent of E \u21d2 F (shifted by i). During the computation, count [E \u21d2 F, i] represents the number of remaining attributes in E + i which have not been \u201cupdated.\u201d The structure list is an array indexed by attributes annotated by time points and the value of list [yi] is a list of records \u3008E \u21d2 F, j\u3009 representing (pointers to) formulas in \u03a3 and their j-shifts such that yi appears in the antecedent of E \u21d2 F shifted by j. An additional variable update is initialized at line 10 and maintains attributes annotated by time points which are waiting to be \u201cupdated.\u201d An update of yi, see lines 13\u201321, consists in decrementing the counter of occurrences of attributes in shifted antecedents in all formulas where yi appears. All such formulas (and their j-shifts) are found in list [yi], see line 14. If count [E \u21d2 F, j] reaches zero, see line 16, the antecedent of E + j \u21d2 F + j is already contained inM , and all new attributes in F +j are prepared for update. Clearly, the procedure terminates after finitely many steps, and by Theorem 34, the attributes annotated by time points accumulated in M represent a subset\nof [A]\u03a3. In addition, if u(B) \u2264 Max , then B \u2286 M iff B \u2286 [A]\u03a3 iff \u03a3 \u22a2 A \u21d2 B as a consequence of our previous observations.\nRemark 10. The procedure in Algorithm 1 is called PseudoLinClosure because for given parameters, \u03a3, A, and Max , it computes a subset of the closure of [A]\u03a3 in a linear time with respect to the numeric value of the encoding of its input arguments, i.e., its time complexity is pseudo-linear. Indeed, this is a consequence of the fact that each yi where l(A) \u2264 i \u2264 Max is updated during the computation at most once.\nExample 5. Consider a set M given by the table in Figure 4. Since M can be regarded as transactional data over a set of items Y with a dimensional attribute d the domain of which is Z, we can utilize the algorithm proposed in [40]. The parameters for the algorithm are numbers maxspan, minsupport, and minconfidence for which we obtain a set \u03a3 of all predictive A \u21d2 B where u(A \u222a B) \u2212 l(A \u222a B) \u2264 maxspan, minconfidence \u2264 confidence(A \u21d2 B), and minsupport \u2264 support(A \u21d2 B). For this particular example we consider maxspan = 5, minconfidence = 1 since we are interested in formulas true in M , and support = 5. In this setting, we obtain\n\u03a3 = {{wm0} \u21d2 {tc4}, {wl0} \u21d2 {tc3},\n{wl0} \u21d2 {wm1}, {wl0} \u21d2 {wm1, tc3}, {wl0, wm1} \u21d2 {tc3}, {rn0, wl2} \u21d2 {tc3}, {rn0, rn3} \u21d2 {tc3}, {tc0, rn5} \u21d2 {tc5}, {tc0, tc3, rn5} \u21d2 {tc5}, {rn0, tc0, rn3} \u21d2 {tc3}, {rn0, tc0, wm2} \u21d2 {tc3}}.\nNow, we may successively reduce the set \u03a3 by removing formulas A \u21d2 B such that \u03a3 \\ {A \u21d2 B} \u22a2 A \u21d2 B, i.e., without loss of information. Since \u03a3 is\npredictive we may use PseudoLinClosure and obtain the following set:\n\u03a3\u2032 = {{wm0} \u21d2 {tc4}, {wl0} \u21d2 {wm1, tc3},\n{rn0, rn3} \u21d2 {tc3}, {rn0, wm2} \u21d2 {tc3}, {tc0, rn5} \u21d2 {tc5}},\ni.e., the equivalent non-redundant set contains less than half of the formulas in \u03a3. For maxspan = 5 and support = 2, the reduction is much more significant. From the total number of 34, 440 generated formulas, PseudoLinClosure can be used to produce an equivalent set consisting of only 81 formulas."}, {"heading": "7 Conclusion", "text": "We have presented logic for reasoning with if-then rules expressing dependencies between attributes changing in time. The logic extends the classic logic for dealing with if-then rules by considering discrete time points as an additional component. We have studied both the semantic entailment based on preserving validity in models in all time points and syntactic entailment represented by a provability relation. We have shown a characterization of the semantic entailment based on least models and syntactico-semantical completeness of the logic. We have shown the problem of entailment is NP-hard, decidable in exponential space, and its simplified variant which involves only predictive formulas is decidable in pseudo-linear time. Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like \u201cvalidity in all time points with possible exceptions\u201d, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment."}, {"heading": "Acknowledgment", "text": "Supported by grant no. P202/14-11585S of the Czech Science Foundation. J. Triska was also supported by internal student grant IGA PrF 2015 023 of Palacky University Olomouc."}], "references": [{"title": "Mining association rules between sets of items in large databases", "author": ["Rakesh Agrawal", "Tomasz Imieli\u0144ski", "Arun Swami"], "venue": "Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data (New York, NY, USA),", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1993}, {"title": "An approach to discovering temporal association rules", "author": ["Juan M. Ale", "Gustavo H. Rossi"], "venue": "Proceedings of the 2000 ACM Symposium on Applied Computing (New York, NY, USA), SAC \u201900,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2000}, {"title": "Dependency structures of data base relationships, Information Processing", "author": ["William Ward Armstrong"], "venue": "Proceedings of IFIP Congress (Amsterdam)", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1974}, {"title": "The complexity of clausal fragments of LTL", "author": ["Alessandro Artale", "Roman Kontchakov", "Vladislav Ryzhikov", "Michael Zakharyaschev"], "venue": "CoRR abs/1306.5088", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "Characterizing functional dependencies in formal concept analysis with pattern structures", "author": ["Jaume Baixeries", "Mehdi Kaytoue", "Amedeo Napoli"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Computational problems related to the design of normal form relational schemas", "author": ["Catriel Beeri", "Philip A. Bernstein"], "venue": "ACM Trans. Database Syst", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1979}, {"title": "Time granularities in databases, data mining, and temporal", "author": ["Claudio Bettini", "Sushil Jajodia", "Xiaoyang Sean Wang"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2000}, {"title": "Imieli\u0144ski, Temporal deductive databases and infinite objects", "author": ["Jan Chomicki", "Tomasz"], "venue": "Proceedings of the 7th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (New York, NY, USA), PODS \u201988,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1988}, {"title": "A relational model of data for large shared data", "author": ["Edgar F. Codd"], "venue": "banks, Commun. ACM", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1970}, {"title": "Interval-based temporal functional dependencies: specification and verification", "author": ["Carlo Combi", "Pietro Sala"], "venue": "Annals of Mathematics and Artificial Intelligence", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "Nondeterministic ideal operators: An adequate tool for formalization in data bases", "author": ["Pablo Cordero", "\u00c1ngel Mora", "Inmaculada P\u00e9rez de Guzm\u00e1n", "Manuel Enciso"], "venue": "Discrete Applied Mathematics", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "Relational Database Writings 1989\u20131991", "author": ["Chris J. Date", "Hugh Darwen"], "venue": "ch. The Role of Functional Dependence in Query Decomposition,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1992}, {"title": "Time and relational theory: Temporal databases in the relational model and sql", "author": ["Chris J. Date", "Hugh Darwen", "Nikos A. Lorentzos"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2014}, {"title": "Introduction to Lattices and Order", "author": ["Brian A. Davey", "Hilary A. Priestley"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1990}, {"title": "Detection and exploitation of functional dependencies for model generation, Theory and Practice of Logic Programming", "author": ["Broes De Cat", "Maurice Bruynooghe"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2013}, {"title": "Mining frequent conjunctive queries using functional and inclusion dependencies", "author": ["Cheikh Tidiane Dieng", "Tao-Yuan Jen", "Dominique Laurent", "Nicolas Spyratos"], "venue": "VLDB Journal", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2013}, {"title": "Functional dependencies in a relational database and propositional logic, IBM", "author": ["Ronald Fagin"], "venue": "Journal of Research and Development", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1977}, {"title": "Incremental detection of inconsistencies in distributed data", "author": ["Wenfei Fan", "Jianzhong Li", "Nan Tang", "Wenyuan Yu"], "venue": "IEEE Transactions on Knowledge and Data Engineering", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2014}, {"title": "Inter-transactional association rules for multi-dimensional contexts for prediction and their application to studying meterological data, Data", "author": ["Ling Feng", "Tharam Dillon", "James Liu"], "venue": "Knowl. Eng", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2001}, {"title": "A template model for multidimensional inter-transactional association rules", "author": ["Ling Feng", "Jeffrey Xu Yu", "Hongjun Lu", "Jiawei Han"], "venue": "The VLDB Journal", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2002}, {"title": "Reasoning about functional and full hierarchical dependencies over partial relations", "author": ["Flavio Ferrarotti", "Sven Hartmann", "Sebastian Link"], "venue": "Information Sciences", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2013}, {"title": "Formal concept analysis: Mathematical foundations", "author": ["Bernhard Ganter", "Rudolf Wille"], "venue": null, "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1997}, {"title": "Computers and intractability: A guide to the theory of np-completeness", "author": ["Michael R. Garey", "David S. Johnson"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1979}, {"title": "Familles minimales d\u2019implications informatives resultant d\u2019un tableau de donn\u00e9es", "author": ["Jean-Louis Guigues", "Vincent Duquenne"], "venue": "binaires, Math. Sci. Humaines", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1986}, {"title": "Metamathematics of Fuzzy Logic, Kluwer Academic Publishers, Dordrecht", "author": ["Petr H\u00e1jek"], "venue": "The Netherlands,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1998}, {"title": "Efficient mining of salinity and temperature association rules from argo data", "author": ["Yo-Ping Huang", "Li-Jen Kao", "Frode-Eika Sandnes"], "venue": "Expert Syst. Appl", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2008}, {"title": "On functional dependencies in q-horn theories", "author": ["Toshihide Ibaraki", "Alexander Kogan", "Kazuhisa Makino"], "venue": "Artificial Intelligence", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2001}, {"title": "An efficient algorithm for mining closed inter-transaction itemsets", "author": ["Anthony J.T. Lee", "Chun-Sheng Wang", "Wan-Yu Weng", "Yi-An Chen", "Huei-Wen Wu"], "venue": "Data Knowl. Eng", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2008}, {"title": "A triadic approach to formal concept analysis, Conceptual Structures: Applications, Implementation and Theory", "author": ["Fritz Lehmann", "Rudolf Wille"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1995}, {"title": "Effective pruning for the discovery of conditional functional dependencies", "author": ["Jiuyong Li", "Jixue Liu", "Hannu Toivonen", "Jianming Yong"], "venue": "Computer Journal", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2013}, {"title": "Discovering calendarbased temporal association rules, Data and Knowledge Engineering", "author": ["Yingjiu Li", "Peng Ning", "Xiaoyang Sean Wang", "Sushil Jajodia"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2003}, {"title": "First order predicate logic with generalized quantifiers", "author": ["Per Lindstr\u00f6m"], "venue": "Theoria", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 1966}, {"title": "On discovery of functional dependencies from data, Data ", "author": ["Jixue Liu", "Feiyue Ye", "Jiuyong Li", "Junhu Wang"], "venue": "Knowledge Engineering", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2013}, {"title": "Beyond intratransaction association analysis: Mining multidimensional intertransaction association", "author": ["Hongjun Lu", "Ling Feng", "Jiawei Han"], "venue": "rules, ACM Trans. Inf. Syst", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2000}, {"title": "Extending inclusion dependencies with conditions", "author": ["Shuai Ma", "Wenfei Fan", "Loreto Bravo"], "venue": "Theoretical Computer Science", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2014}, {"title": "Theory of Relational Databases, Computer Science Pr", "author": ["David Maier"], "venue": "Rockville, MD,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 1983}, {"title": "On a generalization of quantifiers", "author": ["Andrzej Mostowski"], "venue": "Fundamenta Mathematicae", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 1957}, {"title": "A relation-algebraic approach to the \u201cHoare logic\u201d of functional dependencies", "author": ["Jose N. Oliveira"], "venue": "Journal of Logical and Algebraic Methods in Programming", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2014}, {"title": "Computational Complexity, Addison-Wesley Publishing Co., Inc", "author": ["Christos H. Papadimitriou"], "venue": null, "citeRegEx": "45", "shortCiteRegEx": "45", "year": 1994}, {"title": "Adding temporal semantics to association rules, Principles of Data Mining and Knowledge Discovery", "author": ["Chris P. Rainsford", "John F. Roddick"], "venue": "(Jan M. Z\u0307ytkow and Jan Rauch, eds.), Lecture Notes in Computer Science,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 1999}, {"title": "The complexity of decision problems for linear temporal logics", "author": ["Mark Reynolds"], "venue": "Journal of Studies in Logic", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2010}, {"title": "A machine-oriented logic based on the resolution principle", "author": ["John A. Robinson"], "venue": "J. ACM", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1965}, {"title": "Efficient determination of distance thresholds for differential dependencies", "author": ["Shaoxu Song", "Lei Chen", "Hong Cheng"], "venue": "IEEE Transactions on Knowledge and Data Engineering", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 2014}, {"title": "Functional dependencies on symbol strings generated by extended context free languages, Advances in Databases and Information Systems", "author": ["Gyula I. Szabo", "Andras Benczur"], "venue": "Advances in Intelligent Systems and Computing,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2013}, {"title": "Breaking the barrier of transactions: Mining inter-transaction association rules", "author": ["Anthony K.H. Tung", "Hongjun Lu", "Jiawei Han", "Ling Feng"], "venue": "Proceedings of the Fifth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (New York, NY, USA), KDD \u201999,", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1999}, {"title": "The implication problem for \u2018closest node\u2019 functional dependencies in complete XML documents", "author": ["Millist W. Vincent", "Jixue Liu", "Mukesh K. Mohania"], "venue": "Journal of Computer and System Sciences", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 2012}, {"title": "Exploiting functional dependencies in qualitative probabilistic reasoning, CoRR abs/1304.1081", "author": ["Michael P. Wellman"], "venue": null, "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2013}, {"title": "Mining non-redundant association rules, Data Mining and Knowledge Discovery", "author": ["Mohammed J. Zaki"], "venue": null, "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2004}], "referenceMentions": [{"referenceID": 8, "context": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.", "startOffset": 159, "endOffset": 167}, {"referenceID": 35, "context": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.", "startOffset": 159, "endOffset": 167}, {"referenceID": 21, "context": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.", "startOffset": 193, "endOffset": 201}, {"referenceID": 23, "context": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.", "startOffset": 193, "endOffset": 201}, {"referenceID": 0, "context": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.", "startOffset": 215, "endOffset": 222}, {"referenceID": 47, "context": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.", "startOffset": 215, "endOffset": 222}, {"referenceID": 41, "context": "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.", "startOffset": 242, "endOffset": 250}, {"referenceID": 16, "context": ", transactional data, boolean matrices, or n-ary relations) but as it has been shown in [21], the rules may be seen as propositional formulas with the semantic entailment defined as in the propositional logic, possibly extended by additional measures of interestingness.", "startOffset": 88, "endOffset": 92}, {"referenceID": 5, "context": "The rules are popular because of their easy readability for non-expert users and tractability of the entailment problem which is decidable in linear time [6].", "startOffset": 154, "endOffset": 157}, {"referenceID": 4, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 92, "endOffset": 115}, {"referenceID": 20, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 92, "endOffset": 115}, {"referenceID": 26, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 92, "endOffset": 115}, {"referenceID": 34, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 92, "endOffset": 115}, {"referenceID": 37, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 92, "endOffset": 115}, {"referenceID": 42, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 92, "endOffset": 115}, {"referenceID": 9, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 14, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 15, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 17, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 29, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 32, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 43, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 45, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 46, "context": "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].", "startOffset": 233, "endOffset": 269}, {"referenceID": 28, "context": "Fourth, we include notes on the relationship of the formulas to formulas appearing in modal logics [9] and triadic formal concept analysis [34].", "startOffset": 139, "endOffset": 143}, {"referenceID": 44, "context": "Similar rules as we consider in this paper appeared as inter-transaction association rules [52] inferred from time-changing transactional data.", "startOffset": 91, "endOffset": 95}, {"referenceID": 6, "context": "Formulas called temporal functional dependencies emerged in databases with time granularities [7].", "startOffset": 94, "endOffset": 97}, {"referenceID": 16, "context": "In this setting, temporal functional dependencies are like the ordinary functional dependencies [21] with a time granularity as an additional component.", "startOffset": 96, "endOffset": 100}, {"referenceID": 6, "context": "Thus, [7] uses an ordinary notion of validity of functional dependencies which is restricted to some time segments.", "startOffset": 6, "endOffset": 9}, {"referenceID": 6, "context": "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].", "startOffset": 80, "endOffset": 83}, {"referenceID": 0, "context": "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].", "startOffset": 128, "endOffset": 135}, {"referenceID": 47, "context": "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].", "startOffset": 128, "endOffset": 135}, {"referenceID": 1, "context": "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].", "startOffset": 180, "endOffset": 191}, {"referenceID": 30, "context": "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].", "startOffset": 180, "endOffset": 191}, {"referenceID": 39, "context": "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].", "startOffset": 180, "endOffset": 191}, {"referenceID": 18, "context": "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.", "startOffset": 126, "endOffset": 142}, {"referenceID": 19, "context": "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.", "startOffset": 126, "endOffset": 142}, {"referenceID": 27, "context": "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.", "startOffset": 126, "endOffset": 142}, {"referenceID": 44, "context": "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.", "startOffset": 126, "endOffset": 142}, {"referenceID": 33, "context": "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.", "startOffset": 148, "endOffset": 152}, {"referenceID": 0, "context": "As a consequence, the inter-transaction association rules are related to the rules in our approach in the same way as the ordinary association rules [1] are related to the ordinary attribute implications [26].", "startOffset": 149, "endOffset": 152}, {"referenceID": 21, "context": "As a consequence, the inter-transaction association rules are related to the rules in our approach in the same way as the ordinary association rules [1] are related to the ordinary attribute implications [26].", "startOffset": 204, "endOffset": 208}, {"referenceID": 18, "context": "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.", "startOffset": 15, "endOffset": 35}, {"referenceID": 19, "context": "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.", "startOffset": 15, "endOffset": 35}, {"referenceID": 27, "context": "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.", "startOffset": 15, "endOffset": 35}, {"referenceID": 33, "context": "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.", "startOffset": 15, "endOffset": 35}, {"referenceID": 44, "context": "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.", "startOffset": 15, "endOffset": 35}, {"referenceID": 18, "context": "Our observations may stimulate further development in the field of inter-transaction association rules and similar formulas and their applications in various domains [23, 30].", "startOffset": 166, "endOffset": 174}, {"referenceID": 25, "context": "Our observations may stimulate further development in the field of inter-transaction association rules and similar formulas and their applications in various domains [23, 30].", "startOffset": 166, "endOffset": 174}, {"referenceID": 7, "context": "The formulas studied in this paper are also related to particular program rules which appear in Datalog extensions dealing with flow of time and related phenomena [10, 11, 12] such as DatalognS (Datalog with n successors).", "startOffset": 163, "endOffset": 175}, {"referenceID": 13, "context": "More details can be found in [8, 18].", "startOffset": 29, "endOffset": 36}, {"referenceID": 2, "context": "The provability is based on an extension of the Armstrong axiomatic system [3] which is well known mainly in database systems [42].", "startOffset": 75, "endOffset": 78}, {"referenceID": 35, "context": "The provability is based on an extension of the Armstrong axiomatic system [3] which is well known mainly in database systems [42].", "startOffset": 126, "endOffset": 130}, {"referenceID": 35, "context": "(a) Note that there are several equivalent systems which are called the Armstrong systems [42].", "startOffset": 90, "endOffset": 94}, {"referenceID": 2, "context": "In the classic case, (Ax) and (Cut) form a system which is equivalent to that from [3].", "startOffset": 83, "endOffset": 86}, {"referenceID": 35, "context": "\u201d Also note that in the database literature, (Cut) is also referred to as the rule of pseudo-transitivity [42].", "startOffset": 106, "endOffset": 110}, {"referenceID": 2, "context": "The laws hold because our system is an extension of the Armstrong system in which the laws hold as well, see [3, 42].", "startOffset": 109, "endOffset": 116}, {"referenceID": 35, "context": "The laws hold because our system is an extension of the Armstrong system in which the laws hold as well, see [3, 42].", "startOffset": 109, "endOffset": 116}, {"referenceID": 35, "context": "The proof goes by induction on the length of a proof, considering the facts that each axiom is true in all models, (Cut) is a sound deduction rule [42], and (Shf) is sound on account of Lemma 14.", "startOffset": 147, "endOffset": 151}, {"referenceID": 10, "context": "(c) An alternative deduction system for our logic can be based on (Ref) instead of (Ax) and a single rule which is a modification of a simplification deduction rule [15].", "startOffset": 165, "endOffset": 169}, {"referenceID": 24, "context": "[29].", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "For the subproblem we provide a pseudo-polynomial time [27] decision algorithm.", "startOffset": 55, "endOffset": 59}, {"referenceID": 38, "context": "In order to show the lower bound of the time complexity of LENT, we utilize a reduction of decision problems [45] which involves the unbounded subset sum problem.", "startOffset": 109, "endOffset": 113}, {"referenceID": 5, "context": "Let us note that in the case of the ordinary attribute implications and functional dependencies, the problem of determining whether a given formula follows by a finite set of formulas is easy and there exist efficient linear time decision algorithms [6].", "startOffset": 250, "endOffset": 253}, {"referenceID": 40, "context": "In order to establish an upper bound, we utilize the fact that the satisfiability problem of temporal logic with \u201cuntil\u201d and \u201csince\u201d operators over a linear flow of time is decidable in polynomial space [47].", "startOffset": 203, "endOffset": 207}, {"referenceID": 3, "context": "For the purpose of our proof, we use the linear temporal logic over \u3008Z, <\u3009 with the unary temporal operators (always), \u25e6F (next time), and \u25e6P (previous time) because these operators are definable using operators \u201cuntil\u201d and \u201csince\u201d, see [4] for details.", "startOffset": 237, "endOffset": 240}, {"referenceID": 3, "context": "Then, the input is reduced to the satisfiability problem of the linear temporal logic over \u3008Z, <\u3009 with binary temporal operators \u201cuntil\u201d and \u201csince\u201d in linear space [4] which we can decide in polynomial space [47].", "startOffset": 165, "endOffset": 168}, {"referenceID": 40, "context": "Then, the input is reduced to the satisfiability problem of the linear temporal logic over \u3008Z, <\u3009 with binary temporal operators \u201cuntil\u201d and \u201csince\u201d in linear space [4] which we can decide in polynomial space [47].", "startOffset": 209, "endOffset": 213}, {"referenceID": 5, "context": "Therefore, the problem is decidable in a time which is polynomial with respect to the size of \u03a3 A [6, 26, 42].", "startOffset": 98, "endOffset": 109}, {"referenceID": 21, "context": "Therefore, the problem is decidable in a time which is polynomial with respect to the size of \u03a3 A [6, 26, 42].", "startOffset": 98, "endOffset": 109}, {"referenceID": 35, "context": "Therefore, the problem is decidable in a time which is polynomial with respect to the size of \u03a3 A [6, 26, 42].", "startOffset": 98, "endOffset": 109}, {"referenceID": 22, "context": "(a) By considering only LENT \u2229LPRE, we have improved the upper bound since pseudo-polynomial time algorithms belong to EXPTIME [27] which is believed to be better than EXPSPACE.", "startOffset": 127, "endOffset": 131}, {"referenceID": 18, "context": "(b) Because of the complexity issues, in applications it is reasonable to consider attribute implications annotated by time points with small difference between lower and upper time bounds (maxspan [23]) since LENT \u2229 LPRE is decidable in pseudo-linear time with respect to n given by (36).", "startOffset": 198, "endOffset": 202}, {"referenceID": 5, "context": "It is a generalization of LinClosure [6], cf.", "startOffset": 37, "endOffset": 40}, {"referenceID": 35, "context": "also [42], which incorporates applicable time shifts of formulas in \u03a3.", "startOffset": 5, "endOffset": 9}, {"referenceID": 5, "context": "Technical details can be found in [6].", "startOffset": 34, "endOffset": 37}, {"referenceID": 33, "context": "Since M can be regarded as transactional data over a set of items Y with a dimensional attribute d the domain of which is Z, we can utilize the algorithm proposed in [40].", "startOffset": 166, "endOffset": 170}, {"referenceID": 31, "context": "Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like \u201cvalidity in all time points with possible exceptions\u201d, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment.", "startOffset": 98, "endOffset": 106}, {"referenceID": 36, "context": "Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like \u201cvalidity in all time points with possible exceptions\u201d, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment.", "startOffset": 98, "endOffset": 106}, {"referenceID": 12, "context": "Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like \u201cvalidity in all time points with possible exceptions\u201d, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment.", "startOffset": 247, "endOffset": 251}], "year": 2015, "abstractText": "We study logic for reasoning with if-then formulas describing dependencies between attributes of objects which are observed in consecutive points in time. We introduce semantic entailment of the formulas, show its fixed-point characterization, investigate closure properties of model classes, present an axiomatization and prove its completeness, and investigate alternative axiomatizations and normalized proofs. We investigate decidability and complexity issues of the logic and prove that the entailment problem is NP-hard and belongs to EXPSPACE. We show that by restricting to predictive formulas, the entailment problem is decidable in pseudo-linear time.", "creator": "LaTeX with hyperref package"}}}