{"id": "1503.01707", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Mar-2015", "title": "Mapping-equivalence and oid-equivalence of single-function object-creating conjunctive queries", "abstract": "space conjunctive database class queries have been extended nationally with a mechanism enabled for object creation to securely capture important applications such ideas as data frame exchange, data protection integration, and ontology - based data access. object creation globally generates new object knowledge identifiers even in the desired result, even that does do likewise not belong locally to just the correct set of constants contained in solving the source result database. the underlying new object identifiers etc can effectively be also seen as modified skolem terms. hence, those object - creating global conjunctive queries can now also be regarded as totally restricted second - closest order tuple - invariant generating fuzzy dependencies ( so tgds ), however considered problematic in the data integrity exchange literature.", "histories": [["v1", "Thu, 5 Mar 2015 17:47:04 GMT  (27kb)", "https://arxiv.org/abs/1503.01707v1", null], ["v2", "Tue, 12 Jan 2016 14:59:40 GMT  (31kb)", "http://arxiv.org/abs/1503.01707v2", "This revised version has been accepted on 11 January 2016 for publication in The VLDB Journal"]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["angela bonifati", "werner nutt", "riccardo torlone", "jan van den bussche"], "accepted": false, "id": "1503.01707"}, "pdf": {"name": "1503.01707.pdf", "metadata": {"source": "CRF", "title": "Mapping-equivalence and oid-equivalence of single-function object-creating conjunctive queries", "authors": ["Angela Bonifati", "Werner Nutt", "Riccardo Torlone", "Jan Van den Bussche"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n50 3.\n01 70\n7v 2\n[ cs\n.D B\n] 1\nIn this paper, we focus on the class of single-function object-creating conjunctive queries, or sifo CQs for short. The single function symbol can be used only once in the head of the query. We give a new characterization for oid-equivalence of sifo CQs that is simpler than the one given by Hull and Yoshikawa and places the problem in the complexity class NP. Our characterization is based on Cohen\u2019s equivalence notions for conjunctive queries with multiplicities. We also solve the logical entailment problem for sifo CQs, showing that also this problem belongs to NP. Results by Pichler et al. have shown that logical equivalence for more general classes of SO tgds is either undecidable or decidable with as yet unknown complexity upper bounds."}, {"heading": "1 Introduction", "text": "Conjunctive queries form a natural class of database queries, which can be defined by combinations of selection, renaming, natural join, and projection. Much of the research on database query processing is focused on conjunctive queries; moreover, these queries are amenable to advanced optimizations because containment of conjunctive queries is decidable (though NP-complete). In this paper, we are interested in conjunctive queries extended with a facility for object creation.\nObject creation, also called oid generation or value invention, has been repeatedly proposed and investigated as a feature of query languages. This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation\n[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18]. In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].\nIn the present paper, we consider conjunctive queries (CQs) extended with object creation through the use of a single Skolem function, which can be used only once in the head of the query. We refer to such a query as a \u2018sifo CQ\u2019 (for single-function object-creating). The following example of a sifo CQ uses a Skolem function f :\nQ : Family(c, f(x, y)) \u2190 Mother (c, x),Father (c, y).\nThe query introduces a new oid f(x, y) for every pair (x, y) of a woman x and a man y who have at least one child together; all children c of x and y are linked to the new oid in the result of the query (a relation called Family). As an example, if Mother(beth, anne) and Father(beth, adam) are two facts in the underlying database, then the result of the query includes the fact Family(beth, f (anne, adam)), where f (anne, adam) is the newly created oid. This oid will be shared by all the children having anne and adam as parents.\nIn this paper, we first revisit the problem of checking oid-equivalence of sifo CQs. Oid-equivalence has its origins in the theory of object-creating queries introduced by Abiteboul and Kanellakis [3]; it is the natural generalization of query equivalence in the presence of object creation.\nConsider for instance the following sifo CQ:\nQ\u2032 : Family(c, g(x, y, x)) \u2190 Mother (c, x),Father (c, y).\nIt is not hard to see that the result of Q\u2032 has the same structure as the result of the query Q above. The query Q\u2032 links all children c of the parents x and y to the oid g(x, y, x) that depends exactly on x and y. That is, two children in the result of Q are connected to the same oid if and only if they are connected to same oid in Q\u2032, although the oids will be syntactically different. Therefore, we can conclude that Q and Q\u2032 are oid-equivalent, which means that their results are identical on any input up to a simple isomorphism mapping the oids in one result to those in the other.\nHull and Yoshikawa [23] studied oid-equivalence (they called it \u2018obscured equivalence\u2019) for nonrecursive ILOG programs; the decidability of this problem is a long-standing open question. Nevertheless, for the case of \u2018isolated oid creation\u2019, to which sifo CQs belong, they have given a decidable characterization.\nWe give a new result relating oid-equivalence to equivalence of classical conjunctive queries under \u2018combined\u2019 bag-set semantics [14], which models the evaluation of CQs when query results and relations may contain duplicates of tuples. As a corollary, we obtain that oid-equivalence for sifo CQs belongs to NP, which does not follow from the Hull-Yoshikawa test. Obviously, then, oid-equivalence for sifo CQs is NP-complete, since equivalence of classical CQs without object creation is already NP-complete.\nObject creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a\nsource schema are to be transformed into data structured under a target schema. Hence, it is instructive to view sifo CQs as schema mappings, simply by interpreting them as implicational statements. As an example, we may view query Q above as an implicational statement that relates a query over relations Mother and Father in the source schema to the relation Family in the target schema.\nFor standard CQs without object creation, two queries are equivalent if and only if they are logically equivalent as schema mappings [17]. For sifo CQs, we show that oid-equivalence implies logical equivalence, while the converse is not true.\nSifo CQs viewed as schema mappings belong to the class of so-called \u2018nested dependencies\u2019 [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]). For instance, consider again the sifo CQ Q above: it can be rewritten into the following SO-tgd:\n\u2203f\u2200x\u2200y\u2200c(Mother (c, x) \u2227 Father(c, y) \u2192 Family(c, f(x, y))),\nwhich is of second order because the function f is existentially quantified. Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26]. We give a novel and elegant characterization of logical implication for sifo CQs which is simpler than the general implication test for nested dependencies. It turns out that the problem belongs to NP. Hence, logical implication for sifo CQs has no worse complexity than containment for standard CQs without object creation.\nSummarizing, in this paper we provide the following contributions in the area of query languages with object creation:\n1. We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].\n2. We relate the problem of oid-equivalence for sifo CQs to the equivalence of classical conjunctive queries under combined bag-set semantics, which implies its NP-completeness.\n3. We show that when sifo CQs are interpreted as schema mappings, oidequivalence implies logical equivalence but not vice versa.\n4. We provide a new characterization of logical implication for sifo CQs as object-creating queries showing that this problem has the same complexity as deciding containment for classical CQs.\nThis paper is organized as follows. In Section 2 we review some practical applications of sifo CQs. In Section 3 we formally define object-creating conjunctive queries. Section 4 is devoted to the results on oid equivalence. Section 5 is devoted to the results on logical entailment. In Section 6 we conclude by discussing related work and topics for further research."}, {"heading": "2 Applications of sifo CQs", "text": "In this section, we discuss further applications of sifo CQs, which may constitute important components of many advanced database systems, spanning from information integration and schema mapping engines along with their benchmarks, to several Semantic Web tools. We believe this shows that the results in this article on equivalence and logical implication of sifo CQs are relevant and contribute to our understanding of how solutions for these applications can be optimized.\nGAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ. More precisely, a GAV mapping can be written as follows:\nT (x\u0304) \u2190 B\nwhere we use a relation symbol T as the atomic head predicate. GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources. In both systems, source facts are related to facts over the global schema by means of queries.\nSifo CQs can naturally be seen as extensions of GAV mappings, when one of the attributes of the global schema carries newly created identifiers. For instance, the sifo CQ Q from Section 1 can express a mapping from a source schema containing two relations Mother and Father to one relation Family of a global schema, with created identifiers for families appearing in the tuples in the result of the mapping. Thus, we can also interpret Q as an extended GAV schema mapping.\nAnother important application of sifo CQs are schema mapping benchmarks allowing the users to compare and evaluate schema mapping systems. In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].\nMore precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.\nThese skolemization strategies can be captured by sifo CQs as follows. In the query below:\nT (x, y, f(x, y, z, w)) \u2190 B(x, y, z, w)\nwe can observe that the Skolem term uses all the source variables in the body B (option All). If the attribute in the position of x is a primary key for B, then\nthe application of the option Key generates a mapping that can be expressed by the sifo CQ\nT (x, y, f(x)) \u2190 B(x, y, z, w).\nAlternatively, choosing the option Random may lead the iBench to randomly select the attributes in the positions of x and z, and then to generate the mapping represented by\nT (x, y, f(x, z)) \u2190 B(x, y, z, w).\nIt is also worth highlighting that three out of the seven mapping primitives in iBench that are novel with respect to STBenchmark, namely ADD (copy a relation and ADD new attributes), ADL (copy a relation, Add and DeLete attributes in tandem) and MA (Merge and Add new attributes) contain single Skolem functions. They correspond to the following sifo CQs, respectively:\nT (x, y, f(x, y)) \u2190 B(x, y)\nT (x, f(x)) \u2190 B(x, y)\nT (x, y, z, f(x, y, z)) \u2190 B(x, y), T (y, z).\nA third significant application of sifo CQs is the Semantic Web, where sifo CQs can be envisioned in at least two scenarios, namely in systems for ontologybased data access (OBDA) and in direct mappings from the relational to the RDF data format, under development at W3C.1 Indeed, newly created identifiers in the head of a sifo CQ can serve as generated keys, or simply as newly invented values needed to fill an attribute of a relation in the global schema. As such, sifo CQs can be seen as examples of mapping assertions from source schemas to a global ontology in OBDA [31]. Typically, OBDA mapping assertions relate facts in relational source schemas to RDF triples in a global ontology. The newly generated IRIs2 in the RDF triples can be interpreted as skolemized values in the global ontology.\nA related application is the direct translation of a relational schema into OWL, which uses as an important building block the creation of IRIs [32]. In contrast to the previous application, this application handles relational schemas that are not known in advance. For each relation r in a database schema, Datalog-like rules can be used to generate an IRI for the relation r and an IRI for each attribute a in r. We take an example of a translation from a relational schema into OWL and we show that, actually, these Datalog-like rules can be viewed as sifo CQs, since they employ a single concatenation function to obtain such IRIs (exemplified as f). The corresponding sifo CQs are reported below:\nT1(r, f(b, r)) \u2190 B1(r)\nT2(a, r, f(b, r, a)) \u2190 B2(r, a),\n1http://www.w3.org/TR/rdb-direct-mapping/ 2IRIs stand for Internationalized Resource Identifiers and extend the syntax of URIs (Uniform Resource Identifiers) to a much wider repertoire of characters. They naturally embody global identifiers that refer to the same resource on the Web and can be used across different mapping assertions to refer to that resource.\nwhere B1 and B2 are conjunctive query bodies retrieving relation names r and attribute names a from the data dictionary of an underlying relational database, and where b is a string representing a given IRI base (e.g., the string \u2018http://example.edu/db\u2019) for the same database to be translated. Thus, the first query creates a new IRI for the relation r, by concatenating b with the relation symbol r, while the second query returns the set of IRIs of the attributes a of r, by concatenating b with the relation symbol r and its attribute symbols a."}, {"heading": "3 Preliminaries", "text": "In this section we introduce our formalism for dealing with conjunctive queries and introduce the notion of object-creating conjunctive query, adapted from the language ILOG [22]."}, {"heading": "3.1 Databases and conjunctive queries", "text": "From the outset we assume a supply of relation names, where each relation name R has an associated arity ar(R). We also assume an infinite domain dom of atomic data elements called constants. A fact is of the form R(a1, . . . , ak) where a1, . . . , ak are constants and R is a k-ary relation name. We call R the predicate of the fact.\nA database schema S is a finite set of relation names. An instance of S is a finite set of facts with predicates from S. The set of all constants appearing in an instance I is called the active domain of I and denoted by adom(I).\nWe further assume an infinite supply of variables, disjoint from dom. An atom is of the form R(x1, . . . , xk) where x1, . . . , xk are variables and R is a k-ary relation name. As with facts, we call R the predicate of the atom.\nWe can now recall the classical notion of conjunctive query (CQ) [2, 13]. Syntactically, a CQ over a database schema S is of the form\nH \u2190 B,\nwhere B is a finite set of atoms with predicates from S, and H is an atom with a predicate not in S. The set B is called the body and H is called the head. It is required that every variable occurring in the head also occurs in the body. We denote the set of variables occurring in a set of atoms B (or a single atom A) by var(B) (or var(A)).\nThe semantics of CQs is defined in terms of valuations. A valuation is a mapping \u03b1 : X \u2192 dom on some finite set of variables X . When A is an atom with var(A) \u2286 X , we can apply \u03b1 to A simply by applying \u03b1 to every variable in A. This results in a fact and is denoted by \u03b1(A). When B is a set of atoms and \u03b1 is a valuation on var(B), we can apply \u03b1 to B by applying \u03b1 to every atom in B. Formally, \u03b1(B) is defined as the instance {\u03b1(A) | A \u2208 B}.\nWhen I is an instance and \u03b1 is a valuation on var(B) such that \u03b1(B) \u2286 I, we say that \u03b1 is a matching of B in I, and denote this by \u03b1 : B \u2192 I. Now when\nQ is a CQ H \u2190 B and I is an instance, the result of Q on I is defined as\nQ(I) := {\u03b1(H) | \u03b1 : B \u2192 I}."}, {"heading": "3.2 Object-creating conjunctive queries", "text": "Assume a finite vocabulary of function symbols of various arities. As with relation names, the arity of a function symbol f is denoted by ar(f).\nData terms are syntactical expressions built up from constants using function symbols. Formally, data terms are inductively defined as follows:\n1. Every constant is a data term;\n2. If f is a k-ary function symbol and d1, . . . , dk are data terms, then the expression f(d1, . . . , dk) is also a data term. 3\nAn extended fact is defined just like a fact, except that it may contain data terms rather than only constants. Formally, an extended fact is of the form R(d1, . . . , dk), where d1, . . . , dk are data terms and R is a k-ary relation name. The active domain of an extended fact e = R(d1, . . . , dk) is defined as\nadom(e) := {d1, . . . , dk}.\nAn extended instance is a finite set of extended facts. The active domain of an extended instance J is defined as\nadom(J) := \u22c3\ne\u2208J\nadom(e).\nFormula terms are defined in the same way as data terms, but are built up from variables rather than constants. Extended atoms are defined like atoms, but can contain formula terms in addition to variables. If t is a formula term and \u03b1 is a valuation defined on all variables occurring in t, we can apply \u03b1 to every variable occurrence in t, obtaining a data term \u03b1(t). Likewise, we can apply a valuation to an extended atom, resulting in an extended fact.\nWe are now ready to define the syntax and semantics of object-creating conjunctive queries (oCQ). Like a classical CQ, an oCQ is of the form H \u2190 B. The only difference with a classical CQ is that H can be an extended atom; in particular, B is still a finite set of \u201cflat\u201d atoms, not extended atoms. It is still required that var(H) \u2286 var(B). The result of an oCQ Q = H \u2190 B on an instance I is now an extended instance, defined as\nQ(I) := {\u03b1(H) | \u03b1 : B \u2192 I}.\n3Since constants are atomic data elements, no constant is allowed to be of the form f(d1, . . . , dk).\nExample 3.1. Recall the oCQ Q from the Introduction:\nFamily(c, f(x, y)) \u2190 Mother (c, x),Father (c, y).\nIf I is the instance consisting of the Mother and Father facts listed in Table 1, then Q(I) is the extended instance consisting of the extended Family facts listed in the same table.\nExample 3.2. For a more abstract example, consider the following oCQ Q:\nT (x, f(y)) \u2190 R(x, y, z).\nIf I is the instance consisting of the R-facts listed in Table 2, then Q(I) consists of the extended T -facts listed in the same table."}, {"heading": "3.3 The single-function case", "text": "In this paper, we focus on single-function oCQs (sifo CQs), that have exactly one occurrence of a function symbol in the head. Without loss of generality we always place the function term in the last position of the head.\nDefinition 3.3. A sifo CQ over a database schema S is an oCQ over S of the form\nT (x\u0304, f(z\u0304)) \u2190 B,\nwhere\n\u2022 T is the head predicate;\n\u2022 f is a function symbol;\n\u2022 B is the body;\n\u2022 x\u0304 is a tuple of (not necessarily distinct) variables from var(B), called the distinguished variables ;\n\u2022 z\u0304 is a tuple of (not necessarily distinct) variables from var(B), called the creation variables ; some creation variables may be distinguished;\n\u2022 The elements of var(B) that are not distinguished are called the nondistinguished variables.\nExample 3.4. The queries in Examples 3.1 and 3.2 are both examples of sifo CQs."}, {"heading": "3.4 Comparison with ILOG", "text": "Object-creating CQs can be considered to be the conjunctive-query fragment of nonrecursive ILOG [22]; our syntax exposes the Skolem functions, which are normally obscured in the standard ILOG syntax, and our semantics corresponds to what is called the \u2018exposed semantics\u2019 by Hull and Yoshikawa. Nevertheless, in the following section, we will consider oid-equivalence of sifo CQs, which does correspond to what has been called \u2018obscured equivalence\u2019 [23]."}, {"heading": "4 Characterization of oid-equivalence for sifo CQs", "text": ""}, {"heading": "4.1 Oid-equivalence of oCQs", "text": "The result Q(I) of an oCQ Q applied to an instance I is an extended instance. The data terms in adom(Q(I)) that are not constants play the role of created oids (also called invented values). Intuitively it is clear that the actual form of the created oids does not matter.\nExample 4.1. Recall the query Q from Example 3.1:\nFamily(c, f(x, y)) \u2190 Mother (c, x),Father (c, y).\nAs mentioned in the Introduction, we could have used equivalently the following query Q\u2032:\nFamily(c, g(x, y, x)) \u2190 Mother (c, x),Father (c, y).\nApplying the above query to the Mother and Father facts from Table 1 results in the instance shown in Table 3. Intuitively, this instance has exactly the same\nrelevant properties as the Family-instance from Table 1: beth and ben are linked to the same family-oid; eric is linked to another oid; and emma to still another one.\nWe formalize this intuition in the following definitions.\nDefinition 4.2. Let J be an extended instance.\n\u2022 The set adom(J)\u2212 dom is denoted by oids(J);\n\u2022 The set adom(J) \u2229 dom is denoted by consts(J).\nDefinition 4.3. Let J be an extended instance and let \u03c1 be a mapping from adom(J) to the set of data terms. For any extended fact e = R(d1, . . . , dk) in J , we define \u03c1(e) to be the extended fact R(\u03c1(d1), . . . , \u03c1(dk)). We then define \u03c1(J) := {\u03c1(e) | e \u2208 J}.\nDefinition 4.4. Let J1 and J2 be extended instances. Then J1 and J2 are called oid-isomorphic if there exists a bijection \u03c1 : adom(J1) \u2192 adom(J2) such that\n\u2022 \u03c1 is the identity on consts(J1);\n\u2022 \u03c1 maps oids(J1) to oids(J2);\n\u2022 \u03c1(J1) = J2.\nSuch a bijection \u03c1 is called an oid-isomorphism from J1 to J2.\nThe above definition implies that oid-isomorphic instances have the same constants. Formally, if J1 and J2 are oid-isomorphic then consts(J1) = consts(J2).\nDefinition 4.5. Let Q and Q\u2032 be two oCQs with the same head predicate, and over the same database schema S. Then Q and Q\u2032 are called oid-equivalent if for every instance I over S, the results Q(I) and Q\u2032(I) are oid-isomorphic.\nExample 4.6. The queries in Example 4.1 are oid-equivalent. For example, for the instance I of Table 1, the oid-isomorphism from Q(I) to Q\u2032(I) is as follows:\nf(anne, adam) 7\u2192 g(anne, adam, anne) f(claire, carl) 7\u2192 g(claire, carl, claire) f(diane, carl) 7\u2192 g(diane, carl, diane).\nExample 4.7. Recall the query Q from Example 3.2:\nT (x, f(y)) \u2190 R(x, y, z)\nAlso consider the following variation Q\u2032 of Q:\nT (x, f(x, y)) \u2190 R(x, y, z)\nThen Q and Q\u2032 are not oid-equivalent, as shown by the simple instances in Table 4. Indeed, there cannot be an oid-isomorphism fromQ(I) toQ\u2032(I) because Q(I) contains only one distinct oid while Q\u2032(I) contains two distinct oids.\nExample 4.8. As a variant of Example 4.7, consider the following two oCQs:\nQ = T (x, f(x)) \u2190 R(x, y, z)\nQ\u2032 = T (x, f(x, y, z)) \u2190 R(x, y, z)\nAgain these two oCQs are not oid-equivalent, as shown by the counterexample instances in Table 5."}, {"heading": "4.2 Homomorphisms and containment of conjunctive queries", "text": "The characterizations we will give for oid-equivalence of sifo CQs depend on the classical notions of homomorphism and containment between conjunctive queries. Let us briefly recall these notions now [13, 2].\nA variable mapping is a mapping h from a finite set X of variables to another finite set Y of variables. If A is an atom with variables in X , then we can apply h to each variable occurrence in A to obtain an atom with variables in Y , which we denote by h(A). If B is a set of atoms with var(B) \u2286 X , then we naturally define h(B) := {h(A) | A \u2208 B}.\nFor two sets B and B\u2032 of atoms, a variable mapping h : var(B) \u2192 var(B\u2032) is called a homomorphism from B to B\u2032 if h(B) \u2286 B\u2032. This is denoted by h : B \u2192 B\u2032. The notion of homomorphism is extended to conjunctive queries Q = H \u2190 B and Q\u2032 = H \u2032 \u2190 B\u2032 as follows. A homomorphism from Q to Q\u2032 is a homomorphism h : B \u2192 B\u2032 such that h(H) = H \u2032. This is denoted by h : Q \u2192 Q\u2032.\nA classical result relates homomorphisms between conjunctive queries to containment. Let Q and Q\u2032 be two conjunctive queries over a common database schema S. We say that Q\u2032 is contained in Q if for every instance I of S, we\nhave Q\u2032(I) \u2286 Q(I). The classical result states that Q\u2032 is contained in Q if and only if there exists a homomorphism h : Q \u2192 Q\u2032.\nTwo queries Q and Q\u2032 are equivalent if for every instance I of S, we have Q(I) = Q\u2032(I). Since equivalence amounts to containment in both directions, two conjunctive queries are equivalent if and only if there exist homomorphisms between them in both directions."}, {"heading": "4.3 A normal form for oid-equivalence problems", "text": "In this subsection we consider two arbitrary sifo CQs Q, Q\u2032 with the same head predicate:\nQ = T (x\u0304, f(z\u0304)) \u2190 B\nQ\u2032 = T (x\u0304\u2032, f \u2032(z\u0304\u2032)) \u2190 B\u2032.\nThen x\u0304 and x\u0304\u2032 have equal length. Note that x\u0304 and z\u0304 as well as x\u0304\u2032 and z\u0304\u2032 may have variables in common.\nOur aim is to show that oid-equivalence between arbitrary sifo CQs Q and Q\u2032 can be reduced to the case where the heads"}, {"heading": "T (x\u0304, f(z\u0304)) and T (x\u0304\u2032, f \u2032(z\u0304\u2032))", "text": "have identical arguments, that is, where x\u0304 = x\u0304\u2032 and z\u0304 = z\u0304\u2032. As a first lemma we state that rearranging the creation variables of a query does not affect oid-equivalence.\nLemma 4.9 (Rearranging creation variables). Let Q be a sifo CQ written as above. Let u\u0304 be a tuple with exactly the same variables as z\u0304, but possibly with different repetitions and a different ordering, and let g be a function symbol whose arity is equal to the length of u\u0304. Then the sifo CQ P = T (x\u0304, g(u\u0304)) \u2190 B is oid-equivalent to Q.\nProof. Let I be an instance. We define an oid isomorphism from Q(I) to P (I) as follows. Any oid o in Q(I) is of the form f(\u03b1(z\u0304)) for some matching \u03b1 : B \u2192 I; we define \u03c1(o) := g(\u03b1(u\u0304)). This is well-defined, i.e., independent of the choice of \u03b1. Indeed, if the data terms f(\u03b11(z\u0304)) and f(\u03b12(z\u0304)) are equal, then the tuples \u03b11(z\u0304) and \u03b12(z\u0304) are equal, which implies that \u03b11 and \u03b12 agree on every variable appearing in z\u0304. Since exactly the same variables appear in u\u0304, also the tuples \u03b11(u\u0304) and \u03b12(u\u0304) are equal, whence g(\u03b11(u\u0304)) = g(\u03b12(u\u0304)).\nThat \u03c1 : oids(Q(I)) \u2192 oids(P (I)) is injective is shown by an analogous argument. The surjectivity of \u03c1, as well as the equality \u03c1(Q(I)) = P (I), are clear.\nBy the above lemma, we can remove all duplicates from z\u0304 and z\u0304\u2032 in the heads of Q and Q\u2032, respectively. So, from now on we may assume z\u0304 and z\u0304\u2032 have no duplicates.\nIn the following, let Z equal the set of variables occurring in z\u0304, let X equal the set of variables occurring in x\u0304, and let Z \u2032 and X \u2032 be defined similarly.\nWe next show that two sifo CQs can only be oid-equivalent if they have identical patterns of distinguished variables, up to renaming.\nLemma 4.10 (Renaming distinguished variables). If Q and Q\u2032 are oid-equivalent, then there exists a bijective variable mapping \u03c3 : X \u2192 X \u2032 such that \u03c3(x\u0304) = x\u0304\u2032.\nProof. Certainly, if Q and Q\u2032 are oid-equivalent, then the conjunctive queries Q0 = T0(x\u0304) \u2190 B and Q \u2032 0 = T0(x\u0304\n\u2032) \u2190 B\u2032, where T0 is a new predicate symbol, are equivalent. So, there are homomorphisms h : Q0 \u2192 Q \u2032 0 and h\n\u2032 : Q\u20320 \u2192 Q0. In particular, h(x\u0304) = x\u0304\u2032 and h\u2032(x\u0304\u2032) = x\u0304. We define \u03c3 to be the restriction of h to X . The claim \u03c3(x\u0304) = x\u0304\u2032 and the surjectivity of \u03c3 are then clear. So it remains to show that \u03c3 is injective. Thereto, consider h\u2032(\u03c3(x\u0304)) = h\u2032(h(x\u0304)) = h\u2032(x\u0304\u2032) = x\u0304. We see that h\u2032 \u25e6 \u03c3 is the identity on X and thus injective. Hence, \u03c3 must be injective as well.\nBy the above lemma, if there does not exist a renaming \u03c3 as in the lemma, certainly Q and Q\u2032 are not oid-equivalent. If there exists such a renaming, then by renaming the variables in one of the two queries, we can now assume without loss of generality that x\u0304 = x\u0304\u2032 and in particular that X = X \u2032.\nThe next step is to show that oid-equivalent queries must have the same distinguished variables among the creation variables, that is, X \u2229 Z = X \u2229 Z \u2032.\nLemma 4.11 (Distinguished creation variables). If X \u2229 Z 6= X \u2229 Z \u2032, then Q and Q\u2032 are not oid-equivalent.\nProof. Either there exists some x \u2208 X \u2229 Z but not in Z \u2032 or vice versa. By symmetry we may assume the first possibility.\nWe construct an instance I from B\u2032. In doing this, to keep our notation simple, we consider the variables in B\u2032 to be constants. The instance I is obtained from B\u2032 by duplicating x to some new element x2. Formally, consider the mapping d on var(B\u2032) that is the identity everywhere except that x is mapped to x2; then I = B\n\u2032 \u222a d(B\u2032). First, let us look at Q\u2032(I). Using the identity matching that maps every variable to itself, we obtain the extended fact T (x\u0304, f \u2032(z\u0304\u2032)) \u2208 Q\u2032(I). Using the matching d defined above, we obtain the extended fact T (x\u03042, f\n\u2032(d(z\u0304\u2032))) in Q\u2032(I). Here, x\u03042 denotes d(x\u0304), i.e., x\u03042 is obtained from x\u0304 by replacing x with x2. Since x does not belong to Z \u2032, we have d(z\u0304\u2032) = z\u0304\u2032, so T (x\u03042, f\n\u2032(z\u0304\u2032)) \u2208 Q\u2032(I). On the other hand, inQ(I) consider any two extended facts T (\u03b11(x\u0304), f(\u03b11(z\u0304)))\nand T (\u03b12(x\u0304), f(\u03b12(z\u0304))), with matchings \u03b11 : B \u2192 I and \u03b12 : B \u2192 I, such that \u03b11(x\u0304) = x\u0304 and \u03b12(x\u0304) = x\u03042. Then in particular \u03b11(x) = x and \u03b12(x) = x2. Since \u03b11 and \u03b12 differ on x, and x is in Z, also \u03b11(z\u0304) and \u03b12(z\u0304) are different. Hence, the two last components f(\u03b11(z\u0304)) and f(\u03b12(z\u0304)) are different. Thus, we see that in Q(I) it is impossible to have two extended atoms T (x\u0304, o) and T (x\u03042, o) with the same oid o. But we have seen this is possible in Q\u2032(I), so Q(I) and Q\u2032(I) are not oid-isomorphic and Q and Q\u2032 cannot be oid-equivalent.\nBy the above Lemma we now assume X \u2229 Z = X \u2229 Z \u2032. The last step is to show that Z \u2212X and Z \u2032 \u2212X , the sets of non-distinguished creation variables, need to have the same cardinality.\nLemma 4.12 (Non-distinguished creation variables). If Z\u2212X and Z \u2032\u2212X have different cardinality then Q and Q\u2032 are not oid-equivalent.\nProof. As in the proof of Lemma 4.11, we consider B as an instance, viewing variables as constants.\nLet k and k\u2032 be the cardinalities of Z \u2212 X and Z \u2212 X \u2032, respectively. By symmetry we may assume that k > k\u2032. Now, for any natural number n, let In be the instance obtained from B by independently multiplying each variable z \u2208 Z \u2212 X into n fresh copies z(1), . . . , z(n). Formally, for any function d : Z\u2212X \u2192 {1, . . . , n}, let d\u0302 be the valuation on var(B) that maps each z \u2208 Z\u2212X to z(d(z)) and that is the identity on all other variables. Then\nIn = \u22c3\nd:Z\u2212X\u2192{1,...,n}\nd\u0302(B).\nThere are nk different functions d : Z\u2212X \u2192 {1, . . . , n}. Each corresponding\nvaluation d\u0302 is a matching of B in In; all these matchings are the identity on x\u0304 but are pairwise different on z\u0304. Thus there are at least nk different extended facts in Q(In) of the form T (x\u0304, o).\nOn the other hand, consider any set S of valuations from X\u222aZ \u2032 to adom(In) that are pairwise different on Z \u2032 \u2212X but that all agree on X . The cardinality of Z \u2032 \u2212X is k\u2032. The cardinality of adom(In) is O(n) (although the cardinality of In itself is larger). Hence, such a set S can be of cardinality at most O(n\nk\u2032 ). Consequently, since k > k\u2032, for n large enough, Q\u2032(In) cannot possibly contain nk different extended facts of the form T (x\u0304, o). But we saw that this is possible in Q(In). So, Q(In) and Q \u2032(In) are not oid-isomorphic and Q and Q \u2032 cannot be oid-equivalent.\nBy the above lemma, and after renaming the variables in Z \u2032\u2212X and reordering the variables in z\u0304\u2032, we may now indeed assume that z\u0304 and z\u0304\u2032 are identical."}, {"heading": "4.4 Characterization of oid-equivalence", "text": "According to the results of the preceding subsection, we are now given two sifo CQs as follows:\nQ = T (x\u0304, f(z\u0304)) \u2190 B (1)\nQ\u2032 = T (x\u0304, f \u2032(z\u0304)) \u2190 B\u2032. (2)\nNote that Q and Q\u2032 have identical tuples x\u0304 and z\u0304 of distinguished and creation variables; moreover, z\u0304 contains no variable more than once. As before, we denote the sets of distinguished and creation variables as X and Z, respectively.\nWe will show that Q and Q\u2032 are oid-equivalent if and only if there are homomorphisms between B and B\u2032 in both directions that (i) keep x\u0304 fixed and (ii) possibly permute the variables in z\u0304. To make this formal, we associate to each query a classical CQ without function symbols.\nDefinition 4.13. Fix a new relation symbol T\u030a of arity the sum of the lengths of x\u0304 and z\u0304. The flattening of Q is the query Q\u030a = T\u030a (x\u0304, z\u0304) \u2190 B. The query Q\u030a\u2032 is defined similarly.\nLet \u03c0 be a permutation of the set Z\u2212X . We extend \u03c0 to var(B) by defining it to be the identity outside Z \u2212 X . We now define Q\u030a\u03c0 to be the conjunctive query obtained from Q\u030a by permuting the variables in z\u0304, that is\nQ\u030a\u03c0 = T\u030a (x\u0304, \u03c0(z\u0304)) \u2190 B.\nThis notion allows us to formulate the following natural sufficient condition for oid-equivalence.\nProposition 4.14. If there exists a permutation \u03c0 of Z \u2212X such that Q\u030a\u03c0 and Q\u030a\u2032 are equivalent, then Q and Q\u2032 are oid-equivalent.\nProof. Let I be an instance. We define an oid isomorphism \u03c1 from Q(I) to Q\u2032(I) as follows. Any oid o in Q(I) is of the form f(\u03b1(z\u0304)) for some matching \u03b1 : B \u2192 I; we define \u03c1(o) := f \u2032(\u03b1(\u03c0(z\u0304))). This is well-defined, i.e., independent of the choice of \u03b1. Indeed, if the data terms f(\u03b11(z\u0304)) and f(\u03b12(z\u0304)) are equal, then the tuples \u03b11(z\u0304) and \u03b12(z\u0304) are equal, and consequently the permuted tuples \u03b11(\u03c0(z\u0304)) and \u03b12(\u03c0(z\u0304)) are equal. Hence, f \u2032(\u03b11(\u03c0(z\u0304))) = f \u2032(\u03b12(\u03c0(z\u0304))).\nThe injectivity of \u03c1 : oids(Q(I)) \u2192 oids(Q\u2032(I)) is shown by an analogous argument. The surjectivity of \u03c1, and the equality \u03c1(Q(I)) = Q\u2032(I), follow readily from the equality Q\u030a\u03c0(I) = Q\u030a\u2032(I).\nWe next prove that the sufficient condition given by the above Proposition is actually also necessary for oid-equivalence. The key idea for proving this is to show that oid-equivalence of sifo CQs depends only on the number of oids generated for any binding of the distinguished variables.\nFormally, for any instance I and any tuple c\u0304 of elements from adom(I), we define\n#c\u0304(Q, I) := #{ o | T (c\u0304, o) \u2208 Q(I) },\nthat is, #c\u0304(Q, I) denotes the number of distinct oids o that occur together with c\u0304 in Q(I). We will show that Q and Q\u2032 are oid-equivalent if and only if #c\u0304(Q, I) = #c\u0304(Q\n\u2032, I) for all instances I and tuples c\u0304. The only-if direction of this statement is obvious, but the if-direction is not so obvious.\nFor our proof, we rely on work by Cohen [14] who studied queries with multiset variables that are evaluated under so-called combined semantics, a semantics that combines set and multiset semantics. Cohen characterized equivalence of such queries in terms of homomorphisms.\nQueries with multiset variables (MV queries) have the form Q0,M where Q0 is a standard CQ and M is some set of variables of Q0 that do not appear in the head of Q0. The elements of M are called the multiset variables. Evaluating an MV query Q0,M on an instance I results in a multiset (bag) of facts, where the number of times a fact occurs is related to the number of different possible assignments of values to the multiset variables.\nLet us define the combined semantics formally. Let Q0 be of the form H0 \u2190 B0 and let I be an input instance. Recall that Q0(I) according to the classical semantics equals\n{\u03b1(H0) | \u03b1 : B0 \u2192 I}.\nLet W be the set of variables appearing in H0. Then the result of evaluating the MV query Q0,M on instance I is defined to be the multiset with ground set Q0(I), where for each fact e \u2208 Q0(I), the multiplicity of e in the multiset is defined to be\n#{\u03b3|M | \u03b3 : B0 \u2192 I and \u03b3(H0) = e}.\nThat is, given a fact \u03b1(H0) \u2208 Q0(I), there may be many different matchings \u03b3 that agree with \u03b1 on H0. The multiplicity of \u03b1(H0) is defined to be not the total number of different such matchings \u03b3, but rather the number of different restrictions one obtains when restricting these matchings \u03b3 to M .4\nTwo MV queries are equivalent if they evaluate to the same multiset on every input instance. Equivalence of MV queries can be characterized using the notion of multiset-homomorphism [14]. A multiset-homomorphism from MV query Q0,M to MV query Q \u2032 0,M \u2032 is a homomorphism h : Q0 \u2192 Q \u2032 0 such that h is injective on M and h(M) \u2286 M \u2032. Cohen showed the following:\nTheorem 4.15 ([14], Thm 5.3). Two MV queries are equivalent if and only if there are multiset homomorphisms between them in both directions.\nTo leverage this result on MV equivalence, we associate two MV queries to our given sifo CQs in the following way.\nDefinition 4.16. Fix a new relation symbol T0 of arity the length of x\u0304. The MV queries Q\u0303 and Q\u0303\u2032 are defined as Q0, (Z \u2212X) and Q \u2032 0, (Z \u2212X) respectively, where\nQ0 = T0(x\u0304) \u2190 B Q\u20320 = T0(x\u0304) \u2190 B \u2032\nThe following proposition now relates oid-equivalence to MV-equivalence:\nProposition 4.17. If Q and Q\u2032 are oid-equivalent, then the MV queries Q\u0303 and Q\u0303\u2032 are equivalent.\nProof. Let I be an instance. We must show that the multisets Q\u0303(I) and Q\u0303\u2032(I) are equal. Since Q and Q\u2032 are oid-equivalent, the ground sets Q0(I) and Q \u2032 0(I) of Q\u0303(I) and Q\u0303\u2032(I) are already equal. We must show that the element multiplicities are the same as well.\n4The motivation for MV queries was to model the semantics of positive SQL queries with nested EXISTS subqueries. While queries under standard SQL semantics return multisets of tuples, only the relations mentioned in the top level SQL block contribute to the multiplicities of answers, whereas relations mentioned in the subquery do not.\nLet T0(c\u0304) be an arbitrary element of Q0(I). By the semantics of oCQs, we have the following equalities:\n#c\u0304(Q, I) = #{\u03b3|X\u222aZ | \u03b3 : B \u2192 I and \u03b3(x\u0304) = c\u0304}\n#c\u0304(Q \u2032, I) = #{\u03b3|X\u222aZ | \u03b3 : B \u2032 \u2192 I and \u03b3(x\u0304) = c\u0304}\nSince Q(I) and Q\u2032(I) are oid-isomorphic, the left-hand sides of the above two equalities are equal. Hence, the right-hand sides are equal as well. But these are precisely the multiplicities of T0(c\u0304) in Q\u0303(I) and Q\u0303 \u2032(I) respectively.\nThe following proposition further relates MV equivalence to equivalence of the flattenings up to permutation:\nProposition 4.18. If the MV queries Q\u0303 and Q\u0303\u2032 are equivalent then there exists a permutation \u03c0 of Z \u2212X such that Q\u030a\u03c0 and Q\u030a\u2032 are equivalent.\nProof. By Theorem 4.15, there exist a multiset homomorphism h from Q\u0303 to Q\u0303\u2032, and a multiset homomorphism h\u2032 from Q\u0303\u2032 to Q\u0303. Since Theorem 4.15 also implies that h is injective on Z \u2212X and that h(Z \u2212X) \u2286 Z \u2212X , we can conclude that h acts as a permutation on Z \u2212X . Moreover, h is the identity on X . The same two properties hold for h\u2032.\nNow put \u03c0 = (h|Z\u2212X) \u22121. Then h : Q\u030a\u03c0 \u2192 Q\u030a\u2032. So it remains to find a homomorphism h\u2032\u2032 : Q\u030a\u2032 \u2192 Q\u030a\u03c0. Thereto, note that h\u2032h acts as a permutation on Z\u2212X . Since Z\u2212X is finite, there exists a nonzero natural number m such that (h\u2032h)m is the identity on Z \u2212X . Equivalently, (h\u2032h)m\u22121h\u2032 equals \u03c0 on Z \u2212X . We conclude that (h\u2032h)m\u22121h\u2032 is the desired homomorphism h\u2032\u2032.\nWe summarize the three preceding Propositions in the following.\nTheorem 4.19. Consider two sifo CQs\nQ = T (x\u0304, f(z\u0304)) \u2190 B\nQ\u2032 = T (x\u0304, f \u2032(z\u0304)) \u2190 B\u2032\nwhere Q and Q\u2032 have identical tuples x\u0304 and z\u0304 of distinguished and creation variables, and where z\u0304 contains no variable more than once. Denote the sets of distinguished and creation variables by X and Z, respectively.\nThe following are equivalent:\n1. The sifo CQs Q and Q\u2032 are oid-equivalent;\n2. The MV queries Q\u0303 and Q\u0303\u2032 are equivalent;\n3. There is a permutation \u03c0 of Z\u2212X such that the classical CQs Q\u030a\u03c0 and Q\u030a\u2032\nare equivalent."}, {"heading": "4.5 Computational complexity", "text": "The results of this section imply the following:\nCorollary 4.20. Testing oid-equivalence of sifo CQs is NP-complete.\nProof. Assume given sifo CQs Q and Q\u2032 with the same head predicate:\nQ = T (x\u0304, f(z\u0304)) \u2190 B\nQ\u2032 = T (x\u0304\u2032, f \u2032(z\u0304\u2032)) \u2190 B\u2032.\nLet X , X \u2032, Z and Z \u2032 denote the sets of variables occurring in x\u0304, x\u0304\u2032, z\u0304 and z\u0304\u2032, respectively.\nTo test oid-equivalence, we begin by removing duplicates in z\u0304 and z\u0304\u2032, as justified by Lemma 4.9. Note that x\u0304 and x\u0304\u2032 have the same length k, because of the fixed arity of T . So we can write x\u0304 = x1, . . . , xk and x\u0304 \u2032 = x\u20321, . . . , x \u2032 k. Consider the mapping \u03c3 = {(x1, x \u2032 1), . . . , (xk, x \u2032 k)}. We test if \u03c3 is a bijection from X to X \u2032; if not, then Q and Q\u2032 are not oid-equivalent by Lemma 4.10. If \u03c3 is a bijection, we can safely replace every variable x\u2032 in X \u2032 by \u03c3\u22121(x\u2032), which yields a sifo CQ that is oid-equivalent to Q\u2032. Hence, from now on we may assume that x\u0304 = x\u0304\u2032 and in particular X = X \u2032.\nNext, we test whether X \u2229Z = X \u2229Z \u2032 and whether Z\u2212X and Z \u2032\u2212X have the same cardinality; if one of the two tests fails then Q and Q\u2032 are not oidequivalent by Lemmas 4.11 and 4.12. Otherwise, we can rename the variables in Z \u2032 \u2212X , so that we may assume that z\u0304 = z\u0304\u2032.\nWe are now left in the situation where Q and Q\u2032 are in the general forms (1) and (2) from Subsection 4.4, to which Theorem 4.19 applies. By the third statement of this theorem we can test oid-equivalence of Q and Q\u2032 in NP by guessing a permutation \u03c0 and two homomorphisms between Q\u030a\u03c0 and Q\u030a\u2032 in both directions.\nNP-hardness follows immediately because the problem has equivalence of classical CQs as a special case, which is well known to be NP-hard. Indeed, oid equivalence of sifo CQs Q and Q\u2032 in the special case where the creation functions are nullary, amounts to classical equivalence when we ignore the function terms in the heads."}, {"heading": "5 Logical entailment of sifo CQs interpreted as", "text": "schema mappings\nObject-creating CQs, and sifo CQs in particular, can also be interpreted alternatively as schema mappings rather than as queries. Specifically, consider a sifo CQ Q of the general form T (x\u0304, f(z\u0304)) \u2190 B over the database schema S. Let v\u0304 be the sequence of all variables used in B. Then we may view Q as a second-order implicational statement over the augmented schema S \u222a {T }, as follows:\n\u2203f\u2200v\u0304(B \u2192 H)\nHere, H is the head and B is conveniently used to stand for the conjunction of its elements. Note that this formula is second-order because it existentially quantifies a function f ; we denote the above formula by sotgd(Q). This formula belongs to the well-known class of second-order tuple-generating dependencies (SO-tgds). More specifically, it is a plain SO-tgd [7].\nSyntactically, the plain SO-tgds coming from sifo CQs in this manner form a restricted class of SO-tgds, defined by the following restrictions:\n\u2022 Plain SO-tgd may consist of multiple rules; sifo CQs consist of a single rule.\n\u2022 The head of a plain SO-tgd may consist of multiple atoms; the head of a sifo CQ consists of a single atom. (This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.)\n\u2022 There is only one function symbol, which moreover can be applied only once in the head.\nWhen interpreting a sifo CQQ as an SO-tgd, the semantics becomes that of a schema mapping. Specifically, let I be an instance over S, considered as a source instance, and let J be an instance over {T }, considered as a target instance. Then (I, J) together form an instance over the augmented schema S \u222a {T }. Now we say that (I, J) satisfies Q, denoted by (I, J) |= Q, if the structure (adom(I) \u222a adom(J), I, J) satisfies sotgd(Q) under the standard semantics of second-order logic, using adom(I) \u222a adom(J) as the universe of the structure.\nThe following example and remark illustrate that the semantics of sifo CQs as SO-tgds is quite different from their semantics as object-creating queries.\nExample 5.1. Let us consider again our query from Example 1. As we have mentioned in the Introduction, we can now write it as an SO-tgd as follows:\n\u2203f\u2200x\u2200y\u2200c(Mother (c, x) \u2227 Father (c, y) \u2192 Family(c, f(x, y)))\nTake the instance I consisting of the Mother and Father facts listed in Table 3.1, and take the instances J1 and J2 consisting of the Family facts listed in Table 6 left and right respectively. Then both pairs (I, J1) and (I, J2) satisfy the SO-tgd. For J1 this is witnessed by the following function f :\nx y f(x, y) anne adam jones claire carl simpson diana carl smith\nFor J2 this is witnessed by the function that simply maps everything to jones. In contrast, for J3 consisting of the Family facts listed in Table 7, the pair (I, J3) does not satisfy the SO-tgd. Indeed, suppose there would exist a function f witnessing the truth of the formula on (I, J3). Since beth has anne as mother and adam as father, the fact\nFamily(beth, f(anne, adam))\nmust belong to J3. The only Family-fact with beth in the first position is\nFamily(beth, jones),\nso we conclude f(anne, adam) = jones.\nFurthermore, since ben also has anne as mother and adam as father, the fact\nFamily(ben, f(anne, adam))\nmust be in J3. The only Family-fact with ben in the first position is\nFamily(ben,murphy),\nhowever, so we must conclude that\nf(anne, adam) = murphy,\nwhich is in contradiction with the previous conclusion.\nRemark 5.2. Note that, by the purely implicational nature of SO-tgds, if (I, J) satisfies an SO-tgd and J \u2286 J \u2032, then also (I, J \u2032) satisfies the SO-tgd. Hence, continuing the previous example, for any instance J \u2032 obtained by J1 or J2 by adding some more Family-facts, the pair (I, J \u2032) would still satisfy the SO-tgd from the example.\nThe above example and remark show that given a source instance I, there are in general multiple possible target instances J such that (I, J) |= Q. This is in contrast to the semantics of Q as an oCQ, where Q(I) is an extended instance that is uniquely defined. Still, there is a connection between the oCQ semantics and the SO-tgd semantics. Specifically, Q(I) can be viewed as a target instance in a canonical manner, using oid-to-constant assignments (oc-assignments for short) defined as follows.\nDefinition 5.3. Let I be a source instance and let J be an extended instance over {T } such that consts(J) \u2286 adom(I). An oc-assignment for J with respect to I is an injective mapping \u03c1 : oids(J) \u2192 dom so that the image of \u03c1 is disjoint from adom(I).\nThus, \u03c1 assigns to each non-constant data term from J a different constant that is not in adom(I).\nWe now observe the following obvious property giving a connection between the oCQ semantics and the SO-tgd semantics:\nProposition 5.4. Let I be a source instance and let \u03c1 be an oc-assignment for Q(I) with respect to I. Then (I, \u03c1(Q(I))) |= Q.\nIn fact, Q(I) corresponds to what Fagin et al. [18] call the chase of I with sotgd(Q)."}, {"heading": "5.1 Nested dependencies", "text": "We have introduced sifo CQs as a restricted class of plain SO-tgds. But actually, sifo CQs can also be considered as a restricted form of so-called nested tgds [8]. Thereto, consider again a sifo CQ of the general form T (x\u0304, f(z\u0304)) \u2190 B. Let u\u0304 be the sequence of all variables from B, except for the creation variables (the variables from z\u0304). Furthermore, let w be a fresh variable not occurring in B, and let H \u2032 be the atom T (x\u0304, w). We can now associate to Q the following implicational statement, denoted by ntgd(Q):\n\u2200z\u0304\u2203w\u2200u\u0304(B \u2192 H \u2032)\nNote that ntgd(Q) is now a first-order formula, but it is clear that ntgd(Q) is logically equivalent to sotgd(Q). Hence, the schema mappings arising from sifo CQs are not essentially second-order in nature."}, {"heading": "5.2 Logical entailment", "text": "In Section 4 we have shown that equivalence of sifo CQs as object-creating queries is decidable. Now that we have seen that sifo CQs can also be given a semantics as schema mappings, we may again ask if equivalence under this alternative semantics is decidable. The answer is affirmative; we have seen in the previous subsection that sifo CQ mappings belong to the class of nested dependencies, and logical implication of nested dependencies has recently been shown to be decidable [26]. When this general implication test for nested dependencies is applied specifically to sifo CQ schema mappings, it can be implemented in non-deterministic polynomial time. Hence, logical entailment (and also logical equivalence) of sifo CQ schema mappings is NP-complete.\nIn the present section, we present a specialized logical entailment test for sifo CQ schema mappings which is much simpler and more elegant, and provides more insight in the problem by relating it to testing implication of a join dependency by a conjunctive query (Theorem 5.10). Interestingly, there is a striking\ncorrespondence between the general implication test when applied to sifo CQs, and the strategy we use to prove our theorem. An in-depth comparison will be given in Section 6, after we have stated the Theorem formally and have seen its proof.\nFormally, given two schema mappings M and M\u2032 from a source schema S to a target schema {T }, we say that M logically entails M\u2032 if the following implication holds for every instance I over S and every instance J over {T }:\n(I, J) satisfies M \u21d2 (I, J) satisfies M\u2032.\nReferring to the view of sifo CQs as SO-tgds introduced above, we now define:\nDefinition 5.5. Let Q and Q\u2032 be two sifo CQs with the same head predicate, and over the same database schema. We say that Q logically entails Q\u2032 if sotgd(Q) logically entails sotgd(Q\u2032).\nExample 5.6. Recall the sifo CQs Q and Q\u2032 from Example 4.7:\nQ = T (x, f(y)) \u2190 R(x, y, z)\nQ\u2032 = T (x, f \u2032(x, y)) \u2190 R(x, y, z)\nIt is clear that Q logically entails Q\u2032. Indeed, if there exists a function f witnessing the truth of sotgd(Q), then we can easily define a function f \u2032 witnessing the truth of sotgd(Q\u2032) by defining f \u2032(x, y) := f(y).\nConversely, however, Q\u2032 does not logically entail Q. Indeed, Table 8 shows (I, J) where (I, J) |= Q\u2032 but (I, J) 6|= Q.\nExample 5.7. Recall the sifo CQs Q and Q\u2032 from Example 4.8:\nQ = T (x, f(x)) \u2190 R(x, y, z)\nQ\u2032 = T (x, f \u2032(x, y, z)) \u2190 R(x, y, z)\nAlthough Q and Q\u2032 are not oid-equivalent, they are logically equivalent: they logical entail each other. The logical entailment of Q\u2032 by Q is again clear. To see the converse direction, assume f \u2032 witnesses the truth of sotgd(Q\u2032). Then we define f(x) for any x as follows: if there exists a pair (y, z) such that R(x, y, z) holds, we fix one such pair (y, z) arbitrarily and define f(x) := f \u2032(x, y, z). If no such y and z exist, we may define f(x) arbitrarily. It is now clear that this f witnesses the truth of sotgd(Q).\nExample 5.8. Consider the sifo CQs:\nQ = T (x, f(z1)) \u2190 R(z1, x), R(z1, z2)\nQ\u2032 = T (x, f \u2032(z1, z2)) \u2190 R(z1, x), R(z1, z2)\nAlso here, Q and Q\u2032 logically entail each other. The logical entailment of Q\u2032 by Q is again clear. To see the converse direction, we can use a reasoning similar to that used in Example 5.7. Assume f \u2032 witnesses the truth of sotgd(Q\u2032). Then we define f(z1) for any z1 as follows: if there exists z2 such that R(z1, z2) holds, we fix one such z2 arbitrarily and define f(z1) := f\n\u2032(z1, z2). If no such z2 exists, we may define f(z1) arbitrarily. The function f thus defined witnesses the truth of sotgd(Q).\nNote that the kind of reasoning used here and in Example 5.7 does not work in the case of Example 5.6. In Theorem 5.10 we will characterize formally when this kind of reasoning is correct.\nExample 5.7 shows that logical equivalence (logical entailment in both directions) does not imply oid-equivalence of sifo CQs. We will see in Theorem 5.12 that the other direction does hold."}, {"heading": "5.3 Join dependencies and tableau queries", "text": "In our characterization of sifo CQ logical entailment we use a number of concepts from classical relational database theory [2], which we recall here briefly.\nRecall that a relation scheme is a finite set of elements called attributes. It is customary to denote the union of two relation schemes X and Y by juxtaposition, thus writing XY for X \u222a Y .\nA tuple over a relation scheme U is a function from U to dom. A relation over U is a finite set of tuples over U .\nLet t be a tuple over U and let X \u2286 U . The restriction of t to X is denoted by t[X ]. The projection \u03c0X(r) of a relation r over U equals { t[X ] | t \u2208 r }.\nWe now turn to tableau queries, which are an alternative formalization of conjunctive queries so that the result of a query is a set of tuples rather than a set of facts. Let S be a database schema, and let B be a finite set of atoms with predicates from S, as would be the body of a conjunctive query over S. Let V = var(B). For any U \u2286 V , the pair (B,U) is called a tableau query over S. When applied to an instance I over S, this tableau query returns a relation over U in the following manner. Let Mat(B, I) be the set of all matchings of B in I. Using variables for attributes, V can be viewed as a relation scheme. Under this view, every valuation on V is a tuple over V , and thus Mat(B, I) is a relation over V . We now define the result of (B,U) on input I to be \u03c0U (Mat(B, I)). This result is denoted by (B,U)(I).\nWe finally recall join dependencies. Let t1 and t2 be tuples over the relation schemes U1 and U2, respectively. If t1 and t2 agree on U1 \u2229 U2, the union t1 \u222a t2 (where we take the union of two functions, viewed as sets of pairs) is a well-defined tuple over the relation scheme U1U2. The natural join r1 \u22ca\u22c9 r2, for\nrelations r1 and r2 over U1 and U2, respectively, then equals\n{t1 \u222a t2 | t1 \u2208 r1 & t2 \u2208 r2 & t1[U1 \u2229 U2] = t2[U1 \u2229 U2]}.\nConsider now any relation r over some relation scheme U . Let U1 and U2 be subsets of U (not necessarily disjoint) such that U = U1U2. Then r satisfies the join dependency (JD) U1 \u22ca\u22c9 U2 if r = \u03c0U1(r) \u22ca\u22c9 \u03c0U2(r). Note that the containment from left to right is trivial, so one only needs to verify the containment \u03c0U1(r) \u22ca\u22c9 \u03c0U2(r) \u2286 r.\nThe logical implication of JDs by tableau queries is well understood and can be solved by the chase procedure with NP complexity [25, 2]. Formally, a tableau query Q = (B,U) over S is said to imply a JD over U if for every instance I over S, the relation Q(I) satisfies this JD."}, {"heading": "5.4 Decidability of sifo CQ logical entailment", "text": "We consider two sifo CQs Q and Q\u2032 with the same head predicate:\nQ = T (x\u0304, f(z\u0304)) \u2190 B\nQ\u2032 = T (x\u0304\u2032, f \u2032(z\u0304\u2032)) \u2190 B\u2032\nRemark 5.9. We assume Q and Q\u2032 to have their function symbol in the same position in the head (here taken to be the last position). This is justified because otherwise Q could never logically entail Q\u2032. In proof, suppose the function symbol in the head of Q\u2032 would not be in the last position. Then we have a variable x\u2032 from B\u2032 in the last position. Now consider an instance I such that both Q(I) and Q\u2032(I) are nonempty. (Such an instance could be constructed by taking the disjoint union of B and B\u2032 and substituting constants for variables.) Let \u03c1 by an oc-assignment for Q(I) with respect to I. By Proposition 5.4, we have (I, \u03c1(Q(I))) |= Q. In \u03c1(Q(I)), none of the elements in the last position of a T -fact belongs to adom(I). But then (I, \u03c1(Q(I))) cannot satisfy Q\u2032. Indeed, since Q\u2032(I) is nonempty, there is a matching \u03b1\u2032 : B\u2032 \u2192 I. In any J \u2032 such that (I, J \u2032) |= Q\u2032, there needs to be a T -fact with \u03b1\u2032(x\u2032) in the last position, and \u03b1\u2032(x\u2032) \u2208 adom(I). We conclude that Q does not logically entail Q\u2032.\nIn what follows we use X , Z and Z \u2032 to denote the sets of variables appearing in the tuples x\u0304, z\u0304 and z\u0304\u2032, respectively.\nWe establish:\nTheorem 5.10. Q logically entails Q\u2032 if and only if there exists a homomorphism h : B \u2192 B\u2032 satisfying the following conditions:\n1. h(x\u0304) = x\u0304\u2032;\n2. h(X \u2229 Z) \u2286 Z \u2032;\n3. Let Yh := h \u22121(Z \u2032), i.e., Yh = {y \u2208 var(B) | h(y) \u2208 Z \u2032}. Then the tableau query (B,XYhZ) implies the join dependency XYh \u22ca\u22c9 YhZ.\nProof of sufficiency. Let (I, J) |= Q, witnessed by the function f . We must show (I, J) |= Q\u2032. This means finding a function f \u2032 witnessing the truth of sotgd(Q\u2032) in (I, J).\nCall any two matchings \u03b11, \u03b12 \u2208 Mat(B, I) equivalent if they agree on Yh. This is denoted by \u03b11 \u2261 \u03b12. Let \u03c1 be any function from Mat(B, I) to Mat(B, I) with the two properties, first, that \u03c1(\u03b1) \u2261 \u03b1 and, second, that \u03b11 \u2261 \u03b12 implies \u03c1(\u03b11) = \u03c1(\u03b12). Thus, \u03c1 amounts to choosing a representative out of each equivalence class. We denote the application of \u03c1 by subscripting, writing \u03c1(\u03b1) as \u03c1\u03b1.\nLet us define f \u2032 as follows. Take any matching \u03b2 : B\u2032 \u2192 I. Then we put f \u2032(\u03b2(z\u0304\u2032)) := f(\u03c1\u03b2\u25e6h(z\u0304)). To see that this is well-defined, recall that h(Yh) \u2286 Z\n\u2032. Hence, \u03b21(z\u0304 \u2032) = \u03b22(z\u0304 \u2032) implies that \u03b21 \u25e6 h \u2261 \u03b22 \u25e6 h, so \u03c1\u03b21\u25e6h = \u03c1\u03b22\u25e6h.\nWe now show that this interpretation of f \u2032 satisfies the requirements. Specifically, let \u03b2 : B\u2032 \u2192 I be a matching. We must show that T (\u03b2(x\u0304\u2032), f \u2032(\u03b2(z\u0304\u2032))) \u2208 J . Consider the valuations \u03b21 = \u03b2 \u25e6h and \u03b22 = \u03c1\u03b2\u25e6h, both belonging to Mat(B, I), and viewed as tuples over the relation scheme var(B). Since these two tuples agree on Yh, also the two restrictions \u03b21[YhX ] and \u03b22[YhZ] agree on Yh. Since X \u2229 Z \u2286 Yh, the union \u03b21[YhX ] \u222a \u03b22[YhZ] is a well-defined tuple over XYhZ. Since \u03c0XYhZ(Mat(B, I)) satisfies the JD YhX \u22ca\u22c9 YhZ, the union belongs to \u03c0XYhZ(Mat(B, I)). Hence, there exists a valuation \u03b3 \u2208 Mat(B, I) that agrees with \u03b2 \u25e6 h on X , and with \u03c1\u03b2\u25e6h on Z. Since (I, J) |= Q, we have T (\u03b3(x\u0304), f(\u03b3(z\u0304))) \u2208 J . By the preceding, \u03b3(x\u0304) = \u03b2(h(x\u0304)) and \u03b3(z\u0304) = \u03c1\u03b2\u25e6h(z\u0304) = g(\u03b2(z\u0304\u2032)). We conclude that T (\u03b2(x\u0304\u2032), g(\u03b2(z\u0304\u2032))) \u2208 J as desired.\nProof of necessity. Let V \u2032 = var(B\u2032), and let n be the arity of f . For each l \u2208 {0, 1, . . . , n} and each u \u2208 V \u2032 \u2212 Z \u2032 we introduce a fresh copy of u, denoted by ul. We say that this fresh copy is \u201ccolored\u201d with color l. For each variable u \u2208 Z \u2032, we simply define ul to be u itself. We say that the variables in Z \u2032 are \u201ccolored white\u201d.\nFor any tuple of variables u\u0304 = (u1, . . . , up) in V \u2032, we denote the tuple\n(ul1, . . . , u l p) by u\u0304 l. In this tuple, all variables are colored l or white. We then define B\u2032l = {R(u\u0304l) | R(u\u0304) \u2208 B\u2032 } and view it as an instance, i.e., the variables ul are considered to be constants.\nNow define the instance I = \u22c3n\nl=0 B \u2032l, and construct the instance J = Q(I).\nBy Proposition 5.4, (I, J) |= Q, where we omit the oc-assignment for the sake of clarity. Since Q logically entails Q\u2032, also (I, J) |= Q\u2032. Hence, there exists a function f \u2032 such that for each color l, using the matching idl : B\u2032 \u2192 I, u 7\u2192 ul, the fact T (x\u0304\u2032l, f \u2032(z\u0304\u2032l)) = T (x\u0304\u2032l, f \u2032(z\u0304\u2032)) belongs to J .\nSince J = Q(I), we have f \u2032(z\u0304\u2032) = f(w\u0304) for some tuple w\u0304 of colored variables in V \u2032. Since the arity of f is n and there are n + 1 distinct colors, some color does not appear in w\u0304. Without loss of generality we may assume that this is the color 0.\nLet us now focus on the fact T (x\u0304\u20320, f(w\u0304)) in J . Like any T -fact in J , this fact has been produced by some matching k : B \u2192 I such that T (x\u0304\u20320, f(w\u0304)) = k(T (x\u0304, f(z\u0304))), so\n(a) k(x\u0304) = x\u0304\u20320 and\n(b) k(z\u0304) = w\u0304.\nLet s denote the mapping that removes colors, i.e., s(ul) = u for every u \u2208 V \u2032 and every l \u2208 {0, 1, . . . , n}. Since s(I) \u2286 B\u2032, we have a homomorphism s\u25e6k : B \u2192 B\u2032. We now define h := s\u25e6k and show that it satisfies the conditions required by the Theorem. The first condition is clear since h(x\u0304) = s(k(x\u0304)) = s(x\u0304\u20320) = x\u0304\u2032.\nFor the second condition, let x \u2208 X \u2229 Z. By (a), k(x) is colored 0 or white. By (b), k(x) is colored non-zero or white. Hence, k(x) is colored white, i.e., k(x) \u2208 Z \u2032, so h(x) = s(k(x)) = k(x) \u2208 Z \u2032 as desired.\nFinally, to show that (B,XYhZ) implies XYh \u22ca\u22c9 YhZ we must establish the query containment\n(B,XYh) \u22ca\u22c9 (B, YhZ) \u2286 (B,XYhZ).\nTreating tableau queries as conjunctive queries, and using the well-known containment criterion for conjunctive queries, this amounts to showing the existence of a certain homomorphism. More specifically, we express the query (B,XYh) \u22ca\u22c9 (B, YhZ) by the conjunctive query with the body B2 = B0 \u222a B1 defined as follows. The body B0 is obtained from B by replacing each variable u not in Yh by a fresh copy u 0. For each u \u2208 Yh we define u 0 simply as u itself. The body B1 is obtained from B by replacing each variable not in Yh by a fresh copy u1. Again, for each u \u2208 Yh we define u\n1 simply as u itself. To show the containment, we now must find a homomorphism m from B to B2 such that each u \u2208 X \u2212 Yh is mapped to u\n0; each u \u2208 Yh is mapped to u; and each u \u2208 Z \u2212 Yh is mapped to u\n1. Thereto, we define the following mapping m:\n\u2022 if k(u) is colored 0, then m(u) := u0;\n\u2022 if k(u) is colored l for some l > 0, then m(u) := u1;\n\u2022 if k(u) is colored white, then m(u) := u.\nLet us verify that m : B \u2192 B2 is a homomorphism. Consider an atom R(u\u0304) in B; we must show R(m(u\u0304)) \u2208 B2. Since k : B \u2192 I, we know that R(k(u\u0304)) \u2208 I. By definition of I, this means that R(k(u\u0304)) = R(v\u0304l) for some atom R(v\u0304) in B\u2032 and some color l. So, for each variable u in u\u0304, the color of k(u) is either l or white. We now distinguish two cases.\n\u2022 If k(u) is colored white, then h(u) = k(u) \u2208 Z \u2032 so u \u2208 Yh. Hence, in this case, m(u) = u = u0 = u1.\n\u2022 If k(u) is colored l, then by definition m(u) = u0 when l = 0, and m(u) = u1 when l > 0.\nWe conclude that R(m(u\u0304)) = R(u\u03040) \u2208 B0 when l = 0, and R(m(u\u0304)) = R(u\u0304 1) \u2208 B1 when l > 0. Hence, since B2 = B0 \u222a B1, we always have R(m(u\u0304)) \u2208 B2 as desired.\nIt remains to verify that m maps the variables in XYhZ correctly. If u \u2208 Yh, then h(u) = k(u) \u2208 Z \u2032 so k(u) is colored white and m(u) = u as desired. If u \u2208 X \u2212 Yh, then by (a), k(u) is colored 0 so m(u) = u\n0 as desired. Finally, if u \u2208 Z \u2212 Yh, then by (b), k(u) is colored l > 0 so m(u) = u 1 as desired.\nAs a corollary, we obtain that the complexity of deciding logical entailment for sifo CQs is not worse than that of deciding containment for classical CQs:\nCorollary 5.11. Testing logical entailment of sifo CQs is NP-complete.\nProof. Membership in NP follows from Theorem 5.10; as a witness for logical entailment we can use a homomorphism h satisfying the first two conditions of the theorem, together with a homomorphism h0 from the query (B,XYhZ) to the query (B,XYh) \u22ca\u22c9 (B, YhZ) witnessing the third condition of the theorem. NP-hardness follows because the problem has containment of classical CQs as a special case, which is well known to be NP-hard. Indeed, logical entailment of a sifo Q\u2032 by a sifo Q, in the special case where the creation functions of Q and Q\u2032 are nullary, amounts to classical containment of Q in Q\u2032 when we ignore the function terms in the heads."}, {"heading": "5.5 From oid-equivalence to logical entailment", "text": "Let Q and Q\u2032 be sifo CQs of the general forms (1) and (2) from Subsection 4.4. From our main Theorems 4.19 and 5.10, we can conclude the following.\nTheorem 5.12. If Q and Q\u2032 are oid-equivalent, then Q logically entails Q\u2032.\nProof. By Theorem 4.19, there exists a permutation \u03c0 of Z \u2212X such that Q\u030a\u03c0 and Q\u030a\u2032 are equivalent. Hence there is a homomorphism h : Q\u030a\u03c0 \u2192 Q\u030a\u2032. Clearly h : B \u2192 B\u2032. We verify that h satisfies the conditions of Theorem 5.10, thus showing that Q logically entails Q\u2032.\n1. Since h maps the head of Q\u030a\u03c0 to the head of Q\u030a\u2032, we have h(x\u0304) = x\u0304 and h(\u03c0(z\u0304)) = z\u0304. Since x\u0304\u2032 = x\u0304, we have h(x\u0304) = x\u0304\u2032 as desired.\n2. Since h is the identity on X , we have h(X \u2229 Z) = X \u2229 Z \u2286 Z = Z \u2032 as desired.\n3. Since h(\u03c0(z\u0304)) = z\u0304 and \u03c0(Z) = Z, we have h(Z) = Z = Z \u2032. Hence Z \u2286 Yh. But then the join dependency XYh \u22ca\u22c9 YhZ becomes XYh \u22ca\u22c9 Yh which trivially holds."}, {"heading": "6 Discussion", "text": "The results in this paper provide an understanding of the notions of oid-equivalence and logical entailment for sifo CQs. Sifo CQs, however, form a very simple subclass of oCQs. Moreover, oCQs themselves are rather limited, for example, they consist of a single rule and the rule can have only one atom in the head. Thus there are at least three natural directions for further research: (i) allowing more than one function in the head; (ii) allowing more than one atom in the head; (iii) allowing more than one rule.\nContainment Furthermore, in addition to oid equivalence of oCQs, it would be natural to also investigate a notion of oid-containment. There are actually at least two reasonable ways to define such a notion. The situation is similar to that in research on CQs with counting or bag semantics [15, 14]. Most of the known results are for equivalence only, with the extension to containment typically an open problem. Indeed, our characterization of oid-equivalence for sifo CQs relies on equivalence of CQs with bag semantics. An extension to oidcontainment will likely need a similar advance on containment of CQs with bag semantics.\nSifo CQs and ILOG In the introduction we mentioned that sifo CQs, and oCQs in general, are a fragment of ILOG without recursion [22]. Sifo CQs belong to the subclass of the class of recursion-free ILOG programs \u201cwith isolated oid creation\u201d [23]. For this class, oid-equivalence was already known to be decidable. This was shown by checking all finite instances up to some exponential size. Hence, our NP-completeness result for oid-equivalence of sifo CQs does not follow from the previous work. More generally, the decidability of oid-equivalence for general recursion-free ILOG programs, or already of oCQs for that matter, is a long-standing open question. Various interesting examples showing the intricacies of this problem have already been given by Hull and Yoshikawa [23].\nSifo CQs and nested dependencies In Section 5.1 we also presented sifo CQs, now viewed as schema mappings, as a very simple subclass of nested tgds. The implication problem for general nested tgds was shown to be decidable by Kolaitis et al. [26] in work done independently from the present paper. Nevertheless our characterization of implication for sifo CQs, given by Theorem 5.10, does not follow from the general decision procedure for nested tgds. Instead, the general procedure, when applied to two sifo CQs, is strikingly similar to our proof of necessity of our Theorem. Using the notation from that proof, the general procedure applied to test implication of sifo CQ Q\u2032 by sifo CQ Q would amount to testing for the existence of a homomorphism h from {T (x\u0304\u2032l, f \u2032(z\u0304\u2032)) | l = 0, . . . , n} to Q(I). Since Q(I) = {T (\u03b1(x\u0304), f(\u03b1(z\u0304))) | \u03b1 : B \u2192 I}, this can be implemented by guessing h and n + 1 matchings \u03b1l : B \u2192 I such that (h(x\u0304\u2032l), f \u2032(h(z\u0304\u2032))) = (\u03b1l(x\u0304), f(\u03b1l(z\u0304))) for l = 0, . . . , n. In contrast, as explained\nin Corollary 5.11, our characterization involves guessing just two homomorphisms.\nSifo CQs and plain SO-tgds As described in Section 5, sifo CQs are a very simple subclass of plain SO-tgds. For plain SO-tgds, deciding logical equivalence is again an open problem. Also, the notion of oid-equivalence, defined in this paper for oCQs, can be readily extended to plain SO-tgds. We illustrate some difficulties involved in allowing multiple functions in the head, which is indeed allowed in plain SO-tgds. First, consider the oid-equivalence problem. For sifo CQs we have shown in Section 4.4 of this paper that, as far as oid-equivalence is concerned, only the counts of generated oids per tuple are important. Now consider the following pair of oCQs:\nQ = T (x, f(y), g(x, z)) \u2190 R(x, y), R(x, z)\nQ\u2032 = T (x, f(y), g(x, y)) \u2190 R(x, y), R(x, z)\nBoth queries create the same number of new f -oids and g-oids per x-value, but now it also becomes important how these oids are paired. In Q more pairs are generated for each x, and the two queries are not oid-equivalent. So, in the case of multiple functions, also the interaction between the multiple terms needs to be taken into account in some way.\nA similar comment applies to the problem of logical equivalence. It is not immediately clear how the join dependency condition of Theorem 5.10 should be generalized in the presence of multiple functions. Consider, for example, the following:\nQ = T (x, f1(z1, y1), f2(z2, y2)) \u2190 R(x, z1, z2), S(z1, y1), S(z2, y2) Q\u2032 = T (x, g1(u), g2(u)) \u2190 R(x, u, x), R(x, x, u), S(u, v1), S(x, v2)\nThe f1-part of Q (ignoring the third component in the head) logically entails the g1-part of Q\n\u2032, and likewise the f2-part of Q (ignoring the second component in the head) logically entails the g2-part of Q\n\u2032. Globally, however, Q does not logically entail Q\u2032; this can be seen by the instances shown in Table 9, which satisfy Q but not Q\u2032.\nA related interesting question then is whether Theorem 5.12, that oidequivalence implies logical entailment, still holds for plain SO-tgds. When we\nallow nested function terms in the head (which goes beyond plain SO-tgds) the implication breaks down, as shown by the following example [17, Example 3.8]:\nQ = T (x, f(x), g(f(x))) \u2190 S(x)\nQ\u2032 = T (x, f(x), g(x)) \u2190 S(x)\nHere Q and Q\u2032 are oid-equivalent, and Q logically entails Q\u2032, but Q\u2032 does not logically entail Q."}, {"heading": "Acknowledgment", "text": "We thank the anonymous referees for their careful comments which helped improve the presentation of the paper."}], "references": [{"title": "Data on the Web: From relations to semistructured data and XML", "author": ["S. Abiteboul", "P. Buneman", "D. Suciu"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2000}, {"title": "Object identity as a query language primitive", "author": ["S. Abiteboul", "P. Kanellakis"], "venue": "J. ACM 45(5),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1998}, {"title": "Procedural languages for database queries and updates", "author": ["S. Abiteboul", "V. Vianu"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1990}, {"title": "Datalog extensions for database queries and updates", "author": ["S. Abiteboul", "V. Vianu"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1991}, {"title": "STBenchmark: Towards a benchmark for mapping systems", "author": ["B. Alexe", "W.C. Tan", "Y. Velegrakis"], "venue": "PVLDB 1(1),", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2008}, {"title": "The language of plain SOtgds: Composition, inversion and structural properties", "author": ["M. Arenas", "J. P\u00e9rez", "J. Reutter", "C. Riveros"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "Value invention in data exchange", "author": ["P. Arocena", "B. Glavic", "R. Miller"], "venue": "Proceedings 2013 SIGMOD Conference,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Gain control over your integration evaluations", "author": ["P.C. Arocena", "R. Ciucanu", "B. Glavic", "R.J. Miller"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2015}, {"title": "The expressive power of complex values in object-based data models", "author": ["J. Van den Bussche", "J. Paredaens"], "venue": "Information and Computation", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1995}, {"title": "On the completeness of object-creating database transformation languages", "author": ["J. Van den Bussche", "D. Van Gucht", "M. Andries", "M. Gyssens"], "venue": "J. ACM 44(2),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1997}, {"title": "Structural characterizations of schema-mapping languages", "author": ["B. ten Cate", "P. Kolaitis"], "venue": "Commun. ACM 53(1),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Optimal implementation of conjunctive queries in relational data bases", "author": ["A. Chandra", "P. Merlin"], "venue": "Proceedings 9th ACM Symposium on the Theory of Computing,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1977}, {"title": "Equivalence of queries that are sensitive to multiplicities", "author": ["S. Cohen"], "venue": "The VLDB Journal", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "Containment of aggregate queries", "author": ["S. Cohen", "W. Nutt", "Y. Sagiv"], "venue": "Database Theory\u2014ICDT", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2003}, {"title": "Clio: Schema mapping creation and data exchange", "author": ["R. Fagin", "L. Haas", "R.M.M. Hern\u00e1ndez", "L. Popa", "Y. Velegrakis"], "venue": "Conceptual Modeling: Foundations and Applications, Lecture Notes in Computer Science,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2009}, {"title": "Towards a theory of schemamapping optimization", "author": ["R. Fagin", "P. Kolaitis", "A. Nash", "L. Popa"], "venue": "Proceedings 27th ACM Symposium on Principles of Database Systems, pp", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "Composing schema mappings: Secondorder dependencies to the rescue", "author": ["R. Fagin", "P. Kolaitis", "L. Popa"], "venue": "ACM Trans. Database Syst. 30(4),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2005}, {"title": "On the undecidability of the equivalence of second-order tuple generating dependencies", "author": ["I. Feinerer", "R. Pichler", "E. Sallinger", "V. Savenkov"], "venue": "Information Systems", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2015}, {"title": "Navigational plans for data integration", "author": ["M. Friedman", "A.Y. Levy", "T.D. Millstein"], "venue": "In: AAAI/IAAI, pp", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1999}, {"title": "The TSIMMIS approach to mediation: data models and languages", "author": ["H. Garcia-Molina", "Y. Papakonstantinou", "D. Quass", "A. Rajaraman", "Y. Sagiv", "J. Ullman", "V. Vassalos", "J. Widom"], "venue": "Journal of Intelligent Information Systems", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1997}, {"title": "ILOG: Declarative creation and manipulation of object identifiers", "author": ["R. Hull", "M. Yoshikawa"], "venue": "Proceedings of the 16th International Conference on Very Large Data Bases,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1990}, {"title": "On the equivalence of database restructurings involving object identifiers", "author": ["R. Hull", "M. Yoshikawa"], "venue": "Proceedings of the Tenth ACM Symposium on Principles of Database Systems,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1991}, {"title": "A logic for programming with complex objects", "author": ["M. Kifer", "J. Wu"], "venue": "J. Comput. Syst. Sci", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1993}, {"title": "Determining view dependencies using tableaux", "author": ["A. Klug", "R. Price"], "venue": "ACM Trans. Database Syst", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1982}, {"title": "Nested dependencies: Structure and reasoning", "author": ["P. Kolaitis", "R. Pichler", "E. Sallinger", "V. Savenkov"], "venue": "Proceedings 33rd ACM Symposium on Principles of Database Systems", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2014}, {"title": "Data integration: A theoretical perspective", "author": ["M. Lenzerini"], "venue": "Proceedings 21st ACM Symposium on Principles of Database Systems, pp", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2002}, {"title": "Querying heterogeneous information sources using source descriptions", "author": ["A.Y. Levy", "A. Rajaraman", "J.J. Ordille"], "venue": "Proceedings 22nd International Conference on Very Large Data Bases,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1996}, {"title": "A logic for objects", "author": ["D. Maier"], "venue": "Workshop on Foundations of Deductive Databases and Logic Programming,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1986}, {"title": "Object exchange across heterogeneous information sources", "author": ["Y. Papakonstantinou", "H. Garcia-Molina", "J. Widom"], "venue": "ICDE, pp", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1995}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "J. Data Semantics", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2008}, {"title": "On directly mapping relational databases to RDF and OWL", "author": ["J.F. Sequeda", "M. Arenas", "D.P. Miranker"], "venue": "In: International Conference on World Wide Web (WWW), pp", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2012}, {"title": "Information integration using logical views", "author": ["J.D. Ullman"], "venue": "Theor. Comput. Sci. 239(2),", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2000}], "referenceMentions": [{"referenceID": 2, "context": "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation", "startOffset": 59, "endOffset": 69}, {"referenceID": 3, "context": "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation", "startOffset": 59, "endOffset": 69}, {"referenceID": 9, "context": "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation", "startOffset": 59, "endOffset": 69}, {"referenceID": 1, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 8, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 20, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 22, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 27, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 0, "endOffset": 19}, {"referenceID": 19, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 38, "endOffset": 42}, {"referenceID": 0, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 73, "endOffset": 76}, {"referenceID": 6, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 96, "endOffset": 107}, {"referenceID": 14, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 96, "endOffset": 107}, {"referenceID": 16, "context": "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].", "startOffset": 96, "endOffset": 107}, {"referenceID": 20, "context": "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].", "startOffset": 101, "endOffset": 113}, {"referenceID": 22, "context": "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].", "startOffset": 101, "endOffset": 113}, {"referenceID": 27, "context": "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].", "startOffset": 101, "endOffset": 113}, {"referenceID": 1, "context": "Oid-equivalence has its origins in the theory of object-creating queries introduced by Abiteboul and Kanellakis [3]; it is the natural generalization of query equivalence in the presence of object creation.", "startOffset": 112, "endOffset": 115}, {"referenceID": 21, "context": "Hull and Yoshikawa [23] studied oid-equivalence (they called it \u2018obscured equivalence\u2019) for nonrecursive ILOG programs; the decidability of this problem is a long-standing open question.", "startOffset": 19, "endOffset": 23}, {"referenceID": 12, "context": "We give a new result relating oid-equivalence to equivalence of classical conjunctive queries under \u2018combined\u2019 bag-set semantics [14], which models the evaluation of CQs when query results and relations may contain duplicates of tuples.", "startOffset": 129, "endOffset": 133}, {"referenceID": 6, "context": "Object creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a", "startOffset": 80, "endOffset": 87}, {"referenceID": 16, "context": "Object creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a", "startOffset": 80, "endOffset": 87}, {"referenceID": 15, "context": "For standard CQs without object creation, two queries are equivalent if and only if they are logically equivalent as schema mappings [17].", "startOffset": 133, "endOffset": 137}, {"referenceID": 6, "context": "Sifo CQs viewed as schema mappings belong to the class of so-called \u2018nested dependencies\u2019 [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]).", "startOffset": 90, "endOffset": 93}, {"referenceID": 16, "context": "Sifo CQs viewed as schema mappings belong to the class of so-called \u2018nested dependencies\u2019 [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]).", "startOffset": 199, "endOffset": 203}, {"referenceID": 17, "context": "Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26].", "startOffset": 55, "endOffset": 59}, {"referenceID": 24, "context": "Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26].", "startOffset": 144, "endOffset": 148}, {"referenceID": 20, "context": "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].", "startOffset": 112, "endOffset": 116}, {"referenceID": 16, "context": "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].", "startOffset": 161, "endOffset": 165}, {"referenceID": 6, "context": "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].", "startOffset": 208, "endOffset": 211}, {"referenceID": 18, "context": "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.", "startOffset": 37, "endOffset": 49}, {"referenceID": 25, "context": "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.", "startOffset": 37, "endOffset": 49}, {"referenceID": 31, "context": "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.", "startOffset": 37, "endOffset": 49}, {"referenceID": 28, "context": "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.", "startOffset": 89, "endOffset": 97}, {"referenceID": 31, "context": "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.", "startOffset": 89, "endOffset": 97}, {"referenceID": 26, "context": "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.", "startOffset": 122, "endOffset": 126}, {"referenceID": 4, "context": "In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].", "startOffset": 238, "endOffset": 241}, {"referenceID": 7, "context": "In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].", "startOffset": 253, "endOffset": 256}, {"referenceID": 7, "context": "More precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.", "startOffset": 52, "endOffset": 55}, {"referenceID": 4, "context": "More precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.", "startOffset": 85, "endOffset": 88}, {"referenceID": 29, "context": "As such, sifo CQs can be seen as examples of mapping assertions from source schemas to a global ontology in OBDA [31].", "startOffset": 113, "endOffset": 117}, {"referenceID": 30, "context": "A related application is the direct translation of a relational schema into OWL, which uses as an important building block the creation of IRIs [32].", "startOffset": 144, "endOffset": 148}, {"referenceID": 20, "context": "In this section we introduce our formalism for dealing with conjunctive queries and introduce the notion of object-creating conjunctive query, adapted from the language ILOG [22].", "startOffset": 174, "endOffset": 178}, {"referenceID": 11, "context": "We can now recall the classical notion of conjunctive query (CQ) [2, 13].", "startOffset": 65, "endOffset": 72}, {"referenceID": 20, "context": "Object-creating CQs can be considered to be the conjunctive-query fragment of nonrecursive ILOG [22]; our syntax exposes the Skolem functions, which are normally obscured in the standard ILOG syntax, and our semantics corresponds to what is called the \u2018exposed semantics\u2019 by Hull and Yoshikawa.", "startOffset": 96, "endOffset": 100}, {"referenceID": 21, "context": "Nevertheless, in the following section, we will consider oid-equivalence of sifo CQs, which does correspond to what has been called \u2018obscured equivalence\u2019 [23].", "startOffset": 155, "endOffset": 159}, {"referenceID": 11, "context": "Let us briefly recall these notions now [13, 2].", "startOffset": 40, "endOffset": 47}, {"referenceID": 12, "context": "For our proof, we rely on work by Cohen [14] who studied queries with multiset variables that are evaluated under so-called combined semantics, a semantics that combines set and multiset semantics.", "startOffset": 40, "endOffset": 44}, {"referenceID": 12, "context": "Equivalence of MV queries can be characterized using the notion of multiset-homomorphism [14].", "startOffset": 89, "endOffset": 93}, {"referenceID": 12, "context": "15 ([14], Thm 5.", "startOffset": 4, "endOffset": 8}, {"referenceID": 5, "context": "More specifically, it is a plain SO-tgd [7].", "startOffset": 40, "endOffset": 43}, {"referenceID": 25, "context": "(This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.", "startOffset": 33, "endOffset": 41}, {"referenceID": 10, "context": "(This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.", "startOffset": 33, "endOffset": 41}, {"referenceID": 16, "context": "[18] call the chase of I with sotgd(Q).", "startOffset": 0, "endOffset": 4}, {"referenceID": 6, "context": "But actually, sifo CQs can also be considered as a restricted form of so-called nested tgds [8].", "startOffset": 92, "endOffset": 95}, {"referenceID": 24, "context": "The answer is affirmative; we have seen in the previous subsection that sifo CQ mappings belong to the class of nested dependencies, and logical implication of nested dependencies has recently been shown to be decidable [26].", "startOffset": 220, "endOffset": 224}, {"referenceID": 23, "context": "The logical implication of JDs by tableau queries is well understood and can be solved by the chase procedure with NP complexity [25, 2].", "startOffset": 129, "endOffset": 136}, {"referenceID": 13, "context": "The situation is similar to that in research on CQs with counting or bag semantics [15, 14].", "startOffset": 83, "endOffset": 91}, {"referenceID": 12, "context": "The situation is similar to that in research on CQs with counting or bag semantics [15, 14].", "startOffset": 83, "endOffset": 91}, {"referenceID": 20, "context": "Sifo CQs and ILOG In the introduction we mentioned that sifo CQs, and oCQs in general, are a fragment of ILOG without recursion [22].", "startOffset": 128, "endOffset": 132}, {"referenceID": 21, "context": "Sifo CQs belong to the subclass of the class of recursion-free ILOG programs \u201cwith isolated oid creation\u201d [23].", "startOffset": 106, "endOffset": 110}, {"referenceID": 21, "context": "Various interesting examples showing the intricacies of this problem have already been given by Hull and Yoshikawa [23].", "startOffset": 115, "endOffset": 119}, {"referenceID": 24, "context": "[26] in work done independently from the present paper.", "startOffset": 0, "endOffset": 4}], "year": 2016, "abstractText": "Conjunctive database queries have been extended with a mechanism for object creation to capture important applications such as data exchange, data integration, and ontology-based data access. Object creation generates new object identifiers in the result, that do not belong to the set of constants in the source database. The new object identifiers can be also seen as Skolem terms. Hence, object-creating conjunctive queries can also be regarded as restricted second-order tuple-generating dependencies (SO tgds), considered in the data exchange literature. In this paper, we focus on the class of single-function object-creating conjunctive queries, or sifo CQs for short. The single function symbol can be used only once in the head of the query. We give a new characterization for oid-equivalence of sifo CQs that is simpler than the one given by Hull and Yoshikawa and places the problem in the complexity class NP. Our characterization is based on Cohen\u2019s equivalence notions for conjunctive queries with multiplicities. We also solve the logical entailment problem for sifo CQs, showing that also this problem belongs to NP. Results by Pichler et al. have shown that logical equivalence for more general classes of SO tgds is either undecidable or decidable with as yet unknown complexity upper bounds.", "creator": "LaTeX with hyperref package"}}}