{"id": "1506.01864", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-Jun-2015", "title": "Grid-based angle-constrained path planning", "abstract": "square grids are commonly used everywhere in robotics and game development to precisely model specifically an ecosystem agent's environment, and well known in applications artificial intelligence whereas heuristic search algorithms ( a *, jps, theta * etc. ) are utilized publicly for grid path planning. almost a very lot of research centered in this respective area has been explicitly focused than so and far on naturally finding randomly the shortest running paths however while in many applications producing simpler smooth flexible paths is rarely preferable. in our work, we study the problem of confidently generating smooth group grid paths better and concentrate on angle steered constrained group path planning. we put angle shaped constrained path planning problem basically formally and even present a new algorithm procedure of consistently solving correctly it - lian. we examine lian both theoretically correctly and quite empirically. rely on practically the theoretical functional side, further we prove that lian improvement is often sound and almost complete ( under potentially well - defined restrictions ). but on essentially the experimental side,... we show evidence that locating lian significantly even outperforms competitors competitors in developing ability sets to correctly find solutions under tough resource constraints and reduces in computational efficiency.", "histories": [["v1", "Fri, 5 Jun 2015 11:09:23 GMT  (694kb)", "http://arxiv.org/abs/1506.01864v1", "13 pages (12 pages: main text, 1 page: references), 7 figures, 19 references, submitted 2015-May-20 to \"The 38 German Conference on Artificial Intelligence\" (KI-2015)"], ["v2", "Tue, 25 Aug 2015 15:59:28 GMT  (414kb)", "http://arxiv.org/abs/1506.01864v2", "13 pages (12 pages: main text, 1 page: references), 7 figures, 20 references, submitted 2015-June-22 to \"The 38 German Conference on Artificial Intelligence\" (KI-2015)"]], "COMMENTS": "13 pages (12 pages: main text, 1 page: references), 7 figures, 19 references, submitted 2015-May-20 to \"The 38 German Conference on Artificial Intelligence\" (KI-2015)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["konstantin yakovlev", "egor baskin", "ivan hramoin"], "accepted": false, "id": "1506.01864"}, "pdf": {"name": "1506.01864.pdf", "metadata": {"source": "CRF", "title": "Grid-based angle-constrained path planning", "authors": ["Konstantin Yakovlev", "Egor Baskin", "Ivan Hramoin"], "emails": ["hramoin}@isa.ru"], "sections": [{"heading": null, "text": "adfa, p. 1, 2011. \u00a9 Springer-Verlag Berlin Heidelberg 2011\nmodel an agent\u2019s environment, and well known in Artificial Intelligence heuristic search algorithms (A*, JPS, Theta* etc.) are utilized for grid path planning. A lot of research in this area has been focused so far on finding the shortest paths while in many applications producing smooth paths is preferable. In our work, we study the problem of generating smooth grid paths and concentrate on angle constrained path planning. We put angle constrained path planning problem formally and present a new algorithm of solving it \u2013 LIAN. We examine LIAN both theoretically and empirically. On the theoretical side, we prove that LIAN is sound and complete (under well-defined restrictions). On the experimental side, we show that LIAN significantly outperforms competitors in ability to find solutions under tough resource constraints and in computational efficiency.\nKeywords: path planning, path finding, heuristic search, grid, grid world, angle constrained path, A*, Theta*, LIAN"}, {"heading": "1 Introduction", "text": "Path planning is one of the key abilities needed for an intelligent agent (robot, unmanned vehicle, computer game character etc.) to autonomously operate in real or virtual worlds. Typically, in Artificial Intelligence, agent\u2019s environment is modeled with weighted graph which vertices correspond to positions (locations) the agent can occupy and edges correspond to trajectories the agent can traverse, e.g. line segments, curves of predefined shape and length, etc. Each edge is assigned a non-negative real number (weight, cost) by weighting function which is used to quantitatively express characteristics of the corresponding trajectory (such as length, potential risk of traversing, etc.). Thus to solve a path planning problem one needs a) to construct a graph (given the description of the environment) and b) to find a path (preferably \u2013 the shortest one) on this graph.\nAmong the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4]. The latter are the most widespread for several reasons. First, they appear naturally in many virtual environments (computer games are the most obvious example [5]), e.g. the agent\u2019s spatial world description is the grid itself. This means that no methods for converting this description to graph model are needed to be applied. Even in real world scenarios, say in robotics, it is the grids that are commonly used as spatial models [6].\nSecond, even if the environment is described in some other way it is likely that forming a grid out of this description will be less burdensome than constructing other abovementioned models due to grid\u2019s \u201cprimitive\u201d structure.\nAfter the graph is constructed the search for a path on it can be carried out by the well known Dijkstra\u2019s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few. Some of these algorithms are tailored to grid path finding (JPS, Theta*, HPA*), others are more universal and suitable for any graph models (with A* and Dijkstra being the most general ones). Many of them, in fact \u2013 almost all of them, overcome their predecessors in terms of computational efficiency (at least for a large class of tasks). Some algorithms are tailored to single-shot path planning while others demonstrate their supremacy on solving bunches of tasks. But only a few of them take the shape of the resultant path into account although it can be quite useful in many applications. For example, a wheeled robot or an unmanned aerial vehicle simply can not follow a path with sharp turns due to their dynamic constraints. The most common way to incorporate agent\u2019s dynamic constraints into path planning process is to extend the graph model \u2013 see [14] for example \u2013 but this leads to tremendous growth of the search space (which now contains not only the spatial information) and thus finding a path becomes burdensome and computationally ineffective. So it can be beneficial to stay within \u201cprimitive\u201d, spatial-only world model (e.g. grid based) but focus on searching the smooth paths, rather than the short ones, and thus indirectly guarantee the feasibility of that paths against agent\u2019s dynamic constraints.\nWe find the idea of generating smooth paths very appealing and in our work we address the following angle constrained path planning problem. Given a square grid the task is to find a path as a sequence of grid sections (ordered pairs of grid elements) such that an angle of alteration between each two consecutive sections is less or equal than some predefined threshold (formal definitions are given in section 2). We present a new heuristic search algorithm \u2013 LIAN (from \u201climited angle\u201d) \u2013 of solving it. We examine LIAN both theoretically, showing that it is sound and complete (under some constraints), and experimentally, testing LIAN\u2019s applicability for urban outdoor navigation scenarios.\nTo the best of our knowledge, no direct competitors to LIAN are present nowadays, although there exist one or more implicit analogues \u2013 grid path planning methods that can be attributed to as taking the shape of the path into account. For example A*-PS [10] runs A*-search on a grid and after it is finished performs a preprocessing step to eliminate intermediate path elements. Thus the resultant path starts looking more realistic (due to the fact that \u201cback and forth\u201d heading changes are skipped) and at the same time it becomes shorter. Theta* (or more precise \u2013 Basic Theta*) [12] uses the same idea \u2013 intermediate grid elements skipping \u2013 but it performs the smoothing procedure online, e.g. on each step of the algorithm. In [15] a modification of Basic Theta* (also applicable to A*-PS) algorithm is presented which uses special angle-based heuristic to focus the search in order to construct more straightforward paths to the goal. In [16] another modification of Basic Theta* \u2013 weighted angular rate constrained Theta* (wARC-Theta*) - is described. wARC-Theta* uses special techniques to take into account agent\u2019s angular rate (and other) constraints staying within grid model e.g. without\nextending the spatial model with agent\u2019s orientation (heading) information but rather performing additional calculations (related to agent\u2019 pose) online. wARC-Theta* with some minor adaptations can be used to solve the angle constrained path planning problem we are interested in. Unfortunately, the algorithm is incomplete, e.g. it fails to solve a wide range of path planning tasks although the solutions to these tasks do exist. With some modifications, explained further in the paper, the performance of wARC-Theta* can be improved and the number of successfully solved tasks can be increased. This improved version of wARC-Theta* is seen to be the only direct analogue of the proposed algorithm so we use it for comparative experimental study. Obtained results show that the newly proposed algorithm \u2013 LIAN \u2013 significantly outperforms wARC-Theta*: LIAN solves much more tasks and uses significantly less computational resources (processor time and memory).\nThe latter of the paper is organized as follows. In section 2 we express the angle constrained path planning problem formally. In section 3 the new algorithm of solving it \u2013 LIAN \u2013 is presented, as well as modified wARC-Theta* algorithm is described. In section 4 the results of the comparative experimental study are given."}, {"heading": "2 Angle constrained path planning problem on square grid", "text": "Two alternative types of square grid notations are widespread nowadays: center-based, when agent\u2019s locations are tied to the centers of grid cells, and corner-based, when agent\u2019s locations are tied to the corners, respectively (see figure 1).\nIn our work we adopt the center-based notation and consider a grid to be a finite set of cells A that can be represented as a matrix AMxN={aij}, where i, j \u2013 are cell position indexes (coordinates) and M, N \u2013 are grid dimensions. Each cell is labeled either traversable or un-traversable and the set of all traversable cells is denoted as A+. In case cell coordinates can be omitted, lower case Latin characters will be used: a, b, c etc.\nA line-of-sight function, los: A+A+ \u2192 {true, false}, is given and an agent is allowed to move from one traversable cell to the other if los returns true on them (or, saying in other words, if there exist a line-of-sight between them). In our work, as in many others, we use well-known in computer graphics Bresenham algorithm [17] to detect if lineof-sight between two cells exist or not. This algorithms draws a \u201cdiscrete line section\u201d (see figure 2) and if it contains only traversable cells than los is supposed to return true (otherwise los returns false).\nA metric function, dist: A+ \u2192 , is given to measure the distance between any two traversable cells. In our work we use Euclid distance, e.g dist(aij, alk)=\u221a(\ud835\udc59 \u2212 \ud835\udc56)2 + (\ud835\udc58 \u2212 \ud835\udc57)2 as metric function.\nAn ordered pair of distinct grid cells is a section: e=aij, alk, and it is traversable iff los(aij, alk)=true. The length of section aij, alk equals dist(aij, alk). Two sections that have exactly a middle cell in common, e.g. e1=aij, alk, e2=alk, avw, are called adjacent.\n\u0394-section is such section e=aij, alk that it\u2019s endpoint, alk, belongs to CIRCLE(aij, \u0394), where CIRCLE is the set of cells identified by the well-known in computer graphics Midpoint algorithm [18] (which is a modification of the abovementioned Brezenham\u2019s algorithm intended for drawing \u201cdiscrete circumferences\u201d) \u2013 see figure 2.\nA path between two distinct traversable cells s (start cell) and g (goal cell) is the sequence of traversable adjacent sections such that the first section starts with s and the last ends with g: (s, g)=={e1, \u2026, ev}, e1=s, a, ev=b, g. The length of the path len() is the sum of the lengths of the sections forming that path.\nGiven two adjacent sections e1=aij, alk, e2=alk, avw, an angle of alteration is the angle between the vectors \ud835\udc4e\ud835\udc56\ud835\udc57\ud835\udc4e\ud835\udc59\ud835\udc58\u20d7\u20d7 \u20d7\u20d7 \u20d7\u20d7 \u20d7\u20d7 \u20d7\u20d7  \u20d7 and \ud835\udc4e\ud835\udc59\ud835\udc58\ud835\udc4e\ud835\udc63\ud835\udc64\u20d7\u20d7 \u20d7\u20d7 \u20d7\u20d7 \u20d7\u20d7 \u20d7\u20d7 \u20d7\u20d7  \u20d7 , which coordinates are (l - i, k - j) and (v - l, w - k) respectively (see figure 2). This angle is denoted as \u03b1(e1, e2) and it\u2019s value is denoted as |\u03b1(e1, e2)|.\nGiven a path ={e1, \u2026, ev} we call the value \u03b1m()=\u03b1m=max{|\u03b1(e1, e2)|, |\u03b1(e2, e3)|,\n\u2026, |\u03b1(ev-1, ev)|} the path\u2019s maximum angle of alteration.\nNow we are interested in solving angle constrained path planning problem which is formulated as following. Given two distinct traversable cells s (start cell) and g (goal cell) and the value \u03b1m: 0<\u03b1m<180, find a path (s, g) such that \u03b1m()\u2264\u03b1m (angle constrained path).\nShortest angle constrained path is considered to be the optimal solution. For the reasons explained further in the paper, we are also interested in a special class of solutions of the problem, called \u0394-solutions. \u0394-solution is an angle constrained path each section of which, except maybe the last one, is the \u0394-section (the path depicted on the figure 2 is a \u0394-path, \u0394=5)."}, {"heading": "3 Algorithms for the angle constrained path planning", "text": ""}, {"heading": "3.1 wTheta*-LA", "text": "In [16] H. Kim et al. present a modification of Basic Theta* [12] algorithm tailored to solve grid path planning problem for an agent with angular rate constraints. Authors do not consider the maximum angle of alteration constraint \u2013 as described above \u2013 directly. Instead, they investigate the case when the speed and the turning radius of an agent are given and calculate angle constraints online, taking into account the length of the path sections involved. But if one replaces the original procedure of angle constraint calculation with the one which always returns \u03b1m, the algorithm becomes applicable to the angle constrained path problem we are interested in. We call such an algorithm Theta*LA (LA stands for \u201climited angle\u201d).\nTheta*-LA is a pretty straightforward modification of Theta*. The only difference is that when Theta* tries to connect a cell to it\u2019s grandparent (in order to skip the intermediate element, e.g. parent, from the path) it validates only the line-of-sight constraint (e.g. if line-of-sight exists between the cell and it\u2019s grandparent the former is being connected to the latter), while Theta*-LA validates also angle constraint, and if an angle between the sections defined by the trio: grandparent-parent-cell is greater than the predefined threshold \u03b1m, than parent cell is not eliminated from the sequence. This straightforward technique leads to the following problem: if the angle constraint is less than 45 (which is likely to be a common, realistic scenario) the algorithm fails to circumnavigate large obstacles and thus fails to find an angle constrained path - see figure 3 for detailed explanation.\nThe main reason Theta*-LA fails to find a path in many cases is that it doesn\u2019t store the intermediate path elements but rather tries to make path sections as long as possible. In the original work [16] H.Kim et. al give a hint how this problem can be partially solved but do not describe it in details \u2013 they suggest weighting the grid, e.g. assigning each grid cell a non-negative weight value and taking cells\u2019 weights into account while calculation the length of the section. Using weights to penalize the cells residing close to the obstacles in such way that Theta*-LA first prefers processing cells residing at some distance of the obstacles potentially leads to another grandparent-parent-cell sequences and improves the overall performance of the algorithm (see figure 3).\nWe have implemented the grid weighting procedure that makes cells lying close to the obstacles less attractive to the algorithm and call such an algorithm wTheta*-LA. We use the following strategy: given two parameters \u2013 radius r and max weighting penalty p \u2013 discrete circumferences of radius r with the centers in the cells a lying on the boundaries of the obstacles are constructed (by the referred in section 1 Midpoint algorithm). Than the rays connecting a and each cell forming the circumference are traced and each ray cell, say a', is assigned the weight as follows: w(a')=p\u2219(1 + (1 \u2013 dist(a, a'))/r). During the search, a modified length calculation formula is used, e.g. len(a, b)=dist(a, b)\u2219(1+avgW), where avgW \u2013 is the average weight of the cells lying on Bresenham line in between a and b.\nExperimental analysis (see section 4) shows that weighting can significantly improve algorithm\u2019s performance, but still vast variety of path planning tasks remains unsolved. One can suggest playing further with the weighting parameters values or modifying the weighting procedure itself, but we prefer to design a new algorithm that a) does not require any grid preprocessing at all and b) theoretically guarantees completeness (at least for a well defined class of tasks). Such an algorithm is described further."}, {"heading": "3.2 LIAN", "text": "LIAN (from \u201climited angle\u201d) is a new heuristic search algorithm tailored to solve angle constrained path planning problem on square grids. LIAN relies on A* [8] state-space search strategy, uses line-of-sight checks as Theta* [12] and exploits the idea of multiple parents as R* [11].\nAs well as A* our algorithm explores the grid cells and calculates so called g-values, where g-value of a cell a, g(a), is the length of the path (angle constrained path in our case) from start cell s to a found so far. Along with the g-value each cell is obligatory characterized by the parent pointer (like Theta* but unlike A* where parent pointers are commonly used but are not obligatory) \u2013 bp(a), which points to the grid cell which is a predecessor of a. Any grid cell can have multiple parents (this makes LIAN similar to R*). Thus when we are talking about the search space of LIAN we are talking about the space consisting of nodes which are the triples: cell, g-value, parent pointer (which actually points to the node, not the cell). Nodes will be denoted as [a], and [a]=[a, g([a]), bp([a])]. So, [a] is a node and a is a corresponding cell. bp([a]) is a node (e.g. bp([a])=[a']) and bp(a) is a corresponding cell (bp(a)=a').\nAs well as any other A*-like heuristic search algorithm LIAN maintains two lists of nodes: OPEN and CLOSED. OPEN is the collection of nodes \u2013 potential candidates for further processing and it initially contains the only element [s, 0, ]. CLOSED is the collection of nodes that have already been processed. On each step of the algorithm the node [a] with minimal f-value, f([a]),is retrieved from OPEN, where f([a])=g([a])+h(a), and h(a) is a heuristic estimate (e.g. dist(a, g)) of the path length from a to the goal cell (exactly as in A*). Then the set of potential successors of [a] is formed: SUCC([a])=SUCC. In A* SUCC is comprised out of the cells which are adjacent to a. In LIAN potential successors correspond to the cells residing at the fixed distance \u2206 (which is the input parameter of the algorithm) from a. To identify such cells Midpoint algorithm (referred above) is used: a discrete circumference of radius \u2206 (see to figure 1) is drawn and the cells forming this circumference are added to SUCC. If the distance from a to the goal cell is less than \u2206, then the node, corresponding the goal cell is also added to SUCC. To distinguish between the potential successor nodes and the corresponding cells we will use the records [succi] and succi respectively.\nAfter the set of potential successors is constructed it\u2019s pruning is done. First nodes corresponding to un-traversable cells are eliminated. Second, the nodes that violate line-of-sight constraint are pruned. Third, the nodes that correspond to the cells that violate maximum angle of alteration constraints are discarded, e.g. the nodes [succi] that correspond to such cells succi: |\u03b1(bp(a), a, a, succi)|>\u03b1m (NB: if the start node is processed the angle constraints are ignored). Forth, the cells that have been visited before are pruned, e.g. if the CLOSED list contains a node with the same cell and parent pointer then such potential successor is discarded.\nAfter fixing the SUCC set, g-values of the successors are calculated: g([succi])=g([a])+d(a, succi) and corresponding nodes are added to OPEN. [a] is added to CLOSED.\nAlgorithm\u2019s stop criterion is the same as used in A*: LIAN stops when a node corresponding to the goal cell is retrieved from OPEN (in that case the path can be reconstructed using goal node\u2019s parent pointers). If the OPEN list becomes empty during the search algorithm reports failure to found a path.\nThe proposed algorithm has the following properties.\nProperty 1. LIAN always terminates. Sketch of proof. Algorithm is performing the search until the OPEN list is empty (or until the goal node is retrieved from it). OPEN contains only elements that refer to the grid cells the total number of which is finite. The number of potential parents of the cell is also finite. At the same time when a new node is generated LIAN checks whether this node (the node defined by the same cell and the same parent) has been processed before already (lines 24-26). And in case the answer is \u2018yes\u2019 it is pruned and not added to OPEN. Thus, the total number of elements potentially addable to OPEN is finite. Given the fact that on each step of the algorithm exactly one element is removed from OPEN (line 6) one can infer that sooner or later this list will contain no elements, or the goal node will be retrieved. In both cases (lines 4, 7) algorithm terminates.\nProperty 2. If only \u0394-solutions are under investigation then LIAN is sound and complete, e.g. if \u0394-solution to the angle constrained path planning task exists, LIAN finds it, if no \u0394-solution exists, LIAN reports failure. Sketch of proof. LIAN\u2019s parameter \u0394 well defines the set of potential successors for a cell being processed as the set of cells residing at the \u0394-distance. All the (traversable) cells from that set that satisfy the maximum alteration angle constraint are being added to OPEN (except those that have been examined before). Thus, sooner or later all paths compromised of the sections being \u0394-sections (except, maybe, the last section \u2013 lines 16-17) will be constructed and evaluated against angle deviation constraints and the sought path, if it exist, will be found. By construction this path is a \u0394-solution of the given task. If LIAN reports failure it means that all the potential paths \u2013 candidates for the \u0394-solution have been examined (otherwise OPEN list still contains some elements and LIAN continues the search), which in turn means no \u0394-solution exists.\nProperty 3. If different \u0394-solutions to the angle constrained path planning task exist LIAN returns the shortest one. Sketch of proof. LIAN uses the same OPEN prioritization strategy as A* which guarantees finding the shortest path if the admissible heuristic is used. LIAN uses Euclidian distance function dist, which is obviously admissible (and consistent as well) heuristic. Thus LIAN returns the shortest \u0394-solution possible.\nWe would like to notice further that just like A* LIAN allows heuristic weighting, e.g. calculating f-values using the following formula f([a])=g([a])+w\u2219h(a), where w>1. Weighting the heuristic commonly makes it inadmissible thus the optimality of the solution can not be guaranteed any more. But at the same time, it\u2019s known that in many\npractical applications, grid path planning inclusively, heuristic weighting radically improves algorithm\u2019s performance while the quality of the solution decreases insignificantly."}, {"heading": "3.3 D-LIAN", "text": "LIAN algorithm as described above guarantees it\u2019s soundness and completeness only in respect to it\u2019s input parameter \u2013 \u0394. Thus, in general there exist a possibility that some valid solutions can be missed in case \u0394 is initialized \u201cin a wrong way\u201d. Necessity to initialize LIAN with fixed \u0394 also leads to another obvious problem: which exact value to choose? In cluttered spaces setting \u0394 too high will likely make LIAN report failure because line-of-sight constraints will be continuingly violated resulting in exhausting of OPEN list (there simply will be no candidates to fill it up). At the same time setting \u0394 too low leads to the reduction of potential successors for any cell being processed (obviously \u2013 the lower the value \u0394 is the less cells form the discrete circumference of radius \u0394 which defines the SUCC) and thus OPEN list is likely to exhaust again.\nTo address abovementioned problems and make LIAN behavior more flexible and adaptable we suggest dynamically change \u0394 while performing the search. The modification of LIAN that uses this technique will be referred to as D-LIAN.\nD-LIAN works exactly the same as LIAN except the following case. If all the potential successors (of some node under investigation \u2013 [a]), that satisfy maximum angle of alteration constraint, are un-traversable then \u0394 is half-decreased and the search for the successors is repeated. If, again, no valid successors are found, \u0394 is half-decreased once again, and this continues up to the moment value of \u0394 reaches some predefined threshold \u0394min (or some valid successor(s) is generated). If the threshold is reached and still not a single valid successor is generated D-LIAN exits the Expand() procedure (and no nodes are added to OPEN). If, at some point of time, when \u0394=\u0394i, valid successors are generated, \u0394i is remembered and then the search from [a] continues using that exact value of \u0394 (we will refer to it as to \u0394([a])). If next n successive elaborations of [a] are all characterized by successful generation of successors then \u0394([a]) is half increased. The upper limit on \u0394 value, e.g. \u0394max, is also set by the user.\nThus while performing the search D-LIAN dynamically adjusts \u0394 in order to generate as many successors of each node as it is needed to solve the task. One of the features of D-LIAN is that multiple \u0394 are potentially used during the search. Technically this is achieved by storage of \u0394-value referenced to a node. Thus D-LIAN node becomes a quadruple: [a, g([a]), bp([a]), \u0394([a])]. Input parameters of D-LIAN are: \u0394init \u2013 initial value of \u0394, \u0394min \u2013 the lower threshold, \u0394max \u2013 the upper threshold, n \u2013 the number of steps after which \u0394 is half-increased (if the increase is valid). In the experiments we use the following bindings: n=2, \u0394min=\u0394init/2, \u0394max=\u0394init."}, {"heading": "4 Experimental analysis", "text": "The experimental setup for the comparative study of the algorithms considered in the paper \u2013 LIAN, D-LIAN, Theta*-LA, wTheta*-LA \u2013 was the Windows7-operated PC, iCore2 quad 2.5GHz, 2Gb RAM. All the algorithms were coded in C++ using the same data structures and programming techniques.\nUrban outdoor navigation scenario was targeted and path finding for small un-\nmanned aerial vehicle (UAV) performing nap-of-the-earth flight was addressed.\nEach grid involved in the tests was constructed using OpenStreetMaps (OSM) data [19]: a 1347m x 1347m fragment of actual city environment was retrieved from OSM and discretized to a 501 x 501 grid (so one cell refers to 2,7m x 2,7m area). Cells corresponding to the areas occupied by buildings were marked un-traversable. Five different start-goal locations were chosen for each environment fragment residing more than 1350m one from the other (so dist(start, goal)\u2265500). In total, the testbed consisted of 405 various path planning tasks (81 grids, 5 start-goal locations per grid). Targeted angle constraints were: 20, 25 and 30. These figures were advised by the peers involved in UAV controllers design (using these angle constraints indirectly guarantees the feasibility of the path for a particular model of the UAV).\nThe following indicators were used to compare the algorithms: sm \u2013 success maps \u2013 number of the successfully accomplished angle constrained\npath planning tasks;\nsr \u2013 success rate \u2013 the same as above but measured as ratio: sm/n, where n is the\ntotal number of tasks (e.g. 400);\nt \u2013 time (in seconds) \u2013 time needed for the algorithm to produce solution; m \u2013 memory (in nodes) \u2013 number of elements stored in OPENCLOSED (the\nmemory consumption of the algorithm);\npl \u2013 path length (in meters) \u2013 the length of the resulting angle-constrained path.\nPreliminary tests had been conducted to roughly assess the algorithms\u2019 performance. The following observations were made. First, LIAN in some cases (under some parameterizations while solving some tasks) terminates minutes after it has been invoked. So a 60-seconds time limit was suggested for further testing, e.g. if any algorithm did not terminate within 60 seconds the result of the test was considered to be failure. Second, using weighted heuristic radically improves LIAN\u2019s computational performance while path length reduces insignificantly (around 1-2%). So in further tests LIAN was run with the heuristic weight equal to 2. Third, \u201cthe best\u201d parameters for wTheta*-LA (p=0.1, r=12) were identified and these parameters were used further on.\nThe main series of tests involved the following algorithms: 4 instances of LIAN, each using it\u2019s own \u0394: 3, 5, 10, 20, referred, further as LIAN-3, LIAN-5, LIAN-10, LIAN-20; Theta*-LA and wTheta*-LA. Thus, 6*3*405=7290 experiments in total were conducted. Obtained results are shown on figure 5.\nFigures shown in the table (except sm and sr indicators) are the averaged values with failures not considered while averaging. Namely, for each algorithm t, m, pl values were averaged taking into account only it\u2019s respective sm positive results.\nAs one can see Theta*-LA is totally inapplicable to angle-constrained path planning (when angle constraint is set to 20-30), as in this it fails to solve two thirds (or more) of tasks. Weighting a grid, e.g. using wTheta*-LA, significantly (up to several times) improves the performance. But still, wTheta*-LA successfully handles only 14%-55%- 73% of the tasks (for angle constraints 20, 25, 30 respectively), while the worst LIAN result, e.g. the result of LIAN-20 is 66%-72%-79% respectively. So, one can say, that in general even the \u201cworst\u201d LIAN is 1,5 times better (in terms of the number of successfully handled tasks) than \u201cthe best\u201d wTheta*-LA.\nWorth mentioning are the results of LIAN-3. While it solves 99% of tasks when angle limit is 30, in case the latter is 20-25 only one third of tasks is solved. It indirectly confirms the hypothesis (see section 3.3) that lower values of \u0394 should be avoided in general. Setting \u0394 too high \u2013 20 in our case \u2013 also degrades the algorithm performance.\nIf we now take a closer look at the results of best LIAN instances, e.g LIAN-5 and LIAN-10, and compare them to the best results achieved by limited angle Theta*, e.g. to wTheta*-LA results, and use normalization, we\u2019ll get the following picture \u2013 see figure 6.\nAs one can see LIAN-5 and LIAN-10 both significantly (up to 5-10 times) outperform wTheta*-LA in terms of time and memory usage. At the same time, path produces by them are only 1% longer that wTheta*-LA paths.\nWhen the best algorithms of LIAN\u2019s family, e.g. LIAN-5 and LIAN-10, were identified we conducted another experiment, tailored to answer the following question \u2013 can their performance be further improved by using dynamic \u0394 adjustment technique as described in section 3.3? So we repeated the tests but now only LIAN-5, LIAN-10 and their dynamic modifications D-LIAN-5, D-LIAN-10 were used (the latter were parameterized as it was suggested in section 3.3). The results are shown in figure 7.\nAs one can see dynamic adjustment of \u0394 increases the chances of finding a solution. It also decreases running time and memory usage in some cases (for example, when \u0394=10, dynamic adjustment reduces the memory consumption on notable 10-15%). So D-LIAN proves to be a worthwhile modification of LIAN.\nSumming up all the results one can claim that LIAN (especially with dynamic \u0394 adjustment, and initial \u0394 values set to 5 or 10) is an effective algorithm of solving angle constrained path planning problems on square grids and it significantly outperforms it\u2019s direct competitors, e.g. wTheta*-LA, in terms of computational efficiency and the ability to accomplish path finding tasks (at least when the urban outdoor navigation scenarios are under consideration)."}, {"heading": "5 Conclusions and future work", "text": "In this work we have investigated the angle constrained path planning problem for square grids and presented a new parameterized algorithm \u2013 LIAN (and it\u2019s variation D-LIAN) \u2013 for solving it. We have proved that LIAN is sound and complete (with the respect to it\u2019s input parameter \u2013 \u0394). We have studied LIAN experimentally in various modeled outdoor navigation scenarios and showed that it significantly outperforms existing analogues: it solves more angle constrained path planning tasks than the competitors while using less memory and processing time.\nIn future we intend to develop more advanced techniques of dynamic \u0394 adjustment, aimed at further improvement of LIAN performance. Another appealing direction of research is evaluating LIAN in real environments, e.g. implementing LIAN as part of the intelligent control system that automates navigation of a mobile robot or unmanned aerial vehicle in real world.\nAcknowledgements. This work was partially supported by RFBR, research project No. 15-07-07483."}], "references": [{"title": "An algorithm for planning collision-free paths among polyhedral obstacles", "author": ["T. Lozano-P\u00e9rez", "M.A. Wesley"], "venue": "Communications of the ACM,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1979}, {"title": "Roadmap-based path planning-Using the Voronoi diagram for a clearance-based shortest path", "author": ["P. Bhattacharya", "M.L. Gavrilova"], "venue": "Robotics & Automation Magazine,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2008}, {"title": "Navigation queries from triangular meshes", "author": ["M. Kallmann"], "venue": "In Motion in Games (pp", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2010}, {"title": "Grid-based path-finding", "author": ["P. Yap"], "venue": "Proceedings of 15th Conference of the Canadian Society for Computational Studies of Intelligence,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2002}, {"title": "Benchmarks for grid-based pathfinding", "author": ["N.R. Sturtevant"], "venue": "Computational Intelligence and AI in Games, IEEE Transactions on,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "Using occupancy grids for mobile robot perception and navigation", "author": ["A. Elfes"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1989}, {"title": "A note on two problems in connexion with graphs", "author": ["E.W. Dijkstra"], "venue": "Numerische mathematik,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1959}, {"title": "A formal basis for the heuristic determination of minimum cost paths", "author": ["P.E. Hart", "N.J. Nilsson", "B. Raphael"], "venue": "IEEE Transactions on Systems Science and Cybernetics,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1968}, {"title": "ARA*: Anytime A* with Provable Bounds on Sub-Optimality, Advances in Neural Information Processing Systems 16 (NIPS)", "author": ["M. Likhachev", "G. Gordon", "S. Thrun"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "Near optimal hierarchical path finding", "author": ["A. Botea", "M. Muller", "J. Schaeffer"], "venue": "Journal of game development,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2004}, {"title": "Any-Angle Path Planning on Grids", "author": ["A. Nash", "K. Daniel", "S. Koenig", "Felner", "A. 2007. Theta"], "venue": "In Proceedings of the National Conference on Artificial Intelligence", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1177}, {"title": "Online graph pruning for pathfinding on grid maps", "author": ["D. Harabor", "A. Grastien"], "venue": null, "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2011}, {"title": "Real-time motion planning with applications to autonomous urban driving", "author": ["Y. Kuwata", "S. Karaman", "J. Teo", "E. Frazzoli", "J.P. How", "G. Fiore"], "venue": "Control Systems Technology, IEEE Transactions on,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "Improving efficiency in any-angle path-planning algorithms", "author": ["P. Munoz", "M. Rodriguez-Moreno"], "venue": "In Intelligent Systems (IS),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "Angular rate-constrained path planning algorithm for unmanned surface vehicles", "author": ["H. Kim", "D. Kim", "J.U. Shin", "H. Myung"], "venue": "Ocean Engineering,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2014}, {"title": "Algorithm for computer control of a digital plotter", "author": ["J.E. Bresenham"], "venue": "IBM Systems journal,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1965}, {"title": "Algorithms of conic generation", "author": ["M.L.V. Pitteway"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1985}], "referenceMentions": [{"referenceID": 0, "context": "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].", "startOffset": 96, "endOffset": 99}, {"referenceID": 1, "context": "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].", "startOffset": 118, "endOffset": 121}, {"referenceID": 2, "context": "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].", "startOffset": 141, "endOffset": 144}, {"referenceID": 3, "context": "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].", "startOffset": 160, "endOffset": 163}, {"referenceID": 4, "context": "First, they appear naturally in many virtual environments (computer games are the most obvious example [5]), e.", "startOffset": 103, "endOffset": 106}, {"referenceID": 5, "context": "Even in real world scenarios, say in robotics, it is the grids that are commonly used as spatial models [6].", "startOffset": 104, "endOffset": 107}, {"referenceID": 6, "context": "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra\u2019s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.", "startOffset": 117, "endOffset": 120}, {"referenceID": 7, "context": "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra\u2019s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.", "startOffset": 137, "endOffset": 140}, {"referenceID": 8, "context": "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra\u2019s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.", "startOffset": 226, "endOffset": 229}, {"referenceID": 9, "context": "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra\u2019s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.", "startOffset": 236, "endOffset": 240}, {"referenceID": 10, "context": "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra\u2019s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.", "startOffset": 258, "endOffset": 262}, {"referenceID": 11, "context": "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra\u2019s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.", "startOffset": 268, "endOffset": 272}, {"referenceID": 12, "context": "The most common way to incorporate agent\u2019s dynamic constraints into path planning process is to extend the graph model \u2013 see [14] for example \u2013 but this leads to tremendous growth of the search space (which now contains not only the spatial information) and thus finding a path becomes burdensome and computationally ineffective.", "startOffset": 125, "endOffset": 129}, {"referenceID": 9, "context": "For example A*-PS [10] runs A*-search on a grid and after it is finished performs a preprocessing step to eliminate intermediate path elements.", "startOffset": 18, "endOffset": 22}, {"referenceID": 10, "context": "Theta* (or more precise \u2013 Basic Theta*) [12] uses the same idea \u2013 intermediate grid elements skipping \u2013 but it performs the smoothing procedure online, e.", "startOffset": 40, "endOffset": 44}, {"referenceID": 13, "context": "In [15] a modification of Basic Theta* (also applicable to A*-PS) algorithm is presented which uses special angle-based heuristic to focus the search in order to construct more straightforward paths to the goal.", "startOffset": 3, "endOffset": 7}, {"referenceID": 14, "context": "In [16] another modification of Basic Theta* \u2013 weighted angular rate constrained Theta* (wARC-Theta*) - is described.", "startOffset": 3, "endOffset": 7}, {"referenceID": 15, "context": "In our work, as in many others, we use well-known in computer graphics Bresenham algorithm [17] to detect if lineof-sight between two cells exist or not.", "startOffset": 91, "endOffset": 95}, {"referenceID": 16, "context": "\u0394-section is such section e=\uf0e1aij, alk\uf0f1 that it\u2019s endpoint, alk, belongs to CIRCLE(aij, \u0394), where CIRCLE is the set of cells identified by the well-known in computer graphics Midpoint algorithm [18] (which is a modification of the abovementioned Brezenham\u2019s algorithm intended for drawing \u201cdiscrete circumferences\u201d) \u2013 see figure 2.", "startOffset": 193, "endOffset": 197}, {"referenceID": 14, "context": "In [16] H.", "startOffset": 3, "endOffset": 7}, {"referenceID": 10, "context": "present a modification of Basic Theta* [12] algorithm tailored to solve grid path planning problem for an agent with angular rate constraints.", "startOffset": 39, "endOffset": 43}, {"referenceID": 14, "context": "In the original work [16] H.", "startOffset": 21, "endOffset": 25}, {"referenceID": 7, "context": "LIAN relies on A* [8] state-space search strategy, uses line-of-sight checks as Theta* [12] and exploits the idea of multiple parents as R* [11].", "startOffset": 18, "endOffset": 21}, {"referenceID": 10, "context": "LIAN relies on A* [8] state-space search strategy, uses line-of-sight checks as Theta* [12] and exploits the idea of multiple parents as R* [11].", "startOffset": 87, "endOffset": 91}], "year": 2015, "abstractText": "Square grids are commonly used in robotics and game development to model an agent\u2019s environment, and well known in Artificial Intelligence heuristic search algorithms (A*, JPS, Theta* etc.) are utilized for grid path planning. A lot of research in this area has been focused so far on finding the shortest paths while in many applications producing smooth paths is preferable. In our work, we study the problem of generating smooth grid paths and concentrate on angle constrained path planning. We put angle constrained path planning problem formally and present a new algorithm of solving it \u2013 LIAN. We examine LIAN both theoretically and empirically. On the theoretical side, we prove that LIAN is sound and complete (under well-defined restrictions). On the experimental side, we show that LIAN significantly outperforms competitors in ability to find solutions under tough resource constraints and in computational efficiency.", "creator": "Microsoft\u00ae Word 2013"}}}