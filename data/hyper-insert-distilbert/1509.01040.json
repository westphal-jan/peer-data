{"id": "1509.01040", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Sep-2015", "title": "Building a Truly Distributed Constraint Solver with JADE", "abstract": "designing real life problems such as scheduling meeting programs between people at totally different software locations involved can be roughly modelled classified as distributed functional constraint decision satisfaction capability problems ( csps ). suitable and satisfactory solutions both can then directly be found using constraint satisfaction algorithms which so can be exhaustive ( backtracking ) if or otherwise ( parallel local search ). however, most research in this area tested their corresponding algorithms globally by simulation on establishing a single pc hardware with a single running program entry point. the main contribution of sr our work is the integrated design and knowledge implementation of understanding a truly distributed multiple constraint solver paradigm based on a generalized local search machine algorithm using java agent development framework ( jade ) to enable smooth communication situations between agents on different machines. speaking particularly, \u2022 we discuss underlying design parameters and implementation readiness issues related to truly distributed constraint solver knowledge which moreover might not be critical issues when simulated operation on a typical single machine. distributed evaluation results heavily indicate claims that introducing our truly distributed compute constraint solver that works well within the observed criteria limitations accumulated when tested with various distributed csps. our application can nonetheless also incorporate any total constraint solution solving machine algorithm undertaken with thus little modifications.", "histories": [["v1", "Thu, 3 Sep 2015 11:41:45 GMT  (565kb)", "http://arxiv.org/abs/1509.01040v1", "7 pages"]], "COMMENTS": "7 pages", "reviews": [], "SUBJECTS": "cs.AI cs.DC", "authors": ["ibrahim adeyanju"], "accepted": false, "id": "1509.01040"}, "pdf": {"name": "1509.01040.pdf", "metadata": {"source": "META", "title": "Building a Truly Distributed Constraint Solver with JADE", "authors": ["Ibrahim Adeyanju"], "emails": [], "sections": [{"heading": null, "text": "people at different locations can be modelled as distributed Constraint Satisfaction Problems (CSPs). Suitable and satisfactory solutions can then be found using constraint satisfaction algorithms which can be exhaustive (backtracking) or otherwise (local search). However, most research in this area tested their algorithms by simulation on a single PC with a single program entry point. The main contribution of our work is the design and implementation of a truly distributed constraint solver based on a local search algorithm using Java Agent DEvelopment framework (JADE) to enable communication between agents on different machines. Particularly, we discuss design and implementation issues related to truly distributed constraint solver which might not be critical when simulated on a single machine. Evaluation results indicate that our truly distributed constraint solver works well within the observed limitations when tested with various distributed CSPs. Our application can also incorporate any constraint solving algorithm with little modifications.\nGeneral Terms Algorithms, Agent-Oriented systems\nKeywords Constraint Satisfaction, JADE, DisPeL, Multi-agent systems."}, {"heading": "1. INTRODUCTION", "text": "Human beings in their daily activities have to make individual or collective decisions which are restricted by one or more conditions. Such real life activities can be modelled as Constraint Satisfaction problems (CSPs) and algorithms developed to give suitable solutions. A CSP comprises of a finite set of decision variables, each with a set of alternatives it can adopt and a set of constraints [1]. CSPs are solved when all the constraints between decision variables are satisfied by choices made from their domain. A distributed CSP is one in which variables and constraints are distributed among multiple agents in collaboration [2]. In such a scenario, group objectives are clearly defined but individual objectives introduce additional complexity on negotiating solutions.\nThis paper discusses the design and implementation of a truly distributed constraint solver using a local search algorithm on several machines. Real life applications of distributed constraint solvers include dynamic distributed resource allocation [3] which arises in problems such as distributed sensor networks, disaster rescue and hospital scheduling. Another application is building schedulers such as Distributed Meeting Scheduler and Railway Traffic regulation[4].\nThe rest of this paper is as follows. Section 2 provides a critical appraisal of related work while Section 3 discusses the local search algorithm used in our work. We present details of the Java Agent DEvelopment framework (JADE) in Section 4 followed by the design and implementation of our application\nin Section 5. Evaluation of our application is discussed in Section 6 while Section 7 concludes our work with a summary and plans for future work."}, {"heading": "2. RELATED WORK", "text": "Two broad categories of techniques used in solving Constraint Satisfaction Problems (CSP), centralised or distributed, are Exhaustive Search and Local Search. Exhaustive Search also known as Systematic Backtracking involves starting with a partial solution that is carefully chosen and incrementally searching through all the possible combination of different values of the variables until a complete solution that satisfies all constraints is found. Exhaustive search algorithms are guaranteed to find one or more solutions if they exist or could determine if no solution exists at all. Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].\nLocal search involves starting with a partial solution through random assignment of values to variables involved in a CSP. An improvement in the random solution is then sought through successive iterations by exploring different points in the search space until a valid solution is found or the maximum time allowed has elapsed. Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.\nDistribution of CSPs across multiple machines, rather than simulation on a single machine, requires the development of a distributed system. Several technologies exist for building such distributed systems. These include Remote Procedure Calls (RPC) [16,17], .NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.\nIn our work, we used Java Agent DEvelopment Framework (JADE) [26,27], an open source platform for peer-to-peer agent applications. We chose JADE because it is open-source and used more widely to build multi-agent systems."}, {"heading": "3. CONSTRAINT SOLVER", "text": "Our distributed constraint solver application is built using a local search algorithm called Distributed Penalty-driven Local search (DisPeL) [15] as its underlying constraint solver. DisPeL is a local search algorithm for solving distributed CSPs, where each agent controls just one variable, by finding the first solution that satisfies all constraints simultaneously. Collaborating agents take turns in a fixed ordering to improve a random initialization. Gradual sequential improvements are found iteratively rather than the best possible improvement as in conventional hill-climbing algorithms. This causes a reduction in communication costs since all improvements are accepted and the information used in making decisions is always coherent [15].\nDisPeL\u201fs core strategy is in its use of two types of penalties (temporary and incremental) in resolving deadlocks (local optima) by modifying the underlying cost landscape. Deadlocks occur when the solution to a CSP cannot be improved further by agents although no suitable solution has been obtained. Penalties are used to locally perturb the solution thereby forcing the agents to try other combination of values through exploration of other areas in the search space. Temporary penalties are removed immediately after use while incremental penalties are only reset when current value of an agent does not violate any of its constraints. We use the stochastic version of DisPeL where the decision on whether to use temporary or incremental penalties is done randomly.\nPenalties are used collaboratively. When an agent detects a deadlock and has to use a penalty, it implements the penalty on its current value and requests all neighbours with a lower ordering priority (for incremental penalty) or those neighbours with a lower ordering priority and violate constraints with self (for temporary penalty) to implement the same penalty on their current value assignments. It is also assumed that all constraints are uni-directed; therefore each agent in DisPeL will locally evaluate all constraints attached to its variable. Hence, each agent will communicate in a synchronised manner with all other agents that are co-constrained with it exchanging value assignments and requests to impose penalties [15]."}, {"heading": "4. JADE FRAMEWORK", "text": "Distributed constraint solvers are multi-agent systems since they attempt to find suitable solutions to CSPs whose agents are distributed across several locations. Agent-oriented applications combine artificial intelligence with distributed system techniques by modelling components as agents. Each agent is autonomous, proactive, and has the ability to communicate with other agents to achieve personal and communal goals [26]. Such applications have a peer to peer architectural model where any agent is able to send or receive communication from any other agent within the application. Open source middleware which provide domain-independent infrastructure can facilitate communication in multi-agent systems thereby allowing application developers to focus on production of the business logic.\nJava Agent DEvelopment framework (JADE) is a completely distributed middleware system with a flexible infrastructure that allows easy extension [6]. The framework facilitates development of complete agent-oriented applications by means of a run-time environment implementing the life-cycle support features required by agents and the core logic of agents themselves among other tools. JADE is a software platform written in Java that provides basic middleware-layer functionalities which are independent of the specific application and which simplify the realization of distributed applications that exploit the software agent abstraction [26]. Each agent in JADE complies with the FIPA (Foundation for Intelligent Physical Agents) specifications and therefore has such basic qualities as autonomy, pro-activeness, responsiveness, and social ability with secondary qualities like mobility, adaptability and rationality. Any multi-agent system based on JADE is loosely coupled, peer-to-peer and message communication between agents are asynchronous. Each agent has its own thread of execution using this to control its life cycle and decide autonomously to perform specific tasks."}, {"heading": "4.1 JADE Architecture", "text": "A JADE platform consists of a runtime environment (also called containers) that can be distributed over the network and provides all the services needed for hosting and executing agents. A special container, called the main container must always be active in a platform and all other normal containers register with it as soon as they start and must therefore know the main container\u201fs host address and port. A diagram showing the typical architecture of the JADE platform is shown in Figure 1. Starting another main container elsewhere in the network constitutes a different platform to which new normal containers can possibly register. The main container manages the container table (CT), which is the registry of object references and transport addresses of all container nodes in the platform; manages the global agent descriptor table GADT), which is the registry of all agents present in the platform, including their current status and location; and hosts the AMS (Agent Management Service) and DF (Directory Facilitator), the two special agents that provide the agent management service and the default yellow page service of the platform respectively. The DF is not used in our work since the number of agents involved in solving the distributed constraint problem does not change throughout the solution finding process.\nBecause agent communication is peer-to-peer, each agent maintains a local agent descriptor table (LADT) which it searches first when communicating with any other agent and only involves the main container\u201fs GADT if the agent\u201fs address is not on its LADT and caches it locally for future use. Agents in JADE are identified by a globally unique name called an Agent Identifier (AID) consisting basically of the agent\u201fs local name and its addresses (usually inherited from the platform) [26]. Each agent can communicate transparently regardless of their actual location: same container (e.g. A2 & A3 in Figure 1), different containers in the same platform (A1 & A2) or different platforms (A4 & A5) provided they know each other\u201fs agent identifier [6]."}, {"heading": "4.2 Message Transport Service", "text": "JADE includes a Message Transport Service (MTS) that manages all message exchange within and between platforms. All standard Message Transport Protocols (MTPs) defined by FIPA are implemented by this service to promote interoperability between different non-JADE platforms. Each MTP includes the definition of a transport protocol and a standard encoding of the message envelope. HTTP-based MTP are always started by default with the initialization of a main container while no MTP is activated on normal containers. This creates a server socket on the main container host and listens for incoming connections over HTTP at the URL specified. Whenever an incoming connection is established and a valid message is received over that connection, the MTP routes the message to its final destination which, in general, is one of the agents located within the distributed platform [26]. The platform uses a proprietary transport protocol called IMTP (Internal Message Transport Protocol) internally to perform message routing for both incoming and outgoing messages using a single-hop routing table that requires direct visibility among containers. IMTP is also used to transport internal commands needed to manage the distributed platform as well as monitor the status of remote containers. The two main implementations of IMTP available are Java RMI which is the default option and a proprietary protocol using TCP sockets that circumvents the absence of Java RMI in the J2ME environments. The default Java RMI implementation was used throughout the development of our distributed constraint solver."}, {"heading": "4.3 Agent Tasks - Behaviour scheduling", "text": "An agent in JADE carries out its tasks within program elements called \u201cbehaviours\u201d. A behaviour represents a task that an agent can carry out. An agent can execute several behaviours concurrently although the scheduling of behaviours in an agent is not pre-emptive but cooperative. This means that when a behaviour is scheduled for execution its action() method is called and runs until it returns. Therefore it is the programmer who defines when an agent switches from the execution of a behaviour to the execution of the next one. When there are no behaviours available for execution the agent\u201fs thread goes to sleep in order not to consume CPU time and is woken up as soon as there is a behaviour again available for execution [27]."}, {"heading": "4.4 Agent Communication", "text": "The communication paradigm adopted in JADE is the asynchronous message passing [26]. Each agent has a message queue where the JADE runtime posts messages sent by other agents; whenever a message is posted in the message queue, the receiving agent is notified. The programmer however determines if and when the agent actually picks up the message from the queue to process it. This process is shown in Figure 2. The format of messages in JADE is compliant with FIPA-ACL message structure specifications and has fields such as the sender, list of receivers, communicative act (REQUEST, INFORM, PROPOSE etc), content, content language and ontology."}, {"heading": "5. DESIGN & IMPLEMENTATION", "text": "The design of our truly distributed constraint solver application is discussed under two sections via the User Interface (Section 5.1) and the underlying Distributed Constraint Solver (Section 5.2). The user interface is that part of the application that interacts with the user by allowing the user to input values and displays the final result of the computation. The underlying distributed constraint solver\ndeals with the structure of the algorithm and how it was integrated into the JADE platform that was used to allow for true distribution of the agents on different machines in solving constraint satisfaction problems."}, {"heading": "5.1 Graphical User Interface (GUI)", "text": "The graphical user interface would allow a user to input some values for an agent involved in the DisCSP before it is active and starts communicating with other agents in order to solve the problem. The results are shown on a dialog box. The graphical user interface for the distributed constraint solver is shown in Figure 3. This user interface can be used only once by a single agent involved in solving a DisCSP in collaboration with other agents; the application must be restarted in order to solve any other DisCSP. The application can only be exited using the \u201cExit Application\u201d button or the \u201cExit Application\u201d menu item under the \u201cFile\u201d menu which shows a confirmation dialog before exiting. An error dialog box is popped up if any of the input fields contain an invalid value and the information on the dialog gives a hint as to the possible cause of the error.\nThe \u201cStart Agent\u201d button is used to activate an agent involved in solving a DisCSP in collaboration with other active agents on the same main container though they might be on different machines. The agent would only be started if all input fields are found to be correct from all validation checks done. This button is disabled afterwards to ensure that another agent cannot be started using this application instance. The \u201cClear All Inputs\u201d button is used to clear all inputs entered before the agent is started and is also disabled once the agent is started as no input adjustments are allowed afterwards.\nThe \u201cStart Main Container on this Host\u201d button is used to start the main container on the same host as the agent and must be used before any normal agent is started. The menu item is disabled if the main container is started successfully or an agent is started on the same host. Care must be taken to click this button on just one of the machines that are involved in solving a DisCSP because there would be no communication between the agents if each agent host starts its own main container. The \u201cExit Application\u201d button exits the application displaying a confirmation dialog box and the program only exits if no active agent is using the interface; in other words, no agent is started yet or a DisCSP has been solved (partially or fully) and agent\u201fs communication with others is complete.\nThe \u201cHelp\u201d menu contains a single menu item (\u201cAbout\u201d) which pops up information about the author, the version and copyright notices. Basic instructions to guide the user to enter correct and valid inputs values are shown on the upper section of the interface. This ensures that the user reads them first\nbefore entering values in the input boxes provided in the lower section of the user interface. The Agent\u2019s variable name is assumed to be same as the agent\u201fs name since each agent has only one variable. Validation checks are also done to ensure that this input field is not blank before the agent is started. The Agent\u2019s domain value field takes the domain values for this agent\u201fs variable which must be separated by comma. We restricted valid domain value type for this application to Integers. The Maximum Iterations input field takes an Integer value that indicates the cycle after which the agent would stop communicating with neighbouring agents in the DisCSP if a solution has not been found.\nThe Constraint Expressions field allows the user to input the constraints between the agent and other agents in form of mathematical expressions. Our application accepts only comparison (>, <, !=, =, >=, <=) constraints expression to between just two variables i.e. the agent and any another agent. Each constraint expression starts with the agent\u201fs variable name followed by the operator, then the other agent\u201fs variable name. Each constraint expression must as well be separated by a comma if the agent has constraints with more than one agent.\nThe Farthest Agent Distance field accepts an Integer value that is used for termination detection by ensuring that all agents in the DisCSP have obtained solutions to their local problems. The value gives an estimate of the number of agents in between the two farthest agents in the DisCSP that do not have direct constraints together but are indirectly connected through other agents. The Address of Main\nContainer field takes a string value that indicates the address (usually HTTP address, fully qualified with computer name and domain name) where the main container that routes messages between JADE agents is located. The main container must be started first before other agents can join the JADE platform when trying to solve a DisCSP. The loop-back address of the host (\u201elocalhost\u201f) could be used if the agent is starting on the same machine as the main container."}, {"heading": "5.2 Constraint solving technique", "text": "The Distributed Constraint Solver (DCS) underlying our GUI discussed in Section 5.1 is based on the Distributed Penaltydriven Local search (DisPeL) [15] algorithm. Here, we discuss the implementation of a DisPeL DCS with JADE to ensure true distribution of the agents on different machines. It should be emphasized that all versions of DisPeL were previously simulated on single machines by the original author and our implementation of a true DCS is novel. Real distribution of DisCSPs leads to other important research problems. The problems we encountered while implementing a DisPeL DCS on several machines are in next Sub-Sections."}, {"heading": "5.2.1 Ownership of the DisCSP", "text": "When DisPeL algorithm was simulated to solve DisCSPs on a single machine; all the constraint expressions were either randomly generated [15] or entered through the same GUI [29]. It was relatively easy to identify constraint expressions for each variable. However, to run DisPeL on several machines, we have to address the problem of who initialises the DisCSP and sorts out all the constraint expressions. Ideally, each agent involved in the solving a DisCSP should\nonly know about other agents that it has constraints with but the algorithm solves the problem based on the fact that the whole DisCSP is known from the beginning before starting the process towards finding a suitable solution and that the DisCSP is static (unchanged) throughout until a solution is found or the maximum iterations allowed is reached. Some important features of the DisPeL algorithm such as ordering all variable names lexicographically or using the Distributed Agent Ordering scheme is based on this fact and might be difficult to circumvent. We address this problem by ensuring that each agent only knows about the agents it is constrained with and its local CSP are entered manually from the agent\u201fs GUI. Each agent also has an estimate of the size of the whole DisCSP from farthest agent distance entered on its GUI. We also assumed that all agents involved in the DisCSP are started near simultaneously to ensure that the problem is complete before the process towards finding a solution starts."}, {"heading": "5.2.2 Constraints and global constants validation", "text": "Also closely related to the problem of DisCSP ownership is the validation of constraint expressions and global constants like the maximum number of iterations. This does not pose a problem when the constraint solver is implemented on a single machine with single interface for taking all inputs. For instance, if agent A and B have constraints \u201cA>B\u201d between them, it must be ensured that the same equivalent expression (\u201cA>B\u201d on agent A\u201fs interface and \u201cB<A\u201d on agent B) is typed on their interfaces to avoid conflicts. Global constants like the \u201cmaximum number of iterations\u201d should also be identical for all agents as used in the original algorithm. To address this problem, we validate equivalent expressions across constrained agents by passing the constraint operators with other messages that were communicated between agents. Conflicting constraints are then ignored in the process of finding a solution to the DisCSP. We did not think having the same values of the \u201cmaximum number of iterations\u201d was critical to finding a solution to our kind of DisCSPs since this could mean stopping all agents if any of them has a different value from any other one. Therefore, we did not validate the \u201cmaximum number of iterations\u201d input across agents."}, {"heading": "5.2.3 Termination Detection", "text": "The constraint solving process has to be terminated when all of the agents obtain solutions to their constraints. Such termination detection is relatively easy when all agents are implemented on a single machine and have a single application entry since each agent can be checked to have obtained a solution before the application is terminated. The termination detection is more complex when agents are situated on different machines with multiple application entries. We address this problem as suggested by original author of our constraint algorithm [15] by using the same method as Distributed Breakout Algorithm [13]."}, {"heading": "5.2.4 Unreliable network communication", "text": "Since the agents involved in the DisCSP could be located on different machines connected through a computer network (local network preferably), the issues of communication delays, network congestion, packet corruption and time-outs are also paramount. There would be no cause to consider this issue when all the agents are on the same machine. We used the remedy suggested by the author of our constraint solver [15] where agents are allowed to resume activity if messages have not been received after a reasonable amount of time. Agents in such situation assume that their neighbours\u201f values are unchanged."}, {"heading": "6. EVALUATION", "text": "We tested extensively our truly distributed constraint solver application with sample DisCSPs. Test cases were designed based on the functional requirements of our application. Seven DisCSPs having up to a maximum of four agents were formulated for this purpose. The formulated DisCSPs are shown in Table 1. The diameter of agent network was taken as the farthest agent distance parameter used in termination detection. This can be obtained by drawing the agent tree for a DisCSP and counting the number of agents from the top to the bottom of agent tree as illustrated in Figure 4.\nWe observe from Table 1 that all the tested DisCSPs gave correct outputs with the only one not solved showing the interim results when the maximum iteration was reached. There is sometimes a variation in the number of iterations reached across constrained agents when a final solution was obtained because of the asynchronous nature of the JADE. A screenshot from one of the agent\u201fs GUI during our evaluation for test case 7 is shown in Figures 5."}, {"heading": "7. CONCLUSION", "text": "This paper discussed our work on the development of a truly Distributed Constraint Solver application based on a local search algorithm (DisPeL) on different machines. The JADE framework class libraries were used to implement a multiagent system that enables the true distribution of CSPs.\nWe intend to extend our application to allow each agent have multiple variables in addition to being truly distributed on several machines. The type of constraint expressions handled by our software will also be extended to allow Comparison, Boolean and Arithmetic operations between more than two variables. Variables other than Integers like Double, String and other objects like Date that would be more useful in real life applications will also be considered in future version of our application. Finally, we would consider distributing the agents in our constraint solver over a wide area network other than a local network."}, {"heading": "8. ACKNOWLEDGEMENTS", "text": "The author is grateful to Dr. Hatem Ahriz of The Robert\nGordon University, Aberdeen for his very useful feedback."}, {"heading": "9. REFERENCES", "text": "[1] Dechter R. Constraint Processing. San Francisco, CA:\nMorgan Kaufmann; 2003.\n[2] Makoto Y, Edmund H D, Toru I, Kazuhiro K. The Distributed Constraint Satisfaction Problem:\nFormalization and Algorithms. IEEE TKDE. 1998; 10(5): 673-685.\n[3] Pragnesh J M, Hyuckchul J, Milind T, Wei-Min S, Shriniwas K. Dynamic Distributed Resource Allocation:\nA Distributed Constraint Satisfaction Approach. In Proceedings of CP\u201f01. Springer, London; 2001: 685-700.\n[4] Lamma E, Mello P, Milano M. A distributed constraintbased scheduler. Artificial Intelligence in Engineering.\n1997; 11(1): 91-105.\n[5] Dechter R, Enhancement schemes for constraint processing: Backjumping, learning, cutset\ndecomposition. Artificial Intelligence. 1990; 41(3): 273- 312.\n[6] Chen X, van Beek P. Conflict-Directed Backjumping Revisited. JAIR. 2001; 14: 53-81.\n[7] Makoto Yokoo. Asynchronous Weak-commitment Search for Solving Distributed Constraint Satisfaction Problems.\nIn Proceedings of CP\u201f95. Springer, London; 1995:88- 102.\n[8] Meisels A, Zivan R. Asynchronous Forward-checking for DisCSPs. Constraints. 2007; 12(1): 131-150.\n[9] Ioannidis Y E, Wong E. Query optimization by simulated annealing. In Proceedings of the international conference\non Management of data. ACM, NY; 1987: 9-22.\n[10] Wong D F. On simulated annealing in EDA. In Proceedings of the International Symposium on Physical\nDesign. ACM, NY; 2012: 63-64.\n[11] Morris P. The breakout method for escaping from local minima. In: Proceedings of the National Conference on\nArtificial Intelligence. 1993: 40-45.\n[12] Glover F, Laguna M. Tabu Search. Kluwer Academic Publishers, Norwell, MA, USA; 1997.\n[13] Hirayama K, Yokoo M. The distributed breakout algorithms. Artificial Intelligence. 2005; 161(1): 89-115.\n[14] Zhang W, Wittenburg L. Distributed breakout revisited. In Proceedings of the national conference on Artificial\nintelligence. 2002: 352-357.Basharu M B. Modifying Landscapes with Penalties in Iterative Improvements for Solving Distributed Constraints Satisfaction Problems.\n[PhD Thesis]. Aberdeen: Robert Gordon University; 2006.\n[15] Birrell A D, Nelson B J. Implementing remote procedure calls. ACM Transaction on Computer Systems. 1984;\n2(1): 39-59.\n[16] Gomes-Soares P. On remote procedure call. In Proceedings of the conference of the Centre for\nAdvanced Studies on Collaborative research. IBM Press. 1992; 2: 215-267.\n[17] Don W. Browning. .Net Remoting. Manning Publications Co., Greenwich, CT, USA; 2002.\n[18] Ingo Rammer. Advanced .Net Remoting. Apress, Berkely, CA, USA; 2002.\n[19] Maassen J, Van-Nieuwpoort R, Veldema R, Bal H, Kielmann T, Jacobs C, Hofman R. Efficient Java RMI for\nparallel programming. ACM Transaction on Programming Languages and Systems. 2001; 23(6): 747- 775.\n[20] Waldo J. Remote Procedure Calls and Java RMI. IEEE Concurrency. 1998; 6(3): 5-7.\n[21] Bethea W L. Adding parametric polymorphism to the common object request broker architecture (CORBA). In\nAddendum to the proceedings of OOPSLA '00. ACM, NY; 2000: 119-120.\n[22] Felber P.; Guerraoui R. Programming with object groups in CORBA. IEEE Concurrency. 2000; 8(1): 48-58.\n[23] Albuquerque R L, Hubner J F, de Paula G, Sichman J S, Ramalho G. KSACI: A Handheld Device Infrastructure\nfor Agents Communication. In Proceedings of the International Workshop on Intelligent Agents. Springer, London; 2001: 423-435.\n[24] Labrou Y, Finin T, Peng Y. Agent Communication Languages: The Current Landscape. IEEE Intelligent\nSystems. 1999; 14(2): 45-52\n[25] Bellifemine F, Caire G, Greenwood D. Developing multiagent systems with JADE. Chichester: John Wiley &\nSons; 2007.\n[26] Bellifemine, F, Rimassa, G, Poggi, A. JADE - A FIPA compliant Agent Framework. In Proceedings of the\nInternational Conference and Exhibition on the Practical Application of Intelligent Agents and Multi-Agents. London, 1999.\n[27] Caire G. JADE Tutorial- Jade Programming for Beginners. Torino, Italy: Telecom Italia Laboratory\n(TILAB); 2003. Available from: http://jade.tilab.com/\n[28] Lee D. SIDCOT: A Smart Interface for Constraint Programming. [Unpublished BSc. Thesis]. Aberdeen:\nRobert Gordon University; 2006"}], "references": [{"title": "The Distributed Constraint Satisfaction Problem: Formalization and Algorithms", "author": ["Y Makoto", "D Edmund H", "I Toru", "K. Kazuhiro"], "venue": "IEEE TKDE", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1998}, {"title": "Dynamic Distributed Resource Allocation: A Distributed Constraint Satisfaction Approach", "author": ["M Pragnesh J", "J Hyuckchul", "T Milind", "S Wei-Min", "K. Shriniwas"], "venue": "In Proceedings of CP\u201f01. Springer,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "A distributed constraintbased scheduler", "author": ["E Lamma", "P Mello", "M. Milano"], "venue": "Artificial Intelligence in Engineering", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1997}, {"title": "Enhancement schemes for constraint processing: Backjumping, learning, cutset decomposition", "author": ["R Dechter"], "venue": "Artificial Intelligence", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1990}, {"title": "Conflict-Directed Backjumping Revisited. JAIR", "author": ["X Chen", "P. van Beek"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2001}, {"title": "Asynchronous Weak-commitment Search for Solving Distributed Constraint Satisfaction Problems", "author": ["Makoto Yokoo"], "venue": "In Proceedings of CP\u201f95", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1995}, {"title": "Asynchronous Forward-checking for DisCSPs", "author": ["A Meisels", "R. Zivan"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2007}, {"title": "Query optimization by simulated annealing", "author": ["E Ioannidis Y", "E. Wong"], "venue": "In Proceedings of the international conference on Management of data. ACM,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1987}, {"title": "On simulated annealing in EDA", "author": ["F. Wong D"], "venue": "In Proceedings of the International Symposium on Physical Design. ACM,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "The breakout method for escaping from local minima", "author": ["P. Morris"], "venue": "Proceedings of the National Conference on Artificial Intelligence", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1993}, {"title": "The distributed breakout algorithms", "author": ["K Hirayama", "M. Yokoo"], "venue": "Artificial Intelligence", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2005}, {"title": "Distributed breakout revisited", "author": ["W Zhang", "L. Wittenburg"], "venue": "In Proceedings of the national conference on Artificial intelligence", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2002}, {"title": "Implementing remote procedure calls", "author": ["D Birrell A", "J. Nelson B"], "venue": "ACM Transaction on Computer Systems", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1984}, {"title": "On remote procedure call", "author": ["P. Gomes-Soares"], "venue": "In Proceedings of the conference of the Centre for Advanced Studies on Collaborative research. IBM Press", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1992}, {"title": "Net Remoting", "author": ["Don W. Browning"], "venue": "Manning Publications Co., Greenwich, CT,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2002}, {"title": "Advanced .Net Remoting", "author": ["Ingo Rammer"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2002}, {"title": "Efficient Java RMI for parallel programming", "author": ["J Maassen", "R Van-Nieuwpoort", "R Veldema", "H Bal", "T Kielmann", "C Jacobs", "R. Hofman"], "venue": "ACM Transaction on Programming Languages and Systems", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2001}, {"title": "Remote Procedure Calls and Java RMI", "author": ["J. Waldo"], "venue": "IEEE Concurrency", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1998}, {"title": "Adding parametric polymorphism to the common object request broker architecture (CORBA)", "author": ["L. Bethea W"], "venue": "In Addendum to the proceedings of OOPSLA '00. ACM,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2000}, {"title": "Programming with object groups in CORBA", "author": ["P. Felber", "R. Guerraoui"], "venue": "IEEE Concurrency", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2000}, {"title": "KSACI: A Handheld Device Infrastructure for Agents Communication", "author": ["L Albuquerque R", "F Hubner J", "G de Paula", "S Sichman J", "G. Ramalho"], "venue": "In Proceedings of the International Workshop on Intelligent Agents. Springer,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2001}, {"title": "Agent Communication Languages: The Current Landscape", "author": ["Y Labrou", "T Finin", "Y. Peng"], "venue": "IEEE Intelligent Systems", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1999}, {"title": "Developing multiagent systems with JADE", "author": ["F Bellifemine", "G Caire", "D. Greenwood"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2007}, {"title": "JADE - A FIPA compliant Agent Framework", "author": ["F Bellifemine", "G Rimassa", "A. Poggi"], "venue": "In Proceedings of the International Conference and Exhibition on the Practical Application of Intelligent Agents and Multi-Agents. London,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1999}, {"title": "JADE Tutorial- Jade Programming for Beginners", "author": ["G. Caire"], "venue": "Torino, Italy: Telecom Italia Laboratory (TILAB);", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2003}, {"title": "SIDCOT: A Smart Interface for Constraint Programming. [Unpublished BSc", "author": ["D. Lee"], "venue": "Thesis]. Aberdeen: Robert Gordon University;", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2006}], "referenceMentions": [{"referenceID": 0, "context": "A distributed CSP is one in which variables and constraints are distributed among multiple agents in collaboration [2].", "startOffset": 115, "endOffset": 118}, {"referenceID": 1, "context": "Real life applications of distributed constraint solvers include dynamic distributed resource allocation [3] which arises in problems such as distributed sensor networks, disaster rescue and hospital scheduling.", "startOffset": 105, "endOffset": 108}, {"referenceID": 2, "context": "Another application is building schedulers such as Distributed Meeting Scheduler and Railway Traffic regulation[4].", "startOffset": 111, "endOffset": 114}, {"referenceID": 3, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 61, "endOffset": 66}, {"referenceID": 4, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 61, "endOffset": 66}, {"referenceID": 5, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 104, "endOffset": 107}, {"referenceID": 6, "context": "Current backtracking algorithms include Back-jumping schemes [5,6], Asynchronous Weak Commitment search [7] and Asynchronous Forward Checking [8].", "startOffset": 142, "endOffset": 145}, {"referenceID": 7, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 20, "endOffset": 26}, {"referenceID": 8, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 20, "endOffset": 26}, {"referenceID": 9, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 47, "endOffset": 51}, {"referenceID": 10, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 102, "endOffset": 109}, {"referenceID": 11, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 102, "endOffset": 109}, {"referenceID": 12, "context": "Simulated Annealing [9,10], Breakout Algorithm [11], Tabu Search [12], Distributed Breakout Algorithm [13,14] and Distributed Penalty-driven Local search algorithm [15] are examples of existing local search algorithm for constraint solving.", "startOffset": 164, "endOffset": 168}, {"referenceID": 13, "context": "These include Remote Procedure Calls (RPC) [16,17], .", "startOffset": 43, "endOffset": 50}, {"referenceID": 14, "context": "These include Remote Procedure Calls (RPC) [16,17], .", "startOffset": 43, "endOffset": 50}, {"referenceID": 15, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 13, "endOffset": 20}, {"referenceID": 16, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 13, "endOffset": 20}, {"referenceID": 17, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 53, "endOffset": 60}, {"referenceID": 18, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 53, "endOffset": 60}, {"referenceID": 19, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 112, "endOffset": 119}, {"referenceID": 20, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 112, "endOffset": 119}, {"referenceID": 21, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 173, "endOffset": 180}, {"referenceID": 22, "context": "NET Remoting [18,19], Remote Method Invocation (RMI) [20,21], Common Object Request Broker Architecture (CORBA) [22,23] and Simple Agent Communication Infrastructure (SACI) [24,25] among others.", "startOffset": 173, "endOffset": 180}, {"referenceID": 23, "context": "In our work, we used Java Agent DEvelopment Framework (JADE) [26,27], an open source platform for peer-to-peer agent applications.", "startOffset": 61, "endOffset": 68}, {"referenceID": 24, "context": "In our work, we used Java Agent DEvelopment Framework (JADE) [26,27], an open source platform for peer-to-peer agent applications.", "startOffset": 61, "endOffset": 68}, {"referenceID": 12, "context": "CONSTRAINT SOLVER Our distributed constraint solver application is built using a local search algorithm called Distributed Penalty-driven Local search (DisPeL) [15] as its underlying constraint solver.", "startOffset": 160, "endOffset": 164}, {"referenceID": 12, "context": "This causes a reduction in communication costs since all improvements are accepted and the information used in making decisions is always coherent [15].", "startOffset": 147, "endOffset": 151}, {"referenceID": 12, "context": "Hence, each agent will communicate in a synchronised manner with all other agents that are co-constrained with it exchanging value assignments and requests to impose penalties [15].", "startOffset": 176, "endOffset": 180}, {"referenceID": 23, "context": "Each agent is autonomous, proactive, and has the ability to communicate with other agents to achieve personal and communal goals [26].", "startOffset": 129, "endOffset": 133}, {"referenceID": 4, "context": "Java Agent DEvelopment framework (JADE) is a completely distributed middleware system with a flexible infrastructure that allows easy extension [6].", "startOffset": 144, "endOffset": 147}, {"referenceID": 23, "context": "JADE is a software platform written in Java that provides basic middleware-layer functionalities which are independent of the specific application and which simplify the realization of distributed applications that exploit the software agent abstraction [26].", "startOffset": 254, "endOffset": 258}, {"referenceID": 24, "context": "Relationship between Containers and platforms on the JADE architecture [27]", "startOffset": 71, "endOffset": 75}, {"referenceID": 23, "context": "Agents in JADE are identified by a globally unique name called an Agent Identifier (AID) consisting basically of the agent\u201fs local name and its addresses (usually inherited from the platform) [26].", "startOffset": 192, "endOffset": 196}, {"referenceID": 4, "context": "A2 & A3 in Figure 1), different containers in the same platform (A1 & A2) or different platforms (A4 & A5) provided they know each other\u201fs agent identifier [6].", "startOffset": 156, "endOffset": 159}, {"referenceID": 23, "context": "Whenever an incoming connection is established and a valid message is received over that connection, the MTP routes the message to its final destination which, in general, is one of the agents located within the distributed platform [26].", "startOffset": 233, "endOffset": 237}, {"referenceID": 24, "context": "When there are no behaviours available for execution the agent\u201fs thread goes to sleep in order not to consume CPU time and is woken up as soon as there is a behaviour again available for execution [27].", "startOffset": 197, "endOffset": 201}, {"referenceID": 23, "context": "4 Agent Communication The communication paradigm adopted in JADE is the asynchronous message passing [26].", "startOffset": 101, "endOffset": 105}, {"referenceID": 12, "context": "1 is based on the Distributed Penaltydriven Local search (DisPeL) [15] algorithm.", "startOffset": 66, "endOffset": 70}, {"referenceID": 12, "context": "1 Ownership of the DisCSP When DisPeL algorithm was simulated to solve DisCSPs on a single machine; all the constraint expressions were either randomly generated [15] or entered through the same GUI [29].", "startOffset": 162, "endOffset": 166}, {"referenceID": 12, "context": "We address this problem as suggested by original author of our constraint algorithm [15] by using the same method as Distributed Breakout Algorithm [13].", "startOffset": 84, "endOffset": 88}, {"referenceID": 10, "context": "We address this problem as suggested by original author of our constraint algorithm [15] by using the same method as Distributed Breakout Algorithm [13].", "startOffset": 148, "endOffset": 152}, {"referenceID": 12, "context": "We used the remedy suggested by the author of our constraint solver [15] where agents are allowed to resume activity if messages have not been received after a reasonable amount of time.", "startOffset": 68, "endOffset": 72}], "year": 2012, "abstractText": "Real life problems such as scheduling meeting between people at different locations can be modelled as distributed Constraint Satisfaction Problems (CSPs). Suitable and satisfactory solutions can then be found using constraint satisfaction algorithms which can be exhaustive (backtracking) or otherwise (local search). However, most research in this area tested their algorithms by simulation on a single PC with a single program entry point. The main contribution of our work is the design and implementation of a truly distributed constraint solver based on a local search algorithm using Java Agent DEvelopment framework (JADE) to enable communication between agents on different machines. Particularly, we discuss design and implementation issues related to truly distributed constraint solver which might not be critical when simulated on a single machine. Evaluation results indicate that our truly distributed constraint solver works well within the observed limitations when tested with various distributed CSPs. Our application can also incorporate any constraint solving algorithm with little modifications. General Terms Algorithms, Agent-Oriented systems", "creator": "Microsoft\u00ae Office Word 2007"}}}