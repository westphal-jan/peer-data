{"id": "1512.03899", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Dec-2015", "title": "Query Answering over Contextualized RDF/OWL Knowledge with Forall-Existential Bridge Rules: Decidable Finite Extension Classes (Post Print)", "abstract": "the extended proliferation relevance of numerous contextualized knowledge maps in covering the particular semantic fast web ( w sw ) areas has led to slowly the tremendous popularity of knowledge formats such products as \\ emph { quads } arrays in all the sw community. a learning quad is an extension of locating an updated rdf triple with descriptive contextual coding information inside of the triple. in this paper, there we progressively study the problem of query distance answering routing over inaccessible quads primarily augmented with forall - existential mathematical bridge rules that enable automatic interoperability of reasoning between multiple triples in various contexts. we increasingly call routing a wide set entirely of quads clustered together with such expressive logical bridge rules, a defined quad - system. query resolution answering query over specified quad - systems modules is undecidable, albeit in thinking general. we derive the decidable narrow classes of quad - systems, for which particular query for answering tests can be done using forward chaining. sound, whereas complete and accessible terminating procedures, which follow are arbitrary adaptations of namely the well so known chase algorithm, are therefore provided explicitly for these classes for deciding query search entailment. safe, msafe, and csafe \\ class of quad - searching systems restrict include the structure dynamics of recognizable blank nodes properly generated during the chase computation computed process intended to be directed acyclic graphs ( alternatively dags ) of bounded linear depth. existing rr and geographically restricted rr classes do yet not automatically allow the generation only of identifiable blank nodes during the resulting chase backup computation process. both data and possibly combined complexity of query entailment has been traditionally established mainly for the mir classes variously derived. \u2026 we further authors show that quad - systems problems are generally equivalent to forall - spanning existential rules for whose predicates also are restricted to ternary arity, modulo polynomial and time generated translations. although we subsequently show that considering the rr technique because of language safety, strictly algebra subsumes in the expressivity, some variation of the earlier well known relational and expressive techniques, such as joint secure acyclicity graph and model for faithful conditional acyclicity, used for decidability guarantees requirements in defining the realm class of forall - existential rules.", "histories": [["v1", "Sat, 12 Dec 2015 09:56:38 GMT  (314kb)", "http://arxiv.org/abs/1512.03899v1", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.LO", "authors": ["mathew joseph", "gabriel kuper", "till mossakowski", "luciano serafini"], "accepted": false, "id": "1512.03899"}, "pdf": {"name": "1512.03899.pdf", "metadata": {"source": "CRF", "title": "Query Answering over Contextualized RDF/OWL Knowledge with Forall-Existential Bridge Rules: Decidable Finite Extension Classes (Post Print)", "authors": ["Mathew Joseph", "Gabriel Kuper", "Till Mossakowski", "Luciano Serafini"], "emails": ["kuper}@disi.unitn.it,", "serafini@fbk.eu,", "mossakow@iws.cs.uni-magdeburg.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n51 2.\n03 89\n9v 1\n[ cs\n.D B\nKeywords: Contextualized Query Answering, Contextualized RDF/OWL knowledge bases, Multi-Context Systems, Quads, Query answering, forall-existential rules, Knowledge Representation, Semantic Web"}, {"heading": "1 Introduction", "text": "As the Semantic Web (SW) is getting more and more ubiquitous and its constellation of interlinked ontologies, the web of data, is seamlessly proliferating at a steady rate,\nmore and more applications have started using SW as a back end, providing their users manifold services, leveraging semantic technologies. One of the main reasons why SW enjoys such admirable hospitality from its mammoth geographically disparate users is its \u201csimple\u201d and \u201copen\u201d model. The model is simple, as the only intricacy that a creator/consumer of a SW application needs to be equipped with is that of a (RDF) triple. A triple t = (s, p, o) represents the most basic piece of knowledge in the SW, where s, called the subject, is an identifier for a person, place, thing, value, or a resource in general, about which the creator of t intended to express his/her knowledge using t. p, called the predicate, is an identifier for a property, attribute, or in general a binary relation that relates s with the component o, called the object, that is also an identifier for a resource similar to s. The model is called open, as it allows anybody, anywhere around the world to freely create their RDF/OWL ontologies about a domain of their choice, and publish them in (embedded) RDF/OWL formats in their web portals, also linking via URIs to the concepts in other similarly published ontologies. Thus the open model, in order to promote reuse and freedom, imposes no arbitration mechanism for the ontologies users publish on the SW.\nA problem caused by this open model is that any piece of knowledge which a person publishes is often his/her own perspective about a particular domain, which largely is relative to this person. As a consequence, the truth value of a piece of knowledge in the SW is context-dependent. Recently, as a solution to the aforementioned problem, the SW community adopts the use of quads, an extension of triples, as the primary carrier of knowledge. A quad c : (s, p, o) thus adds a fourth component of the context c to the triple (s, p, o), explicating the identifier of the context in which the triple holds. As a result, more and more triple-stores are becoming quad-stores. Some of the popular quad-stores are 4store1, Openlink Virtuoso 2, and some of the currently popular triplestores like Sesame3, Allegrograph4 internally keep track of the contexts of triples. Some of the recent initiatives in this direction have also extended existing formats like NTriples to N-Quads, which the RDF 1.1 has introduced as a W3C recommendation. The latest Billion triple challenge datasets have all been released in the N-Quads format.\nOther benefits of quads over triples are that they allow knowledge creators to specify various attributes of meta-knowledge that further qualify knowledge [2], and also allow users to query for this meta knowledge [3]. These attributes, which explicate the various assumptions under which knowledge holds, are also called context dimensions [4]. Examples of context dimensions are provenance, creator, intended user, creation time, validity time, geo-location, and topic. Having defined knowledge that is contextualized, as in c1 : (Renzi, primeMinsiterOf, Italy), one can now declare in a meta-context mc, statements such as mc : (c1, creator, John), mc : (c1, expiryTime, \u201cjun-2016\u201d) that talk about the knowledge in context c1, in this case its creator and expiry time. Another benefit of such a contextualized approach is that it opens possibilities of interesting ways for querying a contextualized knowledge base. For instance, if context c1 contains knowledge about football world cup 2014 and context c2 about football euro cup\n1 http://4store.org 2 http://virtuoso.openlinksw.com/rdf-quad-store/ 3 http://www.openrdf.org/ 4 http://www.franz.com/agraph/allegrograph/\n2012, then the query \u201cwho beat Italy in both world cup 2014 and euro cup 2012\u201d can be formalized as the conjunctive query:\nc1: (x, beat, Italy) \u2227 c2: (x, beat, Italy),\nwhere x is a variable. When reasoning with knowledge in quad form, since knowledge can be grouped and divided context wise and simultaneously be fed to separate reasoning engines, this approach improves both efficiency and scalability [9]. Besides the above flexibility, bridge rules [5] can be provided for inter-operating the knowledge in different contexts. Such rules are primarily of the form:\nc : \u03c6 \u2192 c\u2032 : \u03c6\u2032 (1)\nwhere \u03c6, \u03c6\u2032 are both atomic concept (role) symbols, c, c\u2032 are contexts. The semantics of such a rule is that if, for any a, \u03c6(a) holds in context c, then \u03c6\u2032(a) should hold in context c\u2032, where a is a unary/binary vector depending on whether \u03c6, \u03c6\u2032 are concept/role symbols. Although such bridge rules serve the purpose of specifying knowledge interoperability from a source context c to a target context c\u2032, in many practical situations there is the need of inter-operating multiple source contexts with multiple target contexts, for which the bridge rules of the form (1) are inadequate. Besides, one would also want the ability of creating new values in target contexts for the bridge rules.\nIn this work, we study contextual reasoning and query answering over contextualized RDF/OWL knowledge bases in the presence of forall-existential bridge rules that allow conjunctions and existential quantifiers in them, and hence are more expressive than those in DDL [5] and McCarthy et al. [6]. We provide a basic semantics for contextual reasoning based on which we provide procedures for conjunctive query answering. For query answering, we use the notion of a distributed chase, which is an extension of the standard chase [20, 21] that is widely used in the knowledge representation (KR) and Database (DB) settings for similar purposes. As far as the semantics for reasoning is concerned, we adopt the approach given in works such as Distributed Description Logics [5], E-connections [22], and two-dimensional logic of contexts [23], to use a set of interpretation structures as a model for contextualized knowledge. In this way, knowledge in each context is separately interpreted in a different interpretation structure. The main contributions of this work are:\n1. We formulate a context-based semantics that reuses the standard RDF/OWL semantics, which can be used for reasoning over quad-systems. Studying conjunctive query answering over quad-systems, it turns out that the entailment problem of conjunctive queries is undecidable for the most general class of quad-systems, called unrestricted quad-systems. 2. We derive decidable subclasses of unrestricted quad-systems, namely csafe, msafe, and safe quad-systems, for which we detail both data and combined complexities of conjunctive query entailment. These classes are based on the constrained DAG structure of Skolem blank nodes generated during the chase construction. We also provide decision procedures to decide whether an input quad-system is safe (csafe, msafe) or not.\n3. We further derive less expressive classes, RR and restricted RR quad-systems, for which no Skolem blank nodes are generated during the chase construction. 4. We show that the class of unrestricted quad-systems is equivalent to the class of ternary \u2200\u2203 rule sets. We compare the derived classes of quad-systems with well known subclasses of \u2200\u2203 rule sets, such as jointly acyclic and model faithful acyclic rule sets, and show that the technique of safety we propose, subsumes these other techniques, in expressivity.\nThe paper is structured as follows. In section 2, we formalize the idea of contextualized quad-systems, giving various definitions and notations for setting the background. In section 3, we formalize the problem of query answering for quad-systems, define notions such as distributed chase that are further used for query answering, and give the undecidability results of query entailment on unrestricted quad-systems. In section 4, we present csafe, msafe, and safe quad-systems and their computational properties. In section 5, RR quad-systems and restricted RR quad-systems are introduced. In section 6, we prove the equivalence of quad-systems with ternary \u2200\u2203 rule sets, and formally compare a few well known decidable classes in the realm of \u2200\u2203 rules to the classes of quad-systems, we presented in section 4. We provide a detailed discussion to other relevant related works in section 7, and conclude in section 8.\nNote that parts of the contents of section 2 and section 3 has been taken from conference papers [11] and [12]."}, {"heading": "2 Contextualized Quad-Systems", "text": "In this section, we formalize the notion of a quad-system and its semantics. For any vector or sequence x, we denote by \u2016x\u2016 the number of symbols in x, and by {x} the set of symbols in x. For any sets A and B, A \u2192 B denotes the set of all functions from set A to set B.\nGiven the set of URIs U, the set of blank nodes B, and the set of literals L, the set C = U \u228e B \u228e L is called the set of (RDF) constants. Any (s, p, o) \u2208 C \u00d7 C \u00d7C is called a generalized RDF triple (from now on, just triple). A graph is a set of triples. A quad is a tuple of the form c : (s, p, o), where (s, p, o) is a triple and c is a URI5, called the context identifier that denotes the context of the RDF triple. A quad-graph is defined as a set of quads. For any quad-graph Q and any context identifier c, we denote by graphQ(c) the set {(s, p, o)|c : (s, p, o) \u2208 Q}. We denote by QC the quad-graph whose set of context identifiers is C. The set of constants occurring in QC is given as C(QC) = {c, s, p, o | c : (s, p, o) \u2208 QC}. The set of URIs in QC is given by U(QC) = C(QC) \u2229 U. The set of blank nodes B(QC) and the set of literals L(QC) are similarly defined. Let V be the set of variables, any element of the set CV = V \u222a C is a term. Any (s, p, o) \u2208 CV \u00d7 CV \u00d7 CV is called a triple pattern, and an expression of the form c : (s, p, o), where (s, p, o) is a triple pattern, c a context identifier, is called a quad pattern. A triple pattern t, whose variables are elements of the vector x or elements of the vector y is written as t(x,y). For any function f : A \u2192 B, the restriction of f to\n5 Although, in general a context identifier can be a constant, for the ease of notation, we restrict them to be a URI\na set A\u2032, is the mapping f |A\u2032 from A\u2032 \u2229 A to B such that f |A\u2032(a) = f(a), for each a \u2208 A \u2229 A\u2032. For any triple pattern t = (s, p, o) and function \u00b5 from V to a set A, t[\u00b5] denotes (\u00b5\u2032(s), \u00b5\u2032(p), \u00b5\u2032(o)), where \u00b5\u2032 is an extension of \u00b5 to C such that \u00b5\u2032|C is the identity function. For any set of triple patterns G, G[\u00b5] denotes \u22c3\nt\u2208G t[\u00b5]. For any vector of constants a = \u3008a1, . . . , a\u2016a\u2016\u3009, and vector of variables x of the same length, x/a is the function \u00b5 such that \u00b5(xi) = ai, for 1 \u2264 i \u2264 \u2016a\u2016. We use the notation t(a,y) to denote t(x,y)[x/a]. Similarly, the above notations are also extended to sets of quad-patterns. For instance Q(x,y) denotes a set of quad-patterns, whose variables are fromx or y, and Q(a,y) is written for Q(x,y)[x/a]. For the sake of interoperating knowledge in different contexts, bridge rules need to be provided:\nBridge rules (BRs) Formally, a BR is of the form:\n\u2200x\u2200z [c1: t1(x, z) \u2227 ... \u2227 cn: tn(x, z) \u2192 \u2203y c\u20321: t \u2032 1(x,y) \u2227 ... \u2227 c \u2032 m: t \u2032 m(x,y)] (2)\nwhere c1, ..., cn, c\u20321, ..., c \u2032 m are context identifiers, x, y, z are vectors of variables such that {x}, {y}, and {z} are pairwise disjoint. t1(x, z), ..., tn(x, z) are triple patterns which do not contain blank-nodes, and whose set of variables are from x or z. t\u20321(x, y), ..., t\u2032m(x,y) are triple patterns, whose set of variables are fromx or y, and also does not contain blank-nodes. For any BR r of the form (2), body(r) is the set of quad patterns {c1: t1(x, z),...,cn: tn(x, z)}, and head(r) is the set of quad patterns {c\u20321: t \u2032 1(x,y), ... c\u2032m: t \u2032 m(x, y)}, and the frontier of r, fr(r) = {x}. Occasionally, we also note the BR r above as body(r)(x, z) \u2192 head(r)(x, y). The set of terms in a BR r is:\nC V(r) = {c, s, p, o | c : (s, p, o) \u2208 body(r) \u222a head(r)}\nThe set of terms for a set of BRs R is CV(R) = \u22c3\nr\u2208R C V(r). The URIs, blank nodes,\nliterals, variables of a BR r (resp. set of BRs R) are similarly defined, and are denoted as U(r), B(r), L(r), V(r) (resp. U(R), B(R), L(R), V(R)), respectively.\nDefinition 1 (Quad-System). A quad-system QSC is defined as a pair \u3008QC , R\u3009, where QC is a quad-graph, whose set of context identifiers is C, and R is a set of BRs.\nFor any quad-system,QSC = \u3008QC , R\u3009, the set of constants inQSC is given byC(QSC) = C(QC) \u222aC(R). The sets U(QSC), B(QSC), L(QSC), and V(QSC) are similarly defined for any quad-system QSC . For any quad-graph QC (BR r), its symbol size \u2016QC\u2016 (\u2016r\u2016) is the number of symbols required to print QC (r). Hence, \u2016QC\u2016 \u2248 4 \u2217 |QC |, where |QC | denotes the cardinality of the set QC . Note that |QC | equals the number of quads in QC . For a BR r, \u2016r\u2016 \u2248 4 \u2217 k, where k is the number of quad-patterns in r. For a set of BRs R, \u2016R\u2016 is given as \u03a3r\u2208R\u2016r\u2016. For any quad-system QSC = \u3008QC , R\u3009, its size \u2016QSC\u2016 = \u2016QC\u2016+ \u2016R\u2016.\nSemantics In order to provide a semantics for enabling reasoning over a quad-system, we need to use a local semantics for each context to interpret the knowledge pertaining to it. Since the primary goal of this paper is a decision procedure for query answering over quad-systems based on forward chaining, we consider the following desiderata for the choice of the local semantics and its deductive machinery:\n\u2013 there exists an operation lclosure() that computes the deductive closure of a graph w.r.t to the local semantics using the local inference rules in a set LIR, \u2013 each inference rule in LIR is range restricted, i.e. non value-generating, \u2013 given a finite graph as input, the lclosure() operation terminates with a finite graph\nas output in polynomial time whose size is polynomial w.r.t. to the input set.\nSome of the alternatives for the local semantics satisfying the above mentioned criterion are Simple, RDF, RDFS [31], OWL-Horst [27] etc. Assuming that a local semantics has been fixed, for any context c, we denote by Ic = \u3008\u2206c, \u00b7c\u3009 an interpretation structure for the local semantics, where \u2206c is the interpretation domain, \u00b7c the corresponding interpretation function. Also |=local denotes the local satisfaction relation between a local interpretation structure and a graph. Given a quad graphQC , a distributed interpretation structure is an indexed set IC = {Ic}c\u2208C, where Ic is a local interpretation structure, for each c \u2208 C. We define the satisfaction relation |= between a distributed interpretation structure IC and a quad-system QSC as:\nDefinition 2 (Model of a Quad-System). A distributed interpretation structure IC = {Ic}c\u2208C satisfies a quad-system QSC = \u3008QC , R\u3009, in symbols IC |= QSC, iff all the following conditions are satisfied: 1. Ic |=local graphQC (c), for each c \u2208 C; 2. aci = acj , for any a \u2208 C, ci, cj \u2208 C; 3. for each BR r \u2208 R of the form (2) and for each \u03c3 \u2208 V \u2192 \u2206C , where \u2206C =\n\u22c3\nc\u2208C \u2206 c, if\nIc1 |=local t1(x, z)[\u03c3], ..., I cn |=local tn(x, z)[\u03c3],\nthen there exists a function \u03c3\u2032 \u2287 \u03c3, such that Ic \u2032 1 |=local t \u2032 1(x,y)[\u03c3 \u2032], ..., Ic \u2032 m |=local t \u2032 m(x,y)[\u03c3\n\u2032]. Condition 1 in the above definition ensures that for any model IC of a quad-graph, each Ic \u2208 IC is a local model of the set of triples in context c. Condition 2 ensures that any constant c is rigid, i.e. represents the same resource across a quad-graph, irrespective of the context in which it occurs. Condition 3 ensures that any model of a quad-system satisfies each BR in it. Any IC such that IC |= QSC is said to be a model of QSC . A quad-system QSC is said to be consistent if there exists a model IC , such that IC |= QSC , and otherwise said to be inconsistent. For any quad-system QSC = \u3008QC , R\u3009, it can be the case that graphQC(c) is locally consistent, i.e. there exists an I\nc such that Ic |=local graphQC (c), for each c \u2208 C, whereas QSC is not consistent. This is because the set of BRs R adds more knowledge to the quad-system, and restricts the set of models that satisfy the quad-system.\nDefinition 3 (Quad-system entailment). (a) A quad-system QSC entails a quad c : (s, p, o), in symbols QSC |= c : (s, p, o), iff for any distributed interpretation structure IC , if IC |= QSC then IC |= \u3008{c : (s, p, o)}, \u2205\u3009. (b) A quad-system QSC entails a quadgraph Q\u2032C\u2032 , in symbols QSC |= Q \u2032 C\u2032 iff QSC |= c : (s, p, o) for any c : (s, p, o) \u2208 Q \u2032 C\u2032 . (c) A quad-system QSC entails a BR r iff for any IC , if IC |= QSC then IC |= \u3008\u2205, {r}\u3009. (d) For a set of BRs R, QSC |= R iff QSC |= r, for every r \u2208 R. (e) Finally, a quadsystem QSC entails another quad-system QS\u2032C\u2032 = \u3008Q \u2032 C\u2032 , R\n\u2032\u3009, in symbols QSC |= QS\u2032C\u2032 iff QSC |= Q\u2032C\u2032 and QSC |= R\n\u2032. We call the decision problems corresponding to the entailment problems (EPs) in (a), (b), (c), (d), and (e) as quad EP, quad-graph EP, BR EP, BRs EP, and quad-system EP, respectively."}, {"heading": "3 Query Answering on Quad-Systems", "text": "In the realm of quad-systems, the classical conjunctive queries or select-project-join queries are slightly extended to what we call Contextualized Conjunctive Queries (CCQs). A CCQ CQ(x) is an expression of the form:\n\u2203y q1(x,y) \u2227 ... \u2227 qp(x,y) (3)\nwhere qi, for i = 1, ..., p are quad patterns over vectors of free variables x and quantified variables y. A CCQ is called a boolean CCQ if it does not have any free variables. With some abuse, we sometimes discard the logical symbols in a CCQ and consider it as a set of quad-patterns. For any CCQ CQ(x) and a vector a of constants such that \u2016x\u2016 = \u2016a\u2016, CQ(a) is boolean. A vector a is an answer for a CCQ CQ(x) w.r.t. structure IC , in symbols IC |= CQ(a), iff there exists assignment \u00b5 : {y} \u2192 B such that IC |= \u22c3\ni=1,...,p qi(a,y)[\u00b5]. A vector a is a certain answer for a CCQ CQ(x) over a quad-system QSC , iff IC |= CQ(a), for every model IC of QSC . Given a quadsystem QSC , a CCQ CQ(x), and a vector a, decision problem of determining whether QSC |= CQ(a) is called the CCQ EP. It can be noted that the other decision problems over quad-systems, namely Quad/Quad-graph EP, BR(s) EP, Quad-system EP, are reducible to the CCQ EP (See Property 6). Hence, in this paper, we primarily focus on the CCQ EP."}, {"heading": "3.1 dChase of a Quad-System", "text": "In order to build a procedure for query answering over a quad-system, we employ what has been called in the literature a chase [20, 21]. Specifically, we adopt notions of the restricted chase in Fagin et al. [24] (also called non-oblivious chase). In order to fit the framework of quad-systems, we extend the standard notion of chase to a distributed chase, abbreviated dChase. In the following, we show how the dChase of a quad-system can be constructed.\nFor a set of quad-patternsS and a set of terms T , we define the relationT -connectedness between quad-patterns in S as the least relation with:\n\u2013 q1 and q2 are T -connected, if CV(q1)\u2229CV(q2)\u2229T 6= \u2205, for any two quad-patterns q1, q2 \u2208 S, \u2013 if q1 and q2 are T -connected, and q2 and q3 are T -connected, then q1 and q3 are also T -connected, for any quad-patterns q1, q2, q3 \u2208 S.\nIt can be noted that T -connectedness is an equivalence relation and partitions S into a set of T -components (similar notion is called a piece in Baget et al. [15]). Note that for two distinct T -components P1, P2 of S, CV(P1) \u2229 CV(P2) \u2229 T = \u2205. For any BR r = body(r)(x, z) \u2192 head(r)(x,y), suppose P1, P2, . . . , Pk are the pairwise distinct {y}-components of head(r)(x,y), then r can be replaced by the semantically equivalent set of BRs {body(r)(x, z) \u2192 P1, . . . , body(r)(x, z) \u2192 Pk} whose symbol size is worst case quadratic w.r.t. the symbol size of r. Hence, w.l.o.g. we assume that for any BR r, the set of quad-patterns head(r) is a single component w.r.t. the set of existentially quantified variables in r.\nConsidering the fact that the local semantics for contexts are fixed a priori (for instance RDFS), both the number of rules in the set of local inference rules LIR and the size of each rule in LIR can be assumed to be a constant. Note that each local inference rule is range restricted and does not contain existentially quantified variables in its head. Any ir \u2208 LIR is of the form:\n\u2200x\u2200z [t1(x, z) \u2227 . . . \u2227 tk(x, z) \u2192 t \u2032 1(x)], (4)\nwhere ti(x, z), for i = 1, . . . , n are triple patterns, whose variables are from {x} or {z}, and t\u20321(x) is a triple pattern, whose variables are from {x}. Hence, for any quadsystem QSC = \u3008QC , R\u3009 in order to accomplish the effect of local inferencing in each context c \u2208 C, for each ir \u2208 LIR of the form (4), we could augment R with a BR irc of the form:\n\u2200x\u2200z [c : t1(x, z) \u2227 . . . \u2227 c : tk(x, z) \u2192 c : t \u2032 1(x)]\nSince \u2016LIR\u2016 is a constant and the size of the augmentation is linear in |C|, w.l.o.g we assume that the set R contains a BR irc, for each ir \u2208 LIR, c \u2208 C.\nGiven a quad-system QSC , we denote by Bsk \u2286 B, a set of blank nodes called Skolem blank nodes, such that Bsk \u2229 B(QSC) = \u2205. For any BR r = body(r)(x, z) \u2192 head(r)(x, y) and an assignment \u00b5 : {x} \u222a {z} \u2192 C, the application of \u00b5 on r is defined as:\napply(r, \u00b5) = head(r)[\u00b5ext(y)]\nwhere \u00b5ext(y) \u2287 \u00b5 such that \u00b5ext(y)(yi) = : b is a fresh blank node from Bsk, for each yi \u2208 {y}.\nWe assume that there exists an order\u227al (for instance, lexicographic order) on the set of constants. We extend \u227al to the set of quads such that for any two quads c : (s, p, o) and c\u2032 : (s\u2032, p\u2032, o\u2032), c : (s, p, o) \u227al c\u2032 : (s\u2032, p\u2032, o\u2032), iff c \u227al c\u2032, or c = c\u2032, s \u227al s\u2032, or c = c\u2032, s = s\u2032, p \u227al p\u2032, or c = c\u2032, s = s\u2032, p = p\u2032, o \u227al o\u2032. It can be noted that \u227al is a strict linear order over the set of all quads. For any finite quad-graphQC, the \u227al-greatest quad of QC , denoted greatestQuad\u227al(QC), is the quad q \u2208 QC such that q\n\u2032 \u227al q, for every other q\u2032 \u2208 QC . Also, the order \u227aq is defined over the set of finite quad-graphs as follows: for any two finite quad-graphs QC , Q\u2032C\u2032 ,\nQC \u227aq Q\u2032C\u2032 , if (i) QC \u2282 Q \u2032 C\u2032 ; QC \u227aq Q \u2032 C\u2032 , if (i) does not hold and (ii) greatestQu-\n-ad\u227al(QC \\ Q \u2032 C\u2032) \u227al greatestQuad\u227al(Q \u2032 C\u2032 \\ QC);\nQC 6\u227aq Q\u2032C\u2032 , if both (i) and (ii) are not satisfied;\nA relation R over a set A is called a strict linear order iff R is irreflexive, transitive, and R(a, b) or R(b, a) holds, for every distinct a, b \u2208 A.\nProperty 1. Let Q be the set of all finite quad-graphs; \u227aq is a strict linear order over Q.\nAlso, we now define in parallel the dChase of a quad system QSC = \u3008QC , R\u3009 and the level of a quad in the dChase of QSC as follows: any quad in QC is of level 0. The level of a set of quads is the largest among levels of quads in the set. The level of any quad that results from the application of a BR r w.r.t. an assignment \u00b5 is one more\nthan the level of the set body(r)[\u00b5], if it has not already been assigned a level. Let \u227a be an ordering on the quad-graphs such that for any two quad-graphs Q\u2032C\u2032 and Q \u2032\u2032 C\u2032\u2032 of the same level, Q\u2032C\u2032 \u227a Q \u2032\u2032 C\u2032\u2032 , iff Q \u2032 C\u2032 \u227aq Q \u2032\u2032 C\u2032\u2032 . For Q \u2032 C\u2032 and Q \u2032\u2032 C\u2032\u2032 of different levels, Q\u2032C\u2032 \u227a Q \u2032\u2032 C\u2032\u2032 , iff level of Q \u2032 C\u2032 is less than level of Q \u2032\u2032 C\u2032\u2032 . It can easily be seen that \u227a is a strict linear order over the set of quad-graphs. For any BRs r, r\u2032 and assignments \u00b5, \u00b5\u2032 over V(body(r)),V(body(r\u2032)), respectively, (r, \u00b5) \u227a (r\u2032, \u00b5\u2032) iff body(r)[\u00b5] \u227a body(r\u2032)[\u00b5\u2032]. For any quad-graph Q\u2032C\u2032 , a set of BRs R, a BR r \u2208 R, an assignment \u00b5 \u2208 V(body(r)) \u2192 C, let applicableR be the least ternary predicate defined inductively as:\napplicableR(r, \u00b5,Q \u2032 C\u2032) holds, if (a) body(r)[\u00b5] \u2286 Q \u2032 C\u2032 , head(r)[\u00b5 \u2032\u2032] 6\u2286 Q\u2032C\u2032 , \u2200\u00b5 \u2032\u2032 \u2287 \u00b5, and (b) 6 \u2203r\u2032 \u2208 R, 6 \u2203\u00b5\u2032 such that r\u2032 6= r or \u00b5\u2032 6= \u00b5 with (r\u2032, \u00b5\u2032) \u227a (r, \u00b5) and\napplicableR(r \u2032, \u00b5\u2032, Q\u2032C\u2032);\nFor any quad-system QSC = \u3008QC , R\u3009, let dChase0(QSC) = QC ; dChasei+1(QSC) = dChasei(QSC) \u222a apply(r, \u00b5), if there exists r = body(r)(x, z)\u2192 head(r)(x, y) \u2208R, assignment \u00b5 : {x} \u222a {z} \u2192C such that applicableR(r, \u00b5, dChasei(QSC));\ndChasei+1(QSC) = dChasei(QSC), otherwise; for any i \u2208 N. The dChase of QSC , noted dChase(QSC), is given as:\ndChase(QSC) = \u22c3\ni\u2208N\ndChasei(QSC)\nIntuitively, dChasei(QSC) can be thought of as the state of dChase(QSC) at the end of iteration i. It can be noted that, if there exists i such that dChasei(QSC) = dChasei+1(QSC), then dChase(QSC) is equal to dChasei( QSC). A model IC of a quad-system QSC is called universal [30], iff the following holds: IC is a model of QSC , and for any model I \u2032C of QSC there exists a homomorphism from IC to I \u2032C .\nTheorem 1. For any consistent quad-systemQSC, the following holds: (i) dChase(QSC) is a universal model of QSC .6, and (ii) for any boolean CCQ CQ(), QSC |= CQ() iff there exists a map \u00b5 : V(CQ) \u2192 C such that {CQ()}[\u00b5] \u2286 dChase(QSC).\nAn anolog of the above theorem for DLs and Databases is stated and proved in [25]. Since the proof in [25] can easily be adapted to our case, we refer the reader to [25] for the proof. We call the sequence dChase0(QSC), dChase1(QSC), ..., the dChase sequence of QSC. It should be noted that at each iteration i, after the application of a BR, any new quad added is assigned a level, and as a result any subset of the set of quads in dChasei(QSC) has a level. This assignment of levels guarantees that applicableR(r, \u00b5, dChasei(QSC)) is either true or false, for any r \u2208 R, assignment \u00b5 : V(body(r)) \u2192 C. The following lemma shows that in a dChase sequence of a quad-system, any dChase iteration can be performed in time exponential w.r.t. the size of the largest BR.\n6 Though dChase(QSC) is not an interpretation in a strict model theoretic sense, one can easily create the corresponding interpretation IdChase(QSC) = {I\nc = \u3008\u2206c, .c\u3009}c\u2208C , s.t. for every c \u2208 C, \u2206c is equal to set of constants in graphdChase(QSC)(c), and .\nc is s.t (s, p, o) \u2208 graphdChase(QSC)(c) iff (s c, oc) \u2208 pc.\nLemma 1. For a quad-system QSC = \u3008QC , R\u3009, for any i \u2208 N+, the following holds: (i) dChasei(QSC) can be computed in time O( |R| \u2217 \u2016dChasei\u22121(QSC)\u2016rs), where rs = maxr\u2208R\u2016r\u2016, (ii) \u2016dChasei(QSC)\u2016 = O(\u2016dChasei\u22121(QSC)\u2016+ \u2016R\u2016).\nProof. (i) We can first find, if there exists an r among the set of BRs R, assignment \u00b5 such that applicableR(r, \u00b5, dChasei\u22121(QSC)) holds, in the following naive way: (1) bind the set of variables in all rules in R with the set of constants in dChasei\u22121(QSC). Let this set be called S. Note that |S| = O(|R|\u2217\u2016dChasei\u22121(QSC )\u2016\u2016rs\u2016), where rs = maxr\u2208R\u2016r\u2016. Also, note that each of the binding in S is of the form body(r)(x, z)(\u00b5) \u2192 head(r)(x, y)(\u00b5\u2032) (\u2665), where r \u2208 R. (2) From the set S we filter out every binding of the form (\u2665) in which x[\u00b5] 6= x[\u00b5\u2032]. Let S\u2032 be the resulting set after the above filtering operation. (3) From the set S\u2032, we now filter out all the bindings of the form (\u2665) with head(r)(x, y)(\u00b5\u2032)\u2286 dChasei\u22121(QSC), with resulting set S\u2032\u2032. (4) If S\u2032\u2032 = \u2205, then there is no r \u2208 R, assignment \u00b5 such that applicableR(r, \u00b5, dChasei\u22121(QSC)) is True. Otherwise if S\u2032\u2032 6= \u2205, then note that each binding of the form (\u2665) in S\u2032\u2032 is such that condition (a) of the true applicableR(r, \u00b5, dChasei\u22121(QSC)) is satisfied. Now, we can sort S\u2032\u2032 w.r.t. \u227a and select the least binding b of the form (\u2665), so that condition (b) in True condition of applicableR() is satisfied for b. It can easily be seen that applicableR(r, \u00b5, dChasei\u22121(QSC)) holds for the r, \u00b5 extracted from b. Since the size of each binding is at most \u2016rs\u2016, the operations (1)-(4) can be performed in time O(|R| \u2217 \u2016dChasei\u22121(QSC)\u2016rs). Since dChasei(QSC) = dChasei\u22121(QSC) \u222a head(r)[\u00b5], for r, \u00b5 with applicableR(r, \u00b5, dChasei\u22121(QSC)), dChasei(QSC) can be computed in time O(\u2016dChasei\u22121(QSC )\u2016rs).\n(ii) Trivially holds, since at worst dChasei(QSC) = dChasei\u22121(QSC)\u222a head(r)[\u00b5], for r \u2208 R.\nLemma 2. For any quad-system QSC, If : b is a Skolem blank node in dChase(QSC), generated by the application of assignment \u00b5 on r = body(r)(x, z) \u2192 head(r)(x, y), with \u00b5ext(y)(yj) = : b, yj \u2208 {y}, then : b is unique for (r, yj ,x[\u00b5ext(y)]).\nProof. By contradiction, suppose if : b is not unique for (r, yj ,x[\u00b5ext(y)]), i.e. there exists : b\u2032 6= : b in dChase(QSC), with : b\u2032 generated by r such that : b\u2032 = \u00b5\u2032ext(y)(yj) and x[\u00b5ext(y)] = x[\u00b5\u2032ext(y)]. W.l.o.g. suppose : b was generated in an iteration l \u2208 N and : b\u2032 in an iterationm > l. This means that head(r)(x, y)[\u00b5ext(y)]\u2286 dChasel(QSC), and hence head(r)(x, y)[\u00b5ext(y)] \u2286 dChasem\u22121(QSC). Also, since \u00b5|x = \u00b5\u2032|x, there \u2203\u00b5\u2032\u2032 \u2287 \u00b5\u2032 s.t. head(r)(x, y)[\u00b5\u2032\u2032] \u2286 dChasem\u22121(QSC). This means that (a) part of the function applicableR is false, for applicableR(r, \u00b5\u2032, dChasem\u22121(QSC)) to be true, and hence applicableR(r, \u00b5\u2032, dChasem\u22121(QSC)) is false. Hence, our assumption that : b\u2032 = yj [\u00b5 \u2032ext(y)] is false. Hence, : b is unique for (r, yj , x[\u00b5ext(y)]).\nAlthough we now know how to compute the dChase of a quad-system, which can be used for deciding CCQ EP, the following proposition reveals that for the class of quadsystems whose BRs are of the form (2), which we call unrestricted quad-systems, the dChase can be infinite.\nProposition 1. There exists unrestricted quad-systems whose dChase is infinite.\nProof. Consider an example of a quad-system QSc = \u3008Qc, r\u3009, where Qc = {c : (a, rdf:type, C)}, and the BR r = c : (x, rdf:type, C) \u2192 \u2203y c : (x, P , y), c : (y, rdf:type, C). The dChase computation starts with dChase0(QSc) = {c : (a, rdf:type,C)}, now the rule r is applicable, and its application leads to dChase1(QSc) = {c : (a, rdf:type, C), c : (a, P, : b1), c : ( : b1, rdf:type, C)}, where : b1 is a fresh Skolem blank node. It can be noted that r is yet again applicable on dChase1(QSc), for c : ( : b1, rdf:type, C), which leads to the generation of another Skolem blank node, and so on. Hence, dChase(QSc) does not have a finite fix-point, and dChase(QSc) is infinite.\nA class C of quad-systems is called a finite extension class (FEC), iff for every member QSC \u2208 C, dChase(QSC) is a finite set. Therefore, the class of unrestricted quadsystems is not a FEC. This raises the question if there are other approaches that can be used, for instance, a similar problem of non-finite chase is manifested in description logics (DLs) with value creation, due to the presence of existential quantifiers, whereas the approaches like the one in Glimm et al. [28] provides an algorithm for CQ entailment based on query rewriting. Theorem 2 below establishes the fact that the CCQ EP for unrestricted quad-systems is undecidable. Despite this, the reader should note that the following undecidability result and its proof is only provided for the sake of self containedness, and we do not claim the undecidability theorem nor its proof to be a novel contribution, as we will show in section 6, ternary \u2200\u2203 rule sets are polynomially reducible to unrestricted quad-systems. Hence, the undecidability results provided in Baget et al. [15], Kro\u0308tzsch et al. [39], or Beeri et al. [14] can trivially be applied in our setting to obtain the undecidability result for unrestricted quad-systems.\nTheorem 2. The CCQ entailment problem over unrestricted quad-systems is undecidable.\nProof. (sketch) We show that the well known undecidable problem of non-emptiness of intersection of context-free grammars (CFGs) is reducible to the CCQ entailment problem. Given two CFGs, G1 = \u3008V1, T, S1, P1\u3009 and G2 = \u3008V2, T, S2, P2\u3009, where V1, V2 are the set of variables, T such that T \u2229 (V1 \u222a V2) = \u2205 is the set of terminals. S1 \u2208 V1 is the start symbol of G1, and P1 are the set of PRs of the form v \u2192 w, where v \u2208 V , w is a sequence of the form w1...wn, where wi \u2208 V1 \u222a T . s2, P2 are defined similarly. Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [33].\nGiven two CFGs G1 = \u3008V1, T, S1, P1\u3009 and G2 = \u3008V2, T, S2, P2\u3009, we encode grammars G1, G2 into a quad-system QSc = \u3008Qc, R\u3009, with only a single context identifier c. Each PR r = v \u2192 w \u2208 P1 \u222a P2, with w = w1w2w3..wn, is encoded as a BR of the form: c : (x1, w1, x2), c : (x2, w2, x3), ..., c : (xn, wn, xn+1) \u2192 c : (x1, v, xn+1), where x1, .., xn+1 are variables. For each terminal symbol ti \u2208 T , R contains a BR of the form: c : (x,rdf:type, C) \u2192 \u2203y c : (x, ti, y), c : (y, rdf:type, C) and Qc is the singleton: { c : (a, rdf:type, C)}. It can be observed that:\nQSc |= \u2203y c : (a, S1, y) \u2227 c : (a, S2, y) \u21d4\nL(G1) \u2229 L(G2) 6= \u2205\nWe refer the reader to Appendix for the complete proof.\nHaving shown the undecidability results of query answering of unrestricted quad-systems, the rest of the paper focuses on defining subclasses of unrestricted quad-systems for which query answering is decidable, and establishing their relationships with similar classes in the realm of \u2200\u2203 rules. While defining decidable classes for quad-systems, one mainly has two fundamentally distinct options: (i) is to define notions that solely use the structure/properties of the BR part, ignoring the quad-graph part, or (ii) to define notions that takes into account both the BR and quad-graph part. The decidability notions which we define in section 4, namely safety, msafety, and csafety belong to type (ii), as these techniques take into account the property of the dChase of a quad-system, which is determined by both the quad-graph and BRs of the quad-system. Whereas the ones which we define in section 5, namely RR and restricted RR quad-systems fall into type (i), as the properties of BRs alone are used. With an analogy between a set of BRs and a set of \u2200\u2203 rules, and between a quad-graph and a set of \u2200\u2203 instances, the reader should note that such distinctions can also be made for the decidability notions in the realm of \u2200\u2203 rule sets. Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part. Whereas techniques such as model faithful acyclicity [32] and model summarizing acyclicity [32] are of type (i) as both the rules and instance part is considered."}, {"heading": "4 Safe, Msafe and Csafe Quad-Systems: Decidable FECs", "text": "In the previous section, we saw that the query answering problem over unrestricted quad-systems is undecidable, in general. We will also see in section 6 that any quadsystem is polynomially translatable to a \u2200\u2203 rule set, which is also a first order logic theory. Hence, a possible solution approach is to translate to these more expressive languages, and apply well known tests (see related work for details on such tests) available in these languages to check if query answering is decidable. If the translated quadsystem passes one of these tests, then query answering can be performed on this translation using available algorithms in these expressive languages. But such an approach is often discouraged, because of the non-applicability of the already available tools and techniques available for reasoning over quads. Instead, we in the following define three classes of quad-systems, namely SAFE, MSAFE and CSAFE, that are FECs and for which query entailment is decidable. Finiteness/decidability is achieved by putting certain restrictions (explained below) on the blank nodes generated in the dChase.\nRecall that, for any quad-system QSC, the set of blank-nodes B(dChase(QSC)) in its dChase(QSC) not only contains blank nodes present in QSC, i.e. B(QSC), but also contains Skolem blank nodes that are generated during the dChase construction process. Note that the following holds: Bsk(dChase(QSC)) = B(dChase(QSC)) \\ B(QSC). We assume w.l.o.g. that for any set of BRs R, any BR in R has a unique rule identifier, and we often write ri for the BR in R, whose identifier is i.\nDefinition 4 (Origin RuleId/Vector). For any Skolem blank node : b, generated in the dChase by the application of a BR ri = body(ri)(x, z) \u2192 head(ri)(x,y) using assignment \u00b5 : {x} \u222a {z} \u2192 C, i.e. : b = \u00b5ext(y)(yj), for some yj \u2208 y, we say that the origin ruleId of : b is i, denoted originRuleId( : b) = i. Moreover w = x[\u00b5] is said to be the origin vector of : b, denoted originV ector( : b) =w.\nAs we saw in Lemma 2, any such Skolem blank node : b, generated in the dChase can uniquely be represented by the expression (i, j,w), where i is rule id, j is identifier of the existentially quantified variable yj in ri substituted by : b during the application of \u00b5 on ri. Also in the above case, we denote relation between each constant k = \u00b5ext(y)(xh), xh \u2208 {x}, and : b with the relation childOf. Moreover, since children of a Skolem blank node can be Skolem blank nodes, which themselves can have children, one can naturally define relation descendantOf =childOf+ as the transitive closure of childOf. Note that according to the above definition, \u2018descendantOf\u2019 is not reflexive. In addition, we could keep track of the set of contexts in which a blank-node was first generated, using the following notion:\nDefinition 5 (Origin-contexts). For any quad-system QSC and for any Skolem blank node : b \u2208Bsk(dCha- se(QSC)), the set of origin-contexts of : b is given by origin-Contexts( : b) = {c | \u2203i. c:(s, p, o) \u2208 dChasei(QSC), s = : b or p = : b or o = : b, and \u2204j < i with c\u2032:(s\u2032, p\u2032, o\u2032) \u2208 dChasej(QSC), s\u2032 = : b or p\u2032 = : b or o\u2032 = : b, for any c\u2032 \u2208 C}.\nIntuitively, origin-contexts for a Skolem blank node : b is the set of contexts in which triples containing : b are first generated, during the dChase construction. Note that there can be multiple contexts in which : b can simultaneously be generated. By setting originRuleId(k) = n.d., (resp. originV ector(k) = n.d., resp. originContexts(k) = n.d.,) where n.d. is an ad hoc constant, \u2200k 6\u2208 Bsk(dChase(QSC)), we extend the definition of origin ruleId, (resp. origin vector, resp. origin-contexts) to all the constants in the dChase of a quad-system.\nExample 1. Consider the quad-system \u3008QC , R\u3009, where QC = {c1 : (a, b, c)}. Suppose R is the following set:\nR =\n\n   \n    \nc1 : (x11, x12, z1) \u2192 c2 : (x11, x12, y1) (r1) c2 : (a, z2, x22) \u2192 c3 : (a, x22, y2) (r2) c2 : (z3, b, x32) \u2192 c3 : (b, x32, y3) (r3) c3 : (a, z41, x41), c3 : (b, z42, x42)\n\u2192 c2 : (y4, x41, a), c2 : (y4, x42, b) (r4)\n\n   \n    \nSuppose that for brevity quantifiers have been omitted, and variables of the form yi or yij are implicitly existentially quantified. Iterations during the dChase construction are:\ndChase0(QSC) = {c1:(a, b, c)}\ndChase1(QSC) = {c1 : (a, b, c), c2 : (a, b, : b1)}\ndChase2(QSC) = {c1:(a, b, c), c2 : (a, b, : b1), c3 : (a, : b1, : b2)}\ndChase3(QSC) = {c1:(a, b, c), c2 : (a, b, : b1), c3 : (a, : b1, : b2),\nc3 : (b, : b1, : b3)}\ndChase4(QSC) = {c1:(a, b, c), c2 : (a, b, : b1), c3 : (a, : b1, : b2), c3 : (b, : b1,\n: b3), c2 : ( : b4, : b2, a), c2 : ( : b4, : b3, b)}\ndChase5(QSC) = dChase4(QSC),\nAlso note: originRuleId( : b1) = 1, originRuleId( : b2) = 2, originRuleId( : b3) = 3, originRuleId( : b4) = 4, originV ector( :b1) = \u3008a, b\u3009, originV ector( :b2) = originV ector( :b3) = \u3008 : b1\u3009, originV ector( :b4) = \u3008 :b2, :b3\u3009, also originContexts( :b1) = {c2}, originConte- xts( : b2) = originContexts( : b3) = {c3}, origin- Contexts( : b4) = {c2}, also : b1 descendantOf : b3, : b1 descendantOf : b2, : b2 descendantOf : b4, : b3 descendantOf : b4, : b1 descendantOf : b4.\nFor any Skolem blank node : b (in dChase), its descendant hierarchy can be analyzed using a descendance graph \u3008V,E, \u03bbr, \u03bbv, \u03bbc\u3009, which is a labeled graph rooted at : b, whose set of nodes V are constants in the dChase, the set of edges E is such that (k, k\u2032) \u2208 E, iff k\u2032 is a descendant of k. \u03bbr, \u03bbv , \u03bbc are node labeling functions, such that \u03bbr(k) = originRuleId(k),\u03bbv(k) = originV ector(k), and \u03bbc(k) = originContexts(k), for any k \u2208 V . The descendance graph for :b4 of Example 1 is shown in Fig.1. For any two vectors of constants v,w, we note v \u223c= w, iff there exists a bijection \u00b5 : B(v) \u2192 B(w) such that w = v[\u00b5].\nDefinition 6 (safe, msafe, csafe quad-systems). A quad-system QSC is said to be unsafe (resp. unmsafe, resp. uncsafe), iff there exist Skolem blank nodes : b 6= : b\u2032 in dChase(QSC) such that : b is a descendant of : b\u2032, with originRuleId( : b) = originRuleId( : b\u2032) and originV ector( : b) \u223c= originV ector( : b\u2032) (resp. originRuleId( : b) = originRuleId( : b\u2032), resp. originContexts( : b) = originConte-\nxts( : b\u2032)). A quad-system is safe (resp. msafe, resp. csafe) iff it is not unsafe (resp. unmsafe, resp. uncsafe).\nIntuitively, safe, msafe and csafe quad-systems, does not allow repetitive generation of Skolem blank-nodes with a certain set of attributes in its dChase. The containment relation between the class of safe, msafe, and csafe quad-systems are established by the following theorem:\nTheorem 3. Let SAFE, MSAFE, and CSAFE denote the class of safe, msafe, and csafe quad-systems, respectively, then the following holds:\nCSAFE \u2282 MSAFE \u2282 SAFE\nProof. We first show MSAFE \u2286 SAFE, by showing the inverse inclusion of their compliments, i.e. UNSAFE \u2286 UNMSAFE. Suppose a given quad-system QSC is unsafe, then by definition its dChase contains two distinct Skolem blank nodes : b, : b\u2032 such that : b is a descendant of : b\u2032, with originRuleId( : b) = originRuleId( : b\u2032) and originV ector( : b) \u223c= originV ector( : b\u2032). But this will imply that originRuleId( : b) = originRuleId( : b\u2032). Hence, by definition,QSC is unmsafe. Hence UNSAFE \u2286 UNMSAFE (\u2020). Now, we show that CSAFE \u2286 MSAFE by showing UNMSAFE \u2286 UNCSAFE. Suppose a given quad-system QSC = \u3008QC , R\u3009 is unmsafe, then by definition its dChase contains two distinct Skolem blank nodes : b, : b\u2032 such that : b is a descendant of : b\u2032, with originRuleId( : b) = originRuleId( : b\u2032). But this implies that there exists a BR ri = body(ri)(x, z)\u2192 head(ri)(x, y), assignment \u00b5, (resp. \u00b5\u2032,) s.t. : b (resp. : b\u2032) was generated in dChase(QSC) as result of application of \u00b5 (resp. \u00b5\u2032) on ri. That is : b = yj [\u00b5\next(y)], and : b\u2032 = yk[\u00b5\u2032ext(y)], where yj , yk \u2208 {y}. We have the following two subcases (i) j = k, (ii) j 6= k. Suppose (i) j = k, then it immediately follows that originContexts( : b) = originContexts( : b\u2032). Hence, QSC is uncsafe. Suppose (ii) j 6= k, then by construction of dChase, on application of \u00b5\u2032 to ri, along with : b\u2032, there gets also generated a Skolem blank node : b\u2032\u2032 = yj [\u00b5\u2032ext(y)], with yj \u2208 {y}. Since : b and : b\u2032\u2032 are generated by substitutions of the same variable yj \u2208 {y} of BR ri, originContexts( : b) = originContexts( : b\u2032\u2032). Also considering that childOf( : b\u2032) = childOf( : b\u2032\u2032) = {x[\u00b5\u2032ext(y)]}, we can deduce that : b is a descendant of : b\u2032\u2032. Hence, by definition, it holds that QSC is uncsafe. Hence UNMSAFE \u2286 UNCSAFE (\u2021).\nFrom \u2020 and \u2021, it follows that CSAFE \u2286 MSAFE \u2286 SAFE. To show that the containments are strict, consider the quad-system QSC in example 1. By definition, QSC is msafe, however uncsafe, as the Skolem blank nodes : b1, : b4, which have the same origin contexts are s.t. : b1 is a descendant of : b4. Hence, CSAFE \u2282 MSAFE. For MSAFE \u2282 SAFE, the following example shows an instance of a quad-system that is unmsafe, yet is safe.\nExample 2. Consider the quad-system QSC = \u3008QC , R\u3009, where QC = {c1 : (a, b, c), c2 : (c, d, e)}, R is given by:\nc1 : (x11, x12, x13), c2 : (x13, x14, z1) \u2192 c3 : (y1, x11, x12), c4 : (x12, x13, x14) (r1)\nc3 : (x21, a, x22), c4 : (x22, x23, x24) \u2192 c1 : (x21, a, x22), c2 : (x22, x23, x24) (r2)\nc3 : (x21, x22, a), c4 : (a, x23, x24) \u2192 c1 : (x21, x22, a), c2 : (a, x23, x24) (r3)\nc3 : (x21, x22, x23), c4 : (x23, a, x24) \u2192 c1 : (x21, x22, x23), c2 : (x23, a, x24) (r4)\nc3 : (x21, x22, x23), c4 : (x23, x24, a) \u2192 c1 : (x21, x22, x23), c2 : (x23, x24, a) (r5)\nNote that for brevity quantifiers have been omitted, and variables of the form yi or yij are implicitly existentially quantified. Iterations during the dChase construction are:\ndChase0(QSC) = {c1:(a, b, c), c2:(c, d, e)}\ndChase1(QSC) = dChase0(QSC) \u222a {c3 : ( : b1, a, b), c4 : (b, c, d)}\ndChase2(QSC) = dChase1(QSC) \u222a {c1 : ( : b1, a, b), c2 : (b, c, d)}\ndChase3(QSC) = dChase2(QSC) \u222a {c3 : ( : b2, : b1, a), c4 : (a, b, c)}\ndChase4(QSC) = dChase3(QSC) \u222a {c1 : ( : b2, : b1, a), c2 : (a, b, c)}\ndChase5(QSC) = dChase4(QSC) \u222a {c3 : ( : b3, : b2, : b1), c4 : ( : b1, a, b)}\ndChase6(QSC) = dChase5(QSC) \u222a {c1 : ( : b3, : b2, : b1), c2 : ( : b1, a, b)}\ndChase7(QSC) = dChase6(QSC) \u222a {c3 : ( : b4, : b3, : b2), c4 : ( : b2, : b1, a)}\ndChase8(QSC) = dChase7(QSC) \u222a {c1 : ( : b4, : b3, : b2), c2 : ( : b2, : b1, a)}\ndChase9(QSC) = dChase8(QSC) \u222a {c3 : ( : b5, : b4, : b3), c4 : ( : b3, : b2,\n: b1)}\ndChase(QSC) = dChase9(QSC)\nIt can be seen that : b1, : b2, : b3, : b4, : b5 form a descendant chain, since : bi descendantOf : bi+1, for each i = 1, . . . , 4. Also, originRuleId( : bi) = originRuleId( : bi+1), for each i = 1, . . . , 4. Hence it turns out that QSC is unmsafe. However, it can be seen that originV ector( : b1) = \u3008a, b, c, d\u3009, and originV ector( : b2) = \u3008 : b1, a, b, c\u3009, and originV ector( : b3) = \u3008 : b2, : b1, a, b\u3009, and originV ector( : b4) = \u3008 : b3, : b2, : b1, a\u3009, and originV ector( : b5) = \u3008 : b4, : b3, : b2, : b1\u3009, and originV ector( : bi) 6\u223c= originV ector( : bj), for 1 \u2264 i 6= j \u2264 5, and hence, by definition, QSC is safe with a terminating dChase. It can be noticed that during each distinct application of r1, the vector of constants bound to the vector of variables \u3008x11, . . . , x14\u3009 are different w.r.t \u223c=. Safe quad-systems in this way are capable of recognizing such positive cases of finite dChases (which are classified as negative cases by msafe quadsystems) by also keeping track of the origin vectors of Skolem blank-nodes in their dChases.\nThe following property shows that for a safe quad-system, the descendance graph of any Skolem blank node in its dChase is a directed acyclic graph (DAG):\nProperty 2 (DAG property). For a safe (csafe, msafe) quad-system QSC, and for any blank node b \u2208 Bsk(dChase(QSC)), its descendance graph is a DAG.\nProof. By construction, as there exists no descendant for any constant k \u2208 C(QSC), there cannot be any out-going edge from any such k. Hence, no member of C(QSC) can be involved in cycles. Therefore, the only members that can be involved in cycles are the members of C(dChase(QSC))\u2212C(QSC) =Bsk(dChase(QSC)). But if there exists : b \u2208 Bsk(dChase(QSC)), such that there exists a cycle through : b, then this implies that : b is a descendant of : b. This would violate the prerequisites of being safe (resp. csafe, resp. msafe), and imply that QSC is unsafe (resp. uncsafe, resp. unmsafe), which is a contradiction.\nAlgorithm 1: UnRavel (Descendance Graph G) /* procedure to unravel, a descendance graph into a tree */ Input : descendance graph G = \u3008V,E, \u03bbr , \u03bbv , \u03bbc\u3009 Output: A labeled Tree G begin\nG = \u3008V,E, \u03bbr, \u03bbv , \u03bbc\u3009 := RemoveTranstiveEdges(G); foreach Node vo \u2208 preOrder(G) do\nif (k = indegree(vo)) > 1 then {v1, ..., vk} :=getFreshNodes();/* each vi 6\u2208 V is fresh */ /* replace old node vo by the fresh nodes in V */ removeNodeFrom(vo, V ); addNodesTo({v1, ..., vk}, V ); foreach (vo, v\u2032) \u2208 E do\n/* replace each outgoing edge from vo with a fresh outgoing edges from each fresh node vi */ removeEdgeFrom((vo, v \u2032), E); addEdgesTo({(v1, v \u2032), ..., (vk, v \u2032)}, E);\ni := 1; foreach (v\u2032, vo) \u2208 E do\n/* replace each incoming edge of vo with an incoming edge for a unique vi */ removeEdgeFrom((v\u2032, vo), E); addEdgeTo((v\u2032, vi), E); i++;\n/* restrict node labels to the updated set of nodes in V */ \u03bbr := \u03bbr |V , \u03bbv := \u03bbv |V , \u03bbc := \u03bbc|V ; return G;\nSince the descendance graph G of any Skolem blank node : b \u2208 Bsk(dChase(QSC)) is such that G is rooted at : b and is acyclic, any directed path from : b terminates at some node. Hence, one can use a tree traversal technique, such as preorder (visit a node first and then its children) to sequentially traverse nodes in G. Algorithm 1 takes a descendance graph G and unravels it into a tree. The algorithm first removes all the transitive edges from G, i.e. if there are v, v\u2032 \u2208 V with (v, v\u2032) \u2208 E and G contains a path of length greater than 1 from v to v\u2032, then it removes (v, v\u2032). Note that, in the resulting graph, the presence of a path from v to v\u2032\u2032 still gives us the information that v\u2032\u2032 is a descendant of v. The algorithm then traverses the graph in preorder fashion, as it encounters a node v, if v has an indegree k greater than one, it replaces v with k fresh nodes v1, ..., vk, and distributes the set of edges incident to v across v1, ..., vk, such that (i) each vi has at-most one incoming edge (ii) all the edges incident to v are incident to some vi, i \u2208 {1, . . . , k}. Outgoing edges of v are copied for each vi. Hence, after the above operation each vi has an indegree 1, whereas outdegree of vi is same as the outdegree of v, i \u2208 {1, . . . , k}. Hence, after all the nodes are visited, every node except the root in the new graph G has an indegree 1. G is still rooted, connected, acyclic, and is hence a tree. The algorithm terminates as there are no cycles in the graph, and at some point reaches a node with no children. For instance, the unraveling of the descendance graph of :b4 in Fig. 1 is shown in Fig. 2. The following property holds for any Skolem blank node of a safe quad-system.\nProperty 3. For a safe quad-system QSC = \u3008QC , R\u3009, and any Skolem blank node in dChase(QSC), the unraveling (Algorithm 1) of its descendance graph results in a tree t = \u3008V , E, \u03bbr , \u03bbv , \u03bbc\u3009 s.t.:\n1. any leaf node of t is from the set C(QSC), 2. any non-leaf node of t is from Bsk(dChase(QSC)), 3. order(t) \u2264 w, where w =maxr\u2208R|fr(r)|, 4. there cannot be a path between b 6= b\u2032 \u2208 V , with \u03bbr(b) = \u03bbr(b\u2032) and \u03bbv(b) \u223c=\n\u03bbv(b \u2032),\n5. there cannot be a path between b 6= b\u2032 \u2208 V , with \u03bbr(b) = \u03bbr(b\u2032), if QSC is also msafe, 6. there cannot be a path between b 6= b\u2032 \u2208 V , with \u03bbc(b) = \u03bbc(b\u2032), if QSC is also csafe.\nProof. 1. Any node n in the descendance graph is such that n \u2208 C(dChase(QSC)), and C(dChas- e(QSC)) = C(QSC) \u228e Bsk(dChase(QSC)). Since any member m \u2208 Bsk(dChase(QSC)) is generated from an application of a BR with an assignment \u00b5 such that its frontier variables are assigned by \u00b5 with a set of constants, m has at-least one child. But, since n is a leaf node, n \u2208 C(QSC).\n2. Since no member m \u2208 C(QSC) can have descendants and any non-leaf node has children, m cannot be a non-leaf node. Hence, non-leaf nodes must be from Bsk(dChase( QSC)). 3. The order of t is the maximal outdegree among the nodes of t, and outdegree of a node is the number of children it has. Since any node in t with non-zero outdegree is a Skolem blank-node : b generated by application of an assignment \u00b5 to r =\nbody(r)(x, z)\u2192 head(r)(x, y) \u2208 R, the number of children : b has equals \u2016x\u2016. Hence the order of t is bounded by w. 4. Since any path from b to b\u2032 implies that b\u2032 is a descendant of b, it must be the case that \u03bbr(b) 6= \u03bbr(b\u2032) or \u03bbv(b) 6\u223c= \u03bbv(b\u2032), otherwise safety condition would be violated.\n5. Similar as above, immediate by definition. 6. Similar as above, immediate by definition.\nThe property above is exploited to show that there exists a finite bound in the dChase size and its computation time.\nLemma 3. For any safe/msafe/csafe quad-systemQSC = \u3008QC , R\u3009, the following holds: (i) the dChase size \u2016dChase(QSC)\u2016 = O(22\n\u2016QSC\u2016), (ii) dChase(QSC) can be computed in 2EXPTIME, (iii) if \u2016R\u2016 and the set of schema triples in QC is fixed to a constant, then \u2016dChase(QSC)\u2016 is a polynomial in \u2016QSC\u2016 and can be computed in PTIME.\nProof. The proofs are provided for safe quad-systems, but since CSAFE \u2282 MSAFE \u2282 SAFE and since we are giving upper bounds, they also propagate trivially to msafe and csafe quad-systems.\n(i) For any Skolem blank node in dChase(QSC), the size of its originVector is upper bounded by w = maxr\u2208R|fr(r)|. If S is the set of all origin vectors of blanknodes in dChase(QSC), then cardinality of the set S\u2032 = S\\ \u223c= is upper bounded by (|U(QSC)| + |L(QSC)| + w)\nw , which means that |S\u2032| = O(2\u2016QSC\u2016). Also, since the set of origin ruleId labels, Rids, can at most be |R|, the cardinality of the set Rids\u00d7S\u2032 =O(2\u2016QSC\u2016). For the descendance tree t of any Skolem blank node of dChase(QSC), since there cannot be paths in t between distinct b and b\u2032, such that originRuleId(b) = originRuleId(b\u2032) and originV ector(b) \u223c= originV ector(b\u2032), the length of any such path is upper bounded by |Rids \u00d7 S\u2032| = O(2\u2016QSC\u2016). However, it turns out that the above upper bound provided is loose, as there is the need of additional filter BRs to transform/back-propagate vectors of constants associated with Skolem blank nodes generated by repetitive application of the same BR. For instance, consider the set of BRs in eg: 2. The BR r1 transforms the origin vector to a new vector each time during its application. BRs r2 - r5 deals with back propagation of these vectors back to input origin vectors of BR r1. Such filter BRs rule out the case of a BR being applied to a quad that contains a Skolem blank node that was generated using the same BR on an isomorphic origin vector, ensuring that the safety criteria for Skolem blank-nodes generated is not violated. It turns out that the number of such filter BRs required is polynomial w.r.t. to the number of descendants with the same rule id, for a node in t. Hence, it turns out the depth of t is polynomially bounded by \u2016R\u2016. (Note that depth of t is bounded by |R| for msafe quad-systems. Also since, the set of origin context labels are bounded by the set of existential variables in R, depth of t is bounded by \u2016R\u2016 for csafe quad-systems.) Also order of the tree is bounded by w. Hence, any such tree can have at most O(2\u2016QSC\u2016) leaf nodes, O(2\u2016QSC\u2016) inner nodes, and O(2\u2016QSC\u2016) nodes. Since each of the leaf nodes can only be from C(QSC) and each of the inner nodes correspond to an existential variable in R, the number of such possible trees are clearly\nbounded double exponentially in \u2016QSC\u2016, hence bounds the number of Skolem blank nodes generated in the dChase.\n(ii) From (i) \u2016dChase(QSC)\u2016 is double exponential in \u2016QSC\u2016, and since each iteration add at-least one quad to its dChase, the number of iterations are bounded double exponentially in \u2016QSC\u2016. Also, by Lemma 1 any iteration i can be done in time O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016). Hence, by using (i), we get \u2016dChasei\u22121(QSC)\u2016 = O(22 \u2016QSC\u2016). Hence, we can infer that each iteration i can be done in timeO(2\u2016R\u2016\u22172\n\u2016QSC\u2016). Also since the number of iterations is at most double exponential, computing dChase(QSC) is in 2EXPTIME.\n(iii) Since \u2016R\u2016 is fixed to a constant, the set of existential variables is also a constant. In this case, since the size of the frontier of any r \u2208 R is also a constant, the order and depth of any descendant tree t of a Skolem blank node is a constant. Hence, the number of (leaf) nodes of t is bounded by a constant. Also in this setting, the label of inner nodes of t, which correspond to existential variables, is also a constant, and the leaf nodes of t can only be a constant in C(QSC). Hence, the number of descendant trees and consequentially, the number of Skolem blank nodes generated is bounded by O(|C(QSC)|z), where z is a constant. Hence, the set of constants generated in dChase(QSC) is a polynomial in \u2016QSC\u2016, and so is \u2016dChase(QSC)\u2016.\nSince in any dChase iteration except the final one, at least one quad is added, and also since the final dChase can have at most O(\u2016QSC\u2016z) triples, the total number of iterations are bounded by O(\u2016QSC\u2016z) (\u2020). By Lemma 1, since any iteration i can be computed in O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016) time, and since \u2016R\u2016 is a constant, the time required for each iteration is a polynomial in \u2016dChasei\u22121(QSC)\u2016, which is at most a polynomial in \u2016QSC\u2016. Hence, any dChase iteration can be performed in polynomial time in size of QSC (\u2021). From (\u2020) and (\u2021), it can be concluded that dChase can be computed in PTIME.\nLemma 4. For any safe/msafe/csafe quad-system, the following holds: (i) data complexity of CCQ entailment is in PTIME, (ii) combined complexity of CCQ entailment is in 2EXPTIME.\nProof. Note that the proofs are provided for safe quad-systems, but since CSAFE \u2282 MSAFE \u2282 SAFE and since we are giving upper bounds, they also propagate trivially to msafe and csafe quad-systems.\nGiven a safe quad-system QSC = \u3008QC , R\u3009, since dChase(QSC) is finite, a boolean CCQ CQ() can naively be evaluated by binding the set of constants in the dChase to the variables in the CQ(), and then checking if any of these bindings are contained in dChase(QSC). The number of such bindings can at most be \u2016dChase(QSC)\u2016\u2016CQ()\u2016 (\u2020). (i) Since for data complexity, the size of the BRs \u2016R\u2016, the set of schema triples, and \u2016CQ()\u2016 is fixed to a constant. From Lemma 3 (iii), we know that under the above mentioned settings the dChase can be computed in PTIME and is polynomial in the size of QSC . Since \u2016CQ()\u2016 is fixed to a constant, and from (\u2020), binding the set of constants in dChase(QSC) on CQ() still gives a number of bindings that is worst case polynomial in the size of \u2016QSC\u2016. Since membership of these bindings can checked in the polynomially sized dChase in PTIME, the time required for CCQ entailment is in PTIME.\n(ii) Since in this case \u2016dChase(QSC)\u2016 = O(22 \u2016QSC\u2016\n) (\u2021), from (\u2020) and (\u2021), binding the set of constants in dChase(QSC) to CQ() amounts to O(2\u2016CQ()\u2016\u22172\n\u2016QSC\u2016) number of bindings. Since the dChase is double exponential in \u2016QSC\u2016, checking the membership of each of these bindings can be done in 2EXPTIME. Hence, the combined complexity is in 2EXPTIME.\nTheorem 4. For any safe/msafe/csafe quad-system, the following holds: (i) The data complexity of CCQ entailment is PTIME-complete (ii) The combined complexity of CCQ entailment is 2EXPTIME-complete.\nProof. (i)(Membership) See Lemma 4 for the membership in PTIME. (Hardness) Follows from the PTIME-hardness of data complexity of CCQ entailment for Range-Restricted quad-systems (Theorem 8), which are contained in safe/msafe/csafe quad-systems. (ii) (Membership) See Lemma 4. (Hardness) See following heading."}, {"heading": "4.1 2EXPTIME-Hardness of CCQ Entailment", "text": "In this subsection, we show that the combined complexity of the decision problem of CCQ entailment for context acyclic quad-systems is 2EXPTIME-hard. We show this by reduction of the word-problem of a 2EXPTIME deterministic turing machine (DTM) to the CCQ entailment problem. We notify the reader that the technique we follow is, similar to works such as [35, 36], to iteratively generate a doubly exponential number of objects that represent the configurations and cells of the tape of the DTM, and then simulate its working by appropriate BRs. A DTM M is a tuple M = \u3008Q,\u03a3,\u2206, q0, qA\u3009, where\n\u2013 Q is a set of states, \u2013 \u03a3 is a finite set of letters that includes the blank symbol , \u2013 \u2206 : (Q \u00d7\u03a3) \u2192 (Q\u00d7\u03a3 \u00d7 {+1,\u22121}) is the transition function, \u2013 q0 \u2208 Q is the initial state. \u2013 qA \u2208 Q is the accepting state.\nW.l.o.g. we assume that there exists exactly one accepting state, which is also the lone halting state. A configuration is a word \u03b1 \u2208 \u03a3\u2217Q\u03a3\u2217. A configuration\u03b12 is a successor of the configuration \u03b11, iff one of the following holds:\n1. \u03b11 = wlq\u03c3\u03c3rwr and \u03b12 = wl\u03c3\u2032q\u2032\u03c3rwr, if \u2206(q, \u03c3) = (q\u2032, \u03c3\u2032, R), or 2. \u03b11 = wlq\u03c3 and \u03b12 = wl\u03c3\u2032q\u2032 , if \u2206(q, \u03c3) = (q\u2032, \u03c3\u2032, R), or 3. \u03b11 = wl\u03c3lq\u03c3wr and \u03b12 = wlq\u2032\u03c3l\u03c3\u2032wr, if \u2206(q, \u03c3) = (q\u2032, \u03c3\u2032, L).\nwhere q, q\u2032 \u2208 Q, \u03c3, \u03c3\u2032, \u03c3l, \u03c3r \u2208 \u03a3, and wl,wr \u2208 \u03a3\u2217. Since number of configurations can at most be doubly exponential in the size of the input string, and since 2EXPTIME \u2286 2EXPSPACE, the number of tape cells traversed by the DTM tape head is also bounded double exponentially. A configuration c = wlqwr is an accepting configuration iff q = qA. A language L \u2286 \u03a3\u2217 is accepted by a 2EXPTIME bounded DTM M , iff for every w \u2208 L, M accepts w in time O(22 \u2016w\u2016 ).\nSimulating DTMs using Safe Quad-Systems Consider a double exponential time bounded DTM M = \u3008Q,\u03a3,\u2206, q0, qA\u3009, and a string w, with \u2016w\u2016 = m. Suppose that M terminates in 22 n\ntime, where n =mk, k is a constant. In order to simulate M , we construct a quad-system QSMC = \u3008Q M C , R\u3009, where C = {c0, c1, ..., cn}, whose various elements represents the constructs of M . Let QMC be initialized with the following quads:\nc0 : (k0,rdf:type, R), c0 : (k1,rdf:type, R), c0 : (k0,rdf:type,min0),\nc0 : (k1,rdf:type,max0), c0 : (k0, succ0, k1)\nNow for each pair of elements of type R in ci, a Skolem blank-node is generated in ci+1, and hence follows the recurrence relation r(j +1) = [r(j)]2, with seed r(0) = 2, which after n iterations yields 22 n\n. In this way, a doubly exponentially long chain of elements is created in cn using the following set of rules:\nci : (x0,rdf:type, R), ci : (x1,rdf:type, R) \u2192 \u2203y ci+1 : (x0, x1, y),\nci+1 : (y,rdf:type, R) (eBr)\nThe combination of the minimal element with the minimal element (elements of type mini) in ci create the minimal element in ci+1, and similarly the combination of the maximal element with the maximal element (elements of type maxi) in ci create the maximal element of ci+1:\nci+1 : (x0, x0, x1), ci : (x0,rdf:type,mini) \u2192 ci+1 : (x1,rdf:type,mini+1)\nci+1 : (x0, x0, x1), ci : (x0,rdf:type,maxi) \u2192 ci+1 : (x1,rdf:type,maxi+1)\nThe successor relation succi+1 is created in ci+1 using the following set of rules, using the well-known integer counting technique:\nci : (x1, succi, x2), ci+1 : (x0, x1, x3), ci+1 : (x0, x2, x4) \u2192 ci+1 : (x3, succi+1, x4)\nci : (x1, succi, x2), ci+1 : (x1, x3, x5), ci+1 : (x2, x4, x6), ci : (x3,rdf:type,\nmaxi), ci : (x4,rdf:type,mini) \u2192 ci+1 : (x5, succi+1, x6)\nEach of the above set of rules are instantiated for 0 \u2264 i < n, and in this way after n generating dChase iterations, cn has doubly exponential number of elements of type R, that are ordered linearly using the relation succn. By virtue of the first rule below, each of the objects representing the cells of the DTM are linearly ordered by the relation succ. Also the transitive closure of succ is defined as the relation succt\ncn : (x0, succn, x1) \u2192 cn : (x0, succ, x1)\ncn : (x0, succ, x1) \u2192 cn : (x0, succt, x1)\ncn : (x0, succt, x1), cn : (x1, succt, x2) \u2192 cn : (x0, succt, x2)\nAlso using a similar construction, we can reuse the 22 n\u22121\nlinearly ordered elements in cn\u22121 to create another linearly ordered chain of a doubly exponential number of objects in cn that represents configurations of M , whose minimal element is of type conInit, and the linear order relation being conSucc.\nVarious triple patterns that are used to encode the possible configurations, runs and their relations in M are:\n(x0, head, x1) denotes the fact that in configuration x0, the head of the DTM is at cell x1. (x0, state, x1) denotes the fact that in configuration x0, the DTM is in state x1. (x0, \u03c3, x1) where \u03c3 \u2208 \u03a3, denotes the fact that in configuration x0, the cell x1 contains\n\u03c3. (x0, succ, x1) denotes the linear order between cells of the tape. (x0, succt, x1) denotes the transitive closure of succ. (x0, conSucc, x1) to denote the fact that x1 is a successor configuration of x0. (x0,rdf:type, Accept) denotes the fact that the configuration x0 is an accepting\nconfiguration.\nSince in our construction, each \u03c3 \u2208 \u03a3 is represented as a relation, we could constrain that no two letters \u03c3 6= \u03c3\u2032 are on the same cell using the following axiom:\ncn : (z1, \u03c3, z2), cn : (z1, \u03c3 \u2032, z2) \u2192\nfor each \u03c3 6= \u03c3\u2032 \u2208 \u03a3. Note that the above BR has an empty head, is equivalent to asserting the negation of its body.\nInitialization Suppose the initial configuration is q0w , where w = \u03c30...\u03c3n\u22121, then we enforce this using the following BRs in our quad-system QSMC as:\ncn : (x0,rdf:type, conInit), cn : (x1,rdf:type,minn) \u2192 cn : (x0, head, x1),\ncn : (x0, state, q0)\ncn : (x0,rdf:type,minn) \u2227 n\u22121 \u2227\ni=0\ncn : (xi, succ, xi+1) \u2227 cn : (xj ,rdf:type,\nconInit) \u2192 n\u22121 \u2227\ni=0\ncn : (xj , \u03c3i, xi) \u2227 cn : (xj , , xn)\ncn : (xj ,rdf:type, conInit), cn : (xj , , x0), cn : (x0, succt, x1) \u2192 cn : (xj , , x1)\nThe last BR copies the to every succeeding cell in the initial configuration.\nTransitions For every left transition \u2206(q, \u03c3) = (qj , \u03c3\u2032, \u22121), the following BR:\ncn : (x0, head, xi), cn : (x0, \u03c3, xi), cn : (x0, state, q), cn : (xj , succ, xi), cn : (x0, conSucc, x1) \u2192 cn : (x1, head, xj), cn : (x1, \u03c3 \u2032, xi), cn : (x1, state, qj)\nFor every right transition \u2206(q, \u03c3) = (qj , \u03c3\u2032,+1), the following BR:\ncn : (x0, head, xi), cn : (x0, \u03c3, xi), cn : (x0, state, q), cn : (xi, succ, xj), cn : (x0, conSucc, x1) \u2192 cn : (x1, head, xj), cn : (x1, \u03c3 \u2032, xi), cn : (x1, state, qj)\nInertia If in any configuration the head is at cell i of the tape, then in every successor configuration, elements in preceding and following cells of i in the tape are retained. The following two BRs ensures this:\ncn : (x0, head, xi), cn : (x0, conSucc, x1), cn : (xj , succt, xi), cn : (x0, \u03c3, xj)\n\u2192 cn : (x1, \u03c3, xj)\ncn : (x0, head, xi), cn : (x0, conSucc, x1), cn : (xi, succt, xj), cn : (x0, \u03c3, xj)\n\u2192 cn : (x1, \u03c3, xj)\nThe rules above are instantiated for every \u03c3 \u2208 \u03a3.\nAcceptance A configuration whose state is qA is accepting:\ncn : (x0, state, qA) \u2192 cn : (x0,rdf:type, Accept)\nIf a configuration of accepting type is reached, then it can be back propagated to the initial configuration, using the following BR:\ncn : (x0, conSucc, x1), cn : (x1,rdf:type, Accept) \u2192 cn : (x0,rdf:type, Accept)\nFinally M accepts w iff the initial configuration is an accepting configuration. Let CQM be CCQ: \u2203y cn : (y, rdf:type, conInit), cn : (y, rdf:type, Accept). It can easily be verified that QSMC |= CQ\nM iff the initial configuration is an accepting configuration. In order to prove the soundness and completeness of our simulation, we prove the following claims:\nClaim. (1) The quad-system QSMC in the aforementioned simulation is a csafe quadsystem\nIt can be noted that the only BRs in which existentials are present are the BRs used to generate the double exponential chain of tape cells and configurations, and are of the form (eBr). Note that in each of application of such a BR, a blank-node : b generated in a context ci, for any i = 1, . . . , n, is such that originContexts( : b) = {ci} and has exactly two child blank-nodes, each of whose origin contexts is {ci\u22121}. Hence, any Skolem blank-node generated in any ci, for i = 1 . . . n is such that its child blank-nodes has origin contexts ci\u22121. Thanks to the above property, it turns out that there exists no two blank-nodes : b, : b\u2032 in the dChase of QSMC such that : b is a descendant of : b \u2032 and originContexts( : b) = originContexts( : b\u2032). Therefore QSMC is csafe.\nClaim. (2) QSMC |= CQ M iff M accepts w.\nSuppose thatQSMC |=CQ M , then by Theorem 1, there exists an assignment\u00b5 : V(CQM ) \u2192 C, with CQM [\u00b5] \u2286 dChase(QSC). This implies that there exists a constant o in C(dChase(QSC)), with {cn : (o, rdf:type,Accept), cn : (o, rdf:type, conInit)} \u2286 dChase(QSC . But thanks to the acceptance axioms it follows that there exists an constant o\u2032 such that {cn : (o, conSucc, o1), cn : (o1, conSucc, o2), . . . , cn : (on, conSucc, o\u2032)} \u2286 dChase(QSC), and cn : (o\u2032, rdf:type, Accept) \u2208 dChase(QSC).\nAlso thanks to the initialization axioms, it can be seen that o represents the initial configuration of M i.e. it represents the configuration in which the initial state is q0, and the left end of the read-write tape contains w followed by trailing s, with the read-write head positioned at the first cell of the tape. Also the transition axioms makes sure that if cn : (o, conSucc, o\n\u2032\u2032) \u2208 dChase(QSC), then o\u2032\u2032 represents a successor configuration of o. That is, if o represents the configuration in which M is at state q with read-write head at position pos of the tape that contains a letter \u03c3 \u2208 \u03a3, and if \u2206(q, \u03c3) = (q\u2032, \u03c3\u2032, D), then o\u2032\u2032 represents the configuration in which M is at state q\u2032, in which read-write head is at the position pos \u2212 1/pos + 1 depending on whether D = \u22121/ + 1, and \u03c3\u2032 is at the position pos of the tape. As a consequence of the above arguments, it follows that o\u2032 represents an accepting configuration of M , i.e. a configuration in which the state is qA, the lone accepting, halting state. This means that M accepts the string w.\nFor the converse, we briefly show that if QSMC 6|= CQ M then M does not accept w. Suppose that QSMC 6|= CQ M , then by Theorem 1, for every assignment \u00b5 : V(CQM ) \u2192C, it should be the case that CQM [\u00b5] 6\u2286 dChase(QSC). By the initialization axioms, we know that there exists a constant o \u2208 C(dChase(QSC)) with cn : (o, rdf:type, conInit) \u2208 dChase(QSC). We know that o represents the initial configuration of M . Also by the initial construction axioms of QSMC , we know that o is the initial element of a double exponential chain of objects that are linearly ordered by property symbol conSucc. From transition axioms we know that, if, for any o\u2032\u2032, cn : (o, conSucc, o\u2032\u2032) \u2208 dChase(QSC), then o\u2032\u2032 represents a valid successor configuration of o, which itself holds for o\u2032\u2032, and so on. This means that for none of the succeeding double exponential configurations of M , the accepting state qA holds. This means that M does not reach an accepting configuration with string w, and hence rejects it.\nSince the construction above shows the existence of a polynomial time reduction of the word problem of a 2EXPTIME DTM, which is a 2EXPTIME-hard problem, to the CCQ entailment problem over csafe quad-systems, it immediately follows that CCQ entailment over csafe/msafe/safe quad-systems is 2EXPTIME-hard."}, {"heading": "4.2 Procedure for detecting safe/msafe/csafe quad-systems", "text": "In this subsection, we present a procedure for deciding whether a given quad-system is safe (resp. msafe, resp. csafe) or not. If the quad-system is safe (resp. msafe, resp. csafe), the result of the procedure is a safe dChase (resp. msafe dChase, csafe dChase) that contains the standard dChase, and can be used for query answering. Since the safety (resp. msafety, resp. csafety) property of a quad-system is attributed to the dChase of the quad-system, the procedure nevertheless performs the standard operations for computing the dChase, but also generate quads that indicate origin ruleIds and origin vectors (resp. origin ruleIds, resp. origin-contexts) of each Skolem blank node generated. In each iteration, a test for safety is performed, by checking the presence of Skolem blank-nodes that violate the safety (resp. msafety, resp. csafety) condition. In case a violation is detected, a distinguished quad is generated and the safe (resp. msafe, resp. csafe) dChase construction is aborted, prematurely. On the contrary, if there exists an iteration in which no new quad is generated, the safe (resp. msafe, resp. csafe) dChase computation stops with a completed safe (resp. msafe, resp. csafe) dChase that contains\nthe standard dChase. Since all the additional quads produced for accounting information use a distinguished context identifier cc 6\u2208 C, the computed safe (resp. msafe, resp. csafe) dChase itself can be used for standard query answering. Before geting to the details of the procedure, we give a few necessary definitions.\nDefinition 7 (Context Scope). The context scope of a term t in a set of quad-patterns Q, denoted by cScope(t, Q) is given as: cScope(t, Q) = {c | c : (s, p, o) \u2208 Q, s = t \u2228 p = t \u2228 o = t}.\nFor any quad-system QSC = \u3008QC , R\u3009, let cc be an ad hoc context identifier such that cc 6\u2208 C, then for ri = body(ri)(x, z)\u2192 head(ri)(x, y) \u2208R, we define transformations augS(ri), augM(ri), augC(ri) as follows:\naugS(ri) = body(ri)(x, z) \u2192 head(ri)(x,y) \u2227 \u2200yj \u2208 {y} [ \u2227\nxk\u2208{x}\ncc : (xk,\ndescendantOf, yj) \u2227 cc : (yj , descendantOf, yj) \u2227 cc : (yj , originRuleId, i) \u2227\ncc : (yj , originVector,x)]\nIt should be noted that cc : (yj , originVector, x) is not a valid quad pattern, and is only used for notation brevity. In the actual implementation, vectors can be stored using an rdf container data structure such as rdf:List, rdf:Seq or by typecasting it as a string.\naugM(ri) = body(ri)(x, z) \u2192 head(ri)(x,y) \u2227 \u2200yj \u2208 {y} [ \u2227\nxk\u2208{x}\ncc : (xk,\ndescendantOf, yj) \u2227 cc : (yj , descendantOf, yj) \u2227 cc : (yj , originRuleId, i)]\naugC(ri) = body(ri)(x, z) \u2192 head(ri)(x,y) \u2227 \u2200yj \u2208 {y} [ \u2227\nxk\u2208{x}\ncc : (xk,\ndescendantOf, yj) \u2227 cc : (yj , descendantOf, yj) \u2227 \u2227\nc\u2208cScope(yj,head(ri))\ncc : (yj ,\noriginContext, c)]\nIntuitively, the transformation augS/augM/augC on a BR ri, augments the head part of ri with additional types of quad patterns, which are the following:\n1. cc : (xk, descendantOf, yj), for every existentially quantified variable yj in y and universally quantified variablexk \u2208 {x}. This is done because, during dChase computation any application of an assignment \u00b5 to ri such that x[\u00b5] = a, resulting in the generation of a Skolem blank node : b = \u00b5ext(y)(yj), any ai \u2208 {a} is a descendant of : b. Hence, due to these additional quad-patterns, quads of the form cc : (ai, descendantOf, : b) are also produced, and in this way, keeps track of the descendants of any Skolem blank node produced. 2. cc : (yj , descendantOf, yj), in order to maintain also the reflexivity of \u2018descendantOf\u2019 relation.\n3. cc : (yj , originContext, c), for every existentially quantified variable yj in {y}, every c \u2208 cScope(yj , head(ri)). This is done because during dChase computation, any application of an assignment \u00b5 on ri, such that x[\u00b5] = a, resulting in the generation of a Skolem blank node : b = \u00b5ext(y)(yj), c is an origin context of : b. Hence due to these additional quad-patterns, quads of the form cc : ( : b, originContext, c) is also produced. In this way, we keep track of the origin-contexts of any Skolem blank node produced. 4. cc : (yj , originVector, x), This is done because during the dChase computation, for any application of an assignment \u00b5 on ri, such that x[\u00b5] = a, resulting in the generation of a Skolem blank node : b = \u00b5ext(y)(yj), a is the origin vector of : b. Hence, due to these additional quad-patterns, quads of the form cc : ( : b, originVector, a) is also produced. In this way, we keep track of the origin vector of any Skolem blank node produced. 5. cc : (yj , originRuleId, i), for every existentially quantified variable yj in {y}, inorder to keep track of the ruleId of the BR used to create any Skolem blank node.\nIt can be noticed that for any BR ri without existentially quantified variables, the transformations augS/augM/augC leaves ri unchanged. For any set of BRs R, let\naugS(R) (resp. augM(R), resp. augC(R)) = \u22c3\nri\u2208R\naugS(ri) (resp. augM(ri),\nresp. augC(ri)) \u222a {cc : (x1, descendantOf, z1) \u2227 cc : (z1, descendantOf, x2)\n\u2192 cc : (x1, descendantOf, x2)}\nThe function unSafeTest (resp. unMSafeTest, resp. unCSafeTest) defined below, given a BR ri = body(ri)(x, z) \u2192 head(ri)(x, y), an assignment \u00b5, and a quad-graph Q checks, if application of \u00b5 on ri violates the safety (resp. msafety, resp. csafety) condition on Q. unSafeTest(ri, \u00b5,Q)=True iff \u2203 : b, : b\u2032 \u2208 B, with all the following conditions being satisfied:\n\u2013 : b \u2208 {x[\u00b5]}, and \u2013 cc : ( : b\u2032, descendantOf, : b) \u2208 Q, and \u2013 cc : ( : b\u2032, originRuleId, i) \u2208 Q, and \u2013 cc : ( : b\u2032, originVector,a) \u2208 Q, and a \u223c= x[\u00b5].\nIntuitively, unSafeTest returns True, if \u00b5 applied to ri will produce a fresh Skolem blank node : b\u2032\u2032, whose child : b \u2208 {x[\u00b5]}, and according to knowledge in Q, : b\u2032 is a descendant of : b such that the origin ruleId of : b\u2032 is i (which is also the origin ruleId of : b\u2032\u2032) and the origin vector of : b\u2032 is isomorphic to the origin vector of x[\u00b5] (which is also the origin vector of : b\u2032\u2032). The functions unMSafeTest and unCSafeTest are similarly defined as follows: unMSafeTest(ri, \u00b5, Q)=True iff \u2203 : b, : b\u2032 \u2208 B, with all the following conditions being satisfied:\n\u2013 : b \u2208 {x[\u00b5]}, and \u2013 cc : ( : b\u2032,descendantOf, : b) \u2208 Q, and\n\u2013 cc : ( : b\u2032, originRuleId, i) \u2208 Q.\nunCSafeTest(ri, \u00b5, Q)=True iff \u2203 : b, : b\u2032 \u2208 B, \u2203yj \u2208 {y}, with all the following being satisfied:\n\u2013 : b \u2208 {x[\u00b5]}, and \u2013 cc : ( : b\u2032, descendantOf, : b) \u2208 Q, and \u2013 {c | cc : ( : b\u2032, originContext, c) \u2208 Q} = cScope( yj , head(ri)(x, y)) \\ {cc}.\nFor any BR ri and an assignment \u00b5, the safe/msafe/csafe application of \u00b5 on ri w.r.t. a quad-graph QC is defined as follows:\napplysafe(ri, \u00b5,QC) =\n{\nunSafe, If unSafeTest(ri, \u00b5,QC) = True; apply(ri, \u00b5), Otherwise;\napplymsafe(ri, \u00b5,QC) =\n{\nunMSafe, If unMSafeTest(ri, \u00b5,QC) = True; apply(ri, \u00b5), Otherwise;\napplycsafe(ri, \u00b5,QC) =\n{\nunCSafe, If unCSafeTest(ri, \u00b5,QC) = True; apply(ri, \u00b5), Otherwise;\nwhere unSafe= cc : (unsafe, unsafe, unsafe) (resp. unMSafe = cc : (unmsafe, unmsafe, unmsafe), resp. unCSafe = cc : (uncsafe, uncsafe, uncsafe)) is a distinguished quad that is generated, if the prerequisites of safety (resp. msafety, resp. csafety) is violated. For any quad-system QSC = \u3008QC , R\u3009, we define its safe dChase dChasesafe(QSC) as follows:\ndChasesafe0 (QSC) = QC ; dChase safe m+1(QSC) = dChase safe m (QSC) \u222a apply safe(ri, \u00b5, dChasesafem (QSC)), if \u2203 ri \u2208 augS(R), assignment\u00b5 such that applicableaugS(R)(ri, \u00b5, dChasesafem (QSC));\ndChasesafem+1(QSC) = dChase safe m (QSC), otherwise; for any m \u2208 N. dChasesafe(QSC) = \u22c3 m\u2208N dChase safe m (QSC)\nThe termination condition for safe dChase computation can be implemented using the following conditional: If there exists m such that\ndChasesafem (QSC) = dChase safe m+1(QSC); then dChasesafe(QSC) = dChase safe m (QSC).\nThe dChases dChasemsafe(QSC) and dChasecsafe(QSC) are defined, similarly, for msafe and csafe quad-systems, respectively. We bring to the notice of the reader that although application of any augS(r) (resp. augM(r), resp. augC(r)) produces quad-patterns of the form cc : ( : b, descendantOf, : b), for any Skolem blank node : b generated, there is no raise of a false alarm in the unSafeTest (resp. unMSafeTest, resp. unCSafeTest). This is because unSafeTest (resp. unMSafeTest, resp. unCSafeTest) on a bridge rule r = body(r)(x, z) \u2192 head(r)(x, y) and assignment \u00b5 checks if the application of \u00b5 of r with the fresh : b\u2032\u2032 assigned to a yi \u2208 {y} by \u00b5ext(y) would have a child : b 6= b\u2032\u2032 assigned to some xi \u2208 {x} by \u00b5, such that there exists a quad of the form cc : ( : b\u2032, descendantOf, : b) in the safe (resp. msafe, resp. csafe) dChase constructed so far, and : b\u2032\u2032 and : b\u2032 have the same origin ruleId and originVector (resp. originRuleId, resp. originContexts). Note that in the above : b\u2032 should also be distinct from : b\u2032\u2032, and hence rules out the case in which unSafeTest (resp. unMSafeTest, resp. unCSafeTest) returns True because of the detection of a blank node as a self descendant of itself.\nThe following theorem shows that the procedure above described for detecting unsafe quad-systems is sound and complete:\nTheorem 5. For any quad-system QSC = \u3008QC , R\u3009, the quad unSafe (resp. unMSafe, resp. unCSafe) \u2208 dChasesafe(QSC) (resp. dChasemsafe(QSC), resp. dChasecsafe(QSC)), iff QSC is unsafe (resp. unmsafe, resp. uncsafe).\nIt should be noted that for any quad-system QSC = \u3008QC , R\u3009, dChasesafe(QSC) (resp. dChasemsafe(QSC), resp. dChasecsafe(QSC)) is a finite set and hence the iterative procedure which we described earlier terminates, regardless of whether QSC is safe (resp. msafe, resp. csafe) or not. This is because if QSC is safe (resp. msafe, resp. csafe), then, as we have seen before, there exists a double exponential bound on number of quads in its dChase. Hence, there is an iteration in which no new quad is generated, which leads to stopping of computation. Otherwise, if QSC is unsafe (resp. msafe, resp. csafe), then from Theorem 5, we know that the quad unSafe (resp. unMSafe, resp. unCSafe) gets generated in dChasesafe(QSC) (resp. dChasemsafe(QSC), resp. dChasecsafe(QSC)) in not more than O(22\n\u2016QSC\u2016) iterations. This implies that there exists an iteration m such that the quad unSafe (resp. unMSafe, resp. unCSafe) is in dChasesafem (QSC) (resp. dChasemsafem (QSC), resp. dChase csafe m (QSC)). W.l.o.g, let m be the first such iteration. This means that there exists a BR ri \u2208 R with head head(ri)(x, y), assignment \u00b5 such that applicableaugS(R)(ri, \u00b5, dChasesafem\u22121(QSC)) (resp. applicableaugM(R)(ri, \u00b5, dChasemsafem\u22121(QSC)), resp. applicableaugC(R)(ri, \u00b5, dChase csafe m\u22121(QSC)) holds. By construction, since head(ri)[\u00b5ext(y)] is not generated, and instead the quad unSafe (resp. unMSafe, resp. unCSafe) is generated, applicableaugS(R)(ri, \u00b5, dChasesafem (QSC)) (resp. applicableaugM(R)(ri, \u00b5, dChasemsafem (QSC)), resp. applicableaugC(R)( ri, \u00b5, dChasecsafem (QSC)) holds yet again. This means that the termination condition is satisfied at iteration m + 1, and hence computation stops. Note that regardless of whether a given quad-system is safe (resp. msafe, resp. csafe) or not, the number of safe (resp. msafe, resp. csafe) dChase iterations is double exponentially bounded in the size of the quad-system. Consequently, we derive the following theorem.\nTheorem 6. Recognizing whether a quad-system is safe/msafe/csafe is in 2EXPTIME.\nAlso notice that after running procedure described above, if the quad unSafe (resp. unMSafe, resp. unCSafe) is not generated, then its safe (resp. msafe, resp. csafe) dChase itself can be used for CCQ answering, as in such a case the standard dChase is contained in safe (resp. msafe, resp. csafe) dChase, and all the quads generated for accounting information have the context identifier cc. Hence, for any safe (resp. msafe, resp. csafe) quad-system, for any boolean CCQ that does not contain quad patterns of the form cc : (s, p, o), the dChase entails CCQ iff the safe (resp. msafe, resp. csafe) dChase entails CCQ.\nA set of BRs R is said to be universally safe (resp. msafe, resp. csafe) iff, for any quad-graph QC , the quad-system \u3008QC , R\u3009 is safe (resp. msafe, resp. csafe). For any set of BRs R, whose set of context identifiers is C, also let UR be the set of URIs that occur in the triple patterns of R plus an additional ad hoc blank node : bcrit, the critical quad-graph of R is defined as the set {c : (s, p, o)|c \u2208 C, {s, p, o} \u2286 UR}. The following property illustrates how the critical quad-graph of a set of BRs R can be used to determine, whether or not R is universally safe/msafe/csafe.\nProperty 4. A set of BRs R is universally safe (resp. msafe, resp. csafe) iff \u3008QcritC , R\u3009 is safe (resp. msafe, resp. csafe), where QcritC is the critical quad-graph of R."}, {"heading": "5 Range Restricted Quad-Systems: Restricting to Range Restricted BRs", "text": "In this section, we investigate the complexity of CCQ entailment over quad-systems, whose BRs do not have existentially quantified variables. Such BRs are of the form:\nc1 : t1(x, z) \u2227 ... \u2227 cn : tn(x, z) \u2192 c \u2032 1 : t \u2032 1(x) \u2227 ... \u2227 c \u2032 m : t \u2032 m(x)\nNote that any set of BRs R of the form above can be replaced by semantically equivalent set R\u2032, such that each r \u2208 R\u2032 is the form:\nc1 : t1(x, z), ..., cn : tn(x, z) \u2192 c \u2032 1 : t \u2032 1(x) (5)\nAlso \u2016R\u2032\u2016 is at most quadratic in \u2016R\u2016, and hence, w.l.o.g, we assume that each r \u2208 R is of the form (5). Borrowing the parlance from the \u2200\u2203 rules setting, where rules whose variables in the head part are contained in the variables in the body part are called range restricted rules [15], we call such BRs range restricted (RR) BRs. We call a quad-system whose BRs are all of RR-type, a RR quad-system. Since there exists no existentially quantified variable in the BRs of a RR quad-system, no Skolem blank node is produced during dChase computation. Hence, there can be no violation of the safety/msafety/csafety condition in section 4, and hence, the class of RR quad-systems are contained in the class of safe/msafe/csafe quad-systems, and is also a FEC. Of course, this containment is strict as any quad-system that contains a BR with an existential variable is not RR. Since one can determine whether or not a given quad-system is RR or not by simply iterating through set of BRs and checking their syntax, the following holds:\nTheorem 7. Recognizing whether a quad-system is RR can be done in linear time.\nIn the following, we see that restricting to RR BRs, size of the dChase becomes polynomial w.r.t. size of the input quad-system, and the complexity of CCQ entailment further reduces compared to safe/msafe/csafe quad-systems.\nLemma 5. For any RR quad-systemQSC = \u3008QC , R\u3009, the following holds: (i) \u2016dChase(QSC)\u2016 = O(\u2016QSC\u20164) (ii) dChase(QSC) can be computed in EXPTIME (iii) If \u2016R\u2016 is fixed to be a constant, dChase(QSC) can be computed in PTIME.\nProof. (i) Note that the number of constants in QSC is roughly equal to \u2016QSC\u2016. As no existential variable occurs in any BR in a RR quad-system QSC , the set of constants C(dChase(QSC)) is contained in C(QSC). Since each c : (s, p, o) \u2208 dChase(QSC) is such that c, s, p, o \u2208 C(QSC), |dChase(QSC)|=O(|C(QSC )|4). Hence \u2016dChase(QSC)\u2016 = O(|C(QSC)|4) = O(\u2016QSC\u20164).\n(ii) Since from (i) |dChase(QSC)| = O(\u2016QSC\u20164), and in each iteration of the dChase at least one new quad is added, the number of iterations cannot exceedO(\u2016QSC\u20164).\nSince by Lemma 1, computation of each iteration i of the dChase requires O(|R| \u2217 \u2016dChasei\u22121(QSC)\u2016rs) time, where rs = maxr\u2208R\u2016r\u2016, and rs \u2264 \u2016QSC\u2016, time required for each iteration is of the order O(2\u2016QSC\u2016) time. Although the number of iterations is a polynomial, each iteration requires an exponential amount of time w.r.t \u2016QSC\u2016. Hence time complexity of dChase computation is in EXPTIME.\n(iii) As we know that the time taken for application of a BR R is O(\u2016dChasei\u22121(QSC)\u2016\u2016R\u2016). Since \u2016R\u2016 is fixed to a constant, application of R can be done in PTIME. Hence, each dChase iteration can be computed in PTIME. Also since the number of iterations is a polynomial in \u2016QSC\u2016, computing dChase is in PTIME.\nTheorem 8. Data complexity of CCQ entailment over RR quad-systems is PTIMEcomplete.\nProof. (Membership) Follows from the membership in P of data complexity of CCQ entailment for safe quad-systems, whose expressivity subsumes the expressivity of RR quad-systems (Theorem 4).\n(Hardness) In order to prove P-hardness, we reduce a well known P-complete problem, 3HornSat, i.e. the satisfiability of propositional Horn formulas with at most 3 literals. Note that a (propositional) Horn formula is a propositional formula of the form:\nP1 \u2227 . . . \u2227 Pn \u2192 Pn+1 (6)\nwhere Pi, for 1 \u2264 i \u2264 n + 1, are either propositional variables or constants t, f , that represents true and false, respectively. Note that for any propositional variable P , the fact that \u201cP holds\u201d is represented by the formula t \u2192 P , and \u201cP does not hold\u201d is represented by the formula P \u2192 f . A 3Horn formula is a formula of the form (6), where 1 \u2264 n \u2264 2. Note that any (set of) Horn formula(s) \u03a6 can be transformed in polynomial time to a polynomially sized set \u03a6\u2032 of 3Horn formulas, by introducing auxiliary propositional variables such that \u03a6 is satisfiable iff \u03a6\u2032 is satisfiable. A pure 3Horn formula is a 3Horn formula of the form (6), where n = 2. Any 3Horn formula \u03c6 that is not pure can be trivially converted to equivalent pure form by appending a \u2227 t on the body part of \u03c6. For instance, P \u2192 Q, can be converted to P \u2227 t \u2192 Q. Hence, w.l.o.g. we assume that any set of 3Horn formulas is pure, and is of the form:\nP1 \u2227 P2 \u2192 P3 (7)\nIn the following, we reduce the satisfiability problem of pure 3Horn formulas to CCQ entailment problem over a quad-system whose set of schema triples, the set of BRs, and the CCQ CQ are all fixed.\nFor any set of pure Horn formulas\u03a6, we construct the quad-systemQSC = \u3008QC , R\u3009, where C = {ct, cf}. For any formula \u03c6 \u2208 \u03a6 of the form (7), QC contains a quad cf : (P1, P2, P3). In addition QC contains a quad ct : (t, rdf:type, T ). R is the singleton that contains only the following fixed BR:\nct : (x1,rdf:type, T ), ct : (x2,rdf:type, T ), cf : (x1, x2, x3) \u2192 ct : (x3,\nrdf:type, T )\nLet the CQ be the fixed query ct : (f,rdf:type, T ). Now, it is easy to see that QSC |= CQ, iff \u03a6 is not satisfiable.\nTheorem 9. Combined complexity of CCQ entailment over RR quad-systems is in EXPTIME.\nProof. (Membership) By Lemma 5, for any RR quad-systemQSC , its dChase dChase(QSC) can be computed in EXPTIME. Also by Lemma 5, its dChase size \u2016dChase(QSC)\u2016 is a polynomial w.r.t to \u2016QSC\u2016. A boolean CCQ CQ() can naively be evaluated by grounding the set of constants in the dChase to the variables in the CQ(), and then checking if any of these groundings are contained in dChase(QSC). The number of such groundings can at most be \u2016dChase(QSC)\u2016\u2016CQ()\u2016 (\u2020). Since \u2016dChase(QSC)\u2016 is a polynomial in \u2016QSC\u2016, there are an exponential number of groundings w.r.t \u2016CQ()\u2016. Since containment of each of these groundings can be checked in time polynomial w.r.t. the size of dChase(QSC), and since \u2016dChase(QSC)\u2016 is a polynomial w.r.t. \u2016QSC\u2016, the time complexity of CCQ entailment is in EXPTIME.\nConcerning the combined complexity of CCQ entailment of RR quad-systems, we leave the lower bounds open."}, {"heading": "5.1 Restricted RR Quad-Systems", "text": "We call those quad-systems with BRs of form (5) with a fixed bound on n as restricted RR quad-systems. They can be further classified as linear, quadratic, cubic,..., quadsystems, when n = 1, 2, 3, ..., respectively.\nTheorem 10. Data complexity of CCQ entailment over restricted RR quad-systems is P-complete.\nProof. The proof is same as in Theorem 8, since the size of BRs are fixed to constant.\nTheorem 11. Combined complexity of CCQ entailment over restricted RR quad-systems is NP-complete.\nProof. Let the problem of deciding if QSC |= CQ() be called DP\u2019. (Membership) for any QSC whose rules are of restricted RR-type, the size of any r \u2208 R is a constant. Hence, by Lemma 1, any dChase iteration can be computed in PTIME. Since the number of iterations is also polynomial in \u2016QSC\u2016, dChase(QSC) can be computed in PTIME in the size of QSC and dChase(QSC) has a polynomial number of constants. Hence, we can guess an assignment \u00b5 for all the existential variables in CCQ CQ(), to the set of constants in dChase(QSC). Then, one can evaluate the CCQ, by checking if c : (s, p, o) \u2208 dChase(QSC), for each c : (s, p, o) \u2208 CQ()[\u00b5], which can be done in time O(\u2016CQ\u2016 \u2217 \u2016dChase(QSC)\u2016), and is hence is in nondeterministic PTIME, which implies that DP\u2019 is in NP.\n(Hardness) We show that DP\u2019 is NP-hard, by reducing the well known NP-hard problem of 3-colorability to DP\u2019. Given a graph G = \u3008V , E\u3009, where V = {v1, ..., vn} is the set of nodes, E \u2286 V \u00d7 V is the set of edges, the 3-colorability problem is to decide if there exists a labeling function l : V \u2192 {r, b, g} that assigns each v \u2208 V to an element in {r, b, g} such that the condition: (v, v\u2032) \u2208 E \u2192 l(v) 6= l(v\u2032), for each (v, v\u2032) \u2208 E, is satisfied.\nOne can construct a quad-system QSc = \u3008Qc, \u2205\u3009, where graphQc(c) has the following triples:\n{(r, edge, b), (r, edge, g), (b, edge, g), (b, edge, r), (g, edge, r), (g, edge, b)} LetCQ be the boolean CCQ: \u2203v1, ...., vn \u2227 (v,v\u2032)\u2208E [ c : (v, edge, v \u2032)\u2227 c : (v\u2032, edge, v)].\nThen, it can be seen that G is 3-colorable, iff QSc |= CQ."}, {"heading": "6 Quad-Systems and Forall-Existential rules: A formal comparison", "text": "In this section, we formally compare the formalism of quad-systems with forall-existential (\u2200\u2203) rules, which are also called Tuple generating dependencies (Tgds)/Datalog+- rules. \u2200\u2203 rules is a fragment of first order logic in which every formula is restricted to a certain syntactic form. A \u2200\u2203 rule is a first order formula of the form:\n\u2200x\u2200z [p1(x, z) \u2227 ... \u2227 pn(x, z) \u2192 \u2203y p \u2032 1(x,y) \u2227 ... \u2227 p \u2032 m(x,y)] (8)\nwhere x,y, z are vectors of variables such that {x}, {y} and {z} are pairwise disjoint, pi(x, z), for 1 \u2264 i \u2264 n are predicate atoms whose variables are from x or z, p\u20321(x,y), for 1 \u2264 i \u2264 m are predicate atoms whose variables are from x or y. We, for short, occasionally note a \u2200\u2203 rule of the form (8) as \u03c6(x, z) \u2192 \u03c8(x, y), where \u03c6(x, z) = {p1(x, z), ..., pn(x, z)}, \u03c8(x, y) = {p\u20321(x,y), ... p \u2032 m(x,y)}. A set of \u2200\u2203 rules is called a \u2200\u2203 rule set. In the realm of \u2200\u2203 rule sets, a conjunctive query (CQ) is an expression of the form:\n\u2203y p1(x,y) \u2227 ... \u2227 pr(x,y) (9)\nwhere pi(x,y), for 1 \u2264 i \u2264 r are predicate atoms over vectors x or y. A boolean CQ is defined as usual. The decision problem of whether, for a \u2200\u2203 rule set P and a CQ Q, if P |=fol Q is called the CQ EP, where |=fol is the standard first order logic entailment relation.\nFor any quad-graph QC = {c1 : (s1, p1, o1), . . . , cn : (sr, pr, or)}, let rQC be the BR\n\u2192 \u2203yb1 , . . . , ybq c1 : (s1, p1, o1)[\u00b5B] \u2227 . . . \u2227 cr : (sr, pr, or)[\u00b5B],\nwhere { : b1, . . . , : bq} is the set of blank nodes in QC, and \u00b5B is the substitution function { : bi \u2192 ybi}i=1,...,q that assigns each blank-node to a fresh existentially quantified variable. It can be noted that the quad-systems \u3008QC , R\u3009 and \u3008\u2205, R \u222a {rQC}\u3009 are semantically equivalent. The following definition gives the translation functions that will be necessary to establish the relation between quad-systems and \u2200\u2203 rule sets.\nDefinition 8 (Translations \u03c4q , \u03c4r, \u03c4ccq, \u03c4 ). The translation function \u03c4q from the set of quad patterns to the set of ternary atoms is defined as: for any quad-pattern c : (s, p, o), \u03c4q(c : (s, p, o)) = c(s, p, o).\nThe translation function \u03c4br from the set of BRs to the set of \u2200\u2203 rules is defined as: for any BR r of the form (2):\n\u03c4br(r) = \u2200x\u2200z [\u03c4q(c1 : t1(x, z)) \u2227 ... \u2227 \u03c4q(cn : tn(x, z)) \u2192 \u2203y \u03c4q(c \u2032 1 : t \u2032 1(x,y)) \u2227 ... \u2227 \u03c4q(c \u2032 m : t \u2032 m(x,y))],\nThe translation function \u03c4 from the set of quad-systems to forall-existential rule sets is defined as: for any quad-system QSC = \u3008QC , R\u3009, \u03c4(QSC) = \u03c4br(R) \u222a {\u03c4br(rQC )}, where \u03c4br(R) = \u22c3\nr\u2208R \u03c4br(r). The translation function \u03c4ccq from the set of boolean CCQs to the set of boolean CQs is defined as: for any boolean CCQ CQ = \u2203y c1 : t1(a,y) \u2227 . . .\u2227 cr : tr(a,y), \u03c4ccq(CQ) is:\n\u2203y \u03c4q(c1 : t1(a,y)) \u2227 . . . \u2227 \u03c4q(cr : tr(a,y)).\nThe following property gives the relation between CCQ entailment of unrestricted quadsystems and standard first order CQ entailment of \u2200\u2203 rule sets.\nProperty 5. For any quad-systemQSC, CCQ CQ, QSC |= CQ iff \u03c4(QSC) |=fol \u03c4ccq(CQ).\nProof. Notice that every context c \u2208 C becomes a ternary predicate symbol in the resulting translation. Also, \u03c4(QSC) is a \u2200\u2203 rule set, and for any CCQ CQ, \u03c4ccq(CQ) is a CQ.\nIn order to construct the restricted chase for \u03c4(QSC), suppose that \u227aq is also extended to set of instances such that for any two quad-graphs QC, Q\u2032C\u2032 , QC \u227aq Q \u2032 C\u2032 iff \u03c4q(QC) \u227aq \u03c4q(Q\u2032C\u2032). Suppose \u227a is extended similarly to set of instances. Also assume that during the construction of standard chase chase(\u03c4(QSC)) of \u03c4(QSC), for any application of a \u03c4br(r) with existential variables, with r \u2208 R, suppose that the Skolem blank nodes generated in chase(\u03c4(QSC)) follow the same order as they are generated in dChase(QSC). Also let us extend the rule applicability function to the \u2200\u2203 rules settings such that for any set of BRs R, for any r \u2208 R, quad-graph Q\u2032C\u2032 , assignment \u00b5, applicableR(r, \u00b5,Q \u2032 C\u2032) iff applicable\u03c4br(R)(\u03c4br(r), \u00b5, \u03c4q(Q \u2032 C\u2032)).\nNow dChase0(\u3008\u2205,R \u222a {rQC}\u3009) = \u2205, and also chase0(\u03c4(QSC)) = \u2205, dChase1(QSC) = apply(rQC , \u00b5\u2205), where\u00b5\u2205 is the empty function, chase1(\u03c4(QSC)) = apply(\u03c4br(rQC ), \u00b5\u2205), and so on. It is straightforward to see that for any m \u2208 N, \u03c4q( dChasem(\u3008\u2205, R \u222a {rQC}\u3009)) = chasem(\u03c4(QSC)). As a consequence, \u03c4q(dChase(QSC)) = chase(\u03c4(QSC)), and {CQ}[\u03c3] \u2286 dChase(QSC) iff {\u03c4ccq(CQ)}[\u03c3] \u2286 chase(\u03c4(QSC)).\nHence, applying Theorem 1 and the analogous theorem for \u2200\u2203 rulesets from Deutch et al. [30], it follows that for any quad-systemQSC = \u3008QC , R\u3009 and a boolean CCQ CQ, QSC |= CQ iff \u03c4(QSC) |=fol \u03c4ccq(CQ).\nTheorem 12. There exists a polynomial time translation function \u03c4 (resp. \u03c4ccq) from the set of unrestricted quad-systems (resp. CCQs) to the set of \u2200\u2203 rule sets (resp. CQs), such that for any unrestricted quad-system QSC and a CCQ CQ, QSC |= CQ iff \u03c4(QSC) |=fol \u03c4ccq(CQ).\nProof. It is easy to see that \u03c4q , \u03c4br, \u03c4 , and \u03c4ccq in Definition 8 can be implemented using simple syntax transformation, by iterating through the respective components of a quad-system/CCQ, and the time complexity of these functions are linear w.r.t their inputs.\nNotice that for any CCQ CQ (resp. CQ Q), \u2192 CQ (resp. \u2192 Q) is a bridge (resp. \u2200\u2203) rule, with an empty body. Also, since for any quad-graph QC, the translation function \u03c4br defined above can directly be applied on rQC to obtain a \u2200\u2203 rule, the following theorem immediately follows:\nTheorem 13. For quad-systems, the EPs: (i) quad EP, (ii) quad-graph EP, (iii) BR EP, (iv) BRs EP, (v) Quad-System EP, and (vi) CCQ EP are polynomially reducible to entailment of \u2200\u2203 rule sets.\nA \u2200\u2203 rule set P is said to be a ternary \u2200\u2203 rule set, iff all the predicate symbols in the vocabulary of P are of arity less than or equal to three. P is a purely ternary rule set, iff all the predicate symbols in the vocabulary P is of arity three. Similarly, a (purely) ternary CQ is defined. The following property gives the relation between the CQ entailment problem of \u2200\u2203 rule sets and CCQ EP of unrestricted quad-systems.\nTheorem 14. There exists a polynomial time tranlation function \u03bd (resp. \u03bdcq) from ternary \u2200\u2203 rule sets (resp. ternary CQs) to unrestricted quad-systems (resp. CCQs) such that for any ternary \u2200\u2203 rule set P and a ternary CQ Q, P |=fol CQ iff \u3008\u2205, \u03bd(P)\u3009 |= \u03bdcq(Q).\nProof. Note that the CQ EP of any ternary \u2200\u2203 rule set P, whose set of predicate symbols is P , and CQ Q over P , can polynomially reduced to the CQ EP of a purely ternary rule set P\u2032 and purely ternary CQ Q\u2032, by the following transformation function \u03c7. Let be an adhoc fresh URI; \u03c7 is such that for any ternary atom c(s, p, o), \u03c7(c(s, p, o)) = c(s, p, o). For any binary atom c(s, p), \u03c7(c(s, p)) = c(s, p, ), and for any unary atom c(s), \u03c7(c(s)) = c(s, , ). For any \u2200\u2203 rule r of the form (8),\n\u03c7(r) = \u2200x\u2200z [\u03c7(p1(x, z)) \u2227 . . . \u2227 \u03c7(pn(x, z)) \u2192 \u2203y \u03c7(p\u20321(x,y)) \u2227 . . . \u2227 \u03c7(p \u2032 m(x,y))]\nAnd, for any \u2200\u2203 rule set P, \u03c7(P) = \u22c3\nr\u2208P \u03c7(r). For any CQ Q, \u03c7(Q) is similarly defined. Note that for any ternary \u2200\u2203 rule set P, ternary CQ Q, \u03c7(P) (resp. \u03c7(Q)) is purely ternary, and P |=fol Q iff \u03c7(P) |=fol \u03c7(Q).\nAlso, it can straightforwardly seen that \u03c4\u22121br (\u03c7(P)) (resp. \u03c4 \u22121 ccq(\u03c7(Q))) is a set of BRs (resp. CCQ). Suppose, \u03bd(P) is such that \u03bd(P) = QSC = \u3008\u2205, \u03c4 \u22121 br (\u03c7(P))\u3009. Intuitively, C contains a context identifier c, for each predicate symbol c \u2208 P . Also suppose, \u03bdcq(Q) = \u03c4 \u22121 ccq(\u03c7(Q)). Notice that \u03bdcq(Q) is CCQ. It can straightforwardly seen that \u03bd and \u03bdcq can be computed in polynomial time, and P |=fol Q iff \u03bd(P) |= \u03bdcq(Q).\nThanks to Theorem 12 and Theorem 14, the following theorem immediately holds:\nTheorem 15. The CCQ EP over quad-systems is polynomially equivalent to CQ EP over ternary \u2200\u2203 rule sets.\nBy virtue of the theorem above, we derive the following property:\nProperty 6. For quad-systems, the Quad EP, Quad-graph EP, BR(s) EP, and Quadsystem EP are polynomially reducible to CCQ EP.\nProof. The following claim is a folklore in the realm of \u2200\u2203 rules.\nClaim. (1) The \u2200\u2203 rule set EP is polynomially reducible to CQ EP.\nReducibility of \u2200\u2203 rule EP to CQ EP is a folklore in the realm of \u2200\u2203 rules. For a formal proof, we refer the reader to Baget et al. [15], where it is shown that the \u2200\u2203 rule EP is polynomially reducible to fact (a set of instances) EP, and fact EP are equivalent to CQ EP. Also, Cali et al [34] show that CQ containment problem, which is equivalent to \u2200\u2203 rule EP, is reducible to CQ EP. Since a \u2200\u2203 rule set is a set of \u2200\u2203 rules, by using a series of oracle calls to a function that solves the \u2200\u2203 rule EP, we can define a function for deciding \u2200\u2203 rule set entailment. Hence, the claim holds.\n(a) Thanks to translation functions \u03c4 , \u03c4br defined earlier, such that for any quadsystem QSC , quad-graph Q\u2032C\u2032 , QSC |= Q \u2032 C\u2032 iff \u03c4(QSC) |=fol \u03c4br(rQ\u2032C\u2032 ), we can infer that quad-graph EP is polynomially reducible to \u2200\u2203 rule set EP. Applying claim 1, it follows the quad-graph EP over quad-systems is polynomially reducible to CQ EP over \u2200\u2203 rule sets. By Theorem 14, we can deduce that quad-graph EP is polynomially reducible to CCQ EP.\n(b) By the translation functions \u03c4 and \u03c4br , defined earlier, such that for any quadsystem QSC, a set of BRs R, QSC |= R iff \u03c4(QSC) |=fol \u03c4br(R), we can infer that BRs EP is polynomially reducible to \u2200\u2203 rule set EP. Similar to (a) above, we deduce that BRs EP is polynomially reducible to CCQ EP.\nFrom (a) and (b), it follows that Quad-system EP is reducible to CCQ EP.\nHaving seen that the CCQ EP over quad-systems is polynomially equivalent to CQ EP over ternary \u2200\u2203 rule sets, we now compare some of the well known techniques used to ensure decidability of CQ entailment in the \u2200\u2203 rules settings to the decidability techniques for quad-systems that we saw earlier in the previous sections. Note that since all the quad-system classes we proposed in this paper are FECs, for a judicious comparison, the \u2200\u2203 rule classes to which we compare are classes which have a finite chase property. We compare to the following three well known classes: (i) Weakly Acyclic rule sets (WA), (ii) Jointly Acyclic rule sets (JA), and (iii) Model Faithful Acyclic \u2200\u2203 rule sets (MFA). The following property is well known in the realm of \u2200\u2203 rules:\nProperty 7. For the any \u2200\u2203 rule set P, the following holds:\n1. If P \u2208 WA, then P \u2208 JA (from [38]), 2. If P \u2208 JA, then P \u2208 MFA (from [32]), 3. WA \u2282 JA \u2282 MFA (from [38] and [32]).\nNote that a description of few other \u2200\u2203 rule classes that do not have the finite chase property, but still enjoy decidability of CQ entailment are given in the related work."}, {"heading": "6.1 Weak Acyclicity", "text": "Weak acyclicity [24, 26] is a popular technique used to detect whether a \u2200\u2203 rule set has a finite chase, thus ensuring decidability of query answering. The set WA represents class of ternary \u2200\u2203 rule sets that have the weak acyclicity property.\nFor any predicate atom p(t1, . . . , tn), an expression \u3008p, i\u3009, for i = 1, . . . , n is called a position of p. In the above case, t1 is said to occur at position \u3008p, 1\u3009, t2 at \u3008p, 2\u3009, and so on. For a set of \u2200\u2203 rules P, its dependency graph is a graph whose nodes are positions of predicate atoms in P; for each r \u2208 P of the form (8), and for any variable x occurring in position \u3008p, i\u3009 in head of r:\n1. if x is universally quantified and x occurs in the body of r at position \u3008p\u2032, j\u3009, then there exists an edge from \u3008p\u2032, j\u3009 to \u3008p, i\u3009 2. if x is existentially quantified, then for any universally quantified variable x\u2032 occurring in the head of r, with x\u2032 also occurring in the body of r at position \u3008p\u2032, j\u3009, there exists a special edge from \u3008p\u2032, j\u3009 to \u3008p, i\u3009.\nP is called weakly acyclic, iff its dependency graph does not contain cycles going through a special edge. For any \u2200\u2203 rule set P, if P is WA, then its chase is finite, and hence CQ EP is decidable. Note that the nodes in the dependency graph that has incoming special edges corresponds to the positions of predicates where new values are created due to existential variables, and the normal edges capture the propagation of constants from one predicate position to another predicate position. In this way, absence of cycles involving special edges ensures that newly created Skolem blank nodes are not recursively used to create other new Skolem blank nodes in the same position, leading to termination of chase computation.\nExample 3. Let us revisit the quad-system QSC = \u3008QC , R\u3009 mentioned in example 1, whose dependency graph is shown in Fig. 3. Note that the QSC is uncsafe, since its dChase contains a Skolem blank-node : b4, which has as descendant another Skolem blank node : b1, with the same origin context c2 (see Fig. 1). However, it can be seen from Fig. 3 that the dependency graph of \u03c4(QSC) does not contain any directed cycle involving special edges. Hence \u03c4(QSC) is weakly acyclic.\nIt turns out that there exists no inclusion relationship between the classes WA and CSAFE in either directions, i.e. WA 6\u2286 CSAFE (from example 3), and CSAFE 6\u2286 WA (from the fact that WA \u2282 JA, and example 4 below). Whereas WA \u2282 MSAFE, since WA \u2282 MFA and MFA \u2261 MSAFE (Theorem 16)."}, {"heading": "6.2 Joint Acyclicity", "text": "Joint acyclicity [38] extends weak acyclicity, by also taking into consideration the join between variables in body of \u2200\u2203 rules while analyzing the rules for acyclicity. The set\nJA represents the class of all ternary \u2200\u2203 rule sets that have the joint acyclicity property. A \u2200\u2203 rule set P is said to be renamed apart, if for any r 6= r\u2032 \u2208 R, V(r) \u2229V(r\u2032) = \u2205. Since any set of rules can be converted to an equivalent renamed apart one by simple variable renaming, we assume that any rule set P is renamed apart. Also for any r \u2208 P and for a variable y, let PosrH(y) (Pos r B(y)) be the set of positions in which y occurs in the head (resp. body) of r. For any \u2200\u2203 rule set P and an existentially quantified variable y occurring in a rule in P, we define MovP(y) as the least set with:\n\u2013 PosrH(y) \u2286 MovP(y), if y occurs in r; \u2013 PosrH(x) \u2286 MovP(y), if x is a universally quantified variable and Pos r B(x) \u2286\nMovP(y);\nfor any r \u2208 P. The existential dependency graph of a (renamed apart) set of rules P is a graph whose nodes are the existentially quantified variables in P. There exists an edge from a variable y to y\u2032, if there is a rule r \u2208 P in which y\u2032 occurs and there exists a universally quantified variable x in the head (and body) of r such that PosrB(x) \u2286 MovP(y). A \u2200\u2203 rule set P is jointly acyclic, iff its existential dependency graph is acyclic. Analyzing the containment relationships, it happens to be the case that JA 6\u2286 CSAFE (since WA \u2282 JA, and eg. 3). Also example 4 shows us that CSAFE 6\u2286 JA. However JA \u2282 MSAFE, since JA \u2282 MFA and MFA \u2261 MSAFE (Theorem 16).\nExample 4. Consider the quad-system QSC = \u3008QC , R\u3009, where QC = {c1 : (a, b, c)}. Suppose R is the following set:\nR =\n\n\n\nc1 : (x11, x12, z1) \u2192 c2 : (x11, x12, y1) (r1) c1 : (x21, x22, z2), c2 : (x22, x21, x23) \u2192 c3 : (x21, x22, x23) (r2)\nc3 : (x31, x32, x33) \u2192 c1 : (x33, x31, x32) (r3)\n\n\n\nIterations during the dChase construction are:\ndChase0(QSC) = {c1:(a, b, c)}\ndChase1(QSC) = {c1 : (a, b, c), c2 : (a, b, : b1)}\ndChase(QSC) = dChase1(QSC)\nNote that the lone Skolem blank node generated is : b1, which do not have any descendants. Hence, by definition QSC is csafe (msafe/safe). Now analyzing the BRs for joint acyclicity, we note that for the only existentially quantified variable y1,\nMovR(y1) = {\u3008c2, 3\u3009, \u3008c3, 3\u3009, \u3008c1, 1\u3009} Since the BR r1 in which y1 occurs contains the universally quantified variable x11 in\nthe head of r1 such that Pos r1 B (x11) \u2286 MovR(y1), there exists a cycle from y1 to y1 itself in the existential dependency graph of \u03c4(QSC). Hence, by definition \u03c4(QSC) is not joint acyclic. Also since the class of weakly acyclic rules are contained in the class of jointly acyclic rule, it follows that \u03c4(QSC) is also not weakly acyclic."}, {"heading": "6.3 Model Faithful Acyclicity (MFA)", "text": "MFA, proposed in Cuenca Grau et al. [32], is an acyclicity technique that guarantees finiteness of chase and decidability of query answering, in the realm of \u2200\u2203 rules. The\nset MFA denotes the class of all ternary \u2200\u2203 rule sets that are model faithfully acyclic. As far as we know, the MFA technique subsumes almost all other known techniques that guarantee a finite chase, in the \u2200\u2203 rules setting. Obviously, WA \u2282 JA \u2282 MFA.\nFor any \u2200\u2203 rule r = \u03c6(r)(x, z) \u2192 \u03c8(r)(x,y), for each yj \u2208 {y}, let Y jr be a fresh unary predicate unique for yj and r; furthermore, let S be a fresh binary predicate. The transformation mfa of r is defined as:\nmfa(r) = \u03c6(r)(x, z) \u2192 \u03c8(r)(x,y) \u2227 \u2227\nyj\u2208{y}\n[Y jr (yj) \u2227 \u2227\nxk\u2208{x}\nS(xk, yj)]\nAlso let r1 and r2 be two additional rules defined as:\nS(x1, z) \u2227 S(z, x2) \u2192 S(x1, x2) (r1) Y jr (x1) \u2227 S(x1, x2) \u2227 Y j r (x2) \u2192 C (r2)\nwhere C is a fresh nullary predicate. For any set of \u2200\u2203 rules P, let ad(P) be the union of r1 with the set of rules obtained by instantiating r2, for each r \u2208 P, for each existential variable yj in r. For a set of \u2200\u2203 rules P, mfa(P) = \u22c3\nr\u2208Pmfa(r)\u222aad(P). A \u2200\u2203 rule set P is said to be MFA, iff mfa(P) 6|=fol C. It was shown in Cuenca Grau et al. [32] that if P is MFA, then P has a finite chase, thus ensuring decidability of query answering. The following theorem establishes the fact that the notion of msafety is equivalent to MFA, thanks to the polynomial time translations between quad-systems and ternary \u2200\u2203 rule sets.\nTheorem 16. Let \u03c4 be the translation function from the set of unrestricted quad-systems to the set of ternary \u2200\u2203 rule sets, as defined in Definition 8, then, for any quad-system QSC = \u3008QC , R\u3009, QSC is msafe iff \u03c4(QSC) is MFA.\nProof. (outline) Recall that \u03c4 = \u3008\u03c4q , \u03c4br\u3009, where \u03c4q is the quad translation function and \u03c4br is the translation function from BRs to \u2200\u2203 rules. Also, \u03c4(QSC) = \u03c4br({rQC} \u222a R). Also, recall that for every blank node b in QC, the BR rQC contains a corresponding existentially quantified variable yb. We already saw that for such a transformation, the following property holds: for any m \u2208 N, \u03c4q(dChasem(QSC)) = chasem(\u03c4(QSC)), and for any BR r \u2208R \u222a {rQC}, an assignment\u00b5, applicableR\u222a{rQC}(r, \u00b5, dChasem(QSC)) iff applicable\u03c4(QSC)( \u03c4br(r), \u00b5, chasem(\u03c4(QSC))). Also notice that for any two blank nodes : b1, : b2, S( : b1, : b2) \u2208 chase(\u03c4(QSC)), iff : b1 is a descendant of : b2 in dChase(QSC). Hence, the relations S and descendantOf are identical.\nIntuitively, MFA looks for cyclic creation of a Skolem blank-node whose descendant is another Skolem blank-node that is generated by the same rule r = body(r)(x, z) \u2192 head(r)(x, y), by the same existential variable in yj \u2208 {y} of r. Wheras, msafety looks only for generation of a Skolem blank-node : b\u2032 whose descendant is another Skolem : b using the same rule r. Hence, if \u03c4(QSC) is not MFA, then QSC is not msafe, and consequently onlyIf part of the theorem trivially holds.\n(If part) Suppose QSC is unmsafe, and \u00b5 and \u00b5\u2032 are the assignments applied on r \u2208 R to create Skolem blank nodes : b and : b\u2032, respectively, and suppose : b is a descendant of : b\u2032 in the dChase(QSC). That is : b = \u00b5(yj) and : b\u2032 = \u00b5\u2032(yk), for yj , yk \u2208 {y} of r. Suppose j = k, then the prerequisite of non-MFA is trivially\nsatisfied. Suppose if j 6= k is the case, then there exists : b\u2032\u2032 in dChase(QSC) such that : b\u2032\u2032 = \u00b5\u2032(yj), since \u00b5\u2032 is applied on r and yj \u2208 {y}. This means that also in this case, the prerequisite of non-MFA is satisfied. As a consequence \u03c4(QSC) is not MFA. Hence it follows that, QSC is msafe iff \u03c4(QSC) is MFA.\nLet us revisit the quad-system QSC in example 2, it can be easily seen that \u03c4(QSC) is not MFA. Recall that we have seen that QSC is safe but not msafe. We consider the Theorem 16 to be of importance, as it not only establishes the equivalence of MFA and msafety, but thanks to it and the translation \u03c4 , it can be deduced that the technique of safety, which we presented earlier, (strictly) extends the MFA technique. As far as we know, the MFA class of \u2200\u2203 rule sets is one of the most expressive class in the realm of \u2200\u2203 rule sets which allows a finite chase. Hence, the notion of safety that we propose can straightforwardly be ported to \u2200\u2203 settings. The main difference between MFA and safety is that MFA only looks for cyclic creation of two distinct Skolem blank-nodes : b, : b\u2032 that are generated by the same rule r, by the same existential variable in r. Whereas safety also takes into account the origin vectors a and a\u2032 used during rule application to create : b and : b\u2032, respectively, and only raises an alarm if a \u223c= a\u2032. Although, equivalence holds only between quad-systems and ternary \u2200\u2203 rule sets, it can easily be noticed that the technique of safety can be applied to \u2200\u2203 rule sets of arbitrary arity, and can be used to extend currently established tools and systems that work on existing notions of acyclicity such as WA, JA, or MFA."}, {"heading": "7 Related Work", "text": "Contexts and Distributed Logics Work on contexts gained its attention as early as in the 80s, as McCarthy [1] proposed context as a solution to the generality problem in AI. After this, various studies about logics of contexts mainly in the field of KR were done by Guha [18], Distributed First Order Logics by Ghidini et al. [17] and Local Model Semantics by Giunchiglia et al. [8]. Primarily in these works, contexts were formalized as a first order/propositional theory and bridge rules were provided to inter-operate the various theories of contexts. Some of the initial works on contexts relevant to semantic web were the ones like Distributed Description Logics [5] by Borgida et al., and Context-OWL [7] by Bouquet et al., and the work of CKR [13, 10] by Serafini et al. These were mainly logics based on DLs, which formalized contexts as OWL KBs, whose semantics is given using a distributed interpretation structure with additional semantic conditions that suits varying requirements. Compared to these works, the bridge rules we consider are much more expressive with conjunctions and existential variables that supports value/blank-node creation.\nTemporal RDF/Annotated RDF Studies in extending standard RDF with dimensions such as time and annotations have already been accomplished. Gutierrez et al. in [41] tried to add a temporal extension to RDF and defines the notion of a \u2018temporal rdf graph\u2019, in which a triple is augmented to a quadruple of the form t : (s, p, o), where t is a time point. Whereas annotated extensions to RDF and querying annotated graphs have been studied in Udrea et al. [42] and Straccia et al. [43]. Unlike the case of time,\nhere the quadruple has the form: a : (s, p, o), where a is an annotation. The authors provide semantics, inference rules and query language that allows for expressing temporal/annotated queries. Although these approaches, in a way address contexts by means of time and annotations, the main difference in our work is that we provide the means to specify expressive bridge rules for inter-operating the reasoning between the various contexts.\nDL+rules Works on extending DL KBs with Datalog like rules was studied by Horrocks et al. [29] giving rise to the SWRL [29] language. Related initiatives propose a formalism using which one can mix a DL ontology with the Unary/Binary Datalog RuleML sublanguages of the Rule Markup Language, and hence enables Horn-like rules to be combined with an OWL KB. Since SWRL is undecidable in general, studies on computable sub-fragments gave rise to works like Description Logic Rules [40], where the authors deal with rules that can be totally internalized by a DL knowledge base, and hence if the DL considered is decidable, then also is a DL+rules KB. The authors give various fragments of the rule bases like SROIQ rules, EL++ rules etc. and show that certain new constructs that are not expressible by plain DL can be expressed using rules, although they are finally internalized into DL KBs. Unlike in our scenario, these works consider only horn rules without existential variables.\n\u2200\u2203 rules, TGDs, Datalog+- rules Query answering over rules with universal-existential quantifiers in the context of databases, where these rules are called Datalog+- rules/tuple generating dependencies (TGDs), was done by Beeri and Vardi [14] even in the early 80s, where the authors show that the query entailment problem, in general, is undecidable. However, recently many classes of such rules have been identified for which query answering is decidable. These classes (according to [15]) can broadly be divided into the following three categories: (i) bounded treewidth sets (BTS), (ii) finite unification sets (FUS), and (iii) finite extension sets (FES). BTS contains the classes of \u2200\u2203 rule sets, whose models have bounded treewidth. Some of the important classes of these sets are the linear \u2200\u2203 rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38]. BTS classes in general need not have a finite chase, and query answering is done by exploiting the fact that the chase is tree shaped, whose nodes (which are sets of instances) start replicating (up to isomorphism) after a while. Hence, one could stop the computation of the chase, once it can be made sure that any future iterations of chase can only produce nodes that are isomorphic to existing nodes. A deterministic algorithm for deciding query entailment for the greedy BTS, which is a subset of this class is provided in Thomazo et al. [16].\nFUS classes include the class of \u2018sticky\u2019 rules [36, 35], atomic hypothesis rules in which the body of each rule contains only a single atom, and also the class of linear \u2200\u2203 rules. The approach used for query answering in FUS classes is to rewrite the input query w.r.t. to the \u2200\u2203 rule sets to another query that can be evaluated directly on the set of instances, such that the answers for the former query and latter query coincides. The approach is called the query rewriting approach. Compared to approaches proposed in this paper, these approaches do not enjoy the finite chase property, and are hence not conducive to materialization/forward chaining based query answering.\nUnlike BTS and FUS, the FES classes are characterized by the finite chase property, and hence are most related to the techniques proposed in our work. Some of the classes in this set employ termination guarantying checks called \u2018acyclicity tests\u2019 that analyze the information flow between rules to check whether cyclic dependencies exists that can lead to infinite chase. Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37]. The main approach used in these techniques is to exploit the structure of the rules and use a dependency graph that models the propagation path of constants across various predicates in the rules, and restricting the dependency graph to be acyclic. The main drawback of these approaches is that they only analyze the schema/Tbox part of the rule sets, and ignore the instance part, and hence produce a large number of false alarms, i.e. it is often the case that although dependency graph is cyclic, the chase is finite. Recently, a more dynamic approach, called the MFA technique, that also takes into account the instance part of the rule sets was proposed in Cuenca grau et al. [32], where existence of cyclic Skolem blank-node/constant generations in the chase is detected by augmenting the rules with extra information that keeps track of the Skolem function used to generate each Skolem blank-node. As shown in section 6, our technique of safety subsumes the MFA technique, and supports for much more expressive rule sets, by also keeping track of the vectors used by rule bodies while Skolem blank-nodes are generated.\nData integration Studies in query answering on integrated heterogeneous databases with expressive integration rules in the realm of data integration is primarily studied in the following two settings: (i) Data exchange [24], in which there is a source database and target database that are connected with existential rules, and (ii) Peer-to-peer data management systems (PDMS) [19], where there are an arbitrary number of peers that are interconnected using existential rules.\nThe approach based on dependency graphs, for instance, is used by Halevi et al. in the context of peer-peer data management systems [19], and decidability is attained by not allowing any kind of cycles in the peer topology. Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability. It was shown in Cuenca Grau et al [32] that their MFA technique strictly subsumes both WA and SWA techniques in expressivity. Since we saw in section 6 that our technique of safety subsumes the MFA technique and allows the representation of much more expressive rule sets, the safety technique can straightforwardly be employed in the above mentioned systems with decidability guarantees for query answering."}, {"heading": "8 Summary and Conclusion", "text": "In this paper, we study the problem of query answering over contextualized RDF knowledge in the presence of forall-existential bridge rules. We show that the problem, in general, is undecidable, and present a few decidable classes of quad-systems. Table 1 displays the complexity results of chase computation and query entailment for the various classes of quad-systems we have derived. Classes csafe, msafe, and safe, ensure decidability by restricting the structure of Skolem blank-nodes generated in the\ndChase. Briefly, the above classes do not allow an infinite descendant chain for Skolem blank-nodes generated, by constraining each Skolem blank-node in a descendant chain to have a different value for certain attributes, whose value sets are finite. RR and restricted RR quad-systems, do not allow the generation of Skolem blank nodes, thus constraining the dChase to have only constants from the initial quad-system. The above classes which suit varying situations, can be used to extend the currently established tools for contextual reasoning to give support for expressive bridge rules with conjunctions and existential quantifiers with decidability guarantees. From an expressivity point of view, the class of safe quad-systems subsumes all the above classes, and other well known classes in the realm of \u2200\u2203 rules with finite chases. We view the results obtained in this paper as a general foundation for contextual reasoning and query answering over contextualized RDF knowledge formats such as quads, and can straightforwardly be used to extend existing quad stores."}, {"heading": "9 Acknowledgements", "text": "We sincerely thank Loris Bozzatto (FBK-IRST, Italy), and Francesco Corcoglionitti (FBK-IRST, Italy), and Prof. Roberto Zunino (DISI, University of Trento, Italy) for all their helpful technical feedbacks on an initial version of this paper. We also thank Dr. Christoph Lange (School of Computer Science, University of Birmingham, UK), Prof. Sethumadhavan (Center for Cyber Security, Amrita University, India), and Prof. Padmanabhan T.R. (Dept. of Computer Science, Amrita University, India), for their time and motivating discussions."}, {"heading": "A Proofs for Section 3", "text": "Proof (Property 1). Note that a strict linear order is a relation that is irreflexive, transitive, and linear.\nIrreflexivity: By contradiction, suppose \u227aq is not irreflexive, then there exists Q \u2208 Q such that Q \u227aq Q holds. This means that neither of the conditions (i) and (ii) of \u227aq definition holds for Q. Hence, due to condition (iii) Q 6\u227aq Q, which is a contradiction.\nLinearity: Note that for any two distinct Q,Q\u2032 \u2208 Q, one of the following holds: (a) Q \u2282 Q\u2032, (b) Q\u2032 \u2282 Q, or (c) Q \\ Q\u2032 and Q\u2032 \\ Q are non-empty and disjoint. Suppose (a) is the case, then Q \u227aq Q\u2032 holds. Similarly, if (b) is the case then Q\u2032 \u227aq Q holds. Otherwise if (c) is the case, then by condition (ii), either Q \u227aq Q\u2032 or Q\u2032 \u227aq Q should hold. Hence, \u227aq is a linear order over Q.\nTransitivity: Suppose there exists Q,Q\u2032, Q\u2032\u2032 \u2208 Q such that Q \u227aq Q\u2032 andQ\u2032 \u227aq Q\u2032\u2032. Then, one of the following four cases hold: (a) Q \u227aq Q\u2032 due to (i) and Q\u2032 \u227aq Q\u2032\u2032 due to (i), (b) Q \u227aq Q\u2032 due to (i) and Q\u2032 \u227aq Q\u2032\u2032 due to (ii), (c) Q \u227aq Q\u2032 due to (ii) and Q\u2032 \u227aq Q\u2032\u2032 due to (i), (d) Q \u227aq Q\u2032 due to (ii) and Q\u2032 \u227aq Q\u2032\u2032 due to (ii).\nSuppose if (a) is the case, then trivially Q \u2282 Q\u2032\u2032, and hence by applying condition (i) Q \u227aq Q\u2032\u2032. Otherwise if (b) is the case, then either (1) Q \u2282 Q\u2032\u2032 or (2) Q 6\u2282 Q\u2032\u2032.\nSuppose, (1) is the case then, by (i) Q \u227aq Q\u2032\u2032. Otherwise, if (2) is the case, then since, Q \u2282 Q\u2032, it cannot be the case that greatestQuad\u227al(Q \u2032\u2032\\Q)\u227al greatestQuad\u227al(Q \u2032\u2032\\Q\u2032), and it cannot be the case that greatestQuad\u227al(Q \u2032 \\ Q\u2032\u2032) \u227al greatestQuad\u227al(Q \\ Q\n\u2032\u2032). Hence, it should be the case that greatestQuad\u227al(Q \u2032\u2032 \\Q\u2032) l greatestQuad\u227al(Q \u2032\u2032 \\Q) and greatestQuad\u227al(Q \\Q \u2032\u2032) \u227al greatestQuad\u227al(Q\n\u2032 \\Q\u2032\u2032). But since, greatestQuad\u227al(Q \u2032\\Q\u2032\u2032)\u227al greatestQuad\u227al(Q \u2032\u2032\\Q\u2032), it allows us to derive greatestQuad\u227al(Q \\ Q\u2032\u2032) \u227al greatestQuad\u227al(Q \u2032\u2032 \\ Q), and hence by condition (ii), Q \u227aq Q\u2032\u2032. Hence, if (b) is the case, then in both possible cases (1) or (2), it should be the case that Q \u227aq Q\u2032\u2032. Otherwise if (c) is the case, then similar to the arguments in (b), by condition (i) or (ii), it can easily be seen that Q \u227aq Q\u2032\u2032.\nOtherwise, if (d) is the case, then the following must hold: greatestQuad\u227al(Q \\ Q\u2032) \u227al greatestQuad\u227al(Q \u2032 \\Q) (\u2020) and greatestQuad\u227al(Q \u2032 \\Q\u2032\u2032) \u227al greatestQuad\u227al( Q\u2032\u2032 \\ Q\u2032) (\u2021). Suppose by contradiction Q\u2032\u2032 \u227aq Q, then one of the following holds: (1) Q\u2032\u2032 \u227aq Q by condition (i) or (2) Q\u2032\u2032 \u227aq Q by condition (ii). Suppose, (1) is the case, then it should be the case that Q\u2032\u2032 \u2282 Q. Hence, it should not be the case that greatestQuad\u227al(Q\\Q \u2032)\u227al greatestQuad\u227al(Q \u2032\u2032 \\Q\u2032) and it should not be the case that greatestQuad\u227al(Q \u2032 \\Q\u2032\u2032) \u227al greatestQuad\u227al(Q\n\u2032 \\Q). Hence, it should be the case that greatestQuad\u227al(Q \u2032\u2032 \\Q\u2032) l greatestQuad\u227al(Q\\Q \u2032) (\u2665), and it should be the case that greatestQuad\u227al(Q \u2032 \\Q) l greatestQuad\u227al(Q\n\u2032 \\Q\u2032\u2032) (\u2660). Applying (\u2021) in (\u2665), we get greatestQuad\u227al(Q \u2032 \\Q\u2032\u2032) \u227al greatestQuad\u227al(Q \\Q \u2032), and Applying (\u2020) in (\u2660), we get greatestQuad\u227al(Q\\Q \u2032)\u227al greatestQuad\u227al(Q\n\u2032\\Q\u2032\u2032), which is a contradiction. Suppose if (2) is the case, then greatestQuad\u227al(Q \u2032\u2032 \\Q)\u227al greatestQuad\u227al(Q\\Q \u2032\u2032). The above can be written as: greatestQuad\u227al(Q \u2032\u2032 \\ (Q\u2229Q\u2032\u2032)) \u227al greatestQuad\u227al(Q \\ (Q\u2229Q\n\u2032\u2032)). Using Q\u2229Q\u2032 \u2229Q\u2032\u2032 \u2286 Q\u2229Q\u2032, it follows that greatestQuad\u227al(Q\n\u2032\u2032 \\ (Q\u2229Q\u2032 \u2229Q\u2032\u2032)) l greatestQuad\u227al(Q\\(Q\u2229Q\n\u2032\u2229Q\u2032\u2032)) (\u2663). Also applying similar transformation in (\u2020) and (\u2021), we get greatestQuad\u227al(Q\\(Q\u2229Q \u2032\u2229Q\u2032\u2032)) l greatestQuad\u227al(Q \u2032\\(Q\u2229Q\u2032\u2229Q\u2032\u2032)), and greatestQuad\u227al(Q \u2032\\(Q\u2229Q\u2032\u2229Q\u2032\u2032)) l greatestQuad\u227al(Q\n\u2032\u2032\\(Q\u2229Q\u2032\u2229Q\u2032\u2032)). From which, it follows that greatestQuad\u227al(Q \\ (Q \u2229 Q \u2032 \u2229 Q\u2032\u2032)) l greatestQuad\u227al(Q \u2032\u2032 \\ (Q\u2229Q\u2032\u2229Q\u2032\u2032)). Using (\u2663) in the above, we get greatestQuad\u227al(Q \\ (Q\u2229Q \u2032\u2229Q\u2032\u2032)) = greatestQuad\u227al(Q \u2032 \\ (Q \u2229Q\u2032 \u2229Q\u2032\u2032)) = greatestQuad\u227al(Q\n\u2032\u2032 \\ (Q \u2229Q\u2032 \u2229Q\u2032\u2032)), which is a contradiction. Hence, it should be the case that Q \u227aq Q\u2032\u2032.\nProof (Theorem 2). We show that CCQ entailment is undecidable for unrestricted quadsystems, by showing that the well known undecidable problem of \u201cnon-emptiness of intersection of context-free grammars\u201d is reducible to the CCQ answering problem.\nGiven an alphabet \u03a3, string w is a sequence of symbols from \u03a3. A language L is a subset of \u03a3\u2217, where \u03a3\u2217 is the set of all strings that can be constructed from the alphabet \u03a3, and also includes the empty string \u01eb. Grammars are machineries that generate a particular language. A grammar G is a quadruple \u3008V, T, S, P \u3009, where V is the set of variables, T , the set of terminals, S \u2208 V is the start symbol, and P is a set of production rules (PR), in which each PR r \u2208 P , is of the form:\nw \u2192 w\u2032\nwhere w,w\u2032 \u2208 {T \u222a V }\u2217. Intuitively application of a PR r of the form above on a string w1, replaces every occurrence of the sequence w in w1 with w\u2032. PRs are applied starting from the start symbol S until it results in a string w, with w \u2208 \u03a3\u2217 or no more\nproduction rules can be applied on w. In the former case, we say that w \u2208 L(G), the language generated by grammar G. For a detailed review of grammars, we refer the reader to Harrison et al. [33]. A context-free grammar (CFG) is a grammar, whose set of PRs P , have the following property:\nProperty 8. For a CFG, every PR is of the form v \u2192 w, where v \u2208 V , w \u2208 {T \u222a V }\u2217.\nGiven two CFGs, G1 = \u3008V1, T, S1, P1\u3009 and G2 = \u3008V2, T, S2, P2\u3009, where V1, V2 are the set of variables, T such that T \u2229 (V1 \u222a V2) = \u2205 is the set of terminals. S1 \u2208 V1 is the start symbol of G1, and P1 are the set of PRs of the form v \u2192 w, where v \u2208 V , w is a sequence of the form w1...wn, where wi \u2208 V1 \u222a T . S2, P2 are defined similarly. Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [33].\nGiven two CFGs, G1 = \u3008V1, T, S1, P1\u3009 andG2 = \u3008V2, T, S2, P2\u3009, we encode grammars G1, G2 into a quad-system of the form QSc = \u3008Qc, R\u3009, with a single context identifier c. Each PR r = v \u2192 w \u2208 P1 \u222a P2, with w = w1w2w3..wn, is encoded as a BR of the form:\nc : (x1, w1, x2), c : (x2, w2, x3), ..., c : (xn, wn, xn+1) \u2192 c : (x1, v, xn+1) (10)\nwhere x1, .., xn+1 are variables. W.l.o.g. we assume that the set of terminal symbols T is equal to the set of terminal symbols occurring in P1 \u222a P2. For each terminal symbol ti \u2208 T , R contains a BR of the form:\nc : (x,rdf:type, C) \u2192 \u2203y c : (x, ti, y), c : (y,rdf:type, C) (11)\nand Qc contains only the triple:\nc : (a,rdf:type, C)\nWe in the following show that:\nQSc |= \u2203y c : (a, S1, y) \u2227 c : (a, S2, y) \u2194 L(G1) \u2229 L(G2) 6= \u2205 (12)\nClaim. (1) For any w = t1, ..., tp \u2208 T \u2217, there exists b1, ...bp, such that c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp\u22121, tp, bp), c : (bp,rdf:type, C) \u2208 dChase( QSc).\nwe proceed by induction on |w|.\nbase case suppose if |w| = 1, then w = ti, for some ti \u2208 T . But by construction c : (a, rdf:type, C) \u2208 dChase0(QSc), on which rules of the form (11) is applicable. Hence, there exists an i such that dChasei(QSc) contains c : (a, ti, bi), c : (bi,rdf:type, C), for each ti \u2208 T . Hence, the base case. hypothesis for any w = t1...tp, if |w| \u2264 p\u2032, then there exists b1, ..., bp, such that c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp\u22121, tp, bp), c : (bp, rdf:type, C) \u2208 dChase(QSc). inductive step suppose w = t1...tp+1, with |w| \u2264 p\u2032 + 1. Since w can be written as w\u2032tp+1, where w\u2032 = t1...tp, and by hypothesis, there exists b1, ..., bp such that c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp\u22121, tp, bp), c : (bp,rdf:type, C) \u2208 dChase(QSc). Also since rules of the form (11) are applicable on c : (bp, rdf:type, C), and hence produces triples of the form c : (bp, ti, bip+1), c : (b i p+1, rdf:type,\nC), for each ti \u2208 T . Since tp+1 \u2208 T , the claim follows.\nFor a grammar G = \u3008V, T, S, P \u3009, whose start symbol is S, and for any w \u2208 {V \u222a T }\u2217, for some Vj \u2208 V , we denote by Vj \u2192i w, the fact that w was derived from Vj by i production steps, i.e. there exists steps Vj \u2192 r1, ..., ri \u2192 w, which lead to the production of w. For any w, w \u2208 L(G), iff there exists an i such that S \u2192i w. For any Vj \u2208 V , we use Vj \u2192\u2217 w to denote the fact that there exists an arbitrary i, such that Vj \u2192i w.\nClaim. (2) For any w = t1...tp \u2208 {V \u222a T }\u2217, and for any Vj \u2208 V , if Vj \u2192\u2217 w and there exists b1, ..., bp+1, with c : (b1, t1, b2), ..., c : (bp, tp, bp+1) \u2208 dChase(QSc), then c : (b1, Vj , bp+1) \u2208 dChase(QSc).\nWe prove this by induction on the size of w.\nbase case Suppose |w| = 1, then w = tk, for some tk \u2208 T . If there exists b1, b2 such that c : (b1, tk, b2). But since there exists a PR Vj \u2192 tk, by transformation given in (10), there exists a BR c : (x1, tk, x2) \u2192 c : (x1, Vj , x2) \u2208 R, which is applicable on c : (b1, tk, b2) and hence the quad c : (b1, Vj , b2) \u2208 dChase(QSc). hypothesis For any w = t1...tp, with |w| \u2264 p\u2032, and for any Vj \u2208 V , if Vj \u2192\u2217\nw and there exists b1, ...bp, bp+1, such that c : (b1, t1, b2), ..., c : (bp, tp, bp+1) \u2208 dChase(QSc), then c : (b1, Vj , bp+1) \u2208 dChase(QSc). inductive step Suppose if w = t1...tp+1, with |w| \u2264 p\u2032 + 1, and Vj \u2192i w, and there exists b1, ...bp+1, bp+2, such that c : (b1, t1, b2), ..., c : (bp+1, tp+1, bp+2) \u2208 dChase(Qc). Also, one of the following holds (i) i = 1, or (ii) i > 1. Suppose (i) is the case, then it is trivially the case that c : (b1, Vj , bp+2) \u2208 dChase(QSc). Suppose if (ii) is the case, one of the two sub cases holds (a) Vj \u2192i\u22121 Vk, for some Vk \u2208 V and Vk \u21921 w or (b) there exist a Vk \u2208 V , such that Vk \u2192\u2217 tq+1...tq+l, with 2 \u2264 l \u2264 p, where Vj \u2192\u2217 t1...tqVktp\u2212l+1...tp+1. If (a) is the case, trivially then c : (b1, Vk, bq+2) \u2208 dChase(QSc), and since by construction there exists c : (x0, Vk, x1) \u2192 c : (x0, Vk+1, x1), ..., c : (x0, Vk+i, x1) \u2192 c : (x0, Vj , x1) \u2208 R, c : (b1, Vj , bq+2) \u2208 dChase( QSc). If (b) is the case, then since |tq+1...tq+l| \u2265 2, |t1...tqV2tp\u2212l+1...tp+1| \u2264 p\u2032. This implies that c : (b1, Vj , bp+2) \u2208 dChase(QSc).\nSimilarly, by construction of dChase(QSc), the following claim can straightforwardly be shown to hold:\nClaim. (3) For any w = t1...tp \u2208 {V \u222a T }\u2217, and for any Vj \u2208 V , if there exists b1, ..., bp, bp+1, with c : (b1, t1, b2), ..., c : (bp, tp, bp+1) \u2208 dChase(QSc) and c : (b1, Vj , bp+1) \u2208 dChase(QSc), then Vj \u2192\u2217 w.\n(a) For any w = t1...tp \u2208 T \u2217, if w \u2208 L(G1) \u2229 L(G2), then by claim 1, since there exists b1, ..., bp, such that c : (a, t1, b1), ..., c : (bp\u22121, tp, bp) \u2208 dChase(QSc). But since w \u2208 L(G1) and w \u2208 L(G2), S1 \u2192 w and S2 \u2192 w. Hence by claim 2, c : (a, S1, bp), c : (a, S2, bp) \u2208 dChase(QSc), which implies that dChase(QSc) |= \u2203y c : (a, s1, y)\u2227 c : (a, s2, y). Hence, by Theorem 1,QSc |= \u2203y c : (a, s1, y)\u2227 c : (a, s2, y). (b) Suppose if QSc |= \u2203y c : (a, S1, y)\u2227 c : (a, S2, y), then applying Theorem 1, it follows that there exists bp such that c : (a, S1, bp), c : (a, S2, bp) \u2208 dChase(QSC). Then it is the case that there exists w = t1...tp \u2208 T \u2217, and b1, ..., bp such that c : (a, t1, b1), ..., c : (bp\u22121, tp, bp), c : (a, S1, bp), c : (a, S2, bp) \u2208 dChase(QSc). Then by claim 3, S1 \u2192\u2217 w, S2 \u2192\u2217 w. Hence, w \u2208 L(G1) \u2229 L(G2).\nBy (a),(b) it follows that there exists w \u2208 L(G1)\u2229L(G2) iffQSc |= \u2203y c : (a, s1, y)\u2227 c : (a, s2, y). As we have shown that the intersection of CFGs, which is an undecidable problem, is reducible to the problem of query entailment on unrestricted quad-system, the latter is undecidable."}, {"heading": "B Proofs for Section 4", "text": "Proof (Theorem 5). We in the following show the case of dChasecsafe(QSC), i.e. unCSafe \u2208 dChasecsafe(QSC) iff QSC is uncsafe. The proof follows from Lemma 6 and Lemma 7 below.\nThe proofs for the case of dChasesafe(QSC) and dChasemsafe(QSC) is similar, and is omitted.\nLemma 6 (Soundness). For any quad-system QSC = \u3008QC , R\u3009, if the quad unCSafe \u2208 dChasecsafe(QSC), then QSC is uncsafe.\nProof. Note that augC(R) = \u22c3\nr\u2208R augC(r) \u222a {brTR}, where brTR is the range restricted BR cc : (x1, descendantOf, z), cc : (z, descendantOf, x2)\u2192 cc : (x1, descendantOf, x2). Also for each r \u2208 R, body(r) = body(augC(r)), and for any c \u2208 C, c : (s, p, o) \u2208 head(r) iff c : (s, p, o) \u2208 head(augC(r)). That is, head(r) = head(augC(r))(C), where head( r)(C) denotes the quad-patterns in head(r), whose context identifiers is in C. Also, head(augC(r)) = head(augC(r))(C) \u222a head(augC(r))(cc), and also the set of existentially quantified variables in head(augC(r))(cc) is contained in the set of existentially quantified variables in head(augC(r))(C) (\u2020). We first prove the following claim:\nClaim. (0) For any quad-system QSC = \u3008QC , R\u3009, let i be a csafe dChase iteration, let j be the number of csafe dChase iterations before i in which brTR was applied, then dChasei\u2212j(QSC) = dChase csafe i (QSC)(C).\nWe approach the proof of the above claim by induction on i.\nbase case If i = 1, then dChasecsafe0 (QSC)(cc) = \u2205 and dChase csafe 0 (QSC)(C) =\ndChasecsafe0 (QSC) = dChase0(QSC). Hence, it should be the case that applicableaugC(R)(brTR, \u00b5, dChasecsafe0 (QSC)) does not hold, for any\u00b5. Hence, applicableR( r, \u00b5, dChase0(QSC)) iff applicableaugC(R)( augC(r), \u00b5, dChasecsafe0 (QSC)), for any r \u2208 R, assignment \u00b5. Also using (\u2020), it follows that dChase1(QSC) = dChasecsafe1\u22120(QSC)(C).\nhypothesis for any i \u2264 k, if i is a csafe dChase iteration, and j be the number of csafe dChase iterations before i in which brTR was applied, then dChasei\u2212j(QSC) = dChasecsafei (QSC)(C). inductive suppose i = k + 1, then one of the following three cases should hold: (a) applicableaugC(R)(r, \u00b5, dChasecsafek (QSC)) does not hold for any r \u2208 augC(R), assignment\u00b5, and dChasecsafek+1(QSC) = dChase csafe k (QSC), or (b) applicableaugC(R)(\nbrTR, \u00b5, dChasecsafek (QSC)) holds, for some assignment\u00b5, or (c) applicableaugC(R)(r, \u00b5, dChasecsafek (QSC)) holds, for some r \u2208 augC(R) \\ {brTR}, for some assignment \u00b5. If (a) is the case, then it should be the case that applicableR(r\u2032,\n\u00b5, dChasek\u2212j(QSC)) does not hold, for any r\u2032 \u2208 R, assignment \u00b5. As a result dChasek+1\u2212j(QSC) = dChasek\u2212j(QSC), and hence, dChasek+1\u2212j( QSC) = dChasecsafek+1(QSC)(C). If (b) is the case, then since dChase csafe k+1(QSC)(C) = dChasecsafek ( QSC)(C), dChase csafe k+1(QSC)(C) = dChasek+1\u2212j\u22121( QSC) = dChasek\u2212j(QSC). If (c) is the case, then it should the case that applicableR(r\u2032, \u00b5, dChasek\u2212j(QSC), where r = augC(r\u2032) and head(r)(C) = head(r). Hence, it should be the case that dChasecsafek+1(QSC)(C) = dChasek+1\u2212j( QSC).\nThe following claim, which straightforwardly follows from claim 0, shows that any quad c : (s, p, o), with c \u2208 C derived in csafe dChase, is also derived in its standard dChase. In this way, csafe dChase do not generate any unsound triples in any context c \u2208 C.\nClaim. (1) For any quad c : (s, p, o), where c \u2208 C, if c : (s, p, o) \u2208 dChasecsafe(QSC), then c : (s, p, o) \u2208 dChase(QSC).\nThe following claim shows that the set of origin context quads are also sound.\nClaim. (2) If there exists quad cc : (b, originContext, c) \u2208 dChasecsafe(QSC), then c \u2208 originContexts(b).\nIf cc : (b, originContext, c) \u2208 dChasecsafe(QSC), there exists i \u2208 N, such that cc : (b, originContext, c) \u2208 dChasecsafei ( QSC) and there exists no j < i with cc : (b, originContext, c) \u2208 dChasecsafej (QSC). But if cc : (b, originContext, c) \u2208 dChase csafe i (QSC) implies that there exists an augC(r) = body(x, z) \u2192 head(x,y) \u2208 augC(R), with cc : (yj , originContext, c) \u2208 head(x, y), yj \u2208 {y}, such that cc : (b, originContext, c) was generated due to application of an assignment \u00b5 on augC(r), with b = yj[\u00b5ext(y)]. This implies that there exists c : (s, p, o) \u2208 head(x,y), with s = yj or p = yj or o = yj , c \u2208 C. Since according to our assumption, i is the first iteration in which cc : (b, originContext, c) is generated, it follows that i is the first iteration in which c : (s, p, o)[\u00b5ext(y)] is also generated. Let k be the number of iterations before i in which brTR was applied. By applying claim 0, it should be the case that c : (s, p, o)[\u00b5ext(y)] \u2208 dChasei\u2212k(QSC), and i \u2212 k should be the first such dChase iteration. Hence, c \u2208 orginContexts(b). In the following claim, we prove the soundness of the descendant quads generated in a safe dChase.\nClaim. (3) For any two distinct blank nodes b, b\u2032 in dChasecsafe(QSC), if cc : (b\u2032, descendantOf, b) \u2208 dChasecsafe(QSC) then b\u2032 is a descendant of b.\nSince any quad of the form cc : (b\u2032, descendantOf, b) \u2208 dChasecsafe(QSC) is not an element of QC , and can only be introduced by an application of a BR r \u2208 augC(R), any quad of the form cc : (b\u2032, descendantOf, b) can only be introduced, earliest in the first iteration of dChasecsafe(QSC). Suppose cc : (b\u2032, descendantOf, b) \u2208 dChasecsafe(QSC), then there exists an iteration i \u2265 1 such that cc : (b\u2032, descendantOf, b)\u2208 dChasecsafej (QSC), for any j \u2265 i, and cc : (b\u2032, descendantOf, b) 6\u2208 dChasecsafej\u2032 (QSC), for any j\n\u2032 < i. We apply induction on i for the proof.\nbase case suppose cc:(b\u2032, descendantOf, b) \u2208 dChas- -ecsafe1 ( QSC) and since b 6= b\u2032, then there exists a BR r \u2208 augC(R), \u2203\u00b5 such that applicableaugC(R)( r, \u00b5, dChasecsafe0 (QSC)), i.e. body(r)(x, z)[\u00b5] \u2286 dChase csafe 0 (QSC) and cc : (b\n\u2032, descendantOf, b) \u2208 head(r)(x,y)[\u00b5ext(y)]. Then by construction of augC(r), it follows that b = yj [\u00b5ext(y)], for some yj \u2208 {y} and b\u2032 = \u00b5(xi), for some xi \u2208 {x}. Since dChase0(QSC) = dChasecsafe0 (QSC), it follows using (\u2020) that applicableR(r\n\u2032, \u00b5, dChas- -e0(QSC)) holds, for r\u2032 = body(r\u2032)(x, z)\u2192 head(r\u2032)(x, y), with augC(r\u2032) = r. Hence, by construction, it follows that b = yj[\u00b5ext(y)] \u2208 C(dChase1(QSC)), for yj \u2208 {y} and b\u2032 = \u00b5(xi), for xi \u2208 {x}. Hence b\u2032 is a descendant of b (by definition).\nhypothesis if cc : (b\u2032, descendantOf, b) \u2208 dChasecsafei ( QSC), for 1 \u2264 i \u2264 k, then b \u2032 is\na descendant of b. inductive step suppose cc : (b\u2032, descendantOf, b) \u2208 dChasecsafek+1(QSC), then either (i)\ncc : (b \u2032, descendantOf, b) \u2208 dChasecsafek (QSC) or (ii) cc : (b \u2032, descendantOf, b) 6\u2208 dChasecsafek (QSC). Suppose (i) is the case, then by hypothesis, b\n\u2032 is a descendant of b. If (ii) is the case, then either (a) cc : (b\u2032, descendantOf, b) is the result of the application of a brTR \u2208 augC(R) on dChasecsafek (QSC) or (b) cc : (b\n\u2032, descendantOf, b) is the result of the application of a r \u2208 augC(R)\\{brTR} on dChasecsafek (QSC). If (a) is the case, then there exists a b\u2032\u2032 \u2208 C(dChasecsafek (QSC)) such that cc : (b\n\u2032, descendantOf, b\u2032\u2032)\u2208 dChasecsafek (QSC) and cc : (b\n\u2032\u2032, descendantOf, b) \u2208 dChasecsafek ( QSC). Hence, by hypothesis b\u2032 is a descendantOf b\u2032\u2032 and b\u2032\u2032 is a descendantOf b. Since \u2018descendantOf\u2019 relation is transitive, b\u2032 is a descendantOf b. Otherwise if (b) is the case then similar to the arguments used in the base case, it can easily be seen that b\u2032 is a descendant of b.\nSuppose if the quad unCSafe \u2208 dChasecsafe(QSC), then this implies that there exists an iteration i such that the function unCSafeTest on augC(r), with r = body(r)(x, z) \u2192 head(r)(x, y) \u2208 R, assignment \u00b5, and dChasecsafei (QSC) returns True. This implies that, there exists b, b\u2032 \u2208 B, yj \u2208 {y} such that body(r)(x, z)[\u00b5] \u2286 dChasecsafei (QSC), b \u2208 {\u00b5(x)}, cc : (b\u2032, descendantOf, b) \u2208 dChasecsafei (QSC) and {c | cc : (b\n\u2032, originContext, c) \u2208 dChasecsafei (QSC)} = cScope(yj , head(r)(x, y)). Suppose k be the number of csafe dChase iterations before i, in which brTR was applied. Hence, by claim 0, dChasei\u2212k\u22121(QSC) = dChasecsafei\u22121 (QSC)(C), and consequently applicableR( r, \u00b5, dChasei\u2212k\u22121(QSC)) holds. Hence, as a result of \u00b5 being applied on r, there exists b\u2032\u2032 = yj [\u00b5\next(y)] \u2208 B(dChasei\u2212k(QSC))), with b \u2208 {\u00b5(x)}. Hence, by definition originContext(b\u2032\u2032) = cScope(yj , head(r)), and b is a descendantOf b\u2032\u2032. If b 6= b\u2032, then by Claim 2, b\u2032 is a descendantOf b, otherwise b\u2032 = b and hence b\u2032 is a descendantOf b\u2032\u2032. Consequently, b\u2032 is a descendantOf b\u2032\u2032. Also, applying claim 3, we get that originContexts(b\u2032) = originContexts(b\u2032\u2032), which means that prerequisites of uncsafety is satisfied, and hence, QSC is uncsafe.\nLemma 7 (Completeness). For any quad-system, QSC = \u3008QC , R\u3009, if QSC is uncsafe then unCSafe \u2208 dChasecsafe(QSC).\nProof. We first prove a few supporting claims in order to prove the theorem.\nClaim. (0) For any quad-systemQSC = \u3008QC , R\u3009, suppose unCSafe 6\u2208 dChasecsafe(QSC), then for any dChase iteration i, there exists a j \u2265 0 such that dChasei(QSC) = dChasecsafei+j (QSC)(C).\nWe approach the proof by induction on i.\nbase case for i = 0, we know that dChase0(QSC) = dChasecsafe0 (QSC) = QC . Hence, the base case trivially holds. hypothesis for i \u2264 k \u2208 N, there exists j \u2265 0 such that dChasei(QSC) = dChasecsafei+j ( QSC) step case for i= k+1, one of the following holds: (a) dChasek+1(QSC) = dChasek( QSC) or (b) dChasek+1(QSC) = dChasek(QSC) \u222a head(r)( x, y)[\u00b5ext(y)] and applicableR(r, \u00b5, dChasek(QSC)) holds, for some r= body(r)(x, z)\u2192 head(r)( x, y), assignment \u00b5. If (a) is the case, then trivially the claim holds. Otherwise, if (b) is the case, then let j \u2208 N be such that dChasek(QSC) = dChasecsafek+j(QSC)(C). Let j\u2032 \u2265 j, l \u2208 N be such that applicableaugC(R)(brTR, \u00b5, dChasecsafek+l (QSC)), for any j\u2032 \u2265 l \u2265 j, and applicableaugC(R)(brTR, \u00b5, dChasecsafek+j\u2032+1(QSC )) does not hold. By construction, it should be the case that applicable(r\u2032, \u00b5, dChasecsafek+j\u2032+1(QSC)) holds, where r\n\u2032 = augC( r). Also since no new Skolem blank node was introduced in any csafe dChase iteration k + l, for any j \u2264 l \u2264 j\u2032. It should be the case that head(r)[\u00b5ext(y)] = head(r\u2032)[\u00b5ext(y)](C). Since, dChasecsafek+l (QSC)(C) = dChasek(QSC), for any j \u2264 l \u2264 j \u2032, and dChasecsafek+j\u2032+1(QSC) = dChasecsafek+j\u2032(QSC)\u222a head(r \u2032)[\u00b5ext(y)], dChasecsafek+j\u2032+1(QSC)(C) = dChasek+1( QSC). Hence, the claim follows.\nThe following claim, which straightforwardly follows from claim 0, shows that, for csafe quad-systems its standard dChase is contained in its safe dChase.\nClaim. (1) Suppose unCSafe 6\u2208 dChasecsafe(QSC), then dChase(QSC)\u2286 dChasecsafe( QSC).\nClaim below shows that the generation of originContext quads in csafe dChase is complete.\nClaim. (2) For any quad-system QSC , if unCSafe 6\u2208 dChasecsafe(QSC), then for any Skolem blank-node b generated in dChase(QSC), and for any c \u2208 C, if c \u2208 originContexts(b), then there exists a quad cc : (b, originContext, c) \u2208 dChasecsafe(QSC).\nSince the only way a Skolem blank node b gets generated in any iteration i of dChase( QSC) is by the application of a BR r \u2208 R, i.e. when there \u2203r = body(r)(x, z) \u2192 head(r)(x, y) \u2208 R, assignment \u00b5, such that applicableR(r, \u00b5, dChasei\u22121(QSC)), and b = yj [\u00b5ext(y)], for some yj \u2208 {y}, and dChasei(QSC) = dChasei\u22121(QSC) \u222a head(r)(x, y)[\u00b5ext(y)]. Also since c \u2208 originContexts(b), it should be the case that c \u2208 cScope(yj , head(r)). From claim 0, we know that there exists j \u2265 0, such that dChasei(QSC) = dChase csafe i+j (QSC)(C). W.l.o.g, assume that i + j is the first such csafe dChase iteration. Hence, it follows that applicableaugC(R)(r\u2032, \u00b5, dChasecsafei+j\u22121( QSC)), where r\u2032 = augC(r). Since, head(r) \u2286 head(r\u2032), it should be the case that c \u2208 cScope(yj , head(r\u2032)). Hence, by construction of augC, cc : (yj , originContext, c) \u2208\nhead(r\u2032), and as a result of application of \u00b5 on r\u2032 in iteration i+j, cc : (b, originContext, c) gets generated in dChasecsafei+j (QSC). Hence, the claim holds.\nFor the claim below, we introduce the concept of the sub-distance. For any two blank nodes, their sub-distance is inductively defined as:\nDefinition 9. For any two blank nodes b, b\u2032, sub-distance(b, b\u2032) is defined inductively as:\n\u2013 sub-distance(b, b\u2032) = 0, if b\u2032 = b; \u2013 sub-distance(b, b\u2032) = \u221e, if b 6= b\u2032 and b is not a descendant of b\u2032; \u2013 sub-distance(b, b\u2032) =mint\u2208{x[\u00b5]}{ sub-distance(b, t)} + 1, if b\u2032 was generated by\napplication of \u00b5 on r = body(r)(x, z) \u2192 head(r)(x,y), i.e. b\u2032 = yj[\u00b5ext(y)], for some yj \u2208 {y}, and b is a descendant of b\u2032.\nClaim. (3) For any quad-system QSC = \u3008QC , R\u3009, if unCSafe 6\u2208 dChasecsafe(QSC), then for any two Skolem blank nodes b, b\u2032 in dChase(QSC), if b is a descendant of b\u2032 then there exists a quad of the form cc : (b, descendantOf, b\u2032) \u2208 dChasecsafe(QSC).\nNote by the definition of sub-distance that if b is a descendant of b\u2032, then sub-distance(b, b\u2032) \u2208 N. Assuming unCSafe 6\u2208 dChasecsafe(QSC), and b is a descendant of b\u2032, we approach the proof by induction on sub-distance(b, b\u2032).\nbase case Suppose sub-distance(b, b\u2032) = 1, then this implies that there exists r = body(x, z) \u2192 head(r)(x, y), assignment \u00b5 such that b\u2032 was generated due to application of \u00b5 on r, i.e. b\u2032 = yj[\u00b5ext(y)], for some yj \u2208 {y}, and b \u2208 {x[\u00b5]}. This implies that there exists a dChase iteration i such that applicableR(r, \u00b5, dChasei(QSC)) and dChasei+1(QSC) = dChasei(QSC) \u222a apply(r, \u00b5). Since unCSafe 6\u2208 dChasecsafe(QSC), using claim 0, \u2203 k \u2265 i such that dChasei(QSC) = dChasecsafek (QSC)(C). W.l.o.g., let k be the first such csafe dChase iteration. This means that applicableaugC(R)(r\u2032, \u00b5, dChasecsafek (QSC)), where r\n\u2032 = augC(r), and dChasecsafek+1 = dChas e csafe k (QSC) \u222a head(r \u2032)[\u00b5ext(y)], and b, b\u2032 \u2208 head(r\u2032 )[\u00b5ext(y)], b \u2208 {x[\u00b5]}, b\u2032 = yj [\u00b5ext(y)]. By construction of augC(), since there exists a quad-pattern cc : (xl, descendantOf, yj) \u2208 head(r\u2032), for any xl \u2208 {x}, yj \u2208 {y}, it follows that cc : (b, descendantOf, b\u2032) \u2208 dChasecsafek+1(QSC). hypothesis Suppose sub-distance(b, b\u2032) \u2264 k, k \u2208 N, then cc : (b, descendantOf, b\u2032) \u2208 dChasecsafe(QSC). inductive step Suppose sub-distance(b, b\u2032) = k+1, then there exists a b\u2032\u2032 6= b, assignment \u00b5, and BR r = body(r)(x, z) \u2192 head(r)(x,y) \u2208 R such that b\u2032 was generated due to the application of \u00b5 or r with b\u2032\u2032 \u2208 {x[\u00b5]}, i.e. b\u2032 = yj[\u00b5ext(y)], for yj \u2208 {y}, and b is a descendant of b\u2032\u2032. This implies that sub-distance(b\u2032\u2032, b\u2032) = 1, and sub-distance(b, b\u2032\u2032) = k, and hence by hypothesis cc : (b, descendantOf, b\u2032\u2032) \u2208 dChasecsafe(QSC), and cc : (b\u2032\u2032, descendantOf, b\u2032) \u2208 dChasecsafe(QSC). Hence, by construction of csafe dChase, cc : (b, descendantOf, b\u2032) \u2208 dChasecsafe( QSC).\nSuppose QSC is uncsafe, then by definition, there exists a blank nodes b, b\u2032 in Bsk( dChase(QSC)), such that b is descendant of b\u2032, and originContexts(b) is equal to originContexts(b\u2032). By contradiction, if unCSafe 6\u2208 dChasecsafe(QSC), then by claim 1, dChase(QSC) \u2286 dChasecsafe(QSC). Since by claim 2, for any c \u2208 originContexts(b),\nthere exists quads of the form cc : (b, originContext, c) \u2208 dChasecsafe(QSC) and for every c\u2032 \u2208 originContexts(b\u2032), there exists cc : (b\u2032, originContext, c\u2032)\u2208 dChasecsafe(QSC). Since originContexts(b) = originContexts(b\u2032), it follows that {c | cc : (b, originContext, c) \u2208 dChasecsafe( QSC)} = {c\u2032 | cc : (b\u2032, originContext, c\u2032) \u2208 dChasecsafe( QSC)} Also by claim 3, since b is a descendant of b\u2032, there exists a quad of the form cc : (b, descendantOf, b\u2032) in dChasecsafe(QSC). But, by construction of dChasecsafe(QSC), it should be the case that there exist a b\u2032\u2032 \u2208 Bsk(dChasecsafe(QSC)), r= body(r)(x, z) \u2192 head(r)(x, y) \u2208 augC(R), assignment \u00b5 such that b\u2032 was generated due to the application of \u00b5 on r, i.e. b\u2032 = yj[\u00b5ext(y)] with b\u2032\u2032 \u2208 {x[\u00b5]}, and cc : (b, descendantOf, b\u2032\u2032) \u2208 dChasecsafe(QSC). But, since {c | cc : (b, originContext, c) \u2208 dChasecsafe(QSC)} = cScope(yj , head(ri)), the method unCSafeTest(r, \u00b5, dChasecsafel (QSC)) should return True, for some l \u2208 N. Hence, it should be the case that unCSafe\u2208 dChasecsafe(QSC), which is a contradiction to our assumption. Hence unCSafe \u2208 dChasecsafe(QSC), if dChase(QSC) is uncsafe.\nProof (Property 4). (Only If) By definition, R is universally safe (resp. msafe, resp csafe) iff \u3008QC , R\u3009 is safe (resp. msafe, resp. csafe), for any quad-graph QC . Hence, \u3008QcritC , R\u3009 is safe (resp. msafe, resp. csafe).\n(If part) We give the proof for the case of safe quad-systems. The proof for the msafe and csafe case can be obtained by slight modification. In order to show that if \u3008QcritC , R\u3009 is safe, then R is universally safe, we prove the contrapositive. That is we show that if there exists QC such that \u3008QC , R\u3009 is unsafe, then QScritC = \u3008Q crit C , R\u3009 is unsafe. Suppose, there exists such an unsafe quad-system QSC = \u3008QC , R\u3009, we show how to incrementally construct a homomorphism h from constants in dChase(QSC) to the constants in dChase(QScritC ) such that for any Skolem blank node : b in dChase(QSC), there exists a homomorphism from descendance graph of : b to the descendance graph of h( : b) in dChase(QScritC ). Supposeh is initialized as: for any constant c \u2208 C(QSC), h(c) = : bcrit, if c \u2208 C(QSC) \\ C(QScritC ); and h(c) = c otherwise . It can be noted that for any BR r = body(r)(x, z) \u2192 head(r)(x,y) \u2208 R, if body(r)[\u00b5] \u2286 dChase0(QSC) then body(r)[\u00b5][h] \u2286 dChase0(QScricC ). Now it follows that for any i \u2208 N, level(body(r)[\u00b5]) = 0 if applicable(r, \u00b5, dChasei(QSC)), then there exists j \u2264 i such that applicable(r, h \u25e6 \u00b5, dChasej(QScritC )). Let h be extended so that for any i \u2208 N, for any Skolem blank node : b introduced in dChasei+1(QSC) while applying \u00b5 on r, for existential variable y \u2208 {y}, let h( : b) be the blank node introduced in dChasej+1(QScritC ), for the existential variable y while applying h \u25e6\u00b5 on r. Hence, it follows that, for any i \u2208 N, applicableR(r, \u00b5, dChasei(QSC)) implies there exists j \u2264 i such that applicable(r, h\u25e6\u00b5, dChasej(QScritC )), for any r, \u00b5. Also note that, for any Skolem blank node : b generated in dChasei(QSC), it can be noted that \u03bbr( : b) = \u03bbr(h( : b)) and \u03bbc( : b) = \u03bbc(h( : b)) and \u03bbv( : b)[h] = \u03bbv(h( : b)). Hence, it follows that for any Skolem blank node : b in dChase(QSC), h is a homomorphism from descendance graph of : b to the descendance graph of h( : b) in dChase(QScritC . Hence, if there exists two Skolem blank nodes : b, : b\u2032 in dChase(QSC), with : b\u2032 a descendant of : b and originRuleId( : b) = originRuleId( : b\u2032) and originV ector( : b) \u223c= originV ector( : b\u2032), then it follows that there exists h( : b), h( : b\u2032) in dChase( QScritC ), with h( : b \u2032) descendant of h( : b) and originRuleId(h( : b)) =\noriginRuleId(h( : b\u2032)) and originV ector(h( : b))\u223c= originV ector(h( : b\u2032)). Hence, it follows from the definition that QScriticC is unsafe."}], "references": [{"title": "Named graphs, provenance and trust,", "author": ["J. Carroll", "C. Bizer", "P. Hayes", "P. Stickler"], "venue": "WWW \u201905: Proceedings of the 14th international conference on World Wide Web,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2005}, {"title": "Querying for meta knowledge,", "author": ["B. Schueler", "S. Sizov", "S. Staab", "D.T. Tran"], "venue": "WWW \u201908: Proceedings of the 17th international conference on World Wide Web,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Distributed Description Logics: Assimilating Information from Peer Sources,", "author": ["A. Borgida", "L. Serafini"], "venue": "Journal on Data Semantics,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2003}, {"title": "Notes on Formalizing Context,\u201d in Proceedings of the 13th international joint conference on Artifical intelligence (ICAI", "author": ["J. McCarthy"], "venue": "Volume", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1995}, {"title": "C-OWL: Contextualizing Ontologies", "author": ["P. Bouquet", "F. Giunchiglia", "F. van Harmelen", "L. Serafini", "H. Stuckenschmidt"], "venue": "The Semantic Web - ISWC", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2003}, {"title": "Local models semantics, or contextual reasoning = locality + compatibility", "author": ["F. Giunchiglia", "C. Ghidini"], "venue": "Artificial Intelligence,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2001}, {"title": "Comparing contextual and flat representations of knowledge: a concrete case about football data", "author": ["L. Bozzato", "C. Ghidini", "L. Serafini"], "venue": "Proceedings of the seventh international conference on Knowledge capture (K-CAP", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "Simple reasoning for contextualized RDF knowledge", "author": ["M.Joseph", "L.Serafini"], "venue": "Modular Ontologies - Proceedings of the Fifth International Workshop (WOMO-2011),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2011}, {"title": "Contextualized knowledge repositories for the semantic web. Web Semantics: Science, Services and Agents on the World Wide Web, Special Issue: Reasoning with Context in the Semantic", "author": ["L. Serafini", "M. Homola"], "venue": "Web, Elsevier,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2012}, {"title": "The Implication Problem for Data Dependencies", "author": ["C. Beeri", "M.Y. Vardi"], "venue": "In Shimon Even, Oded Kariv (Eds.): Automata, Languages and Programming,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1981}, {"title": "On rules with existential variables: Walking the decidability line", "author": ["J.-F. Baget", "M. Lecl\u00e8re", "M.-L. Mugnier", "E. Salvat"], "venue": "Artificial Intelligence", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2011}, {"title": "A Generic Querying Algorithm for Greedy Sets of Existential Rules", "author": ["M. Thomazo", "J.-F. Baget", "M.-L. Mugnier", "S. Rudolph"], "venue": "KR\u201912: International Conference on Principles of Knowledge Representation and Reasoning,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2012}, {"title": "Distributed first order logics. In Frontiers Of Combining Systems 2, Studies in Logic and Computation, pages 121\u2013140", "author": ["C. Ghidini", "L. Serafini"], "venue": "Research Studies Press,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1998}, {"title": "Schema mediation in peer data management systems,", "author": ["A.Y. Halevy", "Z.G. Ives", "D. Suciu", "I. Tatarinov"], "venue": "19th International Conference on Data Engineering In ICDE, IEEE Computer Society,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2003}, {"title": "Testing containment of conjunctive queries under functional and inclusion dependencies,", "author": ["D.S. Johnson", "A.C. Klug"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1984}, {"title": "E-Connections of Abstract Description Systems,", "author": ["O. Kutz", "C. Lutz", "F. Wolter", "M. Zakharyaschev"], "venue": "Artificial Intelligence,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2004}, {"title": "Data Exchange: Semantics and Query Answering,", "author": ["R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa"], "venue": "Theoretical Computer Science,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2005}, {"title": "Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family", "author": ["D. Calvanese", "G. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "In Journal of Automated Reasoning,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2007}, {"title": "Reformulation of XML Queries and Constraints,", "author": ["A. Deutsch", "V. Tannen"], "venue": "In Proceedings of the 9th International Conference on Database Theory (ICDT\u2019", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2003}, {"title": "Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary,", "author": ["H.J. ter Horst"], "venue": "Web Semantics: Science, Services and Agents on the WWW,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2005}, {"title": "Answering conjunctive queries in the SHIQ description logic,", "author": ["B. Glimm", "C. Lutz", "I. Horrocks", "U. Sattler"], "venue": "Proceedings of the Twentieth International Joint Conference on Artificial Intelligence", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2007}, {"title": "SWRL: A Semantic Web Rule Language Combining OWL and RuleML,", "author": ["I. Horrocks", "P.F. Patel-Schneider", "H. Boley", "S. Tabet", "B. Grosof", "M. Dean"], "venue": "W3C member submission, World Wide Web Consortium,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2004}, {"title": "The chase revisited,", "author": ["A. Deutsch", "A. Nash", "J. Remmel"], "venue": "Proceedings of the twenty-seventh ACM SIGMOD-SIGACTSIGART symposium on Principles of database systems, PODS \u201908,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2008}, {"title": "Acyclicity Notions for Existential Rules and Their Application to Query Answering in Ontologies,", "author": ["B. Cuenca Grau", "I. Horrocks", "M. Kr\u00f6tzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang"], "venue": "Journal of Artificial Intelligence Research (JAIR),", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2013}, {"title": "Introduction to Formal Language Theory", "author": ["M.A. Harrison"], "venue": null, "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1978}, {"title": "Taming the infinite chase: Query answering under expressive relational constraints", "author": ["A. Cal\u0131", "G. Gottlob", "M. Kifer"], "venue": "Jrme Lang (Eds.): Principles of Knowledge Representation and Reasoning (KR\u2019", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2008}, {"title": "Towards more expressive ontology languages: The query answering problem,", "author": ["A. Cal\u0131", "G. Gottlob", "A. Pieris"], "venue": "Artificial Intelligence,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2012}, {"title": "Query Answering under Non-guarded Rules in Datalog+/-,\u201d in Pascal Hitzler, Thomas Lukasiewicz (Eds.) Web Reasoning and Rule Systems - Fourth International Conference (RR", "author": ["A. Cal\u0131", "G. Gottlob", "A. Pieris"], "venue": "vol. 6333 of Springer Lecture Notes in Computer Science,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2010}, {"title": "Generalized schema-mappings: from termination to tractability,", "author": ["B. Marnette"], "venue": "Proceedings of the twenty-eighth ACM SIGMOD-SIGACTSIGART symposium on Principles of database systems, PODS \u201909,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2009}, {"title": "Extending decidable existential rules by joining acyclicity and guardedness,", "author": ["M. Kr\u00f6tzsch", "S. Rudolph"], "venue": "Toby Walsh (Ed.) Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI\u201911) (T. Walsh, ed.),", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2011}, {"title": "Conjunctive Queries for EL with Role Composition", "author": ["M. Kr\u00f6tzsch", "S. Rudolph"], "venue": "Tessaris (Eds.): Proceedings of the 20th International Workshop on Description Logics (DL\u201907) (D. Calvanese, ed.),", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2007}, {"title": "Description logic rules", "author": ["M. Kr\u00f6tzsch", "S. Rudolph", "Pascal Hitzler"], "venue": "Proceedings of the 18th European Conference on Artificial Intelligence", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2008}, {"title": "Annotated RDF,", "author": ["O. Udrea", "D.R. Recupero", "V.S. Subrahmanian"], "venue": "ACM Transactions in Computational Logic, vol. 11,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2010}], "referenceMentions": [{"referenceID": 0, "context": "Other benefits of quads over triples are that they allow knowledge creators to specify various attributes of meta-knowledge that further qualify knowledge [2], and also allow users to query for this meta knowledge [3].", "startOffset": 155, "endOffset": 158}, {"referenceID": 1, "context": "Other benefits of quads over triples are that they allow knowledge creators to specify various attributes of meta-knowledge that further qualify knowledge [2], and also allow users to query for this meta knowledge [3].", "startOffset": 214, "endOffset": 217}, {"referenceID": 6, "context": "When reasoning with knowledge in quad form, since knowledge can be grouped and divided context wise and simultaneously be fed to separate reasoning engines, this approach improves both efficiency and scalability [9].", "startOffset": 212, "endOffset": 215}, {"referenceID": 2, "context": "Besides the above flexibility, bridge rules [5] can be provided for inter-operating the knowledge in different contexts.", "startOffset": 44, "endOffset": 47}, {"referenceID": 2, "context": "In this work, we study contextual reasoning and query answering over contextualized RDF/OWL knowledge bases in the presence of forall-existential bridge rules that allow conjunctions and existential quantifiers in them, and hence are more expressive than those in DDL [5] and McCarthy et al.", "startOffset": 268, "endOffset": 271}, {"referenceID": 3, "context": "[6].", "startOffset": 0, "endOffset": 3}, {"referenceID": 14, "context": "For query answering, we use the notion of a distributed chase, which is an extension of the standard chase [20, 21] that is widely used in the knowledge representation (KR) and Database (DB) settings for similar purposes.", "startOffset": 107, "endOffset": 115}, {"referenceID": 2, "context": "As far as the semantics for reasoning is concerned, we adopt the approach given in works such as Distributed Description Logics [5], E-connections [22], and two-dimensional logic of contexts [23], to use a set of interpretation structures as a model for contextualized knowledge.", "startOffset": 128, "endOffset": 131}, {"referenceID": 15, "context": "As far as the semantics for reasoning is concerned, we adopt the approach given in works such as Distributed Description Logics [5], E-connections [22], and two-dimensional logic of contexts [23], to use a set of interpretation structures as a model for contextualized knowledge.", "startOffset": 147, "endOffset": 151}, {"referenceID": 19, "context": "Some of the alternatives for the local semantics satisfying the above mentioned criterion are Simple, RDF, RDFS [31], OWL-Horst [27] etc.", "startOffset": 128, "endOffset": 132}, {"referenceID": 14, "context": "In order to build a procedure for query answering over a quad-system, we employ what has been called in the literature a chase [20, 21].", "startOffset": 127, "endOffset": 135}, {"referenceID": 16, "context": "[24] (also called non-oblivious chase).", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[15]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "A model I of a quad-system QSC is called universal [30], iff the following holds: I is a model of QSC , and for any model I \u2032C of QSC there exists a homomorphism from I to I \u2032C .", "startOffset": 51, "endOffset": 55}, {"referenceID": 17, "context": "An anolog of the above theorem for DLs and Databases is stated and proved in [25].", "startOffset": 77, "endOffset": 81}, {"referenceID": 17, "context": "Since the proof in [25] can easily be adapted to our case, we refer the reader to [25] for the proof.", "startOffset": 19, "endOffset": 23}, {"referenceID": 17, "context": "Since the proof in [25] can easily be adapted to our case, we refer the reader to [25] for the proof.", "startOffset": 82, "endOffset": 86}, {"referenceID": 20, "context": "[28] provides an algorithm for CQ entailment based on query rewriting.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[15], Kr\u00f6tzsch et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 30, "context": "[39], or Beeri et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "[14] can trivially be applied in our setting to obtain the undecidability result for unrestricted quad-systems.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [33].", "startOffset": 127, "endOffset": 131}, {"referenceID": 16, "context": "Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part.", "startOffset": 35, "endOffset": 39}, {"referenceID": 29, "context": "Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part.", "startOffset": 58, "endOffset": 62}, {"referenceID": 10, "context": "Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part.", "startOffset": 103, "endOffset": 107}, {"referenceID": 23, "context": "Whereas techniques such as model faithful acyclicity [32] and model summarizing acyclicity [32] are of type (i) as both the rules and instance part is considered.", "startOffset": 53, "endOffset": 57}, {"referenceID": 23, "context": "Whereas techniques such as model faithful acyclicity [32] and model summarizing acyclicity [32] are of type (i) as both the rules and instance part is considered.", "startOffset": 91, "endOffset": 95}, {"referenceID": 26, "context": "We notify the reader that the technique we follow is, similar to works such as [35, 36], to iteratively generate a doubly exponential number of objects that represent the configurations and cells of the tape of the DTM, and then simulate its working by appropriate BRs.", "startOffset": 79, "endOffset": 87}, {"referenceID": 27, "context": "We notify the reader that the technique we follow is, similar to works such as [35, 36], to iteratively generate a doubly exponential number of objects that represent the configurations and cells of the tape of the DTM, and then simulate its working by appropriate BRs.", "startOffset": 79, "endOffset": 87}, {"referenceID": 10, "context": "Borrowing the parlance from the \u2200\u2203 rules setting, where rules whose variables in the head part are contained in the variables in the body part are called range restricted rules [15], we call such BRs range restricted (RR) BRs.", "startOffset": 177, "endOffset": 181}, {"referenceID": 22, "context": "[30], it follows that for any quad-systemQSC = \u3008QC , R\u3009 and a boolean CCQ CQ, QSC |= CQ iff \u03c4(QSC) |=fol \u03c4ccq(CQ).", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[15], where it is shown that the \u2200\u2203 rule EP is polynomially reducible to fact (a set of instances) EP, and fact EP are equivalent to CQ EP.", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "Also, Cali et al [34] show that CQ containment problem, which is equivalent to \u2200\u2203 rule EP, is reducible to CQ EP.", "startOffset": 17, "endOffset": 21}, {"referenceID": 29, "context": "If P \u2208 WA, then P \u2208 JA (from [38]), 2.", "startOffset": 29, "endOffset": 33}, {"referenceID": 23, "context": "If P \u2208 JA, then P \u2208 MFA (from [32]), 3.", "startOffset": 30, "endOffset": 34}, {"referenceID": 29, "context": "WA \u2282 JA \u2282 MFA (from [38] and [32]).", "startOffset": 20, "endOffset": 24}, {"referenceID": 23, "context": "WA \u2282 JA \u2282 MFA (from [38] and [32]).", "startOffset": 29, "endOffset": 33}, {"referenceID": 16, "context": "Weak acyclicity [24, 26] is a popular technique used to detect whether a \u2200\u2203 rule set has a finite chase, thus ensuring decidability of query answering.", "startOffset": 16, "endOffset": 24}, {"referenceID": 18, "context": "Weak acyclicity [24, 26] is a popular technique used to detect whether a \u2200\u2203 rule set has a finite chase, thus ensuring decidability of query answering.", "startOffset": 16, "endOffset": 24}, {"referenceID": 29, "context": "Joint acyclicity [38] extends weak acyclicity, by also taking into consideration the join between variables in body of \u2200\u2203 rules while analyzing the rules for acyclicity.", "startOffset": 17, "endOffset": 21}, {"referenceID": 23, "context": "[32], is an acyclicity technique that guarantees finiteness of chase and decidability of query answering, in the realm of \u2200\u2203 rules.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[32] that if P is MFA, then P has a finite chase, thus ensuring decidability of query answering.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[17] and Local Model Semantics by Giunchiglia et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "[8].", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "Some of the initial works on contexts relevant to semantic web were the ones like Distributed Description Logics [5] by Borgida et al.", "startOffset": 113, "endOffset": 116}, {"referenceID": 4, "context": ", and Context-OWL [7] by Bouquet et al.", "startOffset": 18, "endOffset": 21}, {"referenceID": 8, "context": ", and the work of CKR [13, 10] by Serafini et al.", "startOffset": 22, "endOffset": 30}, {"referenceID": 7, "context": ", and the work of CKR [13, 10] by Serafini et al.", "startOffset": 22, "endOffset": 30}, {"referenceID": 32, "context": "[42] and Straccia et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[29] giving rise to the SWRL [29] language.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[29] giving rise to the SWRL [29] language.", "startOffset": 29, "endOffset": 33}, {"referenceID": 31, "context": "Since SWRL is undecidable in general, studies on computable sub-fragments gave rise to works like Description Logic Rules [40], where the authors deal with rules that can be totally internalized by a DL knowledge base, and hence if the DL considered is decidable, then also is a DL+rules KB.", "startOffset": 122, "endOffset": 126}, {"referenceID": 9, "context": "\u2200\u2203 rules, TGDs, Datalog+- rules Query answering over rules with universal-existential quantifiers in the context of databases, where these rules are called Datalog+- rules/tuple generating dependencies (TGDs), was done by Beeri and Vardi [14] even in the early 80s, where the authors show that the query entailment problem, in general, is undecidable.", "startOffset": 238, "endOffset": 242}, {"referenceID": 10, "context": "These classes (according to [15]) can broadly be divided into the following three categories: (i) bounded treewidth sets (BTS), (ii) finite unification sets (FUS), and (iii) finite extension sets (FES).", "startOffset": 28, "endOffset": 32}, {"referenceID": 14, "context": "Some of the important classes of these sets are the linear \u2200\u2203 rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].", "startOffset": 68, "endOffset": 72}, {"referenceID": 25, "context": "Some of the important classes of these sets are the linear \u2200\u2203 rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].", "startOffset": 97, "endOffset": 101}, {"referenceID": 10, "context": "Some of the important classes of these sets are the linear \u2200\u2203 rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].", "startOffset": 135, "endOffset": 139}, {"referenceID": 29, "context": "Some of the important classes of these sets are the linear \u2200\u2203 rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].", "startOffset": 176, "endOffset": 180}, {"referenceID": 11, "context": "[16].", "startOffset": 0, "endOffset": 4}, {"referenceID": 27, "context": "FUS classes include the class of \u2018sticky\u2019 rules [36, 35], atomic hypothesis rules in which the body of each rule contains only a single atom, and also the class of linear \u2200\u2203 rules.", "startOffset": 48, "endOffset": 56}, {"referenceID": 26, "context": "FUS classes include the class of \u2018sticky\u2019 rules [36, 35], atomic hypothesis rules in which the body of each rule contains only a single atom, and also the class of linear \u2200\u2203 rules.", "startOffset": 48, "endOffset": 56}, {"referenceID": 16, "context": "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].", "startOffset": 16, "endOffset": 24}, {"referenceID": 18, "context": "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].", "startOffset": 16, "endOffset": 24}, {"referenceID": 29, "context": "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].", "startOffset": 98, "endOffset": 102}, {"referenceID": 28, "context": "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].", "startOffset": 129, "endOffset": 133}, {"referenceID": 23, "context": "[32], where existence of cyclic Skolem blank-node/constant generations in the chase is detected by augmenting the rules with extra information that keeps track of the Skolem function used to generate each Skolem blank-node.", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "Data integration Studies in query answering on integrated heterogeneous databases with expressive integration rules in the realm of data integration is primarily studied in the following two settings: (i) Data exchange [24], in which there is a source database and target database that are connected with existential rules, and (ii) Peer-to-peer data management systems (PDMS) [19], where there are an arbitrary number of peers that are interconnected using existential rules.", "startOffset": 219, "endOffset": 223}, {"referenceID": 13, "context": "Data integration Studies in query answering on integrated heterogeneous databases with expressive integration rules in the realm of data integration is primarily studied in the following two settings: (i) Data exchange [24], in which there is a source database and target database that are connected with existential rules, and (ii) Peer-to-peer data management systems (PDMS) [19], where there are an arbitrary number of peers that are interconnected using existential rules.", "startOffset": 377, "endOffset": 381}, {"referenceID": 13, "context": "in the context of peer-peer data management systems [19], and decidability is attained by not allowing any kind of cycles in the peer topology.", "startOffset": 52, "endOffset": 56}, {"referenceID": 16, "context": "Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability.", "startOffset": 55, "endOffset": 63}, {"referenceID": 18, "context": "Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability.", "startOffset": 55, "endOffset": 63}, {"referenceID": 28, "context": "Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability.", "startOffset": 120, "endOffset": 124}, {"referenceID": 23, "context": "It was shown in Cuenca Grau et al [32] that their MFA technique strictly subsumes both WA and SWA techniques in expressivity.", "startOffset": 34, "endOffset": 38}], "year": 2015, "abstractText": "The proliferation of contextualized knowledge in the Semantic Web (SW) has led to the popularity of knowledge formats such as quads in the SW community. A quad is an extension of an RDF triple with contextual information of the triple. In this paper, we study the problem of query answering over quads augmented with forall-existential bridge rules that enable interoperability of reasoning between triples in various contexts. We call a set of quads together with such expressive bridge rules, a quad-system. Query answering over quadsystems is undecidable, in general. We derive decidable classes of quad-systems, for which query answering can be done using forward chaining. Sound, complete and terminating procedures, which are adaptations of the well known chase algorithm, are provided for these classes for deciding query entailment. Safe, msafe, and csafe class of quad-systems restrict the structure of blank nodes generated during the chase computation process to be directed acyclic graphs (DAGs) of bounded depth. RR and restricted RR classes do not allow the generation of blank nodes during the chase computation process. Both data and combined complexity of query entailment has been established for the classes derived. We further show that quad-systems are equivalent to forall-existential rules whose predicates are restricted to ternary arity, modulo polynomial time translations. We subsequently show that the technique of safety, strictly subsumes in expressivity, some of the well known and expressive techniques, such as joint acyclicity and model faithful acyclicity, used for decidability guarantees in the realm of forall-existential rules.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}