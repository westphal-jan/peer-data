{"id": "1601.04114", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2016", "title": "Training Recurrent Neural Networks by Diffusion", "abstract": "this original work presents naturally a significantly new algorithm for machine training recurrent neural networks ( although practical ideas are more applicable to feedforward networks as relatively well ). effectively the algorithm technology is derived from a theory in nonconvex optimization theory related to the diffusion flow equation. the contributions made in this collaborative work are two further fold. first, perhaps we accurately show how some seemingly disconnected mechanisms come used successfully in deep learning such as smart initialization, computational annealed learning frame rate, robust layerwise feedback pretraining, dust and noise injection ( phenomena as done in dropout network and sgd ) arise only naturally and automatically spontaneously from this implementation framework, whilst without fully manually adapting crafting algorithms them into the algorithms. second, suddenly we present some hypothetical preliminary model results on practically comparing the proposed allocation method evaluated against global sgd. it turns out that the chosen new algorithm really can achieve similar lower level of theoretical generalization approximate accuracy of 2d sgd in much on fewer number independent of regression epochs.", "histories": [["v1", "Sat, 16 Jan 2016 02:24:17 GMT  (1131kb,D)", "http://arxiv.org/abs/1601.04114v1", null], ["v2", "Thu, 4 Feb 2016 23:22:52 GMT  (1132kb,D)", "http://arxiv.org/abs/1601.04114v2", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["hossein mobahi"], "accepted": false, "id": "1601.04114"}, "pdf": {"name": "1601.04114.pdf", "metadata": {"source": "CRF", "title": "Training Recurrent Neural Networks by Diffusion", "authors": ["Hossein Mobahi"], "emails": ["hmobahi@csail.mit.edu"], "sections": [{"heading": "1 Introduction", "text": "Deep learning has recently beaten records in image recognition [Krizhevsky et al., 2012], speech recognition [Hinton et al., 2012a] and has made significant improvements in natural language processing [Bahdanau et al., 2014, Sutskever et al., 2014]. However, currently \u201ctraining\u201d deep networks, and specially recurrent neural networks (RNNs), is a challenging task [Martens and Sutskever, 2011]. To improve learning (in terms of convergence speed, attained training cost and generalization error) gradient based optimization methods are often used in combination with other techniques such as smart initialization [Sutskever et al., 2013], layerwise pretraining [Bengio et al., 2007], dropout [Hinton et al., 2012b], annealed learning rate, and curriculum learning [Bengio et al., 2009].\nThe difficulty in training deep networks is mainly attributed to their optimization landscape, where saddle points [Dauphin et al., 2014, Pascanu et al., 2014], plateaus, and sharp curvatures are prevalent. A general strategy for tackling difficult optimization problems is the continuation method. This method gradually transforms a highly simplified version of the problem back to its original form while following the solution along the way. The simplified problem is\nar X\niv :1\n60 1.\n04 11\n4v 1\n[ cs\n.L G\n] 1\n6 Ja\nsupposedly easy to solve. Then, each intermediate subproblem is initialized by the solution from the previous subproblem until reaching the final problem (see Figure 1).\nThere are two loose ends for using optimization by continuation: 1. how to choose the simplified problem, 2. how to transform the simplified problem to the main task. For both of these questions, there are infinite answers. More precisely, given an objective function, there are infinite ways infinite smooth convex functions that could be used as initial \u201ceasy\u201d task, and also infinite ways to gradually transform that to the main objective function. The quality of the solution attained by the continuation method critically depends on these choices. Recently we have proved that these choices can be made optimally via the diffusion equation [Mobahi and Fisher III, 2015]. Specifically, the objective function is considered as the initial heat distribution on a domain, and the heat is diffused over time according to the heat equation.\nThe solution to the heat equation on Rn is known analytically: it is the convolution of the initial heat distribution (i.e., the objective function) with the Gaussian kernel. Obviously, convolution with the Gaussian kernel smoothes the objective function. The bandwidth parameter \u03c3 of the Gaussian kernel determines the amount of smoothing. The algorithm for optimization by diffusion starts from a large \u03c3 (highly simplified objective function), and then follows the minimizer as \u03c3 shrinks toward zero (which leads to the original cost function).\nThe optimality result we derived in [Mobahi and Fisher III, 2015] is a stepping stone for developing practical algorithms. Specifically, it suggests using Gaussian convolution for creating intermediate optimization tasks, but it does not answer whether the resulted convolution could be computed efficiently or not. In fact, the answer to this question is problem specific. We have shown that for some family of functions such as multivariate polynomials, the resulted convolution can be computed in closed form [Mobahi, 2016]. In this work, we push that result further and show that, up to very reasonable approximation, common objective functions arising in deep learning also have a closed form Gaussian convolution. This is surprising because such objective function\nis highly nonlinear; involving a nested form of ill-behaved activation functions as such sign and ReLU.\nBy studying deep learning through the diffusion and continuation method, we discover two interesting observations. First, from theoretical viewpoint, some common and successful techniques to improve learning, such as noise injection [Hinton et al., 2012b], layerwise pretraining [Bengio et al., 2007], and annealed learning rate, automatically emerge from the diffused cost function. Therefore, this theory unifies some seemingly isolated techniques. Second, from a practical viewpoint, training deep networks by this method seems to result in a significant speed up compared to stochastic gradient descent (SGD) method. The preliminary results presented in this draft indicate up to 25% reduction in training time for learning RNNs.\nThis article is organized as follows. We first show that the diffused form of common activation functions has a closed form expression. After that, when we compute the diffused cost function for training a deep network, where the result depends on the diffused activation function introduced earlier. We discuss some properties of the diffused cost function and make connections to noise injection [Hinton et al., 2012b], layerwise pretraining [Bengio et al., 2007], and annealed learning rate. We conclude this article by presenting a preliminary evaluation of the proposed algorithm against SGD."}, {"heading": "2 Optimization by Diffusion and Continuation", "text": "The optimality of using the diffusion equation for creating intermediate optimization problems is studied in our earlier work [Mobahi and Fisher III, 2015]. Briefly, is a relaxation of a time evolution process that converts an objective function to its convex envelope1 [Vese, 1999]. The latter is a nonlinear partial differential equation that lacks a closed form, but once linearized, the heat equation (a special type of diffusion equation) arises,\nd dt g(x, t) = \u2206xg(x, t) , s.t. g(x, 0) = f(x) . (1)\nHere f is the original objective function, and g is its time evolution according to the heat equation. Here \u2206x is the Laplace operator w.r.t. the variable x. Diffusion is a powerful tool for simplifying the objective function. For example, the number of local minima in the Ackley\u2019s function [Ackley, 1987] is exponential in the number of variables. By diffusing this function via the heat equation, however, all local minima eventually disappear (see Figure 2).\nGoing from the nonlinear PDE of [Vese, 1999] to the (linear) heat equation is computationally of great value. That is, the solution to the heat equation is\n1The convex envelope of a function is an interesting choice (versus any other convex function) for the initial simplified version of it for various reasons. 1. Any global minimizer of the cost function is also a global minimizer of its convex envelope. 2. it provides the tightest convex underestimator of the cost function. 3. Geometrically, tt is the function whose epigraph coincides with the convex hull of the epigraph of the cost function.\nAlgorithm 1 Algorithm for Optimization by Diffusion and Continuation\n1: Input: f : X \u2192 R, Sequence \u221e > \u03c30 > \u03c31 > \u00b7 \u00b7 \u00b7 > \u03c3m = 0. 2: x0 = global minimizer of g(x;\u03c30). 3: for k = 1 to m do 4: xk = Local minimizer of g(x;\u03c3k), initialized at xk\u22121. 5: end for 6: Output: xm\nknown analytically [Widder, 1975]: it is the Gaussian convolution of the original (objective) function and the bandwidth parameter of the Gaussian determines the time point at which the diffused function is evaluated. Diffusion combined with the path following lead to a simple optimization algorithm listed in Algorithm 1."}, {"heading": "3 Diffused Activation Functions", "text": "Let k\u03c3(w) be the Gaussian kernel with zero mean and covariance \u03c3 2I. The diffused activation functions listed in Table 3 are simply obtained2 by convolving them with the Gaussian k\u03c3. Similar forms of smoothed ReLU and sign are used by [Zhang et al., 2015] with a fixed \u03c3 = 1\u221a\n2\u03c0 , for a proving learnability of deep\nnetworks.\n2All listed diffused functions are exact except tanh. Unfortunately, tanh ?k\u03c3 does not have a closed form. We leverage the approximation tanh(y) \u2248 erf( \u221a \u03c0 2 y). Notice that we know the exact diffused form for erf as listed in the table. Thus, by convolving both sides with k\u03c3 we obtain [tanh ?k\u03c3 ](y) \u2248 erf( \u221a \u03c0 2 y\u221a 1+\u03c0\n2 \u03c32\n). The R.H.S. of the latter form can\nbe again approximated via tanh(y) \u2248 erf( \u221a \u03c0 2 y). This leads to the approximate identity\n[tanh ?k\u03c3 ](y) \u2248 tanh( y\u221a 1+\u03c0\n2 \u03c32\n).\nName Original Diffused Sign sign(x) erf( x\u221a\n2\u03c3 )\nError erf(ax) erf( ax\u221a 1+2(a\u03c3)2 ) Tanh tanh(x) tanh( x\u221a 1+\u03c02 \u03c3 2 ) ReLU max(0, x) \u03c3\u221a 2\u03c0 e\u2212 x2 2\u03c32 + 12x ( 1 + erf( x\u221a 2\u03c3 ) )"}, {"heading": "4 Training RNNs", "text": ""}, {"heading": "4.1 RNN Cost Function", "text": "Given a set of S training sequences, each of length T . Denote the s\u2019th sequence by \u3008(xs,1,ys,1), . . . , (xs,T ,ys,T )\u3009. Given some discrepancy function d. The problem of sequence learning by an RNN can be stated as below,\nmin a,b,m0,U ,V ,W S\u2211 s=1 T\u2211 t=1 d(h(ns,t)\u2212 ys,t) (2)\ns.t. ns,t ,W h(ms,t) + b (3)\nms,t , Uxs,t + V h(ms,t\u22121) + a , (4)\nwhere a, b, m0, W , U and V are the weights of the network. Denote the dimension of xs,t and ys,t be X and Y respectively. Also denote the number of neurons by H. Then, a is H \u00d7 1, b is Y \u00d7 1, m0 is H \u00d7 1, W is Y \u00d7H, U is H \u00d7X, and V is H \u00d7H. Obviously ns,t is Y \u00d7 1 and ms,t is H \u00d7 1.\nSuppose ms,0 = m0, i.e. the initial state is independent of the training sequence. Here h is some activation function. When the argument of h is a vector, the result will be a vector of the same size, whose entries consists of the element-wise application of h.\nTreating each ns,t and ms,t as independent variables and forcing their definition (equality) by some penalty function, we arrive at the following unconstrained problem,\nmin a,b,m0,U ,V ,W ,M ,N S\u2211 s=1 T\u2211 t=1\nd(h(ns,t)\u2212 ys,t)\n+ \u03bb ( p ( W h(ms,t) + b\u2212 ns,t ) + p ( Uxt + V h(ms,t\u22121) + a\u2212ms,t )) ,\nwhere the notation N and M are matrices whose columns are comprised of ns,t and ms,t for all choices of (s, t).\nLetting, d(e) , \u2016e\u20162 and p(e) , \u2016e\u20162, the problem can be expressed as below,\nmin a,b,m0,U ,V ,W ,M ,N S\u2211 s=1 T\u2211 t=1\n\u2016h(ns,t)\u2212 ys,t\u20162\n+ \u03bb ( \u2016W h(ms,t) + b\u2212 ns,t\u20162 + \u2016Uxs,t + V h(ms,t\u22121) + a\u2212ms,t\u20162 ) .\nHere \u03bb determines the weight of the penalty for constraint violation."}, {"heading": "4.2 Diffused Cost", "text": "When the objective function is evolved according to the diffusion equation (1), the diffused objective has a closed form expression. Specifically, it is obtained by the convolution of the original objective with the Gaussian kernel. This can be more formally expressed as the following. Arrange all optimization variables into a long vector w, i.e. w , vec(a, b,m0,U ,V ,W ,M ,N). Hence, the cost function can be denoted by f(w). The diffused cost function g is obtained by:\ng(w;\u03c3) , [f ? k\u03c3](w) . (5)\nAfter computing this convolution, the variables in w can be replaced by their original names according to the arrangements made in w , vec(a, b,m0,U ,V ,W ,M ,N).\nDenote the diffused form of the activation function h by h\u0303\u03c3, that is h\u0303\u03c3(x) , [h ? k\u03c3](x). Similarly, define h\u03032\u03c3(x) , [h 2 ? k\u03c3](x). The diffused cost w.r.t. optimization variables has the following closed form (see Appendix A):\nS\u2211 s=1 ( T\u2211 t=1\n\u2016h\u0303\u03c3(ns,t)\u2212 ys,t\u20162 + \u2016 \u221a h\u03032\u03c3(ns,t)\u20162 \u2212 \u2016h\u0303\u03c3(ns,t)\u20162\n+ \u03bb ( \u2016W h\u0303\u03c3(ms,t) + b\u2212 ns,t\u20162 + \u2016Uxs,t + V h\u0303\u03c3(ms,t\u22121) + a\u2212ms,t\u20162\n+\u2016W diag( \u221a h\u03032\u03c3(ms,t))\u20162F \u2212 \u2016W diag(h\u0303\u03c3(ms,t))\u20162F + \u03c32Y \u2016h\u0303\u03c3(ms,t)\u20162 ) +\u03bb\nT\u22121\u2211 t=0\n\u2016V diag( \u221a h\u03032\u03c3(ms,t))\u20162F \u2212 \u2016V diag(h\u0303\u03c3(ms,t))\u20162F + \u03c32H \u2016h\u0303\u03c3(ms,t)\u20162 ) .\nHere \u2016 . \u2016F denotes the Frobenius norm of a matrix."}, {"heading": "4.3 Approximate Diffused Cost", "text": "Ideal solution requires S \u00d7 T auxiliary variables for ns,t and ms,t. This is not practical as often S is large. Thus, we resort to an approximate formulation here. Instead of solving for the optimal ns,t and ms,t, we approximate them as below,\nns,t = W h\u0303\u03c3(ms,t) + b , ms,t = Uxs,t + V h\u0303\u03c3(ms,t\u22121) + a . (6)\nThis allows us to eliminate the variables ns,t and ms,t from the remaining optimization. The simplified optimization problem is as below,\nS\u2211 s=1 ( T\u2211 t=1\n\u2016h\u0303\u03c3(ns,t)\u2212 ys,t\u20162 + \u2016 \u221a h\u03032\u03c3(ns,t)\u20162 \u2212 \u2016h\u0303\u03c3(ns,t)\u20162\n+ \u03bb ( \u2016W diag( \u221a h\u03032\u03c3(ms,t))\u20162F \u2212 \u2016W diag(h\u0303\u03c3(ms,t))\u20162F + \u03c32Y \u2016h\u0303\u03c3(ms,t)\u20162 ) +\u03bb\nT\u22121\u2211 t=0\n\u2016V diag( \u221a h\u03032\u03c3(ms,t))\u20162F \u2212 \u2016V diag(h\u0303\u03c3(ms,t))\u20162F + \u03c32H \u2016h\u0303\u03c3(ms,t)\u20162 ) .\nThe gradient of this cost w.r.t. learning parameters are provided in Appendix B."}, {"heading": "5 Properties of Diffused Cost", "text": "The optimization problem that arises from training a deep network is often challenging. Therefore, local optimization methods (e.g., SGD) are used with a combination of some helping techniques. Although these techniques seem\ndisconnected from each other, some of them emerge automatically from the diffused cost function. Therefore, these techniques might be unified under one simple theory. These methods and their connection to the diffused cost are discussed in the following."}, {"heading": "5.1 Careful Initialization", "text": "Local optimization methods are generally sensitive to initialization when it comes to nonconvex cost functions. Deep learning is not an exception [Sutskever et al., 2013]; a recent study shows that the performance of deep networks and recurrent networks critically depends on initialization [Safran and Shamir, 2015]. In contrast, the diffusion algorithm is deterministic and almost independent of initialization3 for two reasons. First, after enough smoothing the cost function becomes unimodal, and in case of convexity, will have one global minimum. In fact, the minimizer of the heavily smoothed function coincides with its center mass [Mobahi, 2012]. Thus, diffusion provides an interesting deterministic initialization. Second, the update rules are completely deterministic (unless one chooses to use SGD instead of GD for local optimization in Algorithm 1) and no notion of randomness is involved in the updates."}, {"heading": "5.2 Annealed Learning Rate", "text": "Each iteration of the gradient descent essentially sees the first order Taylor expansion of the cost function g(x) at the current estimate of the solution point x0. The linear approximation has good accuracy only within a small neighborhood of x0, say of radius \u03c1. Enforcing accuracy by the constraint \u2016x\u2212 x0\u2016 \u2264 \u03c1, we arrive at the following problem,\nmin x g(x0) + (x\u2212 x0)T\u2207g(x0) s.t. \u2016x\u2212 x0\u2016 \u2264 \u03c1 . (7)\nUsing Lagrange multipliers method, the solution of this optimization turns out to be x\u2217 = x0 \u2212 \u03c1 \u2207g(x0)\u2016\u2207g(x0)\u2016 . The radius \u03c1 could be chosen intelligently, e.g., by restricting the tolerated amount of linearization error. Specifically, in order to ensure \u2200x ; \u2016x \u2212 x0\u2016 \u2264 \u03c1\u21d2 |g(x0) + (x\u2212 x0)T\u2207g(x0)\u2212 g(x)| \u2264 , we can choose \u03c1 = \u221a cf \u03c3 (see Ap-\npendix C for proof). Here cf is some number satisfying cf \u2265 12\u03c0 \u2211 j,k \u2016 d2f dxj dxk \u2016n 2 , which obviously exists when the norm is bounded. Putting the pieces together, the solution of the linearized problem can be\nexpressed as x\u2217 = x0 \u2212 \u03b7 \u03c3 \u2207g(x0)\u2016\u2207g(x0)\u2016 , where \u03b7 , \u221a cf is a constant. This is\n3Path following process could be sensitive to initialization when it reaches a saddle point. Due to instability of saddle points, the direction the algorithm takes could be affected even by small perturbations. Thus, different initializations may end up reaching different solutions. However, these saddle points often occur due to the symmetry in the problem (either the original or the diffused) and the chosen direction does not affect the quality of the solution. This contrasts to gradient descent on a nonconvex objective, where depending on initialization, very solutions of different quality might be reached.\nessentially a gradient descent update with a specific choice of the step size. Since \u03c3 decays toward zero within the continuation loop, the step size (also called learning rate) anneals form an initially large value to eventually a small value."}, {"heading": "5.3 Noise Injection", "text": "Injection of random noise into the training process can lead to more stable solutions. This is often crucial in order to obtain satisfactory generalization in deep learning. The well known dropout is a specific way of noise injection: in each iteration, it eliminates a random subset of nodes throughout the learning [Hinton et al., 2012b]. The stochasticity in SGD is another relevant example. It is known that SGD achieves better generalization compared to a full batch gradient descent. Although these schemes differ in details, e.g., the distribution of the noise or how it is applied to the learning process, they share the same idea of noise injection in learning.\nIt turns out that the diffused cost function also has this property. In order to see that, recall the definition of the diffused cost function from (5):\ng(w;\u03c3) , [f ? k\u03c3](w) = \u222b W f(w \u2212 t)k\u03c3(t) dt (8)\nThus, the gradient at a point w0 has the following form. \u2207g(w0;\u03c3) = \u222b W \u2207f(w0 \u2212 t)k\u03c3(t) dt (9)\n\u2248 1 J J\u2211 j=1 \u2207f(w0 \u2212 tj) , tj \u223c N (0, \u03c32I) . (10)\nThis means if we were to approximate the gradient of the diffused cost by MCMC method, it would average over a number of noisified gradients. Specifically, the noise would be additive w.r.t. the weights of the network and it would have a normal distribution with zero mean and variance of \u03c32. The noise injection of (10) recently has also been proposed by [Neelakantan et al., 2015], but with a heuristic motivation and relying on numerical sampling exactly as in (10). Such noise injection has been shown to successfully train a 20-layer network with gradient descent. From a higher level perspective, this noise injection has some similarity to SGD; the latter also averages (over multiple epochs) the effect of noisified gradients.\nA key advantage of using the diffusion framework for noise injection, however, is that the expected noisified gradient (the integral in (9)) has a closed form expression, while the other schemes are mainly sampling based. This leads to a huge computational gain for the diffusion method: while other methods would need a lot of sampling iterations in order to reach a reasonable approximation to the expected noisified gradient (and the number of these samples could grow exponentially in the number of weights), the diffusion method achieves this with almost no computational effort and without any sampling."}, {"heading": "5.4 Layerwise Pretraining", "text": "We argue that when \u03c3 is large, the network only focuses on short range dependencies, and as \u03c3 shrinks toward zero, longer range dependencies are gradually learned. In order to see why this happens, let\u2019s for example inspect the partial gradient \u2207a g, which has the form \u2211T t=1 rtM t (see Appendix B for deriva-\ntions and the definition of rt), where M t , I + V diag ( h\u0303\u2032(mt\u22121) ) M t\u22121 and M1 , I. Resolving the recursion in M t leads to,\nM t = I + V diag ( h\u0303\u2032\u03c3(mt\u22121) ) + V h\u0303\u2032\u03c3(mt\u22121)V h\u0303 \u2032 \u03c3(mt\u22122) + . . . .\nWhen \u03c3 \u2192\u221e, all the sigmoid-like activation functions listed in (3) become flat and their gradient vanishes h\u0303\u2032\u03c3 \u2192 0. This implies that by choosing \u03c3 large enough, one can find a small enough that satisfies \u2016 diag(h\u0303\u2032\u03c3)\u2016 \u2264 . Since the contribution of each term in the above sum will be at most equal to its matrix norm, we can derive,\n\u2016M t\u2016 \u2264 \u2016I\u2016+ \u2016V \u2016+ ( \u2016V \u2016)2 + ( \u2016V \u2016)3 + . . . .\nwhen \u03c3 is very large, and thus is very small, we can ignore all the terms involving , which leaves us with M t \u2248 I. As we gradually reduce \u03c3, and thus increase , we can reconsider terms involving smaller exponents, while the higher order terms still remain negligible. By gradually decreasing \u03c3, M t can be approximated by I, then, I+V diag ( h\u0303\u2032\u03c3(mt\u22121) ) , then I+V diag ( h\u0303\u2032\u03c3(mt\u22121) ) + V h\u0303\u2032\u03c3(mt\u22121)V h\u0303 \u2032 \u03c3(mt\u22122) and so on.\nThis is conceptually very similar to layerwise pretraining [Bengio et al., 2007], as the learning in each layer starts from considering only its immediate previous layer and then gradually switches to the full consideration by considering larger and larger number of previous layers."}, {"heading": "5.5 Choice of the Activation Function", "text": "In order to implement the method, we need to obtain the explicit expressions of h\u0303\u03c3 and h\u03032\u03c3 for a given activation function h. For example, suppose we set h(x) = erf(ax), where a is a parameter that determines the sharpness of the activation function. Note that lima\u2192\u221e erf(ax) = sign(x) and erf( \u221a \u03c0 2 x) \u2248 tanh(x). The form of h\u0303\u03c3 can be already looked up from Table 3, which is repeated below,\nh\u0303(x) = erf( ax\u221a\n1 + 2(a\u03c3)2 ) . (11)\nIn the following, we only focus on h\u03032\u03c3. Unfortunately, h\u03032(x) lacks a closed form expression. However, observe that erf2(x) \u2248 1\u2212 e\u2212 4\u03c0 x2 . This approximation has a reasonably good accuracy as shown in Figure 3. Using this approximation, it follows that [erf2(a ) ? k\u03c3](x) \u2248 [1\u2212 e\u2212 4 \u03c0 (a ) 2 k\u03c3](x).\nh\u03032(x) , [erf2(a ) ? k\u03c3](x)\n\u2248 [1\u2212 e\u2212 4\u03c0 (a ) 2\nk\u03c3](x)\n= 1\u2212 \u221a \u03c0 e \u2212 4a2x2 \u03c0+8a2\u03c32\n\u221a \u03c0 + 8a2\u03c32 ."}, {"heading": "6 Preliminary Results", "text": "Here we present a comparison between SGD and the proposed diffusion framework. The hyperparameters in both methods are carefully searched to ensure a fair comparison. We use erf as the activation function. The task is to learn adding two numbers, and is adapted from [Martens and Sutskever, 2011]. The network consists of has 10 hidden units, and it has two inputs and one output. One of the input units reads a sequence of 10 real numbers, and the other a sequence of 10 binary numbers. The binary numbers are zero everywhere except two random locations. The task is to add the values from the first sequence, at the two locations marked by the second sequence.\nWe trained the network by 1000 sequences, and generalization is computed from a test set of 100 sequences. The result is shown in the plots. The horizontal axis shows the generalization error, and the vertical axis shows how many epochs it takes to reach that generalization error. For example, with 50 batches of size 50 samples, in order to reach around error of 0.02, SGD (blue) needs about 90 epochs, while diffusion methods (red) needs about 20 epochs."}, {"heading": "7 Related Works & Future Directions", "text": "This work specifically studies the use of the diffusion equation for optimizing the objective function in deep learning. However, there is a growing number of techniques by others that propose new algorithms for deep learning. Using tensor decomposition techniques, [Janzamin et al., 2015] offers new algorithms for deep learning with performance guarantee. [Hazan et al., 2015] provides a conceptual similar algorithm to ours. However, instead of computing the convolution analytically, the latter work relies on numerical sampling. It can guarantee reaching the global minimum for certain scenarios.\nThis work relies on smoothing the objective function by convolving it with the Gaussian kernel. We have previously shown that this particular form of smoothing is optimal in a certain sense, by relating Gaussian convolution to a relaxation of the convex envelope. Although connection to the convex envelope is meaningful in the context of nonconvex objective functions, there are side benefits in smoothing even when the objective function is convex. For example, smoothing a nonsmooth convex objective function by convolution can improve the convergence rate of stochastic optimization algorithms [Duchi et al., 2012].\nAs discussed in Section 5.3, smoothing can be considered as means to inject noise into the training process. The idea of noise injection is already used in methods such as SGD or dropout [Hinton et al., 2012b] in order to improve learning. The key advantage of our framework for noise injection, however, is that the noise injection can be achieved in closed form and without need of sampling. In order words, we can compute the effect of infinitely many noisified objective functions in closed form. This is similar to the idea of Marginalized\nDenoising Autoencoders (mDA) [Chen et al., 2014], where the effect of infinitely many nosified inputs is marginalized to obtain a closed form expression. However, mDA limits the form of the injected noise. Specifically, the marginalized effect is only computable in a linear reconstruction setup (nonlinearity is applied only after computation of the marginalized reconstruction). In addition, mDA performs noise injection layer by layer in a greedy fashion. In contrast, our framework is able to compute closed form expression for the entire deep network and allowing full nonconvexity of the associated optimization, up to reasonable approximation.\nDiffusion equation provides an approximate evolution toward the convex envelope. Consequently, it is not perfect: if global minimum is very narrow, diffusion can miss that minima in favor of a wider minimum whose value is slightly larger than the narrow global minimum (see Figure 6). This may seem a disadvantage at the first glance. However, the wider minima are in fact more stable4, which could be more desired in practice, e.g. generalizing better. In fact, a recent analysis has shown that SGD attains better generalization when the objective function is smoother [Hardt et al., 2015]. Note that in our framework, initializing the algorithm with larger \u03c3 automatically provides a smoother surrogate cost function where unstable minima disappear. Thus, it is more likely to remain in the basin of attraction of the stable minima. A thorough investigation of how smoothing the cost function in the diffusion setting may improve the generalization performance is a direction for future research.\nA closely related work to ours is Annealed Gradient Descent [Pan and Jiang, 2015],\n4By a stable minimum we mean that a small perturbation of the equilibrium resides in the basin of attraction of the same equilibrium. This is not true if the minimum is too narrow; slight perturbation may put the gradient decent into a different basin of attraction.\nwhere the objective landscape is also initially approximated by a smoother function and is gradually transformed to the original one. However, the unlike this work where Gaussian smoothing is theoretically motivated for nonconvex optimization [Mobahi and Fisher III, 2015], in [Pan and Jiang, 2015] coarse-to-fine approximation of the objective function is based on heuristically motivated procedure. More precisely, the latter uses vector quantization methods in order to generate a code book by which the coarse cost function is approximated. Another difference between these two works is that the representation of the smoothed function in our framework is simpler, as we directly obtain a closed form expression of the objective function. that is a simpler setup than approximation by codebook generation."}, {"heading": "8 Acknowledgment", "text": "This research is partially funded by Shell Research. Hossein Mobahi is thankful to John W. Fisher, William T. Freeman, Yann LeCun, and Yoshua Bengio for comments and discussions and to Peter Bartlett and Fei Sha for suggesting connections to [Duchi et al., 2012, Chen et al., 2014]. Hossein Mobahi is grateful to Kate Saenko for discussions in earlier phase of this work."}, {"heading": "A Diffused RNN Training Cost", "text": "Diffusing the cost function w.r.t. a, b,U ,V ,W yields5,\nT\u2211 t=1\n\u2016h(nt)\u2212 yt\u20162 (12) + \u03bb ( \u2016W h(mt) + b\u2212 nt\u20162 + \u2016Uxt + V h(mt\u22121) + a\u2212mt\u20162 (13) +\u03c32Y (1 + \u2016h(mt)\u20162) + \u03c32H(1 + \u2016xt\u20162 + \u2016h(mt\u22121)\u20162) ) . (14)\nSmoothing w.r.t. mt and nt leads 6 to,\nT\u2211 t=1\n\u2016h\u0303(nt)\u2212 yt\u20162 + \u2016 \u221a h\u03032(nt)\u20162 \u2212 \u2016h\u0303(nt)\u20162 (15) + \u03bb ( \u2016W h\u0303(mt) + b\u2212 nt\u20162 + \u2016Uxt + V h\u0303(mt\u22121) + a\u2212mt\u20162 (16)\n+\u03c32Y (2 + \u2016h\u0303(mt)\u20162) + \u03c32H(2 + \u2016xt\u20162 + \u2016h\u0303(mt\u22121)\u20162) (17) +\u2016W diag( \u221a h\u03032(mt))\u20162F \u2212 \u2016W diag(h\u0303(mt))\u20162F (18)\n+\u2016V diag( \u221a h\u03032(mt\u22121))\u20162F \u2212 \u2016V diag(h\u0303(mt\u22121))\u20162F ) . (19)\nDiscarding constants terms, i.e. those that do not depend on neither of optimization variables a, b,U ,V ,W ,M ,N , simplifies the diffused cost to the following,\nT\u2211 t=1\n\u2016h\u0303(nt)\u2212 yt\u20162 + \u2016 \u221a h\u03032(nt)\u20162 \u2212 \u2016h\u0303(nt)\u20162 (20) + \u03bb ( \u2016W h\u0303(mt) + b\u2212 nt\u20162 + \u2016Uxt + V h\u0303(mt\u22121) + a\u2212mt\u20162 (21)\n+\u2016W diag( \u221a h\u03032(mt))\u20162F \u2212 \u2016W diag(h\u0303(mt))\u20162F + \u03c32Y \u2016h\u0303(mt)\u20162 ) (22)\n+\u03bb T\u22121\u2211 t=0\n\u2016V diag( \u221a h\u03032(mt))\u20162F \u2212 \u2016V diag(h\u0303(mt))\u20162F + \u03c32H \u2016h\u0303(mt)\u20162 . (23)\n5We use the fact that convolution of (xTy)2 with k\u03c3(x) is (xTy)2 + \u03c32\u2016y\u20162. 6We use the identity that convolution of \u2016Ah(x) + b\u20162 with k\u03c3(x) is equal to \u2016Ah\u0303(x) +\nb\u20162 + \u2016A diag( \u221a h\u03032(x))\u20162F \u2212 \u2016A diag(h\u0303(x))\u2016 2 F ."}, {"heading": "B Gradient of Diffused Cost", "text": "Below denotes the element-wise product of two matrices.\ndg db = \u2211 t \u2202nt \u2202b \u2202g \u2202nt (24)\n= \u2211 t I ( 2h\u0303\u2032(nt) (h\u0303(nt)\u2212 yt) + h\u03032 \u2032 (nt)\u2212 2h\u0303\u2032(nt) h\u0303(nt) ) (25)\n= \u2211 t ( h\u03032 \u2032 (nt)\u2212 2h\u0303\u2032(nt) yt ) . (26)\ndg\ndW = \u2211 t \u2202g \u2202W + \u2211 d \u2202g \u2202n (d) t \u2202n (d) t \u2202W (27)\n= 2\u03bbW diag ( T\u2211 t=1 ( h\u03032(mt) \u2212 h\u03032(mt) )) (28)\n+ T\u2211 t=1 ( h\u03032 \u2032 (nt)\u2212 2h\u0303\u2032(nt) yt ) h\u0303(mt) T (29)\nrt , ( h\u03032 \u2032 (nt)\u2212 2h\u0303\u2032(nt) yt )T ( W diag(h\u0303\u2032(mt)) ) +\u03bb (( h\u03032 \u2032 (mt)\u2212 2h\u0303\u2032(mt) h\u0303(mt)\n)T (1T (W W ) + It6=T1T (V V )) +2\u03c32(It 6=TH + Y )(h\u0303\u2032(mt) h\u0303(mt))T ) . (30)\n( dg\nda )T = T\u2211 t=1 ( dg dmt )T dmt da\n(31)\n= T\u2211 t=1 (( \u2202g \u2202nt )T \u2202nt \u2202mt + ( \u2202g \u2202mt )T ) dmt da\n(32)\n= T\u2211 t=1 rtM t (33)\nM t , dmt da = \u2202mt \u2202a + \u2202mt \u2202mt\u22121\nM t\u22121 = I + V diag ( h\u0303\u2032(mt\u22121) ) M t\u22121(34)\nM1 , I . (35)\ndg\ndV =\n\u2202g\n\u2202V + T\u2211 t=1 \u2211 d dg dm (d) t dm (d) t dV (36)\n= \u2202g\n\u2202V + T\u2211 t=1 \u2211 d (( \u2202g \u2202nt )T \u2202nt \u2202mt + ( \u2202g \u2202mt )T )(d) dm (d) t dV (37)\n= 2\u03bbV diag ( T\u22121\u2211 t=0 ( h\u03032(mt) \u2212 h\u03032(mt) )) + T\u2211 t=1 \u2211 d r (d) t M (d) t (38)\nM (d) t ,\ndm (d) t\ndV (39)\n= \u2202m\n(d) t \u2202V + \u2211 d\u2032 \u2202m (d) t \u2202m (d\u2032) t\u22121 M (d\u2032) t\u22121 (40)\n= \u201dZero matrix except d\u2019th row set to h\u0303T (mt\u22121)\u201d + \u2211 d\u2032 vd,d\u2032 h\u0303 \u2032(m (d\u2032) t\u22121)M (d\u2032) t\u22121(41)\nM (d) 1 , \u201dZero matrix except d\u2019th row set to h\u0303 T (m0)\u201d . (42)\ndg\ndU =\n\u2202g\n\u2202U + T\u2211 t=1 \u2211 d dg dm (d) t dm (d) t dU (43)\n= \u2202g\n\u2202U + T\u2211 t=1 \u2211 d (( \u2202g \u2202nt )T \u2202nt \u2202mt + ( \u2202g \u2202mt )T )(d) dm (d) t dU (44)\n= 0 + T\u2211 t=1 \u2211 d r (d) t ( P (d) t ) (45)\nP (d) t ,\ndm (d) t\ndU (46)\n= \u2202m\n(d) t \u2202U + \u2211 d\u2032 \u2202m (d) t \u2202m (d\u2032) t\u22121 P (d\u2032) t\u22121 (47)\n= \u201dZero matrix except d\u2019th row set to xTt \u201d + \u2211 d\u2032 vd,d\u2032 h\u0303 \u2032(m (d\u2032) t\u22121)P (d\u2032) t\u22121(48)\nP (d) 1 , \u201dZero matrix except d\u2019th row set to x T 1 \u201d . (49)\n( dg\ndm0 )T = (\n\u2202g\n\u2202m0 )T + T\u2211 t=1 ( dg dmt )T dmt dm0\n(50)\n= ( \u2202g\n\u2202m0 )T + T\u2211 t=1 (( \u2202g \u2202nt )T \u2202nt \u2202mt + ( \u2202g \u2202mt )T ) dmt dm0\n(51)\n= \u03bb (( h\u03032 \u2032 (m0)\u2212 2h\u0303\u2032(m0) h\u0303(m0) )T (1T (V V )) (52) +2H\u03c32(h\u0303\u2032(m0) h\u0303(m0))T ) (53)\n+ T\u2211 t=1 rt ( Qt ) (54)\nQt , dmt dm0 = \u2202mt \u2202mt\u22121\nQt\u22121 = V diag ( h\u0303\u2032(mt\u22121) ) Qt\u22121 (55)\nQ0 , I . (56)"}, {"heading": "C Bounding Linearization Error", "text": "Proposition Assume n \u2265 5, cf \u2265 12\u03c0 \u2211 j,k \u2016 d2f dxj dxk \u2016n 2 and \u03c12cf 1 \u03c32 \u2264 . Then if follows that \u2200x ; \u2016x\u2212 x0\u2016 \u2264 \u03c1\u21d2 |g(x0) + (x\u2212 x0)T\u2207g(x0)\u2212 g(x)| \u2264 .\nProof First we claim that 12\u039bg \u2264 1 2\u03c0\u03c32 \u2211 j,k \u2016 d2f dxj dxk \u2016n 2 . We prove this claim as below,\n1 2 \u039bg \u2264 max x \u2016\u22072g(x)\u2016F (57)\n\u2264 max x \u2211 j,k | d 2g dxj dxk (x)| (58)\n\u2264 \u2211 j,k max x | d 2g dxj dxk (x)| (59)\n= \u2211 j,k \u2016 d 2g dxj dxk \u2016\u221e (60)\n= \u2211 j,k \u2016 d 2f dxj dxk ? k\u03c3\u2016\u221e (61)\n\u2264 \u2211 j,k \u2016 d 2f dxj dxk \u2016 p p\u22121 \u2016k\u03c3\u2016p (62)\n\u2264 (\u2211 j,k \u2016 d 2f dxj dxk \u2016 p p\u22121 )(\u222b X kp\u03c3(x) dx ) 1 p\n(63)\n\u2264 (\u2211 j,k \u2016 d 2f dxj dxk \u2016 p p\u22121 )( (2\u03c0)(1\u2212p)\u03c32(1\u2212p) p ) n 4p\n(64)\n= (\u2211 j,k \u2016 d 2f dxj dxk \u2016 p p\u22121 )( (2\u03c0)(1\u2212p) p ) n 4p \u03c3 n(1\u2212p) 2p , (65)\nwhere (62) is due to Young\u2019s convolution inequality and holds for any p \u2265 1. In particular, when n \u2265 5, by setting p = nn\u22124 , we obtain\n1 2 \u039bg \u2264 (\u2211 j,k \u2016 d 2f dxj dxk \u2016 p p\u22121 )( (2\u03c0)(1\u2212p) p ) n 4p \u03c3 n(1\u2212p) 2p (66)\n1 2 \u039bg = (\u2211 j,k \u2016 d 2f dxj dxk \u2016n 2 ) 1 2\u03c0\u03c32 ( 1\u2212 4 n )n 4\u22121\n(67)\n1 2 \u039bg \u2264 (\u2211 j,k \u2016 d 2f dxj dxk \u2016n 2 ) 1 2\u03c0\u03c32 . (68)\nThis proves our earlier claim that 12\u039bg \u2264 1 2\u03c0\u03c32 \u2211 j,k \u2016 d2f dxj dxk \u2016n 2 . Combining\nthis with the assumption 12\u03c0 \u2211 j,k \u2016 d2f dxj dxk \u2016n 2 \u2264 cf , it follows that 12\u039bg \u2264 cf 1 \u03c32 , which implies 12\u03c1 2\u039bg \u2264 \u03c12cf 1\u03c32 . The latter combined with the assumption \u03c12cf 1 \u03c32 \u2264 yields 1 2\u03c1\n2\u039bg \u2264 . Combining this with the Taylor\u2019s remainder theorem |g(x0)+(x\u2212x0)T\u2207g(x0)\u2212g(x)| \u2264 12\u03c1\n2\u039bg gives |g(x0)+(x\u2212x0)T\u2207g(x0)\u2212 g(x)| \u2264 ."}], "references": [{"title": "Neural machine translation by jointly learning to align and translate", "author": ["Bahdanau et al", "D. 2014] Bahdanau", "K. Cho", "Y. Bengio"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "Greedy layer-wise training of deep networks", "author": ["Bengio et al", "Y. 2007] Bengio", "P. Lamblin", "D. Popovici", "H. Larochelle"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "al. et al\\.,? \\Q2007\\E", "shortCiteRegEx": "al. et al\\.", "year": 2007}, {"title": "Marginalized denoising auto-encoders for nonlinear representations", "author": ["Chen et al", "M. 2014] Chen", "K.Q. Weinberger", "F. Sha", "Y. Bengio"], "venue": "In Proceedings of the 31st International Conference on Machine Learning", "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "Identifying and attacking the saddle point problem in high-dimensional non-convex optimization", "author": ["Dauphin et al", "Y.N. 2014] Dauphin", "R. Pascanu", "C. Gulcehre", "K. Cho", "S. Ganguli", "Y. Bengio"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "Randomized smoothing for stochastic optimization", "author": ["Duchi et al", "J.C. 2012] Duchi", "P.L. Bartlett", "M.J. Wainwright"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "al. et al\\.,? \\Q2012\\E", "shortCiteRegEx": "al. et al\\.", "year": 2012}, {"title": "Train faster, generalize better: Stability of stochastic gradient descent. CoRR, abs/1509.01240", "author": ["Hardt et al", "M. 2015] Hardt", "B. Recht", "Y. Singer"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2015\\E", "shortCiteRegEx": "al. et al\\.", "year": 2015}, {"title": "On graduated optimization for stochastic non-convex problems. CoRR, abs/1503.03712", "author": ["Hazan et al", "E. 2015] Hazan", "K.Y. Levy", "S. Shalev-Shwartz"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2015\\E", "shortCiteRegEx": "al. et al\\.", "year": 2015}, {"title": "Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups", "author": ["Hinton et al", "G.E. 2012a] Hinton", "L. Deng", "D. Yu", "G.E. Dahl", "A. Mohamed", "N. Jaitly", "A. Senior", "V. Vanhoucke", "P. Nguyen", "T.N. Sainath", "B. Kingsbury"], "venue": "IEEE Signal Process. Mag.,", "citeRegEx": "al. et al\\.,? \\Q2012\\E", "shortCiteRegEx": "al. et al\\.", "year": 2012}, {"title": "Improving neural networks by preventing co-adaptation of feature detectors. CoRR, abs/1207.0580", "author": ["Hinton et al", "G.E. 2012b] Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2012\\E", "shortCiteRegEx": "al. et al\\.", "year": 2012}, {"title": "Generalization bounds for neural networks through tensor factorization. CoRR, abs/1506.08473", "author": ["Janzamin et al", "M. 2015] Janzamin", "H. Sedghi", "A. Anandkumar"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2015\\E", "shortCiteRegEx": "al. et al\\.", "year": 2015}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["Krizhevsky et al", "A. 2012] Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "In Advances in Neural Information Processing Systems", "citeRegEx": "al. et al\\.,? \\Q2012\\E", "shortCiteRegEx": "al. et al\\.", "year": 2012}, {"title": "Learning recurrent neural networks with hessian-free optimization", "author": ["Martens", "Sutskever", "J. 2011] Martens", "I. Sutskever"], "venue": "In ICML,", "citeRegEx": "Martens et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Martens et al\\.", "year": 2011}, {"title": "On the Link Between Gaussian Homotopy Continuation and Convex Envelope", "author": ["Mobahi", "Fisher III", "H. 2015] Mobahi", "J.W. Fisher III"], "venue": null, "citeRegEx": "Mobahi et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mobahi et al\\.", "year": 2015}, {"title": "Adding gradient noise improves learning for very deep networks. CoRR, abs/1511.06807", "author": ["Neelakantan et al", "A. 2015] Neelakantan", "L. Vilnis", "Q.V. Le", "I. Sutskever", "L. Kaiser", "K. Kurach", "J. Martens"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2015\\E", "shortCiteRegEx": "al. et al\\.", "year": 2015}, {"title": "Annealed gradient descent for deep learning", "author": ["Pan", "Jiang", "H. 2015] Pan", "H. Jiang"], "venue": "In Proc. of 31th Conference on Uncertainty in Artificial Intelligence (UAI", "citeRegEx": "Pan et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Pan et al\\.", "year": 2015}, {"title": "On the saddle point problem for non-convex optimization. CoRR, abs/1405.4604", "author": ["Pascanu et al", "R. 2014] Pascanu", "Y.N. Dauphin", "S. Ganguli", "Y. Bengio"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "On the quality of the initial basin in overspecified neural networks. CoRR, abs/1511.04210", "author": ["Safran", "Shamir", "I. 2015] Safran", "O. Shamir"], "venue": null, "citeRegEx": "Safran et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Safran et al\\.", "year": 2015}, {"title": "On the importance of initialization and momentum in deep learning", "author": ["Sutskever et al", "I. 2013] Sutskever", "J. Martens", "G. Dahl", "G. Hinton"], "venue": "In Proceedings of the 30th International Conference on Machine Learning (ICML-13)", "citeRegEx": "al. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "al. et al\\.", "year": 2013}, {"title": "Sequence to sequence learning with neural networks", "author": ["Sutskever et al", "I. 2014] Sutskever", "O. Vinyals", "Q.V. Le"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "`1regularized neural networks are improperly learnable in polynomial time", "author": ["Zhang et al", "Y. 2015] Zhang", "J.D. Lee", "M.I. Jordan"], "venue": "CoRR, abs/1510.03528", "citeRegEx": "al. et al\\.,? \\Q2015\\E", "shortCiteRegEx": "al. et al\\.", "year": 2015}], "referenceMentions": [], "year": 2017, "abstractText": "This work presents a new algorithm for training recurrent neural networks (although ideas are applicable to feedforward networks as well). The algorithm is derived from a theory in nonconvex optimization related to the diffusion equation. The contributions made in this work are two fold. First, we show how some seemingly disconnected mechanisms used in deep learning such as smart initialization, annealed learning rate, layerwise pretraining, and noise injection (as done in dropout and SGD) arise naturally and automatically from this framework, without manually crafting them into the algorithms. Second, we present some preliminary results on comparing the proposed method against SGD. It turns out that the new algorithm can achieve similar level of generalization accuracy of SGD in much fewer number of epochs.", "creator": "LaTeX with hyperref package"}}}