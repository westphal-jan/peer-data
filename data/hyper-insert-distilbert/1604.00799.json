{"id": "1604.00799", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Apr-2016", "title": "Extending DLR with Labelled Tuples, Projections, Functional Dependencies and Objectification (full version)", "abstract": "yesterday we immediately introduce secondly an excellent extension of the n - way ary description logic dlr to deal with attribute - object labelled mapping tuples ( generalising upon the positional notation ), complete with defined arbitrary projections of relations ( whose inclusion attribute dependencies ), specifically generic functional dependencies and with global and arbitrary local maps objectification ( otherwise reifying ordinary relations within or limiting their context projections ). we should show how a simple syntactic condition arises on marking the appearance of excluded projections and functional dependencies in expressing a valid knowledge usable base constraint makes the language decidable without essentially increasing the computational complexity of the older basic dlr language.", "histories": [["v1", "Mon, 4 Apr 2016 10:11:52 GMT  (22kb)", "http://arxiv.org/abs/1604.00799v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["alessandro artale", "enrico franconi"], "accepted": false, "id": "1604.00799"}, "pdf": {"name": "1604.00799.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Enrico Franconi"], "emails": ["artale@inf.unibz.it", "franconi@inf.unibz.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 4.\n00 79\n9v 1\n[ cs\n.A I]\n4 A"}, {"heading": "1 Introduction", "text": "We introduce in this paper the language DLR` which extends the n-ary description logicsDLR [Calvanese et al., 1998; Baader et al., 2003] andDLRifd [Calvanese et al., 2001] as follows:\n\u2013 the semantics is based on attribute-labelled tuples: an element of a tuple is identified by an attribute and not by its position in the tuple, e.g., the relation Person has attributes firstname, lastname, age, height with instance: x firstname: Enrico, lastname: Franconi, age: 53, height: 1.90y;\n\u2013 renaming of attributes is possible, e.g., to recover the positional semantics: firstname,lastname,age,height\u00ed 1,2,3,4;\n\u2013 it can express projections of relations, and therefore inclusion dependencies, e.g., Drfirstname,lastnamesStudent \u010e Drfirstname,lastnamesPerson;\n\u2013 it can express multiple-attribute cardinalities, and therefore functional dependencies and multiple-attribute keys, e.g., the functional dependency fromfirstname, lastname to age in Person can be written as: Drfirstname,lastnamesPerson \u010e D\u010f1rfirstname,lastnamespDrfirstname,lastname,agesPersonq; \u2013 it can express global and local objectification (also known as reification): a tuple\nmay be identified by a unique global identifier, or by an identifier which is unique only within the interpretation of a relation, e.g., to identify the name of a person we can write Name \u010e \u00c4 Drfirstname,lastnamesPerson.\nWe show how a simple syntactic condition on the appearance of projections in the knowledge base makes the language decidable without increasing the computational complexity of the basic DLR language. We call DLR\u02d8 this fragment of DLR`."}, {"heading": "DLR", "text": "\u02d8 is able to correctly express the UML fragment as introduced in [Berardi et al., 2005; Artale et al., 2007] and the ORM fragment as introduced in [Franconi and Mosca, 2013].\n2 Syntax of the Description Logic DLR`\nWe first define the syntax of the language DLR`. A signature in DLR` is a triple L \u201c pC,R,U , \u03c4q consisting of a finite set C of concept names (denoted by CN ), a finite set R of relation names (denoted by RN ) disjoint from C, and a finite set U of attributes (denoted by U ), and a relation signature function \u03c4 associating a set of attributes to each relation name, \u03c4pRNq \u201c tU1, . . . , Unu \u010e U with n \u011b 2.\nThe syntax of concepts C, relations R, formulas \u03d5, and attribute renaming axioms \u03d1 is defined in Figure 1, where q is a positive integer and 2 \u010f k \u0103 ARITYpRq. We extend the signature function \u03c4 to arbitrary relations as specified in Figure 2. We define the ARITY of a relation R as the number of the attributes in its signature, namely |\u03c4pRq|.\nA DLR` TBox T is a finite set of formulas, i.e., concept inclusion axioms of the form C1 \u010e C2 and relation inclusion axioms of the form R1 \u010e R2. A renaming schema induces an equivalence relation p\u00ed,Uq over the attributes U , providing a partition of U into equivalence classes each one representing the alternative ways to name attributes. We write rU s\u211c to denote the equivalence class of the attribute U w.r.t. the equivalence relation p\u00ed,Uq. We allow only well founded renaming schemas, namely schemas such that each equivalence class rU s\u211c in the induced equivalence relation never contains two attributes from the same relation signature. In the\nfollowing we use the shortcut U1 . . . Un \u00ed U 11 . . . U 1 n to group many renaming axioms, with the obvious meaning that Ui \u00ed U 1i , for all i \u201c 1, . . . , n. A DLR` knowledge base KB \u201c pT ,\u211cq is composed by a TBox T and a renaming schema \u211c. The renaming schema reconciles the attribute and the positional perspectives on relations (see also the similar perspectives in relational databases [Abiteboul et al., 1995]). They are crucial when expressing both inclusion axioms and operators ([, \\, z) between relations, which make sense only over union compatible relations. Two relations R1, R2 are union compatible if their signatures are equal up to the attribute renaming induced by the renaming schema \u211c, namely, \u03c4pR1q \u201c tU1, . . . , Unu and \u03c4pR2q \u201c tV1, . . . , Vnu have the same arity n and rUis\u211c \u201c rVis\u211c for each 1 \u010f i \u010f n. Notice that, thanks to the renaming schema, relations can use just local attribute names that can then be renamed when composing relations. Also note that it is obviously possible for the same attribute to appear in the signature of different relations.\nTo show the expressive power of the language, let us consider the following example with tree relation names R1, R2 and R3 with the following signature:\n\u03c4pR1q \u201c tU1, U2, U3, U4, U5u\n\u03c4pR2q \u201c tV1, V2, V3, V4, V5u\n\u03c4pR3q \u201c tW1,W2,W3,W4u\nTo state that tU1, U2u is the multi-attribute key of R1 we add the axiom:\nDrU1, U2sR1 \u010e D \u010f1rU1, U2sR1\nwhere DrU1, . . . , UksR stands for D\u011b1rU1, . . . , UksR. To express that there is a functional dependency from the attributes tV3, V4u to the attribute tV5u of R2 we add the axiom:\nDrV3, V4sR2 \u010e D \u010f1rV3, V4spDrV3, V4, V5sR2q (1)\nThe following axioms express that R2 is a sub-relation of R1 and that a projection of R3 is a sub-relation of a projection of R1, together with the corresponding axioms for the renaming schema to explicitly specify the correspondences between the attributes of the two inclusion dependencies:\nR2 \u010e R1\nDrW1,W2,W3sR3 \u010e DrU3, U4, U5sR1\nV1V2V3V4V5 \u00ed U1U2U3U4U5\nW1W2W3 \u00ed U3U4U5"}, {"heading": "3 Semantics", "text": "The semantics makes use of the notion of labelled tuples over a domain set \u2206: a Ulabelled tuple over \u2206 is a function t : U \u00d1 \u2206. For U P U , we write trU s to refer\nto the domain element d P \u2206 labelled by U , if the function t is defined for U \u2013 that is, if the attribute U is a label of the tuple t. Given d1, . . . , dn P \u2206, the expression xU1 : d1, . . . , Un : dny stands for the U-labelled tuple t over \u2206 (tuple, for short) such that trUis \u201c di, for 1 \u010f 1 \u010f n. We write trU1, . . . , Uks to denote the projection of the tuple t over the attributes U1, . . . , Uk, namely the function t restricted to be undefined for the labels not in U1, . . . , Uk. The set of all U-labelled tuples over \u2206 is denoted by T\u2206pUq.\nA DLR` interpretation, I \u201c p\u2206, \u00a8I , \u03c1, \u0131, \u2113RN1, \u2113RN2 , . . .q, consists of a nonempty domain \u2206, an interpretation function \u00a8I , a renaming function \u03c1, a global objectification function \u0131, and a family of local objectification functions \u2113RNi , one for each named relation RNi P R.\nThe renaming function \u03c1 for attributes is a total function \u03c1 : U \u00d1 U representing a canonical renaming for all attributes. We consider, as a shortcut, the notation \u03c1ptU1, . . . , Ukuq \u201c t\u03c1pU1q, . . . , \u03c1pUkqu. The global objectification function is an injective function, \u0131 : T\u2206pUq \u00d1 \u2206, associating a unique global identifier to each possible tuple. The local objectification functions, \u2113RNi : T\u2206pUq \u00d1 \u2206, are distinct for each relation name in the signature, and as the global objectification function they are injective: they associate an identifier \u2013 which is unique only within the interpretation of a relation name \u2013 to each possible tuple. The interpretation function \u00a8I assigns a set of domain elements to each concept name, CNI \u010e \u2206, and a set of U-labelled tuples over \u2206 to each relation name conforming with its signature and the renaming function:\nRNI \u010e T\u2206pt\u03c1pUq | U P \u03c4pRNquq.\nThe interpretation function \u00a8I is unambiguously extended over concept and relation expressions as specified in the inductive definition of Fig. 3.\nAn interpretation I satisfies a concept inclusion axiom C1 \u010e C2 if CI1 \u010e C I 2 , it satisfies a relation inclusion axiom R1 \u010e R2 if RI1 \u010e R I 2\n, and it satisfies a renaming schema \u211c if the renaming function \u03c1 renames the attributes in a consistent way with respect to \u211c, namely if\n@U . \u03c1pUq P rU s\u211c ^ @V P rU s\u211c. \u03c1pUq \u201c \u03c1pV q.\nAn interpretation is a model for a knowledge base pT ,\u211cq if it satisfies all the formulas in the TBox T and it satisfies the renaming schema \u211c. We define KB satisfiability as the problem of deciding the existence of a model of a given knowledge base, concept satisfiability (resp. relation satisfiability) as the problem of deciding whether there is a model of the knowledge base that assigns a non-empty extension to a given concept (resp. relation), and entailment as the problem to check whether a given knowledge base logically implies a formula, that is, whenever all the models of the knowledge base are also models of the formula. For example, from the knowledge base KB introduced in the previous Section the following logical implication holds:\nKB |\u00f9 DrV1, V2sR2 \u010e D \u010f1rV1, V2sR2\ni.e., the attributes V1, V2 are a key for the relation R2.\nProposition 1. The problems of KB satisfiability, concept and relation satisfiability, and entailment are mutually reducible in DLR`.\nProof. We first show that we can reduce all the problems to concept satisfiability, where a concept C is satisfiable iff KB * C \u010e K.\n\u2013 KB is satisfiable iff KB * J \u010e K; \u2013 KB |\u00f9 C1 \u010e C2 iff KB |\u00f9 C1 [ C2 \u010e K; \u2013 KB |\u00f9 R1 \u010e R2 iff KB |\u00f9 DrU spR1 [ R2q \u010e K, for some U P \u03c4pR1q; \u2013 KB * R \u010e K iff KB * DrU sR \u010e K, for some U P \u03c4pRq.\nViceversa, we can show that concept satisfiability can be reduced to any other problem. First, note that concept satisfiability is already expressed as a logical implication problem. For the other cases, given a fresh new binary relation P , we have that\n\u2013 KB * C \u010e K iff KB Y tJ \u010e DrU1spP [ \u03c3U2:CP qu is satisfiable; \u2013 KB * C \u010e K iff KB * \u03c3U2:CP \u010e K. [\\\nDLR ` can express complex inclusion and functional dependencies, for which it is well known that reasoning is undecidable [Mitchell, 1983; Chandra and Vardi, 1985]."}, {"heading": "DLR", "text": "` also includes the DLR extension DLRifd together with unary functional dependencies [Calvanese et al., 2001], which also has been proved to be undecidable.\n4 The DLR\u02d8 fragment of DLR`\nGiven a DLR` knowledge base pT ,\u211cq, we define the projection signature as the set T including the signatures \u03c4pRNq of the relations RN P R, the singletons associated with each attribute name U P U , and the relation signatures as they appear explicitly in projection constructs in the relation inclusion axioms of the knowledge base, together with their implicit occurrences due to the renaming schema:\n1. \u03c4pRNq P T if RN P R; 2. tUu P T if U P U ; 3. tU1, . . . , Uku P T if D\u0133qrV1, . . . , VksR P T and tUi, Viu \u010e rUis\u211c for 1\u010f i\u010fk.\nWe call projection signature graph the directed acyclic graph p\u0104,T q with the attribute singletons tUu being the sinks. The DLR\u02d8 fragment of DLR` allows only for knowledge bases with a projection signature graph being a multitree, namely the set of nodes reachable from any node of the projection signature graph should form a tree. Given a relation name RN , the subgraph of the projection signature graph dominated by RN is a tree where the leaves are all the attributes in \u03c4pRNq and the root is \u03c4pRNq. We call TtU1,...,Uku the tree formed by the nodes in the projection signature graph dominated by the set of attributes tU1, . . . , Uku. Given two relation signatures (i.e., two sets of attributes) \u03c41, \u03c42 \u010e U , by PATHT p\u03c41, \u03c42q we denote the path in p\u0104,T q between \u03c41 and \u03c42, if it exists. Note that PATHT p\u03c41, \u03c42q \u201c H both when a path does not exist and when \u03c41 \u010e \u03c42, and PATHT is functional in DLR\n\u02d8 due to the multitree restriction on projection signatures. The notation CHILDT p\u03c41, \u03c42q means that \u03c42 is a child of \u03c41 in p\u0104,T q.\nIn addition to the above multitree condition, the DLR\u02d8 fragment of DLR` allows for knowledge bases with projection constructs D\u0133qrU1, . . . , UksR (resp. D\u0133qrU sR) with a cardinality q \u0105 1 only if the length of the path PATHT ptU1, . . . , Uku, \u03c4pRqq (resp. PATHT ptUu, \u03c4pRqq) is 1. This allows to map cardinalities in DLR\n\u02d8 into cardinalities in ALCQI.\nFigure 4 shows that the projection signature graph of the knowledge base introduced in Section 2 is indeed a multitree. Note that in the figure we have collapsed equivalent attributes in a unique equivalence class, according to the renaming schema.\nDLR \u02d8 restricts DLR` only in the way multiple projections of relations appear in the knowledge base. It is easy to see that DLR is included in DLR\u02d8, since the projection signature graph of any DLR knowledge base has maximum depth equal to 1. DLRifd [Calvanese et al., 2001] together with (unary) functional dependencies is also included in DLR\u02d8, with the proviso that projections of relations in the knowledge base form a multitree projection signature graph. Since (unary) functional dependencies are expressed via the inclusions of projections of relations (see, e.g., the functional dependency (1) in the previous example), by constraining the projection signature graph to be a multitree, the possibility to build combinations of functional dependencies as the ones in [Calvanese et al., 2001] leading to undecidability is ruled out. Also note that DLR\u02d8 is able to correctly express the UML fragment as introduced in [Berardi et al., 2005; Artale et al., 2007] and the ORM fragment as introduced in [Franconi and Mosca, 2013].\n5 Mapping DLR\u02d8 to ALCQI\nWe show that reasoning in DLR\u02d8 is EXPTIME-complete by providing a mapping from DLR\u02d8 knowledge bases to ALCQI knowledge bases; the reverse mapping from ALCQI knowledge bases to DLR knowledge bases is well known. The proof is based on the fact that reasoning with ALCQI knowledge bases is EXPTIME-complete [Baader et al., 2003]. We adapt and extend the mapping presented for DLR in [Calvanese et al., 1998].\nIn the following we use the shortcut pS1 \u02dd . . . \u02ddSnq\u00b4 for S\u00b4n \u02dd . . . \u02ddS \u00b4 1\n, the shortcut D\u01331S1 \u02dd . . . \u02dd Sn.C for D\u01331S1. . . . . D\u01331Sn.C and the shortcut @S1 \u02dd . . . \u02dd Sn.C for @S1. . . . .@Sn.C. Note that these shortcuts for the role chain constructor \u201c\u02dd\u201d are not correct in general, but they are correct in the context of the specific ALCQI knowledge bases used in this paper.\nLet KB \u201c pT ,\u211cq be a DLR\u02d8 knowledge base. We first rewrite the knowledge base as follows: for each equivalence class rU s\u211c a single canonical representative of the class is chosen, and the KB is consistently rewritten by substituting each attribute with its canonical representative. After this rewriting, the renaming schema does not play any role in the mapping.\nThe mapping function \u00a8: maps each concept name CN in the DLR\u02d8 knowledge base to an ALCQI concept name CN , each relation name RN in the DLR\u02d8 knowledge base to an ALCQI concept name ARN (its global reification), and each attribute name U in the DLR\u02d8 knowledge base to an ALCQI role name, as detailed below. For each relation name RN the mapping introduces a concept name AlRN and a role name QRN (to capture the local reification), and a concept name A \u03c4i RN for each projected signature \u03c4i in the projection signature graph dominated by \u03c4pRNq, \u03c4i P T\u03c4pRNq (to capture global reifications of the projections of RN ). Note that A\u03c4pRNqRN coincides with ARN . Furthermore, the mapping introduces a role name Q\u03c4i for each projected signature \u03c4i in the projection signature, \u03c4i P T , such that there exists \u03c4j P T with CHILDT p\u03c4j , \u03c4iq, i.e., we exclude the case where \u03c4i is one of the roots of the multitree\ninduced by the projection signature. The mapping \u00a8: applies also to a path. Let \u03c4, \u03c4 1 P T be two generic sets of attributes such that the function PATHT p\u03c4, \u03c4 1q \u201c \u03c4, \u03c41, . . . , \u03c4n, \u03c4 1, then, a path is mapped as follows:\nPATHT p\u03c4, \u03c4 1q: \u201c Q\u03c41 \u02dd . . . \u02ddQ\u03c4n \u02ddQ\u03c4 1 .\nIntuitively, the mapping reifies each node in the projection signature graph: the target ALCQI signature of the example of the previous section is partially presented in Fig. 5, together with the projection signature graph. Each node is labelled with the corresponding (global) reification concept (A\u03c4jRi ), for each relation name Ri and each projected signature \u03c4j in the projection signature graph dominated by \u03c4pRiq, while the edges are labelled by the roles (Q\u03c4i) needed for the reification.\nThe mapping \u00a8: is extended to concept and relation expressions as in Figure 6, with the proviso that whenever PATHT p\u03c41, \u03c42q returns an empty path then the translation for\nthe corresponding expression becomes the bottom concept. Note that in DLR\u02d8 the cardinalities on a path are restricted to the case q \u201c 1 whenever a path is of length greater than 1, so we still remain within the ALCQI description logic when the mapping applies to cardinalities. So, if we need to express a cardinality constraint D\u0133qrUisR,] with q \u0105 1, then Ui should not be mentioned in any other projection of the relation R in such a way that |PATHT p\u03c4pRq, tUiuq| \u201c 1.\nIn order to explain the need for the path function in the mapping, notice that a relation is reified according to the decomposition dictated by projection signature graph it dominates. Thus, to access an attribute Uj of a relation Ri it is necessary to follow the path through the projections that use that attribute. This path is a role chain from the signature of the relation (the root) to the attribute as returned by the PATHT p\u03c4pRiq, Uiq function. For example, considering Fig. 5, in order to access the attribute U4 of the relation R3 in the expression p\u03c3U4:CR3q, the path PATHT p\u03c4pR3q, tU4uq\n: is equal to the role chain QtU3,U4,U5u\u02ddQtU3,U4u\u02ddQtU4u, so that p\u03c3U4:CR3q\n: \u201c AR3[@QtU3,U4,U5u\u02dd QtU3,U4u \u02ddQtU4u.C. Similar considerations can be done when mapping cardinalities over relation projections.\nThe mapping \u03b3pKBq of a DLR\u02d8 knowledge base KB with a signature pC,R,U , \u03c4q is defined as the following ALCQI TBox:\n\u03b3pKBq \u201c \u03b3dsj Y \u010f\nRNPR\n\u03b3relpRNq Y \u010f\nRNPR\n\u03b3lobjpRNq Y\n\u010f\nC1\u010eC2PKB\nC : 1 \u010e C : 2 Y\n\u010f\nR1\u010eR2PKB\nR : 1 \u010e R : 2\nwhere\n\u03b3dsj \u201c A\u03c4iRN1 \u010e A \u03c4j RN2 | RN1, RN2 P R, \u03c4i, \u03c4j P T , |\u03c4i| \u011b 2, |\u03c4j| \u011b 2, \u03c4i \u2030 \u03c4j (\n\u03b3relpRNq \u201c \u010f\n\u03c4iPT\u03c4pRNq\n\u010f\nCHILDT p\u03c4i,\u03c4jq\nA\u03c4iRN \u010e DQ\u03c4j .A \u03c4j RN , D \u011b2Q\u03c4j .J \u010e K (\n\u03b3lobjpRNq \u201c tARN \u010e DQRN .AlRN , D \u011b2QRN .J \u010e K,\nAlRN \u010e DQ \u00b4 RN .ARN , D \u011b2Q\u00b4RN .J \u010e Ku.\nIntuitively, \u03b3dsj ensures that relations with different signatures are disjoint, thus, e.g., enforcing the union compatibility. The axioms in \u03b3rel introduce classical reification axioms for each relation and its relevant projections. The axioms in \u03b3lobj make sure that each local objectification differs form the global one.\nClearly, the size of \u03b3pKBq is polynomial in the size of KB (under the same coding of the numerical parameters), and thus we are able to state the main result of this paper.\nTheorem 2. A DLR\u02d8 knowledge base KB is satisfiable iff the ALCQI knowledge base \u03b3pKBq is satisfiable.\nProof. We assume that the KB is consistently rewritten by substituting each attribute with its canonical representative, thus, we do not have to deal with the renaming of attributes. Furthermore, we extend the function \u0131 to singleton tuples with the meaning\nthat \u0131pxUi : diyq \u201c di. (\u00f1) Let I \u201c p\u2206I , \u00a8I , \u03c1, \u0131, \u2113RN1, . . .q be a model for a DLR\n\u02d8 knowledge base KB. To construct a model J \u201c p\u2206J , \u00a8J q for the ALCQI knowledge base \u03b3pKBq we set \u2206J \u201c \u2206I . Furthermore, we set: pCN :qJ \u201c pCNqI , for every atomic conceptCN P C, while for every RN P R and \u03c4i P T\u03c4pRNq we set\npA\u03c4iRN q J \u201c t\u0131pxU1 : d1, . . . , Uk : dkyq | tU1, . . . , Uku \u201c \u03c4i and\nDt P RNI . trU1s \u201c d1, . . . , trUks \u201c dku. (2)\nFor each role name Q\u03c4i , \u03c4i P T , we set\npQ\u03c4iq J \u201c tpd1, d2q P \u2206 J \u02c6\u2206J | Dt P RNI s.t. d1 \u201c \u0131ptr\u03c4jsq, d2 \u201c \u0131ptr\u03c4isq\nand CHILDT p\u03c4j , \u03c4iq, for some RN P Ru. (3)\nFor every RN P R we set\nQJRN \u201c tpd1, d2q P \u2206 J \u02c6 \u2206J | Dt P RNI s.t. d1 \u201c \u0131ptq and d2 \u201c \u2113RN ptqu, (4)\nand\npAlRN q J \u201c t\u2113RNptq | t P RN Iu. (5)\nWe now show that J is indeed a model of \u03b3pKBq.\n1. J |\u00f9 \u03b3dsj. This is a direct consequence of the fact that \u0131 is an injective function and that tuples with different aryties are different tuples. 2. J |\u00f9 \u03b3relpRNq, for everyRN P R. We show that, for each \u03c4i, \u03c4j s.t. CHILDT p\u03c4i, \u03c4jq and \u03c4i P T\u03c4pRNq, J |\u00f9 A \u03c4i RN \u010e DQ\u03c4j .A \u03c4j RN and J |\u00f9 D\n\u011b2Q\u03c4j .J \u010e K: \u2013 J |\u00f9 A\u03c4iRN \u010e DQ\u03c4j .A \u03c4j RN . Let d P pA \u03c4i RN q\nJ , by (2), Dt P RNI s.t. d \u201c \u0131ptr\u03c4isq. Since CHILDT p\u03c4i, \u03c4jq, then Dd1 \u201c \u0131ptr\u03c4jsq and, by (3), pd, d1q P QJ\u03c4j , while by (2), d1 P pA\u03c4jRN q J . Thus, d P pDQ\u03c4j .A \u03c4j RN q\nJ . \u2013 J |\u00f9 D\u011b2Q\u03c4j .J \u010e K. The fact that each Q\u03c4j is interpreted as a funcional role\nis a direct consequence of the construction (3) and the fact that \u0131 is an injective function.\n3. J |\u00f9 \u03b3lobjpRNq, for every RN P R. Similar as above, considering the fact that each \u2113RN is an injective function and equations (4)-(5). 4. J |\u00f9 C: 1 \u010e C : 2 and J |\u00f9 R: 1 \u010e R : 2 . Since I |\u00f9 C1 \u010e C2 and I |\u00f9 R1 \u010e R2, It is\nenough to show the following: \u2013 d P CI iff d P pC:qJ , for all DLR\u02d8 concepts; \u2013 t P RI iff \u0131ptq P pR:qJ , for all DLR\u02d8 relations. Before we proceed with the proof, it is easy to show by structural induction that the following property holds:\nIf \u0131ptq P R:J then D\u0131pt1q P RN :J s.t. t \u201c t1r\u03c4pRqs, for some RN P R. (6)\nWe now proceed with the proof by structural induction. The base cases, for atomic concepts and roles, are immediate form the definition of both CNJ and RNJ . The\ncases where complex concepts and relations are constructed using either boolean operators or global reification are easy to show. We thus show only the following cases. Let d P p \u00c4\nRNqI . Then, d \u201c \u2113RN ptq with t P RNI . By induction, \u0131ptq P AJRN and, by \u03b3lobjpRNq, there is a d1 P \u2206J s.t. p\u0131ptq, d1q P QJRN and d 1 P pAlRN q J . By (4), d1 \u201c \u2113RNptq and, since \u2113RN is injective, d1 \u201c d. Thus, d P p \u00c4\nRNq:J . Let d P pD\u011bqrUisRqI . Then, there are different t1, . . . , tq P RI s.t. tlrUis \u201c d, for all l \u201c 1, . . . , q. By induction, \u0131ptlq P R:J while, by (6), \u0131pt1lq P RN\n:J , for some atomic relation RN P R and a tuple t1l s.t. tl \u201c t 1 lr\u03c4pRqs. By \u03b3relpRNq and (3), p\u0131pt1lq, \u0131ptlqq P pPATHT p\u03c4pRN q, \u03c4pRqq :qJ and p\u0131ptlq, dq P pPATHT p\u03c4pRq, tUiuq:qJ . Since \u0131 is injective, \u0131ptlq \u2030 \u0131ptjq when l \u2030 j, thus, d P pD\u011bqrUisRq:J . Let t P p\u03c3Ui:CRq I . Then, t P RI and trUis P CI and, by induction, \u0131ptq P R:J and trUis P C:J . As before, by \u03b3relpRNq and by (3) and (6), p\u0131ptq, trUisq P pPATHT p\u03c4pRq, tUiuq\n:qJ . Since PATHT p\u03c4pRq, Uiq: is functional, then we have that \u0131ptq P p\u03c3Ui:CRq\n:J . Let t P pDrU1, . . . , UksRqI . Then, there is a tuple t1 P RI s.t. t1rU1, . . . , Uks \u201c t and, by induction, \u0131pt1q P R:J . As before, by \u03b3relpRNq and by (3) and (6), we can show that p\u0131pt1q, \u0131ptqq P PATHT p\u03c4pRq, tU1, . . . , Ukuq:J and thus \u0131ptq P pDrU1, . . . , UksRq\n:J . All the other cases can be proved in a similar way. We now show the vice versa. Let d P p \u00c4\nRNq:J . Then, d P pAlRN q J and d \u201c lRN ptq, for some t P RN I , i.e., d P p \u00c4\nRNqI . Let d P pD\u011bqrUisRq:J . Then, there are different d1, . . . , dq P \u2206J s.t. pdl, dq P pPATHT p\u03c4pRq, tUiuq\n:qJ and dl P R:J , for l \u201c 1, . . . , q. By induction, each dl \u201c \u0131ptlq and tl P RI . Since \u0131 is injective, then tl \u2030 tj for all l, j \u201c 1, . . . , q, l \u2030 j. We need to show that tlrUis \u201c d, for all l \u201c 1, . . . , q. By (3) and the fact that pdl, dq P pPATHT p\u03c4pRq, tUiuq\n:qJ , then d \u201c \u0131ptlrUisq \u201c tlrUis. Let \u0131ptq P p\u03c3Ui:CRq\n:J . Then, \u0131ptq P R:J and, by induction, t P RI . Let trUis \u201c d. We need to show that d P CI . By \u03b3relpRNq and by (3) and (6), p\u0131ptq, dq P pPATHT p\u03c4pRq, tUiuq\n:qJ , then d P C:J and, by induction, d P CI . Let \u0131ptq P pDrU1, . . . , UksRq:J . Then, there is d P \u2206J s.t.\npd, \u0131ptqq P pPATHT p\u03c4pRq, tU1, . . . , Ukuq :qJ\nand d P RJ . By induction, d \u201c \u0131pt1q and t1 P RI . By (3), \u0131ptq \u201c \u0131pt1rU1, . . . , Uksq, i.e., t \u201c t1rU1, . . . , Uks. Thus, t P pDrU1, . . . , UksRqI . (\u00f0) Let J \u201c p\u2206J , \u00a8J q be a model for the knowledge base \u03b3pKBq. Without loss of generality, we can assume that J is a tree model. We then construct a model I \u201c p\u2206I , \u00a8I , \u03c1, \u0131, \u2113RN1, . . .q for a DLR\n\u02d8 knowledge base KB. We set: \u2206I \u201c \u2206J , CNI \u201c pCN :qJ , for every atomic concept CN P C, while, for every RN P R, we set:\nRNI \u201c tt \u201c xU1 : d1, . . . , Un : dny P T\u2206I p\u03c4pRNqq | Dd P A J RN s.t.\npd, trUisq P pPATHT p\u03c4pRNq, tUiuq :qJ for i \u201c 1, . . . , nu. (7)\nSince J satisfies \u03b3relpRNq, then, for every d P A J RN there is a unique tuple xU1 : d1, . . . , Un : dny P RN I , we say that d generates xU1 : d1, . . . , Un : dny and, in\nsymbols, d \u00d1 xU1 : d1, . . . , Un : dny. Furthermore, since J is tree shaped, to each tuple corresponds a unique d that generates it. Thus, let d \u00d1 xU1 : d1, . . . , Un : dny, by setting \u0131pxU1 : d1, . . . , Un : dnyq \u201c d and\n\u0131pxU1 : d1, . . . , Un : dnyr\u03c4isq \u201c d\u03c4i , s.t.\npd, d\u03c4iq P pPATHT ptU1, . . . , Unu, \u03c4iq :qJ , (8)\nfor all \u03c4i P TtU1,...,Unu, then, the function \u0131 is as required. By setting\n\u2113RN pxU1 : d1, . . . , Un : dnyq \u201c d, s. t.\np\u0131pxU1 : d1, . . . , Un : dnyq, dq P Q J RN , (9)\nby \u03b3lobjpRNq, both QRN and its inverse are interpreted as a functional roles by J , thus the function \u2113RN is as required. It is easy to show by structural induction that the following property holds:\nIf t P RI then Dt1 P RNI s.t. t \u201c t1r\u03c4pRqs, for some RN P R. (10)\nWe now show that I is indeed a model of KB, i.e., I |\u00f9 C1 \u010e C2 and I |\u00f9 R1 \u010e R2. As before, since J |\u00f9 C : 1 \u010e C : 2 and J |\u00f9 R: 1 \u010e R : 2 , it is enough to show the following: \u2013 d P CI iff d P pC:qJ , for all DLR\u02d8 concepts; \u2013 t P RI iff \u0131ptq P pR:qJ , for all DLR\u02d8 relations. The proof is by structural induction. The base cases are trivially true. Similarly for the boolean operators and global reification. We thus show only the following cases. Let d P p \u00c4\nRNqI . Then, d \u201c \u2113RN ptq with t P RNI . By induction, \u0131ptq P AJRN and, by \u03b3lobjpRNq, there is a d1 P \u2206J s.t. p\u0131ptq, d1q P QJRN and d 1 P pAlRN q J . By (9), d \u201c d1 and thus, d P p \u00c4\nRNq:J . Let d P pD\u011bqrUisRqI . Then, there are different t1, . . . , tq P RI s.t. tlrUis \u201c d, for all l \u201c 1, . . . , q. For each tl, by (10), there is a t1l P RN\nI s.t. tl \u201c t1lr\u03c4pRqs, for some RN P R, while, by induction, \u0131ptlq P R:J and \u0131pt1lq P RN\n:J . Thus, t1lrUis \u201c tlrUis \u201c d and, by (7), p\u0131pt 1 lq, dq P pPATHT p\u03c4pRNq, tUiuq\n:qJ while, by (8), p\u0131pt1lq, \u0131ptlqq P pPATHT p\u03c4pRNq, \u03c4pRqqq\n:J . Since DLR\u02d8 allows only for knowledge bases with a projection signature graph being a multitree, then,\nPATHT p\u03c4pRNq, tUiuq : \u201c PATHT p\u03c4pRNq, \u03c4pRqq : \u02dd PATHT p\u03c4pRq, tUiuq :.\nThus, p\u0131ptlq, dq P pPATHT p\u03c4pRq, tUiuq:qJ and, since \u0131 is injective, then, \u0131ptlq \u2030 \u0131ptjq when l \u2030 j. Thus, d P pD\u011bqrUisRq:J . Let t P p\u03c3Ui:CRq\nI . Then, t P RI and trUis \u201c d P CI . By induction, \u0131ptq P R:J and d P C:J . As before, by (7), (8) and (10), we can show that p\u0131ptq, dq P pPATHT p\u03c4pRq, tUiuq\n:qJ and, since PATHT p\u03c4pRq, tUiuq: is functional, then \u0131ptq P p\u03c3Ui:CRq\n:J . Let t P pDrU1, . . . , UksRqI . Then, there is a tuple t1 P RI s.t. t1rU1, . . . , Uks \u201c t\nand, by induction, \u0131pt1q P R:J . As before, by (8) and (10), we can show that p\u0131pt1q, \u0131ptqq P PATHT p\u03c4pRq, tU1, . . . , Ukuq\n:J and thus \u0131ptq P pDrU1, . . . , UksRq:J . All the other cases can be proved in a similar way. We now show the vice versa.\nLet d P p \u00c4 RNq:J . Then, d P pAlRN q J and, by \u03b3lobjpRNq, there is a d1 P \u2206J s.t. pd1, dq P QJRN and d 1 P AJRN . By induction, d\n1 \u201c \u0131pt1q with t1 P RNI and thus, p\u0131pt1q, dq P QJRN and, by (9), \u2113RN pt 1q \u201c d, i.e., d P p \u00c4\nRNqI . Let d P pD\u011bqrUisRq:J . Thus, there are different d1, . . . , dq P \u2206J s.t. pdl, dq P pPATHT p\u03c4pRq, tUiuq\n:qJ and dl P R:J , for l \u201c 1, . . . , q. By induction, each dl \u201c \u0131ptlq and tl P RI . Since \u0131 is injective, then tl \u2030 tj for all l, j \u201c 1, . . . , q, l \u2030 j. We need to show that tlrUis \u201c d, for all l \u201c 1, . . . , q. By (10), there is a t1l P RN I s.t. tl \u201c t1lr\u03c4pRqs, for some RN P R and, by (8), p\u0131pt 1 lq, \u0131ptlqq P pPATHT p\u03c4pRNq, \u03c4pRqq :qJ . Since p\u0131ptlq, dq P pPATHT p\u03c4pRq, tUiuq:qJ and PATHT is functional in DLR\u02d8, then, p\u0131pt1lq, dq P pPATHT p\u03c4pRNq, tUiuq :qJ and, by (7), t1lrUis \u201c tlrUis \u201c d. Let \u0131ptq P p\u03c3Ui:CRq\n:J . Thus, \u0131ptq P R:J and, by induction, t P RI . Let trUis \u201c d. We need to show that d P CI . As before, by (10) and (8), we have that p\u0131ptq, dq P pPATHT p\u03c4pRq, tUiuq\n:qJ . Then d P C:J and, by induction, d P CI . Let \u0131ptq P pDrU1, . . . , UksRq:J . Then, there is d P \u2206J s.t.\npd, \u0131ptqq P pPATHT p\u03c4pRq, tU1, . . . , Ukuq :qJ\nand d P R:J . By induction, d \u201c \u0131pt1q and t1 P RI . As before, by (8) and (10), we can show that there is a tuple t2 P RN s.t. p\u0131pt2q, \u0131ptqq P pPATHT p\u03c4pRNq, tU1, . . . , Ukuq:qJ and thus, t \u201c t1rU1, . . . , Uks, i.e., t P pDrU1, . . . , UksRqI . [\\\nAs a direct consequence of the above theorem and the fact that DLR is a sublanguage of DLR\u02d8, we have that\nCorollary 3. Reasoning in DLR\u02d8 is an EXPTIME-complete problem."}, {"heading": "6 Acknowledgements", "text": "We thank Alessandro Mosca for working with us on all the preliminary work necessary to understand how to get these technical results."}], "references": [{"title": "Reasoning over extended ER models", "author": ["Artale et al", "2007. A. Artale", "D. Calvanese", "R. Kontchakov", "V. Ryzhikov", "M. Zakharyaschev"], "venue": "In Proc. of the 26th Int. Conf. on Conceptual Modeling (ER\u201907),", "citeRegEx": "al. et al\\.,? \\Q2007\\E", "shortCiteRegEx": "al. et al\\.", "year": 2007}, {"title": "The Description Logic Handbook: Theory, Implementation and Applications", "author": ["Baader et al", "2003. Franz Baader", "Diego Calvanese", "Deborah McGuinness", "Daniele Nardi", "Peter F. Patel-Schneider", "editors"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2003\\E", "shortCiteRegEx": "al. et al\\.", "year": 2003}, {"title": "Reasoning on UML class diagrams", "author": ["Berardi et al", "2005. D. Berardi", "D. Calvanese", "G. De Giacomo"], "venue": "Artificial Intelligence,", "citeRegEx": "al. et al\\.,? \\Q2005\\E", "shortCiteRegEx": "al. et al\\.", "year": 2005}, {"title": "On the decidability of query containment under constraints", "author": ["Calvanese et al", "1998. D. Calvanese", "G. De Giacomo", "M. Lenzerini"], "venue": "In Proc. of the 17th ACM Sym. on Principles of Database Systems", "citeRegEx": "al. et al\\.,? \\Q1998\\E", "shortCiteRegEx": "al. et al\\.", "year": 1998}, {"title": "Identification constraints and functional dependencies in description logics", "author": ["Calvanese et al", "2001. Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini"], "venue": "In Proceedings of the Seventeenth International Joint Conference on Artificial Intelligence,", "citeRegEx": "al. et al\\.,? \\Q2001\\E", "shortCiteRegEx": "al. et al\\.", "year": 2001}, {"title": "The implication problem for functional and inclusion dependencies is undecidable", "author": ["Chandra", "Vardi", "1985. Ashok K. Chandra", "Moshe Y. Vardi"], "venue": "SIAM Journal on Compututing,", "citeRegEx": "Chandra et al\\.,? \\Q1985\\E", "shortCiteRegEx": "Chandra et al\\.", "year": 1985}, {"title": "Towards a core ORM2 language (research note)", "author": ["Franconi", "Mosca", "2013. Enrico Franconi", "Alessandro Mosca"], "venue": "In OTM Workshops,", "citeRegEx": "Franconi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Franconi et al\\.", "year": 2013}, {"title": "The implication problem for functional and inclusion dependencies", "author": ["Mitchell", "1983. John C. Mitchell"], "venue": "Information and Control,", "citeRegEx": "Mitchell and Mitchell.,? \\Q1983\\E", "shortCiteRegEx": "Mitchell and Mitchell.", "year": 1983}], "referenceMentions": [], "year": 2016, "abstractText": "We introduce an extension of the n-ary description logic DLR to deal with attribute-labelled tuples (generalising the positional notation), with arbitrary projections of relations (inclusion dependencies), generic functional dependencies and with global and local objectification (reifying relations or their projections). We show how a simple syntactic condition on the appearance of projections and functional dependencies in a knowledge base makes the language decidable without increasing the computational complexity of the basic DLR language.", "creator": "LaTeX with hyperref package"}}}