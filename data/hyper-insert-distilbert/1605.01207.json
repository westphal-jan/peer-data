{"id": "1605.01207", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-May-2016", "title": "Ontology-Mediated Queries: Combined Complexity and Succinctness of Rewritings via Circuit Complexity", "abstract": "further we give solutions to exploring two pretty fundamental intermediate computational presentation problems emerging in computing ontology - based data access interfaces with including the w3c standard ontology language mesh owl 2 with ql : introduces the succinctness problem for hierarchical first - order rewritings model of ontology - mediated queries ( simple omqs ), and the complexity check problem posed for omq tree answering. we can classify omqs networks according to the shape of producing their root conjunctive persistence queries ( treewidth, indicating the full number of leaves ) and the existential persistence depth of compiling their constraint ontologies. essentially for examining each objective of selecting these classes, we determine which the combined inherent complexity knowledge of omq answering, and whether at all working omqs experts in describing the puzzle class have polynomial - size \u2014 first - class order, positive existential, predictable and hence nonrecursive datalog rewritings. we obtain the succinctness consistency results using connected hypergraph programs, constructing a new fast computational model for storing boolean functions, which additionally makes where it possible to systematically connect simultaneously the compute size of omq compute rewritings variables and circuit matrix complexity.", "histories": [["v1", "Wed, 4 May 2016 10:10:37 GMT  (152kb)", "http://arxiv.org/abs/1605.01207v1", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI cs.CC", "authors": ["meghyn bienvenu", "stanislav kikot", "roman kontchakov", "vladimir podolskii", "michael zakharyaschev"], "accepted": false, "id": "1605.01207"}, "pdf": {"name": "1605.01207.pdf", "metadata": {"source": "CRF", "title": "Ontology-Mediated Queries: Combined Complexity and Succinctness of Rewritings via Circuit Complexity", "authors": ["MEGHYN BIENVENU", "MICHAEL ZAKHARYASCHEV"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n60 5.\n01 20\n7v 1\n[ cs\n.D B\n] 4\nM ay\n2 01\nKeywords: Ontology-Based Data Access, Description Logic, Ontology-Mediated Query, Query Rewriting, Succinctness, Computational Complexity, Circuit Complexity."}, {"heading": "1 Introduction", "text": ""}, {"heading": "1.1 Ontology-based data access", "text": "Ontology-based data access (OBDA) via query rewriting was proposed by Poggi et al. [62] with the aim of facilitating query answering over complex, possibly incomplete and heterogeneous data sources. In an OBDA system (see Fig. 1), the user does not have to be aware of the structure of data sources, which can be relational databases, spreadsheets, RDF triplestores, etc. Instead, the system provides the user with an ontology that serves as a high-level conceptual view of the data, gives a convenient vocabulary for user queries, and enriches incomplete data with background knowledge. A snippet, T , of such an ontology is shown below in the syntax of first-order (FO) logic:\n\u2200x ( ProjectManager(x) \u2192 \u2203y (isAssistedBy(x, y) \u2227 PA(y)) ) , \u2200x ( \u2203ymanagesProject(x, y) \u2192 ProjectManager(x) ) , \u2200x ( ProjectManager(x) \u2192 Staff(x) ) , \u2200x ( PA(x) \u2192 Secretary(x) ) .\nUser queries are formulated in the signature of the ontology. For example, the conjunctive query (CQ)\nq(x) = \u2203y (Staff(x) \u2227 isAssistedBy(x, y) \u2227 Secretary(y)))\nis supposed to find the staff assisted by secretaries. The ontology signature and data schemas are related by mappings designed by the ontology engineer and invisible to the user. The mappings allow the system to view the data sources as a single RDF graph (a finite set of unary and binary atoms), A, in the signature of the ontology. For example, the global-as-view (GAV) mappings\n\u2200x, y, z ( PROJECT(x, y, z) \u2192 managesProject(x, z) ) , \u2200x, y ( STAFF(x, y) \u2227 (y = 2) \u2192 ProjectManager(x) )\npopulate the ontology predicates managesProject and ProjectManager with values from the database relations PROJECT and STAFF. In the query rewriting approach of Poggi et al. [62], the OBDA system employs the ontology and mappings in order to transform the user query into a query over the data sources, and then delegates the actual query evaluation to the underlying database engines and triplestores.\nFor example, the first-order query\nq\u2032(x) = \u2203y [ Staff(x) \u2227 isAssistedBy(x, y) \u2227 (Secretary(y) \u2228 PA(y)) ] \u2228\nProjectManager(x) \u2228 \u2203zmanagesProject(x, z)\nis an FO-rewriting of the ontology-mediated query (OMQ) Q = (T , q) over any RDF graph A in the sense that a is an answer to q\u2032(x) over A iff q(a) is a logical consequence of T and A. As the system is not supposed to materialise A, it uses the mappings to unfold the rewriting q\u2032 into an SQL (or SPARQL) query over the data sources. Ontology languages suitable for OBDA via query rewriting have been identified by the Description Logic, Semantic Web, and Database/Datalog communities. The DL-Lite family of description logics, first proposed by Calvanese et al. [20] and later extended by Artale et al. [4], was specifically designed to ensure the existence of FO-rewritings for all conjunctive queries (CQs). Based on this family, the W3C defined a profile OWL2QL1 of the Web Ontology Language OWL2 \u2018so that data [. . . ] stored in a standard relational database system can be queried through an ontology via a simple rewriting mechanism.\u2019 Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24]. We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54]. SPARQL 1.1, the standard query language for RDF graphs, contains negation, aggregation and other features beyond first-order logic. The entailment regimes of SPARQL 1.12 also bring inferencing capabilities in the setting, which are, however, necessarily limited for efficient implementations.\nBy reducing OMQ answering to standard database query evaluation, which is generally regarded to be very efficient, OBDA via query rewriting has quickly become a hot topic in both theory and practice. A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]). A\n1 http://www.w3.org/TR/owl2-overview/#Profiles 2 http://www.w3.org/TR/2013/REC-sparql11-entailment-20130321\nfew mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53]. By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.3"}, {"heading": "1.2 Succinctness and complexity", "text": "In this paper, our concern is two fundamental theoretical problems whose solutions will elucidate the computational costs required for answering OMQs with OWL2QL ontologies. The succinctness problem for FO-rewritings is to understand how difficult it is to construct FOrewritings for OMQs in a given class and, in particular, to determine whether OMQs in the class have polynomial-size FO rewritings or not. In other words, the succinctness problem clarifies the computational costs of the reduction of OMQ answering to database query evaluation. On the other hand, it is also important to measure the resources required to answer OMQs by a best possible algorithm, not necessarily a reduction to database query evaluation. Thus, we are interested in the combined complexity of the OMQ answering problem: given an OMQ Q = (T , q(x)) from a certain class, a data instance A and a tuple a of constants from A, decide whether T ,A |= q(a). The combined complexity of CQ evaluation has been thoroughly investigated in database theory; cf. [36, 56] and references therein. To slightly simplify the setting for our problems, we assume that data is given in the form of an RDF graph and leave mappings out of the picture (in fact, GAV mappings only polynomially increase the size of FO-rewritings over RDF graphs).\nWe suggest a \u2018two-dimensional\u2019 classification of OMQs. One dimension takes account of the shape of the CQs in OMQs by quantifying their treewidth (as in classical database theory) and the number of leaves in tree-shaped CQs. Note that, in SPARQL 1.1, the sub-queries that require rewriting under the OWL2QL entailment regime are always tree-shaped (they are, in essence, complex class expressions). The second dimension is the existential depth of ontologies, that is, the length of the longest chain of labelled nulls in the chase on any data. Thus, the NPD FactPages ontology,4 which was designed to facilitate querying the datasets of the Norwegian Petroleum Directorate,5 is of depth 5. A typical example of an ontology axiom causing infinite depth is \u2200x ( Person(x) \u2192 \u2203y (ancestor(y, x) \u2227 Person(y)) ) .\n3 See, e.g., http://optique-project.eu. 4 http://sws.ifi.uio.no/project/npd-v2/ 5 http://factpages.npd.no/factpages/"}, {"heading": "1.3 Results", "text": "The results of our investigation are summarised in the succinctness and complexity landscapes of Fig. 2. In what follows, we discuss these results in more detail.\nThe succinctness problem we consider can be formalised as follows: given a sequence Qn (n < \u03c9) of OMQs whose size is polynomial in n, determine whether the size of minimal rewritings of Qn can be bounded by a polynomial function in n. We distinguish between three types of rewritings: arbitrary FO-rewritings, positive existential (PE-) rewritings (in which only \u2227, \u2228 and \u2203 are allowed), and non-recursive datalog (NDL-) rewritings.6 This succinctness problem was first considered by Kikot et al. [47] and Gottlob and Schwentick [35]. The former constructed a sequence Qn of OMQs (with tree-shaped CQs) whose PE- and NDL-rewritings are of exponential size, while FO-rewritings are superpolynomial unless NP \u2286 P/poly. Gottlob and Schwentick [35] and Gottlob et al. [31] showed that PE- (and so all other) \u2018rewritings\u2019 can be made polynomial under the condition that all relevant data instances contain two special constants. The \u2018succinctification\u2019 trick involves polynomially many extra existential quantifiers over these constants to guess a derivation of the given CQ in the chase, which makes such rewritings impractical (cf. NFAs vs DFAs, and [6]). In this paper, we stay within the classical OBDA setting that does not impose any extra conditions on the data and does not allow any special constants in rewritings.\nFigure 2 (a) gives a summary of the succinctness results obtained in this paper. It turns out that polynomial-size PE-rewritings are guaranteed to exist\u2014in fact, can be constructed in polynomial time\u2014only for the class of OMQs with ontologies of depth 1 and CQs of bounded treewidth; moreover, tree-shaped OMQs have polynomial-size \u03a04-PE-rewritings (with matrices of the form \u2227\u2228\u2227\u2228). Polynomial-size NDL-rewritings can be efficiently constructed for all treeshaped OMQs with a bounded number of leaves, all OMQs with ontologies of bounded depth and CQs of bounded treewidth, and all OMQs with ontologies of depth 1. For OMQs with ontologies of depth 2 and arbitrary CQs, and OMQs with arbitrary ontologies and tree-shaped CQs, we have an exponential lower bound on the size of NDL- (and so PE-) rewritings. The existence of polynomial-size FO rewritings for all OMQs in each of these classes (save the first one) turns out to be equivalent to one of the major open problems in computational complexity such as NC1 = NP/poly.7\nWe obtain these results by establishing a connection between succinctness of rewritings and circuit complexity, a branch of computational complexity theory that classifies Boolean functions according to the size of circuits computing them. Our starting point is the observation that the tree-witness PE-rewriting of an OMQ Q = (T , q) introduced by [49] defines a hypergraph whose vertices are the atoms in q and whose hyperedges correspond to connected sub-queries of q that can be homomorphically mapped to labelled nulls of some chases for T . Based on this observation, we introduce a new computational model for Boolean functions by treating any hypergraphH , whose vertices are labelled by (possibly negated) Boolean variables or constants 0 and 1, as a program computing a Boolean function fH that returns 1 on a valuation for the variables iff there is an independent subset of hyperedges covering all vertices labelled by 0 (under the valuation). We show that constructing short FO- (respectively, PE- and NDL-) rewritings of Q is (nearly) equivalent to finding short Boolean formulas (respectively, monotone formulas and monotone circuits) computing the hypergraph function for Q.\nFor each of the OMQ classes in Fig. 2 (a), we characterise the computational power of the corresponding hypergraph programs and employ results from circuit complexity to identify the size of rewritings. For example, we show that OMQs with ontologies of depth 1 correspond to hypergraph programs of degree \u2264 2 (in which every vertex belongs to at most two hyperedges), and that the latter are polynomially equivalent to nondeterministic branching programs (NBPs). Since NBPs compute the Boolean functions in the class NL/poly \u2286 P/poly, the tree-witness rewritings for OMQs with ontologies of depth 1 can be equivalently transformed into polynomialsize NDL-rewritings. On the other hand, there exist monotone Boolean functions computable by polynomial-size NBPs but not by polynomial-size monotone Boolean formulas, which establishes\n6 Domain-independent FO-rewritings correspond to SQL queries, PE-rewritings to Select-ProjectJoin-Union (or SPJU) queries, and NDL-rewritings to SPJU queries with views; see also Remark 1. 7 C/poly is the non-uniform analogue of a complexity class C.\na superpolynomial lower bound for PE-rewritings. It also follows that all such OMQs have polynomial-size FO-rewritings iff NC1 = NL/poly.\nThe succinctness results in Fig. 2 (a), characterising the complexity of the reduction to plain database query evaluation, are complemented by the combined complexity results in Fig. 2 (b). Combined complexity measures the time and space required for a best possible algorithm to answer an OMQ Q = (T , q) from the given class over a data instance A, as a function of the size of Q and A. It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity\u2014that is, of the same complexity as standard CQ evaluation in databases. However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32]. Here, we prove that, surprisingly, answering OMQs with ontologies of bounded depth and CQs of bounded treewidth is no harder than evaluating CQs of bounded treewidth, that is, LOGCFL-complete. By restricting further the class of CQs to trees with a bounded number of leaves, we obtain an even better NL-completeness result, which matches the complexity of evaluating the underlying CQs. If we consider bounded-leaf tree-shaped CQs coupled with arbitrary OWL2QL ontologies, then the OMQ answering problem remains tractable, LOGCFL-complete to be more precise.\nThe plan of the paper is as follows. Section 2 gives formal definitions of OWL2QL, OMQs and rewritings. Section 3 defines the tree-witness rewriting. Section 4 reduces the succinctness problem for OMQ rewritings to the succinctness problem for hypergraph Boolean functions associated with tree-witness rewritings, and introduces hypergraph programs for computing these functions. Section 5 establishes a correspondence between the OMQ classes in Fig. 2 and the structure of the corresponding hypergraph functions and programs. Section 6 characterises the computational power of hypergraph programs in these classes by relating them to standard models of computation for Boolean functions. Section 7 uses the results of the previous three sections and some known facts from circuit complexity to obtain the upper and lower bounds on the size of PE-, NDL- and FO-rewritings in Fig. 2 (a). Section 8 establishes the combined complexity results in Fig. 2 (b). We conclude in Section 9 by discussing the obtained succinctness and complexity results and formulating a few open problems. All omitted proofs can be found in the appendix.\n2 OWL2QL ontology-mediated queries and first-order rewritability\nIn first-order logic, any OWL2QL ontology (or TBox in description logic parlance), T , can be given as a finite set of sentences (often called axioms) of the following forms\n\u2200x ( \u03c4(x) \u2192 \u03c4 \u2032(x) ) , \u2200x ( \u03c4(x) \u2227 \u03c4 \u2032(x) \u2192 \u22a5 ) , \u2200x, y ( \u033a(x, y) \u2192 \u033a\u2032(x, y) ) , \u2200x, y ( \u033a(x, y) \u2227 \u033a\u2032(x, y) \u2192 \u22a5 ) , \u2200x \u033a(x, x), \u2200x ( \u033a(x, x) \u2192 \u22a5 ) ,\nwhere the formulas \u03c4(x) (called classes or concepts) and \u033a(x, y) (called properties or roles) are defined, using unary predicates A and binary predicates P , by the grammars\n\u03c4(x) ::= \u22a4 | A(x) | \u2203y \u033a(x, y) and \u033a(x, y) ::= \u22a4 | P (x, y) | P (y, x). (1)\n(Strictly speaking, OWL2QL ontologies can also contain inequalities a 6= b, for constants a and b. However, they do not have any impact on the problems considered in this paper, and so will be ignored.)\nExample 1. To illustrate, we show a snippet of the NPD FactPages ontology:\n\u2200x (GasPipeline(x) \u2192 Pipeline(x)),\n\u2200x (FieldOwner(x) \u2194 \u2203y ownerForField(x, y)),\n\u2200y (\u2203x ownerForField(x, y) \u2192 Field(y)),\n\u2200x, y (shallowWellboreForField(x, y) \u2192 wellboreForField(x, y)),\n\u2200x, y (isGeometryOfFeature(x, y) \u2194 hasGeometry(y, x)).\nTo simplify presentation, in our ontologies we also use sentences of the form\n\u2200x ( \u03c4(x) \u2192 \u03b6(x) ) , (2)\nwhere \u03b6(x) ::= \u03c4(x) | \u03b61(x) \u2227 \u03b62(x) | \u2203y ( \u033a1(x, y) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u033ak(x, y) \u2227 \u03b6(y) ) .\nIt is readily seen that such sentences are just syntactic sugar and can be eliminated by means of polynomially many fresh predicates. Indeed, any axiom of the form (2) with\n\u03b6(x) = \u2203y ( \u033a1(x, y) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u033ak(x, y) \u2227 \u03b6 \u2032(y) )\ncan be (recursively) replaced by the following axioms, for a fresh P\u03b6 and i = 1, . . . , k:\n\u2200x ( \u03c4(x) \u2192 \u2203y P\u03b6(x, y) ) , \u2200x, y ( P\u03b6(x, y) \u2192 \u033ai(x, y) ) , \u2200y ( \u2203xP\u03b6(x, y) \u2192 \u03b6 \u2032(y) )\n(3)\nbecause any first-order structure is a model of (2) iff it is a restriction of some model of (3) to the signature of (2). The result of eliminating the syntactic sugar from an ontology T is called the normalisation of T . We always assume that all of our ontologies are normalised even though this is not done explicitly; however, we stipulate (without loss of generality) that the normalisation predicates P\u03b6 never occur in the data.\nWhen writing ontology axioms, we usually omit the universal quantifiers. We typically use the characters P , R to denote binary predicates, A, B, C for unary predicates, and S for either of them. For a binary predicate P , we write P\u2212 to denote its inverse; that is, P (x, y) = P\u2212(y, x), for any x and y, and P\u2212\u2212 = P .\nA conjunctive query (CQ) q(x) is a formula of the form \u2203y \u03d5(x,y), where \u03d5 is a conjunction of atoms S(z) all of whose variables are among x, y.\nExample 2. Here is a (fragment of a) typical CQ from the NPD FactPages:\nq(x1, x2, x3) = \u2203y, z [ ProductionLicence(x1) \u2227 ProductionLicenceOperator(y) \u2227\ndateOperatorValidFrom(y, x2) \u2227 licenceOperatorCompany(y, z) \u2227\nname(z, x3) \u2227 operatorForLicence(y, x1) ] .\nTo simplify presentation and without loss of generality, we assume that CQs do not contain constants. Where convenient, we regard a CQ as the set of its atoms; in particular, |q| is the size of q. The variables in x are called the answer variables of a CQ q(x). A CQ without answer variables is called Boolean. With every CQ q, we associate its Gaifman graph Gq whose vertices are the variables of q and whose edges are the pairs {u, v} such that P (u, v) \u2208 q, for some P . A CQ q is connected if the graph Gq is connected. We call q tree-shaped if Gq is a tree\n8, and if Gq is a tree with at most two leaves, then q is said to be linear.\nAn OWL2QL ontology-mediated query (OMQ) is a pair Q(x) = (T , q(x)), where T is an OWL2QL ontology and q(x) a CQ. The size of Q is defined as |Q| = |T | + |q|, where |T | is the number of symbols in T .\nA data instance, A, is a finite set of unary or binary ground atoms (called an ABox in description logic). We denote by ind(A) the set of individual constants in A. Given an OMQ Q(x) and a data instance A, a tuple a of constants from ind(A) of length |x| is called a certain answer to Q(x) over A if I |= q(a) for all models I of T \u222aA; in this case we write T ,A |= q(a). If q(x) is Boolean, a certain answer to Q over A is \u2018yes\u2019 if T ,A |= q, and \u2018no\u2019 otherwise. We remind the reader [56] that, for any CQ q(x) = \u2203y \u03d5(x,y), any first-order structure I and any tuple a from its domain \u2206, we have I |= q(a) iff there is a map h : x \u222a y \u2192 \u2206 such that (i) if S(z) \u2208 q then I |= S(h(z)), and (ii) h(x) = a. If (i) is satisfied then h is called a homomorphism from q to I, and we write h : q \u2192 I; if (ii) also holds, we write h : q(a) \u2192 I.\nCentral to OBDA is the notion of OMQ rewriting that reduces the problem of finding certain answers to standard query evaluation. More precisely, an FO-formula q\u2032(x), possibly with equality, =, is an FO-rewriting of an OMQ Q(x) = (T , q(x)) if, for any data instance A (without the normalisation predicates for T ) and any tuple a in ind(A),\nT ,A |= q(a) iff IA |= q \u2032(a), (4)\n8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].\nwhere IA is the first-order structure over the domain ind(A) such that IA |= S(a) iff S(a) \u2208 A, for any ground atom S(a). As A is arbitrary, this definition implies, in particular, that the rewriting must be constant-free. If q\u2032(x) is a positive existential formula\u2014that is, q\u2032(x) = \u2203y \u03d5(x,y) with \u03d5 constructed from atoms (possibly with equality) using \u2227 and \u2228 only\u2014we call it a PE-rewriting of Q(x). A PE-rewriting whose matrix \u03d5 is a disjunction of conjunctions is known as a UCQ-rewriting; if \u03d5 takes the form \u2227\u2228\u2227\u2228 we call it a \u03a04-rewriting. The size |q\u2032| of q\u2032 is the number of symbols in it.\nWe also consider rewritings in the form of nonrecursive datalog queries. Recall [1] that a datalog program, \u03a0 , is a finite set of Horn clauses \u2200x (\u03b31 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b3m \u2192 \u03b30), where each \u03b3i is an atom P (x1, . . . , xl) with xi \u2208 x. The atom \u03b30 is the head of the clause, and \u03b31, . . . , \u03b3m its (possibly empty) body. A predicate S depends on S\u2032 in \u03a0 if \u03a0 has a clause with S in the head and S\u2032 in the body; \u03a0 is nonrecursive if this dependence relation is acyclic.\nLet Q = (T , q(x)) be an OMQ, \u03a0 a constant-free nonrecursive program, and G(x) a predicate. The pair q\u2032(x) = (\u03a0,G(x)) is an NDL-rewriting of Q if, for any data instance A and any tuple a in ind(A), we have T ,A |= q(a) iff \u03a0(IA) |= G(a), where \u03a0(IA) is the structure with domain ind(A) obtained by closing IA under the clauses in \u03a0 . Every PE-rewriting can clearly be represented as an NDL-rewriting of linear size.\nRemark 1. As defined, FO- and PE-rewritings are not necessarily domain-independent queries, while NDL-rewritings are not necessarily safe [1]. For example, (x = x) is a PE-rewriting of the OMQ ({\u2200xP (x, x)}, P (x, x)), and the program ({\u22a4 \u2192 A(x)}, A(x)) is an NDL-rewriting of the OMQ ({\u22a4 \u2192 A(x)}, A(x)). Rewritings can easily be made domain-independent and safe by relativising their variables to the predicates in the data signature (relational schema). For instance, if this signature is {A,P}, then a domain-independent relativisation of (x = x) is the PE-rewriting ( A(x)\u2228\u2203y P (x, y)\u2228\u2203y P (y, x) ) \u2227 (x = x). Note that if we exclude from OWL2QL reflexivity statements and axioms with \u22a4 on the left-hand side, then rewritings are guaranteed to be domain-independent, and no relativisation is required. In any case, rewritings are always interpreted under the active domain semantics adopted in databases; see (4).\nAs mentioned in the introduction, the OWL2QL profile of OWL2 was designed to ensure FO-rewritability of all OMQs with ontologies in the profile or, equivalently, OMQ answering in AC0 for data complexity. It should be clear, however, that for the OBDA approach to work in practice, the rewritings of OMQs must be of \u2018reasonable shape and size\u2019. Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large\u2014exponentially-large in the size of the original CQ, to be more precise. These facts imply that, in the context of OBDA, we should actually be interested not in arbitrary but in polynomial-size rewritings. In complexity-theoretic terms, the focus should not only be on the data complexity of OMQ answering, which is an appropriate measure for database query evaluation (where queries are indeed usually small) [74], but also on the combined complexity that takes into account the contribution of ontologies and queries."}, {"heading": "3 Tree-Witness Rewriting", "text": "Now we define one particular rewriting of OWL2QL OMQs that will play a key role in the succinctness and complexity analysis later on in the paper. This rewriting is a modification of the tree-witness PE-rewriting originally introduced by Kikot et al. [49] (cf. [57, 52, 51] for rewritings based on similar ideas).\nWe begin with two simple observations that will help us remove unneeded clutter from the definitions. Every OWL2QL ontology T consists of two parts: T \u2212, which contains all the sentences with \u22a5, and the remainder, T +, which is consistent with every data instance. For any \u03c8(z) \u2192 \u22a5 in T \u2212, consider the Boolean CQ \u2203z \u03c8(z). It is not hard to see that, for any OMQ (T , q(x)) and data instance A, a tuple a is a certain answer to (T , q(x)) over A iff either T +,A |= q(a) or T +,A |= \u2203z \u03c8(z), for some \u03c8(z) \u2192 \u22a5 in T \u2212; see [17] for more details. Thus, from now on we will assume that, in all our ontologies T , the \u2018negative\u2019 part T \u2212 is empty, and so they are consistent with all data instances.\nThe second observation will allow us to restrict the class of data instances we need to consider when rewriting OMQs. In general, if we only require condition (4) to hold for any data instance\nA from some class A, then we call q\u2032(x) a rewriting of Q(x) over A. Such classes of data instances can be defined, for example, by the integrity constraints in the database schema and the mapping [67]. We say that a data instance A is complete9 for an ontology T if T ,A |= S(a) implies S(a) \u2208 A, for any ground atom S(a) with a from ind(A). The following proposition means that from now on we will only consider rewritings over complete data instances.\nProposition 1. If q\u2032(x) is an NDL-rewriting of Q(x) = (T , q(x)) over complete data instances, then there is an NDL-rewriting q\u2032\u2032(x) of Q(x) over arbitrary data instances with |q\u2032\u2032| \u2264 |q\u2032| \u00b7 |T |."}, {"heading": "A similar result holds for PE- and FO-rewritings.", "text": "Proof. Let (\u03a0,G(x)) be an NDL-rewriting of Q(x) over complete data instances. Denote by \u03a0\u2217 the result of replacing each predicate S in \u03a0 with a fresh predicate S\u2217. Define \u03a0 \u2032 to be the union of \u03a0\u2217 and the following clauses for predicates in \u03a0 :\n\u03c4(x) \u2192 A\u2217(x), if T |= \u03c4(x) \u2192 A(x),\n\u033a(x, y) \u2192 P \u2217(x, y), if T |= \u033a(x, y) \u2192 P (x, y),\n\u22a4 \u2192 P \u2217(x, x), if T |= P (x, x)\n(the empty body is denoted by \u22a4). It is readily seen that (\u03a0 \u2032, G\u2217(x)) is an NDL-rewriting of Q(x) over arbitrary data instances. The cases of PE- and FO-rewritings are similar except that we replace A(x) and P (x, y) with\n\u2228\nT |=\u03c4(x)\u2192A(x) \u03c4(x) and\n\u2228\nT |=\u033a(x,y)\u2192P (x,y) \u033a(x, y) \u2228\n\u2228\nT |=P (x,x) (x = y),\nrespectively (the empty disjunction is, by definition, \u22a5).\nAs is well-known [1], every pair (T ,A) of an ontology T and data instance A possesses a canonical model (or chase) CT ,A such that T ,A |= q(a) iff CT ,A |= q(a), for all CQs q(x) and a in ind(A). In our proofs, we use the following definition of CT ,A, where without loss of generality we assume that T does not contain binary predicates P such that T |= \u2200x, y P (x, y). Indeed, occurrences of such P in T can be replaced by \u22a4 and occurrences of P (x, y) in CQs can simply be removed without changing certain answers over any data instance (provided that x and y occur in the remainder of the query).\nThe domain \u2206CT ,A of the canonical model CT ,A consists of ind(A) and the witnesses, or labelled nulls, introduced by the existential quantifiers in (the normalisation of) T . More precisely, the labelled nulls in CT ,A are finite words of the form w = a\u033a1 . . . \u033an (n \u2265 1) such that\n\u2013 a \u2208 ind(A) and T ,A |= \u2203y \u033a1(a, y), but T ,A 6|= \u033a1(a, b) for any b \u2208 ind(A); \u2013 T 6|= \u033ai(x, x) for 1 \u2264 i \u2264 n; \u2013 T |= \u2203x \u033ai(x, y) \u2192 \u2203z \u033ai+1(y, z) and T 6|= \u033ai(y, x) \u2192 \u033ai+1(x, y) for 1 \u2264 i < n.\nEvery individual name a \u2208 ind(A) is interpreted in CT ,A by itself, and unary and binary predicates are interpreted as follows: for any u, v \u2208 \u2206CT ,A ,\n\u2013 CT ,A |= A(u) iff either u \u2208 ind(A) and T ,A |= A(u), or u = w\u033a, for some w and \u033a with T |= \u2203y \u033a(y, x) \u2192 A(x);\n\u2013 CT ,A |= P (u, v) iff one of the following holds: (i) u, v \u2208 ind(A) and T ,A |= P (u, v); (ii) u = v and T |= P (x, x); (iii) v = u\u033a and T |= \u033a(x, y) \u2192 P (x, y); (iv) u = v\u033a\u2212 and T |= \u033a(x, y) \u2192 P (x, y).\nExample 3. Consider the following ontologies:\nT1 = { A(x) \u2192 \u2203y ( R(x, y) \u2227Q(y, x) ) },\nT2 = { A(x) \u2192 \u2203y R(x, y), \u2203xR(x, y) \u2192 \u2203z Q(z, y) },\nT3 = { A(x) \u2192 \u2203y R(x, y), \u2203xR(x, y) \u2192 \u2203z R(y, z) }.\nThe canonical models of (Ti,A), for A = {A(a)}, i = 1, 2, 3, are shown in Fig. 3, where \u03b6(x) = \u2203y (R(x, y) \u2227 Q(y, x)) and P\u03b6 is the corresponding normalisation predicate. When depicting canonical models, we use for constants and for labelled nulls.\n9 Rodriguez-Muro et al. [67] used the term \u2018H-completeness\u2019; see also [50].\nFor any ontology T and any formula \u03c4(x) given by (1), we denote by C\u03c4(a)T the canonical model of (T \u222a{A(x) \u2192 \u03c4(x)}, {A(a)}), for a fresh unary predicate A. We say that T is of depth k, 1 \u2264 k < \u03c9, if (i) there is no \u033a with T |= \u033a(x, x), (ii) at least one of the C\u03c4(a)T contains a word a\u033a1 . . . \u033ak, but (iii) none of the C\u03c4(a)T has such a word of greater length. Thus, T1 in Example 3 is of depth 1, T2 of depth 2, while T3 is not of any finite depth.\nOntologies of infinite depth generate infinite canonical models. However, OWL2QL has the polynomial derivation depth property (PDDP) in the sense that there is a polynomial p such that, for any OMQ Q(x) = (T , q(x)), data instance A and a in ind(A), we have T ,A |= q(a) iff q(a) holds in the sub-model of CT ,A whose domain consists of words of the form a\u033a1 . . . \u033an with n \u2264 p(|Q|) [41, 17]. (In general, the bounded derivation depth property of an ontology language is a necessary and sufficient condition of FO-rewritability [31].)\nWe call a set \u2126Q of words of the form w = \u033a1 . . . \u033an fundamental for Q if, for any A and a in ind(A), we have T ,A |= q(a) iff q(a) holds in the sub-model of CT ,A with the domain {aw | a \u2208 ind(A), w \u2208 \u2126Q}. We say that a class Q of OMQs has the polynomial fundamental set property (PFSP) if there is a polynomial p such that every Q \u2208 Q has a fundamental set \u2126Q with |\u2126Q| \u2264 p(|Q|). The class of all OMQs (even with ontologies of finite depth and tree-shaped CQs) does not have the PFSP [47]. On the other hand, it should be clear that the class of OMQs with ontologies of bounded depth does enjoy the PFSP. A less trivial example is given by the following theorem, which is an immediate consequence of Theorem 3 below:\nTheorem 1. The class of OMQs whose ontologies do not contain axioms of the form \u033a(x, y) \u2192 \u033a\u2032(x, y) (and syntactic sugar (2)) enjoys the PFSP.\nWe are now in a position to define the tree-witness PE-rewriting of OWL2QL OMQs. Suppose we are given an OMQ Q(x) = (T , q(x)) with q(x) = \u2203y \u03d5(x,y). For a pair t = (tr, ti) of disjoint sets of variables in q, with ti \u2286 y10 and ti 6= \u2205 (tr can be empty), set\nq t = { S(z) \u2208 q | z \u2286 tr \u222a ti and z 6\u2286 tr } .\nIf q t is a minimal subset of q for which there is a homomorphism h : q t \u2192 C\u03c4(a)T such that tr = h \u22121(a) and q t contains every atom of q with at least one variable from ti, then we call t = (tr, ti) a tree witness for Q generated by \u03c4 (and induced by h). Observe that if tr = \u2205 then q t is a connected component of q; in this case we call t detached. Note also that the same tree witness t = (tr, ti) can be generated by different \u03c4 . Now, we set\ntwt(tr) = \u2203z (\u2227\nx\u2208tr (x = z) \u2227\n\u2228\nt generated by \u03c4\n\u03c4(z) ) . (5)\nThe variables in ti do not occur in twt and are called internal. The variables in tr, if any, are called root variables. Note that no answer variable in q(x) can be internal. The length |twt| of twt is O(|Q|). Tree witnesses t and t \u2032 are conflicting if q t \u2229q\nt\u2032 6= \u2205. Denote by \u0398Q the set of tree witnesses for Q(x). A subset \u0398 \u2286 \u0398Q is independent if no pair of distinct tree witnesses in it is conflicting. Let q\u0398 = \u22c3\nt\u2208\u0398 qt. The following PE-formula is called the tree-witness rewriting of Q(x) over complete data instances :\nqtw(x) = \u2228\n\u0398\u2286\u0398Q independent \u2203y\n( \u2227\nS(z)\u2208q\\q\u0398\nS(z) \u2227 \u2227\nt\u2208\u0398 twt(tr)\n) . (6)\n10 We (ab)use set-theoretic notation for lists and, for example, write ti \u2286 y to say that every element of ti is an element of y.\nRemark 2. As the normalisation predicates P\u03b6 cannot occur in data instances, we can omit from (5) all the disjuncts with P\u03b6 . For the same reason, the tree witnesses generated only by concepts with normalisation predicates will be ignored in the sequel.\nExample 4. Consider the OMQ Q(x1, x2) = (T , q(x1, x2)) with\nT = { A1(x) \u2192 \u2203y ( R1(x, y) \u2227Q(x, y) )\n\ufe38 \ufe37\ufe37 \ufe38\n\u03b61(x)\n, A2(x) \u2192 \u2203y ( R2(x, y) \u2227Q(y, x) )\n\ufe38 \ufe37\ufe37 \ufe38\n\u03b62(x)\n} ,\nq(x1, x2) = \u2203y1, y2 ( R1(x1, y1) \u2227Q(y2, y1) \u2227R2(x2, y2) ) .\nThe CQ q is shown in Fig. 4 alongside CA1(a)T and C A2(a) T . When depicting CQs, we use for answer variables and for existentially quantified variables. There are two tree witnesses, t1 and t 2, for Q with\nq t1 = { R1(x1, y1), Q(y2, y1) } and q t2 = { Q(y2, y1), R2(x2, y2) }\nshown in Fig. 4 by the dark and light shading, respectively. The tree witness t1 = (t1r , t 1 i ) with t1r = {x1, y2} and t 1 i = {y1} is generated by A1(x), which gives\ntwt1(x1, y2) = \u2203z ( A1(z) \u2227 (x1 = z) \u2227 (y2 = z) ) .\n(Recall that although t1 is also generated by \u2203y P\u03b61(y, z), we do not include it in the disjunction in twt1 because P\u03b61 cannot occur in data instances.) Symmetrically, the tree witness t 2 gives\ntwt2(x2, y1) = \u2203z ( A2(z) \u2227 (x2 = z) \u2227 (y1 = z) ) .\nAs t1 and t2 are conflicting, \u0398Q contains three independent subsets: \u2205, {t1} and {t2}. Thus, we obtain the following tree-witness rewriting qtw(x1, x2) of Q over complete data instances:\n\u2203y1, y2 [( R1(x1, y1) \u2227Q(y2, y1) \u2227R2(x2, y2) ) \u2228 ( twt1 \u2227R2(x2, y2) ) \u2228 ( R1(x1, y1) \u2227 twt2 )] .\nTheorem 2 ([49]). For any OMQ Q(x) = (T , q(x)), any data instance A, which is complete for T , and any tuple a from ind(A), we have T ,A |= q(a) iff IA |= qtw(a). In other words, qtw is a rewriting of Q(x) over complete data instances.\nIntuitively, for every homomorphism h : q(a) \u2192 CT ,A, the sub-CQs of q mapped by h to submodels of the form C\u03c4(a)T define an independent set \u0398 of tree witnesses; see Fig. 5. Conversely, if \u0398 is such a set, then the homomorphisms corresponding to the tree witnesses in \u0398 can be pieced together into a homomorphism from q(a) to CT ,A\u2014provided that the S(z) from q \\ q\u0398 and the twt(tr) for t \u2208 \u0398 hold in IA.\nThe size of the tree-witness PE-rewriting qtw depends on the number of tree witnesses in the given OMQ Q = (T , q) and, more importantly, on the cardinality of \u0398Q as we have |qtw| = O(2 |\u0398Q| \u00b7 |Q|2) with |\u0398Q| \u2264 3|q|.\nTheorem 3. OMQs Q = (T , q), in which T does not contain axioms of the form \u033a(x, y) \u2192 \u033a\u2032(x, y) (and syntax sugar (2)), have at most 3|q| tree witnesses.\nProof. As observed above, there can be only one detached tree witness for each connected component of q. As T has no axioms of the form \u033a(x, y) \u2192 \u033a\u2032(x, y), any two points in C\u03c4(a)T can be R-related for at most one R, and so no point can have more than one R-successor, for any R. It follows that, for every atom P (x, y) in q, there can be at most one tree witness t = (tr, ti) with P (x, y) \u2208 q\nt , x \u2208 tr and y \u2208 ti (P\u2212(y, x) may give another tree witness).\nOMQs with arbitrary axioms can have exponentially many tree witnesses:\nExample 5. Consider the OMQ Qn = (T , qn(x 0)), where\nT = { A(x) \u2192 \u2203y ( R(y, x) \u2227 \u2203z (R(y, z) \u2227B(z)) )} ,\nqn(x 0) = \u2203y,y1,x1,y2\n( B(y) \u2227\n\u2227\n1\u2264k\u2264n\n( R(y1k, y) \u2227R(y 1 k, x 1 k) \u2227R(y 2 k, x 1 k) \u2227R(y 2 k, x 0 k) ))\nand xi and yi denote vectors of n variables xik and y i k, for 1 \u2264 k \u2264 n, respectively. The CQ is shown in Fig. 6 alongside the canonical model CA(a)T . OMQ Qn has at least 2 n tree witnesses: for any \u03b1 = (\u03b11, . . . , \u03b1n) \u2208 {0, 1}n, there is a tree witness (t\u03b1r , t \u03b1 i ) with t\u03b1r = {x \u03b1k k | 1 \u2264 k \u2264 n}. Note, however, that the tree-witness rewriting of Qn can be equivalently transformed into the following polynomial-size PE-rewriting:\nqn(x 0) \u2228 \u2203z\n[ A(z) \u2227\n\u2227\n1\u2264i\u2264n\n( (x0i = z) \u2228 \u2203y (R(y, x 0 i ) \u2227R(y, z)) )] .\nIf any two tree witnesses for an OMQ Q are compatible in the sense that either they are non-conflicting or one is included in the other, then qtw can be equivalently transformed to the PE-rewriting\n\u2203y \u2227\nS(z)\u2208q\n( S(z) \u2228\n\u2228\nt\u2208\u0398Q with S(z)\u2208qt\ntwt(tr) )\nof size O(|\u0398Q| \u00b7 |Q| 2).\nWe now analyse transformations of this kind in the setting of Boolean functions."}, {"heading": "4 OMQ Rewritings as Boolean Functions", "text": "For any OMQ Q(x) = (T , q(x)), we define Boolean functions f\u25bdQ and f \u25b3 Q such that:\n\u2013 if f\u25bdQ is computed by a Boolean formula (monotone formula or monotone circuit) \u03a6, then Q has an FO- (respectively, PE- or NDL-) rewriting of size O(|\u03a6| \u00b7 |Q|);\n\u2013 if q\u2032 is an FO- (PE- or NDL-) rewriting of Q, then f\u25b3Q is computed by a Boolean formula (respectively, monotone formula or monotone circuit) of size O(|q\u2032|).\nWe remind the reader (for details see, e.g., [3, 42]) that an n-ary Boolean function, for n \u2265 1, is any function from {0, 1}n to {0, 1}. A Boolean function f is monotone if f(\u03b1) \u2264 f(\u03b2) for all \u03b1 \u2264 \u03b2, where \u2264 is the component-wise \u2264 on vectors of {0, 1}. A Boolean circuit, C, is a directed acyclic graph whose vertices are called gates. Each gate is labelled with a propositional variable, a constant 0 or 1, or with not, and or or. Gates labelled with variables and constants have in-degree 0 and are called inputs ; not-gates have in-degree 1, while and- and or-gates have\nin-degree 2 (unless otherwise specified). One of the gates in C is distinguished as the output gate. Given an assignment \u03b1 \u2208 {0, 1}n to the variables, we compute the value of each gate in C under \u03b1 as usual in Boolean logic. The output C(\u03b1) of C on \u03b1 \u2208 {0, 1}n is the value of the output gate. We usually assume that the gates g1, . . . , gm of C are ordered in such a way that g1, . . . , gn are input gates; each gate gi, for i \u2265 n, gets inputs from gates gj1 , . . . , gjk with j1, . . . , jk < i, and gm is the output gate. We say that C computes an n-ary Boolean function f if C(\u03b1) = f(\u03b1) for all \u03b1 \u2208 {0, 1}n. The size |C| of C is the number of gates in C. A circuit is monotone if it contains only inputs, and- and or-gates. Boolean formulas can be thought of as circuits in which every logic gate has at most one outgoing edge. Any monotone circuit computes a monotone function, and any monotone Boolean function can be computed by a monotone circuit."}, {"heading": "4.1 Hypergraph Functions", "text": "Let H = (V,E) be a hypergraph with vertices v \u2208 V and hyperedges e \u2208 E \u2286 2V . A subset E\u2032 \u2286 E is said to be independent if e \u2229 e\u2032 = \u2205, for any distinct e, e\u2032 \u2208 E\u2032. The set of vertices that occur in the hyperedges of E\u2032 is denoted by VE\u2032 . For each vertex v \u2208 V and each hyperedge e \u2208 E, we take propositional variables pv and pe, respectively. The hypergraph function fH for H is given by the monotone Boolean formula\nfH = \u2228\nE\u2032 independent\n( \u2227\nv\u2208V \\VE\u2032 pv \u2227\n\u2227\ne\u2208E\u2032 pe\n)\n. (7)\nThe tree-witness PE-rewriting qtw of any OMQ Q(x) = (T , q(x)) defines a hypergraph whose vertices are the atoms of q and hyperedges are the sets q\nt , where t is a tree witness for\nQ. We denote this hypergraph by H(Q) and call fH(Q) the tree-witness hypergraph function for Q. To simplify notation, we write f\u25bdQ instead of fH(Q). Note that formula (7) defining f \u25bd Q is obtained from rewriting (6) by regarding the atoms S(z) in q and tree-witness formulas twt as propositional variables. We denote these variables by pS(z) and pt (rather than pv and pe), respectively.\nExample 6. For the OMQ Q in Example 4, the hypergraph H(Q) has 3 vertices (one for each atom in the query) and 2 hyperedges (one for each tree witness) shown in Fig. 7. The tree-witness hypergraph function for Q is as follows:\nf\u25bdQ = ( pR1(x1,y1) \u2227 pQ(y2,y1) \u2227 pR2(x2,y2) ) \u2228 ( pt1 \u2227 pR2(x2,y2) ) \u2228 ( pR1(x1,y1) \u2227 pt2 ) .\nSuppose the function f\u25bdQ for an OMQ Q(x) is computed by a Boolean formula \u03a6. Consider the first-order formula \u03a6\u2217(x) obtained by replacing each pS(z) in \u03a6 with S(z), each pt with twt, and adding the appropriate prefix \u2203y. By comparing (7) and (6), we see that \u03a6\u2217(x) is an FO-rewriting of Q(x) over data instances that are complete over T . This gives claim (i) of the following theorem:\nTheorem 4. (i) If f\u25bdQ is computed by a (monotone) Boolean formula \u03a6, then there is a (PE-) FO-rewriting of Q(x) of size O(|\u03a6| \u00b7 |Q|).\n(ii) If f\u25bdQ is computed by a monotone Boolean circuit C, then there is an NDL-rewriting of Q(x) of size O(|C | \u00b7 |Q|).\nProof. (ii) Let t1, . . . , tl be tree witnesses for Q(x) = (T , q(x)), where q(x) = \u2203y \u2227n\ni=1 Si(zi). We assume that the gates g1, . . . , gn of C are the inputs pS1(z1), . . . , pSn(zn) for the atoms, the gates gn+1, . . . , gn+l are the inputs pt1 , . . . , ptl for the tree witnesses and gn+l+1, . . . , gm are andand or-gates. Denote by \u03a0 the following NDL-program, where z = x \u222a y:\n\u2013 Si(zi) \u2192 Gi(z), for 0 < i \u2264 n; \u2013 \u03c4(u) \u2192 Gi+m(z[tjr /u]), for 0 < j \u2264 l and \u03c4 generating t\nj, where z[tjr /u] is the result of replacing each z \u2208 tjr in z with u;\n\u2013\n{\nGj(z) \u2227Gk(z) \u2192 Gi(z), if gi = gj \u2227 gk, Gj(z) \u2192 Gi(z) and Gk(z) \u2192 Gi(z), if gi = gj \u2228 gk, for n+ l < i \u2264 m;\n\u2013 Gm(z) \u2192 G(x).\nIt is not hard to see that (\u03a0,G(x)) is an NDL-rewriting of Q(x).\nThus, the problem of constructing polynomial-size rewritings of OMQs reduces to finding polynomial-size (monotone) formulas or monotone circuits for the corresponding functions f\u25bdQ. Note, however, that f\u25bdQ contains a variable pt for every tree witness t, which makes this reduction useless for OMQs with exponentially many tree witnesses. To be able to deal with such OMQs, we slightly modify the tree-witness rewriting.\nSuppose t = (tr, ti) is a tree witness for Q = (T , q) induced by a homomorphism h : qt \u2192 C \u03c4(a) T . We say that t is \u033a-initiated if h(z) is of the form a\u033aw, for every (equivalently, some) variable z \u2208 ti. For such \u033a, we define a formula \u033a\u2217(x) by taking the disjunction of \u03c4(x) with T |= \u03c4(x) \u2192 \u2203y \u033a(x, y). Again, the disjunction includes only those \u03c4(x) that do not contain normalisation predicates (even though \u033a itself can be one).\nExample 7. Consider the OMQ Q(x) = (T , q(x)) with\nT = { \u2203y Q(x, y) \u2192 \u2203y P (x, y), P (x, y) \u2192 R(x, y) } and q(x) = \u2203y R(x, y).\nAs shown in Fig. 8, the tree witness t = ({x}, {y}) forQ(x) is generated by \u2203y Q(x, y), \u2203y P (x, y) and \u2203y R(x, y); it is also P - and R-initiated, but not Q-initiated. We have:\nP \u2217(x) = \u2203y Q(x, y) \u2228 \u2203y P (x, y) and R\u2217(x) = \u2203y Q(x, y) \u2228 \u2203y P (x, y) \u2228 \u2203y R(x, y).\nThe modified tree-witness rewriting for Q(x) = (T , q(x)), denoted q\u2032tw(x), is obtained by replacing (5) in (6) with the formula\ntw\u2032 t (tr, ti) =\n\u2227\nR(z,z\u2032)\u2208q t\n(z = z\u2032) \u2227 \u2228\nt is \u033a-initiated\n\u2227\nz\u2208tr\u222ati \u033a\u2217(z). (5\u2032)\nNote that unlike (5), this formula contains the variables in both ti and tr, which must be equal under every satisfying assignment. We associate with q\u2032tw(x) the monotone Boolean function f H Q given by the formula obtained from (7) by replacing each variable pv with the respective pS(z), for S(z) \u2208 q, and each variable pe with the formula\n\u2227\nR(z,z\u2032)\u2208q t\npz=z\u2032 \u2227 \u2228\nt is \u033a-initiated\n\u2227\nz\u2208tr\u222ati p\u033a\u2217(z), (8)\nfor the respective tree witness t = (tr, ti) for Q(x), where pz=z\u2032 and p\u033a\u2217(z) are propositional variables. Clearly, the number of variables in fHQ is polynomial in |Q|.\nExample 8. For the OMQ Q(x) in the Example 4, we have:\nfHQ = ( pR1(x1,y1) \u2227 pQ(y2,y1) \u2227 pR2(x2,y2) ) \u2228\n(( px1=y1\u2227 py2=y1 \u2227\n\u2227\nz\u2208{x1,y1,y2} pP\u2217 \u03b61 (z)\n) \u2227 pR2(x2,y2) ) \u2228\n( pR1(x1,y1) \u2227 ( py2=y1\u2227 px2=y2 \u2227\n\u2227\nz\u2208{y1,y2,x2} pP\u2217 \u03b62 (z)\n)) .\nThe proof of the following theorem is given in Appendix A:\nTheorem 5. (i) For any OMQ Q(x), the formulas qtw(x) and q \u2032 tw(x) are equivalent, and so q\u2032tw(x) is a PE-rewriting of Q(x) over complete data instances. (ii) Theorem 4 continues to hold for f\u25bdQ replaced by f H Q.\nFinally, we observe that although f\u25bdQ and f H Q are defined by exponential-size formulas, each of these functions can be computed by a nondeterministic polynomial algorithm (in the number of propositional variables). Indeed, given truth-values for the pS(z) and pt in f \u25bd\nQ, guess a set \u0398 of at most |q| tree witnesses and check whether (i) \u0398 is independent, (ii) pt = 1 for all t \u2208 \u0398, and (iii) every S(z) with pS(z) = 0 belongs to some t \u2208 \u0398. The function f H\nQ is computed similarly except that, in (ii), we check whether the polynomial-size formula (8) is true under the given truth-values for every t \u2208 \u0398."}, {"heading": "4.2 Primitive Evaluation Functions", "text": "To obtain lower bounds on the size of rewritings, we associate with every OMQ Q a third Boolean function f\u25b3Q that describes the result of evaluating Q on data instances with a single individual constant. Let \u03b3 \u2208 {0, 1}n be a vector assigning the truth-value \u03b3(Si) to each unary or binary predicate Si in Q. We associate with \u03b3 the data instance\nA(\u03b3) = { Ai(a) | \u03b3(Ai) = 1 } \u222a { Pi(a, a) | \u03b3(Pi) = 1 }\nand set f\u25b3Q(\u03b3) = 1 iff T ,A(\u03b3) |= q(a), where a is the |x|-tuple of as. We call f \u25b3 Q the primitive evaluation function for Q. Theorem 6. (i) If q\u2032 is a (PE-) FO-rewriting of Q, then f\u25b3Q can be computed by a (monotone) Boolean formula of size O(|q\u2032|).\n(ii) If q\u2032 is an NDL-rewriting of Q, then f\u25b3Q can be computed by a monotone Boolean circuit of size O(|q\u2032|).\nProof. (i) Let q\u2032 be an FO-rewriting of Q. We eliminate the quantifiers in q\u2032 by replacing each subformula of the form \u2203x\u03c8(x) and \u2200x\u03c8(x) in q\u2032 with \u03c8(a). We then replace each a = a with \u22a4 and each atom of the form A(a) and P (a, a) with the corresponding propositional variable. The resulting Boolean formula clearly computes f\u25b3Q. If q\n\u2032 is a PE-rewriting of Q, then the result is a monotone Boolean formula computing f\u25b3Q.\n(ii) If (\u03a0,G) is an NDL-rewriting of Q, then we replace all variables in \u03a0 with a and then perform the replacement described in (i). We now turn the resulting propositional NDL-program \u03a0 \u2032 into a monotone circuit computing f\u25b3Q. For every (propositional) variable p occurring in the head of a rule in \u03a0 \u2032, we take an appropriate number of or-gates whose output is p and inputs are the bodies of the rules with head p; for every such body, we introduce an appropriate number of and-gates whose inputs are the propositional variables in the body, or, if the body is empty, we take the gate for constant 1."}, {"heading": "4.3 Hypergraph Programs", "text": "We introduced hypergraph functions as Boolean abstractions of the tree-witness rewritings. Our next aim is to define a model of computation for these functions.\nA hypergraph program (HGP) P is a hypergraphH = (V,E) each of whose vertices is labelled by 0, 1 or a literal over a list p1, . . . , pn of propositional variables. (As usual, a literal, l, is a propositional variable or its negation.) An input for P is a tuple \u03b1 \u2208 {0, 1}n, which is regarded as a valuation for p1, . . . , pn. The output P (\u03b1) of P on \u03b1 is 1 iff there is an independent subset of E that covers all zeros\u2014that is, contains every vertex in V whose label evaluates to 0 under \u03b1. We say that P computes an n-ary Boolean function f if f(\u03b1) = P (\u03b1), for all \u03b1 \u2208 {0, 1}n. An HGP is monotone if its vertex labels do not have negated variables. The size |P | of an HGP P is the size |H | of the underlying hypergraph H = (V,E), which is |V |+ |E|.\nThe following observation shows that monotone HGPs capture the computational power of hypergraph functions. We remind the reader that a subfunction of a Boolean function f is obtained from f using two operations: (1) fixing some of its variables to 0 or 1, and (2) renaming (in particular, identifying) some of the variables in f . A hypergraph H is said to be of degree at most d if every vertex in it belongs to at most d hyperedges; H is of degree d if every vertex in it belongs to exactly d hyperedges.\nProposition 2. (i) Any monotone HGP based on a hypergraph H computes a subfunction of the hypergraph function fH .\n(ii) For any hypergraph H of degree at most d, there is a monotone HGP of size O(|H |) that computes fH and such that its hypergraph is of degree at most max(2, d).\nProof. To show (i), it is enough to replace the vertex variables pv in fH by the corresponding vertex labels of the given HGP and fix all the edge variables pe to 1.\nFor (ii), given a hypergraph H = (V,E), we label each v \u2208 V by the variable pv. For each e \u2208 E, we add a fresh vertex ae labelled by 1 and a fresh vertex be labelled by pe; then we create a new hyperedge e\u2032 = {ae, be} and add ae to the hyperedge e. We claim that the resulting HGP P computes fH . Indeed, for any input \u03b1 with \u03b1(pe) = 0, we have to include the edge e\n\u2032 into the cover, and so cannot include the edge e itself. Thus, P (\u03b1) = 1 iff there is an independent set E of hyperedges with \u03b1(pe) = 1, for all e \u2208 E, covering all zeros of the variables pv.\nIn some cases, it will be convenient to use generalised HGPs that allow hypergraph vertices to be labelled by conjunctions \u2227\ni li of literals li. The following proposition shows that this generalisation does not increase the computational power of HGPs.\nProposition 3. For every generalised HGP P over n variables, there is an HGP P \u2032 computing the same function and such that |P \u2032| \u2264 n \u00b7 |P |.\nProof. To construct P \u2032, we split every vertex v of P labelled with \u2227k\ni=1 li into k new vertices v1, . . . , vk and label vi with li, for 1 \u2264 i \u2264 k (without loss of generality, we can assume that li and lj have distinct variables for i 6= j); each hyperedge containing v will now contain all the vi. It is easy to see that P (\u03b1) = P \u2032(\u03b1), for any input \u03b1. Since k \u2264 n, we have |P \u2032| \u2264 n \u00b7 |P |."}, {"heading": "5 OMQs, hypergraphs and monotone hypergraph programs", "text": "We now establish a correspondence between the structure of OMQs and hypergraphs."}, {"heading": "5.1 OMQs with ontologies of depth 2", "text": "To begin with, we show that every hypergraph H = (V,E) can be represented by a polynomialsize OMQ QH = (T , q) with T of depth 2. With every vertex v \u2208 V we associate a unary predicate Av, and with every hyperedge e \u2208 E a unary predicate Be and a binary predicate Re. We define T to be the set of the following axioms, for e \u2208 E:\nBe(x) \u2192 \u2203y [ \u2227\ne\u2229e\u2032 6=\u2205, e6=e\u2032 Re\u2032(x, y) \u2227\n\u2227 v\u2208e Av(y) \u2227 \u2203z Re(z, y) ] .\nClearly, T is of depth 2. We also take the Boolean CQ q with variables yv, for v \u2208 V , and ze, for e \u2208 E:\nq = { Av(yv) | v \u2208 V } \u222a { Re(ze, yv) | v \u2208 e, for v \u2208 V and e \u2208 E } .\nExample 9. Consider again the hypergraph from Example 6, which we now denote byH = (V,E) with V = {v1, v2, v3}, E = {e1, e2}, e1 = {v1, v2} and e2 = {v2, v3}. The CQ q and the canonical models C Bei (a) T , for i = 1, 2, are shown in Fig. 9 along with four tree witnesses for QH (as explained in Remark 2, we ignore the two extra tree witnesses generated only by normalisation predicates).\nIt is not hard to see that the number of tree witnesses for QH does not exceed |H |. Indeed, all the tree witnesses for QH fall into two types:\ntv = (ti, tr) with tr = {ze | v \u2208 e} and ti = {yv}, for v \u2208 V that belong to a single e \u2208 E; te = (ti, tr) with tr = {ze\u2032 | e \u2229 e \u2032 6= \u2205, e 6= e\u2032} and ti = {ze} \u222a {yv | v \u2208 e}, for e \u2208 E.\nWe call a hypergraph H \u2032 a subgraph of a hypergraph H = (V,E) if H \u2032 can be obtained from H by (i) removing some of its hyperedges and (ii) removing some of its vertices from both V and the hyperedges in E.\nTheorem 7. (i) Any hypergraph H is isomorphic to a subgraph of H(QH). (ii) Any monotone HGP P based on a hypergraph H computes a subfunction of the primitive evaluation function f\u25b3QH .\nProof. (i) An isomorphism between H and a subgraph of H(QH) can be established by the map v 7\u2192 Av(yv), for v \u2208 V , and e 7\u2192 qte , for e \u2208 E.\n(ii) Suppose that P is based on a hypergraph H = (V,E). Given an input \u03b1 for P , we define an assignment \u03b3 for the predicates in QH = (T , q) by taking \u03b3(Av) to be the value of the label of v under \u03b1, \u03b3(Be) = 1, \u03b3(Re) = 1 (and of course \u03b3(P\u03b6) = 0, for all normalisation predicates P\u03b6). By the definition of T , for each e \u2208 E, the canonical model CT ,A(\u03b3) contains labelled nulls we and w \u2032 e such that\nCT ,A(\u03b3) |= \u2227\ne\u2229e\u2032 6=\u2205, e6=e\u2032 Re\u2032(a, we) \u2227\n\u2227 v\u2208e Av(we) \u2227 Re(w \u2032 e, we).\nWe now show that P (\u03b1) = 1 iff f\u25b3QH (\u03b3) = 1 (iff T ,A(\u03b3) |= q). Suppose P (\u03b1) = 1, that is, there is an independent subset E\u2032 \u2286 E such that the label of each v /\u2208 \u22c3 E\u2032 evaluates to 1 under \u03b1. Then the map h : q \u2192 CT ,A(\u03b3) defined by taking\nh(ze) =\n{\nw\u2032e, if e \u2208 E \u2032, a, otherwise, h(yv) =\n{\nwe, if v \u2208 e \u2208 E\u2032,\na, otherwise\nis a homomorphism witnessing CT ,A(\u03b3) |= q, whence f \u25b3 QH (\u03b3) = 1.\nConversely, if f\u25b3QH (\u03b3) = 1 then there is a homomorphism h : q \u2192 CT ,A(\u03b3). For any hyperedge e \u2208 E, there are only two options for h(ze): either a or w\u2032e. It follows that the set E\n\u2032 = {e \u2208 E | h(ze) = w \u2032 e} is independent and covers all zeros. Indeed, if v /\u2208 \u22c3 E\u2032 then h(yv) = a, and so the label of v evaluates to 1 under \u03b1 because Av(yv) \u2208 q.\nNext, we establish a tight correspondence between hypergraphs of degree at most 2 and OMQs with ontologies of depth 1."}, {"heading": "5.2 Hypergraphs of Degree 2 and OMQs with Ontologies of Depth 1", "text": "Theorem 8. For any OMQ Q = (T , q) with T of depth 1, the hypergraph H(Q) is of degree at most 2 and |H(Q)| \u2264 2|q|.\nProof. We have to show that every atom in q belongs to at most two q t , t \u2208 \u0398Q. Suppose t = (tr, ti) is a tree witness for Q and y \u2208 ti. Since T is of depth 1, ti = {y} and tr consists of all the variables in q adjacent to y in the Gaifman graph Gq of q. Thus, different tree witnesses have different internal variables y. An atom of the form A(u) \u2208 q is in q\nt iff u = y. An atom\nof the form P (u, v) \u2208 q is in q t iff either u = y or v = y. Therefore, P (u, v) \u2208 q can only be covered by the tree witness with internal u and by the tree witness with internal v.\nConversely, we show now that any hypergraph H of degree 2 is isomorphic to H(SH), for some OMQ SH = (T , q) with T of depth 1. We can assume that H = (V,E) comes with two fixed maps i1, i2 : V \u2192 E such that for every v \u2208 V , we have i1(v) 6= i2(v), v \u2208 i1(v) and v \u2208 i2(v). For any v \u2208 V , we fix a binary predicate Rv, and let the ontology T in SH contain the following axioms, for e \u2208 E:\nAe(x) \u2192 \u2203y [ \u2227\nv\u2208V i1(v)=e\nRv(y, x) \u2227 \u2227\nv\u2208V i2(v)=e\nRv(x, y) ] .\nClearly, T is of depth 1. The Boolean CQ q contains variables ze, for e \u2208 E, and is defined by taking\nq = { Rv(zi1(v), zi2(v)) | v \u2208 V } .\nExample 10. Suppose that H = (V,E), where V = {v1, v2, v3, v4}, E = {e1, e2, e3} and e1 = {v1, v2, v3}, e2 = {v3, v4}, e3 = {v1, v2, v4}. Let\ni1 : v1 7\u2192 e1, v2 7\u2192 e3, v3 7\u2192 e1, v4 7\u2192 e2,\ni2 : v1 7\u2192 e3, v2 7\u2192 e1, v3 7\u2192 e2, v4 7\u2192 e3.\nThe hypergraph H and the query q are shown in Fig. 10: each Rvk is represented by an edge, i1(vk) is indicated by the circle-shaped end of the edge and i2(vk) by the diamond-shaped end of the edge; the ej are shown as large grey squares. In this case,\nq = \u2203ze1 , ze2 , ze3 ( Rv1(ze1 , ze3) \u2227Rv2(ze3 , ze1) \u2227Rv3(ze1 , ze2) \u2227Rv4(ze2 , ze3) )\nand T consists of the following axioms:\nAe1(x) \u2192 \u2203y [ Rv1(y, x) \u2227Rv2(x, y) \u2227Rv3(y, x) ] , Ae2(x) \u2192 \u2203y [ Rv3(x, y) \u2227Rv4(y, x) ] , Ae3(x) \u2192 \u2203y [ Rv1(x, y) \u2227Rv2(y, x) \u2227Rv4(x, y) ] .\nThe canonical model C Ae1 (a) T is shown on the right-hand side of Fig. 10. Note that each ze determines the tree witness te with q te = {Rv(zi1(v), zi2(v)) | v \u2208 e}; distinct t e and te \u2032\nare conflicting iff e \u2229 e\u2032 6= \u2205. It follows that H is isomorphic to H(SH).\nTheorem 9. (i) Any hypergraph H of degree 2 is isomorphic to H(SH). (ii) Any monotone HGP P based on a hypergraph H of degree 2 computes a subfunction of the primitive evaluation function f\u25b3SH .\nProof. (i) We show that the map g : v 7\u2192 Rv(zi1(v), zi2(v)) is an isomorphism between H and H(SH). By the definition of SH , g is a bijection between V and the atoms of q. For any e \u2208 E, there is a tree witness te = (ter , t e i ) generated by Ae(x) with t e i = {ze} and ter = {ze\u2032 | e \u2229 e\n\u2032 6= \u2205, e 6= e\u2032}, and q\nte consists of the g(v), for v \u2208 e. Conversely, every tree witness t for SH contains\nze \u2208 ti, for some e \u2208 E, and so qt = {g(v) | v \u2208 e}.\n(ii) By Proposition 2 (i), P computes a subfunction of fH . Thus, it suffices to show that fH is a subfunction of f\u25b3SH . Let H = (V,E) be a hypergraph of degree 2. For any \u03b1 \u2208 {0, 1}\n|H|, we define \u03b3 by taking \u03b3(Rv) = \u03b1(pv) for v \u2208 V , \u03b3(Ae) = \u03b1(pe) for e \u2208 E (and \u03b3(P\u03b6) = 0 for all normalisation predicates P\u03b6). We prove that fH(\u03b1) = 1 iff T ,A(\u03b3) |= q. By the definition of T , for each e \u2208 E with Ae(a) \u2208 A(\u03b3) or, equivalently, \u03b1(pe) = 1, the canonical model CT ,A(\u03b3) contains a labelled null we such that\nCT ,A(\u03b3) |= \u2227\nv\u2208V i1(v)=e\nRv(we, a) \u2227 \u2227\nv\u2208V i2(v)=e\nRv(a, we).\n(\u21d2) Let E\u2032 be an independent subset of E such that \u2227 v\u2208V \\VE\u2032 pv \u2227 \u2227\ne\u2208E\u2032 pe is true on \u03b1. Define h : q \u2192 CT ,A(\u03b3) by taking h(ze) = a if e /\u2208 E\n\u2032 and h(ze) = we otherwise. One can check that h is a homomorphism, and so T ,A(\u03b3) |= q.\n(\u21d0) Given a homomorphism h : q \u2192 CT ,A(\u03b3), we show that E \u2032 = {e \u2208 E | h(ze) 6= a} is independent. Indeed, if e, e\u2032 \u2208 E\u2032 and v \u2208 e \u2229 e\u2032, then h sends one variable of the Rv-atom to the labelled null we and the other end to we\u2032 , which is impossible. We claim that fH(\u03b1) = 1. Indeed, for each v \u2208 V \\ VE\u2032 , h sends both ends of the Rv-atom to a, and so \u03b1(pv) = 1. For each e \u2208 E\u2032, we must have h(ze) = we because h(ze) 6= a, and so \u03b1(pe) = 1. It follows that fH(\u03b1) = 1."}, {"heading": "5.3 Tree-Shaped OMQs and Tree Hypergraphs", "text": "We call an OMQ Q = (T , q) tree-shaped if the CQ q is tree-shaped. We now establish a close correspondence between tree-shaped OMQs and tree hypergraphs that are defined as follows.11\nSuppose T = (VT , ET ) is an (undirected) tree. A leaf is a vertex of degree 1. A subtree T \u2032 = (V \u2032T , E \u2032 T ) of T is said to be convex if, for any non-leaf vertex u in the subtree T\n\u2032, we have {u, v} \u2208 E\u2032T whenever {u, v} \u2208 ET . A hypergraph H = (V,E) is called a tree hypergraph if there is a tree T = (VT , ET ) such that V = ET and every hyperedge e \u2208 E induces a convex subtree Te of T . In this case, we call T the underlying tree of H . The boundary of a hyperedge e consists of all leaves of Te; the interior of e is the set of non-leaves of Te. A tree hypergraph program (THGP) is an HGP based on a tree hypergraph.\nExample 11. Let T be the tree shown in Fig. 11. Any tree hypergraph with underlying tree T has the set of vertices {{1, 2}, {2, 3}, {2, 6}, {3, 4}, {4, 5}} (each vertex is an edge of T ), and its hyperedges may include {{1, 2}, {2, 3}, {2, 6}} as the subtree of T induced by these edges is convex, but not {{1, 2}, {2, 3}}.\nTheorem 10. If an OMQ Q = (T , q) is tree-shaped, then H(Q) is isomorphic to a tree hypergraph. Furthermore, if q has at least one binary atom, then the number of leaves in the tree underlying H(Q) is the same as the number of leaves in q."}, {"heading": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka", "text": "hypertree) from graph theory [28, 15, 16].\nProof. The case when q has no binary atoms is trivial. Otherwise, let Gq be the Gaifman graph of q whose vertices u are labelled with the unary atoms \u03be(u) in q of the form A(u) and P (u, u), and whose edges {u, v} are labelled with the atoms of the form P (u, v) and P \u2032(v, u) in q. We replace every edge {u, v} labelled with P1(u\u20321, v \u2032 1), . . . , Pn(u \u2032 n, v \u2032 n), for n \u2265 2, by a sequence of n edges forming a path from u to v and label them with P1(u \u2032 1, v \u2032 1), . . . , Pn(u \u2032 n, v \u2032 n), respectively. In the resulting tree, for every vertex u labelled with n unary atoms \u03be1(u), . . . , \u03ben(u), for n \u2265 1, we pick an edge {u, v} labelled with some P (u\u2032, v\u2032) and replace it by a sequence of n+ 1 edges forming a path from u to v and label them with \u03be1(u), . . . , \u03ben(u), P (u\n\u2032, v\u2032), respectively. The resulting tree T has the same number of leaves as q. It is readily checked that, for any tree witness t for Q, the set of edges in T labelled with atoms in q\nt forms a convex subtree of T ,\nwhich gives a tree hypergraph isomorphic to H(Q).\nSuppose H = (V,E) is a tree hypergraph whose underlying tree T = (VT , ET ) has vertices VT = {1, . . . , n}, for n > 1, and 1 is a leaf of T . Let T 1 = (VT , E1T ) be the directed tree obtained from T by fixing 1 as the root and orienting the edges away from 1. We associate with H a tree-shaped OMQ TH = (T , q), in which q is the Boolean CQ\nq = { Rij(zi, yij), Sij(yij , zj) | (i, j) \u2208 E 1 T } ,\nwhere the zi, for i \u2208 VT , are the variables for vertices of the tree and the yij , for (i, j) \u2208 E 1 T , are the variables for the edges of the tree. To define T , suppose a hyperedge e \u2208 E induces a convex directed subtree Te = (Ve, Ee) of T\n1 with root re \u2208 Ve and leaves Le \u2286 Ve. Denote by T the ontology that contains the following axiom, for each e \u2208 E:\nAe(x) \u2192 \u2203y [ \u2227\n(i,j)\u2208Ee, i=re Rrej(x, y) \u2227\n\u2227\n(i,j)\u2208Ee, j\u2208Le Sij(y, x) \u2227\n\u2203z ( \u2227\n(i,j)\u2208Ee, i6=re Rij(z, y) \u2227\n\u2227\n(i,j)\u2208Ee, j /\u2208Le Sij(y, z)\n)] .\nSince Te is convex, its root, re, has only one outgoing edge, (r e, j), for some j, and so the first conjunct above contains a single atom, Rrej(x, y). These axioms (together with convexity of hyperedges) ensure that TH has a tree witness t e = (ter , t e i ), for e \u2208 E, with\nt e r = { zi | i is on the boundary of e }, t e i = { zi | i is in the interior of e } \u222a { yij | (i, j) \u2208 e }.\nNote that T is of depth 2, and TH is of polynomial size in |H |.\nExample 12. Let H be the tree hypergraph whose underlying tree is as in Example 11 with fixed root 1 and whose only hyperedge is e = {{1, 2}, {2, 3}, {3, 4}, {2, 6}}. The CQ q and the canonical model CAe(a)T for this H are shown in Fig. 12. Note the homomorphism from qte into CAe(a)T .\nThe proofs of the following results (which are THGP analogues of Theorem 7 and Propositions 2 (ii) and 3, respectively) are given in Appendices B and C:\nTheorem 11. (i) Any tree hypergraph H is isomorphic to a subgraph of H(TH). (ii) Any monotone THGP based on a tree hypergraph H computes a subfunction of the primitive evaluation function f\u25b3TH .\nProposition 4. (i) For any tree hypergraph H of degree at most d, there is a monotone THGP of size O(|H |) that computes fH and such that its hypergraph is of degree at most max(2, d).\n(ii) For every generalised THGP P over n variables, there is a THGP P \u2032 such that |P \u2032| \u2264 n \u00b7 |P | and P \u2032 has the same degree and number of leaves as P and computes the same function."}, {"heading": "5.4 OMQs with Bounded Treewidth CQs and Bounded Depth Ontologies", "text": "Recall (see, e.g., [29]) that a tree decomposition of an undirected graph G = (V,E) is a pair (T, \u03bb), where T is an (undirected) tree and \u03bb a function from the set of nodes of T to 2V such that\n\u2013 for every v \u2208 V , there exists a node N with v \u2208 \u03bb(N);\n\u2013 for every e \u2208 E, there exists a node N with e \u2286 \u03bb(N);\n\u2013 for every v \u2208 V , the nodes {N | v \u2208 \u03bb(N)} induce a (connected) subtree of T .\nWe call the set \u03bb(N) \u2286 V a bag for N . The width of a tree decomposition (T, \u03bb) is the size of its largest bag minus one. The treewidth of G is the minimum width over all tree decompositions of G. The treewidth of a CQ q is the treewidth of its Gaifman graph Gq.\nExample 13. The Boolean CQ q = { R(y2, y1), R(y4, y1), S1(y3, y4), S2(y2, y4) } and its tree decomposition (T, \u03bb) of width 2 are shown in Fig. 13, where T has two nodes, N1 and N2, connected by an edge, with bags \u03bb(N1) = {y1, y2, y4} and \u03bb(N2) = {y2, y3, y4}.\nOur aim in this section is to show that, for any OMQ Q(x) = (T , q(x)) with q of bounded treewidth and a finite fundamental set \u2126Q, the modified tree-witness hypergraph function f H\nQ\ncan be computed using a monotone THGP of size bounded by a polynomial in |q| and |\u2126Q|. Let (T, \u03bb) be a tree decomposition of Gq of width m\u2212 1. In order to refer to the variables of q, for each bag \u03bb(N), we fix an order of variables in the bag and define a injection \u03bdN : \u03bb(N) \u2192 {1, . . . ,m} that gives the index of each z in \u03bb(N). A (bag) type is an m-tuple of the form w = (w[1], . . . ,w[m]), where each w[i] \u2208 \u2126Q. Intuitively, the ith component w[i] of w indicates that the ith variable in the bag is mapped to a domain element of the form aw[i] in the canonical model CT ,A. We say that a type w is compatible with a node N of T if the following conditions hold, for all z, z\u2032 \u2208 \u03bb(N):\n(1) if A(z) \u2208 q and w[\u03bdN (z)] 6= \u03b5, then w[\u03bdN (z)] = w\u033a and T |= \u2203y \u033a(y, x) \u2192 A(x); (2) if P (z, z\u2032) \u2208 q and either w[\u03bdN (z)] 6= \u03b5 or w[\u03bdN (z\u2032)] 6= \u03b5, then\n\u2013 w[\u03bdN (z)] = w[\u03bdN (z \u2032)] and T |= P (x, x), or \u2013 w[\u03bdN (z \u2032)] = w[\u03bdN (z)]\u033a and T |= \u033a(x, y) \u2192 P (x, y), or\n\u2013 w[\u03bdN (z)] = w[\u03bdN (z \u2032)]\u033a\u2212 and T |= \u033a(x, y) \u2192 P (y, x).\nClearly, the type with all components equal to \u03b5 is compatible with any node N and corresponds to mapping all variables in \u03bb(N) to individuals in ind(A).\nExample 14. Suppose T = {A(x) \u2192 \u2203y R(x, y) } and q is the same as in Example 13. Let \u03bdN1 and \u03bdN2 respect the order of the variables in the bags shown in Fig. 13. The only types compatible with N1 are (\u03b5, \u03b5, \u03b5) and (R, \u03b5, \u03b5), whereas the only type compatible with N2 is (\u03b5, \u03b5, \u03b5).\nLet w1, . . . ,wM be all the bag types for \u2126Q (M = |\u2126Q|m). Denote by T \u2032 the tree obtained from T by replacing every edge {Ni, Nj} with the following sequence of edges:\n{Ni, u 1 ij}, {u k ij , v k ij} and {v k ij , u k+1 ij }, for 1 \u2264 k < M, {u M ij , v M ij }, {v M ij , v M ji },\n{vMji , u M ji }, {u k+1 ji , v k ji} and {v k ji, u k ji}, for 1 \u2264 k < M, {u 1 ji, Nj},\nfor some fresh nodes ukij , v k ij , u k ji and v k ji. We now define a generalised monotone THGP PQ based on a hypergraph with the underlying tree T \u2032. Denote by [L] the set of nodes of the minimal convex subtree of T \u2032 containing all nodes of L. The hypergraph has the following hyperedges:\n\u2013 Eki = [Ni, u k ij1 , . . . , u k ijn ] if Nj1 , . . . , Njn are the neighbours of Ni in T and wk is compatible\nwith Ni; \u2013 Ek\u2113ij = [v k ij , v \u2113 ji] if {Ni, Nj} is an edge in T and (wk,w\u2113) is compatible with (Ni, Nj) in the\nsense that wk[\u03bdNi(z)] = w\u2113[\u03bdNj (z)], for all z \u2208 \u03bb(Ni) \u2229 \u03bb(Nj).\nWe label the vertices of the hypergraph\u2014that is, the edges of T \u2032\u2014in the following way. The edges {Ni, u1ij}, {v k ij , u k+1 ij } and {v M ij , v M ji } are labelled with 0, and every edge {u k ij , v k ij} is labelled with the conjunction of the following variables:\n\u2013 pS(z), whenever S(z) \u2208 q, z \u2286 \u03bb(Ni) and wk[\u03bdNi(z)] = \u03b5, for all z \u2208 z; \u2013 p\u033a\u2217(z), whenever A(z) \u2208 q, z \u2208 \u03bb(Ni) and wk[\u03bdNi(z)] = \u033aw; \u2013 p\u033a\u2217(z), p\u033a\u2217(z\u2032) and pz=z\u2032 , whenever R(z, z\n\u2032) \u2208 q (possibly with z = z\u2032), z, z\u2032 \u2208 \u03bb(Ni), and either wk[\u03bdNi(z)] = \u033aw or wk[\u03bdNi(z \u2032)] = \u033aw.\nThe following result is proved in Appendix D:\nTheorem 12. For every OMQ Q = (T , q) with a fundamental set \u2126Q and with q of treewidth t, the generalised monotone THGP PQ computes f H Q and is of size polynomial in |q| and |\u2126Q| t.\nExample 15. Let Q = (T , q) be the OMQ from Example 14. As we have seen, there are only two types compatible with nodes in T : w1 = (\u03b5, \u03b5, \u03b5) and w2 = (R, \u03b5, \u03b5). This gives us the generalised THGP PQ shown in Fig. 14, where the omitted labels are all 0. To explain the meaning of PQ, suppose T ,A |= q, for some data instance A. Then there is a homomorphism h : q \u2192 CT ,A. This homomorphism defines the type of bag N1, which can be either w1 (if h(z) \u2208 ind(A) for all z \u2208 \u03bb(N1)) or w2 (if h(y1) = aR for some a \u2208 ind(A)). These two cases are represented by the hyperedges E11 = [N1, u 1 12] and E 2 1 = [N1, u 2 12]. Since {N1, u 1 12} is labelled with 0, exactly one of them must be chosen to construct an independent subset of hyperedges covering all zeros. In contrast to that, there is no hyperedge E22 because w2 is not compatible with N2, and so E 1 2 = [u 1 21, N2] must be present in every covering of all zeros. Both (w1,w1) and (w2,w1) are compatible with (N1, N2), which gives E 11 12 = [v 1 12, v 1 21] and E 21 12 = [v 2 12, v 1 21]. Thus, if N1 is of type w1, then we include E 1 1 and E 11 12 in the covering of all zeros, and so pR(y4,y1) \u2227 pR(y2,y1) should hold. If N1 is of type w2, then instead of E 11 12 , we take E 21 12 , and so py4=y1 \u2227 py2=y1 \u2227 pR\u2217(y1) \u2227 pR\u2217(y2) \u2227 pR\u2217(y4) should be true. Finally, since {v 1 21, u 1 21} does not belong to any hyperedge, pS1(y4,y3) \u2227 pS2(y2,y3) must hold in either case."}, {"heading": "5.5 Summary", "text": "In Tables 1 and 2, we summarise the results of Section 5 that will be used in Section 7 to obtain lower and upper bounds for the size of OMQ rewritings. Table 1 shows how Theorems 8 and 10 (on the shape of tree-witness hypergraphs) combined with Proposition 2 (ii), as well as Theorem 12 provide us with hypergraph programs computing tree-witness hypergraph functions for OMQs. Table 2 contains the representation results of Theorems 7, 9 and 11 that show how abstract hypergraphs can be embedded into tree-witness hypergraphs of OMQs."}, {"heading": "6 Hypergraph Programs and Circuit Complexity", "text": "In the previous section, we saw how different classes of OMQs gave rise to different classes of monotone HGPs. Here we characterise the computational power of HGPs in these classes by relating them to standard models of computation for Boolean functions. Table 3 shows some of the obtained results. For example, its first row says that any Boolean function computable by a polynomial-size nondeterministic circuit can also be computed by a polynomial-size HGP of degree at most 3, and the other way round.\nWe remind the reader that the complexity classes in the table form the chain\n\u03a03 $ AC 0 $ NC1 \u2286 NL/poly \u2286 LOGCFL/poly \u2286 P/poly \u2286 NP/poly (9)\nand that whether any of the non-strict inclusions is actually strict remains a major open problem in complexity theory; see, e.g., [3, 42]. All these classes are non-uniform in the sense that they are defined in terms of polynomial-size non-uniform sequences of Boolean circuits of certain shape and depth. The suffix \u2018/poly\u2019 comes from an alternative definition of C/poly in terms of Turing machines for the class C with an additional advice input of polynomial size.\nWhen talking about complexity classes, instead of individual Boolean functions, we consider sequences of functions f = {fn}n<\u03c9 with fn : {0, 1}n \u2192 {0, 1}. The same concerns circuits, HGPs and the other models of computation we deal with. For example, we say that a circuit C = {Cn}n<\u03c9 computes a function f = {fn}n<\u03c9 if Cn computes fn for every n < \u03c9. (It will always be clear from context whether f , C, etc. denote an individual function, circuit, etc. or a sequence thereof.) A circuit C is said to be polynomial if there is a polynomial p : N \u2192 N such that |Cn| \u2264 p(n), for every n < \u03c9. The depth of Cn is the length of the longest directed path from an input to the output of Cn.\nThe complexity class P/poly can be defined as comprising those Boolean functions that are computed by polynomial circuits, and NC1 consists of functions computed by polynomial formulas (that is, circuits every logic gate in which has at most one output). Alternatively, a Boolean function is in NC1 iff it can be computed by a polynomial-size circuit of logarithmic depth, whose and- and or-gates have two inputs.\nLOGCFL/poly (also known as SAC1) is the class of Boolean functions computable by polynomialsize and logarithmic-depth circuits in which and-gates have two inputs but or-gates can have arbitrarily many inputs (unbounded fan-in) and not-gates can only be applied to inputs of the circuit [76]. AC0 is the class of functions computable by polynomial-size circuits of constant depth with and- and or-gates of unbounded fan-in and not-gates only at the inputs; \u03a03 is the subclass of AC0 that only allows circuits of depth 3 (not counting the not-gates) with an output and-gate.\nFinally, a Boolean function f = {fn}n<\u03c9 is in the class NP/poly if there is a polynomial p and a polynomial circuit C = {Cn+p(n)}n<\u03c9 such that, for any n and \u03b1 \u2208 {0, 1} n,\nfn(\u03b1) = 1 iff there is \u03b2 \u2208 {0, 1} p(n) such that Cn+p(n)(\u03b1,\u03b2) = 1 (10)\n(the \u03b2-inputs are sometimes called certificate inputs). By allowing only monotone circuits or formulas in the definitions of the complexity classes, we obtain their monotone variants: for example, the monotone variant of NP/poly is denoted by mNP/poly and defined by restricting the use of not-gates in the circuits to the certificate inputs only. We note in passing that the monotone variants of the classes in (9) also form a chain [64,"}, {"heading": "2, 44]:", "text": "m\u03a03 $ mAC 0 $ mNC1 $ mNL/poly \u2286 mLOGCFL/poly $ mP/poly $ mNP/poly. (11)\nWhether the inclusion mNL/poly \u2286 mLOGCFL/poly is proper remains an open problem. We use these facts in the next section to show lower bounds on the size of OMQ rewritings.\n6.1 NP/poly and HGP3\nOur first result shows that NP/poly and mNP/poly coincide with the classes HGP3 and mHGP3 of Boolean functions computable by polynomial-size (sequences of) HGPs and monotone HGPs of degree at most 3, respectively.\nTheorem 13. NP/poly = HGP = HGP3 and mNP/poly = mHGP = mHGP3.\nProof. Suppose P is a (monotone) HGP. We construct a non-deterministic circuit C of size polynomial in |P |, whose input variables are the same as the variables in P , certificate inputs correspond to the hyperedges of P , and such that C(\u03b1,\u03b2) = 1 iff {ei | \u03b2(ei) = 1} is an independent set of hyperedges covering all zeros under \u03b1. It will then follow that\nP (\u03b1) = 1 iff there is \u03b2 such that C(\u03b1,\u03b2) = 1. (12)\nFirst, for each pair of intersecting hyperedges ei, ej in P , we take the disjunction \u00acei \u2228 \u00acej , and, for each vertex in P labelled with a literal l (that is, p or \u00acp) and the hyperedges ei1 , . . . , eik incident to it, we take the disjunction l\u2228ei1 \u2228\u00b7 \u00b7 \u00b7\u2228eik . The circuit C is then a conjunction of all such disjunctions. Note that if P is monotone, then \u00ac is only applied to the certificate inputs, e, in C.\nConversely, let C be a circuit with certificate inputs. We construct an HGP P of degree at most 3 satisfying (12) as follows. For each gate gi in C, the HGP contains a vertex gi labelled with 0 and a pair of hyperedges e\u0304i and ei, both containing gi. No other hyperedge contains gi, and so either e\u0304i or ei should be present in any cover of zeros. To ensure this property, for each gate gi, we add the following vertices and hyperedges to P (see Fig. 15):\n\u2013 if gi is an input p, then we add a vertex labelled with \u00acp to ei and a vertex labelled with p to e\u0304i; \u2013 if gi is a certificate input, then no additional vertices and hyperedges are added; \u2013 if gi = \u00acgj , then we add a vertex labelled with 1 to hyperedges ei and e\u0304j, and a vertex labelled with 1 to hyperedges e\u0304i and ej; \u2013 if gi = gj \u2228 gk, then we add a vertex labelled with 1 to hyperedges ej and e\u0304i, add a vertex labelled with 1 to ek and e\u0304i; then, we add vertices vj and vk labelled with 1 to e\u0304j and e\u0304k, respectively, and a vertex ui labelled with 0 to e\u0304i; finally, we add hyperedges {vj , ui} and {vk, ui} to P ; \u2013 if gi = gj \u2227 gk, then we add the pattern dual to the case of gi = gj \u2228 gk: we add a vertex labelled with 1 to e\u0304j and ei, a vertex labelled with 1 to e\u0304k and ei; then, we add vertices vj and vk labelled with 1 to ej and ek, respectively, and a vertex ui labelled with 0 to ei; finally, we add hyperedges {vj, ui} and {vk, ui} to P .\nFinally, we add one more vertex labelled with 0 to em for the output gate gm of C, which ensures that em must be included the cover. It is easily verified that the constructed HGP is of degree at most 3. One can establish (12) by induction on the structure of C. We illustrate the proof of the inductive step for the case of gi = gj \u2228 gk: we show that ei is in the cover iff it contains either ej or ek. Suppose the cover contains ej. Then it cannot contain e\u0304i, and so it contains ei. The vertex ui in this case can be covered by {vj , ui} since e\u0304j is not in the cover. Conversely, if neither ej nor ek is in the cover, then it must contain both e\u0304j and e\u0304k, and so neither {vj, ui} nor {vk, ui} can belong to the cover, and thus we will have to include e\u0304i to the cover.\nIf C is monotone, then we remove from P all vertices labelled with \u00acp, for an input p, and denote the resulting program by P \u2032. We claim that, for any \u03b1, we have P \u2032(\u03b1) = 1 iff there is \u03b2 such that C(\u03b1,\u03b2) = 1. The implication (\u21d0) is trivial: if C(\u03b1,\u03b2) = 1 then, by the argument above, P (\u03b1) = 1 and, clearly, P \u2032(\u03b1) = 1. Conversely, suppose P \u2032(\u03b1) = 1. Each of the vertices gi in P\n\u2032 corresponding to the inputs is covered by one of the hyperdges ei or e\u0304i. Let \u03b1\u2032 be the vector corresponding to these hyperedges; clearly, \u03b1\u2032 \u2264 \u03b1. This cover of vertices of P \u2032 gives us P (\u03b1\u2032) = 1. Thus, by the argument above, there is \u03b2 such that C(\u03b1\u2032,\u03b2) = 1. Since C is monotone, C(\u03b1,\u03b2) = 1.\n6.2 NL/poly and HGP2\nA Boolean function belongs to the class NL/poly iff it can be computed by a polynomial-size nondeterministic branching program (NBP). We remind the reader (consult [42] for more details)\nthat an NBP B is a directed graph G = (V,E), whose arcs are labelled with the Boolean constants 0 and 1, propositional variables p1, . . . , pn or their negations, and which distinguishes two vertices s, t \u2208 V . Given an assignment \u03b1 to variables p1, . . . , pn, we write s \u2192\u03b1 t if there is a path in G from s to t all of whose labels evaluate to 1 under \u03b1. We say that an NBP B computes a Boolean function f if f(\u03b1) = 1 iff s \u2192\u03b1 t, for any \u03b1 \u2208 {0, 1}n. The size |B| of B is the size of the underlying graph, |V |+ |E|. An NBP is monotone if there are no negated variables among its labels. The class of Boolean functions computable by polynomial-size monotone NBPs is denoted by mNL/poly; the class of functions f whose duals f\u2217(p1, . . . , pn) = \u00acf(\u00acp1, . . . ,\u00acpn) are in mNL/poly is denoted by co-mNL/poly.\nTheorem 14. NL/poly = HGP2 and co-mNL/poly = mHGP2.\nProof. As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then \u00acf is also computable by a polynomial-size NBP. So suppose \u00acf is computed by an NBP B. We construct an HGP P computing f of degree at most 2 and polynomial size in |B| as follows (see Fig. 16). For each arc e in B, the HGP P has two vertices e0 and e1, which represent the beginning and the end of e, respectively. The vertex e0 is labelled with the negated label of e in B and e1 with 1. For each arc e in B, the HGP P has an e-hyperedge {e0, e1}. For each vertex v in B but s and t, the HGP P has a v-hyperedge comprising all vertices e1 for the arcs e leading to v, and all vertices e0 for the arcs e leaving v. We also add to the HGP P a vertex w labelled with 0 and a hyperedge, e\u0304w, that consists of w and all vertices e\n1 for the arcs e in B leading to t. We claim that the constructed HGP P computes f . Indeed, if s 6\u2192\u03b1 t then the following subset of hyperedges is independent and covers all zeros: all e-hyperedges, for the arcs e reachable from s and labelled with 1 under \u03b1, and all v-hyperedges with s 6\u2192\u03b1 v (including e\u0304w). Conversely, if s \u2192\u03b1 t then one can show by induction that, for each arc e of the path, the e-hyperedge must be in the cover of all zeros. Thus, no independent set can cover w, which is labelled with 0.\nConversely, suppose f is computed by an HGP P of degree 2 with hyperedges e1, . . . , ek. We first provide a graph-theoretic characterisation of independent sets covering all zeros based on the implication graph [5]. With every hyperedge ei we associate a propositional variable ui and with every assignment \u03b1 we associate the following set \u03a6\u03b1 of propositional binary clauses:\n\u00acui \u2228 \u00acuj , if ei \u2229 ej 6= \u2205,\nui \u2228 uj, if there is v \u2208 ei \u2229 ej with \u03b1(v) = 0.\nInformally, the former means that intersecting hyperedges cannot be chosen at the same time and the latter that all zeros must be covered; note that all vertices have at most two incident edges. By definition, X is an independent set covering all zeros iff X = {ei | \u03b3(ui) = 1}, for some assignment \u03b3 satisfying \u03a6\u03b1. Let C\u03b1 = (V,E\u03b1) be the implication graph of \u03a6\u03b1, that is, a directed graph with\nV = { ui, u\u0304i | 1 \u2264 i \u2264 k } ,\nE\u03b1 = { (ui, u\u0304j) | ei \u2229 ej 6= \u2205 } \u222a { (u\u0304i, uj) | there is v \u2208 ei \u2229 ej with \u03b1(v) = 0 } .\n(V is the set of all \u2018literals\u2019 for the variables of \u03a6\u03b1 and E\u03b1 is the arcs for the implicational form of the clauses of \u03a6\u03b1.) Note that \u00acui\u2228\u00acuj gives rise to two implications, ui \u2192 \u00acuj and uj \u2192 \u00acui, and so to two arcs in the graph; similarly, for ui\u2228uj. By [5, Theorem 1], \u03a6\u03b1 is satisfiable iff there\nis no ui with a (directed) cycle going through ui and u\u0304i. It will be convenient for us to regard the C\u03b1, for assignments \u03b1, as a single labelled directed graph C with arcs of the form (ui, u\u0304j) labelled with 1 and arcs of the form (u\u0304i, uj) labelled with the negation of the literal labelling the uniquely defined v \u2208 ei \u2229 ej (recall that the hypergraph of P is of degree 2). It should be clear that C\u03b1 has a cycle going through ui and u\u0304i iff we have both u\u0304i \u2192\u03b1 ui and ui \u2192\u03b1 u\u0304i in C. The required NBP B contains distinguished vertices s and t, and, for each hyperedge ei in P , two copies, C0i and C 1 i , of C with additional arcs from s to the u\u0304i vertex of C 0 i , from the ui vertex of C0i to the ui vertex of C 1 i , and from the u\u0304i vertex of C 1 i to t; see Fig. 17. By construction, s \u2192\u03b1 t iff there is a hyperedge ei in P such that C\u03b1 contains a cycle going through ui and u\u0304i. We have thus constructed a polynomial-size NBP B computing \u00acf , and thus f must also be computable by a polynomial-size NBP.\nAs to co-mNL/poly = mHGP2, observe that the first construction, if applied to a monotone NBP for f\u2217, produces a polynomial-size HGP of degree 2 computing \u00acf\u2217, all of whose labels are negative. By removing negations from labels, we obtain a monotone HGP computing f . The second construction allows us to transform a monotone HGP of degree 2 for f into an NBP with only negative literals that computes \u00acf . By changing the polarity of the literals in the labels, we obtain a monotone NBP computing f\u2217."}, {"heading": "6.3 NL/poly and THGP(\u2113)", "text": "For any natural \u2113 \u2265 2, we denote by THGP(\u2113) and mTHGP(\u2113) the classes of Boolean functions computable by (sequences of) polynomial-size THGPs and, respectively, monotone THGPs whose underlying trees have at most \u2113 leaves.\nTheorem 15. NL/poly = THGP(\u2113) and mNL/poly = mTHGP(\u2113), for any \u2113 \u2265 2.\nProof. Suppose a polynomial-size THGP P computes a Boolean function f . For simplicity, we consider only \u2113 = 2 here and prove the general case in Appendix E. Thus, we can assume that the vertices v1, . . . , vn of P are consecutive edges of the path graph underlying P , and therefore, every hyperedge in P is of the form [vi, vi+m] = {vi, . . . , vi+m}, for somem \u2265 0. We add to P two extra vertices, v0 and vn+1 (thereby extending the underlying 2-leaf tree to v0, v1, . . . , vn, vn+1) and label them with 0; we also add two hyperedges s = {v0} and t = {vn+1} to P . Clearly, the resulting THGP P \u2032 computes the same f . To construct a polynomial-size NBP B computing f , we take a directed graph whose vertices are hyperedges of P \u2032 and which contains an arc from ei = [vi1 , vi2 ] to ej = [vj1 , vj2 ] iff i2 < j1; we label this arc with \u2227 i2<k<j1 lk, where lk is the label of vk in HGP P . It is not hard to see that a path from s to t evaluated to 1 under given assignment \u03b1 corresponds to a cover of zeros in P \u2032 under \u03b1. Finally, to get rid of conjunctive labels on edges, we replace every arc with a label li1\u2227\u00b7 \u00b7 \u00b7\u2227lik by a sequence of k arcs consequently labelled with li1 , . . . , lik .\nConversely, suppose a Boolean function f is computed by an NBP B based on a directed graph with vertices V = {v1, . . . , vn}, edges E = {e1, . . . , em}, s = v1 and t = vn. Without loss of generality, we assume that em is a loop from t to t labelled with 1. Thus, if there is a path from s to t whose labels evaluate to 1, then there is such a path of length n \u2212 1. We now construct a polynomial-size THGP computing f whose underlying tree T has two leaves. The vertices of the tree T are arranged into n vertex blocks and n \u2212 1 edge blocks, which alternate. The kth vertex (edge) block contains two copies vki , v\u0304 k i (respectively, e k i , e\u0304 k i ) of every vi \u2208 V (respectively, ei \u2208 E):\nv11 , v\u0304 1 1 , v 1 2 , v\u0304 1 2 , . . . , v 1 n, v\u0304 1 n, \ufe38 \ufe37\ufe37 \ufe38\n1st vertex block\ne11, e\u0304 1 1, e 1 2, e\u0304 1 2, . . . , e 1 m, e\u0304 1 m, \ufe38 \ufe37\ufe37 \ufe38\n1st edge block\nv21 , v\u0304 2 1 , v 2 2 , v\u0304 2 2 , . . . , v 2 n, v\u0304 2 n, \ufe38 \ufe37\ufe37 \ufe38\n2nd vertex block\n. . .\nen\u221211 , e\u0304 n\u22121 1 , e n\u22121 2 , e\u0304 n\u22121 2 , . . . , e n\u22121 m , e\u0304 n\u22121 m , \ufe38 \ufe37\ufe37 \ufe38\n(n \u2212 1)th edge block\nvn1 , v\u0304 n 1 , v n 2 , v\u0304 n 2 , . . . , v n n , v\u0304 n n \ufe38 \ufe37\ufe37 \ufe38\nnth vertex block\n.\nWe remove the first, v11 , and last vertex, v\u0304 n n (shown in grey in the formula above), and connect the adjacent vertices by edges to construct the undirected tree T . Consider now a hypergraph H whose vertices are the edges of T and hyperedges are of the form hki = [v\u0304 k j , e k i ] and g k i = [e\u0304 k i , v k+1 j\u2032 ], for ei = (vj , vj\u2032 ) \u2208 E and 1 \u2264 k < n. The vertices of H of the form {eki , e\u0304 k i }, which separate hyperedges hki and g k i , are labelled with the label of ei in the given NBP B, and all other vertices of H with 0. We show now that the constructed THGP P computes f . Indeed, if f(\u03b1) = 1, then there is a path ei1 , . . . , ein\u22121 from v1 to vn whose labels evaluate to 1 under \u03b1. It follows that {hkik , g k ik\n| 1 \u2264 k < n} is an independent set in H covering all zeros. Conversely, if E\u2032 is an independent set in H and covers all zeros under \u03b1, then it must contain exactly one pair of hyperedges hkik and g k ik for every k with 1 \u2264 k < n, and the corresponding sequence of edges ei1 , . . . , ein\u22121 defines a path from v1 to vn. Moreover, since E \u2032 does not cover vertices {ekik , e\u0304 k ik }, for 1 \u2264 k < n, their labels (that is, the labels of the eik in B) evaluate to 1 under \u03b1.\nTo prove Theorem 25 below, we shall require a somewhat different variant of Theorem 15. The proof of the following result is given in Appendix E:\nTheorem 16. Fix \u2113 \u2265 2. For any tree hypergraph H based on a tree with at most \u2113 leaves, the function fH can be computed by an NBP of size polynomial in |H |.\nNote that Theorem 16 does not immediately follow from Theorem 15 and Proposition 4 (i) because the transformation of H into a monotone HGP computing fH given in the proof of Proposition 4 (i) does not preserve the number of leaves."}, {"heading": "6.4 LOGCFL/poly and THGP", "text": "THGP and mTHGP are the classes of functions computable by polynomial-size THGPs and, respectively, monotone THGPs.\nTheorem 17. LOGCFL/poly = THGP and mLOGCFL/poly = mTHGP.\nProof. To show LOGCFL/poly \u2286 THGP, consider a SAC1-circuit C of depth d \u2264 log |C|. It will be convenient to think of C as containing no not-gates but having literals as inputs. By the and-depth of a gate g in C we mean the maximal number of and-gates in a path from an input of C to g (it does not exceed d). Let Sn be the set of and-gates in C of and-depth n. We denote\nby left(g) and right(g) the sub-circuits of C computing the left and right inputs of an and-gate g, respectively. Without loss of generality (see Lemma 2 in Appendix F) we can assume that, for any n \u2264 d,\n\u22c3\ng\u2208Sn left(g) \u2229\n\u22c3\ng\u2208Sn right(g) = \u2205.\nOur aim is to transform C into a polynomial-size THGP P . We construct its underlying tree T by associating with each gate gi three vertices ui, vi, wi and arranging them into a tree as shown in Fig. 18. More precisely, we first arrange the vertices associated with the gates of maximal and-depth, n, into a path following the order of the gates in C and the alphabetic order for ui, vi, wi. Then we fork the path into two branches one of which is associated with the sub-circuit\u22c3\ng\u2208Sn left(g) and the other with \u22c3\ng\u2208Sn right(g), and so forth. We obtain the tree T by removing the vertex wm from the result, where m = |C| and gm is the output gate of C; it has vm as its root and contains 3|C| \u2212 1 vertices. The THGP P is based on the hypergraph whose vertices are the edges of T and whose hyperedges comprise the following (see Fig. 18):\n\u2013 [wi, ui], for each i < m (pairs of edges in each triple of vertices in Fig. 18); \u2013 [vj , vk, vi], for each gi = gj \u2227 gk (shown in Fig. 18 by shading); \u2013 [vj1 , vi], . . . , [vjk , vi], for each gi = gj1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 gjk ,\nwhere [L] is the minimal convex subtree of T containing the vertices in L. Finally, if an input gate gi is a literal l, we label the edge {ui, vi} with l; we label all other {uj, vj}- and {wj, vj}-edges with 0, and the remaining ones with 1. Clearly, the size of P is polynomial in |C|. By Lemma 3, for any input \u03b1, the output of gi is 1 iff the subtree with root vi can be covered, i.e., there is an independent set of hyperedges wholly inside and covering all zeros. Thus, P computes the same function as C.\nTo show THGP \u2286 LOGCFL/poly, suppose a THGP P is based on a hypergraph H with an underlying tree T . By a subtree of T we understand a (possibly empty) connected subset of edges in T . Given an input \u03b1 for P and a nonempty subtree D of T , we set coverD true iff there exists an independent subset of hyperedges in H that lie in D and cover all zeros in D. We also set cover\u2205 true. Note that, for any edge e of T , cover{e} is true if {e} is a hyperedge of H ; otherwise cover{e} is the value of e\u2019s label in P under \u03b1.\nOur aim is to construct recursively a polynomial-size SAC1-circuit C computing the function coverT . Observe that, if D is a subtree of T and a vertex v splits D into subtrees D1, . . . , Dk, then\ncoverD = \u2227\n1\u2264j\u2264k coverDj \u2228\n\u2228\nv\u2208h\u2286D\n\u2227\n1\u2264j\u2264kh coverDh j , (13)\nwhere h ranges over the hyperedges in H , and Dh1 , . . . , D h kh\nare the maximal convex subtrees of T that lie in D \\ h. We call a vertex v of D boundary if T has an edge {v, u} with u not in D, and define the degree deg(D) of D to be the number of its boundary vertices. Note that T itself is the only subtree of T of degree 0. The following lemma shows that to compute coverT we only need subtrees of degree 1 and 2 and the depth of recursion O(log |P |).\nLemma 1. Let D be a subtree of T with m vertices and deg(D) \u2264 2. If deg(D) \u2264 1, then there is a vertex v splitting D into subtrees of size at most m/2 + 1 and degree at most 2. If deg(D) = 2, then there is v splitting D into subtrees of size at most m/2+ 1 and degree at most"}, {"heading": "2 and, possibly, one subtree of size less than m and degree 1.", "text": "Proof. Let deg(D) \u2264 1. Suppose some vertex v1 splits D into subtrees one of which, say D1, is larger than m/2 + 1. Let v2 be the (unique) vertex in D1 adjacent to v1. The splitting of D by v2 consists of the subtree D2 = (D \\D1)\u222a {v1, v2} of size at most m/2 and some other subtrees lying inside D1; all of them are of degree at most 2. We repeat this process until the size of the largest subtree becomes at most m/2 + 1.\nLet deg(D) = 2, with b1 and b2 being the boundary vertices. We proceed as above starting from v1 = b1, but stop when either the largest subtree has \u2264 m/2 + 1 vertices or vi+1 leaves the path between b1 and b2, in which case vi splits D into subtrees of degree at most 2 and one subtree of degree 1 with more than m/2 + 1 vertices.\nBy applying (13) to T recursively and choosing the splitting vertices v as prescribed by Lemma 1, we obtain a circuit C whose inputs are the labels of some vertices of H . Since any tree has polynomially many subtrees of degree 1 or 2, the size of C is polynomial in |P |. We now show how to make the depth of C logarithmic in |P |.\nSuppose D is a subtree with m edges constructed on the recursion step i. To compute coverD using (13), we need one or-gate of unbounded fan-in and a number of and-gates of fan-in 2. We show by induction that we can make the and-depth of these and-gates at most logm + i. Suppose Dj in (13) has mj edges, and som = m1+\u00b7 \u00b7 \u00b7+mk. By the induction hypothesis, we can compute each coverDj within the and-depth at most logmj+i\u22121. Assign the probability mj/m to Dj. As shown by Huffman [39], there is a prefix binary code such that each Dj is encoded by a word of length \u2308log(m/mj)\u2309. This encoding can be represented as a binary tree whose leaves are labelled with the Dj so that the length of the branch ending at Dj is \u2308log(m/mj)\u2309. By replacing each non-leaf vertex of the tree with an and-gate, we obtain a circuit for the first conjunction in (13) whose depth does not exceed\nmax j {logmj + (i\u2212 1) + log(m/mj) + 1} = logm+ i.\nThe second conjunction is considered analogously. \u2293\u2294\n6.5 NC1, \u03a03 and THGP d\nThe proof of the following theorem, given in Appendix F, is a simplified version of the proof of Theorem 17:\nTheorem 18. NC1 = THGPd and mNC1 = mTHGPd, for any d \u2265 3.\nTHGPs of degree 2 turn out to be less expressive:\nTheorem 19. \u03a03 = THGP 2 = THGP2(2) and m\u03a03 = mTHGP 2 = mTHGP2(2).\nProof. To show THGP2 \u2286 \u03a03, take a THGP P of degree 2. Without loss of generality we can assume that it contains no hyperedges e, e\u2032 with e \u2286 e\u2032, for otherwise the vertices in e would not be covered by any other hyperedges, and so could be removed from P together with e.\nConsider the graph D whose vertices are the hyperedges of P , with two vertices being connected if the corresponding hyperedges intersect. Clearly, D is a forest. We label an edge {e1, e2} with the conjunction of the labels of the vertices in e1 \u2229 e2, and label a vertex e with the conjunction of the labels of the vertices in P contained exclusively in e. It is easy to see that, for any given input, an independent cover of zeros in P corresponds to an independent set in D covering all zeros in the vertices and such that each edge labelled with 0 has precisely one endpoint in that independent set.\nWe claim that there is no such an independent set I in D iff there is a path e0, e1, . . . , ek in D with odd k (in particular, k = 1) such that e0 and ek are labelled with 0 and \u2018even\u2019 edges {ei\u22121, ei} with even i are labelled with 0. To see (\u21d0), observe that we have to include e0 and ek in I. Then, the edge {e1, e2} labelled with 0 makes us to include e2 to I (e1 is adjacent to e and cannot be included in I). Next, the edge {e3, e4} makes us to include e4 in I and so on. In the end we will have to include ek\u22121 to I and, since ek is also in I, this gives a contradiction with independence of I.\nTo show (\u21d2), suppose there is no such a pair of vertices. Then we can construct a desired independent set I. Add to I all vertices labelled with 0. If there is a triple of consecutive vertices e, e1, e2 in D such that e is already in I and an edge {e1, e2} is labelled with 0, then we add e2 to I. Note that, if we have add some vertex e\n\u2032 to e in this process, then there is a path e = e0, e1, . . . , ek = e\n\u2032 with even k such that vertex e is labelled with 0 and every edge {ei\u22121, ei} for even i in this path is labelled with 0.\nIn this process we never add two connected vertices e and e\u2032 of D to I, for otherwise the union of the paths described above for these two vertices would result in a path of odd length with endpoints labelled with 0 and with every second edge labelled with 0. This directly contradicts our assumption.\nIf there are still edges labelled with 0 in D with no endpoints in I, then add any endpoint of such an edge to I and repeat the process above. This also will not lead to a pair of connected vertices in I. Indeed, if as a result we add to I a vertex e1 connected to a vertex e which was added to I previously, then there is an edge {e2, e1} labelled with 0 (that was the reason for adding e1 to I), and so we should have added e2 to I before. By repeating this process, we obtain an independent set I covering all vertices and edges labelled with 0.\nThe established claim means that an independent set I in D exists iff, for any simple path e0, e1, . . . , ek with an odd k, the label of e0 or ek evaluates to 1, or the label of at least one {ei\u22121, ei}, for even i, evaluates to 1. This property is computed by a \u03a03-circuit where, for each simple path e0, e1, . . . , ek with an odd k, we take (k + 3)/2-many and-gates whose inputs are the literals in the labels of e0, ek and the {ei\u22121, ei} for even i; then we send the outputs of those and-gates to an or-gate; and, finally, we collect the outputs of all the or-gates as inputs to an and-gate.\nTo show \u03a03 \u2286 THGP 2(2), suppose we are given a \u03a03-circuit C. We can assume C to be a conjunction of DNFs. So, we first construct a generalised HGP P from THGP2(2) computing the same function as C. Denote the or-gates of C by g1, . . . , gk and the inputs of gi by hi1, . . . , h i li , where each hij is an and-gate. Now, we define a tree hypergraph whose underlying path graph has the following edges (in the given order)\nv10 , . . . , v 1 2l1\u22122, v 2 0 , . . . , v 2 2l2\u22122, . . . , v k 0 , . . . , v k 2lk\u22122\nand whose hyperedges are of the form {vij , v i j+1}. We label v i 2m with a conjunction of the inputs of him+1 and the remaining vertices with 0. By the previous analysis for a given i and an input for C, we can cover all zeros among vi0, . . . , v i 2li\u22122 with an independent set of hyperedges iff at least one of the gates hi1, . . . , h i li outputs 1. For different i, the corresponding vi0, . . . , v i 2li\u22122 are covered independently. Thus, P computes the same function as C. We convert P to a THGP from THGP2(2) using Proposition 4 (ii)."}, {"heading": "7 The Size of OMQ Rewritings", "text": "In this section, by an OMQ Q = (T , q) we mean a sequence {Qn = (Tn, qn)}n<\u03c9 of OMQs whose size is polynomial in n; by a rewriting q\u2032 of Q we mean a sequence {q\u2032n}n<\u03c9, where each q\u2032n is a rewriting of Qn, for n < \u03c9.\nBy putting together the results of the previous three sections and some known facts from circuit complexity, we obtain the upper and lower bounds on the size of PE-, NDL- and FOrewritings for various OMQ classes that are collected in Table 4, where exp means an exponential\nlower bound, > poly a superpolynomial lower bound, poly a polynomial upper bound, poly-\u03a04 a polynomial-size \u03a04-rewriting (that is, a PE-rewriting with the matrix of the form \u2227\u2228\u2227\u2228), and \u2113 and t are any fixed constants. It is to be noted that, in case of polynomial upper bounds, we actually provide polynomial algorithms for constructing rewritings."}, {"heading": "7.1 Rewritings for OMQs with ontologies of depth 2", "text": "By Theorem 13, OMQs with ontologies of depth 2 can compute any NP-complete monotone Boolean function, in particular, the function Clique with n(n \u2212 1)/2 variables ejj\u2032 , 1 \u2264 j < j\u2032 \u2264 n, that returns 1 iff the graph with vertices {1, . . . , n} and edges {{j, j\u2032} | ejj\u2032 = 1} contains a k-clique, for some fixed k. A series of papers, started by Razborov [64], gave an exponential lower bound for the size of monotone circuits computing Clique, namely, 2\u2126( \u221a k) for k \u2264 14 (n/ logn) 2/3 [2]. For monotone formulas, an even better lower bound is known: 2\u2126(k) for k = 2n/3 [63]. Thus, we obtain:\nTheorem 20. There is an OMQ with ontologies of depth 2, any PE- and NDL-rewritings of which are of exponential size, while any FO-rewriting is of superpolynomial size unless NP \u2286 P/poly.\nProof. In view of Clique \u2208 NP \u2286 NP/poly and Theorem 13, there is a polynomial-size monotone HGP P computing Clique. Suppose P is based on a hypergraph H and QH is the OMQ for H constructed in Section 5.1. By Theorem 7 (ii), Clique is a subfunction of the primitive evaluation function f\u25b3QH . By Theorem 6, if q \u2032 is a PE- or NDL-rewriting of QH , then f \u25b3 QH \u2014and so Clique\u2014can be computed by a monotone formula or, respectively, circuit of size O(|q\u2032|). Thus, q\u2032 must be of exponential size. If q\u2032 is an FO-rewriting ofQH then, by Theorem 6, Clique is computable by a Boolean formula of size O(|q\u2032|). If NP 6\u2286 P/poly then Clique cannot be computed by a polynomial circuit, and so q\u2032 must be of superpolynomial size.\nOur next theorem gives a complexity-theoretic characterisation of the existence of FOrewritings for OMQs with ontologies of depth 2.\nTheorem 21. The following conditions are equivalent :\n(1) all OMQs with ontologies of depth 2 have polynomial-size FO-rewritings ; (2) all OMQs with ontologies of depth 2 and polynomially many tree witnesses have polynomial-\nsize FO-rewritings ; (3) NP/poly \u2286 NC1.\nProof. The implication (1) \u21d2 (2) is obvious. To show that (2) \u21d2 (3), suppose there is a polynomial-size FO-rewriting for the OMQ QH from the proof of Theorem 20, which has polynomially many tree witnesses. Then Clique is computed by a polynomial-size Boolean formula. Since Clique is NP/poly-complete under NC1-reductions, we have NP/poly \u2286 NC1. Finally, to prove (3) \u21d2 (1), assume NP/poly \u2286 NC1. Let Q be an arbitrary OMQ with ontologies of depth 2. As observed in Section 4.1, the function fHQ is in NP \u2286 NP/poly. Therefore, by our assumption, fHQ can be computed by a polynomial-size formula, and so, by Theorem 5, Q has a polynomial-size FO-rewriting."}, {"heading": "7.2 Rewritings for OMQs with ontologies of depth 1", "text": "Theorem 22. Any OMQ Q with ontologies of depth 1 has a polynomial-size NDL-rewriting.\nProof. By Theorem 8, the hypergraphH(Q) is of degree at most 2, and so, by Proposition 2 (ii), there is a polynomial-size monotone HGP of degree at most 2 computing f\u25bdQ. By Theorem 14, co-mNL/poly = mHGP2, and so we have a polynomial-size monotone NBP computing the dual f\u25bdQ \u2217 of f\u25bdQ. Since mNL/poly \u2286 mP/poly, we also have a polynomial-size monotone Boolean circuit that computes f\u25bdQ \u2217 . By swapping and- and or-gates in that circuit, we obtain a polynomial-size monotone circuit computing f\u25bdQ. It remains to apply Theorem 4 (ii).\nHowever, this upper bound cannot be extended to PE-rewritings:\nTheorem 23. There is an OMQ Q with ontologies of depth 1, any PE-rewriting of which is of superpolynomial size (n\u2126(log n), to be more precise).\nProof. Consider the monotone function Reachability that takes the adjacency matrix of a directed graph G with two distinguished vertices s and t and returns 1 iff the graph G contains a directed path from s to t. It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size n\u2126(logn). Let f = Reachability. By Theorem 14, there is a polynomial-size monotone HGP that is based on a hypergraph H of degree 2 and computes the dual f\u2217 of f . Consider now the OMQ SH for H defined in Section 5.2. By Theorem 9 (ii), f\u2217 is a subfunction of f\u25b3SH . By Theorem 6 (i), no PE-rewriting of the OMQ SH can be shorter than n\u2126(logn).\nTheorem 24. All OMQs with ontologies of depth 1 have polynomial-size FO-rewritings iff NL/poly \u2286 NC1.\nProof. Suppose NL/poly \u2286 NC1. Let Q be an OMQ with ontologies of depth 1. By Theorem 8, its hypergraphH(Q) is of degree 2 and polynomial size. By Proposition 2 (ii), there is a polynomialsize HGP of degree 2 that computes f\u25bdQ. By Theorem 14, f \u25bd\nQ \u2208 NL/poly. Therefore, by our assumption, f\u25bdQ can be computed by a polynomial-size Boolean formula. Finally, Theorem 4 (i) gives a polynomial-size FO-rewriting of Q.\nConversely, suppose there is a polynomial-size FO-rewriting for any OMQ with ontologies of depth 1. Let f = Reachability. Since f \u2208 NL \u2286 NL/poly, by Theorem 14, we obtain a polynomial-size HGP computing f and based on a hypergraph H of degree 2. Consider the OMQ SH with ontologies of depth 1 defined in Section 5.2. By Theorem 9 (ii), f a subfunction of f\u25b3SH . By our assumption, SH has a polynomial-size FO-rewriting; hence, by Theorem 6 (i), f\u25b3SH (and so f) are computed by polynomial-size Boolean formulas. Since f is NL/poly-complete under NC1-reductions [65], we obtain NL/poly \u2286 NC1."}, {"heading": "7.3 Rewritings for tree-shaped OMQs with a bounded number of leaves", "text": "Since, by Theorem 16, the hypergraph function of a leaf-bounded OMQ can be computed by a polynomial-size NBP, we have:\nTheorem 25. For any fixed \u2113 \u2265 2, all tree-shaped OMQs with at most \u2113 leaves have polynomialsize NDL-rewritings.\nThe superpolynomial lower bound below is proved in exactly the same way as Theorem 23 using Theorems 15 and 11 instead of Theorems 14 and 9.\nTheorem 26. There is an OMQ with ontologies of depth 2 and linear CQs any PE-rewriting of which is of superpolynomial size (n\u2126(logn), to be more precise).\nOur next result is similar to Theorem 24:\nTheorem 27. The following are equivalent :\n(1) there exist polynomial-size FO-rewritings for all OMQs with linear CQs and ontologies of depth 2; (2) for any fixed \u2113, there exist polynomial-size FO-rewritings for all tree-shaped OMQs with at most \u2113 leaves ; (3) NL/poly \u2286 NC1.\nProof. (1) \u21d2 (3) Suppose every OMQ Q = (T , q) with linear q and T of depth 2 has an FO-rewriting of size p(|Q|), for some fixed polynomial p. Consider f = Reachability. As f is monotone and f \u2208 NL, we have f \u2208 mNL/poly. Thus, Theorem 15 gives us an HGP P from mTHGP(2) that computes f . Let P be based on a hypergraph H , and let TH be the OMQ with a linear CQ and an ontology of depth 2 constructed in Section 5.3. By Theorem 11 (ii), f is a subfunction of f\u25b3TH . By our assumption, however, TH has a polynomial-size FO-rewriting, and so, by Theorem 6 (i), it is computed by a polynomial-size Boolean formula. Since f is NL/polycomplete under NC1-reductions [65], we obtain NL/poly \u2286 NC1. The implication (3) \u21d2 (2) follows from Theorems 16 and 4 (i), and (2) \u21d2 (1) is trivial."}, {"heading": "7.4 Rewritings for OMQs with PFSP and bounded treewidth", "text": "Since OMQs with the polynomial fundamental set property (PFSP, see Section 3) and CQs of bounded treewidth can be polynomially translated into monotone THGPs and mTHGP = mLOGCFL/poly \u2286 mP/poly, we obtain:\nTheorem 28. For any fixed t > 0, all OMQs with the PFSP and CQs of treewidth at most t have polynomial-size NDL-rewritings.\nUsing Theorem 1 and the fact that OMQs with ontologies of bounded depth enjoy the PFSP, we obtain:\nCorollary 1. The following OMQs have polynomial-size NDL-rewritings :\n\u2013 OMQs with ontologies of bounded depth and CQs of bounded treewidth; \u2013 OMQs with ontologies not containing axioms of the form \u033a(x, y) \u2192 \u033a\u2032(x, y) (and (2)) and CQs of bounded treewidth.\nWhether all OMQs without axioms of the form \u033a(x, y) \u2192 \u033a\u2032(x, y) have polynomial-size rewritings remains open.12\nTheorem 29. The following are equivalent :\n(1) there exist polynomial-size FO-rewritings for all tree-shaped OMQs with ontologies of depth 2 ; (2) there exist polynomial-size FO-rewritings for all OMQs with the PFSP and CQs of treewidth at most t (for any fixed t); (3) LOGCFL/poly \u2286 NC1.\nProof. The implication (2) \u21d2 (1) is trivial, and (1) \u21d2 (3) is proved similarly to the corresponding case of Theorem 27 using Theorems 17, 11 and 6. (3) \u21d2 (2) follows from Theorems 12, 17 and 5."}, {"heading": "7.5 Rewritings for OMQs with ontologies of depth 1 and CQs of bounded treewidth", "text": "We show finally that polynomial PE-rewritings are guaranteed to exist for OMQs with ontologies of depth 1 and CQs of bounded treewidth. By Theorem 18, it suffices to show that fHQ is computable by a THGP of bounded degree. However, since tree witnesses can be initiated by multiple roles, the THGPs constructed in Section 5.4 do not enjoy this property and require a minor modification.\nLet Q = (T , q) be an OMQ with T of depth 1. For every tree witness t = (tr, ti), we take a fresh binary predicate Pt (which cannot occur in any data instance) and extend T with the following axioms:\n\u03c4(x) \u2192 \u2203y Pt(x, y), if \u03c4 generates t,\nPt(x, y) \u2192 \u033a(x, y), if \u033a(u, v) \u2208 qt, u \u2208 tr and v \u2208 ti.\nDenote the resulting ontology by T \u2032 and set Q\u2032 = (T \u2032, q). By Theorem 8, the number of tree witnesses for Q does not exceed |q|, and so the size of Q\u2032 is polynomial in |Q|. It is easy to see that any rewriting of Q\u2032 (with Pt replaced by \u22a5) is also a rewriting for Q. Thus, it suffices to consider OMQs of the form Q\u2032, which will be called explicit.\nGiven an explicit OMQ Q = (T , q), we construct a THGP P \u2032Q in the same way as PQ in Section 5.4 except that in the definition of Eki , instead of considering all types wk of Ni, we only use wk = (w[1], . . . ,w[m]) in which w[j] is either \u03b5 or Pt for the unique tree witness t = (tr, ti) with ti = {\u03bbj(Ni)}. (Since T is of depth 1, every tree witness t has ti = {z}, for some variable z, and ti 6= t \u2032 i whenever t 6= t\u2032.) This modification guarantees that, for every i, the number of distinct Eki is bounded by 2 m. It follows that the hypergraph of P \u2032Q is of bounded degree, 2m + 22m to be more precise. To establish the correctness of the modified construction, we can\n12 A positive answer to this question given by Kikot et al. [48] is based on a flawed proof.\nprove an analogue of Theorem 12, in which the original THGP PQ is replaced by P \u2032 Q, and the function fHQ is replaced by\nfH\u2032Q = \u2228\n\u0398\u2286\u0398Q independent\n( \u2227\nS(z)\u2208q\\q\u0398\npS(z) \u2227 \u2227\nt\u2208\u0398\n( \u2227\nR(z,z\u2032)\u2208q t\npz=z\u2032 \u2227 \u2227\nz\u2208tr\u222ati p\u2203yPt(z,y)\n))\n(which is obtained from fHQ by always choosing Pt as the predicate that initiates t). It is easy to see that Theorem 4 holds also for fH\u2032Q (with explicit Q), which gives us:\nTheorem 30. For any fixed t > 0, all OMQs with ontologies of depth 1 and CQs of treewidth at most t have polynomial-size PE-rewritings.\nFor tree-shaped OMQs, we obtain an even better result. Indeed, by Theorem 10, H(Q) is a tree hypergraph; by Theorem 8, it is of degree at most 2, and so, by Theorem 19, f\u25bdQ is computed by a polynomial-size \u03a03-circuit (which is monotone by definition). Thus, Theorem 4 (i) gives us the following (\u03a03 turns into \u03a04 because of the disjunction in the formula twt):\nTheorem 31. All tree-shaped OMQs with ontologies of depth 1 have polynomial-size \u03a04-rewritings."}, {"heading": "8 Combined Complexity of OMQ answering", "text": "The size of OMQ rewritings we investigated so far is crucial for classical OBDA, which relies upon a reduction to standard database query evaluation (under the assumption that it is efficient in real-world applications). However, this way of answering OMQs may not be optimal, and so understanding the size of OMQ rewritings does not shed much light on how hard OMQ answering actually is. For example, answering the OMQs from the proof of Theorem 23 via PE-rewriting requires superpolynomial time, while the graph reachability problem encoded by those OMQs is NL-complete. On the other hand, the existence of a short rewriting does not obviously imply tractability.\nIn this section, we analyse the combined complexity of answering OMQs classified according to the depth of ontologies and the shape of CQs. More precisely, our concern is the following decision problem: given an OMQQ(x) = (T , q(x)), a data instance A and a tuple a from ind(A) (of the same length as x), decide whether T ,A |= q(a). Recall from Section 3 that T ,A |= q(a) iff CT ,A |= q(a) iff there exists a homomorphism from q(a) to CT ,A.\nThe combined complexity of CQ evaluation has been thoroughly investigated in relational database theory. In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].\nThe emerging combined complexity landscape for OMQ answering is summarised in Fig. 2 (b) in Section 1.3. The NP and LOGCFL lower bounds for arbitrary OMQs and tree-shaped OMQs with ontologies of bounded depth are inherited from the corresponding CQ evaluation problems. The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31]. By reduction of the reachability problem for directed graphs, one can easily show that evaluation of tree-shaped CQs with a bounded number of leaves (as well as answering OMQs with unary predicates only) is NL-hard. We now establish the remaining results."}, {"heading": "8.1 OMQs with bounded-depth ontologies", "text": "We begin by showing that the LOGCFL upper bound for CQs of bounded treewidth [33] is preserved even in the presence of ontologies of bounded depth.\nTheorem 32. For any fixed d \u2265 0 and t > 0, answering OMQs with ontologies of depth at most d and CQs of treewidth at most t is LOGCFL-complete.\nProof. LetQ(x) = (T , q(x)) be an OMQ with T of depth at most d and q of treewidth at most t. As T is of finite depth, CT ,A is finite for anyA. As LOGCFL is closed under LLOGCFL reductions [32] and evaluation of CQs of bounded treewidth is LOGCFL-complete, it suffices to show that CT ,A can be computed by an LLOGCFL-transducer (a deterministic logspace Turing machine with a LOGCFL oracle). Clearly, we need only logarithmic space to represent any predicate name or individual constant from T and A, as well as any word aw \u2208 \u2206CT ,A (since |w| \u2264 d and d is fixed). Finally, as entailment in OWL2QL is in NL [4], each of the following problems can be decided by making a call to an NL (hence LOGCFL) oracle:\n\u2013 decide whether a\u033a1 . . . \u033an \u2208 \u2206CT ,A , for any n \u2264 d and roles \u033ai from T ; \u2013 decide whether u \u2208 \u2206CT ,A belongs to ACT ,A , for a unary A from T and A; \u2013 decide whether (u1, u2) \u2208 \u2206 CT ,A \u00d7\u2206CT ,A is in P CT ,A , for a binary P from T and A. \u2293\u2294\nIf we restrict the number of leaves in tree-shaped OMQs, then the LOGCFL upper bound can be reduced to NL:\nTheorem 33. For any fixed d \u2265 0 and \u2113 \u2265 2, answering OMQs with ontologies of depth at most d and tree-shaped CQs with at most \u2113 leaves is NL-complete.\nProof. Algorithm 1 defines a non-deterministic procedure TreeQuery for deciding whether a tuple a is a certain answer to a tree-shaped OMQ (T , q(x)) over A. The procedure views q as a directed tree (we pick one of its variables z0 as a root) and constructs a homomorphism from q(x) to CT ,A on-the-fly by traversing the tree from root to leaves. The set frontier is initialised with a pair z0 7\u2192 u0 representing the choice of where to map z0. The possible choices for z0 include ind(A) and aw \u2208 \u2206CT ,A such that |w| \u2264 2|T |+ |q|, which are enough to find a homomorphism if it exists [4]. This set of possible choices is denoted by U in Algorithm 1. Note that U occurs only in statements of the form \u2018guess u \u2208 U \u2019 and need not be materialised. Instead, we assume that the sequence u is guessed element-by-element and the condition u \u2208 U is verified along the sequence of guesses. We use the subroutine call canMap(z0, u0) to check whether the guessed u0 is compatible with z0.\n13 It first ensures that, if z0 is an answer variable of q(x), then u0 is the individual constant corresponding to z0 in a. Next, if z0 \u2208 ind(A), then it verifies that u0 satisfies all atoms in q(x) that involve only z0. If u0 6\u2208 ind(A), then u0 must take the form aw\u033a and the subroutine checks whether T |= \u2203y \u033a(y, x) \u2192 A(x) (equivalently, aw\u033a \u2208 ACT ,A) for every A(z0) \u2208 q and whether T |= P (x, x) for every P (z0, z0) \u2208 q. The remainder of the algorithm consists of a while loop, in which we remove z 7\u2192 u from frontier, and if z is not a leaf node, guess where to map its children. We must then check that the guessed element u\u2032 for child z\u2032 is compatible with (i) the binary atoms linking z to z\u2032 and (ii) the atoms that involve only z\u2032; the latter is done by canMap(z\u2032, u\u2032). If the check succeeds, we add z\u2032 7\u2192 u\u2032 to frontier, for each child z\u2032 of z; otherwise, false is returned. We exit the while loop when frontier is empty, i.e., when an element of CT ,A has been assigned to each variable in q(x).\nCorrectness and termination of the algorithm are straightforward and hold for tree-shaped OMQs with arbitrary ontologies. Membership in NL for bounded-depth ontologies and boundedleaf queries follows from the fact that the number of leaves of q does not exceed \u2113, in which case the cardinality of frontier is bounded by \u2113, and the fact that the depth of T does not exceed d, in which case every element of U requires only a fixed amount of space to store. So, since each variable z can be stored in logarithmic space, the set frontier can also be stored in logarithmic space. Finally, it should be clear that the subroutine canMap(z, u) can also be implemented in"}, {"heading": "NL [4].", "text": ""}, {"heading": "8.2 OMQs with bounded-leaf CQs", "text": "It remains to settle the complexity of answering OMQs with arbitrary ontologies and boundedleaf CQs, for which neither the upper bounds from the preceding subsection nor the NP lower bound by [48] are applicable.\nTheorem 34. For any fixed \u2113 \u2265 2, answering OMQs with tree-shaped CQs having at most \u2113 leaves is LOGCFL-complete.\n13 The operator check immediately returns false if the condition is not satisfied.\nALGORITHM 1: Non-deterministic procedure TreeQuery for answering tree-shaped OMQs\nData: a tree-shaped OMQ (T , q(x)), a data instance A and a tuple a from ind(A) Result: true if T ,A |= q(a) and false otherwise\nfix a directed tree T compatible with the Gaifman graph of q and let z0 be its root; let U = { aw \u2208 \u2206CT ,A | a \u2208 ind(A) and |w| \u2264 2|T |+ |q| }\n; /* not computed */ guess u0 \u2208 U ; /* use the definition of U to check whether the guess is allowed */ check canMap(z0,u0); frontier \u2190\u2212 {z0 7\u2192 u0}; while frontier 6= \u2205 do\nremove some z 7\u2192 u from frontier; foreach child z\u2032 of z in T do\nguess u\u2032 \u2208 U ; /* use the def. of U to check whether the guess is allowed */ check (u, u\u2032) \u2208 P CT ,A , for all P (z, z\u2032) \u2208 q, and canMap(z\u2032,u\u2032); frontier \u2190\u2212 frontier \u222a {z\u2032 7\u2192 u\u2032}\nreturn true;\nFunction canMap(z, u) if z is the ith answer variable and u 6= ai then return false; if u = aw\u033a then /* the element u is in the tree part of the canonical model */\ncheck T |= \u2203y \u033a(y, x) \u2192 A(x), for all A(z) \u2208 q, and T |= P (x, x), for all P (z, z) \u2208 q else /* otherwise, u \u2208 ind(A) */\ncheck u \u2208 ACT ,A , for all A(z) \u2208 q, and (u, u) \u2208 P CT ,A , for all P (z, z) \u2208 q\nreturn true;\nProof. First, we establish the upper bound using a characterisation of the class LOGCFL in terms of non-deterministic auxiliary pushdown automata (NAuxPDAs). An NAuxPDA [26] is a non-deterministic Turing machine with an additional work tape constrained to operate as a pushdown store. [72] showed that LOGCFL coincides with the class of problems that can be solved by NAuxPDAs running in logarithmic space and polynomial time (note that the space on the pushdown tape is not subject to the logarithmic space bound). Algorithms 2 and 3 give a procedure BLQuery for answering OMQs with bounded-leaf CQs that can be implemented by an NAuxPDA.\nSimilarly to TreeQuery, the idea is to view the input CQ q(x) as a tree and iteratively construct a homomorphism from q(x) to CT ,A, working from root to leaves. We begin by guessing an element a0w to which the root variable z0 is mapped and checking that a0w is compatible with z0. However, instead of storing directly a0w in frontier, we guess it element-by-element and push the word w onto the stack, stack. We assume that we have access to the top of the stack, denoted by top(stack), and the call top(stack) on empty stack returns \u03b5. During execution of BLQuery, the height of the stack will never exceed 2|T | + |q|, and so we assume that the height of the stack, denoted by |stack|, is also available as, for example, a variable whose value is updated by the push and pop operations on stack.\nAfter having guessed a0w, we check that z0 can be mapped to it, which is done by calling canMapTail(z0, a0, top(stack)). If the check succeeds, we initialise frontier to the set of 4-tuples of the form (z0 7\u2192 (a0, |stack|), zi), for all children zi of z0 in T . Intuitively, a tuple (z 7\u2192 (a, n), z\u2032) records that the variable z is mapped to the element a stack\u2264n and that the child z\u2032 of z remains to be mapped (in the explanations we use stack\u2264n to refer to the word comprising the first n symbols of stack; the algorithm, however, cannot make use of it).\nIn the main loop, we remove one or more tuples from frontier, choose where to map the variables and update frontier and stack accordingly. There are four options. Option 1 is used for tuples (z 7\u2192 (a, 0), z\u2032) where both z and z\u2032 are mapped to individual constants, Option 2 (Option 3) for tuples (z 7\u2192 (a, n), z\u2032) in which we map z\u2032 to a child (respectively, parent) of the image of z in CT ,A, while Option 4 applies when z and z\u2032 are mapped to the same element (which is possible if P (z, z\u2032) \u2208 q, for some P that is reflexive according to T ). Crucially, however, the order in which tuples are treated matters due to the fact that several tuples \u2018share\u2019 the single stack. Indeed, when applying Option 3, we pop a symbol from stack, and may therefore lose\nALGORITHM 2: Non-deterministic procedure BLQuery for answering bounded-leaf OMQs.\nData: a bounded-leaf OMQ (T , q(x)), a data instance A and a tuple a from ind(A) Result: true if T ,A |= q(a) and false otherwise\nfix a directed tree T compatible with the Gaifman graph of q and let z0 be its root; guess a0 \u2208 ind(A); /* guess the ABox element */ guess n0 < 2|T |+ |q|; /* maximum distance from ABox of relevant elements */ foreach n in 1, . . . , n0 do /* guess the initial element in a step-by-step fashion */\nguess a role \u033a in T such that isGenerated(\u033a, a0, top(stack)); push \u033a on stack\ncheck canMapTail(z0, a0, top(stack)); frontier \u2190\u2212 { (z0 7\u2192 (a0, |stack|), zi) | zi is a child of z0 in T }\n; while frontier 6= \u2205 do\nguess one of the 4 options; if Option 1 then /* take a step in ind(A) */\nremove some (z 7\u2192 (a, 0), z\u2032) from frontier; guess a\u2032 \u2208 ind(A); check (a, a\u2032) \u2208 P CT ,A , for all P (z, z\u2032) \u2208 q, and canMapTail(z\u2032, a\u2032, \u03b5); frontier \u2190\u2212 frontier \u222a {(z\u2032 7\u2192 (a\u2032, 0), z\u2032i) | z \u2032 i is a child of z\n\u2032 in T} else if Option 2 and |stack| < 2|T |+ |q| then /* a step \u2018forward\u2019 in the tree part */\nremove some (z 7\u2192 (a, |stack|), z\u2032) from frontier; guess a role \u033a in T such that isGenerated(\u033a, a, top(stack)); push \u033a on stack; check T |= \u033a(x, y) \u2192 P (x, y), for all P (z, z\u2032) \u2208 q, and canMapTail(z\u2032, a, top(stack)); frontier \u2190\u2212 frontier \u222a {(z\u2032 7\u2192 (a, |stack|), z\u2032i) | z \u2032 i is a child of z\n\u2032 in T} else if Option 3 and |stack| > 0 then /* take a step \u2018backward\u2019 in the tree part */\nlet deepest = {(z 7\u2192 (a, n), z\u2032) \u2208 frontier | n = |stack|}; /* may be empty */ remove all deepest from frontier; pop \u033a from stack; foreach (z 7\u2192 (a, n), z\u2032) \u2208 deepest do\ncheck T |= \u033a(x, y) \u2192 P (x, y), for all P (z\u2032, z) \u2208 q, and canMapTail(z\u2032, a, top(stack)); frontier \u2190\u2212 frontier \u222a {(z\u2032 7\u2192 (a, |stack|), z\u2032i) | z \u2032 i is a child of z \u2032 in T}\nelse if Option 4 then /* take a \u2018loop\u2019-step in the tree part of CT ,A */ remove some (z 7\u2192 (a, |stack|), z\u2032) from frontier; check T |= P (x, x), for all P (z, z\u2032) \u2208 q, and canMapTail(z\u2032, a, top(stack)); frontier \u2190\u2212 frontier \u222a {(z\u2032 7\u2192 (a, |stack|), z\u2032i) | z \u2032 i is a child of z\n\u2032 in T} else return false;\nreturn true;\nsome information that is needed for processing other tuples. To avoid this, Option 3 may only be applied to tuples (z 7\u2192 (a, n), z\u2032) with maximal n, and it must be applied to all such tuples at the same time. For Option 2, we require that the selected tuple (z 7\u2192 (a, n), z\u2032) is such that n = |stack|: since z\u2032 is being mapped to an element a stack\u2264n \u033a, we need to access the nth symbol in stack to determine the possible choices for \u033a and to record the symbol chosen by pushing it onto stack.\nThe procedure terminates and returns true when frontier is empty, meaning that we have successfully constructed a homomorphism witnessing that the input tuple is an answer. Conversely, given a homomorphism from q(a) to CT ,A, we can define a successful execution of BLQuery. We prove in Appendix H that BLQuery terminates (Proposition 5), is correct (Proposition 6) and can be implemented by an NAuxPDA (Proposition 7). The following example illustrates the construction.\nExample 16. Suppose T has the following axioms:\nA(x) \u2192 \u2203y P (x, y), P (x, y) \u2192 U(y, x),\n\u2203y P (y, x) \u2192 \u2203y S(x, y), \u2203y S(y, x) \u2192 \u2203y T (y, x), \u2203y P (y, x) \u2192 B(x).\nthe query is as follows:\nALGORITHM 3: Subroutines for BLQuery.\nFunction canMapTail(z, a, \u03c3) if z is the ith answer variable and either a 6= ai or \u03c3 6= \u03b5 then return false; if \u03c3 6= \u03b5 then /* an element of the form a . . . \u03c3 in the tree part */\ncheck T |= \u2203y \u03c3(y, x) \u2192 A(x), for all A(z) \u2208 q, and T |= P (x, x), for all P (z, z) \u2208 q else /* otherwise, in ind(A) */\ncheck a \u2208 ACT ,A , for all A(z) \u2208 q, and (a, a) \u2208 P CT ,A , for all P (z, z) \u2208 q\nreturn true;\nFunction isGenerated(\u033a, a, \u03c3) if \u03c3 6= \u03b5 then /* an element of the form a . . . \u03c3 in the tree part */\ncheck T |= \u2203y \u03c3(y, x) \u2192 \u2203y \u033a(x, y) else /* otherwise, in ind(A) */\ncheck (a, b) \u2208 \u033a(x, y)CT ,A , for some b \u2208 \u2206CT ,A \\ ind(A)\nreturn true;\nq(x1, x2) = \u2203y1y2y3y4y5 ( R(y2, x1) \u2227 P (y2, y1) \u2227 S(y1, y3) \u2227\nT (y5, y3) \u2227 S(y4, y3) \u2227 U(y4, x2) )\nand A = {A(a), R(a, c)}. Observe that CT ,A |= q(c, a). We show how to define an execution of BLQuery that returns true on ((T , q),A, q, (c, a)) and the homomorphism it induces. We fix some variable, say y1, as the root of the query tree. We then guess the constant a and the word P , push P onto stack and check using canMapTail(y1, a, P) that our choice is compatible with y1. At the start of the while loop, we have\nfrontier = {(y1 7\u2192 (a, 1), y2), (y1 7\u2192 (a, 1), y3)} and stack = P, (w-1)\nwhere the first tuple, for example, records that y1 has been mapped to a stack\u22641 = aP and y2 remains to be mapped. We are going to use Option 3 for (y1 7\u2192 (a, 1), y2) and Option 2 for (y1 7\u2192 (a, 1), y3). We (have to) start with Option 2 though: we remove (y1 7\u2192 (a, 1), y3) from frontier, guess S, push it onto stack, and add (y3 7\u2192 (a, 2), y4) and (y3 7\u2192 (a, 2), y5) to frontier. Note that the tuples in frontier allow us to read off the elements a stack\u22641 and a stack\u22642 to which y1 and y3 are mapped. Thus,\nfrontier = {(y1 7\u2192 (a, 1), y2), (y3 7\u2192 (a, 2), y4), (y3 7\u2192 (a, 2), y5)} and stack = PS (w-2)\nat the start of the second iteration of the while loop. We are going to use Option 3 for (y3 7\u2192 (a, 2), y4) and Option 2 for (y3 7\u2192 (a, 2), y5). Again, we have to start with Option 2: we remove (y3 7\u2192 (a, 2), y5) from frontier, and guess T\u2212 and push it onto stack. As y5 has no children, we leave frontier unchanged. At the start of the third iteration,\nfrontier = {(y1 7\u2192 (a, 1), y2), (y3 7\u2192 (a, 2), y4)} and stack = PST \u2212; (w-3)\nsee Fig. 19 (a). We apply Option 3 and, since deepest = \u2205, we pop T\u2212 from stack but make no other changes. In the fourth iteration, we again apply Option 3. Since deepest = {(y3 7\u2192 (a, 2), y4)}, we remove this tuple from frontier and pop S from stack. As the checks succeed for S, we add (y4 7\u2192 (a, 1), x2) to frontier. Before the fifth iteration,\nfrontier = {(y1 7\u2192 (a, 1), y2), (y4 7\u2192 (a, 1), x2)} and stack = P ; (w-5)\nsee Fig. 19 (b). We apply Option 3 with deepest = {(y1 7\u2192 (a, 1), y2), (y4 7\u2192 (a, 1), x2)}. This leads to both tuples being removed from frontier and P popped from stack. We next perform the required checks and, in particular, verify that the choice of where to map the answer variable x2 agrees with the input vector (c, a) (which is indeed the case). Then, we add (y2 7\u2192 (a, 0), x1) to frontier. The final, sixth, iteration begins with\nfrontier = {(y2 7\u2192 (a, 0), x1)} and stack = \u03b5; (w-6)\nsee Fig. 19 (c). We choose Option 1, remove (y2 7\u2192 (a, 0), x1) from frontier, guess c, and perform the required compatibility checks. As x1 is a leaf, no new tuples are added to frontier; see Fig. 19 (d). We are thus left with frontier = \u2205, and return true.\nThe proof of LOGCFL-hardness is by reduction of the following problem: decide whether an input of length n is accepted by the nth circuit of a logspace-uniform family of SAC1 circuits, which is known to be LOGCFL-hard [75]. This problem was used by [33] to show LOGCFLhardness of evaluating tree-shaped CQs. We follow a similar approach, but with one crucial difference: using an ontology, we \u2018unravel\u2019 the circuit into a tree, which allows us to replace tree-shaped CQs by linear ones. Following [33], we assume without loss of generality that the considered SAC1 circuits adhere to the following normal form:\n\u2013 fan-in of all and-gates is 2;\n\u2013 nodes are assigned to levels, with gates on level i only receiving inputs from gates on level i\u2212 1, the input gates on level 1 and the output gate on the greatest level;\n\u2013 the number of levels is odd, all even-level gates are or-gates, and all odd-level non-input gates are and-gates.\nIt is well known [33, 75] that a circuit in normal form accepts an input \u03b1 iff there is a labelled rooted tree (called a proof tree) such that\n\u2013 the root node is labelled with the output and-gate;\n\u2013 if a node is labelled with an and-gate gi and gi = gj \u2227 gk, then it has two children labelled with gj and gk, respectively; \u2013 if a node is labelled with an or-gate gi and gi = gj1 \u2228 . . . \u2228 gjk , then it has a unique child that is labelled with one of gj1 , . . . , gjk ; \u2013 every leaf node is labelled with an input gate whose literal evaluates to 1 under \u03b1.\nFor example, the circuit in Fig. 20 (a) accepts (1, 0, 0, 0, 1), as witnessed by the proof tree in Fig. 20 (b). While a circuit-input pair may admit multiple proof trees, they are all isomorphic modulo the labelling. Thus, with every circuit C, we can associate a skeleton proof tree T such that C accepts \u03b1 iff some labelling of T is a proof tree for C and \u03b1. Note that T depends only on the number of levels in C. The reduction [33], which is for presentation purposes reproduced here with minor modifications, encodes C and \u03b1 in the database and uses a Boolean tree-shaped CQ based on the skeleton proof tree. Specifically, the database D(\u03b1) uses the gates of C as constants and consists of the following facts:\nL(gj , gi) and R(gk, gi), for every and-gate gi with gi = gj \u2227 gk;\nU(gj1 , gi), . . . , U(gjk , gi), for every or-gate gi with gi = gj1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 gjk ;\nA(gi), for every input gate gi whose value is 1 under \u03b1.\nThe CQ q uses the nodes of T as variables, has an atom U(zj, zi) (L(zj, zi), R(zj , zi)) for every node zi with unique (left, right) child zj , and has an atom A(zi) for every leaf node zi. These definitions guarantee that D(\u03b1) |= q iff C accepts \u03b1; moreover, both q and D(\u03b1) can be constructed by logspace transducers.\nTo adapt this reduction to our setting, we replace q by a linear CQ q\u2032, which is obtained by a depth-first traversal of q. When evaluated on D(\u03b1), the CQs q\u2032 and q may give different answers, but the answers coincide if the CQs are evaluated on the unravelling of D(\u03b1) into a tree. Thus, we define (T\u03b1,A) whose canonical model induces a tree isomorphic to the unravelling of D(\u03b1). To formally introduce q\u2032, consider the sequence of words defined inductively as follows:\nw0 = \u03b5 and wj+1 = L \u2212 U\u2212 wj U LR \u2212 U\u2212wj U R, for j > 0.\nSuppose C has 2d+ 1 levels, d \u2265 0. Consider the dth word wd = \u033a1\u033a2 . . . \u033ak and take\nq\u2032(y0) = \u2203y1, . . . , yk [ k\u2227\ni=1\n\u033ai(yi\u22121, yi) \u2227 \u2227\n\u033ai\u033ai+1=U\u2212 U\nA(yi) ] ;\nsee Fig. 20 (c). We now define (T\u03b1,A). Suppose C has gates g1, . . . , gm, with gm the output gate. In addition to predicates U , L, R, A, we introduce a unary predicate Gi for each gate gi. We set A = {Gm(a)} and include the following axioms in T\u03b1:\nGi(x) \u2192 \u2203y ( S(x, y) \u2227Gj(y) ) , for every S(gj , gi) \u2208 D(\u03b1), S \u2208 {U,L,R},\nGi(x) \u2192 A(x), for every A(gi) \u2208 D(\u03b1);\nsee Fig. 20 (d) for an illustration. When restricted to predicates U , L, R, A, the canonical model of (T\u03b1,A) is isomorphic to the unravelling of D(\u03b1) starting from gm.\nWe show in Appendix I that q\u2032 and (T\u03b1,A) can be constructed by logspace transducers (Proposition 8), and that C accepts \u03b1 iff T\u03b1,A |= q \u2032(a) (Proposition 9)."}, {"heading": "9 Conclusions and open problems", "text": "Our aim in this work was to understand how the size of OMQ rewritings and the combined complexity of OMQ answering depend on (i) the existential depth of OWL2QL ontologies, (ii) the treewidth of CQs or the number of leaves in tree-shaped CQs, and (iii) the type of rewriting: PE, NDL or arbitrary FO.\nWe tackled the succinctness problem by representing OMQ rewritings as (Boolean) hypergraph functions and establishing an unexpectedly tight correspondence between the size of OMQ rewritings and the size of various computational models for computing these functions. It turned out that polynomial-size PE-rewritings can only be constructed for OMQs with ontologies of depth 1 and CQs of bounded treewidth. Ontologies of larger depth require, in general, PErewritings of super-polynomial size. The good and surprising news, however, is that, for classes of OMQs with ontologies of bounded depth and CQs of bounded treewidth, we can always (efficiently) construct polynomial-size NDL-rewritings. The same holds if we consider OMQs obtained by pairing ontologies of depth 1 with arbitrary CQs or coupling arbitrary ontologies with bounded-leaf queries; see Fig. 2 for details. The existence of polynomial-size FO-rewritings for different classes of OMQs was shown to be equivalent to major open problems in computational and circuit complexity such as \u2018NL/poly \u2286 NC1?\u2019, \u2018LOGCFL/poly \u2286 NC1?\u2019 and \u2018NP/poly \u2286 NC1?\u2019\nWe also determined the combined complexity of answering OMQs from the considered classes. In particular, we showed that OMQ answering is tractable\u2014either NL- or LOGCFL-complete\u2014 for bounded-depth ontologies coupled with bounded treewidth CQs, as well as for arbitrary ontologies paired with tree-shaped queries with a bounded number of leaves. We point out that membership in LOGCFL implies that answering OMQs from the identified tractable classes can be \u2018profitably parallelised\u2019 (for details, consult [33]).\nComparing the two sides of Fig. 2, we remark that the class of tractable OMQs nearly coincides with the OMQs admitting polynomial-size NDL-rewritings (the only exception being OMQs with ontologies of depth 1 and arbitrary CQs). However, the LOGCFL and NLmembership results cannot be immediately inferred from the existence of polynomial-size NDL-rewritings, since evaluating polynomial-size NDL-queries is a PSpace-complete problem in general. In fact, much more work is required to construct NDL-rewritings that can be evaluated in LOGCFL and NL, which will be done in a follow-up publication; see technical report [8].\nAlthough the present work gives comprehensive solutions to the succinctness and combined complexity problems formulated in Section 1, it also raises some interesting and challenging questions:\n(1) What is the size of rewritings of OMQs with a fixed ontology? (2) What is the size of rewritings of OMQs with ontologies in a fixed signature? (3) Is answering OMQs with CQs of bounded treewidth and ontologies of finite depth fixed-\nparameter tractable if the ontology depth is the parameter? (4) What is the size of rewritings for OMQs whose ontologies do not contain role inclusions,\nthat is, axioms of the form \u033a(x, y) \u2192 \u033a\u2032(x, y)?\nAnswering these questions would provide further insight into the difficulty of OBDA and could lead to the identification of new classes of well-behaved OMQs.\nAs far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data. The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.\nFinally, the focus of this paper was on the ontology language OWL2QL that has been designed specifically for OBDA via query rewriting. However, in practice ontology designers often require constructs that are not available in OWL2QL. Typical examples are axioms such as A(x) \u2192 B(x)\u2228C(x) and P (x, y)\u2227A(y) \u2192 B(x). The former is a standard covering constraint in conceptual modelling, while the latter occurs in ontologies such as SNOMED CT. There are at least two ways of extending the applicability of rewriting techniques to a wider class of ontology languages. A first approach relies upon the observation that although many ontology languages\ndo not guarantee the existence of rewritings for all ontology-query pairs, it may still be the case that the queries and ontologies typically encountered in practice do admit rewritings. This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38]. A second approach consists in replacing an ontology formulated in a complex ontology language (which lacks efficient query answering algorithms) by an ontology written in a simpler language, for which query rewriting methods can be employed. Ideally, one would show that the simpler ontology is equivalent to the original with regards to query answering [14], and thus provides the exact set of answers. Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78])."}, {"heading": "A Proof of Theorem 5", "text": "Theorem 5 (i) For any OMQ Q(x), the formulas qtw(x) and q \u2032 tw(x) are equivalent, and\nso q\u2032tw(x) is a PE-rewriting of Q(x) over complete data instances. (ii) Theorem 4 continues to hold for f\u25bdQ replaced by f H Q.\nProof. Let Q(x) = (T , q(x)) and q(x) = \u2203y \u03d5(x,y). We begin by showing that for every tree witness t for Q(x), we have the following chain of equivalences:\n\u2227\nR(z,z\u2032)\u2208q t\n(z = z\u2032) \u2227 \u2228\nt is \u033a-initiated\n\u2227\nz\u2208tr\u222ati \u033a\u2217(z) \u2261\n\u2227\nz,z\u2032\u2208tr\u222ati (z = z\u2032) \u2227\n\u2228\nt is \u033a-initiated\n\u2227\nz\u2208tr\u222ati \u033a\u2217(z)\n\u2261 \u2203z0 ( \u2227\nz\u2208tr\u222ati (z = z0) \u2227\n\u2228\nt is \u033a-initiated\n\u033a\u2217(z0) ) \u2261 \u2203z0 ( \u2227\nz\u2208tr\u222ati (z = z0) \u2227\n\u2228\nt generated by \u03c4\n\u03c4(z0) ) ,\nwhere z0 is a fresh variable. The first equivalence follows from the transitivity of equality and the fact that every pair of variables z, z\u2032 in a tree witness must be linked by a sequence of binary atoms. The following equivalence can be readily verified using first-order semantics. For the final equivalence, we use the fact that if t is \u033a-initiated and T |= \u03c4(x) \u2192 \u2203y \u033a(x, y), then t is generated by \u03c4 , and conversely, if t is generated by \u03c4 , then there is some \u033a that initiates t and is such that T |= \u03c4(x) \u2192 \u2203y \u033a(x, y).\nBy the above equivalences, the query q\u2032tw(x) can be equivalently expressed as follows:\n\u2203y \u2228\n\u0398\u2286\u0398Q independent\n( \u2227\nS(z)\u2208q\\q\u0398\nS(z) \u2227 \u2227\nt\u2208\u0398\n( \u2203z0 (\n\u2227\nz\u2208tr\u222ati (z = z0) \u2227\n\u2228\nt is generated by \u03c4\n\u03c4(z0)) )) .\nFinally, we observe that, for every independent \u0398 \u2286 \u0398Q, the variables that occur in some ti, for t \u2208 \u0398, do not occur in t\u2032\ni for any other t\u2032 \u2208 \u0398. It follows that if z \u2208 ti and t \u2208 \u0398, then the only\noccurrence of z in the disjunct for \u0398 is in the equality atom z = z0. We can thus drop all such atoms, while preserving equivalence, which gives us precisely the tree-witness rewriting qtw(x). In particular, this means that q\u2032tw(x) is a rewriting of Q(x) over complete data instances.\nTo establish the second statement, let \u03a6 be a Boolean formula that computes\nfHQ = \u2228\n\u0398\u2286\u0398Q independent\n( \u2227\nS(z)\u2208q\\q\u0398\npS(z) \u2227 \u2227\nt\u2208\u0398\n( \u2227\nR(z,z\u2032)\u2208q t\npz=z\u2032 \u2227 \u2228\nt is \u033a-initiated\n\u2227\nz\u2208tr\u222ati p\u033a\u2217(z)\n))\n,\nand let q\u2032(x) be the FO-formula obtained by replacing each pz=z\u2032 in \u03a6 with z = z\u2032, each pS(z) with S(z), each p\u033a\u2217(z) with \u2228\nT |=\u03c4(x)\u2192\u2203y \u033a(x,y) \u03c4(z), and prefixing the result with \u2203y. Recall that the modified rewriting q\u2032tw(x) was obtained by applying this same transformation to the original monotone Boolean formula for fHQ. Since \u03a6 computes f H Q, q \u2032(x) and q\u2032tw(x) are equivalent FOformulas. As we have already established that q\u2032tw(x) is a rewriting of Q(x), the same must be true of q\u2032(x). The statement regarding NDL-rewritings can be proved similarly to the proof of Theorem 4 (ii)."}, {"heading": "B Proof of Theorem 11", "text": "Theorem 11 (i) Any tree hypergraph H is isomorphic to a subgraph of H(TH). (ii) Any monotone THGP based on a tree hypergraph H computes a subfunction of the\nprimitive evaluation function f\u25b3TH .\nProof. (i) Fix a tree hypergraph H = (V,E) whose underlying tree T = (VT , ET ) has vertices VT = {1, . . . , n}, for n > 1, and 1 is a leaf of T . The directed tree obtained from T by fixing 1 as the root and orienting the edges away from 1 is denoted by T 1 = (VT , E 1 T ). By definition, each e \u2208 E induces a convex subtree T e = (Ve, Ee) of T 1. Since, for each subtree T e, the OMQ TH has a tree-witness te with\nt e r = { zi | i in on the boundary of e }, t e i = { zi | i is in the interior of e } \u222a { yij | (i, j) \u2208 e },\nit follows that H is isomorphic to the subgraph of H(TH) obtained by removing all superfluous hyperedges and all vertices corresponding to atoms with Sij .\n(ii) Suppose that P is bssed on a tree hypergraph H . Given an input \u03b1 for P , we define an assignment \u03b3 for the predicates in TH = (T , q) by taking each \u03b3(Rij) and \u03b3(Sij) to be the value of the label of (i, j) \u2208 E1T under \u03b1 and \u03b3(Ae) = 1 for all e \u2208 E (\u03b3(R\u03b6) = 0, for all normalisation predicates R\u03b6). We show that for all \u03b1 we have\nP (\u03b1) = 1 iff f\u25b3TH (\u03b3) = 1.\nObserve that the canonical model CT ,A(\u03b3) contains two labelled nulls, we and w \u2032 e, for each e \u2208 E, satisfying\nCT ,A(\u03b3) |= \u2227\n(i,j)\u2208Ee, i=re Rrej(a, we) \u2227\n\u2227\n(i,j)\u2208Ee, j\u2208Le Sij(we, a) \u2227\n\u2227\n(i,j)\u2208Ee, i6=re Rij(w\n\u2032 e, we) \u2227\n\u2227\n(i,j)\u2208Ee, j /\u2208Le\nSij(we, w \u2032 e).\n(\u21d2) Suppose that P (\u03b1) = 1. Then there exists an independent E\u2032 \u2286 E that covers all zeros of \u03b1. We show T ,A(\u03b3) |= q (that is, f\u25b3TH (\u03b3) = 1). Define a mapping h as follows:\nh(zi) =\n{\nw\u2032e, if i is in the interior of e \u2208 E \u2032, a, otherwise, h(yij) =\n{\nwe, if (i, j) \u2208 e \u2208 E\u2032,\na otherwise.\nNote that h is well-defined: since E\u2032 is independent, its hyperedges share no interior, and there can be at most one hyperedge e \u2208 E\u2032 containing any given vertex (i, j).\nIt remains to show that h is a homomorphism from q to CT ,A(\u03b3). Consider a pair of atoms Rij(zi, yij) and Sij(yij , zj) in q. Then (i, j) \u2208 E1T . If there is e \u2208 E\n\u2032 with(i, j) \u2208 e then there are four possibilities to consider:\n\u2013 if neither i nor j is in the interior then, since Te is a tree and (i, j) is its edge, the only possibility is e = {(i, j)}, whence h(zi) = h(zj) = a and h(yij) = we; \u2013 i is on the boundary and j is internal, then h(zi) = a, h(yij) = we, and h(zj) = w \u2032 e; \u2013 if j is on the boundary and i is internal, then this case is the mirror image; \u2013 if both i and j are in the interior, then h(zi) = h(zj) = w \u2032 e and h(yij) = we.\nOtherwise, the label of (i, j) must evaluate to 1 under \u03b1, whence A(\u03b3) contains Rij(a, a) and Sij(a, a) and we set h(zi) = h(yij) = h(zj) = a. In all cases, h preserves the atoms Rij(zi, yij) and Sij(yij , zj), and so h is indeed a homomorphism.\n(\u21d2) Suppose that f\u25b3TH (\u03b3) = 1. Then T ,A(\u03b3) |= q, and so there is a homomorphism h : q \u2192 CT ,A(\u03b3). We show that there is an independent E \u2032 \u2286 E that covers all zeros of \u03b1. Let E\u2032 be the\nset of all e \u2208 E such that h\u22121(we) 6= \u2205 (that is, we is in the image of h). To show that E\u2032 is independent, we need the following claim:\nClaim. If h\u22121(we) 6= \u2205, then h(yij) = we for all (i, j) \u2208 e. Proof of claim. Let re be the root of T e and Le its leaves. Pick some variable z \u2208 h\u22121(we) such that there is no z\u2032 \u2208 h\u22121(we) higher than z in q (we use the ordering of variables induced by the tree T 1). Observe that z cannot be of the form zj , because then q would contain some atom Rj\u2113(zj , yj\u2113) or S\u2113j(y\u2113j, zj), but we has no outgoing Rj\u2113 or S \u2212 \u2113j arcs in CT ,A(\u03b3). It follows that z is of the form yj\u2113, for some j, \u2113. By considering the available arcs leaving we again, we conclude that (j, \u2113) \u2208 e. We next show that j = re. Suppose that this is not the case. Then, there must be (p, j) \u2208 e with (p, j) \u2208 T 1. A simple examination of the axioms in T shows that the only way for h to satisfy the atom Rj\u2113(zj , yj\u2113) is to map zj to w \u2032 e. It follows that to satisfy the atom Spj(ypj , zj), we must put h(ypj) = we contrary to the assumption that z = yj\u2113 was a highest vertex in h\u22121(we). Thus, j = re. Now, using a simple inductive argument on the distance from zre , and considering the possible ways of mapping the atoms of q, we can show that h(yij) = we for every (i, j) \u2208 e. (end proof of claim)\nSuppose that there are two distinct hyperedges e, e\u2032 \u2208 E\u2032 that have a non-empty intersection: (i, j) \u2208 e\u2229 e\u2032. We know that either yij or yji occurs in q, and we can assume the former without loss of generality. By the claim, we obtain h(yij) = we = we\u2032 , a contradiction. Therefore, E\n\u2032 is independent. We now show that it covers all zeros. Let (i, j) be such that its label evaluates to 0 under \u03b1, and assume again without loss of generality that yij occurs in q. Then A(\u03b3) does not contain Rij(a, a), so the only way h can satisfy the atom Rij(zi, yij) is by mapping yij to some we with (i, j) \u2208 e. It follows that there is an e \u2208 E\u2032 such that (i, j) \u2208 e, so all zeros of \u03b1 are covered by E\u2032. We have thus shown that E\u2032 is an independent subset of E that covers all zeros of \u03b1, and hence, P (\u03b1) = 1."}, {"heading": "C Proof of Proposition 4", "text": "Proposition 4. (i) For any tree hypergraph H of degree \u2264 d, there is a monotone THGP of size O(|H |) that computes fH and such that its hypergraph is of degree \u2264 max(2, d).\n(ii) For every generalised THGP P over n variables, there is a THGP P \u2032 computing the same function and such that |P \u2032| \u2264 n \u00b7 |P |.\nProof. (i) Consider a hypergraph H = (V,E) based on a tree T = (VT , ET ) with V = ET . We label each v \u2208 V with a variable pv and, for each e \u2208 E, we choose some ve \u2208 \u22c3 e, add fresh vertices ae and be with edges {ve, ae} and {ae, be} to T as well as a new hyperedge e\u2032 = [ve, be] to E. We label the segment [ve, ae] with 1 and the segment [ae, be] with pe. We also extend e to include the segment [ve, ae]. We claim that the resulting THGP P computes fH . Indeed, for any input \u03b1 with \u03b1(pe) = 0, we have to include the edge e\n\u2032 into the cover, and so cannot include the edge e itself. Thus, P (\u03b1) = 1 iff there is an independent set E of hyperedges with \u03b1(pe) = 1, for all e \u2208 E, covering all zeros of the variables pv. It follows that P computes fH .\n(ii) Let P be a generalised THGP based on a hypergraph H = (V,E) with the underlying tree T = (VT , ET ) such that V = ET . To construct P\n\u2032, we split every vertex v \u2208 V (which is an edge of T ) labelled with\n\u2227k i=1 li into k new edges v1, . . . , vk and label vi with li, for 1 \u2264 i \u2264 k;\neach hyperedge containing v will now contain all the vi. It is easy to see that P (\u03b1) = P \u2032(\u03b1), for any valuation \u03b1. Since k \u2264 n, we have |P \u2032| \u2264 n \u00b7 |P |. It should be clear that the degree of P \u2032 and the number of leaves in it are the same as in P ."}, {"heading": "D Proof of Theorem 12", "text": "Theorem 12. For every OMQ Q(x) = (T , q(x)) with a fundamental set \u2126Q and with q of treewidth t, the generalised monotone THGP PQ computes f H Q and is of size polynomial in |q| and |\u2126Q|t.\nProof. By [29, Lemma 11.9], we can assume that the tree T in the tree decomposition of q has at most N , N \u2264 |q|, nodes. Recall that M = |\u2126Q|t is the number of bag types. We claim that PQ\n\u2013 contains at most (2M + 1)N vertices and at most N(M +M2) hyperedges;\n\u2013 and has labels with at most 3|q| conjuncts.\nThe vertices of the hypergraph of PQ correspond to the edges of T \u2032, and there can be at most N \u00b7 (2M + 1) of them, because there can be no more than N edges in T , and each is replaced by a sequence of 2M + 1 new edges. The hyperedges are of two types: Eki (where 1 \u2264 i \u2264 N and 1 \u2264 k \u2264 M) and Ek\u2113ij (where (i, j) correspond to an edge in T and 1 \u2264 k, \u2113 \u2264 M). It follows that the total number of hyperedges cannot exceed N(M +M2). Finally, a simple examination of the labelling function shows that there can be at most 3|q| conjuncts in each label. Indeed, given i, j and k, each atom S(z) with z \u2286 \u03bb(Ni) generates either 1 or 3 propositional variables in the label of {ukij , v k ij}, and |q| is the upper bound for the number of such atoms.\nTo complete the proof, we show that PQ computes f H Q: for any valuation \u03b1,\nfHQ(\u03b1) = 1 iff PQ(\u03b1) = 1.\n(\u21d2) Let \u03b1 be such that fHQ(\u03b1) = 1. Then we can find an independent \u0398 \u2286 \u0398Q such that \u03b1 satisfies the corresponding disjunct of fHQ:\n\u2227\nS(z)\u2208q\\q\u0398\npS(z) \u2227 \u2227\nt\u2208\u0398\n( \u2227\nR(z,z\u2032)\u2208q t\npz=z\u2032 \u2227 \u2228\nt is \u033a-initiated\n\u2227\nz\u2208tr\u222ati p\u033a\u2217(z)\n)\n. (14)\nFor every t \u2208 \u0398, let \u033at be a role that makes the disjunction hold. Since t is \u033at-initiated, we can choose a homomorphism ht : qt \u2192 C \u033at(a) T such that, for every z \u2208 ti, ht(z) is of the form a\u033atw, for some w . With each node N in the tree decomposition (T, \u03bb) we associate the type w of N by taking, for all z \u2208 \u03bb(N):\nw[\u03bdN (z)] =\n{\nw, if z \u2208 ti and ht(z) = aw, for some t \u2208 \u0398,\n\u03b5, otherwise.\nObserve that w is well-defined since the independence of \u0398 guarantees that every variable in q can appear in ti for at most one t \u2208 \u0398. We show that w is compatible with N . Consider a unary atom A(z) \u2208 q such that z \u2208 \u03bb(N) and w[\u03bdN (z)] 6= \u03b5. Then there must be t \u2208 \u0398 such that z \u2208 ti, in which case ht(z) = aw[\u03bdN (z)]. Let \u033a be the final symbol in ht(z). Since ht : qt \u2192 C \u2203y\u033at(a,y) T is a homomorphism, we have T |= \u2203y \u033a(y, x) \u2192 A(x). Consider now a binary atom P (z, z\u2032) \u2208 q such that z, z\u2032 \u2208 \u03bb(N) and either w[\u03bdN (z)] 6= \u03b5 or w[\u03bdN (z\u2032)] 6= \u03b5. We assume w.l.o.g. that the former is true (the other case is handled analogously). By definition, there is t \u2208 \u0398 such that z \u2208 ti and ht(z) = aw[\u03bdN (z)]. Since z \u2208 ti and P (z, z\u2032) \u2208 q, by the definition of tree witnesses, z\u2032 \u2208 tr \u222a ti. Since ht : qt \u2192 C \u2203y\u033at(a,y) T is a homomorphism, one of the following holds:\n\u2013 w[\u03bdN (z \u2032)] = w[\u03bdN (z)] and T |= P (x, x); \u2013 w[\u03bdN (z)] = w[\u03bdN (z \u2032)] \u00b7 \u033a for some \u033a with T |= \u033a(y, x) \u2192 P (x, y); \u2013 w[\u03bdN (z \u2032)] = w[\u03bdN (z)] \u00b7 \u033a for some \u033a with T |= \u033a(x, y) \u2192 P (x, y).\nThis establishes the second part of the compatibility condition. Next, we show that the pairs associated with different nodes in T are compatible. Consider a pair of nodes N and N \u2032 and their typesw andw\u2032. It is clear that, by construction,w[\u03bdN (z)] = w\u2032[\u03bdN \u2032(z)], for all z \u2208 \u03bb(N)\u2229\u03bb(N \u2032).\nLet w1, . . . ,wM be all the bag types. Consider now the tree hypergraph PQ, and let E \u2032 be\nthe set consisting of the following hyperedges:\n\u2013 for every Ni in T , the hyperedge E k i = [Ni, u k ij1 , . . . , ukijn ], where k is such that wk is the type of Ni, and Nj1 , . . . , Njn are the neighbours of Ni; \u2013 for every pair of adjacent nodes Ni, Nj in T , the hyperedge E k\u2113 ij = [v k ij , v \u2113 ji], where k and \u2113\nare such that wk and w\u2113 are the types of Ni and Nj, respectively.\nNote that all these hyperedges are present in the hypergraph of PQ because we have shown that the type of each node Ni is compatible with it and that the pairs of types of Ni and Nj are compatible with the pair (Ni, Nj). It is easy to see that E\n\u2032 is independent, since whenever we include Eki or E k\u2113 ij , we do not include any E k\u2032 i or E k\u2032\u2113 ij for k\n\u2032 6= k. It remains to show that every vertex of the hypergraph of PQ that is not covered by E\n\u2032 evaluates to 1 under \u03b1. Observe first that most of the vertices are covered by E\u2032. Specifically:\n\u2013 {Ni, u1ij} is covered by E k i ; \u2013 {vkij , u k+1 ij } is covered either by E n i (if n \u2264 k + 1) or by E n\u2113 ij (if n > k + 1); \u2013 {vMij , v M ji } is covered by E k\u2113 ij ; \u2013 {ukij, v k ij} is covered by E n i if k < n, and by E n\u2113 ij if n > k.\nThus, the only type of vertex not covered by E\u2032 is of the form {ukij, v k ij}, where wk is the type of Ni. In this case, by definition, {ukij , v k ij} is labelled by the following variables:\n\u2013 pS(z), if S(z) \u2208 q, z \u2286 \u03bb(Ni) and wk[\u03bdNi(z)] = \u03b5, for all z \u2208 z; \u2013 p\u033a\u2217(z), if A(z) \u2208 q, z \u2208 \u03bb(Ni) and wk[\u03bdNi(z)] = \u033aw; \u2013 p\u033a\u2217(z), p\u033a\u2217(z\u2032) and pz=z\u2032 , if S(z, z\n\u2032) \u2208 q (possibly with z = z\u2032), z, z\u2032 \u2208 \u03bb(Ni) and either wk[\u03bdNi(z)] = \u033aw or wk[\u03bdNi(z \u2032)] = \u033aw.\nFirst suppose that pS(z) appears in the label of {u k ij , v k ij}. Then wk[\u03bdNi(z)] = \u03b5, for all z \u2208 z, and hence there is no variable in S(z) that belongs to any ti for t \u2208 \u0398. It follows that S(z) \u2208 q \\q\u0398, and since (14) is satisfied, the variable pS(z) evaluates to 1 under \u03b1. Next suppose that one of p\u033a\u2217(z), p\u033a\u2217(z\u2032) and pz=z\u2032 is part of the label. We focus on the case where these variables came from a binary atom (third item above), but the proof is similar for the case of a unary atom (second item above). We know that there is some atom S(z, z\u2032) \u2208 q with z, z\u2032 \u2208 \u03bb(Ni) and either wk[\u03bdNi(z)] = \u033aw or wk[\u03bdNi ] = \u033aw. It follows that there is a tree witness t \u2208 \u0398 such that z, z\u2032 \u2208 tr \u222a ti. This means that the atom pz=z\u2032 is a conjunct of (14), and so it is satisfied under \u03b1. Also, either wk[\u03bdNi(z)] = ht(z) or wk[\u03bdNi(z\n\u2032)] = ht(z\u2032) is of the form \u033aw, and, since all non-empty words in the image of ht begin by \u033at, we obtain \u033a = \u033at. Since \u033at was chosen so that \u2227\nz\u2208tr\u222ati p\u033a\u2217(z) is satisfied under \u03b1, both p\u033a\u2217(z) and p\u033a\u2217(z\u2032) evaluate to 1 under \u03b1. Therefore, E\u2032 is independent and covers all zeros under \u03b1, which means that PQ(\u03b1) = 1.\n(\u21d0) Suppose PQ(\u03b1) = 1, i.e., there is an independent subset E\u2032 of the hyperedges in PQ that covers all vertices evaluated to 0 under \u03b1. It is clear from the construction of PQ that E \u2032 contains exactly one hyperedge of the form Eki for every node Ni in T , and so we can associate with every node Ni the unique index \u00b5(Ni) = k. We also know that E\n\u2032 contains exactly one hyperedge of the form Ek\u2113ij for every edge {Ni, Nj} in T . Moreover, if we have hyperedges E k i and Ek \u2032\u2113\nij (respectively, E \u2113 j and E\nk\u2113\u2032 ij ), then k = k \u2032 (respectively, \u2113 = \u2113\u2032). It also follows from\nthe definition of PQ that every w\u00b5(Ni) is compatible with Ni, and pairs (w\u00b5(Nj),w\u00b5(Nj)) are compatible for adjacent nodes Ni, Nj . Using the compatibility properties and the connectedness condition of tree decompositions, we can conclude that the pairs assigned to any two nodes Ni and Nj in T are compatible. Since every variable must appear in at least one node label, it follows that we can associate a unique word wz with every variable z in q.\nSince all zeros are covered by E\u2032, we know that for every node Ni, the following variables are assigned to 1 by \u03b1:\n\u2013 pS(z), if S(z) \u2208 q, z \u2286 \u03bb(Ni) and wz = \u03b5, for z \u2208 z; \u2013 p\u033a\u2217(z), if A(z) \u2208 q, z \u2208 \u03bb(Ni), and wz = \u033aw; (\u22c6) \u2013 p\u033a\u2217(z), p\u033a(z\u2032) and pz=z\u2032 , if S(z, z\n\u2032) \u2208 q (possibly with z = z\u2032), z, z\u2032 \u2208 \u03bb(Ni) and either wz = \u033aw or wz\u2032 = \u033aw.\nNow let \u2261 be the smallest equivalence relation on the atoms of q that satisfies the following condition, for every variable z in q,\nif wz 6= \u03b5 and z occurs in both S1(z1) and S2(z2), then S1(z1) \u2261 S2(z2).\nLet q1, . . . , qn be the subqueries corresponding to the equivalence classes of \u2261. It is easily verified that the qi are pairwise disjoint. Moreover, if qi contains only variables z with wz = \u03b5, then qi consists of a single atom. We can show that the remaining qi correspond to tree witnesses.\nClaim. For every qi that contains a variable z with wz 6= \u03b5:\n(1) there is a role \u033ai such that every wz 6= \u03b5 (with z a variable in qi) begins by \u033ai; (2) there is a homomorphism hi : qi \u2192 C \u2203y\u033ai(a,y) T such that hi(z) = awz for every variable z in\nqi; (3) there is a tree witness ti for Q that is \u033ai-initiated and such that qi = qti\nProof of claim. By the definition of qi, there exists a sequence Q0, . . . , Qn of subsets of q such that Q0 = {S0(z0)} \u2286 qi contains a variable z0 with wz0 6= \u03b5, Qn = qi, and for every 0 \u2264 \u2113 < n, Q\u2113+1 is obtained from Q\u2113 by adding an atom that contains a variable z that appears in Q\u2113 and is such that wz 6= \u03b5. By construction, every atom in qi contains a variable z with wz 6= \u03b5. Let \u033ai be the first letter of the word wz0 , and for every 0 \u2264 \u2113 \u2264 n, let h\u2113 be the function that maps every variable z in Q\u2113 to awz .\nStatements 1 and 2 can be shown by induction. The base case is trivial. For the induction step, suppose that at stage \u2113, we know that every variable z in Q\u2113 with wz 6= \u03b5 begins by \u033ai, and that h\u2113 is a homomorphism of Q\u2113 into the canonical model C \u2203y\u033ai(a,y) T that satisfies h\u2113(y) = awz . We let S(z) be the unique atom in Q\u2113+1\\Q\u2113. Then S(z) contains a variable z that appears in Q\u2113 and is such that wz 6= \u03b5. If S(z) = B(z) or S(z) = R(z, z), then Statement 1 for wz is immediate. For Statement 2, we let N be a node in T such that z \u2208 \u03bb(N). Since wN is compatible with N , it follows that, if S(z) = B(z), then wz ends by a role \u033a with T |= \u2203y \u033a(y, x) \u2192 B(x), and, if S(z) = R(z, z), then T |= R(x, x), which proves Statement 2. Next, consider the case when S(z) contains two variables, that is, it is of the form R(z, z\u2032) or R(z, z\u2032). We give the argument for the former (the the latter is analogous). Let N be a node in T such that {z, z\u2032} \u2286 \u03bb(N). Since wN is compatible with N , either\n\u2013 wz\u2032 = wz\u033a with T |= \u033a(x, y) \u2192 R(x, y), or \u2013 wz = wz\u2032\u033a with T |= \u033a(y, x) \u2192 R(x, y).\nSince wz begins with \u033ai, the same holds for wz\u2032 unless wz\u2032 = \u03b5, which proves Statement 1. It is also clear from the way we defined h\u2113+1 that it is homomorphism from Q\u2113+1 to C \u2203y\u033ai(a,y) T , so Statement 2 holds. Statement 3 now follows from Statements 1 and 2, the definition of qi and the definition of tree witnesses. (end proof of claim)\nLet \u0398 consist of all the tree witnesses ti obtained in the claim. As the qi are disjoint, the set {q\nti | ti \u2208 \u0398} is independent. We show that \u03b1 satisfies the disjunct of fHQ that corresponds\nto \u0398; cf. (14). First, consider some S(z) \u2208 q \\ q\u0398. Then, for every variable z in S(z), we have wz = \u03b5. Let N be a node in T such that z \u2286 \u03bb(N). Then wz = \u03b5, for all z \u2208 z. It follows from (\u22c6) that \u03b1(pS(z)) = 1. Next, consider a variable pz=z\u2032 such that there is an atom S(z) \u2208 qti with z = {z, z\u2032}. Since S(z) \u2208 qi, either wz 6= \u03b5 or wz\u2032 6= \u03b5. It follows from (\u22c6) that \u03b1(pz=z\u2032) = 1. Finally, let us consider a tree witness ti \u2208 \u0398, and let \u033ai be the role from the claim. We show that p\u033a\u2217i (z) = 1 for every variable z in t i, which will imply that the final disjunction is satisfied by \u03b1. Consider a variable z in ti. By the construction of the query qi = qti , it contains a binary atom S(z) with z, z\u2032 \u2208 z and either wz 6= \u03b5 or wz\u2032 6= \u03b5. By the definition of tree decompositions, there is a node N in T with z, z\u2032 \u2208 \u03bb(N). Then, by Statement 1 of the claim, either wz = \u033aiw or wz\u2032 = \u033aiw. Now we can apply (\u22c6) to obtain p\u033a\u2217\ni (z) = 1, as required."}, {"heading": "E Proofs of Theorems 15 and 16", "text": "Theorem 15 (general case). NL/poly = THGP(\u2113) and mNL/poly = mTHGP(\u2113), for any \u2113 \u2265 2.\nProof. Suppose a polynomial-size THGP P based on a tree hypergraph H with at most \u2113 leaves computes a Boolean function f . We show how to construct a polynomial-size NBP that computes the same f . By Theorem 16 (to be proved below), fH can be computed by a polynomial-size NBP B. We replace the vertex variables pv in labels of B by the corresponding vertex labels in P and fix all the edge variables pe to 1; see the proof of Proposition 2 (i). Clearly, the resulting NBP B\u2032 is as required.\nThe converse direction is given in Section 6.3.\nTheorem 16. Fix \u2113 \u2265 2. For any tree hypergraph H based on a tree with at most \u2113 leaves, the function fH can be computed by an NBP of size polynomial in |H |.\nProof. Let H = (V,E) be a tree hypergraph and T = (VT , ET ) its underlying tree (V = ET and each e \u2208 E induces a convex subtree Te of T ). Pick some vertex r \u2208 VT and fix it as a root of T . We call an independent subset F \u2286 E of hyperedges flat if every simple path in T with endpoint r intersects at most one of Te, for e \u2208 F . Note that every flat subset can contain at most \u2113 hyperedges, so the number of flat subsets is bounded by a polynomial in |H |. We denote by [F ] the union of subtrees Te, for all e \u2208 F ([F ] is a possibly disconnected subgraph of T ). Flat subsets can be partially ordered by taking F F \u2032 if every simple path between the root r and a vertex of [F \u2032] intersects [F ]. As usual, F \u227a F \u2032 if F F \u2032 but F 6= F \u2032.\nThe required NBP P is based on the graph G = (VP , EP ) with\nVP = { uF , u\u0304F | F is flat } \u222a { s, t } , EP = { (s, uF ), (u\u0304F , t), (uF , u\u0304F ) | F is flat } \u222a { (u\u0304F , uF \u2032) | F, F \u2032 are flat and F \u227a F \u2032 } .\nTo define labels, we introduce some notation first for sets of edges of T (which are sets of vertices of H). For a flat F , let before(F ) be the edges of T that lie outside [F ] and are accessible from the root r via paths not passing through [F ]; we denote by after(F ) the edges of T outside [F ] that are accessible from r only via paths passing through [F ]. Finally, for flat F and F \u2032 with F \u227a F \u2032, we denote by between(F, F \u2032) the set of edges in T \u2018between\u2019 [F ] and [F \u2032], that is those edges of T outside [F ] and [F \u2032] that are accessible from [F ] via paths not passing through [F \u2032] but are not accessible from the root r via a path not passing through [F ]; see Fig. 21. Now we are ready to define the labelling for edges of G:\n\u2013 each (uF , u\u0304F ) is labelled with the conjunction of pe for e \u2208 F ; \u2013 each (s, uF ) is labelled with the conjunction of pv for v \u2208 before(F ); \u2013 each (u\u0304F , uF \u2032) is labelled with the conjunction of pv for v \u2208 between(F, F \u2032); \u2013 each (u\u0304F , t) is labelled with the conjunction of pv for v \u2208 after(F ).\nWe claim that under any valuation \u03b1 of pe and pv, there is a path from s to t in G all of whose labels evaluate to 1 under \u03b1 iff fH(\u03b1) = 1, that is, iff there is an independent (not necessarily flat) subset E\u2032 \u2286 E such that \u03b1(pe) = 1 for all e \u2208 E\u2032 and \u03b1(pv) = 1 for all v \u2208 V \\VE\u2032 . Indeed, any such E\u2032 splits into flat \u2018layers\u2019 F 1, F 2, . . . Fm that form a path\ns \u2192 uF 1 \u2192 u\u0304F 1 \u2192 uF 2 \u2192 \u00b7 \u00b7 \u00b7 \u2192 u\u0304Fm \u2192 t\nin G and whose edge labels evaluate to 1: take F 1 to be the set of all hyperedges from E\u2032 that are accessible from r via paths which do not cross (that is come in and go out) any hyperedge of E\u2032; take F 2 to be the set of all edges from E\u2032 \\ F 1 that are accessible from r via paths that do not cross any hyperedge of E\u2032 \\F 1, and so on. Conversely, any path leading from s to t gives us a covering E\u2032, which is the union of all flat sets that occur in the subscripts of vertices on this path."}, {"heading": "F Proof of Theorems 17 and 18", "text": "Lemma 2. Any semi-unbounded fan-in circuit C of and-depth d is equivalent to a semiunbounded fan-in circuit C \u2032 of size 2d|C| and and-depth d such that, for each n \u2264 d, C \u2032 satisfies \u22c3\ng\u2208Sn left(g) \u2229\n\u22c3\ng\u2208Sn right(g) = \u2205.\nProof. We show by induction on n that we can reconstruct the circuit in such a way that the property holds for all i \u2264 n, the and-depth of the circuit does not change and the size of the circuit increases at most by the factor of 2n.\nConsider a subcircuit \u22c3 g\u2208Sn left(g) of C, take its copy C \u2032\u2032 and feed the outputs of C\u2032\u2032 as left inputs to and-gates in Sn. This at most doubles the size of the circuit and ensures the property for Sn. Now apply the induction hypothesis to both C \u2032\u2032 and \u22c3\ng\u2208Sn right(g) (which do\nnot intersect). The size of the resulting circuit will increase at most by the factor of 2n\u22121 and the property for Si for i < n will be ensured. \u2293\u2294\nLet gi be a gate in C. We denote by Ti the subtree of T with the root vi and, given an input \u03b1, we say that Ti can be covered under \u03b1 if the hypergraph with the underlying tree Ti has an independent subset of hyperedges that are wholly in Ti and cover all zeros under \u03b1.\nLemma 3. For a given input \u03b1 and any i, the gate gi outputs 1 iff Ti can be covered.\nProof. We prove the claim by induction on i. If gi is an input gate and outputs 1, then the label of the edge {vi, ui} is evaluated into 1 under \u03b1, and the remainder of Ti can be covered by a set of [wj , uj ]-hyperedges. Conversely, if an input gate gi outputs 0, then no hyperedge can cover {vi, ui}.\nIf gi = gj \u2227 gk is an and-gate and outputs 1, then both its inputs output 1. We cover both subtrees corresponding to the inputs (by induction hypothesis) and add to the covering the hyperedge [vi, vj , vk], which covers Ti. Conversely, any covering of zeros in Ti must include the hyperedge [vi, vj , vk], and so the subtrees Tj and Tk must be covered. Thus, by the induction hypothesis, gj and gk should output 1, and so does gi.\nIf gi = gj1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 gjk is an or-gate and outputs 1, then one of its inputs, say, gj , is 1. By the induction hypothesis, we cover its subtree and add the hyperedge [vi, vj ], which forms a covering of Ti. Conversely, since {vi, ui} is labelled by 0, any covering of Ti must include a hyperedge of the form [vi, vj ] for some j \u2208 {j1, . . . , jk}. Thus Tj must also be covered. By the induction hypothesis, gj outputs 1 and so does gi. \u2293\u2294\nTheorem 18.NC1 = THGPd and mNC1 = mTHGPd, for any d \u2265 3.\nProof. To prove NC1 \u2286 THGP3, consider a polynomial-size formula C, which we represent as a tree of gates g1, . . . , gm enumerated so that j < i whenever gj is an input of gi. We assume that C has negated variables in place of not-gates. We now construct the tree, T , underlying the THGP P we are after: T contains triples of vertices ui, vi, wi partially ordered in the same way as the gi in C. We then remove vertex wm and make vm the root of T . The THGP P is based on the hypergraph whose vertices are the edges of T and whose hyperedges comprise the following:\n\u2013 [ui, uj], for each i < m, where j < i and gj is the input of gi; \u2013 [vi, vj , vk], for each gi = gj \u2227 gk; \u2013 [vi, vj , wk], [vi, wj , vj ], for each gi = gj \u2228 gk.\nFinally, if an input gate gi is a literal l, we label the edge {ui, vi} with l; we label all other edges with 0. It is not hard to check that P is of degree 3, has size polynomial in |C|, and computes the same function as C.\nThe inclusion NC1 \u2287 THGPd follows from the proof of LOGCFL/poly \u2286 THGP in Theorem 17. Indeed, if the degree of the THGP is at most d, then the disjunction in (13) has at most d + 1 disjuncts, and so the constructed circuit has depth O(log s)."}, {"heading": "G Proofs for Section 7", "text": "Theorem 25. For any fixed \u2113 \u2265 2, all tree-shaped OMQs with at most \u2113 leaves have polynomial-size NDL-rewritings.\nProof. Fix \u2113 \u2265 2 and let Q be a tree-shaped OMQ with at most \u2113 leaves. By Theorem 10, H(Q) is a tree hypergraph whose underlying tree has at most \u2113 leaves. By Theorem 16, f\u25bdQ is computable by a polynomial-size monotone NBP, and so, since mNL/poly \u2286 mP/poly, f\u25bdQ can be computed by a polynomial-size monotone Boolean circuit. It remains to apply Theorem 4 (ii).\nTheorem 26. There is an OMQ with ontologies of depth 2 and linear CQs any PE-rewriting of which is of superpolynomial size n\u2126(logn).\nProof. We consider the function f = Reachability. Since f \u2208 mNL/poly, by Theorem 15, there is a polynomial-size monotone HGP that is based on a hypergraph H with underlying tree with 2 leaves and computes f . Consider now the OMQ TH for H defined in Section 5.3, which has an ontology of depth 2. By Theorem 11 (ii), f is a subfunction of f\u25b3TH . By Theorem 6 (i), no PE-rewriting of the OMQ TH can be shorter than n \u2126(logn). \u2293\u2294\nTheorem 28. For any fixed t > 0, all OMQs with the PFSP and CQs of treewidth at most t have polynomial-size NDL-rewritings.\nProof. Fix a t > 0 and a class of OMQs with PFSP. Take an OMQ Q of treewidth at most t from the class. By Theorem 12, there is a polynomial-size monotone THGP that computes fHQ. Since mTHGP \u2286 mLOGCFL/poly \u2286 mP/poly (Theorem 17), fHQ can be computed by a polynomial-size monotone Boolean circuit. It remains to apply Theorem 5 (ii).\nTheorem 30. For any fixed t > 0, all OMQs with ontologies of depth 1 and CQs of treewidth at most t have polynomial-size PE-rewritings.\nThe main argument underlying Theorem 30 was given in the body of the paper. To complete the proof, we give the following two lemmas, which are the modified versions of Theorems 4 and 12 mentioned in the body.\nLemma 4. Theorem 4 continues to hold if f\u25bdQ is replaced by f H\u2032 Q .\nProof. The proof proceeds similarly to the proof of Theorem 5. The key step in the proof is showing that the FO-formula\n\u2203y \u2228\n\u0398\u2286\u0398Q independent\n( \u2227\nS(z)\u2208q\\q\u0398\nS(z) \u2227 \u2227\nt\u2208\u0398\n( \u2227\nR(z,z\u2032)\u2208q t\nz = z\u2032 \u2227 \u2227\nz\u2208tr\u222ati\n\u2228\nt generated by \u03c4\n\u03c4(z) ))\nobtained from fH\u2032Q by replacing variables pS(z), pz=z\u2032 , and p\u2203yPt(z,y) by S(z), z = z \u2032, and \u2228\nt generated by \u03c4 \u03c4(z) respectively is equivalent the tree-witness rewriting qtw.\nLemma 5. In the setting of Section 7.5, for the modified hypergraph program P \u2032Q we still have fP \u2032 Q (v) = fH\u2032Q (v).\nProof. The proof closely follows that of Theorem 12. For the first direction of the proof, the only notable difference is that instead of selecting a role \u033at that satisfies the disjunct corresponding to the tree witness t, we must take the special role Pt. For the second direction, we use the assumption that T is of depth 1 to show that every query qj (constructed according to the equivalence relation) has a single variable vj such that wvj 6= \u03b5. This allows us to prove a stronger version of the claim in which qj = qtj , with t j the unique tree witness with tj i = {vj}, and the selected role \u033aj is equal to the special predicate Ptj associated with t j .\nTheorem 31. All tree-shaped OMQs with ontologies of depth 1 have polynomial-size \u03a04rewritings.\nProof. Take an OMQ Q = (T , q) with T of depth 1 and a tree-shaped q. By Theorems 8 and 10, H(Q) is a polynomial-size tree hypergraph of degree at most 2. By Proposition 4 (i), f\u25bdQ can be computed by a polynomial-size THGP P of degree at most 2. By Theorem 19, there is a polynomial-size monotone \u03a03-circuit computing f \u25bd\nQ. By a simple unravelling argument, it follows that there is polynomial-size monotone Boolean formula computing f\u25bdQ. It remains to apply Theorem 4 (i) and conclude that there is a polynomial-size positive existential \u03a04-rewriting for Q."}, {"heading": "H Proof of LOGCFL membership in Theorem 34", "text": "We say that an iteration of the while loop is successful if the procedure BLQuery does not return false; in particular, if none of the check operations returns false. The following properties can be easily seen to hold by examination of BLQuery and straightforward induction:\nFor every tuple (z 7\u2192 (a, n), z\u2032) \u2208 frontier, z\u2032 is a child of z in T. (15) For every tuple (z 7\u2192 (a, n), z\u2032) \u2208 frontier, we have n \u2264 |stack|. (16) All tuples (z 7\u2192 (a, n), z\u2032) \u2208 frontier with n > 0 share the same a. (17) Once (z 7\u2192 (a, n), z\u2032) is added to frontier, no tuple of the form (z 7\u2192 (a\u2032, n\u2032), z\u2032) (18) can ever be added to frontier.\nIn every successful iteration, either at least one tuple is removed from frontier (19) or frontier is unchanged but one \u033a is popped from the stack. If (z 7\u2192 (a, n), z\u2032) is removed from frontier in a successful iteration, (20) then a tuple of the form (z\u2032 7\u2192 (a\u2032, n\u2032), z\u2032\u2032) is added to frontier,\nfor every child z\u2032\u2032 of z\u2032 in T.\nProposition 5. Every execution of BLQuery terminates.\nProof. A simple examination of BLQuery shows that the only possible source of non-termination is the while loop, which continues as long as frontier is non-empty. By (15) and (18), the total number of tuples that may appear in frontier at any point cannot exceed the number of edges in T , which is itself bounded by |q|. By (18) and (19), every tuple is added at most once and is eventually removed from frontier. Thus, either the algorithm will exit thewhile loop by returning false (if one of the check operations fails), or it will eventually exit the loop after reaching an empty frontier.\nProposition 6. There exists an execution of BLQuery that returns true on input ((T , q),A,a) if and only if T ,A |= q(a).\nProof. (\u21d0) Suppose that T ,A |= q(a). Then there exists a homomorphism h : q \u2192 CT ,A such that h(x) = a. Without loss of generality we may choose h so that the image of h consists of elements aw with |w| \u2264 2|T |+ |q| [4]. We use h to specify an execution of BLQuery((T , q),A,a) that returns true. First, we fix an arbitrary variable z0 as root, and then, we choose the element h(z0) = a0w0. Since h defines a homomorphism of q(a) into CT ,A, the call canMapTail(z0, a0, top(stack)) returns true. We initialise stack to w0 and frontier to {(z0 7\u2192 (a0, |stack|), vi | vi is a child of v0}. Next, we enter the while loop. Our aim is to make the non-deterministic choices to satisfy the following invariant:\nIf (z 7\u2192 (a,m), z\u2032) \u2208 frontier, then h(z) = a stack\u2264m. (21)\nRecall that stack\u2264m denotes the word obtained by concatenating the first m symbols of stack. Observe that before the while loop, property (21) is satisfied. At the start of each iteration of the while loop, we proceed as follows.\n[Case 1.] If frontier contains (z 7\u2192 (a, 0), z\u2032) such that h(z\u2032) \u2208 ind(A), then we choose Option 1. We remove the tuple from frontier and choose the individual a\u2032 = h(z\u2032) for the guess. As a = h(z) (by (21)) and h is a homomorphism, we have (a, a\u2032) \u2208 P CT ,A , for all P (z, z\u2032) \u2208 q, and the call\ncanMapTail(z\u2032, a\u2032, \u03b5) returns true. We thus add (z\u2032 7\u2192 (a\u2032, 0), z\u2032\u2032) to frontier for every child z\u2032\u2032 of z\u2032 in T . These additions to frontier clearly preserve the invariant.\n[Case 2.] If Case 1 does not apply and frontier contains (z 7\u2192 (a, |stack|), z\u2032) such that h(z\u2032) = h(z), then we choose Option 4 and remove the tuple from frontier. Since h is homomorphism, we have T |= P (x, x), for all P (z, z\u2032) \u2208 q, and canMapTail(z\u2032, a, top(stack)) returns true. Then, for every child z\u2032\u2032 of z\u2032 in T , we add (z\u2032 7\u2192 (a, |stack|), z\u2032\u2032) to frontier. Observe that since h(z) = h(z\u2032) and (21) holds for z, property (21) also holds for the newly added tuples.\n[Case 3.] If neither Case 1 nor Case 2 applies and frontier contains (z 7\u2192 (a, |stack|), z\u2032) such that h(z\u2032) = h(z)\u033a, then we choose Option 2 and remove the tuple from frontier. Note that in this case, |stack| < 2|T | + |q| since (i) by (21), h(z) = aw, for w = stack\u2264|stack|, and (ii) by the choice of homomorphism h, we have |w\u033a| \u2264 2|T | + |q|. So, we continue and choose \u033a for the guess. By (21), since h is a homomorphism and h(z\u2032) = h(z)\u033a, the call isGenerated(\u033a, a, top(stack)) returns true, T |= \u033a(x, y) \u2192 P (x, y), for all P (z, z\u2032) \u2208 q and the call canMapTail(z\u2032, a, top(stack)) returns true. So, we push \u033a onto stack and add (z\u2032 7\u2192 (a, |stack|), z\u2032\u2032) to frontier for every child z\u2032\u2032 of z\u2032 in T . As stack contains the word component of h(z\u2032), invariant (21) holds for the newly added tuples.\n[Case 4.] If none of Case 1, Case 2 or Case 3 is applicable, then we choose Option 3 and remove all elements in deepest = {(z 7\u2192 (a, n), z\u2032) \u2208 frontier | n = |stack|} from frontier. Since neither Case 1 nor Case 3 applies, |stack| > 0. So, we pop the top symbol \u033a from stack. Suppose first that deepest 6= \u2205. By (17), all tuples in deepest share the same individual a. By (21), every tuple (z 7\u2192 (a, n), z\u2032) \u2208 deepest is such that h(z) = aw\u033a, where w = stack\u2264|stack|. Moreover, since Case 3 is not applicable, for every such tuple (z 7\u2192 (a, n), z\u2032), we have h(z\u2032) = aw. Using the fact that h is a homomorphism, one can show that T |= \u033a(x, y) \u2192 P (x, y), for all P (z\u2032, z) \u2208 q, and canMapTail(z\u2032, a, top(stack)) returns true. So, we add to frontier all tuples (z\u2032 7\u2192 (a, |stack|), z\u2032\u2032), a child z\u2032\u2032 of z\u2032 in T . Note that invariant (21) is satisfied by all the new tuples. Moreover, since we only removed the last symbol in stack, all the remaining tuples in frontier continue to satisfy (21). Finally, if deepest was empty, then we do nothing but the tuples in frontier continue to satisfy (21).\nIt is easily verified that so long as frontier is non-empty, one of these four cases applies. Since we have shown how to make the non-deterministic choices in the while loop without returning false, by Proposition 5, the procedure eventually leaves the while loop and returns true.\n(\u21d2) Consider an execution of BLQuery((T , q),A,a) that returns true. It follows that the while loop is successfully exited after reaching an empty frontier. Let L be the total number of iterations of the while loop. We inductively define a sequence h0, h1, . . . , hL of partial functions from the variables of q to\u2206CT ,A by considering the guesses made during the different iterations of the while loop. The domain of hi will be denoted by dom(hi). We will ensure that the following properties hold for every 0 \u2264 i < L:\nIf i > 0, then dom(hi\u22121) \u2286 dom(hi), and hi(z) = hi\u22121(z), for z \u2208 dom(hi\u22121). (22) If (z 7\u2192 (a, n), z\u2032) \u2208 frontier at the end of iteration i, then (23)\nhi(z) = aw, where w = stack\u2264n, (23a) and neither z\u2032 nor any of its descendants belongs to dom(hi). (23b)\nhi is a homomorphism qi \u2192 CT ,A, where qi is the restriction of q to dom(hi). (24)\nWe begin by setting h0(z0) = a0w0, where w0 is the word in stack (and leaving h0 undefined for all other variables). Property (22) is vacuously satisfied. Property (23) holds because of the initial values of frontier and stack because only z0 \u2208 dom(h0), and z0 cannot be its own child (hence, it cannot appear in the last component of a tuple in frontier). To see why (24) is satisfied, first suppose that w0 = \u03b5 and so a0w0 \u2208 ind(A). Then, the call canMapTail(z0, a0, top(stack)) returns true. It follows that\nif z0 is the jth answer variable then a0 = aj ; a0 \u2208 A CT ,A , for each A(z0) \u2208 q, and (a0, a0) \u2208 P CT ,A , for each P (z0, z0) \u2208 q;\nand hence, h0 defines a homomorphism of q0 into CT ,A. Otherwise, w0 is non-empty and w0 = w\u20320\u033a. It follows that\nz0 is not an answer variable of q;\nT |= \u2203y \u033a(y, x) \u2192 A(x), for each A(z0) \u2208 q, and T |= P (x, x), for each P (z0, z0) \u2208 q;\nand hence h0 homomorphically maps all atoms of q0 into CT ,A. Thus, the initial partial function h0 satisfies (22)\u2013(24).\nNext we show how to inductively define hi from hi\u22121 while preserving (22)\u2013(24). The variables that belong to dom(hi) \\ dom(hi\u22121) are precisely those variables that appear in the last position of tuples removed from frontier during iteration i (since these are the variables for which we guess a domain element). The choice of where to map these variables depends on which of the four options was selected. In what follows, we will use stacki to denote the contents of stack at the end of iteration i.\nOption 1: we remove a tuple (z 7\u2192 (a, 0), z\u2032) and guess a\u2032 \u2208 ind(A). So, we set hi(z\u2032) = a\u2032 and hi(v) = hi\u22121(v) for all v \u2208 dom(hi\u22121) (all other variables remain undefined). Property (22) is by definition. For property (23), consider a tuple \u03c4 = (v 7\u2192 (c,m), v\u2032) that belongs to frontier at the end of iteration i. Suppose first \u03c4 was added to frontier during iteration i, in which case \u03c4 = (z\u2032 7\u2192 (a\u2032, 0), z\u2032\u2032) for some child z\u2032\u2032 of z\u2032. Property (23a) is satisfied because stacki\u22640 = \u03b5. Since hi\u22121 satisfies (23), z\u2032\u2032 (a descendant of z\u2032) is not in dom(hi\u22121), which satisfies (23b). The remaining possibility is that \u03c4 was already in frontier at the beginning of iteration i. Since hi\u22121 satisfies (23), we have hi\u22121(v) = cw for w = stack i\u22121 \u2264n and neither v \u2032 nor any of its descendants belongs to dom(hi\u22121). Since stack i = stacki\u22121 and hi(v) = hi\u22121(v), property (23a) holds for \u03c4 . Moreover, as \u03c4 was not removed from frontier during iteration i, we have \u03c4 6= (z 7\u2192 (a, 0), z\u2032), and so, by (18), v\u2032 6= z\u2032. Thus, neither v\u2032 nor any of its descendants is in dom(hi).\nFor property (24), we first note that since hi agrees with hi\u22121 on dom(hi) and hi\u22121 satisfies (24), it is only necessary to consider the atoms in qi that do not belong to qi\u22121. There are three kinds of such atoms:\n\u2013 if A(z\u2032) \u2208 qi, then, since canMapTail(z \u2032, a\u2032, \u03b5) returns true, hi(z\u2032) = a\u2032 \u2208 ACT ,A ; \u2013 if P (z\u2032, z\u2032) \u2208 qi, then, again, since canMapTail(z \u2032, a\u2032, \u03b5) returns true, we have (hi(z\u2032), hi(z\u2032)) =\n(a\u2032, a\u2032) \u2208 P CT ,A ; \u2013 if P (z\u2032, v) \u2208 qi with v 6= z \u2032, then v \u2208 dom(hi), so v must coincide with z, the parent of z\u2032\n(rather than being one of the children of z\u2032); the check operation in the algorithm then guarantees (hi(z \u2032), hi(v)) = (a\u2032, a) \u2208 P CT ,A .\nThus, (24) holds for hi. Option 2: a tuple (z 7\u2192 (a, n), z\u2032) was removed from frontier, n = |stack| and a role \u033a was guessed. We set hi(z\n\u2032) = hi\u22121(z)\u033a. By (23), hi\u22121(z) is defined. Moreover, the call isGenerated(\u033a, a, top(stack)) ensures that hi\u22121(z)\u033a \u2208 \u2206CT ,A . We also set hi(v) = hi\u22121(v) for all v \u2208 dom(hi\u22121) and leave the remaining variables undefined. Property (22) is immediate from the definition of hi, and (23b) can be shown exactly as for Option 1. To show (23a), consider a tuple \u03c4 = (v 7\u2192 (c,m), v\u2032) that belongs to frontier at the end of iteration i. Suppose first that \u03c4 was added to frontier during iteration i, in which case \u03c4 = (z\u2032 7\u2192 (a, n+1), z\u2032\u2032) for some child z\u2032\u2032 of z\u2032. Since hi\u22121 satisfies (23), hi\u22121(z) = a stack i\u22121 \u2264n . Property (23a) follows then from hi(z \u2032) = hi\u22121(z)\u033a and stacki = stacki\u22121 \u033a. The other possibility is that \u03c4 was present in frontier at the beginning of iteration i. Since hi\u22121 satisfies (23), we have hi\u22121(v) = a stack i\u22121 \u2264m. Property (23a) continues to hold for \u03c4 because stacki = stacki\u22121 \u033a and m \u2264 |stacki\u22121| and hi(v) = hi\u22121(v). We now turn to property (24). As explained in the proof for Option 1, it is sufficient to consider the atoms in qi \\ qi\u22121, which can be of three types:\n\u2013 if A(z\u2032) \u2208 qi, then, since canMapTail(z \u2032, a, \u033a) returns true, we have T |= \u2203y \u033a(y, x) \u2192 A(x),\nhence hi(z \u2032) = hi\u22121(z)\u033a \u2208 ACT ,A .\n\u2013 if P (z\u2032, z\u2032) \u2208 qi, then, again, since canMapTail(z \u2032, a, \u033a) returns true, we have T |= P (x, x),\nhence (hi(z \u2032), hi(z\u2032)) \u2208 P CT ,A .\n\u2013 if P (z\u2032, v) \u2208 qi with v 6= z \u2032 then v = z (see Option 1); so, T |= \u033a(x, y) \u2192 P (y, x), whence\n(hi(z \u2032), hi(v)) = (hi\u22121(z)\u033a, hi\u22121(z)) \u2208 P CT ,A .\nTherefore, hi is a homomorphism from qi into CT ,A, which is required by (24). Option 3: tuples in deepest = {(z 7\u2192 (a, n), z\u2032) \u2208 frontier | n = |stack|} are removed from frontier, and role \u033a is popped from stack. By (17), all tuples in deepest share the same individual a. Let V = {z\u2032 | (z 7\u2192 (a, n), z\u2032) \u2208 deepest}. For every v \u2208 V , we set hi(v) = a stack\ni; we also set hi(v) = hi\u22121(v) for all v \u2208 dom(hi\u22121) and leave the remaining variables undefined. Property (22) is again immediate, and the argument for (23b) is the same as in Option 1. For property (23a), take any tuple \u03c4 = (v 7\u2192 (c,m), v\u2032) in frontier at the end of iteration i. If the tuple was added to frontier during this iteration, then v \u2208 V , a = c, m = |stacki|, and hi(v) = a stack\ni, whence (23a). The other possibility is that \u03c4 was present in frontier at the beginning of iteration i. Then hi\u22121(v) = c stack i\u22121 \u2264m and m < |stack i\u22121|. Since stacki is obtained from stacki\u22121 by popping one role, we have m \u2264 |stacki|, and so (23a) holds for \u03c4 . For property (24), the argument is similar to Options 1 and 2 and involves considering the different types of atoms that may appear in qi \\ qi\u22121:\n\u2013 if A(z\u2032) \u2208 qi with z \u2032 \u2208 V then, since canMapTail(z\u2032, a, top(stack)) returns true, we have\nhi(z \u2032) \u2208 ACT ,A (see Options 1 and 2);\n\u2013 if P (z\u2032, z\u2032) \u2208 qi with z \u2032 \u2208 V then, since canMapTail(z\u2032, a, top(stack)) returns true, we have\n(hi(z \u2032), hi(z\u2032)) = (a, a) \u2208 P CT ,A ;\n\u2013 if P (z\u2032, v) \u2208 qi with v 6= z \u2032 and z\u2032 \u2208 V , then v is the parent of z (see Option 1) and, since\nT |= \u033a(y, x) \u2192 P (x, y), we obtain (hi(z\u2032), hi(v)) = (a stack i, a stacki \u033a) \u2208 P CT ,A .\nThus, (24) holds for hi.\nOption 4: a tuple (z 7\u2192 (a, n), z\u2032) was removed from frontier with n = |stack|. We set hi(z\u2032) = hi(z), hi(v) = hi\u22121(v) for every v \u2208 dom(hi\u22121), and leave all other variables unmapped. Again, it is easy to see that properties (22) and (23b) are satisfied by hi. For property (23a), let \u03c4 = (v 7\u2192 (c,m), v\u2032) be a tuple in frontier at the end of iteration i. If the tuple was added during iteration i, then v = z\u2032, a = c, and m = n. Since (z 7\u2192 (a, n), z\u2032) was present at the end of iteration i \u2212 1 and stacki = stacki\u22121, we have hi(z\u2032) = a stack i\u22121 \u2264n , hence hi(z) = c stack i \u2264m. As hi(z \u2032) = hi(z), we have hi(z\u2032) = a stack i \u2264m, so \u03c4 satisfies (23a). If \u03c4 was already present at the beginning of iteration i, then we can use the fact that stacki = stacki\u22121 and all tuples in frontier satisfy (23a).\nTo show (24), we consider the three types of atoms that may appear in qi \\ qi\u22121:\n\u2013 ifA(z\u2032) \u2208 qi then, since canMapTail(z \u2032, a, top(stack)) returns true, then T |= \u2203y \u033a(y, x) \u2192 A(x),\nwhere \u033a = top(stack), and so hi(z \u2032) \u2208 ACT ,A ;\n\u2013 if P (z\u2032, z\u2032) \u2208 qi then, since canMapTail(z \u2032, a, top(stack)) returns true, then T |= P (x, x),\nand so (hi(z \u2032), h(z\u2032)) \u2208 P CT ,A ;\n\u2013 if P (z\u2032, v) \u2208 qi with v 6= z \u2032, then v = z (see Option 1), and so, since T |= P (x, x), we have\n(hi(z \u2032), hi(z)) \u2208 P CT ,A .\nWe claim that the final partial function hL is a homomorphism of q to CT ,A. Since hL is a homomorphism of qL into CT ,A, it suffices to show that q = qL, or equivalently, that all variables of q are in dom(hL). This follows from the tree-shapedness of q (which in particular means that q is connected), invariants (15), and (20), and the fact that dom(hi+1) = dom(hi) \u222a {z\n\u2032 | (z 7\u2192 (a, n), z\u2032) is removed from frontier during iteration i}.\nProposition 7. BLQuery can be implemented by an NAuxPDA.\nProof. It suffices to show that BLQuery runs in non-deterministic logarithmic space and polynomial time (the size of stack does not have to be bounded).\nFirst, we non-deterministically fix a root variable z0, but do not actually need to store the induced directed tree T in memory. Instead, it suffices to decide, given two variables z and z\u2032, whether z\u2032 is a child of z in T , which clearly belongs to NL.\nNext, we need only logarithmic space to store the individual a0. The initial word w0 = \u033a1 . . . \u033an0 is guessed symbol by symbol and pushed onto stack. We note that both subroutines, isGenerated and canMapTail, can be made to run in non-deterministic logarithmic space. Then, since the children of a node in T can be identified in NL, we can decide in non-deterministic\nlogarithmic space whether a tuple (z0 7\u2192 (a0, |stack|, zi) should be included in frontier. Moreover, since the input query q is a tree-shaped query with a bounded number of leaves, we know that only constantly many tuples can be added to frontier by each such operation. Moreover, it is clear that every tuple can be stored using in logarithmic space. More generally, by (15) and (18), one can show that |frontier| is bounded by a constant throughout the execution of the procedure, and the tuples added during the while loop can also be stored in logarithmically space.\nNext observe that every iteration of the while loop involves a polynomial number of the following elementary operations such as\n\u2013 remove a tuple from frontier, or add a tuple to frontier;\n\u2013 pop a role from stack, or push a role onto stack;\n\u2013 guess a single individual constant or symbol;\n\u2013 identify the children of a given variable;\n\u2013 test whether T |= \u03b1, for some inclusion \u03b1 involving symbols from T ; \u2013 make a call to one of the subroutines isGenerated or canMapTail.\nFor each of the above operations, it is either easy to see, or has already been explained, that the operation can be performed in non-deterministic logarithmic space.\nTo complete the proof, observe that, by (19), each iteration of the while loop involves removing a tuple from frontier or popping a role from stack. By (15) every tuple in frontier corresponds to an edge in T , and, by (18), we create at most one tuple per edge. Thus, there can be at most |q| iterations involving the removal of a tuple. The total number of roles added to stack is bounded by at most \u2264 2|T | + |q| roles in the initial stack, plus the at most |q| roles added in later iterations, yielding at most 2|T | + 2|q| iterations involving only the popping of a role. Thus, the total number of iterations of the while loop cannot exceed can 2|T |+ 3|q|."}, {"heading": "I Proof of LOGCFL-hardness in Theorem 34", "text": "Proposition 8. The query q\u2032 and KB (T\u03b1,A) can be computed from C by logspace transducers.\nProof. Consider a circuit C in normal form with 2d + 1 layers of gates, where d is logarithmic in number of its inputs n. We show that (T\u03b1,A) and q\u2032 can be constructed using O(log(n)) worktape memory.\nTo produce the query q\u2032, we can generate the word wd letter-by-letter and insert the corresponding variables. This can be done by a simple recursive procedure of depth d, using the worktape to remember the current position in the recursion tree as well as the index of the current variable yi. Note that |wd| (hence the largest index of the query variables) may be exponential in d, but is only polynomial in n, and so we need only logarithmic space to store the index of the current variable.\nThe ontology T\u03b1 is obtained by making a single pass over a (graph representation) of the circuit and generating the axioms that correspond to the gates of C and the links between them. To decide which axioms of the form Gi(x) \u2192 A(x) to include, we must also look up the value of the variables associated to the input gates under the valuation \u03b1. Finally, A consists of a single constant atom.\nProposition 9. C accepts \u03b1 iff T\u03b1,A |= q\u2032(a).\nProof. Denote by e the natural homomorphism from q\u2032 to q, and by e\u2032 the natural homomorphism from CT\u03b1,A to D(\u03b1). Since C accepts input \u03b1 iff there is a homomorphism h from q to D(\u03b1) [33], it suffices to show that there exists a homomorphism f from q\u2032 to CT\u03b1,A iff there is a homomorphism h from q to D(\u03b1):\n(a) q\u2032\nq D(\u03b1)\nCT\u03b1,A\ne e\u2032\nh\nh\u2032\nf (b) q\u2032\nq D(\u03b1)\nCT\u03b1,A\ne e\u2032\nf\nf \u2032\nh\n(\u21d2) Suppose that h is a homomorphism from q toD(\u03b1). We define a homomorphism h\u2032 : q \u2192 CT\u03b1,A inductively moving from the root n1 of q to its leaves. For the basis of induction, we set h\u2032(n1) = a; note that CT\u03b1,A |= Gm(a). For the inductive step, suppose that nj is a child of ni, h\u2032(ni) is defined, CT\u03b1,A |= Gi\u2032 (h(ni)) and h(nj) = gj\u2032 . In this case, we set h \u2032(nj) = h\u2032(ni)P \u2212 i\u2032j\u2032 . It follows from the definition of T\u03b1 that CT\u03b1,A |= Gj\u2032 (h \u2032(nj)), which enables us to continue the induction. It should be clear that h\u2032 is indeed a homomorphism from q into CT\u03b1,A. The desired homomorphism f : q\u2032 \u2192 CT\u03b1,A can be obtained as the composition of e and h\n\u2032, as illustrated in diagram (a).\n(\u21d0) Suppose that f is a homomorphism from q\u2032 to CT\u03b1,A. We prove, by induction on |j\u2212 i|, that for all its variables yi, yj,\ne(yi) = e(yj) implies f(yi) = f(yj). (25)\nThe base case (|j \u2212 i| = 0) is trivial. For the inductive step, we may assume without loss of generality that i < j and between yi and yj there is no intermediate variable yk with e(yi) = e(yk) = e(yj) (otherwise, we can simply use the induction hypothesis together with the transitivity of equality). It follows that e(yi+1) = e(yj\u22121), and the atom between yj\u22121 and yj is oriented from yj\u22121 towards yj, while the atom between yi and yi+1 goes from yi+1 to yi. Indeed, this holds if the node n = e(yi) = e(yj) is an or-node since there are exactly two variables in q\u2032 which are mapped to n, and they bound the subtree in q generated by n. For an and-node, this also holds because of our assumption about intermediate variables. By the induction hypothesis, we have f(yi+1) = f(yj\u22121) = aw\u033a for some word aw\u033a. Since the only parent of aw\u033a in CT\u03b1,A is aw, all arrows in relations U , L and R are oriented towards the root, and f is known to be a homomorphism, it follows that f(yi) = f(yj) = aw. This concludes the inductive argument.\nNext, we define f \u2032 : q \u2192 CT\u03b1,A by setting f \u2032(x) = f(y), where y is such that e(y) = x. By (25), f \u2032 is well-defined, and because f is a homomorphism, the same holds for f \u2032. To obtain the desired homomorphism h : q \u2192 D(\u03b1), it suffices to consider the composition of f \u2032 and e\u2032; see diagram (b)."}, {"heading": "13. M. Bienvenu, B. ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: A study through", "text": "disjunctive datalog, csp, and MMSNP. ACM Transasctions on Database Systems, 39(4):33:1\u201344, 2014. 14. E. Botoeva, D. Calvanese, V. Santarelli, D. F. Savo, A. Solimando, and G. Xiao. Beyond OWL 2 QL in OBDA: rewritings and approximations. In Proc. of the AAAI Conf. on Artificial Intelligence (AAAI 2016). AAAI, 2016. 15. A. Brandsta\u0308dt, V. B. Le, and J. P. Spinrad. Graph Classes: A Survey. SIAM, Philadelphia, PA, USA, 1999. 16. A. Bretto. Hypergraph Theory: An Introduction. Springer, 2013. 17. A. Cal\u0300\u0131, G. Gottlob, and T. Lukasiewicz. A general datalog-based framework for tractable query\nanswering over ontologies. Journal of Web Semantics, 14:57\u201383, 2012.\n18. A. Cal\u0300\u0131, G. Gottlob, and A. Pieris. Towards more expressive ontology languages: The query answering problem. Artificial Intelligence, 193:87\u2013128, 2012. 19. D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, A. Poggi, M. Rodriguez-Muro, R. Rosati, M. Ruzzi, and D. F. Savo. The MASTRO system for ontology-based data access. Semantic Web, 2(1):43\u201353, 2011. 20. D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Tractable reasoning and efficient query answering in description logics: the DL-Lite family. Journal of Automated Reasoning, 39(3):385\u2013429, 2007. 21. A. Chandra and P. Merlin. Optimal implementation of conjunctive queries in relational data bases. In Conference Record of the 9th Annual ACM Symposium on Theory of Computing (STOC\u201977), pages 77\u201390. ACM, 1977. 22. C. Chekuri and A. Rajaraman. Conjunctive query containment revisited. Theoretical Computer Science, 239(2):211\u2013229, 2000. 23. A. Chortaras, D. Trivela, and G. Stamou. Optimized query rewriting for OWL 2 QL. In Proc. of CADE-23, volume 6803 of LNCS, pages 192\u2013206. Springer, 2011. 24. C. Civili and R. Rosati. A broad class of first-order rewritable tuple-generating dependencies. In Proc. of the 2nd Int. Datalog 2.0 Workshop, volume 7494 of Lecture Notes in Computer Science, pages 68\u201380. Springer, 2012. 25. M. Console, J. Mora, R. Rosati, V. Santarelli, and D. F. Savo. Effective computation of maximal sound approximations of description logic ontologies. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part II, volume 8797 of Lecture Notes in Computer Science, pages 164\u2013179. Springer, 2014. 26. S. A. Cook. Characterizations of pushdown machines in terms of time-bounded computers. Journal of the ACM, 18(1):4\u201318, 1971. 27. T. Eiter, M. Ortiz, M. S\u030cimkus, T.-K. Tran, and G. Xiao. Query rewriting for Horn-SHIQ plus rules. In Proc. of the 26th AAAI Conf. on Artificial Intelligence (AAAI 2012), pages 726\u2013733. AAAI, 2012. 28. C. Flament. Hypergraphes arbore\u0301s. Discrete Mathematics, 21(3):223\u2013227, 1978. 29. J. Flum and M. Grohe. Parameterized Complexity Theory. Texts in Theoretical Computer Science.\nAn EATCS Series. Springer, 2006.\n30. M. Giese, A. Soylu, G. Vega-Gorgojo, A. Waaler, P. Haase, E. Jime\u0301nez-Ruiz, D. Lanti, M. Rezk, G. Xiao, O\u0308. O\u0308zc\u0327ep, and R. Rosati. Optique: Zooming in on big data. IEEE Computer, 48(3):60\u201367, 2015. 31. G. Gottlob, S. Kikot, R. Kontchakov, V. V. Podolskii, T. Schwentick, and M. Zakharyaschev. The price of query rewriting in ontology-based data access. Artificial Intelligence, 213:42\u201359, 2014. 32. G. Gottlob, N. Leone, and F. Scarcello. Computing LOGCFL certificates. In Proc. of the 26th Int. Colloquium on Automata, Languages and Programming (ICALP-99), volume 1644 of Lecture Notes in Computer Science, pages 361\u2013371. Springer, 1999. 33. G. Gottlob, N. Leone, and F. Scarcello. The complexity of acyclic conjunctive queries. Journal of the ACM, 48(3):431\u2013498, 2001. 34. G. Gottlob, G. Orsi, and A. Pieris. Ontological queries: Rewriting and optimization. In Proc. of ICDE 2011, pages 2\u201313. IEEE Computer Society, 2011. 35. G. Gottlob and T. Schwentick. Rewriting ontological queries into small nonrecursive datalog programs. In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 254\u2013263. AAAI, 2012. 36. M. Grohe, T. Schwentick, and L. Segoufin. When is the evaluation of conjunctive queries tractable? In Proc. of the 33rd Annual ACM Symposium on Theory of Computing (STOC 2001), pages 657\u2013 666. ACM, 2001. 37. V. Gutie\u0301rrez-Basulto, Y. Iba\u0301n\u0303ez-Garc\u0301\u0131a, R. Kontchakov, and E. V. Kostylev. Queries with negation and inequalities over lightweight ontologies. J. Web Sem., 35:184\u2013202, 2015."}, {"heading": "38. P. Hansen, C. Lutz, I. Seylan, and F. Wolter. Efficient query rewriting in the description logic EL", "text": "and beyond. In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3034\u20133040. AAAI, 2015. 39. D. A. Huffman. A method for the construction of minimum-redundancy codes. Proceedings of the Institute of Radio Engineers, 40(9):1098\u20131101, 1952. 40. N. Immerman. Nondeterministic space is closed under complementation. SIAM J. Comput., 17(5):935\u2013938, 1988. 41. D. S. Johnson and A. C. Klug. Testing containment of conjunctive queries under functional and inclusion dependencies. In Proc. of the ACM Symposium on Principles of Database Systems (PODS), pages 164\u2013169. ACM, 1982. 42. S. Jukna. Boolean Function Complexity \u2014 Advances and Frontiers, volume 27 of Algorithms and combinatorics. Springer, 2012. 43. M. Kaminski, Y. Nenov, and B. Cuenca Grau. Datalog rewritability of disjunctive datalog programs and its applications to ontology reasoning. In Proc. of the 28th AAAI Conference on Artificial Intelligence (AAAI 2014), pages 1077\u20131083. AAAI, 2014. 44. M. Karchmer and A.Wigderson. Monotone circuits for connectivity require super-logarithmic depth. In Proc. of the 20th Annual ACM Symposium on Theory of Computing (STOC \u201988), pages 539\u2013550. ACM, 1988. 45. E. Kharlamov, D. Hovland, E. Jime\u0301nez-Ruiz, D. Lanti, H. Lie, C. Pinkel, M. Rezk, M. G. Skj\u00e6veland, E. Thorstensen, G. Xiao, D. Zheleznyakov, and I. Horrocks. Ontology based access to exploration data at Statoil. In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), Part II, volume 9367 of Lecture Notes in Computer Science, pages 93\u2013112. Springer, 2015. 46. E. Kharlamov, N. Solomakhina, O\u0308. L. O\u0308zc\u0327ep, D. Zheleznyakov, T. Hubauer, S. Lamparter, M. Roshchin, A. Soylu, and S. Watson. How semantic technologies can enhance data access at Siemens Energy. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 601\u2013619. Springer, 2014. 47. S. Kikot, R. Kontchakov, V. V. Podolskii, and M. Zakharyaschev. Exponential lower bounds and separation for query rewriting. In Proc. of the 39th Int. Colloquium on Automata, Languages and Programming (ICALP 2012), volume 7392 of Lecture Notes in Computer Science, pages 263\u2013274. Springer, 2012. 48. S. Kikot, R. Kontchakov, and M. Zakharyaschev. On (in)tractability of OBDA with OWL 2 QL. In Proc. of the 24th Int. Workshop on Description Logics (DL 2011), volume 745, pages 224\u2013234. CEUR-WS, 2011. 49. S. Kikot, R. Kontchakov, and M. Zakharyaschev. Conjunctive query answering with OWL 2 QL. In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 275\u2013285. AAAI, 2012. 50. M. Ko\u0308nig, M. Lecle\u0300re, and M.-L. Mugnier. Query rewriting for existential rules with compiled preorder. In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3106\u2013 3112. AAAI Press, 2015. 51. M. Ko\u0308nig, M. Lecle\u0300re, M.-L. Mugnier, and M. Thomazo. Sound, complete and minimal ucq-rewriting for existential rules. Semantic Web, 6(5):451\u2013475, 2015. 52. R. Kontchakov, C. Lutz, D. Toman, F. Wolter, and M. Zakharyaschev. The combined approach to query answering in DL-Lite. In Principles of Knowledge Representation and Reasoning: Proceedings of the 12th Int. Conf. KR 2010, pages 247\u2013257. AAAI Press, 2010. 53. R. Kontchakov, M. Rezk, M. Rodriguez-Muro, G. Xiao, and M. Zakharyaschev. Answering SPARQL queries over databases under OWL 2 QL entailment regime. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 552\u2013567. Springer, 2014. 54. E. V. Kostylev, J. L. Reutter, and D. Vrgoc. XPath for DL ontologies. In Proc. of the 29th AAAI Conference on Artificial Intelligence (AAAI 2015), pages 1525\u20131531. AAAI, 2015. 55. D. Lembo, J. Mora, R. Rosati, D. F. Savo, and E. Thorstensen. Mapping analysis in ontology-based data access: Algorithms and complexity. In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), volume 9366 of Lecture Notes in Computer Science, pages 217\u2013234. Springer, 2015. 56. L. Libkin. Elements Of Finite Model Theory. Springer, 2004. 57. C. Lutz. The complexity of conjunctive query answering in expressive description logics. In Proc.\nof the 4th Int. Joint Conf. on Automated Reasoning (IJCAR 2008), number 5195 in LNAI, pages 179\u2013193. Springer, 2008. 58. C. Lutz, R. Piro, and F. Wolter. Description logic tboxes: Model-theoretic characterizations and rewritability. In Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2011), pages 983\u2013988. IJCAI/AAAI, 2011. 59. J. Mora, R. Rosati, and O\u0301. Corcho. Kyrie2: query rewriting under extensional constraints in ELHIO. In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), volume 8796 of Lecture Notes in Computer Science, pages 568\u2013583. Springer, 2014.\n60. H. Pe\u0301rez-Urbina, B. Motik, and I. Horrocks. A comparison of query rewriting techniques for DLlite. In Proc. of the 22nd Inte. Workshop on Description Logics (DL 2009), volume 477 of CEUR Workshop Proceedings. CEUR-WS, 2009. 61. H. Pe\u0301rez-Urbina, E. Rodr\u0301\u0131guez-D\u0131\u0301az, M. Grove, G. Konstantinidis, and E. Sirin. Evaluation of query rewriting approaches for OWL 2. In Proc. of SSWS+HPCSW 2012, volume 943 of CEUR Workshop Proceedings. CEUR-WS, 2012. 62. A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, and R. Rosati. Linking data to ontologies. Journal on Data Semantics, X:133\u2013173, 2008. 63. R. Raz and A. Wigderson. Monotone circuits for matching require linear depth. Journal of the ACM, 39(3):736\u2013744, 1992. 64. A. Razborov. Lower bounds for the monotone complexity of some Boolean functions. Dokl. Akad. Nauk SSSR, 281(4):798\u2013801, 1985. 65. A. A. Razborov. Lower bounds for deterministic and nondeterministic branching programs. In Proc. of the 8th Int. Symposium on Fundamentals of Computation Theory (FCT\u201991), volume 529 of Lecture Notes in Computer Science, pages 47\u201360. Springer, 1991. 66. M. Rodriguez-Muro and D. Calvanese. High performance query answering over DL-Lite ontologies. In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 308\u2013318. AAAI, 2012. 67. M. Rodriguez-Muro, R. Kontchakov, and M. Zakharyaschev. Ontology-based data access: Ontop of databases. In Proc. of the 12th Int. Semantic Web Conf. (ISWC 2013), volume 8218 of Lecture Notes in Computer Science, pages 558\u2013573. Springer, 2013. 68. R. Rosati. The limits of querying ontologies. In Proc. of the 11th Int. Conf. on Database Theory (ICDT 2007), volume 4353 of Lecture Notes in Computer Science, pages 164\u2013178. Springer, 2007. 69. R. Rosati. Prexto: Query rewriting under extensional constraints in DL-Lite. In Proc. of the 9th Extended Semantic Web Conf. (EWSC 2012), volume 7295 of Lecture Notes in Computer Science, pages 360\u2013374. Springer, 2012. 70. R. Rosati and A. Almatelli. Improving query answering over DL-Lite ontologies. In Proc. of the 12th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2010), pages 290\u2013300. AAAI Press, 2010. 71. J. F. Sequeda, M. Arenas, and D. P. Miranker. OBDA: query rewriting or materialization? in practice, both! In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 535\u2013551. Springer, 2014. 72. I. H. Sudborough. On the tape complexity of deterministic context-free languages. Journal of the ACM, 25(3):405\u2013414, 1978. 73. R. Szelepcse\u0301nyi. The method of forced enumeration for nondeterministic automata. Acta Informatica, 26(3):279\u2013284, 1988. 74. M. Vardi. The complexity of relational query languages (extended abstract). In Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC\u201982), pages 137\u2013146. ACM, 1982. 75. H. Venkateswaran. Properties that characterize LOGCFL. Journal of Computer and System Sciences, 43(2):380\u2013404, 1991. 76. H. Vollmer. Introduction to Circuit Complexity: A Uniform Approach. Springer, 1999. 77. M. Yannakakis. Algorithms for acyclic database schemes. In Proc. of the 7th Int. Conf. on Very\nLarge Data Bases (VLDB), pages 82\u201394. IEEE Computer Society, 1981. 78. Y. Zhou, B. Cuenca Grau, Y. Nenov, M. Kaminski, and I. Horrocks. Pagoda: Pay-as-you-go ontology\nquery answering using a datalog reasoner. Journal of Artificial Intelligence Research (JAIR), 54:309\u2013 367, 2015."}], "references": [{"title": "Foundations of Databases", "author": ["S. Abiteboul", "R. Hull", "V. Vianu"], "venue": "Addison-Wesley,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "The monotone circuit complexity of boolean functions", "author": ["N. Alon", "R. Boppana"], "venue": "Combinatorica, 7(1):1\u201322,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1987}, {"title": "Computational Complexity: A Modern Approach", "author": ["S. Arora", "B. Barak"], "venue": "Cambridge University Press, New York, NY, USA, 1st edition,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2009}, {"title": "The DL-Lite family and relations", "author": ["A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev"], "venue": "Journal of Artificial Intelligence Research (JAIR), 36:1\u201369,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2009}, {"title": "A linear-time algorithm for testing the truth of certain quantified boolean formulas", "author": ["B. Aspvall", "M. Plass", "R. Tarjan"], "venue": "Information Processing Letters, 8(3):121\u2013123,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1979}, {"title": "Eliminating definitions and Skolem functions in first-order logic", "author": ["J. Avigad"], "venue": "ACM Transactions on Computational Logic, 4(3):402\u2013415,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "On rules with existential variables: Walking the decidability line", "author": ["J.-F. Baget", "M. Lecl\u00e8re", "M.-L. Mugnier", "E. Salvat"], "venue": "Artificial Intelligence, 175(9\u201310):1620\u20131654,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2011}, {"title": "Theoretically optimal datalog rewritings for owl 2 ql ontology-mediated queries", "author": ["M. Bienvenu", "S. Kikot", "R. Kontchakov", "V. Podolskii", "M. Zakharyaschev"], "venue": "CoRR, abs/1604.05258,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2016}, {"title": "First-order rewritability of atomic queries in horn description logics", "author": ["M. Bienvenu", "C. Lutz", "F. Wolter"], "venue": "In Proc. of the 23nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2013), pages 754\u2013760. IJCAI/AAAI,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2013}, {"title": "Regular path queries in lightweight description logics: Complexity and algorithms", "author": ["M. Bienvenu", "M. Ortiz", "M. Simkus"], "venue": "Journal of Artificial Intelligence Research (JAIR), 53:315\u2013374,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2015}, {"title": "Tractable queries for lightweight description logics", "author": ["M. Bienvenu", "M. Ortiz", "M. Simkus", "G. Xiao"], "venue": "In Proc. of the 23nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2013), pages 768\u2013774. IJCAI/AAAI,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Query-based comparison of OBDA specifications", "author": ["M. Bienvenu", "R. Rosati"], "venue": "In Proc. of the 28th International Workshop on Description Logics (DL 2015), volume 1350 of CEUR Workshop Proceedings, pages 55\u201366. CEUR-WS,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "B", "author": ["M. Bienvenu"], "venue": "ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: A study through disjunctive datalog, csp, and MMSNP. ACM Transasctions on Database Systems, 39(4):33:1\u201344,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2014}, {"title": "Beyond OWL 2 QL in OBDA: rewritings and approximations", "author": ["E. Botoeva", "D. Calvanese", "V. Santarelli", "D.F. Savo", "A. Solimando", "G. Xiao"], "venue": "In Proc. of the AAAI Conf. on Artificial Intelligence (AAAI 2016). AAAI,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2016}, {"title": "Graph Classes: A Survey", "author": ["A. Brandst\u00e4dt", "V.B. Le", "J.P. Spinrad"], "venue": "SIAM, Philadelphia, PA, USA,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1999}, {"title": "Hypergraph Theory: An Introduction", "author": ["A. Bretto"], "venue": "Springer,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "A general datalog-based framework for tractable query answering over ontologies", "author": ["A. Cal\u0300\u0131", "G. Gottlob", "T. Lukasiewicz"], "venue": "Journal of Web Semantics,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2012}, {"title": "Towards more expressive ontology languages: The query answering problem", "author": ["A. Cal\u0300\u0131", "G. Gottlob", "A. Pieris"], "venue": "Artificial Intelligence,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2012}, {"title": "The MASTRO system for ontology-based data access", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "M. Rodriguez-Muro", "R. Rosati", "M. Ruzzi", "D.F. Savo"], "venue": "Semantic Web, 2(1):43\u201353,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Tractable reasoning and efficient query answering in description logics: the DL-Lite family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Journal of Automated Reasoning, 39(3):385\u2013429,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2007}, {"title": "Optimal implementation of conjunctive queries in relational data bases", "author": ["A. Chandra", "P. Merlin"], "venue": "In Conference Record of the 9th Annual ACM Symposium on Theory of Computing (STOC\u201977), pages 77\u201390. ACM,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1977}, {"title": "Conjunctive query containment revisited", "author": ["C. Chekuri", "A. Rajaraman"], "venue": "Theoretical Computer Science, 239(2):211\u2013229,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2000}, {"title": "Optimized query rewriting for OWL 2 QL", "author": ["A. Chortaras", "D. Trivela", "G. Stamou"], "venue": "In Proc. of CADE-23, volume 6803 of LNCS, pages 192\u2013206. Springer,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2011}, {"title": "A broad class of first-order rewritable tuple-generating dependencies", "author": ["C. Civili", "R. Rosati"], "venue": "In Proc. of the 2nd Int. Datalog 2.0 Workshop, volume 7494 of Lecture Notes in Computer Science, pages 68\u201380. Springer,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2012}, {"title": "Effective computation of maximal sound approximations of description logic ontologies", "author": ["M. Console", "J. Mora", "R. Rosati", "V. Santarelli", "D.F. Savo"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part II, volume 8797 of Lecture Notes in Computer Science, pages 164\u2013179. Springer,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2014}, {"title": "Characterizations of pushdown machines in terms of time-bounded computers", "author": ["S.A. Cook"], "venue": "Journal of the ACM, 18(1):4\u201318,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1971}, {"title": "Query rewriting for Horn-SHIQ plus rules", "author": ["T. Eiter", "M. Ortiz", "M. \u0160imkus", "T.-K. Tran", "G. Xiao"], "venue": "In Proc. of the 26th AAAI Conf. on Artificial Intelligence (AAAI 2012), pages 726\u2013733. AAAI,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2012}, {"title": "Hypergraphes arbor\u00e9s", "author": ["C. Flament"], "venue": "Discrete Mathematics, 21(3):223\u2013227,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1978}, {"title": "Parameterized Complexity Theory", "author": ["J. Flum", "M. Grohe"], "venue": "Texts in Theoretical Computer Science. An EATCS Series. Springer,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2006}, {"title": "Optique: Zooming in on big data", "author": ["M. Giese", "A. Soylu", "G. Vega-Gorgojo", "A. Waaler", "P. Haase", "E. Jim\u00e9nez-Ruiz", "D. Lanti", "M. Rezk", "G. Xiao", "\u00d6. \u00d6z\u00e7ep", "R. Rosati"], "venue": "IEEE Computer, 48(3):60\u201367,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2015}, {"title": "The price of query rewriting in ontology-based data access", "author": ["G. Gottlob", "S. Kikot", "R. Kontchakov", "V.V. Podolskii", "T. Schwentick", "M. Zakharyaschev"], "venue": "Artificial Intelligence, 213:42\u201359,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2014}, {"title": "Computing LOGCFL certificates", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "In Proc. of the 26th Int. Colloquium on Automata, Languages and Programming (ICALP-99), volume 1644 of Lecture Notes in Computer Science, pages 361\u2013371. Springer,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1999}, {"title": "The complexity of acyclic conjunctive queries", "author": ["G. Gottlob", "N. Leone", "F. Scarcello"], "venue": "Journal of the ACM, 48(3):431\u2013498,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2001}, {"title": "Ontological queries: Rewriting and optimization", "author": ["G. Gottlob", "G. Orsi", "A. Pieris"], "venue": "In Proc. of ICDE 2011, pages 2\u201313. IEEE Computer Society,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2011}, {"title": "Rewriting ontological queries into small nonrecursive datalog programs", "author": ["G. Gottlob", "T. Schwentick"], "venue": "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 254\u2013263. AAAI,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2012}, {"title": "When is the evaluation of conjunctive queries tractable? In Proc", "author": ["M. Grohe", "T. Schwentick", "L. Segoufin"], "venue": "of the 33rd Annual ACM Symposium on Theory of Computing (STOC 2001), pages 657\u2013 666. ACM,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2001}, {"title": "Queries with negation and inequalities over lightweight ontologies", "author": ["V. Guti\u00e9rrez-Basulto", "Y. Ib\u00e1\u00f1ez-Gar\u0107\u0131a", "R. Kontchakov", "E.V. Kostylev"], "venue": "J. Web Sem., 35:184\u2013202,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2015}, {"title": "Efficient query rewriting in the description logic EL and beyond", "author": ["P. Hansen", "C. Lutz", "I. Seylan", "F. Wolter"], "venue": "In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3034\u20133040. AAAI,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2015}, {"title": "A method for the construction of minimum-redundancy codes", "author": ["D.A. Huffman"], "venue": "Proceedings of the Institute of Radio Engineers, 40(9):1098\u20131101,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 1952}, {"title": "Nondeterministic space is closed under complementation", "author": ["N. Immerman"], "venue": "SIAM J. Comput., 17(5):935\u2013938,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 1988}, {"title": "Testing containment of conjunctive queries under functional and inclusion dependencies", "author": ["D.S. Johnson", "A.C. Klug"], "venue": "In Proc. of the ACM Symposium on Principles of Database Systems (PODS), pages 164\u2013169. ACM,", "citeRegEx": "41", "shortCiteRegEx": null, "year": 1982}, {"title": "Boolean Function Complexity \u2014 Advances and Frontiers, volume 27 of Algorithms and combinatorics", "author": ["S. Jukna"], "venue": "Springer,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2012}, {"title": "Datalog rewritability of disjunctive datalog programs and its applications to ontology reasoning", "author": ["M. Kaminski", "Y. Nenov", "B. Cuenca Grau"], "venue": "In Proc. of the 28th AAAI Conference on Artificial Intelligence (AAAI 2014), pages 1077\u20131083. AAAI,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2014}, {"title": "Monotone circuits for connectivity require super-logarithmic depth", "author": ["M. Karchmer", "A.Wigderson"], "venue": "In Proc. of the 20th Annual ACM Symposium on Theory of Computing (STOC", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1988}, {"title": "Ontology based access to exploration data at Statoil", "author": ["E. Kharlamov", "D. Hovland", "E. Jim\u00e9nez-Ruiz", "D. Lanti", "H. Lie", "C. Pinkel", "M. Rezk", "M.G. Skj\u00e6veland", "E. Thorstensen", "G. Xiao", "D. Zheleznyakov", "I. Horrocks"], "venue": "In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), Part II, volume 9367 of Lecture Notes in Computer Science, pages 93\u2013112. Springer,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2015}, {"title": "How semantic technologies can enhance data access at Siemens Energy", "author": ["E. Kharlamov", "N. Solomakhina", "\u00d6.L. \u00d6z\u00e7ep", "D. Zheleznyakov", "T. Hubauer", "S. Lamparter", "M. Roshchin", "A. Soylu", "S. Watson"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 601\u2013619. Springer,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2014}, {"title": "Exponential lower bounds and separation for query rewriting", "author": ["S. Kikot", "R. Kontchakov", "V.V. Podolskii", "M. Zakharyaschev"], "venue": "In Proc. of the 39th Int. Colloquium on Automata, Languages and Programming (ICALP 2012), volume 7392 of Lecture Notes in Computer Science, pages 263\u2013274. Springer,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2012}, {"title": "On (in)tractability of OBDA with OWL 2 QL", "author": ["S. Kikot", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of the 24th Int. Workshop on Description Logics (DL 2011), volume 745, pages 224\u2013234. CEUR-WS,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2011}, {"title": "Conjunctive query answering with OWL 2 QL", "author": ["S. Kikot", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 275\u2013285. AAAI,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2012}, {"title": "Query rewriting for existential rules with compiled preorder", "author": ["M. K\u00f6nig", "M. Lecl\u00e8re", "M.-L. Mugnier"], "venue": "In Proc. of the 24th Int. Joint Conf. on Artificial Intelligence (IJCAI 2015), pages 3106\u2013 3112. AAAI Press,", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2015}, {"title": "Sound, complete and minimal ucq-rewriting for existential rules", "author": ["M. K\u00f6nig", "M. Lecl\u00e8re", "M.-L. Mugnier", "M. Thomazo"], "venue": "Semantic Web, 6(5):451\u2013475,", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2015}, {"title": "The combined approach to query answering in DL-Lite", "author": ["R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev"], "venue": "In Principles of Knowledge Representation and Reasoning: Proceedings of the 12th Int. Conf. KR 2010, pages 247\u2013257. AAAI Press,", "citeRegEx": "52", "shortCiteRegEx": null, "year": 2010}, {"title": "Answering SPARQL queries over databases under OWL 2 QL entailment regime", "author": ["R. Kontchakov", "M. Rezk", "M. Rodriguez-Muro", "G. Xiao", "M. Zakharyaschev"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 552\u2013567. Springer,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2014}, {"title": "XPath for DL ontologies", "author": ["E.V. Kostylev", "J.L. Reutter", "D. Vrgoc"], "venue": "In Proc. of the 29th AAAI Conference on Artificial Intelligence (AAAI 2015), pages 1525\u20131531. AAAI,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2015}, {"title": "Mapping analysis in ontology-based data access: Algorithms and complexity", "author": ["D. Lembo", "J. Mora", "R. Rosati", "D.F. Savo", "E. Thorstensen"], "venue": "In Proc. of the 14th Int. Semantic Web Conf. (ISWC 2015), volume 9366 of Lecture Notes in Computer Science, pages 217\u2013234. Springer,", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2015}, {"title": "Elements Of Finite Model Theory", "author": ["L. Libkin"], "venue": "Springer,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 2004}, {"title": "The complexity of conjunctive query answering in expressive description logics", "author": ["C. Lutz"], "venue": "In Proc. of the 4th Int. Joint Conf. on Automated Reasoning (IJCAR 2008), number 5195 in LNAI, pages 179\u2013193. Springer,", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2008}, {"title": "Description logic tboxes: Model-theoretic characterizations and rewritability", "author": ["C. Lutz", "R. Piro", "F. Wolter"], "venue": "In Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2011), pages 983\u2013988. IJCAI/AAAI,", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2011}, {"title": "Kyrie2: query rewriting under extensional constraints in ELHIO", "author": ["J. Mora", "R. Rosati", "\u00d3. Corcho"], "venue": "In Proc. of the 13th Int. Semantic Web Conf. (ISWC 2014), volume 8796 of Lecture Notes in Computer Science, pages 568\u2013583. Springer,", "citeRegEx": "59", "shortCiteRegEx": null, "year": 2014}, {"title": "A comparison of query rewriting techniques for DLlite", "author": ["H. P\u00e9rez-Urbina", "B. Motik", "I. Horrocks"], "venue": "In Proc. of the 22nd Inte. Workshop on Description Logics (DL 2009), volume 477 of CEUR Workshop Proceedings. CEUR-WS,", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2009}, {"title": "E", "author": ["H. P\u00e9rez-Urbina"], "venue": "Rod\u0155\u0131guez-D\u0131\u0301az, M. Grove, G. Konstantinidis, and E. Sirin. Evaluation of query rewriting approaches for OWL 2. In Proc. of SSWS+HPCSW 2012, volume 943 of CEUR Workshop Proceedings. CEUR-WS,", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2012}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "Journal on Data Semantics, X:133\u2013173,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 2008}, {"title": "Monotone circuits for matching require linear depth", "author": ["R. Raz", "A. Wigderson"], "venue": "Journal of the ACM, 39(3):736\u2013744,", "citeRegEx": "63", "shortCiteRegEx": null, "year": 1992}, {"title": "Lower bounds for the monotone complexity of some Boolean functions", "author": ["A. Razborov"], "venue": "Dokl. Akad. Nauk SSSR, 281(4):798\u2013801,", "citeRegEx": "64", "shortCiteRegEx": null, "year": 1985}, {"title": "Lower bounds for deterministic and nondeterministic branching programs", "author": ["A.A. Razborov"], "venue": "In Proc. of the 8th Int. Symposium on Fundamentals of Computation Theory (FCT\u201991), volume 529 of Lecture Notes in Computer Science, pages 47\u201360. Springer,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 1991}, {"title": "High performance query answering over DL-Lite ontologies", "author": ["M. Rodriguez-Muro", "D. Calvanese"], "venue": "In Proc. of the 13th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2012), pages 308\u2013318. AAAI,", "citeRegEx": "66", "shortCiteRegEx": null, "year": 2012}, {"title": "Ontology-based data access: Ontop of databases", "author": ["M. Rodriguez-Muro", "R. Kontchakov", "M. Zakharyaschev"], "venue": "In Proc. of the 12th Int. Semantic Web Conf. (ISWC 2013), volume 8218 of Lecture Notes in Computer Science, pages 558\u2013573. Springer,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2013}, {"title": "The limits of querying ontologies", "author": ["R. Rosati"], "venue": "In Proc. of the 11th Int. Conf. on Database Theory (ICDT 2007), volume 4353 of Lecture Notes in Computer Science, pages 164\u2013178. Springer,", "citeRegEx": "68", "shortCiteRegEx": null, "year": 2007}, {"title": "Prexto: Query rewriting under extensional constraints in DL-Lite", "author": ["R. Rosati"], "venue": "In Proc. of the 9th Extended Semantic Web Conf. (EWSC 2012), volume 7295 of Lecture Notes in Computer Science, pages 360\u2013374. Springer,", "citeRegEx": "69", "shortCiteRegEx": null, "year": 2012}, {"title": "Improving query answering over DL-Lite ontologies", "author": ["R. Rosati", "A. Almatelli"], "venue": "In Proc. of the 12th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR 2010), pages 290\u2013300. AAAI Press,", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2010}, {"title": "OBDA: query rewriting or materialization? in practice, both! In Proc", "author": ["J.F. Sequeda", "M. Arenas", "D.P. Miranker"], "venue": "of the 13th Int. Semantic Web Conf. (ISWC 2014), Part I, volume 8796 of Lecture Notes in Computer Science, pages 535\u2013551. Springer,", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2014}, {"title": "On the tape complexity of deterministic context-free languages", "author": ["I.H. Sudborough"], "venue": "Journal of the ACM, 25(3):405\u2013414,", "citeRegEx": "72", "shortCiteRegEx": null, "year": 1978}, {"title": "The method of forced enumeration for nondeterministic automata", "author": ["R. Szelepcs\u00e9nyi"], "venue": "Acta Informatica, 26(3):279\u2013284,", "citeRegEx": "73", "shortCiteRegEx": null, "year": 1988}, {"title": "The complexity of relational query languages (extended abstract)", "author": ["M. Vardi"], "venue": "In Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC\u201982), pages 137\u2013146. ACM,", "citeRegEx": "74", "shortCiteRegEx": null, "year": 1982}, {"title": "Properties that characterize LOGCFL", "author": ["H. Venkateswaran"], "venue": "Journal of Computer and System Sciences, 43(2):380\u2013404,", "citeRegEx": "75", "shortCiteRegEx": null, "year": 1991}, {"title": "Introduction to Circuit Complexity: A Uniform Approach", "author": ["H. Vollmer"], "venue": "Springer,", "citeRegEx": "76", "shortCiteRegEx": null, "year": 1999}, {"title": "Algorithms for acyclic database schemes", "author": ["M. Yannakakis"], "venue": "In Proc. of the 7th Int. Conf. on Very Large Data Bases (VLDB), pages 82\u201394. IEEE Computer Society,", "citeRegEx": "77", "shortCiteRegEx": null, "year": 1981}, {"title": "Pagoda: Pay-as-you-go ontology query answering using a datalog reasoner", "author": ["Y. Zhou", "B. Cuenca Grau", "Y. Nenov", "M. Kaminski", "I. Horrocks"], "venue": "Journal of Artificial Intelligence Research (JAIR), 54:309\u2013 367,", "citeRegEx": "78", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 61, "context": "[62] with the aim of facilitating query answering over complex, possibly incomplete and heterogeneous data sources.", "startOffset": 0, "endOffset": 4}, {"referenceID": 61, "context": "[62], the OBDA system employs the ontology and mappings in order to transform the user query into a query over the data sources, and then delegates the actual query evaluation to the underlying database engines and triplestores.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[20] and later extended by Artale et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "[4], was specifically designed to ensure the existence of FO-rewritings for all conjunctive queries (CQs).", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "\u2019 Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].", "startOffset": 135, "endOffset": 146}, {"referenceID": 17, "context": "\u2019 Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].", "startOffset": 135, "endOffset": 146}, {"referenceID": 23, "context": "\u2019 Various dialects of tuple-generating dependencies (tgds) that admit FO-rewritings of CQs and extend OWL2QL have also been identified [7, 18, 24].", "startOffset": 135, "endOffset": 146}, {"referenceID": 67, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 36, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 9, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 53, "context": "We note in passing that while most work on OBDA (including the present paper) assumes that the user query is given as a CQ, other query languages, allowing limited forms of recursion and/or negation, have also been investigated [68, 37, 10, 54].", "startOffset": 228, "endOffset": 244}, {"referenceID": 61, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 91, "endOffset": 95}, {"referenceID": 69, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 111, "endOffset": 119}, {"referenceID": 68, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 111, "endOffset": 119}, {"referenceID": 48, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 144, "endOffset": 148}, {"referenceID": 33, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 195, "endOffset": 199}, {"referenceID": 50, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 206, "endOffset": 210}, {"referenceID": 59, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 303, "endOffset": 307}, {"referenceID": 22, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 315, "endOffset": 319}, {"referenceID": 26, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 329, "endOffset": 333}, {"referenceID": 58, "context": "A number of rewriting techniques have been proposed and implemented for OWL2QL (PerfectRef [62], Presto/Prexto [70, 69], tree witness rewriting [49]), sets of tuplegenerating dependencies (Nyaya [34], PURE [51]), and more expressive ontology languages that require recursive datalog rewritings (Requiem [60], Rapid [23], Clipper [27] and Kyrie [59]).", "startOffset": 344, "endOffset": 348}, {"referenceID": 18, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 70, "endOffset": 74}, {"referenceID": 60, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 95, "endOffset": 99}, {"referenceID": 70, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 114, "endOffset": 118}, {"referenceID": 29, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 145, "endOffset": 149}, {"referenceID": 66, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 192, "endOffset": 200}, {"referenceID": 52, "context": "few mature OBDA systems have also recently emerged: pioneering MASTRO [19], commercial Stardog [61] and Ultrawrap [71], and the Optique platform [30] based on the query answering engine Ontop [67, 53].", "startOffset": 192, "endOffset": 200}, {"referenceID": 45, "context": "By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.", "startOffset": 228, "endOffset": 232}, {"referenceID": 44, "context": "By providing a semantic end-to-end connection between users and multiple distributed data sources (and thus making the IT expert middleman redundant), OBDA has attracted the attention of industry, with companies such as Siemens [46] and Statoil [45] experimenting with OBDA technologies to streamline the process of data access for their engineers.", "startOffset": 245, "endOffset": 249}, {"referenceID": 35, "context": "[36, 56] and references therein.", "startOffset": 0, "endOffset": 8}, {"referenceID": 55, "context": "[36, 56] and references therein.", "startOffset": 0, "endOffset": 8}, {"referenceID": 46, "context": "[47] and Gottlob and Schwentick [35].", "startOffset": 0, "endOffset": 4}, {"referenceID": 34, "context": "[47] and Gottlob and Schwentick [35].", "startOffset": 32, "endOffset": 36}, {"referenceID": 34, "context": "Gottlob and Schwentick [35] and Gottlob et al.", "startOffset": 23, "endOffset": 27}, {"referenceID": 30, "context": "[31] showed that PE- (and so all other) \u2018rewritings\u2019 can be made polynomial under the condition that all relevant data instances contain two special constants.", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "NFAs vs DFAs, and [6]).", "startOffset": 18, "endOffset": 21}, {"referenceID": 48, "context": "Our starting point is the observation that the tree-witness PE-rewriting of an OMQ Q = (T , q) introduced by [49] defines a hypergraph whose vertices are the atoms in q and whose hyperedges correspond to connected sub-queries of q that can be homomorphically mapped to labelled nulls of some chases for T .", "startOffset": 109, "endOffset": 113}, {"referenceID": 19, "context": "It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity\u2014that is, of the same complexity as standard CQ evaluation in databases.", "startOffset": 12, "endOffset": 19}, {"referenceID": 3, "context": "It is known [20, 4] that the general OMQ answering problem is NP-complete for combined complexity\u2014that is, of the same complexity as standard CQ evaluation in databases.", "startOffset": 12, "endOffset": 19}, {"referenceID": 47, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 60, "endOffset": 64}, {"referenceID": 76, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 159, "endOffset": 171}, {"referenceID": 21, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 159, "endOffset": 171}, {"referenceID": 31, "context": "However, answering tree-shaped OMQs turns out to be NP-hard [48] in contrast to the wellknown tractability of evaluating tree-shaped and bounded-treewidth CQs [77, 22, 32].", "startOffset": 159, "endOffset": 171}, {"referenceID": 55, "context": "We remind the reader [56] that, for any CQ q(x) = \u2203y \u03c6(x,y), any first-order structure I and any tuple a from its domain \u2206, we have I |= q(a) iff there is a map h : x \u222a y \u2192 \u2206 such that (i) if S(z) \u2208 q then I |= S(h(z)), and (ii) h(x) = a.", "startOffset": 21, "endOffset": 25}, {"referenceID": 76, "context": "8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].", "startOffset": 57, "endOffset": 65}, {"referenceID": 10, "context": "8 Tree-shaped CQs also go by the name of acyclic queries [77, 11].", "startOffset": 57, "endOffset": 65}, {"referenceID": 0, "context": "Recall [1] that a datalog program, \u03a0 , is a finite set of Horn clauses \u2200x (\u03b31 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b3m \u2192 \u03b30), where each \u03b3i is an atom P (x1, .", "startOffset": 7, "endOffset": 10}, {"referenceID": 0, "context": "As defined, FO- and PE-rewritings are not necessarily domain-independent queries, while NDL-rewritings are not necessarily safe [1].", "startOffset": 128, "endOffset": 131}, {"referenceID": 18, "context": "Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large\u2014exponentially-large in the size of the original CQ, to be more precise.", "startOffset": 39, "endOffset": 43}, {"referenceID": 46, "context": "Indeed, it was observed experimentally [19] and also established theoretically [47] that sometimes the rewritings are prohibitively large\u2014exponentially-large in the size of the original CQ, to be more precise.", "startOffset": 79, "endOffset": 83}, {"referenceID": 73, "context": "In complexity-theoretic terms, the focus should not only be on the data complexity of OMQ answering, which is an appropriate measure for database query evaluation (where queries are indeed usually small) [74], but also on the combined complexity that takes into account the contribution of ontologies and queries.", "startOffset": 204, "endOffset": 208}, {"referenceID": 48, "context": "[49] (cf.", "startOffset": 0, "endOffset": 4}, {"referenceID": 56, "context": "[57, 52, 51] for rewritings based on similar ideas).", "startOffset": 0, "endOffset": 12}, {"referenceID": 51, "context": "[57, 52, 51] for rewritings based on similar ideas).", "startOffset": 0, "endOffset": 12}, {"referenceID": 50, "context": "[57, 52, 51] for rewritings based on similar ideas).", "startOffset": 0, "endOffset": 12}, {"referenceID": 16, "context": "It is not hard to see that, for any OMQ (T , q(x)) and data instance A, a tuple a is a certain answer to (T , q(x)) over A iff either T ,A |= q(a) or T ,A |= \u2203z \u03c8(z), for some \u03c8(z) \u2192 \u22a5 in T \u2212; see [17] for more details.", "startOffset": 197, "endOffset": 201}, {"referenceID": 66, "context": "Such classes of data instances can be defined, for example, by the integrity constraints in the database schema and the mapping [67].", "startOffset": 128, "endOffset": 132}, {"referenceID": 0, "context": "As is well-known [1], every pair (T ,A) of an ontology T and data instance A possesses a canonical model (or chase) CT ,A such that T ,A |= q(a) iff CT ,A |= q(a), for all CQs q(x) and a in ind(A).", "startOffset": 17, "endOffset": 20}, {"referenceID": 66, "context": "[67] used the term \u2018H-completeness\u2019; see also [50].", "startOffset": 0, "endOffset": 4}, {"referenceID": 49, "context": "[67] used the term \u2018H-completeness\u2019; see also [50].", "startOffset": 46, "endOffset": 50}, {"referenceID": 40, "context": "\u033an with n \u2264 p(|Q|) [41, 17].", "startOffset": 19, "endOffset": 27}, {"referenceID": 16, "context": "\u033an with n \u2264 p(|Q|) [41, 17].", "startOffset": 19, "endOffset": 27}, {"referenceID": 30, "context": "(In general, the bounded derivation depth property of an ontology language is a necessary and sufficient condition of FO-rewritability [31].", "startOffset": 135, "endOffset": 139}, {"referenceID": 46, "context": "The class of all OMQs (even with ontologies of finite depth and tree-shaped CQs) does not have the PFSP [47].", "startOffset": 104, "endOffset": 108}, {"referenceID": 48, "context": "Theorem 2 ([49]).", "startOffset": 11, "endOffset": 15}, {"referenceID": 2, "context": ", [3, 42]) that an n-ary Boolean function, for n \u2265 1, is any function from {0, 1} to {0, 1}.", "startOffset": 2, "endOffset": 9}, {"referenceID": 41, "context": ", [3, 42]) that an n-ary Boolean function, for n \u2265 1, is any function from {0, 1} to {0, 1}.", "startOffset": 2, "endOffset": 9}, {"referenceID": 27, "context": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].", "startOffset": 128, "endOffset": 140}, {"referenceID": 14, "context": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].", "startOffset": 128, "endOffset": 140}, {"referenceID": 15, "context": "11 Our definition of tree hypergraph is a minor variant of the notion of (sub)tree hypergraph (aka hypertree) from graph theory [28, 15, 16].", "startOffset": 128, "endOffset": 140}, {"referenceID": 28, "context": ", [29]) that a tree decomposition of an undirected graph G = (V,E) is a pair (T, \u03bb), where T is an (undirected) tree and \u03bb a function from the set of nodes of T to 2 such that \u2013 for every v \u2208 V , there exists a node N with v \u2208 \u03bb(N); \u2013 for every e \u2208 E, there exists a node N with e \u2286 \u03bb(N); \u2013 for every v \u2208 V , the nodes {N | v \u2208 \u03bb(N)} induce a (connected) subtree of T .", "startOffset": 2, "endOffset": 6}, {"referenceID": 0, "context": "A (bag) type is an m-tuple of the form w = (w[1], .", "startOffset": 45, "endOffset": 48}, {"referenceID": 2, "context": ", [3, 42].", "startOffset": 2, "endOffset": 9}, {"referenceID": 41, "context": ", [3, 42].", "startOffset": 2, "endOffset": 9}, {"referenceID": 75, "context": "LOGCFL/poly (also known as SAC) is the class of Boolean functions computable by polynomialsize and logarithmic-depth circuits in which and-gates have two inputs but or-gates can have arbitrarily many inputs (unbounded fan-in) and not-gates can only be applied to inputs of the circuit [76].", "startOffset": 285, "endOffset": 289}, {"referenceID": 63, "context": "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:", "startOffset": 86, "endOffset": 97}, {"referenceID": 1, "context": "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:", "startOffset": 86, "endOffset": 97}, {"referenceID": 43, "context": "We note in passing that the monotone variants of the classes in (9) also form a chain [64, 2, 44]:", "startOffset": 86, "endOffset": 97}, {"referenceID": 41, "context": "We remind the reader (consult [42] for more details)", "startOffset": 30, "endOffset": 34}, {"referenceID": 72, "context": "As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then \u00acf is also computable by a polynomial-size NBP.", "startOffset": 16, "endOffset": 24}, {"referenceID": 39, "context": "As follows from [73, 40], if a function f is computable by a polynomial-size NBP, then \u00acf is also computable by a polynomial-size NBP.", "startOffset": 16, "endOffset": 24}, {"referenceID": 4, "context": "We first provide a graph-theoretic characterisation of independent sets covering all zeros based on the implication graph [5].", "startOffset": 122, "endOffset": 125}, {"referenceID": 38, "context": "As shown by Huffman [39], there is a prefix binary code such that each Dj is encoded by a word of length \u2308log(m/mj)\u2309.", "startOffset": 20, "endOffset": 24}, {"referenceID": 63, "context": "A series of papers, started by Razborov [64], gave an exponential lower bound for the size of monotone circuits computing Clique, namely, 2 \u221a k)", "startOffset": 40, "endOffset": 44}, {"referenceID": 1, "context": "for k \u2264 14 (n/ logn) 2/3 [2].", "startOffset": 25, "endOffset": 28}, {"referenceID": 62, "context": "For monotone formulas, an even better lower bound is known: 2 for k = 2n/3 [63].", "startOffset": 75, "endOffset": 79}, {"referenceID": 43, "context": "It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size n.", "startOffset": 12, "endOffset": 20}, {"referenceID": 41, "context": "It is known [44, 42] that Reachability is computable by a polynomial-size monotone NBP (that is, belongs to mNL/poly), but any monotone Boolean formula for Reachability is of size n.", "startOffset": 12, "endOffset": 20}, {"referenceID": 64, "context": "Since f is NL/poly-complete under NC-reductions [65], we obtain NL/poly \u2286 NC.", "startOffset": 48, "endOffset": 52}, {"referenceID": 64, "context": "Since f is NL/polycomplete under NC-reductions [65], we obtain NL/poly \u2286 NC.", "startOffset": 47, "endOffset": 51}, {"referenceID": 0, "context": "4 except that in the definition of E i , instead of considering all types wk of Ni, we only use wk = (w[1], .", "startOffset": 103, "endOffset": 106}, {"referenceID": 47, "context": "[48] is based on a flawed proof.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 42, "endOffset": 46}, {"referenceID": 76, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 90, "endOffset": 94}, {"referenceID": 21, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 121, "endOffset": 129}, {"referenceID": 35, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 121, "endOffset": 129}, {"referenceID": 32, "context": "In general, evaluating CQs is NP-complete [21], but becomes tractable for tree-shaped CQs [77] and bounded treewidth CQs [22, 36]\u2014LOGCFL-complete, to be more precise [33].", "startOffset": 166, "endOffset": 170}, {"referenceID": 19, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 45, "endOffset": 49}, {"referenceID": 3, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 54, "endOffset": 57}, {"referenceID": 47, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 114, "endOffset": 118}, {"referenceID": 30, "context": "The NP upper bound for all OMQs was shown by [20] and [4], while the matching lower bound for tree-shaped OMQs by [48] and [31].", "startOffset": 123, "endOffset": 127}, {"referenceID": 32, "context": "We begin by showing that the LOGCFL upper bound for CQs of bounded treewidth [33] is preserved even in the presence of ontologies of bounded depth.", "startOffset": 77, "endOffset": 81}, {"referenceID": 31, "context": "As LOGCFL is closed under L reductions [32] and evaluation of CQs of bounded treewidth is LOGCFL-complete, it suffices to show that CT ,A can be computed by an L-transducer (a deterministic logspace Turing machine with a LOGCFL oracle).", "startOffset": 39, "endOffset": 43}, {"referenceID": 3, "context": "Finally, as entailment in OWL2QL is in NL [4], each of the following problems can be decided by making a call to an NL (hence LOGCFL) oracle: \u2013 decide whether a\u033a1 .", "startOffset": 42, "endOffset": 45}, {"referenceID": 3, "context": "The possible choices for z0 include ind(A) and aw \u2208 \u2206CT ,A such that |w| \u2264 2|T |+ |q|, which are enough to find a homomorphism if it exists [4].", "startOffset": 140, "endOffset": 143}, {"referenceID": 3, "context": "Finally, it should be clear that the subroutine canMap(z, u) can also be implemented in NL [4].", "startOffset": 91, "endOffset": 94}, {"referenceID": 47, "context": "It remains to settle the complexity of answering OMQs with arbitrary ontologies and boundedleaf CQs, for which neither the upper bounds from the preceding subsection nor the NP lower bound by [48] are applicable.", "startOffset": 192, "endOffset": 196}, {"referenceID": 25, "context": "An NAuxPDA [26] is a non-deterministic Turing machine with an additional work tape constrained to operate as a pushdown store.", "startOffset": 11, "endOffset": 15}, {"referenceID": 71, "context": "[72] showed that LOGCFL coincides with the class of problems that can be solved by NAuxPDAs running in logarithmic space and polynomial time (note that the space on the pushdown tape is not subject to the logarithmic space bound).", "startOffset": 0, "endOffset": 4}, {"referenceID": 74, "context": "The proof of LOGCFL-hardness is by reduction of the following problem: decide whether an input of length n is accepted by the nth circuit of a logspace-uniform family of SAC circuits, which is known to be LOGCFL-hard [75].", "startOffset": 217, "endOffset": 221}, {"referenceID": 32, "context": "This problem was used by [33] to show LOGCFLhardness of evaluating tree-shaped CQs.", "startOffset": 25, "endOffset": 29}, {"referenceID": 32, "context": "Following [33], we assume without loss of generality that the considered SAC circuits adhere to the following normal form: \u2013 fan-in of all and-gates is 2; \u2013 nodes are assigned to levels, with gates on level i only receiving inputs from gates on level i\u2212 1, the input gates on level 1 and the output gate on the greatest level; \u2013 the number of levels is odd, all even-level gates are or-gates, and all odd-level non-input gates are and-gates.", "startOffset": 10, "endOffset": 14}, {"referenceID": 32, "context": "It is well known [33, 75] that a circuit in normal form accepts an input \u03b1 iff there is a labelled rooted tree (called a proof tree) such that \u2013 the root node is labelled with the output and-gate; \u2013 if a node is labelled with an and-gate gi and gi = gj \u2227 gk, then it has two children labelled with gj and gk, respectively; \u2013 if a node is labelled with an or-gate gi and gi = gj1 \u2228 .", "startOffset": 17, "endOffset": 25}, {"referenceID": 74, "context": "It is well known [33, 75] that a circuit in normal form accepts an input \u03b1 iff there is a labelled rooted tree (called a proof tree) such that \u2013 the root node is labelled with the output and-gate; \u2013 if a node is labelled with an and-gate gi and gi = gj \u2227 gk, then it has two children labelled with gj and gk, respectively; \u2013 if a node is labelled with an or-gate gi and gi = gj1 \u2228 .", "startOffset": 17, "endOffset": 25}, {"referenceID": 32, "context": "The reduction [33], which is for presentation purposes reproduced here with minor modifications, encodes C and \u03b1 in the database and uses a Boolean tree-shaped CQ based on the skeleton proof tree.", "startOffset": 14, "endOffset": 18}, {"referenceID": 32, "context": "We point out that membership in LOGCFL implies that answering OMQs from the identified tractable classes can be \u2018profitably parallelised\u2019 (for details, consult [33]).", "startOffset": 160, "endOffset": 164}, {"referenceID": 7, "context": "In fact, much more work is required to construct NDL-rewritings that can be evaluated in LOGCFL and NL, which will be done in a follow-up publication; see technical report [8].", "startOffset": 172, "endOffset": 175}, {"referenceID": 66, "context": "As far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data.", "startOffset": 92, "endOffset": 100}, {"referenceID": 52, "context": "As far as practical OBDA is concerned, our experience with the query answering engine Ontop [67, 53], which employs the tree-witness rewriting, shows that mappings and database constraints together with semantic query optimisation techniques can drastically reduce the size of rewritings and produce efficient SQL queries over the data.", "startOffset": 92, "endOffset": 100}, {"referenceID": 65, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 68, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 54, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 11, "context": "The role of mappings and data constraints in OBDA is yet to be fully investigated [66, 69, 55, 12] and constitutes another promising avenue for future work.", "startOffset": 82, "endOffset": 98}, {"referenceID": 57, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 8, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 12, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 42, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 37, "context": "This has motivated the development of diverse methods for identifying particular ontologies and OMQs for which (first-order or Datalog) rewritings exist [58, 9, 13, 43, 38].", "startOffset": 153, "endOffset": 172}, {"referenceID": 13, "context": "Ideally, one would show that the simpler ontology is equivalent to the original with regards to query answering [14], and thus provides the exact set of answers.", "startOffset": 112, "endOffset": 116}, {"referenceID": 24, "context": "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).", "startOffset": 90, "endOffset": 98}, {"referenceID": 13, "context": "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).", "startOffset": 90, "endOffset": 98}, {"referenceID": 77, "context": "Alternatively, one can use a simpler ontology to approximate the answers for the full one [25, 14] (possibly employing a more costly complete algorithm to decide the status of the remaining candidate answers [78]).", "startOffset": 208, "endOffset": 212}, {"referenceID": 3, "context": "Without loss of generality we may choose h so that the image of h consists of elements aw with |w| \u2264 2|T |+ |q| [4].", "startOffset": 112, "endOffset": 115}, {"referenceID": 32, "context": "Since C accepts input \u03b1 iff there is a homomorphism h from q to D(\u03b1) [33], it suffices to show that there exists a homomorphism f from q\u2032 to CT\u03b1,A iff there is a homomorphism h from q to D(\u03b1):", "startOffset": 69, "endOffset": 73}], "year": 2016, "abstractText": "We give solutions to two fundamental computational problems in ontologybased data access with the W3C standard ontology language OWL2QL: the succinctness problem for first-order rewritings of ontology-mediated queries (OMQs), and the complexity problem for OMQ answering. We classify OMQs according to the shape of their conjunctive queries (treewidth, the number of leaves) and the existential depth of their ontologies. For each of these classes, we determine the combined complexity of OMQ answering, and whether all OMQs in the class have polynomial-size first-order, positive existential, and nonrecursive datalog rewritings. We obtain the succinctness results using hypergraph programs, a new computational model for Boolean functions, which makes it possible to connect the size of OMQ rewritings and circuit complexity.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}