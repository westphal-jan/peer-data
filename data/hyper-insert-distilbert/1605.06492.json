{"id": "1605.06492", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-May-2016", "title": "Linear-Memory and Decomposition-Invariant Linearly Convergent Conditional Gradient Algorithm for Structured Polytopes", "abstract": "other recently, several philosophical works have shown that natural modifications speak of beyond the classical conditional gradient optimal method ( aka frank - julius wolfe decomposition algorithm ) for constrained convex optimization, provably converge with corresponding a linear rate when : requires i ) acknowledging the feasible set is automatically a cardinal polytope, and ii ) satisfying the objective path is smooth and then strongly - convex. however, all of these results suffer equally from other two least significant memory shortcomings : large memory bandwidth requirement due primarily to the size need inherent to fully store for an explicit convex decomposition replica of the relevant current iterate, and as a humorous consequence, consequently large running - time error overhead drops per iteration, and exponential worst end case rapid convergence rate that depends much unfavorably back on the dimension.", "histories": [["v1", "Fri, 20 May 2016 19:55:48 GMT  (275kb,D)", "http://arxiv.org/abs/1605.06492v1", null]], "reviews": [], "SUBJECTS": "math.OC cs.LG", "authors": ["dan garber", "ofer meshi"], "accepted": true, "id": "1605.06492"}, "pdf": {"name": "1605.06492.pdf", "metadata": {"source": "CRF", "title": "Linear-memory and Decomposition-invariant Linearly Convergent Conditional Gradient Algorithm for Structured Polytopes", "authors": ["Dan Garber", "Ofer Meshi"], "emails": ["meshi}@ttic.edu"], "sections": [{"heading": null, "text": "1. large memory requirement due to the need to store an explicit convex decomposition of the current iterate, and as a consequence, large running-time overhead per iteration\n2. the worst case convergence rate depends unfavorably on the dimension\nIn this work we present a new conditional gradient variant and a corresponding analysis that improves on both of the above shortcomings. In particular:\n1. both memory and computation overheads are only linear in the dimension\n2. in case the optimal solution is sparse, the new convergence rate replaces a factor which is at least linear in the dimension in previous works, with a linear dependence on the number of non-zeros in the optimal solution\nAt the heart of our method, and corresponding analysis, is a novel way to compute decomposition-invariant away-steps. While our theoretical guarantees do not apply to any polytope, they apply to several important structured polytopes that capture central concepts such as paths in graphs, perfect matchings in bipartite graphs, marginal distributions that arise in structured prediction tasks, and more. Our theoretical findings are complemented by empirical evidence which shows that our method delivers state-of-the-art performance."}, {"heading": "1 Introduction", "text": "The efficient reduction of a constrained convex optimization problem to a constrained linear optimization problem is an appealing algorithmic concept, in particular for large-scale problems. The reason is that for many feasible sets of interest, the problem of minimizing a linear function over the set admits much more efficient methods than its non-linear convex counterpart. Prime examples for this phenomenon include various structured polytopes that arise in combinatorial optimization, such as the path polytope of a graph (aka the unit flow polytope), the perfect matching polytope of a bipartite graph, and the base polyhedron of a matroid, for which we have highly efficient combinatorial algorithms for linear minimization that rely heavily on the specific rich structure of the polytope [22]. At the same time, minimizing a non-linear convex function over these sets usually requires the use of generic interior point solvers that are oblivious to the specific combinatorial structure of the underlying set, and as a result, are often\nar X\niv :1\n60 5.\n06 49\n2v 1\n[ m\nat h.\nO C\n] 2\n0 M\nay 2\n01 6\nmuch less efficient. Another important example includes structured sets of matrices such as the spectrahedron, i.e., convex-hull of unit-trace positive semidefinite matrices, or the nuclear ball that are central to many machine learning problems, such as matrix completion, for which linear optimization amounts to computing the leading eigenvector or leading pair of singular vectors, whereas, algorithms for non-linear convex optimization over these sets often rely on very expensive singular value decompositions. Indeed, it is for this reason, that the conditional gradient (CG) method (aka Frank-Wolfe algorithm), a method for constrained convex optimization that is based on solving linear subproblems over the feasible domain, has regained much interest in recent years in the machine learning, signal processing and optimization communities. It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].\nAs part of the regained interest in the conditional gradient method, there is also a recent effort to understand the convergence rates and associated complexities of conditional gradientbased methods, which is in general far less understood than other first-order methods, e.g., the projected gradient method. It is known, already from the first introduction of the method by Frank and Wolfe in the 1950\u2019s [5], and the somewhat later work of Polyak and Levitin [20], that the method converges with a rate of roughly O(1/t) for minimizing a smooth convex function over a convex and compact set, which matches the rate of the standard projected gradient method for the same setting. However, it is not clear if this convergence rate improves under an additional standard strong-convexity assumption. In fact, certain lower bounds, such as in [18, 6], suggest that such improvement, even if possible, should come with a worse dependence on the problem\u2019s parameters (e.g., the dimension), which is a phenomena that does not occur for the projected gradient method, for instance. Nevertheless, over the past years, various works tried to design natural variants of the CG method that converge provably faster under the additional strong convexity assumption, or a slightly weaker assumption, without dramatically increasing the per-iteration complexity, which is the main appeal for these methods. For instance, Gue\u0301Lat and Marcotte [8] showed that a CG variant which uses the concept of away-steps converges exponentially fast in case the objective function is strongly convex, the feasible set is a polytope, and the optimal solution is located in the interior of the set. A similar result was presented by Beck and Teboulle [3] who considered a specific problem they refer to a the convex feasibility problem over an arbitrary convex set. They also obtained a linear convergence rate under the assumption that an optimal solution that is far enough from the boundary of the set exists. In both of these works, the exponent depends on the distance of the optimal solution from the boundary of the set, which in general can be arbitrarily small. Later, Ahipasaoglu, Sun and Todd [1] showed that in the specific case of minimizing a smooth and strongly convex function over the unit simplex, a variant of the CG method which also uses away-steps, converges with a linear rate. Unfortunately, it is not clear from their analysis how this rate depends on natural parameters of the problem such as the dimension and the condition number of the objective function.\nRecently, Garber and Hazan presented the first natural linearly-converging CG variant for polytopes without any restricting assumptions on the location of the optimum. The exponent in their convergence rate depends on various geometric parameters of the polytope [6]. It is important to note, that while, in theory, these geometric parameters can result in an arbitrarily bad convergence rate, for polytopes for which it makes sense to apply the CG method, i.e., there exists an highly efficient algorithm to solve the linear subproblems, such as polytopes that arise in combinatorial optimization problems, these parameters are quite reasonable and can be efficiently computed. In a follow-up work, Lacoste-Julien and Jaggi [15, 16] gave a refined affine-invariant analysis of an algorithm presented in [8] which also uses away steps, and showed that it also converges exponentially fast in the same setting as the Garber-Hazan\nresult. In a later work, Beck and Shtern [2] gave a different, duality-based, analysis for the algorithm of [8], and showed that it can be applied to a wider class of functions than purely strongly convex functions. However, the explicit dependency of their convergence rate on the dimension is suboptimal, compared to [6, 16]. Aside from the polytope case, Garber and Hazan have shown recently that in case the feasible set is strongly-convex and the objective function satisfies certain strong convexity-like proprieties, then the standard CG method converges with an accelerated rate of O(1/t2) [7].\nDespite the exponential improvement in convergence rate in the polytope case obtained in recent results, all of these results suffer from two major drawbacks. First, while in terms of the number of calls per-iteration to the linear optimization oracle, these methods match the standard CG method, i.e., a single call per iteration, the overhead of other operations both in terms of running times and memory requirements is significantly worse. The reason is that in order to apply the so-called away-steps, which all methods use in order to obtain the accelerated rate, they require to maintain at all times an explicit decomposition of the current iterate into vertices of the polytope. Maintaining such a decomposition and computing the away-steps, even with efficient implementations of incremental decomposition procedures, such as suggested in [2], require both memory and per-iteration runtime overheads that are at least quadratic in the dimension. This is much worse than the standard CG method, whose memory and runtime overheads are only linear in the dimension. Second, the convergence rate of all previous linearly convergent CG methods depends explicitly on the dimension. While it is known that this dependency is unavoidable in certain cases, e.g., when the optimal solution is, informally speaking, dense (see for instance the lower bound in [6]), it is not clear that such an unfavorable dependence is mandatory when the optimum is sparse.\nIn this paper, we revisit the application of CG variants to smooth and strongly-convex optimization over polytopes. We introduce a new variant which overcomes both of the above shortcomings from which all previous linearly-converging variants suffer. The main novelty of our method, which is the key to its improved performance, is that unlike previous variants, it is decomposition-invariant, i.e., it does not require to maintain an explicit convex decomposition of the current iterate. This principle proves to be crucial both for eliminating the memory and runtime overheads, as well as to obtaining shaper convergence rates for instances that admit a sparse optimal solution.\nWe give a detailed comparison of our method to previous art in Table 1. We also provide empirical evidence that the proposed method delivers state-of-the-art performance on several tasks of interest. While our method is less general than previous ones, i.e., our theoretical guarantees do not hold for arbitrary polytopes, they readily apply for many structured polytopes that capture important concepts such as paths in graphs, perfect matchings in bipartite graphs, Markov random fields, and more. We also specify how to apply the method to arbitrary polytopes, but without giving formal convergence guarantees."}, {"heading": "1.1 Organization of the paper", "text": "The rest of this paper is organized as follows. In Section 2 we give preliminaries and notation, and present the exact setting considered in this paper. In Section 3 we briefly present the conditional gradient method and its previous away-steps-based variants, and present our new method: a decomposition-invariant pairwise conditional gradient algorithm. In this section we also give our main theorem which details the novel convergence rate of our method. In Section 4 we briefly describe several important polytopes that fall into our assumptions, and detail the application of our method for optimization over these polytopes. In Section 5 we give a complete analysis of our method and prove the main theorem. In Section 6 we detail how to apply our\napproach to a broader class of polytopes, though we do not complement our algorithm with a convergence rate result in this case. We also show that our requirement that the objective function is strongly convex can be relaxed, and that our results in fact hold for a broader class of functions. In Section 7 we introduce a lower-bound for conditional gradient-based methods, that shows that for certain problems with a sparse optimal solution, our method is nearly optimal. Finally, in Section 8 we present empirical evidence which demonstrates the performance of our method."}, {"heading": "2 Preliminaries", "text": "Definition 1. We say that a function f(x) : Rn \u2192 R is \u03b1-strongly convex w.r.t. a norm \u2016 \u00b7 \u2016, if for all x, y \u2208 Rn it holds that\nf(y) \u2265 f(x) +\u2207f(x) \u00b7 (y \u2212 x) + \u03b1 2 \u2016x\u2212 y\u20162.\nDefinition 2. We say that a function f(x) : Rn \u2192 R is \u03b2-smooth w.r.t. a norm \u2016 \u00b7 \u2016, if for all x, y \u2208 Rn it holds that\nf(y) \u2264 f(x) +\u2207f(x) \u00b7 (y \u2212 x) + \u03b2 2 \u2016x\u2212 y\u20162.\nThe first-order optimality condition implies that for a \u03b1-strongly convex f , if x\u2217 is the unique minimizer of f over a convex and compact set K \u2282 Rn, then for all x \u2208 K it holds that\nf(x)\u2212 f(x\u2217) \u2265 \u03b1 2 \u2016x\u2212 x\u2217\u20162. (1)\nThroughout this work we let \u2016\u00b7\u2016 denote the standard euclidean norm. Given a point x \u2208 Rn, we let card(x) denote the number of non-zero entries in x."}, {"heading": "2.1 Setting", "text": "In this work we consider the following optimization problem:\nmin x\u2208P f(x).\nWe make the following assumptions on f and P:\n\u2022 f(x) is \u03b1-strongly convex and \u03b2-smooth with respect to the `2 norm.\n\u2022 P is a polytope which satisfies the following two properties:\n1. P can be described algebraically as P = {x \u2208 Rn |x \u2265 0, Ax = b} . 2. All vertices of P lie on the hypercube {0, 1}n.\nWe let x\u2217 denote the (unique) minimizer of f over P, and we let D denote the Euclidean diameter of P, namely, D = maxx,y\u2208P \u2016x\u2212 y\u2016. We let V denote the set of vertices of P, where according to our assumptions, it holds that V \u2282 {0, 1}n.\nWhile the polytopes that satisfy the above assumptions are not completely general, these assumptions already capture several important concepts such as paths in graphs, perfectmatchings, Markov random fields, and more. Indeed, a surprisingly large number of applications from machine learning, signal processing and other domains formulate optimization problems in this category (e.g., [12, 14, 16]). We give detailed examples of such polytopes in Section 4. Importantly, the above assumptions allow us to get rid of the dependency of the convergence rate on certain geometric parameters (such as \u03c8, \u03be in [6] or the pyramidal width in [15, 16]), which can be polynomial in the dimension, and hence result in an impractical convergence rate. Finally, for many of these polytopes, the vertices are sparse, i.e., for any vertex v \u2208 V, card(v) << n. In this case, when the optimum x\u2217 can be decomposed as a convex combination of only a few vertices (and thus, sparse by itself), we get a sharper convergence rate that depends on the sparsity of x\u2217 and not explicitly on the dimension, as in previous works.\nWe believe that our theoretical guarantees could be well extended to more general polytopes and we leave this extension for future work."}, {"heading": "3 Our Approach", "text": "In order to better communicate our ideas, we begin by first briefly introducing the standard conditional gradient method and its accelerated away-steps-based variants. We discuss both the blessings and shortcomings of these away-steps-based variants in Subsection 3.1. Then, in Subsection 3.2, we present our new method, a decomposition-invariant away-steps-based conditional gradient algorithm, and discuss how it addresses the major shortcomings of previous away-steps-based variants."}, {"heading": "3.1 The conditional gradient method and acceleration via away-steps", "text": "The standard conditional gradient algorithm is given below (Algorithm 1). It is well known that when setting the step-size \u03b7t in an appropriate way, the worst case convergence rate of the method is O(\u03b2D2/t) [12]. This convergence rate is tight for the method in general, see for instance [18].\nConsider the iterate of Algorithm 1 on iteration t, and let xt = \u2211k\ni=1 \u03bbivi be its convex decomposition into vertices of the polytope P. Note that Algorithm 1, implicitly discounts each coefficient \u03bbi by a factor (1 \u2212 \u03b7t), in favor of the new added vertex vt. A different approach,\nAlgorithm 1 Conditional Gradient\n1: Let x1 be some vertex in V 2: for t = 1... do 3: vt \u2190 arg minv\u2208V v \u00b7 \u2207f(xt) 4: choose a step-size \u03b7t \u2208 (0, 1] 5: xt+1 \u2190 (1\u2212 \u03b7t)xt + \u03b7tvt 6: end for\nis not to decrease all vertices in the decomposition of xt uniformly, but to more-aggressively decrease vertices that are worse than others, with respect to some computable measure, such as their product with the gradient direction. This key principle proves to be crucial to breaking the 1/t rate of the standard method, and to achieve a linear convergence rate under certain strong-convexity assumptions, as described in the recent works [6, 16, 2]. For instance, in [6] it was shown, via the introduction of the concept of a Local Linear Optimization Oracle, that using such a non-uniform reweighing rule, in fact approximates a certain proximal problem, that together with the shrinking effect of strong convexity, as captured by Eq. (1), yields a linear convergence rate. We refer to these methods as away-step-based CG methods. As a concrete example, which will also serve as a basis for our new method, we bring the pairwise variant recently studied in [16], which applies this principle in Algorithm 2, given below 1. Note that Algorithm 2 decreases the weight of exactly one vertex in the decomposition: that with the largest product with the gradient.\nIt is important to note that since previous away-step-based CG, unlike the original CG method, do not decrease the coefficients in the convex decomposition of the current iterate uniformly, they all require to explicitly store and maintain a convex decomposition of the current iterate. This issue raises two main disadvantages:\nSuperlinear memory and running-time overheads Storing a decomposition of the current iterate as a convex combination of vertices of the polytope generally requires O(n2) memory. While the away-step-based variants increase the size of the decomposition by at most a single vertex per iteration, they also typically exhibit linear convergence after performing at least O(n) steps [6, 16, 2], and thus, this O(n2) estimate still holds. Moreover, since these methods require i) to find the worse vertex in the decomposition, in terms of dot-product with current gradient direction, and ii) to update this decomposition on each iteration (even when using sophisticated update techniques such as in [2]), the per-iteration over-head in terms of computation time of these methods is also at least O(n2).\nDecomposition-specific performance While the choice of new vertex to be added in Algorithms 1 is independent of a specific representation of the current iterate xt as a convex combination of vertices of the polytope, the choice of away-step in Algorithm 2 does depend on the specific decomposition that is maintained by the algorithm. Since the feasible point xt may admit several different convex decompositions, committing to one such decomposition, might result in sub-optimal away-steps. Ideally, the away-steps, much like the standard CG methods, will be independent of any specific decomposition. As observable in Table 1, for certain problems in which the optimal solution is sparse, all analyses of previous away-steps-based variants are significantly suboptimal, since they all depend explicitly on the dimension, which seems to\n1While the convergence rate of this pairwise variant, established in [16], despite being linear, is significantly worse than other away-step-based variants, here we show on the contrary, that a proper analysis yields state-ofthe-art performance guarantees.\nbe an unavoidable side-effect of being decomposition-dependent. On the other hand, the fact that our new approach is decomposition-invariant allows us to obtain sharper convergence rates for such instances.\nAlgorithm 2 Pairwise Conditional Gradient\n1: Let x1 be some vertex in V 2: for t = 1... do 3: let \u2211kt i=1 a (i) t v (i) t be an explicitly maintained convex decomposition of xt 4: v+t \u2190 arg minv\u2208V v \u00b7 \u2207f(xt) 5: jt \u2190 arg minj\u2208[kt] v (j) t \u00b7 (\u2212\u2207f(xt)) 6: choose a step-size \u03b7t \u2208 (0, a(jt)t ] 7: xt+1 \u2190 xt + \u03b7t(v+t \u2212 v (jt) t ) 8: update the convex decomposition of xt+1 9: end for"}, {"heading": "3.2 A new decomposition-invariant pairwise conditional gradient method", "text": "Our main observation is that in many cases of interest, given a feasible iterate xt, one can in-fact compute an optimal away-step from xt without relying on any single specific decomposition. This observation allows us to overcome both of the main disadvantages of previous away-stepbased CG variants. Our algorithm, which we refer to as a decomposition-invariant pairwise conditional gradient (DICG), is given below in Algorithm 3.\nAlgorithm 3 Decomposition-invariant Pairwise Conditional Gradient\n1: input: sequence of step-sizes {\u03b7t}t\u22651 2: let x0 be an arbitrary point in P 3: x1 \u2190 arg minv\u2208V v \u00b7 \u2207f(x0) 4: for t = 1... do 5: v+t \u2190 arg minv\u2208V v \u00b7 \u2207f(xt) 6: define the vector \u2207\u0303f(xt) \u2208 Rm as follows:\n\u2207\u0303f(xt)i := { \u2207f(xt)i if xt > 0 \u2212\u221e if xt = 0\n7: v\u2212t \u2190 arg minv\u2208V v \u00b7 ( \u2212\u2207\u0303f(xt) ) 8: choose a new step-size \u03b7\u0303t using one of the following two options:\nOption 1: predefined step-size let \u03b4t be the smallest natural such that 2 \u2212\u03b4t \u2264 \u03b7t, and set a new step-size \u03b7\u0303t \u2190 2\u2212\u03b4t\nOption 2: line-search \u03b3t \u2190 max\u03b3\u2208[0,1]{xt + \u03b3(v+t \u2212 v \u2212 t ) \u2265 0}, \u03b7\u0303t \u2190 min\u03b7\u2208(0,\u03b3t] f(xt + \u03b7(v + t \u2212 v \u2212 t ))\n9: xt+1 \u2190 xt + \u03b7\u0303t(v+t \u2212 v \u2212 t )\n10: end for\nThe following observation details the optimality of away-steps taken by Algorithm 3.\nObservation 1 (optimal away-steps in Algorithm 3). Consider an iteration t of Algorithm 3 and suppose that the iterate xt is feasible. Let xt = \u2211k i=1 \u03bbivi for some integer k, be an\nirreducible way of writing xt as a convex sum of vertices of P, i.e., \u03bbi > 0 for all i \u2208 [k]. Then it holds that\n\u2200i \u2208 [k] : vi \u00b7 \u2207f(xt) \u2264 v\u2212t \u00b7 \u2207f(xt), \u03b3t \u2265 min{xt(i) | i \u2208 [n], xt(i) > 0}. Proof. Let xt = \u2211k\ni=1 \u03bbivi be a convex decomposition of xt into vertices of P, for some integer k, where each \u03bbi is positive. Note that it must hold that for any j \u2208 [n] and any i \u2208 [k], xt(j) = 0 \u21d2 vi(j) = 0, since by our assumption on P, V \u2282 Rn+. The observation then follows directly from the definition of v\u2212t .\nThe following theorem which details the convergence rate of Algorithm 3 is the main theorem of this paper.\nTheorem 1. Let M1 = \u221a \u03b1 8card(x\u2217) and M2 = \u03b2D2 2 . Consider running Algorithm 3 with Option"}, {"heading": "1 for the step-size, and suppose that", "text": "\u2200t \u2265 1 : \u03b7t = M1\n2 \u221a M2\n( 1\u2212 M 2 1\n4M2\n) t\u22121 2\n.\nThen the iterates of Algorithm 3 are always feasible and satisfy:\n\u2200t \u2265 1 : f(xt)\u2212 f(x\u2217) \u2264 \u03b2D2\n2 exp\n( \u2212 \u03b1\n8\u03b2D2card(x\u2217) t\n) .\nThe following corollary of Theorem 1 shows that the so-called duality gap, defined as gt := (xt\u2212 v+t ) \u00b7\u2207f(xt), which serve as a certificate of the sub-optimality of the iterates of Algorithm 3, also converges with a linear rate.\nCorollary 1. For any iteration t of Algorithm 3, define the dual gap gt := (xt \u2212 v+t ) \u00b7 \u2207f(xt), and observe that, since f(x) is convex, ht \u2264 gt. Then, for any t which satisfies: ht \u2264 \u03b2D 2\n2 , it holds that\ngt \u2264 \u221a 2\u03b2D2ht.\nWe now turn to make several remarks regarding Algorithm 3 and Theorem 1:\n\u2022 Note that on any iteration t of the algorithm, aside from the computation of the gradient vector \u2207f(xt) and the two calls to the linear optimization oracle of P, all other computations, when using the first option for choosing the step-size, can be carried out in O(n) time and space. This is much more efficient than previous linearly convergent CG variant, such as those in [6, 16, 2], which typically require at least additional O(n2) time and space per iteration, since they require to maintain an explicit convex decomposition of the iterates.\n\u2022 Note that despite the different parameters of the problem at hand (e.g., \u03b1, \u03b2,D, card(x\u2217)), running the algorithm with Option 1 for choosing the step-size, for which the guarantee of Theorem 1 holds, requires the knowledge of a single parameter, i.e., M1/ \u221a M2. In\nparticular, it is an easy consequence that running the algorithm with an estimate M \u2208 [0.5M1/ \u221a M2, M1/ \u221a M2], will only affect the leading constant in the convergence rate listed in the theorem. Hence, M1/ \u221a M2 could be efficiently estimated via a logarithmicscale search.\n\u2022 Theorem 1 improves significantly over the convergence rate established for the pairwise conditional gradient variant in [16]. In particular, the number of iterations to reach an error in the analysis of [16] depends linearly on |V|!, where |V| is the number of vertices of P."}, {"heading": "4 Examples of Polytopes", "text": "In this section we turn to survey several important examples of structured polytopes that fit the assumptions detailed in Subsection 2.1 and detail the application of Algorithm 3 to optimization over these polytopes.\nUnit Simplex The simplex in Rn is the set of all distributions over n elements, i.e. the set:\nSn = {x \u2208 Rn |x \u2265 0 , n\u2211 i=1 xi = 1}.\nAlternatively, Sn is the convex hull of all standard basis vectors in Rn. It is easy to verify that D = \u221a 2.\nLinear minimization over the simplex is trivial and can be carried out by a single pass over the non-zero elements in the linear objective. In particular, computing v\u2212t in Algorithm 3 simply amounts to finding the largest (signed) entry in \u2207f(xt) which corresponds to a non-zero entry in xt, and thus is even more efficient than computing the standard CG direction v + t .\nFlow polytope Let G be a directed acyclic graph (DAG) with a set of vertices V such that |V | = n, and a set of edges E such that |E| = m, and let s, t be two vertices in V which we refer to as the source and the target, respectively. The s\u2212 t flow polytope, denoted here by Fst, is the set of all unit s\u2212 t flows in G, where for each point x \u2208 Fst and i \u2208 [m], the entry xi is the amount of flow through edge i according to the flow x. Fst is also known as the s\u2212 t path polytope since it is the convex hull of all identifying vectors of paths from s to t in the graph G. It is easy to verify that that D < \u221a 2n.\nSince Fst is the convex hull of paths, linear minimization is straightforward: given a linear objective c \u2208 Rm, we need to find the identifying vector of the lightest s \u2212 t path in G with respect to the edge weights induced by c. Since the graph G is a DAG, this could be carried out in O(m) time [22]. In particular, computing the direction v\u2212t in Algorithm 3 over the flow polytope, amounts to finding the lightest s \u2212 t path in G with respect to the gradient vector \u2207f(xt), under the constraint that all edges on the path are assigned non-zero flow by xt. Thus, we can compute v\u2212t by running a shortest s \u2212 t path algorithm after removing all edges with zero flow from the graph. Thus, as in the simplex case, computing v\u2212t is even more efficient than computing the standard direction v+t .\nIt is also important to note that when G is not extremely sparse, i.e., when m = \u03c9(n), it holds for every vertex v of Fst that card(v) << m. Thus, if x\u2217 can be expressed as a combination of only a few paths, i.e., it corresponds to a sparse flow, it holds that card(x\u2217) is much smaller than the standard dimension of the problem m.\nPerfect Matchings polytope Let G be a bipartite graph with n vertices on each side and m crossing edges. The perfect matching polytope, denoted here by M, is the convex hull of all identifying vectors of perfect matchings in G. In case the two sides of G are fully connected, this polytope is also known as the Birkhoff polytope - the set of all n\u00d7n doubly stochastic matrices, i.e. matrices with non-negative real entries whose entries along any row and any column add up to 1. It easily follows that D \u2264 \u221a 2n.\nIn order to minimize a linear objective over M, we need to find a minimum-weight perfect matching in a bipartite graph, where the edge weights are induced by the linear objective. This could be carried out via combinatorial algorithms in min{O\u0303( \u221a nm), O(n3)} time [22]. As in the flow polyope, in this case also, computing v\u2212t is even more efficient than computing v + t , since it\namounts to finding a minimum weight perfect matching after all edges that are zero-valued in xt are removed from the graph.\nAs in the flow polytope, in case G is not trivially sparse, i.e., when m = \u03c9(n), it holds that if x\u2217 could be expressed as a combination of only a few matchings in G, then card(x\u2217) << m, where m is the dimension of the problem.\nMarginal polytope In Graphical Models several optimization problems are defined for variables representing marginal distributions over subsets of model variables. There exists a set of linear constraints, known as the marginal polytope, which guarantees that these variables are legal marginals of some global distribution [25]. For example, the learning problem in Max-Margin Markov Networks is defined as a quadratic program over the marginal polytope [24].\nFor general graphical models the marginal polytope consists of an exponential number of constraints. Fortunately, for some models, such as tree-structured graphs, the polytope can be characterized by a polynomial number of local consistency constraints, known as the local marginal polytope [25]. Consider a set of discrete variables (y1, . . . , yn), and denote by \u00b5c(yc) the marginal probability of an assignment to a subset of these variables yc. Then the local marginal polytope is defined as:\nML = { \u00b5 \u2265 0 : \u2211 yc\\i\n\u00b5c(yc) = \u00b5i(yi) \u2200c, i \u2208 c, yi\u2211 yi \u00b5i(yi) = 1 \u2200i\n}\nFor tree-structured graphsML is known to have only integral vertices [25], so it has the desired form assumed in Section 2.1.\nIn this case D = \u221a\n2|C|, where C is the number of subsets yc (factors in the graphical model). In many interesting cases linear optimization over the marginal polytope can be implemented efficiently via dynamic programming. For example, for chain-structured graphs the Viterbi algorithm is used. Finally, we note that computing the direction v\u2212t in Algorithm 3 can often be cheaper than computing v+t , since the restriction to the support of xt can eliminate many of the possible configurations of marginals."}, {"heading": "5 Analysis", "text": "In this section we turn to analyze the performance of Algorithm 3, and prove Theorem 1. Throughout this section we let ht denote the approximation error of Algorithm 3 on iteration t, for any t \u2265 1, i.e., ht = f(xt)\u2212 f(x\u2217)."}, {"heading": "5.1 Feasibility of the iterates generated by Algorithm 3", "text": "We start by proving that the iterates of Algorithm 3 are always feasible. While feasibility is straightforward when using the the line-search option to set the step-size (Option 2), it is less obvious when using the first option.\nObservation 2. Suppose that on some iteration t of Algorithm 3, the iterate xt is feasible, and that the step-size is chosen using Option 1. Then, if for all i \u2208 [n] for which xt(i) 6= 0 it holds that xt(i) \u2265 \u03b7\u0303t, then the following iterate xt+1 is also feasible.\nProof. From the optimality of v\u2212t it follows that for any i \u2208 [n], if xt(i) = 0, then v \u2212 t (i) = 0 (note in particular that any vertex with positive weight in some convex decomposition of xt must satisfy this condition). Thus, from our assumption on the size of positive entries in xt,\nand since v\u2212t \u2208 {0, 1}n, it follows that the vector wt := xt \u2212 \u03b7\u0303tv \u2212 t , satisfies: wt \u2265 0. Since v + t is feasible it also follows that xt+1 = wt + \u03b7\u0303t \u2265 0. Finally, since xt, v\u2212t , v + t are all feasible, it also holds that Axt+1 = b. Thus, xt+1 is feasible.\nLemma 1 (feasibility of iterates under Option 1). Suppose that the sequence of step-sizes {\u03b7t}t\u22651 is monotonically non-increasing, and contained in the interval [0, 1]. Then, the iterates generated by Algorithm 3 using Option 1 for setting the step-size, are always feasible.\nProof. We are going to prove by induction that on each iteration t there exists a non-negative integer-valued vector st \u2208 Nn, such that for any i \u2208 [n], it holds that xt(i) = 2\u2212\u03b4tst(i). The lemma then follows by applying Observation 2, and since by definition, \u03b7\u0303t = 2\n\u2212\u03b4t . The base case t = 1 holds since x1 is a vertex of P and thus for any i \u2208 [n] we have that x1(i) \u2208 {0, 1} (recall that V \u2282 {0, 1}n). On the other hand, since \u03b71 \u2264 1, it follows that \u03b41 \u2265 0. Thus, there indeed exists a non-negative integer-valued vector s1, such that x1 = 2\n\u2212\u03b41s1. Suppose now that the induction holds for some t \u2265 1. Since by definition of v\u2212t , subtracting \u03b7\u0303tv \u2212 t from xt can only decrease positive entries in xt (see proof of Observation 2), and both v\u2212t , v + t are vertices of P (and thus in {0, 1}n), and \u03b7\u0303t = 2\u2212\u03b4t , it follows that each entry i in xt+1 is given by:\nxt+1(i) = 2 \u2212\u03b4t  st(i) if st(i) \u2265 1 & v\u2212t (i) = v+t (i) = 1 or v\u2212t (i) = v+t (i) = 0 st(i)\u2212 1 if st(i) \u2265 1 & v\u2212t (i) = 1 & v+t (i) = 0 st(i) + 1 if v \u2212 t (i) = 0 & v + t (i) = 1\nThus, xt+1 can also be written in the form 2 \u2212\u03b4t s\u0303t+1 for some s\u0303t+1 \u2208 Nn. By definition of\n\u03b4t and the monotonicity of {\u03b7t}t\u22651, we have that 2 \u2212\u03b4t\n2\u2212\u03b4t+1 is a positive integer. Thus, setting\nst+1 = 2\u2212\u03b4t\n2\u2212\u03b4t+1 s\u0303t+1, the induction holds also for t+ 1."}, {"heading": "5.2 Bounding the per-iteration error-reduction of Algorithm 3", "text": "The following technical lemma is the key to deriving the linear convergence rate of our method, and in particular, to deriving the improved dependence on the sparsity of x\u2217, instead of the dimension. At a high-level, the lemma translates the `2 distance between two feasible points into a `1 distance in a simplex defined over the set of vertices of the polytope, which as we will show, is a natural way to measure distances for conditional gradient-based methods.\nLemma 2. Let x, y \u2208 P. There exists a way to write x as a convex combination of vertices of P, x = \u2211k i=1 \u03bbivi for some integer k, such that y can be written as y = \u2211k i=1(\u03bbi\u2212\u2206i)vi+( \u2211k i=1 \u2206i)z\nwith \u2206i \u2208 [0, \u03bbi] \u2200i \u2208 [k],z \u2208 P, and \u2211k i=1 \u2206i \u2264 \u221a card(y)\u2016x\u2212 y\u2016.\nProof. Consider writing y as some convex combination of vertices, y = \u2211s\ni=1 \u03b3iui for some appropriate integer s. Applying Lemma 5.3. from [6], it follows that we can write x as\nx = s\u2211 i=1 (\u03b3i \u2212 \u2206\u0303i)ui + ( s\u2211 i=1 \u2206\u0303i)z\u0303, (2)\nwhere \u2206\u0303i \u2208 [0, \u03b3i]\u2200i \u2208 [s], z\u0303 \u2208 P, and for every i with \u2206\u0303i > 0 there exists ji \u2208 [n] such that z\u0303(ji) = 0 and ui(ji) > 0. Since each ui is a vertex of P and thus a point of the {0, 1}-hypercube, it further follows that ui(ji) = 1. Let C = {ji | i \u2208 [s]}. Observe that |C| \u2264 card(y). Now, we\nhave that\n\u2016x\u2212 y\u20162 = \u2016 s\u2211 i=1 \u2206\u0303i(ui \u2212 z\u0303)\u20162 \u2265 \u2211 j\u2208C ( s\u2211 i=1 \u2206\u0303i(ui(j)\u2212 z\u0303(j)) )2 = \u2211 j\u2208C ( s\u2211 i=1 \u2206\u0303iui(j) )2\n\u2265 1 |C| \u2211 j\u2208C s\u2211 i=1 \u2206\u0303iui(j) 2 \u2265 1 |C| ( s\u2211 i=1 \u2206\u0303i )2 .\nRearranging we have that\ns\u2211 i=1 \u2206\u0303i \u2264 \u221a |C|\u2016x\u2212 y\u2016 \u2264 \u221a card(y)\u2016x\u2212 y\u2016. (3)\nNote that using the convex decomposition of x as in Eq. (2), and the bound in Eq. (3) it follows that we can rewrite y as a convex decomposition as suggested in the lemma.\nLemma 3. Consider the iterates of Algorithm 3, when the step-sizes are chosen using Option 1. Let M1 = \u221a \u03b1 8card(x\u2217) and M2 = \u03b2D2 2 . For any t \u2265 1 it holds that\nht+1 \u2264 ht \u2212 \u03b7tM1h1/2t + \u03b72tM2.\nProof. Define \u2206t =\n\u221a 2card(x\u2217)ht \u03b1 , and note that from Eq. (1) we have that \u2206t \u2265 \u221a\ncard(x\u2217)\u2016xt \u2212 x\u2217\u2016. As a first step, we are going to show that the point yt := xt + \u2206t(v + t \u2212 v \u2212 t ) satisfies:\nyt \u00b7 \u2207f(xt) \u2264 x\u2217 \u00b7 \u2207f(xt). From Lemma 2 it follows that we can write x as a convex combination xt = \u2211k i=1 \u03bbivi and\nwrite x\u2217 as x\u2217 = \u2211k i=1(\u03bbi \u2212\u2206i)vi + \u2211k i=1 \u2206iz, where \u2206i \u2208 [0, \u03bbi], z \u2208 P, and \u2211k\ni=1 \u2206i \u2264 \u2206t. It holds that\n(yt \u2212 xt) \u00b7 \u2207f(xt) = \u2206t(v+t \u2212 v \u2212 t ) \u00b7 \u2207f(xt) \u2264 k\u2211 i=1 \u2206i(v + t \u2212 v \u2212 t ) \u00b7 \u2207f(xt)\n\u2264 k\u2211 i=1 \u2206i(z \u2212 vi) \u00b7 \u2207f(xt) = (x\u2217 \u2212 xt) \u00b7 \u2207f(xt),\nwhere the first inequality follows since (v+t \u2212v \u2212 t ) \u00b7\u2207f(xt) \u2264 0, and the second inequality follows from the optimality of v+t and v \u2212 t (Observation 1). Rearranging, we have that indeed\n( xt + \u2206t(v + t \u2212 v \u2212 t ) ) \u00b7 \u2207f(xt) \u2264 x\u2217 \u00b7 \u2207f(xt), (4)\nas needed. Observe now that from the definition of \u03b7\u0303t it follows for any t \u2265 1 that \u03b7t2 \u2264 \u03b7\u0303t \u2264 \u03b7t. Using\nthe smoothness of f(x) we have that\nht+1 = f(xt + \u03b7\u0303t(v + t \u2212 v \u2212 t ))\u2212 f(x\u2217)\n\u2264 ht + \u03b7\u0303t(v+t \u2212 v \u2212 t ) \u00b7 \u2207f(xt) +\n\u03b7\u03032t \u03b2\n2 \u2016v+t \u2212 v \u2212 t \u20162\n\u2264 ht + \u03b7\u0303t(v+t \u2212 v \u2212 t ) \u00b7 \u2207f(xt) +\n\u03b7\u03032t \u03b2D 2\n2\n\u2264 ht + \u03b7t 2 (v+t \u2212 v \u2212 t ) \u00b7 \u2207f(xt) +\n\u03b72t \u03b2D 2\n2\n= ht + \u03b7t\n2\u2206t\n( (xt + \u2206t(v + t \u2212 v \u2212 t )\u2212 xt ) \u00b7 \u2207f(xt) + \u03b7\u03032t \u03b2D 2\n2\n\u2264 ht + \u03b7t 2\u2206t (x\u2217 \u2212 xt) \u00b7 \u2207f(xt) +\n\u03b72t \u03b2D 2\n2\n\u2264 ht \u2212 \u03b7t\n2\u2206t ht +\n\u03b72t \u03b2D 2\n2\n= ht \u2212 \u03b7t \u221a \u03b1 2 \u221a 2card(x\u2217)ht ht + \u03b72t \u03b2D 2 2 ,\nwhere the third inequality follows since (v+t \u2212v \u2212 t ) \u00b7\u2207f(xt) \u2264 0, the forth inequality follows from Eq. (4), the fifth inequality follows from convexity of f(x), and the last equality follows from plugging the value of \u2206t."}, {"heading": "5.3 Proof of Theorem 1", "text": "We now turn to prove Theorem 1. Afterwards, we prove Corollary 1.\nProof. We are first going to prove the convergence rate stated in the theorem, assuming that all iterates are feasible. Then we will show that for our choice of step-sizes, indeed the iterates are feasible. We are going to prove by induction that there exist c0, c1 such that for all t \u2265 1 it holds that ht \u2264 c0(1\u2212 c1)t\u22121. Clearly for the base case we must require that c0 \u2265 h1.\nSuppose now that the induction holds for some t \u2265 1. Let us set\n\u03b7t = M1 2M2 \u221a c0(1\u2212 c1) t\u22121 2 . (5)\nUsing Lemma 3 and the induction hypothesis we have that\nht+1 \u2264 ht \u2212 M21 2M2\n\u221a c0(1\u2212 c1)t\u22121h1/2t +\nM21 4M2 c0(1\u2212 c1)t\u22121\n\u2264 ht \u2212 M21 2M2 ht + M21 4M2 c0(1\u2212 c1)t\u22121\n= ht\n( 1\u2212 M 2 1\n2M2\n) +\nM21 4M2 c0(1\u2212 c1)t\u22121\n\u2264 c0(1\u2212 c1)t\u22121 ( 1\u2212 M 2 1\n4M2\n) ,\nwhere the induction hypothesis was used in both the second and third inequalities. In the third inequality we have also used the fact that\nM21 2M2 = \u03b1 8\u03b2card(x\u2217)D2 < 1, (6)\nwhere the inequality follows since \u03b1 \u2264 \u03b2 and both card(x\u2217), D are at least 1. Thus, if we set c1 = M21 4M2\n, the induction follows. We now turn to figure out c0. Using the smoothness of f(x) and the choice of x1 in Algorithm 3, we have that\nh1 = f(x1)\u2212 f(x\u2217) = f(x0 + (x1 \u2212 x0))\u2212 f(x\u2217)\n\u2264 f(x0)\u2212 f(x\u2217) + (x1 \u2212 x0) \u00b7 \u2207f(x0) + \u03b2\u2016x0 \u2212 x1\u20162\n2\n\u2264 f(x0)\u2212 f(x\u2217) + (x\u2217 \u2212 x0) \u00b7 \u2207f(x0) + \u03b2\u2016x0 \u2212 x1\u20162 2 \u2264 \u03b2D 2 2 ,\nwhere the last inequality follows from the convexity of f(x).\nThus, we can set c0 = \u03b2D2\n2 = M2, which completes the proof of the convergence rate. Now, it remains to prove that indeed all iterates are feasible. First note that the sequence {\u03b7t}t\u22651, as defined in Eq. (5) is monotonically non-increasing. Furthermore, plugging the values M1,M2, c0, we have that\n\u03b71 = M1 \u221a c0\n2M2 =\n1\n2 \u221a M21 M2 = 1 2 \u221a \u03b1 4\u03b2D2card(x\u2217) \u2264 1,\nwhere the inequality follows similarly to the one in Eq. (6). Thus, our choice of step-size sequence {\u03b7t}t\u22651 satisfies the conditions of Lemma 1, and thus it follows that all iterates of Algorithm 3 are feasible.\nWe now prove Corollary 1.\nProof. Fix an iteration t. Using the \u03b2-smoothness of f(x) we have that\n\u2200\u03b7 \u2208 (0, 1] : f(x\u2217) \u2264 f(xt + \u03b7(v+t \u2212 xt)) \u2264 f(xt) + \u03b7(v + t \u2212 xt) \u00b7 \u2207f(xt) +\n\u03b72\u03b2D2\n2 .\nRearranging we have that\n\u2200\u03b7 \u2208 (0, 1] : gt = (xt \u2212 v+t ) \u00b7 \u2207f(xt) \u2264 1\n\u03b7 ht +\n\u03b7\u03b2D2\n2 .\nThus, when \u221a\n2ht \u03b2D2 \u2264 1, we can set \u03b7 = \u221a 2ht \u03b2D2 in the above inequality, and obtain the corollary."}, {"heading": "6 Extensions", "text": "In this section we detail two extensions of our result: i) relaxing the specific structure of the polytope P considered in Subsection 2.1, and ii) relaxing the strong convexity requirement on the objective function f(x)."}, {"heading": "6.1 Extension of Algorithm 3 to arbitrary polytopes", "text": "In this subsection we detail how to extend our approach to a broader class of polytopes. While proving rigorous guarantees for this extension is beyond the scope of this paper and left for future work, the encouraging experimental results for Algorithm 3 with line-search, suggest that this extended variant, for which line-search is also possible, may also exhibit favorable\nempirical performance. Towards this end, in this subsection we consider minimizing a smooth and strongly-convex function over an arbitrary polytope P which we assume is given in the following way:\nP = {x \u2208 Rn |A1x = b1, A2x \u2264 b2},\nwhere A2 is m\u00d7 n. We assume that given a point x \u2208 Rn, we have an efficient way to evaluate the vector A2x, which is indeed the case for most structured polytopes of interest.\nAlgorithm 4 Decomposition-invariant Pairwise Conditional Gradient with Line-search for Arbitrary Polytopes\n1: let x0 be an arbitrary point in P 2: x1 \u2190 arg minv\u2208V v \u00b7 \u2207f(x0) 3: for t = 1... do 4: v+t \u2190 arg minv\u2208V v \u00b7 \u2207f(xt) 5: define the vector c \u2208 Rm as follows:\nci := { 0 if A2(i) \u00b7 xt < b2(i) \u221e if A2(i) \u00b7 xt = b2(i)\n6: v\u2212t \u2190 arg minv\u2208V (\u2212\u2207f(xt)) \u00b7 v + c>A2v 7: \u03b3t \u2190 max{\u03b3 \u2208 [0, 1] |A2(xt + \u03b3(v+t \u2212 v \u2212 t )) \u2264 b2} 8: \u03b7t \u2190 arg min\u03b7\u2208[0,\u03b3t] f(xt + \u03b7(v + t \u2212 v \u2212 t )) 9: xt+1 \u2190 xt + \u03b7t(v+t \u2212 v \u2212 t )\n10: end for\nObservation 3 (optimal away-step for an arbitrary polytope). Consider an iteration t of Algorithm 4 and suppose that the iterate xt is feasible. Let xt = \u2211k i=1 \u03bbivi for some integer k, be a irreducible way of writing xt as a convex sum of vertices of P, i.e., \u03bbi > 0 for all i \u2208 [k]. Then it holds that\n\u2200i \u2208 [k] : vi \u00b7 \u2207f(xt) \u2264 v\u2212t \u00b7 \u2207f(xt), \u03b3t > 0.\nMoreover, there exists a convex decomposition of xt that assigns a weight at least \u03b3t to v \u2212 t .\nProof. Let xt = \u2211k\ni=1 \u03bbivi be a decomposition of xt into vertices of P such that \u03bbi > 0 for all i \u2208 [k]. Observe that for any j \u2208 [m] and i \u2208 [k] it holds that A2(j) \u00b7 xt = b2(j)\u21d2 A2(j) \u00b7 vi = b2(j). Note that by definition of the vector c and v \u2212 t it holds that\nv\u2212t \u2208 arg max v\u2208V \u2207f(xt) \u00b7 v \u2212 c>A2v \u2261 arg max v\u2208V \u2207f(xt) \u00b7 v + c>(b2 \u2212A2v)\n\u2261 arg maxv\u2208{y\u2208V | \u2200j\u2208[m]:A2(j)\u00b7xt=b2(j)\u21d2A2(j)\u00b7y=b2(j)}v \u00b7 \u2207f(xt). (7)\nThus, it follows that for all i \u2208 [k], v\u2212t \u00b7 \u2207f(xt) \u2265 vi \u00b7 \u2207f(xt). In order to prove the second part of the observation, we note that from the RHS of Eq. (7) it follows that there exists \u03b3t > 0 such that indeed xt\u2212\u03b3tv\u2212t \u2264 (1\u2212\u03b3t)b2. To see this, consider some j \u2208 [m]. If A2(j) \u00b7 xt = b2(j), then from the RHS of Eq. (7), it follows that A2(j) \u00b7 v\u2212t = b2(j) and thus, for any \u03b3t it holds that A2(j) \u00b7(xt\u2212\u03b3tv\u2212t ) = (1\u2212\u03b3t)b2(j). Otherwise, there exists some j > 0 such that A2(j) \u00b7v\u2212t \u2264 b2(j)\u2212 j . Thus, for small enough, yet positive \u03b3t we will have that A2(j) \u00b7 (xt \u2212 \u03b3tv\u2212t ) \u2264 (1\u2212 \u03b3t)b2(j). Since it clearly also holds that A1(xt \u2212 \u03b3tv \u2212 t ) = (1\u2212 \u03b3t)b1, we have that the vector wt := xt\u2212\u03b3tv\u2212t satisfies: wt \u2208 (1\u2212\u03b3t)P. Hence, wt can be decomposed\nas wt = \u2211q\ni=1 \u03b3\u0303iv\u0303i, where q is a positive integer and for all i \u2208 [q], \u03bb\u0303i > 0, v\u0303i is a vertex of P, and \u2211q i=1 \u03bb\u0303i = 1 \u2212 \u03b3t. Thus, since v \u2212 t is a vertex of P, it follows that xt = wt + \u03b3tv \u2212 t admits\nthe convex decomposition \u2211q\ni=1 \u03bb\u0303iv\u0303i + \u03b3tv \u2212 t , as needed.\nThe following lemma is an immediate consequence of the choice of \u03b3t in Algorithm 4.\nLemma 4. The iterates of Algorithm 4 are always feasible."}, {"heading": "6.2 Relaxing the strong convexity of the objective function", "text": "Until now we have assumed that the objective function f is strongly convex. However, as can be observed from our analysis, the only consequence of strong convexity that we relied on in our analysis, is Eq. (1). Indeed, there exist functions which are not strongly convex, that under certain conditions, still satisfy Eq. (1), and thus are compatible with our method and analysis.\nFollowing the work of Beck and Shtern [2], we can consider a broader class of objective functions, namely functions that take the following form:\nf(x) = g(Ax) + b \u00b7 x, (8)\nwhere A \u2208 Rm\u00d7n, and g : Rm \u2192 R is smooth and strongly convex. In [2] (Lemma 2.5) it was shown, using an application of Hoffman\u2019s lemma, that there exists a constant \u03ba which depends both on the condition number of g and the parameters A, b, such that for any feasible point x, it holds that\nmin y\u2208P\u2217\n\u2016x\u2212 y\u20162 \u2264 \u03ba (f(x)\u2212 f\u2217) , (9)\nwhere P\u2217 \u2282 P, is the set of all feasible points that minimize f(x) over P, and f\u2217 is the minimum value of f(x) over P.\nIt is easy to verify that Eq. (9) can be readily used in our analysis instead of Eq. (1), and thus our results extend to handle objectives of the form given in Eq. (8).\nWe note that now, the dependency in our analysis and in Theorem 1 on the strong convexity parameter \u03b1 will be replaced with \u03ba, and the dependency on card(x\u2217) will be replaced with maxy\u2208P\u2217 card(y)."}, {"heading": "7 Lower Bound for Problems with a Sparse Solution", "text": "In this section we present a simple lower bound on the approximation error of, informally speaking, any natural conditional gradient variant that when initialized with a vertex of the feasible set, its iterate after t iterations admits a convex decomposition into at most t + 1 vertices of the polytope. That is, on each iteration, at most a single new vertex is added to the decomposition. The lower bound shows that there exists a 1-smooth and 1-strongly convex function f , for which, any such CG variant which is applied to the minimization of f over the unit simplex, must take \u2126(card(x\u2217)) steps before entering the linear convergence regime. To date, none of the previous analyses of linearly converging CG variants matches this lower bound since, in this exact setting, they all require, in worst-case, \u2126(n) steps before entering the linear convergence regime, i.e., number of steps that is independent of card(x\u2217).\nTo the best of our knowledge, Algorithm 3 and the corresponding Theorem 1 are the first to match this lower bound. We emphasize that the idea behind the construction of this lower bound is well known and follows almost immediately from previous constructions, such as those in [12, 6].\nLemma 5. Fix an even integer k \u2208 [n], and consider the optimization problem\nmin x\u2208Sn {f(x) := 1 2 \u2016x\u2212 1 k 1k\u20162},\nwhere Sn denotes the unit simplex in Rn, i.e., Sn := {x \u2208 Rn |x \u2265 0, \u2016x\u20161 = 1}, and 1k is a vector in Rn, defined as:\n1k(i) = { 1 if 1 \u2264 i \u2264 k 0 else\nObserve that x\u2217 = 1k1k is the unique minimizer of f over Sn. Then, any point x \u2208 Sn, for which it holds that card(x) \u2264 k/2 satisfies:\nf(x)\u2212 f(x\u2217) \u2265 1 4k .\nProof. Fix a point x \u2208 Sn for which it holds that card(x) \u2264 k/2. In order to lower bound the approximation error of x, it suffices to consider the entries which are zero for x and non-zero for x\u2217. Thus, we have that\nf(x) \u2265 1 2 \u00b7 k 2 \u00b7 ( 0\u2212 1 k )2 = 1 4k ."}, {"heading": "8 Experiments", "text": "In this section we illustrate the performance of our algorithm in numerical experiments. We use the two experimental settings from [16], which include a constrained Lasso problem and a video co-localization problem. In addition, we test our algorithm on a learning problem related to an optical character recognition (OCR) task from [24]. In each setting we compare the performance of our algorithm (DICG) to standard conditional gradient (CG), as well as to the fast away (ACG) and pairwise (PCG) variants [16]. For the baselines in the first two settings we use the publicly available code from [16], to which we add our own implementation of Algorithm 3. Similarly, for the OCR problem we extend code from [21], kindly provided by the authors. For all algorithms we use line-search to set the step size.\nLasso In the first example the goal is to solve the problem: minx\u2208M \u2016A\u0304x \u2212 b\u0304\u20162, where M is a scaled `1 ball. Notice that the constraints M do not match the required structure of P, however, with a simple change of variables we can obtain an equivalent optimization problem over the simplex. We generate the random matrix A\u0304 and vector b\u0304 as in [16]. In Figure 1 (left, top) we observe that our algorithm (DICG) converges similarly to the pairwise variant PCG and faster than the other baselines. This is expected since the away direction v\u2212 in DICG (Algorithm 3) is equivalent to the away direction in PCG (Algorithm 2) in the case of simplex constraints.\nVideo co-localization The second example is a quadratic program over the flow polytope, originally proposed in [14]. This is an instance of P that is mentioned in Section 4 in the appendix. As can be seen in Figure 1 (middle, top), in this setting our proposed algorithm significantly outperforms the baselines, as a result of finding a better away direction v\u2212. Figure 1\n(middle, bottom) shows convergence on a time scale, where the difference between the algorithms is even larger. One reason for this difference is the costly search over the history of vertices maintained by the baseline algorithms. Specifically, the number of stored vertices grows fast with the number of iterations and reaches 1222 for away steps and 1438 for pairwise steps (out of 2000 iterations).\nOCR We next conduct experiments on a structured SVM learning problem resulting from an OCR task. The constraints in this setting are the marginal polytope corresponding to a chain graph over the letters of a word (see [24]), and the objective function is quadratic. Notice that the marginal polytope has a concise characterization in this case and also satisfies our assumptions (see Section 4 in the appendix for more details). For this problem we actually run Algorithm 3 in a block-coordinate fashion, where blocks correspond to training examples in the dual SVM formulation [17, 21]. In Figure 1 (right, top) we see that our DICG algorithm is comparable to the PCG algorithm and faster than the other baselines on the iteration scale. Figure 1 (right, bottom) demonstrates that in terms of actual running time we get a noticeable speedup compared to all baselines. We point out that for this OCR problem, both ACG and PCG each require about 5GB of memory to store the explicit decomposition in the implementation that we used, so using DICG instead results in significant memory savings."}], "references": [{"title": "Linear convergence of a modified frank-wolfe algorithm for computing minimum-volume enclosing ellipsoids", "author": ["S. Damla Ahipasaoglu", "Peng Sun", "Michael J. Todd"], "venue": "Optimization Methods and Software,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "Linearly convergent away-step conditional gradient for non-strongly convex functions", "author": ["Amir Beck", "Shimrit Shtern"], "venue": "arXiv preprint arXiv:1504.05002,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2015}, {"title": "A conditional gradient method with linear rate of convergence for solving convex linear systems", "author": ["Amir Beck", "Marc Teboulle"], "venue": "Math. Meth. of OR,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2004}, {"title": "Lifted coordinate descent for learning with trace-norm regularization", "author": ["Miroslav Dud\u0301\u0131k", "Z\u00e4\u0131d Harchaoui", "J\u00e9r\u00f4me Malick"], "venue": "Journal of Machine Learning Research - Proceedings Track,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2012}, {"title": "An algorithm for quadratic programming", "author": ["M. Frank", "P. Wolfe"], "venue": "Naval Research Logistics Quarterly,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 1956}, {"title": "A linearly convergent conditional gradient algorithm with applications to online and stochastic optimization", "author": ["Dan Garber", "Elad Hazan"], "venue": "CoRR, abs/1301.4666,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2013}, {"title": "Faster rates for the frank-wolfe method over strongly-convex sets", "author": ["Dan Garber", "Elad Hazan"], "venue": "In Proceedings of the 32nd International Conference on Machine Learning, ICML 2015,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2015}, {"title": "Some comments on Wolfe\u2019s \u2018away step", "author": ["Jacques Gu\u00e9Lat", "Patrice Marcotte"], "venue": "Mathematical Programming,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1986}, {"title": "Large-scale image classification with trace-norm regularization", "author": ["Z\u00e4\u0131d Harchaoui", "Matthijs Douze", "Mattis Paulin", "Miroslav Dud\u0301\u0131k", "J\u00e9r\u00f4me Malick"], "venue": "In IEEE Conference on Computer Vision and Pattern Recognition,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "Projection-free online learning", "author": ["Elad Hazan", "Satyen Kale"], "venue": "In Proceedings of the 29th International Conference on Machine Learning,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Variance-reduced and projection-free stochastic optimization", "author": ["Elad Hazan", "Haipeng Luo"], "venue": "CoRR, abs/1602.02101,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2016}, {"title": "Revisiting frank-wolfe: Projection-free sparse convex optimization", "author": ["Martin Jaggi"], "venue": "In Proceedings of the 30th International Conference on Machine Learning,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "Sulovsk\u00fd. A simple algorithm for nuclear norm regularized problems", "author": ["Martin Jaggi", "Marek"], "venue": "In Proceedings of the 27th International Conference on Machine Learning,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "Efficient image and video co-localization with Frank-Wolfe algorithm", "author": ["Armand Joulin", "Kevin Tang", "Li Fei-Fei"], "venue": "In Computer Vision\u2013ECCV", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "An affine invariant linear convergence analysis for frank-wolfe algorithms", "author": ["Simon Lacoste-Julien", "Martin Jaggi"], "venue": "CoRR, abs/1312.7864,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2013}, {"title": "On the global linear convergence of Frank-Wolfe optimization variants", "author": ["Simon Lacoste-Julien", "Martin Jaggi"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2015}, {"title": "Blockcoordinate frank-wolfe optimization for structural svms", "author": ["Simon Lacoste-Julien", "Martin Jaggi", "Mark W. Schmidt", "Patrick Pletscher"], "venue": "In Proceedings of the 30th International Conference on Machine Learning,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2013}, {"title": "The complexity of large-scale convex programming under a linear optimization oracle", "author": ["Guanghui Lan"], "venue": "CoRR, abs/1309.5550,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2013}, {"title": "A hybrid algorithm for convex semidefinite optimization", "author": ["S\u00f6ren Laue"], "venue": "In Proceedings of the 29th International Conference on Machine Learning,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2012}, {"title": "Constrained minimization methods", "author": ["Evgeny S Levitin", "Boris T Polyak"], "venue": "USSR Computational mathematics and mathematical physics,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1966}, {"title": "Minding the gaps for block frank-wolfe optimization of structured svm", "author": ["Anton Osokin", "Jean-Baptiste Alayrac", "Puneet K. Dokania", "Simon Lacoste-Julien"], "venue": "In International Conference on Machine Learning (ICML),", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2016}, {"title": "Combinatorial Optimization - Polyhedra and Efficiency", "author": ["A. Schrijver"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2003}, {"title": "Large-scale convex minimization with a low-rank constraint", "author": ["Shai Shalev-Shwartz", "Alon Gonen", "Ohad Shamir"], "venue": "In Proceedings of the 28th International Conference on Machine Learning,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2011}, {"title": "Max-margin Markov networks", "author": ["B. Taskar", "C. Guestrin", "D. Koller"], "venue": "In Advances in Neural Information Processing Systems. MIT Press,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2003}, {"title": "Graphical Models, Exponential Families, and Variational Inference", "author": ["M. Wainwright", "M.I. Jordan"], "venue": "Now Publishers Inc.,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2008}, {"title": "Distance metric learning with eigenvalue optimization", "author": ["Yiming Ying", "Peng Li"], "venue": "J. Mach. Learn. Res.,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2012}], "referenceMentions": [{"referenceID": 21, "context": "Prime examples for this phenomenon include various structured polytopes that arise in combinatorial optimization, such as the path polytope of a graph (aka the unit flow polytope), the perfect matching polytope of a bipartite graph, and the base polyhedron of a matroid, for which we have highly efficient combinatorial algorithms for linear minimization that rely heavily on the specific rich structure of the polytope [22].", "startOffset": 420, "endOffset": 424}, {"referenceID": 12, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 16, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 3, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 8, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 9, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 22, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 18, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 25, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 10, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 13, "context": "It has been recently shown that the method delivers state-of-the-art performance on many problems of interest, see for instance [13, 17, 4, 9, 10, 23, 19, 26, 11, 14].", "startOffset": 128, "endOffset": 166}, {"referenceID": 4, "context": "It is known, already from the first introduction of the method by Frank and Wolfe in the 1950\u2019s [5], and the somewhat later work of Polyak and Levitin [20], that the method converges with a rate of roughly O(1/t) for minimizing a smooth convex function over a convex and compact set, which matches the rate of the standard projected gradient method for the same setting.", "startOffset": 96, "endOffset": 99}, {"referenceID": 19, "context": "It is known, already from the first introduction of the method by Frank and Wolfe in the 1950\u2019s [5], and the somewhat later work of Polyak and Levitin [20], that the method converges with a rate of roughly O(1/t) for minimizing a smooth convex function over a convex and compact set, which matches the rate of the standard projected gradient method for the same setting.", "startOffset": 151, "endOffset": 155}, {"referenceID": 17, "context": "In fact, certain lower bounds, such as in [18, 6], suggest that such improvement, even if possible, should come with a worse dependence on the problem\u2019s parameters (e.", "startOffset": 42, "endOffset": 49}, {"referenceID": 5, "context": "In fact, certain lower bounds, such as in [18, 6], suggest that such improvement, even if possible, should come with a worse dependence on the problem\u2019s parameters (e.", "startOffset": 42, "endOffset": 49}, {"referenceID": 7, "context": "For instance, Gu\u00e9Lat and Marcotte [8] showed that a CG variant which uses the concept of away-steps converges exponentially fast in case the objective function is strongly convex, the feasible set is a polytope, and the optimal solution is located in the interior of the set.", "startOffset": 34, "endOffset": 37}, {"referenceID": 2, "context": "A similar result was presented by Beck and Teboulle [3] who considered a specific problem they refer to a the convex feasibility problem over an arbitrary convex set.", "startOffset": 52, "endOffset": 55}, {"referenceID": 0, "context": "Later, Ahipasaoglu, Sun and Todd [1] showed that in the specific case of minimizing a smooth and strongly convex function over the unit simplex, a variant of the CG method which also uses away-steps, converges with a linear rate.", "startOffset": 33, "endOffset": 36}, {"referenceID": 5, "context": "The exponent in their convergence rate depends on various geometric parameters of the polytope [6].", "startOffset": 95, "endOffset": 98}, {"referenceID": 14, "context": "In a follow-up work, Lacoste-Julien and Jaggi [15, 16] gave a refined affine-invariant analysis of an algorithm presented in [8] which also uses away steps, and showed that it also converges exponentially fast in the same setting as the Garber-Hazan", "startOffset": 46, "endOffset": 54}, {"referenceID": 15, "context": "In a follow-up work, Lacoste-Julien and Jaggi [15, 16] gave a refined affine-invariant analysis of an algorithm presented in [8] which also uses away steps, and showed that it also converges exponentially fast in the same setting as the Garber-Hazan", "startOffset": 46, "endOffset": 54}, {"referenceID": 7, "context": "In a follow-up work, Lacoste-Julien and Jaggi [15, 16] gave a refined affine-invariant analysis of an algorithm presented in [8] which also uses away steps, and showed that it also converges exponentially fast in the same setting as the Garber-Hazan", "startOffset": 125, "endOffset": 128}, {"referenceID": 1, "context": "In a later work, Beck and Shtern [2] gave a different, duality-based, analysis for the algorithm of [8], and showed that it can be applied to a wider class of functions than purely strongly convex functions.", "startOffset": 33, "endOffset": 36}, {"referenceID": 7, "context": "In a later work, Beck and Shtern [2] gave a different, duality-based, analysis for the algorithm of [8], and showed that it can be applied to a wider class of functions than purely strongly convex functions.", "startOffset": 100, "endOffset": 103}, {"referenceID": 5, "context": "However, the explicit dependency of their convergence rate on the dimension is suboptimal, compared to [6, 16].", "startOffset": 103, "endOffset": 110}, {"referenceID": 15, "context": "However, the explicit dependency of their convergence rate on the dimension is suboptimal, compared to [6, 16].", "startOffset": 103, "endOffset": 110}, {"referenceID": 6, "context": "Aside from the polytope case, Garber and Hazan have shown recently that in case the feasible set is strongly-convex and the objective function satisfies certain strong convexity-like proprieties, then the standard CG method converges with an accelerated rate of O(1/t2) [7].", "startOffset": 270, "endOffset": 273}, {"referenceID": 1, "context": "Maintaining such a decomposition and computing the away-steps, even with efficient implementations of incremental decomposition procedures, such as suggested in [2], require both memory and per-iteration runtime overheads that are at least quadratic in the dimension.", "startOffset": 161, "endOffset": 164}, {"referenceID": 5, "context": ", when the optimal solution is, informally speaking, dense (see for instance the lower bound in [6]), it is not clear that such an unfavorable dependence is mandatory when the optimum is sparse.", "startOffset": 96, "endOffset": 99}, {"referenceID": 4, "context": "#LOO calls runtime memory Frank & Wolfe [5] \u03b2D 2 1 n n Garber & Hazan [6] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Lacoste-Julien & Jaggi [16] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Beck & Shtern [2] n 2\u03b2D2 \u03b1 log(1/ ) 1 n 2 n2 This paper card(x \u2217)\u03b2D2 \u03b1 log(1/ ) 2 n n", "startOffset": 40, "endOffset": 43}, {"referenceID": 5, "context": "#LOO calls runtime memory Frank & Wolfe [5] \u03b2D 2 1 n n Garber & Hazan [6] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Lacoste-Julien & Jaggi [16] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Beck & Shtern [2] n 2\u03b2D2 \u03b1 log(1/ ) 1 n 2 n2 This paper card(x \u2217)\u03b2D2 \u03b1 log(1/ ) 2 n n", "startOffset": 70, "endOffset": 73}, {"referenceID": 15, "context": "#LOO calls runtime memory Frank & Wolfe [5] \u03b2D 2 1 n n Garber & Hazan [6] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Lacoste-Julien & Jaggi [16] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Beck & Shtern [2] n 2\u03b2D2 \u03b1 log(1/ ) 1 n 2 n2 This paper card(x \u2217)\u03b2D2 \u03b1 log(1/ ) 2 n n", "startOffset": 123, "endOffset": 127}, {"referenceID": 1, "context": "#LOO calls runtime memory Frank & Wolfe [5] \u03b2D 2 1 n n Garber & Hazan [6] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Lacoste-Julien & Jaggi [16] n\u03b2D 2 \u03b1 log(1/ ) 1 n 2 n2 Beck & Shtern [2] n 2\u03b2D2 \u03b1 log(1/ ) 1 n 2 n2 This paper card(x \u2217)\u03b2D2 \u03b1 log(1/ ) 2 n n", "startOffset": 168, "endOffset": 171}, {"referenceID": 5, "context": "To get lower complexity and memory requirements for the algorithms in [6, 16, 2], we assume they all employ an algorithmic version of Carathodory\u2019s theorem to maintain a convex decomposition of the iterate to at most n + 1 vertices, as fully detailed in [2].", "startOffset": 70, "endOffset": 80}, {"referenceID": 15, "context": "To get lower complexity and memory requirements for the algorithms in [6, 16, 2], we assume they all employ an algorithmic version of Carathodory\u2019s theorem to maintain a convex decomposition of the iterate to at most n + 1 vertices, as fully detailed in [2].", "startOffset": 70, "endOffset": 80}, {"referenceID": 1, "context": "To get lower complexity and memory requirements for the algorithms in [6, 16, 2], we assume they all employ an algorithmic version of Carathodory\u2019s theorem to maintain a convex decomposition of the iterate to at most n + 1 vertices, as fully detailed in [2].", "startOffset": 70, "endOffset": 80}, {"referenceID": 1, "context": "To get lower complexity and memory requirements for the algorithms in [6, 16, 2], we assume they all employ an algorithmic version of Carathodory\u2019s theorem to maintain a convex decomposition of the iterate to at most n + 1 vertices, as fully detailed in [2].", "startOffset": 254, "endOffset": 257}, {"referenceID": 15, "context": "We note that the bound on number of iterations in the analysis of [16] does not depend explicitly on the dimension n, but on the squared inverse pyramidal width of P, which is difficult to evaluate.", "startOffset": 66, "endOffset": 70}, {"referenceID": 11, "context": ", [12, 14, 16]).", "startOffset": 2, "endOffset": 14}, {"referenceID": 13, "context": ", [12, 14, 16]).", "startOffset": 2, "endOffset": 14}, {"referenceID": 15, "context": ", [12, 14, 16]).", "startOffset": 2, "endOffset": 14}, {"referenceID": 5, "context": "Importantly, the above assumptions allow us to get rid of the dependency of the convergence rate on certain geometric parameters (such as \u03c8, \u03be in [6] or the pyramidal width in [15, 16]), which can be polynomial in the dimension, and hence result in an impractical convergence rate.", "startOffset": 146, "endOffset": 149}, {"referenceID": 14, "context": "Importantly, the above assumptions allow us to get rid of the dependency of the convergence rate on certain geometric parameters (such as \u03c8, \u03be in [6] or the pyramidal width in [15, 16]), which can be polynomial in the dimension, and hence result in an impractical convergence rate.", "startOffset": 176, "endOffset": 184}, {"referenceID": 15, "context": "Importantly, the above assumptions allow us to get rid of the dependency of the convergence rate on certain geometric parameters (such as \u03c8, \u03be in [6] or the pyramidal width in [15, 16]), which can be polynomial in the dimension, and hence result in an impractical convergence rate.", "startOffset": 176, "endOffset": 184}, {"referenceID": 11, "context": "It is well known that when setting the step-size \u03b7t in an appropriate way, the worst case convergence rate of the method is O(\u03b2D2/t) [12].", "startOffset": 133, "endOffset": 137}, {"referenceID": 17, "context": "This convergence rate is tight for the method in general, see for instance [18].", "startOffset": 75, "endOffset": 79}, {"referenceID": 5, "context": "This key principle proves to be crucial to breaking the 1/t rate of the standard method, and to achieve a linear convergence rate under certain strong-convexity assumptions, as described in the recent works [6, 16, 2].", "startOffset": 207, "endOffset": 217}, {"referenceID": 15, "context": "This key principle proves to be crucial to breaking the 1/t rate of the standard method, and to achieve a linear convergence rate under certain strong-convexity assumptions, as described in the recent works [6, 16, 2].", "startOffset": 207, "endOffset": 217}, {"referenceID": 1, "context": "This key principle proves to be crucial to breaking the 1/t rate of the standard method, and to achieve a linear convergence rate under certain strong-convexity assumptions, as described in the recent works [6, 16, 2].", "startOffset": 207, "endOffset": 217}, {"referenceID": 5, "context": "For instance, in [6] it was shown, via the introduction of the concept of a Local Linear Optimization Oracle, that using such a non-uniform reweighing rule, in fact approximates a certain proximal problem, that together with the shrinking effect of strong convexity, as captured by Eq.", "startOffset": 17, "endOffset": 20}, {"referenceID": 15, "context": "As a concrete example, which will also serve as a basis for our new method, we bring the pairwise variant recently studied in [16], which applies this principle in Algorithm 2, given below 1.", "startOffset": 126, "endOffset": 130}, {"referenceID": 5, "context": "While the away-step-based variants increase the size of the decomposition by at most a single vertex per iteration, they also typically exhibit linear convergence after performing at least O(n) steps [6, 16, 2], and thus, this O(n2) estimate still holds.", "startOffset": 200, "endOffset": 210}, {"referenceID": 15, "context": "While the away-step-based variants increase the size of the decomposition by at most a single vertex per iteration, they also typically exhibit linear convergence after performing at least O(n) steps [6, 16, 2], and thus, this O(n2) estimate still holds.", "startOffset": 200, "endOffset": 210}, {"referenceID": 1, "context": "While the away-step-based variants increase the size of the decomposition by at most a single vertex per iteration, they also typically exhibit linear convergence after performing at least O(n) steps [6, 16, 2], and thus, this O(n2) estimate still holds.", "startOffset": 200, "endOffset": 210}, {"referenceID": 1, "context": "Moreover, since these methods require i) to find the worse vertex in the decomposition, in terms of dot-product with current gradient direction, and ii) to update this decomposition on each iteration (even when using sophisticated update techniques such as in [2]), the per-iteration over-head in terms of computation time of these methods is also at least O(n2).", "startOffset": 260, "endOffset": 263}, {"referenceID": 15, "context": "As observable in Table 1, for certain problems in which the optimal solution is sparse, all analyses of previous away-steps-based variants are significantly suboptimal, since they all depend explicitly on the dimension, which seems to While the convergence rate of this pairwise variant, established in [16], despite being linear, is significantly worse than other away-step-based variants, here we show on the contrary, that a proper analysis yields state-ofthe-art performance guarantees.", "startOffset": 303, "endOffset": 307}, {"referenceID": 0, "context": "Option 2: line-search \u03b3t \u2190 max\u03b3\u2208[0,1]{xt + \u03b3(v t \u2212 v \u2212 t ) \u2265 0}, \u03b7\u0303t \u2190 min\u03b7\u2208(0,\u03b3t] f(xt + \u03b7(v + t \u2212 v \u2212 t ))", "startOffset": 32, "endOffset": 37}, {"referenceID": 5, "context": "This is much more efficient than previous linearly convergent CG variant, such as those in [6, 16, 2], which typically require at least additional O(n2) time and space per iteration, since they require to maintain an explicit convex decomposition of the iterates.", "startOffset": 91, "endOffset": 101}, {"referenceID": 15, "context": "This is much more efficient than previous linearly convergent CG variant, such as those in [6, 16, 2], which typically require at least additional O(n2) time and space per iteration, since they require to maintain an explicit convex decomposition of the iterates.", "startOffset": 91, "endOffset": 101}, {"referenceID": 1, "context": "This is much more efficient than previous linearly convergent CG variant, such as those in [6, 16, 2], which typically require at least additional O(n2) time and space per iteration, since they require to maintain an explicit convex decomposition of the iterates.", "startOffset": 91, "endOffset": 101}, {"referenceID": 15, "context": "\u2022 Theorem 1 improves significantly over the convergence rate established for the pairwise conditional gradient variant in [16].", "startOffset": 122, "endOffset": 126}, {"referenceID": 15, "context": "In particular, the number of iterations to reach an error in the analysis of [16] depends linearly on |V|!, where |V| is the number of vertices of P.", "startOffset": 77, "endOffset": 81}, {"referenceID": 21, "context": "Since the graph G is a DAG, this could be carried out in O(m) time [22].", "startOffset": 67, "endOffset": 71}, {"referenceID": 21, "context": "This could be carried out via combinatorial algorithms in min{\u00d5( \u221a nm), O(n3)} time [22].", "startOffset": 84, "endOffset": 88}, {"referenceID": 24, "context": "There exists a set of linear constraints, known as the marginal polytope, which guarantees that these variables are legal marginals of some global distribution [25].", "startOffset": 160, "endOffset": 164}, {"referenceID": 23, "context": "For example, the learning problem in Max-Margin Markov Networks is defined as a quadratic program over the marginal polytope [24].", "startOffset": 125, "endOffset": 129}, {"referenceID": 24, "context": "Fortunately, for some models, such as tree-structured graphs, the polytope can be characterized by a polynomial number of local consistency constraints, known as the local marginal polytope [25].", "startOffset": 190, "endOffset": 194}, {"referenceID": 24, "context": "For tree-structured graphsML is known to have only integral vertices [25], so it has the desired form assumed in Section 2.", "startOffset": 69, "endOffset": 73}, {"referenceID": 0, "context": "Suppose that the sequence of step-sizes {\u03b7t}t\u22651 is monotonically non-increasing, and contained in the interval [0, 1].", "startOffset": 111, "endOffset": 117}, {"referenceID": 5, "context": "from [6], it follows that we can write x as", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "ci := { 0 if A2(i) \u00b7 xt < b2(i) \u221e if A2(i) \u00b7 xt = b2(i) 6: v\u2212 t \u2190 arg minv\u2208V (\u2212\u2207f(xt)) \u00b7 v + cA2v 7: \u03b3t \u2190 max{\u03b3 \u2208 [0, 1] |A2(xt + \u03b3(v t \u2212 v \u2212 t )) \u2264 b2} 8: \u03b7t \u2190 arg min\u03b7\u2208[0,\u03b3t] f(xt + \u03b7(v + t \u2212 v \u2212 t )) 9: xt+1 \u2190 xt + \u03b7t(v t \u2212 v \u2212 t ) 10: end for", "startOffset": 114, "endOffset": 120}, {"referenceID": 1, "context": "Following the work of Beck and Shtern [2], we can consider a broader class of objective functions, namely functions that take the following form:", "startOffset": 38, "endOffset": 41}, {"referenceID": 1, "context": "In [2] (Lemma 2.", "startOffset": 3, "endOffset": 6}, {"referenceID": 11, "context": "We emphasize that the idea behind the construction of this lower bound is well known and follows almost immediately from previous constructions, such as those in [12, 6].", "startOffset": 162, "endOffset": 169}, {"referenceID": 5, "context": "We emphasize that the idea behind the construction of this lower bound is well known and follows almost immediately from previous constructions, such as those in [12, 6].", "startOffset": 162, "endOffset": 169}, {"referenceID": 15, "context": "We use the two experimental settings from [16], which include a constrained Lasso problem and a video co-localization problem.", "startOffset": 42, "endOffset": 46}, {"referenceID": 23, "context": "In addition, we test our algorithm on a learning problem related to an optical character recognition (OCR) task from [24].", "startOffset": 117, "endOffset": 121}, {"referenceID": 15, "context": "In each setting we compare the performance of our algorithm (DICG) to standard conditional gradient (CG), as well as to the fast away (ACG) and pairwise (PCG) variants [16].", "startOffset": 168, "endOffset": 172}, {"referenceID": 15, "context": "For the baselines in the first two settings we use the publicly available code from [16], to which we add our own implementation of Algorithm 3.", "startOffset": 84, "endOffset": 88}, {"referenceID": 20, "context": "Similarly, for the OCR problem we extend code from [21], kindly provided by the authors.", "startOffset": 51, "endOffset": 55}, {"referenceID": 15, "context": "We generate the random matrix \u0100 and vector b\u0304 as in [16].", "startOffset": 52, "endOffset": 56}, {"referenceID": 13, "context": "Video co-localization The second example is a quadratic program over the flow polytope, originally proposed in [14].", "startOffset": 111, "endOffset": 115}, {"referenceID": 23, "context": "The constraints in this setting are the marginal polytope corresponding to a chain graph over the letters of a word (see [24]), and the objective function is quadratic.", "startOffset": 121, "endOffset": 125}, {"referenceID": 16, "context": "For this problem we actually run Algorithm 3 in a block-coordinate fashion, where blocks correspond to training examples in the dual SVM formulation [17, 21].", "startOffset": 149, "endOffset": 157}, {"referenceID": 20, "context": "For this problem we actually run Algorithm 3 in a block-coordinate fashion, where blocks correspond to training examples in the dual SVM formulation [17, 21].", "startOffset": 149, "endOffset": 157}], "year": 2016, "abstractText": "Recently, several works have shown that natural modifications of the classical conditional gradient method (aka Frank-Wolfe algorithm) for constrained convex optimization, provably converge with a linear rate when: i) the feasible set is a polytope, and ii) the objective is smooth and strongly-convex. However, all of these results suffer from two significant shortcomings: 1. large memory requirement due to the need to store an explicit convex decomposition of the current iterate, and as a consequence, large running-time overhead per iteration 2. the worst case convergence rate depends unfavorably on the dimension In this work we present a new conditional gradient variant and a corresponding analysis that improves on both of the above shortcomings. In particular: 1. both memory and computation overheads are only linear in the dimension 2. in case the optimal solution is sparse, the new convergence rate replaces a factor which is at least linear in the dimension in previous works, with a linear dependence on the number of non-zeros in the optimal solution At the heart of our method, and corresponding analysis, is a novel way to compute decomposition-invariant away-steps. While our theoretical guarantees do not apply to any polytope, they apply to several important structured polytopes that capture central concepts such as paths in graphs, perfect matchings in bipartite graphs, marginal distributions that arise in structured prediction tasks, and more. Our theoretical findings are complemented by empirical evidence which shows that our method delivers state-of-the-art performance.", "creator": "LaTeX with hyperref package"}}}