{"id": "1606.08954", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "29-Jun-2016", "title": "Greedy, Joint Syntactic-Semantic Parsing with Stack LSTMs", "abstract": "we present a layered transition - based parser set that jointly, produces syntactic and semantic marker dependencies. it learns a representation of the respective entire recall algorithm turing state, using stack on long spaced short - processor term memories. additionally our greedy inference algorithm has linear time, including temporal feature variance extraction. running on the upcoming conll edition 2008 - - present 9 english shared naming tasks, we obtain the 26th best algorithm published parsing procedure performance among models that ultimately jointly learn adaptive syntax and semantics.", "histories": [["v1", "Wed, 29 Jun 2016 05:01:56 GMT  (188kb,D)", "http://arxiv.org/abs/1606.08954v1", "13 pages, 5 figures, accepted to CoNLL 2016"]], "COMMENTS": "13 pages, 5 figures, accepted to CoNLL 2016", "reviews": [], "SUBJECTS": "cs.CL cs.AI", "authors": ["swabha swayamdipta", "miguel ballesteros", "chris dyer", "noah a smith"], "accepted": false, "id": "1606.08954"}, "pdf": {"name": "1606.08954.pdf", "metadata": {"source": "CRF", "title": "Greedy, Joint Syntactic-Semantic Parsing with Stack LSTMs", "authors": ["Swabha Swayamdipta", "Miguel Ballesteros", "Chris Dyer", "Noah A. Smith"], "emails": ["swabha@cs.cmu.edu,", "miguel.ballesteros@upf.edu,", "cdyer@cs.cmu.edu,", "nasmith@cs.washington.edu"], "sections": [{"heading": null, "text": "representation of the entire algorithm state, using stack long short-term memories. Our greedy inference algorithm has linear time, including feature extraction. On the CoNLL 2008\u20139 English shared tasks, we obtain the best published parsing performance among models that jointly learn syntax and semantics."}, {"heading": "1 Introduction", "text": "We introduce a new joint syntactic and semantic dependency parser. Our parser draws from the algorithmic insights of the incremental structure building approach of Henderson et al. (2008), with two key differences. First, it learns representations for the parser\u2019s entire algorithmic state, not just the top items on the stack or the most recent parser states; in fact, it uses no expert-crafted features at all. Second, it uses entirely greedy inference rather than beam search. We find that it outperforms all previous joint parsing models, including Henderson et al. (2008) and variants (Gesmundo et al., 2009; Titov et al., 2009; Henderson et al., 2013) on the CoNLL 2008 and 2009 (English) shared tasks. Our parser\u2019s multilingual results are comparable to the top systems at CoNLL 2009.\nJoint models like ours have frequently been proposed as a way to avoid cascading errors in NLP pipelines; varying degrees of success have been attained for a range of joint syntactic-semantic analysis tasks (Sutton and McCallum, 2005; Henderson et al., 2008; Toutanova et al., 2008; Johansson, 2009; Llu\u0131\u0301s et al., 2013, inter alia).\nOne reason pipelines often dominate is that they make available the complete syntactic parse tree, and arbitrarily-scoped syntactic features\u2014such as the \u201cpath\u201d between predicate and argument, proposed by Gildea and Jurafsky (2002)\u2014for semantic analysis. Such features are a mainstay of high-performance semantic role labeling (SRL) systems (Roth and Woodsend, 2014; Lei et al., 2015; FitzGerald et al., 2015; Foland and Martin, 2015), but they are expensive to extract (Johansson, 2009; He et al., 2013).\nThis study shows how recent advances in representation learning can bypass those expensive features, discovering cheap alternatives available during a greedy parsing procedure. The specific advance we employ is the stack LSTM (Dyer et al., 2015), a neural network that continuously summarizes the contents of the stack data structures in which a transition-based parser\u2019s state is conventionally encoded. Stack LSTMs were shown to obviate many features used in syntactic dependency parsing; here we find them to do the same for joint syntactic-semantic dependency parsing.\nWe believe this is an especially important finding for greedy models that cast parsing as a sequence of decisions made based on algorithmic state, where linguistic theory and researcher intuitions offer less guidance in feature design.\nOur system\u2019s performance does not match that of the top expert-crafted feature-based systems (Zhao et al., 2009; Bjo\u0308rkelund et al., 2010; Roth and Woodsend, 2014; Lei et al., 2015), systems which perform optimal decoding (Ta\u0308ckstro\u0308m et al., 2015), or of systems that exploit additional, differently-annotated datasets (FitzGerald et al., 2015). Many advances in those systems are orthogonal to our model, and we expect future work to achieve further gains by integrating them.\nar X\niv :1\n60 6.\n08 95\n4v 1\n[ cs\n.C L\n] 2\n9 Ju\nn 20\nBecause our system is very fast\u2014 with an end-to-end runtime of 177.6\u00b118 seconds to parse the CoNLL 2009 English test data on a single core\u2014we believe it will be useful in practical settings. Our open-source implementation has been released.1"}, {"heading": "2 Joint Syntactic and Semantic Dependency Parsing", "text": "We largely follow the transition-based, synchronized algorithm of Henderson et al. (2013) to predict joint parse structures. The input to the algorithm is a sentence annotated with part-of-speech tags. The output consists of a labeled syntactic dependency tree and a directed SRL graph, in which a subset of words in the sentence are selected as predicates, disambiguated to a sense, and linked by labeled, directed edges to their semantic arguments. Figure 1 shows an example."}, {"heading": "2.1 Transition-Based Procedure", "text": "The two parses are constructed in a bottom-up fashion, incrementally processing words in the sentence from left to right. The state of the parsing algorithm at timestep t is represented by three stack data structures: a syntactic stack St, a semantic stack Mt\u2014each containing partially built structures\u2014and a buffer of input words Bt. Our algorithm also places partial syntactic and semantic parse structures onto the front of the buffer, so it is also implemented as a stack. Each arc in the output corresponds to a transition (or \u201caction\u201d) chosen based on the current state; every transition modifies the state by updating St,Mt, andBt to St+1,Mt+1, andBt+1, respectively. While each state may license several valid actions, each action has a deterministic effect on the state of the algorithm.\nInitially, S0 and M0 are empty, and B0 contains the input sentence with the first word at the front of B and a special root symbol at the end.2 Execution ends on iteration t such that Bt is empty and St and Mt contain only a single structure headed by root."}, {"heading": "2.2 Transitions for Joint Parsing", "text": "There are separate sets of syntactic and semantic transitions; the former manipulate S andB, the latterM and B. All are formally defined in Table 1. The syntactic transitions are from the \u201carc-eager\u201d algorithm of Nivre (2008). They include:\n\u2022 S-SHIFT, which copies3 an item from the front of B and pushes it on S. \u2022 S-REDUCE pops an item from S.\n1https://github.com/clab/joint-lstm-parser 2This works better for the arc-eager algorithm (Ballesteros and Nivre, 2013), in contrast to Henderson et al. (2013), who initialized with root at the buffer front. 3Note that in the original arc-eager algorithm (Nivre, 2008), SHIFT and RIGHT-ARC actions move the item on the buffer front to the stack, whereas we only copy it (to allow the semantic operations to have access to it).\n\u2022 S-RIGHT(`) creates a syntactic dependency. Let u be the element at the top of S and v be the element at the front of B. The new dependency has u as head, v as dependent, and label `. u is popped off S, and the resulting structure, rooted at u, is pushed on S. Finally, v is copied to the top of S. \u2022 S-LEFT(`) creates a syntactic dependency with label ` in the reverse direction as S-RIGHT. The top\nof S, u, is popped. The front of B, v, is replaced by the new structure, rooted at v.\nThe semantic transitions are similar, operating on the semantic stack.\n\u2022 M-SHIFT removes an item from the front of B and pushes it on M . \u2022 M-REDUCE pops an item from M . \u2022 M-RIGHT(r) creates a semantic dependency. Let u be the element at the top of M and v, the front\nof B. The new dependency has u as head, v as dependent, and label r. u is popped off M , and the resulting structure, rooted at u, is pushed on M . \u2022 M-LEFT(r) creates a semantic dependency with label r in the reverse direction as M-RIGHT. The\nbuffer front, v, is replaced by the new v-rooted structure. M remains unchanged.\nBecause SRL graphs allow a node to be a semantic argument of two parents\u2014like all in the example in Figure 1\u2014M-LEFT and M-RIGHT do not remove the dependent from the semantic stack and buffer respectively, unlike their syntactic equivalents, S-LEFT and S-RIGHT. We use two other semantic transitions from Henderson et al. (2013) which have no syntactic analogues:\n\u2022 M-SWAP swaps the top two items on M , to allow for crossing semantic arcs. \u2022 M-PRED(p) marks the item at the front of B as a semantic predicate with the sense p, and replaces it\nwith the disambiguated predicate.\nThe CoNLL 2009 corpus introduces semantic self-dependencies where many nominal predicates (from NomBank) are marked as their own arguments; these account for 6.68% of all semantic arcs in the English corpus. An example involving an eventive noun is shown in Figure 2. We introduce a new semantic transition, not in Henderson et al. (2013), to handle such cases:\n\u2022 M-SELF(r) adds a dependency, with label r between the item at the front of B and itself. The result replaces the item at the front of B.\nNote that the syntactic and semantic transitions both operate on the same buffer, though they independently specify the syntax and semantics, respectively. In order to ensure that both syntactic and semantic parses are produced, the syntactic and semantic transitions are interleaved. Only syntactic transitions are considered until a transition is chosen that copies an item from the buffer front to the syntactic stack (either S-SHIFT or S-RIGHT). The algorithm then switches to semantic transitions until a buffer-modifying transition is taken (M-SHIFT).4 At this point, the buffer is modified and the algorithm returns to syntactic transitions. This implies that, for each word, its left-side syntactic dependencies are resolved before its left-side semantic dependencies. An example run of the algorithm is shown in Figure 3.\n4Had we moved the item at the buffer front during the syntactic transitions, it would have been unavailable for the semantic transitions, hence we only copy it."}, {"heading": "2.3 Constraints on Transitions", "text": "To ensure that the parser never enters an invalid state, the sequence of transitions is constrained, following Henderson et al. (2013). Actions that copy or move items from the buffer (S-SHIFT, S-RIGHT and M-SHIFT) are forbidden when the buffer is empty. Actions that pop from a stack (S-REDUCE and M-REDUCE) are forbidden when that stack is empty. We disallow actions corresponding to the same dependency, or the same predicate to be repeated in the sequence. Repetitive M-SWAP transitions are disallowed to avoid infinite swapping. Finally, as noted above, we restrict the parser to syntactic actions until it needs to shift an item from B to S, after which it can only execute semantic actions until it executes an M-SHIFT.\nAsymptotic runtime complexity of this greedy algorithm is linear in the length of the input, following the analysis by Nivre (2009).5"}, {"heading": "3 Statistical Model", "text": "The transitions in \u00a72 describe the execution paths our algorithm can take; like past work, we apply a statistical classifier to decide which transition to take at each timestep, given the current state. The novelty of our model is that it learns a finite-length vector representation of the entire joint parser\u2019s state (S, M , and B) in order to make this decision."}, {"heading": "3.1 Stack Long Short-Term Memory (LSTM)", "text": "LSTMs are recurrent neural networks equipped with specialized memory components in addition to a hidden state (Hochreiter and Schmidhuber, 1997; Graves, 2013) to model sequences. Stack LSTMs (Dyer et al., 2015) are LSTMs that allow for stack operations: query, push, and pop. A \u201cstack pointer\u201d is maintained which determines which cell in the LSTM provides the memory and hidden units when computing the new memory cell contents. Query provides a summary of the stack in a single fixed-length vector. Push adds an element to the top of the stack, resulting in a new summary. Pop, which does not correspond to a conventional LSTM operation, moves the stack pointer to the preceding timestep, resulting in a stack summary as it was before the popped item was observed. Implementation details (Dyer et al., 2015; Goldberg, 2015) and code have been made publicly available.6\nUsing stack LSTMs, we construct a representation of the algorithm state by decomposing it into smaller pieces that are combined by recursive function evaluations (similar to the way a list is built by a concatenate operation that operates on a list and an element). This enables information that would be distant from the \u201ctop\u201d of the stack to be carried forward, potentially helping the learner.\n5The analysis in (Nivre, 2009) does not consider SWAP actions. However, since we constrain the number of such actions, the linear time complexity of the algorithm stays intact.\n6https://github.com/clab/lstm-parser"}, {"heading": "3.2 Stack LSTMs for Joint Parsing", "text": "Our algorithm employs four stack LSTMs, one each for the S, M , and B data structures.Like Dyer et al. (2015), we use a fourth stack LSTM, A, for the history of actions\u2014A is never popped from, only pushed to. Figure 4 illustrates the architecture. The algorithm\u2019s state at timestep t is encoded by the four vectors summarizing the four stack LSTMs, and this is the input to the classifier that chooses among the allowable transitions at that timestep.\nLet st, mt, bt, and at denote the summaries of St,Mt,Bt, andAt, respectively. LetAt = Allowed(St,Mt, Bt, At) denote the allowed transitions given the current stacks and buffer. The parser state at time t is given by a\nrectified linear unit (Nair and Hinton, 2010) in vector yt:\nyt = elementwisemax {0,d+W[st;mt;bt;at]}\nwhere W and d are the parameters of the classifier. The transition selected at timestep t is\nargmax \u03c4\u2208At\nq\u03c4 + \u03b8\u03c4 \u00b7 yt (1)\n\u2261 argmax \u03c4\u2208At score(\u03c4 ;St,Mt, Bt, At)\nwhere \u03b8\u03c4 and q\u03c4 are parameters for each transition type \u03c4 . Note that only allowed transitions are considered in the decision rule (see \u00a72.3)."}, {"heading": "3.3 Composition Functions", "text": "To use stack LSTMs, we require vector representations of the elements that are stored in the stacks. Specifically, we require vector representations of atoms (words, possibly with part-of-speech tags) and parse fragments. Word vectors can be pretrained or learned directly; we consider a concatenation of both in our experiments; part-of-speech vectors are learned and concatenated to the same.\nTo obtain vector representations of parse fragments, we use neural networks which recursively compute representations of the complex structured output (Dyer et al., 2015). The tree structures here are always ternary trees, with each internal node\u2019s three children including a head, a dependent, and a label. The vectors for leaves are word vectors and vectors corresponding to syntactic and semantic relation types.\nThe vector for an internal node is a squashed (tanh) affine transformation of its children\u2019s vectors. For syntactic and semantic attachments, respectively, the composition function is:\ngs(v,u, l) = tanh(Zs[v;u; l] + es) (2)\ngm(v,u, r) = tanh(Zm[v;u; r] + em) (3)\nwhere v and u are vectors corresponding to atomic words or composed parse fragments; l and r are learned vector representations for syntactic and semantic labels respectively. Syntactic and semantic parameters are separated (Zs, es and Zm, em, respectively).\nFinally, for predicates, we use another recursive function to compose the word representation, v with a learned representation for the dismabiguated sense of the predicate, p:\ngd(v,p) = tanh(Zd[v;p] + ed) (4)\nwhere Zd and ed are parameters of the model. Note that, because syntactic and semantic transitions are interleaved, the fragmented structures are a blend of syntactic and semantic compositions. Figure 5 shows an example."}, {"heading": "3.4 Training", "text": "Training the classifier requires transforming each training instance (a joint parse) into a transition sequence, a deterministic operation under our transition set. Given a collection of algorithm states at time t and correct classification decisions \u03c4t, we minimize the sum of log-loss terms, given (for one timestep) by:\n\u2212 log exp(q\u03c4t + \u03b8\u03c4t \u00b7 yt)\u2211 \u03c4 \u2032\u2208At exp(q\u03c4 \u2032 + \u03b8\u03c4 \u2032 \u00b7 yt)\n(5)\nwith respect to the classifier and LSTM parameters. Note that the loss is differentiable with respect to the parameters; gradients are calculated using backpropagation. We apply stochastic gradient descent with dropout for all neural network parameters."}, {"heading": "3.5 Pretrained Embeddings", "text": "Following Dyer et al. (2015), \u201cstructured skip-gram\u201d embeddings (Ling et al., 2015) were used, trained on the English (AFP section), German, Spanish and Chinese Gigaword corpora, with a window of size 5; training was stopped after 5 epochs. For out-of-vocabulary words, a randomly initialized vector of the same dimension was used."}, {"heading": "3.6 Predicate Sense Disambiguation", "text": "Predicate sense disambiguation is handled within the model (M-PRED transitions), but since senses are lexeme-specific, we need a way to handle unseen predicates at test time. When a predicate is encountered at test time that was not observed in training, our system constructs a predicate from the predicted lemma of the word at that position and defaults to the \u201c01\u201d sense, which is correct for 91.22% of predicates by type in the English CoNLL 2009 training data."}, {"heading": "4 Experimental Setup", "text": "Our model is evaluated on the CoNLL shared tasks on joint syntactic and semantic dependency parsing in 2008 (Surdeanu et al., 2008) and 2009 (Hajic\u030c et al., 2009). The standard training, development and test splits of all datasets were used. Per the shared task guidelines, automatically predicted POS tags\nand lemmas provided in the datasets were used for all experiments. As a preprocessing step, pseudoprojectivization of the syntactic trees (Nivre et al., 2007) was used, which allowed an accurate conversion of even the non-projective syntactic trees into syntactic transitions. However, the oracle conversion of semantic parses into transitions is not perfect despite using the M-SWAP action, due to the presence of multiple crossing arcs.7\nThe standard evaluation metrics include the syntactic labeled attachment score (LAS), the semantic F1 score on both in-domain (WSJ) and out-of-domain (Brown corpus) data, and their macro average (Macro F1) to score joint systems. Because the task was defined somewhat differently in each year, each dataset is considered in turn."}, {"heading": "4.1 CoNLL 2008", "text": "The CoNLL 2008 dataset contains annotations from the Penn Treebank (Marcus et al., 1993), PropBank (Palmer et al., 2005) and NomBank (Meyers et al., 2004). The shared task evaluated systems on predicate identification in addition to predicate sense disambiguation and SRL.\nTo identify predicates, we trained a zero-Markov order bidirectional LSTM two-class classifier. As input to the classifier, we use learned representations of word lemmas and POS tags. This model achieves an F1 score of 91.43% on marking words as predicates (or not).\nHyperparameters The input representation for a word consists of pretrained embeddings (size 100 for English, 80 for Chinese, 64 for German and Spanish), concatenated with additional learned word and POS tag embeddings (size 32 and 12, respectively). Learned embeddings for syntactic and semantic arc labels are of size 20 and predicates 100. Two-layer LSTMs with hidden state dimension 100 were used for each of the four stacks. The parser state yt and the composition function g are of dimension 100. A dropout rate of 0.2 (Zaremba et al., 2014) was used on all layers at training time, tuned on the development data from the set of values {0.1, 0.2, 0.3, 1.0}. The learned representations for actions are of size 100, similarly tuned from {10, 20, 30, 40, 100}. Other hyperparameters have been set intuitively; careful tuning is expected to yield improvements (Weiss et al., 2015).\nAn initial learning rate of 0.1 for stochastic gradient descent was used and updated in every training epoch with a decay rate of 0.1 (Dyer et al., 2015). Training is stopped when the development performance does not improve for approximately 6\u20137 hours of elapsed time. Experiments were run on a single thread on a CPU, with memory requirements of up to 512 MB."}, {"heading": "4.2 CoNLL 2009", "text": "Relative to the CoNLL 2008 task (above), the main change in 2009 is that predicates are pre-identified, and systems are only evaluated on predicate sense disambiguation (not identification). Hence, the bidirectional LSTM classifier is not used here. The preprocessing for projectivity, and the hyperparameter selection is the same as in \u00a74.1.\nIn addition to the joint approach described in the preceding sections, we experiment here with several variants:\nSemantics-only: the set of syntactic transitions S, the syntactic stack S, and the syntactic composition function gs are discarded. As a result, the set of constraints on transitions is a subset of the full set of constraints in \u00a72.3. Effectively, this model does not use any syntactic features, similar to Collobert et al. (2011) and Zhou and Xu (2015). It provides a controlled test of the benefit of explicit syntax in a semantic parser.\nSyntax-only: all semantic transitions in M, the semantic stack M , and the semantic composition function gm are discarded. S-SHIFT and S-RIGHT now move the item from the front of the buffer to the syntactic stack, instead of copying. The set of constraints on the transitions is again a subset of the full set of constraints. This model is an arc-eager variant of Dyer et al. (2015), and serves to check whether semantic parsing degrades syntactic performance.\n7For 1.5% of English sentences in the CoNLL 2009 English dataset, the transition sequence incorrectly encodes the goldstandard joint parse; details in Henderson et al. (2013).\nHybrid: the semantics parameters are trained using automatically predicted syntax from the syntaxonly model. At test time, only semantic parses are predicted. This setup bears similarity to other approaches which pipeline syntax and semantics, extracting features from the syntactic parse to help SRL. However, unlike other approaches, this model does not offer the entire syntactic tree for feature extraction, since only the partial syntactic structures present on the syntactic stack (and potentially the buffer) are visible at a given timestep. This model helps show the effect of joint prediction."}, {"heading": "5 Results and Discussion", "text": "CoNLL 2008 (Table 2) Our joint model significantly outperforms the joint model of Henderson et al. (2008), from which our set of transitions is derived, showing the benefit of learning a representation for the entire algorithmic state. Several other joint learning models have been proposed (Llu\u0131\u0301s and Ma\u0300rquez, 2008; Johansson, 2009; Titov et al., 2009) for the same task; our joint model surpasses the performance of all these models. The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these. We fall behind only Johansson and Nugues (2008), whose success was attributed to carefully designed global SRL features integrated into a pipeline of classifiers, making them asymptotically slower.\nCoNLL 2009 English (Table 3) All of our models (Syntax-only, Semantics-only, Hybrid and Joint) improve over Gesmundo et al. (2009) and Henderson et al. (2013), demonstrating the benefit of our entire-parser-state representation learner compared to the more locally scoped model.\nGiven that syntax has consistently proven useful in SRL, we expected our Semantics-only model to underperform Hybrid and Joint, and it did. In the training domain, syntax and semantics benefit each other (Joint outperforms Hybrid). Out-of-domain (the Brown test set), the Hybrid pulls ahead, a sign that Joint overfits to WSJ. As a syntactic parser, our Syntax-only model performs slightly better than Dyer et al. (2015), who achieve 89.56 LAS on this task. Joint parsing is very slightly better still.\nThe overall performance of Joint is on par with the other winning participants at the CoNLL 2009 shared task (Zhao et al., 2009; Che et al., 2009; Gesmundo et al., 2009), falling behind only Zhao et al. (2009), who carefully designed language-specific features and used a series of pipelines for the joint task, resulting in an accurate but computationally expensive system.\nState-of-the-art SRL systems (shown in the last block of Table 3) which use advances orthogonal to the contributions in this paper, perform better than our models. Many of these systems use expert-crafted features derived from full syntactic parses in a pipeline of classifiers followed by a global reranker (Bjo\u0308rkelund et al., 2009; Bjo\u0308rkelund et al., 2010; Roth and Woodsend, 2014); we have not used these features or reranking. Lei et al. (2015) use syntactic parses to obtain interaction features between predicates and their arguments and then compress feature representations using a low-rank tensor. Ta\u0308ckstro\u0308m et al. (2015) present an exact inference algorithm for SRL based on dynamic programming and their local and\nstructured models make use of many syntactic features from a pipeline; our search procedure is greedy. Their algorithm is adopted by FitzGerald et al. (2015) for inference in a model that jointly learns representations from a combination of PropBank and FrameNet annotations; we have not experimented with extra annotations.\nOur system achieves an end-to-end runtime of 177.6\u00b118 seconds to parse the CoNLL 2009 English test set on a single core. This is almost 2.5 times faster than the pipeline model of Lei et al. (2015) (439.9\u00b142 seconds) on the same machine.8\nCoNLL 2009 Multilingual (Table 4) We tested the joint model on the non-English CoNLL 2009 datasets, and the results demonstrate that it adapts easily\u2014it is on par with the top three systems in most cases. We note that our Chinese parser relies on pretrained word embeddings for its superior performance; without them (not shown), it was on par with the others. Japanese is a small-data case (4,393 training examples), illustrating our model\u2019s dependence on reasonably large training datasets.\nWe have not extended our model to incorporate morphological features, which are used by the systems to which we compare. Future work might incorporate morphological features where available; this could potentially improve performance, especially in highly inflective languages like Czech. An alternative might be to infer word-internal representations using character-based word embeddings, which was found beneficial for syntactic parsing (Ballesteros et al., 2015).\n8See https://github.com/taolei87/SRLParser; unlike other state-of-the-art systems, this one is publicly available."}, {"heading": "6 Related Work", "text": "Other approaches to joint modeling, not considered in our experiments, are notable. Llu\u0131\u0301s et al. (2013) propose a graph-based joint model using dual decomposition for agreement between syntax and semantics, but do not achieve competitive performance on the CoNLL 2009 task. Lewis et al. (2015) proposed an efficient joint model for CCG syntax and SRL, which performs better than a pipelined model. However, their training necessitates CCG annotation, ours does not. Moreover, their evaluation metric rewards semantic dependencies regardless of where they attach within the argument span given by a PropBank constituent, making direct comparison to our evaluation infeasible. Krishnamurthy and Mitchell (2014) propose a joint CCG parsing and relation extraction model which improves over pipelines, but their task is different from ours. Li et al. (2010) also perform joint syntactic and semantic dependency parsing for Chinese, but do not report results on the CoNLL 2009 dataset.\nThere has also been an increased interest in models which use neural networks for SRL. Collobert et al. (2011) proposed models which perform many NLP tasks without hand-crafted features. Though they did not achieve the best results on the constituent-based SRL task (Carreras and Ma\u0300rquez, 2005), their approach inspired Zhou and Xu (2015), who achieved state-of-the-art results using deep bidirectional LSTMs. Our approach for dependency-based SRL is not directly comparable."}, {"heading": "7 Conclusion", "text": "We presented an incremental, greedy parser for joint syntactic and semantic dependency parsing. Our model surpasses the performance of previous joint models on the CoNLL 2008 and 2009 English tasks, without using expert-crafted, expensive features of the full syntactic parse."}, {"heading": "Acknowledgments", "text": "The authors thank Sam Thomson, Lingpeng Kong, Mark Yatskar, Eunsol Choi, George Mulcaire, and Luheng He, as well as the anonymous reviewers, for many useful comments. This research was supported in part by DARPA grant FA8750-12-2-0342 funded under the DEFT program and by the U.S. Army Research Office under grant number W911NF-10-1-0533. Any opinion, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the view of the U.S. Army Research Office or the U.S. Government. Miguel Ballesteros was supported by the European Commission under the contract numbers FP7-ICT-610411 (project MULTISENSOR) and H2020-RIA-645012 (project KRISTINA)."}], "references": [{"title": "Going to the roots of dependency parsing", "author": ["Ballesteros", "Nivre2013] Miguel Ballesteros", "Joakim Nivre"], "venue": "Computational Linguistics,", "citeRegEx": "Ballesteros et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Ballesteros et al\\.", "year": 2013}, {"title": "Improved transition-based parsing by modeling characters instead of words with LSTMs", "author": ["Chris Dyer", "Noah A. Smith"], "venue": "In Proc. of EMNLP", "citeRegEx": "Ballesteros et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ballesteros et al\\.", "year": 2015}, {"title": "Multilingual semantic role labeling", "author": ["Love Hafdell", "Pierre Nugues"], "venue": "In Proc. of CoNLL", "citeRegEx": "Bj\u00f6rkelund et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Bj\u00f6rkelund et al\\.", "year": 2009}, {"title": "A highperformance syntactic and semantic dependency parser", "author": ["Bernd Bohnet", "Love Hafdell", "Pierre Nugues"], "venue": "In Proc. of COLING", "citeRegEx": "Bj\u00f6rkelund et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bj\u00f6rkelund et al\\.", "year": 2010}, {"title": "Introduction to the CoNLL-2005 shared task: Semantic role labeling", "author": ["Carreras", "M\u00e0rquez2005] Xavier Carreras", "Llu\u0131\u0301s M\u00e0rquez"], "venue": "In Proc. of CoNLL", "citeRegEx": "Carreras et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Carreras et al\\.", "year": 2005}, {"title": "A cascaded syntactic and semantic dependency parsing system", "author": ["Che et al.2008] Wanxiang Che", "Zhenghua Li", "Yuxuan Hu", "Yongqiang Li", "Bing Qin", "Ting Liu", "Sheng Li"], "venue": "In Proc. of CoNLL", "citeRegEx": "Che et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Che et al\\.", "year": 2008}, {"title": "Multilingual dependency-based syntactic and semantic parsing", "author": ["Che et al.2009] Wanxiang Che", "Zhenghua Li", "Yongqiang Li", "Yuhang Guo", "Bing Qin", "Ting Liu"], "venue": "In Proc. of CoNLL", "citeRegEx": "Che et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Che et al\\.", "year": 2009}, {"title": "DeSRL: A linear-time semantic role labeling system", "author": ["Giuseppe Attardi", "Felice Dell\u2019Orletta", "Mihai Surdeanu"], "venue": "In Proc. of CoNLL", "citeRegEx": "Ciaramita et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ciaramita et al\\.", "year": 2008}, {"title": "Natural language processing (almost) from scratch", "author": ["Jason Weston", "L\u00e9on Bottou", "Michael Karlen", "Koray Kavukcuoglu", "Pavel Kuksa"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Collobert et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Collobert et al\\.", "year": 2011}, {"title": "Transition-based dependency parsing with stack long short-term memory", "author": ["Dyer et al.2015] Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith"], "venue": "In Proc. of ACL", "citeRegEx": "Dyer et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Dyer et al\\.", "year": 2015}, {"title": "Semantic role labelling with neural network factors", "author": ["Oscar T\u00e4ckstr\u00f6m", "Kuzman Ganchev", "Dipanjan Das"], "venue": "In Proc. of EMNLP", "citeRegEx": "FitzGerald et al\\.,? \\Q2015\\E", "shortCiteRegEx": "FitzGerald et al\\.", "year": 2015}, {"title": "Dependencybased semantic role labeling using convolutional neural networks", "author": ["Foland", "Martin2015] William R. Foland", "James Martin"], "venue": "In Proc. of *SEM", "citeRegEx": "Foland et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Foland et al\\.", "year": 2015}, {"title": "A latent variable model of synchronous syntactic-semantic parsing for multiple languages", "author": ["James Henderson", "Paola Merlo", "Ivan Titov"], "venue": "In Proc. of CoNLL", "citeRegEx": "Gesmundo et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Gesmundo et al\\.", "year": 2009}, {"title": "Automatic labeling of semantic roles", "author": ["Gildea", "Jurafsky2002] Daniel Gildea", "Daniel Jurafsky"], "venue": "Computational Linguistics,", "citeRegEx": "Gildea et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Gildea et al\\.", "year": 2002}, {"title": "A primer on neural network models for natural language processing", "author": ["Yoav Goldberg"], "venue": null, "citeRegEx": "Goldberg.,? \\Q2015\\E", "shortCiteRegEx": "Goldberg.", "year": 2015}, {"title": "Generating sequences with recurrent neural networks. arXiv:1308.0850", "author": ["Alex Graves"], "venue": null, "citeRegEx": "Graves.,? \\Q2013\\E", "shortCiteRegEx": "Graves.", "year": 2013}, {"title": "The CoNLL-2009 shared task: Syntactic and semantic dependencies in multiple languages", "author": ["Haji\u010d et al.2009] Jan Haji\u010d", "Massimiliano Ciaramita", "Richard Johansson", "Daisuke Kawahara", "Maria Ant\u00f2nia Mart\u0131", "Llu\u0131\u0301s M\u00e0rquez", "Adam Meyers", "Joakim Nivre", "Sebastian Pad\u00f3", "Jan \u0160t\u011bp\u00e1nek", "Pavel Stra\u0148\u00e1k", "Mihai Surdeanu", "Nianwen Xue", "Yi Zhang"], "venue": "In Proc. of CoNLL", "citeRegEx": "Haji\u010d et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Haji\u010d et al\\.", "year": 2009}, {"title": "Dynamic feature selection for dependency parsing", "author": ["He et al.2013] He He", "Hal Daum\u00e9 III", "Jason Eisner"], "venue": "In Proc. of EMNLP", "citeRegEx": "He et al\\.,? \\Q2013\\E", "shortCiteRegEx": "He et al\\.", "year": 2013}, {"title": "A latent variable model of synchronous parsing for syntactic and semantic dependencies", "author": ["Paola Merlo", "Gabriele Musillo", "Ivan Titov"], "venue": "In Proc. of CoNLL", "citeRegEx": "Henderson et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Henderson et al\\.", "year": 2008}, {"title": "Multi-lingual joint parsing of syntactic and semantic dependencies with a latent variable model", "author": ["Paola Merlo", "Ivan Titov", "Gabriele Musillo"], "venue": null, "citeRegEx": "Henderson et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Henderson et al\\.", "year": 2013}, {"title": "Long short-term memory", "author": ["Hochreiter", "Schmidhuber1997] Sepp Hochreiter", "J\u00fcrgen Schmidhuber"], "venue": "Neural Computation,", "citeRegEx": "Hochreiter et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter et al\\.", "year": 1997}, {"title": "Dependency-based syntactic-semantic analysis with PropBank and NomBank", "author": ["Johansson", "Nugues2008] Richard Johansson", "Pierre Nugues"], "venue": "In Proc. of CoNLL", "citeRegEx": "Johansson et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Johansson et al\\.", "year": 2008}, {"title": "Statistical bistratal dependency parsing", "author": ["Richard Johansson"], "venue": "In Proc. of EMNLP", "citeRegEx": "Johansson.,? \\Q2009\\E", "shortCiteRegEx": "Johansson.", "year": 2009}, {"title": "Joint syntactic and semantic parsing with combinatory categorial grammar", "author": ["Krishnamurthy", "Tom M. Mitchell"], "venue": "In Proc. of ACL", "citeRegEx": "Krishnamurthy et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Krishnamurthy et al\\.", "year": 2014}, {"title": "High-order low-rank tensors for semantic role labeling", "author": ["Lei et al.2015] Tao Lei", "Yuan Zhang", "Llu\u0131\u0301s M\u00e0rquez i Villodre", "Alessandro Moschitti", "Regina Barzilay"], "venue": "In Proc. of NAACL", "citeRegEx": "Lei et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Lei et al\\.", "year": 2015}, {"title": "Joint A* CCG parsing and semantic role labelling", "author": ["Lewis et al.2015] Mike Lewis", "Luheng He", "Luke Zettlemoyer"], "venue": "In Proc. of EMNLP", "citeRegEx": "Lewis et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Lewis et al\\.", "year": 2015}, {"title": "Joint syntactic and semantic parsing of Chinese", "author": ["Li et al.2010] Junhui Li", "Guodong Zhou", "Hwee Tou Ng"], "venue": "In Proc. of ACL", "citeRegEx": "Li et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Li et al\\.", "year": 2010}, {"title": "Two/too simple adaptations of word2vec for syntax problems", "author": ["Ling et al.2015] Wang Ling", "Chris Dyer", "Alan Black", "Isabel Trancoso"], "venue": "In Proc. of NAACL", "citeRegEx": "Ling et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Ling et al\\.", "year": 2015}, {"title": "Joint arc-factored parsing of syntactic and semantic dependencies", "author": ["Llu\u0131\u0301s et al.2013] Xavier Llu\u0131\u0301s", "Xavier Carreras", "Llu\u0131\u0301s M\u00e0rquez"], "venue": "Transactions of the ACL,", "citeRegEx": "Llu\u0131\u0301s et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Llu\u0131\u0301s et al\\.", "year": 2013}, {"title": "Building a large annotated corpus of English: The Penn treebank", "author": ["Mary Ann Marcinkiewicz", "Beatrice Santorini"], "venue": null, "citeRegEx": "Marcus et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Marcus et al\\.", "year": 1993}, {"title": "The NomBank project: An interim report", "author": ["Meyers et al.2004] Adam Meyers", "Ruth Reeves", "Catherine Macleod", "Rachel Szekely", "Veronika Zielinska", "Brian Young", "Ralph Grishman"], "venue": "In Proc. of NAACL", "citeRegEx": "Meyers et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Meyers et al\\.", "year": 2004}, {"title": "Rectified linear units improve restricted Boltzmann machines", "author": ["Nair", "Hinton2010] Vinod Nair", "Geoffrey E. Hinton"], "venue": "In Proc. of ICML", "citeRegEx": "Nair et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Nair et al\\.", "year": 2010}, {"title": "MaltParser: A language-independent system for data-driven dependency parsing", "author": ["Nivre et al.2007] Joakim Nivre", "Johan Hall", "Jens Nilsson", "Atanas Chanev", "G\u00fclsen Eryigit", "Sandra K\u00fcbler", "Svetoslav Marinov", "Erwin Marsi"], "venue": "Natural Language Engineering,", "citeRegEx": "Nivre et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Nivre et al\\.", "year": 2007}, {"title": "Algorithms for deterministic incremental dependency parsing", "author": ["Joakim Nivre"], "venue": "Computational Linguistics,", "citeRegEx": "Nivre.,? \\Q2008\\E", "shortCiteRegEx": "Nivre.", "year": 2008}, {"title": "Non-projective dependency parsing in expected linear time", "author": ["Joakim Nivre"], "venue": "In Proc. of ACL", "citeRegEx": "Nivre.,? \\Q2009\\E", "shortCiteRegEx": "Nivre.", "year": 2009}, {"title": "The Proposition Bank: An annotated corpus of semantic roles", "author": ["Palmer et al.2005] Martha Palmer", "Daniel Gildea", "Paul Kingsbury"], "venue": null, "citeRegEx": "Palmer et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Palmer et al\\.", "year": 2005}, {"title": "Composition of word representations improves semantic role labelling", "author": ["Roth", "Woodsend2014] Michael Roth", "Kristian Woodsend"], "venue": "In Proc. of EMNLP", "citeRegEx": "Roth et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Roth et al\\.", "year": 2014}, {"title": "The CoNLL-2008 shared task on joint parsing of syntactic and semantic dependencies", "author": ["Richard Johansson", "Adam Meyers", "Llu\u0131\u0301s M\u00e0rquez", "Joakim Nivre"], "venue": "In Proc. of CoNLL", "citeRegEx": "Surdeanu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Surdeanu et al\\.", "year": 2008}, {"title": "Joint parsing and semantic role labeling", "author": ["Sutton", "McCallum2005] Charles Sutton", "Andrew McCallum"], "venue": "In Proc. of CoNLL", "citeRegEx": "Sutton et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Sutton et al\\.", "year": 2005}, {"title": "Efficient inference and structured learning for semantic role labeling", "author": ["Kuzman Ganchev", "Dipanjan Das"], "venue": "Transactions of the ACL,", "citeRegEx": "T\u00e4ckstr\u00f6m et al\\.,? \\Q2015\\E", "shortCiteRegEx": "T\u00e4ckstr\u00f6m et al\\.", "year": 2015}, {"title": "Online graph planarisation for synchronous parsing of semantic and syntactic dependencies", "author": ["Titov et al.2009] Ivan Titov", "James Henderson", "Paola Merlo", "Gabriele Musillo"], "venue": "In Proc. of IJCAI", "citeRegEx": "Titov et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Titov et al\\.", "year": 2009}, {"title": "A global joint model for semantic role labeling", "author": ["Aria Haghighi", "Christopher D. Manning"], "venue": null, "citeRegEx": "Toutanova et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Toutanova et al\\.", "year": 2008}, {"title": "Structured training for neural network transition-based parsing", "author": ["Weiss et al.2015] David Weiss", "Chris Alberti", "Michael Collins", "Slav Petrov"], "venue": "In Proc. of ACL", "citeRegEx": "Weiss et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Weiss et al\\.", "year": 2015}, {"title": "Recurrent neural network regularization", "author": ["Ilya Sutskever", "Oriol Vinyals"], "venue": null, "citeRegEx": "Zaremba et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Zaremba et al\\.", "year": 2014}, {"title": "Parsing syntactic and semantic dependencies with two single-stage maximum entropy models", "author": ["Zhao", "Kit2008] Hai Zhao", "Chunyu Kit"], "venue": "In Proc. of CoNLL", "citeRegEx": "Zhao et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Zhao et al\\.", "year": 2008}, {"title": "Multilingual dependency learning: Exploiting rich features for tagging syntactic and semantic dependencies", "author": ["Zhao et al.2009] Hai Zhao", "Wenliang Chen", "Jun\u2019ichi Kazama", "Kiyotaka Uchimoto", "Kentaro Torisawa"], "venue": "In Proc. of CoNLL", "citeRegEx": "Zhao et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Zhao et al\\.", "year": 2009}, {"title": "End-to-end learning of semantic role labeling using recurrent neural networks", "author": ["Zhou", "Xu2015] Jie Zhou", "Wei Xu"], "venue": "In Proc. of ACL", "citeRegEx": "Zhou et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Zhou et al\\.", "year": 2015}], "referenceMentions": [{"referenceID": 12, "context": "(2008) and variants (Gesmundo et al., 2009; Titov et al., 2009; Henderson et al., 2013) on the CoNLL 2008 and 2009 (English) shared tasks.", "startOffset": 20, "endOffset": 87}, {"referenceID": 40, "context": "(2008) and variants (Gesmundo et al., 2009; Titov et al., 2009; Henderson et al., 2013) on the CoNLL 2008 and 2009 (English) shared tasks.", "startOffset": 20, "endOffset": 87}, {"referenceID": 19, "context": "(2008) and variants (Gesmundo et al., 2009; Titov et al., 2009; Henderson et al., 2013) on the CoNLL 2008 and 2009 (English) shared tasks.", "startOffset": 20, "endOffset": 87}, {"referenceID": 24, "context": "Such features are a mainstay of high-performance semantic role labeling (SRL) systems (Roth and Woodsend, 2014; Lei et al., 2015; FitzGerald et al., 2015; Foland and Martin, 2015), but they are expensive to extract (Johansson, 2009; He et al.", "startOffset": 86, "endOffset": 179}, {"referenceID": 10, "context": "Such features are a mainstay of high-performance semantic role labeling (SRL) systems (Roth and Woodsend, 2014; Lei et al., 2015; FitzGerald et al., 2015; Foland and Martin, 2015), but they are expensive to extract (Johansson, 2009; He et al.", "startOffset": 86, "endOffset": 179}, {"referenceID": 22, "context": ", 2015; Foland and Martin, 2015), but they are expensive to extract (Johansson, 2009; He et al., 2013).", "startOffset": 68, "endOffset": 102}, {"referenceID": 17, "context": ", 2015; Foland and Martin, 2015), but they are expensive to extract (Johansson, 2009; He et al., 2013).", "startOffset": 68, "endOffset": 102}, {"referenceID": 9, "context": "The specific advance we employ is the stack LSTM (Dyer et al., 2015), a neural network that continuously summarizes the contents of the stack data structures in which a transition-based parser\u2019s state is conventionally encoded.", "startOffset": 49, "endOffset": 68}, {"referenceID": 45, "context": "Our system\u2019s performance does not match that of the top expert-crafted feature-based systems (Zhao et al., 2009; Bj\u00f6rkelund et al., 2010; Roth and Woodsend, 2014; Lei et al., 2015), systems which perform optimal decoding (T\u00e4ckstr\u00f6m et al.", "startOffset": 93, "endOffset": 180}, {"referenceID": 3, "context": "Our system\u2019s performance does not match that of the top expert-crafted feature-based systems (Zhao et al., 2009; Bj\u00f6rkelund et al., 2010; Roth and Woodsend, 2014; Lei et al., 2015), systems which perform optimal decoding (T\u00e4ckstr\u00f6m et al.", "startOffset": 93, "endOffset": 180}, {"referenceID": 24, "context": "Our system\u2019s performance does not match that of the top expert-crafted feature-based systems (Zhao et al., 2009; Bj\u00f6rkelund et al., 2010; Roth and Woodsend, 2014; Lei et al., 2015), systems which perform optimal decoding (T\u00e4ckstr\u00f6m et al.", "startOffset": 93, "endOffset": 180}, {"referenceID": 39, "context": ", 2015), systems which perform optimal decoding (T\u00e4ckstr\u00f6m et al., 2015), or of systems that exploit additional, differently-annotated datasets (FitzGerald et al.", "startOffset": 48, "endOffset": 72}, {"referenceID": 10, "context": ", 2015), or of systems that exploit additional, differently-annotated datasets (FitzGerald et al., 2015).", "startOffset": 79, "endOffset": 104}, {"referenceID": 12, "context": "Our parser draws from the algorithmic insights of the incremental structure building approach of Henderson et al. (2008), with two key differences.", "startOffset": 97, "endOffset": 121}, {"referenceID": 12, "context": "Our parser draws from the algorithmic insights of the incremental structure building approach of Henderson et al. (2008), with two key differences. First, it learns representations for the parser\u2019s entire algorithmic state, not just the top items on the stack or the most recent parser states; in fact, it uses no expert-crafted features at all. Second, it uses entirely greedy inference rather than beam search. We find that it outperforms all previous joint parsing models, including Henderson et al. (2008) and variants (Gesmundo et al.", "startOffset": 97, "endOffset": 510}, {"referenceID": 8, "context": "(2008) and variants (Gesmundo et al., 2009; Titov et al., 2009; Henderson et al., 2013) on the CoNLL 2008 and 2009 (English) shared tasks. Our parser\u2019s multilingual results are comparable to the top systems at CoNLL 2009. Joint models like ours have frequently been proposed as a way to avoid cascading errors in NLP pipelines; varying degrees of success have been attained for a range of joint syntactic-semantic analysis tasks (Sutton and McCallum, 2005; Henderson et al., 2008; Toutanova et al., 2008; Johansson, 2009; Llu\u0131\u0301s et al., 2013, inter alia). One reason pipelines often dominate is that they make available the complete syntactic parse tree, and arbitrarily-scoped syntactic features\u2014such as the \u201cpath\u201d between predicate and argument, proposed by Gildea and Jurafsky (2002)\u2014for semantic analysis.", "startOffset": 21, "endOffset": 787}, {"referenceID": 18, "context": "1 2 Joint Syntactic and Semantic Dependency Parsing We largely follow the transition-based, synchronized algorithm of Henderson et al. (2013) to predict joint parse structures.", "startOffset": 118, "endOffset": 142}, {"referenceID": 33, "context": "Note that in the original arc-eager algorithm (Nivre, 2008), SHIFT and RIGHT-ARC actions move the item on the buffer front to the stack, whereas we only copy it (to allow the semantic operations to have access to it).", "startOffset": 46, "endOffset": 59}, {"referenceID": 31, "context": "The syntactic transitions are from the \u201carc-eager\u201d algorithm of Nivre (2008). They include: \u2022 S-SHIFT, which copies3 an item from the front of B and pushes it on S.", "startOffset": 64, "endOffset": 77}, {"referenceID": 18, "context": "com/clab/joint-lstm-parser This works better for the arc-eager algorithm (Ballesteros and Nivre, 2013), in contrast to Henderson et al. (2013), who initialized with root at the buffer front.", "startOffset": 119, "endOffset": 143}, {"referenceID": 18, "context": "We use two other semantic transitions from Henderson et al. (2013) which have no syntactic analogues: \u2022 M-SWAP swaps the top two items on M , to allow for crossing semantic arcs.", "startOffset": 43, "endOffset": 67}, {"referenceID": 18, "context": "We use two other semantic transitions from Henderson et al. (2013) which have no syntactic analogues: \u2022 M-SWAP swaps the top two items on M , to allow for crossing semantic arcs. \u2022 M-PRED(p) marks the item at the front of B as a semantic predicate with the sense p, and replaces it with the disambiguated predicate. The CoNLL 2009 corpus introduces semantic self-dependencies where many nominal predicates (from NomBank) are marked as their own arguments; these account for 6.68% of all semantic arcs in the English corpus. An example involving an eventive noun is shown in Figure 2. We introduce a new semantic transition, not in Henderson et al. (2013), to handle such cases: \u2022 M-SELF(r) adds a dependency, with label r between the item at the front of B and itself.", "startOffset": 43, "endOffset": 655}, {"referenceID": 18, "context": "3 Constraints on Transitions To ensure that the parser never enters an invalid state, the sequence of transitions is constrained, following Henderson et al. (2013). Actions that copy or move items from the buffer (S-SHIFT, S-RIGHT and M-SHIFT) are forbidden when the buffer is empty.", "startOffset": 140, "endOffset": 164}, {"referenceID": 18, "context": "3 Constraints on Transitions To ensure that the parser never enters an invalid state, the sequence of transitions is constrained, following Henderson et al. (2013). Actions that copy or move items from the buffer (S-SHIFT, S-RIGHT and M-SHIFT) are forbidden when the buffer is empty. Actions that pop from a stack (S-REDUCE and M-REDUCE) are forbidden when that stack is empty. We disallow actions corresponding to the same dependency, or the same predicate to be repeated in the sequence. Repetitive M-SWAP transitions are disallowed to avoid infinite swapping. Finally, as noted above, we restrict the parser to syntactic actions until it needs to shift an item from B to S, after which it can only execute semantic actions until it executes an M-SHIFT. Asymptotic runtime complexity of this greedy algorithm is linear in the length of the input, following the analysis by Nivre (2009).5 3 Statistical Model The transitions in \u00a72 describe the execution paths our algorithm can take; like past work, we apply a statistical classifier to decide which transition to take at each timestep, given the current state.", "startOffset": 140, "endOffset": 888}, {"referenceID": 15, "context": "1 Stack Long Short-Term Memory (LSTM) LSTMs are recurrent neural networks equipped with specialized memory components in addition to a hidden state (Hochreiter and Schmidhuber, 1997; Graves, 2013) to model sequences.", "startOffset": 148, "endOffset": 196}, {"referenceID": 9, "context": "Stack LSTMs (Dyer et al., 2015) are LSTMs that allow for stack operations: query, push, and pop.", "startOffset": 12, "endOffset": 31}, {"referenceID": 9, "context": "Implementation details (Dyer et al., 2015; Goldberg, 2015) and code have been made publicly available.", "startOffset": 23, "endOffset": 58}, {"referenceID": 14, "context": "Implementation details (Dyer et al., 2015; Goldberg, 2015) and code have been made publicly available.", "startOffset": 23, "endOffset": 58}, {"referenceID": 34, "context": "The analysis in (Nivre, 2009) does not consider SWAP actions.", "startOffset": 16, "endOffset": 29}, {"referenceID": 9, "context": "Like Dyer et al. (2015), we use a fourth stack LSTM, A, for the history of actions\u2014A is never popped from, only pushed to.", "startOffset": 5, "endOffset": 24}, {"referenceID": 9, "context": "To obtain vector representations of parse fragments, we use neural networks which recursively compute representations of the complex structured output (Dyer et al., 2015).", "startOffset": 151, "endOffset": 170}, {"referenceID": 27, "context": "(2015), \u201cstructured skip-gram\u201d embeddings (Ling et al., 2015) were used, trained on the English (AFP section), German, Spanish and Chinese Gigaword corpora, with a window of size 5; training was stopped after 5 epochs.", "startOffset": 42, "endOffset": 61}, {"referenceID": 9, "context": "5 Pretrained Embeddings Following Dyer et al. (2015), \u201cstructured skip-gram\u201d embeddings (Ling et al.", "startOffset": 34, "endOffset": 53}, {"referenceID": 37, "context": "4 Experimental Setup Our model is evaluated on the CoNLL shared tasks on joint syntactic and semantic dependency parsing in 2008 (Surdeanu et al., 2008) and 2009 (Haji\u010d et al.", "startOffset": 129, "endOffset": 152}, {"referenceID": 16, "context": ", 2008) and 2009 (Haji\u010d et al., 2009).", "startOffset": 17, "endOffset": 37}, {"referenceID": 32, "context": "As a preprocessing step, pseudoprojectivization of the syntactic trees (Nivre et al., 2007) was used, which allowed an accurate conversion of even the non-projective syntactic trees into syntactic transitions.", "startOffset": 71, "endOffset": 91}, {"referenceID": 29, "context": "1 CoNLL 2008 The CoNLL 2008 dataset contains annotations from the Penn Treebank (Marcus et al., 1993), PropBank (Palmer et al.", "startOffset": 80, "endOffset": 101}, {"referenceID": 35, "context": ", 1993), PropBank (Palmer et al., 2005) and NomBank (Meyers et al.", "startOffset": 18, "endOffset": 39}, {"referenceID": 30, "context": ", 2005) and NomBank (Meyers et al., 2004).", "startOffset": 20, "endOffset": 41}, {"referenceID": 43, "context": "2 (Zaremba et al., 2014) was used on all layers at training time, tuned on the development data from the set of values {0.", "startOffset": 2, "endOffset": 24}, {"referenceID": 42, "context": "Other hyperparameters have been set intuitively; careful tuning is expected to yield improvements (Weiss et al., 2015).", "startOffset": 98, "endOffset": 118}, {"referenceID": 9, "context": "1 (Dyer et al., 2015).", "startOffset": 2, "endOffset": 21}, {"referenceID": 8, "context": "Effectively, this model does not use any syntactic features, similar to Collobert et al. (2011) and Zhou and Xu (2015).", "startOffset": 72, "endOffset": 96}, {"referenceID": 8, "context": "Effectively, this model does not use any syntactic features, similar to Collobert et al. (2011) and Zhou and Xu (2015). It provides a controlled test of the benefit of explicit syntax in a semantic parser.", "startOffset": 72, "endOffset": 119}, {"referenceID": 8, "context": "Effectively, this model does not use any syntactic features, similar to Collobert et al. (2011) and Zhou and Xu (2015). It provides a controlled test of the benefit of explicit syntax in a semantic parser. Syntax-only: all semantic transitions in M, the semantic stack M , and the semantic composition function gm are discarded. S-SHIFT and S-RIGHT now move the item from the front of the buffer to the syntactic stack, instead of copying. The set of constraints on the transitions is again a subset of the full set of constraints. This model is an arc-eager variant of Dyer et al. (2015), and serves to check whether semantic parsing degrades syntactic performance.", "startOffset": 72, "endOffset": 589}, {"referenceID": 8, "context": "Effectively, this model does not use any syntactic features, similar to Collobert et al. (2011) and Zhou and Xu (2015). It provides a controlled test of the benefit of explicit syntax in a semantic parser. Syntax-only: all semantic transitions in M, the semantic stack M , and the semantic composition function gm are discarded. S-SHIFT and S-RIGHT now move the item from the front of the buffer to the syntactic stack, instead of copying. The set of constraints on the transitions is again a subset of the full set of constraints. This model is an arc-eager variant of Dyer et al. (2015), and serves to check whether semantic parsing degrades syntactic performance. For 1.5% of English sentences in the CoNLL 2009 English dataset, the transition sequence incorrectly encodes the goldstandard joint parse; details in Henderson et al. (2013).", "startOffset": 72, "endOffset": 841}, {"referenceID": 15, "context": "1 Henderson et al. (2008) 87.", "startOffset": 2, "endOffset": 26}, {"referenceID": 15, "context": "1 Henderson et al. (2008) 87.6 73.1 80.5 Johansson (2009) 86.", "startOffset": 2, "endOffset": 58}, {"referenceID": 15, "context": "1 Henderson et al. (2008) 87.6 73.1 80.5 Johansson (2009) 86.6 77.1 81.8 Titov et al. (2009) 87.", "startOffset": 2, "endOffset": 93}, {"referenceID": 15, "context": "1 Henderson et al. (2008) 87.6 73.1 80.5 Johansson (2009) 86.6 77.1 81.8 Titov et al. (2009) 87.5 76.1 81.8 CoNLL 2008 best: #3: Zhao and Kit (2008) 87.", "startOffset": 2, "endOffset": 149}, {"referenceID": 5, "context": "2 #2: Che et al. (2008) 86.", "startOffset": 6, "endOffset": 24}, {"referenceID": 5, "context": "2 #2: Che et al. (2008) 86.7 78.5 82.7 #2: Ciaramita et al. (2008) 87.", "startOffset": 6, "endOffset": 67}, {"referenceID": 5, "context": "2 #2: Che et al. (2008) 86.7 78.5 82.7 #2: Ciaramita et al. (2008) 87.4 78.0 82.7 #1: J&N (2008) 89.", "startOffset": 6, "endOffset": 97}, {"referenceID": 22, "context": "Several other joint learning models have been proposed (Llu\u0131\u0301s and M\u00e0rquez, 2008; Johansson, 2009; Titov et al., 2009) for the same task; our joint model surpasses the performance of all these models.", "startOffset": 55, "endOffset": 118}, {"referenceID": 40, "context": "Several other joint learning models have been proposed (Llu\u0131\u0301s and M\u00e0rquez, 2008; Johansson, 2009; Titov et al., 2009) for the same task; our joint model surpasses the performance of all these models.", "startOffset": 55, "endOffset": 118}, {"referenceID": 45, "context": "The overall performance of Joint is on par with the other winning participants at the CoNLL 2009 shared task (Zhao et al., 2009; Che et al., 2009; Gesmundo et al., 2009), falling behind only Zhao et al.", "startOffset": 109, "endOffset": 169}, {"referenceID": 6, "context": "The overall performance of Joint is on par with the other winning participants at the CoNLL 2009 shared task (Zhao et al., 2009; Che et al., 2009; Gesmundo et al., 2009), falling behind only Zhao et al.", "startOffset": 109, "endOffset": 169}, {"referenceID": 12, "context": "The overall performance of Joint is on par with the other winning participants at the CoNLL 2009 shared task (Zhao et al., 2009; Che et al., 2009; Gesmundo et al., 2009), falling behind only Zhao et al.", "startOffset": 109, "endOffset": 169}, {"referenceID": 2, "context": "Many of these systems use expert-crafted features derived from full syntactic parses in a pipeline of classifiers followed by a global reranker (Bj\u00f6rkelund et al., 2009; Bj\u00f6rkelund et al., 2010; Roth and Woodsend, 2014); we have not used these features or reranking.", "startOffset": 144, "endOffset": 219}, {"referenceID": 3, "context": "Many of these systems use expert-crafted features derived from full syntactic parses in a pipeline of classifiers followed by a global reranker (Bj\u00f6rkelund et al., 2009; Bj\u00f6rkelund et al., 2010; Roth and Woodsend, 2014); we have not used these features or reranking.", "startOffset": 144, "endOffset": 219}, {"referenceID": 11, "context": "5 Results and Discussion CoNLL 2008 (Table 2) Our joint model significantly outperforms the joint model of Henderson et al. (2008), from which our set of transitions is derived, showing the benefit of learning a representation for the entire algorithmic state.", "startOffset": 107, "endOffset": 131}, {"referenceID": 11, "context": "5 Results and Discussion CoNLL 2008 (Table 2) Our joint model significantly outperforms the joint model of Henderson et al. (2008), from which our set of transitions is derived, showing the benefit of learning a representation for the entire algorithmic state. Several other joint learning models have been proposed (Llu\u0131\u0301s and M\u00e0rquez, 2008; Johansson, 2009; Titov et al., 2009) for the same task; our joint model surpasses the performance of all these models. The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al.", "startOffset": 107, "endOffset": 550}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al.", "startOffset": 89, "endOffset": 107}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these.", "startOffset": 89, "endOffset": 132}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these.", "startOffset": 89, "endOffset": 156}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these. We fall behind only Johansson and Nugues (2008), whose success was attributed to carefully designed global SRL features integrated into a pipeline of classifiers, making them asymptotically slower.", "startOffset": 89, "endOffset": 319}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these. We fall behind only Johansson and Nugues (2008), whose success was attributed to carefully designed global SRL features integrated into a pipeline of classifiers, making them asymptotically slower. CoNLL 2009 English (Table 3) All of our models (Syntax-only, Semantics-only, Hybrid and Joint) improve over Gesmundo et al. (2009) and Henderson et al.", "startOffset": 89, "endOffset": 600}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these. We fall behind only Johansson and Nugues (2008), whose success was attributed to carefully designed global SRL features integrated into a pipeline of classifiers, making them asymptotically slower. CoNLL 2009 English (Table 3) All of our models (Syntax-only, Semantics-only, Hybrid and Joint) improve over Gesmundo et al. (2009) and Henderson et al. (2013), demonstrating the benefit of our entire-parser-state representation learner compared to the more locally scoped model.", "startOffset": 89, "endOffset": 628}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these. We fall behind only Johansson and Nugues (2008), whose success was attributed to carefully designed global SRL features integrated into a pipeline of classifiers, making them asymptotically slower. CoNLL 2009 English (Table 3) All of our models (Syntax-only, Semantics-only, Hybrid and Joint) improve over Gesmundo et al. (2009) and Henderson et al. (2013), demonstrating the benefit of our entire-parser-state representation learner compared to the more locally scoped model. Given that syntax has consistently proven useful in SRL, we expected our Semantics-only model to underperform Hybrid and Joint, and it did. In the training domain, syntax and semantics benefit each other (Joint outperforms Hybrid). Out-of-domain (the Brown test set), the Hybrid pulls ahead, a sign that Joint overfits to WSJ. As a syntactic parser, our Syntax-only model performs slightly better than Dyer et al. (2015), who achieve 89.", "startOffset": 89, "endOffset": 1169}, {"referenceID": 3, "context": "The best reported systems on the CoNLL 2008 task are due to Johansson and Nugues (2008), Che et al. (2008), Ciaramita et al. (2008) and Zhao and Kit (2008), all of which pipeline syntax and semantics; our system\u2019s semantic and overall performance is comparable to these. We fall behind only Johansson and Nugues (2008), whose success was attributed to carefully designed global SRL features integrated into a pipeline of classifiers, making them asymptotically slower. CoNLL 2009 English (Table 3) All of our models (Syntax-only, Semantics-only, Hybrid and Joint) improve over Gesmundo et al. (2009) and Henderson et al. (2013), demonstrating the benefit of our entire-parser-state representation learner compared to the more locally scoped model. Given that syntax has consistently proven useful in SRL, we expected our Semantics-only model to underperform Hybrid and Joint, and it did. In the training domain, syntax and semantics benefit each other (Joint outperforms Hybrid). Out-of-domain (the Brown test set), the Hybrid pulls ahead, a sign that Joint overfits to WSJ. As a syntactic parser, our Syntax-only model performs slightly better than Dyer et al. (2015), who achieve 89.56 LAS on this task. Joint parsing is very slightly better still. The overall performance of Joint is on par with the other winning participants at the CoNLL 2009 shared task (Zhao et al., 2009; Che et al., 2009; Gesmundo et al., 2009), falling behind only Zhao et al. (2009), who carefully designed language-specific features and used a series of pipelines for the joint task, resulting in an accurate but computationally expensive system.", "startOffset": 89, "endOffset": 1461}, {"referenceID": 2, "context": "Many of these systems use expert-crafted features derived from full syntactic parses in a pipeline of classifiers followed by a global reranker (Bj\u00f6rkelund et al., 2009; Bj\u00f6rkelund et al., 2010; Roth and Woodsend, 2014); we have not used these features or reranking. Lei et al. (2015) use syntactic parses to obtain interaction features between predicates and their arguments and then compress feature representations using a low-rank tensor.", "startOffset": 145, "endOffset": 285}, {"referenceID": 2, "context": "Many of these systems use expert-crafted features derived from full syntactic parses in a pipeline of classifiers followed by a global reranker (Bj\u00f6rkelund et al., 2009; Bj\u00f6rkelund et al., 2010; Roth and Woodsend, 2014); we have not used these features or reranking. Lei et al. (2015) use syntactic parses to obtain interaction features between predicates and their arguments and then compress feature representations using a low-rank tensor. T\u00e4ckstr\u00f6m et al. (2015) present an exact inference algorithm for SRL based on dynamic programming and their local and", "startOffset": 145, "endOffset": 467}, {"referenceID": 1, "context": "An alternative might be to infer word-internal representations using character-based word embeddings, which was found beneficial for syntactic parsing (Ballesteros et al., 2015).", "startOffset": 151, "endOffset": 177}, {"referenceID": 8, "context": "Their algorithm is adopted by FitzGerald et al. (2015) for inference in a model that jointly learns representations from a combination of PropBank and FrameNet annotations; we have not experimented with extra annotations.", "startOffset": 30, "endOffset": 55}, {"referenceID": 8, "context": "Their algorithm is adopted by FitzGerald et al. (2015) for inference in a model that jointly learns representations from a combination of PropBank and FrameNet annotations; we have not experimented with extra annotations. Our system achieves an end-to-end runtime of 177.6\u00b118 seconds to parse the CoNLL 2009 English test set on a single core. This is almost 2.5 times faster than the pipeline model of Lei et al. (2015) (439.", "startOffset": 30, "endOffset": 420}, {"referenceID": 25, "context": "Llu\u0131\u0301s et al. (2013) propose a graph-based joint model using dual decomposition for agreement between syntax and semantics, but do not achieve competitive performance on the CoNLL 2009 task.", "startOffset": 0, "endOffset": 21}, {"referenceID": 24, "context": "Lewis et al. (2015) proposed an efficient joint model for CCG syntax and SRL, which performs better than a pipelined model.", "startOffset": 0, "endOffset": 20}, {"referenceID": 24, "context": "Lewis et al. (2015) proposed an efficient joint model for CCG syntax and SRL, which performs better than a pipelined model. However, their training necessitates CCG annotation, ours does not. Moreover, their evaluation metric rewards semantic dependencies regardless of where they attach within the argument span given by a PropBank constituent, making direct comparison to our evaluation infeasible. Krishnamurthy and Mitchell (2014) propose a joint CCG parsing and relation extraction model which improves over pipelines, but their task is different from ours.", "startOffset": 0, "endOffset": 435}, {"referenceID": 24, "context": "Lewis et al. (2015) proposed an efficient joint model for CCG syntax and SRL, which performs better than a pipelined model. However, their training necessitates CCG annotation, ours does not. Moreover, their evaluation metric rewards semantic dependencies regardless of where they attach within the argument span given by a PropBank constituent, making direct comparison to our evaluation infeasible. Krishnamurthy and Mitchell (2014) propose a joint CCG parsing and relation extraction model which improves over pipelines, but their task is different from ours. Li et al. (2010) also perform joint syntactic and semantic dependency parsing for Chinese, but do not report results on the CoNLL 2009 dataset.", "startOffset": 0, "endOffset": 580}, {"referenceID": 8, "context": "Collobert et al. (2011) proposed models which perform many NLP tasks without hand-crafted features.", "startOffset": 0, "endOffset": 24}, {"referenceID": 8, "context": "Collobert et al. (2011) proposed models which perform many NLP tasks without hand-crafted features. Though they did not achieve the best results on the constituent-based SRL task (Carreras and M\u00e0rquez, 2005), their approach inspired Zhou and Xu (2015), who achieved state-of-the-art results using deep bidirectional LSTMs.", "startOffset": 0, "endOffset": 252}], "year": 2016, "abstractText": "We present a transition-based parser that jointly produces syntactic and semantic dependencies. It learns a representation of the entire algorithm state, using stack long short-term memories. Our greedy inference algorithm has linear time, including feature extraction. On the CoNLL 2008\u20139 English shared tasks, we obtain the best published parsing performance among models that jointly learn syntax and semantics.", "creator": "LaTeX with hyperref package"}}}