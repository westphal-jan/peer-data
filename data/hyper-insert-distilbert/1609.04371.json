{"id": "1609.04371", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Sep-2016", "title": "Finite LTL Synthesis is EXPTIME-complete", "abstract": "in ltl synthesis - - the incomplete construction function of suitable a machine function to satisfy a logical approximation specification formulated in defining linear orthogonal temporal logic - - sri is developing a 2exptime - complete problem with certain relevant paradigm applications in human controller or synthesis departments and a myriad of computational artificial intelligence applications. certainly in demonstrating this research note about we consider de giacomo lopez and nicolas vardi'90 s experimental variant of designing the synthesis turing problem for ltl formulas strictly interpreted together over finite rather squares than infinite length traces. rather of surprisingly, given now the overlapping existing claims focused on complexity, instead we establish that ltl logic synthesis is exptime - complete for the full finite interpretation, and why not 2exptime - comprehension complete as previously reported. our result coincides nicely correlated with preceding the goal planning perspective where non - euclidean deterministic planning with full observability is exptime - complete and a partial gross observability increases among the cognitive complexity contrary to the 2exptime - complete ; for a useful recent related result for ltl word synthesis both shows illustrates that in demonstrating the finite case with superior partial observability, the problem is strictly 2exptime - absolute complete.", "histories": [["v1", "Wed, 14 Sep 2016 18:23:25 GMT  (53kb,D)", "http://arxiv.org/abs/1609.04371v1", null], ["v2", "Thu, 17 Nov 2016 14:12:45 GMT  (0kb,I)", "http://arxiv.org/abs/1609.04371v2", "We withdraw this paper because of an error in the proof"]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["jorge a baier", "alberto camacho", "christian muise", "sheila a mcilraith"], "accepted": false, "id": "1609.04371"}, "pdf": {"name": "1609.04371.pdf", "metadata": {"source": "CRF", "title": "Finite LTL Synthesis is EXPTIME-complete", "authors": ["Jorge A. Baier", "Alberto Camacho", "Christian Muise", "Sheila A. McIlraith"], "emails": ["jabaier@ing.puc.cl", "acamacho@cs.toronto.edu", "cjmuise@mit.edu", "sheila@cs.toronto.edu"], "sections": [{"heading": null, "text": "LTL synthesis \u2013 the construction of a function to satisfy a logical specification formulated in Linear Temporal Logic \u2013 is a 2EXPTIME-complete problem with relevant applications in controller synthesis and a myriad of artificial intelligence applications. In this research note we consider De Giacomo and Vardi\u2019s variant of the synthesis problem for LTL formulas interpreted over finite rather than infinite traces. Rather surprisingly, given the existing claims on complexity, we establish that LTL synthesis is EXPTIME-complete for the finite interpretation, and not 2EXPTIME-complete as previously reported. Our result coincides nicely with the planning perspective where non-deterministic planning with full observability is EXPTIME-complete and partial observability increases the complexity to 2EXPTIME-complete; a recent related result for LTL synthesis shows that in the finite case with partial observability, the problem is 2EXPTIME-complete."}, {"heading": "1. Introduction", "text": "Church\u2019s synthesis problem, a classical problem in computer science, calls for the automatic construction of a procedure which, given a logical specification \u03d5(I,O) between input strings I and output strings O, determines whether there exists an operator F that implements the specification such that \u03d5(I, F (I)) holds for all inputs I. It was first posed\nEmail addresses: jabaier@ing.puc.cl (Jorge A. Baier), acamacho@cs.toronto.edu (Alberto Camacho), cjmuise@mit.edu (Christian Muise), sheila@cs.toronto.edu (Sheila A. McIlraith)\nUnder review for publication\nar X\niv :1\n60 9.\n04 37\n1v 1\n[ cs\n.L O\nby Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3]. Bu\u0308chi and Landweber first solved the problem in 1969 [4]. Soon after, Rabin proposed a solution exploiting automata on infinite trees [5]. In the years that have followed, two common approaches to solving the problem have emerged: reducing the problem to the emptiness problem of tree automata, and characterizing the problem in terms of a two-player game.\nIn 1989, Pnueli and Rosner examined the problem of reactive synthesis using Linear Temporal Logic (LTL) [6] as the specification language, viewing the problem as a two-player game, and showing that this problem was 2EXPTIME-complete [7]. Pnueli and Rosner\u2019s approach required two translations, first from the LTL formula, \u03d5, to a Bu\u0308chi automaton, B\u03d5, and then determinization of B\u03d5 to a deterministic Rabin automaton. This double translation gives the procedure its worst case double exponential complexity in the size of \u03d5. The subsequent game over the Rabin automata can be solved in nk, where n is the number of states of the automaton and k is the number of accepting pairs.\nOver the years, this discouraging result has been mitigated by the identification of several restricted classes of LTL for which the complexity of the synthesis problem need not be so high. For example, in 1998 Asarin, Maler, Pnueli and Sifakis presented efficient polynomial (N2) solutions to games, and therefore synthesis problems, where the acceptance condition was restricted to an LTL formula of the form p, q, p or q. In 2004, Alur and La Torre also identified what they argued to be a compelling fragment of LTL that restricts to Boolean combinations of either (,\u2227) or (,\u2227,\u2228), proving that the synthesis problem was PSPACE-complete or EXPSPACE, respectively, utilizing a parameterization in terms of the so-called longest distance (length of the longest simple path in the Bu\u0308chi automaton) [8]. Further, in 2006, Piterman, Pnueli, and Sa\u2019ar examined the synthesis of reactive designs when the LTL specification was restricted to the class of so-called Generalized Reactivity(1) (GR1) formulae, presenting an N3-time algorithm which checks whether the formula is realizable, and in the case where it is, constructs an automaton representing one of the possible implementing circuits [3].\nIn this paper, we identify another important and rich class of LTL formulae for which the synthesis problem does not require a double exponential solution. In particular, we show that when the specification, \u03d5, is restricted to formulae expressed in LTL interpreted over finite traces, so-called finite LTL or LTLf , the synthesis problem is EXPTIME-complete. The notion of interpreting LTL over finite traces dates back at least 20 years to its use expressing domain control knowledge or temporally extended goals and preferences in artificial intelligence (AI) automated plan generation tasks. Various techniques for generating plans with finite LTL goals have been developed for actions with deterministic effects (e.g., [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.g., [15]). Finite LTL generally exploits a weak-next operator () and often includes a special modality to designate the final state of the finite trace, distinguishing its syntax and expressivity from LTL interpreted over infinite traces (e.g., [16, 17, 18]). Finite LTL supports the specification\nof an important classes of planning and synthesis problems. The majority of automated planning applications require solutions that are finite, such as a plan for a fleet of trucks to deliver a set of packages. Similarly, the class of synthesis problems for which solutions are finite is large, including a myriad of tasks from component robot skills or terminating software activities such as web services and the processing of business transactions (e.g., [19, 20]). Indeed, LTLf is used extensively in business process specifications [21].\nIn 2015, De Giacomo and Vardi investigated synthesis from LTL specifications interpreted over finite traces, characterizing the problem computationally as 2EXPTIMEcomplete and presenting a sound and complete synthesis technique based on Deterministic Finite Automata (reachability) games. This paper shows that synthesis from LTL specifications interpreted over finite traces is EXPTIME-complete. Similar in spirit to the work of Asarin et al., Alur and La Torre, and Piterman et al., this result is important not only for clarifying the complexity of the finite LTL synthesis task, but also because it identifies another rich fragment of LTL for which synthesis avoids the discouraging double exponential originally described by Pnueli and Rosner.\nThe paper proceeds as follows. First, we provide necessary background on alternating Turing machines and finite LTL, LTLf . Next, we briefly describe a technique by the Torres and Baier\u2019s for translating LTLf into alternating automata that has been used in support of automated plan generation with LTLf temporally extended goals [22]. In the next section we introduce the problem of LTLf synthesis, and present the central contribution of this paper: a proof that LTLf synthesis is EXPTIME-complete. The proof is based on two lemmas. In Lemma 1, we show that LTLf synthesis is in EXPTIME by means of an algorithm, inspired in Torres and Baier\u2019s alternating automata compilation, that shows that LTLf synthesis can be solved using alternating Turing machines in polynomial space. In Lemma 2, we show that LTLf synthesis is EXPTIME-hard. The technique we use transforms an alternating Turing machine into LTLf synthesis, and gains some inspiration from methods used by Rintanen to prove the complexity of non-deterministic planning with full and partial observability [23]."}, {"heading": "2. Preliminaries", "text": "In this section we review alternating Turing machines and LTLf . We also overview a technique for translating LTLf into alternating automata. These concepts are necessary for the proofs that follow. The reader familiar with some or all of these topics can safely skip the corresponding subsections."}, {"heading": "2.1. Alternating Turing Machines", "text": "Alternating Turing Machines (ATMs) where introduced by Chandra et al. (1981). Throughout the paper, we use a variant of the original definition, and follow the notation that has been used by Rintanen (2004).\nDefinition 1 (Alternating Turing Machine) An Alternating Turing Machine (ATM) is a tuple \u3008\u03a3, Q, q0, g\u3009 where:\n\u2022 \u03a3 is a finite alphabet\n\u2022 Q is a finite set of internal states\n\u2022 \u03b4 : \u03a3 \u222a {|, } \u00d7 Q \u2192 2\u03a3\u222a{|}\u00d7Q\u00d7{L,N,R} is a transition function, where | and are, respectively, the end-of-tape and blank symbols. Additionally, we require:\n\u2013 s\u2032 = | and m = R for all \u3008s\u2032, q\u2032,m\u3009 \u2208 \u03b4(|, q) \u2013 s\u2032 \u2208 \u03a3 for all \u3008s\u2032, q\u2032,m\u3009 \u2208 \u03b4(s, q) where s \u2208 \u03a3\n\u2022 q0 \u2208 Q is the initial internal state\n\u2022 g : Q \u2192 {accept , reject ,\u2203, \u2200} is a labeling function. States q \u2208 Q with g(q) = \u2200 are called universal, whereas states with g(q) = \u2203 are called existential.\nA configuration of an ATM A is defined by the content of its tape cells, its internal state, and the position of the R/W head over the tape cells (see Definition 2). In the initial configuration, the R/W head is positioned over the second tape cell. The first tape cell has an end-of-tape symbol, and the following cells have, in order, the value of the elements in the input string \u03c3. The remaining cells of the tape are assumed to be blank ( ).\nFor a given configuration C of an ATM A, each element \u3008s\u2032, q\u2032,m\u3009 in \u03b4(q, s) identifies a successor configuration. Intuitively, the content of the tape cell under the R/W head is updated to s\u2032. The internal state of A switches to q\u2032, and m describes the movement of the R/W head \u2013 which moves either one cell right, left, or stays in the same position (see Definition 3).\nDefinition 2 (Configuration of an ATM) A configuration of an ATM A = \u3008\u03a3, Q, q0, g\u3009 is a tuple \u3008q, \u03c3l, \u03c3r\u3009 where q \u2208 Q is the current state of A, \u03c3l is a word containing the tape cells to the left head, including the symbol under the head, \u03c3r is a word describing the contents of the tape to the right of the head. Elements in \u03c3l and \u03c3r have values in \u03a3 \u222a {|, }. For an input string \u03c3 = s0, s1, . . . , sn, the initial configuration of A is \u3008q0, |s0, s1 . . . sn\u3009.\nDefinition 3 (Successor Configurations of an ATM) For a configuration C of an ATM A = \u3008\u03a3, Q, q0, g\u3009, the set of successor configurations is the smallest set that has the following elements:\n\u2022 \u3008q\u2032, \u03c3, s\u2032\u03c3\u2032\u3009 if \u3008s\u2032, q\u2032, L\u3009 \u2208 \u03b4(s, q) and C = \u3008q, \u03c3s, \u03c3\u2032\u3009\n\u2022 \u3008q\u2032, \u03c3s\u2032, \u03c3\u2032\u3009 if \u3008s\u2032, q\u2032, N\u3009 \u2208 \u03b4(s, q) and C = \u3008q, \u03c3s, \u03c3\u2032\u3009\n\u2022 \u3008q\u2032, \u03c3s\u2032t, \u03c3\u2032\u3009 if \u3008s\u2032, q\u2032, R\u3009 \u2208 \u03b4(s, q) and C = \u3008q, \u03c3s, t\u03c3\u2032\u3009\n\u2022 \u3008q\u2032, \u03c3s\u2032 , \u03c3\u2032\u3009 if \u3008s\u2032, q\u2032, R\u3009 \u2208 \u03b4(s, q), C = \u3008q, \u03c3s, \u03c3\u2032\u3009, and |\u03c3\u2032| = 0\nA configuration \u3008q, \u03c3l, \u03c3r\u3009 of n ATM A = \u3008\u03a3, Q, q0\u3009 is final if g(q) \u2208 {accept , reject}. The acceptance of a string \u03c3 by A is defined inductively as follows. A final configuration is 0-accepting if g(q) = accept . A non-final configuration is n-accepting, for n > 0, if one of these conditions hold: (1) g(q) = \u2200, at least one successor configuration is (n\u22121)-accepting, and all other successor configurations are m-accepting for some m < n; or (2) g(q) = \u2203, at least one successor configuration is (n\u22121)-accepting, and no other successor configurations are m-accepting for any m < n \u2212 1. A configuration is accepting if it is n-accepting for some n \u2265 0. In particular, we say that A accepts string \u03c3 if the initial configuration is accepting.\nDefinition 4 (Computation Subtrees) The computation subtree of an ATM A = \u3008\u03a3, Q, q0, g\u3009 is the set T of accepting configurations defined recursively as follows:\n\u2022 \u3008q0, \u03c3\u3009 \u2208 T , i.e., T contains the initial configuration of the ATM\n\u2022 If \u3008q, \u03c3\u2032\u3009 \u2208 T and g(q) = \u2200, then all successor configurations of \u3008q, \u03c3\u2032\u3009 are in T\n\u2022 If \u3008q, \u03c3\u2032\u3009 \u2208 T , q is existential, and \u3008q, \u03c3\u2032\u3009 is n-accepting, then there exists at least one successor configuration of \u3008q, \u03c3\u2032\u3009 that is in T and is m-accepting for some m < n.\nA Deterministic Turing Machine (DTM) is an ATM without universal states, and such that |\u03b4(q, s)| = 1 for all q \u2208 Q and s \u2208 \u03a3\u222a{|}. EXPTIME is the class of decision problems that can be solved by DTMs that use a number of tape cells bounded by an exponential on the input length n. APSPACE is the class of decision problems that can be solved by ATMs that use a number of tape cells bounded by a polynomial on the input length n. It is well-known that EXPTIME = APSPACE [24].\n2.2. Finite LTL\nFinite LTL, or LTLf , is a variant of LTL interpreted over finite traces. The syntax of finite LTL differs only slightly from standard LTL, save the addition of a \u201cweak next\u201d operator (). The definition follows.\nDefinition 5 (LTLf formulas) The set of LTLf formulas over a set of propositions P, LTLf(P), is inductively defined as follows:\n\u2022 >, \u22a5, and p are in LTLf(P), for every p \u2208 P.\n\u2022 If \u03d5 and \u03c8 are in LTLf(P) then so are \u00ac\u03d5, (\u03d5 \u2227 \u03c8), (\u03d5 \u2228 \u03c8), \u03d5, \u03d5, (\u03d5U\u03c8), and (\u03d5R\u03c8).\nThe standard LTL operators eventually () and always () are defined as macros \u03d5 \u2261 (>U\u03d5) and \u03d5 \u2261 (\u22a5R\u03d5). As usual, > evaluates to true and \u22a5 evaluates to false.\nDefinition 6 (Subformulas of an LTLf Formula) Given a formula \u03d5 over a set of propositions P, we define the set of subformulae of \u03d5, denoted sub(\u03d5), inductively as follows.\n1. If \u03d5 is a proposition in P, then sub(\u03d5) = {\u03d5}. 2. If \u03d5 = ?\u03c8, where ? is a unary connective in {\u00ac,,}, then sub(\u03d5) = {\u03d5}\u222a sub(\u03c8). 3. If \u03d5 = (\u03c8 \u2217 \u03c7) where \u2217 is any binary connective in {\u2227,\u2228,U,R} then sub(\u03d5) = {\u03d5} \u222a sub(\u03c8) \u222a sub(\u03c7).\nFinally, the size of a formula \u03d5, denoted by |\u03d5|, is defined as the number of connectives in \u03d5 plus the number of atomic formulas in \u03d5; thus the size of (p \u2228 \u00acp) is 4.\nProposition 1 The cardinality of sub(\u03d5) is at most |\u03d5|.\nProof: By induction on the construction of \u03d5. The base case, that is, \u03d5 is a propositional variable, is straightforward. For the induction, if \u03d5 = ?\u03c8, for a unary connective ?, we observe that |sub(\u03d5)| \u2264 1 + |sub(\u03c8)|, from where the results follows immediately by using the inductive hypothesis. The proof for binary connectives is analogous. If \u03d5 = (\u03c8 ? \u03c7), then |sub(\u03d5)| \u2264 1 + |sub(\u03c8)|+ |sub(\u03c7)|. In both cases, |sub(\u03d5)| \u2264 |\u03d5|.\nThe truth of an LTLf formula over P is evaluated over a finite word of states, where each state is an element over alphabet 2P .\nDefinition 7 Given a finite word of states \u03c3 = s0 . . . sn, and a formula \u03d5 \u2208 LTLf(P), we say that \u03c3 satisfies \u03d5, denoted as \u03c3 |= \u03d5, iff it holds that \u03c3, 0 |= \u03d5, where, for every i \u2208 {0, . . . , n}:\n1. \u03c3, i |= >. 2. \u03c3, i |= p iff p \u2208 si, when p \u2208 P. 3. \u03c3, i |= \u00ac\u03d5 iff \u03c3, i 6|= \u03d5 4. \u03c3, i |= (\u03c8 \u2227 \u03c7) iff \u03c3, i |= \u03c8 and \u03c3, i |= \u03c7 5. \u03c3, i |= (\u03c8 \u2228 \u03c7) iff \u03c3, i |= \u03c8 or \u03c3, i |= \u03c7 6. \u03c3, i |= \u03c8 iff i < n and \u03c3, (i+ 1) |= \u03c8 7. \u03c3, i |= \u03c8 iff i = n or \u03c3, (i+ 1) |= \u03c8 8. \u03c3, i |= (\u03c8U\u03c7) iff there exists k \u2208 {i, ..., n} such that \u03c3, k |= \u03c7 and for each j \u2208 {i, ..., k \u2212 1}, it holds that \u03c3, j |= \u03c8 9. \u03c3, i |= (\u03c8 R\u03c7) iff for each k \u2208 {i, ..., n} it holds that \u03c3, k |= \u03c7 or there exists a j \u2208 {i, ..., k \u2212 1} such that \u03c3, j |= \u03c8\n2.3. An Alternating Automaton for LTLf\nWe present Torres and Baier\u2019s construction of alternating automata from LTLf formulae [22]. Given an LTLf formula \u03d5, this construction defines an alternating automaton A\u03d5 that accepts precisely the models of \u03d5. We commence with some definitions and then present the construction."}, {"heading": "2.3.1. Alternating Automata", "text": "Definition 8 (Positive Boolean Formula) The set of positive formulae over a set of propositions P\u2014denoted by B+(P)\u2014is the set of all Boolean formulae over P and constants \u22a5 and > that do not use the connective \u201c\u00ac\u201d.\nDefinition 9 (Alternating Automata) An alternating automata (AA) over words is a tuple A = (Q,\u03a3, \u03b4, I,F), where Q is a finite set of states, the alphabet \u03a3 is a finite set of symbols, \u03b4 : Q \u00d7 \u03a3 \u2192 B+(Q) is the transition function, I \u2286 Q are the initial states, and F \u2286 Q is a set of final states.\nFor a set of states Q\u2032 \u2286 Q, we define \u03b4(Q\u2032, s) def= \u2227 q\u2208Q\u2032 \u03b4(q, s). In what follows, a word\nis an ordered finite sequence x1, x2, . . . , xn of symbols in \u03a3.\nDefinition 10 (Run of an AA over a Finite String) A run of an AA A = (Q,\u03a3, \u03b4, I,F) over word x1x2 . . . xn is a sequence Q0Q1 . . . Qn of subsets of Q, where Q0 = I, and Qi |= \u03b4(Qi\u22121, xi), for every i \u2208 {1, . . . , n}.\nDefinition 11 A word w is accepted by an AA, A, iff there is a run Q0 . . . Qn of A over w such that Qn \u2286 F .\nFor example, if the definition of an AA, A, is such that \u03b4(q, b) = (s\u2227t)\u2228r, and I = {q}, then both {q}{s, t} and {q}{r} are runs of A over word b."}, {"heading": "2.3.2. Torres and Baier\u2019s Automaton", "text": "Given a formula \u03c8 in LTLf(P), the first step is to convert it into an equivalent formula, \u03d5, in negation normal form (NNF). NNF is a form in which negations, if any, are applied only over propositional variables. This can be done in linear time by applying successively the substitutions given by \u00ac(\u03b1 \u2227 \u03b2) \u2261 (\u00ac\u03b1 \u2228 \u00ac\u03b2), \u00ac(\u03b1 \u2228 \u03b2) \u2261 (\u00ac\u03b1 \u2227 \u00ac\u03b2), \u00ac\u03b1 \u2261 \u00ac\u03b1, \u00ac(\u03b1U\u03b2) \u2261 (\u00ac\u03b1R\u00ac\u03b2), \u00ac\u03b1 \u2261 \u00ac\u03b1. Henceforth we assume that all LTL formulae are in NNF.\nFor a formula \u03d5 Torres and Baier\u2019s automaton is a tuple A\u03d5 = (Q, 2 P , \u03b4, q\u03d5, {qF }),\nwhere Q = {\u03b1 | \u03b1 \u2208 sub(\u03d5)} \u222a {qF } and:\n\u03b4(`, s) = { >, if ` is a literal over P and s |= ` \u22a5, if ` is a literal over P and s 6|= `\n\u03b4(qF , s) = \u22a5 \u03b4(\u03b1 \u2228 \u03b2, s) = \u03b4(\u03b1, s) \u2228 \u03b4(\u03b2, s) \u03b4(\u03b1 \u2227 \u03b2, s) = \u03b4(\u03b1, s) \u2227 \u03b4(\u03b2, s) \u03b4(\u03b1, s) = \u03b1\n\u03b4(\u03b1, s) = qF \u2228 \u03b1 \u03b4(\u03b1U\u03b2, s) = \u03b4(\u03b2, s) \u2228 (\u03b4(\u03b1, s) \u2227 \u03b1U\u03b2) \u03b4(\u03b1R\u03b2, s) = \u03b4(\u03b2, s) \u2227 (qF \u2228 \u03b4(\u03b1, s) \u2228 \u03b1R\u03b2)\nThis AA is based on Muller et al.\u2019s AA for infinite [25]. Unlike theirs, this AA has a state qF , which, besides from being a final state, has the intuitive meaning of \u201cforcing the input to finish now\u201d. Indeed, when the automaton is in qF , processing any input symbol gets the automaton into a rejection configuration.\nTheorem 1 (Correctness of A\u03d5 [22]) \u03c3 |= \u03d5 iff A\u03d5 accepts \u03c3.\n3. LTLf Synthesis\nLTL synthesis is a 2EXPTIME-complete problem. In this section, we introduce the problem of LTLf synthesis. The community has assumed that LTLf synthesis was a 2EXPTIMEcomplete problem [21]. We prove that, contrary to the common thought, LTLf synthesis is an EXPTIME-hard problem.\nDefinition 12 (LTLf Realizability) Given two disjoint sets of variables X and Y, and a formula \u03d5 over LTLf(X \u222a Y), we say that \u03d5 is realizable iff there exists a function f : (2X )\u2217 \u2192 2Y such that for every infinite word X1X2 . . . over subsets of X , there exists a natural n such that when \u03c0 = (X1 \u222a f(X1))(X2 \u222a f(X2X1)) . . . (Xn \u222a f(XnXn\u22121 . . . X1)), it holds that \u03c0 |= \u03d5.\nLemma 1 LTLf realizability is in EXPTIME.\nProof: Algorithm 1 defines an alternating, non-deterministic procedure where Realizable({\u03d5}) accepts iff \u03d5 is realizable. Moreover, as we show below, it requires memory that is linear in |\u03d5|. This proves that the problem is in APSPACE, the class of problems that can be decided with an ATM that requires polynomial space on its input. In addition, because APSPACE=EXPTIME [24], we conclude that LTLf realizability is in EXPTIME.\nAlgorithm 1: An Algorithm for Deciding Realizability 1 procedure Realizable(Q) 2 if Q \u2286 {qF } then 3 accept 4 if qF \u2208 Q then 5 reject 6 forall subsets X of X do 7 guess a subset Y of Y do 8 s\u2190 X \u222a Y 9 Progress(Q, \u2205, s)\n10 procedure Progress(Qold,Qnew, s) 11 if Qold = \u2205 then 12 Realizable(Qnew) 13 Remove a formula \u03d5 from Qold (different from qF ) 14 switch \u03d5 do 15 case \u03d5 is a literal 16 if s 6|= \u03d5 then 17 reject\n18 case \u03d5 is of the form \u03b1 \u2228 \u03b2 19 choose 20 either Progress(Qold \u222a {\u03b1},Qnew, s) 21 or Progress(Qold \u222a {\u03b2},Qnew, s)\n22 case \u03d5 is of the form \u03b1 \u2227 \u03b2 23 Progress(Qold \u222a {\u03b1, \u03b2},Qnew, s) 24 case \u03d5 is of the form \u03b1 25 Progress(Qold,Qnew \u222a {\u03b1}, s) 26 case \u03d5 is of the form \u03b1 27 choose 28 either Progress(Qold,Qnew \u222a {qF }, s) 29 or Progress(Qold,Qnew \u222a {\u03b1}, s)\n30 case \u03d5 is of the form \u03b1U\u03b2 31 choose 32 either Progress(Qold \u222a {\u03b2},Qnew, s) 33 or Progress(Qold \u222a {\u03b1},Qnew \u222a {\u03b1U\u03b2}, s)\n34 case \u03d5 is of the form \u03b1R\u03b2 35 Qold \u2190 Qold \u222a {\u03b2} 36 choose 37 either Progress(Qold,Qnew \u222a {qF }, s) 38 or Progress(Qold \u222a {\u03b1},Qnew, s) 39 or Progress(Qold,Qnew \u222a {\u03b1R\u03b2}, s)\nBefore continuing with the proof, we provide some intuition for both procedures. Let us first denote the set of infinite words over alphabet 2X by W\u221e. The objective of the algorithm is to prove that for every infinite word w = X1X2 . . . \u2208 W\u221e, there exists a finite word Y1Y2 . . . Yn over alphabet 2\nY such that when \u03c0 = (X1\u222aY1)(X2\u222aY2) . . . (XN(w)\u222aYN(w)), where N is a function from W\u221e to the natural numbers, it holds that \u03c0 |= \u03d5. To prove this, via successive calls, the recursive algorithm Realizable attempts to compute an accepting run Q0Q1 . . . QN(w) of the automaton A\u03d5 for each possible w \u2208 W\u221e, by guessing sets Y0Y1 . . . YN(w). In the k-th recursive call, as we prove below, the set of states Q used as the argument for the procedure corresponds to Qk.\nIn each call to Realizable, both variables for X and Y are chosen non-deterministically (Lines 6 and 7). Observe, however, that variables from X are chosen using a universal transition. (In fact, Line 6 is the only universal transition in the algorithm.) Once state s is built, the algorithm invokes procedure Progress.\nProcedure Progress is also a recursive procedure whose objective is to build the next set of states that conforms to a run (that is, it computes Qk+1 given Qk and the (k+ 1)-th symbol of the input string). To do this it uses two arguments: Qold and Qnew. The former set represents the set of states A\u03d5 is in before processing symbol s. The latter is the new set of states. Through multiple iterations, Progress builds Qnew and yields the control back to Realizable when Qold is empty (Line 12).\nNow we argue that the algorithm we propose is correct, that is, it accepts iff \u03d5 is realizable. We start by arguing that Progress is correct. Specifically we prove that if Progress is called in Line 9 with Q as the first argument and s as the third argument, and, after a number of self-recursive calls of Progress, the next call to Realizable in Line 12 is made with argument Q\u2032, then Q\u2032 |= \u03b4(Q, s). This follows from the fact that Progress adds to Qnew precisely the formulae that are added in a branch of a Tableaux proof tree for the formula \u03b4(Q, s). In the successive calls for Progress when Qold is empty, Qnew thus contains a model of the formula \u03b4(Q, s). Observe also that a Progress call never reaches Line 12 and rejects: if the Tableaux proof tree branch would have added \u22a5 to the Tableaux set, it would mean that there is no model for the formula.\nNow we prove that Realizable is correct too, that is, it accepts iff \u03d5 is realizable. For the \u21d2 direction, assume Realizable accepts. Then the accepting run of Realizable can be conceptualized as a finite tree, as shown in Figure 1, which every internal node has one children for each element of 2X . Each of these sets is accompanied by an element of 2Y . Thus each branch of the tree of length n defines words X1X2 . . . Xn and Y1Y2 . . . Yn, respectively in (2X )\u2217 and (2Y)\u2217, together with a sequence Q0Q1 . . . Qn of sets of states of A\u03d5, such that Q0 = {\u03d5} and Qk+1 |= \u03b4(Qk, s), for every k \u2208 {0, . . . , n \u2212 1}, and such that Qn \u2286 {qF }. From the correctness of the automaton, this means that (X1 \u222a Y1)(X2 \u222a Y2) . . . (Xn \u222a Yn) |= \u03d5. Finally, it only remains to define function f : for every path of the tree labeled with (X1, Y1)(X2, Y2) . . . (Xm, Ym), we define f(Xm . . . X1) = Ym. This proves that \u03d5 is realizable since for every infinite word wX in 2\nX there is a branch in the tree that defines a (finite) prefix of wX .\nFor the \u21d0 direction, recall we denote the set of infinite words over alphabet 2X as W\u221e. Because \u03d5 is realizable, for each w = X1X2 . . . in W\u221e there exists a finite word Y1 . . . YN(w) in (2\nY)\u2217 such that (X1 \u222a Y1) . . . (XN(w) \u222a YN(w)) |= \u03d5, where N is a function from words inW\u221e to the natural numbers. This means that to prove realizability, we only need to check a (finite) number of finite words rather than over all words in W\u221e; in fact, we need to check at most all words in (2X )\u2217 whose size is bounded by maxw\u2208W\u221e N(w). In other words, this means that for each infinite word w in W\u221e, there is a prefix of w that is sufficient to characterize all words in W\u221e that share the same prefix. Then it is clear that if one can provide a finite proof for realizability, it is possible to represent this proof as a finite tree, analogous to the one shown Figure 1. This means that Realizable({\u03d5}) will accept.\nWe have proven that Realizable({\u03d5}) accepts iff \u03d5 is realizable. Now it remains to prove that a call to Realizable({\u03d5}) requires only polynomial memory on |\u03d5|. Clearly, all operations in the Progress procedure require polynomial space. To see this, observe that the cardinality of bothQold andQnew is at most |sub(\u03d5)|+1. This implies that Realizable requires memory linear in \u03d5 to store its Q argument. Moreover, the other operations in Realizable, namely the forall and guess can be implemented in polynomial space by choosing, in sequence, whether or not each variable is included in the set X.\nWe conclude that LTLf realizability can be decided in APSPACE and thus that it is in EXPTIME.\nLemma 2 LTLf realizability is EXPTIME-hard.\nProof: We show that LTLf synthesis is at least as hard as the problem of deciding plan existence in ATMs with a polynomial space bound p(x) on the size of the input string. We do so by introducing a polynomial time transformation, similar to the one used by Rintanen to prove that non-deterministic planning with partial observability is 2EXPTIME-hard [23].\nFirst, we describe the transformation from a given ATM A = \u3008\u03a3, Q, \u03b4, q0, g\u3009 with input string \u03c3 = s1, . . . , sn \u2013 therefore, space bound p(n) \u2013 to an LTLf synthesis specification. Finally, we show that accepting ATM computation trees correspond one-to-one with solutions to the LTLf synthesis problem.\nControllable Variables The set of controllable variables in the LTLf synthesis problem consists of the following sets:\n\u2022 {vq | q \u2208 Q}, denoting the internal state of the ATM\n\u2022 {vs,i | s \u2208 \u03a3 \u222a {|, } and i \u2208 {0, . . . , p(n)}}, denoting the state of each tape cell\n\u2022 {vi | i \u2208 {0, . . . , p(n) + 1}}, denoting the position of the R/W head\n\u2022 Z = {z1, z2, . . . , z\u2206}, where \u2206 = max{|\u03b4(s, q)| , s.t. s \u2208 \u03a3 \u222a {|, }, q \u2208 Q}\nThe value of these variables simulate the configuration of the ATM. Intuitively, vq is true when the internal state of A is q, vs,i is true when the value in the i-th tape cell is s, and vi is true when the R/W head is over the i-th tape cell. The values of variables in Z are used to uniquely identify one of the successor configurations of the ATM when the internal state is existential.\nUncontrollable Variables The set of uncontrollable variables is X = {x1, x2, . . . , x\u2206}. For convenience, we define the formulae evalX(i, k) as follows:\nevalX(i, k) =  xi \u2227 \u2227 j=1..i\u22121 \u00acxj if i < k\u2227\nj=1..i\u22121 \u00acxj if i = k undefined if i > k\nIntuitively, evalX(i, k) evaluates true when i is the lowest index of the first k variables in X that evaluates true. evalX(k, k) also evaluates true when none of the first k variables in X evaluates true. We will use the truth of these formulae to distinguish one among k possible transitions. For the set of controllable variables Z, evalZ(i, k) is defined analogously. Initial Configuration Let C = \u3008q\u2032, \u03c3l, \u03c3r\u3009 be a configuration of the ATM A, where the internal state is q\u2032, the values in the tape cells are s0, . . . , sp(n), and the R/W head is over sj . We simulate configuration C with the formula:\n\u03d5C = \u2227 VQ \u2227 \u2227 VS \u2227 \u2227 VH (1)\nThe sets of variables that constitute each of the subformulas in \u03d5C are defined as follows:\n\u2022 VQ = {vq\u2032} \u222a {\u00acvq | q \u2208 Q \\ {q\u2032}}\n\u2022 VS = {vs,i | s \u2208 \u03a3 \u222a {|, }, si \u2208 \u03c3\u2032, si = s} \u222a {\u00acvs,i | s \u2208 \u03a3 \u222a {|, }, si \u2208 \u03c3\u2032, si 6= s}\n\u2022 VH = {vj} \u222a {\u00acvi | i \u2208 {0, 1, . . . , p(n) + 1}, i 6= j}\nIn order to simulate the initial configuration of the ATM with input string \u03c3 = s1, . . . , sn, we consider the formula \u03d5C with C = \u3008q0, \u03c3l, \u03c3r\u3009 as follows. The R/W head is placed over s1, so \u03c3l = |s1. The values of the remaining tape cells are \u03c3r = s2 . . . sp(n). Here, we set si = for n < i < p(n) + 1, as the value of the tape cells in positions greater than n are initially blank cells. Note that the value of controllable variables Z is not set.\nGoal Configuration The goal configuration of the ATM is captured in Formula (2), which simulates achievement of an accepting state of the ATM.\n \u2228 q\u2208Q\ng(q)=accept\nvq (2)\nTransitions For all s \u2208 \u03a3 \u222a {|, } and q \u2208 Q, the transition function \u03b4 maps the pair \u3008s, q\u3009 into a set of tuples \u03b4(s, q) = {\u3008s\u20321, q\u20321,m1\u3009, . . . , \u3008s\u2032k, q\u2032k,mk\u3009}, where s\u2032 \u2208 \u03a3\u222a{|}, q\u2032 \u2208 Q, and m \u2208 {L,R,N}. Let \u03b1, \u03ba, and \u03b8 be functions such that, for each \u3008s\u2032\u03c1, q\u2032\u03c1,m\u03c1\u3009 \u2208 \u03b4(s, q), we have s\u2032\u03c1 = \u03b1(s, q, \u03c1), q \u2032 \u03c1 = \u03ba(s, q, \u03c1), and m\u03c1 = \u03b8(s, q, \u03c1) for \u03c1 = 1..|\u03b4(s, q)|, and undefined for \u03c1 > |\u03b4(s, q)|. The successor configurations of the ATM are captured with the families of LTLf formulae described below. Each family of formulae can be viewed as successor state axioms [26], that describe the updates in the value of each variable after each time step. For each q \u2208 Q such that g(q) = \u2203, and each s \u2208 \u03a3 \u222a {|, }:\u2227\nj=1..p(n)+1\n(vs\u2032,j \u2190\u2192 \u2228\ni=1..p(n) i 6=j\n(vs\u2032,j \u2227 vi \u2227 \u00acvj)\u2228\n\u2228 \u03c1=1..|\u03b4(s,q)|\ns s.t. s\u2032=\u03b1(s,q,\u03c1)\n(vs,j \u2227 vj \u2227 vq \u2227 evalZ(\u03c1, |\u03b4(s, q)|))) (3)\n(vq\u2032 \u2190\u2192 \u2228\ni=1..p(n) \u03c1=1..|\u03b4(s,q)|\nq s.t. q\u2032=\u03ba(s,q,\u03c1)\n(vs,i \u2227 vi \u2227 vq \u2227 evalZ(\u03c1, |\u03b4(s, q)|))) (4)\n\u2227 j=1..p(n)+1 (vj \u2190\u2192 \u2228\n\u03c1=1..|\u03b4(s,q)| \u03b8(s,q,\u03c1)=L\ni=j+1,i\u2264p(n)+1\n(vs,i \u2227 vi \u2227 vq \u2227 evalZ(\u03c1, |\u03b4(s, q)|)))\u2228\n\u2228 \u03c1=1..|\u03b4(s,q)| \u03b8(s,q,\u03c1)=R i=j\u22121,i>0 (vs,i \u2227 vi \u2227 vq \u2227 evalZ(\u03c1, |\u03b4(s, q)|)))\u2228\n\u2228 \u03c1=1..|\u03b4(s,q)| \u03b8(s,q,\u03c1)=N\ni=j\n(vs,i \u2227 vi \u2227 vq \u2227 evalZ(\u03c1, |\u03b4(s, q)|)))\n(5)\nFor each q \u2208 Q such that g(q) = \u2200, and each s \u2208 \u03a3 \u222a {|, }:\u2227 j=1..p(n)+1 (vs\u2032,j \u2190\u2192 \u2228\ni=1..p(n) i 6=j\n(vs\u2032,j \u2227 vi \u2227 \u00acvj)\u2228\n\u2228 \u03c1=1..|\u03b4(s,q)|\ns s.t. s\u2032=\u03b1(s,q,\u03c1)\n(vs,j \u2227 vj \u2227 vq \u2227 evalX(\u03c1, |\u03b4(s, q)|))) (6)\n(vq\u2032 \u2190\u2192 \u2228\ni=1..p(n) \u03c1=1..|\u03b4(s,q)|\nq s.t. q\u2032=\u03ba(s,q,\u03c1)\n(vs,i \u2227 vi \u2227 vq \u2227 evalX(\u03c1, |\u03b4(s, q)|))) (7)\n\u2227 j=1..p(n)+1 (vj \u2190\u2192 \u2228\n\u03c1=1..|\u03b4(s,q)| \u03b8(s,q,\u03c1)=L\ni=j+1,i\u2264p(n)+1\n(vs,i \u2227 vi \u2227 vq \u2227 evalX(\u03c1, |\u03b4(s, q)|)))\u2228\n\u2228 \u03c1=1..|\u03b4(s,q)| \u03b8(s,q,\u03c1)=R i=j\u22121,i>0 (vs,i \u2227 vi \u2227 vq \u2227 evalX(\u03c1, |\u03b4(s, q)|)))\u2228\n\u2228 \u03c1=1..|\u03b4(s,q)| \u03b8(s,q,\u03c1)=N\ni=j\n(vs,i \u2227 vi \u2227 vq \u2227 evalX(\u03c1, |\u03b4(s, q)|)))\n(8)\nIntuitively, the family of formulae in (3) simulate the update of the value in the tape cell under the R/W head according to one of the successor configurations of the ATM. Similarly, the family of formulae in (4) simulate the update of the internal state of the ATM. Finally, the family of formulae in (5) simulate the update of the position of the R/W head over the cell tapes of the ATM. In all cases, the selection of a particular successor configuration is simulated by evalZ(s, q), which depends on the value of the variables in Z. The families of Formulae (6), (7), and (8) are analogous. This time, q is an universal state and all successor\nconfigurations of the ATM are plausible and need to be considered. This is simulated by means of evalX(s, q), whose truth value depends on the set of uncontrollable variables X.\nMemory bounds The formulae above simulate the transitions of the ATM, but do not guarantee the memory bounds are preserved. The memory bound is maintained if the R/W head never reaches the position p(n) + 1. We simulate this requirement with the following formula:\n\u00acvp(n)+1 (9)\nFor a configuration C of ATM A, we consider the synthesis problem synth(A, C) whose specification is given by the conjunction of all formulae defined above. In particular, Formula (1) is such that simulates configuration C. Such transformation can be computed in polynomial time. We claim that if the ATM A with input string \u03c3 accepts without violating the space bound, then the associated LTLf synthesis problem also has a solution, and vice-versa.\nThe first implication we prove is, that from a computation tree of a t-accepting configuration C of an ATM A = \u3008\u03a3, Q, \u03b4, q0, g\u3009 we can extract a solution for the LTLf synthesis problem synth(A, C). We prove it via induction on t. If t = 0, then g(q\u20320) = accept and, by construction, the initial state of synth(A,C) is accepting. For the general case, we distinguish two cases:\n\u2022 If g(q\u20320) = \u2203, then let \u3008s\u2032\u03c1, q\u2032\u03c1,m\u03c1\u3009 \u2208 \u03b4(sj , q\u20320) be a transition that leads to a successor configuration in the ATM computation tree that is (t\u2212 1)-accepting. Let Z0 be the assignment of variables in Z that satisfy evalZ(\u03c1, |\u03b4(sj , q\u20320)|). The first assignment to controllable variables in synth(A, C) assigns Z0 to variables in Z. The values of the remaining controllable variables simulate the configuration C of the ATM.\nLet C \u2032 be the successor configuration of C that is associated with transition \u3008s\u2032\u03c1, q\u2032\u03c1,m\u03c1\u3009 \u2208 \u03b4(sj , q \u2032 0). Such configuration is (t\u22121)-accepting and, by inductive hypothesis, we can construct a solution to synth(A, C \u2032). It is easy to see that the assignment to controllable variables defined above, followed by the the solution strategy to synth(A, C \u2032) is a solution to synth(A, C).\n\u2022 If g(q\u20320) = \u2200, then the first assignment to controllable variables in synth(A, C) assigns any value to variables in Z. As in the previous case, the value of the remaining controllable variables simulates the configuration C of the ATM.\nLet C \u2032 be the successor configuration of C that is associated with transition \u3008s\u2032\u03c1, q\u2032\u03c1,m\u03c1\u3009 \u2208 \u03b4(sj , q \u2032 0). Such configuration is t\n\u2032-accepting, for certain t\u2032 < t and, by inductive hypothesis, we can construct a solution to synth(A, C \u2032). As in the previous case, the assignment to controllable variables defined above, followed by the the solution strategy to synth(A, C \u2032) is a solution to synth(A, C).\nFor the other direction, we first prove one of the contrapositives. If the ATM violates the space bounds p(n), then at some point the variable vp(n)+1 has to become true, representing that the R/W head moves to a tape cell position that violates the space bounds. At this point, the Formula (9) is not satisfied.\nIt remains to prove that from a solution to the LTLf synthesis problem synth(A, C0), where C0 is the initial configuration of the ATM A, we can construct a computation tree. This can be done by constructing the tree directly by unfolding a simulation of the LTLf synthesis problem. By construction, assignments to variables in the LTLf problem describe configurations of the ATM. Satisfaction of Formula (2) guarantees that the ATM is accepting.\nWe have shown that deciding whether or not an ATM with a polynomial space bound accepts can be converted to an LTLf synthesis problem in polynomial time. Therefore, existence of solutions to LTLf synthesis is APSPACE-hard or, equivalently, EXPTIMEhard.\nTheorem 2 LTLf realizability is EXPTIME-complete.\nProof: Follows directly from Lemmas 1 and 2."}, {"heading": "4. Conclusion", "text": "In this research note we have presented a proof that the synthesis problem with logical specification represented in LTLf , LTL interpreted over finite traces, is EXPTIME-complete. This result improves upon the 2EXPTIME-complete result reported in [21]. Our complexity result completes the landscape of complexity results that connect LTLf synthesis and non-deterministic planning. With full observability, LTLf synthesis and non-deterministic planning are EXPTIME-complete. With partial observability, LTLf synthesis and nondeterministic planning are 2EXPTIME-complete. This latter result was recently reported in [27].\nOur proofs leverage recent advances from the automated planning community. In particular, the algorithm used to prove EXPTIME membership in Lemma 1 is inspired by recent compilations based on alternating automata [22, 15]. Lemma 2 proves that LTLf synthesis is EXPTIME-hard, with a polynomial transformation of ATMs into LTLf specifications.\nAI automated planning with temporally extended goals specified in LTLf is a practically motivated task of broad interest. The synthesis problem is an extension of plan synthesis where aspects of state are uncontrollable by the agent\u2019s actions, and the synthesized procedure must fulfill the specification regardless of how the uncontrollable aspects of state change. Like it\u2019s automated planning counterpart, LTLf synthesis is well-motivated by myriad finite controller applications. Indeed, conditional planning with an LTLf goal\nis a special case of the synthesis problem that can be realized by LTLf FOND planning algorithms such as those proposed by the authors in related work [15]. The techniques developed in that work provide the computational core for the development of efficient algorithms for the realization of LTLf synthesis \u2013 a topic of current exploration. There is renewed interest to link planning and LTL synthesis, as demonstrated by Sardina and D\u2019Ippolito where non-deterministic planning is modeled as a synthesis problem [28]. Our approach is complementary, as we leverage planning techniques to establish complexity results in synthesis.\nAcknowledgements: The authors gratefully acknowledge funding from Fondecyt (grant number 1150328), and from the Natural Sciences and Engineering Research Council of Canada (NSERC) under the Discovery Grant and Postdoctoral Fellowship programs."}], "references": [{"title": "Applications of recursive arithmetic to the problem of circuit synthesis", "author": ["A. Church"], "venue": "Summaries of the Summer Institute of Symbolic Logic, Cornell University 1957 1 ", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1957}, {"title": "Logic", "author": ["A. Church"], "venue": "arithmetic and automata, in: Proceedings of the international congress of mathematicians, 23\u201335", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1962}, {"title": "Y", "author": ["N. Piterman", "A. Pnueli"], "venue": "Sa\u2019ar, Synthesis of Reactive(1) Designs, in: Verification, Model Checking, and Abstract Interpretation, 7th International Conference, VMCAI 2006, Charleston, SC, USA, January 8-10, 2006, Proceedings, 364\u2013380", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2006}, {"title": "Solving Sequential Conditions by Finite-State Strategies", "author": ["J.R. B\u00fcchi", "L.H. Landweber"], "venue": "Transactions of the American Mathematical Society 138 ", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1969}, {"title": "Automata on Infinite Objects and Church\u2019s Problem", "author": ["M.O. Rabin"], "venue": "American Mathematical Society, Boston, MA, USA", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1972}, {"title": "The temporal logic of programs", "author": ["A. Pnueli"], "venue": "in: Proceedings of the 18th IEEE Symposium on Foundations of Computer Science, 46\u201357", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1977}, {"title": "On the Synthesis of a Reactive Module", "author": ["A. Pnueli", "R. Rosner"], "venue": "in: Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, Austin, Texas, USA, January 11-13, 1989, 179\u2013190", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1989}, {"title": "Deterministic Generators and Games for LTL Fragments", "author": ["R. Alur", "S. La Torre"], "venue": "ACM Trans. Comput. Logic 5 (1) ", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2004}, {"title": "Using temporal logics to express search control knowledge for planning", "author": ["F. Bacchus", "F. Kabanza"], "venue": "Artificial Intelligence 116 (1-2) ", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2000}, {"title": "TALplanner: A Temporal Logic-Based Planner", "author": ["P. Doherty", "J. Kvarnstr\u00f6m"], "venue": "AI Magazine 22 (3) ", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2001}, {"title": "Compilation of LTL Goal Formulas into PDDL", "author": ["S. Cresswell", "A.M. Coddington"], "venue": "in: R. L. de M\u00e1ntaras, L. Saitta (Eds.), Proceedings of the 16th European Conference on Artificial Intelligence, IOS Press, Valencia, Spain, 985\u2013986", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2004}, {"title": "Planning with First-Order Temporally Extended Goals using Heuristic Search", "author": ["J.A. Baier", "S.A. McIlraith"], "venue": "in: Proceedings, The Twenty-First National Conference on Artificial Intelligence and the Eighteenth Innovative Applications of Artificial Intelligence Conference, July 16-20, 2006, Boston, Massachusetts, USA, 788\u2013795", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Planning with Qualitative Temporal Preferences", "author": ["M. Bienvenu", "C. Fritz", "S.A. McIlraith"], "venue": "in: Proceedings of the 10th International Conference on Knowledge Representation and Reasoning, 134\u2013144", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2006}, {"title": "On the Compilation of Plan Constraints and Preferences", "author": ["S. Edelkamp"], "venue": "in: Proceedings of the 16th International Conference on Automated Planning and Scheduling, 374\u2013377", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2006}, {"title": "Non- Deterministic Planning with Temporally Extended Goals: Completing the Story for Finite and Infinite LTL (Amended Version)", "author": ["A. Camacho", "E. Triantafillou", "C.J. Muise", "J.A. Baier", "S.A. McIlraith"], "venue": "in: Proceedings of the Workshop on Knowledge-based Techniques for Problem Solving and Reasoning co-located with 25th International Joint Conference on Artificial Intelligence ", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2016}, {"title": "Deterministic planning in the fifth international planning competition: PDDL3 and experimental evaluation of the planners", "author": ["A. Gerevini", "P. Haslum", "D. Long", "A. Saetti", "Y. Dimopoulos"], "venue": "Artificial Intelligence 173 (5-6) ", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "Linear Temporal Logic and Linear Dynamic Logic on Finite Traces", "author": ["G. De Giacomo", "M.Y. Vardi"], "venue": "in: Proceedings of the 23rd International Joint Conference on Artificial Intelligence, Beijing, China, 854\u2013860", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2013}, {"title": "Reasoning on LTL on Finite Traces: Insensitivity to Infiniteness", "author": ["G. De Giacomo", "R.D. Masellis", "M. Montali"], "venue": "in: Proceedings of the 28th AAAI Conference on Artificial Intelligence, 1027\u20131033", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2014}, {"title": "Semantic Web Services", "author": ["S.A. McIlraith", "T.C. Son", "H. Zeng"], "venue": "IEEE Intelligent Systems 16 (2) ", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2001}, {"title": "Monitoring Business Metaconstraints Based on LTL and LDL for Finite Traces", "author": ["G. De Giacomo", "R. De Masellis", "M. Grasso", "F.M. Maggi", "M. Montali"], "venue": "in: Business Pro- 18  cess Management - 12th International Conference, BPM 2014, Haifa, Israel, September 7-11, 2014. Proceedings, 1\u201317", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2014}, {"title": "Synthesis for LTL and LDL on Finite Traces", "author": ["G. De Giacomo", "M.Y. Vardi"], "venue": "in: Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence, 1558\u20131564", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2015}, {"title": "Polynomial-Time Reformulations of LTL Temporally Extended Goals into Final-State Goals", "author": ["J. Torres", "J.A. Baier"], "venue": "in: Q. Yang, M. Wooldridge (Eds.), International Joint Conference on Artificial Intelligence, AAAI Press, Buenos Aires, Argentina, 1696\u2013 1703", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2015}, {"title": "Complexity of Planning with Partial Observability", "author": ["J. Rintanen"], "venue": "in: Proceedings of the 14th International Conference on Automated Planning and Scheduling, 345\u2013354", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "Alternation", "author": ["A.K. Chandra", "D. Kozen", "L.J. Stockmeyer"], "venue": "Journal of the ACM 28 (1) ", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1981}, {"title": "Weak Alternating Automata Give a Simple Explanation of Why Most Temporal and Dynamic Logics are Decidable in Exponential Time", "author": ["D.E. Muller", "A. Saoudi", "P.E. Schupp"], "venue": "in: Proceedings of the 3rd Annual Symposium on Logic in Computer Science, 422\u2013427", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1988}, {"title": "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems", "author": ["R. Reiter"], "venue": "MIT Press, Cambridge, MA", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2001}, {"title": "LTLf and LDLf Synthesis under Partial Observability", "author": ["G. De Giacomo", "M.Y. Vardi"], "venue": "in: Proceedings of the 25th International Joint Conference on Artificial Intelligence, 1044\u20131050", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2016}, {"title": "N", "author": ["S. Sardina"], "venue": "D\u2019Ippolito, Towards Fully Observable Non-deterministic Planning as Assumption-based Reactive Synthesis, in: Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), 3200\u20133206", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 0, "context": "by Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3].", "startOffset": 95, "endOffset": 101}, {"referenceID": 1, "context": "by Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3].", "startOffset": 95, "endOffset": 101}, {"referenceID": 2, "context": "by Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3].", "startOffset": 177, "endOffset": 180}, {"referenceID": 3, "context": "B\u00fcchi and Landweber first solved the problem in 1969 [4].", "startOffset": 53, "endOffset": 56}, {"referenceID": 4, "context": "Soon after, Rabin proposed a solution exploiting automata on infinite trees [5].", "startOffset": 76, "endOffset": 79}, {"referenceID": 5, "context": "In 1989, Pnueli and Rosner examined the problem of reactive synthesis using Linear Temporal Logic (LTL) [6] as the specification language, viewing the problem as a two-player game, and showing that this problem was 2EXPTIME-complete [7].", "startOffset": 104, "endOffset": 107}, {"referenceID": 6, "context": "In 1989, Pnueli and Rosner examined the problem of reactive synthesis using Linear Temporal Logic (LTL) [6] as the specification language, viewing the problem as a two-player game, and showing that this problem was 2EXPTIME-complete [7].", "startOffset": 233, "endOffset": 236}, {"referenceID": 7, "context": "In 2004, Alur and La Torre also identified what they argued to be a compelling fragment of LTL that restricts to Boolean combinations of either (\ue009,\u2227) or (\ue009,\u2227,\u2228), proving that the synthesis problem was PSPACE-complete or EXPSPACE, respectively, utilizing a parameterization in terms of the so-called longest distance (length of the longest simple path in the B\u00fcchi automaton) [8].", "startOffset": 375, "endOffset": 378}, {"referenceID": 2, "context": "Further, in 2006, Piterman, Pnueli, and Sa\u2019ar examined the synthesis of reactive designs when the LTL specification was restricted to the class of so-called Generalized Reactivity(1) (GR1) formulae, presenting an N3-time algorithm which checks whether the formula is realizable, and in the case where it is, constructs an automaton representing one of the possible implementing circuits [3].", "startOffset": 387, "endOffset": 390}, {"referenceID": 8, "context": ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.", "startOffset": 2, "endOffset": 25}, {"referenceID": 9, "context": ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.", "startOffset": 2, "endOffset": 25}, {"referenceID": 10, "context": ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.", "startOffset": 2, "endOffset": 25}, {"referenceID": 11, "context": ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.", "startOffset": 2, "endOffset": 25}, {"referenceID": 12, "context": ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.", "startOffset": 2, "endOffset": 25}, {"referenceID": 13, "context": ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.", "startOffset": 2, "endOffset": 25}, {"referenceID": 14, "context": ", [15]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 15, "context": ", [16, 17, 18]).", "startOffset": 2, "endOffset": 14}, {"referenceID": 16, "context": ", [16, 17, 18]).", "startOffset": 2, "endOffset": 14}, {"referenceID": 17, "context": ", [16, 17, 18]).", "startOffset": 2, "endOffset": 14}, {"referenceID": 18, "context": ", [19, 20]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 19, "context": ", [19, 20]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 20, "context": "Indeed, LTLf is used extensively in business process specifications [21].", "startOffset": 68, "endOffset": 72}, {"referenceID": 21, "context": "Next, we briefly describe a technique by the Torres and Baier\u2019s for translating LTLf into alternating automata that has been used in support of automated plan generation with LTLf temporally extended goals [22].", "startOffset": 206, "endOffset": 210}, {"referenceID": 22, "context": "The technique we use transforms an alternating Turing machine into LTLf synthesis, and gains some inspiration from methods used by Rintanen to prove the complexity of non-deterministic planning with full and partial observability [23].", "startOffset": 230, "endOffset": 234}, {"referenceID": 23, "context": "It is well-known that EXPTIME = APSPACE [24].", "startOffset": 40, "endOffset": 44}, {"referenceID": 21, "context": "An Alternating Automaton for LTLf We present Torres and Baier\u2019s construction of alternating automata from LTLf formulae [22].", "startOffset": 120, "endOffset": 124}, {"referenceID": 24, "context": "\u2019s AA for infinite [25].", "startOffset": 19, "endOffset": 23}, {"referenceID": 21, "context": "Theorem 1 (Correctness of A\u03c6 [22]) \u03c3 |= \u03c6 iff A\u03c6 accepts \u03c3.", "startOffset": 29, "endOffset": 33}, {"referenceID": 20, "context": "The community has assumed that LTLf synthesis was a 2EXPTIMEcomplete problem [21].", "startOffset": 77, "endOffset": 81}, {"referenceID": 23, "context": "In addition, because APSPACE=EXPTIME [24], we conclude that LTLf realizability is in EXPTIME.", "startOffset": 37, "endOffset": 41}, {"referenceID": 22, "context": "We do so by introducing a polynomial time transformation, similar to the one used by Rintanen to prove that non-deterministic planning with partial observability is 2EXPTIME-hard [23].", "startOffset": 179, "endOffset": 183}, {"referenceID": 25, "context": "Each family of formulae can be viewed as successor state axioms [26], that describe the updates in the value of each variable after each time step.", "startOffset": 64, "endOffset": 68}, {"referenceID": 20, "context": "This result improves upon the 2EXPTIME-complete result reported in [21].", "startOffset": 67, "endOffset": 71}, {"referenceID": 26, "context": "This latter result was recently reported in [27].", "startOffset": 44, "endOffset": 48}, {"referenceID": 21, "context": "In particular, the algorithm used to prove EXPTIME membership in Lemma 1 is inspired by recent compilations based on alternating automata [22, 15].", "startOffset": 138, "endOffset": 146}, {"referenceID": 14, "context": "In particular, the algorithm used to prove EXPTIME membership in Lemma 1 is inspired by recent compilations based on alternating automata [22, 15].", "startOffset": 138, "endOffset": 146}, {"referenceID": 14, "context": "is a special case of the synthesis problem that can be realized by LTLf FOND planning algorithms such as those proposed by the authors in related work [15].", "startOffset": 151, "endOffset": 155}, {"referenceID": 27, "context": "There is renewed interest to link planning and LTL synthesis, as demonstrated by Sardina and D\u2019Ippolito where non-deterministic planning is modeled as a synthesis problem [28].", "startOffset": 171, "endOffset": 175}], "year": 2017, "abstractText": "LTL synthesis \u2013 the construction of a function to satisfy a logical specification formulated in Linear Temporal Logic \u2013 is a 2EXPTIME-complete problem with relevant applications in controller synthesis and a myriad of artificial intelligence applications. In this research note we consider De Giacomo and Vardi\u2019s variant of the synthesis problem for LTL formulas interpreted over finite rather than infinite traces. Rather surprisingly, given the existing claims on complexity, we establish that LTL synthesis is EXPTIME-complete for the finite interpretation, and not 2EXPTIME-complete as previously reported. Our result coincides nicely with the planning perspective where non-deterministic planning with full observability is EXPTIME-complete and partial observability increases the complexity to 2EXPTIME-complete; a recent related result for LTL synthesis shows that in the finite case with partial observability, the problem is 2EXPTIME-complete.", "creator": "LaTeX with hyperref package"}}}