{"id": "1609.05811", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Sep-2016", "title": "Temporal Logic Programs with Variables", "abstract": "in this note we consider the constrained problem concept of effectively introducing variables in temporal logic programs under discussing the spatial formalism of \" temporal equilibrium logic \" ( tn tel ), an extension of answer set intelligent programming ( asp ) specifically for theories dealing with free linear - function time modal rule operators. leading to this aim, naturally we provide a definition of a complete first - order general version of tel models that traditionally shares the syntax rules of restricted first - order linear - time temporal logic ( ltl ) theory but cohen has suggested a different behavioral semantics, specifically selecting some ltl analytic models we formally call \" temporal stable models \". then, perhaps we consider a useful subclass of conditioned theories ( called \" splittable temporal logic programs \" ) that arguably are nominally close to a usual intermediate logic programs but sometimes allowing a strict restricted use logic of predictable temporal operators. in presenting this geometric setting, we provide thus a syntactic static definition function of \" safe variables \" that presently suffices to and show the useful property dependency of \" automatic domain independence \" - - that is, for addition of randomly arbitrary elements in when the universe does not vary the set of temporal stable unstable models. : finally, we thereby present a definitive method for computing out the derivable control facts by either constructing randomly a non - temporal logic program with select variables values that individually is fed randomly to a certain standard asp resident grounder. expanding the spatial information burden provided by the independent grounder is far then easily used further to specifically generate a subset of ground temporal rules which evidently is necessarily equivalent to ( and generally smaller directly than ) the full program instantiation.", "histories": [["v1", "Mon, 19 Sep 2016 16:11:49 GMT  (40kb)", "http://arxiv.org/abs/1609.05811v1", "Under consideration in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "Under consideration in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["felicidad aguado", "pedro cabalar", "mart\\'in di\\'eguez", "gilberto p\\'erez", "concepci\\'on vidal"], "accepted": false, "id": "1609.05811"}, "pdf": {"name": "1609.05811.pdf", "metadata": {"source": "CRF", "title": "Temporal Logic Programs with Variables", "authors": ["Felicidad Aguado", "Pedro Cabalar", "Mart\u0301\u0131n Di\u00e9guez", "Gilberto P\u00e9rez", "Concepci\u00f3n Vidal", "F. Aguado", "P. Cabalar", "M. Di\u00e9guez", "G. P\u00e9rez", "C. Vidal"], "emails": ["aguado@udc.es", "cabalar@udc.es", "gperez@udc.es", "eicovima@udc.es", "martin.dieguez@irit.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 9.\n05 81\n1v 1"}, {"heading": "Under consideration in Theory and Practice of Logic Programming (TPLP)", "text": "KEYWORDS: Artificial Intelligence; Knowledge Representation; Temporal Logic; Grounding; Logic Programming; Answer Set Programming"}, {"heading": "1 Introduction", "text": "Many application domains and example scenarios from Answer Set Programming (ASP) (Niemela\u0308 1999; Marek and Truszczyn\u0301ski 1999) contain a dynamic component, frequently representing transition systems over discrete time. In an attempt to provide a full logical framework for temporal reasoning in ASP, (Aguado et al. 2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most\ngeneral and best studied logical characterisation of stable models (Gelfond and Lifschitz 1988). In (Aguado et al. 2011) a reduction of (propositional) TEL into regular LTL was presented, but applicable to a subclass of temporal theories called splittable Temporal Logic Programs. This syntactic fragment deals with temporal rules in which, informally speaking, \u201cpast does not depend on the future,\u201d a restriction general enough to cover most (if not all) existing examples of ASP temporal scenarios. The reduction was implemented in a tool, STeLP1 (Cabalar and Die\u0301guez 2011), that computes the temporal stable models of a given program, that are shown as a Bu\u0308chi automaton.\nAlthough the approach in (Aguado et al. 2011) was exclusively propositional, the input language of STeLP was extended with variables. As in non-temporal ASP, these were just understood as a shortcut for all their possible ground instances. This initial approach was not fully satisfactory for several reasons. First, it forced that any variable instance was not only safe (that is, occurring in the positive body of the rule) but also \u201ctyped\u201d by a static predicate, i.e., a predicate whose extent does not vary along time. Second, this restriction implied sometimes the generation of irrelevant ground rules that increased the size of the resulting ground LTL theory while they could be easily detected and removed by a simple analysis of the temporal program. Last, but not least, the treatment of variables had no formal background and had not been proved to be sound with respect to the important property of domain independence (Bria et al. 2008) \u2013 essentially, a program is domain independent when its stable models do not vary under the arbitrary addition of new constants. Although the usual definition of safe variables guarantees domain independence, there was no formal proof for temporal logic programs under TEL.\nIn this note we provide some results that allow an improved treatment of variables in temporal logic programs, using a first order version of TEL as underlying logical framework. We relax the STeLP definition of safe variable by removing the need for static predicates so that, as in ASP, a variable in a rule is safe when it occurs in the positive body2. We prove that this simpler safety condition satisfies domain independence. Finally, we describe a method for grounding temporal logic programs under this new safety condition that still allows calling a standard ASP grounder as a backend, but using a positive normal logic program that is generated by a given transformation on the original temporal logic program.\n2 A motivating example\nExample 1 Suppose we have a set of cars placed at different cities and, at each transition, we can drive a car from one city to another in a single step, provided that there is a road connecting them. \u22a0\nFigure 1 contains a possible representation of this scenario in the language of\n1 http://kr.irlab.org/stelp_online 2 This definition of safety, initially introduced in DLV (Leone et al. 2006) has been adopted in the standard ASP-Core-2 (Calimeri et al. 2015) and also followed by Gringo (Gebser et al. 2011).\nSTeLP. Operator \u2018o\u2019 stands for \u201cnext\u201d whereas \u201c::-\u201d corresponds to the standard ASP conditional \u201c:-\u201d, but holding at all time points. Rule (1) is the effect axiom for driving car X to city A. The disjunctive rule (2) is used to generate possible occurrences of actions in a non-deterministic way. Rules (3) and (4) represent the inertia of fluent at(X,A). Finally, rule (5) forbids that a car is at two different cities simultaneously.\nAs we can see in the first line, predicates city/1, car/1 and road/2 are declared to be static. The scenario would be completed with rules for static predicates. These rules constitute what we call the static program and can only refer to static predicates without temporal operators. An example of a static program for this scenario could be:\nroad(A,B) :- road(B,A). % roads are bidirectional city(A) :- road(A,B). car(1). car(2). road(lisbon,madrid). road(madrid,paris). road(boston,ny). road(ny,nj).\nAdditionally, our temporal program would contain rules describing the initial state like, for instance, the pair of facts:\nat(1,madrid). at(2,ny).\nNote that all variables in a rule are always in some atom for a static predicate in the positive body. The current grounding process performed by STeLP just consists in feeding the static program to an ASP grounder (DLV or gringo) and, once it provides an extension for all the static predicates, each temporal rule is instantiated for each possible substitution of variables according to static predicates. In our running example, for instance, the grounder provides a unique model3 for the static program containing the facts:\n3 If the static program yields several stable models, each one generates a different ground theory whose temporal stable models are computed independently.\ncar(1), car(2), city(lisbon), city(madrid), city(paris), city(boston), city(ny), city(nj), road(lisbon,madrid), road(madrid,lisbon), road(madrid,paris), road(paris,madrid), road(boston,ny), road(ny,boston), road(ny,nj), road(nj,ny)\nWith these data, rule (1) generates 12 ground instances, since we have two possible cars for X and six possible cities for A. Similarly, rule (4) would generate 60 instances as there are 30 pairs A,B of different cities and two cars for X. Many of these ground rules, however, are irrelevant. Take, for instance:\no at(1,ny) ::- driveto(1,ny). no_at(1,paris) ::- at(1,ny).\ncorresponding to possible instantiations of (1) and (4), respectively. In both cases, the body refers to a situation where car 1 is located or will drive to New York, while we can observe that it was initially at Madrid and that the European roadmap is disconnected from the American one. Of course, one could additionally encode a static reachability predicate to force that rule instances refer to reachable cities for a given car, but this would not be too transparent or elaboration tolerant.\nOn the other hand, if we forget, for a moment, the temporal operators and we consider the definition of safe variables used in ASP, one may also wonder whether it is possible to simply require that each variable occurs in the positive body of rules, without needing to refer to static predicates mandatorily. Figure 2 contains a possible variation of the same scenario allowing this possibility. Our goal is allowing this new, more flexible definition of safe variables and exploiting, if possible, the information in the temporal program to reduce the set of generated ground rules."}, {"heading": "3 Temporal Quantified Equilibrium Logic", "text": "Syntactically, we consider function-free first-order languages L = \u3008C,P \u3009 built over a set of constant symbols, C, and a set of predicate symbols, P . Using L, connectors\nand variables, an L = \u3008C,P \u3009-formula F is defined following the grammar:\nF ::= p | \u22a5 | F1 \u2227 F2 | F1 \u2228 F2 | F1 \u2192 F2 |\n\u00a9F | F | \u2666F | \u2200xF (x) | \u2203xF (x)\nwhere p \u2208 P is an atom, x is a variable and \u00a9, and \u2666 respectively stand for \u201cnext\u201d, \u201calways\u201d and \u201ceventually.\u201d A theory is a finite set of formulas. We use the following derived operators:\n\u00acF def = F \u2192 \u22a5\n\u22a4 def = \u00ac\u22a5\nF \u2194 G def = (F \u2192 G) \u2227 (G\u2192 F )\nfor any formulas F,G. An atom is any p(t1, . . . , tn) where p \u2208 P is a predicate with n-arity and each ti is a term (a constant or a variable) in its turn. We say that a term or a formula is ground if it does not contain variables. An L-sentence or closed-formula is a formula without free-variables.\nThe application of i consecutive \u00a9\u2019s is denoted as follows: \u00a9i\u03d5 def = \u00a9(\u00a9i\u22121\u03d5) for i > 0 and \u00a90\u03d5 def = \u03d5. A temporal fact is a construction of the form \u00a9iA where A is an atom.\nLet D be a non-empty set (the domain or universe). By At(D,P ) we denote the set of ground atomic sentences of the language \u3008D,P \u3009. We will also define an interpretation \u03c3 of constants in C (and domain elements in D) as a mapping\n\u03c3 : C \u222aD \u2192 D\nsuch that \u03c3(d) = d for all d \u2208 D.\nA first-order LTL-interpretation is a structure \u3008(D, \u03c3),T\u3009 where D and \u03c3 are as above and T is an infinite sequence of sets, T = {Ti}i\u22650 with Ti \u2286 At(D,P ). Intuitively, Ti contains those ground atoms that are true at situation i. Given two LTL-interpretations H and T we say that H is smaller than T, written H \u2264 T, when Hi \u2286 Ti for all i \u2265 0. As usual, H < T stands for: H \u2264 T and H 6= T. We define the ground temporal facts associated to T as follows: Facts(T) def = {\u00a9ip | p \u2208 Ti}. It is easy to see that H \u2264 T iff Facts(H) \u2286 Facts(T).\nGiven T as above, we denote by T|C the sequence of sets {Ti|C}i\u22650, where each Ti|C = Ti \u2229 At(\u03c3(C), P ), i.e., those atoms from Ti that contain terms exclusively formed with universe elements that are images of syntactic constants in C.\nDefinition 1\nA temporal-here-and-there L-structure with static domains, or a TQHT-structure, is a tuple M = \u3008(D, \u03c3),H,T\u3009 where \u3008(D, \u03c3),H\u3009 and \u3008(D, \u03c3),T\u3009 are two LTLinterpretations satisfying H \u2264 T. \u22a0\nA TQHT-structure of the form M = \u3008(D, \u03c3),T,T\u3009 is said to be total. If M = \u3008(D, \u03c3),H,T\u3009 is a TQHT-structure and k any positive integer, we denote by (M, k) = \u3008(D, \u03c3), (H, k), (T, k)\u3009 the temporal-here-and-thereL-structure with (H, k) = {Hi}i\u2265k and (T, k) = {Ti}i\u2265k. The satisfaction relation for M = \u3008(D, \u03c3),H,T\u3009 is\ndefined recursively forcing us to consider formulas from \u3008C \u222aD,P \u3009. Formally, if \u03d5 is an L-sentence for the atoms in At(C \u222aD,P ), then:\n\u2022 If \u03d5 = p(t1, . . . , tn) \u2208 At(C \u222aD,P ), then\nM |= p(t1, . . . , tn) iff p(\u03c3(t1), . . . , \u03c3(tn)) \u2208 H0.\nM |= t = s iff \u03c3(t) = \u03c3(s)\n\u2022 M 6|= \u22a5\n\u2022 M |= \u03d5 \u2227 \u03c8 iff M |= \u03d5 and M |= \u03c8.\n\u2022 M |= \u03d5 \u2228 \u03c8 iff M |= \u03d5 or M |= \u03c8.\n\u2022 M |= \u03d5\u2192 \u03c8 iff \u3008(D, \u03c3), w,T\u3009 6|= \u03d5 or \u3008(D, \u03c3), w,T\u3009 |= \u03c8 for all w \u2208 {H,T}\n\u2022 M |= \u00a9\u03d5 if (M, 1) |= \u03d5.\n\u2022 M |= \u03d5 if \u2200j \u2265 0, (M, j) |= \u03d5\n\u2022 M |= \u2666\u03d5 if \u2203j \u2265 0, (M, j) |= \u03d5\n\u2022 \u3008(D, \u03c3),H,T\u3009 |= \u2200x\u03d5(x) iff \u3008(D, \u03c3), w,T\u3009 |= \u03d5(d) for all d \u2208 D and for all\nw \u2208 {H,T}.\n\u2022 M |= \u2203x\u03d5(x) iff M |= \u03d5(d) for some d \u2208 D.\nThe resulting logic is called Quantified Temporal Here-and-There Logic with static domains, and denoted by SQTHT or simply by QTHT. It is not difficult to see that, if we restrict to total TQHT-structures, \u3008(D, \u03c3),T,T\u3009 |= \u03d5 iff \u3008(D, \u03c3),T,T\u3009 |= \u03d5 in first-order LTL. Furthermore, the following property can be easily checked by structural induction.\nProposition 1\nFor any formula \u03d5, if \u3008(D, \u03c3),H,T\u3009 |= \u03d5, then:\n\u3008(D, \u03c3),T,T\u3009 |= \u03d5\nA theory \u0393 is a set of L-sentences. An interpretation M is a model of a theory\n\u0393, written M |= \u0393, if it satisfies all the sentences in \u0393.\nDefinition 2 (Temporal Equilibrium Model)\nA temporal equilibrium model of a theory \u0393 is a total model M = \u3008(D, \u03c3),T,T\u3009 of \u0393 such that there is no H < T satisfying \u3008(D, \u03c3),H,T\u3009 |= \u0393. \u22a0\nIf M = \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of a theory \u0393, we say that the First-Order LTL interpretation \u3008(D, \u03c3),T\u3009 is a temporal stable model of \u0393. We write TSM(\u0393) to denote the set of temporal stable models of \u0393. The set of credulous consequences of a theory \u0393, written CredFacts(\u0393) contains all the temporal facts that occur at some temporal stable model of \u0393, that is:\nCredFacts(\u0393) def =\n\u22c3\n\u3008(D,\u03c3),T\u3009\u2208TSM(\u03a0)\nFacts(T)\nA property of TEL directly inherited from Equilibrium Logic (see Proposition 5\nin (Pearce 2006)) is the following:\nProposition 2 (Cumulativity for negated formulas) Let \u0393 be some theory and let \u00ac\u03d5 be some formula such that M |= \u00ac\u03d5 for all temporal equilibrium models of \u0393. Then, the theories \u0393 and \u0393 \u222a {\u00ac\u03d5} have the same set of temporal equilibrium models. \u22a0\nIn this work, we will further restrict the study to a syntactic subset called split-\ntable temporal formulas (STF) which will be of one of the following types:\nB \u2227N \u2192 H (1)\nB \u2227\u00a9B\u2032 \u2227N \u2227\u00a9N \u2032 \u2192 \u00a9H \u2032 (2) (B \u2227\u00a9B\u2032 \u2227N \u2227\u00a9N \u2032 \u2192 \u00a9H \u2032) (3)\nwhere B and B\u2032 are conjunctions of atomic formulas, N and N \u2032 are conjunctions of \u00acp, being p an atomic formula and H and H \u2032 are disjunctions of atomic formulas.\nDefinition 3 A splittable temporal logic program (STL-program for short) is a finite set of sentences like\n\u03d5 = \u2200x1\u2200x2 . . . \u2200xn\u03c8,\nwhere \u03c8 is a splittable temporal formula with x1, x2, . . . , xn free variables.\nWe will also accept in an STL-program an implication of the form (B\u2227N \u2192 H) (that is, containing but not any \u00a9) understood as an abbreviation of the pair of STL-formulas:\nB \u2227N \u2192 H\n(\u00a9B \u2227\u00a9N \u2192 \u00a9H)\nExample 2 The following theory \u03a02 is an STL-program:\n\u00acp \u2192 q (4)\nq \u2227 \u00ac\u00a9 r \u2192 \u00a9p (5)\n(q \u2227 \u00ac\u00a9 p \u2192 \u00a9q) (6)\n(r \u2227 \u00ac\u00a9 p \u2192 \u00a9r \u2228\u00a9q) (7)\nFor an example including variables, the encoding of Example 1 in Figure 2 is also\nan STL-program \u03a01 whose logical representation corresponds to:\n( Driveto(x, a) \u2192 \u00a9At(x, a) ) (8)\n( At(x, a) \u2227Road(a, b) \u2192 Driveto(x, b) \u2228NoDriveto(x, b) ) (9)\n( At(x, a) \u2227 \u00ac\u00a9NoAt(x, a) \u2192 \u00a9At(x, a) ) (10)\n( At(x, b) \u2227 City(a) \u2227 a 6= b \u2192 NoAt(x, a) ) (11)\n( At(x, a) \u2227 At(x, b) \u2227 a 6= b \u2192 \u22a5 ) (12)\nRemember that all rule variables are implicitly universally quantified. For simplicity, we assume that inequality is a predefined predicate.\nAn STL-program is said to be positive if for all rules (1)-(3), N and N \u2032 are empty (an empty conjunction is equivalent to \u22a4). An STL-program is said to be normal if it contains no disjunctions, i.e., for all rules (1)-(3), H and H \u2032 are atoms.\nGiven a propositional combination \u03d5 of temporal facts with \u2227,\u2228,\u22a5,\u2192, we denote \u03d5i as the formula resulting from replacing each temporal fact A in \u03d5 by \u00a9iA. For a formula r = \u03d5 like (3), we denote by ri the corresponding \u03d5i. For instance, (6) i = (\u00a9iq \u2227 \u00ac\u00a9i+1 p \u2192 \u00a9i+1q). As \u00a9 behaves as a linear operator in THT, in fact F i \u2194 \u00a9iF is a THT tautology.\nDefinition 4 (expanded program) Given an STL-program \u03a0 for signature At we define its expanded program \u03a0\u221e as the infinitary logic program containing all rules of the form (1), (2) in \u03a0 plus a rule ri per each rule r of the form (3) in \u03a0 and each integer value i \u2265 0. \u22a0\nThe program \u03a0\u221e2 consists of (4), (5) plus the infinite set of rules:\n\u00a9iq \u2227 \u00ac\u00a9i+1 p \u2192 \u00a9i+1q \u00a9ir \u2227 \u00ac\u00a9i+1 p \u2192 \u00a9i+1r \u2228\u00a9i+1q\nfor i \u2265 0. We can interpret the expanded program as an infinite, non-temporal program where the signature is the infinite set of atoms {\u00a9ip | p \u2208 At, i \u2265 0}.\nTheorem 1 (Theorem 1 in (Aguado et al. 2011)) \u3008T,T\u3009 is a temporal equilibrium model of \u03a0 iff {\u00a9ip | p \u2208 Ti, i \u2265 0} is a stable model of \u03a0\u221e under the (infinite) signature {\u00a9ip | p \u2208 At}. \u22a0\nProposition 3 Any normal positive STL-program\u03a0 has a unique temporal stable model \u3008(D, \u03c3),T\u3009 which coincides with its \u2264-least LTL-model. We denote LM(\u03a0) = Facts(T). \u22a0"}, {"heading": "4 Safe Variables and Domain Independence", "text": "In this section we consider a definition of safe variables for temporal programs that removes the reference to static predicates.\nDefinition 5 A splittable temporal formula \u03d5 of type (1), (2) or (3) is said to be safe if, for any variable x occurring in \u03d5, there exists an atomic formula p in B or B\u2032 such that x occurs in p. A formula \u2200x1\u2200x2 . . .\u2200xn\u03c8 is safe if the splittable temporal formula \u03c8 is safe.\nFor instance, rules (8)-(12) are safe. A simple example of an unsafe rule is the splittable temporal formula:\n\u22a4 \u2192 p(x) (13)\nwhere x does not occur in the positive body. Although an unsafe rule does not always lead to lack of domain independence (see examples in (Cabalar et al. 2009)) it is frequently the case. We prove next that domain independence is, in fact, guaranteed for safe STL-programs.\nTheorem 2 If \u03d5 is a safe sentence and \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of \u03d5, then T|C = T and Ti \u2286 At(\u03c3(C), P ) for any i \u2265 0.\nLet (D, \u03c3) be a domain and D\u2032 \u2286 D a finite subset; the grounding over D\u2032 of a\nsentence \u03d5, denoted by GrD\u2032(\u03d5), is defined recursively\nGrD\u2032(p) def = p, where p denotes any atomic formula\nGrD\u2032(\u03d51 \u2299 \u03d52) def = GrD\u2032(\u03d51)\u2299GrD\u2032(\u03d52),\nwith \u2299 any binary operator in {\u2227,\u2228,\u2192}\nGrD\u2032(\u2200x\u03d5(x)) def =\n\u2227\nd\u2208D\u2032 GrD\u2032\u03d5(d)\nGrD\u2032(\u2203x\u03d5(x)) def =\n\u2228\nd\u2208D\u2032 GrD\u2032\u03d5(d)\nGrD\u2032(\u00a9\u03d5) def = \u00a9GrD\u2032(\u03d5)\nGrD\u2032( \u03d5) def = GrD\u2032(\u03d5) GrD\u2032(\u2666\u03d5) def = \u2666GrD\u2032(\u03d5)\nTheorem 3 (Domain independence) Let \u03d5 be safe splittable temporal sentence. Suppose we expand the language L by considering a set of constants C\u2032 \u2287 C. A total QTHT-model \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of GrC\u2032(\u03d5) if and only if it is a temporal equilibrium model of GrC(\u03d5)."}, {"heading": "5 Derivable ground facts", "text": "In this section we present a technique for grounding safe temporal programs based on the construction of a positive normal ASP program with variables. The method is based on the idea of derivable ground temporal facts for an STL-program \u03a0. This set, call it \u2206, will be an upper estimation of the credulous consequences of the program, that is, CredFacts(\u03a0) \u2286 \u2206. Of course, the ideal situation would be that \u2206 = CredFacts(\u03a0), but the set CredFacts(\u03a0) requires the temporal stable models of \u03a0 and these (apart from being infinite sequences) will not be available at grounding time. In the worst case, we could choose \u2206 to contain the whole set of possible temporal facts, but this would not provide relevant information to improve grounding. So, we will try to obtain some superset of CredFacts(\u03a0) as small as possible, or if preferred, to obtain the largest set of non-derivable facts we can find. Note that a non-derivable fact \u00a9ip 6\u2208 \u2206 satisfies that \u00a9ip 6\u2208 CredFacts(\u03a0) and so, by Proposition 2, \u03a0\u222a{\u00ac\u00a9i p} is equivalent to \u03a0, that is, both theories have the same set of temporal equilibrium models. This information can be used to simplify the ground program either by removing rules or literals.\nWe begin defining several transformations on STL-programs. For any temporal\nrule r, we define r\u2227 as the set of rules:\n\u2022 If r has the form (1) then r\u2227 def = {B \u2192 p | atom p occurs in H} \u2022 If r has the form (2) then r\u2227 def = {B \u2227\u00a9B\u2032 \u2192 \u00a9p | atom p occurs in H \u2032} \u2022 If r has the form (3) then r\u2227 def = { (B \u2227\u00a9B\u2032 \u2192 \u00a9p) | atom p occurs in H \u2032}\nIn other words, r\u2227 will imply all the original disjuncts in the disjunctive head of r. It is interesting to note that for any rule r with an empty head (\u22a5) this definition implies r\u2227 = \u2205. Program \u03a0\u2227 is defined as the union of r\u2227 for all rules r \u2208 \u03a0. As an example, \u03a0\u22272 consists of the rules:\n\u22a4 \u2192 q\nq \u2192 \u00a9p\n(q \u2192 \u00a9q) (r \u2192 \u00a9r)\n(r \u2192 \u00a9q)\nwhereas \u03a0\u22271 would be the program:\n( Driveto(x, a) \u2192 \u00a9At(x, a) ) (14)\n( At(x, a) \u2227Road(a, b) \u2192 Driveto(x, b) ) (15)\n( At(x, a) \u2227Road(a, b) \u2192 NoDriveto(x, b) ) (16)\n( At(x, a) \u2192 \u00a9At(x, a) ) (17)\n( At(x, b) \u2227 City(a) \u2227 a 6= b \u2192 NoAt(x, a) ) (18)\nNotice that, by definition, \u03a0\u2227 is always a positive normal STL-program and, by\nProposition 3, it has a unique temporal stable model, LM(\u03a0\u2227).\nProposition 4 For any STL-program \u03a0, CredFacts(\u03a0) \u2286 LM(\u03a0\u2227). \u22a0\nUnfortunately, using \u2206 = LM(\u03a0\u2227) as set of derivable facts is unfeasible, since it contains infinite temporal facts corresponding to an \u201cinfinite run\u201d of the transition system described by \u03a0\u2227. Instead, we will adopt a compromise solution taking a superset of LM(\u03a0\u2227) extracted from a new theory, \u0393\u03a0. This theory will collapse all the temporal facts from situation 2 on, so that all the states Ti for i \u2265 2 will be repeated4. We define \u0393\u03a0 as the result of replacing each rule (B \u2227\u00a9B\u2032 \u2192 \u00a9p) in \u03a0\u2227 by the formulas:\nB \u2227\u00a9B\u2032 \u2192 \u00a9p (19) \u00a9B \u2227\u00a92B\u2032 \u2192 \u00a92p (20) \u00a92B \u2227\u00a92B\u2032 \u2192 \u00a92p (21)\nand adding the axiom schema:\n\u00a92 (p\u2194 \u00a9p) (22)\nfor any ground atom p \u2208 At(D,P ) in the signature of \u03a0. As we can see, (19) and (20) are the first two instances of the original rule (B\u2227\u00a9B\u2032 \u2192 \u00a9p) corresponding to situations i = 0 and i = 1. Formula (21), however, differs from the instance we\n4 Note that rules of the form (1) and (2) are not in the scope of and so may provide an irregular behaviour for atoms at situations 0 and 1. In a theory only consisting of rules like (3) we could collapse all situations from i = 0 on since they would follow a regular pattern.\nwould get for i = 2 since, rather than having\u00a93B\u2032 and\u00a93p, we use\u00a92B\u2032 and\u00a92p respectively. This can be done because axiom (22) is asserting that from situation 2 on all the states are repeated.\nIn the cars example, for instance, (14) from \u03a0\u22271 would yield the three rules:\nDriveto(x, a) \u2192 \u00a9At(x, a)\n\u00a9Driveto(x, a) \u2192 \u00a92At(x, a) \u00a92Driveto(x, a) \u2192 \u00a92At(x, a)\nIt is not difficult to see that axiom (22) implies that checking that some M is a temporal equilibrium model of \u0393\u03a0 is equivalent to checking that {\u00a9ip | p \u2208 Ti , i = 0, 1, 2} is a stable model of \u0393\u03a0 \\ {(22)} and fixing Ti = T2 for i \u2265 3. This allows us to exclusively focus on the predicate extents in T0, T1 and T2, so we can see the\n-free program \u0393\u03a0 \\ {(22)} as a positive normal ASP (i.e., non-temporal) program for the propositional signature {p,\u00a9p,\u00a92p | p \u2208 At(D,P )} that can be directly fed to an ASP grounder, after some simple renaming conventions.\nTheorem 4 \u0393\u03a0 has a least LTL-model, LM(\u0393\u03a0) which is a superset of LM(\u03a0 \u2227).\nIn other words CredFacts(\u03a0) \u2286 LM(\u03a0\u2227) \u2286 LM(\u0393\u03a0) = \u2206, i.e., we can use LM(\u0393\u03a0) as set of derivable facts and simplify the ground program accordingly. To this aim, a slight adaptation is further required. Each rule in \u03a0 like (3) has the form\n\u03b1 and any predicate p in \u03b1 is implicitly affected (Theorem 1) by the extension of \u00a92p in LM(\u0393\u03a0). In order to properly ground the extensions for p,\u00a9p and \u00a92p we replace each \u03b1 by the equivalent conjunction of the three rules \u03b1, \u00a9\u03b1 and\n\u00a92 \u03b1. For instance, (9) would be replaced by:\nAt(x, a) \u2227Road(a, b) \u2192 Driveto(x, b) \u2228NoDriveto(x, b) (23)\n\u00a9At(x, a) \u2227\u00a9Road(a, b) \u2192 \u00a9Driveto(x, b)\n\u2228\u00a9NoDriveto(x, b) (24)\n( \u00a92At(x, a) \u2227\u00a92Road(a, b) \u2192 \u00a92Driveto(x, b)\n\u2228\u00a92 NoDriveto(x, b) ) (25)\nand then check the possible extents for the positive bodies we get from the set of derivable facts \u2206 = LM(\u0393\u03a0). For example, for the last rule, we can make substitutions for x, a and b using the extents of \u00a92At(x, a) and \u00a92Road(a, b) we have in \u2206. However, this still means making a join operation for both predicates. We can also use the ASP grounder for that purpose by just adding a rule that has as body, the positive body of the original temporal rule r, and as head, a new auxiliary predicate Substr(x, a, b) referring to all variables in the rule. In the example, for rule (25) we would include in our ASP program:\n\u00a92At(x, a) \u2227\u00a92Road(a, b) \u2192 Subst(25)(x, a, b)\nIn this way, each tuple of Substr(x1, . . . , xn) directly points out the variable\nsubstitution to be performed on the temporal rule.\nFor instance, in the small instance case described of our example (2 cars and 6\ncities) we reduce the number of generated ground rules in the scope of \u2018 \u2019 from 160 using the previous STeLP grounding method to 62. The reader may easily imagine that the higher degree of cities interconnection, the smaller obtained reduction of rule instances. Although an exhaustive experimentation is still ongoing work, a reduction of this kind is very promising. In our initial experiments, the grounding performed on \u0393\u03a0 (whose generation is polynomial) does not constitute a significant time increase, whereas the computation of temporal stable models is drastically improved by the reduction of ground rules5."}, {"heading": "6 Conclusions", "text": "We have improved the grounding method for temporal logic programs with variables in different ways. First, we provided a safety condition that directly corresponds to extrapolating the usual concept of safe variable in ASP. In this way, any variable occurring in a rule is considered to be safe if it also occurs in the positive body of the rule, regardless the possible scope of temporal operators and removing the previous dependence on the use of static predicates.\nWe have proved that this safety condition suffices to guarantee the property of domain independence by which computing the (temporal) stable models is insensitive to the possible addition of new arbitrary constants to the universe.\nWe have also designed a method for grounding the temporal logic program that consists in constructing a non-temporal normal positive program with variables that is fed to an ASP solver to directly obtain the set of variable substitutions to be performed for each rule. The proposed method allows reducing in many cases the number of ground temporal rules generated as a result.\nThe current note contains formal results, providing the correctness (with respect to domain independence) of the safety condition and the method for grounding safe programs. Regarding implementation, a stand-alone prototype for proving examples like the one in the paper has been constructed, showing promising results. The immediate next step is incorporating the new grounding method inside STeLP and analysing its performance on benchmark scenarios.\nAcknowledgements This research was partially supported by Spanish MINECO project TIN2013-42149-P and Xunta de Galicia GPC 2013/070."}, {"heading": "Appendix. Proofs", "text": "Proof of Proposition 3. Consider the expanded program \u03a0\u221e. This is an infinitary positive (non-temporal) logic program. Using the well-known results by (van Emden and Kowalski 1976), we know it has a least Herbrand model LM(\u03a0\u221e) call it I, which may contain an infinite set of atoms in the signature of ground temporal facts {\u00a9ip | p \u2208 At, i \u2265 0}, where At is the original signature of \u03a0. Furthermore, as \u03a0\u221e is positive, its unique stable model is precisely I. Given any set of ground temporal facts I we can establish a one-to-one correspondence to an LTL-interpretation I with Facts(I) = I. By Theorem 1, J is a stable model of \u03a0\u221e iff J, with Facts(J) = J is a temporal stable model of \u03a0. Finally, as I is the unique stable model of \u03a0\u221e we get that I is the only temporal stable model of \u03a0. \u22a0\nA variable assignment \u00b5 in (D, \u03c3) is a mapping from the set of variables to D. If \u03d5 \u2208 L has free-variables, \u03d5\u00b5 is the closed formula obtained by replacing every free variable x by \u00b5(x).\nLemma 1\nLet \u03d5 be a splittable temporal formula and \u00b5 a variable assignment in (D, \u03c3). If \u03d5 is safe, then if follows that:\n\u3008(D, \u03c3),T,T\u3009 |= \u03d5\u00b5 implies \u3008(D, \u03c3),T|C ,T\u3009 |= \u03d5 \u00b5."}, {"heading": "Proof", "text": "First of all, take \u03d5 = B \u2227N \u2192 H of type (1) and suppose that \u3008T,T\u3009 |= \u03d5\u00b5 but \u3008T|C ,T\u3009 6|= \u03d5\u00b5. This means that \u3008T|C ,T\u3009 |= B\u00b5 \u2227N\u00b5 and \u3008T|C ,T\u3009 6|= H\u00b5. Since \u3008T,T\u3009 |= H\u00b5, there exists an atomic formula q in H such that \u3008T,T\u3009 |= q\u00b5 but \u3008T|C ,T\u3009 6|= q\u00b5. So we have a variable x in q with \u00b5(x) 6\u2208 \u03c3(C). As \u03d5 is safe, we know that x occurs in an atomic formula p in B. Then \u3008T|C ,T\u3009 6|= p\u00b5 and \u3008T|C ,T\u3009 6|= B\u00b5 which yields a contradiction.\nIf \u03d5 is of type (2), we use a similar argument. Finally, take \u03d5 = (B \u2227 \u00a9B\u2032 \u2227 N \u2227 \u00a9N \u2032 \u2192 \u00a9H \u2032) = \u03c8 of type (3) and suppose that \u3008T,T\u3009 |= \u03d5\u00b5 but \u3008T|C ,T\u3009 6|= \u03d5 \u00b5. There exists i \u2265 0 such that \u3008Ti, Ti\u3009 |= \u03c8\u00b5 and \u3008Ti \u2229 \u03c3(C), Ti\u3009 6|= \u03c8\u00b5. We then have that \u3008Ti \u2229 \u03c3(C), Ti\u3009 |= B\u00b5 \u2227 (\u00a9B\u2032)\u00b5 \u2227N\u00b5 \u2227 (\u00a9N \u2032)\u00b5 and \u3008Ti \u2229 \u03c3(C), Ti\u3009 6|= (\u00a9H \u2032)\u00b5. Using that \u03d5 is safe and the same argument as above, we find an atomic formula p in B or B\u2032 such that \u3008Ti \u2229 \u03c3(C), Ti\u3009 6|= p\u00b5 which implies \u3008Ti \u2229 \u03c3(C), Ti\u3009 6|= B\u00b5 \u2227 (\u00a9B\u2032)\u00b5 and leads to contradiction. The other implication follows directly from Proposition 1.\nProposition 5\nFor any safe sentence \u03d5 = \u2200x1\u2200x2 . . . \u2200xn\u03c8\n\u3008(D, \u03c3),T,T\u3009 |= \u03d5 iff \u3008(D, \u03c3),T|C ,T\u3009 |= \u03d5."}, {"heading": "Proof", "text": "Proceed by induction over the length of the prefix. If n = 0, we can take any \u00b5 assignment of variables and apply Lemma 1 on \u03d5 = \u03d5\u00b5 . So take \u03d5 = \u2200x1 . . .\u2200xn\u03c8 of length n and suppose that the result is true for any universal safe sentence whose prefix has length at most n \u2212 1. If \u3008(D, \u03c3),T,T\u3009 |= \u03d5, put \u03d5 = \u2200x1\u03b1(x1) with \u03b1(x1) = \u2200x2 . . .\u2200xn\u03c8. For any d \u2208 D, we know that \u3008(D, \u03c3),T,T\u3009 |= \u03b1(d) and we have to show that \u3008(D, \u03c3),T|C ,T\u3009 |= \u03b1(d). The induction hypothesis and the fact that \u03b1(d) is a safe sentence whose prefix has length smaller or equal than n \u2212 1 finishes the proof.\nProof of Theorem 2. If \u03d5 is a safe sentence and \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of \u03d5, we have that \u3008(D, \u03c3),T|C ,T\u3009 |= \u03d5 by Proposition 5. The definition of temporal equilibrium model implies that T|C = T and Ti \u2286 At(\u03c3(C), P ) for any i \u2265 0. \u22a0\nLemma 2 Let \u03d5(x) be a safe splittable temporal formula of type (1), (2) or (3) and take \u3008(D, \u03c3),H,T\u3009 be such that T = T|C . Then, for any d \u2208 D \\ \u03c3(C) we have:\n\u3008(D, \u03c3),H,T\u3009 |= \u03d5(d)."}, {"heading": "Proof", "text": "First of all, suppose that \u03d5(x) is of type (1):\nB \u2227N \u2192 H\nand take d \u2208 D \\ \u03c3(C) and w \u2208 {H,T} such that \u3008(D, \u03c3), w,T\u3009 6|= \u03d5(d). This implies that \u3008(D, \u03c3), w,T\u3009 |= B(d) \u2227N(d) but \u3008(D, \u03c3), w,T\u3009 6|= H(d). \u03d5(x) is safe so there must be an atom p in B such that x has an occurrence in p. Since T0 \u2286 At(\u03c3(C), P ), it is clear that \u3008(D, \u03c3), w,T\u3009 6|= p(d), so \u3008(D, \u03c3), w,T\u3009 6|= B(d) which yields a contradiction.\nThe proof for the case of \u03d5(x) being of type (2) and (3) is similar.\nLemma 3 Let \u03d5(x) = \u2200x1\u2200x2 . . . \u2200xn\u03c8 with \u03c8 a splittable temporal formula and such that \u03d5(x) has no other free variables than x. Let M = \u3008(D, \u03c3),H,T\u3009 be such that T = T|C . Then, if \u2200x\u03d5(x) is safe, we have that:\nM |= \u2200x\u03d5(x) iff M |= \u2227\nc\u2208C \u03d5(c)."}, {"heading": "Proof", "text": "From left to right, just note that if M |= \u2200x\u03d5(x) but M 6|= \u03d5(c), for some c \u2208 C, we would have that M 6|= \u03d5(\u03c3(c)) which would yield a contradiction.\nFor right to left, we can proceed by induction in n. If n = 0, then \u03d5(x) is in the case of the previous lemma for any d \u2208 D \\ \u03c3(C), so M |= \u2200x\u03d5(x) whenever M |= \u2227\nc\u2208C \u03d5(c). Now, suppose the result is true for any prenex formula\nwith length up to n \u2212 1 and take \u03d5(x) = \u2200x1\u2200x2 . . . \u2200xn\u03c8(x, x1, . . . , xn) such that\nM |= \u2227\nc\u2208C \u03d5(c). It only rests to show that M |= \u03d5(d) for any d \u2208 D \\\u03c3(C). Notice\nthat \u03d5(d) = \u2200x1\u03b1(x1) with \u03b1(x1) = \u2200x2 . . . \u2200xn\u03c8(d, x1, x2, . . . , xn). Since we can apply the induction hypothesis on \u03b1(x1), it will be sufficient to prove that:\nM |= \u2227\nc\u2208C \u03b1(c).\nNow fix any c \u2208 C and take into account that\nM |= \u03d5(c\u2032) = \u2200x1\u2200x2 . . . \u2200xn\u03c8(c \u2032, x1, x2 . . . , xn)\nfor all c\u2032 \u2208 C, so we can replace x1 by any constant in C, including c, and so:\nM |= \u2200x2 . . . \u2200xn\u03c8(c \u2032, c, x2, . . . , xn), for any c \u2032 \u2208 C\nObserve that we can apply the induction hypothesis on \u03b2(z), where\n\u03b2(z) = \u2200x2 . . . \u2200xn\u03c8(z, c, x2, . . . , xn)\nand then M |= \u2200z\u03b2(z). In particular M |= \u03b2(d) which completes the proof since \u03b2(d) = \u03b1(c).\nThe following proposition can be easily proved\nProposition 6 Given any D 6= \u2205: \u3008(D, \u03c3),H,T\u3009 |= \u03d5 iff \u3008(D, \u03c3),H,T\u3009 |= GrD(\u03d5). \u22a0\nTheorem 5 If \u03d5 = \u2200x1\u2200x2 . . . \u2200xn\u03c8 is a safe splittable temporal sentence andM = \u3008(D, \u03c3),H,T\u3009 such that T = T|C , then\nM |= \u03d5 iff M |= GrC(\u03d5)."}, {"heading": "Proof", "text": "From left to right, suppose that M |= \u03d5. By Proposition 6, we know that M |= GrD(\u03d5). The result follows since \u03c3(C) \u2286 D and GrC(\u03d5) = Gr\u03c3(C)(\u03d5).\nNow, from the right to left direction, take \u03d5 = \u2200x1\u2200x2 . . . \u2200xn\u03c8 a safe splittable temporal sentence and suppose that M |= GrC(\u03d5). Again, we can proceed by induction in n. If n = 0, then \u03d5 is quantifier free so GrC(\u03d5) = \u03d5. Suppose the result is true for any safe splittable sentence with length up to n\u22121 and put \u03d5 = \u2200x1\u03b1(x1) with \u03b1(x1) = \u2200x2 . . . \u2200xn\u03c8(x1, x2, . . . , xn). Notice that \u03b1(x1) is a safe formula that has no more free variables than x1, so, if we apply Lemma 3, it will be sufficient to show that M |= \u2227\nc\u2208C \u03b1(c). Since we are supposing that\nM |= GrC(\u03d5) = \u2227 c\u2208C GrC(\u03b1(c)),\nand we can apply the induction hypothesis on any \u03b1(c) with c \u2208 C, it follows that M |= \u2227\nc\u2208C \u03b1(c) and this completes the proof.\nTheorem 6 If \u03d5 is a safe splittable temporal sentence, then \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of \u03d5 iff \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of GrC(\u03d5)."}, {"heading": "Proof", "text": "Suppose that \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of \u03d5 and \u3008(D, \u03c3),H,T\u3009 |= GrC(\u03d5). Since \u03d5 is safe, we know by Theorem 2 that T = T|C so, applying Theorem 5, it follows that \u3008(D, \u03c3),H,T\u3009 |= \u03d5 and H = T. This shows that \u3008(D, \u03c3),T,T\u3009 is also a temporal equilibrium model of GrC(\u03d5), The other implication follows directly from the fact that \u3008(D, \u03c3),H,T\u3009 |= \u03d5 implies \u3008(D, \u03c3),H,T\u3009 |= GrC(\u03d5).\nProof of Theorem 3. Let us show that the following assertions are equivalent:\n1. \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of GrC(\u03d5) 2. \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of \u03d5 3. \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of GrC\u2032(\u03d5)\nTaking into account the previous theorem, we only have to prove the equivalence of 2 and 3. Suppose that \u3008(D, \u03c3),T,T\u3009 is a temporal equilibrium model of \u03d5 and \u3008(D, \u03c3),H,T\u3009 |= GrC\u2032(\u03d5). Because of Theorem 2, we have that T = T|C \u2286 T|C\u2032 and an obvious extension of Theorem 5 to C\u2032, implies that\n\u3008(D, \u03c3),H,T\u3009 |= \u03d5\nand so H = T. This shows that 2 implies 3. The other implication (3. =\u21d2 2.) follows directly. \u22a0\nLemma 4 If T is any equilibrium model of a (non temporal) program \u03a0 with rules of type (1), then T \u2286 J , where J is any model of the normal positive program \u03a0\u2227."}, {"heading": "Proof", "text": "We will prove that \u3008T \u2229 J, T \u3009 |= \u03a0, and so, T \u2229 J = T by the minimality of T .\nLet B\u2227N \u2192 H of the form (1) be an arbitrary rule in \u03a0. To prove \u3008T \u2229J, T \u3009 |= r we already know that \u3008T, T \u3009 |= r and remain to prove that if \u3008T \u2229 J, T \u3009 |= B \u2227N then \u3008T \u2229 J, T \u3009 |= H . So, suppose that \u3008T \u2229 J, T \u3009 |= B \u2227N . Then \u3008T, T \u3009 |= B \u2227N y \u3008J, J\u3009 |= B. Therefore, \u3008T, T \u3009 |= H and there exists p \u2208 H such that \u3008T, T \u3009 |= p. Since rule B \u2192 p \u2208 \u03a0\u2227 and \u3008J, J\u3009 |= B, we get that \u3008J, J\u3009 |= p and so \u3008T \u2229 J, T \u3009 |= H , as we wanted to prove.\nGiven any rule like r like (2) of (3) and a set of atoms X , we define its simplifi-\ncation simp(r,X) as:\nsimp(r,X) def =\n{\n\u00a9B\u2032 \u2227\u00a9N \u2032 \u2192 \u00a9H \u2032 if B \u2286 X and N \u2229X = \u2205 \u22a4 otherwise\nDefinition 6 (Slice program) Given some LTL interpretation T, let us define now the sequence of programs:\nslice(\u03a0,T, 0) def = \u03a00 = ini0(\u03a0) slice(\u03a0,T, 1) def = {simp(r, T0) | r \u2208 ini1(\u03a0) \u222a dyn(\u03a0)}\nslice(\u03a0,T, i+ 1) def = {\u00a9isimp(r, Ti) | r \u2208 dyn(\u03a0)} for i \u2265 1\n\u22a0\nTheorem 7 (Theorem 3 in (Aguado et al. 2011)) Let \u3008T,T\u3009 be a model of a splittable TLP \u03a0. \u3008T,T\u3009 is a temporal equilibrium model of \u03a0 iff\n(i) T0 = T0 is a stable model of slice(\u03a0,T, 0) = \u03a0 0 = ini0(\u03a0) and\n(ii) (T1 \\At0) is a stable model of slice(\u03a0,T, 1) and\n(iii) (Ti \\Ati\u22121) is a stable model of slice(\u03a0,T, i) for i \u2265 2. \u22a0\nProof of Proposition 4. Let \u3008T,T\u3009 be any temporal equilibrium model of \u03a0 an denote by {Li}i\u22650 the corresponding infinite sequence of ground atoms of LM(\u03a0\u2227). By Theorem 7, we know that, for all i \u2265 0, Ti (resp. Li) is a stable model of slice(\u03a0,T, i) (resp. of slice(\u03a0\u2227, LM(\u03a0\u2227), i). Finally, we can apply Lemma 4 and the fact that slice(\u03a0,T, 0)\u2227 = slice(\u03a0\u2227, LM(\u03a0\u2227), 0) and, for i \u2265 1,\nslice(\u03a0,T, i)\u2227 \u2286 slice(\u03a0\u2227, LM(\u03a0\u2227), i).\n\u22a0\nProof of Theorem 4. Let \u3008T,T\u3009 be the unique temporal equilibrium model of \u03a0\u2227 and let \u3008D,D\u3009 denote the temporal interpretation defined by:\n\u2022 Di = Ti if 0 \u2264 i \u2264 1, \u2022 D2 is the stable model of the positive non-disjunctive program:\n{\u00a92B \u2227\u00a92B\u2032 \u2192 \u00a92p | (B \u2227\u00a9B\u2032 \u2192 \u00a9p) \u2208 dyn(\u03a0\u2227)} \u222a slice(\u03a0\u2227, L, 1)\n\u2022 Di = D2 if \u2265 3,\nIt is straightforward to check that \u3008D,D\u3009 is a temporal equilibrium model of \u0393\u03a0. Notice that T2 \u2286 D2. This follows from Lemma 4 and the facts that T2 \\ AT 1 is the stable model of slice(\u03a0\u2227, L, 1) and D2 is a model of this latter program.\nThe cases i = 0, 1, 2 follow from Proposition 4 an the fact that T2 \u2286 D2. When i \u2265 3, we shall prove that \u3008Ti \\Ati\u22121 \u2229Di \\Ati\u22121,Ti \\Ati\u22121\u3009 is a model of slice(\u03a0\u2227,T, i) so by Theorem 7, Ti \\ Ati\u22121 \u2229 Di \\ Ati\u22121 = Ti \\ Ati\u22121 and, consequently, Ti \u2286 Di. So, take \u00a9iB\u2032 \u2192 \u00a9iH \u2032 \u2208 slice(\u03a0\u2227,T, i) and suppose that\n\u3008Ti \\Ati\u22121 \u2229Di \\Ati\u22121,Ti \\Ati\u22121\u3009 |= \u00a9iB\u2032\nThis fact implies that \u3008Ti \\ Ati\u22121,Ti \\ Ati\u22121\u3009 |= \u00a9iB\u2032 and also that there exists a (positive normal) dynamic rule like (3) such that B \u2286 Ti\u22121 \u2286 Di\u22121. Since \u3008Ti \\ Ati\u22121,Ti \\ Ati\u22121\u3009 is a model of slice(\u03a0\u2227,T, i), the only atom p \u2208 H \u2032 satisfies \u3008Ti \\ Ati\u22121,Ti \\ Ati\u22121\u3009 |= \u00a9ip. It only rests to show that \u3008Di,Di\u3009 |= \u00a9ip or equivalently \u3008D,D\u3009 |= \u00a92p (notice that Di = D2 if i \u2265 2). Finally, we can use that the rule \u00a92B \u2227\u00a92B\u2032 \u2192 \u00a92p \u2208 \u0393\u03a0 and also the fact that \u3008D,D\u3009 |= \u00a92B \u2227\u00a92B\u2032 because i \u2265 3 and B\u2032 \u2286 Di = D2 and B \u2286 T\u0131\u22121 \u2286 Di\u22121 = D2. \u22a0"}], "references": [{"title": "Strongly equivalent temporal logic programs", "author": ["F. Aguado", "P. Cabalar", "G. P\u00e9rez", "C. Vidal"], "venue": "JELIA\u201908. Lecture Notes in Computer Science, vol. 5293. Springer, 8\u201320.", "citeRegEx": "Aguado et al\\.,? 2008", "shortCiteRegEx": "Aguado et al\\.", "year": 2008}, {"title": "Loop formulas for splitable temporal logic programs", "author": ["F. Aguado", "P. Cabalar", "G. P\u00e9rez", "C. Vidal"], "venue": "LPNMR\u201911, J. P. Delgrande and W. Faber, Eds. Lecture Notes in Computer Science, vol. 6645. Springer, 80\u201392.", "citeRegEx": "Aguado et al\\.,? 2011", "shortCiteRegEx": "Aguado et al\\.", "year": 2011}, {"title": "On the complexity of temporal equilibrium logic", "author": ["L. Bozzelli", "D. Pearce"], "venue": "Proc. of the 30th Annual ACM/IEEE Symp. on Logic in Computer Science, (LICS\u201915). IEEE Computer Society, 645\u2013656.", "citeRegEx": "Bozzelli and Pearce,? 2015", "shortCiteRegEx": "Bozzelli and Pearce", "year": 2015}, {"title": "Normal form nested programs", "author": ["A. Bria", "W. Faber", "N. Leone"], "venue": "Proc. of the 11th European Conference on Logics in Artificial Intelligence (JELIA\u201908), S. H. et al, Ed. Lecture Notes in Artificial Intelligence. Springer, 76\u201388.", "citeRegEx": "Bria et al\\.,? 2008", "shortCiteRegEx": "Bria et al\\.", "year": 2008}, {"title": "STELP - a tool for temporal answer set programming", "author": ["P. Cabalar", "M. Di\u00e9guez"], "venue": "LPNMR\u201911. Lecture Notes in Computer Science, vol. 6645. Springer, 370\u2013375.", "citeRegEx": "Cabalar and Di\u00e9guez,? 2011", "shortCiteRegEx": "Cabalar and Di\u00e9guez", "year": 2011}, {"title": "A revised concept of safety for general answer set programs", "author": ["P. Cabalar", "D. Pearce", "A. Valverde"], "venue": "Proc. of the 10th Int. Conf. Logic Programming and Nonmonotonic Reasoning (LPNMR\u201909). Lecture Notes in Computer Science, vol. 5753. Springer, 58\u201370.", "citeRegEx": "Cabalar et al\\.,? 2009", "shortCiteRegEx": "Cabalar et al\\.", "year": 2009}, {"title": "ASP-core-2 input language format", "author": ["F. Calimeri", "W. Faber", "M. Gebser", "G. Ianni", "R. Kaminski", "T. Krennwallner", "N. Leone", "F. Ricca", "T. Schaub"], "venue": "https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf.", "citeRegEx": "Calimeri et al\\.,? 2015", "shortCiteRegEx": "Calimeri et al\\.", "year": 2015}, {"title": "Advances in gringo series", "author": ["M. Gebser", "R. Kaminski", "A. K\u00f6nig", "T. Schaub"], "venue": null, "citeRegEx": "Gebser et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Logic Programming: Proc. of the Fifth International Conference and Symposium (Volume 2), R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Cambridge, MA, 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "The dlv system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7, 499\u2013562.", "citeRegEx": "Leone et al\\.,? 2006", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "Stable models and an alternative logic programming paradigm", "author": ["V. Marek", "M. Truszczy\u0144ski"], "venue": "Springer-Verlag, 169\u2013181.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1999", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1999}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["I. Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence 25, 241\u2013273.", "citeRegEx": "Niemel\u00e4,? 1999", "shortCiteRegEx": "Niemel\u00e4", "year": 1999}, {"title": "A new logical characterisation of stable models and answer sets", "author": ["D. Pearce"], "venue": "Non monotonic extensions of logic programming. Proc. NMELP\u201996. (LNAI 1216). SpringerVerlag.", "citeRegEx": "Pearce,? 1996", "shortCiteRegEx": "Pearce", "year": 1996}, {"title": "Equilibrium logic", "author": ["D. Pearce"], "venue": "Annals of Mathematics and Artificial Intelligence 47, 1-2, 3\u201341.", "citeRegEx": "Pearce,? 2006", "shortCiteRegEx": "Pearce", "year": 2006}, {"title": "The temporal logic of programs", "author": ["A. Pnueli"], "venue": "18th Annual Symposium on Foundations of Computer Science. IEEE Computer Society Press, 46\u201357.", "citeRegEx": "Pnueli,? 1977", "shortCiteRegEx": "Pnueli", "year": 1977}, {"title": "The semantics of predicate logic as a programming language", "author": ["M.H. van Emden", "R.A. Kowalski"], "venue": "Journal of the ACM", "citeRegEx": "Emden and Kowalski,? \\Q1976\\E", "shortCiteRegEx": "Emden and Kowalski", "year": 1976}, {"title": "Theorem 7 (Theorem 3 in (Aguado et al. 2011)) Let \u3008T,T\u3009 be a model of a splittable TLP \u03a0. \u3008T,T\u3009 is a temporal equilibrium model of \u03a0", "author": ["F. Aguado", "P. Cabalar", "M. Di\u00e9guez", "G. P\u00e9rez", "C. Vidal"], "venue": null, "citeRegEx": "Aguado et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Aguado et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 11, "context": "Many application domains and example scenarios from Answer Set Programming (ASP) (Niemel\u00e4 1999; Marek and Truszczy\u0144ski 1999) contain a dynamic component, frequently representing transition systems over discrete time.", "startOffset": 81, "endOffset": 124}, {"referenceID": 10, "context": "Many application domains and example scenarios from Answer Set Programming (ASP) (Niemel\u00e4 1999; Marek and Truszczy\u0144ski 1999) contain a dynamic component, frequently representing transition systems over discrete time.", "startOffset": 81, "endOffset": 124}, {"referenceID": 0, "context": "In an attempt to provide a full logical framework for temporal reasoning in ASP, (Aguado et al. 2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most", "startOffset": 81, "endOffset": 101}, {"referenceID": 14, "context": "2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most", "startOffset": 142, "endOffset": 155}, {"referenceID": 12, "context": "2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most", "startOffset": 227, "endOffset": 240}, {"referenceID": 8, "context": "general and best studied logical characterisation of stable models (Gelfond and Lifschitz 1988).", "startOffset": 67, "endOffset": 95}, {"referenceID": 1, "context": "In (Aguado et al. 2011) a reduction of (propositional) TEL into regular LTL was presented, but applicable to a subclass of temporal theories called splittable Temporal Logic Programs.", "startOffset": 3, "endOffset": 23}, {"referenceID": 4, "context": "The reduction was implemented in a tool, STeLP (Cabalar and Di\u00e9guez 2011), that computes the temporal stable models of a given program, that are shown as a B\u00fcchi automaton.", "startOffset": 47, "endOffset": 73}, {"referenceID": 1, "context": "Although the approach in (Aguado et al. 2011) was exclusively propositional, the input language of STeLP was extended with variables.", "startOffset": 25, "endOffset": 45}, {"referenceID": 3, "context": "Last, but not least, the treatment of variables had no formal background and had not been proved to be sound with respect to the important property of domain independence (Bria et al. 2008) \u2013 essentially, a program is domain independent when its stable models do not vary under the arbitrary addition of new constants.", "startOffset": 171, "endOffset": 189}, {"referenceID": 9, "context": "org/stelp_online 2 This definition of safety, initially introduced in DLV (Leone et al. 2006) has been adopted in the standard ASP-Core-2 (Calimeri et al.", "startOffset": 74, "endOffset": 93}, {"referenceID": 6, "context": "2006) has been adopted in the standard ASP-Core-2 (Calimeri et al. 2015) and also followed by Gringo (Gebser et al.", "startOffset": 50, "endOffset": 72}, {"referenceID": 7, "context": "2015) and also followed by Gringo (Gebser et al. 2011).", "startOffset": 34, "endOffset": 54}, {"referenceID": 13, "context": "A property of TEL directly inherited from Equilibrium Logic (see Proposition 5 in (Pearce 2006)) is the following:", "startOffset": 82, "endOffset": 95}, {"referenceID": 1, "context": "Theorem 1 (Theorem 1 in (Aguado et al. 2011)) \u3008T,T\u3009 is a temporal equilibrium model of \u03a0 iff {\u00a9p | p \u2208 Ti, i \u2265 0} is a stable model of \u03a0 under the (infinite) signature {\u00a9p | p \u2208 At}.", "startOffset": 24, "endOffset": 44}, {"referenceID": 5, "context": "Although an unsafe rule does not always lead to lack of domain independence (see examples in (Cabalar et al. 2009)) it is frequently the case.", "startOffset": 93, "endOffset": 114}], "year": 2016, "abstractText": "In this note we consider the problem of introducing variables in temporal logic programs under the formalism of Temporal Equilibrium Logic (TEL), an extension of Answer Set Programming (ASP) for dealing with linear-time modal operators. To this aim, we provide a definition of a first-order version of TEL that shares the syntax of first-order Linear-time Temporal Logic (LTL) but has a different semantics, selecting some LTL models we call temporal stable models. Then, we consider a subclass of theories (called splittable temporal logic programs) that are close to usual logic programs but allowing a restricted use of temporal operators. In this setting, we provide a syntactic definition of safe variables that suffices to show the property of domain independence \u2013 that is, addition of arbitrary elements in the universe does not vary the set of temporal stable models. Finally, we present a method for computing the derivable facts by constructing a non-temporal logic program with variables that is fed to a standard ASP grounder. The information provided by the grounder is then used to generate a subset of ground temporal rules which is equivalent to (and generally smaller than) the full program instantiation. Under consideration in Theory and Practice of Logic Programming (TPLP)", "creator": "LaTeX with hyperref package"}}}