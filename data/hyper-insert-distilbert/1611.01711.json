{"id": "1611.01711", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Nov-2016", "title": "Causes for Query Answers from Databases: Datalog Abduction, View-Updates, and Integrity Constraints", "abstract": "faulty causality has only been recently purposely introduced in databases, to model, characterize, and possibly compute causes for query answers. connections between automated qa - defect causality update and product consistency - based hybrid diagnosis and data database similarity repairs ( wrt. integrity response constraint violations ) naturally have already been established. embedded in this specialized work we indirectly establish all precise quality connections between qa - trait causality and enforce both natural abductive diagnosis patterns and eliminate the view - loss update consistency problem in databases, allowing easy us to easily obtain new algorithmic conclusion and complexity results for qa - causality. we probably also only obtain new results from on acquiring the complexity node of view - factor conditioned causality, retrieve and investigate the notion element of qa - causality rooted in the potential presence of identity integrity constraints, obtaining false complexity results such from introducing a connection with view - index conditioned dependence causality. the abduction complexity connection under integrity security constraints allows us users to obtain detailed algorithmic decision tools for qa - causality.", "histories": [["v1", "Sun, 6 Nov 2016 00:35:09 GMT  (87kb,D)", "http://arxiv.org/abs/1611.01711v1", "Journal submission. Extended version of Flairs'16 and UAI'15 WS on Causality papers"], ["v2", "Fri, 14 Jul 2017 23:02:08 GMT  (87kb,D)", "http://arxiv.org/abs/1611.01711v2", "Version after minor revisions (as requested by reviewers) for submission to International Journal of Approximate Reasoning. Extended version of \"Flairs'16\" and \"UAI'15 WS on Causality\" papers"], ["v3", "Mon, 31 Jul 2017 17:58:01 GMT  (86kb,D)", "http://arxiv.org/abs/1611.01711v3", "To appear in International Journal of Approximate Reasoning. Extended version of \"Flairs'16\" and \"UAI'15 WS on Causality\" papers"]], "COMMENTS": "Journal submission. Extended version of Flairs'16 and UAI'15 WS on Causality papers", "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["leopoldo bertossi", "babak salimi"], "accepted": false, "id": "1611.01711"}, "pdf": {"name": "1611.01711.pdf", "metadata": {"source": "CRF", "title": "Causes for Query Answers from Databases: Datalog Abduction, View-Updates, and Integrity Constraints", "authors": ["Leopoldo Bertossi", "Babak Salimi"], "emails": ["bertossi@scs.carleton.ca.", "imi@cs.washington.edu."], "sections": [{"heading": null, "text": "Causality has been recently introduced in databases, to model, characterize, and possibly compute causes for query answers. Connections between QAcausality and consistency-based diagnosis and database repairs (wrt. integrity constraint violations) have already been established. In this work we establish precise connections between QA-causality and both abductive diagnosis and the view-update problem in databases, allowing us to obtain new algorithmic and complexity results for QA-causality. We also obtain new results on the complexity of view-conditioned causality, and investigate the notion of QA-causality in the presence of integrity constraints, obtaining complexity results from a connection with view-conditioned causality. The abduction connection under integrity constraints allows us to obtain algorithmic tools for QA-causality.\nKeywords: Causality in databases, abductive diagnosis, view updates, delete propagation, integrity constraints"}, {"heading": "1. Introduction", "text": "Causality is an important concept that appears at the foundations of many scientific disciplines, in the practice of technology, and also in our everyday life. Causality is fundamental to understand and manage uncertainty in data, information, knowledge, and theories. In data management in particular, there is a need to represent, characterize and compute causes that explain why certain query results are obtained or not, or why natural semantic conditions, such as integrity constraints, are not satisfied, or not. Causality can also be used to explain the contents of a view, i.e. of a predicate with virtual contents that is defined in terms of other physical, materialized relations (tables).\nMost of the work on causality has been developed in the context of artificial intelligence [46] and Statistics [47], and little has been said about causality in\n1 Contact author. Carleton University, School of Computer Science, Ottawa, Canada. Email: bertossi@scs.carleton.ca.\n2 University of Washington, Computer Science & Engineering, Seattle, USA. Email: bsalimi@cs.washington.edu.\nPreprint submitted to Journal of LATEX Templates October 3, 2017\nar X\niv :1\n61 1.\n01 71\n1v 1\n[ cs\n.D B\n] 6\nN ov\ndata management. In this work we concentrate on causality as defined for- and applied to relational databases. In a world of big, uncertain data, the necessity to understand the data beyond direct query answers, introducing explanations in different forms, becomes particularly relevant.\nThe notion of causality-based explanation for a query result was introduced in [43], on the basis of the deeper concept of actual causation.3 We will refer to this notion as query-answer causality (or simply, QA-causality). Intuitively, a database atom (or tuple) \u03c4 is an actual cause for an answer a\u0304 to a conjunctive query Q from a relational instance D if there is a \u201ccontingent\u201d subset of tuples \u0393, accompanying \u03c4 , such that, after removing \u0393 from D, removing \u03c4 from Dr\u0393 causes a\u0304 to switch from being an answer to being a non-answer (i.e. not being an answer). Usually, actual causes and contingent tuples are restricted to be among a pre-specified set of endogenous tuples, which are admissible, possible candidates for causes, as opposed to exogenous tuples.\nA cause \u03c4 may have different associated contingency sets \u0393. Intuitively, the smaller they are the strongest is \u03c4 as a cause (it need less company to undermine the query answer). So, some causes may be stronger than others. This idea is formally captured through the notion of causal responsibility, and introduced in [43]. It reflects the relative degree of actual causality. In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities [44, 43].\nFurthermore, view-conditioned causality (in short, vc-causality) was proposed in [44, 45] as a restricted form of QA-causality, to determine causes for unexpected query results, but conditioned to the correctness of prior knowledge that cannot be altered by hypothetical tuple deletions.\nActual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.4 Causal responsibility was introduced in [13], to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.\nIn [55, 7] connections were established between QA-causality and database repairs [4], which allowed to obtain several complexity results for QA-causality related problems. Connections between QA-causality and consistency-based diagnosis [52] were established in [55, 7]. More specifically, QA-causality and causal responsibility were characterized in terms of consistency-based diagnosis, which led to new algorithmic results for QA-causality [55, 7]. In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced. We elaborate elaborate on this in the rest of this section.\nThe definition of QA-causality applies to monotone queries [43, 44]. How-\n3 In contrast with general causal claims, such as \u201csmoking causes cancer\u201d, which refer some sort of related events, actual causation specifies a particular instantiation of a causal relationship, e.g., \u201cJoe\u2019s smoking is a cause for his cancer\u201d.\n4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.\never, all complexity and algorithmic results in [43, 55] have been restricted to first-order (FO) monotone queries, mainly conjunctive queries. However, Datalog queries [11, 1], which are also monotone, but may contain recursion, require investigation in the context of QA-causality.\nIn contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29]. In particular, Datalog can be used as the specification language, giving rise to Datalog-abduction [29]. In this work we establish a relationship between Datalog-abduction and QAcausality, which allows us to obtain complexity results for QA-causality for Datalog queries.\nWe also explore fruitful connections between QA-causality and the classical and important view-update problem in databases [1], which is about updating a database through views. An important aspect of the problem is that one wants the base relations (sometimes called \u201cthe source database\u201d) to change in a minimal way while still producing the intended view updates. This is an update propagation problem, from views to base relations.\nThe delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views. If the views are defined by monotone queries, only source deletions can give an account of view deletions. When only a subset-minimal set of deletions from the base relations is expected to be performed, we are in the \u201cminimal source-side-effect\u201d case. The \u201cminimum source-side-effect\u201d case appears when that set is required to have a minimum cardinality. In a different case, we may want to minimize the side-effects on the view, requiring that other tuples in the (virtual) view contents are not affected (deleted) [10].\nIn this work we provide precise connections between QA-causality and different variants of the delete-propagation problem. In particular, we show that the minimal-source-side-effect deletion-problem and the minimum-source-sideeffect deletion-problem are related to QA-causality for monotone queries and the most-responsible cause problem, as investigated in [43, 55? ]. The minimumview-side-effect deletion-problem is related to vc-causality. We establish precise mutual characterizations (reductions) between these problems, obtaining in particular, new complexity results for view-conditioned causality.\nFinally, we also define and investigate the notion of query-answer causality in the presence of integrity constraints, which are logical dependencies between database tuples [1]. Under the assumption that the instance at hand satisfies a given set of ICs, the latter should have an effect on the causes for a query answer, and their computation. We show that they do, proposing a notion of QA-cause under ICs. But taking advantage of the connection with Datalog-abduction (this time under ICs on the extensional relations), we develop techniques to compute causes for query answers from Datalog queries in the presence of ICs.\nSummarizing, our main results are the following:\n1. We establish precise connections between QA-causality for Datalog queries and abductive diagnosis from Datalog specifications, i.e. mutual charac-\nterizations and computational reductions between them.\n2. We establich that, in contrast to (unions of) conjunctive queries, deciding tuple causality for Datalog queries is NP-complete in data.\n3. We identify a class of (possibly recursive) Datalog queries for which deciding causality is fixed-parameter tractable in combined complexity.\n4. We establish that deciding whether the causal responsibility of a tuple for a Datalog query-answer is greater than a given threshold is NP-complete in data.\n5. We establish mutual characterizations between QA-causality and different forms of delete-propagation as a view-update problem.\n6. We obtain that computing the size of the solution to a minimum-sourceside-effect deletion-problem is hard for the complexity class FPNP(log(n)), that of computational problems solvable in polynomial time (in data) by calling a logarithmic number of times an NP-oracle.\n7. We investigate in detail the problem of view-conditioned QA-causality (vc-causality), and we establish connections with the view-side-effect free delete propagation problem for view updates.\n8. We obtain that deciding if an answer has a vc-cause is NP-complete in data; that deciding tuple vc-causality is NP-complete in data; and deciding if the vc-causal responsibility of a tuple for a Datalog query-answer is greater than a given threshold is also NP-complete in data.\n9. We define the notion of QA-causality in the presence of integrity constraints (ICs), and investigate its properties. In particular, we make the case that the new property provides natural results.\n10. We obtain complexity results for QA-causality under ICs. In particular, we show that even for conjunctive queries, deciding tuple causality may become NP-hard under inclusion dependencies.\n11. We establish connections between QA-causality for Datalog queries under ICs and the view update problem and abduction from Datalog specifications, both under ICs. Through these connections we provide algorithmic results for computing causes for Datalog query answers under ICs.\nThis paper is structured as follows. Section 2 provides background material on relational databases and Datalog queries. Section 3 introduces the necessary concepts, known results, and the main computational problems for QAcausality. Section 4 introduces the abduction problem in Datlog specifications, and establishes its connections with QA-causality. Section 5 introduces the main problems related to updates trough views defined by monotone queries, and their connections with QA-causality problems. Section 6 defines and investigates view-conditioned QA-causality. Section 7 defines and investigates\nQA-causality under integrity constraints. Finally, Section 8 discusses some relevant related problems and draws final conclusions. The Appendix contains a couple of proofs that are not in the main body of the paper. This paper is an extension of both [56] and [57]."}, {"heading": "2. Preliminaries", "text": "We consider relational database schemas of the form S = (U,P), where U is the possibly infinite database domain and P is a finite set of database predicates of fixed arities.5 A database instance D compatible with S can be seen as a finite set of ground atomic formulas (a.k.a. atoms or tuples), of the form P (c1, ..., cn), where P \u2208 P has arity n, and c1, . . . , cn \u2208 U .\nA conjunctive query (CQ) is a formula of the first-order (FO) language L(S) associated to S, of the form Q(x\u0304) : \u2203y\u0304(P1(s\u03041)\u2227 \u00b7 \u00b7 \u00b7 \u2227Pm(s\u0304m)), where the Pi(s\u0304i) are atomic formulas, i.e. Pi \u2208 P, and the s\u0304i are sequences of terms, i.e. variables or constants of U . The x\u0304 in Q(x\u0304) shows all the free variables in the formula, i.e. those not appearing in y\u0304. A sequence c\u0304 of constants is an answer to query Q(x\u0304) if D |= Q[c\u0304], i.e. the query becomes true in D when the free variables are replaced by the corresponding constants in c\u0304. We denote the set of all answers from instance D to a conjunctive query Q(x\u0304) with Q(D).\nA conjunctive query is Boolean (a BCQ), if x\u0304 is empty, i.e. the query is a sentence, in which case, it is true or false in D, denoted by D |= Q and D 6|= Q, respectively. Accordingly, when Q is a BCQ, Q(D) = {yes} if Q is true, and Q(D) = \u2205, otherwise.\nA queryQ is monotone if for every two instances D1 \u2286 D2, Q(D1) \u2286 Q(D2), i.e. the set of answers grows monotonically with the instance. For example, CQs and unions of CQs (UCQs) are monotone queries. In this work we consider only monotone queries.\nAn integrity constraint (IC) is a sentence \u03d5 in the language L(S). For a given instance D for schema S, it may be true or false in D, which is denoted with D |= \u03d5, resp. D 6|= \u03d5. Given a set \u03a3 of integrity constraints, a database instance D is consistent if D |= \u03a3; otherwise it is said to be inconsistent. In this work we assume that sets of integrity constraints are always finite and logically consistent (i.e. they are all simultaneously true in some instance).\nA particular class of ICs is formed by inclusion dependencies (INDs), which are sentences of the form \u2200x\u0304(P (x\u0304) \u2192 \u2203y\u0304R(x\u0304\u2032, y\u0304)), with P,R predicates, x\u0304\u2032 \u2229 y\u0304 = \u2205, and x\u0304\u2032 \u2286 x\u0304. The tuple-generating dependencies (tgds) are ICs that generalize INDs, and are of the form \u2200x\u0304( \u2227 i Pi(x\u0304i) \u2192 \u2203y\u0304 \u2227 j Pj(x\u0304 \u2032 j , y\u0304j)), with Pi, Pj predicates, x\u0304 \u2032 j \u2286 \u22c3 x\u0304i = x\u0304, and y\u0304j \u2229 x\u0304 = \u2205.\nAnother special class of ICs is formed by functional dependencies (FDs). For example, \u03c8 : \u2200x\u2200y\u2200z(P (x, y) \u2227 P (x, z) \u2192 y = z) specifies that the second attribute of P functionally depends upon the first. (If A,B are the first and second attributes for P , the usual notation for this FD is P : A\u2192 B.) Actually,\n5 As opposed to built-in predicates, e.g. 6=, that we leave implicit, unless otherwise stated.\nthis FD is also a key constraint (KC), in the sense that the attribute(s) on the LHS of the arrow functionally determines all the other attributes of the predicate (cf. [1] for more details on ICs).\nGiven a relational schema S, queries Q1(x\u0304),Q2(x\u0304), and a set \u03a3 of ICs (all for schema schema S), Q1 and Q2 are equivalent wrt. \u03a3, denoted Q1 \u2261\u03a3 Q2, iff Q1(D) = Q2(D) for every instance D for S that satisfies \u03a3. One can define in similar terms the notion of query containment under ICs, denoted Q1 \u2286\u03a3 Q2.\nA Datalog query Q(x\u0304) is a whole program \u03a0 consisting of positive Horn rules (a.k.a. positive definite rules), of the form P (t\u0304)\u2190 P1(t\u03041), . . . , Pn(t\u0304n), with the Pi(t\u0304i) atomic formulas. All the variables in t\u0304 appear in some of the t\u0304i. Here, n \u2265 0, and if n = 0, P (t\u0304) is called a fact and does not contain variables. We assume the facts are those stored in an underlying extensional database D.\nWe may assume that a Datalog program \u03a0 as a query defines an answercollecting predicate Ans(x\u0304) by means of a top rule of the form Ans(t\u0304) \u2190 P1(t\u03041), . . . , Pm(t\u0304m), where all the predicates in the RHS (a.k.a. as the rule body) are defined by other rules in \u03a0 or are database predicates for D. Here, the t\u0304, t\u0304i are lists of variables or constants, and the variables in t\u0304 belong to \u22c3 i t\u0304i.\nNow, a\u0304 is an answer to query \u03a0 onD when \u03a0\u222aD |= Ans(a\u0304). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. So, the extension, Ans(\u03a0 \u222aD), of predicate Ans contains the answers to the query in the minimal model of the program (including the database). The Datalog query is Boolean if the top answer-predicate is propositional, with a definition of the form ans \u2190 P1(s\u03041), . . . , Pm(s\u0304m). In this case, the query is true if \u03a0\u222aD |= ans, equivalently, if ans belongs to the minimal model of \u03a0 \u222aD [1, 11].\nDatalog queries may contain recursion, and then they may not be FO [1, 11]. However they are also monotone."}, {"heading": "3. QA-Causality and its Decision Problems", "text": "In this section we review the notion of QA-causality as introduced in [43]. We also summarize the main decision and computational problems that emerge in this context and the established results for them."}, {"heading": "3.1. Causality and responsibility", "text": "In the rest of this work, unless otherwise stated, we assume that a relational database instance D is split in two disjoint sets, D = Dn \u222aDx, where Dn and Dx are the sets of endogenous and exogenous tuples, respectively.\nA tuple \u03c4 \u2208 Dn is a counterfactual cause for an answer a\u0304 to Q(x\u0304) in D if D |= Q(a\u0304), but D r {\u03c4} 6|= Q(a\u0304). A tuple \u03c4 \u2208 Dn is an actual cause for a\u0304 if there exists \u0393 \u2286 Dn, called a contingency set, such that \u03c4 is a counterfactual cause for a\u0304 in D r \u0393. Causes(D,Q(a\u0304)) denotes the set of actual causes for a\u0304. If Q is Boolean, Causes(D,Q) contains the causes for answer yes. For \u03c4 \u2208 Causes(D,Q(a\u0304)), Cont(D,Q(a\u0304), \u03c4) denotes the set of contingency sets for \u03c4 as a cause for Q(a\u0304) in D.\nNotice that Causes(D,Q(a\u0304)) is non-empty when D |= Q(a\u0304), but Dx 6|= Q(a\u0304), reflecting the fact that endogenous tuples are required for the answer.\nGiven a \u03c4 \u2208 Causes(D,Q(a\u0304)), we collect all subset-minimal contingency sets associated with \u03c4 :\nConts(D,Q(a\u0304), \u03c4) := {\u0393 \u2286 Dn | D r \u0393 |= Q(a\u0304), D r (\u0393 \u222a {\u03c4}) 6|= Q(a\u0304), and \u2200\u0393\u2032 $ \u0393, D r (\u0393\u2032 \u222a {\u03c4}) |= Q(a\u0304)}.\nThe causal responsibility of a tuple \u03c4 for answer a\u0304, denoted with \u03c1D Q(a\u0304) (\u03c4), is 1 (|\u0393|+1) , where |\u0393| is the size of the smallest contingency set for \u03c4 . When \u03c4 is not an actual cause for a\u0304, no contingency set is associated to \u03c4 . In this case, \u03c1D Q(a\u0304) (\u03c4) is defined as 0.\nExample 1. Consider an instance D with relations Author(AName, JName) and Journal(JName, Topic, Paper#), and contents as below:\nAuthor AName JName\nJoe TKDE John TKDE Tom TKDE John TODS\nJournal JName Topic Paper#\nTKDE XML 30 TKDE CUBE 31 TODS XML 32\nThe following conjunctive query:\nQ(AName,Topic) : \u2203JName \u2203Paper#(Author(AName, JName) \u2227 (1) Journal(JName,Topic,Paper#))\nhas the following answers:\nQ(D) AName Topic Joe XML Joe CUBE Tom XML Tom CUBE John XML John CUBE\nAssume \u3008John,XML\u3009 is an unexpected answer to Q. That is, it is not likely that John has a paper on XML. Now, we want to compute causes for this unexpected observation. For the moment assume all tuples in D are endogenous.\nIt holds that Author(John, TODS) is an actual cause for answer \u3008John,XML\u3009. Actually, it has two contingency sets, namely: \u03931 = {Author(John,TKDE)} and \u03932={Journal(TKDE,XML, 32)}. That is, Author(John,TODS) is a counterfactual cause for \u3008John,XML\u3009 in both Dr\u03931 and Dr\u03932. Moreover, the responsibility of Author(John,TODS) is 12 , because its minimum-cardinality contingency sets have size 1.\nTuples Journal(TKDE,XML, 32), Author(John,TKDE) and Journal(TODS, XML, 32) are also actual causes for \u3008John,XML\u3009, with responsibility 12 .\nFor more subtle situation, assume only Author tuples are endogenous, possibly reflecting the fact that the data in Journal table are more reliable than those in the Author table. Under this assumption, the only actual causes for answer \u3008John,XML\u3009 are Author(John,TKDE) and Author(John,TODS).\nThe definition of QA-causality can be applied without any conceptual changes to Datalog queries. Actually, CQs can be expressed as Datalog queries. For example, (1) can be expressed in Datalog as:\nAnsQ(AName,Topic)\u2190 Author(AName, JName), Journal(JName,Topic,Paper#), with the auxiliary predicate AnsQ collecting the answers to query Q. In the case of Datalog, we sometimes use the notation Causes(D,\u03a0(a\u0304)) for the set of causes for answer a\u0304 (and simply Causes(D,\u03a0) when \u03a0 is Boolean).\nExample 2. Consider the instance D with a single binary relation E as below (t1-t7 are tuple identifiers). Assume all tuples are endogenous.\nE A B t1 a b t2 b e t3 e d t4 d b t5 c a t6 c b t7 c d\nInstance D can be represented as the directed graph G(V, E) in Figure 1, where the set of vertices V coincides with the active domain of D (i.e. the set of constants in E). The set of edges E contains (v1, v2) iff E(v1, v2) \u2208 D. The tuple identifiers are used as labels for the corresponding edges, and also to refer to the database tuples.\nConsider the recursive Datalog query \u03a0:\nAns(x, y) \u2190 P (x, y) P (x, y) \u2190 E(x, y) P (x, y) \u2190 P (x, z), E(z, y),\nwhich collects pairs of vertices of G that are connected through a path. Since \u03a0\u222aD |= Ans(c, e), we have \u3008c, e\u3009 as an answer to query \u03a0 on D. This is because there are three distinct paths between c and e in G. All tuples except for t3 are actual causes for this answer: Causes(E,\u03a0(c, e)) = {t1, t2, t4, t5, t6, t7}. We can see that all of these tuples contribute to at least one path between c and\ne. Among them, t2 has the highest responsibility, because, t2 is a counterfactual cause for the answer, i.e. it has an empty contingency set.\nThe complexity of the computational and decision problems that arise in QA-causality have been investigated in [43, 55]. Here we recall those results that we will use throughout this work. The first problem is about deciding whether a tuple is an actual cause for a query answer.\nDefinition 1. For a Boolean monotone query Q, the causality decision problem (CDP) is (deciding about membership of): CDP(Q) := {(D, \u03c4) | \u03c4 \u2208 Dn, and \u03c4 \u2208 Causes(D,Q)}.\nThis problem is tractable for UCQs [55]. The next problem is about deciding if the responsibility of a tuple as a cause for a query answer is above a given threshold.\nDefinition 2. For a Boolean monotone query Q, the responsibility decision problem (RDP) is (deciding about membership of): RDP(Q) = {(D, \u03c4, v) | \u03c4 \u2208 Dn, v \u2208 {0} \u222a\n{ 1k | k \u2208 N +}, D |= Q and \u03c1D Q (\u03c4) > v}.\nThis problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43]. Roughly speaking, a CQ is linear if its atoms can be ordered in a way that every variable appears in a continuous sequence of atoms that does not contain a self-join (i.e. a join involving the same predicate), e.g. \u2203xvyu(A(x) \u2227 S1(x, v) \u2227 S2(v, y) \u2227 R(y, u) \u2227 S3(y, z)) is linear, but not \u2203xyz(A(x) \u2227B(y) \u2227 C(z) \u2227W (x, y, z)), for which RDP is NP-complete [43].\nThe functional, non-decision, version of RDP is about computing responsibilities. This optimization problem is complete (in data) for FPNP(log(n)) for UCQs [55]. Finally, we have the problem of deciding whether a tuple is a most responsible cause:\nDefinition 3. For a Boolean monotone query Q, the most responsible cause decision problem is: MRCD(Q) = {(D, \u03c4) | \u03c4 \u2208 Dn and 0 < \u03c1DQ(\u03c4) is a maximum for D}.\nFor UCQs this problem is complete for PNP(log(n)) [55]. Hardness already holds for a CQ.\nA notion of view-conditioned causality [44] will be formalized and investigated in Section 6."}, {"heading": "4. Causality and Abduction", "text": "In general logical terms, an abductive explanation for an observation is a formula that, together with a background logical theory, entails the observation. Although one could see an abductive explanation as a cause for the observation, it has been argued that causes and abductive explanations are not necessarily the same [50, 21].\nUnder the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules. By restricting the explanation formulas to the predicates describing primitive causes (action executions), an explanation formula which entails an observation gives also a cause for the observation [21]. In this case, and is some sense, causality information is imposed by the system specifier [48].\nIn database causality we do not have, at least not initially, a system description,6 but just a set of tuples. It is when we pose a query that we create something like a description, and the causal relationships between tuples are captured by the combination of atoms in the query. If the query is a Datalog query (in particular, a CQ), we have a specification in terms of positive definite rules.\nIn this section we will first establish connections between abductive diagnosis and database causality.7 We start by making precise the kind of abduction problems we will consider."}, {"heading": "4.1. Background on Datalog abductive diagnosis", "text": "A Datalog abduction problem [23] is of the form AP = \u3008\u03a0, E,Hyp,Obs\u3009, where: (a) \u03a0 is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), (c) Hyp, the hypothesis, is a finite set of ground atoms, the abducible atoms in this case,8 and (d) Obs, the observation, is a finite conjunction of ground atoms. As it is common, we will start with the assumption that \u03a0\u222aE\u222aHyp |= Obs. \u03a0\u222aE is called the background theory (or specification).\nDefinition 4. Consider a Datalog abduction problem AP = \u3008\u03a0, E,Hyp,Obs\u3009. (a) An abductive diagnosis (or simply, a solution) for AP is a subset-minimal\n\u2206 \u2286 Hyp, such that \u03a0 \u222a E \u222a\u2206 |= Obs. This requires that no proper subset of \u2206 has this property.9 Sol(AP) denotes the set of abductive diagnoses for problem AP.\n(b) A hypothesis h \u2208 Hyp is relevant for AP if h contained in at least one diagnosis of AP, otherwise it is irrelevant. Rel(AP) collects all relevant hypothesis for AP.\n(c) A hypothesis h \u2208 Hyp is necessary for AP if h contained in all diagnosis of AP. Ness(AP) collects all the necessary hypothesis for AP.\n6 Having integrity constraints would go in that direction, but this is something that has not been considered in database causality so far. See [55, sec. 5] for a consistency-based diagnosis connection, where the DB is turned into a theory.\n7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52]. For relationships and comparisons between consistency-based and abductive diagnosis see [17].\n8 It is common to accept as hypothesis all the possible ground instantiations of abducible predicates. We assume abducible predicates do not appear in rule heads.\n9 Of course, other minimality criteria could take this place.\nNotice that for a problem AP, Sol(AP) is never empty due to the assumption \u03a0 \u222aD \u222aHyp |= Obs. In case, \u03a0 \u222aD |= Obs, it holds Sol(AP) = {\u2205}.\nExample 3. Consider the digital circuit in Figure 2. The inputs are a = 1, b = 0, c = 1, but the output is d = 0. So, the circuit is not working properly. The diagnosis problem is formulated below as a Datalog abduction problem whose data domain is {a, b, c, d, e, and, or}. The underlying, extensional database is as follows: E = {One(a),Zero(b), One(c),And(a, b, e, and),Or(e, c, d, or}.\nThe Datalog program \u03a0 contains rules that model the normal and the faulty behavior of each gate. We show only the Datalog rules for the And gate. For its normal behavior, we have the following rules:\nOne(O) \u2190 And(I1, I2, O,G),One(I1),One(I2) Zero(O) \u2190 And(I1, I2, O,G),One(I1),Zero(I2) Zero(O) \u2190 And(I1, I2, O,G),Zero(I1),One(I2) Zero(O) \u2190 And(I1, I2, O,G),Zero(I1),One(I2).\nThe faulty behavior is modeled by the following rules:\nZero(O) \u2190 And(I1, I2, O,G),One(I1),One(I2),Faulty(G) One(O) \u2190 And(I1, I2, O,G),One(I1),Zero(I2),Faulty(G) One(O) \u2190 And(I1, I2, O,G),Zero(I1),One(I2),Faulty(G) One(O) \u2190 And(I1, I2, O,G),Zero(I1),One(I2),Faulty(G)\nFinally, we consider Obs : Zero(d), and Hyp = {Faulty(and),Faulty(or)}. The abduction problem consists in finding minimal \u2206 \u2286 Hyp, such that \u03a0\u222aE\u222a\u2206 |= Zero(d). There is one abductive diagnosis: \u2206 = {Faulty(or)}.\nIn the context of Datalog abduction, we are interested in deciding, for a fixed Datalog program, if a hypothesis is relevant/necessary or not, with all the data as input. More precisely, we consider the following decision problems.\nDefinition 5. Given a Datalog program \u03a0, (a) The necessity decision problem (NDP) for \u03a0 is (deciding about the membership of):\nNDP(\u03a0) = {(E ,Hyp,Obs, h) | h \u2208 Ness(AP),with AP = \u3008\u03a0, E,Hyp,Obs\u3009}. (b) The relevance decision problem (RLDP) for \u03a0 is (deciding about the membership of):\nRLDP(\u03a0) = {(E ,Hyp,Obs, h) | h \u2208 Rel(AP),with AP = \u3008\u03a0, E,Hyp,Obs\u3009}.\nAs it is common, we will assume that |Obs|, i.e. the number of atoms in the conjunction, is bounded above by a fixed parameter p. In many cases, p = 1 (a single atomic observation).\nThe last two definitions suggest that we are interested in the data complexity of the relevance and necessity decision problems for Datalog abduction. That is, the Datalog program is fixed, but the data consisting of hypotheses and input structure E may change. In contrast, under combined complexity the program is also part of the input, and the complexity is measured also in terms of the program size.\nA comprehensive complexity analysis of several reasoning tasks on abduction from propositional logic programs, in particular of the relevance and necessity problems, can be found in [23]. Those results are all in combined complexity. In [23], it has been shown that for abduction from function-free first-order logic programs, the data complexity of each type of reasoning problem in the firstorder case coincides with the complexity of the same type of reasoning problem in the propositional case. In this way, the next two results can be obtained for NDP and RLDP from [23, the. 26] and the complexity of these problems for propositional Horn abduction (PDA), established in [24]. In the Appendix we provide direct, ad hoc proofs by adapting the full machinery developed in [23] for general programs.\nProposition 1. For every Datalog program, \u03a0, NDP(\u03a0) is in PTIME (in data).\nProposition 2. For Datalog programs \u03a0,RLDP(\u03a0) is NP-complete (in data).10\nIt is clear from this result that deciding relevance for Datalog abduction is also intractable in combined complexity. However, a tractable case of combined complexity is identified in [29], on the basis of the notions of tree-decomposition and bounded tree-width, which we now briefly present.\nLet H = \u3008V,H\u3009 be a hypergraph, where V is the set of vertices, and H is the set of hyperedges, i.e. of subsets of V . A tree-decomposition of H is a pair (T , \u03bb), where T = \u3008N,E\u3009 is a tree and \u03bb is a labeling function that assigns to each node n \u2208 N , a subset \u03bb(n) of V (\u03bb(n) is aka. bag), i.e. \u03bb(n) \u2286 V , such\n10 More precisely, this statement (and others of this kind) means: (a) For every Datalog program \u03a0, RLDP(\u03a0) \u2208 NP ; and (b) there are programs \u03a0\u2032 for which RLDP(\u03a0\u2032) is NP-hard (all this in data).\nthat, for every node n \u2208 N , the following hold: (a) For every v \u2208 V , there exists n \u2208 N with v \u2208 \u03bb(n). (b) For every h \u2208 H, there exists a node n \u2208 N with h \u2286 \u03bb(n). (c) For every v \u2208 V , the set of nodes {n | v \u2208 \u03bb(n)} induces a connected subtree of T .\nThe width of a tree decomposition (T , \u03bb) of H = \u3008V,H\u3009, with T = \u3008N,E\u3009, is defined as max{|\u03bb(n)| \u2212 1 : n \u2208 N}. The tree-width tw(H) of H is the minimum width over all its tree decompositions.\nIntuitively, the tree-width of a hypergraph H is a measure of the \u201ctreelikeness\u201d of H. A set of vertices that form a cycle in H are put into a same bag, which becomes (the bag of a) node in the corresponding tree-decomposition. If the tree-width of the hypergraph under consideration is bounded by a fixed constant, then many otherwise intractable problems become tractable [28].\nIt is possible to associate an hypergraph to any finite structure D (think of a relational database): If its universe (the active domain in the case of a relational database) is V , define the hypergraph H(D) = (V,H), with H = { {a1, . . . , an} | D contains a ground atom P (a1 . . . an) for some predicate symbol P}.\nExample 4. Consider instance D in Example 1. The hypergraph H(D) associated to D is shown in Figure 3(a). Its vertices are the elements of Adom(D) = {John, Joe,Tom,TODS,TKDE,XML,CUBE, 30, 31, 32}, the active domain of D. For example, since Journal(TKDE,XML, 30) \u2208 D, {TKDE,XML, 30} is one of the hyperedges.\nThe dashed ovals show four sets of vertices, i.e. hyperedges, that together form a cycle. Their elements are put into the same bag of the tree-decomposition. Figure 3(b) shows a possible tree-decomposition of H(D). In it, the maximum |\u03bb(n)|\u22121 is 6\u22121, corresponding to the top box bag of the tree. So, tw(H(D)) \u2264 5.\nThe following is a fixed-parameter tractability result for the relevance decision problem for Datalog abduction for guarded programs \u03a0, where in every rule body there is an atom that contains (guards) all the variables appearing in that body.\nTheorem 1. [29, theo. 7.9] Let k be an integer. For Datalog abduction problems AP = \u3008\u03a0, E,Hyp,Obs\u3009 where \u03a0 is guarded, and tw(H(E)) \u2264 k, relevance can be decided in polynomial time in |AP|. More precisely, the following decision problem is tractable: RLDP = {(\u3008\u03a0,E ,Hyp,Obs\u3009, h) | h \u2208 Rel(\u3008\u03a0,E ,Hyp,Obs\u3009), h \u2208 Hyp,\n\u03a0 is guarded, and tw(H(E)) \u2264 k}.\nThis is a case of tractable combined complexity with a fixed parameter that is the tree-width of the extensional database.\nIn the rest of this section we assume, unless otherwise stated, that we have a partitioned relational instance D = Dx \u222aDn."}, {"heading": "4.2. Actual causes from abductive diagnoses", "text": "In this section we show that, for Datalog system specifications, abductive inference corresponds to actual causation. That is, abductive diagnoses for an observation essentially contain actual causes for the observation.\nConsider that \u03a0 is a Boolean, possibly recursive Datalog query; and assume that \u03a0 \u222aD |= ans. Then, the decision problem in Definition 1 takes the form:\nCDP(\u03a0) := {(D, \u03c4) | \u03c4 \u2208 Dn, and \u03c4 \u2208 Causes(D,\u03a0)}. (2)\nWe now show that actual causes for ans can be obtained from abductive diagnoses of the associated causal Datalog abduction problem (CDAP): APc := \u3008\u03a0, Dx, Dn, ans\u3009, where Dx takes the role of the extensional database for \u03a0. Accordingly, \u03a0 \u222a Dx becomes the background theory, Dn becomes the set of hypothesis, and atom ans is the observation.\nProposition 3. For an instance D = Dx \u222a Dn and a Boolean Datalog query \u03a0, with \u03a0 \u222aD |= ans, and its associated CDAP APc, the following hold:\n(a) \u03c4 \u2208 Dn is an counterfactual cause for ans iff \u03c4 \u2208 Ness(APc).\n(b) \u03c4 \u2208 Dn is an actual cause for ans iff \u03c4 \u2208 Rel(APc).\nProof: Part (a) is straightforward. To proof part (b), first assume \u03c4 is an actual cause for ans. According to the definition of an actual cause, there exists a contingency set \u0393 \u2286 Dn such that \u03a0\u222aDr\u0393 |= ans but \u03a0\u222aDr(\u0393\u222a{\u03c4}) 6|= ans. This implies that there exists a set \u2206 \u2286 Dn with \u03c4 \u2208 \u2206 such that \u03a0 \u222a \u2206 |= ans. It is easy to see that \u2206 is an abductive diagnosis for APc. Therefore, \u03c4 \u2208 Rel(APc).\nSecond, assume \u03c4 \u2208 Rel(APc). Then there exists a set Sk \u2208 Sol(APc) = {s1 . . . sn} such that Sk |= ans with \u03c4 \u2208 Sk. Obviously, Sol(APc) is a collection of subsets of Dn. Pick a set \u0393 \u2286 Dn such that for all Si \u2208 Sol(APc) i 6= k, \u0393 \u2229 Si 6= \u2205 and \u0393 \u2229 Sk = \u2205. It is clear that \u03a0 \u222a D r (\u0393 \u222a {t}) 6|= ans but \u03a0\u222aDr\u0393 |= ans. Therefore, \u03c4 is an actual cause for ans. To complete the proof we need to show that such \u0393 always exists. This can be done by applying the digitalization technique to construct such \u0393. Since all elements of Sol(APc) are\nsubset-minimal, then, for each Si \u2208 Sol(APc) with i 6= k, there exists a \u03c4 \u2032 \u2208 Si such that \u03c4 \u2032 6\u2208 Sk. So, \u0393 can be obtained from the union of differences between each Si (i 6= k) and Sk.\nExample 5. Consider the instance D with relations R and S as below, and the\nquery \u03a0 : ans \u2190 R(x, y), S(y), which is true in D. Assume all tuples are endogenous.\nR A B a1 a4 a2 a1 a3 a3\nS B a1 a2 a3\nIn this case, APc = \u3008\u03a0, \u2205, D, ans\u3009, which has two (subset-minimal) abductive diagnoses: \u22061 = {S(a1), R(a2, a1)} and \u22062 = {S(a3), R(a3, a3)}. Then, Rel(APc) = {S(a3), R(a3, a3), S(a1), R(a2, a1)}. It is easy to see that the relevant hypothesis are actual causes for ans."}, {"heading": "4.3. Causal responsibility and abductive diagnosis", "text": "In the previous section we showed that counterfactual and actual causes for Datalog query answers appear as necessary and relevant hypotheses in the associated Datalog abduction problem. The form causal responsibility takes in Datalog abduction is less direct. Actually, we first show that causal responsibility inspires an interesting concept for Datalog abduction, that of degree of necessity of a hypothesis.\nExample 6. (ex. 5 cont.) Consider nowD\u2032 = {R(a1, a3), R(a2, a3), S(a3)}, and APc = \u3008\u03a0, \u2205, D\u2032, ans\u3009. APc has two abductive diagnosis: \u22061 = {S(a3), R(a1, a3)} and \u22062 = {S(a3), R(a2, a3)}.\nHere, Ness(APc) = {S(a3)}, i.e. only S(a3) is necessary for abductively explaining ans. However, this is not capturing the fact that R(a1, a3) or R(a3, a3) are also needed as a part of the explanation.\nThis example suggests that necessary hypotheses might be better captured as sets of them rather than as individuals.\nDefinition 6. Given a DAP, AP = \u3008\u03a0, E,Hyp,Obs\u3009, N \u2286 Hyp is a necessaryhypothesis set if: (a) for AP\u2212N := \u3008\u03a0, E,Hyp r N,Obs\u3009, Sol(AP\u2212N ) = \u2205, and (b) N is subset-minimal, i.e. no proper subset of N has the previous property.\nIt is easy to verify that a hypothesis h is necessary according to Definition 4 iff {h} is a necessary-hypothesis set.\nIf we apply Definition 6 to APc in Example 6, we obtain two necessaryhypothesis sets: N1 = {S(a3)} and N2 = {R(a1, a3), R(a2, a3)}. In this case, it makes sense to claim that S(a3) is more necessary for explaining ans than the other two tuples, that need to be combined. Actually, we can think of ranking hypothesis according to the minimum cardinality of necessary-hypothesis sets where they are included.\nDefinition 7. Given a DAP, AP = \u3008\u03a0, E,Hyp,Obs\u3009, the necessity-degree of a hypothesis h \u2208 Hyp is \u03b7AP(h) := 1|N | where, N is a minimum-cardinality necessary-hypothesis set with h \u2208 N . If h does not belong to any necessary hypothesis set, \u03b7AP(h) := 0.\nExample 7. (ex. 6 cont.) We have \u03b7APc(S(a3)) = 1 and \u03b7APc(R(a2, a3)) = \u03b7APc(R(a1, a3)) = 1 2 . Now, if we consider the original Datalog query in the causality setting, where \u03a0\u222aD\u2032 |= ans, then S(a3), R(a2, a3), R(a1, a3) are all actual causes, with responsibilities: \u03c1D\n\u03a0 (S(a3)) = 1, \u03c1 D \u03a0 (R(a2, a3)) = \u03c1 D \u03a0\n(R(a1, a3)) = 12 . This is not a coincidence. In fact the notion of causal responsibility is in correspondence with the notion of necessity degree in the Datalog abduction setting.\nProposition 4. Let D = Dx \u222aDn be an instance and \u03a0 be a Boolean Datalog query with \u03a0 \u222aD |= ans, and APc its associated CDAP. For \u03c4 \u2208 Dn, it holds: \u03b7APc(\u03c4) = \u03c1 D \u03a0 (\u03c4).\nProof: It is easy to verify that each actual cause, together with a contingency set, forms a necessary hypothesis set for the corresponding causal Datalog abduction setting (and the other way around). Then, the two values are in correspondence.\nNotice that the notion of necessity-degree is interesting and applicable to general abduction from logical theories, that may not necessarily represent causal knowledge about a domain. In this case, the necessity-degree is not a causality-related notion, and merely reflects the extent by which a hypothesis is necessary for making an observation explainable within an abductive theory."}, {"heading": "4.4. Abductive diagnosis from actual causes", "text": "Now we show, conversely, that QA-causality can capture Datalog abduction. In particular, we show that abductive diagnoses from Datalog programs are formed essentially by actual causes for the observation. More precisely, consider a Datalog abduction problem AP = \u3008\u03a0, E,Hyp,Obs\u3009, where E is the underlying extensional database, and Obs is a conjunction of ground atoms. For this we need to construct a QA-causality setting.\nProposition 5. Let AP = \u3008\u03a0, E,Hyp,Obs\u3009 be a Datalog abduction problem, and h \u2208 Hyp. It holds that h is a relevant hypothesis for AP, i.e. h \u2208 Rel(AP), iff h is an actual cause for the associated Boolean Datalog query \u03a0c := \u03a0 \u222a {ans \u2190 Obs} being true in D := Dx \u222a Dn with Dx := E, and Dn := Hyp. Here, ans is a fresh propositional atom.\nThe proof is similar to that of Proposition 3.\nExample 8. (ex. 3 cont.) For the given DAP AP, we construct a QA-causality setting as follows. Consider the instance D with relations And, Or, Faulty , One and Zero, as below, and the Boolean Datalog query \u03a0c : \u03a0 \u222a {ans \u2190 Zero(d)}, where \u03a0 is the Datalog program in Example 3.\nAnd I1 I2 O G a b e and\nZero I b\nOr I1 I2 O G e c d or\nOne I a c\nFaulty G and or\nIt clear that \u03a0c \u222a D |= ans. D is partitioned into the set of endogenous tuples Dn := {Faulty(and), Faulty(or)} and the set of exogenous tuples Dx := D rDn.\nIt is easy to verify that this result has only one actual cause, namely Faulty(or) (with responsibility 1), confirming the correspondence with Example 3 as stated in Proposition 5."}, {"heading": "4.5. Complexity of causality for Datalog queries", "text": "Now we use the results obtained so far in this section to obtain new complexity results for Datalog QA-causality. We first consider the problem of deciding if a tuple is a counterfactual cause for a query answer.\nA counterfactual cause is a tuple that, when removed from the database, undermines the query-answer, without having to remove other tuples, as is the case for actual causes. Actually, for each of the latter there may be an exponential number of contingency sets, i.e. of accompanying tuples [55]. Notice that a counterfactual cause is an actual cause with responsibility 1.\nDefinition 8. For a Boolean monotone query Q, the counterfactual causality decision problem (CFDP) is (deciding about membership of):\nCFDP(Q) := {(D, \u03c4) | \u03c4 \u2208 Dn and \u03c1D Q (\u03c4) = 1}.\nThe complexity of this problem can be obtained from the connection between counterfactual causation and the necessity of hypothesis in Datalog abduction via Propositions 1 and 3.\nProposition 6. For Boolean Datalog queries \u03a0, CFDP(\u03a0) is in PTIME (in data).\nProof: Directly from Propositions 1 and 3.\nNow we address the complexity of the actual causality problem for Datalog queries. The following result is obtained from Propositions 2 and 5.\nProposition 7. For Boolean Datalog queries \u03a0, CDP(\u03a0) is NP-complete (in data).\nProof: To show the membership of NP, consider an instance D = Dn\u222aDx and a tuple \u03c4 \u2208 Dn. To check if (D, \u03c4) \u2208 CDP(\u03a0) (equivalently \u03c4 \u2208 Causes(D,\u03a0)), non-deterministically guess a subset \u0393 \u2286 Dn, return yes if \u03c4 is a counterfactual cause for Q(a\u0304) in D r \u0393, and no otherwise. By Proposition 6 this can be done in polynomial time.\nThe NP-hardness is obtained by a reduction from the relevance problem for Datalog abduction to causality problem, as given in Proposition 5.\nThis result should be contrasted with the tractability of the same problem for UCQs [55]. In the case of Datalog, the NP-hardness requires a recursive query. This can be seen from the proof of Proposition 7, which appeals in the end to the NP-hardness in Proposition 2, whose proof uses a recursive query (program) (cf. the query given by (A.1)-(A.2) in the Appendix).\nWe now introduce a fixed-parameter tractable case of the actual causality problem. Actually, we consider the \u201ccombined\u201d version, CDP, of the decision problem in Definition 1, where both the Datalog query and the instance are part of the input. For this, we take advantage of the tractable case of Datalog abduction presented in Section 4.1. The following is an immediate consequence of Theorem 1 and Proposition 3.\nProposition 8. For a guarded Boolean Datalog query \u03a0, an instance D = Dx\u222a Dn, with Dx of bounded tree-width, and \u03c4 \u2208 Dn, deciding if \u03c4 \u2208 Causes(D,\u03a0) is fixed-parameter tractable (in combined complexity), and the parameter is the tree-width bound.\nFinally, we establish the complexity of the responsibility problem for Datalog queries.\nProposition 9. For Boolean Datalog queries \u03a0, RDP(\u03a0) is NP-complete.\nProof: To show membership of NP, consider an instance D = Dn \u222a Dx, a tuple \u03c4 \u2208 Dn, and a responsibility bound v. To check if \u03c1D\n\u03a0 (\u03c4) > v, non-\ndeterministically guess a set \u0393 \u2286 Dn and check if \u0393 is a contingency set and \u0393 < 1v . The verification can be done in polynomial time. Hardness is obtain from the NP-completeness of RDP for conjunctive queries established in [55]."}, {"heading": "5. Causality and View-Updates", "text": "There is a close relationship between QA-causality and the view-update problem in the form of delete-propagation. It was first suggested in [38, 39], and here we investigate it more deeply. We start by formalizing some computational problems related to the general delete-propagation problem that are interesting from the perspective of QA-causality."}, {"heading": "5.1. Background on delete-propagation", "text": "Given a monotone query Q, we can think of it as defining a view, V, with virtual contents Q(D). If a\u0304 \u2208 Q(D), which may not be intended, we may try to delete some tuples from D, so that a\u0304 disappears from Q(D). This is a particular case of database updates through views [1], and may appear in different and natural formulations. The next example shows one of them.\nExample 9. Consider relational predicates GroupUser(User ,Group) and GroupFile(File,Group), with extensions as in instance D below. They represent users\u2019 memberships of groups, and access permissions for groups to files, respectively.11\nGroupUser User Group\nJoe g1 Joe g2 John g1 Tom g2 Tom g3 John g3\nGroupFiles File Group\nf1 g1 f1 g3 f2 g2 f3 g3\nIt is expected that a user u can access file f if u belongs to a group that can access f , i.e. there is some group g such that GroupUser(u, g) and GroupFile(f, g) hold. Accordingly, we can define a view that collects users with the files they can access, as defined by the following query:\nAccess(User ,File) \u2190 GroupUser(User ,Group),GroupFile(File,Group). (3)\nQuery Access in (3) has the following answers, providing a view extension:\nAccess(D) User File\nJoe f1 Joe f2 Tom f1 Tom f2 Tom f3 John f1 John f3\nIn a particular version of the delete-\npropagation problem, the objective may be to delete a minimum number of tuples from the instance, so that an authorized access (unexpected answer to the query) is deleted from the query answers, while all other authorized accesses (other answers to the query) remain intact.\nIn the following, we consider several variations of this problem, both in their functional and decision versions.\nDefinition 9. Let D be a database instance, and Q(x\u0304) a monotone query.\n(a) For a\u0304 \u2208 Q(D), the minimal-source-side-effect deletion-problem is about computing a subset-minimal \u039b \u2286 D, such that a\u0304 /\u2208 Q(D r \u039b).\n(b) The minimal-source-side-effect decision problem is (deciding about the membership of):\n11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates. We use it here to point to the similarities between the seemingly different problems of view-updates and causality.\nMSSEPs(Q) = {(D,D\u2032, a\u0304) | a\u0304 \u2208 Q(D), D\u2032 \u2286 D, a\u0304 6\u2208 Q(D\u2032), and D\u2032 is subset-maximal}. (The superscript s stands for subset-minimal.)\n(c) For a\u0304 \u2208 Q(D), the minimum-source-side-effect deletion-problem is about computing a minimum-cardinality \u039b \u2286 D, such that a\u0304 /\u2208 Q(D r \u039b).\n(d) The minimum-source-side-effect decision problem is (deciding about the membership of):\nMSSEPc(Q) = {(D,D\u2032, a\u0304) | a\u0304 \u2208 Q(D), D\u2032 \u2286 D, a\u0304 /\u2208 Q(D\u2032), and D\u2032 has maximum cardinality}. (Here, c stands for cardinality.)\nDefinition 10. [10] Let D be a database instance D, and Q(x\u0304) a monotone query.\n(a) For a\u0304 \u2208 Q(D), the view-side-effect-free deletion-problem is about computing a \u039b \u2286 D, such that Q(D) r {a\u0304} = Q(D r \u039b).\n(b) The view-side-effect-free decision problem is (deciding about the membership of):\nVSEFP(Q) = {(D, a\u0304) | a\u0304 \u2208 Q(D), and exists D\u2032 \u2286 D with Q(D) r {a\u0304} = Q(D\u2032)}.\nThe decision problem in Definition 10(b) is NP-complete for conjunctive queries [10, theorem 2.1]. Notice that, in contrast to those in (a) and (c) in Definition 9, this decision problem does not involve a candidate D\u2032, and only asks about its existence. This is because candidates always exist for Definition 9, whereas for the view-side-effect-free deletion-problem there may be no subinstance that produces exactly the intended deletion from the view. As usual, there are functional problems associated to VSEFP, about computing a maximal/maximum D\u2032 that produces the intended side-effect free deletion; and also the two corresponding decision problems about deciding concrete candidates D\u2032.\nExample 10. (ex. 1 cont.) Consider the instance D and the conjunctive query Q in (1). Assume that XML is not among John\u2019s research interests, so that tuple \u3008John,XML\u3009 in the view Q(D) is unintended. We want to find tuples in D whose removal leads to the deletion of this view tuple. There are multiple ways to achieve this goal.\nNotice that the tuples in D related to answer \u3008John,XML\u3009 through the query are Author(John, TKDE), Journal(TODS, XML, 32), Author(John, TODS) and Journal(TKDE, XML, 30). They are all candidates for removal. However, the decision problems described above impose different conditions on what are admissible deletions. (a) Source-side effect: The objective is to find minimal/minimum sets of tuples whose removal leads to the deletion of \u3008John,XML\u3009. One solution is removing S1={Author(John, TODS), Author(John, TKDE)} from the Author table.\nThe other solution is removing S2={Journal(TODS, XML, 30), Journal(TKDE, XML, 30)} from the Journal table.\nFurthermore, the removal of either S3 = {Author(John,TKDE), Journal(TODS, XML, 32)} or S4 = {Author(John,TODS), Journal(TKDE,XML, 30)} eliminates the intended view tuple. Thus, S1, S2, S3 and S4 are solutions to both the minimum- and minimal-source side-effect deletion-problems. (b) View-side effect: Removing any of the sets S1, S2, S3 or S4, leads to the deletion of \u3008John,XML\u3009. However, we now want those sets whose elimination produce no side-effects on the view. That is, their deletion triggers the deletion of \u3008John,XML\u3009 from the view, but not of any other tuple in it.\nNone of the sets S1, S2, S3 and S4 is side-effect free. For example, the deletion of S1 also results in the deletion of \u3008John,CUBE\u3009 from the view.\nExample 11. (ex. 9 cont.) It is easy to verify that there is no solution to the view-side-effect-free deletion-problem for answer \u3008Tom, f3\u3009 (in the view extension Access). To eliminate this entry from the view, either GroupUser(Tom, g3) or GroupFiles(f3, g3) must be deleted from D. Removing the former results in the additional deletion of \u3008Tom, f1\u3009 from the view; and eliminating the latter, results in the additional deletion of \u3008John, f3\u3009.\nHowever, for the answer \u3008Joe, f1\u3009, there is a solution to the view-side-effectfree deletion-problem, by removing GroupUser(Joe, g1) from D. This deletion does not have unintended side-effects on the view contents."}, {"heading": "5.2. QA-causality and delete-propagation", "text": "In this section we first establish mutual reductions between the deletepropagation problems and QA-causality."}, {"heading": "5.2.1. Delete propagation from QA-causality.", "text": ""}, {"heading": "In this section, unless otherwise stated, all the database tuples are", "text": "assumed to be endogenous.12\nConsider a relational instance D, a view V defined by a monotone query Q. Then, the virtual view extension, V(D), is Q(D).\nFor a tuple a\u0304 \u2208 Q(D), the delete-propagation problem, in its most general form, is about deleting a set of tuples from D, and so obtaining a subinstance D\u2032 of D, such that a\u0304 /\u2208 Q(D\u2032). It is natural to expect that the deletion of a\u0304 from Q(D) can be achieved through deletions from D of actual causes for a\u0304 (to be in the view extension). However, to obtain solutions to the different variants of this problem introduced in Section 5.1, different combinations of actual causes must be considered.\nFirst, we show that an actual cause for a\u0304 forms, with any of its contingency sets, a solution to the minimal-source-side-effect deletion-problem associated to a\u0304 (cf. Definition 9).\n12 The reason is that in this section we want to characterize view-deletions in term of causality, but for the former problem we did not partition the database tuples.\nProposition 10. For an instance D, a subinstance D\u2032 \u2286 D, a view defined by a monotone query Q(x\u0304), and a\u0304 \u2208 Q(D), (D,D\u2032, a\u0304) \u2208 MSSEPs(Q) iff there is a \u03c4 \u2208 D r D\u2032, such that \u03c4 \u2208 Causes(D,Q(a\u0304)) and D r (D\u2032 \u222a {\u03c4}) \u2208 Conts(D,Q(a\u0304), \u03c4).\nProof: Suppose first that (D,D\u2032, a\u0304) \u2208 MSSEPs(Q). Then, according to Definition 9, a\u0304 6\u2208 Q(D\u2032). Let \u039b = D r D\u2032. For an arbitrary element \u03c4 \u2208 \u039b (clearly, \u039b 6= \u2205), let \u0393 := \u039b r {\u03c4}. Due to the subset-maximality of D\u2032 (then, subset-minimality of \u039b), we obtain: D r (\u0393 \u222a {\u03c4}) 6|= Q(a\u0304), but D r \u0393 |= Q(a\u0304). Therefore, \u03c4 is an actual cause for a\u0304.\nFor the other direction, suppose \u03c4 \u2208 Causes(D,Q(a\u0304)) and Dr (D\u2032 \u222a {\u03c4}) \u2208 Conts(D,Q(a\u0304), \u03c4). Let \u0393 := D r (D\u2032 \u222a {\u03c4}). From the definition of an actual cause, we obtain that a\u0304 /\u2208 Q(D r (\u0393 \u222a {\u03c4}). So, a\u0304 /\u2208 Q(D\u2032) (notice that D\u2032 = D r (\u0393 \u222a {\u03c4}). Since \u0393 is a subset-minimal contingency set for \u03c4 , D\u2032 is a subset-maximal subinstance that enjoys the mentioned property. So, (D,D\u2032, a\u0304) \u2208MSSEPs(Q).\nCorollary 1. For a view defined by a monotone query, deciding if a set of source deletions producing the deletion from the view is subset minimal is in polynomial time in data.\nProof: This follows from the connection between QA-causality and deletepropagation established in Proposition 10, and the fact that deciding a cause for a monotone query and deciding the subset minimality of an associated contingency set candidate are both in polynomial time in data [43, 7].\nWe show next that, in order to minimize the number of side-effects on the source (the problem in Definition 9(c)), it is good enough to pick a most responsible cause for a\u0304 with any of its minimum-cardinality contingency sets.\nProposition 11. For an instance D, a subinstance D\u2032 \u2286 D, a view V defined by a monotone query Q, and a\u0304 \u2208 Q(D), (D,D\u2032, a\u0304) \u2208 MSSEPc(Q) iff there is a \u03c4 \u2208 D r D\u2032, such that \u03c4 \u2208 MRC(D,Q(a\u0304)), \u0393 := D r (D\u2032 \u222a {\u03c4}) \u2208 Conts(D,Q(a\u0304), \u03c4), and there is no \u0393\u2032 \u2208 Conts(D,Q(a\u0304), \u03c4) with |\u0393\u2032| < |\u0393|.\nProof: Similar to the proof of Proposition 10.\nIn relation to the problems involved in this proposition, the decision problems associated to computing a minimum-side-effect source deletion and computing the responsibility of a cause, both for monotone queries, have been independently established as NP-complete in data, in [10] and [7], resp.\nExample 12. (ex. 10 cont.) We obtained the followings solutions to the minimum- (and also minimal-) source-side-effect deletion-problem for the view tuple \u3008John,XML\u3009:\nS1 = {Author(John,TODS),Author(John,TKDE)}, S2 = {Journal(TODS,XML, 30), Journal(TKDE,XML, 30)}, S3 = {Author(John,TKDE), Journal(TODS,XML, 32)}, S4 = {Author(John,TODS), Journal(TKDE,XML, 30)}.\nOn the other side, in Example 1, we showed that the tuples Author(John,TODS), Journal(TKDE,XML, 32), Author(John,TKDE), and Journal(TODS, XML, 32) are actual causes for the answer \u3008John,XML\u3009 (to the view query). In particular, for the cause Author(John,TODS) we obtained two contingency sets: \u03931 = {Author(John,TKDE)} and \u03932={Journal(TKDE,XML, 32)}.\nIt is easy to verify that each actual cause for answer \u3008John,XML\u3009, together with any of its subset-minimal (and minimum-cardinality) contingency sets, forms a solution to the minimal- (and minimum-) source-side-effect deletionproblem for \u3008John,XML\u3009. For illustration, {Author(John,TODS)}\u222a\u03931 coincides with S1, and {Author(John,TODS)}\u222a\u03931 coincides with S4. Thus, both of them are solutions to minimal- (and minimum-) source-side-effect deletion-problem for the view tuple \u3008John,XML\u3009. This confirms Propositions 10 and 11.\nNow we consider a variant of the functional problem in Definition 9(c), about computing the minimum number of source deletions. The next result is obtained from the FPNP(log(n))-completeness of computing the highest responsibility associated to a query answer (i.e. the responsibility of the most responsible causes for the answer) [55, prop. 42].\nProposition 12. Computing the size of a solution to a minimum-source-sideeffect deletion-problem is FPNP(log(n))-hard.\nProof: By reduction from computing responsibility of a most responsible cause (cf. Definition 3) via the characterization in Proposition 11."}, {"heading": "5.2.2. QA-causality from delete-propagation.", "text": "In this subsection we assume that all tuples are endogenous since the endogenous vs. exogenous classification has not been considered on the view update side (but cf. Section 8.2).\nConsider a relational instance D, and a monotone query Q with a\u0304 \u2208 Q(D). We will show that actual causes and most responsible causes for a\u0304 can be obtained from different variants of the delete-propagation problem associated with a\u0304.\nFirst, we show that actual causes for a query answer can be obtained from the solutions to a corresponding minimal-source-side-effect deletion-problem.\nProposition 13. For an instance D and a monotone query Q(x\u0304) with a\u0304 \u2208 Q(D), \u03c4 \u2208 D is an actual cause for a\u0304 iff there is a D\u2032 \u2286 D with \u03c4 \u2208 (D rD\u2032) and (D,D\u2032, a\u0304) \u2208MSSEPs(Q).\nProof: Suppose \u03c4 \u2208 D is an actual cause for a\u0304 with a subset-minimal contingency set \u0393 \u2286 D. Let \u039b = \u0393 \u222a {\u03c4} and D\u2032 = D r \u039b . It is clear that a\u0304 6\u2208 Q(D\u2032). Then, due to the subset-minimality of \u039b, we obtain that (D,D\u2032, a\u0304) \u2208 MSSEPs(Q). A similar argument applies to the other direction.\nSimilarly, most-responsible causes for a query answer can be obtained from solutions to a corresponding minimum-source-side-effect deletion-problem.\nProposition 14. For an instance D and a monotone query Q(x\u0304) with a\u0304 \u2208 Q(D), \u03c4 \u2208 D is a most responsible actual cause for a\u0304 iff there is a D\u2032 \u2286 D with t \u2208 (D rD\u2032) and (D,D\u2032, a\u0304) \u2208MSSEPc(Q).\nProof: Similar to the proof of Proposition 13.\nExample 13. (ex. 1 and 12 cont.) Assume all tuples are endogenous. We obtained S1, S2, S3 and S4 as solutions to the minimal- (and minimum-) sourceside-effect deletion-problems for the view-element \u3008John,XML\u3009. Let S be their union, i.e. S = {Author(John,TODS), Journal(TKDE,XML, 32),Author(John, TKDE), Journal(TODS,XML, 32)}.\nWe can see that S contains actual causes for \u3008John,XML\u3009. In this case, actual causes are also most responsible causes. This coincides with the results obtained in Example 1, and confirms Propositions 13 and 14.\nConsider a view defined by a query Q as in Proposition 14. Deciding if a candidate contingency set (for an actual cause \u03c4) has minimum cardinality (giving to \u03c4 its responsibility value) is the complement of checking if a set of tuples is a maximum-cardinality repair (i.e a cardinality-based repair [4]) of the given instance with respect to the denial constraint that has Q as violation view (instantiated on \u03c4). The latter problem is in coNP-hard in data [42, 2]. Thus, we obtain that checking minimum-cardinality contingency sets is NP-hard in data. Appealing to Proposition 14, we can reobtain via repairs and causality the result in [10] about the NP -completeness ofMSSEPc(Q). We illustrate the connection with an example.\nExample 14. Consider the instance D as below, and the view V defined by the query V (y) \u2190 R(x, y), S(y).\nA view element (and query answer) is: \u3008a1\u3009.\nNow, the denial constraint that has this (instantiated) view as violation view is \u03ba : \u00acV (a1), equivalently,\nR A B a1 a4 a2 a1 a3 a1\nS B a1 a2 a3\n\u03ba : \u00ac\u2203x(R(x, a1) \u2227 S(a1)). Instance D is inconsistent with respect to \u03ba, and has to be repaired by keeping a consistent subset of D of maximum cardinality. The only cardinality-repair is: D r {S(a1)}. The complement of this repair, \u0393 = {S(a1)}, will be the minimum-cardinality contingency set for any cause in D for the query answer, i.e. for R(a2, a1) and R(a3, a1), but not for the cause S(a1), which is a counterfactual cause. Cf. [7] for more details on the relationship between repairs and causes with their contingency sets."}, {"heading": "6. View-Conditioned Causality", "text": ""}, {"heading": "6.1. VC-causality and its decision problems", "text": "QA-causality is defined for a fixed query Q and a fixed answer a\u0304. However, in practice one often has multiple queries and/or multiple answers. For a query\nwith several answers one might be interested in causes for a fixed answer, on the condition that the other query answers are correct. This form of conditioned causality was suggested in [44]; and formalized in [45], in a more general, nonrelational setting, to give an account of the effect of a tuple on multiple outputs (views). Here we adapt this notion of view-conditioned causality to the case of a single query, with possibly several answers. We illustrate first the notion with a couple of examples.\nExample 15. (ex. 1 cont.) Consider again the answer \u3008John,XML\u3009 to Q. Suppose this answer is unexpended and likely to be wrong, while all other answers to Q are known to be correct. In this case, it makes sense that for the causality status of \u3008John,XML\u3009 only those contingency sets whose removal does not affect the correct answers to the query are admissible. In other words, the hypothetical states of the database D that do not provide the correct answers are not considered.\nExample 16. (ex. 9 cont.) Consider the query in (3) as defining a view Access, collecting users and the files they can access.\nSuppose we observe that a particular file is accessible by an unauthorized user (an unexpected answer to the query), while all other users\u2019 accesses are known to be authorized (i.e. the other answers to the query are deemed to be correct). We want to find out the causes for this unexpected observation. For this task, contingency sets whose removal do not return the correct answers anymore should not be considered.\nMore generally, consider a query Q with Q(D) = {a\u03041, . . . , a\u0304n}. Fix an answer, say a\u03041 \u2208 Q(D), while the other answers will be used as a condition on a\u03041\u2019s causality. Intuitively, a\u03041 is somehow unexpected, we look for causes, but considering the other answers as \u201ccorrect\u201d. This has the effect of reducing the spectrum of contingency sets, by keeping Q(D)\u2019s extension fixed (the fixed view extension), except for a\u03041 [45].\nDefinition 11. Given an instance D and a monotone query Q, consider a\u0304 \u2208 Q(D), and V := Q(D) r {a\u0304}:\n(a) Tuple \u03c4 \u2208 Dn is a view-conditioned counterfactual cause (vcc-cause) for a\u0304 in D relative to V if a\u0304 /\u2208 Q(D r {\u03c4}) but Q(D r {\u03c4}) = V .\n(b) Tuple \u03c4 \u2208 Dn is a view-conditioned actual cause (vc-cause) for a\u0304 in D relative to V if there exists a contingency set, \u0393 \u2286 Dn, such that \u03c4 is a vcc-cause for a\u0304 in D r \u0393 relative to V .\n(c) vc-Causes(D,Q(a\u0304)) denotes the set of all vc-causes for a\u0304.\n(d) The vc-causal responsibility of a tuple \u03c4 for answer a\u0304 is vc-\u03c1D Q(a\u0304) (\u03c4) := 11+|\u0393| ,\nwhere |\u0393| is the size of the smallest contingency set that makes \u03c4 a vc-cause for a\u0304.\nNotice that the implicit conditions on vc-causality in Definition 11(b) are: a\u0304 \u2208 Q(D r \u0393), a\u0304 /\u2208 (D r (\u0393 \u222a {\u03c4})), and Q(D r (\u0393 \u222a {\u03c4})) = V . In the following, we will omit saying \u201crelative to V \u201d since the fixed contents can be understood from the context.\nClearly, vc-Causes(D,Q(a\u0304)) \u2286 Causes(D,Q(a\u0304)), but not necessarily the other way around. Furthermore, the causal responsibility and the vc-causal responsibility of a tuple as a cause, resp. vc-cause, for a same query answer may take different values.\nExample 17. (ex. 9 and 16 cont.) The extension for the Access view, given by query (3), is as follows:\nAccess(D) User File\nJoe f1 Joe f2 Tom f1 Tom f2 Tom f3 John f1 John f3\nAssume the access of Joe to file f1 -corresponding to the query answer \u3008Joe, f1\u3009- is deemed to be unauthorized, while all other users\u2019 accesses are considered to be authorized, i.e. the other answers to the query are considered to be correct.\nFirst, GroupUser(Joe, g1) is a counterfactual cause for answer \u3008Joe, f1\u3009, and then also an actual cause, with empty contingency set. Now we are interested in causes for the answer \u3008Joe, f1\u3009 that keep all the other answers untouched. GroupUser(Joe, g1) is also a vcc-cause.\nIn fact, Access(Dr{GroupUser(Joe, g1)}) = Access(D)r{\u3008Joe, f1\u3009}, showing that after the removal of GroupUser(Joe, g1), all the other previous answers remain. So, GroupUser(Joe, g1) is a vc-cause with empty contingency set, or equivalently, a vcc-cause.\nGroupFile(f1 , g1 ) is also an actual cause for \u3008Joe, f1\u3009, actually a counterfactual cause. However, it is not a vcc-cause, because its removal leads to the elimination of the previous answer \u3008John, f1\u3009. Even less could it be a vc-cause, because deleting a non-empty contingency set together with GroupFile(f1 , g1 ) can only make things worse: answer \u3008John, f1\u3009 would still be lost.\nActually, GroupUser(Joe, g1) is the only vc-cause and the only vcc-cause for \u3008Joe, f1\u3009.\nLet us assume that, instead of D, we have instance D\u2032, with extensions:\nGroupUser\u2019 User Group\nJoe g0 Joe g1 Joe g2 John g1 Tom g2 Tom g3 John g3\nGroupFiles\u2019 File Group\nf1 g0 f1 g1 f1 g3 f2 g2 f3 g3\nThe answers to the query are the same as with D, in particular, we still have \u3008Joe, f1\u3009 as an answer to the query.\nNow, GroupUser(Joe, g1 ) is not a counterfactual cause for \u3008Joe, f1\u3009 anymore, since this answer can still be obtained via the tuples involving g0. However, GroupUser(Joe, g1 ) is an actual cause, with minimal contingency sets: \u03931 = {GroupUsers(Joe, g0)} and \u03932 = {GroupFiles(f1, g0)}.\nNow, GroupUser(Joe, g1 ) is not a vcc-cause, but it is a vc-cause, with minimal contingence sets \u03931 and \u03932 as above: Removing \u03931 or \u03932 from D\n\u2032 keeps \u3008Joe, f1\u3009 as an answer. However, both under D\u2032 r (\u03931 \u222a {GroupUser(Joe, g1 )}) and D\u2032r (\u03932\u222a{GroupUser(Joe, g1 )}) the answer \u3008Joe, f1\u3009 is lost, but the other answers stay.\nExample 18. (ex. 1 and 15 cont.) The answer \u3008John,XML\u3009 does not have any vc-cause. In fact, consider for example the tuple Author(John, TODS) that is an actual cause for \u3008John,XML\u3009, with two contingency sets, \u03931 and \u03932. It is easy to verify that none of these contingency sets satisfies the condition in Definition 11(b). For example, the original answer \u3008John,CUBE\u3009 is not preserved in Dr\u03931. The same argument can be applied to all actual causes for \u3008John,XML\u3009.\nNotice that Definition 11 could be generalized by considering that several answers are unexpected and the others are correct. This generalization can only affect the admissible contingency sets.\nThe notions of vc-causality and vc-responsibility have corresponding decisions problems, which can be defined in terms similar to those for plain causality and responsibility.\nDefinition 12. (a) The vc-causality decision problem (VCDP) is about membership of VCDP(Q) = {(D, a\u0304, \u03c4) | a\u0304 \u2208 Q(D) and \u03c4 \u2208 vc-Causes(D,Q(a\u0304)) }. (b) The vc-causal responsibility decision problem is about membership of: VRDP(Q) = {(D, a\u0304, \u03c4, v) | \u03c4 \u2208 Dn, v \u2208 {0} \u222a { 1k | k \u2208 N\n+}, D |= Q(a\u0304), and vc-\u03c1D\nQ (\u03c4) > v}.\nLeaving the answers to a view fixed when finding causes for a query answer is a strong condition. Actually, as Example 18 shows, sometimes there are no vc-causes. For this reason it makes sense to study the complexity of deciding whether a query answer has a vc-cause or not. This is a relevant problem. For illustration, consider the query Access in Example 16. The existence of a vccause for an unexpected answer (unauthenticated access) to this query, tells us that it is possible to revoke the unauthenticated access without restricting other users\u2019 access permissions.\nDefinition 13. For a monotone queryQ, the vc-cause existence problem (VCEP) is (deciding about membership of): VCEP(Q) = {(D, a\u0304) | a\u0304 \u2208 Q(D) and vc-Causes(D,Q(a\u0304)) 6= \u2205 }."}, {"heading": "6.2. Characterization of vc-causality", "text": "In this section we establish mutual reductions between the delete-propagation problem and view-conditioned QA-causality. They will be used in Section 6.3 to obtain some complexity results for view-conditioned causality.\nNow, we show that, in order to check if there exists a solution to the viewside-effect-free deletion-problem for a\u0304 \u2208 V(D) (cf. Definition 10), it is good enough to check if a\u0304 has a view-conditioned cause for a\u0304.13\nProposition 15. For an instance D and a view defined by a monotone query Q, with a\u0304 \u2208 Q(D), (D, a\u0304) \u2208 VSEFP(Q) iff vc-Causes(D,Q(a\u0304)) 6= \u2205.\nProof: Assume a\u03041 has a view-conditioned cause \u03c4 . According to Definition 11, there exists a \u0393 \u2286 D, such that D r (\u0393 \u222a {\u03c4}) 6|= Q(a\u0304), D r \u0393 |= Q(a\u0304), and Dr (\u0393\u222a{\u03c4}) |= Q(a\u0304\u2032), for every a\u0304\u2032 \u2208 Q(D) with a\u0304\u2032 6= a\u0304. So, \u0393\u222a{\u03c4} is a viewside-effect-free delete-propagation solution for a\u0304; and (D, a\u0304) \u2208 VSEFP(Q). A similar argument applies in the other direction.\nExample 19. (ex. 10, 12 and 18 cont.) We obtained in Example 10(b) that there is no view-side-effect-free solution to the delete-propagation problem for the view tuple \u3008John,XML\u3009. This coincides with the result in Example 18, and confirms Proposition 15.\nNext, we show that vc-causes for an answer can be obtained from solutions to a corresponding view-side-effect-free deletion-problem.\nProposition 16. For an instance D = Dn \u222a Dx and a monotone query Q(x\u0304) with a\u0304 \u2208 Q(D), \u03c4 \u2208 Dn is a vc-cause for a\u0304 iff there is D\u2032 \u2286 D, with \u03c4 \u2208 (D rD\u2032) \u2286 Dn, that is a solution to the view-side-effect-free deletion-problem for a\u0304.\nProof: Similar to the proof of Proposition 13."}, {"heading": "6.3. Complexity of vc-causality", "text": "We now investigate the complexity of the view-conditioned causality problem (cf. Definition 12). For this, we take advantage of the connection between vccausality and view-side-effect-free delete-propagation.\nFirst, the following result about the vc-cause existence problem (cf. Definition 13) is obtained from the NP-completeness of the view-side-effect-free delete-propagation decision problem for conjunctive views [10, theorem 2.1] and Proposition 15.\nProposition 17. For CQs Q, VCEP(Q) is NP-complete (in data).\n13 Since this delete-propagation problem does not explicitly involve anything like contingency sets, the existential problem in Definition 10(b) is the right one to consider.\nProof: For membership of NP, the following is a non-deterministic PTIME algorithm for VCEP: Given D and answer a\u0304 to Q, guess a subset \u0393 \u2286 Dn and a tuple \u03c4 \u2208 Dn, return yes if \u03c4 is a vc-cause for a\u0304 with contingency set \u0393; otherwise return no. This test can be performed in PTIME in the size of D.\nHardness is by the reduction from the (NP-hard) view-side-effect-free deletepropagation problem that is explicitly given in the formulation of Proposition 15.\nThe next result is about deciding vc-causality (cf. Definition 12).\nProposition 18. For CQs Q, VCDP(Q) is NP-complete (in data).\nProof: Membership: For an input (D, a\u0304), non-deterministically guess \u03c4 \u2208 Dn and \u0393 \u2286 Dn, with \u03c4 /\u2208 \u0393. If \u03c4 is a vc-cause for a\u0304 with contingency set \u0393 (which can be checked in polynomial time), return yes; otherwise return no.\nHardness: Given an instance D and a\u0304 \u2208 Q(D), it is easy to see that: (D, a\u0304) \u2208 VCEP(Q) iff there is \u03c4 \u2208 Dn with (D, a\u0304, \u03c4) \u2208 VCDP(Q). This immediately gives us a one-to-many reduction from VCEP(Q): (D, a\u0304) is mapped to the polynomially-many inputs of the form (D, a\u0304, \u03c4) for VCDP(Q), with \u03c4 \u2208 Dn. The answer for (D, a\u0304) is yes iff at least for one \u03c4 , (D, a\u0304, \u03c4) gets answer yes. This is a polynomial number of membership tests for VCDP(Q).\nIn this result, NP -hardness is defined in terms of \u201cCook (or Turing) reductions\u201d as opposed to many-one (or Karp) reductions [25, 27]. NP -hardness under many-one reductions implies NP -hardness under Cook reductions, but the converse, although conjectured not to hold, is an open problem. However, for Cook reductions, it is still true that there is no efficient algorithm for an NP -hard problem, unless P = NP .\nFinally, we settle the complexity of the vc-causality responsibility problem for conjunctive queries.\nProposition 19. For CQs Q, VRDP(Q) is NP-complete (in data).\nProof: Membership: For an input (D, a\u0304, \u03c4, v), non-deterministically guess \u0393 \u2286 Dn, and return yes if \u03c4 is a vc-cause for a\u0304 with contingency set \u0393, and |\u0393| < 1v . Otherwise, return no. The verification can be done in PTIME in data.\nHardness: By reduction from the VCDP problem, shown to be NP -complete in Proposition 18.\nMap (D, a\u0304, \u03c4), an input for VCDP(Q), to the input (D, a\u0304, \u03c4, k) for VRDP(Q), where k = 1|D|+1 . Clearly, (D, a\u0304, \u03c4) \u2208 VCDP(Q) iff (D, \u03c4, a\u0304, k) \u2208 VRDP(Q). This follows from the fact that \u03c4 \u2208 Dn is an actual cause for a\u0304 iff vc-\u03c1D\nQ(a\u0304) (\u03c4) \u2265\n1 |D| .\nNotice that the previous proof uses a Karp reduction, but from a problem identified as NP -hard through the use of a Cook reduction (in Proposition 18).\nAll results on vc-causality in this section also hold for UCQs."}, {"heading": "7. QA-Causality under Integrity Constraints", "text": "We start with some observations and examples on QA-causality in the presence of integrity constraints (ICs). First, at the basis of Halpern & Pearl\u2019s approach to causality [30], we find interventions, i.e. actions on the model that determine counterfactual scenarios. In databases, they take the form of database updates, in particular, tuple deletions, which is the scenario we have consider so far. Accordingly, if a database D is expected to satisfy a given set of integrity constraints (that should also be considered as parts of the \u201cmodel\u201d), the instances obtained from D by tuple deletions (as interventions), as used to determine causes, should also satisfy the ICs.\nOn a different side, QA-causality as introduced in [43] is insensitive to equivalent query rewriting (as first pointed out in [26]): On the same instance, causes for query answers coincide for logically equivalent queries. However, QAcausality might be sensitive to equivalent query rewritings in the presence of ICs, as the following example shows.\nExample 20. Consider a relational schema S with predicates Dep(DName, TStaff ) and Course(CName, LName,DName). Consider the instance D for S:\nDep DName TStaff t1 Computing John t2 Philosophy Patrick t3 Math Kevin\nCourse CName TStaff DName t4 COM08 John Computing t5 Math01 Kevin Math t6 HIST02 Patrick Philosophy t7 Math08 Eli Math t8 COM01 John Computing\nwhere all the tuples are endogenous. Now, consider the CQ, Q, that collects the teaching staff who are lecturing in the department they are associated with:\nAnsQ(TStaff ) \u2190 Dep(DName,TStaff ), (4) Course(CName,TStaff ,DName).\nThe answers are: Q(D) = {John,Patrick,Kevin}. Answer \u3008John\u3009 has the following actual causes: t1, t4 and t8. t1 is a counterfactual cause, t4 has a single minimal contingency set \u03931 = {t8}; and t8 has a single minimal contingency set \u03932 = {t4}.\nNow, consider the following inclusion dependency that is satisfied by D:\n\u03c8 : \u2200x\u2200y (Dep(x, y)\u2192 \u2203u Course(u, y, x)). (5)\nIn the presence of \u03c8, Q is equivalent to the query Q\u2032 given by:\nAnsQ\u2032(TStaff ) \u2190 Dep(DName,TStaff )). (6)\nThat is, Q \u2261{\u03c8} Q\u2032. For query Q\u2032, \u3008John\u3009 is still an answer from D. However, considering only query Q\u2032 and instance D, this answer has a single cause, t1, which is also a counterfactual cause. The question is whether t4 and t8 should still be considered as causes for answer \u3008John\u3009 in the presence of \u03c8.\nNow consider the query Q1 given by\nAnsQ1(TStaff ) \u2190 Course(CName,TStaff ,DName). (7)\n\u3008John\u3009 is an answer, and t4 and t8 are the only actual causes, with contingency sets \u03931 = {t8} and \u03932 = {t4}, resp.\nIn the presence of \u03c8, one should wonder if also t1 would be a cause (it contains the referring value John in table Dept), or, if not, whether its presence would make the previous causes less responsible.\nDefinition 14. Given an instance D = Dn \u222aDx that satisfies a set \u03a3 of ICs, i.e. D |= \u03a3, and a monotone query Q with D |= Q(a\u0304), a tuple \u03c4 \u2208 Dn is an actual cause for a\u0304 under \u03a3 if there is \u0393 \u2286 Dn, such that:\n(a) D r \u0393 |= Q(a\u0304), and (b) D r \u0393 |= \u03a3.\n(c) D r (\u0393 \u222a {t}) 6|= Q(a\u0304), and (d) D r (\u0393 \u222a {t}) |= \u03a3.\nCauses(D,Q(a\u0304),\u03a3) denotes the set of actual causes for a\u0304 under \u03a3. For \u03c4 \u2208 Causes(D,Q(a\u0304),\u03a3), Cont(D,Q(a\u0304), \u03c4,\u03a3) and Conts(D,Q(a\u0304), \u03c4,\u03a3) denote the set of contingency sets, resp. subset-minimal contingency sets, for \u03c4 under \u03a3.\nThe responsibility of \u03c4 as a cause for an answer a\u0304 to query Q under a set \u03a3 of ICs, denoted by \u03c1D,\u03a3\nQ(a\u0304) (\u03c4), is defined exactly as in Section 3.1.\nExample 21. (ex. 20 cont.) Consider query Q in (4), and its answer \u3008John\u3009. Without the constraint \u03c8 in (5), tuple t4 was a cause with minimal contingency set \u03931 = {t8}.\nNow, it holds D r \u03931 |= \u03c8, but D r (\u03931 \u222a {t2}) 6|= \u03c8. So, in presence of \u03c8, and applying Definition 14, t4 is not longer an actual cause for answer \u3008John\u3009. The same happens with t8. However, t1 is still an actual (counterfactual) cause, and the only one. So, it holds: Cause(D,Q(John), \u03c8) $ Causes(D,Q(John)).\nNotice that Q and Q\u2032 in (6) have the same actual causes for answer \u3008John\u3009 under \u03c8, namely t1.\nNow consider queryQ1 in (7), and its answer \u3008John\u3009. Tuples t4 and t8 are still (non-counterfactual) actual causes in the presence of \u03c8. However, their previous contingency sets are not such anymore: Dr(\u03931\u222a{t4}) 6|= \u03c8, Dr(\u03932\u222a{t8}) 6|= \u03c8. Actually, the smallest contingency set for t4 is \u03933 = {t8, t1}; and for t8, \u03934 = {t4, t1}. Accordingly, the causal responsibilities of t4, t8 decrease in the presence of \u03c8: \u03c1D\nQ(John) (t4) = 1 2 , but \u03c1 D,\u03c8 Q(John) (t4) = 1 3 .\nIn the presence of \u03c8, tuple t1 is still not an actual cause for answer \u3008John\u3009 to Q1. For example, if we check the conditions in Definition 14, with \u03931 as potential contingency set, we find that (a),(b) and (d) hold: D r \u03931 |= Q1(John), D r \u03931 |= \u03d5, and D r (\u03931 \u222a {t1}) |= \u03c8, resp. However, (c) does not hold: D r (\u03931 \u222a {t1}) |= Q1(John). For any other potential contingency set, some of the conditions (a)-(d) are not satisfied.\nFunctional dependencies (FDs) are never violated by tuple deletions. For these reason, conditions (b) and (d) in Definition 14, those that have to do with the ICs, are always satisfied. So, FDs should not have no effect on the set of causes for a query answer. Actually, this applies to the more general class of denial constraints (DCs), i.e. of the form \u00ac\u2200x\u0304(A1(x\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 An(x\u0304n)), with Ai a database predicate or a built-in.\nProposition 20. Consider an instance D, a monotone query Q, and a set of ICs \u03a3, such that D |= \u03a3. The following hold:\n(a) Causes(D,Q(a\u0304),\u03a3) \u2286 Causes(D,Q(a\u0304)). Furthermore, for every \u03c4 \u2208 D, \u03c1D,\u03a3\nQ(a\u0304) (\u03c4) \u2264 \u03c1D Q(a\u0304) (\u03c4).\n(b) Causes(D,Q(a\u0304), \u2205) = Causes(D,Q(a\u0304)).\n(c) If \u03a3 is a set of DCs, Causes(D,Q(a\u0304),\u03a3) = Causes(D,Q(a\u0304)). Furthermore, for every \u03c4 \u2208 D, \u03c1D,\u03a3\nQ(a\u0304) (\u03c4) = \u03c1D Q(a\u0304) (\u03c4).\n(d) For a monotone query Q\u2032 with Q\u2032 \u2261\u03a3 Q, it holds Causes(D,Q(a\u0304),\u03a3) = Causes(D,Q\u2032(a\u0304),\u03a3).\nProof: (a) Any contingency set \u0393 used for \u03c4 \u2208 Causes(D,Q(a\u0304),\u03a3), can be used as a contingency set for the definition of causality without ICs (which are those in Definition 14(a,c)): Cont(D,Q(a\u0304), \u03c4,\u03a3) \u2286 Cont(D,Q(a\u0304), \u03c4). The same inclusion holds for subset-minimal contingency sets. (b) For every contingency set \u0393 for a cause \u03c4 without ICs, conditions in Definition 14(b,d) are trivially satisfied with an empty set of ICs. (c) When D |= \u03a3, and \u03a3 are DCs, every subset of D also satisfies \u03a3. Then, the new conditions on candidate contingency sets, those in Definition 14(b,d), are immediately satisfied. Since the same contingency sets apply both with or without ICs, the responsibility does not change. (d) For a potential cause \u03c4 with a candidate contingency set \u0393, conditions in Definition 14(a,c) will be always simultaneously satisfied for Q and Q\u2032, because according to the conditions in Definition 14(b,d), both Dr\u0393 and Dr (\u0393\u222a{\u03c4}) satisfy \u03a3.\nNotice that Example 21 shows that the inclusion in item (a) above can be proper. It also shows that for a same actual cause, with and without ICs, the inequality of responsibilities may be strict.\nItem (d) above corresponds to the equivalent rewriting of the query in (4) into query (6) under the referential constraints. As shown in Example 21, under the latter both queries have the same causes.14 The monotonicity condition on Q\u2032 in item (d) is necessary, first to apply the notion of cause to it, but more importantly, because monotonicity is not implied by the monotonicity of Q and\n14 Notice that this rewriting resembles the resolution-based rewritings used in semantic query optimization [12].\nquery equivalence under \u03a3. In fact, for schema S = {R(A,B), S(A,B)}, the FD R : A\u2192 B, the BCQ Q : \u2203x\u2203y\u2203z(R(x, y) \u2227R(x, z) \u2227 y 6= z), and the nonmonotonic Boolean query Q\u2032 : \u2203x\u2203y\u2203z(R(x, y) \u2227R(x, z) \u2227 \u00acS(x, y) \u2227 y 6= z), it holds Q \u2261FD Q\n\u2032. All the causality-related decision and computational problems for the case without ICs can be easily redefined in the presence of a set \u03a3 of ICs, that we now make explicitly appear as a problem parameter, such as in RDP(Q,\u03a3), for the responsibility decision problem.\nSince FDs have no effect on causes, the causality-related decision problems in the presence of FDs have the same complexity upper bound as causality without FDs. For example, for a set \u03a3 of FDs, RDP(Q,\u03a3), the responsibility problem now under FDs, is NP-complete, since this is already the case without ICs [43].\nWhen an instance satisfies a set of FDs, the decision problems may become tractable depending on the query structure. A particular syntactic class of CQs is that of key-preserving CQs: Given a set \u03ba of key constraints (KCs), a CQ Q is key-preserving (more precisely, \u03ba-preserving) if the key attributes of the relations appearing inQ are all included among the non-existentially quantified attributes of Q [15]. For, example, for the schema S(A,B,C), R(C,D), with the keys underlined, the queries Q1(y, z) : \u2203xS(x, y, z), Q2(x, y, z) : (S(x, y, z)\u2227R(z, v)) are not key-preserving, but Q3(x, y) : \u2203zS(x, y, z) and Q\u20322(x, y, z, w, z) : (S(x, y, z)\u2227 R(w, v) \u2227 z = w) are. It turns out that, in the case of key-preserving CQs, deciding responsibility over instances that satisfy the key constraints (KCs) is in PTIME [14].\nThe view-side-effect-free delete propagation (VSEFD) problem can be easily reformulated in the presence of ICs, by including their satisfaction in Definition 10, both by D and the instance resulting from delete propagation, D r \u039b. Furthermore, the mutual characterizations between the VSEFD and view-conditioned causality problems of Section 6.2 still hold in the presence of ICs.\nIt turns out that the decision version of the view-side-effect-free deletion problem for key preserving CQs is tractable in data complexity [15]. By appealing to the connection in Section 6 between vc-causality and that form of delete-propagation, vc-responsibility under KCs becomes tractable.15 However, it is intractable in general, because the problem without KCs already is, as shown in Proposition 19).\nProposition 21. Given a set \u03ba of KCs, and a key-preserving CQ query Q, deciding VRDP(Q, \u03ba) is in PTIME.\nOther classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).\n15 Actually, the result in [15] just mentioned holds for single tuple deletions (with multiple deletions it can be NP-hard), which is the case in the causality setting, where a single answer is hypothetically deleted.\nThe connections between delete-propagation and causality established in Sections 5 and 6 should allow us to obtain new tractability results for causality.\nOur next result tells us that it is possible to capture vc-causality through non-conditioned QA-causality under tuple-generating dependencies (tgds).\nLemma 1. For every instance D an for a schema S, Q(x\u0304) \u2208 L(S) a conjunctive query with n free variables, and a\u0304 \u2208 Q(D), there is a tgd \u03c8 over schema S\u222a{V }, with V a fresh n-ary predicate, and an instance D\u2032 for S \u222a {V }, such that vc-Causes(D,Q(a\u0304)) = Causes(D\u2032,Q(a\u0304), {\u03c8}).\nProof: Consider the instance D\u2032 := D \u222a {V (c\u0304) | c\u0304 \u2208 (Q(D) r {a\u0304}), where the second disjunct is the extension for predicate V . The tgd \u03c8 over schema S\u222a{V } is \u2200x\u0304(V (x\u0304)\u2192 Q(x\u0304)).\nIn the absence of ICs, deciding causality for CQs is tractable [43], but their presence may have an impact on this problem.\nProposition 22. For a CQ Q and a tgd \u03c8, CDP(Q, {\u03c8}) is NP-complete.\nProof: Membership is clear. Hardness is established by reduction from the NPcomplete vc-causality decision problem (cf. Proposition 18) for a CQ Q(x\u0304) over schema S. Now, consider the schema S \u2032 := S \u222a{V } and the tgd \u03c8 as in Lemma 1. In order to decide about (D,Q(a\u0304), \u03c4)\u2019s membership of VCDP(Q), consider the instance D\u2032 for S \u2032 as in Proposition 1. It holds: (D,Q(a\u0304), \u03c4) \u2208 VCDP(Q) iff (D\u2032,Q(a\u0304), \u03c4) \u2208 CDP(Q, {\u03c8})."}, {"heading": "7.1. Causality under ICs via view-updates and abduction", "text": "In this work we have connected QA-causality with both abduction and viewupdates in form of delete-propagations. It is expected to find connections between causality under ICs and those two other problems in the presence of ICs, as the following example suggests.\nExample 22. (ex. 20 cont.) Formulated as an abduction problem, we have the query Q specified in by the Datalog rule in (4), defining an intentional predicate, AnsQ(TStaff ). All the tuples in the underlying database D, all endogenous, are considered to be abducible. The view-update request is the deletion of \u3008John\u3009 from Q(D) (more precisely, from AnsQ(D)). As an abduction task, it is about giving an explanation for obtaining tuple AnsQ(John).\nAccording to our approach to abduction of Section 4, the abductive explanations are obtained from (and also lead to) maximal subsets E of D, such that E plus the query rule (4) does not entail AnsQ(John) anymore. These sets are: E1 = D r {t1}, and E2 = D r {t4, t8}, and are determined by finding minimal abductive explanations for AnsQ(John). So far, all this without considering the IC \u03c8 in (5).\nNow, these maximal sub-instances have to be examined at the light of the IC. In this case, E1 does satisfy \u03c8, but E2 does not. So, the latter is rejected. As a consequence, the only admissible update is the deletion of t1 from D, which\ncoincides with having t1 as the only actual cause under the IC, as determined in Example 21.\nThis example shows that, and how, (minimal) abductive explanations, and also admissible view-updates, could be used to define, provide alternative characterizations, and compute actual causes in the presence of ICs. In this case, and according to Section 5, an admissible view-update (under the ICs) should be in correspondence, by definition, with an admissible combination of an actual cause and one of its contingency sets. This would make, in the previous example, t1 the only actual cause (also counterfactual) for \u3008John\u3009 under \u03c8, as expected from the direct definition of cause under ICs.\nBoth view-updates and abduction can be defined in the presence of ICs. In particular, theories written in languages of logic programming have been considered as underlying theories for abduction and view updates in the presence of ICs [35, 36]. More specifically, in [18], view updates via abductive explanations are investigated in the context of stratified logic programs with ICs on the extensional database (as opposed to on the intentional relations).\nWe briefly illustrate using our ongoing example how Datalog abduction a\u0300 la logic programming with constraints [40] could be used to determine causes in the presence of ICs.\nExample 23. (ex. 20 and 21 cont.) Consider query Q1, defined by the Datalog rule in (7), and the IND \u03c8 in (5). We want to compute the causes for answer John by applying a resolution-based refutation procedure that generates candidate causes, but checks possible support from ICs, for underlying causes:\n\u2190 AnsQ1(John) (negated answer) AnsQ1(x) \u2190 Course(u, x, y)\n\u2190 Course(u, John, y) Course(COM08, John,Computing) \u2190 (from D) (*)\n\u2190 (tuple is candidate) Course(u, John, y) \u2190 Dep(y, John) (check IND with (*))\n\u2190 Dep(y, John) Dep(Computing, John) \u2190 (from D)\n\u2190 (tuple is candidate, no more IC)\nThe successful refutation shows Dep(Computing, John) as an abductive explanation (or a cause).16\nNotice that our additional checking above of (*) with the IND can be seen as generating a new query through the interaction of (7) and the IND, namely: Ans \u2032Q1(x)\u2190 Course(u, x, y),Dept(y, x), where the last body atom appended to the original query is the residue from that interaction, via resolution. This is\n16 More precisely, a Skolem functional term f(y, John) should replace variable u in Course(u, John, y)\u2190 Dep(y, John) [41].\nreminiscent of semantic query optimization [12], where satisfied ICs are used to optimize query answering, and also of consistent query answering [4, sec. 3.1], where possibly not satisfied ICs are imposed on queries to obtain semantically correct answers.\nThe procedure shown in the example could be refined to obtain contingent tuples for the obtained cause. Furthermore, it could be applied with Datalog extended with stratified negation [1, 11], using negation-as-failure [41] in the refutation. It could even be applied with causes for answers to conjunctive queries with negated atoms,17 and Why-No causes (as opposed to our Why-So causes [43]), i.e. for not obtaining an expected answer. This could be treated through view insertions with ICs, for which abduction can also be applied [18].\nIt is outside the scope of this work to give a full deductive-abductive approach to causes for answers to Datalog queries. However, it is worth mentioning that a FO, classical abductive approach to view updates in the presence of ICs is proposed in [18]. Continuing with our ongoing example, we briefly sketch this approach.\nExample 24. (ex. 23 cont.) Consider again the query Q defined by (4). Now, in FO-logic it becomes:18\n\u2200x(AnsQ1(x) \u2261 \u2203y\u2203z(Dep(y, x) \u2227 Course(z, x, y))). (8)\nIn contrapositive, considering that we want to virtually delete the unintended answer AnsQ1(John):\n\u00acAnsQ1(John) \u2261 \u2200y\u2200z(\u00acDep(y, John) \u2228 \u00acCourse(z, John, y)). (9)\nThe formula on the right-hand side is (essentially) in disjunctive normal form (DNF), and expressed in terms of base atoms ( or abducible atoms). It is obtained through the negation (due to a virtual answer deletion) of the (only partially ground) lineage of the instantiated query [60, 9, 37].\nUp to this point the ICs have not been taken into account. This is the next step. First, the IND is written in DNF as well, via Skolemization, obtaining\n\u03c8\u2032 : \u2200x\u2200y (\u00acDep(x, y) \u2228 Course(f(x, y), y, x)), (10)\nwhich is equiconsistent with \u03c8 [41]. Next, to enforce the ICs, the atoms in (9) are appended residues from the ICs. They are obtained by resolution between each of the atoms (or more generally, literals) in (9) and the constraint (10). In this case, Dep(y, John) has not residue, but Course(z, John, y)) has Dept(y, John).19 So, the RHS of (9) becomes:\n\u2200y\u2200z(\u00acDep(y, John) \u2228 (\u00acCourse(z, John, y) \u2227Dept(y, John)). (11)\n17 This kind of queries were considered in [58], with a probabilistic approach. 18 Notice that this is the completion of predicate AnsQ as defined by (4). Predicate completion [41] can be used to deal with more complex Datalog queries [18]. 19 Notice the similarity with query rewriting for obtaining consistent query answers from possibly inconsistent databases [4, sec. 3.1].\nWe could call the right-hand side the semantic lineage of the (negated) query. Actually, it holds: (8) \u2227 (11) |= \u00acAnsQ(John) [18]. Notice that (11) can be written as:\n\u2200y(\u00acDep(y, John) \u2228 (\u00ac\u2203zCourse(z, John, y) \u2227Dept(y, John))). (12)\nDue to the IND, the second disjunct (which is its negation) can be eliminated, simply obtaining: \u2200y\u00acDep(y, John).\nUp to now the (extensional) databaseD has not been considered. By looking it up, we obtain that the (minimal) abductive explanation is Dep(Computing, John), leading to its deletion, and to it as a cause for the original answer.\nIn our case, formula (12) is very simple. In general, it can be much more complicated, e.g. when we have: (a) More complex Datalog queries, possibly with stratified negation, for which the intentional predicate completions have to be computed. In particular, conjunctive queries with negated atoms. (b) Several, possibly interacting ICs. (c) Complex view (intentional) updates, with both positive and negative ground atoms [18]. For tuple view insertions denial constraints, in particular key constraints and FDs, become relevant. It is possible to apply resolution to them, to obtain residues for the lineage literals.\nThe final interaction with the extensional database D, to keep everything in a classical FO setting, can be done (via resolution and the unique names assumption [41]) with the logical reconstruction of D [51]. In our example, it is given by the theory:\n\u2200x\u2200y(Dep(x, y) \u2261 (x = Computing \u2227 y = John) \u2228 (x = Philosophy \u2227 y = Patrick) \u2228 \u2228 (x = Math \u2227 y = Kevin)).\n\u2200x\u2200y\u2200z(Course(x, y, z) \u2261 (x = Com08 \u2227 y = John \u2227 z = Computing) \u2228 (x = Math01 \u2227 y = Kevin \u2227 z = Math) \u2228 (x = Hist02 \u2227 y = Patrick \u2227 z = Philosophy) \u2228 (x = Math08 \u2227 y = Eli \u2227 z = Math) \u2228 (x = Com01 \u2227 y = John \u2227 z = Computing))."}, {"heading": "8. Discussion and Conclusions", "text": "In this work we have investigated the computational aspects causality for answers to Datalog queries. This was made possible by establishing a precise connections (mutual reductions) with adbuction from Datalog theories. This connection is interesting per se. In particular, the notion of necessity-degree for abductive explanations, motivated by causality concepts, has been identified as relevant (cf. Section 4.3).\nWe have also investigated in detail the connections between query-answer causality for monotone queries and updates through views defined by monotone\nqueries. Particularly relevant is our investigation of view-conditioned causality, for which we established connections with the view side-effect free delete propagation problem. We obtained new complexity results for both problems.\nThe problem of causality under integrity constraints (ICs) had not been investigated so far. Here we proposed the corresponding notions and obtained first complexity results. Abduction under ICs was shown to be a promising direction to compute causes under ICs. There are still many problems and issues to investigate around causality in the presence of ICs.\nIn this work we concentrated on Why-So causes, i.e. causes for obtained query answers. In [43], causality for non-query-answers, i.e. causes for not obtaining an expected answer, i.e. Why-No causality, is defined on basis of sets of potentially missing tuples that account for the missing answer. However, concepts and techniques for abduction under ICs as found in [18] and suggested in Section 7.1 seem to be applicable to Why-No causality. This is also left for future work.\nIn the rest of this section we discuss in a bit more depth some issues that deserve being considered for future research. At the same time we also mention some related work that could be explored in more depth, for possibly interesting connections with our work."}, {"heading": "8.1. Causality and ICs", "text": "Some ICs are implicative, e.g. INDs and tgds, which makes it tempting to give them a causal semantics. For example, in [54] and more in the context of interventions for explanations, a ground instantiation, Pi(t\u0304i)\u2192 Pj(t\u0304j), of an inclusion dependency is regarded a causal dependency of Pj(t\u0304j) upon Pi(t\u0304i). On this basis, a valid intervention removes Pj(t\u0304j) whenever Pi(t\u0304i) is removed from the instance. This is in line with our general approach, as can be seen from Example 21, with query Q1 and tuple t1.\nGiving to ICs a causal connotation is controversial. Actually, according to [31] logical dependencies are not causal dependencies per se. Our approach is also consistent with this view, in that antecedents of implications are not actual causes, but only elements of contingency sets, as can be seen, again, from Example 21, with query Q1 and tuple t1.\nOur use in Section 7.1 of the semantic lineage for determining causes in the presence of ICs leads, after grounding, to Boolean formulas in DNF. This opens the ground for possible applications of knowledge compilation techniques that are used in knowledge representation [20], and had also provided interesting results in data management [34]. This is direction that deserves investigation.\nEven more, we should point out that there are different ways of seeing ICs, and they could have an impact on the notion of cause. For example, according to [53], ICs are \u201cepistemic in nature\u201d, in the sense that rather than being statements about the domain represented by a database (or knowledge base), they are statement about the contents of the database, or about what it knows."}, {"heading": "8.2. Endogenous tuples and view updates", "text": "The partition of a database into endogenous and exogenous tuples used in causality may also be of interest in the context of delete-propagation. It makes sense to consider solutions based on endogenous delete-propagation, obtained through deletions of endogenous tuples only. Actually, given an instance D = Dn \u222aDx, a view V defined by a monotone query Q, and a\u0304 \u2208 V(D), endogenous delete-propagation solutions for a\u0304 (in all of its flavors) can be obtained from actual causes for a\u0304 from the partitioned instance.\nExample 25. (ex. 10 cont.) Assume again that \u3008John,XML\u3009 has to be deleted from the query answer (view extension). Assume now only the data in the Journal relation are reliable. Then, only deletions from the Author relation make sense. This can be captured by making Journal-tuples exogenous, and Author-tuples endogenous. With this partition, only Author(John,TODS) and Author(John,TKDE) are actual causes for \u3008John,XML\u3009, with contingency sets \u0393 = {Author(John,TKDE)} and \u0393\u2032 = {Author(John,TODS)}, respectively (see Example 1).\nNow, each actual cause for \u3008John,XML\u3009, together with its one-tuple subsetminimal (and also minimum-cardinality) contingency set, leads to the same set {Author(John,TODS), Author(John,TKDE)}, which, according to Propositions 10 and 11, is an endogenous minimal- (and minimum-) delete-propagation solution for \u3008John,XML\u3009."}, {"heading": "8.3. Related connections", "text": "Our work, in combination with the results reported in [7], shows that there are deeper and multiple connections between the areas of QA-causality, abductive and consistency-based diagnosis, view-updates, and database repairs. Connections between consistency-based and abductive diagnosis have been established, e.g. in [16]. Abduction has been explicitly applied to database repairs [3]. The idea, again, is to \u201cabduce\u201d possible repair updates that bring the database to a consistent state. Further exploring and exploiting these connections is matter of ongoing and future research.\nThe view-update problem has been treated from the point of view of abductive reasoning [35, 18]. The basic idea is to \u201cabduce\u201d the presence of tuples in the base tables that explain the presence of those tuples in the view extension, of those one would like to, e.g. get rid of (cf. Section 7.1).\nDatabase repairs are related to the view-update problem. Actually, answer set programs (ASPs) [8] for database repairs [4, chap. 4] implicity repair the database by updating conjunctive combinations of intentional, annotated predicates. Those logical combinations -views after all- capture violations of integrity constraints in the original database or along the (implicitly iterative) repair process (a reason for the use of annotations).\nIn order to protect sensitive information, in [5] databases are explicitly and virtually \u201crepaired\u201d through secrecy views that specify the information that has to be kept secret. In order to protect information, a user is allowed to interact\nonly with the virtually repaired versions of the original database that result from making those views empty or contain only null values. Repairs are specified and computed using ASP, and an explicit connection to prioritized attribute-based repairs [4].\nAcknowledgments: Research funded by NSERC Discovery, and the NSERC Strategic Network on Business Intelligence (BIN)."}, {"heading": "Appendix A. Proofs of Results", "text": "Proof of Proposition 1: Consider a DAP AP = \u3008\u03a0, E,Hyp,Obs\u3009 associated to \u03a0, and h \u2208 Hyp. From the subset minimality of abductive diagnosis and Definition 4 (part (c)), we obtain h \u2208 Ness(AP) iff Sol(AP \u2032) = \u2205 where, AP \u2032 = \u3008\u03a0, E,Hyp r {h},Obs\u3009. To decide whether Sol(AP \u2032) = \u2205, it is good enough to check if \u03a0\u222aE\u222aHyp |= Obs. This can be done in polynomial time since Datalog evaluation is in polynomial time in data complexity.\nProof of Proposition 2: Membership: Consider a Datalog abduction problem AP and a hypotheses h \u2208 Hyp. To check whether h is relevant for AP, nondeterministically guess a subset \u2206 \u2286 Hyp, check if: (a) h \u2208 \u2206, and (b) \u2206 is an abductive diagnosis for AP. If h passes both tests then it is relevant, otherwise, it is irrelevant.\nClearly, test (a) can be performed in polynomial time. We only need to show that checking (b) is also polynomial time. More precisely, we need to show that \u03a0\u222aE\u222a\u2206 |= Obs and \u2206 is subset-minimal. Checking whether \u03a0\u222aE\u222a\u2206 |= Obs can be done in polynomial time, because Datalog evaluation is polynomial time. It is easy to verify that to check the minimality of \u2206, it is good enough to show that for all elements \u03b4 \u2208 \u2206, \u03a0 \u222a E \u222a\u2206 r {\u03b4} 6|= Obs. This is because positive Datalog is monotone.\nHardness: We show that the combined complexity of deciding relevance for the Propositional Horn Clause Abduction (PHCA) problem, that is NPcomplete [24], is a lower bound for the data complexity of the relevance problem for Datalog abduction.\nA PHCA problem is of the form P = \u3008Var ,H,SD ,O\u3009, where Var is a finite set of propositional variables, H \u2286 Var contains hypotheses, SD is a set of definite propositional Horn clauses, and O \u2286 Var is the observation, with H \u2229 O = \u2205. An abductive diagnosis for P is a subset-minimal \u2206 \u2286 H, such that \u2206\u222aSD |= \u2227 o\u2208O o. Deciding whether h \u2208 H is relevant to P (i.e. it is an element of an abductive diagnosis of P) is NP-complete [24]. Deciding relevance for PHCA remains NP-hard for the 3-bounded case where: SD contains a rule \u201ctrue \u2190\u201d, and all the other rules are of the form \u201ca \u2190 b1, b2, b3\u201d. 20\nNow, we provide a polynomial-time reduction from the problem of deciding relevance for 3-bounded PHCA to our problem RLDP. To obtain data complexity for the latter, we need a fixed relational schema and a fixed Datalog program \u03a0 over it, so that inputs for relevance in 3-bounded PHCA are mapped to the extensional components of \u03a0, where relevance is tested.\nMore precisely, given a 3-bounded PHCA P, build the DAP problem APP =\n20 Every PHCA can be transformed to an equivalent 3-bounded PHCA, because each rule a \u2190 b1, b2, . . . , bn can be equivalently replaced by two rules a \u2190 c, . . . , bn and c \u2190 b1, b2. Furthermore, true can be used to augment rule bodies with less than three propositional variables.\n\u3008\u03a0, EP ,HypP ,ObsP\u3009 as follows, where \u03a0 is the following (non-propositional) Datalog program (whose underlying domain consists of the propositional variables in SD plus true):\nT (true) \u2190 (A.1) T (x0) \u2190 T (x1), T (x2), T (x3), R(x0, x1, x2, x3). (A.2)\nFurthermore, EP := {R(a, b1, b2, b3) | a \u2190 b1, b2, b3 appears in SD}. Furthermore, Hyp = {T (a) | a \u2208 H} and Obs = {T (a) | a \u2208 O}. Notice that this reduction can be done in polynomial-time in the size of P.\nIt is possible to prove that: For a P = \u3008Var ,H,SD ,O\u3009 and a hypothesis h \u2208 H, h is relevant for P iff T (h) \u2208 Rel(APP).\nThe following example illustrates the reduction in the hardness part of the proof of Proposition 2.\nExample 26. Consider the \u201cPropositional Horn Clause Abduction\u201d (PHCA) P = \u3008{a, b, c}, {c, b}, {a \u2190 b, c ; b \u2190 c}, {a}\u3009, whose components are, respectively, a set of propositional variables, a subset of the former formed by the abductibles (hypothesis), a positive propositional program, and the set of observations. It is easy to verify that P has the single abductive diagnosis, {c}, and then a single relevant hypotheses, c.\nThe 3-bounded PHCA P3b = \u3008{a, b, c}, {c, b}, {true \u2190 ; a\u2190 b, c, true ; b\u2190 c, true, true}, {a}\u3009 is equivalent to P.\nNow, P3b can be mapped to the DAP APP 3b\n= \u3008\u03a0, {R(a, b, c, true), R(c, b, true, true)}, {T (c), T (b)}, {T (a))}\u3009, with \u03a0 as in (A.1, (A.2), which has a single abductive diagnosis, {T (c)}."}], "references": [{"title": "Repair Checking in Inconsistent Databases: Algorithms and Complexity", "author": ["F.N. Afrati", "Kolaitis", "Ph"], "venue": "Proc. ICDT,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "Coherent Integration of Databases by Abductive Logic Programming", "author": ["O. Arieli", "M. Denecker", "B. Van Nuffelen", "M. Bruynooghe"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2004}, {"title": "Database Repairing and Consistent Query Answering", "author": ["L. Bertossi"], "venue": "Synthesis Lectures on Data Management,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2011}, {"title": "Achieving Data Privacy through Secrecy Views and Null-Based Virtual Updates", "author": ["L. Bertossi", "L. Li"], "venue": "IEEE Transaction on Knowledge and Data Engineering,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2013}, {"title": "Unifying Causality, Diagnosis, Repairs and View- Updates in Databases", "author": ["L. Bertossi", "B. Salimi"], "venue": "First International PODS-Workshop on Big Uncertain Data (BUDA", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2014}, {"title": "Answer Set Programming at a Glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczynski"], "venue": "Communications of the ACM,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Why and Where: A Characterization of Data Provenance", "author": ["P. Buneman", "S. Khanna", "W.C. Tan"], "venue": "Proc. ICDT,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2001}, {"title": "On Propagation of Deletions and Annotations Through Views", "author": ["P. Buneman", "S. Khanna", "W.C. Tan"], "venue": "Proc. PODS,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2002}, {"title": "Logic-Based Approach to Semantic Query Optimization", "author": ["U.S. Chakravarthy", "J. Grant", "J. Minker"], "venue": "ACM TODS,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1990}, {"title": "Responsibility and Blame: A Structural- Model Approach", "author": ["H. Chockler", "J.Y. Halpern"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2004}, {"title": "A Characterization of the Complexity of Resilience and Responsibility for Conjunctive Queries", "author": ["F. Cibele", "W. Gatterbauer", "N. Immerman", "Meliou A"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2015}, {"title": "On the Complexity of View Update Analysis and its Application to Annotation Propagation", "author": ["G. Cong", "W. Fan", "F. Geerts", "J. Li", "J. Luo"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "A Spectrum of Logical Definitions of Model- Based Diagnosis", "author": ["L. Console", "P. Torasso"], "venue": "Comput. Intell.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1991}, {"title": "On the Relationship between Abduction and Deduction", "author": ["L. Console", "D. Theseider-Dupre", "P. Torasso"], "venue": "J. Log. Comput.,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1991}, {"title": "The Role of Abduction in Database View Updating", "author": ["L. Console", "M.L. Sapino", "D. Theseider-Dupre"], "venue": "J. Intell. Inf. Syst.,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1995}, {"title": "Run-Time Translation of View Tuple Deletions Using Data Lineage", "author": ["Y. Cui", "J. Widom"], "venue": "Technical Report,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2001}, {"title": "A Knowledge Compilation Map", "author": ["A. Darwiche", "P. Marquis"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2002}, {"title": "Abduction in Logic Programming", "author": ["M. Denecker", "A.C. Kakas"], "venue": "In Computational Logic: Logic Programming and Beyond,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2002}, {"title": "The Complexity of Logic-Based Abduction", "author": ["T. Eiter", "G. Gottlob"], "venue": "J. ACM ,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1995}, {"title": "Abduction from Logic Programs: Semantics and Complexity", "author": ["T. Eiter", "G. Gottlob", "N. Leone"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1997}, {"title": "Hypothesis Classification, Abductive Diagnosis and Therapy", "author": ["G. Friedrich", "Gottlob. G", "W. Nejdl"], "venue": "Proc. Internat. Workshop on Expert Systems in Engineering,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1990}, {"title": "Reexamining Some Holy Grails of Data Provenance", "author": ["B. Glavic", "R.J. Miller"], "venue": "Proc. Theory and Practice of Provenance (TaPP),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2011}, {"title": "Computational Complexity", "author": ["O. Goldreich"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2008}, {"title": "Bounded Treewidth as a Key to Tractability of Knowledge Representation And Reasoning", "author": ["G. Gottlob", "R. Pichler", "F. Wei"], "venue": "Artificial Intelligence,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2010}, {"title": "Tractable Database Design and Datalog Abduction through Bounded Treewidth", "author": ["G. Gottlob", "R. Pichler", "F. Wei"], "venue": "Inf. Syst.,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2010}, {"title": "Causes and Explanations: A Structural-Model Approach: Part 1", "author": ["J. Halpern", "J. Pearl"], "venue": "British J. Philosophy of Science,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2005}, {"title": "Actual Causation and The Art of Modelling", "author": ["J. Halpern", "C.R. Hitchcock"], "venue": "College Publications,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2010}, {"title": "Appropriate Causal Models and Stability of Causation", "author": ["J. Halpern"], "venue": "Proc. KR,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2014}, {"title": "A Modification of Halpern-Pearl Definition of Causality", "author": ["J. Halpern"], "venue": "In Proc. IJCAI,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2015}, {"title": "Knowledge Compilation Meets Database Theory: Compiling Queries to Decision Diagrams", "author": ["A. Jha", "D. Suciu"], "venue": "Theory of Computing Systems,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2013}, {"title": "Database Updates through Abduction", "author": ["A.C. Kakas", "P. Mancarella"], "venue": "Proc. VLDB,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 1990}, {"title": "Abductive Logic Programming", "author": ["A.C. Kakas", "R.A. Kowalski", "F. Toni"], "venue": "J. Logic and Computation,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 1992}, {"title": "Semiring-Annotated Data: Queries and Provenance", "author": ["G. Karvounarakis", "T.J. Green"], "venue": "SIGMOD Record,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2012}, {"title": "A Dichotomy in the Complexity of Deletion Propagation with Functional Dependencies", "author": ["B. Kimelfeld"], "venue": "Proc. PODS,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2012}, {"title": "Maximizing Conjunctive Views in Deletion Propagation", "author": ["B. Kimelfeld", "J. Vondrak", "R. Williams"], "venue": "ACM TODS,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2012}, {"title": "Integrity Checking in Deductive Databases", "author": ["R.A. Kowalski", "F. Sadri", "P. Soper"], "venue": "Proc. VLDB", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 1987}, {"title": "Complexity of Consistent Query Answering in Databases under Cardinality-Based and Incremental Repair Semantics", "author": ["A. Lopatenko", "L. Bertossi"], "venue": "Proc. ICDT,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2007}, {"title": "The Complexity of Causality and Responsibility for Query Answers and Non-Answers", "author": ["A. Meliou", "W. Gatterbauer", "K.F. Moore", "D. Suciu"], "venue": "Proc. VLDB,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2010}, {"title": "Causality in Databases", "author": ["A. Meliou", "W. Gatterbauer", "J. Halpern", "C. Koch", "K.F. Moore", "D. Suciu"], "venue": "IEEE Data Eng. Bull,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2010}, {"title": "Tracing Data Errors with View-Conditioned Causality", "author": ["A. Meliou", "W. Gatterbauer", "S. Nath", "D. Suciu"], "venue": "Proc. SIGMOD,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2011}, {"title": "Logic Programming, Abduction and Probability", "author": ["D. Poole"], "venue": "Proc. FGCS,", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1992}, {"title": "Representing Diagnosis Knowledge", "author": ["D. Poole"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 1994}, {"title": "Ampliative Reasoning: Induction or Abduction", "author": ["A. Psillos"], "venue": "Proc. ECAI\u201996 Workshop on Abductive and Inductive Reasoning,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 1996}, {"title": "Towards a Logical Reconstruction of Relational Database Theory", "author": ["R. Reiter"], "venue": "In On Conceptual", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 1984}, {"title": "A Theory of Diagnosis from First Principles", "author": ["R. Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1987}, {"title": "What Should A Database Know", "author": ["R. Reiter"], "venue": "J. Log. Program,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 1992}, {"title": "A Formal Approach to Finding Explanations for Database Queries", "author": ["S. Roy", "D. Suciu"], "venue": "Proc. SIGMOD,", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2014}, {"title": "From Causes for Database Queries to Repairs and Model-Based Diagnosis and Back", "author": ["B. Salimi", "L. Bertossi"], "venue": "Proc. ICDT,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2015}, {"title": "Query-Answer Causality in Databases: Abductive Diagnosis and View-Updates", "author": ["B. Salimi", "L. Bertossi"], "venue": "Proc. UAI Workshop on Causal Inference,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2015}, {"title": "Causes for Query Answers from Databases, Datalog Abduction and View-Updates: The Presence of Integrity Constraints", "author": ["B. Salimi", "L. Bertossi"], "venue": "Proc. FLAIRS,", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2016}, {"title": "Quantifying Causal Effects on Query Answering in Databases", "author": ["B. Salimi", "L. Bertossi", "D. Suciu", "G. Van den Broeck"], "venue": "Proc. 8th USENIX Workshop on the Theory and Practice of Provenance", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2016}, {"title": "Model-based Problem Solving", "author": ["P. Struss"], "venue": "In Handbook of Knowledge Representation, chap. 10. Elsevier,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2008}], "referenceMentions": [{"referenceID": 37, "context": "The notion of causality-based explanation for a query result was introduced in [43], on the basis of the deeper concept of actual causation.", "startOffset": 79, "endOffset": 83}, {"referenceID": 37, "context": "This idea is formally captured through the notion of causal responsibility, and introduced in [43].", "startOffset": 94, "endOffset": 98}, {"referenceID": 38, "context": "In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities [44, 43].", "startOffset": 118, "endOffset": 126}, {"referenceID": 37, "context": "In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities [44, 43].", "startOffset": 118, "endOffset": 126}, {"referenceID": 38, "context": "Furthermore, view-conditioned causality (in short, vc-causality) was proposed in [44, 45] as a restricted form of QA-causality, to determine causes for unexpected query results, but conditioned to the correctness of prior knowledge that cannot be altered by hypothetical tuple deletions.", "startOffset": 81, "endOffset": 89}, {"referenceID": 39, "context": "Furthermore, view-conditioned causality (in short, vc-causality) was proposed in [44, 45] as a restricted form of QA-causality, to determine causes for unexpected query results, but conditioned to the correctness of prior knowledge that cannot be altered by hypothetical tuple deletions.", "startOffset": 81, "endOffset": 89}, {"referenceID": 37, "context": "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.", "startOffset": 29, "endOffset": 41}, {"referenceID": 38, "context": "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.", "startOffset": 29, "endOffset": 41}, {"referenceID": 39, "context": "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.", "startOffset": 29, "endOffset": 41}, {"referenceID": 25, "context": "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.", "startOffset": 65, "endOffset": 69}, {"referenceID": 9, "context": "Causal responsibility was introduced in [13], to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.", "startOffset": 40, "endOffset": 44}, {"referenceID": 47, "context": "In [55, 7] connections were established between QA-causality and database repairs [4], which allowed to obtain several complexity results for QA-causality related problems.", "startOffset": 3, "endOffset": 10}, {"referenceID": 2, "context": "In [55, 7] connections were established between QA-causality and database repairs [4], which allowed to obtain several complexity results for QA-causality related problems.", "startOffset": 82, "endOffset": 85}, {"referenceID": 44, "context": "Connections between QA-causality and consistency-based diagnosis [52] were established in [55, 7].", "startOffset": 65, "endOffset": 69}, {"referenceID": 47, "context": "Connections between QA-causality and consistency-based diagnosis [52] were established in [55, 7].", "startOffset": 90, "endOffset": 97}, {"referenceID": 47, "context": "More specifically, QA-causality and causal responsibility were characterized in terms of consistency-based diagnosis, which led to new algorithmic results for QA-causality [55, 7].", "startOffset": 172, "endOffset": 179}, {"referenceID": 4, "context": "In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced.", "startOffset": 3, "endOffset": 6}, {"referenceID": 13, "context": "In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced.", "startOffset": 96, "endOffset": 104}, {"referenceID": 18, "context": "In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced.", "startOffset": 96, "endOffset": 104}, {"referenceID": 37, "context": "The definition of QA-causality applies to monotone queries [43, 44].", "startOffset": 59, "endOffset": 67}, {"referenceID": 38, "context": "The definition of QA-causality applies to monotone queries [43, 44].", "startOffset": 59, "endOffset": 67}, {"referenceID": 47, "context": "4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.", "startOffset": 18, "endOffset": 22}, {"referenceID": 27, "context": "4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.", "startOffset": 110, "endOffset": 118}, {"referenceID": 28, "context": "4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.", "startOffset": 110, "endOffset": 118}, {"referenceID": 37, "context": "ever, all complexity and algorithmic results in [43, 55] have been restricted to first-order (FO) monotone queries, mainly conjunctive queries.", "startOffset": 48, "endOffset": 56}, {"referenceID": 47, "context": "ever, all complexity and algorithmic results in [43, 55] have been restricted to first-order (FO) monotone queries, mainly conjunctive queries.", "startOffset": 48, "endOffset": 56}, {"referenceID": 17, "context": "In contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29].", "startOffset": 195, "endOffset": 207}, {"referenceID": 19, "context": "In contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29].", "startOffset": 195, "endOffset": 207}, {"referenceID": 24, "context": "In contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29].", "startOffset": 195, "endOffset": 207}, {"referenceID": 24, "context": "In particular, Datalog can be used as the specification language, giving rise to Datalog-abduction [29].", "startOffset": 99, "endOffset": 103}, {"referenceID": 7, "context": "The delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views.", "startOffset": 31, "endOffset": 43}, {"referenceID": 33, "context": "The delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views.", "startOffset": 31, "endOffset": 43}, {"referenceID": 34, "context": "The delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views.", "startOffset": 31, "endOffset": 43}, {"referenceID": 7, "context": "In a different case, we may want to minimize the side-effects on the view, requiring that other tuples in the (virtual) view contents are not affected (deleted) [10].", "startOffset": 161, "endOffset": 165}, {"referenceID": 48, "context": "This paper is an extension of both [56] and [57].", "startOffset": 35, "endOffset": 39}, {"referenceID": 49, "context": "This paper is an extension of both [56] and [57].", "startOffset": 44, "endOffset": 48}, {"referenceID": 37, "context": "In this section we review the notion of QA-causality as introduced in [43].", "startOffset": 70, "endOffset": 74}, {"referenceID": 37, "context": "The complexity of the computational and decision problems that arise in QA-causality have been investigated in [43, 55].", "startOffset": 111, "endOffset": 119}, {"referenceID": 47, "context": "The complexity of the computational and decision problems that arise in QA-causality have been investigated in [43, 55].", "startOffset": 111, "endOffset": 119}, {"referenceID": 47, "context": "This problem is tractable for UCQs [55].", "startOffset": 35, "endOffset": 39}, {"referenceID": 37, "context": "This problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43].", "startOffset": 36, "endOffset": 40}, {"referenceID": 47, "context": "This problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43].", "startOffset": 50, "endOffset": 54}, {"referenceID": 37, "context": "This problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43].", "startOffset": 85, "endOffset": 89}, {"referenceID": 37, "context": "\u2203xvyu(A(x) \u2227 S1(x, v) \u2227 S2(v, y) \u2227 R(y, u) \u2227 S3(y, z)) is linear, but not \u2203xyz(A(x) \u2227B(y) \u2227 C(z) \u2227W (x, y, z)), for which RDP is NP-complete [43].", "startOffset": 141, "endOffset": 145}, {"referenceID": 47, "context": "This optimization problem is complete (in data) for FP for UCQs [55].", "startOffset": 64, "endOffset": 68}, {"referenceID": 47, "context": "For UCQs this problem is complete for P [55].", "startOffset": 40, "endOffset": 44}, {"referenceID": 38, "context": "A notion of view-conditioned causality [44] will be formalized and investigated in Section 6.", "startOffset": 39, "endOffset": 43}, {"referenceID": 42, "context": "Although one could see an abductive explanation as a cause for the observation, it has been argued that causes and abductive explanations are not necessarily the same [50, 21].", "startOffset": 167, "endOffset": 175}, {"referenceID": 17, "context": "Although one could see an abductive explanation as a cause for the observation, it has been argued that causes and abductive explanations are not necessarily the same [50, 21].", "startOffset": 167, "endOffset": 175}, {"referenceID": 13, "context": "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.", "startOffset": 42, "endOffset": 58}, {"referenceID": 18, "context": "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.", "startOffset": 42, "endOffset": 58}, {"referenceID": 40, "context": "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.", "startOffset": 42, "endOffset": 58}, {"referenceID": 41, "context": "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.", "startOffset": 42, "endOffset": 58}, {"referenceID": 17, "context": "By restricting the explanation formulas to the predicates describing primitive causes (action executions), an explanation formula which entails an observation gives also a cause for the observation [21].", "startOffset": 198, "endOffset": 202}, {"referenceID": 40, "context": "In this case, and is some sense, causality information is imposed by the system specifier [48].", "startOffset": 90, "endOffset": 94}, {"referenceID": 19, "context": "A Datalog abduction problem [23] is of the form AP = \u3008\u03a0, E,Hyp,Obs\u3009, where: (a) \u03a0 is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), (c) Hyp, the hypothesis, is a finite set of ground atoms, the abducible atoms in this case, and (d) Obs, the observation, is a finite conjunction of ground atoms.", "startOffset": 28, "endOffset": 32}, {"referenceID": 47, "context": "7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52].", "startOffset": 5, "endOffset": 9}, {"referenceID": 51, "context": "7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52].", "startOffset": 89, "endOffset": 93}, {"referenceID": 44, "context": "7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52].", "startOffset": 130, "endOffset": 134}, {"referenceID": 13, "context": "For relationships and comparisons between consistency-based and abductive diagnosis see [17].", "startOffset": 88, "endOffset": 92}, {"referenceID": 19, "context": "A comprehensive complexity analysis of several reasoning tasks on abduction from propositional logic programs, in particular of the relevance and necessity problems, can be found in [23].", "startOffset": 182, "endOffset": 186}, {"referenceID": 19, "context": "In [23], it has been shown that for abduction from function-free first-order logic programs, the data complexity of each type of reasoning problem in the firstorder case coincides with the complexity of the same type of reasoning problem in the propositional case.", "startOffset": 3, "endOffset": 7}, {"referenceID": 20, "context": "26] and the complexity of these problems for propositional Horn abduction (PDA), established in [24].", "startOffset": 96, "endOffset": 100}, {"referenceID": 19, "context": "In the Appendix we provide direct, ad hoc proofs by adapting the full machinery developed in [23] for general programs.", "startOffset": 93, "endOffset": 97}, {"referenceID": 24, "context": "However, a tractable case of combined complexity is identified in [29], on the basis of the notions of tree-decomposition and bounded tree-width, which we now briefly present.", "startOffset": 66, "endOffset": 70}, {"referenceID": 23, "context": "If the tree-width of the hypergraph under consideration is bounded by a fixed constant, then many otherwise intractable problems become tractable [28].", "startOffset": 146, "endOffset": 150}, {"referenceID": 47, "context": "of accompanying tuples [55].", "startOffset": 23, "endOffset": 27}, {"referenceID": 47, "context": "This result should be contrasted with the tractability of the same problem for UCQs [55].", "startOffset": 84, "endOffset": 88}, {"referenceID": 47, "context": "Hardness is obtain from the NP-completeness of RDP for conjunctive queries established in [55].", "startOffset": 90, "endOffset": 94}, {"referenceID": 33, "context": "It was first suggested in [38, 39], and here we investigate it more deeply.", "startOffset": 26, "endOffset": 34}, {"referenceID": 34, "context": "It was first suggested in [38, 39], and here we investigate it more deeply.", "startOffset": 26, "endOffset": 34}, {"referenceID": 15, "context": "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.", "startOffset": 41, "endOffset": 45}, {"referenceID": 7, "context": "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.", "startOffset": 64, "endOffset": 76}, {"referenceID": 33, "context": "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.", "startOffset": 64, "endOffset": 76}, {"referenceID": 34, "context": "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.", "startOffset": 64, "endOffset": 76}, {"referenceID": 7, "context": "[10] Let D be a database instance D, and Q(x\u0304) a monotone query.", "startOffset": 0, "endOffset": 4}, {"referenceID": 37, "context": "Proof: This follows from the connection between QA-causality and deletepropagation established in Proposition 10, and the fact that deciding a cause for a monotone query and deciding the subset minimality of an associated contingency set candidate are both in polynomial time in data [43, 7].", "startOffset": 284, "endOffset": 291}, {"referenceID": 7, "context": "In relation to the problems involved in this proposition, the decision problems associated to computing a minimum-side-effect source deletion and computing the responsibility of a cause, both for monotone queries, have been independently established as NP-complete in data, in [10] and [7], resp.", "startOffset": 277, "endOffset": 281}, {"referenceID": 2, "context": "e a cardinality-based repair [4]) of the given instance with respect to the denial constraint that has Q as violation view (instantiated on \u03c4).", "startOffset": 29, "endOffset": 32}, {"referenceID": 36, "context": "The latter problem is in coNP-hard in data [42, 2].", "startOffset": 43, "endOffset": 50}, {"referenceID": 0, "context": "The latter problem is in coNP-hard in data [42, 2].", "startOffset": 43, "endOffset": 50}, {"referenceID": 7, "context": "Appealing to Proposition 14, we can reobtain via repairs and causality the result in [10] about the NP -completeness ofMSSEP(Q).", "startOffset": 85, "endOffset": 89}, {"referenceID": 38, "context": "This form of conditioned causality was suggested in [44]; and formalized in [45], in a more general, nonrelational setting, to give an account of the effect of a tuple on multiple outputs (views).", "startOffset": 52, "endOffset": 56}, {"referenceID": 39, "context": "This form of conditioned causality was suggested in [44]; and formalized in [45], in a more general, nonrelational setting, to give an account of the effect of a tuple on multiple outputs (views).", "startOffset": 76, "endOffset": 80}, {"referenceID": 39, "context": "This has the effect of reducing the spectrum of contingency sets, by keeping Q(D)\u2019s extension fixed (the fixed view extension), except for \u01011 [45].", "startOffset": 142, "endOffset": 146}, {"referenceID": 22, "context": "In this result, NP -hardness is defined in terms of \u201cCook (or Turing) reductions\u201d as opposed to many-one (or Karp) reductions [25, 27].", "startOffset": 126, "endOffset": 134}, {"referenceID": 25, "context": "First, at the basis of Halpern & Pearl\u2019s approach to causality [30], we find interventions, i.", "startOffset": 63, "endOffset": 67}, {"referenceID": 37, "context": "On a different side, QA-causality as introduced in [43] is insensitive to equivalent query rewriting (as first pointed out in [26]): On the same instance, causes for query answers coincide for logically equivalent queries.", "startOffset": 51, "endOffset": 55}, {"referenceID": 21, "context": "On a different side, QA-causality as introduced in [43] is insensitive to equivalent query rewriting (as first pointed out in [26]): On the same instance, causes for query answers coincide for logically equivalent queries.", "startOffset": 126, "endOffset": 130}, {"referenceID": 8, "context": "14 Notice that this rewriting resembles the resolution-based rewritings used in semantic query optimization [12].", "startOffset": 108, "endOffset": 112}, {"referenceID": 37, "context": "For example, for a set \u03a3 of FDs, RDP(Q,\u03a3), the responsibility problem now under FDs, is NP-complete, since this is already the case without ICs [43].", "startOffset": 144, "endOffset": 148}, {"referenceID": 11, "context": "A particular syntactic class of CQs is that of key-preserving CQs: Given a set \u03ba of key constraints (KCs), a CQ Q is key-preserving (more precisely, \u03ba-preserving) if the key attributes of the relations appearing inQ are all included among the non-existentially quantified attributes of Q [15].", "startOffset": 288, "endOffset": 292}, {"referenceID": 10, "context": "It turns out that, in the case of key-preserving CQs, deciding responsibility over instances that satisfy the key constraints (KCs) is in PTIME [14].", "startOffset": 144, "endOffset": 148}, {"referenceID": 11, "context": "It turns out that the decision version of the view-side-effect-free deletion problem for key preserving CQs is tractable in data complexity [15].", "startOffset": 140, "endOffset": 144}, {"referenceID": 33, "context": "Other classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).", "startOffset": 121, "endOffset": 129}, {"referenceID": 34, "context": "Other classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).", "startOffset": 121, "endOffset": 129}, {"referenceID": 11, "context": "Other classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).", "startOffset": 153, "endOffset": 157}, {"referenceID": 11, "context": "15 Actually, the result in [15] just mentioned holds for single tuple deletions (with multiple deletions it can be NP-hard), which is the case in the causality setting, where a single answer is hypothetically deleted.", "startOffset": 27, "endOffset": 31}, {"referenceID": 37, "context": "In the absence of ICs, deciding causality for CQs is tractable [43], but their presence may have an impact on this problem.", "startOffset": 63, "endOffset": 67}, {"referenceID": 30, "context": "In particular, theories written in languages of logic programming have been considered as underlying theories for abduction and view updates in the presence of ICs [35, 36].", "startOffset": 164, "endOffset": 172}, {"referenceID": 31, "context": "In particular, theories written in languages of logic programming have been considered as underlying theories for abduction and view updates in the presence of ICs [35, 36].", "startOffset": 164, "endOffset": 172}, {"referenceID": 14, "context": "More specifically, in [18], view updates via abductive explanations are investigated in the context of stratified logic programs with ICs on the extensional database (as opposed to on the intentional relations).", "startOffset": 22, "endOffset": 26}, {"referenceID": 35, "context": "We briefly illustrate using our ongoing example how Datalog abduction \u00e0 la logic programming with constraints [40] could be used to determine causes in the presence of ICs.", "startOffset": 110, "endOffset": 114}, {"referenceID": 8, "context": "reminiscent of semantic query optimization [12], where satisfied ICs are used to optimize query answering, and also of consistent query answering [4, sec.", "startOffset": 43, "endOffset": 47}, {"referenceID": 37, "context": "It could even be applied with causes for answers to conjunctive queries with negated atoms, and Why-No causes (as opposed to our Why-So causes [43]), i.", "startOffset": 143, "endOffset": 147}, {"referenceID": 14, "context": "This could be treated through view insertions with ICs, for which abduction can also be applied [18].", "startOffset": 96, "endOffset": 100}, {"referenceID": 14, "context": "However, it is worth mentioning that a FO, classical abductive approach to view updates in the presence of ICs is proposed in [18].", "startOffset": 126, "endOffset": 130}, {"referenceID": 6, "context": "It is obtained through the negation (due to a virtual answer deletion) of the (only partially ground) lineage of the instantiated query [60, 9, 37].", "startOffset": 136, "endOffset": 147}, {"referenceID": 32, "context": "It is obtained through the negation (due to a virtual answer deletion) of the (only partially ground) lineage of the instantiated query [60, 9, 37].", "startOffset": 136, "endOffset": 147}, {"referenceID": 50, "context": "17 This kind of queries were considered in [58], with a probabilistic approach.", "startOffset": 43, "endOffset": 47}, {"referenceID": 14, "context": "Predicate completion [41] can be used to deal with more complex Datalog queries [18].", "startOffset": 80, "endOffset": 84}, {"referenceID": 14, "context": "Actually, it holds: (8) \u2227 (11) |= \u00acAnsQ(John) [18].", "startOffset": 46, "endOffset": 50}, {"referenceID": 14, "context": "(c) Complex view (intentional) updates, with both positive and negative ground atoms [18].", "startOffset": 85, "endOffset": 89}, {"referenceID": 43, "context": "The final interaction with the extensional database D, to keep everything in a classical FO setting, can be done (via resolution and the unique names assumption [41]) with the logical reconstruction of D [51].", "startOffset": 204, "endOffset": 208}, {"referenceID": 37, "context": "In [43], causality for non-query-answers, i.", "startOffset": 3, "endOffset": 7}, {"referenceID": 14, "context": "However, concepts and techniques for abduction under ICs as found in [18] and suggested in Section 7.", "startOffset": 69, "endOffset": 73}, {"referenceID": 46, "context": "For example, in [54] and more in the context of interventions for explanations, a ground instantiation, Pi(t\u0304i)\u2192 Pj(t\u0304j), of an inclusion dependency is regarded a causal dependency of Pj(t\u0304j) upon Pi(t\u0304i).", "startOffset": 16, "endOffset": 20}, {"referenceID": 26, "context": "Actually, according to [31] logical dependencies are not causal dependencies per se.", "startOffset": 23, "endOffset": 27}, {"referenceID": 16, "context": "This opens the ground for possible applications of knowledge compilation techniques that are used in knowledge representation [20], and had also provided interesting results in data management [34].", "startOffset": 126, "endOffset": 130}, {"referenceID": 29, "context": "This opens the ground for possible applications of knowledge compilation techniques that are used in knowledge representation [20], and had also provided interesting results in data management [34].", "startOffset": 193, "endOffset": 197}, {"referenceID": 45, "context": "For example, according to [53], ICs are \u201cepistemic in nature\u201d, in the sense that rather than being statements about the domain represented by a database (or knowledge base), they are statement about the contents of the database, or about what it knows.", "startOffset": 26, "endOffset": 30}, {"referenceID": 12, "context": "in [16].", "startOffset": 3, "endOffset": 7}, {"referenceID": 1, "context": "Abduction has been explicitly applied to database repairs [3].", "startOffset": 58, "endOffset": 61}, {"referenceID": 30, "context": "The view-update problem has been treated from the point of view of abductive reasoning [35, 18].", "startOffset": 87, "endOffset": 95}, {"referenceID": 14, "context": "The view-update problem has been treated from the point of view of abductive reasoning [35, 18].", "startOffset": 87, "endOffset": 95}, {"referenceID": 5, "context": "Actually, answer set programs (ASPs) [8] for database repairs [4, chap.", "startOffset": 37, "endOffset": 40}, {"referenceID": 3, "context": "In order to protect sensitive information, in [5] databases are explicitly and virtually \u201crepaired\u201d through secrecy views that specify the information that has to be kept secret.", "startOffset": 46, "endOffset": 49}, {"referenceID": 2, "context": "Repairs are specified and computed using ASP, and an explicit connection to prioritized attribute-based repairs [4].", "startOffset": 112, "endOffset": 115}], "year": 2017, "abstractText": "Causality has been recently introduced in databases, to model, characterize, and possibly compute causes for query answers. Connections between QAcausality and consistency-based diagnosis and database repairs (wrt. integrity constraint violations) have already been established. In this work we establish precise connections between QA-causality and both abductive diagnosis and the view-update problem in databases, allowing us to obtain new algorithmic and complexity results for QA-causality. We also obtain new results on the complexity of view-conditioned causality, and investigate the notion of QA-causality in the presence of integrity constraints, obtaining complexity results from a connection with view-conditioned causality. The abduction connection under integrity constraints allows us to obtain algorithmic tools for QA-causality.", "creator": "LaTeX with hyperref package"}}}