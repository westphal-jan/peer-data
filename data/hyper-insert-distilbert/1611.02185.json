{"id": "1611.02185", "review": {"conference": "iclr", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Nov-2016", "title": "Trusting SVM for Piecewise Linear CNNs", "abstract": "we present a fairly novel layerwise optimization suppression algorithm known for the learning objective features of a large class of layered convolutional integrated neural networks ( gp cnns ). specifically, we continually consider cnns that employ piecewise simultaneous linear optical non - boundary linearities such as coupling the commonly used relu algorithm and associated max - pool, denoted and an unstable svm collision classifier as processing the final layer. certainly the key theoretical observation strategy of advancing our approach is currently that the problem corresponding to preserving the hidden parameter preference estimation coefficients of a layer module can indirectly be formulated as executing a difference - of - convex ( pronounced dc ) program, which happens to ultimately be a comparatively latent structured - svm. locally we cannot optimize the actual dc program using the underlying concave - convex encoding procedure, which requires making us to manually iteratively solve a newly structured svm decision problem. to reach this end, we extend the geometric block - coordinate naive frank - landau wolfe ( bcfw ) detection algorithm in three explicitly important ways : ( initially i ) we better include a trust - mapped region equation for managing the subsequent parameters, ) which temporarily allows us to use taking the previous parameters as an initialization ; ( ii ) first we reduce the simultaneous memory expectation requirement estimates of bcfw objects by potentially distinguishing several orders of magnitude terms for managing the dense layers, which enables first us to learn into a reasonably large overlapping set of arbitrary parameters ; and ( iii ) better we observe for that, empirically, the potentially optimal solution of capturing the structured svm problem query can surprisingly be nearly obtained efficiently by solving a physically related, but obviously significantly easier, multi - class, svm statistical problem. using publicly available data sets, hopefully we actually show both that our approach outperforms the state of modelling the large art efficient variants of binary backpropagation, in and is also more robust to the dynamic hyperparameters of the learning objective.", "histories": [["v1", "Mon, 7 Nov 2016 17:41:20 GMT  (80kb,D)", "https://arxiv.org/abs/1611.02185v1", null], ["v2", "Tue, 8 Nov 2016 23:54:26 GMT  (103kb,D)", "http://arxiv.org/abs/1611.02185v2", null], ["v3", "Sat, 17 Dec 2016 09:19:58 GMT  (216kb,D)", "http://arxiv.org/abs/1611.02185v3", null], ["v4", "Mon, 30 Jan 2017 16:42:22 GMT  (477kb,D)", "http://arxiv.org/abs/1611.02185v4", null], ["v5", "Mon, 6 Mar 2017 16:21:35 GMT  (478kb,D)", "http://arxiv.org/abs/1611.02185v5", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["leonard berrada", "rew zisserman", "m pawan kumar"], "accepted": true, "id": "1611.02185"}, "pdf": {"name": "1611.02185.pdf", "metadata": {"source": "CRF", "title": "TRUSTING SVM FOR PIECEWISE LINEAR CNNS", "authors": ["Leonard Berrada", "Andrew Zisserman", "Pawan Kumar"], "emails": ["lberrada@robots.ox.ac.uk", "az@robots.ox.ac.uk", "pawan@robots.ox.ac.uk"], "sections": [{"heading": "1 INTRODUCTION", "text": "The backpropagation algorithm is commonly employed to estimate the parameters of a convolutional neural network (CNN) using a supervised training data set (Rumelhart et al., 1986). Part of the appeal of backpropagation comes from the fact that it is applicable to a wide variety of networks, namely those that have (sub-)differentiable non-linearities and employ a (sub-)differentiable learning objective. However, the generality of backpropagation comes at the cost of a high sensitivity to its hyperparameters such as the learning rate and momentum. Standard line-search algorithms cannot be used on the primal objective function in this setting, as (i) there may not exist a step-size guaranteeing a monotonic decrease because of the use of sub-gradients, and (ii) even in the smooth case, each function evaluation requires a forward pass over the entire data set without any update, making the approach computationally unfeasible. Choosing the learning rate thus remains an open issue, with the state-of-the-art algorithms suggesting adaptive learning rates (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015). In addition, techniques such as batch normalization (Ioffe & Szegedy, 2015) and dropout (Srivastava et al., 2014) have been introduced to respectively reduce the sensitivity to the learning rate and to prevent from overfitting.\nWith this work, we open a different line of inquiry, namely, is it possible to design more robust optimization algorithms for special but useful classes of CNNs? To this end, we focus on the networks that are commonly used in computer vision. Specifically, we consider CNNs with convolutional and dense layers that apply a set of piecewise linear (PL) non-linear operations to obtain a discriminative representation of an input image. While this assumption may sound restrictive at first, we show that commonly used non-linear operations such as ReLU and max-pool fall under the category of PL functions. The representation obtained in this way is used to classify the image via a multi-class SVM, which forms the final layer of the network. We refer to this class of networks as PL-CNN.\nWe design a novel, principled algorithm to optimize the learning objective of a PL-CNN. Our algorithm is a layerwise method, that is, it iteratively updates the parameters of one layer while keeping the other layers fixed. For this work, we use a simple schedule over the layers, namely, repeated passes from the output layer to the input one. However, it may be possible to further improve the accuracy and efficiency of our algorithm by designing more sophisticated scheduling strategies. The key observation of our approach is that the parameter estimation of one layer of PL-CNN can be\nar X\niv :1\n61 1.\n02 18\n5v 5\n[ cs\n.L G\n] 6\nM ar\n2 01\n7\nformulated as a difference-of-convex (DC) program that can be viewed as a latent structured SVM problem (Yu & Joachims, 2009). This allows us to solve the DC program using the concave-convex procedure (CCCP) (Yuille & Rangarajan, 2002). Each iteration of CCCP requires us to solve a convex structured SVM problem. To this end, we use the powerful block-coordinate Frank-Wolfe (BCFW) algorithm (Lacoste-Julien et al., 2013), which solves the dual of the convex program iteratively by computing the conditional gradients corresponding to a subset of training samples. In order to further improve BCFW for PL-CNNs, we extend it in three important ways. First, we introduce a trust-region term that allows us to initialize the BCFW algorithm using the current estimate of the layer parameters. Second, we reduce the memory requirement of BCFW by an order of magnitude, via an efficient representation of the feature vectors corresponding to the dense layers. Third, we show that, empirically, the number of constraints of the structural SVM problem can be reduced substantially without any loss in accuracy, which allows us to significantly reduce its time complexity.\nCompared to backpropagation (Rumelhart et al., 1986) or its variants (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015), our algorithm offers three advantages. First, the CCCP algorithm provides a monotonic decrease in the learning objective at each layer. Since layerwise optimization itself can be viewed as a block-coordinate method, our algorithm guarantees a monotonic decrease of the overall objective function after each layer\u2019s parameters have been updated. Second, since the dual of the SVM problem is a smooth convex quadratic program, each step of the BCFW algorithm (in the inner iteration of the CCCP) provides a monotonic increase in its dual objective. Third, since the only step-size required in our approach comes while solving the SVM dual, we can use the optimal step-size that is computed analytically during each iteration of BCFW (Lacoste-Julien et al., 2013). In other words, our algorithm has no learning rate, initial or not, that requires tuning.\nUsing standard network architectures and publicly available data sets, we show that our algorithm provides a boost over the state of the art variants of backpropagation for learning PL-CNNs and we demonstrate scalability of the method."}, {"heading": "2 RELATED WORK", "text": "While some of the early successful approaches for the optimization of deep neural networks relied on greedy layer-wise training (Hinton et al., 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction.\nAt every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. This makes the choice of the learning rate critical for efficient optimization. Duchi et al. (2011) have proposed the Adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates. Adagrad changes the learning rate to favor steps in gradient directions that have not been observed frequently in past updates. When applied to the non-convex CNN optimization problem, Adagrad may converge prematurely due to a rapid decrease in the learning rate (Goodfellow et al., 2016). In order to prevent this behavior, the Adadelta algorithm (Zeiler, 2012) makes the decay of the learning rate slower. It is worth noting that this fix is empirical, and to the best of our knowledge, provides no theoretical guarantees. Kingma & Ba (2015) propose a different scheme for the learning rate, called Adam, which uses an online estimation of the first and second moments of the gradients to provide centered and normalized updates. However all these methods still require the tuning of the initial learning rate to perform well.\nSecond-order and natural gradient optimization methods have also been a subject of attention. The focus in this line of work has been to come up with appropriate approximations to make the updates cheaper. Martens & Sutskever (2012) suggested a Hessian-free second order optimization using finite differences to approximate the Hessian and conjugate gradient to compute the update. Martens & Grosse (2015) derive an approximation of the Fisher matrix inverse, which provides a more efficient method for natural gradient descent. Ollivier (2013) explore a set of Riemannian methods based on natural gradient descent and quasi-Newton methods to guarantee reparametrization invariance of the problem. Desjardins et al. (2015) demonstrate a scaled up natural gradient descent method by training on the ImageNet data set (Russakovsky et al., 2015). Though providing more informative updates and solid theoretical support than SGD-based approaches, these methods do not take into account the structure of the problem offered by the commonly used non-linear operations.\nOur work is also related to some of the recent developments in optimization for deep learning. For example, Taylor et al. (2016) use ADMM for massive distribution of computation in a layer-wise fashion, and in particular their method will yield closed-form updates for any PL-CNN. Lee et al. (2015) propose to use targets instead of gradients to propagate information through the network, which could help to extend our algorithm. Zhang et al. (2016) derive a convex relaxation for the learning objective for a restricted class of CNNs, which also relies on solving an approximate convex problem. In (Amos et al., 2016), the authors identify convex problems for the inference task, when the neural network is a convex function of some of its inputs.\nWith a more theoretical approach, Goel et al. (2016) propose an algorithm to learn shallow ReLU nets with guarantees of time convergence and generalization error. Heinemann et al. (2016) show that a subclass of neural networks can be modeled as an improper kernel, which then reduces the learning problem to a simple SVM with the constructed kernel.\nMore generally, we believe that our hitherto unknown observation regarding the relationship between PL-CNNs and latent SVMs can (i) allow the progress made in one field to be transferred to the other and (ii) help design a new generation of principled algorithms for deep learning optimization."}, {"heading": "3 PIECEWISE LINEAR CONVOLUTIONAL NEURAL NETWORKS", "text": "A piecewise linear convolutional neural network (PL-CNN) consists of a series of convolutional layers, followed by a series of dense layers, which provides a concise representation of an input image. Each layer of the network performs two operations: a linear transformation (that is, a convolution or a matrix multiplication), followed by a piecewise linear non-linear operation such as ReLU or max-pool. The resulting representation of the image is used for classification via an SVM. In the remainder of this section, we provide a formal description of PL-CNN.\nPiecewise Linear Functions. A piecewise linear (PL) function f(u) is a function of the following form (Melzer, 1986):\nf(u) = max i\u2208[m] {a>i u} \u2212max j\u2208[n] {b>j u}, (1)\nwhere [m] = {1, \u00b7 \u00b7 \u00b7 ,m}, and [n] = {1, \u00b7 \u00b7 \u00b7 , n}. Each of the two maxima above is a convex function, therefore such a function f is not generally convex, but it is rather a difference of two convex functions. Importantly, many commonly used non-linear operations such as ReLU or max-pool are PL functions of their input. For example, ReLU corresponds to the function R(v) = max{v, 0} where v is a scalar. Similarly, max-pool for a D-dimensional vector u corresponds to M(u) = maxi\u2208[D]{e>i u}, where ei is a vector whose i-th element is 1 and all other elements are 0. Given a value of u, we say that (i\u2217, j\u2217) is the activation of the PL function at u if i\u2217 = argmaxi\u2208[m]{a>i u} and j\u2217 = argmaxj\u2208[n]{b>j u}.\nPL-CNN Parameters. We denote the parameters of an L layer PL-CNN byW = {W l; l \u2208 [L]}. In other words, the parameters of the l-th layer is defined as W l. The CNN defines a composite function, that is, the output zl\u22121 of layer l \u2212 1 is the input to the layer l. Given the input zl\u22121 to layer l, the output is computed as zl = \u03c3l(W l \u00b7 zl\u22121), where \u201c\u00b7\u201d is either a convolution or a matrix multiplication, and \u03c3l is a PL non-linear function, such as ReLU or max-pool. The input to the first layer is an image x, that is, z0 = x. We denote the input to the final layer by zL = \u03a6(x;W) \u2208 RD. In other words, given an image x, the convolutional and dense layers of a PL-CNN provide a Ddimensional representation of x to the final classification layer. The final layer of a PL-CNN is a C class SVM W svm, which specifies one parameter W svmy \u2208 RD for each class y \u2208 Y .\nPrediction. Given an image x, a PL-CNN predicts its class using the following rule:\ny\u2217 = argmax y\u2208Y W svmy \u03a6(x;W). (2)\nIn other words, the dot product of the D-dimensional representation of x with the SVM parameter for a class y provides the score for the class. The desired prediction is obtained by maximizing the score over all possible classes.\nLearning Objective. Given a training data set D = {(xi, yi), i \u2208 [N ]}, where xi is the input image and yi is its ground-truth class, we wish to estimate the parametersW \u222aW svm of the PL-CNN. To this end, we minimize a regularized upper bound on the empirical risk. The risk of a prediction y\u2217i given the ground-truth yi is measured with a user-specified loss function \u2206(y \u2217 i , yi). For example, the standard 0 \u2212 1 loss has a value of 0 for a correct prediction and 1 for an incorrect prediction. Formally, the parameters of a PL-CNN are estimated using the following learning objective:\nmin W,W svm\n\u03bb\n2 \u2211 l\u2208[L]\u222a{svm} \u2016W l\u20162F + 1 N N\u2211 i=1 max y\u0304i\u2208Y ( \u2206(y\u0304i, yi) + ( W svmy\u0304i \u2212W svm yi )T \u03a6(xi;W) ) . (3)\nThe hyperparameter \u03bb denotes the relative weight of the regularization compared to the upper bound of the empirical risk. Note that, due to the presence of piecewise linear non-linearities, the representation \u03a6(\u00b7;W) (and hence, the above objective) is highly non-convex in the PL-CNN parameters."}, {"heading": "4 PARAMETER ESTIMATION FOR PL-CNN", "text": "In order to enable layerwise optimization of PL-CNNs, we show that parameter estimation of a layer can be formulated as a difference-of-convex (DC) program (subsection 4.1). This allows us to use the concave-convex procedure, which solves a series of convex optimization problems (subsection 4.2). We show that each convex problem closely resembles a structured SVM objective, which can be addressed by the powerful block-coordinate Frank-Wolfe (BCFW) algorithm. We extend BCFW to improve its initialization, time complexity and memory requirements, thereby enabling its use in learning PL-CNNs (subsection 4.3). For the sake of clarity, we only provide sketches of the proofs for those propositions that are necessary for understanding the paper. The detailed proofs of the remaining propositions are provided in the Appendix."}, {"heading": "4.1 LAYERWISE OPTIMIZATION AS A DC PROGRAM", "text": "Given the values of the parameters for the convolutional and the dense layers (that is,W), the learning objective (3) is the standard SVM problem in parameters W svm. In other words, it is a convex optimization problem with several efficient solvers (Tsochantaridis et al., 2004; Joachims et al., 2009; Shalev-Shwartz et al., 2009), including the BCFW algorithm (Lacoste-Julien et al., 2013). Hence, the optimization of the final layer is a computationally easy problem. In contrast, the optimization of the parameters of a convolutional or a dense layer l does not result in a convex program. In general, this problem can be arbitrarily hard to solve. However, in the case of PL-CNN, we show that the problem can be formulated as a specific type of DC program, which enables efficient optimization via the iterative use of BCFW. The key property that enables our approach is the following proposition that shows that the composition of PL functions is also a PL function. Proposition 1. Consider PL functions g : Rm \u2192 R and gi : Rn \u2192 R, for all i \u2208 [m]. Define a function f : Rn \u2192 R as f(u) = g([g1(u), g2(u), \u00b7 \u00b7 \u00b7 , gm(u)]>). Then f is also a PL function (proof in Appendix A).\nUsing the above proposition, we can reformulate the problem of optimizing the parameters of one layer of the network as a DC program. Specifically, the following proposition shows that the problem can be formulated as a latent structured SVM objective (Yu & Joachims, 2009). Proposition 2. The learning objective of a PL-CNN with respect to the parameters of the l-th layer can be specified as follows:\nmin W l\n\u03bb 2 \u2016W l\u20162F + 1 N N\u2211 i=1\nmax hi\u2208H y\u0304i\u2208Y\n( \u2206(y\u0304i, yi) + (W l)>\u03a8(xi, y\u0304i,hi) ) \u2212 max\nhi\u2208H\n( (W l)>\u03a8(xi, yi,hi) ) ,\n(4)\nfor an appropriate choice of the latent space H and joint feature vectors \u03a8(x, y,h) of the input x, the output y and the latent variables h. In other words, parameter estimation for the l-th layer corresponds to minimizing the sum of its Frobenius norm plus a PL function for each training sample.\nSketch of the Proof. For a given image x with the ground-truth class y, consider the input to the layer l, which we denote by zl\u22121. Since all the layers except the l-th one are fixed, the input zl\u22121 is a\nconstant vector, which only depends on the image x (that is, its value does not depend on the variables W l). In other words, we can write zl\u22121 = \u03d5(x).\nGiven the input zl\u22121, all the elements of the output of the l-th layer, denoted by zl, are a PL function of W l since the layer performs a linear transformation of zl\u22121 according to the parameters W l, followed by an application of PL operations such as ReLU or max-pool. The vector zl is then fed to the (l + 1)-th layer. The output zl+1 of the (l + 1)-th layer is a vector whose elements are PL functions of zl. Therefore, by proposition (1), the elements of zl+1 are a PL function of W l. By applying the same argument until we reach the layer L, we can conclude that the representation \u03a6(x;W) is a PL function of W l. Next, consider the upper bound of the empirical risk, which is specified as follows:\nmax y\u0304\u2208Y\n( \u2206(y\u0304, y) + ( W svmy\u0304 \u2212W svmy )T \u03a6(x;W) ) . (5)\nOnce again, since W svm is fixed, the above upper bound can be interpreted as a PL function of \u03a6(x;W), and thus, by proposition (1), the upper bound is a PL function of W l. It only remains to observe that the learning objective (3) also contains the Frobenius norm of W l. Thus, it follows that the estimation of the parameters of layer l can be reformulated as minimizing the sum of its Frobenius norm and the PL upper bound of the empirical risk over all training samples, as shown in problem (4). Note that we have ignored the constants corresponding to the Frobenius norm of the parameters of all the fixed layers. This constitutes an existential proof of Proposition 2. In the next paragraph, we give an intuition about the feature vectors \u03a8(xi, y\u0304i,hi) and the latent spaceH.\nFeature Vectors & Latent Space. The exact form of the joint feature vectors depends on the explicit DC decomposition of the objective function. In Appendix B, we detail the practical computations and give an example: we construct two interleaved neural networks whose outputs define the convex and concave parts of the DC objective function. Given the explicit DC objective function, the feature vectors are given by a subgradient and can therefore be obtained by automatic differentiation.\nWe now give an intuition of what the latent space H represents. Consider an input image x and a corresponding latent variable h \u2208 H. The latent variable can be viewed as a set of variables hk, k \u2208 {l + 1, \u00b7 \u00b7 \u00b7 , L}. In other words, each subset hk of the latent variable corresponds to one of the layers of the network that follow the layer l. Intuitively, hk represents the choice of activation at layer k when going through the PL activation: for each neuron j of layer k, hkj takes value i if and only if the i-th piece of the piecewise linear activation is selected. For instance, i is the index of the selected input in the case of a max-pooling unit.\nNote that the latent space only depends on the layers that follow the current layer being optimized. This is due to the fact that the input zl\u22121 to the l-th layer is a constant vector that does not depend on the value of W l. However, the activations of all subsequent layers following the l-th one depend on the value of the parameters W l. As a consequence, the greater the number of following layers, the greater the size of the latent space, and this growth happens to be exponential. However, as will be seen shortly, it is still possible to efficiently optimize problem (4) for all the layers of the network despite this exponential increase."}, {"heading": "4.2 CONCAVE-CONVEX PROCEDURE", "text": "The optimization problem (4) is a DC program in the parameters W l. This follows from the fact that the upper bound of the empirical risk is a PL function, and can therefore be expressed as the difference of two convex PL functions (Melzer, 1986). Furthermore, the Frobenius norm of W l is also a convex function of W l. This observation allows us to obtain an approximate solution of problem (4) using the iterative concave-convex procedure (CCCP) (Yuille & Rangarajan, 2002).\nAlgorithm 1 describes the main steps of CCCP. In step 3, we impute the best value of the latent variable corresponding to the ground-truth class yi for each training sample. This imputation corresponds to the linearization step of the CCCP. The selected latent variable corresponds to a choice of activations at each non-linear layer of the network, and therefore defines a path of activations to the ground truth. Next, in step 4, we update the parameters by solving a convex optimization problem. This convex problem amounts to finding the path of activations which minimizes the maximum margin violations given the path to the ground truth defined in step 3.\nThe CCCP algorithm has the desirable property of providing a monotonic decrease in the objective function at each iteration. In other words, the objective function value of problem (4) at W lt is greater than or equal to its value at W lt+1. Since layerwise optimization itself can be viewed as a block-coordinate algorithm for minimizing the learning objective (3), our overall algorithm provides guarantees of monotonic decrease until convergence. This is one of the main advantages of our approach compared to backpropagation and its variants, which fail to provide similar guarantees on the value of the objective function from one iteration to the next.\nAlgorithm 1 CCCP for parameter estimation of the l-th layer of the PL-CNN.\nRequire: Data set D = {(xi, yi), i \u2208 [N ]}, fixed parameters {W \u222aW svm}\\W l, initial estimate W l0.\n1: t = 0 2: repeat 3: For each sample (xi, yi), find the best latent variable value by solving the following problem:\nh\u2217i = argmax h\u2208H (W lt ) >\u03a8(xi, yi,h). (6)\n4: Update the parameters by solving the following convex optimization problem:\nW lt+1 = argmin W l\n\u03bb 2 \u2016W l\u20162F + 1 N N\u2211 i=1\nmax y\u0304i\u2208Y hi\u2208H\n( \u2206(y\u0304i, yi) + (W l)>\u03a8(xi, y\u0304i,hi) ) \u2212\n( (W l)>\u03a8(xi, yi,h \u2217 i ) ) . (7)\n5: t = t+1 6: until Objective function of problem (4) cannot be improved beyond a specified tolerance.\nIn order to solve the convex program (7), which corresponds to a structured SVM problem, we make use of the powerful BCFW algorithm (Lacoste-Julien et al., 2013) that solves its dual via conditional gradients. This has two main advantages: (i) as the dual is a smooth quadratic program, each iteration of BCFW provides a monotonic increase in its objective; and (ii) the optimal step-size at each iteration can be computed analytically. This is once again in stark contrast to backpropagation, where the estimation of the step-size is still an active area of research (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015). As shown by Lacoste-Julien et al. (2013), given the current estimate of the parameters W l, the conditional gradient of the dual of program (7) with respect to a training sample (xi, yi) can be obtained by solving the following problem:\n(y\u0302i, h\u0302i) = argmax y\u0304\u2208Y,h\u2208H\n(W l)>\u03a8(xi, y\u0304,h) + \u2206(y\u0304, yi). (8)\nWe refer the interested reader to (Lacoste-Julien et al., 2013) for further details.\nThe overall efficiency of the CCCP algorithm relies on our ability to solve problems (6) and (8). At first glance, these problems may appear to be computationally intractable as the latent spaceH can be very large, especially for layers close to the input (of the order of millions of dimensions for a typical network). However, the following proposition shows that both the problems can be solved efficiently using the forward and backward passes that are employed in backpropagation.\nProposition 3. Given the current estimate W l of the parameters for the l-th layer, as well as the parameter values of all the other fixed layers, problems (6) and (8) can be solved using a forward pass on the network. Furthermore, the joint feature vectors \u03a8(xi, y\u0302i, h\u0302i) and \u03a8(xi, yi,h\u2217i ) can be computed using a backward pass on the network.\nSketch of the Proof. Recall that the latent space consists of the putative activations for each PL operation in the layers following the current one. Thus, intuitively, the maximization over the latent variables corresponds to finding the exact activations of all such PL operations. In other words, we need to identify the indices of the linear pieces that are used to compute the value of the PL\nfunction in the current state of the network. For a ReLU operation, this corresponds to estimating max{0, v}, where the input to the ReLU is a scalar v. Similarly, for a max-pool operation, this corresponds to estimating maxi{e>i u}, where u is the input vector to the max-pool. This is precisely the computation that the forward pass of backpropagation performs. Given the activations, the joint feature vector is the subgradient of the sample with respect to the current layer. Once again, this is precisely what is computed during the backward pass of the backpropagation algorithm.\nAn example is constructed in Appendix B to illustrate how to compute the feature vectors in practice."}, {"heading": "4.3 IMPROVING THE BCFW ALGORITHM", "text": "As the BCFW algorithm was originally designed to solve a structured SVM problem, it requires further extensions to be suitable for training a PL-CNN. In what follows, we present three such extensions that improve the initialization, memory requirements and time complexity of the BCFW algorithm respectively.\nTrust-Region for Initialization. The original BCFW algorithm starts with an initial parameter W l = 0 (that is, all the parameters are set to 0). The reason for this initialization is that it is possible to compute the dual variables that correspond to the 0 primal variable. However, since our algorithm visits each layer of the network several times, it would be desirable to initialize its parameters using its current value W tl . To this end, we introduce a trust-region in the constraints of problem (7), or equivalently, an `2 norm based proximal term in its objective function (Parikh & Boyd, 2014). The following proposition shows that this has the desired effect of initializing the BCFW algorithm close to the current parameter values.\nProposition 4. By adding a proximal term \u00b52 \u2016W l \u2212 W lt\u20162F to the objective function in (7), we can compute a feasible dual solution whose corresponding primal solution is equal to \u00b5\u03bb+\u00b5W l t . Furthermore, the addition of the proximal term still allows us to efficiently compute the conditional gradient using a forward-backward pass (proof in Appendix D).\nIn practice, we always choose a value of \u00b5 = 10\u03bb: this yields an initialization of ' 0.9W lt which does not significantly change the value of the objective function.\nEfficient Representation of Joint Feature Vectors. The BCFW algorithm requires us to store a linear combination of the feature vectors for each mini-batch. While this requirement is not too stringent for convolutional and multi-class SVM layers, where the dimensionality of the feature vectors is small, it becomes prohibitively expensive for dense layers. The following proposition prevents a blow-up in the memory requirements of BCFW.\nProposition 5. When optimizing dense layer l, if W l \u2208 Rp\u00d7q, we can store a representation of the joint feature vectors \u03a8(x, y,h) with vectors of size p in problems (6) and (7). This is in contrast to the na\u0131\u0308ve approach that requires them to be of size p\u00d7 q.\nSketch of the Proof. By Proposition (3), the feature vectors are subgradients of the hinge loss function, which we loosely denote by \u03b7 for this proof. Then by the chain rule: \u2202\u03b7\n\u2202W l = \u2202\u03b7 \u2202zl \u2202zl \u2202W l = \u2202\u03b7 \u2202zl \u00b7 ( zl\u22121 )T .\nNoting that zl\u22121 \u2208 Rq is a forward pass up until layer l (independent of W l), we can store only \u2202\u03b7 \u2202zl \u2208 Rp and still reconstruct the full feature vector \u2202\u03b7 \u2202W l by a forward pass and an outer product.\nReducing the Number of Constraints. In order to reduce the amount of time required for the BCFW algorithm to converge, we use the structure ofH to simplify problem (7) to a much simpler problem. Specifically, sinceH represents the activations of the network for a given sample, it has a natural decomposition over the layers: H = H1 \u00d7 ...\u00d7HL. We use this structure in the following observation.\nObservation 1. Problem (7) can be approximately solved by optimizing the dual problem on increasingly large search spaces. In other words, we start with constraints of Y , followed by Y \u00d7HL, then Y \u00d7HL \u00d7HL\u22121 and so on. The algorithm converges when the primal-dual gap is below tolerance.\nThe latent variables which are not optimized over are set to be the same as the ones selected for the ground truth. Experimentally, we observe that for convolutional layers (architectures in section 5), restricting the search space to Y yields a dual gap low enough to consider the problem has converged. This means that in practice for these layers, problem (7) can be solved by searching directions over the search space Y instead of the much larger Y \u00d7 H. The intuition is that the norm of the difference-of-convex decomposition grows with the number of activations selected differently in the convex and concave parts (see Appendix A for the decomposition of piecewise linear functions). This compels the path of activations to be the same in the convex and the concave part to avoid large margin violations, especially for convolutional layers which are followed by numerous non-linearities at the max-pooling layers."}, {"heading": "5 EXPERIMENTS", "text": "Our experiments are designed to assess the ability of LW-SVM (Layer-Wise SVM, our method) and the SGD baselines to optimize problem (3). To compare LW-SVM with the state-of-the-art variants of backpropagation, we look at the training and testing accuracies as well as the training objective value. Unlike dropout, which effectively learns an ensemble model, we learn a single model using each baseline optimization algorithm. All experiments are conducted on a GPU (Nvidia Titan X) and use Theano (Bergstra et al., 2010; Bastien et al., 2012). We compare LW-SVM with Adagrad, Adadelta and Adam. For all data sets, we start at a good solution provided by these solvers and fine-tune it with LW-SVM. We then check whether a longer run of the SGD solver reaches the same level of performance.\nThe practical use of the LW-SVM algorithm needs choices at the three following levels: how to select the layer to optimize (i), when to stop the CCCP on each layer (ii) and when to stop the convex optimization at each inner iteration of the CCCP (iii). These choices are detailed in the next paragraph.\nThe layer-wise schedule of LW-SVM is as follows: as long as the validation accuracy increases, we perform passes from the end of the network (SVM) to the first layer (i). At each pass, each layer is optimized with one outer iteration of the CCCP (ii). The inner iterations are stopped when the dual objective function does not increase by more than 1% over an epoch (iii). We point out that the dual objective function is cheap to compute since we are maintaining its value at all time. By contrast, to compute the exact primal objective function requires a forward pass over the data set without any update."}, {"heading": "5.1 MNIST DATA SET", "text": "Data set & Architecture The training data set consists in 60,000 gray scale images of size 28\u00d7 28 with 10 classes, which we split into 50,000 samples for training and 10,000 for validating. The images are normalized, and we do not use any data augmentation. The architecture used for this experiment is shown in Figure 1.\nMethod The number of epochs is set to 200, 100 and 100 for Adagrad, Adadelta and Adam - Adagrad is given more epochs as we observed it took a longer time to converge. We then use LWSVM and compare the results on training objective, training accuracy and testing accuracy. We also let the solvers run to up to 500 epochs to verify that we have not stopped the optimization prematurely. The regularization hyperparameter \u03bb and the initial learning rate are chosen by cross-validation. \u03bb is set to 0.001 for all solvers, and the initial learning rates can be found in Appendix C. For LW-SVM, \u03bb is set to the same value as the baseline, and the proximal term \u00b5 to \u00b5 = 10\u03bb = 0.01.\nResults As Table 1 shows, LW-SVM systematically improves on all training objective, training accuracy and testing accuracy. In particular, it obtains the best testing accuracy when combined with Adadelta. Because each convex sub-problem is run up to sufficient convergence, the objective function of LW-SVM features of monotonic decrease at each iteration of the CCCP (blue curves in first row of Figure 2)."}, {"heading": "5.2 CIFAR DATA SETS", "text": "Data sets & Architectures The CIFAR-10/100 data sets are comprised of 60,000 RGB natural images of size 32\u00d7 32 with 10/100 classes (Krizhevsky, 2009)). We split the training set into 45,000 training samples and 5,000 validation samples in both cases. The images are centered and normalized, and we do not use any data augmentation. To obtain a strong enough baseline, we employ (i) a pre-training with a softmax and cross-entropy loss and (ii) Batch-Normalization (BN) layers before each non-linearity.\nWe have experimentally found out that pre-training with a softmax layer followed by a cross-entropy loss led to better behavior and results than using an SVM loss alone. The baselines are trained with batch normalization. Once they have converged, the estimated mean and standard deviation are fixed like they would be at test time. Then batch normalization becomes a linear transformation, which can be handled by the LW-SVM algorithm. This allows us to compare LW-SVM with a baseline benefiting from batch normalization. Specifically, we use the architecture shown in Figure 3:\nMethod Again, the initial learning rates and regularization weight \u03bb are obtained by crossvalidation, and a value of 0.001 is obtained for \u03bb for all solvers on both datasets. As before, \u00b5 is set to 10\u03bb. The initial learning rates are reported in Appendix C. The layer schedule and convergence criteria are as described at the beginning of the section. For each SGD optimizer, we train the network for 10 epochs with a cross-entropy loss (preceded by a softmax layer). Then it is trained with an SVM loss (without softmax) for respectively 1000, 100 and 100 epochs for Adagrad, Adadelta and Adam. This amount is doubled to verify that the baselines are not harmed by a premature stopping. Results are presented in Tables 2 and 3.\nResults It can be seen from this set of results that LW-SVM always improves over the solution of the SGD algorithm, for example on CIFAR-100, decreasing the objective value of Adam from 0.22 to 0.06, or improving the test accuracy of Adadelta from 84.4% to 86.6% on CIFAR-10. The automatic step-size allows for a precise fine-tuning to optimize the training objective, while the regularization of the proximal term helps for better generalization."}, {"heading": "5.3 IMAGENET DATA SET", "text": "We show results on the classification task of the ImageNet data set (Russakovsky et al., 2015). The ImageNet data set contains 1.2 million images for training and 50,000 images for validation, each of them mapped to one of the 1,000 classes. For this experiment we use a VGG-16 network (configuration D in (Simonyan & Zisserman, 2015)). We start with a pre-trained model as publicly available online, and we tune each of the dense layers as well as the final SVM layer with the LW-SVM algorithm. This experiment is designed to test the scalability of LW-SVM to large data sets and large networks, rather than comparing with the optimization baselines as before - indeed for any baseline, obtaining proper convergence as in previous experiments would take a very long time. We set the hyperparameters \u03bb to 0.001 and \u00b5 to 10\u03bb as previously. We budget five epochs per layer, which in total takes two days of training on a single GPU (Nvidia Titan X). At training time we used centered crops of size 224\u00d7 224. The evaluation method is the same as the single test scale method described in (Simonyan & Zisserman, 2015). We report the results on the validation set in Table 4, for the Pre-Trained model (PT) and the same model further optimized by LW-SVM (PT+LW-SVM):\nSince the objective function penalizes the top-1 error, it is logical to observe that the improvement is most important on the top-1 accuracy. Importantly, having an efficient representation of feature vectors proves to be essential for such large networks: for instance, in the optimization of the first fully connected layer with a batch-size of 100, the use of our representation lowers the memory requirements of the BCFW algorithm from 7,600GB to 20GB, which can then fit in the memory of a powerful computer."}, {"heading": "6 DISCUSSION", "text": "We presented a novel layerwise optimization algorithm for a large and useful class of convolutional neural networks, which we term PL-CNNs. Our key observation is that the optimization of the parameters of one layer of a PL-CNN is equivalent to solving a latent structured SVM problem. As the problem is a DC program, it naturally lends itself to the iterative CCCP approach, which optimizes a convex structured SVM objective at each iteration. This allows us to leverage the advancements made in structured SVM optimization over the past decade to design a computationally feasible approach for learning PL-CNNs. Specifically, we use the BCFW algorithm and extend it to improve its initialization, memory requirements and time complexity. In particular, this allows our method to not require the tuning of any learning rate. Using the publicly available MNIST, CIFAR-10 and CIFAR-100 data sets, we show that our approach provides a boost for learning PL-CNNs over the state of the art backpropagation algorithms. Furthermore, we demonstrate scalability of the method with results on the ImageNet data set with a large network.\nWhen the mean and standard deviation estimations of batch normalization are not fixed (unlike in our experiments with LW-SVM), batch normalization is not a piecewise linear transformation, and therefore cannot be used in conjunction with the BCFW algorithm for SVMs. However, it is difference-of-convex as it is a C2 function (Horst & Thoai, 1999). Incorporating a normalization scheme into our framework will be the object of future work. With our current methodology, LW-SVM algorithm can already be used on most standard architectures like VGG, Inception and ResNet-type architectures.\nIt is worth noting that other approaches for solving structured SVM problems, such as cuttingplane algorithms (Tsochantaridis et al., 2004; Joachims et al., 2009) and stochastic subgradient descent (Shalev-Shwartz et al., 2009), also rely on the efficiency of estimating the conditional gradient of the dual. Hence, all these methods are equally applicable to our setting. Indeed, the main strength of our approach is the establishment of a hitherto unknown connection between CNNs and latent structured SVMs. We believe that our observation will allow researchers to transfer the substantial existing knowledge of DC programs in general, and latent SVMs specifically, to produce the next generation of principled optimization algorithms for deep learning. In fact, there are already several such improvements that can be readily applied in our setting, which were not explored only due to a lack of time. This includes multi-plane variants of BCFW (Shah et al., 2015; Osokin et al., 2016), as well as generalizations of Frank-Wolfe such as partial linearization (Mohapatra et al., 2016)."}, {"heading": "ACKNOWLEDGMENTS", "text": "This work was supported by the EPSRC AIMS CDT grant EP/L015987/1, the EPSRC Programme Grant Seebibyte EP/M013774/1 and Yougov. Many thanks to A. Desmaison, R. Bunel and D. Bouchacourt for the helpful discussions."}, {"heading": "A PIECEWISE LINEAR FUNCTIONS", "text": "Proof of Proposition (1) By the definition from (Melzer, 1986), we can write each function as the difference of two point-wise maxima of linear functions:\ng(v) = max j\u2208[m+] {a>i v} \u2212 max k\u2208[m\u2212] {b>j v} And \u2200i \u2208 [n], gi(u) = g+i (u)\u2212 g \u2212 i (u)\nWhere all the g+i , g \u2212 i are linear point-wise maxima of linear functions. Then:\nf(u) = g([g1(u), \u00b7 \u00b7 \u00b7 , gn(u)]>) = max j\u2208[m+] {a>j [g1(u), \u00b7 \u00b7 \u00b7 , gn(u)]>} \u2212 max k\u2208[m\u2212] {b>k [g1(u), \u00b7 \u00b7 \u00b7 , gn(u)]>}\n= max j\u2208[m+] { n\u2211 i=1 aj,igi(u) } \u2212 max k\u2208[m\u2212] { n\u2211 i=1 bk,igi(u) }\n= max j\u2208[m+] { n\u2211 i=1 aj,ig + i (u)\u2212 n\u2211 i=1 aj,ig \u2212 i (u) } \u2212 max k\u2208[m\u2212] { n\u2211 i=1 bk,ig + i (u)\u2212 n\u2211 i=1 bk,ig \u2212 i (u) }\n= max j\u2208[m+]  n\u2211 i=1 aj,ig + i (u) + \u2211 j\u2032\u2208[m+]\\{j} n\u2211 i=1 aj,ig \u2212 i (u) \u2212 \u2211 j\u2032\u2208[m+] n\u2211 i=1 aj,ig \u2212 i (u)\n\u2212 max k\u2208[m\u2212]  n\u2211 i=1 bk,ig + i (u) + \u2211 k\u2032\u2208[m\u2212]\\{k} n\u2211 i=1 bk,ig \u2212 i (u) + \u2211 k\u2032\u2208[m\u2212] n\u2211 i=1 bk,ig \u2212 i (u)\n= max j\u2208[m+]  n\u2211 i=1 aj,ig + i (u) + \u2211 j\u2032\u2208[m+]\\{j} n\u2211 i=1 aj,ig \u2212 i (u) + \u2211 k\u2032\u2208[m\u2212] n\u2211 i=1 bk,ig \u2212 i (u)\n\u2212  max k\u2208[m\u2212]  n\u2211 i=1 bk,ig + i (u) + \u2211 k\u2032\u2208[m\u2212]\\{k} n\u2211 i=1 bk,ig \u2212 i (u) + \u2211 j\u2032\u2208[m+] n\u2211 i=1 aj,ig \u2212 i (u)  = max j\u2208[m+]  n\u2211 i=1 aj,ig + i (u) + \u2211 j\u2032\u2208[m+]\\{j} n\u2211 i=1 aj,ig \u2212 i (u) + \u2211 k\u2032\u2208[m\u2212] n\u2211 i=1 bk,ig \u2212 i (u)\n \u2212 max k\u2208[m\u2212]  n\u2211 i=1 bk,ig + i (u) + \u2211 k\u2032\u2208[m\u2212]\\{k} n\u2211 i=1 bk,ig \u2212 i (u) + \u2211 j\u2032\u2208[m+] n\u2211 i=1 aj,ig \u2212 i (u)\n In each line of the last equality, we recognize a pointwise maximum of a linear combination of pointwise maxima of linear functions. This constitutes a pointwise maximum of linear functions.\nThis derivation also extends equation (10) to the multi-dimensional case by showing an explicit DC decomposition of the output."}, {"heading": "B COMPUTING THE FEATURE VECTORS", "text": "We describe here how to compute the feature vectors in practice. To this end, we show how to construct two (intertwined) neural networks that decompose the objective function into a convex and a concave part. We call these Difference of Convex (DC) networks. Once the DC networks are defined, a standard forward and backward pass in the two networks yields the feature vectors for the convex and concave contribution to the objective function. First, we derive how to perform a DC decomposition in linear and non-linear layers, and then we construct an example of DC networks.\nDC Decomposition in a Linear Layer Let W be the weights of a fixed linear layer. We introduce W+ = 12 (|W | + W ) and W \u2212 = 12 (|W | \u2212W ). We can note that W + and W\u2212 have exclusively non-negative weights, and that W = W+\u2212W\u2212. Say we have an input u with the DC decomposition (ucvx, uccv), that is: u = ucvx \u2212 uccv, where both ucvx and uccv are convex. Then we can decompose the output of the layer as:\nW \u00b7 u = (W+ \u00b7 ucvx +W\u2212 \u00b7 uccv)\ufe38 \ufe37\ufe37 \ufe38 convex \u2212 (W\u2212 \u00b7 ucvx +W+ \u00b7 uccv)\ufe38 \ufe37\ufe37 \ufe38 convex\n(9)\nDC Decomposition in a Piecewise Linear Activation Layer For simplicity purposes, we consider that the non-linear layer is a point-wise maximum across [K] scalar inputs, that is, for an input (uk)k\u2208[K] \u2208 RK , the output is maxk\u2208[K] uk (the general multi-dimensional case can be found in Appendix A). We suppose that we have a DC decomposition (ucvxk , u ccv k ) for each input k. Then we can write the following decomposition for the output of the layer:\nmax k\u2208[K] uk = max k\u2208[K]\n(ucvxk \u2212 uccvk )\n= max k\u2208[K] ucvxk + \u2211 i\u2208[K],i6=k uccvi  \ufe38 \ufe37\ufe37 \ufe38\nconvex\n\u2212 \u2211 k\u2208[K]\nuccvk\ufe38 \ufe37\ufe37 \ufe38 convex\n(10)\nIn particular, for a ReLU, we can write:\nmax(ucvx \u2212 uccv, 0) = max(ucvx, uccv)\ufe38 \ufe37\ufe37 \ufe38 convex \u2212 uccv\ufe38\ufe37\ufe37\ufe38 convex\n(11)\nAnd for a Max-Pooling layer, one can easily verify that equation (10) is equivalent to:\nMaxPool(ucvx \u2212 uccv) = MaxPool(ucvx \u2212 uccv) + SumPool(uccv)\ufe38 \ufe37\ufe37 \ufe38 convex \u2212SumPool(uccv)\ufe38 \ufe37\ufe37 \ufe38 convex (12)\nAn Example of DC Networks We use the previous observations to obtain a DC decomposition in any layer. We now take the example of the neural network used for the experiments on the MNIST data set, and we show how to construct the two neural networks when optimizing W 1, the weights of the first convolutional layer. First let us recall the architecture without decomposition:\nWe want to optimize the first convolutional layer, therefore we fix all other parameters. Then we apply all operations as described in the previous paragraphs, which yields the DC networks in Figure 7.\nThe network graph in Figure 7 illustrates Proposition 3 for the optimization of W 1: suppose we are interested in f cvx(x,W 1), the convex part of the objective function for a given sample x, and we wish to obtain the feature vector needed to perform an update of BCFW. With a forward pass, the oracle for the latent and label variables (h\u0302, y\u0302) is efficiently computed; and with a backward pass, we obtain the corresponding feature vector \u03a8(x, y\u0302, h\u0302). Indeed, we recall from problem (8) that (h\u0302, y\u0302) are the latent and label variables maximizing f cvx(x,W 1). Then given x, the forward pass in the DC networks sequentially solves the nested maximization: it maximizes the activation of the ReLU and MaxPooling units at each layer, thereby selecting the best latent variable h\u0302 at each non-linear layer, and maximizes the output of the SVM layer, thereby selecting the best label y\u0302. At the end of the forward pass, f cvx(x,W 1) is therefore available as the output of the convex network, and the feature vector \u03a8(x, y\u0302, h\u0302) can be computed as a subgradient of f cvx(x,W 1) with respect to W 1.\nConcave Network Convex Network\nNon-Decomposed Corresponding\nNetwork\nLinearizing the concave part is equivalent to fixing the activations of the DC networks, which can be done by using a fixed copy of W 1 at the linearization point (all other weights being fixed anyway). Then one can re-use the above reasoning to obtain the feature vectors for the linearized concave part. Altogether, this methodology allows our algorithm to be implemented in any standard deep learning library (our implementation is available at http://github.com/oval-group/pl-cnn)."}, {"heading": "C EXPERIMENTAL DETAILS", "text": "Hyper-parameters The hyper-parameters are obtained by cross-validation with a search on powers of 10. In this section, \u03b7 will denote the initial learning rate. We denote the Softmax + Cross-Entropy loss by SCE, while SVM stands for the usual Support Vector Machines loss.\nOne may note that the hyper-parameters are the same for both CIFAR-10 and CIFAR-100 for each combination of solver and loss. This makes sense since the initial learning rate mainly depends on the architecture of the network (and not so much on which particular images are fed to this network), which is very similar for the experiments on the CIFAR-10 and CIFAR-100 data sets."}, {"heading": "D SVM FORMULATION & DUAL DERIVATION", "text": "Multi-Class SVM Suppose we are given a data set of N samples, for which every sample i has a feature vector \u03c6i \u2208 Rd and a ground truth label yi \u2208 Y . For every possible label y\u0304i \u2208 Y , we introduce the augmented feature vector \u03c8i(y\u0304i) \u2208 R|Y|\u00d7d containing \u03c6i at index y\u0304i, \u2212\u03c6i at index yi, and zeros everywhere else (then \u03c8i(yi) is just a vector of zeros). We also define \u2206(y\u0304i, yi) as the loss by choosing the output y\u0304i instead of the ground truth yi in our task. For classification, this is the zero-one loss for example.\nThe SVM optimization problem is formulated as:\nmin w,\u03bei\n\u03bb 2 \u2016w\u20162 + 1 N N\u2211 i=1 \u03bei\nsubject to: \u2200i \u2208 [N ], \u2200y\u0304i \u2208 Y, \u03bei \u2265 wT\u03c8i(y\u0304i) + \u2206(yi, y\u0304i)\nWhere \u03bb is the regularization hyperparameter. We now add a proximal term to a given starting point w0:\nmin w,\u03bei\n\u03bb 2 \u2016w\u20162 + \u00b5 2 \u2016w \u2212 w0\u20162 + 1 N N\u2211 i=1 \u03bei\nsubject to: \u2200i \u2208 [N ], \u2200y\u0304i \u2208 Y, \u03bei \u2265 wT\u03c8i(y\u0304i) + \u2206(yi, y\u0304i)\nFactorizing the second-order polynomial in w, we obtain the equivalent problem (changed by a constant):\nmin w,\u03bei\n\u03bb+ \u00b5 2 \u2016w \u2212 \u00b5 \u03bb+ \u00b5 w0\u20162 + 1 N N\u2211 i=1 \u03bei\nsubject to: \u2200i \u2208 [N ], \u2200y\u0304i \u2208 Y, \u03bei \u2265 wT\u03c8i(y\u0304i) + \u2206(yi, y\u0304i)\nFor simplicity, we introduce the ratio \u03c1 = \u00b5\n\u03bb+ \u00b5 .\nDual Objective function The primal problem is:\nmin w,\u03bei\n\u03bb+ \u00b5\n2 \u2016w \u2212 \u03c1w0\u20162 +\n1\nN N\u2211 i=1 \u03bei\nsubject to: \u2200i \u2208 [N ], \u2200y\u0304i \u2208 Y, \u03bei \u2265 wT\u03c8i(y\u0304i) + \u2206(yi, y\u0304i)\nThe dual problem can be written as:\nmax \u03b1\u22650 min w,\u03bei\n\u03bb+ \u00b5\n2 \u2016w \u2212 \u03c1w0\u20162 +\n1\nN N\u2211 i=1 \u03bei + 1 N N\u2211 i=1 \u2211 y\u0304i\u2208Y \u03b1i(y\u0304i) ( \u2206(yi, y\u0304i) + w T\u03c8i(y\u0304i)\u2212 \u03bei )\nThen we obtain the following KKT conditions:\n\u2200i \u2208 [N ], \u2202\u00b7 \u2202\u03bei = 0 \u2212\u2192 \u2211 y\u0304i\u2208Y \u03b1i(y\u0304i) = 1\n\u2202\u00b7 \u2202w = 0 \u2212\u2192 w = \u03c1w0 \u2212 1 N 1 \u03bb+ \u00b5 N\u2211 i=1 \u2211 y\u0304i\u2208Y\n\u03b1i(y\u0304i)\u03c8i(y\u0304i)\ufe38 \ufe37\ufe37 \ufe38 A\u03b1\nWe also introduce b = 1N (\u2206(yi, y\u0304i))i,y\u0304i . We define Pn(Y) as the sample-wise probability simplex:\nu \u2208 Pn(Y) if: \u2200i \u2208 [N ], \u2200y\u0304i \u2208 Y, ui(y\u0304i) \u2265 0 \u2200i \u2208 [N ], \u2211 y\u0304i\u2208Y ui(y\u0304i) = 1\nWe inject back and simplify to:\nmax \u03b1\u2208Pn(Y) \u2212(\u03bb+ \u00b5) 2 \u2016A\u03b1\u20162 + \u00b5wT0 (A\u03b1) + \u03b1T b\nFinally:\nmin \u03b1\u2208Pn(Y) f(\u03b1)\nWhere: f(\u03b1) , \u03bb+ \u00b5\n2 \u2016A\u03b1\u20162 \u2212 \u00b5wT0 (A\u03b1)\u2212 \u03b1T b\nBCFW derivation We write \u2207(i)f the gradient of f w.r.t. the block (i) of variables in \u03b1, padded with zeros on blocks (j) for j 6= i. Similarly, A(i) and b(i) contain the rows of A and the elements of b for the block of coordinates (i) and zeros elsewhere. We can write:\n\u2207(i)f(\u03b1) = (\u03bb+ \u00b5)AT(i)A\u03b1\u2212 \u00b5A(i)w0 \u2212 b(i) Then the search corner for the block of coordinates (i) is given by:\nsi = argmin s\u2032i\n( < s\u2032i,\u2207(i)f(\u03b1) > ) = argmin\ns\u2032i\n( (\u03bb+ \u00b5)\u03b1TATA(i)s \u2032 i \u2212 \u00b5wT0 A(i)s\u2032i \u2212 bT(i)s \u2032 i ) We replace:\nA\u03b1 = \u03c1w0 \u2212 w\nA(i)s \u2032 i =\n1\nN\n1\n\u03bb+ \u00b5 \u2211 y\u0304i\u2208Y s\u2032i(y\u0304i)\u03c8i(y\u0304i)\nbT(i)s \u2032 i =\n1\nN \u2211 y\u0304i\u2208Y s\u2032i(y\u0304i)\u2206(y\u0304i, yi)\nWe then obtain:\nsi = argmin s\u2032i \u2212(w \u2212 \u03c1w0)T \u2211 y\u0304i\u2208Y s\u2032i(y\u0304i)\u03c8i(y\u0304i)\u2212 wT0 \u03c1 \u2211 y\u0304i\u2208Y s\u2032i(y\u0304i)\u03c8i(y\u0304i)\u2212 \u2211 y\u0304i\u2208Y s\u2032i(y\u0304i)\u2206(y\u0304i, yi)  = argmax\ns\u2032i wT \u2211 y\u0304i\u2208Y s\u2032i(y\u0304i)\u03c8i(y\u0304i) + \u2211 y\u0304i\u2208Y s\u2032i(y\u0304i)\u2206(y\u0304i, yi)  As expected, this maximum is obtained by setting si to one at y\u2217i = argmax\ny\u0304i\u2208Y\n( wT\u03c8i(y\u0304i) + \u2206(y\u0304i, yi) ) and zeros elsewhere. We introduce the notation:\nwi = \u2212A(i)\u03b1(i) li = b T (i)\u03b1(i)\nws = \u2212A(i)si ls = b T (i)si\nThen we have:\nws = \u2212 1\nN\n1\n\u03bb+ \u00b5 \u03c8(y\u2217i ) = \u2212\n1\nN\n1\n\u03bb+ \u00b5\n\u2202Hi(y \u2217 i )\n\u2202w\nls = 1\nN \u2206(yi, y\n\u2217 i )\nThe optimal step size in the direction of the block of coordinates (i) is given by :\n\u03b3\u2217 = argmin \u03b3 f(\u03b1+ \u03b3(si \u2212 \u03b1i))\nThe optimal step-size is given by:\n\u03b3\u2217 = < \u2207(i)f(\u03b1), si \u2212 \u03b1i > (\u03bb+ \u00b5)\u2016A(si \u2212 \u03b1i)\u20162\nWe introduce wd = \u2212A\u03b1 = w \u2212 \u03c1w0. Then we obtain:\n\u03b3\u2217 = (wi \u2212 ws)T (w \u2212 \u03c1w0) + \u03c1wT0 (wi \u2212 ws)\u2212 1\u03bb+\u00b5 (li \u2212 ls)\n\u2016wi \u2212 ws\u20162\n= (wi \u2212 ws)Tw \u2212 1\u03bb+\u00b5 (li \u2212 ls)\n\u2016wi \u2212 ws\u20162\nAnd the updates are the same as in standard BCFW:\nAlgorithm 2 BCFW with warm start\n1: Let w(0) = w0, \u2200i \u2208 [N ], w(0)i = 0 2: Let l(0) = 0, \u2200i \u2208 [N ], l(0)i = 0 3: for k=0...K do 4: Pick i randomly in {1, .., n}\n5: Get y\u2217i = argmax y\u0304i\u2208Y Hi(y\u0304i, w (k)) and ws = \u2212\n1\nN\n1\n\u03bb+ \u00b5\n\u2202Hi(y \u2217 i , w (k))\n\u2202w(k)\n6: ls = 1 N\u2206(y \u2217 i , yi) 7: \u03b3 = (wi \u2212 ws)Tw \u2212 1\u03bb+\u00b5 (li \u2212 ls)\n\u2016wi \u2212 ws\u20162 clipped to [0, 1]\n8: w(k+1)i = (1\u2212 \u03b3)w (k) i + \u03b3ws 9: l(k+1)i = (1\u2212 \u03b3)l (k) i + \u03b3ls\n10: w(k+1) = w(k) + w(k+1)i \u2212 w (k) i = w (k) + \u03b3(w (k) s \u2212 w(k)i ) 11: l(k+1) = l(k) + l(k+1)i \u2212 l (k) i 12: end for\nIn particular, we have proved Proposition (4) in this section: w is initialized to \u03c1w0 (KKT conditions), and the direction of the conditional gradient, ws, is given by \u2202Hi(y \u2217 i )\n\u2202w , which is independent of w0.\nNote that the derivation of the Lagrangian dual has introduced a dual variable \u03b1i(y\u0304i) for each linear constraint of the SVM problem (this can be replaced by \u03b1i(hi, (y\u0304i)) if we consider latent variables). These dual variables indicate the complementary slackness not only for the output class y\u0304i, but also for each of the activation which defines a piece of the piecewise linear hinge loss. Therefore a choice of \u03b1 defines a path of activations."}, {"heading": "E SENSITIVITY OF SGD ALGORITHMS", "text": "Here we discuss some weaknesses of the SGD-based algorithms that we have encountered in practice for our learning objective function. These behaviors have been observed in the case of PL-CNNs, and generally may not appear in different architectures (in particular the failure to learn with high regularization goes away with the use of batch normalization layers).\nE.1 INITIAL LEARNING RATE\nAs mentioned in the experiments section, the choice of the initial learning rate is critical for good performance of all Adagrad, Adadelta and Adam. When the learning rate is too high, the network does not learn anything and the training and validating accuracies are stuck at random level. When it is too low, the network may take a considerably greater number of epochs to converge.\nE.2 FAILURES TO LEARN\nRegularization When the regularization hyper-parameter \u03bb is set to a value of 0.01 or higher on CIFAR-10, SGD solvers get trapped in a local minimum and fail to learn. The SGD solvers indeed fall in the local minimum of shutting down all activations on ReLUs, which provide zero-valued feature vector to the SVM loss layer (and a hinge loss of one). As a consequence, no information can be back-propagated. We plot this behavior below:\nIn this situation, the network is at a bad saddle point (note that the training and validation accuracies are stuck at random levels). Our algorithm does not fall into such bad situations, however it is not able to get out of it either: each layer is at a pathological critical point of its own objective function, which makes our algorithm unable to escape from it.\nWith a lower initial learning rate, the evolution is slower, but eventually the solver goes back to the bad situation presented above.\nBiases The same failing behavior as above has been observed when not using the biases in the network. Again our algorithm is robust to this change."}], "references": [{"title": "Input convex neural networks", "author": ["Brandon Amos", "Lei Xu", "J. Zico Kolter"], "venue": "arXiv preprint arXiv:1609.07152,", "citeRegEx": "Amos et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Amos et al\\.", "year": 2016}, {"title": "Greedy layer-wise training of deep networks", "author": ["Yoshua Bengio", "Pascal Lamblin", "Dan Popovici", "Hugo Larochelle"], "venue": "Conference on Neural Information Processing Systems,", "citeRegEx": "Bengio et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bengio et al\\.", "year": 2007}, {"title": "Theano: a CPU and GPU math expression compiler", "author": ["James Bergstra", "Olivier Breuleux", "Fr\u00e9d\u00e9ric Bastien", "Pascal Lamblin", "Razvan Pascanu", "Guillaume Desjardins", "Joseph Turian", "David Warde-Farley", "Yoshua Bengio"], "venue": "Python for Scientific Computing Conference (SciPy),", "citeRegEx": "Bergstra et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bergstra et al\\.", "year": 2010}, {"title": "Adaptive subgradient methods for online learning and stochastic optimization", "author": ["John Duchi", "Elad Hazan", "Yoram Singer"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Duchi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Duchi et al\\.", "year": 2011}, {"title": "Reliably learning the ReLU in polynomial time", "author": ["Surbhi Goel", "Varun Kanade", "Adam Klivans", "Justin Thaler"], "venue": "arXiv preprint arXiv:1611.10258,", "citeRegEx": "Goel et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Goel et al\\.", "year": 2016}, {"title": "Deep Learning", "author": ["Ian Goodfellow", "Yoshua Bengio", "Aaron Courville"], "venue": null, "citeRegEx": "Goodfellow et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2016}, {"title": "Improper deep kernels", "author": ["Uri Heinemann", "Roi Livni", "Elad Eban", "Gal Elidan", "Amir Globerson"], "venue": "International Conference on Artificial Intelligence and Statistics,", "citeRegEx": "Heinemann et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Heinemann et al\\.", "year": 2016}, {"title": "A fast learning algorithm for deep belief nets", "author": ["Geoffrey E Hinton", "Simon Osindero", "Yee-Whye Teh"], "venue": "Neural computation,", "citeRegEx": "Hinton et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2006}, {"title": "DC programming: overview", "author": ["Reiner Horst", "Nguyen V. Thoai"], "venue": "Journal of Optimization Theory and Applications,", "citeRegEx": "Horst and Thoai.,? \\Q1999\\E", "shortCiteRegEx": "Horst and Thoai.", "year": 1999}, {"title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "author": ["Sergey Ioffe", "Christian Szegedy"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Ioffe and Szegedy.,? \\Q2015\\E", "shortCiteRegEx": "Ioffe and Szegedy.", "year": 2015}, {"title": "Cutting-plane training of structural SVMs", "author": ["Thorsten Joachims", "Thomas Finley", "Chun-Nam John Yu"], "venue": "Machine Learning,", "citeRegEx": "Joachims et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Joachims et al\\.", "year": 2009}, {"title": "Adam: A method for stochastic optimization", "author": ["Diederik Kingma", "Jimmy Ba"], "venue": "International Conference on Learning Representations,", "citeRegEx": "Kingma and Ba.,? \\Q2015\\E", "shortCiteRegEx": "Kingma and Ba.", "year": 2015}, {"title": "Learning multiple layers of features from tiny images", "author": ["Alex Krizhevsky"], "venue": "Technical report, University of Toronto,", "citeRegEx": "Krizhevsky.,? \\Q2009\\E", "shortCiteRegEx": "Krizhevsky.", "year": 2009}, {"title": "Block-coordinate FrankWolfe optimization for structural SVMs", "author": ["Simon Lacoste-Julien", "Martin Jaggi", "Mark Schmidt", "Patrick Pletscher"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Lacoste.Julien et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Lacoste.Julien et al\\.", "year": 2013}, {"title": "Difference target propagation", "author": ["Dong-Hyun Lee", "Saizheng Zhang", "Asja Fischer", "Yoshua Bengio"], "venue": "Joint European Conference on Machine Learning and Knowledge Discovery in Databases,", "citeRegEx": "Lee et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2015}, {"title": "Optimizing neural networks with Kronecker-factored approximate curvature", "author": ["James Martens", "Roger Grosse"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Martens and Grosse.,? \\Q2015\\E", "shortCiteRegEx": "Martens and Grosse.", "year": 2015}, {"title": "Training deep and recurrent networks with hessian-free optimization", "author": ["James Martens", "Ilya Sutskever"], "venue": "Neural Networks: Tricks of the Trade,", "citeRegEx": "Martens and Sutskever.,? \\Q2012\\E", "shortCiteRegEx": "Martens and Sutskever.", "year": 2012}, {"title": "On the expressibility of piecewise-linear continuous functions as the difference of two piecewise-linear convex functions", "author": ["D. Melzer"], "venue": null, "citeRegEx": "Melzer.,? \\Q1986\\E", "shortCiteRegEx": "Melzer.", "year": 1986}, {"title": "Partial linearization based optimization for multi-class SVM", "author": ["Pritish Mohapatra", "Puneet Dokania", "CV Jawahar", "M Pawan Kumar"], "venue": "European Conference on Computer Vision,", "citeRegEx": "Mohapatra et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Mohapatra et al\\.", "year": 2016}, {"title": "Riemannian metrics for neural networks", "author": ["Yann Ollivier"], "venue": "Information and Inference: a Journal of the IMA,", "citeRegEx": "Ollivier.,? \\Q2013\\E", "shortCiteRegEx": "Ollivier.", "year": 2013}, {"title": "Minding the gaps for block Frank-Wolfe optimization of structured SVMs", "author": ["Anton Osokin", "Jean-Baptiste Alayrac", "Isabella Lukasewitz", "Puneet Dokania", "Simon LacosteJulien"], "venue": "Inernational Conference on Machine Learning,", "citeRegEx": "Osokin et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Osokin et al\\.", "year": 2016}, {"title": "Learning representations by backpropagating errors", "author": ["David Rumelhart", "Geoffrey Hinton", "Ronald Williams"], "venue": "Nature,", "citeRegEx": "Rumelhart et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Rumelhart et al\\.", "year": 1986}, {"title": "A multi-plane block-coordinate Frank-Wolfe algorithm for training structural SVMs with a costly max-oracle", "author": ["Neel Shah", "Vladimir Kolmogorov", "Christoph H. Lampert"], "venue": "Conference on Computer Vision and Pattern Recognition,", "citeRegEx": "Shah et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Shah et al\\.", "year": 2015}, {"title": "Pegasos: Primal estimated sub-gradient solver for SVM", "author": ["Shai Shalev-Shwartz", "Yoram Singer", "Nathan Srebro"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Shalev.Shwartz et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Shalev.Shwartz et al\\.", "year": 2009}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["Karen Simonyan", "Andrew Zisserman"], "venue": "International Conference on Learning Representations,", "citeRegEx": "Simonyan and Zisserman.,? \\Q2015\\E", "shortCiteRegEx": "Simonyan and Zisserman.", "year": 2015}, {"title": "Dropout: a simple way to prevent neural networks from overfitting", "author": ["Nitish Srivastava", "Geoffrey Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "Srivastava et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Srivastava et al\\.", "year": 2014}, {"title": "Training neural networks without gradients: A scalable ADMM approach", "author": ["Gavin Taylor", "Ryan Burmeister", "Zheng Xu", "Bharat Singh", "Ankit Patel", "Tom Goldstein"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Taylor et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Taylor et al\\.", "year": 2016}, {"title": "Support vector machine learning for interdependent and structured output spaces", "author": ["Ioannis Tsochantaridis", "Thomas Hofmann", "Thorsten Joachims", "Yasemin Altun"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Tsochantaridis et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Tsochantaridis et al\\.", "year": 2004}, {"title": "Learning structural SVMs with latent variables", "author": ["Chun-Nam John Yu", "Thorsten Joachims"], "venue": "International Conference on Machine Learning,", "citeRegEx": "Yu and Joachims.,? \\Q2009\\E", "shortCiteRegEx": "Yu and Joachims.", "year": 2009}, {"title": "The concave-convex procedure (CCCP)", "author": ["Alan L. Yuille", "Anand Rangarajan"], "venue": "Conference on Neural Information Processing Systems,", "citeRegEx": "Yuille and Rangarajan.,? \\Q2002\\E", "shortCiteRegEx": "Yuille and Rangarajan.", "year": 2002}, {"title": "ADADELTA: an adaptive learning rate method", "author": ["Matthew Zeiler"], "venue": null, "citeRegEx": "Zeiler.,? \\Q2012\\E", "shortCiteRegEx": "Zeiler.", "year": 2012}, {"title": "Convexified convolutional neural networks", "author": ["Yuchen Zhang", "Percy Liang", "Martin J. Wainwright"], "venue": "arXiv preprint arXiv:1609.01000,", "citeRegEx": "Zhang et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2016}], "referenceMentions": [{"referenceID": 21, "context": "The backpropagation algorithm is commonly employed to estimate the parameters of a convolutional neural network (CNN) using a supervised training data set (Rumelhart et al., 1986).", "startOffset": 155, "endOffset": 179}, {"referenceID": 3, "context": "Choosing the learning rate thus remains an open issue, with the state-of-the-art algorithms suggesting adaptive learning rates (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015).", "startOffset": 127, "endOffset": 180}, {"referenceID": 30, "context": "Choosing the learning rate thus remains an open issue, with the state-of-the-art algorithms suggesting adaptive learning rates (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015).", "startOffset": 127, "endOffset": 180}, {"referenceID": 25, "context": "In addition, techniques such as batch normalization (Ioffe & Szegedy, 2015) and dropout (Srivastava et al., 2014) have been introduced to respectively reduce the sensitivity to the learning rate and to prevent from overfitting.", "startOffset": 88, "endOffset": 113}, {"referenceID": 13, "context": "To this end, we use the powerful block-coordinate Frank-Wolfe (BCFW) algorithm (Lacoste-Julien et al., 2013), which solves the dual of the convex program iteratively by computing the conditional gradients corresponding to a subset of training samples.", "startOffset": 79, "endOffset": 108}, {"referenceID": 21, "context": "Compared to backpropagation (Rumelhart et al., 1986) or its variants (Duchi et al.", "startOffset": 28, "endOffset": 52}, {"referenceID": 3, "context": ", 1986) or its variants (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015), our algorithm offers three advantages.", "startOffset": 24, "endOffset": 77}, {"referenceID": 30, "context": ", 1986) or its variants (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015), our algorithm offers three advantages.", "startOffset": 24, "endOffset": 77}, {"referenceID": 13, "context": "Third, since the only step-size required in our approach comes while solving the SVM dual, we can use the optimal step-size that is computed analytically during each iteration of BCFW (Lacoste-Julien et al., 2013).", "startOffset": 184, "endOffset": 213}, {"referenceID": 7, "context": "While some of the early successful approaches for the optimization of deep neural networks relied on greedy layer-wise training (Hinton et al., 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al.", "startOffset": 128, "endOffset": 170}, {"referenceID": 1, "context": "While some of the early successful approaches for the optimization of deep neural networks relied on greedy layer-wise training (Hinton et al., 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al.", "startOffset": 128, "endOffset": 170}, {"referenceID": 21, "context": ", 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction.", "startOffset": 69, "endOffset": 93}, {"referenceID": 5, "context": "When applied to the non-convex CNN optimization problem, Adagrad may converge prematurely due to a rapid decrease in the learning rate (Goodfellow et al., 2016).", "startOffset": 135, "endOffset": 160}, {"referenceID": 30, "context": "In order to prevent this behavior, the Adadelta algorithm (Zeiler, 2012) makes the decay of the learning rate slower.", "startOffset": 58, "endOffset": 72}, {"referenceID": 1, "context": ", 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction. At every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. This makes the choice of the learning rate critical for efficient optimization. Duchi et al. (2011) have proposed the Adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates.", "startOffset": 8, "endOffset": 462}, {"referenceID": 1, "context": ", 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction. At every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. This makes the choice of the learning rate critical for efficient optimization. Duchi et al. (2011) have proposed the Adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates. Adagrad changes the learning rate to favor steps in gradient directions that have not been observed frequently in past updates. When applied to the non-convex CNN optimization problem, Adagrad may converge prematurely due to a rapid decrease in the learning rate (Goodfellow et al., 2016). In order to prevent this behavior, the Adadelta algorithm (Zeiler, 2012) makes the decay of the learning rate slower. It is worth noting that this fix is empirical, and to the best of our knowledge, provides no theoretical guarantees. Kingma & Ba (2015) propose a different scheme for the learning rate, called Adam, which uses an online estimation of the first and second moments of the gradients to provide centered and normalized updates.", "startOffset": 8, "endOffset": 1135}, {"referenceID": 1, "context": ", 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction. At every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. This makes the choice of the learning rate critical for efficient optimization. Duchi et al. (2011) have proposed the Adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates. Adagrad changes the learning rate to favor steps in gradient directions that have not been observed frequently in past updates. When applied to the non-convex CNN optimization problem, Adagrad may converge prematurely due to a rapid decrease in the learning rate (Goodfellow et al., 2016). In order to prevent this behavior, the Adadelta algorithm (Zeiler, 2012) makes the decay of the learning rate slower. It is worth noting that this fix is empirical, and to the best of our knowledge, provides no theoretical guarantees. Kingma & Ba (2015) propose a different scheme for the learning rate, called Adam, which uses an online estimation of the first and second moments of the gradients to provide centered and normalized updates. However all these methods still require the tuning of the initial learning rate to perform well. Second-order and natural gradient optimization methods have also been a subject of attention. The focus in this line of work has been to come up with appropriate approximations to make the updates cheaper. Martens & Sutskever (2012) suggested a Hessian-free second order optimization using finite differences to approximate the Hessian and conjugate gradient to compute the update.", "startOffset": 8, "endOffset": 1653}, {"referenceID": 1, "context": ", 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction. At every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. This makes the choice of the learning rate critical for efficient optimization. Duchi et al. (2011) have proposed the Adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates. Adagrad changes the learning rate to favor steps in gradient directions that have not been observed frequently in past updates. When applied to the non-convex CNN optimization problem, Adagrad may converge prematurely due to a rapid decrease in the learning rate (Goodfellow et al., 2016). In order to prevent this behavior, the Adadelta algorithm (Zeiler, 2012) makes the decay of the learning rate slower. It is worth noting that this fix is empirical, and to the best of our knowledge, provides no theoretical guarantees. Kingma & Ba (2015) propose a different scheme for the learning rate, called Adam, which uses an online estimation of the first and second moments of the gradients to provide centered and normalized updates. However all these methods still require the tuning of the initial learning rate to perform well. Second-order and natural gradient optimization methods have also been a subject of attention. The focus in this line of work has been to come up with appropriate approximations to make the updates cheaper. Martens & Sutskever (2012) suggested a Hessian-free second order optimization using finite differences to approximate the Hessian and conjugate gradient to compute the update. Martens & Grosse (2015) derive an approximation of the Fisher matrix inverse, which provides a more efficient method for natural gradient descent.", "startOffset": 8, "endOffset": 1826}, {"referenceID": 1, "context": ", 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction. At every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. This makes the choice of the learning rate critical for efficient optimization. Duchi et al. (2011) have proposed the Adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates. Adagrad changes the learning rate to favor steps in gradient directions that have not been observed frequently in past updates. When applied to the non-convex CNN optimization problem, Adagrad may converge prematurely due to a rapid decrease in the learning rate (Goodfellow et al., 2016). In order to prevent this behavior, the Adadelta algorithm (Zeiler, 2012) makes the decay of the learning rate slower. It is worth noting that this fix is empirical, and to the best of our knowledge, provides no theoretical guarantees. Kingma & Ba (2015) propose a different scheme for the learning rate, called Adam, which uses an online estimation of the first and second moments of the gradients to provide centered and normalized updates. However all these methods still require the tuning of the initial learning rate to perform well. Second-order and natural gradient optimization methods have also been a subject of attention. The focus in this line of work has been to come up with appropriate approximations to make the updates cheaper. Martens & Sutskever (2012) suggested a Hessian-free second order optimization using finite differences to approximate the Hessian and conjugate gradient to compute the update. Martens & Grosse (2015) derive an approximation of the Fisher matrix inverse, which provides a more efficient method for natural gradient descent. Ollivier (2013) explore a set of Riemannian methods based on natural gradient descent and quasi-Newton methods to guarantee reparametrization invariance of the problem.", "startOffset": 8, "endOffset": 1965}, {"referenceID": 1, "context": ", 2006; Bengio et al., 2007), most currently used methods are variants of backpropagation (Rumelhart et al., 1986) with adaptive learning rates, as discussed in the introduction. At every iteration, backpropagation performs a forward pass and a backward pass on the network, and updates the parameters of each layer by stochastic or mini-batch gradient descent. This makes the choice of the learning rate critical for efficient optimization. Duchi et al. (2011) have proposed the Adagrad convex solver, which adapts the learning rate for every direction and takes into account past updates. Adagrad changes the learning rate to favor steps in gradient directions that have not been observed frequently in past updates. When applied to the non-convex CNN optimization problem, Adagrad may converge prematurely due to a rapid decrease in the learning rate (Goodfellow et al., 2016). In order to prevent this behavior, the Adadelta algorithm (Zeiler, 2012) makes the decay of the learning rate slower. It is worth noting that this fix is empirical, and to the best of our knowledge, provides no theoretical guarantees. Kingma & Ba (2015) propose a different scheme for the learning rate, called Adam, which uses an online estimation of the first and second moments of the gradients to provide centered and normalized updates. However all these methods still require the tuning of the initial learning rate to perform well. Second-order and natural gradient optimization methods have also been a subject of attention. The focus in this line of work has been to come up with appropriate approximations to make the updates cheaper. Martens & Sutskever (2012) suggested a Hessian-free second order optimization using finite differences to approximate the Hessian and conjugate gradient to compute the update. Martens & Grosse (2015) derive an approximation of the Fisher matrix inverse, which provides a more efficient method for natural gradient descent. Ollivier (2013) explore a set of Riemannian methods based on natural gradient descent and quasi-Newton methods to guarantee reparametrization invariance of the problem. Desjardins et al. (2015) demonstrate a scaled up natural gradient descent method by training on the ImageNet data set (Russakovsky et al.", "startOffset": 8, "endOffset": 2143}, {"referenceID": 0, "context": "In (Amos et al., 2016), the authors identify convex problems for the inference task, when the neural network is a convex function of some of its inputs.", "startOffset": 3, "endOffset": 22}, {"referenceID": 22, "context": "For example, Taylor et al. (2016) use ADMM for massive distribution of computation in a layer-wise fashion, and in particular their method will yield closed-form updates for any PL-CNN.", "startOffset": 13, "endOffset": 34}, {"referenceID": 11, "context": "Lee et al. (2015) propose to use targets instead of gradients to propagate information through the network, which could help to extend our algorithm.", "startOffset": 0, "endOffset": 18}, {"referenceID": 11, "context": "Lee et al. (2015) propose to use targets instead of gradients to propagate information through the network, which could help to extend our algorithm. Zhang et al. (2016) derive a convex relaxation for the learning objective for a restricted class of CNNs, which also relies on solving an approximate convex problem.", "startOffset": 0, "endOffset": 170}, {"referenceID": 0, "context": "In (Amos et al., 2016), the authors identify convex problems for the inference task, when the neural network is a convex function of some of its inputs. With a more theoretical approach, Goel et al. (2016) propose an algorithm to learn shallow ReLU nets with guarantees of time convergence and generalization error.", "startOffset": 4, "endOffset": 206}, {"referenceID": 0, "context": "In (Amos et al., 2016), the authors identify convex problems for the inference task, when the neural network is a convex function of some of its inputs. With a more theoretical approach, Goel et al. (2016) propose an algorithm to learn shallow ReLU nets with guarantees of time convergence and generalization error. Heinemann et al. (2016) show that a subclass of neural networks can be modeled as an improper kernel, which then reduces the learning problem to a simple SVM with the constructed kernel.", "startOffset": 4, "endOffset": 340}, {"referenceID": 17, "context": "A piecewise linear (PL) function f(u) is a function of the following form (Melzer, 1986): f(u) = max i\u2208[m] {ai u} \u2212max j\u2208[n] {bj u}, (1)", "startOffset": 74, "endOffset": 88}, {"referenceID": 27, "context": "In other words, it is a convex optimization problem with several efficient solvers (Tsochantaridis et al., 2004; Joachims et al., 2009; Shalev-Shwartz et al., 2009), including the BCFW algorithm (Lacoste-Julien et al.", "startOffset": 83, "endOffset": 164}, {"referenceID": 10, "context": "In other words, it is a convex optimization problem with several efficient solvers (Tsochantaridis et al., 2004; Joachims et al., 2009; Shalev-Shwartz et al., 2009), including the BCFW algorithm (Lacoste-Julien et al.", "startOffset": 83, "endOffset": 164}, {"referenceID": 23, "context": "In other words, it is a convex optimization problem with several efficient solvers (Tsochantaridis et al., 2004; Joachims et al., 2009; Shalev-Shwartz et al., 2009), including the BCFW algorithm (Lacoste-Julien et al.", "startOffset": 83, "endOffset": 164}, {"referenceID": 13, "context": ", 2009), including the BCFW algorithm (Lacoste-Julien et al., 2013).", "startOffset": 38, "endOffset": 67}, {"referenceID": 17, "context": "This follows from the fact that the upper bound of the empirical risk is a PL function, and can therefore be expressed as the difference of two convex PL functions (Melzer, 1986).", "startOffset": 164, "endOffset": 178}, {"referenceID": 13, "context": "In order to solve the convex program (7), which corresponds to a structured SVM problem, we make use of the powerful BCFW algorithm (Lacoste-Julien et al., 2013) that solves its dual via conditional gradients.", "startOffset": 132, "endOffset": 161}, {"referenceID": 3, "context": "This is once again in stark contrast to backpropagation, where the estimation of the step-size is still an active area of research (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015).", "startOffset": 131, "endOffset": 184}, {"referenceID": 30, "context": "This is once again in stark contrast to backpropagation, where the estimation of the step-size is still an active area of research (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015).", "startOffset": 131, "endOffset": 184}, {"referenceID": 3, "context": "This is once again in stark contrast to backpropagation, where the estimation of the step-size is still an active area of research (Duchi et al., 2011; Zeiler, 2012; Kingma & Ba, 2015). As shown by Lacoste-Julien et al. (2013), given the current estimate of the parameters W , the conditional gradient of the dual of program (7) with respect to a training sample (xi, yi) can be obtained by solving the following problem: (\u0177i, \u0125i) = argmax \u0233\u2208Y,h\u2208H (W )\u03a8(xi, \u0233,h) + \u2206(\u0233, yi).", "startOffset": 132, "endOffset": 227}, {"referenceID": 13, "context": "We refer the interested reader to (Lacoste-Julien et al., 2013) for further details.", "startOffset": 34, "endOffset": 63}, {"referenceID": 2, "context": "All experiments are conducted on a GPU (Nvidia Titan X) and use Theano (Bergstra et al., 2010; Bastien et al., 2012).", "startOffset": 71, "endOffset": 116}, {"referenceID": 12, "context": "Data sets & Architectures The CIFAR-10/100 data sets are comprised of 60,000 RGB natural images of size 32\u00d7 32 with 10/100 classes (Krizhevsky, 2009)).", "startOffset": 131, "endOffset": 149}, {"referenceID": 27, "context": "It is worth noting that other approaches for solving structured SVM problems, such as cuttingplane algorithms (Tsochantaridis et al., 2004; Joachims et al., 2009) and stochastic subgradient descent (Shalev-Shwartz et al.", "startOffset": 110, "endOffset": 162}, {"referenceID": 10, "context": "It is worth noting that other approaches for solving structured SVM problems, such as cuttingplane algorithms (Tsochantaridis et al., 2004; Joachims et al., 2009) and stochastic subgradient descent (Shalev-Shwartz et al.", "startOffset": 110, "endOffset": 162}, {"referenceID": 23, "context": ", 2009) and stochastic subgradient descent (Shalev-Shwartz et al., 2009), also rely on the efficiency of estimating the conditional gradient of the dual.", "startOffset": 43, "endOffset": 72}, {"referenceID": 22, "context": "This includes multi-plane variants of BCFW (Shah et al., 2015; Osokin et al., 2016), as well as generalizations of Frank-Wolfe such as partial linearization (Mohapatra et al.", "startOffset": 43, "endOffset": 83}, {"referenceID": 20, "context": "This includes multi-plane variants of BCFW (Shah et al., 2015; Osokin et al., 2016), as well as generalizations of Frank-Wolfe such as partial linearization (Mohapatra et al.", "startOffset": 43, "endOffset": 83}, {"referenceID": 18, "context": ", 2016), as well as generalizations of Frank-Wolfe such as partial linearization (Mohapatra et al., 2016).", "startOffset": 81, "endOffset": 105}], "year": 2017, "abstractText": "We present a novel layerwise optimization algorithm for the learning objective of Piecewise-Linear Convolutional Neural Networks (PL-CNNs), a large class of convolutional neural networks. Specifically, PL-CNNs employ piecewise linear non-linearities such as the commonly used ReLU and max-pool, and an SVM classifier as the final layer. The key observation of our approach is that the problem corresponding to the parameter estimation of a layer can be formulated as a difference-of-convex (DC) program, which happens to be a latent structured SVM. We optimize the DC program using the concave-convex procedure, which requires us to iteratively solve a structured SVM problem. This allows to design an optimization algorithm with an optimal learning rate that does not require any tuning. Using the MNIST, CIFAR and ImageNet data sets, we show that our approach always improves over the state of the art variants of backpropagation and scales to large data and large network settings.", "creator": "LaTeX with hyperref package"}}}