{"id": "1611.03398", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2016", "title": "XCSP3: An Integrated Format for Benchmarking Combinatorial Constrained Problems", "abstract": "unfortunately we propose a major geometric revision of the format xcsp 2. rfc 1, called xcsp3, to build thoroughly integrated unicode representations of locally combinatorial constrained geometric problems. this new derived format module is effectively able to inherently deal with mono / multi dimensional optimization, namely many attribute types combinations of variables, transaction cost functions, image reification, views, annotations, mathematical variable quantification, semantic distributed, probabilistic and qualitative reasoning. evidently the emerging new transformation format is better made pretty compact, highly readable, and could rather be easy to parse. interestingly, it captures defining the structure metadata of the problem models, through communicating the possibilities of declaring small arrays of variables, and identifying hidden syntactic connections and semantic groups of constraints. the number estimation of specific constraints is traditionally kept under control simultaneously by introducing a limited complexity set mixture of internally basic constraint forms, narrowing and starts producing almost unlimited automatically some of exactly their large variations through lifting, restriction, rule sliding, automatic logical factor combination and numerical relaxation mechanisms. even as simply a result, xcsp3 globally encompasses practically all constraints globally that can be found in major database constraint solvers especially developed centrally by the cp software community. a libre website, unlike which increasingly is increasingly developed conjointly contiguous with the format, contains many business models indexed and allows series of instances. thereby the document user can make sophisticated queries for selecting problem instances from very least precise criteria. the common objective element of xcsp3 is to ease the effort required to structurally test and compare different task algorithms \u00bb by quickly providing a \" common test - maker bed version of combinatorial complexity constrained graph instances.", "histories": [["v1", "Thu, 10 Nov 2016 17:00:56 GMT  (494kb,D)", "http://arxiv.org/abs/1611.03398v1", "230 pages"]], "COMMENTS": "230 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["frederic boussemart", "christophe lecoutre", "c\\'edric piette"], "accepted": false, "id": "1611.03398"}, "pdf": {"name": "1611.03398.pdf", "metadata": {"source": "CRF", "title": "XCSP3 An Integrated Format for Benchmarking Combinatorial Constrained Problems", "authors": ["Fr\u00e9d\u00e9ric Boussemart", "Christophe Lecoutre", "C\u00e9dric Piette"], "emails": ["boussemart@cril.fr", "lecoutre@cril.fr", "piette@cril.fr"], "sections": [{"heading": null, "text": "XCSP3\nAn Integrated Format for Benchmarking\nCombinatorial Constrained Problems\nFre\u0301de\u0301ric Boussemart Christophe Lecoutre Ce\u0301dric Piette\nCRIL- CNRS, UMR 8188, University of Artois Rue de l\u2019universite\u0301, SP 16, 62307 Lens, France\nwww.xcsp.org\nXCSP3 Specifications \u2013 Version 3.0.4 August 20, 2016\nar X\niv :1\n61 1.\n03 39\n8v 1\n[ cs\n.A I]\n1 0\nN ov\n2 01\n6\nPlease, do not hesitate to provide us with a feedback. Send an email to: {boussemart,lecoutre,piette}@cril.fr\nXCSP3 website: www.xcsp.org\nAbstract\nWe propose a major revision of the format XCSP 2.1, called XCSP3, to build integrated representations of combinatorial constrained problems. This new format is able to deal with mono/multi optimization, many types of variables, cost functions, reification, views, annotations, variable quantification, distributed, probabilistic and qualitative reasoning. The new format is made compact, highly readable, and rather easy to parse. Interestingly, it captures the structure of the problem models, through the possibilities of declaring arrays of variables, and identifying syntactic and semantic groups of constraints. The number of constraints is kept under control by introducing a limited set of basic constraint forms, and producing almost automatically some of their variations through lifting, restriction, sliding, logical combination and relaxation mechanisms. As a result, XCSP3 encompasses practically all constraints that can be found in major constraint solvers developed by the CP community. A website, which is developed conjointly with the format, contains many models and series of instances. The user can make sophisticated queries for selecting instances from very precise criteria. The objective of XCSP3 is to ease the effort required to test and compare different algorithms by providing a common test-bed of combinatorial constrained instances.\nContents"}, {"heading": "1 Introduction 7", "text": "1.1 Features of XCSP3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 1.2 Skeleton of XCSP3 Problem Instances . . . . . . . . . . . . . . . . . . . . . . . 10 1.3 XML versus JSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 1.4 XCSP3-core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 1.5 Important Notes about Syntax and Semantics . . . . . . . . . . . . . . . . . . . 17 1.6 Notes (Short Comments) and Classes . . . . . . . . . . . . . . . . . . . . . . . . 19 1.7 Structure of the Document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\nI Variables and Objectives 21"}, {"heading": "2 Variables 23", "text": "2.1 0/1 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 2.2 Integer Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 2.3 Symbolic Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 2.4 Real Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 2.5 Set Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 2.6 Graph Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 2.7 Stochastic Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 2.8 Qualitative Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 2.9 Arrays of Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.9.1 Using Compact Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 2.9.2 Dealing With Mixed Domains . . . . . . . . . . . . . . . . . . . . . . . . 34\n2.10 Empty Domains and Useless Variables . . . . . . . . . . . . . . . . . . . . . . . 35 2.11 Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36"}, {"heading": "3 Objectives 39", "text": "3.1 Objectives in Functional Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 3.2 Objectives in Specialized Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 3.3 Multi-objective Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41"}, {"heading": "II Constraints 43", "text": ""}, {"heading": "4 Constraints over Simple Discrete Variables 45", "text": "1\n4.1 Constraints over Integer Variables . . . . . . . . . . . . . . . . . . . . . . . . . 47 4.1.1 Generic Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n4.1.1.1 Constraint intension . . . . . . . . . . . . . . . . . . . . . . . 47 4.1.1.2 Constraint extension . . . . . . . . . . . . . . . . . . . . . . . 49\n4.1.2 Constraints defined from Languages . . . . . . . . . . . . . . . . . . . . 52 4.1.2.1 Constraint regular . . . . . . . . . . . . . . . . . . . . . . . . 52 4.1.2.2 Constraint grammar . . . . . . . . . . . . . . . . . . . . . . . . 53 4.1.2.3 Constraint mdd . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 4.1.3 Comparison-based Constraints . . . . . . . . . . . . . . . . . . . . . . . 55 4.1.3.1 Constraint allDifferent . . . . . . . . . . . . . . . . . . . . . 55 4.1.3.2 Constraint allEqual . . . . . . . . . . . . . . . . . . . . . . . 56 4.1.3.3 Constraint allDistant . . . . . . . . . . . . . . . . . . . . . . 57 4.1.3.4 Constraint ordered . . . . . . . . . . . . . . . . . . . . . . . . 58 4.1.4 Counting and Summing Constraints . . . . . . . . . . . . . . . . . . . . 59 4.1.4.1 Constraint sum . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 4.1.4.2 Constraint count . . . . . . . . . . . . . . . . . . . . . . . . . 60 4.1.4.3 Constraint nValues . . . . . . . . . . . . . . . . . . . . . . . . 61 4.1.4.4 Constraint cardinality . . . . . . . . . . . . . . . . . . . . . 62 4.1.4.5 Constraint balance . . . . . . . . . . . . . . . . . . . . . . . . 63 4.1.4.6 Constraint spread . . . . . . . . . . . . . . . . . . . . . . . . . 64 4.1.4.7 Constraint deviation . . . . . . . . . . . . . . . . . . . . . . . 65 4.1.4.8 Constraint sumCosts . . . . . . . . . . . . . . . . . . . . . . . 65 4.1.5 Connection Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 4.1.5.1 Constraint maximum . . . . . . . . . . . . . . . . . . . . . . . . 69 4.1.5.2 Constraint minimum . . . . . . . . . . . . . . . . . . . . . . . . 70 4.1.5.3 Constraint element . . . . . . . . . . . . . . . . . . . . . . . . 71 4.1.5.4 Constraint channel . . . . . . . . . . . . . . . . . . . . . . . . 72 4.1.5.5 Constraint permutation . . . . . . . . . . . . . . . . . . . . . 74 4.1.5.6 Constraint precedence . . . . . . . . . . . . . . . . . . . . . . 74 4.1.6 Packing and Scheduling Constraints . . . . . . . . . . . . . . . . . . . . 75 4.1.6.1 Constraint stretch . . . . . . . . . . . . . . . . . . . . . . . . 75 4.1.6.2 Constraint noOverlap . . . . . . . . . . . . . . . . . . . . . . . 76 4.1.6.3 Constraint cumulative . . . . . . . . . . . . . . . . . . . . . . 78 4.1.6.4 Constraint binPacking . . . . . . . . . . . . . . . . . . . . . . 79 4.1.6.5 Constraint knapsack . . . . . . . . . . . . . . . . . . . . . . . 81 4.1.6.6 Constraint networkFlow . . . . . . . . . . . . . . . . . . . . . 81 4.1.7 Constraints on Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 4.1.7.1 Constraint circuit . . . . . . . . . . . . . . . . . . . . . . . . 82 4.1.7.2 Constraint nCircuits . . . . . . . . . . . . . . . . . . . . . . . 83 4.1.7.3 Constraint path . . . . . . . . . . . . . . . . . . . . . . . . . . 84 4.1.7.4 Constraint nPaths . . . . . . . . . . . . . . . . . . . . . . . . . 85 4.1.7.5 Constraint tree . . . . . . . . . . . . . . . . . . . . . . . . . . 86 4.1.7.6 Constraint nTrees . . . . . . . . . . . . . . . . . . . . . . . . . 86 4.1.8 Elementary Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 4.1.8.1 Constraint clause . . . . . . . . . . . . . . . . . . . . . . . . . 87 4.1.8.2 Constraint instantiation . . . . . . . . . . . . . . . . . . . . 88\n4.2 Constraints over Symbolic Variables . . . . . . . . . . . . . . . . . . . . . . . . 89\n2"}, {"heading": "5 Constraints over Complex Discrete Variables 90", "text": "5.1 Constraints over Set Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n5.1.1 Generic Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 5.1.1.1 Constraint intension . . . . . . . . . . . . . . . . . . . . . . . 90 5.1.2 Comparison-based Constraints . . . . . . . . . . . . . . . . . . . . . . . 92 5.1.2.1 Constraint allDifferent . . . . . . . . . . . . . . . . . . . . . 92 5.1.2.2 Constraint allEqual . . . . . . . . . . . . . . . . . . . . . . . 93 5.1.2.3 Constraint allIntersecting . . . . . . . . . . . . . . . . . . . 93 5.1.2.4 Constraint ordered . . . . . . . . . . . . . . . . . . . . . . . . 95 5.1.3 Counting Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 5.1.3.1 Constraint sum . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 5.1.3.2 Constraint count . . . . . . . . . . . . . . . . . . . . . . . . . 97 5.1.3.3 Constraint range . . . . . . . . . . . . . . . . . . . . . . . . . 98 5.1.3.4 Constraint roots . . . . . . . . . . . . . . . . . . . . . . . . . 98 5.1.4 Connection Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 5.1.4.1 Constraint element . . . . . . . . . . . . . . . . . . . . . . . . 99 5.1.4.2 Constraint channel . . . . . . . . . . . . . . . . . . . . . . . . 100 5.1.4.3 Constraint partition . . . . . . . . . . . . . . . . . . . . . . . 101 5.1.4.4 Constraint precedence . . . . . . . . . . . . . . . . . . . . . . 101\n5.2 Constraints over Graph Variables . . . . . . . . . . . . . . . . . . . . . . . . . . 102 5.2.1 Constraint circuit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 5.2.2 Constraint nCircuits . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 5.2.3 Constraint path . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103 5.2.4 Constraint nPaths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 5.2.5 Constraint arbo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 5.2.6 Constraint nArbos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 5.2.7 Constraint nCliques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105"}, {"heading": "6 Constraints over Continuous Variables 106", "text": "6.1 Constraints over Real Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\n6.1.1 Constraint intension . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 6.1.2 Constraint sum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\n6.2 Constraints over Qualitative Variables . . . . . . . . . . . . . . . . . . . . . . . 108 6.2.1 Constraint interval . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 6.2.2 Constraint point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 6.2.3 Constraint rcc8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110 6.2.4 Constraint dbd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110"}, {"heading": "III Advanced Forms of Constraints 112", "text": ""}, {"heading": "7 Lifted and Restricted Forms of Constraints 114", "text": "7.1 Constraints lifted to Lists, Sets and Multisets . . . . . . . . . . . . . . . . . . . 114\n7.1.1 Lifted Constraints allDifferent . . . . . . . . . . . . . . . . . . . . . . 115 7.1.1.1 On lists (tuples) . . . . . . . . . . . . . . . . . . . . . . . . . . 115 7.1.1.2 On sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116 7.1.1.3 On multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 7.1.2 Lifted Constraints allEqual . . . . . . . . . . . . . . . . . . . . . . . . 118\n3\n7.1.2.1 On lists (tuples) . . . . . . . . . . . . . . . . . . . . . . . . . . 118 7.1.2.2 On sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 7.1.2.3 On multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\n7.1.3 Lifted Constraints allDistant . . . . . . . . . . . . . . . . . . . . . . . 119 7.1.3.1 On lists (tuples) . . . . . . . . . . . . . . . . . . . . . . . . . . 120 7.1.3.2 On sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 7.1.3.3 On multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 7.1.4 Lifted Constraints ordered (lex on lists) . . . . . . . . . . . . . . . . . 122 7.1.4.1 On lists (tuples) . . . . . . . . . . . . . . . . . . . . . . . . . . 122 7.1.4.2 On sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 7.1.4.3 On multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 7.1.5 Lifted Constraints allIncomparable . . . . . . . . . . . . . . . . . . . . 124 7.1.5.1 On lists (tuples) . . . . . . . . . . . . . . . . . . . . . . . . . . 124 7.1.5.2 On sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 7.1.5.3 On multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125 7.1.6 Lifted Constraints nValues . . . . . . . . . . . . . . . . . . . . . . . . . 125 7.1.6.1 On lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125 7.1.6.2 On sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126 7.1.6.3 On multisets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n7.2 Constraints lifted to Matrices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127 7.2.1 Constraint allDifferent-matrix . . . . . . . . . . . . . . . . . . . . . . 128 7.2.2 Constraint ordered-matrix (lex2) . . . . . . . . . . . . . . . . . . . . . 128 7.2.3 Constraint element-matrix . . . . . . . . . . . . . . . . . . . . . . . . . 129 7.2.4 Constraint cardinality-matrix . . . . . . . . . . . . . . . . . . . . . . 130 7.3 Restricted Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131 7.3.1 Constraint allDifferent.symmetric . . . . . . . . . . . . . . . . . . . 132 7.3.2 Constraint allDifferent.symmetric+irreflexive . . . . . . . . . . . 132 7.3.3 Constraint allDifferent.convex . . . . . . . . . . . . . . . . . . . . . 133 7.3.4 Constraint nValues.increasing . . . . . . . . . . . . . . . . . . . . . . 133 7.3.5 Constraint cardinality.increasing . . . . . . . . . . . . . . . . . . . 134 7.3.6 Constraint permutation.increasing (sort) . . . . . . . . . . . . . . . 134 7.3.7 Constraint sumCosts.allDifferent . . . . . . . . . . . . . . . . . . . . 135"}, {"heading": "8 Meta-Constraints 136", "text": "8.1 Meta-Constraint slide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 8.2 Some Classical Uses of slide . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n8.2.1 Constraint sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138 8.2.2 Constraint slidingSum . . . . . . . . . . . . . . . . . . . . . . . . . . . 139 8.2.3 Constraints change and smooth . . . . . . . . . . . . . . . . . . . . . . . 140\n8.3 Meta-Constraint seqbin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 8.4 Meta-Constraint and . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141 8.5 Some Classical Uses of and . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142\n8.5.1 Constraint gen-sequence . . . . . . . . . . . . . . . . . . . . . . . . . . 142 8.5.2 Constraint gsc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142 8.5.3 Constraint cardinalityWithCosts . . . . . . . . . . . . . . . . . . . . . 143 8.5.4 Constraints costRegular and multicostRegular . . . . . . . . . . . . 143\n8.6 Meta-Constraint or . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144 8.7 Meta-Constraint not . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n4"}, {"heading": "9 Soft Constraints 146", "text": "9.1 Relaxed Constraints and Cost Functions . . . . . . . . . . . . . . . . . . . . . . 147 9.2 Simple Relaxation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147 9.3 Complex Relaxation of Generic Constraints . . . . . . . . . . . . . . . . . . . . 149\n9.3.1 Constraint soft-intension . . . . . . . . . . . . . . . . . . . . . . . . . 149 9.3.2 Constraint soft-extension . . . . . . . . . . . . . . . . . . . . . . . . . 151\n9.4 Complex Relaxation of Global Constraints . . . . . . . . . . . . . . . . . . . . . 153 9.4.1 Constraint soft-and (Cardinality Operator) . . . . . . . . . . . . . . . . 153 9.4.2 Constraint soft-slide (cardPath) . . . . . . . . . . . . . . . . . . . . . 154 9.4.3 Constraint soft-allDifferent . . . . . . . . . . . . . . . . . . . . . . . 156 9.4.4 Constraint soft-cardinality . . . . . . . . . . . . . . . . . . . . . . . . 156 9.4.5 Constraint soft-regular . . . . . . . . . . . . . . . . . . . . . . . . . . 157 9.4.6 Constraint soft-permutation (same) . . . . . . . . . . . . . . . . . . . 157 9.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157"}, {"heading": "IV Groups, Frameworks and Annotations 159", "text": ""}, {"heading": "10 Groups, Blocks, Reification, Views and Aliases 160", "text": "10.1 Constraint Templates and Groups . . . . . . . . . . . . . . . . . . . . . . . . . 160 10.2 Blocks and Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 10.3 Reification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165 10.4 Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167 10.5 Aliases (attribute as) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168"}, {"heading": "11 Frameworks 170", "text": "11.1 Dealing with Satisfaction (CSP) . . . . . . . . . . . . . . . . . . . . . . . . . . 170 11.2 Dealing with Optimization (COP) . . . . . . . . . . . . . . . . . . . . . . . . . 171 11.3 Dealing with Preferences through Soft Constraints . . . . . . . . . . . . . . . . 172\n11.3.1 WCSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 11.3.2 FCSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174\n11.4 Dealing with Quantified Variables . . . . . . . . . . . . . . . . . . . . . . . . . . 177 11.4.1 QCSP(+) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177 11.4.2 QCOP(+) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 11.5 Stochastic Constraint Reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . 182 11.5.1 SCSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182 11.5.2 SCOP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183 11.6 Qualitative Spatial Temporal Reasoning . . . . . . . . . . . . . . . . . . . . . . 183 11.6.1 Interval Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184 11.6.2 Point Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 11.6.3 Region Connection Calculus . . . . . . . . . . . . . . . . . . . . . . . . . 186 11.6.4 TCSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187 11.7 Continuous Constraint Solving . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 11.7.1 NCSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 11.7.2 NCOP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 11.8 Distributed Constraint Reasoning . . . . . . . . . . . . . . . . . . . . . . . . . . 190 11.8.1 DisCSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190 11.8.2 DisWCSP (DCOP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193\n5"}, {"heading": "12 Annotations 194", "text": "12.1 Annotations about Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195 12.2 Annotations about Constraints . . . . . . . . . . . . . . . . . . . . . . . . . . . 197 12.3 Annotations about Preprocessing and Search . . . . . . . . . . . . . . . . . . . 198\nAppendices 201"}, {"heading": "A KeyWords 202", "text": ""}, {"heading": "B Syntax 203", "text": "C Index of Constraints 210\nD XML and JSON 214\nE Versioning 219\n6\n1 Introduction\nThe Constraint Programming (CP) community suffers from the lack of a standard format for representing various forms of combinatorial problems subject to constraints and optimization. Here, we refer to the possibility of generating and exchanging files containing precise descriptions of problem instances, so that fair comparisons of problem solving approaches can be made in good conditions, and experiments can be reproduced easily. In this paper, we present the specifications for a major revision/extension of the basic format XCSP 2.1, which was introduced in 2009. This new format, XCSP3, looks like a light language that allows us to get integrated representations of combinatorial constrained problems, by enumerating variables, constraints and objectives in a very simple, structured and unambiguous way. XCSP3 can be seen as an intermediate format because it can preserve the structure of problem models. However, the goal we pursue must not be confused with that of a powerful modeling language such as those dedicated to mathematical programming - e.g. AMPL (http://www.ampl.com) and GAMS (http://www.gams.com) - or dedicated to constraint programming1 - e.g. OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].\nAs a solid basis for XCSP3, we employ the Extensible Markup Language (XML) [134], which is a flexible text format playing an important role in the exchange of a wide variety of data on the Web. At this point, it is important to note that XML is only here to support the overall architecture of our language, facilitating the issue of parsing files through common tools such as DOM and SAX (and permitting possible transformations using XSLT). Within the global architecture, there are various XML elements that are not totally described in XML terms (for example, each integer is not put within its own element). This choice we deliberately made allows compact, readable and easily modifiable problem representations, without burdening too much on parser developers because internal data that need to be analyzed are quite basic. In other words, XCSP3 aims at being a good compromise between simplicity, readability and structure.\n1Note that the specification language Z (http://vl.users.org) has also been used to build nice (high-level) problem models [117]\n7\n1.1 Features of XCSP3\nActually, here are the main advantages of XCSP3:\n\u2022 Generality. XCSP3 allows us to represent many forms of combinatorial constrained problems since it can deal with:\n\u2013 constraint satisfaction: CSP (Constraint Satisfaction Problem)\n\u2013 mono and multi-objective optimization: COP (Constrained Optimization Problem)\n\u2013 preferences through soft constraints: WCSP (Weighted Constraint Satisfaction Problem) and FCSP (Fuzzy Constraint Satisfaction Problem)\n\u2013 variable quantification: QCSP(+) (Quantified Constraint Satisfaction Problem) and QCOP(+) (Quantified Constraint Optimization Problem)\n\u2013 probabilistic constraint reasoning: SCSP (Stochastic Constraint Satisfaction Problem) and SCOP (Stochastic Constraint Optimization Problem)\n\u2013 qualitative reasoning: QSTR (Qualitative Spatial and Temporal Reasoning) and TCSP (Temporal Constraint Satisfaction Problem)\n\u2013 continuous constraint solving: NCSP (Numerical Constraint Satisfaction Problem) and NCOP (Numerical Constraint Optimization Problem)\n\u2013 distributed constraint reasoning: DisCSP (Distributed Constraint Satisfaction Problem) and DCOP (Distributed Constraint Optimization Problem)\n\u2022 Completeness. A very large range of constraints is available, encompassing practically (i.e., to a very large extent) all constraints that can be found in major constraint solvers such as, e.g., Choco and Gecode.\n\u2022 Understanding. We paid attention to control the number of concepts and basic constraint forms, advisedly exploiting automatic variations of these forms through lifting, restriction, sliding, combination and relaxation mechanisms, so as to facilitate global understanding.\n\u2022 Readability. The new format is more compact, and less redundant, than XCSP 2.1, making it very easy to read and understand, especially as variables and constraints can be handled under the form of arrays and groups. Also, anyone can modify very easily an instance by hand. We do believe that a rookie in CP can manage small instances in XCSP3.\n\u2022 Flexibility. It will be very easy to extend the format, if necessary, in the future, for example by adding new kind of global constraints, or by adding a few XML attributes in order to handle new concepts.\n\u2022 Ease of Parsing. Thanks to the XML architecture of the format, basically, it is easy to parse instance files at a coarse-grain level. Besides, parsers written in Java and C++ are available.\n\u2022 Dedicated Website. A website, companion of XCSP3, is available, with many downloadable models/series/instances. This website allows the user to make (possibly sophisticated) queries in order to select and download the instances that he finds relevant.\nBefore starting the description of the new format, let us briefly introduce what are the main novelties of XCSP3 with respect to XCSP 2.1:\n8\n\u2022 Optimization. XCSP3 can manage both mono-objective and multi-objective optimization.\n\u2022 New Types of Variables. It is possible to define 0/1, integer, symbolic, real, stochastic, set, qualitative, and graph variables, in XCSP3.\n\u2022 Lifted and Restricted forms of Constraints. It is natural to extend basic forms of constraints over lists (tuples), sets and multi-sets. It is simple to build restricted forms of constraints by considering some properties of lists.\n\u2022 Meta-constraints. It is possible to exploit sliding and logical mechanisms over variables and constraints.\n\u2022 Soft constraints. Cost-based soft constraints can be defined easily. \u2022 Reification. Half and full reification is easy, and made possible by letting the user\nassociate a 0/1 variable with any constraint of the problem through a dedicated XML attribute.\n\u2022 Views. In XCSP3, it is possible to post constraints with arguments that are not limited to simple variables or constants, thus, avoiding in some situations the necessity of introducing auxiliary variables and constraints, and permitting solvers that can handle variable views to do it.\n\u2022 Structure. It is possible to post variables under the form of arrays (of any dimension) and to post constraints in (semantic or syntactic) groups, thereby, partly preserving the structure of the models. XCSP3 is an intermediate format.\n\u2022 No Redundancy. In XCSP3, redundancy is very limited, making instance representations more compact and less error-prone.\n\u2022 Compactness. Posting variables and constraints in arrays/groups, while avoiding redundancy, makes instances in XCSP3 more compact than similar instances in XCSP 2.1.\n\u2022 Annotations. It is possible to add annotations to the instances, for indicating search guidance and filtering preferences.\nAs you may imagine from this rapid description, XCSP3 is a major rethinking of XCSP 2.1. Because we wanted to fix some problems inherent to the way XCSP 2.1 was developed, we have chosen not to make XCSP3 backward-compatible. However, do not feel concerned too much about this issue because all series in XCSP 2.1 are translated into XCSP3, and as said above, parsers are available.\nIt is very important to understand that XCSP3 is not a modeling language: XCSP3 aims at being a rich format, simple to be used by both the human and the machine (parser/solver). We show this graphically in Figure 1.1. XCSP3 can be considered as an intermediate format. It is not as flat as FlatZinc and XCSP 2.1 can be, since XCSP3 allows us to specify arrays of variables and groups of constraints.\nTo summarize, the representation of constrained problems can be handled at three different levels of abstraction:\n\u2022 high level of abstraction. At this level, modeling languages are used. They permit to use control structures (such as loops) and separate models from data. It means that for a given problem, you typically write a model which is a kind of problem abstraction parameterized by some formal data. For a specific instance, you need to furnish the\n9\neffective data. In practice, you have a file for the model, and for each instance you have an additional file containing the data.\n\u2022 intermediate level. At this level, there is no separation between the model and the data, although the structure remains visible. XCSP3 is the only intermediate format proposed in the literature. For each instance, you only have a file.\n\u2022 low level. At this level, we find flat formats. Each component (variable or constraint) of a problem instance is represented independently. As a consequence, the initial structure of the problem is difficult to find.\nIn the following sections of this chapter, we provide some basic information concerning the syntax and the semantics of XCSP3, which will be useful for reading the rest of the document. More precisely, we present the skeleton of typical XCSP3 instances, and introduce a few important notes related to XCSP3 syntax and semantics.\n1.2 Skeleton of XCSP3 Problem Instances\nTo begin with, below, you will find the syntactic form of the skeleton of a typical XCSP3 problem instance, i.e., the skeleton used by most2 of the frameworks recognized by XCSP3. In our syntax, as shown in Appendix B, Page 203, we combine XML and BNF. XML is used for describing the main elements and attributes of XCSP3, whereas BNF is typically used for describing the textual contents of XCSP3 elements and attributes, with in particular |, [ ], ( ), * and + respectively standing for alternation, optional character, grouping and repetitions (0 or more, and 1 or more). Note that <elt.../> denotes an XML element of name elt whose description is given later in the document (this is the meaning of ...). Strings written in dark blue italic form refer to BNF non-terminals defined in Appendix B. For example, frameworkType corresponds to a token chosen among CSP, COP, WCSP, . . . Also, for the sake of simplicity, we write <constraint.../> and <metaConstraint.../> for respectively denoting any constraint element such as e.g., <extension.../> or <allDifferent.../>, and any metaconstraint such as e.g., <slide.../> or <not.../>.\n2Syntactic details for various frameworks are given in Chapter 11.\n10\nSyntax 1\n<instance format=\"XCSP3\" type=\"frameworkType\">\n<variables>\n( <var.../>\n| <array.../>\n)+\n</variables> <constraints>\n( <constraint.../>\n| <metaConstraint.../> | <group.../> | <block.../>\n)*\n</constraints> [<objectives [combination=\"combinationType\"]>\n( <minimize.../>\n| <maximize.../>\n)+\n</objectives>]\n[<annotations.../>]\n</instance>\nAs you can observe, a typical instance is composed of variables, constraints, and possibly objectives (and annotations). Variables are declared stand-alone (element <var.../>) or under the form of arrays (element <array.../>). Constraints can be elementary (element <constraint.../> or more complex (element <metaConstraint.../>). Constraints can also be posted in groups and/or declared in blocks; <group.../> and <block.../> correspond to structural mechanisms. Finally, any objective boils down to minimizing or maximizing a certain function, and is represented by an element <minimize.../> or <maximize.../>.\nRemark 1 It is important to note that <objectives> and <annotations> are optional.\nFor a first illustration of XCSP3, let us consider the small constraint network depicted (by its compatibility graph) in Figure 1.2. We have here three symbolic variables, x, y, z of domain {a, b} and three binary constraints, one per pair of variables. An edge in this graph means a compatibility between two values of two different variables. In XCSP3, we obtain:\nExample 1\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<var id=\"x\" type=\"symbolic\"> a b </var > <var id=\"y\" type=\"symbolic\"> a b </var > <var id=\"z\" type=\"symbolic\"> a b </var >\n</variables > <constraints >\n<extension >\n<list > x y </list > <supports > (a,a)(b,b) </supports >\n</extension >\n11\nOf course, we shall give all details of this representation in the next chapters, but certainly you are comfortable to make the correspondence between the figure and the XCSP3 code. If you pay attention to the constraints, you can detect that two of them are similar. Indeed, the list of supports (compatible pairs) between x and y is the same as that between x and z. In XCSP3, it is possible to avoid such redundancy by using either the concept of constraint group or the attribute as. Also, because the three variables share the same type and the same domain, it is possible to avoid redundancy by using either the concept of variable array or the attribute as. We shall describe all these concepts in the next chapters.\nAs a second illustration, we consider the arithmetic optimization example introduced in the MiniZinc Tutorial: \u201cA banana cake which takes 250g of self-raising flour, 2 mashed bananas, 75g sugar and 100g of butter, and a chocolate cake which takes 200g of self-raising flour, 75g of cocoa, 150g sugar and 150g of butter. We can sell a chocolate cake for $4.50 and a banana cake for $4.00. And we have 4kg self-raising flour, 6 bananas, 2kg of sugar, 500g of butter and 500g of cocoa. The question is how many of each sort of cake should we bake for the fete to maximize the profit?\u201d Here is how this small problem can be encoded in XCSP3. Surely, you can analyze this piece of code (if you are told that le stands for \u201cless than or equal to\u201d). Notice that any XCSP3 element can be given the optional attribute note, which is used as a short comment.\n12\nExample 2\n<instance format=\"XCSP3\" type=\"COP\">\n<variables >\n<var id=\"b\" note=\"number of banana cakes\"> 0..100 </var > <var id=\"c\" note=\"number of chocolate cakes\"> 0..100 </var >\n</variables > <constraints >\n<intension > le(add(mul(250,b),mul(200,c)) ,4000) </intension > <intension > le(mul(2,b) ,6) </intension > <intension > le(add(mul(75,b),mul(150,c)) ,2000) </intension > <intension > le(add(mul(100,b),mul(150,c)) ,500) </intension > <intension > le(mul(75,c) ,500) </intension >\n</constraints > <objectives >\n<maximize > add(mul(b,400) ,mul(c,450)) </maximize >\n</objectives >\n</instance >\nAs we shall see, we can group together the constraints that share the same syntax (by introducing so-called constraint templates, which are abstract forms of constraints with parameters written %i) and we can describe specialized forms of objectives. An equivalent representation of the previous instance is:\nExample 3\n<instance format=\"XCSP3\" type=\"COP\">\n<variables >\n<var id=\"b\" note=\"number of banana cakes\"> 0..99 </var > <var id=\"c\" note=\"number of chocolate cakes\"> 0..99 </var >\n</variables > <constraints >\n<group >\n<intension > le(add(mul (%0 ,%1),mul (%2 ,%3)) ,%4) </intension > <args > 250 b 200 c 4000 </args > <args > 75 b 150 c 2000 </args > <args > 100 b 150 c 500 </args >\n</group > <group >\n<intension > le(mul (%0 ,%1) ,%2) </intension > <args > 2 b 6 </args > <args > 75 c 500 </args >\n</group >\n</constraints > <objectives >\n<maximize type=\"sum\">\n<list > b c </list > <coeffs > 400 450 </coeffs >\n</maximize > </objectives >\n</instance >\n13\nAlternatively, we could even use the global constraint sum, so as to obtain:\nExample 4\n<instance format=\"XCSP3\" type=\"COP\">\n<variables >\n<var id=\"b\" note=\"number of banana cakes\"> 0..99 </var > <var id=\"c\" note=\"number of chocolate cakes\"> 0..99 </var >\n</variables > <constraints >\n<sum note=\"using the 4000 grams of flour\">\n<list > b c </list > <coeffs > 250 200 </coeffs > <condition > (le ,4000) </condition >\n</sum > <sum note=\"using the 6 bananas\">\n<list > b </list > <coeffs > 2 </coeffs > <condition > (le ,6) </condition >\n</sum > <sum note=\"using the 2000 grams of sugar\">\n<list > b c </list > <coeffs > 75 150 </coeffs > <condition > (le ,2000) </condition >\n</sum > <sum note=\"using the 500 grams of butter\">\n<list > b c </list > <coeffs > 100 150 </coeffs > <condition > (le ,500) </condition >\n</sum > <sum note=\"using the 500 grams of cocoa\">\n<list > c </list > <coeffs > 75 </coeffs > <condition > (le ,500) </condition >\n</sum >\n</constraints >\n<objectives >\n<maximize type=\"sum\" note=\"receiving 400 and 450 cents for each\nbanana and chocolate cake , respectively\">\n<list > b c </list > <coeffs > 400 450 </coeffs >\n</maximize > </objectives >\n</instance >\nSince we have just mentioned MiniZinc, let us claim again that XCSP3 is not a modeling language. XCSP3 has no advanced control structures and no mechanism for separating model and data, but aims at being an intermediate format, simple to be used by both the human and the machine (parser/solver) while keeping the structure of the problems.\n14"}, {"heading": "1.3 XML versus JSON", "text": "For various reasons, some people prefer working with JSON, instead of XML. As shown in Appendix D, we can easily convert XCSP3 instances from XML to JSON by following a few rules. We illustrate this on the previous examples. Their JSON representations are shown below.\nExample 5\n{\n\"@format\":\"XCSP3\", \"@type\":\"CSP\", \"variables\":{\n\"var\":[{\n\"@id\":\"x\", \"domain\":\"a b\"\n}, {\n\"@id\":\"y\", \"domain\":\"a b\"\n}, {\n\"@id\":\"z\", \"domain\":\"a b\"\n}]\n}, \"constraints\":{\n\"extension\":[{\n\"list\":\"x y\", \"supports\":\"(a,a)(b,b)\"\n}, {\n\"list\":\"x z\", \"supports\":\"(a,a)(b,b)\"\n}, {\n\"list\":\"y z\", \"supports\":\"(a,b)(b,a)\"\n}]\n}\n}\nExample 6\n{\n\"@format\":\"XCSP3\", \"@type\":\"COP\", \"variables\":{\n\"var\":[{\n\"@id\":\"b\", \"domain\":\"0..100\"\n}, {\n\"@id\":\"c\", \"domain\":\"0..100\"\n}]\n15\n}, \"constraints\":{\n\"intension\":[ \"le(add(mul(250,b),mul(200,c)) ,4000)\", \"le(mul(2,b) ,6)\", \"le(add(mul(75,b),mul(150,c)) ,2000)\", \"le(add(mul(100,b),mul(150,c)) ,500)\", \"le(mul(75,c) ,500)\" ]\n}, \"objectives\":{\n\"maximize\":\"add(mul(b,400) ,mul(c,450))\"\n}\n}\nRemark 2 Although JSON looks attractive, there exist some limitations that make us preferring XML. These limitations are discussed in Appendix D.\n1.4 XCSP3-core\nXCSP3-core is a subset of XCSP3, with what can be considered as the main concepts of Constraint Programming (although, of course, this is quite subjective). The interest of XCSP3core is multiple:\n\u2022 focusing on the most popular constraints, \u2022 facilitating parsing process through dedicated parsers in Java and C++, using callback\nfunctions,\n\u2022 and defining a core format for future competitions of constraint solvers. XCSP3-core, targeted for CSP (Constraint Satisfaction Problem) and COP (Constrained Optimization problem), handles integer variables, mono-objective optimization, and 20 important constraints, described in the next chapters of this document:\n\u2022 intension \u2022 extension \u2022 regular \u2022 mdd \u2022 allDifferent \u2022 allEqual \u2022 ordered (lex) \u2022 sum (linear) \u2022 count (capturing atLeast, atMost, exactly, among) \u2022 nValues \u2022 cardinality \u2022 minimum\n16\n\u2022 maximum \u2022 element \u2022 channel \u2022 stretch \u2022 noOverlap (capturing disjunctive and diffn) \u2022 cumulative \u2022 instantiation \u2022 slide Importantly, as for full XCSP3, the structure of problems (models) can be preserved in\nXCSP3-core thanks to the following mechanisms:\n\u2022 arrays of variables \u2022 groups of constraints \u2022 blocks of constraints \u2022 the meta-constraint slide More information about XCSP3-core can be found at www.xcsp.org. Finally, note that the\nfollowing parsers are available:\n\u2022 a Java 8 parser for XCSP3-core (and also for full XCSP3) \u2022 a C++ parser for XCSP3-core"}, {"heading": "1.5 Important Notes about Syntax and Semantics", "text": "As already indicated, for the syntax, we invite the reader to consult Appendix B. In this section, we discuss some important points.\nConstraint Parameters and Numerical Conditions. One important decision concerns the way constraint parameters are defined. We have adopted the following rules:\n1. Most of the time, when defining a constraint, there is a main list of variables (not necessarily, its full scope) that must be handled. We have chosen to call3 it <list>. Identifying the main list of variables (using its type/form) permits in a very simple and natural way to derive variants of constraints, by using alternative forms such as as <set> and <mset> as shown in Chapter 7.\n2. Also, quite often, we need to introduce numerical conditions (comparisons) composed of an operator and a right-hand side operand k that is a value, a variable, an interval or a set; the left-hand side being indirectly defined by the constraint. The numerical condition is a kind of terminal operation to be applied after the constraint has \u201cperformed some computation\u201d. We propose to represent each numerical condition, i.e., each pair ( , k) by a single XCSP3 element <condition> containing both the operator and the right operand, between parentheses and with comma as separator.\n3. All other parameters are given by their natural names, as for example <transitions> for the constraint regular, or <index> for the constraint element.\n3Exceptions are for some scheduling constraints, where <origins> is more appropriate.\n17\nIt is important to note that each numerical condition ( , k) semantically stands for \u201c k\u201d, where:\n\u2022 either \u2208 {<,\u2264, >,\u2265,=, 6=} and k is a value or a variable; in XCSP3, we thus have to choose a symbol in {lt,le,gt,ge,eq,ne} for ,\n\u2022 or \u2208 {\u2208, /\u2208} and k is an integer interval of the form l..u, or an integer set of the form {a1, . . . , ap} with a1, . . . , ap integer values; in XCSP3, we thus have to choose a symbol in {in,notin} for .\nFor example, we may have ( , k) denoting \u201c> 10\u201d, \u201c 6= z\u201d or \u201c\u2208 1..5\u201d by respectively writing (gt,10), (ne,z) and (in,1..5). In XCSP3, we shall syntactically represent a numerical condition as follows:\nSyntax 2\n<condition> \"(\" operator \",\" operand \")\" </condition>\nwhere operator and operand are two BNF non-terminals defined in Appendix B.\nAttributes id, as and reifiedBy. In the next chapters, we shall present the syntax as precisely as possible. However, we shall make the following simplifications.\nAny XML element in XCSP3 can be given a value for the attribute id. This attribute is required for the elements <var.../> and <array.../>, but it is optional for all other elements. When presenting the syntax, we shall avoid to systematically write [id=\"identifier\"], each time we put an element for which id is optional. Note that, as for HTML5, each value of an attribute id must be document-wide unique.\nAny XML element in XCSP3 can be given a value for the attribute as. This attribute is always optional. Again, when presenting the syntax, we shall avoid to systematically write [as=\"identifier\"], each time we introduce an element. This form of aliasing is discussed in Chapter 10.\nAny constraint and meta-constraint can be given a value for one of the three following attributes reifiedBy, hreifiedFrom and hreifiedTo. These attributes are optional and mutually exclusive. When presenting the syntax in this document, we shall avoid to systematically write [reifiedBy=\"01Var\"|hreifiedFrom=\"01Var\"|hreifiedTo=\"01Var\"] each time we introduce a constraint or meta-constraint. Reification is discussed in Chapter 10.\nViews. For clarity, we always give the syntax of constraints in a rather usual restricted form. For example, we shall write (intVar wspace)* when a list of integer variables is naturally expected. However, most of time, it is possible to replace variables by more general expressions (for example, we could have add(x,10) where a variable is expected). This is acceptable (the XML schema that we provide for XCSP3 allows such forms) although we employ a more restrictive syntax in this document. Views are discussed in Chapter 10.\nWhitespaces. The tolerance with respect to whitespaces is the following:\n\u2022 leading and trailing whitespaces for values of XML attributes are not tolerated. For example, id=\" x\" is not valid.\n\u2022 leading and trailing whitespaces for textual contents of XML elements are tolerated, and not required. Although, for the sake of simplicity, we prefer writing:\n18\n<list> (intVar wspace)* </list>\ninstead of the heavier and more precise form:\n<list> [intVar (wspace intVar)*] </list>\nit must be clear that no trailing whitespace is actually required.\n\u2022 numerical conditions must not contain any whitespace. For example, (lt, 10) is not valid.\n\u2022 functional expressions must not contain any whitespace. For example, add(x,y ) is not valid.\n\u2022 whitespaces are tolerated between vectors (tuples) but not within vectors, where a vector (tuple) is a sequence of elements put between brackets with comma as separator. For example, <supports> (1,3)( 2,4) </supports> is not valid, whereas:\n<supports>\n(1,3) (2,4)\n</supports>\nis.\n\u2022 whitespaces are not tolerated at all when expressing decimals, rationals, integer intervals, real intervals, and probabilities. For example, 3. 14, 3 /2, 1 .. 10, [1.2, 5], and 2: 1/6 are clearly not valid expressions.\nSemantics. Concerning the semantics, here are a few important remarks:\n\u2022 when presenting the semantics, we distinguish between a variable x and its assigned value x (note the bold face on the symbol x).\n\u2022 Concerning the semantics of a numerical condition ( , k), and depending on the form of k (a value, a variable, an interval or a set), we shall indiscriminately use k to denote the value k, the value of the variable k, the interval l..u represented by k, or the set {a1, . . . , ap} represented by k."}, {"heading": "1.6 Notes (Short Comments) and Classes", "text": "In XCSP3, it is possible to associate a note (short comment) with any element. It suffices to use the attribute note whose value can be any string. Of course, for simplicity, when presenting the syntax, we shall never write [note=\"string\"], each time an element is introduced. Here is a small instance with two variables and one constraint, each one accompanied by a note.\nExample 7\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<var id=\"x\" note=\"x is a number between 1 and 10\"> 1..10 </var > <var id=\"y\" note=\"y denotes the square of x\"> 1..100 </var >\n</variables >\n19\n<constraints >\n<intension note=\"this constraint links x and y\">\neq(y,mul(x,x))\n</intension > </constraints >\n</instance >\nIn XCSP3, it is also possible to associate tags with any element. As in HTML, these tags are introduced by the attribute class, whose value is a sequence of identifiers, with whitespace used as a separator. Again, for simplicity, when presenting the syntax, we shall never write [class=\"(identifier wspace)+\"], each time an element is introduced. As we shall see in Section 10.2, these tags can be predefined or user-defined."}, {"heading": "1.7 Structure of the Document", "text": "The document is organized in four parts. In the first part, we show how to define different types of variables (Chapter 2) and objectives (Chapter 3). In the second part, we describe basic forms of constraints over simple discrete variables (Chapter 4), complex discrete variables (Chapter 5) and continuous variables (Chapter 6). Advanced (i.e., non-basic) forms of constraints are presented in the third part of the document: they correspond to lifted and restricted constraints (Chapter 7), meta-constraints (Chapter 8) and soft constraints (Chapter 9). Finally, in the fourth part, we introduce groups, blocks, reification, views and aliases (Chapter 10), frameworks (Chapter 11) and annotations (Chapter 12).\n20\nPart I\nVariables and Objectives\n21\nIn this part, we show how variables and objectives are represented in XCSP3.\n22\n2 Variables\nVariables are the basic components of combinatorial problems. In XCSP3, as shown in Figure 2.1, you can declare:\n23\n\u2022 discrete variables, that come in three categories:\n\u2013 simple discrete variables\n\u2217 integer variables, including 0/1 variables that can be used to represent Boolean variables too\n\u2217 symbolic variables \u2013 complex discrete variables\n\u2217 set variables \u2217 graph variables\n\u2013 stochastic discrete variables\n\u2022 continuous variables\n\u2013 real variables\n\u2013 qualitative variables\nYou can also declare: \u2022 k-dimensional arrays of variables, with k \u2265 1 Recall that stand-alone variables as well as arrays of variables must be put inside the element\n<variables>, as follows:\nSyntax 3\n<variables>\n(<var.../> | <array.../>)+\n</variables>\nAlso as already mentioned, for the syntax, we combine XML and BNF, with BNF nonterminals written in dark blue italic form (see Appendix B). The general syntax of an element <var> is:\nSyntax 4\n<var id=\"identifier\" [type=\"varType\"]>\n... // Domain description\n</var>\nA stand-alone variable can thus be declared by means of an element <var>, and its identification is given by the value of the required attribute id. In accordance with the value (\"integer\" by default) of the attribute type, this element contains the description of its domain, i.e., the values that can possibly be assigned to it.\nSometimes, however, an element <var> has no content at all. Actually, there are three such situations:\n\u2022 when a variable is qualitative, its domain is implicit, as we shall see in Section 2.8, \u2022 when a (non-qualitative) variable has an empty domain, as discussed in Section 2.10, \u2022 when the attribute as is present. For the last case, we have:\n24\nSyntax 5\n<var id=\"identifier\" [type=\"varType\"] as=\"identifier\" />\nThe value of as must correspond to the value of the attribute id of another element. When this attribute is present, the content of the element is exactly the same as the one that is referred to (as if we applied a copy and paste operation), as discussed in Section 10.5. From now on, for simplicity, we shall systematically omit the optional attribute as, although its role will be illustrated in the section about integer variables.\nThe general syntax of an element <array> is:\nSyntax 6\n<array id=\"identifier\" [type=\"varType\"] size=\"dimensions\" [startIndex=\"integer\"]>\n... // Domain description\n</array>\nThe chapter is organized as follows. From Section 2.1 to Section 2.8, we develop the syntax for the different types of stand-alone variables, namely, 0/1 variables, integer variables, symbolic variables, real variables, set variables, graph variables, stochastic variables and qualitative variables. Then, in Section 2.9 we describe arrays of variables, and in Section 2.10 we discuss about variables with empty domains as well as about useless variables. In the last section of this chapter, Section 2.11, we show how solutions can be represented."}, {"heading": "2.1 0/1 Variables", "text": "There is no specific language keyword for denoting a 0/1 variable. Instead, a 0/1 variable is defined as an integer variable (see next section).\nRemark 3 In XCSP3, there is no difference between a 0/1 variable and a Boolean variable: when appropriate, 0 stands for false and 1 stands for true."}, {"heading": "2.2 Integer Variables", "text": "Integer variables are given a domain of values by listing them, using whitespace as separator. More precisely, the content of an element <var> that represents an integer variable is an ordered sequence of integer values and integer intervals. We have for example:\n\u2022 1 5 10 that corresponds to the set {1, 5, 10}. \u2022 1..3 7 10..14 that corresponds to the set {1, 2, 3, 7, 10, 11, 12, 13, 14}.\nSyntax 7\n<var id=\"identifier\" [type=\"integer\"]>\n((intVal | intIntvl) wspace)*\n</var>\n25\nAs an illustration, below, both variables foo and bar exhibit the same domain, whereas qux mixes integer and integer intervals:\nExample 8\n<var id=\"foo\"> 0 1 2 3 4 5 6 </var > <var id=\"bar\"> 0..6 </var > <var id=\"qux\"> -6..-2 0 1..3 4 7 8..11 </var >\nAs mentioned earlier, declaring a 0/1 variable is made explicitly, i.e, with the same syntax as an \u201cordinary\u201d integer variable. For example, b1 and b2 are two 0/1 variables that can be served as Boolean variables in logical expressions:\nExample 9\n<var id=\"b1\"> 0 1 </var > <var id=\"b2\"> 0 1 </var >\nNot all domains of integer variables are necessarily finite. Indeed, it is possible to use the special value infinity , preceded by the mandatory sign + or \u2212 (necessarily, as a bound for an integer interval). For example:\nExample 10\n<var id=\"x\"> 0..+ infinity </var > <var id=\"y\"> -infinity ..+ infinity </var >\nFinally, when domains of certain variables are similar, and it appears that declaring array(s) is not appropriate, we can use the optional attribute as to indicate that an element has the same content as another one; the value of as must be the value of an attribute id, as explained in Section 10.5 of Chapter 10. Below, v2 is a variable with the same domain as v1.\nExample 11\n<var id=\"v1\"> 2 5 8 9 12 15 22 25 30 50 </var > <var id=\"v2\" as=\"v1\" />\nRemark 4 As shown by the syntax, for an integer variable, the attribute type is optional: if present, its value must be \"integer\".\nRemark 5 The integer values and intervals listed in the domain of an integer variable must always be in increasing order, without several occurrences of the same value. For example, 0..10 10 is forbidden to be the content of an element <var>."}, {"heading": "2.3 Symbolic Variables", "text": "A symbolic variable is defined from a finite domain containing a sequence of symbols as possible values (whitespace as separator). These symbols are identifiers, and so, must start with a letter. For a symbolic variable, the attribute type for element <var> is required, and its value must be \"symbolic\".\n26\nSyntax 8\n<var id=\"identifier\" type=\"symbolic\">\n(symbol wspace)*\n</var>\nAn example is given by variables light, whose domain is {green, orange, red}, and person, whose domain is {tom, oliver , john,marc}.\nExample 12\n<var id=\"light\" type=\"symbolic\"> green orange red </var > <var id=\"person\" type=\"symbolic\"> tom oliver john marc </var >\nRemark 6 Integer values and symbolic values cannot be mixed inside the same domain.\nRemark 7 The values listed in the domain of a symbolic variable are not necessarily given in increasing (lexicographic) order, but they must be all distinct."}, {"heading": "2.4 Real Variables", "text": "Real variables are given a domain of values by listing real intervals, using whitespace as separator. More precisely, the content of an element <var> that represents a real variable contains an ordered sequence of real intervals (two bounds separated by a comma and enclosed between open or closed square brackets), whose bounds are integer, decimal or rational values. In practice, most of the time, only one interval is given. For a real variable, the attribute type for element <var> is required, and its value must be \"real\".\nSyntax 9\n<var id=\"identifier\" type=\"real\">\n(realIntvl wspace)*\n</var>\nWe have for example:\nExample 13\n<var id=\"w\" type=\"real\"> [0,+ infinity[ </var > <var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [2/3 ,8.355] </var >\nRemark 8 Whenever infinity is involved, the associated square bracket(s) must be open, so that we shall always write ]-infinity and +infinity[.\nRemark 9 The intervals listed in the domain of a real variable must always be in increasing order, without overlapping. For example, [0,10] [8,20] is forbidden as content of any element <var>.\n27"}, {"heading": "2.5 Set Variables", "text": "Set variables have associated set domains. To begin with, we focus on integer set variables, i.e., on variables that must be assigned a set of integer values. It is usual1 that a set domain is approximated by a set interval specified by its upper and lower bounds (subset-bound representation), defined by some appropriate ordering on the domain values [59, 60]. The core idea is to approximate the domain of a set variable s by a closed interval denoted [smin, smax], specified by its unique least upper bound smin, and unique greatest lower bound smax, under set inclusion. We have smin that contains the required elements of s and smax that contains in addition the possible elements of s. For example, if [smin = {1, 5}, smax = {1, 3, 5, 6}] is the domain of an integer set variable s, then it means that the elements 1 and 5 necessarily belong to s and that 3 and 6 are possible elements of s. The variable s can then be assigned any set in the lattice defined from smin and smax.\nTo define an integer set variable, we just have to introduce two elements <required> and <possible> within the element <var>. Such elements contain an ordered sequence of integers and integer intervals, as for ordinary integer variables. For an integer set variable, the attribute type for <var> is required, and its value must be \"set\".\nSyntax 10\n<var id=\"identifier\" type=\"set\">\n[<required> ((intVal | intIntvl) wspace)* </required>\n<possible> ((intVal | intIntvl) wspace)* </possible>]\n</var>\nAn integer set variable s of domain [{1, 5}, {1, 3, 5, 6}] is thus represented by:\nExample 14\n<var id=\"s\" type=\"set\">\n<required > 1 5 </required > <possible > 3 6 </possible >\n</var >\nIt is also possible to define symbolic set variables. In that case, elements <required> and <possible> must each contain a sequence of symbols (identifiers). For a symbolic set variable, the attribute type for <var> is required, and its value must be \"symbolic set\".\nSyntax 11\n<var id=\"identifier\" type=\"symbolic set\">\n[<required> (symbol wspace)* </required>\n<possible> (symbol wspace)* </possible>]\n</var>\nThe following example exhibits a symbolic set variable named team, which must contain elements Bob and Paul, and can additionally contain elements Emily, Luke and Susan.\n1There exist alternatives to represent domains, as the length-lex representation [61]. We might introduce them in the future if they become more popular in solvers.\n28\nExample 15\n<var id=\"team\" type=\"symbolic set\">\n<required > Bob Paul </required > <possible > Emily Luke Susan </possible >\n</var >\nRemark 10 It is forbidden to have a value present both in <required> and <possible>."}, {"heading": "2.6 Graph Variables", "text": "Graph variables have associated graph domains. More precisely, graph variables have domains that are approximated by the lattice of graphs included between two bounds: the greatest lower bound and the least upper bound of the lattice [44]. Graph variables can be directed or undirected, meaning that either edges or arcs are handled. For a graph variable g, the greatest lower bound gmin defines the set of nodes and edges/arcs which are known to be part of g while the least upper bound graph gmax defines the set of possible nodes and edges/arcs in g. For example, if [gmin = ({a, b}, {(a, b)}), gmax = ({a, b, c}, {(a, b), (a, c), (b, c)})] is the domain of an undirected graph variable g, then it means that the nodes a and b, as well as the edge (a, b) necessarily belong to g and that the node c as well as the edges (a, c) and (b, c) are possible elements of g.\nTo define a graph variable, we have to introduce two elements <required> and <possible> within the element <var>. Inside these elements, we find the elements <nodes> and <edges> for an undirected graph variable, and the elements <nodes> and <arcs> for a directed graph variable. For a graph variable, the attribute type for <var> is required, and its value must be either \"undirected graph\" or \"directed graph\".\nSyntax 12\n<var id=\"identifier\" type=\"undirected graph\">\n[<required>\n<nodes> (symbol wspace)* </nodes> <edges> (\"(\" symbol \",\" symbol \")\")* </edges>\n</required> <possible>\n<nodes> (symbol wspace)* </nodes> <edges> (\"(\" symbol \",\" symbol \")\")* </edges>\n</possible>]\n</var>\nSyntax 13\n<var id=\"identifier\" type=\"directed graph\">\n[<required>\n<nodes> (symbol wspace)* </nodes> <arcs> (\"(\" symbol \",\" symbol \")\")* </edges>\n</required> <possible>\n29\n<nodes> (symbol wspace)* </nodes> <arcs> (\"(\" symbol \",\" symbol \")\")* </edges>\n</possible>]\n</var>\nThe example given by Figure 2.2, for an undirected graph variable g whose domain is [({a, b}, {(a, b)}), ({a, b, c}, {(a, b), (a, c), (b, c)})], is thus represented by:\nRemark 11 It is forbidden to have an element (node, edge, or arc) present both in <required> and <possible>."}, {"heading": "2.7 Stochastic Variables", "text": "In some situations, when modeling a problem, it is useful to associate a probability distribution with the values that are present in the domain of an integer variable. Such variables are typically uncontrollable (i.e., not decision variables). This is for example the case with the Stochastic CSP (SCSP) framework introduced by T. Walsh [135] to capture combinatorial decision problems involving uncertainty. In XCSP3, the domain of an integer stochastic variable is defined as usual by a sequence of integers and integer intervals, but each element of the sequence is given a probability preceded by the symbol \u201d:\u201d. The value of a probability can be 0, 1, a rational value or a decimal value in ]0, 1[. Note that it is also possible to declare symbolic stochastic variables. For an integer stochastic variable, the attribute type for <var> is required, and its value must be \"stochastic\".\n30\nSyntax 14\n<var id=\"identifier\" type=\"stochastic\">\n((intVal | intIntvl) \":\" proba wspace)+\n</var>\nFor a symbolic stochastic variable, the attribute type for <var> is required, and its value must be \"symbolic stochastic\".\nSyntax 15\n<var id=\"identifier\" type=\"symbolic stochastic\">\n(symbol \":\" proba wspace)+\n</var>\nOf course, the sum of probabilities associated with the different possible values of a stochastic variable must be equal to 1, and consequently, it is not possible to build a stochastic variable with an empty domain.\nAn illustration is given by:\nExample 17\n<var id=\"foo\" type=\"stochastic\">\n5:1/6 15:1/3 25:1/2\n</var > <var id=\"dice\" type=\"stochastic\">\n1..6:1/6\n</var > <var id=\"coin\" type=\"symbolic stochastic\">\nheads :0.5 tails :0.5\n</var >\nRemark 12 When the probability is associated with an integer interval, it applies independently to every value of the interval."}, {"heading": "2.8 Qualitative Variables", "text": "In qualitative spatial and temporal reasoning (QSTR) [70], one has to reason with entities that corresponds to points, intervals, regions, ... The variables that are introduced represent such entities, and their domains, being continuous, cannot be described extensionally. This is the reason why we simply use the attribute type to refer to the implicit domain of qualitative variables.\nIn XCSP3, we can currently refer to the following types: \u2022 \"point\", when referring to the possible time points (or equivalently, points of the line) \u2022 \"interval\", when referring to the possible time intervals (or equivalently, intervals of\nthe line)\n31\n\u2022 \"region\", when referring to possible regions in Euclidean space (or in a topological space)\nSyntax 16\n<var id=\"identifier\" type=\"point\" /> <var id=\"identifier\" type=\"interval\" /> <var id=\"identifier\" type=\"region\" />\nAn illustration is given by:\nExample 18\n<var id=\"foo\" type=\"point\" /> <var id=\"bar\" type=\"interval\" /> <var id=\"qux\" type=\"region\" />\nRemark 13 Other domains for qualitative variables might be introduced in the future."}, {"heading": "2.9 Arrays of Variables", "text": "Interestingly, XCSP3 allows us to declare k-dimensional arrays of variables, with k \u2265 1, by introducing elements <array> inside <variables>. We recall the general (simplified) syntax for arrays:\nSyntax 17\n<array id=\"identifier\" [type=\"varType\"] size=\"dimensions\" [startIndex=\"integer\"]>\n...\n</array>\nHence, for each such element, there is a required attribute id and a required attribute size whose value gives the structure of the array under the form \u201d[nb1]...[nbp]\u201d with nb1, . . . , nbp being strictly positive integers. The number of dimensions of an array is the number of pairs of opening/closing square brackets, and the size of each dimension is given by its bracketed value. For example, if x is an array of 10 variables, you just write \"[10]\", and if y is a 2-dimensional array, 5 rows by 8 columns, you write \"[5][8]\". Indexing used for any dimension of an array starts at 0, unless the (optional) attribute startIndex gives another value. Of course, it is possible to define arrays of any kind of variables, as e.g., arrays of symbolic variables, arrays of set variables, etc. by using the attribute type: all variables of an array have the same type. The content of an element <array> of a specified type is defined similarly to the content of an element <var> of the same type, and basically, all variables of an array have the same domain, except if mixed domains are introduced (as we shall see in subsection 2.9.2).\nTo define an array x of 10 integer variables with domain 1..100, a 2-dimensional array y (5 \u00d7 8) of 0/1 variables, an array diceYathzee of 5 stochastic variables, and an array z of 12 symbolic set variables with domain [{a, b}, {a, b, c, d}], we write:\n32\nExample 19\n<array id=\"x\" size=\"[10]\"> 1..100 </array > <array id=\"y\" size=\"[5][8]\"> 0 1 </array > <array id=\"diceYathzee\" size=\"[5]\" type=\"stochastic\">\n1..6:1/6\n</array > <array id=\"z\" size=\"[12]\" type=\"symbolic set\">\n<required > a b </required > <possible > c d </possible >\n</array >\nImportantly, it is necessary to be able to identify variables in arrays. We simply use the classical \u201c[]\u201d notation, with indexing starting at 0 (unless another value is given by startIndex). For example, assuming that 0 is the \u201cstarting index\u201d, x[0] is the first variable of the array x, and y[4][7] the last variable of the array y."}, {"heading": "2.9.1 Using Compact Forms", "text": "Sometimes, one is interested in selecting some variables from an array, for example, the variables in the first row of a 2-dimensional array. We use integer intervals for that purpose, as in x[3..5] and y[2..3][0..1], and we refer to such expressions as compact lists of array variables. In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)). On our previous example, in a context where a list of variables is expected, x[3..5] denotes the list of variables x[3], x[4] and x[5], while y[2..3][0..1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1]. It is also possible to omit an index, with a meaning similar to using 0..s where s denotes the largest possible index. For example, y[2][] is equivalent to y[2][0..7].\nFinally, one may wonder how compact lists of array variables (such as x[3..5], y[2..3][0..1], x[], y[][]) precisely expand in the context of the XCSP3 elements that will be presented in the next chapters. The rule is the following:\n1. if a 2-dimensional compact list (such as y[][]) appears in an element <matrix>, the compact list expands as a sequence of tuples (one tuple per row, with variables of the row separated by a comma, enclosed between parentheses). For example,\n<matrix >\ny[][]\n</matrix >\nexpands as:\n33\n<matrix >\n(y[0][0] ,y[0][1] ,... ,y[0][7]) (y[1][0] ,y[1][1] ,... ,y[1][7]) ... (y[4][0] ,y[4][1] ,... ,y[4][7])\n</matrix >\n2. in all other situations, the compact list expands as a list of variables, with whitespace as a separator. For example, we have:\n<list >\ny[2..3][0..1]\n</list >\nthat expands as:\n<list >\ny[2][0] y[2][1] y[3][0] y[3][1]\n</list >\nUsing this rule, it is always possible to expand all compact lists of array variables in order to get a form of the problem instance with only references to simple variables."}, {"heading": "2.9.2 Dealing With Mixed Domains", "text": "Sometimes, the variables from the same array naturally have mixed domains. One solution is to build a large domain that can be suitable for all variables, and then to post unary domain constraints. But this not very satisfactory.\nAnother solution with XCSP3 is to insert the different definitions of domains inside the <array> element. When several subsets of variables of an array have different domains, we simply have to put an element <domain> for each of these subsets. An attribute for indicates the list of variables to which the domain definition applies. The value of for can be a sequence (whitespace as separator) of variable identifiers (with compact forms authorized), or the special value \"others\", which is used to declare a default domain. Only one element <domain> can have its attribute for set to \"others\", and if it is present, it is necessary at the last position. The syntax for arrays that involve variables with different domains is:\nSyntax 18\n<array id=\"identifier\" [type=\"varType\"] size=\"dimensions\" [startIndex=\"integer\"]>\n(<domain for=\"(intVar wspace)+\"> ... </domain>)+ [<domain for=\"others\"> ... </domain>]\n</array>\nAs an illustration, the 2-dimensional array x below is such that the variables of the first, second and third rows have 1..10, 1..20 and 1..15 as domains, respectively. Also, all variables\n34\nof array y have {2, 4, 6} as domain except for y[4] whose domain is {0, 1}. Finally, all variables of array z have {0, 1} as domain except for the variables that belong to the lists z[][0..1][] and z[][2][2..4].\nExample 20\n<array id=\"x\" size=\"[3][5]\">\n<domain for=\"x[0][]\"> 1..10 </domain > <domain for=\"x[1][]\"> 1..20 </domain > <domain for=\"x[2][]\"> 1..15 </domain >\n</array > <array id=\"y\" size=\"[10]\">\n<domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain >\n</array > <array id=\"z\" size=\"[5][5][5]\">\n<domain for=\"z[][0..1][] z[][2][2..4]\"> 0..10 </domain > <domain for=\"others\"> 0 1 </domain >\n</array >"}, {"heading": "2.10 Empty Domains and Useless Variables", "text": "In some (rare) cases, one may want to represent variables with empty domains. For example, if an inconsistency is detected during an inference process, it may be interesting to represent the state of the variable domains (including those that became empty). For all types of variables, except for qualitative ones, an empty content for an element <var> (or <array>) means that the domain is empty (if, of course, the attribute as is not present).\nIn our illustration, below, we have an integer variable x and a set variable y, with both an empty domain.\nExample 21\n<var id=\"x\" /> <var id=\"y\" type=\"set\" />\nWe conclude this chapter with a short discussion about the concept of undefined and useless variables. An undefined (domain) variable is a variable with no domain definition (note that this is different from a variable having an empty domain). Actually, undefined variables can only belong to arrays showing different domains for subsets of variables: when a variable does not match any value of attributes for, then it is undefined, and so must be completely ignored (by solvers).\nAs an illustration, below, the variable z[5] is undefined.\nExample 22\n<array id=\"z\" size=\"[10]\">\n<domain for=\"z[0..4]\"> 1..10 </domain > <domain for=\"z[6..9]\"> 1..20 </domain >\n</array >\n35\nA variable is said useless if it is involved nowhere (neither in constraints nor in objective functions); otherwise, it is said useful. On the one hand, a useless variable can be the result of a reformulation/simplification process (and one may wish to keep such variables, for various reasons). On the other hand, modeling can introduce useless variables, typically for symmetrical reasons, which may happen when introducing arrays of variables.\nFor the example below, suppose that only variables [i][j] of t such that i > j are involved in constraints. This means that all variables [i][j] with i \u2264 j are useless.\nExample 23\n<array id=\"t\" size=\"[8][8]\"> 1..10 </array >\nRemark 14 It is not valid to have a variable both undefined and useful. In other words, it is not permitted in XCSP3 to have an undefined variable that is involved in a constraint or an objective.\nTo summarize, undefined variables must be ignored by solvers, and useless variables can be discarded. We might consider introducing in the future new elements, attributes or annotations for clearly specifying which variables are useless, but note that it can be easily identified by parsers. The tool for checking solutions (and their costs) that we are currently developing will be able to handle the presence or the absence of useless variables. So, users will be given the possibility to submit complete instantiations or partial instantiations only involving useful variables."}, {"heading": "2.11 Solutions", "text": "In XCSP3, we can also represent solutions, i.e., XCSP3 output. We simply use an element <instantiation> that gives a value for each (useful) variable of the instance. More precisely, to define a solution, we introduce two elements <list> and <values> inside the element <instantiation>: the ith variable of <list> is assigned the ith value of <values>. Obviously, it is not possible to have several occurrences of the same variable inside <list>.\nThere is a required attribute type. For decision problems, e.g., CSP or SCSP, its value is necessarily \"solution\". For optimization problems, e.g., COP or WCSP, its value is either \"solution\" or \"optimum\", and another required attribute cost gives the cost of the (optimal) solution. The syntax is given below for integer variables only.\nSyntax 19\n<instantiation type=\"solution|optimum\" [cost=\"integer\"] >\n<list> (intVar wspace)+ </list> <values> (intVal wspace)+ </values>\n</instantiation>\nAs an illustration, let us consider the optimization problem from Chapter 1. The optimal solution can be represented by:\n36\nExample 24\n<instantiation type=\"optimum\" cost=\"1700\">\n<list > b c </list > <values > 2 2 </values >\n</instantiation >\nOf course, although the syntax is not developed here (because it is immediate), it is possible to deal with other types of variables:\n\u2022 for symbolic variables, values are represented by symbols as e.g., green, lucie or b, \u2022 for real variables, values are represented by real numbers or intervals as e.g., 7.2 or\n[3.01, 3.02],\n\u2022 for set variables, values are represented by set values, as e.g., {2, 3, 7} or {}. Importantly, when some useless variables are present in an instance, the use is offered three\npossibilities to deal with them:\n\u2022 the useless variables (and of course their values) are not listed, \u2022 the useless variables are given the special value \u2019*\u2019, \u2022 the useless variables are given any value from their domains. Let us illustrate this with a small CSP example. The following instance involves an array\nof 4 variables, but one of them, x[3], is useless.\nExample 25\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<array id=\"x\" size=\"4\"> 1..3 </array >\n</variables > <constraints >\n<intension > eq(add(x[0],x[1]),x[2]) </intension >\n</constraints >\n</instance >\nTo represent the solution x[0] = 1, x[1] = 1, x[2] = 2, one can choose between the three following representations:\nExample 26\n<instantiation type=\"solution\">\n<list > x[0] x[1] x[2] </list > <values > 1 1 2 </values >\n</instantiation >\nExample 27\n<instantiation type=\"solution\">\n<list > x[] </list > <values > 1 1 2 * </values >\n</instantiation >\n37\nExample 28\n<instantiation type=\"solution\">\n<list > x[] </list > <values > 1 1 2 1 </values >\n</instantiation >\nFor the last representation, we could have chosen the value 2 or the value 3 for the last variable x[3]. Note that the interest of these different forms clearly depends on the context.\nRemark 15 Interestingly, a solution can be perceived as a constraint; see Section 4.1.8.2. The attributes are thus simply ignored.\n38\n3 Objectives\nThere are two kinds of elements that can be used for representing objectives. You can use:\n\u2022 an element <minimize> \u2022 or an element <maximize> These elements must be put inside <objectives>. The role of the attribute combination\nwill be explained at the end of this chapter.\nSyntax 20\n<objectives [combination=\"combinationType\"]>\n(<minimize.../> | <maximize.../>)+\n</objectives>\nEach element <minimize> and <maximize> has an optional attribute id and an optional attribute type, whose value can currently be:\n\u2022 \"expression\" \u2022 \"sum\" \u2022 \"product\" \u2022 \"minimum\" \u2022 \"maximum\" \u2022 \"nValues\" \u2022 \"lex\""}, {"heading": "3.1 Objectives in Functional Forms", "text": "The default value for type is \"expression\", meaning that the content of the element <minimize> or <maximize> is necessarily a numerical functional expression (of course, possibly just a vari-\n39\nable) built from operators described in Tables 4.1 and 5.1 for COP instances (that deal with integer values only), and Table 6.1 for NCOP instances (that deal with real values).\nAn objective in functional form is thus defined by an element <minimize> or <maximize>. We only give the syntax of <minimize> (as the syntax for <maximize> is quite similar) for COP instances. Here, an integer functional expression is referred to as intExpr in the syntax box below; its precise syntax is given in Appendix B.\nSyntax 21\n<minimize [id=\"identifier\"] [type=\"expression\"]>\nintExpr\n</minimize>\nFor NCOP instances, just replace above intExpr by realExpr. An example is given below for an objective obj1 that consists in minimizing the value of the variable z, and an objective obj2 that consists in maximizing the value of the expression x+ 2y.\nExample 29\n<minimize id=\"obj1\"> z </minimize > <maximize id=\"obj2\"> add(x,mul(y,2)) </maximize >\nThis way of representing objectives is generic, but when possible, it is better to use specialized forms in order to simplify the XCSP3 code and also to inform directly solvers of the nature of the objective(s)."}, {"heading": "3.2 Objectives in Specialized Forms", "text": "Whatever is the type among \"sum\", \"product\", \"minimum\", \"maximum\", \"nValues\" and \"lex\", two forms are possible. We show this for the element <minimize>, but of course, this is quite similar for the element <maximize>. Here, we give the syntax for COP instances:\nSyntax 22\n<minimize [id=\"identifier\"] type=\"sum|product|minimum|maximum|nValues|lex\">\n<list> (intVar wspace)2+ </list> [<coeffs> (intVal wspace)2+ </coeffs>]\n</minimize>\nFor NCOP instances, you just have to replace (intVar wspace)2+ and (intVal wspace)2+ by (realVar wspace)2+ and (realVal wspace)2+.\nThere is one possible coefficient per variable. When the element <coeffs> is absent, coefficients are all assumed to be equal to 1, and the opening/closing tags for <list> become optional, which gives:\n40\nSyntax 23\n<minimize [id=\"identifier\"] type=\"sum|product|minimum|maximum|nValues|lex\">\n(intVar wspace)2+ // Simplified Form\n</minimize>\nFor the semantics, we consider that X = \u3008x1, x2, . . . , xk\u3009 and C = \u3008c1, c2, . . . , xk\u3009 denote the lists of variables and coefficients. Also, minimizelex denotes minimization over tuples when considering the lexicographic order. Finally, the type is given as third argument of elements minimize below.\nSemantics 1 minimize(X,C, sum) : minimize \u2211|X| i=1 ci \u00d7 xi\nminimize(X,C, product) : minimize \u220f|X| i=1 ci \u00d7 xi minimize(X,C,minimum) : minimize min |X| i=1 ci \u00d7 xi minimize(X,C,maximum) : minimize max |X| i=1 ci \u00d7 xi minimize(X,C,nValues) : minimize |{ci \u00d7 xi : 1 \u2264 i \u2264 |X|}| minimize(X,C, lex ) : minimizelex \u3008c1 \u00d7 x1, c2 \u00d7 x2, . . . , ck \u00d7 xk\u3009\nThe following example shows an objective obj1 that consists in minimizing 2x1 + 4x2 + x3 + 4x4 + 8x5, and an objective obj2 that consists in minimizing the highest value among those taken by variables y1, y2, y3, y4.\nExample 30\n<minimize id=\"obj1\" type=\"sum\">\n<list > x1 x2 x3 x4 x5 </list > <coeffs > 2 4 1 4 8 </coeffs >\n</minimize > <minimize id=\"obj2\" type=\"maximum\">\n<list > y1 y2 y3 y4 </list >\n</minimize >\nBecause the opening and closing tags of <list> are optional here (as there is no element <coeffs>), the objective \"obj2\" can be simply written:\nExample 31\n<minimize id=\"obj2\" type=\"maximum\"> y1 y2 y3 y4 </minimize >\nRemark 16 There is no real interest in introducing coefficients for \"product\"."}, {"heading": "3.3 Multi-objective Optimization", "text": "When dealing with several objectives, it is possible to indicate how these objectives must be combined. The element <objectives> has an optional attribute combination. Current possible values for this attribute are:\n41\n\u2022 \"lexico\": the objectives are lexicographically ordered (according to their positions in <objectives>).\n\u2022 \"pareto\": no objective is more important than another one. Note that this attribute is forbidden when there is only one objective. The default value is \"pareto\". More values might be introduced in the future. For the following example, we try first to minimize the value of z, and in case of equality, we try to maximize the value of the expression x+ (y \u2212 10).\nExample 32\n<objectives combination=\"lexico\">\n<minimize id=\"obj1\"> z </minimize > <maximize id=\"obj2\"> add(x,sub(y,10)) </maximize >\n</objectives >\n42\nPart II\nConstraints\n43\nIn this part of the document, we show how basic forms of constraints are represented in XCSP3. This part contains three chapters, as follows:\nConstraints\nConstraints over Simple Discrete Variables\nConstraints over Integer Variables\nConstraints over Symbolic Variables\nConstraints over Complex Discrete Variables\nConstraints over Set Variables\nConstraints over Graph Variables\nConstraints over Continuous Variables\nConstraints over Real Variables\nConstraints over Qualitative Variables\n44\n4 Constraints over Simple Discrete\nVariables\nThe element <constraints> may contain many kinds of elements, as <constraint.../> denotes any kind of elementary constraint as shown in Appendix B. For example, this can be <extension.../>, <intension.../>, <regular.../>, and so on. In this chapter, we are interested in constraints over simple discrete variables that are either integer or symbolic variables. First, we focus on (elementary) constraints that involve integer variables. This includes of course constraints involving 0/1 variables, which also serve in our format as Boolean variables. Some of these constraints are also appropriate for symbolic variables, as we shall see at the end of this chapter. Constraints involving set, graph and continuous variables will be introduced in next chapters.\nRecall first that there are three main ways of representing constraints: \u2022 by means of a predicate (Boolean expression); \u2022 by listing supports (allowed tuples) or conflicts (forbidden tuples); \u2022 by referring to a known pattern called global constraint. In this chapter, and the next ones, we describe these different possibilities for XCSP3. Each constraint corresponds to an XML element (except for some special forms allowing us to build groups of constraints) that is put inside the element <constraints>. Each constraint has an optional attribute id, and contains one or several XML elements that can be seen as the parameters of the constraint. A constraint parameter is an XML element that usually contains a simple term like a numerical value (possibly, an interval), a variable id, or a more complex term like a list of values, a list of (ids of) variables or a list of tuples.\nNote that many global constraints have been introduced in CP; see [132, 113, 6]. For a welldetailed documentation, we solicit the reader to consult the global constraint catalog. Below, we introduce constraints per family as shown by Figure 4.1.\nFor the syntax, we invite the reader to consult Chapter 1 and Appendix B. Recall that BNF\n45\n46\nnon-terminals are written in dark blue italic form, such as for example intVar and intVal that respectively denote an integer variable and an integer value. In XCSP3, an intVar corresponds to the id of a variable declared in <variables> and an intVal corresponds to a value in N. Note that when the value of a parameter can be an intVal or an intVar, we only give the semantics for intVar. To simplify the presentation, we omit to specify [id=\"identifier\"] when introducing all following types of constraints."}, {"heading": "4.1 Constraints over Integer Variables", "text": ""}, {"heading": "4.1.1 Generic Constraints", "text": "In this section, we present general ways of representing constraints, namely, intentional and extensional forms of constraints. The elements we introduce are:\n1. intension\n2. extension\n4.1.1.1 Constraint intension\nIntentional constraints form an important type of constraints. They are defined from Boolean expressions, usually called predicates. For example, the constraint x + y = z corresponds to an equation that is an expression evaluated to true or false according to the values assigned to the variables x, y and z. Predicates are represented under functional form in XCSP3: the function name appears first, followed by the operands between parenthesis (with comma as a separator). The XCSP3 representation of the constraint x+y = z is eq(add(x, y), z). Operators on integers (including Booleans since we assume that false = 0 and true = 1) that can be used to build predicates are presented in Table 4.1. When we refer to a Boolean operand or result, we mean either the integer value 0 or the integer value 1.\nAn intensional constraint is defined by an element <intension>, containing an element <function> that describes the functional representation of the predicate, referred to as boolExpr in the syntax box below, and whose precise syntax is given in Appendix B.\nSyntax 24\n<intension>\n<function> boolExpr </function>\n</intension>\nNote that the opening and closing tags for <function> are optional, which gives:\nSyntax 25\n<intension> boolExpr </intension> // Simplified Form\nBelow, P denotes a predicate expression with r formal parameters (not shown here, for simplicity), X = \u3008x1, x2, . . . , xr\u3009 a sequence of r variables, the scope of the constraint, and P (x1,x2, . . . ,xr) the value (0 or 1) returned by P for any instantiation of the variables of X.\n47\nSemantics 2\nintension(P,X), with P predicate and X = \u3008x1, x2, . . . , xr\u3009, iff P (x1,x2, . . . ,xr) = 1 // recall that 1 stands for true\nFor example, for constraints c1 : x+ y = z and c2 : w \u2265 z, we have:\n48\nExample 33\n<intension id=\"c1\">\n<function > eq(add(x,y),z) </function >\n</intension > <intension id=\"c2\">\n<function > ge(w,z) </function >\n</intension >\nor, equivalently, in simplified form:\nExample 34\n<intension id=\"c1\"> eq(add(x,y),z) </intension > <intension id=\"c2\"> ge(w,z) </intension >\nMost of the time, intensional constraints correspond to primitive constraints which admit specialized filtering algorithms, such as the binary operators =, 6=, <, . . . When parsing, it is rather easy to identify those primitive constraints.\nRemark 17 It is not possible to use compact lists of array variables (see Chapter 2) and \"+/-infinity\" values in predicates.\n4.1.1.2 Constraint extension\nExtensional constraints, also called table constraints (especially, when constraint arity is large), form another important type of constraints. They are defined by enumerating the list of tuples that are allowed (supports) or forbidden (conflicts). Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3rm [76] and AC3bit+rm [80]. Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].\nAn extensional constraint contains then two elements. The first element is an element <list> that indicates the scope of the constraint (necessarily a list of variable ids). The second element is either an element <supports> or an element <conflicts>, depending on the semantics of the ordinary tuples that are listed in lexicographic order within the element.\nFor classical non-unary positive table constraints, we have:\nSyntax 26\n<extension>\n<list> (intVar wspace)2+ </list> <supports> (\"(\" intVal (\",\" intVal)+ \")\")* </supports>\n</extension>\n49\nSemantics 3\nextension(X,S), with X = \u3008x1, x2, . . . , xr\u3009 and S the set of supports, iff \u3008x1,x2, . . . ,xr\u3009 \u2208 S\nPrerequisite : \u2200\u03c4 \u2208 S, |\u03c4 | = |X| \u2265 2\nFor classical non-unary negative table constraints, we have:\nSyntax 27\n<extension>\n<list> (intVar wspace)2+ </list> <conflicts> (\"(\" intVal (\",\" intVal)+ \")\")* </conflicts>\n</extension>\nSemantics 4\nextension(X,C), with X = \u3008x1, x2, . . . , xr\u3009 and C the set of conflicts, iff \u3008x1,x2, . . . ,xr\u3009 /\u2208 C\nPrerequisite : \u2200\u03c4 \u2208 C, |\u03c4 | = |X| \u2265 2\nHere is an example with a ternary constraint c1 defined on scope \u3008x1, x2, x3\u3009 with supports {\u30080, 1, 0\u3009, \u30081, 0, 0\u3009, \u30081, 1, 0\u3009, \u30081, 1, 1\u3009} and a quaternary constraint c2 defined on scope \u3008y1, y2, y3, y4\u3009 with conflicts {\u30081, 2, 3, 4\u3009, \u30083, 1, 3, 4\u3009}.\nExample 35\n<extension id=\"c1\">\n<list > x1 x2 x3 </list > <supports > (0,1,0)(1,0,0)(1,1,0)(1,1,1) </supports >\n</extension > <extension id=\"c2\">\n<list > y1 y2 y3 y4 </list > <conflicts > (1,2,3,4)(3,1,3,4) </conflicts >\n</extension >\nQuite often, when modeling, there are groups of extensional constraints that share the same relations. It is then interesting to exploit the concept of syntactic group, presented in Section 10.1, or if not appropriate, the attribute as described in Section 10.5.\nFor unary table constraints, one uses a simplified form: supports and conflicts are indeed defined exactly as the domains of integer variables. It means that we directly put integer values and intervals in increasing order within <supports> and <conflicts>.\nFor unary positive table constraints, we have:\n50\nSyntax 28\n<extension>\n<list> intVar </list> <supports> ((intVal | intIntvl) wspace)* </supports>\n</extension>\nFor unary negative table constraints, we have:\nSyntax 29\n<extension>\n<list> intVar </list> <conflicts> ((intVal | intIntvl) wspace)* </conflicts>\n</extension>\nThe semantics is immediate. As an illustration, the constraint c3 corresponds to x \u2208 {1, 2, 4, 8, 9, 10}.\nExample 36\n<extension id=\"c3\">\n<list > x </list > <supports > 1 2 4 8..10 </supports >\n</extension >\nWe now introduce extended forms of non-unary table constraints: they involve non-ordinary tuples, i.e., shortened or compressed tuples. On the one hand, it may be particularly useful to integrate shortened tuples (based on short supports) [93] in tables. This means that we can insert the special symbol \u201d*\u201d in tuples to represent any possible value, for the associated variable(s). For example, the following constraint c4 has two shortened tuples, \u30081, \u2217, 1, 2\u3009 and \u30082, 1, \u2217, \u2217\u3009. Assuming that the domain of all variables is {1, 2}, the first shortened tuple is equivalent to the two (long) tuples \u30081, 1, 1, 2\u3009 and \u30081, 2, 1, 2\u3009 whereas the second shortened tuple is equivalent to the four tuples \u30082, 1, 1, 1\u3009, \u30082, 1, 1, 2\u3009, \u30082, 1, 2, 1\u3009 and \u30082, 1, 2, 2\u3009.\nExample 37\n<extension id=\"c4\">\n<list > z1 z2 z3 z4 </list > <supports > (1,*,1,2)(2,1,*,*) </supports >\n</extension >\nOn the other hand, to reduce space complexity, one may also seek to integrate compressed tuples [69, 137] in tables. This means that tuples can contain not only usual integer values, but also sets of integer values. The set of classical tuples represented by a compressed tuple \u03c4 is then the Cartesian product built from the components of \u03c4 . For example, in constraint c5, \u30080, {1, 2}, 0, {0, 2}\u3009 is a compressed tuple representing the set of tuples in {0} \u00d7 {1, 2} \u00d7 {0} \u00d7 {0, 2}, which contains \u30080, 1, 0, 0\u3009, \u30080, 1, 0, 2\u3009, \u30080, 2, 0, 0\u3009 and \u30080, 2, 0, 2\u3009.\n51\nExample 38\n<extension id=\"c5\">\n<list > w1 w2 w3 w4 </list > <supports > (0,{1,2},0,{0,2})(1,0,1,2)(2,{0,2},0,2) </supports >\n</extension >\nThe syntax is obtained from those given at the beginning of this section, for non-unary constraints, by replacing intVal by tuplePiece, as described in Appendix B, in elements <supports> and <conflicts>.\nRemark 18 Ordinary tuples must always be given in lexicographic order (without any repetitions)."}, {"heading": "4.1.2 Constraints defined from Languages", "text": "In this section, we present constraints that are defined from advanced data structures such as automatas, grammars and diagrams, which exhibit languages. More specifically, we introduce:\n1. regular\n2. grammar\n3. mdd\n4.1.2.1 Constraint regular\nThe constraint regular [33, 96] ensures that the sequence of values assigned to the variables it involves forms a word that can be recognized by a deterministic (or non-deterministic) finite automaton. The scope of the constraint is given by the element <list>, and three elements, <transitions>, <start> and <final>, are introduced for representing respectively the transitions, the start state and the final (accept) states of the automaton. Note that the set of states and the alphabet can be inferred from <transitions>. When the automaton is nondeterministic, we can find two transitions (qi, a, qj) and (qi, a, qk) such that qj 6= qk. In what follows, state stands for any identifier and states for a sequence of identifiers (whitespace as separator).\nSyntax 30\n<regular>\n<list> (intVar wspace)+ </list> <transitions> (\"(\" state \",\" intVal \",\" state \")\")+ </transitions> <start> state </start> <final> (state wspace)+ </final>\n</regular>\nBelow, L(A) denotes the language recognized by a deterministic (or non-deterministic) finite automaton A.\n52\nSemantics 5\nregular(X,A), with X = \u3008x1, x2, . . . , xr\u3009 and A a finite automaton, iff x1x2 . . .xr \u2208 L(A)\nastart b c d e\n0\n1 1 0\n0\n1\n0\nAs an example, the constraint defined on scope \u3008x1, x2, . . . , x7\u3009 from the simple automation depicted above is:\nExample 39\n<regular >\n<list > x1 x2 x3 x4 x5 x6 x7 </list > <transitions >\n(a,0,a)(a,1,b)(b,1,c)(c,0,d)(d,0,d)(d,1,e)(e,0,e)\n</transitions > <start > a </start > <final > e </final >\n</regular >\n4.1.2.2 Constraint grammar\nThe constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar. The scope of the constraint is given by the element <list>, and three elements, <terminal>, <rules> and <start>, are introduced for representing respectively the terminal symbols (in our case, integer values), the production rules and the start non-terminal symbol of the grammar. Each rule is composed of a \u201chead\u201d word (on the left) containing an arbitrary number of symbols (provided that at least one of them is a non-terminal symbol) and a \u201cbody\u201d word (on the right) containing an arbitrary number of symbols (possibly, none). It is important to note that both the head and body words are represented by a sequence of symbols, using whitespace as a separator between each pair of consecutive symbols. This avoids ambiguity, and besides, this allows us to infer the set of non-terminal symbols from <terminal> and <rules>. In what follows, symbol stands for any identifier.\nSyntax 31\n<grammar>\n<list> (intVar wspace)+ </list> <terminal> (intVal wspace)+ </terminal> <rules>\n(\"(\" (intVal | symbol) (wspace (intVal | symbol))* \",\"\n[(intVal | symbol) (wspace (intVal | symbol))*] \")\")+\n</rules> <start> symbol </start>\n53\n</grammar>\nBelow, L(G) denotes the language recognized by a formal grammar G.\nSemantics 6\ngrammar(X,G), with X = \u3008x1, x2, . . . , xr\u3009 and G a grammar, iff x1x2 . . .xr \u2208 L(G)\nAs an example, let us consider the grammar defined from the set of non-terminal symbols N = {A,S} (S being the start symbol), the set of terminal symbols \u03a3 = {0, 1, 2}, and the following rules (with denoting the empty string):\n\u2022 S \u2192 0S \u2022 S \u2192 1S \u2022 A\u2192 \u2022 A\u2192 2A This grammar describes the same language as the regular expression 0\u221712\u2217. Assuming that x1, x2 and x3 are three integer variables with domain {0, 1, 2}, we could build a constraint grammar as follows:\nExample 40\n<grammar >\n<list > x1 x2 x3 </list > <terminal > 0 1 2 </terminal > <rules > (S,0 S)(S,1 S)(A,)(A,2 A) </rules > <start > S </start >\n</grammar >\n4.1.2.3 Constraint mdd\nThe constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node. Because the graph is directed, acyclic, with only one root node and only one terminal node, we just need to introduce <transitions>.\nSyntax 32\n<mdd>\n<list> (intVar wspace)+ </list> <transitions> (\"(\" state \",\" intVal \",\" state \")\")+ </transitions>\n</mdd>\nBelow, L(M) denotes the language recognized by a MDD M .\n54\nSemantics 7\nmdd(X,M), with X = \u3008x1, x2, . . . , xr\u3009 and M a MDD, iff x1x2 . . .xr \u2208 L(M)\nr\nn1 n2 n3\nn4 n5\nt\nx1\nx2\nx3\n0 1 2\n2 2 0\n0 0\nAs an example, the constraint of scope \u3008x1, x2, x3\u3009 is defined from the simple MDD depicted above (with root node r and terminal node t) as:\nExample 41\n<mdd >\n<list > x1 x2 x3 </list > <transitions >\n(r,0,n1)(r,1,n2)(r,2,n3) (n1 ,2,n4)(n2 ,2,n4)(n3 ,0,n5) (n4 ,0,t)(n5 ,0,t)\n</transitions >\n</mdd >"}, {"heading": "4.1.3 Comparison-based Constraints", "text": "In this section, we present constraints that are based on comparisons between pairs of variables. More specifically, we introduce:\n1. allDifferent (capturing allDifferentExcept)\n2. allEqual\n3. allDistant\n4. ordered\n4.1.3.1 Constraint allDifferent\nThe constraint allDifferent, see [108, 131, 58], ensures that the variables in <list> must all take different values. A variant, called allDifferentExcept in the literature [6, 40], enforces variables to take distinct values, except those that are assigned to some specified values (often, the single value 0). This is the reason why we introduce an optional element <except>.\n55\nSyntax 33\n<allDifferent>\n<list> (intVar wspace)2+ </list> [<except> (intVal wspace)+ </except>]\n</allDifferent>\nNote that the opening and closing tags of <list> are optional if <list> is the unique parameter of the constraint, which gives:\nSyntax 34\n<allDifferent> (intVar wspace)2+ </allDifferent> // Simplified Form\nSemantics 8\nallDifferent(X,E), with X = \u3008x1, x2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X|,xi 6= xj \u2228 xi \u2208 E \u2228 xj \u2208 E allDifferent(X) iff allDifferent(X, \u2205)\nFor example, below, the constraint c1 forces all variables x1, x2, x3, x4, x5 to take different values, and the constraint c2 forces each of the variables of the 1-dimensional array y to take either the value 0 or a value different from the other variables.\nExample 42\n<allDifferent id=\"c1\">\nx1 x2 x3 x4 x5\n</allDifferent > <allDifferent id=\"c2\">\n<list > y[] </list > <except > 0 </except >\n</allDifferent >\nRemark 19 Possible restricted forms of allDifferent are possible by forcing variables to be, for example, symmetric and/or irreflexive. For more details, see Section 7.3.\n4.1.3.2 Constraint allEqual\nThe constraint allEqual ensures that all involved variables take the same value.\nSyntax 35\n<allEqual>\n<list> (intVar wspace)2+ </list>\n</allEqual>\nNote that the opening and closing tags of <list> are optional, which gives:\n56\nSyntax 36\n<allEqual> (intVar wspace)2+ </allEqual> // Simplified Form\nSemantics 9\nallEqual(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X|,xi = xj\nExample 43\n<allEqual >\nx1 x2 x3 x4 x5\n</allEqual >\n4.1.3.3 Constraint allDistant\nThe constraint allDistant ensures that the distance between each pair of variables of <list> is subject to a numerical condition. In [110, 102], this constraint is studied with respect to the operator \u2265, and called interDistance.\nSyntax 37\n<allDistant>\n<list> (intVar wspace)2+ </list> <condition> \"(\" operator \",\" operand \")\" </condition>\n</allDistant>\nSemantics 10\nallDistant(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X|, |xi \u2212 xj | v\nBelow, the constraint c1 corresponds to |x1\u2212x2| \u2265 2\u2227|x1\u2212x3| \u2265 2\u2227|x2\u2212x3| \u2265 2, whereas the constraint c2 guarantees that \u2200(i, j) : 1 \u2264 i < j \u2264 4, we have 2 \u2264 |yi \u2212 yj | \u2264 4\nExample 44\n<allDistant id=\"c1\">\n<list > x1 x2 x3 </list > <condition > (ge ,2) </condition >\n</allDistant > <allDistant id=\"c2\">\n<list > y1 y2 y3 y4 </list > <condition > (in ,2..4) </condition >\n</allDistant >\n57\n4.1.3.4 Constraint ordered\nThe constraint ordered ensures that the variables of <list> are ordered in sequence according to a relational operator specified in <operator>, whose value must be in {<,\u2264,\u2265, >}.\nSyntax 38\n<ordered>\n<list> (intVar wspace)2+ </list> <operator> \"lt\" | \"le\" | \"ge\" | \"gt\" </operator>\n</ordered>\nSemantics 11\nordered(X, ), with X = \u3008x1, x2, . . .\u3009 and \u2208 {<,\u2264,\u2265, >}, iff \u2200i : 1 \u2264 i < |X|,xi xi+1\nBelow, the constraint c is equivalent to x1 < x2 < x3 < x4.\nExample 45\n<ordered id=\"c\">\n<list > x1 x2 x3 x4 </list > <operator > lt </operator >\n</ordered >\nThe constraints from the Global Constraint Catalog that are captured by ordered are: \u2022 increasing, strictly increasing \u2022 decreasing, strictly decreasing As a matter of fact, one can define a constraint ordered without using the element <operator>:\nit suffices to add a special attribute case to <ordered>. This way, the opening and closing tags of <list> become optional, making the XCSP3 representation more compact.\nSyntax 39\n<ordered case=\"orderedType\"> (intVar wspace)2+ </ordered> // Simplified Form\nThe possible values for the attribute case are \"increasing\", \"strictlyIncreasing\", \"decreasing\" and \"strictlyDecreasing\". The constraint c, introduced above, can then be written:\nExample 46\n<ordered id=\"c\" case=\"strictlyIncreasing\"> x1 x2 x3 x4 </ordered >\nRemark 20 In the future, the format might be extended to include an element specifying the order (preferences between values) to follow.\n58"}, {"heading": "4.1.4 Counting and Summing Constraints", "text": "In this section, we present constraints that are based on counting the number of times variables or values satisfy a certain condition, and also those that are based on summations. More specifically, we introduce:\n1. sum (sometimes called linear in the literature)\n2. count (capturing among, atLeast, atMost and exactly)\n3. nValues (capturing nValuesExcept)\n4. cardinality\n5. balance\n6. spread\n7. deviation\n8. sumCosts\n4.1.4.1 Constraint sum\nThe constraint sum is one of the most important constraint. When the optional element <coeffs> is missing, it is assumed that all coefficients are equal to 1. The constraint is subject to a numerical condition.\nSyntax 40\n<sum>\n<list> (intVar wspace)2+ </list> [ <coeffs> (intVal wspace)2+ | (intVar wspace)2+ </coeffs> ] <condition> \"(\" operator \",\" operand \")\" </condition>\n</sum>\nAlthough in practice, coefficients are most the time integer values, we introduce the semantics with variable coefficients.\nSemantics 12\nsum(X,C, ( , k)), with X = \u3008x1, x2, . . .\u3009, and C = \u3008c1, c2, . . .\u3009, iff ( \u2211|X| i=1 ci \u00d7 xi) k\nPrerequisite : |X| = |C| \u2265 2\nThe following constraint c1 states that the values taken by variables x1, x2, x3 and y must respect the linear function x1 \u00d7 1 + x2 \u00d7 2 + x3 \u00d7 3 > y.\nExample 47\n<sum id=\"c1\">\n<list > x1 x2 x3 </list > <coeffs > 1 2 3 </coeffs > <condition > (gt,y) </condition >\n</sum >\n59\nA form of sum, sometimes called subset-sum or knapsack [125, 97] involves the operator \u201cin\u201d, and ensures that the obtained sum belongs (or not) to a specified interval. The following constraint c2 states that the values taken by variables y1, y2, y3, y4 must respect 2 \u2264 y1 \u00d7 4 + y2 \u00d7 2 + y3 \u00d7 3 + y4 \u00d7 1 \u2264 5.\nExample 48\n<sum id=\"c2\">\n<list > y1 y2 y3 y4 </list > <coeffs > 4 2 3 1 </coeffs > <condition > (in ,2..5) </condition >\n</sum >\n4.1.4.2 Constraint count\nThe constraint count, introduced in CHIP [8] and Sicstus [34], ensures that the number of variables in <list> which are assigned a value in <values> respects a numerical condition. It is also present in Gecode with the same name and in the Global Constraint Catalog where it is called counts. This constraint captures known constraints atLeast, atMost, exactly and among.\nSyntax 41\n<count>\n<list> (intVar wspace)2+ </list> <values> (intVal wspace)+ | (intVar wspace)+ </values> <condition> \"(\" operator \",\" operand \")\" </condition>\n</count>\nTo simplify, we assume for the semantics that V is a set of integer values.\nSemantics 13\ncount(X,V, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff |{i : 1 \u2264 i \u2264 |X| \u2227 xi \u2208 V }| k\nBelow, c1 enforces that the number of variables in {v1, v2, v3, v4} that take the value of variable v must be different from the value of k1. Constraints c2, c3, c4 and c5 illustrate how to represent atLeast, atMost, exactly and among.\n\u2022 c2 represents among(k2, {w1, w2, w3, w4}, {1, 5, 8}); \u2022 c3 represents atLeast(k3, {x1, x2, x3, x4, x5}, 1); \u2022 c4 represents atMost(2, {y1, y2, y3, y4}, 0); \u2022 c5 represents exactly(k5, {z1, z2, z3}, z).\n60\nExample 49\n<count id=\"c1\">\n<list > v1 v2 v3 v4 </list > <values > v </values > <condition > (ne,k1) </condition >\n</count > <count id=\"c2\"> // among\n<list > w1 w2 w3 w4 </list > <values > 1 5 8 </values > <condition > (eq,k2) </condition >\n</count > <count id=\"c3\" > // atLeast\n<list > x1 x2 x3 x4 x5 </list > <values > 1 </values > <condition > (ge,k3) </condition >\n</count > <count id=\"c4\" > // atMost\n<list > y1 y2 y3 y4 </list > <values > 0 </values > <condition > (le ,2) </condition >\n</count > <count id=\"c5\"> // exactly\n<list > z1 z3 z3 </list > <values > z </values > <condition > (eq,k5) </condition >\n</count >\n4.1.4.3 Constraint nValues\nThe constraint nValues [17], ensures that the number of distinct values taken by variables in <list> respects a numerical condition. A variant, called nValuesExcept [17] discards some specified values (often, the single value 0). This is the reason why we introduce an optional element <except>.\nSyntax 42\n<nValues>\n<list> (intVar wspace)2+ </list> [<except> (intVal wspace)+ </except>] <condition> \"(\" operator \",\" operand \")\" </condition>\n</nValues>\nSemantics 14\nnValues(X,E, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff |{xi : 1 \u2264 i \u2264 |X|} \\ E| k nValues(X, , k) iff nValues(X, \u2205, ( , k))\n61\nRemark 21 This element captures atLeastNValues and atMostNValues, since it is possible to specify the relational operator in <condition>.\nIn the following example, the constraint c1 states that there must be exactly three distinct values taken by variables x1, . . . , x4, whereas c2 states at most w distinct values must be taken by variables y1, . . . , y5. The constraint c3 ensures that two different values are taken by variables z1, . . . , z4, considering that the value 0 must be ignored.\nExample 50\n<nValues id=\"c1\">\n<list > x1 x2 x3 x4 </list > <condition > (eq ,3) </condition >\n</nValues > <nValues id=\"c2\">\n<list > y1 y2 y3 y4 y5 </list > <condition > (le,w) </condition >\n</nValues > <nValues id=\"c3\">\n<list > z1 z2 z3 z4 </list > <except > 0 </except > <condition > (eq ,2) </condition >\n</nValues >\nRemark 22 The constraint increasingNValues can be built by adding restriction increasing to <list>. For more details about restricted constraints, see section 7.3.\n4.1.4.4 Constraint cardinality\nThe constraint cardinality, also called globalCardinality or gcc, see [109, 65], ensures that the number of occurrences of each value in <values>, taken by variables of <list>, is related to a corresponding element (value, variable or interval) in <occurs>. The element <values> has an optional attribute closed (\"true\", by default): when closed=\"true\", this means that all variables of <list> must be assigned a value from <values>.\nSyntax 43\n<cardinality>\n<list> (intVar wspace)2+ </list> <values [closed=\"boolean\"]> (intVal wspace)+ | (intVar wspace)+ </values> <occurs> (intVal wspace)+ | (intVar wspace)+ | (intIntvl wspace)+ </occurs>\n</cardinality>\nFor simplicity, for the semantics, we assume that V only contains values and O only contains variables. Note that V cl means that closed=\"true\".\n62\nSemantics 15\ncardinality(X,V,O), with X = \u3008x1, x2, . . .\u3009, V = \u3008v1, v2, . . .\u3009, O = \u3008o1, o2, . . .\u3009, iff \u2200j : 1 \u2264 j \u2264 |V |, |{i : 1 \u2264 i \u2264 |X| \u2227 xi = vj}| = oi cardinality(X,V cl , O) iff cardinality(X,V,O) \u2227 \u2200i : 1 \u2264 i \u2264 |X|,xi \u2208 V\nPrerequisite : |X| \u2265 2 \u2227 |V | = |O| \u2265 1\nIn the following example, c1 states that value 2 must be assigned to 0 or 1 variable (among x1, x2, x3, x4), value 5 must be assigned by at least 1 and at most 3 variables, and value 10 by at least 2 and at most 3 variables. For c2, the number of variables from y1, y2, y3, y4, y5 that take value 0 must be equal to z0, and so on. Note that it is possible for a variable to be assigned a value not present in {0, 1, 2, 3, } since closed=\"false\".\nExample 51\n<cardinality id=\"c1\">\n<list > x1 x2 x3 x4 </list > <values > 2 5 10 </values > <occurs > 0..1 1..3 2..3 </occurs >\n</cardinality > <cardinality id=\"c2\">\n<list > y1 y2 y3 y4 y5 </list > <values closed=\"false\"> 0 1 2 3 </values > <occurs > z0 z1 z2 z3 </occurs >\n</cardinality >\nThe form of the constraint obtained by only considering variables in all contained elements is called distribute in MiniZinc. In that case, for the semantics, me must additionally guarantee:\n\u2200(i, j) : 1 \u2264 i < j \u2264 |V |,vi 6= vj .\nExample 52\n<cardinality id=\"c3\">\n<list > w1 w2 w3 w4 </list > <values > v1 v2 </values > <occurs > n1 n2 </occurs >\n</cardinality >\nThe constraint cardinalityWithCosts [112] will be discussed in Section 8.5.3.\nRemark 23 The constraint increasing global ardinality defined in the Global Constraint Catalog can be built by adding restriction increasing to <list>. For more details about restricted constraints, see section 7.3.\n4.1.4.5 Constraint balance\nThe constraint balance [6, 21] ensures that the difference between the maximum number of occurrences and the minimum number of occurrences among the values assigned to the variables\n63\nin <list> respects a numerical condition. If the optional element <values> is present, then all variables must be assigned to a value from this set; see balance\u2217 in [21].\nSyntax 44\n<balance>\n<list> (intVar wspace)2+ </list> [<values> (intVal wspace)+ </values>] <condition> \"(\" operator \",\" operand \")\" </condition>\n</balance>\nSemantics 16\nbalance(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff maxv\u2208V |{i : 1 \u2264 i \u2264 |X| \u2227 xi = v}| \u2212minv\u2208V |{i : 1 \u2264 i \u2264 |X| \u2227 xi = v}| k with V = {xi : 1 \u2264 i \u2264 |X|} balance(X,V, ( , k)) iff balance(X, ( , k)) \u2227 \u2200xi \u2208 X,xi \u2208 V\nExample 53\n<balance id=\"c1\">\n<list > x1 x2 x3 x4 </list > <condition > (eq,k) </condition >\n</balance > <balance id=\"c2\">\n<list > y1 y2 y3 y4 y5 </list > <values > 0 1 2 </values > <condition > (lt ,2) </condition >\n</balance >\n4.1.4.6 Constraint spread\nThe constraint spread [98, 119, 118] ensures that the variance of values taken by variables of <list> respects a numerical condition. The element <total> is optional; if present, its value must be equal to the sum of values of variables in <list>.\nSyntax 45\n<spread>\n<list> (intVar wspace)2+ </list> [<total> intVar </total>] <condition> \"(\" operator \",\" operand \")\" </condition>\n</spread>\n64\nSemantics 17\nspread(X, s, ( , k)), with X = \u3008x1, x2, . . . xr\u3009, iff s = \u2211r i=1 xi\n(r \u2211r i=1 x 2 i \u2212 s2) k\n4.1.4.7 Constraint deviation\nThe constraint deviation [120, 118] ensures that the deviation of values taken by variables of <list> respects a numerical condition. The element <total> is optional; if present, its value must be equal to the sum of values of variables in <list>.\nSyntax 46\n<deviation>\n<list> (intVar wspace)2+ </list> [<total> intVar </total>] <condition> \"(\" operator \",\" operand \")\" </condition>\n</deviation>\nSemantics 18\ndeviation(X, s, ( , v)), with X = {x1, x2, . . . , xr}, iff s = \u2211r i=1 xi\u2211r\ni=1 |rxi \u2212 s| v\n4.1.4.8 Constraint sumCosts\nThe constraint sumCosts ensures that the sum of integer costs for values taken by variables in <list> respects a numerical condition. This constraint is particularly useful, when combined with other constraints, to express preferences (as shown in Section 8.5).\nA first form of sumCosts allows us to define a cost matrix, where an integer cost is associated with each variable-value pair that we call literal. The matrix contains tuples of integer values; there is one tuple per variable, containing as many costs as values present in the domain of the variable.\nSyntax 47\n<sumCosts>\n<list> (intVar wspace)2+ </list> <costMatrix> (\"(\" intVal ( \",\" intVal)* \")\")2+ </costMatrix> <condition> \"(\" operator \",\" operand \")\" </condition>\n</sumCosts>\nFor the semantics, we assume that M is a matrix that gives the cost M [xi][ai] for any value ai = xi assigned to the ith variable xi of <list>.\n65\nSemantics 19\nsumCosts(X,M, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff\u2211 {M [xi][xi] : 1 \u2264 i \u2264 |X|} k\nThe following example shows a constraint c1 that involves 3 variables y1, y2, y3 in its main list, with four values in each variable domain (let us say {0, 1, 2, 3}). The assignment costs are as follows: 10 for (y1, 0), 0 for (y1, 1), 5 for (y1, 2), 0 for (y1, 3), 0 for (y2, 0), 5 for (y2, 1), and so on. For c1, the sum of assignment costs must be less than or equal to 12.\nExample 54\n<sumCosts id=\"c1\">\n<list > y1 y2 y3 </list > <costMatrix >\n(10,0,5,0) // costs for y1 (0,5,0,0) // costs for y2 (5,10,0,0) // costs for y3\n</costMatrix > <condition > (le ,12) </condition >\n</sumCosts >\nA second form of sumCosts allows us to define the cost matrix under a dual point of view. We replace the element <costMatrix> by a sequence of elements <literals>, where each such element has a required attribute cost that gives the common cost of all literals (variable-value pairs) contained inside the element. It is possible to use the optional attribute defaultCost for <sumCosts> to specify the cost of all implicit literals (i.e., those not explicitly listed).\nSyntax 48\n<sumCosts [defaultCost=\"integer\"]>\n<list> (intVar wspace)2+ </list> (<literals cost=\"integer\"> (\"(\" intVar \",\" intVal \")\")+ </literals>)+ <condition> \"(\" operator \",\" operand \")\" </condition>\n</sumCosts>\nFor the semantics, we assume, for any pair (xi, ai), that cost A(xi, ai) denotes the cost\ncost(Aj) of the set Aj such that (xi, ai) \u2208 Aj .\nSemantics 20\nsumCosts(X,A, ( , k)), with X = \u3008x1, x2, . . .\u3009, and A = \u3008A1, A2, . . .\u3009 where Ai is a set of literals of cost cost(Pi), iff \u2211 {costA(xi,xi) : 1 \u2264 i \u2264 [X|} k\nPrerequisite :\n\u2200(i, j) : 1 \u2264 i < j \u2264 |A|, Ai \u2229Aj = \u2205 \u2200(x, a) : x \u2208 X \u2227 a \u2208 dom(x), \u2203Ai \u2208 A : (x, a) \u2208 Ai\nWhen a value a always admits the same cost, whatever the variable xi is, we can simplify (x1, a), (x2, a), . . . by (\u2217, a).\n66\nWe give an illustration. The constraint c1b is equivalent to constraint c1 introduced above. The constraint c2 involves 4 variables w1, w2, w3, w4 in its main list, with 3 values in each domain (let us say {0, 1, 2}). The assignment costs are as follows: 10 for (w1, 0), (w2, 0), (w3, 0), (w4, 0) and (w3, 1), and 0 for the other literals (variable-value pairs).\nExample 55\n<sumCosts id=\"c1b\" defaultCost=\"0\">\n<list > y1 y2 y3 </list > <literals cost=\"10\"> (y1 ,0)(y3 ,1) </literals > <literals cost=\"5\"> (y1 ,2)(y2 ,1)(y3 ,0) </literals > <condition > (le ,12) </condition >\n</sumCosts > <sumCosts id=\"c2\" defaultCost=\"0\">\n<list > w1 w2 w3 w4 </list > <literals cost=\"10\"> (*,0)(w3 ,1) </literals > <condition > (eq,z) </condition >\n</sumCosts >\nA related form of sumCosts is defined by using a sequence of elements <values>, where each such element has a required attribute cost that gives the common cost of all values contained inside the element, i.e., whatever the variables are. The optional attribute defaultCost for <sumCosts> is useful for specifying the cost of all implicit values (i.e., those not explicitly listed).\nSyntax 49\n<sumCosts [defaultCost=\"integer\"]>\n<list> (intVar wspace)2+ </list> (<values cost=\"integer\"> (intVal wspace)+ </values>)+ <condition> \"(\" operator \",\" operand \")\" </condition>\n</sumCosts>\nFor the semantics, we assume, for any value ai in the domain of a variable of X, that costV(ai) denotes the cost cost(Vj) of the set Vj such that ai \u2208 Vj .\nSemantics 21\nsumCosts(X,V, ( , k)), with X = \u3008x1, x2, . . .\u3009, and V = \u3008V1, V2, . . .\u3009 where Vi is a set of values of cost cost(Vi), iff\u2211 {costV(xi) : 1 \u2264 i \u2264 [X|} k\nPrerequisite :\n\u2200(i, j) : 1 \u2264 i < j \u2264 |V|, Vi \u2229 Vj = \u2205 \u2200a \u2208 \u222ax\u2208Xdom(x),\u2203Vi \u2208 V : a \u2208 Vi\nThe constraint c3 involves 5 variables v1, v2, v3, v4, v5 in its main list, with 4 values in each domain (let us say {1, 2, 3, 4}). The assignment costs are as follows: 10 for (v1, 2), (v2, 2), . . .,\n67\n(v1, 4), (v2, 4), . . ., and 0 for the other literals. The constraint c3 forces z to be equal to the sum of the assignment costs.\nExample 56\n<sumCosts id=\"c3\" defaultCost=\"0\">\n<list > v1 v2 v3 v4 v5 </list > <values cost=\"10\"> 2 4 </values > <condition > (eq,z) </condition >\n</sumCosts >\nFinally, by replacing the element <list> by an element <set>, we can represent the constraint sum of weights of distinct values [7], where any cost is defined per value and can be taken into account only once.\nSyntax 50\n<sumCosts [defaultCost=\"integer\"]>\n<set> (intVar wspace)2+ </set> (<values cost=\"integer\"> (intVal wspace)+ </values>)+ <condition> \"(\" operator \",\" operand \")\" </condition>\n</sumCosts>\nFor the semantics of this constraint variant, that we refer to as sumCostsset, we assume, for any value ai in the domain of a variable of X, that cost\nV(ai) denotes the cost cost(Vj) of the set Vj such that ai \u2208 Vj .\nSemantics 22\nsumCostsset(X,V, ( , k)), with X = \u3008x1, x2, . . .\u3009, and V = \u3008V1, V2, . . .\u3009 where Vi is a set of values of cost cost(Vi), iff\u2211 {costV(a) : a \u2208 \u222ax\u2208Xdom(x) \u2227 \u2203i : 1 \u2264 i \u2264 [X| \u2227 xi = a} k\nPrerequisite :\n\u2200(i, j) : 1 \u2264 i < j \u2264 |V|, Vi \u2229 Vj = \u2205 \u2200a \u2208 \u222ax\u2208Xdom(x),\u2203Vi \u2208 V : a \u2208 Vi\nRemark 24 We have just seen that turning an element <list> into an element <set> allows us to define a variant for the constraint sumCosts. This principle will be generalized in Chapter 7."}, {"heading": "4.1.5 Connection Constraints", "text": "In this section, we present constraints that establish a connection between different variables. More specifically, we introduce:\n1. maximum\n2. minimum\n68\n3. element\n4. channel\n5. permutation\n6. precedence\n4.1.5.1 Constraint maximum\nThe constraint maximum ensures that the maximum value among those assigned to variables of <list> respects a numerical condition.\nSyntax 51\n<maximum>\n<list> (intVar wspace)2+ </list> <condition> \"(\" operator \",\" operand \")\" </condition>\n</maximum>\nSemantics 23\nmaximum(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff max{xi : 1 \u2264 i \u2264 |X|} k\nIn the following example, the constraint c1 states that max{x1, x2, x3, x4} = y whereas c2 states that max{z1, z2, z3, z4, z5} < w.\nExample 57\n<maximum id=\"c1\">\n<list > x1 x2 x3 x4 </list > <condition > (eq,y) </condition >\n</maximum > <maximum id=\"c2\">\n<list > z1 z2 z3 z4 z5 </list > <condition > (lt,w) </condition >\n</maximum >\nAnother form of maximum, sometimes called arg max, ensures that <index> is the index of a variable in <list> that respect the numerical condition. The optional attribute startIndex of <list> gives the number used for indexing the first variable in <list> (0, by default). The optional attribute rank of <index> indicates if <index> is the first index, the last index or any index of a variable of <list> that respect the numerical condition (\"any\", by default). The element <condition> becomes optional.\n69\nSyntax 52\n<maximum>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <index [rank=\"rankType\"]> intVar </index> [ <condition> \"(\" operator \",\" operand \")\" </condition> ]\n</maximum>\nWe give the semantics for rank=\"any\".\nSemantics 24\nmaximum(X, i), with X = \u3008x1, x2, . . .\u3009, iff // indexing assumed to start at 1 i \u2208 {j : 1 \u2264 j \u2264 |X| \u2227 xj = max{xk : 1 \u2264 k \u2264 |X|}} maximum(X, i, ( , k)) iff maximum(X, i) \u2227 maximum(X, ( , k))\n4.1.5.2 Constraint minimum\nThe constraint minimum ensures that the minimum value among the values assigned to variables in <list> respects a numerical condition.\nSyntax 53\n<minimum>\n<list> (intVar wspace)2+ </list> <condition> \"(\" operator \",\" operand \")\" </condition>\n</minimum>\nSemantics 25\nminimum(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff min{xi : 1 \u2264 i \u2264 |X|} k\nIn the following example, the constraint c1 states that min{x1, x2, x3, x4} = y whereas c2 states that min{z1, z2, z3, z4, z5} 6= w.\nExample 58\n<minimum id=\"c1\">\n<list > x1 x2 x3 x4 </list > <condition > (eq,y) </condition >\n</minimum > <minimum id=\"c2\">\n<list > z1 z2 z3 z4 z5 </list > <condition > (ne,w) </condition >\n</minimum >\nAnother form of minimum, sometimes called arg min, ensures that <index> is the index of the variable in <list> that respect the numerical condition. The optional attribute startIndex\n70\nof <list> gives the number used for indexing the first variable in <list> (0, by default). The optional attribute rank of <index> indicates if <index> is the first index, the last index or any index of a variable of <list> that respect the numerical condition (\"any\", by default). The element <condition> becomes optional.\nSyntax 54\n<minimum>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <index [rank=\"rankType\"]> intVar </index> [ <condition> \"(\" operator \",\" operand \")\" </condition> ]\n</minimum>\nWe give the semantics for rank=\"any\".\nSemantics 26\nminimum(X, i), with X = \u3008x1, x2, . . .\u3009, iff // indexing assumed to start at 1 i \u2208 {j : 1 \u2264 j \u2264 |X| \u2227 xj = min{xk : 1 \u2264 k \u2264 |X|}} minimum(X, i, ( , k)) iff minimum(X, i) \u2227 minimum(X, ( , k))\n4.1.5.3 Constraint element\nThe constraint element [63] ensures that <value> is element of <list>, i.e., equal to one value among those assigned to variables of <list>. The optional attribute startIndex gives the number used for indexing the first variable in <list> (0, by default). The optional element <index> gives the index (position) of one occurrence of <value> inside <list>. The optional attribute rank of <index> indicates if <index> is the first index, the last index or any index of a variable of <list> with the specified value (\"any\", by default).\nSyntax 55\n<element>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> [ <index [rank=\"rankType\"]> intVar </index> ] <value> intVal | intVar </value>\n</element>\nWe give the semantics for rank=\"any\".\nSemantics 27\nelement(X, v), with X = \u3008x1, x2, . . .\u3009, iff // indexing assumed to start at 1 \u2203i : 1 \u2264 i \u2264 |X| \u2227 xi = v element(X, i, v), with X = \u3008x1, x2, . . .\u3009, iff xi = v\nThe following constraint c1 states that the ith variable of \u3008x1, x2, x3, x4\u3009 must be equal to v. For example, if i is equal to 2, then x2 must be equal to v. The constraint c2 ensures that z is element (member) of the 1-dimensional array y.\n71\nExample 59\n<element id=\"c1\">\n<list startIndex=\"1\"> x1 x2 x3 x4 </list > <index > i </index > <value > v </value >\n</element > <element id=\"c2\">\n<list > y[] </list > <value > z </value >\n</element >\n4.1.5.4 Constraint channel\nThe constraint channel ensures that if the ith variable is assigned the value j, then the jth variable must be assigned the value i. The optional attribute startIndex of <list> gives the number used for indexing the first variable in this list (0, by default).\nSyntax 56\n<channel>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list>\n</channel>\nNote that the opening and closing tags of <list> are optional when, of course, the attribute startIndex is not required, which gives:\nSyntax 57\n<channel> (intVar wspace)2+ </channel> // Simplified Form\nSemantics 28\nchannel(X), with X = \u3008x1, x2, . . .\u3009, iff // indexing assumed to start at 1 \u2200i : 1 \u2264 i \u2264 |X|,xi = j \u21d2 xj = i\nNote that it is possible to enforce a stronger form through the restriction \"irreflexive\"; see Section 7.3.\nAnother classical form of channel, sometimes called inverse or assignment, is defined from two separate lists of variables (that must be of same size). It ensures that the value assigned to the ith variable of the first element <list> gives the position of the variable of the second element <list> that is assigned to i, and vice versa. For each list, the optional attribute startIndex gives the number used for indexing the first variable in this list (0, by default).\n72\nSyntax 58\n<channel>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <list [startIndex=\"integer\"]> (intVar wspace)2+ </list>\n</channel>\nSemantics 29\nchannel(X,Y ), with X = \u3008x1, x2, . . .\u3009 and Y = \u3008y1, y2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |X|,xi = j \u21d4 yj = i\nCondition: |X| = |Y | \u2265 2\nExample 60\n<channel id=\"c1\">\n<list > x1 x2 x3 x4 </list > <list > y1 y2 y3 y4 </list >\n</channel >\nAnother form is obtained by considering a list of 0/1 variables to be channeled with an integer variable. This third form of constraint channel ensures that the only variable of <list> that is assigned to 1 is at an index (position) that corresponds to the value assigned to the variable in <value>.\nSyntax 59\n<channel>\n<list [startIndex=\"integer\"]> (01Var wspace)2+ </list> <value> intVar </value>\n</channel>\nSemantics 30\nchannel(X, v), with X = {x1, x2, . . .}, iff // indexing assumed to start at 1 \u2200i : 1 \u2264 i \u2264 |X|,xi = 1\u21d4 v = i \u2203i : 1 \u2264 i \u2264 |X| \u2227 xi = 1\nExample 61\n<channel id=\"c2\">\n<list > z1 z2 z3 z4 z5 </list > <value > v </value >\n</channel >\n73\n4.1.5.5 Constraint permutation\nThe constraint permutation ensures that the tuple of values taken by variables of the second element <list> is a permutation of the tuple of values taken by variables of the first element <list>. In other words, both lists represent the same multi-set. The optional element <mapping> gives for each value of the first tuple its position in the second tuple. If the element <mapping> is present, then it is possible to introduce the optional attribute startIndex that gives the number used for indexing the first variable in the second element <list> (0, by default).\nSyntax 60\n<permutation>\n<list> (intVar wspace)2+ </list> <list [startIndex=\"integer\"]> (intVar wspace)2+ </list> [<mapping> (intVar wspace)2+ </mapping>]\n</permutation>\nSemantics 31\npermutation(X,Y ), with X = \u3008x1, x2, . . .\u3009 and Y = \u3008y1, y2, . . .\u3009, iff {{xi : 1 \u2264 i \u2264 |X|}} = {{yi : 1 \u2264 i \u2264 |Y |}} permutation(X,Y,M), with M = \u3008m1,m2, . . .\u3009, iff permutation(X,Y ) \u2227 \u2200i : 1 \u2264 i \u2264 |X|,xi = ymi \u2227 \u2200(i, j) : 1 \u2264 i < j \u2264 |M |,mi 6= mj\nPrerequisite : |X| = |Y | = |M | \u2265 2\nExample 62\n<permutation id=\"c\">\n<list > x1 x2 x3 x4 </list > <list > y1 y2 y3 y4 </list >\n</permutation >\nThe constraint permutation captures correspondence in the Global Constraint Catalog. For a generalization of permutation, see allEqual on multisets in Section 7.1.2. For a specialization of permutation, where the second list is increasingly sorted, see Section 7.3.\n4.1.5.6 Constraint precedence\nThe constraint precedence, see [74, 136], ensures that if a variable x of <list> is assigned the i+ 1th value of <values>, then another variable of <list>, that precedes x, is assigned the ith value of <values> The optional attribute covered indicates whether each value of <values> must be assigned by at least one variable in <list> (\"false\", by default). It is also possible to reverse the order by specifying the relational operator in the optional element <operator> (lt, by default).\n74\nSyntax 61\n<precedence>\n<list> (intVar wspace)2+ </list> <values [covered=\"boolean\"]> (intVal wspace)2+ </values> [<operator> \"lt\" | \"gt\" </operator>]\n</precedence>\nFor the semantics, V cv means covered=\"true\".\nSemantics 32\nprecedence(X,V, ), with X = \u3008x1, x2, . . .\u3009, V = \u3008v1, v2, . . .\u3009, and \u2208 {<,>} iff \u2200i : 1 \u2264 i < |V |, vi+1 \u2208 {xi : 1 \u2264 i \u2264 |X|} \u21d2 vi \u2208 {xi : 1 \u2264 i \u2264 |X|} \u2200i : 1 \u2264 i < |V | \u2227 vi+1 \u2208 {xi : 1 \u2264 i \u2264 |X|},\nmin{j : 1 \u2264 j \u2264 |X| \u2227 xj = vi} min{j : 1 \u2264 j \u2264 |X| \u2227 xj = vi+1} precedence(X,V cv , ) iff precedence(X,V, ) \u2227 v|V | \u2208 {xi : 1 \u2264 i \u2264 |X|}\nExample 63\n<precedence >\n<list > x1 x2 x3 x4 </list > <values > 4 0 1 </values >\n</precedence >\nThe constraint precedence captures int value precede and int value precede chain in the Global Constraint Catalog."}, {"heading": "4.1.6 Packing and Scheduling Constraints", "text": "In this section, we present constraints that are useful in packing and scheduling problems. More specifically, we introduce:\n1. stretch\n2. noOverlap (capturing disjunctive and diffn)\n3. cumulative (capturing cumulatives too)\n4. binPacking\n5. knapsack\n6. networkFlow\n4.1.6.1 Constraint stretch\nThe constraint stretch [95] aims at grouping values in sequences. Each stretch is a maximal subsequence with the same value over the list of variables in <list>. Each stretch must have a width compatible with the corresponding interval specified in <widths>. The optional element <patterns> gives the possible successive values between stretches.\n75\nSyntax 62\n<stretch>\n<list> (intVar wspace)2+ </list> <values> (intVal wspace)+ </values> <widths> (intIntvl wspace)+ </widths> [<patterns> (\"(\" intVal \",\" intVal \")\")+ </patterns>]\n</stretch>\nGiven a sequence of variables X = \u3008x1, x2, . . .\u3009, and a value assigned to each of these variables, we define as stretches(X) the set of stretches over X, each one being identified by a pair (vk, i..j) composed of the value vk of the stretch and the interval i..j of the indexes of the variables composing the stretch.\nSemantics 33\nstretch(X,V,W ), with X = \u3008x1, x2, . . .\u3009, V = \u3008v1, v2, . . .\u3009, W = \u3008l1..u1, l2..u2, . . .\u3009, iff \u2200(vk, i..j) \u2208 stretches(X), lk \u2264 j \u2212 i+ 1 \u2264 uk\nstretch(X,V,W,P ) iff\nstretch(X,V,W ) \u2227 \u2200i : 1 \u2264 i < |X|,xi 6= xi+1 \u21d2 (xi,xi+1) \u2208 P\nPrerequisite : |V | = |W |\nAlthough the section is devoted to integer variables, we give an example with symbolic values, as this is a straightforward adaptation.\nExample 64\n<stretch >\n<list > x1 x2 x3 x4 x5 x6 x7 </list > <values > morning afternoon night off </values > <widths > 1..3 1..3 2..3 2..4 </widths >\n</stretch >\nRemark 25 In the future, we might authorize longer forms of patterns.\n4.1.6.2 Constraint noOverlap\nWe start with the one dimensional form of noOverlap [65] that corresponds to disjunctive [30] and ensures that some tasks, defined by their origins and durations (lengths), must not overlap. The attribute zeroIgnored is optional (\"true\", by default); when set to \"false\", it indicates that zero-length tasks cannot be packed anywhere (cannot overlap with other tasks).\nSyntax 63\n<noOverlap [zeroIgnored=\"boolean\"] >\n<origins> (intVar wspace)2+ </origins> <lengths> (intVal wspace)2+ | (intVar wspace)2+ </lengths>\n</noOverlap>\n76\nThe semantics is given for zeroIgnored=\"false\".\nSemantics 34\nnoOverlap(X,L), with X = \u3008x1, x2, . . .\u3009 and L = \u3008l1, l2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X|,xi + li \u2264 xj \u2228 xj + lj \u2264 xi\nPrerequisite : |X| = |L| \u2265 2\nExample 65\n<noOverlap >\n<origins > x1 x2 x3 </origins > <lengths > l1 l2 l3 </lengths >\n</noOverlap >\nThe k-dimensional form of noOverlap corresponds to diffn [8] and ensures that, given a set of n-dimensional boxes; for any pair of such boxes, there exists at least one dimension where one box is after the other, i.e., the boxes do not overlap. The attribute zeroIgnored is optional (\"true\", by default); when set to \"false\", it indicates that zero-width boxes cannot be packed anywhere (cannot overlap with other boxes).\nSyntax 64\n<noOverlap [zeroIgnored=\"boolean\"]>\n<origins> (\"(\" intVar (\",\" intVar)+ \")\")2+ </origins> <lengths>\n(\"(\" intVal (\",\" intVal)+ \")\")2+ | (\"(\" intVar (\",\" intVar)+ \")\")2+\n</lengths>\n</noOverlap>\nThe semantics is given for zeroIgnored=\"false\".\nSemantics 35\nnoOverlap(X ,L), with X = \u3008(x1,1, . . . , x1,n), (x2,1, . . . , x2,n), . . .\u3009 and L = \u3008(l1,1, . . . , l1,n), (l2,1, . . . , l2,n), . . .\u3009, iff\n\u2200(i, j) : 1 \u2264 i < j \u2264 |X |,\u2203k \u2208 1..n : xi,k + li,k \u2264 xj,k \u2228 xj,k + lj,k \u2264 xi,k\nPrerequisite : |X | = |L| \u2265 2\nThe following constraint enforces that all four 3-dimensional specified boxes do not overlap. The first box has origin (x1, y1, z1) and length (2, 4, 1), meaning that this box is situated from x1 to x1 + 2 on x-axis, from y1 to y1 + 4 on y-axis, and from z1 to z1 + 1 on z-axis.\n77\nExample 66\n<noOverlap >\n<origins > (x1,y1,z1)(x2,y2,z2)(x3,y3,z3)(x4,y4,z4) </origins > <lengths > (2,4,1)(4,2,3)(5,1,2)(3,3,2) </lengths >\n</noOverlap >\n4.1.6.3 Constraint cumulative\nHere, we have a collection of tasks, each one described by 4 attributes: origin, length, end and height. In XCSP3, the element <ends> is optional. The constraint cumulative [1] enforces that at each point in time, the cumulated height of tasks that overlap that point, respects a numerical condition. When the operator \u201cle\u201d is used, this corresponds to not exceeding a given limit.\nSyntax 65\n<cumulative>\n<origins> (intVar wspace)2+ </origins> <lengths> (intVal wspace)2+ | (intVar wspace)2+ </lengths> [<ends> (intVar wspace)2+ </ends>] <heights> (intVal wspace)2+ | (intVar wspace)2+ </heights> <condition> \"(\" operator \",\" operand \")\" </condition>\n</cumulative>\nSemantics 36\ncumulative(X,L,H, ( , k)), with X = \u3008x1, x2, . . .\u3009, L = \u3008l1, l2, . . .\u3009, H = \u3008h1, h2, . . .\u3009, iff \u2200t \u2208 N, \u2211 {hi : 1 \u2264 i \u2264 |H| \u2227 xi \u2264 t < xi + li} k\nPrerequisite : |X| = |L| = |H| \u2265 2\nIf the element <ends> is present, for the semantics, we have additionally that:\n\u2200i : 1 \u2264 i \u2264 |X|,xi + li = ei\nExample 67\n<cumulative >\n<origins > s1 s2 s3 s4 </origins > <lengths > l1 l2 l3 l4 </lengths > <heights > h1 h2 h3 h4 </heights > <condition > (le ,4) </condition >\n</cumulative >\nA refined form of cumulative corresponds to the constraint sometimes called cumulatives [5]. We have a set of available machines (resources), with their respective numerical conditions in <conditions>, which replaces <condition>, through a sequence of pairs composed of an operator and an operand. Each task is thus performed by a machine, which is given in an\n78\nelement <machines>. For each machine, the cumulated height of tasks that overlap a time point for this machine must respect the numerical (capacity) condition associated with the machine. The optional attribute startIndex gives the number used for indexing the first numerical condition (and so, the first machine) in this list (0, by default).\nSyntax 66\n<cumulative>\n<origins> (intVar wspace)2+ </origins> <lengths> (intVal wspace)2+ | (intVar wspace)2+ </lengths> [ <ends> (intVar wspace)2+ </ends> ] <heights> (intVal wspace)2+ | (intVar wspace)2+ </heights> <machines> (intVar wspace)2+ </machines> <conditions [startIndex=\"integer\"]>\n(\"(\" operator \",\" operand \")\")2+\n</conditions>\n</cumulative>\nSemantics 37\ncumulative(X,L,H,M,C), with X = \u3008x1, x2, . . .\u3009, L = \u3008l1, l2, . . .\u3009, H = \u3008h1, h2, . . .\u3009, M = \u3008m1,m2, . . .\u3009, and C = \u3008( 1, k1), ( 2, k2), . . .\u3009 iff\n\u2200m \u2208 {mi : 1 \u2264 i \u2264 |M |},\u2200t \u2208 N : \u22031 \u2264 i \u2264 |H| : xi \u2264 t < xi + li \u2227mi = m,\u2211 {hi : 1 \u2264 i \u2264 |H| \u2227 xi \u2264 t < xi + li \u2227mi = m} m km\nPrerequisite : |X| = |L| = |H| = |M | \u2265 2\n4.1.6.4 Constraint binPacking\nThe constraint binPacking [123, 118, 29] ensures that a list of items, whose sizes are given, are put in different bins in such a way that the total size of the items in each bin respects a numerical condition (always the same, because the capacity is assumed to be the same for all bins). When the operator \u201cle\u201d is used, this corresponds to not exceeding the capacity of each bin.\nSyntax 67\n<binPacking>\n<list> (intVar wspace)2+ </list> <sizes> (intVal wspace)2+ </sizes> <condition> \"(\" operator \",\" operand \")\" </condition>\n</binPacking>\n79\nSemantics 38\nbinPacking(X,S, ( , k)), with X = \u3008x1, x2, . . .\u3009 and S = \u3008s1, s2, . . .\u3009, iff \u2200b \u2208 {xi : 1 \u2264 i \u2264 |X|}, \u2211 {si : 1 \u2264 i \u2264 |S| \u2227 xi = b} k\nPrerequisite : |X| = |S| \u2265 2\nExample 68\n<binPacking id=\"c1\">\n<list > x1 x2 x3 x4 x5 </list > <sizes > 25 53 38 41 32 </sizes > <condition > (le ,100) </condition >\n</binPacking >\nIn another form of binPacking, a specific numerical condition is associated with each available bin. The element <condition> is replaced by an element <conditions>. The optional attribute startIndex gives the number used for indexing the first numerical condition (and so, the first bin) in this list (0, by default).\nSyntax 68\n<binPacking>\n<list> (intVar wspace)2+ </list> <sizes> (intVal wspace)2+ </sizes> <conditions [startIndex=\"integer\"]>\n(\"(\" operator \",\" operand \")\")2+\n</conditions>\n</binPacking>\nFor the semantics, we assume that startIndex=\"1\".\nSemantics 39\nbinPacking(X,S,C), with X = \u3008x1, x2, . . .\u3009, S = \u3008s1, s2, . . .\u3009, and C = \u3008( 1, k1), ( 2, k2), . . .\u3009, iff \u2200b : 1 \u2264 b \u2264 |C|, \u2211 {si : 1 \u2264 i \u2264 |S| \u2227 xi = b} b kb\nPrerequisite : |X| = |S| \u2265 2 \u2227 |C| \u2265 2\nThe constraint c2 involves 7 items and 3 bins. Here, the variables l1, l2 and l3 are used to denote loads (since the operator is systematically \u201ceq\u201d).\nExample 69\n<binPacking id=\"c2\">\n<list > y1 y2 y3 y4 y5 y6 y7 </list > <sizes > 12 7 21 36 19 22 30 </sizes > <conditions > (eq,l1)(eq,l2)(eq,l3) </conditions >\n</binPacking >\n80\n4.1.6.5 Constraint knapsack\nThe constraint knapsack [47, 121, 87] ensures that some items are packed in a knapsack with certain weight and profit restrictions.\nSyntax 69\n<knapsack>\n<list> (intVar wspace)2+ </list> <weights> (intVal wspace)2+ </weights> <profits> (intVal wspace)2+ </profits> <limit> intVal | intVar </limit> <condition> \"(\" operator \",\" operand \")\" </condition>\n</knapsack>\nSemantics 40\nknapsack(X,W,P,w, ( , k)), with X = \u3008x1, x2, . . .\u3009, W = \u3008w1, w2, . . .\u3009, and P = \u3008p1, p2, . . .\u3009, iff\u2211|X|\ni=1(wi \u00d7 xi) \u2264 w\u2211|X| i=1(pi \u00d7 xi) k\nPrerequisite : |X| = |W | = |P | \u2265 2\n4.1.6.6 Constraint networkFlow\nThe constraint networkFlow ensures that there is a valid flow in a graph. The flow of each arc and the balance (difference between input and output flows) of each node are given by elements <list> and <balance>, respectively. Optionally, a unit weight can be associated with each, arc, and the total cost must then be related to the overall cost of the flow by a numerical condition. Also, there can be an element <capacities> that give lower and upper capacities of each arc.\nSyntax 70\n<networkFlow>\n<list> (intVar wspace)2+ </list> <balance> (intVal wspace)2+ | (intVar wspace)2+ </balance> <arcs> (\"(\" node \",\" node \")\")2+ </arcs> [<capacities> (intIntvl wspace)2+ </capacities>] [\n<weights> (intVal wspace)2+ | (intVar wspace)2+ </weights> <condition> \"(\" operator \",\" operand \")\" </condition>\n]\n</networkFlow>\nFor the semantics, considering the graph defined by <arcs>, for any node v, \u0393+(v) denotes the set of arcs (of this graph) with head v and \u0393\u2212(v) denotes the set of arcs with tail v.\n81\nSemantics 41\nnetworkFlow(X,B,A), with X = \u3008x1, x2, . . .\u3009, B = \u3008b1, b2, . . .\u3009, A = \u3008a1, a2, . . .\u3009, iff for any node v, \u2211 {xi : 1 \u2264 i \u2264 |X| \u2227 ai \u2208 \u0393\u2212(v)} \u2212 \u2211 {xi : 1 \u2264 i \u2264 |X| \u2227 ai \u2208 \u0393+(v)} = bi networkFlow(X,B,A,C), with C = \u3008l1..u1, l2..u2, . . .\u3009, iff networkFlow(X,B,A) \u2227 \u2200i : 1 \u2264 i \u2264 |X|,xi \u2208 li..ui networkFlow(X,B,A,C,W, ( , k)), with W = \u3008w1, w2, . . .\u3009, iff networkFlow(X,B,A,C) \u2227 \u2211 {xi \u00d7 wi : 1 \u2264 i \u2264 |X|} k\nPrerequisite : |X| = |A| = |C| = |W |"}, {"heading": "4.1.7 Constraints on Graphs", "text": "In this section, we present constraints that are defined on graphs using integer variables (encoding called \u201csuccessors variables\u201d). We introduce:\n1. circuit\n2. nCircuits\n3. path\n4. nPaths\n5. tree\n6. nTrees\nFor all these constraints, we have an element <list> that contains variables x1, x2, . . . The assumption is that each pair (i,xi) represents an arc (or edge) of the graph to be built; if xi = j, then it means that the successor of node i is node j. Note that a loop (also called self-loop) corresponds to a variable xi such that xi = i; it is isolated if there is no variable xj with j 6= i such that xj = i.\n4.1.7.1 Constraint circuit\nThe constraint circuit [8] ensures that the values taken by the variables in <list> forms a circuit, with the assumption that each pair (i,xi) represents an arc. The optional attribute startIndex of <list> gives the number used for indexing the first variable/node in <list> (0, by default). The optional element size indicates that the circuit must be of a given size (strictly greater than 1).\nIt is important to note that the circuit is not required to cover all nodes (the nodes that are not present in the circuit are then self-looping). Hence circuit, with loops being simply ignored, basically represents subcircuit (e.g., in MiniZinc). If ever you need a full circuit (i.e., without any loop), you have three solutions:\n\u2022 indicate in size the number of variables \u2022 initially define the variables without the self-looping values, \u2022 post unary constraints.\n82\nSyntax 71\n<circuit>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> [<size> intVal | intVar </size>]\n</circuit>\nNote that the opening and closing tags of <list> are optional if <list> is the unique parameter of the constraint and the attribute startIndex is not necessary, which gives:\nSyntax 72\n<circuit> (intVar wspace)2+ </circuit> // Simplified Form\nSemantics 42\ncircuit(X), with X = \u3008x1, x2, . . .\u3009, iff // capture subscircuit {(i,xi) : 1 \u2264 i \u2264 |X| \u2227 i 6= xi} forms a circuit of size > 1 circuit(X, z), with X = \u3008x1, x2, . . .\u3009, iff {(i,xi) : 1 \u2264 i \u2264 |X| \u2227 i 6= xi} forms a circuit of size z > 1\nIn the following example, the constraint states that \u3008x0, x1, x2, x3\u3009 must form a single circuit \u2013 for example, with \u3008x0,x1,x2,x3\u3009 = \u30081, 2, 3, 0\u3009, or a subcircuit \u2013 for example, with \u3008x0,x1,x2,x3\u3009 = \u30081, 2, 0, 3\u3009.\nExample 70\n<circuit >\nx0 x1 x2 x3\n</circuit >\nNote that it is possible to capture the variant of circuit in Gecode that involves a cost matrix. It suffices to logically combine circuit and sumCosts as shown in Section 8.4.\n4.1.7.2 Constraint nCircuits\nOne may be interested in building more than one circuit. For constraint nCircuits, the number of circuits obtained after instantiating variables of <list> must respect a numerical condition. In the literature, this variant with k > 1 circuits is called cycle. The optional attribute countLoops indicates whether or not loops must be considered as circuits (\"true\", by default).\nSyntax 73\n<nCircuits [countLoops=\"boolean\"]>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <condition> \"(\" operator \",\" operand \")\" </condition>\n</nCircuits>\n83\nSemantics 43\nnCircuits(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff {(i,xi) : 1 \u2264 i \u2264 |X|} forms p node-disjoint circuits s.t. p k\nRemark 26 It is always possible to avoid having self-loops as circuits, by combining circuits with a set of unary constraints.\nBelow, the constraint states that \u3008y0, y1, y2, y3, y4\u3009 must form two disjoint circuits \u2013 for example, with \u3008y0,y1,y2,y3,y4\u3009 = \u30081, 0, 4, 2, 3\u3009.\nExample 71\n<nCircuits >\n<list > y0 y1 y2 y3 y4 </list > <condition > (eq ,2) </condition >\n</nCircuits >\n4.1.7.3 Constraint path\nThe constraint path ensures that the values taken by the variables in <list> forms a path from the node specified in <start> to the node specified in <final>, with the assumption that each pair (i,xi) represents an arc. The optional attribute startIndex of <list> gives the number used for indexing the first variable/node in <list> (0, by default). The successor of the final node is necessary itself (self-loop). The optional element size indicates that the path must be of a given size.\nIt is important to note that the path is not required to cover all nodes (the nodes that are not present in the path are then self-looping). Hence path, with loops being simply ignored, basically represents subpath (e.g., in Choco3). If ever you need a full path (i.e., without any loop other than the final node), you have three solutions:\n\u2022 indicate in size the number of variables \u2022 initially define the variables without the self-looping values, \u2022 post unary constraints.\nSyntax 74\n<path>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <start> intVal | intVar </start> <final> intVal | intVar </final> [<size> intVal | intVar </size>]\n</path>\n84\nSemantics 44\npath(X, s, f), with X = \u3008x1, x2, . . .\u3009, iff // capture subspath {(i,xi) : 1 \u2264 i \u2264 |X| \u2227 i 6= xi} forms a path from s to f path(X, s, f, z), with X = \u3008x1, x2, . . .\u3009, iff {(i,xi) : 1 \u2264 i \u2264 |X| \u2227 i 6= xi} forms a path from s to f of size z\nIn the following example, the constraint states that \u3008x0, x1, x2, x3\u3009 must form a path from s to f \u2013 for example, \u3008x0,x1,x2,x3\u3009 = \u30080, 0, 3, 1\u3009 with s = 2 and f = 0 satisfies the constraint.\nExample 72\n<path >\n<list > x0 x1 x2 x3 </list > <start > s </start > <final > f </final >\n</path >\n4.1.7.4 Constraint nPaths\nThe constraint nPaths ensures that the number of paths formed after instantiating variables of <list> must respect a numerical condition. The optional attribute countLoops indicates whether or not isolated loops must be considered as paths (\"true\", by default).\nSyntax 75\n<nPaths [countLoops=\"boolean\"]>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <condition> \"(\" operator \",\" operand \")\" </condition>\n</nPaths>\nSemantics 45\nnPaths(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff {(i,xi) : 1 \u2264 i \u2264 |X|} forms p node-disjoint paths s.t. p k\nThe constraint c states that \u3008y0, y1, . . . , y7\u3009 must form k disjoints paths \u2013 for example, \u3008y0,y1, . . . ,y7\u3009 = \u30080, 2, 4, 6, 0, 5, 6, 5\u3009 with k = 3.\nExample 73\n<nPaths id=\"c\">\n<list > y0 y1 y2 y3 y4 y5 y6 y7 </list > <condition > (eq,k) </condition >\n</nPaths >\n85\n4.1.7.5 Constraint tree\nThe constraint tree [9, 46] ensures that the values taken by variables in <list> forms an antiarborescence (covering all nodes) whose root is specified by <root>, with the assumption that each pair (i,xi) represents an arc (with such representation, we do obtain an anti-arborescence). The optional attribute startIndex of <list> gives the number used for indexing the first variable/node in <list> (0, by default). The successor of the root node is necessarily itself (self-loop). The optional element size indicates that the anti-arborescence must be of a given size.\nIt is important to note that the anti-arborescence is not required to cover all nodes (the nodes that are not present in the anti-arborescence are then self-looping). Hence tree, with loops being simply ignored, basically represents subtree. If ever you need a full anti-arborescence (i.e., without any loop other than the root node), you have three solutions:\n\u2022 indicate in size the number of variables \u2022 initially define the variables without the self-looping values, \u2022 post unary constraints.\nSyntax 76\n<tree>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <root> intVal | intVar </root> [<size> intVal | intVar </size>]\n</tree>\nSemantics 46\ntree(X, r), with X = \u3008x1, x2, . . .\u3009, iff {(i,xi) : 1 \u2264 i \u2264 |X| \u2227 i 6= xi} forms an anti-arborescence of root r. tree(X, r, z), with X = \u3008x1, x2, . . .\u3009, iff {(i,xi) : 1 \u2264 i \u2264 |X| \u2227 i 6= xi} forms an anti-arborescence of root r and size z\nIn the following example, the constraint states that \u3008x0, x1, x2, x3\u3009 must form an antiarborescence of root r \u2013 for example, \u3008x0,x1,x2,x3\u3009 = \u30081, 3, 3, 3\u3009 with r = 3 satisfies the constraint.\nExample 74\n<tree >\n<list > x0 x1 x2 x3 </list > <root > r </root >\n</tree >\n4.1.7.6 Constraint nTrees\nThe constraint nTrees ensures that the number of anti-arborescences formed after instantiating variables in <list> must respect a numerical condition. The optional attribute countLoops indicates whether or not isolated loops must be considered as trees (\"true\", by default).\n86\nSyntax 77\n<nTrees [countLoops=\"boolean\"]>\n<list> (intVar wspace)2+ </list> <condition> \"(\" operator \",\" operand \")\" </condition>\n</nTrees>\nSemantics 47\nnTrees(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff {(i,xi) : 1 \u2264 i \u2264 |X|} forms p disjoint anti-arborescences s.t. p k\nThe constraint c states that \u3008y0, y1, . . . , y7\u3009 must form k node-disjoints anti-arborescences \u2013 for example, \u3008y0,y1, . . . ,y7\u3009 = \u30080, 4, 4, 6, 0, 0, 6, 4\u3009 with k = 2.\nExample 75\n<nTrees id=\"c\">\n<list > y0 y1 y2 y3 y4 y5 y6 y7 </list > <condition > (eq,k) </condition >\n</nTrees >"}, {"heading": "4.1.8 Elementary Constraints", "text": "In this section, we present some elementary constraints that are frequently encountered. We introduce:\n1. clause\n2. instantiation\n4.1.8.1 Constraint clause\nThe constraint clause represents a disjunction of literals, put in an element <list>, where a literal is either a 0/1 variable (serving as a Boolean variable) or its negation. The negation of a variable x is simply written not(x).\nSyntax 78\n<clause>\n<list> ((01Var | \"not(\"01Var\")\") wspace)+ </list>\n</clause>\nNote that the opening and closing tags of <list> are optional, which gives:\nSyntax 79\n<clause> ((01Var | \"not(\"01Var\")\") wspace)+ </clause> // Simplified Form\n87\nSemantics 48\nclause(L) iff\n\u2203x \u2208 L : x = 1 \u2228 \u2203\u00acx \u2208 L : x = 0\nIn the following example, the constraint states that x0 \u2228 \u00acx1 \u2228 x2 \u2228 x3 \u2228 \u00acx4\nExample 76\n<clause >\nx0 not(x1) x2 x3 not(x4)\n</clause >\n4.1.8.2 Constraint instantiation\nThe constraint instantiation represents a set of unary constraints corresponding to variable assignments. There are three main interests in introducing it. First, when modeling, rather often we need to instantiate a subset of variables (for example, for taking some hints/clues into consideration, or for breaking some symmetries). It is simpler, more natural and informative to post a constraint instantiation than a set of unary constraints intension. Second, instantiations can be used to represent partial search instantiations that can be directly injected into XCSP3 instances. Third, instantiations allow us to represent solutions, as explained in Section 2.11, having this way the output of the format made compatible with the input.\nThe constraint instantiation ensures that the ith variable x of <list> is assigned the ith value of <values>. Every variable can only occur once in <list>.\nSyntax 80\n<instantiation>\n<list> (intVar wspace)+ </list> <values> (intVal wspace)+ </values>\n</instantiation>\nSemantics 49\ninstantiation(X,V ), with X = \u3008x1, . . . , xr\u3009 and V = \u3008v1, . . . , vr\u3009 iff \u2200i : 1 \u2264 i < |X|, xi = vi\nIn our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.\n88\nExample 77\n<instantiation >\n<list > x y z </list > <values > 12 4 30 </values >\n</instantiation > <instantiation >\n<list > w[] </list > <values > 1 0 2 1 3 1 </values >\n</instantiation >\nRemark 27 The constraint instantiation is a generalization of the constraint cube used in the SAT community when dealing with DNF (Disjunctive Normal Form) expressions.\nRemark 28 The attributes coming with the element <instantiation> when used to represent a solution (see Section 2.11) are simply ignored (and tolerated) when a solution is injected in the input."}, {"heading": "4.2 Constraints over Symbolic Variables", "text": "Many constraints introduced above for integer variables can be used with symbolic variables. Basically, this is always when no arithmetic computation is involved. In the current version of this document, we shall not list exhaustively all such cases.\nWe just give an illustration of an extensional constraint involving three symbolic variables of domain {a, b, c}.\nExample 78\n<extension id=\"c1\">\n<list > x1 x2 x3 </list > <supports > (a,b,a)(b,a,c)(b,c,b)(c,a,b) </supports >\n</extension >\n89\n5 Constraints over Complex\nDiscrete Variables\nIn this chapter, we introduce constraints over complex discrete variables, namely, set and graph variables. We shall use the terms setVar and graphVar to denote respectively a set and a graph variable. These terms as well as related ones, like for example, setVal, are defined in Appendix B."}, {"heading": "5.1 Constraints over Set Variables", "text": "We first introduce constraints over set variables per family, as indicated by Figure 5.1. In what follows, set variables are denoted by lowercase letters s, t, possibly subscripted. For sequences of set variables, we use uppercase letters S, T , possibly subscripted, as e.g., S = \u3008s1, s2, . . .\u3009. For sequences of sequences of set variables, we use uppercase letters S, T in mathcal font, as e.g., S = \u3008S1, S2, . . .\u3009.\n5.1.1 Generic Constraints\n5.1.1.1 Constraint intension\nUnsurprisingly, a constraint intension defined on set variables is built similarly to a constraint intension defined on integer variables. Simply, some additional operators are available. They are given by Table 5.1 that shows the specific operators that can be used to build predicates with set operands. Of course, it is possible to combine such operators with those presented for integers (and Booleans) in Table 4.1. Note that the operators on convexity are used in Gecode.\nAn intensional constraint is defined by an element <intension>, containing an element <function> that describes the functional representation of the predicate, referred to as boolExprSet in the syntax box below, and whose precise syntax is given in Appendix B.\n90\nSyntax 81\n<intension>\n<function> boolExprSet </function>\n</intension>\nNote that the opening and closing tags for <function> are optional, which gives:\nSyntax 82\n<intension> boolExprSet </intension> // Simplified Form\nIn the following example, the constraints c1 and c2 are respectively defined by |s| = 2 and t1 \u222a t2 \u2282 t3, with s, t1, t2 and t3 being set variables.\n91\nExample 79\n<intension id=\"c1\">\neq(card(s) ,2)\n</intension > <intension id=\"c2\">\nsubset(union(t1 ,t2),t3)\n</intension >\n5.1.2 Comparison-based Constraints\n5.1.2.1 Constraint allDifferent\nSuch constraints are similar to those described earlier for integer variables, but set variables/values simply replace integer variables/values.\nSyntax 83\n<allDifferent>\n<list> (setVar wspace)2+ </list> [<except> setVal+ </except>]\n</allDifferent>\n92\nNote that the opening and closing tags for <list> are optional, if <except> is not present, which gives:\nSyntax 84\n<allDifferent> (setVar wspace)2+ </allDifferent> // Simplified Form\nExample 80\n<allDifferent id=\"c1\">\ns1 s2 s3\n</allDifferent > <allDifferent id=\"c2\">\n<list > t1 t2 t3 t4 </list > <except > {} </except >\n</allDifferent >\n5.1.2.2 Constraint allEqual\nSuch constraints are similar to those described earlier for integer variables, but set variables simply replace integer variables.\nSyntax 85\n<allEqual>\n<list> (setVar wspace)2+ </list>\n</allEqual>\nNote that the opening and closing tags for <list> are optional, which gives:\nSyntax 86\n<allEqual> (setVar wspace)2+ </allEqual> // Simplified Form\nExample 81\n<allEqual id=\"c\">\ns1 s2 s3 s4\n</allEqual >\n5.1.2.3 Constraint allIntersecting\nThe constraint allIntersecting ensures that each pair of set variables in <list> intersects in a number of elements that respects a numerical condition. It captures for example at most1 in MiniZinc, with operator le and value 1.\n93\nSyntax 87\n<allIntersecting>\n<list> (setVar wspace)2+ </list> <condition> \"(\" operator \",\" operand \")\" </condition>\n</allIntersecting>\nSemantics 50\nallIntersecting(S, ( , k)), with S = \u3008s1, s2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |S|, |si \u2229 sj | k\nIn the following example, the constraints c1 states that |s1\u2229s2| = k\u2227|s1\u2229s3| = k\u2227|s2\u2229s3| = k, whereas the constraint c2 states that |t1 \u2229 t2| \u2264 1 \u2227 |t1 \u2229 t3| \u2264 1 \u2227 |t2 \u2229 t3| \u2264 1.\nExample 82\n<allIntersecting id=\"c1\">\n<list > s1 s2 s3 </list > <condition > (eq,k) </condition >\n</allIntersecting > <allIntersecting id=\"c2\">\n<list > t1 t2 t3 </list > <condition > (le ,1) </condition >\n</allIntersecting >\nWe propose to identify two cases of allIntersecting over set variables, corresponding to the case where all sets must be disjoint (value \"disjoint\" for case) and the case where all sets must be overlapping (value \"overlapping\" for case). For both cases, the element <condition> becomes implicit. The two following constraints c3 and c4:\nExample 83\n<allIntersecting id=\"c3\">\n<list > s1 s2 s3 </list > <condition > (gt ,0) </condition >\n</allIntersecting > <allIntersecting id=\"c4\">\n<list > t1 t2 t3 t4 </list > <condition > (eq ,0) </condition >\n</allIntersecting >\ncan then be defined by:\n94\nExample 84\n<allIntersecting id=\"c3\" case=\"disjoint\">\ns1 s2 s3\n</allIntersecting > <allIntersecting id=\"c4\" case=\"overlapping\">\nt1 t2 t3 t4\n</allIntersecting >\n5.1.2.4 Constraint ordered\nAs for the constraint ordered-set (i.e., the constraint ordered lifted to sets), we consider the inclusion order for sets: the operators that can be used are among {\u2282,\u2286,\u2287,\u2283}. This gives:\nSyntax 88\n<ordered>\n<list> (setVar wspace)2+ </list> <operator> \"subset\" | \"subseq\" | \"supseq\" | \"supset\" </operator>\n</ordered>\nSemantics 51\nordered(S, ), with S = \u3008s1, s2, . . .\u3009 and \u2208 {\u2282,\u2286,\u2287,\u2283}, iff \u2200i : 1 \u2264 i < |S|, si si+1\nThis captures increasing (subsetEq in Choco3) and decreasing, as illustrated below respectively with constraints c1 and c2.\nExample 85\n<ordered id=\"c1\">\n<list > s1 s2 s3 </list > <operator > subseq </operator >\n</ordered > <ordered id=\"c2\">\n<list > t1 t2 t3 t4 t5 </list > <operator > supseq </operator >\n</ordered >\nA second form of ordered uses an underlying ordering based either on bounds or on indicator (characteristic) functions. In the former case, the ordering bnd is defined as:\ns bnd t iff max(s) \u2264 min(t).\nIn the latter case, the ordering ind is defined as follows: s ind t iff s = \u2205\u2228 t 6= \u2205\u2227 (min(s) < min(t)\u2228min(s) = min(t)\u2227s\\{min(s)} ind t\\{min(t)})\nThe attribute order is required here, with either the value \"bnd\" or the value \"ind\".\n95\nSyntax 89\n<ordered order=\"bnd|ind\">\n<list> (setVar wspace)2+ </list> <operator> \"lt\" | \"le\" | \"ge\" | \"gt\" </operator>\n</ordered>\nFor the semantics, orderedbnd and orderedind correspond to versions of ordered, with order set to \"bnd\" and \"ind\", respectively.\nSemantics 52\norderedbnd(S, ), with S = \u3008s1, s2, . . .\u3009 and \u2208 {<,\u2264,\u2265, >}, iff \u2200i : 1 \u2264 i < |S|,max(si) min(si+1) orderedind(S, ), with S = \u3008s1, s2, . . .\u3009 and \u2208 {<,\u2264,\u2265, >}, iff \u2200i : 1 \u2264 i < |S|, si ind si+1\nThe constraint with type \"bnd\" captures sequence of Gecode. The constraint ordered over set variables can be of course lifted to other structures like lists and sets. We show this on lists (sequences) of set variables, capturing lex defined in MiniZinc. The lexicographic order can rely on bnd or ind. For example, for ind, we have:\nS = \u3008s1, s2, . . . , sk\u3009 ind T = \u3008t1, t2, . . . tk\u3009 iff S = \u3008\u3009 \u2228 T 6= \u3008\u3009 \u2227 (s1 \u227aind t1 \u2228 s1 = t1 \u2227 \u3008s2, . . . , sk\u3009 ind \u3008t2, . . . tk\u3009).\nSyntax 90\n<ordered order=\"bnd|ind\">\n(<list> (setVar wspace)+ </list>)2+ <operator> \"lt\" | \"le\" | \"ge\" | \"gt\" </operator>\n</ordered>\nSemantics 53\norderedind(S, ), with S = \u3008S1, S2, . . .\u3009 and \u2208 {<,\u2264,\u2265, >}, iff \u2200i : 1 \u2264 i < |S|, Si ind Si+1\nConditions: |S| > 1\n5.1.3 Counting Constraints\n5.1.3.1 Constraint sum\nThe constraint sum ensures that the sum of coefficients in <coeffs> indexes by values present in <index> respects a numerical condition.\n96\nSyntax 91\n<sum>\n<index> setVar </index> <coeffs [startIndex=\"integer\"]> (intVal wspace)+ </coeffs> <condition> \"(\" operator \",\" operand \")\" </condition>\n</sum>\nSemantics 54\nsum(s, C, ( , k)), with C = \u3008c1, c2, . . .\u3009, iff\u2211 {ci : 1 \u2264 i \u2264 |C| \u2227 i \u2208 s} k\nThis constraint captures sum set in the catalog, sum in Choco3 and weights in Gecode.\nExample 86\n<sum >\n<index > s </index > <coeffs > 4 2 3 2 7 </coeffs > <condition > (gt,v) </condition >\n</sum >\n5.1.3.2 Constraint count\nThe constraint count ensures that the number of set variables in <list> which are assigned a set among those in <values> respects a numerical condition.\nSyntax 92\n<count>\n<list> (setVar wspace)2+ </list> <values> (setVal wspace)+ | (setVar wspace)+ </values> <condition> \"(\" operator \",\" operand \")\" </condition>\n</count>\nTo simplify, we assume for the semantics that T is a set of set values (and not variables).\nSemantics 55\ncount(S, T, ( , k)), with S = \u3008s1, s2, . . .\u3009, T = \u3008t1, t2, . . .\u3009, iff |{i : 1 \u2264 i \u2264 |S| \u2227 si \u2208 T}| k\n97\nExample 87\n<count >\n<list > s1 s2 s3 s4 </list > <values > t </values > <condition > (eq ,2) </condition >\n</count >\nThe constraint count captures atLeast, atMost and exactly. It also captures nEmpty of Choco3, by using <values> set() </values>.\n5.1.3.3 Constraint range\nThe constraint range [16, 18] holds iff the set of values taken by variables of <list> at indices given by <index> is exactly the set <image>. The optional attribute startIndex gives the number used for indexing the first variable in <list> (0, by default).\nSyntax 93\n<range>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <index> setVal | setVar </index> <image> setVal | setVar </image>\n</range>\nSemantics 56\nrange(X, s, t), with X = \u3008x1, x2, . . .\u3009, iff {xi : 1 \u2264 i \u2264 |X| \u2227 i \u2208 s} = t\nIn the following example, the constraints c1 and c2, taken together, permit to represent nValues({x0, x1, x2, x3, x4, x5}, y); see [16].\nExample 88\n<range id=\"c1\">\n<list > x0 x1 x2 x3 x4 x5 </list > <index > {0,1,2,3,4,5} </index > <image > t </image >\n</range > <intension id=\"c2\"> eq(y,card(t)) </intension >\n5.1.3.4 Constraint roots\nThe constraint roots [16, 19] holds iff <index> represents exactly the set of indices of variables in <list> which are assigned a value in <image>. The optional attribute startIndex gives the number used for indexing the first variable in <list> (0, by default).\n98\nSyntax 94\n<roots>\n<list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <index> setVal | setVar </index> <image> setVal | setVar </image>\n</roots>\nSemantics 57\nroots(X, s, t), with X = \u3008x1, x2, . . .\u3009, iff {i : 1 \u2264 i \u2264 |X| \u2227 xi \u2208 t} = s\nIn the following example, the constraints c1 and c2, taken together, permit to represent among(2,{x0, x1, x2, x3, x4, x5}, {0, 1}); see [16].\nExample 89\n<roots id=\"c1\">\n<list > x0 x1 x2 x3 x4 x5 </list > <index > s </index > <image > {0,1} </image >\n</roots > <intension id=\"c2\"> eq(2,card(s)) </intension >\n5.1.4 Connection Constraints\n5.1.4.1 Constraint element\nThe constraint element ensures that <value> is element of <list>, i.e., equal to one set among those assigned to the set variables of <list>. The optional element <index> gives the index (position) of one occurrence of <value> inside <list>. The optional attribute startIndex gives the number used for indexing the first variable in <list> (0, by default).\nSyntax 95\n<element>\n<list [startIndex=\"integer\"]> (setVar wspace)2+ </list> [<index> intVar </index>] <value> setVal | setVar </value>\n</element>\nSemantics 58\nelement(S, t), with S = \u3008s1, s2, . . .\u3009, iff \u2203i : 1 \u2264 i \u2264 |S| \u2227 si = t element(S, i, t), with S = \u3008s1, s2, . . .\u3009, iff si = t\n99\nThe first form (without element <index>) captures member in Choco3.\nExample 90\n<element id=\"c1\">\n<list > s1 s2 s3 </list > <index > i </index > <value > t </value >\n</element > <element id=\"c2\">\n<list > t1 t2 t3 t4 </list > <value > t5 </value >\n</element >\n5.1.4.2 Constraint channel\nThe constraint channel, in its first form, sometimes called inverse set or inverse in the literature, ensures that two lists of set variables represent inverse functions. Any value in the set of a list must be within the index range of the other list. For each list, the optional attribute startIndex gives the number used for indexing the first variable in this list (0, by default).\nSyntax 96\n<channel>\n<list [startIndex=\"integer\"]> (setVar wspace)2+ </list> <list [startIndex=\"integer\"]> (setVar wspace)2+ </list>\n</channel>\nFor the semantics, starting indexes are assumed to be equal to 1.\nSemantics 59\nchannel(S, T ), with S = \u3008s1, s2, . . .\u3009 and T = \u3008t1, t2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |S|, j \u2208 si \u21d4 i \u2208 tj\nA second form of the constraint channel, called int set channel in MiniZinc, links a set of integer variables to a set of set variables.\nSyntax 97\n<channel>\n<list [startIndex=\"integer\"]> (intVar wspace)+ </list> <list [startIndex=\"integer\"]> (setVar wspace)+ </list>\n</channel>\nSemantics 60\nchannel(X,S), with X = \u3008x1, x2, . . .\u3009 and S = \u3008s1, s2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |X|,xi = j \u21d4 i \u2208 sj\n100\nA final form, called bool channel in Choco3, is obtained by considering a list of 0/1 variables to be channeled with a set variable. It constrains this list to be a representation of the set.\nSyntax 98\n<channel>\n<list [startIndex=\"integer\"]> (01Var wspace)2+ </list> <value> setVar </value>\n</channel>\nSemantics 61\nchannel(X, s), with X = {x1, x2, . . .}, iff \u2200i : 1 \u2264 i \u2264 |X|,xi = 1\u21d4 i \u2208 s\n5.1.4.3 Constraint partition\nThe constraint partition ensures that <list> represents a partition of <value>.\nSyntax 99\n<partition>\n<list> (setVar wspace)2+ </list> <value> setVar </value>\n</partition>\nSemantics 62\npartition(S, t), with S = \u3008s1, s2, . . .\u3009, iff t = \u222a|S|i=1si \u2227 \u2200(i, j) : 1 \u2264 i < j \u2264 |S|, si \u2229 sj = \u2205\n5.1.4.4 Constraint precedence\nThe constraint precedence ensures that if a set variable sj of <list> contains the i + 1th value of <values>, but not the ith value, then another set variable of <list>, that precedes sj , contains the ith value of <values>, but not the i+ 1th value. The optional attribute covered indicates whether each value of <values> must belong to at least one set variable of <list> (\"false\", by default). It is also possible to reverse the order by specifying the relational operator in the optional element <operator> (lt, by default).\n101\nSyntax 100\n<precedence>\n<list> (setVar wspace)2+ </list> <values [covered=\"boolean\"]> (intVal wspace)2+ </values> [<operator> \"lt\" | \"gt\" </operator>]\n</precedence>\nFor the semantics, V cv means that covered is \"true\", and we note v \u2208 S iff there exists a set variable sj \u2208 S such that v \u2208 sj .\nSemantics 63\nprecedence(S, V ), with S = \u3008s1, s2, . . .\u3009 and V = \u3008v1, v2, . . .\u3009, iff \u2200i : 1 \u2264 i < |V |, vi+1 \u2208 S \u21d2 vi \u2208 S \u2200i : 1 \u2264 i < |V | \u2227 vi+1 \u2208 S,min{j : 1 \u2264 j \u2264 |S| \u2227 vi \u2208 sj} min{j : 1 \u2264 j \u2264 |S| \u2227 vi+1 \u2208 sj} precedence(S, V cv , ) iff precedence(S, V, ) \u2227 v|V | \u2208 S\nExample 91\n<precedence >\n<list > s1 s2 s3 s4 </list > <values > 4 0 </values >\n</precedence >\nThe constraint precedence captures set value precede in the Global Constraint Catalog."}, {"heading": "5.2 Constraints over Graph Variables", "text": "In this section, we present constraints that are defined on graph variables. We have:\n1. circuit\n2. nCircuits\n3. path\n4. nPaths\n5. arbo\n6. nArbos\n7. nCliques\n5.2.1 Constraint circuit\nThis form of the constraint circuit ensures that the value taken by the (directed or undirected) graph variable in <graph> represents a circuit (cycle). The optional element <size> indicates that the circuit must be of a given size (number of nodes). Consequently, in that case, and only in that case, the circuit is not required to cover all nodes that are present in the upper bound of the graph variable.\n102\nSyntax 101\n<circuit>\n<graph> graphVar </graph> [<size> intVal | intVar </size>]\n</circuit>\nFor the semantics, nmax denotes the number of nodes in the upper bound gmax of g.\nSemantics 64\ncircuit(g) iff\ng is a circuit of size nmax\ncircuit(g, s) iff\ng is a circuit of size s > 1\n5.2.2 Constraint nCircuits\nFor several circuits, one must specify a numerical condition.\nSyntax 102\n<nCircuits>\n<graph> graphVar </graph> <condition> \"(\" operator \",\" operand \")\" </condition>\n</nCircuits>\nSemantics 65\nnCircuits(g, ( , k)), iff g represents p node-disjoint circuits with p k\n5.2.3 Constraint path\nThe constraint path ensures that the value taken by the (directed or undirected) graph variable in <graph> represents a path from the node specified in <start> to the node specified in <final>. The optional element size indicates that the path must be of a given size (number of nodes). Consequently, in that case, and only in that case, the path is not required to cover all nodes that are present in the upper bound of the graph variable.\nSyntax 103\n<path>\n<graph> graphVar </graph> <start> intVal | intVar </start> <final> intVal | intVar </final> [<size> intVal | intVar </size>]\n</path>\n103\nSemantics 66\npath(g, s, e) iff\ng is a path from s to e of size nmax\npath(g, s, e, z) iff\ng is a path from s to e of size z > 1\n5.2.4 Constraint nPaths\nFor several paths, one must specify a numerical condition.\nSyntax 104\n<nPaths>\n<graph> graphVar </graph> <condition> \"(\" operator \",\" operand \")\" </condition>\n</nPaths>\nSemantics 67\nnPaths(g, ( , k)), iff g forms p paths s.t. p k\n5.2.5 Constraint arbo\nThe constraint arbo ensures that the value taken by the directed (respectively, undirected) graph variable in <graph> represents an arborescence (respectively, tree) whose root is specified by <root>. The optional element size indicates that the arborescence must be of a given size (number of nodes). Consequently, in that case, the arborescence is not required to cover all nodes that are present in the upper bound of the graph variable.\nSyntax 105\n<arbo>\n<graph> graphVar </graph> <root> intVal | intVar </root> [<size> intVal | intVar </size>]\n</arbo>\nSemantics 68\narbo(g, r) iff\ng is an arborescence of root r and size nmax\narbo(g, r, s) iff\ng is an arborescence of root r and size s > 1\n104\n5.2.6 Constraint nArbos\nSyntax 106\n<nArbos>\n<graph> graphVar </graph> <condition> \"(\" operator \",\" operand \")\" </condition>\n</nArbos>\nSemantics 69\nnArbos(g, ( , k)), with \u2208 {<,\u2264, >,\u2265,=, 6=}, iff g represents p arborescences s.t. p k\n5.2.7 Constraint nCliques\nThe constraint nCliques, called nclique in [45], ensures that the value taken by the graph variable in <graph> represents a set of cliques whose cardinality must respect a numerical condition.\nSyntax 107\n<nCliques>\n<graph> graphVar </graph> <condition> \"(\" operator \",\" operand \")\" </condition>\n</nCliques>\nSemantics 70\nnCliques(g, ( , k)), with \u2208 {<,\u2264, >,\u2265,=, 6=}, iff g represents p cliques s.t. p k\n105\n6 Constraints over Continuous\nVariables\nIn this chapter, we introduce constraints over continuous variables, namely, real and qualitative variables. We shall use the term realVar and qualVar to denote a real variable and a qualitative variable, respectively. These terms as well as related ones, like for example, realVal, are defined in Appendix B."}, {"heading": "6.1 Constraints over Real Variables", "text": "Reasoning over real variables is typically performed by means of intensional arithmetic constraints and sum (linear) constraints. However, in the future, we might introduce a few global constraints adapted to real variables.\n6.1.1 Constraint intension\nA constraint intension on real variables is built similarly to a constraint intension defined on integer variables. Simply, some additional operators are available. They are given by Table 6.1 that does show the specific operators that can be used to build predicates with real operands. Of course, it is possible to combine such operators with those presented for integers (and Booleans) in Table 4.1.\nAn intensional constraint is defined by an element <intension>, containing an element <function> that describes the functional representation of the predicate, referred to as boolExprReal in the syntax box above, and whose precise syntax is given in Appendix B.\n106\nIn the following example, the constraints c1 and c2 are respectively defined by v = \u221a w and\nx \u2265 3 ln y + z4, with v, w, x, y, z assumed to be real variables.\nExample 92\n<intension id=\"c1\">\neq(v,sqrt(w))\n</intension > <intension id=\"c2\">\nge(x,add(mul(3,ln(y)),pow(z,4)))\n</intension >\n107\n6.1.2 Constraint sum\nThe constraint sum is the most important constraint in the context of real computation. When the optional element <coeffs> is missing, it is assumed that all coefficients are equal to 1. Of course, real values, variables and intervals are expected in <condition>.\nSyntax 110\n<sum>\n<list> (realVar wspace)2+ </list> [<coeffs> (realVal wspace)+ </coeffs>] <condition> \"(\" operator \",\" (realVal | realVar | realIntvl) \")\" </condition>\n</sum>\nSemantics 71\nsum(X,C, ( , k)), with X = \u3008x1, x2, . . .\u3009 and C = \u3008c1, c2, . . .\u3009, iff ( \u2211|X| i=1 ci \u00d7 xi) k\nPrerequisite : |X| = |C|\nIn the following example, the constraint expresses 1.5x0 + 2x1 + 3.2x2 > y.\nExample 93\n<sum >\n<list > x0 x1 x2 </list > <coeffs > 1.5 2 3.2 </coeffs > <condition > (gt,y) </condition >\n</sum >"}, {"heading": "6.2 Constraints over Qualitative Variables", "text": "Qualitative Spatial Temporal Reasoning (QSTR) deals with qualitative calculi (also called algebras). A qualitative calculus is defined from a finite set B of base relations on a certain domain. In this section, we introduce some constraints over some important qualitative calculi. In the future, more algebras might be introduced.\n6.2.1 Constraint interval\nInterval Algebra, also called Allen\u2019s calculus [2] handles temporal entities that represent intervals on the rational line. The set of base relations of this calculus is:\nBint = {eq, p, pi,m,mi, o, oi, s, si, d, di, f, fi}\nwhere for example m stands for meets. The constraint interval allows us to express qualitative information between two intervals.\n108\nSyntax 111\n<interval>\n<scope> qualVar wspace qualVar </scope> <relation> (iaBaseRelation wspace)* </relation>\n</interval>\nSemantics 72\ninterval(x, y,R), with R \u2286 Bint, iff \u2203b \u2208 R : (x,y) \u2208 b\nIn the following example, the constraint expresses that either x must overlap y or x must meet y.\nExample 94\n<interval >\n<scope > x y </scope > <relation > o m </relation >\n</interval >\n6.2.2 Constraint point\nPoint Algebra (PA) is a simple qualitative algebra defined for time points. The set of base relations of this calculus is:\nBpoint = {b, eq, a}\nwhere for example b stands for before. The constraint point allows us to express qualitative information between two points.\nSyntax 112\n<point>\n<scope> qualVar wspace qualVar </scope> <relation> (paBaseRelation wspace)* </relation>\n</point>\nSemantics 73\npoint(x, y,R), with R \u2286 Bpoint, iff \u2203b \u2208 R : (x,y) \u2208 b\nIn the following example, the constraint expresses that either x must be before or after y.\n109\nExample 95\n<point >\n<scope > x y </scope > <relation > b a </relation >\n</point\n6.2.3 Constraint rcc8\nRCC8 [106] is a region connection calculus for reasoning about regions in Euclidean space. The set of base relations of this calculus is:\nBrcc8 = {dc, ec, eq, po, tpp, tppi, nttp, ntppi}\nwhere for example dc stands for disconnected. The constraint region allows us to express qualitative information between two regions. For RCC8, the attribute type is required, and its value must be set to \"rcc8\".\nSyntax 113\n<region type=\"rcc8\">\n<scope> qualVar wspace qualVar </scope> <relation> (rcc8BaseRelation wspace)* </relation>\n</region>\nSemantics 74\nregionrcc8(x, y,R), with R \u2286 Brcc8, iff \u2203b \u2208 R : (x,y) \u2208 b\nIn the following example, the constraint expresses that either x must be disconnected or externally connected with y.\nExample 96\n<region type=\"rcc8\">\n<scope > x y </scope > <relation > dc ec </relation >\n</region >\n6.2.4 Constraint dbd\nFor Temporal Constraint Satisfaction [42], variables represent time points and temporal information is represented by a set of unary and binary constraints, each specifying a set of permitted intervals.\nFor this framework, we only need to introduce a type of constraints, called dbd constraints, for disjunctive binary difference constraints (as in [70]).\n110\nSyntax 114\n<dbd>\n<scope> qualVar (wspace qualVar)* </scope> <intervals> (realIntvl wspace)+ </intervals>\n</dbd>\nBelow, we give the semantics for unary and binary dbd constraints.\nSemantics 75\ndbd(x, I), with I = \u3008l1..u1, l2..u2, . . .\u3009, iff \u2203i : 1 \u2264 i \u2264 |I| \u2227 x \u2208 li..ui dbd(x, y, I), with I = \u3008l1..u1, l2..u2, . . .\u3009, iff \u2203i : 1 \u2264 i \u2264 |I| \u2227 y \u2212 x \u2208 li..ui\nIn the following example, the constraint expresses that either x2\u2212 x1 must be in [30, 40] or in [60,+infinity[.\nExample 97\n<dbd >\n<scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals >\n</dbd >\n111\nPart III\nAdvanced Forms of Constraints\n112\nIn XCSP3, it is possible to build advanced forms of (basic) constraints bu means of lifting, restriction, sliding, logical combination and relaxation mechanisms. In this part, we introduce them.\n113\n7 Lifted and Restricted Forms of\nConstraints\nIn this chapter, we introduce two mechanisms that allow us to extend the scope of constraints defined in XCSP3. First, we show how it is possible to lift constraints over lists, sets, multisets, and also matrices, in a quite generic and natural way. Second, we show how classical restrictions on constraints can be posed by operating a simple attribute. These two mechanisms offer flexibility and extensibility, without paying the price of introducing many new XML elements."}, {"heading": "7.1 Constraints lifted to Lists, Sets and Multisets", "text": "Many constraints, introduced earlier on integer variables can be extended to lists (tuples), sets and multisets. In XCSP3, this is quite easy to handle: replace, when appropriate, each integer variable of a list by an element <list>, or replace each of them by an element <set>, or even replace each of them by an element <mset>. The semantics, initially given for a sequence of variables, is naturally extended to apply to a sequence of lists of variables, a sequence of sets of variables, and a sequence of multisets of variables. The semantics must handle now tuples of values, sets of values, and multisets of values, since:\n\u2022 The values assigned to the variables of an element <list> represent a tuple of values. For example, if we have <list> x1 x2 x3 </list> and the instantiation x1 = 1, x2 = 0, x3 = 1, we deal with the tuple \u30081, 0, 1\u3009.\n\u2022 The values assigned to the variables of an element <set> represent a set of values. For example, if we have <set> x1 x2 x3 </set> and the instantiation x1 = 1, x2 = 0, x3 = 1, we deal with the set {0, 1}.\n\u2022 The values assigned to the variables of an element <mset> represent a multiset of values. For example, if we have <mset> x1 x2 x3 </mset> and the instantiation x1 = 1, x2 = 0, x3 = 1, we deal with the multiset {{0, 1, 1}}.\n114\nA lifting operation always applies to an element <list> conceived to contain integer variables. After all variables have been replaced by lists, sets or tuples, the opening and closing tags for the initial element <list> are no more required. This is the reason we shall never represent them.\nIn this section, we show this approach for the most popular \u201cbasic\u201d constraints. More specifically, we present the following constraints lifted to lists, sets and multisets:\n\u2022 allDifferent \u2022 allEqual \u2022 allDistant \u2022 ordered \u2022 allIncomparable \u2022 nValues \u2022 sort Because these constraints are defined on several sequences (vectors) of variables, they admit a parameter X = \u3008X1, X2, . . .\u3009, with X1 = \u3008x1,1, x1,2, . . .\u3009, X2 = \u3008x2,1, x2,2, . . .\u3009, . . . If X = \u3008x1, x2, . . . , xp\u3009 then |X| = p, and: \u2022 X denotes \u3008x1,x2, . . . ,xp\u3009, the tuple of values obtained when considering an arbitrary\ninstantiation of X.\n\u2022 {X} denotes {xi : 1 \u2264 i \u2264 p}, the set of values obtained when considering an arbitrary instantiation of X.\n\u2022 {{X}} denotes {{xi : 1 \u2264 i \u2264 p}}, the multiset of values obtained when considering an arbitrary instantiation of X.\nAlthough we do not introduce new constraint types (names) in XCSP3, in order to clarify the textual description (in particular, for the semantics), we shall refer in the text to the versions of a constraint ctr, lifted to lists, sets and multisets, by ctr-list, ctr-set and ctr-mset, respectively. For example, we shall refer in the text to allDifferent-list, allDifferent-set and allDifferent-mset when considering lifted versions of allDifferent.\n7.1.1 Lifted Constraints allDifferent\nThe constraint allDifferent, introduced earlier on integer variables, can be naturally extended to lists (tuples), sets and multisets [103]."}, {"heading": "7.1.1.1 On lists (tuples)", "text": "If allDifferent admits as parameter several lists of integer variables, then the constraint ensures that the tuple of values taken by variables of the first element <list> is different from the tuple of values taken by variables of the second element <list>. If more than two elements <list> are given, all tuples must be different. A variant enforces tuples to take distinct values, except those that are assigned to some specified tuples (often, the single tuple containing only 0), specified in the optional element <except>.\n115\nSyntax 115\n<allDifferent>\n(<list> (intVar wspace)2+ </list>)2+ [<except> (\"(\" intVal (\",\" intVal)+ \")\")+ </except>]\n</allDifferent>\nAs explained in the introduction of this section, in the text below, allDifferent-list refers to allDifferent defined over several lists of integer variables.\nSemantics 76\nallDifferent-list(X , E), with X = \u3008X1, X2, . . .\u3009, E the set of discarded tuples, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |,Xi 6= Xj \u2228Xi \u2208 E \u2228Xj \u2208 E allDifferent-list(X ) iff allDifferent-list(X , \u2205)\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2 \u2227 \u2200\u03c4 \u2208 E, |\u03c4 | = |X1|\nExample 98\n<allDifferent id=\"c1\">\n<list > x1 x2 x3 x4 </list > <list > y1 y2 y3 y4 </list >\n</allDifferent > <allDifferent id=\"c2\">\n<list > v1 v2 v3 v4 </list > <list > w1 w2 w3 w4 </list > <list > z1 z2 z3 z4 </list > <except > (0,0,0,0) </except >\n</allDifferent >\nConstraints captured by allDifferent-list from the Global Constraint Catalog: \u2022 lex different \u2022 lex alldifferent \u2022 lex alldifferent except 0"}, {"heading": "7.1.1.2 On sets", "text": "If allDifferent admits several sets of integer variables as parameter, then the constraint ensures that the set of values taken by variables of the first element <set> is different from the set of values taken by variables of the second element <set>. If more than two elements <set> are given, all sets must be different. A variant enforces sets of values to be different, except those that are assigned to some specified sets, specified in the optional element <except>.\n116\nSyntax 116\n<allDifferent>\n(<set> (intVar wspace)+ </set>)2+ [<except> (\"{\" intVal (\",\" intVal)* \"}\")+ </except>]\n</allDifferent>\nAs explained in the introduction of this section, in the text below, allDifferent-set refers to allDifferent defined over several sets of integer variables.\nSemantics 77\nallDifferent-set(X , E), with X = \u3008X1, X2, . . .\u3009, E the set of discarded sets, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, {Xi} 6= {Xj} \u2228 {Xi} \u2208 E \u2228 {Xj} \u2208 E allDifferent-set(X ) iff allDifferent-set(X , \u2205)\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i \u2264 |X |, |Xi| \u2265 1\nExample 99\n<allDifferent id=\"c1\">\n<set > x1 x2 x3 x4 </set > <set > y1 y2 y3 </set >\n</allDifferent > <allDifferent id=\"c2\">\n<set > v1 v2 v3 </set > <set > w1 w2 w3 w4 </set > <set > z1 z2 </set > <except > {0,1} </except >\n</allDifferent >"}, {"heading": "7.1.1.3 On multisets", "text": "If allDifferent admits several multisets of integer variables as parameter, then the constraint ensures that the multiset of values taken by variables of the first element <mset> is different from the multiset of values taken by variables of the second element <mset>. If more than two elements <mset> are given, all multisets must be different. A variant enforces multisets of values to be different, except those that correspond some specified multisets, specified in the optional element <except>.\nSyntax 117\n<allDifferent>\n(<mset> (intVar wspace)2+ </mset>)2+ [<except> (\"{{\" intVal (\",\" intVal)+ \"}}\")+ </except>]\n</allDifferent>\nAs explained in the introduction of this section, in the text below, allDifferent-mset refers to allDifferent defined over several multisets of integer variables.\n117\nSemantics 78\nallDifferent-mset(X , E), with X = \u3008X1, X2, . . .\u3009, E the set of discarded msets, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, {{Xi}} 6= {{Xj}} \u2228 {{Xi}} \u2208 E \u2228 {{Xj}} \u2208 E allDifferent-mset(X ) iff allDifferent-mset(X , \u2205)\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2 \u2227 \u2200M \u2208 E, |M | = |X1|\nExample 100\n<allDifferent id=\"c1\">\n<mset > x1 x2 x3 x4 </mset > <mset > y1 y2 y3 y4 </mset >\n</allDifferent > <allDifferent id=\"c2\">\n<mset > v1 v2 v3 v4 </mset > <mset > w1 w2 w3 w4 </mset > <mset > z1 z2 z3 z4 </mset > <except > {{0,0,0,0}} </except >\n</allDifferent >\n7.1.2 Lifted Constraints allEqual\nThe versions of allEqual lifted to lists, sets and multisets are defined similarly to those presented above for allDifferent."}, {"heading": "7.1.2.1 On lists (tuples)", "text": "Syntax 118\n<allEqual>\n(<list> (intVar wspace)2+ </list>)2+\n</allEqual>\nSemantics 79\nallEqual-list(X ), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |,Xi = Xj\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nConstraints captured by allEqual-list from the Global Constraint Catalog: lex equal\n118"}, {"heading": "7.1.2.2 On sets", "text": "Syntax 119\n<allEqual>\n(<set> (intVar wspace)+ </set>)2+\n</allEqual>\nSemantics 80\nallEqual-set(X ), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, {Xi} = {Xj}\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i \u2264 |X |, |Xi| \u2265 1"}, {"heading": "7.1.2.3 On multisets", "text": "Syntax 120\n<allEqual>\n(<mset> (intVar wspace)2+ </mset>)2+\n</allEqual>\nSemantics 81\nallEqual-mset(X ), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, {{Xi}} = {{Xj}}\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nConstraints captured by allEqual-mset from the Global Constraint Catalog: same\n7.1.3 Lifted Constraints allDistant\nSimilarly to allDifferent and allEqual, allDistant can be lifted to lists, sets and multisets. Of course, we have to clarify the distances that are used, when considering pairs of lists, sets and multisets. By default, we shall use the following distances:\n\u2022 Hamming distance for lists: distH (X,Y ) = |{i : 1 \u2264 i \u2264 |X| \u2227 xi 6= yi}| with X = \u3008x1, x2, . . .\u3009, Y = \u3008y1, y2, . . .\u3009 and |X| = |Y |.\n\u2022 infimum distance for sets (of integers): distinf (X,Y ) = min{|x\u2212 y| : x \u2208 X \u2227 y \u2208 Y } \u2022 Manhattan distance for multisets: distM (X,Y ) = \u2211 a\u2208X\u222aY |\u03bdX(a) \u2212 \u03bdY (a)| with \u03bdZ(c)\ndenoting the multiplicity (number of occurrences) of value c in the multiset Z.\n119"}, {"heading": "7.1.3.1 On lists (tuples)", "text": "Syntax 121\n<allDistant>\n(<list> (intVar wspace)2+ </list>)2+ <condition> \"(\" operator \",\" operand \")\" </condition>\n</allDistant>\nSemantics 82\nallDistant-list(X , ( , k)), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, distH(Xi,Xj) k\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nConstraints captured by allDistant-list from the Global Constraint Catalog: \u2022 differ from at least k pos, differ from at most k pos \u2022 differ from exactly k pos \u2022 all differ from at least k pos, all differ from at most k pos \u2022 all differ from exactly k pos"}, {"heading": "7.1.3.2 On sets", "text": "Syntax 122\n<allDistant>\n(<set> (intVar wspace)+ </set>)2+ <condition> \"(\" operator \",\" operand \")\" </condition>\n</allDistant>\nSemantics 83\nallDistant-set(X , ( , k)), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, distinf ({Xi}, {Xj}) k\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i \u2264 |X |, |Xi| \u2265 1\nWe propose to identify two types of allDistant-set, corresponding to the case where all sets must be disjoint (value \"disjoint\" for case) and the case where all sets must be overlapping (value \"overlapping\" for case). For both cases, the element <condition> becomes implicit. The two following constraints c1 and c2:\n120\nExample 101\n<allDistant id=\"c1\">\n<set > x1 x2 x3 x4 </set > <set > y1 y2 y3 y4 </set > <set > z1 z2 z3 </set > <condition > (gt ,0) </condition >\n</allDistant > <allDistant id=\"c2\">\n<set > v1 v2 v3 </set > <set > v4 v5 v6 v7 </set > <set > v8 v9 </set > <condition > (eq ,0) </condition >\n</allDistant >\ncan then be defined by:\nExample 102\n<allDistant id=\"c1\" case=\"disjoint\">\n<set > x1 x2 x3 x4 </set > <set > y1 y2 y3 y4 </set > <set > z1 z2 z3 </set >\n</allDistant > <allDistant id=\"c2\" case=\"overlapping\">\n<set > v1 v2 v3 </set > <set > v4 v5 v6 v7 </set > <set > v8 v9 </set >\n</allDistant >"}, {"heading": "7.1.3.3 On multisets", "text": "Syntax 123\n<allDistant>\n(<mset> (intVar wspace)2+ </mset>)2+ <condition> \"(\" operator \",\" operand \")\" </condition>\n</allDistant>\nSemantics 84\nallDistant-mset(X , ( , k)), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, distM ({{Xi}}, {{Xj}}) k\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nRemark 29 In the future, we project to deal with other distances by introducing an attribute distance, while fixing the terminology (values that can be used for distance).\n121\n7.1.4 Lifted Constraints ordered (lex on lists)\nThe constraint ordered can be naturally lifted to lists, sets and multisets. As for allDistant, we have to clarify the (total or partial) orders that are used, when comparing lists, sets and multisets. By default, we shall use the following orders:\n\u2022 lexicographic order \u2264lex for lists; \u2022 inclusion order \u2286 for sets; \u2022 multiplicity inclusion order \u2286 for multisets: X \u2286 Y iff \u2200a \u2208 X, \u03bdX(a) \u2264 \u03bdY (a), with \u03bdZ(c) denoting the multiplicity (number of occurrences) of value c in the multiset Z."}, {"heading": "7.1.4.1 On lists (tuples)", "text": "Because this constraint is very popular, it is allowed to use lex, instead of ordered over lists of integer variables. The constraint lex, see [32, 54], ensures that the tuple formed by the values assigned to the variables of the first element <list> is related to the tuple formed by the values assigned to the variables of the second element <list> with respect to the operator specified in <operator>. If more than two elements <list> are given, the entire sequence of tuples must be ordered; this captures then lexChain [31].\nSyntax 124\n<lex>\n(<list> (intVar wspace)2+ </list>)2+ <operator> \"lt\" | \"le\" | \"ge\" | \"gt\" </operator>\n</lex>\nSemantics 85\nlex(X , ), with X = \u3008X1, X2, . . .\u3009 and \u2208 {<lex,\u2264lex,\u2265lex, >lex}, iff \u2200i : 1 \u2264 i < |X |,Xi Xi+1\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nIn the following example, the constraint c1 states that \u3008x1, x2, x3, x4\u3009 \u2264lex \u3008y1, y2, y3, y4\u3009, whereas c2 states that \u3008z1, z2, z3\u3009 >lex \u3008z4, z5, z6\u3009 >lex \u3008z7, z8, z9\u3009.\nExample 103\n<lex id=\"c1\">\n<list > x1 x2 x3 x4 </list > <list > y1 y2 y3 y4 </list > <operator > le </operator >\n</lex > <lex id=\"c2\">\n<list > z1 z2 z3 </list > <list > z4 z5 z6 </list > <list > z7 z8 z9 </list > <operator > gt </operator >\n</lex >\n122\nConstraints captured by lex from the Global Constraint Catalog: \u2022 lex between \u2022 lex greater, lex greatereq \u2022 lex less, lex lesseq \u2022 lex chain greater, lex chain greatereq \u2022 lex chain less, lex chain lesseq"}, {"heading": "7.1.4.2 On sets", "text": "The constraint ensures that the set of values taken by variables of the first element <set> is related to the set of values taken by the variables of the second element <set>, with respect to a relational set operator. If more than two elements <set> are given, the entire sequence of sets must be ordered.\nSyntax 125\n<ordered>\n(<set> (intVar wspace)+ </set>)2+ <operator> \"subset\" | \"subseq\" | \"supseq\" | \"supset\" </operator>\n</ordered>\nSemantics 86\nordered-set(X , ), with X = {X1, X2, . . .} and \u2208 {\u2282,\u2286,\u2287,\u2283}, iff \u2200i : 1 \u2264 i < |X |, {Xi} {Xi+1}\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i \u2264 |X |, |Xi| \u2265 1\nThis captures uses [16]."}, {"heading": "7.1.4.3 On multisets", "text": "Syntax 126\n<ordered>\n(<mset> (intVar wspace)2+ </mset>)2+ <operator> \"subset\" | \"subseq\" | \"supseq\" | \"supset\" </operator>\n</ordered>\nSemantics 87\nordered-mset(X , ), with X = {X1, X2, . . .} and \u2208 {\u2282,\u2286,\u2287,\u2283}, iff \u2200i : 1 \u2264 i < |X |, {{Xi}} {{Xi+1}}\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nThis captures usedBy [11].\n123\nRemark 30 In the future, we project to deal with other orders by introducing an attribute order, while fixing the terminology (values that can be used for order).\n7.1.5 Lifted Constraints allIncomparable\nThe constraint allIncomparable is not defined on integer variables because N is totally ordered, but it is meaningful on lists, sets and multisets. This is why it is only introduced in this chapter. As for ordered, we have to clarify the partial orders that are used, when comparing lists, sets and multisets. By default, we shall use the following partial orders:\n\u2022 product order (and not lexicographic order) for lists: X \u2264prod Y iff \u2200i : 1 \u2264 i \u2264 |X|, xi \u2264 yi with X = \u3008x1, x2, . . .\u3009, Y = \u3008y1, y2, . . .\u3009 and |X| = |Y |;\n\u2022 inclusion order \u2286 for sets; \u2022 multiplicity inclusion order \u2286 for multisets: X \u2286 Y iff \u2200a \u2208 X, \u03bdX(a) \u2264 \u03bdY (a), with \u03bdZ(c) denoting the multiplicity (number of occurrences) of value c in the multiset Z."}, {"heading": "7.1.5.1 On lists (tuples)", "text": "All elements <list> must correspond to tuples that are all incomparable (for the product order).\nSyntax 127\n<allIncomparable>\n(<list> (intVar wspace)2+ </list>)2+\n</allIncomparable>\nSemantics 88\nallIncomparable-list(X ), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |,\u2203(k, l) : 1 \u2264 k < l \u2264 |Xi| \u2227 xi,k > xj,k \u2227 xi,l < xj,l\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nThe constraints captured by allIncomparable-list from the Global Constraint Catalog are: incomparable and all incomparable"}, {"heading": "7.1.5.2 On sets", "text": "All elements <set> must be incomparable (for inclusion).\nSyntax 128\n<allIncomparable>\n(<set> (intVar wspace)+ </set>)2+\n</allIncomparable>\n124\nSemantics 89\nallIncomparable-set(X ), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, {Xi} 6\u2286 {Xj} \u2227 {Xj} 6\u2286 {Xi}\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i \u2264 |X |, |Xi| \u2265 1"}, {"heading": "7.1.5.3 On multisets", "text": "All elements <mset> must be incomparable (for multiplicity inclusion).\nSyntax 129\n<allIncomparable>\n(<mset> (intVar wspace)2+ </mset>)2+\n</allIncomparable>\nSemantics 90\nallIncomparable-mset(X ), with X = \u3008X1, X2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X |, {{Xi}} 6\u2286 {{Xj}} \u2227 {{Xj}} 6\u2286 {{Xi}}\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2\nRemark 31 In the future, we project to deal with other partial orders by introducing an attribute order, while fixing the terminology (values that can be used for order).\n7.1.6 Lifted Constraints nValues\nThe constraint nValues can be naturally lifted to lists, sets and multisets; the term \u201cvalue\u201d being understood successively as a list, a set or a multiset."}, {"heading": "7.1.6.1 On lists", "text": "This constraint, sometimes called nVectors, ensures that the number of distinct tuples taken by variables of different elements <list> (of same size) must respect a numerical condition. A variant enforces tuples to take distinct values, except those that are assigned to some specified tuples (often, the single tuple containing only 0), specified in the optional element <except>.\nSyntax 130\n<nValues>\n(<list> (intVar wspace)2+ </list>)2+ [<except> (\"(\" intVal (\",\" intVal)+ \")\")+ </except>] <condition> \"(\" operator \",\" operand \")\" </condition>\n</nValues>\nFor the semantics, E denotes the set of tuples that must be discarded.\n125\nSemantics 91\nnValues-list(X , E, ( , k)), with X = \u3008X1, X2, . . .\u3009, iff |{Xi : 1 \u2264 i \u2264 |X |} \\ E| k nValues(X , ( , k)) iff nValues(X , \u2205, ( , k))\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2 \u2227 \u2200\u03c4 \u2208 E, |\u03c4 | = |X1|\nExample 104\n<nValues id=\"c\">\n<list > x1 x2 x3 </list > <list > y1 y2 y3 </list > <list > z1 z2 z3 </list > <condition > (eq ,2) </condition >\n</nValues >\nConstraints captured by nValues-list from the Global Constraint Catalog: \u2022 atleast nvector, atmost nvector \u2022 nvector, nvectors"}, {"heading": "7.1.6.2 On sets", "text": "Syntax 131\n<nValues>\n(<set> (intVar wspace)+ </set>)2+ [<except> (\"{\" intVal (\",\" intVal)* \"}\")+ </except>] <condition> \"(\" operator \",\" operand \")\" </condition>\n</nValues>\nSemantics 92\nnValues-set(X , E, ( , k)), with X = \u3008X1, X2, . . .\u3009, iff |{{Xi} : 1 \u2264 i \u2264 |X |} \\ E| k nValues-set(X , ( , k)) iff nValues(X , \u2205, ( , k))\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i \u2264 |X |, |Xi| \u2265 1\n126"}, {"heading": "7.1.6.3 On multisets", "text": "Syntax 132\n<nValues>\n(<mset> (intVar wspace)2+ </mset>)2+ [<except> (\"{{\" intVal (\",\" intVal)+ \"}}\")+ </except>] <condition> \"(\" operator \",\" operand \")\" </condition>\n</nValues>\nSemantics 93\nnValues-mset(X , E, ( , k)), with X = \u3008X1, X2, . . .\u3009, iff |{{{Xi}} : 1 \u2264 i \u2264 |X |} \\ E| k nValues-mset(X , ( , k)) iff nValues(X , \u2205, ( , k))\nPrerequisite : |X | \u2265 2 \u2227 \u2200i : 1 \u2264 i < |X |, |Xi| = |Xi+1| \u2265 2 \u2227 \u2200M \u2208 E, |M | = |X1|"}, {"heading": "7.2 Constraints lifted to Matrices", "text": "Some constraints, introduced earlier on list(s) of integer variables, can naturally be extended to matrices of variables. This means that such constraints restraint both row lists and column lists of variables. The principle is to replace the element <list> of the basic constraint by an element <matrix>. However, lifting constraints over matrices is not always purely automatic, as we shall show with cardinality.\nAs in the previous section, although we do not introduce new constraint types (names) in XCSP3, we shall refer in the text to the matrix version of a constraint ctr by ctr-matrix, in order to clarify the textual description (in particular, for the semantics). For example, we shall refer in the text to allDifferent-matrix when considering the matrix version of allDifferent.\nIn this section, we present the following constraints defined on matrices of integer variables:\n1. allDifferent-matrix\n2. ordered-matrix (lex2)\n3. element-matrix\n4. cardinality-matrix\nThese constraints are defined on matrices of variables. So, they admit a parameter M = [X1, X2, . . . , Xn], with X1 = \u3008x1,1, x1,2, . . . , x1,m\u3009, X2 = \u3008x2,1, x2,2, . . . , x2,m\u3009, . . ., given by an element <matrix>, assuming here a matrix of size n\u00d7m. Note here that we use square brackets (\u201d[\u201d and \u201d]\u201d) to delimit matrices, in order to distinguish them from lists of lists (where angle brackets are used). We use the following notations below:\n\u2022 \u2200i : 1 \u2264 i \u2264 n,M[i] = Xi denotes the ith row of M \u2022 \u2200j : 1 \u2264 i \u2264 m,MT [j] = \u3008xi,j : 1 \u2264 i \u2264 |M|\u3009 denotes the jth column of M\n127\n7.2.1 Constraint allDifferent-matrix\nThe constraint allDifferent-matrix, called alldiffmatrix in [113] and in JaCoP, ensures that the values taken by variables on each row and on each column of a matrix are all different.\nSyntax 133\n<allDifferent>\n<matrix> (\"(\" intVar (\",\" intVar)+ \")\")2+ </matrix>\n</allDifferent>\nSemantics 94\nallDifferent-matrix(M), with M = [X1, X2, . . . , Xn], iff \u2200i : 1 \u2264 i \u2264 n, allDifferent(M[i]) \u2200j : 1 \u2264 j \u2264 m, allDifferent(MT [j])\nPrerequisite : \u2200i : 1 \u2264 i \u2264 n, |Xi| = m\nExample 105\n<allDifferent >\n<matrix >\n(x1 ,x2 ,x3 ,x4 ,x5) (y1 ,y2 ,y3 ,y4 ,y5) (z1 ,z2 ,z3 ,z4 ,z5)\n</matrix >\n</allDifferent >\n7.2.2 Constraint ordered-matrix (lex2)\nThe constraint ordered-matrix, that can be called lex-matrix too, corresponds to lex2 in the literature [50]. It ensures that, for a given matrix of variables, both adjacent rows and adjacent columns are lexicographically ordered. For the syntax, we can use lex instead of ordered, as for ordered-list.\nSyntax 134\n<lex>\n<matrix> (\"(\" intVar (\",\" intVar)+ \")\")2+ </matrix> <operator> \"lt\" | \"le\" | \"ge\" | \"gt\" </operator>\n</lex>\n128\nSemantics 95\nlex-matrix(M, ), with M = [X1, X2, . . . Xn] and = {<,\u2264,\u2265, >}, iff lex(\u3008M[1], . . . ,M[n]\u3009, ) lex(\u3008MT [1], . . . ,MT [m]\u3009, )\nIn the following example, the constraint states that: \u2022 \u3008z1, z2, z3\u3009 \u2264lex \u3008z4, z5, z6\u3009 \u2264lex \u3008z7, z8, z9\u3009 \u2022 \u3008z1, z4, z7\u3009 \u2264lex \u3008z2, z5, z8\u3009 \u2264lex \u3008z3, z6, z9\u3009.\nExample 106\n<lex >\n<matrix >\n(z1 ,z2 ,z3) (z4 ,z5 ,z6) (z7 ,z8 ,z9)\n</matrix > <operator > le </operator >\n</lex >\n7.2.3 Constraint element-matrix\nThe constraint element-matrix has been introduced in CHIP and called element matrix in the Global Constraint Catalog. Note here that we need to put two variables in <index> because we need two indexes to designate a variable in the matrix. The optional attributes startRowIndex and startColIndex respectively give the numbers used for indexing the first variable in each row and each column of <matrix> (0, by default).\nSyntax 135\n<element>\n<matrix [startRowIndex=\"integer] [startColIndex=\"integer\"] >\n(\"(\" intVar (\",\" intVar)+ \")\")2+\n</matrix> [<index> intVar wspace intVar </index>] <value> intVal | intVar </value>\n</element>\nSemantics 96\nelement-matrix(M, v), with M = [\u3008x1,1, x1,2, . . . , x1,m\u3009, \u3008x2,1, x2,2, . . . , x2,m\u3009, . . .], iff \u2203(i, j) : 1 \u2264 i \u2264 |M| \u2227 1 \u2264 j \u2264 m \u2227 xi,j = v element-matrix(M, \u3008i, j\u3009, v), with M = [\u3008x1,1, x1,2, . . . , x1,m\u3009, \u3008x2,1, x2,2, . . . , x2,m\u3009, . . .], iff xi,j = v\n129\nExample 107\n<element >\n<matrix >\n(x1 ,x2 ,x3) (y1 ,y2 ,y3) (z1 ,z2 ,z3)\n</matrix > <index > i j </index > <value > 5 </value >\n</element >\n7.2.4 Constraint cardinality-matrix\nThe constraint cardinality-matrix, see [114], ensures a constraint cardinality on each row and each column. For managing cardinality of values, elements <rowOccurs> and <colOccurs> are introduced. Below, we only describe the variant with cardinality variables.\nSyntax 136\n<cardinality>\n<matrix> (\"(\" intVar (\",\" intVar)+ \")\")2+ </matrix> <values> (intVal wspace)+ </values> <rowOccurs> (\"(\" intVar (\",\" intVar)+ \")\")2+ </rowOccurs> <colOccurs> (\"(\" intVar (\",\" intVar)+ \")\")2+ </colOccurs>\n</cardinality>\nSemantics 97\ncardinality-matrix(M, V, R,C), with M = [X1, X2, . . . , Xn], R = \u3008R1, R2, . . . , Rn\u3009 C = \u3008C1, C2, . . . , Cm\u3009, iff\n\u2200i : 1 \u2264 i \u2264 n, cardinality(M[i], V, R[i]) \u2200j : 1 \u2264 j \u2264 m, cardinality(MT [j], V, C[j])\nPrerequisite : \u2200i : 1 \u2264 i \u2264 n, |Xi| = m \u2227 \u2200i : 1 \u2264 i \u2264 n, |Ri| = |V | \u2227 \u2200j : 1 \u2264 j \u2264 m, |Cj | = |V |\nExample 108\n<cardinality id=\"c\">\n<matrix >\n(x1 ,x2 ,x3 ,x4) (y1 ,y2 ,y3 ,y4) (z1 ,z2 ,z3 ,z4)\n</matrix > <values > 0 1 </values > <rowOccurs > (r10 ,r11)(r20 ,r21)(r30 ,r31) </rowOccurs > <colOccurs > (c10 ,c11)(c20 ,c21)(c30 ,c31)(c40 ,c41) </colOccurs >\n</cardinality >\n130"}, {"heading": "7.3 Restricted Constraints", "text": "A few global constraints are defined as specific restricted cases of other ones; restricting means here hardening. For example, allDifferentSymmetric and increasingNValues are restricted versions of allDifferent and nValues, respectively. Of course, one can always simply post two distinct constraints instead of a combined restricted one in order to to get something equivalent. However, it is useful to keep partly the model\u2019s structure and to inform solvers that it is possible to treat combinations of constraints as a single constraint over the same list of variables. That is why we define an attribute restriction, which can be added to any element containing a list of variables, i.e., any element <list>. This attribute can be assigned either a restriction or a list of restrictions (whitespace as separator), chosen among the following list:\n\u2022 \"allDifferent\" \u2022 \"increasing\" \u2022 \"strictlyIncreasing\" \u2022 \"decreasing\" \u2022 \"strictlyDecreasing\" \u2022 \"irreflexive\" \u2022 \"symmetric\" \u2022 \"convex\" When applied to an element <list>, inside any XCSP3 constraint element ctr, we obtain the following syntax: Note that a possible alternative is to use the meta-constraint and, but the solution we present here is simpler and more compact.\nSyntax 137\n<ctr>\n... <list restriction=\"restrictionList\"> ... </list> ...\n</ctr>\nBecause there is usually no ambiguity in the way a restriction applies, a constraint ctr, with restriction res, will be denoted by ctr .res, as for example allDifferent .symmetric. The semantics of each restriction type is defined below. For simplicity when introducing the semantics, we assume below that the value of the attribute startIndex, associated with the list (sequence) of variables X, is equal to 1 (although it is 0, by default).\nSemantics 98\nallDifferent(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X|,xi 6= xj increasing(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i < |X|,xi \u2264 xi+1 strictlyIncreasing(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i < |X|,xi < xi+1\n131\ndecreasing(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |X|,xi \u2265 xi+1 strictlyDecreasing(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |X|,xi > xi+1 irreflexive(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |X|,xi 6= i symmetric(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200(i, j) : 1 \u2264 i < j \u2264 |X|,xi = j \u21d4 xj = i convex(X), with X = \u3008x1, x2, . . .\u3009, iff \u2200v : min(X) \u2264 v \u2264 max(X), v \u2208X\nRemark 32 If the value of the attribute startIndex associated with the list X is denoted by start, then the conditions expressed for irreflexive and symmetric must be of the form xi 6= i\u2212 1 + start.\n7.3.1 Constraint allDifferent.symmetric\nThe constraint allDifferent.symmetric [111] is a classical restriction of allDifferent. Not only all variables must take different values, but they must also be either grouped by pairs or left alone. It is thus implicit that the variables cannot be symbolic since values must correspond to indexes. If the ith variable is assigned the value representing element j with i 6= j, then the jth variable must be assigned the value representing element i. The constraint allDifferent.symmetric is expressed by setting the attribute restriction of <list> to the value \"symmetric\".\nSemantics 99\nallDifferent . symmetric(X), with X = \u3008x1, x2, . . .\u3009, iff allDifferent(X) \u2227 symmetric(X)\nExample 109\n<allDifferent >\n<list restriction=\"symmetric\"> x1 x2 x3 x4 x5 </list >\n</allDifferent >\n7.3.2 Constraint allDifferent.symmetric+irreflexive\nThe constraint allDifferent .symmetric can be further restricted by forcing irreflexivity. This is called oneFactor in [64]. By forbidding every variable to be assigned the value representing its own index, all variables are necessarily grouped by pairs. The constraint allDifferent.symmetric+irreflexive is expressed by setting the attribute restriction of <list> to the value \"symmetric irreflexive\".\n132\nSemantics 100\nallDifferent . symmetric + irreflexive(X), with X = \u3008x1, x2, . . .\u3009, iff allDifferent . symmetric(X) \u2227 irreflexive(X)\nExample 110\n<allDifferent >\n<list restriction=\"symmetric irreflexive\"> X[] </list >\n</allDifferent >\n7.3.3 Constraint allDifferent.convex\nThe constraint allDifferent .convex is called alldifferent consecutive values in the Global Constraint Catalog. Not only all variables must take different values, but they must also be consecutive. The constraint allDifferent.convex is expressed by setting the attribute restriction of <list> to the value \"convex\".\nSemantics 101\nallDifferent . convex(X), with X = \u3008x1, x2, . . .\u3009, iff allDifferent(X) \u2227 convex(X)\nExample 111\n<allDifferent >\n<list restriction=\"convex\"> x1 x2 x3 x4 </list >\n</allDifferent >\n7.3.4 Constraint nValues.increasing\nThe constraint nValues .increasing [10] combines nValues and ordered :increasing. It is expressed by setting the attribute restriction of <list> to the value \"increasing\".\nSemantics 102\nnValues . increasing(X, ( , k)), with X = \u3008x1, x2, . . .\u3009, iff nValues(X, ( , k)) \u2227 increasing(X)\nIn the following example, the constraint c enforces the array of variables X to be in increasing order and to take exactly 2 different values.\n133\nExample 112\n<nValues id=\"c\">\n<list restriction=\"increasing\"> X[] </list > <condition > (eq ,2) </condition >\n</nValues >\n7.3.5 Constraint cardinality.increasing\nThe constraint cardinality.increasing, capturing increasing global cardinality in the Global Constraint Catalog, is the conjunction of cardinality and ordered (with operator \u2264). It is obtained by adding \"increasing\" as restriction to the element <list> of the XCSP3 constraint element <cardinality>.\nSemantics 103\ncardinality . increasing(X,V,O), with X = \u3008x1, x2, . . .\u3009, iff cardinality(X,V,O) \u2227 ordered(X,\u2264)\nBelow, the constraint c enforces the variables x1, x2, x3, x4 to be in increasing order and to be assigned between 1 and 3 occurrences of value 2 and between 1 and 3 occurrences of value 4. Note that the values taken by these variables do not necessarily have to be in {2, 4} since the attribute closed is set to \"false\".\nExample 113\n<cardinality id=\"c\">\n<list restriction=\"increasing\"> x1 x2 x3 x4 </list > <values closed=\"false\"> 2 4 </values > <occurs > 1..3 1..3 </occurs >\n</cardinality >\n7.3.6 Constraint permutation.increasing (sort)\nThe constraint permutation.increasing, often called sort in the literature, is the conjunction of permutation and ordered (with operator \u2264). It is obtained by adding \"increasing\" as restriction to the second element <list> of the XCSP3 constraint element <permutation>.\nSemantics 104\npermutation . increasing(X,Y ), with X = \u3008x1, x2, . . .\u3009 and Y = \u3008y1, y2, . . .\u3009, iff permutation(X,Y ) \u2227 ordered(Y,\u2264)\npermutation . increasing(X,Y,M) iff\npermutation(X,Y,M)) \u2227 ordered(Y,\u2264)\nPrerequisite : |X| = |Y | = |M | > 1\n134\nExample 114\n<permutation id=\"c1\">\n<list > x1 x2 x3 x4 </list > <list restriction=\"increasing\"> y1 y2 y3 y4 </list >\n</permutation > <permutation id=\"c2\">\n<list > v1 v2 v3 </list > <list restriction=\"increasing\"> v4 v5 v6 </list > <mapping > m1 m2 m3 </mapping >\n<permutation >\n7.3.7 Constraint sumCosts.allDifferent\nThe constraint sumCosts .allDifferent [52], also called minimumWeightAllDifferent in the literature, is the conjunction of sumCosts and allDifferent. It is obtained by adding \"allDifferent\" as restriction to the element <list> of the XCSP3 constraint element <sumCosts>.\nExample 115\n<sumCosts id=\"c\">\n<list restriction=\"allDifferent\"> y1 y2 y3 </list > <costMatrix >\n(10,0,5) // costs for y1 (0,5,0) // costs for y2 (5,10,0) // costs for y3\n</costMatrix > <condition > (eq,z) </condition >\n</sumCosts >\n135\n8 Meta-Constraints\nIn this chapter, we present general mechanisms that can be used to combine constraints. Sometimes in the literature, they are called meta-constraints. We have:\n\u2022 sliding mechanisms over sequences of variables: slide and seqbin \u2022 logical mechanisms over constraints: and, or and not They are referred to by <metaConstraint.../> in Chapter 1.\nRemark 33 Note that all meta-constraints introduced in this chapter (slide, seqbin, and, or, not) can be reified as they are all considered as single constraints; for reification, see Section 10.3.\n8.1 Meta-Constraint slide\nA general mechanism, or meta-constraint, that is useful to post constraints on sequences of variables is slide [20]. The scheme slide ensures that a given constraint is enforced all along a sequence of variables. To represent such sliding constraints in XCSP3, we simply build an element <slide> containing a constraint template (for example, one for <extension> or <intension>) to indicate the abstract (parameterized) form of the constraint to be slided, preceded by an element <list> that indicates the sequence of variables on which the constraint must slide. Constraint templates are described in Section 10.1, and possible expressions of <constraint.../> are given in Appendix B. The attribute circular of <slide> is optional (\"false\", by default); when set to \"true\", the constraint is slided circularly. The attribute offset of <list> is optional (value 1, by default); it permits, when sliding, to skip more than just one variable of the sequence, capturing slidej in [20].\n136\nSyntax 138\n<slide [circular=\"boolean\"]>\n<list [offset=\"integer\"]> (intVar wspace)2+ </list> <constraint.../> // constraint template, i.e., constraint involving parameters\n</slide>\nFor the semantics, we consider that ctr(%0, . . . ,%q \u2212 1) denotes the template of the constraint ctr of arity q, and that slidecirc means the circular form of slide (i.e., with circular=\"true\" in XCSP3).\nSemantics 105\nslide(X, ctr(%0, . . . ,%q \u2212 1)), with X = \u3008x0, x1, . . .\u3009, iff \u2200i : 0 \u2264 i \u2264 |X| \u2212 q, ctr(xi, xi+1, . . . , xi+q\u22121) slide(X, os, ctr(%0, . . . ,%q \u2212 1)), with an offset os, iff \u2200i : 0 \u2264 i \u2264 (|X| \u2212 q)/os, ctr(xi\u00d7os , xi\u00d7os+1, . . . , xi\u00d7os+q\u22121) slidecirc(X, ctr(%0, . . . ,%q \u2212 1)) iff \u2200i : 0 \u2264 i \u2264 |X| \u2212 q + 1, ctr(xi, xi+1 . . . , x(i+q\u22121)%|X|)\nIn the following example, c1 is the constraint x1 +x2 = x3 \u2227 x2 +x3 = x4, c2 is the circular sliding table constraint (y1, y2) \u2208 T \u2227 (y2, y3) \u2208 T \u2227 (y3, y4) \u2208 T \u2227 (y4, y1) \u2208 T with T = {(a, a), (a, c), (b, b), (c, a), (c, b)} and c3 is the sliding 6= constraint w1 6= z1 \u2227w2 6= z2 \u2227w3 6= z3, with offset 2.\nExample 116\n<slide id=\"c1\">\n<list > x1 x2 x3 x4 </list > <intension > eq(add (%0 ,%1) ,%2) </intension >\n</slide > <slide id=\"c2\" circular=\"true\">\n<list > y1 y2 y3 y4 </list > <extension >\n<list > %0 %1 </list > <supports > (a,a)(a,c)(b,b)(c,a)(c,b) </supports >\n</extension >\n</slide > <slide id=\"c3\">\n<list offset=\"2\"> w1 z1 w2 z2 w3 z3 </list > <intension > ne(%0 ,%1) </intension >\n</slide >\nIn some cases, it may be more practical to handle more than one sliding list. This is the reason we can put several successive elements <list>. In that case, variables are collected from list to list in the order they are put (all variables of a list are considered before starting with the next list). The number of variables to be collected from one list at each iteration is given by the optional attribute collect (value 1, by default). The attribute offset can be associated independently with each list.\nThe general syntax is:\n137\nSyntax 139\n<slide>\n(<list [offset=\"integer\"] [collect=\"integer\"]> (intVar wspace)+ </list>)2+\n<constraint.../> // constraint template, i.e., constraint involving parameters\n</slide>\nAs an illustration, the following constraint c4 corresponds to x1 + y1 = z1 \u2227 x2 + y2 = z2 \u2227 x3 + y3 = z3.\nExample 117\n<slide id=\"c4\">\n<list offset=\"2\" collect=\"2\"> x1 y1 x2 y2 x3 y3 </list > <list > z1 z2 z3 </list > <intension > eq(add (%0 ,%1) ,%2) </intension >\n</slide >\nRemark 34 Note that slide\n\u2022 can be relaxed/softened, obtaining then cardPath; see Section 9.4.2; \u2022 cannot be a descendant of (i.e., involved in) an element <group>, <slide> or <seqbin>.\n8.2 Some Classical Uses of slide\n8.2.1 Constraint sequence\nThe constraint sequence, see [8, 113], also called among seq in [4], enforces a set of count constraints over a sequence of variables. Although it can be represented by slide, we introduce this specific constraint because it is often used. The arity of sliding constraints is given by the attribute window.\nSyntax 140\n<sequence>\n<list window=\"integer\"> (intVar wspace)2+ </list> <values> (intVal wspace)+ </values> <condition> \"(\" operator \",\" operand \")\" </condition>\n</sequence>\nFor the semantics below, the arity of sliding constraints (i.e., the window size) is given by q, the set of values by V and the condition by ( , k) (classically, corresponding to an interval l..u of possible cumulated occurrences).\nSemantics 106\nsequence(X, q, V, ( , k), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |X| \u2212 q + 1, count(\u3008xi+j \u2208 X : 0 \u2264 j < q\u3009, V, ( , k))\nThe following constraint\n138\nsequence(\u3008x1, x2, x3, x4, x5\u3009, 3, {0, 2, 4}, (\u2208, 0..1))\nis then equivalent to:\ncount(\u3008x1, x2, x3\u3009, {0, 2, 4}, (\u2208, 0..1)) \u2227 count(\u3008x2, x3, x4\u3009, {0, 2, 4}, (\u2208, 0..1)) \u2227 count(\u3008x3, x4, x5\u3009, {0, 2, 4}, (\u2208, 0..1))\nThis gives in XCSP3:\nExample 118\n<sequence id=\"c\">\n<list window=\"3\"> x1 x2 x3 x4 x5 </list > <values > 0 2 4 </values > <condition > (in ,0..1) </condition >\n</sequence >\nand with slide:\nExample 119\n<slide id=\"c\">\n<list > x1 x2 x3 x4 x5 </list > <count >\n<list > %0 %1 %2 </list > <values > 0 2 4 </values > <condition > (in ,0..1) </condition >\n</count >\n</slide >\n8.2.2 Constraint slidingSum\nThe constraint slidingSum [4], enforces a set of sum constraints over a sequence of variables. For the semantics below, the arity of sliding constraints is given by q, and the interval of possible values for the sum by l..u.\nSemantics 107\nslidingSum(X, q, l..u), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |X| \u2212 q + 1, l \u2264 \u2211i+q\u22121 j=i xj \u2264 u\nIn the following example, c is the sliding sum 1 \u2264 x1 + x2 + x3 \u2264 3 \u2227 1 \u2264 x2 + x3 + x4 \u2264 3 \u2227 1 \u2264 x3 + x4 + x5 \u2264 3.\n139\nExample 120\n<slide id=\"c\">\n<list > x1 x2 x3 x4 x5 </list > <sum >\n<list > %0 %1 %2 </list > <condition > (in ,1..3) </condition >\n</sum > </slide >\n8.2.3 Constraints change and smooth\nThese two constraints are sliding constraints. However, as they also integrate relaxation, we introduce them in Chapter 9.\n8.3 Meta-Constraint seqbin\nThe meta-constraint seqbin [99, 68] ensures that a binary constraint holds down a sequence of variables, and counts how many times another binary constraint is violated.\nSyntax 141\n<seqbin>\n<list> (intVar wspace)2+ </list> <constraint.../> // template of the hard binary constraint <constraint.../> // template of the soft binary constraint <number> intVal | intVar </number>\n</seqbin>\nThe attribute violable is required (with value \"true\") for the soft binary constraint.\nSemantics 108\nseqbin(X, ctrh(%0,%1), ctrs(%0,%1), z), with X = \u3008x1, x2, . . .\u3009, iff \u2200i : 1 \u2264 i < |X|, ctrh(xi, xi+1) |{i : 1 \u2264 i < |X| \u2227 \u00acctrs(xi, xi+1)}| = z\nRemark 35 Note that in our definition, we do not add 1 to z as proposed in [68], and implicitly defined in [99]. We do believe that it can be easily handled by solvers.\nExample 121\n<seqbin id=\"c1\">\n<list > x1 x2 x3 x4 x5 x6 x7 </list > <intension > ne(%0 ,%1) </intension > <intension violable=\"true\"> lt(%0 ,%1) </intension > <number > y </number >\n140\n</seqbin > <seqbin id=\"c2\">\n<list > w1 w2 w3 w4 w5 w6 </list > <extension >\n<list > %0 %1 </list > <supports > (0,0)(0,1)(0,3)(1,1)(1,2)(2,3)(3,0) </supports >\n</extension > <intension violable=\"true\"> gt(%0 ,%1) </intension > <number > z </number >\n</seqbin >\nRemark 36 Note that seqbin cannot be a descendant of (i.e., involved in) an element <group>, <slide> or <seqbin>.\n8.4 Meta-Constraint and\nSometimes, it may be interesting to combine logically constraints [81, 82]. The meta-constraint and ensures the conjunction of a set of constraints (and possibly, meta-constraints) that are put together inside a same element. This may be useful for obtaining a stronger filtering and/or dealing with reification. Below, <constraint.../> and <metaConstraint.../> represent any constraint and meta-constraint introduced in XCSP3 (see Appendix B for an exhaustive list).\nSyntax 142\n<and>\n(<constraint.../> | <metaConstraint.../>)2+\n</and>\nSemantics 109\nand(ctr1, ctr2, . . . , ctrk) iff\nctr1 \u2227 ctr2 . . . \u2227 ctrk\nThe following example shows a constraint c which is equal to c1 \u2227 c2.\nExample 122\n<and id=\"c\">\n<intension id=\"c1\"> eq(x,add(y,z)) </intension > <extension id=\"c2\">\n<list > x z </list > <supports > (0,1)(1,3)(1,2)(1,3)(2,0)(2,2)(3,1) </supports >\n</extension >\n</and >\nRemark 37 Note that and can be relaxed/softened, obtaining then soft-and; see Section ??.\n141\n8.5 Some Classical Uses of and\nSome constraints conjunction are classical.\n8.5.1 Constraint gen-sequence\nA general form of sequence, with name gen-sequence, has been proposed in [133]. It allows specifying the precise sequences of variables on which a constraint count must hold; so, this is no more exactly a sliding constraint. Each such count constraint is defined by a window (interval p..q, giving the indexes of the variables of the consecutive variables of the window) and a range (interval l..u giving the constraining bounds for the variables of the window).\nSemantics 110\ngen-sequence(X,W, V,R), with X = \u3008x1, x2, . . .\u3009, W = \u3008p1..q1, p2..q2, . . .\u3009, R = \u3008l1..u1, l2..u2, . . .\u3009, iff \u2200i : 1 \u2264 i \u2264 |W |, count(\u3008xj \u2208 X : pi \u2264 j \u2264 qi\u3009, V, (\u2208, li..ui))\nConditions: |W | = |R|\nThe constraint\ngen-sequence(\u3008x0, x1, x2, x3, x4\u3009, \u30080..2, 2..4\u3009, {0, 2, 4}, \u30080..1, 1..2\u3009)\nis equivalent to:\ncount(\u3008x0, x1, x2\u3009, {0, 2, 4}, (\u2208, 0..1)) \u2227 count(\u3008x2, x3, x4\u3009, {0, 2, 4}, (\u2208, 1..2))\nIn XCSP3, we simply combine the two constraints by and.\nExample 123\n<and >\n<count >\n<list > x0 x1 x2 </list > <values > 0 2 4 </values > <condition > (in ,0..1) </condition >\n</count > <count >\n<list > x2 x3 x4 </list > <values > 0 2 4 </values > <condition > (in ,1..2) </condition >\n</count >\n</slide >\n8.5.2 Constraint gsc\nThe global sequencing constraint (gsc) [116] combines sequence with cardinality. An example is given below.\n142\nExample 124\n<and id =\"c\">\n<sequence >\n<list id=\"X\" window=\"3\"> x1 x2 x3 x4 x5 </list > <values > 0 2 4 </values > <condition > (in ,0..1) </condition >\n</sequence > <cardinality >\n<list as=\"X\" /> <values > 0 1 </values > <occurs > 0..2 2..3 </occurs >\n</cardinality >\n</and >\n8.5.3 Constraint cardinalityWithCosts\nThe constraint cardinalityWithCosts [112] combines cardinality with sumCosts. An example is given below.\nExample 125\n<and >\n<cardinality >\n<list id=\"X\"> x1 x2 x3 x4 x5 </list > <values > 0 1 2 </values > <occurs > y1 y2 y3 </occurs >\n</cardinality > <sumCosts >\n<list as=\"X\" /> <values cost=\"5\"> 0 2 </values > <values cost=\"0\"> default </values > <condition > (eq,z) </condition >\n</sumCosts >\n</and >\n8.5.4 Constraints costRegular and multicostRegular\nThe constraint costRegular [43] combines regular with sumCosts. An example is given below (variables are assumed to have binary domains).\nExample 126\n<and >\n<regular >\n<list id=\"B\"> b1 b2 b3 b4 </list > <transitions >\n(a,0,a)(a,1,b)(b,0,c)(b,1,d)(c,0,d)\n</transitions >\n143\n<start > a </start > <final > d </final >\n</regular > <sumCosts >\n<list as=\"B\" /> <costMatrix > (10 ,0)(0,5)(5,2)(5,0) </costMatrix > <condition > (le,z) </condition >\n</sumCosts >\n</and >\nIt is possible, by introducing several constraints sumCosts to represent multicostregular [88]."}, {"heading": "8.6 Meta-Constraint or", "text": "The meta-constraint or ensures the disjunction of a set of constraints that are put together inside a same element. This may be useful for modeling and/or dealing with reification.\nSyntax 143\n<or>\n(<constraint.../> | <metaConstraint.../>)2+\n</or>\nSemantics 111\nor(ctr1, ctr2, . . . , ctrk) iff\nctr1 \u2228 ctr2 . . . \u2228 ctrk\nThe following example shows a constraint c which is equal to c1 \u2228 c2.\nExample 127\n<or id=\"c\">\n<intension id=\"c1\"> eq(x,add(y,z)) </intension > <extension id=\"c2\">\n<list > x z </list > <supports > (0,1)(1,3)(1,2)(1,3)(2,0)(2,2)(3,1) </supports >\n</extension >\n</or >\n8.7 Meta-Constraint not\nThe meta-constraint not ensures the negation of a constraint that is put inside the element. This may be useful for modeling and/or dealing with reification.\n144\nSyntax 144\n<not>\n<constraint.../> | <metaConstraint.../>\n</not>\nSemantics 112\nnot(ctr) iff\n\u00acctr\nThe meta-constraint not is also useful to represent well-known global constraints such as notAllEqual ensuring that at least one of the involved variables in the constraint allEqual must differ from the other ones.\nExample 128\n<not >\n<allEqual >\nx1 x2 x3 x4 x5\n</allEqual >\n</not >\n145\n9 Soft Constraints\nIt is sometimes useful, or even necessary, to express preferences or costs when modeling problems. Actually, many works in the literature focus on the concept of costs that can be associated with certain instantiations of variables inside constraints. There are two main ways of integrating costs:\n\u2022 by restricting constraints, this way, additionally ensuring that some introduced costs are within certain limits.\n\u2022 by relaxing constraints, this way, permitting a certain degree of violation with respect to the original forms of constraints;\nIn Chapters 7 and 8, it was shown how to build restricted constraints, either with the attribute restriction or with the meta-constraint and that enables the integration of the cost-related constraint sumCosts.\nIn this chapter, we focus on relaxation, and in this context, we introduce cost-based soft constraints. There are two main ways1 of handling (cost-based) soft constraints. We can deal with hard constraints that are relaxed by integrating cost variables, obtaining so-called relaxed constraints hereafter; see [115, 100, 12]. Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39]. After introducing relaxed constraints and cost functions in Section 9.1, we describe simple relaxation in Section 9.2. In Sections 9.3 and 9.4, complex relaxation for generic constraints and global constraints is presented. Related information concerning WCSP can be found in Section 11.3.1 of Chapter 11.\nAlthough we do not introduce new constraint types (names) in XCSP3, in order to clarify the textual description (and, make semantics unambiguous), we shall refer in the text to a soft variant of a constraint ctr by soft-ctr. For example, we shall refer in the text to soft-allDifferent when considering a soft version of allDifferent.\n1We shall discuss other frameworks for expressing preferences/costs in Chapter 11.\n146"}, {"heading": "9.1 Relaxed Constraints and Cost Functions", "text": "A soft constraint in XCSP3 is an XML constraint element with an attribute type set to the value \"soft\". A soft constraint in XCSP3 is either a relaxed constraint or a cost function.\nRelaxed Constraints. In XCSP3, a relaxed constraint is a constraint explicitly integrating a cost component. This means that the XML constraint element contains an element <cost>, which is besides necessarily the last child of the constraint. This new element <cost> can contain a numerical condition (similarly to an element <condition>), which typically involves a cost variable as operand: the actual cost of an instantiation is related to the value of the cost variable with respect to the specified relational operator. The element <cost> can also simply contain an integer variable: in that case, the value of this variable represents exactly the cost of the constraint, and we have intVar which is equivalent to \"(eq,\" intVar \")\". As we shall see in the next sections, some optional attributes in mutual exclusion, called violationCost, defaultCost and violationMeasure, can also be specifically introduced.\nThe syntax is as follows:\nSyntax 145\n<constraint type=\"soft\" [violationCost=\"integer\" |\ndefaultCost=\"integer\" | violationMeasure=\"measureType\"]>\n... <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</constraint>\nRemark 38 It is important to note that a relaxed constraint remains a hard constraint. Either it is satisfied because the cost condition holds, or it is not.\nCost Functions. In XCSP3, a cost function is defined similarly to a relaxed constraint, except that it does not integrate the cost component (element <cost>). A cost function is not a constraint since it returns integer values and not Boolean values.\nRemark 39 It is possible to mix hard constraints with relaxed constraints and cost functions. However, when an XCSP3 instance involves at least one cost function, the attribute type for <instance> must be given the value \"WCSP\" and no objectives must be present (because the objective function is implicitly defined).\nMany illustrations (especially showing the difference between the use of relaxed constraints and cost functions) are given in the next sections."}, {"heading": "9.2 Simple Relaxation", "text": "The simplest relaxation mechanism consists in associating a fixed integer cost q with some constraints. The cost of the constraint is 0 when the constraint is satisfied, and q otherwise. To deal with simple relaxation, which can be applied to any types of constraints, it suffices to introduce the attribute violationCost whose value must be an integer value.\n147\nAs an illustration, let us consider a very basic problem: \u201cLucy, Mary, and Paul want to align in one row for taking a photo. Some of them have preferences next to whom they want to stand: Lucy wants to stand at the left of Mary and Paul also wants to stand at the left of Mary.\u201d. Not satisfying Lucy\u2019s preference costs 3 while not satisfying Paul\u2019s preference costs 2. The objective here is to minimize the sum of violation costs.\nIllustration with Relaxed Constraints. First, let us represent this problem with relaxed constraints. We have three variables for denoting the positions (numbered 1, 2 and 3 from left to right) of Lucy, Mary and Paul in the row. We have a hard constraint allDifferent and two relaxed constraints (note that we need to introduce two variables for representing the violation costs associated with the preferences expressed by Lucy and Paul). Finally, we have an explicit objective: minimizing the sum of the violation costs.\nExample 129\n<instance format=\"XCSP3\" type=\"COP\">\n<variables >\n<var id=\"lucy\"> 1..3 </var > <var id=\"mary\"> 1..3 </var > <var id=\"paul\"> 1..3 </var > <var id=\"z1\"> 0 3 </var > <var id=\"z2\"> 0 2 </var >\n</variables > <constraints >\n<allDifferent > lucy mary paul </allDifferent > <intension type=\"soft\" violationCost=\"3\">\n<function > eq(lucy ,sub(mary ,1)) </function > <cost > z1 </cost >\n</intension > <intension type=\"soft\" violationCost=\"2\">\n<function > eq(paul ,sub(mary ,1)) </function > <cost > z2 </cost >\n</intension > </constraints > <objectives >\n<minimize type=\"sum\"> z1 z2 </minimize >\n</objectives >\n</instance >\nIllustration with Cost Functions. Now, let us represent this problem with cost functions. We still have three variables for denoting the positions (numbered 1, 2 and 3 from left to right) of Lucy, Mary and Paul in the row. We have a hard constraint allDifferent and two cost functions for representing the preferences expressed by Lucy and Paul. Note that we do not need to introduce cost variables and to define an explicit objective (WCSP is discussed with more details in Section 11.3.1).\n148\nExample 130\n<instance format=\"XCSP3\" type=\"WCSP\">\n<variables >\n<var id=\"lucy\"> 1..3 </var > <var id=\"mary\"> 1..3 </var > <var id=\"paul\"> 1..3 </var >\n</variables > <constraints >\n<allDifferent > lucy mary paul </allDifferent > <intension type=\"soft\" violationCost=\"3\">\neq(lucy ,sub(mary ,1))\n</intension > <intension type=\"soft\" violationCost=\"2\">\neq(paul ,add(lucy ,1))\n</intension > </constraints >\n</instance >"}, {"heading": "9.3 Complex Relaxation of Generic Constraints", "text": "In this section, we show how to build complex relaxation of the generic constraint types <intension> and <extension>. This relaxation form is more general than the simple one described in Section 9.2 (but dedicated to these two special constraint types). Note that for these two constraint types, we need to modify the way these constraints are classically built: an integer function replaces a Boolean function (predicate), and elements <tuple> replace elements <supports> and <conflicts>, respectively.\n9.3.1 Constraint soft-intension\nWhen relaxing an intensional constraint, one has first to replace in <function> the predicate expression (that returns either 0, standing for false, or 1, standing for true) by an integer functional expression (that may return any integer, and should return 0 when the original constraint is satisfied), which is referred to as intExpr in the syntax boxes below, and whose precise syntax is given in Appendix B.\nConstraint soft-intension as a Relaxed Constraint. We have to introduce an element <cost>, which gives the following syntax:\nSyntax 146\n<intension type=\"soft\">\n<function> intExpr </function> <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</intension>\nBelow, F denotes a function (functional expression) with r formal parameters (not shown here, for simplicity), X = \u3008x1, x2, . . . , xr\u3009 a sequence of r variables, and F (x1,x2, . . . ,xr) the\n149\nvalue returned by function F for a given instantiation of variables in X. The numerical cost condition is represented by ( , z).\nSemantics 113\nsoft-intension(F,X, ( , z)), with X = \u3008x1, x2, . . . , xr\u3009, iff F (x1,x2, . . . ,xr) z\nFor example, suppose that we want to use |x\u2212 y| as cost for the relaxed form of constraint x = y, and make this value equal to a cost variable z. We obtain constraint c1 below. Now, suppose that we want to use (v \u2212 w)2 as cost for the relaxed form of constraint v \u2264 w. Note that we need to be careful about ensuring that the cost is 0 when the constraint is satisfied. Here, the cost must be less than or equal to the value of a cost variable u. We obtain constraint c2.\nExample 131\n<intension id=\"c1\" type=\"soft\">\n<function > dist(x,y) </function > <cost > z </cost >\n</intension > <intension id=\"c2\" type=\"soft\">\n<function > if(le(v,w) ,0,sqr(sub(v,w))) </function > <cost > (le,u) </cost >\n</intension >\nConstraint soft-intension as a Cost Function. The syntax is given by:\nSyntax 147\n<intension type=\"soft\">\n<function> intExpr </function>\n</intension>\nThe opening and closing tags of <function> are optional, which gives:\nSyntax 148\n<intension type=\"soft\"> intExpr </intension> // Simplified Form\nFor example, suppose that we want to use |x\u2212 y| as cost function. We obtain constraint c1 below. Now, suppose that we want to use (v \u2212 w)2 as cost function when v > w. Again, note that we need to be careful about ensuring that the cost is 0 when the constraint is satisfied. We obtain constraint c2.\n150\nExample 132\n<intension id=\"c1\" type=\"soft\">\ndist(x,y) </intension > <intension id=\"c2\" type=\"soft\">\nif(le(v,w) ,0,sqr(sub(v,w)))\n</intension >\n9.3.2 Constraint soft-extension\nWhen relaxing an extensional constraint, one has first to refine the enumeration of tuples, by indicating the cost for each of them. The elements <supports> and <conflicts> are then replaced by a sequence of elements <tuples>, where each element <tuples> has a required attribute cost that gives the common cost of all tuples contained inside the element. It is necessary to use the attribute defaultCost of <extension> to specify the cost of all implicit tuples (i.e., those not explicitly listed).\nConstraint soft-extension as a Relaxed Constraint. As usual, we have to introduce an element <cost>. This gives the following syntax for extensional constraints of arity greater than or equal to 2:\nSyntax 149\n<extension type=\"soft\" defaultCost=\"integer\">\n<list> (intVar wspace)2+ </list> (<tuples cost=\"integer\"> (\"(\" intVal (\",\" intVal)+ \")\")+ </tuples>)+ <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</extension>\nSemantics 114\nsoft-extension(X, T , ( , z)), with X = \u3008x1, x2, . . . , xr\u3009, T = \u3008T1, T2, . . .\u3009 where each Ti is a set of tuples of cost cost(Ti), iff\n\u3008x1,x2, . . . ,xr\u3009 \u2208 Ti \u21d2 cost(Ti) z\nConditions:\n\u2200i : 1 \u2264 i \u2264 |T |, \u2200\u03c4 \u2208 Ti, |\u03c4 | = |X| \u2200(i, j) : 1 \u2264 i < j \u2264 |T |, Ti \u2229 Tj = \u2205 \u2200\u03c4 \u2208 dom(x1)\u00d7 dom(x2)\u00d7 . . .\u00d7 dom(xr), \u2203i : 1 \u2264 i \u2264 |T | \u2227 \u03c4 \u2208 Ti\nAssume that we have a relaxed extensional constraint involving three variables x1, x2, x3, each of them with domain {1, 2}. Assume that the cost for tuples \u30081, 2, 2\u3009, \u30082, 1, 2\u3009 and \u30082, 2, 1\u3009 is 10, the cost for tuples \u30081, 1, 2\u3009 and \u30081, 1, 3\u3009 is 5, and the cost for all other tuples \u2013that is, \u30081, 1, 1\u3009, \u30081, 2, 1\u3009, \u30082, 1, 1\u3009, \u30082, 2, 2\u3009\u2013 is 0. If the cost of an instantiation must be given by a cost variable z, we write:\n151\nExample 133\n<extension type=\"soft\" defaultCost=\"0\">\n<list > x1 x2 x3 </list > <tuples cost=\"10\"> (1,2,2)(2,1,2)(2,2,1) </tuples > <tuples cost=\"5\"> (1,1,2)(1,1,3) </tuples > <cost > z </cost >\n</extension >\nFor a unary constraint, we obtain:\nSyntax 150\n<extension type=\"soft\" defaultCost=\"integer\">\n<list> intVar </list> (<tuples cost=\"integer\"> ((intVal | intIntvl) wspace)+ </tuples>)+ <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</extension>\nConstraint soft-extension as a Cost Function. We have the following syntax for cost functions of arity greater than or equal to 2:\nSyntax 151\n<extension type=\"soft\" defaultCost=\"integer\">\n<list> (intVar wspace)2+ </list> (<tuples cost=\"integer\"> (\"(\" intVal (\",\" intVal)+ \")\")+ </tuples>)+\n</extension>\nThe previous example gives under the form of a cost function:\nExample 134\n<extension type=\"soft\" defaultCost=\"0\">\n<list > x1 x2 x3 </list > <tuples cost=\"10\"> (1,2,2)(2,1,2)(2,2,1) </tuples > <tuples cost=\"5\"> (1,1,2)(1,1,3) </tuples >\n</extension >\nFor a unary cost function, we obtain:\nSyntax 152\n<extension type=\"soft\" defaultCost=\"integer\">\n<list> intVar </list> (<tuples cost=\"integer\"> ((intVal | intIntvl) wspace)+ </tuples>)+\n</extension>\n152"}, {"heading": "9.4 Complex Relaxation of Global Constraints", "text": "In this section, we show how to build complex relaxation of (some) global constraints. This relaxation form is more general than the simple one described in Section 9.2. The way global constraints are defined (i.e., their intern elements or parameters) remains the same, contrary to what we have seen for <intension> and <extension> in Section 9.3.\nFor global constraints, the attribute violationMeasure, when present, indicates the violation measure used to assess the cost of the constraints. Currently, there are four pre-defined values, but in the future, other values might be introduced too. A default violation measure is considered when this attribute is not present.\nIt is then possible to soften global constraints by referring to some known violation measures [101, 130]. A violation measure \u00b5 is simply a cost function that guarantees that cost 0 is associated with, and only with, any tuple that fully satisfies the constraint. Two following violation measures are general-purpose:\n\u2022 \"var\": it measures the number of variables that need to change their values in order to satisfy the constraint\n\u2022 \"dec\": it measures the number of violated constraints in the binary decomposition of the constraint\nRemark 40 In the future, we might introduce an additional attribute violationParameters to provide some information needed by some violation measures. For example, the violation measure \"var\" can be refined [12] by indicating the subset of variables that are allowed to change their values, when measuring.\nRemark 41 The measure \"dec\", although a general scheme, cannot always be used: for some global constraints, no natural binary decomposition is known.\nLet us say a few words about the semantics, when considering relaxed global constraints. For the semantics, we consider that soft-ctr\u00b5 is the relaxed form of the global constraint ctr of scope X, considering the violation measure \u00b5. We also consider that \u00b5 applied to the constraint ctr returns the cost for any given instantiation of X, and that ( , z) represents the numerical cost condition.\nSemantics 115\nsoft-ctr\u00b5(X, ( , z)), with X = \u3008x1, x2, . . . , xr\u3009, iff \u00b5(ctr(x1,x2, . . . ,xr)) z\nFinally, when several constraints are at stake, the attribute violationMeasure is usually absent, implicitly referring to the number of constraints that are violated in a set. In the next subsections, we only focus on relaxed global constraints. For global cost functions, it suffices to remove systematically the element <cost>.\n9.4.1 Constraint soft-and (Cardinality Operator)\nThe cardinality operator [129], which must not be confused with the cardinality constraint, connects a cost variable with a set (conjunction) of constraints: the value of the cost variable is the number of violated constraints in the set. In XCSP3, we just need to relax the element <and>; the violation measure is implicit: it counts the number of violated constraints. Note\n153\nthat we use a violation measure, and not a satisfaction measure; it is immediate to pass from one form to the other.\nSyntax 153\n<and type=\"soft\">\n(<constraint.../> | <metaConstraint.../>)2+ <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</and>\nSemantics 116\nsoft-and(ctr1, ctr2, . . . , ctrk, ( , z)), iff |{i : 1 \u2264 i \u2264 k \u2227 \u00acctri}| z\nAn example is given below for a conjunction of three constraints.\nExample 135\n<and type=\"soft\">\n<intension > eq(w,add(x,y)) </intension > <extension >\n<list > v w </list > <supports > (0,1)(1,3)(1,2)(1,3)(2,0)(2,2)(3,1) </supports >\n</extension > <allDifferent > v w x y </allDifferent > <cost > z </cost >\n</and >\n9.4.2 Constraint soft-slide (cardPath)\nA general scheme, or meta-constraint, that is useful to post constraints on sequences of variables is cardPath [4]. In XCSP3, we just need to relax the element <slide>; the violation measure is implicit: it counts the number of violated constraints.\nSyntax 154\n<slide [circular=\"boolean\"] type=\"soft\">\n<list [offset=\"integer\"]> (intVar wspace)+ </list> <constraint.../> // constraint template, i.e., constraint involving parameters <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</slide>\nSemantics 117\nsoft-slide(X, ctr(%1, . . . ,%q), ( , z)), with X = \u3008x1, x2, . . .\u3009 iff |{i : 1 \u2264 i \u2264 |X| \u2212 q + 1 \u2227 \u00acctr(xi, . . . ,xi+q\u22121)| z\n154\nWe first illustrate soft-slide with the constraint change that constrains the number of times an inequality (or another relational operator) holds over a sequence of variables.\nSemantics 118\nchange(X, , z), with X = \u3008x1, x2, . . .\u3009 and \u2208 {<,\u2264, >,\u2265,=, 6=}, iff |{i : 1 \u2264 i < |X| \u2227 xi xi+1}| = z\nConsidering that we use a violation measure, and not a satisfaction measure, one can indirectly represent change, as in the following example (where z is the complementary value of the one given in the semantics).\nExample 136\n<slide id=\"c1\" type=\"soft\">\n<list > x1 x2 x3 x4 x5 </list > <intension > ne(%0 ,%1) </intension > <cost > z </cost >\n</slide >\nWe now illustrate soft-slide with the constraint smooth that constrains the number of times a binary constraint comparing a distance between two successive variables and a specified limit holds over a sequence of variables.\nSemantics 119\nsmooth(X, l, z), with X = \u3008x1, x2, . . .\u3009, iff |{i : 1 \u2264 i < |X| \u2227 |xi \u2212 xi+1| > l}| = z\nConsidering that we use a violation measure, and not a satisfaction measure, one can indirectly represent smooth, as in the following example.\nExample 137\n<slide id=\"c2\" type=\"soft\">\n<list > y1 y2 y3 y4 </list > <intension > gt(dist (%0 ,%1) ,2) </intension > <cost > w </cost >\n</slide >\nFinally, we illustrate soft-slide with the constraint softSlidingSum [4].\nSemantics 120\nsoftSlidingSum(X, q, l..u,min..max ), with X = \u3008x1, x2, . . .\u3009, iff |{i : 1 \u2264 i \u2264 |X| \u2212 q + 1 \u2227 l \u2264 \u2211i+q\u22121 j=i xj \u2264 u}| \u2208 min..max\nIn the following example, c3 is the XCSP3 form of the relaxed sliding sum 1 \u2264 x1+x2+x3 \u2264 3 \u2227 1 \u2264 x2 + x3 + x4 \u2264 3 \u2227 1 \u2264 x3 + x4 + x5 \u2264 3 with the constraint that 2 or 3 constraints must be satisfied. Note that the range is 0..1, the complementary of 2..3.\n155\nExample 138\n<slide id=\"c3\" type=\"soft\">\n<list > x1 x2 x3 x4 x5 </list > <sum >\n<list > %0 %1 %2 </list > <condition > (le ,3) </condition >\n</sum > <cost > (in ,0..1) </cost >\n</slide >\n9.4.3 Constraint soft-allDifferent\nFor the relaxed version [101, 132] of allDifferent, we can use the two general-purpose violation measures \"var\" and \"dec\". We only give here the syntax for the relaxed basic variant (and without <except>) of allDifferent.\nSyntax 155\n<allDifferent type=\"soft\" violationMeasure=\"var|dec\">\n<list> (intVar wspace)2+ </list> <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</allDifferent>\nFor the measure \"dec\", the semantics is:\nSemantics 121\nsoft-allDifferentdec(X, ( , z)), with X = \u3008x1, x2, . . .\u3009, \u2208 {<,\u2264, >,\u2265,=, 6=}, iff |{(i, j) : 1 \u2264 i < j \u2264 |X| \u2227 xi = xj}| z\nAn example is given below:\nExample 139\n<allDifferent type=\"soft\" violationMeasure=\"dec\">\n<list > x1 x2 x3 x4 x5 </list > <cost > (le,z) </cost >\n</allDifferent >\n9.4.4 Constraint soft-cardinality\nFor the soft version of cardinality, we can use \"var\" as well as the measure \"val\" defined in [130].\n156\nSyntax 156\n<cardinality type=\"soft\" violationMeasure=\"var|val\">\n<list> (intVar wspace)2+ </list> <values [closed=\"boolean\"]> (intVal wspace)+ | (intVar wspace)+ </values> <occurs> (intVal wspace)+ | (intVar wspace)+ | (intIntvl wspace)+ </occurs> <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</cardinality>\n9.4.5 Constraint soft-regular\nFor the relaxed version of regular, we can use \"var\" as well as the measure \"edit\" defined in [130].\nSyntax 157\n<regular type=\"soft\" violationMeasure=\"var|edit\">\n<list> (intVar wspace)+ </list> <transitions> (\"(\" state \",\" intVal \",\" state \")\")+ </transitions> <start> state </start> <final> (state wspace)+ </final> <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</regular>\n9.4.6 Constraint soft-permutation (same)\nFor the relaxed version of permutation (same), we can use \"var\" [130], while discarding the optional element <mapping> of the hard version.\nSyntax 158\n<permutation type=\"soft\" violationMeasure=\"var\">\n<list> (intVar wspace)2+ </list> <list [startIndex=\"integer\"]> (intVar wspace)2+ </list> <cost> \"(\" operator \",\" operand \")\" | intVar </cost>\n</permutation>"}, {"heading": "9.5 Summary", "text": "Soft (cost-based) constraints in XCSP3 can be managed by means of either relaxed constraints or cost functions. On the one hand, it is important to note that relaxed constraints must be understood and treated as hard constraints. Simply, they (typically) involve cost variables which can possibly (i.e., not necessarily) be used for optimization. On the other hand, cost functions necessarily imply an implicit optimization task that consists in miminiming the sum of the constraint costs. Currently, in XCSP3, it is not possible to have both a cost function and an explicit objective function (although extensions in the future can be envisioned). Importantly,\n157\nwhen a cost function is present, the type of the instance is necessarily \"WCSP\"; see Section 11.3.1.\nFinally, a soft constraint is easily identifiable: its attribute type is given the value \"soft\". It is also easy to determine whether we have a relaxed constraint or a cost function: just check the presence of an element <cost> (as last child). A simple relaxation will necessarily involve the atribute violationCost.\n158\nPart IV\nGroups, Frameworks and Annotations\n159\n10 Groups, Blocks, Reification,\nViews and Aliases\nSeveral important features of XCSP3 are introduced in this chapter. In particular, groups of constraints are an essential mechanism to preserve the structure of the problem instances."}, {"heading": "10.1 Constraint Templates and Groups", "text": "A constraint template is a kind of constraint abstraction, that is to say, an element representing a constraint in XCSP3 where some formal parameters are present (typically, for representing missing values and/or variables). Such parameters are denoted by the symbol % followed by a parameter index. A constraint template has p \u2265 1 parameters(s), with indices going from 0 to p\u2212 1, and of course, a parameter can appear several times.\nFor example, here is a constraint template, with three parameters, for the element intension:\nExample 140\n<intension > eq(add (%0 ,%1) ,%2) </intension >\nand another one, with two parameters, for the element extension:\nExample 141\n<extension >\n<list > %0 %1 </list > <supports > (1,2)(2,1)(2,3)(3,1)(3,2)(3,3) </supports >\n</extension >\nA constraint template must be used in a context that permits to furnish the actual parameters, or arguments. A first possibility is within constraints slide and seqbin, where\n160\nthe arguments are automatically given by the variables of a sequence (sliding effect). A second possibility is to build an element <group> whose role is to encapsulate a constraint template followed by a sequence of elements <args>. Currently, the constraint template <constraint.../> is either put directly inside <group>, or put indirectly inside <group> through the meta-constraint <not>1. Each element <args> must contain as many arguments as the number of parameters in the constraint template (using whitespace as separator). Of course, the first argument in <args> corresponds to %0, the second one to %1, and so on.\nRemark 42 Do note that a constraint template can only be found in elements <slide>, <seqbin> and <group>, and that no two such elements can be related by an ancestor-descendant relationship.\nConsidering constraints over integer variables, an argument can be any integer functional expression, referred to as intExpr in the syntax box below (its precise syntax is given in Appendix B). When parsing, a solver has to replace the formal parameters of the predicate template by the corresponding arguments to build the constraint.\nAs a formal parameter, in the context of a group, it is also possible to use %... that stands for a variable number of arguments. If %i is the formal parameter with the highest index i present in the template, then %... will be replaced by the sequence (whitespace as separator) of arguments that come after the one associated with %i. If %... is the only formal parameter present in the template, then %... will be replaced by the full sequence of arguments.\nRemark 43 It is currently forbidden to use %... inside elements <slide> and <seqbin>. Also, note that %... can never occur in a functional expression (for example, add(x,%...) is clearly invalid)..\nThe syntax for the element <group>, admitting an optional attribute id, is:\nSyntax 159\n<group [id=\"identifier\"]>\n<not> <constraint.../> </not> | <constraint.../> // constraint template (<args> (intExpr wspace)+ </args>)2+\n</group>\nTo summarize, an element <group> defines a group of constraints sharing the same constraint template. This is equivalent to posting as many constraints as the number of elements <args> inside <group>. When the attribute id is specified for a group, we can consider that the id of each constraint is given by the id of the group followed by [i] where i denotes the position (starting at 0) of the constraint inside the group. At this point, it should be clear that (syntactic) groups are useful. First, they permit to partially preserve the structure of the problem. Second, there is no need to parse several times the constraint template. Third, the representation is made more compact.\nLet us illustrate this important concept of syntactic groups of constraints. The following group of constraints is equivalent to post:\n\u2022 g[0]: x0 + x1 = x2 \u2022 g[1]: x3 + x4 = x5 \u2022 g[2]: x6 + x7 = x8\n1We might extend the possibilities of building groups, in the future.\n161\nExample 142\n<group id=\"g\">\n<intension > eq(add (%0 ,%1) ,%2) </intension > <args > x0 x1 x2 </args > <args > x3 x4 x5 </args > <args > x6 x7 x8 </args >\n</group >\nWith T = {(1, 2), (2, 1), (2, 3), (3, 1), (3, 2), (3, 3)}, the following group of constraints is equivalent to post:\n\u2022 h[0]: (w, x) \u2208 T \u2022 h[1]: (w, z) \u2208 T \u2022 h[2]: (x, y) \u2208 T\nExample 143\n<group id=\"h\">\n<extension >\n<list > %0 %1 </list > <supports > (1,2)(2,1)(2,3)(3,1)(3,2)(3,3) </supports >\n</extension > <args > w x </args > <args > w z </args > <args > x y </args >\n</group >\nNow, we give the XCSP3 formulation for the 3-order instance of the Latin Square problem (fill an n\u00d7n array with n different symbols, such that each symbol occurs exactly once in each row and exactly once in each column).\nExample 144\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<array id=\"x\" size=\"[3][3]\"> 1..3 </array >\n</variables > <constraints >\n<group >\n<allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args >\n</group >\n</constraints >\n</instance >\n162\nNote that we can use shorthands for lists of variables taken from arrays, and also the formal parameter %..., as illustrated by:\nExample 145\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<array id=\"x\" size=\"[3][3]\"> 1..3 </array >\n</variables > <constraints >\n<group >\n<allDifferent > %... </allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args >\n</group >\n</constraints >\n</instance >\nOf course, in this very special context, a group is not very useful as it is possible to use the constraint allDifferent-matrix, leading to:\nExample 146\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<array id=\"x\" size=\"[3][3]\"> 1..3 </array >\n</variables > <constraints >\n<allDifferent >\n<matrix > x[][] </matrix >\n</allDifferent >\n</constraints >\n</instance >\nAs a last illustration, we give the XCSP3 formulation for the 3-order instance of the Magic Square problem. Note that, we cannot replace the element <group> by a more compact representation.\nExample 147\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<array id=\"x\" size=\"[3][3]\"> 1..9 </array >\n</variables > <constraints >\n<allDifferent > x[][] </allDifferent > <group >\n<sum >\n163\n<list > %... </list > <condition > (eq ,15) </condition >\n</sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args >\n</group >\n</constraints >\n</instance >\nRemark 44 Note that an element <group>\n\u2022 cannot be reified, as it is considered as a set of constraints, and not a single one; \u2022 cannot be relaxed/softened, for the same reason; \u2022 can only be a child of <constraints> or a child of an element <block>; hence, it cannot\nbe a descendant of (i.e., involved in) an element <group>, <slide> or <seqbin>."}, {"heading": "10.2 Blocks and Classes", "text": "We have just seen that we can declare syntactic group of constraints, i.e. groups of constraints built from the same template. But it may be interesting to identify blocks of constraints that are linked together semantically. For example, in a problem model, one may declare a set of constraints that corresponds to clues (typically, for a game), a set of symmetry breaking constraints, a set of constraints related to week-ends when scheduling the shifts of nurses, and so on. This kind of information can be useful for users and solvers. Sometimes, one might also emphasize that there exist some links between variables and constraints.\nIn XCSP3, there are two complementary ways of managing semantic groups of constraints (and variables): blocks and classes. A block is represented by an XML element whereas a class is represented by an XML attribute. To declare a block of constraints, you just need to introduce an element <block>, with an optional attribute id. Each block may contain several constraints, meta-constraints, groups of constraints and intern blocks. Most of the times, a block will be tagged by one or more classes (a class is simply an identifier), just by introducing the attribute class as in HTML.\nSyntax 160\n<block [id=\"identifier\"] [class=\"(identifier wspace)+\"]>\n(<constraint.../> | <metaConstraint.../> | <group.../> | <block.../>)+\n</block>\nPredefined classes are: \u2022 \"clues\", used for identifying clues or hints usually given for a game,\n164\n\u2022 \"symmetryBreaking\", used for identifying elements that are introduced for breaking some symmetries,\n\u2022 \"redundantConstraints\", used for identifying redundant (implied) constraints, \u2022 \"nogoods\", used for identifying elements related to nogood recording\nOther predefined values might be proposed later. It is also possible to introduce user-defined classes (i.e., any arbitrary identifier), making this approach very flexible.\nAn an illustration, we give the skeleton of an element <constraints> that contains several blocks. A first block contains the constraints corresponding to some clues (for example, the initial values of a Sudoku grid). A second block introduces some symmetry breaking constraints (lex). A third block introduces some redundant constraints. And finally, the two last blocks refer to constraints related to the management of two different weeks; by introducing blocks here, we can associate a note (short comment) with them.\nExample 148\n<constraints >\n<block class=\"clues\">\n<intension > ... </intension > <intension > ... </intension > ...\n</block > <block class=\"symmetryBreaking\">\n<lex > ... </lex > <lex > ... </lex > ...\n</block > <block class=\"redundantConstraints\"> ... </block > <block note=\"Management of first week\"> ... </block > <block note=\"Management of second week\"> ... </block >\n</constraints >\nRemark 45 The class \"redundantConstraints\" permits to identify implied constraints that are usually posted in order to improve the solving process. Because they are properly identified (by means of the attribute class), a solver can be easily asked to discard them, so as to compare its behavior when solving an instance with and without the redundant constraints. Note that this facility can be used with any value of class.\nRemark 46 The attribute type of <block>, introduced in previous specifications, is deprecated."}, {"heading": "10.3 Reification", "text": "Reification of a (hard) constraint c means associating a 0/1 variable xc with c such that xc denotes the truth value of c. Reification can be stated as:\nxc \u21d4 c\nReification of c through xc means that:\n165\n\u2022 c must be true if xc is set to 1 \u2022 \u00acc must be true if xc is set to 0 \u2022 xc must be set to 1 if c becomes entailed \u2022 xc must be set to 0 if c becomes disentailed Half reification uses implication instead of equivalence. Half reification can be stated as:\nxc \u21d2 c\nHalf reification of c orientated from xc means that: \u2022 c must be true if xc is set to 1 \u2022 xc must be set to 0 if c becomes disentailed Half reification can also be stated as:\nxc \u21d0 c\nHalf reification of c orientated towards xc means that: \u2022 \u00acc must be true if xc is set to 0 \u2022 xc must be set to 1 if c becomes entailed In XCSP3, to reify a constraint, you just need to specify an attribute reifiedBy whose value is the id of a 0/1 variable, to be associated with the XCSP3 element defining this constraint. For half reification, we use either the attribute hreifiedFrom (for xc \u21d2 c) or the attribute hreifiedTo (for xc \u21d0 c).\nAs an example, taken from [49], let us suppose that you need to express the following constraint:\nx \u2264 4\u21d2 t[x]\u00d7 y \u2265 6\nwhich requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6. By introducing variables b1, b2 for reification and variable z for handling array indexing, we obtain:\nc1: b1 \u21d4 x \u2264 4 c2: Element(t, x, z) c3: b2 \u21d4 z \u00d7 x \u2265 6 c4: b1 \u21d2 b2\nThis gives in XCSP3 form:\nExample 149\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<var id=\"x\"> 0..10 </var > <var id=\"y\"> 0..10 </var > <var id=\"z\"> 1..5 </var > <var id=\"b1\"> 0 1 </var > <var id=\"b2\"> 0 1 </var >\n</variables > <constraints >\n166\n<intension id=\"c1\" reifiedBy=\"b1\"> le(x,4) </intension > <element id=\"c2\">\n<list > 2 5 3 1 4 </list > <index > x </index > <value > z </value >\n</element > <intension id=\"c3\" reifiedBy=\"b2\"> ge(mul(z,x) ,6) </intension > <intension id=\"c4\"> imp(b1,b2) </intension >\n</constraints >\n</instance >\nAnother example taken from [49] is:\nx > 4 \u2228 allDifferent(x, y, y \u2212 x)\nWith reification, we should have a propagator for the negation of allDifferent. With half reification, we obtain:\nc1: b1 \u21d2 x > 4 c2: z = y \u2212 x c3: b2 \u21d2 allDifferent(x, y, z) c4: b1 \u2228 b2\nThis gives in XCSP3 form:\nExample 150\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<var id=\"x\"> 0..10 </var > <var id=\"y\"> 0..10 </var > <var id=\"z\"> -10..10 </var > <var id=\"b1\"> 0 1 </var > <var id=\"b2\"> 0 1 </var >\n</variables > <constraints >\n<intension id=\"c1\" hreifiedFrom=\"b1\"> gt(x,4) </intension > <intension id=\"c2\"> eq(z,sub(y,x)) </intension > <allDifferent id=\"c3\" hreifiedFrom=\"b2\"> x y z </allDifferent > <intension id=\"c4\"> or(b1,b2) </intension >\n</constraints >\n</instance >\nNote that it is also possible to post a constraint allDifferent containing x y sub(y,x), as shown in the next section."}, {"heading": "10.4 Views", "text": "XCSP3 allows the user to express general formulations of constraints, typically by permitting the use of functional expressions where a variable is usually expected. Some constraint solvers\n167\nare able to cope directly with such formulations through the concept of views [28]. A variable view is a kind of adaptor that performs some transformations when accessing the variable it abstracts over. For example, suppose that you have a filtering algorithm (propagator) for the constraint allDifferent. Can you directly deal with allDifferent({x1 + 1, x2 + 2, x3 + 3}), or must you introduce intermediate variables? In XCSP3, we let the possibility of generating instances that are \u201cview-compatible\u201d. As a classical illustration, let us consider the 8-queens problem instance. We just need 8 variables x0, x1, . . . , x7 and ensure that the values of all xi variables, the values of all xi \u2212 i, and the values of all xi + i must be pairwise different. This leads to a XCSP3 instance composed of an array of 8 variables and three allDifferent constraints.\nExample 151\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<array id=\"x\" size=\"[8]\"> 1..8 </array >\n</variables > <constraints >\n<allDifferent id=\"rows\">\nx[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7]\n</allDifferent > <allDifferent id=\"diag1\">\nadd(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7)\n</allDifferent > <allDifferent id=\"diag2\">\nsub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7)\n</allDifferent >\n</constraints >\n</instance >\n10.5 Aliases (attribute as)\nIn some cases, it is not possible to avoid some redundancy (similar contents of elements), even when using the mechanisms described above. This is the reason why we have a mechanism of aliases. It is implemented by an attribute as that can be used by any element, anywhere in the document, to refer to the content of another element of the document. The semantics is the following: the content of an element <elt> with attribute as set to value \"idOther\" is defined as being the content of the element <eltOther> in the document with attribute id set to value \"idOther\". There are a few restrictions:\n\u2022 the element <elt> must not contain anything of its own, \u2022 the element <eltOther> must precede <elt> in the document, \u2022 the element <eltOther> cannot contain an element equipped with the attribute id. \u2022 the element <eltOther> cannot be specified an attribute as (no allowed transitivity) Let us illustrate this. Suppose that an instance must contain variables x0, x1, x2, x3, with domain {a, b, c} for x0 and x2, and domain {a, b, c, d, e} for x1 and x3. If for some reasons, you\n168\nwant to preserve the names of the variables, you have to write:\nExample 152\n<variables >\n<var id=\"x0\"> a b c </var > <var id=\"x1\"> a b c d e </var > <var id=\"x2\"> a b c </var > <var id=\"x3\"> a b c d e </var >\n</variables >\nBy using the attribute as, you obtain the following equivalent non-redundant form:\nExample 153\n<variables >\n<var id=\"x0\"> a b c </var > <var id=\"x1\"> a b c d e </var > <var id=\"x2\" as=\"x0\" /> <var id=\"x3\" as=\"x1\" />\n</variables >\nOf course, this can be applied to any kind of elements. For example, if for some reason, you describe twice the same set of tuples in the document, like for example :\nExample 154\n<constraints >\n... <supports > (a,b)(a,c)(b,a)(b,c)(c,a)(c,c) </supports > ... <conflicts > (a,b)(a,c)(b,a)(b,c)(c,a)(c,c) </conflicts > ...\n</constraints >\nthen, you can simply write (note that we have introduced here the attribute id that is optional for certain elements):\nExample 155\n<constraints >\n... <supports id=\"tps\"> (a,b)(a,c)(b,a)(b,c)(c,a)(c,c) </supports > ... <conflicts as=\"tps\" /> ...\n</constraints >\n169\n11 Frameworks\nIn this chapter, we show how to define instances in various CP frameworks."}, {"heading": "11.1 Dealing with Satisfaction (CSP)", "text": "A discrete Constraint Network (CN) P is a pair (X ,C ) where X denotes a finite set of variables and C denotes a finite set of constraints. A CN is also called a CSP instance.\nTo define a CSP instance, in XCSP3, you have to: \u2022 set the attribute type of <instance> to \"CSP\"; \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints within <constraints>; The syntax is as follows:\nSyntax 161\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables>\n(<var.../> | <array.../>)+\n</variables> <constraints>\n(<constraint.../> | <metaConstraint.../> | <group.../> | <block.../>)*\n</constraints> [<annotations.../>]\n</instance>\nAs an illustration, here is a way to represent the instance langford-2-04; see CSPLib.\n170\nExample 156\n<instance format=\"XCSP3\" type=\"CSP\">\n<variables >\n<array id=\"x\" size=\"[2][4]\"> 0..7 </array >\n</variables > <constraints >\n<allDifferent > x[][] </allDifferent > <group >\n<intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args >\n</group >\n</constraints >\n</instance >"}, {"heading": "11.2 Dealing with Optimization (COP)", "text": "A COP instance is defined by a set of variables X , a set of constraints C , as for a CN, together with a set of objective functions O. Mono-objective optimization is when only one objective function is present in O. Otherwise, this is multi-objective optimization.\nTo define a COP instance, in XCSP3, you have to: \u2022 set the attribute type of <instance> to \"COP\"; \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints (if any) within <constraints>; \u2022 enumerate objectives (at least one) within <objectives>. The syntax is as follows:\nSyntax 162\n<instance format=\"XCSP3\" type=\"COP\">\n<variables>\n(<var.../> | <array.../>)+\n</variables> <constraints>\n(<constraint.../> | <metaConstraint.../> | <group.../> | <block.../>)*\n</constraints> <objectives [combination=\"combinationType\"]>\n(<minimize.../> | <maximize.../>)+\n</objectives> [<annotations.../>]\n</instance>\nAs an illustration, let us consider the Coins problem: what is the minimum number of coins that allows one to pay exactly any price p smaller than one euro [3]. Here, we consider the instance of this problem for p = 83.\n171\nExample 157\n<instance format=\"XCSP3\" type=\"COP\">\n<variables >\n<var id=\"c1\"> 1..100 </var > <var id=\"c2\"> 1..50 </var > <var id=\"c5\"> 1..20 </var > <var id=\"c10\"> 1..10 </var > <var id=\"c20\"> 1..5 </var > <var id=\"c50\"> 1..2 </var >\n</variables > <constraints >\n<sum >\n<list > c1 c2 c5 c10 c20 c50 </list > <coeffs > 1 2 5 10 20 50 </coeffs > <condition > (eq ,83) </condition >\n</sum >\n</constraints > <objectives >\n<minimize type=\"sum\"> c1 c2 c5 c10 c20 c50 </minimize >\n</objectives >\n</instance >\nRemark 47 MaxCSP is an optimization problem, which consists in satisfying the maximum number of constraints of a given CN. Typically, you may be interested in that problem, when CSP instances are over-constrained, i.e., without any solution. In the format, we do not need to refer to MaxCSP: simply feed your solver with (unsatisfiable) CSP instances, and activate MaxCSP solving."}, {"heading": "11.3 Dealing with Preferences through Soft Constraints", "text": "The classical CSP framework can be extended by introducing valuations to be associated with constraint tuples [24], making it possible to express preferences. We show below how two main specializations of the Valued Constraint Satisfaction Problem (VCSP) are represented in XCSP3."}, {"heading": "11.3.1 WCSP", "text": "WCSP (Weighted CSP) is an extension to CSP that relies on a specific valuation structure S(k) = ([0, . . . , k],\u2295,\u2265) where: \u2022 k \u2208 [1, . . . ,\u221e] is either a strictly positive natural or infinity, \u2022 [0, 1, . . . , k] is the set of naturals less than or equal to k, \u2022 \u2295 is the sum over the valuation structure defined as: a\u2295 b = min{k, a+ b}, \u2022 \u2265 is the standard order among naturals. A Weighted Constraint Network (WCN), or WCSP instance, is defined by a valuation structure S(k), a set of variables, and a set of weighted constraints, also called cost functions (see Chapter 9). A WCN is also known as a CFN (Cost Function Network).\n172\nSome examples of cost functions, taken from Chapter 9 are given below:\nExample 158\n<extension type=\"soft\" defaultCost=\"0\">\n<list > x1 x2 x3 </list > <tuples cost=\"10\"> (1,2,2)(2,1,2)(2,2,1) </tuples > <tuples cost=\"5\"> (1,1,2)(1,1,3) </tuples >\n</extension > <intension type=\"soft\" violationCost=\"3\">\neq(lucy ,sub(mary ,1))\n</intension > <intension type=\"soft\"> dist(x,y) </intension > <allDifferent type=\"soft\" violationMeasure=\"dec\">\nx1 x2 x3 x4 x5\n</allDifferent >\nRemark 48 When representing a WCSP instance, it is possible to refer to hard constraints. For such constraints, an allowed tuple has a cost of 0 while a disallowed tuple has a cost equal to the value of k.\nTo define a CFN (WCSP instance), in XCSP3, you have to; \u2022 set the attribute type of <instance> to \"WCSP\", \u2022 enumerate variables (at least one) inside <variables>; \u2022 optionally set a value to the optional attribute ub of the element <constraints>; this\nvalue represents k in the WCSP valuation structure and must be an integer greater than or equal to 1, or the special value \"+infinity\"; the default value for ub is \"+infinity\";\n\u2022 optionally set a value to the optional attribute lb of the element <constraints>. If present, this value must be an integer greater than or equal to 0, and less than or equal to the value of ub. It represents a constant cost that must be added to the other costs, sometimes called the 0-ary constraint of the WCSP framework (e.g. see [72]). Of course, if it is not present, it is assumed to be equal to 0;\n\u2022 enumerate hard constraints, relaxed constraints and cost functions (at least, one) inside <constraints>;\nThe syntax is as follows:\nSyntax 163\n<instance format=\"XCSP3\" type=\"WCSP\">\n<variables>\n(<var.../> | <array.../>)+\n</variables> <constraints [lb=\"integer\"] [ub=\"integer|+infinity\"]>\n(<constraint .../> |\n<constraint type=\"soft\".../> | <group.../> | <block.../>)*\n</constraints>\n173\n[<annotations.../>]\n</instance>\nIn the simple example below, we have a CFN with two variables, two unary extensional constraints and one binary extensional constraint. Note that the forbidden cost limit is 5 (value of ub).\nExample 159\n<instance format=\"XCSP3\" type=\"WCSP\">\n<variables >\n<var id=\"x\"> 0..3 </var > <var id=\"y\"> 0..3 </var >\n</variables > <constraints ub=\"5\">\n<extension type=\"soft\" defaultCost=\"0\">\n<list > x </list > <tuples cost=\"1\"> 1 3 </tuples >\n</extension > <extension type=\"soft\" defaultCost=\"0\">\n<list > y </list > <tuples cost=\"1\"> 1 2 </tuples >\n</extension > <extension type=\"soft\" defaultCost=\"0\">\n<list > x y </list > <tuples cost=\"5\">\n(0,0)(0,1)(1,0)(1,1)(1,2)(2,1)(2,2)(2,3)(3,2)(3,3)\n</tuples >\n</extension > </constraints >\n</instance >"}, {"heading": "11.3.2 FCSP", "text": "A fuzzy constraint network (FCN) is composed of a set of variables and a set of fuzzy constraints. Each fuzzy constraint represents a fuzzy relation on its scope: it associates a value in [0, 1] (either a rational, a decimal or one of the integers 0 and 1), called membership degree, with each constraint tuple \u03c4 , indicating to what extent \u03c4 belongs to the relation and therefore satisfies the constraint. The membership degree of a tuple gives us the preference for that tuple. In fuzzy constraints, preference 1 is the best one and preference 0 the worst one.\nIn XCSP3, a fuzzy constraint is systematically represented by an XML element whose attribute type is set to \"fuzzy\". Below, we show how to represent fuzzy constraints, either in extensional form, or in intensional form.\nFuzzy Constraints in Extension. For representing such a constraint, an element <extension> with the attribute type set to \"fuzzy\" is used, containing an element <list> and a sequence of elements <tuples>. Each element <tuples> has a required attribute degree that gives the common membership degree of all tuples contained inside the element. It is possible to use\n174\nthe optional attribute defaultDegree of <extension> to specify the membership degree of all implicit tuples (i.e., those not explicitly listed).\nThis gives the following syntax for fuzzy extensional constraints of arity greater than or equal to 2:\nSyntax 164\n<extension type=\"fuzzy\" [defaultDegree=\"number\"]>\n<list> (intVar wspace)2+ </list> (<tuples degree=\"number\"> (\"(\" intVal (\",\" intVal)+ \")\")+ </tuples>)+\n</extension>\nAn example is given below.\nExample 160\n<extension id=\"c1\" type=\"fuzzy\" defaultDegree=\"0\">\n<list > w x y z </list > <tuples degree=\"0.1\"> (1,2,3,4)(2,1,2,3)(3,1,3,4) </tuples > <tuples degree=\"0.6\"> (1,1,3,4)(2,2,2,2) </tuples >\n</extension >\nFor a fuzzy unary constraint, we obtain:\nSyntax 165\n<extension type=\"fuzzy\" [defaultDegree=\"number\"]>\n<list> intVar </list> (<tuples degree=\"number\"> ((intVal | intIntvl) wspace)+ </tuples>)+\n</extension>\nFuzzy Constraints in Intension. For representing such a constraint, we need an element <intension> with the attribute type set to \"fuzzy\". It contains a functional expression representing a fuzzy relation returning a real value (comprised between 0 and 1).\nSyntax 166\n<intension type=\"fuzzy\">\n<function> realExpr </function>\n</intension>\nThe opening and closing tags of <function> are optional, which gives:\nSyntax 167\n<intension type=\"fuzzy\"> realExpr </intension> // Simplified Form\nAn example is given below.\n175\nExample 161\n<intension id=\"c1\" type=\"fuzzy\">\nif(eq(x,y) ,0.5,0)\n</intension >\nTo define a FCSP instance, in XCSP3, you have to; \u2022 set the attribute type of <instance> to \"FCSP\", \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate fuzzy constraints within <constraints>; The syntax is as follows:\nSyntax 168\n<instance format=\"XCSP3\" type=\"FCSP\">\n<variables>\n(<var.../> | <array.../>)+\n</variables> <constraints>\n(<constraint type=\"fuzzy\".../> | <group.../> | <block.../>)*\n</constraints> [<annotations.../>]\n</instance>\nAs an illustration, let us consider the XCSP3 representation of the problem instance described in [48], page 110.\nExample 162\n<instance format=\"XCSP3\" type=\"FCSP\">\n<variables >\n<var id=\"x\"> 0..7 </var > <var id=\"y\"> 0..7 </var > <var id=\"z\"> 0..7 </var >\n</variables > <constraints >\n<extension id=\"c0\" type=\"fuzzy\" defaultDegree=\"0.25\">\n<list > x </list > <tuples degree=\"1\"> 4 </tuples > <tuples degree=\"0.75\"> 3 5 </tuples >\n</extension > <extension id=\"c1\" type=\"fuzzy\" defaultDegree=\"0.5\">\n<list > y </list > <tuples degree=\"1\"> 3 4 </tuples >\n</extension > <extension id=\"c2\" type=\"fuzzy\" defaultDegree=\"0\">\n<list > z </list > <tuples degree=\"1\"> 2 </tuples > <tuples degree=\"0.75\"> 1 3 </tuples >\n</extension >\n176\n<intension id=\"c3\" type=\"fuzzy\">\nif(eq(add(x,y,z) ,7) ,1,0)\n</intension > </constraints >\n</instance >"}, {"heading": "11.4 Dealing with Quantified Variables", "text": "Two frameworks for dealing with quantification of variables have been introduced in the literature. The former, QCSP+, is an extension of CSP, and the latter, QCOP+, is an extension of COP.\n11.4.1 QCSP(+)\nThe Quantified Constraint Satisfaction Problem (QCSP) is an extension of CSP in which variables may be quantified universally or existentially1. A QCSP instance corresponds to a sequence of quantified variables, called prefix, followed by a conjunction of constraints. QCSP and its semantics were introduced in [25]. QCSP+ is an extension of QCSP, introduced in [13] to overcome some difficulties that may occur when modeling real problems with classical QCSP. From a logic viewpoint, an instance of QCSP+ is a formula in which (i) quantification scopes of alternate type are nested one inside the other, (ii) the quantification in each scope is restricted by a CSP called restriction or precondition, and (iii) a CSP to be satisfied, called goal, is attached to the innermost scope. An example with 4 scopes is:\n\u2200X1 (L\u22001(X1)\u2192 \u2203Y1 (L\u22031(X1, Y1) \u2227\n\u2200X2 (L\u22002(X1, Y1, X2)\u2192 \u2203Y2 (L\u22032(X1, Y1, X2, Y2) \u2227 G(X1, X2, Y1, Y2))\n)\n)\n) (11.1)\nwhere X1, X2, Y1, and Y2 are in general sets of variables, and each L Q i is a conjunction of constraints. A more compact and readable syntax for QCSP+ employs square braces to enclose restrictions. An example with 3 scopes is as follows:\n\u2200X1[L\u22001(X1)] \u2203Y1[L\u22031(X1, Y1)] \u2200X2[L\u22002(X1, Y1, X2)] G(X1, Y1, X2)\nwhich reads \u201cfor all values of X1 which satisfy the constraints L \u2200 1(X1), there exists a value for Y1 that satisfies L \u2203 1(X1, Y1) and is such that for all values for X2 which satisfy L \u2200 2(X1, Y1, X2), the goal G(X1, X2, Y1) is satisfied\u201d. A standard QCSP can be viewed as a particular case of QCSP+ in which all quantifications are unrestricted, i.e. all the CPSs LQi are empty.\n1This is a revised version of the XCSP 2.1 proposal made initially for QCSP and QCSP+ by M. Benedetti, A. Lallouet and J. Vautard.\n177\nTo define a QCSP/QCSP+ instance, in XCSP3, you have to; \u2022 set the attribute type of <instance> to \"QCSP\" or \"QCSP+\"; \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints within <constraints>; \u2022 handle quantification in an element <quantification>.\nHandling Quantification. The element <quantification> provides an ordered list of quantification blocks. Notice that the order in which quantification blocks are listed inside this XML element provides key information, as it specifies the left-to-right order of (restricted) quantifications associated with the QCSP/QCSP+ instance. Each block of a QCSP/QCSP+ instance is represented by either an element <forall> or an element <exists>, which gives the kind of quantification for all the variables in the block. For QCSP, the list of variables of a block is given directly inside elements <forall> and <exists>. However, for QCSP+, if restrictions are present, we put the ids of restrictions (restricting constraints) inside an element <ctrs>, and put the list of variables inside an element <vars>; note that restrictions are put with other constraints in <constraints>. At least one variable must be present in each block, and the order in which variables are listed is not relevant.\nRemark 49 Each variable can be mentioned in at most one block. Each variable must be mentioned in at least one block; this means the problem is closed, i.e. no free variables are allowed2;\nFor QCSP, the syntax is as follows:\nSyntax 169\n<instance format=\"XCSP3\" type=\"QCSP\">\n<variables>\n(<var.../> | <array.../>)+\n</variables> <constraints>\n(<constraint.../> | <metaConstraint.../> | <group.../> | <block.../>)*\n</constraints> <quantification>\n(<exists> (intVar wspace)+ <exists> | <forall> (intVar wspace)+ <forall>)+\n</quantification> [<annotations.../>]\n</instance>\nLet w, x, y and z be four variables, whose domains are {1, 2, 3, 4}. An XCSP3 encoding of the QCSP:\n\u2203w, x \u2200y \u2203z w + x = y + z, y 6= z\nis given by:\n2This restriction may be relaxed by future formalizations of open QCSPs.\n178\nExample 163\n<instance format=\"XCSP3\" type=\"QCSP\">\n<variables >\n<var id=\"w\"> 1..4 </var > <var id=\"x\"> 1..4 </var > <var id=\"y\"> 1..4 </var > <var id=\"z\"> 1..4 </var >\n</variables > <constraints >\n<intension > eq(add(w,x),add(y,z)) </intension > <intension > ne(y,z) </intension >\n</constraints > <quantification >\n<exists > w x </exists > <forall > y </forall > <exists > z </exists >\n</quantification >\n</instance >\nRecall that, in XCSP3, an intVar corresponds to the id of a variable declared in <variables>. Similarly, an intCtr corresponds to the id of a constraint declared in <constraints>. For QCSP+, the syntax is then as follows:\nSyntax 170\n<instance format=\"XCSP3\" type=\"QCSP+\">\n<variables>\n(<var.../> | <array.../>)+\n</variables> <constraints>\n(<constraint.../> | <metaConstraint.../> | <group.../> | <block.../>)*\n</constraints> <quantification>\n( <exists>\n<vars> (intVar wspace)+ <vars> [<ctrs> (intCtr wspace)+ </ctrs>]\n</exists>\n|\n<forall>\n<vars> (intVar wspace)+ <vars> [<ctrs> (intCtr wspace)+ </ctrs>]\n<forall>\n)+\n</quantification> [<annotations.../>]\n</instance>\nAn XCSP3 encoding of the QCSP+:\n\u2203w, x[w + x < 8, w \u2212 x > 2] \u2200y[w 6= y, x 6= y] \u2203z[z < w \u2212 y] w + x = y + z\nis given by:\n179\nExample 164\n<instance format=\"XCSP3\" type=\"QCSP+\">\n<variables >\n<var id=\"w\"> 1..4 </var > <var id=\"x\"> 1..4 </var > <var id=\"y\"> 1..4 </var > <var id=\"z\"> 1..4 </var >\n</variables > <constraints >\n<intension id=\"r1a\"> lt(add(w,x) ,8) </intension > <intension id=\"r1b\"> gt(sub(w,x) ,2) </intension > <intension id=\"r2a\"> ne(w,y) </intension > <intension id=\"r2b\"> ne(x,y) </intension > <intension id=\"r3\"> gt(sub(w,y),z) </intension > <intension id=\"goal\"> eq(add(w,x),add(y,z)) </intension >\n</constraints > <quantification >\n<exists >\n<vars > w x </vars > <ctrs > r1a r1b </ctrs >\n</exists > <forall >\n<vars > y </vars > <ctrs > r2a r2b </ctrs >\n</forall > <exists >\n<vars > z </vars > <ctrs > r3 </ctrs >\n</exists >\n</quantification >\n</instance >\nNote here that we have to specify an id for each restricting constraint in order to be able to reference them.\n11.4.2 QCOP(+)\nQCOP(+), Quantified Constraint Optimization problem, is a framework [14] that allows us to formally express preferences over QCSP(+) strategies. A QCOP(+) instance is obtained from a QCSP(+) instance by adding preferences and aggregates to the quantification blocks. For aggregation, we need aggregate ids (which look like local variables but cannot be part of constraints) and aggregate functions. Possible aggregate functions are:\n\u2022 \"sum\", \u2022 \"product\" \u2022 \"average\" \u2022 \"deviation\" \u2022 \"median\" \u2022 \"count\"\n180\nCompared to QCSP(+), we must add information to elements <exists> and <forall> for dealing with optimization. For an element <exists>, we need an optimization condition, which is represented by an element <minimize> or an element <maximize>, the content of which is a variable id or an aggregate id. However, when no element <minimize> or <maximize> is present for an element <exists>, this implicitly corresponds to the atom any [14]. For an element <forall>, we must add a sequence of one or several elements <aggregate>, each of them with a required attribute id that gives the aggregate identifier. The content of the element is an expression of the form f(x) where f denotes an aggregate function and x denotes a variable id or an aggregate id.\nTo define a QCOP/QCOP+ instance, in XCSP3, you have to: \u2022 set the attribute type of <instance> to \"QCOP\" or \"QCOP+\"; \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints (at least one) within <constraints>; \u2022 handle quantification in an element <quantification>. As an illustration, here is the XCSP3 representation of the toy problem introduced in [14], page 472. We assume here that the array A, given as an input to the instance is {12, 5, 6, 9, 4, 3, 13, 10, 12, 5}\nExample 165\n<instance format=\"XCSP3\" type=\"QCOP+\">\n<variables >\n<var id=\"x\"> 0 1 </var > <var id=\"i\"> 0..9 </var > <var id=\"z\"> 0..+ infinity </var >\n</variables > <constraints >\n<intension id=\"res\"> eq(mod(i,2),x) </intension > <element id=\"goal\">\n<list > 12 5 6 9 4 3 13 10 12 5 </list > <index > i </index > <value > z </value >\n</element >\n</constraints > <quantification >\n<exists >\n<vars > x </vars > <minimize > s </minimize >\n</exists > <forall >\n<vars > i </vars > <ctrs > res </ctrs > <aggregate id=\"s\"> sum(z) </aggregate >\n</forall > <exists >\n<vars > z </vars >\n</exists >\n</quantification >\n</instance >\n181"}, {"heading": "11.5 Stochastic Constraint Reasoning", "text": "Two frameworks have been introduced for dealing with uncontrollable variables: SCSP (Stochastic Constraint Satisfaction Problem) and SCOP (Stochastic Constraint Optimization Problem)."}, {"heading": "11.5.1 SCSP", "text": "To define a SCSP instance, in XCSP3, you have to:\n\u2022 set the attribute type of <instance> to \"SCSP\"; \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints (at least one) within <constraints>; either there is an attribute threshold associated with <constraints> or an attribute threshold associated with each constraint element present in <constraints>.\n\u2022 handle stages with an element <stages>, which alternately contains elements <decision> and <stochastic>; in each of these elements, we find a sequence of variable ids.\nThe syntax is:\nSyntax 171\n<instance format=\"XCSP3\" type=\"SCSP\">\n<variables>\n(<var.../> | <array.../>)+\n</variables> <constraints [threshold=\"number\"]>\n(<constraint [threshold=\"number\"].../> | <group.../> | <block.../>)*\n</constraints> <stages>\n(<decision> (intVar wspace)+ <decision> |\n<stochastic> (intVar wspace)+ <stochastic>)+\n</stages> [<annotations.../>]\n</instance>\nHere is an illustration taken from [135] about modeling a simple m quarter production planning problem. In each quarter, we will sell between 100 and 105 copies of a book. To keep customers happy, we want to satisfy demand in all m quarters with 80% probability. At the start of each quarter, we decide how many books to print for that quarter. There are m decision variables, xi representing production in each quarter. There are also m stochastic variables, yi representing demand in each quarter. These take values between 100 and 105 with equal probability. There is a constraint to ensure 1st quarter production meets 1st quarter demand: xi \u2265 yi There is also a constraint to ensure 2nd quarter production meets 2nd quarter demand plus any unsatisfied demand or less any stock: x2 \u2265 y2 + (y1\u2212x1) And there is a constraint to ensure jth (j \u2265 2) quarter production meets jth quarter demand plus any unsatisfied demand or less any stock: xj \u2265 yj + \u2211j\u22121 i=1 (yi \u2212 xi) We must satisfy these constraints with a threshold probability of 0.8. For our illustration, with m = 2, we obtain:\n182\nExample 166\n<instance format=\"XCSP3\" type=\"SCSP\">\n<variables >\n<var id=\"x1\"> 100..105 </var > <var id=\"x2\"> 100..105 </var > <var id=\"y1\" type=\"stochastic\"> 100..105:1/6 </var > <var id=\"y2\" type=\"stochastic\"> 100..105:1/6 </var >\n</variables > <constraints threshold=\"0.8\">\n<intension > ge(x1,y1) </intension > <intension > ge(x2,add(y2,sub(y1,x1)) </intension >\n</constraints > <stages >\n<decision > x1 </decision > <stochastic > y1 </stochastic > <decision > x2 </decision > <stochastic > y2 </stochastic >\n</stages > </instance >\nSuppose now that there is a specific threshold 0.7 and 0.9 for the two constraints. The elements <constraints> become:\nExample 167\n<constraints >\n<intension threshold=\"0.7\">\nge(x1 ,y1)\n</intension > <intension threshold=\"0.9\">\nge(x2 ,add(y2 ,sub(y1,x1))\n</intension > </constraints >"}, {"heading": "11.5.2 SCOP", "text": "To define a SCOP instance, in XCSP3, you have to:\n\u2022 set the attribute type of <instance> to \"SCOP\"; \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints (at least one) within <constraints>; \u2022 handle stages with an element <stages>; \u2022 enumerate objectives (at least one) within <objectives>;"}, {"heading": "11.6 Qualitative Spatial Temporal Reasoning", "text": "Qualitative Spatial Temporal Reasoning (QSTR) deals with qualitative calculi. A qualitative calculus is defined from a finite set B of base relations on a domain D. The elements of D\n183\nrepresent temporal or spatial entities, and the elements of B represent all possible configurations between two entities. B is a set that satisfies the following properties [84]: B forms a partition of D\u00d7D, B contains the identity relation Id, and B is closed under the converse operation (\u22121). A (complex) relation is the union of some base relations, but it is customary to represent a relation as the set of base relations contained in it. Hence, the set 2B represents the set of relations of the qualitative calculus.\nA QSTR instance is a pair composed of a set of variables and a set of constraints. Each variable represents a spatial/temporal entity of the system that is modeled. Each constraint represents a set of acceptable qualitative configurations between two variables and is defined by a relation."}, {"heading": "11.6.1 Interval Calculus", "text": "A well known temporal qualitative formalism is the Interval Algebra, also called Allen\u2019s calculus [2]. The domain Dint of this calculus is the set {(x\u2212, x+) \u2208 Q\u00d7Q : x\u2212 < x+} since temporal entities are intervals of the rational line. The set Bint of this calculus is the set {eq, p, pi,m,mi, o, oi, s, si, d, di, f, fi} of thirteen binary relations representing all orderings of the four endpoints of two intervals. For example, m = {((x\u2212, x+), (y\u2212, y+)) \u2208 Dint \u00d7 Dint : x+ = y\u2212}.\nTo define a QSTR instance based on the Interval Algebra, in XCSP3, you have to: \u2022 set the attribute type of <instance> to \"QSTR\", \u2022 enumerate interval variables (at least one) within <variables>; \u2022 enumerate interval constraints within <constraints>. The syntax is:\nSyntax 172\n<instance format=\"XCSP3\" type=\"QSTR\">\n<variables>\n(<var type=\"interval\".../> | <array type=\"interval\".../>)+\n</variables> <constraints> <interval.../>* </constraints> [<annotations.../>]\n</instance>\nRemark 50 Although not indicated above, groups and blocks of interval constraints can also be used.\n184\nv0 v1\nv2\nv3\n{di,m, s}\n{o, oi}\n{m, s, fi}\n{d, o, fi}\nAs seen in Chapter 6, an interval constraint is defined by an element <interval> that contains an element <scope> and an element <relation>. An illustration is given for the qualitative constraint network depicted above. Its XCSP3 encoding is given by:\nExample 168\n<instance format=\"XCSP3\" type=\"QSTR\">\n<variables >\n<var id=\"v0\" type=\"interval\"/> <var id=\"v1\" type=\"interval\"/> <var id=\"v2\" type=\"interval\"/> <var id=\"v3\" type=\"interval\"/>\n</variables > <constraints >\n<interval >\n<scope > v0 v1 </scope > <relation > di m s </relation >\n</interval > <interval >\n<scope > v0 v3 </scope > <relation > m s fi </relation >\n</interval > <interval >\n<scope > v1 v2 </scope > <relation > o oi </relation >\n</interval > <interval >\n<scope > v2 v3 </scope > <relation > d o fi </relation >\n</interval >\n</constraints >\n</instance >"}, {"heading": "11.6.2 Point Calculus", "text": "Point Algebra (PA) is a simple qualitative algebra defined for time points. To define a QSTR instance based on the Point Algebra, in XCSP3, you have to:\n185\n\u2022 set the attribute type of <instance> to \"QSTR\", \u2022 enumerate point variables (at least one) within <variables>; \u2022 enumerate point constraints within <constraints>. The syntax is:\nSyntax 173\n<instance format=\"XCSP3\" type=\"QSTR\">\n<variables>\n(<var type=\"point\".../> | <array type=\"point\".../>)+\n</variables> <constraints> <point.../>* </constraints> [<annotations.../>]\n</instance>\nRemark 51 Although not indicated above, groups and blocks of point constraints can also be used.\nAs seen in Chapter 6, a point constraint is defined by an element <point> that contains an element <scope> and an element <relation>. An illustration is given by:\nExample 169\n<instance format=\"XCSP3\" type=\"QSTR\">\n<variables >\n<var id=\"x\" type=\"point\"/> <var id=\"y\" type=\"point\"/> <var id=\"z\" type=\"point\"/>\n</variables > <constraints >\n<point >\n<scope > x y </scope > <relation > b a </relation >\n</point > <point >\n<scope > x z </scope > <relation > b eq </relation >\n</point > <point >\n<scope > y z </scope > <relation > a </relation >\n</point >\n</constraints >\n</instance >"}, {"heading": "11.6.3 Region Connection Calculus", "text": "RCC8 consists of 8 basic relations that are possible between two regions:\n186\n\u2022 disconnected (DC) \u2022 externally connected (EC) \u2022 equal (EQ) \u2022 partially overlapping (PO) \u2022 tangential proper part (TPP) \u2022 tangential proper part inverse (TPPi) \u2022 non-tangential proper part (NTPP) \u2022 non-tangential proper part inverse (NTPPi) So, as before, to define a QSTR instance based on the Region Connection Calculus 8, in\nXCSP3, you have to:\n\u2022 set the attribute type of <instance> to \"QSTR\", \u2022 enumerate region variables (at least one) within <variables>; \u2022 enumerate rcc8 constraints within <constraints>. As seen in Chapter 6, a rcc8 constraint is defined by an element <region> with attribute\ntype set to \"rcc8\" and containing an element <scope> and an element <relation>."}, {"heading": "11.6.4 TCSP", "text": "A well-known framework for time reasoning is TCSP (Temporal Constraint Satisfaction Problem) [42]. In this framework, variables represent time points and temporal information is represented by a set of unary and binary constraints, each specifying a set of permitted intervals.\nFor this framework, as seen in Chapter 6, we only need to introduce a type of constraints, called dbd constraints, for disjunctive binary difference constraints (as in [70]). A unary dbd constraint on variable x has the form:\na1 \u2264 x \u2264 b1 \u2228 . . . \u2228 ap \u2264 x \u2264 bp\nA binary dbd constraint on variables x and y has the form:\na1 \u2264 y \u2212 x \u2264 b1 \u2228 . . . \u2228 ap \u2264 y \u2212 x \u2264 bp\nwhere x and y are real variables representing time points and a1, . . . , ap, b1, . . . , bp are real numbers denoting the bounds of p considered intervals.\nIn XCSP3, a dbd constraint is defined by an element <dbd> that contains an element <scope> and an element <intervals>. When a scope contains two variables x y in that order, it means that the difference is y \u2212 x.\nTo define a TCSP instance, in XCSP3, you have to; \u2022 set the attribute type of <instance> to \"TCSP\", \u2022 enumerate point variables (at least one) within <variables>; \u2022 enumerate dbd constraints within <constraints>. The syntax is:\n187\nSyntax 174\n<instance format=\"XCSP3\" type=\"TCSP\">\n<variables>\n(<var type=\"point\".../> | <array type=\"point\".../>)+\n</variables> <constraints> <dbd.../>* </constraints> [<annotations.../>]\n</instance>\nHere is an example taken from [42]. John goes to work either by car (30-40 minutes) or by bus (at least 60 minutes). Fred goes to work either by car (20-30 minutes) or in a car pool (40-50 minutes). Today John left home between 7:10 and 7:20, and Fred arrived at work between 8:00 and 8:10. We also know that John arrived at work about 10-20 minutes after Fred left home.\nFollowing [70], we can introduce the following variables: x0 for a special time point denoting the beginning of time (7:00 in our case), x1 for the time at which John left home, x2 for the time at which John arrived at work, x3 for the time at which Fred left home, and x4 for the time at which Fred arrived at work. We then obtain:\nExample 170\n<instance format=\"XCSP3\" type=\"TCSP\">\n<variables >\n<var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/>\n</variables > <constraints >\n<dbd >\n<scope > x0 x1 </scope > <intervals > [10 ,20] </intervals >\n</dbd > <dbd >\n<scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals >\n</dbd > <dbd >\n<scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals >\n</dbd > <dbd >\n<scope > x3 x2 </scope > <intervals > [10 ,20] </intervals >\n</dbd > <dbd >\n<scope > x0 x4 </scope > <intervals > [60 ,70] </intervals >\n</dbd >\n188\n</constraints >\n</instance >"}, {"heading": "11.7 Continuous Constraint Solving", "text": ""}, {"heading": "11.7.1 NCSP", "text": "Numerical CSP instances are defined as CSP instances, but involve real variables and constraints.\nTo define a NCSP instance, in XCSP3, you have to: \u2022 set the attribute type of <instance> to \"NCSP\"; \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints within <constraints>; The syntax is as follows:\nSyntax 175\n<instance format=\"XCSP3\" type=\"NCSP\">\n<variables>\n(<var type=\"real\".../> | <array type=\"real\".../>)+\n</variables> <constraints> (<intension.../> | <sum.../>)* </constraints> [<annotations.../>]\n</instance>\nExample 171\n<instance format=\"XCSP3\" type=\"NCSP\">\n<variables >\n<var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [-4,4] </var >\n</variables > <constraints >\n<intension > eq(sub(y,pow(x,2)) ,0) </intension > <intension > eq(sub(y,add(x,1)) ,0) </intension >\n</constraints >\n</instance >"}, {"heading": "11.7.2 NCOP", "text": "Numerical COP instances are defined as COP instances, but involve real variables and constraints.\nTo define a NCOP instance, in XCSP3, you have to: \u2022 set the attribute type of <instance> to \"NCOP\" \u2022 enumerate variables (at least one) within <variables>;\n189\n\u2022 enumerate constraints within <constraints>; \u2022 enumerate objectives (at least one) within <objectives>. The syntax is as follows:\nSyntax 176\n<instance format=\"XCSP3\" type=\"NCOP\">\n<variables>\n(<var type=\"real\".../> | <array type=\"real\".../>)+\n</variables> <constraints> (<intension.../> | <sum.../>)* </constraints> <objectives [combination=\"combinationType\"]>\n(<minimize.../> | <maximize.../>)+\n</objectives> [<annotations.../>]\n</instance>"}, {"heading": "11.8 Distributed Constraint Reasoning", "text": "Distributed Constraint Reasoning has been studied for both satisfaction and optimization."}, {"heading": "11.8.1 DisCSP", "text": "DisCSP (Distributed CSP) instance, is defined as a classical CN P = (X ,C ), together with a set of p agents A = {a1, a2, . . . , ap}. Each agent a \u2208 A controls a proper subset of variables vars(a) of X , and knows a subset of constraints ctrs(a) of C . The sets of controlled variables of all agents form a partition of X . When an agent ai can directly send messages to another agent aj , aj is said to be reachable from ai.\nTo describe the way agents are defined and interact, we add to <instance> an element <agents> that contains a sequence of elements <agent>. Each element <agent> has an optional attribute id and contains an element <vars>, an element <ctrs> and a sequence of elements <comm>. Note that, as described below, some of these intern elements can be omitted in certain cases. They are defined as follows:\n\u2022 The element <vars> contains the list of variables, given by their ids, controlled by the agent.\n\u2022 The element <ctrs> contains the list of constraints, given by their ids, known by the agent.\n\u2022 When there is no (special) communication cost between agents, there is only one element <comm> that contains the list of agents, given by their ids, reachable from the agent.\n\u2022 When there are specific communication costs between agents, there is a sequence of elements <comm>, each one that contains the list of agents, given by their ids, reachable from the agent with a cost given by an attribute cost.\nNote that the introduced elements <comm>, taken together, allows us to describe the topology of the communication graph/network.\nThere are special cases where some elements can be omitted. It depends on the general configuration of agents, which is characterized by three (optional) attributes associated with\n190\nthe element <agents>. The optional attribute varsModel characterizes the partition of variables between agents. When there is a bijection between X and A , i.e., each agent controls exactly one distinct variable, the value of varsModel is set to \"bijection\". The optional attribute ctrsModel characterizes the knowledge of agents on constraints. When every agent a exactly knows the set of constraints involving at least one variable controlled by the agent, i.e., ctrs(a) = {c \u2208 C | scp(c) \u2229 vars(a) 6= \u2205}, the value of ctrsModel is set to \"TKC\", which stands for Totally Known Constraints. The optional attribute commModel characterizes the way agents can communicate, i.e. what is the topology of the communication network. When the communication graph is the same as the constraint (primal) graph, the value of commModel is set to \"scope\".\nNow, here are the possible simplifications according to the value of these three attributes. First, for any element <agent>, the sequence of elements <comm> can be empty when there is no (special) communication cost between agents and when the value of the attribute commModel is \"scope\", because it is possible to infer the communication graph in that case. Similarly, for any element <agent>, the element <ctrs> can be omitted when the value of ctrsModel is \"TKC\". Finally, when varsModel has value \"bijection\", ctrsModel has value \"TKC\" and commModel has value \"scope\", we can avoid to introduce all intern elements <agent>.\nTo define a DisCSP instance, in XCSP3, you have to; \u2022 set the attribute type of <instance> to \"DisCSP\", \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate constraints (at least one) within <constraints>; \u2022 enumerate agents within <agents>. An illustration is given below:\nExample 172\n<instance format=\"XCSP3\" type=\"DisCSP\">\n<variables >\n<var id=\"w\"> red green blue </var > <var id=\"x\"> red green blue </var > <var id=\"y\"> red green blue </var > <var id=\"z\"> red green blue </var >\n</variables > <constraints >\n<intension id=\"c1\"> ne(w,x) </intension > <intension id=\"c2\"> ne(w,y) </intension > <intension id=\"c3\"> ne(w,z) </intension > <intension id=\"c4\"> ne(x,z) </intension > <intension id=\"c5\"> ne(y,z) </intension >\n</constraints > <agents >\n<agent id=\"a1\">\n<vars > w </vars > <ctrs > c1 c2 c3 </ctrs > <comm > a2 a3 a4 </comm >\n</agent > <agent id=\"a2\">\n<vars > x </vars >\n191\n<ctrs > c1 c4 </ctrs > <comm > a1 a4 </comm >\n</agent > <agent id=\"a3\">\n<vars > y </vars > <ctrs > c2 c5 </ctrs > <comm > a1 a4 </comm >\n</agent > <agent id=\"a4\">\n<vars > z </vars > <ctrs > c3 c4 c5 </ctrs > <comm > a1 a2 a3 </comm >\n</agent >\n</agents > </instance >\nInterestingly enough, for the element <agents>, we can use the following abridged version:\nExample 173\n<agents varsModel=\"bijection\"\nctrsModel=\"TKC\" commModel=\"scope\" />\nLet us suppose now that we only consider three agents, one controlling the variables w and x, and the two others controlling the variables y and z, respectively. We keep a TKC model, and consider that the communication cost between any pair of agents is 10, except between the first and third agents, where it is 100. We then obtain the following element <agents>:\nExample 174\n<agents ctrsModel=\"TKC\" commModel=\"scope\">\n<agent id=\"a1\">\n<vars > w x </vars > <ctrs > c1 c2 c3 c4 </ctrs > <comm cost=\"10\"> a2 </comm > <comm cost=\"100\"> a3 </comm >\n</agent > <agent id=\"a2\">\n<vars > y </vars > <ctrs > c2 c5 </ctrs > <comm cost=\"10\"> a1 a3 </comm >\n</agent > <agent id=\"a3\">\n<vars > z </vars > <ctrs > c3 c4 c5 </ctrs > <comm cost=\"100\"> a1 </comm > <comm cost=\"10\"> a2 </comm >\n</agent >\n</agents >\n192\nBecause the model is TKC, we could discard all elements <ctrs>."}, {"heading": "11.8.2 DisWCSP (DCOP)", "text": "A DisWCSP (Distributed WCSP) instance, often called DCOP in the literature, is defined as a classical WCN P = (X ,C , k), together with a set of p agents A = {a1, a2, . . . , ap}. The way the agents are defined are exactly as for DisCSP.\nTo define a DisWCSP instance, in XCSP3, you have to; \u2022 set the attribute type of <instance> to \"DisWCSP\", \u2022 enumerate variables (at least one) within <variables>; \u2022 enumerate weighted constraints (at least one) within <constraints>; \u2022 enumerate agents within <agents>.\n193\n12 Annotations\nIn XCSP3, it is possible to insert an element <annotations> to express search and filtering advice. In this chapter, we present this while considering integer variables only (i.e., CSP and COP frameworks), but of course, what follows can be directly adapted to other frameworks.\nRecall that, in XCSP3, an intVar corresponds to the id of a variable declared in <variables>. Similarly, an intCtr corresponds to the id of a constraint declared in <constraints>. Besides, all BNF non-terminals such as filteringType, consistencyType, branchingType and restartsType are defined in Appendix B. The general syntax for <annotations> is as follows:\nSyntax 177\n<annotations>\n[<variables>\n[<decision> (intVar wspace)+ <decision>] [<output> (intVar wspace)+ <output>] [<varHeuristic.../>] [<valHeuristic.../>]\n</variables>] [<constraints>\n(<filtering type=\"filteringType\"> (intCtr wspace)+ <filtering>)* [<filtering type=\"filteringType\"/>]\n</constraints>] [<prepro consistency=\"consistencyType\"/>] [<search [consistency=\"consistencyType\"] [branching=\"branchingType\"]>\n[<restarts type=\"restartsType\" cutoff=\"unsignedInteger\" [factor=\"decimal\"]/>]\n</search>]\n</annotations>\n194"}, {"heading": "12.1 Annotations about Variables", "text": "It is possible to associate annotations with variables by introducing an element <variables> inside <annotations>. First, one can indicate the variables that the solver should branch in, so-called branching or decision variables, and the variables that are considered relevant when outputting solutions. This is made possible by introducing an element <decision> and an element <output> inside <variables>. For example, below, we identify variables x0, x1 and x2 as being three decision variables, and variables y and z as being those that should be displayed whenever a solution is found.\nExample 175\n<variables >\n<decision > x0 x1 x2 </decision > <output > y z </output >\n</variables >\nIt may be interesting to indicate which heuristic(s) should be followed by a solver. This is the role of the elements <varHeuristic> and <valHeuristic>. For variable ordering, one can introduce several elements inside <varHeuristic>, chosen among <static>, <random>, <min> and <max>. An element <static> indicates in which exact order variables contained in it must be selected by the solver. An element <random> indicates that variables contained in it should be selected at random. An element <min> or <max> has a required attribute type whose value indicates the type of variable ordering heuristic, based on one or several criteria, that must be followed for the variables it contains. Basic types, based on elementary criteria, are currently:\n\u2022 \"lexico\". \u2022 \"dom\" [62]. \u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and\nalso with the operator \u201c+\u201d to determine how to break ties. We can then use complex types, as for example:\n\u2022 \"dom/deg\", \"dom/ddeg\" and \"dom/wdeg\" \u2022 \"dom+ddeg\" For example, \"dom+ddeg\" is known as the Brelaz heuristic [27, 124]. Note that the BNF syntax for all possible values of type is given by varhType in Appendix\nB. The syntax for <varHeuristic> is then:\nSyntax 178\n<varHeuristic [lc=\"unsignedInteger\"]>\n( <static> (intVar wspace)+ <static>\n| <random> (intVar wspace)+ <random> | <min type=\"varhType\"> (intVar wspace)+ <min> | <max type=\"varhType\"> (intVar wspace)+ <max>\n195\n)* [<random/> | <min type=\"varhType\"/> | <max type=\"varhType\"/>] // default\n</varHeuristic>\nAs you can see, there may be several elements inside <varHeuristic>, including one in last position that may contain nothing. Actually, when there are several elements inside <varHeuristic>, it means that the variables of the first element should be selected first (using the semantics of the element), then the variables of the second element should be selected, and so on. Finally, when there is an element at last position without any content, it means that it applies to all remaining variables (i.e., those not explicitly listed in previous elements): this is the default heuristic. By means of the attribute lc, it is also possible to indicate that last conflict reasoning [78] should be employed: the value of the attribute indicates the maximal size (k) of the testing set.\nIf the advice is simply to use min dom/wdeg over the entire constraint network, you will write:\nExample 176\n<varHeuristic >\n<min type=\"dom/wdeg\"/>\n</varHeuristic >\nIn another example, below, we assume that the solver should select variables x0, x7 and x12 first (in that order), then variables x10, x20 in an order that depends on their domain sizes, and finally all other variables by considering at each decision step the variable with the greatest weighted degree. On our example, it is also advised to use lc(2).\nExample 177\n<varHeuristic lc=\"2\">\n<static > x0 x7 x12 </static > <min type=\"dom\"> x10 x20 </min > <max type=\"wdeg\"/>\n</varHeuristic >\nFor value ordering, one can introduce several elements inside <valHeuristic>, chosen among <static>, <random>, <min> and <max>. An element <static> indicates in which order values for the variables contained in it should be selected by the solver. The order for values is given by the attribute order. An element <random> indicates that values for the variables contained in it should be selected randomly. An element <min> or <max> has a required attribute type whose value indicates the type of value ordering heuristic that must be followed for the variables it contains. Currently, possible values of type (i.e., values of valhType defined in Appendix B) are:\n\u2022 \"conflicts\" \u2022 \"value\". Here, conflicts refers to the number of conflicts with neighbors [91, 55]. The syntax for <valHeuristic> is then:\n196\nSyntax 179\n<valHeuristic>\n( <static order=\"(intVal wspace)+\"> (intVar wspace)+ <static>\n| <random> (intVar wspace)+ <random> | <min type=\"valhType\"> (intVar wspace)+ <min> | <max type=\"valhType\"> (intVar wspace)+ <max>\n)* [<random /> | <min type=\"valhType\"/> | <max type=\"valhType\"/>] // default\n</valHeuristic>\nIf the advice is simply to use min value over the entire constraint network, you will write:\nExample 178\n<valHeuristic >\n<min type=\"value\"/>\n</valHeuristic >\nAnother example is given below. Whenever x is selected, the solver must choose the first valid value in the order given by order. Whenever y and z are selected, the solver must select the value that has the smallest number of conflicts (with its neighbors). Finally, whenever any other variable is selected by the solver, the greatest value in the domain of the selected variable must be chosen.\nExample 179\n<valHeuristic >\n<static order = \"4 5 3 6 2 1\"> x </static > <min type=\"conflicts\"> y z </min > <max type=\"value\"/>\n</valHeuristic >"}, {"heading": "12.2 Annotations about Constraints", "text": "It is possible to associate annotations with constraints by introducing an element <constraints> inside <annotations>. First, one can indicate the level of filtering that the solver should try to enforce on specified constraints by using elements <filtering> with the type attribute set to the wished value. Currently, there are five possible values for type:\n\u2022 \"boundsZ\" for integer bounds propagation. See Bounds(Z) in [38]. \u2022 \"boundsD\" for a stronger integer bounds propagation. See Bounds(D) in [38]. \u2022 \"boundsR\" for real bounds propagation. See Bounds(R) in [38]. \u2022 \"AC\" for (Generalized) Arc Consistency. This value is valid for both binary and non-\nbinary constraints (when it is usually called GAC).\n\u2022 \"FC\" for Forward Checking. In that case, the element <filtering> has an optional attribute delay that indicates the number of unassigned variables under which AC should be enforced (since FC is a partial form of AC).\n197\nWhen an element <filtering> contains nothing, it must be the last element, meaning that it applies to all remaining constraints (i.e., those not explicitly listed in previous elements).\nAn example is given below. Here, the solver should enforce Bounds(Z) on constraints c0, c1 and c2, Bounds(D) on constraints c3 and c4 and full (generalized) arc consistency on all other constraints.\nExample 180\n<constraints >\n<filtering type=\"boundsZ\"> c0 c1 c2 </filtering > <filtering type=\"boundsD\"> c3 c4 </filtering > <filtering type=\"AC\"/>\n</constraints >"}, {"heading": "12.3 Annotations about Preprocessing and Search", "text": "In some cases, it may be useful to indicate the overall level of consistency that the solve should enforce at preprocessing (i.e, before search) and/or during search; for this purpose, we introduce elements <prepro> and <search>. Currently, this level of consistency can be any value among:\n\u2022 \"FC\" for Forward Checking \u2022 \"BC\" for Bounds Consistency \u2022 \"AC\" for (Generalized) Arc Consistency (i.e., for both binary and non-binary constraints) \u2022 \"SAC\" for Singleton Arc Consistency \u2022 \"FPWC\" for Full Pairwise Consistency \u2022 \"PC\" for Path Consistency \u2022 \"CDC\" for Conservative Dual Consistency \u2022 \"FDAC\" For Full Directional Arc Consistency \u2022 \"EDAC\" for Existential Directional Arc Consistency \u2022 \"VAC\" for Virtual Arc Consistency To record this information, we use an attribute consistency whose value is one among those cited just above. For search, we can also indicate the kind of branching that the solver should use, by means of the attribute branching whose value must currently be one among \"2-way\" and \"d-way\". Finally, we can give relevant information about restarts. We just have to introduce an element <restarts> with two attributes type and cutoff. Currently, possible values for type are:\n\u2022 \"luby\" \u2022 \"geometric\"\nThe attribute cutoff indicates the number of conflicts that must be encountered before restarting the first time. When the progression is geometric, there is an additional attribute factor.\nAn example is given below.\n198\nExample 181\n<prepro consistency=\"SAC\"/> <search consistency=\"AC\" branching=\"2-way\">\n<restarts type=\"geometric\" cutoff=\"10\" factor=\"1.1\"/>\n</search >\n199\nAcknowledgments\nThis work has been supported by both CNRS and OSEO (BPI France) within the ISI project \u2019Pajero\u2019. Soon, in this section, we shall thank all people that helped us for this project.\n200\nAppendices\n201\nA KeyWords\nXCSP3 keywords are:\nneg, abs, add, sub, mul, div, mod, sqr, pow, min, max, dist, lt, le, ge, gt, ne, eq, set, in, not, and, or, xor, iff, imp, if, card, union, inter, diff, sdiff, hull, djoint, subset, subseq, supseq, supset, convex, PI, E, fdiv, fmod, sqrt, nroot, exp, ln, log, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, others\nThere are some restrictions about the identifiers that can be used in XCSP3:\n\u2022 the set of keywords, the set of symbolic values and the set of id values (i.e., values of attributes id) must all be disjoint,\n\u2022 it is not permitted to have two attributes id with the same value, \u2022 it is not permitted to have an attribute id of an element <array> that corresponds to a\nprefix of any other attribute id,\n\u2022 it is not permitted to have an attribute id of an element <group> that corresponds to a prefix of any other attribute id.\nRecall that characters \u201c[\u201c and \u201c]\u201d are not allowed in identifiers. If you need to build a subnetwork (new file) with a selection of variables (from arrays) and constraints (from groups), it is recommended to adopt the following usage: replace each occurrence of the form \u201c[i]\u201d by \u201c i\u201d. For example, x[0][3] becomes x_0_3 and g[0] becomes g_0.\n202\nB Syntax\nThe syntax given in this document combines two languages:\n\u2022 XML for describing the main elements and attributes of XCSP3 (high level description) \u2022 BNF for describing the textual contents of XCSP3 elements and attributes (low level\ndescription)\nAt some places, we need to postpone the description of some XML elements. In that case, we just employ <elt.../> to stand for an XML element of name elt, whose description is given elsewhere. This roughly corresponds to the notion of XML non-terminal. For example, because, as seen below, |, parentheses and + respectively stand for alternation, grouping and repetition (at least one), for indicating that the element <variables> can contain some elements <var> and <array>, we just write:\n<variables>\n(<var.../> | <array.../>)+\n</variables>\nThe \u201cXML non-terminals\u201d <var.../> and <array.../> must then be precisely described at another place. For example, for <var.../>, we can use the following piece of XCSP3 syntax, where one can observe that we have an XML element <var> with two attributes id and type (optional). The value of the attribute id as well as the content of the element <var> is defined using BNF, with BNF non-terminals written in dark blue italic form. The non-terminals, referred to all along the document, are defined in this section.\n<var id=\"identifier\" [type=\"integer\"]>\n((intVal | intIntvl) wspace)*\n</var>\nIn many situations (as for our example above), the content of an XML text-only element corresponds to a list of basic data (values, variables, ...) with whitespace as separator. In such situations, the whitespace that follows the last object of the list must always be considered as optional.\n203\nMore generally, the following rule applies for XCSP3:\nRemark 52 In XCSP3, leading and trailing whitespace are tolerated, but not required, in any XML text-only element.\nWe use a variant of Backus-Naur Form (BNF) defined as follows:\n\u2022 a non-terminal definition is preceded by ::= \u2022 terminals are between quotation marks as e.g., \"CSP\" \u2022 non-terminals are composed of alphanumeric characters (and the character \u201d \u201d), and so,\ndo not contain any white space character, as e.g., frameworkType. When such nonterminals are mixed with XML notation (in the document), they are written in dark blue italic form as e.g., frameworkType\n\u2022 concatenation is given by any non-empty sequence of white space characters \u2022 alternatives are separated by a vertical bar as, e.g., \"+\" | \"-\" \u2022 square brackets are used for surrounding optional elements, as, e.g., [\"+\" | \"-\"] \u2022 an element followed by * can occur 0 or any number of times \u2022 an element followed by + must occur at least 1 time \u2022 an element followed by n+ must occur at least n times \u2022 parentheses are used for grouping (often used with *, + and n+) The syntax is given for fully expanded XCSP3 code, meaning that compact lists of array\nvariables (such as x[]) are not handled. The basic BNF non-terminals used in this document are:\nwspace ::= (\" \" | \"\\t\" | \"\\n\" | \"\\r\")+\ndigit ::= \"0\"..\"9\" unsignedInteger ::= digit+ integer ::= [\"+\" | \"-\"] unsignedInteger decimal ::= integer \".\" unsignedInteger rational ::= integer \"/\" unsignedInteger number ::= integer | decimal | rational\nboolean ::= \"false\" | \"true\" intSet ::= \"set(\" [integer (\",\" integer)*] \")\"\nletter ::= \"a\"..\"z\" | \"A\"..\"Z\" identifier ::= letter (letter | digit | \"_\" )*\nThe basic data type are (note that we include many aliases so as to facilitate readability):\nindexing ::= (\"[\" unsignedInteger \"]\")+ variable ::= identifier [indexing]\n01Var ::= variable intVar ::= variable\n204\nsymVar ::= variable realVar ::= variable setVar ::= variable graphVar ::= variable qualVar ::= variable\nintVal ::= integer realVal ::= number intIntvl ::= (integer | \"-infinity\") \"..\" (integer | \"+infinity\") realIntvl ::= (\"]\" | \"[\") (number | \"-infinity\") \",\"\n(number | \"+infinity\") (\"]\" | \"[\")\nsetVal ::= \"{\" [integer (\",\" integer)*] \"}\" proba ::=\nunsignedInteger \".\" unsignedInteger | unsignedInteger \"/\" unsignedInteger | 0 | 1\noperator ::= \"lt\" | \"le\" | \"ge\" | \"gt\" | \"ne\" | \"eq\" | \"in\" | \"notin\" operand ::= intVal | intVar | intIntvl | intSet\ntuplePiece ::= intVal | \"*\" | setVal\nstate ::= identifier symbol ::= identifier intCtr ::= identifier\ndimensions ::= indexing\nSome types are defined as:\nframeworkType ::=\n\"CSP\" | \"COP\" | \"WCSP\" | \"FCSP\" | \"QCSP\" | \"QCSP+\" | \"QCOP\" | \"QCOP+\"\n| \"SCSP\" | \"SCOP\" | \"QSTR\" | \"TCSP\" | \"NCSP\" | \"NCOP\" | \"DisCSP\" | \"DisWCSP\"\nvarType ::=\n\"integer\" | \"symbolic\" | \"real\" | \"set\" | \"symbolic set\"\n| \"undirected graph\" | \"directed graph\" | \"stochastic\" | \"symbolic stochastic\" | \"point\" | \"interval\" | \"region\"\norderedType ::=\n\"increasing\" | \"strictlyIncreasing\" | \"decreasing\" | \"strictlyDecreasing\"\nrankType ::= \"any\" | \"first\" | \"last\"\niaBaseRelation ::=\n\"eq\" | \"p\" | \"pi\" | \"m\" | \"mi\" | \"o\" | \"oi\"\n| \"s\" | \"si\" | \"d\" | \"di\" | \"f\" | \"fi\"\n205\npaBaseRelation ::= \"b\" | \"eq\" | \"a\"\nrcc8BaseRelation ::=\n\"dc\" | \"ec\" | \"eq\" | \"po\"\n| \"tpp\" | \"tppi\" | \"nttp\" | \"nttpi\"\nmeasureType ::= \"var\" | \"dec\" | \"val\" | \"edit\"\ncombinationType ::= \"lexico\" | \"pareto\"\nblockType ::=\n\"clues\" | \"symmetryBreaking\" | \"redundantConstraints\" | \"nogoods\"\nvarhType ::=\n\"lexico\" | \"dom\" | \"deg\" | \"ddeg\" | \"wdeg\" | \"immpact\" | \"activity\"\n| varhType \"/\" varhType | varhType \"+\" varhType\nvalhType ::= \"conflicts\" | \"value\"\nfilteringType ::= \"boundsZ\" | \"boundsD\" | \"boundsR\" | \"AC\" | \"FC\"\nconsistencyType ::=\n\"FC\" | \"BC\" | \"AC\" | \"SAC\" | \"FPWC\" | \"PC\" | \"CDC\" | \"FDAC\" | \"EDAC\" | \"VAC\"\nbranchingType ::= \"2-way\" | \"d-way\"\nrestartsType ::= \"luby\" | \"geometric\"\nThe grammar used to build predicate expressions with integer variables is:\nintExpr ::=\n01Var | intVar | integer\n| \"neg(\" intExpr \")\" | \"abs(\" intExpr \") | \"add(\" intExpr (\",\" intExpr)+ \")\" | \"sub(\" intExpr \",\" intExpr \")\" | \"mul(\" intExpr (\",\" intExpr)+ \")\" | \"div(\" intExpr \",\" intExpr \")\" | \"mod(\" intExpr \",\" intExpr \")\" | \"sqr(\" intExpr \")\" | \"pow(\" intExpr \",\" intExpr \")\" | \"min(\" intExpr (\",\" intExpr)+ \")\" | \"max(\" intExpr (\",\" intExpr)+ \")\" | \"dist(\" intExpr \",\" intExpr \")\" | \"if(\" boolExpr \",\" intExpr \",\" intExpr \")\"\nboolExpr ::=\n206\n01Var\n| \"lt(\" intExpr \",\" intExpr \")\" | \"le(\" intExpr \",\" intExpr \")\" | \"ge(\" intExpr \",\" intExpr \")\" | \"gt(\" intExpr \",\" intExpr \")\" | \"ne(\" intExpr \",\" intExpr \")\" | \"eq(\" intExpr (\",\" intExpr)+ \")\" | \"in(\" intExpr \",\" intSet \")\" | \"not(\" boolExpr \")\" | \"and(\" boolExpr (\",\" boolExpr)+ \")\" | \"or(\" boolExpr (\",\" boolExpr)+ \")\" | \"xor(\" boolExpr (\",\" boolExpr)+ \")\" | \"iff(\" boolExpr (\",\" boolExpr)+ \")\" | \"imp(\" boolExpr \",\" boolExpr \")\"\nThe grammar used to build predicate expressions with integer variables and set variables is:\nintExprSet ::=\n01Var | intVar | integer\n| \"neg(\" intExprSet \")\" | \"abs(\" intExprSet \") | \"add(\" intExprSet (\",\" intExprSet)+ \")\" | \"sub(\" intExprSet \",\" intExprSet \")\" | \"mul(\" intExprSet (\",\" intExprSet)+ \")\" | \"div(\" intExprSet \",\" intExprSet \")\" | \"mod(\" intExprSet \",\" intExprSet \")\" | \"sqr(\" intExprSet \")\" | \"pow(\" intExprSet \",\" intExprSet \")\" | \"min(\" intExprSet (\",\" intExprSet)+ \")\" | \"max(\" intExprSet (\",\" intExprSet)+ \")\" | \"dist(\" intExprSet \",\" intExprSet \")\" | \"if(\" boolExprSet \",\" intExprSet \",\" intExprSet \")\" | \"card(\" setExpr \")\" | \"min(\" setExpr \")\" | \"max(\" setExpr \")\"\nsetExpr ::=\nsetVar | \"set(\" [intExprSet (\",\" intExprSet)*] \")\"\n| \"union(\" setExpr (\",\" setExpr)+ \")\" | \"inter(\" setExpr (\",\" setExpr)+ \")\" | \"diff(\" setExpr \",\" setExpr \")\" | \"sdiff(\" setExpr (\",\" setExpr)+ \")\" | \"hull(\" setExpr \")\"\nboolExprSet ::=\n01Var\n| \"lt(\" intExprSet \",\" intExprSet \")\" | \"le(\" intExprSet \",\" intExprSet \")\"\n207\n| \"ge(\" intExprSet \",\" intExprSet \")\" | \"gt(\" intExprSet \",\" intExprSet \")\" | \"ne(\" intExprSet \",\" intExprSet \")\" | \"eq(\" intExprSet (\",\" intExprSet)+ \")\" | \"in(\" intExprSet \",\" setExpr \")\" | \"ne(\" setExpr \",\" setExpr \")\" | \"eq(\" setExpr (\",\" setExpr)+ \")\" | \"not(\" boolExprSet \")\" | \"and(\" boolExprSet (\",\" boolExprSet)+ \")\" | \"or(\" boolExprSet (\",\" boolExprSet)+ \")\" | \"xor(\" boolExprSet (\",\" boolExprSet)+ \")\" | \"iff(\" boolExprSet (\",\" boolExprSet)+ \")\" | \"imp(\" boolExprSet \",\" boolExprSet \")\" | \"djoint(\" setExpr \",\" setExpr \")\" | \"subset(\" setExpr \",\" setExpr \")\" | \"subseq(\" setExpr \",\" setExpr \")\" | \"supseq(\" setExpr \",\" setExpr \")\" | \"supset(\" setExpr \",\" setExpr \")\" | \"convex(\" setExpr \")\"\nThe grammar used to build predicate expressions with integer variables and real variables is:\nrealExpr ::=\n01Var | intVar | realVar | number | PI | E\n| \"neg(\" realExpr \")\" | \"abs(\" realExpr \") | \"add(\" realExpr (\",\" realExpr)+ \")\" | \"sub(\" realExpr \",\" realExpr \")\" | \"mul(\" realExpr (\",\" realExpr)+ \")\" | \"fdiv(\" realExpr \",\" realExpr \")\" | \"fmod(\" realExpr \",\" realExpr \")\" | \"min(\" realExpr (\",\" realExpr)+ \")\" | \"max(\" realExpr (\",\" realExpr)+ \")\" | \"sqr(\" realExpr \")\" | \"pow(\" realExpr \",\" realExpr \")\" | \"sqrt(\" realExpr \")\" | \"nroot(\" realExpr \",\" integer \")\" | \"exp(\" realExpr \")\" | \"ln(\" realExpr \")\" | \"log(\" realExpr \",\" integer \")\" | \"sin(\" realExpr \")\" | \"cos(\" realExpr \")\" | \"tan(\" realExpr \")\" | \"asin(\" realExpr \")\" | \"acos(\" realExpr \")\" | \"atan(\" realExpr \")\" | \"sinh(\" realExpr \")\" | \"cosh(\" realExpr \")\"\n208\n| \"tanh(\" realExpr \")\" | \"if(\" boolExprReal \",\" realExpr \",\" realExpr \")\"\nboolExprReal ::=\n01Var\n| \"lt(\" realExpr \",\" realExpr \")\" | \"le(\" realExpr \",\" realExpr \")\" | \"ge(\" realExpr \",\" realExpr \")\" | \"gt(\" realExpr \",\" realExpr \")\" | \"ne(\" realExpr \",\" realExpr \")\" | \"eq(\" realExpr (\",\" realExpr)+ \")\" | \"not(\" boolExprReal \")\" | \"and(\" boolExprReal (\",\" boolExprReal)+ \")\" | \"or(\" boolExprReal (\",\" boolExprReal)+ \")\" | \"xor(\" boolExprReal (\",\" boolExprReal)+ \")\" | \"iff(\" boolExprReal (\",\" boolExprReal)+ \")\" | \"imp(\" boolExprReal \",\" boolExprReal \")\"\nFinally, we need some non-terminal tokens to be used for XML elements.\nconstraint ::=\n\"extension\" | \"intension\"\n| \"regular\" | \"grammar\" | \"mdd\" | \"allDifferent\" | \"allEqual\" | \"allDistant\" | \"ordered\" | \"allIncomparable\" | \"sum\" | \"count\" | \"nValues\" | \"cardinality\" | \"balance\" | \"spread\" | \"deviation\" |\n\"sumCosts\" | \"sequence\"\n| \"maximum\" | \"minimum\" | \"element\" | \"channel\" | \"permutation\" | \"precedence\" | \"stretch\" | \"noOverlap\" | \"cumulative\" | \"binPacking\" | \"knapsack\" | \"networkFlow\" | \"circuit\" | \"nCircuits\" | \"path\" | \"nPaths\" | \"tree\" | \"nTrees\" | \"clause\" | \"instantiation\" | \"allIntersecting\" | \"range\" | \"roots\" | \"partition\" | \"arbo\" | \"nArbos\" | \"nCliques\"\nmetaConstraint ::=\n\"slide\" | \"seqbin\" | \"and\" | \"or\" | \"not\"\n209\nC Index of Constraints\nConstraint Type Page Remark allDifferent Integer 55\nallDifferent-list Integer 115 allDifferent-set Integer 116 allDifferent-mset Integer 117 allDifferent-matrix Integer 128 allDifferent Set 116\nallDifferent.symmetric Integer 132 restriction allDistant Integer 57\nallDistant-list Integer 120 allDistant-set Integer 120 allDistant-mset Integer 121\nallEqual Integer 56 allEqual-list Integer 118 allEqual-set Integer 119 allEqual-mset Integer 119\nallEqual Set 119 allIncomparable-list Integer 124 allIncomparable-set Integer 124 allIncomparable-mset Integer 125\nallIntersecting Set 93 among Integer see count and Integer 141 meta arbo Graph 104\natLeast Integer see count atMost Integer see count balance Integer 63\nbinPacking Integer 79\n210\ncardinality Integer 62 cardinality-matrix Set 130\ncardinalityWithCosts Integer 143 construction cardPath Integer see soft-slide meta channel Integer 72 channel Set 100 change Integer see soft-slide circuit Integer 82 circuit Graph 102 clause Integer 87\ncostRegular Integer 143 construction count Integer 60 count Set 97 cube Integer 88 cumulative Integer 78 cumulatives Integer see cumulative\ndbd Qualitative 110 decreasing Integer see ordered deviation Integer 65 diffn Integer see noOverlap\ndisjunctive Integer see noOverlap distribute Integer see cardinality element Integer 71\nelement-matrix Integer 129 element Set 99 exactly Integer see count\nextension Integer 49 fuzzy-extension Integer 174 fuzzy-intension Integer 175\ngcc Integer see cardinality globalCardinality Integer see cardinality\ngrammar Integer 53 increasing Integer see ordered\ninstantiation Integer 88 intension Integer 47 intension Real 106 intension Set 90 interDistance Integer see allDistant interval Qualitative 108 knapsack Integer 81\nlex Integer see 122 lex2 Integer see ordered-matrix linear Integer see sum linear Real see sum maximum Integer 69 mdd Integer 54 member Integer see element minimum Integer 70\n211\nnArbos Graph 105 nCircuits Integer 83 nCircuits Graph 103 nCliques Graph 105\nnetworkFlow Integer 81 noOverlap Integer 76 not Integer 144 meta notAllEqual Integer 145 construction\nnPaths Integer 85 nPaths Graph 104 nTrees Integer 86 nValues Integer 61 nValues-list Integer 125 nValues-set Integer 126 nValues-mset Integer 127\nnValues.increasing Integer 133 restriction or Integer 144 meta\nordered Integer 58 ordered-list Integer 122 ordered-set Integer 123 ordered-mset Integer 123 ordered-matrix Integer 128\nordered Set 123 partition Set 101\npath Integer 84 path Graph 103\npermutation Integer 74 permutation.increasing Integer 134 restriction\npoint Qualitative 109 precedence Integer 74 precedence Set 101\nrange Set 98 rcc8 Qualitative 110\nregular Integer 52 roots Set 98 same Integer see soft-permutation seqbin Integer 140 meta\nsequence Integer 138 slide Integer 136 meta\nslidingSum Integer 139 construction smooth Integer see soft-slide\nsoft-allDifferent Integer 156 soft-and Integer 153 meta\nsoft-cardinality Integer 156 soft-extension Integer 151 soft-intension Integer 149 soft-permutation Integer 157 soft-regular Integer 157\n212\nsoft-slide Integer 154 meta softSlidingSum Integer see soft-slide\nsort Integer see permutation.increasing restriction spread Integer 64 stretch Integer 75\nstrictlyDecreasing Integer see ordered strictlyIncreasing Integer see ordered\nsum Integer 59 sum Real 108 sum Set 96\nsumCosts Integer 65 table Integer see extension tree Integer 86\nweighted-allDifferent Integer ?? weighted-cardinality Integer ?? weighted-extension Integer 152 weighted-intension Integer 150 weighted-permutation Integer 152 weighted-regular Integer ??\n213\nD XML and JSON\nJSON (JavaScript Object Notation) is another popular language-independent data format. We show in this appendix how we can translate XCSP3 instances from XML to JSON, without loosing any information. However, note that although JSON allows us to build objects with duplicate keys, JSON decoders might handle those objects differently; we discuss this important issue at the end of this chapter. We basically adopt and adapt the rules proposed by O\u2019Reilly (www.xml.com).\n\u2022 Each XML attribute is represented as a name/value property. The name of the property is the name of the attribute preceded by @, and the value of the property is the value of the attribute.\n\u2022 Each XML element is represented as a name/value property. The name of the property is the name of the element, and the value of the property is defined as follows:\n\u2013 If the element has no attribute and no content, the value is \u201cnull\u201d.\n\u2013 If the element has no attribute and only a (non-empty) textual content, the value is the textual content.\n\u2013 In all other cases, the value is an object with each XML attribute and each child element represented as a property of the object. Note that a child text node is represented by a property with \u201d#text\u201d as name and the text as value, except for the following special cases:\n\u2217 if the parent node name is \u201cvar\u201d or \u201carray\u201d, then the name of the property (for the child text node) is \u201cdomain\u201d, \u2217 if the parent node name is \u201cintension\u201d, then the name of the property (for the child text node) is \u201cfunction\u201d, \u2217 if the parent node name is \u201cminimize\u201d or \u201cmaximize\u201d, then the name of the property (for the child text node) is either \u201cexpression\u201d (if the objective has a functional form) or \u201clist\u201d (if the objective has a specialized form); see forms of objectives in Chapter 3,\n214\n\u2217 if the parent node name is \u201callDifferent\u201d, \u201callEqual\u201d, \u201cordered\u201d, \u201cchannel\u201d, \u201ccircuit\u201d, \u201cclause\u201d, \u201ccube\u201d, or \u201callIntersecting\u201d, the name of the property (for the child text node) is \u201clist\u201d.\n\u2013 Refining the previous rule, any sequence of XML elements of same names, is represented as a property whose name is the name of the elements and the value an array containing the values of these elements in sequence.\n\u2013 The order of elements must be preserved.\n\u2013 The root element \u201cinstance\u201d is not represented. We directly give the representation of the content of this element (together with its attributes). So, for a CSP instance, we obtain something like:\n{\n\"@format\": \"XCSP3\", \"@type\": \"CSP\", ...\n}\ninstead of:\n{\n\"instance\": {\n\"@format\": \"XCSP3\", \"@type\": \"CSP\", ...\n}\n}\nAn illustration of these rules (special cases are not illustrated) is given below:\n215\n<elt/> \"elt\": null\n<elt> \"elt\": \"text\"\ntext\n</elt>\n<elt \"elt\": {\natt=\"val\" \"@att\": \"val\"\n/> }\n<elt \"elt\": {\natt1=\"val1\" \"@att1\": \"val1\", att2=\"val2\" \"@att2\": \"val2\"\n/> }\n<elt att=\"val\"> \"elt\": {\ntext \"@att\": \"val\", </elt> \"#text\": \"text\"\n}\n<elt> \"elt\": {\n<a> text1 </a> \"a\": \"text1\", <b> text2 </b> \"b\": \"text2\"\n</elt> }\n<elt> \"elt\": {\n<a> text1 </a> \"a\": [ <a> text2 </a> \"text1\",\n</elt> \"text2\"\n]\n}\n<elt> \"elt\": {\n<a> text1 </a> \"a\": [ <a att=\"val\"> text2 </a> \"text1\", <b> text3 </b> { \"@att\": \"val\", \"#text\": \"text2\" } <a> text4 </a> ],\n</elt> \"b\": \"text3\",\n\"a\": \"text4\"\n}\nAn XSLT-based converter will be made available soon on our website.\nRemark 53 JSON is an attractive format. However, in our context of representing CP instances, the reader must be aware of two possible limitations, described below.\nFirst, although it is theoretically valid to build objects with duplicate keys, JSON parsers may behave differently. For example,\n216\nJSON.parse(\u2019{\"a\": \"texta\", \"b\" :\"textb\", \"a\": \"texta2 \"}\u2019)\nyields with some parsers:\n{ a: \"texta2\", b: \"textb\" }\nJust imagine what you can obtain with the following constraints:\n<constraints >\n<intension > eq(x,0) </intension > <extension >\n<list > t[0] t[1] </list > <supports > (2,4)(3,5) </supports >\n</extension > <intension > le(y,z) </intension >\n</constraints >\ntranslated in JSON as:\n\"constraints\": {\n\"intension\": \"eq(x,0)\", \"extension\": {\n\"list\": \"t[0] t[1]\", \"supports\": \"(2,4)(3,5)\"\n}, \"intension\": \"le(y,z)\"\n}\nIf the parser you use has not the appropriate behavior for our purpose, you have to transform the JSON file, putting in arrays the contents of similar keys. In our example, this would give:\n\"constraints\": {\n\"intension\": [\"eq(x,0)\", \"le(y,z)\"], \"extension\": {\n\"list\": \"t[0] t[1]\", \"supports\": \"(2,4)(3,5)\"\n}\n}\nNote that the initial order of constraints cannot be preserved. Besides, for some frameworks (e.g., SCSP, QCSP), is not possible to proceed that way. We have to define other transformation rules for cases like:\n217\n<quantification >\n<exists > w x </exists > <forall > y </forall > <exists > z </exists >\n</quantification >\n218\nE Versioning\n\u2022 XCSP3, version 3.0.4. Published on August 20, 2016. A few modifications about soft constraints have been achieved: see Chapter 9 and Section 11.3.1. Simple relaxation is now possible, simplified use of cost variable is authorized, and we have a better integration between relaxed constraints and cost functions. Constraint sum now admits variable coefficients. The semantics of constraints circuit, path and tree have been slighlty modified.\n\u2022 XCSP3, version 3.0.3. Published on May 20, 2016. Solutions can now be represented; see Section 2.11. Related to solutions, the constraint instantiation is introduced; see Section 4.1.8.2. It generalizes and replaces the constraint cube. XCSP3-core has been slightly updated: it involves now 20 constraints (including the constraint instantiation and the meta-constraint slide); see Section 1.4. More examples are given in Section 1.2, when presenting the skeleton of XCSP3 instances. A problem with the semantics of slide has been fixed; see Section 8.1.\n\u2022 XCSP3, version 3.0.2. Published on February 5, 2016. XCSP3 is an intermediate format, as explained in Section 1.1. More information about \u201cXML versus JSON\u201d is given in Appendix D as well as in Section 1.3 of Chapter 1; limitations of JSON are identified. New universal attributes are introduced: note for associating a short comment with any element, and class for associating either predefined or user-defined tags with any element; this is discussed in Sections 1.6 and 10.2.\n\u2022 XCSP3, version 3.0.1. Published on October 27, 2015. Converting XCSP3 instances from XML to JSON is discussed in a new Appendix as well as in Section 1.3 of Chapter 1. XCSP3-core is introduced in Section 1.4 of Chapter 1.\n\u2022 XCSP3, version 3.0.0. First official version. Published on September 1, 2015. \u2022 XCSP3, Release Candidate. Published on June 22, 2015.\n219\nBibliography\n[1] A. Aggoun and N. Beldiceanu. Extending chip in order to solve complex scheduling and placement problems. Mathematical and Computer Modelling, 17(7):57\u201373, 1993.\n[2] J.F. Allen. An interval-based representation of temporal knowledge. In Proceedings of IJCAI\u201981, pages 221\u2013226, 1981.\n[3] K.R. Apt. Principles of Constraint Programming. Cambridge University Press, 2003.\n[4] N. Beldiceanu and M. Carlsson. Revisiting the cardinality operator and introducing the cardinality-path constraint family. In Proceedings of ICLP\u201901, pages 59\u201373, 2001.\n[5] N. Beldiceanu and M. Carlsson. A new multi-resource cumulatives constraint with negative heights. In Proceedings of CP\u201902, pages 63\u201379, 2002.\n[6] N. Beldiceanu, M. Carlsson, and J.-X. Rampon. Global constraint catalog. Technical Report T2012:03, TASC-SICS-LINA, 2014.\n[7] N. Beldiceanu, M. Carlsson, and S. Thiel. Cost-filtering algorithms for the two sides of the sum of weights of distinct values. Technical Report T2002-14, Swedish Institute of Computer Science, 2002.\n[8] N. Beldiceanu and E. Contejean. Introducing global constraints in CHIP. Mathematical and Computer Modelling, 20(12):97\u2013123, 1994.\n[9] N. Beldiceanu, P. Flener, and X. Lorca. The tree constraint. In Proceedings of CPAIOR\u201905, pages 64\u201378, 2005.\n[10] N. Beldiceanu, F. Hermenier, X. Lorca, and T. Petit. The increasing nvalue constraint. In Proceedings of CPAIOR\u201910, pages 25\u201339, 2010.\n[11] N. Beldiceanu, I. Katriel, and S. Thiel. Filtering algorithms for the Same and UsedBy constraints. Technical Report MPI-I-2004-1-001, Max Planck Institut Informartik, 2004.\n[12] N. Beldiceanu and T. Petit. Cost evaluation of soft global constraints. In Proceedings of CPAIOR\u201904, pages 80\u201395, 2004.\n[13] M. Benedetti, A. Lallouet, and J. Vautard. QCSP made practical by virtue of restricted quantification. In Proceedings of IJCAI\u201907, pages 6\u201312, 2007.\n[14] M. Benedetti, A. Lallouet, and J. Vautard. Quantified constraint optimization. In Proceedings of CP\u201908, pages 463\u2013477, 2008.\n220\n[15] C. Bessiere. Arc consistency and arc consistency again. Artificial Intelligence, 65:179\u2013190, 1994.\n[16] C. Bessiere, E. Hebrard, B. Hnich, Z. Kiziltan, and T. Walsh. The range and roots constraints: Specifying counting and occurrence problems. In Proceedings of IJCAI\u201905, pages 60\u201365, 2005.\n[17] C. Bessiere, E. Hebrard, B. Hnich, Z. Kiziltan, and T. Walsh. Filtering algorithms for the nvalue constraint. Constraints, 11(4):271\u2013293, 2006.\n[18] C. Bessiere, E. Hebrard, B. Hnich, Z. Kiziltan, and T. Walsh. The range constraint: Algorithms and implementation. In Proceedings of CPAIOR\u201906, pages 59\u201373, 2006.\n[19] C. Bessiere, E. Hebrard, B. Hnich, Z. Kiziltan, and T. Walsh. The roots constraint. In Proceedings of CP\u201906, pages 75\u201390, 2006.\n[20] C. Bessiere, E. Hebrard, B. Hnich, Z. Kiziltan, and T. Walsh. SLIDE: A useful special case of the CARDPATH constraint. In Proceedings of ECAI\u201908, pages 475\u2013479, 2008.\n[21] C. Bessiere, E. Hebrard, G. Katsirelos, Z. Kiziltan, E. Picard-Cantin, C.-G. Quimper, and T. Walsh. The balance constraint family. In Proceedings of CP\u201914, pages 174\u2013189, 2014.\n[22] C. Bessiere and J. Re\u0301gin. Arc consistency for general constraint networks: preliminary results. In Proceedings of IJCAI\u201997, pages 398\u2013404, 1997.\n[23] C. Bessiere, J.-C. Re\u0301gin, R. Yap, and Y. Zhang. An optimal coarse-grained arc consistency algorithm. Artificial Intelligence, 165(2):165\u2013185, 2005.\n[24] S. Bistarelli, U. Montanari, F. Rossi, T. Schiex, G. Verfaillie, and H. Fargier. Semiringbased CSPs and valued CSPs: Frameworks, properties, and comparison. Constraints, 4(3):199\u2013240, 1999.\n[25] L. Bordeaux and E. Monfroy. Beyond NP: Arc-Consistency for quantified constraints. In Proceedings of CP\u201902, pages 371\u2013386, 2002.\n[26] F. Boussemart, F. Hemery, C. Lecoutre, and L. Sais. Boosting systematic search by weighting constraints. In Proceedings of ECAI\u201904, pages 146\u2013150, 2004.\n[27] D. Brelaz. New methods to color the vertices of a graph. Communications of the ACM, 22:251\u2013256, 1979.\n[28] C. and G. Tack. Views and iterators for generic constraint implementations. In Proceedings of CSCLP\u201905, pages 118\u2013132, 2005.\n[29] H. Cambazard, D. Mehta, B. O\u2019Sullivan, and H. Simonis. Bin packing with linear usage costs - an application to energy management in data centres. In Proceedings of CP\u201913, pages 47\u201362, 2013.\n[30] J. Carlier. The one-machine sequencing problem. European Journal of Operational Research, 11:42\u201347, 1982.\n[31] M. Carlsson and N. Beldiceanu. Arc-consistency for a chain of lexicographic ordering constraints. Technical Report T2002-18, Swedish Institute of Computer Science, 2002.\n221\n[32] M. Carlsson and N. Beldiceanu. Revisiting the lexicographic ordering constraint. Technical Report T2002-17, Swedish Institute of Computer Science, 2002.\n[33] M. Carlsson and N. Beldiceanu. From constraints to finite automata to filtering algorithms. In Proceedings of ESOP\u201904, pages 94\u2013108, 2004.\n[34] M. Carlsson, M. Ottosson, and B. Carlson. An open-ended finite domain constraint solver. In Proceedings of PLILP\u201997, pages 191\u2013306, 1997.\n[35] K. Cheng and R. Yap. Maintaining generalized arc consistency on ad-hoc n-ary Boolean constraints. In Proceedings of ECAI\u201906, pages 78\u201382, 2006.\n[36] K. Cheng and R. Yap. Maintaining generalized arc consistency on ad-hoc r-ary constraints. In Proceedings of CP\u201908, pages 509\u2013523, 2008.\n[37] K. Cheng and R. Yap. An MDD-based generalized arc consistency algorithm for positive and negative table constraints and some global constraints. Constraints, 15(2):265\u2013304, 2010.\n[38] C. Choi, W. Harvey, J. Lee, and P. Stuckey. Finite domain bounds consistency revisited. In Proceedings of Australian Conference on Artificial Intelligence, pages 49\u201358, 2006.\n[39] M. Cooper, S. de Givry, M. Sanchez, T. Schiex, M. Zytnicki, and T. Werner. Soft arc consistency revisited. Artificial Intelligence, 174(7-8):449\u2013478, 2010.\n[40] R. Cymer. Dulmage-mendelsohn canonical decomposition as a generic pruning technique. Constraints, 17(3):234\u2013272, 2012.\n[41] M. Garcia de la Banda, K. Marriott, R. Rafeh, and M. Wallace. The modelling language Zinc. In Proceedings of CP\u201906, pages 700\u2013705, 2006.\n[42] R. Dechter, I. Meiri, and J. Pearl. Temporal constraint networks. Artificial Intelligence, 49(1-3):61\u201395, 1991.\n[43] S. Demassey, G. Pesant, and L.-M. Rousseau. A cost-regular based hybrid column generation approach. Constraints, 11(4):315\u2013333, 2006.\n[44] G. Dooms, Y. Deville, and P. Dupont. CP(Graph): Introducing a graph computation domain in constraint programming. In Proceedings of CP\u201905, pages 211\u2013225, 2005.\n[45] J.-G. Fages. Exploitation de structures de graphe en programmation par contraintes. PhD thesis, Ecole nationale supe\u0301rieure des mines de Nantes, 2014.\n[46] J.-G. Fages and X. Lorca. Revisiting the tree constraint. In Proceedings of CP\u201911, pages 271\u2013285, 2011.\n[47] T. Fahle and M. Sellmann. Cost based filtering for the constrained knapsack problem. Annals OR, 115(1-4):73\u201393, 2002.\n[48] H. Fargier. Proble\u0300mes de satisfaction de contraintes flexibles - application a\u0300 l\u2019ordonnancement de production. PhD thesis, Universite\u0301 Paul Sabatier de Toulouse, 1994.\n[49] T. Feydy, Z. Somogyi, and P. Stuckey. Half reification and flattening. In Proceedings of CP\u201911, pages 286\u2013301, 2011.\n222\n[50] P. Flener, A.M. Frisch, B. Hnich, Z. Kiziltan, I. Miguel, J. Pearson, and T. Walsh. Breaking row and column symmetries in matrix models. In Proceedings of CP\u201902, pages 462\u2013476, 2002.\n[51] P. Flener, J. Pearson, and M. A\u030agren. Introducing ESRA, a relational language for modelling combinatorial problems. In LOPSTR\u201903: Revised Selected Papers, pages 214\u2013232, 2004.\n[52] F. Focacci, A. Lodi, and M. Milano. Cost-based domain filtering. In Proceedings of CP\u201999, pages 189\u2013203, 1999.\n[53] A. Frisch, M. Grum, C. Jefferson, B. Martinez Hernandez, and I. Miguel. The design of ESSENCE: A constraint language for specifying combinatorial problems. In Proceedings of IJCAI\u201907, pages 80\u201387, 2007.\n[54] A. Frisch, B. Hnich, Z. Kiziltan, I. Miguel, and T. Walsh. Global constraints for lexicographic orderings. In Proceedings of CP\u201902, pages 93\u2013108, 2002.\n[55] D. Frost and R. Dechter. Look-ahead value ordering for constraint satisfaction problems. In Proceedings of IJCAI\u201995, pages 572\u2013578, 1995.\n[56] P.A. Geelen. Dual viewpoint heuristics for binary constraint satisfaction problems. In Proceedings of ECAI\u201992, pages 31\u201335, 1992.\n[57] I.P. Gent, C. Jefferson, I. Miguel, and P. Nightingale. Data structures for generalised arc consistency for extensional constraints. In Proceedings of AAAI\u201907, pages 191\u2013197, 2007.\n[58] I.P. Gent, I. Miguel, and P. Nightingale. Generalised arc consistency for the alldifferent constraint: An empirical survey. Artificial Intelligence, 172(18):1973\u20132000, 2008.\n[59] C. Gervet. Interval propagation to reason about sets: Definition and implementation of a practical language. Constraints, 1(3):191\u2013244, 1997.\n[60] C. Gervet. Constraints over structured domains. In Handbook of Constraint Programming, chapter 17, pages 603\u2013636. Elsevier, 2006.\n[61] C. Gervet and P. Van Hentenryck. Length-lex ordering for set CSPs. In Proceedings of AAAI\u201906, pages 48\u201353, 2006.\n[62] R.M. Haralick and G.L. Elliott. Increasing tree search efficiency for constraint satisfaction problems. Artificial Intelligence, 14:263\u2013313, 1980.\n[63] P. Van Hentenryck and J.-P. Carillon. Generality versus specificity: An experience with AI and OR techniques. In Proceedings of AAAI\u201988, pages 660\u2013664, 1988.\n[64] M. Henz, T. Mller, and S. Thiel. Global constraints for round robin tournament scheduling. European Journal of Operational Research, 153(1):92\u2013101, 2004.\n[65] J.N. Hooker. Integrated Methods for Optimization. Springer, 2012.\n[66] S. Kadioglu and M. Sellmann. Efficient context-free grammar constraints. In Proceedings of AAAI\u201908, pages 310\u2013316, 2008.\n[67] S. Kadioglu and M. Sellmann. Grammar constraints. Constraints, 15(1):117\u2013144, 2010.\n223\n[68] G. Katsirelos, N. Narodytska, and T. Walsh. The seqbin constraint revisited. In Proceedings of ICP\u201912, pages 332\u2013347, 2012.\n[69] G. Katsirelos and T. Walsh. A compression algorithm for large arity extensional constraints. In Proceedings of CP\u201907, pages 379\u2013393, 2007.\n[70] M. Koubarakis. Temporal CSPs. In Handbook of Constraint Programming, chapter 19, pages 663\u2013695. Elsevier, 2006.\n[71] J. Larrosa. Node and arc consistency in weighted CSP. In Proceedings of AAAI\u201902, pages 48\u201353, 2002.\n[72] J. Larrosa and T. Schiex. In the quest of the best form of local consistency for Weighted CSP. In Proceedings of IJCAI\u201903, pages 363\u2013376, 2003.\n[73] J. Larrosa and T. Schiex. Solving weighted CSP by maintaining arc consistency. Artificial Intelligence, 159(1-2):1\u201326, 2004.\n[74] Y.C. Law and J. Lee. Global constraints for integer and set value precedence. In Proceedings of CP\u201904, pages 362\u2013376, 2004.\n[75] C. Lecoutre. STR2: Optimized simple tabular reduction for table constraints. Constraints, 16(4):341\u2013371, 2011.\n[76] C. Lecoutre and F. Hemery. A study of residual supports in arc consistency. In Proceedings of IJCAI\u201907, pages 125\u2013130, 2007.\n[77] C. Lecoutre, C. Likitvivatanavong, and R. Yap. A path-optimal GAC algorithm for table constraints. In Proceedings of ECAI\u201912, pages 510\u2013515, 2012.\n[78] C. Lecoutre, L. Sais, S. Tabary, and V. Vidal. Reasonning from last conflict(s) in constraint programming. Artificial Intelligence, 173(18):1592\u20131614, 2009.\n[79] C. Lecoutre and R. Szymanek. Generalized arc consistency for positive table constraints. In Proceedings of CP\u201906, pages 284\u2013298, 2006.\n[80] C. Lecoutre and J. Vion. Enforcing arc consistency using bitwise operations. Constraint Programming Letters, 2:21\u201335, 2008.\n[81] O. Lhomme. Arc-consistency filtering algorithms for logical combinations of constraints. In Proceedings of CPAIOR\u201904, pages 209\u2013224, 2004.\n[82] O. Lhomme. Practical reformulations with table constraints. In Proceedings of ECAI\u201912, pages 911\u2013912, 2012.\n[83] O. Lhomme and J.-C. Re\u0301gin. A fast arc consistency algorithm for n-ary constraints. In Proceedings of AAAI\u201905, pages 405\u2013410, 2005.\n[84] G. Ligozat and J. Renz. What is a qualitative calculus? a general framework. In Proceedings of PRICAI\u201904, pages 53\u201364, 2004.\n[85] A.K. Mackworth. Consistency in networks of relations. Artificial Intelligence, 8(1):99\u2013 118, 1977.\n224\n[86] J.-B. Mairy, P. van Hentenryck, and Y. Deville. An optimal filtering algorithm for table constraints. In Proceedings of CP\u201912, pages 496\u2013511, 2012.\n[87] Y. Malitsky, M. Sellmann, and R. Szymanek. Filtering bounded knapsack constraints in expected sublinear time. In Proceedings of AAAI\u201910, pages 141\u2013146, 2010.\n[88] J. Menana and S. Demassey. Sequencing and counting with the multicost-regular constraint. In Proceedings of CPAIOR\u201909, pages 178\u2013192, 2009.\n[89] P. Meseguer, F. Rossi, and T. Schiex. Soft constraints. In Handbook of Constraint Programming, chapter 9, pages 281\u2013328. Elsevier, 2006.\n[90] L. Michel and P. Van Hentenryck. Activity-based search for black-box constraint programming solvers. In Proceedings of CPAIOR\u201912, pages 228\u2013243, 2012.\n[91] S. Minton, M.D. Johnston, A.B. Philips, and P. Laird. Minimizing conflicts: a heuristic repair method for constraint-satisfaction and scheduling problems. Artificial Intelligence, 58(1-3):161\u2013205, 1992.\n[92] R. Mohr and T.C. Henderson. Arc and path consistency revisited. Artificial Intelligence, 28:225\u2013233, 1986.\n[93] P. Nightingale, I.P. Gent, C. Jefferson, and I. Miguel. Short and long supports for constraint propagation. Journal of Artificial Intelligence Research, 46:1\u201345, 2013.\n[94] G. Perez and J.-C. Re\u0301gin. Improving GAC-4 for Table and MDD constraints. In Proceedings of CP\u201914, pages 606\u2013621, 2014.\n[95] G. Pesant. A filtering algorithm for the stretch constraint. In Proceedings of CP\u201901, pages 183\u2013195, 2001.\n[96] G. Pesant. A regular language membership constraint for finite sequences of variables. In Proceedings of CP\u201904, pages 482\u2013495, 2004.\n[97] G. Pesant and C.-G. Quimper. Counting solutions of knapsack constraints. In Proceedings of CPAIOR\u201908, pages 203\u2013217, 2008.\n[98] G. Pesant and J.-C. Re\u0301gin. SPREAD: A balancing constraint based on statistics. In Proceedings of CP\u201905, pages 460\u2013474, 2005.\n[99] T. Petit, N. Beldiceanu, and X. Lorca. A generalized arc-consistency algorithm for a class of counting constraint. In Proceedings of IJCAI\u201911, pages 643\u2013648, 2011.\n[100] T. Petit, J.-C. Re\u0301gin, and C. Bessiere. Meta-constraints on violations for over constrained problems. In Proceedings of ICTAI\u201900, pages 358\u2013365, 2000.\n[101] T. Petit, J.-C. Re\u0301gin, and C. Bessiere. Specific filtering algorithms for over-constrained problems. In Proceedings of CP\u201901, pages 451\u2013463, 2001.\n[102] C.-G. Quimper, A. Lopez-Ortiz, and G. Pesant. A quadratic propagator for the interdistance constraint. In Proceedings of AAAI\u201906, pages 123\u2013128, 2006.\n[103] C.-G. Quimper and T. Walsh. Beyond finite domains: The all different and global cardinality constraints. In Proceedings of CP\u201905, pages 812\u2013816, 2005.\n225\n[104] C.-G. Quimper and T. Walsh. Decomposing global grammar constraints. In Proceedings of CP\u201907, pages 590\u2013604, 2007.\n[105] C.-G. Quimper and T. Walsh. Decompositions of grammar constraints. In Proceedings of AAAI\u201908, pages 1567\u20131570, 2008.\n[106] D.A. Randell, Z.Cui, and A.G. Cohn. A spatial logic based on regions and connection. In Proceedings of KR\u201992, pages 165\u2013176, 1992.\n[107] P. Refalo. Impact-based search strategies for constraint programming. In Proceedings of CP\u201904, pages 557\u2013571, 2004.\n[108] J.-C. Re\u0301gin. A filtering algorithm for constraints of difference in CSPs. In Proceedings of AAAI\u201994, pages 362\u2013367, 1994.\n[109] J.-C. Re\u0301gin. Generalized arc consistency for global cardinality constraint. In Proceedings of AAAI\u201996, pages 209\u2013215, 1996.\n[110] J.-C. Re\u0301gin. The global minimum distance constraint. Technical report, ILOG, 1997.\n[111] J.-C. Re\u0301gin. The symmetric alldiff constraint. In Proceedings of IJCAI\u201999, pages 420\u2013425, 1999.\n[112] J.-C. Re\u0301gin. Cost-based arc consistency for global cardinality constraints. Constraints, 7(3-4):387\u2013405, 2002.\n[113] J.-C. Re\u0301gin. Global constraints: a survey. In Hybrid Optimization, chapter 2, pages 63\u2013134. Springer, 2011.\n[114] J.-C. Re\u0301gin and C.P. Gomes. The cardinality matrix constraint. In Proceedings of CP\u201904, pages 572\u2013587, 2004.\n[115] J.-C. Re\u0301gin, T. Petit, C. Bessiere, and J.-F. Puget. An original constraint based approach for solving over constrained problems. In Proceedings of CP\u201900, pages 543\u2013548, 2000.\n[116] J.-C. Re\u0301gin and J.-F. Puget. A filtering algorithm for global sequencing constraints. In Proceedings of CP\u201997, pages 32\u201346, 1997.\n[117] G. Renker and H. Ahriz. Building models through formal specification. In Proceedings of CPAIOR\u201904, pages 395\u2013401, 2004.\n[118] P. Schaus. Solving Balancing and Bin-Packing problems with Constraint Programming. PhD thesis, Universite\u0308 catholique de Louvain la Neuve, 2009.\n[119] P. Schaus, Y. Deville, P. Dupont, and J.-C. Re\u0301gin. Simplification and extension of the SPREAD constraint. In Proceedings of CPAI\u201906 Workshop held with CP\u201906, pages 72\u201392, 2006.\n[120] P. Schaus, Y. Deville, P. Dupont, and J.-C. Re\u0301gin. The Deviation constraint. In Proceedings of CPAIOR\u201907, pages 260\u2013274, 2007.\n[121] M. Sellmann. Approximated consistency for knapsack constraints. In Proceedings of CP\u201903, pages 679\u2013693, 2003.\n226\n[122] M. Sellmann. The theory of grammar constraints. In Proceedings of CP\u201906, pages 530\u2013 544, 2006.\n[123] P. Shaw. A constraint for bin packing. In Proceedings of CP\u201904, pages 648\u2013662, 2004.\n[124] B.M. Smith. The brelaz heuristic and optimal static orderings. In Proceedings of CP\u201999, pages 405\u2013418, Alexandria, VA, 1999.\n[125] M. Trick. A dynamic programming approach for consistency and propagation for knapsack constraints. Annals OR, 118(1-4):73\u201384, 2003.\n[126] E. Tsang, P. Mills, R. Williams, J. Ford, and J. Borrett. A computer-aided constraint programming system. In Proceedings of PACLP\u201999, pages 81\u201393, 1999.\n[127] J.R. Ullmann. An algorithm for subgraph isomorphism. Journal of the ACM, 23(1):31\u201342, 1976.\n[128] P. van Hentenryck. The OPL Optimization Programming Language. The MIT Press, 1999.\n[129] P. van Hentenryck and Y. Deville. The cardinality operator: A new logical connective for constraint logic programming. In Proceedings of ICLP\u201991, pages 745\u2013759, 1991.\n[130] W. van Hoeve, G. Pesant, and L.-M. Rousseau. On global warming: Flow-based soft global constraints. Journal of Heuristics, 12(4-5):347\u2013373, 2006.\n[131] W.J. van Hoeve. The alldifferent constraint: a survey. In Proceedings of the Sixth Annual Workshop of the ERCIM Working Group on Constraints, 2001.\n[132] W.J. van Hoeve and I. Katriel. Global constraints. In Handbook of Constraint Programming, chapter 6, pages 169\u2013208. Elsevier, 2006.\n[133] W.J. van Hoeve, G. Pesant, L.-M. Rousseau, and A. Sabharwal. Revisiting the sequence constraint. In Proceedings of CP\u201906, pages 620\u2013634, 2006.\n[134] World Wide Web Consortium (W3C). Extensible Markup Language (XML). http://www.w3.org/XML/, 1997.\n[135] T. Walsh. Stochastic constraint programming. In Proceedings of ECAI\u201902, pages 111\u2013115, 2002.\n[136] T. Walsh. Symmetry breaking using value precedence. In Proceedings of ECAI\u201906, pages 168\u2013172, 2006.\n[137] W. Xia and R. Yap. Optimizing STR algorithms with tuple compression. In Proceedings of CP\u201913, pages 724\u2013732, 2013.\n[138] J. Zhou. Introduction to the constraint language NCL. Journal of Logic Programming, 45(1-3):71\u2013103, 2000.\n227"}], "references": [{"title": "Extending chip in order to solve complex scheduling and placement problems", "author": ["A. Aggoun", "N. Beldiceanu"], "venue": "Mathematical and Computer Modelling, 17(7):57\u201373,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1993}, {"title": "An interval-based representation of temporal knowledge", "author": ["J.F. Allen"], "venue": "Proceedings of IJCAI\u201981, pages 221\u2013226,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1981}, {"title": "Principles of Constraint Programming", "author": ["K.R. Apt"], "venue": "Cambridge University Press,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2003}, {"title": "Revisiting the cardinality operator and introducing the cardinality-path constraint family", "author": ["N. Beldiceanu", "M. Carlsson"], "venue": "Proceedings of ICLP\u201901, pages 59\u201373,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2001}, {"title": "A new multi-resource cumulatives constraint with negative heights", "author": ["N. Beldiceanu", "M. Carlsson"], "venue": "Proceedings of CP\u201902, pages 63\u201379,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2002}, {"title": "Global constraint catalog", "author": ["N. Beldiceanu", "M. Carlsson", "J.-X. Rampon"], "venue": "Technical Report T2012:03, TASC-SICS-LINA,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2014}, {"title": "Cost-filtering algorithms for the two sides of the sum of weights of distinct values", "author": ["N. Beldiceanu", "M. Carlsson", "S. Thiel"], "venue": "Technical Report T2002-14, Swedish Institute of Computer Science,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2002}, {"title": "Introducing global constraints in CHIP", "author": ["N. Beldiceanu", "E. Contejean"], "venue": "Mathematical and Computer Modelling, 20(12):97\u2013123,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1994}, {"title": "The tree constraint", "author": ["N. Beldiceanu", "P. Flener", "X. Lorca"], "venue": "Proceedings of CPAIOR\u201905, pages 64\u201378,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2005}, {"title": "The increasing nvalue constraint", "author": ["N. Beldiceanu", "F. Hermenier", "X. Lorca", "T. Petit"], "venue": "Proceedings of CPAIOR\u201910, pages 25\u201339,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "Filtering algorithms for the Same and UsedBy constraints", "author": ["N. Beldiceanu", "I. Katriel", "S. Thiel"], "venue": "Technical Report MPI-I-2004-1-001, Max Planck Institut Informartik,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2004}, {"title": "Cost evaluation of soft global constraints", "author": ["N. Beldiceanu", "T. Petit"], "venue": "Proceedings of CPAIOR\u201904, pages 80\u201395,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "QCSP made practical by virtue of restricted quantification", "author": ["M. Benedetti", "A. Lallouet", "J. Vautard"], "venue": "Proceedings of IJCAI\u201907, pages 6\u201312,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2007}, {"title": "Quantified constraint optimization", "author": ["M. Benedetti", "A. Lallouet", "J. Vautard"], "venue": "Proceedings of CP\u201908, pages 463\u2013477,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2008}, {"title": "Arc consistency and arc consistency again", "author": ["C. Bessiere"], "venue": "Artificial Intelligence, 65:179\u2013190,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1994}, {"title": "The range and roots constraints: Specifying counting and occurrence problems", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of IJCAI\u201905, pages 60\u201365,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2005}, {"title": "Filtering algorithms for the nvalue constraint", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Constraints, 11(4):271\u2013293,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "The range constraint: Algorithms and implementation", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of CPAIOR\u201906, pages 59\u201373,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2006}, {"title": "The roots constraint", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of CP\u201906, pages 75\u201390,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2006}, {"title": "SLIDE: A useful special case of the CARDPATH constraint", "author": ["C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh"], "venue": "Proceedings of ECAI\u201908, pages 475\u2013479,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2008}, {"title": "The balance constraint family", "author": ["C. Bessiere", "E. Hebrard", "G. Katsirelos", "Z. Kiziltan", "E. Picard-Cantin", "C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of CP\u201914, pages 174\u2013189,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2014}, {"title": "Arc consistency for general constraint networks: preliminary results", "author": ["C. Bessiere", "J. R\u00e9gin"], "venue": "Proceedings of IJCAI\u201997, pages 398\u2013404,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1997}, {"title": "An optimal coarse-grained arc consistency algorithm", "author": ["C. Bessiere", "J.-C. R\u00e9gin", "R. Yap", "Y. Zhang"], "venue": "Artificial Intelligence, 165(2):165\u2013185,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2005}, {"title": "Semiringbased CSPs and valued CSPs: Frameworks, properties, and comparison", "author": ["S. Bistarelli", "U. Montanari", "F. Rossi", "T. Schiex", "G. Verfaillie", "H. Fargier"], "venue": "Constraints, 4(3):199\u2013240,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1999}, {"title": "Beyond NP: Arc-Consistency for quantified constraints", "author": ["L. Bordeaux", "E. Monfroy"], "venue": "Proceedings of CP\u201902, pages 371\u2013386,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2002}, {"title": "Boosting systematic search by weighting constraints", "author": ["F. Boussemart", "F. Hemery", "C. Lecoutre", "L. Sais"], "venue": "Proceedings of ECAI\u201904, pages 146\u2013150,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2004}, {"title": "New methods to color the vertices of a graph", "author": ["D. Brelaz"], "venue": "Communications of the ACM, 22:251\u2013256,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1979}, {"title": "Views and iterators for generic constraint implementations", "author": ["G. Tack"], "venue": "In Proceedings of CSCLP\u201905,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2005}, {"title": "Bin packing with linear usage costs - an application to energy management in data centres", "author": ["H. Cambazard", "D. Mehta", "B. O\u2019Sullivan", "H. Simonis"], "venue": "In Proceedings of CP\u201913,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2013}, {"title": "The one-machine sequencing problem", "author": ["J. Carlier"], "venue": "European Journal of Operational Research, 11:42\u201347,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 1982}, {"title": "Arc-consistency for a chain of lexicographic ordering constraints", "author": ["M. Carlsson", "N. Beldiceanu"], "venue": "Technical Report T2002-18, Swedish Institute of Computer Science,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2002}, {"title": "Revisiting the lexicographic ordering constraint", "author": ["M. Carlsson", "N. Beldiceanu"], "venue": "Technical Report T2002-17, Swedish Institute of Computer Science,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2002}, {"title": "From constraints to finite automata to filtering algorithms", "author": ["M. Carlsson", "N. Beldiceanu"], "venue": "Proceedings of ESOP\u201904, pages 94\u2013108,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2004}, {"title": "An open-ended finite domain constraint solver", "author": ["M. Carlsson", "M. Ottosson", "B. Carlson"], "venue": "Proceedings of PLILP\u201997, pages 191\u2013306,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1997}, {"title": "Maintaining generalized arc consistency on ad-hoc n-ary Boolean constraints", "author": ["K. Cheng", "R. Yap"], "venue": "Proceedings of ECAI\u201906, pages 78\u201382,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2006}, {"title": "Maintaining generalized arc consistency on ad-hoc r-ary constraints", "author": ["K. Cheng", "R. Yap"], "venue": "Proceedings of CP\u201908, pages 509\u2013523,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2008}, {"title": "An MDD-based generalized arc consistency algorithm for positive and negative table constraints and some global constraints", "author": ["K. Cheng", "R. Yap"], "venue": "Constraints, 15(2):265\u2013304,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2010}, {"title": "Finite domain bounds consistency revisited", "author": ["C. Choi", "W. Harvey", "J. Lee", "P. Stuckey"], "venue": "Proceedings of Australian Conference on Artificial Intelligence, pages 49\u201358,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2006}, {"title": "Soft arc consistency revisited", "author": ["M. Cooper", "S. de Givry", "M. Sanchez", "T. Schiex", "M. Zytnicki", "T. Werner"], "venue": "Artificial Intelligence,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2010}, {"title": "Dulmage-mendelsohn canonical decomposition as a generic pruning technique", "author": ["R. Cymer"], "venue": "Constraints, 17(3):234\u2013272,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2012}, {"title": "The modelling language Zinc", "author": ["M. Garcia de la Banda", "K. Marriott", "R. Rafeh", "M. Wallace"], "venue": "In Proceedings of CP\u201906,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2006}, {"title": "Temporal constraint networks", "author": ["R. Dechter", "I. Meiri", "J. Pearl"], "venue": "Artificial Intelligence, 49(1-3):61\u201395,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 1991}, {"title": "A cost-regular based hybrid column generation approach", "author": ["S. Demassey", "G. Pesant", "L.-M. Rousseau"], "venue": "Constraints, 11(4):315\u2013333,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2006}, {"title": "CP(Graph): Introducing a graph computation domain in constraint programming", "author": ["G. Dooms", "Y. Deville", "P. Dupont"], "venue": "Proceedings of CP\u201905, pages 211\u2013225,", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2005}, {"title": "Exploitation de structures de graphe en programmation par contraintes", "author": ["J.-G. Fages"], "venue": "PhD thesis, Ecole nationale sup\u00e9rieure des mines de Nantes,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2014}, {"title": "Revisiting the tree constraint", "author": ["J.-G. Fages", "X. Lorca"], "venue": "Proceedings of CP\u201911, pages 271\u2013285,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2011}, {"title": "Cost based filtering for the constrained knapsack problem", "author": ["T. Fahle", "M. Sellmann"], "venue": "Annals OR, 115(1-4):73\u201393,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2002}, {"title": "Probl\u00e8mes de satisfaction de contraintes flexibles - application \u00e0 l\u2019ordonnancement de production", "author": ["H. Fargier"], "venue": "PhD thesis, Universit\u00e9 Paul Sabatier de Toulouse,", "citeRegEx": "48", "shortCiteRegEx": null, "year": 1994}, {"title": "Half reification and flattening", "author": ["T. Feydy", "Z. Somogyi", "P. Stuckey"], "venue": "Proceedings of CP\u201911, pages 286\u2013301,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2011}, {"title": "Breaking row and column symmetries in matrix models", "author": ["P. Flener", "A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "J. Pearson", "T. Walsh"], "venue": "Proceedings of CP\u201902, pages 462\u2013476,", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2002}, {"title": "Introducing ESRA, a relational language for modelling combinatorial problems", "author": ["P. Flener", "J. Pearson", "M. \u00c5gren"], "venue": "LOPSTR\u201903: Revised Selected Papers, pages 214\u2013232,", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2004}, {"title": "Cost-based domain filtering", "author": ["F. Focacci", "A. Lodi", "M. Milano"], "venue": "Proceedings of CP\u201999, pages 189\u2013203,", "citeRegEx": "52", "shortCiteRegEx": null, "year": 1999}, {"title": "The design of ESSENCE: A constraint language for specifying combinatorial problems", "author": ["A. Frisch", "M. Grum", "C. Jefferson", "B. Martinez Hernandez", "I. Miguel"], "venue": "Proceedings of IJCAI\u201907, pages 80\u201387,", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2007}, {"title": "Global constraints for lexicographic orderings", "author": ["A. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "T. Walsh"], "venue": "Proceedings of CP\u201902, pages 93\u2013108,", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2002}, {"title": "Look-ahead value ordering for constraint satisfaction problems", "author": ["D. Frost", "R. Dechter"], "venue": "Proceedings of IJCAI\u201995, pages 572\u2013578,", "citeRegEx": "55", "shortCiteRegEx": null, "year": 1995}, {"title": "Dual viewpoint heuristics for binary constraint satisfaction problems", "author": ["P.A. Geelen"], "venue": "Proceedings of ECAI\u201992, pages 31\u201335,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 1992}, {"title": "Data structures for generalised arc consistency for extensional constraints", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel", "P. Nightingale"], "venue": "Proceedings of AAAI\u201907, pages 191\u2013197,", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2007}, {"title": "Generalised arc consistency for the alldifferent constraint: An empirical survey", "author": ["I.P. Gent", "I. Miguel", "P. Nightingale"], "venue": "Artificial Intelligence, 172(18):1973\u20132000,", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2008}, {"title": "Interval propagation to reason about sets: Definition and implementation of a practical language", "author": ["C. Gervet"], "venue": "Constraints, 1(3):191\u2013244,", "citeRegEx": "59", "shortCiteRegEx": null, "year": 1997}, {"title": "Constraints over structured domains", "author": ["C. Gervet"], "venue": "Handbook of Constraint Programming, chapter 17, pages 603\u2013636. Elsevier,", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2006}, {"title": "Length-lex ordering for set CSPs", "author": ["C. Gervet", "P. Van Hentenryck"], "venue": "Proceedings of AAAI\u201906, pages 48\u201353,", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2006}, {"title": "Increasing tree search efficiency for constraint satisfaction problems", "author": ["R.M. Haralick", "G.L. Elliott"], "venue": "Artificial Intelligence, 14:263\u2013313,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 1980}, {"title": "Generality versus specificity: An experience with AI and OR techniques", "author": ["P. Van Hentenryck", "J.-P. Carillon"], "venue": "Proceedings of AAAI\u201988, pages 660\u2013664,", "citeRegEx": "63", "shortCiteRegEx": null, "year": 1988}, {"title": "Global constraints for round robin tournament scheduling", "author": ["M. Henz", "T. Mller", "S. Thiel"], "venue": "European Journal of Operational Research, 153(1):92\u2013101,", "citeRegEx": "64", "shortCiteRegEx": null, "year": 2004}, {"title": "Integrated Methods for Optimization", "author": ["J.N. Hooker"], "venue": "Springer,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 2012}, {"title": "Efficient context-free grammar constraints", "author": ["S. Kadioglu", "M. Sellmann"], "venue": "Proceedings of AAAI\u201908, pages 310\u2013316,", "citeRegEx": "66", "shortCiteRegEx": null, "year": 2008}, {"title": "Grammar constraints", "author": ["S. Kadioglu", "M. Sellmann"], "venue": "Constraints, 15(1):117\u2013144,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2010}, {"title": "The seqbin constraint revisited", "author": ["G. Katsirelos", "N. Narodytska", "T. Walsh"], "venue": "Proceedings of ICP\u201912, pages 332\u2013347,", "citeRegEx": "68", "shortCiteRegEx": null, "year": 2012}, {"title": "A compression algorithm for large arity extensional constraints", "author": ["G. Katsirelos", "T. Walsh"], "venue": "Proceedings of CP\u201907, pages 379\u2013393,", "citeRegEx": "69", "shortCiteRegEx": null, "year": 2007}, {"title": "Temporal CSPs", "author": ["M. Koubarakis"], "venue": "Handbook of Constraint Programming, chapter 19, pages 663\u2013695. Elsevier,", "citeRegEx": "70", "shortCiteRegEx": null, "year": 2006}, {"title": "Node and arc consistency in weighted CSP", "author": ["J. Larrosa"], "venue": "Proceedings of AAAI\u201902, pages 48\u201353,", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2002}, {"title": "In the quest of the best form of local consistency for Weighted CSP", "author": ["J. Larrosa", "T. Schiex"], "venue": "Proceedings of IJCAI\u201903, pages 363\u2013376,", "citeRegEx": "72", "shortCiteRegEx": null, "year": 2003}, {"title": "Solving weighted CSP by maintaining arc consistency", "author": ["J. Larrosa", "T. Schiex"], "venue": "Artificial Intelligence, 159(1-2):1\u201326,", "citeRegEx": "73", "shortCiteRegEx": null, "year": 2004}, {"title": "Global constraints for integer and set value precedence", "author": ["Y.C. Law", "J. Lee"], "venue": "Proceedings of CP\u201904, pages 362\u2013376,", "citeRegEx": "74", "shortCiteRegEx": null, "year": 2004}, {"title": "STR2: Optimized simple tabular reduction for table constraints", "author": ["C. Lecoutre"], "venue": "Constraints, 16(4):341\u2013371,", "citeRegEx": "75", "shortCiteRegEx": null, "year": 2011}, {"title": "A study of residual supports in arc consistency", "author": ["C. Lecoutre", "F. Hemery"], "venue": "Proceedings of IJCAI\u201907, pages 125\u2013130,", "citeRegEx": "76", "shortCiteRegEx": null, "year": 2007}, {"title": "A path-optimal GAC algorithm for table constraints", "author": ["C. Lecoutre", "C. Likitvivatanavong", "R. Yap"], "venue": "Proceedings of ECAI\u201912, pages 510\u2013515,", "citeRegEx": "77", "shortCiteRegEx": null, "year": 2012}, {"title": "Reasonning from last conflict(s) in constraint programming", "author": ["C. Lecoutre", "L. Sais", "S. Tabary", "V. Vidal"], "venue": "Artificial Intelligence, 173(18):1592\u20131614,", "citeRegEx": "78", "shortCiteRegEx": null, "year": 2009}, {"title": "Generalized arc consistency for positive table constraints", "author": ["C. Lecoutre", "R. Szymanek"], "venue": "Proceedings of CP\u201906, pages 284\u2013298,", "citeRegEx": "79", "shortCiteRegEx": null, "year": 2006}, {"title": "Enforcing arc consistency using bitwise operations", "author": ["C. Lecoutre", "J. Vion"], "venue": "Constraint Programming Letters, 2:21\u201335,", "citeRegEx": "80", "shortCiteRegEx": null, "year": 2008}, {"title": "Arc-consistency filtering algorithms for logical combinations of constraints", "author": ["O. Lhomme"], "venue": "Proceedings of CPAIOR\u201904, pages 209\u2013224,", "citeRegEx": "81", "shortCiteRegEx": null, "year": 2004}, {"title": "Practical reformulations with table constraints", "author": ["O. Lhomme"], "venue": "Proceedings of ECAI\u201912, pages 911\u2013912,", "citeRegEx": "82", "shortCiteRegEx": null, "year": 2012}, {"title": "A fast arc consistency algorithm for n-ary constraints", "author": ["O. Lhomme", "J.-C. R\u00e9gin"], "venue": "Proceedings of AAAI\u201905, pages 405\u2013410,", "citeRegEx": "83", "shortCiteRegEx": null, "year": 2005}, {"title": "What is a qualitative calculus? a general framework", "author": ["G. Ligozat", "J. Renz"], "venue": "Proceedings of PRICAI\u201904, pages 53\u201364,", "citeRegEx": "84", "shortCiteRegEx": null, "year": 2004}, {"title": "Consistency in networks of relations", "author": ["A.K. Mackworth"], "venue": "Artificial Intelligence, 8(1):99\u2013 118,", "citeRegEx": "85", "shortCiteRegEx": null, "year": 1977}, {"title": "An optimal filtering algorithm for table constraints", "author": ["J.-B. Mairy", "P. van Hentenryck", "Y. Deville"], "venue": "In Proceedings of CP\u201912,", "citeRegEx": "86", "shortCiteRegEx": "86", "year": 2012}, {"title": "Filtering bounded knapsack constraints in expected sublinear time", "author": ["Y. Malitsky", "M. Sellmann", "R. Szymanek"], "venue": "Proceedings of AAAI\u201910, pages 141\u2013146,", "citeRegEx": "87", "shortCiteRegEx": null, "year": 2010}, {"title": "Sequencing and counting with the multicost-regular constraint", "author": ["J. Menana", "S. Demassey"], "venue": "Proceedings of CPAIOR\u201909, pages 178\u2013192,", "citeRegEx": "88", "shortCiteRegEx": null, "year": 2009}, {"title": "Soft constraints", "author": ["P. Meseguer", "F. Rossi", "T. Schiex"], "venue": "Handbook of Constraint Programming, chapter 9, pages 281\u2013328. Elsevier,", "citeRegEx": "89", "shortCiteRegEx": null, "year": 2006}, {"title": "Activity-based search for black-box constraint programming solvers", "author": ["L. Michel", "P. Van Hentenryck"], "venue": "Proceedings of CPAIOR\u201912, pages 228\u2013243,", "citeRegEx": "90", "shortCiteRegEx": null, "year": 2012}, {"title": "Minimizing conflicts: a heuristic repair method for constraint-satisfaction and scheduling problems", "author": ["S. Minton", "M.D. Johnston", "A.B. Philips", "P. Laird"], "venue": "Artificial Intelligence, 58(1-3):161\u2013205,", "citeRegEx": "91", "shortCiteRegEx": null, "year": 1992}, {"title": "Arc and path consistency revisited", "author": ["R. Mohr", "T.C. Henderson"], "venue": "Artificial Intelligence, 28:225\u2013233,", "citeRegEx": "92", "shortCiteRegEx": null, "year": 1986}, {"title": "Short and long supports for constraint propagation", "author": ["P. Nightingale", "I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "Journal of Artificial Intelligence Research, 46:1\u201345,", "citeRegEx": "93", "shortCiteRegEx": null, "year": 2013}, {"title": "Improving GAC-4 for Table and MDD constraints", "author": ["G. Perez", "J.-C. R\u00e9gin"], "venue": "Proceedings of CP\u201914, pages 606\u2013621,", "citeRegEx": "94", "shortCiteRegEx": null, "year": 2014}, {"title": "A filtering algorithm for the stretch constraint", "author": ["G. Pesant"], "venue": "Proceedings of CP\u201901, pages 183\u2013195,", "citeRegEx": "95", "shortCiteRegEx": null, "year": 2001}, {"title": "A regular language membership constraint for finite sequences of variables", "author": ["G. Pesant"], "venue": "Proceedings of CP\u201904, pages 482\u2013495,", "citeRegEx": "96", "shortCiteRegEx": null, "year": 2004}, {"title": "Counting solutions of knapsack constraints", "author": ["G. Pesant", "C.-G. Quimper"], "venue": "Proceedings of CPAIOR\u201908, pages 203\u2013217,", "citeRegEx": "97", "shortCiteRegEx": null, "year": 2008}, {"title": "SPREAD: A balancing constraint based on statistics", "author": ["G. Pesant", "J.-C. R\u00e9gin"], "venue": "Proceedings of CP\u201905, pages 460\u2013474,", "citeRegEx": "98", "shortCiteRegEx": null, "year": 2005}, {"title": "A generalized arc-consistency algorithm for a class of counting constraint", "author": ["T. Petit", "N. Beldiceanu", "X. Lorca"], "venue": "Proceedings of IJCAI\u201911, pages 643\u2013648,", "citeRegEx": "99", "shortCiteRegEx": null, "year": 2011}, {"title": "Meta-constraints on violations for over constrained problems", "author": ["T. Petit", "J.-C. R\u00e9gin", "C. Bessiere"], "venue": "Proceedings of ICTAI\u201900, pages 358\u2013365,", "citeRegEx": "100", "shortCiteRegEx": null, "year": 2000}, {"title": "Specific filtering algorithms for over-constrained problems", "author": ["T. Petit", "J.-C. R\u00e9gin", "C. Bessiere"], "venue": "Proceedings of CP\u201901, pages 451\u2013463,", "citeRegEx": "101", "shortCiteRegEx": null, "year": 2001}, {"title": "A quadratic propagator for the interdistance constraint", "author": ["C.-G. Quimper", "A. Lopez-Ortiz", "G. Pesant"], "venue": "Proceedings of AAAI\u201906, pages 123\u2013128,", "citeRegEx": "102", "shortCiteRegEx": null, "year": 2006}, {"title": "Beyond finite domains: The all different and global cardinality constraints", "author": ["C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of CP\u201905, pages 812\u2013816,", "citeRegEx": "103", "shortCiteRegEx": null, "year": 2005}, {"title": "Decomposing global grammar constraints", "author": ["C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of CP\u201907, pages 590\u2013604,", "citeRegEx": "104", "shortCiteRegEx": null, "year": 2007}, {"title": "Decompositions of grammar constraints", "author": ["C.-G. Quimper", "T. Walsh"], "venue": "Proceedings of AAAI\u201908, pages 1567\u20131570,", "citeRegEx": "105", "shortCiteRegEx": null, "year": 2008}, {"title": "A spatial logic based on regions and connection", "author": ["D.A. Randell", "Z.Cui", "A.G. Cohn"], "venue": "In Proceedings of KR\u201992,", "citeRegEx": "106", "shortCiteRegEx": "106", "year": 1992}, {"title": "Impact-based search strategies for constraint programming", "author": ["P. Refalo"], "venue": "Proceedings of CP\u201904, pages 557\u2013571,", "citeRegEx": "107", "shortCiteRegEx": null, "year": 2004}, {"title": "A filtering algorithm for constraints of difference in CSPs", "author": ["J.-C. R\u00e9gin"], "venue": "Proceedings of AAAI\u201994, pages 362\u2013367,", "citeRegEx": "108", "shortCiteRegEx": null, "year": 1994}, {"title": "Generalized arc consistency for global cardinality constraint", "author": ["J.-C. R\u00e9gin"], "venue": "Proceedings of AAAI\u201996, pages 209\u2013215,", "citeRegEx": "109", "shortCiteRegEx": null, "year": 1996}, {"title": "The global minimum distance constraint", "author": ["J.-C. R\u00e9gin"], "venue": "Technical report, ILOG,", "citeRegEx": "110", "shortCiteRegEx": null, "year": 1997}, {"title": "The symmetric alldiff constraint", "author": ["J.-C. R\u00e9gin"], "venue": "Proceedings of IJCAI\u201999, pages 420\u2013425,", "citeRegEx": "111", "shortCiteRegEx": null, "year": 1999}, {"title": "Cost-based arc consistency for global cardinality constraints", "author": ["J.-C. R\u00e9gin"], "venue": "Constraints, 7(3-4):387\u2013405,", "citeRegEx": "112", "shortCiteRegEx": null, "year": 2002}, {"title": "Global constraints: a survey", "author": ["J.-C. R\u00e9gin"], "venue": "Hybrid Optimization, chapter 2, pages 63\u2013134. Springer,", "citeRegEx": "113", "shortCiteRegEx": null, "year": 2011}, {"title": "The cardinality matrix constraint", "author": ["J.-C. R\u00e9gin", "C.P. Gomes"], "venue": "Proceedings of CP\u201904, pages 572\u2013587,", "citeRegEx": "114", "shortCiteRegEx": null, "year": 2004}, {"title": "An original constraint based approach for solving over constrained problems", "author": ["J.-C. R\u00e9gin", "T. Petit", "C. Bessiere", "J.-F. Puget"], "venue": "Proceedings of CP\u201900, pages 543\u2013548,", "citeRegEx": "115", "shortCiteRegEx": null, "year": 2000}, {"title": "A filtering algorithm for global sequencing constraints", "author": ["J.-C. R\u00e9gin", "J.-F. Puget"], "venue": "Proceedings of CP\u201997, pages 32\u201346,", "citeRegEx": "116", "shortCiteRegEx": null, "year": 1997}, {"title": "Building models through formal specification", "author": ["G. Renker", "H. Ahriz"], "venue": "Proceedings of CPAIOR\u201904, pages 395\u2013401,", "citeRegEx": "117", "shortCiteRegEx": null, "year": 2004}, {"title": "Solving Balancing and Bin-Packing problems with Constraint Programming", "author": ["P. Schaus"], "venue": "PhD thesis, Universit\u00eb catholique de Louvain la Neuve,", "citeRegEx": "118", "shortCiteRegEx": null, "year": 2009}, {"title": "Simplification and extension of the SPREAD constraint", "author": ["P. Schaus", "Y. Deville", "P. Dupont", "J.-C. R\u00e9gin"], "venue": "Proceedings of CPAI\u201906 Workshop held with CP\u201906, pages 72\u201392,", "citeRegEx": "119", "shortCiteRegEx": null, "year": 2006}, {"title": "The Deviation constraint", "author": ["P. Schaus", "Y. Deville", "P. Dupont", "J.-C. R\u00e9gin"], "venue": "Proceedings of CPAIOR\u201907, pages 260\u2013274,", "citeRegEx": "120", "shortCiteRegEx": null, "year": 2007}, {"title": "Approximated consistency for knapsack constraints", "author": ["M. Sellmann"], "venue": "Proceedings of CP\u201903, pages 679\u2013693,", "citeRegEx": "121", "shortCiteRegEx": null, "year": 2003}, {"title": "The theory of grammar constraints", "author": ["M. Sellmann"], "venue": "Proceedings of CP\u201906, pages 530\u2013 544,", "citeRegEx": "122", "shortCiteRegEx": null, "year": 2006}, {"title": "A constraint for bin packing", "author": ["P. Shaw"], "venue": "Proceedings of CP\u201904, pages 648\u2013662,", "citeRegEx": "123", "shortCiteRegEx": null, "year": 2004}, {"title": "The brelaz heuristic and optimal static orderings", "author": ["B.M. Smith"], "venue": "Proceedings of CP\u201999, pages 405\u2013418, Alexandria, VA,", "citeRegEx": "124", "shortCiteRegEx": null, "year": 1999}, {"title": "A dynamic programming approach for consistency and propagation for knapsack constraints", "author": ["M. Trick"], "venue": "Annals OR, 118(1-4):73\u201384,", "citeRegEx": "125", "shortCiteRegEx": null, "year": 2003}, {"title": "A computer-aided constraint programming system", "author": ["E. Tsang", "P. Mills", "R. Williams", "J. Ford", "J. Borrett"], "venue": "Proceedings of PACLP\u201999, pages 81\u201393,", "citeRegEx": "126", "shortCiteRegEx": null, "year": 1999}, {"title": "An algorithm for subgraph isomorphism", "author": ["J.R. Ullmann"], "venue": "Journal of the ACM, 23(1):31\u201342,", "citeRegEx": "127", "shortCiteRegEx": null, "year": 1976}, {"title": "The OPL Optimization Programming Language", "author": ["P. van Hentenryck"], "venue": null, "citeRegEx": "128", "shortCiteRegEx": "128", "year": 1999}, {"title": "The cardinality operator: A new logical connective for constraint logic programming", "author": ["P. van Hentenryck", "Y. Deville"], "venue": "In Proceedings of ICLP\u201991,", "citeRegEx": "129", "shortCiteRegEx": "129", "year": 1991}, {"title": "On global warming: Flow-based soft global constraints", "author": ["W. van Hoeve", "G. Pesant", "L.-M. Rousseau"], "venue": "Journal of Heuristics,", "citeRegEx": "130", "shortCiteRegEx": "130", "year": 2006}, {"title": "The alldifferent constraint: a survey", "author": ["W.J. van Hoeve"], "venue": "In Proceedings of the Sixth Annual Workshop of the ERCIM Working Group on Constraints,", "citeRegEx": "131", "shortCiteRegEx": "131", "year": 2001}, {"title": "Revisiting the sequence constraint", "author": ["W.J. van Hoeve", "G. Pesant", "L.-M. Rousseau", "A. Sabharwal"], "venue": "In Proceedings of CP\u201906,", "citeRegEx": "133", "shortCiteRegEx": "133", "year": 2006}, {"title": "Stochastic constraint programming", "author": ["T. Walsh"], "venue": "Proceedings of ECAI\u201902, pages 111\u2013115,", "citeRegEx": "135", "shortCiteRegEx": null, "year": 2002}, {"title": "Symmetry breaking using value precedence", "author": ["T. Walsh"], "venue": "Proceedings of ECAI\u201906, pages 168\u2013172,", "citeRegEx": "136", "shortCiteRegEx": null, "year": 2006}, {"title": "Optimizing STR algorithms with tuple compression", "author": ["W. Xia", "R. Yap"], "venue": "Proceedings of CP\u201913, pages 724\u2013732,", "citeRegEx": "137", "shortCiteRegEx": null, "year": 2013}, {"title": "Introduction to the constraint language NCL", "author": ["J. Zhou"], "venue": "Journal of Logic Programming, 45(1-3):71\u2013103,", "citeRegEx": "138", "shortCiteRegEx": null, "year": 2000}], "referenceMentions": [{"referenceID": 127, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 4, "endOffset": 9}, {"referenceID": 125, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 16, "endOffset": 21}, {"referenceID": 135, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 27, "endOffset": 32}, {"referenceID": 50, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 39, "endOffset": 43}, {"referenceID": 40, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 50, "endOffset": 54}, {"referenceID": 52, "context": "OPL [128], EaCL [126], NCL [138], ESRA [51], Zinc [41] and ESSENCE [53].", "startOffset": 67, "endOffset": 71}, {"referenceID": 116, "context": "org) has also been used to build nice (high-level) problem models [117]", "startOffset": 66, "endOffset": 71}, {"referenceID": 3, "context": "Example 13 <var id=\"w\" type=\"real\"> [0,+ infinity[ </var > <var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [2/3 ,8.", "startOffset": 84, "endOffset": 90}, {"referenceID": 9, "context": "For example, [0,10] [8,20] is forbidden as content of any element <var>.", "startOffset": 13, "endOffset": 19}, {"referenceID": 7, "context": "For example, [0,10] [8,20] is forbidden as content of any element <var>.", "startOffset": 20, "endOffset": 26}, {"referenceID": 19, "context": "For example, [0,10] [8,20] is forbidden as content of any element <var>.", "startOffset": 20, "endOffset": 26}, {"referenceID": 58, "context": "It is usual that a set domain is approximated by a set interval specified by its upper and lower bounds (subset-bound representation), defined by some appropriate ordering on the domain values [59, 60].", "startOffset": 193, "endOffset": 201}, {"referenceID": 59, "context": "It is usual that a set domain is approximated by a set interval specified by its upper and lower bounds (subset-bound representation), defined by some appropriate ordering on the domain values [59, 60].", "startOffset": 193, "endOffset": 201}, {"referenceID": 60, "context": "1There exist alternatives to represent domains, as the length-lex representation [61].", "startOffset": 81, "endOffset": 85}, {"referenceID": 43, "context": "More precisely, graph variables have domains that are approximated by the lattice of graphs included between two bounds: the greatest lower bound and the least upper bound of the lattice [44].", "startOffset": 187, "endOffset": 191}, {"referenceID": 132, "context": "Walsh [135] to capture combinatorial decision problems involving uncertainty.", "startOffset": 6, "endOffset": 11}, {"referenceID": 69, "context": "In qualitative spatial and temporal reasoning (QSTR) [70], one has to reason with entities that corresponds to points, intervals, regions, .", "startOffset": 53, "endOffset": 57}, {"referenceID": 9, "context": "For example, if x is an array of 10 variables, you just write \"[10]\", and if y is a 2-dimensional array, 5 rows by 8 columns, you write \"[5][8]\".", "startOffset": 63, "endOffset": 67}, {"referenceID": 4, "context": "For example, if x is an array of 10 variables, you just write \"[10]\", and if y is a 2-dimensional array, 5 rows by 8 columns, you write \"[5][8]\".", "startOffset": 137, "endOffset": 140}, {"referenceID": 7, "context": "For example, if x is an array of 10 variables, you just write \"[10]\", and if y is a 2-dimensional array, 5 rows by 8 columns, you write \"[5][8]\".", "startOffset": 140, "endOffset": 143}, {"referenceID": 9, "context": "Example 19 <array id=\"x\" size=\"[10]\"> 1.", "startOffset": 31, "endOffset": 35}, {"referenceID": 4, "context": "100 </array > <array id=\"y\" size=\"[5][8]\"> 0 1 </array > <array id=\"diceYathzee\" size=\"[5]\" type=\"stochastic\"> 1.", "startOffset": 34, "endOffset": 37}, {"referenceID": 7, "context": "100 </array > <array id=\"y\" size=\"[5][8]\"> 0 1 </array > <array id=\"diceYathzee\" size=\"[5]\" type=\"stochastic\"> 1.", "startOffset": 37, "endOffset": 40}, {"referenceID": 4, "context": "100 </array > <array id=\"y\" size=\"[5][8]\"> 0 1 </array > <array id=\"diceYathzee\" size=\"[5]\" type=\"stochastic\"> 1.", "startOffset": 87, "endOffset": 90}, {"referenceID": 11, "context": "6:1/6 </array > <array id=\"z\" size=\"[12]\" type=\"symbolic set\"> <required > a b </required > <possible > c d </possible > </array >", "startOffset": 36, "endOffset": 40}, {"referenceID": 3, "context": "For example, assuming that 0 is the \u201cstarting index\u201d, x[0] is the first variable of the array x, and y[4][7] the last variable of the array y.", "startOffset": 102, "endOffset": 105}, {"referenceID": 6, "context": "For example, assuming that 0 is the \u201cstarting index\u201d, x[0] is the first variable of the array x, and y[4][7] the last variable of the array y.", "startOffset": 105, "endOffset": 108}, {"referenceID": 1, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 233, "endOffset": 236}, {"referenceID": 3, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 236, "endOffset": 239}, {"referenceID": 1, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 251, "endOffset": 254}, {"referenceID": 4, "context": "In a context where a list of variables is expected, it is possible to use this kind of notation, and the result is then considered to be a list of variables, ordered according to a lexicographic order \u227a on index tuples (for example y[2][4] is before y[2][5] since (2, 4) \u227a (2, 5)).", "startOffset": 254, "endOffset": 257}, {"referenceID": 2, "context": "5] denotes the list of variables x[3], x[4] and x[5], while y[2.", "startOffset": 34, "endOffset": 37}, {"referenceID": 3, "context": "5] denotes the list of variables x[3], x[4] and x[5], while y[2.", "startOffset": 40, "endOffset": 43}, {"referenceID": 4, "context": "5] denotes the list of variables x[3], x[4] and x[5], while y[2.", "startOffset": 49, "endOffset": 52}, {"referenceID": 1, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 34, "endOffset": 37}, {"referenceID": 1, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 43, "endOffset": 46}, {"referenceID": 0, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 46, "endOffset": 49}, {"referenceID": 2, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 52, "endOffset": 55}, {"referenceID": 2, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 64, "endOffset": 67}, {"referenceID": 0, "context": "1] denotes the list of variables y[2][0], y[2][1], y[3][0] and y[3][1].", "startOffset": 67, "endOffset": 70}, {"referenceID": 1, "context": "For example, y[2][] is equivalent to y[2][0.", "startOffset": 14, "endOffset": 17}, {"referenceID": 1, "context": "For example, y[2][] is equivalent to y[2][0.", "startOffset": 38, "endOffset": 41}, {"referenceID": 0, "context": "<matrix > (y[0][0] ,y[0][1] ,.", "startOffset": 24, "endOffset": 27}, {"referenceID": 6, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 12, "endOffset": 15}, {"referenceID": 0, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 21, "endOffset": 24}, {"referenceID": 0, "context": ",y[0][7]) (y[1][0] ,y[1][1] ,.", "startOffset": 24, "endOffset": 27}, {"referenceID": 0, "context": ",y[1][7]) .", "startOffset": 2, "endOffset": 5}, {"referenceID": 6, "context": ",y[1][7]) .", "startOffset": 5, "endOffset": 8}, {"referenceID": 3, "context": "(y[4][0] ,y[4][1] ,.", "startOffset": 2, "endOffset": 5}, {"referenceID": 3, "context": "(y[4][0] ,y[4][1] ,.", "startOffset": 11, "endOffset": 14}, {"referenceID": 0, "context": "(y[4][0] ,y[4][1] ,.", "startOffset": 14, "endOffset": 17}, {"referenceID": 3, "context": ",y[4][7]) </matrix >", "startOffset": 2, "endOffset": 5}, {"referenceID": 6, "context": ",y[4][7]) </matrix >", "startOffset": 5, "endOffset": 8}, {"referenceID": 1, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 9, "endOffset": 12}, {"referenceID": 1, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 17, "endOffset": 20}, {"referenceID": 0, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 20, "endOffset": 23}, {"referenceID": 2, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 25, "endOffset": 28}, {"referenceID": 2, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 33, "endOffset": 36}, {"referenceID": 0, "context": "<list > y[2][0] y[2][1] y[3][0] y[3][1] </list >", "startOffset": 36, "endOffset": 39}, {"referenceID": 3, "context": "of array y have {2, 4, 6} as domain except for y[4] whose domain is {0, 1}.", "startOffset": 48, "endOffset": 51}, {"referenceID": 1, "context": "1][] and z[][2][2.", "startOffset": 12, "endOffset": 15}, {"referenceID": 2, "context": "Example 20 <array id=\"x\" size=\"[3][5]\"> <domain for=\"x[0][]\"> 1.", "startOffset": 31, "endOffset": 34}, {"referenceID": 4, "context": "Example 20 <array id=\"x\" size=\"[3][5]\"> <domain for=\"x[0][]\"> 1.", "startOffset": 34, "endOffset": 37}, {"referenceID": 0, "context": "10 </domain > <domain for=\"x[1][]\"> 1.", "startOffset": 28, "endOffset": 31}, {"referenceID": 1, "context": "20 </domain > <domain for=\"x[2][]\"> 1.", "startOffset": 28, "endOffset": 31}, {"referenceID": 9, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 44, "endOffset": 48}, {"referenceID": 3, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 65, "endOffset": 68}, {"referenceID": 4, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 155, "endOffset": 158}, {"referenceID": 4, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 158, "endOffset": 161}, {"referenceID": 4, "context": "15 </domain > </array > <array id=\"y\" size=\"[10]\"> <domain for=\"y[4]\"> 0 1 </domain > <domain for=\"others\"> 2 4 6 </domain > </array > <array id=\"z\" size=\"[5][5][5]\"> <domain for=\"z[][0.", "startOffset": 161, "endOffset": 164}, {"referenceID": 1, "context": "1][] z[][2][2.", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "As an illustration, below, the variable z[5] is undefined.", "startOffset": 41, "endOffset": 44}, {"referenceID": 9, "context": "Example 22 <array id=\"z\" size=\"[10]\"> <domain for=\"z[0.", "startOffset": 31, "endOffset": 35}, {"referenceID": 7, "context": "Example 23 <array id=\"t\" size=\"[8][8]\"> 1.", "startOffset": 31, "endOffset": 34}, {"referenceID": 7, "context": "Example 23 <array id=\"t\" size=\"[8][8]\"> 1.", "startOffset": 34, "endOffset": 37}, {"referenceID": 2, "context": "The following instance involves an array of 4 variables, but one of them, x[3], is useless.", "startOffset": 75, "endOffset": 78}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <intension > eq(add(x[0],x[1]),x[2]) </intension > </constraints > </instance >", "startOffset": 67, "endOffset": 70}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <intension > eq(add(x[0],x[1]),x[2]) </intension > </constraints > </instance >", "startOffset": 73, "endOffset": 76}, {"referenceID": 0, "context": "To represent the solution x[0] = 1, x[1] = 1, x[2] = 2, one can choose between the three following representations:", "startOffset": 37, "endOffset": 40}, {"referenceID": 1, "context": "To represent the solution x[0] = 1, x[1] = 1, x[2] = 2, one can choose between the three following representations:", "startOffset": 47, "endOffset": 50}, {"referenceID": 0, "context": "Example 26 <instantiation type=\"solution\"> <list > x[0] x[1] x[2] </list > <values > 1 1 2 </values > </instantiation >", "startOffset": 57, "endOffset": 60}, {"referenceID": 1, "context": "Example 26 <instantiation type=\"solution\"> <list > x[0] x[1] x[2] </list > <values > 1 1 2 </values > </instantiation >", "startOffset": 62, "endOffset": 65}, {"referenceID": 2, "context": "For the last representation, we could have chosen the value 2 or the value 3 for the last variable x[3].", "startOffset": 100, "endOffset": 103}, {"referenceID": 112, "context": "Note that many global constraints have been introduced in CP; see [132, 113, 6].", "startOffset": 66, "endOffset": 79}, {"referenceID": 5, "context": "Note that many global constraints have been introduced in CP; see [132, 113, 6].", "startOffset": 66, "endOffset": 79}, {"referenceID": 84, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 59, "endOffset": 63}, {"referenceID": 91, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 69, "endOffset": 73}, {"referenceID": 14, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 79, "endOffset": 83}, {"referenceID": 22, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 92, "endOffset": 96}, {"referenceID": 75, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 102, "endOffset": 106}, {"referenceID": 79, "context": "Some algorithms for binary extensional constraints are AC3 [85], AC4 [92], AC6 [15], AC2001 [23], AC3 [76] and AC3 [80].", "startOffset": 115, "endOffset": 119}, {"referenceID": 21, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 70, "endOffset": 74}, {"referenceID": 82, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 87, "endOffset": 91}, {"referenceID": 56, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 106, "endOffset": 110}, {"referenceID": 78, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 119, "endOffset": 123}, {"referenceID": 74, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 130, "endOffset": 134}, {"referenceID": 85, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 145, "endOffset": 149}, {"referenceID": 76, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 156, "endOffset": 160}, {"referenceID": 93, "context": "Some algorithms for non-binary extensional constraints are GAC-schema [22], GAC-nextIn [83], GAC-nextDiff [57], GAC-va [79], STR2 [75], AC5TC-Tr [86], STR3 [77] and GAC4r [94].", "startOffset": 171, "endOffset": 175}, {"referenceID": 92, "context": "On the one hand, it may be particularly useful to integrate shortened tuples (based on short supports) [93] in tables.", "startOffset": 103, "endOffset": 107}, {"referenceID": 68, "context": "On the other hand, to reduce space complexity, one may also seek to integrate compressed tuples [69, 137] in tables.", "startOffset": 96, "endOffset": 105}, {"referenceID": 134, "context": "On the other hand, to reduce space complexity, one may also seek to integrate compressed tuples [69, 137] in tables.", "startOffset": 96, "endOffset": 105}, {"referenceID": 32, "context": "1 Constraint regular The constraint regular [33, 96] ensures that the sequence of values assigned to the variables it involves forms a word that can be recognized by a deterministic (or non-deterministic) finite automaton.", "startOffset": 44, "endOffset": 52}, {"referenceID": 95, "context": "1 Constraint regular The constraint regular [33, 96] ensures that the sequence of values assigned to the variables it involves forms a word that can be recognized by a deterministic (or non-deterministic) finite automaton.", "startOffset": 44, "endOffset": 52}, {"referenceID": 121, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 103, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 65, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 104, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 66, "context": "The constraint grammar [122, 104, 66, 105, 67] ensures that the sequence of values assigned to the variables it involves belongs to the language defined by a formal grammar.", "startOffset": 23, "endOffset": 46}, {"referenceID": 34, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 35, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 36, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 93, "context": "The constraint mdd [35, 36, 37, 94] ensures that the sequence of values assigned to the variables it involves follows a path going from the root of the described MDD (Multi-valued Decision Diagram) to the unique terminal node.", "startOffset": 19, "endOffset": 35}, {"referenceID": 107, "context": "1 Constraint allDifferent The constraint allDifferent, see [108, 131, 58], ensures that the variables in <list> must all take different values.", "startOffset": 59, "endOffset": 73}, {"referenceID": 130, "context": "1 Constraint allDifferent The constraint allDifferent, see [108, 131, 58], ensures that the variables in <list> must all take different values.", "startOffset": 59, "endOffset": 73}, {"referenceID": 57, "context": "1 Constraint allDifferent The constraint allDifferent, see [108, 131, 58], ensures that the variables in <list> must all take different values.", "startOffset": 59, "endOffset": 73}, {"referenceID": 5, "context": "A variant, called allDifferentExcept in the literature [6, 40], enforces variables to take distinct values, except those that are assigned to some specified values (often, the single value 0).", "startOffset": 55, "endOffset": 62}, {"referenceID": 39, "context": "A variant, called allDifferentExcept in the literature [6, 40], enforces variables to take distinct values, except those that are assigned to some specified values (often, the single value 0).", "startOffset": 55, "endOffset": 62}, {"referenceID": 109, "context": "In [110, 102], this constraint is studied with respect to the operator \u2265, and called interDistance.", "startOffset": 3, "endOffset": 13}, {"referenceID": 101, "context": "In [110, 102], this constraint is studied with respect to the operator \u2265, and called interDistance.", "startOffset": 3, "endOffset": 13}, {"referenceID": 124, "context": "A form of sum, sometimes called subset-sum or knapsack [125, 97] involves the operator \u201cin\u201d, and ensures that the obtained sum belongs (or not) to a specified interval.", "startOffset": 55, "endOffset": 64}, {"referenceID": 96, "context": "A form of sum, sometimes called subset-sum or knapsack [125, 97] involves the operator \u201cin\u201d, and ensures that the obtained sum belongs (or not) to a specified interval.", "startOffset": 55, "endOffset": 64}, {"referenceID": 7, "context": "2 Constraint count The constraint count, introduced in CHIP [8] and Sicstus [34], ensures that the number of variables in <list> which are assigned a value in <values> respects a numerical condition.", "startOffset": 60, "endOffset": 63}, {"referenceID": 33, "context": "2 Constraint count The constraint count, introduced in CHIP [8] and Sicstus [34], ensures that the number of variables in <list> which are assigned a value in <values> respects a numerical condition.", "startOffset": 76, "endOffset": 80}, {"referenceID": 16, "context": "The constraint nValues [17], ensures that the number of distinct values taken by variables in <list> respects a numerical condition.", "startOffset": 23, "endOffset": 27}, {"referenceID": 16, "context": "A variant, called nValuesExcept [17] discards some specified values (often, the single value 0).", "startOffset": 32, "endOffset": 36}, {"referenceID": 108, "context": "The constraint cardinality, also called globalCardinality or gcc, see [109, 65], ensures that the number of occurrences of each value in <values>, taken by variables of <list>, is related to a corresponding element (value, variable or interval) in <occurs>.", "startOffset": 70, "endOffset": 79}, {"referenceID": 64, "context": "The constraint cardinality, also called globalCardinality or gcc, see [109, 65], ensures that the number of occurrences of each value in <values>, taken by variables of <list>, is related to a corresponding element (value, variable or interval) in <occurs>.", "startOffset": 70, "endOffset": 79}, {"referenceID": 111, "context": "The constraint cardinalityWithCosts [112] will be discussed in Section 8.", "startOffset": 36, "endOffset": 41}, {"referenceID": 5, "context": "5 Constraint balance The constraint balance [6, 21] ensures that the difference between the maximum number of occurrences and the minimum number of occurrences among the values assigned to the variables", "startOffset": 44, "endOffset": 51}, {"referenceID": 20, "context": "5 Constraint balance The constraint balance [6, 21] ensures that the difference between the maximum number of occurrences and the minimum number of occurrences among the values assigned to the variables", "startOffset": 44, "endOffset": 51}, {"referenceID": 20, "context": "If the optional element <values> is present, then all variables must be assigned to a value from this set; see balance\u2217 in [21].", "startOffset": 123, "endOffset": 127}, {"referenceID": 97, "context": "6 Constraint spread The constraint spread [98, 119, 118] ensures that the variance of values taken by variables of <list> respects a numerical condition.", "startOffset": 42, "endOffset": 56}, {"referenceID": 118, "context": "6 Constraint spread The constraint spread [98, 119, 118] ensures that the variance of values taken by variables of <list> respects a numerical condition.", "startOffset": 42, "endOffset": 56}, {"referenceID": 117, "context": "6 Constraint spread The constraint spread [98, 119, 118] ensures that the variance of values taken by variables of <list> respects a numerical condition.", "startOffset": 42, "endOffset": 56}, {"referenceID": 119, "context": "The constraint deviation [120, 118] ensures that the deviation of values taken by variables of <list> respects a numerical condition.", "startOffset": 25, "endOffset": 35}, {"referenceID": 117, "context": "The constraint deviation [120, 118] ensures that the deviation of values taken by variables of <list> respects a numerical condition.", "startOffset": 25, "endOffset": 35}, {"referenceID": 6, "context": "Finally, by replacing the element <list> by an element <set>, we can represent the constraint sum of weights of distinct values [7], where any cost is defined per value and can be taken into account only once.", "startOffset": 128, "endOffset": 131}, {"referenceID": 62, "context": "3 Constraint element The constraint element [63] ensures that <value> is element of <list>, i.", "startOffset": 44, "endOffset": 48}, {"referenceID": 73, "context": "6 Constraint precedence The constraint precedence, see [74, 136], ensures that if a variable x of <list> is assigned the i+ 1th value of <values>, then another variable of <list>, that precedes x, is assigned the ith value of <values> The optional attribute covered indicates whether each value of <values> must be assigned by at least one variable in <list> (\"false\", by default).", "startOffset": 55, "endOffset": 64}, {"referenceID": 133, "context": "6 Constraint precedence The constraint precedence, see [74, 136], ensures that if a variable x of <list> is assigned the i+ 1th value of <values>, then another variable of <list>, that precedes x, is assigned the ith value of <values> The optional attribute covered indicates whether each value of <values> must be assigned by at least one variable in <list> (\"false\", by default).", "startOffset": 55, "endOffset": 64}, {"referenceID": 94, "context": "1 Constraint stretch The constraint stretch [95] aims at grouping values in sequences.", "startOffset": 44, "endOffset": 48}, {"referenceID": 64, "context": "2 Constraint noOverlap We start with the one dimensional form of noOverlap [65] that corresponds to disjunctive [30] and ensures that some tasks, defined by their origins and durations (lengths), must not overlap.", "startOffset": 75, "endOffset": 79}, {"referenceID": 29, "context": "2 Constraint noOverlap We start with the one dimensional form of noOverlap [65] that corresponds to disjunctive [30] and ensures that some tasks, defined by their origins and durations (lengths), must not overlap.", "startOffset": 112, "endOffset": 116}, {"referenceID": 7, "context": "The k-dimensional form of noOverlap corresponds to diffn [8] and ensures that, given a set of n-dimensional boxes; for any pair of such boxes, there exists at least one dimension where one box is after the other, i.", "startOffset": 57, "endOffset": 60}, {"referenceID": 0, "context": "The constraint cumulative [1] enforces that at each point in time, the cumulated height of tasks that overlap that point, respects a numerical condition.", "startOffset": 26, "endOffset": 29}, {"referenceID": 4, "context": "A refined form of cumulative corresponds to the constraint sometimes called cumulatives [5].", "startOffset": 88, "endOffset": 91}, {"referenceID": 122, "context": "The constraint binPacking [123, 118, 29] ensures that a list of items, whose sizes are given, are put in different bins in such a way that the total size of the items in each bin respects a numerical condition (always the same, because the capacity is assumed to be the same for all bins).", "startOffset": 26, "endOffset": 40}, {"referenceID": 117, "context": "The constraint binPacking [123, 118, 29] ensures that a list of items, whose sizes are given, are put in different bins in such a way that the total size of the items in each bin respects a numerical condition (always the same, because the capacity is assumed to be the same for all bins).", "startOffset": 26, "endOffset": 40}, {"referenceID": 28, "context": "The constraint binPacking [123, 118, 29] ensures that a list of items, whose sizes are given, are put in different bins in such a way that the total size of the items in each bin respects a numerical condition (always the same, because the capacity is assumed to be the same for all bins).", "startOffset": 26, "endOffset": 40}, {"referenceID": 46, "context": "5 Constraint knapsack The constraint knapsack [47, 121, 87] ensures that some items are packed in a knapsack with certain weight and profit restrictions.", "startOffset": 46, "endOffset": 59}, {"referenceID": 120, "context": "5 Constraint knapsack The constraint knapsack [47, 121, 87] ensures that some items are packed in a knapsack with certain weight and profit restrictions.", "startOffset": 46, "endOffset": 59}, {"referenceID": 86, "context": "5 Constraint knapsack The constraint knapsack [47, 121, 87] ensures that some items are packed in a knapsack with certain weight and profit restrictions.", "startOffset": 46, "endOffset": 59}, {"referenceID": 7, "context": "1 Constraint circuit The constraint circuit [8] ensures that the values taken by the variables in <list> forms a circuit, with the assumption that each pair (i,xi) represents an arc.", "startOffset": 44, "endOffset": 47}, {"referenceID": 8, "context": "5 Constraint tree The constraint tree [9, 46] ensures that the values taken by variables in <list> forms an antiarborescence (covering all nodes) whose root is specified by <root>, with the assumption that each pair (i,xi) represents an arc (with such representation, we do obtain an anti-arborescence).", "startOffset": 38, "endOffset": 45}, {"referenceID": 45, "context": "5 Constraint tree The constraint tree [9, 46] ensures that the values taken by variables in <list> forms an antiarborescence (covering all nodes) whose root is specified by <root>, with the assumption that each pair (i,xi) represents an arc (with such representation, we do obtain an anti-arborescence).", "startOffset": 38, "endOffset": 45}, {"referenceID": 0, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 170, "endOffset": 173}, {"referenceID": 1, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 180, "endOffset": 183}, {"referenceID": 2, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 190, "endOffset": 193}, {"referenceID": 3, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 200, "endOffset": 203}, {"referenceID": 4, "context": "In our example below, we have a first constraint that enforces x = 12, y = 4 and z = 30, and a second constraint involving an array w of 6 variables such that w[0] = 1, w[1] = 0, w[2] = 2, w[3] = 1, w[4] = 3, w[5] = 1.", "startOffset": 210, "endOffset": 213}, {"referenceID": 15, "context": "3 Constraint range The constraint range [16, 18] holds iff the set of values taken by variables of <list> at indices given by <index> is exactly the set <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 17, "context": "3 Constraint range The constraint range [16, 18] holds iff the set of values taken by variables of <list> at indices given by <index> is exactly the set <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 15, "context": "In the following example, the constraints c1 and c2, taken together, permit to represent nValues({x0, x1, x2, x3, x4, x5}, y); see [16].", "startOffset": 131, "endOffset": 135}, {"referenceID": 15, "context": "4 Constraint roots The constraint roots [16, 19] holds iff <index> represents exactly the set of indices of variables in <list> which are assigned a value in <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 18, "context": "4 Constraint roots The constraint roots [16, 19] holds iff <index> represents exactly the set of indices of variables in <list> which are assigned a value in <image>.", "startOffset": 40, "endOffset": 48}, {"referenceID": 15, "context": "In the following example, the constraints c1 and c2, taken together, permit to represent among(2,{x0, x1, x2, x3, x4, x5}, {0, 1}); see [16].", "startOffset": 136, "endOffset": 140}, {"referenceID": 44, "context": "7 Constraint nCliques The constraint nCliques, called nclique in [45], ensures that the value taken by the graph variable in <graph> represents a set of cliques whose cardinality must respect a numerical condition.", "startOffset": 65, "endOffset": 69}, {"referenceID": 1, "context": "Interval Algebra, also called Allen\u2019s calculus [2] handles temporal entities that represent intervals on the rational line.", "startOffset": 47, "endOffset": 50}, {"referenceID": 105, "context": "3 Constraint rcc8 RCC8 [106] is a region connection calculus for reasoning about regions in Euclidean space.", "startOffset": 23, "endOffset": 28}, {"referenceID": 41, "context": "4 Constraint dbd For Temporal Constraint Satisfaction [42], variables represent time points and temporal information is represented by a set of unary and binary constraints, each specifying a set of permitted intervals.", "startOffset": 54, "endOffset": 58}, {"referenceID": 69, "context": "For this framework, we only need to introduce a type of constraints, called dbd constraints, for disjunctive binary difference constraints (as in [70]).", "startOffset": 146, "endOffset": 150}, {"referenceID": 29, "context": "In the following example, the constraint expresses that either x2\u2212 x1 must be in [30, 40] or in [60,+infinity[.", "startOffset": 81, "endOffset": 89}, {"referenceID": 39, "context": "In the following example, the constraint expresses that either x2\u2212 x1 must be in [30, 40] or in [60,+infinity[.", "startOffset": 81, "endOffset": 89}, {"referenceID": 29, "context": "Example 97 <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd >", "startOffset": 56, "endOffset": 64}, {"referenceID": 39, "context": "Example 97 <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd >", "startOffset": 56, "endOffset": 64}, {"referenceID": 102, "context": "The constraint allDifferent, introduced earlier on integer variables, can be naturally extended to lists (tuples), sets and multisets [103].", "startOffset": 134, "endOffset": 139}, {"referenceID": 31, "context": "The constraint lex, see [32, 54], ensures that the tuple formed by the values assigned to the variables of the first element <list> is related to the tuple formed by the values assigned to the variables of the second element <list> with respect to the operator specified in <operator>.", "startOffset": 24, "endOffset": 32}, {"referenceID": 53, "context": "The constraint lex, see [32, 54], ensures that the tuple formed by the values assigned to the variables of the first element <list> is related to the tuple formed by the values assigned to the variables of the second element <list> with respect to the operator specified in <operator>.", "startOffset": 24, "endOffset": 32}, {"referenceID": 30, "context": "If more than two elements <list> are given, the entire sequence of tuples must be ordered; this captures then lexChain [31].", "startOffset": 119, "endOffset": 123}, {"referenceID": 15, "context": "This captures uses [16].", "startOffset": 19, "endOffset": 23}, {"referenceID": 10, "context": "This captures usedBy [11].", "startOffset": 21, "endOffset": 25}, {"referenceID": 112, "context": "1 Constraint allDifferent-matrix The constraint allDifferent-matrix, called alldiffmatrix in [113] and in JaCoP, ensures that the values taken by variables on each row and on each column of a matrix are all different.", "startOffset": 93, "endOffset": 98}, {"referenceID": 49, "context": "2 Constraint ordered-matrix (lex2) The constraint ordered-matrix, that can be called lex-matrix too, corresponds to lex2 in the literature [50].", "startOffset": 139, "endOffset": 143}, {"referenceID": 0, "context": "Xn] and = {<,\u2264,\u2265, >}, iff lex(\u3008M[1], .", "startOffset": 32, "endOffset": 35}, {"referenceID": 0, "context": ",M[n]\u3009, ) lex(\u3008M [1], .", "startOffset": 17, "endOffset": 20}, {"referenceID": 113, "context": "4 Constraint cardinality-matrix The constraint cardinality-matrix, see [114], ensures a constraint cardinality on each row and each column.", "startOffset": 71, "endOffset": 76}, {"referenceID": 110, "context": "symmetric [111] is a classical restriction of allDifferent.", "startOffset": 10, "endOffset": 15}, {"referenceID": 63, "context": "This is called oneFactor in [64].", "startOffset": 28, "endOffset": 32}, {"referenceID": 9, "context": "increasing [10] combines nValues and ordered :increasing.", "startOffset": 11, "endOffset": 15}, {"referenceID": 51, "context": "allDifferent [52], also called minimumWeightAllDifferent in the literature, is the conjunction of sumCosts and allDifferent.", "startOffset": 13, "endOffset": 17}, {"referenceID": 19, "context": "A general mechanism, or meta-constraint, that is useful to post constraints on sequences of variables is slide [20].", "startOffset": 111, "endOffset": 115}, {"referenceID": 19, "context": "The attribute offset of <list> is optional (value 1, by default); it permits, when sliding, to skip more than just one variable of the sequence, capturing slidej in [20].", "startOffset": 165, "endOffset": 169}, {"referenceID": 7, "context": "1 Constraint sequence The constraint sequence, see [8, 113], also called among seq in [4], enforces a set of count constraints over a sequence of variables.", "startOffset": 51, "endOffset": 59}, {"referenceID": 112, "context": "1 Constraint sequence The constraint sequence, see [8, 113], also called among seq in [4], enforces a set of count constraints over a sequence of variables.", "startOffset": 51, "endOffset": 59}, {"referenceID": 3, "context": "1 Constraint sequence The constraint sequence, see [8, 113], also called among seq in [4], enforces a set of count constraints over a sequence of variables.", "startOffset": 86, "endOffset": 89}, {"referenceID": 3, "context": "2 Constraint slidingSum The constraint slidingSum [4], enforces a set of sum constraints over a sequence of variables.", "startOffset": 50, "endOffset": 53}, {"referenceID": 98, "context": "The meta-constraint seqbin [99, 68] ensures that a binary constraint holds down a sequence of variables, and counts how many times another binary constraint is violated.", "startOffset": 27, "endOffset": 35}, {"referenceID": 67, "context": "The meta-constraint seqbin [99, 68] ensures that a binary constraint holds down a sequence of variables, and counts how many times another binary constraint is violated.", "startOffset": 27, "endOffset": 35}, {"referenceID": 67, "context": "Remark 35 Note that in our definition, we do not add 1 to z as proposed in [68], and implicitly defined in [99].", "startOffset": 75, "endOffset": 79}, {"referenceID": 98, "context": "Remark 35 Note that in our definition, we do not add 1 to z as proposed in [68], and implicitly defined in [99].", "startOffset": 107, "endOffset": 111}, {"referenceID": 80, "context": "Sometimes, it may be interesting to combine logically constraints [81, 82].", "startOffset": 66, "endOffset": 74}, {"referenceID": 81, "context": "Sometimes, it may be interesting to combine logically constraints [81, 82].", "startOffset": 66, "endOffset": 74}, {"referenceID": 131, "context": "1 Constraint gen-sequence A general form of sequence, with name gen-sequence, has been proposed in [133].", "startOffset": 99, "endOffset": 104}, {"referenceID": 115, "context": "The global sequencing constraint (gsc) [116] combines sequence with cardinality.", "startOffset": 39, "endOffset": 44}, {"referenceID": 111, "context": "3 Constraint cardinalityWithCosts The constraint cardinalityWithCosts [112] combines cardinality with sumCosts.", "startOffset": 70, "endOffset": 75}, {"referenceID": 42, "context": "4 Constraints costRegular and multicostRegular The constraint costRegular [43] combines regular with sumCosts.", "startOffset": 74, "endOffset": 78}, {"referenceID": 87, "context": "It is possible, by introducing several constraints sumCosts to represent multicostregular [88].", "startOffset": 90, "endOffset": 94}, {"referenceID": 114, "context": "We can deal with hard constraints that are relaxed by integrating cost variables, obtaining so-called relaxed constraints hereafter; see [115, 100, 12].", "startOffset": 137, "endOffset": 151}, {"referenceID": 99, "context": "We can deal with hard constraints that are relaxed by integrating cost variables, obtaining so-called relaxed constraints hereafter; see [115, 100, 12].", "startOffset": 137, "endOffset": 151}, {"referenceID": 11, "context": "We can deal with hard constraints that are relaxed by integrating cost variables, obtaining so-called relaxed constraints hereafter; see [115, 100, 12].", "startOffset": 137, "endOffset": 151}, {"referenceID": 70, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 72, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 88, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 38, "context": "Or we can deal with cost functions that are also called weighted constraints in the litterature (framework WCSP); see [71, 73, 89, 39].", "startOffset": 118, "endOffset": 134}, {"referenceID": 100, "context": "It is then possible to soften global constraints by referring to some known violation measures [101, 130].", "startOffset": 95, "endOffset": 105}, {"referenceID": 129, "context": "It is then possible to soften global constraints by referring to some known violation measures [101, 130].", "startOffset": 95, "endOffset": 105}, {"referenceID": 11, "context": "For example, the violation measure \"var\" can be refined [12] by indicating the subset of variables that are allowed to change their values, when measuring.", "startOffset": 56, "endOffset": 60}, {"referenceID": 128, "context": "1 Constraint soft-and (Cardinality Operator) The cardinality operator [129], which must not be confused with the cardinality constraint, connects a cost variable with a set (conjunction) of constraints: the value of the cost variable is the number of violated constraints in the set.", "startOffset": 70, "endOffset": 75}, {"referenceID": 3, "context": "2 Constraint soft-slide (cardPath) A general scheme, or meta-constraint, that is useful to post constraints on sequences of variables is cardPath [4].", "startOffset": 146, "endOffset": 149}, {"referenceID": 3, "context": "Finally, we illustrate soft-slide with the constraint softSlidingSum [4].", "startOffset": 69, "endOffset": 72}, {"referenceID": 100, "context": "For the relaxed version [101, 132] of allDifferent, we can use the two general-purpose violation measures \"var\" and \"dec\".", "startOffset": 24, "endOffset": 34}, {"referenceID": 129, "context": "For the soft version of cardinality, we can use \"var\" as well as the measure \"val\" defined in [130].", "startOffset": 94, "endOffset": 99}, {"referenceID": 129, "context": "5 Constraint soft-regular For the relaxed version of regular, we can use \"var\" as well as the measure \"edit\" defined in [130].", "startOffset": 120, "endOffset": 125}, {"referenceID": 129, "context": "6 Constraint soft-permutation (same) For the relaxed version of permutation (same), we can use \"var\" [130], while discarding the optional element <mapping> of the hard version.", "startOffset": 101, "endOffset": 106}, {"referenceID": 0, "context": "The following group of constraints is equivalent to post: \u2022 g[0]: x0 + x1 = x2 \u2022 g[1]: x3 + x4 = x5 \u2022 g[2]: x6 + x7 = x8 1We might extend the possibilities of building groups, in the future.", "startOffset": 82, "endOffset": 85}, {"referenceID": 1, "context": "The following group of constraints is equivalent to post: \u2022 g[0]: x0 + x1 = x2 \u2022 g[1]: x3 + x4 = x5 \u2022 g[2]: x6 + x7 = x8 1We might extend the possibilities of building groups, in the future.", "startOffset": 103, "endOffset": 106}, {"referenceID": 0, "context": "With T = {(1, 2), (2, 1), (2, 3), (3, 1), (3, 2), (3, 3)}, the following group of constraints is equivalent to post: \u2022 h[0]: (w, x) \u2208 T \u2022 h[1]: (w, z) \u2208 T \u2022 h[2]: (x, y) \u2208 T", "startOffset": 139, "endOffset": 142}, {"referenceID": 1, "context": "With T = {(1, 2), (2, 1), (2, 3), (3, 1), (3, 2), (3, 3)}, the following group of constraints is equivalent to post: \u2022 h[0]: (w, x) \u2208 T \u2022 h[1]: (w, z) \u2208 T \u2022 h[2]: (x, y) \u2208 T", "startOffset": 158, "endOffset": 161}, {"referenceID": 2, "context": "Example 144 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 144 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 112, "endOffset": 115}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 120, "endOffset": 123}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 142, "endOffset": 145}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 150, "endOffset": 153}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 153, "endOffset": 156}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 158, "endOffset": 161}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 161, "endOffset": 164}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 183, "endOffset": 186}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 191, "endOffset": 194}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 194, "endOffset": 197}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 199, "endOffset": 202}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 202, "endOffset": 205}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 232, "endOffset": 235}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 240, "endOffset": 243}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 268, "endOffset": 271}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 273, "endOffset": 276}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 276, "endOffset": 279}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 281, "endOffset": 284}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 284, "endOffset": 287}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 309, "endOffset": 312}, {"referenceID": 0, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 314, "endOffset": 317}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 317, "endOffset": 320}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 322, "endOffset": 325}, {"referenceID": 1, "context": "3 </array > </variables > <constraints > <group > <allDifferent > %0 %1 %2 </allDifferent > <args > x[0][0] x[0][1] x[0][2] </args > <args > x[1][0] x[1][1] x[1][2] </args > <args > x[2][0] x[2][1] x[2][2] </args > <args > x[0][0] x[1][0] x[2][0] </args > <args > x[0][1] x[1][1] x[2][1] </args > <args > x[0][2] x[1][2] x[2][2] </args > </group > </constraints > </instance >", "startOffset": 325, "endOffset": 328}, {"referenceID": 2, "context": "Example 145 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 145 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 50, "endOffset": 53}, {"referenceID": 1, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 74, "endOffset": 77}, {"referenceID": 0, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 124, "endOffset": 127}, {"referenceID": 1, "context": "</allDifferent > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > </group > </constraints > </instance >", "startOffset": 148, "endOffset": 151}, {"referenceID": 2, "context": "Example 146 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 146 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 2, "context": "Example 147 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 2, "context": "Example 147 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[3][3]\"> 1.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 86, "endOffset": 89}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 110, "endOffset": 113}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 160, "endOffset": 163}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 184, "endOffset": 187}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 214, "endOffset": 217}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 217, "endOffset": 220}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 222, "endOffset": 225}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 225, "endOffset": 228}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 247, "endOffset": 250}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 255, "endOffset": 258}, {"referenceID": 0, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 258, "endOffset": 261}, {"referenceID": 1, "context": "</list > <condition > (eq ,15) </condition > </sum > <args > x[0][] </args > <args > x[1][] </args > <args > x[2][] </args > <args > x[][0] </args > <args > x[][1] </args > <args > x[][2] </args > <args > x[0][0] x[1][1] x[2][2] </args > <args > x[2][0] x[1][1] x[0][2] </args > </group > </constraints > </instance >", "startOffset": 266, "endOffset": 269}, {"referenceID": 48, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 26, "endOffset": 30}, {"referenceID": 1, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 4, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 2, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 0, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 3, "context": "As an example, taken from [49], let us suppose that you need to express the following constraint: x \u2264 4\u21d2 t[x]\u00d7 y \u2265 6 which requires that if x \u2264 4 then the value at the xth position of array t (assumed here to be [2, 5, 3, 1, 4]) multiplied by y must be at least 6.", "startOffset": 212, "endOffset": 227}, {"referenceID": 48, "context": "Another example taken from [49] is: x > 4 \u2228 allDifferent(x, y, y \u2212 x)", "startOffset": 27, "endOffset": 31}, {"referenceID": 27, "context": "are able to cope directly with such formulations through the concept of views [28].", "startOffset": 78, "endOffset": 82}, {"referenceID": 7, "context": "Example 151 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[8]\"> 1.", "startOffset": 82, "endOffset": 85}, {"referenceID": 0, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 72, "endOffset": 75}, {"referenceID": 1, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 77, "endOffset": 80}, {"referenceID": 2, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 87, "endOffset": 90}, {"referenceID": 4, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 92, "endOffset": 95}, {"referenceID": 5, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 97, "endOffset": 100}, {"referenceID": 6, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 102, "endOffset": 105}, {"referenceID": 0, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 167, "endOffset": 170}, {"referenceID": 1, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 180, "endOffset": 183}, {"referenceID": 2, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 193, "endOffset": 196}, {"referenceID": 3, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 206, "endOffset": 209}, {"referenceID": 4, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 219, "endOffset": 222}, {"referenceID": 5, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 232, "endOffset": 235}, {"referenceID": 6, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 245, "endOffset": 248}, {"referenceID": 0, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 314, "endOffset": 317}, {"referenceID": 1, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 327, "endOffset": 330}, {"referenceID": 2, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 340, "endOffset": 343}, {"referenceID": 3, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 353, "endOffset": 356}, {"referenceID": 4, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 366, "endOffset": 369}, {"referenceID": 5, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 379, "endOffset": 382}, {"referenceID": 6, "context": "8 </array > </variables > <constraints > <allDifferent id=\"rows\"> x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] </allDifferent > <allDifferent id=\"diag1\"> add(x[0] ,0) add(x[1] ,1) add(x[2] ,2) add(x[3] ,3) add(x[4] ,4) add(x[5] ,5) add(x[6] ,6) add(x[7] ,7) </allDifferent > <allDifferent id=\"diag2\"> sub(x[0] ,0) sub(x[1] ,1) sub(x[2] ,2) sub(x[3] ,3) sub(x[4] ,4) sub(x[5] ,5) sub(x[6] ,6) sub(x[7] ,7) </allDifferent > </constraints > </instance >", "startOffset": 392, "endOffset": 395}, {"referenceID": 1, "context": "Example 156 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[2][4]\"> 0.", "startOffset": 82, "endOffset": 85}, {"referenceID": 3, "context": "Example 156 <instance format=\"XCSP3\" type=\"CSP\"> <variables > <array id=\"x\" size=\"[2][4]\"> 0.", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 145, "endOffset": 148}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 180, "endOffset": 183}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 183, "endOffset": 186}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 191, "endOffset": 194}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 215, "endOffset": 218}, {"referenceID": 1, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 218, "endOffset": 221}, {"referenceID": 1, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 226, "endOffset": 229}, {"referenceID": 0, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 250, "endOffset": 253}, {"referenceID": 2, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 253, "endOffset": 256}, {"referenceID": 2, "context": "7 </array > </variables > <constraints > <allDifferent > x[][] </allDifferent > <group > <intension > eq(%0,add (%1 ,%2)) </intension > <args > x[1][0] x[0][0] 2 </args > <args > x[1][1] x[0][1] 3 </args > <args > x[1][2] x[0][2] 4 </args > <args > x[1][3] x[0][3] 5 </args > </group > </constraints > </instance >", "startOffset": 261, "endOffset": 264}, {"referenceID": 2, "context": "As an illustration, let us consider the Coins problem: what is the minimum number of coins that allows one to pay exactly any price p smaller than one euro [3].", "startOffset": 156, "endOffset": 159}, {"referenceID": 23, "context": "The classical CSP framework can be extended by introducing valuations to be associated with constraint tuples [24], making it possible to express preferences.", "startOffset": 110, "endOffset": 114}, {"referenceID": 71, "context": "see [72]).", "startOffset": 4, "endOffset": 8}, {"referenceID": 0, "context": "Each fuzzy constraint represents a fuzzy relation on its scope: it associates a value in [0, 1] (either a rational, a decimal or one of the integers 0 and 1), called membership degree, with each constraint tuple \u03c4 , indicating to what extent \u03c4 belongs to the relation and therefore satisfies the constraint.", "startOffset": 89, "endOffset": 95}, {"referenceID": 47, "context": "As an illustration, let us consider the XCSP3 representation of the problem instance described in [48], page 110.", "startOffset": 98, "endOffset": 102}, {"referenceID": 24, "context": "QCSP and its semantics were introduced in [25].", "startOffset": 42, "endOffset": 46}, {"referenceID": 12, "context": "QCSP is an extension of QCSP, introduced in [13] to overcome some difficulties that may occur when modeling real problems with classical QCSP.", "startOffset": 44, "endOffset": 48}, {"referenceID": 13, "context": "2 QCOP() QCOP(), Quantified Constraint Optimization problem, is a framework [14] that allows us to formally express preferences over QCSP() strategies.", "startOffset": 76, "endOffset": 80}, {"referenceID": 13, "context": "However, when no element <minimize> or <maximize> is present for an element <exists>, this implicitly corresponds to the atom any [14].", "startOffset": 130, "endOffset": 134}, {"referenceID": 13, "context": "As an illustration, here is the XCSP3 representation of the toy problem introduced in [14], page 472.", "startOffset": 86, "endOffset": 90}, {"referenceID": 132, "context": "Here is an illustration taken from [135] about modeling a simple m quarter production planning problem.", "startOffset": 35, "endOffset": 40}, {"referenceID": 83, "context": "B is a set that satisfies the following properties [84]: B forms a partition of D\u00d7D, B contains the identity relation Id, and B is closed under the converse operation (\u22121).", "startOffset": 51, "endOffset": 55}, {"referenceID": 1, "context": "1 Interval Calculus A well known temporal qualitative formalism is the Interval Algebra, also called Allen\u2019s calculus [2].", "startOffset": 118, "endOffset": 121}, {"referenceID": 41, "context": "4 TCSP A well-known framework for time reasoning is TCSP (Temporal Constraint Satisfaction Problem) [42].", "startOffset": 100, "endOffset": 104}, {"referenceID": 69, "context": "For this framework, as seen in Chapter 6, we only need to introduce a type of constraints, called dbd constraints, for disjunctive binary difference constraints (as in [70]).", "startOffset": 168, "endOffset": 172}, {"referenceID": 41, "context": "Here is an example taken from [42].", "startOffset": 30, "endOffset": 34}, {"referenceID": 69, "context": "Following [70], we can introduce the following variables: x0 for a special time point denoting the beginning of time (7:00 in our case), x1 for the time at which John left home, x2 for the time at which John arrived at work, x3 for the time at which Fred left home, and x4 for the time at which Fred arrived at work.", "startOffset": 10, "endOffset": 14}, {"referenceID": 9, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 277, "endOffset": 285}, {"referenceID": 19, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 277, "endOffset": 285}, {"referenceID": 29, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 353, "endOffset": 361}, {"referenceID": 39, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 353, "endOffset": 361}, {"referenceID": 19, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 445, "endOffset": 453}, {"referenceID": 29, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 445, "endOffset": 453}, {"referenceID": 39, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 454, "endOffset": 462}, {"referenceID": 49, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 454, "endOffset": 462}, {"referenceID": 9, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 530, "endOffset": 538}, {"referenceID": 19, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 530, "endOffset": 538}, {"referenceID": 59, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 606, "endOffset": 614}, {"referenceID": 69, "context": "Example 170 <instance format=\"XCSP3\" type=\"TCSP\"> <variables > <var id=\"x0\" type=\"point\"/> <var id=\"x1\" type=\"point\"/> <var id=\"x2\" type=\"point\"/> <var id=\"x3\" type=\"point\"/> <var id=\"x4\" type=\"point\"/> </variables > <constraints > <dbd > <scope > x0 x1 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x1 x2 </scope > <intervals > [30 ,40] [60,+ infinity[ </intervals > </dbd > <dbd > <scope > x3 x4 </scope > <intervals > [20 ,30] [40 ,50] </intervals > </dbd > <dbd > <scope > x3 x2 </scope > <intervals > [10 ,20] </intervals > </dbd > <dbd > <scope > x0 x4 </scope > <intervals > [60 ,70] </intervals > </dbd >", "startOffset": 606, "endOffset": 614}, {"referenceID": 3, "context": "Example 171 <instance format=\"XCSP3\" type=\"NCSP\"> <variables > <var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [-4,4] </var > </variables > <constraints > <intension > eq(sub(y,pow(x,2)) ,0) </intension > <intension > eq(sub(y,add(x,1)) ,0) </intension > </constraints > </instance >", "startOffset": 88, "endOffset": 94}, {"referenceID": 3, "context": "Example 171 <instance format=\"XCSP3\" type=\"NCSP\"> <variables > <var id=\"x\" type=\"real\"> [-4,4] </var > <var id=\"y\" type=\"real\"> [-4,4] </var > </variables > <constraints > <intension > eq(sub(y,pow(x,2)) ,0) </intension > <intension > eq(sub(y,add(x,1)) ,0) </intension > </constraints > </instance >", "startOffset": 128, "endOffset": 134}, {"referenceID": 61, "context": "\u2022 \"dom\" [62].", "startOffset": 8, "endOffset": 12}, {"referenceID": 126, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 8, "endOffset": 13}, {"referenceID": 25, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 33, "endOffset": 37}, {"referenceID": 55, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 49, "endOffset": 58}, {"referenceID": 106, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 49, "endOffset": 58}, {"referenceID": 89, "context": "\u2022 \"deg\" [127], \"ddeg\" and \"wdeg\" [26] \u2022 \"impact\" [56, 107] \u2022 \"activity\" [90] It is possible to combine such criteria with the operator \u201c/\u201d, thus considering ratios, and also with the operator \u201c+\u201d to determine how to break ties.", "startOffset": 72, "endOffset": 76}, {"referenceID": 26, "context": "We can then use complex types, as for example: \u2022 \"dom/deg\", \"dom/ddeg\" and \"dom/wdeg\" \u2022 \"dom+ddeg\" For example, \"dom+ddeg\" is known as the Brelaz heuristic [27, 124].", "startOffset": 156, "endOffset": 165}, {"referenceID": 123, "context": "We can then use complex types, as for example: \u2022 \"dom/deg\", \"dom/ddeg\" and \"dom/wdeg\" \u2022 \"dom+ddeg\" For example, \"dom+ddeg\" is known as the Brelaz heuristic [27, 124].", "startOffset": 156, "endOffset": 165}, {"referenceID": 77, "context": "By means of the attribute lc, it is also possible to indicate that last conflict reasoning [78] should be employed: the value of the attribute indicates the maximal size (k) of the testing set.", "startOffset": 91, "endOffset": 95}, {"referenceID": 90, "context": "Here, conflicts refers to the number of conflicts with neighbors [91, 55].", "startOffset": 65, "endOffset": 73}, {"referenceID": 54, "context": "Here, conflicts refers to the number of conflicts with neighbors [91, 55].", "startOffset": 65, "endOffset": 73}, {"referenceID": 37, "context": "See Bounds(Z) in [38].", "startOffset": 17, "endOffset": 21}, {"referenceID": 37, "context": "See Bounds(D) in [38].", "startOffset": 17, "endOffset": 21}, {"referenceID": 37, "context": "See Bounds(R) in [38].", "startOffset": 17, "endOffset": 21}, {"referenceID": 2, "context": "For example, x[0][3] becomes x_0_3 and g[0] becomes g_0.", "startOffset": 17, "endOffset": 20}, {"referenceID": 0, "context": "<constraints > <intension > eq(x,0) </intension > <extension > <list > t[0] t[1] </list > <supports > (2,4)(3,5) </supports > </extension > <intension > le(y,z) </intension > </constraints >", "startOffset": 77, "endOffset": 80}, {"referenceID": 0, "context": "\"constraints\": { \"intension\": \"eq(x,0)\", \"extension\": { \"list\": \"t[0] t[1]\", \"supports\": \"(2,4)(3,5)\" }, \"intension\": \"le(y,z)\" }", "startOffset": 71, "endOffset": 74}, {"referenceID": 0, "context": "\"constraints\": { \"intension\": [\"eq(x,0)\", \"le(y,z)\"], \"extension\": { \"list\": \"t[0] t[1]\", \"supports\": \"(2,4)(3,5)\" } }", "startOffset": 84, "endOffset": 87}], "year": 2016, "abstractText": "We propose a major revision of the format XCSP 2.1, called XCSP3, to build integrated representations of combinatorial constrained problems. This new format is able to deal with mono/multi optimization, many types of variables, cost functions, reification, views, annotations, variable quantification, distributed, probabilistic and qualitative reasoning. The new format is made compact, highly readable, and rather easy to parse. Interestingly, it captures the structure of the problem models, through the possibilities of declaring arrays of variables, and identifying syntactic and semantic groups of constraints. The number of constraints is kept under control by introducing a limited set of basic constraint forms, and producing almost automatically some of their variations through lifting, restriction, sliding, logical combination and relaxation mechanisms. As a result, XCSP3 encompasses practically all constraints that can be found in major constraint solvers developed by the CP community. A website, which is developed conjointly with the format, contains many models and series of instances. The user can make sophisticated queries for selecting instances from very precise criteria. The objective of XCSP3 is to ease the effort required to test and compare different algorithms by providing a common test-bed of combinatorial constrained instances.", "creator": "LaTeX with hyperref package"}}}