{"id": "1703.09749", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Mar-2017", "title": "Developpement de Methodes Automatiques pour la Reutilisation des Composants Logiciels", "abstract": "the large amount of design information and the increasing dynamic complexity of applications constrain enterprise developers to have stand - alone and reusable components targeted from large libraries and component markets. our approach mostly consists in developing methods to evaluate the spatial quality of rendering the software component composition of these libraries, on eliminating the medium one last hand and especially moreover to economically optimize the eventual financial cost and control the total adaptation's time of these selected components. our objective function loosely defines a particular metric property that accurately maximizes of the value of the software integrated component quality by minimizing the same financial term cost requirement and maintenance time. this model only should sometimes make a it best possible to classify the required components and order knit them together in order to facilitate choose toward the tools most optimized.", "histories": [["v1", "Tue, 21 Mar 2017 15:34:28 GMT  (970kb)", "http://arxiv.org/abs/1703.09749v1", "in French"]], "COMMENTS": "in French", "reviews": [], "SUBJECTS": "cs.SE cs.CL cs.DB", "authors": ["kouakou ive arsene koffi", "konan marcellin brou", "souleymane oumtanaga"], "accepted": false, "id": "1703.09749"}, "pdf": {"name": "1703.09749.pdf", "metadata": {"source": "CRF", "title": "DEVELOPPEMENT DE METHODES AUTOMATIQUES POUR LA REUTILISATION DES COMPOSANTS LOGICIELS", "authors": ["KOFFI Kouakou", "Ive Ars\u00e8ne", "Docteur BROU", "Konan Marcellin", "OUMTAGADA Souleymane"], "emails": ["koffiyvesarsene@gmail.com"], "sections": [{"heading": "DEVELOPPEMENT DE METHODES AUTOMATIQUES POUR LA REUTILISATION DES COMPOSANTS LOGICIELS", "text": "KOFFI Kouakou Ive Ars\u00e8ne, Docteur BROU Konan Marcellin, Prof. OUMTAGADA Souleymane D\u00e9partement d\u2019informatique Ecole Doctorale Polytechnique Institut National Polytechnique Houphouet Boigny (EDP-INPHB) YAMOUSSOUKRO C\u00d4TE D\u2019IVOIRE koffiyvesarsene@gmail.com"}, {"heading": "R\u00c9SUM\u00c9.La masse importanted\u2019informationset \u00e0 lacomplexit\u00e9 croissantedes applications", "text": "contraignent les d\u00e9veloppeurs \u00e0 avoir des composants autonomes et r\u00e9utilisables des biblioth\u00e8ques et des march\u00e9s de composants. Notre approche consiste \u00e0 d\u00e9velopper des m\u00e9thodes pour \u00e9valuer la qualit\u00e9 du composant logiciel de ces biblioth\u00e8ques d\u2019une part et d\u2019autre part \u00e0 optimiser le co\u00fbt financier et le temps d\u2019adaptation des composants s\u00e9lectionn\u00e9s. Notre fonction objectif d\u00e9finit une m\u00e9trique qui maximise la valeur de la qualit\u00e9 du composant logiciel en minimisant le co\u00fbt financier et le temps de maintenance. Ce mod\u00e8le devrait permettre de classer les composants et de les ordonner afin de choisir le plus optimis\u00e9. ABSTRACT.The large amount of information and the increasing complexity of applications constrain developers to have stand-alone and reusable components from libraries and component markets.Our approach consists in developing methods to evaluate the quality of the software component of these libraries, on the one hand and moreover to optimize the financial cost and the adaptation\u2019s time of these selected components. Our objective function defines a metric that maximizes the value of the software component quality by minimizing the financial cost and maintenance time. This model should make it possible to classify the components and order them in order to choose the most optimized. MOTS-CLES : d\u00e9veloppement de m\u00e9thode, r\u00e9utilisation, composants logiciels, qualit\u00e9 de composant KEYWORDS:method development, reuse, software components, component quality ."}, {"heading": "INTRODUCTION", "text": "Les d\u00e9veloppeurs et les entreprises se trouvent souvent confront\u00e9es \u00e0 une masse importante d\u2019informations dans l\u2019ing\u00e9nierie des syst\u00e8mes d\u2019information. Cette masse importante d\u2019informations a pour cons\u00e9quence l\u2019augmentation de la taille des logiciels \u00e0 d\u00e9velopper et l\u2019accroissement de la complexit\u00e9 de ces applications. Pour r\u00e9soudre ces difficult\u00e9s, les d\u00e9veloppeurs de logiciel font de plus en plus recours \u00e0 des composants r\u00e9utilisables dans leurs applications. La r\u00e9utilisation de ces composants n\u00e9cessite le d\u00e9veloppement de mod\u00e8les et de m\u00e9thodes sans lesquels de nombreuses t\u00e2ches sont manuelles et r\u00e9p\u00e9titives. Nous allons, dans ces travaux de recherche, d\u00e9velopper des m\u00e9thodes automatiques pour \u00e9valuer et am\u00e9liorer la qualit\u00e9 des composants logiciels s\u00e9lectionn\u00e9s selon les crit\u00e8res d\u00e9finis par l\u2019utilisateur. Il s\u2019agit de :\n1. D\u00e9finir un mod\u00e8le de qualit\u00e9 du composant logiciel; 2. D\u00e9finir un processus de s\u00e9lection du composant pertinent et adapt\u00e9 au syst\u00e8me\nlogiciel \u00e0 construire;\n3. Etablir un mod\u00e8le m\u00e9trique pour \u00e9valuer, maximiser la qualit\u00e9 du composant. 4. Optimiser le co\u00fbt et le temps de maintenance.\nCe travail est organis\u00e9 comme suit. La premi\u00e8re partie concerne l\u2019\u00e9tat de l\u2019art relatif \u00e0 la s\u00e9lection des composants r\u00e9utilisables. La deuxi\u00e8me partie traite des diff\u00e9rents mod\u00e8les d\u00e9velopp\u00e9s qui font objet de notre article. La derni\u00e8re partie concerne la conclusion et les perspectives.\nSECTION 1"}, {"heading": "1. Etat de l\u2019art", "text": "1.1. m\u00e9thodes d\u2019analyse multicrit\u00e8re et optimisation Pour \u00e9valuer la qualit\u00e9 des objets s\u00e9lectionn\u00e9s en g\u00e9n\u00e9ral et des composants logiciels en particulier, plusieurs m\u00e9thodes de prise de d\u00e9cision multicrit\u00e8re ont \u00e9t\u00e9 r\u00e9alis\u00e9es. Dans l\u2019article de E. Triantaphyllou et al.(1998), les chercheursproposentla m\u00e9thode d\u2019analyse hi\u00e9rarchique des proc\u00e9d\u00e9s (AHP).Cette technique \u00e9tablit une table de comparaison binaire des caract\u00e9ristiques, des sous caract\u00e9ristiques des composants logiciels par niveau. Ensuite d\u00e9termine les poids de ces diff\u00e9rents crit\u00e8res et sous crit\u00e8res d\u2019une part et d\u2019autre part \u00e9value la coh\u00e9rence de cette table. Dans les travauxde A.A. Zaidan et al.(2015), les auteurs d\u00e9finissent une approche de prise de d\u00e9cision multi-crit\u00e8res pour traiter les probl\u00e8mes complexes. Cette approche permet de d\u00e9composer le probl\u00e8me en plusieurs niveaux, d\u00e9finissant les objectifs et fournissant un cadre d\u2019ensemble pour l'\u00e9valuation de solutions. Ils proposent la m\u00e9thode d\u2019analyse AHP comme la meilleure alternative pour la maximisation des donn\u00e9es complexes.Ils donnent le mod\u00e8le suivant :\nDans le cadre de l\u2019optimisation des param\u00e8tres li\u00e9s aux composants s\u00e9lectionn\u00e9s, l\u2019article de R. Perriot et al.(2014), donne diff\u00e9rents mod\u00e8les math\u00e9matiques d\u2019optimisation en programmation lin\u00e9aire. L\u2019un de ces mod\u00e8les \u00e9tablit un compromis entre le co\u00fbt mon\u00e9taire minimum et le temps de r\u00e9ponse dans les nuages informatiques. Il est formul\u00e9 ci-dessous :\n1.2. S\u00e9lection de composants logiciels\nLa gestion des informations implique la recherche, la s\u00e9lection et le stockage de documents pertinents en g\u00e9n\u00e9ral et dans le domaine du g\u00e9nie logiciel, des composants logiciels en particulier. Le chercheur E. Rames (1991) d\u00e9finit un mod\u00e8le de recherche bas\u00e9 sur la classification hi\u00e9rarchique et th\u00e9matique des composants logiciels contenus dans une base. Cependant, sa m\u00e9thode de classification des composants \u00e9tait bas\u00e9e sur une technique manuelle. Dans l\u2019article deB. George et al.(2010), un m\u00e9canisme permettant l\u2019automatisation de la s\u00e9lection d\u2019un composant logiciel, parmi un ensemble de\n(1) * 1 max 1,2,3,....AHP ij jjA q w for i M \nminimiser( C+(1- )T\navecles contraintes\n: mod\u00e8le de cout\n:\nquidefinissent\nC le\nT letemps deselectiondesvues       \n(2)\ncandidats en fonction de leurs propri\u00e9t\u00e9s fonctionnelles et non fonctionnelles a \u00e9t\u00e9 \u00e9tudi\u00e9. Ce m\u00e9canisme permet de rendre possible l\u2019extraction et de comparer les composants. Il s\u2019agit apr\u00e8s des phases de s\u00e9lection de composants, de mesurer l\u2019indice de satisfaction de ces diff\u00e9rents composants candidats s\u00e9lectionn\u00e9s afin de trouver les plus pertinents. L\u2019article de A.A. Zaidan et al.(2015) propose une \u00e9tude comparative des logiciels dont le but est d\u2019\u00e9valuer et de s\u00e9lectionner des logiciels \u00ab open source \u00bb pour la gestiondes dossiers m\u00e9dicaux \u00e9lectroniques et num\u00e9riques. Cette \u00e9tude est r\u00e9alis\u00e9e avec diff\u00e9rentes techniques de prise de d\u00e9cision \u00e0 crit\u00e8res multiples. Ainsi les syst\u00e8mes logiciels sont s\u00e9lectionn\u00e9s sur la base d'un ensemble de r\u00e9sultats m\u00e9triques \u00e0 l'aide de la technique AHP int\u00e9gr\u00e9e \u00e0 diff\u00e9rentes techniques de prise de d\u00e9cision multicrit\u00e8res. Dans l\u2019article de J. Pande et al.(2013), une m\u00e9trique de souplesse a \u00e9t\u00e9d\u00e9finie. Cette m\u00e9trique leur a permis de d\u00e9terminer une s\u00e9lection optimale des composants logiciels avec le mod\u00e8le suivant :\nA = ensemble d\u2019attributs de qualit\u00e9 ;\nSC = ensemble de composants disponibles (composants candidats) ;\nqhi= le niveau normalis\u00e9 de l\u2019attribut de qualit\u00e9 h\u03f5 A pour le composant i ; Wh = poids attribu\u00e9 \u00e0 l'attribut de qualit\u00e9 h\u03f5 A ; xi = 1 si le composant i est s\u00e9lectionn\u00e9, sinon 0 ; Ci = co\u00fbt normalis\u00e9 du composant i.\n1.3. Limite des m\u00e9thodes\nCompte tenu des m\u00e9thodes d\u00e9velopp\u00e9es, nous remarquons que diff\u00e9rents chercheurs ont apport\u00e9 d'\u00e9normes contributions. Cependant, certains aspects tels que le temps d\u2019adaptation et de maintenance des composants logiciels d\u2019une part et d\u2019autre part, l\u2019optimisation des deux param\u00e8tres co\u00fbt et temps relatifs aux composants s\u00e9lectionn\u00e9sde ces biblioth\u00e8ques n'ont pas \u00e9t\u00e9 pris en compte.\n(3) h hi i i i h A i SC i SC p w q x c x      \nSECTION 2"}, {"heading": "2. Probl\u00e8me de recherche", "text": "Dans la revue de litt\u00e9rature, divers travaux relatifs aux m\u00e9thodes de s\u00e9lection de composants logiciels pertinents ont \u00e9t\u00e9 r\u00e9alis\u00e9s. Les travaux que nous pr\u00e9sentons traitent de la probl\u00e9matique de l\u2019\u00e9valuation de la qualit\u00e9 des composants pr\u00e9-faits. Il s\u2019agit de la maximisation de leurs valeurs de qualit\u00e9 en optimisant le co\u00fbt financier, de maintenance et le temps d\u2019adaptation de ces composants en vue de les r\u00e9utiliser dans un syst\u00e8me logiciel. Notre objectif est donc de d\u00e9terminer une m\u00e9trique qui permettra de maximiser la qualit\u00e9 du composant logiciel s\u00e9lectionn\u00e9 tout en minimisant le co\u00fbt financier, de maintenance et le temps d\u2019adaptation de ce composant. Il s\u2019agit alors de d\u00e9finir un mod\u00e8le de qualit\u00e9 du composant logiciel, ensuite de d\u00e9finir un processus de s\u00e9lection des composantsadapt\u00e9s au syst\u00e8me logiciel \u00e0 construire, et enfin d\u2019\u00e9tablir un mod\u00e8le m\u00e9trique pour \u00e9valuer la qualit\u00e9 du composant logiciel s\u00e9lectionn\u00e9 d\u2019une part, et d\u2019autre part, d\u2019optimiser le co\u00fbt financier et le temps de modification, d\u2019adaptation de ce composant. Ceci nous am\u00e8ne \u00e0 formuler les hypoth\u00e8ses de recherche suivantes : Les caract\u00e9ristiques d\u00e9finies des composants logiciels permettent-elles d\u2019obtenir des attributs mesurables et g\u00e9n\u00e9rant des composants logiciels de qualit\u00e9 ? La s\u00e9lection de composant de qualit\u00e9, pertinent r\u00e9pondant aux besoins de l\u2019utilisateur permet-elle d\u2019optimiser le co\u00fbt financier de maintenance et le temps d\u2019adaptation de ce composant dans un syst\u00e8me logiciel?\nSECTION 3"}, {"heading": "3. Phase de mod\u00e9lisation", "text": "3.1. Proposition de mod\u00e8le de qualit\u00e9 du composant logiciel Nous nous int\u00e9resserons \u00e0 l\u2019\u00e9valuation de la s\u00e9lection et \u00e0 l\u2019int\u00e9gration des composants logiciels dans un syst\u00e8me de logiciel. Notre objectif principal est de faire le choix du \u00ab meilleur composant logiciel \u00bb d\u2019une biblioth\u00e8que ou d\u2019un march\u00e9 de composants. Cette s\u00e9lection doit r\u00e9pondre au mieux aux crit\u00e8res d\u00e9finis par l\u2019utilisateur et selon le type d\u2019application \u00e0 construire. Les caract\u00e9ristiques d\u00e9finies sont les suivantes : la capacit\u00e9 fonctionnelle, la fiabilit\u00e9, la facilit\u00e9 d\u2019utilisation, la s\u00e9curit\u00e9 et la maintenabilit\u00e9. Ce qui nous permet de d\u00e9finir le mod\u00e8le 1 suivant :\nFig1 mod\u00e8le de qualit\u00e9 de composant logiciel\nCe mod\u00e8le est bas\u00e9 sur le mod\u00e8le de qualit\u00e9 ISO 9126 et des repr\u00e9sentations de qualit\u00e9 des revues de litt\u00e9rature. Il permet de pr\u00e9ciser les caract\u00e9ristiques les plus importantes pour le choix des composants logiciels selon les besoins de l\u2019utilisateur.\n1Mod\u00e8le de qualit\u00e9, Inspir\u00e9 du mod\u00e8le ISO 9126 et de la qualit\u00e9 logicielle d\u00e9finie par J\u00e9remie Grodziski\nEn utilisant la technique Analyse Hi\u00e9rarchique des Proc\u00e9d\u00e9s (AHP), nous pourrons atteindre l\u2019objectif qui consiste \u00e0 choisir le composant logiciel qui r\u00e9pond le mieux possible aux besoins de l\u2019utilisateur. Pour se faire, nous avons construit le mod\u00e8le hi\u00e9rarchique de qualit\u00e9 en fonction des caract\u00e9ristiques et des sous caract\u00e9ristiques des composants logiciels (fig1). Ensuite, \u00e0 l\u2019aide de la m\u00e9thode d\u2019analyse multicrit\u00e8re, nous avons construit une table de comparaison binaire des caract\u00e9ristiques et sous caract\u00e9ristiques. Ceci a permis de d\u00e9terminer les poids des diff\u00e9rents crit\u00e8res de qualit\u00e9 d\u00e9finis du composant logiciel d\u2019une part et d\u2019autre part d\u2019\u00e9valuer la coh\u00e9rence de notre travail.\n3.2. Proposition de processus de s\u00e9lection du composant logiciel Nous allons donner une description du processus de s\u00e9lection des composants s\u00e9lectionn\u00e9s puis \u00e9valu\u00e9s. Ceci nous am\u00e8nera \u00e0 faire le choix du composant pertinent et optimis\u00e9.\nFig2 Mod\u00e8le d\u2019\u00e9valuation de la qualit\u00e9 du composant logiciel\nEn noir : les actions \u00e0 effectuerlors de la s\u00e9lection\nEn rouge : les m\u00e9thodes utilis\u00e9es lors de la s\u00e9lection\nCe processus est mod\u00e9lis\u00e9 en UML de la mani\u00e8re suivante :\nFig3 processus de s\u00e9lection d\u2019un composant\nIl s\u2019agit de d\u00e9finir un processus de s\u00e9lection qui permettra \u00e0 l\u2019utilisateur de faire le choix du composant logiciel dans une biblioth\u00e8que. En effet sur le net, il existe de nombreuses biblioth\u00e8ques telles que ComponentSource, Sourceforge, flashline,citerAlterWay, etc, permettant de programmer une interface graphique pour des applications donn\u00e9es.\n1\n2\n3\n4\n5\n6\nLe processus de s\u00e9lection suit les \u00e9tapes suivantes : Etape1:L\u2019utilisateur exprime les besoins de qualit\u00e9 du composant. Etape2: Une premi\u00e8re recherche consiste \u00e0 prendre en compte les propri\u00e9t\u00e9s fonctionnelles fournissant certains services en rapport avec le type de logiciel \u00e0 construire et surtout les besoins exprim\u00e9s par l\u2019utilisateur. Nous obtenons un ensemble de composants logiciels s\u00e9lectionn\u00e9s dont les propri\u00e9t\u00e9s sont des propri\u00e9t\u00e9s fonctionnelles fournies par les composants logiciels. Autrement dit, il s\u2019agit des services rendus par les diff\u00e9rents composants. Etape3: Cette \u00e9tape consiste \u00e0 faire une s\u00e9lection bas\u00e9e sur les propri\u00e9t\u00e9s non fonctionnelles. Il s\u2019agit de tenir compte de la qualit\u00e9 du composant logiciel et comment les services sont rendus. Cette \u00e9tape consiste \u00e0 \u00e9valuer la qualit\u00e9 du composant \u00e0 partir de m\u00e9trique d\u00e9finie. On s\u00e9lectionnera le composant qui r\u00e9pond aux mieux, aux crit\u00e8res de qualit\u00e9 d\u00e9finis par l\u2019utilisateur. Etape4: Au niveau de cette \u00e9tape, on \u00e9value la maintenance c\u2019est-\u00e0-dire, la phase de modification et d\u2019adaptation du composant dans un syst\u00e8me en cours d\u2019utilisation. Elle repr\u00e9sente la phase de simulation pour d\u00e9terminer la qualit\u00e9 du composant. Nous appliquons \u00e0 ce niveau, la m\u00e9trique qui permet d\u2019\u00e9valuer le co\u00fbt financier et le temps g\u00e9n\u00e9r\u00e9s. Elle \u00e9valueet produit un co\u00fbt financier et un temps de maintenance. Etape5: Dans le cas o\u00f9 les param\u00e8tresco\u00fbt et temps sont optimis\u00e9s, alors, le composant s\u00e9lectionn\u00e9 est retenu. Etape6: Si les param\u00e8tres ne le sont pas, alors la recherche continue et le processus reprend\n3.3. Proposition de mod\u00e8le pour \u00e9valuer le co\u00fbt financier et le temps de\nmaintenance\nEn nous inspirant des mod\u00e8les d\u00e9finis dans les revues de litt\u00e9ratures, notre approche consiste \u00e0 \u00e9valuer en plus du co\u00fbt financier du composant, le temps mis pour r\u00e9aliser la maintenance. Notre mod\u00e8le a pour objectif de prendre en compte le param\u00e8tre temps lors de d\u2019\u00e9valuation de la qualit\u00e9 du composant logiciel \u00e0 l\u2019aide de la programmation lin\u00e9aire. Il s\u2019agira pour nous de d\u00e9finir une m\u00e9trique \u00e0 deux param\u00e8tres dont le co\u00fbt financier et le temps sont fonction de l\u2019indice du composant choisi. Cette m\u00e9trique sert \u00e0 optimiser les param\u00e8tres afin de s\u00e9lectionner le \u00ab meilleur composant logiciel \u00bb d\u2019une part et d\u2019autre part de minimiser ce co\u00fbt financier et le temps d\u2019adaptation et de modification du composant s\u00e9lectionn\u00e9. Nous d\u00e9finissons notre fonction de la mani\u00e8re suivante :\n   , , 1 i i f c t i c t    i sc  ;\nAvec les contraintes suivantes :\n0 1 \n(4)\nmax\ni\nt t\nT  et 0 1it \nmax\ni\nc c\nC  et 0 1ic \nO\u00f9 Sc : ensemble de composants disponibles ;\nic : Co\u00fbt financier normalis\u00e9 de maintenance du composant i ; C : cout relatif g\u00e9n\u00e9r\u00e9 par le composant i ; Cmax : Co\u00fbt maximum r\u00e9alis\u00e9 par un des composants s\u00e9lectionn\u00e9s ; it : temps d\u2019adaptation et de maintenance normalis\u00e9 du composant i ; t : temps relatif, g\u00e9n\u00e9r\u00e9 par le composant i ;  : Coefficient d\u2019adaptation ; Tmax : temps maximum r\u00e9alis\u00e9 par un des composants s\u00e9lectionn\u00e9s.\nDonc la m\u00e9trique pour tout composant logiciel i s\u00e9lectionn\u00e9 sera :\nEt les contraintes\n0 1it  et\nmax\ni\nc c\nC  et 0 1ic \nO\u00f9 A = ensemble des caract\u00e9ristiques de qualit\u00e9 du logiciel; SC = ensemble de composants disponibles (composants candidats) ; qhi= le niveau normalis\u00e9 de l\u2019attribut de qualit\u00e9 h\u03f5 A pour le composant i ; Wh = poids attribu\u00e9 \u00e0 l'attribut de qualit\u00e9 h\u03f5 A ; xi = 1 si le composant i est s\u00e9lectionn\u00e9, 0 sinon ; Ci = co\u00fbt normalis\u00e9 du composant i ; it : Temps normalis\u00e9 de maintenance du composant i ;  : Coefficient d\u2019adaptation \u00e0 pr\u00e9ciser Le mod\u00e8le (5) repr\u00e9sente la fonction objectif. Cette fonction permet de calculer puisd\u2019\u00e9valuer la qualit\u00e9 des caract\u00e9ristiques des composants logiciels s\u00e9lectionn\u00e9s.\ni SC \n0 1 \n(5)  1h hi i i i ii h A S w q x c t x        \nmax\ni\nt t\nT \nPourmaximiserla fonction objectif, nous devons optimiser les param\u00e8tres Temps et co\u00fbt de maintenance. Alors, il nous faudrait maximiser le premier terme et minimiser le second terme de iS . Ceci revient \u00e0 maximiser le terme Qi\net \u00e0 minimiser le second terme mi\n 1i i i im c t x      i SC \nPour tout composant logiciel i de la biblioth\u00e8que, on obtient le syst\u00e8me suivant :\nNous pourrons alors comparer et ordonner les diff\u00e9rentes valeurs iS d\u00e9signant les valeurs de qualit\u00e9 de chaque composant logiciel choisis. Ainsi plus la valeur est grande, plus le composant logiciel est de qualit\u00e9 avec un temps d\u2019adaptation et un co\u00fbt de maintenance r\u00e9duits.\n(6)\n(7)\n   \nmax max\nmax max\nmax\nmax max\nmax( 1 ) max( ) min( 1 )\n1 1\n0 1 0 1\n0 0\n0 0\n1 0\nh hi i i i i h hi i i i ih A h A\nh hh A h A\ni i\ni i\nw q x c t x w q x c t x\nw w\nt t t et t T t et t T\nT T\nc c c et c C c et\nC C\nx siselectionn\u00e9 sinon x\n   \n \n \n \n                                             max 1 0 c C x siselectionn\u00e9 sinon x               \ni h h i\nh A Q w q x   i SC \n(8)\nSECTION 4"}, {"heading": "4. Phase de Validation", "text": "En mati\u00e8re de recherche, toute th\u00e9orie doit passer par une phase d'exp\u00e9rimentation ou de simulation avant sa validation. Pour se faire, nous proposons un algorithme pour soutenir et valider la th\u00e9orie d\u00e9velopp\u00e9e \u00e9valuant la qualit\u00e9 du composant logiciel. Il s\u2019agit \u00e9galement d\u2019optimiser les deux param\u00e8tres dont le temps et le co\u00fbt d\u2019adaptation. En effet nous proposons l\u2019algorithme SelectCompo pour r\u00e9soudre le probl\u00e8me\n4.1. Tableau d\u2019analyse du probl\u00e8me L\u2019algorithme SelectCompo a pour but de s\u00e9lectionner, dans une biblioth\u00e8que choisie, un ensemble de composants (Pi). Nous pr\u00e9sentons dans le tableau 1, les variables et les notations utilis\u00e9es dans nos algorithmes.\nIdentificateurs Types Entr\u00e9e/ Sortie R\u00f4les\nbiblio Chaine de\ncaract\u00e8re\nEntr\u00e9e Variable d\u00e9signant l\u2019intitul\u00e9 de la biblioth\u00e8que\ncourante.\nP[], composant[ ]\nChaine de caract\u00e8re Entr\u00e9e Variable d\u00e9signant un tableau de composants de la biblioth\u00e8que courante.\nMaxCompo Entier Entr\u00e9e Variable d\u00e9signant le nombre maximum de composants de la biblioth\u00e8que courante. MaxCaracter Entier Entr\u00e9e Variable d\u00e9signant le nombre maximum de caract\u00e9ristiques et sous caract\u00e9ristiques du\ncomposant courant\ni,j Entier Entr\u00e9e Indices de parcours des composants\ncompo Chaine de\ncaract\u00e8re\nsortie Variable d\u00e9signant le composant optimis\u00e9 et\nretenu.\nnom Chaine de caract\u00e8re Entr\u00e9e / Sortie Variable d\u00e9signant le nom de la caract\u00e9ristique Et de la sous caract\u00e9ristique\npoids r\u00e9el Entr\u00e9e / Sortie Variable d\u00e9signant le poids de la caract\u00e9ristique\net de la sous caract\u00e9ristique\nnote r\u00e9el Entr\u00e9e / Sortie Variable d\u00e9signant le note de la caract\u00e9ristique\net de la sous caract\u00e9ristique\nSousCaract[ ] Chaine de\ncaract\u00e8re\nEntr\u00e9e / Sortie Variable d\u00e9signant un tableau de\ncaract\u00e9ristiques et de sous caract\u00e9ristiques du composant courant\nSomme[] r\u00e9el Sortie Variabled\u00e9signant un tableau de valeurs r\u00e9elles\nexprimant la qualit\u00e9 des composantschoisis\nCr[] r\u00e9el Entr\u00e9e Variable d\u00e9signant un tableau de cout relatif du composant courant\nTr [] r\u00e9el Entr\u00e9e Variable d\u00e9signant un tableau de temps d\u2019adaptation relatif du composant courant\nTableau 1\n4.2. Proc\u00e9dures utilis\u00e9es Nous allons initialiser les 5 principales caract\u00e9ristiques (fig1) d\u00e9finies par l\u2019utilisateur pour faire notre \u00e9tude. Apr\u00e8s la phase de s\u00e9lection de l\u2019ensemble des composants (Pi), nous allons \u00e9valuer la qualit\u00e9 des caract\u00e9ristiques de ses composants en fonction de leur importance (poids) et de la qualit\u00e9 relative du composant (note) \u00e0 l\u2019aide de la proc\u00e9dure evaluation(Pi,nbre). A l\u2019\u00e9tape suivante, nous allons optimiser les composants en fonction du co\u00fbt et du temps de d\u2019adaptation par laproc\u00e9dure optimisation(Pi,nbre). Enfin nous allons choisir le composant le plus optimis\u00e9 de l\u2019ensemble des composants Pi avec la proc\u00e9dure affichage(). Ce dernier correspondra au composant ayant la valeur maximale des Pi not\u00e9e Max,suite \u00e0 l\u2019application de la proc\u00e9dure optimisation(Pi,nbre). Alors pour \u00e9crire l\u2019algorithme SelectCompo, nous allons utiliser diff\u00e9rentes proc\u00e9dures suivantes :\na. Proc\u00e9dure initialisation().\nElle permet d\u2019initialiser les caract\u00e9ristiques et les sous caract\u00e9ristiques d\u00e9finies par l\u2019utilisateur. Toutes les valeurs d\u00e9crites (fig1) sont initialis\u00e9es.\nb. Proc\u00e9dure saisie (biblio : chaine, nbre :entier)\nCette proc\u00e9dure permet de saisir la biblioth\u00e8que et le nombre de composants disponibles et r\u00e9pondant aux crit\u00e8res d\u00e9finis par l\u2019utilisateur en entr\u00e9e.En sortie, nous r\u00e9cup\u00e9rons la somme des poids des diff\u00e9rentes caract\u00e9ristiques.\nc. Procedure evaluation (Composant : tableau [1..MaxCompo] : chaine,\nnombre : entier)\nCette proc\u00e9dure permet de calculer par la m\u00e9trique des valeurs de qualit\u00e9 d\u00e9finie. Elle prend en entr\u00e9e une liste de composants et le nombre de composant souhait\u00e9. A la suite des tests et des contr\u00f4les, elle retourne un vecteur de valeurs r\u00e9elles d\u00e9signant la valeur de qualit\u00e9 du composant not\u00e9e Somme [].\nd. Procedure optimisation (nbre : entier)\nCette proc\u00e9dure permet de classer et d\u2019ordonner les valeurs de qualit\u00e9 retourn\u00e9es\npar\nla proc\u00e9dureevaluation. En param\u00e8tre, nous avons le nombre de composants retenus \u00e0 trier.\ne. affichage()\nCette proc\u00e9dure permet d\u2019affiche le composant retenu apr\u00e8s le tri par ordre d\u00e9croissant des valeurs de qualit\u00e9 des composants\n4.3. Pr\u00e9sentationdes algorithmes Dans cette partie de notre travail, nous pr\u00e9senterons le pseudo code dans les diff\u00e9rents algorithmes.\n4.3.1. Algorithme SelectCompo\nLe programme principal va se pr\u00e9senter comme suit :"}, {"heading": "Algorithme SelectCompo", "text": "Entr\u00e9e : biblio,\ntableau_de_composants chaine\nNbre, i entier\nSomme [] tableau de r\u00e9els\nSortie : compo chaine\nDebut\nTantque (besoins Exprim\u00e9s)"}, {"heading": "Debut", "text": "saisie (biblio , nombre )\nnbre = nombre\nPour i de 1 \u00e0 nbre faire\nDebut"}, {"heading": "Selectionner (Pi, nbre)", "text": "Pi = tableau_de_composants\nFinpour\ninitialisation()"}, {"heading": "Fintanque", "text": "si ((conditionsCaracterisques Remplies) et (co\u00fbt et temps relatifs dans\nintervalles requis) alors\ndebut\nPour i de 1 \u00e0 nbre faire\nDebut\nevaluation (Pi, nbre)\nsomme[i] = ValeurQualite(Pi)\nFinpour\nSi SatisfactionQualit\u00e9alors\nOptimisation (nbre )"}, {"heading": "Sinon", "text": "Reverser (composants dans biblio)\nfinsi\nAfichage()\nFin\nFig 4 : pseudo code de selectCompo\n4.3.2. Algorithme Evaluation\nNous avons donn\u00e9 la fonction objectif Si repr\u00e9sent\u00e9e par le mod\u00e8le (5).Cette fonction permettra l\u2019\u00e9valuation de la qualit\u00e9 du composant logiciel de la biblioth\u00e8que en tenant compte des contraintes d\u00e9finies au mod\u00e8le (8). L\u2019algorithmeEvaluation permet de calculer les valeurs de qualit\u00e9 d\u00e9finie par Si. Cette proc\u00e9dure prend en param\u00e8tre, une liste de composants et le nombre de composant\nobtenu apr\u00e8s la phase de s\u00e9lection bas\u00e9e sur les propri\u00e9t\u00e9s fonctionnelles de celui-ci. A\nla suite des tests et des contr\u00f4les, elle retourne un vecteur de valeurs r\u00e9elles d\u00e9signant la\nvaleur de qualit\u00e9 des composants.\nprocedure Evaluation(Composant : tableau [1..MaxCompo] : chaine,nombre : entier)\nEntr\u00e9e :i,j entier\nSom_qlte ,\nSom_CoutTemps r\u00e9el Sortie :somme somme tableau [1.. Max] de r\u00e9els\ndebut\nEcrire(le nombre de composants) Lire(nombre)\nSi (nomnbre>MaxCompo) alors\nnombre = MaxCompo\npour i de 1 \u00e0 nombre debut\nEcrire(cout et temps relatifs au composant courant)\nlire(cr[i], Tr[i])) Som_qlte 0 ;\nSom_coutTemps0 ;\nPour j de 1 \u00e0 MaxCaracter faire\nDebut\nSi ((0\u2264 Caract[j].poids\u22641) et (0< Caract[j].note \u2264 Qmax) et Somm =1 ) alors\nDebutsi\n   .W j caract j poids\n4.3.3. Algorithme Optimisation L\u2019algorithmeevaluation nous a permis de s\u00e9lectionner un ensemble de\ncomposantsr\u00e9pondant aux besoins de qualit\u00e9 d\u00e9finis par l\u2019utilisateur. A l\u2019aide de la\nproc\u00e9dure optimisation, nous allons trier ce vecteur de r\u00e9els d\u00e9signant le degr\u00e9 de\nqualit\u00e9 des composants retenus.\nProcedure Optimisation (Max : entier)\nEntr\u00e9e :i,j entier somme tableau [1.. Max] de r\u00e9els Sortie : somme tableau [1.. Max] de r\u00e9els tri\u00e9s par ordre d\u00e9croissant\ndebut\npour i de 1 \u00e0 Max -1 faire\ndebut\npour j de i +1 \u00e0 Max faire\ndebut\nsi (somme [i ] >somme[j] ) alors\ndebutsi\ntampon = somme [i ]\nsomme [i ]= somme [j ]\nsomme[j]=tampon\nFinsi\nFinpour\nFinpour\nFin"}, {"heading": "5. Conclusion", "text": "Notre travail repose sur trois approches. Nous avons construit un mod\u00e8le de qualit\u00e9 qui prend en compte les caract\u00e9ristiques d\u00e9finissant la fiabilit\u00e9 et la s\u00fbret\u00e9 du logiciel \u00e0 construire. Ensuite nous construit un mod\u00e8le de s\u00e9lection de composants logiciels dans une biblioth\u00e8que ou sur le net. Enfin nous avons d\u00e9fini une m\u00e9trique qui prend en compte le co\u00fbt financier et le temps d\u2019adaptation des composants s\u00e9lectionn\u00e9s. Cette m\u00e9trique \u00e9value et simule la qualit\u00e9 du composant en optimisant les param\u00e8tres dont le co\u00fbt financier et le temps. Cette approche est soutenue par l\u2019algorithme SelectCompo construit. Plusieurs aspects restent \u00e0 d\u00e9velopper. Il s\u2019agit de prendre en compte la s\u00e9lection de composants logiciels dans diverses biblioth\u00e8ques pour toute plateforme. Cela permettra de r\u00e9soudre le probl\u00e8me d\u2019interop\u00e9rabilit\u00e9 de ces composants sur diff\u00e9rentes plateformes. Dans les futurs travaux, nous pourrons tester la facilit\u00e9 d\u2019int\u00e9gration de ces composants sur une plateforme donn\u00e9e. Afin de r\u00e9soudre les difficult\u00e9s de d\u00e9ploiement de certains composants logiciels sur une combinaison de plateforme, de fourniture de service \u00e0 des utilisateurs ou des clients anonymes, nous pourrions orienter nos recherches vers les web services. Cela aura pour avantage de r\u00e9agir rapidement \u00e0 tous changement en s\u2019assurant de la fiabilit\u00e9 et la de s\u00e9curit\u00e9 de ces composants r\u00e9utilisables."}], "references": [], "referenceMentions": [], "year": 2017, "abstractText": "The large amount of information and the increasing complexity of applications constrain developers to have stand-alone and reusable components from libraries and component markets.Our approach consists in developing methods to evaluate the quality of the software component of these libraries, on the one hand and moreover to optimize the financial cost and the adaptation\u2019s time of these selected components. Our objective function defines a metric that maximizes the value of the software component quality by minimizing the financial cost and maintenance time. This model should make it possible to classify the components and order them in order to choose the most optimized. MOTS-CLES : d\u00e9veloppement de m\u00e9thode, r\u00e9utilisation, composants logiciels, qualit\u00e9 de composant", "creator": "Microsoft\u00ae Office Word 2007"}}}