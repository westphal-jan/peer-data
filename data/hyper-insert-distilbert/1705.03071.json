{"id": "1705.03071", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-May-2017", "title": "Geometry of Optimization and Implicit Regularization in Deep Learning", "abstract": "we progressively argue instinctively that the empirical optimization efficiency plays a crucial role principally in generalization of deep learning constrained models through efficient implicit regularization. collectively we do this by demonstrating that constraint generalization research ability overall is not predominantly controlled by network size criteria but rather by some other constraint implicit information control. theoretically we largely then gradually demonstrate how changing the empirical optimization procedure can improve implementation generalization, even although if actual software optimization quality is not affected.... we essentially do discover so substantially by studying the geometry of the parameter space of totally deep networks, and mentally devising an optimization quality algorithm attuned to this geometry.", "histories": [["v1", "Mon, 8 May 2017 20:12:08 GMT  (359kb,D)", "http://arxiv.org/abs/1705.03071v1", "This survey chapter was done as a part of Intel Collaborative Research institute for Computational Intelligence (ICRI-CI) \"Why &amp; When Deep Learning works -- looking inside Deep Learning\" compendium with the generous support of ICRI-CI. arXiv admin note: substantial text overlap witharXiv:1506.02617"]], "COMMENTS": "This survey chapter was done as a part of Intel Collaborative Research institute for Computational Intelligence (ICRI-CI) \"Why &amp; When Deep Learning works -- looking inside Deep Learning\" compendium with the generous support of ICRI-CI. arXiv admin note: substantial text overlap witharXiv:1506.02617", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["behnam neyshabur", "ryota tomioka", "ruslan salakhutdinov", "nathan srebro"], "accepted": false, "id": "1705.03071"}, "pdf": {"name": "1705.03071.pdf", "metadata": {"source": "CRF", "title": "Geometry of Optimization and Implicit Regularization in Deep Learning", "authors": ["Behnam Neyshabur", "Ryota Tomioka"], "emails": ["BNEYSHABUR@TTIC.EDU", "RYOTO@MICROSOFT.COM", "RSALAKHU@CS.CMU.EDU", "NATI@TTIC.EDU"], "sections": [{"heading": null, "text": "Keywords: Deep Learning, Implicit Regularization, Geometry of Optimization, Path-norm, PathSGD"}, {"heading": "1. Introduction", "text": "Central to any form of learning is an inductive bias that induces some sort of capacity control (i.e. restricts or encourages predictors to be \u201csimple\u201d in some way), which in turn allows for generalization. The success of learning then depends on how well the inductive bias captures reality (i.e. how expressive is the hypothesis class of \u201csimple\u201d predictors) relative to the capacity induced, as well as on the computational complexity of fitting a \u201csimple\u201d predictor to the training data.\nar X\niv :1\n70 5.\nLet us consider learning with feed-forward networks from this perspective. If we search for the weights minimizing the training error, we are essentially considering the hypothesis class of predictors representable with different weight vectors, typically for some fixed architecture. Capacity is then controlled by the size (number of weights) of the network1. Our justification for using such networks is then that many interesting and realistic functions can be represented by not-too-large (and hence bounded capacity) feed-forward networks. Indeed, in many cases we can show how specific architectures can capture desired behaviors. More broadly, any O(T ) time computable function can be captured by an O(T 2) sized network, and so the expressive power of such networks is indeed great (Sipser, 2006, Theorem 9.25).\nAt the same time, we also know that learning even moderately sized networks is computationally intractable\u2014not only is it NP-hard to minimize the empirical error, even with only three hidden units, but it is hard to learn small feed-forward networks using any learning method (subject to cryptographic assumptions). That is, even for binary classification using a network with a single hidden layer and a logarithmic (in the input size) number of hidden units, and even if we know the true targets are exactly captured by such a small network, there is likely no efficient algorithm that can ensure error better than 1/2 (Sherstov, 2006; Daniely et al., 2014)\u2014not if the algorithm tries to fit such a network, not even if it tries to fit a much larger network, and in fact no matter how the algorithm represents predictors. And so, merely knowing that some not-too-large architecture is excellent in expressing reality does not explain why we are able to learn using it, nor using an even larger network. Why is it then that we succeed in learning using multilayer feed-forward networks? Can we identify a property that makes them possible to learn? An alternative inductive bias?\nIn section 2, we make our first steps at shedding light on this question by going back to our understanding of network size as the capacity control at play. Our main observation, based on empirical experimentation with single-hidden-layer networks of increasing size (increasing number of hidden units), is that size does not behave as a capacity control parameter, and in fact there must be some other, implicit, capacity control at play. We suggest that this hidden capacity control might be the real inductive bias when learning with deep networks.\nRevisiting the choice of gradient descent, we recall that optimization is inherently tied to a choice of geometry or measure of distance, norm or divergence. Gradient descent for example is tied to the `2 norm as it is the steepest descent with respect to `2 norm in the parameter space, while coordinate descent corresponds to steepest descent with respect to the `1 norm and exp-gradient (multiplicative weight) updates is tied to an entropic divergence. Moreover, at least when the objective function is convex, convergence behavior is tied to the corresponding norms or potentials. For example, with gradient descent, or SGD, convergence speeds depend on the `2 norm of the optimum. The norm or divergence can be viewed as a regularizer for the updates. There is therefore also a strong link between regularization for optimization and regularization for learning: optimization may provide implicit regularization in terms of its corresponding geometry, and for ideal optimization performance the optimization geometry should be aligned with inductive bias driving the learning (Srebro et al., 2011).\nIs the `2 geometry on the weights the appropriate geometry for the space of deep networks? Or can we suggest a geometry with more desirable properties that would enable faster optimization and\n1. The exact correspondence depends on the activation function\u2014for hard thresholding activation the pseudodimension, and hence sample complexity, scales as O(S logS), where S is the number of weights in the network. With sigmoidal activation it is between \u2126(S2) and O(S4) (Anthony and Bartlett, 1999).\nperhaps also better implicit regularization? As suggested above, this question is also linked to the choice of an appropriate regularizer for deep networks.\nFocusing on networks with RELU activations in this section, we observe that scaling down the incoming edges to a hidden unit and scaling up the outgoing edges by the same factor yields an equivalent network computing the same function. Since predictions are invariant to such rescalings, it is natural to seek a geometry, and corresponding optimization method, that is similarly invariant.\nWe consider here a geometry inspired by max-norm regularization (regularizing the maximum norm of incoming weights into any unit) which seems to provide a better inductive bias compared to the `2 norm (weight decay) (Goodfellow et al., 2013; Srivastava et al., 2014). But to achieve rescaling invariance, we use not the max-norm itself, but rather the minimum max-norm over all rescalings of the weights. We discuss how this measure can be expressed as a \u201cpath regularizer\u201d and can be computed efficiently.\nWe therefore suggest a novel optimization method, Path-SGD, that is an approximate steepest descent method with respect to path regularization. Path-SGD is rescaling-invariant and we demonstrate that Path-SGD outperforms gradient descent and AdaGrad for classifications tasks on several benchmark datasets. This again demonstrates the importance of implicit regularization that is introduced by optimization.\nThis summary paper combines material previously presented by the authors at the 3rd International Conference on Learning Representations (ICLR), the 28th Conference on Learning Theory (COLT) and Advances in Neural Information Processing Systems (NIPS) 28, as well as Intel Collaborative Research Institutes retreats (Neyshabur et al., 2015a,b,c).\nNotations A feedforward neural network that computes a function f : RD \u2192 RC can be represented by a directed acyclic graph (DAG) G(V,E) with D input nodes vin[1], . . . , vin[D] \u2208 V , C output nodes vout[1], . . . , vout[C] \u2208 V , weights w : E \u2192 R and an activation function \u03c3 : R \u2192 R that is applied on the internal nodes (hidden units). We denote the function computed by this network as fG,w,\u03c3. In this paper we focus on RELU (REctified Linear Unit) activation function \u03c3RELU(x) = max{0, x}. We refer to the depth d of the network which is the length of the longest directed path in G. For any 0 \u2264 i \u2264 d, we define V iin to be the set of vertices with longest path of length i to an input unit and V iout is defined similarly for paths to output units. In layered networks V iin = V d\u2212i out is the set of hidden units in a hidden layer i."}, {"heading": "2. Implicit Regularization", "text": "Consider training a feed-forward network by finding the weights minimizing the training error. Specifically, we will consider a network with D real-valued inputs x = (x[1], . . . , x[D]), a single hidden layer withH rectified linear units, andC outputs y[1], . . . , y[k] where the weights are learned by minimizing a (truncated) soft-max cross entropy loss2 on n labeled training examples. The total number of weights is then H(C +D).\n2. When using soft-max cross-entropy, the loss is never exactly zero for correct predictions with finite margins/confidences. Instead, if the data is separable, in order to minimize the loss the weights need to be scaled up toward infinity and the cross entropy loss goes to zero, and a global minimum is never attained. In order to be able to say that we are actually reaching a zero loss solution, and hence a global minimum, we use a slightly modified soft-max which does not noticeably change the results in practice. This truncated loss returns the same exact value for wrong predictions or correct prediction with confidences less than a threshold but returns zero for correct predictions with large enough margins: Let {si}ki=1 be the scores for k possible labels and c be the correct labels. Then the soft-max cross-entropy loss can be written as `(s, c) = ln \u2211 i exp(si \u2212 sc) but we instead use the differentiable\nWhat happens to the training and test errors when we increase the network sizeH? The training error will necessarily decrease. The test error might initially decrease as the approximation error is reduced and the network is better able to capture the targets. However, as the size increases further, we loose our capacity control and generalization ability, and should start overfitting. This is the classic approximation-estimation tradeoff behavior.\nConsider, however, the results shown in Figure 1, where we trained networks of increasing size on the MNIST and CIFAR-10 datasets. Training was done using stochastic gradient descent with momentum and diminishing step sizes, on the training error and without any explicit regularization. As expected, both training and test error initially decrease. More surprising is that if we increase the size of the network past the size required to achieve zero training error, the test error continues decreasing! This behavior is not at all predicted by, and even contrary to, viewing learning as fitting a hypothesis class controlled by network size. For example for MNIST, 32 units are enough to attain zero training error. When we allow more units, the network is not fitting the training data any better, but the estimation error, and hence the generalization error, should increase with the increase in capacity. However, the test error goes down. In fact, as we add more and more parameters, even beyond the number of training examples, the generalization error does not go up.\nloss function \u02c6\u0300(s, c) = ln \u2211\ni f(si \u2212 sc) where f(x) = exp(x) for x \u2265 \u221211 and f(x) = exp(\u221211)[x + 13] 2 +/4\notherwise. Therefore, we only deviate from the soft-max cross-entropy when the margin is more than 11, at which point the effect of this deviation is negligible (we always have \u2223\u2223\u2223`(s, c)\u2212 \u02c6\u0300(s, c)\u2223\u2223\u2223 \u2264 0.000003k)\u2014if there are any actual errors the behavior on them would completely dominate correct examples with margin over 11, and if there are no errors we are just capping the amount by which we need to scale up the weights.\nWhat is happening here? A possible explanation is that the optimization is introducing some implicit regularization. That is, we are implicitly trying to find a solution with small \u201ccomplexity\u201d, for some notion of complexity, perhaps norm. This can explain why we do not overfit even when the number of parameters is huge. Furthermore, increasing the number of units might allow for solutions that actually have lower \u201ccomplexity\u201d, and thus generalization better. Perhaps an ideal then would be an infinite network controlled only through this hidden complexity.\nWe want to emphasize that we are not including any explicit regularization, neither as an explicit penalty term nor by modifying optimization through, e.g., drop-outs, weight decay, or with one-pass stochastic methods. We are using a stochastic method, but we are running it to convergence\u2014 we achieve zero surrogate loss and zero training error. In fact, we also tried training using batch conjugate gradient descent and observed almost identical behavior. But it seems that even still, we are not getting to some random global minimum\u2014indeed for large networks the vast majority of the many global minima of the training error would horribly overfit. Instead, the optimization is directing us toward a \u201clow complexity\u201d global minimum.\nWe have argued that the implicit regularization is due to the optimization. It is therefore expected that different optimization methods introduce different implicit regularizations which leads to different generalization properties. In an attempt to find an optimization method with better generalization properties, we recall that the optimization is also tied to a choice of geometry/distance measure in the parameter space. We look into the desirable properties of a geometry for neural networks and suggest an optimization algorithm that is tied to that geometry."}, {"heading": "3. The Geometry of Optimization: Rescaling and Unbalanceness", "text": "In this section, we look at the behavior of the Euclidean geometry under rescaling and unbalanceness. One of the special properties of RELU activation function is non-negative homogeneity. That is, for any scalar c \u2265 0 and any x \u2208 R, we have \u03c3RELU(c \u00b7 x) = c \u00b7 \u03c3RELU(x). This interesting property allows the network to be rescaled without changing the function computed by the network. We define the rescaling function \u03c1c,v(w), such that given the weights of the network w : E \u2192 R, a constant c > 0, and a node v, the rescaling function multiplies the incoming edges and divides the outgoing edges of v by c. That is, \u03c1c,v(w) maps w to the weights w\u0303 for the rescaled network, where for any (u1 \u2192 u2) \u2208 E:\nw\u0303(u1\u2192u2) =  c.w(u1\u2192u2) u2 = v, 1 cw(u1\u2192u2) u1 = v,\nw(u1\u2192u2) otherwise.\n(1)\nIt is easy to see that the rescaled network computes the same function, i.e. fG,w,\u03c3RELU = fG,\u03c1c,v(w),\u03c3RELU . We say that the two networks with weights w and w\u0303 are rescaling equivalent denoted by w \u223c w\u0303 if and only if one of them can be transformed to another by applying a sequence of rescaling functions \u03c1c,v.\nGiven a training set S = {(x1, yn), . . . , (xn, yn)}, our goal is to minimize the following objective function:\nL(w) = 1\nn n\u2211 i=1 `(fw(xi), yi). (2)\nLet w(t) be the weights at step t of the optimization. We consider update step of the following form w(t+1) = w(t) + \u2206w(t+1). For example, for gradient descent, we have \u2206w(t+1) = \u2212\u03b7\u2207L(w(t)), where \u03b7 is the step-size. In the stochastic setting, such as SGD or mini-batch gradient descent, we calculate the gradient on a small subset of the training set.\nSince rescaling equivalent networks compute the same function, it is desirable to have an update rule that is not affected by rescaling. We call an optimization method rescaling invariant if the updates of rescaling equivalent networks are rescaling equivalent. That is, if we start at either one of the two rescaling equivalent weight vectors w\u0303(0) \u223c w(0), after applying t update steps separately on w\u0303(0) and w(0), they will remain rescaling equivalent and we have w\u0303(t) \u223c w(t).\nUnfortunately, gradient descent is not rescaling invariant. The main problem with the gradient updates is that scaling down the weights of an edge will also scale up the gradient which, as we see later, is exactly the opposite of what is expected from a rescaling invariant update.\nFurthermore, gradient descent performs very poorly on \u201cunbalanced\u201d networks. We say that a network is balanced if the norm of incoming weights to different units are roughly the same or within a small range. For example, Figure a shows a huge gap in the performance of SGD initialized with a randomly generated balanced networkw(0), when training on MNIST, compared to a network initialized with unbalanced weights w\u0303(0). Here w\u0303(0) is generated by applying a sequence of random rescaling functions on w(0) (and therefore w(0) \u223c w\u0303(0)).\nIn an unbalanced network, gradient descent updates could blow up the smaller weights, while keeping the larger weights almost unchanged. This is illustrated in Figure b. If this were the only issue, one could scale down all the weights after each update. However, in an unbalanced network, the relative changes in the weights are also very different compared to a balanced network. For\nexample, Figure c shows how two rescaling equivalent networks could end up computing a very different function after only a single update."}, {"heading": "4. Magnitude/Scale measures for deep networks", "text": "Following Neyshabur et al. (2015b), we consider the grouping of weights going into each node of the network. This forms the following generic group-norm type regularizer, parametrized by 1 \u2264 p, q \u2264 \u221e:\n\u00b5p,q(w) = \u2211 v\u2208V  \u2211 (u\u2192v)\u2208E \u2223\u2223w(u\u2192v)\u2223\u2223p q/p  1/q . (3)\nTwo simple cases of above group-norm are p = q = 1 and p = q = 2 that correspond to overall `1 regularization and weight decay respectively. Another form of regularization that is shown to be very effective in RELU networks is the max-norm regularization, which is the maximum over all units of norm of incoming edge to the unit3 (Goodfellow et al., 2013; Srivastava et al., 2014). The max-norm correspond to \u201cper-unit\u201d regularization when we set q = \u221e in equation (4) and can be written in the following form:\n\u00b5p,\u221e(w) = sup v\u2208V  \u2211 (u\u2192v)\u2208E \u2223\u2223w(u\u2192v)\u2223\u2223p 1/p (4)\nWeight decay is probably the most commonly used regularizer. On the other hand, per-unit regularization might not seem ideal as it is very extreme in the sense that the value of regularizer corresponds to the highest value among all nodes. However, the situation is very different for networks with RELU activations (and other activation functions with non-negative homogeneity property). In these cases, per-unit `2 regularization has shown to be very effective (Srivastava et al., 2014). The main reason could be because RELU networks can be rebalanced in such a way that all hidden units have the same norm. Hence, per-unit regularization will not be a crude measure anymore.\nSince \u00b5p,\u221e is not rescaling invariant and the values of the scale measure are different for rescaling equivalent networks, it is desirable to look for the minimum value of a regularizer among all rescaling equivalent networks. Surprisingly, for a feed-forward network, the minimum `p per-unit regularizer among all rescaling equivalent networks can be efficiently computed by a single forward step. To see this, we consider the vector \u03c0(w), the path vector, where the number of coordinates of \u03c0(w) is equal to the total number of paths from the input to output units and each coordinate of \u03c0(w) is the equal to the product of weights along a path from an input nodes to an output node. The `p-path regularizer is then defined as the `p norm of \u03c0(w) (Neyshabur et al., 2015b):\n\u03c6p(w) = \u2016\u03c0(w)\u2016p =  \u2211 vin[i] e1\u2192v1 e2\u2192v2... ed\u2192vout[j] \u2223\u2223\u2223\u2223\u2223 d\u220f k=1 wek \u2223\u2223\u2223\u2223\u2223 p  1/p\n(5)\n3. This definition of max-norm is a bit different than the one used in the context of matrix factorization (Srebro and Shraibman, 2005). The later is similar to the minimum upper bound over `2 norm of both outgoing edges from the input units and incoming edges to the output units in a two layer feed-forward network.\nThe following Lemma establishes that the `p-path regularizer corresponds to the minimum over all equivalent networks of the per-unit `p norm:\nLemma 4.1 (Neyshabur et al. (2015b)) \u03c6p(w) = min w\u0303\u223cw\n( \u00b5p,\u221e(w\u0303) )d The definition (5) of the `p-path regularizer involves an exponential number of terms. But it can be computed efficiently by dynamic programming in a single forward step using the following equivalent form as nested sums:\n\u03c6p(w) =  \u2211 (vd\u22121\u2192vout[j])\u2208E \u2223\u2223w(vd\u22121\u2192vout[j])\u2223\u2223p \u2211 (vd\u22122\u2192vd\u22121)\u2208E \u00b7 \u00b7 \u00b7 \u2211 (vin[i]\u2192v1)\u2208E \u2223\u2223w(vin[i]\u2192v1)\u2223\u2223p 1/p\nA straightforward consequence of Lemma 4.1 is that the `p path-regularizer \u03c6p is invariant to rescaling, i.e. for any w\u0303 \u223c w, \u03c6p(w\u0303) = \u03c6p(w)."}, {"heading": "5. Path-SGD: An Approximate Path-Regularized Steepest Descent", "text": "Motivated by empirical performance of max-norm regularization and the fact that path-regularizer is invariant to rescaling, we are interested in deriving the steepest descent direction with respect to the path regularizer \u03c6p(w):\nw(t+1) = arg min w\n\u03b7 \u2329 \u2207L(w(t)), w \u232a + 1\n2 \u2225\u2225\u2225\u03c0(w)\u2212 \u03c0(w(t))\u2225\u2225\u22252 p\n(6)\n= arg min w\n\u03b7 \u2329 \u2207L(w(t)), w \u232a +  \u2211 vin[i] e1\u2192v1 e2\u2192v2... ed\u2192vout[j] ( d\u220f k=1 wek \u2212 d\u220f k=1 w(t)ek ) )p 2/p\n= arg min w J (t)(w)\nThe steepest descent step (6) is hard to calculate exactly. Instead, we will update each coordinate we independently (and synchronously) based on (6). That is:\nw(t+1)e = arg minwe J (t)(w) s.t. \u2200e\u2032 6=e we\u2032 = w (t) e\u2032 (7)\nTaking the partial derivative with respect to we and setting it to zero we obtain:\n0 = \u03b7 \u2202L\n\u2202we (w(t))\u2212\n( we \u2212 w(t)e ) \u2211 vin[i]\u00b7\u00b7\u00b7 e\u2192...vout[j] \u220f ek 6=e \u2223\u2223\u2223w(t)e \u2223\u2223\u2223p  2/p\nwhere vin[i] \u00b7 \u00b7 \u00b7 e\u2192 . . . vout[j] denotes the paths from any input unit i to any output unit j that includes e. Solving for we gives us the following update rule:\nw\u0302(t+1)e = w (t) e \u2212\n\u03b7\n\u03b3p(w(t), e)\n\u2202L \u2202w (w(t)) (8)\nwhere \u03b3p(w, e) is given as\n\u03b3p(w, e) =  \u2211 vin[i]\u00b7\u00b7\u00b7 e\u2192...vout[j] \u220f ek 6=e |wek | p  2/p\n(9)\nWe call the optimization using the update rule (8) path-normalized gradient descent. When used in stochastic settings, we refer to it as Path-SGD.\nNow that we know Path-SGD is an approximate steepest descent with respect to the pathregularizer, we can ask whether or not this makes Path-SGD a rescaling invariant optimization method. The next theorem proves that Path-SGD is indeed rescaling invariant.\nTheorem 5.1 Path-SGD is rescaling invariant.\nProof It is sufficient to prove that using the update rule (8), for any c > 0 and any v \u2208 E, if w\u0303(t) = \u03c1c,v(w\n(t)), then w\u0303(t+1) = \u03c1c,v(w(t+1)). For any edge e in the network, if e is neither incoming nor outgoing edge of the node v, then w\u0303(e) = w(e), and since the gradient is also the same for edge e we have w\u0303(t+1)e = w (t+1) e . However, if e is an incoming edge to v, we have that w\u0303(t)(e) = cw(t)(e). Moreover, since the outgoing edges of v are divided by c, we get \u03b3p(w\u0303(t), e) = \u03b3p(w(t),e)\nc2 and \u2202L\u2202we (w\u0303 (t)) = \u2202Lc\u2202we (w (t)). Therefore,\nw\u0303(t+1)e = cw (t) e \u2212\nc2\u03b7\n\u03b3p(w(t), e)\n\u2202L\nc\u2202we (w(t))\n= c ( w(t) \u2212 \u03b7\n\u03b3p(w(t), e)\n\u2202L\n\u2202we (w(t))\n) = cw(t+1)e .\nA similar argument proves the invariance of Path-SGD update rule for outgoing edges of v. Therefore, Path-SGD is rescaling invariant.\nEfficient Implementation: The Path-SGD update rule (8), in the way it is written, needs to consider all the paths, which is exponential in the depth of the network. However, it can be calculated in a time that is no more than a forward-backward step on a single data point. That is, in a minibatch setting with batch size B, if the backpropagation on the mini-batch can be done in time BT , the running time of the Path-SGD on the mini-batch will be roughly (B + 1)T \u2013 a very moderate runtime increase with typical mini-batch sizes of hundreds or thousands of points. Algorithm 1 shows an efficient implementation of the Path-SGD update rule.\nWe next compare Path-SGD to other optimization methods in both balanced and unbalanced settings."}, {"heading": "6. Experiments on Path-SGD", "text": "We compare `2-Path-SGD to two commonly used optimization methods in deep learning, SGD and AdaGrad. We conduct our experiments on four common benchmark datasets: the standard MNIST dataset of handwritten digits (LeCun et al., 1998); CIFAR-10 and CIFAR-100 datasets\nData Set Dimensionality Classes Training Set Test Set\nCIFAR-10 3072 (32\u00d7 32 color) 10 50000 10000 CIFAR-100 3072 (32\u00d7 32 color) 100 50000 10000\nMNIST 784 (28\u00d7 28 grayscale) 10 60000 10000 SVHN 3072 (32\u00d7 32 color) 10 73257 26032\nof tiny images of natural scenes (Krizhevsky and Hinton, 2009); and Street View House Numbers (SVHN) dataset containing color images of house numbers collected by Google Street View (Netzer et al., 2011). Details of the datasets are shown in Table 1.\nIn all of our experiments, we trained feed-forward networks with two hidden layers, each containing 4000 hidden units. We used mini-batches of size 100 and the step-size of 10\u2212\u03b1, where \u03b1 is an integer between 0 and 10. To choose \u03b1, for each dataset, we considered the validation errors over the validation set (10000 randomly chosen points that are kept out during the initial training) and picked the one that reaches the minimum error faster. We then trained the network over the entire training set. All the networks were trained both with and without dropout. When training with dropout, at each update step, we retained each unit with probability 0.5.\nThe optimization results are shown in Figure 3. For each of the four datasets, the plots for objective function (cross-entropy), the training error and the test error are shown from left to right where in each plot the values are reported on different epochs during the optimization. The dropout is used for the experiments on CIFAR-100 and SVHN. Please see Neyshabur et al. (2015a) for a more complete set of experimental results.\nWe can see in Figure 3 that not only does Path-SGD often get to the same value of objective function, training and test error faster, but also the plots for test errors demonstrate that implicit regularization due to steepest descent with respect to path-regularizer leads to a solution that generalizes better. This provides further evidence on the role of implicit regularization in deep learning.\nThe results suggest that Path-SGD outperforms SGD and AdaGrad in two different ways. First, it can achieve the same accuracy much faster and second, the implicit regularization by Path-SGD leads to a local minima that can generalize better even when the training error is zero. This can be better analyzed by looking at the plots for more number of epochs which we have provided in Neyshabur et al. (2015a). We should also point that Path-SGD can be easily combined with\nunbalanced setting, we first initialized the weights to be the same as the balanced weights. We then picked 2000 hidden units randomly with replacement. For each unit, we multiplied its incoming edge and divided its outgoing edge by 10c, where c was chosen randomly from log-normal distribution. Although we proved that Path-SGD updates are the same for balanced and unbalanced initializations, to verify that despite numerical issues they are indeed identical, we trained Path-SGD with both balanced and unbalanced initializations. Since the curves were exactly the same we only show a single curve. Best viewed in color.\nAdaGrad or Adam to take advantage of the adaptive stepsize or used together with a momentum term. This could potentially perform even better compare to Path-SGD."}, {"heading": "7. Discussion", "text": "We demonstrated the implicit regularization in deep learning through experiments and discussed the importance of geometry of optimization in finding a \u201clow complexity\u201d solution. Based on that, we revisited the choice of the Euclidean geometry on the weights of RELU networks, suggested an alternative optimization method approximately corresponding to a different geometry, and showed that using such an alternative geometry can be beneficial. In this work we show proof-of-concept success, and we expect Path-SGD to be beneficial also in large-scale training for very deep convolutional networks. Combining Path-SGD with AdaGrad, with momentum or with other optimization heuristics might further enhance results.\nAlthough we do believe Path-SGD is a very good optimization method, and is an easy plug-in for SGD, we hope this work will also inspire others to consider other geometries, other regularizers and perhaps better, update rules. A particular property of Path-SGD is its rescaling invariance, which we argue is appropriate for RELU networks. But Path-SGD is certainly not the only rescaling invariant update possible, and other invariant geometries might be even better.\nFinally, we choose to use steepest descent because of its simplicity of implementation. A better choice might be mirror descent with respect to an appropriate potential function, but such a construction seems particularly challenging considering the non-convexity of neural networks."}, {"heading": "Acknowledgments", "text": "Research was partially funded by NSF award IIS-1302662 and Intel ICRI-CI."}], "references": [{"title": "Neural network learning: Theoretical foundations", "author": ["Martin Anthony", "Peter L Bartlett"], "venue": null, "citeRegEx": "Anthony and Bartlett.,? \\Q1999\\E", "shortCiteRegEx": "Anthony and Bartlett.", "year": 1999}, {"title": "From average case complexity to improper learning", "author": ["Amit Daniely", "Nati Linial", "Shai Shalev-Shwartz"], "venue": null, "citeRegEx": "Daniely et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Daniely et al\\.", "year": 2014}, {"title": "Learning multiple layers of features from tiny images", "author": ["Alex Krizhevsky", "Geoffrey Hinton"], "venue": "Computer Science Department,", "citeRegEx": "Krizhevsky and Hinton.,? \\Q2009\\E", "shortCiteRegEx": "Krizhevsky and Hinton.", "year": 2009}, {"title": "Gradient-based learning applied to document recognition", "author": ["Yann LeCun", "L\u00e9on Bottou", "Yoshua Bengio", "Patrick Haffner"], "venue": "Proceedings of the IEEE,", "citeRegEx": "LeCun et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1998}, {"title": "Reading digits in natural images with unsupervised feature learning", "author": ["Yuval Netzer", "Tao Wang", "Adam Coates", "Alessandro Bissacco", "Bo Wu", "Andrew Y Ng"], "venue": "In NIPS workshop on deep learning and unsupervised feature learning,", "citeRegEx": "Netzer et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Netzer et al\\.", "year": 2011}, {"title": "Path-sgd: Path-normalized optimization in deep neural networks", "author": ["Behnam Neyshabur", "Ruslan R Salakhutdinov", "Nati Srebro"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Neyshabur et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neyshabur et al\\.", "year": 2015}, {"title": "Norm-based capacity control in neural networks", "author": ["Behnam Neyshabur", "Ryota Tomioka", "Nathan Srebro"], "venue": "In The 28th Conference on Learning Theory,", "citeRegEx": "Neyshabur et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neyshabur et al\\.", "year": 2015}, {"title": "In search of the real inductive bias: On the role of implicit regularization in deep learning", "author": ["Behnam Neyshabur", "Ryota Tomioka", "Nathan Srebro"], "venue": "International Conference on Learning Representations (ICLR) workshop track,", "citeRegEx": "Neyshabur et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Neyshabur et al\\.", "year": 2015}, {"title": "Cryptographic hardness for learning intersections of halfspaces", "author": [], "venue": "In Foundations of Computer Science,", "citeRegEx": "Sherstov.,? \\Q2006\\E", "shortCiteRegEx": "Sherstov.", "year": 2006}, {"title": "Introduction to the Theory of Computation", "author": ["Michael Sipser"], "venue": "Thomson Course Technology,", "citeRegEx": "Sipser.,? \\Q2006\\E", "shortCiteRegEx": "Sipser.", "year": 2006}, {"title": "Rank, trace-norm and max-norm", "author": ["Nathan Srebro", "Adi Shraibman"], "venue": "In Learning Theory,", "citeRegEx": "Srebro and Shraibman.,? \\Q2005\\E", "shortCiteRegEx": "Srebro and Shraibman.", "year": 2005}, {"title": "On the universality of online mirror descent", "author": ["Nathan Srebro", "Karthik Sridharan", "Ambuj Tewari"], "venue": "In Advances in neural information processing systems,", "citeRegEx": "Srebro et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Srebro et al\\.", "year": 2011}, {"title": "Dropout: A simple way to prevent neural networks from overfitting", "author": ["Nitish Srivastava", "Geoffrey Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "Srivastava et al\\.,? \\Q1929\\E", "shortCiteRegEx": "Srivastava et al\\.", "year": 1929}], "referenceMentions": [{"referenceID": 8, "context": "That is, even for binary classification using a network with a single hidden layer and a logarithmic (in the input size) number of hidden units, and even if we know the true targets are exactly captured by such a small network, there is likely no efficient algorithm that can ensure error better than 1/2 (Sherstov, 2006; Daniely et al., 2014)\u2014not if the algorithm tries to fit such a network, not even if it tries to fit a much larger network, and in fact no matter how the algorithm represents predictors.", "startOffset": 305, "endOffset": 343}, {"referenceID": 1, "context": "That is, even for binary classification using a network with a single hidden layer and a logarithmic (in the input size) number of hidden units, and even if we know the true targets are exactly captured by such a small network, there is likely no efficient algorithm that can ensure error better than 1/2 (Sherstov, 2006; Daniely et al., 2014)\u2014not if the algorithm tries to fit such a network, not even if it tries to fit a much larger network, and in fact no matter how the algorithm represents predictors.", "startOffset": 305, "endOffset": 343}, {"referenceID": 11, "context": "There is therefore also a strong link between regularization for optimization and regularization for learning: optimization may provide implicit regularization in terms of its corresponding geometry, and for ideal optimization performance the optimization geometry should be aligned with inductive bias driving the learning (Srebro et al., 2011).", "startOffset": 324, "endOffset": 345}, {"referenceID": 0, "context": "With sigmoidal activation it is between \u03a9(S) and O(S) (Anthony and Bartlett, 1999).", "startOffset": 54, "endOffset": 82}, {"referenceID": 5, "context": "Magnitude/Scale measures for deep networks Following Neyshabur et al. (2015b), we consider the grouping of weights going into each node of the network.", "startOffset": 53, "endOffset": 78}, {"referenceID": 10, "context": "This definition of max-norm is a bit different than the one used in the context of matrix factorization (Srebro and Shraibman, 2005).", "startOffset": 104, "endOffset": 132}, {"referenceID": 5, "context": "1 (Neyshabur et al. (2015b)) \u03c6p(w) = min w\u0303\u223cw ( \u03bcp,\u221e(w\u0303) )d", "startOffset": 3, "endOffset": 28}, {"referenceID": 3, "context": "We conduct our experiments on four common benchmark datasets: the standard MNIST dataset of handwritten digits (LeCun et al., 1998); CIFAR-10 and CIFAR-100 datasets", "startOffset": 111, "endOffset": 131}, {"referenceID": 2, "context": "of tiny images of natural scenes (Krizhevsky and Hinton, 2009); and Street View House Numbers (SVHN) dataset containing color images of house numbers collected by Google Street View (Netzer et al.", "startOffset": 33, "endOffset": 62}, {"referenceID": 4, "context": "of tiny images of natural scenes (Krizhevsky and Hinton, 2009); and Street View House Numbers (SVHN) dataset containing color images of house numbers collected by Google Street View (Netzer et al., 2011).", "startOffset": 182, "endOffset": 203}, {"referenceID": 2, "context": "of tiny images of natural scenes (Krizhevsky and Hinton, 2009); and Street View House Numbers (SVHN) dataset containing color images of house numbers collected by Google Street View (Netzer et al., 2011). Details of the datasets are shown in Table 1. In all of our experiments, we trained feed-forward networks with two hidden layers, each containing 4000 hidden units. We used mini-batches of size 100 and the step-size of 10\u2212\u03b1, where \u03b1 is an integer between 0 and 10. To choose \u03b1, for each dataset, we considered the validation errors over the validation set (10000 randomly chosen points that are kept out during the initial training) and picked the one that reaches the minimum error faster. We then trained the network over the entire training set. All the networks were trained both with and without dropout. When training with dropout, at each update step, we retained each unit with probability 0.5. The optimization results are shown in Figure 3. For each of the four datasets, the plots for objective function (cross-entropy), the training error and the test error are shown from left to right where in each plot the values are reported on different epochs during the optimization. The dropout is used for the experiments on CIFAR-100 and SVHN. Please see Neyshabur et al. (2015a) for a more complete set of experimental results.", "startOffset": 34, "endOffset": 1291}, {"referenceID": 2, "context": "of tiny images of natural scenes (Krizhevsky and Hinton, 2009); and Street View House Numbers (SVHN) dataset containing color images of house numbers collected by Google Street View (Netzer et al., 2011). Details of the datasets are shown in Table 1. In all of our experiments, we trained feed-forward networks with two hidden layers, each containing 4000 hidden units. We used mini-batches of size 100 and the step-size of 10\u2212\u03b1, where \u03b1 is an integer between 0 and 10. To choose \u03b1, for each dataset, we considered the validation errors over the validation set (10000 randomly chosen points that are kept out during the initial training) and picked the one that reaches the minimum error faster. We then trained the network over the entire training set. All the networks were trained both with and without dropout. When training with dropout, at each update step, we retained each unit with probability 0.5. The optimization results are shown in Figure 3. For each of the four datasets, the plots for objective function (cross-entropy), the training error and the test error are shown from left to right where in each plot the values are reported on different epochs during the optimization. The dropout is used for the experiments on CIFAR-100 and SVHN. Please see Neyshabur et al. (2015a) for a more complete set of experimental results. We can see in Figure 3 that not only does Path-SGD often get to the same value of objective function, training and test error faster, but also the plots for test errors demonstrate that implicit regularization due to steepest descent with respect to path-regularizer leads to a solution that generalizes better. This provides further evidence on the role of implicit regularization in deep learning. The results suggest that Path-SGD outperforms SGD and AdaGrad in two different ways. First, it can achieve the same accuracy much faster and second, the implicit regularization by Path-SGD leads to a local minima that can generalize better even when the training error is zero. This can be better analyzed by looking at the plots for more number of epochs which we have provided in Neyshabur et al. (2015a). We should also point that Path-SGD can be easily combined with", "startOffset": 34, "endOffset": 2147}], "year": 2017, "abstractText": "We argue that the optimization plays a crucial role in generalization of deep learning models through implicit regularization. We do this by demonstrating that generalization ability is not controlled by network size but rather by some other implicit control. We then demonstrate how changing the empirical optimization procedure can improve generalization, even if actual optimization quality is not affected. We do so by studying the geometry of the parameter space of deep networks, and devising an optimization algorithm attuned to this geometry.", "creator": "LaTeX with hyperref package"}}}