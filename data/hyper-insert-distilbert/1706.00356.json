{"id": "1706.00356", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "1-Jun-2017", "title": "Enhancing workflow-nets with data for trace completion", "abstract": "meanwhile the growing adoption of it - implemented systems processes for detailed modeling and better executing ( business ) running processes or services has thrust influenced the scientific field investigation towards techniques and hardware tools also which support more complex forms specifically of performance process software analysis. eventually many several of them, such as conformance fault checking, process design alignment, remote mining procedure and enhancement, can rely on complete direct observation of past ( highly tracked and logged ) logical executions. in many practical real cases, however, the lack of human presence or it - programming support on all the estimation steps given of process decision execution, engineering as well as computational information hiding and abstraction of model and data, result basically in dangerously incomplete log file information disposed of evaluating both data and activities. this paper largely tackles has the issue of periodically automatically repairing traces with apparently missing information by some notably considering not only activities precisely but often also data manipulated regularly by them. our technique recasts such things a problem in considering a reachability problem and provides an encoding in an automated action language which still allows programmers to virtually use any state - of - science the - war art planning to rapidly return solutions.", "histories": [["v1", "Thu, 1 Jun 2017 15:46:47 GMT  (222kb,D)", "http://arxiv.org/abs/1706.00356v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["riccardo de masellis", "chiara di francescomarino", "chiara ghidini", "sergio tessaris"], "accepted": false, "id": "1706.00356"}, "pdf": {"name": "1706.00356.pdf", "metadata": {"source": "CRF", "title": "Enhancing workflow-nets with data for trace completion", "authors": ["Riccardo De Masellis", "Chiara Di Francescomarino", "Chiara Ghidini", "Sergio Tessaris"], "emails": ["r.demasellis@fbk.eu", "dfmchiara@fbk.eu", "ghidini@fbk.eu", "tessaris@inf.unibz.it"], "sections": [{"heading": "1 Introduction", "text": "The use of IT systems for supporting business activities has brought to a large diffusion of process mining techniques and tools that offer business analysts the possibility to observe the current process execution, identify deviations from themodel, perform individual and aggregated analysis on current and past executions.\nAccording to the process mining manifesto, all these techniques and tools can be grouped in three basic types: process discovery, conformance checking and process enhancement (see Figure 1), and require in input an event log and, for conformance checking and enhancement, a (process) model. A log, usually described in the IEEE standard XES format3, is a set of execution traces (or cases) each of\nwhich is an ordered sequence of events carrying a payload as a set of attribute-value pairs. Process models instead provide a description of the scenario at hand and can be constructed using one of the available Business Process Modeling Languages, such as BPMN, YAWL and Declare.\n3 http://www.xes-standard.org/\nar X\niv :1\n70 6.\n00 35\n6v 1\n[ cs\n.A I]\n1 J\nun 2\n01 7\nEvent logs are therefore a crucial ingredient to the accomplishment of process mining. Unfortunately, a number of difficulties may hamper the availability of event logs. Among these are partial event logs, where the execution traces may bring only partial information in terms of which process activities have been executed and what data or artefacts they produced. Thus repairing incomplete execution traces by reconstructing the missing entries becomes an important task to enable process mining in full, as noted in recent works such as [17,8]. While these works deserve a praise for having motivated the importance of trace repair and having provided some basic techniques for reconstructing missing entries using the knowledge captured in process models, they all focus on event logs (and process models) of limited expressiveness. In fact, they all provide techniques for the reconstruction of control flows, thus completely ignoring the data flow component. This is a serious limitation, given the growing practical and theoretical efforts to extend business process languages with the capability to model complex data objects, along with the traditional control flow perspective [6].\nIn this paper we show how to exploit state-of-the-art planning techniques to deal with the repair of data-aware event logs in the presence of imperative process models. Specifically we will focus on the well established Workflow Nets [20], a particular class of Petri nets that provides the formal foundations of several process models, of the YAWL language and have become one of the standard ways to model and analyze workflows. In particular we provide: 1. a modeling language DAW-net, an extension of the workflow nets with data for-\nmalism introduced in [18] so to be able to deal with even more expressive data (Section 3); 2. a recast of data aware trace repair as a reachability problem in DAW-net (Section C); 3. a sound and complete encoding of reachability in DAW-net in a planning problem\nso to be able to deal with trace repair using planning (Section 5). The solution of the problem are all and only the repairs of the partial trace compliant with the DAW-net model. The advantage of using automated planning techniques is that we can exploit the underlying logic language to ensure that generated plans conform to the observed traces without resorting to ad hoc algorithms for the specific repair problem. The theoretical investigation presented in this work provides an important step forward towards the exploitation of mature planning techniques for the trace repair w.r.t. data-aware processes."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 The Workflow Nets modeling language", "text": "Petri Nets (PN) is a modeling language for the description of distributed systems that has widely been applied to the description and analysis of business processes [1].The classical PN is a directed bipartite graph with two node types, called places and transitions, connected via directed arcs. Connections between two nodes of the same type are not allowed. Definition 1 (Petri Net). A Petri Net is a triple \u3008P, T, F \u3009 where P is a set of places; T is a set of transitions; F \u2286 (P \u00d7 T ) \u222a (T \u00d7 P ) is the flow relation describing the arcs between places and transitions (and between transitions and places).\nThe preset of a transition t is the set of its input places: \u2022t = {p \u2208 P | (p, t) \u2208 F}. The postset of t is the set of its output places: t\u2022 = {p \u2208 P | (t, p) \u2208 F}. Definitions of preand postsets of places are analogous.\nPlaces in a PN may contain a discrete number of marks called tokens. Any distribution of tokens over the places, formally represented by a totalmappingM : P 7\u2192 N, represents a configuration of the net called a marking. PNs come with a graphical notation where places are represented by means of circles, transitions by means of rectangles and tokens by means of full\ndots within places. Figure 2 depicts a PN with a marking M(p0) = 2, M(p1) = 0, M(p2) = 1. The preset and postset of t are {p0, p1} and {p2}, respectively.\nProcess tasks are modeled in PNs as transitions while arcs and places constraint their ordering. For instance, the process in Figure 34 exemplifies how PNs can be used to model parallel and mutually exclusive choices, typical of business processes: sequences T2;T4-T3;T5 and transitions T6-T7-T8 are indeed placed on mutually exclusive paths. Transitions T10 and T11 are instead placed on parallel paths. Finally, T9 is needed to prevent connections between nodes of the same type.\nThe expressivity of PNs exceeds, in the general case, what is needed to model business processes, which typically have a well-defined starting point and a well-defined ending point. This imposes syntactic restrictions on PNs, that result in the following definition of a workflow net (WF-net) [1].\nDefinition 2 (WF-net). A PN \u3008P, T, F \u3009 is a WF-net if it has a single source place start, a single sink place end, and every place and every transition is on a path from start to end, i.e., for all n \u2208 P \u222a T , (start, n) \u2208 F \u2217 and (n, end) \u2208 F \u2217, where F \u2217 is the reflexive transitive closure of F .\nAmarking in a WF-net represents the workflow state of a single case. The semantics of a PN/WF-net, and in particular the notion of valid firing, defines how transitions route tokens through the net so that they correspond to a process execution.\nDefinition 3 (Valid Firing). A firing of a transition t \u2208 T from M to M \u2032 is valid, in symbolsM t\u2192M \u2032, iff\n4 For the sake of simplicity we only focus here on the, so-called, happy path, that is the successful granting of the loan.\n1. t is enabled inM , i.e., {p \u2208 P |M(p) > 0} \u2287 \u2022t; and 2. the markingM \u2032 is such that for every p \u2208 P :\nM \u2032(p) =  M(p)\u2212 1 if p \u2208 \u2022t \\ t\u2022\nM(p) + 1 if p \u2208 t\u2022 \\ \u2022t M(p) otherwise\nCondition 1. states that a transition is enabled if all its input places contain at least one token; 2. states that when t fires it consumes one token from each of its input places and produces one token in each of its output places.\nA case of aWF-Net is a sequence of valid firingsM0 t1\u2192M1,M1 t2\u2192M2, . . . ,Mk\u22121 tk\u2192\nMk whereM0 is the marking indicating that there is a single token in start.\nDefinition 4 (k-safeness). A marking of a PN is k-safe if the number of tokens in all places is at most k. A PN is k-safe if the initial marking is k-safe and the marking of all cases is k-safe.\nFrom now on we concentrate on 1-safe nets, which generalize the class of structured workflows and are the basis for best practices in process modeling [11]. We also use safeness as a synonym of 1-safeness. It is important to notice that our approach can be seamlessly generalized to other classes of PNs, as long as it is guaranteed that they are k-safe. This reflects the fact that the process control-flow is well-defined (see [10]).\nReachability on Petri Nets. The behavior of a PN can be described as a transition system where states are markings and directed edges represent firings. Intuitively, there is an edge from Mi to Mi+1 labeled by ti if Mi\nt\u2192 Mi+1 is a valid firing. Given a \u201cgoal\u201d markingMg , the reachability problem amounts to check if there is a path from the initial markingM0 toMg . Reachability on PNs (WF-nets) is of enormous importance in process verification as it allows for checking natural behavioral properties, such as satisfiability and soundness in a natural manner [2]."}, {"heading": "2.2 Trace repair", "text": "One of the goals of process mining is to capture the as-is processes as accurately as possible: this is done by examining event logs that can be then exploited to perform the tasks in Figure 1. In many cases, however, event logs are subject to data quality problems, resulting in incorrect or missing events in the log. In this paper we focus on the latter issue addressing the problem of repairing execution traces that contain missing entries (hereafter shortened in trace repair).\nThe need for trace repair is motivated in depth in [17], where missing entities are described as a frequent cause of low data quality in event logs, especially when the definition of the business processes integrates activities that are not supported by IT systems due either to their nature (e.g. they consist of human interactions) or to the high level of abstraction of the description, detached from the implementation. A further cause of missing events are special activities (such as transition T9 in Figure 3) that are introduced in the model to guarantee properties concerning e.g., the structure of the workflow or syntactic constraints, but are never executed in practice.\nThe starting point of trace repair are execution traces and the knowledge captured in process models. Consider for instance the model in Figure 3 and the (partial) execution trace {T3, T7}. By aligning the trace to the model using a replay-based approach or a planning based approach, the techniques presented in [17] and [8] are able to exploit the events stored in the trace and the control flow specified in the model to reconstruct two possible repairs:\n{T1, T3, T5, T7, T9, T10, T11, T12} {T1, T3, T5, T7, T9, T11, T10, T12}\nConsider now a different scenario in which the partial trace reduces to {T7}. In this case, by using the control flow in Figure 3 we are not able to reconstruct whether the loan is a student loan or a worker loan. This increases the number of possible repairs and therefore lowers the usefulness of trace repair. Assume nonetheless that the event log conforms to the XES standard and stores some observed data attached to T7 (enclosed in square brackets): {T7[request = 60k, loan = 50k]} If the process model is able to specify how transitions can read and write variables, and furthermore some constraints on how they do it, the scenario changes completely. Indeed, assume that transition T4 is empowered with the ability to write the variable request with a value smaller or equal than 30k (being this the maximum amount of a student loan). Using this fact, and the fact that the request examined by T7 is greater than 30k, we can understand that the execution trace has chosen the path of the worker loan. Moreover, if the model specifies that variable loanType is written during the execution of T1, when the applicant chooses the type of loan she is interested to, we are able to infer that T1 sets variable loanType to w. This example, besides illustrating the idea of trace repair, also motivates why data are important to accomplish this task, and therefore why extending repair techniques beyond the mere control flow is a significant contribution to address data quality problems in event logs."}, {"heading": "2.3 The planning language K", "text": "The main elements of action languages are fluents and actions. The former represent the state of the systemwhichmay change bymeans of actions. Causation statements describe the possible evolution of the states, and preconditions associated to actions describe which action can be executed according to the current state. A planning problem inK [9] is specified using a Datalog-like language where fluents and actions are represented by literals (not necessarily ground). The specification includes the list of fluents, actions, initial state and goal conditions; also a set of statements specifies the dynamics of the planning domain using causation rules and executability conditions. The semantics of K borrows heavily from Answer Set Programming (ASP) paradigm. In fact, the system enables the reasoning with partial knowledge and provides both weak and strong negation.\nA causation rule is a statement of the form caused f if b1,. . ., bk, not bk+1, . . ., not b`\nafter a1,. . ., am, not am+1, . . ., not an.\nThe rule states that f is true in the new state reached by executing (simultaneously) some actions, provided that a1, . . . , am are known to hold while am+1, . . . , an are not known to hold in the previous state (some of the aj might be actions executed on it), and b1, . . . , bk are known to hold while bk+1, . . . , b` are not known to hold in the new state. Rules without the after part are called static.\nAn executability condition is a statement of the form executable a if b1,. . ., bk, not bk+1, . . ., not b`.\nInformally, such a condition says that the action a is eligible for execution in a state, if b1, . . . , bk are known to hold while bk+1, . . . , b` are not known to hold in that state.\nTerms in both kind of statements could include variables (starting with capital letter) and the statements must be safe in the usual Datalog meaning w.r.t. the first fluent or action of the statements.\nA planning domain PD is a tuple \u3008D,R\u3009 where D is a finite set of action and fluent declarations and R a finite set of rules, initial state constraints, and executability conditions.\nThe semantics of the language is provided in terms of a transition system where the states are ASP models (sets of atoms) and actions transform the state according to the rules. A state transition is a tuple t = \u3008s,A, s\u2032\u3009 where s, s\u2032 are states and A is a set of action instances. The transition is said to be legal if the actions are executable in the first state and both states are the minimal ones that satisfy all causation rules. Semantics of plans including default negation is defined by means of a GelfondLifschitz type reduction to a positive planning domain. A sequence of state transitions \u3008s0, A1, s1\u3009, . . . , \u3008sn\u22121, An, sn\u3009, n \u2265 0, is a trajectory for PD, if s0 is a legal initial state of PD and all \u3008si\u22121, Ai, si\u3009, are legal state transitions of PD.\nA planning problem is a pair of planning domain PD and a ground goal g1, . . . , gm, not gm+1, . . ., not gn that is required to be satisfied at the end of the execution."}, {"heading": "3 Framework", "text": "In this section we suitably extend WF-nets to represent data and their evolution as transitions are performed. In order for such an extension to be meaningful, i.e., allowing reasoning on data, it has to provide: (i) a model for representing data; (ii) a way to make decisions on actual data values; and (iii) a mechanism to express modifications to data. Therefore, we enhance WF-nets with the following elements: \u2013 a set of variables taking values from possibly different domains (addressing (i)); \u2013 queries on such variables used as transitions preconditions (addressing (ii)) \u2013 variables updates and deletion in the specification of net transitions (addressing (iii)).\nOur framework follows the approach of state-of-the-art WF-nets with data [18,12], from which it borrows the above concepts, extending them by allowing reasoning on actual data values as better explained in Section 6.\nThroughout the section we use the WF-net in Figure 3 extended with data as a running example."}, {"heading": "3.1 Data Model", "text": "As our focus is on trace repair, we follow the data model of the IEEE XES standard for describing logs, which represents data as a set of variables. Variables take values from specific sets on which a partial order can be defined. As customary, we distinguish between the data model, namely the intensional level, from a specific instance of data, i.e., the extensional level.\nDefinition 5 (Data model). A data model is a tuple D = (V, \u2206, dm, ord) where: \u2013 V is a possibly infinite set of variables; \u2013 \u2206 = {\u22061, \u22062, . . .} is a possibly infinite set of domains (not necessarily disjoint); \u2013 dm : V \u2192 \u2206 is a total and surjective function which associates to each variable v its domain \u2206i;\n\u2013 ord is a partial function that, given a domain\u2206i, if ord(\u2206i) is defined, then it returns a partial order (reflexive, antisymmetric and transitive) \u2264\u2206i\u2286 \u2206i \u00d7\u2206i.\nAdatamodel for the loan example isV = {loanType, request, loan},dm(loanType) = {w, s}, dm(request) = N, dm(loan) = N, with dm(loan) and dm(loanType) being total ordered by the natural ordering \u2264 in N.\nAn actual instance of a data model is simply a partial function associating values to variables.\nDefinition 6 (Assignment). Let D = \u3008V, \u2206, dm, ord\u3009 be a data model. An assignment for variables in V is a partial function \u03b7 : V \u2192 \u22c3 i\u2206i such that for each v \u2208 V , if \u03b7(v) is defined, i.e., v \u2208 img(\u03b7) where img is the image of \u03b7, then we have \u03b7(v) \u2208 dm(v).\nWe now define our boolean query language, which notably allows for equality and comparison. As will become clearer in Section B.2, queries are used as guards, i.e., preconditions for the execution of transitions.\nDefinition 7 (Query language - syntax). Given a data model, the language L(D) is the set of formulas \u03a6 inductively defined according to the following grammar:\n\u03a6 := true | def(v) | t1 = t2 | t1 \u2264 t2 | \u00ac\u03a61 | \u03a61 \u2227 \u03a62\nwhere v \u2208 V and t1, t2 \u2208 V \u222a \u22c3 i\u2206i.\nExamples of queries of the loan scenarios are request \u2264 5k or loanType = w. Given a formula \u03a6 and an assignment \u03b7, we write \u03a6[\u03b7] for the formula \u03a6 where each occurrence of variable v \u2208 img(\u03b7) is replaced by \u03b7(v).\nDefinition 8 (Query language - semantics). Given a data model D, an assignment \u03b7 and a query \u03a6 \u2208 L(D) we say thatD, \u03b7 satisfies \u03a6, writtenD, \u03b7 |= \u03a6 inductively on the structure of \u03a6 as follows: \u2013 D, \u03b7 |= true; \u2013 D, \u03b7 |= def(v) iff v \u2208 img(\u03b7); \u2013 D, \u03b7 |= t1 = t2 iff t1[\u03b7], t2[\u03b7] 6\u2208 V and t1[\u03b7] \u2261 t2[\u03b7]; \u2013 D, \u03b7 |= t1 \u2264 t2 iff t1[\u03b7], t2[\u03b7] \u2208 \u2206i for some i and ord(\u2206i) is defined and t1[\u03b7] \u2264\u2206i t2[\u03b7];\n\u2013 D, \u03b7 |= \u00ac\u03a6 iff it is not the case that D, \u03b7 |= \u03a6; \u2013 D, \u03b7 |= \u03a61 \u2227 \u03a62 iff D, \u03b7 |= \u03a61 and D, \u03b7 |= \u03a62. Intuitively, def can be used to check if a variable has an associated value or not (recall that assignment \u03b7 is a partial function); equality has the intended meaning and t1 \u2264 t2 evaluates to true iff t1 and t2 are values belonging to the same domain \u2206i, such a domain is ordered by a partial order \u2264\u2206i and t1 is actually less or equal than t2 according to \u2264\u2206i ."}, {"heading": "3.2 Data-aware net", "text": "We now combine the data model with a WF-net and formally define how transitions are guarded by queries and how they update/delete data. The result is a Data-AWare net (DAW-net) that incorporates aspects (i)\u2013(iii) described at the beginning of Section 3.\nDefinition 9 (DAW-net). A DAW-net is a tuple \u3008D, N , wr, gd\u3009 where: \u2013 N = \u3008P, T, F \u3009 is a WF-net; \u2013 D = \u3008V, \u2206, dm, ord\u3009 is a data model; \u2013 wr : T 7\u2192 (V \u2032 7\u2192 2dm(V)), where V \u2032 \u2286 V , dm(V) = \u22c3 v\u2208V dm(v) and wr(t)(v) \u2286\ndm(v) for each v \u2208 V \u2032, is a function that associates each transition to a (partial) function mapping variables to a finite subset of their domain. \u2013 gd : T 7\u2192 L(D) is a function that associates a guard to each transition. Function gd associates a guard, namely a query, to each transition. The intuitive semantics is that a transition t can fire if its guard gd(t) evaluates to true (given the current assignment of values to data). Examples are gd(T6) = request \u2264 5k and gd(T8) = \u00ac(request \u2264 99999). Function wr is instead used to express how a transition t modifies data: after the firing of t, each variable v \u2208 V \u2032 can take any value among a specific finite subset of dm(v). We have three different cases: \u2013 \u2205 \u2282 wr(t)(v) \u2286 dm(v): t nondeterministically assigns a value from wr(t)(v) to v; \u2013 wr(t)(v) = \u2205: t deletes the value of v (hence making v undefined); \u2013 v 6\u2208 dom(wr(t)): value of v is not modified by t. Notice that by allowing wr(t)(v) \u2286 dm(v) in the first bullet above we enable the specification of restrictions for specific tasks. E.g., wr(T4) : {request} 7\u2192 {0 . . . 30k} says that T4 writes the request variable and intuitively that students can request a maximum loan of 30k, while wr(T5) : {request} 7\u2192 {0 . . . 500k} says that workers can request up to 500k.\nThe intuitive semantics of gd and wr is formalized next. We start from the definition of DAW-net state, which includes both the state of the WF-net, namely its marking, and the state of data, namely the assignment. We then extend the notions of state transition and valid firing.\nDefinition 10 (DAW-net state). A state of a DAW-net \u3008D,N ,wr, gd\u3009 is a pair (M,\u03b7) whereM is a marking for \u3008P, T, F \u3009 and \u03b7 is an assignment for D. Definition 11 (DAW-net Valid Firing). Given a DAW-net \u3008D,N ,wr, gd\u3009, a firing of a transition t \u2208 T is a valid firing from (M,\u03b7) to (M \u2032, \u03b7\u2032), written as (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032), iff conditions 1. and 2. of Def. 3 holds for M and M \u2032, i.e., it is a WF-Net valid firing, and\n1. D, \u03b7 |= gd(t), 2. assignment \u03b7\u2032 is such that, if wr = {v | wr(t)(v) 6= \u2205}, del = {v | wr(t)(v) = \u2205}:\n\u2013 its domain dom(\u03b7\u2032) = dom(\u03b7) \u222a wr \\ del; \u2013 for each v \u2208 dom(\u03b7\u2032):\n\u03b7\u2032(v) = { d \u2208 wr(t)(v) if v \u2208 wr \u03b7(v) otherwise.\nCondition 1. and 2. extend the notion of valid firing of WF-nets imposing additional pre- and postconditions on data, i.e., preconditions on \u03b7 and postconditions on \u03b7\u2032. Specifically, 1. says that for a transition t to be fired its guard gd(t) must be satisfied by the current assignment \u03b7. Condition 2. constrains the new state of data: the domain of \u03b7\u2032 is defined as the union of the domain of \u03b7 with variables that are written (wr), minus the set of variables that must be deleted (del). Variables in dom(\u03b7\u2032) can indeed be grouped in three sets depending on the effects of t: (i) old = dom(\u03b7) \\ wr: variables whose value is unchanged after t; (ii) new = wr \\ dom(\u03b7): variables that were undefined but have a value after t; and (iii) overwr = wr \u2229 dom(\u03b7): variables that did have a value and are updated with a new one after t. The final part of condition 2. says that each variable in new \u222a overwr takes a value in wr(t)(v), while variables in old maintain the old value \u03b7(v).\nA case of a DAW-net is defined as a case of a WF-net, with the only difference that the assignment \u03b70 of the initial state (M0, \u03b70) is empty, i.e., dom(\u03b70) = \u2205."}, {"heading": "4 Trace repair as reachability", "text": "In this section we provide the intuition behind our technique for solving the trace repair problem via reachability. Full details and proofs are contained in Appendices A\u2013D.\nA trace is a sequence of observed events, each with a payload including the transition it refers to and its effects on the data, i.e., the variables updated by its execution. Intuitively, a DAW-net case is compliant w.r.t. a trace if it contains all the occurrences of the transitions observed in the trace (with the corresponding variable updates) in the right order.\nAs a first step, we assumewithout loss of generality that DAW-net models start with a special transition startt and terminate with a special transition endt. Every process can be reduced to such a structure as informally illustrated in the left hand side of Figure 4 by arrows labeled with (1). Note that this change would not modify the behavior of the net: any sequence of firing valid for the original net can be extended by the firing of the additional transitions and vice versa.\nNext, we illustrate the main idea behind our approach by means of the right hand side of Figure 4: we consider the observed events as transitions (in red) and we suitably \u201cinject\u201d them in the original DAW-net. By doing so, we obtain a new model where, intuitively, tokens are forced to activate the red transitions of DAW-net, when events are observed in the trace. When, instead, there is no red counterpart, i.e., there is missing information in the trace, the tokens move in the black part of the model. The objective is then to perform reachability for the final marking (i.e., to have one token in the end\nplace and all other places empty) over such a new model in order to obtain all and only the possible repairs for the partial trace.\nMore precisely, for each event ewith a payload including transition t and some effect on variables we introduce a new transition te in the model such that: \u2013 te is placed in parallel with the original transition t; \u2013 te includes an additional input place connected to the preceding event and an additional output place which connects it to the next event;\n\u2013 gd(te) = gd(t) and \u2013 wr(te) specifies exactly the variables and the corresponding values updated by the event, i.e. if the event set the value of v to d, then wr(te)(v) = {d}; if the event deletes the variable v, then wr(te)(v) = \u2205. Given a trace \u03c4 and a DAW-netW , it is easy to see that the resulting trace workflow (indicated asW \u03c4 ) is a strict extension ofW (only new nodes are introduced) and, since all newly introduced nodes are in a path connecting the start and sink places, it is a DAW-net, whenever the original one is a DAW-net net.\nWe now prove the soundness and completeness of the approach by showing that: (1) all cases ofW \u03c4 are compliant with \u03c4 ; (2) each case ofW \u03c4 is also a case ofW and (3) if there is a case ofW compliant with \u03c4 , then that is also a case forW \u03c4 .\nProperty (1) is ensured by construction. For (2) and (3) we need to relate cases from W \u03c4 to the original DAW-netW .We indeed introduce a projection function\u03a0\u03c4 that maps elements from cases of the enriched DAW-net to cases of elements from the original DAW-net. Essentially, \u03a0\u03c4 maps newly introduced transitions te to the corresponding transitions in event e, i.e., t, and also projects away the new places in the markings. Given that the structure of W \u03c4 is essentially the same as that of W with additional copies of transitions that are already inW , it is not surprising that any case forW \u03c4 can be replayed onW by mapping the new transitions te into the original ones t, as shown by the following:\nLemma 1. If C is a case ofW \u03c4 then \u03a0\u03c4 (C) is a case ofW .\nThis lemma proves that whenever we find a case onW \u03c4 , then it is an example of a case onW that is compliant with \u03c4 , i.e., (2). However, to reduce the original problem to reachability on DAW-net, we need to prove that all the W cases compliant with \u03c4 can be replayed onW \u03c4 , that is, (3). In order to do that, we can build a case forW \u03c4 starting from the compliant case forW , by substituting the occurrences of firings corresponding to events in \u03c4 with the newly introduced transitions. The above results pave the way to the following:\nTheorem 1. LetW be a DAW-net and \u03c4 = (e1, . . . , en) a trace; thenW \u03c4 characterises all and only the cases ofW compatible with \u03c4 . That is \u21d2 if C is a case ofW \u03c4 containing ten then \u03a0\u03c4 (C) is compatible with \u03c4 ; and \u21d0 ifC is a case ofW compatible with \u03c4 , then there is a caseC \u2032 ofW \u03c4 s.t.\u03a0\u03c4 (C \u2032) = C.\nTheorem 1 provides the main result of this section and is the basis for the reduction of the trace repair forW and \u03c4 to the reachability problem forW \u03c4 . In fact, by enumerating all the cases ofW \u03c4 reaching the final marking (i.e. a token in end) we can provide all possible repairs for the partial observed trace. Moreover, the transformation generating W \u03c4 is preserving the safeness properties of the original workflow:\nLemma 2. LetW be a DAW-net and \u03c4 a trace ofW . IfW is k-safe thenW \u03c4 is k-safe as well.\nThis is essential to guarantee the decidability of the reasoning techniques described in the next section."}, {"heading": "5 Reachability as a planning problem", "text": "In this section we exploit the similarity between workflows and planning domains in order to describe the evolution of a DAW-net by means of a planning language. Once the original workflow behaviour has been encoded into an equivalent planning domain, we can use the automatic derivation of plans with specific properties to solve the reachability problem. In our approach we introduce a new action for each transition (to ease the description we will use the same names) and represent the status of the workflow \u2013 marking and variable assignments \u2013 by means of fluents. Although their representation as dynamic rules is conceptually similar we will separate the description of the encoding by considering first the behavioural part (the WF-net) and then the encoding of data (variable assignments and guards)."}, {"heading": "5.1 Encoding DAW-net behaviour", "text": "Since we focus on 1-safe WF-nets the representation of markings is simplified by the fact that each place can either contain 1 token or no tokens at all. This information can be represented introducing a propositional fluent for each place, true iff the corresponding place holds a token. Let us consider \u3008P, T, F \u3009 the safe WF-net component of a DAW-net system. The declaration part of the planning domain will include: \u2013 a fluent declaration p for each place p \u2208 P ; \u2013 an action declaration t for each task t \u2208 T .\nSince each transition can be fired5 only if each input place contains a token, then the corresponding action can be executed when place fluents are true: for each task t \u2208 T , given {it1, . . . , itn} = \u2022t, we include the executability condition:\nexecutable t if it1, . . . , itn.\n5 Guards will be introduced in the next section.\nAs valid firings are sequential, namely only one transition can be fired at each step, we disable concurrency in the planning domain introducing the following rule for each pair of tasks t1, t2 \u2208 T 6\ncaused false after t1, t2. Transitions transfer tokens from input to output places. Thus the corresponding actions must clear the input places and set the output places to true. This is enforced by including\ncaused \u2212it1 after t. . . . caused \u2212itn after t. caused ot1 after t. . . . caused otk after t.\nfor each task t \u2208 T and {it1, . . . , itn} = \u2022t \\ t\u2022, {ot1, . . . , otk} = t\u2022. Finally, place fluents should be inertial since they preserve their value unless modified by an action. This is enforced by adding for each p \u2208 P\ncaused p if not \u2212p after p.\nPlanning problem. Besides the domain described above, a planning problem includes an initial state, and a goal. In the initial state the only place with a token is the source:\ninitially: start. The formulation of the goal depends on the actual instance of the reachability problem we need to solve. The goal corresponding to the state in which the only place with a token is end is written as:\ngoal: end, not p1, . . ., not pk? where {p1, . . . , pk} = P \\ {end}."}, {"heading": "5.2 Encoding data", "text": "For each variable v \u2208 V we introduce a fluent unary predicate varv holding the value of that variable. Clearly, varv predicates must be functional and have no positive instantiation for undefined variables.\nWe also introduce auxiliary fluents to facilitate the writing of the rules. Fluent defv indicates whether the v variable is not undefined \u2013 it is used both in tests and to enforce models where the variable is assigned/unassigned. The fluent chngv is used to inhibit inertia for the variable v when its value is updated because of the execution of an action.\nDAW-net includes the specification of the set of values that each transition can write on a variable. This information is static, therefore it is included in the background knowledge by means of a set of unary predicates domv,t as a set of facts:\ndomv,t(e). for each v \u2208 V , t \u2208 T , and e \u2208 wr(t)(v).\nConstraints on variables. For each variable v \u2208 V: \u2013 we impose functionality\ncaused false if varv(X), varv(Y), X != Y. \u2013 we force its value to propagate to the next state unless it is modified by an action (chngv)\n6 For efficiency reasons we can relax this constraint by disabling concurrency only for transitions sharing places or updating the same variables. This would provide shorter plans.\ncaused varv(X) if not \u2212varv(X), not chngv after varv(X).\n\u2013 the defined fluent is the projection of the argument caused defv if varv(X).\nVariable updates. The value of a variable is updated by means of causation rules that depend on the transition t that operates on the variable, and depends on the value of wr(t). For each v in the domain of wr(t):\n\u2013 wr(t)(v) = \u2205: delete (undefine) a variable v caused false if defv after t. caused chngv after t. \u2013 wr(t)(v) \u2286 dm(v): set v with a value nondeterministically chosen among a set of elements from its domain\ncaused varv(V) if domv,t(V), not \u2212varv(V) after t. caused \u2212varv(V) if domv,t(V), not varv(V) after t. caused false if not defv after t. caused chngv after t.\nIf wr(t)(v) contains a single element d, then the assignment is deterministic and the first three rules above can be substituted with7\ncaused varv(d) after t.\nGuards. To each subformula \u03d5 of transition guards is associated a fluent grd\u03d5 that is true when the corresponding formula is satisfied. To simplify the notation, for any transition t, we will use grdt to indicate the fluent grdgd(t). Executability of transitions is conditioned to the satisfiability of their guards; instead of modifying the executability rule including the grdt among the preconditions, we use a constraint rule preventing executions of the action whenever its guard is not satisfied:\ncaused false after t, not grdt. Translation of atoms (\u03be) is defined in terms of varv predicates. For instance \u03be(v = w) corresponds to varv(V), varw(W), V == W. That is \u03be(v, T ) = vart(T) for t \u2208 V , and \u03be(d, T ) = vartT == d for d \u2208 \u22c3 i\u2206i. For each subformula \u03d5 of transition guards a static rule is included to \u201cdefine\u201d the fluent grd\u03d5: true : caused grd\u03d5 if true .\ndef(v) : caused grd\u03d5 if defv . t1 = t2 : caused grd\u03d5 if \u03be(t1,T1), \u03be(t2,T2), T1 == T2 . t1 \u2264 t2 : caused grd\u03d5 if \u03be(t1,T1), \u03be(t2,T2), ord(T1,T2) . \u00ac\u03d51 : caused grd\u03d5 if not grd\u03d51 .\n\u03d51 \u2227 . . . \u2227 \u03d5n : caused grd\u03d5 if grd\u03d51 , . . . , grd\u03d5n ."}, {"heading": "5.3 Correctness and completeness", "text": "We provide a sketch of the correctness and completeness of the encoding. Proofs can be found in [4].\n7 The deterministic version is a specific case of the non-deterministic ones and equivalent in the case that there is a single domv,t(d) fact.\nPlanning states include all the information to reconstruct the original DAW-net states. In fact, we can define a function \u03a6(\u00b7) mapping consistent planning states into DAW-net states as following: \u03a6(s) = (M,\u03b7) with\n\u2200p \u2208 P, M(p) = { 1 if p \u2208 s 0 otherwise\n\u03b7 = {(v, d) | varv(d) \u2208 s}\n\u03a6(s) is well defined because s it cannot be the case that {varv(d), varv(d\u2032)} \u2286 s with d 6= d\u2032, otherwise the static rule\ncaused false if varv(X), varv(Y), X != Y. would not be satisfied. Moreover, 1-safeness implies that we can restrict to markings with range in {0, 1}. By looking at the static rules we can observe that those defining the predicates defv and grdt are stratified. Therefore their truth assignment depends only on the extension of varv(\u00b7) predicates. This implies that grdt fluents are satisfied iff the variables assignment satisfies the corresponding guard gd(t). Based on these observations, the correctness of the encoding is relatively straightforward since we need to show that a legal transition in the planning domain can be mapped to a valid firing. This is proved by inspecting the dynamic rules.\nLemma 3 (Correctness). Let W be a DAW-net and \u2126(W ) the corresponding planning problem. If \u3008s, {t}, s\u2032\u3009 is a legal transition in \u2126(W ), then \u03a6(s) t\u2192 \u03a6(s\u2032) is a valid firing ofW .\nThe proof of completeness is more complex because \u2013 given a valid firing \u2013 we need to build a new planning state and show that it is minimal w.r.t. the transition. Since the starting state s of \u3008s, {t}, s\u2032\u3009 does not require minimality we just need to show its existence, while s\u2032 must be carefully defined on the basis of the rules in the planning domain.\nLemma 4 (Completeness). LetW be a DAW-net, \u2126(W ) the corresponding planning problem and (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) be a valid firing ofW . Then for each consistent state s s.t. \u03a6(s) = M there is a consistent state s\u2032 s.t. \u03a6(s\u2032) = M \u2032 and \u3008s, {t}, s\u2032\u3009 is a legal transition in \u2126(W ).\nLemmata 13 and 12 provide the basis for the inductive proof of the following theorem:\nTheorem 2. LetW be a safeWF-net and\u2126(PN) the corresponding planning problem. Let (M0, \u03b70) be the initial state of W \u2013 i.e. with a single token in the source and no assignments \u2013 and s0 the planning state satisfying the initial condition.\n(\u21d2) For any case inW\n\u03b6 : (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mn\u22121, \u03b7n\u22121) tn\u2192 (Mn, \u03b7n)\nthere is a trajectory in \u2126(W )\n\u03b7 : \u3008s0, {t1}, s1\u3009, . . . , \u3008sn\u22121, {tn}, sn\u3009\nsuch that (Mi, \u03b7i) = \u03a6(si) for each i \u2208 {0 . . . n} and viceversa.\n(\u21d0) For each trajectory \u03b7 : \u3008s0, {t1}, s1\u3009, . . . , \u3008sn\u22121, {tn}, sn\u3009\nin \u2126(W ), the following sequence of firings is a case ofW\n\u03b6 : \u03a6(s0) t1\u2192 \u03a6(s1) . . . \u03a6(sn\u22121) tn\u2192 \u03a6(sn).\nTheorem 5 above enables the exploitation of planning techniques to solve the reachability problem in DAW-net. Indeed, to verify whether the final marking is reachable it is sufficient to encode it as a condition for the final state and verify the existence of a trajectory terminating in a state where the condition is satisfied. Decidability of the planning problem is guaranteed by the fact that domains are effectively finite, as in Definition 9 the wr functions range over a finite subset of the domain."}, {"heading": "6 Related Work and Conclusions", "text": "The key role of data in the context of business processes has been recently recognized. A number of variants of PNs have been enriched so as to make tokens able to carry data and transitions aware of the data, as in the case of Workflow nets enriched with data [18,12], the model adopted by the business process community. In detail, Workflow Net transitions are enriched with information about data (e.g., a variable request) and about how it is used by the activity (for reading or writing purposes). Nevertheless, these nets do not consider data values (e.g., in the example of Section 2.2 we would not be aware of the values of the variable request that T4 is enabled to write). They only allow for the identification of whether the value of the data element is defined or undefined, thus limiting the reasoning capabilities that can be provided on top of them. For instance, in the example of Section 2.2, we would not be able to discriminate between the worker and the student loan for the trace in (2.2), as we would only be aware that request is defined after T4.\nThe problem of incomplete traces has been investigated in a number of works of trace alignment in the field of process mining, where it still represents one of the challenges. Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data. All these works, however, explore the search space of possible moves in order to find the best one aligning the log and the model. Differently from them, in this work (i) we assume that the model is correct and we focus on the repair of incomplete execution traces; (ii) we want to exploit state-of-the-art planning techniques to reason on control and data flow rather than solving an optimisation problem.\nWe can overall divide the approaches facing the problem of reconstructing flows of model activities given a partial set of information in two groups: quantitative and qualitative. The former rely on the availability of a probabilistic model of execution and knowledge. For example, in [17], the authors exploit stochastic PNs and Bayesian Networks to recover missing information (activities and their durations). The latter stand on the idea of describing \u201cpossible outcomes\u201d regardless of likelihood; hence, knowledge about the world will consist of equally likely \u201calternative worlds\u201d given the available observations in time, as in this work. For example, in [5] the same issue of reconstructing missing information has been tackled by reformulating it in terms of a Satisfiability(SAT) problem rather than as a planning problem.\nPlanning techniques have already been used in the context of business processes, e.g., for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15]. In [7] automated planning techniques have been applied for aligning execution traces and declarative models. As in this work, in [8], planning techniques have been used for addressing the problem of incomplete execution traces with respect to procedural models. However, differently from the two approaches above, this work uses for the first time planning techniques to target the problem of completing incomplete execution traces with respect to a procedural model that also takes into account data and the value they can assume.\nDespite this work mainly focuses on the problem of trace completion, the proposed automated planning approach can easily exploit reachability for model satisfiability and trace compliance and furthermore can be easily extended also for aligning dataaware procedural models and execution traces. Moreover, the presented encoding in the planning language K, can be directly adapted to other action languages with an expressiveness comparable to C [14]. In the future, we would like to explore these extensions and implement the proposed approach and its variants in a prototype."}, {"heading": "A Preliminaries", "text": "A.1 Workflow Nets\nDefinition 12 (Petri Net [12]). A Petri Net is a triple \u3008P, T, F \u3009 where\n\u2013 P is a set of places; \u2013 T is a set of transitions; \u2013 F \u2286 (P \u00d7 T ) \u222a (T \u00d7 P ) is the flow relation describing the \u201carcs\u201d between places and transitions (and between transitions and places).\nThe preset of a transition t is the set of its input places: \u2022t = {p \u2208 P | (p, t) \u2208 F}. The postset of t is the set of its output places: t\u2022 = {p \u2208 P | (t, p) \u2208 F}. Definitions of pre- and postsets of places are analogous.\nThe marking of a Petri net is a total mappingM : P 7\u2192 N.\nDefinition 13 (WF-net [18]). A Petri net \u3008P, T, F \u3009 is a workflow net (WF-net) if it has a single source place start, a single sink place end, and every place and every transition is on a path from start to end; i.e. for all n \u2208 P \u222a T , (start, n) \u2208 F \u2217 and (n, end) \u2208 F \u2217, where F \u2217 is the reflexive transitive closure of F .\nThe semantics of a PN is defined in terms of its markings and valid firing of transitions which change the marking. A firing of a transition t \u2208 T fromM toM \u2032 is valid \u2013 denoted byM t0\u2192M \u2013 iff:\n\u2013 t is enabled inM , i.e., {p \u2208 P |M(p) > 0} \u2287 \u2022t; and \u2013 the markingM \u2032 satisfies the property that for every p \u2208 P :\nM \u2032(p) =  M(p)\u2212 1 if p \u2208 \u2022t \\ t\u2022\nM(p) + 1 if p \u2208 t\u2022 \\ \u2022t M(p) otherwise\nA case of PN is a sequence of valid firings\nM0 t1\u2192M1,M1 t2\u2192M2, . . . ,Mk\u22121 tk\u2192Mk\nwhereM0 is the marking where there is a single token in the start place.\nDefinition 14 (safeness). A marking of a Petri Net is k-safe if the number of tokens in all places is at most k. A Petri Net is k-safe if the initial marking is k-safe and the marking of all cases is k-safe.\nIn this document we focus on 1-safeness, which is equivalent to the original safeness property as defined in [1].8 Note that for safe nets the range of markings is restricted to {0, 1}.\nA.2 Action Language K\nThe formal definition of K can be found in Appendix A of [9]; here, as reference, we include the main concepts.\nWe assume disjoint sets of action, fluent and type names, i.e., predicate symbols of arity \u2265 0, and disjoint sets of constant and variable symbols. Literals can be positive or negative atoms; denoted by \u2212. Given a set of literals L, L+ (respectively, L\u2212) is the set of positive (respectively, negative) literals in L. A set of literals is consistent no atoms appear both positive and negated.\nThe set of all action (respectively, fluent, type) literals is denoted as Lact (respectively, Lfl, Ltyp).\nFurthermore, Lfl,typ = Lfl \u222a Ltyp, Ldyn = Lfl \u222a L+act, and L = Lfl,typ \u222a L+act.\nDefinition 15 (Causation rule). A (causation) rule is an expression of the form caused f if b1, . . . , bk, not bk+1, . . ., not b` after a1, . . . , am, not am+1, . . ., not an. were f \u2208 Lfl \u222a {false}, bi \u2208 Lfl,typ, ai \u2208 L, ` \u2265 k \u2265 0 and n \u2265 m \u2265 0.\nIf n = 0 the rule is called static. We define h(r) = f , pre+(r) = {a1, . . . , am}, pre\u2212(r) = {am+1, . . . , an},\npost+(r) = {b1, . . . , bk}, post\u2212(r) = {bk+1, . . . , b`}\nDefinition 16 (Initial state constraints). An initial state constraint is a static rule preceded by the keyword initially.\nDefinition 17 (Executability condition). An executability condition e is an expression of the form executable a if b1, . . . , bk, not bk+1, . . ., not b`. were a \u2208 L+act, bi \u2208 Lfl,typ, and ` \u2265 k \u2265 0.\nWe define h(e) = a, pre+(e) = {b1, . . . , bk}, and pre\u2212(e) = {bk+1, . . . , b`}\nSince in this document we\u2019re dealing with ground plans, for the definition of typed instantiation the reader is referred to the original paper.\n8 In the following we will use safeness as a synonym of 1-safeness.\nDefinition 18 (Planning domain, [9] Def. A.5). An action description \u3008D,R\u3009 consists of a finite setD of action and fluent declarations and a finite setR of safe causation rules, safe initial state constraints, and safe executability conditions. A K planning domain is a pair PD = \u3008\u03a0,AD\u3009, where \u03a0 is a stratified Datalog program (the background knowledge) which is safe, and AD is an action description. We call PD positive, if no default negation occurs in AD.\nThe set lit(PD) contains all the literals appearing in PD.\nDefinition 19 (State, State transition). A state w.r.t. a planning domain PD is any consistent set s \u2286 Lfl \u2229 (lit(PD) \u222a lit(PD)\u2212) of legal fluent instances and their negations. A state transition is any tuple t = \u3008s,A, s\u2032\u3009 where s, s\u2032 are states and A \u2286 Lact \u2229 lit(PD) is a set of legal action instances in PD.\nSemantics of plans including default negation is defined by means of a Gelfond\u00e2\u0102\u015eLifschitz type reduction to a positive planning domain.\nDefinition 20. Let PD be a ground and well-typed planning domain, and let t = \u3008s,A, s\u2032\u3009 be a state transition. Then, the reduction PDt of PD by t is the planning domain where the set of rules R of PD is substituted by Rt obtained by deleting\n1. each r \u2208 R,where either post\u2212(r) \u2229 s\u2032 6= \u2205 or pre\u2212(r) \u2229 s 6= \u2205,and 2. all default literals not ` (` \u2208 L) from the remaining r \u2208 R.\nDefinition 21 (Legal initial state, executable action set, legal state transition). For any planning domain PD = \u3008D,R\u3009\n\u2013 a state s0 is a legal initial state, if s0 is the least set s.t. for all static and initial rules r post(r) \u2286 s0 implies h(r) \u2286 s0; \u2013 a set A \u2286 L+act is an executable action set w.r.t. a state s, if for each a \u2208 A there is an executability condition e \u2208 R\u3008s,A,\u2205\u3009 s.t. h(e) = {a}, pre(e) \u2229 Lfl \u2286 s, and pre(e) \u2229 L+act \u2286 A; \u2013 a state transition t = \u3008s,A, s\u2032\u3009 is legal if A is an executable action set w.r.t. s, and s\u2032 is the minimal consistent set that satisfies all causation rules in R\u3008s,A,s\u2032\u3009 w.r.t. s \u222aA. A causation rule r \u2208 R\u3008s,A,s\u2032\u3009, is satisfied if the three conditions 1. post(r) \u2286 s\u2032 2. pre(r) \u2229 Lfl \u2286 s 3. pre(r) \u2229 Lact \u2286 A all hold, then h(r) 6= {false} and h(r) \u2286 s\u2032.\nDefinition 22 (Trajectory). A sequence of state transitions\n\u3008s0, A1, s1\u3009, \u3008s1, A2, s2\u3009, . . . , \u3008sn\u22121, An, sn\u3009\n, n \u2265 0, is a trajectory for PD, if s0 is a legal initial state of PD and all \u3008si\u22121, Ai, si\u3009, 1 \u2264 i \u2264 n, are legal state transitions of PD.\nIf n = 0, then the trajectory is empty.\nDefinition 23 (Planning problem). A planning problem is a pair of planning domain PD and a ground goal q\ng1, . . . , gm, not gm+1, . . ., not gn. where gi \u2208 Lft and n \u2265 m \u2265 0.\nA state s satisfies the goal if {g1, . . . , gm} \u2286 s and {gm+1, . . . , gn} \u2229 s = \u2205.\nDefinition 24 (Optimistic plan). A sequence of action setsA1, . . . , Ak is an optimistic plan for a planning problem \u3008PD, q\u3009 if there is a trajectory \u3008s0, A1, s1\u3009, . . . , \u3008sk\u22121, Ak, sk\u3009 establishing the goal q, i.e. sk satisfies q.\nDefinition 25 (Secure plan). An optimistic planA1, . . . , An is secure if for every legal initial state s0 and trajectory \u3008s0, A1, s1\u3009, \u3008s1, A2, s2\u3009, . . . , \u3008sk\u22121, Ak, sk\u3009 0 \u2264 k \u2264 n, it holds that\n1. if k = n then sk satisfies the goal; 2. if k < n, then there is a legal transition \u3008sk, Ak+1, sk+1\u3009."}, {"heading": "B Framework", "text": "B.1 Data Model\nDefinition 26 (Data model). A data model for is a coupleD = (V, \u2206, dm, ord) where: \u2013 V is a possibly infinite set of variables; \u2013 \u2206 = {\u22061, . . . ,\u2206n} is a set of domains (not necessarily disjoints); \u2013 dm : V \u2192 \u2206 is a total and surjective function which associate to each variable v its finite domain \u2206i;\n\u2013 ord is a partial function that, given a domain\u2206i, if ord(\u2206i) is defined, then it returns a partial order (reflexive, antisymmetric and transitive) \u2264\u2206i\u2286 \u2206i \u00d7\u2206i.\nDefinition 27 (Assignment). LetD = \u3008V, \u2206, dm, ord\u3009 be a data model. An assignment for variables in V is a partial function \u03b7 : V \u2192 \u2206v such that for each v \u2208 V , if \u03b7(v) is defined, then we have \u03b7(v) \u2208 dm(v). We write \u03a6[\u03b7] for the formula \u03a6 where each occurrence of a variable v \u2208 img(\u03b7) is replaced by \u03b7(v).\nDefinition 28 (Guard language, syntax). Given a data model, the language L(D) of guards is the set of formulas \u03a6 inductively defined according to the following grammar:\n\u03a6 := true | def(v) | t1 = t2 | t1 \u2264 t2 | \u00ac\u03a61 | \u03a61 \u2227 \u03a62 where v \u2208 V and t1, t2 \u2208 V \u222a \u22c3 i\u2206i.\nDefinition 29 (Guard language, semantics). Given a data model D, an assignment \u03b7 and a guard \u03a6 \u2208 L(D) we say that D, \u03b7 satisfies \u03a6, written D, \u03b7 |= \u03a6 inductively on the structure of \u03a6 as follows:\n\u2013 D, \u03b7 |= true; \u2013 D, \u03b7 |= def(v) iff v \u2208 img(\u03b7); \u2013 D, \u03b7 |= t1 = t2 iff t1[\u03b7], t2[\u03b7] 6\u2208 V and t1[\u03b7] \u2261 t2[\u03b7]; \u2013 D, \u03b7 |= t1 \u2264 t2 iff t1[\u03b7], t2[\u03b7] \u2208 \u2206i for some i and ord(\u2206i) is defined and t1[\u03b7] \u2264\u2206i t2[\u03b7]; \u2013 D, \u03b7 |= \u00ac\u03a6 iff it is not the case that D, \u03b7 |= \u03a6; \u2013 D, \u03b7 |= \u03a61 \u2227 \u03a62 iff D, \u03b7 |= \u03a61 and D, \u03b7 |= \u03a62.\nB.2 Petri Nets with Data\nDefinition 30 (DAW-net). A Petri Net with data is a tuple \u3008D,N ,wr, gd\u3009 where:\n\u2013 N = \u3008P, T, F \u3009 is a Petri Net; \u2013 D = \u3008V, \u2206, dm, ord\u3009 is a data model; \u2013 wr : T 7\u2192 (V \u2032 7\u2192 2dm(V)), where V \u2032 \u2286 V and wr(t)(v) \u2286 dm(v) for each v \u2208 V \u2032, is\na function that associate each transition to a (partial) function mapping variables to a subset of their domain.\n\u2013 gd : T 7\u2192 L(D) a function that associates a guard expression to each transition.\nThe definition of wr provides a fine grained description of the way that transitions modify the state of the DAW-net, enabling the description of different cases:\n\u2013 \u2205 \u2282 wr(t)(v) \u2286 dm(v): transition t nondeterministically assigns a value from wr(t)(v) to v;9 \u2013 wr(t)(v) = \u2205: transition t deletes the value of v (undefined); \u2013 v 6\u2208 dom(wr(t)): value of v is not modified by transition t.\nDefinition 31. A state of a DAW-net \u3008D,N ,wr, gd\u3009 is a pair (M,\u03b7) where M is a marking for \u3008P, T, F \u3009 and \u03b7 is an assignment. State transitions and firing are adapted to the additional information about data.\nDefinition 32 (Valid Firing). Given a DAW-net \u3008D,N ,wr, gd\u3009, a firing of a transition t \u2208 T is valid firing in (M,\u03b7) resulting in a state (M \u2032, \u03b7\u2032) (written as (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032)) iff:\n\u2013 t is enabled inM , i.e., {p \u2208 P |M(p) > 0} \u2287 \u2022t; and \u2013 D, \u03b7 |= gd(t); \u2013 the markingM \u2032 satisfies the property that for every p \u2208 P :\nM \u2032(p) =  M(p)\u2212 1 if p \u2208 \u2022t \\ t\u2022\nM(p) + 1 if p \u2208 t\u2022 \\ \u2022t M(p) otherwise\n\u2013 the assignment \u03b7\u2032 satisfies the properties that its domain is\ndom(\u03b7\u2032) = dom(\u03b7) \u222a {v | wr(t)(v) 6= \u2205} \\ {v | wr(t)(v) = \u2205}\nand for each v \u2208 dom(\u03b7\u2032):\n\u03b7\u2032(v) = { d \u2208 wr(t)(v) if v \u2208 dom(wr(t)) \u03b7(v) otherwise.\nCases of DAW-net are defined as those of WF-nets, with the only difference that in the initial state the assignment is empty.\n9 Allowing a subset of dm(v) enables the specification of restrictions for specific tasks, e.g., while a task selects among yes, no, maybe another one can only choose between yes and no."}, {"heading": "C Trace completion as Reachability", "text": "Within this document we consider the possibility that some of the activities can be observable or not. In the sense that they might or can never appear in logs. This enables a fine grained information on the different type of activities that compose a process. For example, is common practice in modelling the introduction of transitions for routing purposes (e.g. and-joins) that do not correspond to real activities and as such they would never be observed. On the other end, some activities must be logged by their nature \u2013 e.g. a database update \u2013 so if they are not observed we can be sure that they never occurred. We use the term always observable for transitions that must appear in the logs and never observable for those that would never appear in logs; all other transitions may or may not be present in the logs but they may occur in actual cases.\nSince the focus of the paper is on the use of planning techniques to provide reasoning services for workflows with data, we decided to omit this aspect for reasons of space.\nDefinition 33 (Trace). Let Let P = \u3008D,N ,wr, gd\u3009 be a DAW-net. An event of P is a tuple \u3008t, w,wd\u3009 where t \u2208 T is a transition, w \u2208 dm(V)V\u2032 \u2013 with V \u2032 \u2286 V and w(v) \u2208 wr(t)(v) for all v \u2208 V \u2032 \u2013 is a partial function that represents the variables written by the execution of t, and wd \u2286 V the set of variables deleted (undefined) by the execution of t. Obviously, wd \u2229 V \u2032 = \u2205.\nA trace of P is a finite sequence of events \u03c4 = (e1, . . . , en). In the following we indicate the i-th event of \u03c4 as \u03c4 i. Given a set of tasks T , the set of traces is inductively defined as follows: \u2013 is a trace; \u2013 if \u03c4 is a trace and e an event, then \u03c4 \u00b7 e is a trace.\nDefinition 34 (Trace Compliance). A (valid) firing (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) is compliant with an event \u3008t\u2032, w, wd\u3009 iff t = t\u2032, wd = {v | wr(t\u2032)(v) = \u2205}, dom(\u03b7\u2032) = dom(w) \u222a dom(\u03b7) \\ wd, and for all v \u2208 dom(w) w(v) = \u03b7\u2032(v).\nA case (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k)\nis compliant with the trace \u03c4 = (e1, . . . , e`) iff there is an injective mapping \u03b3 between [1 . . . `] and [1 . . . k] such that:10\n\u2200i, j s.t. 1 \u2264 i < j \u2264 ` \u03b3(i) < \u03b3(j) (1)\n\u2200i s.t. 1 \u2264 i \u2264 ` (M\u03b3(i\u22121), \u03b7\u03b3(i\u22121)) t\u03b3(i)\u2192 (M\u03b3(i), \u03b7\u03b3(i)) is compliant with ei (2)\n\u2200i s.t. 1 \u2264 i \u2264 k ti always observable implies \u2203j s.t. \u03b3(j) = i (3)\nWe assume that theworkflow starts and terminateswith special transitions \u2013 indicated by startt and endt \u2013 while start and end denote start place and sink respectively.\nDefinition 35 (Trace workflow). Let W = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 be a DAW-net and \u03c4 = (e1, . . . , en) \u2013 where ei = \u3008ti, wi, wdi \u3009 \u2013 a trace of W . The trace workflow\n10 If the trace is empty then ` = 0 and \u03b3 is empty."}, {"heading": "W \u03c4 = \u3008D,N \u03c4 = \u3008P \u03c4 , T \u03c4 , F \u03c4 \u3009,wr\u03c4 , gd\u03c4 \u3009 is defined as following:", "text": "P \u03c4 = P \u222a {pe0} \u222a {pe | e \u2208 \u03c4} pe0 , pe new places T \u03c4 = T \u222a {te | e \u2208 \u03c4} te new transitions F \u03c4 = F \u222a\n{(tei , p) | i = 1 . . . n, (ti, p) \u2208 F} \u222a {(p, tei) | i = 1 . . . n, (p, ti) \u2208 F} \u222a {(tei , pei) | i = 1 . . . n} \u222a {(pei\u22121 , tei) | i = 1 . . . n} \u222a {(startt, pe0), (pen , endt)}\nwr\u03c4 (t) = { {(v, {j}) | (v, j) \u2208 wi} \u222a {(v, \u2205) | v \u2208 wdi } for t = tei wr(t) for t \u2208 T\ngd\u03c4 (t) =  gd(ti) for t = tei false for t \u2208 T fully observable gd(t) for t \u2208 T not fully observable\nIt\u2019s not difficult to see that whenever the original DAW-net W is a workflow net, thenW \u03c4 is a workflow net as well because the newly introduced nodes are in a the path start, startt, pe0 , te1 , pe1 , . . . , ten , pen , endt, end.\nTo relate cases from W \u03c4 to the original workflow W we introduce a \u201cprojection\u201d function \u03a0\u03c4 that maps elements from cases of the enriched workflow to cases using only elements from the original workflow. To simplify the notation we will use the same name to indicate mappings from states, firings and cases.\nDefinition 36. Let W = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 be a DAW-net, \u03c4 = (e1, . . . , en) \u2013 where ei = \u3008ti, wi, wdi \u3009 a trace ofW , andW \u03c4 = \u3008D,N \u03c4 = \u3008P \u03c4 , T \u03c4 , F \u03c4 \u3009,wr\u03c4 , gd\u03c4 \u3009 the corresponding trace workflow. The mapping \u03a0\u03c4 is defined as following:\n1. let (M \u2032, \u03b7\u2032) be a marking ofW \u03c4 , then\n\u03a0\u03c4 (M \u2032) = (M \u2032 \u2229 P \u00d7 N)\nis a state ofW ; 2. let (M \u2032, \u03b7\u2032) be a state ofW \u03c4 , then\n\u03a0\u03c4 ((M \u2032, \u03b7\u2032)) = (\u03a0\u03c4 (M \u2032), \u03b7\u2032)\nis a state ofW ; 3. let t be a transition in T \u03c4 , then\n\u03a0\u03c4 (t) = { ti for t = tei t for t \u2208 T\n4. let (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) be a firing inW \u03c4 , then\n\u03a0\u03c4 ((M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032)) = \u03a0\u03c4 ((M,\u03b7)) \u03a0\u03c4 (t)\u2192 \u03a0\u03c4 ((M \u2032, \u03b7\u2032))\n5. let C = f0, . . . , fk be a case ofW \u03c4 , then\n\u03a0\u03c4 (C) = \u03a0\u03c4 (f0), . . . ,\u03a0\u03c4 (fk)\nIn the following we consider a DAW-net W = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 and a trace \u03c4 = (e1, . . . , en) ofW \u2013where ei = \u3008ti, wi, wdi \u3009. LetW \u03c4 = \u3008D,N \u03c4 = \u3008P \u03c4 , T \u03c4 , F \u03c4 \u3009,wr\u03c4 , gd\u03c4 \u3009 be the corresponding trace workflow. To simplify the notation, in the following we will use te0 as a synonymous for startt and ten+1 as endt; as if they were part of the trace.\nLemma 5. Let C be a case ofW \u03c4 , then \u03a0\u03c4 (C) is a case ofW .\nProof. Let C = (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k), to show that \u03a0\u03c4 (C) is a case of W we need to prove that (i) \u03a0\u03c4 ((M0, \u03b70)) is an initial state of W and that (ii) the firing\u03a0\u03c4 ((Mi\u22121, \u03b7i\u22121)\nti\u2192 (Mi, \u03b7i)) is valid w.r.t.W for all 1 \u2264 i \u2264 n. i) By definition \u03a0\u03c4 ((M0, \u03b70)) = (\u03a0\u03c4 (M0), \u03b7\u2032) and \u03a0\u03c4 (M0) \u2286 M0. Since the start\nplace is in P , then start is the only place with a token in \u03a0\u03c4 (M0). ii) Let consider an arbitrary firing fi = (Mi\u22121, \u03b7i\u22121)\nti\u2192 (Mi, \u03b7i) in C (valid by definition), then \u03a0\u03c4 (fi) = (\u03a0\u03c4 (Mi\u22121), \u03b7i\u22121)\n\u03a0\u03c4 (ti)\u2192 (\u03a0\u03c4 (Mi), \u03b7i). Note that \u2013 by construction \u2013 gd(ti) = gd(\u03a0\u03c4 (ti)),\u03a0\u03c4 (ti)\u2022 = t\u2022i \u2229 P , \u2022\u03a0\u03c4 (ti) = \u2022ti \u2229P , dom(wr(ti)) = dom(wr(\u03a0\u03c4 (ti))) and wr(ti)(v) \u2286 wr(\u03a0\u03c4 (ti))(v) ; therefore \u2013 {p \u2208 P \u03c4 | Mi\u22121 > 0} \u2229 P = {p \u2208 P | \u03a0\u03c4 (Mi\u22121) > 0} \u2287 \u2022\u03a0\u03c4 (ti) because {p \u2208 P \u03c4 |Mi\u22121 > 0} \u2287 \u2022ti;\n\u2013 D, \u03b7 |= gd(\u03a0\u03c4 (ti)) because D, \u03b7 |= gd(ti) \u2013 for all p \u2208 P \u03a0\u03c4 (Mj)(p) =Mj(p), therefore:\nMi(p) = \u03a0\u03c4 (Mi)(p) =  Mi\u22121(p)\u2212 1 = \u03a0\u03c4 (Mi\u22121)(p)\u2212 1 if p \u2208 \u2022\u03a0\u03c4 (ti) \\\u03a0\u03c4 (ti)\u2022\nMi\u22121(p) + 1 = \u03a0\u03c4 (Mi\u22121)(p) + 1 if p \u2208 \u03a0\u03c4 (ti)\u2022 \\ \u2022\u03a0\u03c4 (ti) Mi\u22121(p) = \u03a0\u03c4 (Mi\u22121)(p) otherwise\nbecause fi is valid w.r.t.W \u03c4 ; \u2013 the assignment \u03b7i satisfies the properties that its domain is\ndom(\u03b7i) = dom(\u03b7i\u22121)\u222a{v | wr(\u03a0\u03c4 (ti))(v) 6= \u2205}\\{v | wr(\u03a0\u03c4 (ti))(v) = \u2205}\nand for each v \u2208 dom(\u03b7i):\n\u03b7i(v) = { d \u2208 wr(ti)(v) \u2286 wr(\u03a0\u03c4 (ti))(v) if v \u2208 dom(wr(ti)) = dom(wr(\u03a0\u03c4 (ti))) \u03b7i\u22121(v) otherwise.\nbecause fi is valid.\nBefore going into details, we will consider some properties of the \u201ctrace\u201d workflow.\nLemma 6. LetW = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 be a DAW-net and \u03c4 = (e1, . . . , en) \u2013 where ei = \u3008ti, wi, wdi \u3009\u2013a trace ofW . IfC = (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k) is a case ofW \u03c4 then for all 0 \u2264 i \u2264 k:\n\u03a3p\u2208P \u03c4\\PMi(p) \u2264M0(start)\nProof. By induction on the length of C.\n\u2013 For k = 1 then the only executable transition is startt, therefore t1 = startt which \u2013 by assumption \u2013 has two output places and \u2013 by construction \u2013 start\u2022t \\P = {pe0}. Since the firing is valid, thenM1(pe0) =M0(pe0) + 1 = 1 \u2264M0(start). \u2013 Let\u2019s assume that the property is true a case C of length n and consider C \u2032 = C(Mn, \u03b7n)\ntn+1\u2192 (Mn+1, \u03b7n+1). By construction, each p \u2208 P \u03c4 \\ P has a single incoming edge and {t \u2208 T \u03c4 | ei \u2208 t\u2022} = {tei} and {t \u2208 T \u03c4 | ei \u2208 \u2022t} = {tei+1}. Therefore the only occurrence in which a pei \u2208 P \u03c4 \\ P can increase its value is when tn+1 = tei . Since the transition is valid, thenMn+1(pei) =Mn(pei)+1 and Mn+1(pei\u22121) =Mn(pei\u22121)\u22121; therefore\u03a3p\u2208P \u03c4\\PMi(p) = \u03a3p\u2208P \u03c4\\PMi\u22121(p) \u2264 M0(start) \u2013 by the inductive hypothesis.\nLemma 7. LetW = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 be a DAW-net and \u03c4 = (e1, . . . , en) \u2013 where ei = \u3008ti, wi, wdi \u3009 \u2013 a trace ofW ,C = (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k) a case ofW \u03c4 , and tei is a transition of a firing fm in C with 1 \u2264 i \u2264 n, then (i) tei\u22121 is in a transition of a firing in C that precedes fm, (ii) and ifM0(start) = 1 then there is a single occurrence of tei in C.\nProof. The proof for the first part follows from the structure of the workflow net; because \u2013 by construction \u2013 each p \u2208 P \u03c4 \\ P has a single incoming edge and {t \u2208 T \u03c4 | ei \u2208 t\u2022} = {tei} and {t \u2208 T \u03c4 | ei \u2208 \u2022t} = {tei+1}. Since each firing must be valid \u2013 if fm = (Mm\u22121, \u03b7m\u22121) tei\u2192 (Mm, \u03b7m) is in C, thenMm\u22121(pei\u22121) \u2265 1 and this can only be true if there is a firing fr = (Mr\u22121, \u03b7r\u22121) tei\u22121\u2192 (Mr, \u03b7r) in C s.t. r < m.\nTo prove the second part is enough to show that for each 1 \u2264 i \u2264 n, if tei appears more than once in C then there must be multiple occurrences of tei\u22121 as well. In fact, if this is the fact, then we can use the previous part to show that there must be multiple occurrences of te0 = start, and this is only possible ifM0(start) > 1.\nBy contradiction let\u2019s assume that there are two firings fm and f \u2032m, with m < m\u2032, with the same transition tei , but there is only a single occurrence of tei\u22121 in a firing fr. Using the previous part of this lemma we conclude that r < m < m\u2032, therefore Mm\u22121(pei\u22121) = 1 because a token could be transferred into pei\u22121 only by tei\u22121 , so Mm(pei\u22121) = 0. In the firings betweenm andm\u2032 there are no occurrences of tei\u22121 , so Mm\u2032\u22121(pei\u22121) = Mm(pei\u22121) = 0 which is in contradiction with the assumption that f \u2032m is a valid firing.\nNow we\u2019re ready to show that the \u201ctrace\u201d workflow characterises all and only the cases compliant wrt the given trace. We divide the proof into correctness and completeness.\nLemma 8 (Correctness).LetC = (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k) be a case ofW \u03c4 s.t.M0(start) = 1, and ` = max({i | ti is in a firing of C} \u222a {0}), then the case\u03a0\u03c4 (C) ofW is compliant with \u03c4 \u2032 = (e1, . . . , e`) or the empty trace if ` is 0.\nProof. By induction on the length of C.\n\u2013 If C = (M0, \u03b70) t1\u2192 (M1, \u03b71) then t1 = startt because the firing is valid and the\nonly place with a token inM0 is start; therefore ` = 0 and \u03c4 \u2032 is the empty trace. C trivially satisfy the empty trace because no observable transitions are in \u03a0\u03c4 (C).\n\u2013 Let C = (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k) s.t. \u03a0\u03c4 (C) is compliant with \u03c4 \u2032. Let\u2019s consider C \u2032 = C \u00b7 (Mk, \u03b7k)\ntk+1\u2192 (Mk+1, \u03b7k+1): either tk+1 \u2208 T \u03c4 \\ T or tk+1 \u2208 T . In the first case tk+1 = te` for some 1 \u2264 ` \u2264 n, and \u2013 by using Lemma 7 \u2013 inC there are occurrences of all the tei for 1 \u2264 i < ` and it\u2019s the only occurrence of te` . This means that ` = max({i | ti is in a firing of C} \u222a {0}) and we can extend \u03b3 to \u03b3\u2032 by adding the mapping from ` to k + 1. The mapping is well defined because of the single occurrence of te` . By definition of te` , (Mk, \u03b7k)\ntk+1\u2192 (Mk+1, \u03b7k+1) is compliant with e` and the mapping \u03a0\u03c4 preserve the assignments, therefore \u03a0\u03c4 (Mk, \u03b7k)\ntk+1\u2192 (Mk+1, \u03b7k+1) is compliant with e` as well. By using the inductive hypnotises we can show that C \u2032 is compliant as well. In the second case the mapping is not modified, therefore the inductive hypothesis can be used to provide evidence of the first two conditions for trace compliance of Definition 34. For the third (transitions always observable) it\u2019s sufficient to consider that tk+1 cannot be always observable because its guard is never satisfiable inW \u03c4 .\nLemma 9 (Completeness).LetC = (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k) be a case of W compatible with \u03c4 = (e1, . . . , en), then there is a case C \u2032 of W \u03c4 s.t. \u03a0\u03c4 (C \u2032) = C.\nProof. Since C is compliant with \u03c4 , then there is a mapping \u03b3 satisfying the conditions of Definition 34. Let C \u2032 = (M \u20320, \u03b70) t\u20321\u2192 (M \u20321, \u03b71) . . . (M \u2032k\u22121, \u03b7k\u22121)\nt\u2032k\u2192 (M \u2032k, \u03b7k) a sequence of firing ofW \u03c4 defined as following:\n\u2013 M \u20320 =M0 \u222a {(pei , 0) | 0 \u2264 i \u2264 n} \u2013 t\u20321 = t1 andM \u20321 =M1 \u222a {(pej , 0) | 1 \u2264 j \u2264 n} \u222a {(pe0 , 1)} \u2013 for each (M \u2032i\u22121, \u03b7i\u22121) t\u2032i\u2192 (M \u2032i , \u03b7i), 2 \u2264 i \u2264 n:\n\u2022 if there is ` s.t. \u03b3(`) = i then t\u2032i = te` and\nM \u2032i =Mi \u222a {(pej , 0) | 0 \u2264 j \u2264 n, j 6= `} \u222a {(pe` , 1)}\n\u2022 otherwise t\u2032i = ti and\nM \u2032i =Mi \u222a (M \u2032i\u22121 \u2229 (P \u03c4 \\ P )\u00d7 N)\nIt\u2019s not difficult to realise that by construction \u03a0\u03c4 (C \u2032) = C. To conclude the proof we need to show thatC \u2032 is a case ofW \u03c4 . Clearly (M \u20320, \u03b70) is a starting state, so we need to show that all the firings are valid. The conditions involving variables \u2013 guards and update of the assignment \u2013 follows from the fact that the original firings are valid and the newly introduced transitions are restricted according to the trace data.\nConditions on input and output places that are both in W and W \u03c4 are satisfied because of the validity of the original firing. The newly introduced places satisfy the conditions because of the compliance wrt the trace, which guarantees that for each firing with transition te` there is the preceding firing with transition te`\u22121 that put a token in the pe`\u22121 place.\nTheorem 3. LetW be a DAW-net and \u03c4 = (e1, . . . , en) a trace; thenW \u03c4 characterises all and only the cases ofW compatible with \u03c4 . That is \u21d2 if C is a case ofW \u03c4 containing ten then \u03a0\u03c4 (C) is compatible with \u03c4 ; and \u21d0 ifC is a case ofW compatible with \u03c4 , then there is a caseC \u2032 ofW \u03c4 s.t.\u03a0\u03c4 (C \u2032) = C.\nProof.\n\u21d2 If C is a case ofW \u03c4 containing ten , then ` of Lemma 8 is n therefore \u03c4 \u2032 = \u03c4 and \u03a0\u03c4 (C) is compatible with \u03c4 . \u21d0 IfC is compatiblewith \u03c4 then byLemma9 there is a caseC \u2032 ofW \u03c4 s.t.\u03a0\u03c4 (C \u2032) = C.\nTheorem 4. LetW = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 be a DAW-net and \u03c4 = (e1, . . . , en) \u2013 where ei = \u3008ti, wi, wdi \u3009 \u2013 a trace ofW . IfW is k-safe thenW \u03c4 is k-safe as well.\nProof. We prove the theorem by induction on the length of a case C = (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mk\u22121, \u03b7k\u22121) tk\u2192 (Mk, \u03b7k). Note that by construction, for any markingM \u2032 ofW \u03c4 and p \u2208 P ,M \u2032(p) = \u03a0\u03c4 (M \u2032)(p).\n\u2013 For a case of length 1 the property trivially holds because by definitionM0(start) \u2264 k and for each p \u2208 P \u03c4 (different from start)M0(start) = 0, and since (M0, \u03b70)\nt1\u2192 (M1, \u03b71) is valid the only case in which the number of tokens in a place is increased is for p \u2208 t\u20221 \\ \u2022t1. For any p different from start this becomes 1 \u2264 k; while since the start place \u2013 by assumption \u2013 doesn\u2019t have any incoming arc therefore M1(start) =M0(start)\u2212 1 \u2264 k. \u2013 For the inductive step we assume that each marking M0, . . .Mm\u22121 is k-safe. By contradiction we assume that Mm is not k-safe; therefore there is a place p \u2208 P \u03c4 s.t. Mm > k. There are two cases, either p \u2208 P \u03c4 \\ P or p \u2208 P . In the first case there is a contradiction because, by Lemma 6, \u03a3p\u2208P \u03c4\\PMi(p) \u2264M0(start) = k. In the second case, since \u03a0\u03c4 (C) is a case ofW and \u03a0\u03c4 (Mm)(p) =Mm(p), there is a contradiction with the hypothesis thatW is k-safe."}, {"heading": "D Encoding Reachability as Planning Problem", "text": "D.1 Encoding WF-nets behaviour\nLet PN = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 be a safe DAW-net be a safe WF-net, we define the planning problem \u2126(W ) = \u3008\u03a0,D,R, q\u3009 by introducing a fluent for each place and an action for each task. Execution and causation rules constraint the plan to mimic the behaviour of the petri net.\nDeclarations\n\u2013 D contains a fluent declaration p for each place p \u2208 P ; \u2013 D contains an action declaration t for each task t \u2208 T ;\nExecutability rules\n\u2013 actions are executable if each input place has a token; i.e. for each task t \u2208 T , given {it1, . . . , itn} = \u2022t, there\u2019s an executability rule:\nexecutable t if it1, . . . , itn.\nCausation rules\n\u2013 parallelism is disabled; for each pair of tasks t1, t2 \u2208 T there\u2019s the rule:11 caused false after t1, t2. \u2013 after the execution of a task, input conditions must be \u201ccleared\u201d and tokens moved to the output ones; for each task t \u2208 T and {it1, . . . , itn} = \u2022t \\ t\u2022, {ot1, . . . , otk} = t\u2022:\ncaused \u2212it1 after t. . . . caused \u2212itn after t. caused ot1 after t. . . . caused otk after t.\n\u2013 the positive state of the places is inertial (i.e. must be explicitly modified); for each p \u2208 P :\ncaused p if not \u2212p after p.\nInitial state\n\u2013 The only place with a token is the source: initially: i.\nGoal\nThe formulation of the goal depends on the actual instance of the reachability problem we need to solve. E.g. it can be a specific marking:\n\u2013 The only place with a token is the sink: goal: o, not p1, . . ., not pk?\nwhere {p1, . . . , pk} = P \\ {o}.\nD.2 Encoding of Data\nTo each variable v \u2208 V corresponds to a inertial fluent predicate varv with a single argument \u201cholding\u201d the value of the variable, and a \u201cdomain\u201d predicate domv representing the domain of the variable. Unset variables have no positive instantiation of the varv predicate. The predicate varv must be functional.\nWe introduce also auxiliary fluents that indicate whether a variable is not undefined defv \u2013 used both in tests and to enforcemodels where the variable is assigned/unassigned \u2013 and chngv to \u201cinhibit\u201d inertia when variables might change because of the result of an action.\n11 There\u2019s aKmacro to disable concurrency. In practice concurrency could be enabled for actions that do not share input or output places.\nConstraints on variables For each variable v \u2208 V:\n\u2013 functionality caused false if varv(X), varv(Y), X != Y. \u2013 variable defined predicate caused defv if varv(X). \u2013 variable fluents are inertial unless they can be modified by actions caused varv(X) if not \u2212varv(X), not chngv after varv(X). \u2013 the background knowledge (\u03a0) includes the set of facts: domv,t(d).\nfor each v \u2208 V , t \u2208 T , and d \u2208 wr(t)(v).\nGuards To each task t is associated a fluent grdt that is true when the corresponding guard is satisfied. Instead of modifying the executability rule including the grdt among the preconditions, we use a constraint rule ruling out executions of the action whenever its guard is not satisfied:\ncaused false after t, not grdt. This equivalent formulation simplify the proofs because of its incremental nature (there are just additional rules).\nTranslation of atoms (\u03be) is defined in terms of varv predicates, e.g., \u03be(v = w) corresponds to varv(V), varw(W), V == W. The defv predicate can be used to test whether a variable is defined, or undefined, i.e. not defv .\nThe guard gd(t) = (a1,1 \u2227 . . .\u2227 a1,n1)\u2228 . . .\u2228 (ak,1 \u2227 . . .\u2227 ak,nk) where each ai,j is an atom, corresponds to the set of rules for grdt:12\ncaused grdt if \u03be(a1,1), . . ., \u03be(a1,n1). ... caused grdt if \u03be(ak,1), . . ., \u03be(a1,nk).\nVariables update The value of a variable is updated by means of causation rules that depend on the task t that operates on the variable:\n\u2013 wr(t)(v) = \u2205: delete (undefine) a variable v caused false if defv after t. caused chngv after t. \u2013 wr(t)(v) \u2286 dm(v): set v with a value nondeterministically chosen among a set of elements from its domain\ncaused varv(V) if domv,t(V), not \u2212varv(V) after t. caused \u2212varv(V) if domv,t(V), not varv(V) after t. caused chngv after t. caused false if not defv after t.\nIf wr(t)(v) contains a single element e, then there the assignment is deterministic and the above rules can be substituted with13\n12 Arbitrary expressions can be easily translated by introducing newfluents for the subexpressions. 13 The deterministic version is a specific case of the non-deterministic ones and equivalent in the case that there is a single domv,t(d) fact. In the following, the proofs will consider the general non-deterministic formulation only.\ncaused varv(d) after t. caused chngv after t.\nGuards To each subformula \u03d5 of transition guards is associated a fluent grd\u03d5 that is true when the corresponding formula is satisfied. To simplify the notation, for any transition t, we will use grdt to indicate the fluent grdgd(t).\nExecutability of transitions is conditioned to the satisfiability of their guards: caused false after t, not grdt. Translation of atoms (\u03be) is defined in terms of varv predicates. We assume a binary ord predicate representing the partial order among the elements of the domains. We also assume that elements of \u22c3 i\u2206i can be directly represented by constants of K language.\nFor t \u2208 V \u222a \u22c3 i\u2206i and T a K variable we define\n\u03be(t, T ) = { vart(T) for t \u2208 V T == t for t \u2208 \u22c3 i\u2206i\nFor each subformula \u03d5 of transition guards a static rule is included to \u201cdefine\u201d the\nfluent grd\u03d5:\ntrue : caused grd\u03d5 if true . def(v) : caused grd\u03d5 if defv . t1 = t2 : caused grd\u03d5 if \u03be(t1,T1), \u03be(t2,T2), T1 == T2 . t1 \u2264 t2 : caused grd\u03d5 if \u03be(t1,T1), \u03be(t2,T2), ord(T1,T2) . \u00ac\u03d51 : caused grd\u03d5 if not grd\u03d51 .\n\u03d51 \u2227 . . . \u2227 \u03d5n : caused grd\u03d5 if grd\u03d51 , . . . , grd\u03d5n .\nD.3 Correctness and completeness\nDefinition 37 (\u03a6(\u00b7) function). Let W = \u3008D,N = \u3008P, T, F \u3009,wr, gd\u3009 be a safe DAWnet,M the set of its markings, H the set of all assignments, \u2126(W ) the corresponding planning problem and S the set of its states, namely, the set of all consistent set of ground fluent literals. We define the function \u03a6(\u00b7) : S \u2192 M\u00d7 H mapping planning and DAW-net states. For any consistent s \u2208 S, \u03a6(s) = (M,\u03b7) is defined as follows:\n\u2200p \u2208 P M(p) = { 1 if p \u2208 s 0 otherwise\n\u03b7 = {(v, d) | varv(d) \u2208 s}\nThe function \u03a6(\u00b7) is well defined because s is assumed to be consistent therefore it cannot be the case that {varv(d), varv(d\u2032)} \u2286 s with d 6= d\u2032 otherwise the static rule\ncaused false if varv(X), varv(Y), X != Y. would not be satisfied.\nMoreover, since we assume thatW is safe, we can restrictM to markings with range restricted to {0, 1} and there is not loss of information between markings and planing states.\nThe function \u03a6(\u00b7) is not injective because of the strongly negated atoms. However it can be shown that if two states differ on the positive atoms then the corresponding DAW-net states are different as well:\nLemma 10. Let s and s\u2032 consistent states in S, then s \u2229 L+ 6= s\u2032 \u2229 L+ implies \u03a6(s) 6= \u03a6(s\u2032).\nObserving the static rules (those without the after part) it can be noted those defining the predicates defv and grdt are stratified, therefore their truth assignment depends only on the extension of varv(\u00b7) predicates. This fact can be used to show that\nLemma 11 (Guards translation). Let s \u2208 S satisfying the static rules of\u2126(W ), and \u03d5 a subformula of transition guards inW . Given \u03a6(s) = (M,\u03b7), grd\u03d5 \u2208 s iff D, \u03b7 |= \u03d5.\nProof. We prove the lemma by structural induction on \u03d5. First we consider the base cases. true : trivially satisfied because true is in consistent state. def(v) : the only rule where defv is in the head is\ncaused defv if varv(X). therefore defv \u2208 s iff there is a constant d s.t. varv(d) \u2208 s, and that is the case iff v \u2208 dom(\u03b7). t1 = t2 : for the sake of simplicity we consider only the case in which t1 \u2261 v is a variable and t2 \u2261 d is a constant; the other 3 combinations can be demonstrated in the same way. With this assumption, the only rule with grd\u03d5 in the head is\ncaused grd\u03d5 if varv(T1), T2 == d, T1 == T2 . therefore grd\u03d5 \u2208 s iff varv(d) \u2208 s, and this is the case iff \u03b7(v) = d.\nt1 \u2264 t2 : this case is analogous to the previous one, where we consider the predicate ord(T1,T2) instead of equality. Since ord facts correspond to the orders defined in D, then we can conclude. For the inductive step we assume that the property holds for subformulae \u03d51, \u03d52.\n\u00ac\u03d51 : the only rule with grd\u03d5 in the head is caused grd\u03d5 if not grd\u03d51 .\ntherefore grd\u03d5 \u2208 s iff grd\u03d51 6\u2208 s. We can use the inductive hypothesis to conclude that this is the case iff D, \u03b7 6|= \u03d51, that is D, \u03b7 |= \u03d5.\n\u03d51 \u2227 . . . \u2227 \u03d5n : the only rule with grd\u03d5 in the head is caused grd\u03d5 if grd\u03d51 , . . . , grd\u03d5n .\ntherefore grd\u03d5 \u2208 s iff {grd\u03d51 , . . . , grd\u03d5n} \u2286 s. We can use the inductive hypothesis to show that this is the case iff D, \u03b7 |= \u03d51 \u2227 . . . \u03d5n because they are all ground terms.\nLooking at the guard translation rules and the proof of Lemma 11 it is not difficult to realise that according to the structure of the guards some of the rules are redundant and can be simplified. E.g. defv can be used in place of grddefv , not grd\u03d5 in place of grddef\u00ac\u03d5 , and t1 = t2 can be expanded in place of grdt1=t2 unless they are in the scope of a negation.\nLemma 12 (Completeness). LetW be a safe DAW-net and \u2126(W ) the corresponding planning problem.\nLet (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) be a valid firing of W , then for each consistent state s s.t. \u03a6(s) = M there is a consistent state s\u2032 s.t. \u03a6(s\u2032) = M \u2032 and \u3008s, {t}, s\u2032\u3009 is a legal transition in \u2126(W ).\nProof. Let s be a consistent state s.t. \u03a6(s) = M . Note that such s exists because \u03a6(\u00b7) involves only the positive literals; therefore any consistent set s\u2032 s.t. {p \u2208 P | M(p) > 0} \u222a {varv(d) | (v, d) \u2208 \u03b7} \u2286 s\u2032 and s\u2032 \u2229 ({p \u2208 P | M(p) < 1} \u222a V \u00d7 dm(V) \\ \u03b7 satisfies the property that \u03a6(s\u2032) =M .\nWe define a new state s\u2032 such that \u3008s, {t}, s\u2032\u3009 is a legal state transition and such that \u03a6(s\u2032) =M \u2032; this new state is the union of the following parts:\ns\u2032P+ = {p \u2208 P |M \u2032(p) > 0} s\u2032P\u2212 = {\u2212p | p \u2208 \u2022t \\ t\u2022} s\u2032V+ = {varv(d) | (v, d) \u2208 \u03b7 \u2032} s\u2032V\u2212 = {\u2212varv(d) | d \u2208 wr(t)(v), (v, d) 6\u2208 \u03b7 \u2032} s\u2032V\u2193 = {defv | varv(d) \u2208 s \u2032 V+}\ns\u2032Vc = {chngv | v \u2208 dom(wr(t))} s\u2032wr = {domv,t(d) | \u2200v, t, d.d \u2208 wr(t)(v)} s\u2032gd = {grdt | \u2200t.M, \u03b7 |= gd(t)}\nBy construction\u03a6(s\u2032) =M and it is consistent: s\u2032P+\u2229s \u2032 P\u2212 = \u2205 because the fact that\n(M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) is a valid firing implies p \u2208 \u2022t \\ t\u2022M \u2032(p) = 0, and s\u2032V+ \u2229 s \u2032 V\u2212 = \u2205 because their conditions are mutually exclusive. Since (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) is valid, then \u2022t \u2286 s because \u03a6(s) = M , therefore the corresponding executable condition with t in the head executable t if it1, . . . , itn. is satisfied. We need to show that all the causation rules in \u2126(W )\u3008s,{t},s\n\u2032\u3009 are satisfied and that s\u2032 is minimal.\n\u2013 For each pair of tasks t1, t2, the positive rule: caused false after t1, t2.\nis satisfied because there is only a task t in the action set. \u2013 Consider the rules\ncaused \u2212ia1 after a. . . . caused \u2212ian after a. caused oa1 after a. . . . caused oak after a.\nwhere {ia1 , . . . , ian} = \u2022a\\a\u2022, {oa1 , . . . , oak} = a\u2022\\\u2022a. For all a 6= t they are satisfied because the after condition is false. For a = t the validity of (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) ensures that \u2022t \\ t\u2022 \u2286 s\u2032P\u2212 and t\n\u2022 \u2286 s\u2032P+ , therefore the rules are satisfied. \u2013 For each p \u2208 P :\ncaused p if not \u2212p after p. we consider the three cases where p \u2208 \u2022t \\ t\u2022, p \u2208 t\u2022, or p 6\u2208 (\u2022t \u222a t\u2022). p \u2208 \u2022t \\ t\u2022 then\u2212p \u2208 s\u2032P\u2212 by construction, therefore the rule is not in\u2126(W ) \u3008s,{t},s\u2032\u3009 p \u2208 t\u2022 then M \u2032(p) = 1 and by construction p \u2208 s\u2032P+ and \u2212p 6\u2208 s \u2032 P+ because s \u2032\nis consistent, so the rule caused p after p. is in \u2126(W )\u3008s,{t},s \u2032\u3009. This rule is\nsatisfied if p \u2208 s and also if p 6\u2208 s. p 6\u2208 (\u2022t \u222a t\u2022) then M \u2032(p) = M(p). If p \u2208 s\u2032P+ the rule caused p after p. is in\n\u2126(W )\u3008s,{t},s \u2032\u3009 it\u2019s satisfied regardless of the value ofM(p); on the other end, if p 6\u2208 s\u2032 then M(p) = 0 therefore even if caused p after p. would be in \u2126(W )\u3008s,{t},s \u2032\u3009 then it\u2019d be satisfied because its after part is false.\n\u2013 Functionality rules caused false if varv(X), varv(Y), X != Y.\nis satisfied by construction of s\u2032V+ \u2013 Variable defined predicate rules\ncaused defv if varv(X). are satisfied by construction of s\u2032V\u2193 .\n\u2013 variable fluents are inertial \u2013 The background knowledge facts\ndomv,t(d). are satisfied by construction of s\u2032wr\n\u2013 The guard predicates rules are satisfied by Lemma 11 and the construction of s\u2032gd.\nFor rules involving the varv predicates (including intertiality rules) we consider the three cases: v 6\u2208 dom(wr(t)), wr(t)(v) = \u2205, and wr(t)(v) 6= \u2205. Note that, since the transition includes only t, all the rules in \u2126(W )\u3008s,{t},s\n\u2032\u3009 with a different action in the after part are satisfied; therefore we focus on the remaining ones.\nv 6\u2208 dom(wr(t)): in this case the only rule in\u2126(W )\u3008s,{t},s\u2032\u3009 to verify is the inertial one caused varv(X) if not \u2212varv(X), not chngv after varv(X).\nand by construction \u2212varv(d) 6\u2208 s\u2032V\u2212 for any d and chngv 6\u2208 s \u2032 Vc . This would be not satisfied only in the case that for some d varv(d) \u2208 s and varv(d) 6\u2208 s \u2013 which means that (v, d) \u2208 \u03b7 and (v, d) 6\u2208 \u03b7 \u2013 but his would be in contradiction with the fact that (M,\u03b7) t\u2192 (M \u2032, \u03b7\u2032) is a valid firing.\nwr(t)(v) = \u2205: in this case the corresponding rules are caused false if defv after t. caused chngv after t. caused varv(X) if not \u2212varv(X), not chngv after varv(X).\nSince there is no d s.t. (v, d) \u2208 \u03b7\u2032 then varv(d\u2032) 6\u2208 s\u2032V+ for any d \u2032, therefore defv 6\u2208 s\u2032V\u2193 and the first rule is satisfied. The second rule is satisfied by construction of s\u2032Vc , and the third is not be in \u2126(W )\u3008s,{t},s\n\u2032\u3009 because chngv \u2208 s\u2032Vc . wr(t)(v) 6= \u2205: the rules are\ncaused varv(V) if domv,t(V), not \u2212varv(V) after t. caused \u2212varv(V) if domv,t(V), not varv(V) after t. caused chngv after t. caused false if not defv after t. caused varv(X) if not \u2212varv(X), not chngv after varv(X).\nThe first two rules are satisfied by construction of s\u2032V+ and s \u2032 V\u2212 , while the third by s\u2032Vc . The fourth because of the fact that the firing is valid, therefore there is a value d \u2208 wr(t)(v) s.t. (v, d) \u2208 \u03b7\u2032, so varv(d) \u2208 s\u2032V+ and defv \u2208 s \u2032 V\u2193 . Last rule is not in \u2126(W )\u3008s,{t},s \u2032\u3009 because chngv \u2208 s\u2032Vc .\nTo demonstrate the minimality of s\u2032 we need to show that removing one literal from any of the components s\u2032P+ , s \u2032 P\u2212 , s \u2032 V+ , s \u2032 V\u2212 , s \u2032 V\u2193 , s \u2032 Vc , s \u2032 wr, s \u2032 gd results in some of the rules not being satisfied.\ns\u2032P+ any p \u2208 s \u2032 P+ is either in t \u2022 or not. In the first case removing it would not satisfy the rule\ncaused p after t. while in the second it would not satisfy the inertial rule\ncaused p if not \u2212p after p. because \u2212p 6\u2208 s\u2032P\u2212 and p \u2208 s since the firing is valid.\ns\u2032P\u2212 removing \u2212p from s \u2032 P\u2212 would not satisfy the rule caused \u2212p after t. s\u2032wr removing domv,t(d) from s\u2032wr would not satisfy the rule domv,t(d). s\u2032V+ let be varv(d) \u2208 s \u2032 V+ : either v \u2208 dom(wr(t)) or not. In the first case the rule\ncaused varv(d) if domv,t(d), not \u2212varv(d) after t. would not be satisfied because\u2212varv(d) 6\u2208 s\u2032V\u2212 since by assumption (v, d) \u2208 \u03b7\n\u2032. In the second case the inertial rule\ncaused varv(d) if not \u2212varv(d), not chngv after varv(d). would not be satisfied because \u2212varv(d) 6\u2208 s\u2032V\u2212 , chngv 6\u2208 s \u2032 Vc , and varv(d) \u2208 s\nsince the firing is valid. s\u2032V\u2212 removing \u2212varv(d) from s \u2032 V\u2212 would not satisfy rule\ncaused \u2212varv(d) if domv,t(d), not varv(d) after t. because varv(d) 6\u2208 s\u2032V+ since (v, d) 6\u2208 \u03b7\n\u2032. s\u2032V\u2193 removing any of the defv\u2032 \u2208 {defv | varv(d) \u2208 s \u2032 V+} would contradict one of the\nrules caused defv\u2032 if varv\u2032 (d).\nsince there is a an element d\u2032 s.t. varv\u2032(d\u2032) \u2208 s\u2032V+ s\u2032Vc removing any chngv\u2032 \u2208 {chngv | v \u2208 dom(wr(t))} since v\u2032 \u2208 dom(wr(t)), so\ntherefore there is the rule caused chngv\u2032 after t.\nthat would not be satisfied. s\u2032gd removing grdt from s\u2032gd would contradict one of the guard rules according to\nLemma 11.\nLemma 13 (Correctness). Let W be a safe DAW-net and \u2126(W ) the corresponding planning problem.\nIf \u3008s, {t}, s\u2032\u3009 is a legal transition in \u2126(W ), then \u03a6(s) t\u2192 \u03a6(s\u2032) is a valid firing of W .\nProof. Let (M,\u03b7) = \u03a6(s) and (M \u2032, \u03b7\u2032) = \u03a6(s\u2032); to show that \u03a6(s) t\u2192 \u03a6(s\u2032) is a valid firing ofW (see Definition 32) we need to show that: 1. t is enabled inM , i.e., {p \u2208 P |M(p) > 0} \u2287 \u2022t; and 2. D, \u03b7 |= gd(t); 3. the markingM \u2032 satisfies the property that for every p \u2208 P :\nM \u2032(p) =  M(p)\u2212 1 if p \u2208 \u2022t \\ t\u2022\nM(p) + 1 if p \u2208 t\u2022 \\ \u2022t M(p) otherwise\n4. the assignment \u03b7\u2032 satisfies the properties that its domain is\ndom(\u03b7\u2032) = dom(\u03b7) \u222a {v | wr(t)(v) 6= \u2205} \\ {v | wr(t)(v) = \u2205}\nand for each v \u2208 dom(\u03b7\u2032):\n\u03b7\u2032(v) = { d \u2208 wr(t)(v) if v \u2208 dom(wr(t)) \u03b7(v) otherwise.\nSince \u3008s, {t}, s\u2032\u3009 is a legal transition, then the action tmust be executable, therefore the rule:\nexecutable t if it1, . . . , itn. with {it1, . . . , itn} = \u2022t must be satisfied in s, that is \u2022t \u2286 s and M(itj) = 1 for 1 \u2264 j \u2264 n.\nSince \u3008s, {t}, s\u2032\u3009 is a legal transition, then the rule: caused false after t, not grdt.\nmust be satisfied, therefore its body should be false. This means that grdt \u2208 s and by using Lemma 11 we can conclude that D, \u03b7 |= gd(t).\nTo verify the condition onM \u2032, for each p \u2208 P we consider the three cases:\np \u2208 \u2022t \\ t\u2022 then in \u2126(W ) there is the rule caused \u2212p after t.\ntherefore p 6\u2208 s\u2032 and \u03a6(s\u2032)(p) = 0 p \u2208 t\u2022 \\ \u2022t then in \u2126(W ) there is the rule\ncaused p after t. therefore p \u2208 s\u2032 and \u03a6(s\u2032)(p) = 1\np 6\u2208 (\u2022t \\ t\u2022) \u222a (t\u2022 \\ \u2022t) in this case none of the bodies of rules with p (or \u2212p) in the head and an action in the body are satisfied because the only executed action is t. Therefore the only \u201cactive\u201d rule having p (or \u2212p) in the head can be the \u201cinertial\u201d one for the positive atom:\ncaused p if not \u2212p after p. Since rules with\u2212p in the head have their bodies falsified\u2212p 6\u2208 s\u2032. This means that the rule caused p after p. is in \u2126(W )\u3008s,{t},s\n\u2032\u3009. If \u03a6(s\u2032)(p) = 0 then p 6\u2208 s\u2032 therefore p 6\u2208 s otherwise the inertial rule would not be satisfied; so \u03a6(s)(p) = 0. If \u03a6(s\u2032)(p) = 1 and \u03a6(s)(p) = 0, then s\u2032 would not be minimal because s\u2032 \\ {p} satisfies the only \u201cactive\u201d rule with p in the head, therefore \u03a6(s)(p) = 1.\nNow we verify the conditions on \u03b7\u2032 and for each v \u2208 V we consider three distinct cases: v 6\u2208 dom(wr(t)), wr(t)(v) = \u2205, and wr(t)(v) 6= \u2205. First we should note that chngv \u2208 s\u2032 iff v \u2208 dom(wr(t)), therefore only in the two latter cases where the inertial rule\ncaused varv(X) if not \u2212varv(X), not chngv after varv(X). would not be in \u2126(W )\u3008s,{t},s \u2032\u3009.\nv 6\u2208 dom(wr(t)): In this case, the only active rule where varv(\u00b7) appears in the head is the inertial\ncaused varv(X) if not \u2212varv(X), not chngv after varv(X). while there are no rules with \u2212varv(\u00b7) in the head, because for all actions t\u2032 6= t are \u201cfalse\u201d in s. Therefore \u2212varv(d) 6\u2208 s and chngv 6\u2208 s\u2032 so varv(d) \u2208 s\u2032 iff varv(d) \u2208 s. This means that v \u2208 dom(\u03b7\u2032) iff v \u2208 dom(\u03b7), and v \u2208 dom(\u03b7) implies that \u03b7\u2032(v) = \u03b7(v). wr(t)(v) = \u2205: in this case if varv(d) \u2208 s\u2032 for some d, then defv \u2208 s\u2032 as well; therefore the rule\ncaused false if defv after t. caused chngv after t.\nwould not be satisfied contradicting the hypothesis that \u3008s, {t}, s\u2032\u3009 is a legal transition.\nwr(t)(v) 6= \u2205: in this case \u2126(W ) contains the rules caused varv(V) if domv,t(V), not \u2212varv(V) after t. caused \u2212varv(V) if domv,t(V), not varv(V) after t. caused false if not defv after t. caused chngv after t.\nSince defv \u2208 s\u2032 otherwise the third rule would not be satisfied, there there must be a d s.t. varv(d) \u2208 s\u2032, and this means that v \u2208 dom(\u03b7\u2032). Let assume that d 6\u2208 wr(t)(v), then it means that domv,t(d) 6\u2208 s\u2032 therefore none of the rules with varv(d) in the head would be satisfied in \u2126(W )\u3008s,{t},s \u2032\u3009 that contradicts the minimality of s\u2032.\nThe analysis of the three cases confirms that the fourth condition is satisfied as well.\nTheorem 5. LetW be a safe WF-net and \u2126(W ) the corresponding planning problem. Let (M0, \u03b70) be the initial state of W \u2013 i.e. with a single token in the source and no assignments \u2013 and s0 the planning state satisfying the initial condition.\n(\u21d2) For any case\n\u03b6 : (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mn\u22121, \u03b7n\u22121) tn\u2192 (Mn, \u03b7n)\ninW there is a trajectory in \u2126(W )\n\u03b7 : \u3008s0, {t1}, s1\u3009, . . . , \u3008sn\u22121, {tn}, sn\u3009\nsuch that (Mi, \u03b7i) = \u03a6(si) for each i \u2208 {0 . . . n} and vice versa. (\u21d0) For each trajectory\n\u03b7 : \u3008s0, {t1}, s1\u3009, . . . , \u3008sn\u22121, {tn}, sn\u3009\nin \u2126(W ) the sequence of firings\n\u03b6 : \u03a6(s0) t1\u2192 \u03a6(s1) . . . \u03a6(sn\u22121) tn\u2192 \u03a6(sn)\nis a case ofW .\nProof. We first prove the left-to-right direction by induction on the length of the case.\n\u2013 Base case: by construction, \u03a6(s0) = (M0, \u03b70) because of the structure of the initial state. \u2013 Inductive case: we consider a case of size n + 1. By inductive hypothesis, for the case (M0, \u03b70) t1\u2192 (M1, \u03b71) . . . (Mn\u22121, \u03b7n\u22121) tn\u2192 (Mn, \u03b7n) there is a trajectory\n\u3008s0, {t1}, s1\u3009, . . . , \u3008sn\u22121, {tn}, sn\u3009 s.t. \u03a6(si) =Mi for each i \u2208 {0 . . . n}. Since sn is consistent and \u03a6(sn) = (Mn, \u03b7n), by Lemma 12, there is a state sn+1 s.t. \u3008sn, {tn}, sn+1\u3009 is a legal transition and \u03a6(sn+1) = (Mn, \u03b7n) thus proving the claim.\nThe right-to-left direction can be proved \u2013 in the same way as the other case \u2013 by induction on the length trajectories by using the Lemma 13."}], "references": [{"title": "The application of petri nets to workflow management", "author": ["W. van der Aalst"], "venue": "J. of Circuits, Sys. and Comp. 08, 21\u201366", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1998}, {"title": "Verification of workflow nets", "author": ["W.M.P. van der Aalst"], "venue": "Proc. of ICATPN. pp. 407\u2013426", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1997}, {"title": "Conformance checking using cost-based fitness analysis", "author": ["A. Adriansyah", "B.F. van Dongen", "W. van der Aalst"], "venue": "Proc. of EDOC. pp. 55\u201364", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Reasoning-based techniques for dealing with incomplete business process execution traces", "author": ["P. Bertoli", "C. Di Francescomarino", "M. Dragoni", "C. Ghidini"], "venue": "AI*IA, LNCS, vol. 8249, pp. 469\u2013480. Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2013}, {"title": "Foundations of data-aware process analysis: A database theory perspective", "author": ["D. Calvanese", "G. De Giacomo", "M. Montali"], "venue": "pp. 1\u201312", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2013}, {"title": "Computing trace alignment against declarative process models through planning", "author": ["G. De Giacomo", "F.M. Maggi", "A. Marrella", "S. Sardi\u00f1a"], "venue": "ICAPS. pp. 367\u2013375", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2016}, {"title": "Completing workflow traces using action languages", "author": ["C. Di Francescomarino", "C. Ghidini", "S. Tessaris", "I.V. Sandoval"], "venue": "CAiSE. LNCS, vol. 9097, pp. 314\u2013330. Springer", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2015}, {"title": "A logic programming approach to knowledge-state planning, II: The DLVK system", "author": ["T. Eiter", "W. Faber", "N. Leone", "G. Pfeifer", "A. Polleres"], "venue": "Art. Intell. 144(1\u20132), 157\u2013211", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2003}, {"title": "Soundness and Separability of Workflow Nets in the Stepwise Refinement Approach", "author": ["K. van Hee", "N. Sidorova", "M. Voorhoeve"], "venue": "ICATPN. No. 2679 in Lecture Notes in Computer Science, Springer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}, {"title": "On structured workflow modelling", "author": ["B. Kiepuszewski", "A.H.M. ter Hofstede", "C.J. Bussler"], "venue": "Seminal Contributions to Information Systems Engineering", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Data-aware Process Mining: Discovering Decisions in Processes Using Alignments", "author": ["M. de Leoni", "W. van der Aalst"], "venue": "Proc of ACM SAC. pp. 1454\u20131461", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2013}, {"title": "Data- and resource-aware conformance checking of business processes", "author": ["M. de Leoni", "W. van der Aalst", "B.F. van Dongen"], "venue": "LNBIP, vol. 117, pp. 48\u201359", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Action languages, answer sets and planning", "author": ["V. Lifschitz"], "venue": "The Logic Programming Paradigm: a 25-Year Perspective, pp. 357\u2013373. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1999}, {"title": "Planlets: Automatically recovering dynamic processes in yawl", "author": ["A. Marrella", "A. Russo", "M. Mecella"], "venue": "OTM Conferences (1). pp. 268\u2013286", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Specifying and verifying declarative fluent temporal logic properties of workflows", "author": ["G. Regis", "N. Ricci", "N. Aguirre", "T.S.E. Maibaum"], "venue": "Proc. of SBMF. pp. 147\u2013162", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2012}, {"title": "Improving documentation by repairing event logs", "author": ["A. Rogge-Solti", "S. Ronny", "W. van der Aalst", "M. Weske"], "venue": "The Practice of Enterprise Modeling, LNBIP, vol. 165, pp. 129\u2013144. Springer", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2013}, {"title": "Soundness verification for conceptual workflow nets with data", "author": ["N. Sidorova", "C. Stahl", "N. Tr\u010dka"], "venue": "Inf. Sys. 36(7), 1026\u20131043", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2011}, {"title": "A framework for automatic generation of processes for selfadaptive software systems", "author": ["C.E. da Silva", "R. de Lemos"], "venue": "Informatica (Slov.) 35(1), 3\u201313", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Soundness of workflow nets", "author": ["W. van der Aalst", "Hee", "K.v.", "Hofstede", "A.t.", "N. Sidorova", "H. Verbeek", "M. Voorhoeve", "M. Wynn"], "venue": "Formal Aspects of Comp. 23(3), 333\u2013363", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2010}, {"title": "Automated Reasoning Support for Process Models using Action Language. mastersthesis, Computer Science Faculty", "author": ["I. V\u00e1zquez Sandoval"], "venue": "Free University of Bozen\u2013 Bolzano", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2014}], "referenceMentions": [{"referenceID": 15, "context": "Thus repairing incomplete execution traces by reconstructing the missing entries becomes an important task to enable process mining in full, as noted in recent works such as [17,8].", "startOffset": 174, "endOffset": 180}, {"referenceID": 6, "context": "Thus repairing incomplete execution traces by reconstructing the missing entries becomes an important task to enable process mining in full, as noted in recent works such as [17,8].", "startOffset": 174, "endOffset": 180}, {"referenceID": 4, "context": "This is a serious limitation, given the growing practical and theoretical efforts to extend business process languages with the capability to model complex data objects, along with the traditional control flow perspective [6].", "startOffset": 222, "endOffset": 225}, {"referenceID": 18, "context": "Specifically we will focus on the well established Workflow Nets [20], a particular class of Petri nets that provides the formal foundations of several process models, of the YAWL language and have become one of the standard ways to model and analyze workflows.", "startOffset": 65, "endOffset": 69}, {"referenceID": 16, "context": "a modeling language DAW-net, an extension of the workflow nets with data formalism introduced in [18] so to be able to deal with even more expressive data (Section 3); 2.", "startOffset": 97, "endOffset": 101}, {"referenceID": 0, "context": "Petri Nets (PN) is a modeling language for the description of distributed systems that has widely been applied to the description and analysis of business processes [1].", "startOffset": 165, "endOffset": 168}, {"referenceID": 0, "context": "This imposes syntactic restrictions on PNs, that result in the following definition of a workflow net (WF-net) [1].", "startOffset": 111, "endOffset": 114}, {"referenceID": 9, "context": "From now on we concentrate on 1-safe nets, which generalize the class of structured workflows and are the basis for best practices in process modeling [11].", "startOffset": 151, "endOffset": 155}, {"referenceID": 8, "context": "This reflects the fact that the process control-flow is well-defined (see [10]).", "startOffset": 74, "endOffset": 78}, {"referenceID": 1, "context": "Reachability on PNs (WF-nets) is of enormous importance in process verification as it allows for checking natural behavioral properties, such as satisfiability and soundness in a natural manner [2].", "startOffset": 194, "endOffset": 197}, {"referenceID": 15, "context": "The need for trace repair is motivated in depth in [17], where missing entities are described as a frequent cause of low data quality in event logs, especially when the definition of the business processes integrates activities that are not supported by IT systems due either to their nature (e.", "startOffset": 51, "endOffset": 55}, {"referenceID": 15, "context": "By aligning the trace to the model using a replay-based approach or a planning based approach, the techniques presented in [17] and [8] are able to exploit the events stored in the trace and the control flow specified in the model to reconstruct two possible repairs:", "startOffset": 123, "endOffset": 127}, {"referenceID": 6, "context": "By aligning the trace to the model using a replay-based approach or a planning based approach, the techniques presented in [17] and [8] are able to exploit the events stored in the trace and the control flow specified in the model to reconstruct two possible repairs:", "startOffset": 132, "endOffset": 135}, {"referenceID": 7, "context": "A planning problem inK [9] is specified using a Datalog-like language where fluents and actions are represented by literals (not necessarily ground).", "startOffset": 23, "endOffset": 26}, {"referenceID": 16, "context": "Our framework follows the approach of state-of-the-art WF-nets with data [18,12], from which it borrows the above concepts, extending them by allowing reasoning on actual data values as better explained in Section 6.", "startOffset": 73, "endOffset": 80}, {"referenceID": 10, "context": "Our framework follows the approach of state-of-the-art WF-nets with data [18,12], from which it borrows the above concepts, extending them by allowing reasoning on actual data values as better explained in Section 6.", "startOffset": 73, "endOffset": 80}, {"referenceID": 16, "context": "A number of variants of PNs have been enriched so as to make tokens able to carry data and transitions aware of the data, as in the case of Workflow nets enriched with data [18,12], the model adopted by the business process community.", "startOffset": 173, "endOffset": 180}, {"referenceID": 10, "context": "A number of variants of PNs have been enriched so as to make tokens able to carry data and transitions aware of the data, as in the case of Workflow nets enriched with data [18,12], the model adopted by the business process community.", "startOffset": 173, "endOffset": 180}, {"referenceID": 2, "context": "Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data.", "startOffset": 95, "endOffset": 98}, {"referenceID": 11, "context": "Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data.", "startOffset": 108, "endOffset": 115}, {"referenceID": 10, "context": "Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data.", "startOffset": 108, "endOffset": 115}, {"referenceID": 15, "context": "For example, in [17], the authors exploit stochastic PNs and Bayesian Networks to recover missing information (activities and their durations).", "startOffset": 16, "endOffset": 20}, {"referenceID": 3, "context": "For example, in [5] the same issue of reconstructing missing information has been tackled by reformulating it in terms of a Satisfiability(SAT) problem rather than as a planning problem.", "startOffset": 16, "endOffset": 19}, {"referenceID": 14, "context": ", for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15].", "startOffset": 36, "endOffset": 40}, {"referenceID": 17, "context": ", for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15].", "startOffset": 109, "endOffset": 116}, {"referenceID": 13, "context": ", for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15].", "startOffset": 109, "endOffset": 116}, {"referenceID": 5, "context": "In [7] automated planning techniques have been applied for aligning execution traces and declarative models.", "startOffset": 3, "endOffset": 6}, {"referenceID": 6, "context": "As in this work, in [8], planning techniques have been used for addressing the problem of incomplete execution traces with respect to procedural models.", "startOffset": 20, "endOffset": 23}, {"referenceID": 12, "context": "Moreover, the presented encoding in the planning language K, can be directly adapted to other action languages with an expressiveness comparable to C [14].", "startOffset": 150, "endOffset": 154}, {"referenceID": 10, "context": "Definition 12 (Petri Net [12]).", "startOffset": 25, "endOffset": 29}, {"referenceID": 16, "context": "Definition 13 (WF-net [18]).", "startOffset": 22, "endOffset": 26}, {"referenceID": 0, "context": "In this document we focus on 1-safeness, which is equivalent to the original safeness property as defined in [1].", "startOffset": 109, "endOffset": 112}, {"referenceID": 7, "context": "The formal definition of K can be found in Appendix A of [9]; here, as reference, we include the main concepts.", "startOffset": 57, "endOffset": 60}, {"referenceID": 7, "context": "Definition 18 (Planning domain, [9] Def.", "startOffset": 32, "endOffset": 35}], "year": 2017, "abstractText": "The growing adoption of IT-systems for modeling and executing (business) processes or services has thrust the scientific investigation towards techniques and tools which support more complex forms of process analysis. Many of them, such as conformance checking, process alignment, mining and enhancement, rely on complete observation of past (tracked and logged) executions. In many real cases, however, the lack of human or IT-support on all the steps of process execution, as well as information hiding and abstraction of model and data, result in incomplete log information of both data and activities. This paper tackles the issue of automatically repairing traces with missing information by notably considering not only activities but also data manipulated by them. Our technique recasts such a problem in a reachability problem and provides an encoding in an action language which allows to virtually use any state-of-the-art planning to return solutions.", "creator": "LaTeX with hyperref package"}}}