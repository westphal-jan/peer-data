{"id": "0904.2623", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Apr-2009", "title": "Exponential Family Graph Matching and Ranking", "abstract": "optimal require a simple and difficult function for researchers to rank. landau introduced an interpretation of still more general method for learning max - weight pricing useful in experimental optimization, which seeks enabling statistical optimization. the method consists entirely performing systematic preference posteriori estimation in exponential families where suitable sufficient statistics. we apply spectral method to obtain hierarchical benchmark dataset for learning web page ranking, obtaining state - from - the - art results.", "histories": [["v1", "Fri, 17 Apr 2009 03:48:02 GMT  (51kb,D)", "https://arxiv.org/abs/0904.2623v1", null], ["v2", "Fri, 5 Jun 2009 03:54:58 GMT  (459kb,D)", "http://arxiv.org/abs/0904.2623v2", null]], "reviews": [], "SUBJECTS": "cs.LG cs.AI", "authors": ["james petterson", "tib\u00e9rio s caetano", "julian john mcauley", "jin yu"], "accepted": true, "id": "0904.2623"}, "pdf": {"name": "0904.2623.pdf", "metadata": {"source": "CRF", "title": "Exponential Family Graph Matching and Ranking", "authors": ["James Petterson", "Tib\u00e9rio Caetano", "Julian McAuley", "Jin Yu"], "emails": ["first.last@nicta.com.au"], "sections": [{"heading": "1 Introduction", "text": "The Maximum-Weight Bipartite Matching Problem (henceforth \u2018matching problem\u2019) is a fundamental problem in combinatorial optimization [26]. This is the problem of finding the \u2018heaviest\u2019 perfect match in a weighted bipartite graph. An exact optimal solution can be found in cubic time by standard methods such as the Hungarian algorithm.\nThis problem is of practical interest because it can nicely model real-world applications. For example, in computer vision the crucial problem of finding a correspondence between sets of image features is often modeled as a matching problem [2, 3]. Ranking algorithms can be based on a matching framework [19], as can clustering algorithms [14, 11].\nWhen modeling a problem as one of matching, one central question is the choice of the weight matrix. The problem is that in real applications we typically observe edge feature vectors, not edge weights. Consider a concrete example in computer vision: it\n\u2217NICTA\u2019s Statistical Machine Learning program, Locked Bag 8001, ACT 2601, Australia, and Research School of Information Sciences and Engineering, Australian National University, ACT 0200, Australia. NICTA is funded by the Australian Government\u2019s Backing Australia\u2019s Ability initiative, and the Australian Research Council\u2019s ICT Centre of Excellence program. e-mails: first.last@nicta.com.au\nar X\niv :0\n90 4.\n26 23\nv2 [\ncs .L\nG ]\n5 J\nun 2\nis difficult to tell what the \u2018similarity score\u2019 is between two image feature points, but it is straightforward to extract feature vectors (e.g. SIFT) associated with those points.\nIn this setting, it is natural to ask whether we could parameterize the features, and use labeled matches in order to estimate the parameters such that, given graphs with \u2018similar\u2019 features, their resulting max-weight matches are also \u2018similar\u2019. This idea of \u2018parameterizing algorithms\u2019 and then optimizing for agreement with data is called structured estimation [31, 33].\n[31] and [3] describe max-margin structured estimation formalisms for this problem. Max-margin structured estimators are appealing in that they try to minimize the loss that one really cares about (\u2018structured losses\u2019, of which the Hamming loss is an example). However structured losses are typically piecewise constant in the parameters, which eliminates any hope of using smooth optimization directly. Max-margin estimators instead minimize a surrogate loss which is easier to optimize, namely a convex upper bound on the structured loss [33]. In practice the results are often good, but known convex relaxations produce estimators which are statistically inconsistent [22], i.e., the algorithm in general fails to obtain the best attainable model in the limit of infinite training data. The inconsistency of multiclass support vector machines is a well-known issue in the literature that has received careful examination recently [8, 7].\nMotivated by the inconsistency issues of max-margin structured estimators as well as by the well-known benefits of having a full probabilistic model, in this paper we present a maximum a posteriori (MAP) estimator for the matching problem. The observed data are the edge feature vectors and the labeled matches provided for training. We then maximize the conditional posterior likelihood of matches given the observed data. We build an exponential family model where the sufficient statistics are such that the mode of the distribution (the prediction) is the solution of a max-weight matching problem. The resulting partition function is ]P-complete to compute exactly. However, we show that for learning to rank applications the model instance is tractable. We then compare the performance of our model instance against a large number of state-of-theart ranking methods, including DORM [19], an approach that only differs to our model instance by using max-margin instead of a MAP formulation. We show very competitive results on standard webpage ranking datasets, and in particular we show that our model performs better than or on par with DORM. For intractable model instances, we show that the problem can be approximately solved using sampling and we provide experiments from the computer vision domain. However the fastest suitable sampler is still quite slow for large models, in which case max-margin matching estimators like those of [3] and [31] are likely to be preferable even in spite of their potential inferior accuracy."}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 Structured Prediction", "text": "In recent years, great attention has been devoted in Machine Learning to so-called structured predictors, which are predictors of the kind\ng\u03b8 : X 7\u2192 Y, (1)\nwhere X is an arbitrary input space and Y is an arbitrary discrete space, typically exponentially large. Y may be, for example, a space of matrices, trees, graphs, sequences, strings, matches, etc. This structured nature of Y is what structured prediction refers to. In the setting of this paper, X is the set of vector-weighted bipartite graphs (i.e., each edge has a feature vector associated to it), and Y is the set of perfect matches induced by X. IfN graphs are available, along with corresponding annotated matches (i.e., a set {(xn, yn)}Nn=1), our task will be to estimate \u03b8 such that when we apply the predictor g\u03b8 to a new graph it produces a match that is similar to matches of similar graphs from the annotated set. Structured learning or structured estimation refers to the process of estimating a vector \u03b8 for predictor g\u03b8 when data {(x1, y1), . . . , (xN , yN )} \u2208 (X\u00d7Y)N are available. Structured prediction for input xmeans computing y = g(x; \u03b8) using the estimated \u03b8.\nTwo generic estimation strategies have been popular in producing structured predictors. One is based on max-margin estimators [33, 32, 31], and the other on maximumlikelihood (ML) or MAP estimators in exponential family models [18].\nThe first approach is a generalization of support vector machines to the case where the set Y is structured. However the resulting estimators are known to be inconsistent in general: in the limit of infinite training data the algorithm fails to recover the best model in the model class [22, 7, 8]. McAllester recently provided an interesting analysis on this issue, where he proposed new upper bounds whose minimization results in consistent estimators, but no such bounds are convex [22]. The other approach uses ML or MAP estimation in conditional exponential families with \u2018structured\u2019 sufficient statistics, such as in probabilistic graphical models, where they are decomposed over the cliques of the graph (in which case they are called Conditional Random Fields, or CRFs [18]). In the case of tractable graphical models, dynamic programming can be used to efficiently perform inference. Other tractable models of this type include models that predict spanning trees and models that predict binary labelings in planar graphs [9, 17]. ML and MAP estimators in exponential families not only amount to solving an unconstrained and convex optimization problem; in addition they are statistically consistent. The main problem with these types of models is that often the partition function is intractable. This has motivated the use of max-margin methods in many scenarios where such intractability arises."}, {"heading": "2.2 The Matching Problem", "text": "Consider a weighted bipartite graph with m nodes in each part, G = (V,E,w), where V is the set of vertices, E is the set of edges and w : E 7\u2192 R is a set of real-valued weights associated to the edges. G can be simply represented by a matrix (wij) where\nto attain the graph G = (V,E,w). See Figure 1 for an illustration.\nGx G\ni j i j xij wij = \u3008xij , \u03b8\u3009\nFigure 1. Left: Illustration of an input vector-weighted bi-\npartite graph Gx with 3 \u00d7 3 edges. There is a vector xe\nassociated to each edge e (for clarity only xij is shown,\ncorresponding to the solid edge). Right: weighted bipar-\ntite graph G obtained by evaluating Gx on the learned\nvector \u03b8 (again only edge ij is shown).\n{X,Y } = {(x1, y1), . . . , (xN , yN )} is available, for n = 1, 2, . . . , N (where xn := (xn11, x n 12 . . . , x n M(n)M(n))). Here M(n) is the number of nodes in each part of the vector-weighted bipartite graph xn. We then parameterize xij as wiy(i) = f(xiy(i); \u03b8), and the goal is to find the \u03b8 which maximizes the posterior likelihood of the observed data. We will assume f to be bilinear, i.e. f(xiy(i); \u03b8) = \u2329 xiy(i), \u03b8 \u232a .\n3.2. Exponential Family Model\nWe assume an exponential family model, where the probability model is\np(y|x; \u03b8) = exp (\u3008\u03c6(x, y), \u03b8\u3009 \u2212 g(x; \u03b8)), (3)\nwhere\ng(x; \u03b8) = log \u2211\ny\nexp \u3008\u03c6(x, y), \u03b8\u3009 (4)\nis the log-partition function, which is a convex and differentiable function of \u03b8 (Wainwright & Jordan, 2003).\nThe prediction in this model is the most likely y, i.e.\ny\u2217 = argmax y p(y|x; \u03b8) = argmax y \u3008\u03c6(x, y), \u03b8\u3009 (5)\nand ML estimation amounts to maximizing the conditional likelihood of a sample {X,Y }, i.e. computing argmax\u03b8 p(Y |X; \u03b8). In practice we will in general introduce a prior on \u03b8 and perform MAP estimation:\n\u03b8\u2217 = argmax \u03b8 p(Y |X; \u03b8)p(\u03b8) = argmax \u03b8 p(\u03b8|Y,X). (6)\nAssuming iid sampling, we have p(Y |X; \u03b8) =\n\u220fN n=1 p(y n|xn; \u03b8). Therefore,\np(\u03b8|Y,X) \u221d p(\u03b8) N\u220f\nn=1\nexp (\u3008\u03c6(xn, yn), \u03b8\u3009 \u2212 g(xn; \u03b8))\n= exp ( log p(\u03b8) + N\u2211\nn=1\n(\u3008\u03c6(xn, yn), \u03b8\u3009 \u2212 g(xn; \u03b8)) ) .\n(7)\nWe impose a Gaussian prior on \u03b8. Instead of maximizing the posterior we can instead minimize the negative\nlog-posterior `(Y |X; \u03b8), which becomes our loss func-\ntion (we suppress the constant term):\n`(Y |X; \u03b8) =\u03bb\n2\n\u2016\u03b8\u20162 + 1\nN\nN\u2211\n(g(xn; \u03b8)\u2212 \u3008\u03c6(xn, yn), \u03b8\u3009)\nwhere \u03bb is a regularization constant. `(Y |X; \u03b8) is a convex function of \u03b8 since the log-partition function g(\u03b8) is a convex function of \u03b8 (Wainwright & Jordan, 2003) and the other terms are clearly convex in \u03b8.\n3.3. Feature Parameterization\nThe critical observation now is that we equate the solution of the matching problem (2) to the prediction of the exponential family model (5), i.e. \u2211 i wiy(i) = \u3008\u03c6(x, y), \u03b8\u3009. Since our goal is to parameterize features of individual pairs of nodes (so as to produce the weight of an edge), the most natural model is\n\u03c6(x, y) = M\u2211\ni=1\nxiy(i), which gives (9)\nwiy(i) = \u2329 xiy(i), \u03b8 \u232a , (10)\ni.e. linear in both x and \u03b8 (see Figure 1, right). The specific form for xij will be discussed in the experimental section. In light of (10), (2) now clearly means a prediction of the best match for Gx under the model \u03b8.\n4. Learning the Model\n4.1. Basics\nWe need to solve \u03b8\u2217 = argmin\u03b8 `(Y |X; \u03b8). `(Y |X; \u03b8) is a convex and differentiable function of \u03b8 (Wainwright & Jordan, 2003), therefore gradient descent will find the global optimum. In order to compute\u2207\u03b8`(Y |X; \u03b8), we need to compute \u2207\u03b8g(\u03b8). It is a standard result of exponential families that the gradient of the logpartition function is the expectation of the sufficient statistics:\n\u2207\u03b8g(x; \u03b8) = Ey\u223cp(y|x;\u03b8)[\u03c6(x, y)]. (11)\nthe entrywij is the weight of the edge ij. Consider also bij ction y : {1, 2, . . . ,m} 7\u2192 {1, 2, . . . ,m}, i.e., a permutation. Then the matching problem consists of computing\ny\u2217 = argmax y\nm\u2211\ni=1\nwiy(i). (2)\nThis is a well-studied problem; it is tractable and can be solved inO(m3) tim [16, 26]. This model can be used to match features in images [3], improve classification algorithms [11] and rank webpages [19], to cite a few applications. The typical setting consists of engineering the score matrix wij according to domain knowledge and subsequently solving the combinatorial problem."}, {"heading": "3 The Model", "text": ""}, {"heading": "3.1 Basic Goal", "text": "In this paper we assume that the weights wij are instead to be estimated from training data. More precisely, the weight wij associ ted to he edge ij in a graph will be the result of an appropriate composition of a feature vector xij (observed) and a parameter vector \u03b8 (estimated from training data). Therefore, in practice, our input is a vectorweighted bipartite graph Gx = (V,E, x) (x : E 7\u2192 Rn which is \u2018evaluated\u2019 at a particular \u03b8 (obtained from previous training) so as to attain the graph G = (V,E,w). See Figure 1 for an illustration.\nMore formally, assume that a training set {X, = {(xn, yn)}Nn=1 is available, where xn := (xn11, x n 12 . . . , x n M(n)M(n)). Here M(n) is the number of nodes in each part of the vector-weighted bipartite graph xn. We then parameterize xij as wiy(i) = f(xiy(i); \u03b8), and the goal is to find the \u03b8 which maximizes the posterior likelihood of the observed data. We will assume f to be bilinear, i.e., f(xiy(i); \u03b8) = \u2329 xiy(i), \u03b8 \u232a ."}, {"heading": "3.2 Exponential Family Model", "text": "We assume an exponential family model, where the probability model is\np(y|x; \u03b8) = exp (\u3008\u03c6(x, y), \u03b8\u3009 \u2212 g(x; \u03b8)), where (3)\ng(x; \u03b8) = log \u2211\ny\nexp \u3008\u03c6(x, y), \u03b8\u3009 (4)\nis the log-partition function, which is a convex and differentiable function of \u03b8 [35]. The prediction in this model is the most likely y, i.e.,\ny\u2217 = argmax y p(y|x; \u03b8) = argmax y \u3008\u03c6(x, y), \u03b8\u3009 (5)\nand ML estimation amounts to maximizing the conditional likelihood of the training set {X,Y }, i.e., computing argmax\u03b8 p(Y |X; \u03b8). In practice we will in general introduce a prior on \u03b8 and perform MAP estimation:\n\u03b8\u2217 = argmax \u03b8 p(Y |X; \u03b8)p(\u03b8) = argmax \u03b8 p(\u03b8|Y,X). (6)\nAssuming iid sampling, we have p(Y |X; \u03b8) =\u220fNn=1 p(yn|xn; \u03b8). Therefore,\np(\u03b8|Y,X) \u221d p(\u03b8) N\u220f\nn=1\nexp (\u3008\u03c6(xn, yn), \u03b8\u3009 \u2212 g(xn; \u03b8))\n= exp ( log p(\u03b8) + N\u2211\nn=1\n(\u3008\u03c6(xn, yn), \u03b8\u3009 \u2212 g(xn; \u03b8)) ) . (7)\nWe impose a Gaussian prior on \u03b8. Instead of maximizing the posterior we can instead minimize the negative log-posterior `(Y |X; \u03b8), which becomes our loss function (we suppress the constant term):\n`(Y |X; \u03b8) =\u03bb 2 \u2016\u03b8\u20162 + 1 N\nN\u2211\nn=1\n(g(xn; \u03b8)\u2212 \u3008\u03c6(xn, yn), \u03b8\u3009) (8)\nwhere \u03bb is a regularization constant. `(Y |X; \u03b8) is a convex function of \u03b8 since the logpartition function g(\u03b8) is a convex function of \u03b8 [35] and the other terms are clearly convex in \u03b8."}, {"heading": "3.3 Feature Parameterization", "text": "The critical observation now is that we equate the solution of the matching problem (2) to the prediction of the exponential family model (5), i.e., \u2211 i wiy(i) = \u3008\u03c6(x, y), \u03b8\u3009.\nSince our goal is to parameterize features of individual pairs of nodes (so as to produce the weight of an edge), the most natural model is\n\u03c6(x, y) = M\u2211\ni=1\nxiy(i), which gives (9)\nwiy(i) = \u2329 xiy(i), \u03b8 \u232a , (10)\ni.e., linear in both x and \u03b8 (see Figure 1, right). The specific form for xij will be discussed in the experimental section. In light of (10), (2) now clearly means a prediction of the best match for Gx under the model \u03b8."}, {"heading": "4 Learning the Model", "text": ""}, {"heading": "4.1 Basics", "text": "We need to solve \u03b8\u2217 = argmin\u03b8 `(Y |X; \u03b8). `(Y |X; \u03b8) is a convex and differentiable function of \u03b8 [35], therefore gradient descent will find the global optimum. In order to compute \u2207\u03b8`(Y |X; \u03b8), we need to compute \u2207\u03b8g(\u03b8). It is a standard result of exponential families that the gradient of the log-partition function is the expectation of the sufficient statistics:\n\u2207\u03b8g(x; \u03b8) = Ey\u223cp(y|x;\u03b8)[\u03c6(x, y)]. (11)\nTherefore in order to perform gradient descent we need to compute the above expectation. Opening the above expression gives\nEy\u223cp(y|x;\u03b8)[\u03c6(x, y)] = \u2211\ny\n\u03c6(x, y)p(y|x; \u03b8) (12)\n= 1\nZ(x; \u03b8)\n\u2211\ny\n\u03c6(x, y) M\u220f\ni=1\nexp( \u2329 xiy(i), \u03b8 \u232a ), (13)\nwhich reveals that the partition function Z(x; \u03b8) needs to be computed. The partition function is:\nZ(x; \u03b8) = \u2211\ny\nM\u220f\ni=1\nexp( \u2329 xiy(i), \u03b8 \u232a ) \ufe38 \ufe37\ufe37 \ufe38 =:Biy(i) . (14)\nNote that the above is the expression for the permanent of matrix B [23]. The permanent is similar in definition to the determinant, the difference being that for the latter sgn(y) comes before the product. However, unlike the determinant, which is computable efficiently and exactly by standard linear algebra manipulations [17], computing the permanent is a ]P-complete problem [34]. Therefore we have no realistic hope of computing (11) exactly for general problems."}, {"heading": "4.2 Exact Expectation", "text": "The exact partition function itself can be efficiently computed for up to about M = 30 using the O(M2M ) algorithm by Ryser [29]. However for arbitrary expectations we are not aware of any exact algorithm which is more efficient than full enumeration (which would constrain tractability to very small graphs). However we will see that even in the case of very small graphs we find a very important application: learning to rank. In our experiments, we successfully apply a tractable instance of our model to benchmark webpage ranking datasets, obtaining very competitive results. For larger graphs, we have alternative options as indicated below."}, {"heading": "4.3 Approximate Expectation", "text": "If we have a situation in which the set of feasible permutations is too large to be fully enumerated efficiently, we need to resort to some approximation for the expectation of the sufficient statistics. The best solution we are aware of is one by Huber and Law, who recently presented an algorithm to approximate the permanent of dense non-negative matrices [13]. The algorithm works by producing exact samples from the distribution of perfect matches on weighted bipartite graphs. This is in precisely the same form as the distribution we have here, p(y|x; \u03b8) [13]. We can use this algorithm for applications that involve larger graphs.1 We generateK samples from the distribution p(y|x; \u03b8), and directly approximate (12) with a Monte Carlo estimate\nEy\u223cp(y|x;\u03b8)[\u03c6(x, y)] \u2248 1 K\nK\u2211\ni=1\n\u03c6(x, yi). (15)\nIn our experiments, we apply this algorithm to an image matching application."}, {"heading": "5 Experiments", "text": ""}, {"heading": "5.1 Ranking", "text": "Here we apply the general matching model introduced in previous sections to the task of learning to rank. Ranking is a fundamental problem with applications in diverse areas such as document retrieval, recommender systems, product rating and others. We focus on web page ranking.\nWe are given a set of queries {qk} and, for each query qk, a list of D(k) documents {dk1 , . . . , dkD(k)} with corresponding ratings {rk1 , . . . , rkD(k)} (assigned by a human editor), measuring the relevance degree of each document with respect to query qk. A rating or relevance degree is usually a nominal value in the list {1, . . . , R}, where R is typically between 2 and 5. We are also given, for every retrieved document dki , a joint feature vector \u03c8ki for that document and the query qk.\nTraining At training time, we model each query qk as a vector-weighted bipartite graph (Figure 1) where the nodes on one side correspond to a subset of cardinalityM of\n1The algorithm is described in the appendix.\nall D(k) documents retrieved by the query, and the nodes on the other side correspond to all possible ranking positions for these documents (1, . . . ,M ). The subset itself is chosen randomly, provided at least one exemplar document of every rating is present. Therefore M must be such that M \u2265 R.\nThe process is then repeated in a bootstrap manner: we resample (with replacement) from the set of documents {dk1 , . . . , dkD(k)},M documents at a time (conditioned on the fact that at least one exemplar of every rating is present, but otherwise randomly). This effectively boosts the number of training examples since each query qk ends up being selected many times, each time with a different subset of M documents from the original set of D(k) documents.\nIn the following we drop the query index k to examine a single query. Here we follow the construction used in [19] to map matching problems to ranking problems (indeed the only difference between our ranking model and that of [19] is that they use a max-margin estimator and we use MAP in an exponential family.) Our edge feature vector xij will be the product of the feature vector \u03c8i associated with document i, and a scalar cj (the choice of which will be explained below) associated with ranking position j\nxij = \u03c8icj . (16)\n\u03c8i is dataset specific (see details below). From (10) and (16), we havewij = cj \u3008\u03c8i, \u03b8\u3009, and training proceeds as explained in Section 4.\nTesting At test time, we are given a query q and its corresponding list of D associated documents. We then have to solve the prediction problem, i.e.,\ny\u2217 = argmax y\nD\u2211\ni=1\n\u2329 xiy(i), \u03b8 \u232a = argmax\ny\nD\u2211\ni=1\ncy(i) \u3008\u03c8i, \u03b8\u3009 . (17)\nWe now notice that if the scalar cj = c(j), where c is a non-increasing function of rank position j, then (17) can be solved simply by sorting the values of \u3008\u03c8i, \u03b8\u3009 in decreasing order.2 In other words, the matching problem becomes one of ranking the values \u3008\u03c8i, \u03b8\u3009. Inference in our model is therefore very fast (linear time).3 In this setting it makes sense to interpret the quantity \u3008\u03c8i, \u03b8\u3009 as a score of document di for query q. This leaves open the question of which non-increasing function c should be used. We do not solve this problem in this paper, and instead choose a fixed c. In theory it is possible to optimize over c during learning, but in that case the optimization problem would no longer be convex. We describe the results of our method on LETOR 2.0 [20], a publicly available benchmark data collection for comparing learning to rank algorithms. It is comprised of three data sets: OHSUMED, TD2003 and TD2004.\nData sets OHSUMED contains features extracted from query-document pairs in the OHSUMED collection, a subset of MEDLINE, a database of medical publications. It contains 106 queries. For each query there are a number of associated documents, with relevance degrees judged by humans on three levels: definitely, possibly or not\n2If r(v) denotes the vector of ranks of entries of vector v, then \u3008a, \u03c0(b)\u3009 is maximized by the permutation \u03c0\u2217 such that r(a) = r(\u03c0\u2217(b)), a theorem due to Polya, Littlewood, Hardy and Blackwell [30].\n3Sorting the top k items of a list of D items takes O(k log k +D) time [21].\nrelevant. Each query-document pair is associated with a 25 dimensional feature vector, \u03c8i. The total number of query-document pairs is 16,140. TD2003 and TD2004 contain features extracted from the topic distillation tasks of TREC 2003 and TREC 2004, with 50 and 75 queries, respectively. Again, for each query there are a number of associated documents, with relevance degrees judged by humans, but in this case only two levels are provided: relevant or not relevant. Each query-document pair is associated with a 44 dimensional feature vector, \u03c8i. The total number of query-document pairs is 49,171 for TD2003 and 74,170 for TD2004. All datasets are already partitioned for 5-fold cross-validation. See [20] for more details.\nEvaluation Metrics In order to measure the effectiveness of our method we use the normalized discount cumulative gain (NDCG) measure [15] at rank position k, which is defined as\nNDCG@k = 1 Z\nk\u2211\nj=1\n2r(j) \u2212 1 log(1 + j) , (18)\nwhere r(j) is the relevance of the jth document in the list, and Z is a normalization constant so that a perfect ranking yields an NDCG score of 1.\nExternal Parameters The regularization constant \u03bb is chosen by 5-fold crossvalidation, with the partition provided by the LETOR package. All experiments are repeated 5 times to account for the randomness of the sampling of the training data. We use c(j) = M \u2212 j on all experiments.\nOptimization To optimize (8) we use a standard BFGS Quasi-Newton method with a backtracking line search, as described in [25].\nResults For the first experiment training was done on subsets sampled as described above, where for each query qk we sampled 0.4 \u00b7D(k) \u00b7M subsets, therefore increasing\nthe number of samples linearly with M . For TD2003 we also trained with all possible subsets (M = 2(all) in the plots). In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27]. We also included a plot of our implementation of DORM [19], using precisely the same resampling methodology and data for a fair comparison. RankMatch performs among the best methods on both TD2004 and OHSUMED, while on TD2003 it performs poorly (for low k) or fairly well (for high k).\nWe notice that there are four methods which only report results in two of the three datasets: the two SortNet versions are only reported on TD2003 and TD2004, while StructRank and C-CRF are only reported on TD2004 and OHSUMED. RankMatch compares similarly with SortNet and StructRank on TD2004, similarly to C-CRF and StructRank on OHSUMED and similarly to the two versions of SortNet on TD2003. This exhausts all the comparisons against the methods which have results reported in only two datasets. A fairer comparison could be made if these methods had their performance published for the respective missing dataset.\nWhen compared to the methods which report results in all datasets, RankMatch entirely dominates their performance on TD2004 and is second only to IsoRank on OHSUMED (and performing similarly to QBRank).\nThese results should be interpreted cautiously; [24] presents an interesting discussion about issues with these datasets. Also, benchmarking of ranking algorithms is still in its infancy and we don\u2019t yet have publicly available code for all of the competitive methods. We expect this situation to change in the near future so that we are able to compare them on a fair and transparent basis.\nConsistency In a second experiment we trained RankMatch with different training subset sizes, starting with 0.03 \u00b7D(k) \u00b7M and going up to 1.0 \u00b7D(k) \u00b7M . Once again, we repeated the experiments with DORM using precisely the same training subsets. The purpose here is to see whether we observe a practical advantage of our method with increasing sample size, since statistical consistency only provides an asymptotic indication. The results are plotted in Figure 3-right, where we can see that, as more training data is available, RankMatch improves more saliently than DORM.\nRuntime The runtime of our algorithm is competitive with that of max-margin for small graphs, such as those that arise from the ranking application. For larger graphs, the use of the sampling algorithm will result in much slower runtimes than those typically obtained in the max-margin framework. This is certainly the benefit of the max-margin matching formulations of [3, 19]: it is much faster for large graphs. Table 1 shows the runtimes for graphs of different sizes, both for exponential family and max-margin matching models."}, {"heading": "5.2 Image Matching", "text": "For our computer vision application we used a silhouette image from the Mythological Creatures 2D database4. We randomly selected 20 points on the silhouette as our interest points and applied shear to the image creating 200 different images. We then randomly selected N pairs of images for training, N for validation and 500 for testing, and trained our model to match the interest points in the pairs. In this setup,\nxij = |\u03c8i \u2212 \u03c8j |2, (19)\nwhere |\u00b7| denotes the elementwise difference and \u03c8i is the Shape Context feature vector [1] for point i.\nFor a graph of this size computing the exact expectation is not feasible, so we used the sampling method described in Section 4.3. Once again, the regularization constant \u03bb was chosen by cross-validation. Given the fact that the MAP estimator is consistent while the max-margin estimator is not, one is tempted to investigate the practical performance of both estimators as the sample size grows. However, since consistency is only an asymptotic property, and also since the Hamming loss is not the criterion optimized by either estimator, this does not imply a better large-sample performance of MAP in real experiments. In any case, we present results with varying training set sizes in Figure 3-left. The max-margin method is that of [3]. After a sufficiently large training set size, our model seems to enjoy a slight advantage."}, {"heading": "6 Conclusion and Discussion", "text": "We presented a method for learning max-weight bipartite matching predictors, and applied it extensively to well-known webpage ranking datasets, obtaining state-of-the-art results. We also illustrated\u2013with an image matching application\u2013that larger problems can also be solved, albeit slowly, with a recently developed sampler. The method has a number of convenient features. First, it consists of performing maximum-a-posteriori estimation in an exponential family model, which results in a simple unconstrained convex optimization problem solvable by standard algorithms such as BFGS. Second,\n4http://tosca.cs.technion.ac.il\n0 50 100 150 200 250 300 350 400 450 500 0.08\n0.1\n0.12\n0.14\n0.16\n0.18\n0.2\nnumber of training pairs\ner ro\nr\nexponential model max margin\ngrows. However, since consistency is only an asymptotic property, and also since the Hamming loss is not the criterion optimized by either estimator, this does not imply a better large-sample performance of MAP in real experiments. In any case, we present results with varying training set sizes in Figure 2. In Figure ?? we can see an example of a match with and without learning. The max-margin method is that of [?]. The methods perform almost identically after a sufficiently large training set size, although the experiment was truncated at 500 training/testing pairs due to computational overload. (The dataset has in total about 20,000 different image pairs.)\n0 50 100 150 200 250 300 350 400 450 500\n0.08\n0.1\n0.12\n0.14\n0.16\n0.18\n0.2\nnumber of training pairs\ner ro\nr\nmax margin exponential model\nFigure 3: Left: match without learning (6/20 correct matches). Right: match with learning (14/20\ncorrect matches)\nand training of \u03b8 proceeds as explained in Section 4.\nTesting At test time, we are given a query q and its corresponding list of D associated documents. We then have to solve the prediction problem, i.e.\ny\u2217 = argmax y D\u2211 i=1 \u2329 xiy(i), \u03b8 \u232a (19a)\n= argmax y D\u2211 i=1 cy(i) \u3008\u03c8i, \u03b8\u3009 . (19b)\nWe now notice that if the scalar cj = c(j), where c is a non-increasing function of rank position j, then (19b) can be solved simply by sorting the values of \u3008\u03c8i, \u03b8\u3009 in decreasing order.3 In other words, the matching problem becomes one of ranking the values \u3008\u03c8i, \u03b8\u3009. Inference in our model is therefore very fast (linear time).4 In this setting it makes sense to interpret the quantity \u3008\u03c8i, \u03b8\u3009 as a score of document di for query q. This leaves open the question of which non-increasing function c should be used. We do not solve this problem in this paper, and instead choose a fixed c. In theory it is possible to optimize over c during learning, but in that case the optimization problem would no longer be convex. We describe the results of our method on LETOR 2.0 [22], a publicly available benchmark data collection for comparing learning to rank algorithms. It is comprised of three data sets: OHSUMED, TD2003 and TD2004.\nData sets OHSUMED contains features extracted from query-document pairs in the OHSUMED collection, a subset of MEDLINE, a database of medical publications. It contains 106 queries. For each query there are a number of associated documents, with relevance degrees judged by humans on three levels: definitely, possibly or not relevant. Each query-document pair has a 25 dimensional feature vector associated (our \u03c8i). The total number of query-document pairs is 16,140. TD2003 and TD2004 contain features extracted from the topic distillation tasks of TREC 2003 and TREC 2004, with 50 and 75 queries respectively. Again, for each query there are a number of associated documents, with relevance degrees judged by humans, but in this case only two levels are provided: relevant or not relevant. Each query-document pair has a 44 dimensional feature vector associated (our \u03c8i). The total number of query-document pairs is 49,171 for TD2003 and 74,170 for TD2004. All datasets are already partitioned for 5-fold cross-validation. See [22] for more detail.\nEvaluation Metrics In order to measure the effectiveness of our method we use the normalized discount cumulative gain (NDCG) measure [16] at rank position k, which is defined as\nNDCG@k = 1 Z k\u2211 j=1 2r(j) \u2212 1 log(1 + j) , (20)\nwhere r(j) is the relevance of the jth document in the list, and Z is a normalization constant so that a perfect ranking yields an NDCG score of 1.\n3If r(v) denotes the vector of ranks of entries of vector v, then \u3008a, \u03c0(b)\u3009 is maximized by the permutation \u03c0\u2217 such that r(a) = r(\u03c0\u2217(b)), a theorem due to Polya, Littlewood, Hardy and Blackwell [31].\n4Sorting the top k items of a list of D items takes O(k log k +D) time with a quicksort-style agorithm.\nFigure 2: Learning image matching: hamming loss for different number of raining pairs (test set\nsize fixed to 500 pairs).\n5.2 Ranking\nHer we apply the general matching model introduced in revious sections to the task of learning to rank. Ranking is a fundamental problem with applications in diverse areas such as document retrieval, recommender systems, product rating and others. We are going to focus on web page ranking.\nFor this problem we are given a set of queries {qk} and, for each query qk, a list of D(k) documents {dk1 , . . . , dkD(k)} with corresponding ratings {rk1 , . . . , rkD(k)} (assigned by a human editor), measuring the relevance degree of each document with respect to query qk. A rating or relevance degree is usually a nominal value in the list {1, . . . , R}, where R is typically between 2 and 5. We are also given, for every retrieved document dki , a joint feature vector \u03c8 k i for that document and the query qk.\nTraining At training time, we model each query qk as a vector-weighted bipartite graph (Figure 1) where the nodes on one side correspond to a subset of cardinality M of all D(k) documents retrieved by the query, and the nodes on the other side correspond to all possible ranking positions for these documents (1, . . . ,M ). The subset itself is chosen randomly, provided at least one exemplar document of every rating is present. Therefore M must be such that M \u2265 R. Th process is then r peated in a bootstrap manner: we res mple (with replacement) from the set of documents { k1 , . . . , dkD(k)}, M documents at a time (conditioned on the fact that at least one\n6\n10 \u22121\n10 0\n0.53\n0.535\n0.54\n0.545\n0.55\n0.555\n0.56\n0.565\n0.57\nsample size (x M D)\nN D\nC G\n\u2212 1\nOHSUMED\nRankMatch DORM\nFigure 2: Learning image matching. Left: hamming loss for different numbers of training pairs (test set size fixed to 500 pairs). Right: an example match from the test set (blue are correct and red incorrect matches).\nretrieval, recommender systems, product rating and others. We are going to focus on web page ranking.\nFor this problem we are given a set of queries {qk} and, for each query qk, a list of D(k) documents {dk1 , . . . , dkD(k)} with corresponding ratings {rk1 , . . . , rkD(k)} (assigned by a human editor), measuring the relevance degree of each document with respect to query qk. A rating or relevance degree is\nusually a nominal value in the list {1, . . . , R}, where R is typically between 2 and 5. We are also\ngiven, for every retrieved document dki , a joint feature vector \u03c8\nk\ni for that document and the query\nqk.\nTraining At training time, we model each query qk as a vector-weighted bipartite graph (Figure 1) where the nodes on one side correspond to a subset of cardinality M of all D(k) documents retrieved by the query, and the nodes on the other side correspond to all possible ranking positions for these documents (1, . . . ,M ). The subset itself is chosen randomly, provided at least one exemplar document of every rating is present. Therefore M must be such that M \u2265 R. The process is then repeated in a bootstrap manner: we resample (with replacement) from the set of documents {dk1 , . . . , dkD(k)}, M d cuments at a ti e (conditioned on the fact that at least one exemplar of every rating is present, but otherwise randomly). This effectively boosts the number of training examples since each query qk ends up being selected many times, each time with a different subset of M documents from the original set of D(k) documents.\nIn the following we drop the query index k since we examine a single query. Here we follow the construction used in [21] to map matching problems to ranking problems. (Indeed the only difference between our ranking model and that of [21] is that they use a max-margin estimator and we use MAP in an exponential family.) Our edge feature vector xij will be the product of feature vector \u03c8i associated with document i, and a scala cj (the choice of which will be explained below) associated with ranking position j\nxij = \u03c8icj . (17)\n\u03c8i is dataset specific (details below).\nWe therefore have from (10) and (17) that\nwij = cj \u3008\u03c8i, \u03b8\u3009 , (18)\nand training of \u03b8 proceeds as explained in Secti n 4.\n6\nFigure 3: Performance with increasing sample size. Left: hamming loss for different numbers of training pairs in the image matching problem (test set size fixed to 500 p rs). Right: results of NDCG@1 on the ranking dataset OHSUMED. This evidence is in agreement with the fact that our estimator is consistent, while max-margin is not.\nthe estimator is not only statistically consistent but also in practice it seems to benefit\nmore from increasing sample sizes than its max-margin alternative. Finally, being fully\nprobabilistic, the model can be easily integrated as a module in a Bayesian framework,\nfor example. The main direction for future research consists of finding more efficient ways to solve large problems. This will most likely arise from appropriate exploitation of data sparsity in the permutation group."}, {"heading": "Appendix A", "text": "For completeness we include a description of the sampling algorithm presented in [13]. The algorithm is an accept-reject algorithm. The core idea of such an algorithm is very simple: assume we need to sample from a distribution p in a given domain M, but that such a task is intractable. Instead, we sample from a distribution q in a superset N of the original domain (in which sampling is easier), whose restriction to the original domain coincides with the original distribution: q|\nN = p. We then only \u2018accept\u2019 those\nsamples that effectively fall within the original domain M. Clearly, the efficiency of such a procedure will be dictated by (i) how efficient it is to sample from q in N and\n(ii) how much mass of q is in M. Roughly speaking, the algorithm presented in [13] manages to sample perfect matches of bipartite graphs such that both conditions (i) and (ii) are favorable.\nThe reasoning goes as follows: the problem consists of generating variates y \u2208 Y (y is a match) with the property that p(y) = w(y)/Z, where w(y) is the nonnegative score of match y and Z = \u2211 y w(y) is the partition function, which in our case is a permanent as discussed in Section 4.1. We first partition the space Y into Y1, . . . ,YI , where Yi = {y : y(1) = i}. Each part has its own partition function Zi = \u2211 y\u2208Yi w(y). Next, a suitable upper bound U(Yi) \u2265 Zi on the partition function is constructed such that the following two properties hold:5\n(P1) M\u2211\ni=1\nU(Yi) \u2264 U(Y).\n(P2) If |Yi| = 1, then U(Yi) = Zi = w(y).\nThat is, (i) the upper bound is super-additive in the elements of the partition and (ii) if Yi has a single match, the upper bound equals the partition function, which in this case is just the score of that match.\nNow the algorithm: consider the random variable I where p(I = i) = U(Yi)/U(Y). By (P1), \u2211M i=1 p(i) \u2264 1, so assume p(I = 0) = 1 \u2212 \u2211M i=1 p(i). Now, draw a variate from this distribution, and if I = i = 0, reject and restart, otherwise recursively sample in Yi.6 This algorithm either stops and restarts or it reaches Yfinal which consists of a match, i.e., |Yfinal| = 1. This match is then a legitimate sample from p(y). The reason this is the case is because of (P2), as shown below. Assuming the algorithm finishes after k samples, the probability of the match is the telescopic product\nU(YI(1)) U(Y) U(YI(2)) U(YI(1)) . . . U(YI(k)) U(YI(k\u22121)) (P2) = w(y) U(Y) , (20)\nand since the probability of acceptance is Z/U(Y), we have\np(y) = w(y)/U(Y) Z/U(Y) = w(y) Z , (21)\nwhich is indeed the distribution from which we want to sample. For pseudocode and a rigorous presentation of the algorithm, see [13].\n5See [13] for details. 6Due to the self-reducibility of permutations, when we fix y(1) = i, what remains is also a set of\npermutations. We then sample y(2), y(3) . . . y(M)."}], "references": [{"title": "Matching with shape contexts. CBAIVL00", "author": ["S. Belongie", "J Malik"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2000}, {"title": "Shape matching and object recogniti n sing shape contexts", "author": ["S. Belongie", "J. Malik", "J. Puzicha"], "venue": "IEEE Trans. on PAMI,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2002}, {"title": "Learning graph matching", "author": ["T.S. Caetano", "L. Cheng", "Q.V. Le", "A.J. Smola"], "venue": "IEEE Trans. on PAMI,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "Learning to rank: from pairwise approach to listwise approach", "author": ["Z. Cao", "T. Qin", "Liu", "T.-Y", "Tsai", "M.-F", "H. Li"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2007}, {"title": "Frank: A ranking method with fidelity", "author": ["M. Tsai", "T. Liu", "T. Qin", "H. Chen", "W. Ma"], "venue": "loss. SIGIR", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2007}, {"title": "An efficient boosting algorithm for combining preferences", "author": ["Y. Freund", "R. Iy r", "R.E. S apir", "Y. Singer"], "venue": "J. Mach. Learn. Res.,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "Multicategory \u03c8-learning and support vector machine", "author": ["Y. Liu", "X. Shen"], "venue": "Computational tools. J. Computational and Graphical Statistics,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "Approximate inference using planar graph decomposition", "author": ["A. Globerson", "T. Jaakkola"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "Large margin rank boundaries for ordinal regression", "author": ["A. Herbrich", "T. Graepel", "K. Obermayer"], "venue": "In Advances in Large Margin Classifiers", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2000}, {"title": "Loopy belief propagation for bipartite maximum weight b-matching. AISTATS", "author": ["B. Huang", "T. Jebara"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2007}, {"title": "Structured ranking learning using cumulative distribution networks", "author": ["J.C. Huang", "B.J. Frey"], "venue": "In NIPS", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2008}, {"title": "Fast approximation of the permanent for very dense problems", "author": ["M. Huber", "J. Law"], "venue": "SODA. 7,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2008}, {"title": "B-matching for spectral clustering. ECML", "author": ["T. Jebara", "V. Shchogolev"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2006}, {"title": "Cumulated gain-based evaluation of ir techniques", "author": ["K. Jarvelin", "J. Kekalainen"], "venue": "ACM Transactions on Information Systems,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2002}, {"title": "A shortest augmenting path algorithm for dense and sparse linear assignment problems", "author": ["R. Jonker", "A. Volgenant"], "venue": null, "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1987}, {"title": "Structured prediction models via the matrix-tree", "author": ["T. Koo", "A. Globerson", "X. Carreras", "M. Collins"], "venue": "theorem. EMNLP", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2007}, {"title": "Conditional random fields: Probabilistic modeling for segmenting and labeling sequence data", "author": ["J.D. Lafferty", "A. McCallum", "F. Pereira"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2001}, {"title": "Direct optimization of ranking measures. http://arxiv.org/abs/0704.3359", "author": ["Q. Le", "A. Smola"], "venue": null, "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2007}, {"title": "Letor: Benchmark dataset for research on learning to rank for information", "author": ["Liu", "T.-Y", "J. Xu", "T. Qin", "W. Xiong", "H. Li"], "venue": "retrieval. LR4IR", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2007}, {"title": "Generalization bounds and consistency for structured labeling", "author": ["D. McAllester"], "venue": "Predicting Structured Data", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2007}, {"title": "Selection bias in the letor datasets. LR4IR", "author": ["T. Minka", "S. Robertson"], "venue": null, "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2008}, {"title": "Combinatorial optimization: Algorithms and complexity", "author": ["C.H. Papadimitriou", "K. Steiglitz"], "venue": "New Jersey: Prentice-Hall", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1982}, {"title": "Global ranking using continuous conditional random fields", "author": ["T. Qin", "Liu", "T.-Y", "Zhang", "X.-D", "Wang", "D.-S", "H. Li"], "venue": null, "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2009}, {"title": "Sortnet: Learning to rank by a neural-based sorting algorithm. LR4IR", "author": ["L. Rigutini", "T. Papini", "M. Maggini", "F. Scarselli"], "venue": null, "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2008}, {"title": "On a Theorem of Hardy, Littlewood, Polya, and Blackwell", "author": ["S. Sherman"], "venue": "Proceedings of the National Academy of Sciences,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1951}, {"title": "Learning structured prediction models: a large-margin approach", "author": ["B. Taskar"], "venue": "Doctoral dissertation, Stanford University", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2004}, {"title": "Large margin methods for structured and interdependent output variables", "author": ["I. Tsochantaridis", "T. Joachims", "T. Hofmann", "Y. Altun"], "venue": null, "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2005}, {"title": "The complexity of computing the permanent", "author": ["L.G. Valiant"], "venue": "Theor. Comput. Sci. (pp. 189\u2013201)", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1979}, {"title": "Graphical models, exponential families, and variational inference (Technical Report 649)", "author": ["M.J. Wainwright", "M.I. Jordan"], "venue": "UC Berkeley, Department of Statistics", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2003}, {"title": "Adarank: a boosting algorithm for information", "author": ["J. Xu", "H. Li"], "venue": "retrieval. SIGIR", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "Query-level learning to rank using isotonic regression. LR4IR", "author": ["Z. Zheng", "H. Zha", "G. Sun"], "venue": null, "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2008}], "referenceMentions": [{"referenceID": 21, "context": "The Maximum-Weight Bipartite Matching Problem (henceforth \u2018matching problem\u2019) is a fundamental problem in combinatorial optimization [26].", "startOffset": 133, "endOffset": 137}, {"referenceID": 1, "context": "For example, in computer vision the crucial problem of finding a correspondence between sets of image features is often modeled as a matching problem [2, 3].", "startOffset": 150, "endOffset": 156}, {"referenceID": 2, "context": "For example, in computer vision the crucial problem of finding a correspondence between sets of image features is often modeled as a matching problem [2, 3].", "startOffset": 150, "endOffset": 156}, {"referenceID": 17, "context": "Ranking algorithms can be based on a matching framework [19], as can clustering algorithms [14, 11].", "startOffset": 56, "endOffset": 60}, {"referenceID": 12, "context": "Ranking algorithms can be based on a matching framework [19], as can clustering algorithms [14, 11].", "startOffset": 91, "endOffset": 99}, {"referenceID": 9, "context": "Ranking algorithms can be based on a matching framework [19], as can clustering algorithms [14, 11].", "startOffset": 91, "endOffset": 99}, {"referenceID": 25, "context": "This idea of \u2018parameterizing algorithms\u2019 and then optimizing for agreement with data is called structured estimation [31, 33].", "startOffset": 117, "endOffset": 125}, {"referenceID": 26, "context": "This idea of \u2018parameterizing algorithms\u2019 and then optimizing for agreement with data is called structured estimation [31, 33].", "startOffset": 117, "endOffset": 125}, {"referenceID": 25, "context": "[31] and [3] describe max-margin structured estimation formalisms for this problem.", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "[31] and [3] describe max-margin structured estimation formalisms for this problem.", "startOffset": 9, "endOffset": 12}, {"referenceID": 26, "context": "Max-margin estimators instead minimize a surrogate loss which is easier to optimize, namely a convex upper bound on the structured loss [33].", "startOffset": 136, "endOffset": 140}, {"referenceID": 19, "context": "In practice the results are often good, but known convex relaxations produce estimators which are statistically inconsistent [22], i.", "startOffset": 125, "endOffset": 129}, {"referenceID": 6, "context": "The inconsistency of multiclass support vector machines is a well-known issue in the literature that has received careful examination recently [8, 7].", "startOffset": 143, "endOffset": 149}, {"referenceID": 17, "context": "We then compare the performance of our model instance against a large number of state-of-theart ranking methods, including DORM [19], an approach that only differs to our model instance by using max-margin instead of a MAP formulation.", "startOffset": 128, "endOffset": 132}, {"referenceID": 2, "context": "However the fastest suitable sampler is still quite slow for large models, in which case max-margin matching estimators like those of [3] and [31] are likely to be preferable even in spite of their potential inferior accuracy.", "startOffset": 134, "endOffset": 137}, {"referenceID": 25, "context": "However the fastest suitable sampler is still quite slow for large models, in which case max-margin matching estimators like those of [3] and [31] are likely to be preferable even in spite of their potential inferior accuracy.", "startOffset": 142, "endOffset": 146}, {"referenceID": 26, "context": "One is based on max-margin estimators [33, 32, 31], and the other on maximumlikelihood (ML) or MAP estimators in exponential family models [18].", "startOffset": 38, "endOffset": 50}, {"referenceID": 25, "context": "One is based on max-margin estimators [33, 32, 31], and the other on maximumlikelihood (ML) or MAP estimators in exponential family models [18].", "startOffset": 38, "endOffset": 50}, {"referenceID": 16, "context": "One is based on max-margin estimators [33, 32, 31], and the other on maximumlikelihood (ML) or MAP estimators in exponential family models [18].", "startOffset": 139, "endOffset": 143}, {"referenceID": 19, "context": "However the resulting estimators are known to be inconsistent in general: in the limit of infinite training data the algorithm fails to recover the best model in the model class [22, 7, 8].", "startOffset": 178, "endOffset": 188}, {"referenceID": 6, "context": "However the resulting estimators are known to be inconsistent in general: in the limit of infinite training data the algorithm fails to recover the best model in the model class [22, 7, 8].", "startOffset": 178, "endOffset": 188}, {"referenceID": 19, "context": "McAllester recently provided an interesting analysis on this issue, where he proposed new upper bounds whose minimization results in consistent estimators, but no such bounds are convex [22].", "startOffset": 186, "endOffset": 190}, {"referenceID": 16, "context": "The other approach uses ML or MAP estimation in conditional exponential families with \u2018structured\u2019 sufficient statistics, such as in probabilistic graphical models, where they are decomposed over the cliques of the graph (in which case they are called Conditional Random Fields, or CRFs [18]).", "startOffset": 287, "endOffset": 291}, {"referenceID": 7, "context": "Other tractable models of this type include models that predict spanning trees and models that predict binary labelings in planar graphs [9, 17].", "startOffset": 137, "endOffset": 144}, {"referenceID": 15, "context": "Other tractable models of this type include models that predict spanning trees and models that predict binary labelings in planar graphs [9, 17].", "startOffset": 137, "endOffset": 144}, {"referenceID": 14, "context": "This is a well-studied problem; it is tractable and can be solved inO(m) tim [16, 26].", "startOffset": 77, "endOffset": 85}, {"referenceID": 21, "context": "This is a well-studied problem; it is tractable and can be solved inO(m) tim [16, 26].", "startOffset": 77, "endOffset": 85}, {"referenceID": 2, "context": "This model can be used to match features in images [3], improve classification algorithms [11] and rank webpages [19], to cite a few applications.", "startOffset": 51, "endOffset": 54}, {"referenceID": 9, "context": "This model can be used to match features in images [3], improve classification algorithms [11] and rank webpages [19], to cite a few applications.", "startOffset": 90, "endOffset": 94}, {"referenceID": 17, "context": "This model can be used to match features in images [3], improve classification algorithms [11] and rank webpages [19], to cite a few applications.", "startOffset": 113, "endOffset": 117}, {"referenceID": 28, "context": "is the log-partition function, which is a convex and differentiable function of \u03b8 [35].", "startOffset": 82, "endOffset": 86}, {"referenceID": 28, "context": "`(Y |X; \u03b8) is a convex function of \u03b8 since the logpartition function g(\u03b8) is a convex function of \u03b8 [35] and the other terms are clearly convex in \u03b8.", "startOffset": 100, "endOffset": 104}, {"referenceID": 28, "context": "`(Y |X; \u03b8) is a convex and differentiable function of \u03b8 [35], therefore gradient descent will find the global optimum.", "startOffset": 56, "endOffset": 60}, {"referenceID": 15, "context": "However, unlike the determinant, which is computable efficiently and exactly by standard linear algebra manipulations [17], computing the permanent is a ]P-complete problem [34].", "startOffset": 118, "endOffset": 122}, {"referenceID": 27, "context": "However, unlike the determinant, which is computable efficiently and exactly by standard linear algebra manipulations [17], computing the permanent is a ]P-complete problem [34].", "startOffset": 173, "endOffset": 177}, {"referenceID": 11, "context": "The best solution we are aware of is one by Huber and Law, who recently presented an algorithm to approximate the permanent of dense non-negative matrices [13].", "startOffset": 155, "endOffset": 159}, {"referenceID": 11, "context": "This is in precisely the same form as the distribution we have here, p(y|x; \u03b8) [13].", "startOffset": 79, "endOffset": 83}, {"referenceID": 17, "context": "Here we follow the construction used in [19] to map matching problems to ranking problems (indeed the only difference between our ranking model and that of [19] is that they use a max-margin estimator and we use MAP in an exponential family.", "startOffset": 40, "endOffset": 44}, {"referenceID": 17, "context": "Here we follow the construction used in [19] to map matching problems to ranking problems (indeed the only difference between our ranking model and that of [19] is that they use a max-margin estimator and we use MAP in an exponential family.", "startOffset": 156, "endOffset": 160}, {"referenceID": 18, "context": "0 [20], a publicly available benchmark data collection for comparing learning to rank algorithms.", "startOffset": 2, "endOffset": 6}, {"referenceID": 24, "context": "For each query there are a number of associated documents, with relevance degrees judged by humans on three levels: definitely, possibly or not 2If r(v) denotes the vector of ranks of entries of vector v, then \u3008a, \u03c0(b)\u3009 is maximized by the permutation \u03c0\u2217 such that r(a) = r(\u03c0\u2217(b)), a theorem due to Polya, Littlewood, Hardy and Blackwell [30].", "startOffset": 338, "endOffset": 342}, {"referenceID": 18, "context": "See [20] for more details.", "startOffset": 4, "endOffset": 8}, {"referenceID": 13, "context": "Evaluation Metrics In order to measure the effectiveness of our method we use the normalized discount cumulative gain (NDCG) measure [15] at rank position k, which is defined as", "startOffset": 133, "endOffset": 137}, {"referenceID": 5, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 219, "endOffset": 222}, {"referenceID": 8, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 232, "endOffset": 236}, {"referenceID": 4, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 244, "endOffset": 247}, {"referenceID": 3, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 257, "endOffset": 260}, {"referenceID": 29, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 270, "endOffset": 274}, {"referenceID": 30, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 297, "endOffset": 301}, {"referenceID": 23, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 311, "endOffset": 315}, {"referenceID": 10, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 328, "endOffset": 332}, {"referenceID": 22, "context": "In Figure 2 we plot the results of our method (named RankMatch), for M = R, compared to those achieved by a number of state-of-the-art methods which have published NDCG scores in at least two of the datasets: RankBoost [6], RankSVM [10], FRank [5], ListNet [4], AdaRank [36], QBRank [38], IsoRank [37], SortNet [28], StructRank [12] and C-CRF [27].", "startOffset": 343, "endOffset": 347}, {"referenceID": 17, "context": "We also included a plot of our implementation of DORM [19], using precisely the same resampling methodology and data for a fair comparison.", "startOffset": 54, "endOffset": 58}, {"referenceID": 20, "context": "These results should be interpreted cautiously; [24] presents an interesting discussion about issues with these datasets.", "startOffset": 48, "endOffset": 52}, {"referenceID": 2, "context": "This is certainly the benefit of the max-margin matching formulations of [3, 19]: it is much faster for large graphs.", "startOffset": 73, "endOffset": 80}, {"referenceID": 17, "context": "This is certainly the benefit of the max-margin matching formulations of [3, 19]: it is much faster for large graphs.", "startOffset": 73, "endOffset": 80}, {"referenceID": 11, "context": "Runtimes for M = 3, 4, 5 are from the ranking experiments, computed by full enumeration; M = 20 corresponds to the image matching experiments, which use the sampler from [13].", "startOffset": 170, "endOffset": 174}, {"referenceID": 0, "context": "where |\u00b7| denotes the elementwise difference and \u03c8i is the Shape Context feature vector [1] for point i.", "startOffset": 88, "endOffset": 91}, {"referenceID": 2, "context": "The max-margin method is that of [3].", "startOffset": 33, "endOffset": 36}, {"referenceID": 19, "context": "0 [22], a publicly available benchmark data collection for comparing learning to rank algorithms.", "startOffset": 2, "endOffset": 6}, {"referenceID": 19, "context": "See [22] for more detail.", "startOffset": 4, "endOffset": 8}, {"referenceID": 14, "context": "Evaluation Metrics In order to measure the effectiveness of our method we use the normalized discount cumulative gain (NDCG) measure [16] at rank position k, which is defined as", "startOffset": 133, "endOffset": 137}, {"referenceID": 25, "context": "If r(v) denotes the vector of ranks of entries of vector v, then \u3008a, \u03c0(b)\u3009 is maximized by the permutation \u03c0\u2217 such that r(a) = r(\u03c0\u2217(b)), a theorem due to Polya, Littlewood, Hardy and Blackwell [31].", "startOffset": 193, "endOffset": 197}], "year": 2009, "abstractText": "We present a method for learning max-weight matching predictors in bipartite graphs. The method consists of performing maximum a posteriori estimation in exponential families with sufficient statistics that encode permutations and data features. Although inference is in general hard, we show that for one very relevant application\u2013web page ranking\u2013exact inference is efficient. For general model instances, an appropriate sampler is readily available. Contrary to existing maxmargin matching models, our approach is statistically consistent and, in addition, experiments with increasing sample sizes indicate superior improvement over such models. We apply the method to graph matching in computer vision as well as to a standard benchmark dataset for learning web page ranking, in which we obtain state-of-the-art results, in particular improving on max-margin variants. The drawback of this method with respect to max-margin alternatives is its runtime for large graphs, which is comparatively high.", "creator": "LaTeX with hyperref package"}}}