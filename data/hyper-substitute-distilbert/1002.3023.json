{"id": "1002.3023", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Feb-2010", "title": "Rewriting Constraint Models with Metamodels", "abstract": "an important challenge in integrated programming is employing rewrite machine methods into executable programs object - ing vector solutions. this phase factor problem processing may require variations including supervised derivation routines - em, transformations of constraint representations, concurrency checking, and estimation of operational strategies. in open paper, we introduce practical pivot metamodel via the initial fea - composition of constraint models including graphical implementations of con - straints, statements like generators and loops, with smaller work - class instructions like object classes and predicates. task metamodel brings general enough to bear with the constructions of larger languages, from constraints - governed modeling languages to source testing, whereby code contains independent from inheritance. the rewriting operations manipulate, brings apart several languages. giving a consequence, loop executing operations apply whatever languages poorly selected when they sufficiently appropriate to manage model procedural information. a bridge is created between the path compatible program languages using intrinsic functionality. tools from the problem engineering organization shall be useful to implement this framework.", "histories": [["v1", "Tue, 16 Feb 2010 07:26:48 GMT  (215kb)", "http://arxiv.org/abs/1002.3023v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["raphael chenouard", "laurent granvilliers", "ricardo soto"], "accepted": false, "id": "1002.3023"}, "pdf": {"name": "1002.3023.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Ricardo Soto"], "emails": ["raphael.chenouard@univ-nantes.fr", "laurent.granvilliers@univ-nantes.fr", "ricardo.soto@univ-nantes.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n00 2.\n30 23\nv1 [\ncs .A\nI] 1\n6 Fe\nb 20\n10"}, {"heading": "Introduction", "text": "In constraint programming (CP), users describe properties of problems as constraints involving variables. The computer system calls constraint solvers to calculate the solutions. The automatic mapping from constraint models to solvers is the key issue of this paper. The goal is to develop middle software tools that are able to reformulate and rewrite models according to solving requirements.\nModeling real-world problems requires high-level languages with many constructions such as constraint definitions, programming statements, and modularity features. In the recent past, a variety of languages has been designed for a variety of users and problem categories. On one hand, there are many modeling languages for combinatorial problems such as OPL (Van Hentenryck et al. 1999), Essence (Frisch et al. 2007), and MiniZinc (Nethercote et al. 2007) or numerical constraint and optimization problems such as Numerica (Van Hentenryck, Michel, and Deville 1997) and Realpaver (Granvilliers and Benhamou 2006). On the\nCopyright c\u00a9 2010, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nother hand, constraint solving libraries have been plugged in computer programming languages, for instance ILOG Solver (Puget 1994), Gecode (Schulte and Tack 2006), and ECLiPSe (Apt and Wallace 2007). In the following, we will only consider modeling languages as input constraint models. However, computer programming languages can be chosen as targets of the mapping process. Our aim is therefore to provide a many-to-many mapping tool that is able to cope with a variety of languages.\nMany constructions are shared among the different languages, in particular the definitions of constraints. Other constructions are specific such as classes in object-oriented languages or predicates in logic languages. We propose to embed this collection of concepts in a so-called metamodel, that is a model of constraint models. This pivot metamodel describes the relations between concepts and it encodes in an abstract manner the rules for constraint modeling. This is a considerable improvement of our previous work (Chenouard, Granvilliers, and Soto 2008) which was restricted to a one-to-many mapping approach from a particular modeling language. Moreover, the translations to obtain Flat s-COMMA models were hand-coded and model structures are always flattened like for FlatZinc models (Nethercote et al. 2007). Previous model transformations were also specific to Flat s-COMMA and its structure (e.g. there is no object and no loop to manage). Our pivot metamodel is independent of modeling languages and our approach offers more flexibility in getting efficient executable models.\nThe rewriting process can be seen as a three-steps procedure. During the first step, the user constraint model is parsed and a metamodel instance is created. During the last step, the resulting program is generated from a metamodel instance. These two steps constitute a bridge between languages \u2014 the grammar space \u2014 and models \u2014 the model space. The middle step may implement rewriting operations over metamodel instances, for instance to transform constraint representations from an integer model to a boolean model. The main interest is to manipulate concepts rather than syntactic constructions. As a consequence, the rewriting operations can be expressed with clarity and they apply whatever languages are chosen.\nAn interesting work is about the rule-based programming language Cadmium (Duck, Stuckey, and Brand 2006)\ncombining constraint handling rules (Fru\u0308hwirth 2009) and term rewriting to transform constraint models. The rewriting algorithm matches rules against terms in order to derive some term normal forms. This approach provides a very clear semantics to the mapping procedure and it addresses confluence and termination issues. Considering metamodels allows one to reuse metamodeling tools from software engineering. For instance, ATL (Kurtev, van den Berg, and Jouault 2007) is a general rule-based transformation language mixing model pattern matching and imperative programs, which can be contrasted with term matching in Cadmium. Kermeta (Muller, Fleurey, and Je\u0301ze\u0301quel 2005) is a transformation framework allowing to handle model elements using object-oriented programs. A benefit of the model-driven approach is to directly manage typed model concepts using the metamodel abstract description.\nThe remaining of this paper is organized as follows. Section 2 presents the general model-driven transformation framework underlying this work. A motivating example using known CP languages is described in Section 3. The pivot metamodel and rewriting operations are presented in Section 4. Section 5 investigates some transformation experiments on well-known CP models. Finally, Section 6 concludes the paper and details some future work."}, {"heading": "Model Engineering Framework", "text": "A constraint model is a representation of a problem, written in a language, and having a structure. Our purpose is to transform solver-independent models to solver-dependent models. That may lead\n\u2022 to change the representation of input models, namely the intrinsic constraint definitions, in order to improve the solving strategy,\n\u2022 to translate languages, from high-level modeling languages to low-level solver languages or computer programming languages, and\n\u2022 to modify model structures according to the capabilities of solvers, for instance to make a shift from object-oriented models to logic models based on predicates.\nManaging representations supposes to specify constraint transformation rules such as the equivalence of constraint formulations or constraint relaxations. Translating languages requires to map concrete syntactic elements. Manipulating structures deals with abstract modeling concepts like objects or predicates. An important motivation is to separate these different concerns. In particular, the equivalence of constraint formulations is independent from the languages. This argues in favour of a model technical space (MDE TS) gathering modeling concepts and transformation rules and a grammar technical space (Grammar TS) addressing the language issues, as shown in Figure 1.\nIn the grammar space, models are written in languages given by grammars. In the model space, they are defined as relations between elements that conform to metamodels. The elements are instances of concepts described in metamodels, for example a constraint x + y = z deriving from\nsome algebraic constraint concept. The relations define links between concepts such as composition and inheritance. That allows one to define complex elements, such as constraint systems composed of collections of constraints.\nThe shift from languages to models can be implemented by parsing techniques. Model A is created from the source user model A. This model must conform to the user language metamodel, as is required in the model space. As a consequence, metamodels of languages \u2014 modeling languages, constraint programming languages, solver languages\u2014 must be defined. The output B is generated from model B. This model must conform to the metamodel of the solver language.\nModel transformations are defined in the model space. The goal is to transform model A reflecting the user constraint model to model B associated to the solver. As previously mentioned, that requires to change model representations and structures. This process can be done by rewriting operations manipulating concepts from A to B. In order to share common concepts, we propose to introduce the socalled pivot metamodel. The transformation chain is then a three-steps procedure: a shift from model A to the pivot model, the application of rewriting operations over the pivot model, and a shift from the pivot model to model B.\nIn the following (Section 4), we will present the pivot metamodels and model transformation operations. However, we will present first a motivating example (next section) and discuss the requirements for handling constraint models."}, {"heading": "A Motivating Example", "text": "Let us illustrate the transformation process on the social golfers problem. The user model is written in the objectoriented modeling language s-COMMA. The output is a computer program written in the constraint logic programming language ECLiPSe. This problem considers a group of n = g\u00d7s golfers that wish to play golf each week, arranged into g groups of s golfers. The problem is to find a playing schedule for w weeks such that no two golfers play together more than once. Figure 2 and 3 show the s-COMMA model\nand the ECLiPSe model for this problem, respectively. The s-COMMA model is divided in a data file and a model file. The data file is composed by an enumeration holding the golfer names, and three constants to define the problem dimensions (size of groups, number of weeks, and groups per week). The model file is divided into three classes. One to model the groups, one to model the weeks and one to arrange the schedule of the social golfers. The Group class owns the players attribute corresponding to a set of golfers playing together, each golfer being identified by a name given in the enumeration from the data file. In this class, the code block called groupSize (lines 14 to 16) is a constraint zone (constraint zones are used to group statements such as loops, conditionals and constraints under a given name). The groupSize constraint zone restricts the size of the golfers group. The Week class has an array of Group objects and the constraint zone playOncePerWeek ensures that each golfer takes part of a unique group per week. Finally, the SocialGolfers class has an array of Week objects and the constraint zone differentGroups states that each golfer never plays two times with the same golfer throughout the considered weeks.\nThe generated ECLiPSe model is depicted in Figure 3, which has been built as a single predicate whose body is a sequence of atoms. The sequence is made of the problem dimensions (lines 2 to 4), the list of integer sets L (lines 6 to 7), and three nested loop blocks resulting from the transformation of the three s-COMMA classes (lines 9 to 36). It turns out that parts of both models are similar. This is due to the sharing of concepts in the underlying metamodels, for instance constants, forall statements, or constraints. However, the syntaxes are different and specific processing may\nbe required. For instance, the for statement of ECLiPSe needs the param keyword to declare parameters defined outside the current scope, e.g. the number of groups G.\nThe treatment of objects is more subtle since they must not participate to ECLiPSe models. Many mapping strategies may be devised, for instance mapping objects to predicates (Soto and Granvilliers 2007). Another mapping strategy is used here, which consists of removing the objectbased problem structure. Flattening the problem requires visiting the many classes through their inheritance and composition relations. A few problems to be handled are described as follows. Important impacts on the attributes may happen. For example, the weekSched array of Week objects defined at line 2 of the model file in Figure 2 is refactored and transformed to the WEEKSCHED GROUPSCHED PLAYERS flat list stated at line 6 in Figure 3. It may be possible to insert new loops in order to traverse arrays of objects and to post the whole set of constraints. For instance, the last block of for loops in the ECLiPSe model (lines 28 to 36) has been built from the playOncePerWeek constraint zone of the sCOMMA model, but there is an additional for loop (line 28) since the Week instances are contained in the weekSched array. Another issue is related to lists that cannot be accessed in the same way as arrays in s-COMMA. Thus, local variables (Vi) and the well-known nth Prolog predicate are introduced in the ECLiPSe model."}, {"heading": "Pivot Model Handling", "text": "Our pivot metamodel has been defined to catch most modeling needs that occur in constraint modeling languages.\nThen, pivot models are managed with several refining transformations, where each transformation identifies a clear refining process, namely structure modifications (e.g. removal of object variables) or model optimization."}, {"heading": "Pivot Metamodel", "text": "Figure 4 depicts an extract of our pivot structure metamodel in a simplified UML Class diagram formalism. Italic font is used to denote abstract concepts. The root concept is Model which contains all entities. Three abstract concepts inherit from the abstract class ModelElement:\n\u2022 Classifier represents all types than can be used to define variables or constants:\n\u2013 DataType corresponds to common primitive data types used in CP, namely Boolean, Integer and Real.\n\u2013 Enumeration is used to define symbolic types, i.e. a set of symbolic values defined as EnumLiteral (not defined here to keep the figure readable), e.g. enum Name:={a,b,. . .}, line 1 of data file in Figure 2.\n\u2013 Class is similar to the object-oriented concept of class, but defined in a CP context (Soto and Granvilliers 2007), i.e. a class definition is composed of variable or constant definitions and also constraints and other statements. Thus, a Class has a set of features being instances of ModelFeature.\n\u2022 ModelFeature corresponds to the instance concepts defined within a model. It is also divided in three concepts:\n\u2013 Record relates to non-typed instances being composed of a collection of elements, such as tuples. To cover a broader range of record definitions, we define a composition of ModelFeature instances.\n\u2013 TypedElement is an abstract concept corresponding to typed constraint model elements. Thus, it has a reference to a classifier. The concept of array variable is not distinguished from variable, but array can be represented using a sequence of sizes, corresponding to each dimension of an array (more than two dimensions are allowed). Theses sizes are expressed as Expression instances. \u2217 Variable has an optional Domain definition (not\nshown here) restricting values belonging to the associated type. Three concepts of Domain are taken into account: intervals, sets and domains defined as an expression.\n\u2217 Constant concept is for constants having a type and a fixed value.\n\u2013 Statement is used to represent all the other features that may occur in a Model or a Class: \u2217 Constraint is the abstract constraint concept having\ntwo sub-concepts. ExpressionConstraint stands for constraints built inductively from terms and relations. GlobalCtr handles global constraints defined by a name and a list of parameters.\n\u2217 ForAll defines a loop mechanism over constraints and other statements. It has an iterating variable which is local to the loop.\n\u2217 If obviously defines a conditional statement. It is composed of an Expression corresponding to the boolean test and two sets of statements corresponding to the statements to take into account according to the test evaluation. The second set of statements is optional if no alternative to the true evaluation of the test is defined.\n\u2022 ParameterizedElement defines concepts having a list of parameters and not being a classifier neither an instance of a ModelFeature:\n\u2013 Predicate represents logical predicates in a model as in ECLiPSe. Predicates have parameters and a body composed of a sequence of ModelFeature, such as variable definitions or constraint statements.\n\u2013 Function represents user-defined functions stated in a model. It contains also a body, but it is based on a statement used to compute a result.\nThe notion of expression is ubiquitous in CP. The related concepts of our metamodel are detailed in Figure 5. They represent all the entities occurring in first-order formulas made from variables, terms, relations, and connectives. The concept Expression is abstract and is used as super class for all kinds of expressions:\n\u2022 FunctionCall is used to refer to an already defined Function and contains a list of parameters defined as Expression.\n\u2022 VarOccurrence is used to refer to already defined instances: records, variables or constants. It is only composed of a reference to the corresponding instance declaration and to a list of optional indexes to handle arrays. It is specialized in ObjectOccurrence in order to express the navigation path to an object attribute (e.g. groupSched[g1].players, line 8 in Figure 2). Variable occurrences are not classified according to their declaration type in one of the three expression types inheriting from Expression in order to avoid multiple declaration of the same concept, while requiring type inference mechanism.\n\u2022 BooleanExpression is used to specify boolean concepts occurring in expressions:\n\u2013 BoolValue represents the terms true and False. \u2013 PredicateCall corresponds to the call of a predicate\nwith its list of parameters. Thus, it is composed of a reference to a Predicate with a list of parameters defined as Expression in order to allow at the same time VarOccurrence and evaluable expressions, such as 1, x or x+ 1.\n\u2013 BoolOperator is an abstract concept having a name representing the symbol of well-known operators. It is specialized in the two common types of operators:\n\u2217 BoolUnaryOp corresponds to the negation operator and has an operand corresponding to an Expression, since it can be a boolean expression, but also a variable. In the following, operands of all operators will be defined as a composition of Expression.\n\u2217 BoolBinaryOp corresponds to the several common binary operators returning a boolean value, such as: \u21d4, \u2192, and, or, =, 6=, \u2264, \u2265, <, >.\n\u2022 SetExpression defines the main constructs available to deal with sets within expressions:\n\u2013 SetValue corresponds to a set of value occurrences, such as {1, 2, 3}. To tackle various contents as set elements (e.g. {1, x + 1}), it is composed of a list of elements conformed to Expression.\n\u2013 SetFunction corresponds to the call of known functions over sets, such as the cardinality function.\n\u2013 SetOperator is specialized only in SetBinaryOp since no unary operator is commonly used on sets. For instance, intersection, union and difference are available.\n\u2022 AlgebraicExpression defines the numerical expressions:\n\u2013 AlgValue is abstract and represents the three main concepts of values in numerical expressions: IntValue for integer values, RealValue for real number values and IntervalValue for interval values such as [\u22121, 1].\n\u2013 AlgFunction corresponds to the call of a well-known function over numbers, such as trigonometric functions.\n\u2013 AlgOperator refers to the common operators used in algebraic expressions: AlgUnaryOp(\u2212, +) and AlgBinaryOp (+, \u2212, \u2217, / and \u02c6).\nOur pivot metamodel has been defined to fit with most modeling needs in CP, but also to fit with the metamodel of CP languages. Thus, some simplifications have been done to ease transformations such as the VarOccurrence concept which directly inherits from Expression. Indeed, variable occurrences can be typed in expressions (i.e. boolean, set or algebraic), but we define only one to avoid redundancies."}, {"heading": "Pivot model refactoring", "text": "Model transformations are implemented as rewriting operations over pivot models.\nFor sake of clarity, we will present a few operations using an imperative pseudo-code style, while specific transformation languages are used in practice. The main interest given by the concept hierarchy is to provide navigation mechanisms through models. For instance, it is immediate to iterate over the set of variables of a constraint, since this information is gathered in the corresponding abstract constraint concept (see e.g. Algorithm 2). It is therefore possible to manipulate models globally, which is very powerful.\nObject flattening This refactoring step replaces object instances, namely variables whose type is a class, by all elements defined in the class definition (variable, constants, constraints and other statements). In order to prevent name conflicts, named elements are prefixed with the name of object instances.\nThis refactoring transformation can be expressed in terms of a brief pseudo-code algorithm as shown in Algorithm 1.\nAlgorithm 1 Transforming and removing object variables and class definitions objectRemoval(m : Model) : Model\n1: let res : Model 2: for all o in m.elements do 3: if is var(o) and is class(o.type) then 4: res.insert(flatten(o,o.type.features)) 5: else if not is class(o) then 6: res.elements.insert(o) 7: end if 8: end for 9: return res\nflatten(o : Variable, features : Set of ModelFeature) : Set of ModelFeature\n1: let res : Set of ModelFeature = \u2205 2: for all f in features do 3: if is var(f) and not is class(f.type) then 4: let v : Variable 5: v \u2190 duplicate(f) 6: v.name = o.name + \u2019 \u2019 + v.name 7: res.insert(v) 8: else 9: ...\n10: end if 11: end for 12: return res\nThe ObjectRemoval function processes a source model by iterating on all its elements (line 2). If object instances are detected (line 3), then the function flatten is called and its result is added to the output model elements (line 4). Instances not being a Class definition are duplicated in the output model (line 5,6), while Class definitions are removed. In the flatten function every feature given as parameter is cloned and added to the resulting set of ModelFeature. In the case of a variable (and also constants), its name is concatenated to the object variable name (line 6). Figure 6 depicts the result of the transformation on the social golfers example previously presented.\nclass SocialGolfers { Week weekSched[w];. . .} class Week { Group groupSched[g];. . .} class Group { Name set players;. . .} \u21d2 Name set weekSched groupSched players[g*w];\nFigure 6: Applying the object flattening transformation on the social golfers example using s-COMMA syntax.\nArrays of objects and expressions refactoring are not presented here to keep the algorithm simple. As mentioned at the end of Section 3, in the case of object arrays, we must transfer their size to their attributes and a loop statement has to be introduced to iterate on their Statement instances. Within expressions, instances of VarOccurrence may just be updated with the declaration of the new flat variables.\nAlldifferent removal Since global constraints are not handled by every solver, there is a motivation to reformulate them or to generate relaxations. We consider here, the wellknown global constraint alldifferent(x1, ..., xn). We assume that the domain of each xi varies from 1 to n to ease the definition of the two last algorithms. We propose three possible transformations:\n\u2022 Generating a set of disequalities as shown in Algorithm 2. For all variable combinations (line 2,3), a constraint is generated and added to the result (line 6).\nAlgorithm 2 Transforming alldifferent to a set of disequalities AllDiffToDisequalities(c : GlobalConstraint) : Set of Constraint\n1: let res : Set of Constraint = \u2205 2: for all i in 1..c.parameters.size() do 3: for all j in i+ 1..c.parameters.size() do 4: let x : Variable = c.parameter[i] 5: let y : Variable = c.parameter[j] 6: res.insert(new Constraint(x 6= y)) 7: end for 8: end for 9: return res\n\u2022 Generating a relaxation as shown on Algorithm 3. Only one constraint is created (line 3) assessing that the sum of all variable values is equal to n(n+ 1)/2.\nAlgorithm 3 Generating alldifferent relaxations AllDiffToRelaxation(c : GlobalConstraint) : Constraint\n1: let n : Integer = c.parameters.size() 2: let sum : Expression = \u2211n i=1 c.parameters[i] 3: return new Constraint(sum = n(n+1)/2)\n\u2022 Generating a boolean version as shown on Algorithm 4. In this case, we define a new matrix of boolean variables (line 2,3,4), where b[i, j] being true means xi has value j. Line 7 checks that only one value per variable is defined. Line 10 ensures that two variables have different values."}, {"heading": "Experiments", "text": "The presented architecture has been implemented with three tools and languages: KM3 (Jouault and Be\u0301zivin 2006) is a metamodel language, ATL (Kurtev, van den Berg, and Jouault 2007) is a declarative rule language to describe model transformations and TCS (Jouault, Be\u0301zivin, and Kurtev 2006) is a declarative language based on templates to define the text to model and model to text transitions. These MDE tools allow us to choose the refactoring steps to apply on pivot models in order to keep supported structures of the target metamodel.\nWe have carried out a set of tests in order to analyze the performance of our approach. We used five CP problems: Social Golfers, Engine Design, Send+More=Money,\nAlgorithm 4 Reformulating alldifferent into a boolean model AllDiffToBoolean(c : GlobalConstraint) : Set of ModelFeature\n1: let res : Set of Constraint = \u2205 2: let n : Integer = c.parameters.size() 3: let m : Integer = card(c.parameters.domain) 4: let b[n,m] : Boolean 5: res.insert(b) 6: for i in 1..n do 7: res.insert(new Constraint( \u2211m j=1 b[i,j] = 1)) 8: end for 9: for j in 1..m do\n10: res.insert(new Constraint( \u2211n\ni=1 b[i,j] = 1)) 11: end for\nStable Marriage and N-Queens. The first experiment evaluates the performance in terms of translation time, and the second one was done to show that the automatic generation of solver files does not lead to a loss of performance in terms of solving time. The benchmarking study was performed on a 2.66Ghz computer with 2GB RAM running Ubuntu.\nIn the first experiment we test the s-COMMA (sC) to ECLiPSe (Ecl) translation. Table 1 depicts the results. The first column gives the problem names. The second column shows the number of lines of the s-COMMA source files. The following columns correspond to the time of atomic steps involved in the transformation (in seconds): transformations from s-COMMA to Pivot (s-to-P) (corresponds to Source Text A to Model Pivot in Figure 1), object flattening (Object), enumeration removal (Enum), and transformations from Pivot to ECLiPSe (P-to-E) (corresponds to Model Pivot to Target Text B in Figure 1). The next column details the total time of the complete transformation, and the last column depicts the number of lines of the generated ECLiPSe files.\nThe results show that the text processing phases (s-toP and P-to-E) are fast, but we may remark that the given problems are concisely stated (maximum of 112 lines). The transformation s-COMMA to pivot is slower than the transformation pivot to ECLiPSe. This is explained by the refactoring phases performed on the pivot that reduce the number of elements to handle the pivot to ECLiPSe step. The composition flattening is the more expensive phase. In particular, the Engine problem exhibits the slowest running time,\nsince it contains several object compositions. In summary, considering the whole set of phases involved, we believe the results show reasonable translation times.\nIn the second experiment we compare the ECLiPSe files automatically generated by the framework with native ECLiPSe files written by hand (see Table 2). We consider the solving time and the lines of each problem file. The data of the native models is first given. We then introduce generated files where the loops have not been unrolled (avoiding this phase the size of generated solver files is closer to the native ones). In this case, the solving times of both types of files are almost equivalent. At the end, we consider problems including the loop unrolling phase (Flat). This process leads to a considerable increase of model sizes. Only the solving time of the flat 20-Queens and 28-Queens problems are impacted (about 0.4 and 7 seconds). This may be explained by the incremental propagation algorithm commonly implemented in CLP languages. We may suppose that a propagation happens each time a constraint is added to the constraint store. If a for statement is not interleaved with propagation, i.e. it is considered as one block, then only one propagation step is required. This is not the case if loops are unrolled, leading to one propagation for each individual constraint. It results in a slow-down. This negative impact in terms of solving time demonstrates the need for keeping the structure of target models (e.g. not unrolling loops) instead of building a flat model."}, {"heading": "Related Work", "text": "Model transformation is a recent research topic in CP. Just a few CP model transformation approaches have been proposed. The solver-independent architecture is likely to be the nearest framework to our approach, for instance, MiniZinc (and Zinc), Essence and s-COMMA.\nMiniZinc is a high-level constraint modeling language allowing transformations to ECLiPSe and Gecode models. These mappings are implemented by means of Cadmium. The translation process involves an intermediate model where several MiniZinc constructs are replaced by simplified or solver-supported constructs. This facilitates the translation to get a solver model.\nEssence is another language involving model transformations. Its solver-independent platform that allows to map Essence models into ECLiPSe and Minion (Gent, Jefferson, and Miguel 2006). A model transformation system called Conjure (Frisch et al. 2005) is included in the framework, which takes as input an Essence specification and refines it to an intermediate language\ncalled Essence\u2019. The translation from Essence\u2019 to solver code is currently performed by java translators using the tool Tailor.\ns-COMMA is an object-oriented language, supported by a solver-independent platform where solvers can be mapped to ECLiPSe, Gecode/J, RealPaver, and GNU Prolog (Diaz and Codognet 2000). The language also involves an intermediate model called Flat s-COMMA to facilitate the translation. Hand-written translators and MDE-translators have been developed to translate a Flat s-COMMA model in the target solver model.\nOur approach can be seen as a natural evolution of this solver-independent architecture. Two major advantages arise. (1) In the aforementioned approaches just one modeling language can be used as the source of the transformation, in our framework many modeling language can be plugged as the source. We believe this enables flexibility and provides freedom to the modelers. (2) In the s-COMMA, MiniZinc, and Essence transformation processes, the refactoring steps (e.g. enumeration removal, loop and set unrolling) are always applied. This makes the structure of the solver file completely different from the original model. In our framework we focus on generating optimized models while trying to maintain as much as possible the original structure of the source model. We believe that keeping the source modeling structures into target models, then improve their readability and understanding."}, {"heading": "Conclusion and Future Work", "text": "In this paper, we have presented a new framework for constraint model transformations. This framework is supported by an MDE approach and a pivot metamodel that provides independence and flexibility to cope with different languages. The transformation chain involves three main steps: from the source to the pivot model, refining of the pivot model and from the pivot model to the target. Among others, an important feature of this chain is the modularity of mode transformations and that the hard transformation work (refactoring/optimization) is always performed over the pivot. This makes the transformations from/to pivot simpler, and as a consequence the integration of new languages to the architecture requires less effort.\nIn a near future, we intend to increase the number of CP languages our approach supports. We also want to define more pivot refactoring transformations to optimize and reformulate models. Another major outline for future work is to improve the management of complex CP models transformation chains, which is not investigated in this paper. The order in which refactoring steps are applied and which refactoring step to apply can be automated. However, we may investigate how to qualify models and transformations according to the pivot and target metamodels."}], "references": [{"title": "and Wallace", "author": ["K.R. Apt"], "venue": "M.", "citeRegEx": "Apt and Wallace 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "Model-Driven Constraint Programming", "author": ["Granvilliers Chenouard", "R. Soto 2008] Chenouard", "L. Granvilliers", "R. Soto"], "venue": "In ACM SIGPLAN PPDP,", "citeRegEx": "Chenouard et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Chenouard et al\\.", "year": 2008}, {"title": "and Codognet", "author": ["D. Diaz"], "venue": "P.", "citeRegEx": "Diaz and Codognet 2000", "shortCiteRegEx": null, "year": 2000}, {"title": "P", "author": ["Duck, G.J.", "Stuckey"], "venue": "J.; and Brand, S.", "citeRegEx": "Duck. Stuckey. and Brand 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "The Rules of Constraint Modelling", "author": ["Frisch"], "venue": null, "citeRegEx": "Frisch,? \\Q2005\\E", "shortCiteRegEx": "Frisch", "year": 2005}, {"title": "B", "author": ["A.M. Frisch", "M. Grum", "C. Jefferson", "Hern\u00e1ndez"], "venue": "M.; and Miguel., I.", "citeRegEx": "Frisch et al. 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "I", "author": ["Gent"], "venue": "P.; Jefferson, C.; and Miguel, I.", "citeRegEx": "Gent. Jefferson. and Miguel 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "and Benhamou", "author": ["L. Granvilliers"], "venue": "F.", "citeRegEx": "Granvilliers and Benhamou 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "and B\u00e9zivin", "author": ["F. Jouault"], "venue": "J.", "citeRegEx": "Jouault and B\u00e9zivin 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "TCS: a DSL for the Specification of Textual Concrete Syntaxes in Model Engineering", "author": ["B\u00e9zivin Jouault", "F. Kurtev 2006] Jouault", "J. B\u00e9zivin", "I. Kurtev"], "venue": "In ACM GPCE,", "citeRegEx": "Jouault et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Jouault et al\\.", "year": 2006}, {"title": "Rule-based Modularization in Model Transformation Languages Illustrated with ATL", "author": ["van den Berg Kurtev", "I. Jouault 2007] Kurtev", "K. van den Berg", "F. Jouault"], "venue": "Science of Computer Programming,", "citeRegEx": "Kurtev et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Kurtev et al\\.", "year": 2007}, {"title": "Weaving Executability into Object-Oriented Meta-Languages", "author": ["Fleurey Muller", "P.-A. J\u00e9z\u00e9quel 2005] Muller", "F. Fleurey", "J.-M. J\u00e9z\u00e9quel"], "venue": "Proceedings of MODELS/UML,", "citeRegEx": "Muller et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Muller et al\\.", "year": 2005}, {"title": "G", "author": ["N. Nethercote", "P.J. Stuckey", "R. Becket", "S. Brand", "Duck"], "venue": "J.; and Tack, G.", "citeRegEx": "Nethercote et al. 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "and Tack", "author": ["C. Schulte"], "venue": "G.", "citeRegEx": "Schulte and Tack 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "and Granvilliers", "author": ["R. Soto"], "venue": "L.", "citeRegEx": "Soto and Granvilliers 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "Constraint Programming in OPL", "author": ["Van Hentenryck"], "venue": "In PPDP,", "citeRegEx": "Hentenryck,? \\Q1999\\E", "shortCiteRegEx": "Hentenryck", "year": 1999}, {"title": "Numerica: a Modeling Language for Global Optimization", "author": ["Michel Van Hentenryck", "P. Deville 1997] Van Hentenryck", "L. Michel", "Y. Deville"], "venue": null, "citeRegEx": "Hentenryck et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Hentenryck et al\\.", "year": 1997}], "referenceMentions": [], "year": 2010, "abstractText": "An important challenge in constraint programming is to rewrite constraint models into executable programs calculating the solutions. This phase of constraint processing may require translations between constraint programming languages, transformations of constraint representations, model optimizations, and tuning of solving strategies. In this paper, we introduce a pivot metamodel describing the common features of constraint models including different kinds of constraints, statements like conditionals and loops, and other first-class elements like object classes and predicates. This metamodel is general enough to cope with the constructions of many languages, from object-oriented modeling languages to logic languages, but it is independent from them. The rewriting operations manipulate metamodel instances apart from languages. As a consequence, the rewriting operations apply whatever languages are selected and they are able to manage model semantic information. A bridge is created between the metamodel space and languages using parsing techniques. Tools from the software engineering world can be useful to implement this framework.", "creator": "LaTeX with hyperref package"}}}