{"id": "1306.3884", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Jun-2013", "title": "The Rise and Fall of Semantic Rule Updates Based on SE-Models", "abstract": "logic programmers assuming essentially stable model semantics, largely crystal - set programs, created potentially expressive pseudo - matrix symbolic representation framework, featuring a flexible, stable and well - understood semantics. however, studying the lack of rule bases is still now largely open problem. the agm framework for belief change was shown we give unstable rules when directly compared to digital databases under essentially non - logical semantics such its the flow models. the approaches to combat this lack, developed exceptionally significantly, proposed update semantics based mainly explaining the syntactic syntax of programs and messages.", "histories": [["v1", "Mon, 17 Jun 2013 15:02:11 GMT  (61kb,D)", "http://arxiv.org/abs/1306.3884v1", "38 pages, to appear in Theory and Practice of Logic Programming (TPLP)"]], "COMMENTS": "38 pages, to appear in Theory and Practice of Logic Programming (TPLP)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["martin slota", "jo\\~ao leite"], "accepted": false, "id": "1306.3884"}, "pdf": {"name": "1306.3884.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["JO\u00c3O LEITE"], "emails": [], "sections": [{"heading": null, "text": "More recently, AGM revision has been successfully applied to a significantly more expressive semantic characterisation of logic programs based on SE-models. This is an important step, as it changes the focus from the evolution of a syntactic representation of a rule base to the evolution of its semantic content.\nIn this paper, we borrow results from the area of belief update to tackle the problem of updating (instead of revising) answer-set programs. We prove a representation theorem which makes it possible to constructively define any operator satisfying a set of postulates derived from Katsuno and Mendelzon\u2019s postulates for belief update. We define a specific operator based on this theorem, examine its computational complexity and compare the behaviour of this operator with syntactic rule update semantics from the literature. Perhaps surprisingly, we uncover a serious drawback of all rule update operators based on Katsuno and Mendelzon\u2019s approach to update and on SE-models.\nKEYWORDS: belief update, answer-set programs, rule update, SE-models, support, literal inertia"}, {"heading": "1 Introduction", "text": "Answer-Set Programming (ASP) (Gelfond and Lifschitz 1988; Baral 2003) is now widely recognised as a valuable approach to knowledge representation and reasoning, mostly due to its simple and well-understood declarative semantics, its rich expressive power, and the existence of efficient implementations.\nHowever, the dynamic character of many applications that can benefit from ASP calls for the development of ways to deal with the evolution of answer-set programs and the inconsistencies that may arise.\n\u2217 This is an extended version of (Slota and Leite 2010).\nar X\niv :1\n30 6.\n38 84\nv1 [\ncs .A\nI] 1\n7 Ju\nThe problems associated with knowledge evolution have been extensively studied, over the years, by different research communities, namely in the context of Classical Logic, and in the context of Logic Programming.\nThe former have been inspired, to a large extent, by the seminal work of Alchourro\u0301n, Ga\u0308rdenfors and Makinson (AGM) who proposed a set of desirable properties of belief change operators, now called AGM postulates (Alchourro\u0301n et al. 1985). Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991). While revision deals with incorporating new information about a static world, update takes place when changes occurring in a dynamic world are recorded. Katsuno and Mendelzon formulated a separate set of postulates for update, now known as KM postulates.\nBoth AGM and KM postulates were later studied in the context of Logic Programming, only to find that their formulations based on a non-monotonic semantics, such as the answer sets, are inappropriate (Eiter et al. 2002). Like many belief change operators, earlier methods used to tackle rule updates were based on literal inertia (Alferes and Pereira 1996) but proved not sufficiently expressive. This led to the development of rule update semantics based on different intuitions, principles and constructions, when compared to their classical counterparts. For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour. Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al. 2007), or dependencies on default assumptions (S\u030cefra\u0301nek 2006; Kru\u0308mpelmann and KernIsberner 2010; S\u030cefra\u0301nek 2011).\nThough useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour. For example, except for the semantics proposed in (Alferes et al. 2005; S\u030cefra\u0301nek 2011), a tautological update may influence the result under all of these semantics, a behaviour that is highly undesirable when considering knowledge updates. Other kinds of irrelevant updates are even more problematic and subject of ongoing research (S\u030cefra\u0301nek 2006; S\u030cefra\u0301nek 2011). But more important, the common feature of all of these semantics is that they make heavy use of the syntactic structure of programs and rules, making any analysis of their semantic properties a daunting task.\nRecently, AGM revision was reformulated in the context of Logic Programming in a manner analogous to belief revision in classical propositional logic, and specific revision operators for logic programs were investigated (Delgrande et al. 2008; Osorio and Cuevas 2007). Central to this novel approach are SE-models (Turner 2003) which provide a monotonic semantic characterisation of logic programs that is strictly more expressive than the answer-set semantics. Furthermore, two programs have the same set of SE-models if and only if they are strongly equivalent (Lifschitz et al. 2001), which means that programs P,Q with the same set of SE-models can be modularly replaced by one another, even in the presence of additional rules, without affecting the resulting answer sets.\nIndeed, these results constitute an important breakthrough in the research of answer-set\nprogram evolution. They change the focus from the syntactic representation of a program, where not all rules and literal occurrences are necessarily relevant to the meaning of the program as a whole, to its semantic content, i.e. to the information that the program is intended to represent.\nIn this paper, we follow a similar path, but to tackle the problem of answer-set program updates, instead of revision as in (Delgrande et al. 2008).\nUsing SE-models, we adapt the KM postulates to answer-set program updates and prove a representation theorem that provides a constructive characterisation of rule update operators satisfying the postulates, making it possible to define and evaluate any operator satisfying the postulates using an intuitive construction. We show how this constructive characterisation can be used by defining a concrete answer-set program update operator that can be seen as a counterpart of Winslett\u2019s belief update operator (Winslett 1990) which satisfies the KM postulates and is commonly used in the literature.\nHowever, while investigating the operator\u2019s properties, we uncover a serious drawback which, as it turns out, extends to all answer-set program update operators based on SE-models and Katsuno and Mendelzon\u2019s approach to updates. This finding is very important as it guides the research on updates of answer-set programs away from the purely semantic approach materialised in AGM and KM postulates or, alternatively, to the development of semantic characterisations of answer-set programs, richer than SE-models, that are appropriate for describing their dynamic behaviour.\nThe remainder of this paper is structured as follows: In Section 2 we introduce the formal concepts that are necessary throughout the rest of the paper. Section 3 contains the reformulation of KM postulates for logic program updates and the representation theorem that establishes a general constructive characterisation of rule update operators obeying the postulates. We also show how this theorem can be used by defining a specific rule update operator that satisfies the postulates and we examine the computational complexity of query answering for this operator. In Section 4 we further analyse the previously defined operator and establish that all semantic rule update operators based on SE-models exhibit an undesired behaviour. We summarise our findings in Section 5."}, {"heading": "2 Preliminaries", "text": "We consider a propositional language over a finite set of propositional variables A and the usual set of propositional connectives to form propositional formulae. An objective literal is either an atom p or its negation \u00acp. A Horn clause is a disjunction of at most one atom and zero or more negated atoms; a Horn formula is a conjunction of Horn clauses.\nA (propositional) interpretation is any subset of A and the set of all interpretations is I = 2A. We use the standard semantics for propositional formulae and denote the set of models of a formula \u03c6 by J\u03c6K. We also write J |= \u03c6 if J \u2208 J\u03c6K. We say that a formula \u03c6 is complete if J\u03c6K is a singleton set. For formulae \u03c6, \u03c8 we say that \u03c6 is equivalent to \u03c8, denoted by \u03c6 \u2261 \u03c8, if J\u03c6K = J\u03c8 K, and that \u03c6 entails \u03c8, denoted by \u03c6 |= \u03c8, if J\u03c6K \u2286 J\u03c8 K. As we are dealing with the finite case, every knowledge base can be expressed by a single formula."}, {"heading": "2.1 Belief Update", "text": "Update is a belief change operation that brings a knowledge base up to date when the world described by it changes (Keller and Winslett 1985; Katsuno and Mendelzon 1991). Formally, a belief update operator is a function that takes two formulae, representing the original knowledge base and its update, as arguments and returns a formula representing the updated knowledge base. To further specify the desired properties of update operators, the following eight postulates for a belief update operator and formulae \u03c6, \u03c8, \u00b5, \u03bd were proposed in (Katsuno and Mendelzon 1991):\n(B1) \u03c6 \u00b5 |= \u00b5. (B2) If \u03c6 |= \u00b5, then \u03c6 \u00b5 \u2261 \u03c6. (B3) If J\u03c6K 6= \u2205 and J\u00b5K 6= \u2205, then J\u03c6 \u00b5K 6= \u2205. (B4) If \u03c6 \u2261 \u03c8 and \u00b5 \u2261 \u03bd, then \u03c6 \u00b5 \u2261 \u03c8 \u03bd. (B5) (\u03c6 \u00b5) \u2227 \u03bd |= \u03c6 (\u00b5 \u2227 \u03bd). (B6) If \u03c6 \u00b5 |= \u03bd and \u03c6 \u03bd |= \u00b5, then \u03c6 \u00b5 \u2261 \u03c6 \u03bd. (B7) If \u03c6 is complete, then (\u03c6 \u00b5) \u2227 (\u03c6 \u03bd) |= \u03c6 (\u00b5 \u2228 \u03bd). (B8) (\u03c6 \u2228 \u03c8) \u00b5 \u2261 (\u03c6 \u00b5) \u2228 (\u03c8 \u00b5).\nKatsuno and Mendelzon also proved an important representation theorem that makes it possible to define and evaluate any operator satisfying these postulates using an intuitive construction. It is based on treating the models of a knowledge base as possible real states of the modelled world. An update of an original knowledge base \u03c6 is performed by modifying each of its models as little as possible to make it consistent with new information in the update \u00b5, obtaining a new set of interpretations \u2013 the models of the updated knowledge base. More formally,\nJ\u03c6 \u00b5K = \u22c3\nI\u2208J\u03c6K incorporate(J\u00b5K, I) ,\nwhere incorporate(M, I) returns the members ofM closer to I . A natural way of defining incorporate(M, I) is by assigning an order \u2264I over I to each interpretation I and taking the minima ofM w.r.t. \u2264I , i.e. incorporate(M, I) = min(M,\u2264I). In the following we first formally establish the concept of an order assignment; thereafter we define when an update operator is characterised by such an assignment.\nGiven a set S, a preorder over S is a reflexive and transitive binary relation over S; a strict preorder over S is an irreflexive and transitive binary relation over S; a partial order over S is a preorder over S that is antisymmetric. Given a preorder \u2264 over S, we denote by < the strict preorder induced by \u2264, i.e. s < t if and only if s \u2264 t and not t \u2264 s. For any subset T of S, the set of minimal elements of T w.r.t. \u2264 is\nmin(T ,\u2264) = { s \u2208 T | \u00ac\u2203t \u2208 T : t < s } .\nDefinition 1 (Order assignment) Let S be a set. A preorder assignment over S is any function \u03c9 that assigns a preorder \u2264s\u03c9 over S to each s \u2208 S. A partial order assignment over S is any preorder assignment \u03c9 over S such that \u2264s\u03c9 is a partial order over S for every s \u2208 S.\nDefinition 2 (Belief update operator characterised by an order assignment) Let be a belief update operator and \u03c9 a preorder assignment over I. We say that is characterised by \u03c9 if for all formulae \u03c6, \u00b5,\nJ\u03c6 \u00b5K = \u22c3\nI\u2208J\u03c6K min\n( J\u00b5K,\u2264I\u03c9 ) . (1)\nA natural condition to impose on the assigned orders is that every interpretation be the closest to itself. This is captured by the notion of a faithful order assignment:\nDefinition 3 (Faithful order assignment (Katsuno and Mendelzon 1991)) A preorder assignment \u03c9 over I is faithful if for every interpretation I the following condition is satisfied:\nFor every J \u2208 I with J 6= I it holds that I <I\u03c9 J .\nThe representation theorem of (Katsuno and Mendelzon 1991) states that operators characterised by faithful order assignments are exactly those that satisfy the KM postulates.\nTheorem 4 (Representation theorem for belief updates (Katsuno and Mendelzon 1991)) Let be a belief update operator. Then the following conditions are equivalent:\na) The operator satisfies conditions (B1) \u2013 (B8). b) The operator is characterised by a faithful preorder assignment. c) The operator is characterised by a faithful partial order assignment.\nKatsuno and Mendelzon\u2019s results provide a framework for belief update operators, each specified on the semantic level by a faithful partial order assignment over I. The most influential instance of this framework is the Possible Models Approach (Keller and Winslett 1985; Winslett 1990), also referred to as Winslett\u2019s belief update semantics, based on minimising the set of atoms whose truth value changes when an interpretation is updated. Formally, Winslett\u2019s partial order assignment W is defined for all interpretations I , J , K by"}, {"heading": "J \u2264IW K if and only if (J \u00f7 I) \u2286 (K \u00f7 I) ,", "text": "where \u00f7 denotes set-theoretic symmetric difference. It is not difficult to verify that W is a faithful partial order assignment, so it follows from Theorem 4 that any belief update operator characterised by W satisfies postulates (B1) \u2013 (B8). Note that there is a whole class of operators characterised by W that differ in the syntactic representation of updated belief bases. Insofar as we are interested in the semantic properties of Winslett\u2019s updates, it follows from (B4) that it does not matter which operator from this class we pick. This is illustrated in the following example:\nExample 5 (Winslett\u2019s belief update semantics) Consider the knowledge base \u03c6 = (p\u2227 (q \u2261 r)) and the update \u00b5 = (q \u2228 r) over the set of atoms A = { p, q, r }. Their sets of models are as follows:\nJ\u03c6K = { { p } , { p, q, r } } , J\u00b5K = { { q } , { r } , { q, r } , { p, q } , { p, r } , { p, q, r } } .\nWhen performing an update of \u03c6 by \u00b5 under Winslett\u2019s update semantics, equation (1) applies as follows:\nJ\u03c6 \u00b5K = \u22c3\nI\u2208J\u03c6K min\n( J\u00b5K,\u2264IW ) = min ( J\u00b5K,\u2264{ p }W ) \u222amin ( J\u00b5K,\u2264{ p,q,r }W ) .\nThe models of \u00b5 that \u201cdiffer least\u201d from { p }, in the sense of the order assignment W, are { p, q } and { p, r }. Furthermore, since W is faithful, the unique model of \u00b5 that is minimally distant from { p, q, r } is { p, q, r } itself. Consequently,\nJ\u03c6 \u00b5K = { { p, q } , { p, r } , { p, q, r } } .\nNote that from the syntactic viewpoint, \u03c6 \u00b5 can be any formula with the above set of models. Thus, it may for example be the case that \u03c6 \u00b5 = (p \u2227 (q \u2228 r)) while for another operator \u2032, also characterised by W, \u03c6 \u2032 \u00b5 = ((p \u2227 q) \u2228 (p \u2227 r))."}, {"heading": "2.2 Computational Complexity of Winslett\u2019s Update Semantics", "text": "Computationally, query answering for Winlett\u2019s operator, i.e. the problem of deciding whether \u03c6 \u00b5 |= \u03c8, where is characterised by W, belongs to the second level of the polynomial hierarchy (Eiter and Gottlob 1992). We formulate this result formally as it later facilitates the study of computational complexity of a newly introduced rule update operator.\nAssuming that the reader is familiar with the classes NP and co-NP, we briefly introduce the polynomial hierarchy (Meyer and Stockmeyer 1972; Stockmeyer 1976). Its definition relies on the notion of an oracle: An oracle for a class of decision problems C can decide any problem in C in just one step of computation. We denote by NPC the class of decision problems solvable in polynomial time by a non-deterministic Turing machine that can make calls to an oracle for C. The classes \u03a3Pi and \u03a0 P i of the polynomial hierarchy are defined inductively as follows: \u03a3P0 = \u03a0 P 0 = P and for all i \u2265 0,\n\u03a3Pi+1 = NP \u03a3Pi and \u03a0Pi+1 = co-\u03a3 P i+1 .\nIn the general case, query answering for Winslett\u2019s updates is \u03a0P2 -complete.\nTheorem 6 (Part of Theorem 6.4 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W. Deciding whether \u03c6 \u00b5 |= \u03c8 for formulae \u03c6, \u00b5, \u03c8 is \u03a0P2 -complete. Hardness holds even if \u03c6 is a conjunction of atoms and \u03c8 is one of the atoms in that conjunction.\nHowever, when dealing only with Horn formulae, the problem drops to the first level of the polynomial hierarchy:\nTheorem 7 (Part of Theorem 7.2 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W. Deciding whether \u03c6 \u00b5 |= \u03c8 for Horn formulae \u03c6, \u00b5, \u03c8 is co-NP-complete. Hardness holds even if \u03c6 is a conjunction of objective literals and \u03c8 is one of the literals in that conjunction."}, {"heading": "2.3 Logic Programming", "text": "We define the syntax and semantics of logic programs, borrowing some of the notation used in (Delgrande et al. 2008).\nAn atom is any p \u2208 A. A literal is an atom p or its default negation \u223cp. Given a set of literals S, we introduce the following notation:\nS+ = { p \u2208 A | p \u2208 S } , S\u2212 = { p \u2208 A | \u223cp \u2208 S } , \u223cS = { \u223cp | p \u2208 S \u2229A } , \u00acS = { \u00acp | p \u2208 S \u2229A } .\nA rule is a pair of sets of literals \u03c0 = (H(\u03c0), B(\u03c0)). We say that H(\u03c0) is the head of \u03c0 and B(\u03c0) is the body of \u03c0. Usually, for convenience, we write \u03c0 as\nH(\u03c0)+;\u223cH(\u03c0)\u2212 \u2190 B(\u03c0)+,\u223cB(\u03c0)\u2212. (2)\nOperators \u2018;\u2019 and \u2018,\u2019 express disjunctive and conjunctive connectives, respectively. A rule is called a fact if its head contains exactly one literal and its body is empty. A fact is positive if the literal in its head is an atom. A rule is non-disjunctive if its head contains at most one literal; definite if it is non-disjunctive and its head and body contain only atoms. A program is a set of rules. A program is non-disjunctive if all rules inside it are non-disjunctive; definite if all rules inside it are definite.\nTurning to the semantics, we need to define answer sets and SE-models of a logic program. We start by defining the more basic notion of a (classical) model of a logic program. For every rule \u03c0 of the form (2) we denote by \u03ba(\u03c0) the propositional formula\u2227\n(B(\u03c0)+ \u222a \u00acB(\u03c0)\u2212) \u2283 \u2228 (H(\u03c0)+ \u222a \u00acH(\u03c0)\u2212) .\nFor a program P, \u03ba(P) = \u2227 \u03c0\u2208P \u03ba(\u03c0). An interpretation J is a model of a program P, denoted by J |= P, if J |= \u03ba(P). We say that P is consistent if it has some classical model.\nAn interpretation J is an answer set of a program P if it is a subset-minimal model of the reduct of P relative to J :\nPJ = { H(\u03c0)+ \u2190 B(\u03c0)+. \u2223\u2223 \u03c0 \u2208 P \u2227H(\u03c0)\u2212 \u2286 J \u2227B(\u03c0)\u2212 \u2229 J = \u2205 } . SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets. We use SE-models in the following sections to reformulate the KM postulates for belief update in the context of rule updates.\nIntuitively, each SE-interpretation assigns one of three truth values to every atom. Technically it consists of a pair of propositional interpretations, the first containing atoms that are true and the second containing atoms that are not false. Formally:\nDefinition 8 (SE-interpretation (Turner 2003)) An SE-interpretation is a pair of interpretations (I, J) such that I \u2286 J . The set of all SE-interpretations is denoted by X.\nSE-models themselves are defined by referring to the program reduct used to define answer sets above.\nDefinition 9 (SE-model (Turner 2003)) Let P be a program. An SE-interpretation (I, J) is an SE-model of P if J |= P and I |= PJ . The set of all SE-models of P is denoted by JP KSE and we write (I, J) |= P if (I, J) \u2208 JP KSE.\nNote that J |= P if and only if (J, J) \u2208 JP KSE, so SE-models capture the classical models of a program. And just like classical models, the set of SE-models of a program is monotonic, i.e. larger programs have smaller sets of SE-models. This is one of the important differences between SE-models and the non-monotonic answer sets.\nNevertheless, a program\u2019s answer sets, just like its classical models, can be extracted from its set of SE-models: An interpretation J is an answer set of P if and only if (J, J) \u2208 JP KSE and no (I, J) \u2208 JP KSE with I ( J exists. This implies that programs with the same set of SE-models also have the same answer sets. Moreover, when such programs are augmented with the same set of rules, the resulting programs still have the same answer sets. In many situations such a property is desirable as it allows one program to be modularly replaced by another one, even in the presence of additional rules, without affecting the resulting answer sets. It is typically referred to as strong equivalence (Lifschitz et al. 2001) and the relationship between SE-models and strong equivalence is formally captured as follows:\nProposition 10 (SE-models and strong equivalence (Turner 2003)) Let P,Q be programs. It holds that JP KSE = JQKSE if and only if for every programR, the answer sets of P \u222aR and Q\u222aR are the same.\nIn other words, SE-models exactly capture the concept of strong equivalence. This also explains the origin of the name SE-models \u2013 \u201cSE\u201d stands for strong equivalence. Based on this result, we define strong equivalence and entailment as follows:\nDefinition 11 (Strong equivalence and strong entailment) Let P, Q be programs. We say that P is strongly equivalent to Q, denoted by P \u2261SE Q, if JP KSE = JQKSE, and that P strongly entails Q, denoted by P |=SE Q, if JP KSE \u2286 JQKSE.\nAn important distinguishing property of SE-models that we will need to carefully consider in the following sections is that whenever a program P has the SE-model (I, J), it also has the SE-model (J, J). More generally, any set of SE-interpretations with this property is referred to as well-defined (Delgrande et al. 2008).\nDefinition 12 (Well-defined set of SE-interpretations (Delgrande et al. 2008)) For every SE-interpretation X = (I, J) we denote by X\u2217 the SE-interpretation (J, J). A set of SE-interpretationsM is well-defined if for every SE-interpretation X , X \u2208 M implies X\u2217 \u2208M.\nIn fact, as pinpointed in the following result, not only is the set of SE-models of a program well-defined, but every well-defined set of SE-interpretations is also the set of SE-models of some program.\nProposition 13 (Delgrande et al. 2008) A set of SE-interpretationsM is well-defined if and only ifM = JP KSE for some program P.\nAs a consequence, whenever I ( J , there is no program that has the single SE-model X = (I, J), though there is a program that has the pair of SE-models X , X\u2217. The following notion of a basic program is thus analogous to the concept of a complete formula that is used in the formulation of belief update postulate (B7).\nDefinition 14 (Basic program) We say that a program P is basic if JP KSE = {X,X\u2217 } for some SE-interpretation X .\nNote that a program is basic if either it has a unique SE-model (J, J), or a pair of SE-models (I, J) and (J, J). In the former case, the program exactly determines the truth values of all atoms \u2013 the atoms in J are true and the remaining atoms are false. In the latter case, the program makes atoms in I true, the atoms in J \\ I may either be undefined or true, as long as they all have the same truth value, and the remaining atoms are false.\n3 Semantic Rule Updates Based on SE-Models\nWith the necessary concepts defined, we are ready to step forward and tailor the belief update postulates and operators to the context of logic programs viewed through their sets of SE-models. Since SE-models provide a monotonic characterisation of logic programs, the analysis provided in (Eiter et al. 2002), which showed KM postulates not appropriate for use with non-monotonic semantics, no longer applies. In the following we reformulate the belief update postulates as well as a constructive characterisation of semantic rule update operators, and finally show a counterpart of the representation theorem for belief updates. The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; S\u030cefra\u0301nek 2011).\nSimilarly as in the case of belief updates, we liberally define a rule update operator as any function that takes two inputs, the original program and its update, and returns the updated program.\nDefinition 15 (Rule update operator) A rule update operator is a binary function on the set of all programs.\nIn order to reformulate postulates (B1) \u2013 (B8) for logic programs under the SE-model semantics, we first need to specify what a conjunction and disjunction of logic programs is. To this end, we introduce program conjunction and disjunction operators. These are required to assign, to each pair of programs, a program whose set of SE-models is the intersection and union, respectively, of the sets of SE-models of argument programs.\nDefinition 16 (Program conjunction and disjunction) A binary operator \u2227\u0307 on the set of all programs is a program conjunction operator if for all programs P, Q,\nJP \u2227\u0307 QKSE = JP KSE \u2229 JQKSE .\nA binary operator \u2228\u0307 on the set of all programs is a program disjunction operator if for all programs P, Q,\nJP \u2228\u0307 QKSE = JP KSE \u222a JQKSE .\nIn the following we assume that some program conjunction and disjunction operators \u2227\u0307, \u2228\u0307 are given. Note that the program conjunction operator may simply return the union of argument programs; it is the same as the expansion operator defined in (Delgrande et al. 2008). A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).\nThe final obstacle before we can proceed with introducing the new postulates is the following: We need to substitute the notion of a complete formula used in (B7) with a suitable class of logic programs. It turns out that the notion of a basic program, as introduced in Definition 14, is a natural candidate for this purpose. While a complete formula is defined as having a unique model, a program is basic if it has either a unique SE-model (J, J), or a pair of SE-models (I, J) and (J, J). The latter case needs to be allowed in order to make the new postulate applicable to SE-interpretations (I, J) with I ( J because no program has the single SE-model (I, J) (c.f. Proposition 13).\nThe following are the reformulated postulates for a rule update operator\u2295 and programs P, Q, U , V:\n(P1)SE P \u2295 U |=SE U . (P2)SE If P |=SE U , then P \u2295 U \u2261SE P. (P3)SE If JP KSE 6= \u2205 and JU KSE 6= \u2205, then JP \u2295 U KSE 6= \u2205. (P4)SE If P \u2261SE Q and U \u2261SE V , then P \u2295 U \u2261SE Q\u2295 V . (P5)SE (P \u2295 U) \u2227\u0307 V |=SE P \u2295 (U \u2227\u0307 V). (P6)SE If P \u2295 U |=SE V and P \u2295 V |=SE U , then P \u2295 U \u2261SE P \u2295 V . (P7)SE If P is basic, then (P \u2295 U) \u2227\u0307 (P \u2295 V) |=SE P \u2295 (U \u2228\u0307 V). (P8)SE (P \u2228\u0307 Q)\u2295 U \u2261SE (P \u2295 U) \u2228\u0307 (Q\u2295 U).\nNow we turn to a constructive characterisation of rule update operators satisfying conditions (P1)SE \u2013 (P8)SE. Analogically to belief updates, it is based on an order assignment, but this time over the set of all SE-interpretations X. Since the set of SE-models of a program must be well-defined, not every order assignment characterises a rule update operator. We thus additionally define well-defined order assignments as those that do.\nDefinition 17 (Rule update operator characterised by an order assignment) Let \u2295 be a rule update operator and \u03c9 a preorder assignment over X. We say that \u2295 is characterised by \u03c9 if for all programs P, U ,\nJP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264X\u03c9 ) .\nWe say that a preorder assignment over X is well-defined if some rule update operator is characterised by it.\nSimilarly as with belief update, we require the order assignment to be faithful, i.e. to consider each SE-interpretation the closest to itself.\nDefinition 18 (Faithful order assignment) A preorder assignment \u03c9 over X is faithful if for every SE-interpretation X the following condition is satisfied:\nFor every Y \u2208 X with Y 6= X it holds that X <X\u03c9 Y .\nInterestingly, faithful assignments characterise the same class of operators as the larger class of semi-faithful assignments, defined as follows:\nDefinition 19 (Semi-faithful order assignment) A preorder assignment \u03c9 over X is semi-faithful if for every SE-interpretation X the following conditions are satisfied:\n1. For every Y \u2208 X with Y 6= X and Y 6= X\u2217, either X <X\u03c9 Y or X\u2217 <X\u03c9 Y . 2. If X\u2217 \u2264X\u03c9 X , then X \u2264X\u03c9 X\u2217.\nFinally, we require the preorder assignment to satisfy one further condition, related to the well-definedness of sets of SE-models of every program. It can be seen as the natural semantic counterpart of (P7)SE.\nDefinition 20 (Organised order assignment) A preorder assignment \u03c9 is organised if for all SE-interpretations X , Y and all welldefined sets of SE-interpretationsM,N the following condition is satisfied:\nIf Y \u2208 min(M,\u2264X\u03c9 ) \u222amin(M,\u2264X \u2217 \u03c9 ) and Y \u2208 min(N ,\u2264X\u03c9 ) \u222amin(N ,\u2264X \u2217 \u03c9 ), then Y \u2208 min(M\u222aN ,\u2264X\u03c9 ) \u222amin(M\u222aN ,\u2264X \u2217 \u03c9 ).\nNow we are ready to formulate the main result of this section:\nTheorem 21 (Representation theorem for rule updates) Let \u2295 be a rule update operator. The following conditions are equivalent:\na) The operator \u2295 satisfies conditions (P1)SE \u2013 (P8)SE. b) The operator \u2295 is characterised by a semi-faithful and organised preorder assignment. c) The operator \u2295 is characterised by a faithful and organised partial order assignment."}, {"heading": "Proof", "text": "See Appendix A, page 25.\nThis theorem provides a constructive characterisation of rule update operators satisfying the defined postulates. It facilitates the analysis of their properties, both semantic as well as computational. Note also that it implies that the larger class of semi-faithful and organised preorder assignments is equivalent to the smaller class of faithful and organised partial order assignments. Furthermore, it offers a strategy for defining operators satisfying the postulates that can be directly applied whenever an order assignment is known or can be approximated. This strategy is also complete in the sense that, up to strong equivalence, all operators satisfying the postulates can be characterised and distinguished by applying this strategy.\nIn what follows, we define a specific update operator based on the ideas underlying Winslett\u2019s update semantics (Keller and Winslett 1985; Winslett 1990) defined Section 2. Similarly as was argued in (Delgrande et al. 2008), since we are working with well-defined sets of SE-interpretations, preference needs to be given to their second component. Thus, we extend the assignment W to all SE-interpretations X = (I, J), Y = (K1, L1), Z = (K2, L2) as follows: Y \u2264XW Z if and only if the following conditions are satisfied:\n1. (L1 \u00f7 J) \u2286 (L2 \u00f7 J); 2. If (L1 \u00f7 J) = (L2 \u00f7 J), then (K1 \u00f7 I) \\\u2206 \u2286 (K2 \u00f7 I) \\\u2206 where \u2206 = L1 \u00f7 J .\nIntuitively, first we compare the differences between the second components of Y and Z w.r.t. X . If they are equal, we compare the differences between the first components of Y and Z w.r.t. X , but now ignoring the differences between the second components. A concrete illustration of these comparisons is presented next:\nExample 22 (Assignment W for SE-interpretations) Let the SE-interpretations X , Y , Z1, Z2, Z3 be as follows:1\nX = (I, J) = (p, pq) , Y = (K,L) = (p, pr) ,\nZ1 = (K1, L1) = (p, prs) , Z2 = (K2, L2) = (\u2205, pr) , Z3 = (K3, L3) = (pr, pr) .\nWe can see that (L \u00f7 J) = { q, r } ( { q, r, s } = (L1 \u00f7 J), so it follows that Y \u2264XW Z1 holds and it is not the case that Z1 \u2264XW Y . Thus, Y <XW Z1.\nOn the other hand, (L\u00f7 J) = (L2 \u00f7 J) = (L3 \u00f7 J) = \u2206 = { q, r }, so Y and Z2 can only be distinguished based on the second condition. Furthermore, we have (K\u00f7I)\\\u2206 = \u2205 ( { p } = (K2 \u00f7 I) \\\u2206. Similarly as before, we obtain Y <XW Z2.\nA slightly different case occurs with Z3 because (K3\u00f7 I) \\\u2206 = { r } \\ { q, r } = \u2205 and it follows that both Y \u2264XW Z3 and Z3 \u2264XW Y hold, despite the fact that Y 6= Z3.\nOur following result shows that W indeed satisfies the necessary conditions to characterise rule update operators satisfying the reformulated postulates.\nProposition 23 The assignment W is a well-defined, faithful and organised preorder assignment."}, {"heading": "Proof", "text": "See Appendix A, page 29.\nFurthermore, as a consequence of Theorem 21 and Proposition 23:\nCorollary 24 Every rule update operator characterised by W satisfies conditions (P1)SE \u2013 (P8)SE.\nAs regards the computational complexity of query answering for rule update operators characterised by W, it follows the same pattern as query answering for Winslett\u2019s belief update operator (c.f. Theorems 6 and 7). In the general case, it resides in the second level of the polynomial hierarchy while for definite programs it drops to the first level. Formally:\n1 For the sake of readability, we omit the usual set notation when listing SE-interpretations. For example, instead of ({ p } , { p, q }) we simply write (p, pq).\nTheorem 25 (Computational complexity of rule updates characterised by W) Let \u2295 be a rule update operator characterised by W. Deciding whether P \u2295 U |=SE Q for programs P, U , Q is \u03a0P2 -complete. Hardness holds even if P is a set of positive facts, U is a non-disjunctive program and Q contains a single fact from P."}, {"heading": "Proof", "text": "See Appendix A, page 34.\nTheorem 26 (Computational complexity of definite rule updates characterised by W) Let \u2295 be a rule update operator characterised by W. Deciding whether P \u2295 U |=SE Q for definite programs P, U , Q is co-NP-complete. Hardness holds even if P is a set of facts and Q contains a single fact from P."}, {"heading": "Proof", "text": "See Appendix A, page 35."}, {"heading": "4 Support in Semantic Rule Updates", "text": "In this section we take a closer look at the behaviour of semantic rule update operators. One of the benefits of dealing with rule updates on the semantic level is that semantic properties that are rather difficult to show for syntax-based update operators are much easier to analyse and prove. For example, one of the most widespread and counterintuitive side effects of syntactic updates is that they are sensitive to tautological updates. In case of semantic update operators, such a behaviour is easily shown to be impossible given that the operator satisfies (P2)SE.\nHowever, semantic update operators do not always behave the way we expect. Consider first an example using some update operator \u2295 characterised by the order assignment W defined in the previous section:2\nExample 27 Let the programs P, Q and U be as follows:\nP : p. Q : p\u2190 q. U : \u223cq. q. q.\nIt can be easily verified that:\nJP \u2295 U K SE = JQ\u2295 U K SE = { (p, p) } .\nHence, both P\u2295U andQ\u2295U have the single answer set J = { p }. In case of P\u2295U this is indeed the expected result. But in case ofQ\u2295U we can see that p is true in J even though there is no rule in Q \u222a U justifying it, i.e. there is no rule with p in its head and its body\n2 It has been shown that Winslett\u2019s update semantics has some drawbacks, just as other update operators previously proposed in the context of Classical Logic do (see (Herzig and Rifi 1999) for a survey). Nevertheless, we decided to choose Winslett\u2019s update operator as the basis to define a rule update operator and illustrate its properties because it is one of the most extensively studied and understood update operators, and because the undesired behaviour illustrated in this example is shared by all update operators based on KM postulates and SE-models \u2013 as we shall see \u2013 and not a specific problem due to our choice of Winslett\u2019s operator.\nsatisfied in J . This means that the behaviour of \u2295 is in discord with intuitions underlying most Logic Programming semantics.\nIn the following we show that such counterintuitive behaviour is not specific to \u2295, but extends to all semantic update operators for answer-set programs based on the wellestablished notions of SE-models and KM postulates. This is especially interesting from the point of view of comparison with syntax-based approaches to rule updates that, as we formally pinpoint in what follows, do not suffer from such drawbacks.\nThe property of support (Apt et al. 1988; Dix 1995b) is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy. In the static case, this property can be formulated as follows:\nDefinition 28 (Static support) Let P be a program, p an atom and J an interpretation. We say that P supports p in J if there is some rule \u03c0 \u2208 P such that p \u2208 H(\u03c0) and J |= B(\u03c0).\nA Logic Programming semantics S is supported if for each model J of a program P under S the following condition is satisfied: Every atom p \u2208 J is supported by P in J .\nA supported semantics thus requires all atoms in an assigned model to be in the head of some rule with a satisfied body, ensuring that no atom is true without at least some justification. Note that the widely accepted Logic Programming semantics, such as the answer-set and well-founded semantics, are supported (see (Dix 1995a; Dix 1995b) for more on properties of Logic Programming semantics).\nIt is only natural to require that rule update operators do not neglect this essential property which also gives rise to much of the intuitive appeal of Logic Programming systems. As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:\nDefinition 29 (Dynamic support) We say that a rule update operator\u2295 respects support if the following condition is satisfied for all programs P, U and all answer sets J of P \u2295 U : Every atom p \u2208 J is supported by P \u222a U in J .\nSo an update operator respects support if it returns only programs whose answer sets are supported by rules from either the original program or from its update. Similarly as in the case of static support, this amounts to the requirement that an atom may be true only if at least some justification can be found for it.\nAnother basic expectation from an update operator is the usual intuition regarding how facts should be updated by newer facts. It enforces the principle of literal inertia, but only for the case when both the initial program and its update are consistent sets of facts. Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:\nDefinition 30 (Fact update) We say that a rule update operator \u2295 respects fact update if for all consistent sets of facts P, U , the unique answer set of P \u2295 U is the interpretation\n{ p | (p.) \u2208 P \u222a U \u2227 (\u223cp.) /\u2208 U } .\nThus, a rule update operator respects fact update if it is well-behaved w.r.t. consistent sets of facts: it provides the answer set that contains exactly those atoms that are asserted as true in either the original program or its update, and are not asserted as false in the update. This behaviour is widely accepted \u2013 it stems from the intuitions regarding database updates and is uncontroversial in both the belief change and rule change communities.\nWe conjecture that any reasonable update operator for answer-set programs should satisfy support and fact update since these two properties place basic constraints on its behaviour and are based on fundamental and widely accepted intuitions. They are by no means exhaustive or sufficient \u2013 it is not difficult to define rule update operators that satisfy both of them but are sensitive to tautological updates or quickly end up in an inconsistent state without a possibility of recovery \u2013 but they both seem necessary, even elementary, properties of a well-behaved rule update operator. However, it turns out that every rule update operator based on SE-models, even if it satisfies only the basic postulate that enforces syntax independence, fails to comply with at least one of these two basic expectations.\nTheorem 31 A rule update operator that satisfies (P4)SE either does not respect support or it does not respect fact update."}, {"heading": "Proof", "text": "Let \u2295 be a rule update operator that satisfies (P4)SE and consider again the programs P, Q and U from Example 27. Since P is strongly equivalent to Q, by (P4)SE we obtain that P \u2295 U is strongly equivalent to Q\u2295 U . Consequently, P \u2295 U has the same answer sets as Q\u2295U . It only remains to observe that if\u2295 respects fact update, then P\u2295U has the unique answer set { p }. But then { p } is an answer set of Q \u2295 U in which p is unsupported by Q\u222a U . Hence \u2295 does not respect support.\nSo any answer-set program update operator based on SE-models and the KM approach to belief update, as materialised in the fundamental principle (P4)SE, cannot respect two basic and desirable properties: support and fact update. We believe that this is a major drawback of such operators, severely diminishing their applicability.\nMoreover, the principle (P4)SE is also adopted for revision of answer-set programs based on SE-models in (Delgrande et al. 2008).3 This means that Theorem 31 extends to semantic program revision operators, such as those defined in (Delgrande et al. 2008): Whenever\n3 Note that the belief update postulate (B4), from which (P4)SE originates, is also one of the reformulated AGM postulates for belief revision (Katsuno and Mendelzon 1992). The original AGM framework (Alchourro\u0301n et al. 1985) assumes that the initial knowledge base B is closed w.r.t. logical consequence and the first AGM postulate requires that the result of revision also be a closed set. Under these assumptions, different knowledge bases cannot be equivalent and, as a consequence, the original AGM postulate corresponding to (B4) is ?5: If Cn(\u00b5) = Cn(\u03bd), then B ? \u00b5 = B ? \u03bd (where Cn is the logical consequence operator and ? the revision operator.)\nsupport and fact update are expected to be satisfied by a rule revision operator, it cannot be defined by purely manipulating the sets of SE-models of the underlying programs.\nOne question that suggests itself is whether a weaker version of the principle (P4)SE can be combined with properties such as support and fact update. Its two immediate weakenings, analogous to the weakenings of (B4) in (Herzig and Rifi 1999), are as follows:\n(P4.1)SE If P \u2261SE Q, then P \u2295 U \u2261SE Q\u2295 U . (P4.2)SE If U \u2261SE V , then P \u2295 U \u2261SE P \u2295 V .\nIn case of (P4.1)SE, it is easy to see that the proof of Theorem 31 applies in the same way as with (P4)SE, so (P4.1)SE is likewise incompatible with support and fact update.\nOn the other hand, principle (P4.2)SE, also referred to as Weak Independence of Syntax (WIS) (Osorio and Cuevas 2007), does not suffer from such severe limitations. It is, nevertheless, violated by syntax-based rule update semantics that assign a special meaning to occurrences of default literals in heads of rules, as illustrated in the following example:\nExample 32 Let the programs P, U and V be as follows:\nP : p. U : \u223cp\u2190 q. V : \u223cq \u2190 p. q.\nSince U is strongly equivalent to V , (P4.2)SE requires that P \u2295 U be strongly equivalent to P\u2295V . This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal \u223cp in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true. A consequence of this is that an update of P by U results in the single answer set { q } while an update by V leads to the single answer set { p }.\nThus, when considering the principle (P4.2)SE, benefits of the declarativeness that it brings with it need to be weighed against the loss of control over the results of updates by rules with default literals in their heads.\nThe problems we identified might be mitigated if a richer semantic characterisation of logic programs was used instead of SE-models. Such a characterisation would have to be able to distinguish between programs such as P = { p., q. } and Q = { p\u2190 q., q. } because they are expected to behave differently when subject to evolution.\nAnother alternative is to use one of the syntactic approaches to rule updates, e.g. (Alferes et al. 2005), that have matured over the years."}, {"heading": "5 Conclusion", "text": "In this paper we revisited the problem of updates of answer-set programs, in an attempt to change the focus from the syntactic representation of a program to its semantic content and to facilitate the analysis of semantic properties of defined update operators. We did so by applying the established approach to updates following Katsuno and Mendelzon\u2019s postulates in the context of logic programs. Whereas until recently this was not possible since these postulates were simply not applicable (nor adaptable) when considering\nnon-monotonic Logic Programming semantics, as shown in (Eiter et al. 2002), the introduction of SE-models (Turner 2003), which provide a monotonic characterisation of logic programs that is strictly more expressive than the answer-set semantics, provided a new opportunity to cast KM postulates into Logic Programming.\nWe adapted the KM postulates to be used for answer-set program updates and showed a representation theorem which provides a constructive characterisation of rule update operators satisfying the postulates. This characterisation not only facilitates the investigation of these operators\u2019 properties, both semantic as well as computational, but it also provides an intuitive strategy for constructively defining these operators. This is one of the major contributions of the paper since it brings, for the first time, updates of answer-set programs in line with KM postulates. We illustrated this result with a definition of a specific rule update operator which is a counterpart of Winslett\u2019s belief update operator.\nThe second important contribution of this paper is the uncovering of a serious drawback that extends to all answer-set program update operators based on SE-models and AGMstyle approach to program revision and update. All such operators violate at least one of two basic and very desirable properties. The first one consists of respecting support, a property that is enjoyed, in the static case, by all widely accepted Logic Programming semantics. The second property, fact update, is concerned with the answer set assigned to a consistent set of facts after it is updated by another consistent set of facts. This contribution is very important as it should guide further research on updates of answer-set programs\na) away from the purely semantic approach materialised in AGM and KM postulates, or b) to the development of semantic characterisations of answer-set programs that are richer than SE-models and appropriately capture their dynamic behaviour, such as in (Slota and Leite 2012), or even c) turning back to the more syntactic approaches, such as (Alferes et al. 2005), and see whether they indeed offer a viable alternative.\nEither way, updating answer-set programs is a very important theoretical and practical problem that is still waiting for a definite solution. Also, despite the issues with the syntax independence postulate (P4)SE, other principles based on SE-models play an important role with regards to the classification and evaluation of different approaches to rule change. For instance, the reformulations of rule change principles from (Eiter et al. 2002) in terms of strong equivalence, considered already in (Delgrande et al. 2008), can be formulated as follows:\n(Initialisation)SE \u2205 \u2295 U \u2261SE U . (Idempotence)SE P \u2295 P \u2261SE P.\n(Tautology)SE If U \u2261SE \u2205, then P \u2295 U \u2261SE P. (Absorption)SE If U \u2261SE V , then (P \u2295 U)\u2295 V \u2261SE P \u2295 V . (Augmentation)SE If V |=SE U , then (P \u2295 U)\u2295 V \u2261SE P \u2295 V .\nWe believe that all of these properties are indeed desirable and strengthen their original formulations in an interesting way. Investigation of operators with these properties, as well as a further analysis of the postulates (P1)SE \u2013 (P8)SE, remains an important research topic.\nThis paper contains, we believe, a relevant contribution to a better understanding of rule change that will help guide future research."}, {"heading": "Acknowledgement", "text": "We would like to thank the anonymous reviewers for their valuable comments. M. Slota was supported by FCT scholarship SFRH/BD/38214/2007. J. Leite was partially supported by FCT funded project ERRO (PTDC/EIA-CCO/121823/2010)."}, {"heading": "Appendix A Proofs: Representation Theorem", "text": "Definition 33 (Program corresponding to a set of SE-interpretations) LetM be a set of SE-interpretations. We denote by \u2016M\u2016 some arbitrary but fixed program P such that JP KSE = {X,X\u2217 | X \u2208M } . Instead of \u2016 {X1, X2, . . . , Xn } \u2016 we usually write \u2016X1, X2, . . . , Xn\u2016.\nDefinition 34 (Order assignment generated by an update operator) Let \u2295 be a rule update operator and X an SE-interpretation. We define the binary relation \u227aX\u2295 for all SE-interpretations Y , Z as follows: Y \u227aX\u2295 Z if and only if the following conditions are satisfied:\nY \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE (A1) Z /\u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE (A2) If Y 6= Y \u2217, then Z \u2208 J\u2016X\u2016 \u2295 \u2016Y \u2217, Z\u2016KSE (A3)\nThe preorder assignment generated by\u2295 assigns to every SE-interpretationX the reflexive and transitive closure\u2264X\u2295 of\u227aX\u2295 , i.e. Y \u2264X\u2295 Z if and only if Y = Z or there is some n \u2265 2 and SE-interpretations Y1, Y2, . . . , Yn such that Y = Y1 \u227aX\u2295 Y2 \u227aX\u2295 \u00b7 \u00b7 \u00b7 \u227aX\u2295 Yn = Z.\nLemma 35 Let \u2295 be a rule update operator satisfying conditions (P1)SE \u2013 (P8)SE and X , Y , Z some SE-interpretations. If Y \u2264X\u2295 Z, then either Y = Z or Z /\u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE."}, {"heading": "Proof", "text": "Suppose that Y 6= Z. Then, by the definition of\u2264X\u2295 , for some n \u2264 2 and SE-interpretations Y1, Y2, . . . , Yn it holds that Y = Y1 \u227aX\u2295 Y2 \u227aX\u2295 \u00b7 \u00b7 \u00b7 \u227aX\u2295 Yn = Z. We will prove by induction on n that Yn /\u2208 J\u2016X\u2016 \u2295 \u2016Y1, Yn\u2016KSE from which the desired result follows directly.\n1\u25e6 For n = 2 this follows from Y1 \u227aX\u2295 Y2 by (A2). 2\u25e6 We inductively assume that\nYn /\u2208 J\u2016X\u2016 \u2295 \u2016Y1, Yn\u2016KSE (A4)\nand prove that Yn+1 /\u2208 J\u2016X\u2016 \u2295 \u2016Y1, Yn+1\u2016KSE.\nWe know that Yn \u227aX\u2295 Yn+1, so by (A2) we obtain\nYn+1 /\u2208 J\u2016X\u2016 \u2295 \u2016Yn, Yn+1\u2016KSE . (A5) Considering that the program \u2016Y1, Yn, Yn+1\u2016\u2227\u0307\u2016Y1, Yn\u2016 is strongly equivalent to \u2016Y1, Yn\u2016, by (P5)SE and (P4)SE we conclude that\n(\u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016) \u2227\u0307 \u2016Y1, Yn\u2016 |=SE \u2016X\u2016 \u2295 \u2016Y1, Yn\u2016\nwhich, together with (A4), implies that\nYn /\u2208 J\u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016KSE . (A6) Similarly, since the program \u2016Y1, Yn, Yn+1\u2016 \u2227\u0307 \u2016Yn, Yn+1\u2016 is strongly equivalent to \u2016Yn, Yn+1\u2016, by (P5)SE and (P4)SE we obtain that\n(\u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016) \u2227\u0307 \u2016Yn, Yn+1\u2016 |=SE \u2016X\u2016 \u2295 \u2016Yn, Yn+1\u2016 ,\nand so due to (A5) it holds that\nYn+1 /\u2208 J\u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016KSE . (A7) Now we consider two cases:\na) If Yn = Y \u2217n , then (A6) and (P1)SE imply that\n\u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016 |=SE \u2016Y1, Yn+1\u2016 ; \u2016X\u2016 \u2295 \u2016Y1, Yn+1\u2016 |=SE \u2016Y1, Yn, Yn+1\u2016 ,\nso by (P6)SE we can conclude that \u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016 is strongly equivalent to \u2016X\u2016 \u2295 \u2016Y1, Yn+1\u2016. But then the desired conclusion follows from (A7).\nb) If Yn 6= Y \u2217n , then from (A3) we infer that\nYn+1 \u2208 J\u2016X\u2016 \u2295 \u2016Y \u2217n , Yn+1\u2016KSE . (A8) Furthermore, from (A6) and (P1)SE we obtain\n\u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016 |=SE \u2016Y1, Y \u2217n , Yn+1\u2016 ; \u2016X\u2016 \u2295 \u2016Y1, Y \u2217n , Yn+1\u2016 |=SE \u2016Y1, Yn, Yn+1\u2016 ,\nso by (P6)SE we can conclude that \u2016X\u2016 \u2295 \u2016Y1, Yn, Yn+1\u2016 is strongly equivalent to \u2016X\u2016 \u2295 \u2016Y1, Y \u2217n , Yn+1\u2016 and, due to (A7), Yn+1 /\u2208 J\u2016X\u2016 \u2295 \u2016Y1, Y \u2217n , Yn+1\u2016KSE . Since \u2016Y1, Y \u2217n , Yn+1\u2016 is strongly equivalent to \u2016Y1, Yn+1\u2016 \u2228\u0307 \u2016Y \u2217n , Yn+1\u2016, it follows from (P4)SE and (P7)SE that either Yn+1 /\u2208 J\u2016X\u2016 \u2295 \u2016Y1, Yn+1\u2016KSE or Yn+1 /\u2208 J\u2016X\u2016 \u2295 \u2016Y \u2217n , Yn+1\u2016KSE. The latter is impossible due to (A8).\nLemma 36 Let \u2295 be a rule update operator satisfying conditions (P1)SE \u2013 (P8)SE and X , Y , Z, some SE-interpretations. If Y \u226eX\u2295 Z, then the following conditions are satisfied: (1) If Y = Z\u2217, then Z \u2208 J\u2016X\u2016 \u2295 \u2016Y, Z\u2016KSE. (2) If Y = Y \u2217 and Z \u2208 J\u2016X\u2016 \u2295 \u2016Z\u2016KSE, then Z \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE. (3) If Y 6= Y \u2217 and Z \u2208 J\u2016X\u2016 \u2295 \u2016Y \u2217, Z\u2016KSE, then Z \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE."}, {"heading": "Proof", "text": "First we show the following auxiliary statement: If Y = Z or Y /\u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE, then all three conditions are satisfied.\nFirst suppose that Y = Z. If Y = Z\u2217, then Y = Y \u2217 = Z = Z\u2217, so it follows from (P1)SE and (P3)SE that J\u2016X\u2016\u2295\u2016Y,Z\u2016KSE = J\u2016X\u2016\u2295\u2016Z\u2217\u2016KSE = {Z\u2217 }, verifying condition (1). Furthermore, conditions (2) and (3) are satisfied because \u2016Z\u2016 = \u2016Y \u2217, Z\u2016 = \u2016Y,Z\u2016.\nNow suppose that Y /\u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE. If Y = Z\u2217, then it follows from (P1)SE and (P3)SE that Z \u2208 J\u2016X\u2016 \u2295 \u2016Y, Z\u2016KSE. If Y = Y \u2217, then it follows from (P1)SE that\n\u2016X\u2016 \u2295 \u2016Y,Z\u2016 |=SE \u2016Z\u2016 and \u2016X\u2016 \u2295 \u2016Z\u2016 |=SE \u2016Y, Z\u2016 ,\nso by (P6)SE we obtain that \u2016X\u2016 \u2295 \u2016Y,Z\u2016 \u2261SE \u2016X\u2016 \u2295 \u2016Z\u2016. Hence, it follows from Z \u2208 J\u2016X\u2016\u2295\u2016Z\u2016KSE that Z \u2208 J\u2016X\u2016\u2295\u2016Y,Z\u2016KSE. On the other hand, if Y 6= Y \u2217, then it follows from (P1)SE that\n\u2016X\u2016 \u2295 \u2016Y, Z\u2016 |=SE \u2016Y \u2217, Z\u2016 and \u2016X\u2016 \u2295 \u2016Y \u2217, Z\u2016 |=SE \u2016Y, Z\u2016 ,\nso by (P6)SE we obtain that \u2016X\u2016 \u2295 \u2016Y,Z\u2016 \u2261SE \u2016X\u2016 \u2295 \u2016Y \u2217, Z\u2016. Hence it follows from Z \u2208 J\u2016X\u2016 \u2295 \u2016Y \u2217, Z\u2016KSE that Z \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE.\nTurning to the proof of the lemma, note that since Y \u226eX\u2295 Z, either Y X\u2295 Z orZ \u2264X\u2295 Y . In the former case, Y \u2280X\u2295 Z, so, by the definition of \u227aX\u2295 , either Y /\u2208 J\u2016X\u2016 \u2295 \u2016Y, Z\u2016KSE, so we can apply our auxiliary statement, or Z \u2208 J\u2016X\u2016\u2295 \u2016Y,Z\u2016KSE as desired, or Y 6= Y \u2217 and Z /\u2208 J\u2016X\u2016 \u2295 \u2016Y \u2217, Z\u2016KSE, in which case all three conditions are trivially satisfied. In the latter case it follows from Lemma 35 that either Y = Z or Y /\u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE, so the rest follows once again from the auxiliary statement.\nProposition 37 Let \u2295 be a rule update operator satisfying conditions (P1)SE \u2013 (P8)SE, X an SE-interpretation and U a program. Then,\nJ\u2016X\u2016 \u2295 U KSE = min ( JU KSE,\u2264X\u2295 ) ."}, {"heading": "Proof", "text": "First take some Z \u2208 J\u2016X\u2016 \u2295 U KSE. By (P1)SE, Z \u2208 JU KSE. Suppose that Z is not minimal in JU KSE w.r.t. \u2264X\u2295 . Then there is some Y \u2208 JU KSE such that Y <X\u2295 Z. Thus, Y 6= Z, and by Lemma 35 we conclude that Z /\u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE. Considering that U \u2227\u0307 \u2016Y,Z\u2016 is strongly equivalent to \u2016Y,Z\u2016, it follows from (P4)SE and (P5)SE that (\u2016X\u2016\u2295U) \u2227\u0307 \u2016Y,Z\u2016 |=SE \u2016X\u2016\u2295\u2016Y, Z\u2016. Consequently, Z /\u2208 J\u2016X\u2016\u2295U KSE, contrary to our assumption. Therefore, J\u2016X\u2016 \u2295 U KSE is a subset of min(JU KSE,\u2264X\u2295 ).\nTo prove the converse inclusion, assume that Z is minimal in JU KSE w.r.t. \u2264X\u2295 and take some Y \u2208 JU KSE. Note that Y \u226eX\u2295 Z, so we can use Lemma 36. We will show that Z \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE. We consider three cases:\na) If Y = Z\u2217, then Z \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE follows immediately from condition (1) of Lemma 36. b) If Y = Y \u2217, then the previous case together with the fact that JU KSE is well-defined entails that Z \u2208 J\u2016X\u2016 \u2295 \u2016Z\u2016KSE and by condition (2) of Lemma 36 it follows that Z \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE.\nc) If Y 6= Y \u2217, then the previous case together with the fact that JU KSE is well-defined entails that Z \u2208 J\u2016X\u2016 \u2295 \u2016Y \u2217, Z\u2016KSE and by condition (3) of Lemma 36 it follows that Z \u2208 J\u2016X\u2016 \u2295 \u2016Y,Z\u2016KSE.\nThe choice of Y was arbitrary, so we have proven that Z \u2208 J\u2016X\u2016 \u2295 \u2016Y, Z\u2016KSE for all Y \u2208 JU KSE. This means that by repeated application of (P7)SE, Z is an SE-model of the program\n\u2016X\u2016 \u2295 \u2228\u0307\nY \u2208JU KSE\n\u2016Y,Z\u2016\nand since U is strongly equivalent to the program \u2228\u0307 Y \u2208JU KSE \u2016Y, Z\u2016, it follows from (P4)SE that Z \u2208 J\u2016X\u2016 \u2295 U KSE.\nProposition 38 If a rule update operator\u2295 satisfies conditions (P1)SE \u2013 (P8)SE, then the preorder assignment generated by \u2295 is semi-faithful and organised and it characterises \u2295."}, {"heading": "Proof", "text": "First we show that the assignment generated by \u2295 characterises \u2295. We know that P is strongly equivalent to the program \u2228\u0307 X\u2208JP KSE \u2016X\u2016, so by (P4)SE and repeated application of (P8)SE we obtain that P \u2295 U is strongly equivalent to the program\u2228\u0307 X\u2208JP KSE (\u2016X\u2016 \u2295 U) .\nFurthermore, Proposition 37 implies that J\u2016X\u2016 \u2295 U KSE = min ( JU KSE,\u2264X\u2295 ) , so indeed\nJP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nJ\u2016X\u2016 \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264X\u2295 ) . (A9)\nTo see that the assignment generated by \u2295 is semi-faithful, first take some SE-interpretations X , Y such that Y 6= X and Y 6= X\u2217. We need to show that either X <X\u2295 Y or X\u2217 <X\u2295 Y . The equation (A9) together with (P2)SE imply that\nJ\u2016X\u2016 \u2295 \u2016Y \u2217, X\u2016KSE = min ( {Y \u2217, X,X\u2217 } ,\u2264X\u2295 ) \u222amin ( {Y \u2217, X,X\u2217 } ,\u2264X \u2217 \u2295 ) = {X,X\u2217 } ,\nJ\u2016X\u2016 \u2295 \u2016Y,X\u2016KSE = min ( {Y, Y \u2217, X,X\u2217 } ,\u2264X\u2295 ) \u222amin ( {Y, Y \u2217, X,X\u2217 } ,\u2264X \u2217 \u2295 ) = {X,X\u2217 } .\nThus, Y \u2217 is not minimal within {Y \u2217, X,X\u2217 } and Y is not minimal within {Y, Y \u2217, X,X\u2217 } w.r.t. \u2264X\u2295 . In other words:\neither X <X\u2295 Y \u2217 or X\u2217 <X\u2295 Y \u2217 and (A10) either X <X\u2295 Y or X \u2217 <X\u2295 Y or Y \u2217 <X\u2295 Y . (A11)\nIn case of the first two alternatives of (A11), we have already achieved our goal. The third alternative together with (A10) and transitivity of <X\u2295 also concludes the proof of the first condition of semi-faithfulness. To see that the second condition holds as well, consider that\nby (P2)SE, J\u2016X\u2217\u2016 \u2295 \u2016X\u2016KSE = {X\u2217 } and J\u2016X\u2016 \u2295 \u2016X\u2016KSE = {X,X\u2217 }, so it follows from (A9) that\nX /\u2208 min({X,X\u2217 } ,\u2264X \u2217 \u2295 ) and X \u2208 min({X,X\u2217 } ,\u2264X\u2295 ) \u222amin({X,X\u2217 } ,\u2264X \u2217 \u2295 ) .\nHence, X \u2208 min({X,X\u2217 } ,\u2264X\u2295 ). In other words, if X\u2217 \u2264X\u2295 X , then it must also be the case that X \u2264X\u2295 X\u2217. Consequently, the order assignment generated by \u2295 is semi-faithful.\nTo show that it is also organised, consider well-defined sets of SE-interpretations M, N , and SE-interpretations X , Y such that\nY \u2208 min ( M,\u2264X\u2295 ) \u222amin ( M,\u2264X \u2217 \u2295 ) and Y \u2208 min ( N ,\u2264X\u2295 ) \u222amin ( N ,\u2264X \u2217 \u2295 ) .\nBy (A9) we obtain that Y \u2208 J\u2016X\u2016 \u2295 \u2016M\u2016KSE and Y \u2208 J\u2016X\u2016 \u2295 \u2016N\u2016KSE. Applying (P7)SE and (P4)SE yields that Y \u2208 J\u2016X\u2016 \u2295 \u2016M \u222a N\u2016KSE. Consequently, by (A9), either Y \u2208 min ( M\u222aN ,\u2264X\u2295 ) or Y \u2208 min ( M\u222aN ,\u2264X\u2217\u2295 ) , so the order assignment generated by \u2295 is organised.\nLemma 39 Let \u03c9 be a semi-faithful preorder assignment and X an SE-interpretation. Then there is no SE-interpretation Y such that Y <X\u03c9 X ."}, {"heading": "Proof", "text": "We prove by contradiction. Suppose that Y <X\u03c9 X for some SE-interpretation Y . Clearly, Y 6= X due to irreflexivity of <X\u03c9 and Y 6= X\u2217 due to the second condition of semifaithfulness. Hence, Y 6= X and Y 6= X\u2217, so by the first condition of semi-faithfulness, either X <X\u03c9 Y or X \u2217 <X\u03c9 Y . The former is in conflict with the irreflexivity of < X \u03c9 and in the latter case it follows by transitivity of <X\u03c9 that X \u2217 <X\u03c9 X , contrary to the second condition of semi-faithfulness.\nProposition 40 Let \u2295 be a rule update operator. If \u2295 is characterised by a semi-faithful and organised preorder assignment, then it is also characterised by a faithful and organised partial order assignment."}, {"heading": "Proof", "text": "Let \u2295 be characterised by a semi-faithful and organised preorder assignment \u03c9. We define the assignment \u03c9\u2032 over X as follows:"}, {"heading": "Y \u2264X\u03c9\u2032 Z if and only if Y = X \u2228 Y = Z \u2228 Y <X\u03c9 Z .", "text": "We need to show that \u2264X\u03c9\u2032 is a partial order for all X \u2208 X, that \u03c9\u2032 is faithful and organised and that for all programs P, U ,\nJP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264X\u03c9\u2032 ) .\nNote that due to Lemma 39, the following holds for all SE-interpretations X , Y :\nIf Y \u2264X\u03c9\u2032 X , then Y = X. (A12)\nOtherwise we would obtain that Y <X\u03c9 X which is in conflict with Lemma 39. Turning back to the main proof, reflexivity of \u2264X\u03c9\u2032 follows directly by its definition. To show that\u2264X\u03c9\u2032 is antisymmetric, take some SE-interpretations Y1, Y2 such that Y1 \u2264X\u03c9\u2032 Y2 and Y2 \u2264X\u03c9\u2032 Y1. If Y1 = X , then Y2 \u2264X\u03c9\u2032 X and it follows from (A12) that Y2 = X = Y1. The case when Y2 = X is symmetric. If Y1 6= X and Y2 6= X , then, by the definition of \u2264X\u03c9\u2032 , either Y1 = Y2 as desired, or Y1 <X\u03c9 Y2 and Y2 <X\u03c9 Y1, which is in conflict with the transitivity and irreflexivity of <X\u03c9 .\nTurning to transitivity of \u2264X\u03c9\u2032 , suppose that Y1 \u2264X\u03c9\u2032 Y2 and Y2 \u2264X\u03c9\u2032 Y3. We need to show that Y1 \u2264X\u03c9\u2032 Y3. We consider three cases:\na) If Y1 = X , then Y1 \u2264X\u03c9\u2032 Y3 by the definition of \u2264X\u03c9\u2032 . b) If Y2 = X , then Y1 \u2264X\u03c9\u2032 X , so Y1 = X due to (A12) and the previous case applies. c) If Y1 6= X and Y2 6= X , then the desired conclusion follows from the transitivity of\nequality and of <X\u03c9 .\nAs for faithfulness of \u03c9\u2032, suppose that Y 6= X . We have X \u2264X\u03c9\u2032 Y by definition and Y X\u03c9\u2032 X follows from (A12).\nTo show that \u03c9\u2032 is organised, we prove the following property: For any well-defined set of SE-interpretationsM and any SE-interpretation X ,\nmin ( M,\u2264X\u03c9\u2032 ) \u222amin ( M,\u2264X \u2217 \u03c9\u2032 ) = min ( M,\u2264X\u03c9 ) \u222amin ( M,\u2264X \u2217 \u03c9 ) . (A13)\nFrom (A13) it follows that since \u03c9 is organised, \u03c9\u2032 must also be. Before we prove (A13), we need to note that Y <X\u03c9\u2032 Z holds if and only if Y \u2264X\u03c9\u2032 Z and Z X\u03c9\u2032 Y , so according to the definition of \u2264X\u03c9\u2032 ,"}, {"heading": "Y <X\u03c9\u2032 Z if and only if (Y = X\u2228Y = Z\u2228Y <X\u03c9 Z)\u2227(Z 6= X\u2227Z 6= Y \u2227Z 6<X\u03c9 Y ) .", "text": "Due to Lemma 39 and the transitivity and irreflexivity of <X\u03c9 , this can be simplified to\nY <X\u03c9\u2032 Z if and only if (Y = X \u2227 Y 6= Z) \u2228 Y <X\u03c9 Z . (A14)\nComing back to the proof of (A13), we need to consider three cases:\na) If X /\u2208M and X\u2217 /\u2208M, then for all Y,Z \u2208M, Y 6= X and Y 6= X\u2217, so by (A14),\nY <X\u03c9\u2032 Z if and only if Y < X \u03c9 Z and Y <\nX\u2217 \u03c9\u2032 Z if and only if Y < X\u2217 \u03c9 Z ,\nfrom which the desired conclusion follows directly. b) If X /\u2208M and X\u2217 \u2208M, then for all Y,Z \u2208M, Y 6= X , so by (A14),\nY <X\u03c9\u2032 Z if and only if Y < X \u03c9 Z .\nConsequently, min(M,\u2264X\u03c9\u2032) = min(M,\u2264X\u03c9 ), and by (A14) and semi-faithfulness of \u03c9 we obtain min(M,\u2264X\u2217\u03c9\u2032 ) = {X\u2217 } = min(M,\u2264X \u2217\n\u03c9 ). c) If X \u2208M, then X\u2217 \u2208M, and by (A14) and semi-faithfulness of \u03c9,\n{X } \u2286 min ( M,\u2264X\u03c9 ) \u2286 {X,X\u2217 } , min ( M,\u2264X \u2217 \u03c9 ) = {X\u2217 } ,\nmin ( M,\u2264X\u03c9\u2032 ) = {X } , min ( M,\u2264X \u2217 \u03c9\u2032 ) = {X\u2217 } ,\nfrom which the desired conclusion follows straightforwardly.\nFinally, it follows from the assumption that \u03c9 characterises \u2295 and from (A13) that JP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264X\u03c9 ) =\n\u22c3 X\u2208JP KSE ( min ( JU KSE,\u2264X\u03c9 ) \u222amin ( JU KSE,\u2264X \u2217 \u03c9 )) =\n\u22c3 X\u2208JP KSE ( min ( JU KSE,\u2264X\u03c9\u2032 ) \u222amin ( JU KSE,\u2264X \u2217 \u03c9\u2032 )) =\n\u22c3 X\u2208JP KSE min ( JU KSE,\u2264X\u03c9\u2032 ) .\nProposition 41 Let \u2295 be a rule update operator. If \u2295 is characterised by a faithful and organised partial order assignment, then \u2295 satisfies conditions (P1)SE \u2013 (P8)SE."}, {"heading": "Proof", "text": "Let\u2295 be characterised by a faithful and organised partial order assignment \u03c9. We consider each condition separately:\n(P1)SE Since \u03c9 characterises \u2295, for all programs P, U , JP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264X\u03c9 ) ,\nso all elements of JP \u2295 U KSE belong to JU KSE. Equivalently, P \u2295 U |=SE U . (P2)SE Suppose that P |=SE U and take some X \u2208 JP KSE \u2286 JU KSE. Since the preorder\nassignment is faithful, for all Y \u2208 JU KSE with Y 6= X we have X <X\u03c9 Y . Consequently, min(JU KSE,\u2264X\u03c9 ) = {X } and so\nJP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264X\u03c9 ) = \u22c3 X\u2208JP KSE {X } = JP KSE .\n(P3)SE Suppose that both JP KSE 6= \u2205 and JU KSE 6= \u2205. Then there is some X0 \u2208 JP KSE and also some Y \u2208 min(JU KSE,\u2264X0\u03c9 ), so we obtain\nY \u2208 min ( JU KSE,\u2264X0\u03c9 ) \u2286 \u22c3 X\u2208JP KSE min ( JU KSE,\u2264X\u03c9 ) = JP \u2295 U KSE .\nHence, JP \u2295 U KSE 6= \u2205. (P4)SE If P \u2261SE Q and U \u2261SE V , then\nJP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264X\u03c9 ) = \u22c3 X\u2208JQKSE min ( JV KSE,\u2264X\u03c9 ) = JQ\u2295 V KSE .\nTherefore, P \u2295 U \u2261SE Q\u2295 V . (P5)SE Suppose that Y is an SE-model of (P\u2295U) \u2227\u0307 V . Then Y \u2208 JV KSE and there is some\nSE-model X of P such that Y belongs to min(JU KSE,\u2264X\u03c9 ). Consequently, Y also belongs to min(JU KSE \u2229 JV KSE,\u2264X\u03c9 ), so Y is an SE-model of P \u2295 (U \u2227\u0307 V).\n(P6)SE Assume that P \u2295 U |=SE V and P \u2295 V |=SE U . We will prove by contradiction that P \u2295 U |=SE P \u2295 V . The other half can be proved similarly. So suppose that Y is an SE-model of P \u2295 U but not of P \u2295 V . Then there is some SE-model X of P such that\nY \u2208 min(JU KSE,\u2264X\u03c9 ) . (A15)\nAt the same time, there must be some SE-model Z of V such that Z <X\u03c9 Y . Let Z0 be minimal w.r.t. \u2264X\u03c9 among all such Z. Then by transitivity of <X\u03c9 we obtain that Z0 \u2208 min(JV KSE,\u2264X\u03c9 ) and, consequently, Z0 is an SE-model of P\u2295V . By the assumption we now obtain that Z0 is an SE-model of U . But since Z0 <X\u03c9 Y , this is in conflict with (A15).\n(P7)SE Suppose that P is strongly equivalent to \u2016X\u2016 for some SE-interpretation X and Y is an SE-model of both P \u2295 U and P \u2295 V . We will show that Y is an SE-model of P \u2295 (U \u2228\u0307 V). LetM = JU KSE and N = JV KSE. It follows that\nY \u2208 min(M,\u2264X\u03c9 ) \u222amin(M,\u2264X \u2217 \u03c9 ) and Y \u2208 min(N ,\u2264X\u03c9 ) \u222amin(N ,\u2264X \u2217 \u03c9 ) ,\nso since \u03c9 is organised, Y \u2208 min(M\u222a N ,\u2264X\u03c9 ) \u222a min(M\u222a N ,\u2264X \u2217\n\u03c9 ). Consequently, Y is an SE-model of P \u2295 (U \u2228\u0307 V).\n(P8)SE The following sequence of equations establishes the property: J(P \u2228\u0307 Q)\u2295 U KSE = \u22c3\nX\u2208JP\u2228\u0307QKSE\nmin ( JU KSE,\u2264X\u03c9 ) =\n\u22c3 X\u2208JP KSE min ( JU KSE,\u2264X\u03c9 ) \u222a \u22c3 X\u2208JQKSE min ( JU KSE,\u2264X\u03c9 ) = JP \u2295 U KSE \u222a JQ\u2295 U KSE = J(P \u2295 U) \u2228\u0307 (Q\u2295 U)KSE\nTheorem 21. Let \u2295 be a rule update operator. The following conditions are equivalent:\na) The operator \u2295 satisfies conditions (P1)SE \u2013 (P8)SE. b) The operator \u2295 is characterised by a semi-faithful and organised preorder assignment. c) The operator \u2295 is characterised by a faithful and organised partial order assignment."}, {"heading": "Proof of Theorem 21", "text": "Follows from Propositions 38, 40 and 41."}, {"heading": "Appendix B Proofs: Properties of the Assignment W", "text": "Proposition 42 The assignment W is a preorder assignment."}, {"heading": "Proof", "text": "Recall that the assignment W is defined for all SE-interpretations X = (I, J), Y = (K1, L1), Z = (K2, L2) as follows: Y \u2264XW Z if and only if\n1. (L1 \u00f7 J) \u2286 (L2 \u00f7 J); 2. If (L1 \u00f7 J) = (L2 \u00f7 J), then (K1 \u00f7 I) \\\u2206 \u2286 (K2 \u00f7 I) \\\u2206 where \u2206 = L1 \u00f7 J .\nIn order to show that W is a preorder assignment, we need to prove that given an arbitrary SE-interpretation X = (I, J), \u2264XW is a preorder over X. This holds if and only if \u2264XW is reflexive and transitive. First we show reflexivity. Take some SE-interpretation Y = (K,L). By definition, Y \u2264XW Y holds if and only if\n1. (L\u00f7 J) \u2286 (L\u00f7 J); 2. If (L\u00f7 J) = (L\u00f7 J), then (K \u00f7 I) \\\u2206 \u2286 (K \u00f7 I) \\\u2206 where \u2206 = L\u00f7 J .\nIt is not difficult to check that both conditions hold. To show transitivity, take some SE-interpretations Y1 = (K1, L1), Y2 = (K2, L2), Y3 = (K3, L3) such that Y1 \u2264XW Y2 and Y2 \u2264XW Y3. We need to show that Y1 \u2264XW Y3. According to the definition of \u2264XW we obtain\n1. (L1 \u00f7 J) \u2286 (L2 \u00f7 J); 2. If (L1 \u00f7 J) = (L2 \u00f7 J), then (K1 \u00f7 I) \\\u2206 \u2286 (K2 \u00f7 I) \\\u2206 where \u2206 = L1 \u00f7 J ;\nand also\n1\u2019 (L2 \u00f7 J) \u2286 (L3 \u00f7 J); 2\u2019 If (L2 \u00f7 J) = (L3 \u00f7 J), then (K2 \u00f7 I) \\\u2206 \u2286 (K3 \u00f7 I) \\\u2206 where \u2206 = L2 \u00f7 J .\nWe need to show the following two conditions:\n1\u2217 (L1 \u00f7 J) \u2286 (L3 \u00f7 J); 2\u2217 If (L1 \u00f7 J) = (L3 \u00f7 J), then (K1 \u00f7 I) \\\u2206 \u2286 (K3 \u00f7 I) \\\u2206 where \u2206 = L1 \u00f7 J .\nIt can be seen that 1\u2217 follows from 1. and 1\u2019 by transitivity of the subset relation. To show that 2\u2217 holds as well, suppose that (L1 \u00f7 J) = (L3 \u00f7 J). Then by 1. and 1\u2019 we obtain that (L1 \u00f7 J) = (L2 \u00f7 J) = (L3 \u00f7 J) = \u2206 and so by 2. and 2\u2019 it holds that\n(K1 \u00f7 I) \\\u2206 \u2286 (K2 \u00f7 I) \\\u2206 \u2286 (K3 \u00f7 I) \\\u2206 .\nConsequently, 2\u2217 is also satisfied and the proof is finished.\nLemma 43 Let X = (I, J), Y = (K1, L1), Z = (K2, L2) be SE-interpretations. Then Y <XW Z holds if and only if one of the following conditions is satisfied:\na) (L1 \u00f7 J) ( (L2 \u00f7 J), or b) (L1 \u00f7 J) = (L2 \u00f7 J) and (K1 \u00f7 I) \\\u2206 ( (K2 \u00f7 I) \\\u2206 where \u2206 = L1 \u00f7 J ."}, {"heading": "Proof", "text": "By definition, Y <XW Z holds if and only if Y \u2264XW Z and it is not the case that Z \u2264XW Y . This in turn holds if and only if the following two conditions hold\n1. (L1 \u00f7 J) \u2286 (L2 \u00f7 J); 2. If (L1 \u00f7 J) = (L2 \u00f7 J), then (K1 \u00f7 I) \\\u2206 \u2286 (K2 \u00f7 I) \\\u2206 where \u2206 = L1 \u00f7 J .\nand one of the following conditions also holds:\ni) (L2 \u00f7 J) * (L1 \u00f7 J), or ii) (L2 \u00f7 J) = (L1 \u00f7 J) and (K2 \u00f7 I) \\\u2206 * (K1 \u00f7 I) \\\u2206 where \u2206 = L2 \u00f7 J .\nIt is not difficult to verify that conditions 1., 2. and i) are together equivalent to a) and that conditions 1., 2. and ii) are together equivalent to b). This concludes our proof.\nProposition 44 The assignment W is well-defined."}, {"heading": "Proof", "text": "By definition we need to show that there is a rule update operator \u2295 such that for all programs P, U ,\nJP \u2295 U KSE = \u22c3\nX\u2208JP KSE\nmin ( JU KSE,\u2264XW ) .\nThis holds if and only if for every well-defined set of SE-interpretations M and every SE-interpretation X , the set of SE-interpretations\nmin ( M,\u2264XW ) \u222amin ( M,\u2264X \u2217 W ) (B1)\nis well-defined. Suppose that Y belongs to (B1). We need to demonstrate that Y \u2217 also belongs to (B1). We consider two cases:\n(a) Suppose that Y \u2208 min(M,\u2264XW ). If Y \u2217 belongs to min(M,\u2264X \u2217\nW ), then we are finished. On the other hand, if Y \u2217 does not belong to min(M,\u2264X\u2217W ), then there must be some Z \u2208 M such that Z <X\u2217W Y \u2217. Let Y = (K1, L1), Z = (K2, L2) and X = (I, J). By Lemma 43 we know that Z <X \u2217\nW Y \u2217 holds if and only if one of the\nfollowing conditions is satisfied:\na) (L2 \u00f7 J) ( (L1 \u00f7 J), or b) (L2 \u00f7 J) = (L1 \u00f7 J) and (K2 \u00f7 J) \\\u2206 ( (L1 \u00f7 J) \\\u2206 where \u2206 = L2 \u00f7 J .\nIf a) is satisfied, then Lemma 43 implies that Z <XW Y which is in conflict with the assumption that Y \u2208 min(M,\u2264XW ). So b) must hold. But in that case we infer that (K2 \u00f7 J) \\\u2206 is a proper subset of\n(L1 \u00f7 J) \\\u2206 = (L1 \u00f7 J) \\ (L1 \u00f7 J) = \u2205 ,\nwhich is impossible. (b) Suppose that Y \u2208 min(M,\u2264X\u2217W ) and let X = (I, J), Y = (K,L). First we show that\nY \u2217 \u2264X\u2217W Y holds \u2013 for this, the following conditions need to be satisfied:\n1. (L\u00f7 J) \u2286 (L\u00f7 J); 2. If (L\u00f7 J) = (L\u00f7 J), then (L\u00f7 J) \\\u2206 \u2286 (K \u00f7 J) \\\u2206 where \u2206 = L\u00f7 J .\nIt is not difficult to verify that both conditions hold. Thus, since Y \u2217 \u2264X\u2217W Y , there can be no Z \u2208 M with Z <X \u2217 W Y \u2217 because by transitivity we would obtain Z <X \u2217\nW Y which would be in conflict with the assumption that Y \u2208 min(M,\u2264X\u2217W ). So Y \u2217 \u2208 min(M,\u2264X \u2217 W ) and our proof is finished.\nProposition 45 The assignment W is faithful."}, {"heading": "Proof", "text": "Take some SE-interpretations X = (I, J), Y = (K,L) such that Y 6= X . We need to show thatX <XW Y . By Lemma 43 this holds if and only if one of the following conditions is satisfied:\na) (J \u00f7 J) ( (L\u00f7 J), or b) (J \u00f7 J) = (L\u00f7 J) and (I \u00f7 I) \\\u2206 ( (K \u00f7 I) \\\u2206 where \u2206 = J \u00f7 J .\nWe consider two cases:\ni) If L\u00f7 J = \u2205, then L = J and since Y 6= X , we conclude that K 6= I . Consequently, the second condition is satisfied because I \u00f7 I = J \u00f7J = \u2205 and K \u00f7 I is non-empty.\nii) If L\u00f7 J 6= \u2205, then a) holds since J \u00f7 J = \u2205.\nProposition 46 The assignment W is organised."}, {"heading": "Proof", "text": "Recall that by definition W is organised if for all SE-interpretations X , Y and all welldefined sets of SE-interpretationsM,N the following condition is satisfied:\nIf Y \u2208 min(M,\u2264XW ) \u222amin(M,\u2264X \u2217 W ) and Y \u2208 min(N ,\u2264XW ) \u222amin(N ,\u2264X \u2217 W ), then Y \u2208 min(M\u222aN ,\u2264XW ) \u222amin(M\u222aN ,\u2264X \u2217 W ).\nSuppose that Y /\u2208 min(M\u222aN ,\u2264XW )\u222amin(M\u222aN ,\u2264X \u2217\nW ). We need to show that at least one of the following holds:\ni) Y /\u2208 min(M,\u2264XW ) \u222amin(M,\u2264X \u2217\nW ); ii) Y /\u2208 min(N ,\u2264XW ) \u222amin(N ,\u2264X \u2217 W ).\nIf Y /\u2208M, then i) is trivially satisfied. Similarly, if Y /\u2208 N , then ii) is trivially satisfied. So we can assume that Y \u2208M\u2229N . It follows from the assumption that there must be some Z1, Z2 \u2208 M \u222a N such that Z1 <XW Y and Z2 <X \u2217\nW Y . If Z1 and Z2 both belong toM, then i) is satisfied; if they both belong to N , then ii) is satisfied. So let\u2019s assume, without loss of generality, that Z1 \u2208 M and Z2 \u2208 N . Furthermore, let X = (I, J), Y = (K,L), Z1 = (K1, L1) and Z2 = (K2, L2). It follows from Z2 <X \u2217\nW Y and Lemma 43 that we need to consider two cases:\na) If (L2 \u00f7 J) ( (L\u00f7 J), then by Lemma 43 we also have Z2 <XW Y and, consequently, ii) is satisfied. b) If (L2 \u00f7 J) = (L\u00f7 J) and (K2 \u00f7 J) \\\u2206 ( (K \u00f7 J) \\\u2206 where \u2206 = L2 \u00f7 J , then it follows that (K \u00f7 J) \\\u2206 6= \u2205 and by using \u2206 = L2 \u00f7 J = L\u00f7 J we obtain\n(K \u00f7 J) \\ (L\u00f7 J) 6= \u2205 . (B2)\nFurthermore, from Z1 <XW Y we know that one of the following cases occurs:\na\u2019) (L1 \u00f7 J) ( (L\u00f7 J), or b\u2019) (L1 \u00f7 J) = (L\u00f7 J) and (K1 \u00f7 I) \\\u2206 ( (K \u00f7 I) \\\u2206, where \u2206 = L1 \u00f7 J .\nWe will show that Z\u22171 < X\u2217\nW Y . By Lemma 43 this holds if and only if one of the following conditions is satisfied:\na\u2217) (L1 \u00f7 J) ( (L\u00f7 J), or b\u2217) (L1 \u00f7 J) = (L\u00f7 J) and (L1 \u00f7 J) \\\u2206 ( (K \u00f7 J) \\\u2206, where \u2206 = L1 \u00f7 J .\nWe see that a\u2019) implies a\u2217) and b\u2019) together with (B2) implies b\u2217). Also, since M is well-defined, we have Z\u22171 \u2208M, so i) is satisfied.\nProposition 23. The assignment W is a well-defined, faithful and organised preorder assignment."}, {"heading": "Proof of Proposition 23", "text": "Follows by Propositions 42, 44, 45 and 46."}, {"heading": "Appendix C Proofs: Computational Complexity of Operators Characterised by W", "text": "Definition 47 (Truth value assigned by SE-interpretation) Let X be an SE-interpretation and p an atom. We define the truth value assigned by X to p as follows:\nX(p) =  T if p \u2208 I ; U if p \u2208 J \\ I ; F if p \u2208 A \\ J .\nDefinition 48 (Set of relevant atoms) Let \u03c6 be a propositional formula. We inductively define the set of atoms relevant to \u03c6, denoted by at(\u03c6), as follows:\n\u2022 If \u03c6 is > or \u22a5, then at(\u03c6) = \u2205; \u2022 If \u03c6 is an atom p, then at(\u03c6) = { p }; \u2022 If \u03c6 is of the form \u00ac\u03c8, then at(\u03c6) = at(\u03c8); \u2022 If \u03c6 is of the form \u03c81\u2227\u03c82, \u03c81\u2228\u03c82, \u03c81 \u2283 \u03c82 or \u03c81 \u2261 \u03c82, then at(\u03c6) = at(\u03c81)\u222aat(\u03c82).\nFor a logic program P, at(P) = at(\u03ba(P)).\nLemma 49 Let P, U be programs and \u2295 a rule update operator characterised by W. If Z belongs to min(JU KSE,\u2264XW ) for some X \u2208 JP KSE, then X(p) = Z(p) for all p \u2208 A \\ at(U)."}, {"heading": "Proof", "text": "We prove by contradiction. Suppose that our assumptions are satisfied and X(p) 6= Z(p) for some p \u2208 A \\ at(U). Let the SE-interpretation Y be defined as follows:\nY (q) =\n{ X(q) q = p ;\nZ(q) q 6= p .\nFirst note that since Z is an SE-model of U and Y differs from Z only in the truth value assigned to p, where p /\u2208 at(U), it follows that Y is also an SE-model of U .\nPut X = (I, J), Y = (K1, L1) and Z = (K2, L2). By assumption, X(p) 6= Z(p), so, by the definition of Y , Y (p) 6= Z(p). Thus, one of the following cases occurs:\na) If L1 \u00f7 L2 = { p }, then we immediately obtain that (L1 \u00f7 J) \u00f7 (L2 \u00f7 J) = { p }. Since Y (p) = X(p), we conclude that p /\u2208 L1 \u00f7 J and it follows that\n(L1 \u00f7 J) \\ (L2 \u00f7 J) = \u2205 and (L2 \u00f7 J) \\ (L1 \u00f7 J) = { p } .\nConsequently, L1 \u00f7 J ( L2 \u00f7 J , so Y <XW Z, contrary to the assumption that Z belongs to min(JU KSE,\u2264XW ). b) If K1 \u00f7K2 = { p }, then we obtain that (K1 \u00f7 I)\u00f7 (K2 \u00f7 I) = { p }. Since Y (p) = X(p), we conclude that p /\u2208 K1 \u00f7 I and it follows that\n(K1 \u00f7 I) \\ (K2 \u00f7 I) = \u2205 and (K2 \u00f7 I) \\ (K1 \u00f7 I) = { p } .\nFurthermore, assuming that the previous case does not occur, it follows that L1 = L2, so for \u2206 = L1\u00f7J = L2\u00f7J it holds that p /\u2208 \u2206 because X(p) = Z(p). Consequently, (K1 \u00f7 I) \\\u2206 ( (K2 \u00f7 I) \\\u2206, so Y <XW Z, contrary to the assumption that Z belongs to min(JU KSE,\u2264XW ).\nDefinition 50 (Truth value substitution) Let X = (I, J) be an SE-interpretation and p an atom. We define the SE-interpretations X [p:=T], X [p:=U] and X [p:=F] as follows:\nX [p:=T] = (I \u222a { p } , J \u222a { p }) ,\nX [p:=U] = (I \\ { p } , J \u222a { p }) ,\nX [p:=F] = (I \\ { p } , J \\ { p }) .\nLemma 51 Let X , Y , Z be SE-interpretations, p an atom such that X(p) = Z(p) and V a truth value. Then,\nY <XW Z implies Y [p:=V] <X\n[p:=V]\nW Z [p:=V] ."}, {"heading": "Proof", "text": "Put X = (I, J), Y = (K1, L1) and Z = (K2, L2). The assumption that X(p) = Z(p) implies that\np /\u2208 L2 \u00f7 J and p /\u2208 K2 \u00f7 I . (C1)\nFurthermore, if Y <XW Z, then, by Lemma 43, one of the following two cases occurs:\na) If (L1 \u00f7 J) ( (L2 \u00f7 J), then it follows from (C1) that p /\u2208 L1 \u00f7 J and we obtain the following:\n(L1 \u222a { p })\u00f7 (J \u222a { p }) = L1 \u00f7 J ( L2 \u00f7 J = (L2 \u222a { p })\u00f7 (J \u222a { p }) , (C2) (L1 \\ { p })\u00f7 (J \\ { p }) = L1 \u00f7 J ( L2 \u00f7 J = (L2 \\ { p })\u00f7 (J \\ { p }) . (C3)\nFinally, we need to consider two cases depending on V:\n(i) If V = T or V = U, then the second components of the SE-interpretations X [p:=V], Y [p:=V] and Z [p:=V] are J \u222a{ p }, L1\u222a{ p } and L2\u222a{ p }, respectively. Hence, the desired conclusion follows from (C2) by Lemma 43.\n(ii) If V = F, then the second components of the SE-interpretations X [p:=V], Y [p:=V]\nand Z [p:=V] are J \\{ p }, L1 \\{ p } and L2 \\{ p }, respectively. Hence, the desired conclusion follows from (C3) by Lemma 43.\nb) If (L1 \u00f7 J) = (L2 \u00f7 J) and (K1 \u00f7 I) \\\u2206 ( (K2 \u00f7 I) \\\u2206 where \u2206 = L1 \u00f7 J , then L1 = L2 and it follows from (C1) that p /\u2208 \u2206 as well as p /\u2208 K1 \u00f7 I , so we obtain the following:\n(L1 \u222a { p })\u00f7 (J \u222a { p }) = (L2 \u222a { p })\u00f7 (J \u222a { p }) = \u2206 , (C4)\n(L1 \\ { p })\u00f7 (J \\ { p }) = (L2 \\ { p })\u00f7 (J \\ { p }) = \u2206 , (C5)\n[(K1 \u222a { p })\u00f7 (I \u222a { p })] \\\u2206 = (K1 \u00f7 I) \\\u2206 ( (K2 \u00f7 I) \\\u2206 = [(K2 \u222a { p })\u00f7 (I \u222a { p })] \\\u2206 ,\n(C6)\n[(K1 \\ { p })\u00f7 (I \\ { p })] \\\u2206 = (K1 \u00f7 I) \\\u2206 ( (K2 \u00f7 I) \\\u2206 = [(K2 \\ { p })\u00f7 (I \\ { p })] \\\u2206 .\n(C7)\nFinally, we need to use Lemma 43, considering three cases depending on V:\n(i) If V = T, then the desired conclusion follows from (C4) and (C6). (ii) If V = U, then the desired conclusion follows from (C4) and (C7).\n(iii) If V = F, then the desired conclusion follows from (C5) and (C7).\nLemma 52 Let P, U be programs, p an atom with p /\u2208 at(P) \u222a at(U), \u2295 a rule update operator characterised by W and Z, Z \u2032 be SE-interpretations such that Z = Z \u2032[p:=V] for some truth value V. Then,\nZ \u2208 JP \u2295 U KSE if and only if Z \u2032 \u2208 JP \u2295 U KSE ."}, {"heading": "Proof", "text": "We prove the direct implication, the converse one follows by the symmetry of the claim.\nSuppose that Z \u2208 JP\u2295U KSE but Z \u2032 /\u2208 JP\u2295U KSE. Then there is some SE-interpretation X \u2208 JP KSE such that Z belongs to min(JU KSE,\u2264XW ). It follows from Lemma 49 that\nX(p) = Z(p) = V .\nPut Z \u2032(p) = V\u2032 and let X \u2032 = X [p:=V \u2032]. Since X \u2032 differs from X only in the truth value\nassigned to p and p /\u2208 at(P), it follows that X \u2032 \u2208 JP KSE. Thus, there exists some SE-interpretation Y \u2032 such that Y \u2032 <X \u2032\nW Z \u2032 and by Lemma 51 we conclude that\nY \u2032[p:=V] <X \u2032[p:=V] W Z \u2032[p:=V] .\nIt remains to observe that X \u2032[p:=V] = X and Z \u2032[p:=V] = Z, so for Y = Y \u2032[p:=V] we have\nY <XW Z .\nSince Y differs from Y \u2032 only in the truth value assigned to p and p /\u2208 at(U), it follows that Y \u2208 JU KSE \u2013 a conflict with the assumption that Z belongs to min(JU KSE,\u2264XW ).\nCorollary 53 Let P, U be programs, \u2295 a rule update operator characterised by W and Z, Z \u2032 be SE-interpretations such that Z(p) = Z \u2032(p) for all p \u2208 at(P) \u222a at(U). Then,\nZ \u2208 JP \u2295 U KSE if and only if Z \u2032 \u2208 JP \u2295 U KSE ."}, {"heading": "Proof", "text": "Suppose that\nA \\ (at(P) \u222a at(U)) = { p1, p2, . . . , pn } and construct a sequence of SE-interpretations Z0, Z1, . . . , Zn as follows: Z0 = Z and Zi+1 = Z [pi:=Z \u2032(pi)]\ni for all i with 0 \u2264 i < n. Clearly, Zn = Z \u2032 and Lemma 52 can be used n times, for each pair (Zi, Zi+1), to infer the desired result.\nLemma 54 Let P be a set of facts, U a program such that at(U) \u2286 at(P), \u2295 a rule update operator characterised by W and Z an SE-interpretation from JP \u2295 U KSE. Then for every atom p with (p.) \u2208 P it holds that Z(p) 6= U."}, {"heading": "Proof", "text": "Suppose that Z belongs to JP \u2295 U KSE, put Z = (K,L) and let\nY = (K \u2229 at(P), L \u2229 at(P)) .\nIt follows by Corollary 53 that Y belongs to JP \u2295 U KSE. Thus, there exists some SE-interpretation X \u2208 JP KSE such that Y belongs to min(JU KSE,\u2264XW ). Also, using Lemma 49 we conclude that X assigns truth values as follows:\nX(q) =  T (q.) \u2208 P ; F (\u223cq.) \u2208 P ; F q \u2208 A \\ at(P) .\nIn other words, X is of the form (J, J) where J = { q \u2208 A | (q.) \u2208 P }. Furthermore, since Y belongs to JU KSE, Y \u2217 = (L \u2229 at(P), L \u2229 at(P)) also belongs there.\nWe proceed by contradiction: Suppose that Z(p) = U for some atom p with (p.) \u2208 P.\nThen p \u2208 L \\K, p \u2208 at(P) and p \u2208 J and we reach a conflict because Y \u2217 <XW Y follows by Lemma 43 from the fact that\n[(L \u2229 at(P))\u00f7 J ] \\ [(L \u2229 at(P))\u00f7 J ] = \u2205 ( { p } \u2286 [(K \u2229 at(P))\u00f7 J ] \\ [(L \u2229 at(P))\u00f7 J ] .\nLemma 55 Let P, U be programs, \u2295 a rule update operator characterised by W, a belief update operator characterised by W and L an interpretation. Then,\n(L,L) \u2208 JP \u2295 U KSE if and only if L \u2208 J\u03ba(P) \u03ba(U)K ."}, {"heading": "Proof", "text": "Suppose that (L,L) \u2208 JP \u2295 U KSE. Then (L,L) belongs to min(JU KSE,\u2264XW ) for some X = (I, J) \u2208 JP KSE. Since JP KSE is a well-defined set of SE-interpretations, we conclude that (J, J) \u2208 JP KSE and, consequently, J |= P. We will prove that L \u2208 min(J\u03ba(U)K,\u2264JW). Suppose that this is not the case, i.e. there is some L\u2032 \u2208 J\u03ba(U)K such that L\u2032 <JW L. In other words, L\u2032 \u00f7 J ( L \u00f7 J . It follows that (L\u2032, L\u2032) is an SE-model of U and by Lemma 43 we conclude that (L\u2032, L\u2032) <XW (L,L), contrary to the assumption that (L,L) belongs to min(JU KSE,\u2264XW ).\nTo prove the converse implication, assume that L \u2208 J\u03ba(P) \u03ba(U)K. Then there is some interpretation J with J |= P such that L \u2208 min(J\u03ba(U)K,\u2264JW). It follows that X = (J, J) \u2208 JP KSE and Z = (L,L) \u2208 JU KSE. Our goal is to prove that Z \u2208 min(JU KSE,\u2264XW ). Suppose that this is not the case, i.e. there is some Z \u2032 = (K \u2032, L\u2032) \u2208 JU KSE such that Z \u2032 <XW Z. Note that since JU KSE is a well-defined set of SE-interpretations, it follows that (L\u2032, L\u2032) \u2208 JU KSE and thus L\u2032 |= U . By Lemma 43, one of the following conditions is then satisfied:\na) If L\u2032\u00f7 J ( L\u00f7 J , then we obtain L\u2032 <JW L, contrary to the assumption that L belongs to min(J\u03ba(U)K,\u2264JW). b) The case when L\u2032 \u00f7 J = L\u00f7 J and (K \u2032 \u00f7 J) \\\u2206 ( (L\u00f7 J) \\\u2206, where \u2206 = L\u00f7 J , is impossible because the set (L\u00f7 J) \\\u2206 is empty.\nProposition 56 Let P be a set of facts, Q and U be programs such that Q \u2286 P and at(U) \u2286 at(P), \u2295 a rule update operator characterised by W and a belief update operator characterised by W. Then,\nP \u2295 U |=SE Q if and only if \u03ba(P) \u03ba(U) |= \u03ba(Q) ."}, {"heading": "Proof", "text": "First suppose that P\u2295U |=SE Q and take some L \u2208 J\u03ba(P) \u03ba(U)K. We need to prove that L |= Q. It follows from Lemma 55 that (L,L) \u2208 JP \u2295 U KSE and our assumption implies that (L,L) |= Q. This means that L |= Q, so we reached the desired conclusion.\nFor the converse implication, suppose that \u03ba(P) \u03ba(U) |= \u03ba(Q) and take some (K,L) \u2208 JP \u2295 U KSE. Our goal is to prove that (K,L) |= Q. Since the set of SE-interpretations JP \u2295 U KSE is well-defined, we obtain that (L,L) \u2208 JP \u2295 U KSE and by Lemma 55 it\nfollows that L \u2208 J\u03ba(P) \u03ba(U)K. By our assumption we infer that L |= Q. Thus, for every positive fact (p.) from Q it holds that p \u2208 L and due to Lemma 54 also p \u2208 K. Therefore, (K,L) |= (p.). Similarly, for every negative fact (\u223cp.) from Q it holds that p /\u2208 L and, hence, (K,L) |= (\u223cp.). Consequently, (K,L) |= Q as desired.\nTheorem 25 (Computational complexity of rule updates characterised by W). Let \u2295 be a rule update operator characterised by W. Deciding whether P \u2295 U |=SE Q for programs P, U , Q is \u03a0P2 -complete. Hardness holds even if P is a set of positive facts, U is a non-disjunctive program and Q contains a single fact from P."}, {"heading": "Proof of Theorem 25", "text": "Hardness can be shown by reducing the problem of query answering for Winslett\u2019s belief update semantics to the problem of query answering for \u2295. To do this, we rely on some specifics of the proof of Theorem 6 as it is presented in (Eiter and Gottlob 1992). More specifically, Lemma 6.2 (c.f. page 250 of (Eiter and Gottlob 1992)) shows \u03a0P2 -hardness of Winslett\u2019s belief update semantics by taking an instance\nF = \u2200x1, . . . , xm\u2203y1, . . . , yn : \u03bd\nof QBF2,\u2200 and constructing propositional formulae \u03c6, \u00b5 and \u03c8 such that\nF is valid if and only if \u03c6 \u00b5 |= \u03c8 . (C8)\nIn the following we reproduce the definition of \u03c6, \u00b5 and \u03c8 in order to pinpoint their syntactic structure. Then we show how they can be encoded as logic programs P, U and Q such that\n\u03c6 \u00b5 |= \u03c8 if and only if P \u2295 U |=SE Q . (C9)\nHowever, we omit the proof of the equivalence (C8) and refer the interested reader to (Eiter and Gottlob 1992) for further details.\nFormulae \u03c6, \u00b5 and \u03c8 can be defined as follows:\n\u03c6 = x1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 xm \u2227 z1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 zm \u2227 y1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 yn \u2227 r , \u00b5 = (x1 \u2261 \u00acz1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 (xm \u2261 \u00aczm) \u2227 (r \u2283 \u03bd) \u2227 ((y1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 yn) \u2283 r) , \u03c8 = r ,\nwhere z1, . . . , zm and r are fresh propositional variables. Moreover, we can assume without loss of generality that \u03bd is in conjunctive normal form, i.e.\n\u03bd = s\u2227 i=1 (pi,1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 pi,ti \u2228 \u00acqi,1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00acqi,ui)\nwhere pi,j and qi,k belong to {x1, . . . , xm, y1, . . . , yn } for all i, j, k. We construct pro-\ngrams P, U and Q as follows:\nP = { (xi.) | 1 \u2264 i \u2264 m } \u222a { (zi.) | 1 \u2264 i \u2264 m } \u222a { (yi.) | 1 \u2264 i \u2264 n } \u222a { (r.) } , U = { (xi \u2190 \u223czi.), (\u223czi \u2190 xi.) | 1 \u2264 i \u2264 m }\n\u222a { (\u22a5 \u2190 \u223cpi,1, . . . ,\u223cpi,ti , qi,1, . . . , qi,ui , r.) | 1 \u2264 i \u2264 s } \u222a { (r \u2190 yi.) | 1 \u2264 i \u2264 n } ,\nQ = { (r.) } .\nIt is not difficult to verify that \u03ba(P) \u2261 \u03c6, \u03ba(U) \u2261 \u00b5 and \u03ba(Q) \u2261 \u03c8, so it follows from postulate (B4) and Proposition 56 that (C9) is satisfied. Together with (C8) this implies that query answering for rule update operators characterised by W is \u03a0P2 -hard.\nTo verify membership to \u03a0P2 , consider the following non-deterministic polynomial algorithm with an NP oracle, analogous to the one for Winslett\u2019s belief update semantics (c.f. proof of Theorem 6.4 on page 252 in (Eiter and Gottlob 1992)): To prove that P \u2295 U 6|=SE Q, consider only atoms from at(P) \u222a at(U) \u222a at(Q) (this can be done due to Corollary 53), guess some SE-interpretations X and Y , check in polynomial time that X \u2208 JP KSE, Y \u2208 JU KSE and Y /\u2208 JQKSE and invoke the NP oracle to check that there is no Z \u2208 JU KSE such that Z <XW Y .\nLemma 57 Let U be a definite program. Then for all interpretations I , J it holds that,\n(I, J) \u2208 JU KSE if and only if I \u2286 J \u2227 I |= \u03ba(U) \u2227 J |= \u03ba(U) ."}, {"heading": "Proof", "text": "Follows from the fact that since U is definite, UK = U for any interpretation K.\nTheorem 26 (Computational complexity of definite rule updates characterised by W). Let \u2295 be a rule update operator characterised by W. Deciding whether P \u2295 U |=SE Q for definite programs P, U , Q is co-NP-complete. Hardness holds even if P is a set of facts and Q contains a single fact from P."}, {"heading": "Proof of Theorem 26", "text": "Hardness follows by reducing the co-NP-complete problem of query answering for Horn formulae under Winslett\u2019s belief update semantics. More specifically, Theorem 7 shows that deciding whether \u03c6 \u00b5 |= \u03c8, where is a belief update operator characterised by W, is co-NP-hard even when \u03c6 is a conjunction of objective literals, \u00b5 is a Horn formula and \u03c8 is one of the literals in \u03c6. It is straightforward to construct a set of facts P, a definite program U and a program Q containing a single fact from P such that \u03ba(P) \u2261 \u03c6, \u03ba(U) \u2261 \u00b5 and \u03ba(Q) \u2261 \u03c8. Finally, it follows from postulate (B4) and Proposition 56 that\nP \u2295 U |=SE Q if and only if \u03c6\u2295 \u00b5 |= \u03c8 ,\nwhich concludes the proof of co-NP-hardness of query answering for \u2295. To verify membership to co-NP, consider the following non-deterministic polynomial algorithm, analogous to the one for Winslett\u2019s belief update semantics for Horn formulae (c.f. proof of Theorem 7.2 on page 259 in (Eiter and Gottlob 1992)): To prove that P \u2295\nU 6|=SE Q, consider only atoms from A\u2032 = at(P) \u222a at(U) \u222a at(Q) (this can be done due to Corollary 53), guess some SE-interpretations X = (I, J) and Y = (K,L) and check in polynomial time that X \u2208 JP KSE, Y \u2208 JU KSE and Y /\u2208 JQKSE. It remains to check that there is no SE-interpretation Z \u2208 JU KSE such that Z <XW Y . This can be performed in polynomial time by using Lemma 57 as follows: Put \u2206 = L \u00f7 J and \u2206\u2032 = (K \u00f7 I) \\\u2206 and let for every atom p,\nt(p) = { p J |= p ; \u00acp J 6|= p ;\ns(p) = { p I |= p ; \u00acp I 6|= p .\nIt follows from Lemma 57 and from the definition of \u2264XW that it suffices to verify that for every p \u2208 \u2206 and every q \u2208 \u2206\u2032, both of the Horn formulae\n\u03ba(U) \u2227 t(p) \u2227 \u2227\nr\u2208A\u2032\\\u2206\nt(r) and \u03ba(U) \u2227 s(q) \u2227 \u2227\nr\u2208A\u2032\\\u2206\u2032 s(r)\nare not satisfiable."}, {"heading": "ALFERES, J. J., LEITE, J. A., PEREIRA, L. M., PRZYMUSINSKA, H., AND PRZYMUSINSKI, T. C.", "text": "2000. Dynamic updates of non-monotonic knowledge bases. The Journal of Logic Programming 45, 1-3 (September/October), 43\u201370. 2, 9, 14, 16\nALFERES, J. J. AND PEREIRA, L. M. 1996. Update-programs can update programs. In NonMonotonic Extensions of Logic Programming (NMELP \u201996), Selected Papers, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 110\u2013131. 2\nAPT, K. R., BLAIR, H. A., AND WALKER, A. 1988. Towards a theory of declarative knowledge. In Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann, 89\u2013148. 14\nBARAL, C. 2003. Knowledge Representation, Reasoning, and Declarative Problem Solving. Cambridge University Press. 1\nCABALAR, P. AND FERRARIS, P. 2007. Propositional theories are strongly equivalent to logic programs. Theory and Practice of Logic Programming (TPLP) 7, 6, 745\u2013759. 10\nDELGRANDE, J. P. 2010. A Program-Level Approach to Revising Logic Programs under the Answer Set Semantics. Theory and Practice of Logic Programming, 26th Int\u2019l. Conference on Logic Programming (ICLP\u201910) Special Issue 10, 4-6 (July), 565\u2013580. 14\nDELGRANDE, J. P., SCHAUB, T., AND TOMPITS, H. 2007. A preference-based framework for updating logic programs. In Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2007), C. Baral, G. Brewka, and J. S. Schlipf, Eds. Lecture Notes in Computer Science, vol. 4483. Springer, Tempe, AZ, USA, 71\u201383. 2, 9, 14\nDELGRANDE, J. P., SCHAUB, T., TOMPITS, H., AND WOLTRAN, S. 2008. Belief revision of logic programs under answer set semantics. In Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR 2008), G. Brewka and J. Lang, Eds. AAAI Press, Sydney, Australia, 411\u2013421. 2, 3, 7, 8, 9, 10, 12, 15, 17 DIX, J. 1995a. A classification theory of semantics of normal logic programs: I. Strong properties. Fundamenta Informaticae 22, 3, 227\u2013255. 14 DIX, J. 1995b. A classification theory of semantics of normal logic programs: II. Weak properties. Fundamenta Informaticae 22, 3, 257\u2013288. 14 EITER, T., FINK, M., SABBATINI, G., AND TOMPITS, H. 2002. On properties of update sequences based on causal rejection. Theory and Practice of Logic Programming (TPLP) 2, 6, 721\u2013777. 2, 9, 14, 17 EITER, T. AND GOTTLOB, G. 1992. On the complexity of propositional knowledge base revision, updates, and counterfactuals. In Proceedings of the 11th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS 1992). ACM Press, San Diego, California, USA, 261\u2013273. 6, 34, 35 GELFOND, M. AND LIFSCHITZ, V. 1988. The stable model semantics for logic programming. In Proceedings of the 5th International Conference and Symposium on Logic Programming (ICLP/SLP 1988), R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Seattle, Washington, 1070\u2013 1080. 1 HERZIG, A. AND RIFI, O. 1999. Propositional belief base update and minimal change. Artificial Intelligence 115, 1, 107\u2013138. 13, 16 HEYTING, A. 1930. Die formalen Regeln der intuitionistischen Logik. Sitzungsberichte der Preussischen Akademie der Wissenschaften, 42\u201356. Reprint in Logik-Texte: Kommentierte Auswahl zur Geschichte der Modernen Logik, Akademie-Verlag, 1986. 7, 10 ILIC, M., LEITE, J., AND SLOTA, M. 2008. Explicit dynamic user profiles for a collaborative filtering recommender system. In Proceedings of the 11th Ibero-American Conference on Artificial Intelligence (IBERAMIA\u201908), H. Geffner, R. Prada, I. M. Alexandre, and N. David, Eds. Vol. LNAI 5290. Springer-Verlag, 352\u2013361. 2 KATSUNO, H. AND MENDELZON, A. O. 1991. On the difference between updating a knowledge base and revising it. In Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning (KR\u201991), J. F. Allen, R. Fikes, and E. Sandewall, Eds. Morgan Kaufmann Publishers, Cambridge, MA, USA, 387\u2013394. 2, 4, 5 KATSUNO, H. AND MENDELZON, A. O. 1992. Propositional knowledge base revision and minimal change. Artificial Intelligence 52, 3, 263\u2013294. 15 KELLER, A. M. AND WINSLETT, M. 1985. On the use of an extended relational model to handle changing incomplete information. IEEE Transactions on Software Engineering 11, 7, 620\u2013633. 2, 4, 5, 12 KRU\u0308MPELMANN, P. AND KERN-ISBERNER, G. 2010. On belief dynamics of dependency relations for extended logic programs. In Proceedings of the 13th International Workshop on NonMonotonic Reasoning. Toronto, Canada. 2 LEITE, J. A. 2003. Evolving Knowledge Bases. Frontiers of Artificial Intelligence and Applications, xviii + 307 p. Hardcover, vol. 81. IOS Press. 2 LEITE, J. A. AND PEREIRA, L. M. 1998. Generalizing updates: From models to programs. In Proceedings of the 3rd International Workshop on Logic Programming and Knowledge Representation (LPKR \u201997), October 17, 1997, Port Jefferson, New York, USA, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1471. Springer, 224\u2013246. 2, 9, 14, 16 LIFSCHITZ, V., PEARCE, D., AND VALVERDE, A. 2001. Strongly equivalent logic programs. ACM Transactions on Computational Logic (TOCL) 2, 4, 526\u2013541. 2, 8 \u0141UKASIEWICZ, J. 1941. Die Logik und das Grundlagenproblem. In Les Entretiens de Zu\u0308rich sue les Fondements et la me\u0301thode des sciences mathe\u0301matiques 1938. Zu\u0308rich, 82\u2013100. 7, 10\nMEYER, A. R. AND STOCKMEYER, L. J. 1972. The equivalence problem for regular expressions with squaring requires exponential space. In Proceedings of the 13th Annual Symposium on Switching and Automata Theory (SWAT) (October 25-27). IEEE Computer Society, College Park, Maryland, USA, 125\u2013129. 6\nOSORIO, M. AND CUEVAS, V. 2007. Updates in answer set programming: An approach based on basic structural properties. Theory and Practice of Logic Programming 7, 4, 451\u2013479. 2, 16\nPEARCE, D. 1997. A new logical characterisation of stable models and answer sets. In Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming (NMELP \u201996), J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 57\u201370. 7, 10\nSAIAS, J. AND QUARESMA, P. 2004. A methodology to create legal ontologies in a logic programming based web information retrieval system. Artificial Intelligence and Law 12, 4, 397\u2013417. 2\nSAKAMA, C. AND INOUE, K. 2003. An abductive framework for computing knowledge base updates. Theory and Practice of Logic Programming (TPLP) 3, 6, 671\u2013713. 2, 9, 14\nS\u030cEFRA\u0301NEK, J. 2006. Irrelevant updates and nonmonotonic assumptions. In Proceedings of the 10th European Conference on Logics in Artificial Intelligence (JELIA 2006), M. Fisher, W. van der Hoek, B. Konev, and A. Lisitsa, Eds. Lecture Notes in Computer Science, vol. 4160. Springer, Liverpool, UK, 426\u2013438. 2\nS\u030cEFRA\u0301NEK, J. 2011. Static and dynamic semantics: Preliminary report. Mexican International Conference on Artificial Intelligence, 36\u201342. 2, 9\nSISKA, J. 2006. Dynamic logic programming and world state evaluation in computer games. In Proceedings of the 20th Workshop on Logic Programming, M. Fink, H. Tompits, and S. Woltran, Eds. INFSYS Research Report, vol. 1843-06-02. Technische Universita\u0308t Wien, Austria, Vienna, Austria, 64\u201370. 2\nSLOTA, M. AND LEITE, J. 2010. On semantic update operators for answer-set programs. In Proceedings of the 19th European Conference on Artificial Intelligence (ECAI 2010), H. Coelho, R. Studer, and M. Wooldridge, Eds. Frontiers in Artificial Intelligence and Applications, vol. 215. IOS Press, Lisbon, Portugal, 957\u2013962. 1\nSLOTA, M. AND LEITE, J. 2012. Robust equivalence models for semantic updates of answer-set programs. In Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR 2012), G. Brewka, T. Eiter, and S. A. McIlraith, Eds. AAAI Press, Rome, Italy, 158\u2013168. 17\nSLOTA, M., LEITE, J., AND SWIFT, T. 2011. Splitting and updating hybrid knowledge bases. Theory and Practice of Logic Programming, 27th Int\u2019l. Conference on Logic Programming (ICLP\u201911) Special Issue 11, 4-5, 801\u2013819. 2\nSTOCKMEYER, L. J. 1976. The polynomial-time hierarchy. Theoretical Computer Science 3, 1, 1\u201322. 6\nTURNER, H. 2003. Strong equivalence made easy: nested expressions and weight constraints. Theory and Practice of Logic Programming (TPLP) 3, 4-5, 609\u2013622. 2, 7, 8, 17\nWINSLETT, M. 1990. Updating Logical Databases. Cambridge University Press, New York, USA. 2, 3, 5, 12\nZHANG, Y. 2006. Logic program-based updates. ACM Transactions on Computational Logic 7, 3, 421\u2013472. 2, 9, 14\nZHANG, Y. AND FOO, N. Y. 2005. A unified framework for representing logic program updates. In Proceedings of the 20th National Conference on Artificial Intelligence (AAAI 2005), M. M. Veloso and S. Kambhampati, Eds. AAAI Press / The MIT Press, Pittsburgh, Pennsylvania, USA, 707\u2013713. 2, 9"}], "references": [{"title": "On the logic of theory change: Partial meet contraction and revision functions", "author": ["C.E. ALCHOURR\u00d3N", "P. G\u00c4RDENFORS", "D. MAKINSON"], "venue": "Journal of Symbolic Logic 50, 2, 510\u2013530. 2, 15", "citeRegEx": "ALCHOURR\u00d3N et al\\.,? 1985", "shortCiteRegEx": "ALCHOURR\u00d3N et al\\.", "year": 1985}, {"title": "The refined extension principle for semantics of dynamic logic programming", "author": ["J.J. ALFERES", "F. BANTI", "A. BROGI", "J.A. LEITE"], "venue": "Studia Logica 79, 1, 7\u201332. 2, 9, 14, 16, 17", "citeRegEx": "ALFERES et al\\.,? 2005", "shortCiteRegEx": "ALFERES et al\\.", "year": 2005}, {"title": "An evolvable rule-based email agent", "author": ["J.J. ALFERES", "A. BROGI", "J.A. LEITE", "L.M. PEREIRA"], "venue": "Proceedings of the 11th Portuguese Conference Artificial Intelligence (EPIA 2003), F. Moura-Pires and S. Abreu, Eds. Lecture Notes in Computer Science, vol. 2902. Springer, Beja, Portugal, 394\u2013408. 2", "citeRegEx": "ALFERES et al\\.,? 2003", "shortCiteRegEx": "ALFERES et al\\.", "year": 2003}, {"title": "Dynamic updates of non-monotonic knowledge bases", "author": ["J.J. ALFERES", "J.A. LEITE", "L.M. PEREIRA", "H. PRZYMUSINSKA", "T.C. PRZYMUSINSKI"], "venue": "The Journal of Logic Programming 45, 1-3 (September/October), 43\u201370. 2, 9, 14, 16", "citeRegEx": "ALFERES et al\\.,? 2000", "shortCiteRegEx": "ALFERES et al\\.", "year": 2000}, {"title": "Update-programs can update programs", "author": ["J.J. ALFERES", "L.M. PEREIRA"], "venue": "NonMonotonic Extensions of Logic Programming (NMELP \u201996), Selected Papers, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 110\u2013131. 2", "citeRegEx": "ALFERES and PEREIRA,? 1996", "shortCiteRegEx": "ALFERES and PEREIRA", "year": 1996}, {"title": "Towards a theory of declarative knowledge", "author": ["K.R. APT", "H.A. BLAIR", "A. WALKER"], "venue": "Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann, 89\u2013148. 14", "citeRegEx": "APT et al\\.,? 1988", "shortCiteRegEx": "APT et al\\.", "year": 1988}, {"title": "Knowledge Representation, Reasoning, and Declarative Problem Solving", "author": ["C. BARAL"], "venue": "Cambridge University Press. 1", "citeRegEx": "BARAL,? 2003", "shortCiteRegEx": "BARAL", "year": 2003}, {"title": "Propositional theories are strongly equivalent to logic programs", "author": ["P. CABALAR", "P. FERRARIS"], "venue": "Theory and Practice of Logic Programming (TPLP) 7, 6, 745\u2013759. 10", "citeRegEx": "CABALAR and FERRARIS,? 2007", "shortCiteRegEx": "CABALAR and FERRARIS", "year": 2007}, {"title": "A Program-Level Approach to Revising Logic Programs under the Answer Set Semantics", "author": ["J.P. DELGRANDE"], "venue": "Theory and Practice of Logic Programming, 26th Int\u2019l. Conference on Logic Programming (ICLP\u201910) Special Issue 10, 4-6 (July), 565\u2013580. 14", "citeRegEx": "DELGRANDE,? 2010", "shortCiteRegEx": "DELGRANDE", "year": 2010}, {"title": "A preference-based framework for updating logic programs", "author": ["J.P. DELGRANDE", "T. SCHAUB", "H. TOMPITS"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2007), C. Baral, G. Brewka, and J. S. Schlipf, Eds. Lecture Notes in Computer Science, vol. 4483. Springer, Tempe, AZ, USA, 71\u201383. 2, 9, 14", "citeRegEx": "DELGRANDE et al\\.,? 2007", "shortCiteRegEx": "DELGRANDE et al\\.", "year": 2007}, {"title": "Belief revision of logic programs under answer set semantics", "author": ["J.P. DELGRANDE", "T. SCHAUB", "H. TOMPITS", "S. WOLTRAN"], "venue": "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR 2008), G. Brewka and J. Lang, Eds. AAAI Press, Sydney, Australia, 411\u2013421. 2, 3, 7, 8, 9, 10, 12, 15, 17", "citeRegEx": "DELGRANDE et al\\.,? 2008", "shortCiteRegEx": "DELGRANDE et al\\.", "year": 2008}, {"title": "A classification theory of semantics of normal logic programs: I", "author": ["DIX J."], "venue": "Strong properties. Fundamenta Informaticae 22, 3, 227\u2013255. 14", "citeRegEx": "J.,? 1995a", "shortCiteRegEx": "J.", "year": 1995}, {"title": "A classification theory of semantics of normal logic programs: II", "author": ["DIX J."], "venue": "Weak properties. Fundamenta Informaticae 22, 3, 257\u2013288. 14", "citeRegEx": "J.,? 1995b", "shortCiteRegEx": "J.", "year": 1995}, {"title": "On properties of update sequences based on causal rejection", "author": ["T. EITER", "M. FINK", "G. SABBATINI", "H. TOMPITS"], "venue": "Theory and Practice of Logic Programming (TPLP) 2, 6, 721\u2013777. 2, 9, 14, 17", "citeRegEx": "EITER et al\\.,? 2002", "shortCiteRegEx": "EITER et al\\.", "year": 2002}, {"title": "On the complexity of propositional knowledge base revision, updates, and counterfactuals", "author": ["T. EITER", "G. GOTTLOB"], "venue": "Proceedings of the 11th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS 1992). ACM Press, San Diego, California, USA, 261\u2013273. 6, 34, 35", "citeRegEx": "EITER and GOTTLOB,? 1992", "shortCiteRegEx": "EITER and GOTTLOB", "year": 1992}, {"title": "The stable model semantics for logic programming", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Proceedings of the 5th International Conference and Symposium on Logic Programming (ICLP/SLP 1988), R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Seattle, Washington, 1070\u2013 1080. 1", "citeRegEx": "GELFOND and LIFSCHITZ,? 1988", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1988}, {"title": "Propositional belief base update and minimal change", "author": ["A. HERZIG", "O. RIFI"], "venue": "Artificial Intelligence 115, 1, 107\u2013138. 13, 16", "citeRegEx": "HERZIG and RIFI,? 1999", "shortCiteRegEx": "HERZIG and RIFI", "year": 1999}, {"title": "Die formalen Regeln der intuitionistischen Logik", "author": ["A. HEYTING"], "venue": "Sitzungsberichte der Preussischen Akademie der Wissenschaften, 42\u201356. Reprint in Logik-Texte: Kommentierte Auswahl zur Geschichte der Modernen Logik, Akademie-Verlag, 1986. 7, 10", "citeRegEx": "HEYTING,? 1930", "shortCiteRegEx": "HEYTING", "year": 1930}, {"title": "Explicit dynamic user profiles for a collaborative filtering recommender system", "author": ["M. ILIC", "J. LEITE", "M. SLOTA"], "venue": "Proceedings of the 11th Ibero-American Conference on Artificial Intelligence (IBERAMIA\u201908), H. Geffner, R. Prada, I. M. Alexandre, and N. David, Eds. Vol. LNAI 5290. Springer-Verlag, 352\u2013361. 2", "citeRegEx": "ILIC et al\\.,? 2008", "shortCiteRegEx": "ILIC et al\\.", "year": 2008}, {"title": "On the difference between updating a knowledge base and revising it", "author": ["H. KATSUNO", "A.O. MENDELZON"], "venue": "Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning (KR\u201991), J. F. Allen, R. Fikes, and E. Sandewall, Eds. Morgan Kaufmann Publishers, Cambridge, MA, USA, 387\u2013394. 2, 4, 5", "citeRegEx": "KATSUNO and MENDELZON,? 1991", "shortCiteRegEx": "KATSUNO and MENDELZON", "year": 1991}, {"title": "Propositional knowledge base revision and minimal change", "author": ["H. KATSUNO", "A.O. MENDELZON"], "venue": "Artificial Intelligence 52, 3, 263\u2013294. 15", "citeRegEx": "KATSUNO and MENDELZON,? 1992", "shortCiteRegEx": "KATSUNO and MENDELZON", "year": 1992}, {"title": "On the use of an extended relational model to handle changing incomplete information", "author": ["A.M. KELLER", "M. WINSLETT"], "venue": "IEEE Transactions on Software Engineering 11, 7, 620\u2013633. 2, 4, 5, 12", "citeRegEx": "KELLER and WINSLETT,? 1985", "shortCiteRegEx": "KELLER and WINSLETT", "year": 1985}, {"title": "On belief dynamics of dependency relations for extended logic programs", "author": ["P. KR\u00dcMPELMANN", "G. KERN-ISBERNER"], "venue": "Proceedings of the 13th International Workshop on NonMonotonic Reasoning. Toronto, Canada. 2", "citeRegEx": "KR\u00dcMPELMANN and KERN.ISBERNER,? 2010", "shortCiteRegEx": "KR\u00dcMPELMANN and KERN.ISBERNER", "year": 2010}, {"title": "Evolving Knowledge Bases", "author": ["J.A. LEITE"], "venue": "Frontiers of Artificial Intelligence and Applications, xviii + 307 p. Hardcover, vol. 81. IOS Press. 2", "citeRegEx": "LEITE,? 2003", "shortCiteRegEx": "LEITE", "year": 2003}, {"title": "Generalizing updates: From models to programs", "author": ["J.A. LEITE", "L.M. PEREIRA"], "venue": "Proceedings of the 3rd International Workshop on Logic Programming and Knowledge Representation (LPKR \u201997), October 17, 1997, Port Jefferson, New York, USA, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1471. Springer, 224\u2013246. 2, 9, 14, 16", "citeRegEx": "LEITE and PEREIRA,? 1998", "shortCiteRegEx": "LEITE and PEREIRA", "year": 1998}, {"title": "Strongly equivalent logic programs", "author": ["V. LIFSCHITZ", "D. PEARCE", "A. VALVERDE"], "venue": "ACM Transactions on Computational Logic (TOCL) 2, 4, 526\u2013541. 2, 8", "citeRegEx": "LIFSCHITZ et al\\.,? 2001", "shortCiteRegEx": "LIFSCHITZ et al\\.", "year": 2001}, {"title": "Die Logik und das Grundlagenproblem", "author": ["J. \u0141UKASIEWICZ"], "venue": "Les Entretiens de Z\u00fcrich sue les Fondements et la m\u00e9thode des sciences math\u00e9matiques 1938. Z\u00fcrich, 82\u2013100. 7, 10", "citeRegEx": "\u0141UKASIEWICZ,? 1941", "shortCiteRegEx": "\u0141UKASIEWICZ", "year": 1941}, {"title": "The equivalence problem for regular expressions with squaring requires exponential space", "author": ["A.R. MEYER", "L.J. STOCKMEYER"], "venue": "Proceedings of the 13th Annual Symposium on Switching and Automata Theory (SWAT) (October 25-27). IEEE Computer Society, College Park, Maryland, USA, 125\u2013129. 6", "citeRegEx": "MEYER and STOCKMEYER,? 1972", "shortCiteRegEx": "MEYER and STOCKMEYER", "year": 1972}, {"title": "Updates in answer set programming: An approach based on basic structural properties", "author": ["M. OSORIO", "V. CUEVAS"], "venue": "Theory and Practice of Logic Programming 7, 4, 451\u2013479. 2, 16", "citeRegEx": "OSORIO and CUEVAS,? 2007", "shortCiteRegEx": "OSORIO and CUEVAS", "year": 2007}, {"title": "A new logical characterisation of stable models and answer sets", "author": ["D. PEARCE"], "venue": "Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming (NMELP \u201996), J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 57\u201370. 7, 10", "citeRegEx": "PEARCE,? 1997", "shortCiteRegEx": "PEARCE", "year": 1997}, {"title": "A methodology to create legal ontologies in a logic programming based web information retrieval system", "author": ["J. SAIAS", "P. QUARESMA"], "venue": "Artificial Intelligence and Law 12, 4, 397\u2013417. 2", "citeRegEx": "SAIAS and QUARESMA,? 2004", "shortCiteRegEx": "SAIAS and QUARESMA", "year": 2004}, {"title": "An abductive framework for computing knowledge base updates", "author": ["C. SAKAMA", "K. INOUE"], "venue": "Theory and Practice of Logic Programming (TPLP) 3, 6, 671\u2013713. 2, 9, 14", "citeRegEx": "SAKAMA and INOUE,? 2003", "shortCiteRegEx": "SAKAMA and INOUE", "year": 2003}, {"title": "Irrelevant updates and nonmonotonic assumptions", "author": ["J. \u0160EFR\u00c1NEK"], "venue": "Proceedings of the 10th European Conference on Logics in Artificial Intelligence (JELIA 2006), M. Fisher, W. van der Hoek, B. Konev, and A. Lisitsa, Eds. Lecture Notes in Computer Science, vol. 4160. Springer, Liverpool, UK, 426\u2013438. 2", "citeRegEx": "\u0160EFR\u00c1NEK,? 2006", "shortCiteRegEx": "\u0160EFR\u00c1NEK", "year": 2006}, {"title": "Static and dynamic semantics: Preliminary report", "author": ["J. \u0160EFR\u00c1NEK"], "venue": "Mexican International Conference on Artificial Intelligence, 36\u201342. 2, 9", "citeRegEx": "\u0160EFR\u00c1NEK,? 2011", "shortCiteRegEx": "\u0160EFR\u00c1NEK", "year": 2011}, {"title": "Dynamic logic programming and world state evaluation in computer games", "author": ["J. SISKA"], "venue": "Proceedings of the 20th Workshop on Logic Programming, M. Fink, H. Tompits, and S. Woltran, Eds. INFSYS Research Report, vol. 1843-06-02. Technische Universit\u00e4t Wien, Austria, Vienna, Austria, 64\u201370. 2", "citeRegEx": "SISKA,? 2006", "shortCiteRegEx": "SISKA", "year": 2006}, {"title": "On semantic update operators for answer-set programs", "author": ["M. SLOTA", "J. LEITE"], "venue": "Proceedings of the 19th European Conference on Artificial Intelligence (ECAI 2010), H. Coelho, R. Studer, and M. Wooldridge, Eds. Frontiers in Artificial Intelligence and Applications, vol. 215. IOS Press, Lisbon, Portugal, 957\u2013962. 1", "citeRegEx": "SLOTA and LEITE,? 2010", "shortCiteRegEx": "SLOTA and LEITE", "year": 2010}, {"title": "Robust equivalence models for semantic updates of answer-set programs", "author": ["M. SLOTA", "J. LEITE"], "venue": "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR 2012), G. Brewka, T. Eiter, and S. A. McIlraith, Eds. AAAI Press, Rome, Italy, 158\u2013168. 17", "citeRegEx": "SLOTA and LEITE,? 2012", "shortCiteRegEx": "SLOTA and LEITE", "year": 2012}, {"title": "Splitting and updating hybrid knowledge bases", "author": ["M. SLOTA", "J. LEITE", "T. SWIFT"], "venue": "Theory and Practice of Logic Programming, 27th Int\u2019l. Conference on Logic Programming (ICLP\u201911) Special Issue 11, 4-5, 801\u2013819. 2", "citeRegEx": "SLOTA et al\\.,? 2011", "shortCiteRegEx": "SLOTA et al\\.", "year": 2011}, {"title": "The polynomial-time hierarchy", "author": ["L.J. STOCKMEYER"], "venue": "Theoretical Computer Science 3, 1, 1\u201322. 6", "citeRegEx": "STOCKMEYER,? 1976", "shortCiteRegEx": "STOCKMEYER", "year": 1976}, {"title": "Strong equivalence made easy: nested expressions and weight constraints", "author": ["H. TURNER"], "venue": "Theory and Practice of Logic Programming (TPLP) 3, 4-5, 609\u2013622. 2, 7, 8, 17", "citeRegEx": "TURNER,? 2003", "shortCiteRegEx": "TURNER", "year": 2003}, {"title": "Updating Logical Databases", "author": ["M. WINSLETT"], "venue": "Cambridge University Press, New York, USA. 2, 3, 5, 12", "citeRegEx": "WINSLETT,? 1990", "shortCiteRegEx": "WINSLETT", "year": 1990}, {"title": "Logic program-based updates", "author": ["Y. ZHANG"], "venue": "ACM Transactions on Computational Logic 7, 3, 421\u2013472. 2, 9, 14", "citeRegEx": "ZHANG,? 2006", "shortCiteRegEx": "ZHANG", "year": 2006}, {"title": "A unified framework for representing logic program updates", "author": ["Y. ZHANG", "N.Y. FOO"], "venue": "Proceedings of the 20th National Conference on Artificial Intelligence (AAAI 2005), M. M. Veloso and S. Kambhampati, Eds. AAAI Press / The MIT Press, Pittsburgh, Pennsylvania, USA, 707\u2013713. 2, 9", "citeRegEx": "ZHANG and FOO,? 2005", "shortCiteRegEx": "ZHANG and FOO", "year": 2005}], "referenceMentions": [{"referenceID": 15, "context": "Answer-Set Programming (ASP) (Gelfond and Lifschitz 1988; Baral 2003) is now widely recognised as a valuable approach to knowledge representation and reasoning, mostly due to its simple and well-understood declarative semantics, its rich expressive power, and the existence of efficient implementations.", "startOffset": 29, "endOffset": 69}, {"referenceID": 6, "context": "Answer-Set Programming (ASP) (Gelfond and Lifschitz 1988; Baral 2003) is now widely recognised as a valuable approach to knowledge representation and reasoning, mostly due to its simple and well-understood declarative semantics, its rich expressive power, and the existence of efficient implementations.", "startOffset": 29, "endOffset": 69}, {"referenceID": 35, "context": "\u2217 This is an extended version of (Slota and Leite 2010).", "startOffset": 33, "endOffset": 55}, {"referenceID": 21, "context": "Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991).", "startOffset": 128, "endOffset": 197}, {"referenceID": 40, "context": "Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991).", "startOffset": 128, "endOffset": 197}, {"referenceID": 19, "context": "Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991).", "startOffset": 128, "endOffset": 197}, {"referenceID": 13, "context": "Both AGM and KM postulates were later studied in the context of Logic Programming, only to find that their formulations based on a non-monotonic semantics, such as the answer sets, are inappropriate (Eiter et al. 2002).", "startOffset": 199, "endOffset": 218}, {"referenceID": 4, "context": "Like many belief change operators, earlier methods used to tackle rule updates were based on literal inertia (Alferes and Pereira 1996) but proved not sufficiently expressive.", "startOffset": 109, "endOffset": 135}, {"referenceID": 24, "context": "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al.", "startOffset": 64, "endOffset": 88}, {"referenceID": 3, "context": "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.", "startOffset": 147, "endOffset": 244}, {"referenceID": 13, "context": "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.", "startOffset": 147, "endOffset": 244}, {"referenceID": 23, "context": "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.", "startOffset": 147, "endOffset": 244}, {"referenceID": 1, "context": "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.", "startOffset": 147, "endOffset": 244}, {"referenceID": 28, "context": "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.", "startOffset": 147, "endOffset": 244}, {"referenceID": 31, "context": "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al.", "startOffset": 113, "endOffset": 136}, {"referenceID": 42, "context": "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al.", "startOffset": 149, "endOffset": 169}, {"referenceID": 41, "context": "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al.", "startOffset": 186, "endOffset": 198}, {"referenceID": 9, "context": "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al. 2007), or dependencies on default assumptions (\u0160efr\u00e1nek 2006; Kr\u00fcmpelmann and KernIsberner 2010; \u0160efr\u00e1nek 2011).", "startOffset": 212, "endOffset": 235}, {"referenceID": 2, "context": "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.", "startOffset": 49, "endOffset": 144}, {"referenceID": 30, "context": "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.", "startOffset": 49, "endOffset": 144}, {"referenceID": 34, "context": "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.", "startOffset": 49, "endOffset": 144}, {"referenceID": 18, "context": "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.", "startOffset": 49, "endOffset": 144}, {"referenceID": 37, "context": "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.", "startOffset": 49, "endOffset": 144}, {"referenceID": 1, "context": "For example, except for the semantics proposed in (Alferes et al. 2005; \u0160efr\u00e1nek 2011), a tautological update may influence the result under all of these semantics, a behaviour that is highly undesirable when considering knowledge updates.", "startOffset": 50, "endOffset": 86}, {"referenceID": 10, "context": "Recently, AGM revision was reformulated in the context of Logic Programming in a manner analogous to belief revision in classical propositional logic, and specific revision operators for logic programs were investigated (Delgrande et al. 2008; Osorio and Cuevas 2007).", "startOffset": 220, "endOffset": 267}, {"referenceID": 28, "context": "Recently, AGM revision was reformulated in the context of Logic Programming in a manner analogous to belief revision in classical propositional logic, and specific revision operators for logic programs were investigated (Delgrande et al. 2008; Osorio and Cuevas 2007).", "startOffset": 220, "endOffset": 267}, {"referenceID": 39, "context": "Central to this novel approach are SE-models (Turner 2003) which provide a monotonic semantic characterisation of logic programs that is strictly more expressive than the answer-set semantics.", "startOffset": 45, "endOffset": 58}, {"referenceID": 25, "context": "Furthermore, two programs have the same set of SE-models if and only if they are strongly equivalent (Lifschitz et al. 2001), which means that programs P,Q with the same set of SE-models can be modularly replaced by one another, even in the presence of additional rules, without affecting the resulting answer sets.", "startOffset": 101, "endOffset": 124}, {"referenceID": 10, "context": "In this paper, we follow a similar path, but to tackle the problem of answer-set program updates, instead of revision as in (Delgrande et al. 2008).", "startOffset": 124, "endOffset": 147}, {"referenceID": 40, "context": "We show how this constructive characterisation can be used by defining a concrete answer-set program update operator that can be seen as a counterpart of Winslett\u2019s belief update operator (Winslett 1990) which satisfies the KM postulates and is commonly used in the literature.", "startOffset": 188, "endOffset": 203}, {"referenceID": 21, "context": "Update is a belief change operation that brings a knowledge base up to date when the world described by it changes (Keller and Winslett 1985; Katsuno and Mendelzon 1991).", "startOffset": 115, "endOffset": 169}, {"referenceID": 19, "context": "Update is a belief change operation that brings a knowledge base up to date when the world described by it changes (Keller and Winslett 1985; Katsuno and Mendelzon 1991).", "startOffset": 115, "endOffset": 169}, {"referenceID": 19, "context": "To further specify the desired properties of update operators, the following eight postulates for a belief update operator and formulae \u03c6, \u03c8, \u03bc, \u03bd were proposed in (Katsuno and Mendelzon 1991): (B1) \u03c6 \u03bc |= \u03bc.", "startOffset": 164, "endOffset": 192}, {"referenceID": 19, "context": "Definition 3 (Faithful order assignment (Katsuno and Mendelzon 1991)) A preorder assignment \u03c9 over I is faithful if for every interpretation I the following condition is satisfied:", "startOffset": 40, "endOffset": 68}, {"referenceID": 19, "context": "The representation theorem of (Katsuno and Mendelzon 1991) states that operators characterised by faithful order assignments are exactly those that satisfy the KM postulates.", "startOffset": 30, "endOffset": 58}, {"referenceID": 19, "context": "Theorem 4 (Representation theorem for belief updates (Katsuno and Mendelzon 1991)) Let be a belief update operator.", "startOffset": 53, "endOffset": 81}, {"referenceID": 21, "context": "The most influential instance of this framework is the Possible Models Approach (Keller and Winslett 1985; Winslett 1990), also referred to as Winslett\u2019s belief update semantics, based on minimising the set of atoms whose truth value changes when an interpretation is updated.", "startOffset": 80, "endOffset": 121}, {"referenceID": 40, "context": "The most influential instance of this framework is the Possible Models Approach (Keller and Winslett 1985; Winslett 1990), also referred to as Winslett\u2019s belief update semantics, based on minimising the set of atoms whose truth value changes when an interpretation is updated.", "startOffset": 80, "endOffset": 121}, {"referenceID": 14, "context": "the problem of deciding whether \u03c6 \u03bc |= \u03c8, where is characterised by W, belongs to the second level of the polynomial hierarchy (Eiter and Gottlob 1992).", "startOffset": 127, "endOffset": 151}, {"referenceID": 27, "context": "Assuming that the reader is familiar with the classes NP and co-NP, we briefly introduce the polynomial hierarchy (Meyer and Stockmeyer 1972; Stockmeyer 1976).", "startOffset": 114, "endOffset": 158}, {"referenceID": 38, "context": "Assuming that the reader is familiar with the classes NP and co-NP, we briefly introduce the polynomial hierarchy (Meyer and Stockmeyer 1972; Stockmeyer 1976).", "startOffset": 114, "endOffset": 158}, {"referenceID": 14, "context": "4 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W.", "startOffset": 5, "endOffset": 29}, {"referenceID": 14, "context": "2 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W.", "startOffset": 5, "endOffset": 29}, {"referenceID": 10, "context": "We define the syntax and semantics of logic programs, borrowing some of the notation used in (Delgrande et al. 2008).", "startOffset": 93, "endOffset": 116}, {"referenceID": 39, "context": "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.", "startOffset": 10, "endOffset": 23}, {"referenceID": 17, "context": "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.", "startOffset": 76, "endOffset": 121}, {"referenceID": 26, "context": "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.", "startOffset": 76, "endOffset": 121}, {"referenceID": 29, "context": "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.", "startOffset": 76, "endOffset": 121}, {"referenceID": 39, "context": "Definition 8 (SE-interpretation (Turner 2003)) An SE-interpretation is a pair of interpretations (I, J) such that I \u2286 J .", "startOffset": 32, "endOffset": 45}, {"referenceID": 39, "context": "Definition 9 (SE-model (Turner 2003)) Let P be a program.", "startOffset": 23, "endOffset": 36}, {"referenceID": 25, "context": "It is typically referred to as strong equivalence (Lifschitz et al. 2001) and the relationship between SE-models and strong equivalence is formally captured as follows:", "startOffset": 50, "endOffset": 73}, {"referenceID": 39, "context": "Proposition 10 (SE-models and strong equivalence (Turner 2003)) Let P,Q be programs.", "startOffset": 49, "endOffset": 62}, {"referenceID": 10, "context": "More generally, any set of SE-interpretations with this property is referred to as well-defined (Delgrande et al. 2008).", "startOffset": 96, "endOffset": 119}, {"referenceID": 10, "context": "Definition 12 (Well-defined set of SE-interpretations (Delgrande et al. 2008)) For every SE-interpretation X = (I, J) we denote by X\u2217 the SE-interpretation (J, J).", "startOffset": 54, "endOffset": 77}, {"referenceID": 10, "context": "Proposition 13 (Delgrande et al. 2008) A set of SE-interpretationsM is well-defined if and only ifM = JP KSE for some program P.", "startOffset": 15, "endOffset": 38}, {"referenceID": 13, "context": "Since SE-models provide a monotonic characterisation of logic programs, the analysis provided in (Eiter et al. 2002), which showed KM postulates not appropriate for use with non-monotonic semantics, no longer applies.", "startOffset": 97, "endOffset": 116}, {"referenceID": 24, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 3, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 13, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 31, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 42, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 1, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 41, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 9, "context": "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; \u0160efr\u00e1nek 2011).", "startOffset": 161, "endOffset": 339}, {"referenceID": 10, "context": "Note that the program conjunction operator may simply return the union of argument programs; it is the same as the expansion operator defined in (Delgrande et al. 2008).", "startOffset": 145, "endOffset": 168}, {"referenceID": 17, "context": "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).", "startOffset": 116, "endOffset": 161}, {"referenceID": 26, "context": "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).", "startOffset": 116, "endOffset": 161}, {"referenceID": 29, "context": "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).", "startOffset": 116, "endOffset": 161}, {"referenceID": 7, "context": "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; \u0141ukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).", "startOffset": 273, "endOffset": 300}, {"referenceID": 21, "context": "In what follows, we define a specific update operator based on the ideas underlying Winslett\u2019s update semantics (Keller and Winslett 1985; Winslett 1990) defined Section 2.", "startOffset": 112, "endOffset": 153}, {"referenceID": 40, "context": "In what follows, we define a specific update operator based on the ideas underlying Winslett\u2019s update semantics (Keller and Winslett 1985; Winslett 1990) defined Section 2.", "startOffset": 112, "endOffset": 153}, {"referenceID": 10, "context": "Similarly as was argued in (Delgrande et al. 2008), since we are working with well-defined sets of SE-interpretations, preference needs to be given to their second component.", "startOffset": 27, "endOffset": 50}, {"referenceID": 16, "context": "2 It has been shown that Winslett\u2019s update semantics has some drawbacks, just as other update operators previously proposed in the context of Classical Logic do (see (Herzig and Rifi 1999) for a survey).", "startOffset": 166, "endOffset": 188}, {"referenceID": 5, "context": "The property of support (Apt et al. 1988; Dix 1995b) is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy.", "startOffset": 24, "endOffset": 52}, {"referenceID": 24, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 3, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 13, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 31, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 1, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 41, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 9, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 8, "context": "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:", "startOffset": 193, "endOffset": 352}, {"referenceID": 24, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 3, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 13, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 31, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 1, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 41, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 9, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 8, "context": "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:", "startOffset": 146, "endOffset": 305}, {"referenceID": 10, "context": "Moreover, the principle (P4)SE is also adopted for revision of answer-set programs based on SE-models in (Delgrande et al. 2008).", "startOffset": 105, "endOffset": 128}, {"referenceID": 10, "context": "This means that Theorem 31 extends to semantic program revision operators, such as those defined in (Delgrande et al. 2008): Whenever", "startOffset": 100, "endOffset": 123}, {"referenceID": 20, "context": "3 Note that the belief update postulate (B4), from which (P4)SE originates, is also one of the reformulated AGM postulates for belief revision (Katsuno and Mendelzon 1992).", "startOffset": 143, "endOffset": 171}, {"referenceID": 16, "context": "Its two immediate weakenings, analogous to the weakenings of (B4) in (Herzig and Rifi 1999), are as follows:", "startOffset": 69, "endOffset": 91}, {"referenceID": 28, "context": "2)SE, also referred to as Weak Independence of Syntax (WIS) (Osorio and Cuevas 2007), does not suffer from such severe limitations.", "startOffset": 60, "endOffset": 84}, {"referenceID": 24, "context": "This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal \u223cp in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true.", "startOffset": 54, "endOffset": 120}, {"referenceID": 3, "context": "This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal \u223cp in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true.", "startOffset": 54, "endOffset": 120}, {"referenceID": 1, "context": "This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal \u223cp in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true.", "startOffset": 54, "endOffset": 120}, {"referenceID": 1, "context": "(Alferes et al. 2005), that have matured over the years.", "startOffset": 0, "endOffset": 21}, {"referenceID": 13, "context": "non-monotonic Logic Programming semantics, as shown in (Eiter et al. 2002), the introduction of SE-models (Turner 2003), which provide a monotonic characterisation of logic programs that is strictly more expressive than the answer-set semantics, provided a new opportunity to cast KM postulates into Logic Programming.", "startOffset": 55, "endOffset": 74}, {"referenceID": 39, "context": "2002), the introduction of SE-models (Turner 2003), which provide a monotonic characterisation of logic programs that is strictly more expressive than the answer-set semantics, provided a new opportunity to cast KM postulates into Logic Programming.", "startOffset": 37, "endOffset": 50}, {"referenceID": 36, "context": "a) away from the purely semantic approach materialised in AGM and KM postulates, or b) to the development of semantic characterisations of answer-set programs that are richer than SE-models and appropriately capture their dynamic behaviour, such as in (Slota and Leite 2012), or even c) turning back to the more syntactic approaches, such as (Alferes et al.", "startOffset": 252, "endOffset": 274}, {"referenceID": 1, "context": "a) away from the purely semantic approach materialised in AGM and KM postulates, or b) to the development of semantic characterisations of answer-set programs that are richer than SE-models and appropriately capture their dynamic behaviour, such as in (Slota and Leite 2012), or even c) turning back to the more syntactic approaches, such as (Alferes et al. 2005), and see whether they indeed offer a viable alternative.", "startOffset": 342, "endOffset": 363}, {"referenceID": 13, "context": "For instance, the reformulations of rule change principles from (Eiter et al. 2002) in terms of strong equivalence, considered already in (Delgrande et al.", "startOffset": 64, "endOffset": 83}, {"referenceID": 10, "context": "2002) in terms of strong equivalence, considered already in (Delgrande et al. 2008), can be formulated as follows:", "startOffset": 60, "endOffset": 83}, {"referenceID": 14, "context": "To do this, we rely on some specifics of the proof of Theorem 6 as it is presented in (Eiter and Gottlob 1992).", "startOffset": 86, "endOffset": 110}, {"referenceID": 14, "context": "page 250 of (Eiter and Gottlob 1992)) shows \u03a02 -hardness of Winslett\u2019s belief update semantics by taking an instance", "startOffset": 12, "endOffset": 36}, {"referenceID": 14, "context": "However, we omit the proof of the equivalence (C8) and refer the interested reader to (Eiter and Gottlob 1992) for further details.", "startOffset": 86, "endOffset": 110}, {"referenceID": 14, "context": "4 on page 252 in (Eiter and Gottlob 1992)): To prove that P \u2295 U 6|=SE Q, consider only atoms from at(P) \u222a at(U) \u222a at(Q) (this can be done due to Corollary 53), guess some SE-interpretations X and Y , check in polynomial time that X \u2208 JP KSE, Y \u2208 JU KSE and Y / \u2208 JQKSE and invoke the NP oracle to check that there is no Z \u2208 JU KSE such that Z <W Y .", "startOffset": 17, "endOffset": 41}, {"referenceID": 14, "context": "2 on page 259 in (Eiter and Gottlob 1992)): To prove that P \u2295", "startOffset": 17, "endOffset": 41}], "year": 2017, "abstractText": "Logic programs under the stable model semantics, or answer-set programs, provide an expressive rule-based knowledge representation framework, featuring a formal, declarative and well-understood semantics. However, handling the evolution of rule bases is still a largely open problem. The AGM framework for belief change was shown to give inappropriate results when directly applied to logic programs under a non-monotonic semantics such as the stable models. The approaches to address this issue, developed so far, proposed update semantics based on manipulating the syntactic structure of programs and rules. More recently, AGM revision has been successfully applied to a significantly more expressive semantic characterisation of logic programs based on SE-models. This is an important step, as it changes the focus from the evolution of a syntactic representation of a rule base to the evolution of its semantic content. In this paper, we borrow results from the area of belief update to tackle the problem of updating (instead of revising) answer-set programs. We prove a representation theorem which makes it possible to constructively define any operator satisfying a set of postulates derived from Katsuno and Mendelzon\u2019s postulates for belief update. We define a specific operator based on this theorem, examine its computational complexity and compare the behaviour of this operator with syntactic rule update semantics from the literature. Perhaps surprisingly, we uncover a serious drawback of all rule update operators based on Katsuno and Mendelzon\u2019s approach to update and on SE-models.", "creator": "LaTeX with hyperref package"}}}