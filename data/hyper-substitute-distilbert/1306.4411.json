{"id": "1306.4411", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Jun-2013", "title": "Event-Object Reasoning with Curated Knowledge Bases: Deriving Missing Information", "abstract": "the broader goal of our research is by deliver answers to why information reconcile things with access to context accumulate, requires vague definitions. one which we encounters when acquainted with many available knowledge bases makes that at times needed information is vague. examples containing this include supposed missing information about possibly sub - event, first counter - entity, now plus - event, result from an event, input to an event, remembrance of an event, and raw material conserved in an event. in other cases intuition can recover part of the missing, requiring reasoning. in good instance we apply best formal perspective about possible such missing beliefs can safely recovered & then define an asp examination of it. we then construct by implication of this with respect to answering why and how different.", "histories": [["v1", "Wed, 19 Jun 2013 01:58:21 GMT  (1359kb,D)", "https://arxiv.org/abs/1306.4411v1", "13 pages"], ["v2", "Thu, 20 Jun 2013 00:19:24 GMT  (1362kb,D)", "http://arxiv.org/abs/1306.4411v2", "13 pages"]], "COMMENTS": "13 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["chitta baral", "nguyen h vo"], "accepted": false, "id": "1306.4411"}, "pdf": {"name": "1306.4411.pdf", "metadata": {"source": "CRF", "title": "Event-Object Reasoning with Curated Knowledge Bases: Deriving Missing Information", "authors": ["Chitta Baral", "Nguyen H. Vo"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Our work in this paper is part of two related long terms goals: answering \u201cHow\u201d, \u201cWhy\u201d and \u201cWhat-if\u201d questions and reasoning with the growing body of available knowledge bases 1, some of which are crowd-sourced. Although answering \u201cHow\u201d and \u201cWhy\u201d questions are important, so far little research has been done on them. Our starting point to address them has been to formulate answers to such questions with respect to abstract knowledge structures obtained from knowledge bases. In particular, in the recent past we considered Event Description Graphs (EDGs) [1] and Event-Object Description Graphs (EODGs) [2] to formulate answers to some \u201cHow\u201d and \u201cWhy\u201d questions with respect to the Biology knowledge base AURA [3].\nGoing from the abstract structures to reasoning with real knowledge bases (KBs) we noticed that the KBs often have missing pieces of information, such as properties of an instance (of a class) or relations between two instances. For example, AURA does not encode that Eukaryotic translation is the next event of Synthesis of RNA in eukaryote; this may be because the two subevents of \u201cProtein synthesis\u201d were encoded independently. The missing pieces make the KB and the Description Graphs constructed from it fragmented and as a result answers obtained with respect to them are not intuitive. Moreover, the KBs like AURA often have two or more names that refer to the same entity. To get intuitive answers they need to be resolved and merged into a single entity.\n1 See for example, http://linkeddata.org/.\nar X\niv :1\n30 6.\n44 11\nv2 [\ncs .A\nI] 2\n0 Ju\nn 20\n13\nSuch finding of non-identical duplicates in the KB and merging them into one is referred in the literature as entity resolution [4, 5].\nIn this paper, we start with introducing knowledge description graphs (KDGs) as structures that can be (without much reasoning) obtained from frame based KBs such as AURA. We discuss underspecified knowledge description graphs (UDGs) and formulate notions of reasoning with respect to these graphs to obtain certain missing information. We then present our approach of entity resolution and use it in recovering additional missing information. We give an Answer Set Programming (ASP) encoding of our formulation. We conclude with a discussion on the use of the above in answering \u201cwhy\u201d and \u201chow\u201d questions."}, {"heading": "2 Background: Frame-based Knowledge Bases; ASP", "text": "The KB we used in this work is based on AURA [3] and was described in details in [6]. AURA is a frame-based KB manually curated by biology experts; it contains a large amount of frames describing biological entities events (or processes). One important aspect of our KB is the class hierarchy. For example 2: its basic class is Thing, which has two children classes: Entity and Event. Entity is the ancestor of all classes of biological entities; Event, of biologicalogy events. For instance, Spatial entity, Eukaryote, Nucleus and mRNA are descendants of Entity, while \u201cEukaryotic translation\u201d, \u201cEukaryotic transcription\u201d are descendant of Event.\nOur KB is a set of facts of the form \u201chas(A, slot name, B)\u201d where A and B are either classes or instances (of classes), slot name is the name of the relation between A and B such as instance of, raw material or results. The statement \u201ceukaryotic translation is based on mRNA\u201d is represented in our KB as follows.\nhas(euka_transl4191 , instance_of , event). has(euka_transl4191 , instance_of , eukaryotic_translation). has(euka_transl4191 , base , mrna4642). has(mrna4642 , instance_of , mrna).\nThis snippet reads as \u201ceukaryotic translation4191 is an instance of class event and an instance of class eukaryotic translation. eukaryotic translation4191 is based on mrna4642, which is an instance of mrna\u201d.\nFor the declarative implementation of our formulations, we use ASP [7]. That allows us to use our earlier work [6] on using ASP to reason with frame-based knowledge bases. ASP\u2019s strong theoretical foundation [8] and its default negation and recursion are useful in our encoding and in proving results about them."}, {"heading": "3 Knowledge Description Graphs", "text": "An Underspecified Knowledge Description Graph (UDG) is a structure to represent the facts about instances and classes of events, entities and relationships between them. An UDG is constructed from knowledge bases such as AURA. Formal definition of the UDGs is given in the following.\nDefinition 1. An UDG is a directed graph with one type of node and five types of directed edges: compositional edges, ordering edges, class edges, locational edges and participant edges. Each node represents an instance (of a class) or a class in our KBs. 2 Our examples are either directly from AURA, or are slightly modified from it.\nEdge type Relation(s) locational happenings class instance-of, super-class compositional subevent, first-subevent, has-part, has-region, has-basic-structural-unit ordering next-event, enables, causes, prevents, inhibits participant raw-materials, result, agent, destination, instrument, origin, site\nTable 1. Types of edges in an UDG. An edge of relation Y from a node X to Z represents X[Y ] = Z, meaning the slot Y of the entity X has value Z.\nWe used the slot names in KM [9] and AURA as a guide to categorize four types of edges (Table 1).\nA Knowledge Description Graph (KDG) (a slight generalization of EODGs in [2]) is constructed from an UDG. A node in a KDG represents either an instance of a biological entity, an instance of a biological process, or a class of biological entity/event. The KDG structure allows us to answer \u201cHow\u201d and \u201cWhy\u201d questions. More formally, a KDG is defined as follows.\nDefinition 2. A KDG is a directed graph with: (i) three types of nodes: event nodes, entity nodes, and class nodes; and (ii) five types of directed edges: compositional edges, class edges, ordering edges, locational edges and participant edges. A KDG has the property that there are no directed cycles within any combination of compositional, locational and participant edges.\nFigure 1 shows the types of edges in a KDG and the corresponding sources and destinations of the edges. Edges in a KDG are from the edges of the UDG, with additional type constraints of the source and destination nodes. For example, ordering edges must be from events to events; compositional edges are from events to events or from entity to entity, depending on their specific relations.\nSince UDGs and KDGs can be huge, we usually work on their smaller subgraphs that are rooted at an entity or an event. They are defined as follows.\nDefinition 3. Let Z be a node in a KDG G. The Knowledge Description Graph (KDG) rooted at Z is the subgraph of G composed of: (1) The set N of all the nodes of G that are accessible from Z through compositional edges, class edges,\nlocational edges or participant edges; and (2) All the edges of G connecting two nodes in N . We denote the KDG rooted at Z as KDG(Z) or the KDG of Z.\nThe UDG rooted at Z, denoted as UDG(Z), is defined similarly. Figure 2 shows an example of a KDG rooted at Eukaryote where every other nodes can be reached from Eukaryote through edges with solid lines (compositional edges, class edges, locational edges or participant edges)."}, {"heading": "4 Reasoning about Missing Info. in UDGs and KDGs", "text": "In this section, we discuss about missing information in the UDGs and the KDGs and how we can recover some of it through reasoning."}, {"heading": "4.1 Event, Next Event, First Sub-event and Last Sub-event", "text": "One can directly obtain event names by looking at facts of the form \u201chas(E, instance of, event)\u201d in the KB; and concluding E in it as an event. However, for some events such facts may be missing. In that case, we may be able to get the fact from the UDG\u2019s edges and the edge constraints of the KDGs (Figure 1). More formally:\nDefinition 4. Let E be a node in the UDG(Z). E is an event if there is (i) a participant edge or an ordering edge from E; (ii) a locational edge or an ordering edge to E; (iii) a compositional edge (of subevent or first subevent relation) from/to E; or (iv) a path of class edges from E to the class event.\nBased on Definition 4, we can get that photosynthesis is an event because it has compositional edges (of subevent relation) to light reaction and calvin cycle.\nNext-event, first subevent and last subevent are amongst the most important properties in describing events. However, they are not always directly available in our KB. Fortunately, in many cases, we can recover them from other properties.\nDefinition 5. Let E and E\u2032 be two events in the KDG(Z). Event E\u2032 is the next event of E if E enables, causes, prevents or inhibits E\u2032.\nIn other words, E\u2032 is the next event of E if there is an ordering edge from E to E\u2032.\nDefinition 6. Let S be the set of subevents of an event X in the KDG(Z). Event E in S is the first subevent of X if there exists no other event E\u2032 in S such that E is the next event of E\u2032. Similarly, event E in S is the last subevent of X if there exists no other event E\u2032 in S such that E\u2032 is the next event of E.\nHere we assume that S was properly encoded in that there is only one chain of subevents in S. In our KB, light reaction and calvin cycle are two subevents of photosynthesis and light reaction enables calvin cycle. But their orders are not defined. However, using Definition 5 and 6, we can identify that: calvin cycle is the next event of light reaction; light reaction is the first subevent of photosynthesis; and calvin cycle is the last subevent."}, {"heading": "4.2 Input/Output of Events", "text": "Two types of events: In our KB there are two types of events: transport events and operational events. In a transport event, there is only a change in the locations; the input location and output location are different from each other while the input entity and output entity are the same. All other events are operational events. In an operational event, there is usually no change in its location. We differentiate two types of events by their ancestor classes; transport events are descendants of the classes move through, move into and move out of.\nInput, Output, Input Location, Output Location: To reason about the KDG, we need the input and output of each event as well as the input location and the output location, which are not always available. In the following, we show how to use various event\u2019s relations - such as raw-material, destination, location and others - to create four new relations (IO relations): input, output, input-location and output-location. After that, we propose rules to complete the KDG\u2019s IO relations.\nWe created the IO relations of an event based on specific relations as shown in Table 2. The meaning of relation \u201cbase\u201d from AURA depends on the context. For transport events, it is for input-location; for operational events, it is for input.\nDefinition 7. Let FSE and LSE respectively be the first subevent and last subevent of event E in KDG(Z).\nLet InputRelation be the input relation, input-location relation or one of their corresponding relations (Table 2). If InputRelation is a relation from FSE to X then InputRelation is also a relation from E to X.\nLet OutputRelation be the output relation and output-location relation or one of their corresponding relations. If OutputRelation is a relation from LSE to X then OutputRelation is also a relation from E to X.\nIn our KB, photosynthesis has two subevents: light reaction and calvin cycle, the next event of light reaction. Sunlight is the raw-material of the light reaction, sugar is the result of calvin cycle. Using Definition 7, we have that sunlight is the raw-material of photosynthesis and sugar is its result. Moreover, we also have: sunlight is the input of light reaction as well as photosynthesis; sugar is the output of both calvin cycle and photosynthesis.\nSimilarly, the output location of an operational event is often not defined in the KB but we can use input location as the default value for output location.\nDefinition 8. Let E be an event in KDG(Z), E\u2019s input location is also the output location if E\u2019s output location has not been specified.\nFigure 3 shows the IO properties of events in Fig 2. The properties in bold are the ones that were recovered using Definitions 7 and 8."}, {"heading": "4.3 Main Class of an Instance", "text": "In our KB, one instance can belong to many classes. For example, dna strand19497 - the input of Eukaryotic transcription - is an instance of dna strand, dna sequence, nucleic acid and polymer 4. However, to reason about the equality between in-\n4 For the sake of simplicity, in the previous figures and descriptions, we usually referenced the entities and events by their \u201cmain\u201d class(es) and not by the instances\u2019 names although our KB and our implementation works on instances\u2019 names.\nstances, we need the \u201cmain\u201d class(es), the most specific class(es) of that instance. Our formal definition of \u201cmain\u201d class is given below.\nDefinition 9. Let E be an instance in KDG(Z). ClassB is a main class of instance E if (1) it is a class of E and (2) it is not the case that there is a ClassA which is a class of E and (a) ClassB is ancestor of ClassA or (b) ClassB is a general class but ClassA is not; where general classes in our KB are thing, event, entity, spatial entity, tangible entity, and chemical entity.\nThe main classes of dna strand19497, according to the Definition 9, are dna strand and dna sequence; the other classes of dna strand19497 are ancestors of those two."}, {"heading": "5 Entity Resolution", "text": "In the KBs such as AURA, the curation was done in many sessions and probably by many people. (Same is true with respect to many other KBs; especially the ones that are developed using crowd-sourcing.) The results are, in many cases, (i) two different instance names were used when they are probably the same instance; and (ii) parts of some biological process were encoded as independent events. For example: the input of Eukaryotic translation (Figure 2) is mrna4642 whereas the output of Move out is mrna22911 ; Synthesis of RNA in eukaryote and Eukaryotic translation should be subevents of \u201cSynthesis of protein in eukaryote\u201d but they are encoded as two separate events.\nIn this section, we propose methods to solve the first problem. These methods are then used to solve the second problem in the next section. In order to compare two instances in a KB, we define a match relation. Generally speaking, instance A can match with instance B if A can be safely used in a context where a term of B is expected. We defined matching relation with many confidence levels for greater flexibility in future works.\nDefinition 10. Let A and B be two instances in KDG(Z). Let ClassA and ClassB be main classes of A and B respectively.\n1. A matches with B with high confidence if one of the following is true\n(a) A = B (A and B are the same instance) (b) A is cloned from B (Shortcut in AURA to specify that A has all the\nproperties of B) (c) ClassA is an ancestor of ClassB.\n2. A matches with B with medium confidence if A and B are both cloned from an instance C. 3. A matches with B with low confidence if ClassA = ClassB (A and B are instances of the same main class). 4. A matches with B with confidence min(Conf1, Conf2) if\n(a) A matches with C with confidence Conf1 and (b) C matches with B with confidence Conf2\n5. Otherwise, A does not match with B.\nUsing Def.10, we can match mrna4642 - the input of Eukaryotic translation - with mrna22911 - the output of Move out, because both have mrna as the main class.\nWhile Def.10 can match all the input and output in our aforementioned example, it is not sufficient for matching location. For example, we can not match an instance of cytoplasm to an instance of cytosol. However when we say Event A occurs in cytosol, we can understand that Event A occurs in cytoplasm. To overcome this shortcoming, we define the relation Spatially match as follows.\nDefinition 11. Instance A in KDG(Z) is a location instance if the class ClassA of A is a descendant of the class spatial entity.\nDefinition 12. Let A and B be two location instances in KDG(Z). Let ClassA and ClassB be main classes of A and B respectively.\n1. Location A spatially matches with location B with confidence Conf if instance A matches with instance B with confidence Conf . 2. Location A spatially matches with location B with high confidence if one of the following is true: (a) B is inside A (the relation inside is encoded in our KB by slot name\nis inside). (b) B is part of A (the relation \u201cpart of\u201d is encoded in our KB by slot name\npart of). 3. Location A spatially matches with location B with confidence min(Conf1, Conf2)\nif (a) A spatially matches with location C with confidence Conf1, and (b) C spatially matches with B with confidence Conf2.\nSuppose that in our KB we have: cytosol234 and cytosol987 all are instances of cytosol; cytoplasm322 is an instance of cytoplasm and cytosol987 is inside cytoplasm322. We can then conclude: cytosol234 and cytosol987 match with each other with low confidence, according to Def.10.3; cytoplasm322 spatially matches with cytosol987 with high confidence (Def.12.2.a); cytosol987 spatially matches with cytosol234 with low confidence (Def.12.1); and cytoplasm322 spatially matches with cytosol234 with low confidence (Def.12.3) ."}, {"heading": "6 Finding the Possible Next Events", "text": "In this section, we demonstrate the usefulness of matching instances (Definition 10 and 12) in finding the possible next event(s) of a given event. While in simple cases (Section 4.1), we can find the next event E\u2019 of an event E by using Definition 5, there are still cases where there exists no ordering edges from E to E\u2032. For examples, Alteration of mrna ends and RNA splicing are two subevents of RNA processing but no other relation between them was defined. However, they all occur in nucleus16421 and Alteration of mrna ends\u2019s output, pre mrna7690, matches with RNA splicing \u2019s input, rna8697. This information hints us that RNA splicing is Alteration of mrna ends\u2019s next event.\nFollowing this intuition, our approach for finding the next event is that E\u2032 is the next event of E if the output of E matches the input of E\u2032 and output\nlocation of E matches the input location of E\u2032. In the example in Figure 2, this assumption holds in all three events: Eukaryotic transcription, RNA processing and Move out ; all of which are already defined in our KB as consequent events. This assumption also suggests that Eukaryotic translation can be the next event of either Synthesis of RNA in eukaryote or Move out. Armed with Definition 10 and 12, we define the following join relation.\nDefinition 13. Let A and B be two events in KDG(Z). Event A joins to event B if all of the following conditions are true:\n1. The output of A matches with the input of B or vice versa. 2. The output location of A spatially matches with the input location of B or\nvice versa.\nApplying this definition, we have: Alteration of mrna ends joins to RNA splicing, Eukaryotic transcription joins to RNA processing ; RNA processing joins to Move out ; and both Synthesis of RNA in eukaryote and Move out are joined from Eukaryotic translation. Since we want Eukaryotic translation to be a possible next event of Synthesis of RNA in eukaryote instead of its subevent Move out, we define the possible next event as follows.\nDefinition 14. Let A and B be two events in KDG(Z) where A joins to B. B is a possible next event of A if none of the following conditions is true:\n1. A joins to AncestorB where AncestorB is the ancestor event of B (in other words, there is a non-empty path of subevent relation from AncestorB to B). 2. Ancestor event AncestorA of A joins to B. 3. A is an ancestor event of B. 4. B is an ancestor event of A. 5. A and B have the same ancestor event.\nIn our example, condition 14.2 gives us that Eukaryotic translation is not the possible next event of Move out while 14 concludes that Eukaryotic translation is the possible next event of Synthesis of RNA in eukaryote. We assume that an event and its subevents are put in our KB as a whole, so the next event relations between them are well defined. Thus conditions 14.3-5 take those relations out of consideration.\nWhen we have a path of possible next events, we can create an event SE, which is the super event of all events in the path, and add suitable next event or subevent relations. This new event would link the events that were mistakenly encoded as independent events (that we mentioned earlier)."}, {"heading": "7 ASP Encodings", "text": "In this section we give ASP encodings of our formulations in the previous sections.\nEncoding the Entities and Events: Rules t1-t2 in the following state that an instance X is an event or an entity if and only if it is the instance of event\nclass or entity class respectively. Rules t3-t4 identify E as an event if there is an ordering edge to E (Definition 4.ii). Rule t5 encodes Definition 4.iv. \u201chas(X, ancestorclass, Y)\u201d denotes the transitive closure of \u201chas(M, superclass, N)\u201d and is encoded the standard way (rules t6-t7). The rest of Definition 4 are encoded similarly in rules t8-t21.\nt1: event(X):-has(X,instance_of ,event). t2: entity(X):-has(X,instance_of ,entity). t3: ordering_edge(next_event; enables; causes; prevents; inhibits). t4: has(E, instance_of , event) :- has(X, S, E), ordering_edge(S). t5: has(E, instance_of , event) :- has(X, instance_of , ClassY), has(ClassY ,\nancestorclass , event).\nFinding Next Events, First Subevents and Last Subevents: Rules e1-e2 find the next events (Definition 5) and rules e3-e6 find the first subevents and the last subevents (Definition 6).\ne1: predicates(ordering_edge , enables; causes; prevents; inhibits). e2: has(E1 , next_event , E2) :- has(E1, Predicate , E2), predicates(ordering_edge , Predicate). e3: not_fse(Z, E) :- has(Z, subevent , E), has(Z, subevent , E2), E2 != E,\nhas(E2 , next_event , E). e4: not_lse(Z, E) :- has(Z, subevent , E), has(Z, subevent , E2), E2 != E,\nhas(E, next_event , E2). e5: has(Z, first_subevent , E) :- has(Z, subevent , E), not not_fse(Z, E). e6: has(Z, last_subevent , E) :- has(Z, subevent , E), not not_lse(Z, E).\nEncoding Transport Events and Operational Events: t event(E) or o event(E) is used to indicate a transport event or an operational event, respectively.\nev1: predicates(t_event , move_through; move_into; move_out_of). ev2: t_event(E) :- has(E, instance_of , Transport_class), predicates(t_event , Transport_class), event(E). ev3: o_event(E) :- event(E), not t_event(E).\nEncoding the Inputs and Outputs of Operational Events: We denote the input/output/input location/output location of an event by input, output, input loc and output loc respectively. Rules i1-i5 get the IOs of operational events. IOs of transport events are encoded similarly (rules i6-i10).\ni1:input(E,A):-has(E,object ,A),o_event(E). i2:input(E,A):-has(E,base ,A),o_event(E). i3:input(E,A):-has(E,raw_material ,A),o_event(E). i4:output(E,A):-has(E,result ,A),o_event(E). i5:input_loc(E,A):-has(E,site ,A),o_event(E).\nGetting the Missing Inputs and Outputs: Rule i11 gets the input of an event from its first subevent (Definition 7.1). Rule i12 gets the object property of a transport event from its first subevent. Other rules to get the input location, output and output location as well as other properties, such as raw-material, result, are encoded in a similar way (rules i13-i24). Rule i25 gets the default output location of an event(Definition 8).\ni11: has(E, input , A) :- has(SE, input , A), has(E, first_subevent , SE). i12: has(E, object , A) :- has(SE, object , A), has(E, first_subevent , SE), transport_event(E). i25: has(E, output_location , A) :- not has(E, output_location , A2), has(E,\ninput_location , A), entity(A2), event(E), A2 != A.\nEncoding the Main Class(es) of an Instance: ClassA is a main class of instanceA if ClassA is one ofA\u2019s classes and we do not have not main class(A,ClassA) (which mean ClassA is not the main class of A).\nm1: general_class(thing; event; entity; spatial_entity; tangible_entity; chemical_entity). m2: not_main_class(A, ClassB) :- has(A, instance_of , ClassA), has(A, instance_of , ClassB), has(ClassA , ancestorclass , ClassB). m3: not_main_class(A, ClassB) :- has(A, instance_of , ClassA)), has(A, instance_of , ClassB), general_class(ClassB), not general_class(ClassA). m4: main_class(A, ClassA) :- has_class(A, ClassA), not not_main_class(A, ClassA).\nEncoding Instance Matching: We use predicatematch with(A,B,Confidence) to represent match with relation (Definition 10) from instanceA toB; Confidence can be either low, medium or high. Rule ma1 encodes the sub-case 10.1.a of Definition 10. The last rule is for Definition 10.4, matching A to B transitively through C. lowest confidence(Conf1, Conf2, Conf) means Conf is the lowest confidence in Conf1 and Conf2 (Rules lc1-lc7). Rules for other cases of Definition 10 are skipped (rules ma2-ma5); locational instance matching is encoded in a similar way (rules sma1-sma4).\nma1: match_with(A,B,high) :- main_class(A,ClassA), main_class(B,ClassB), A==B. ma6: match_with(A,B,Conf) :- match_with(A,C,Conf1), match_with(C,B,Conf2), A!=B, A!=C, B!=C, lowest_confidence(Conf1 ,Conf2 ,Conf).\nEncoding Possible-next-event Relation: In this section, we show how Definition 14 is encoded. We use has(A, tc subevent,B) to represent transitive closure of sub event relation between A and B (encoded by has(A, subevent,B)), which is defined in the standard way (rules tcsub1-tcsub3). We also use join(A,B) to encode that A joins to B according to Definition 13 (rules j1-j3). The two rules below is corresponding to the sub-case 14.1. Other cases are skipped (rules n2-n5).\nn1: _notNextEvent(A, B) :- _join(A, SuperB), _join(A, B), has(SuperB , tc_subevent , B). n6: possible_next_event(A,B) :- _join(A, B), not _notNextEvent(A, B).\nCorrectness of the ASP Rules:\nDefinition 15. The ASP program \u03a0Z is the answer set program consisting of the facts of the form \u201chas(X,S, V )\u201d that are generated from all the nodes and edges of KDG(Z) in the following way:\n1. For each node N , generate \u201chas(N, instance of, event)\u201d if N is event node, \u201chas(N, instance of, entity) if N is entity nodes. 2. For each edge of relation R (Table 1) from E1 to E2, generate \u2018has(E1, R,E2)\u201d.\nDefinition 16. The ASP program \u03a0 is the answer set program consisting of the following rules: t1 to t14 for events and entities, e1 to e6 for next events, first subevents and last events, ev1 to ev3 for two types of events, i1 to 25 for inputs, outputs of events, m1 to m4 for main class(es), lc1 to lc7 for the lowest confidence, ma1 to ma6 for match relation, sma1 to sma4 for spatially match relation, tcsub1 to tcsub2 for transitive closure of subevents, j1 to j3 for joined events, and n1 to n6 for possible next events.\nProposition 1: E is the last subevent of X in KDG(Z) iff \u03a0Z \u222a\u03a0 |= has(Z, last subevent, E) Proposition 2: A is the main class of E in KDG(Z) iff \u03a0Z \u222a\u03a0 |= main class(E,A) Proposition 3: Let A and B be two instances in KDG(Z). A matches with B with the confidence level Conf iff \u03a0Z \u222a\u03a0 |= match with(A,B,Conf) Proposition 4: Let A and B be two events in in KDG(Z). A is a possible next event of B iff \u03a0Z \u222a\u03a0 |= possible next event(A,B)"}, {"heading": "8 Discussion: Answering \u201cHow\u201d and \u201cWhy\u201d Questions", "text": "In Section 4, we showed how to recover missing information using properties of KDG\u2019s structure. Completing this information not only allows us to improve the KB that was used to construct the KDG, but also make it possible to reason about large curated KB using KDG. In Section 5 and 6, we also solved an important step in bringing the KB\u2019s usage out of small examples: we proposed the methods to compare instances and demonstrated their power in finding possible next events.\nThose efforts have enabled us to answer deep reasoning questions, such as \u201cHow\u201d and \u201cWhy\u201d questions. We give examples of a few of them in the following. Details about answering them are explained in another work of ours [2].\n1. The answer of \u201cHow does X occur?\u201d is simply a structure that basically contains KDG(X) and all the nodes connected to/from X through ordering edges. 2. The answer of \u201cHow does X produce Y?\u201d is similar to \u201cHow does X occur?\u201d but X must produce Y . 3. The answer of \u201cHow are X and Y related?\u201d is a simplified structure of KDG(Z) that contains: two paths of component edges to X and Y from their lowest common ancestor and all paths of ordering edges linking two nodes in those two paths. 4. Similarly, the answer of \u201cWhy X is important to Y?\u201d is the answer of \u201cHow are X and Y related?\u201d plus the path on \u201cimportant\u201d links which explains why X is important to Y . An \u201cimportant\u201d link from A to B is defined in KDG to indicates that A is important to B. 5. Other questions that KDG can answer includes \u201cHow does X participate in process Y?\u201d, \u201cHow does X do Y?\u201d, \u201cWhy does X produce Y?\u201d and others."}, {"heading": "9 Conclusion", "text": "In this paper we have shown how to derive certain missing information from large knowledge bases. Often such knowledge bases are created by multiple people; sometimes even through crowd-sourcing. This often leads to some information being not explicitly stated, even though the knowledge base contains clues to derive that information. In our larger quest to formulate answers to \u201cwhy\u201d and \u201chow\u201d questions, we focused on the frame based knowledge base AURA, noticed several such omissions, and using those as examples, developed several general formulations regarding missing knowledge about events. We also gave an ASP\nimplementation of our formulations and used them in answering \u201cwhy\u201d and \u201chow\u201d questions. We briefly discussed some of those question types and how their answer can be obtained from Knowledge Description Graphs (KDGs). Thus, by being able to obtain missing information and enriching the original KDGs one can obtain more accurate and intuitive answers to the various \u2018why\u201d and \u201chow\u201d questions.\nOne of our formulations was about entity resolution where we resolve multiple entities that may have different names but may refer to the same entity. Our method is different from other methods in the literature [4,5]. Since each entity resolution method heavily relies on the properties of the database it is working on, and no other system we know of is about AURA or similar event centered knowledge bases we were unable to directly compare our method with the others.\nOur approach to use rules (albeit ASP rules) to derive missing information is analogous to use of rules in data cleaning and in improving data quality [10\u201312]. However those works do not focus on issues that we discussed in this paper."}], "references": [{"title": "Answering why and how questions with respect to a frame-based knowledge base: a preliminary report", "author": ["C. Baral", "N.H. Vo", "S. Liang"], "venue": "Technical Communications of the 28th International Conference on Logic Programming (ICLP\u201912) 17", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Formulating question answering with respect to event-object description graphs", "author": ["C. Baral", "N. Vo"], "venue": "Unpublished paper submitted to a conference", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "AURA: capturing knowledge and answering questions on science textbooks", "author": ["V.K. Chaudhri", "P.E. Clark", "S. Mishra", "J. Pacheco", "A. Spaulding", "J. Tien"], "venue": "Technical report, SRI International", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2009}, {"title": "Link mining: a survey", "author": ["L. Getoor", "C.P. Diehl"], "venue": "ACM SIGKDD Explorations Newsletter 7(2)", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2005}, {"title": "A survey of entity resolution and record linkage methodologies", "author": ["D.G. Brizan", "A.U. Tansel"], "venue": "Communications of the IIMA 6(3)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2006}, {"title": "From knowledge represented in frame-based languages to declarative representation and reasoning via ASP", "author": ["C. Baral", "S. Liang"], "venue": "13th International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In Kowalski, R., Bowen, K., eds.: Logic Programming: Proc. of the Fifth Int\u2019l Conf. and Symp., MIT Press", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1988}, {"title": "Knowledge representation, reasoning and declarative problem solving", "author": ["C. Baral"], "venue": "Cambridge University Press", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2003}, {"title": "KM: The knowledge machine 2.0: Users manual", "author": ["P. Clark", "B. Porter", "B. Works"], "venue": "Citeseer", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2004}, {"title": "Data quality and record linkage techniques", "author": ["T.N. Herzog", "F.J. Scheuren", "W.E. Winkler"], "venue": "Springer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2007}, {"title": "Data cleaning: Problems and current approaches", "author": ["E. Rahm", "H.H. Do"], "venue": "IEEE Data Engineering Bulletin 23(4)", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2000}, {"title": "Conditional dependencies: A principled approach to improving data quality", "author": ["W. Fan", "F. Geerts", "X. Jia"], "venue": "Dataspace: The Final Frontier. Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "In particular, in the recent past we considered Event Description Graphs (EDGs) [1] and Event-Object Description Graphs (EODGs) [2] to formulate answers to some \u201cHow\u201d and \u201cWhy\u201d questions with respect to the Biology knowledge base AURA [3].", "startOffset": 80, "endOffset": 83}, {"referenceID": 1, "context": "In particular, in the recent past we considered Event Description Graphs (EDGs) [1] and Event-Object Description Graphs (EODGs) [2] to formulate answers to some \u201cHow\u201d and \u201cWhy\u201d questions with respect to the Biology knowledge base AURA [3].", "startOffset": 128, "endOffset": 131}, {"referenceID": 2, "context": "In particular, in the recent past we considered Event Description Graphs (EDGs) [1] and Event-Object Description Graphs (EODGs) [2] to formulate answers to some \u201cHow\u201d and \u201cWhy\u201d questions with respect to the Biology knowledge base AURA [3].", "startOffset": 235, "endOffset": 238}, {"referenceID": 3, "context": "Such finding of non-identical duplicates in the KB and merging them into one is referred in the literature as entity resolution [4, 5].", "startOffset": 128, "endOffset": 134}, {"referenceID": 4, "context": "Such finding of non-identical duplicates in the KB and merging them into one is referred in the literature as entity resolution [4, 5].", "startOffset": 128, "endOffset": 134}, {"referenceID": 2, "context": "The KB we used in this work is based on AURA [3] and was described in details in [6].", "startOffset": 45, "endOffset": 48}, {"referenceID": 5, "context": "The KB we used in this work is based on AURA [3] and was described in details in [6].", "startOffset": 81, "endOffset": 84}, {"referenceID": 6, "context": "For the declarative implementation of our formulations, we use ASP [7].", "startOffset": 67, "endOffset": 70}, {"referenceID": 5, "context": "That allows us to use our earlier work [6] on using ASP to reason with frame-based knowledge bases.", "startOffset": 39, "endOffset": 42}, {"referenceID": 7, "context": "ASP\u2019s strong theoretical foundation [8] and its default negation and recursion are useful in our encoding and in proving results about them.", "startOffset": 36, "endOffset": 39}, {"referenceID": 8, "context": "We used the slot names in KM [9] and AURA as a guide to categorize four types of edges (Table 1).", "startOffset": 29, "endOffset": 32}, {"referenceID": 1, "context": "A Knowledge Description Graph (KDG) (a slight generalization of EODGs in [2]) is constructed from an UDG.", "startOffset": 73, "endOffset": 76}, {"referenceID": 1, "context": "Details about answering them are explained in another work of ours [2].", "startOffset": 67, "endOffset": 70}, {"referenceID": 3, "context": "Our method is different from other methods in the literature [4,5].", "startOffset": 61, "endOffset": 66}, {"referenceID": 4, "context": "Our method is different from other methods in the literature [4,5].", "startOffset": 61, "endOffset": 66}, {"referenceID": 9, "context": "Our approach to use rules (albeit ASP rules) to derive missing information is analogous to use of rules in data cleaning and in improving data quality [10\u201312].", "startOffset": 151, "endOffset": 158}, {"referenceID": 10, "context": "Our approach to use rules (albeit ASP rules) to derive missing information is analogous to use of rules in data cleaning and in improving data quality [10\u201312].", "startOffset": 151, "endOffset": 158}, {"referenceID": 11, "context": "Our approach to use rules (albeit ASP rules) to derive missing information is analogous to use of rules in data cleaning and in improving data quality [10\u201312].", "startOffset": 151, "endOffset": 158}], "year": 2013, "abstractText": "The broader goal of our research is to formulate answers to why and how questions with respect to knowledge bases, such as AURA. One issue we face when reasoning with many available knowledge bases is that at times needed information is missing. Examples of this include partially missing information about next sub-event, first subevent, last sub-event, result of an event, input to an event, destination of an event, and raw material involved in an event. In many cases one can recover part of the missing knowledge through reasoning. In this paper we give a formal definition about how such missing information can be recovered and then give an ASP implementation of it. We then discuss the implication of this with respect to answering why and how questions.", "creator": "LaTeX with hyperref package"}}}