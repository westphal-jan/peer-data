{"id": "1401.0767", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Jan-2014", "title": "From Kernel Machines to Ensemble Learning", "abstract": "ensemble methods such as boosting combine multiple learners to obtain better prediction than samples confidently accessed from only individual learner. here we propose broader principled framework for independently constructing ensemble learning methods above both methods. unlike conventional procedures providing the equivalence combined boosting and support vector machines ( las ), which includes a translation procedure, practitioners add that tool isn refreshing to try estimation - like approaches to solve more resultant scaling problems.", "histories": [["v1", "Sat, 4 Jan 2014 02:28:48 GMT  (542kb,D)", "http://arxiv.org/abs/1401.0767v1", null]], "reviews": [], "SUBJECTS": "cs.LG cs.CV", "authors": ["chunhua shen", "fayao liu"], "accepted": false, "id": "1401.0767"}, "pdf": {"name": "1401.0767.pdf", "metadata": {"source": "CRF", "title": "From Kernel Machines to Ensemble Learning", "authors": ["Chunhua Shen", "Fayao Liu"], "emails": [], "sections": [{"heading": null, "text": "Index Terms\u2014Kernel, Support vector machines, Ensemble learning, Column generation, Multi-class classification.\nI. INTRODUCTION\nEnsemble learning methods, with a typical example being boosting [1]\u2013[5], have been successfully applied to many machine learning and computer vision applications. Its excellent performance and fast evaluation have made ensemble learning one of the most widelyused learning methods, together with kernel machines like SVMs. In the literature, the general connection between boosting and SVM has been shown by Schapire et al. [2], and Ra\u0308tsch et al. [6]. In particular, Ra\u0308tsch et al. [6] developed a mechanism to convert SVM algorithms to boosting-like algorithms by translating the quadratic programs (QP) of SVMs into linear programs (LP) of boosting (similar to LPBoost [7]). A one-class boosting method was then designed by converting one-class SVM into an LP. Following this vein, a direct approach to multi-class boosting was developed in [8] by using the loss function in Crammer and Singer\u2019s multi-class SVM [9]. The recipe to transfer algorithms is essentially [6]: \u201cThe SV-kernel is replaced by an appropriately constructed hypothesis space for leveraging where the optimization of an analogous mathematical program is done using `1 instead of `2-norm.\u201d This transfer is indirect in the sense that one has to design a different `1 norm regularized mathematical program. We suspect that this is due to the widely-adopted belief that boosting methods need the sparsity-inducing `1-norm regularization so that the final ensemble model only relies on a subset of weak learners [3], [6].1 In this work, we show that it is possible to design ensemble learning methods by directly solving standard SVM optimization problems. Unlike [6], [8], no mathematical transform is needed. The only optimization technique that our framework relies on is column generation. With the proposed framework, the advantages that we can think of are: 1) Many kernel methods can directly have an equivalent ensemble model; 2) As conventional boosting methods, our ensemble models are iteratively learned. At each iteration, compared with the `1 optimization involved in the indirect approach [3], [6]\u2013[8], our optimization problems are much simpler. For the first time, we enable the use of fast linear SVM optimization software for ensemble learning. 3) As the fully-corrective boosting methods in [3], [8], our\nThe authors are with Australian Center for Visual Technologies, and School of Computer Science, The University of Adelaide, SA 5005, Australia (e-mail: {chunhua.shen,fayao.liu}@adelaide.edu.au).\nThis work was in part supported by Australian Research Council Future Fellowship FT120100969.\n1At the same time, standard SVM needs `2 regularization so that the kernel trick can be applied, although `1 SVM [10] takes a different approach.\nensemble learning procedure is also fully corrective. Therefore the convergence speed is often much faster than stage-wise boosting. 4) Kernel SVMs usually offer promising classification accuracies at the price of high usage of memory and evaluation time, especially when the size of training data is large. Recall that the number of support vectors is linearly proportional to the number of training data [11]. Ensemble models, on the other hand, are often much faster to evaluate. Ensemble learning is also more flexible in that the user can determine the number of weak learners used. Typically an ensemble model uses less than a few thousand weak learners. Ensemble learning can also select features by using decision stumps or trees as weak learners, while nonlinear kernels are defined on the entire feature space. The developed framework tries to enjoy the best of both worlds of kernel machines and ensemble learning. Additional contributions of this work include: 1) To exemplify the usefulness of this proposed framework, we introduce a new multiclass boosting method based on the recent multi-class SVM [12]. The new multi-class boosting is effective in performance and can be efficiently learned since a closed-form solution exists at each iteration. 2) We introduce Fourier features as weak learners for learning the strong classifier. Fourier features approximate the radial basis function (RBF) Gaussian kernel. Our experiments demonstrate that Fourier weak learners usually outperforms decision stumps and linear perceptrons. 3) We also show that multiple kernel learning is made much easier with the proposed framework."}, {"heading": "II. RELATED WORK", "text": "The general connection between SVM and boosting has been discussed by a few researchers [2], [6] at a high level. To our knowledge, the work here is the first one that attempts to build ensemble models by solving SVM\u2019s optimization problem. We review some closest work next. Boosting has been extensively studied in the past decade [1]\u2013[3], [7], [8]. Our methods are close to [3], [7] in that we also use column generation (CG) to select weak learners and fully-correctively update weak learners\u2019 coefficients. Because we are solving the SVM problem, instead of the `1 regularized boosting problem, conventional CG cannot be directly applied. We use CG in a novel way\u2014instead of looking at dual constraints, we rely on the KKT conditions.\nIf one uses an infinitely many weak learners in boosting [13] (or hidden units in neural networks [14]), the model is equivalent to SVM with a certain kernel. In particular, it shows that when the feature mapping function \u03a6(\u00b7) contains infinitely many randomly distributed decision stumps, the kernel function k(x,x\u2032) = \u3008\u03a6(x),\u03a6(x\u2032)\u3009 is the stump kernel of the form \u2206\u2212 \u2016x\u2212 x\u2032\u20161. Here \u2206 is a constant, which has no impact on the SVM training. Moreover, when \u03a6(x) = sign(\u03b8>x\u2212\u03ba), i.e. , a perceptron, the corresponding kernel is called the perceptron kernel k(x,x\u2032) = \u2206\u2032 \u2212 \u2016x\u2212 x\u2032\u20162.\nLoosely speaking, boosting can be seen as explicitly computing the kernel mapping functions because, as pointed out in [6], a kernel constructed by the inner product of weak learners\u2019 outputs satisfies the Mercer\u2019s condition. Random Fourier features (RFF) [15] have been applied to large-scale kernel methods. RFF is designed by using the fact that a shift-invariant kernel is the Fourier transform of a non-negative measure. Yang et al. show that RFF does not perform well due to its data-independent sampling strategy when there is a large gap in the eigen-spectrum of the kernel matrix [16]. In [17], [18], it shows that for homogeneous additive kernels, the kernel mapping function can be exactly computed. When RFF is used as weak learners in the proposed framework here, the greedy CG based RFF selection can be viewed as data-dependent feature selection. Indeed, our experiments demonstrate that our method performs much better than random sampling.\nar X\niv :1\n40 1.\n07 67\nv1 [\ncs .L\nG ]\n4 J\nan 2\n01 4\n2"}, {"heading": "III. KERNEL METHODS AND ENSEMBLE MODELS", "text": "We first review some fundamental concepts in SVMs and boosting. We then show the connection between these two methods and show how to design column generation based ensemble learning methods that directly solve the optimization problems in kernel methods.\nLet us consider binary classification for the time being. Assume that the input data points are (xi, yi) \u2208 X \u00d7{\u22121, 1}, with i = 1 \u00b7 \u00b7 \u00b7m. For SVMs, it is well known that the original data x are implicitly mapped to a feature space through a mapping function \u03a6 : X\u2192 F. The function \u03a6 is implicitly defined by a kernel function k(x,x\u2032) = \u3008\u03a6(x),\u03a6(x\u2032)\u3009, which computes the inner product in F. SVM finds a hyperplane that best separates the data by solving:\nmin w,b,\u03be\u22650\nfsv = 1 2 \u2016w\u201622 + C1 >\u03be, (1)\nsubject to the margin constraints yi(w>\u03a6(xi)+b) \u2265 1\u2212\u03bei, \u2200i. Here 1 is a vector of all 1\u2019s. The Lagrange dual can be easily derived:\nmax \u03b1\n1>\u03b1\u2212 1 2 \u03b1>(K \u25e6 yy>)\u03b1, s.t. 0 \u2264 \u03b1 \u2264 C,y>\u03b1 = 0. (2)\nHere C is the trade-off parameter; K is the kernel matrix with Kij = k(xi,xj); and \u25e6 denotes element-wise matrix multiplication, i.e. , Hadamard product. yy> is the label matrix with y = [y1, \u00b7 \u00b7 \u00b7 , ym] >. Note that in the case of linear SVMs, i.e. , k(x,x\u2032) = \u3008x,x\u2032\u3009, there are fast and scalable algorithms for training linear SVMs, e.g. , LIBLINEAR [19].\nEnsemble learning methods, with boosting being the typical example, usually learns a strong classifier/model by linearly combining a finite set of weak learners. Formally the learned model is F (x) = w>\u03a6(x) with\n\u03a6(x) = [}1(x), \u00b7 \u00b7 \u00b7 , }J(x)]>. (3)\nTherefore, in the case of boosting, the feature mapping function is explicitly learned: \u03a6 : x \u2192 [}1(x), \u00b7 \u00b7 \u00b7 , }J(x)]>, where }(\u00b7) \u2208 H is the weak learner. It is easy to see that a kernel induced by the weak learner set k(x,x\u2032) = \u2211 j }j(x)}j(x\n\u2032) is a valid one and its corresponding kernel matrix must be positive semidefinite. Next let us take LPBoost as an example to see how CG is used to explicitly learn weak learners, which is the core of most boosting methods [3], [7].\nThe primal program of LPBoost can be written as\nmin w\u22650,\u03be\u22650\nflp = \u2016w\u20161 + C1 >\u03be, (4)\nsubject to the margin constraint yi(w>\u03a6(xi)) \u2265 1 \u2212 \u03bei, \u2200i. with \u03a6(\u00b7) defined in (3). The dual of (4) is\nmax \u03b1\n1>\u03b1, s.t. 0 \u2264 \u03b1 \u2264 C, \u2211 iyi\u03b1i\u03a6(xi) \u2264 1. (5)\nNote that the last constraint in the dual is a set of J constraints. Often, the number of possible weak learners can be infinitely large. In this case it is intractable to solve either the primal or dual. In this case, CG can be used to solve the problem. These original problems are referred to as the master problems. The CG method solves these problems by incrementally selecting a subset of columns (variables in the primal and constraints in the dual) and optimizing the restricted problem on the subset of variables. So the basic idea of CG is to add one constraint at a time to the dual problem until an optimal solution is identified. In terms of the primal problem, CG solves the problem on a subset of variables, which corresponds to a subset of constraints in the dual. If a constraint absent from the dual problem is violated by the solution to the restricted problem, this constraint needs to be included in the dual problem to further restrict its feasible region. To speed convergence we would like to find the one with maximum\ndeviation (most violated dual constraint), that is, the base learning algorithm must deliver a function }\u0302(\u00b7) such that\n}\u0302(\u00b7) = argmax }\u2208H\n\u2211 i yi\u03b1i}(xi). (6)\nIf there is no weak learner }(\u00b7) for which the dual constraint\u2211 i yi\u03b1i}(xi) \u2264 1 is violated, then the current combined hypothesis is the optimal solution over all linear combinations of weak learners. That is the main idea of LPBoost [7] and its extension [3]. It has been believed that here two components have played an essential role in this procedure of deriving this meaningful dual such that CG can be applied. 1) This derivation relies on the `1 norm regularization in the primal objective of flp. 2) The constraint of nonnegative w lead to the dual inequality constraint. Without this nonnegative constraint, the last dual constraint becomes an equality: \u2211 iyi\u03b1i\u03a6(xi) = 1. In terms of optimization, the constraint w \u2265 0 causes difficulties. We will show the remedies for these difficulties in the next section."}, {"heading": "IV. FROM SVM TO ENSEMBLE LEARNING", "text": "We show how to derive ensemble learning directly from kernel methods like SVM. Our goal is to explicitly solve (1) without using the kernel trick. In other words, similar to boosting, we iteratively solve (1) by explicitly learning the kernel mapping function \u03a6(\u00b7). At the first glance, it is unclear how to use the idea of CG to derive a boosting-like procedure similar to LPBoost, as discussed above. In order to add a weak learner }(\u00b7) into \u03a6(\u00b7) by finding the most violated dual constraint\u2014as a starting point\u2014we must have a dual constraint containing \u03a6(\u00b7). From the dual problem of SVM (2), the main difficulty here is that the dual constraints are two types of simple linear constraints on the dual variable \u03b1. The dual constraints do not have \u03a6(\u00b7) at all. A condition for applying CG is that the duality gap between the primal and dual problems is zero (strong duality). Generally, the primal problem must be convex2 and both the primal and dual are feasible, so the Slater condition holds. In such a case, the KKT conditions are necessary conditions for a solution to be optimal. One such condition in deriving the dual (2) from (1) is\nw = \u2211m i=1 yi\u03b1i\u03a6(xi). (7)\nThis KKT condition is the root of the representer theorem in kernel methods, which states that a minimizer of a regularized empirical risk function defined over a reproducing kernel Hilbert space can be represented as a finite linear combination of kernel products evaluated on the input points.\nWe can verify the optimality by checking the dual feasibility and KKT conditions. At optimality, (7) must hold for all j, i.e. , wj = \u2211 i yi\u03b1i}j(xi) must hold for all j. For the columns/weak learners in the current working set, i.e. , j = 1 . . . J , the corresponding condition in (7) is satisfied by the current solution. For the weak learners that are not selected yet, they do not appear in the current restricted optimization problem and the corresponding wj = 0. It is easy to see that if \u2211 i yi\u03b1i}j(xi) = 0 for any }j(\u00b7) that is not in the current working set, then current solution is already the globally optimal one. So, our base learning strategy to check the optimality as well as to select the best weak learner }\u0302(\u00b7) is:\n}\u0302(\u00b7) = argmax }\u2208H \u2223\u2223\u2223\u2211i yi\u03b1i}(xi)\u2223\u2223\u2223. (8) Different from (6), here we select the weak learner with the score\u2211 i yi\u03b1i}(xi) farthest from 0, which can be negative. Now we show that using (8) to choose a weak learner is not heuristic in terms of solving the SVM problem of (1).\n2A Lagrange dual problem is always convex.\n3 Algorithm 1 CGENS: Column generation for learning ensembles Input: Training data (xi, yi), i = 1 \u00b7 \u00b7 \u00b7m; termination threshold > 0;\nregularization parameter C > 0; (optional) maximum iteration Jmax.\nInitialize: J = 0; w = 0; \u03b1i = const (0 < const < C).1 while true do2 \u00b7 Find a new weak learner }\u0302(\u00b7) by solving (6);3 \u00b7 Check the termination condition: if \u2211 i yi\u03b1i}\u0302(xi) < , then4 terminate (problem solved); \u00b7 Add }\u0302(\u00b7) to the restricted master problem;5 \u00b7 Solve either the primal (1) or dual (2), and update \u03b1, w, b.6 \u00b7 J = J + 1; (optional) if J > Jmax, then terminate.7\nOutput: The final learned model: F (x) = w>\u03a6(x) +b = \u2211 j wj }j(x) + b.\nClaim 4.1: At iteration J + 1, the weak learner selected using (8) decreases the duality gap the most for the current solution obtained at iteration J , in terms of solving the SVM primal problem (1) or dual (2). To prove the above result, let us check the dual objective in (2). We denote the current working set (corresponding to current selected weak learners) by W and the rest by W\u0304. The dual objective in (2) is\n1>\u03b1\u2212 1 2 \u03b1>(KW \u25e6 yy>)\u03b1\u2212 1 2 \u03b1>(KW\u0304 \u25e6 yy>)\u03b1. (9)\nHere the (s, t) entry of KW is\u2329 \u03a6W(xs),\u03a6 W(xt) \u232a = \u2211 j\u2208W }j(xs)}j(xt);\nand likewise, KW\u0304st = \u2211 j\u2208W\u0304 }j(xs)}j(xt). Clearly the sum of first terms in (9) equals to the objective value of the primal problem with the current solution: 1\n2 \u2016w\u201622 + C1 >\u03be. Therefore the duality gap is the last term of (9): \u2212 1\n2 \u03b1>(KW\u0304 \u25e6 yy>)\u03b1 =\n\u2212 1 2 \u2211 j\u2208W\u0304 [\u2211 i yi\u03b1i}j(xi) ]2 . Clearly minimization of this duality gap leads to the base learning rule (8). Next, we show that it can be equivalent between (6) and (8).\nClaim 4.2: Let us assume that the weak learn set H is negation complete; i.e. , if }(\u00b7) \u2208 H, then [\u2212}](\u00b7) \u2208 H; and vice versa. Here [\u2212}](\u00b7) means the function [\u2212}](\u00b7) = \u2212(}(\u00b7)). Then to solve (8), we only need to solve (6). This result is straightforward. Because H is negation complete, if a maximizer of (8), }\u0302(\u00b7), leads to \u2211 i yi\u03b1i}\u0302(xi) < 0, then [\u2212}\u0302(\u00b7)](\u00b7) \u2208\nH is also a maximizer of (8) such that \u2211 i yi\u03b1i}\u0302(xi) > 0. Therefore we can always solve (6) to obtain the maximizers of (8). At this point, we are ready to design CG based ensemble learning for solving the SVM problem, analogue to boosting, e.g. , LPBoost. The proposed ensemble learning method,3 termed CGENS, is summarized in Algorithm 1. Note that at Line 6, we can use very efficient linear SVM solvers to solve either the primal or dual. In our experiments, we have used LIBLINEAR [19].\nHaving shown how to solve the standard SVM problem using CG, we provide another example application of the proposed framework by developing a new multi-class ensemble method using the idea of simplex coding [12]."}, {"heading": "V. MULTI-CLASS ENSEMBLE LEARNING", "text": "As most real-world problems are inherently multi-class, multiclass learning is becoming increasingly important. Coding matrix based boosting methods are one of the popular boosting approaches to multi-class classification. Methods in this category include AdaBoost.MO [20], AdaBoost.OC and AdaBoost.ECC [21]. Shen and Hao proposed a direct approach to multi-class boosting in [8].\n3In order not to confuse the terms, we use \u201censemble learning\u201d instead of \u201cboosting\u201d for our boosting-like algorithms.\nAlgorithm 2 CGENS-SLS: Simplex coding multi-class ensembles Input: Training data (xi, yi), i = 1 \u00b7 \u00b7 \u00b7m; termination threshold > 0;\nregularization parameter C > 0; (optional) maximum iteration Jmax.\nInitialize: J = 0; Li: = spx(yi)>; Assign a positive constant to each1 element of Ui\u03c4 . w\u03c4 = 0, b\u03c4 = 0, \u03c4 = 1 \u00b7 \u00b7 \u00b7 l. while true do2 \u00b7 Find a new weak learner }\u0302(\u00b7) by solving (13);3 \u00b7 Check the termination condition: if max\u03c4 \u2211 i }\u0302(xi)Ui\u03c4 < ,4 then terminate (problem solved); \u00b7 Add }\u0302(\u00b7) to the restricted master problem;5 \u00b7 Update H, U, w\u03c4 using (11) (solving (10));6 \u00b7 J = J + 1; (optional) if J > Jmax, then terminate.7\nOutput: The learned l classifiers: F\u03c4 (x) = w>\u03c4\u03a6(x) + b\u03c4 , \u03c4 = 1, \u00b7 \u00b7 \u00b7 , l; with \u03a6(x) = [}1(x), \u00b7 \u00b7 \u00b7 , }J (x)]>.\nHere we proffer a new multi-class ensemble learning method based on the simplex least-squares SVM (SLS-SVM) introduced in [12]. SLS-SVM can be seen as a generalization of the binary LS-SVM (least-squares SVM). For binary classification, LS-SVM fits the decision function output to the label: min 1\n2 \u2016w\u201622 + C 2 \u2211 i \u03be 2 i with\n\u03bei = w >\u03a6(xi) + b \u2212 yi. In the case of multi-class classification, label yi \u2208 {1, 2, . . . , l + 1}. Here we have l + 1 classes. Simplex coding maps each class label to l + 1 most separated vectors {c1, c2, \u00b7 \u00b7 \u00b7 , cl+1} on the unit hypersphere in Rm. So we need to learn l classifiers. Let us assume that the simplex label coding function is spx : {1, \u00b7 \u00b7 \u00b7 , l} \u2192 {c1, \u00b7 \u00b7 \u00b7 , cl} (see Appendix). The label matrix L \u2208 Rm\u00d7l collects training data\u2019s coded labels such that each row Li: = spx(yi)>.\nSLS-SVM trains the l classifiers simultaneously by minimizing the following regularized problem:\nmin 1 2 \u2211l \u03c4=1 \u2016w\u03c4\u2016 2 2 + C 2 \u2211m i=1 \u2211l \u03c4=1 O 2 i\u03c4 ,\ns.t. Oi\u03c4 = Li\u03c4 \u2212w>\u03c4\u03a6(xi)\u2212 b\u03c4 . (10)\nHere the model parameters to optimize are w\u03c4 \u2208 RJ , b\u03c4 \u2208 R, for \u03c4 = 1, \u00b7 \u00b7 \u00b7 , l. Problem (10) can be solved by deriving its dual (see Appendix) and the solutions are:\nb = (1>S\u22121L 1>S\u221211 )> ,\nU = S\u22121(L\u2212 1b>), w\u03c4 = HU:\u03c4 .\n(11)\nHere H \u2208 RJ\u00d7m denotes the learned weak classifiers\u2019 response on the whole training data such that each column H:i = \u03a6(xi); S = H>H+ 1\nC Im; Im is the m\u00d7m identity matrix; U \u2208 Rm\u00d7l is the dual\nLagrange multiplier associated with the equality constraints of O. Note that, the inverse of S can be computed efficiently incrementally (see the supplementary document).\nHere one of the KKT conditions that CG relies on is (last equation of (11)):\nw\u03c4 = \u2211 iUi\u03c4\u03a6(xi), (12)\nSimilar to the binary case, the subproblem for generating weak learners is\n}\u0302(\u00b7) = argmax \u03c4=1\u00b7\u00b7\u00b7l,}\u2208H\n\u2211 iUi\u03c4}(xi). (13)\nFor the same reason as in Result 4.2, we have removed the absolute operation without changing the essential problem. A subtle difference from the binary classification is that we pick the best weak learner across all the l classifiers.\nWe summarize our multi-class ensemble method in Algorithm 2. The output is the l classifiers:\nF (x) = [ w>1 \u03a6(x) + b1, \u00b7 \u00b7 \u00b7 ,w>l \u03a6(x) + bl ] , (14)\nThe classification rule assigns the label\nargmax y=1,\u00b7\u00b7\u00b7 ,l+1\n\u3008F (x), cy\u3009 (15)\nto the test datum x."}, {"heading": "VI. EXPERIMENTS", "text": "We run experiments on binary and multi-class classification problems, and compare our methods against classical boosting methods."}, {"heading": "A. Binary classification", "text": "We conduct experiments on synthetic as well as real datasets, namely, 2D toy, 13 UCI benchmark datasets4, and then on several vision tasks such as digits recognition, pedestrian detection etc..\n2D toy data The data are generated by sampling points from a 2D Gaussian distribution. All points within a certain radius belong to one class and all outside belong to the other class. The decision boundary obtained by CGENS with decision stumps is plotted in Fig. 1. As can be seen, our method converges faster than AdaBoost because CGENS is fully corrective.\nUCI benchmark For the UCI experiment, we use three different weak learners, namely, decision stumps, perceptrons and Fourier\n4http://www.raetschlab.org/Members/raetsch/benchmark\nweak learners, with each compared with the corresponding kernel SVMs and other boosting methods.\nWe use decision stumps (stump kernel for SVM) in this experiment. We compared our method with AdaBoost, LPBoost, all using decision stumps as the weak learner. All the parameters are chosen using 5- fold cross validation. The maximum iteration for AdaBoost, LPBoost [7] and our CGENS are searched from {25, 50, 100, 250, 500}. Results of SVMs with the stump kernel are also reported [13]. Results are the average of 5 random splits on each dataset. From Table I, we can see that overall, all the methods achieve comparable accuracy, with CGENS being marginally the best, and SVM the second best.\nIn the second experiment, we compare our method (using 500 weak learners) against several other methods such as SVM using (1) perceptrons sign(\u03b8>x \u2212 \u03ba) as weak learners and the perceptron kernel for SVM, and (2) Fourier cosine functions [15] cos(\u03b8>x\u2212\u03ba) as weak learners and Gaussian RBF kernel for SVM. We did not optimize the weak learner\u2019s parameters {\u03b8, \u03ba}. Instead, we sample 2000 pairs of {\u03b8, \u03ba} according to their distributions as described in [13] and [15], and then pick the one that maximizes the weak learner selection criterion in Equ. (8).\nIn the case of the perceptron kernel, same as the decision stump kernel, it is parameter free. In the case of Gaussian RBF kernel (corresponding Fourier weak learners), there is Gaussian bandwidth parameter \u03c3. Here \u03b8 in Fourier is sampled from a Gaussian distribution with the same bandwidth. We cross validate this bandwidth parameter \u03c3 with the SVM and use the same \u03c3 for sampling Fourier weak learners for use in CGENS. Ideally one can cross validate \u03c3 with CGENS, which needs extra computation overhead. This might be the reason why RBF SVM is slightly better CGENS with Fourier weak learners as shown in Table II, because CGENS uses the optimal \u03c3 of SVM. While in the case of perceptrons, CGENS performs on par with SVM. Note that as expected, in general, CGENS and SVM again outperform AdaBoost and LPBoost.\nWe have also compared our CGENS with RFF [15]. Although CGENS uses 500 features (weak learners) and RFF uses 2000 features, CGENS still slightly outperforms RFF.\nComputation efficiency of CGENS We evaluate the computation efficiency of the proposed CGENS. As mentioned, At each CG iteration of CGENS, we need to solve a linear SVM and therefore we can take advantage of off-the-shelf fast linear SVM solvers. Here we have used LIBLINEAR. We compare CGENS against LPBoost because both are fully-corrective boosting. At each iteration, LPBoost needs to solve a linear program. We use the state-of-the-art commercial solver Mosek [22] to solve the dual problem (5). The dual problem has less number of variables than the primal (4). Thus it more efficient for Mosek to solve the dual problem.\nWe run experiments on a standard desktop using the MNIST data\nto differentiate odd from even digits. First we vary the number of iterations (selected weak learners) while fixing the number of training data to be 104. For the second one, we vary the number of training data and fix the iteration number to be 100. Fig. 2 reports the comparison results. Note that the CPU time includes the training time of decision stumps. Overall, CGENS is orders of magnitude faster than LPBoost."}, {"heading": "B. Multi-class classification", "text": "To demonstrate the potential effectiveness of the proposed ensemble learning method in multi-class classification task, we test the proposed CGENS-SLS algorithm both on UCI and image benchmark datasets. For fair comparison, we focus on the multi-class algorithms using binary weak learners, including AdaBoost.ECC [21] , AdaBoost.MH [20] and MultiBoost [8] using the exponential loss.\nThe proposed CGENS-SLS method is more related to MultiBoost in the sense that both use the fully-corrective boosting framework, yet it employs an LS regression-type formulation of multi-class classifier and a closed-form solution exists for the sub optimization problem during each iteration. For all boosting algorithms, decision stumps are chose as the weak learners due to its simplicity and the controlled complexity. Similar to the binary classification experiments, the maximum number of iteration is set to 500. The regularization parameters in our CGENS-SLS and MultiBoost [8] are both determined by 5- fold cross validation. We first test the proposed CGENS-SLS on 7 UCI datasets, and then on several vision tasks. The results are summarized in Table III.\nUCI datasets For each of the 7 dataset, all samples are randomly divided into 75% for training and 25% for test, regardless of the existence of a pre-specified split. Each algorithm is evaluated 10 times and the average results are reported.\nHandwritten digit recognition Three handwritten digit datasets are evaluated here, namely, MNIST, USPS and PENDIGITS. For MNIST, we randomly sample 1000 examples from each class for training and use the original test set of 10000 examples for test. For USPS, we randomly select 75% for training and the rest for test.\nImage classification We then apply the proposed CGENS-SLS for image classification on several datasets: PASCAL07 [23], LabelMe [24] and CIFAR10. For PASCAL07, we use 5 types of features provided in [25]. For LabelMe, we use the LabelMe-12-50k5 subset and generate the GIST [26] features. Images which have more than one class labels are excluded for these two datasets. We use 70% of the data for training, and the rest for test. As for CIFAR106, we also\n5http://www.ais.uni-bonn.de/download/datasets.html 6http://www.cs.toronto.edu/ kriz/cifar.html\nuse the GIST [26] features and use the provided test and training sets.\nScene recognition The Scene15 dataset consists of 4,485 images of 9 outdoor scenes and 6 indoor scenes. We randomly select 100 images per class for training and the rest for test. Each image is divided into 31 sub-windows, each of which is represented as a histogram of 200\nvisual code words, leading to a 6200D representation. For the SUN dataset, we construct a subset of the original dataset containing 25 categories, where the top 200 images are selected from each category. For the subset, we randomly select 80% data for training and the rest for test. HOG features described in [27] are used as the image feature.\nFrom Table III, we can see that the proposed CGENS-SLS achieves overall best performance, especially on the vision datasets. Figure 3 shows the test error and training time comparison with respect to different iteration numbers on four image datasets. Our proposed CGENS-SLS performs slightly better than all the other methods in terms of classification accuracy while being more efficient than AdaBoost.MH and MultiBoost."}, {"heading": "VII. CONCLUSION", "text": "Kernel methods are popular in domains even outside of the computer science community largely because they are easy to use and there are highly optimized software available. On the other hand, ensemble learning is being developed in a separate direction and has also found its applications in various domains. In this work, we show that one can directly design ensemble learning methods from kernel methods like SVMs. In other words, one may directly solve the optimization problems of kernel methods by using column generation technique. The learned ensemble model is equivalent to learning the explicit feature mapping functions of kernel methods. This new insight about the precise correspondence enables us to design new algorithms. In particular we have shown two examples of new ensemble learning methods which have roots in SVMs. Extensive experiments show the advantages of these new ensemble methods over conventional boosting methods in term of both classification accuracy and computation efficiency."}, {"heading": "VIII. APPENDIX", "text": ""}, {"heading": "A. Solutions of the multi-class SLS-SVM and ensemble learning", "text": "The Lagrangian of problem (10) is L(w1, \u00b7 \u00b7 \u00b7 ,wl,b,O,U) = 12 \u2211l \u03c4=1 \u2016w\u03c4\u2016 2 2 +\nC 2 \u2211m i=1 \u2211l \u03c4=1 O 2 i\u03c4 \u2212 \u2211m i=1 \u2211l \u03c4=1 Uij \u00b7\n(w>\u03c4\u03a6(xi) + b\u03c4 \u2212 Li\u03c4 + Oi\u03c4 ), (16)\nwhere U \u2208 Rm\u00d7l is the collection of Lagrange variables corresponded to O. The optimization problem can be solved by setting its first order partial derivative with respect to the parameters w\u03c4 , b\u03c4 ,Li\u03c4\nand Oi\u03c4 to zeros: \u2202L\n\u2202w\u03c4 = w\u03c4 \u2212\n\u2211m i=1Ui\u03c4\u03a6(xi) = 0,\n\u2202L \u2202b\u03c4 = \u2212\n\u2211m i=1Ui\u03c4 = 0,\n\u2202L\n\u2202Oi\u03c4 = COi\u03c4 \u2212Ui\u03c4 = 0,\n\u2202L\n\u2202Ui\u03c4 = w>\u03c4\u03a6(xi) + b\u03c4 \u2212 Li\u03c4 + Oi\u03c4 = 0.\n(17)\nUse H \u2208 RJ\u00d7m to denote the weak classifiers\u2019 response on the whole training data such that each column H:i = \u03a6(xi). The previous conditions can be rewritten to the following form:\nw\u03c4 = HU:\u03c4 , (18a)\n0 = U>:\u03c41, (18b) O:\u03c4 = C \u22121U:\u03c4 , (18c) L:\u03c4 = H >w\u03c4 + b\u03c41 + O:\u03c4 , (18d)\nwhere O:\u03c4 and L:\u03c4 is the \u03c4 th column of O and L, respectively. Substituting (18a) and (18c) into (18d), we have\nL:\u03c4 = ( def. as S\ufe37 \ufe38\ufe38 \ufe37 H>H + C\u22121Im)U:\u03c4 + b\u03c41\n=\u21d2 S\u22121L:\u03c4 = S\u22121SU:\u03c4 + b\u03c4S\u221211 =\u21d2 S\u22121L:\u03c4 = S\u22121SU:\u03c4 + b\u03c4S\u221211\n=\u21d2 1>S\u22121L:\u03c4 = =0, due to (18b)\ufe37 \ufe38\ufe38 \ufe37 1>U:\u03c4 +b\u03c41 >S\u221211 =\u21d2 b\u03c4 = 1>S\u22121L:\u03c4\n1>S\u221211 , U:\u03c4 = S\n\u22121(L:\u03c4 \u2212 b\u03c41)\n=\u21d2 b = (1 >S\u22121L\n1>S\u221211 )>, U = S\u22121(L\u2212 1b>).\n(19)\nThe inverse for S can be computed efficiently as follows. Suppose H(J),S(J),S\u22121(J) and H(J+1),S(J+1),S \u22121 (J+1) are matrices in the J th and (J + 1)th iteration, respectively. We have H(J+1) = [ H>(J) hJ+1 ]> , where hJ+1 = [}J+1(x1), }J+1(x2), \u00b7 \u00b7 \u00b7 , }J+1(xn)]>. It is easy to see that S(J),S \u22121 (J),S(J+1) and S \u22121 (J+1) are symmetric matrices. So,\nS\u22121(J+1) = ( C\u22121Im + H > (J+1)H(J+1) )\u22121 = ( C\u22121Im + H > (J)H(J) + hJ+1h > J+1\n)\u22121 = ( S(J) + hJ+1h > J+1\n)\u22121 =S\u22121(J) \u2212 S \u22121 (J)hJ+1 ( 1 + h>J+1S \u22121 (J)hJ+1 )\u22121 h>J+1S \u22121 (J).\nLet sJ+1 = S\u22121(J)hJ+1, the update process finally is\nS\u22121(J+1) = S \u22121 (J) \u2212\nsJ+1s > J+1\n1 + h>J+1sJ+1 . (20)"}, {"heading": "B. Binary classification on Spambase data set", "text": "We performed experiments on the UCI Spam dataset to demonstrate the feature selection of the proposed method when using\ndecision stump as weak learner. The task is to differentiate spam emails according to word frequencies. We use AdaBoost as a baseline. The maximum iterations are both set to 60 due to fast convergence and no overfitting observed hereafter. We use 5-fold cross validation to choose the best hyper parameter C in CGENS. The results, shown in Table IV, are reported over 20 different runs with training/testing ratio being 3 : 2. Fig. 5 plots the average frequencies over the 20 rounds. As can be observed, both algorithms select important features such as \u201cfree\u201d (feature #16), \u201chp\u201d (25) and \u201c!\u201d (52) with high frequencies. As for the other features, the two methods showed different inclinations. CGENS tends to select features like \u201cremove\u201d (7), \u201cyou\u201d (19), \u201c$\u201d (53) which are intuitively meaningful for the classification. On the contrary, the favorite ones of AdaBoost are \u201cgeorge\u201d (27), \u201cmeeting\u201d (42) and \u201cedu\u201d (46) which are more irrelevant for spam email detection. This explains why our method slightly outperformed AdaBoost in test accuracy."}], "references": [{"title": "A decision-theoretic generalization of on-line learning and an application to boosting", "author": ["Y. Freund", "R.E. Schapire"], "venue": "J. Comp. & Syst. Sci., vol. 55, no. 1, pp. 119\u2013139, 1997.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1997}, {"title": "Boosting the margin: a new explanation for the effectiveness of voting methods", "author": ["R.E. Schapire", "Y. Freund", "P. Bartlett", "W.S. Lee"], "venue": "Annals of Statistics, vol. 26, pp. 322\u2013330, 1998. 8", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1998}, {"title": "On the dual formulation of boosting algorithms", "author": ["C. Shen", "H. Li"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., vol. 32, 2010.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "RandomBoost: Simplified multi-class boosting through randomization", "author": ["S. Paisitkriangkrai", "C. Shen", "Q. Shi", "A. van den Hengel"], "venue": "IEEE Transactions on Neural Networks and Learning Systems, 2014.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2014}, {"title": "Boosting through optimization of margin distributions", "author": ["C. Shen", "H. Li"], "venue": "IEEE Transactions on Neural Networks, vol. 21, no. 4, pp. 659\u2013666, 2010.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Constructing boosting algorithms from SVMs: An application to one-class classification", "author": ["G. R\u00e4tsch", "S. Mika", "B. Sch\u00f6lkopf", "K.-R. M\u00fcller"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., vol. 24, no. 9, 2002.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2002}, {"title": "Linear programming boosting via column generation", "author": ["A. Demiriz", "K.P. Bennett", "J. Shawe-Taylor"], "venue": "Mach. Learn., vol. 46, no. 1-3, pp. 225\u2013254, 2002.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2002}, {"title": "A direct formulation for totally-corrective multi-class boosting", "author": ["C. Shen", "Z. Hao"], "venue": "Proc. IEEE Conf. Comp. Vis. Patt. Recogn., 2011, pp. 2585\u20132592.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "On the algorithmic implementation of multiclass kernel-based vector machines", "author": ["K. Crammer", "Y. Singer"], "venue": "J. Mach. Learn. Res., vol. 2, pp. 265\u2013292, 2001.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2001}, {"title": "1-norm support vector machines", "author": ["J. Zhu", "S. Rosset", "T. Hastie", "R. Tibshirani"], "venue": "Proc. Adv. Neural Inf. Process. Syst., 2003.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}, {"title": "Sparseness of support vector machines", "author": ["I. Steinwart"], "venue": "J. Mach. Learn. Res., vol. 4, pp. 1071\u20131105, 2003.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2003}, {"title": "Multiclass learning with simplex coding", "author": ["Y. Mroueh", "T. Poggio", "L. Rosasco", "J.J. Slotine"], "venue": "Proc. Adv. Neural Inf. Process. Syst., 2012, http://arxiv.org/abs/1209.1360.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "Support vector machinery for infinite ensemble learning", "author": ["H.-T. Lin", "L. Li"], "venue": "J. Mach. Learn. Res., vol. 9, pp. 285\u2013312, 2008.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2008}, {"title": "Continuous neural networks", "author": ["N. Le Roux", "Y. Bengio"], "venue": "Int. Conf. Artificial Intelli. & Stat., 2007.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2007}, {"title": "Random features for large-scale kernel machines", "author": ["A. Rahimi", "B. Recht"], "venue": "Proc. Adv. Neural Inf. Process. Syst., 2007.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2007}, {"title": "Nystr\u00f6m method vs. random Fourier features: A theoretical and empirical comparison", "author": ["T. Yang", "Y.-F. Li", "M. Mahdavi", "R. Jin", "Z.-H. Zhou"], "venue": "Proc. Adv. Neural Inf. Process. Syst., 2012.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2012}, {"title": "Efficient classification for additive kernel SVMs", "author": ["S. Maji", "A.C. Berg", "J. Malik"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., 2012.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2012}, {"title": "Efficient additive kernels via explicit feature maps", "author": ["A. Vedaldi", "A. Zisserman"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., vol. 34, no. 3, 2012.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2012}, {"title": "LIBLINEAR: A library for large linear classification", "author": ["R.-E. Fan", "K.-W. Chang", "C.-J. Hsieh", "X.-R. Wang", "C.-J. Lin"], "venue": "J. Mach. Learn. Res., vol. 9, 2008.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2008}, {"title": "Improved boosting algorithms using confidence-rated predictions", "author": ["R.E. Schapire", "Y. Singer"], "venue": "Mach. Learn., vol. 37, no. 3, pp. 297\u2013336, 1999.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1999}, {"title": "Multiclass learning, boosting, and error-correcting codes", "author": ["V. Guruswami", "A. Sahai"], "venue": "Proc. Ann. Conf. Computat. Learn. Theory, 1999.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1999}, {"title": "The MOSEK interior point optimizer", "author": ["Mosek"], "venue": "http://www. mosek.com.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 0}, {"title": "The PASCAL visual object classes challenge 2007", "author": ["M. Everingham", "L. Van Gool", "C. Williams", "J. Winn", "A. Zisserman"], "venue": "2th PASCAL Challenge Workshop, 2007.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2007}, {"title": "LabelMe: A database and web-based tool for image annotation", "author": ["B. Russell", "A. Torralba", "K. Murphy", "W. Freeman"], "venue": "Int. J.  Comp. Vis., vol. 77, no. 1, pp. 157\u2013173, 2008.", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2008}, {"title": "Multimodal semisupervised learning for image classification", "author": ["M. Guillaumin", "J. Verbeek", "C. Schmid"], "venue": "Proc. IEEE Conf. Comp. Vis. Patt. Recogn., 2010, pp. 902\u2013909.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2010}, {"title": "Modeling the shape of the scene: A holistic representation of the spatial envelope", "author": ["A. Oliva", "A. Torralba"], "venue": "Int. J. Comp. Vis., vol. 42, no. 3, pp. 145\u2013175, 2001.", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2001}, {"title": "Sun database: Large-scale scene recognition from abbey to zoo", "author": ["J. Xiao", "J. Hays", "K. Ehinger", "A. Oliva", "A. Torralba"], "venue": "Proc. IEEE Conf. Comp. Vis. Patt. Recogn., 2010, pp. 3485\u2013 3492.", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2010}], "referenceMentions": [{"referenceID": 0, "context": "Ensemble learning methods, with a typical example being boosting [1]\u2013[5], have been successfully applied to many machine learning and computer vision applications.", "startOffset": 65, "endOffset": 68}, {"referenceID": 4, "context": "Ensemble learning methods, with a typical example being boosting [1]\u2013[5], have been successfully applied to many machine learning and computer vision applications.", "startOffset": 69, "endOffset": 72}, {"referenceID": 1, "context": "[2], and R\u00e4tsch et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6].", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6] developed a mechanism to convert SVM algorithms to boosting-like algorithms by translating the quadratic programs (QP) of SVMs into linear programs (LP) of boosting (similar to LPBoost [7]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[6] developed a mechanism to convert SVM algorithms to boosting-like algorithms by translating the quadratic programs (QP) of SVMs into linear programs (LP) of boosting (similar to LPBoost [7]).", "startOffset": 189, "endOffset": 192}, {"referenceID": 7, "context": "Following this vein, a direct approach to multi-class boosting was developed in [8] by using the loss function in Crammer and Singer\u2019s multi-class SVM [9].", "startOffset": 80, "endOffset": 83}, {"referenceID": 8, "context": "Following this vein, a direct approach to multi-class boosting was developed in [8] by using the loss function in Crammer and Singer\u2019s multi-class SVM [9].", "startOffset": 151, "endOffset": 154}, {"referenceID": 5, "context": "The recipe to transfer algorithms is essentially [6]: \u201cThe SV-kernel is replaced by an appropriately constructed hypothesis space for leveraging where the optimization of an analogous mathematical program is done using `1 instead of `2-norm.", "startOffset": 49, "endOffset": 52}, {"referenceID": 2, "context": "We suspect that this is due to the widely-adopted belief that boosting methods need the sparsity-inducing `1-norm regularization so that the final ensemble model only relies on a subset of weak learners [3], [6].", "startOffset": 203, "endOffset": 206}, {"referenceID": 5, "context": "We suspect that this is due to the widely-adopted belief that boosting methods need the sparsity-inducing `1-norm regularization so that the final ensemble model only relies on a subset of weak learners [3], [6].", "startOffset": 208, "endOffset": 211}, {"referenceID": 5, "context": "Unlike [6], [8], no mathematical transform is needed.", "startOffset": 7, "endOffset": 10}, {"referenceID": 7, "context": "Unlike [6], [8], no mathematical transform is needed.", "startOffset": 12, "endOffset": 15}, {"referenceID": 2, "context": "At each iteration, compared with the `1 optimization involved in the indirect approach [3], [6]\u2013[8], our optimization problems are much simpler.", "startOffset": 87, "endOffset": 90}, {"referenceID": 5, "context": "At each iteration, compared with the `1 optimization involved in the indirect approach [3], [6]\u2013[8], our optimization problems are much simpler.", "startOffset": 92, "endOffset": 95}, {"referenceID": 7, "context": "At each iteration, compared with the `1 optimization involved in the indirect approach [3], [6]\u2013[8], our optimization problems are much simpler.", "startOffset": 96, "endOffset": 99}, {"referenceID": 2, "context": "3) As the fully-corrective boosting methods in [3], [8], our", "startOffset": 47, "endOffset": 50}, {"referenceID": 7, "context": "3) As the fully-corrective boosting methods in [3], [8], our", "startOffset": 52, "endOffset": 55}, {"referenceID": 9, "context": "1At the same time, standard SVM needs `2 regularization so that the kernel trick can be applied, although `1 SVM [10] takes a different approach.", "startOffset": 113, "endOffset": 117}, {"referenceID": 10, "context": "Recall that the number of support vectors is linearly proportional to the number of training data [11].", "startOffset": 98, "endOffset": 102}, {"referenceID": 11, "context": "Additional contributions of this work include: 1) To exemplify the usefulness of this proposed framework, we introduce a new multiclass boosting method based on the recent multi-class SVM [12].", "startOffset": 188, "endOffset": 192}, {"referenceID": 1, "context": "The general connection between SVM and boosting has been discussed by a few researchers [2], [6] at a high level.", "startOffset": 88, "endOffset": 91}, {"referenceID": 5, "context": "The general connection between SVM and boosting has been discussed by a few researchers [2], [6] at a high level.", "startOffset": 93, "endOffset": 96}, {"referenceID": 0, "context": "Boosting has been extensively studied in the past decade [1]\u2013[3], [7], [8].", "startOffset": 57, "endOffset": 60}, {"referenceID": 2, "context": "Boosting has been extensively studied in the past decade [1]\u2013[3], [7], [8].", "startOffset": 61, "endOffset": 64}, {"referenceID": 6, "context": "Boosting has been extensively studied in the past decade [1]\u2013[3], [7], [8].", "startOffset": 66, "endOffset": 69}, {"referenceID": 7, "context": "Boosting has been extensively studied in the past decade [1]\u2013[3], [7], [8].", "startOffset": 71, "endOffset": 74}, {"referenceID": 2, "context": "Our methods are close to [3], [7] in that we also use column generation (CG) to select weak learners and fully-correctively update weak learners\u2019 coefficients.", "startOffset": 25, "endOffset": 28}, {"referenceID": 6, "context": "Our methods are close to [3], [7] in that we also use column generation (CG) to select weak learners and fully-correctively update weak learners\u2019 coefficients.", "startOffset": 30, "endOffset": 33}, {"referenceID": 12, "context": "If one uses an infinitely many weak learners in boosting [13] (or hidden units in neural networks [14]), the model is equivalent to SVM with a certain kernel.", "startOffset": 57, "endOffset": 61}, {"referenceID": 13, "context": "If one uses an infinitely many weak learners in boosting [13] (or hidden units in neural networks [14]), the model is equivalent to SVM with a certain kernel.", "startOffset": 98, "endOffset": 102}, {"referenceID": 5, "context": "Loosely speaking, boosting can be seen as explicitly computing the kernel mapping functions because, as pointed out in [6], a kernel constructed by the inner product of weak learners\u2019 outputs satisfies the Mercer\u2019s condition.", "startOffset": 119, "endOffset": 122}, {"referenceID": 14, "context": "Random Fourier features (RFF) [15] have been applied to large-scale kernel methods.", "startOffset": 30, "endOffset": 34}, {"referenceID": 15, "context": "show that RFF does not perform well due to its data-independent sampling strategy when there is a large gap in the eigen-spectrum of the kernel matrix [16].", "startOffset": 151, "endOffset": 155}, {"referenceID": 16, "context": "In [17], [18], it shows that for homogeneous additive kernels, the kernel mapping function can be exactly computed.", "startOffset": 3, "endOffset": 7}, {"referenceID": 17, "context": "In [17], [18], it shows that for homogeneous additive kernels, the kernel mapping function can be exactly computed.", "startOffset": 9, "endOffset": 13}, {"referenceID": 18, "context": ", LIBLINEAR [19].", "startOffset": 12, "endOffset": 16}, {"referenceID": 2, "context": "Next let us take LPBoost as an example to see how CG is used to explicitly learn weak learners, which is the core of most boosting methods [3], [7].", "startOffset": 139, "endOffset": 142}, {"referenceID": 6, "context": "Next let us take LPBoost as an example to see how CG is used to explicitly learn weak learners, which is the core of most boosting methods [3], [7].", "startOffset": 144, "endOffset": 147}, {"referenceID": 6, "context": "That is the main idea of LPBoost [7] and its extension [3].", "startOffset": 33, "endOffset": 36}, {"referenceID": 2, "context": "That is the main idea of LPBoost [7] and its extension [3].", "startOffset": 55, "endOffset": 58}, {"referenceID": 18, "context": "In our experiments, we have used LIBLINEAR [19].", "startOffset": 43, "endOffset": 47}, {"referenceID": 11, "context": "Having shown how to solve the standard SVM problem using CG, we provide another example application of the proposed framework by developing a new multi-class ensemble method using the idea of simplex coding [12].", "startOffset": 207, "endOffset": 211}, {"referenceID": 19, "context": "MO [20], AdaBoost.", "startOffset": 3, "endOffset": 7}, {"referenceID": 20, "context": "ECC [21].", "startOffset": 4, "endOffset": 8}, {"referenceID": 7, "context": "Shen and Hao proposed a direct approach to multi-class boosting in [8].", "startOffset": 67, "endOffset": 70}, {"referenceID": 11, "context": "Here we proffer a new multi-class ensemble learning method based on the simplex least-squares SVM (SLS-SVM) introduced in [12].", "startOffset": 122, "endOffset": 126}, {"referenceID": 6, "context": "The maximum iteration for AdaBoost, LPBoost [7] and our CGENS are searched from {25, 50, 100, 250, 500}.", "startOffset": 44, "endOffset": 47}, {"referenceID": 12, "context": "Results of SVMs with the stump kernel are also reported [13].", "startOffset": 56, "endOffset": 60}, {"referenceID": 14, "context": "In the second experiment, we compare our method (using 500 weak learners) against several other methods such as SVM using (1) perceptrons sign(\u03b8>x \u2212 \u03ba) as weak learners and the perceptron kernel for SVM, and (2) Fourier cosine functions [15] cos(\u03b8>x\u2212\u03ba) as weak learners and Gaussian RBF kernel for SVM.", "startOffset": 237, "endOffset": 241}, {"referenceID": 12, "context": "Instead, we sample 2000 pairs of {\u03b8, \u03ba} according to their distributions as described in [13] and [15], and then pick the one that maximizes the weak learner selection criterion in Equ.", "startOffset": 89, "endOffset": 93}, {"referenceID": 14, "context": "Instead, we sample 2000 pairs of {\u03b8, \u03ba} according to their distributions as described in [13] and [15], and then pick the one that maximizes the weak learner selection criterion in Equ.", "startOffset": 98, "endOffset": 102}, {"referenceID": 14, "context": "We have also compared our CGENS with RFF [15].", "startOffset": 41, "endOffset": 45}, {"referenceID": 21, "context": "We use the state-of-the-art commercial solver Mosek [22] to solve the dual problem (5).", "startOffset": 52, "endOffset": 56}, {"referenceID": 14, "context": "Fourier weak learner/RBF kernel Perceptron/Perceptron kernel RFF [15] SVM CGENS AdaBoost LPBoost SVM CGENS", "startOffset": 65, "endOffset": 69}, {"referenceID": 20, "context": "ECC [21] , AdaBoost.", "startOffset": 4, "endOffset": 8}, {"referenceID": 19, "context": "MH [20] and MultiBoost [8] using the exponential loss.", "startOffset": 3, "endOffset": 7}, {"referenceID": 7, "context": "MH [20] and MultiBoost [8] using the exponential loss.", "startOffset": 23, "endOffset": 26}, {"referenceID": 7, "context": "The regularization parameters in our CGENS-SLS and MultiBoost [8] are both determined by 5fold cross validation.", "startOffset": 62, "endOffset": 65}, {"referenceID": 22, "context": "Image classification We then apply the proposed CGENS-SLS for image classification on several datasets: PASCAL07 [23], LabelMe [24] and CIFAR10.", "startOffset": 113, "endOffset": 117}, {"referenceID": 23, "context": "Image classification We then apply the proposed CGENS-SLS for image classification on several datasets: PASCAL07 [23], LabelMe [24] and CIFAR10.", "startOffset": 127, "endOffset": 131}, {"referenceID": 24, "context": "For PASCAL07, we use 5 types of features provided in [25].", "startOffset": 53, "endOffset": 57}, {"referenceID": 25, "context": "For LabelMe, we use the LabelMe-12-50k subset and generate the GIST [26] features.", "startOffset": 68, "endOffset": 72}, {"referenceID": 6, "context": "2: Training time of LPBoost [7] and our CGENS in log-scale.", "startOffset": 28, "endOffset": 31}, {"referenceID": 25, "context": "use the GIST [26] features and use the provided test and training sets.", "startOffset": 13, "endOffset": 17}, {"referenceID": 7, "context": "MH MultiBoost [8] CGENS-SLS wine\u2217 3.", "startOffset": 14, "endOffset": 17}, {"referenceID": 26, "context": "HOG features described in [27] are used as the image feature.", "startOffset": 26, "endOffset": 30}, {"referenceID": 7, "context": "MH and MultiBoost [8].", "startOffset": 18, "endOffset": 21}], "year": 2014, "abstractText": "Ensemble methods such as boosting combine multiple learners to obtain better prediction than could be obtained from any individual learner. Here we propose a principled framework for directly constructing ensemble learning methods from kernel methods. Unlike previous studies showing the equivalence between boosting and support vector machines (SVMs), which needs a translation procedure, we show that it is possible to design boosting-like procedure to solve the SVM optimization problems. In other words, it is possible to design ensemble methods directly from SVM without any middle procedure. This finding not only enables us to design new ensemble learning methods directly from kernel methods, but also makes it possible to take advantage of those highlyoptimized fast linear SVM solvers for ensemble learning. We exemplify this framework for designing binary ensemble learning as well as a new multi-class ensemble learning methods. Experimental results demonstrate the flexibility and usefulness of the proposed framework.", "creator": "LaTeX with hyperref package"}}}