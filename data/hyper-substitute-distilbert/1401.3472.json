{"id": "1401.3472", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Jan-2014", "title": "Variable Forgetting in Reasoning about Knowledge", "abstract": "completing this conclusion, psychologists investigate knowledge reasoning within both simple framework above knowledge structure. teams investigate variable forgetting : a basic trait for this individual to reason about we own the other agents \\ knowledge. in our framework, two tasks \u2013 data \\ logical variables and the weakest sufficient condition play symbolic roles in knowledge reasoning. given a valid knowledge base utilizing a set of observable variables from each agent, first show that simple notion of an agent knowing formula formula have be proven as a somewhat sufficient condition of data formula under background description base. moreover, we mention how computers capture the notion on common knowledge theory using a generalized notion entitled explicitly required position. whereas, we show that effective policy operator can simply conveniently dealt aloud in our method of knowledge binding. further, we explore the computational value of finding problem solving an epistemic belief succeeds realized in a public structure. in numerical group theory, this definition starts pspace - hard ; however, for some cognitive subcases, it, be reduced to co - workers. finally, we discuss possible penetration of our language into some interesting domains such as mathematical phylogenetic analysis of new well - done identities web puzzle and routine validation of later revised hirsch - schroeder structure. another believe and there are many scenarios where mistakenly assumed choice of the information identity y knowledge is under explicit rule against a knowledge pattern. what makes data hard compared with the empirical multi - agent s5 kripke structure is but it often be much more succinct.", "histories": [["v1", "Wed, 15 Jan 2014 05:29:17 GMT  (319kb)", "http://arxiv.org/abs/1401.3472v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["kaile su", "abdul sattar", "guanfeng lv", "yan zhang"], "accepted": false, "id": "1401.3472"}, "pdf": {"name": "1401.3472.pdf", "metadata": {"source": "CRF", "title": "Variable Forgetting in Reasoning about Knowledge", "authors": ["Kaile Su", "Abdul Sattar", "Guanfeng Lv", "Yan Zhang"], "emails": ["sukl@pku.edu.cn", "a.sattar@griffith.edu.au", "lvgf@yahoo.com", "yan@cit.uws.edu.au"], "sections": [{"heading": "1. Introduction", "text": "Epistemic logics, or logics of knowledge are usually recognized as having originated in the work of Jaakko Hintikka - a philosopher who showed how certain modal logics could be used to capture intuitions about the nature of knowledge in the early 1960s (Hintikka,\nc\u00a92009 AI Access Foundation. All rights reserved.\n1962). In the mid of 1980s, Halpern and his colleagues discovered that S5 epistemic logics could be given a natural interpretation in terms of the states of processes (commonly called agents) in a distributed system. This model now is known as the interpreted system model (Fagin, Halpern, Moses, & Vardi, 1995). It was found that this model plays an important role in the theory of distributed systems and has been applied successfully in reasoning about communication protocols (Halpern & Zuck, 1992). However, the work on epistemic logic has mainly focused on theoretical issues such as variants of modal logic, completeness, computational complexity, and derived notions like distributed knowledge and common knowledge.\nIn this paper, we explore knowledge reasoning within a more concrete model of knowledge. Our framework of reasoning about knowledge is simple and powerful enough to analyze realistic protocols such as some widely used security protocols.\nTo illustrate the problem investigated in this paper, let us consider the communication scenario that Alice sends Bob a message and Bob sends Alice an acknowledgement when receiving the message. We assume Alice and Bob commonly have the following background knowledge base \u0393CS :\nBob recv msg \u21d2 Alice send msg Bob send ack \u21d2 Bob recv msg Alice recv ack \u21d2 Bob send ack\nwhere Bob recv msg and Bob send ack are observable variables to Bob, while Alice send msg and Alice recv ack are observable to Alice.\nThe problem we are concerned with is how to verify that Alice or Bob knows a statement \u03d5. Intuitively, we should be able to prove that for a statement observable to Alice (Bob), Alice (Bob) knows the statement if and only if the statement itself holds. As for the knowledge of non-observable statements, the following should hold:\n1. Alice knows Bob recv msg if Alice recv ack holds; on the other hand, if Alice knows Bob recv msg, then Alice recv ack holds, which means that, in the context of this example, the only way that Alice gets to know Bob recv msg is that Alice receives the acknowledgement from Bob.\n2. Bob knows Alice send msg if Bob recv msg holds; moreover, if Bob knows Alice send msg, then Bob recv msg holds. The latter indicates that the only way that Bob gets to know Alice send msg is that Bob receives the message from Alice.\n3. Finally, Bob does not know Alice recv ack.\nThe idea behind the presented knowledge model for those scenarios demonstrated above is that an agent\u2019s knowledge is just the agent\u2019s observations or logical consequences of the agent\u2019s observations under the background knowledge base.\nOne of the key notions introduced in this paper is agents\u2019 observable variables. This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003). Informally speaking, local propositions are those depending only upon an agent\u2019s local information; and an agent can always determine whether a given local proposition is true. Local variables\nare those primitive propositions that are local. Nevertheless, the notion of local propositions (Engelhardt et al., 1998, 2003) is a semantics property of the truth assignment function in a Kripke structure, while the notion of local variables (van der Hoek & Wooldridge, 2002) is a property of syntactical variables. In this paper, we prefer to use the term \u201cobservable variable\u201d in order to avoid any confusion with the term \u201clocal variable\u201d used in programming, where \u201cnon-local variables\u201d such as \u201cglobal variables\u201d may often be observable.\nOur knowledge model is also closely related to the notion of weakest sufficient condition, which was first formalized by Lin (2001). Given a background knowledge base \u0393 and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula \u03d5 can be defined as the weakest sufficient condition of \u03d5 over Oi under \u0393, which can be computed via the operation of variable forgetting (Lin & Reiter, 1994) or eliminations of middle terms (Boole, 1854). Moreover, we generalize the notion of weakest sufficient condition and capture the notion of common knowledge.\nNow we briefly discuss the role of variable forgetting in our knowledge model. Let us examine the scenario described above again. Consider the question: how can Alice figure out Bob\u2019s knowledge when she receives the acknowledgement from Bob? Note that Alice\u2019s knowledge is the conjunction of the background knowledge base \u0393CS and her observations Alice recv ack etc. Moreover, all Alice knows about Bob\u2019s knowledge is the conjunction of the background knowledge base \u0393CS and all she knows about Bob\u2019s observations. Thus, Alice gets Bob\u2019s knowledge by computing all she knows about Bob\u2019s observations. In our setting, Alice gets her knowledge on Bob\u2019s observations simply by forgetting Bob\u2019s nonobservable variables in her own knowledge.\nThere is a recent trend of extending epistemic logics with dynamic operators so that the evolution of knowledge can be expressed (van Benthem, 2001; van Ditmarsch, van der Hoek, & Kooi, 2005a). The most basic extension is public announcement logic (PAL), which is obtained by adding an operator for truthful public announcements (Plaza, 1989; Baltag, Moss, & Solecki, 1998; van Ditmarsch, van der Hoek, & Kooi, 2005b). We show that public announcement operator can be conveniently dealt with via our notion of knowledge structure. This makes the notion of knowledge structure genuinely useful for those applications like the automated analysis of the well-known muddy children puzzle.\nFrom the discussion above, we can see that our framework of reasoning about knowledge is appropriate in those situations where every agent has a specified set of observable variables. To further show the significance of our framework, we investigate some of its interesting applications to the automated analysis of the well-known muddy children puzzle and the verification of the revised Needham-Schroeder protocol (Lowe, 1996).\nWe believe that there are many scenarios where the natural presentation of the available information about knowledge is under the form of a knowledge structure. What makes it valuable compared with the corresponding multi-agent S5 Kripke structure is that it can be much more succinct. Of course, the price to pay is that determining whether a formula holds in a knowledge structure is PSPACE-hard in the general case, while it is in PTIME when the corresponding S5 Kripke structure is taken as input. However, the achieved trade-off between time and space can prove computationally valuable. In particular, the validity problem from a knowledge structure can be addressed for some instances for which generating the corresponding Kripke structure would be unfeasible. The muddy children puzzle shows this point clearly: generating the corresponding Kripke structure is impossible\nfrom a practical point of view, even for the least number of children considered in the experiments.\nThe organization of this paper is as follows. In the next section, we briefly introduce the concept of forgetting and the notion of weakest sufficient and strongest necessary conditions. In Section 3, we define our framework of reasoning about knowledge via variable forgetting. In Section 4, we generalize the notion of weakest sufficient condition and strongest necessary condition to capture common knowledge within our framework. In Section 5, we show that public announcement operator can also be conveniently dealt with via our notion of knowledge structure. Section 6 discusses the computational complexity issue about the problem of whether an epistemic formula is realized in a knowledge structure. In the general case, this problem is PSPACE-hard; however, for some interesting subcases, it can be reduced to co-NP. In Section 7, we consider a case study by applying our framework to model the well known muddy children puzzle; and further more to security protocol verification in Section 8. Finally, we discuss some related work and conclude the paper with some remarks."}, {"heading": "2. Preliminaries", "text": "In this section, we provide some preliminaries about the notions of variable forgetting and weakest sufficient condition, and epistemic logic."}, {"heading": "2.1 Forgetting", "text": "Given a set of propositional variables P , we identify a truth assignment over P with a subset of P . We say a formula \u03d5 is a formula over P if each propositional variable occurring in \u03d5 is in P . For convenience, we define true as an abbreviation for a fixed valid propositional formula, say p \u2228 \u00acp, where p is primitive proposition in P . We abbreviate \u00actrue by false.\nWe also use |= to denote the usual satisfaction relation between a truth assignment and a formula. Moreover, for a set of formulas \u0393 and a formula \u03d5, we use \u0393 |= \u03d5 to denote that for every assignment \u03c3, if \u03c3 |= \u03b1 for all \u03b1 \u2208 \u0393, then \u03c3 |= \u03d5.\nGiven a propositional formula \u03d5, and a propositional variable p, we denote by \u03d5( ptrue) the result of replacing every p in \u03d5 by true. We define \u03d5( pfalse) similarly.\nThe notion of variable forgetting (Lin & Reiter, 1994), or eliminations of middle terms (Boole, 1854), can be defined as follows:\nDefinition 1 Let \u03d5 be a formula over P , and V \u2286 P . The forgetting of V in \u03d5 , denoted as \u2203V \u03d5, is a quantified formula over P , defined inductively as follows:\n1. \u2203\u2205\u03d5 = \u03d5; 2. \u2203{p}\u03d5 = \u03d5 ( ptrue ) \u2228 \u03d5 ( pfalse ) ;\n3. \u2203(V \u222a {p})\u03d5 = \u2203V (\u2203{p}\u03d5). For convenience, we use \u2200V \u03d5 to denote \u00ac\u2203V (\u00ac\u03d5).\nExample 2: Let \u03d5 = (p \u2228 q) \u2227 (\u00acp \u2228 r). We have \u2203{p}\u03d5 \u2261 (q \u2228 r) and \u2203{q}\u03d5 \u2261 (\u00acp \u2228 r). 2\nMany characterizations of variable forgetting, together with complexity results, are reported in the work of Lang and Marquis (1998). In particular, the notion of variable forgetting is closely related to that of formula-variable independence (Lang, Liberatore, & Marquis, 2003).\nDefinition 3 Let \u03d5 be a propositional formula, and V a set of propositional variables. We say \u03d5 is independent from V if and only if \u03d5 is logically equivalent to a formula in which none of the variables in V appears.\nThe following proposition was given in the work of Lang, Liberatore and Marquis (2003).\nProposition 4 Let \u03d5 be a propositional formula, and V a set of propositional variables. Then \u2203V \u03d5 is the logically strongest consequence of \u03d5 that is independent from V (up to logical equivalence)."}, {"heading": "2.2 Weakest Sufficient Conditions", "text": "The formal definitions of weakest sufficient conditions and strongest necessary conditions were first formalized via the notion of variable forgetting by Lin (2001), which in turn play an essential role in our approach.\nDefinition 5 Let V be a set of propositional variables and V \u2032 \u2286 V . Given a set of formulas \u0393 over V as a background knowledge base and a formula \u03b1 over V .\n\u2022 A formula \u03d5 over V \u2032 is called a sufficient condition of \u03b1 over V \u2032 under \u0393 if \u0393 |= \u03d5 \u21d2 \u03b1. It is called a weakest sufficient condition of \u03b1 over V \u2032 under \u0393 if it is a sufficient condition of \u03b1 over V \u2032 under \u0393, and for any sufficient condition \u03d5\u2032 of \u03b1 on V \u2032 under \u0393, we have \u0393 |= \u03d5\u2032 \u21d2 \u03d5.\n\u2022 A formula \u03d5 over V \u2032 is called a necessary condition of \u03b1 over V \u2032 under \u0393 if \u0393 |= \u03b1 \u21d2 \u03d5. It is called a strongest necessary condition of \u03b1 over V \u2032 under \u0393 if it is a necessary condition of \u03b1 over V \u2032 under \u0393, and for any necessary condition \u03d5\u2032 of \u03b1 over V \u2032 under \u0393, we have \u0393 |= \u03d5 \u21d2 \u03d5\u2032.\nThe notions given above are closely related to theory of abduction. Given an observation, there may be more than one abduction conclusion that we can draw. It should be useful to find the weakest one of such conclusions, i.e., the weakest sufficient condition of the observation (Lin, 2001). The notions of strongest necessary and weakest sufficient conditions of a proposition also have many potential applications in other areas such as reasoning about actions. The following proposition, which is due to Lin (2001), shows how to compute the two conditions.\nProposition 6 Given a background knowledge base {\u03b8} over V , a formula \u03b1 over V , and a subset V \u2032 of V . Let SNC\u03b1 and WSC\u03b1 be a strongest necessary condition and a weakest sufficient condition of \u03b1 over V \u2032 under {\u03b8} respectively. Then\n\u2022 WSC\u03b1 is equivalent to \u2200(V \u2212 V \u2032)(\u03b8 \u21d2 \u03b1); and \u2022 SNC\u03b1 is equivalent to \u2203(V \u2212 V \u2032)(\u03b8 \u2227 \u03b1)."}, {"heading": "2.3 Epistemic Logic and Kripke Structure", "text": "We now recall some standard concepts and notations related to the modal logics for multiagents\u2019 knowledge.\nGiven a set V of propositional variables. Let L(V ) be the set of all propositional formulas on V . The language of epistemic logic, denoted by Ln(V ), is L(V ) augmented with modal operator Ki for each agent i. Ki\u03c6 can be read \u201cagent i knows \u03c6 \u201d. Let LCn (V ) be the language of Ln(V ) augmented with modal operator C\u2206 for each set of agents \u2206. A formula C\u2206\u03b1 indicates that it is common knowledge among agents in \u2206 that \u03b1 holds. We omit the argument V and write Ln and LCn , if it is clear from context.\nAccording to the paper by Halpern and Moses (1992), semantics of these formulas can be given by means of Kripke structure (Kripke, 1963), which formalizes the intuition behind possible worlds. A Kripke structure is a tuple (W,\u03c0,K1, \u00b7 \u00b7 \u00b7 ,Kn), where W is a set of worlds, \u03c0 associates with each world a truth assignment to the propositional variables, so that \u03c0(w)(p) \u2208 {true, false} for each world w and propositional variable p, and K1, \u00b7 \u00b7 \u00b7 ,Kn are binary accessibility relations. By convention, WM , KMi and \u03c0M are used to refer to the set W of possible worlds, the Ki relation and the \u03c0 function in the Kripke structure M , respectively. We omit the superscript M if it is clear from context. Finally, let C\u2206 be the transitive closure of \u22c3 i\u2208\u2206Ki.\nA situation is a pair (M, w) consisting of a Kripke structure and a world w in M . By using situations, we can inductively give semantics to formulas as follows: for primitive propositions p,\n(M, w) |= p iff \u03c0M (w)(p) = true.\nConjunctions and negations are dealt with in the standard way. Finally, (M, w) |= Ki\u03b1 iff for all w\u2032 \u2208 W such that wKMi w\u2032, we have that (M, w\u2032) |= \u03b1; and (M, w) |= C\u2206\u03b1 iff for all w\u2032 \u2208 W such that wCM\u2206 w\u2032, we have that (M, w\u2032) |= \u03b1. We say a formula \u03b1 is satisfiable in Kripke structure M if (M, w) |= \u03b1 for some possible world w in Kripke structure M . A Kripke structure M is called an S5n Kripke structure if, for every i, KMi is an equivalence relation. A Kripke structure M is called a finite Kripke structure if the set of possible worlds is finite. According to the work of Halpern and Moses (1992), we have the following lemma.\nLemma 7 If a formula is satisfiable in an S5n Kripke structure, then so is in a finite S5n Kripke structure."}, {"heading": "3. Knowledge and Weakest Sufficient Conditions", "text": "In our framework, a knowledge structure is a simple model of reasoning about knowledge. The advantage of this model is, as will be shown later, that agents\u2019 knowledge can be computed via the operation of variable forgetting."}, {"heading": "3.1 Knowledge Structure", "text": "Definition 8 A knowledge structure F with n-agents is a (n + 2)-tuple (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On) where (1) V is a set of propositional variables; (2) \u0393 is a consistent set of propositional formulas over V ; and (3) for each agent i, Oi \u2286 V .\nThe variables in Oi are called agent i\u2019s observable variables. An assignment that satisfies \u0393 is called a state of knowledge structure F . Given a state s of F , we define agent i\u2019s local state at state s as s \u2229Oi. Two knowledge structures are said to be equivalent if they have the same set of propositional variables, the same set of states and, for each agent i, the same set of agent i\u2019s observable variables.\nA pair (F , s) of knowledge structure F and a state s of F is called a scenario. Given a knowledge structure (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On) and a set V of subsets of V , we use EV to denote a relation between two assignments s, s\u2032 on V satisfying \u0393 such that (s, s\u2032) \u2208 EV iff there exists a P \u2208 V with s \u2229 P = s\u2032 \u2229 P . We use E\u2217V to denote the transitive closure of EV .\nLet V\u2206 = {Oi | i \u2208 \u2206}. We then have that (s, s\u2032) \u2208 EV\u2206 iff there exists an i \u2208 \u2206 with s \u2229Oi = s\u2032 \u2229Oi.\nA simple instance of knowledge structure is F0 = ({p, q}, {p \u21d2 q}, {p}, {q}), where p, q are propositional variables. There are two agents for knowledge structure F0. Variables p and q are observable to agents 1 and 2, respectively. We have that V{1,2} = {{p}, {q}}; and for any two subsets s and s\u2032 of {p, q} that satisfy p \u21d2 q, we have that (s, s\u2032) \u2208 E\u2217V{1,2} .\nWe now give the semantics of language LCn based on scenarios.\nDefinition 9 The satisfaction relationship |= between a scenario (F , s) and a formula \u03d5 is defined by induction on the structure of \u03d5.\n1. For each propositional variable p, (F , s) |= p iff s |= p. 2. For any formulas \u03b1 and \u03b2, (F , s) |= \u03b1 \u2227 \u03b2 iff (F , s) |= \u03b1 and (F , s) |= \u03b2; and\n(F , s) |= \u00ac\u03b1 iff not (F , s) |= \u03b1. 3. (F , s) |= Ki\u03b1 iff for all s\u2032 of F such that s\u2032 \u2229Oi = s \u2229Oi, (F , s\u2032) |= \u03b1. 4. (F , s) |= C\u2206\u03b1 iff (F , s\u2032) |= \u03b1 for all s\u2032 of F such that (s, s\u2032) \u2208 E\u2217V\u2206 .\nWe say that a proposition formula in L(V ) is i-local if it is over Oi. Clearly, agent i knows an i-local formula \u03d5 in F iff \u0393 |= \u03d5.\nLet F = (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On) be a knowledge structure. We say that a formula \u03b1 is realized in knowledge structure F , if for every state s of F , (F , s) |= \u03b1. For convenience, by F |= \u03b1, we denote formula \u03b1 is realized in knowledge structure F .\nWe conclude this subsection by the following lemma, which will be used in the remains of this paper.\nLemma 10 Let V be a finite set of variables, F = (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On) be a knowledge structure, and s be a state of F . Also suppose that \u2206 \u2286 {1, \u00b7 \u00b7 \u00b7 , n}, and V\u2206 = {Oi | i \u2208 \u2206}. Then\n1. for any objective formula \u03c8 (i.e., propositional formula over V ), (F , s) |= \u03c8 iff s |= \u03c8; 2. for any formula \u03b3 \u2208 \u0393, (F , s) |= \u03b3; 3. for any i-local formula \u03b2, (F , s) |= Ki\u03b2 \u21d4 \u03b2; 4. for any formula \u03b2, if there exists, for each i \u2208 \u2206, an i-local formula logically equivalent\nto \u03b2 under \u0393, then (F , s) |= C\u2206\u03b2 \u21d4 \u03b2; 5. for any formulas \u03b11 and \u03b12, (F , s) |= Ki(\u03b11 \u21d2 \u03b12) \u21d2 (Ki\u03b11 \u21d2 Ki\u03b12); 6. for any formulas \u03b11 and \u03b12, (F , s) |= C\u2206(\u03b11 \u21d2 \u03b12) \u21d2 (C\u2206\u03b11 \u21d2 C\u2206\u03b12); 7. for any formula \u03b1 and i \u2208 \u2206, (F , s) |= C\u2206\u03b1 \u21d2 KiC\u2206\u03b1.\nProof:\n1. The first item of this proposition can be proved by induction on the structure of \u03c8. When \u03c8 is a primitive proposition, it is done by the first item of Definition 9. When \u03c8 is of the form of negation or conjunction, the conclusion also follows immediately by the first item of Definition 9.\n2. The second item of this proposition can be proved by the first item and the fact s satisfies \u0393.\n3. Given an i-local formula \u03b2, it suffices to show (F , s) |= Ki\u03b2 iff (F , s) |= \u03b2. By the first item of this proposition, we have that (F , s) |= \u03b2 iff s |= \u03b2. Moreover, as \u03b2 is i-local or over Oi, for all assignments s\u2032 with s\u2032 \u2229 Oi = s \u2229 Oi, we have that s\u2032 |= \u03b2 iff s |= \u03b2. Therefore, we get the following three \u201ciff\u201ds: (F , s) |= Ki\u03b2 iff, for all state s\u2032 of F with s\u2032 \u2229 Oi = s \u2229 Oi, we have that (F , s\u2032) |= \u03b2 iff, for all state s\u2032 of F with s\u2032 \u2229Oi = s \u2229Oi, we have that s\u2032 |= \u03b2 iff s |= \u03b2. Thus, (F , s) |= Ki\u03b2 iff (F , s) |= \u03b2.\n4. Suppose that, for each i \u2208 \u2206, there exists an i-local formula logically equivalent to \u03b2 under \u0393. We need to show (F , s) |= C\u2206\u03b2 \u21d4 \u03b2. First, because (s, s) \u2208 EV\u2206 \u2286 E\u2217V\u2206 , for all formula \u03b1, we have that (F , s) |= C\u2206\u03b1 implies (F , s) |= \u03b1. Therefore, it suffices to prove that (F , s) |= \u03b2 \u21d2 C\u2206\u03b2. Assume (F , s) |= \u03b2. To prove that (F , s) |= C\u2206\u03b2, we need to show that for every assignment s\u2032 such that (s, s\u2032) \u2208 E\u2217V\u2206 , (F , s\u2032) |= \u03b2. From the definition of E\u2217V\u2206 , it suffices to show that for every finite sequence of assignments s0, \u00b7 \u00b7 \u00b7 , sk with s0 = s and (sj , sj+1) \u2208 EV\u2206 (0 \u2264 j < k), we have that for every j \u2264 k, (F , sj) |= \u03b2. We show this by induction on j. When j = 0, the result is clearly true. Assume (F , sj) |= \u03b2. Now we prove (F , sj+1) |= \u03b2. Because (sj , sj+1) \u2208 EV\u2206 , there is an i \u2208 \u2206 such that Oi \u2229 sj = Oi \u2229 sj+1. On the other hand, we have that sj |= \u03b2 iff sj+1 |= \u03b2 because \u03b2 is equivalent under \u0393 to an i-local formula. Hence, (F , sj+1) |= \u03b2 as desired.\n5. It suffice to show that if (F , s) |= Ki(\u03b11 \u21d2 \u03b12) and (F , s) |= Ki\u03b11, then (F , s) |= Ki\u03b12. Assume that (F , s) |= Ki(\u03b11 \u21d2 \u03b12) and (F , s) |= Ki\u03b11, by item 3 of Definition 9 we get that, for all s\u2032 of F with s\u2032 \u2229Oi = s \u2229Oi, we have (F , s\u2032) |= (\u03b11 \u21d2 \u03b12) and (F , s\u2032) |= \u03b11. However, by item 2 of Definition 9, we get (F , s\u2032) |= \u03b12 from (F , s\u2032) |= (\u03b11 \u21d2 \u03b12) and (F , s\u2032) |= \u03b11. Therefore, we get that, for all s\u2032 of F with s\u2032 \u2229Oi = s \u2229Oi, we have (F , s\u2032) |= \u03b12. It follows immediately that (F , s) |= Ki\u03b12.\n6. This item can be shown in the same way as in the proof of item 5.\n7. It suffices to prove that for those state s\u2032\u2032 such that there is a state s\u2032 with s \u2229 Oi = s\u2032 \u2229Oi and s\u2032E\u2217V\u2206s\u2032\u2032, we can get sE\u2217V\u2206s\u2032\u2032, which follows immediately from the fact thatE\u2217V\u2206 is the transitive closure of EV\u2206 . 2"}, {"heading": "3.2 Relationship with S5 Kripke Structure", "text": "Given a knowledge structure F = (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On), let M(F) be Kripke structure (W,\u03c0,K1, \u00b7 \u00b7 \u00b7 ,Kn), where\n1. W is the set of all states of F ; 2. for each w \u2208 W , the assignment \u03c0(w) is the same as w; and 3. for each agent i and assignments w, w\u2032 \u2208 W , we have that wKiw\u2032 iff w\u2229Oi = w\u2032 \u2229Oi. The following proposition indicates that a knowledge structure can be viewed as a spe-\ncific Kripke structure.\nProposition 11 Given a knowledge structure F , a state s of F , and a formula \u03b1 in LCn (V ), we have that (F , s) |= \u03b1 iff (M(F), s) |= \u03b1. Proof: Immediately by the definition of the satisfaction relationship between a scenario and a formula and that between a situation and a formula. 2\nFrom Proposition 11, we conclude that if a formula in LCn is satisfiable in some knowledge structure, then the formula is also satisfiable in some Kripke structure. From the following proposition and Lemma 7, we can get that if a formula in LCn is satisfiable in some Kripke structure, then the formula is also satisfiable in some knowledge structure.\nProposition 12 For a finite S5n Kripke structure M with the propositional variable set V and possible world w in M , there exists a knowledge structure FM and a state sw of F such that, for every formula \u03b1 \u2208 LCn (V ), we have that (FM , sw) |= \u03b1 iff (M, w) |= \u03b1.\nProof: Let M = (W,\u03c0, R1, \u00b7 \u00b7 \u00b7 , Rn), where W is a finite set and R1, \u00b7 \u00b7 \u00b7 , Rn are equivalence relations. Let O1, \u00b7 \u00b7 \u00b7 , On be sets of new propositional variables such that\n1. O1, \u00b7 \u00b7 \u00b7 , On are finite and pairwise disjoint; and 2. for each i (0 < i \u2264 n), the number of all subsets of Oi is not less than that of all\nequivalence classes of Ri.\nBy the latter condition, there is, for each i, a function gi: W 7\u2192 2Oi such that for all w1, w2 \u2208 W , gi(w1) and gi(w2) are the same subset of Oi iff w1 and w2 are in the same equivalence class of Ri.\nLet V \u2032 = V \u222a\u22c30<i\u2264n Oi. We define a function g : W 7\u2192 2V \u2032 as follows. For each possible\nworld w in W , g(w) = {v \u2208 V | \u03c0(w)(v) = true} \u222a \u22c3\n0<i\u2264n gi(w).\nThe following two claims hold:\nC1 For all w1, w2 \u2208 W , and i (0 < i \u2264 n), we have that g(w1) \u2229 Oi = g(w2) \u2229 Oi iff w1Riw2.\nC2 For all w \u2208 W and v \u2208 V , we have that v \u2208 g(w) iff \u03c0(w)(v) = true. Let\n\u0393M = {\u03b1 | \u03b1 is over V \u2032, and g(w) |= \u03b1 for all w \u2208 W}. We then get the knowledge structure\nFM = (V \u2032,\u0393M , O1, \u00b7 \u00b7 \u00b7 , On).\nWe now show the following claim:\nC3 For every s \u2286 V \u2032, s is a state of FM iff s = g(w) for some w \u2208 W. The \u201cif\u201d part of claim C3 is easy to prove. If s = g(w\u2032) for some w\u2032 \u2208 W , then by the definition of \u0393M , we have that g(w\u2032) |= \u0393M and hence g(w\u2032) is a state of FM . To show the \u201conly if\u201d part, assume that for every w \u2208 W , s 6= g(w). Then, for every w \u2208 W , there exists \u03b1w over V \u2032 such that s |= \u03b1w but g(w) |= \u00ac\u03b1w. Therefore, s |= \u2227 w\u2208W \u03b1w.\nMoreover, we have that, for every w\u2032 \u2208 W , g(w\u2032) |= \u2228w\u2208W \u00ac\u03b1w, and hence \u2228\nw\u2208W \u00ac\u03b1w \u2208 \u0393M . Consequently, we have that s 6|= \u0393M and hence s is not a state of FM .\nTo complete the proof, it suffices to show, for every \u03b1 \u2208 LCn (V ), that (FM , g(w)) |= \u03b1 iff (M, w) |= \u03b1. With conditions C1, C2 and C3, we can do so by induction on \u03b1. For the base case, we assume \u03b1 is a propositional variable, say p. Then, by condition C2, we have that (FM , g(w)) |= p iff p \u2208 g(w) iff \u03c0(w)(p) = true iff (M, w) |= p.\nSuppose that \u03b1 is not a propositional variable and the claim holds for every subformula of \u03b1. There are three cases:\n1. \u03b1 is of form \u00ac\u03b2 or \u03b2 \u2227 \u03b3. This case can be dealt with by the definitions of satisfaction relations directly.\n2. \u03b1 is of form Ki\u03b2. In this case, we have (FM , g(w)) |= Ki\u03b2 iff (FM , s) |= \u03b2 for all states s of FM with g(w) \u2229Oi = s \u2229Oi. By condition C3, we have that (FM , g(w)) |= Ki\u03b2 iff (FM , g(w\u2032)) |= \u03b2 for all w\u2032 \u2208 W with g(w) \u2229 Oi = g(w\u2032) \u2229 Oi. By condition C1, we then have (FM , g(w)) |= Ki\u03b2 iff (FM , g(w\u2032)) |= \u03b2 for all w\u2032 \u2208 W with wRiw\u2032. Therefore, by the induction assumption, we have (FM , g(w)) |= Ki\u03b2 iff (M, w\u2032) |= \u03b2 for all w\u2032 \u2208 W with wRiw\u2032. The right part is just (M, w) |= Ki\u03b2.\n3. \u03b1 is of form C\u2206\u03b2. Recall that, for arbitrary two states s and s\u2032 of FM , (s, s\u2032) \u2208 EV\u2206 iff there exists an i \u2208 \u2206 with s \u2229Oi = s\u2032 \u2229Oi. By condition C1, for all w1, w2 \u2208 W ,\n(g(w1), g(w2)) \u2208 EV\u2206 iff (w1, w2) \u2208 \u22c3\ni\u2208\u2206 Ri.\nAs E\u2217V\u2206 is the transitive closure of EV\u2206 , and CM\u2206 is that of \u22c3\ni\u2208\u2206 Ri, by condition C3 we get that (g(w1), g(w2)) \u2208 E\u2217V\u2206 iff (w1, w2) \u2208 CM\u2206 for all w1, w2 \u2208 W .\nWe want to show that (FM , g(w)) |= C\u2206\u03b2 iff (M, w) |= C\u2206\u03b2. On one hand, (FM , g(w)) |= C\u2206\u03b2 iff for all states s of FM with (g(w), s) \u2208 E\u2217V\u2206 , (FM , s) |= \u03b2. By condition C3, we have that (FM , g(w)) |= C\u2206\u03b2 iff for all w\u2032 \u2208 W with (g(w), g(w\u2032)) \u2208 E\u2217V\u2206 . On the other hand, (M, w) |= C\u2206\u03b2 iff for all w\u2032 \u2208 W with (w, w\u2032) \u2208 CM\u2206 . Therefore, we conclude that (FM , g(w)) |= C\u2206\u03b2 iff (M, w) |= C\u2206\u03b2 by the above discussion. 2\nPropositions 11 and 12 show that the satisfiability issue for a formula in the language of multi-agent S5 with the common knowledge modality is the same whatever satisfiability is meant w.r.t. a standard Kripke structure or w.r.t. a knowledge structure."}, {"heading": "3.3 Knowledge as Weakest Sufficient Conditions", "text": "The following theorem establishes a bridge between the notion of knowledge and the notion of weakest sufficient and strongest necessary conditions.\nTheorem 13 Let V be a finite set of variables, F = (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On) a knowledge structure, \u03b1 a propositional formula in L(V ), and for an agent i, WSC\u03b1i and SNC\u03b1i a weakest sufficient condition and a strongest necessary condition of \u03b1 over Oi under \u0393 respectively. Then, for each state s of F ,\n(F , s) |= Ki\u03b1 \u21d4 WSC\u03b1i and\n(F , s) |= \u00acKi\u00ac\u03b1 \u21d4 SNC\u03b1i . Proof: We only show (F , s) |= Ki\u03b1 \u21d4 WSC\u03b1i , while the other part comes in a straightforward way by duality between WSCs and SNCs. Because WSC\u03b1i is a sufficient condition of \u03b1 under \u0393, we have \u0393 |= WSC\u03b1i \u21d2 \u03b1. Let \u03b8 be the conjunction of all formulas in \u0393, then we have |= \u03b8 \u21d2 (WSC\u03b1i \u21d2 \u03b1), which leads to (F , s) |= KiWSC\u03b1i \u21d2 Ki\u03b1 (by item 5 of Lemma 10.) Because WSC\u03b1i is i-local, by Lemma 10 (item 3) again, we have (F , s) |= WSC\u03b1i \u21d2 KiWSC\u03b1i . Hence, (F , s) |= WSC\u03b1i \u21d2 Ki\u03b1.\nTo show the other direction (F , s) |= Ki\u03b1 \u21d2 WSC\u03b1i , we consider the formula \u2200(V \u2212 Oi)(\u03b8 \u21d2 \u03b1), where \u03b8 is the same as above. By Proposition 6, we have \u0393 |= \u2200(V \u2212Oi)(\u03b8 \u21d2 \u03b1) \u21d2 WSC\u03b1i . On the other hand, we know that (F , s) |= Ki\u03b1 \u21d2 \u2200(V \u2212Oi)(\u03b8 \u21d2 \u03b1) by the definition of Ki\u03b1. This proves (F , s) |= Ki\u03b1 \u21d2 WSC\u03b1i . 2\nThe following corollary characterizes the subjective formulas Ki\u03b1 (where \u03b1 is objective) which are satisfied in a given knowledge structure.\nCorollary 14 Let V be a finite set of variables, F = (V, {\u03b8}, O1, \u00b7 \u00b7 \u00b7 , On) a knowledge structure with n agents, and \u03b1 a formula over V . Then, for every state s of F ,\n(F , s) |= Ki\u03b1 \u21d4 \u2200(V \u2212Oi)(\u03b8 \u21d2 \u03b1). Proof: Immediately by Theorem 13 and Proposition 6. 2\nExample 15 : Now we consider the communication scenario between Alice and Bob addressed in section 1 once again. To show how our system can deal with the knowledge reasoning issue in this scenario, we define a knowledge structure F as follows:\nF = (V, {\u03b8}, OA, OB),\nwhere\n\u2022 OA = {Alice send msg, Alice recv ack},\n\u2022 OB = {Bob recv msg, Bob send ack},\n\u2022 V = OA \u222aOB, and\n\u2022 \u03b8 is the conjunction of the following three formulas:\nBob recv msg \u21d2 Alice send msg, Bob send ack \u21d2 Bob recv msg, Alice recv ack \u21d2 Bob send ack,\nNow given a state of F\ns =    Alice send msg, Alice recv ack, Bob recv msg, Bob send ack    ,\nwe would like to know whether Alice knows that Bob received the message. Consider the formula\n\u2200 {\nBob recv msg, Bob send ack\n} (\u03b8 \u21d2 Bob recv msg).\nFrom Definition 1, the above formula is simplified as Alice recv ack, which, obviously, is satisfied in the scenario (F , s), i. e. ,\n(F , s) |= Alice recv ack.\nThen from Corollary 14, we have\n(F , s) |= KABob recv msg. From item 3 of lemma 10, it follows that\n(F , s) |= KAAlice send msg\nand (F , s) |= KAAlice recv ack,\nwhich indicates that Alice knows that she sent the message and she knows that she received acknowledgement from Bob. 2\nGiven a set of states S of a knowledge structure F and a formula \u03b1, by (F , S) |= \u03b1, we mean that for each s \u2208 S, (F , s) |= \u03b1. The following proposition presents an alternative way to compute an agent\u2019s knowledge.\nProposition 16 Let V be a finite set of variables, F = (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On) a knowledge structure with n agents, \u03c8 a formula over V , and \u03b1 a formula in LCn . Suppose that SNC\u03c8i is a strongest necessary condition of \u03c8 over Oi under \u0393, S\u03c8 denotes the set of those states s of F such that (F , s) |= \u03c8, and S\nSNC\u03c8i denotes the set of those states s such that (F , s) |=\nSNC\u03c8i . Then, for each agent i, we have that\n(F , S\u03c8) |= Ki\u03b1 iff (F , SSNC\u03c8i ) |= \u03b1.\nProof: Let S1 be the set of all states s satisfying (F , s) |= \u2203(V \u2212 Oi)(\u03b8 \u2227 \u03c8). Because \u0393 |= SNC\u03c8i \u21d4 \u2203(V \u2212Oi)(\u03b8\u2227\u03c8), we have S1 = SSNC\u03c8i . Also it is easy to see that for state s of F , s \u2208 S1 iff there is a state s\u2032 of F such that s\u2032 |= \u03c8 and s\u2229Oi = s\u2032 \u2229Oi. Therefore we have (F , S\u03c8) |= Ki\u03b1 iff S1 \u2286 {s | (F , s) |= \u03b1}. This leads to (F , S\u03c8) |= Ki\u03b1 iff (F , S1) |= \u03b1 iff (F , S\nSNC\u03c8i ) |= \u03b1. 2\nThe intuitive meaning behind Proposition 16 is that if all we know about the current state is \u03c8, then all we know about agent i\u2019s knowledge (or agent i\u2019s observations) is the strongest necessary condition of \u03c8 over Oi.\nThe following proposition provides a method to determined whether a formula with the nested depth of knowledge operators (like Ki1 \u00b7 \u00b7 \u00b7Kik\u03b1, where \u03b1 is a propositional formula) is always true in those states, where a given proposition formula \u03c8 is true.\nProposition 17 Let V be a finite set of variables, F = (V, {\u03b8}, O1, \u00b7 \u00b7 \u00b7 , On) a knowledge structure with n agents, \u03b1 and \u03c8 two formulas over V , and S\u03c8 denotes the set of states s of F such that (F , s) |= \u03c8. Then, for each group of agents i1, \u00b7 \u00b7 \u00b7 , ik, we have (F , S\u03c8) |= Ki1 \u00b7 \u00b7 \u00b7Kik\u03b1 holds iff |= \u03b8 \u2227 \u03c8k \u21d2 \u03b1 where \u03c8k is defined inductively as follows:\n\u03c81 = \u2203(V \u2212Oi1)(\u03b8 \u2227 \u03c8);\nand for each j < k, \u03c8j+1 = \u2203(V \u2212Oij+1)(\u03b8 \u2227 \u03c8j).\nProof: We show this proposition by induction on the nested depth of knowledge operations. The base case is implied directly by Proposition 16. Assume that the claim holds for those cases with nested depth k, we want to show it also holds when the nested depth is k + 1, i. e. , (F , S\u03c8) |= Ki1 \u00b7 \u00b7 \u00b7Kik+1\u03b1 iff |= \u03b8 \u2227 \u03c8k+1 \u21d2 \u03b1. By Proposition 16, we have\n(F , S\u03c8) |= Ki1 \u00b7 \u00b7 \u00b7Kik+1\u03b1 iff (F , S\u03c81) |= Ki2 \u00b7 \u00b7 \u00b7Kik+1\u03b1. By the inductive assumption, we have that\n(F , S\u03c81) |= Ki2 \u00b7 \u00b7 \u00b7Kik+1\u03b1 iff |= \u03b8 \u2227 \u03c8k+1 \u21d2 \u03b1.\nCombining two assertions above, we get\n(F , S\u03c8) |= Ki1 \u00b7 \u00b7 \u00b7Kik+1\u03b1 iff |= \u03b8 \u2227 \u03c8k+1 \u21d2 \u03b1. 2\nWhen we consider the case where the nested depth of knowledge operators is no more than 2, we get the following corollary.\nCorollary 18 Let V,F , \u03b1, \u03c8 and S\u03c8 be as in Proposition 17. Then, for each agent i and each agent j, we have\n1. (F , S\u03c8) |= Ki\u03b1 holds iff |= (\u03b8 \u2227 \u2203(V \u2212Oi)(\u03b8 \u2227 \u03c8)) \u21d2 \u03b1;\n2. (F , S\u03c8) |= KjKi\u03b1 holds iff |= (\u03b8 \u2227 \u2203(V \u2212Oi)(\u03b8 \u2227 \u2203(V \u2212Oj)(\u03b8 \u2227 \u03c8))) \u21d2 \u03b1.\nProof: Immediately from Proposition 17. 2\nAs will be illustrated in our analysis of security protocols (i.e. Section 6), the part 2 of Corollary 18 is useful for verifying protocol specifications with nested knowledge operators. Given a background knowledge base \u03b8, when we face the task of testing whether KjKi\u03b1 holds in those states satisfying \u03c8, by part 2 of Corollary 18, we can first get \u03c61 = \u2203(V \u2212Oj)(\u03b8\u2227\u03c8), which is a strongest necessary condition of \u03c8 over Oj . This is all we know about what agent j observes from \u03c8. Then we compute \u03c62 = \u2203(V \u2212Oi)(\u03b8\u2227\u03c61), i. e. , the strongest necessary condition of \u03c61 over Oi which is, from the viewpoint of agent j, about what agent i observes. In this way, the task of checking KjKi\u03b1 is reduced to a task of checking \u03b8 \u2227 \u03c62 \u21d2 \u03b1.\nThe following corollary gives two methods to check the truth of Ki\u03b1 (where \u03b1 is a propositional formula) in all those states where a given formula \u03c8 is true. One is via the strongest necessary condition of \u03c8 and the other is via the weakest sufficient condition of \u03b1.\nCorollary 19 Let V be a finite set of propositional variables and F = (V, {\u03b8}, O1, \u00b7 \u00b7 \u00b7 , On) a knowledge structure with n agents, \u03b1 and \u03c8 two formulas over V . Suppose that S\u03c8 denotes the set of all states s of F such that (F , s) |= \u03c8, and SNC\u03c8i and WSC\u03b1i are a strongest necessary condition of \u03c8 over Oi and a weakest sufficient condition of \u03b1 over Oi under {\u03b8} respectively. Then\n1. (F , S\u03c8) |= Ki\u03b1 iff |= (\u03b8 \u2227 \u03c8) \u21d2 WSC\u03b1i ; and 2. (F , S\u03c8) |= Ki\u03b1 iff |= (\u03b8 \u2227 SNC\u03c8i ) \u21d2 \u03b1.\nProof: The first part of the corollary follows from Theorem 13 and Lemma 10, while the second part follows immediately by Proposition 16. 2\nIn our analysis of security protocols, we observe that very often, it seems more efficient to check an agent\u2019s knowledge via the second part of Corollary 19 rather than via the first part. But this may not be always true for some other applications (e.g. see the example of the muddy children puzzle in the next section)."}, {"heading": "4. Common Knowledge", "text": "Common knowledge is a special kind of knowledge for a group of agents, which plays an important role in reasoning about knowledge (Fagin et al., 1995). A group of agents \u2206 commonly know \u03d5 when all the agents in \u2206 know \u03d5, they all know that they know \u03d5, they all know that they all know that they know \u03d5, and so on ad infinitum. We recall that common knowledge can be characterized in terms of Kripke structures. Given a Kripke structure M = (W,\u03c0,K1, \u00b7 \u00b7 \u00b7 ,Kn), a group \u2206 of agents commonly know \u03d5 ( or in modal logic language, C\u2206\u03d5 is true ) in a world w iff \u03d5 is true in all worlds w\u2032 such that (w, w\u2032) \u2208 C\u2206, where C\u2206 denotes the transitive closure of \u22c3 i\u2208\u2206Ki.\nIn this section, we generalize the concept of weakest sufficient and strongest necessary conditions so that they can be used to compute common knowledge."}, {"heading": "4.1 Generalized Weakest Sufficient and Strongest Necessary Conditions", "text": "The following gives a generalized notion of weakest sufficient conditions and strongest necessary conditions.\nDefinition 20 Given a set of formulas \u0393 over V as a background knowledge base. Let \u03b1 be a formula over V , and V a nonempty set of subsets of V .\n\u2022 A formula \u03d5 is called V-definable under \u0393 (or simply called V-definable if there is no confusion in the context), if for each P \u2208 V, there is a formula \u03c8P over P such that \u0393 |= \u03d5 \u21d4 \u03c8P .\n\u2022 A formula \u03d5 is called a V-sufficient condition of \u03b1 under \u0393 if it is V-definable and \u0393 |= \u03d5 \u21d2 \u03b1. It is called a weakest V-sufficient condition of \u03b1 under \u0393 if it is a V-sufficient condition of \u03b1 under \u0393, and for any other V-sufficient condition \u03d5\u2032 of \u03b1 under \u0393, we have \u0393 |= \u03d5\u2032 \u21d2 \u03d5.\n\u2022 Similarly, formula \u03d5 is called a V-necessary condition of \u03b1 under \u0393 if it is V-definable and \u0393 |= \u03b1 \u21d2 \u03d5. It is called a strongest V-necessary condition of \u03b1 under \u0393 if it is a V-necessary condition of \u03b1 under \u0393, and for any other V-necessary condition \u03d5\u2032 of \u03b1 under \u0393, we have \u0393 |= \u03d5 \u21d2 \u03d5\u2032.\nWe notice that the notion of V-definability introduced here is a simple elaboration of the notion of V-definability as given in the work of Lang and Marquis (1998): \u03c6 is V-definable under \u0393 iff \u03c6 is V -definable under \u0393 for each V \u2208 V. Moreover, it is easy to see that the formulas implied by \u0393 or inconsistent with it are exactly the formulas \u2205-definable under \u0393, and that definability exhibits a monotonicity property: if \u03c6 is V -definable under \u0393, then \u03c6 is V \u2032-definable under \u0393 for each superset V \u2032 of V (Lang & Marquis, 1998). Observe also that \u03c6 is V -definable under \u0393 iff \u00ac\u03c6 is V -definable under \u0393, and this extends trivially to V-definability.\nThe following lemma says that the notions of weakest V-sufficient conditions and strongest V-necessary ones are dual to each other.\nLemma 21 Given a set of formulas \u0393 over V as a background knowledge base, and V a set of subsets of V . Let \u03d5 and \u03b1 be formulas over V . Then, we have that \u03d5 is a weakest\nV-sufficient condition of \u03b1 under \u0393 iff \u00ac\u03d5 is a strongest V-necessary condition of \u00ac\u03b1 under \u0393.\nProof: Straightforward by the duality between WSCs and SNCs. 2\nTo give some intuition and motivation of the above definition, let us consider the following example.\nExample 22: Imagine that there are two babies, say Marry and Peter, playing with a dog. Suppose the propositions \u201cThe dog is moderately satisfied\u201d (denoted by m, for short) and \u201cThe dog is full\u201d(f) are understandable to Marry, and the propositions \u201cThe dog is hungry\u201d (h) and \u201cThe dog is unhappy\u201d(u) are understandable to Peter.\nLet \u0393 = {h \u21d2 u,\u00ac(m\u2227 f), (m\u2228 f) \u21d4 \u00ach}, V1 = {m, f}, V2 = {h, u}, and V = {V1, V2}. We will show that\n1. h is V-definable under \u0393;\n2. h is a weakest V-sufficient condition of u under \u0393; and\n3. \u00ach is a strongest V-necessary condition of \u00acu under \u0393.\nThe first claim is easy to check by the definition. The last two claims follow immediately if we can prove that all the V-definable propositions under \u0393 are false, true, h and \u00ach (up to logical equivalence under \u0393). There are 8 propositions over V1 up to logical equivalence. The 8 propositions are: true, false, m,\u00acm, f,\u00acf,m \u2228 f,\u00acm \u2227 \u00acf . Similarly, there are 8 propositions over V2 up to logical equivalence under \u0393, i.e., true, false, h,\u00ach, u,\u00acu, h \u2228 \u00acu,\u00ach \u2227 u. However, we can find, between the two classes of propositions, only 4 pairs of equivalence relations under \u0393, i.e., \u0393 |= true \u21d4 true, \u0393 |= false \u21d4 false, \u0393 |= (m \u2228 f) \u21d4 \u00ach, \u0393 |= (\u00acm \u2227 \u00acf) \u21d4 h. Therefore, all the V-definable propositions under \u0393 are false, true, h and \u00ach (up to logical equivalence under \u0393). 2\nExample 23: Now we recall the background knowledge \u0393CS about the communication scenario between Alice and Bob in the introduction section. \u0393CS is the set of the following three formulas:\nBob recv msg \u21d2 Alice send msg Bob send ack \u21d2 Bob recv msg Alice recv ack \u21d2 Bob send ack\nLet OA = {Alice send msg, Alice recv ack}, OB = {Bob recv msg, Bob send ack}, VAB = {OA, OB}.\nClearly, if a formula \u03d5 is logically implied by \u0393CS or inconsistent with \u0393CS , then \u03d5 is VAB-definable under \u0393CS . Moreover, as in Example 22, we are able to check that there are no VAB-definable formulas other than those implied by \u0393CS or inconsistent with \u0393CS . Therefore, given a formula \u03b1, a weakest VAB-sufficient condition of \u03b1 under \u0393CS is implied by \u0393CS if \u0393CS |= \u03b1, or inconsistent with \u0393CS . 2\nLet \u0393 be a set of formulas, V a set of propositional variables, and V a set of subsets of V . The following proposition gives the existence of weakest V-sufficient and strongest V-necessary conditions. For a given formula \u03b1 over V , a weakest V-sufficient condition \u03c61 of \u03b1 and a strongest V-necessary condition \u03c62 of \u03b1 can be obtained in the proposition. Indeed, the set of assignments satisfying \u03c61 and that of assignments satisfying \u03c62 can be given in terms of relation EV . Proposition 24 Given a finite set V of propositional variables, a set \u0393 of formulas over V as a background knowledge base, a formula \u03b1 over V , and a set V of subsets of V . Denote by S\u03b1WSC the set of assignments s over V such that s |= \u0393, and for all assignments s\u2032 satisfying \u0393 with (s, s\u2032) \u2208 E\u2217V , s\u2032 |= \u03b1. Also denote by S\u03b1SNC the set of assignments s over V such that s |= \u0393, and there exists an s\u2032 such that s\u2032 |= \u0393, s\u2032 |= \u03b1 and (s, s\u2032) \u2208 E\u2217V . Then, the following two points hold.\n\u2022 If a formula is satisfied exactly by those assignments in S\u03b1WSC , then the formula is a weakest V-sufficient condition of \u03b1 under \u0393; and\n\u2022 If a formula is satisfied exactly by those assignments in S\u03b1SNC , then the formula is a strongest V-necessary condition of \u03b1 under \u0393.\nProof: We first prove the former point, and then show the other by Lemma 21. Let \u03c61 be a propositional formula over V such that, for all assignments s, s |= \u03c61 iff s \u2208 S\u03b1WSC . Then, for every assignment s \u2208 S\u03b1WSC , we have s |= \u03b1 because (s, s) \u2208 E\u2217V . Thus, \u03c61 |= \u03b1.\nWe remark that for arbitrarily given formula \u03d5 over V and assignment s over V , s |= \u2200(V \u2212 P )\u03d5 iff for all assignments s\u2032 over V such that s \u2229 P = s\u2032 \u2229 P , we have s\u2032 |= \u03d5.\nTo prove that \u03c61 is V-definable, we show that, for each P \u2208 V, \u03c61 |= \u2200(V \u2212P )\u03c61, which implies that \u03c61 is equivalent to the formula \u2200(V \u2212P )\u03c61 over P . To prove \u03c61 |= \u2200(V \u2212P )\u03c61, in a semantical way, it suffices to show that, for every assignment s \u2208 S\u03b1WSC and s\u2032 |= \u0393, if s\u2229P = s\u2032 \u2229P , then s\u2032 \u2208 S\u03b1WSC . Let s and s\u2032 be given as above and suppose s\u2229P = s\u2032 \u2229P . Then, (s, s\u2032) \u2208 EV . Given an assignment t such that t |= \u0393, if (s\u2032, t) \u2208 E\u2217V , then (s, t) \u2208 E\u2217V by (s, s\u2032) \u2208 EV . Thus, s\u2032 \u2208 S\u03b1WSC . This proves that \u03c61 is V-definable.\nNow we show that \u03c61 is a weakest V-sufficient condition under \u0393. Suppose \u03c6 is a Vdefinable and sufficient condition of \u03b1 under \u0393, we want to prove that \u0393 |= \u03c6 \u21d2 \u03c61. The semantical argument of such a proof is as follows. Let s be an assignment with s |= \u0393 and \u03c6, we must show that s \u2208 S\u03b1WSC , i.e., for every assignment s\u2032 with s\u2032 |= \u0393 such that (s, s\u2032) \u2208 E\u2217V , s\u2032 |= \u03b1. Because \u0393 |= \u03c6 \u21d2 \u03b1, it suffices to show that s\u2032 |= \u03c6. By the condition (s, s\u2032) \u2208 E\u2217V , there is a finite sequence of assignments s0, \u00b7 \u00b7 \u00b7 , sk such that sj |= \u0393 with s0 = s and sk = s\u2032, and for every j < k, (sj , sj+1) \u2208 EV . By the V-definability of \u03c6, we know that for every j < k, sj |= \u03c6 implies sj+1 |= \u03c6. Thus, we have s\u2032 |= \u03c6 by induction.\nNow we prove the second point of this proposition by Lemma 21. Let \u03c62 be a propositional formula over V such that, for all assignments s, s |= \u03c62 iff s \u2208 S\u03b1SNC . Let \u03b8 be the conjunction of formulas in \u0393. Then, s |= \u00ac\u03c62 \u2227 \u03b8 iff for all assignments s\u2032 with s\u2032 |= \u0393 such that sE\u2217Vs\u2032, we have s\u2032 |= \u00ac\u03d5. Thus, by the first point of this proposition, we have that \u00ac\u03c62 \u2227 \u03b8 is a weakest V-sufficient condition of \u00ac\u03b1. Thus, \u03c62 \u2228\u00ac\u03b8 and hence \u03c62 is a strongest V-necessary condition of \u03b1 according to Lemma 21. 2\nThe above proposition can be thought of as a semantical characterization of weakest V-sufficient and strongest V-necessary conditions."}, {"heading": "4.2 Characterizations with Least and Greatest Fixed Points", "text": "We investigate the computation of the weakest V-sufficient and strongest V-necessary conditions by using the notions of a least and a greatest fixed points of an operator, which is introduced as follows. Let V be a set of propositional variables, and \u039b be an operator (or a mapping) from the set of propositional formulas over V to the set of propositional formulas over V . We say a \u03c8 is a fixed point of \u039b, if |= \u039b(\u03c8) \u21d4 \u03c8. We say a \u03c80 is a greatest fixed point of \u039b, if \u03c80 is a fixed point of \u039b and for every fixed point \u03c8 of \u039b, we have |= \u03c8 \u21d2 \u03c80. Clearly, any two greatest fixed points are logically equivalent to each other. Thus, we denote a greatest fixed point of \u039b by gfpZ\u039b(Z). Similarly, we say a \u03c80 is a least fixed point of \u039b, if \u03c80 is a fixed point of \u039b and for every fixed point \u03c8 of \u039b, we have |= \u03c80 \u21d2 \u03c8. We denote a least fixed point of \u039b by lfpZ\u039b(Z). We say \u039b is monotonic, if for every two formulas \u03c81 and \u03c82 such that |= \u03c81 \u21d2 \u03c82, we have |= \u039b(\u03c81) \u21d2 \u039b(\u03c82). For a finite set V of propositional variables if \u039b is monotonic, then there exists a least fixed point and a greatest fixed point (Tarski, 1955).\nTheorem 25 Let V be a finite set of variables, F = (V, {\u03b8}, O1, \u00b7 \u00b7 \u00b7 , On) a knowledge structure, \u03b1 a formula over V , \u2206 \u2286 {1, \u00b7 \u00b7 \u00b7 , n}, V\u2206 = {Oi | i \u2208 \u2206}. Assume that \u039b1 and \u039b2 are two operators such that\n\u039b1(Z) = \u2227\ni\u2208\u2206 \u2200(x\u2212Oi)(\u03b8 \u21d2 Z)\nand \u039b2(Z) = \u2228\ni\u2208\u2206 \u2203(x\u2212Oi)(\u03b8 \u2227 Z).\nThen,\n\u2022 a weakest V\u2206-sufficient condition of \u03b1 under {\u03b8} is equivalent to gfp Z(\u03b1 \u2227 \u039b1(Z)); and\n\u2022 a strongest V\u2206-necessary condition of \u03b1 under {\u03b8} is equivalent to lfp Z(\u03b1 \u2228\u039b2(Z)). Proof: Let WSC\u03b1\u2206 be a weakest V\u2206-sufficient condition of \u03b1 under {\u03b8}. Note that the operator (\u03b1 \u2227 \u039b1(Z)) is monotonic and thus there exists a greatest fixed point of it. Let \u03c81= gfp Z(\u03b1 \u2227 \u039b1(Z)). To prove the first point of this theorem, we must show that \u03b8 |= WSC\u03b1\u2206 \u21d4 \u03c81.\nWe first show that \u03b8 |= WSC\u03b1\u2206 \u21d2 \u03c81. For this purpose, we only need to prove 1. \u03b8 |= WSC\u03b1\u2206 \u21d2 (\u03b1 \u2227 \u039b1(true)); and 2. for all formulas \u03d5 on V , if \u03b8 |= WSC\u03b1\u2206 \u21d2 \u03d5, then \u03b8 |= WSC\u03b1\u2206 \u21d2 (\u03b1 \u2227 \u039b1(\u03d5)).\nThe first point is trivially true because \u039b1(true) is equivalent to true and WSC\u03b1\u2206 is a sufficient condition of \u03b1 under {\u03b8}. To show the second point, suppose \u03b8 |= WSC\u03b1\u2206 \u21d2 \u03d5. For i \u2208 \u2206, let \u03b1i be the formula over Oi such that \u03b8 |= WSC\u03b1\u2206 \u21d4 \u03b1i. Then, \u03b8 |= \u03b1i \u21d2 \u03d5. It follows that |= \u03b1i \u21d2 (\u03b8 \u21d2 \u03d5) and hence |= \u03b1i \u21d2 \u2200(V \u2212 Oi)(\u03b8 \u21d2 \u03d5) because \u03b1i does not depend on the variables in (V \u2212 Oi). So, we have that, for all i \u2208 \u2206, \u03b8 |= WSC\u03b1\u2206 \u21d2 \u2200(V \u2212Oi)(\u03b8 \u21d2 \u03d5). The conclusion of the second point follows immediately.\nWe now show that \u03b8 |= \u03c81 \u21d2 WSC\u03b1\u2206, or \u03b8 |= (\u03b8 \u21d2 \u03c81) \u21d2 WSC\u03b1\u2206. It suffices to show that \u03b8 \u21d2 \u03c81 is V\u2206-sufficient condition of \u03b1 under {\u03b8}, that is,\n1. \u03b8 \u21d2 \u03c81 is V\u2206-definable; and 2. \u03b8 |= (\u03b8 \u21d2 \u03c81) \u21d2 \u03b1.\nBy the fact that \u03c81 is a fixed point of the operator (\u03b1 \u2227 \u039b1(Z)), we have that\n|= \u03c81 \u21d2 (\u03b1 \u2227 \u2227\ni\u2208\u2206 \u2200(x\u2212Oi)(\u03b8 \u21d2 \u03c81)).\nIt follows that |= \u03c81 \u21d2 \u03b1, and hence \u03b8 |= (\u03b8 \u21d2 \u03c81) \u21d2 \u03b1. To show the other point, for i \u2208 \u2206, we need to prove that \u03b8 \u21d2 \u03c81 is equivalent to a formula over Oi. By the above, we have that \u03c81 \u21d2 \u2200(V \u2212 Oi)(\u03b8 \u21d2 \u03c81). It follows that \u03b8 |= (\u03b8 \u21d2 \u03c81) \u21d2 \u2200(V \u2212 Oi)(\u03b8 \u21d2 \u03c81), and hence \u03b8 |= (\u03b8 \u21d2 \u03c81) \u21d4 \u2200(V \u2212Oi)(\u03b8 \u21d2 \u03c81) because |= \u2200(V \u2212 Oi)(\u03b8 \u21d2 \u03c81) \u21d2 (\u03b8 \u21d2 \u03c81) holds trivially. Thus (\u03b8 \u21d2 \u03c81) is equivalent under \u03b8 to \u2200(V \u2212 Oi)(\u03b8 \u21d2 \u03c81), which is over Oi. This completes the first point of the conclusion of the theorem.\nWe now show the second point of this theorem by using the first point and Lemma 21. Let SNC\u03b1\u2206 be a strongest V\u2206-necessary condition of \u03b1 under {\u03b8}. By Lemma 21, \u00acSNC\u03b1\u2206 is a weakest V\u2206-sufficient condition of \u00ac\u03b1 under {\u03b8}. Thus, by the first point of this theorem, \u00acSNC\u03b1\u2206 is equivalent to gfp Z(\u00ac\u03b1 \u2227 \u039b1(Z)) under \u03b8. Hence, SNC\u03b1\u2206 is equivalent to \u00acgfp Z(\u00ac\u03b1 \u2227 \u039b1(Z)) under \u03b8. However, \u00acgfp Z(\u00ac\u03b1 \u2227 \u039b1(Z)) is logically equivalent to lfp Z(\u00ac(\u00ac\u03b1\u2227\u039b1(\u00acZ))), which is in turn equivalent to lfp Z(\u03b1\u2228\u039b2(Z)). This completes the second point of the theorem. 2"}, {"heading": "4.3 Common Knowledge as Weakest V-sufficient Conditions", "text": "Given a set \u2206 of agents and a family V\u2206 of observable variable sets of these agents, we investigate the relationship between common knowledge and the weakest V\u2206-sufficient and strongest V\u2206-necessary conditions.\nTheorem 26 Let V be a finite set of variables, F = (V, \u0393, O1, \u00b7 \u00b7 \u00b7 , On) a knowledge structure, \u2206 \u2286 {1, \u00b7 \u00b7 \u00b7 , n}, V\u2206 = {Oi | i \u2208 \u2206}, \u03b1 a formula over V , and WSC\u03b1\u2206 and SNC\u03b1\u2206 a weakest V\u2206-sufficient condition and a strongest V\u2206-necessary condition of \u03b1 under \u0393 respectively. Then, for every state s of F ,\n(F , s) |= C\u2206\u03b1 \u21d4 WSC\u03b1\u2206 and\n(F , s) |= \u00acC\u2206\u00ac\u03b1 \u21d4 SNC\u03b1\u2206.\nProof: We only show the first part of this theorem, i.e., (F , s) |= C\u2206\u03b1 \u21d4 WSC\u03b1\u2206, by which and Lemma 21 we can get the other part immediately. Because WSC\u03b1\u2206 is a sufficient condition of \u03b1, we have that \u0393 |= WSC\u03b1\u2206 \u21d2 \u03b1. Let \u03b8 be the conjunction of all formulas in \u0393, we have that |= \u03b8 \u21d2 (WSC\u03b1\u2206 \u21d2 \u03b1), which leads to (F , s) |= C\u2206WSC\u03b1\u2206 \u21d2 C\u2206\u03b1 (by point 6 of Lemma 10). Because WSC\u03b1\u2206 is V\u2206-definable, we have, by point 4 of Lemma 10, (F , s) |= WSC\u03b1\u2206 \u21d2 C\u2206WSC\u03b1\u2206. Hence, (F , s) |= WSC\u03b1\u2206 \u21d2 C\u2206\u03b1.\nTo show the other direction (F , s) |= C\u2206\u03b1 \u21d2 WSC\u03b1\u2206, we consider the formula \u03c81 in the proof of Theorem 25, i.e., the greatest fixed point of the operator\n\u039b(Z) = \u03b1 \u2227 \u2227\ni\u2208\u2206 \u2200(V \u2212Oi)(\u03b8 \u21d2 Z).\nBecause we already have (F , s) |= \u03c81 \u21d2 WSC\u03b1\u2206 by Theorem 25, it suffices to show (F , s) |= C\u2206\u03b1 \u21d2 \u03c81. Because the greatest fixed point \u03c81 of the operator \u039b can be obtained by a finite iteration of the operator with the starting point \u039b(true), we only need to prove that\n1. F |= C\u2206\u03b1 \u21d2 \u039b(true); and\n2. for an arbitrary propositional formula \u03d5 over V , if F |= C\u2206\u03b1 \u21d2 \u03d5, then F |= C\u2206\u03b1 \u21d2 \u039b(\u03d5).\nThe first point is trivially true because \u039b(true) is equivalent to \u03b1. To prove the second, suppose F |= C\u2206\u03b1 \u21d2 \u03d5. Then, for each i \u2208 \u2206, F |= Ki(C\u2206\u03b1 \u21d2 \u03d5). Thus, we have that F |= C\u2206\u03b1 \u21d2 Ki\u03d5 by points 5 and 7 of Lemma 10. Hence, F |= C\u2206\u03b1 \u21d2 \u2200(V \u2212Oi)(\u03b8 \u21d2 \u03d5) (by Corollary 14). It follows that F |= C\u2206\u03b1 \u21d2 \u2227 i\u2208\u2206 \u2200(V \u2212 Oi)(\u03b8 \u21d2 \u03d5) and hence F |= C\u2206\u03b1 \u21d2 \u039b(\u03d5). We thus get F |= C\u2206\u03b1 \u21d2 \u03c81. This completes the proof. 2\nProposition 27 Given V , F , \u2206, V\u2206, \u03b1 as defined in Theorem 26. Let \u03c8 be a formula over V . Assume that a strongest V\u2206-necessary condition of \u03c8 is SNC\u03c8\u2206. Denote by S\u03c8 the set of those states s of F such that (F , s) |= \u03c8, and by S\nSNC\u03c8\u2206 the set of those states s such\nthat (F , s) |= SNC\u03c8\u2206. Then, we have\n(F , S\u03c8) |= C\u2206\u03b1 iff (F , SSNC\u03c8\u2206) |= \u03b1.\nProof: Let S1 be the set of all states s such that there is a state s\u2032 with s\u2032 |= \u03c8 and (s\u2032, s) \u2208 V\u2206. We have that (F , S\u03c8) |= C\u2206\u03b1 iff for every s \u2208 S1, (F , s) |= \u03b1. This leads to (F , S\u03c8) |= C\u2206\u03b1 iff (F , S1) |= \u03b1. On the other hand, by Proposition 24, we have that S1 = SSNC\u03c8\u2206 . Then the conclusion of the proposition follows immediately. 2\nNote that, in Proposition 27, if \u03b1 is a propositional formula, we have that (F , S\u03c8) |= C\u2206\u03b1 iff \u0393 |= SNC\u03c8\u2206 \u21d2 \u03b1. Moreover, by Theorem 26, we have (F , S\u03c8) |= C\u2206\u03b1 iff \u0393 |= \u03c8 \u21d2 WSC\u03b1\u2206, where WSC \u03b1 \u2206 is a weakest V\u2206-sufficient of \u03b1."}, {"heading": "5. Adding Public Announcement Operator", "text": "There is a recent trend of extending epistemic logic with dynamic operators so that the evolution of knowledge can be expressed. The most basic such extension is public announcement logic (PAL), which is obtained by adding an operator for truthful public announcements. The original version of PAL was proposed by Plaza (1989). In this section, we show that public announcement operator can be conveniently dealt with via our notion of knowledge structure."}, {"heading": "5.1 Public Announcement Logic", "text": "Given a set of agents A = {1, . . . , n} and a set V of propositional variables. The language of public announcement logic (PALn) is inductively defined as\n\u03d5 ::= p|\u00ac\u03d5|\u03d5 \u2227 \u03c8|Ki\u03d5|C\u2206\u03d5|[\u03d5]\u03c8\nwhere p \u2208 V , i \u2208 A and \u2206 \u2286 A. In other words, PALn is obtained from epistemic logic LCn (V ) by adding public announcement operator [\u03d5] for each formula \u03d5. Formula [\u03d5]\u03c8 means that \u201cafter public announcement of \u03d5, formula \u03c8 is true.\u201d\nWe now give the semantics of public announcement logic under Kripke model. Given a Kripke structure M = (W,\u03c0,K1, . . . ,Kn), the semantics of the new operators is defined as follows.\nM, w |= [\u03d5]\u03c8 iff M, w |= \u03d5 implies M |\u03d5, w |= \u03c8, where M |\u03d5 is a Kripke structure such that M |\u03d5 = (W \u2032, \u03c0\u2032,K\u20321, . . . ,K\u2032n) and\n\u2022 W \u2032 = {w \u2208 W |M, w |= \u03d5},\n\u2022 \u03c0\u2032(w\u2032)(p) = \u03c0(w\u2032)(p) for each w\u2032 \u2208 W \u2032 and each p \u2208 V , and\n\u2022 K\u2032i = Ki \u2229 (W \u2032 \u00d7W \u2032) for each i \u2208 A.\nThere are some sentences that become false immediately after the announcement of them. Consider, for example, the sentence \u2018p is true but was not commonly known to be true \u2019. By the announcement of the sentence all agents learn that p and therefore p is commonly known. This can be modelled in public announcement logic by valid formula [\u03d5]\u00ac\u03d5, where \u03d5 = p \u2227 \u00acC\u2206p. To see its validity, let (M, w) be an arbitrary situation. If M, w |= \u03d5,then M, w |= p, which implies that M |\u03d5, w |= C\u2206p, and therefore M |\u03d5, w |= \u00ac\u03d5."}, {"heading": "5.2 Semantics under Knowledge Structure", "text": "The semantics of public announcement logic can be conveniently characterized by our notion of knowledge structure. We define the satisfaction relationship |= between a scenario (F , s) and a formula in PALn. We need only consider those formulas of the form [\u03d5]\u03c8; other cases are the same as in Definition 9.\nLet V be a finite set of propositional variables and F = (\u0393, V,O1, \u00b7 \u00b7 \u00b7 , On). The semantics definition for the new operators is as follows. First, let F|\u03d5 be the knowledge structure ({\u03b8}, V,O1, \u00b7 \u00b7 \u00b7 , On), where \u03b8 is a propositional formula on V such that (F , s) |= \u03d5 iff s satisfies \u03b8. As V is a finite set, such a propositional formula \u03b8 always exists.\nThen, we set that (F , s) |= [\u03d5]\u03c8 iff (F , s) |= \u03d5 implies that (F|\u03d5, s) |= \u03c8. We remark that if formula \u03d5 is equivalent to propositional one \u03d5\u2032 in knowledge structure F , i.e., F |= \u03d5 \u21d4 \u03d5\u2032 for some propositional formula \u03d5\u2032, then we can simply define F|\u03d5 as (\u0393 \u222a {\u03d5\u2032}, V,O1, \u00b7 \u00b7 \u00b7 , On).\nThe following proposition indicates that the semantics of public announcement logic under knowledge structure coincides with that under Kripke model.\nProposition 28 (1) Let V be a finite set of propositional variables and F = (\u0393, V,O1, \u00b7 \u00b7 \u00b7 , On). For every state s of F and every formula \u03b1 \u2208 PALn, we have that (F , s) |= \u03b1 iff the situation (M(F), s) |= \u03b1. (2) For a finite S5n Kripke structure M and possible world w in M , there is a knowledge structure FM and a state sw of F such that, for every formula \u03b1 \u2208 PALn, we have that (FM , sw) |= \u03b1 iff (M, w) |= \u03b1.\nProof: (1) Let us proceed by induction on the structure of formula \u03b1. We consider only the case that \u03b1 is of the form [\u03d5]\u03c8; other cases are straightforward by the definitions.\nBy the definition, we have that (F , s) |= [\u03d5]\u03c8 iff (F , s) |= \u03d5 implies that (F|\u03d5, s) |= \u03c8. Thus, by the inductive assumption, we have that (F , s) |= [\u03d5]\u03c8 iff (M(F), s) |= \u03d5 implies that (M(F|\u03d5), s) |= \u03c8. We want to show that (F , s) |= [\u03d5]\u03c8 iff (M(F), s) |= [\u03d5]\u03c8. It suffices to show that M(F|\u03d5) equals M(F)|\u03d5 because (M(F), s) |= [\u03d5]\u03c8 iff (M(F), s) |= \u03d5 implies that (M(F)|\u03d5, s) |= \u03c8.\nFirst, the set of possible states of M(F|\u03d5) equals to the set of those states s\u2032 of F with (F , s\u2032) |= \u03d5. By the inductive assumption, (F , s\u2032) |= \u03d5 iff (M(F), s\u2032) |= \u03d5. Thus, the set of possible states of M(F|\u03d5) equals to the set of those states s\u2032 of F with (M(F), s\u2032) |= \u03d5, hence equals to the set of possible states of M(F)|\u03d5. Second, we have that for each s\u2032 of F with (M(F), s\u2032) |= \u03d5, \u03c0M(F|\u03d5)(s\u2032) = s\u2032 and \u03c0M(F)|\u03d5(s\u2032) = \u03c0M(F)(s\u2032) = s\u2032. Hence \u03c0M(F|\u03d5) = \u03c0M(F)|\u03d5 . Finally, for all states s1 and s2 of F with (M(F), s1) |= \u03d5 and (M(F), s2) |= \u03d5, we have that (s1, s2) \u2208 KM(F|\u03d5)i iff (s1, s2) \u2208 KM(F)i iff s1 \u2229 Oi = s2 \u2229 Oi. Moreover, (s1, s2) \u2208 KM(F)|\u03d5i iff s1 \u2229Oi = s2 \u2229Oi. Therefore, KM(F|\u03d5)i = KM(F)|\u03d5i . This completes the proof for M(F|\u03d5) = M(F)|\u03d5.\n(2) Suppose M = (W0, \u03c00, R1, \u00b7 \u00b7 \u00b7 , Rn), where W0 is a finite set and R1, \u00b7 \u00b7 \u00b7 , Rn are equivalence relations. We assume also that the set of propositional variables is V0.\nLet O1, \u00b7 \u00b7 \u00b7 , On be sets of new propositional variables such that 1. O1, \u00b7 \u00b7 \u00b7 , On are finite and pairwise disjoint; and 2. for each i (0 < i \u2264 n), the number of all subsets of Oi is not less than that of all\nequivalence classes of Ri.\nBy the latter condition, there is, for each i, a function gi: W0 7\u2192 2Oi such that for all w1, w2 \u2208 W0, gi(w1) and gi(w2) are the same subset of Oi iff w1 and w2 are in the same equivalence class of Ri.\nLet V = V0\u222a \u22c3\n0<i\u2264n Oi. We define a function g : W0 7\u2192 2V as follows. For each possible world w in W0,\ng(w) = {v \u2208 V | \u03c0(w)(v) = true} \u222a \u22c3\n0<i\u2264n gi(w).\nThe following two claims hold:\nC1 For all w1, w2 \u2208 W0, and i (0 < i \u2264 n), we have that g(w1) \u2229 Oi = g(w2) \u2229 Oi iff w1Riw2.\nC2 For all w \u2208 W0 and v \u2208 V0, we have that v \u2208 g(w) iff \u03c0(w)(v) = true. For any W \u2282 W0, let\n\u0393W = {\u03b1 | \u03b1 is over V, and g(w) |= \u03b1 for all w \u2208 W}.\nWe then get a knowledge structure\nFW = (V, \u0393W , O1, \u00b7 \u00b7 \u00b7 , On). We now show that following claim:\nC3 For every s \u2286 V , s is a state of FW iff s = g(w) for some w \u2208 W. The \u201cif\u201d part of claim C3 is easy to prove. If s = g(w\u2032) for some w\u2032 \u2208 W , then by the definition of \u0393W , we have that g(w\u2032) |= \u0393W and hence g(w\u2032) is a state of FM . To show the \u201conly if\u201d part, assume that for every w \u2208 W , s 6= g(w). Then, for every w \u2208 W , there exists \u03b1w over V such that s |= \u03b1w but g(w) |= \u00ac\u03b1w. Therefore, s |= \u2227 w\u2208W \u03b1w. Moreover, we have\nthat, for every w\u2032 \u2208 W , g(w\u2032) |= \u2228w\u2208W \u00ac\u03b1w, and hence \u2228\nw\u2208W \u00ac\u03b1w \u2208 \u0393W . Consequently, we have that s 6|= \u0393W and hence s is not a state of FW .\nTo complete the proof of the second part, it suffices to show, for every \u03b1 \u2208 PALn, that (FW , g(w)) |= \u03b1 iff (M |W , w) |= \u03b1, where M |W is a Kripke structure such that M |\u03d5 = (W,\u03c0, R\u20321, . . . , R\u2032n) and\n\u2022 \u03c0(w)(p) = \u03c00(w)(p) for each w \u2208 W and each p \u2208 V0, and \u2022 R\u2032i = Ri \u2229 (W \u2032 \u00d7W \u2032) for each i with 0 < i \u2264 n. With claims C1, C2 and C3, we can do so by induction on \u03b1. Again, we consider only the case that \u03b1 is of the form [\u03d5]\u03c8; other cases can be dealt with in the same way as the proof of Proposition 12.\nWe first show that knowledge structure FW |\u03d5 is equivalent to FW \u2032 , where W \u2032 = {w\u2032 \u2208 W | MW , w |= \u03d5}.\nAs the two knowledge structures have the same set V of propositional variables and, for each agent i, the same set Oi of observable variables to agent i, we need only to prove that they have the same set of states. An assignment s on V is a state of FW |\u03d5 iff s is a state of FW and FW , s |= \u03d5. Thus, by claim C3, s is a state of FW |\u03d5 iff s = g(w\u2032) for some w\u2032 \u2208 W with FW , g(w\u2032) |= \u03d5. On the other hand, we have, by claim C3 again, that assignment s is a state of FW \u2032 iff s = g(w\u2032) for some w\u2032 \u2208 W \u2032, i.e., w\u2032 \u2208 W and MW , w\u2032 |= \u03d5. However, by the induction assumption, FW , g(w\u2032) |= \u03d5 iff MW , w\u2032 |= \u03d5. Therefore, knowledge structures FW |\u03d5 and FW \u2032 have the same set of states.\nTo show (FW , g(w)) |= [\u03d5]\u03c8 iff (M |W , w) |= [\u03d5]\u03c8, we have, by the induction assumption, that (FW , g(w)) |= \u03d5 iff (M |W , w) |= \u03d5. Also, by the claim we just proved above, we have that (FW |\u03d5, g(w)) |= \u03c8 iff (FW \u2032 , g(w)) |= \u03c8. By the induction assumption again, (FW \u2032 , g(w)) |= \u03c8 iff MW \u2032 , w |= \u03c8. By the definition of W \u2032, we have that MW |\u03d5, w |= \u03c8. Hence, (FW |\u03d5, g(w)) |= \u03c8 iff MW |\u03d5, w |= \u03c8. Therefore, by the semantics of the announcement operators in Kripke structure and knowledge structure, we have that (FW , g(w)) |= [\u03d5]\u03c8 iff (M |W , w) |= [\u03d5]\u03c8. 2\nThe above proposition is a generalization of Propositions 11 and 12 to PALn, which shows that the satisfiability issue for a formula in the language of multi-agent S5 with the announcement operators is the same whatever satisfiability is meant w.r.t. a standard Kripke structure or w.r.t. a knowledge structure.\nNotice that, for every formula in PALn, we can get an equivalent propositional formula. More specifically, we have the following:\nRemark 29 Let V be a finite set of propositional variables and F = ({\u03b8}, V,O1, \u00b7 \u00b7 \u00b7 , On). Given a formula \u03b1 \u2208 PALn, we define a propositional formula b\u03b1e\u03b8 by induction on the structure of \u03b1:\n\u2022 If \u03b1 is a propositional formula, then b\u03b1e\u03b8 = \u03b1.\n\u2022 b\u03b1 \u2227 \u03b2e\u03b8 = b\u03b1e\u03b8 \u2227 b\u03b2e\u03b8.\n\u2022 bKi\u03b1e\u03b8 = \u2200(V \u2212Oi)(\u03b8 \u21d2 b\u03b1e\u03b8).\n\u2022 Let \u2206 \u2286 {1, \u00b7 \u00b7 \u00b7 , n}, V\u2206 = {Oi | i \u2208 \u2206}. Then\nbC\u2206\u03b1e\u03b8 = WSCb\u03b1e \u03b8\n\u2206\nwhere WSCb\u03b1e \u03b8\n\u2206 is a weakest V\u2206-sufficient condition b\u03b1e\u03b8 under \u03b8.\n\u2022 b[\u03d5]\u03b1e\u03b8 = b\u03b1e\u03b8\u2227b\u03d5e\u03b8\nThen, for every \u03b1 \u2208 PALn, we have that F |= \u03b1 \u21d4 b\u03b1e\u03b8."}, {"heading": "6. Complexity Results", "text": "We are interested in the following problem: given a knowledge structure F and a formula \u03b1 in the language of epistemic logic, whether formula \u03b1 is realized in structure F . This kind of problem is called the realization problem. In this section, we examine the inherent difficulty of the realization problem in terms of computational complexity. In the general case, this problem is PSPACE-Complete; however, for some interesting subset of the language, it can be reduced to co-NP.\nLet L be some epistemic logic (or language). The realization problem for L is, given a knowledge structure F and a formula \u03b1 \u2208 L, to determine whether F |= \u03b1 holds.\nThe realization problem here is closely related to the model checking problem: given an epistemic formula \u03b1 and a Kripke structure M , to determine whether M |= \u03b1. By checking the definition of Kripke structure semantics for epistemic logic, we can see that the model checking problem can be solved in polynomial time (with respect to the input size (| M | + | \u03b1 |). We can determine whether a formula \u03b1 is realized in a knowledge structure F by first translating knowledge structure F into a Kripke structure M then checking M |= \u03b1. However, the resulting algorithm will be exponential in space. This is because the size of the corresponding Kripke structure M is exponential with respect to knowledge structure F .\nA number of algorithms for model checking epistemic specifications and the computational complexity of the related realization problems were studied in (van der Meyden, 1998). However, like Kripke structure, the semantics framework they adopt is to list all global states explicitly. As a result, the size of the input of the concerned decision problem can be very large.\nProposition 30 The realization problem for Ln is PSPACE-complete.\nProof: The proposition is of two parts: the PSPACE-easiness and the PSPACE-hardness. The PSPACE-easiness part means that there is an algorithm that determines in polynomial space whether an epistemic formula \u03b1 \u2208 Ln is realized in a knowledge structure F . The PSPACE-completeness indicates that there is a PSPACE-hard problem, say the satisfiability problem for quantified propositional formulas (QBF) (Stockmeyer & Meyer, 1973), can be effectively reduced to the realization problem we consider.\nIt is not difficult to see the PSPACE-easiness. Given a knowledge structure and epistemic formula \u03b1, by Corollary 14, we can replace knowledge modalities by propositional quantifiers in formula \u03b1. So, the problem of whether \u03b1 is realized in F is reduced to determine whether a quantified Boolean formulas is valid. The latter can be done in polynomial space (Stockmeyer & Meyer, 1973).\nAs for the PSPACE-hardness, it suffices to show that for every QBF formula\n\u2200p1\u2203q2\u2200p2\u2203q3 \u00b7 \u00b7 \u00b7 \u2200pm\u22121\u2203qmA(p1, q2, p2, q3 \u00b7 \u00b7 \u00b7 , pm\u22121, qm),\nwe can construct a knowledge structure F such that\n` \u2200p1\u2203q2\u2200p2\u2203q3 \u00b7 \u00b7 \u00b7 \u2200pm\u22121\u2203qmA(p1, q2, p2 \u00b7 \u00b7 \u00b7 , pm\u22121, qm) iff\nF |= d1 \u2227 \u00acd2 \u21d2 (K1\u00acK2\u00ac)m\u22121(dm \u2227A(p1, q2, p2, q3 \u00b7 \u00b7 \u00b7 , pm\u22121, qm)). Let F = (V, {\u03b8}, O1, O2), where 1. V = {c} \u222a {d1, \u00b7 \u00b7 \u00b7 , dm} \u222a {d\u20321, \u00b7 \u00b7 \u00b7 , d\u2032m} \u222a {p1, \u00b7 \u00b7 \u00b7 , pm} \u222a {q1, \u00b7 \u00b7 \u00b7 , qm} 2. \u03b8 is the conjunction of the following formulas\n(a) \u2227\nj<m\n(dj+1 \u21d2 dj) \u2227 (d\u2032j+1 \u21d2 d\u2032j)\n(b) \u2227\nj<m\n dj \u2227 \u00acdj+1 \u21d2 \u2227\ni6=j (pi \u21d4 qi)\n \n(c) c \u21d2 \u2227\nj<m+1\n(dj \u21d4 d\u2032j)\n(d)\n\u00acc \u21d2  ((dm\u22121 \u2227 \u00acdm) \u21d4 d\u2032m ) \u2227 \u2227\nj<m\u22121\n( (dj \u2227 \u00acdj+1) \u21d4 (d\u2032j+1 \u2227 \u00acd\u2032j+2)\n)  \n3. O1 = {c} \u222a {d1, \u00b7 \u00b7 \u00b7 , dm} \u222a {q1, \u00b7 \u00b7 \u00b7 , qm} 4. O2 = {d\u20321, \u00b7 \u00b7 \u00b7 , d\u2032m} \u222a {p1, \u00b7 \u00b7 \u00b7 , pm}\nIn our picture, we have only two agents: agents 1 and 2. We assign every state an integer number, called the depth of the state for convenience. For every j, dj expresses that the depth of the state is at least j. Propositions d1, \u00b7 \u00b7 \u00b7 , dm are observable to agent 1, but not to agent 2. Nevertheless, agent 2 can observe d\u20321, \u00b7 \u00b7 \u00b7 , d\u2032m, which are closely related to d1, \u00b7 \u00b7 \u00b7 , dm. The formula in item 2c indicates that d\u20321, \u00b7 \u00b7 \u00b7 , d\u2032m are the same as d1, \u00b7 \u00b7 \u00b7 , dm if c holds, while the formula in item 2d says that, if c does not hold, the depth expressed by d1, \u00b7 \u00b7 \u00b7 , dm is less than that by d\u20321, \u00b7 \u00b7 \u00b7 , d\u2032m and the difference is 1. The formula in item 2b implies that, under the condition that the depth of the state is exactly j, only pj is unobservable to agent 1 and only qj is unobservable to agent 2.\nIn order to show that\n` \u2200p1\u2203q2\u2200p2\u2203q3 \u00b7 \u00b7 \u00b7 \u2200pm\u22121\u2203qmA(p1, q2, p2 \u00b7 \u00b7 \u00b7 , pm\u22121, qm) implies\nF |= d1 \u2227 \u00acd2 \u21d2 (K1\u00acK2\u00ac)m\u22121(dm \u2227A(p1, q2, p2, q3 \u00b7 \u00b7 \u00b7 , pm\u22121, qm)),\nit suffices to prove that, for every j \u2264 m and propositional formula \u03d5 over p1, \u00b7 \u00b7 \u00b7 , pm, q1, \u00b7 \u00b7 \u00b7 , qm,\nF |= dj \u2227 \u00acdj+1 \u2227 \u2200pj\u2203qj+1\u03d5 \u21d2 K1\u00acK2\u00ac(dj+1 \u2227 \u00acdj+2 \u2227 \u03d5) To do so, we need only to show that\nF |= dj \u2227 \u00acdj+1 \u2227 \u2200pj\u03d5 \u21d2 K1(dj \u2227 \u00acdj+1 \u2227 \u03d5) and\nF |= dj \u2227 \u00acdj+1 \u2227 \u2203qj+1\u03d5 \u21d2 \u00acK2\u00ac(dj+1 \u2227 \u00acdj+2 \u2227 \u03d5). As for the other direction, we notice that, for each l < m\u2212 1,\nF |= d1 \u2227 \u00acd2 \u21d2 (K1K2)l\u00acdl+2. We also notice that, for each 1 < m\u2032 \u2264 m,\nF |= K1\u00acK2dm\u2032 \u21d2 dm\u2032\u22121 and F |= dm\u2032\u22121 \u2227 \u00acdm\u2032 \u2227K1\u00acK2\u00ac(dm\u2032 \u2227 \u03d5) \u21d2 \u2200pm\u2032\u22121\u2203qm\u2032\u03d5. By applying the above three claims repeatedly, we can obtain that\nF |= d1 \u2227 \u00acd2 \u2227 (K1\u00acK2\u00ac)m\u22121(dm \u2227 \u03d5) \u21d2 \u2200p1\u2203q2\u2200p2\u2203q3 \u00b7 \u00b7 \u00b7 \u2200pm\u22121\u2203qm\u03d5. Therefore, if\nF |= d1 \u2227 \u00acd2 \u21d2 (K1\u00acK2\u00ac)m\u22121(dm \u2227 \u03d5) then we have that \u2200p1\u2203q2\u2200p2\u2203q3 \u00b7 \u00b7 \u00b7 \u2200pm\u22121\u2203qm\u03d5 is satisfiable in F because so is d1 \u2227 \u00acd2. However, as the QBF formula \u2200p1\u2203q2\u2200p2\u2203q3 \u00b7 \u00b7 \u00b7 \u2200pm\u22121\u2203qm\u03d5 does not contain any free variable, we immediately conclude that the QBF formula is valid from that QBF formula is satisfiable in F . 2\nBy Remark 29, we can see that, for the language of formulas in PALn without common knowledge operators, the realization problem can be reduced to the problem of validness problem of quantified Boolean formulas, and hence is PSPACE-complete by Proposition 30. We conjecture that the realization problem is also PSPACE-complete for LCn and PALn.\nProposition 30 indicates that the realization problem in the general case is hard for a computer to solve. Thus, it is interesting to give some special cases with lower computational complexity. Let L+Kn be the fragment of positive formulas in Ln. It consists of those formulas such that the negation can be applied only to propositional formulas and the modalities are restricted to K1, \u00b7 \u00b7 \u00b7 ,Kn. For instance, formula K1K2p\u2228K1K2\u00acp (where p is a propositional formula) belongs to L+Kn , but formula K1K2p \u2228K1\u00acK2p does not.\nThe sublanguage L+Kn is interesting in that it is sufficient to represent most important security properties for security protocols. Moreover, as shown in the following proposition, the complexity of the realization problem for L+Kn is co-NP-complete.\nProposition 31 The realization problem for L+Kn is co-NP-complete.\nProof: It is well-known that the validity problem for propositional formulas is co-NPcomplete. We can easily get the co-NP-hardness of the realization problem for L+Kn , because the validity problem for propositional formulas can be reduced to the realization problem for propositional formulas (considering the case where background knowledge base is a tautology).\nOn the other hand, to show the realization problem for L+Kn is in co-NP, we show it can be reduced to the validity problem of propositional formulas. Given a knowledge structure F and formula \u03d5 in L+Kn , we will translate \u03d5 into a propositional formula \u2016\u03d5\u2016F (which will be define below), so that \u03d5 is realized in F iff \u03b8 \u21d2 \u2016\u03d5\u2016F is valid, where \u03b8 is the background knowledge base of knowledge structure F .\nSuppose F = (V, {\u03b8}, O1, \u00b7 \u00b7 \u00b7 , On). For every subformula Ki\u03c8 of \u03d5, we introduce a set V i\u03c8 of new propositional variables such that | V i\u03c8 |=| V \u2212Oi |.\nThe propositional translation \u2016\u03d5\u2016F is inductively given as follows. 1. If \u03d5 is a propositional formula, then \u2016\u03d5\u2016F = \u03d5. 2. If \u03d5 is of the conjunction form \u03d51 \u2227 \u03d52, then\n\u2016\u03d5\u2016F = \u2016\u03d51\u2016F \u2227 \u2016\u03d52\u2016F .\n3. If \u03d5 is of the disjunction form \u03d51 \u2228 \u03d52, then\n\u2016\u03d5\u2016F = \u2016\u03d51\u2016F \u2228 \u2016\u03d52\u2016F .\n4. If \u03d5 is of the form Ki\u03c8, then\n\u2016\u03d5\u2016F = (\u03b8 \u21d2 \u2016\u03c8\u2016F )(V \u2212Oi V i\u03c8 ),\nwhere (\u03b8 \u21d2 \u2016\u03c8\u2016F )(V\u2212OiV i \u03c8 ) is the formula obtained from (\u03b8 \u21d2 \u2016\u03c8\u2016F ) by replacing variables in V \u2212Oi by the new ones in V i\u03c8.\nThe idea behind the above translation is that we first translate formula \u03d5 into a quantified propositional formula, where all the quantifiers are universal ones, and then eliminate those universal quantifiers by introducing new variables.\nLet V\u03d5 be the set of new variables in \u2016\u03d5\u2016F . To show the correctness of the translation, it suffices to show that F |= \u03d5 \u21d4 \u2200V\u03d5\u2016\u03d5\u2016F .\nWe prove this claim by induction on \u03d5.\n\u2022 It is trivial, if \u03d5 is a propositional formula.\n\u2022 If \u03d5 is of the form \u03d51 \u2227 \u03d52, the claim can be obtained immediately by the induction assumption.\n\u2022 If \u03d5 is of the form \u03d51 \u2228 \u03d52, we have that \u2200V\u03d5(\u2016\u03d51\u2016F \u2228 \u2016\u03d52\u2016F ) is logically equivalent to \u2200V\u03d51\u2016\u03d51\u2016F \u2228 \u2200V\u03d52\u2016\u03d52\u2016F , as the variables in V\u03d51 do not appear in \u2200V\u03d52\u2016\u03d52\u2016F and those in V\u03d52 do not in \u2200V\u03d51\u2016\u03d51\u2016F . Thus, the claim holds by the induction assumption.\n\u2022 Finally, if \u03d5 is of the form Ki\u03c8, then\n\u2016\u03d5\u2016F = (\u03b8 \u21d2 \u2016\u03c8\u2016F )(V \u2212Oi V i\u03c8 ).\nTherefore, V\u03d5 = V\u03c8\u222aV i\u03c8 and \u2200V\u03d5\u2016\u03d5\u2016F is logically equivalent to (\u03b8 \u21d2 \u2200V i\u03c8\u2200V\u03c8\u2016\u03c8\u2016F )(V\u2212OiV i \u03c8 ). Thus, by the induction assumption, we have that\nF |= \u2200V\u03d5\u2016\u03d5\u2016F \u21d4 (\u03b8 \u21d2 \u2200V i\u03c8\u03c8( V \u2212Oi\nV i\u03c8 )\nand hence\nF |= \u2200V\u03d5\u2016\u03d5\u2016F \u21d4 (\u03b8 \u21d2 \u2200(V \u2212Oi)\u03c8).\nTherefore, we have F |= \u2200V\u03d5\u2016\u03d5\u2016F \u21d4 Ki\u03c8. 2\nProposition 31 implies that, for an arbitrary formula \u03d5 in L+Kn and a knowledge structure F with background knowledge base \u03b8,\nF |= \u03d5 iff \u03b8 \u2227 \u00ac\u2016\u03d5\u2016F is unsatisfiable.\nThus, we can solve the realization problem for formulas in L+Kn by using a propositional satisfiability solver."}, {"heading": "7. A Case Study: the Muddy Children Puzzle", "text": "In this section, we demonstrate how our framework can be applied to practical problems by using the example of the muddy children puzzle."}, {"heading": "7.1 Muddy Children Puzzle", "text": "The muddy children puzzle is a well-known variant of the wise men puzzle. The story goes as follows (Fagin et al., 1995): Imagine n children playing together. Some of the children, say k of them, get mud on their foreheads. Each can see the mud on others but not on his/her own forehead. Along comes the father, who says, \u201cat least one of you has mud on your forehead.\u201d The father then asks the following question, over and over: \u201cDoes any of you know whether you have mud on your own forehead?\u201d\nAssuming that all children are perceptive, intelligent, truthful, and they answer simultaneously, what we want to show is that the first (k\u2212 1) times the father asks the question, they will say \u201cNo\u201d but the kth time the children with muddy foreheads will all answer \u201cYes.\u201d"}, {"heading": "7.2 Modeling the Muddy Children Puzzle", "text": "To model the muddy children puzzle, let mi be a propositional variable, which means that child i is muddy (i < n). Denote by V the set {mi | i < n}. Suppose the assignment s0 = {mi | i < k} represents the actual state: child 0, \u00b7 \u00b7 \u00b7, child k \u2212 1 have mud on their foreheads; and the other children have not. This can be captured by the scenario (F0, s0), where F0 = (V, \u03930, O0, \u00b7 \u00b7 \u00b7 , On\u22121) with\n\u2022 V = {mi | i < n};\n\u2022 \u03930 = \u2205;\n\u2022 and Oi = V \u2212 {mi} for each i < n. Let \u03d5 = \u2227\ni<n \u00acKimi, which indicates that every child does not know whether he has mud on his own forehead. For convenience, we introduce, for all natural number l, the notations [\u03d5]l\u03c8 so that [\u03d5]0\u03c8 = \u03c8 and [\u03d5]l+1\u03c8 = [\u03d5][\u03d5]l\u03c8. The properties we want to show is then formally expressed in PALn:\n\u2022 [\u2228i<n mi][\u03d5]j\u03d5 for every 0 \u2264 j < k \u2212 1, and \u2022 [\u2228i<n mi][\u03d5]k\u22121 \u2227 i<k Kimi.\nFormula [ \u2228\ni<n mi][\u03d5] j\u03d5 means that the children will all say \u201cNo\u201d for the j + 1th time the\nfather asks the question. In particular, when j = 0, the condition 0 \u2264 j < k\u22121 is simplified as k > 1; and the resulting formula [ \u2228 i<n mi]\u03d5 says that after the father announces \u2228 i<n mi\nevery child says \u201cNo\u201d. Formula [ \u2228 i<n mi][\u03d5] k\u22121 \u2227 i<k Kimi indicates that the k th time the children with muddy foreheads will all answer \u201cYes.\u201d Therefore, what we want to prove is that\n(F0, s0) |=   \u2227\n0\u2264j<k\u22121 [ \u2228 i<n mi][\u03d5]j\u03d5\n  \u2227  [ \u2228\ni<n\nmi][\u03d5]k\u22121 \u2227\ni<k\nKimi\n  .\nTo check the above, we basically follow the definition of PAL semantics under knowledge structure. During the checking process, a series Fj (0 < j \u2264 k) of knowledge structures are constructed so that F1 = F0 |\u2228\ni<n mi\nand, for every j (0 < j < k), Fj+1 = Fj |\u03d5.\nSpecifically, we have that, for each step j \u2264 k, we get\nFj = (V, \u0393j , O0, \u00b7 \u00b7 \u00b7 , On\u22121)\nwhere Oi = V \u2212 {mi} for each i < n, and \u0393j is defined as follows:\n\u2022 At step 1: \u03931 = { \u2228 i<n mi}. \u2022 At step j + 1: Let \u03d5b = \u2227i<n \u00ac\u2200mi(\u0393j \u21d2 mi). As for each i < n, Fj |= Kimi \u21d4 \u2200mi(\u0393j \u21d2 mi), we have that Fj |= \u03d5 \u21d4 \u03d5b. Thus, we may set \u0393j+1 = \u0393j \u222a { \u03d5b } .\nTherefore, it suffices to verify, for 0 < j < k and i < n, (Fj , s0) |= \u00acKimi, and for i < k, (Fk, s0) |= Kimi."}, {"heading": "7.3 Experimental Results", "text": "Our framework of knowledge structure has been implemented by using the BDD library (CUDD) developed by Fabio Somenzi at Colorado University. Notice that BDD-based QBF solvers for satisfiability problems are not among the best solvers nowadays. However, in the experiments here we need to compute and represent a serial of Boolean functions (say \u0393j), which are not decision problems and can not be solved by a general QBF solver.\nTo check agents\u2019 knowledge, we implemented two different algorithms in terms of Part 1 and 2 of Corollary 19 in Section 3, respectively. Algorithm 1, which is based on part 1 of Corollary 19, seems much more efficient than Algorithm 2, which is based on part 2 of Corollary 19, for this particular example. The reason is as follows. It is clear that the main task of both algorithms is to check whether (Fj , s0) |= Kimi. However, Algorithm 1\u2019s method is to compute s0 |= \u2200mi(\u0393j \u21d2 mi), while Algorithm 2 is to compute |= \u2203mi(\u0393j \u2227 s0) \u21d2 mi. Now the main reason why Algorithm 1 is much more efficient for this particular problem is clear: \u2200mi(\u0393j \u21d2 mi) is simply equivalent to \u00ac\u0393j( mifalse). Assuming half of the children are muddy, Fig. 1 gives the performances for a Pentium IV PC at 2.4GHz, with 512RAM. In the figure, the x-axis is for the number of children, and the y-axis for the CPU run time in seconds.\nThe muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999). Proof-theoretic approaches depend on efficient provers for multi-modal logics; and semantical ones may suffer from the state-explosion problem. Our approach is essentially a semantic one, but we give a syntactical and compact way to represent Kripke structures by using knowledge structures, and hence may avoid the state-explosion problem to some extent."}, {"heading": "8. Application to Verification of Security Protocols", "text": "In this section, we apply our knowledge model to security protocol verification. Security protocols that set up credits of the parties and deal with the distribution of cryptographic keys are essential in communication over vulnerable networks. Authentication plays a key role in security protocols. Subtle bugs that lead to attack are often found when the protocols have been used for many years. This presents a challenge of how to prove the correctness of a security protocol. Formal methods are introduced to establish and prove whether a secure protocol satisfies a certain authentication specification."}, {"heading": "8.1 Background on Authentication Protocols", "text": "Authentication protocols aim to coordinate the activity of different parties (usually referred to as principals) over a network. They generally consist of a sequence of message exchanges whose format is fixed in advance and must be conformed to. Usually, a principal can take part into a protocol run in different ways, as the initiator or the responder ; we often call the principal has different roles. Very often a principal can take part into several protocol runs simultaneously with different roles.\nThe designers of authentication protocols must have the conscious in mind that the message may be intercepted and someone with malicious intention can impersonate an honest principal. One of the key issues in authentication is to ensure the confidentiality, that is, to prevent private information from being disclosed to unauthorized entities. Another issue is to avoid intruder impersonating other principals. In general, a principal should ensure that the message he receives was created recently and sent by the principal who claims to have sent it.\nCryptography is a fundamental element in authentication. A message transmitted over a channel without any cryptographic converting is called plaintext. The intention of cryptography is to transform a given message to some form that is unrecognizable by anyone except the intended receiver. The procedure is called encryption and the corresponding parameter is known as encryption key. The encoded message is referred to as ciphertext. The reverse procedure is called decryption and uses the corresponding decryption key. The symmetric-key cryptography, which is also called secret-key cryptography, uses the same key for both encryption and decryption. The asymmetric-key cryptography, which is also called public-key cryptography, uses different keys for encryption and decryption. The one for the encryption is the public key that is generally available for anyone. Corresponding to the public key is the private key, which is for the decryption and only owned by one principal."}, {"heading": "8.2 The Dolev-Yao Intruder Model", "text": "The standard adversary model for the analysis of security protocols was introduced by Dolev and Yao in 1983 and is commonly known as Dolev-Yao model (Dolev & Yao, 1983). According to this model, a set of conservative assumptions are made as follows:\n1. Messages are considered as indivisible abstract values instead of sequences of bits.\n2. All the messages from one principal to any other principals must pass through the adversary and the adversary acts as a general router in the communication.\n3. The adversary can read, alter and redirect any message.\n4. The adversary can only decrypt a message if he has the right keys, and can only compose new messages from keys and messages that he already possesses.\n5. The adversary can not perform any statistical or other cryptanalytic attacks.\nAlthough this model has the drawback of finding implementation dependent attacks, it simplifies the protocol analysis. It has been proved to be the most powerful modeling of the adversary (Cervesato, 2001) because it can simulate any other possible attackers."}, {"heading": "8.3 The Revised Needham-Schroeder Protocol", "text": "As Lowe (1996) pointed out, the Needham-Schroeder protocol has the problem of lacking the identity of the responder and can be fixed by a small modification. However, it is not clear if the revised version is correct. Our approach provides a method to automatically prove the correctness of security protocols instead of just finding bugs as usual analysis tools do for security protocols.\nIn the cryptography literature, the revised Needham-Schroeder protocol is described as follows:\n1. A \u2192 B: {Na, A}Kb 2. B \u2192 A: {B,Na, Nb}Ka 3. A \u2192 B: {Nb}Kb\nwhere A \u2192 B : M is a notation for \u201cA sends B the message M \u201d or \u201cB receives the message M from A\u201d. The notation {M}K means the encryption of M with the key K. Also, A,B denote the principal identifiers; and Ka, Kb indicate, respectively, A\u2019s and B\u2019s public keys. Moreover, Na and Nb are the nonces which are newly generated unguessable values by A and B, respectively, to guarantee the freshness of messages.\nTwo informal goals or specifications of the protocol are \u201cA knows that B knows A said Na and Na is fresh,\u201d and \u201cB knows that A knows B said Nb and Nb is fresh .\u201d\nTo analyze the protocol, we introduce A and B local histories for the protocol: If A plays the role of the initiator in the protocol, and assumes that B be the responsor, then A\u2019s local history is that\n1. A said {Na,A}KbA\n2. A sees {BA, Na, NbA}Ka 3. A said {NbA}KbA\nwhere \u201cA said M\u201d means that A sent the message M , or other message containing M ; \u201cA sees M\u201d indicates that A receives M or got M by some received messages; BA is the responsor of the protocol from A\u2019s local view; KbA and NbA are, from A\u2019s local view, the responsor\u2019s public key and nonce, respectively.\nIf B plays the role of the responsor in the protocol, and assumes A be the initiator, then A\u2019s local history is that\n1. B sees {NaB, AB}Kb 2. B said {B,NaB, Nb}Ka 3. B sees {Nb}Kb\nwhere AB is the initiator of the protocol from B\u2019s local observations; KaB and NaB are, from B\u2019s local view, the initiator\u2019s public key and nonce, respectively.\nThe main point of our analysis is that if an agent is involved in the protocol, then the agent\u2019s real observations should be compatible with the so-called local history. For example, if A is the initiator of the protocol, and A sees {B,NaB, Nb}Ka, then according to A\u2019s local history for the protocol we have that A assumes that B is the responsor of the protocol, the responsor\u2019s nonce is Nb, and from the responsor\u2019s view, the initiator\u2019s nonce is Na (see the 4th formula of the background knowledge \u0393 below).\nLet us see how our framework of reasoning about knowledge can be applied to this protocol.\nThe variable set VRNS consists of the following atoms:\n\u2022 fresh(Na): Nonce Na is fresh. \u2022 fresh(Nb): Nonce Nb is fresh. \u2022 role(Init, A): A plays the role of the initiator of the protocol. \u2022 role(Resp, B): B plays the role of the responder of the protocol. \u2022 RespA = B: A assumes that the responder of the protocol is B. \u2022 InitB = A: B assumes that the initiator of the protocol is A. \u2022 NaB = Na: B assumes that the partner\u2019s nonce in the execution of the protocol is\nNa.\n\u2022 NbA = Nb: A assumes that the partner\u2019s nonce in the execution of the protocol is Nb.\n\u2022 said(B,Na): B said Na by sending a message containing Na. \u2022 said(A,Nb): A said Nb.\n\u2022 sees(B, {Na, A}Kb): B sees {Na,A}Kb (possibly by decrypting the messages received.)\n\u2022 sees(A, {B,NaB, Nb}Ka): A sees {B,NaB, Nb}Ka.\nThe background knowledge \u0393RNS consists of the following formulas:\n1.  \nsees(B, {Na,A}Kb)\u2227 said(B,Na)\u2227 fresh(Na)\n  \u21d2 role(Resp, B)\n2.  \nsees(A, {B,NaB, Nb}Ka)\u2227 said(A,Nb)\u2227 fresh(Nb)\n  \u21d2 role(Init, A)\n3.   role(Resp, B)\u2227 sees(B, {Na,A}Kb)\u2227 said(B,Na)\u2227 fresh(Na)   \u21d2 ( InitB = A\u2227 NaB = Na )\n4.  \nrole(Init, A)\u2227 sees(A, {B,NaB , Nb}Ka)\u2227 said(A,Nb)\u2227 fresh(Nb)\n  \u21d2  \nRespA = B\u2227 NaB = Na\u2227 NbA = Nb\n \n5. ( role(Init, A)\u2227 RespA = B ) \u21d2 ( sees(B, {Na, A}Kb)\u2227 said(B,Na) ) 6. (\nrole(Resp, B)\u2227 InitB = A\n) \u21d2 ( sees(A, {B,NaB , Nb}Ka)\u2227 said(A,Nb) )\n7. (role(Init, A) \u21d2 fresh(Na))\u2227 (role(Resp, B) \u21d2 fresh(Nb))\nNotice that the first two formulas are required for the rationality of the agents A and B. The other formulas in \u0393 can be obtained automatically by some fixed set of meta rules. We obtain the third and fourth formulas by comparing their local history for the protocols to the conditions appearing in the formulas. To get the fifth formula informally, consider A\u2019s local history under the conditions role(Init, A) and RespA = B, which should be that\n1. A said {Na,A}Kb 2. A sees {B,Na, NbA}Ka 3. A said {NbA}Kb.\nAccording to A\u2019s local history, A sees the nonce Na generated by A itself. Because Na is only said in the message {Na,A}Kb, thus B, who has the inverse key of Kb, must see this message and said Na. Similarly, we can see that the sixth formula holds. The last formula follows immediately by the definition of the protocol.\nThe set OA of the observable variables to A is\n{fresh(Na), role(Init, A), RespA = B}.\nThe set OB of the observable variables to B is\n{fresh(Nb), role(Resp, B), InitB = A}.\nNow consider the knowledge structure\nF = (VRNS ,\u0393RNS , OA, OB).\nLet SpecA be the formal specification:  \nfresh(Na)\u2227 role(Init, A)\u2227 RespA = B\n  \u21d2 KAKB ( said(A,Na)\u2227 fresh(Na) )\nand SpecB be the formal specification:  \nfresh(Nb)\u2227 role(Resp, B)\u2227 InitB = A\n  \u21d2 KBKA ( said(B,Nb)\u2227 fresh(Nb) ) .\nIt is easy to show that, for all states s of F ,\n(F , s) |= SpecA \u2227 SpecB as desired.\nWe should mention that, in the original Needham-Schroeder protocol (Needham & Schroeder, 1978), the second message is B \u2192 A: {Na, Nb}Ka instead of B \u2192 A: {B,Na, Nb}Ka. Therefore, the fourth formula in \u0393 would be changed to\n \nrole(Init, A)\u2227 sees(A, {NaB , Nb}Ka)\u2227 said(A,Nb)\u2227 fresh(Nb)\n  \u21d2 ( NaB = Na\u2227 NbA = Nb )\nThus, RespA = B does not necessarily hold under the condition\nrole(Init, A) \u2227 sees(A, {NaB, Nb}Ka) \u2227 said(A,Nb) \u2227 fresh(Nb).\nThis is why the specifications SpecA and SpecB do not hold for the original NeedhamSchroeder protocol."}, {"heading": "8.4 Discussion", "text": "BAN logic (Burrows, Abadi, & Needham, 1990) is one of the most successful logical tools to reason about security protocols. However, the semantics of BAN is always arguable, and it is not clear under what assumption the rules of BAN logic is sound and complete. This\nmotivated the research of seeking more adequate frameworks (models). Providing a modeltheoretic semantics for BAN logic has been a central idea in the development of BAN-like logics such as AT (Abadi & Tuttle, 1991) and SVO (Syversion & van Oorschot, 1996). The advantage of our approach is that we use knowledge structures as semantic models to verify the correctness of epistemic goals for security protocols.\nAn important problem is that, given a security protocol, where and how the corresponding knowledge structure comes from. To get the knowledge structure corresponding to a security protocol, we have developed a semantic model, and the background knowledge base of the corresponding knowledge structure consists of those formulas valid in the semantic model. Moreover, we can generate the background knowledge systematically. The ongoing work is to implement our approach into a promising automatic security protocol verifier."}, {"heading": "9. Related Work", "text": "There are a number of approaches dealing with the concept of variable forgetting or eliminations of middle terms (Boole, 1854) in several contexts. The notion of variable forgetting was formally defined in propositional and first order logics by Lin and Reiter (1994). In recent years, theories of forgetting under answer set programming semantics were proposed (Zhang & Foo, 2006; Eiter & Wang, 2008). Forgetting was also generalized to description logics (Kontchakov, Wolter, & Zakharyaschev, 2008; Wang, Wang, Topor, & Pan, 2008; Kontchakov, Walther, & Wolter, 2009).\nIn the context of epistemic logic, the notion of forgetting was studied in a number of ways. Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect \u00acK\u03d5 \u2227 \u00acK\u00ac\u03d5: after knowledge forgetting \u03d5, the agent would neither know \u03d5 nor \u00ac\u03d5. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]\u03d5 means that after the agent forgets his knowledge about p, \u03d5 is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003).\nThe notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases. Lang and Marquis (2002) used it for merging a set of knowledge bases when simply taking their union may result in inconsistency. The notion of variable forgetting is also closely related to that of formula-variable independence, because the result of forgetting the set of variables V in a formula \u03d5 can be defined as the strongest consequence of \u03d5 being independent from V (Lang et al., 2003). More recently, Liu and Lakemeyer (2009) applied the notion of forgetting into the situation calculus, and obtained some interesting results about the first-order definability and computability of progression for local-effect actions."}, {"heading": "10. Conclusion", "text": "The main contribution of this paper is as follows. First, we have investigated knowledge reasoning within a simple framework called knowledge structure, which consists of a global\nknowledge base and a set of observable variables for each agent. The notion of knowledge structure can be used as a semantic model for a multi-agent logic of knowledge and common knowledge. In this model, the computation of knowledge and common knowledge can be reduced to the operation of variable forgetting; moreover, an objective formula \u03b1 is known by agent i at state s when any of its weakest sufficient condition on Oi holds at state s.\nSecond, to capture the notion of common knowledge in our framework, we have generalized the notion of weakest sufficient conditions and obtained, for a set V of sets of propositional variables, the notion of the weakest V-sufficient conditions. Given a set \u2206 of agents and a family V\u2206 of observable variable sets of these agents, we have shown that an objective formula \u03b1 is common knowledge for agents in \u2206 iff the weakest {Oi | i \u2208 \u2206}-sufficient of \u03b1 holds. Also, we have shown that public announcement operator can be conveniently dealt with via our notion of knowledge structure.\nThird, the relationship between S5 Kripke structure and knowledge structure has been explored. Specifically, the satisfiability issue for a formula in the language of multi-agent S5 with public announcement operator is the same as what satisfiability is meant w.r.t. a standard Kripke structure or w.r.t. a knowledge structure.\nFourth, we have examined the computational complexity of the problem whether a formula \u03b1 is realized in structure F . In the general case, this problem is PSPACE-hard; however, there are some interesting subcases in which it can be reduced to co-NP.\nFinally, we have shown the strength of the concept of knowledge structure from the practical side by some empirical results about the satisfiability problem for knowledge structures based on the instances of the muddy children puzzle, since even for the smallest instances considered in the experiments generating the corresponding S5 Kripke structure would be out of reach. we have also discussed the automated analysis and verification of the corrected Needham-Schroeder protocol via knowledge structures.\nOur work presented in this paper can be further extended in several directions. First, we will investigate whether our knowledge structures can be extended and used as a basis for knowledge based programming (Fagin et al., 1995). Secondly, in our current framework of knowledge structures, we have not considered the issue of only knowing which has been extensively studied in other knowledge reasoning models (Halpern & Lakemeyer, 1996; van der Hock, Jaspars, & Thijsse, 2003; Levesque, 1990). It will be an interesting topic of how our knowledge model handles only knowing in reasoning about knowledge. Thirdly, the notions and methods in this work can be extended to investigate the extension of the variable forgetting operator to multi-agent logics of beliefs. Finally, recent research has shown that knowledge update has many important applications in reasoning about actions and plans and dynamic modeling of multi-agent systems (Zhang, 2003). A first step in this direction (in mono-agent S5) can be found in the work of Herzig, Lang and Marquis (2003). Baral and Zhang have proposed a general model for performing knowledge update based on the standard single agent S5 modal logic (Baral & Zhang, 2001). We believe that their work can be extended to multi-agent modal logics by using the knowledge structure defined in this paper and therefore to develop a more general system for knowledge update. Along this direction, an interesting research issue is to explore the underlying relationship between knowledge forgetting - a specific type of knowledge update, and variable forgetting as addressed in this paper."}, {"heading": "Acknowledgments", "text": "The authors thank Ron van der Meyden, Fangzheng Lin and the anonymous reviewers for their valuable comments on an earlier version of this paper. This work was partially supported by the Australian Research Council grant DP0452628, the National Basic Research 973 Program grants (Nos. 2010CB328103, 2009CB320701 and 2005CB321902), and National Natural Science Foundation of China grants (Nos. 60725207 and 60763004). This paper is the revised and extended version of a paper which appeared in Proceedings of KR 2004 (Su, Lv, & Zhang, 2004)"}], "references": [{"title": "A semantics for a logic of authentication", "author": ["M. Abadi", "M. Tuttle"], "venue": "In Proceedings of the Tenth Annual ACM Symposium on Principles of Distributed Computing,", "citeRegEx": "Abadi and Tuttle,? \\Q1991\\E", "shortCiteRegEx": "Abadi and Tuttle", "year": 1991}, {"title": "The logic of public announcements and common knowledge for distributed applications (extended abstract)", "author": ["A. Baltag", "L. Moss", "S. Solecki"], "venue": "In Proceedings of TARKVII,", "citeRegEx": "Baltag et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Baltag et al\\.", "year": 1998}, {"title": "On the semantics of knowledge update", "author": ["C. Baral", "Y. Zhang"], "venue": "In Proceedings of the 17th International Joint Conference on Artificial Intelligence", "citeRegEx": "Baral and Zhang,? \\Q2001\\E", "shortCiteRegEx": "Baral and Zhang", "year": 2001}, {"title": "Knowledge updates: semantic and complexity issues", "author": ["C. Baral", "Y. Zhang"], "venue": "Artificial Intelligence,", "citeRegEx": "Baral and Zhang,? \\Q2006\\E", "shortCiteRegEx": "Baral and Zhang", "year": 2006}, {"title": "An Investigation of the Laws of Thought", "author": ["G. Boole"], "venue": "Walton, London.", "citeRegEx": "Boole,? 1854", "shortCiteRegEx": "Boole", "year": 1854}, {"title": "A logic of authentication", "author": ["M. Burrows", "M. Abadi", "R.M. Needham"], "venue": "ACM Transactions on Computer Systems,", "citeRegEx": "Burrows et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Burrows et al\\.", "year": 1990}, {"title": "The Dolev-Yao intruder is the most powerful attacker", "author": ["I. Cervesato"], "venue": "Proc. 16th Annual Int. Symp on Logic in Computer Science.", "citeRegEx": "Cervesato,? 2001", "shortCiteRegEx": "Cervesato", "year": 2001}, {"title": "On the security of public-key protocols", "author": ["D. Dolev", "A. Yao"], "venue": "Communications of the ACM,", "citeRegEx": "Dolev and Yao,? \\Q1983\\E", "shortCiteRegEx": "Dolev and Yao", "year": 1983}, {"title": "Semantic forgetting in answer set programming", "author": ["T. Eiter", "K. Wang"], "venue": "Artificial Intelligence,", "citeRegEx": "Eiter and Wang,? \\Q2008\\E", "shortCiteRegEx": "Eiter and Wang", "year": 2008}, {"title": "Knowledge and the logic of local propositions", "author": ["K. Engelhardt", "R. van der Meyden", "Y. Moses"], "venue": "In Proceedings of TARK VII", "citeRegEx": "Engelhardt et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Engelhardt et al\\.", "year": 1998}, {"title": "Modal logics with a hierarchy of local propositional quantifiers", "author": ["K. Engelhardt", "R. van der Meyden", "K. Su"], "venue": "In Advance in Modal Logic,", "citeRegEx": "Engelhardt et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Engelhardt et al\\.", "year": 2003}, {"title": "Reasoning about knowledge", "author": ["R. Fagin", "J. Halpern", "Y. Moses", "M. Vardi"], "venue": null, "citeRegEx": "Fagin et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Fagin et al\\.", "year": 1995}, {"title": "Bisimulation on Plant Kripke", "author": ["J. Gerbrandy"], "venue": "Ph.D thesis, Institute for Logic, Language and Computation, University of Amsterdam.", "citeRegEx": "Gerbrandy,? 1999", "shortCiteRegEx": "Gerbrandy", "year": 1999}, {"title": "A guide to completeness and complexity for modal logics of knowledge and belief", "author": ["J. Halpern", "Y. Moses"], "venue": "Artificial Intelligence,", "citeRegEx": "Halpern and Moses,? \\Q1992\\E", "shortCiteRegEx": "Halpern and Moses", "year": 1992}, {"title": "A little knowledge goes a long way: Simple knowledge based derivations and correctness proofs for a family of protocols", "author": ["J. Halpern", "L. Zuck"], "venue": "Journal of the ACM,", "citeRegEx": "Halpern and Zuck,? \\Q1992\\E", "shortCiteRegEx": "Halpern and Zuck", "year": 1992}, {"title": "Multi-agent only knowing", "author": ["J.Y. Halpern", "G. Lakemeyer"], "venue": "In Proceedings of TARK VI,", "citeRegEx": "Halpern and Lakemeyer,? \\Q1996\\E", "shortCiteRegEx": "Halpern and Lakemeyer", "year": 1996}, {"title": "Action representation and partially observable planning using epistemic logic", "author": ["A. Herzig", "J. Lang", "P. Marquis"], "venue": "In Proceedings of IJCAI-03,", "citeRegEx": "Herzig et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Herzig et al\\.", "year": 2003}, {"title": "Knowledge and Belief", "author": ["J. Hintikka"], "venue": "Cornell University Press, Ithaca, NY.", "citeRegEx": "Hintikka,? 1962", "shortCiteRegEx": "Hintikka", "year": 1962}, {"title": "Forgetting and uniform interpolation in large-scale description logic terminologies", "author": ["R. Kontchakov", "D. Walther", "F. Wolter"], "venue": "In Proc. of IJCAI\u201909", "citeRegEx": "Kontchakov et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2009}, {"title": "Can you tell the difference between dl-lite ontologies", "author": ["R. Kontchakov", "F. Wolter", "M. Zakharyaschev"], "venue": "In Proc. of KR\u201908", "citeRegEx": "Kontchakov et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2008}, {"title": "A semantical analysis of modal logic", "author": ["S. Kripke"], "venue": "i: Normal modal propositional calculi. Z. Math. Logik Grundl. Math., 9, 67\u201396.", "citeRegEx": "Kripke,? 1963", "shortCiteRegEx": "Kripke", "year": 1963}, {"title": "Propositional independence: Formulavariable independence and forgetting", "author": ["J. Lang", "P. Liberatore", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Lang et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Lang et al\\.", "year": 2003}, {"title": "Complexity results for independence and definability", "author": ["J. Lang", "P. Marquis"], "venue": "In Proc. the 6th International Conference on Knowledge Representation and Reasoning,", "citeRegEx": "Lang and Marquis,? \\Q1998\\E", "shortCiteRegEx": "Lang and Marquis", "year": 1998}, {"title": "Resolving inconsistencies by variable forgetting", "author": ["J. Lang", "P. Marquis"], "venue": "In Proc. of KR\u20192002,", "citeRegEx": "Lang and Marquis,? \\Q2002\\E", "shortCiteRegEx": "Lang and Marquis", "year": 2002}, {"title": "All I know: a study in autoepistemic logic", "author": ["H. Levesque"], "venue": "Artificial Intelligence, 42, 263\u2013309.", "citeRegEx": "Levesque,? 1990", "shortCiteRegEx": "Levesque", "year": 1990}, {"title": "On the strongest necessary and weakest sufficient conditions", "author": ["F. Lin"], "venue": "Artificial Intelligence, 128, 143\u2013159.", "citeRegEx": "Lin,? 2001", "shortCiteRegEx": "Lin", "year": 2001}, {"title": "On first-order definability and computability of progression for local-effect actions and beyond", "author": ["Y. Liu", "G. Lakemeyer"], "venue": "In Proc. of IJCAI\u201909", "citeRegEx": "Liu and Lakemeyer,? \\Q2009\\E", "shortCiteRegEx": "Liu and Lakemeyer", "year": 2009}, {"title": "Knowledge Sharing among Ideal Agents", "author": ["A. Lomuscio"], "venue": "Ph.D thesis, School of Computer Science, University of Birmingham.", "citeRegEx": "Lomuscio,? 1999", "shortCiteRegEx": "Lomuscio", "year": 1999}, {"title": "Breaking and fixing the Needham-Schroeder public-key protocol using FDR", "author": ["G. Lowe"], "venue": "Margaria, & Steffen (Eds.), Tools and Algorithms for the Construction and Analysis of Systems, Vol 1055 of Lecture Notes in Computer Science, pp. 147\u2013166. Springer Verlag.", "citeRegEx": "Lowe,? 1996", "shortCiteRegEx": "Lowe", "year": 1996}, {"title": "Using encryption for authentication in large networks of computers", "author": ["R.M. Needham", "M.D. Schroeder"], "venue": "Communication of the ACM,", "citeRegEx": "Needham and Schroeder,? \\Q1978\\E", "shortCiteRegEx": "Needham and Schroeder", "year": 1978}, {"title": "Logics of public communications", "author": ["J. Plaza"], "venue": "Proceedings of the 4th International Symposium on Methodologies for Intelligent Systems, pp. 201\u2013216\u2013346.", "citeRegEx": "Plaza,? 1989", "shortCiteRegEx": "Plaza", "year": 1989}, {"title": "Word problem requiring exponential time: prelimnary report", "author": ["L. Stockmeyer", "A. Meyer"], "venue": "In Proc. 5th ACM Symp. on Theory of Computing,", "citeRegEx": "Stockmeyer and Meyer,? \\Q1973\\E", "shortCiteRegEx": "Stockmeyer and Meyer", "year": 1973}, {"title": "Reasoing about knowledge by variable forgetting", "author": ["K. Su", "G. Lv", "Y. Zhang"], "venue": "In Proceedings of KR-04,", "citeRegEx": "Su et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Su et al\\.", "year": 2004}, {"title": "An unified cryptographic protocol logic", "author": ["P.F. Syversion", "P. van Oorschot"], "venue": "Tech. rep. NRL Publication", "citeRegEx": "Syversion and Oorschot,? \\Q1996\\E", "shortCiteRegEx": "Syversion and Oorschot", "year": 1996}, {"title": "A lattice-theoretical fixpoint theorem ans its applications", "author": ["A. Tarski"], "venue": "Pacific J. Math., 5, 285\u2013309.", "citeRegEx": "Tarski,? 1955", "shortCiteRegEx": "Tarski", "year": 1955}, {"title": "Logics for information update", "author": ["J. van Benthem"], "venue": "In Proceedings of TARK-VIII,", "citeRegEx": "Benthem,? \\Q2001\\E", "shortCiteRegEx": "Benthem", "year": 2001}, {"title": "Theories of knowledge and ignorance", "author": ["W. van der Hock", "J. Jaspars", "E. Thijsse"], "venue": "Logic, Epistemology and the Unity of Science. Kluwer", "citeRegEx": "Hock et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Hock et al\\.", "year": 2003}, {"title": "Model checking knowledge and time", "author": ["W. van der Hoek", "M. Wooldridge"], "venue": "In Proc. 19th Workshop on SPIN (Model Checking Software),", "citeRegEx": "Hoek and Wooldridge,? \\Q2002\\E", "shortCiteRegEx": "Hoek and Wooldridge", "year": 2002}, {"title": "Common knowledge and update in finite environments", "author": ["R. van der Meyden"], "venue": "Information and Computation,", "citeRegEx": "Meyden,? \\Q1998\\E", "shortCiteRegEx": "Meyden", "year": 1998}, {"title": "Introspective forgetting", "author": ["H. van Ditmarsch", "A. Herzig", "J. Lang", "P. Marquis"], "venue": "AI 2008: Advances in Artificial Intelligence,", "citeRegEx": "Ditmarsch et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ditmarsch et al\\.", "year": 2008}, {"title": "Dynamic epistemic logic with assignment", "author": ["H. van Ditmarsch", "W. van der Hoek", "B. Kooi"], "venue": "In Proceedings of AAMAS-05,", "citeRegEx": "Ditmarsch et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Ditmarsch et al\\.", "year": 2005}, {"title": "Public announcements and belief expansion", "author": ["H. van Ditmarsch", "W. van der Hoek", "B. Kooi"], "venue": "In Advances in Modal Logic, Volume", "citeRegEx": "Ditmarsch et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Ditmarsch et al\\.", "year": 2005}, {"title": "Forgetting in dl-lite", "author": ["Z. Wang", "K. Wang", "R. Topor", "J. Pan"], "venue": "In Proc. of ESWC\u201908", "citeRegEx": "Wang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2008}, {"title": "Updating propositional formulas", "author": ["A. Weber"], "venue": "Proc. First Conference on Expert Database Systems, pp. 487\u2013500.", "citeRegEx": "Weber,? 1986", "shortCiteRegEx": "Weber", "year": 1986}, {"title": "Minimal change and maximal coherence for epistemic logic program updates", "author": ["Y. Zhang"], "venue": "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI-03), pp. 112\u2013117.", "citeRegEx": "Zhang,? 2003", "shortCiteRegEx": "Zhang", "year": 2003}, {"title": "Solving logic program conflict through strong and weak forgettings", "author": ["Y. Zhang", "N. Foo"], "venue": "Artificial Intelligence,", "citeRegEx": "Zhang and Foo,? \\Q2006\\E", "shortCiteRegEx": "Zhang and Foo", "year": 2006}, {"title": "Properties of knowledge forgetting", "author": ["Y. Zhang", "Y. Zhou"], "venue": "In Proceedings of the 20th International Workshop on Non-monoronic Reasoning ( NMR\u201908),", "citeRegEx": "Zhang and Zhou,? \\Q2008\\E", "shortCiteRegEx": "Zhang and Zhou", "year": 2008}], "referenceMentions": [{"referenceID": 37, "context": "This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003).", "startOffset": 87, "endOffset": 114}, {"referenceID": 37, "context": "This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003).", "startOffset": 87, "endOffset": 196}, {"referenceID": 37, "context": "This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003). Informally speaking, local propositions are those depending only upon an agent\u2019s local information; and an agent can always determine whether a given local proposition is true.", "startOffset": 87, "endOffset": 256}, {"referenceID": 4, "context": "Given a background knowledge base \u0393 and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula \u03c6 can be defined as the weakest sufficient condition of \u03c6 over Oi under \u0393, which can be computed via the operation of variable forgetting (Lin & Reiter, 1994) or eliminations of middle terms (Boole, 1854).", "startOffset": 335, "endOffset": 348}, {"referenceID": 30, "context": "The most basic extension is public announcement logic (PAL), which is obtained by adding an operator for truthful public announcements (Plaza, 1989; Baltag, Moss, & Solecki, 1998; van Ditmarsch, van der Hoek, & Kooi, 2005b).", "startOffset": 135, "endOffset": 223}, {"referenceID": 28, "context": "To further show the significance of our framework, we investigate some of its interesting applications to the automated analysis of the well-known muddy children puzzle and the verification of the revised Needham-Schroeder protocol (Lowe, 1996).", "startOffset": 232, "endOffset": 244}, {"referenceID": 8, "context": "Nevertheless, the notion of local propositions (Engelhardt et al., 1998, 2003) is a semantics property of the truth assignment function in a Kripke structure, while the notion of local variables (van der Hoek & Wooldridge, 2002) is a property of syntactical variables. In this paper, we prefer to use the term \u201cobservable variable\u201d in order to avoid any confusion with the term \u201clocal variable\u201d used in programming, where \u201cnon-local variables\u201d such as \u201cglobal variables\u201d may often be observable. Our knowledge model is also closely related to the notion of weakest sufficient condition, which was first formalized by Lin (2001). Given a background knowledge base \u0393 and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula \u03c6 can be defined as the weakest sufficient condition of \u03c6 over Oi under \u0393, which can be computed via the operation of variable forgetting (Lin & Reiter, 1994) or eliminations of middle terms (Boole, 1854).", "startOffset": 48, "endOffset": 628}, {"referenceID": 4, "context": "The notion of variable forgetting (Lin & Reiter, 1994), or eliminations of middle terms (Boole, 1854), can be defined as follows:", "startOffset": 88, "endOffset": 101}, {"referenceID": 22, "context": "Many characterizations of variable forgetting, together with complexity results, are reported in the work of Lang and Marquis (1998). In particular, the notion of variable forgetting is closely related to that of formula-variable independence (Lang, Liberatore, & Marquis, 2003).", "startOffset": 109, "endOffset": 133}, {"referenceID": 25, "context": "The formal definitions of weakest sufficient conditions and strongest necessary conditions were first formalized via the notion of variable forgetting by Lin (2001), which in turn play an essential role in our approach.", "startOffset": 154, "endOffset": 165}, {"referenceID": 25, "context": ", the weakest sufficient condition of the observation (Lin, 2001).", "startOffset": 54, "endOffset": 65}, {"referenceID": 25, "context": ", the weakest sufficient condition of the observation (Lin, 2001). The notions of strongest necessary and weakest sufficient conditions of a proposition also have many potential applications in other areas such as reasoning about actions. The following proposition, which is due to Lin (2001), shows how to compute the two conditions.", "startOffset": 55, "endOffset": 293}, {"referenceID": 20, "context": "According to the paper by Halpern and Moses (1992), semantics of these formulas can be given by means of Kripke structure (Kripke, 1963), which formalizes the intuition behind possible worlds.", "startOffset": 122, "endOffset": 136}, {"referenceID": 13, "context": "According to the paper by Halpern and Moses (1992), semantics of these formulas can be given by means of Kripke structure (Kripke, 1963), which formalizes the intuition behind possible worlds.", "startOffset": 26, "endOffset": 51}, {"referenceID": 13, "context": "According to the work of Halpern and Moses (1992), we have the following lemma.", "startOffset": 25, "endOffset": 50}, {"referenceID": 11, "context": "Common knowledge is a special kind of knowledge for a group of agents, which plays an important role in reasoning about knowledge (Fagin et al., 1995).", "startOffset": 130, "endOffset": 150}, {"referenceID": 22, "context": "We notice that the notion of V-definability introduced here is a simple elaboration of the notion of V-definability as given in the work of Lang and Marquis (1998): \u03c6 is V-definable under \u0393 iff \u03c6 is V -definable under \u0393 for each V \u2208 V.", "startOffset": 140, "endOffset": 164}, {"referenceID": 34, "context": "For a finite set V of propositional variables if \u039b is monotonic, then there exists a least fixed point and a greatest fixed point (Tarski, 1955).", "startOffset": 130, "endOffset": 144}, {"referenceID": 30, "context": "The original version of PAL was proposed by Plaza (1989). In this section, we show that public announcement operator can be conveniently dealt with via our notion of knowledge structure.", "startOffset": 44, "endOffset": 57}, {"referenceID": 11, "context": "The story goes as follows (Fagin et al., 1995): Imagine n children playing together.", "startOffset": 26, "endOffset": 46}, {"referenceID": 1, "context": "The muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999).", "startOffset": 151, "endOffset": 205}, {"referenceID": 12, "context": "The muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999).", "startOffset": 151, "endOffset": 205}, {"referenceID": 27, "context": "The muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999).", "startOffset": 151, "endOffset": 205}, {"referenceID": 6, "context": "It has been proved to be the most powerful modeling of the adversary (Cervesato, 2001) because it can simulate any other possible attackers.", "startOffset": 69, "endOffset": 86}, {"referenceID": 28, "context": "As Lowe (1996) pointed out, the Needham-Schroeder protocol has the problem of lacking the identity of the responder and can be fixed by a small modification.", "startOffset": 3, "endOffset": 15}, {"referenceID": 4, "context": "There are a number of approaches dealing with the concept of variable forgetting or eliminations of middle terms (Boole, 1854) in several contexts.", "startOffset": 113, "endOffset": 126}, {"referenceID": 10, "context": "This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003).", "startOffset": 206, "endOffset": 231}, {"referenceID": 21, "context": "The notion of variable forgetting is also closely related to that of formula-variable independence, because the result of forgetting the set of variables V in a formula \u03c6 can be defined as the strongest consequence of \u03c6 being independent from V (Lang et al., 2003).", "startOffset": 245, "endOffset": 264}, {"referenceID": 2, "context": "There are a number of approaches dealing with the concept of variable forgetting or eliminations of middle terms (Boole, 1854) in several contexts. The notion of variable forgetting was formally defined in propositional and first order logics by Lin and Reiter (1994). In recent years, theories of forgetting under answer set programming semantics were proposed (Zhang & Foo, 2006; Eiter & Wang, 2008).", "startOffset": 114, "endOffset": 268}, {"referenceID": 2, "context": "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect \u00acK\u03c6 \u2227 \u00acK\u00ac\u03c6: after knowledge forgetting \u03c6, the agent would neither know \u03c6 nor \u00ac\u03c6.", "startOffset": 0, "endOffset": 23}, {"referenceID": 2, "context": "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect \u00acK\u03c6 \u2227 \u00acK\u00ac\u03c6: after knowledge forgetting \u03c6, the agent would neither know \u03c6 nor \u00ac\u03c6. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]\u03c6 means that after the agent forgets his knowledge about p, \u03c6 is true.", "startOffset": 0, "endOffset": 220}, {"referenceID": 2, "context": "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect \u00acK\u03c6 \u2227 \u00acK\u00ac\u03c6: after knowledge forgetting \u03c6, the agent would neither know \u03c6 nor \u00ac\u03c6. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]\u03c6 means that after the agent forgets his knowledge about p, \u03c6 is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003). The notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases.", "startOffset": 0, "endOffset": 879}, {"referenceID": 2, "context": "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect \u00acK\u03c6 \u2227 \u00acK\u00ac\u03c6: after knowledge forgetting \u03c6, the agent would neither know \u03c6 nor \u00ac\u03c6. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]\u03c6 means that after the agent forgets his knowledge about p, \u03c6 is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003). The notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases. Lang and Marquis (2002) used it for merging a set of knowledge bases when simply taking their union may result in inconsistency.", "startOffset": 0, "endOffset": 957}, {"referenceID": 2, "context": "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect \u00acK\u03c6 \u2227 \u00acK\u00ac\u03c6: after knowledge forgetting \u03c6, the agent would neither know \u03c6 nor \u00ac\u03c6. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]\u03c6 means that after the agent forgets his knowledge about p, \u03c6 is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003). The notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases. Lang and Marquis (2002) used it for merging a set of knowledge bases when simply taking their union may result in inconsistency. The notion of variable forgetting is also closely related to that of formula-variable independence, because the result of forgetting the set of variables V in a formula \u03c6 can be defined as the strongest consequence of \u03c6 being independent from V (Lang et al., 2003). More recently, Liu and Lakemeyer (2009) applied the notion of forgetting into the situation calculus, and obtained some interesting results about the first-order definability and computability of progression for local-effect actions.", "startOffset": 0, "endOffset": 1368}, {"referenceID": 11, "context": "First, we will investigate whether our knowledge structures can be extended and used as a basis for knowledge based programming (Fagin et al., 1995).", "startOffset": 128, "endOffset": 148}, {"referenceID": 24, "context": "Secondly, in our current framework of knowledge structures, we have not considered the issue of only knowing which has been extensively studied in other knowledge reasoning models (Halpern & Lakemeyer, 1996; van der Hock, Jaspars, & Thijsse, 2003; Levesque, 1990).", "startOffset": 180, "endOffset": 263}, {"referenceID": 44, "context": "Finally, recent research has shown that knowledge update has many important applications in reasoning about actions and plans and dynamic modeling of multi-agent systems (Zhang, 2003).", "startOffset": 170, "endOffset": 183}, {"referenceID": 9, "context": "First, we will investigate whether our knowledge structures can be extended and used as a basis for knowledge based programming (Fagin et al., 1995). Secondly, in our current framework of knowledge structures, we have not considered the issue of only knowing which has been extensively studied in other knowledge reasoning models (Halpern & Lakemeyer, 1996; van der Hock, Jaspars, & Thijsse, 2003; Levesque, 1990). It will be an interesting topic of how our knowledge model handles only knowing in reasoning about knowledge. Thirdly, the notions and methods in this work can be extended to investigate the extension of the variable forgetting operator to multi-agent logics of beliefs. Finally, recent research has shown that knowledge update has many important applications in reasoning about actions and plans and dynamic modeling of multi-agent systems (Zhang, 2003). A first step in this direction (in mono-agent S5) can be found in the work of Herzig, Lang and Marquis (2003). Baral and Zhang have proposed a general model for performing knowledge update based on the standard single agent S5 modal logic (Baral & Zhang, 2001).", "startOffset": 129, "endOffset": 981}], "year": 2009, "abstractText": "In this paper, we investigate knowledge reasoning within a simple framework called knowledge structure. We use variable forgetting as a basic operation for one agent to reason about its own or other agents\u2019 knowledge. In our framework, two notions namely agents\u2019 observable variables and the weakest sufficient condition play important roles in knowledge reasoning. Given a background knowledge base \u0393 and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula \u03c6 can be defined as a weakest sufficient condition of \u03c6 over Oi under \u0393. Moreover, we show how to capture the notion of common knowledge by using a generalized notion of weakest sufficient condition. Also, we show that public announcement operator can be conveniently dealt with via our notion of knowledge structure. Further, we explore the computational complexity of the problem whether an epistemic formula is realized in a knowledge structure. In the general case, this problem is PSPACE-hard; however, for some interesting subcases, it can be reduced to co-NP. Finally, we discuss possible applications of our framework in some interesting domains such as the automated analysis of the well-known muddy children puzzle and the verification of the revised Needham-Schroeder protocol. We believe that there are many scenarios where the natural presentation of the available information about knowledge is under the form of a knowledge structure. What makes it valuable compared with the corresponding multi-agent S5 Kripke structure is that it can be much more succinct.", "creator": " TeX output 2009.08.13:2309"}}}