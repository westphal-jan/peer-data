{"id": "1401.5853", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jan-2014", "title": "Reasoning over Ontologies with Hidden Content: The Import-by-Query Approach", "abstract": "there is currently a systematic interest in techniques for hiding parts of dependency language via mat ontology kh that is being reused producing another different kv. if general goal, in this purpose you propose stronger import - by - drop framework, which hopes the content of kh appear through a similar interaction interface. whenever kv are matching symbols supporting kh in a weakly inaccessible way, someone can reason over kv direct configuration by accessing one kv and the outgoing item. we demonstrated thereby the feasibility of : destination - by - query problem. according particular, we note the limitations of algebraic framework and prove that minimal restrictions on the expressivity of kh and the way my context kv reuses symbols from kh are strictly necessary to use reasoning in particular setting. which consequently help cases in experimental research is possible and moreover present suitable state - by - operation reasoning challenges.", "histories": [["v1", "Thu, 23 Jan 2014 02:44:34 GMT  (837kb)", "http://arxiv.org/abs/1401.5853v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["bernardo cuenca grau", "boris motik"], "accepted": false, "id": "1401.5853"}, "pdf": {"name": "1401.5853.pdf", "metadata": {"source": "CRF", "title": "Reasoning over Ontologies with Hidden Content: The Import-by-Query Approach", "authors": ["Bernardo Cuenca Grau", "Boris Motik"], "emails": ["bernardo.cuenca.grau@cs.ox.ac.uk", "boris.motik@cs.ox.ac.uk"], "sections": [{"heading": null, "text": "of an ontology Kh that is being reused by another ontology Kv. Towards this goal, in this paper we propose the import-by-query framework, which makes the content of Kh accessible through a limited query interface. If Kv reuses the symbols from Kh in a certain restricted way, one can reason over Kv \u222aKh by accessing only Kv and the query interface. We map out the landscape of the import-by-query problem. In particular, we outline the limitations of our framework and prove that certain restrictions on the expressivity of Kh and the way in which Kv reuses symbols from Kh are strictly necessary to enable reasoning in our setting. We also identify cases in which reasoning is possible and we present suitable import-by-query reasoning algorithms."}, {"heading": "1. Introduction", "text": "Ontologies\u2014formal conceptualizations of a domain of interest\u2014have become increasingly important in computer science. They play a central role in many applications, such as the Semantic Web and biomedical information systems. The most widely used ontology languages are the Web Ontology Language (OWL) (Horrocks, Patel-Schneider, & van Harmelen, 2003) and its revision OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider, & Sattler, 2008), which have been standardized by the World Wide Web Consortium (W3C). The formal underpinning of the OWL family of languages is provided by description logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2007)\u2014knowledge representation formalisms with well-understood computational properties.\nConstructing ontologies is a labor-intensive task, so reusing (parts of) well-established ontologies is seen as key to reducing ontology development cost. Consequently, the problem of ontology reuse has recently received significant attention (Stuckenschmidt, Parent, & Spaccapietra, 2009; Lutz & Wolter, 2010; Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008, 2007; Doran, Tamma, & Iannone, 2007; Jime\u0301nez-Ruiz, Cuenca Grau, Sattler, Schneider, & Berlanga Llavori, 2008).\nWe discuss the problems of ontology reuse by means of an example from the health-care domain. In particular, ontologies are currently being used in several countries to describe electronic patient records (EPR). The representation of patients\u2019 data typically involves ontological descriptions of human anatomy, medical conditions, drugs and treatments, and so on. The latter domains have already been described in well-established reference ontologies, such as SNOMED-CT, GALEN, or the Foundational Model of Anatomy (FMA). In order to save resources, increase interoperability between applications, and rely on experts\u2019\nc2012 AI Access Foundation. All rights reserved.\nknowledge, these and other reference ontologies should be reused whenever possible. For example, assume that some reference ontology Kh describes concepts such as the \u201cventricular septum defect\u201d; then, one might reuse the terms from Kh in order to define an ontology Kv of concepts such as \u201cpatients having a ventricular septum defect,\u201d which might then be embedded in an EPR application.\nTo enable ontology reuse, OWL provides an importing mechanism: an ontology Kv can import another ontology Kh, and the result is logically equivalent to Kv \u222aKh. OWL reasoners deal with imports by loading both ontologies and merging their contents, thus requiring physical access to the axioms of Kh. The vendor of Kh, however, may be reluctant to distribute (parts of) the contents of Kh, as doing so might allow competitors to plagiarize Kh. Moreover, Kh may contain information that is sensitive from a privacy point of view. Finally, one may want to impose a varying cost on the reuse of different parts of Kh.\nRather than publishing the entire ontology, the vendor of Kh might want to freely distribute the symbols that describe organs and medical conditions, but without distributing the axioms describing these symbols. Furthermore, the vendor might want to completely hide the sensitive information from Kh, such as the information about treatments. It should, however, be possible to reuse the published part of Kh without affecting the ontology\u2019s consequences; that is, if a part of Kh is used to construct an ontology Kv, then any query q mentioning only symbols from Kv should be answered over Kv and the respective part of Kh in the same way as this would be done over Kv \u222aKh. To stipulate that Kh should not be publicly available, we call the ontology Kh hidden and, by analogy, we call Kv visible.\nMotivated by such scenarios, several approaches to hiding a subset \u03a5 of the signature of Kh have been developed. For example, one possible approach is to publish an \u03a5-interpolant ofKh\u2014an ontology that contains no symbols from\u03a5 and that coincides withKh on all logical consequences formed using the symbols not in \u03a5 (Konev, Walther, & Wolter, 2009; Wang, Wang, Topor, Pan, & Antoniou, 2009; Wang, Wang, Topor, & Pan, 2008; Wang, Wang, Topor, & Zhang, 2010; Wang et al., 2008; Lutz & Wolter, 2011; Nikitina, 2011). Publishing an interpolant ensures that the sensitive information in Kh (i.e., the information about the symbols from Kh not mentioned in the interpolant) is not exposed in any way; furthermore, interpolants preserve all consequences of symbols not in\u03a5 and have the additional advantage that the developers of Kv can reason over the union of Kv and the interpolant using off-theshelf reasoners. The interpolation approach may, however, exhibit several drawbacks. First, an interpolant may exist only if Kh is expressed in a relatively weak ontology language and if it satisfies certain syntactic conditions (Konev et al., 2009). Second, although interpolants preserve logical consequences formed using symbols not in \u03a5, they are not robust under replacement (Sattler, Schneider, & Zakharyaschev, 2009)\u2014that is, the union of Kv and an \u03a5-interpolant of Kh is not guaranteed to yield the same consequences as Kh \u222aKv for a query q involving only symbols from Kv. Finally, an \u03a5-interpolant of Kh can be exponentially larger than Kh, and it may reveal more information than what is strictly needed. We refer the reader to Section 7 for a detailed discussion of the related work.\nIn this paper, we propose a novel approach to ontology reuse that addresses the problems outlined above by making Kh accessible via a limited query interface called an oracle. The oracle advertises a public subset \u0393 of the signature of Kh (e.g., all symbols describing organs or medical conditions), and it can answer queries over Kh that are expressed in a particular query language and that use only the symbols from \u0393. Under certain assumptions, a so-\ncalled import-by-query algorithm can reason over Kv \u222aKh (e.g., determine the satisfiability of Kv \u222aKh) by posing queries to the oracle for Kh, and without accessing any of the axioms from Kh. Furthermore, reasoning can be performed without making the axioms of Kv available to Kh, which is beneficial as Kv might also contain sensitive information from a privacy point of view. Finally, our framework can be applicable even in cases when the relevant interpolant for Kh does not exist.\nIn order to achieve these benefits, however, Kv must reuse the symbols from \u0393 only in a syntactically restricted way, and the formal properties of import-by-query algorithms and the specific restrictions necessary for an import-by-query algorithm to exist depend on the oracle query language and the ontology languages used to express Kv and Kh. In this paper, we explore the properties of import-by-query reasoning with languages ranging from the lightweight description logic EL (Baader, Brandt, & Lutz, 2005) to the expressive logic ALCHOIQ (Horrocks & Sattler, 2005), combined with the following types of oracles.\n\u2022 Queries for concept satisfiability oracles are concepts constructed using the symbols in \u0393 expressed in a particular DL; for each query, the oracle decides the satisfiability of the query concept w.r.t. Kh.\n\u2022 Queries for ABox satisfiability oracles are ABoxes constructed using the symbols in \u0393; for each query, the oracle decides the satisfiability of the query ABox w.r.t. Kh.\n\u2022 Queries for ABox entailment oracles consist of an ABox and an assertion, both constructed using the symbols in \u0393; for each query, the oracle determines whether the assertion is entailed by Kh and the query ABox.\nConcept satisfiability, ABox satisfiability, and ABox entailment have been implemented in most state-of-the-art DL reasoners, so the above mentioned query languages seem like a natural foundation for practical implementations of our framework.\nThe main contributions of this paper are as follows:\n1. We present the import-by-query framework, formalize the notions of an oracle and an import-by-query algorithm, and establish the connections between import-by-query algorithms based on different types of oracles.\n2. We explore the limitations of our framework for a wide range of description logics and formulate precise conditions under which import-by-query algorithms fail to exist.\n3. We identify sufficient conditions on the visible ontology Kv for which an import-byquery algorithm can be obtained.\n4. We present a general hypertableau-based (Motik, Shearer, & Horrocks, 2009) importby-query algorithm that relies on ABox satisfiability oracles and that is applicable to Kv and Kh given in the expressive description logic ALCHIQ (Horrocks & Sattler, 1999), provided that Kv satisfies our sufficient conditions.\n5. Our general algorithm, however, is unlikely to be suitable for practice due to a high degree of nondeterminism. Therefore, we present a practical (goal-oriented) variant that is applicable whenever Kh is expressed in a Horn DL. This algorithm can be\nreadily applied to ontologies expressed in the lightweight description logic EL, but it is not guaranteed to be computationally optimal. Therefore, we also present a practical and computationally optimal algorithm that can be used if both Kv and Kh are expressed in EL.\n6. We establish the lower bounds on the size and the number of queries that an importby-query algorithm may need to ask an oracle in order to solve a reasoning task.\nOur results provide flexible and useful ways for ontology designers to ensure selective access to their ontologies, as well as a family of reasoning algorithms that provide a starting point for implementation and optimization. Furthermore, we believe our techniques can also be adapted to other settings, such as distributed ontology reasoning, or collaborative ontology development scenarios in which ontology developers have restricted access to the parts of the ontology developed by others."}, {"heading": "2. Preliminaries", "text": "In this section, we recapitulate the description logic notation used in this paper, we present an overview of various hypertableau reasoning algorithms for description logics (Motik et al., 2009), and we recapitulate various notions of modular ontology reuse (Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Konev, Lutz, Walther, & Wolter, 2008)."}, {"heading": "2.1 Description Logics", "text": "The syntax of the description logic ALCHOIQ is defined w.r.t. pairwise-disjoint countably infinite sets of atomic concepts NC , atomic roles NR, and named individuals NI . Set NC contains a distinguished infinite subset NO \u2286 NC of nominal concepts (or simply nominals). A role is either an atomic role or an inverse role R\u2212 for R an atomic role.\nThe set of concepts is the smallest set containing , A, \u00acC, C1 C2, \u2203R.C (existential restriction), and \u2265n R.C (cardinality restriction), for A an atomic concept, C, C1, and C2 concepts, R a role, and n a nonnegative integer. Furthermore, \u22a5, C1  C2, \u2200R.C, and \u2264n R.C are abbreviations of \u00ac, \u00ac(\u00acC1  \u00acC2), and \u00ac(\u2203R.\u00acC), and \u00ac(\u2265n+1R.C), respectively. We also often treat concepts of the form \u2203R.C as abbreviations of \u2265 1 R.C.\nA concept inclusion axiom has the form C1  C2 for C1 and C2 concepts, a concept equivalence C1 \u2261 C2 is an abbreviation for C1  C2 and C2  C1, and a concept definition is a concept equivalence of the form A \u2261 C with A an atomic concept. A role inclusion axiom has the form R1  R2 for R1 and R2 roles. A TBox axiom is either a concept inclusion axiom or a role inclusion axiom. A TBox T is a finite set of TBox axioms. An assertion has the form C(a), R(a, b), \u00acR(a, b), a \u2248 b, or a \u2248 b, for C a concept, R a role, and a and b individuals. An ABox A is a finite set of assertions. An ABox is normalized if it contains only assertions of the form A(a), \u00acA(a), R(a, b), \u00acR(a, b), and a \u2248 b, where A is an atomic concept and R is an atomic role. An axiom is either a TBox axiom or an assertion. A knowledge base K = T \u222aA consists of a TBox T and an ABox A.\nA signature is a set of atomic concepts and atomic roles. For \u03b1 a concept, a role, an axiom, or a set of axioms, the signature of \u03b1, written sig(\u03b1), is the set of atomic concepts and atomic roles occurring in \u03b1.1\nThe cardinality of a set S is written S. An interpretation I = (I , \u00b7I) consists of a nonempty domain setI and a function \u00b7I that assigns an object aI \u2208 I to each individual a, a set AI \u2286 I to each atomic concept A such that A \u2208 NO implies AI = 1, and a relation RI \u2286 I \u00d7I to each atomic role R. Table 1 defines the extension of \u00b7I to roles and concepts, as well as the satisfaction of axioms in I. An interpretation I is a model of K, written I |= K, if I satisfies all axioms in K; if such I exists, then K is satisfiable. A concept C is satisfiable w.r.t. K if a model I of K exists such that CI = \u2205.\nSometimes, nominal concepts are defined as having the form {a} for a an individual, and such a concept is interpreted as ({a})I = {aI}; that is, a nominal concept contains precisely the given individual. The drawback of such a definition is that it blurs the distinction between concepts and individuals at the syntactic level. Such a distinction is important for the import-by-query framework since our framework supports sharing concepts, but not individuals. In this paper we thus use the above given alternative definition, where nominals are \u201cspecial\u201d atomic concepts with a singleton interpretation. It is well known that these two definitions are equally expressive (Baader et al., 2007).\nSome of our results use a general notion of a description logic. Formally, we define a description logic DL as a pair consisting of a set of concepts and a set of knowledge bases. We call the elements of the former set DL-concepts and the elements of the latter set DLknowledge bases. Each concept in a DL-knowledge base must be a DL-concept. A DL-TBox (resp. DL-ABox ) is a DL-knowledge base containing no assertions (resp. no TBox axioms).\n1. Note that we are treating nominals as special atomic concepts (and not as individuals); hence, sig(\u03b1) includes the nominals, but not the individuals occurring in \u03b1.\nA DL-TBox axiom (resp. DL-assertion) is a TBox axiom (resp. assertion) that occurs in some DL-knowledge base. A description logic DL1 is a fragment of DL2 (or, conversely, DL2 extends DL1) if each DL1-concept is a DL2-concept and each DL1-knowledge base is a DL2-knowledge base. Since the \u201cunqualified\u201d notions of a concept and knowledge base are defined for ALCHOIQ, our definitions imply that each description logic considered in this paper is a fragment of ALCHOIQ.\nLet DL1 and DL2 be description logics. We say that DL1 allows for DL2-definitions if, for each DL1-knowledge base K, each atomic concept A, and each DL2-concept C, we have that K \u222a {A \u2261 C} is a DL1-knowledge base. Furthermore, DL1 has the finite model property if each satisfiable DL1-knowledge base has a model with a finite domain.\nThe description logic ALC is obtained from ALCHOIQ by disallowing nominal concepts (O), inverse roles (I), role inclusion axioms (H), and cardinality restrictions (Q). The description logics between ALC and ALCHOIQ are named by appending combinations of letters O, H, I, and Q to ALC.\nThe DL EL (Baader et al., 2005) (resp. FL0, see Baader et al., 2007) is obtained from ALC by allowing only concepts of the form , \u22a5, A, C1  C2, and \u2203R.C (resp. \u2200R.C) for A and R atomic, and by allowing only assertions of the form C(a) or R(a, b), with C an EL (resp. FL0) concept and R an atomic role. In recent years, significant effort has been devoted to the development of DL languages with good computational properties, such as EL, DL-Lite (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007), and Horn-SHIQ (Hustadt, Motik, & Sattler, 2005). An ALCHIQ knowledge base is Horn if it is expressed in the Horn-SHIQ fragment of ALCHIQ.\nFor an ABoxA, with G(A) we denote the graph whose nodes are precisely the individuals occurring in A, and that contains an undirected edge between individuals a and b if and only if a = b or both a and b occur together in an assertion in A. Individuals a and b are connected in A if a and b are connected in G(A); furthermore, A is connected if all pairs of individuals occurring in A are connected. An ABox A \u2286 A is a connected component of A if G(A) is a connected component of G(A)."}, {"heading": "2.2 Hypertableau Reasoning Algorithm", "text": "The hypertableau calculus by Motik et al. (2009) decides the satisfiability of an ALCHOIQ knowledge base K. As we show in Section 4.1, the presence of nominals precludes the existence of an import-by-query algorithm; hence, in this section we present an overview of a simplified version of the algorithm that is applicable if K is an ALCHIQ knowledge base.\nThe algorithm first preprocesses K into a set of rules R\u2014implications interpreted under first-order semantics\u2014and a normalized ABox A such that K is equisatisfiable with R \u222a A. Preprocessing consists of three steps. First, transitivity axioms are eliminated from K by encoding them using concept inclusions. Second, axioms are normalized and complex concepts are replaced with atomic ones in a way similar to the structural transformation for first-order logic. Third, the normalized axioms are translated into rules by using the correspondence between description and first-order logic. We omit the details of the preprocessing for the sake of brevity; Motik et al. (2009) present all the relevant details. Preprocessing produces so-called HT-rules\u2014syntactically restricted rules on which\nthe hypertableau calculus is guaranteed to terminate; the precise syntactic form of HT-rules is described in Section 2.2.1.\nAfter preprocessing, the satisfiability ofR\u222aA is decided using the hypertableau calculus, which is described in Section 2.2.2."}, {"heading": "2.2.1 HT-Rules", "text": "Let NV be a set of variables disjoint with the set of individuals NI . An atom is an expression of the form C(s) (a concept atom), R(s, t) (a role atom), or s \u2248 t (an equality atom), where s, t \u2208 NV \u222aNI , C is a concept, and R is a role. A rule is an expression of the form\nU1 \u2227 . . . \u2227 Um \u2192 V1 \u2228 . . . \u2228 Vn (1)\nwhere Ui and Vj are atoms, m \u2265 0, and n \u2265 0. Conjunction U1 \u2227 . . . \u2227 Um is called the body, and disjunction V1 \u2228 . . . \u2228 Vn is called the head of the rule. The empty body and the empty head are written as  and \u22a5, respectively. Rules are interpreted as universally quantified FOL implications in the usual way. A rule is Horn if it contains at most one head atom.\nAn HT-rule is a rule of the form \nAi(x) \u2227  Rij(x, yi) \u2227  Sij(yi, x) \u2227 \nBij(yi) \u2192 Ci(x) \u2228  R ij (x, yi) \u2228  S ij (yi, x) \u2228  Dij(yi) \u2228  yi \u2248 yj\n(2)\nwhere Rij , Sij , Rij , and S  ij are atomic roles; Ai, Bij , and Dij are atomic concepts; and Ci are either atomic concepts or concepts of the form \u2265n R.A or \u2265n R.\u00acA. In addition, each variable yi occurring in an HT-rule is required to occur in a body atom of the form Rij(x, yi) or Sij(yi, x). Intuitively, the body and the head of HT-rules can be seen as being star-shaped: \u201ccenter variable\u201d x represents the center of the star, and \u201cbranch variables\u201d yi can be connected to the center only through role atoms. Such shape ensures that satisfiable HT-rules will always have a tree-like model\u2014a property that can be used to explain the good computational properties of many DLs.\nAs Motik et al. (2009) have shown, the preprocessing of K produces an equisatisfiable set of HT-rules and a normalized ABox; furthermore, if K is Horn, then the resulting set contains only Horn HT-rules. Furthermore, if certain description logic constructors are not used in K, then R satisfies certain syntactic restrictions as discussed next.\n\u2022 If K does not use cardinality restrictions, then no HT-rule  \u2208 R contains an atom of the form yi \u2248 yj in the head.\n\u2022 If K does not use inverse roles, then no HT-rule  \u2208 R contains an atom of the form S\nij (yi, x) in the head or an atom of the form Sij(yi, x) in the body.\n\u2022 If K does not use role hierarchies, then no HT-rule  \u2208 R contains a role atom in the head.\nAs an example, consider the following knowledge base K and the corresponding set of HT-rules R obtained from K.\nA  \u2203R.B  A(x) \u2192 \u2203R.B(x) (3) A  \u2203R.C  A(x) \u2192 \u2203R.C(x) (4)\n  \u2264 1 R.  R(x, y1) \u2227R(x, y2) \u2192 y1 \u2248 y2 (5) B  C  D  B(x) \u2227 C(x) \u2192 D(x) (6) \u2203R.D  E  R(x, y) \u2227D(y) \u2192 E(x) (7)\nNote that R is a set of Horn HT-rules. Note also that K uses a cardinality restriction \u2264 1 R., so R contains a rule with an equality atom in the head. Furthermore, K does not use role hierarchies, so no rule in R contains a role atom in the head. Finally, K does not use inverse roles, so each role atom occurring in the body of a rule in R contains the center variable x in the first position and a branch variable yi in the second position.\nWhen applied to an EL knowledge base, the transformation by Motik et al. (2009) produces EL-rules\u2014HT-rules of the form (8) in which C is either an atomic concept or a concept of the form \u2203R.A with A an atomic concept.\nk\ni=1\nAi(x) \u2227 m\ni=1\n Ri(x, yi) \u2227 mi\nj=1\nBij(yi)\n\n\u2192 C(x) (8)\nNote that all the rules in our previous example except for the third one (which uses equality in the head) are EL-rules."}, {"heading": "2.2.2 Hypertableau Calculus for HT-Rules", "text": "Given an arbitrary set of HT-rules R and a normalized ABox A, satisfiability of R\u222aA can be decided using the calculus described in Definition 1.\nDefinition 1. Individuals. For a set of named individuals NI , the set of all individuals NX is inductively defined as the smallest set such that NI \u2286 NX and, if x \u2208 NX , then x.i \u2208 NX for each integer i. The individuals in NX \\NI are unnamed. An individual x.i is a successor of x, and x is a predecessor of x.i; descendant and ancestor are the transitive closures of successor and predecessor, respectively.\nPairwise Anywhere Blocking. The label LA(s) of an individual s and the label LA(s, t) of an individual pair s, t in an ABox A are defined as follows:\nLA(s) = {A | A(s) \u2208 A and A is atomic} LA(s, t) = {R | R(s, t) \u2208 A}\nLet \u227a be a strict ordering on NX containing the ancestor relation. By induction on \u227a, we assign to each individual s in A a blocking status as follows.\n\u2022 Individual s is directly blocked by individual t iff the following conditions hold, for s and t the predecessors of s and t, respectively:\n\u2013 s and t are unnamed, t is not blocked, and t \u227a s;2\n\u2013 LA(s) = LA(t) and LA(s) = LA(t); and \u2013 LA(s, s) = LA(t, t) and LA(s, s) = LA(t, t).\n2. When blocking is used with ALCHOIQ knowledge bases, individuals s and t are also required to be unnamed; however, this restriction is not needed for ALCHIQ knowledge bases.\nPruning and Merging. The ABox pruneA(s) is obtained from A by removing all assertions containing a descendant of s. The ABox mergeA(s \u2192 t) is obtained from pruneA(s) by replacing s with t in all assertions.\nClash. An ABox A contains a clash if \u22a5 \u2208 A; otherwise, A is clash-free. Derivation Rules. The derivation rules consist of the Hyp-, \u2265-, \u2248-, and \u22a5-rule from Table 2, which, given R and a clash-free ABox A, derive the ABoxes A1, . . . ,An. In the Hyp-rule, \u03c3(U) is obtained from U by replacing each variable x with \u03c3(x). For a role R and individuals s and t, function ar(R, s, t) returns assertion R(s, t) if R is atomic, or assertion S(t, s) if R is an inverse role and R = S\u2212.\nDerivation. A derivation for R and A is a pair (T, \u03c1) where T is a finitely branching tree and \u03c1 labels the nodes of T with ABoxes such that ( i) \u03c1() = A for  the root, and ( ii) for each node t, if a derivation rule is applicable to R and \u03c1(t), then t has children t1, . . . , tn such that \u03c1(t1), . . . , \u03c1(tn) are the result of applying one derivation rule to R and \u03c1(t). The algorithm returns t if some derivation for R and A has a leaf node labeled with a clash-free ABox, and f otherwise.\nThe Hyp-rule is similar to the one of the hypertableau calculus for first-order logic: given an HT-rule of he form (1) and an ABox A, the Hyp-rule tries to unify the atoms U1, . . . , Um with a subset of the assertions in A; if a unifier \u03c3 is found, the rule nondeterministically derives \u03c3(Vj) for some 1 \u2264 j \u2264 n. For example, given the rule A(x) \u2192 \u2203R.C(x) \u2228D(x) and an assertion A(a), the Hyp-rule derives either \u2203R.C(a) or D(a). The \u2265-rule deals with existential quantifiers; for example, given \u2203R.C(a), the rule introduces a fresh individual t and derives R(a, t) and C(t). The \u2248-rule deals with equality; for example, given a \u2248 b, the rule replaces the individual a in all assertions with the individual b. Finally, the \u22a5-rule detects obvious contradictions such as A(a) and \u00acA(a), R(a, b) and \u00acR(a, b), or a \u2248 a.\nSince ALCHIQ allows for cyclic concept inclusions of the form C  \u2203R.C, termination of the hypertableau calculus requires a blocking mechanism to prevent the \u2265-rule from generating infinite sequences of successors. When an individual s is directly blocked by another individual t, the \u2265-rule is no longer applicable to s, which prevents the introduction of fresh successors of s. Furthermore, all descendants of s are then indirectly blocked, which prevents the application of any of the rules in Table 2 to the descendants of s.\nIf a derivation for R and A exists in which a leaf node is labeled with a clash-free ABox A, then a model of R \u222a A can be constructed from A via a well-known technique called unraveling. Models of R\u222aA obtained in such a way are called canonical forest models, and Motik et al. (2009) discuss in depth the properties of such models.\nLet R be the set of HT-rules (3)\u2013(7) given in Section 2.2.1, and let A = {A(a),\u00acE(a)}; we next show how to demonstrate using the hypertableau algorithm that R \u222aA is unsatisfiable. By applying the Hyp-rule to A(a), we derive \u2203R.B(a) and \u2203R.C(a). Next, by applying the \u2265-rule to \u2203R.B(a) we derive R(a, t1) and B(t1); and by applying the \u2265-rule to \u2203R.C(a) we derive R(a, t2) and C(t2). Individuals t1 and t2 are fresh successors of s and are actually of the form s.1 and s.2; however, for clarity we write them simply as t1 and t2. By applying the Hyp-rule to R(a, t1) and R(a, t2), we derive t1 \u2248 t2. Furthermore, to apply the \u2248-rule to t1 \u2248 t2, we must replace t1 with t2 in all assertions; thus, we replace R(a, t1) and B(t1) with R(a, t2) and B(t2), respectively. Next, by applying the Hyp-rule to B(t2) and C(t2) we derive D(t2). Next, by applying the Hyp-rule to R(a, t2) and D(t2) we derive E(a). Finally, by applying the the \u22a5-rule to E(a) and \u00acE(a) we derive \u22a5. We have thus constructed a derivation for R and A whose (only) leaf contains a clash, and so R \u222aA is unsatisfiable.\n2.2.3 Hypertableau Algorithm for EL-rules Since any EL knowledge base is an ALCHIQ knowledge base as well, the hypertableau algorithm can straightforwardly be applied to EL KBs. Motik and Horrocks (2008) showed, however, that a worst-case optimal algorithm can be obtained by modifying the \u2265-rule. This modified algorithm works on a set R of EL-rules.\nThe following algorithm checks satisfiability of R \u222aA, for R a set of EL-rules and A a normalized ABox.\nDefinition 2. For each named individual a \u2208 NI and each atomic concept A \u2208 NC , let aA be a fresh individual that is uniquely associated with a and A. The hypertableau algorithm for EL is the same as the one described in Definition 1, but the derivation rules include the Hyp-, \u22a5-, and \u2203-rule from Table 2."}, {"heading": "2.3 Modularity", "text": "Let Kv be a knowledge base that reuses a knowledge base Kh, and let \u0393 be the subset of sig(Kh) that is being reused in Kv\u2014that is, \u0393 = sig(Kh) \u2229 sig(Kv). It is often beneficial if Kv reuses Kh in a modular way; intuitively, this is the case if the knowledge base Kv does not \u201caffect the meaning\u201d of the symbols in \u0393 (Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Konev, Lutz, Walther, & Wolter, 2008). Two different notions of modularity have been considered in literature, each providing a different formal account of what it means for Kv to \u201caffect the meaning\u201d of the symbols in \u0393.\nA knowledge base Kv is deductively modular w.r.t. a signature \u0393 if, for all concepts C and D expressed in the same description logic as Kv such that sig(C) \u2286 \u0393 and sig(D) \u2286 \u0393, we have that Kv |= C  D implies \u2205 |= C  D. That is, the axioms of Kv must not give rise to nontrivial logical consequences that involve only the symbols from \u0393.\nA knowledge base Kv is semantically modular w.r.t. a signature \u0393 if, for each interpretation I = (I , \u00b7I) for the symbols in \u0393, there exists an interpretation J = (J , \u00b7J) such that I = J , XI = XJ for each X \u2208 \u0393, and J |= Kv. That is, the axioms of Kv are not allowed to impose any constraints on the interpretation of the symbols from \u0393.\nSemantic modularity is stronger than the deductive one: if Kv is semantically modular w.r.t. \u0393, then it is also deductively modular w.r.t. \u0393; the converse does not hold necessarily. Deciding whether a knowledge base Kv is deductively or semantically modular w.r.t. a signature \u0393 is a very hard computational problem for most DLs, and it is often undecidable (Lutz et al., 2007; Konev et al., 2008). Cuenca Grau, Horrocks, Kazakov, and Sattler (2008) have defined several practically useful sufficient syntactic conditions that guarantee semantic modularity."}, {"heading": "3. The Import-by-Query Framework", "text": "In this section we introduce our framework. We first present a motivating example, after which we proceed with a formalization of the import-by-query problem.\nConsider a medical research company (MRC) that has developed a knowledge base of human anatomy. This knowledge base contains concepts describing organs such as Heart and TV (tricuspid valve); medical conditions such as CHD (congenital heart defect), VSD (ventricular septum defect), and AS (aortic stenosis); and treatments such as Surgery. The roles part, con, and treatment relate organs with their parts, medical conditions, and treatments, respectively, and they are used to define concepts such as VSD Heart (a heart with a ventricular septum defect) and Sur Heart (a heart that requires surgical treatment). We focus on reusing schema knowledge, so we assume that the knowledge base consists only of a TBox Th, which is shown in Table 3. Assume that MRC wants to freely distribute information about organs and conditions, but hide the information about treatments. Thus, MRC identifies a set \u0393 of public symbols of Th; we write these symbols in bold, and the remaining private symbols in sans serif. MRC does not want to distribute the axioms of Th, as this might allow competitors to copy parts of Th; therefore, we say that knowledge base Th is hidden.\nConsider also a health-care provider (HCP) that reuses Th to describe types of patients such as VSD Patient (patients with a ventricular septum defect), HS Patient (patients requiring heart surgery), AS Patient (patients with aortic stenosis), EA Patient (patients\nwith Ebstein\u2019s anomaly), and TVD Patient (patients with a tricuspid valve defect). Since the TBox Th does not describe Ebstein\u2019s anomaly, HCP defines EA Heart as a heart with a ventricular septum defect and with a displaced tricuspid valve Dis TV ; furthermore, it defines a displaced tricuspid valve as abnormal, and Ab TV Heart as a heart with an abnormal tricuspid valve. In general, HCP\u2019s knowledge base could contain ABox assertions, so we denote the knowledge base with Kv and call it visible. The axioms of Kv are shown in Table 3, and the private symbols of Kv are written in italic. HCP can use the combined knowledge base Kv \u222a Th to deduce that VSD Patient  HS Patient (patients with ventricular septum defect require heart surgery) and EA Patient  TVD Patient (patients with Ebstein\u2019s anomaly are a kind of patients with a tricuspid valve defect).\nTo support such scenarios, we propose the import-by-query framework. Instead of publishing (a subset of) the axioms of Th, MRC can publish an oracle for Th\u2014a service that advertises a set \u0393 of public symbols in Th and a query language L, and that can answer L-queries over Th provided that these queries use only symbols in \u0393. A so-called import-byquery algorithm can then reason with Kv \u222a Th (e.g., determine the satisfiability of Kv \u222a Th) without having physical access to the contents of Th, by just asking queries to the oracle. The existence of such an algorithm, however, depends on the oracle\u2019s query language, the DLs used to express Kv and Th, and the way in which the symbols from \u0393 are reused in Kv.\nOne of the most popular query languages in description logics is concept satisfiability, which is available in all DL reasoners known to us. It is thus natural to consider concept satisfiability oracles, which advertise a signature \u0393 and check the satisfiability w.r.t. Th of (not necessarily atomic) concepts formed using the symbols in \u0393. Later on we show that import-by-query algorithms based on concept satisfiability oracles exist only if rather strong\nrestrictions are imposed on the way Kv reuses the symbols from \u0393; roughly speaking, it is not possible to mix roles from \u0393 with concepts private to Kv in existential and universal restrictions. In our example, this means that axioms \u03b46 and \u03b48 from Table 3 would not be allowed in Kv. To overcome the limitations of concept satisfiability oracles, we consider two additional types of (closely related) oracles that are more powerful than the oracles based on concept satisfiability. An ABox satisfiability oracle is given an ABox A with sig(A) \u2286 \u0393, and it checks the satisfiability of A \u222a Th. An ABox entailment oracle is given an ABox A and an assertion \u03b1 with sig(A) \u2286 \u0393 and sig(\u03b1) \u2286 \u0393, and it checks whether A \u222a Th |= \u03b1. ABox satisfiability and entailment have been implemented in most state-of-the-art DL reasoners, so oracles based on such inferences seem natural.\nIn practice, it is natural to express oracle queries in the same DL as Th; however, for the sake of generality we allow queries to be expressed in an arbitrary description logic L. Intuitively, this allows Kv to \u201clearn more about the structure of the models of Th,\u201d which allows us to obtain more general results about nonexistence of import-by-query algorithms. Definition 3 formally introduces different types of oracles.\nDefinition 3. Let Th be a TBox, let \u0393 be a signature, and let L be a description logic. The concept satisfiability oracle for Th, \u0393, and L is the Boolean function \u2126cTh,\u0393,L that, for each L-concept C with sig(C) \u2286 \u0393, returns t if and only if C is satisfiable w.r.t. Th. The ABox satisfiability oracle for Th, \u0393, and L is the Boolean function \u2126aTh,\u0393,L that, for each connected L-ABox A with sig(A) \u2286 \u0393, returns t if and only if Th \u222aA is satisfiable. The ABox entailment oracle for Th, \u0393, and L is the Boolean function \u2126eTh,\u0393,L that, for each connected L-ABox A such that sig(A) \u2286 \u0393 and each L-assertion \u03b1 that mentions only the individuals in A such that sig(\u03b1) \u2286 \u0393, returns t if and only if Th \u222aA |= \u03b1.\nWe use the generic term oracle for either a concept satisfiability, an ABox satisfiability, or an ABox entailment oracle. Furthermore, if L is the same as the description logic of Th, we abbreviate \u2126Th,\u0393,L to \u2126Th,\u0393. Finally, we often refer to the oracle arguments (i.e., the concepts C, the ABoxes A, and the pairs A,\u03b1 in the case of concept satisfiability, ABox satisfiability, and ABox entailment oracles, respectively) as oracle queries.\nWe next formally define import-by-query algorithms using the well-known notion of an oracle Turing machine. A precise definition of the latter is given by Papadimitriou (1993); we next present just an informal overview of the main ideas. An oracle Turing machine T has a separate query tape, on which it can write arbitrary strings over a given alphabet. At any point in time, T can enter a special state q?, upon which a black-box oracle \u2126 checks whether the string currently written on the query tape belongs to the language associated with \u2126; if that is the case, then T enters a special state qyes , and otherwise T enters a special state qno . This allows the oracle\u2019s answers to affect the computation of T . A combination of T and \u2126 is usually written as T\u2126. This definition assumes that the computation of T depends only on the input and the oracle\u2019s answers; that is, if \u21261 and \u21262 are two distinct oracles, the computations of T\u21261 will be indistinguishable from the computations of T\u21262 if \u21261 and \u21262 return the same answers to queries encountered in computations. In the rest of this paper, we do not make any assumptions on the type of T : any \u201creasonable\u201d Turing machine model can be used. We merely assume that T is equipped with a suitable notion of a run which captures the computation of T\u2126 on each input. A run can (but does not need to) accept or reject the input.\nDefinition 4. A class of inputs C is a class of triples of the form \u0393C ,KCv , T Ch  where \u0393C is a signature, KCv is a knowledge base, and T Ch is a TBox such that sig(KCv ) \u2229 sig(T Ch ) \u2286 \u0393C. Each triple in C is called an input.\nAn import-by-query algorithm for a description logic L and a class of inputs C based on oracles of type x \u2208 {a, e, c} is an oracle Turing machine ibqx that can be combined with an oracle of type x. For each input \u0393,Kv, Th \u2208 C the following properties must be satisfied, where ibqx[Th,\u0393,L] is the combination of ibqx and the oracle \u2126xTh,\u0393,L:\n1. whenever ibqx[Th,\u0393,L] enters the state q? in a run, the string on the query tape encodes a query accepted by \u2126xTh,\u0393,L;\n2. ibqx[Th,\u0393,L] has an accepting run on Kv if and only if Kv \u222a Th is satisfiable; and\n3. each run of ibqx[Th,\u0393,L] on Kv is finite. Intuitively, the transition relation of ibqx takes into account the possible answers of an\noracle of type x, but ibqx is not \u201cexecutable\u201d because the actual oracle is unknown. Thus, ibqx can be seen as a computer program in which a particular subroutine is missing. Given an input \u0393,Kv, Th \u2208 C, we can parameterize ibqx by \u2126xTh,\u0393,L to obtain ibq\nx[Th,\u0393,L], and the latter Turing machine can be freely applied to Kv.\nIn the rest of this paper, whenever the oracle type is not explicitly given, our discussion applies to all oracle types. We will consider various classes of inputs, each of which can be defined using the following formulation:\nC is the largest class of triples \u0393C ,KCv , T Ch  where sig(KCv ) \u2229 sig(T Ch ) \u2286 \u0393C and \u0393C , KCv , and T Ch satisfy some condition.\nUsually, however, we abbreviate such formulations as follows:\nC[\u0393C ,KCv , T Ch ] is a class of inputs where \u0393C , KCv , and T Ch satisfy some condition. Definition 4 straightforwardly implies the following property, which essentially just re-\nformulates the idea that the runs of a Turing machine are determined only by the oracles\u2019 answers, and not the oracles themselves.\nProposition 1. Let ibq be an import-by-query algorithm for a description logic L and a class of inputs C, let \u0393,Kv, T 1h  be an arbitrary input from C, and let Q1, . . . , Qn be the oracle queries encountered in all possible runs of ibq[T 1\nh ,\u0393,L] on Kv. Then, for each T 2h\nsuch that \u0393,Kv, T 2h  \u2208 C and \u2126T 1h ,\u0393,L(Qi) = \u2126T 2h ,\u0393,L(Qi) for each 1 \u2264 i \u2264 n, each run of ibq[T 1\nh ,\u0393,L] on Kv is a run of ibq[T 2h ,\u0393,L] on Kv and vice versa.\nIn Section 4 we will identify DLs defining the oracle query language and classes of inputs for which no import-by-query algorithm based on oracles of a particular type exists. The following proposition shows that it suffices to prove nonexistence results for the most expressive DL and the smallest class of inputs; then, analogous results then hold for each weaker DL and each larger class of inputs.\nProposition 2. Let L1 be a description logic and let L2 be a fragment of L1; let C1 and C2 be classes of inputs such that each triple in C1 also belongs to C2; and let x \u2208 {a, c, e} be an oracle type. If there is no import-by-query algorithm for L1 and C1 based on oracles of type x, then there is also no import-by-query algorithm for L2 and C2 based on oracles of type x.\nProof. We prove the contrapositive claim. Let ibqx be an import-by-query algorithm for L2 and C2. Since each triple in C1 is also contained in C2, ibqx is clearly an import-byquery algorithm for L2 and C1. Let \u0393,Kv, Th \u2208 C1 be an arbitrary input, and let Q be an arbitrary L2-query encountered in a run of ibqx[Th,\u0393,L] on Kv. Since L2 is a fragment of L1, Q is an L1-query as well. Thus, ibqx is an import-by-query algorithm for L1 and C1.\nThe following theorem shows that oracles of certain types can simulate oracles of other types. This is important because if \u21261 can simulate \u21262 and we show that no import by query algorithm exists for a particular class of inputs applicable to \u21261, then also no such algorithm exists that is applicable to \u21262.\nTheorem 1. Let \u2264 be the smallest partial order on the class of all oracles that satisfies the following conditions for each TBox Th, each signature \u0393, and each description logic L:\n1. \u2126cTh,\u0393,L \u2264 \u2126 a Th,\u0393,L \u2264 \u2126 e Th,\u0393,L; and\n2. if for each L-ABox A and each L-assertion \u03b1 we have that A \u222a {\u00ac\u03b1} is an L-ABox, then \u2126eTh,\u0393,L \u2264 \u2126 a Th,\u0393,L holds as well.\nLet L be a description logic, let C be a class of inputs, and let x1, x2 \u2208 {a, c, e} be oracle types such that \u2126x1Th,\u0393,L \u2264 \u2126 x2 Th,\u0393,L for each \u0393,Kv, Th \u2208 C. Then, each import-by-query algorithm ibqx1 for L and C can be transformed into an import-by-query algorithm ibqx2 for L and C such that, for each input \u0393,Kv, Th \u2208 C, ibqx1 [Th,\u0393,L] has a run on Kv with n oracle queries if and only if ibqx2 [Th,\u0393,L] has a run on Kv with n oracle queries.\nProof. Let ibqx1 be an arbitrary import-by-query algorithm for L and C, and consider an arbitrary input \u0393,Kv, Th \u2208 C. Conditions 1 and 2 ensure that \u2126x1Th,\u0393,L is reducible to \u2126x2Th,\u0393,L in the sense that a computable total function f exists from the domain of \u2126x1Th,\u0393,L to the domain of \u2126 x2 Th,\u0393,L such that for each query Q accepted by \u2126 x1 Th,\u0393,L, we have \u2126x1Th,\u0393,L(Q) = \u2126 x2 Th,\u0393,L(f(Q)). In particular, an ABox satisfiability oracle is reducible to an ABox entailment oracle via f(A) = (A,\u22a5) for each ABox A. Furthermore, if Condition 2 holds, then an ABox entailment oracle is reducible to an ABox satisfiability oracle via f(A,\u03b1) = A \u222a {\u00ac\u03b1}. Finally, a concept satisfiability oracle is reducible to an ABox satisfiability oracle via f(C) = {C(a)} for a a fresh individual.\nAlgorithm ibqx2 can then simply simulate ibqx1 on each input \u0393,Kv, Th \u2208 C; furthermore, whenever ibqx1 [Th,\u0393,L] poses a query Q to \u2126x1Th,\u0393,L, then ibq\nx2 [Th,\u0393,L] computes f(Q) and poses the query f(Q) to \u2126x2Th,\u0393,L. Since ibq\nx1 is an import-by-query algorithm for L and C, so is ibqx2 . Furthermore, for each input, there is a one-to-one correspondence between the runs of both algorithms with corresponding runs posing exactly the same number of oracle queries.\nWe next show that, if the shared signature \u0393 contains only atomic concepts, there is a close correspondence between ABox and concept satisfiability oracles.\nTheorem 2. Let L be a description logic and let C[\u0393C ,KCv , T Ch ] be a class of inputs where \u0393C contains only atomic concepts. Then, each import-by-query algorithm ibqa for L and C can be transformed into an import-by-query algorithm ibqc for L and C such that the following statements hold for each input \u0393,Kv, Th \u2208 C.\n\u2022 For each run of ibqa[Th,\u0393,L] on Kv with n oracle queries and m the maximum number of individuals in a query ABox, a run of ibqc[Th,\u0393,L] on Kv with at most n\u00d7m oracle queries exists.\n\u2022 For each run of ibqc[Th,\u0393,L] on Kv with n oracle queries, a run of ibqa[Th,\u0393,L] on Kv with at most n oracle queries exists.\nProof. Let ibqa be an import-by-query algorithm for L and C. We define ibqc such that, on each input \u0393,Kv, Th \u2208 C, algorithm ibqc[Th,\u0393,L] simulates the steps of algorithm ibqa[Th,\u0393,L]; furthermore, when ibqa[Th,\u0393,L] queries \u2126aTh,\u0393,L with an ABox A, algorithm ibqc[Th,\u0393,L] proceeds as follows.\n1. The algorithm transforms A into an ABox A by iterating over all assertions of the form a \u2248 b in A and, for each such assertion, replacing one individual (say a) with the other one (say b) in all assertions.\n2. IfA contains an individual a such that a \u2248 a \u2208 A or \u2126cTh,\u0393,L(B1  . . . Bn) = f where B1, . . . , Bn are all concepts such that Bi(a) \u2208 A, then ibqc[Th,\u0393,L] proceeds in the same way as ibqa[Th,\u0393,L] for \u2126aTh,\u0393,L(A) = f; otherwise, ibq\nc[Th,\u0393,L] proceeds in the same way as ibqa[Th,\u0393,L] for \u2126aTh,\u0393,L(A) = t.\nThere is an obvious correspondence between the runs of ibqa[Th,\u0393,L] and ibqc[Th,\u0393,L] on Kv; furthermore, whenever ibqa[Th,\u0393,L] issues a query to \u2126aTh,\u0393,L, then ibq\nc[Th,\u0393,L] issues at most m queries to \u2126cTh,\u0393,L in order to determine how to proceed. Finally, note that the second statement in the theorem directly follows from Theorem 1.\nWe finally show that we can without loss of generality assume Kv to contain no concept such as \u2203con.AS in axiom \u03b43 in Table 3.\nDefinition 5. Let \u0393 be a signature. A concept C is \u0393-modal if sig(C) \u2286 \u0393 and C is of the form \u2203R.D, \u2200R.D, \u2265n R.D, or \u2264n R.D.\nIntuitively, \u0393-modal concepts can always be treated as \u201catomic\u201d from the point of view of Kv, so we can rely on the oracle to compute all relevant consequences of such concepts.\nTheorem 3. Let L, DL1, and DL2 be description logics such that each DL1-concept is also an L-concept and DL2 allows for DL1-definitions; let x \u2208 {a, c, e}; let C[\u0393C ,KCv , T Ch ] be a class of inputs where KCv is a DL1-knowledge base and T Ch is a DL2-TBox; and let D[\u0393D,KDv , T Dh ] be the class of inputs consisting of all triples \u0393,Kv, Th in C[\u0393C ,KCv , T Ch ] in which Kv contains no \u0393-modal concepts. Then, each import-by-query algorithm ibqx2 for L and D can be transformed into an import-by-query algorithm ibqx1 for L and C.\nProof. For \u0393 a signature, C a concept, and \u03b1 a concept, axiom, or knowledge base, we say that C is \u0393-outermost in \u03b1 if C is \u0393-modal and C does not occur in \u03b1 as a proper subconcept of another \u0393-modal concept.\nLet \u0393,Kv, Th \u2208 C be an arbitrary input in C, let S be the set of all \u0393-outermost concepts in Kv, and let XC be a fresh atomic concept uniquely associated with each C \u2208 S. We define \u0393, T \nh , and Kv as follows: \u0393 = \u0393 \u222a {XC | C \u2208 S}; Kv is obtained from Kv by replacing each\nC \u2208 S with XC ; and T h = Th \u222a {XC \u2261 C | C \u2208 S}. Clearly, Kv \u222a Th is equisatisfiable with\nKv \u222a T h, and \u0393,Kv, T h \u2208 D. Let ibqx2 be an arbitrary import-by-query algorithm for L and D. We define ibqx1 as the algorithm that on each \u0393,Kv, Th \u2208 C simulates the steps of ibqx2 on input \u0393,Kv, T h \u2208 D, but with the following modifications:\n\u2022 ibqx1 [Th,\u0393,L] treats all concepts in S as if they were atomic; and\n\u2022 whenever ibqx2 [T h,\u0393,L] queries \u2126xT h,\u0393,L with a query Q , then ibqx1 [Th,\u0393,L] queries\n\u2126xTh,\u0393,L with a query Q obtained from Q  by replacing each occurrence of XC with C.\nThere is an obvious correspondence between the runs of ibqx2 [T h,\u0393,L] and ibqx1 [Th,\u0393,L] on Kv, so ibqx1 is an import-by-query algorithm for L and C."}, {"heading": "4. Limitations of the Import-by-Query Framework", "text": "In this section, we explore the limitations of the import-by-query framework and show that import-by-query algorithms do not exist under certain conditions. Our negative results apply to classes of input where Kv and Th are expressed in a description logic DL that is as lightweight as possible, the oracle is based on ABox satisfiability, and the oracle accepts queries expressed in a description logic L that is as expressive as possible. By Theorem 1 and Proposition 2, our results also apply to all other oracle types, queries expressed in a fragment of L, and all classes of input where Kv and Th are expressed in a description logic that extends DL.\nIn particular, in Section 4.1 we establish the following general limitations of the importby-query framework.\n\u2022 The presence of nominals in Th may preclude the existence of an import-by-query algorithm even if \u0393 = \u2205 (cf. Theorem 4).\n\u2022 Deductive modularity of the TBox of Kv w.r.t. \u0393 is a necessary condition for the existence of an import-by-query algorithm (cf. Theorem 5).\n\u2022 Deductive modularity, however, is not sufficient, even if Kv and Th are in EL and \u0393 is allowed to contain only atomic concepts (cf. Theorem 6).\nIn response to these negative results, all import-by-query algorithms proposed in this paper are subjected to the following restrictions:\nR1. Th is not allowed to contain nominals.\nR2. The TBox of Kv is required to be semantically modular w.r.t. \u0393.\nWe show in Section 5.1 that these two restrictions are sufficient to guarantee the existence of an import-by-query algorithm for Kv in ALCHIQ and Th in ALCHIQ, provided that \u0393 contains only atomic concepts.\nIn Section 4.2, however, we show that further restrictions on the input are necessary if \u0393 is allowed to contain atomic roles. Roughly speaking, restrictions R1 and R2 are insufficient since the axioms in Kv can arbitrarily propagate information about the symbols private to Kv via a role in \u0393 to a \u201chidden\u201d part of the canonical model of Kv\u222aTh (that is, a part of the canonical model that cannot be constructed using only the axioms in Kv); such propagation\ncan occur both via existential (cf. Theorem 7) and universal quantification (cf. Theorem 8). To overcome these negative results, we define in Section 5.1 the HT-safety condition that, on the one hand, ensures semantic modularity and, on the other hand, prevents arbitrary transfer of information about the symbols private to Kv to hidden parts of the canonical model via a role in \u0393. This condition, however, is still insufficient to enable import-byquery reasoning if Th contains universal quantifiers, inverse roles, and functional roles, and Kv entails cyclic axioms of the form A  \u2203R.A for R \u2208 \u0393 and A \u2208 \u0393 (cf. Theorem 9). To overcome this negative result, in Section 5.1 we introduce an acyclicity condition that together with HT-safety guarantees the existence of an import-by-query algorithm based on ABox satisfiability oracles for Kv and Th expressed in ALCHIQ.\nFinally, in Section 4.3 we show that no import-by-query algorithm based on concept satisfiability oracles exists for the class of inputs C[\u0393C ,KCv , T Ch ] where KCv is in EL and it satisfies the HT-safety condition, and T C\nh is in EL (cf. Theorem 10). In Section 5.2.2,\nhowever, we present an algorithm based on ABox entailment oracles that applies to this class of inputs C. Thus, practically relevant cases exist for which import-by-query reasoning is impossible with concept satisfiability oracles, but it becomes feasible with ABox oracles."}, {"heading": "4.1 General Limitations", "text": "We first show that the presence of nominals in the hidden knowledge base precludes the existence of an import-by-query algorithm if the visible knowledge base is satisfiable only in infinite models. Expressive DLs used in practice often do not have the finite model property, and our negative result holds even if the shared signature is empty; thus, in the rest of this paper we do not further consider DLs with nominals, and we leave an investigation of conditions that enable import-by-query reasoning with such DLs for future work.\nTheorem 4. For each description logic DL without the finite model property, no importby-query algorithm based on ABox satisfiability oracles exists for L = ALCHOIQ and the class of inputs C[\u0393C ,KCv , T Ch ] where \u0393C = \u2205, KCv is a DL-knowledge base, and T Ch is an ALCHOIQ-TBox.\nProof. Let C be an arbitrary class of inputs and let ibqa be an arbitrary import-by-query algorithm such that C and ibqa both satisfy the theorem\u2019s assumptions. Furthermore, let \u0393,Kv, T 1h  \u2208 C be an arbitrary input where KCv is satisfiable only in infinite models, \u0393 = \u2205, and T 1\nh = \u2205. Since all runs of ibqa[T 1 h ,\u0393,L] on Kv are finite, the number of individuals\noccurring in a query ABox in each such run is bounded by some integer n. Let T 2 h be as follows, where O1, . . . , On are fresh nominal concepts:\nT 2h = {  O1  . . . On} (9)\nClearly, Kv \u222a T 1h is satisfiable, but Kv \u222a T 2h is not. Consider now an arbitrary query ABox A occurring in a run of ibqa[T 1\nh ,\u0393,L]. Since \u0393 = \u2205, A consists only of assertions of the form\na \u2248 b or a \u2248 b; furthermore, A contains at most n individuals, so \u2126aT 1h ,\u0393(A) = t implies \u2126aT 2h ,\u0393\n(A) = t, and the converse holds by the monotonicity of first-order logic. But then, by Proposition 1, the runs of ibqa[T 1\nh ,\u0393,L] on Kv coincide with the runs of ibqa[T 2h ,\u0393,L] on\nKv, which contradicts the fact that Kv \u222a T 1h is satisfiable but Kv \u222a T 2h is not.\nWe next present a very strong result: deductive modularity is a necessary requirement for the existence of an import-by-query algorithm; that is, no import-by-query algorithm exists for any class of inputs that contains a triple \u0393,Kv, Th such that the TBox of Kv is not deductively modular w.r.t. \u0393. Intuitively, without deductive modularity, Kv can arbitrarily influence the consequences of Th, and the oracle cannot take this into account since it does not have access to the axioms of Kv. For the sake of generality, we do not impose any conditions on \u0393.\nTheorem 5. Let DL1 be an arbitrary fragment of ALCHIQ; let DL2 be an arbitrary description logic that extends EL and allows for DL1-definitions; let \u0393 be an arbitrary signature; and let Kv be an arbitrary satisfiable DL1-knowledge base whose TBox is not deductively modular w.r.t. \u0393. Then, no import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[\u0393C ,KCv , T Ch ] where \u0393C = \u0393, KCv = Kv, and T Ch is a DL2-TBox.\nProof. Let C be a class of inputs satisfying the theorem\u2019s conditions, and let \u0393,Kv, T 1h  \u2208 C be an input where T 1\nh = \u2205. Since Kv is not deductively modular w.r.t. \u0393, possibly com-\nplex DL1 concepts C1 and C2 exist such that sig(C1) \u2286 \u0393, sig(C2) \u2286 \u0393, Tv |= C1  C2, and \u2205 |= C1  C2. Let ibqa be an import-by-query algorithm for L = ALCHIQ and C. Finally, let T 2\nh be as follows, where A, B1, B2, and R do not occur in \u0393.\nT 2h = { B1 \u2261 C1, B2 \u2261 C2,   \u2203R.(A B1), A B2  \u22a5 } (10)\nClearly, Kv \u222a T 1h is satisfiable, but Kv \u222a T 2h is not. Consider now an arbitrary L-ABox A such that sig(A) \u2286 \u0393. If A \u222a T 1\nh is unsatisfiable, so is A \u222a T 2 h . Conversely, assume\nthat A \u222a T 1 h is satisfiable in a model I  = (I , \u00b7I). Since \u2205 |= C1  C2, an interpretation I  = (I , \u00b7I) and a domain element x \u2208 I exist such that x \u2208 CI1 but x \u2208 CI  2 . Without loss of generality we assume that I \u2229I = \u2205. Let I be the following interpretation:\nI = I \u222aI\naI = aI for each individual a occurring in A AI = {x} BI1 = CI  1 \u222a CI  1 BI2 = CI  2 \u222a CI  2 RI = {o, x | o \u2208 I} XI = XI \u222aXI for each atomic concept or role X \u2208 \u0393\nNow for each ALCHIQ-concept E such that sig(E) \u2286 \u0393, since I and I are disjoint, by a straightforward induction on the structure of E one can show that EI = EI \u2229I and EI\n = EI \u2229I . Furthermore, SI \u2286 SI for each atomic role S \u2208 \u0393. Thus I |= A, and it is straightforward to check that I |= T 2\nh . Consequently, \u2126aT 1h ,\u0393,L (A) = \u2126aT 2h ,\u0393,L(A) for each LABox A with sig(A) \u2286 \u0393. Hence, by Proposition 1, the runs of ibqa[T 1\nh ,\u0393,L] on Kv coincide\nwith the runs of ibqa[T 2 h ,\u0393,L] on Kv, which contradicts the fact that Kv \u222a T 1h is satisfiable but Kv \u222a T 2h is not.\nWhile Theorem 5 shows that deductive modularity is a necessary requirement for an import-by-query algorithm to exist, the following theorem shows that it is not a sufficient\nrequirement, even if \u0393 contains only atomic concepts, Kv is an EL-knowledge base, and Th is an EL-TBox.\nTheorem 6. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[\u0393C ,KCv , T Ch ] where \u0393C contains only atomic concepts, KCv and T Ch are in EL, and the TBox of KCv is deductively modular w.r.t. \u0393C.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem\u2019s assumptions, let \u0393 = {A, B,C}, and let Kv, T 1h , and T 2h be the following EL knowledge bases:\nKv = { A(a), B  \u2203R.C } (11) T 1h = { C  \u22a5 } (12) T 2h = T 1h \u222a { A  \u2203S.B } (13)\nThe TBox of Kv is clearly deductively modular w.r.t. \u0393, so \u0393,Kv, T ih  \u2208 C for i \u2208 {1, 2}; furthermore, Kv \u222a T 1h is satisfiable, whereas Kv \u222a T 2h is not. Consider now an arbitrary query ABox A such that sig(A) \u2286 \u0393; since A contains only assertions of the form X(a), \u00acX(a), a \u2248 b, and a \u2248 b where sig(X) \u2286 \u0393, we have \u2126aT 1h ,\u0393,L(A) = \u2126 a T 2h ,\u0393,L\n(A). But then, by Proposition 1, the runs of ibqa[T 1\nh ,\u0393,L] on Kv coincide with the runs of ibqa[T 2h ,\u0393,L]\non Kv, which contradicts the fact that Kv \u222a T 1h is satisfiable but Kv \u222a T 2h is not.\nWhile deductive modularity is not sufficient, semantic modularity is sufficient in some cases: in Section 5.1 we present an import-by-query algorithm that can be applied to the case when \u0393 contains only atomic concepts, Kv and Th are in ALCHIQ, and the TBox of Kv is semantically modular w.r.t. \u0393."}, {"heading": "4.2 Limitations of Importing Atomic Roles", "text": "In this section, we establish the limitations of the import-by-query framework for the cases when \u0393 is allowed to contain atomic roles. In particular, we show that semantic modularity is not sufficient to guarantee existence of an import-by-query algorithm.\nTheorems 7 and 8 demonstrate problems that arise due to certain fundamental limitations of our oracle query languages. To understand the intuition behind these results, assume that the shared signature \u0393 contains one atomic role R. Even in the relatively simple DL EL, knowledge base Th can imply existence of arbitrarily long R-chains using an axiom such as C  \u2203R.C. All of the oracle languages that we consider, however, can examine only bounded prefixes of such chains. For example, assume that we use an ABox satisfiability oracle and a query language based on ALCHIQ. Each concept in a query ABox corresponds to a first-order formula, and it is well known that the satisfiability of such a formula in a first-order interpretation depends on the formula\u2019s quantifier depth. Since the number of oracle calls in a run of an import-by-query algorithm must be bounded, an import-by-query algorithm can examine only a bounded prefix of a model of Th. But this leads us to a fundamental problem: if Th is changed so that it has \u201cinteresting consequences\u201d that can be detected only by examining longer R-chains, then such consequences will go undetected by our algorithm and render the algorithm incorrect. Theorem 7 exploits the fact that the\n\u201cinteresting consequences\u201d of Th are detected by Kv using axioms with existentially quantified concepts (i.e., our proof uses axiom \u2203R.B2  B2), whereas Theorem (8) analogously uses axioms with universally quantified concepts (i.e., B  \u2200R.B).\nAn alternative intuitive explanation of the results in Theorems 7 and 8 is to think of the culprit axioms \u2203R.B2  B2 and B  \u2200R.B in Kv as propagating information from Kv into Th. In order not to miss the \u201cinteresting consequences\u201d of Th, an import-by-query algorithm must examine a \u201csufficiently large\u201d portion of the hidden part of a canonical model of Kv \u222a Th in order to correctly evaluate the culprit axioms. This, however, is impossible because no bound on the portion size can be determined from the algorithm\u2019s inputs.\nTheorem 7. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[\u0393C ,KCv , T Ch ] where \u0393C is arbitrary, KCv and T Ch are expressed in EL, and the TBox of KCv is semantically modular w.r.t. \u0393C.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem\u2019s assumptions, let \u0393 = {A1, A2, R}, and let Kv be the following EL knowledge base:\nKv = { B1(a), B1  \u2203S.A1, A2  B2, \u2203R.B2  B2, \u2203S.B2  \u22a5 } (14)\nThe TBox of Kv is semantically modular w.r.t. \u0393: for each interpretation I of the symbols in \u0393, the interpretation J such that XJ = XI for each X \u2208 \u0393, BJ1 = \u2205, BJ2 = J , and SJ = \u2205 is a model of the TBox of Kv. Let T 1h be the following EL TBox:\nT 1h = { A1  C, C  \u2203R.C } (15)\nSince each run of ibqa[T 1 h ,\u0393,L] on Kv is finite, an integer n exists such that each query ABox occurring in a run contains concepts of quantifier depth at most n. Let T 2\nh be the\nfollowing EL TBox:\nT 2 h = {A1  \u2203R . . . \u2203R   .A2 } n + 1 times\n(16)\nClearly, Kv \u222a T 1h is satisfiable, whereas Kv \u222a T 2h is not. Consider an arbitrary query ABox A occurring in a run of ibqa[T 1\nh ,\u0393,L]. We next show that \u2126aT 1h ,\u0393,L(A) = \u2126 a T 2h ,\u0393,L (A). Assume that T 1\nh \u222aA is satisfiable. Since A is expressed in ALCHIQ and T 1 h is in EL, a\ncanonical forest model I = (I , \u00b7I) of T 1 h \u222aA exists (e.g., such a model can be obtained by applying the hypertableau algorithm to T 1 h\nand A). Due to (15), for each x \u2208 AI1, an infinite sequence {\u03b1x0 ,\u03b1x1 ,\u03b1x2 , . . .} \u2286 I exists such that \u03b1x0 = x and \u03b1xi ,\u03b1xi+1 \u2208 RI for each 0 \u2264 i. Let J = (J , \u00b7J) be the interpretation defined as follows:\nJ = I AJ2 = AI2 \u222a {\u03b1xn+1 | x \u2208 AI1} XJ = XI for each X = A2\nClearly, J |= T 2 h . Furthermore, since I |= A, A contains concepts of quantifier depth at most n, and I and J \u201ccoincide up to depth n,\u201d we have J |= A. Thus, T 2\nh \u222aA is satisfiable.\nAssume that T 2 h \u222aA is satisfiable. Then a canonical forest model I = (I , \u00b7I) of T 2 h \u222aA exists. Due to (16), for each x \u2208 AI1, a finite sequence {\u03b1x0 ,\u03b1x1 ,\u03b1x2 , . . . ,\u03b1xn+1} \u2286 I exists\nsuch that \u03b1x0 = x and \u03b1xi ,\u03b1xi+1 \u2208 RI for each 0 \u2264 i < n. Let J = (J , \u00b7J) be the interpretation defined as follows:\nJ = I RJ = RI \u222a {\u03b1x n+1,\u03b1 x n+1 | x \u2208 AI1} CJ = {\u03b1x0 , . . . ,\u03b1xn+1 | x \u2208 AI1} XJ = XI for each X \u2208 {R,C}\nClearly, J |= T 1 h . Furthermore, since I |= A, C \u2208 sig(A), A contains only concepts of quantifier depth at most n, and I and J \u201ccoincide up to depth n\u201d, we have J |= A. Thus, T 1\nh \u222aA is satisfiable. By Proposition 1, the runs of ibqa[T 1\nh ,\u0393,L] on Kv coincide with the runs of ibqa[T 2h ,\u0393,L]\non Kv, which contradicts the fact that Kv \u222a T 1h is satisfiable but Kv \u222a T 2h is not.\nTheorem 8. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[\u0393C ,KCv , T Ch ] where \u0393C is arbitrary, KCv is expressed in FL0, T Ch is expressed in EL, and the TBox of KCv is semantically modular w.r.t. \u0393C.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem\u2019s assumptions, let \u0393 = {A1, A2, R}, and let Kv be the following FL0 knowledge base.\nKv = { A1(a), B(a), B  \u2200R.B, A2 B  \u22a5 } (17)\nThe TBox of Kv is semantically modular w.r.t. \u0393: for each interpretation I for \u0393, the interpretation J such that XJ = XI for each X \u2208 \u0393 and BJ = \u2205 is a model of the TBox of Kv. Let T 1h be the EL TBox (15) given in the proof of Theorem 7. Since each run of ibqa[T 1\nh ,\u0393,L] on Kv is finite, an integer n exists such that each query ABox occurring in\na run contains concepts of quantifier depth at most n. Let T 2 h be the the EL TBox (16) from Theorem 7. Clearly, Kv \u222a T 1h is satisfiable, whereas Kv \u222a T 2h is not. Using arguments analogous to those from the proof of Theorem 7, one can show that \u2126aT 1h ,\u0393,L\n(A) = \u2126aT 2h ,\u0393,L(A) for each query ABox A occurring in a run of ibqa[T 1\nh ,\u0393,L]. By Proposition 1, the runs of\nibqa[T 1 h ,\u0393,L] on Kv coincide with the runs of ibqa[T 2h ,\u0393,L] on Kv, which contradicts the fact that Kv \u222a T 1h is satisfiable but Kv \u222a T 2h is not.\nA possible way to overcome these negative results is to prevent the axioms in Kv from propagating information via the roles in \u0393 into the hidden part of a canonical model of Kv \u222a Th. In Section 5.1, we achieve this by requiring Kv to be HT-safe. Roughly speaking, such Kv is semantically modular w.r.t. \u0393, but, in addition, it can be translated into a set of HT-rules Rv where variables x and y in each role atom of the form R(x, y) with R \u2208 \u0393 are \u201cguarded\u201d by suitable concepts. For example, although the knowledge base Kv in (17) is semantically modular w.r.t. \u0393 = {A1, A2, R}, the axiom B  \u2200R.B \u2208 Kv violates the HTsafety condition since the body of its corresponding HT-rule B(x) \u2227R(x, y) \u2192 B(y) does not contain a \u201cguard\u201d concept atom for variable y. In order to streamline the presentation and ensure that all notions needed to enable import-by-query reasoning are defined in one place, we formalize HT-safety in Definition 6 in Section 5.1. Unfortunately, as Theorem 9 shows, HT-safety alone does not ensure existence of an import-by-query algorithm.\nTheorem 9. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[\u0393C ,KCv , T Ch ] where \u0393C is arbitrary, KCv is expressed in EL, T C\nh is expressed in Horn-ALCIF , and the TBox of KCv is HT-safe w.r.t. \u0393C.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem\u2019s assumptions, let \u0393 = {B, R}, and let Kv be the following EL knowledge base:\nKv = { A(a), B(a), A  \u2203R.A } (18)\nThe TBox of Kv is semantically modular w.r.t. \u0393: for each interpretation I for \u0393, the interpretation J such that XJ = XI for each X \u2208 \u0393 and AJ = \u2205 is a model of the TBox of Kv. According to Definition 6, the TBox of Kv is then HT-safe as well. Let T 1h be the following Horn-ALCIF TBox:\nT 1h = { B  C  \u22a5, B  \u2200R.C, C  \u2200R.C,   \u2264 1 R\u2212 } (19)\nSince each run of ibqa[T 1 h ,\u0393,L] on Kv is finite, integers n and m exist such that each query ABox occurring in a run contains at most n individuals and concepts of quantifier depth at most m. Let k = n + m and let D0, . . . ,Dk be distinct and fresh atomic concepts. Let T 2h be the following Horn-ALC TBox:\nT 2 h = T 1 h \u222a { Di Dj  \u22a5, | 0 \u2264 i < j \u2264 k } \u222a { Dj\u22121  \u2200R.Dj | 1 \u2264 i \u2264 k } \u222a { B  D0, Dk  \u22a5 }\n(20)\nClearly, Kv \u222a T 1h is satisfiable, whereas Kv \u222a T 2h is not. Consider an arbitrary query ABox A occurring in a run of ibqa[T 1\nh ,\u0393,L]. We next show that \u2126aT 1h ,\u0393,L(A) = \u2126 a T 2h ,\u0393,L (A). This clearly holds if T 1\nh \u222aA is unsatisfiable, so assume that T 1 h \u222aA is satisfiable. Then, there\nexists a canonical forest model I = (I , \u00b7I) of T 1 h \u222aA. Consider now an arbitrary domain element x \u2208 BI . We say that a domain element y \u2208 I is reachable from x in  steps if a sequence of domain elements \u03b10 = x,\u03b11,\u03b12, . . . ,\u03b1 = y exist such that \u03b1i,\u03b1i+1 \u2208 RI for each 1 \u2264 i < . For each such x and y, the axioms of T 1\nh ensure the following properties:\n1. Each such sequence is unique and it consists of unique domain elements. This is because RI is an inverse-functional relation so, for each 0 \u2264 i < , domain element \u03b1i is the only element such that \u03b1i,\u03b1i+1 \u2208 RI , so \u03b1i = \u03b1j for 0 < i < j \u2264 ; furthermore, \u03b10 \u2208 BI and \u03b10 \u2208 CI , and \u03b1i \u2208 CI for 0 < i \u2264 , which ensures \u03b10 = \u03b1i for 0 < i \u2264 .\n2. No x \u2208 BI distinct from x exists such that y is reachable form x. This is because xi \u2208 BI for each 0 < i \u2264  and RI is inverse-functional.\n3.  < k. This is because A contains at most n individuals and all concepts in A are of quantifier depth at most m.\nLet J = (J , \u00b7J) be an interpretation defined as follows:\nJ = I XJ = XI for each X \u2208 sig(T 1 h ) DJ k = \u2205 DJ\ni =\n\nx\u2208BI {y \u2208 I | y is reachable from x in i steps } for each 0 \u2264 i < k\nInterpretations I and J coincide on the symbols from T 1 h , so J |= A \u222a T 1 h . Furthermore, if y \u2208 DI\ni with i < k, by properties 1\u20133 then y \u2208 DI j for each j = i, so J |= A \u222a T 2 h . But then,\nby Proposition 1, the runs of ibqa[T 1 h ,\u0393,L] on Kv coincide with the runs of ibqa[T 2h ,\u0393,L] on Kv, which contradicts the fact that Kv \u222a T 1h is satisfiable but Kv \u222a T 2h is not.\nThe proof of Theorem 9 uses Kv that implies A  \u2203Rn.A for arbitrary n, where A \u2208 \u0393 and R \u2208 \u0393. Furthermore, axioms in Th containing universally quantified concepts propagate information along an R-chain to an unknown level m. An import-by-query algorithm cannot determine the depth to which it must examine a model of Kv, which precludes the termination requirement of Definition 4. In Section 5.1, we present a sufficient acyclicity restriction on Kv that bounds n and ensures the existence of an import-by-query algorithm."}, {"heading": "4.3 ABox vs. Concept Satisfiability Oracles", "text": "In this section we show that, for Kv an EL-knowledge base and and Th an EL-TBox, no import-by-query algorithm based on concept satisfiability oracles exists, even if Kv is HTsafe w.r.t. \u0393. This is interesting because in Section 5.2.2 we present an algorithm based on ABox entailment oracles that can handle such a case. Thus, ABox oracles are strictly more expressive than concept satisfiability oracles.\nTheorem 10. No import-by-query algorithm based on concept satisfiability oracles exists for L = ALCHIQ and the class of inputs C[\u0393C ,KCv , T Ch ] where \u0393C is arbitrary, KCv and T Ch are expressed in EL, and the TBox of KCv is HT-safe w.r.t. \u0393C. Proof. Let ibqc be an import-by-query algorithm satisfying the theorem\u2019s assumptions, let \u0393 = {R}, and let Kv be the following EL knowledge base:\nKv = { A(a), A  \u2203R.A } (21)\nBy Definition 6, the TBox of Kv is HT-safe. Let T 1h = \u2205. Each run of ibqc[T 1h ,\u0393,L] on Kv is finite, so an integer n exists such that each query concept occurring in a run contains concepts of quantifier depth at most n. Let T 2\nh be the following EL TBox:\nT 2 h = { \u2203R. . . .\u2203R   .  \u22a5 } n + 1 times\n(22)\nClearly, Kv \u222a T 1h is satisfiable, whereas Kv \u222a T 2h is not. Furthermore, it is straightforward to see that, for each ALCHIQ concept C of quantifier depth at most n with sig(C) \u2286 \u0393, we have T 1\nh |= C  \u22a5 if and only if T 2 h |= C  \u22a5, so \u2126cT 1h ,\u0393(C) = \u2126 c T 2h ,\u0393 (C). But then, by Proposition 1, the runs of ibqc[T 1\nh ,\u0393,L] on Kv coincide with the runs of ibqc[T 2h ,\u0393,L] on\nKv, which contradicts the fact that Kv \u222a T 1h is satisfiable but Kv \u222a T 2h is not.\nNote that the knowledge base Kv used in the proof of Theorem 10 is analogous to the one from the proof of Theorem 9\u2014that is, it entails a cyclic axiom of the form A  \u2203R.A with R \u2208 \u0393 but A \u2208 \u0393. The negative result from Theorem 9, however, does not apply in this case because Th is expressed in EL. The algorithm presented in Section 5.2.2 can handle such knowledge bases via an ABox entailment oracle. Intuitively, this is because ABoxes can encode cyclic structures, whereas concepts cannot."}, {"heading": "5. Import-by-Query Algorithms", "text": "In this section, we identify several cases in which import-by-query algorithms exist. For simplicity, throughout this section we assume that Kv does not contain \u0393-modal concepts; by Theorem 3 this is without loss of generality.\nTo overcome the negative results from Section 4, in Sections 5.1.1 and 5.1.2 we introduce the HT-safety and acyclicity conditions, respectively, that Kv must satisfy in order to prevent the undesirable interactions between the axioms of Kv and Th. Furthermore, in the rest of this paper we assume that Kv is preprocessed as described by Motik et al. (2009) into the corresponding set of HT-rules Rv and ABox Av; this will be convenient because HT-rules do not contain nested quantifiers. We thus formulate HT-safety and acyclicity in terms of Rv and Av, and we define Kv as being HT-safe (resp. acyclic) if the corresponding Rv and Av are HT-safe (resp. acyclic). All our algorithms take as inputs Rv and Av, and we specify the allowed inputs using classes C[\u0393C ,RCv \u222a ACv , T Ch ] of triples \u0393C ,RCv \u222aACv , T Ch  where Rv is a set of HT-clauses, Av is a normalized ABox, and sig(RCv \u222aACv ) \u2229 sig(T Ch ) \u2286 \u0393C .\nIn Section 5.1 we present a general import-by-query algorithm based on ABox satisfiability oracles that is applicable to the case when Kv imports both atomic concepts and roles, and Kv and Th are expressed in ALCHIQ. In order for the algorithm to be applicable, however, Kv must be both HT-safe and acyclic. If \u0393 contains only atomic concepts, then acyclicity is vacuously satisfied for each Kv and HT-safety becomes equivalent to semantic modularity; thus, if only atomic concepts are shared, our algorithms is applicable whenever Kv is semantically modular w.r.t. \u0393.\nThe algorithm from Section 5.1, however, is unlikely to be suitable for practice due to a high degree of nondeterminism. Therefore, in Section 5.2.1 we present an import-by-query algorithm based on ABox entailment oracles that, we believe, is suited for implementation and optimization. The algorithm requires Th to be a Horn knowledge base, which allows the algorithm to be more goal-oriented.\nThe practical algorithm from Section 5.2.1 can readily be applied to EL knowledge bases, but it is not guaranteed to be optimal. Therefore, in Section 5.2.2 we present an EL-specific import-by-query algorithm for the case when Kv and Th are expressed in EL. In addition to being optimal on EL knowledge bases, this EL-specific algorithm does not require Kv to be acyclic and it somewhat relaxes the HT-safety requirement.\n5.1 Import-by-Query in ALCHIQ We next present an import-by-query algorithm based on ABox satisfiability oracles that is applicable to a set of HT-rules Rv and a TBox Th in ALCHIQ. No assumptions are made on the type of symbols in \u0393: Rv can reuse both atomic concepts and roles from Th."}, {"heading": "5.1.1 HT-Safety", "text": "We now define the HT-safety condition that allows us to overcome the negative results of Theorems 7 and 8, and that also guarantees semantic modularity required to overcome the negative results of Theorems 5 and 6. If \u0393 contains only atomic concepts, then HT-safety reduces to the semantic modularity of Rv w.r.t. \u0393.\nThe notion of HT-safety forRv consists of the following building blocks. We first identity the safe concepts\u2014that is, concepts private to Rv that should not be \u201cpropagated\u201d into the models of Th. Next, we transform Rv into a reduct by replacing in Rv all safe concepts with \u22a5, and we require the reduct to be semantically modular w.r.t. \u0393. The latter property ensures that any interpretation for the symbols in \u0393 can be extended to an interpretation of the symbols in Rv by interpreting safe concepts as the empty set. Finally, as motivated in\nSection 4.2, we impose a syntactic restriction on each HT-rule  \u2208 Rv: for each body atom R(x, y) in  with R \u2208 \u0393, we require variables x and y to be \u201cguarded\u201d by a safe concept.\nDefinition 6. Let Rv be a set of HT-rules and let \u0393 be a signature. The set of safe concepts of Rv and \u0393 is the smallest set safe(Rv,\u0393) such that, for each HT-rule  \u2208 Rv whose body contains an atom of the form R(x, yi) or R(yi, x) with R \u2208 \u0393 and an atom of the form A(x) or A(yi) with A \u2208 \u0393, we have A \u2208 safe(Rv,\u0393).\nThe reduct of Rv w.r.t. \u0393 is the set of rules obtained from Rv by removing each rule containing a concept in safe(Rv,\u0393) in the body, and then removing from the head of the remaining rules each atom containing a concept in safe(Rv,\u0393).\nThe set Rv is HT-safe w.r.t. \u0393 if\n1. the reduct of Rv w.r.t. \u0393 is semantically modular w.r.t. \u0393, and\n2. for each rule  \u2208 Rv and each body atom of  of the form R(x, yi) or R(yi, x) with R \u2208 \u0393, the body of  contains atoms A(x) and B(yi) such that A, B \u2208 safe(Rv,\u0393).\nHT-safety invalidates the proofs of Theorems 7 and 8: the knowledge bases Kv used in the proofs of these two theorems are not HT-safe w.r.t. the respective signatures \u0393. In particular, consider Kv used in the proof of Theorem 7. The set of HT-rules Rv obtained from the TBox of Kv is shown below.\nB1  \u2203S.A1  B1(x) \u2192 \u2203S.A1(x) (23) A2  B2  A2(x) \u2192 B2(x) (24)\n\u2203R.B2  B2  R(x, y) \u2227B2(y) \u2192 B2(x) (25) \u2203S.B2  \u22a5  S(x, y) \u2227B2(y) \u2192 \u22a5 (26)\nNow safe(Rv,\u0393) = {B2}. It is straightforward to see that the reduct of Rv w.r.t. \u0393, shown below, is not semantically modular w.r.t. \u0393 = {A1, A2, R}.\nB1(x) \u2192 \u2203S.A1(x) (27) A2(x) \u2192 \u22a5 (28)\nConsider now Kv used in the proof of Theorem 8. The set of HT-rules Rv obtained from the TBox of Kv is shown below.\nB  \u2200R.B  B(x) \u2227R(x, y) \u2192 B(y) (29) A2 B  \u22a5  A2(x) \u2227B(x) \u2192 \u22a5 (30)\nNow safe(Rv,\u0393) = {B}, so the reduct ofRv w.r.t. \u0393 is empty and thus semantically modular w.r.t. \u0393 = {A1, A2, R}; however, the first HT-rule does not satisfy Condition 2 from Definition 6 since the rule body does not contain an atom of the form A(y) with A \u2208 safe(Rv,\u0393).\nNote that, if \u0393 contains only atomic concepts, then safe(Rv,\u0393) = \u2205. The reduct of Rv w.r.t. \u0393 is then equal to Rv, so Condition 1 from Definition 6 holds if and only if Rv is semantically modular w.r.t. \u0393; furthermore, Condition 2 vacuously holds for Rv. Thus, HT-safety reduces to semantic modularity w.r.t. \u0393 if only atomic concepts are shared. The following proposition shows that, given an interpretation for the symbols in \u0393, we can obtain a model of Rv by interpreting safe concepts as the empty set.\nProposition 3. Let Rv be a set of HT-rules that is HT-safe w.r.t. \u0393. Then, for each interpretation I of the symbols in \u0393, a model J of Rv exists such that J = I , XJ = XI for each symbol X \u2208 \u0393, and XJ = \u2205 for each atomic concept X \u2208 safe(Rv,\u0393).\nProof. Let I be an interpretation for the symbols in \u0393, and let Rv be the reduct of Rv w.r.t \u0393. Since Rv is semantically modular w.r.t. \u0393, a model I  of Rv exists such that I\n = I and XI = XI for each symbol X \u2208 \u0393. Let J be the interpretation obtained from I  by setting XJ = \u2205 for each X \u2208 safe(Rv,\u0393). Consider now an arbitrary HT-rule  \u2208 Rv. If some A \u2208 safe(Rv,\u0393) occurs in the body of , then AJ = \u2205 clearly implies J |= . Otherwise, let  \u2208 Rv be the rule obtained by removing in  all head atoms that contain a safe concept; then I  |=  clearly implies J |= . Consequently, J |= Rv.\nFinally, note that HT-safety is not a syntactic condition; in fact, checking HT-safety is undecidable in general because it requires checking semantic modularity of a set of HT-rules w.r.t. a signature. As mentioned in Section 2.3, however, several practically useful syntactic conditions are known that guarantee semantic modularity (Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008), and any such condition can be used to obtain a purely syntactic HT-safety notion."}, {"heading": "5.1.2 Acyclicity", "text": "The negative result of Theorem 9 relies on Kv containing a cyclic axiom A  \u2203R.A with R \u2208 \u0393 and A \u2208 \u0393. We next present a sufficient condition that can detect such cycles in polynomial time.\nOur test involves a set of function-free first-order formulae with equality D(Rv,Av) whose consequences \u201csummarize\u201d the models ofRv \u222a Th \u222aAv; more precisely, the projection of each canonical model of Rv \u222a Th \u222aAv to the symbols in sig(Rv) can be homomorphically embedded into the set of ground facts entailed by D(Rv,Av). Intuitively, since the axioms of Th are not available, the facts entailed by D(Rv,Av) should reflect all possible consequences of Th and all information that can be derived using Rv \u222aAv. Theory D(Rv,Av) also keeps track of the paths in the \u201cvisible\u201d part of the canonical models of Rv \u222a Th \u222aAv by using two special binary predicates: Succ keeps track the \u201csuccessorship\u201d relation between domain elements, and \u0393-Desc keeps track the \u201cdescendant\u201d relation via roles contained in \u0393. The acyclicity condition then checks whether the \u0393-Desc relation as entailed by D(Rv,Av) is cyclic; if this is not the case, we can establish a bound on the length of paths of roles in \u0393.\nDefinition 7. Let Rv be a set of HT-rules, let Av be an ABox, and let \u0393 be a signature. For each atomic concept A \u2208 sig(Rv) \u222a sig(Av), let vA and v\u00acA be individuals uniquely associated with A and \u00acA, respectively; furthermore, let Succ and \u0393-Desc be binary predicates not occurring in Rv or Av. Function tt(\u00b7) maps each atom \u03b1 occurring in Rv \u222aAv into a conjunction of atoms as follows, where z is an arbitrary term:\n\u2022 tt(\u00acA(z)) = ;\n\u2022 tt(\u2265n R.C(z)) = ar(R, z, vC) \u2227 tt(C(vC)) \u2227 Succ(z, vC); and\n\u2022 tt(\u03b1) = \u03b1 for each atom \u03b1 of the form not covered by the above two cases.\nFurthermore, D(Rv,Av) is the set of function-free formulas of first-order logic with equality defined as follows, where all variables are implicitly universally quantified.\n\u2022 For each assertion \u03b1 \u2208 Av, set D(Rv,Av) contains tt(\u03b1).\n\u2022 For each individual c occurring in Av and each atomic concept A \u2208 \u0393, set D(Rv,Av) contains A(c).\n\u2022 For each HT-rule  \u2208 Rv of the form (1) and each 1 \u2264 j \u2264 n, set D(Rv,Av) contains the following formula:\ntt(U1) \u2227 . . . \u2227 tt(Um) \u2192 tt(Vj) (31)\n\u2022 For each atomic concept A \u2208 \u0393, set D(Rv,Av) contains the following formula:\nSucc(z1, z2) \u2192 A(z2) (32)\n\u2022 For all atomic roles R,R \u2208 \u0393, set D(Rv,Av) contains the following formulae:\nR(z1, z2) \u2192 R(z1, z2) (33) R(z1, z2) \u2192 R(z2, z1) (34)\nR(z, z1) \u2227R(z, z2) \u2192 z1 \u2248 z2 (35) R(z1, z) \u2227R(z2, z) \u2192 z1 \u2248 z2 (36) R(z1, z) \u2227R(z, z2) \u2192 z1 \u2248 z2 (37)\n\u2022 For each atomic role R \u2208 \u0393, set D(Rv,Av) contains the following formulae:\nSucc(z1, z2) \u2227R(z1, z2) \u2192 \u0393-Desc(z1, z2) (38) \u0393-Desc(z1, z2) \u2227 \u0393-Desc(z2, z3) \u2192 \u0393-Desc(z1, z3) (39)\nSet D(Rv,Av) contains a harmful cycle if D(Rv,Av) |= \u0393-Desc(vC , vC) for some vC . Furthermore, Rv \u222aAv is acyclic w.r.t. \u0393 if D(Rv,Av) does not contain a harmful cycle.\nThe set of formulae D(Rv,Av) can be straightforwardly transformed into an equivalent datalog program with equality using the well-known equivalences of first-order logic; therefore, we often refer to D(Rv,Av) as a datalog program.\nAcyclicity allows us to express axioms \u03b46 and \u03b48 from Table 3. Intuitively, acyclicity ensures that the \u201cvisible parts\u201d of the canonical forest models ofRv \u222a Th \u222aAv do not contain infinite chains of roles from \u0393; we use this property in our algorithm to define a suitable blocking condition. We explain this intuition by means of an example. Let \u0393 = {C, R, U} where C is a concept and R and U roles, Av = {A(a)}, and Rv contains the following HTrules; the corresponding formulae in D(Rv,Av) are shown after the \u201c\u201d symbol. Note that Rv is HT-safe w.r.t. \u0393.\nA(x) \u2192 \u2203R.B(x)  A(x) \u2192 R(x, vB) \u2227B(vB) \u2227 Succ(x, vB) (40) A(x) \u2192 \u2203S.C(x)  A(x) \u2192 S(x, vC) \u2227 C(vC) \u2227 Succ(x, vC) (41)\nA(x) \u2192 \u2203S.D(x)  A(x) \u2192 S(x, vD) \u2227D(vD) \u2227 Succ(x, vD) (42) S(x, y1) \u2227 S(x, y2) \u2192 y1 \u2248 y2  S(x, y1) \u2227 S(x, y2) \u2192 y1 \u2248 y2 (43)\nC(x) \u2227D(x) \u2192 \u2203S.A(x)  C(x) \u2227D(x) \u2192 S(x, vA) \u2227A(vA) \u2227 Succ(x, vA) (44)\nConsider also the following hidden TBox expressed in ALCHIQ:\nTh = {   \u2264 1 R., R  U\u2212, \u2203U.  C } (45)\nFigure 1(a) shows a canonical model I of Rv \u222aTh\u222aAv. Furthermore, Figure 1(c) shows the ground atoms entailed by D(Rv,Av) represented as a graph G in which solid arrows show roles R, U , and S, and dashed arrows show the special predicate \u0393-Desc; for clarity, the atoms involving the special predicate Succ have not been included in this and the following figures. Note that D(Rv,Av) entails R(vA, vB) and R(a, vB); these atoms, together with rules (34) and (35), entail vA \u2248 va; consequently, vA and va are represented in Figure 1(c) by the same node. Structure G \u201csummarizes\u201d I in the sense that I can be homomorphically embedded into G. The repetitive structure of I is represented in G as a cycle over nodes vA and vC via S; however, since S is not a shared symbol (i.e., S \u2208 \u0393), this does not give rise to a harmful cycle. Consequently, Rv \u222a Av is acyclic w.r.t. \u0393, which guarantees that the \u201cvisible\u201d part of a model of Rv \u222a Th \u222aAv does not contain R-chains of unbounded length, regardless of the contents of Th. Accordingly, the canonical model I of Rv \u222a Th \u222aAv shown in Figure 1(a) contains no such R-chains.\nNote, however, that G overestimates the canonical model I; for example, G contains an individual vA that is an instance of both A and C, which is not reflected in I. Now let us assume that Rv is Rv extended with the following HT-rule:\nA(x) \u2227 C(x) \u2192 \u2203R.C(x)  A(x) \u2227 C(x) \u2192 R(x, vC) \u2227 C(vC) \u2227 Succ(x, vC) (46) The canonical model of Rv \u222a Th \u222aAv is clearly the same as that of Rv \u222a Th \u222aAv; however, D(Rv,Av) contains a harmful cycle, as shown in Figure 1(d). Intuitively, D(Rv,Av) provides us with a conservative overestimate of the canonical models, which can in some cases detect \u201ccycles\u201d that do not really exist in canonical models. This is a necessary consequence of the fact that acyclicity can be checked in polynomial time.\nDefinition 7, however, provides us with a sufficient check. For example, let Rv be Rv extended with the following HT-rules:\nA(x) \u2192 \u2203R.E(x)  A(x) \u2192 R(x, vE) \u2227 E(vE) \u2227 Succ(x, vE) (47)\nB(x) \u2227 C(x) \u2227 E(x) \u2192 \u2203R.A(x)  B(x) \u2227 C(x) \u2227 E(x) \u2192 R(x, vA) \u2227A(vA) \u2227 Succ(x, vA) (48)\nThe canonical model of Rv\u222aTh\u222aAv and the ground atoms entailed by D(Rv ,Av) are shown in Figures 1(b) and 1(e), respectively. The HT-rules in Rv \\Rv enforce the existence of an infinite R-chain, which is reflected as a harmful cycle (e.g., the self-loop on vA).\nAcyclicity can indeed be checked in polynomial time, as shown next.\nProposition 4. Acyclicity of Rv \u222aAv w.r.t. \u0393 can be checked in polynomial time. Proof. Let D(Rv,Av) be as specified in Definition 7. The number of fresh individuals of the form vA and v\u00acA is clearly linear in the size of Rv, Av, and \u0393, so the size of D(Rv,Av) is polynomial in the size of Rv, Av, and \u0393.\nWe can compute the set of all positive ground atoms that follow from D(Rv,Av) in polynomial time using forward chaining. All predicates in D(Rv,Av) are of bounded arity, so the number of such atoms is polynomial in the size of D(Rv,Av). This straightforwardly implies the claim of this proposition if we show that, given a set of facts and a rule  \u2208 D(Rv,Av), we can compute the set of entailed facts in polynomial time. Rules not of the form (31) contain a bounded number of variables, so the set of entailed facts can be computed in polynomial time by simply considering all possible mappings of variables to individuals. Assume now that  is of the form (31). The number of variables in  is linear in the size of Rv, so there are exponentially many mappings of variables to individuals. We can, however, determine the values for x and yi that make the body true as follows. For each variable yi, let Pi be a binary relation that initially contains all pairs of individuals occurring in D(Rv,Av); this relation will eventually contain all pairs of values for x and yi that make the body of  true. We then remove from each Pi all pairs that do not satisfy all body atoms of  that contain only variables x and yi. Next, for all Pi and Pj , we remove all pairs c, c from Pi for which no c exists such that c, c \u2208 Pj . We then consider each consequent atom \u03b1 of ; if \u03b1 contains only variables x and yi, we infer all ground atoms obtained by replacing x with c and yi with c for each c, c \u2208 Pi; if \u03b1 contains only variables yi and yj , we infer all ground atoms c \u2248 c such that an individual c exists where c, c \u2208 Pi and c, c \u2208 Pj . This can clearly be done by polynomially many steps in the number of individuals in D(Rv,Av) and the maximal number of variables in a rule in Rv."}, {"heading": "5.1.3 An Import-by-Query Algorithm", "text": "We next present our import-by-query algorithm applicable to Rv \u222aAv that is HT-safe and acyclic w.r.t. \u0393. The algorithm modifies the standard hypertableau algorithm as follows. First, several cut rules nondeterministically guess all \u201crelevant\u201d assertions involving the symbols in \u0393. Second, the \u2126a-rule checks whether the guesses are indeed consistent with Th. Third, a relaxed blocking condition ensures termination.\nDefinition 8. Let C[\u0393C ,RCv \u222aACv , T Ch ] be the class of inputs where RCv \u222aACv is acyclic w.r.t. \u0393C, RCv is HT-safe w.r.t. \u0393C, and T Ch is an ALCHIQ TBox. The ALCHIQ \u2126a-algorithm takes a triple \u0393,Rv \u222aAv, Th \u2208 C and is obtained by modifying Definition 1 as follows.\nBlocking. An unnamed individual s is blocking-relevant in A if, for s the predecessor of s, we have\nLA(s, s) \u2229 \u0393 = LA(s, s) \u2229 \u0393 = \u2205.\nThen, each individual s in an ABox A is assigned a blocking status in the same way as in Definition 1, with the difference that s is directly blocked by t if, in addition to the conditions in Definition 1, both s and t are blocking-relevant.\nDerivation Rules. The derivation rules are given in Tables 2 and 4, where A|\u0393 is the ABox obtained from A by removing each assertion containing an indirectly blocked individual and each assertion \u03b1 such that sig(\u03b1) \u2286 \u0393.\nIn Section 5.1.4 we show that some of the cut rules in Table 4 are not needed if we know that Th is expressed in a description logic between ALC and ALCHIQ. Our algorithm is indeed an import-by-query algorithm, as we show next.\nTheorem 11. The ALCHIQ \u2126a-algorithm is an import-by-query algorithm based on ABox satisfiability oracles for the class of inputs C[\u0393C ,RCv \u222a ACv , T Ch ] from Definition 8. The algorithm can be implemented such that it runs in N2ExpTime in N , and the total number of oracle queries and the size of each query are both at most exponential in N , where N = |Rv \u222aAv|+ |\u0393| for the input Rv, Av, and \u0393.\nThe proof of Theorem 11 is lengthy and quite technical, so we defer it to the appendix and next discuss only the intuitions. The derivation rules from Table 2 are clearly sound.\nFurthermore, due to acyclicity, the chains of assertions involving roles from \u0393 are bounded in length, which enables blocking and ensures termination. We next sketch the completeness argument. In particular, for completeness we need to show that the existence of a clash-free ABox in a derivation to which no rule is applicable implies the satisfiability of the input. Let A be a clash-free ABox labeling the leaf of a derivation for \u0393,Rv \u222aAv, Th, and let Rh be the set of HT-rules corresponding to Th. Each model of Rv \u222aA \u222a Th can be extended to a model of Rv \u222aAv \u222a Th, so it suffices to show the satisfiability of Rv \u222aA \u222a Th. To this end, we extend A to a clash-free ABox Afin such that no derivation rule of the standard hypertableau algorithm is applicable to Rv \u222aRh and Afin; thus, Rv \u222aAfin \u222a Th is satisfiable, and since A \u2286 Afin so is Rv \u222aA \u222a Th by monotonicity. The construction of Afin proceeds as follows:\n1. We split the projection A|\u0393 of A to \u0393. In particular, we define Anm as the ABox containing all assertions of A|\u0393 involving individuals reachable from a named individual; furthermore, for each nonblocked blocking-relevant individual t, we define At as the ABox containing all assertions of A|\u0393 involving individuals reachable from t.\n2. We apply the standard hypertableau algorithm to Rh and each of the connected components of Anm, and Rh and each At; let Anmfin and Atfin be clash-free ABoxes labeling leaves of the respective derivations. The \u2126a-rule is not applicable to A so such ABoxes exist.\n3. We define Afin as the union of A, Anmfin , all Atfin, and all assertions C(s) such that s is blocked in A by the blocker s, C(s) \u2208 As\ufffffin, and sig(C) \u2286 sig(Rh).\nLet us call the individuals from A old, and the individuals introduced in the second step new ; we then observe the following. (1) Due to the cut rules, the second step above cannot derive fresh assertions involving only old individuals and the symbols in \u0393 without leading to a contradiction. (2) Each of the connected components of Anm and each At are disjoint, so the HT-rules from Rh can be applied in Afin only to subsets that correspond to a connected component of Anm and At. (3) Due to (1), no HT-rule from Rv can become applicable to assertions involving only old individuals. (4) Due to HT-safety, no HT-rule from Rv can become applicable to an assertion of Afin that involves a new individual. (5) Due to (1) and the third step from the construction above, if an individual s is blocked in A, Anmfin , or Atfin, then s is blocked in Afin as well. Then, (1)\u2013(5) imply that no derivation rule of the standard hypertableau algorithm is applicable to Rv \u222aRh and Afin, which proves completeness.\nWe explain this intuition on an example where \u0393 = {C, R}, Av = {A(a)}, Rv consists of HT-rules (40)\u2013(44), and Th is defined as follows:\nTh = { \u2203R.  C, C  \u2203T.C, C  E } (49)\nAs shown in Section 5.1.2, Rv \u222a Av is acyclic w.r.t. \u0393, so the ALCHIQ \u2126a-algorithm is applicable. The algorithm produces a derivation in which a leaf is labeled with the ABox A shown in Figure 2(a); for readability, we show neither the negative assertions nor the assertions involving complex concepts. Individual f is directly blocked by c in A, and assertions C(a) and C(d) are introduced by the A-cut rule. To construct Afin, the assertions containing a symbol not in \u0393 are removed, resulting in the ABox A|\u0393 shown in\nFigure 2(b). This ABox is then split into connected components Anm, Ac, and Ad; note that c and d are the only nonblocked blocking-relevant individuals. Next, Anm, Ac, and Ad are completed w.r.t. Rh using the standard hypertableau algorithm; Figure 2(c) shows the resulting ABoxes Anmfin , Acfin, and Adfin. Note that C(a) and C(d) in A are consistent with the axiom \u2203R.  C from Th. Finally, Afin is obtained by taking the union of A, Anmfin , Acfin, and Adfin, and adding E(f); the latter is because f is blocked by c and E(c) \u2208 Acfin. The result is shown in Figure 2(d); clearly, no derivation rule of the standard hypertableau algorithm is applicable to Afin.\n5.1.4 Hidden Ontology in DLs Between ALC and ALCHIQ The main limitation of the acyclicity condition from Definition 7 stems from the fact that we must anticipate all possible consequences of Th. Both the acyclicity conditions and the derivation rules from Table 4 can be simplified if the hidden ontology is known to be expressed in a description logic between ALC and ALCHIQ.\n\u2022 If Th is known not to use cardinality restrictions, then we can omit rules (35)\u2013(37) in the definition of D(Rv,Av), and the \u2248-cut rule in Table 4 is not required.\n\u2022 If Th is known not to use inverse roles, then we can omit rules (34), (36), and (37) in the definition of D(Rv,Av), the R\u2212-cut rule is not required, and Conditions 3.2 and 3.3 can be removed from the \u2248-cut rule.\n\u2022 If Th is known not to use role hierarchies, then we can omit rules (33) and (34) in the definition of D(Rv,Av), the R-cut in Table 4 is not required, and the R\u2212-cut rule need only be applied if R and R are the same.\nThese simplifications allow our approach to be applied to a wider range of visible ontologies. For example, consider the set Rv consisting of HT-rules (40)\u2013(44) and (47)\u2013(48), for which we obtained a harmful cycle w.r.t. \u0393 = {C, R, U}, as shown in Figure 1(e). If Th is known to be expressed in ALCHI (and so does not use cardinality restrictions), we\ncan omit formulas of the form (35)\u2013(37) in the definition of D(Rv,Av); the ground atoms entailed by such D(Rv,Av) are shown in Figure 3. This change makes Rv \u222aAv acyclic w.r.t. \u0393: we can now be sure that, for an arbitrary hidden TBox expressed in ALCHI, no infinite R-chains need to be considered during reasoning with Rv."}, {"heading": "5.2 Practical Import-by-Query Algorithms", "text": "The algorithm presented in Section 5.1.3 is not suited for practical implementation because the derivation rules in Table 4 incur a huge amount of nondeterminism. In this section, we present practical import-by-query algorithms in which nondeterministic rules are replaced with \u201con demand\u201d oracle calls, which makes the algorithms \u201cmore goal-oriented.\u201d Our algorithms make no assumptions about the kinds of symbols contained in \u0393: both atomic concepts and roles can be shared."}, {"heading": "5.2.1 Importing Horn Ontologies", "text": "In this section, we present a practical algorithm that applies when Th is expressed in the Horn-ALCHIQ fragment of ALCHIQ. It is well known that Th can then be transformed into a set of Horn HT-rules. This allows us to eliminate the nondeterministic cut rules, use an ABox entailment oracle instead of an ABox satisfiability oracle, and define oracle query rules that deterministically \u201ccomplete\u201d the query ABox A with the missing assertions entailed by Th\u222aA. Such an algorithm issues oracle queries on demand, so it is goal oriented and thus more amenable to implementation.\nDefinition 9. Let C[\u0393C ,RCv \u222aACv , T Ch ] be the class of inputs where RCv \u222aACv is acyclic w.r.t. \u0393C, RCv is HT-safe w.r.t. \u0393C, and T Ch is a Horn-ALCHIQ TBox. The Horn-ALCHIQ \u2126ealgorithm takes a triple \u0393,Rv \u222aAv, Th \u2208 C and is obtained from Definition 8 by replacing the derivation rules from Table 4 with those in Table 5.\nOur algorithm is indeed an import-by-query algorithm with the same worst-case complexity as the algorithm for the non-Horn case.\nTheorem 12. The Horn-ALCHIQ \u2126e-algorithm is an import-by-query algorithm based on ABox entailment oracles for the class of inputs C[\u0393C ,RCv \u222aACv , T Ch ] from Definition 9. The algorithm can be implemented such that it runs in N2ExpTime in N , and the total number of oracle queries and the size of each query are both also at most exponential in N , where N = |Rv \u222aAv|+ |\u0393| for the input Rv, Av, and \u0393.\nThe proof of Theorem 12 is obtained by a modification of the one for Theorem 11 and is given in the appendix."}, {"heading": "5.2.2 Import-by-Query in EL", "text": "In this section, we present an import-by-query algorithm based on ABox entailment oracles that can handle the case when both Kv and Th are expressed in EL. In this setting, only Theorems 5 and 7 provide clues about features that hinder existence of an import-by-query algorithm. In particular, it is no longer necessary for Kv to be acyclic.\nOur algorithm is again based on the hypertableau framework, so Kv is first converted into a set Rv of EL-rules and a normalized ABox Av. Since EL does not allow for inverse roles\nor universal quantification, there is no danger of information propagating from a successor to a predecessor; therefore, we can relax the HT-safety condition as shown in Definition 10.\nDefinition 10. Let Rv be a set of EL-rules, and let \u0393 be a signature Then, Rv is EL-safe w.r.t. \u0393 if\n\u2022 it satisfies Condition 1 from Definition 6, and\n\u2022 for each rule  \u2208 Rv and each body atom of  of the form R(x, yi) with R \u2208 \u0393, the body of  contains an atom B(yi) such that B \u2208 safe(Rv,\u0393).\nOur algorithm takes a set Rv of EL-safe rules and a normalized ABox Av. It applies the standard EL hypertableau derivation rules; furthermore, just like the Horn-ALCHIQ \u2126e-algorithm from Section 5.2.1, it uses the oracle to complete the ABoxes encountered in a derivation with the relevant concept assertions.\nDefinition 11. Let C[\u0393C ,RCv \u222aACv , T Ch ] be the class of inputs where RCv is a set of EL-rules that is EL-safe w.r.t. \u0393C, ACv is a normalized ABox, and T Ch is an EL TBox. The EL \u2126e-algorithm takes a triple \u0393,Rv \u222aAv, Th \u2208 C and is obtained by extending the algorithm from Definition 2 with the \u2126e-concept derivation rule shown in Table 5.\nOur algorithm is indeed an import-by-query algorithm, and it can be implemented to run in polynomial time, as shown by the following theorem. In contrast to algorithms we have presented thus far, the EL \u2126e-algorithm is both optimal and amenable to implementation.\nTheorem 13. The EL \u2126e-algorithm is an import-by-query algorithm based on ABox entailment oracles for the class of inputs C[\u0393C ,RCv \u222aACv , T Ch ] from Definition 11. The algorithm can be implemented such that it runs in PTime in N with a polynomial number in N of calls to \u2126eTh,\u0393, where N = |Rv \u222aAv|+ |\u0393| for the input Rv, Av, and \u0393.\nThe proof of Theorem 13 is rather technical and lengthy, and it is given in the appendix. The intuition behind the proof, however, is the same as in the case of the ALCHIQ \u2126aalgorithm, and the differences are due to the fact that the ABoxes produced by the EL \u2126e-algorithm have a specific shape."}, {"heading": "6. A Lower Bound on the Complexity of Import-by-Query Reasoning", "text": "In this section we show that no import-by-query algorithm that handles the same input as our ALCHIQ \u2126a-algorithm can make only a polynomial number (in |\u0393|) of queries each of which is of polynomial size (in |\u0393|). This result applies already if \u0393 contains only atomic concepts, so the only requirement for the ALCHIQ \u2126a-algorithm to be applicable is that the TBox of Kv is semantically modular w.r.t. \u0393.\nTheorem 14. Let C[\u0393C ,KCv , T Ch ] be the class of inputs where \u0393C contains only atomic concepts, KCv is an ALCHIQ knowledge base that is semantically modular in \u0393C, and T Ch is an ALCHIQ TBox. Then, no import-by-query algorithm ibqa based on ABox satisfiability oracles for L = ALCHIQ and C exists such that, for each input \u0393,Kv, Th \u2208 C, the total number of oracle queries in all possible runs of ibqa[Th,\u0393,L] on Kv, as well as the size of each query, are both polynomial in |\u0393|.\nProof. Assume that ibqa is an algorithm that satisfies the theorem\u2019s assumptions; then, integers c1 and c2 exist such that, for each input \u0393,Kv, Th \u2208 C, the total number of oracle queries in all possible runs of ibqa[Th,\u0393,L] on Kv is smaller than or equal to |\u0393|c1 , and the maximal size of each query ABox is smaller than or equal to |\u0393|c2 .\nWe next construct a particular input in C for which we show that ibqa violates the above assumption. Let k be an arbitrary integer such that kc1+c2 < 2k; such k exists since c1 and c2 are fixed. Let \u0393 = {A1, . . . , Ak} be arbitrary atomic concepts, and let Z, B, C1, . . ., Ck, C1, . . ., Ck be atomic concepts not occurring in \u0393. Then, we define Kv = Tv \u222aAv such that Av = {Z(a)} and Tv contains the following axioms:\nB  \u2203R.B (50) Z  B  C1  . . .  Ck (51)\nCj  Cj  \u22a5 1 \u2264 j \u2264 k (52)   (\u00acC1  \u2200R.C1)  (\u00acC1  \u2200R.C1) (53)\nCj\u22121  \u2203R.Cj\u22121  (\u00acCj  \u2200R.Cj)  (\u00acCj  \u2200R.Cj) 1 < j \u2264 k (54) Cj\u22121  (Cj\u22121  \u2203R.Cj\u22121)  (\u00acCj  \u2200R.Cj)  (\u00acCj  \u2200R.Cj) 1 < j \u2264 k (55)\nCi  Ai 1 \u2264 i \u2264 k (56)\nCi  \u00acAi 1 \u2264 i \u2264 k (57)\nTBox Tv uses the well-known \u201cinteger counting\u201d technique (Tobies, 2000). Consider an arbitrary model I of Kv. Domain elements of I can be assigned integers between 0 and 2k \u2212 1 by means of 2k atomic concepts C1, . . ., Ck, C1, . . ., Ck. Axiom (51) implies that aI \u2208 (Ck  . . .  C1)I , which \u201cinitializes the counter\u201d to 0. Axiom (50) ensures that aI is an origin of an infinite R-chain. Axioms (52) ensure that no domain element in this chain is labeled with both Cj and Cj . Axioms (53), (54), and (55) increment the counter over R. Finally, these axioms together with axioms (56) and (57) ensure that each possible number between 0 and 2k \u2212 1 is assigned to some domain element of I in the R-chain. Clearly, Tv is semantically modular w.r.t. \u0393 since we can extend each interpretation of the symbols of \u0393 to a model of Tv by interpreting the symbols not in \u0393 with the empty set.\nLet T 1 h = \u2205, let A1, . . . ,Am be the query ABoxes occurring in all possible runs of ibqa[T 1\nh ,\u0393,L] on Kv, and let n be the maximal size of Ai for 1 \u2264 i \u2264 m. By our assumptions,\nwe have m \u2264 kc1 and n \u2264 kc2 , which implies m\u00d7 n = kc1+c2 < 2k due to the way we chose k. For each 1 \u2264 i \u2264 m, let A\ni be the following ABox equivalent to Ai:\n\u2022 If Ai is unsatisfiable, then Ai = {\u22a5}.\n\u2022 If Ai is satisfiable, let Ai be an ABox that contains for each individual s exactly one concept assertion of the form D(s) where D is in disjunctive normal form; that is, D is expressed as a disjunction of concepts of the form (\u00ac)A1  . . .  (\u00ac)Ak. Such Ai can be obtained from Ai by applying de Morgan\u2019s laws.\nLet D1, . . . ,D be all disjunctive concepts that occur in some satisfiable ABox Ai. Each Ai contains at most n such concepts, so 1 \u2264  \u2264 m\u00d7 n. Furthermore, let U be the subset of {D1, . . . ,D} containing precisely those Di that have exactly one disjunct. Finally, let S be a concept of the form (\u00ac)A1  . . .  (\u00ac)Ak that does not occur in U ; such S exists because  \u2264 m\u00d7 n < 2k. Now let T 2\nh be the following TBox:\nT 2h = {S  \u22a5} (58)\nWe next show that, for each 1 \u2264 j \u2264 , concept Dj is satisfiable w.r.t. T 2h . The claim is trivial if Dj does not contain S; otherwise, Dj contains a disjunct S = S, so an interpretation satisfying T 2\nh and Dj can be obtained by interpreting S as a nonempty set.\nWe next show that \u2126aT 1h ,\u0393,L (A i ) = \u2126aT 2h ,\u0393,L (A i ) for each 1 \u2264 i \u2264 m; since Ai and Ai are\nequivalent, then \u2126aT 1h ,\u0393,L (Ai) = \u2126aT 2h ,\u0393,L(Ai) as well. The statement clearly holds if A  i is unsatisfiable, so assume that A\ni is satisfiable. Since A i consists of assertions of the form\nD(s) where D is satisfiable w.r.t. T 2 h , an interpretation satisfying A i \u222a T 2 h can be obtained as a disjoint union of the interpretations satisfying each D. By Proposition 1, the runs of ibqa[T 1\nh ,\u0393,L] on Kv then coincide with the runs of\nibqa[T 2 h ,\u0393,L] on Kv; however, it is straightforward to see that Kv\u222aT 1h is satisfiable, whereas Kv \u222a T 2h is unsatisfiable, which is a contradiction."}, {"heading": "7. Related Work", "text": "There is currently a growing interest in techniques for hiding parts of an ontology Th. One possible approach is to hide a subset\u03a5 of the signature of Th by first extracting from Th an\u03a5-\nmodule M\u03a5\u2014a subset of Th that preserves all \u03a5-consequences (i.e., all logical consequences formed using only the symbols in \u03a5)\u2014and then publishing the ontology Th \\M\u03a5. In order to ensure that no sensitive information about \u03a5 is being disclosed, the module M\u03a5 should be depleting (Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009)\u2014that is, ontology Th \\M\u03a5 should be indistinguishable from the empty ontology w.r.t. \u03a5-consequences. This approach ensures that no \u03a5-consequences are disclosed to external applications and offers the additional advantage that one can reason over the union of Kv and Th \\M\u03a5 using off-the-shelf DL reasoners. Finally, although determining whether a subset of an ontology is a depleting module for a signature is an undecidable problem for many DLs (and hence extraction of minimal depleting modules is often computationally infeasible), several practical techniques for extracting (not necessarily minimal) depleting modules are known (Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008).\nAn important disadvantage of this approach is that the module M\u03a5 may also contain relevant information that is not sensitive (e.g., M\u03a5 may entail consequences about symbols \u0393 not in \u03a5) and hence the union of Kv (which may use symbols from \u0393) and Th \\M\u03a5 may not contain enough information to answer relevant queries. Furthermore, by adopting this approach, the vendor of Th would distribute a subset of the axioms of Th, which may allow competitors to plagiarize parts of Th. Finally, the published axioms might mention symbols in \u03a5 (even if they do not entail any \u03a5-consequence) and external applications would be aware of the presence of those symbols in the ontology.\nSome of these drawbacks can be overcome by publishing an \u03a5-interpolant of Th\u2014an ontology that contains no symbols from \u03a5 and that coincides with Th on all logical consequences formed using the symbols not in \u03a5 (Konev et al., 2009; Wang et al., 2009, 2008; Lutz & Wolter, 2011; Nikitina, 2011). In contrast to the module extraction approach, publishing an interpolant ensures that the sensitive information in Th (i.e., the information about the symbols from Th not mentioned in the interpolant) is not exposed in any way to external applications; furthermore, interpolants preserve all consequences of symbols not in \u03a5. Similarly to the module extraction approach, using interpolation has the additional advantage that the developers of Kv can reason over the union of Kv and the interpolant using off-the-shelf DL reasoners.\nThe interpolation approach may, however, have several drawbacks. First, an interpolant may exist only if Th is expressed in a relatively weak DL and satisfies certain syntactic conditions (Konev et al., 2009). In contrast, import-by-query is often possible even if an interpolant of Th for the signature of interest does not exist.\nSecond, although interpolants preserve logical consequences formed using symbols not in \u03a5, they are not robust under replacement (Sattler et al., 2009)\u2014that is, the union of Kv and an \u03a5-interpolant of Th is not guaranteed to yield the same consequences as Th \u222aKv for a query q involving no symbols from \u03a5. For example, given \u03a5 = {R} and Th = {A  \u2203R.B}, the empty ontology is an\u03a5-interpolant (it preserves all consequences of the form C  D with C and D arbitrary boolean concepts over the signature {A, B}); however, for Kv = {B  \u22a5} we have that Kv \u222a Th entails the consequence A  \u22a5, whereas the union of Kv and the (empty) interpolant does not. Thus, once an interpolant has been published, it cannot be imported into Kv with the guarantee that all relevant consequences will be preserved, unless suitable restrictions are imposed to Kv.\nFinally, an \u03a5-interpolant of Th can be exponentially larger than Th, and may reveal more information than what is strictly needed. Although import-by-query algorithms can also formulate in the worst-case exponentially many queries to the oracle, our algorithms may limit the flow of irrelevant information from Th to Kv, especially if Th is expressed in a Horn DL, in which case our import-by-query algorithms issue queries \u201con demand.\u201d For example, for \u0393 = {R,C}, \u03a5 = \u2205, Kv = {A  \u2203R.B,B  C} and Th = {\u2203R.\u2203R.C  C}, the \u03a5-interpolant is equal to Th and thus publishing the interpolant reveals entire contents of Th. In contrast, our import-by-query algorithm for EL would not reveal any positive information about Th, as it would only disclose the fact that an ABox of the form {R(a, b), C(b)} is satisfiable w.r.t. Th.\nThe idea of accessing an ontology through an oracle is similar in spirit to the proposal by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2004) for query answering in a peerto-peer setting. The authors consider the problem of answering a conjunctive query q over KBs Kv and Kh and mappings M by reformulating q as queries that can be evaluated over Kv and Kh in isolation. The query reformulation algorithm accesses only Kv and M , so q can be answered using an oracle for Kh. In this setting, however, the focus is on the reuse of data, rather than schema. Since a satisfiable Kh cannot affect the subsumption of concepts in Kv, the results by Calvanese et al. (2004) are not applicable to schema reasoning."}, {"heading": "8. Conclusion", "text": "In this paper, we have proposed and studied the import-by-query framework. Our results provide a flexible way for ontology designers to ensure selective access to their ontologies. Our framework thus provides key theoretical insights into the issues surrounding ontology privacy. Furthermore, we believe our algorithms to be practicable when applied to Horn ontologies; thus, our results provide a starting point for the development of practical importby-query systems.\nThe problem of import-by-query is novel, and we see many open questions. For example, a problem that is relevant to both theory and practice is to allow the hidden ontology to selectively export data and not just schema statements."}, {"heading": "Acknowledgments", "text": "This is an extended version of the paper \u201cImport-by-Query: Ontology Reasoning under Access Limitations\u201d by Bernardo Cuenca Grau, Boris Motik, and Yevgeny Kazakov published at IJCAI 2009 and the paper \u201cPushing the Limits of Reasoning over Ontologies with Hidden Content\u201d by Bernardo Cuenca Grau and Boris Motik published at KR 2010.\nThis research has been supported by the Royal Society and the EPSRC projects ExODA (EP/H051511/1) and HermiT (EP/F065841/1)."}, {"heading": "Appendix A. Proof of Theorem 11", "text": "We will use the following definitions and intermediate results to prove the theorem.\nDefinition 12. An ABox A is an HT-ABox if all of its assertions satisfy the following conditions, for B an atomic or a negated atomic concept, S a role, R an atomic role, a and b named individuals, s an individual, and i and j integers.\n1. Each concept assertion in A is of the form B(s) or \u2265n S.B(s).\n2. Each role assertion in A is of the form R(a, b), R(s, s.i), or R(s.i, s).\n3. If an individual s.i occurs in an assertion in A, then A contains a role assertion of the form R(s, s.i) or R(s.i, s).\n4. Each equality in A is of the form s.i \u2248 s.j, s.i.j \u2248 s, s \u2248 s, or a \u2248 b.i. Furthermore, an extended HT-ABox A is additionally allowed to contain assertions of the form R(s, s) and s.i \u2248 s. Lemma 1. Let R be a set of HT-rules and let A be an ABox. Then, each ABox labeling a node of a derivation for R and A is an HT-ABox. Proof. The proof is a straightforward modification of the proof of Lemma 4 by Motik et al. (2009), which are due the following observations: since HT-rules do not allow for atoms of the form R(x, x) in the head, one cannot derive atoms of the form R(s, s); this, in turn, guarantees that one cannot derive equalities of the form s.i \u2248 s.\nLemma 2. (Motik et al., 2009, Lemma 6) Let R be a set of HT-rules and let A be a clashfree extended HT-ABox not containing indirectly blocked individuals. If no derivation rule is applicable to R and A, then R \u222aA is satisfiable. Definition 13. The weakened pairwise anywhere blocking, abbreviated w-blocking, is the same as in Definition 1, with the difference that the following condition is used instead of LA(s) = LA(t):\nFor each HT-rule  \u2208 R containing a body atom of the form R(x, y) or R(y, x) with R an atomic role such that R \u2208 LA(s, s) \u222a LA(s, s), and for each atomic concept A occurring in , we have A \u2208 LA(s) if and only if A \u2208 LA(t).\nLemma 3. Lemma 2 holds even if the derivation for R and A uses w-blocking. Proof (Sketch). Let A be an ABox labeling a leaf of a derivation for R and A; let s be an individual that is blocked in A by t by w-blocking; and let s and t be the parents of s and t. For the proof by Motik et al. (2009, Lemma 6) to hold, we must show that no HT-rule is applicable to an interpretation obtained by unraveling A. Let  \u2208 R be an arbitrary HT-rule. If  does not contain in the body a role atom with a role R \u2208 LA(s, s) \u222a LA(s, s), then the Hyp-rule cannot be applied to  with mapping \u03c3(x) = s. Furthermore, if  does not contain an atomic concept A, then the fact that A \u2208 LA(s) but A \u2208 LA(t) or vice versa cannot affect the applicability of . Thus, by a straightforward modification of the proof by Motik et al. (2009, Lemma 6), we can construct a model for A and R by unraveling A.\nIt is straightforward to see that the derivation rules in Table 4 do not invalidate Lemma 1\u2014that is, given an HT-ABox, they always produce an HT-ABox.\nA.1 Termination\nWe first show that the logical consequences of the datalog program D(Rv,Av) from Definition 7 \u201coverestimate\u201d the ABoxes produced by the hypertableau algorithm; that is, we show that each ABox \u03c1(t) labeling a derivation node can be homomorphically embedded into the set of ground facts entailed by D(Rv,Av).\nIf s = s.i and either R(s, s) \u2208 \u03c1(t) or R(s, s) \u2208 \u03c1(t) with R \u2208 \u0393, we say that s is a \u0393-successor of s.\nLemma 4. Let Rv be a set of HT-rules, let Av be an ABox, let \u0393 be a signature, let D(Rv,Av) be as given in Definition 7, let Th be an ALCHIQ TBox, and let (T, \u03c1) be a derivation for \u0393,Rv \u222aAv, Th. Then, for each derivation node t \u2208 T , a mapping \u00b5 from the individuals in \u03c1(t) to the individuals in D(Rv,Av) exists satisfying all of the following properties for all individuals s and s occurring in \u03c1(t):\n1. A(s) \u2208 \u03c1(t) with A an atomic concept implies D(Rv,Av) |= A(\u00b5(s)).\n2. R(s, s) \u2208 \u03c1(t) implies D(Rv,Av) |= R(\u00b5(s), \u00b5(s)).\n3. If s is a successor of s in \u03c1(t), then D(Rv,Av) |= Succ(\u00b5(s), \u00b5(s)).\n4. If s is a \u0393-successor of s in \u03c1(t), then D(Rv,Av) |= \u0393-Desc(\u00b5(s), \u00b5(s)).\n5. If \u2265n R.C(s) \u2208 \u03c1(t) with R a possibly inverse role, then the following conditions hold:\n(a) if C is an atomic concept, then D(Rv,Av) |= C(vC); (b) D(Rv,Av) |= ar(R,\u00b5(s), vC); (c) D(Rv,Av) |= Succ(\u00b5(s), vC); and (d) if R \u2208 \u0393, then D(Rv,Av) |= \u0393-Desc(\u00b5(s), vC).\n6. If s \u2248 s \u2208 \u03c1(t), then D(Rv,Av) |= \u00b5(s) \u2248 \u00b5(s).\n7. If s is an unnamed individual in \u03c1(t), an atomic concept A \u2208 sig(Rv) \u222a sig(Av) exists such that \u00b5(s) = vA or \u00b5(s) = v\u00acA.\nProof. We prove the lemma by induction on the structure of the derivation. For  \u2208 T the root node of the derivation, let \u00b5 map each individual in Av to itself. ABox \u03c1() = Av trivially satisfies Properties 3, 4, and 7 since Av contains only named individuals. Properties 5 and 6 also hold trivially because \u03c1() is a normalized ABox and hence it does not contain assertions of the form \u2265n R.C(s) or of the form s \u2248 s. Finally, Properties 1 and 2 hold because \u03c1() \u2286 D(Rv,Av).\nFor the induction step, assume that, for some derivation node t \u2208 T , ABox \u03c1(t) satisfies the claim for some mapping \u00b5. For each child node t of t in T , we consider the possible ways \u03c1(t) can be derived from \u03c1(t).\n\u2022 \u2126a-rule: All properties hold trivially for \u03c1(t) and \u00b5.\n\u2022 A-cut: All properties hold trivially for \u03c1(t) and \u00b5 except for Property 1 in case \u03c1(t) = \u03c1(t) \u222a {A(s)} with A \u2208 \u0393. If s is a named individual in \u03c1(t), then s occurs in Av and Property 1 holds because D(Rv,Av) contains the assertion A(s) for each A \u2208 \u0393 and each s occurring in Av. If s is unnamed, then s is the successor of some individual s in \u03c1(t); by the induction hypothesis (Property 3) we have D(Rv,Av) |= Succ(\u00b5(s), \u00b5(s)); however, D(Rv,Av) contains the formula (32) for each A \u2208 \u0393, so we have D(Rv,Av) |= A(\u00b5(s)), as required.\n\u2022 R-cut: All properties hold trivially for \u03c1(t) and \u00b5 except for Property 2 in case \u03c1(t) = \u03c1(t) \u222a {R(s, s)} with R \u2208 \u0393. By Condition 2 of R-cut we have R(s, s) \u2208 \u03c1(t) for some atomic role R \u2208 \u0393, so we have D(Rv,Av) |= R(\u00b5(s), \u00b5(s)) by the induction assumption. Since R,R \u2208 \u0393 and D(Rv,Av) contains formulae (33) for all roles in \u0393, we have D(Rv,Av) |= R(\u00b5(s), \u00b5(s)), so \u03c1(t) satisfies Property 2 for \u00b5.\n\u2022 R\u2212-cut: All properties hold trivially for \u03c1(t) and \u00b5 except for Property 2 in case \u03c1(t) = \u03c1(t) \u222a {R(s, s)} with R \u2208 \u0393. By Condition 2 of R\u2212-cut we have R(s, s) \u2208 \u03c1(t) for some atomic role R \u2208 \u0393, so we have D(Rv,Av) |= R(\u00b5(s), \u00b5(s)) by the induction assumption. Since R,R \u2208 \u0393 and D(Rv,Av) contains formulae (34) for all roles in \u0393, we have D(Rv,Av) |= R(\u00b5(s), \u00b5(s)), so \u03c1(t) satisfies Property 2 for \u00b5.\n\u2022 \u22a5-rule: All properties hold trivially for \u03c1(t) and \u00b5.\n\u2022 \u2265-rule: Assume that \u03c1(t) is defined as follows, where \u2265n R.C(s) \u2208 \u03c1(t), si are fresh successors of s, and C is a possibly negated atomic concept:\n\u03c1(t) = \u03c1(t) \u222a { ar(R, s, si), C(si) | 1 \u2264 i \u2264 n } \u222a { si \u2248 sj | 1 \u2264 i < j \u2264 n }\nLet \u00b5 = \u00b5 \u222a {si \u2192 vC | 1 \u2264 i \u2264 n}. Properties 5 and 6 hold trivially for \u03c1(t) and \u00b5, and it is obvious that Property 7 holds as well. Hence, we focus on showing Properties 1\u20144. For Property 1, assume that C is an atomic concept; since Property 5(a) holds for \u03c1(t) and \u00b5 by the induction assumption, we have D(Rv,Av) |= C(vC), as required. For Property 2, since Property 5(b) holds for \u03c1(t) and \u00b5 by the induction assumption, we have D(Rv,Av) |= ar(R,\u00b5(s), vC), as required. For Property 3, since Property 5(c) holds for \u03c1(t) and \u00b5 by the induction assumption, we have D(Rv,Av) |= Succ(\u00b5(s), vC), so Property 3 holds for \u03c1(t) and \u00b5. For Property 4, assume that R \u2208 \u0393; Property 5(d) holds for \u03c1(t) and \u00b5 by the induction assumption, we have D(Rv,Av) |= \u0393-Desc(\u00b5(s), vC), so Property 4 holds for \u03c1(t) and \u00b5.\n\u2022 Hyp-rule: Assume that \u03c1(t) = \u03c1(t) \u222a {\u03b1} for \u03b1 the head atom of an HT-rule  of the form (2). Properties 3, 4, and 7 hold trivially for \u03c1(t) and \u00b5, so we focus on the remaining properties. By Condition 2 of the Hyp-rule, \u03c1(t) contains individuals s, s1, . . . , sn such that the statements from the left column from the following table holds. But then, by the induction assumption, the statements from the right column hold as well.\nAi(s) \u2208 \u03c1(t) \u21d2 D(Rv,Av) |= Ai(\u00b5(s)) Rij(s, si) \u2208 \u03c1(t) \u21d2 D(Rv,Av) |= Rij(\u00b5(s), \u00b5(si)) Sij(si, s) \u2208 \u03c1(t) \u21d2 D(Rv,Av) |= Sij(\u00b5(si), \u00b5(s))\nBij(si) \u2208 \u03c1(t) \u21d2 D(Rv,Av) |= Bij(\u00b5(si))\nFor the HT-rule , the datalog program contains the rule (31). Thus, the statements from the following table then hold as well:\nD(Rv,Av) |= tt(Ci(\u00b5(s))) D(Rv,Av) |= Rij(\u00b5(s), \u00b5(si)) D(Rv,Av) |= Sij(\u00b5(si), \u00b5(s)) D(Rv,Av) |= Dij(\u00b5(si)) D(Rv,Av) |= \u00b5(si) \u2248 \u00b5(sj)\nConsequently, Properties 2 and 6 clearly hold; Property 1 also holds since for an atomic concept atom \u03b1 we have tt(\u03b1) = \u03b1. To show Property 5, assume that Ci(\u00b5(s)) is of the form \u2265n R.C(\u00b5(s)), so\ntt(Ci(\u00b5(s))) = ar(R,\u00b5(s), vC) \u2227 tt(C(vC)) \u2227 Succ(\u00b5(s), vC).\nThen, the following holds:\nD(Rv,Av) |= ar(R,\u00b5(s), vC) D(Rv,Av) |= tt(C(vC)) D(Rv,Av) |= Succ(\u00b5(s), vC)\nThus, Properties (5a), (5b), and (5c) hold. Finally, if R \u2208 \u0393, then Property (5d) holds because the datalog program entails assertion Succ(\u00b5(s), vC), and it contains formulae (38) and (34) for all roles in \u0393.\n\u2022 \u2248-cut rule: Assume that \u03c1(t) = \u03c1(t) \u222a {\u03b1} with \u03b1 an assertion of the form s1 \u2248 s2 or s1 \u2248 s2. Then, \u03c1(t) trivially satisfies Properties 1\u20135 and 7 for \u00b5. Property 6 also holds trivially if \u03b1 is of the form s1 \u2248 s2, so assume that \u03b1 of the form s1 \u2248 s2. By the preconditions of the \u2248-cut rule, an individual s in \u03c1(t) and atomic roles R,R \u2208 \u0393 exist such that\n{ R(s, s1), R(s, s2) } \u2286 \u03c1(t) or { R(s1, s), R(s2, s) } \u2286 \u03c1(t) or { R(s1, s), R(s, s2) } \u2286 \u03c1(t).\nBy the induction hypothesis (Property 2), then\nD(Rv,Av) |= { R(\u00b5(s), \u00b5(s1)), R(\u00b5(s), \u00b5(s2)) } or D(Rv,Av) |= { R(\u00b5(s1), \u00b5(s)), R(\u00b5(s2), \u00b5(s)) } or D(Rv,Av) |= { R(\u00b5(s1), \u00b5(s)), R(\u00b5(s), \u00b5(s2)) }.\nBut then, since the datalog program contains formulas (35)\u2013(37) for all roles in \u0393, we have D(Rv,Av) |= \u00b5(s1) \u2248 \u00b5(s2), as required.\n\u2022 \u2248-rule: Assume that \u03c1(t) = merge\u03c1(t)(s \u2192 s). Then, by Conditions 1 and 2 of the \u2248-rule, s \u2248 s \u2208 \u03c1(t) with s = s. Furthermore, by the induction assumption, we have D(Rv,Av) |= \u00b5(s) \u2248 \u00b5(s). Since merging merely replaces s with s, by the semantics of equality \u03c1(t) satisfies all the required properties.\nWe next use Lemma 4 to prove that the length of chains of role assertions involving a role in \u0393 is bounded.\nLemma 5. Let Rv, Av, \u0393, D(Rv,Av), and (T, \u03c1) be as in Lemma 4 with the additional restriction that Rv \u222aAv is acyclic w.r.t. \u0393. Let N be the number of individuals of the form vC occurring in D(Rv,Av), let t \u2208 T be an arbitrary derivation node of (T, \u03c1), and let s1, . . . , s be unnamed individuals occurring in \u03c1(t) such that si+1 is a \u0393-successor of si for each 1 \u2264 i < . Then,  \u2264 N .\nProof. Assume that, for some integer  > N , unnamed individuals s1, . . . , s satisfying the conditions of this lemma exist, and let \u00b5 be a mapping satisfying Lemma 4. By Property 7 in Lemma 4, for each 1 \u2264 i \u2264  we have \u00b5(si) = vCi for some Ci (because each si is unnamed). Furthermore, by Property 4 in Lemma 4, we also have D(Rv,Av) |= \u0393-Desc(\u00b5(si), \u00b5(si+1)) for each 1 \u2264 i < . But then, since  > N and predicate \u0393-Desc(x, y) is axiomatized as transitive by formula (39) in D(Rv,Av), we clearly obtain a harmful cycle, which is a contradiction.\nWe are now ready to prove our main claim.\nLemma 6 (Termination). Let Rv, Av, \u0393, D(Rv,Av), N , and (T, \u03c1) be as in Lemma 5. Then, (T, \u03c1) is finite.\nProof. Let the depth of an individual s be the number of its ancestors, and let c and r be the numbers of atomic concepts and roles, respectively, occurring in Rv and Av; finally, let \u2118 = (22cr + 1)(N + 1) + 1. Consider now an arbitrary derivation node t \u2208 T . Let s be an individual in \u03c1(t) of depth i(N + 1) + 1. By a simple induction on i, one can show that s has at least i ancestors that are blocking-relevant. The induction base is straightforward for i = 0; furthermore, the induction step holds because, by Lemma 5 and the fact that \u03c1(t) is an HT-ABox, the depth of the nearest blocking-relevant ancestor of s can be at most N + 1 less than the depth of s. Thus, each individual s of depth \u2118 has at least 22cr + 1 blocking-relevant ancestors; since there are at most 22cr possible concept and role labelings for an individual and its predecessor, one of the blocking ancestors of s is blocked due to the definition of blocking; hence, s is either directly or indirectly blocked in \u03c1(t). The rest of the proof of our claim is then analogous to the proof of Lemma 7 by Motik et al. (2009).\nA.2 Soundness\nLemma 7 (Soundness). Let Rv be a set of HT-rules, let Th be an ALCHIQ TBox, let A be an ABox such that Rv \u222a Th \u222aA is satisfiable, and let A1, . . . ,An be the ABoxes obtained by applying a derivation rule from Table 2 or 4 to Rv and A. Then, Rv \u222a Th \u222aAi is satisfiable for some 1 \u2264 i \u2264 n.\nProof. Let I be a model of Rv \u222a Th \u222aA, and let us consider the possible derivation rules that derive A1, . . . ,An. The cases for the Hyp-, \u2265-, \u2248-, and \u22a5-rule are the same as in the proof by Motik et al. (2009, Lemma 5). Furthermore, by the law of excluded middle of first-order logic, the claim is true for A, R-cut, R\u2212-cut and \u2248-cut rules. Assume that the \u2126a-rule derives \u22a5\u2014that is, that Th \u222aA is unsatisfiable for some connected component A of A|\u0393. But then, since A \u2286 A|\u0393 \u2286 A, by the monotonicity of first-order logic Rv \u222a Th \u222aA is unsatisfiable as well, which is a contradiction.\nA.3 Completeness\nDefinition 14 and Proposition 5 show that the part of a model that is implied by Th can always be extended to a model of Rv. We say that an assertion is atomic if it is of the form A(a) with A an atomic concept, or R(a, b) with R an atomic role.\nDefinition 14. Let \u0393 be a signature, let Rv be a set of HT-rules, and let A be a nonempty clash-free ABox containing exactly one individual such that sig(A) \u2286 \u0393. An ABox A is an Rv-extension of A w.r.t. \u0393 if the following conditions hold:\n1. A contains exactly one individual, A|\u0393 = A, and sig(A) \u2286 sig(Rv);\n2. no derivation rule from Table 2 is applicable to A and Rv; and\n3. A does not contain an assertion of the form A(s) with A \u2208 safe(Rv,\u0393).\nProposition 5. For each \u0393, Rv, and A as in Definition 14 where Rv is additionally HTsafe, at least one Rv-extension A of A w.r.t. \u0393 exists.\nProof. Let s be the individual occurring in A, and let I = (I , \u00b7I) be the interpretation for the symbols in \u0393 defined as follows:\nI = {s} AI =  {s} if A(s) \u2208 A \u2205 otherwise R I =  {s, s} if R(s, s) \u2208 A \u2205 otherwise\nSince Rv is HT-safe w.r.t. \u0393 and sig(A) \u2286 \u0393, by Proposition 3 a model J of Rv exists such that J = I , XJ = XI for each symbol X \u2208 \u0393, and XJ = \u2205 for each X \u2208 safe(Rv,\u0393). We define the ABox A as follows:\nA = {s \u2248 s} \u222a {A(s) | s \u2208 AJ and A \u2208 sig(Rv)} \u222a {\u00acA(s) | s \u2208 AJ and A \u2208 sig(Rv)} \u222a {R(s, s) | s, s \u2208 RJ and R \u2208 sig(Rv)} \u222a {\u2265 1 R.A(s) | s \u2208 (\u2265 1 R.A)J and {R,A} \u2286 sig(Rv)} \u222a {\u2265 1 R.\u00acA(s) | s \u2208 (\u2265 1 R.\u00acA)J and {R,A} \u2286 sig(Rv)}\nWe now show that A is an Rv-extension of A w.r.t. \u0393. Since J coincides with I on the interpretation of all atomic concepts and roles in \u0393, A satisfies Properties 1 and 3 of Definition 14. We next show that no hypertableau derivation rule is applicable to A and Rv. The \u2248- and the \u22a5-rule are clearly not applicable to A. Furthermore, the construction of A ensures that \u2265 1 R.C(s) \u2208 A if and only if {R(s, s), C(s)} \u2286 A, so the \u2265-rule is not applicable to A either. Finally, assume that the Hyp-rule is applicable to an HT-rule \u03c1 \u2208 Rv and A with a mapping \u03c3. Since A contains only the individual s, the mapping \u03c3 maps all variables in \u03c1 to s. Since J |= Rv, rule  contains a head atom Vj such that J |= \u03c3(Vj). Note that if Vj is of the form \u2265n R.C, then n = 1 since J contains just one element. Thus, \u03c3(Vj) can be of the form A(s), R(s, s), \u2265 1 R.C(s), or s \u2248 s, where A \u2208 sig(Rv), R \u2208 sig(Rv), and sig(C) \u2286 sig(Rv). But then, by the construction of A we have \u03c3(Vj) \u2208 A, which contradicts the assumption that the Hyp-rule is applicable to Rv and A.\nWe are now ready to prove the main claim of the section.\nLemma 8 (Completeness). Let \u0393,Rv \u222aAv, Th be an input of the ALCHIQ \u2126a-algorithm. If a derivation for \u0393,Rv \u222aAv, Th contains a leaf node labeled with a clash-free ABox, then Rv \u222aAv \u222a Th is satisfiable.\nProof. Let A be an ABox obtained from a clash-free ABox labeling a leaf of a derivation for \u0393,Rv \u222aAv, Th by removing all assertions involving an indirectly blocked individual. Since Rv \u222aAv is acyclic w.r.t. \u0393, ABox A is finite by Lemma 6. Furthermore, A is clearly an HTABox and no derivation rule is applicable to Rv, A, and \u2126aTh,\u0393. Finally, it is straightforward to see that a mapping h from the individuals in Av to the individuals in A exists such that h(a) = a for each individual a occurring in A, C(a) \u2208 Av implies C(h(a)) \u2208 A, and R(a, b) \u2208 Av implies R(h(a), h(b)) \u2208 A. Hence, each model of Rv \u222aA \u222a Th can be extended to a model of Rv \u222aAv \u222a Th by interpreting each individual a not occurring in Av in the same way as h(a). Thus, we prove this lemma by showing that Rv \u222aA \u222a Th is satisfiable.\nLet Rh be the result of transforming Th into a set of HT-rules as described by Motik et al. (2009); then, Rv \u222aAv \u222a Th is equisatisfiable with Rv \u222aAv \u222aRh, and each model of the latter is a model of the former as well. Therefore, in the rest of the proof we extend A to a clash-free extended HT-ABox Afin such that no derivation rule from Table 2 is applicable to Rv \u222aRh and Afin. By Lemma 3, Rv \u222aAfin \u222aRh is satisfiable, which, together with A \u2286 Afin, implies the satisfiability of Rv \u222aA \u222aRh. Before proceeding with the construction of Afin, we next introduce several useful definitions and notational conventions.\n\u2022 Let \u0393v = sig(Rv) \u222a sig(Av) and let \u0393h = sig(Rh).\n\u2022 In this proof, term \u201cblocking\u201d refers to the version of blocking given in Definition 8; term \u201cw-blocking\u201d refers to the version of blocking in Definition 13; and term \u201csblocking\u201d refers to the standard blocking given in Definition 1 with the additional requirement that individuals s, s, t, and t are all unnamed.\n\u2022 For each blocked individual s, we pick an arbitrary but fixed individual s that blocks s, which we call the blocker of s.\n\u2022 The modified hypertableau algorithm is the same as the standard hypertableau algorithm from Definition 1 with the difference that it uses s-blocking and that it can be applied to ABoxes that contain unnamed individuals; such individuals are then treated by the algorithm as if they were named. The modified hypertableau algorithm is clearly sound, complete, and terminating.\n\u2022 The projection of an ABox A to a set of individuals S is the ABox consisting of exactly those assertions from A that contain only individuals in S.\nWe now proceed with the construction of Afin. To this end, we split A|\u0393 into ABoxes Anm and At as follows; we use these ABoxes later to construct Afin.\n\u2013 The ABox Anm is the projection of A|\u0393 to the set containing all named individuals in A and all unnamed individuals that are connected to a named individual in A|\u0393.\n\u2013 For each nonblocked blocking-relevant individual t in A, the ABox At is the projection of A|\u0393 to the set containing t and all (unnamed) individuals connected to t in A|\u0393.\nLet Anmder be the result of taking any clash-free ABox labeling a leaf of a derivation for Rh \u222aAnm by the modified hypertableau algorithm and then removing all assertions containing an indirectly blocked individual; furthermore, for each nonblocked blockingrelevant individual t in A, let Atder be obtained from At in an analogous way. ABoxes Anmder andAtder exist because \u2126aTh,\u0393(A ) = t for each connected componentA ofAnm, \u2126aTh,\u0393(A t) = t for each t, and the modified hypertableau algorithm is sound, complete, and terminating. Since the supply of unnamed individuals is unlimited, we assume without loss of generality that the \u2265-rule always introduces individuals that are \u201cglobally fresh\u201d\u2014that is, that do not occur in any other ABox.\nWe next extend Anmder and each Atder with assertions necessary to satisfy Rv. Let A be Anm (resp. some At) and let Ader be Anmder (resp. the corresponding Atder). We say that an individual u is fresh in Ader if u occurs in Ader but not in A. For each fresh individual u in Ader, we define Ader[u] as an Rv-extension of the projection of Ader|\u0393 to {u}; without loss of generality, we assume that Ader[u1] = Ader[u2] for all u1 and u2 for which the projections of Ader|\u0393 to {u1} and {u2} are isomorphic (i.e., identical up to the renaming of individuals). Finally, let A\ufffffin be the union of Ader and Ader[u] for each u that is fresh in Ader; thus, we obtain ABoxes Anmfin and Atfin. By Condition 1 of Definition 14, the atomic assertions of Ader|sig(Rh) coincide with the atomic assertions of A|sig(Rh). Furthermore, since all individuals involved in s-blocking are required to be unnamed and all isomorphic individuals are extended in the same way, this construction does not affect s-blocking\u2014that is, u is s-blocked in A if and only if u is s-blocked in Ader.\nWe now define Afin as the ABox obtained by\n1. taking the union of A, Anmfin , and Atfin for each nonblocked blocking-relevant individual t in A, and\n2. adding A(s) for each blocked individual s in A with blocker s such that A(s) \u2208 As\ufffffin and A \u2208 \u0393h.3\nBy Lemma 1, Anmfin and all Atfin are HT-ABoxes, and Afin is clearly an extended HT-ABox. We next show that no hypertableau derivation rule is applicable to Rv \u222aRh and Afin.\nTo this end, we first show that Afin satisfies the following property (*): if \u03b1 \u2208 Afin is an atomic assertion or an assertion of the form a \u2248 b such that sig(\u03b1) \u2286 \u0393v and all individuals mentioned in \u03b1 occur in A, then \u03b1 \u2208 A. In particular, note that the extension of Anmder and Atder to Anmfin and Atfin, respectively, does not introduce an atomic assertion \u03b1 that involves an individual from A and for which sig(\u03b1) \u2229 (\u0393v \\ \u0393) = \u2205; hence, the only possibility for \u03b1 \u2208 Afin, \u03b1 \u2208 A, and sig(\u03b1) \u2286 \u0393v is if \u03b1 \u2208 Anmder or \u03b1 \u2208 Atder for some t. We consider next the former case; the latter one is analogous. We prove (*) by induction on the application of the derivation rules in the construction of Anmder. To this end, we show that each ABox A in a derivation for Anm and Rh satisfies the following properties: 3. Note that, since s is blocked, it is blocking-relevant.\n1. If \u03b1 \u2208 A is an atomic assertion or an assertion of the form a \u2248 b such that sig(\u03b1) \u2286 \u0393v and all individuals mentioned in \u03b1 occur in A, then \u03b1 \u2208 A or \u00ac\u03b1 \u2208 A.\n2. If R(a, b) \u2208 A such that a and b occur in A and R \u2208 \u0393h \\ \u0393, then S \u2208 \u0393 exists such that S(a, b) \u2208 A or S(b, a) \u2208 A.\n3. If a \u2248 b \u2208 A such that a occurs in A, then R \u2208 \u0393 and an individual c occurring in A exist such that R(a, c) \u2208 A or R(c, a) \u2208 A.\nThe base case is trivial. We next consider ways in which an assertion in A can be derived. An application of the \u22a5-rule or the \u2265-rule clearly preserves (1)\u2013(3). In an application of the \u2248-rule, the modified hypertableau algorithm treats the individuals in A as named; furthermore, if a \u2248 b \u2208 A and a and b occur in A, by (1) we have a \u2248 b \u2208 A, so a = b since the \u2248-rule is not applicable to A; but then, it is straightforward to see that (1)\u2013(3) remain preserved. Finally, the following types of assertions are relevant in an application of the Hyp-rule to an HT-rule  \u2208 Rh:\n\u2022 A(a) with a in A and A \u2208 \u0393. Since the A-cut rule is not applicable to A, we have A(a) \u2208 A or \u00acA(a) \u2208 A, so (1) holds.\n\u2022 R(a, b) with a and b in A. The body of  then contains an atom that is matched to an assertion R(a, b) \u2208 A or R(b, a) \u2208 A with R \u2208 \u0393v that satisfies the induction assumption; thus, S \u2208 \u0393 exists such that S(a, b) \u2208 A or S(b, a) \u2208 A, so (2) holds. Furthermore, if R \u2208 \u0393, then this assertion satisfies the preconditions of the R-cut and the R\u2212-cut rule; since these rules are not applicable to A, we have R(a, b) \u2208 A or \u00acR(a, b) \u2208 A, so (1) holds.\n\u2022 a \u2248 b with a inA. The body of  then contains an atom that is matched to an assertion R(a, c) \u2208 A or R(c, a) \u2208 A with R \u2208 \u0393v that satisfies the induction assumption; thus, S \u2208 \u0393 exists such that S(a, c) \u2208 A or S(c, a) \u2208 A, so (3) holds. Furthermore, if b is in A, then the body of  also contains an atom that is matched to an assertion R(a, c) \u2208 A or R(c, a) \u2208 A that satisfies the induction assumption; thus, S \u2208 \u0393 exists such that S(a, c) \u2208 A or S(c, a) \u2208 A. The precondition of the \u2248-cut rule is then satisfied and, since the rule is not applicable to A, we have a \u2248 b \u2208 A or a \u2248 b \u2208 A, so (1) holds.\nThis completes the proof of (1)\u2013(3). Property (*) is a straightforward consequence of (1): a derivation of an assertion \u03b1 such that sig(\u03b1) \u2286 \u0393v and all individuals mentioned in \u03b1 occur in A either makes no difference or it leads to a contradiction. A straightforward consequence of (*) is that (59) and (60) hold for all individuals u and v that occur in A:\nLAfin(u) \u2229 \u0393v =LA(u) (59) LAfin(u, v) \u2229 \u0393v =LA(u, v) (60)\nWe now show that no derivation rule of the hypertableau algorithm with w-blocking is applicable to Rv \u222aRh and Afin. We do so by considering the possible derivation rules.\n(\u2265-rule) Assume that the \u2265-rule is applicable to an assertion \u2265n R.C(s) \u2208 Afin, so s is not w-blocked in Afin. We show that then s is not blocked in A, or s is not s-blocked in Anmfin , or s is not s-blocked in some Atfin. We have the following cases.\n\u2022 \u2265n R.C(s) \u2208 A. Assume that s is blocked in A with blocker t, and let s and t be the predecessors of s and t, respectively. By the definition of blocking, (61)\u2013(65) hold:\nLA(s) =LA(t) (61) LA(s) =LA(t) (62) LA(s, s) =LA(t, t) (63) LA(s, s) =LA(t, t) (64)\nLA(s, s) \u222a LA(s, s) \u2286\u0393v \\ \u0393 (65)\nBy (59) and (60), the following properties hold as well:\nLAfin(s) \u2229 \u0393v =LAfin(t) \u2229 \u0393v (66) LAfin(s\uffff) \u2229 \u0393v =LAfin(t\uffff) \u2229 \u0393v (67)\nFurthermore, the second item in the construction of Afin ensures that LAfin(s) and LAfin(t) coincide on each concept C \u2208 \u0393h, which ensures the following property:\nLAfin(s) = LAfin(t) (68)\nBy (65), A|\u0393 does not contains an assertion involving individuals s and s, or individuals t and t. By the construction of Afin, the following properties hold:\nLAfin(s, s) =LAfin(t, t) (69) LAfin(s\uffff, s) =LAfin(t\uffff, t) (70)\nConsider now each rule  \u2208 Rv \u222aRh. If  \u2208 Rh, then no role in the body of  occurs in LAfin(s, s) \u222a LAfin(s\uffff, s), so  satisfies the condition of weakened pairwise anywhere blocking. If  \u2208 Rv, then  satisfies the condition of weakened pairwise anywhere blocking due to (67). Together with (68)\u2013(70), this implies that s is w-blocked by t, which is a contradiction. Consequently, s is not blocked in A.\n\u2022 \u2265n R.C(s) \u2208 Anmfin and \u2265n R.C(s) \u2208 A. If s occurs in A or if s is a successor of an individual that occurs in A, then s is not s-blocked in Anmfin since the modified hypertableau algorithm treats the individuals occurring in A as named and such individuals cannot be s-blocked. Otherwise, by the construction of Afin, LAfin(u) = LAnmfin (u) and LAfin(u, v) = LAnmfin (u, v) for all individuals u and v occurring in A nm fin but not in A;\nagain, s is not s-blocked in Anmfin .\n\u2022 \u2265n R.C(s) \u2208 Atfin for some t and \u2265n R.C(s) \u2208 A. This case is completely analogous to the previous one.\nLet A be the ABox for which the above property holds; note that \u2265n R.C(s) \u2208 A. The \u2265-rule is not applicable to s in A, so A contains individuals u1, . . . , un such that\n{ar(R, s, ui), C(ui) | 1 \u2264 i \u2264 n} \u222a {ui \u2248 uj | 1 \u2264 i < j \u2264 n} \u2286 A.\nBy the construction of Afin we have A \u2286 Afin, which then contradicts the assumption that the \u2265-rule is applicable to s and Afin.\n(\u22a5-rule, first variant) Property (59) holds for each individual s occurring in A, and (71) and (72) hold for each individual s occurring in Anmfin and Atfin, respectively.\nLAfin(s) \u2229 \u0393h =LAnmfin (s) \u2229 \u0393h (71) LAfin(s) \u2229 \u0393h =LAtfin(s) \u2229 \u0393h (72)\nThus, {A(s),\u00acA(s)} \u2286 Afin implies {A(s),\u00acA(s)} \u2286 A, where A can be A, or Anmfin , or some Atfin. Since the first variant of the \u22a5-rule is not applicable to A, it is not applicable to Afin either.\n(\u22a5-rule, second variant) Property (60) holds for each pair of individuals s and t occurring inA. Furthermore, Anmfin andAtfin do not contain negative assertions other than those already present in A. Since the second variant of the \u22a5-rule is not applicable to A, Anmfin , and all Atfin, it is not applicable to Afin either.\n(\u22a5-rule, third variant) Suppose that the \u22a5-rule is applicable to an assertion of the form s \u2248 s \u2208 Afin. By the construction of Afin, then s \u2248 s \u2208 A for A being A, Anmfin , or Atfin for some t. But then, since the \u22a5-rule is not applicable to A, it is not applicable to Afin either.\n(\u2248-rule) Assume now that the \u2248-rule is applicable to Afin. Then, an assertion s \u2248 s in Afin exists with s = s. By the construction of Afin, we have that s \u2248 s \u2208 A, with A = A, or A = Anmfin , or A = Atfin for some t. But then, since the \u2248-rule is not applicable to A, it is not applicable to Afin either.\n(Hyp-rule) Assume that the Hyp-rule is applicable to Afin and an HT-rule  \u2208 Rv \u222aRh of the form (2). Thus, a mapping \u03c3 from the variables in  to the individuals Afin exists such that \u03c3(Ui) \u2208 Afin for each 1 \u2264 i \u2264 m, but \u03c3(Vj) \u2208 Afin for each 1 \u2264 j \u2264 n. Let s = \u03c3(x) and ui = \u03c3(yi). We have the following possibilities:\n\u2022  \u2208 Rh. Let A be the ABox chosen among Anmfin and Atfin containing the individual s. Consider now each ui. Then  contains an atom of the form Rij(x, yi) or Rij(yi, x) with Rij \u2208 \u0393h, so Afin contains an assertion of the form Rij(s, ui) or Rij(ui, s). By the definition of blocking, for each pair of individuals u and v that belong to different Anm and At, the ABox A does not contain an assertion of the form T (u, v) with T \u2208 \u0393h; but then, by the construction of Afin, if u and v belong to different Anmfin and Atfin, the ABox Afin does not contain such an assertion either. Thus, all ui occur in A, so the Hyp-rule is applicable to  and A, which is a contradiction.\n\u2022  \u2208 Rv. We first show the following property (**): if s or some ui does not occur in A, then s = uj for each uj . We consider first the case when s does not occur in A. Consider an arbitrary uj . Since  is an HT-rule, the body of  contains an atom of the form Rjk(x, yj) or Rjk(yj , x), so Afin contains an assertion of the form Rjk(s, uj) or Rjk(uj , s). We have the following two possibilities for Rjk.\n\u2013 Rjk \u2208 \u0393v\\\u0393. By the construction of Afin, assertion Rjk(s, uj) or Rjk(uj , s) with s not occurring in A must have been introduced via some Rv-extension, so uj = s.\n\u2013 Rjk \u2208 \u0393. Since  is HT-safe w.r.t. \u0393,  contains an atom of the form A(x) such that A \u2208 safe(Rv,\u0393) in the body. By Condition 3 of Definition 14, A(s) \u2208 Afin, which is a contradiction.\nThe case when some ui does not occur in A is symmetric; the only difference is that in case Rjk \u2208 \u0393 we consider a body atom B(yj) of  such that B \u2208 safe(Rv,\u0393). Let A = A if s occurs in A, and let A be the ABox that contains s otherwise. A straightforward consequence of (**) is that \u03c3(Ui) \u2208 A for each 1 \u2264 i \u2264 m; furthermore, A \u2286 Afin and \u03c3(Vj) \u2208 Afin imply \u03c3(Vj) \u2208 A for each 1 \u2264 j \u2264 n. But then, the Hyp-rule is applicable to A for  and \u03c3, which is a contradiction.\nThus, no derivation rule of the hypertableau algorithm with w-blocking is applicable to Rv \u222aRh and Afin, so Rv \u222aRh \u222aAfin is satisfiable by Lemma 3. As explained earlier, this then proves the claim of this lemma.\nLemmas 6, 7, and 8 immediately imply Theorem 11."}, {"heading": "Appendix B. Proof of Theorem 12", "text": "The termination argument for the Horn-ALCHIQ \u2126e-algorithm is analogous to the nonHorn case: for each derivation for \u0393,Rv \u222aAv, Th, and each node t in the derivation, we can find an embedding \u00b5 as in Lemma 4; the proof is a straightforward variant of the proof given for the non-Horn case. Termination then follows exactly as in the non-Horn case. Soundness is a consequence of the soundness of the standard hypertableau algorithm together with the following lemma.\nLemma 9. Let Rv be a set of HT-rules, let Th be a Horn-ALCHIQ TBox, and let A an ABox such that Rv \u222a Th \u222aA is satisfiable. Furthermore, let A1 be the ABox obtained by applying a derivation rule from Table 5 to Rv and A. Then, Rv \u222a Th \u222aA1 is satisfiable.\nProof. Let I be a model of Rv \u222a Th \u222aA, and let us assume that a derivation rule from Table 5 derives A1 = A \u222a {\u03b1}. By the preconditions of the \u2126e-concept, \u2126e-role, and \u2126e-\u2248 rules, then \u2126eTh,\u0393(A\n,\u03b1) = t for some connected component A of A|\u0393, so Th \u222aA |= \u03b1. Since A \u2286 A|\u0393 \u2286 A, we have that I |= Th \u222aA, so I |= \u03b1, which implies our claim.\nWe now show completeness of the algorithm. If a set of HT-rules R is Horn, then each derivation of the hypertableau algorithm contains exactly one leaf node, so we can identify a derivation with a sequence of ABoxes A0, . . . ,An. The following proposition is a straightforward consequence of the fact that R is a Horn set of HT-rules.\nProposition 6. Let R be a set of Horn HT-rules, let A an ABox, and let A0, . . . ,An be a derivation for R and A. Then, for each assertion \u03b1 that mentions only the individuals from A such that \u03b1 \u2208 Ai for some 1 \u2264 i \u2264 n, we have R \u222aA |= \u03b1.\nLemma 10 (Completeness). Let \u0393,Rv \u222aAv, Th be an input of the Horn-ALCHIQ \u2126ealgorithm. If a derivation for \u0393,Rv \u222aAv, Th contains a leaf node labeled with a clash-free ABox, then Rv \u222aAv \u222a Th is satisfiable.\nProof. The proof is analogous to the proof of Lemma 8: given an ABox A labeling a derivation leaf, we construct an ABox Afin such that no derivation rule of the hypertableau algorithm with w-blocking is applicable to Rv \u222aRh and Afin. The construction and the\nbulk of the proof are exactly the same as in Lemma 8, and we next prove only properties that are affected by the difference in the derivation rules.\nThe preconditions of the derivation rules in Table 5 clearly ensure that, whenever a derivation rule is applied to an HT-ABox, the result is also an HT-ABox; consequently, Afin is an extended HT-ABox.\nWe next show that property (*) holds despite the change in the derivation rules: if \u03b1 \u2208 Afin is an atomic assertion or an assertion of the form a \u2248 b such that sig(\u03b1) \u2286 \u0393v and all individuals mentioned in \u03b1 occur in A, then \u03b1 \u2208 A. In particular, note that the construction of Afin does not introduce an atomic assertion \u03b1 that involves an individual from A and for which sig(\u03b1) \u2229 (\u0393v \\ \u0393) = \u2205. Assume now that sig(\u03b1) \u2286 \u0393 and all individuals in \u03b1 occur in A. By Proposition 6 we have Rh \u222aA |= \u03b1. Furthermore, in the same say as in Lemma 8 one can show that the preconditions of the \u2126e-concept, \u2126e-role, or \u2126e-\u2248 rule are satisfied in A; since the relevant rule in not applicable to A, we have \u03b1 \u2208 A, which proves our claim.\nThe rest of the proof is exactly the same as in Lemma 8.\nTheorem 12 follows immediately from Lemmas 9 and 10."}, {"heading": "Appendix C. Proof of Theorem 13", "text": "For each set of EL-rules R and each ABox A, each derivation of the EL hypertableau algorithm contains exactly one leaf node, so we identify a derivation with a sequence of ABoxes A0,A1, . . . ,An. Since Aj\u22121 \u2286 Aj for each 1 \u2264 i \u2264 n, the ABox labeling the derivation leaf is uniquely defined by R and A. The following lemma captures the relevant properties of the standard EL hypertableau algorithm, and it can be proved by a slight variation of the proofs by Motik and Horrocks (2008) and Baader et al. (2005).\nLemma 11. Let R be a set of EL-rules, let A be an ABox containing only named individuals, and let Af be the ABox labeling a leaf of a derivation for R and A. Then the following properties hold for each pair of atomic concepts A, B \u2208 sig(R) and each individual s in A:\n1. A(s) \u2208 Af if and only if R \u222aA |= A(s).\n2. B(aA) \u2208 Af if and only if R |= A  B.\n3. For each A \u2286 A and each R \u2286 R, we have A f \u2286 Af , where Af is the ABox labeling\na leaf of a derivation for R and A.\nJust like in the EL hypertableau algorithm, each derivation of the EL \u2126e-algorithm contains exactly one leaf node, and the ABox labeling the derivation leaf is uniquely defined by \u0393,Rv \u222aAv, Th. We next show several useful properties of this algorithm.\nLemma 12. Let \u0393,Rv \u222aAv, Th be an input of the EL \u2126e-algorithm and let Ae be the ABox labeling a leaf of a derivation for \u0393,Rv \u222aAv, Th. Then the following holds.\n1. Let Rh be the set of EL-rules corresponding to Th as described by Motik et al. (2009), and let AEL be the ABox labeling a leaf of a derivation of the standard EL hypertableau algorithm for Rv \u222aRh and Av; then, Ae \u2286 AEL.\n2. If \u22a5 \u2208 Ae and B(aA) \u2208 Ae with A \u2208 \u0393, then B \u2208 safe(Rv,\u0393).\nProof. (Claim 1) Let A0, . . . ,An be a derivation of the EL \u2126e-algorithm for Rv, Av, and \u2126eTh,\u0393 such that A0 = Av and An = A\ne. We prove the claim inductively by showing that Aj \u2286 AEL for each 0 \u2264 j \u2264 n. For the induction base, we clearly have A0 \u2208 AEL. Assume now that Aj\u22121 \u2286 AEL and let Aj be obtained from Aj\u22121 by applying a derivation rule of the EL \u2126e-algorithm. If the Hyp-rule is applied to Aj\u22121 and some  \u2208 Rv, then  \u2208 Rv \u222aRh, Aj\u22121 \u2286 AEL, and the fact that Hyp-rule is not applicable to AEL and  imply Aj \u2286 AEL. The argument is analogous for the \u2203-rule. Finally, assume that the \u2126e-concept rule derives A(s) with A \u2208 \u0393 \u222a {\u22a5} from Aj\u22121. By the preconditions of the \u2126e-concept rule, then \u2126eTh,\u0393(A\n, A(s)) = t for some connected component A of Aj\u22121|\u0393. By Property 1 of Lemma 11 then A(s) \u2208 A, where A is the ABox labeling a leaf of a derivation of the standard EL hypertableau algorithm for A and Rh. Now A \u2286 AEL, Rh \u2286 Rh \u222aRv, and Property 3 of Lemma 11 imply A \u2286 AEL; consequently, A(s) \u2208 AEL and Aj \u2208 AEL.\n(Claim 2) Consider an arbitrary individual of the form aA with A \u2208 \u0393 and an arbitrary assertion B(aA) \u2208 Ae. By Claim 1, B(aA) \u2208 AEL, so by Property 2 of Lemma 11 we have Av \u222aRv \u222aRh |= A  B. Since Rv \u222aRh are EL-rules, Av does not affect subsumption inferences, so Rv \u222aRh |= A  B. Since \u22a5 \u2208 Ae, an interpretation I exists such that AI = \u2205 and I |= Rh. Assume now that B \u2208 safe(Rv,\u0393). By Proposition 3 and the fact that Rv is EL-safe, a model J of Rv exists such that XJ = XI for each X \u2208 sig(Rh), and BJ = \u2205. Thus, J |= Rv \u222aRh, which contradicts the fact that Rv \u222aRh |= A  B.\nSoundness of the EL \u2126e-algorithm follows immediately from Property 1 of Lemma 12 and the fact that the standard EL hypertableau algorithm is sound. We next prove that the algorithm is complete.\nLemma 13 (Completeness). Let \u0393,Rv \u222aAv, Th be an input of the EL \u2126e-algorithm and let Th be an EL TBox, and let Ae be the ABox labeling a leaf of a derivation for \u0393,Rv \u222aAv, Th. If \u22a5 \u2208 Ae, then Rv \u222aAv \u222a Th is satisfiable.\nProof. Let Rh be the result of transforming Th into a set of EL-rules as described by Motik et al. (2009); then, Rv \u222aAv \u222a Th is equisatisfiable with Rv \u222aAv \u222aRh, and each model of the latter is a model of the former as well. Therefore, in the rest of the proof we extend A to a clash-free ABox Afin such that no derivation rule from Table 2 is applicable to Rv \u222aRh and Afin. By Lemma 3, then Rv \u222aAfin \u222aRh is satisfiable, which, together with A \u2286 Afin, implies the satisfiability of Rv \u222aA \u222aRh. Let \u0393v = sig(Rv) \u222a sig(Av) and \u0393h = sig(Rh).\nWe next present the construction of Afin. The first step is to extend Ae such that it satisfies Rh, which we achieve by applying the EL hypertableau algorithm to Rh and Ae. We assume that the individuals in Ae of the form aA are reused whenever A \u2208 \u0393v. We call the individuals from Ae old and the freshly introduced individuals new, and we call an individual \u0393-relevant if it is of the form aA with A \u2208 \u0393.\nWe next show that each ABox Aj in a derivation for Rh and Ae satisfies the following properties (*):\n1. \u03b1 \u2208 Aj implies \u03b1 \u2208 Ae whenever \u03b1 is of the form\n(a) C(s) with sig(C) \u2286 \u0393v and s an old individual, or\n(b) R(s, t) with R \u2208 \u0393v and s and t old individuals.\n2. For each C(s) \u2208 Aj , the following properties hold:\n(a) sig(C) \u2286 \u0393v or sig(C) \u2286 \u0393h, and (b) if s is a new individual, then sig(C) \u2286 \u0393h.\n3. For each R(s, t) \u2208 Aj , the following properties hold:\n(a) if t is a new individual, then R \u2208 \u0393h, and (b) if s is new and t is old, then t is \u0393-relevant and R \u2208 \u0393h.\nThe proof of (*) is by induction on the application of the derivation rules. For the induction base, we have A0 = Ae. Statements (1) and (2a) hold trivially, and (2b) and (3) are vacuously true since Ae contains only old individuals. Assume now that (1)\u2013(3) hold for Aj\u22121 and consider an application of a derivation rule that derives Aj .\nAssume that the \u2203-rule is applied to \u2203R.A(s) \u2208 Aj\u22121, deriving R(s, aA) and A(aA). If {R,A} \u2286 \u0393v and s is old, then \u2203R.A(s) \u2208 Ae by the induction assumption; since the \u2203- rule is not applicable to Ae, then {R(s, aA), A(aA)} \u2286 Ae, so (1) holds. Furthermore, if A \u2208 \u0393v \\ \u0393, then s is old by (2b), and R \u2208 \u0393v by (2a); but then \u2203R.A(s) \u2208 Ae, so the \u2203-rule cannot be applicable to \u2203R.A(s) in Aj\u22121. Consequently, we have {R,A} \u2286 \u0393h, so A(aA) clearly satisfies (2), and R(s, aA) clearly satisfies (3a). Finally, aA can be old only if A \u2208 \u0393, so R(s, aA) clearly satisfies (3b).\nAssume that the Hyp-rule is applied to an EL-rule \u03c1 \u2208 Rh of the form (8), deriving C(s). Then, individuals t1, . . . , tm in Aj\u22121 exist such that Ai(s) \u2208 Aj\u22121 for each 1 \u2264 i \u2264 k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} \u2286 Aj\u22121 for each 1 \u2264 i \u2264 m. ABox Aj trivially satisfies (1b) and (3), and it satisfies (2) because \u03c1 \u2208 Rh, so sig(C) \u2286 \u0393h. To show (1a), assume that s is an old individual and sig(C) \u2286 \u0393v; since \u03c1 \u2208 Rh, then sig(C) \u2286 \u0393. By Property 1 of Lemma 11, then Rh \u222aAe |= C(s). Since sig(C) \u2286 \u0393, we have Rh \u222aAe|\u0393 |= C(s). Since the \u2126e-concept rule is not applicable to Ae, we have C(s) \u2208 Ae, so Aj satisfies (1a).\nThis completes the proof of (*). Let Ader be the ABox labeling a leaf of a derivation of the EL hypertableau algorithm for Rh and Ae. Such Ader is clash-free since \u22a5 /\u2208 Ae and the \u2126e-rule is not applicable to Ae; furthermore, Ader satisfies (*).\nWe now extend Ader such that the EL-rules in Rv are satisfied when they are matched to new individuals. To this end, for each new individual u in Ader, let Ader[u] be an Rvextension w.r.t. \u0393 of the projection of Ader on {u}; such Ader[u] exists by Proposition 5 and the fact that Rv is EL-safe. Let Afin be the union of Ader and all such Ader[u]. Since Av \u2286 Ae and Ae \u2286 Afin, we have Av \u2286 Afin. Furthermore, since \u22a5 \u2208 Ader and \u22a5 \u2208 Ader[u] for each u that is new in Ader, we have \u22a5 \u2208 Afin. Finally, by (*), Property 2 of Lemma 12, and the fact that each Ader[u] contains only one individual and no safe concepts, Afin satisfies the following properties (**):\n1. For each B(s) \u2208 Afin such that s is \u0393-relevant or new, we have B \u2208 safe(Rv,\u0393).\n2. For each R(s, t) \u2208 Afin, the following properties hold:\n(a) if t is a new individual and s = t, then R \u2208 \u0393h, and\n(b) if s is new and t is old, then t is \u0393-relevant and R \u2208 \u0393h.\nTo complete the proof of this lemma, we show that no derivation rule of the hypertableau algorithm is applicable to Afin and Rv \u222aRh.\n(\u2203-rule) Consider an arbitrary \u2203R.C(s) \u2208 Afin. If \u2203R.C(s) \u2208 Ader, since the \u2203-rule is not applicable to Ader, we have {R(s, t), C(t)} \u2286 Ader \u2286 Afin. If \u2203R.C(s) \u2208 Ader[u] for some individual u that is new in Ader, by Definition 14 the \u2203-rule is not applicable to Ader[u], so {R(s, t), C(t)} \u2286 Ader[u] \u2286 Afin. Either way, the \u2203-rule is not applicable to \u2203R.C(s) in Afin.\n(Hyp-rule) Assume that the Hyp-rule is applicable to an EL-rule \u03c1 \u2208 Rv \u222aRh of the form (8), deriving C(s). Then, individuals t1, . . . , tm in Afin exist such that Ai(s) \u2208 Afin for each 1 \u2264 i \u2264 k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} \u2286 Afin for each 1 \u2264 i \u2264 m. Then we have the following possibilities:\n\u2022  \u2208 Rh. For each new individual u and each assertion \u03b1 \u2208 Ader[u] \\ Ader, by Definition 14 either sig(\u03b1) \u2208 \u0393v \\ \u0393 or \u03b1 is of the form \u2203R.C. Thus, Ai(s) \u2208 Ader for each 1 \u2264 i \u2264 k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} \u2286 Ader for each 1 \u2264 i \u2264 m, so the Hyp-rule is applicable to  and Ader, which is a contradiction.\n\u2022  \u2208 Rv. We first show the following property (***): if s or some ti is new, then s = tj for each tj . We have the following cases.\n\u2013 Assume that s is new and consider an arbitrary 1 \u2264 i \u2264 m. Clearly, Ri \u2208 \u0393v; furthermore, if Ri \u2208 \u0393, since  is EL-safe, the body of  contains an atom that is matched to some Bij(ti) \u2208 Afin such that Bij \u2208 safe(Rv,\u0393). Assume now that ti = s. If ti is new, then Ri \u2208 \u0393 by Statement (2a) of (**); furthermore, if ti is old, then Ri \u2208 \u0393 and ti is \u0393-relevant by Statement (2b) of (**); consequently, Ri \u2208 \u0393 and ti is either new or \u0393-relevant. But then, by Statement (1) of (**) and Property 3 of Definition 14, then Bij(ti) \u2208 Afin, which is a contradiction. Hence, we conclude that s = ti.\n\u2013 Assume that ti is new for some 1 \u2264 i \u2264 m. If ti = s, by Statement (2a) of (**) then Ri \u2208 \u0393. Since  is EL-safe, the body of  then contains an atom that is matched to some Bij(ti) \u2208 Afin such that Bij \u2208 safe(Rv,\u0393). Statement (1) of (**) then implies Bij(ti) \u2208 Afin, which is a contradiction. Hence, we conclude that s = ti; by the previous case then s = tj for each 1 \u2264 j \u2264 m.\nLet A = Ae if s is old, and A = Ader[s] otherwise. A straightforward consequence of (***) is that Ai(s) \u2208 A for each 1 \u2264 i \u2264 k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} \u2286 A for each 1 \u2264 i \u2264 m. The Hyp-rule is not applicable to  and A, so C(s) \u2208 A. Since A \u2286 Afin, we have C(s) \u2208 Afin, which contradicts the assumption that the Hyp-rule is applicable to  and Afin.\nThis completes the proof of this lemma.\nFinally, we prove that the EL \u2126e-algorithm is an optimal import-by-query algorithm.\nTheorem 13. The EL \u2126e-algorithm is an import-by-query algorithm based on ABox entailment oracles for the class of inputs C[\u0393C ,RCv \u222aACv , T Ch ] from Definition 11. The algorithm can be implemented such that it runs in PTime in N with a polynomial number (in N) of calls to \u2126eTh,\u0393, where N = |Rv \u222aAv|+ |\u0393| for the input Rv, Av, and \u0393.\nProof. That the EL \u2126e-algorithm is an import-by-query algorithm is a straightforward consequence of Lemmas 12 and 13. To estimate the algorithm\u2019s running time, note that each application of a derivation rule adds an assertion of the form C(a) or R(a, b) for C \u2208 \u0393v \u222a {\u22a5}, where a and b are individuals occurring either in Av or are of the form aA with A \u2208 sig(Rv). Clearly, the maximal number of individuals occurring in an ABox in a derivation is polynomial in the size of Av, Rv, and \u0393, and so is the maximal number of assertions. Furthermore, no derivation rule removes assertions from an ABox, so the number of assertions in an ABox monotonically increases in the course of a derivation. Consequently, the number of rule applications is polynomial in the size of Av, Rv, and \u0393. In the same way as in the standard EL hypertableau algorithm (Motik & Horrocks, 2008), one can show that each derivation rule can be applied in polynomial time, which implies the claim of this theorem."}], "references": [{"title": "Pushing the EL Envelope", "author": ["F. Baader", "S. Brandt", "C. Lutz"], "venue": "Proc. of the 19th Int. Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "Baader et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2005}, {"title": "The Description Logic Handbook: Theory, Implementation and Applications (2nd edition)", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2007}, {"title": "Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "What to Ask to a Peer: Ontolgoy-based Query Reformulation", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Proc. of the 9th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Calvanese et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2004}, {"title": "A Logical Framework for Modularity of Ontologies", "author": ["B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler"], "venue": "Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Grau et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2007}, {"title": "Modular Reuse of Ontologies: Theory and Practice", "author": ["B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Grau et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2008}, {"title": "OWL 2: The next step for OWL", "author": ["B. Cuenca Grau", "I. Horrocks", "B. Motik", "B. Parsia", "P. Patel-Schneider", "U. Sattler"], "venue": "Journal of Web Semantics: Science, Services and Agents on the World Wide Web,", "citeRegEx": "Grau et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2008}, {"title": "Ontology module extraction for ontology reuse: an ontology engineering perspective", "author": ["P. Doran", "V.A.M. Tamma", "L. Iannone"], "venue": null, "citeRegEx": "Doran et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Doran et al\\.", "year": 2007}, {"title": "A Description Logic with Transitive and Inverse Roles and Role Hierarchies", "author": ["I. Horrocks", "U. Sattler"], "venue": "Journal of Logic and Computation,", "citeRegEx": "Horrocks and Sattler,? \\Q1999\\E", "shortCiteRegEx": "Horrocks and Sattler", "year": 1999}, {"title": "Data Complexity of Reasoning in Very Expressive Description Logics", "author": ["U. Hustadt", "B. Motik", "U. Sattler"], "venue": "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Hustadt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2005}, {"title": "Safe and Economic Re-Use of Ontologies: A Logic-Based Methodology and Tool Support", "author": ["E. Jim\u00e9nez-Ruiz", "B. Cuenca Grau", "U. Sattler", "T. Schneider", "R. Berlanga Llavori"], "venue": "Proc. of the 5th European Semantic Web Conference (ESWC 2008),", "citeRegEx": "Jim\u00e9nez.Ruiz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Jim\u00e9nez.Ruiz et al\\.", "year": 2008}, {"title": "Semantic Modularity and Module Extraction in Description Logics", "author": ["B. Konev", "C. Lutz", "D. Walther", "F. Wolter"], "venue": "Proc. of the 18th European Conf. on Artificial Intelligence (ECAI", "citeRegEx": "Konev et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Konev et al\\.", "year": 2008}, {"title": "Forgetting and Uniform Interpolation in Large-Scale Description Logic Terminologies", "author": ["B. Konev", "D. Walther", "F. Wolter"], "venue": "Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Konev et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Konev et al\\.", "year": 2009}, {"title": "Minimal Module Extraction from DL-Lite Ontologies Using QBF Solvers", "author": ["R. Kontchakov", "L. Pulina", "U. Sattler", "T. Schneider", "P. Selmer", "F. Wolter", "M. Zakharyaschev"], "venue": "Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Kontchakov et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2009}, {"title": "Conservative Extensions in Expressive Description Logics", "author": ["C. Lutz", "D. Walther", "F. Wolter"], "venue": "Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Lutz et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2007}, {"title": "Deciding inseparability and conservative extensions in the description logic EL", "author": ["C. Lutz", "F. Wolter"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "Lutz and Wolter,? \\Q2010\\E", "shortCiteRegEx": "Lutz and Wolter", "year": 2010}, {"title": "Foundations for Uniform Interpolation and Forgetting in Expressive Description Logics", "author": ["C. Lutz", "F. Wolter"], "venue": "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Lutz and Wolter,? \\Q2011\\E", "shortCiteRegEx": "Lutz and Wolter", "year": 2011}, {"title": "Individual Reuse in Description Logic Reasoning", "author": ["B. Motik", "I. Horrocks"], "venue": "Proc. of the 4th Int. Joint Conf. on Automated Reasoning (IJCAR 2008),", "citeRegEx": "Motik and Horrocks,? \\Q2008\\E", "shortCiteRegEx": "Motik and Horrocks", "year": 2008}, {"title": "Hypertableau Reasoning for Description Logics", "author": ["B. Motik", "R. Shearer", "I. Horrocks"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "Computational Complexity", "author": ["C.H. Papadimitriou"], "venue": "Addison Wesley.", "citeRegEx": "Papadimitriou,? 1993", "shortCiteRegEx": "Papadimitriou", "year": 1993}, {"title": "Which Kind of Module Should I Extract", "author": ["U. Sattler", "T. Schneider", "M. Zakharyaschev"], "venue": "Proc. of the 22nd Int. Workshop on Description Logics (DL 2009),", "citeRegEx": "Sattler et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Sattler et al\\.", "year": 2009}, {"title": "Modular Ontologies: Concepts, Theories and Techniques for Knowledge Modularization, Vol", "author": ["H. Stuckenschmidt", "C. Parent", "S. Spaccapietra"], "venue": null, "citeRegEx": "Stuckenschmidt et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Stuckenschmidt et al\\.", "year": 2009}, {"title": "The Complexity of Reasoning with Cardinality Restrictions and Nominals in Expressive Description Logics", "author": ["S. Tobies"], "venue": "Journal of Artificial Intelligence Research, 12, 199\u2013 217.", "citeRegEx": "Tobies,? 2000", "shortCiteRegEx": "Tobies", "year": 2000}, {"title": "Concept and Role Forgetting inALC Ontologies", "author": ["K. Wang", "Z. Wang", "R.W. Topor", "J.Z. Pan", "G. Antoniou"], "venue": "Proc. of the 8th Int. Semantic Web Conference (ISWC 2009),", "citeRegEx": "Wang et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2009}, {"title": "Forgetting Concepts in DL-Lite", "author": ["Z. Wang", "K. Wang", "R.W. Topor", "J.Z. Pan"], "venue": "Proc. of the 5th European Semantic Web Conference (ESWC 2008),", "citeRegEx": "Wang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2008}, {"title": "Tableau-based Forgetting in ALC Ontologies", "author": ["Z. Wang", "K. Wang", "R.W. Topor", "X. Zhang"], "venue": "Proc. of the 19th European Conference on Artificial Intelligence,", "citeRegEx": "Wang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Wang et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 24, "context": "For example, one possible approach is to publish an \u03a5-interpolant ofKh\u2014an ontology that contains no symbols from\u03a5 and that coincides withKh on all logical consequences formed using the symbols not in \u03a5 (Konev, Walther, & Wolter, 2009; Wang, Wang, Topor, Pan, & Antoniou, 2009; Wang, Wang, Topor, & Pan, 2008; Wang, Wang, Topor, & Zhang, 2010; Wang et al., 2008; Lutz & Wolter, 2011; Nikitina, 2011).", "startOffset": 202, "endOffset": 398}, {"referenceID": 12, "context": "First, an interpolant may exist only if Kh is expressed in a relatively weak ontology language and if it satisfies certain syntactic conditions (Konev et al., 2009).", "startOffset": 144, "endOffset": 164}, {"referenceID": 18, "context": "In this section, we recapitulate the description logic notation used in this paper, we present an overview of various hypertableau reasoning algorithms for description logics (Motik et al., 2009), and we recapitulate various notions of modular ontology reuse (Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Konev, Lutz, Walther, & Wolter, 2008).", "startOffset": 175, "endOffset": 195}, {"referenceID": 1, "context": "It is well known that these two definitions are equally expressive (Baader et al., 2007).", "startOffset": 67, "endOffset": 88}, {"referenceID": 0, "context": "The DL EL (Baader et al., 2005) (resp.", "startOffset": 10, "endOffset": 31}, {"referenceID": 18, "context": "The hypertableau calculus by Motik et al. (2009) decides the satisfiability of an ALCHOIQ knowledge base K.", "startOffset": 29, "endOffset": 49}, {"referenceID": 18, "context": "The hypertableau calculus by Motik et al. (2009) decides the satisfiability of an ALCHOIQ knowledge base K. As we show in Section 4.1, the presence of nominals precludes the existence of an import-by-query algorithm; hence, in this section we present an overview of a simplified version of the algorithm that is applicable if K is an ALCHIQ knowledge base. The algorithm first preprocesses K into a set of rules R\u2014implications interpreted under first-order semantics\u2014and a normalized ABox A such that K is equisatisfiable with R \u222a A. Preprocessing consists of three steps. First, transitivity axioms are eliminated from K by encoding them using concept inclusions. Second, axioms are normalized and complex concepts are replaced with atomic ones in a way similar to the structural transformation for first-order logic. Third, the normalized axioms are translated into rules by using the correspondence between description and first-order logic. We omit the details of the preprocessing for the sake of brevity; Motik et al. (2009) present all the relevant details.", "startOffset": 29, "endOffset": 1031}, {"referenceID": 18, "context": "As Motik et al. (2009) have shown, the preprocessing of K produces an equisatisfiable set of HT-rules and a normalized ABox; furthermore, if K is Horn, then the resulting set contains only Horn HT-rules.", "startOffset": 3, "endOffset": 23}, {"referenceID": 18, "context": "When applied to an EL knowledge base, the transformation by Motik et al. (2009) produces EL-rules\u2014HT-rules of the form (8) in which C is either an atomic concept or a concept of the form \u2203R.", "startOffset": 60, "endOffset": 80}, {"referenceID": 18, "context": "Models of R\u222aA obtained in such a way are called canonical forest models, and Motik et al. (2009) discuss in depth the properties of such models.", "startOffset": 77, "endOffset": 97}, {"referenceID": 17, "context": "Motik and Horrocks (2008) showed, however, that a worst-case optimal algorithm can be obtained by modifying the \u2265-rule.", "startOffset": 0, "endOffset": 26}, {"referenceID": 14, "context": "a signature \u0393 is a very hard computational problem for most DLs, and it is often undecidable (Lutz et al., 2007; Konev et al., 2008).", "startOffset": 93, "endOffset": 132}, {"referenceID": 11, "context": "a signature \u0393 is a very hard computational problem for most DLs, and it is often undecidable (Lutz et al., 2007; Konev et al., 2008).", "startOffset": 93, "endOffset": 132}, {"referenceID": 11, "context": ", 2007; Konev et al., 2008). Cuenca Grau, Horrocks, Kazakov, and Sattler (2008) have defined several practically useful sufficient syntactic conditions that guarantee semantic modularity.", "startOffset": 8, "endOffset": 80}, {"referenceID": 19, "context": "A precise definition of the latter is given by Papadimitriou (1993); we next present just an informal overview of the main ideas.", "startOffset": 47, "endOffset": 68}, {"referenceID": 18, "context": "Furthermore, in the rest of this paper we assume that Kv is preprocessed as described by Motik et al. (2009) into the corresponding set of HT-rules Rv and ABox Av; this will be convenient because HT-rules do not contain nested quantifiers.", "startOffset": 89, "endOffset": 109}, {"referenceID": 22, "context": "TBox Tv uses the well-known \u201cinteger counting\u201d technique (Tobies, 2000).", "startOffset": 57, "endOffset": 71}, {"referenceID": 12, "context": "Some of these drawbacks can be overcome by publishing an \u03a5-interpolant of Th\u2014an ontology that contains no symbols from \u03a5 and that coincides with Th on all logical consequences formed using the symbols not in \u03a5 (Konev et al., 2009; Wang et al., 2009, 2008; Lutz & Wolter, 2011; Nikitina, 2011).", "startOffset": 210, "endOffset": 292}, {"referenceID": 12, "context": "First, an interpolant may exist only if Th is expressed in a relatively weak DL and satisfies certain syntactic conditions (Konev et al., 2009).", "startOffset": 123, "endOffset": 143}, {"referenceID": 20, "context": "Second, although interpolants preserve logical consequences formed using symbols not in \u03a5, they are not robust under replacement (Sattler et al., 2009)\u2014that is, the union of Kv and an \u03a5-interpolant of Th is not guaranteed to yield the same consequences as Th \u222aKv for a query q involving no symbols from \u03a5.", "startOffset": 129, "endOffset": 151}, {"referenceID": 2, "context": "Since a satisfiable Kh cannot affect the subsumption of concepts in Kv, the results by Calvanese et al. (2004) are not applicable to schema reasoning.", "startOffset": 87, "endOffset": 111}, {"referenceID": 18, "context": "The proof is a straightforward modification of the proof of Lemma 4 by Motik et al. (2009), which are due the following observations: since HT-rules do not allow for atoms of the form R(x, x) in the head, one cannot derive atoms of the form R(s, s); this, in turn, guarantees that one cannot derive equalities of the form s.", "startOffset": 71, "endOffset": 91}, {"referenceID": 18, "context": "The rest of the proof of our claim is then analogous to the proof of Lemma 7 by Motik et al. (2009).", "startOffset": 80, "endOffset": 100}, {"referenceID": 18, "context": "Let Rh be the result of transforming Th into a set of HT-rules as described by Motik et al. (2009); then, Rv \u222aAv \u222a Th is equisatisfiable with Rv \u222aAv \u222aRh, and each model of the latter is a model of the former as well.", "startOffset": 79, "endOffset": 99}, {"referenceID": 15, "context": "The following lemma captures the relevant properties of the standard EL hypertableau algorithm, and it can be proved by a slight variation of the proofs by Motik and Horrocks (2008) and Baader et al.", "startOffset": 156, "endOffset": 182}, {"referenceID": 0, "context": "The following lemma captures the relevant properties of the standard EL hypertableau algorithm, and it can be proved by a slight variation of the proofs by Motik and Horrocks (2008) and Baader et al. (2005).", "startOffset": 186, "endOffset": 207}, {"referenceID": 18, "context": "Let Rh be the set of EL-rules corresponding to Th as described by Motik et al. (2009), and let AEL be the ABox labeling a leaf of a derivation of the standard EL hypertableau algorithm for Rv \u222aRh and Av; then, Ae \u2286 AEL.", "startOffset": 66, "endOffset": 86}, {"referenceID": 18, "context": "Let Rh be the result of transforming Th into a set of EL-rules as described by Motik et al. (2009); then, Rv \u222aAv \u222a Th is equisatisfiable with Rv \u222aAv \u222aRh, and each model of the latter is a model of the former as well.", "startOffset": 79, "endOffset": 99}], "year": 2012, "abstractText": "There is currently a growing interest in techniques for hiding parts of the signature of an ontology Kh that is being reused by another ontology Kv. Towards this goal, in this paper we propose the import-by-query framework, which makes the content of Kh accessible through a limited query interface. If Kv reuses the symbols from Kh in a certain restricted way, one can reason over Kv \u222aKh by accessing only Kv and the query interface. We map out the landscape of the import-by-query problem. In particular, we outline the limitations of our framework and prove that certain restrictions on the expressivity of Kh and the way in which Kv reuses symbols from Kh are strictly necessary to enable reasoning in our setting. We also identify cases in which reasoning is possible and we present suitable import-by-query reasoning algorithms.", "creator": "TeX"}}}