{"id": "1402.0559", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Short and Long Supports for Constraint Propagation", "abstract": "special - edition partial block variants frequently make implicit use of chain feedback - - by combining linear participant composing the variables, they can produce support ( either justification that involves right - value pair algorithm still form linear into logical assignment that repeats the constraint ) among multiple other variables and significantly likewise save substantial work - - but short supports such not been considered in far lawful right. the two main circumstances causing this design are the identification of short process utilization tools for constraint propagation, prompting the introduction sequential iteration, an efficient and efficient general purpose scheduling algorithm for computation dependent supports. given the advent of compiler, specialists evaluated it as heavily optimised problem since a simpler algorithm shortgac. previous experiments demonstrate a reduction of shortgac compared with sophisticated general - purpose propagation processors however a simple compiler supplying parallel supports is stable, we learned theoretically and experimentally that behavior is even better. tools also find polynomial method performs better vs \u03b5 - easy since full - object supports. we also introduce some variant algorithm haggisgac - stable, which is adapted to avoid work on concurrency and in some parts can find predictable or therefore detrimental reductions in memory use. hopefully the proposed algorithms are excellent for propagating disjunctions - constraints. in automated simulations with disjunctions we found our algorithms simply be fastest than null or and gac - like by at least 37 mm per magnitude, and 70 % three _ de magnitude.", "histories": [["v1", "Tue, 4 Feb 2014 01:34:04 GMT  (488kb)", "http://arxiv.org/abs/1402.0559v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["peter nightingale", "ian philip gent", "christopher jefferson", "ian miguel"], "accepted": false, "id": "1402.0559"}, "pdf": {"name": "1402.0559.pdf", "metadata": {"source": "CRF", "title": "Short and Long Supports for Constraint Propagation", "authors": ["Peter Nightingale", "Ian P. Gent", "Christopher Jefferson", "Ian Miguel"], "emails": ["pwn1@st-andrews.ac.uk", "ian.gent@st-andrews.ac.uk", "caj21@st-andrews.ac.uk", "ijm@st-andrews.ac.uk"], "sections": [{"heading": "1. Introduction", "text": "Constraint solvers typically employ a systematic backtracking search, interleaving the choice of an assignment of a decision variable with the propagation of the constraints to determine the consequences of the assignment made. Propagation algorithms can broadly be divided into two types. The first are specialised to reason very efficiently about constraint patterns that occur frequently in models. Examples include the global cardinality constraint (Re\u0301gin, 1996) and the element constraint (Gent, Jefferson, & Miguel, 2006b). It is not feasible to support every possible constraint expression with a specialised propagator in this way, in which case general-purpose constraint propagators, such as GAC-Schema (Bessie\u0300re & Re\u0301gin, 1997), GAC2001/3.1 (Bessie\u0300re, Re\u0301gin, Yap, & Zhang, 2005), STR2 (Lecoutre, 2011) or MDDC (Cheng & Yap, 2010) are used. These are typically more expensive than specialised propagators but are an important tool when no specialised propagator is available.\nA support in a constraint for a domain value of a variable is a justification that the value may still form part of an assignment that satisfies the constraint. It is usually given in terms of a set of literals: variable-value pairs corresponding to possible assignments to the other\nc\u00a92013 AI Access Foundation. All rights reserved.\nvariables in the constraint. One of the efficiencies typically found in specialised propagators is the use of short supports: by examining a subset of the variables, they can infer support for all other variables and values and save substantial work. This use is typically implicit, i.e. achieved through a specialised algorithm which does not examine all variables in all cases. One of our contributions is to highlight the general importance of short supports.\nAs an example, consider the element constraint xy = z, with x0, x1, x2, y \u2208 {0 . . . 2}, z \u2208 {0 . . . 3}. This constraint is satisfied iff the element in position y of vector [x0, x1, x2] equals z. Consider the set of literals S = {x0 7\u2192 1, y 7\u2192 0, z 7\u2192 1}. This set clearly satisfies the definition of the constraint xy = z, but it does not contain a literal for each variable. Any extension of S with valid literals for variables x1 and x2 is a support. S is an example of a short support.\nIn our previous work we introduced ShortGAC (Nightingale, Gent, Jefferson, & Miguel, 2011), a general-purpose propagation algorithm that exploits short supports. Until the introduction of ShortGAC, general-purpose propagators relied upon supports involving all variables. In this paper we develop the concept further and introduce a new algorithm HaggisGAC,1 which is consistently more efficient than ShortGAC. Where available, the use of compact sets of short supports allows HaggisGAC to outperform greatly existing general-purpose propagation algorithms. In some cases, HaggisGAC even approaches the performance of special-purpose propagators. HaggisGAC is also very well suited to propagating disjunctions of constraints, and outperforms the traditional Constructive Or algorithm (Lagerkvist & Schulte, 2009; Wu\u0308rtz & Mu\u0308ller, 1996) by orders of magnitude. HaggisGAC is also more efficient than GAC-Schema on full-length supports. We also describe a variant, HaggisGAC-Stable, in which supports do not need to be deleted on backtracking. Applied to full-length supports, this version has greatly reduced memory usage.\nShortGAC, HaggisGAC and HaggisGAC-Stable are all instantiated with a function named findNewSupport (and are similar to GAC-Schema in this way). This function can be specific to a constraint, and generate short supports procedurally. Alternatively, a generic findNewSupport can retrieve short supports from a data structure.\nSection 2 presents the necessary background, and Section 3 introduces the concept of short support. Section 4 outlines the basic idea used to deal with implicit supports throughout the paper. Section 5 gives full details of ShortGAC, including the complexity of key operations and alternative implementations for when short supports are provided in list form. Section 6 presents the new algorithm HaggisGAC as a development of ShortGAC. Both ShortGAC and HaggisGAC are evaluated experimentally in Section 7. Section 8 describes HaggisGAC-Stable, with corresponding experiments in Section 9. Finally, Sections 10 and 11 discuss related work and present our conclusions.\n1. HaggisGAC is named for the legendary wild haggis of Scotland, which has both short legs and long legs for walking around hills. Like its namesake, HaggisGAC copes with both full-length and shorter supports and originates in Scotland. Details of the wild haggis can be found on Wikipedia, http: //en.wikipedia.org/wiki/Wild_haggis, and in the Veterinary Record (King, Cromarty, Paterson, & Boyd, 2007)."}, {"heading": "2. Supports, GAC, Triggers", "text": "A constraint satisfaction problem (CSP) is defined as a set of variables X, a function that maps each variable to its domain, D : X \u2192 2Z where each domain is a finite set, and a set of constraints C. A constraint c \u2208 C is a relation over a subset of the variables X. The scope of a constraint c, named scope(c), is the set of variables that c constrains.\nA solution to a CSP is a function s : X \u2192 Z that maps each variable x \u2208 X to a value from D(x), such that for every constraint c \u2208 C, the values of scope(c) form a tuple that is in c (i.e. the constraint is satisfied).\nDuring a systematic search for a solution to a CSP, values are progressively removed from the domains D. Therefore, we distinguish between the initial domains and the current domains. The function D refers to the current domains unless stated otherwise. A literal is defined as a variable-value pair, and is written x 7\u2192 v. A literal x 7\u2192 v is valid if v is in the current domain of x (i.e. v \u2208 D(x)).\nDefinition 2.1. [Support] A support S for constraint c and domains D is defined as a set of valid literals that contains exactly one valid literal for each variable in scope(c) and satisfies c. Where necessary for disambiguation, we call such a support a full-length support or simply long support, to contrast with short supports as defined later.\nA property commonly established by constraint propagation algorithms is generalised arc consistency (GAC) (Mackworth, 1977). A constraint c is GAC if and only if there exists a full-length support for every valid literal of every variable in scope(c). GAC is established by identifying all literals x 7\u2192 v for which no full-length support exists and removing v from the domain of x. We consider only algorithms for establishing GAC in this paper.\nA GAC propagation algorithm is usually situated in a systematic search. Hence, it must operate in three contexts: initialisation (at the root node), where support is established from scratch; following the deletion of one or more domain values (as a result of a branching decision and/or the propagation of other constraints), where support must be re-established selectively; and upon backtracking, where data structures must be restored to the correct state for this point in search. Our primary focus will be on the second context, operation following value deletion, although we will discuss efficient backtracking in Section 8. A GAC propagation algorithm would typically be called for each deleted domain value in turn. Once the algorithm has been called for each such domain value, the constraint will be GAC.\nThe propagation algorithms we present have the concept of active support, inspired by GAC-Schema (Bessie\u0300re & Re\u0301gin, 1997). An active support is a support that is currently in use to support a set of literals. Each literal has a set of active supports that support it. When an active support is found to be invalid, it is removed. When the set for some literal is empty, we say the literal has lost support. A new support is sought for the literal, and if found the new support becomes active. If no new support is found, the literal has no support and it is deleted.\nIn the propagation algorithms we present, for efficiency we make use of \u2018watched literals\u2019 as provided in Minion (Gent et al., 2006b), because propagators need not be called for every deleted domain value to establish GAC. We say that propagators attach and remove triggers on literals. When a domain value v for variable x is deleted, the propagator is called if and\nonly if it has a trigger attached to the literal x 7\u2192 v. Doing so means that when a literal is deleted which is not attached to a trigger, zero work is incurred. We should emphasise that the use of watched literals is not fundamental to our work. If they are not available in a given solver, our algorithms only need a minor adaptation. When called on any literal removal, we may just return immediately if the literal is not in any active support, which can be checked in time O(1). Thus our algorithms fit the traditional fine-grained scheme (Bessie\u0300re & Re\u0301gin, 1997) except that in some cases they will not be invoked because they use watched literals."}, {"heading": "3. Short Supports", "text": "The concept of a short support is a generalisation of full-length support. It is defined below.\nDefinition 3.1. [Short support] A short support S for constraint c and domains D is defined as a set of valid literals x 7\u2192 v such that x \u2208 scope(c), x occurs only once in S, and every superset of S that contains one valid literal for each variable in scope(c) is a full-length support. A strict short support is a short support that is not a full-length support.\nThe definition of short support includes both extremes. The empty set is a short support when the constraint is entailed (i.e. every tuple on scope(c) within D satisfies the constraint). Similarly, every full-length support S is necessarily a short support, because the only superset of S is itself. In our case studies we will see examples of both empty short supports and short supports that also happen to be full length.\nShort supports can be used to maintain GAC. Just as with a full-length support, a short support provides GAC support for each literal contained within it. We call this explicit support for those literals. The new feature is that a short support also provides support for all valid literals of all variables not contained in the short support. This is because, by definition, every valid extension of the short support to cover all variables in scope(c) is a full-length support. We say that a short support gives implicit GAC support for all valid literals of variables not in the short support.\nWe also define the concept of a complete set of short supports for a constraint.\nDefinition 3.2. [Short support set] A short support set S(c,D) is a set of short supports for constraint c under domains D, such that every full-length support S of c under D is a (not necessarily strict) superset of at least one short support S\u2032 \u2208 S(c,D).\nA constraint may have many short support sets. This gives us some latitude to implement one that is efficient to compute.\nIt is natural to ask how we can identify correct short supports given a constraint c. A simple but fundamental result is given in Lemma 3.3.\nLemma 3.3. Given a constraint c and domains D, the empty set {} is a short support for c iff GAC propagation for the constraint not(c) leads to an empty domain.\nProof. {} is a short support if and only if every valid assignment to variables in scope(c) satisfies c. Every assignment satisfies c iff every assignment violates not(c). If every assignment violates not(c), then GAC propagation for the constraint not(c) leads to an empty\ndomain. To complete this last equivalence, note that if any assignment does not violate not(c), all literals in that assignment are supported, so GAC propagation cannot cause an empty domain.\nThis lemma has two important consequences. First, we can check any short support for correctness, not just the empty support. To check a short support S = {x1 7\u2192 v1, . . . , xk 7\u2192 vk}, we can simply set D(x1) = {v1}, . . . , D(xk) = {vk}. All assignments now extend S, so S is a short support iff {} is. Lemma 3.3 applies so we can check the correctness of S by propagating not(c) and seeing if a domain is emptied.\nThe second consequence is negative, however. Determining whether GAC propagation will empty a domain is polynomially equivalent to actually performing GAC propagation (Bessie\u0300re, Hebrard, Hnich, & Walsh, 2007). Since some constraints are NP hard to GAC propagate, it follows that it is not easy even to check if the empty set is a short support. Thus we cannot expect to find a method which is both fast and general for finding short supports for a constraint.\nGiven the provable difficulty of finding short supports from a set of full-length supports, we construct sets of short supports specifically for each of three experimental case studies in Section 7. The focus of this paper is to show the value of strict short supports if they are given to the system. The situation is analogous with that in an important area of constraints, namely that of exploiting symmetries in constraint problems (Gent, Petrie, & Puget, 2006). A large majority of research has assumed that sets of symmetries are provided to the system, even though finding such sets is hard. This has not inhibited research in exploiting symmetry, within which the automated detection of symmetry has become an important subarea (Mears, 2009; Puget, 2005): however we leave the automated construction of compact short support sets to future research. Analogously to patterns such as matrix symmetries (Flener, Frisch, Hnich, Kiziltan, Miguel, Pearson, & Walsh, 2002), we can at least identify a pattern which often lets us identify strict short supports, as we now describe."}, {"heading": "3.1 Short Supports and Disjunction", "text": "Strict short supports arise naturally from disjunctions. If a constraint can be expressed as a disjunction of shorter constraints, then a set of strict short supports can be constructed for it. Suppose we have the following constraint.\nc(x1, x2, x3, x4) \u2261 c1(x1, x2) \u2228 c2(x2, x3) \u2228 c3(c3, x4)\nSuppose also that A = {x1 7\u2192 2, x2 7\u2192 1} is a valid assignment that satisfies c1. If we satisfy c1, we satisfy c regardless of the values of x3 and x4. Therefore A = {x1 7\u2192 2, x2 7\u2192 1} is a strict short support for c.\nLemma 3.4. Given constraint c, a domain set D, and a set of constraints {c1 . . . ck} where \u2200ci \u2208 {c1 . . . ck} : scope(ci) \u2286 scope(c) and c \u2261 c1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 ck, the following is a short support set (where we write fls(ci, D) to mean the full-length supports of ci w.r.t. domains D):\nS(c,D) = {S | S \u2208 fls(c1, D) \u2228 \u00b7 \u00b7 \u00b7 \u2228 S \u2208 fls(ck, D)}\nProof. (a) Each element of S(c,D) is a short support according to Definition 3.1 by the semantics of disjunction. (b) S(c,D) is a short support set by Definition 3.2. Every fulllength support of c must satisfy some disjunct ci, therefore the full-length support contains a full-length support for ci that is included in S(c,D).\nLemma 3.4 allows a short support set to be created for any disjunction, given the initial domains. We do this for two of our three case studies (for the third, the set is prohibitively large).\nUsing a similar approach to Lemma 3.4 we can create a function that generates short supports on demand. The function takes a valid literal x 7\u2192 v and the current domains D, and returns a short support that supports x 7\u2192 v (explicitly or implicitly), or Null if none exists. The function can be constructed as follows. We create new domains D\u2032 where D\u2032(x) = {v}, and otherwise D\u2032 is identical to D. If no disjunct is satisfiable under D\u2032, then the function returns Null. Otherwise, the function picks any disjunct ck that is satisfiable under D\u2032, and returns a satisfying assignment of ck that is valid under D\n\u2032. For each of the three case studies in Section 7, we created a function that follows this scheme with some optimisations.\nPropagating disjunctions is recognised to be an important topic. Many papers have been published in this area (Wu\u0308rtz & Mu\u0308ller, 1996; Lhomme, 2003; Lagerkvist & Schulte, 2009; Jefferson, Moore, Nightingale, & Petrie, 2010). Exploiting strict short supports in the algorithms ShortGAC, HaggisGAC and HaggisGAC-Stable allows us to outperform the traditional Constructive Or algorithm (Wu\u0308rtz & Mu\u0308ller, 1996) by orders of magnitude."}, {"heading": "3.2 Backtrack Stability of Short Supports", "text": "Within a search tree, propagation algorithms often spend significant time backtracking data structures. Reducing or eliminating backtracking can improve efficiency. For example, avoiding backtracking triggers can speed up a simple table propagator by more than 2 times (Gent et al., 2006b), and MAC-6 and MAC-7 can be much more efficient (in both space and time) if backtracking is avoided (Re\u0301gin, 2005). There are two potential advantages of reducing use of backtracking state: it saves time restoring data structures, and it saves space by avoiding storing supports on the backtrack stack.\nDefinition 3.5. [Backtrack Stable] A short support of constraint c with current domains D is backtrack stable iff it always remains a short support (according to Definition 3.1) after backtracking up the search tree.\nA short support s may support some variable x implicitly, and as we backtrack we may add values back into the domain of x that are not consistent with s, meaning that s no longer meets the definition of a short support. We give an example below.\nExample 3.1. Consider the constraint b \u2192 M [x] = y, for a boolean variable b, array of variables M and variables x and y. When b is assigned False, this constraint is entailed, and so the empty short support can be used to support all literals in M,x and y. This support is not backtrack stable, as on backtracking when True is restored to the domain of b, the empty set is no longer a short support.\nAny support that is full length is backtrack stable: whenever the support is valid it supports all literals it contains. Backtrack stable supports always exist because we can use full-length supports in all cases (as in GAC-Schema), although these may be much longer than necessary.\nIn Section 8 we exploit backtrack stability to define a new algorithm.\n4. ShortGAC: An Overview\nThis section summarises the key ideas of the ShortGAC propagation algorithm, along with an illustrative example.2\nShortGAC maintains a set of short supports sufficient to support all valid literals of the variables in the scope of the constraint it is propagating. We refer to these as the active supports. The algorithm rests on exploiting the observation that, using short supports, support can be established for a literal in two ways. First, as usual, a short support that contains a literal supports that literal. Second, a literal x 7\u2192 v is supported by a short support that contains no literal of variable x. Hence, the only short supports that do not support x 7\u2192 v are those which contain a literal x 7\u2192 w for some other value w 6= v.\nThe following data structures are central to the operation of the ShortGAC algorithm:\nnumSupports is the total number of active short supports.\nsupportsPerVar is an array (indexed by [x]) indicating the number of active short supports containing each variable x.\nsupportListPerLit is an array (indexed by [x 7\u2192 v]) of lists of active short supports containing each literal x 7\u2192 v.\nIf the number of supports containing some variable x is less than the total number of supports then there exists a support s that does not contain x. Therefore, s supports all literals of x. The algorithm spends no time processing variables all of whose literals are known to be supported in this way. Only for variables involved in all active supports do we have to seek support for literals with no active supports.\nTo illustrate, we consider the element example from the introduction: xy = z, with x0, x1, x2, y \u2208 {0 . . . 2}, and z \u2208 {0 . . . 3}. This constraint is satisfied iff the element in position y of vector [x0, x1, x2] equals z. Suppose in the current state ShortGAC is storing just one support: A = {x0 7\u2192 1, y 7\u2192 0, z 7\u2192 1}. The data structures are as follows, where \u00d7 indicates that a literal is not valid.3\n2. The details we present here are different from those we presented previously (Nightingale et al., 2011), as we have optimised the data structures and algorithms compared with our previous work. The two most significant changes are: we no longer keep a count of supports per literal, saving overhead in maintaining this; and data is stored in a one dimensional vector by literal, instead of a two dimensional array by variable/value, saving space if variables in a constraint have very different domain sizes. Experiments in Appendix A demonstrate that the algorithms and data structures presented here perform better than our previous implementation. 3. For clarity, we have presented the one-dimensional array supportListPerLit in a two-dimensional format.\nSupports: A: x0 7\u2192 1, y 7\u2192 0, z 7\u2192 1 supportListPerLit: Variable\nValue x0 x1 x2 y z 0 {} {} {} {A} {} 1 {A} {} {} {} {A} 2 {} {} {} {} {} 3 \u00d7 \u00d7 \u00d7 \u00d7 {}\nsupportsPerVar: 1 0 0 1 1 numSupports: 1\nAll values of x1 and x2 have support, since their supportsPerVar counters are both less than numSupports. Therefore the ShortGAC algorithm can ignore x1 and x2 and only look for new supports of x0, y and z. Consider finding a new support for literals in z. ShortGAC can ignore the literals with at least one support \u2013 in this case z 7\u2192 1. The algorithm looks for literals z 7\u2192 a where supportListPerLit[z, a] = {}. Here, z 7\u2192 0 is such a literal, so ShortGAC seeks a new support for it. A possible new support is B = {x1 7\u2192 0, y 7\u2192 1, z 7\u2192 0}. Following its discovery, we update the data structures:\nSupports: A: x0 7\u2192 1, y 7\u2192 0, z 7\u2192 1 B: x1 7\u2192 0, y 7\u2192 1, z 7\u2192 0\nsupportListPerLit: Variable Value x0 x1 x2 y z\n0 {} {B} {} {A} {B} 1 {A} {} {} {B} {A} 2 {} {} {} {} {} 3 \u00d7 \u00d7 \u00d7 \u00d7 {}\nsupportsPerVar: 1 1 0 2 2 numSupports: 2\nNow variable x0 is also fully supported, since supportsPerVar[x0] < numSupports. There remain three literals for which support has not been established: y 7\u2192 2, z 7\u2192 2 and z 7\u2192 3. For the first two ShortGAC finds supports such as C = {x0 7\u2192 2, y 7\u2192 0, z 7\u2192 2} and D = {x2 7\u2192 0, y 7\u2192 2, z 7\u2192 0}. No support exists for z 7\u2192 3, so 3 will be deleted, giving:\nSupports: A: x0 7\u2192 1, y 7\u2192 0, z 7\u2192 1 B: x1 7\u2192 0, y 7\u2192 1, z 7\u2192 0 C: x0 7\u2192 2, y 7\u2192 0, z 7\u2192 2 D: x2 7\u2192 0, y 7\u2192 2, z 7\u2192 0\nsupportListPerLit: Variable Value x0 x1 x2 y z\n0 {} {B} {D} {A,C} {B,D} 1 {A} {} {} {B} {A} 2 {C} {} {} {D} {C} 3 \u00d7 \u00d7 \u00d7 \u00d7 \u00d7\nsupportsPerVar: 2 1 1 4 4 numSupports: 4\nAll valid literals are now supported. Nothing further need be done until a change in state, such as the removal of a value by a branching decision or propagation.\n5. ShortGAC: Details\nThe key tasks in implementing ShortGAC are: data structure update; iteration over variables where supportsPerVar equals numSupports; and iteration over the unsupported values of a variable. This section describes the infrastructure that allows us to perform each of these tasks efficiently.\n5.1 ShortGAC Data Structures\nAn active short support S of arity k provides explicit support for each of the k literals it contains. Therefore, a reference to S must appear in k of the lists of supportListPerLit. To do this, we represent S with two types of object: ShortSupport and ShortSupportCell. The ShortSupport object contains k ShortSupportCell objects, each of which contains a literal x 7\u2192 v,4 and a reference to the parent ShortSupport. The elements of the array supportListPerLit are doubly-linked lists of ShortSupportCells. Through the reference to the parent ShortSupport, we can iterate through all active short supports for a given literal.\nThe algorithm iterates over all variables x where supportsPerVar[x] equals numSupports. The following data structure represents a partition of the variables by the number of supports. It allows constant time size checking and linear-time iteration of each cell in the partition, and allows any variable to be moved into an adjacent cell (i.e. if the number of supports increases or decreases by 1) in constant time. It is inspired by the indexed dependency array in Gecode (Schulte & Tack, 2010).\nvarsBySupport is an array containing a permutation of the variables. Variables are ordered by non-decreasing number of active supports (supportsPerVar[x]).\nsupportNumLowIdx is an array of integers, indexed from 0 to the number of literals, that being the maximum number of active supports possible. Either supportNumLowIdx[i] is the smallest index in varsBySupport with i or more active supports, or (when there are no such variables) supportNumLowIdx[i]= k where k is the total number of variables. k acts as a sentinel value. The set of variables with i supports is:\nvarsBySupport[supportNumLowIdx[i] . . . supportNumLowIdx[i+ 1]\u2212 1]\nInitially, all variables have 0 active supports, so supportNumLowIdx[0] = 0 and the rest of the array is set to k.\nThe following table illustrates how the partition data structure works (on a different example with 11 variables). Suppose supportsPerVar[x2] changed from 7 to 6. x2 and y1 (boxed) are swapped in varsBySupport and the cell boundary is moved so that x2 is in the lower cell. Consequently, supportNumLowIdx[7] is incremented by 1.\nvarsBySupport[] w1 w2 y1 x1 x2 y2 y3 x3 z1 z2 z3 supportsPerVar 6 6 7 7 7 7 7 7 8 8 8\nx2 updated w1 w2 x2 x1 y1 y2 y3 x3 z1 z2 z3\n4. A literal x 7\u2192 v is represented using a single integer i. There is a mapping between x 7\u2192 v and i, which allows O(1) access to x and v from i and vice-versa.\nRequire: sup: a ShortSupport 1: for all sc: ShortSupportCell \u2208 sup do 2: (x 7\u2192 v) \u2190 sc.literal 3: if supportListPerLit[x 7\u2192 v] = {} then 4: attachTrigger(x 7\u2192 v) 5: Add sc to doubly linked list supportListPerLit[x 7\u2192 v] 6: supportsPerVar[x]++ 7: sx \u2190 supportsPerVar[x] 8: cellend \u2190 supportNumLowIdx[sx ]\u22121 9: swap(x, varsBySupport[cellend ]) 10: supportNumLowIdx[sx ]-- 11: numSupports++\nProcedure 1: addSupport(sup)\nFor a variable x with supportsPerVar[x] = numSupports, ShortGAC iterates over the values with zero explicit supports. To avoid iterating over all values, we use a set data structure:\nzeroLits is an array (indexed by [x]) of stacks containing the literals of variable x with zero explicit support, in no particular order.\ninZeroLits is an array (indexed by [x 7\u2192 v]) of booleans indicating whether literal x 7\u2192 v \u2208 zeroLits[x].\nWhen supportListPerLit[x 7\u2192 v] is reduced to the empty list, if inZeroLits[x 7\u2192 v] is false then x 7\u2192 v is pushed onto zeroLits[x] (and inZeroLits[x 7\u2192 v] is set to true). As an optimisation, values are not eagerly removed from the set; they are only removed lazily when the set is iterated. Also, the set is not backtracked. During iteration, a non-zero value is removed by swapping it to the top of the stack, and popping. This lazy maintenance never costs work overall because, if the value would have been removed eagerly, then it will be removed the next time the set is iterated, costing O(1). It can save work, because we may never iterate over the list before the value would have been restored to the set again.\nWe use a free list to manage the set of ShortSupport objects to avoid the cost of unnecessary object construction/destruction. The ShortSupport object retrieved from the free list may contain too few ShortSupportCell objects, so we use a resizable vector data structure. The size is only ever increased."}, {"heading": "5.2 Adding and Deleting Supports", "text": "When a support is added or deleted, all the data structures described above must be updated. This is done by Procedures 1 (addSupport) and 2 (deleteSupport). Both these procedures iterate through the given short support, and for each literal in it they update supportListPerLit, supportsPerVar, varsBySupport and supportNumLowIdx. Procedure 2 also inserts the literal into zeroLits if necessary. We briefly explain the maintenance of varsBySupport as it will become important in Section 6.2. Suppose we are adding support for literal x 7\u2192 v in Procedure 1. Because it has an additional support, x must be moved to the next cell in varsBySupport. Line 8 finds the end of the cell that x is in, then we swap x to the\nRequire: sup: a ShortSupport 1: for all sc: ShortSupportCell \u2208 sup do 2: (x 7\u2192 v) \u2190 sc.literal 3: Remove sc from doubly-linked list supportListPerLit[x 7\u2192 v] 4: supportsPerVar[x]-5: if supportListPerLit[x 7\u2192 v] = {} then 6: removeTrigger(x 7\u2192 v) 7: if \u00acinZeroLits[x 7\u2192 v] then 8: inZeroLits[x 7\u2192 v] \u2190 true 9: zeroLits[x].push(x 7\u2192 v) 10: sx \u2190 supportsPerVar[x] 11: cellend \u2190 supportNumLowIdx[sx+1] 12: swap(x, varsBySupport[cellend ]) 13: supportNumLowIdx[sx+1]++ 14: numSupports--\nProcedure 2: deleteSupport(sup)\nRequire: x 67\u2192 v (where v has been pruned from the domain of x) 1: while supportListPerLit[x 7\u2192 v] 6= {} do 2: deleteSupport(supportListPerLit[x 7\u2192 v].pop()) 3: repeat 4: continueLoop \u2190 false 5: for all i \u2208 {supportNumLowIdx[numSupports]. . . supportNumLowIdx[numSupports+1]-1} do 6: y \u2190 varsBySupport[i] 7: if ShortGAC-variableUpdate(y) = true then 8: continueLoop \u2190 true 9: break out of for loop Line 5 10: until continueLoop = false\nProcedure 3: ShortGAC-Propagate: propagate(x 67\u2192 v)\nend of its cell using a subroutine swap(xi, xj). This simple procedure (not given) locates and swaps the two variables in varsBySupport, leaving other variables unaffected. To do so it makes use of a second array, varsBySupInv, which is the inverse mapping of varsBySupport. Having done this, the cell boundary is decremented so that (in its new position), x is now in the higher cell. Another point to note is that addSupport will add a trigger for x 7\u2192 v if sup is the only active explicit support to contain that literal, while deleteSupport will remove the trigger if the deleted support is the only support.\nFinally, we note that we do not have special-purpose methods to undo these changes on backtracking. On backtracking past the point where a support is added, we simply call deleteSupport, and similarly we call addSupport when we backtrack past a support\u2019s deletion.\nRequire: variable x 1: for all (x 7\u2192 v) \u2208 zeroLits[x] do 2: if supportListPerLit[x 7\u2192 v] 6= {} then 3: Remove (x 7\u2192 v) from zeroLits[x] 4: else 5: if v \u2208 D(x) then 6: sup \u2190 findNewSupport(x 7\u2192 v) 7: if sup = Null then 8: prune(x 7\u2192 v) 9: else 10: addSupport(sup) 11: if supportListPerLit[x 7\u2192 v] 6= {} then 12: Remove (x 7\u2192 v) from zeroLits[x] 13: return true 14: return false\nProcedure 4: ShortGAC-variableUpdate: (x). Here and in other pseudocode we abstract the detailed maintenance of the zeroLits and inZeroLits data structures. It might seem that the test on Line 11 must always succeed. However, although sup must support x 7\u2192 v, it does not have to contain x 7\u2192 v as it might be an implicit support. The findNewSupport function is discussed in Section 5.5."}, {"heading": "5.3 The Propagation Algorithm", "text": "The ShortGAC propagator (Procedure 3) is only invoked when a literal contained in one or more active short supports is pruned.5 It first deletes all supports involving the pruned literal. Then it checks all variables y which are not implicitly supported, i.e. where supportsPerVar[y]=numSupports (Line 5). Each such variable y is checked by Procedure 4 (ShortGAC-variableUpdate, described below). If this call results in a new support being found, then the data structures will have changed (ShortGAC-variableUpdate(y) returns true to indicate this) and we must break out of the for-all-loop (Line 9) and go round again. Iteration therefore continues until either no new support is necessary or no new support can be found.\nShortGAC-variableUpdate (Procedure 4) is used to check the status of every variable lacking implicit support. It iterates over zeroLits, i.e. the literals for a variable which might have zero explicit supports. Since zeroLits is maintained lazily, on each iteration we first check that the literal does indeed have no explicit support, and correct zeroLits if necessary (Lines 2\u20133). The important case is that the literal indeed has no support. Then, provided that v is in the current domain of x, we must seek a new support by calling findNewSupport for the constraint. If there is no support, value v must be pruned from the domain of x, or if we have found a support we update data structures by calling addSupport.\nTo initialise data structures at the root of search, Lines 3\u201310 of Procedure 3 are invoked. Notice that these lines do not refer to the parameter x 67\u2192 v, and on first calling there are no supports at all so the initial iteration at Line 5 is over all variables.\n5. As we noted earlier, if watched literals are not available in a solver, a simple check can be made at the start of the procedure, to return immediately if the removed literal is in no active support.\n5.4 Complexity Analysis of ShortGAC\nIn this section we provide a complexity analysis of ShortGAC as it is used incrementally during search in a constraint solver. The analysis has as parameters the arity of the constraint n, the maximum domain size d, and the cost f of calling findNewSupport. We assume that both attaching and removing a trigger to a literal are O(1). This is the case in Minion 0.12.\nFirst we observe that the swap procedure executes in O(1) time: each operation in swap is O(1) and it does not loop. Secondly we establish the time complexity of the procedures addSupport and deleteSupport, which are key to the algorithm.\nLemma 5.1. Procedure 1 (addSupport) has time complexity O(n).\nProof. The outer loop on Line 1 iterates over the literals in the short support. In the worst case, there are n literals. We now consider the steps within this loop. The list test on Line 3 is O(1), as is the call to attachTrigger on Line 4. Adding the ShortSupportCell to the doubly-linked list on Line 5 is O(1), as are the following five array dereferences. As established above, the swap procedure is also O(1). Hence, addSupport is O(n).\nLemma 5.2. Procedure 2 (deleteSupport) has time complexity O(n).\nProof. Similarly to the add Support procedure, the outer loop on Line 1 has at most n iterations. The removal from the doubly-linked list on Line 3 is O(1), as are the array dereferences on Line 4 and subsequently. The list test on Line 5 and the call to removeTrigger on Line 6 are both O(1), as is the stack push operation on Line 9. Recalling once again that the swap procedure is O(1), deleteSupport is O(n).\nTheorem 5.3. Procedure 3 (ShortGAC-propagate) has time complexity in O(n2d2 +ndf). The upper bound can be obtained, i.e. the worst case time complexity is in \u2126(n2d2 + ndf).\nProof. Analysis for the first statement breaks down into three parts. First, the loop on Line 1 is over the elements of supportListPerLit. The worst case occurs when nd literals have an explicit support. Of these supports, a maximum of (n \u2212 1)d + 1 can involve a particular literal, because this literal may be in the short support for every literal of every other variable ((n\u2212 1)d), and itself (1). The cost of the body of this loop is O(n) from Lemma 5.2, so the total is O(n2d). This will be dominated by the next part.\nThe second part is the loop from lines 3\u201310. The maximum number of iterations in Line 5 is n when all supports are full length and so the iteration in Line 5 contains all n variables. Successive calls to Procedure 4 at Line 7 can add at most O(d) new supports. But each support addition triggers a restart of the loop beginning on Line 5 over all n variables, for a total of at most O(n2d) calls to Procedure 4. Each such call involves O(d) iterations of the loop on Line 1 of Procedure 4. Therefore the innermost loop is run at most O(n2d2) times.\nTo complete the proof of the first statement, we consider the cost of the innermost loop of Procedure 4. Within this loop, most operations are O(1), the exceptions being the call to findNewSupport on Line 6 (cost f) and the call to addSupport on Line 10 (cost n from Lemma 5.1). But f is the dominating cost, since it must at least traverse the new support to record it. However, of the n2d2 iterations, there can be at most nd calls to findNewSupport,\nafter which time all valid literals will have an explicit support. So the cost is either O(n2d2) or O(ndf), whichever is greater. In any case the cost is O(n2d2 + ndf).\nThe upper bounds of ndf and n2d2 can be attained in the worst case. If each literal needs a new support, we have \u2126(ndf) calls to findNewSupport. We can have cost \u2126(n2d2) if there are nd literals with explicit support, each of size n, and each variable ends up with (for example) d/2 values supported and d/2 values deleted. The worst case is thus \u2126(n2d2 + ndf).\nProcedure 3 can be invoked at most n(d \u2212 1) times in one branch of the search tree, therefore the complexity for one branch is O(n3d3 + n2d2f)."}, {"heading": "5.4.1 A Second Complexity Analysis", "text": "The analysis above can be very conservative when the total number, and maximum size, of short supports is small. Therefore, we give another complexity analysis with two additional parameters: the maximum length l of short supports returned by findNewSupport, and the total number s of distinct short supports that may be returned by findNewSupport. This analysis also pertains to a branch of search rather than a single call to the propagate algorithm.\nThe first part of this complexity analysis concerns the s short supports of length l. Each short support may be added to the active set once, and may be deleted once down a branch. Each short support must also be found by calling findNewSupport, with cost O(f). Lemma 5.1 shows that the addSupport procedure takes O(n) time. The same lemma can be re-stated in terms of l, because the loop in addSupport will iterate O(l) times, giving a total time of O(l). This also applies to deleteSupport. Since there are s short supports, the cost of finding, adding and deleting (collectively processing) short supports is O(s(l + f)) down a branch.\nSecondly, the algorithm may make calls to findNewSupport that return Null. This can happen at most n(d\u2212 1) + 1 times, because this is the maximum number of domain values that may be deleted. Therefore the cost is O(ndf).\nIn addition, ShortGAC does some operations that have not been charged to either of the above categories. To analyse these, we must do a top-down analysis of algorithm.\nProcedure 3 is invoked O(s) times (each time a short support is invalidated). Lines 1\u20132 are already charged to processing short supports. The body of the loop on lines 3\u201310 may be executed s times when a new support is found, and a further s times when no new support is found, therefore O(s) times in total down a branch of search.\nNow we come to the inner loop on lines 5\u20139. From Lemma 5.4 (below), unless a domain is empty there is always one or more active short support. Therefore, at most l variables will be contained in all active short supports, so at most l variables are in the relevant partition of varsBySupport, and the loop body will be executed O(l) times.\nLemma 5.4. After initialisation, Procedure 3 always has at least one active short support or a variable domain is empty.\nProof. Suppose the opposite. The algorithm is invoked each time a literal in an active short support is pruned, therefore to delete all active short supports they must all contain one literal x 7\u2192 v. If all active short supports contain variable x, then all values in the domain\nof x are not implicitly supported and must be explicitly supported. Therefore v must be the last remaining value in D(x). Now to prune x 7\u2192 v empties the domain and we have a contradiction.\nDown a branch, this causes O(sl) calls to ShortGAC-variableUpdate, on Line 7. Each call to ShortGAC-variableUpdate takes O(d) time because there may be d \u2212 1 invalid literals or d explicitly supported literals in zeroLits. Other time spent in this procedure is charged to processing short supports, or to pruning domains. Therefore in the top-down analysis the cost is O(sld).\nOverall, the time complexity is O(s(l + f) + ndf + sld), a tighter bound in some cases than the one given in the section above. For example, a SAT clause has s = n, f = n, l = 1 and d = 2, giving a time complexity of O(n2) for a branch of search."}, {"heading": "5.5 Instantiation of findNewSupport", "text": "Similarly to GAC-Schema (Bessie\u0300re & Re\u0301gin, 1997), ShortGAC must be instantiated with a findNewSupport function. The function takes a valid literal, and returns a support if one exists, otherwise returns Null. One way to do this is to write a specialist findNewSupport function for each constraint. We do this in each of the empirical case studies below. In each case, the findNewSupport function is much simpler than a propagator for the same constraint. We use Lemma 3.4 to build the findNewSupport functions, which reduces the task to finding satisfying tuples of simple constraints like x < y and x = y.\nThe alternative is to write a generic version of findNewSupport for the case where all short supports are given as a list. We now detail two generic instantiations of findNewSupport for lists, and in our case studies below we compare them with the specialist functions."}, {"heading": "5.5.1 findNewSupport-List", "text": "We provide a generic instantiation named findNewSupport-List (Procedure 5) that takes a list of short supports for each literal (supportList), including both the explicit and implicit short supports for that literal. This is analogous to the Positive instantiation of GACSchema (Bessie\u0300re & Re\u0301gin, 1997). FindNewSupport-List has persistent state: listPos, an array of integers indexed by variable and value, initially 0. This indicates the current position in the supportList. The algorithm simply iterates through the list of supports, seeking one where all literals are valid. ListPos is not backtracked, with the consequence that when the end of the list is reached, we cannot fail immediately and must search again from the start back to listPos. Down a branch of the search tree, any particular element of the list may be looked at more than once. However, this algorithm is optimal in both time and space across the search tree (Gent, 2012). This surprising result is achieved by amortizing the cost across all branches. Practically, using listPos stops the algorithm always starting from the first element of the list, and it seems to be a good tradeoff between avoiding provably unnecessary work and doing too much data structure maintenance.\nA constraint-specific findNewSupport can sometimes find shorter supports than findNewSupport-List. This is because a specific findNewSupport can take advantage of current domains whereas the supportList may only contain supports given the initial domains. For example, if the constraint becomes entailed, the specific findNewSupport can return the\nRequire: x, v, supportList 1: for all j \u2208 {listPos[x, v]. . .(supportList[x, v].size-1)} do 2: sup \u2190 supportList[x, v, j] 3: if all literals in sup are valid then 4: listPos[x, v] \u2190 j 5: return sup 6: for all j \u2208 {0 . . .listPos[x, v]\u22121} do 7: sup \u2190 supportList[x, v, j] 8: if all literals in sup are valid then 9: listPos[x, v] \u2190 j 10: return sup 11: return Null\nProcedure 5: findNewSupport-List: findNewSupport(x, v). The first block searches from the location of the previous support to the end of the support list. If it is unsuccessful the search restarts from the start of the list in the second block. This circular approach removes the need to backtrack listPos.\nempty support whereas the list version we have presented cannot. We exploit this fact in Case Study 3 below."}, {"heading": "5.5.2 findNewSupport-NDList", "text": "The list instantiation has two major disadvantages. First, it can be inefficient because it is unable to skip over sets of invalid tuples. The literature contains many solutions to this problem in the context of full-length supports, for example binary search (Lecoutre & Szymanek, 2006) or tries (Gent, Jefferson, Miguel, & Nightingale, 2007). Second, it can require a large amount of memory. For each short support S, there are potentially nd pointers to S, because there is a pointer to it for each literal that S implicitly supports.\nIn this section we give a second generic list instantiation based on NextDifference lists (Gent et al., 2007). We have a single list (named supportList) containing all short supports (indexed by an integer), and a second list named NDList where for each support s =supportList[j], for each literal in the support s[k], NDList[j][k] is the index of the next support that does not contain literal s[k]. Thus, when searching the list, the algorithm is able to jump over sets of short supports that all contain the same invalid literal. The version of findNewSupport for NextDifference lists is given in Procedure 6.\nThis approach solves both of the problems with the list instantiation: it is able to jump over sets of invalid short supports, and usually requires substantially less memory. In fact it it is optimal in space (unlike the list instantiation): given t short supports of length at most l, the NextDifference list is O(tl). However it uses only one list of supports, therefore it can spend time searching through short supports that do not support the desired literal."}, {"heading": "5.6 Literals of Assigned Variables", "text": "Suppose ShortGAC discovers a new support S that contains a literal x 7\u2192 v, and x is assigned to v. Since x can take no value other than v, it is sound to remove x 7\u2192 v from S and save the overhead of adding it. We apply this minor optimisation in all cases when using ShortGAC, and also in all cases when using HaggisGAC (described in Section 6). How-\nRequire: x, v, supportList, NDList 1: j \u2190 listPos[x, v] 2: while j < supportList.size do 3: sup \u2190 supportList[j] 4: nextDiff \u2190 NDList[j] 5: for k \u2208 {0 . . . sup.size\u2212 1} do 6: (y 7\u2192 b)\u2190 sup[k] 7: if b /\u2208 D(y) or (x = y and v 6= b) then 8: j \u2190 nextDiff [k] {Jump to next short support where y is assigned a different value.} 9: continue while loop at Line 2 10: listPos[x, v] \u2190 j 11: return sup 12: j \u2190 0 13: while j < listPos[x, v] do 14: sup \u2190 supportList[j] 15: nextDiff \u2190 NDList[j] 16: for k \u2208 {0 . . . sup.size\u2212 1} do 17: (y 7\u2192 b)\u2190 sup[k] 18: if b /\u2208 D(y) or (x = y and v 6= b) then 19: j \u2190 nextDiff [k] {Jump to next short support where y is assigned a different value.} 20: continue while loop at Line 13 21: listPos[x, v] \u2190 j 22: return sup 23: return Null\nProcedure 6: findNewSupport-NDlist: findNewSupport(x, v)\never this optimisation cannot be used with HaggisGAC-Stable (described in Section 8) because that algorithm retains active supports as it backtracks, and after backtracking the literal x 7\u2192 v may no longer be assigned.\n6. HaggisGAC: Dealing with Both Full-Length and Strict Short Supports\nWe now introduce HaggisGAC. We show that it has better theoretical properties than ShortGAC. Furthermore, experiments show it runs substantially faster in many cases on strict short supports than ShortGAC (which is specialised for strict short supports), and substantially faster on full-length supports than GAC-Schema."}, {"heading": "6.1 Introduction and Motivating Example", "text": "ShortGAC is designed to exploit the concept of implicit support, but has some inefficiencies when dealing with explicit supports and especially full-length supports. Consider for example the constraint AllDifferentExceptZero, in which the constraint is that all non-zero values in the array must be different, but that zero may occur freely. This constraint might be used, for example, in a timetabling problem where classes taking place in different rooms must be different, but we use zero to represent a room being unused and this can occur multiple times. Suppose we have AllDifferentExceptZero([w, x, y, z]), each variable with initial domain {0, 1, 2, 3}. Supports for the constraint are full-length supports in which every\nnon-zero value is different, or any three variables equalling zero where the last variable may take any value. Suppose we execute ShortGAC and reach the following situation:\nSupports: A: w 7\u2192 0, x 7\u2192 2, y 7\u2192 3, z 7\u2192 1 B: w 7\u2192 0, x 7\u2192 3, y 7\u2192 2, z 7\u2192 1 C: w 7\u2192 3, x 7\u2192 0, y 7\u2192 1, z 7\u2192 2 D: x 7\u2192 0, y 7\u2192 0, z 7\u2192 0 E: w 7\u2192 0, x 7\u2192 1, y 7\u2192 2, z 7\u2192 3\nsupportListPerLit: Variable Value w x y z\n0 {A,B,E} {C,D} {D} {D} 1 {} {E} {C} {A,B} 2 {} {A} {B,E} {C} 3 {C} {B} {A} {E}\nsupportsPerVar: 4 5 5 5 numSupports: 5\nNotice that the lack of explicit supports for w 7\u2192 1 and w 7\u2192 2 is acceptable because we have supportsPerVar[w] = 4 < numSupports = 5. Now suppose the literal y 7\u2192 0 is deleted by some other constraint. This causes support D to be deleted, causing the following state:\nSupports: A: w 7\u2192 0, x 7\u2192 2, y 7\u2192 3, z 7\u2192 1 B: w 7\u2192 0, x 7\u2192 3, y 7\u2192 2, z 7\u2192 1 C: w 7\u2192 3, x 7\u2192 0, y 7\u2192 1, z 7\u2192 2 E: w 7\u2192 0, x 7\u2192 1, y 7\u2192 2, z 7\u2192 3\nsupportListPerLit: Variable Value w x y z\n0 {A,B,E} {C} \u00d7 {} 1 {} {E} {C} {A,B} 2 {} {A} {B,E} {C} 3 {C} {B} {A} {E}\nsupportsPerVar: 4 4 4 4 numSupports: 4\nAt this point ShortGAC iterates through the zeroLits lists for all variables where supportsPerVar = numSupports, in this case all four variables. It will discover that we must find new supports for w 7\u2192 1, w 7\u2192 2 and z 7\u2192 0. However, this is inefficient for two reasons. First, we should not need to check zeroLits[z] to discover z 7\u2192 0, because the support list for z 7\u2192 0 became empty during the deletion of support D, so we could have discovered it then. Second, we should only need to look at zeroLits[w] because the deletion of D has caused w to lose its implicit support. We should not need to check zeroLits for x, y, z because these variables were not implicitly supported prior to D\u2019s deletion. Removing these two reasons for inefficiency is the motivation behind our development of HaggisGAC. In this example, it can focus directly on the literal z 7\u2192 0 and the set zeroLits[w] as the only literals potentially needing new support.\nThe fundamental problem with ShortGAC is that it cannot efficiently detect when a literal loses its last support. Every variable with no implicit support is checked every time any support is deleted, so ShortGAC can take O(nd) time to find a single literal that needs a new support or to discover that there is no such literal. To improve upon this, we wish\nHaggisGAC to be able to detect the loss of a literal\u2019s last explicit support in time O(1), and the loss of a variable\u2019s last implicit support in time O(1). Perhaps surprisingly, both these goals are achievable by the use of data structures already existing in ShortGAC."}, {"heading": "6.2 Finding Literals With No Support Efficiently", "text": "Of the two types of support, detecting when the last explicit support for a literal is lost is the simpler task. When we delete a support, Procedure 2 iterates through the literals in a short support. For each literal it removes a ShortSupportCell from the corresponding supportListPerLit and updates data structures appropriately. If the list is empty \u2013 tested at Line 5 of Procedure 2 \u2013 the literal has lost its last explicit support. We now add this literal to a scratch list of literals which have lost their last explicit support: we describe below how we process the scratch list. The additional cost is O(1) when we detect an empty list. Because we are inside an existing test, there is zero additional cost when the literal has not lost its last support. This contrasts with ShortGAC which tests (in Procedure 4) every variable with no implicit support, for a worst case cost of O(n) even when no literal has lost its last explicit support.\nThe more subtle task is to detect when a variable (and thus all literals involving it) has lost its last implicit support. The reason this is more difficult is that we are seeking variables that are not involved in the support being deleted, but in Procedure 2 we iterate through the literals that are in the support being deleted. The variables we seek are those x which have supportsPerVar[x] = numSupports after the support deletion, while they had supportsPerVar[x] < numSupports before the support deletion. (Variables that have supportsPerVar[x] = numSupports both before and after the deletion have no implicit support now, but did not lose implicit support because of this deletion.) Fortunately, our existing maintenance of data structures happens to compact exactly these variables into a particular region of varsBySupport, so we can find them very easily and efficiently. The compaction happens through the sequence of calls to the Procedure swap made by Procedure 2. We first show a worked example and we then prove the general properties we need.\nIn Figure 1, we suppose there are 11 variables in a constraint, there are currently 8 supports, and we are deleting a support involving variables x1, x2, x3, z1, z2 and z3, with\nthe literals deleted in an arbitrary order from top (start) to bottom (finish). Before we start, the z variables already have supportsPerVar = numSupports = 8; variables x and y have supportsPerVar = 7; and variables w have supportsPerVar = 6. As we process literals in deleteSupport, pairs of variables are swapped (marked by boxes in each line) and the boundaries move between cells (marked by vertical lines) of variables with equal supportsPerVar. At the end, w and x variables still have supportsPerVar = 6 < numSupports = 7. The z variables have supportsPerVar=numSupports both before and after deletion. The only variables that have lost their last implicit support are the y variables. The crucial point is that at the end they lie precisely between the final boundary between 6 and 7 supports (from i = 5), and the initial boundary between 7 and 8 supports (from i = 8). The following simple results show that variables losing their last implicit support are always compacted in a similar way.\nLemma 6.1. Suppose, before we delete a support S, that numSupports = p (and so numSupports = p\u2212 1 afterwards). For a variable x to lose its last implicit support, it has p\u2212 1 explicit supports both before and after the deletion of S.\nProof. If x initially has fewer than p\u22121 explicit supports, then x has more than one implicit support and deleting S removes at most one of these. If x initially has p explicit supports, then it is involved in S (since it is involved in all supports) and so has no implicit support to lose. Hence, x must initially have p \u2212 1 explicit supports and one implicit support and S must be that one implicit support. Therefore after the deletion of S, x has p\u2212 1 explicit supports and no implicit supports.\nLemma 6.2. We set p as in Lemma 6.1, i as the value of supportNumLowIdx[p] when deleteSupport is called, and j as the value of supportNumLowIdx[p \u2212 1] when deleteSupport exits. When deleteSupport finishes, the variables that lost their last implicit support during the call to deleteSupport are exactly the set of variables at indices in the range [j, i) in varsBySupport.\nProof. All variables with no implicit supports when deleteSupport exits lie at index j or greater in varsBySupport. This establishes the lower bound on the index range.\nAny variable z that has no implicit support at the start of the call must have p explicit supports and so must be at index i or higher. z must be in the support being deleted, because it is in all supports. When z is updated by deleteSupport, it is always swapped with the variable at index supportNumLowIdx[p]. The index supportNumLowIdx[p] only increases during deleteSupport, so z stays at index i or higher throughout. Thus the variables from index i upwards at the finish are a permutation of those at the start, meaning that variables which lost their last implicit support must be in the range [j, i). Finally, any variable in the range [j, i) has no implicit support at the end of the call (as it is at index j or above) but had an implicit support at the start (as it is before i). Therefore all and only variables which lost their last implicit support lie at indices in the range [j, i).\nFrom Lemma 6.2, after we run deleteSupport it is trivial to enumerate all variables which have lost their last implicit support as a result. They are exactly the variables varsBySupport[k] for k = j, j+1, ...i\u22121 with i and j as defined in the Lemma. Enumerating this list is the only additional work over that already done by Procedure 2, so we have:\nCorollary 6.3. Given a constraint on n variables, the additional work to identify variables which have lost their last implicit support is O(1) for each such variable where there are some, and O(1) if there are none.\nProof. We have already argued the case where there are variables which have lost implicit support. If there are no such variables, there is still O(1) work to check that the range is empty.\nThis low level of complexity contrasts very favourably with ShortGAC. When a support is deleted, Procedure 4 iterates over all variables with numSupports explicit supports. In the worst case this is O(n) work even if no variable has lost its last implicit support, compared to the O(1) work that we now have. We now move on to the details of incorporating these optimisations into a full suite of procedures for maintaining GAC.\n6.3 HaggisGAC: Details\nTwo issues complicate the implementation of HaggisGAC compared with ShortGAC. First, the Lemmas above depend on all literals in a support being deleted in a single pass. Therefore, instead of acting immediately on finding a literal with no supports, we keep a list of literals with lost supports for later treatment. Second, we now have two cases in which we might detect lost support \u2013 when the lost support is explicit or implicit \u2013 compared to the single case in ShortGAC, where all lost supports are detected in the same way.\nWe introduce two simple data structures for storing literals and variables that have lost explicit or implicit support as we find them.\nlitsLostExplicitSupport is a set containing literals that have lost their final explicit support and are not supported implicitly.\nvarsLostImplicitSupport is a set containing variables that have lost their final implicit support.\nWe have to adapt the deleteSupport procedure from Procedure 2. The new version is shown as Procedure 7. When we find a literal which has no explicit support, we immediately check if it has an implicit support instead (Line 8). If it does not, then we add it to the set litsLostExplicitSupport for later processing to find a new support or delete it. Variables which have no implicit support are detected after all literals have been deleted. This is done by lines 15-16, which are justified by Lemma 6.2.\nThe new propagate procedure is shown in Procedure 8. Like the earlier Procedure 3, we first delete all supports involving the literal to be deleted, but the rest of the procedure is very different. We first iterate through all literals which lost their last explicit support, and then the variables which lost their last implicit support.\nFor the lost explicit supports, we call HaggisGAC-literalUpdate (Procedure 9). This procedure has no analogue in ShortGAC, but is straightforward. The only point of interest is that we still check whether a literal is supported, even though it was only added to litsLostExplicitSupport if it was not. The reason is that some support found by an unrelated call to findNewSupport might also support this literal. If so we are done, but if not then Procedure 9 calls findNewSupport. If a new support is found it is added, but if not then we have to prune the literal as being no longer supported.\nRequire: Short Support sup 1: oldIndex \u2190 supportNumLowIdx[numSupports] 2: for all (x 7\u2192 v) \u2208 sup do 3: Remove sup from supportListPerLit[x 7\u2192 v] 4: if supportListPerLit[x 7\u2192 v] = {} then 5: detachTrigger(x,v) 6: if (x 7\u2192 v) 6\u2208 zeroLits[x] then 7: Add (x 7\u2192 v) to zeroLits[x] 8: if supportsPerVar[x] = numSupports then 9: Add (x 7\u2192 v) to litsLostExplicitSupport 10: sPV \u2190 supportsPerVar[x] 11: swap(x, varsBySupport[sPV]) 12: supportNumLowIdx[sPV] \u2190 supportNumLowIdx[sPV]+1 13: supportsPerVar[x]\u2190 sPV\u22121 14: numSupports-15: for all i \u2208 {supportNumLowIdx[numSupports] . . . oldIndex \u2212 1} do 16: Add varsBySupport[i] to varsLostImplicitSupport\nProcedure 7: HaggisGAC-DeleteSupport: (sup). One subtlety is that we must add (x 7\u2192 v) to zeroLits (line 7) even if we also add it to litsLostExplicitSupport (line 9). The only case where this matters is that we seek and find a new implicit support, i.e. not containing x 7\u2192 v, but this is later lost. At the later point Procedure 10 requires x 7\u2192 v to be in zeroLits because x 7\u2192 v might still have no explicit support.\nRequire: x 67\u2192 v (where v has been pruned from domain of x) 1: litsLostExplicitSupport\u2190 {} 2: varsLostImplicitSupport\u2190 {} 3: while supportListPerLit[x 7\u2192 v] 6= {} do 4: sup\u2190 first element of supportListPerLit[x 7\u2192 v] 5: deleteSupport(sup) 6: for all (y 7\u2192 b) \u2208 litsLostExplicitSupport do 7: HaggisGAC-literalUpdate(y 7\u2192 b) 8: for all z \u2208 varsLostImplicitSupport do 9: HaggisGAC-variableUpdate(z)\nProcedure 8: HaggisGAC-Propagate: propagate(x 67\u2192 v)\nFor variables with lost implicit supports, we call HaggisGAC-variableUpdate (Procedure 10), which is similar to Procedure 4. The differences are that the return statements from Procedure 4 are omitted; we check at every iteration whether a new implicit support has been found for x and if so exit the loop; and we do not remove x 7\u2192 v from zeroLits if a new explicit support has been found, allowing this to be done lazily in a later call at Line 5.\nWe gain efficiency over ShortGAC for two reasons. First, variableUpdate is only called for variables that have just lost implicit support. Second, there is no outer loop in HaggisGAC-Propagate which must be restarted when a new support is found, as there is in Procedure 3. If we write m for the number of variables which have lost their last implicit support, we have reduced the worst case number of calls to variableUpdate from HaggisGAC-Propagate from O(n2d) where n is the arity of the constraint to m. Since m \u2264 n and m can often be much smaller than n or even zero, this is a significant gain.\nRequire: x 7\u2192 v, where last explicit support of x 7\u2192 v has been deleted 1: if v \u2208 D(x) and supportsPerVar[x] = numSupports and\nsupportListPerLit[x 7\u2192 v] = {} then 2: sup \u2190 findNewSupport(x, v) 3: if sup = Null then 4: prune(x 7\u2192 v) 5: else 6: addSupport(sup)\nProcedure 9: HaggisGAC-literalUpdate(x 7\u2192 v)\nRequire: variable x 1: for all (x 7\u2192 v) \u2208 zeroLits[x] do 2: if supportsPerVar[x] < numSupports then 3: return 4: if supportListPerLit[x 7\u2192 v] 6= {} then 5: Remove (x 7\u2192 v) from zeroLits[x] 6: else 7: if v \u2208 D(x) then 8: sup\u2190 findNewSupport(x 7\u2192 v) 9: if sup = Null then 10: prune(x 7\u2192 v) 11: else 12: addSupport(sup)\nProcedure 10: HaggisGAC-variableUpdate(x)"}, {"heading": "6.4 Dealing Efficiently With Full-length Supports", "text": "When a full-length support is added, ShortGAC increments numSupports and supportsPerVar for every variable. Since we are only interested in the condition numSupports = supportsPerVar[x], a full-length support cannot change this status for any variable. Therefore we can save overheads in the case where we add a full-length support. This is achieved through a case split in HaggisGAC\u2019s versions of addSupport and deleteSupport: if a support is full length we do not update numSupports, supportsPerVar, and related data structures. Note that the test we apply is not that the final support is of arity n, but the initial one before the omission of any assigned literals as the optimisation is correct even if assigned literals are omitted. We omit the pseudocode for this optimisation, as the changes are straightforward. This optimisation often improves performance on instances with all full-length supports by 20%, and has no important effect on our other instances with runtimes all within \u00b12.5% with or without it. This optimisation is also applicable to ShortGAC, but we did not implement it in that case because it does not address the key inefficiency that algorithm has, i.e. the repeated checking of variables which cannot have lost their last implicit support. This does not affect our experimental results dramatically: in most cases we found that the improved performance of HaggisGAC was larger than this optimisation provides.\n7. Experimental Evaluation of ShortGAC and HaggisGAC\nThe Minion solver 0.12 (Gent, Jefferson, & Miguel, 2006a) was used for our experiments, with the only changes being the additional propagators. In all experiments, all the compared methods maintain GAC. Therefore, the solver explores the same search space in each case. Since the number of nodes searched is invariant, we compare the rate of search exploration, measured in search nodes per second.6\nWe used an 8-core machine with 2.27GHz Intel Xeon E5520 CPUs and 12GB memory, running Ubuntu Linux. Where possible we ran 12 processes in parallel. For each combination of problem instance and propagator, we report the median of 11 runs.7 In some cases it is not possible to run 12 processes in parallel because they exceed 1GB memory. For these, we ran just one process at a time, and we report the median of 5 runs. These instances are marked with a \u2018\u2021\u2019 in the tables of results. If one method exceeded 1GB, we sometimes ran other comparable methods in series as well. This allows consistent comparison between List and NDList, and different propagation algorithms. It also means that \u2018\u2021\u2019 in the tables does not necessarily indicate that the method uses more than 1GB memory. We find the median to be a very robust measure of performance, for reasons described in Appendix B.\nIn all cases, we imposed a time limit of one hour, and a limit of 1,000,000 search nodes (whichever is first). To avoid short runs when the solver can find a solution easily, we searched for all solutions. We report complete cpu times, i.e. we have not attempted to measure the time attributable to the given propagator and we include any initialisation. This has the advantage that we automatically take account of all factors affecting runtime, including aspects (e.g. cache usage) that we may not realise affect runtime. It does however mean that our results tend to understate the difference between methods being studied.\nFor each case study, we implemented a findNewSupport method for ShortGAC and HaggisGAC specific to the constraint. We also used the generic list instantiation (Section 5.5.1) and the Next-Difference List instantiation (Section 5.5.2) for comparison where possible. We compare ShortGAC and HaggisGAC with the special-purpose propagator (when available).\nWe also compare with ShortGAC-Long (ShortGAC with full-length supports), with HaggisGAC-Long, and with GAC-Schema (Bessie\u0300re & Re\u0301gin, 1997) as the closest equivalent algorithm without strict short supports. We discuss GAC-Schema further in Section 7.4. GAC-Schema, ShortGAC-Long and HaggisGAC-Long use the same (constraint-specific) findNewSupport as ShortGAC, and subsequently extend the short support to full length using the minimum value for each extra variable.\nIn each case, the constraint can be compactly represented as a disjunction. Therefore we compare ShortGAC and HaggisGAC with Constructive Or. The algorithm used is based on Lagerkvist and Schulte\u2019s (2009), without the rule for entailment detection. The\n6. Source code for the solver with the three algorithms is available at http://www.cs.st-andrews.ac. uk/~pn/haggisgac-source.tgz and problem instances and experimental results at http://www.cs. st-andrews.ac.uk/~pn/haggisgac-data-instances.tgz. 7. In preliminary investigations, we found that running 12 processes in parallel gives consistent cpu time results, and this consistency is improved by taking the median.\nimplementation in Minion is fully incremental: each disjunct is propagated incrementally down a branch of search and backtracked as the search backtracks.8\nWe do not compare with table constraints, as described by (for example) Gent et al. (2007), because the constraints are too large. For example, the smallest element constraints reported below have 638 allowed tuples, making it impossible even to generate and store the list of allowed tuples.\nTo aid comparison between HaggisGAC and ShortGAC, in addition to the tables we compare them graphically in Figure 2. This figure shows the relative speedup (or in some cases slowdown) of using HaggisGAC compared with ShortGAC."}, {"heading": "7.1 Case Study 1: Element", "text": "We use the quasigroup existence problem QG3 (Colton & Miguel, 2001) to evaluate ShortGAC and HaggisGAC on the element constraint. The problem class has one parameter n, specifying the size of an n\u00d7 n table (qg) of variables with domains {0 . . . n\u2212 1}. Rows, columns and one diagonal have GAC allDifferent constraints, following Colton and Miguel\u2019s model. The element constraints represent the QG3 property that (i \u2217 j) \u2217 (j \u2217 i) = i (where i and j are members of the quasigroup and \u2217 is the quasigroup operator). This translates as \u2200i, j : element(qg, aux[i, j], i), and aux[i, j]= n \u00d7 qg[i, j] + qg[j, i], where aux[i, j] has domain {0 . . . n\u00d7 n\u2212 1}.\n8. Personal communication with Pascal Van Hentenryck indicated that there is an unpublished optimisation of Constructive Or whereby some disjuncts need not be propagated in some cases. We did not implement this optimisation.\nFor the constraint element(X, y, z), the findNewSupport method for ShortGAC returns tuples of the form \u3008xi 7\u2192 j, y 7\u2192 i, z 7\u2192 j\u3009, where i is an index into the vector X and j is a common value of z and xi. ShortGAC-list has all supports of this form. For Constructive Or, we used (x0 = z \u2227 y = 0) \u2228 (x1 = z \u2227 y = 1) \u2228 \u00b7 \u00b7 \u00b7 .\nWe compare ShortGAC and HaggisGAC with the special-purpose Watched Element propagator (Gent et al., 2006b), GAC-Schema and Constructive Or. Table 1 presents our results on QG3. Of the general purpose methods, using short supports (with Specific, List or NDList instantiations) is dramatically better than any alternative. For example at n = 10, even the HaggisGAC-List method (which is slower than HaggisGAC-Specific) is more than 450 times faster than Constructive Or, the best of the other methods.\nShortGAC-Long runs about 10\u201320% faster than GAC-Schema for n = 6 to 8, slower at n = 9 but better at n = 10 because GAC-Schema uses more memory. Recall that they both use the same findNewSupport method, so this is a fair comparison of how efficiently they exploit these supports. This is in contrast to our results reported previously (Nightingale et al., 2011), where ShortGAC was about half the speed of GAC-Schema. Two substantial differences account for the improvement: the improved data structures described in Section 5; and that we remove assigned literals from the full-length supports as described in Section 5.6. HaggisGAC-Long is consistently faster than both ShortGAC-Long and GAC-Schema.\nWhile much faster than methods using full-length supports, list variants HaggisGACList and HaggisGAC-NDList are both slower than HaggisGAC-Element (and the same is true for ShortGAC). This is to be expected as neither is specialised to the Element constraint, and both have to deal with data structures containing the lists of tuples. Of the two list variants, the NDList variant runs much more slowly. However, its memory usage is, as we expected, much less than HaggisGAC-List. It used less than half as much memory at n = 6, improving to almost 10 times less memory at n = 10.\nHaggisGAC-Element is approximately twice as fast as ShortGAC-Element on these instances. We believe this is because two variables are in all short supports \u2013 the index and result variables \u2013 meaning that they are always supported explicitly. As can be seen\nin Figure 2, List, NDList and Long instantiations of HaggisGAC are also faster than the same instantiations of ShortGAC but by a smaller margin. The special purpose Watched Element propagator is the fastest method, being 3.6 times faster when n = 10. Watched Element also appears to be scaling better as n increases. Constructive Or is much slower than all the methods that exploit strict short supports, however it is faster than HaggisGAC-Long. Overall it is clear that exploiting strict short supports is very beneficial compared with other general purpose methods."}, {"heading": "7.2 Case Study 2: Lex-ordering", "text": "We use the BIBD problem to evaluate ShortGAC and HaggisGAC on the lexicographic ordering constraint. The lex constraint is placed on both the rows and columns, to perform the \u2018Double Lex\u2019 symmetry breaking method (Flener et al., 2002). We use the BIBD model given by Frisch, Hnich, Kiziltan, Miguel, and Walsh (2002), and the GACLex propagator given by Frisch, Hnich, Kiziltan, Miguel, and Walsh (2006). We use BIBDs with the parameter values (4n+ 3, 4n+ 3, 2n+ 1, 2n+ 1, n).\nFor the constraint lexleq(X, Y ) on arrays X and Y , we define mxi = min(Dom(xi)) and myi = max(Dom(yi)). The findNewSupport method for ShortGAC finds the lowest index i \u2208 {0 . . . n} such that mxi < myi, or i = n. The case i = n arises when X cannot be lexicographically less than Y , so a support is sought for X = Y . If i < n, the support contains xi 7\u2192 mxi, yi 7\u2192 myi. For each index j < i, if mxj = myj , then the short support contains xj 7\u2192 mxj , yj 7\u2192 myj otherwise there is no valid support and Null is returned.\nThe lex constraint on two arrays of length n and domain size d has more than dn short supports in any short support set, because all assignments where the two arrays are equal satisfy the constraint and cannot be reduced. ShortGAC-List and ShortGAC-NDList\nare not practical for any substantial constraint so we omit them from the comparison. For Constructive Or we use the following representation with n+ 1 disjuncts: (x0 < y0)\u2228 (x0 = y0 \u2227 x1 < y1) \u2228 \u00b7 \u00b7 \u00b7 , including the final case where all pairs are equal.\nTable 2 presents the results of our experiments on non-list based methods with values of n from 3 to 24. It is clear that the best method is the special-purpose GACLex propagator, with HaggisGAC coming second. On this problem, HaggisGAC and ShortGAC perform similarly. HaggisGAC and ShortGAC are by far the best general purpose methods. For the largest instances they run about 1.5 times slower than the special purpose method, while outperforming the next best method by almost 300 times. Again, HaggisGAC-Long and ShortGAC-Long outperform GAC-Schema, and on these instances the difference is even more marked.\nHaggisGAC-Long can be substantially faster than ShortGAC-Long, as can be seen in Figure 2: this is largely explained by the optimisation of Section 6.4.\nTo summarise, these experiments on the Lex constraint clearly show the benefit of HaggisGAC and ShortGAC compared with other general-purpose propagation methods. Their speed even approaches that of the special purpose GACLex propagator."}, {"heading": "7.3 Case Study 3: Rectangle Packing", "text": "The rectangle packing problem (Simonis & O\u2019Sullivan, 2008) (with parameters n, width and height) consists of packing all squares from size 1 \u00d7 1 to n \u00d7 n into the rectangle of size width \u00d7 height . This is modelled as follows: we have variables x1 . . . xn and y1 . . . yn, where (xi, yi) represents the Cartesian coordinates of the lower-left corner of the i \u00d7 i square. Domains of xi variables are {0 . . .width \u2212 i}, and for yi variables are {0 . . . height \u2212 i}. Variables are branched on in decreasing order of i (to place the largest square first), with xi before yi, smallest value first. The only type of constraint is non-overlap of squares i and j: (xi + i \u2264 xj) \u2228 (xj + j \u2264 xi) \u2228 (yi + i \u2264 yj) \u2228 (yj + j \u2264 yi). Minion does not have the special-purpose non-overlap constraint (Simonis & O\u2019Sullivan, 2008), so we only report a comparison of general-purpose methods. For the experiment we used the optimum rectangle sizes reported by Simonis and O\u2019Sullivan.\nThe domains of xn and yn are reduced to break flip symmetries as described by Simonis and O\u2019Sullivan (2008). Our focus is performance of the non-overlap constraint, and so we did not implement the commonly-used implied constraints.\nThe findNewSupport function for ShortGAC is as follows. If any of the four disjuncts above are entailed given the current domains, return the empty support (indicating entailment). Otherwise, return a support with two literals to satisfy one of the four disjuncts. The list used for ShortGAC-List and ShortGAC-NDList has all supports of size 2.\nIn Table 3, we compare HaggisGAC and ShortGAC with other general purpose methods. We can see that HaggisGAC is the fastest method, with ShortGAC second. HaggisGAC-List and HaggisGAC-NDList (as well as ShortGAC-List and ShortGACNDList) performed well compared to GAC-Schema and Constructive Or. However at n = 20, HaggisGAC-List consumes 971MB memory and HaggisGAC-NDList 496MB, and with n > 20 it was not possible to run these methods with 12 processes in parallel. Interestingly, the performance of the two List variants of HaggisGAC is reversed from Case Study 1: here, NDList is significantly faster than List in most cases. As expected,\nNDList used less memory, though less dramatically than before. It used from about 30% to 50% of the memory of HaggisGAC-List.\nOf the other methods, all are always at least 10 times slower than HaggisGAC. HaggisGAC-Long is faster than GAC-Schema in all cases. Also ShortGAC-Long is faster than GAC-Schema on all instances except 27-47-148 (this contradicts the result we previously reported (Nightingale et al., 2011), and some explanation of this is given in the first case study).\nTable 3 shows that HaggisGAC (with the SquarePack instantiation) is substantially faster than ShortGAC on most of the instances, with the exception of n = 23 and n = 26 where ShortGAC is slightly faster. When compared with ShortGAC for List, NDList, and Long instantiations in Figure 2, we see that HaggisGAC is mostly between 10 and 50% faster. In summary, these results very clearly show the benefits of using strict short supports.\n7.4 Comparing HaggisGAC With GAC-Schema\nAcross all the above experiments, HaggisGAC-Long runs significantly faster than GACSchema \u2013 from a minimum of about 20% faster to more than three times faster \u2013 even though our code contains overhead for dealing with strict short supports. We compared memory usage across all experiments, and found very similar performance across all instances. We found that HaggisGAC-Long uses less than 5% more memory on all except BIBD instances, and on BIBD it uses less than 17% more memory than GAC-Schema.\nHowever, the comparison has been only on functional instantiations of full-length supports, and on constraints that admit strict short supports. In this section, we broaden the comparison by using the list instantiations rather than functional ones, and using problem instances that have been used previously for comparing table constraints.\nWe compared against GAC-Schema because it is very similar to HaggisGAC and ShortGAC conceptually. All three algorithms maintain a list of supports for each literal, which is updated and backtracked during search. GAC-Schema was carefully implemented\nfollowing the pseudocode of the original paper (Bessie\u0300re & Re\u0301gin, 1997). While some code is shared among all three algorithms, each was optimised independently. For example, GAC-Schema has a different implementation of supportListPerLit, named SC in (Bessie\u0300re & Re\u0301gin, 1997), which is specialised to full-length supports.\nIn contrast to GAC-Schema, other table constraint propagators such as STR2 (Lecoutre, 2011) and MDDC (Cheng & Yap, 2010) are entirely different to HaggisGAC, and it would be difficult to create truly comparable implementations of them.\nWe report on the use of HaggisGAC-List only, because it searches for supports in the same way as GAC-Schema (with one difference we discuss below.) We used the structured instances from Gent et al. (2007), except the Semigroup class. In addition, we used Car Sequencing instances from Nightingale (2011), specifically model B instances numbered 60-79. These instances contain a large number of ternary table constraints.\nFigure 3 shows that HaggisGAC-List is almost always faster than GAC-Schema on these problems. For BIBDs it is not clear which algorithm is better. HaggisGAC is always at least marginally faster on the Sports Scheduling, Prime Queens and Graceful Graphs instances, in most cases in the range 10-20% faster. HaggisGAC is substantially faster on Car Sequencing. To seek new supports, HaggisGAC calls Procedure 5, and when it finds a new support it stores the index of it in listPos. HaggisGAC does not backtrack listPos as described in Section 5.5.1. GAC-Schema is similar, but it does backtrack listPos, and it ensures optimality down a branch of search by iterating only from listPos to the end of the list (Bessie\u0300re & Re\u0301gin, 1997). Profiling shows that GAC-Schema is hindered by backtracking listPos (by block-copying memory) on Car Sequencing, where there are a very large number of table constraints (2000 on instance 60) and large domains (some of size\nover 1000). Alternative memory management techniques might speed up GAC-Schema, so we do not claim that HaggisGAC is fundamentally 10 times faster than GAC-Schema."}, {"heading": "7.5 Results Summary", "text": "To summarise the three case studies, HaggisGAC does indeed outperform ShortGAC on many instances, sometimes by more than two times and commonly by more than 25%. ShortGAC is only rarely faster, but only on one instance by as much as 10%. Overall, in our experiments, HaggisGAC is clearly a better algorithm than ShortGAC. Furthermore, HaggisGAC and ShortGAC perform very well compared to Constructive Or and GACSchema, a result which validates the idea of strict short supports.\nFinally, we have shown experimentally that HaggisGAC can outperform GAC-Schema on problems containing only full-length supports. We discuss why this should be in Appendix C as it is not a major focus of this paper."}, {"heading": "8. Backtrack Stability and Short Supports", "text": "Within a search tree, HaggisGAC often spends significant time backtracking data structures. Reducing or eliminating backtracking can improve efficiency. For example MAC-6 and MAC-7 can be much more efficient (in both space and time) if backtracking is avoided (Re\u0301gin, 2005). In this section we present a new algorithm that saves time by not deleting short supports on backtrack, and saves memory by bounding the total number of stored short supports (including those on the backtrack stack).\nThe new algorithm requires that short supports have the backtrack stability property. A short support is backtrack stable iff it remains a short support after backtracking (Section 3.2).\nIn our three case studies, we find that the short supports we construct for the element and lex constraints are backtrack stable, but for rectangle packing they are not. For rectangle packing, we generate the empty support when the constraint is entailed. The empty support is not backtrack stable unless the constraint is entailed at the root node of search.\nWe introduce the algorithm HaggisGAC-Stable where we know all short supports are backtrack stable. The key change is that we do not delete supports when we backtrack past their point of introduction. Because they are stable, they are still correct at ancestors of the node they were introduced at. This can save time over the previous algorithms, since we sometimes need to do no work at all on backtracking. Also, as we show below, we obtain very tight limits on space usage of stored supports.\nTo present HaggisGAC-Stable, we introduce the notion of a prime support of a deleted literal. A prime support of a deleted literal is a support (either explicit or implicit) which will be a valid support for that literal when the literal is restored on backtracking. The invariant we maintain after deleting a literal is that either we have labelled a deleted support on the backtrack stack as its prime support or the literal\u2019s variable is currently implicitly supported. With this invariant, we guarantee that when we backtrack to the point where the literal is restored, it must be supported again: either by the prime support which we can restore, or by the known implicit support.\nThe task of finding the prime support for a literal naturally splits into three cases. The simplest case is that HaggisGAC-Stable itself deletes literals when not able to find a\nnecessary new support. The prime support is then just the implicit or explicit support whose deletion caused the fruitless search for a new support.\nThe second case is where a literal is pruned by some other constraint or the search procedure, and the pruned literal had an explicit support in this constraint. All its explicit supports must be deleted as no longer valid, and we can label an arbitrary one to be the literal\u2019s prime support: we simply choose the last one to be deleted.\nThe third case is unfortunately complicated. It is that a literal is pruned outside the current constraint, and the literal had an implicit support but no explicit support. This is difficult precisely because the pruned literal does not have any link to its implicit support. Providing and maintaining such a link throughout search would negate the efficiencies we have gained. Our solution to this problem is to be lazy. The variable of the pruned literal is implicitly supported. While we have any implicit support for the variable, we are maintaining the invariant described above. So when the literal is pruned we need do nothing in this case. We only need do any work when this variable loses its last implicit support, if it ever does. When this happens, an invalid literal which had no explicit support must by definition be in the relevant zeroLits list. Whereas previously we ignored invalid literals when iterating through zeroLits, we now can label the deleted implicit support as a prime support for the invalid literal.\nWe will show in Lemma 8.1 that HaggisGAC-Stable stores at any time at most O(z) supports, where z is the total number of literals. This can save a lot of memory because HaggisGAC and ShortGAC may store O(z2) supports, because there can be O(z) deletions of literals down a branch, and for each deletion a new set of O(z) supports may be stored. Our experiments later will show that this difference in memory usage can be significant in practice. At its most effective, memory usage was reduced by 20 times.\n8.1 Details of HaggisGAC-Stable\nIn HaggisGAC-Stable, we have to control with great care the deletion and restoration of supports, instead of (as in the rest of this paper) simply reversing the addition or deletion of a support at a node by respectively deleting or adding it back when we backtrack past that node. In short we never delete an active support on backtracking, and only add back in a deleted support if it is a prime support for a literal with no current active support.\nWhen deleting a support, we setup a counter numPrimeSupported. It is initially 0, and is incremented each time we find the support is a prime support. When the propagation algorithm finishes, for any support with numPrimeSupported = 0, the support can be destroyed and its space reclaimed. Otherwise, we place numPrimeSupported new pairs on the backtrack stack. Each pair consists of the deleted support and the literal it is a prime support for. On backtracking, when we pop a pair, we first check if any current support already supports the literal. If so, we simply decrement numPrimeSupported, and if this reduces to 0, again we reclaim the support\u2019s space. If the literal is not supported, then we restore the support via a call to addSupport. In this way all literals the support was prime for are now guaranteed to be supported.\nA relatively minor difference is that when we iterate through zeroLits we now delete invalid literals from zeroLits. We can do this because on backtracking we can restore them into\nRequire: x 7\u2192 v, where last explicit support of x 7\u2192 v has been deleted 1: if v \u2208 D(x) then 2: if supportsPerVar[x] = numSupports and supportListPerLit[x 7\u2192 v] = {} then 3: sup \u2190 findNewSupport(x, v) 4: if sup = Null then 5: prune(x 7\u2192 v) 6: increment lastSupportPerLit[x 7\u2192 v].numPrimeSupported 7: push \u3008x 7\u2192 v, lastSupportPerLit[x 7\u2192 v]\u3009 onto BacktrackStack 8: else 9: addSupport(sup) 10: else 11: increment lastSupportPerLit[x 7\u2192 v].numPrimeSupported 12: push \u3008x 7\u2192 v, lastSupportPerLit[x 7\u2192 v]\u3009 onto BacktrackStack\nProcedure 11: HaggisGAC-Stable-literalUpdate: (x 7\u2192 v). In comparison to Procedure 9, we update numPrimeSupported and BacktrackStack.\nzeroLits because they are on the backtrack stack, and doing so enables the space complexity result in Lemma 8.1.\nHaggisGAC-Stable is similar to HaggisGAC. Where appropriate we simply describe differences to save space. The Procedure HaggisGAC-Stable-Propagate is almost the same as Procedure 8, calling the backtrack stable variants of deleteSupport, literalUpdate (Procedure 11) and variableUpdate (Procedure 12). In addition, at the end of this algorithm we destroy and reclaim the space for any deleted support for which numPrimeSupported = 0. The Procedure HaggisGAC-Stable-DeleteSupport (called with support S) is also very similar to its predecessor, Procedure 7, with some additions. First, it initialises numPrimeSupported for S to 0. Second, we have new data structures lastSupportPerLit for a deleted literal x 7\u2192 a and lastSupportPerVar for a variable x. In terms of Procedure 7, these are both assigned to S at Line 9 and Line 16 (respectively). Note these assignments do not make S a prime support: this will be checked later.\nProcedure 11 is analogous to Procedure 9 but with enough differences that we show it in detail here. It identifies prime supports, and when necessary increments numPrimeSupported and pushes invalid literal/support pairs onto the backtrack stack. We also present Procedure 12 in detail, the analogue to Procedure 10. Again it identifies prime supports, increments the counter and adds pairs to BacktrackStack. One difficult case arises, from Line 17. Here, x 7\u2192 a has been pruned, but externally to this constraint. If it had been pruned by Procedure 11, it would not be in zeroLits. When x 7\u2192 a is restored on backtracking we still need to make sure it has support. Since it has no explicit support (it is in zeroLits), its last support must be this implicit support we are deleting. Therefore we store the support on BacktrackStack. A minor change to note is that we remove literals from zeroLits, at Lines 13 and 19.\nWhenever a new search node (including the root) is entered, a Null is pushed onto the BacktrackStack. This is used as a marker for the procedure HaggisGAC-StableBacktrack (Procedure 13), which processes literal/support pairs until it reaches the Null. This restores prime supports for literals being put back into the domain on backtracking, but only if no other support is currently known. If the numPrimeSupported counter for\nRequire: variable x 1: for all (x 7\u2192 v) \u2208 zeroLits[x] do 2: if supportsPerVar[x] < numSupports then 3: return 4: if supportListPerLit[x 7\u2192 v] 6= {} then 5: Remove (x 7\u2192 v) from zeroLits[x] 6: else 7: if v \u2208 D(x) then 8: sup\u2190 findNewSupport(x, v) 9: if sup = Null then 10: prune(x 7\u2192 v) 11: increment lastSupportPerVar[x].numPrimeSupported 12: push \u3008x 7\u2192 v, lastSupportPerVar[x]\u3009 onto BacktrackStack 13: Remove (x 7\u2192 v) from zeroLits[x] 14: else 15: addSupport(sup) 16: else 17: increment lastSupportPerVar[x].numPrimeSupported 18: push \u3008x 7\u2192 v, lastSupportPerVar[x]\u3009 onto BacktrackStack 19: Remove (x 7\u2192 v) from zeroLits[x]\nProcedure 12: HaggisGAC-Stable-variableUpdate: (x). This is similar to Procedure 10 with the addition of maintenance of numPrimeSupported and BacktrackStack.\n1: while the top element of BacktrackStack is not Null do 2: pop \u3008x 7\u2192 v, sup\u3009 from BacktrackStack 3: if sup has not yet been restored then 4: if supportsPerVar(x) = numSupports and supportListPerLit[x 7\u2192 v] = {} then 5: HaggisGAC-Stable-AddSupport(sup) 6: else 7: {Another support exists for x 7\u2192 v} 8: decrement sup.numPrimeSupported 9: if sup.numPrimeSupported = 0 then\n10: destroy sup and reclaim space 11: if supportListPerLit[x 7\u2192 v] = {} then 12: Add (x 7\u2192 v) to zeroLits[x] 13: pop Null from BacktrackStack\nProcedure 13: HaggisGAC-Stable-Backtrack. Performs backtracking using BacktrackStack.\na support becomes zero, the support can be destroyed as it is no longer necessary. Note that literals are put back into zeroLits if necessary at Line 12, reversing their deletion in Procedure 12.\nWe cannot use the optimisation described in Section 5.6, of deleting literals in supports for variables that are assigned, because this may break the backtrack stability property.\nHowever, we retain the optimisation of Section 6.4 for full-length supports, but again omit pseudocode showing this in the interest of focusing on the essential aspects of the algorithms.\n8.2 Improved Space Complexity of HaggisGAC-Stable\nOur approach improves the space complexity of HaggisGAC-Stable compared with HaggisGAC, as the following lemma shows.\nLemma 8.1. For a constraint involving z literals, at most 2z supports are stored, either as active or as deleted supports on the backtrack stack.\nProof. We define a function from supports to literals. If the support is still active, it was found from a call to findNewSupport for a specific literal, and we map the support to this literal. Similarly, if the support is on the backtrack stack, then it is in a pair with at least one literal it is a prime support for. Map the support to any one of these literals. Every stored support falls into one of these two categories, because if a support is deleted and it is not put onto the backtrack stack, its space is reclaimed. No three supports are mapped to the same literal because:\n\u2022 For valid literals, findNewSupport will not be called again if an existing active support exists for that literal.\n\u2022 For invalid literals, each literal appears in a pair on the backtrack stack at most twice. The only case where a literal appears as often as twice is that a literal with a prime support already on the stack is processed when its variable loses its last implicit support. In this case, the literal must be in zeroLits, and the newly deleted implicit support will be added to the backtrack stack for this literal. But this can only happen once because we delete the literal from zeroLits the first time it happens.\nThus the number of supports is bounded above by 2z.\nThe bound 2z in Lemma 8.1 would improve to z if we maintained zeroLits eagerly instead of lazily, but at the expense of higher overheads elsewhere.\n9. Experimental Evaluation of HaggisGAC-Stable\nWe compare HaggisGAC-Stable to HaggisGAC using the same experimental setup as in Section 7. As well as tables of results, we provide a graphical comparison of runtimes of HaggisGAC-Stable and HaggisGAC in Figure 4, and of their memory usage in Figure 5.\nTable 4 and Figure 4 shows results for the instances of Section 7.1. We present all four instantiations of HaggisGAC-Stable, along with the fastest instantiation of HaggisGAC, the Watched Element special-purpose propagator, and Constructive Or (which was faster than GAC-Schema in Table 1). For element, we observe about a 10% slowdown, and again a slight slowdown for both List variants. For full-length supports, we see almost identical performance.\nTable 5 shows the results for instances of Section 7.2. HaggisGAC-Stable-Lex performs slightly worse than HaggisGAC-Lex, though is in fact never more than 10% worse and very slightly faster on the largest instances. This might be because supports found\ndeep in search are likely to contain more literals than supports found earlier, meaning that when we backtrack the longer supports are retained instead of replaced by the earlier and more efficient short supports. If so, this advantage disappears for the Long variants. Indeed, HaggisGAC-Stable-Long performs much better than HaggisGAC-Long, and the improvement increases with n, being about 4.5 times for n = 24.\nThe Rectangle Packing instantiation of ShortGAC described in Section 7 generates an empty support when the constraint becomes entailed, causing all variables to be implicitly supported from that point on. This empty support is not backtrack stable, so cannot be used with HaggisGAC-Stable. We implemented a new backtrack stable variant of findNewSupport, in which the empty support is not returned, but is otherwise the same as before. The List and Long variants are not affected because they do not return the empty support in this case. In Table 6, we use the instances from Section 7.3. Results show significant slowdowns by using backtrack stability for rectangle packing, more than 2 times for n = 24. This is probably because of the inability to return the empty support. On the other hand, we see speedups of about 50% for the list variants, and in some cases a factor of 2 speedup for full-length supports.\nWe see in Figure 5 that the memory usage goes down greatly when stability is used on full-length supports, possibly contributing to speedups in these cases. The greatest reductions are in the case of element, in two cases more than 20 times less memory. On the other hand, there is no significant reduction in memory usage in any non-long variant.\nWe also tested HaggisGAC-Stable against GAC-Schema as in Section 7.4. This gave very similar performance to HaggisGAC and was therefore better than GAC-Schema: we omit detailed results. There was no significant memory advantage compared to HaggisGAC, with the Stable variant saving less than 25%. We therefore do not seem to gain the advantages we saw earlier from backtrack stability on full-length supports.\nWe conclude that backtrack stability can speed up HaggisGAC significantly, and greatly reduce memory usage when using full-length supports. However, care must be used, because backtrack stability can be harmful if insisting on backtrack stability increases the size of returned supports."}, {"heading": "10. Related Work", "text": "Our use of counters to count supports is inspired by AC4 (Mohr & Henderson, 1986). There has been some study of compressing the tuples of a constraint into a compact data structure in order to make propagation more efficient. For example, Gent et al. (2007) used tries, and Cheng and Yap (2010) applied MDDs. There has also been extensive study of searching the list of tuples to find the first valid tuple. Approaches include binary search (Lecoutre & Szymanek, 2006), trie search (Gent et al., 2007), and approaches similar to skip lists such as NDLists (Gent et al., 2007) and hologram-tuples (Lhomme, 2004; Lhomme & Re\u0301gin, 2005). All these techniques are orthogonal to the main focus of this paper because they assist in finding supports, not in maintaining the set of active supports. We have adapted NDLists to contain short supports in Section 5.5.2; it may also be interesting to adapt some of the other approaches.\nSTR2 maintains a sparse set of all valid satisfying tuples of the constraint (Lecoutre, 2011). Updated variable domains are computed from this set each time the algorithm is\ninvoked. There is no concept of maintaining support, or seeking new support for a literal. It would be interesting to investigate adapting STR2 to handle short supports. This would result in an entirely different algorithm to the ones presented in this paper, possibly with complementary strengths.\nThe MDD propagator MDDC (Cheng & Yap, 2010) maintains an MDD incrementally during search. The MDD is a compressed representation of the satisfying tuples of the constraint. The time complexity of MDDC is linear in the initial size of the MDD, therefore the degree of compression is vital to the efficiency of the algorithm. In some cases, if a constraint is amenable to strict short supports, it will also compress well into an MDD (given an appropriate variable ordering). For example, the lex constraint compresses well partly because (given the variable order x1, y1, x2, y2, . . .) the constraint can be satisfied by assigning a prefix of the variables. Lex is amenable to short supports for the same reason. However, some constraints have a small set of short supports but cannot be compressed effectively into an MDD. Suppose we have a disjunction of equality constraints for each pair of n variables of domain size d. After n\u2212 1 variables, the MDD must have dCn\u22121 states.\nAnother property of MDD compression might indicate an interesting direction for future work. Lex also compresses well into an MDD because multiple assignments to a prefix of the variables lead to the same subsequent vertex (e.g. {x1 7\u2192 1, y1 7\u2192 1} and {x1 7\u2192 2, y1 7\u2192 2}). This is something that our short support algorithms are not currently able to exploit.\nKatsirelos and Walsh (2007) proposed a different generalisation of support, named ctuples. A c-tuple contains a set of values for each variable in the scope of the constraint. Any valid tuple whose values are drawn from the c-tuple is a (full-length) support. Katsirelos and Walsh give an outline of a modified version of GAC-Schema which directly stores c-tuples. They also present experiments based on a different propagator, GAC3.1r, demonstrating a modest speed improvement for c-tuples compared to conventional full-length supports. When a c-tuple contains all values of some variable, it will nevertheless be recorded (in SC) as support for each value individually (Katsirelos & Walsh, 2007). The algorithm has no concept of implicit support.\nIn the context of Constructive Or, Lhomme (2003) observed that a support for one disjunct A will support all values of any variable not contained in A. The concept is similar to a short support albeit less general, because the length of the supports is fixed to the length of the disjuncts. He presented a non-incremental Constructive Or algorithm for two disjuncts.\nOur algorithms have a similar flavour to GAC-Schema (Bessie\u0300re & Re\u0301gin, 1997), so it was natural to compare them to GAC-Schema. However there are other GAC algorithms such as GAC2001/3.1 (Bessie\u0300re et al., 2005) and it would be interesting to compare these to our algorithms."}, {"heading": "11. Conclusions", "text": "We have introduced and detailed three general purpose propagation algorithms for short supports. They each can either be given a specialised function to find new supports for each constraint, or used with a function that accepts an explicit list of short supports. Where strict short supports are available, all three algorithms perform very well, and provide much\nbetter performance than the general purpose methods GAC-Schema and Constructive Or. This shows the value of using strict short supports.\nThe first algorithm we studied was ShortGAC, for which we described improvements compared to our earlier report on this algorithm (Nightingale et al., 2011). We identified a significant inefficiency with ShortGAC when dealing with explicit supports. We introduced a new algorithm, HaggisGAC which corrects this flaw, has better theoretical complexities, and performs much better than ShortGAC in our experiments. In three case studies, HaggisGAC is far faster than the general purpose methods. In the best case it even achieved speeds more than 90% of that of a special purpose propagator. Perhaps remarkably, while able to deal with both strict short and full-length supports, HaggisGAC outperformed ShortGAC on strict short supports and GAC-Schema on full-length supports, i.e. the cases which those algorithms are respectively specialised for.\nOur third algorithm, HaggisGAC-Stable, can retain supports on backtracking. It can be less effective than HaggisGAC if it invalidates the use of certain strict short supports, but it can also be significantly faster on problems with only full-length supports, and reduce memory usage greatly in those cases.\nAll the proposed algorithms are excellent for propagating disjunctions of constraints. In all experiments with disjunctions we found our algorithms to be faster than Constructive Or and GAC-Schema by at least an order of magnitude, and up to three orders of magnitude.\nTo summarise, we have shown the value of the explicit use of strict short supports in general purpose propagation algorithms for generalised arc consistency. When strict short supports are available, exploiting them yields orders of magnitude improvements for generic propagation algorithms. In some cases, we even found that a generic algorithm can come close to the performance of a specialised propagator. Previously, short supports do not seem to have been recognised as important in their own right. Our overall contribution is to correct this and focus on short supports as first class objects."}, {"heading": "Acknowledgments", "text": "We would like to thank anonymous reviewers and Bilal Syed Hussain for their comments, and EPSRC for funding this work through grants EP/H004092/1 and EP/E030394/1.\nAppendix A. Comparison of ShortGAC and ShortGAC-IJCAI\nIn Section 4, we noted that we have optimised data structures and algorithms for ShortGAC, compared with our previous presentation (Nightingale et al., 2011). To demonstrate that these are indeed improvements, we compared the two implementations of ShortGAC on the three case studies used in this paper. We use the name ShortGAC-IJCAI for the previous version. We are not quoting results from our previous work (Nightingale et al., 2011), but have rerun all experiments using the environment described in Section 7. We also updated the codebase to Minion 0.12 instead of Minion 0.10 in our earlier paper. For each algorithm and instance, we report nodes searched per second and peak memory use.\nTable 7 shows results for the instances of Section 7.1. It is clear from the results that ShortGAC makes much better use of memory and is also faster than ShortGAC-IJCAI\non these instances. Table 8 shows the results for instances of Section 7.2. As with Element, ShortGAC makes better use of memory and is faster than ShortGAC-IJCAI, although improvements are not as great as before. In Table 9, we use the instances from Section 7.3. As in the previous two case studies, ShortGAC is consistently better in both speed and memory use. We conclude that the algorithms and data structures used in this paper are indeed superior to those we used previously (Nightingale et al., 2011)."}, {"heading": "Appendix B. Median Absolute Deviation of our Experiments", "text": "In our experiments we report the median of either 11 or 5 runs. To assess how robust the median was as a measure we looked, for each combination of instances and algorithm, at the median absolute deviation (MAD), i.e. the median of the absolute difference of data points from the median. Figure 6 shows the MAD for all algorithm/instance combinations as a fraction of the median for that case. This shows 511 algorithm/instance combinations we tested (including some combinations not reported in detail in this paper). For nodes per second, the maximum MAD we found is always less than 15% of the median, with a worst case of 14.5%. This was HaggisGAC-Long for n = 9 in Table 1. There were only four more cases with MAD above 8% of the median. Figures for memory usage were even more consistent, with only two cases (at 6.3% and 6.1%) showing MAD above 5% of the median and and no others above 2%. Any major conclusions we draw do not regard a 10% change of behaviour between one method and another as significant, and therefore we can say that the median is a robust measure of performance.\nAppendix C. Comparison of GAC-Schema and HaggisGAC\nWe showed in Section 7.4 that HaggisGAC outperforms GAC-Schema when dealing with full-length supports. This is despite the fact that HaggisGAC has small overheads for dealing with strict short supports even when none exist. We now discuss briefly why this may be so.\nGAC-Schema has the concept of current supports \u2013 each literal has one current support, which is one of the active supports that contain the literal. There is an additional data structure S(\u03c4). For each active support \u03c4 , S(\u03c4) is a list of all literals that have \u03c4 as their current support. Hence when \u03c4 is invalidated, GAC-Schema finds a new current support for each literal in S(\u03c4) (or deletes the literal). In HaggisGAC we dispensed with this entirely. The sign that a literal needs a new support is not that it lost its current support, but that its support list (supportListPerLit) is empty. There is a small potential saving from not maintaining S(\u03c4).\nA second, possibly more important, difference is that GAC-Schema is more eager than HaggisGAC. When a literal x 7\u2192 v loses its current support, GAC-Schema will check if other active supports containing x 7\u2192 v are valid, an O(n) operation for each one. If they are all invalid, GAC-Schema then calls findNewSupport. If this returns Null then x 7\u2192 v is deleted. HaggisGAC does none of this, avoiding completely the cost of checking validity. This is safe because if every support is invalid, the literal deletion from each support will cause a call to deleteSupport and the last will result in the empty list, causing a call to findNewSupport. Both approaches are correct, but GAC-Schema\u2019s is wasteful because it performs unnecessary validity checks. However, one cannot guarantee time saving, because GAC-Schema can perform deletions sooner, possibly affecting the way the propagator interacts with the other propagators."}], "references": [{"title": "The complexity of reasoning with global", "author": ["C. Bessi\u00e8re", "E. Hebrard", "B. Hnich", "T. Walsh"], "venue": "constraints. Constraints,", "citeRegEx": "Bessi\u00e8re et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bessi\u00e8re et al\\.", "year": 2007}, {"title": "Arc consistency for general constraint networks: Preliminary results", "author": ["C. Bessi\u00e8re", "R\u00e9gin", "J.-C"], "venue": "In Proceedings IJCAI", "citeRegEx": "Bessi\u00e8re et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Bessi\u00e8re et al\\.", "year": 1997}, {"title": "An optimal coarse-grained arc consistency algorithm", "author": ["C. Bessi\u00e8re", "R\u00e9gin", "J.-C", "R.H.C. Yap", "Y. Zhang"], "venue": "Artificial Intelligence,", "citeRegEx": "Bessi\u00e8re et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Bessi\u00e8re et al\\.", "year": 2005}, {"title": "An MDD-based generalized arc consistency algorithm for positive and negative table constraints and some global", "author": ["K.C.K. Cheng", "R.H.C. Yap"], "venue": "constraints. Constraints,", "citeRegEx": "Cheng and Yap,? \\Q2010\\E", "shortCiteRegEx": "Cheng and Yap", "year": 2010}, {"title": "Constraint generation via automated theory formation", "author": ["S. Colton", "I. Miguel"], "venue": "In Proceedings CP", "citeRegEx": "Colton and Miguel,? \\Q2001\\E", "shortCiteRegEx": "Colton and Miguel", "year": 2001}, {"title": "Breaking row and column symmetries in matrix models", "author": ["P. Flener", "A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "J. Pearson", "T. Walsh"], "venue": "In Proceedings CP", "citeRegEx": "Flener et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Flener et al\\.", "year": 2002}, {"title": "Global constraints for lexicographic orderings", "author": ["A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "T. Walsh"], "venue": "In Proceedings CP", "citeRegEx": "Frisch et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Frisch et al\\.", "year": 2002}, {"title": "Propagation algorithms for lexicographic ordering constraints", "author": ["A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "T. Walsh"], "venue": "Artificial Intelligence,", "citeRegEx": "Frisch et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Frisch et al\\.", "year": 2006}, {"title": "An optimality result on maintaining list pointers during backtracking search", "author": ["I.P. Gent"], "venue": "Tech. rep. CIRCA preprint 2012/1, University of St Andrews.", "citeRegEx": "Gent,? 2012", "shortCiteRegEx": "Gent", "year": 2012}, {"title": "Minion: A fast scalable constraint solver", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "In Proceedings ECAI", "citeRegEx": "Gent et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2006}, {"title": "Watched literals for constraint propagation in Minion", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "In Proceedings CP", "citeRegEx": "Gent et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2006}, {"title": "Data structures for generalised arc consistency for extensional constraints", "author": ["I.P. Gent", "C. Jefferson", "I. Miguel", "P. Nightingale"], "venue": "In Proceedings AAAI", "citeRegEx": "Gent et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2007}, {"title": "Handbook of Constraint Programming (Foundations of Artificial Intelligence), chap. Symmetry in Constraint Programming, pp. 329\u2013376", "author": ["I.P. Gent", "K. Petrie", "Puget", "J.-F"], "venue": null, "citeRegEx": "Gent et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gent et al\\.", "year": 2006}, {"title": "Implementing logical connectives in constraint programming", "author": ["C. Jefferson", "N.C.A. Moore", "P. Nightingale", "K.E. Petrie"], "venue": "Artificial Intelligence,", "citeRegEx": "Jefferson et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Jefferson et al\\.", "year": 2010}, {"title": "A compression algorithm for large arity extensional constraints", "author": ["G. Katsirelos", "T. Walsh"], "venue": "In Proceedings CP", "citeRegEx": "Katsirelos and Walsh,? \\Q2007\\E", "shortCiteRegEx": "Katsirelos and Walsh", "year": 2007}, {"title": "Applications of ultrasonography in the reproductive management of dux magnus gentis venteris saginati", "author": ["A. King", "L. Cromarty", "C. Paterson", "J. Boyd"], "venue": "Veterinary record,", "citeRegEx": "King et al\\.,? \\Q2007\\E", "shortCiteRegEx": "King et al\\.", "year": 2007}, {"title": "STR2: optimized simple tabular reduction for table constraints", "author": ["C. Lecoutre"], "venue": "Constraints, 16 (4), 341\u2013371.", "citeRegEx": "Lecoutre,? 2011", "shortCiteRegEx": "Lecoutre", "year": 2011}, {"title": "Generalized arc consistency for positive table constraints", "author": ["C. Lecoutre", "R. Szymanek"], "venue": "In Proceedings CP", "citeRegEx": "Lecoutre and Szymanek,? \\Q2006\\E", "shortCiteRegEx": "Lecoutre and Szymanek", "year": 2006}, {"title": "A fast arc consistency algorithm for n-ary constraints", "author": ["O. Lhomme", "R\u00e9gin", "J.-C"], "venue": "In Proceedings AAAI", "citeRegEx": "Lhomme et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Lhomme et al\\.", "year": 2005}, {"title": "An efficient filtering algorithm for disjunction of constraints", "author": ["O. Lhomme"], "venue": "Proceedings CP 2003, pp. 904\u2013908.", "citeRegEx": "Lhomme,? 2003", "shortCiteRegEx": "Lhomme", "year": 2003}, {"title": "Arc-consistency filtering algorithms for logical combinations of constraints", "author": ["O. Lhomme"], "venue": "Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems (CP-AI-OR\u201904), pp. 209\u2013224.", "citeRegEx": "Lhomme,? 2004", "shortCiteRegEx": "Lhomme", "year": 2004}, {"title": "On reading sketch maps", "author": ["A.K. Mackworth"], "venue": "Reddy, R. (Ed.), IJCAI, pp. 598\u2013606. William Kaufmann.", "citeRegEx": "Mackworth,? 1977", "shortCiteRegEx": "Mackworth", "year": 1977}, {"title": "Automatic Symmetry Detection and Dynamic Symmetry Breaking for Constraint Programming", "author": ["C.D. Mears"], "venue": "Ph.D. thesis, Clayton School of Information Technology, Monash University.", "citeRegEx": "Mears,? 2009", "shortCiteRegEx": "Mears", "year": 2009}, {"title": "Arc and path consistency revisited", "author": ["R. Mohr", "T.C. Henderson"], "venue": "Artificial Intelligence,", "citeRegEx": "Mohr and Henderson,? \\Q1986\\E", "shortCiteRegEx": "Mohr and Henderson", "year": 1986}, {"title": "The extended global cardinality constraint: An empirical survey", "author": ["P. Nightingale"], "venue": "Artificial Intelligence, 175 (2), 586\u2013614.", "citeRegEx": "Nightingale,? 2011", "shortCiteRegEx": "Nightingale", "year": 2011}, {"title": "Exploiting short supports for generalised arc consistency for arbitrary constraints", "author": ["P. Nightingale", "I.P. Gent", "C. Jefferson", "I. Miguel"], "venue": "In Proceedings IJCAI", "citeRegEx": "Nightingale et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Nightingale et al\\.", "year": 2011}, {"title": "Automatic detection of variable and value symmetries", "author": ["Puget", "J.-F."], "venue": "Proceedings CP 2005, pp. 475\u2013489.", "citeRegEx": "Puget and J..F.,? 2005", "shortCiteRegEx": "Puget and J..F.", "year": 2005}, {"title": "Generalized arc consistency for global cardinality constraint", "author": ["R\u00e9gin", "J.-C."], "venue": "Proceedings AAAI 1996, pp. 209\u2013215.", "citeRegEx": "R\u00e9gin and J..C.,? 1996", "shortCiteRegEx": "R\u00e9gin and J..C.", "year": 1996}, {"title": "Maintaining arc consistency algorithms during the search without additional space cost", "author": ["R\u00e9gin", "J.-C."], "venue": "Proceedings CP 2005, pp. 520\u2013533.", "citeRegEx": "R\u00e9gin and J..C.,? 2005", "shortCiteRegEx": "R\u00e9gin and J..C.", "year": 2005}, {"title": "Implementing efficient propagation control. In Proceedings of TRICS: Techniques foR Implementing Constraint programming Systems, a conference workshop of CP", "author": ["C. Schulte", "G. Tack"], "venue": null, "citeRegEx": "Schulte and Tack,? \\Q2010\\E", "shortCiteRegEx": "Schulte and Tack", "year": 2010}, {"title": "Search strategies for rectangle packing", "author": ["H. Simonis", "B. O\u2019Sullivan"], "venue": "In Proceedings CP", "citeRegEx": "Simonis and O.Sullivan,? \\Q2008\\E", "shortCiteRegEx": "Simonis and O.Sullivan", "year": 2008}, {"title": "Constructive disjunction revisited", "author": ["J. W\u00fcrtz", "T. M\u00fcller"], "venue": "In Proceedings of the 20th Annual German Conference on Artificial Intelligence: Advances in Artificial Intelligence, KI", "citeRegEx": "W\u00fcrtz and M\u00fcller,? \\Q1996\\E", "shortCiteRegEx": "W\u00fcrtz and M\u00fcller", "year": 1996}], "referenceMentions": [{"referenceID": 16, "context": "1 (Bessi\u00e8re, R\u00e9gin, Yap, & Zhang, 2005), STR2 (Lecoutre, 2011) or MDDC (Cheng & Yap, 2010) are used.", "startOffset": 46, "endOffset": 62}, {"referenceID": 21, "context": "A property commonly established by constraint propagation algorithms is generalised arc consistency (GAC) (Mackworth, 1977).", "startOffset": 106, "endOffset": 123}, {"referenceID": 22, "context": "This has not inhibited research in exploiting symmetry, within which the automated detection of symmetry has become an important subarea (Mears, 2009; Puget, 2005): however we leave the automated construction of compact short support sets to future research.", "startOffset": 137, "endOffset": 163}, {"referenceID": 19, "context": "Many papers have been published in this area (W\u00fcrtz & M\u00fcller, 1996; Lhomme, 2003; Lagerkvist & Schulte, 2009; Jefferson, Moore, Nightingale, & Petrie, 2010).", "startOffset": 45, "endOffset": 156}, {"referenceID": 25, "context": "The details we present here are different from those we presented previously (Nightingale et al., 2011), as we have optimised the data structures and algorithms compared with our previous work.", "startOffset": 77, "endOffset": 103}, {"referenceID": 8, "context": "However, this algorithm is optimal in both time and space across the search tree (Gent, 2012).", "startOffset": 81, "endOffset": 93}, {"referenceID": 11, "context": "In this section we give a second generic list instantiation based on NextDifference lists (Gent et al., 2007).", "startOffset": 90, "endOffset": 109}, {"referenceID": 8, "context": "8 We do not compare with table constraints, as described by (for example) Gent et al. (2007), because the constraints are too large.", "startOffset": 74, "endOffset": 93}, {"referenceID": 25, "context": "This is in contrast to our results reported previously (Nightingale et al., 2011), where ShortGAC was about half the speed of GAC-Schema.", "startOffset": 55, "endOffset": 81}, {"referenceID": 5, "context": "The lex constraint is placed on both the rows and columns, to perform the \u2018Double Lex\u2019 symmetry breaking method (Flener et al., 2002).", "startOffset": 112, "endOffset": 133}, {"referenceID": 5, "context": "The lex constraint is placed on both the rows and columns, to perform the \u2018Double Lex\u2019 symmetry breaking method (Flener et al., 2002). We use the BIBD model given by Frisch, Hnich, Kiziltan, Miguel, and Walsh (2002), and the GACLex propagator given by Frisch, Hnich, Kiziltan, Miguel, and Walsh (2006).", "startOffset": 113, "endOffset": 216}, {"referenceID": 5, "context": "The lex constraint is placed on both the rows and columns, to perform the \u2018Double Lex\u2019 symmetry breaking method (Flener et al., 2002). We use the BIBD model given by Frisch, Hnich, Kiziltan, Miguel, and Walsh (2002), and the GACLex propagator given by Frisch, Hnich, Kiziltan, Miguel, and Walsh (2006). We use BIBDs with the parameter values (4n+ 3, 4n+ 3, 2n+ 1, 2n+ 1, n).", "startOffset": 113, "endOffset": 302}, {"referenceID": 30, "context": "The domains of xn and yn are reduced to break flip symmetries as described by Simonis and O\u2019Sullivan (2008). Our focus is performance of the non-overlap constraint, and so we did not implement the commonly-used implied constraints.", "startOffset": 78, "endOffset": 108}, {"referenceID": 25, "context": "Also ShortGAC-Long is faster than GAC-Schema on all instances except 27-47-148 (this contradicts the result we previously reported (Nightingale et al., 2011), and some explanation of this is given in the first case study).", "startOffset": 131, "endOffset": 157}, {"referenceID": 16, "context": "In contrast to GAC-Schema, other table constraint propagators such as STR2 (Lecoutre, 2011) and MDDC (Cheng & Yap, 2010) are entirely different to HaggisGAC, and it would be difficult to create truly comparable implementations of them.", "startOffset": 75, "endOffset": 91}, {"referenceID": 8, "context": ") We used the structured instances from Gent et al. (2007), except the Semigroup class.", "startOffset": 40, "endOffset": 59}, {"referenceID": 8, "context": ") We used the structured instances from Gent et al. (2007), except the Semigroup class. In addition, we used Car Sequencing instances from Nightingale (2011), specifically model B instances numbered 60-79.", "startOffset": 40, "endOffset": 158}, {"referenceID": 11, "context": "Approaches include binary search (Lecoutre & Szymanek, 2006), trie search (Gent et al., 2007), and approaches similar to skip lists such as NDLists (Gent et al.", "startOffset": 74, "endOffset": 93}, {"referenceID": 11, "context": ", 2007), and approaches similar to skip lists such as NDLists (Gent et al., 2007) and hologram-tuples (Lhomme, 2004; Lhomme & R\u00e9gin, 2005).", "startOffset": 62, "endOffset": 81}, {"referenceID": 20, "context": ", 2007) and hologram-tuples (Lhomme, 2004; Lhomme & R\u00e9gin, 2005).", "startOffset": 28, "endOffset": 64}, {"referenceID": 7, "context": "For example, Gent et al. (2007) used tries, and Cheng and Yap (2010) applied MDDs.", "startOffset": 13, "endOffset": 32}, {"referenceID": 3, "context": "(2007) used tries, and Cheng and Yap (2010) applied MDDs.", "startOffset": 23, "endOffset": 44}, {"referenceID": 16, "context": "STR2 maintains a sparse set of all valid satisfying tuples of the constraint (Lecoutre, 2011).", "startOffset": 77, "endOffset": 93}, {"referenceID": 19, "context": "In the context of Constructive Or, Lhomme (2003) observed that a support for one disjunct A will support all values of any variable not contained in A.", "startOffset": 35, "endOffset": 49}, {"referenceID": 2, "context": "1 (Bessi\u00e8re et al., 2005) and it would be interesting to compare these to our algorithms.", "startOffset": 2, "endOffset": 25}, {"referenceID": 25, "context": "The first algorithm we studied was ShortGAC, for which we described improvements compared to our earlier report on this algorithm (Nightingale et al., 2011).", "startOffset": 130, "endOffset": 156}, {"referenceID": 25, "context": "In Section 4, we noted that we have optimised data structures and algorithms for ShortGAC, compared with our previous presentation (Nightingale et al., 2011).", "startOffset": 131, "endOffset": 157}, {"referenceID": 25, "context": "We are not quoting results from our previous work (Nightingale et al., 2011), but have rerun all experiments using the environment described in Section 7.", "startOffset": 50, "endOffset": 76}, {"referenceID": 25, "context": "We conclude that the algorithms and data structures used in this paper are indeed superior to those we used previously (Nightingale et al., 2011).", "startOffset": 119, "endOffset": 145}], "year": 2013, "abstractText": "Special-purpose constraint propagation algorithms frequently make implicit use of short supports \u2014 by examining a subset of the variables, they can infer support (a justification that a variable-value pair may still form part of an assignment that satisfies the constraint) for all other variables and values and save substantial work \u2013 but short supports have not been studied in their own right. The two main contributions of this paper are the identification of short supports as important for constraint propagation, and the introduction of HaggisGAC, an efficient and effective general purpose propagation algorithm for exploiting short supports. Given the complexity of HaggisGAC, we present it as an optimised version of a simpler algorithm ShortGAC. Although experiments demonstrate the efficiency of ShortGAC compared with other general-purpose propagation algorithms where a compact set of short supports is available, we show theoretically and experimentally that HaggisGAC is even better. We also find that HaggisGAC performs better than GAC-Schema on full-length supports. We also introduce a variant algorithm HaggisGACStable, which is adapted to avoid work on backtracking and in some cases can be faster and have significant reductions in memory use. All the proposed algorithms are excellent for propagating disjunctions of constraints. In all experiments with disjunctions we found our algorithms to be faster than Constructive Or and GAC-Schema by at least an order of magnitude, and up to three orders of magnitude.", "creator": "TeX"}}}