{"id": "1404.4089", "review": {"conference": "aaai", "VERSION": "v1", "DATE_OF_SUBMISSION": "15-Apr-2014", "title": "On the Role of Canonicity in Bottom-up Knowledge Compilation", "abstract": "we illustrate the protocol governing bottom - centered compilation of knowledge bases, whoever is usually analyzed is alternative existence but a numerical function possessing different compilations using boolean operators ( usually considering an apply polynomial ). while such a standard apply function generally known as value for certain languages ( and. )., obdds ) and not function for others ( e. g., dnnf ), simpler existence for certain languages sounds unknown. applying the algebraic models designing recently conceived binary synthetic logical decision techniques ( sdds ), function comparison highly restricted apply function exists for unreduced sdds, whereas remains reserved for discrete ones ( i. e. nonlinear sdds ). both learn but open issue regarding this session and consider confirmation of its theoretical and practical applications. some of further tasks we report confirm the common wisdom on the problems between closed - up compilation, compiler canonicity and the choice of structured apply function.", "histories": [["v1", "Tue, 15 Apr 2014 21:43:41 GMT  (74kb,D)", "http://arxiv.org/abs/1404.4089v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["guy van den broeck", "adnan darwiche"], "accepted": true, "id": "1404.4089"}, "pdf": {"name": "1404.4089.pdf", "metadata": {"source": "META", "title": "On the Role of Canonicity in Bottom-up Knowledge Compilation", "authors": ["Guy Van den Broeck", "Adnan Darwiche"], "emails": ["guyvdb@cs.ucla.edu", "darwiche@cs.ucla.edu"], "sections": [{"heading": "Introduction", "text": "The Sentential Decision Diagram (SDD) is a recently proposed circuit representation of propositional knowledge bases (Darwiche 2011). The SDD is a target language for knowledge compilation (Selman and Kautz 1996; Darwiche and Marquis 2002), meaning that once a propositional knowledge base is compiled into an SDD, the SDD can be reused to answer multiple hard queries efficiently (e.g., clausal entailment or model counting).\nSDDs subsume Ordered Binary Decision Diagrams (OBDD) (Bryant 1986) and come with a tighter size bound (Darwiche 2011), while still being equally powerful as far as their polytime support for classical queries (e.g., the ones in Darwiche and Marquis (2002)). Moreover, SDDs are subsumed by d-DNNFs (Darwiche 2001), which received much attention over the last decade, for fault diagnosis (Elliott and Williams 2006), planning (Palacios et al. 2005), databases (Suciu et al. 2011), but most importantly for probabilistic inference (Chavira, Darwiche, and Jaeger 2006; Chavira and Darwiche 2008; Fierens et al. 2011). Even though SDDs are less succinct than d-DNNFs, they can be compiled bottom-up, just like OBDDs. For example, a clause can be compiled by disjoining the SDDs corresponding to its literals, and a CNF can be compiled by conjoining the SDDs corresponding to its clauses. This bottom-up compilation is implemented using the Apply function, which\ncombines two SDDs using Boolean operators.1 Bottomup compilation makes SDDs attractive for certain applications (e.g., probabilistic inference (Choi, Kisa, and Darwiche 2013)) and can be critical when the knowledge base to be compiled is constructed incrementally (see the discussion in Pipatsrisawat and Darwiche (2008)).\nAccording to common wisdom, a language supports bottom-up compilation only if it supports a polytime Apply function. For example, OBDDs are known to support bottom-up compilation and have traditionally been compiled this way. In fact, the discovery of SDDs was mostly driven by the need for bottom-up compilation, which was preceded by the discovery of structured decomposability (Pipatsrisawat and Darwiche 2008): a property that enables some Boolean operations to be applied in polytime. SDDs satisfy this property and stronger ones, leading to a polytime Apply function (Darwiche 2011). This function, however, assumes that the SDDs are unreduced (i.e., not canonical). For reduced SDDs, the existence of a polytime Apply function has been an open question since SDDs were first introduced (note, however, that both reduced and unreduced OBDDs are supported by a polytime Apply function).\nWe resolve this open question in this paper, showing that such an Apply function does not exist in general. We also pursue some theoretical and practical implications of this result, on bottom-up compilation in particular. On the practical side, we reveal an empirical finding that seems quite surprising: bottom-up compilation with reduced SDDs is much more feasible practically than with unreduced ones, even though the latter supports a polytime Apply function while the former does not. This finding questions common convictions on the relative importance of a polytime Apply in contrast to canonicity as desirable properties for a language that supports efficient bottom-up compilation. On the theoretical side, we show that certain transformations (e.g., conditioning) can lead to blowing up the size of reduced SDDs, while they don\u2019t for unreduced SDDs. Finally, we identify a subset of SDDs for which a polytime Apply exists even under reduction.\n1The Apply function (and its name) originated in the OBDD literature (Bryant 1986)\nar X\niv :1\n40 4.\n40 89\nv1 [\ncs .A\nI] 1\n5 A\npr 2\n01 4"}, {"heading": "Background", "text": "We will use the following notation for propositional logic. Upper-case letters (e.g., X) denote propositional variables and lower-case letters denote their instantiations (e.g., x). Bold letters represent sets of variables (e.g., X) and their instantiations (e.g., x). A literal is a variable or its negation. A Boolean function f(X) maps each instantiation x to > (true) or \u22a5 (false)."}, {"heading": "The SDD Representation", "text": "The Sentential Decision Diagram (SDD) is a newly introduced representation language for propositional knowledge bases (Darwiche 2011). Figure 1a depicts an SDD: pairedboxes p s are called elements and represent conjunctions (p \u2227 s), where p is called a prime and s is called a sub. Circles are called decision nodes and represent disjunctions of their child elements.\nAn SDD is constructed for a given vtree, which is a full binary tree whose leaves are variables; see for example Figure 1b. Every node in an SDD respects some vtree node (except for > and \u22a5). SDD literals respect the vtree leaf labeled with their variable. In Figure 1a, decision nodes are labeled with the vtree node they respect. Consider a decision node with elements p1 s1 , . . . , pn sn , and suppose that it respects a vtree node v which has variables X in its left subtree and variables Y in its right subtree. We are then guaranteed that each prime pi will only mention variables in X and that each sub si will only mention variables in Y. Moreover, the primes are guaranteed to represent propositional sentences that are consistent, mutually exclusive, and exhaustive. This type of decomposition is called an (X,Y)partition (Darwiche 2011). For example, the top decision node in Figure 1a has the following elements\n{(A \u2227B\ufe38 \ufe37\ufe37 \ufe38 prime , >\ufe38\ufe37\ufe37\ufe38 sub ), (\u00acA \u2227B\ufe38 \ufe37\ufe37 \ufe38 prime , C\ufe38\ufe37\ufe37\ufe38 sub ), (\u00acB\ufe38\ufe37\ufe37\ufe38 prime , D \u2227 C\ufe38 \ufe37\ufe37 \ufe38 sub )}, (1)\nwhich correspond to an (AB,CD)-partition of the function (A\u2227B)\u2228(B\u2227C)\u2228(C\u2227D). One can verify that the primes and subs of this partition satisfy the properties mentioned above.\nAn (X,Y)-partition is compressed if it has distinct subs, and an SDD is compressed if its (X,Y)-partitions are compressed. A Boolean function may have multiple (X,Y)-\npartitions, but the compressed partition is unique. Our example function has another (AB,CD)-partition, which is not compressed:\n{(A \u2227B,>), (\u00acA \u2227B,C), (A \u2227 \u00acB,D \u2227 C), (\u00acA \u2227 \u00acB,D \u2227 C)}. (2)\nAn uncompressed (X,Y)-partition can be compressed by merging all elements (p1, s), . . . , (pn, s) that share the same sub into one element (p1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn, s). Compressing (2) combines the two last elements into ([A \u2227 \u00acB] \u2228 [\u00acA \u2227 \u00acB], D \u2227 C) = (\u00acB,D \u2227 C), resulting in (1). This is the unique compressed (AB,CD)-partition.\nGiven a vtree, each Boolean function also has a unique compressed SDD, when this property is combined with either trimming or normalization properties (Darwiche 2011). These are weaker properties that mildly affect the size of an SDD. For example, a trimmed SDD contains no decision nodes of the form {(>, \u03b1)} or {(\u03b1,>), (\u00ac\u03b1,\u22a5)} (we can trim an SDD by replacing these nodes with \u03b1). Compressed and trimmed SDDs are canonical, and so are compressed and normalized SDDs (Darwiche 2011).\nOBDDs correspond precisely to SDDs that are constructed using a special type of vtree, called a right-linear vtree (Darwiche 2011). The left child of each inner node in these vtrees is a variable. With right-linear vtrees, compressed/trimmed SDDs correspond to reduced OBDDs, while compressed/normalized SDDs correspond to oblivious OBDDs (Xue, Choi, and Darwiche 2012) (reduced and oblivious OBDDs are also canonical). We will refer to compressed and trimmed SDDs as reduced SDDs and restrict our attention to them in the rest of the paper.\nThe size of an OBDD depends critically on the underlying variable order. Similarly, the size of an SDD depends critically on the vtree used (right-linear vtrees correspond to variable orders). Vtree search algorithms can sometimes find SDDs that are orders-of-magnitude more succinct than OBDDs found by searching for variable orders (Choi and Darwiche 2013). Such algorithms assume canonical SDDs, allowing one to search the space of SDDs by searching the space of vtrees."}, {"heading": "Queries and Transformations", "text": "SDDs are a strict subset of deterministic, decomposable negation normal form (d-DNNF). They are actually a strict\nAlgorithm 1 Apply(\u03b1, \u03b2, \u25e6) 1: if \u03b1 and \u03b2 are constants or literals then 2: return \u03b1 \u25e6 \u03b2 // result is a constant or literal 3: else if Cache(\u03b1, \u03b2, \u25e6) 6= nil then 4: return Cache(\u03b1, \u03b2, \u25e6) // has been computed before 5: else 6: \u03b3\u2190{} 7: for all elements (pi, si) in \u03b1 do 8: for all elements (qj , rj) in \u03b2 do 9: p\u2190Apply(pi, qj ,\u2227) 10: if p is consistent then 11: s\u2190Apply(si, rj , \u25e6) 12: add element (p, s) to \u03b3 13: (optionally) \u03b3 \u2190 Compress(\u03b3) // compression // get unique decision node and return it 14: return Cache(\u03b1, \u03b2, \u25e6)\u2190UniqueD(\u03b3)\nsubset of structured d-DNNF and, hence, support the same polytime queries supported by structured d-DNNF (Pipatsrisawat and Darwiche 2008); see Table 1. This makes SDDs as powerful as OBDDs in terms of their support for these queries.\nSDDs satisfy stronger properties than structured dDNNFs, allowing one, for example, to conjoin or disjoin two SDDs in polytime. Algorithm 1 shows the outline of an Apply function (Darwiche 2011) that takes two SDDs \u03b1 and \u03b2, and a binary Boolean operator \u25e6 (e.g., \u2227, \u2228, xor), and returns the SDD for \u03b1\u25e6\u03b2. This code assumes that the SDD is normalized instead of trimmed. The code for trimmed SDDs is similar, although a bit more detailed. Line 13 optionally compresses each partition, in order to return a compressed SDD. Without compression, this algorithm has a time and space complexity of O(nm), where n and m are the sizes of input SDDs (Darwiche 2011). This comes at the expense of losing canonicity. Whether a polytime complexity can be attained under compression is an open question.\nThere are several implications of this question. For example, depending on the answer, one would know whether certain transformations, such as conditioning and existential quantification, can be supported in polytime on reduced SDDs. Moreover, according to common wisdom, a negative answer may preclude bottom-up compilation from being feasible on reduced SDDs. We explore this question and its implications next.\nComplexity of Apply on Reduced SDDs The size of a decision node is the number of its elements, and the size of an SDD is the sum of sizes attained by its decision nodes. We now show that reduction, given a fixed vtree, may blow up the size of an SDD.\nTheorem 1. There exists a class of Boolean functions fm(X1, . . . , Xm) and corresponding vtrees Tm such that fm has an SDD of size O(m2) wrt vtree Tm, yet the reduced SDD of function fm wrt vtree Tm has size \u2126(2m).\nProof. Consider the function fan(X,Y, Z) =\n\u2228n i=1 (\u2227i\u22121 j=1 \u00acYj ) \u2227 Yi \u2227 Xi which has 2n + 1 variables. Of these, Z is non-essential. Consider a vtree Tn of the form\n1\nZ2\nYX\nwhere the sub-vtrees over variables X and Y are arbitrary. We will now construct an uncompressed SDD for this function using vtree Tn and whose size is O(n2). We will then show that the compressed SDD for this function and vtree has a size \u2126(2n).\nThe first step is to construct a partition of FUNCTION fan that respects the root vtree node, that is, an (XY,Z)-partition. Consider (Y1 \u2227X1,>), (\u00acY1 \u2227 Y2 \u2227X2,>), . . . , (\u00acY1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acYn\u22121 \u2227 Yn \u2227Xn,>), (Y1 \u2227 \u00acX1,\u22a5), (\u00acY1 \u2227 Y2 \u2227 \u00acX2,\u22a5), . . . , (\u00acY1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acYn\u22121 \u2227 Yn \u2227 \u00acXn,\u22a5), (\u00acY1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acYn,\u22a5)  ,\nwhich is equivalently written as n\u22c3\ni=1\n i\u22121\u2227\nj=1\n\u00acYj \u2227 Yi \u2227Xi,>  , i\u22121\u2227\nj=1\n\u00acYj \u2227 Yi \u2227 \u00acXi,\u22a5  \u222a   n\u2227\nj=1\n\u00acYj ,\u22a5  . The size of this partition is 2n + 1, and hence linear in n. It is uncompressed, because there are n elements that share sub> and n+1 elements that share sub\u22a5. The subs already respect the leaf vtree node labelled with variable Z.\nIn a second step, each of prime above is written as a compressed (X,Y)-partition that respects the left child of the vtree root. Prime \u2227i\u22121 j=1 \u00acYj \u2227 Yi \u2227Xi becomes  Xi, i\u22121\u2227 j=1 \u00acYj \u2227 Yi  , (\u00acXi,\u22a5)  ,\nprime \u2227i\u22121\nj=1 \u00acYj \u2227 Yi \u2227 \u00acXi becomes \u00acXi, i\u22121\u2227\nj=1\n\u00acYj \u2227 Yi  , ( Xi,\u22a5) \nand prime \u2227n\nj=1 \u00acYj becomes >, n\u2227\nj=1\n\u00acYj  .\nThe sizes of these partitions are bounded by 2. Finally, we need to represent the above primes as SDDs over variables X and the subs as SDDs over variables Y. Since these primes and subs correspond to terms (i.e. conjunctions of literals), each has a compact SDD representation, independent of the chosen sub-vtree over variables X and Y. For example, we can choose a right-linear vtree over variables X, and similarly for variables Y, leading to an OBDD representation of each prime and sub, with a size linear in n for each OBDD. The full SDD for function fan will then have a size which isO(n2). Recall that this SDD is uncompressed as some of its decision nodes have elements with equal subs.\nThe compressed SDD for this function and vtree is unique. We now show that its size must be \u2126(2n). We first observe that the unique, compressed (XY,Z)-partition of function fan is  n\u2228\ni=1 i\u22121\u2227 j=1 \u00acYj  \u2227 Yi \u2227Xi,>  ,\n n\u2228 i=1 i\u22121\u2227 j=1 \u00acYj  \u2227 Yi \u2227 \u00acXi  \u2228  n\u2227 j=1 \u00acYj  ,\u22a5  .\nIts first sub is the function\nf bn(X,Y) = n\u2228 i=1 i\u22121\u2227 j=1 \u00acYj  \u2227 Yi \u2227Xi, which we need to represent as an (X,Y)-partition to respect left child of the vtree root. However, Xue, Choi, and Darwiche (2012) proved the following.\nLemma 2. The compressed (X,Y)-partition of f bn(X,Y) has 2n elements.\nThis becomes clear when looking at the function f bn after instantiating the X-variables. Each distinct x results in a unique subfunction f bn(x,Y), and all states x are mutually exclusive and exhaustive. Therefore,\n{(x, f bn(x,Y)) | x instantiates X}\nis the unique, compressed (X,Y)-partition of function f bn(X,Y), which has 2\nn elements. Hence, the compressed SDD must have size \u2126(2n).\nTheorem 1 has a number of implications, which are summarized in Table 2; see also Darwiche and Marquis (2002). Theorem 3. The results in Table 2 hold.\nThe proof of this theorem is in the supplementary material. First, combining two reduced SDDs (e.g., using the conjoin or disjoin operator) may lead to a reduced SDD whose size is exponential in the size of inputs. Hence, if we activate compression in Algorithm 1, the algorithm may take exponential time in the worst-case. Second, conditioning a reduced SDD on a literal may exponentially increase its size (assuming the result is also reduced). Third, forgetting a variable (i.e., existentially quantifying it) from a reduced\nSDD may exponentially increase its size (again, assuming that the result is also reduced). These results may seem discouraging. However, we argue next that, in practice, working with reduced SDDs is actually favorable despite the lack of polytime guarantees on these transformations. Moreover, we identify a class of vtrees, called bounded vtrees, which include right-linear ones, and which induce reduced SDDs with a polytime Apply function.\nCanonicity or a Polytime Apply? One has two options when working with SDDs. The first option is to work with unreduced SDDs, which are not canonical, but are supported by a polytime Apply function. The second option is to work with reduced SDDs, which are canonical but loose the advantage of a polytime Apply function. The classical reason for seeking canonicity is that it leads to a very efficient equivalence test, which takes constant time (both reduced and unreduced SDDs support a polytime equivalence test, but the one known for unreduced SDDs is not a constant time test). The classical reason for seeking a polytime Apply function is to enable bottom-up compilation, that is, compiling a knowledge base (e.g., CNF or DNF) into an SDD by repeated application of the Apply function to components of the knowledge base (e.g., clauses or terms). If our goal is efficient bottom-up compilation, one may expect that unreduced SDDs provide a better alternative. Empirically, however, this turns out to be false. Our goal in this section is to shed some light on this phenomena through some empirical evidence and then an explanation.\nWe used the SDD package provided by the Automated Reasoning Group at UCLA2 in our experiments. The package works with reduced SDDs, but can be adjusted to work with unreduced SDDs as long as dynamic vtree search is not invoked.3 In our first experiment, we compiled CNFs from the LGSynth89 benchmarks into the following: \u2013 Reduced SDDs respecting an arbitrary vtree. Dynamic\nvtree search is used to minimize the size of the SDD during compilation, starting from a balanced vtree.\n2Available at http://reasoning.cs.ucla.edu/sdd/ 3Dynamic vtree search requires reduced SDDs as this reduces\nthe search space over SDDs into one over vtrees.\n\u2013 Reduced SDDs respecting a fixed balanced vtree.\n\u2013 Unreduced SDDs respecting a fixed balanced vtree.\nTables 3 and 4 show the corresponding sizes and compilation times. According to these results, unreduced SDDs end up several orders of magnitude larger than the reduced ones, with or without dynamic vtree search. For the harder problems, this translates to orders-of-magnitude increase in compilation times. Often, we cannot even compile the input without reduction (due to running out of 4GB of memory), even on relatively easy benchmarks. For the easiest benchmarks, dynamic vtree search is slower due to the overhead, but yields smaller compilations. The benefit of vtree search shows only in harder problems (e.g., \u201cunreg\u201d).\nThis experiment clearly shows the advantage of reduced SDDs over unreduced ones, even though the latter supports a polytime Apply function while the former does not. This begs an explanation and we provide one next that we back up by additional experimental results.\nThe benefit of reduced SDDs is canonicity, which plays a critical role in the performance of the Apply function. Consider in particular Line 4 of Algorithm 1. The test Cache(\u03b1, \u03b2, \u25e6) 6= nil checks whether SDDs \u03b1 and \u03b2 have been previously combined using the Boolean operator \u25e6. Without canonicity, it is possible that we would have combined some \u03b1\u2032 and \u03b2\u2032 using \u25e6, where SDD \u03b1\u2032 is equivalent\nto, but distinct from SDD \u03b1 (and similarly for \u03b2\u2032 and \u03b2). In this case, the cache test would fail, causing Apply to recompute the same result again. Worse, the SDD returned by Apply(\u03b1, \u03b2, \u25e6) may be distinct from the SDD returned by Apply(\u03b1\u2032, \u03b2\u2032, \u25e6), even though the two SDDs are equivalent. This redundancy also happens when \u03b1 is not equivalent to \u03b1\u2032 (and similarly for \u03b2 and \u03b2\u2032), \u03b1 \u25e6 \u03b2 is equivalent to \u03b1\u2032 \u25e6 \u03b2\u2032, but the result returned by Apply(\u03b1, \u03b2, \u25e6) is distinct from the one returned by Apply(\u03b1\u2032, \u03b2\u2032, \u25e6).\nTwo observations are due here. First, this redundancy is still under control when calling Apply only once: Apply runs in O(nm) time, where n and m are the sizes of input SDDs. However, this redundancy becomes problematic when calling Apply multiple times (as in bottom-up compilation), in which case quadratic performance is no longer as attractive. For example, if we use Apply to combine m SDDs of size n each, all we can say is that the output will be of size O(nm). The second observation is that the previous redundancy will not occur when working with reduced SDDs due to their canonicity: Two SDDs are equivalent iff they are represented by the same structure in memory.4\nThis analysis points to the following conclusion: While Apply has a quadratic complexity on unreduced SDDs, it\n4This is due to the technique of unique nodes from OBDDs; see UniqueD in Algorithm 1.\nmay have a worse average complexity than Apply on reduced SDDs. Our next experiment is indeed directed towards this hypothesis.\nFor all benchmarks in Table 3 that can be compiled without vtree search, we intercept all non-trivial calls to Apply (when |\u03b1| \u00b7 |\u03b2| > 500) and report the size of the output |\u03b1 \u25e6 \u03b2| divided by |\u03b1| \u00b7 |\u03b2|. For unreduced SDDs, we know that |\u03b1 \u25e6 \u03b2| = O(|\u03b1| \u00b7 |\u03b2|) and that these ratios are therefore bounded above by some constant. For reduced SDDs, however, Theorem 3 states that there exists no constant bound.\nFigure 2 shows the distribution of these ratios for the two methods (note the log scale). The number of function calls is 67,809 for reduced SDDs, vs. 1,626,591 for unreduced ones. The average ratio is 0.027 for reduced, vs. 0.101 for unreduced. Contrasting the theoretical bounds, reduced Apply incurs much smaller blowups than unreduced Apply. This is most clear for ratios in the range [0.48, 0.56], covering 30% of the unreduced, but only 2% of the reduced calls.\nThe results are similar when looking at runtime for individual Apply calls, which we measure by the number of recursive Apply calls r. Figure 3 reports these, again relative to |\u03b1| \u00b7 |\u03b2|. The ratio r/(|\u03b1| \u00b7 |\u03b2|) is on average 0.013 for reduced SDDs, vs. 0.034 for unreduced ones These results corroborate our earlier analysis, suggesting that canonicity is quite important for the performance of bottom-up compilers as they make repeated calls to the Apply function. In fact, this can be more important than a polytime Apply, perhaps contrary to common wisdom which seems to emphasize the importance of polytime Apply in effective bottom-up compilation (e.g., Pipatsrisawat and Darwiche (2008)).\nBounded Vtrees A bounded vtree is one for which the number of variables in any left subtree is bounded. This includes right-linear vtrees\nwhich give rise to OBDDs, since each left subtree contains a single variable in this case. We now have the following.\nTheorem 4. The time and space complexity of Algorithm 1, with compression, is inO(nm), where n andm are the sizes of its inputs, assuming that the input SDDs are reduced and respect a bounded vtree.\nThe compression step of Algorithm 1 identifies elements (pi, s) and (pj , s) that share sub s, and merges these elements into the element (pi \u2228 pj , s) by calling Apply recursively to disjoin primes pi and pj . Since the vtree is bounded, primes pi and pj must be over a bounded number of variables. Hence, the complexity of compression is bounded, leading Apply to have the same complexity with or without compression.\nFor example, in right-linear vtrees (i.e., OBDDs), primes are literals over a single variable. Hence, all decision nodes are of the form {(X,\u03b1), (\u00acX,\u03b2)}. On these, compression occurs when \u03b1 = \u03b2, resulting in the partition {(X \u2228 \u00acX,\u03b1)} = {(>, \u03b1)}, which trimming replaces by \u03b1. This corresponds to the OBDD reduction rule that eliminates decision nodes with isomorphic children (Bryant 1986).\nXue, Choi, and Darwiche (2012) showed a class of Boolean functions whose OBDDs have exponential size with respect to certain orders (right-linear vtrees), but which have SDDs of linear size when the vtrees are not right-linear (but have the same left-to-right variable order). The used vtrees, however, were not bounded. It would be interesting to see if a similar result can be obtained for bounded vtrees."}, {"heading": "Conclusions", "text": "We have shown that the Apply function on reduced SDDs can take exponential time in the worst case, resolving a question that has been open since SDDs were first introduced. We have also pursued some of the theoretical and practical implications of this result. On the theoretical side, we showed that it implies an exponential complexity for various transformations, such as conditioning and existential quantification. We also identified the class of bounded vtrees, for which the Apply function can be implemented in polynomial time even for reduced SDDs. On the practical side, we argued empirically that working with reduced SDDs remains favorable, despite the polytime complexity of the Apply function on unreduced SDDs. The canonicity of reduced SDDs, we argued, is more valuable for bottom-up compilation than a polytime Apply due to its role in facilitating caching and dynamic vtree search. Our findings appear contrary to some of the common wisdom on the relationship between bottom-up compilation, canonicity and the complexity of the Apply function.\nAcknowledgments We thank Arthur Choi, Doga Kisa, and Umut Oztok for helpful suggestions. This work was supported by ONR grant #N00014-12-1-0423, NSF grant #IIS-1118122, NSF grant #IIS-0916161, and the Research Foundation-Flanders (FWO-Vlaanderen). GVdB is also at KU Leuven, Belgium."}, {"heading": "Complexity of Transformations", "text": "We now prove Theorem 3, stating that the results in Table 2 hold. We will first show the results for unreduced SDDs, and then prove the results for reduced SDDs.\nFor unreduced SDDs, Darwiche (2011) showed support for \u2227BC, \u2228BC, and \u00acC (see Algorithm 1). We show support for unreduced CD next. Theorem 5. We can condition an unreduced SDD on a literal ` in polynomial time by replacing ` by > and \u00ac` by \u22a5. Moreover, when removing all elements whose prime is equivalent to\u22a5, the resulting sentence is an unreduced SDD.\nProof. It is clear that the procedure transforms \u03b1 into a sentence that is logically equivalent to \u03b1|`: the first step directly follows the definition of conditioning, and the second step maintains logical equivalence. We need to show next that the result is syntactically an SDD, by showing that the primes in its partitions are consistent, exhaustive, and mutually exclusive. The second step enforces consistency of the primes. Moreover, if the primes are exhaustive, that is, p1\u2228\u00b7 \u00b7 \u00b7\u2228pn \u2261 >, then p1|`\u2228\u00b7 \u00b7 \u00b7\u2228pn|` \u2261 (p1\u2228\u00b7 \u00b7 \u00b7\u2228pn)|` \u2261 >|` \u2261 >, and the result of conditioning is also exhaustive. Finally, when pi and pj are mutually exclusive, that is, pi \u2227 pj \u2261 \u22a5, then pi|` \u2227 pj |` \u2261 (pi \u2227 pj)|` \u2261 \u22a5|` \u2261 \u22a5, and the conditioned primes are also mutually exclusive.\nSupport for SFO follows from the support for CD and \u2228BC. The negative results for FO,\u2227C and\u2228C follow from identical OBDD results in Darwiche and Marquis (2002), and the fact that OBDDs are a special case of SDDs.\nFor reduced SDDs, the negative FO, \u2227C and \u2228C results also follow from OBDD results. It is also clear from Algorithm 1 that negating a reduced SDD \u03b1 by computing Apply(\u03b1,>, xor) does not cause any subs to become equivalent. Therefore, negating a reduced SDD leads to a reduced result, and reduced SDDs support \u00acC. The remaining results in Table 2, on CD, SFO, \u2227BC and \u2228BC are discussed next. Theorem 6. There exists a class of Boolean functions f(X1, . . . , Xn) and vtrees Tn for which the reduced SDD has size O(n), yet the reduced SDD for the function f(X1, . . . , Xn)|` has size \u2126(2n) for some literal `.\nProof. Consider the function\nf cn(X,Y,Z,W ) =\nn\u2228 i=1 i\u22121\u2227 j=1 \u00acYj \u2227 Yi \u2227 [(Xi \u2227 (W \u2228 Zi)) \u2228 (\u00acXi \u2227 Zi)]\nand the vtree depicted in Figure 4a. The root of the reduce SDD for f cn is an (XY,ZW )- partition that respects vtree node 1, consisting of elements\nn\u22c3 i=1  i\u22121\u2227 j=1 \u00acYj \u2227 Yi \u2227Xi, W \u2228 Zi  , i\u22121\u2227\nj=1\n\u00acYj \u2227 Yi \u2227 \u00acXi, Zi  ,\ntogether with (\u2227n j=1 \u00acYj , \u22a5 )\nto make it exhaustive. The size of this partition is linear in n. It has the same primes as the unreduced SDD for fan used in the proof of Theorem 1, only now the partition is compressed, as all subs are distinct.\nThe primes of this partition can be represented as compressed (X,Y)-partitions, exactly as in the second step for Theorem 1. The remaining primes and subs (over X, over Y, and over Z \u222a {W}) are all simple conjunctions or disjunctions of literals that have a linear reduced SDD representation for any vtree.\nWe have now obtained a polysize SDD. However, when we condition this SDD on the literal W , all n subs of the form W \u2228 Zi become equivalent to >. Their elements need to be compressed into the single element(\u2228n\ni=1 \u2227i\u22121 j=1 \u00acYj \u2227 Yi \u2227Xi, > ) . Its prime is again the\nfunction f bn(X,Y) for which Lemma 2 states that the reduced SDD wrt vtree node 2 has exponential size.\nTheorem 7. There is a class of Boolean functions f(X1, . . . , Xn) and vtrees Tn for which the reduced SDD has size O(n), yet the reduced SDD for the Boolean function f(X1, . . . , Xn) \u2227 ` has size \u2126(2n) for some literal `.\nProof. Consider again the reduced SDD for f cn that was constructed in the proof of Theorem 6 for the vtree in Figure 4a. Conjoining this SDD with the SDD for literal W makes the n subs of the form W \u2228 Zi equivalent to W \u2227 (W \u2228 Zi) = W . Compressing these creates the element (\u2228n i=1 \u2227i\u22121 j=1 \u00acYj \u2227 Yi \u2227Xi, W ) , whose prime is\nagain f bn(X,Y), which has no polysize reduced SDD for vtree node 2.\nThis already proves that Apply is worst-case exponential when performing conjunctions on reduced SDDs. Given that reduced SDDs support polytime negation, this result generalizes to any binary Boolean operator \u25e6 that is functionally complete together with negation (Wernick 1942). Support for these operators would allow us to do polytime conjunction by combining \u25e6 and negation. One such operator is disjunction, which is therefore also is worst-case exponential.\nSuppose now that we can perform singleton forgetting in polytime, which is defined as \u2203L.\u03b1 = (\u03b1|L)\u2228(\u03b1|\u00acL). Then given any two reduced SDDs \u03b2 and \u03b3 respecting the same vtree T , we can obtain \u03b2 \u2228 \u03b3 in polytime as follows. Add a new variable L to vtree T , as depicted in Figure 4b. The reduced SDD \u03b1 for the function (L\u2227 \u03b2)\u2228 (\u00acL\u2227 \u03b3) has the\nroot partition {(L, \u03b2), (\u00acL, \u03b3)}. Forgetting L from \u03b1 results in the reduced SDD for \u03b2\u2228\u03b3. Hence, if single forgetting can be done in polytime, then bounded disjunction can also be done in polytime. Since the latter is impossible, the former is also impossible."}], "references": [{"title": "Graph-based algorithms for Boolean function manipulation", "author": ["R.E. Bryant"], "venue": "IEEE Transactions on Computers C-35:677\u2013691.", "citeRegEx": "Bryant,? 1986", "shortCiteRegEx": "Bryant", "year": 1986}, {"title": "On probabilistic inference by weighted model counting", "author": ["M. Chavira", "A. Darwiche"], "venue": "Artificial Intelligence Journal 172(6\u20137):772\u2013799.", "citeRegEx": "Chavira and Darwiche,? 2008", "shortCiteRegEx": "Chavira and Darwiche", "year": 2008}, {"title": "Compiling relational bayesian networks for exact inference", "author": ["M. Chavira", "A. Darwiche", "M. Jaeger"], "venue": "International Journal of Approximate Reasoning 42(1):4\u201320.", "citeRegEx": "Chavira et al\\.,? 2006", "shortCiteRegEx": "Chavira et al\\.", "year": 2006}, {"title": "Dynamic minimization of sentential decision diagrams", "author": ["A. Choi", "A. Darwiche"], "venue": "Proceedings of the 27th Conference on Artificial Intelligence (AAAI).", "citeRegEx": "Choi and Darwiche,? 2013", "shortCiteRegEx": "Choi and Darwiche", "year": 2013}, {"title": "Compiling probabilistic graphical models using sentential decision diagrams", "author": ["A. Choi", "D. Kisa", "A. Darwiche"], "venue": "Proceedings of the 12th European Conference on Symbolic and Quantitative Approaches to Reasoning with Uncertainty (ECSQARU).", "citeRegEx": "Choi et al\\.,? 2013", "shortCiteRegEx": "Choi et al\\.", "year": 2013}, {"title": "A knowledge compilation map", "author": ["A. Darwiche", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research 17:229\u2013264.", "citeRegEx": "Darwiche and Marquis,? 2002", "shortCiteRegEx": "Darwiche and Marquis", "year": 2002}, {"title": "On the tractability of counting theory models and its application to belief revision and truth maintenance", "author": ["A. Darwiche"], "venue": "Journal of Applied Non-Classical Logics 11(12):11\u201334.", "citeRegEx": "Darwiche,? 2001", "shortCiteRegEx": "Darwiche", "year": 2001}, {"title": "SDD: A new canonical representation of propositional knowledge bases", "author": ["A. Darwiche"], "venue": "Proceedings of the 22nd International Joint Conference on Artificial Intelligence, 819\u2013826.", "citeRegEx": "Darwiche,? 2011", "shortCiteRegEx": "Darwiche", "year": 2011}, {"title": "DNNF-based belief state estimation", "author": ["P. Elliott", "B. Williams"], "venue": "Proceedings of the 21st National Conference on Artificial Intelligence (AAAI).", "citeRegEx": "Elliott and Williams,? 2006", "shortCiteRegEx": "Elliott and Williams", "year": 2006}, {"title": "Inference in probabilistic logic programs using weighted CNF\u2019s", "author": ["D. Fierens", "G. Van den Broeck", "I. Thon", "B. Gutmann", "L.D. Raedt"], "venue": "UAI, 211\u2013220.", "citeRegEx": "Fierens et al\\.,? 2011", "shortCiteRegEx": "Fierens et al\\.", "year": 2011}, {"title": "Pruning conformant plans by counting models on compiled d-DNNF representations", "author": ["H. Palacios", "B. Bonet", "A. Darwiche", "H. Geffner"], "venue": "Proceedings of the 15th International Conference on Automated Planning and Scheduling, 141\u2013150.", "citeRegEx": "Palacios et al\\.,? 2005", "shortCiteRegEx": "Palacios et al\\.", "year": 2005}, {"title": "New compilation languages based on structured decomposability", "author": ["K. Pipatsrisawat", "A. Darwiche"], "venue": "Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence (AAAI), 517\u2013522.", "citeRegEx": "Pipatsrisawat and Darwiche,? 2008", "shortCiteRegEx": "Pipatsrisawat and Darwiche", "year": 2008}, {"title": "Knowledge compilation and theory approximation", "author": ["B. Selman", "H. Kautz"], "venue": "Journal of the ACM (JACM) 43(2):193\u2013224.", "citeRegEx": "Selman and Kautz,? 1996", "shortCiteRegEx": "Selman and Kautz", "year": 1996}, {"title": "Probabilistic databases", "author": ["D. Suciu", "D. Olteanu", "C. R\u00e9", "C. Koch"], "venue": "Synthesis Lectures on Data Management 3(2):1\u2013180.", "citeRegEx": "Suciu et al\\.,? 2011", "shortCiteRegEx": "Suciu et al\\.", "year": 2011}, {"title": "Complete sets of logical functions", "author": ["W. Wernick"], "venue": "Transactions of the American Mathematical Society 51(1):117\u2013132. Xue, Y.; Choi, A.; and Darwiche, A. 2012. Basing decisions on sentences in decision diagrams. In In Proceedings", "citeRegEx": "Wernick,? 1942", "shortCiteRegEx": "Wernick", "year": 1942}], "referenceMentions": [{"referenceID": 7, "context": "The Sentential Decision Diagram (SDD) is a recently proposed circuit representation of propositional knowledge bases (Darwiche 2011).", "startOffset": 117, "endOffset": 132}, {"referenceID": 12, "context": "The SDD is a target language for knowledge compilation (Selman and Kautz 1996; Darwiche and Marquis 2002), meaning that once a propositional knowledge base is compiled into an SDD, the SDD can be reused to answer multiple hard queries efficiently (e.", "startOffset": 55, "endOffset": 105}, {"referenceID": 5, "context": "The SDD is a target language for knowledge compilation (Selman and Kautz 1996; Darwiche and Marquis 2002), meaning that once a propositional knowledge base is compiled into an SDD, the SDD can be reused to answer multiple hard queries efficiently (e.", "startOffset": 55, "endOffset": 105}, {"referenceID": 0, "context": "SDDs subsume Ordered Binary Decision Diagrams (OBDD) (Bryant 1986) and come with a tighter size bound (Darwiche 2011), while still being equally powerful as far as their polytime support for classical queries (e.", "startOffset": 53, "endOffset": 66}, {"referenceID": 7, "context": "SDDs subsume Ordered Binary Decision Diagrams (OBDD) (Bryant 1986) and come with a tighter size bound (Darwiche 2011), while still being equally powerful as far as their polytime support for classical queries (e.", "startOffset": 102, "endOffset": 117}, {"referenceID": 6, "context": "Moreover, SDDs are subsumed by d-DNNFs (Darwiche 2001), which received much attention over the last decade, for fault diagnosis (Elliott and Williams 2006), planning (Palacios et al.", "startOffset": 39, "endOffset": 54}, {"referenceID": 8, "context": "Moreover, SDDs are subsumed by d-DNNFs (Darwiche 2001), which received much attention over the last decade, for fault diagnosis (Elliott and Williams 2006), planning (Palacios et al.", "startOffset": 128, "endOffset": 155}, {"referenceID": 10, "context": "Moreover, SDDs are subsumed by d-DNNFs (Darwiche 2001), which received much attention over the last decade, for fault diagnosis (Elliott and Williams 2006), planning (Palacios et al. 2005), databases (Suciu et al.", "startOffset": 166, "endOffset": 188}, {"referenceID": 13, "context": "2005), databases (Suciu et al. 2011), but most importantly for probabilistic inference (Chavira, Darwiche, and Jaeger 2006; Chavira and Darwiche 2008; Fierens et al.", "startOffset": 17, "endOffset": 36}, {"referenceID": 1, "context": "2011), but most importantly for probabilistic inference (Chavira, Darwiche, and Jaeger 2006; Chavira and Darwiche 2008; Fierens et al. 2011).", "startOffset": 56, "endOffset": 140}, {"referenceID": 9, "context": "2011), but most importantly for probabilistic inference (Chavira, Darwiche, and Jaeger 2006; Chavira and Darwiche 2008; Fierens et al. 2011).", "startOffset": 56, "endOffset": 140}, {"referenceID": 0, "context": "SDDs subsume Ordered Binary Decision Diagrams (OBDD) (Bryant 1986) and come with a tighter size bound (Darwiche 2011), while still being equally powerful as far as their polytime support for classical queries (e.g., the ones in Darwiche and Marquis (2002)).", "startOffset": 54, "endOffset": 256}, {"referenceID": 0, "context": "SDDs subsume Ordered Binary Decision Diagrams (OBDD) (Bryant 1986) and come with a tighter size bound (Darwiche 2011), while still being equally powerful as far as their polytime support for classical queries (e.g., the ones in Darwiche and Marquis (2002)). Moreover, SDDs are subsumed by d-DNNFs (Darwiche 2001), which received much attention over the last decade, for fault diagnosis (Elliott and Williams 2006), planning (Palacios et al. 2005), databases (Suciu et al. 2011), but most importantly for probabilistic inference (Chavira, Darwiche, and Jaeger 2006; Chavira and Darwiche 2008; Fierens et al. 2011). Even though SDDs are less succinct than d-DNNFs, they can be compiled bottom-up, just like OBDDs. For example, a clause can be compiled by disjoining the SDDs corresponding to its literals, and a CNF can be compiled by conjoining the SDDs corresponding to its clauses. This bottom-up compilation is implemented using the Apply function, which combines two SDDs using Boolean operators.1 Bottomup compilation makes SDDs attractive for certain applications (e.g., probabilistic inference (Choi, Kisa, and Darwiche 2013)) and can be critical when the knowledge base to be compiled is constructed incrementally (see the discussion in Pipatsrisawat and Darwiche (2008)).", "startOffset": 54, "endOffset": 1278}, {"referenceID": 11, "context": "In fact, the discovery of SDDs was mostly driven by the need for bottom-up compilation, which was preceded by the discovery of structured decomposability (Pipatsrisawat and Darwiche 2008): a property that enables some Boolean operations to be applied in polytime.", "startOffset": 154, "endOffset": 187}, {"referenceID": 7, "context": "SDDs satisfy this property and stronger ones, leading to a polytime Apply function (Darwiche 2011).", "startOffset": 83, "endOffset": 98}, {"referenceID": 0, "context": "The Apply function (and its name) originated in the OBDD literature (Bryant 1986) ar X iv :1 40 4.", "startOffset": 68, "endOffset": 81}, {"referenceID": 7, "context": "The Sentential Decision Diagram (SDD) is a newly introduced representation language for propositional knowledge bases (Darwiche 2011).", "startOffset": 118, "endOffset": 133}, {"referenceID": 7, "context": "This type of decomposition is called an (X,Y)partition (Darwiche 2011).", "startOffset": 55, "endOffset": 70}, {"referenceID": 7, "context": "Given a vtree, each Boolean function also has a unique compressed SDD, when this property is combined with either trimming or normalization properties (Darwiche 2011).", "startOffset": 151, "endOffset": 166}, {"referenceID": 7, "context": "Compressed and trimmed SDDs are canonical, and so are compressed and normalized SDDs (Darwiche 2011).", "startOffset": 85, "endOffset": 100}, {"referenceID": 7, "context": "OBDDs correspond precisely to SDDs that are constructed using a special type of vtree, called a right-linear vtree (Darwiche 2011).", "startOffset": 115, "endOffset": 130}, {"referenceID": 3, "context": "Vtree search algorithms can sometimes find SDDs that are orders-of-magnitude more succinct than OBDDs found by searching for variable orders (Choi and Darwiche 2013).", "startOffset": 141, "endOffset": 165}, {"referenceID": 11, "context": "subset of structured d-DNNF and, hence, support the same polytime queries supported by structured d-DNNF (Pipatsrisawat and Darwiche 2008); see Table 1.", "startOffset": 105, "endOffset": 138}, {"referenceID": 7, "context": "Algorithm 1 shows the outline of an Apply function (Darwiche 2011) that takes two SDDs \u03b1 and \u03b2, and a binary Boolean operator \u25e6 (e.", "startOffset": 51, "endOffset": 66}, {"referenceID": 7, "context": "Without compression, this algorithm has a time and space complexity of O(nm), where n and m are the sizes of input SDDs (Darwiche 2011).", "startOffset": 120, "endOffset": 135}, {"referenceID": 6, "context": "However, Xue, Choi, and Darwiche (2012) proved the following.", "startOffset": 24, "endOffset": 40}, {"referenceID": 5, "context": "Theorem 1 has a number of implications, which are summarized in Table 2; see also Darwiche and Marquis (2002).", "startOffset": 82, "endOffset": 110}, {"referenceID": 6, "context": ", Pipatsrisawat and Darwiche (2008)).", "startOffset": 20, "endOffset": 36}, {"referenceID": 0, "context": "This corresponds to the OBDD reduction rule that eliminates decision nodes with isomorphic children (Bryant 1986).", "startOffset": 100, "endOffset": 113}, {"referenceID": 6, "context": "Xue, Choi, and Darwiche (2012) showed a class of Boolean functions whose OBDDs have exponential size with respect to certain orders (right-linear vtrees), but which have SDDs of linear size when the vtrees are not right-linear (but have the same left-to-right variable order).", "startOffset": 15, "endOffset": 31}, {"referenceID": 6, "context": "For unreduced SDDs, Darwiche (2011) showed support for \u2227BC, \u2228BC, and \u00acC (see Algorithm 1).", "startOffset": 20, "endOffset": 36}, {"referenceID": 5, "context": "The negative results for FO,\u2227C and\u2228C follow from identical OBDD results in Darwiche and Marquis (2002), and the fact that OBDDs are a special case of SDDs.", "startOffset": 75, "endOffset": 103}, {"referenceID": 14, "context": "Given that reduced SDDs support polytime negation, this result generalizes to any binary Boolean operator \u25e6 that is functionally complete together with negation (Wernick 1942).", "startOffset": 161, "endOffset": 175}], "year": 2014, "abstractText": "We consider the problem of bottom-up compilation of knowledge bases, which is usually predicated on the existence of a polytime function for combining compilations using Boolean operators (usually called an Apply function). While such a polytime Apply function is known to exist for certain languages (e.g., OBDDs) and not exist for others (e.g., DNNF), its existence for certain languages remains unknown. Among the latter is the recently introduced language of Sentential Decision Diagrams (SDDs), for which a polytime Apply function exists for unreduced SDDs, but remains unknown for reduced ones (i.e. canonical SDDs). We resolve this open question in this paper and consider some of its theoretical and practical implications. Some of the findings we report question the common wisdom on the relationship between bottom-up compilation, language canonicity and the complexity of the Apply function.", "creator": "TeX"}}}