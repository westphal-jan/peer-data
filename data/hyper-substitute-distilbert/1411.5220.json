{"id": "1411.5220", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Nov-2014", "title": "Existential Rule Languages with Finite Chase: Complexity and Expressiveness", "abstract": "finite chase, or : chase analysis, is an aesthetic condition important ensure computational achievement of existential structural languages. recalling the past few years, vast number of dynamic languages with finite chase is emerged studied. in more work, we propose such novel approach when classifying more rule languages with finite chase. using this approach, a family into derived category languages, which alter the existing languages : the finite chase property, are loosely defined. economists uniquely study the complexity of independent languages. terms all encompassing them exist tractable for data separation, will admit that maximal combined complexity can assume amazingly high. furthermore, we establish that all the rule languages except brute chase - extend the structurally optimal language are possess the same expressiveness as the weakly productive one, while rule properties require higher combined detail might sometimes sum more abundant than dialects with worse semantic content.", "histories": [["v1", "Wed, 19 Nov 2014 13:37:22 GMT  (27kb)", "https://arxiv.org/abs/1411.5220v1", "Extended version of a paper to appear on AAAI 2015"], ["v2", "Sat, 22 Nov 2014 05:36:49 GMT  (26kb)", "http://arxiv.org/abs/1411.5220v2", "Extended version of a paper to appear on AAAI 2015"], ["v3", "Thu, 8 Jan 2015 22:53:11 GMT  (343kb,D)", "http://arxiv.org/abs/1411.5220v3", "Extended version of a paper to appear on AAAI 2015"]], "COMMENTS": "Extended version of a paper to appear on AAAI 2015", "reviews": [], "SUBJECTS": "cs.AI cs.DB cs.LO", "authors": ["heng zhang", "yan zhang", "jia-huai you"], "accepted": true, "id": "1411.5220"}, "pdf": {"name": "1411.5220.pdf", "metadata": {"source": "CRF", "title": "Existential Rule Languages with Finite Chase: Complexity and Expressiveness", "authors": ["Heng Zhang", "Yan Zhang", "Jia-Huai You"], "emails": [], "sections": [{"heading": "Introduction", "text": "It has been shown that existential rule languages, also called Datalog\u00b1, have prominent applications in ontological reasoning, knowledge representation, and databases, in which query answering is a primary yet challenging problem; see e.g., (Cal\u0131\u0300 et al. 2010; Baget et al. 2011a). Under an existential rule language, queries are answered against a logical theory consisting of an input database and a finite set of existential rules, while a chase procedure is usually used. Specifically, given an input database D, a finite set \u03a3 of existential rules, and a query q, we want to decide whether D \u222a\u03a3 |= q. Applying the chase procedure, the problem is equivalent to deciding whether chase(D,\u03a3) |= q. Through a chase procedure, fresh nulls have to be introduced for each application of the existential rules, and hence, potential cyclic applications of these rules may lead the chase procedure not to terminate, i.e., chase(D,\u03a3) is infinite. Therefore, the problem of query answering under existential rule languages is in general undecidable (Beeri and Vardi 1981).\nThere have been a considerable number of works on identifying decidable classes with respect to query answering. Basically, two major approaches have provided a landscape on this study: One is to focus on some restricted\nCopyright c\u00a9 2015, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nfragments of existential rule languages such that the underlying chase procedure, though non-terminating in general, still enjoys some kind of finite representability property, so that the problem of query answering is decidable under this setting. This paradigm includes, e.g., guarded rules (Cal\u0131\u0300, Gottlob, and Lukasiewicz 2012), greedy bounded treewidth sets (Baget et al. 2011b), sticky sets (Cal\u0131\u0300, Gottlob, and Pieris 2012), and Shy programs (Leone et al. 2012). The other approach is to identify a certain acyclicity condition under which each existential rule can only be finitely applied so that the chase procedure always terminates. There have been many recent studies on this paradigm. Our work presented in this paper is along this line. Below, let us provide a brief summary of recent works under this approach.\nIn their milestone paper, Fagin et al. (2005) formulated a concept called weak acyclicity (WA) as a sufficient condition to ensure the chase termination for existential rules. This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Kro\u0308tzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al. 2013), and some dependency relations by (Baget et al. 2014). Among these, MFA is known to define the largest rule class. In addition, many ontologies in various domains turn out to be in the MFA class, as evidenced in (Grau et al. 2013).\nIt has been observed that almost all of the existential rule languages defined based on the notion of acyclicity or its variations have PTIME-complete data complexity and 2- EXPTIME-complete combined complexity. The uniformity on data complexity is in fact due to an interesting result proved in (Marnette 2009), which states that every rule language with finite Skolem chase is in PTIME for data complexity. A natural question then arises: Does this uniformity hold for combined complexity? Moreover, what is the expressiveness of existing rule languages with finite chase? Please note that the uniformity on data complexity does not imply the uniformity on expressiveness as data complexity only captures the hardest case of a language. Recently, there have been two interesting related works that studied the expressiveness of existential rules (Arenas, Gottlob, and Pieris 2014; Gottlob, Rudolph, and Simkus 2014). But both of them only focus on guarded language or its variations. ar X\niv :1\n41 1.\n52 20\nv3 [\ncs .A\nI] 8\nJ an\n2 01\n5\nIn this paper, we study the complexity, expressiveness and succinctness for existential rule languages with finite chase. Our contributions are summarized as follows:\n1. A novel approach for classifying the existential rule languages with finite Skolem chase is proposed by restricting the use of existential variables in the Skolem chase. Under this approach, a family of interesting decidable rule languages, called bounded languages, are naturally defined. All of the existing rule languages with finite chase, e.g., the MFA class, are contained in these languages.\n2. For every nonnegative integer k, the combined complexity of Boolean query answering for k-exponentially bounded language is proved to be (k + 2)-EXPTIME-complete, and the membership problem of k-exponentially bounded language is proved to be in (k + 2)-EXPTIME. Furthermore, for other bounded languages, the corresponding upper bounds of the complexity are also obtained.\n3. All the languages with finite Skolem chase that extend the WA class are proved to be of the same expressiveness as WA, while languages with higher combined complexity are in general more succinct than those with lower combined complexity. On ordered databases, WA is shown to capture all existential rule sets whose universal models are computable in PTIME, even if they have no finite chase.\nThe results presented in this paper not only generalize some of the existing works, such as the two acyclicity notions of MFA and MSA proposed in (Grau et al. 2013), more importantly, they provide a global landscape for characterizing the existential rule languages with finite Skolem chase.\nThe rest of this paper is organized as follows. Section 2 provides necessary preliminaries. Section 3 defines a family of existential rule languages with finite Skolem chase called bounded classes, and presents some interesting properties of this family of languages. Section 4 then focuses on the complexity issues for bounded classes of languages, while section 5 explores the expressiveness and succinctness of these bounded classes of languages in details. Finally, section 6 concludes this paper with some remarks. Due to space limitation, proofs of some results are presented in an extended version of this paper, see (Zhang, Zhang, and You 2014)."}, {"heading": "Preliminaries", "text": "Databases and Queries. As usual, we assume (i) an infinite set \u2206 of constants, (ii) an infinite set \u2206n of (labelled) nulls, and (iii) an infinite set \u2206v of variables. A relational schema R consists of a finite set of relation symbols, each of which is armed with a natural number, its arity. Terms are either constants or variables. Every atomic formula (or atom) has the form R(t) where R is a relation symbol and t a tuple of terms of a proper length. Ground terms are terms involving no variable, and facts are atoms built from ground terms.\nGiven a relational schemaR, an instance (database) over R, or simply R-instance (R-database), is a (finite) set of facts involving only relation symbols from R. The domain of a database D, denoted dom(D), is the set of all constants appearing inD. General instances (databases) are the extensions of instances (databases) by allowing nulls to be\nused. Given a general instance (database) D and a relational schemaR, the restriction ofD toR, denotedD|R, is the set of facts in D involving only relation symbols fromR.\nA substitution is a function h : \u2206\u222a\u2206n\u222a\u2206v \u2192 \u2206\u222a\u2206n\u222a \u2206v with (i) h(c) = c for all c \u2208 \u2206 and (ii) h(n) \u2208 \u2206 \u222a\u2206n for all n \u2208 \u2206n. Let D and D0 be general instances of the same schema. Then D is called homomorphic to D0, written D \u2192 D0, if there is a substitution h with h(D) \u2286 D0 where h is assumed to be extended to atoms and general instances naturally. In this case, the function is called a homomorphism from D to D0. Moreover, D is homomorphically equivalent toD0 ifD is homomorphic toD0 and vice versa.\nEvery conjunctive query (CQ) q over a relational schema R has the form q(x) := \u2203y\u03d5(x,y), where x,y are tuples of variables, and \u03d5(x,y) is a conjunction (sometimes we regard it as a set) of atoms with variables from x and y, and relation symbols fromR. A Boolean CQ (BCQ) is a CQ of the form q(). Actually, BCQs can be regarded as general databases if we omit the quantifiers and regard the variables as nulls. Given any BCQ q and any general instance D over the same schema, the answer to q over D is \u201cYes\u201d, written D |= q, if there exists a homomorphism from q to D.\nExistential Rules and Skolem Chase. Given a relational schemaR, every (existential) rule overR is a first-order sentence \u03b3 of the form \u2200x\u2200y(\u03d5(x,y)\u2192 \u2203z\u03c8(x, z)), where \u03d5 and \u03c8 are conjunctions of atoms with relation symbols from R and variables from x \u222a y and x \u222a z, respectively. We call \u03d5 the body of \u03b3 and \u03c8 the head of \u03b3, and write them as body(\u03b3) and head(\u03b3), respectively. When writing a rule, for simplicity, we will omit the universal quantifiers.\nA rule ontology is a triple (\u03a3,D,Q), where \u03a3 is finite and nonempty set \u03a3 of rules, D, called database schema, is a relational schema consisting of the relation symbols to be used in databases, and Q, called query schema, is a relational schema consisting of the relation symbols to be used in queries. Relation symbols appearing in \u03a3 but neither D norQ are called auxiliary symbols. Note thatD andQ could be the same. Without loss of generality, in any rule ontology, each variable is assumed to be quantified at most once.\nLet \u03b3 be a rule \u03d5(x,y) \u2192 \u2203z\u03c8(x, z). We introduce a function symbol fz of arity |x| for each variable z \u2208 z. From now on, we will regard terms built from constants and the introduced function symbols as a special class of nulls. The functional transformation of \u03b3, denoted sk(\u03b3), is the formula obtained from \u03b3 by substituting fz(x) for each variable z \u2208 z. Given a set \u03a3 of rules, the functional transformation of \u03a3, denoted sk(\u03a3), is the set of rules sk(\u03b3) for all \u03b3 \u2208 \u03a3.\nNow we are in the position to define the (Skolem) chase. Let D be a database and \u03a3 a rule set. We let chase0(D,\u03a3) = D and, for all n > 0, let chasen(D,\u03a3) denote the union of chasen\u22121(D,\u03a3) and h(head(\u03b3)) for all rules \u03b3 \u2208 sk(\u03a3) and all substitutions h such that h(body(\u03b3)) \u2286 chasen\u22121(D,\u03a3). Let chase(D,\u03a3) be the union of chasen(D,\u03a3) for all n \u2265 0. It is well-known that, for all BCQs q, D \u222a\u03a3 |= q (under the semantics of first-order logic) if and only if chase(D,\u03a3) |= q. Given a rule ontology O = (\u03a3,D,Q), we say that O has finite chase if for all D-databases D, chase(D,\u03a3) is finite. For more details, please refer to (Marnette 2009).\nMore Notations. Given a set \u03a3 of rules and a BCQ q, let ||\u03a3|| and ||q|| denote the numbers of symbols occurring in \u03a3 and q, respectively. We assume that the reader is familiar with complexity theory. Given a unary function T on natural numbers, by DTIME(T (n)) we mean the class of complexity languages decidable in time T (n) by a deterministic Turing machine. For k \u2265 0 we let expk(n) denote the function that maps n to n if k = 0, and 2expk\u22121(n) otherwise. By k-EXPTIME we mean the class \u22c3 c\u22650 DTIME(expk(n\nc)). For simplicity, we denote relation symbols (nulls/function symbols, respectively) by capitalized (lower-case, respectively) sans-serif letters, constants by lower-case italic letters a, b, c, variables by lower-case italic letters u, v, w, x, y, z, and terms by lower-case italic letters s, t. All of these symbols may be written with subscripts or superscripts. In addition, bold italic letters u,v,w,x,y, z and s, t are used to range over tuples of variables and terms, respectively."}, {"heading": "Bounded Classes", "text": "In this section, we define a family of rule languages with finite chase, and study its general properties.\nWe first define some notations. Given a ground term t, the height of t, denoted ht(t), is defined as follows:\nht(t) := { 0 if t \u2208 \u2206; max{ht(s) : s \u2208 s}+ 1 if t= f(s) for some f.\nGiven any general instance A, the height of A, denoted ht(A), is defined as the maximum height of terms that have at least one occurrence in A if it exists, and\u221e otherwise. Definition 1. Every bound function is a function from positive integers to positive integers. Let \u03b4 be a bound function. A rule ontology (\u03a3,D,Q) is called \u03b4-bounded if, for all D-databases D, ht(chase(D,\u03a3)) \u2264 \u03b4(||\u03a3||). We let \u03b4BOUNDED denote the class of \u03b4-bounded rule ontologies.\nAs there exist an infinite number of bound functions, it is interesting to know if there is a \u201cmaximum\u201d bound function that captures all \u03b4-bounded rule ontologies for any bound function \u03b4 (or all rule ontologies with finite chase). The following result shows that the answer is definitely \u201cyes\u201d. Proposition 1. There is a bound function \u03b4 such that, for every rule ontology O, O has finite chase iff it is \u03b4-bounded.\nProof. (Sketch) We first construct a bound function \u03b4, and then it suffices to show that every rule ontology with finite chase is \u03b4-bounded. To define \u03b4, we want to prove that, for every rule ontology O = (\u03a3,D,Q), there exists a database D\u2217O such that ht(chase(D,\u03a3)) \u2264 ht(chase(D\u2217O,\u03a3)) for all D-databasesD. This can be done by employing the so-called critical database technique, which was developed in (Marnette 2009). Define \u03b4(n) as the maximum ht(chase(D\u2217O,\u03a3)) among all rule ontologies O = (\u03a3,D,Q) with finite chase such that ||\u03a3|| \u2264 n; we then have the desired function \u03b4. Remark 1. Let BOUNDED be the union of \u03b4-BOUNDED for all bound functions \u03b4. A rule ontology is called bounded if it belongs to BOUNDED. As all bounded rule ontologies have finite chase, by Proposition 1 we have that BOUNDED contains exactly the rule ontologies with finite chase.\nNext, let us define a class of interesting bound functions. Definition 2. Let k be a natural number and let expk be the function defined in the previous section. A rule ontology is called k-exponentially bounded if it is expk-bounded. Remark 2. The MFA class (Grau et al. 2013), which was shown to extend many existing languages with an acyclicity restriction, is defined by restricting the recursive uses of existential variables in Skolem chase. It is not difficult to see that MFA \u2286 exp0-BOUNDED. The following example shows that the inclusion is in fact strict. Example 1. Let O = (\u03a3,D,Q) be a rule ontology, where D = {R} and \u03a3 consists of the following rules:\nR(x, x) \u2192 \u2203yz S(x, y) \u2227 S(y, z) R(x, y) \u2227 S(x, z) \u2192 \u2203v R(z, v)\nThis rule ontology does not belong to the MFA class because the existential variable v might be recursively applied in the Skolem chase (one can check it by letting the database D be {R(a, a)}). As each existential variable can be recursively used at most twice, O is 0-exponentially bounded.\nOne might ask if all bounded ontologies can be captured by exponential bound functions (or computable bound functions). The proposition below shows that this is impossible. Proposition 2. There is no computable bound function \u03b4 such that every bounded rule ontology is \u03b4-bounded."}, {"heading": "Complexity", "text": "Now we study the complexity of bounded classes. We are interested in the complexity of two kinds of important computations: query answering and language membership.\nBoolean Query Answering. The problem to be investigated here, also known as query entailment, is defined as follows: Given a set \u03a3 of rules, a database D and a Boolean query q, decide if D \u222a \u03a3 |= q. We first consider the upper bound. Proposition 3. Let \u03b4 be a bound function. Then for any \u03b4bounded rule ontology (\u03a3,D,Q), any D-database D and any BCQ q over Q, it is in\nDTIME((|dom(D)|+ ||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))\u00b7||q||O(1)) to check whether D \u222a \u03a3 |= q. Proof. (Sketch) First evaluate the size of chase(D,\u03a3). By this we know how many stages are needed for the chase to terminate. Counting the cost of each chase stage and querying on chase(D,\u03a3), we then have the desired result.\nA lower bound for the combined complexity is as follows. Proposition 4. It is (k + 2)-EXPTIME-hard (for the combined complexity) to check, given a k-exponentially bounded rule ontology (\u03a3,D,Q), aD-databaseD and a BCQ q over Q, whether D \u222a \u03a3 |= q. Proof. (Sketch) LetM be any deterministic Turing machine that terminates in expk+2(n) steps on any input of length n. Let D = \u2205 and Q = {Accept} where Accept is a nullary relation symbol. To show the desired result, it suffices to\nshow that, for each input (a binary string) x, there is an expkbounded rule ontology (\u03a3,D,Q) such that M terminates on input x if and only if \u2205 \u222a \u03a3 |= Accept. Let x be an input of length n. To construct the rule set \u03a3, the main difficulty is to define a linear order of length expk+2(n). If the order is defined, by an encoding similar to that in (Dantsin et al. 2001), one can construct a set of datalog rules to encode both M and x. Here we only explain how to define the linear order.\nLet us first consider the case where k is even. The general idea is to construct a sequence of rule sets (\u03a3i)i\u22650. For each i, let Succi,Mini and Maxi be relation symbols intended to define the (immediate) successor relation, the minimum element and the maximum element, respectively, of a linear order. For i > 0, the function of \u03a3i is as follows: If Succi\u22121,Mini\u22121 and Maxi\u22121 define a linear order of length n, then Succi,Mini and Maxi define a linear order on integers (represented in binary strings) from 0 to 22 n\n. To implement each \u03a3i, we generalize a technique used in the proof of Theorem 1 in (Cal\u0131\u0300, Gottlob, and Pieris 2010).\nThe first task is to define the binary strings of length one, i.e. \u201c0\u201d and \u201c1\u201d. This can be done by the following rule:\nMini\u22121(v)\u2192 BSi(v, 0) \u2227 BSi(v, 1) where BSi(v, x) states that x is a binary string of length 2v .\nThe following rules are used to generate binary strings of length 2v+1 by combining two binary strings of length 2v:\nBSi(v, x) \u2227 BSi(v, y) \u2192 \u2203z Ci(v, x, y, z) Ci(v, x, y, z) \u2227 Succi\u22121(v, w) \u2192 BSi(w, z)\nThen, some rules to define a successor relation (w.r.t. the lexicographic order) on strings of length 2v+1 are as follows: [\nCi(v, x, y, z) \u2227 Ci(v, x, y0, z0) \u2227Succ\u2217i (v, y, y0) \u2227 Succi\u22121(v, w)\n] \u2192 Succ\u2217i (w, z, z0)\n  Ci(v, x, y, z) \u2227 Ci(v, x0, y0, z0) \u2227Max\u2217i (v, y) \u2227Min\u2217i (v, y0)\n\u2227Succ\u2217i (v, x, x0) \u2227 Succi\u22121(v, w)\n  \u2192 Succ\u2217i (w, z, z0)\nwhere Succ\u2217i (v, x, y) is intended to assert that y is the immediate successor of x, and both x and y are of length 2v .\nThe minimum and the maximum binary strings of length 2v+1 are defined by the following rules:[\nMin\u2217i (v, x) \u2227Min\u2217i (v, y) \u2227Ci(v, x, y, z) \u2227 Succi\u22121(v, w) ] \u2192 Min\u2217i (w, z)\n[ Max\u2217i (v, x) \u2227Max\u2217i (v, y)\n\u2227Ci(v, x, y, z) \u2227 Succi\u22121(v, w)\n] \u2192 Max\u2217i (w, z)\nNow the desired relations Numi,Succi,Mini and Maxi can be obtained by applying the following rules:\nSucc\u2217i (v, x, y) \u2227Maxi\u22121(v) \u2192 Succi(x, y) Min\u2217i (v, x) \u2227Maxi\u22121(v) \u2192 Mini(x) Max\u2217i (v, x) \u2227Maxi\u22121(v) \u2192 Maxi(x)\nFor all i > 0, let \u03a3i consist of all of the above rules. It is easy to see that \u03a3i is as desired. Let 0, . . . , n\u2212 1 be distinct constants. Let \u03a30 denote the following rule set:\nMin0(0) \u2227Max0(n\u2212 1) Succ0(0, 1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Succ0(n\u2212 2, n\u2212 1)\nNext, let ` = k/2 + 1 and let \u03a3num be the union of \u03a3i for all i with 0 \u2264 i \u2264 `. By the previous analysis, it is not difficult to see that Succ`,Min` and Max` define a linear order on (the binary representions of) integers from 0 to expk+2(n). It is also not difficult to check that the rule ontology (\u03a3num, \u2205, {Accept}) is expk-bounded.\nFor the case where k is odd, we can achieve the goal by some slight modifications to \u03a3num: (i) substituting the least integer greater than or equal to log n for n in \u03a30, and then (ii) setting ` = k/2 + 2. Similarly, we can show that the resulting rule set \u03a3num satisfies the desired property.\nNow, by combining Propositions 3, 4, and the data complexity of Datalog (see, e.g., (Dantsin et al. 2001)), for any k-exponentially bounded class we then have the exact bound of the complexity w.r.t. Boolean query answering. Theorem 5. For all integers k \u2265 0, the Boolean query answering problem of the k-exponentially bounded language is (k+ 2)-EXPTIME-complete for the combined complexity, and PTIME-complete for the data complexity.\nMembership of Language. Now we consider the membership problem of bounded languages. The problem is as follows: Given a rule ontology, check whether it belongs to the bounded language under consideration. Since the boundedness is defined in a semantical way, it is interesting to know how to check whether a rule ontology is \u03b4-bounded. Proposition 6. Let \u03b4 be a bound function that is computable in DTIME(T (n)) for some function T (n). Then for every rule ontology O = (\u03a3,D,Q), it is in\nDTIME(||\u03a3||||\u03a3||O(\u03b4(||\u03a3||)) + T (log ||\u03a3||)O(1)) to check whether O is \u03b4-bounded.\nThe above proposition can be proved by using Marnette\u2019s critical database technique (2009) and then by an analysis similar to that in the proof of Proposition 3. Remark 3. Two immediate corollaries of Proposition 6 are: It is in (k + 2)-EXPTIME to check whether a rule ontology is k-exponentially bounded; moreover, the membership for \u03b4-bounded language is decidable whenever \u03b4 is computable."}, {"heading": "Expressiveness and Succinctness", "text": "Though all rule languages with finite chase are tractable for data complexity (Marnette 2009), in the last section we have shown that their combined complexity could be very high. Hence, a natural question is as follows: Are the languages with high combined complexity really necessary for representing ontological knowledge? In this section, we address this question on two aspects: What is the expressiveness of these languages? How about the succinctness among them?\nUniversal Worldview Mapping. We first propose a semantic (and more general) definition for rule ontologies. Definition 3. LetD andQ be two relational schemas. A universal worldview mapping, or UWM for short, over (D,Q) is a function that maps every D-database D to a general instance Q over Q. Let \u03a6 and \u03a8 be two UWMs over (D,Q). We say that \u03a6 is equivalent to \u03a8, written \u03a6 \u2248 \u03a8, if for allDdatabases, \u03a6(D) is homomorphically equivalent to \u03a8(D).\nIt is clear that \u2248 is an equivalence relation on the UWMs. Next, we show how to define UWMs from rule ontologies. Definition 4. Let O = (\u03a3,D,Q) be any rule ontology. We define [[O]] as the function that maps every D-database D to the general instance chase(D,\u03a3)|Q.\nGiven any rule ontology O, it is clear that [[O]] is a UWM. We say that two rule ontologies O1 and O2 are equivalent if the corresponding UWMs are equivalent, i.e., [[O1]] \u2248 [[O2]]. The following property explains why this is desired. Proposition 7. Let O1 = (\u03a31,D,Q) and O2 = (\u03a32,D,Q) be two rule ontologies with finite chase. Then [[O1]] \u2248 [[O2]] iff, for all D-databases D and all BCQs q over Q, we have"}, {"heading": "D \u222a \u03a31 |= q iff D \u222a \u03a32 |= q.", "text": "In addition, for a technical reason, given a rule ontology O = (\u03a3,D,Q), we require that D andQ are disjoint and no relation symbol in D has an occurrence in the head of any rule in \u03a3.1 We call such rule ontologies normal. These assumptions do not change the expressiveness since, for every relation symbol R \u2208 D \u2229 Q, we can always replace R in D with a fresh relation symbol R\u2032 of the same arity, and then add a copy rule R\u2032(x)\u2192 R(x) into the rule set \u03a3. From Bounded Classes to the WA Class. In this subsection, we show that any bounded ontology can be rewritten to a rule ontology that is weakly acyclic (Fagin et al. 2005).\nLet us first review the notion of weak acyclicity. Fix \u03a3 as a set of rules and R its schema. A position of \u03a3 is a pair (R, i) where R \u2208 R is of an arity n and 1 \u2264 i \u2264 n. The dependency graph of \u03a3 is a directed graph with each position of \u03a3 as a node, and with each pair ((R, i), (S, j)) as an edge if there is a rule \u03d5(x,y)\u2192 \u2203z\u03c8(x, z) from \u03a3 such that \u2022 there is a variable x \u2208 x such that x occurs both in the\nposition (R, i) in \u03d5 and in the position (S, j) in \u03c8, or \u2022 there are variables x \u2208 x and z \u2208 z such that x occurs in\nthe position (R, i) in \u03d5 and z occurs in the position (S, j) in \u03c8 (in this case, the edge is called a special edge).\nA rule ontology (\u03a3,D,Q) is weakly acyclic (WA) if no cycle in the dependency graph of \u03a3 goes through a special edge.\nIt is well-known that the class of WA rule ontologies enjoys the finite chase property. In the last few years, a number of classes have been proposed to extend it. However, the next theorem shows that, in view of the expressiveness, the WA class is no weaker than any class with finite chase. Theorem 8. For every normal rule ontologyO = (\u03a3,D,Q) with finite chase, there exists a weakly acyclic normal rule ontology O\u2217 = (\u03a3\u2217,D,Q) such that [[O]] \u2248 [[O\u2217]].\nWe prove this theorem by developing a translation. The general idea is as follows. Given any normal rule ontology O = (\u03a3,D,Q) with finite chase, we need to construct a weakly acyclic rule ontology O\u2217 = (\u03a3\u2217,D,Q) such that any computation onO can be simulated by a computation on O\u2217. The main difficulty is how to simulate the cyclic existential quantifications by weakly acyclic existential quantifications. Fortunately, by Proposition 1,O is always bounded,\n1This is similar to that in data exchange (Fagin et al. 2005).\nwhich means that the size of any (possibly functional) term generated by the chase procedure of O on any database is bounded by some integer `. Therefore, every (possibly functional) term generated by the chase procedure of O can be encoded by an `-tuple of function-free terms. For every relation symbol R occurring in O, we introduce an auxiliary relation symbol R\u2217 with a larger arity so that every fact of the form R(t) can be encoded by a fact of the form R\u2217(t\u2217).\nWith these settings, we can then construct some rules to simulate the chase procedure of O by that of O\u2217 so that, for every D-database D and every fact R(t) \u2208 chase(D,\u03a3), there exists a fact R\u2217(t\u2217) \u2208 chase(D,\u03a3\u2217) that encodes R(t). These rules can be constructed by an approach similar to that in (Kro\u0308tzsch and Rudolph 2011). So, the remaining task is to decode R(t) from R\u2217(t\u2217). The difficulty of decoding is how to assure that, for each term (that might occur as arguments in different facts) in chase(D,\u03a3), there is exactly one null to be allocated to it. Fortunately again, it can be overcome by some encoding techniques. We will explain this later.\nNow, let us define the translation formally. Let D,Q and \u03a3 be defined as in the theorem. Let \u03b4 be a bound function such that \u03a3 is \u03b4-bounded. Let m be the maximum arity of function symbols appearing in sk(\u03a3). Let ` = \u2211\u03b4(||\u03a3||) i=0 m i and s = (`\u2212 1)/m. Introduce a fresh ` \u00b7n-ary relation symbol2 R\u2217 for each n-ary relation symbol R, introduce a fresh variable vi for each variable v and each i with 1 \u2264 i \u2264 `, and introduce (as a blank symbol to fill the gaps) and all non-nullary function symbols in sk(\u03a3) as fresh constants.\nTo represent a (functional) term t, we first regard t as an m-complete tree with each symbol (function or constant) as a node and arguments of a function symbol f as the children of f. If some node is empty, we then fill it with . The tuple encodes t is then the symbol sequence obtained by a depthfirst traversal. If the tuple is of length < `, we then fill s in the tail. Lastly, we let [t] denote this tuple. For example, if m = 2, ` = 7 and t = f(g(a), b), then [t] = fga b .\nTo activate the simulation, some rules are needed to copy the data of R to R\u2217. Formally, for each n-ary relation symbols R \u2208 D, we need a rule %R, defined as follows:\nR(x1, . . . , xn)\u2192 R\u2217(x1, ?, \u00b7 \u00b7 \u00b7xn, ?) where ? denotes the tuple consisting of `\u22121 consecutive s.\nLet \u03b3 be a rule from \u03a3 of the form \u03d5(x,y)\u2192 \u2203z \u03c8(x, z) where x = x1 \u00b7 \u00b7 \u00b7xk is a permutation of all the variables occurring in both \u03d5 and \u03c8. We need a rule \u03b3\u2217, which will be defined shortly, to simulate \u03b3. For any term t in \u03b3, we let\n\u03c4(t) :=    a \u00b7 \u00b7 \u00b7 if t = a \u2208 \u2206; v1 \u00b7 \u00b7 \u00b7 vs \u00b7 \u00b7 \u00b7 if t = v \u2208 x ; fvx 1 1 \u00b7 \u00b7 \u00b7xs1x12 \u00b7 \u00b7 \u00b7xsk \u00b7 \u00b7 \u00b7 if t = v \u2208 z ;\nv1 \u00b7 \u00b7 \u00b7 v` if t = v \u2208 y . where, in each of the first three cases, the tail of \u03c4(t) is filled with the symbol such that the length of \u03c4(t) is exactly `. Now we define \u03b3\u2217 as the rule \u03d5\u2217 \u2192 \u03c8\u2217, where \u03d5\u2217 and \u03c8\u2217 denote the formulas obtained from \u03d5 and \u03c8, respectively, by\n2In fact, we can use some relation symbol with a smaller arity, but this will make the presentation more complicated.\n\u2022 substituting \u03c4(t) for each term t \u2208 \u2206 \u222a\u2206v , followed by \u2022 substituting R\u2217 for each relation symbol R.\nIn the chase procedure for the new ontology, by applying above rules on a D-database D, we obtain a fact set S\u2217 that encodes chase(D,\u03a3). Thus, as mentioned previously, the remaining task is to construct rules for the decoding. The idea is as follows: (i) let Dom\u2217 be the set of all `-tuples that encode terms with occurrences in chase(D,\u03a3); (ii) for each `-tuple s\u2217 \u2208 Dom\u2217, generate a null n for it (by appying an existential quantifier once), and use Map(s\u2217, n) to record the correspondence between s\u2217 and n; (iii) translate each fact R\u2217(t\u2217) to a fact R(t) by looking up the relation Map.\nTo collect the `-tuples in stage (i), we need the following rules. Given an n-ary relation symbol R \u2208 Q, let \u03bbR denote\nR\u2217(v1, . . . ,vn)\u2192 Dom\u2217(v1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Dom\u2217(vn) where each vi is a tuple of distinct variables v1i \u00b7 \u00b7 \u00b7 vsi , and Dom\u2217 a fresh relation symbol of arity `.\nNext, we define some rules to generate nulls, which implement stage (ii). For each function symbol fx in sk(\u03a3) where x is an existential variable in \u03a3, let \u03b6x denote\nDom\u2217(fx,v)\u2192 \u2203xMap(fx,v, x) where v is a tuple of distinct variables v1 \u00b7 \u00b7 \u00b7 v`\u22121, and Map a fresh (`+1)-ary relation symbol. In addition, let \u03b6c denote\nDom\u2217(x, , . . . , )\u2192 Map(x, , . . . , , x). Informally, this rule asserts that, for any `-tuple that encodes a single-symbol term, we do not need to generate any null.\nNow, we can define rules to carry out the decoding. For each n-ary relation symbol R \u2208 Q, let \u03d1R denote [ R\u2217(v1, . . . ,vn) \u2227Map(v1, x1)\n\u2227 \u00b7 \u00b7 \u00b7 \u2227Map(vn, xn)\n] \u2192 R(x1, . . . , xn).\nFinally, we let \u03a3\u2217 denote the rule set consisting of (1) %R for every relation symbol R \u2208 D, (2) \u03b3\u2217 for every rule \u03b3 \u2208 \u03a3, (3) \u03bbR for every relation symbol R \u2208 Q, (4) \u03b6x for every existential variable x in \u03a3 such that fx is of a positive arity, (5) \u03b6c, and (6) \u03d1R for every relation symbol R \u2208 Q. Example 2. By adding a copy rule into the rule ontology O defined in Example 1, we then obtain a normal rule ontology O0 = (\u03a30,D0,Q0), where \u03a30 is the following rule set:\nD(x, y)\u2192 R(x, y) R(x, x)\u2192 \u2203yz S(x, y) \u2227 S(y, z) R(x, y) \u2227 S(x, z)\u2192 \u2203v R(z, v)\nand D0 = {D}, Q0 = {R}. Next, we will illustrate the translation by the rule ontology O0.\nAll the function symbols in sk(\u03a30) are clearly unary, and as analyzed in Example 1, O0 is \u03b4-bounded for some bound function \u03b4 with \u03b4(||\u03a30||) = 2. So, we have ` = 10+11+12 = 3, i.e., terms generated by the chase procedure of O0 will be encoded by triples of function-free terms. Now, we use the following rule to initialize the auxiliary relation symbol D\u2217:\nD(x, y)\u2192 D\u2217(x y )\nTo simulate the chase procedure of O0, we need the following rules, which correspond to the rules in \u03a30:\nD\u2217(x1x2x3 y1y2y3)\u2192 R\u2217(x1x2x3 y1y2y3) R\u2217(x1x2 x1x2 )\u2192S\u2217(x1x2 fyx1x2)\u2227S\u2217(fyx1x2 fzx1x2) R\u2217(x1x2x3 y1y2y3)\u2227S\u2217(y1y2y3 z1z2 )\u2192R\u2217(z1z2 fvz1z2)\nThe following rules are used to implement the decoding: R\u2217(x1x2x3 y1y2y3)\u2192 Dom\u2217(x1x2x3) \u2227 Dom\u2217(y1y2y3) Dom\u2217(fyx1x2)\u2192 \u2203yMap(fyx1x2 y) Dom\u2217(fzx1x2)\u2192 \u2203zMap(fzx1x2 z) Dom\u2217(fvx1x2)\u2192 \u2203vMap(fvx1x2 v)\nDom\u2217(x )\u2192 Map(x x) [\nR\u2217(x1x2x3 y1y2y3)\u2227 Map(x1x2x3 x) \u2227Map(y1y2y3 y)\n] \u2192 R(x y)\nFinally, let \u03a3\u22170 consist of the set of all rules defined above. It is not difficult to check that [[O0]] \u2248 [[(\u03a3\u22170,D0,Q0)]]. Capturing PTIME by the WA Class. We have proved that all the rule languages with finite chase are of the same expressiveness as the WA class in the last subsection. However, this characterization is syntactic. In this subsection, we will give a complexity-theoretic characterization. Before presenting the result, we need some definitions.\nLike in traditional Datalog (Dantsin et al. 2001), we will study the expressiveness on ordered databases. Every ordered database is a database whose domain is an integer set {0, . . . , n} for some integer n \u2265 0; whose schema contains three special relation symbols Succ, Min and Max (we call such a schema ordered); in which Succ is interpreted as the immediate successor relation on natural numbers, and Min and Max are interpreted as {0} and {n}, respectively. By ordered UWMs we mean the restrictions of UWMs to ordered databases. We generalize definitions of [[\u00b7]] and \u2248 to ordered UWMs by replacing \u201cdatabase\u201d with \u201cordered database\u201d. Note that the ordered version of Proposition 7 still holds.\nWe fix a natural way for representing (general) databases in binary strings. Given a general databaseD, let \u3008D\u3009 denote its binary represention. Let D and Q be any two disjoint relational schemas where D is ordered. Let \u03a6 be an ordered UWM over (D,Q). We say that \u03a6 is computed by a Turing machine M if M halts on any input \u3008D\u3009 where D is an ordered D-database, and there is a general Q-database Q such that Q is homomorphically equivalent to \u03a6(D) and the output w.r.t. \u3008D\u3009 is \u3008Q\u3009, the binary representation of Q.\nOn syntax, we also need a slightly richer language defined as follows. LetD be a relational schema (as a database schema). A semipositive rule w.r.t. D is a generalized rule defined by allowing negated atoms with relation symbols from D to appear in the body. Semipositive rule ontologies are then generalized from rule ontologies by allowing semipositive rules w.r.t. its database schema. A semipositive rule ontology is called weakly acyclic if the rule ontology obtained by omitting negative atoms is weakly acyclic. Theorem 9. For every ordered UWM \u03a6 that is computable in deterministic polynomial time, there is a weakly acyclic and semipositive rule ontology O such that [[O]] \u2248 \u03a6.\nRemark 4. By a slight generalization of the critical database technique proposed in (Marnette 2009), one can show that every semipositive rule ontology with finite Skolem chase is computable in deterministic polynomial time. Therefore, the above theorem implies that every semipositive rule language with finite Skolem chase that extends the semipositive WA class captures the class of PTIME-computable UWMs.\nSuccinctness. Our previous results show that all the rule languages with finite chase that extend the weakly acyclic class are of the same expressiveness. Now we further consider the following question: Is it possible to compare the efficiency of rule languages with finite chase for representing ontological knowledge? In general, it is not an easy task to compare the succinctness for fragments of first-order logic. However, the following theorem provides us with such a result for rule languages, which states that the bounded rule languages with higher combined complexity are normally more succinct than those with lower combined complexity. Theorem 10. For all k > 0, there exists a k-exponentially bounded rule ontologyO=(\u03a3,D,Q) such that, for any (k\u2212 1)-exponentially bounded rule ontology O0 = (\u03a30,D,Q) where \u03a30 is of polynomial size w.r.t. \u03a3, we have [[O0]] 6\u2248 [[O]]. Proof. (Sketch) Let n, ` and \u03a3num be defined as in the proof of Proposition 4. Let D = \u2205 and Q = {Min`,Max`,Succ`}. By using the notion of core (see, e.g., (Deutsch, Nash, and Remmel 2008)), we show a lower bound for the number of nulls in universal models. By estimating the number of nulls to be used in the chase, we then prove that (\u03a3num,D,Q) is not equivalent to any (k \u2212 1)-exponentially bounded ontology (\u03a3,D,Q) if \u03a3 is of a polynomial size w.r.t. \u03a3num. Remark 5. Theorem 10 tells us that, although extending the WA class to larger classes with finite chase does not increase the expressiveness, the succinctness could be a bonus.\nRemark 6. It would be interesting to compare the succinctness of finite-chase rule languages with the same combined complexity under query answering. For instance, is the MFA class more succinct than the WA class? But this is beyond the scope of this work. We will pursue it in the future."}, {"heading": "Concluding Remarks", "text": "We have studied the existential rule languages with finite chase in this paper. Instead of considering specific rule languages like most current works on this topic, here we have defined a family of rule languages based on a new concept called \u03b4-boundedness, from which the overall complexity and expressiveness characterizations on these languages have been provided. Our study on this topic may be further undertaken in various directions. One interesting yet challenging future work is to investigate disjunctive existential rule languages. It is important to discover whether our approach can be extended to identify decidable disjunctive existential rule languages and to characterize relevant complexity and expressiveness properties. Results on this aspect may significantly enhance our current understanding on ontological reasoning with disjunctive existential rules (Alviano et al. 2012; Bourhis, Morak, and Pieris 2013)."}, {"heading": "Appendix: Detailed Proofs", "text": ""}, {"heading": "Proof of Proposition 1", "text": "Proposition 1. There is a bound function \u03b4 such that, for every rule ontology O, O has finite chase iff it is \u03b4-bounded.\nTo show this, we use a technique developed by (Marnette 2009). Let O = (\u03a3,D,Q) be a rule ontology. Let C denote the set of constants appearing in \u03a3 and let \u2217 be a special constant without occurrence in \u03a3. A database over D is called critical forO if each relation in it is a full relation on the domain C \u222a {\u2217}. Clearly, the critical database for O is unique. For convenience, let D\u2217O denote the critical database of O.\nProof of Proposition 1. Given an arbitrary bound function \u03b4, it is clear that every \u03b4-bounded rule ontology has finite chase. So, it suffices to show that there is a bound function \u03b4 such that every rule ontology with finite chase is \u03b4-bounded. To do this, we first need to prove a claim as follow.\nClaim 1. Let O = (\u03a3,D,Q) be a rule ontology and D a D-database. Then ht(chase(D,\u03a3)) \u2264 ht(chase(D\u2217O,\u03a3)).\nProof. Let f denote the function that maps every constant in \u2206 to itself if it appears in \u03a3, and \u2217 otherwise. Furthermore, we generalize f to terms, atoms and general instances in the standard way. By a routine induction, one can easily show that f(chasen(D,\u03a3)) \u2286 chasen(D\u2217O,\u03a3) for all n \u2265 0, which implies f(chase(D,\u03a3)) \u2286 chase(D\u2217O,\u03a3) immediately. Since ht(f(t)) = ht(t) for every term t, we can then conclude that ht(chase(D,\u03a3)) \u2264 ht(chase(D\u2217O,\u03a3)).\nNow we are in the position to complete the proof. Let p be a function that maps each rule ontology O = (\u03a3,D,Q) with finite chase to ht(chase(D\u2217O,\u03a3)). It is clear that p(O) is a positive integer for any rule ontology O with finite chase. Now, for all n > 0 let \u03b4(n) be the maximal p(O) for all rule onologies O = (\u03a3,D,Q) with finite chase and ||\u03a3|| = n. Since the number of rule sets of size n is finite, \u03b4 should be a bound function. By Claim 1, every rule ontology with finite chase is clearly \u03b4-bounded, which is as desired."}, {"heading": "Proof of Proposition 2", "text": "Proposition 2. There is no computable bound function \u03b4 such that every bounded rule ontology is \u03b4-bounded.\nProof. Towards a contradiction, we assume that such a computable function \u03b4 exists. Let \u03a3 be any rule ontology. Then, by Remark 1, to check whether \u03a3 has finite chase, it is equivalent to check whether \u03a3 is \u03b4-bounded. Since \u03b4 is computable, by Proposition 6 (whose proof is given shortly in this appendix), there is an algorithm to check whether \u03a3 is \u03b4-bounded. This means that the problem of checking whether a rule ontology has finite Skolem chase is decidable, which contradicts with Theorem 4 in (Marnette 2009), which states that it is RE-complete to decide whether a tg schema-mapping (i.e., rule ontology) has finite Skolem chase. This completes the proof."}, {"heading": "Proof of Proposition 3", "text": "Proposition 3. Let \u03b4 be a bound function. Then for any \u03b4bounded rule ontology (\u03a3,D,Q), any D-database D and any BCQ q over Q, it is in\nDTIME((|dom(D)|+ ||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))\u00b7||q||O(1)) to check whether D \u222a \u03a3 |= q. Proof. Let (\u03a3,D,Q) be a \u03b4-bounded rule ontology, D a D-database, and q a BCQ over Q. Let k, n, `, m, and c denote the number of relation symbols appearing in \u03a3, the maximal arity of relation symbols appearing in \u03a3, the number of function symbols in sk(\u03a3), the maximal arity of function symbols appearing in sk(\u03a3), and the number of constants appearing in D, respectively. Let R(t) be any fact in chase(D,\u03a3). By the definition of \u03b4-boundedness, it is clear that every component t \u2208 t contains at most\u2211\u03b4(||\u03a3||) i=0 m\ni = mO(\u03b4(||\u03a3||)) symbols, and each symbol is either a constant or a function symbol. So, chase(D,\u03a3) consists of (c + `)m\nO(\u03b4(||\u03a3||))\u00b7n \u00b7 k facts. Since k, n, `,m \u2264 ||\u03a3|| and c = |dom(D)|, the chase on D and \u03a3 must terminate in (|dom(D)| + ||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))\u00b7||\u03a3||O(1) steps. It is also clear that each step of the chase can be computed in DTIME((|dom(D)|+||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))). Thus, chase(D,\u03a3) can be computed in DTIME((|dom(D)|+ ||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))), too.\nTo complete the query answering, it is now sufficient to evaluate q on chase(D,\u03a3) directly. Without loss of generality, we assume that q is in prenex normal form. Let s be the number of existential variables occurring in q. To evaluate the chase, it is equivalent to check whether there is a substitution h, mapping every existential variable to a ground term of height less than \u03b4(||\u03a3||), such that h(q) \u2286 chase(D,\u03a3). By the previous analysis, there are at most (|dom(D)| + ||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))\u00b7s substitutions that need to be check. In addition, it is in DTIME((|dom(D)| + ||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))\u00b7||q||O(1)) to check whether h(q) \u2286 chase(D,\u03a3). Since s \u2264 ||q||, the evaluation can then be finished in DTIME((|dom(D)| + ||\u03a3||)||\u03a3||O(\u03b4(||\u03a3||))\u00b7||q||O(1)). Combining it with the result in previous paragraph, we then have the desired proposition."}, {"heading": "Proof of Theorem 5", "text": "Theorem 5. For all integers k \u2265 0, the Boolean query answering problem of the k-exponentially bounded language is (k + 2)-EXPTIME-complete for the combined complexity, and PTIME-complete for the data complexity.\nProof. The combined complexity is by Propositions 3 and 4. The membership of the data complexity is by Proposition 3 (also in fact implied by Theorem 3 of (Marnette 2009)), and the hardness follows from the PTIME-completeness of data complexity for Datalog, see, e.g., (Dantsin et al. 2001)."}, {"heading": "Proof of Proposition 6", "text": "Proposition 6. Let \u03b4 be a bound function that is computable in DTIME(T (n)) for some function T (n). Then for every rule ontology O = (\u03a3,D,Q), it is in\nDTIME(||\u03a3||||\u03a3||O(\u03b4(||\u03a3||)) + T (log ||\u03a3||)O(1))\nto check whether O is \u03b4-bounded.\nProof. Let O = (\u03a3,D,Q) be a rule ontology. According to Claim 1, we can infer that O is \u03b4-bounded if and only if ht(chase(D\u2217O,\u03a3)) \u2264 \u03b4(||\u03a3||), where D\u2217O is the critical database defined as previous. So, to check ifO is \u03b4-bounded, it is equivalent to check if ht(chase(D\u2217O,\u03a3)) \u2264 \u03b4(||\u03a3||). By the analysis in the proof of Proposition 3, if the inequality holds, chase(D\u2217\u03a3,\u03a3) should be of the size ||\u03a3||||\u03a3|| O(\u03b4(||\u03a3||)) . In particular, an upper bound for this size can be computed in DTIME((||\u03a3|| + T (log ||\u03a3||))O(1)). Let n denote the resulting upper bound. Now, we can design an algorithm to simulate the first n + 1 stages of the chase on D\u2217O and \u03a3. If ht(chasen+1(D\u2217O,\u03a3)) \u2264 \u03b4(||\u03a3||), then \u03a3 should be \u03b4-bounded, otherwise not. It is clear that the full computation can be implemented in DTIME(||\u03a3||||\u03a3||O(\u03b4(||\u03a3||)) + T (log ||\u03a3||)O(1))."}, {"heading": "Proof of Proposition 7", "text": "Proposition 7. Let O1 = (\u03a31,D,Q) and O2 = (\u03a32,D,Q) be two rule ontologies with finite chase. Then [[O1]] \u2248 [[O2]] iff, for all D-databases D and all BCQs q over Q, we have"}, {"heading": "D \u222a \u03a31 |= q iff D \u222a \u03a32 |= q.", "text": "Proof. The direction of \u201conly-if\u201d is trivial. We only show the converse. Assume thatD\u222a\u03a31 |= q if and only ifD\u222a\u03a32 |= q for all D-databases D and all BCQs q over Q. Let D be any D-database. For i = 1 or 2, let qi denote the BCQ obtained from chase(D,\u03a3i) by replacing each null (i.e., a functional term) by a fresh existential variable. Note that both O1 and O2 have finite chase, so such BCQs exist. Then it is clear that D \u222a \u03a3i |= qi. Thus, by the assumption we have that chase(D,\u03a32) |= q1 and chase(D,\u03a31) |= q2. From these, we can infer that chase(D,\u03a31) and chase(D,\u03a31) are homomorphically equivalent. This completes the proof."}, {"heading": "Proof of Theorem 8", "text": "Theorem 8. For every normal rule ontologyO = (\u03a3,D,Q) with finite chase, there exists a weakly acyclic normal rule ontology O\u2217 = (\u03a3\u2217,D,Q) such that [[O]] \u2248 [[O\u2217]]. Proof. Let R be the schema of \u03a3, and let R\u2217 consist of R\u2217 for all relation symbols R \u2208 R. Given a ground term t, let [t] be defined as previous (after the statement of Theorem 8). Now, we need to generalized the mapping [\u00b7] to atoms and general instances. For any atom \u03b1 of the form R(t1, . . . , tn), we define [\u03b1] = R\u2217([t1], . . . , [tn]). Given any general instance I , let [I] denote the set of [\u03b1] for all \u03b1 \u2208 I . To prove the desired theorem, we need two claims.\nClaim 2. [chasen(D,\u03a3)]\u2286chasen+1(D,\u03a3\u2217)|R\u2217 for n \u2265 0. Proof of Claim 2. We show this by an induction on n. It is clear for n = 0 since chase0(D,\u03a3) = D and any fact from [D] can be obtained from D by applying rules %R in one chase stage. Assume n > 0, and suppose as inductive hypothesis that [chasen\u22121(D,\u03a3)] \u2286 chasen(D,\u03a3\u2217)|R\u2217 . Let \u03b1 \u2208 [chasen(D,\u03a3)] be an atom of form [R(t1, . . . , tk)] for some R \u2208 R. Then it is clear that R(t1, . . . , tk) \u2208 chasen(D,\u03a3). By the definition of chase, there exist a rule \u03b3 \u2208 \u03a3 and a\nsubstitution h such that h(body(\u03b3)) \u2286 chasen\u22121(D,\u03a3) and R(t1, . . . , tk) \u2208 h(head(\u03b3)). By the inductive hypothesis, we can conclude that [h(body(\u03b3))] \u2286 chasen(D,\u03a3\u2217). Let [h] be the substitution that maps each variable x to [h(x)]. We then have that [h](body(\u03b3\u2217)) \u2286 chasen(D,\u03a3\u2217). Consequently, it holds that [h](head(\u03b3\u2217)) \u2286 chasen+1(D,\u03a3\u2217), or equivalently [h(head(\u03b3))] \u2286 chasen+1(D,\u03a3\u2217). Thus, we have \u03b1 \u2208 chasen+1(D,\u03a3\u2217). This yields the desired claim.\nClaim 3. [chasen(D,\u03a3)] \u2287 chasen(D,\u03a3\u2217)|R\u2217 for n \u2265 0. Proof of Claim 3. Again, we show this by an induction on n. It is clearly true for n = 0 since chase0(D,\u03a3\u2217)|R\u2217 = \u2205. Now we assume n > 0 and suppose as inductive hypothesis that [chasen\u22121(D,\u03a3)] \u2287 chasen\u22121(D,\u03a3\u2217)|R\u2217 . Let \u03b1\u2217 be any atom from chasen(D,\u03a3\u2217). By the definition of chase, there must exist a rule \u03b30 \u2208 \u03a3\u2217 and an assignment h\u2217 such that h\u2217(body(\u03b30)) \u2286 chasen\u22121(D,\u03a3\u2217) and \u03b1\u2217 \u2208 h\u2217(head(\u03b30)). So it suffices to show \u03b1\u2217 \u2208 [chasen(D,\u03a3)] for each of the following cases: (1) \u03b30 = %R for some R \u2208 D; (2) \u03b30 = \u03b3\u2217 for some \u03b3 \u2208 \u03a3. Let us first assume case (1), and suppose that \u03b1\u2217 is of form R\u2217(c1, ?, \u00b7 \u00b7 \u00b7 , ck, ?) for some k-ary relation symbol R \u2208 D, where ? denotes the tuple consisting of ` \u2212 1 consecutive s. Then, it is not difficult to see that R(c1, . . . , ck) \u2208 D, which implies \u03b1\u2217 \u2208 [chasen(D,\u03a3)] immediately. Next, let us consider case (2). Let \u03b3 be the rule from \u03a3 such that \u03b30 = \u03b3\u2217. Let h be an assignment that maps each variable x to [h\u2217(x)]\u22121, where [\u00b7]\u22121 denotes the inverse function of [\u00b7]. (Clearly, such a function exists.) Then, by the definition of \u03b3\u2217, it is clear that [\u03b1\u2217]\u22121 \u2208 h(head(\u03b3)). To show \u03b1\u2217 \u2208 [chasen(D,\u03a3)], it is enough to show h(body(\u03b3)) \u2286 chasen\u22121(D,\u03a3), which can be obtained from the definition of \u03b3\u2217 and the inductive hypothesis.\nBy these two claims, we then have that [chase(D,\u03a3)] = chase(D,\u03a3\u2217)|R\u2217 . On the other hand, let g be a function that maps each variable-free `-tuple t to the first component of t if the second component of t is , and fx(t) (where x is a variable) otherwise. By rules \u03b6x and \u03b6c, we see that Map is the graph of g. Let h be the function that maps each term t to g([t]). It is not difficult to check that h is a homomorphism from chase(D,\u03a3)|Q to chase(D,\u03a3\u2217)|Q and h\u22121 is a homomorphism from chase(D,\u03a3\u2217)|Q to chase(D,\u03a3)|Q."}, {"heading": "Proof of Theorem 9", "text": "Theorem 9. For every ordered UWM \u03a6 that is computable in deterministic polynomial time, there is a weakly acyclic and semipositive rule ontology O such that [[O]] \u2248 \u03a6. Proof. Let \u03a6 be a UWM for ordered database that is computed by a deterministic Turing machine M in polynomial time, where D and Q are disjoint relational schemas. Then there is an integer k \u2265 0 such that M will halt on every orderedD-database D in |dom(D)|k steps. To show the theorem, it is sufficient to construct a weakly acyclic and semipositive rule ontology O = (\u03a3,D,Q) such that [[O]] \u2248 \u03a6. W.l.o.g., we assume theM has only three tape symbols: \u201c0\u201d, \u201c1\u201d and \u201c \u201d (the blank symbol), and a one-way tape in which cells are indexed by natural numbers. Both the input and output are stored on the tape started from the 0-th cell.\nLet D be any ordered D-database. Again, the first task is to define a linear order of length \u2265 |dom(D)|k. Clearly, we can use the following rule to assert that the unary relation Const consists of all the constants from the domain of D:\nSucc(x, y)\u2192 Const(x) \u2227 Const(y). With it, we can then generate |dom(D)|k new elements by\nConst(x1) \u2227 \u00b7 \u00b7 \u00b7Const(xk)\u2192 \u2203y G(x1, . . . , xk, y) where new elements are stored in the last argument of G. To define a linear order (it can be built from the original order Succ) on these new elements, we need the following rule[\nG(xi, y,zi, u) \u2227 G(xi, y0,vi, w) \u2227Succ(y, y0) \u2227Max(z) \u2227Min(v)\n] \u2192 Succ\u2217(u,w)\nfor each i with 1 \u2264 i \u2264 k, where xi is an (i \u2212 1)-tuple of distinct variables, and zi and vi denote the (k\u2212i\u22121)-tuples z \u00b7 \u00b7 \u00b7 z and v \u00b7 \u00b7 \u00b7 v, respectively. Clearly, Succ\u2217 defines a linear order on new elements (the lexicographical order generated from Succ). For technical reasons, we will combine it with the old order. This can be done by the following rules:\nMin(x) \u2192 Min\u2217(x) Succ(x, y) \u2192 Succ\u2217(x, y)\nMax(x) \u2227Min(y) \u2227 G(y, . . . , y, z) \u2192 Succ\u2217(x, z) Max(x) \u2227 G(x, . . . , x, y) \u2192 Max\u2217(y)\nNow, by applying the above rules, we then have a linear order of length |dom(D)|+ |dom(D)|k. To complete the construction, we still need to define some arithmetical relations. This can be done in a routine way, e.g., we can define the relation Add of addition by the following rules:\nSucc\u2217(x, y)\u2192 Num(x) \u2227 Num(y) Num(x) \u2227Min\u2217(y)\u2192 Add(x, y, x)\nAdd(x, y, z) \u2227 Succ\u2217(y, u) \u2227 Succ\u2217(z, v)\u2192 Add(x, u, v) In addition, we let LE\u2217 define the relation \u201cless than or equal to\u201d. It can be defined by the following rules:\nNum(x)\u2192 LE\u2217(x, x) Succ\u2217(x, y)\u2192 LE\u2217(x, y)\nLE\u2217(x, y) \u2227 LE\u2217(y, z)\u2192 LE\u2217(x, z) With the linear order and arithmetical relations, we are then in the position to represent the Turing machine M . Without loss of generality, we assume D = {D0, . . .Dd} andQ = {Q0, . . .Qq} for some d, q > 0. We let DPosi(x, v) be a binary relation asserting that the truth of fact Di(x) has been stored in the v-th tape cell initially; QPosi(x, v) be a binary relation asserting that the truth of fact Qi(x) should be stored in the v-th tape cell finally; DSize(x) and QSize(y) asserting that the sizes of input string and output string are x and y, respectively. It is not difficult to see that, for a natural encoding approach of the (general) database, these relations can be defined by using some arithmetical relations.\nTo set the initial configuration, we need following rules Min\u2217(x)\u2192 Head(x, x) \u2227 State(x, s0)\nDi(v) \u2227 DPosi(v, x) \u2227Min\u2217(y)\u2192 Tape(y, x, 1) \u00acDi(v) \u2227 DPosi(v, x) \u2227Min\u2217(y)\u2192 Tape(y, x, 0) DSize(z) \u2227 LE\u2217(z, x) \u2227Min\u2217(y)\u2192 Tape(y, x, )\nfor each relation symbol Di \u2208 D, where Tape(x, y, z) states that, in time x, the tape symbol z is written on the y-th tape cell, State(x, y) states that, in time x, the state of M is y, and Head(x, y) states that, in time x, the head of M is under the y-th tape cell. The last rule says that every tape cell after the input string are initially written as \u201c \u201d.\nThe rules that define the state transitions of M are similar to those in the proof of Theorem 7.2 in (Dantsin et al. 2001). Hence, it remains to define rules for output. For each relation symbol Qi \u2208 Q, we define the following rule QPosi(v, x) \u2227 Tape(y, x, 1) \u2227Max\u2217(y)\u2192 Qi(v)\nInformally, the function of these rules is to reconstruct the query (general) database from the output of M . Here, we assume that M do the operation \u201cnop\u201d repeatedly so that it will terminate at the |dom(D)|+ |dom(D)|k-th stage."}, {"heading": "Proof of Theorem 10", "text": "Theorem 10. For all k > 0, there exists a k-exponentially bounded rule ontologyO=(\u03a3,D,Q) such that, for any (k\u2212 1)-exponentially bounded rule ontology O0 = (\u03a30,D,Q) where \u03a30 is of polynomial size w.r.t. \u03a3, we have [[O0]] 6\u2248 [[O]].\nProof. Let n, ` and \u03a3num be defined as in the proof of Proposition 4. Let D = \u2205 and Q = {Min`,Max`,Succ`}, and let m = expk+2(n) \u2212 1. Let Q be a general database over Q that consists of Min`(n0),Max`(nm) and Succ`(ni, ni+1) for all integers i with 0 \u2264 i < m, where (ni)0\u2264i\u2264m are distinct nulls. By the analysis in the proof of Proposition 4, it is clear that [[(\u03a3num,D,Q)]](\u2205) is homomorphically equivalent to Q. (Note that \u2205 is the only database over schema D.) Since the core of Q is Q, Q should be the least universal model of \u2205\u222a\u03a3num. Towards a contradiction, we assume that there exists a (k \u2212 1)-exponentially bounded rule ontology O = (\u03a3,D,Q) such that [[O]] = [[(\u03a3num,D,Q)]] and \u03a3 is of polynomial size w.r.t. \u03a3num. Then [[O]] is homomorphically equivalent to Q. This implies that [[O]](\u2205) contains at least expk+2(n) nulls. On the other hand, as \u03a3 is of polynomial size w.r.t. \u03a3num, by the analysis in the proof of Proposition 3, we infer that the size of chase(\u2205,\u03a3) is expk+1(O(n)). This means that chase(\u2205,\u03a3), or equivalently [[O]](\u2205), contains expk+1(O(n)) nulls, a contradiction as desired."}], "references": [{"title": "Disjunctive datalog with existential quantifiers: Semantics, decidability, and complexity issues", "author": ["M. Alviano", "W. Faber", "N. Leone", "M. Manna"], "venue": "Theor. Pract. Log. Prog. 12:701\u2013718.", "citeRegEx": "Alviano et al\\.,? 2012", "shortCiteRegEx": "Alviano et al\\.", "year": 2012}, {"title": "Expressive languages for querying the semantic web", "author": ["M. Arenas", "G. Gottlob", "A. Pieris"], "venue": "Proc. PODS-2014, 14\u201326.", "citeRegEx": "Arenas et al\\.,? 2014", "shortCiteRegEx": "Arenas et al\\.", "year": 2014}, {"title": "On rules with existential variables: Walking the decidability line", "author": ["J. Baget", "M. Lecl\u00e8re", "M. Mugnier", "E. Salvat"], "venue": "Artif. Intell. 175(9-10):1620\u20131654.", "citeRegEx": "Baget et al\\.,? 2011a", "shortCiteRegEx": "Baget et al\\.", "year": 2011}, {"title": "Walking the complexity lines for generalized guarded existential rules", "author": ["J. Baget", "M. Mugnier", "S. Rudolph", "M. Thomazo"], "venue": "Proc. IJCAI-2011, 712\u2013717.", "citeRegEx": "Baget et al\\.,? 2011b", "shortCiteRegEx": "Baget et al\\.", "year": 2011}, {"title": "Extending acyclicity notions for existential rules", "author": ["J. Baget", "F. Garreau", "M. Mugnier", "S. Rocher"], "venue": "Proc. ECAI-2014, 39\u201344.", "citeRegEx": "Baget et al\\.,? 2014", "shortCiteRegEx": "Baget et al\\.", "year": 2014}, {"title": "The implication problem for data dependencies", "author": ["C. Beeri", "M.Y. Vardi"], "venue": "Proc. ICALP-1981, 73\u201385.", "citeRegEx": "Beeri and Vardi,? 1981", "shortCiteRegEx": "Beeri and Vardi", "year": 1981}, {"title": "The impact of disjunction on query answering under guarded-based existential rules", "author": ["P. Bourhis", "M. Morak", "A. Pieris"], "venue": "Proc. IJCAI-2013, 796\u2013802.", "citeRegEx": "Bourhis et al\\.,? 2013", "shortCiteRegEx": "Bourhis et al\\.", "year": 2013}, {"title": "Datalog+/-: A family of logical knowledge representation and query languages for new applications", "author": ["A. Cal\u0131", "G. Gottlob", "T. Lukasiewicz", "B. Marnette", "A. Pieris"], "venue": "In Proc. LICS-2010,", "citeRegEx": "Cal\u0131\u0300 et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Cal\u0131\u0300 et al\\.", "year": 2010}, {"title": "A general datalogbased framework for tractable query answering over ontologies", "author": ["A. Cal\u0131", "G. Gottlob", "T. Lukasiewicz"], "venue": "J. Web Sem", "citeRegEx": "Cal\u0131\u0300 et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Cal\u0131\u0300 et al\\.", "year": 2012}, {"title": "Query answering under non-guarded rules in Datalog+/", "author": ["A. Cal\u0131", "G. Gottlob", "A. Pieris"], "venue": "In Proc. RR-2010,", "citeRegEx": "Cal\u0131\u0300 et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Cal\u0131\u0300 et al\\.", "year": 2010}, {"title": "Towards more expressive ontology languages: The query answering problem", "author": ["A. Cal\u0131", "G. Gottlob", "A. Pieris"], "venue": null, "citeRegEx": "Cal\u0131\u0300 et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Cal\u0131\u0300 et al\\.", "year": 2012}, {"title": "Complexity and expressive power of logic programming", "author": ["E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov"], "venue": "ACM Comput. Surv. 33(3):374\u2013425.", "citeRegEx": "Dantsin et al\\.,? 2001", "shortCiteRegEx": "Dantsin et al\\.", "year": 2001}, {"title": "The chase revisited", "author": ["A. Deutsch", "A. Nash", "J. Remmel"], "venue": "Proc. PODS-2008, 149\u2013158.", "citeRegEx": "Deutsch et al\\.,? 2008", "shortCiteRegEx": "Deutsch et al\\.", "year": 2008}, {"title": "Data exchange: Semantics and query answering", "author": ["R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa"], "venue": "Theor. Comput. Sci. 336(1):89\u2013124.", "citeRegEx": "Fagin et al\\.,? 2005", "shortCiteRegEx": "Fagin et al\\.", "year": 2005}, {"title": "Expressiveness of guarded existential rule languages", "author": ["G. Gottlob", "S. Rudolph", "M. Simkus"], "venue": "Proc. PODS-2014, 27\u201338.", "citeRegEx": "Gottlob et al\\.,? 2014", "shortCiteRegEx": "Gottlob et al\\.", "year": 2014}, {"title": "Acyclicity notions for existential rules and their application to query answering in ontologies", "author": ["B.C. Grau", "I. Horrocks", "M. Kr\u00f6tzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang"], "venue": "J. Artif. Intell. Res. 47:741\u2013808.", "citeRegEx": "Grau et al\\.,? 2013", "shortCiteRegEx": "Grau et al\\.", "year": 2013}, {"title": "Stratification criteria and rewriting techniques for checking chase termination", "author": ["S. Greco", "F. Spezzano", "I. Trubitsyna"], "venue": "PVLDB 4(11):1158\u20131168.", "citeRegEx": "Greco et al\\.,? 2011", "shortCiteRegEx": "Greco et al\\.", "year": 2011}, {"title": "Extending decidable existential rules by joining acyclicity and guardedness", "author": ["M. Kr\u00f6tzsch", "S. Rudolph"], "venue": "Proc. IJCAI2011, 963\u2013968.", "citeRegEx": "Kr\u00f6tzsch and Rudolph,? 2011", "shortCiteRegEx": "Kr\u00f6tzsch and Rudolph", "year": 2011}, {"title": "Efficiently computable datalog\u2203 programs", "author": ["N. Leone", "M. Manna", "G. Terracina", "P. Veltri"], "venue": "Proc. KR-2012, 13\u201323.", "citeRegEx": "Leone et al\\.,? 2012", "shortCiteRegEx": "Leone et al\\.", "year": 2012}, {"title": "Generalized schema-mappings: from termination to tractability", "author": ["B. Marnette"], "venue": "Proc. PODS-2009, 13\u201322.", "citeRegEx": "Marnette,? 2009", "shortCiteRegEx": "Marnette", "year": 2009}, {"title": "Existential rule languages with finite chase: Complexity and expressiveness", "author": ["H. Zhang", "Y. Zhang", "J.-H. You"], "venue": "CoRR abs/1411.5220.", "citeRegEx": "Zhang et al\\.,? 2014", "shortCiteRegEx": "Zhang et al\\.", "year": 2014}], "referenceMentions": [{"referenceID": 7, "context": ", (Cal\u0131\u0300 et al. 2010; Baget et al. 2011a).", "startOffset": 2, "endOffset": 41}, {"referenceID": 2, "context": ", (Cal\u0131\u0300 et al. 2010; Baget et al. 2011a).", "startOffset": 2, "endOffset": 41}, {"referenceID": 5, "context": "Therefore, the problem of query answering under existential rule languages is in general undecidable (Beeri and Vardi 1981).", "startOffset": 101, "endOffset": 123}, {"referenceID": 3, "context": ", guarded rules (Cal\u0131\u0300, Gottlob, and Lukasiewicz 2012), greedy bounded treewidth sets (Baget et al. 2011b), sticky sets (Cal\u0131\u0300, Gottlob, and Pieris 2012), and Shy programs (Leone et al.", "startOffset": 86, "endOffset": 106}, {"referenceID": 18, "context": "2011b), sticky sets (Cal\u0131\u0300, Gottlob, and Pieris 2012), and Shy programs (Leone et al. 2012).", "startOffset": 72, "endOffset": 91}, {"referenceID": 19, "context": "This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Kr\u00f6tzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al.", "startOffset": 133, "endOffset": 148}, {"referenceID": 17, "context": "This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Kr\u00f6tzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al.", "startOffset": 228, "endOffset": 255}, {"referenceID": 15, "context": "This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Kr\u00f6tzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al. 2013), and some dependency relations by (Baget et al.", "startOffset": 328, "endOffset": 346}, {"referenceID": 4, "context": "2013), and some dependency relations by (Baget et al. 2014).", "startOffset": 40, "endOffset": 59}, {"referenceID": 15, "context": "In addition, many ontologies in various domains turn out to be in the MFA class, as evidenced in (Grau et al. 2013).", "startOffset": 97, "endOffset": 115}, {"referenceID": 10, "context": "In their milestone paper, Fagin et al. (2005) formulated a concept called weak acyclicity (WA) as a sufficient condition to ensure the chase termination for existential rules.", "startOffset": 26, "endOffset": 46}, {"referenceID": 19, "context": "The uniformity on data complexity is in fact due to an interesting result proved in (Marnette 2009), which states that every rule language with finite Skolem chase is in PTIME for data complexity.", "startOffset": 84, "endOffset": 99}, {"referenceID": 15, "context": "The results presented in this paper not only generalize some of the existing works, such as the two acyclicity notions of MFA and MSA proposed in (Grau et al. 2013), more importantly, they provide a global landscape for characterizing the existential rule languages with finite Skolem chase.", "startOffset": 146, "endOffset": 164}, {"referenceID": 19, "context": "For more details, please refer to (Marnette 2009).", "startOffset": 34, "endOffset": 49}, {"referenceID": 19, "context": "This can be done by employing the so-called critical database technique, which was developed in (Marnette 2009).", "startOffset": 96, "endOffset": 111}, {"referenceID": 15, "context": "The MFA class (Grau et al. 2013), which was shown to extend many existing languages with an acyclicity restriction, is defined by restricting the recursive uses of existential variables in Skolem chase.", "startOffset": 14, "endOffset": 32}, {"referenceID": 11, "context": "If the order is defined, by an encoding similar to that in (Dantsin et al. 2001), one can construct a set of datalog rules to encode both M and x.", "startOffset": 59, "endOffset": 80}, {"referenceID": 11, "context": ", (Dantsin et al. 2001)), for any k-exponentially bounded class we then have the exact bound of the complexity w.", "startOffset": 2, "endOffset": 23}, {"referenceID": 19, "context": "The above proposition can be proved by using Marnette\u2019s critical database technique (2009) and then by an analysis similar to that in the proof of Proposition 3.", "startOffset": 45, "endOffset": 91}, {"referenceID": 19, "context": "Though all rule languages with finite chase are tractable for data complexity (Marnette 2009), in the last section we have shown that their combined complexity could be very high.", "startOffset": 78, "endOffset": 93}, {"referenceID": 13, "context": "In this subsection, we show that any bounded ontology can be rewritten to a rule ontology that is weakly acyclic (Fagin et al. 2005).", "startOffset": 113, "endOffset": 132}, {"referenceID": 13, "context": "This is similar to that in data exchange (Fagin et al. 2005).", "startOffset": 41, "endOffset": 60}, {"referenceID": 17, "context": "These rules can be constructed by an approach similar to that in (Kr\u00f6tzsch and Rudolph 2011).", "startOffset": 65, "endOffset": 92}, {"referenceID": 11, "context": "Like in traditional Datalog (Dantsin et al. 2001), we will study the expressiveness on ordered databases.", "startOffset": 28, "endOffset": 49}, {"referenceID": 19, "context": "By a slight generalization of the critical database technique proposed in (Marnette 2009), one can show that every semipositive rule ontology with finite Skolem chase is computable in deterministic polynomial time.", "startOffset": 74, "endOffset": 89}], "year": 2015, "abstractText": "Finite chase, or alternatively chase termination, is an important condition to ensure the decidability of existential rule languages. In the past few years, a number of rule languages with finite chase have been studied. In this work, we propose a novel approach for classifying the rule languages with finite chase. Using this approach, a family of decidable rule languages, which extend the existing languages with the finite chase property, are naturally defined. We then study the complexity of these languages. Although all of them are tractable for data complexity, we show that their combined complexity can be arbitrarily high. Furthermore, we prove that all the rule languages with finite chase that extend the weakly acyclic language are of the same expressiveness as the weakly acyclic one, while rule languages with higher combined complexity are in general more succinct than those with lower combined complexity.", "creator": "LaTeX with hyperref package"}}}