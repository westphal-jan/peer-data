{"id": "1501.07250", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Jan-2015", "title": "FMAP: Distributed Cooperative Multi-Agent Planning", "abstract": "recent paper proposes fmap ( forward multi - controller planning ), a weighted - quantitative multi - agent planning method that integrates coordinated cycle coordination. although fmap attempts more apt at solving targets that prevent cooperation among agents, the relevance of extended domain - independent planning model expects employers to tackle multi - system planning tasks using appropriate type. sensing fairness, parties aggressively improve the plan space by pinning up existing plans through displaying complete continuously flexible forward - chaining word - differential domain. transaction search is aided by $ h _ { dtg } $, a novel constraint function that lies based by the concepts sql domain transition mapping yield frontier diagram and is optimized, evaluate schedules in distributed fashion. agents learning fmap apply an advanced validity model ; allows them to adequately keep private decisions out communicating only detailed data of the refinement plans that if relevant at discussions of subsequent participating agents. consistency results recognize that voting is a general - purpose approach that uniformly evaluate tightly - coupled problems that have specialized options and defined approaches as pathways performing two - threaded interactions. specifically, similar empirical evaluation admits that planning outperforms current map systems, solving sustainable planning tasks and are adapted from the international planning competition landscape.", "histories": [["v1", "Wed, 28 Jan 2015 19:38:35 GMT  (386kb,D)", "http://arxiv.org/abs/1501.07250v1", "21 pages, 11 figures"]], "COMMENTS": "21 pages, 11 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["alejandro torre\\~no", "eva onaindia", "\\'oscar sapena"], "accepted": false, "id": "1501.07250"}, "pdf": {"name": "1501.07250.pdf", "metadata": {"source": "CRF", "title": "FMAP: Distributed Cooperative Multi-Agent Planning", "authors": ["Alejandro Torre\u00f1o", "Eva Onaindia", "\u00d3scar Sapena"], "emails": ["atorreno@dsic.upv.es", "onaindia@dsic.upv.es", "osapena@dsic.upv.es"], "sections": [{"heading": null, "text": "Agent Planning), a fully-distributed multi-agent planning method that integrates planning and coordination. Although FMAP is specifically aimed at solving problems that require cooperation among agents, the flexibility of the domain-independent planning model allows FMAP to tackle multi-agent planning tasks of any type. In FMAP, agents jointly explore the plan space by building up refinement plans through a complete and flexible forward-chaining partial-order planner. The search is guided by hDTG, a novel heuristic function that is based on the concepts of Domain Transition Graph and frontier state and is optimized to evaluate plans in distributed environments. Agents in FMAP apply an advanced privacy model that allows them to adequately keep private information while communicating only the data of the refinement plans that is relevant to each of the participating agents. Experimental results show that FMAP is a general-purpose approach that efficiently solves tightly-coupled domains that have specialized agents and cooperative goals as well as loosely-coupled problems. Specifically, the empirical evaluation shows that FMAP outperforms current MAP systems at solving complex planning tasks that are adapted from the International Planning Competition benchmarks.\nAlejandro Torren\u0303o Departamento de Sistemas Informa\u0301ticos y Computacio\u0301n Universtitat Polite\u0300cnica de Vale\u0300ncia Camino de Vera, s/n, 46022, Valencia, Spain E-mail: atorreno@dsic.upv.es\nEva Onaind\u0301\u0131a E-mail: onaindia@dsic.upv.es\nO\u0301scar Sapena E-mail: osapena@dsic.upv.es\nKeywords Distributed Algorithms \u00b7 Multi-Agent Planning \u00b7 Heuristic Planning \u00b7 Privacy"}, {"heading": "1 Introduction", "text": "Multi-agent planning (MAP) introduces a social approach to planning by which multiple intelligent entities work together to solve planning tasks that they are not able to solve by themselves, or to at least accomplish them better by cooperating [40]. MAP places the focus on the collective effort of multiple agents to accomplish tasks by combining their knowledge and capabilities.\nThe complexity of solving a MAP task directly depends on its typology. In order to illustrate the features of a MAP task, let us introduce a brief application example.\nExample 1 Consider the transportation task in Fig. 1, which involves three different agents. There are two transport agencies (ta1 and ta2), each of which has a truck (t1 and t2, respectively). The two agencies work in two different geographical areas, ga1 and ga2, respectively. The third agent is a factory, f , which is placed in the area ga2. To manufacture products, factory f requires raw materials (rm) that are gathered from area ga1. In this task, ta1 and ta2 have the same capabilities, but they act in different areas; i.e., they are spatially distributed agents. Additionally, the factory agent f is functionally different from ta1 and ta2. The goal of this task is for f to manufacture a set of final products. In order to carry out the task, ta1 will send its truck t1 to load the raw materials rm located in l2 and then transport them to a storage facility (sf) that is placed in the intersection of both geographical areas. Then, ta2 will complete the delivery by using its truck t2 to transport ar X iv :1\n50 1.\n07 25\n0v 1\n[ cs\n.A I]\n2 8\nJa n\n20 15\nthe materials from sf to f , which will in turn manufacture the final products. Therefore, this task involves three specialized agents that are spatially and functionally distributed which must cooperate to accomplish a common goal.\nExample 1 emphasizes most of the key elements of a MAP task. First, the spatial and/or functional distribution of planning agents gives rise to specialized agents that have different knowledge and capabilities. In turn, this information distribution stresses the issue of privacy, which is one of the basic aspects that should be considered in multi-agent applications [33].\nSince the three parties involved in Example 1 are specialized in different functional or geographical areas of the task, most of the information managed by factory f is not relevant for the transport agencies and vice-versa. The same occurs with the transport agencies ta1 and ta2. Additionally, agents may not be willing to share the sensitive information of their internal procedures with the others. For instance, ta1 and ta2 are cooperating in this particular delivery task, but they might be potential competitors since they work in the same business sector. Therefore, agents in a MAP context want to minimize the information they share with each other, either for strategic reasons or simply because it is not relevant for the rest of the agents in order to address the planning task.\nBesides the need for computational or information distribution, privacy is also one of the reasons to adopt a multi-agent approach. This aspect, however, has been traditionally relegated in MAP, particularly by the planning community [21]. While some approaches define a basic notion of privacy [2,25], others allow agents to share detailed parts of their plans or do not take private information into account at all [22].\nThe complexity of a MAP task is often described by means of its coupling level [4], which is measured as the number of interactions that arise among agents during the resolution of a MAP task. According to this parameter, MAP tasks can be classified into looselycoupled tasks (which present few interactions among agents) and tightly-coupled tasks (which involve many interactions among agents). The coupling level, how-\never, does not take into consideration one key aspect of MAP tasks: the presence of cooperative goals; i.e., goals that cannot be solved individually by any agent since they require the cooperation of specialized agents. Example 1 illustrates a tightly-coupled task with one such goal since none of the agents can achieve the manufacturing of the final products by itself. Instead, they must make use of their specialized capabilities and interact with each other to deliver the raw materials and manufacture the final products.\nIn this paper, we present FMAP (Forward MAP), which is a domain-independent MAP system that is designed to cope with a great variety of planning tasks of different complexity and coupling level. FMAP is a fully distributed method that interleaves planning and coordination by following a cooperative refinement planning approach. This search scheme allows us to efficiently coordinate agents\u2019 actions in any type of planning task (either loosely-coupled or tightly-coupled) as well as to handle cooperative goals.\nFMAP relies on a theoretical model which defines a more sophisticated notion of privacy than most of the existing MAP systems. Instead of using a single set of private data, FMAP allows agents to declare the information they will share with each other. For instance, the transport agency ta2 in Example 1 will share with factory f information that is likely to be different from the information shared with agent ta1. Our system enhances privacy by minimizing the information that agents need to disclose. FMAP is a complete and reliable planning system that has proven to be very competitive when compared to other state-of-theart MAP systems. The experimental results will show that FMAP is particularly effective for solving tightlycoupled MAP problems with cooperative goals.\nThis article is organized as follows: section 2 presents some related work on multi-agent planning, with an emphasis on issues like the coupling level of planning tasks, privacy, or cooperative goals. Section 3 formalizes the notion of a MAP task; section 4 describes the main components of FMAP, the search procedure, and the DTG-based heuristic function; finally, section 5 provides a thorough experimental evaluation of FMAP and section 6 concludes the paper."}, {"heading": "2 Related work", "text": "In the literature, there are two main approaches for solving MAP tasks like the one described in Example 1. Centralized MAP involves using an intermediary agent that has complete knowledge of the task. The distributed or decentralized approach spreads the planning\nresponsability among agents, which are in charge of interacting with each other to coordinate their local solutions, if necessary [28,18]. The adoption of a centralized approach is aimed at improving the planner performance by taking advantage of the inherent structure of the MAP tasks [22,8]. Centralized approaches assume a single planning entity that has complete knowledge of the task, which is rather unrealistic if the parties involved in the task have sensitive private information that they are not willing to disclose [32]. In Example 1, the three agents involved in the task want to protect the information regarding their internal processes and business strategies, so a centralized setting is not an acceptable solution.\nWe then focus on fully distributed MAP, that is, the problem of coordinating agents in a shared environment where information is distributed. The distributed MAP setting involves two main tasks: the planning of local solutions and the coordination of the agents\u2019 plans into a global solution. Coordination can be performed at one or various stages of the distributed resolution of a MAP task. Some techniques are used for problems in which agents build local plans for the individual goals that they have been assigned. MAP is about coordinating the local plans of agents so as to mutually benefit by avoiding the duplication of effort. In this case, the goal is not to build a joint plan among entities that are functionally or spatially distributed but rather to apply plan merging to coordinate the local plans of multiple agents that are capable of achieving the problem goals by themselves [7].\nThere is a large body of work on plan-merging techniques. The work in [7] introduces a distributed coordination framework based on partial-order planning that addresses the interactions that emerge between the agents\u2019 local plans. This framework, however, does not consider privacy. The proposal in [36] is based on the iterative revision of the agents\u2019 local plans. Agents in this model cooperate by mutually adapting their local plans, with a focus on improving their common or individual benefit. This approach also ignores privacy and agents are assumed to be fully cooperative. The approach in [39] uses multi-agent plan repair to solve inconsistencies among the agents\u2019 local plans while maintaining privacy. \u00b5-SATPLAN [9] extends a satisfiability-based planner to coordinate the agents\u2019 local plans by studying positive and negative interactions among them.\nPlan-merging techniques are not very well suited for coping with tightly-coupled tasks as they may introduce exponentially many ordering constraints in problems that require great coordination effort [7]. In general, plan merging is not an effective method for attaining cooperative goals since this resolution scheme generally\nassumes that each agent is able to solve a subset of the task\u2019s goals by itself. However, some approaches use plan merging to coordinate local plans of specialized agents. In this case, the effort is placed on discovering the interaction points among agents through the public information that they share. For instance, Planning First [25] introduces a cooperative MAP approach for loosely-coupled tasks, in which specialized agents carry out planning individually through a state-based planner. The resulting local plans are then coordinated by solving a distributed Constraint Satisfaction Problem (CSP) [16]. This combination of CSP and planning to solve MAP tasks was originally introduced by the MASTRIPS framework [4].\nAnother major research trend in MAP interleaves planning and coordination, providing a more unified vision of cooperative MAP. One of the first approaches to domain-independent MAP is the Generalized Partial Global Planning (GPGP) framework [23]. Agents in GPGP have a partial view of the world and communicate their local plans to the rest of the agents, which in turn merge this information into their own partial global plan in order to improve it. Approaches to continual planning (interleaving planning and execution in a world undergoing continual change), assume there is uncertainty in the world state and therefore agents do not have a complete view of the world [5]. Specifically in [5], agents have a limited knowledge of the environment and limited capabilities, but the authors do not explicitly deal with a functional distribution among agents or cooperative goals. TFPOP is a fully centralized approach that combines temporal and forward-chaining partial-order planning to solve loosely-coupled MAP tasks [22]. The Best-Response Planning algorithm departs from an initial joint plan that is built through the Planning First MAP system [25] and iteratively improves the quality of this initial plan by applying cost optimal planning [17]. Agents can only access the public information of the other agents\u2019 plans thereby preserving privacy, and they optimize their plans with the aim to converge to a Nash equilibrium regarding their preferences. MAP-POP is a fully distributed method that effectively maintains the agents\u2019 privacy [38,37]. Agents in MAP-POP perform an incomplete partialorder planning search to progressively develop and coordinate a joint plan until its completion.\nFinally, MAPR is a recent planner that performs goal allocation to each agent [2]. Agents iteratively solve the assigned goals by extending the plan of the previous agent. In this approach, agents work under limited knowledge of the environment by obfuscating the private information in their plans. MAPR is particularly effective for loosely-coupled problems, but it can-\nnot deal with tasks that feature specialized agents and cooperative goals since it assumes that each goal is achieved by a single agent. Section 5 will show a comparative performance evaluation between MAPR and FMAP, our proposed approach."}, {"heading": "3 MAP task formalization", "text": "Agents in FMAP work with limited knowledge of the planning task by assuming that information that is not represented in an agent\u2019s model is unknown to the agent. The states of the world are modeled through a finite set of state variables, V, each of which is associated to a finite domain, Dv, of mutually exclusive values that refer to the objects in the world. Assigning a value d to a variable v \u2208 V generates a fluent. A positive fluent is a tuple \u3008v, d\u3009, which indicates that the variable v takes the value d. A negative fluent is of the form \u3008v,\u00acd\u3009, indicating that v does not take the value d. A state S is a set of positive and negative fluents.\nAn action is a tuple \u03b1 = \u3008PRE(\u03b1), EFF (\u03b1)\u3009, where PRE(\u03b1) is a finite set of fluents that represents the preconditions of \u03b1, and EFF (\u03b1) is a finite set of positive and negative variable assignments that model the effects of \u03b1. Executing an action \u03b1 in a world state S leads to a new world state S\u2032 as a result of applying EFF (\u03b1) over S. An effect of the form (v = d) assigns the value d to the variable v, i.e., it adds the fluent \u3008v, d\u3009 to S\u2032 as well as adding a set of fluents \u3008v,\u00acd\u2032\u3009 for each other value d\u2032 in the variable domain in order to have a consistent state representation. Additionally, any fluent in S of the form \u3008v,\u00acd\u3009 or \u3008v, d\u2032\u2032\u3009, d\u2032\u2032 6= d, is removed in state S\u2032. This latter modification removes any fluent that contradicts \u3008v, d\u3009. On the other hand, an assignment (v 6= d) adds the fluent \u3008v,\u00acd\u3009 to S\u2032 and removes \u3008v, d\u3009 from S\u2032, if such a fluent exists in S.\nFor instance, let us suppose that the transportation task in Example 1 includes a variable pos-rm that describes the position of the raw materials rm, which can be any of the locations in the task. Let S be a state that includes a fluent \u3008pos-rm, l2\u3009, which indicates that rm is placed in its initial location (see Fig. 1). Agent ta1 performs an action to load rm into its truck t1, which includes an effect of the form (pos-rm = t1). The application of this action results in a new world state S\u2032 that will include a fluent \u3008pos-rm, t1\u3009 and fluents of the form \u3008pos-rm,\u00acl\u3009 for each other location l 6= t1; the fluent \u3008pos-rm, l2\u3009 will no longer be in S\u2032.\nDefinition 1 A MAP task is defined as a tuple TMAP = \u3008AG,V,I,G,A\u3009. AG = {1, . . . , n} is a finite non-empty set of agents. V = \u22c3 i\u2208AG Vi, where Vi is the set of state\nvariables known to an agent i. I = \u22c3\ni\u2208AG Ii is a set\nof fluents that defines the initial state of TMAP . Since specialized agents are allowed, they may only know a subset of I. Given two agents i and j, Ii \u2229 Ij may or may not be \u2205; in any case, the initial states of the agents never contradict each other. G is the set of goals of TMAP , i.e., the values of the state variables that agents have to achieve in order to accomplish TMAP . Finally, A = \u22c3 i\u2208AG Ai is the set of planning actions of the agents. Ai and Aj of two specialized agents i and j will typically be two disjoint sets since the agents have their own different capabilities; otherwise, Ai and Aj may overlap. A includes two fictitious actions \u03b1i and \u03b1f that do not belong to the action set of any particular agent: \u03b1i represents the initial state of TMAP , i.e., PRE(\u03b1i) = \u2205 and EFF (\u03b1i) = I, while \u03b1f represents the global goals of TMAP , i.e., PRE(\u03b1f ) = G, and EFF (\u03b1f ) = \u2205.\nAs discussed in Example 1, our model considers specialized agents that can be functionally and/or spatially distributed. This specialization defines the local view that each agent has of the MAP task. Local views are a typical characteristic of multi-agent systems and other distributed systems. For instance, distributed CSPs use local views, such that agents only receive information about the constraints in which they are involved [16, 41]. Next, we define the information of an agent i on a planning task TMAP . The view of an agent i on a MAP task TMAP is defined as T iMAP = \u3008Vi,Ai, Ii,G\u3009. Vi is the set of state variables known to agent i; Ai \u2286 A is the set of its capabilities (planning actions); Ii is the subset of fluents of the initial state I that are visible to agent i; and G is the set of global goals of TMAP . Since agents in FMAP are fully cooperative, they are all aware of the global goals of the task. Obviously, because of specialization, a particular agent may not understand the goals as specified in G; defining G as global goals implies that all agents contribute to the achievement of G, either directly (achieving a g \u2208 G) or indirectly (introducing actions whose effects help other agents achieve g).\nThe state variables of an agent i are determined by the view the agent has on the initial state, Ii, the planning actions it can perform, Ai, and the set of goals of TMAP . This also affects the domain Dv of a variable v. We define Div \u2286 Dv as the set of values of the variable v that are known to agent i.\nConsider again the pos-rm variable in Example 1. The domain of pos-rm contains all the locations in the transportation task, including the factory f , the storage facility sf , and the trucks; that is, Dpos-rm = {l1, l2, l3, l4, f, sf, t1, t2}. However, agents ta1 and ta2\nhave local knowledge about the domain of pos-rm because some of the values of such variable refer to objects of TMAP that are unknown to them. Hence, ta1 will manage Dta1pos-rm = {l1, l2, sf, t1}, while ta2 will manage Dta2pos-rm = {l3, l4, sf, f, t2}.\nAgents in FMAP interact with each other by sharing information about their state variables. For each pair of agents i and j, the public information they share is defined as Vij = Vji = Vi \u2229 Vj . Additionally, some of the values in the domain of a variable can also be public to both agents. The set of values of a variable v that are public to a pair of agents i and j is defined as Dijv = Div \u2229 Djv. As Example 1 indicates, the pos-rm variable is public to agents ta1 and ta2. The values that are public to both agents are defined as the intersection of the values that are known to each of them, Dta1 ta2pos-rm = {sf}. This way, the only public location of rm for agents ta1 and ta2 is the storage facility sf , which is precisely the intersection between the two geographical areas. Hence, if agent ta1 places rm in sf , it will inform ta2 accordingly, and vice versa. This allows agents ta1 and ta2 to work together while minimizing the information they share with each other.\nOur MAP model is a multi-agent refinement planning framework, which is a general method based on the refinement of the set of all possible plans. The internal reasoning of agents in FMAP is configured as a Partial-Order Planning (POP) search procedure. Other local search strategies are applicable, as long as agents build partial-order plans. The following concepts and definitions are standard terms from the POP paradigm [12], which have been adapted to state variables. Additionally, definitions also account for the multi-agent nature of the planning task and the local views of the task by the agents.\nDefinition 2 A partial-order plan or partial plan is a tuple \u03a0 = \u3008\u2206,OR, CL\u3009. \u2206 = {\u03b1|\u03b1 \u2208 A} is the set of actions in \u03a0. OR is a finite set of ordering constraints (\u227a) on \u2206. CL is a finite set of causal links of the form \u03b1 \u3008v,d\u3009\u2192 \u03b2 or \u03b1 \u3008v,\u00acd\u3009\u2192 \u03b2, where \u03b1 and \u03b2 are actions in \u2206. A causal link \u03b1 \u3008v,d\u3009\u2192 \u03b2 enforces precondition \u3008v, d\u3009 \u2208 PRE(\u03b2) through an effect (v = d) \u2208 EFF (\u03b1) [12]. Similarly, a causal link \u03b1\n\u3008v,\u00acd\u3009\u2192 \u03b2 enforces \u3008v,\u00acd\u3009 \u2208 PRE(\u03b2) through an effect (v 6= d) \u2208 EFF (\u03b1) or (v = d\u2032) \u2208 EFF (\u03b1), d\u2032 6= d.\nAn empty partial plan is defined as \u03a00 = \u3008\u22060, OR0, CL0\u3009, where OR0 and CL0 are empty sets, and \u22060 contains only the fictitious initial action \u03b1i. A partial plan \u03a0 for a task TMAP will always contain \u03b1i.\nThe introduction of new actions in a partial plan may trigger the appearance of flaws. There are two types of flaws in a partial plan: preconditions that are not yet solved (or supported) through a causal link, and threats. A threat over a causal link \u03b1 \u3008v,d\u3009\u2192 \u03b2 is caused by an action \u03b3 that is not ordered w.r.t. \u03b1 or \u03b2 and might potentially modify the value of v [12] ((v 6= d) \u2208 EFF (\u03b3) or (v = d\u2032) \u2208 EFF (\u03b3), d\u2032 6= d), making the causal link unsafe. Threats are addressed by introducing either an ordering constraint \u03b3 \u227a \u03b1 (this is called demotion because the causal link is posted after the threatening action) or an ordering \u03b2 \u227a \u03b3 (this is called promotion because the causal link is placed before the threatening action) [12].\nA flaw-free plan is a threat-free partial plan in which\nthe preconditions of all the actions are supported through causal links.\nPlanning agents in FMAP cooperate to solve MAP tasks by progressively refining an initially empty plan\u03a0 until a solution is reached. The definition of refinement plan is closely related to the internal forward-chaining partial-order planning search performed by the agents. Refinement planning is a technique that is widely used by many planners, specifically in anytime planning, where a first initial solution is progressively refined until the deliberation time expires [31]. We define a refinement plan as follows:\nDefinition 3 A refinement plan \u03a0r = \u3008\u2206r, ORr, CLr\u3009 over a partial plan \u03a0 = \u3008\u2206, OR, CL\u3009 is a flaw-free partial plan that extends \u03a0, i.e., \u2206 \u2282 \u2206r, OR \u2282 ORr and CL \u2282 CLr. \u03a0r introduces a new action \u03b1 \u2208 \u2206r in \u03a0, resulting in \u2206r = \u2206 \u222a \u03b1. All the preconditions in PRE(\u03b1) are linked to existing actions in \u03a0 through causal links; i.e., all preconditions are supported: \u2200p \u2208 PRE(\u03b1), \u2203 \u03b2 p\u2192 \u03b1 \u2208 CLr, where \u03b2 \u2208 \u2206.\nRefinement plans in FMAP include actions that can be executed in parallel by different agents. Some MAP models consider that two parallel or non-sequential actions are mutually consistent if neither of them modifies the value of a state variable that the other relies on or affects [5]. We also consider that the preconditions of two mutually consistent actions have to be consistent [3]. Hence, two non-sequential actions \u03b1 \u2208 Ai and \u03b2 \u2208 Aj are mutually consistent if none of the following conditions hold:\n\u2013 \u2203(v = d) \u2208 EFF (\u03b1) and \u2203(\u3008v, d\u2032\u3009 \u2208 PRE(\u03b2) \u2228 \u3008v,\u00acd\u3009 \u2208 PRE(\u03b2)), where v \u2208 Vij , d \u2208 Dijv , d\u2032 \u2208 Djv and d 6= d\u2032, or vice versa; that is, the effects of \u03b1 and the preconditions of \u03b2 (or vice versa) do not\ncontradict each other under the specified conditions.\n\u2013 \u2203(v = d) \u2208 EFF (\u03b1) and \u2203((v = d\u2032) \u2208 EFF (\u03b2) \u2228 (v 6= d) \u2208 EFF (\u03b2)), where v \u2208 Vij , d \u2208 Dijv , d\u2032 \u2208 Djv and d 6= d\u2032, or vice versa; that is, the effects of \u03b1 and the effects of \u03b2 (or vice versa) do not contradict\neach other under the specified conditions.\n\u2013 \u2203\u3008v, d\u3009 \u2208 PRE(\u03b1) and \u2203(\u3008v, d\u2032\u3009 \u2208 PRE(\u03b2)\u2228\u3008v,\u00acd\u3009 \u2208 PRE(\u03b2)), where v \u2208 Vij , d \u2208 Dijv , d\u2032 \u2208 Djv and d 6= d\u2032, or vice versa; that is, the preconditions of \u03b1 and the preconditions of \u03b2 (or vice versa) do not\ncontradict each other under the specified conditions.\nAgents address parallelism by the resolution of threats\nover the causal links of the plan. Thus, consistency between any two non-sequential actions introduced by different agents is always guaranteed as refinement plans are flaw-free plans.\nFinally, a solution plan for TMAP is a refinement plan \u03a0 = \u3008\u2206, OR, CL\u3009 that addresses all the global goals G of TMAP . A solution plan includes the fictitious final action \u03b1f and ensures that all its preconditions (note that PRE(\u03b1f ) = G) are satisfied; that is, \u2200g \u2208 PRE(\u03b1f ), \u2203 \u03b2\ng\u2192 \u03b1f \u2208 CL, \u03b2 \u2208 \u2206, which is the necessary condition to guarantee that \u03a0 solves TMAP .\n3.1 Privacy in partial plans\nEvery time an agent i refines a partial plan by introducing a new action \u03b1 \u2208 Ai, it communicates the resulting refinement plan to the rest of the agents in TMAP . As stated above, the information that is public to a pair of agents is defined according to the common state variables and domain values. In order to preserve privacy, agent i will only communicate to agent j the fluents in action \u03b1 whose variables are common to both agents. The information of a refinement plan \u03a0 that agent j receives from agent i configures its view of that plan, viewj(\u03a0). More specifically, given two agents i and j and a fluent \u3008v, d\u3009, where v \u2208 Vi and d \u2208 Div (equivalently for a negative fluent \u3008v,\u00acd\u3009), we distinguish the three following cases:\n\u2013 Public fluent: if v \u2208 Vij and d \u2208 Dijv , the fluent \u3008v, d\u3009 is public to both i and j, and thus agent i will send agent j all the causal links, preconditions, and\neffects regarding \u3008v, d\u3009. \u2013 Private fluent to agent i: if v 6\u2208 Vij , the fluent \u3008v, d\u3009 is private to agent i w.r.t. agent j, and thus agent i will occlude the preconditions and effects re-\ngarding \u3008v, d\u3009 to agent j. Causal links of the form \u03b1 \u3008v,d\u3009\u2192 \u03b2 will be sent to agent j as ordering con-\nstraints \u03b1 \u227a \u03b2. \u2013 Partially private fluent to agent i: if v \u2208 Vij but d 6\u2208 Dijv , the fluent \u3008v, d\u3009 is partially private to agent\ni w.r.t. agent j. Instead of \u3008v, d\u3009, agent i will send agent j a fluent \u3008v,\u22a5\u3009, where \u22a5 is the undefined value. Hence, preconditions of the form \u3008v, d\u3009 will be sent as \u3008v,\u22a5\u3009, effects of the form (v = d) will be replaced by (v =\u22a5), and causal links \u03b1 \u3008v,d\u3009\u2192 \u03b2 will adopt the form \u03b1 \u3008v,\u22a5\u3009\u2192 \u03b2.\nIf an agent j receives a fluent \u3008v,\u22a5\u3009, \u22a5 is interpreted as follows: \u2200d \u2208 Djv, \u3008v,\u00acd\u3009. That is, \u22a5 indicates that v is not assigned any of the values known to agent j (Djv). This mechanism is used to inform an agent that a resource is no longer available in its influence area. For instance, suppose that agent ta2 in Example 1 acquires the raw material rm from sf by loading it into its truck t2. Agent ta2 communicates to ta1 that rm is no longer in sf , but agent ta1 does not know about the truck t2. To solve this issue, ta2 sends ta1 the fluent \u3008pos-rm,\u22a5\u3009, meaning that the resource rm is no longer available in the geographical area of agent ta1. Consequently, ta1 is now aware that rm is not located in any of its accessible positions Dta1pos-rm = {l1, l2, sf, t1}. Fig. 2 shows the view that the transport agents ta1 and ta2 in Example 1 have of a simple refinement plan \u03a0r. In this plan, agent ta1 drives the truck t1 from l1 to l2 and loads rm into t1. As shown in Fig. 2a, viewta1(\u03a0r) contains all the information of both actions in the plan since agent ta1 has introduced them. Agent ta2, however, does not know about the truck t1, and hence the variable pos-t1, which models the position of t1, is private to ta1 w.r.t. ta2. This way, all the preconditions and effects related to the fluents \u3008pos-t1, l1\u3009 and \u3008pos-t1, l2\u3009 are occluded in viewta2(\u03a0r) (see Fig. 2b). Additionally, the causal links regarding these two fluents are replaced by ordering constraints in viewta2(\u03a0r). On the other hand, the variable pos-rm is public to both agents, but the load action refers to the locations t1 and l2, which are not in Dta2pos-rm. Therefore, fluents \u3008pos-rm, l2\u3009 and \u3008pos-rm, t1\u3009 are partially private to agent ta1 w.r.t. ta2. This way, in viewta2(\u03a0r), the precondition \u3008pos-rm, l2\u3009 and the effect (pos-rm = t1) of the load action are replaced by \u3008pos-rm,\u22a5\u3009 and (pos-rm =\u22a5), respectively. The fluent \u3008pos-rm, l2\u3009 is also replaced by \u3008pos-rm,\u22a5\u3009 in the causal link \u03b1i\n\u3008pos-rm,l2\u3009\u2192 load t1 rm l2.\n3.2 MAP definition language\nThere is a large body of work on planning task specification languages. Since planning has been traditionally regarded as a centralized problem, the most popular definition languages, such as the different versions of\n!\"#$%&'()*+,!\"#$%&'()*',-i -f ./ *#.0)&')12)*+01345)&')*')*+\n6/\n!\"#$%&'()*',\n7\"#$%&'8*+/\n!\"#$%&'()*+, !\"#$%12()*+,\n7\"#$%128&'/\n!\"#$%12()*+,\n-i -f-1-0 !\"#$%12()\u22a5,\n7\"#$%128)\u22a5/\n!\"#$%12()\u22a5,\nFig. 2 A refinement plan \u03a0r as viewed by: a) agent ta1 b) agent ta2\nPDDL (the Planning Domain Definition Language1), are designed to model single-agent planning tasks. MAP introduces a set of requirements that are not present in single-agent planning, such as privacy or specialized agents, which motivate the development of specification languages for multi-agent planning.\nThere are many different approaches to MAP as described in section 2. MA-STRIPS [4], which was designed as a minimalistic extension to STRIPS [10], is one of the most common MAP languages. It allows defining a set of agents and associating the planning actions they can execute. FMAP presents several advanced features that motivated the definition of our own PDDL-based specification language (the language syntax is detailed in [38]) rather than using MA-STRIPS.\nSince the world states in FMAP are modeled through\nstate variables instead of predicates, our MAP language is based on PDDL3.1 [20], the latest version of PDDL. Unlike its predecessors, which model planning tasks through predicates, PDDL3.1 incorporates state variables that map to a finite domain of objects of the task.\nIn a single-agent language, the user specifies the domain of the task (planning operators, types of objects, and functions) and the problem to be solved (objects of the task, initial state, and goals). In FMAP, we write a domain and a problem file for each agent, which define the typology of the agent, and the agent\u2019s local view of the MAP task, respectively. The domain files keep the structure of a regular PDDL3.1 domain file. The problem files, however, are extended with an additional :shared-data section, which specifies the information that an agent can share with each of the other participating agents in the task."}, {"heading": "4 FMAP refinement planning procedure", "text": "FMAP is based on a cooperative refinement planning procedure in which agents jointly explore a multi-agent, plan-space search tree. A multi-agent search tree is one\n1 http://en.wikipedia.org/wiki/Planning_Domain_\nDefinition_Language\n!i !f\"0\n!i !f\"00 #$%&'()*(+*(+,\n!i !f\"01 #$%&'()*(+*(-. !i !f\"02 #$%&'(),(+/(-.\n!i !f\"03 #$%&'(),(+/(.\n)0* )0,\nFig. 3 FMAP multi-agent search tree example\nin which the partial plans of the nodes are built with the contributions of one or more agents.\nFig. 3 shows the first level of the multi-agent search tree that would be generated for the transportation task of Example 1. At this level, agents ta1 and ta2 each propose two refinement plans, specifically the plans to move their trucks within their geographical areas. In each of these refinement plans, the agent adds one action and the corresponding orderings and causal links. Agent f does not contribute here with any refinement plan because the initial empty plan \u03a00 does not have the necessary supporting information for f to insert any of its actions. In a subsequent iteration (expansion of the next tree node), agents can in turn create new refinement plans. For instance, if node \u03a000 in Fig. 3 is selected next for expansion, the three agents in the problem (ta1, ta2, or f) will try to create refinement plans over \u03a000 by adding one of their actions and supporting it through the necessary causal links and orderings.\nAgents keep a copy of the multi-agent search tree, storing the local view they have of each of the plans in the tree nodes. Given a node \u03a0 in the multi-agent search tree, an agent i maintains viewi(\u03a0) in its copy of the tree.\nFMAP applies a multi-agent A* search that iteratively explores the multi-agent tree. One iteration of FMAP involves the following: 1) agents select one of the unexplored leaf nodes of the tree for expansion; 2) agents expand the selected plan by generating all the refinement plans over this node; and 3) agents evaluate the resulting successor nodes and communicate the results to the rest of the agents. Instead of using a broadcast control framework, FMAP uses democratic leadership, in which a coordinator role is scheduled among the agents. One of the agents adopts the role of coordinator at each iteration, thus leading the procedure in one iteration (initially, the coordinator role is randomly assigned to one of the participating agents). More specifically, a FMAP iteration is as follows:\n\u2013 Base plan selection: Among all the open nodes\n(unexplored leaf nodes) of the multi-agent search tree, the coordinator agent selects the most promising plan, \u03a0b, as the base plan to refine in the current\niteration. \u03a0b is selected according to the evaluation of the open nodes (details on the node evaluation and selection are presented in section 4.3). In the initial iteration, the base plan is the empty plan \u03a00. \u2013 Refinement plan generation: Agents expand \u03a0b and generate its successor nodes. A successor node\nis a refinement plan over \u03a0b that an agent generates individually through its embedded forward-chaining partial-order planner (see subsection 4.1). \u2013 Refinement plan evaluation: Each agent i evalu-\nates its refinement plans \u03a0r by applying a classical A* evaluation function (f(\u03a0r) = g(view i(\u03a0r)) + h(viewi(\u03a0r))). The expression g(view i(\u03a0r)) stands for the number of actions of \u03a0r. Since agents view all the actions of the plans (but not necessarily all their preconditions and effects), g(viewi(\u03a0r)) is equivalent to g(\u03a0r). h(view i(\u03a0r)) applies our DTG-based heuristic (see subsection 4.3) to estimate the cost of reaching a solution plan from \u03a0r.\n\u2013 Refinement plan communication: Each agent\ncommunicates its refinement plans to the rest of the agents. The information that an agent i communicates about its plan \u03a0r to the rest of the agents depends on the level of privacy specified with each of them. Along with the refinement plan \u03a0r, agent i communicates the result of the evaluation of \u03a0r, f(\u03a0r).\nOnce the iteration is completed, the leadership is handed to another agent, which adopts the coordinator role, and a new iteration starts. The next coordinator agent selects the open node \u03a0 that minimizes f(\u03a0) as the new base plan \u03a0b, and then, agents proceed to expand it. This iterative process carries on until \u03a0b becomes a solution plan that supports the final action \u03b1f , or when all the open nodes have been visited, in which case, the agents will have explored the complete search space without finding a solution for the MAP task TMAP . A refinement plan \u03a0 is evaluated only by the agent that generates it. The agent communicates \u03a0 along with f(\u03a0) to the rest of the agents. Therefore, the decision on the next base plan is not affected by the agent that plays the coordinator role since all of the agents manage the same f(\u03a0) value for every open node \u03a0.\nIn the example depicted in Fig. 3, agent ta1 evaluates its refinement plans, \u03a000 and \u03a001, and communicates them along with f(\u03a000) and f(\u03a001) to agents ta2 and f ; likewise, ta2 with ta1 and f . In this first level of the tree, agents ta1 and ta2 have a complete view of the refinement plans, that they have generated since these plans only contain an action that they themselves introduced. However, when ta1 and ta2 communicate their plans to each other, they will only send the flu-\n!i !f\"#$%&'()'*+',-\"#$%&'()'*)'*+\n3001\nents according to the level of privacy defined between them, as described in subsection 3.1. This way, ta1 will send viewta2(\u03a000) and view ta2(\u03a001) to agent ta2, and viewf (\u03a000) and view f (\u03a001) to agent f .\nThe following subsections analyze the key elements of FMAP, that is, the search algorithm that agents use for the generation of the refinement plans and the heuristic function they use for plan evaluation. We also include a subsection that addresses the completeness and correctness of the algorithm as well as a subsection that describes the limitations of FMAP.\n4.1 Forward-Chaining Partial-Order Planning\nAgents in FMAP use an embedded flexible forwardchaining POP system to generate the refinement plans; this will be referred to as FLEX in the remainder of the paper. Similarly to other approaches, FLEX explores the potential of forward search to support partial-order planning. OPTIC [1], for instance, combines partialorder structures with information on the frontier state of the plan. Informally speaking, the frontier state of the partial plan of a tree node is the resulting state after executing the actions in such a plan. Given a refinement plan \u03a0 = \u3008\u2206,OR, CL\u3009, we define its frontier state FS(\u03a0) as the set of fluents \u3008v, d\u3009 achieved by actions \u03b1 \u2208 \u2206 | \u3008v, d\u3009 \u2208 EFF (\u03b1), such that any action \u03b1\u2032 \u2208 \u2206 that modifies the value of the variable v (\u3008v, d\u2032\u3009 \u2208 EFF (\u03b1\u2032) | d 6= d\u2032) is not reachable from \u03b1 by following the orderings and causal links in \u03a0.\nThe only actions that OPTIC adds to a plan are those whose preconditions hold in the frontier state. This behaviour forces OPTIC to some early commitments; however, this does not sacrifice completeness, because search can backtrack. Also, TFPOP [22] applies a centralized forward-chaining POP for multiple agents, keeping a sequential execution thread per agent.\nThe aforementioned approaches only permit introducing actions that are applicable in the frontier state of the plan. In contrast, FLEX allows inserting actions at any position of the plan without assuming that any\naction in the plan has already been executed. This is a more flexible approach that is also more compliant with the least-commitment principle that typically guides backward-chaining POP. Fig. 4 shows the advantages of our flexible search strategy. Consider the refinement plan \u03a0001, which is the result of a refinement of agent ta1 on plan \u03a000 (see Fig. 3) after including the action (drive t1 l1 sf). This is not the best course of action for taking the raw material rm to the factory f as ta1 should load rm into t1 before moving to sf . The frontier state FS(\u03a0001) reflects the state of the world after executing the plan \u03a0001, in which the truck t1 would be at sf . Planners like OPTIC would only introduce actions that are applicable in the frontier state FS(\u03a0001). In this example, OPTIC would first insert the action (drive t1 sf l2) to move the truck t1 back to l2 in order to be able to apply the action (load t1 rm l2) (see Fig. 4a). FLEX, however, is able to introduce actions at any position in the plan, so the load action can be directly placed between both drive actions, thus minimizing the length of the plan (see Fig. 4b).\nAlgorithm 1: FLEX search algorithm for an agent i\nRP i \u2190 \u2205 if potentiallySupportable(\u03b1f , viewi(\u03a0b)) then return solutionP lans CandidateActions\u2190 \u2205 forall the \u03b1 \u2208 Ai do if potentiallySupportable(\u03b1, viewi(\u03a0b)) then CandidateActions\u2190 CandidateActions \u222a \u03b1\nforall the \u03b1 \u2208 CandidateActions do Plans\u2190 {viewi(\u03a0b)} repeat\nSelect and extract \u03a0s \u2208 Plans F laws(\u03a0s)\u2190 unsupportedPrecs(\u03b1,\u03a0s) \u222a Threats(\u03a0s) if Flaws(\u03a0s) = \u2205 then RP i \u2190 RP i \u222a\u03a0s\nelse Select and extract \u03a6 \u2208 Flaws(\u03a0s) Plans\u2190 Plans \u222a solveF law(\u03a0s, \u03a6)\nuntil Plans = \u2205 return RP i\nAlgorithm 1 summarizes the FLEX procedure invoked by an agent i to generate refinement plans, and Fig. 5 shows how agent ta1 in Example 1 uses the FLEX algorithm to refine plan \u03a000 in Fig. 3. The first operation of an agent i that executes FLEX is to check whether the fictitious final action \u03b1f is supportable in \u03a0b, that is, if a solution plan can be obtained from \u03a0b. If so, the agent will generate a set of solution plans that\ncovers all the possible ways to support the preconditions of \u03b1f through causal links.\nIf a solution plan is not found, agent i analyzes all its planning actions Ai and estimates if they are supportable in \u03a0b. Given an action \u03b1 \u2208 Ai, the function potentiallySupportable(\u03b1,\u03a0b) checks if \u2200\u3008v, d\u3009 \u2208 PRE(\u03b1), \u2203\u03b2 \u2208 \u2206(\u03a0b) | (v = d) \u2208 EFF (\u03b2), i.e., the agent estimates that \u03b1 is supportable if for every precondition of \u03b1 there is a matching effect among the actions of \u03a0b.\nFig. 5 shows an example of potentially supportable actions. Agent ta1 evaluates all the actions in Ata and finds five candidate actions. In \u03b1i, the initial state of \u03a000, the truck t1 is at location l1. Consequently, ta1 considers (drive t1 l1 sf) and (drive t1 l1 l2) as potential candidate actions for its refinements. Note that action (drive t1 l1 l2) is already included in plan \u03a000. Actions (drive t1 l2 sf), (drive t1 l2 l1), and (load t1 rm l2) are also classified as candidates since they are applicable after the action (drive t1 l1 l2), which is already in plan \u03a000.\nIt is possible to introduce an action multiple times in a plan; for instance, a truck may need to travel back and forth between two different locations several times. For this reason, ta1 again considers (drive t1 l1 l2) as a candidate action when refining \u03a000, even if this action is already included in \u03a000. By estimating potentially supportable actions in any position of the plan, FLEX follows the least commitment principle and does not leave out any potential refinement plan.\nThe potentiallySupportable procedure is an estimate because it does not actually check the possible flaws that arise when supporting an action. Hence, an agent analyzes the alternatives that support each candidate action \u03b1 by generating a POP search tree for that particular action (repeat loop in Algorithm 1). All the leaf nodes of the tree (stored in the Plans list in Algorithm 1) are explored, thereby covering all the possible ways to introduce \u03b1 in \u03a0b.\nAs in backward-chaining POP, FLEX introduces the action \u03b1 in \u03a0b by supporting its preconditions through causal links and solving the threats that arise during the search. The set of flaw-free plans obtained from this search are stored in RP i as valid refinement plans of agent i over \u03a0b. This procedure is carried out for each candidate action. Completeness is guaranteed since all the possible refinement plans over a given base plan are generated by the agents involved in TMAP . Fig. 5 shows that, for every candidate action, ta1 performs an independent POP search aimed at supporting the action. Actions (load t1 rm l2), (drive t1 l2 sf), and (drive t1 l2 l1) lead to three different refinement plans over \u03a000: {\u03a0000, \u03a0001, \u03a0002}. These plans will then be inserted into ta1\u2019s copy of the multi-agent search tree. Agent ta1 will also send the information of these plans to agents ta2 and f according to the level of privacy defined with each one. ta2 and f also store the received plans in their copies of the tree.\nCandidate action (drive t1 l1 sf) does not produce valid refinement plans because it causes an unsolvable threat. This is because truck t1 cannot simultaneously move to two different locations from l1, which causes a conflict between the existing action (drive t1 l1 l2) \u2208 \u2206(\u03a000) and (drive t1 l1 sf). Similarly, action (drive t1 l1 l2) does not yield any valid refinements. The resulting plan would have two actions (drive t1 l1 l2) in parallel, both of which are linked to \u03b1i, which causes an unsolvable threat because t1 cannot perform two identical drive actions in parallel.\n4.2 Completeness and Soundness\nAs explained in the previous section, agents refine the base plan concurrently by analyzing all of the possible ways to support their actions in the base plan. Since this operation is done by every agent and for all their actions, we can conclude FMAP is a complete procedure that explores the whole search space.\nAs for soundness, a partial-order plan is sound if it is a flaw-free plan. The FLEX algorithm addresses inconsistencies among actions in a partial plan by detecting and solving threats.\nWhen an agent i introduces an action \u03b1 in a base plan \u03a0, FLEX studies the threats that \u03b1 causes in the causal links of \u03a0 and the threats that the actions of \u03a0 may cause in the causal links that support the preconditions of \u03b1. In both cases, i is able to detect all threats whatever its view of the plan is, viewi(\u03a0). That is, FMAP soundness is guaranteed regardless of the level of privacy defined between agents.\nWith regard to the threats caused by the effects of a new action, privacy may prevent the agent from viewing\nsome of the causal links of the plan. Suppose that agent i introduces an action \u03b1t with an effect (v = d \u2032) in plan \u03a0. Additionally, there is a causal link in \u03a0 of the form cl = \u03b10 \u3008v,d\u3009\u2192 \u03b11 introduced by an agent j; as cl is not ordered with respect to \u03b1t, this situation generates a threat. According to viewi(\u03a0), agent i may find one of the following situations:\n\u2013 If \u3008v, d\u3009 is public to i and j, then cl is in viewi(\u03a0), and thus the threat between cl and \u03b1t will be cor-\nrectly detected and solved by promoting or demoting \u03b1t. \u2013 If \u3008v, d\u3009 is private to j w.r.t. i, then \u03b1t cannot contain an effect (v = d\u2032) because v 6\u2208 Vi. Therefore, the threat described above can never occur in \u03a0. \u2013 If \u3008v, d\u3009 is partially private to j w.r.t. i, then cl = \u03b10 \u3008v,d\u3009\u2192 \u03b11 will be seen as cl = \u03b10 \u3008v,\u22a5\u3009\u2192 \u03b11 in\nviewi(\u03a0). Since \u22a56= d, agent i will be able to detect and address the threat between \u03b1t and cl.\nConsequently, an agent can always detect the arising threats when it adds a new action, \u03b1t, in the plan. Now, we should study whether the potential threats caused by actions in \u03a0 on the causal links that support the action \u03b1t are correctly detected by agent i. Suppose that there is a causal link cl\u2032 = \u03b2 \u3008v\u2032,e\u3009\u2192 \u03b1t, and an action \u03b3 with an effect (v\u2032 = e\u2032) which is not ordered with respect to \u03b1t. Again, agent imay find itself in three different scenarios according to its view of (v\u2032 = e\u2032):\n\u2013 If (v\u2032 = e\u2032) is public to i and j, the threat between\ncl\u2032 and \u03b3 will be correctly detected by i.\n\u2013 If (v\u2032 = e\u2032) is private to j w.r.t. i, then none of\nthe variables in PRE(\u03b1t) are related to v \u2032 because\nv\u2032 6\u2208 Vi. Thus, this threat will never arise in \u03a0. \u2013 If (v\u2032 = e\u2032) is partially private to j w.r.t. i, (v\u2032 = e\u2032)\nwill be seen as (v\u2032 =\u22a5) in viewi(\u03a0). Since \u22a56= e, the threat between \u03b3 and cl\u2032 will be correctly detected by agent i.\nNote that privacy does not prevent agents from detecting and solving threats nor does it affect the complexity of the process. If the fluent is public or partially private, the agent that is refining the plan will be able to detect the threat because it either sees the value of the variable or sees \u22a5, and both contradict the value of the variable in the causal link. If the fluent is private, then there is no such threat. This proves that FMAP is sound.\n4.3 DTG-based Heuristic Function\nThe last aspect of FMAP to analyze is how agents evaluate the refinement plans. FMAP guides the search\nthrough a domain-independent heuristic function, as most planning systems do [30]. It uses the information provided by the frontier states to perform the heuristic evaluation of the plans contained in the tree nodes.\nAccording to the definition shown in section 4.1, the frontier state of a plan \u03a0, FS(\u03a0), can be easily computed as the finite set of fluents that results from executing the actions of the plan \u03a0 in I, the initial state of TMAP . Since refinement plans are not sequential plans, the actions in \u2206 have to be linearized in order to compute the frontier state. The linearization of a refinement plan \u03a0 involves establishing a total order among the actions in \u2206. Given two actions \u03b1 \u2208 \u2206 and \u03b2 \u2208 \u2206, if \u03b1 \u227a \u03b2 \u2208 OR or \u03b2 \u227a \u03b1 \u2208 OR, we keep this ordering constraint in the linearized plan. If \u03b1 and \u03b2 are non-sequential actions, we establish a total ordering among them. Since plans returned by FLEX are free of conflicts, it is irrelevant how non-sequential actions are ordered.\nFrontier states allow us to make use of state-based\nheuristics such as hFF , the relaxed planning graph (RPG) heuristic of FF [15]. However, the distributed approach and the privacy model of FMAP makes the application of hFF inadequate to guide the search. Since none of the agents has knowledge that is complete enough to build an RPG by itself, using hFF to estimate the quality of a refinement plan involves agents building a distributed RPG [42]. This is a costly process that requires many communications among agents to coordinate which each other, and it has to be repeated for the evaluation of each refinement plan. Therefore, the\npredictable high computational cost of the application of hFF led us to discard this choice and opt for designing a heuristic that is based on Domain Transition Graphs (DTGs) [14].\nA DTG is a directed graph that shows the ways in which a variable can change its value [14]. Each transition is labeled with the necessary conditions for this to happen; i.e., the preconditions that are common to all the actions that induce the transition. Since DTGs are independent of the state of the plan, recalculations are avoided during the planning process.\nPrivacy is kept in DTGs through the use of the undefined value \u22a5. This value is represented in a DTG like the rest of the values of the variables, the only difference being that transitions from/to \u22a5 are labeled with the agents that induce them.\nConsider a reduced version of Example 1 that is depicted in Fig. 6. In this example, both transport agents ta1 and ta2 can use truck t1 within their geographical areas ga1 and ga2, respectively. Fig. 7 shows the DTG of the variable \u3008pos-rm\u3009. In a single-agent task (upper diagram) all the information is available in the DTG. However, in the multi-agent task (bottom diagrams), agent ta1 does not know the location of rm if ta2 transports it to f , while ta2 does not know the initial placement of rm, since location l1 lies outside ta2\u2019s geographical area, ga2. In order to evaluate the cost of achieving \u3008pos-rm, f\u3009 from the initial state, ta1 will first check its DTG, thus obtaining the cost of loading rm in t1. As shown in Fig. 7, the transition between values t1 and \u22a5 is labeled with agent ta2. Therefore, ta1 will ask ta2 for the cost of the path between values t1 and f to complete the calculation. Communications are required to evaluate multi-agent plans, but DTGs are more efficient than RPGs because they remain constant during planning, so agents can minimize the overhead by memorizing paths and distances between values.\nFor a given plan \u03a0, our DTG-based heuristic function (hDTG in the following) returns the number of actions of a relaxed plan between the frontier state FS(\u03a0) and the set of goals of TMAP , G. hDTG performs a backward search introducing the actions that support the goals in G into the relaxed plan until all their preconditions are supported. Hence, the underlying principle of hDTG is similar to hFF , except for the fact that DTGs are used instead of RPGs to build the relaxed plan.\nThe hDTG evaluation of a plan \u03a0 begins by calculating the frontier state FS(\u03a0). Next, an iterative procedure is performed to build the relaxed plan. This procedure manages a list of fluents, openGoals, initially set to G. The process iteratively extracts a fluent from openGoals and supports it through the introduction of an action in the relaxed plan. The preconditions of such\nan action are then included in the openGoals list. For each variable v \u2208 V, the procedure manages a list of values, V aluesv, which is initialized to the value of v in the frontier state FS(\u03a0). For each action added to the relaxed plan that has an effect (v = d\u2032), d\u2032 will be stored in V aluesv. An iteration of the hDTG evaluation process executes the following stages:\n\u2013 Open goal selection: From the openGoals set, the\nprocedure extracts the fluent \u3008v, dg\u3009 \u2208 openG that requires the largest number of value transitions to be supported. \u2013 DTG path computation: For every value d0 in\nV aluesv, this stage calculates the shortest sequence of value transitions in v\u2019s DTG from d0 to dg. Each path is computed by applying Dijkstra\u2019s algorithm between the nodes d0 and dg in the DTG associated to variable v. The path with the minimum length is stored asminPath = ((d0, d1), (d1, d2), . . . , (dg\u22121, dg)).\n\u2013 Relaxed plan construction: For each value tran-\nsition (di, di+1) \u2208 minPath, the minimum-cost action \u03b1min that produces such a transition is introduced in the relaxed plan; that is, \u3008v, di\u3009 \u2208 PRE(\u03b1min) and (v = di+1) \u2208 EFF (\u03b1min). The cost of an action is computed as the sum of the minimum number of value transitions required to support its preconditions. The unsupported preconditions of \u03b1min are stored in openGoals, so they will be supported in the subsequent iterations. For each effect (v\u2032 = d\u2032) \u2208 EFF (\u03b1min), the value d \u2032 is stored in V aluesv\u2032 , so d\u2032 can be used in the following iterations to support other openGoals.\nThe iterative evaluation procedure carries on until all the open goals have been supported, that is, openGoals = \u2205, and hDTG returns the number of actions in the relaxed plan.\n4.4 Limitations of FMAP\nIn this section, we present some limitations of FMAP that are worth discussing. FMAP builds upon the POP paradigm, so it can handle plans with parallel actions and only enforces an ordering when strictly necessary. FMAP, however, does not yet explicitly manage time constraints nor durative actions. A POP-based planner can easily be extended to incorporate time because the application of the least-commitment principle provides a high degree of execution flexibility. Additionally, POP is independent of the assumption that actions must be instantaneous or have the same duration and allows actions of arbitrary duration and different types of temporal constraints to be defined as long as the conditions\nunder which actions interfere are well defined [34]. In short, POP represents a natural and very appropriate way to include and handle time in a planning framework.\nFLEX involves the construction of a POP tree for each potentially supportable action (see Fig. 5). This procedure is more costly than the operations required by a standard planner to refine a plan. However, the search trees are independent of each other, which makes it possible to implement FLEX by using multiple execution threads. Parallelization improves the performance of FLEX and the ability of FMAP to scale up. Section 5 provides more insight into the FLEX implementation.\nCurrently, FMAP is limited to cooperative goals, which means that all the goals are defined as global objectives to all the participating agents (see section 3). Nevertheless, as a future work, we are considering an extension of FMAP to support self-interested agents with local goals.\nFMAP is a general procedure aimed at solving any kind of MAP task. In particular, solving tightly-coupled tasks requires a great amount of coordination. Multiagent coordination in distributed systems where agents must cooperate is always a major issue. This dependency on coordination makes FMAP a communicationreliant approach. Agents not only have to communicate the refinement plans that they build at each iteration, but they also have to communicate during the heuristic evaluation of the refinement plans in order to maintain privacy (see subsection 4.3). The usage of a coordinator agent effectively reduces the need for communication. The experimental results will show that FMAP can effectively tackle large problem instances (see section 5). Nevertheless, reducing communication overhead while keeping the ability to solve any kind of task remains an ongoing research topic that we plan to consider for future developments.\nPrivacy management is another issue that potentially worsens the performance of FMAP. In section 3.1, we defined a mechanism to detect and address threats in partial plans, even when agents do not have a complete view of such plans. Privacy does not add extra complexity to FLEX since agents manage the undefined value \u22a5 as any other value in the domain of a variable. It does, however, make the refinement-plan communication stage more complex because, when an agent i sends viewj(\u03a0) to an agent j, this implies that i must previously adapt the information of \u03a0 according to the privacy rules defined w.r.t. to j.\nPrivacy also affects the heuristic evaluation of the plans in terms of quality. Since a refinement plan is only evaluated by the agent that generates it and this evaluation is influenced by the agent\u2019s view of the plan,\nthe result may not be as accurate as if the agent had had a complete view of the plan. Empirical results, however, will show that, even with these limitations, our heuristic function provides good performance in a wide variety of planning domains (see section 5)."}, {"heading": "5 Experimental results", "text": "In order to assess the performance of FMAP, we ran experimental tests with some of the benchmark problems from the International Planning Competitions2 (IPC). More precisely, we adapted the STRIPS problem suites of 10 different domains from the latest IPC editions to a MAP context. The tests compare FMAP with two different state-of-the-art MAP systems: MAPR [2] and MAP-POP [37]. We excluded Planning First [25] from the comparison because it is outperformed by MAPPOP [37].\nThis section is organized as follows: first, we provide some information on the FMAP implementation and experimental setup. Then, we present the features of the tested domains and we analyze the MAP adaptation performed for each domain. Next, we show a comparative analysis between FMAP and the aforementioned planners, MAPR [2] and MAP-POP [37]. Then, we perform a scalability analysis of FMAP and MAPR. Finally, we summarize and discuss the results obtained by FMAP and how they compare to the other two planners.\n5.1 FMAP implementation and experimental setup\nMost multi-agent applications nowadays make use of middleware multi-agent platforms that provide them with the communication services required by the agents [27]. The entire code of FMAP is implemented in Java and builds upon the Magentix2 platform3 [35]. Magentix2 provides a set of libraries to define the agents\u2019 behavior, along with the communication resources required by the agents. Magentix2 agents communicate by means of the FIPA Agent Communication Language [26]. Messaging is carried out through the Apache QPid broker4, which is a critical component for FMAP agents.\nFMAP is optimized to take full advantage of the CPU execution threads. The FLEX procedure, which generates refinement plans over a given base plan, develops a POP search tree for each potentially supportable action of the agent\u2019s domain. As the POP trees are\n2 http://ipc.icaps-conference.org/ 3 http://www.gti-ia.upv.es/sma/tools/magentix2 4 http://qpid.apache.org/\ncompletely independent from each other, the processes for building the trees run in parallel for each agent.\nAgents synchronize their activities at the end of the refinement plan generation stage. Consequently, FMAP assigns the same number of execution threads to each agent so that they all spend a similar amount of time to complete the FLEX procedure (note that if we allocate extra threads to a subset of the agents, they would still have to wait for the slowest agent to synchronize). FLEX builds as many POP search trees in parallel as execution threads agents have been allocated. The hDTG heuristic is implemented in a similar way. An agent can simultaneously evaluate as many plans as execution threads it has been allocated.\nAll the experimental tests were performed on a single machine with a quad-core Intel Core i7 processor and 8 GB RAM (1.5 GB RAM available for the Java VM). The CPU used in the experimentation has eight available execution threads, which are distributed as follows: in tasks that involve two agents, FMAP allocates four execution threads per agent; in tasks with three or four agents, each agent has two available execution threads; finally, in tasks involving five or more agents, each agent has a single execution thread at its disposal. For instance, the three agents in Example 1 would get two different execution threads in this particular machine. Hence, in the FLEX example depicted in Fig. 5, agent ta1 would be able to study two candidate actions simultaneously, thus reducing the execution time of the overall procedure.\n5.2 Planning domain taxonomy\nThe benchmark used for the experiments includes 10 different domains of the IPCs that are suitable for a multi-agent adaptation. The IPC benchmarks come from (potential) real-world applications of planning, and they have become the de facto mechanism for assessing the performance of single-agent planning systems. The elevators domain, for instance, is inspired by a real problem of Schindler Lifts Ltd. [19]; the satellite domain is motivated by a NASA space application [24]; the rovers domain deals with the decision of daily planning activities of Mars rovers [6]; and the openstacks domain is based on the minimum maximum simultaneous open stacks combinatorial optimization problem. Hence, all the domains from the IPCs resemble practical scenarios and they are modeled to keep, as much as possible, both their structure and complexity. In MAP, there is not a standardized collection of planning domains available. Instead, MAP approaches adapt some well-known IPC\ndomains to a multi-agent context, namely the satellite, rovers, and logistics domains [2,25,37].\nConverting planning domains into a multi-agent version is not always possible due to the domain characteristics. While some IPC domains have a straightforward multi-agent decomposition, others are inherently single-agent. We developed a domain-dependent tool to automatically translate the original STRIPS tasks into our PDDL-based MAP language.\nThe columns in Table 1 describe the main features of the 10 MAP domains that are included in the benchmark. Typology indicates whether the MAP tasks of the domain are loosely-coupled or tightly-coupled. IPC shows the last edition of the IPC in which the domain was included. Agents indicates the types of object used to define the agents. Cooperative goals indicates the presence or absence of these goals in the tasks of each domain. Finally, Applicability shows the MAP systems that are capable of coping with each domain.\nIn order to come up with a well-balanced benchmark, we put the emphasis on the presence (or absence) of specialized agents and cooperative goals. Besides the adaptation to a multi-agent context, the 10 selected domains are a good representative sample of looselycoupled domains with non-specialized agents and tightlycoupled domains with cooperative goals.\nPrivacy in each domain is defined according to the nature of the problem and the type of agents involved, while maintaining a correlation and identification with the objects in a real-world problem."}, {"heading": "5.2.1 Loosely-coupled domains", "text": "The five loosely-coupled domains presented in Table 1 are: Blocksworld, Driverlog, Rovers, Satellite, and Zenotravel. The prime characteristic of these domains is that agents have the same planning capabilities (operators) such that each task goal can be individually solved by a single agent. That is, tasks can be addressed without\ncooperation among agents. Next, we provide some insight into the features of these domains and the MAP adaptations.\nSatellite [24]. This domain offers a straightforward multi-agent decomposition [25,37]. The MAP domain features one agent per satellite. The resulting MAP tasks are almost decoupled as each satellite can attain a subset of the task goals (even all the goals in some cases) without interacting with any other agent. The number of agents in the tasks of this domain vary from 1 to 12. The location, orientation, and instruments of a satellite are private to the agent, only the information on the images taken by the satellites is defined as public.\nRovers [24]. Like the Satellite domain, Rovers also\noffers a straightforward decomposition [25,37]. The MAP domain features one agent per rover. Rovers collect samples of soil and rock and hardly interact with each other except when a soil or rock sample is collected by an agent, and so it is no longer available to the rest of the agents. The number of agents ranges from 1 to 8 rovers per task. As in the Satellite domain, only the information related to the collected samples is defined as public.\nBlocksworld. The MAP version of this domain introduces a set of robot agents (four agents per task), each having an arm to arrange blocks. Unlike the original domain, the MAP version of Blocksworld allows handling more than one block at a time. All the information in this domain is considered to be public.\nDriverlog [24]. In this MAP domain, the agents are the drivers of the problem, ranging between 2 and 8 agents per task. Driver agents are in charge of driving the available trucks and delivering the packages to the different destinations. All the information in the domain (status of drivers, trucks, and packages) is publicized by the driver agents.\nZenotravel [24]. This domain defines one agent per aircraft. The simplest tasks include one agent and the\nmost complex ones up to five agents. Aircraft can directly transport passengers to any city in the task. As in the Blocksworld and Driverlog domains, all the information concerning the situation of the passengers and the current location of each aircraft is publicly available to all the participating agents."}, {"heading": "5.2.2 Tightly-coupled domains", "text": "We also analyzed five additional domains that feature specialized agents with different planning capabilities: Depots, Elevators, Logistics, Openstacks and Woodworking. The features of these domains give rise to complex, tightly-coupled tasks that require interactions or commitments [13] among agents in order to be solved.\nDepots [24]. This domain includes two different types of specialized agents, depots and trucks, that must cooperate in order to solve most of the goals of the tasks. This domain, which is the most complex one in our MAP benchmark, leads to tightly-coupled MAP tasks with many dependences among agents. Depots tasks contain a large number of participating agents, ranging from 5 to 12 agents. Only the location of packages and trucks is defined as public information.\nElevators. Each agent in this domain can be a slowelevator or a fast-elevator. Operators in the STRIPS domain are basically the same for both types of elevators since the differences between them only affect the action costs. Elevator agents, however, are still specialized because the floors they can access are limited. This leads to tasks that require cooperation to fulfill some of the goals. For instance, an elevator may not be able to take a passenger to a certain floor, so it will stop at an intermediate floor so that the passenger can board another elevator that goes to that floor. Tasks include from 3 to 5 agents. Agents share the information regarding the location of the different passengers.\nLogistics. This domain presents two different types of specialized agents: airplanes and trucks. The delivery of some of the packages involves the cooperation of several truck and airplane agents (similarly to the example task introduced in this article). Tasks feature from 3 to 10 different agents. Information regarding the position of the packages is defined as public.\nOpenstacks [11]. This MAP domain includes two specialized agents in all of the tasks; the manager is in charge of handling the orders, and the manufacturer controls the different stacks and manufactures the products. Both agents depend on each other to perform their activities, thus resulting in tightly-coupled MAP tasks with inherently cooperative goals. Most of the information regarding the different orders and products is\npublic since both agents need it to interact with each other.\nWoodworking. This domain features four different types of specialized agents (a planer, a saw, a grinder and a varnisher) that represent the machines in a production chain. In most cases, the output of one machine constitutes the input of the following one, so Woodworking agents have to cooperate to fulfill the different goals. All the tasks include four agents (a machine of each type). All the information on the status of the different wood pieces is publicized since agents require this information in order to operate.\n5.3 FMAP vs. MAPR comparison\nThis subsection compares the experimental results of FMAP and MAPR [2]. MAPR is implemented in Lisp and uses LAMA [29] as the underlying planning system, without using a middleware platform for multi-agent systems. Each experiment is limited to 30 minutes.\nTable 2 shows the comparative results for FMAP and MAPR. The Solved columns refer to the number of tasks solved by each approach. The average number of actions, makespan (plan duration), and search time consider only the tasks solved by both FMAP and MAPR (the Common column shows the number of tasks solved by both planners). Actions, makespan, and time values in MAPR are relative to the results obtained with FMAP. The values nx in Table 3 indicate \u201dn times as much as the FMAP result\u201d. Therefore, an Actions or Makespan value that is higher than 1x is a better result for FMAP and a value lower than 1x is a worse result for FMAP. However, a Time value higher than 1x indicates a better result for FMAP.\nOf the most recent MAP systems, MAPR is one that offers excellent performance in comparison to other state-of-the-art MAP approaches [2]. However, as reflected in Table 1, MAPR is only compatible with the loosely-coupled domains in the benchmark. This limitation is due to the planning approach of MAPR. Specifically, MAPR applies a goal allocation procedure, decomposing the MAP task into subtasks and giving each agent a subset of the task goals to solve. Each agent subtask is solved with the single-agent planner LAMA [29] such that the resulting subplans are progressively combined into a global solution. This makes MAPR an incomplete planning approach that is limited to looselycoupled tasks without cooperative goals. That is, MAPR is built under the assumption that each goal must be addressed by at least one of the agents in isolation [2].\nWhereas the communication overhead is relatively high in FMAP (to a large extent, this is due to the use\nof the Magentix MAS platform), agents in MAPR do not need to communicate during the plan construction because each agent addresses its allocated subgoals by itself. This setup has a rather positive impact on the execution times and the number of problems solved (coverage). As expected, Table 2 shows that execution times in MAPR are much lower than FMAP. With respect to coverage, MAPR solves 110 out of 114 loosely-coupled tasks (roughly 96% of the tasks), while FMAP solves 87 of such tasks (76%).\nHowever, in most domains, FMAP comes up with better quality plans than MAPR, taking into account the number of actions as well as the makespan. MAPR is limited by the order in which agents solve their subtasks. The first agent that computes a subplan cannot take advantage of the potential synergies that may arise from other agents\u2019 actions; the second agent has only the information of the first agent\u2019s subplan, and so on. Additionally, the allocation of goals to each agent may lead to poorly balanced plans. Although FMAP is a more time-consuming approach, it avoids these limitations because agents work together to build the plan action by action. Thus, FMAP provides agents with a global view of the plan at each point of the construction process, while agents in MAPR keep a local view of the plan at hand.\nThe Driverlog domain, while being loosely-coupled, offers many possible synergies between agents. For instance, a driver agent can use a truck to travel to its destination and load a package on its way, while another agent may take over the truck and complete the delivery. If the first agent acted in isolation, it would deliver the package and then go back to its destination, which would result in a worse plan. Robot agents in the Blocksworld domain can also cooperate to improve the quality of the plans: for instance, a robot can pick up a block so that another robot can retrieve the block below. Goal balance is also a key aspect in Zenotravel since aircraft agents have limited autonomy. If an aircraft solves too many goals it may be forced to refuel thereby worsening the plan quality.\nFig. 8 illustrates the MAPR limitations by showing the solution plans obtained by both approaches for task 8 of the Zenotravel domain. The goals of this task\ninvolve transporting three different people and flying plane1 to city3. The first three goals are achievable by all the plane agents, but the last goal can only be completed by agent plane1.\nMAPR starts with agent plane3, which solves all of the goals that it can. Then, plane1 receives the subplan and completes it by solving the remaining goal. The resulting joint plan is far from the optimal solution. Agent plane3 requires 10 time units to solve its subplan because it transports all of the passengers. The high number of fly actions forces the agent to introduce additional actions to refuel its tank. On the other hand, agent plane1 flies directly to its destination without transporting any passengers.\nIn contrast, agents in FMAP progressively build the solution plan together without using an a-priori goal allocation, which allows them to obtain much better quality plans, taking advantage of synergies between actions of different agents and effectively balancing the workload among agents. Fig. 8 shows that, in FMAP, agent plane1 transports person6 to its destination, thus simplifying the activities of plane3, which avoids refueling. The resulting plan is a much shorter and better balanced solution than the MAPR plan (only 6 time steps versus 10 time steps in MAPR) and it requires fewer actions (13 actions versus 16 in MAPR).\nTable 2 shows that FMAP noticeably improves plan quality except in the most decoupled domains, namely Rovers and Satellite (in the latter, FMAP results are slightly better than MAPR results). In these domains, synergies among agents are minimal or even nonexistent. Consequently, MAPR is not penalized by its search scheme, obtaining plans of similar quality to FMAP.\n5.4 FMAP vs. MAP-POP comparison\nWe compared FMAP with another recent MAP system, MAP-POP [37]. Like FMAP, MAP-POP agents explore the space of multi-agent plans jointly. This setup allows MAP-POP to overcome some of the limitations of MAPR since it is able to tackle tightlycoupled tasks with cooperative goals. However, MAPPOP has two major disadvantages. Much like MAPR,\nMAP-POP is an incomplete approach because it implicitly bounds the search tree by limiting its branching factor. This may prevent agents from generating potential solution plans [37]. Additionally, MAP-POP is based on backward-chaining POP technologies, thus relying on heuristics that offer a rather poor performance in most MAP domains.\nTable 3 shows the comparison between FMAP and MAP-POP. As in Table 2, the average results consider only the tasks solved by both approaches (the FMAP results for Openstacks and Woodworking domains include all the tasks solved by this approach because MAP-POP does not solve any of the tasks). The figures in FMAP show the results obtained using FMAP for the common problems; MAP-POP values are relative to the results of FMAP.\nIn general, FMAP results are better than MAPPOP results in almost every aspect. In terms of coverage, FMAP clearly outperforms MAP-POP, solving 178 out of 244 tasks (roughly 73% of the tasks in the benchmark), while MAP-POP solves only 54 tasks (22%). Overall, in MAP-POP there are problems with some of the most complex tightly-coupled domains (specifically, Depots, Openstacks, and Woodworking), but it\nperforms well in the Elevators domain. With respect to the loosely-coupled domains, MAP-POP attains only the simplest tasks, solving from three to seven tasks per domain.\nIt is difficult to compare the results related to plan quality due to the low coverage of MAP-POP. Focusing on the domains in which MAP-POP solves a significant number of tasks, we observe that MAP-POP obtains slightly better solution plans than FMAP in Blocksworld and Satellite. FMAP, however, outperforms MAP-POP in Elevators, the domain in which both approaches solve the largest number of tasks.\nFinally, the results show that FMAP is much faster than MAP-POP, from 5 times faster in Logistics to even 1000 times faster in the Driverlog domain. MAP-POP only obtains faster times than FMAP in the seven Satellite tasks.\n5.5 Scalability analysis\nWe prepared two additional experiments to analyze the ability of FMAP and MAPR to scale up. The first test analyzes how both planners scale up when the number of agents of a task is increased, keeping the rest of the\nt2\nl4\nl3\nl6\nl5\np4\np3 t1\nl2\nl1\np2\np1 t3 ... t15\nFig. 9 Logistics-like scalability task\nFig. 10 Scalability results for the logistics-like task\nparameters unchanged. More specifically, we designed a loosely-coupled logistics-like transportation task, which is shown in Fig. 9. The basic task includes two different trucks, t1 and t2. Truck t1 moves between locations l1 and l2, and truck t2 moves between locations l3 and l4; there is no connection between t1\u2019s and t2\u2019s locations. The trucks have to transport a total of four packages, p1 . . . p4, as shown in Fig 9. In order to ensure that MAPR is able to solve the task, both t1 and t2 can solve two of the four problem goals by themselves: t1 will deliver p1 and p2, while t2 will transport p3 and p4. Therefore, cooperation is not required in this task, as opposed to the IPC logistics domain.\nWe defined and ran 14 different tests for this basic task. In each test, the number of agents in the task is increased by one, ranging from 2 to 15 truck agents. The problems are modeled so that the extra truck agents, t3 . . . t15, are placed in a separate location l5, from which there is no access to the locations that t1 and t2 can move through. Therefore, the additional agents included in each task are unable to solve any of the task goals. However, they do propose refinement plans in FMAP (more precisely, they introduce an action to move to l6, as shown in Fig. 9), increasing the complexity of the task in terms of both the number of messages exchanged and the branching factor of the FMAP search tree.\nThe plot in Fig. 10 separately depicts the time required by each process in FMAP. We show the time required by FLEX to generate the refinement plans, the time consumed by the hDTG evaluation procedure, and the time spent by agents to communicate and syn-\nchronize, which includes the base plan selection and the exchange of plans among agents. Every task was solved by FMAP in 14 iterations, resulting in a 12-action solution plan (truck t1 and truck t2 each introduced six actions).\nAs Fig. 10 shows, FLEX has a noticeably low impact on the overall execution time. This proves that, even when dealing with privacy and building a tree for each potentially supportable action, FLEX offers good performance and does not limit FMAP\u2019s scalability.\nEven though each task only required 14 iterations to be solved, the growing number of agents increases the size of the search tree. In the two-agent task, the agents generate an average of 3.3 refinement plans per iteration, while in the 15-agent task, the average branching factor goes up to 11.8 refinement plans. Nevertheless, this does not affect the time consumed by hDTG, which remains relatively constant in all tasks. Since agents evaluate plans simultaneously, the evaluation time hardly grows when the number of participants increases.\nFig. 10 confirms that communications among agents are the major bottleneck of FMAP. As the number of agents increases, so does the branching factor. Therefore, each agent has to communicate more refinement plans to a higher number of participants. Synchronizing a larger number of agents is also more complex, which increases the number of exchanged messages. All these communications are managed by a centralized component, the QPid broker, which is negatively affected by the communication overhead of the system.\nThe behaviour of MAPR remains constant in all of the tests, taking about 0.2 seconds to resolve each task. Since MAPR does not require communications, the growing number of agents does not affect its performance. Note that if we consider only the time spent by hDTG (around 0.8 seconds per test) and FLEX (approximately 0.02 seconds), FMAP execution times are quite similar to MAPR.\nThe resolution of this loosely-coupled task does not require coordination in order to be able to compare with MAPR. However, the coordination mechanism and message exchange of FMAP is equally applied to all planning tasks. Hence, the ability to solve tightly-coupled tasks requires great coordination, which is not the case for MAPR.\nWe performed a second experiment based on the satellite domain to assess the scalability of the two planners when both the number of agents and the number of goals increase, thus increasing the complexity of the task. We also defined 14 MAP tasks, ranging from 2 to 15 satellite agents. The simplest task comprises two satellite agents, s1 and s2, which must take an image of two different planets. The satellites are configured so that each one of them can capture an image of a single planet. The instruments they have on board are turned on and calibrated, so the agent can directly reorient and acquire the image. Unlike the first test, each satellite task adds one more goal over the previous task, as well as an extra agent. Then, the additional agents, s3 . . . s15, must each solve a goal by themselves. This increases the branching factor as well as the number of iterations for solving a task.\nFig. 11 shows the results for this scenario. The solution plans obtained by FMAP range from 4 actions (in the two-agent task) to 30 actions (in the 15-agent task). FMAP required 31 iterations to solve the 15-agent task and only 4 iterations for the two-agent task. The growing complexity also affects the average branching factor, which ranges from 25.67 to 255.06 plans.\nAs Fig 11 shows, the complexity of the tasks does not affect FLEX, which takes less than 0.2 seconds in each task. In general, the performance of FLEX only decreases when handling very large base plans in domains with many applicable actions. We can therefore conclude that FLEX is an efficient and highly scalable component of FMAP.\nWith regard to the hDTG heuristic, evaluation times range from 0.35 seconds for the simplest task to 26.64 seconds for the most complex one. Although the evaluation time is slightly higher than the generation time, we can affirm that this is a good performance considering that: 1) the branching factor and the number of iterations increase from task to task, which results in a much larger number of plans to evaluate; and 2) unlike FLEX, the evaluation function hDTG also involves some communications among agents, which obviously increase when the number of agents goes up. All in all, and considering just the times of hDTG and FLEX, FMAP is only about 9 times slower in the 15-agent task than MAPR, which completes this task in 3 seconds.\nIn summary, both tests confirm that communication overhead is the main issue of FMAP with regard to scalability. Communicating plans and synchronizing agents are rather costly tasks, especially when dealing with complex tasks that combine a large branching factor and a high number of participating agents.\n5.6 Discussion of the results\nThe experimental results support our initial claim: FMAP is a domain-independent approach that offers a good trade-off between coverage and execution times being and is able to solve any typology of MAP task.\nWe compared FMAP against two different state-ofthe-art MAP approaches. On the one hand, MAPR is designed as a fast MAP solver. The results show that MAPR provides excellent execution times, but its performance comes at a cost: it completely rules out tightly-coupled domains that require cooperation. Many real-world domains, such as logistics or production supplychains, require cooperation between independent entities. Hence, non-cooperative planners for solving disjoint subtasks in which agents can effectively avoid interactions are not suitable for many real-world MAP problems. Overall, in the experiments, MAPR solves 45% of the whole benchmark while FMAP solves 73% of the tasks.\nOn the other hand, MAP-POP is a general approach that is capable of solving any type of planning task like FMAP. The approach followed by MAP-POP is clearly influenced by the use of backward-chaining POP technologies and, in particular, by the application of low-informative heuristics. This planner offers the worst results in terms of coverage and execution times, thus indicating that FMAP represents a step ahead in multiagent cooperative planning.\nWith regard to the scalability tests, it has been proved that the FMAP ability to scale up is only affected by communications. While MAPR performance is unaltered when the number of agents increases, FMAP performance is affected by its heavy dependency on agent communications. These results lead us to one of our future lines of work, studying techniques to reduce overhead communication without losing the ability to tackle any kind of MAP task."}, {"heading": "6 Conclusions", "text": "FMAP is a general-purpose MAP model that supports inherently distributed domains and defines an advanced notion of privacy. Agents in FMAP use an internal POP procedure to calculate all possible ways to refine\na plan, which guarantees FMAP completeness. Agents exchange plans and their evaluations by means of a communication mechanism that is governed by a coordinator agent. FMAP exploits the structure of distributed state-independent domain transition graphs for the heuristic evaluation of the plans, thus avoiding having to recalculate estimates in each node of the POP search tree.\nPrivacy is maintained throughout the entire search process. Agents only communicate the relevant information they share with the rest of the agents. This advanced notion of privacy is very useful for modeling real-world problems. The experiments show that dealing with privacy has a relatively low impact on the overall performance of FMAP.\nThe exhaustive testing on IPC benchmarks shows that FMAP outperforms other state-of-the-art MAP frameworks because it is capable of solving tightly-coupled domains with specialized agents and cooperative goals as well as loosely-coupled problems. The performance of FMAP is only affected by the extensive communications among agents. To the best of our knowledge, FMAP is currently likely to be the most competitive domain-independent cooperative MAP system.\nAcknowledgements This work has been partly supported by the Spanish MICINN under projects Consolider Ingenio 2010 CSD2007-00022 and TIN2011-27652-C03-01, the Valencian Prometeo project II/2013/019, and the FPI-UPV scholarship granted to the third author by the Universitat Polite\u0300cnica de Vale\u0300ncia."}], "references": [{"title": "Temporal planning with preferences and time-dependent continuous costs", "author": ["J. Benton", "A. Coles", "A. Coles"], "venue": "Proceedings of the 22nd International Conference on Automated Planning and Scheduling (ICAPS), pp. 2\u201310", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Multi-agent planning by plan reuse", "author": ["D. Borrajo"], "venue": "Proceedings of the 12th International Conference on Autonomous Agents and Multi-agent Systems (AAMAS), pp. 1141\u20131142", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "Partial-order planning with concurrent interacting actions", "author": ["C. Boutilier", "R. Brafman"], "venue": "Journal of Artificial Intelligence Research 14(105), 136", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2001}, {"title": "From one to many: Planning for loosely coupled multi-agent systems", "author": ["R. Brafman", "C. Domshlak"], "venue": "Proceedings of the 18th International Conference on Automated Planning and Scheduling (ICAPS), pp. 28\u201335", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2008}, {"title": "Continual planning and acting in dynamic multiagent environments", "author": ["M. Brenner", "B. Nebel"], "venue": "Journal of Autonomous Agents and Multiagent Systems 19(3), 297\u2013 331", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Planning under continuous time and resource uncertainty: A challenge for AI", "author": ["J. Bresina", "R. Dearden", "N. Meuleau", "S. Ramakrishnan", "D. Smith", "R. Washington"], "venue": "Proceedings of the 18th Conference on Uncertainty in Artificial Intelligence, pp. 77\u201384", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2002}, {"title": "Efficient and distributable methods for solving the multiagent plan coordination problem", "author": ["J. Cox", "E. Durfee"], "venue": "Multiagent and Grid Systems 5(4), 373\u2013408", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2009}, {"title": "Automated agent decomposition for classical planning", "author": ["M. Crosby", "M. Rovatsos", "R. Petrick"], "venue": "Proceedings of the 23rd International Conference on Automated Planning and Scheduling (ICAPS), pp. 46\u201354", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2013}, {"title": "\u03bc-satplan: Multi-agent planning as satisfiability", "author": ["Y. Dimopoulos", "M.A. Hashmi", "P. Moraitis"], "venue": "Knowledge-Based Systems 29, 54\u201362", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "STRIPS: A new approach to the application of theorem proving to problem solving", "author": ["R. Fikes", "N. Nilsson"], "venue": "Artificial Intelligence 2(3), 189\u2013208", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1971}, {"title": "Deterministic planning in the fifth International Planning Competition: PDDL3 and experimental evaluation of the planners", "author": ["A. Gerevini", "P. Haslum", "D. Long", "A. Saetti", "Y. Dimopoulos"], "venue": "Artificial Intelligence 173(5-6), 619\u2013668", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}, {"title": "Automated Planning", "author": ["M. Ghallab", "D. Nau", "P. Traverso"], "venue": "Theory and Practice. Morgan Kaufmann", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "Constraint satisfaction as a tool for modeling and checking feasibility of multiagent commitments", "author": ["A. G\u00fcnay", "P. Yolum"], "venue": "Applied Intelligence 39(3), 489\u2013509", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2013}, {"title": "A planning heuristic based on causal graph analysis", "author": ["M. Helmert"], "venue": "Proceedings of ICAPS pp. 161\u2013170", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2004}, {"title": "The FF planning system: Fast planning generation through heuristic search", "author": ["J. Hoffmann", "B. Nebel"], "venue": "Journal of Artificial Intelligence Research 14, 253\u2013302", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2001}, {"title": "Modeling and solving distributed configuration problems: A CSP-based approach", "author": ["D. Jannach", "M. Zanker"], "venue": "IEEE Transactions on Knowledge and Data Engineering 25(3), 603\u2013618", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "Scaling up multiagent planning: A best-response approach", "author": ["A. Jonsson", "M. Rovatsos"], "venue": "Proceedings of the 21st International Conference on Automated Planning and Scheduling (ICAPS), pp. 114\u2013121. AAAI", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2011}, {"title": "Dynamic distributed lanes: motion planning for multiple autonomous vehicles", "author": ["R. Kala", "K. Warwick"], "venue": "Applied Intelligence pp. 1\u201322", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2014}, {"title": "An AI-based approach to destination control in elevators", "author": ["J. Koehler", "D. Ottiger"], "venue": "AI Magazine 23(3), 59\u201378", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2002}, {"title": "Complete BNF description of PDDL3.1", "author": ["D.L. Kovacs"], "venue": "Tech. rep", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2011}, {"title": "Quantifying privacy in multiagent planning", "author": ["R. van der Krogt"], "venue": "Multiagent and Grid Systems 5(4), 451\u2013469", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2009}, {"title": "Planning for loosely coupled agents using partial order forward-chaining", "author": ["J. Kvarnstr\u00f6m"], "venue": "Proceedings of the 21st International Conference on Automated Planning and Scheduling (ICAPS), pp. 138\u2013145. AAAI", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "Evolution of the GPGP/TAEMS domainindependent coordination framework", "author": ["V. Lesser", "K. Decker", "T. Wagner", "N. Carver", "A. Garvey", "B. Horling", "D. Neiman", "R. Podorozhny", "M. Prasad", "A Raja"], "venue": "Autonomous agents and multi-agent systems 9(1-2), 87\u2013143", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "The 3rd International Planning Competition: results and analysis", "author": ["D. Long", "M. Fox"], "venue": "Journal of Artificial Intelligence Research 20, 1\u201359", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2003}, {"title": "A general, fully distributed multi-agent planning algorithm", "author": ["R. Nissim", "R. Brafman", "C. Domshlak"], "venue": "Proceedings of the 9th International Conference on Autonomous Agents and Multiagent Systems (AAMAS), pp. 1323\u2013 1330", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2010}, {"title": "Fipa - towards a standard for software agents", "author": ["P. O\u2019Brien", "R. Nicol"], "venue": "BT Technology Journal 16(3), 51\u201359", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1998}, {"title": "A multiagent framework for coordinated parallel problem solving", "author": ["P. \u00d6zt\u00fcrk", "K. Rossland", "O. Gundersen"], "venue": "Applied Intelligence 33(2), 132\u2013143", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2010}, {"title": "Communication constraints multi-agent territory exploration task", "author": ["A. Pal", "R. Tiwari", "A. Shukla"], "venue": "Applied Intelligence 38(3), 357\u2013383", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2013}, {"title": "The LAMA planner: Guiding cost-based anytime planning with landmarks", "author": ["S. Richter", "M. Westphal"], "venue": "Journal of Artificial Intelligence Research 39(1), 127\u2013177", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2010}, {"title": "A casebased approach to heuristic planning", "author": ["T. de la Rosa", "A. Gar\u0107\u0131a-Olaya", "D. Borrajo"], "venue": "Applied Intelligence 39(1), 184\u2013201", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2013}, {"title": "Planning in highly dynamic environments: an anytime approach for planning under time constraints", "author": ["O. Sapena", "E. Onaindia"], "venue": "Applied Intelligence 29(1), 90\u2013109", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2008}, {"title": "A distributed CSP approach for collaborative planning systems", "author": ["O. Sapena", "E. Onaindia", "A. Garrido", "M. Arang\u00fa"], "venue": "Engineering Applications of Artificial Intelligence 21(5), 698\u2013709", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2008}, {"title": "Strategies for avoiding preference profiling in agent-based ecommerce environments", "author": ["E. Serrano", "J. Such", "J. Bot\u0301\u0131a", "A. Gar\u0107\u0131a-Fornes"], "venue": "Applied Intelligence pp. 1\u201316", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2013}, {"title": "Bridging the gap between planning and scheduling", "author": ["D. Smith", "J. Frank", "A. J\u00f3nsson"], "venue": "Knowledge Engineering Review 15(1), 47\u201383", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2000}, {"title": "Magentix2: A privacy-enhancing agent platform", "author": ["J. Such", "A. Gar\u0107\u0131a-Fornes", "A. Espinosa", "J. Bellver"], "venue": "Engineering Applications of Artificial Intelligence pp. 96\u2013109", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2012}, {"title": "Plan coordination by revision in collective agent based systems", "author": ["H. Tonino", "A. Bos", "M. de Weerdt", "C. Witteveen"], "venue": "Artificial Intelligence 142(2), 121\u2013145", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2002}, {"title": "An approach to multi-agent planning with incomplete information", "author": ["A. Torre\u00f1o", "E. Onaindia", "O. Sapena"], "venue": "Proceedings of the 20th European Conference on Artificial Intelligence (ECAI 2012), vol. 242, pp. 762\u2013767. IOS Press", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2012}, {"title": "A flexible coupling approach to multi-agent planning under incomplete information", "author": ["A. Torre\u00f1o", "E. Onaindia", "O. Sapena"], "venue": "Knowledge and Information Systems 38(1), 141\u2013178", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2014}, {"title": "Plan repair as an extension of planning", "author": ["R. Van Der Krogt", "M. De Weerdt"], "venue": "Proceedings of the 15th International Conference on Automated Planning and Scheduling (ICAPS), pp. 161\u2013170", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2005}, {"title": "Introduction to planning in multiagent systems", "author": ["M. de Weerdt", "B. Clement"], "venue": "Multiagent and Grid Systems 5(4), 345\u2013355", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2009}, {"title": "The distributed constraint satisfaction problem: Formalization and algorithms", "author": ["M. Yokoo", "E. Durfee", "T. Ishida", "K. Kuwabara"], "venue": "IEEE Transactions on Knowledge and Data Engineering 10(5), 673\u2013685", "citeRegEx": "41", "shortCiteRegEx": null, "year": 1998}, {"title": "Graph-based multi-agent replanning algorithm", "author": ["J. Zhang", "X. Nguyen", "R. Kowalczyk"], "venue": "Proceedings of the 6th Conference on Autonomous Agents and Multiagent Systems (AAMAS), pp. 798\u2013805", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2007}], "referenceMentions": [{"referenceID": 39, "context": "work together to solve planning tasks that they are not able to solve by themselves, or to at least accomplish them better by cooperating [40].", "startOffset": 138, "endOffset": 142}, {"referenceID": 32, "context": "considered in multi-agent applications [33].", "startOffset": 39, "endOffset": 43}, {"referenceID": 20, "context": "This aspect, however, has been traditionally relegated in MAP, particularly by the planning community [21].", "startOffset": 102, "endOffset": 106}, {"referenceID": 1, "context": "While some approaches define a basic notion of privacy [2,25], others allow agents to share detailed parts of their plans or do not take private information into account at all [22].", "startOffset": 55, "endOffset": 61}, {"referenceID": 24, "context": "While some approaches define a basic notion of privacy [2,25], others allow agents to share detailed parts of their plans or do not take private information into account at all [22].", "startOffset": 55, "endOffset": 61}, {"referenceID": 21, "context": "While some approaches define a basic notion of privacy [2,25], others allow agents to share detailed parts of their plans or do not take private information into account at all [22].", "startOffset": 177, "endOffset": 181}, {"referenceID": 3, "context": "The complexity of a MAP task is often described by means of its coupling level [4], which is measured as the number of interactions that arise among agents during the resolution of a MAP task.", "startOffset": 79, "endOffset": 82}, {"referenceID": 27, "context": "responsability among agents, which are in charge of interacting with each other to coordinate their local solutions, if necessary [28,18].", "startOffset": 130, "endOffset": 137}, {"referenceID": 17, "context": "responsability among agents, which are in charge of interacting with each other to coordinate their local solutions, if necessary [28,18].", "startOffset": 130, "endOffset": 137}, {"referenceID": 21, "context": "The adoption of a centralized approach is aimed at improving the planner performance by taking advantage of the inherent structure of the MAP tasks [22,8].", "startOffset": 148, "endOffset": 154}, {"referenceID": 7, "context": "The adoption of a centralized approach is aimed at improving the planner performance by taking advantage of the inherent structure of the MAP tasks [22,8].", "startOffset": 148, "endOffset": 154}, {"referenceID": 31, "context": "Centralized approaches assume a single planning entity that has complete knowledge of the task, which is rather unrealistic if the parties involved in the task have sensitive private information that they are not willing to disclose [32].", "startOffset": 233, "endOffset": 237}, {"referenceID": 6, "context": "by themselves [7].", "startOffset": 14, "endOffset": 17}, {"referenceID": 6, "context": "The work in [7] introduces a distributed coordination framework based on partial-order planning that addresses the interactions that emerge between the agents\u2019 local plans.", "startOffset": 12, "endOffset": 15}, {"referenceID": 35, "context": "The proposal in [36] is based on the iterative revision of the agents\u2019 local plans.", "startOffset": 16, "endOffset": 20}, {"referenceID": 38, "context": "The approach in [39] uses multi-agent plan repair to solve inconsistencies among the agents\u2019 local plans while maintaining privacy.", "startOffset": 16, "endOffset": 20}, {"referenceID": 8, "context": "\u03bc-SATPLAN [9] extends a satisfiability-based planner to coordinate the agents\u2019 local plans by studying positive and negative interactions among them.", "startOffset": 10, "endOffset": 13}, {"referenceID": 6, "context": "Plan-merging techniques are not very well suited for coping with tightly-coupled tasks as they may introduce exponentially many ordering constraints in problems that require great coordination effort [7].", "startOffset": 200, "endOffset": 203}, {"referenceID": 24, "context": "For instance, Planning First [25] introduces a cooperative MAP approach for loosely-coupled tasks, in which specialized agents carry out planning individually through a state-based planner.", "startOffset": 29, "endOffset": 33}, {"referenceID": 15, "context": "The resulting local plans are then coordinated by solving a distributed Constraint Satisfaction Problem (CSP) [16].", "startOffset": 110, "endOffset": 114}, {"referenceID": 3, "context": "This combination of CSP and planning to solve MAP tasks was originally introduced by the MASTRIPS framework [4].", "startOffset": 108, "endOffset": 111}, {"referenceID": 22, "context": "One of the first approaches to domain-independent MAP is the Generalized Partial Global Planning (GPGP) framework [23].", "startOffset": 114, "endOffset": 118}, {"referenceID": 4, "context": "tinual planning (interleaving planning and execution in a world undergoing continual change), assume there is uncertainty in the world state and therefore agents do not have a complete view of the world [5].", "startOffset": 203, "endOffset": 206}, {"referenceID": 4, "context": "[5], agents have a limited knowledge of the environment and limited capabilities, but the authors do not explicitly deal with a functional distribution among agents", "startOffset": 0, "endOffset": 3}, {"referenceID": 21, "context": "tasks [22].", "startOffset": 6, "endOffset": 10}, {"referenceID": 24, "context": "The Best-Response Planning algorithm departs from an initial joint plan that is built through the Planning First MAP system [25] and iteratively improves the quality of this initial plan by applying cost optimal planning [17].", "startOffset": 124, "endOffset": 128}, {"referenceID": 16, "context": "The Best-Response Planning algorithm departs from an initial joint plan that is built through the Planning First MAP system [25] and iteratively improves the quality of this initial plan by applying cost optimal planning [17].", "startOffset": 221, "endOffset": 225}, {"referenceID": 37, "context": "MAP-POP is a fully distributed method that effectively maintains the agents\u2019 privacy [38,37].", "startOffset": 85, "endOffset": 92}, {"referenceID": 36, "context": "MAP-POP is a fully distributed method that effectively maintains the agents\u2019 privacy [38,37].", "startOffset": 85, "endOffset": 92}, {"referenceID": 1, "context": "Finally, MAPR is a recent planner that performs goal allocation to each agent [2].", "startOffset": 78, "endOffset": 81}, {"referenceID": 15, "context": "For instance, distributed CSPs use local views, such that agents only receive information about the constraints in which they are involved [16, 41].", "startOffset": 139, "endOffset": 147}, {"referenceID": 40, "context": "For instance, distributed CSPs use local views, such that agents only receive information about the constraints in which they are involved [16, 41].", "startOffset": 139, "endOffset": 147}, {"referenceID": 11, "context": "definitions are standard terms from the POP paradigm [12], which have been adapted to state variables.", "startOffset": 53, "endOffset": 57}, {"referenceID": 11, "context": "A causal link \u03b1 \u3008v,d\u3009 \u2192 \u03b2 enforces precondition \u3008v, d\u3009 \u2208 PRE(\u03b2) through an effect (v = d) \u2208 EFF (\u03b1) [12].", "startOffset": 100, "endOffset": 104}, {"referenceID": 11, "context": "\u03b1 or \u03b2 and might potentially modify the value of v [12] ((v 6= d) \u2208 EFF (\u03b3) or (v = d\u2032) \u2208 EFF (\u03b3), d\u2032 6= d), making the causal link unsafe.", "startOffset": 51, "endOffset": 55}, {"referenceID": 11, "context": "Threats are addressed by introducing either an ordering constraint \u03b3 \u227a \u03b1 (this is called demotion because the causal link is posted after the threatening action) or an ordering \u03b2 \u227a \u03b3 (this is called promotion because the causal link is placed before the threatening action) [12].", "startOffset": 274, "endOffset": 278}, {"referenceID": 30, "context": "by many planners, specifically in anytime planning, where a first initial solution is progressively refined until the deliberation time expires [31].", "startOffset": 144, "endOffset": 148}, {"referenceID": 4, "context": "Some MAP models consider that two parallel or non-sequential actions are mutually consistent if neither of them modifies the value of a state variable that the other relies on or affects [5].", "startOffset": 187, "endOffset": 190}, {"referenceID": 2, "context": "We also consider that the preconditions of two mutually consistent actions have to be consistent [3].", "startOffset": 97, "endOffset": 100}, {"referenceID": 3, "context": "MA-STRIPS [4], which was designed as a minimalistic extension to STRIPS [10], is", "startOffset": 10, "endOffset": 13}, {"referenceID": 9, "context": "MA-STRIPS [4], which was designed as a minimalistic extension to STRIPS [10], is", "startOffset": 72, "endOffset": 76}, {"referenceID": 37, "context": "PDDL-based specification language (the language syntax is detailed in [38]) rather than using MA-STRIPS.", "startOffset": 70, "endOffset": 74}, {"referenceID": 19, "context": "1 [20], the latest version of PDDL.", "startOffset": 2, "endOffset": 6}, {"referenceID": 0, "context": "OPTIC [1], for instance, combines partialorder structures with information on the frontier state", "startOffset": 6, "endOffset": 9}, {"referenceID": 21, "context": "Also, TFPOP [22] applies a centralized forward-chaining POP for multiple agents, keeping a sequential execution thread per agent.", "startOffset": 12, "endOffset": 16}, {"referenceID": 29, "context": "through a domain-independent heuristic function, as most planning systems do [30].", "startOffset": 77, "endOffset": 81}, {"referenceID": 14, "context": "Frontier states allow us to make use of state-based heuristics such as hFF , the relaxed planning graph (RPG) heuristic of FF [15].", "startOffset": 126, "endOffset": 130}, {"referenceID": 41, "context": "Since none of the agents has knowledge that is complete enough to build an RPG by itself, using hFF to estimate the quality of a refinement plan involves agents building a distributed RPG [42].", "startOffset": 188, "endOffset": 192}, {"referenceID": 13, "context": "Therefore, the predictable high computational cost of the application of hFF led us to discard this choice and opt for designing a heuristic that is based on Domain Transition Graphs (DTGs) [14].", "startOffset": 190, "endOffset": 194}, {"referenceID": 13, "context": "A DTG is a directed graph that shows the ways in which a variable can change its value [14].", "startOffset": 87, "endOffset": 91}, {"referenceID": 33, "context": "Additionally, POP is independent of the assumption that actions must be instantaneous or have the same duration and allows actions of arbitrary duration and different types of temporal constraints to be defined as long as the conditions under which actions interfere are well defined [34].", "startOffset": 284, "endOffset": 288}, {"referenceID": 1, "context": "The tests compare FMAP with two different state-of-the-art MAP systems: MAPR [2] and MAP-POP [37].", "startOffset": 77, "endOffset": 80}, {"referenceID": 36, "context": "The tests compare FMAP with two different state-of-the-art MAP systems: MAPR [2] and MAP-POP [37].", "startOffset": 93, "endOffset": 97}, {"referenceID": 24, "context": "We excluded Planning First [25] from the comparison because it is outperformed by MAPPOP [37].", "startOffset": 27, "endOffset": 31}, {"referenceID": 36, "context": "We excluded Planning First [25] from the comparison because it is outperformed by MAPPOP [37].", "startOffset": 89, "endOffset": 93}, {"referenceID": 1, "context": "comparative analysis between FMAP and the aforementioned planners, MAPR [2] and MAP-POP [37].", "startOffset": 72, "endOffset": 75}, {"referenceID": 36, "context": "comparative analysis between FMAP and the aforementioned planners, MAPR [2] and MAP-POP [37].", "startOffset": 88, "endOffset": 92}, {"referenceID": 26, "context": "Most multi-agent applications nowadays make use of middleware multi-agent platforms that provide them with the communication services required by the agents [27].", "startOffset": 157, "endOffset": 161}, {"referenceID": 34, "context": "The entire code of FMAP is implemented in Java and builds upon the Magentix2 platform [35].", "startOffset": 86, "endOffset": 90}, {"referenceID": 25, "context": "Magentix2 agents communicate by means of the FIPA Agent Communication Language [26].", "startOffset": 79, "endOffset": 83}, {"referenceID": 18, "context": "[19]; the satellite domain is motivated by a NASA space application [24]; the rovers domain deals with the decision of daily planning activities of Mars rovers [6]; and the openstacks domain is based on the minimum maximum simultaneous open stacks combinatorial optimization problem.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[19]; the satellite domain is motivated by a NASA space application [24]; the rovers domain deals with the decision of daily planning activities of Mars rovers [6]; and the openstacks domain is based on the minimum maximum simultaneous open stacks combinatorial optimization problem.", "startOffset": 68, "endOffset": 72}, {"referenceID": 5, "context": "[19]; the satellite domain is motivated by a NASA space application [24]; the rovers domain deals with the decision of daily planning activities of Mars rovers [6]; and the openstacks domain is based on the minimum maximum simultaneous open stacks combinatorial optimization problem.", "startOffset": 160, "endOffset": 163}, {"referenceID": 1, "context": "domains to a multi-agent context, namely the satellite, rovers, and logistics domains [2,25,37].", "startOffset": 86, "endOffset": 95}, {"referenceID": 24, "context": "domains to a multi-agent context, namely the satellite, rovers, and logistics domains [2,25,37].", "startOffset": 86, "endOffset": 95}, {"referenceID": 36, "context": "domains to a multi-agent context, namely the satellite, rovers, and logistics domains [2,25,37].", "startOffset": 86, "endOffset": 95}, {"referenceID": 23, "context": "Satellite [24].", "startOffset": 10, "endOffset": 14}, {"referenceID": 24, "context": "This domain offers a straightforward multi-agent decomposition [25,37].", "startOffset": 63, "endOffset": 70}, {"referenceID": 36, "context": "This domain offers a straightforward multi-agent decomposition [25,37].", "startOffset": 63, "endOffset": 70}, {"referenceID": 23, "context": "Rovers [24].", "startOffset": 7, "endOffset": 11}, {"referenceID": 24, "context": "offers a straightforward decomposition [25,37].", "startOffset": 39, "endOffset": 46}, {"referenceID": 36, "context": "offers a straightforward decomposition [25,37].", "startOffset": 39, "endOffset": 46}, {"referenceID": 23, "context": "Driverlog [24].", "startOffset": 10, "endOffset": 14}, {"referenceID": 23, "context": "Zenotravel [24].", "startOffset": 11, "endOffset": 15}, {"referenceID": 12, "context": "The features of these domains give rise to complex, tightly-coupled tasks that require interactions or commitments [13] among agents in order to be solved.", "startOffset": 115, "endOffset": 119}, {"referenceID": 23, "context": "Depots [24].", "startOffset": 7, "endOffset": 11}, {"referenceID": 10, "context": "Openstacks [11].", "startOffset": 11, "endOffset": 15}, {"referenceID": 1, "context": "This subsection compares the experimental results of FMAP and MAPR [2].", "startOffset": 67, "endOffset": 70}, {"referenceID": 28, "context": "MAPR is implemented in Lisp and uses LAMA [29] as the underlying planning system, without using a middleware platform for multi-agent systems.", "startOffset": 42, "endOffset": 46}, {"referenceID": 1, "context": "Of the most recent MAP systems, MAPR is one that offers excellent performance in comparison to other state-of-the-art MAP approaches [2].", "startOffset": 133, "endOffset": 136}, {"referenceID": 28, "context": "Each agent subtask is solved with the single-agent planner LAMA [29] such that the resulting subplans are progressively combined into a global solution.", "startOffset": 64, "endOffset": 68}, {"referenceID": 1, "context": "That is, MAPR is built under the assumption that each goal must be addressed by at least one of the agents in isolation [2].", "startOffset": 120, "endOffset": 123}, {"referenceID": 36, "context": "We compared FMAP with another recent MAP system, MAP-POP [37].", "startOffset": 57, "endOffset": 61}, {"referenceID": 36, "context": "solution plans [37].", "startOffset": 15, "endOffset": 19}], "year": 2015, "abstractText": "This paper proposes FMAP (Forward MultiAgent Planning), a fully-distributed multi-agent planning method that integrates planning and coordination. Although FMAP is specifically aimed at solving problems that require cooperation among agents, the flexibility of the domain-independent planning model allows FMAP to tackle multi-agent planning tasks of any type. In FMAP, agents jointly explore the plan space by building up refinement plans through a complete and flexible forward-chaining partial-order planner. The search is guided by hDTG, a novel heuristic function that is based on the concepts of Domain Transition Graph and frontier state and is optimized to evaluate plans in distributed environments. Agents in FMAP apply an advanced privacy model that allows them to adequately keep private information while communicating only the data of the refinement plans that is relevant to each of the participating agents. Experimental results show that FMAP is a general-purpose approach that efficiently solves tightly-coupled domains that have specialized agents and cooperative goals as well as loosely-coupled problems. Specifically, the empirical evaluation shows that FMAP outperforms current MAP systems at solving complex planning tasks that are adapted from the International Planning Competition benchmarks. Alejandro Torre\u00f1o Departamento de Sistemas Inform\u00e1ticos y Computaci\u00f3n Universtitat Polit\u00e8cnica de Val\u00e8ncia Camino de Vera, s/n, 46022, Valencia, Spain E-mail: atorreno@dsic.upv.es Eva Onaind\u0301\u0131a E-mail: onaindia@dsic.upv.es \u00d3scar Sapena E-mail: osapena@dsic.upv.es", "creator": "LaTeX with hyperref package"}}}