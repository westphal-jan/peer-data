{"id": "1502.04665", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Feb-2015", "title": "Optimizations for Decision Making and Planning in Description Logic Dynamic Knowledge Bases", "abstract": "skill - builder structures presenting business processes recently met a flood of attention whose they unexpectedly slowly combine performance ( i. e. data related ) with dynamical ( i. e. process architecture ) aspects leaving a seamless way. this would increasingly parallel with declarative approaches for modelling processes, having activities involved frequently burdened ; parameter - specified constrains machinery in specialized process - centric approaches, but allows to adapt their internal entities within the humans involved and the programmers must consider. in this paper, we try completely merge among automated modules by putting a framework working into assessing rich business domains through description logic - capable ontologies, and adopting a set outcome tests allows the system directly evolve by modifying such ontologies. we then incorporate model inference over hybrid simulations which represents a viable and formal description to demonstrate simulation making asset planning techniques for dl - based artifact - type valuation domains.", "histories": [["v1", "Mon, 16 Feb 2015 19:06:25 GMT  (87kb)", "http://arxiv.org/abs/1502.04665v1", "7 pages"], ["v2", "Wed, 4 Mar 2015 22:17:37 GMT  (597kb)", "http://arxiv.org/abs/1502.04665v2", "14 pages"], ["v3", "Thu, 12 Mar 2015 16:44:12 GMT  (235kb)", "http://arxiv.org/abs/1502.04665v3", "14 pages"], ["v4", "Thu, 19 Mar 2015 17:24:55 GMT  (73kb)", "http://arxiv.org/abs/1502.04665v4", "14 pages"], ["v5", "Fri, 3 Apr 2015 11:52:17 GMT  (71kb)", "http://arxiv.org/abs/1502.04665v5", "14 pages"], ["v6", "Wed, 29 Apr 2015 16:56:58 GMT  (273kb)", "http://arxiv.org/abs/1502.04665v6", "17 pages, extended version"], ["v7", "Mon, 4 May 2015 16:05:29 GMT  (260kb)", "http://arxiv.org/abs/1502.04665v7", "16 pages, extended version"]], "COMMENTS": "7 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["michele stawowy"], "accepted": false, "id": "1502.04665"}, "pdf": {"name": "1502.04665.pdf", "metadata": {"source": "CRF", "title": "Optimizations for Decision Making and Planning in Description Logic Based Dynamic Knowledge Bases", "authors": ["Michele Stawowy"], "emails": ["michele.stawowy@imtlucca.it"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 2.\n04 66\n5v 1\n[ cs\n.A I]\n1 6\nFe b\n20 15"}, {"heading": "1 Introduction", "text": "Classically, management of business processes always focused on the workflows and the actions/interactions that take part in them, an approach called process-centric. One of the most prominent operations related to business processes is planning [Ghallab et al., 2004], namely finding a sequence of operations/actions that allows to reach a desired goal. Lately, such approach has been call into question under two different aspects. First, the sole focus on the workflow leaves out the informational context in which the workflow is executed. Secondly, the traditional imperative approach to define workflows turns out to be too rigid, burdened by over-specified constrains, while in reality the actors (e.g., the humans that execute the workflow) may still be able to break them while still reaching the prefixed goal. This last point could be also applied to planning, as in general its scope is to find only the first valid plan to reach a goal, while agents might execute others (we can\u2019t consider all possible real-life conditions).\nArtifact-centric models for business processes recently raised a lot of attention [Bhattacharya et al., 2007; Cohn and Hull, 2009], as they manage to combine structural (i.e. data related) with dynamical (i.e. process related)\naspects in a seamless way, thus overcoming the limits of process-centric approach. In this context, we can see the development of the framework called Knowledge and Actions Bases [Hariri et al., 2013], the later higher formalization of it named Description Logic Based Dynamic Systems [Calvanese et al., 2013], and the Golog-based work of [Baader and Zarrie\u00df, 2013]. These works all share the same concept: handle the data-layer through a Description Logic ontology, while the process-layer, since DLs are only able to give a static representation of the domain of interest, is defined as actions that update the ontology (the so-called \u201cfunctional view of knowledge bases\u201d [Levesque, 1984]). The combination of these two elements generates a transition system, in which states are represented by DL knowledge bases. They do also share a similar objective: verification of temporal formulas over the afore-mentioned transition system. Since finding a path that lead to a goal state can be expressed as a reachability temporal formula, these environments can be used as planners.\nArtifact-centric models developed in parallel with declarative approaches for modelling processes [Pesic and Van Der Aalst, 2006; Montali et al., 2010], where activities try to adapt the internal system to the humans involved and the input they receive. Following such idea, we think that also the traditional planning function could be changed: finding only one plan might be too restrictive, especially if we consider that capturing all the real-life aspects that could influence the building of the plan is, in general, very difficult if not impossible. We treat the planner as a stage in a decision-making tool-chain: we expect the planning phase to produce all the plans that can be considered relevant to the goal, which are then fed to the following stages for further refinements. Since the relevance of a plan might not be expressible as a temporal formula or common heuristic function, it would pose some problems in the previous frameworks. From their definition, we are limited to explore the state-space in a forward manner (we could end up having to explore the full state-space) and only by using the full body of the available knowledge.\nIn this paper we propose a framework, called Dynamic Knowledge Base, aimed at describing rich business domains and, by overcoming the described limitations, be a more versatile environment for planning and decision-making. It takes inspiration from the afore-mentioned Knowledge and Actions\nBases, but differs in the definition and introduces few optimizations. The data-layer is taken care of by a DL-LiteA knowledge base, while a set of actions allows the system to evolve by adding/removing assertions and introducing new instances to the system. We then introduce the following optimizations: action rewriting, that allows to ditch completely the TBox in the building of the transition system (while keeping the consistency w.r.t. it), and abstraction, that gives the possibility to work with partial abstract knowledge. The described framework constitutes the basis of an on-going work aimed at exploring new planning techniques in DL-based artifact-centric business models, where large amount of structured data poses a difficulty in handling resources efficiently and in avoiding inconsistent behaviours.\nOrganization: in Sec. 2 we introduce the formalization of Dynamic Knowledge Bases . In Sec. 3 we illustrate a business example to better explain our framework. In Sec. 4 we describe the optimizations we introduce, namely action rewriting (Sec. 4.1), and abstraction (Sec. 4.2). Finally, in Sec. 4.3 we study the properties of the resulting abstract framework w.r.t. the original one."}, {"heading": "2 Dynamic Knowledge Base", "text": "Dynamic Knowledge Bases (or DKBs) are, briefly, dynamic systems (more precisely labelled transition systems) in which states are constituted by DL-Lite knowledge bases composed of a TBox and an ABox, and a set of actions that makes the system evolve by modifying the ABox: it follows that the TBox is fixed, while the ABox changes as the system evolves (thus an ABox Ai is sufficient to identify the state i of the system). More specifically, we adopt DL-LiteA ontologies [Calvanese et al., 2006], and restrict the possible TBox axioms by not allowing functional roles, nor attributes. The ABox is a finite set of assertions, i.e., atomic formulas of the form C(i) and R(i, i\u2032), where C is an atomic concept name, R is an atomic role name, and i, i\u2032 are individual constants defined over a countably infinite (object) universe \u2206 of individuals. The set ADOM(A) identifies the constants in A (it follows that ADOM(A) \u2286 \u2206). AT denotes the set of all possible consistent ABoxes w.r.t. T that can be constructed using concept and role names in T , and individuals in \u2206. The semantic adopted is the standard one based on first-order interpretations and on the notion of (first-order) model: a TBox is satisfiable if admits at least one model, an ABox A is consistent w.r.t. a TBox T if (T,A) is satisfiable, and (T,A) logically implies an ABox assertion \u03b1 (denoted (T,A) |= \u03b1) if every model of (T,A) is also a model of \u03b1.\nDefinition 2.1. A DKB is a tuple D = (T,A0,\u0393), where (T,A0) is a DL-LiteA KB, while \u0393 is a finite set of actions.\nAn action from the set \u0393 is of the form a: q \u222a N E, where a is the action name, q is a query called action guard, N is a set of variables which are used in an instance creation function, and E are the action effects. The guard q is a standard conjunctive query of the type q = {\u2212\u2192x |conj(\u2212\u2192x )}, where conj(\u2212\u2192x ) is a conjunction of atoms with only free variables \u2212\u2192x , no existential ones and no individuals. Atoms of q uses concepts and roles found in T . The set N simply contains variables which do not appear in\nq (Vars(q) \u2229 N = \u2205), and are fed to an assignment function m when the action is executed. The set E is a set of atomic effects (i.e., atomic non-grounded ABox assertions) which use variables that are in Vars(q) \u222a N , and is divided in two subsets: E\u2212, the set of negative effects, and E+, the set of positive effects. All atoms of E\u2212 must occur among the atoms of q+ (E\u2212 = {e\u2212 | e\u2212 \u2208 q+}), while the atoms of E+ must be different from them (E+ = {e+ | e+ 6\u2208 q+}). We also assume, for consistency reasons, that (T,E+) is satisfiable under the canonical interpretation [Glimm et al., 2011].\nThe dynamics of a DKB D is defined by the transition system \u03a5D it generates.\nDefinition 2.2. The transition system \u03a5D is defined as a tuple \u03a5D = (\u2206, T,\u03a3, A0,\u21d2), where: (i) \u2206 is the universe of individual constants; (ii) T is a TBox; (iii) \u03a3 is a set of states, namely ABoxes from the set AT (\u03a3 \u2286 AT ); (iv) A0 is the initial state; (v) \u21d2\u2286 \u03a3 \u00d7 L \u00d7 \u03a3 is a labelled transition relation between states, where L = \u0393 \u00d7 \u0398 is the set of labels containing one pair (a, \u03d1) for every action a \u2208 \u0393 and a corresponding homomorphism \u03d1 \u2208 \u0398.\nThe informal semantic of a transition is that, starting from a state A and selected an action a, we: i) extract the certain answers ANS(q, T,A) of the guard q from the current state A; ii) pick randomly one of the homomorphisms \u03d1a from the certain answers of q in (T,A) (\u03d1a \u2208 ANS(q, T,A)); iii) apply the assignment function m : N \u2192 \u2206 to the variables of the set N and complete \u03d1a; iv) use \u03d1a to instantiate the effects E (a\u03d1a is called an instantiation of a) and calculate A\u2032 by applying the instantiated effects to A. The assignment function m assigns to each variable of N an individual from \u2206 which does not appear already in A (m(N,A) : N \u2192 (\u2206 \\ ADOM(A))).\nThe sets \u03a3 and \u21d2 are thus mutually defined using induction (starting from A0) as the smallest sets satisfying the following property: for every A \u2208 \u03a3 and action a \u2208 \u0393, if exists an action instantiation a\u03d1a s.t. A\u2032 = A\\sub(E\u2212)\u03d1a\u222aE+\u03d1a, and A\u2032 \u2208 AT , then A\u2032 \u2208 \u03a3 and A l \u21d2 A\u2032, with l = (a, \u03d1a).\nNotice that we apply first the negative effects E\u2212, then the positive effects E+. sub(E\u2212) represents all the assertions that are subsumed by the assertions of E\u2212. The reason we remove also subsumed assertions is due to practicality, as described in Example 2.1.\nExample 2.1. Consider the following elements: a TBox T = {Assembler \u2291 Worker}, an action to fire a worker (fire: Worker(x) {Worker(x)}\u2212), and an ABox A = {Assembler(a)}. If we apply fire to A (using \u03d1 = {x 7\u2192 cos a}, a valid answer in ANS(q, T,A)), we see that, if we remove only E\u2212\u03d1 from A, we do not change the ABox, as Worker(a) belongs to the inferred terms. This is not what we would expect in a real-life scenario.\nGiven a negative effect e\u2212, an assertion \u03b1 is in sub(E\u2212) if: \u2022 e\u2212 = A1(x), \u03b1 = A2(x), and T |= A2 \u2291 A1; \u2022 e\u2212 = A(x), \u03b1 = R(x, ) 1 , and T |= \u2203R \u2291 A; \u2022 e\u2212 = A(x), \u03b1 = R( , x), and T |= \u2203R\u2212 \u2291 A; \u2022 e\u2212 = R1(x, y), \u03b1 = R2(x, y), and T |= R2 \u2291 R1;\n1 The symbol denotes that it can be substituted with any instance in ADOM(A)\n\u2022 e\u2212 = R(x, y), \u03b1 = A(x), and T |= A \u2291 \u2203R; \u2022 e\u2212 = R(y, x), \u03b1 = A(x), and T |= A \u2291 \u2203R\u2212; The generated transition system \u03a5D is possibly infinite, as we have the possibility to introduce new constants. We call a path \u03c0 a (possibly infinite) sequence of transitions over \u03a5D that start from A0 (\u03c0 = A0 a1\u03d11\u21d2 ... an\u03d1n\u21d2 An).\nA DKB is a concrete instantiation of the abstract framework Description Logic Based Dynamic System [Calvanese et al., 2013], which is a tuple S = (TS , AS ,\u0393S) where (TS , AS) is a DL KB (note that the KB is not restricted to use DL-Lite), and \u0393S is a set of actions of the type a = (\u03c0, \u03c4). Without explaining the mechanisms that define a Description Logic Based Dynamic System , we provide the translations from it to our DKB. The KB (TS , AS) corresponds to the KB (T,A0) used in the DKB. To match the definition of actions \u0393S , we reformulate the actions in \u0393 as a = (\u03c0a, \u03c4a), where: \u2022 \u03c0a executes the guard q over (T,A), obtaining a partial\naction instantiation \u03d1a, partially instantiating the effects, and returning the variables of the set N ; \u2022 \u03c4a(A,m) completes the instantiation of the effects by using the assignment function m, and returns the ABox A\u2032\nobtained by applying the effects to A. If A\u2032 is not consistent w.r.t. T , then \u03c4a(A,m) is undefined. Our framework is also closely related to the framework Knowledge and Action Bases (KAB) [Hariri et al., 2013]. , although with some minor differences in the specific DL-Lite flavour used (our is more strict) and in the dynamic aspect of the system. A KAB action \u03b3KAB is a finite set of effects ei (\u03b3KAB = {e1, ..., en}), with each effect defined as ei = [q + i ] \u222a Q \u2212 i A \u2032 i, where q\n+ is an UCQ, Q\u2212 an ECQ used to refine the result set [q+] (i.e. the result set obtained by performing q+ over the KB (T,Ai)), and A\u2032i a complete ABox. Our actions are not sets of effects, but resemble the definition of a single KAB effect, thus this difference can be easily overcome by defining a DKB action for each effect in a KAB action. In our framework the guard is simply a CQ (we do not provide an ECQ to refine the result set of the guard), and our effects states what to add/remove from the starting ABox. Given the close relationship to KABs, we also inherit the capability of verifying \u00b5LA temporal formulas and the complexity results (both verification and synthesis can be done in EXPTIME)."}, {"heading": "3 Example", "text": "We now detail an example based on a manufacturing company that produces electronic goods and, as in a typical situation, has different product assembly lines and a warehouse.\nThrough the TBox T we model the structure of the company, which represented graphically Figure 1: solid arrows corresponds to the hierarchy of concepts, while the dashed lines to the disjointness of concepts. It is a fairly simple TBox in which we represent different type of workers (the concept Worker and its subconcepts Assembler and Warehouse), the products being assembled by the company (Cellphone and Tablet concepts) and some product attributes (like Packed to denote a product being ready to be shipped, and Stocked if it has being placed in the warehouse). The intial ABox A0 contains the following assertions:\nA0 = { Assembler(e1), Warehouse(e2), Parts(p1), Parts(p2), Cellphone(c1), Stocked(c1) }\nWe now define the actions available in the set \u0393:\npack product : Worker(x) \u2227 Product(y) {Packed(y)}+\ncreate tablet : (Assembler(x) \u2227 Parts(y)) \u222a {z}\n{Parts(y)}\u2212 \u222a {Tablet(z),Scrap(y)}+\nunstock product : Warehouse(x) \u2227 Stocked(y) {Stocked(y)}\u2212\nclean : Worker(x) \u2227 Scrap(y) {Scrap(y)}\u2212\nWe have thus defined the elements that compose the DKB D = \u3008T,A0,\u0393\u3009 (as detailed in Sec. 2). We show in Figure 2 (we omit the homomorphisms for clarity of the image) a partial development of the transition system \u03a5D with a couple of possible transitions and their properties. Starting from A0: \u2022 we can perform pack product with \u03d1 = {x 7\u2192 e1, y 7\u2192 c1}, but the resulting state A\u2032 = A0 \u222a {Packed(c1)} is inconsistent, as c1 appears in the disjoint concepts Packed and Stocked. Such transition is therefore not valid, and does not appear in \u03a5D; \u2022 we can\u2019t perform clean, as the query Worker(x)\u2227Scrap(y) has no certain answers in A0; \u2022 we can perform create tablet with \u03d1 = {x 7\u2192 e1, y 7\u2192 p1}, and the resulting state A1 is consistent w.r.t T , making\nA0 create tablet\u03d1\n\u21d2 A1 a valid transition. Notice that we also introduce a new individual t1 which was not present in A0.\nA1 = { Assembler(e1), Warehouse(e2),Parts(p2), Cellphone(c1), Stocked(c1), Tablet(t1), Scrap(p1) }"}, {"heading": "4 Optimizations", "text": "As stated in the introduction, our aim is to use DKBs for planning and decision making purposes. Given the specifications of a DKB, few details arise that pose a problem to reach our objective. First of all, we only consider the totality of the available knowledge at a given time.\nWhile such condition is necessary to asses the consistency of the overall system, it bounds us to work with details that might not be of interests immediately. In decision making [Gigerenzer and Gaissmaier, 2011], \u201can heuristic is a strategy that ignores part of the information, with the goal of making decisions more quickly, frugally, and/or accurately than more complex methods\u201d. To allow our framework to be used for such strategies, it must be able to work with partial information, so that users can focus on a chosen subset of knowledge. This goal is vital when we deal with systems described by complex ontologies and are composed of millions (if not more) instances.\nTo fulfil these objectives, we introduces two optimizations to our framework, namely action rewriting and abstraction of the transition system. The first is aimed at simplifying the building of the transition system and removing the dependency from the TBox T , while guaranteeing that all the states are still consistent w.r.t. it. The second, instead, allows to build a transition system which uses partial knowledge and allows us to work in an abstract environment which is not tied to the instances in the ABox."}, {"heading": "4.1 Action Rewriting", "text": "In the actual specification of a DKB (and also in the framework Knowledge and Action Bases [Hariri et al., 2013]), actions could lead to inconsistent states w.r.t. the TBox T . We first introduce three theorems related to DL-LiteA KBs.\nTheorem 4.1. Given a DL-LiteA KB (T,A) and a partition A = \u22c3 i Ai, we have that chase(T,A) = \u22c3 i chase(T,Ai).\nProof. This property can be easily derived from the definition of chase of a DL-LiteA KB [Calvanese et al., 2009], which is used to generate the set of inferred terms.\nTheorem 4.2. Given a DL-LiteA KB (T,A) every ABoxA\u2032 \u2282 A is consistent w.r.t T .\nProof. If (T,A) is satisfiable, from the definition of chase and NI-closure of T (denoted cln(T )) of a DL-LiteA KB [Calvanese et al., 2009], it follows that, for every assertion \u03b1 in chase(T,A) we have cln(T ) |= \u03b1.\nAssume that it exists A\u2032 \u2286 A such that (T,A\u2032) is not satisfiable, thus it exists at least one assertion\u03b1\u2032 in chase(T,A\u2032) \u2286 which is not implied by cln(T ) (cln(T ) 6|= \u03b1\u2032). From the definition of chase, although, it\u2019s easy to see that \u03b1\u2032 must be also in chase(T,A), which creates the absurd situation where \u03b1\u2032 is both implied and not implied by cln(T ).\nDefinition 4.1. Given a DL-LiteA TBox T , we call NI-closure of T w.r.t. an assertion \u03b1 (with \u03b1 an assertion of the type A(i) or P(i1, i2)), denoted by cln(T, \u03b1), the TBox defined as the NI-closure of T [Calvanese et al., 2009] where all the assertions in which A (resp. P, \u2203P, or \u2203P\u2212) does not appear on any side are removed.\nTheorem 4.3. Given a satisfiable DL-LiteA KB K = (T,A) and an assertion \u03b1 6\u2208 A, we have that K\u2032 = (T,A \u222a {\u03b1}) is satisfiable if cln(T, \u03b1) |= \u03b1.\nProof. From [Calvanese et al., 2009], we have that the canonical interpretation can(K\u2032) is a model of K\u2032 if and only if DB(A \u222a {\u03b1}) is a model of (cln(T ), A \u222a {\u03b1}). Since K = (T,A) is already satisfiable, it means that every membership assertion in A already respects the axioms in T , and thus in cln(T ). If \u03b1 doesn\u2019t respect cln(T ), then can(K\u2032) can\u2019t be a model of K\u2032. This would mean that \u03b1 breaks an axiom inside cln(T ), which has to contain the concept (or role) used in \u03b1, thus this axiom must be also in cln(T, \u03b1) by definition. It follows that it is sufficient to test if cln(T, \u03b1) |= \u03b1 to know if K\u2032 = (T,A \u222a {\u03b1}) is satisfiable or not.\nDefinition 4.2. Given an action a \u2208 \u0393, we define its rewriting as arew = q \u222aN \u222aB E, with B = \u2228 i bi an union of conjunctive queries (UCQ) (where bi are single non-grounded assertions), called blocking query.\nB is built in the following manner. For each effect e+ \u2208 E+: 1. calculate cln(T, e+), and, for every NI-assertions in it,\nbuild the assertion A(x) (resp., R(x1, x2)), where: A (resp., role R) is the class (res., role) that is disjoint with the class (resp., role) of e+, x (resp., x1, x2) is the variable appearing in e+. We do not consider the cases \u2203R or \u2203R\u2212; 2. remove the assertions that use variables from the set N , as they would require instances that do not exists in A; 3. remove the assertions that appear in sub(E\u2212), as they would be removed in A\u2032; 4. add the remaining assertions to B by or-connecting them.\nTheorem 4.4. Given an action a \u2208 \u0393 and its rewrite arew, for every ABox A such that \u03d1a \u2208 ANS(q, T,A) and (\u2205, A) 6|= B\u03d1a, we can create the transition A a rew\u03d1a\u21d2 A\u2032 and be sure that A\u2032 is consistent w.r.t. T .\nProof. From the definition of \u21d2, we have that A\u2032 is equal to A \\ sub(E\u2212)\u03d1a \u222aE+\u03d1a. Since (T,A) is satisfiable, then for Theorem 4.2 also (T,A \\ sub(E\u2212)\u03d1a) is satisfiable.\nAdding E+\u03d1a to A\\sub(E\u2212)\u03d1a maintains the consistency thanks to Theorem 4.3 and the way B is built, since we test the presence of possible assertions that could break any NIassertions in cln(T,E+) (excluding the one that are either removed or related to new instances).\nExample 4.1. Given the action create tablet from Sec. 3 with E+ = {Tablet(z), Scrap(y)}+, cln(T,E+) equals to:\ncln(T,E+) = {Tablet \u2291 \u00acCellphone,Tablet \u2291 \u00acWorker,\n..., Scrap \u2291 \u00acProduct,Scrap \u2291 \u00acCellphone, ...}\nFrom it we derive the UCQ B: B =Product(y) \u2228 Tablet(y) \u2228 Cellphone(y)\n\u2228 Packed(y) \u2228 Stocked(y)\nNotice that there are no assertions related to Tablet(z) (i.e., Cellphone(z)), since z \u2208 N .\nThanks to the rewriting of the actions, we build the transition system \u03a5D without having to check the consistency of each ABox, and thus skipping the use of T for such task. Using the query reformulation algorithm [Calvanese et al., 2009], the TBox T is not necessary to find the possible action instantiations (query answering), thus making T superfluous for the building of \u03a5D, but still being consistent w.r.t. it."}, {"heading": "4.2 Abstract Transition System", "text": "We now build an abstraction of the transition system \u03a5D, which takes place in two points: i) we no longer use ABoxes to define states, but conjunctive queries; ii) we define a looser transition function to build the transition system.\nWe first characterize a DL-LiteA abstract KB, which is a tuple (T, A\u0302) constituted by a TBox T and an abstract ABox A\u0302. An abstract ABox A\u0302 is a finite set of non-ground facts, i.e., atomic formulas of the form C(x) and R(x, x\u2032), where C is a concept name, R is a role name, and x, x\u2032 are variables taken from a countably infinite (object) universe \u2206\u0302 of variables (note that here we allow C and R to be non atomic, as it should be instead in a normal DL-LiteA ABox). Given A\u0302, we obtain the relative conjunctive query Q(A\u0302) by simply and-connecting all the assertions:\nQ(A\u0302) = \u2227\ni \u03b1i | \u03b1i \u2208 A\u0302\nWith a little abuse of notation, we identify with A\u0302 both the abstract ABox and the corresponding query, depending on the context of use. The set Vars(A\u0302) identifies the variables in A\u0302 (it follows that Vars(A\u0302) \u2286 \u2206\u0302). A\u0302T denotes the set of all possible consistent abstract ABoxes that can be constructed using concept and role names in T , and variables in \u2206\u0302. The semantic adopted for abstract ABoxes is based on the canonical interpretation [Glimm et al., 2011]: an abstract ABox A\u0302 is consistent w.r.t. a TBox T if it exists a canonical interpretation I\nA\u0302 , such that I A\u0302 |= (T, A\u0302).\nDefinition 4.3. An abstract transition system \u03a5\u0302D is a tuple \u03a5\u0302D = (\u2206\u0302, T, \u03a3\u0302, A\u03020, ), where: (i) \u2206\u0302 is the universe of variables; (ii) T is a TBox; (iii) \u03a3\u0302 is a set of abstract states, namely abstract ABoxes from the set A\u0302T (\u03a3\u0302 \u2286 A\u0302T ); (iv) A\u03020 is a set of initial abstract states obtained from the intial ABox A0; (v) \u2286 \u03a3\u0302 \u00d7 L\u0302 \u00d7 \u03a3\u0302 is a labelled transition relation between states, where L\u0302 = \u0393\u00d7\u03a6 is the set of labels containing one pair (a, \u03c6) for every action a \u2208 \u0393 and a corresponding homomorphism \u03c6 \u2208 \u03a6.\nThe set A\u03020 is obtained in the following way: 1. define an homomorphism \u03d1\u2212A0 that assigns each individ-\nual of ADOM(A0) to a distinct variable from \u2206\u0302 (\u03d1 \u2212 A0 : ADOM(A0) 7\u2192 \u2206\u0302 s.t. (i = i\u2032 \u21d2 x = x\u2032) \u2227 (i 6= i\u2032 \u21d2 x 6= x\u2032) , \u2200i 7\u2192 x, i\u2032 7\u2192 x\u2032);\n2. obtain the abstract state A\u0302max = chase(A0)\u03d1 \u2212 A0 . A\u0302max is obviously a valid query, as \u03d1A0 is an answer; 3. A\u03020 = P\u22651(A\u0302max), which is a set of queries (not all the possible ones) that do find an answer in A0.\nExample 4.2. Considering the initial ABox A0 detailed in Sec. 3 , we can obtain the following elements related to the definition of A\u03020: \u2022 \u03d1\u2212A0 = {e1 7\u2192 x, e2 7\u2192 y, p1 7\u2192 z, p2 7\u2192 w, c1 7\u2192 v}; \u2022 (A0)inf = {Worker(e1),Worker(e2),Product(c1)}; \u2022 A\u0302max = {Assembler(x), Warehouse(y), Parts(z), Parts(w),\nCellphone(v), Stocked(v), Worker(x), Worker(y), Product(v)};\n\u2022 A\u03020 = {A\u03020a, A\u03020b, ...} with A\u03020a = {Assembler(x), Parts(z)}, and A\u03020b = {Assembler(x), Worker(x), Parts(z)};\nThe informal semantic of a transition is the same of \u21d2 (we substitute A and \u2206 with, respectively, A\u0302 and \u2206\u0302), with the only difference that we look for the certain answers of ANS(q, \u2205, A\u0302) (we do not consider T ). We can also apply the rewriting of actions detailed in Sec. 4.1, and get the same properties as for normal ABoxes. The sets \u03a3\u0302 and are defined using a more loose definition w.r.t. to \u03a3 and \u21d2. Given a A\u0302 \u2208 \u03a3\u0302, an action arew (a \u2208 \u0393), and a valid action instantiation \u03c6a (so that (\u2205, A\u0302) 6|= B\u03c6a), we express A\u0302\u2032 as:\nA\u0302\u2032 \u2286 A\u0302 \\ sub(E\u2212)\u03c6a \u222aE +\nall\u03c6a\nwhere E+all = chase(T,E +). If such A\u0302\u2032, then A\u0302\u2032 \u2208 A\u0302T (thanks to Theorem 4.4) and A\u0302\u2032 \u2208 \u03a3\u0302 and A\u0302 l\u0302 A\u0302\u2032, with\nl\u0302 = (a, \u03c6a). The generated transition system \u03a5\u0302D is, like \u03a5D, a possibly infinite transition system, since we have the possibility to introduce new variables. We call an abstract path \u03c0\u0302 a (possibly infinite) sequence of transitions over \u03a5\u0302D (\u03c0\u0302 \u2208 \u03a5\u0302D) that starts from A\u03020 \u2208 A\u03020 (A\u03020 a1\u03c61 \u21d2 ... an\u03c6n \u21d2 A\u0302n).\nExample 4.3. Considering the initial abstract state A\u03020b = {Assembler(x), Worker(x), Parts(z)} (detailed in Example 4.2), we can execute the action create tablet (with \u03c6 = {x 7\u2192 x, y 7\u2192 z, z 7\u2192 w}) and get A\u03020b \\ sub(E\u2212)\u03c6 \u222a E+all\u03c6 = {Assembler(x), Worker(x), Scrap(z), Tablet(w), Product(w)} (sub(E\u2212) = {Parts(y)}). From it, all the possible subsets are valid ending states A\u2032 of the transition:\nA\u03020b create tablet\u03c6 A\u2032\nAs for the construction of \u03a5D, also the abstract transition system \u03a5\u0302D can be built without the use of T ."}, {"heading": "4.3 Abstract Transition System Properties", "text": "Having said that the abstract transition system \u03a5\u0302D is an abstraction of \u03a5D , we look for the exact relation between the two. We define first when an abstract transition A\u0302 l\u0302 A\u0302\u2032 is a proper abstraction of a transition A l \u21d2 A\u2032.\nDefinition 4.4. An abstract transition A\u0302 l\u0302 A\u0302\u2032 is a proper abstraction of a transition A l \u21d2 A\u2032 if:\n\u2022 both transitions are caused by the same action a; \u2022 A\u0302 (A\u0302\u2032) returns some results as a query against A (A\u2032), thus \u2203\u03d1A | \u03d1A \u2208 ANS(A\u0302, T, A) (\u2203\u03d1A\u2032 | \u03d1A\u2032 \u2208 ANS(A\u0302\u2032, T, A\u2032)); \u2022 a variable is linked to the same individual through-out all the transition (\u2200x 7\u2192 i, x\u2032 7\u2192 i\u2032 \u2208 (\u03d1A \u222a \u03d1A\u2032 \u222a \u03c6\u2212a \u03d1a) s.t. x = x\u2032 \u21d2 i = i\u2032).\nIf A\u0302 l\u0302 A\u0302\u2032 is a proper abstraction of a transition A l \u21d2 A\u2032,\nthen A l \u21d2 A\u2032 is a proper concretion of A\u0302 l\u0302 A\u0302\u2032. The definition can be extended to paths: an abstract path \u03c0\u0302 (resp., a path \u03c0) is an abstraction (resp., a concretion) of a path \u03c0 (resp., an abstract path \u03c0\u0302) if each transition in \u03c0\u0302 (resp., \u03c0) is a proper abstraction (resp., concretion) of the corresponding transition in \u03c0 (resp., \u03c0\u0302).\nFrom the last point of Definition 4.4, we can derive the fact that \u03c6\u2212\na \u03d1a \u2286 \u03d1A \u222a \u03d1A\u2032 , as the instances (resp., variables) in-\nvolved in the action must be present either in A (resp., A\u0302), or in A\u2032 (resp., A\u0302\u2032). The constrain about variables-individuals is needed in order to have a significant representation of the concrete transition by the abstract one. If we do not force it, we could end up with a non-logical representation, as demonstrated in Example 4.4.\nExample 4.4. Consider the transition A0 create tablet\u03d1\n\u21d2 A1 with \u03d1 = {x 7\u2192 e1, y 7\u2192 p1} (from Sec. 3), and the ab-\nstract transaction A\u03020b create tablet\u03c6 A\u03021 with A\u03021 = {Scrap(z)}\n(A\u03020b is detailed in Example 4.2). We could set \u03d1A0 = {x 7\u2192 e1, z 7\u2192 p2}, \u03d1A1 = {z 7\u2192 p1}, but we would have a meaningless abstraction, as the variable z would point to different individuals throughout the transition.\nTheorem 4.5. An abstract transition system \u03a5\u0302D is a simulation of the transition system \u03a5D.\nProof. Let\u2019s consider a path \u03c0 = A0 a1\u03d1a1\u21d2 ... an\u03d1an\u21d2 An in \u03a5D. We try to build an abstract path \u03c0\u0302 = A\u03020 a1\u03c6a1 ... aN\u03c6aN A\u0302N , so that: \u2022 each state A\u0302i of \u03c0\u0302 is equal to (Ai)all\u03d1\n\u2212 Ai , with Ai the corresponding state in \u03c0, and (Ai)all = chase(Ai); \u2022 each abstract transition A\u0302i al\u03c6al A\u0302l is a proper abstraction\nof the corresponding transition Ai al\u03d1al\u21d2 Al.\nWe proceed inductively starting from A0, and seeing that, from the definition of A\u03020 we can define A\u03020 = (A0)all\u03d1\n\u2212 A0\n(with \u03d1A0 the homomorphism from A\u03020 to A0). We can build the homomorphisms \u03d1a1 and \u03c6a1 by using \u03d1A0 as a guide, and thus respecting the constrain about variables from Definition 4.4 (we just have to complete them with the variables from N of the action a1). The last step is to see if, after the transition, we can have A\u03021 as (A1)all\u03d1\n\u2212 A1 . Given the definition of an transition in \u03a5D, we know that A1 = A0 \\ sub(E\u2212)\u03d1a1 \u222aE\n+\u03d1a1 , thus we can, using Theorem 4.1, rewrite (A1)all ((A1)all = chase(T,A1)) as:\n(A1)all = (A0 \\ sub(E \u2212)\u03d1a1 \u222a E +\u03d1a1)all\n= (A0 \\ sub(E \u2212)\u03d1a1)all \u222a (E +)all\u03d1a1\nWe can also define \u03d1A1 by combining \u03d1A0 and \u03d1a1 , since ADOM(A1) \u2286 ADOM(A0) \u222a N\u03d1a1 (where N\u03d1a1 are the instances introduced by a). Given the definition of a transition in \u03a5\u0302D, we know that A\u03021 \u2286 A\u03020 \\ sub(E\u2212)\u03c6a1 \u222aE +\nall\u03c6a1 , thus we can consider the extreme case:\nA\u03021\u2212max = A\u03020 \\ sub(E \u2212)\u03c6a1 \u222a E + all\u03c6a1\n= (A0)all\u03d1 \u2212 A0 \\ sub(E\u2212)\u03c6a1 \u222a E + all\u03c6a1\nAs we already defined \u03d1A0 , \u03d1a1 and \u03c6a1 , we can apply them to (A0)all\u03d1\n\u2212 A0 \\ sub(E\u2212)\u03c6a1 , thus transforming the variables in instances and get (A0)all \\ sub(E\u2212)\u03d1a1 \u222a E +\nall\u03d1a1 . We see now that the definition of A1 and its abstract counterpart A\u03021\u2212max are very similar, the only difference given by the set (A0\\sub(E\u2212)\u03d1a1)all and (A0)all\\sub(E \u2212)\u03d1a1 , which can be\nnot equal (more precisely, (A0 \\ sub(E\u2212)\u03d1a1)all \u2286 (A0)all \\ sub(E\u2212)\u03d1a1 ). Since A\u03021 \u2286 A\u03021\u2212max, we can select the proper subset where A\u03021 = (A0\u03d1\n\u2212 A0 \\ sub(E\u2212)\u03c6a1)all \u222aE + all\u03c6a1 .\nWe thus demonstrated that the abstract transition function is capable of reproducing the transition function \u21d2, meaning that every path in \u03a5D has at least one proper abstraction in \u03a5\u0302D. An abstract path \u03c0\u0302, on the other side, doesn\u2019t always have a proper concretion in \u03a5D: this is a clear (and intended) consequence of working with partial knowledge. To know if it exists a path \u03c0 that is a concretion of \u03c0\u0302, we have to consider all the available knowledge, which means we have to take into account the whole initial knowledge of the state A0, and the application of all of the effects of each action. We build \u03c0 starting from A0 and using the transition function \u21d2; \u03c0\u0302 acts as a guide for the actions to perform, and at each step we see if the proposed action respects its blocking query or not."}, {"heading": "5 Conclusions", "text": "In this paper we formalize a framework, based on description logic, aimed at modelling the dynamics of business processes. Such framework, called Dynamic Knowledge Bases, is represented by a transition system where states are defined by a DL-Lite knowledge base, and where a set of actions allow the system to evolve by adding or removing assertions, along with the possibility to introduce new instances. The expressive power and reasoning services of description logics are very helpful to describe and manage the domain knowledge, but constitute a difficult environment to deal with when it comes to the processes. To tackle this problem, we introduce two optimizations, namely action rewriting and the abstraction of the transition system related to a Dynamic Knowledge Base: these optimizations give us a framework where we can work with partial knowledge and where the TBox is not needed, still guaranteeing that the resulting system is consistent with it. Our framework represents a formal base which can be used to solve planning and decision making problems, a relevant aspect of rich business domains.\nWe are currently working to further expand this framework in various directions. Under the theoretical side, we intend to expose more properties of the abstract transition system, in particular the connections with the concrete one (e.g., being able to asses if an abstract path \u03c0\u0302 has a concretion \u03c0 without explicitly calculating it). Another progression is the expansion of the expressive power of the framework, namely by allowing the use of full DL-LiteA knowledge bases, along with more powerful actions, e.g., allowing the use of ECQs to refine the results of the guard. Under the practical side, a backward planning algorithm is already under development, which takes advantage of the abstract transition system and the possibility to work with partial knowledge to return all plans of interest w.r.t. a goal.\nAlthough further investigation is surely needed, Dynamic Knowledge Bases are a promising framework that can be usefully employed to tackle the problem of planning and decision making in artifact-centric business domains."}], "references": [{"title": "Verification of Golog programs over description logic actions", "author": ["Baader", "Zarrie\u00df", "2013] Franz Baader", "Benjamin Zarrie\u00df"], "venue": "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),", "citeRegEx": "Baader et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2013}, {"title": "Business Process Management", "author": ["Kamal Bhattacharya", "Cagdas Gerede", "Richard Hull. Towards formal analysis of artifact-centric business process models"], "venue": "pages 288\u2013304,", "citeRegEx": "Bhattacharya et al.. 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "Linking data to ontologies: The description logic DL-LiteA", "author": ["Diego Calvanese", "Giuseppe De Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Antonella Poggi", "Riccardo Rosati"], "venue": "CEUR Workshop Proceedings, 216,", "citeRegEx": "Calvanese et al.. 2006", "shortCiteRegEx": null, "year": 2006}, {"title": "Ontologies and Databases: the DL-Lite Approach", "author": ["Diego Calvanese", "Giuseppe Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Antonella Poggi", "Mariano Rodriguez-Muro", "Riccardo Rosati"], "venue": "5689:255\u2013356,", "citeRegEx": "Calvanese et al.. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "volume 7994 of Lecture Notes in Computer Science", "author": ["Diego Calvanese", "Giuseppe De Giacomo", "Marco Montali", "Fabio Patrizi. Verification", "Synthesis in Description Logic Based Dynamic Systems"], "venue": "Springer Berlin Heidelberg, Berlin, Heidelberg,", "citeRegEx": "Calvanese et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Business artifacts: A data-centric approach to modeling business operations and processes", "author": ["David Cohn", "Richard Hull"], "venue": "IEEE Data Eng. Bull, 32(3):3\u20139,", "citeRegEx": "Cohn and Hull. 2009", "shortCiteRegEx": null, "year": 2009}, {"title": "Automated planning - theory and practice", "author": ["Malik Ghallab", "Dana S. Nau", "Paolo Traverso"], "venue": "Elsevier,", "citeRegEx": "Ghallab et al.. 2004", "shortCiteRegEx": null, "year": 2004}, {"title": "Annual review of psychology", "author": ["Gerd Gigerenzer", "Wolfgang Gaissmaier. Heuristic decision making"], "venue": "62:451\u2013482,", "citeRegEx": "Gigerenzer and Gaissmaier. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "Conjunctive Query Answering for the Description Logic SHIQ", "author": ["Birte Glimm", "Ian Horrocks", "Carsten Lutz", "Ulrike Sattler"], "venue": "volume 31.", "citeRegEx": "Glimm et al.. 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "JAIR)", "author": ["Babak Bagheri Hariri", "Diego Calvanese", "Marco Montali", "Giuseppe De Giacomo", "Riccardo De Masellis", "Paolo Felli. Description Logic Knowledge", "Action Bases. J. Artif. Intell. Res"], "venue": "46:651\u2013686,", "citeRegEx": "Hariri et al.. 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "Artif", "author": ["Hector J. Levesque. Foundations of a Functional Approach to Knowledge Representation"], "venue": "Intell., 23(2):155\u2013212,", "citeRegEx": "Levesque. 1984", "shortCiteRegEx": null, "year": 1984}, {"title": "ACM Transactions on the Web", "author": ["Marco Montali", "Maja Pesic", "Wil M.P. Van Der Aalst", "Federico Chesani", "Paola Mello", "Sergio Storari. Declarative specification", "verification of service choreographiess"], "venue": "4(May):1\u201362,", "citeRegEx": "Montali et al.. 2010", "shortCiteRegEx": null, "year": 2010}, {"title": "Van Der Aalst", "author": ["Maja Pesic", "Wil M. P"], "venue": "A Declarative Approach for Flexible Business Processes Management.", "citeRegEx": "Pesic and Van Der Aalst. 2006", "shortCiteRegEx": null, "year": 2006}], "referenceMentions": [{"referenceID": 6, "context": "One of the most prominent operations related to business processes is planning [Ghallab et al., 2004], namely finding a sequence of operations/actions that allows to reach a desired goal.", "startOffset": 79, "endOffset": 101}, {"referenceID": 1, "context": "Artifact-centric models for business processes recently raised a lot of attention [Bhattacharya et al., 2007; Cohn and Hull, 2009], as they manage to combine structural (i.", "startOffset": 82, "endOffset": 130}, {"referenceID": 5, "context": "Artifact-centric models for business processes recently raised a lot of attention [Bhattacharya et al., 2007; Cohn and Hull, 2009], as they manage to combine structural (i.", "startOffset": 82, "endOffset": 130}, {"referenceID": 9, "context": "In this context, we can see the development of the framework called Knowledge and Actions Bases [Hariri et al., 2013], the later higher formalization of it named Description Logic Based Dynamic Systems [Calvanese et al.", "startOffset": 96, "endOffset": 117}, {"referenceID": 4, "context": ", 2013], the later higher formalization of it named Description Logic Based Dynamic Systems [Calvanese et al., 2013], and the Golog-based work of [Baader and Zarrie\u00df, 2013].", "startOffset": 92, "endOffset": 116}, {"referenceID": 10, "context": "These works all share the same concept: handle the data-layer through a Description Logic ontology, while the process-layer, since DLs are only able to give a static representation of the domain of interest, is defined as actions that update the ontology (the so-called \u201cfunctional view of knowledge bases\u201d [Levesque, 1984]).", "startOffset": 307, "endOffset": 323}, {"referenceID": 12, "context": "Artifact-centric models developed in parallel with declarative approaches for modelling processes [Pesic and Van Der Aalst, 2006; Montali et al., 2010], where activities try to adapt the internal system to the humans involved and the input they receive.", "startOffset": 98, "endOffset": 151}, {"referenceID": 11, "context": "Artifact-centric models developed in parallel with declarative approaches for modelling processes [Pesic and Van Der Aalst, 2006; Montali et al., 2010], where activities try to adapt the internal system to the humans involved and the input they receive.", "startOffset": 98, "endOffset": 151}, {"referenceID": 2, "context": "More specifically, we adopt DL-LiteA ontologies [Calvanese et al., 2006], and restrict the possible TBox axioms by not allowing functional roles, nor attributes.", "startOffset": 48, "endOffset": 72}, {"referenceID": 8, "context": "We also assume, for consistency reasons, that (T,E) is satisfiable under the canonical interpretation [Glimm et al., 2011].", "startOffset": 102, "endOffset": 122}, {"referenceID": 4, "context": "A DKB is a concrete instantiation of the abstract framework Description Logic Based Dynamic System [Calvanese et al., 2013], which is a tuple S = (TS , AS ,\u0393S) where (TS , AS) is a DL KB (note that the KB is not restricted to use DL-Lite), and \u0393S is a set of actions of the type a = (\u03c0, \u03c4).", "startOffset": 99, "endOffset": 123}, {"referenceID": 9, "context": "Our framework is also closely related to the framework Knowledge and Action Bases (KAB) [Hariri et al., 2013].", "startOffset": 88, "endOffset": 109}, {"referenceID": 7, "context": "In decision making [Gigerenzer and Gaissmaier, 2011], \u201can heuristic is a strategy that ignores part of the information, with the goal of making decisions more quickly, frugally, and/or accurately than more complex methods\u201d.", "startOffset": 19, "endOffset": 52}, {"referenceID": 9, "context": "In the actual specification of a DKB (and also in the framework Knowledge and Action Bases [Hariri et al., 2013]), actions could lead to inconsistent states w.", "startOffset": 91, "endOffset": 112}, {"referenceID": 3, "context": "This property can be easily derived from the definition of chase of a DL-LiteA KB [Calvanese et al., 2009], which is used to generate the set of inferred terms.", "startOffset": 82, "endOffset": 106}, {"referenceID": 3, "context": "If (T,A) is satisfiable, from the definition of chase and NI-closure of T (denoted cln(T )) of a DL-LiteA KB [Calvanese et al., 2009], it follows that, for every assertion \u03b1 in chase(T,A) we have cln(T ) |= \u03b1.", "startOffset": 109, "endOffset": 133}, {"referenceID": 3, "context": "an assertion \u03b1 (with \u03b1 an assertion of the type A(i) or P(i1, i2)), denoted by cln(T, \u03b1), the TBox defined as the NI-closure of T [Calvanese et al., 2009] where all the assertions in which A (resp.", "startOffset": 130, "endOffset": 154}, {"referenceID": 3, "context": "From [Calvanese et al., 2009], we have that the canonical interpretation can(K) is a model of K if and only if DB(A \u222a {\u03b1}) is a model of (cln(T ), A \u222a {\u03b1}).", "startOffset": 5, "endOffset": 29}, {"referenceID": 3, "context": "Using the query reformulation algorithm [Calvanese et al., 2009], the TBox T is not necessary to find the possible action instantiations (query answering), thus making T superfluous for the building of \u03a5D, but still being consistent w.", "startOffset": 40, "endOffset": 64}, {"referenceID": 8, "context": "ical interpretation [Glimm et al., 2011]: an abstract ABox \u00c2 is consistent w.", "startOffset": 20, "endOffset": 40}], "year": 2017, "abstractText": "Artifact-centric models for business processes recently raised a lot of attention as they manage to combine structural (i.e. data related) with dynamical (i.e. process related) aspects in a seamless way. This developed in parallel with declarative approaches for modelling processes, where activities are not burdened by over-specified constrains like in traditional process-centric approaches, but try to adapt the internal system to the humans involved and the input they receive. In this paper, we try to merge these two aspects by proposing a framework aimed at describing rich business domains through Description Logic-based ontologies, and where a set of actions allows the system to evolve by modifying such ontologies. We then propose an evolution of such framework which represents a viable and formal environment to develop decision making and planning techniques for DL-based artifactcentric business domains.", "creator": "LaTeX with hyperref package"}}}