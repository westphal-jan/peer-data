{"id": "1503.06733", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Mar-2015", "title": "Yara Parser: A Fast and Accurate Dependency Parser", "abstract": "hierarchical parsers ranks among the most intensive tools and natural hierarchy software as nodes generate nothing important applications targeting downstream tasks such as information retrieval, syntax translation nor knowledge acquisition. we build the temporal parser, a slightly backward accurate zero - source dependency code residing outside the arc - eager algorithm lazy beam search. it deserves maximum equivalence accuracy of 98. 02 past the standard wsj test set who leads it among the best dependency parsers. turing its fastest, yara can parse about 4000 sentences per second when in normal mode ( 1 mb ). when optimizing for accuracy ( using 64 beams and brown hal models ), yara determines parse 720 sentence without question. the programmer can be trained on any syntactic information curve and different options were provided utilizing theory to make content more flexible and tunable for higher tasks. it is released with proprietary apache api 2. 0 project and can is used general commercially free and academic customers. mandatory accessibility requirements choose started at", "histories": [["v1", "Mon, 23 Mar 2015 17:20:54 GMT  (255kb,D)", "http://arxiv.org/abs/1503.06733v1", null], ["v2", "Tue, 24 Mar 2015 18:45:13 GMT  (757kb,D)", "http://arxiv.org/abs/1503.06733v2", null]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["mohammad sadegh rasooli", "joel tetreault"], "accepted": false, "id": "1503.06733"}, "pdf": {"name": "1503.06733.pdf", "metadata": {"source": "CRF", "title": "Yara Parser: A Fast and Accurate Dependency Parser", "authors": ["Mohammad Sadegh Rasooli", "Joel Tetreault"], "emails": ["rasooli@cs.columbia.edu", "tetreaul@yahoo-inc.com"], "sections": [{"heading": null, "text": "many important applications in downstream tasks such as information retrieval, machine translation and knowledge acquisition. We introduce the Yara Parser, a fast and accurate open-source dependency parser based on the arc-eager algorithm and beam search. It achieves an unlabeled accuracy of 93.32 on the standard WSJ test set which ranks it among the top dependency parsers. At its fastest, Yara can parse about 4000 sentences per second when in greedy mode (1 beam). When optimizing for accuracy (using 64 beams and Brown cluster features), Yara can parse 45 sentences per second. The parser can be trained on any syntactic dependency treebank and different options are provided in order to make it more flexible and tunable for specific tasks. It is released with the Apache version 2.0 license and can be used for both commercial and academic purposes. The parser can be found at https: //github.com/yahoo/YaraParser.\nContents"}, {"heading": "1 Introduction 2", "text": ""}, {"heading": "2 Using Yara in Practice 2", "text": "2.1 Data format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 2.2 Training and Model Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\n2.2.1 Punctuation Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2.2.2 Some Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n2.3 Test and Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.4 Parsing a Partial Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.5 Yara Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.6 Pipeline API usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n2.6.1 Importing libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.6.2 Parsing Raw Text File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.6.3 Parsing Raw Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.6.4 Parsing a Sentence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.6.5 Parsing a Tokenized Sentence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.6.6 Parsing a Tagged Sentence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6"}, {"heading": "3 Yara Technical Details 7", "text": "3.1 Arc-Eager Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 3.2 Online Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 3.3 Beam Search and Update Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 3.4 Dynamic and Static Oracles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 3.5 Other Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\n\u2217Implementation of the core structure of the parser was done during a summer internship at Yahoo Labs NYC.\nar X\niv :1\n50 3.\n06 73\n3v 1\n[ cs\n.C L\n] 2\n3 M"}, {"heading": "4 Experiments 9", "text": "4.1 Parsing WSJ Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 4.2 Parsing Non-Projective Languages: Persian . . . . . . . . . . . . . . . . . . . . . . . . . . 10"}, {"heading": "5 Conclusion and Future Work 11", "text": ""}, {"heading": "1 Introduction", "text": "Dependency trees are one of the main representations used in the syntactic analysis of sentences. They show explicit syntactic dependencies among words in the sentence [K\u00fcbler et al., 2009]. Many dependency parsers have been released in the past decade. Among them, graph-based and transition-based parsing are two main approaches towards dependency parsing. In graph-based models, the parser aims to find the most likely tree from all possible trees by using maximum spanning tree algorithms often in conjunction with dynamic programming. On the other hand, in transition-based models, a tree is converted to a set of incremental actions and the parser decides to commit an action depending on the current configuration of the partial tree. Graph-based parsers can achieve state-of-the-art performance with the guarantee of recovering the best possible parse, but usually at the expense of speed. On the other hand, transition-based parsers are fast because the parser can greedily choose an action in each configuration and thus it can use arbitrary non-local features to compensate the lack of optimality. Also, it is easy to augment the set of actions to extend the functionality of the parser on such tasks as disfluency detection [Rasooli and Tetreault, 2013, Rasooli and Tetreault, 2014, Honnibal and Johnson, 2014] and punctuation prediction [Zhang et al., 2013a]. They are mostly used in supervised tasks but in rare cases they are also used in unsupervised tasks either with little manual linguistic knowledge or with no prior knowledge [Daum\u00e9 III, 2009, Rasooli and Faili, 2012].\nIn this report, we provide a brief introduction to our newly released dependency parser. We show that it can achieve a very high accuracy on the standard English WSJ test set and show that it is very fast even in its slowest mode while getting results very close to state-of-the-art. The structure of this report is as follows: in \u00a72 we provide some details about using Yara both in command line and as an API. We provide technical details about it in \u00a73 and experiments are conducted in \u00a74. Finally we conclude in \u00a75."}, {"heading": "2 Using Yara in Practice", "text": "In this section, we give a brief overview of training the parser, using it from the command-line and also as an API. Finally we introduce a simple NLP pipeline that can parse text files. All technical details for the parser are provided in \u00a73. The default settings for Yara are expected to be the best in practice for accuracy (except the number of training iterations which is dependent on the data and feature settings)."}, {"heading": "2.1 Data format", "text": "Yara uses the CoNLL 2006 dependency format1 for training as well as testing. The CoNLL format is a tabular one in which each word (and its information) in a sentence occupies one line and sentences are separated by a blank line. Each line is organized into the following tab-delimited columns: 1) word number (starting at one), 2) word form, 3) word lemma, 4) coarse-grained POS tag, 5) fine-grained POS (part-of-speech) tag, 6) unordered set of syntactic and/or morphological features, separated by a vertical bar (|), or an underscore if not available, 7) head of current token (an integer showing the head number where 0 indicates root token), 8) dependency label, 9) projective head (underscore if not available) and 10) projective dependency labels (underscore if not available). Blank fields are represented by an underscore. Yara only uses the first, second, fourth, seventh and eights columns."}, {"heading": "2.2 Training and Model Selection", "text": "The jar file in the package can be directly used to train a model with the following command line (run from the root directory of the project):\n\u00bb java -jar jar/YaraParser.jar train -train-file [train-file] -dev [dev-file] -model [model-file]\n1http://ilk.uvt.nl/conll/#dataformat\n-punc [punc-file]\nwhere [train-file] and [dev-file] are CoNLL files for training and development data and [model-file] is the output path for the trained model file. [punc-file] contains a list of POS tags for punctuations in the treebank (see \u00a72.2.1). The model for each iteration will be saved with the pattern [model-file]_iter[iter#]; e.g. model_iter2. In this way, the user can track the best performing model and delete all others. For cases where there is no development data, the user can remove the -dev option from the command line and use any of the saved model files as the final model based on his/her prior knowledge (15 is a reasonable number).\nThe other options are as follows: \u2022 -cluster [cluster-file] Brown cluster file: at most 4096 clusters are supported by Yara (default:\nempty). The format should be the same as https://github.com/percyliang/brown-cluster/ blob/master/output.txt\n\u2022 beam:[beam-width]; e.g. beam:16 (default is 64). \u2022 iter:[training-iterations]; e.g. iter:10 (default is 20). \u2022 unlabeled (default: labeled parsing, unless explicitly put \u2018unlabeled\u2019) \u2022 lowercase (default: case-sensitive words, unless explicitly put \u2018lowercase\u2019) \u2022 basic (default: use extended feature set, unless explicitly put \u2018basic\u2019) \u2022 static (default: use dynamic oracles, unless explicitly put \u2018static\u2019 for static oracles) \u2022 early (default: use max violation update, unless explicitly put \u2018early\u2019 for early update) \u2022 random (default: choose maximum scoring oracle, unless explicitly put \u2018random\u2019 for randomly\nchoosing an oracle) \u2022 nt:#threads; e.g. nt:4 (default is 8). \u2022 root_first (default: put ROOT in the last position, unless explicitly put \u2018root_first\u2019)"}, {"heading": "2.2.1 Punctuation Files", "text": "In most dependency evaluations, punctuation symbols and their incoming arcs are ignored. Most parser do this by using hard-coded rules for punctuation attachment. Yara instead allows the user to specify which punctuation POS tags are important to their task by providing a path for a punctuation file ([punc-file]) with the -punc option (e.g. -punc punc_files/wsj.puncs). If no file is provided, Yara uses WSJ punctuations. The punctuation file contains a list of punctuation POS tags, one per line. The Yara git repository provides punctuation files for WSJ data and Google universal POS tags [Petrov et al., 2011]."}, {"heading": "2.2.2 Some Examples", "text": "Here we provide examples for training Yara with different settings. Essentially we pick those examples where, we think, would be useful in practice.\nTraining with Brown clusters This can be done via the -cluster option.\n\u00bb java -jar jar/YaraParser.jar train -train-file [train-file] -dev [dev-file] -model [model-file] -punc [punc-file] -cluster [cluster-file]\nTraining with the fastest mode This can be done via the basic and beam:1 options.\n\u00bb java -jar jar/YaraParser.jar train -train-file [train-file] -dev [dev-file] -model [model-file] -punc [punc-file] beam:1 basic\nChanging the number of iterations This can be done via the iter option. In the following example, we selected 10 iterations.\n\u00bb java -jar jar/YaraParser.jar train -train-file [train-file] -dev [dev-file] -model [model-file] -punc [punc-file] iter:10\nExtending memory consumption It is possible that Java default setting for memory is less than what is really needed in some particular data sets. In those cases, we can extend the memory size by the JVM -Xmx option. In the following example, memory is extended to ten gigabytes.\n\u00bb java -Xmx10g -jar jar/YaraParser.jar train -train-file [train-file] -dev [dev-file] -model [model-file] -punc [punc-file]\nUsing very specific options The following example shows a specific case where Yara trains a model on the training data (data/train.conll), develops it on the development data (data/dev.conll), saves each model in the model file (model/train.model) for each iteration (model/train.model_iter1, model/train.model_iter2, model/train.model_iter3, etc), uses its specific punctuation list (punc_files/my_lang.puncs), uses its specific Brown cluster data (data/cluster.path), trains the model in 10 iterations, with 16 beams and 4 threads and uses static oracle and early update. This is all done after all words are lowercased (with the lowercase option).\n\u00bb java -Xmx10g -jar jar/YaraParser.jar train -train-file data/train.conll -dev data/dev.conll -model model/train.model -punc punc_files/my_lang.puncs -cluster data/cluster.path beam:16 iter:10 unlabeled lowercase static early nt:4 root_first"}, {"heading": "2.3 Test and Evaluation", "text": "The test file can be either a CoNLL file or a POS tagged file. The output will be a file in CoNLL format.\nParsing a CoNLL file \u00bb java -jar jar/YaraParser.jar parse_conll -input [test-file] -out [output-file] -model [model-file]\nParsing a tagged file The tagged file is a simple file where words and tags are separated by a delimiter (default is underscore). The user can use the option -delim [delimiter] (e.g. -delim /) to change the delimiter. The output will be in CoNLL format.\n\u00bb java -jar jar/YaraParser.jar parse_tagged -input [test-file] -out [output-file] -model [model-file]\nEvaluation Both [gold-file] and [parsed-file] should be in CoNLL format.\n\u00bb java -jar YaraParser.jar eval -gold [gold-file] -parse [parsed-file] -punc [punc-file]\nA more descriptive end-to-end example by using a small amount of German training data2 is shown in Yara\u2019s Github repository. This example is shown at https://github.com/yahoo/YaraParser#example-usage."}, {"heading": "2.4 Parsing a Partial Tree", "text": "Yara can parse partial trees where some gold dependencies are provided and it is expected to return a dependency tree consistent with the partial dependencies. Unknown dependencies are represented with \u201c-1\u201d as the head in the CoNLL format. Figure 1 shows an example of partial parse tree before and after doing constrained parsing.\n2https://github.com/yahoo/YaraParser/tree/master/sample_data\n\u00bb java -jar YaraParser.jar parse_partial -input [test-file] -out [output-file] -model [model-file]"}, {"heading": "2.5 Yara Pipeline", "text": "We also provide an easy pipeline to use Yara in real applications. The pipeline benefits from the OpenNLP3 tokenizer and sentence delimiter and our own POS tagger4. Thus the user has to download a specific sentence boundary detection and word tokenizer model from OpenNLP website depending on the specific target language. It is also possible to train a new sentence boundary detection and word tokenizer model with OpenNLP5.\nThe number of threads can be changed via the option nt:[#nt] (e.g. nt:10). The pipeline can be downloaded from https://github.com/rasoolims/YaraPipeline.\n\u00bb java -jar jar/YaraPipeline.jar -input [input file] -output [output file] -parse_model [parse model file] -pos_model [pos model] -tokenizer_model [tokenizer model] -sentence_model [sentence detector model]"}, {"heading": "2.6 Pipeline API usage", "text": "It is possible to use the Yara API directly6, but the pipeline gives an easier way to do it with different levels of information. The user can set the number of threads for parsing: numberOfThreads."}, {"heading": "2.6.1 Importing libraries", "text": "The user should first import libraries into the code as in Listing 1. Class YaraPipeline.java contains static methods for parsing a sentence, and ParseResult contains information about words, POS tags, dependency labels and heads, and normalized tagging score and parsing score. Info contains all information about parsing setting and models for the parser, POS tagger, tokenizer and sentence boundary detector.\n1 import edu . columbia . cs . r a s o o l i . YaraPipe l ine . S t ruc t s . In f o ; 2 import edu . columbia . cs . r a s o o l i . YaraPipe l ine . S t ruc t s . ParseResult ; 3 import edu . columbia . cs . r a s o o l i . YaraPipe l ine . YaraPipe l ine ;\nListing 1: Code for importing necessary libraries."}, {"heading": "2.6.2 Parsing Raw Text File", "text": "In this case, we need to have all models for parsing, tagging, tokenization and sentence boundary detection. Listing 2 shows such a case where the parser puts the results in CoNLL format into the [output_file].\n3http://opennlp.apache.org/index.html 4https://github.com/rasoolims/SemiSupervisedPosTagger 5For more information please visit OpenNLP manual at https://opennlp.apache.org/documentation/1.5.3/\nmanual/opennlp.html. 6https://github.com/yahoo/YaraParser/blob/master/src/YaraParser/Parser/API_UsageExample.java\n1 // should put r e a l f i l e path in the bracket s ( e . g . [ parse_model ] ) 2 In f o i n f o 1=new In fo ( \" [ parse_model ] \" , \" [ pos_model ] \" , \" [ tokenizer_model ] \" , \" [ sentence_model ] \" , numberOfThreads ) ; 3 YaraPipe l ine . p a r s eF i l e ( \" [ i npu t_ f i l e ] \" , \" [ ou tput_f i l e ] \" , i n f o 1 ) ;\nListing 2: Code for parsing raw text file"}, {"heading": "2.6.3 Parsing Raw Text", "text": "Similar to parsing a file, we can parse raw texts. It is shown in Listing 3.\n1 // should put r e a l f i l e path in the bracket s ( e . g . [ parse_model ] ) 2 In f o i n f o 2=new In fo ( \" [ parse_model ] \" , \" [ pos_model ] \" , \" [ tokenizer_model ] \" , \" [ sentence_model ] \" , numberOfThreads ) ; 3 St r ing someText=\" some text . . . . \" ; 4 St r ing conl lOutputText2= YaraPipe l ine . parseText ( someText , i n f o 1 ) ;\nListing 3: Code for parsing raw text"}, {"heading": "2.6.4 Parsing a Sentence", "text": "For the cases where the user uses his own sentence delimiter, it is possible to parse sentences as shown in Listing 4.\n1 // should put r e a l f i l e path in the bracket s ( e . g . [ parse_model ] ) 2 In f o i n f o 3=new In fo ( \" [ parse_model ] \" , \" [ pos_model ] \" , \" [ tokenizer_model ] \" , numberOfThreads ) ; 3 St r ing someSentence=\" some sentence . \" ; 4 ParseResult parseResu l t3= YaraPipe l ine . parseSentence ( someSentence , i n f o 1 ) ; 5 St r ing conl lOutputText3=parseResu l t3 . getConllOutput ( ) ;\nListing 4: Code for parsing a sentence"}, {"heading": "2.6.5 Parsing a Tokenized Sentence", "text": "Listing 5 shows an example for the cases where the user only wants to use the parser and POS tagger to parse a pre-tokenized sentence.\n1 // should put r e a l f i l e path in the bracket s ( e . g . [ parse_model ] ) 2 In f o i n f o 4=new In fo ( \" [ parse_model ] \" , \" [ pos_model ] \" , numberOfThreads ) ; 3 St r ing [ ] someWords4={\" some \" , \" words \" , \" . . . \" } ; 4 ParseResult parseResu l t4= YaraPipe l ine . parseTokenizedSentence ( someWords4 , i n f o 1 ) ; 5 St r ing conl lOutputText4=parseResu l t4 . getConllOutput ( ) ;\nListing 5: Code for parsing a tokenized sentence"}, {"heading": "2.6.6 Parsing a Tagged Sentence", "text": "Listing 6 shows an example for the cases where the user only wants to use Yara to parse pre-tagged sentence.\n1 // should put r e a l f i l e path in the bracket s ( e . g . [ parse_model ] ) 2 In f o i n f o 5=new In fo ( \" [ parse_model ] \" , numberOfThreads ) ; 3 St r ing [ ] someWords5={\" some \" , \" words \" , \" . . . \" } ; 4 St r ing [ ] someTags5={\" tag1 \" , \" tag2 \" , \" tag3 \" } ; 5 ParseResult parseResu l t5= YaraPipe l ine . parseTaggedSentence ( someWords5 , someTags5 , i n f o 1 ) ; 6 St r ing conl lOutputText5=parseResu l t5 . getConllOutput ( ) ;\nListing 6: Code for parsing a tagged sentence"}, {"heading": "3 Yara Technical Details", "text": "Yara is a transition-based dependency parser based on the arc-eager algorithm [Nivre, 2004]. It uses beam search training and decoding [Zhang and Clark, 2008] in order to avoid local errors in parser decisions. The features of the parser are roughly the same as [Zhang and Nivre, 2011] with additional Brown clustering [Brown et al., 1992] features.7 Yara also includes several flexible parameters and options to allow users to easily tune it depending on the language and task. Generally speaking, there are 128 possible combinations of the settings in addition to tuning the number of iterations, Brown clustering features and beam width.8"}, {"heading": "3.1 Arc-Eager Algorithm", "text": "As in the arc-eager algorithm, Yara has the following actions:\n\u2022 Left-arc (LA): The first word in the buffer becomes the head of the top word in the stack. The top word is popped after this action.\n\u2022 Right-arc (RA): The top word in the stack becomes the head of the first word in the buffer. \u2022 Reduce (R): The top word in the stack is popped. \u2022 Shift (SH): The first word in the buffer is pushed to the stack.\nDepending on position of the root, the constraints for initialization and actions differ. Figure 2 shows the transitions used to parse the sentence \"I want to parse a sentence .\".\nUnshift Action The original algorithm is not guaranteed to output a tree and thus in some occasions when the root is positioned in the beginning of the sentence, the parser decides to connect all remaining words in the stack to the root token. In [Nivre and Fern\u00e1ndez-Gonz\u00e1lez, 2014], a new action and empty flag is introduced to compensate for this problem and preserve the tree constraint. The action is called unshift which pops the first word in the stack and returns it to the start position of the buffer. We also added the \u201cunshift\u201d action for the cases where the root token is in the initial position of the sentence. This makes the parser more robust and gives a slight boost in performance.9"}, {"heading": "3.2 Online Learning", "text": "Most current supervised parsers use online learning algorithms. Online learners are fast, efficient and very accurate. We use averaged structured perceptron [Collins, 2002] which is also used in previous similar parsers [Zhang and Clark, 2008, Zhang and Nivre, 2011, Choi and Palmer, 2011]. We use different\n7The idea of using Brown clustering features is inspired from [Koo et al., 2008, Honnibal and Johnson, 2014]. 8We put the best performing setting as the default setting for Yara. 9This problem happens less in the case of beam search and it is more often in greedy parsing.\nengineering methods to speed up the parser, such as the averaging trick introduced by [Daum\u00e9 III, 2006,\nFigure 2.3]. Furthermore, all the features except label set-lexical pair features are converted to long integer values to prevent frequent hash collisions and decrease memory consumption. Semi-sparse weight vectors are used for additional speed up, though it comes with an increase in memory consumption. The details of this implementation are out of the scope of this report."}, {"heading": "3.3 Beam Search and Update Methods", "text": "Early transition-based parsers such as the Malt parser [Nivre et al., 2006] were greedy and trained in batch mode. This was done by converting each tree to a set of independent actions. This has been shown to be less effective than a global search. Given our feature setting, it is impossible to use dynamic programming to get the exact result. We instead use beam search as an approximation.10 Therefore, unlike batch learning, the same procedure is used for training and decoding the parser. Yara supports beam search and its default beam size is 64.\nThere are several ways to update the classifier weights with beam learning. A very trivial way is to get the best scoring result from beam search as the prediction and update the weights compared to the gold. This is known as \u201clate update\u201d but it does not lead to a good performance [Huang et al., 2012]. A more appealing way is to keep searching until the gold prediction goes out of the beam or the search reaches the end state. This is known as \"early update\" [Collins and Roark, 2004] and studies have shown a boost in performance relative to late update [Collins and Roark, 2004, Zhang and Clark, 2008]. The main problem with early update is that it does not update the weights according to the maximally violated prediction. A \"max-violation\" is a state in the beam where the gold standard is out of the beam and the gap in the score of the gold prediction and best scoring beam item is maximum. With max-violation update [Huang et al., 2012], the learner updates the weights according to the max-violation state. In other words, max-violation is the worst mistake that the classifier makes in the beam compared to the gold action. Yara supports both early and max-violation update while Zpar [Zhang and Nivre, 2011] only supports early update and RedShift [Honnibal and Johnson, 2014] only supports max-violation. Its default value for the update model is max-violation."}, {"heading": "3.4 Dynamic and Static Oracles", "text": "With the standard transition-based parsing algorithms, it is possible to have a parse tree with different action sequences. In other words, different search paths may lead to the same parse tree. Most of the off-the-shelf parsers such as Zpar [Zhang and Nivre, 2011] define some manual rules for recovering a gold oracle to give it to the learner. This is known as a static oracle. The other way is to allow the oracle to be dynamic and let the learner choose from the oracles [Goldberg and Nivre, 2013]. Yara supports both static and dynamic oracles. In the case of dynamic oracles, only zero-cost explorations are allowed. In [Goldberg and Nivre, 2013], the gold oracle can be chosen randomly but we also provided another option to choose the best scoring oracle as the selected oracle. The latter way is known as latent structured Perceptron [Sun et al., 2013] by supposing the gold tree as the structure and each oracle as a latent path for reaching the final structure. Our experiments show that using the highest scoring oracle gives slightly better results and thus we let it be the default option in the parser training."}, {"heading": "3.5 Other Properties", "text": "Root Position In [Ballesteros and Nivre, 2013], it is shown that the position of the root token has a significant effect on the parser performance. We allow the root to be either in the initial or final position in the sentence. The final position is the default option for Yara parser.\nFeatures We use roughly the same feature set as [Zhang and Nivre, 2011]. The extended feature set is the default but the user can use the basic option to set it to basic set of local features to improve speed with a loss in accuracy. We also add extra features from Brown word clusters [Brown et al., 1992], as used in [Koo et al., 2008], by using the Brown clusters for the first word in the buffer and stack, the prefixes of length 4 and 6 from the cluster bit string in the place of part of speech tags and the full bit string of the cluster in the place of words. When using all the features, we get a boost in performance but at the expense of speed.\n10Greedy search can be viewed as beam search with a beam size of one.\nUnlabeled Parsing Although the parser is designed for labeled parsing, unlabeled parsing is also available through command line options. This is useful for the cases where the user simply needs a very fast parser and does not care about the loss in performance or the lack of label information.\nPartial Parsing There are some occasions especially in semi-supervised parsing, where we have partial information about the tree, for example, we know that the third word is the subject of the first word. With partial parsing, we let the user benefit from dynamic oracles to parse partial trees such that known arcs are preserved unless the tree constraints cannot be satisfied.\nMultithreading Given the fact that current systems have multiple processing unit cores and many of those cores, support hyper-threading, we added the support for multithreading. When dealing with a file, the parser does multithreaded parsing on the sentence level (i.e. parsing sentences in parallel but outputting them in the same order given in the input). When using the API, it is possible to use multithreading at the beam-level. Beam level multithreading is slower than sentence-level multithreading. We also use beam-level multi-threading for training the parser and this significantly speeds up the training phase. Yara\u2019s default is set to 8 threads but the user can easily change it.\nModel Selection Unlike most current parsers, Yara saves the model file for all training iterations and lets the user choose the best performing model based on the performance on the development data. It also reports the performance on the development data to make it easier for the users to select the best model.\nTree Scoring Yara also has the option to output the parse score to a text file. The score is the perceptron score divided by the sentence length.\nLowercasing In cases, such as spoken lanuage parsing, no casing is provided and it is better to train on lowercased text. Yara has this option with the argument lowercase in training."}, {"heading": "4 Experiments", "text": "In this section we show how Yara performs on two different data sets and compare its performance to other leading parsers. We also graphically depict the tradeoff between beam width and accuracy and number of iterations. For all experiments we use version 0.2 of Yara."}, {"heading": "4.1 Parsing WSJ Data", "text": "We use the the traditional WSJ train-dev-test split for our experiment. As in [Zhang and Nivre, 2011], we first converted the WSJ data [Marcus et al., 1993] with Penn2Malt11. Next, automatic POS tags are generated for the whole dataset with version 0.2 of our POS tagger12 by doing 10-way jack-knifing on the training data. The tagger is a 20-beam third-order tagger trained with the maximum violation strategy with the same settings as in [Collins, 2002], along with additional Brown clustering features [Liang, 2005].13 It achieved a POS tagging accuracy of 97.14, 97.18 and 97.37 on the train, development and test files respectively.\nTable 1 shows the results on WSJ data by varying beam size and the use of Brown clusters. A comparison with prior art is made in Table 2. All unlabeled accuracy scores (UAS) and labeled accuracy scores (LAS) are calculated with punctuations ignored. As seen in Table 1, Yara\u2019s accuracy is very close to the state-of-the-art [Bohnet and Nivre, 2012].\nEffect of Beam Size Choosing a reasonable beam size is essential in certain NLP applications as there is always a trade-off between speed and performance. As shown in Figure 3, after a beam size of eight, the performance results do not change as much as the performance gap in for example beam of size one compared to beam of size two. This is useful because when changing the beam size from 64 to 8, one may speed up parsing by a factor of three (as shown in Table 3) with a small relative loss in performance.\n11stp.lingfil.uu.se/~nivre/research/Penn2Malt.html 12https://github.com/rasoolims/SemiSupervisedPosTagger. 13We use the pre-built Brown cluster features in http://metaoptimize.com/projects/wordreprs/ with 1000 word\nclasses."}, {"heading": "4.2 Parsing Non-Projective Languages: Persian", "text": "As mentioned before, Yara can only be trained on projective trees and thus there will be some loss in accuracy for non-projective languages. We use version 1.1 of the Persian dependency treebank (PerDT) [Rasooli et al., 2013]14 and tagged it with the same setting as WSJ data. We tokenized Mizan corpus15 and add it to our training data to create 1000 Brown clusters.16 The training data contains 22% nonprojective trees. We use Mate parser (v3.6.1) [Bohnet, 2010] as a highly accurate non-projective parsing tool to compare with Yara. Table 4 shows the performance for the two parsers. There is a 1.35% gap in\n14http://www.dadegan.ir/catalog/perdt 15http://www.dadegan.ir/catalog/mizan 16The definition of Brown cluster in this data is loose because there are multi-word verbs in the treebank while Brown clusters are acquired from training on single words. Therefore multi-word verbs in the treebank will not get any Brown cluster assignment and thus we will have a slight loss in performance.\nunlabeled accuracy but given that 22% of the trees (\u223c2.5% of the arcs) are non-projective, this gap is reasonable."}, {"heading": "5 Conclusion and Future Work", "text": "We presented an introduction to our open-source dependency parser. We showed that the parser is very fast and accurate. This parser can also be used for non-projective languages with a very slight loss in performance. We believe that our parser can be useful in different downstream tasks given its performance and flexible license. Our future plans include extending this parser to handle non-projectivity and also use continuous value representation features such as word embeddings to improve the accuracy of the parser."}, {"heading": "Acknowledgements", "text": "We would like to thank Yahoo labs open-sourcing team to allow us to release the parser with a very flexible license, especially Dev Glass for setting up the initial release of the code. We thank Amanda Stent, Kapil Thadani, Idan Szpektor and Yuval Pinter and other colleagues in Yahoo labs for their support and fruitful ideas. Finally we thank Michael Collins and Matthew Honnibal for their feedback."}], "references": [{"title": "Going to the roots of dependency parsing", "author": ["Ballesteros", "Nivre", "M. 2013] Ballesteros", "J. Nivre"], "venue": "Computational Linguistics,", "citeRegEx": "Ballesteros et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Ballesteros et al\\.", "year": 2013}, {"title": "A transition-based system for joint partof-speech tagging and labeled non-projective dependency parsing", "author": ["Bohnet", "Nivre", "B. 2012] Bohnet", "J. Nivre"], "venue": "In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,", "citeRegEx": "Bohnet et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Bohnet et al\\.", "year": 2012}, {"title": "Class-based n-gram models of natural language", "author": ["Brown et al", "P.F. 1992] Brown", "P.V. Desouza", "R.L. Mercer", "V.J.D. Pietra", "J.C. Lai"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q1992\\E", "shortCiteRegEx": "al. et al\\.", "year": 1992}, {"title": "Transition-based dependency parsing with selectional branching", "author": ["Choi", "McCallum", "J.D. 2013] Choi", "A. McCallum"], "venue": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),", "citeRegEx": "Choi et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Choi et al\\.", "year": 2013}, {"title": "Getting the most out of transition-based dependency parsing", "author": ["Choi", "Palmer", "J.D. 2011] Choi", "M. Palmer"], "venue": "In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Choi et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Choi et al\\.", "year": 2011}, {"title": "Incremental parsing with the perceptron algorithm. In Proceedings of the 42nd Meeting of the Association for Computational Linguistics (ACL\u201904)", "author": ["Collins", "Roark", "M. 2004] Collins", "B. Roark"], "venue": "Main Volume,", "citeRegEx": "Collins et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Collins et al\\.", "year": 2004}, {"title": "Practical Structured Learning Techniques for Natural Language Processing", "author": ["III Daum\u00e9", "III H. 2006] Daum\u00e9"], "venue": "PhD thesis,", "citeRegEx": "Daum\u00e9 and Daum\u00e9,? \\Q2006\\E", "shortCiteRegEx": "Daum\u00e9 and Daum\u00e9", "year": 2006}, {"title": "Unsupervised search-based structured prediction", "author": ["III Daum\u00e9", "III H. 2009] Daum\u00e9"], "venue": "In Proceedings of the 26th Annual International Conference on Machine Learning,", "citeRegEx": "Daum\u00e9 and Daum\u00e9,? \\Q2009\\E", "shortCiteRegEx": "Daum\u00e9 and Daum\u00e9", "year": 2009}, {"title": "Training deterministic parsers with nondeterministic oracles", "author": ["Goldberg", "Nivre", "Y. 2013] Goldberg", "J. Nivre"], "venue": null, "citeRegEx": "Goldberg et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Goldberg et al\\.", "year": 2013}, {"title": "Joint incremental disfluency detection and dependency parsing", "author": ["Honnibal", "Johnson", "M. 2014] Honnibal", "M. Johnson"], "venue": "Transactions of the Association for Computational Linguistics,", "citeRegEx": "Honnibal et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Honnibal et al\\.", "year": 2014}, {"title": "Structured perceptron with inexact search", "author": ["Huang et al", "L. 2012] Huang", "S. Fayong", "Y. Guo"], "venue": "In Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "al. et al\\.,? \\Q2012\\E", "shortCiteRegEx": "al. et al\\.", "year": 2012}, {"title": "Dynamic programming for linear-time incremental parsing", "author": ["Huang", "Sagae", "L. 2010] Huang", "K. Sagae"], "venue": "In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Huang et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Huang et al\\.", "year": 2010}, {"title": "Simple semi-supervised dependency parsing", "author": ["Koo et al", "T. 2008] Koo", "X. Carreras", "M. Collins"], "venue": "In Proceedings of ACL-08: HLT,", "citeRegEx": "al. et al\\.,? \\Q2008\\E", "shortCiteRegEx": "al. et al\\.", "year": 2008}, {"title": "Efficient third-order dependency parsers", "author": ["Koo", "Collins", "T. 2010] Koo", "M. Collins"], "venue": "In Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics,", "citeRegEx": "Koo et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Koo et al\\.", "year": 2010}, {"title": "Fourth-order dependency parsing", "author": ["Ma", "Zhao", "X. 2012] Ma", "H. Zhao"], "venue": "In Proceedings of COLING 2012: Posters,", "citeRegEx": "Ma et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Ma et al\\.", "year": 2012}, {"title": "Building a large annotated corpus of English: The Penn treebank", "author": ["Marcus et al", "M.P. 1993] Marcus", "M.A. Marcinkiewicz", "B. Santorini"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q1993\\E", "shortCiteRegEx": "al. et al\\.", "year": 1993}, {"title": "Turning on the turbo: Fast third-order non-projective turbo parsers", "author": ["Martins et al", "A. 2013] Martins", "M. Almeida", "N.A. Smith"], "venue": "In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers),", "citeRegEx": "al. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "al. et al\\.", "year": 2013}, {"title": "Non-projective dependency parsing using spanning tree algorithms", "author": ["McDonald et al", "R. 2005] McDonald", "F. Pereira", "K. Ribarov", "J. Haji\u010d"], "venue": "In Proceedings of the Conference on Human Language Technology and Empirical Methods in Natural Language Processing,", "citeRegEx": "al. et al\\.,? \\Q2005\\E", "shortCiteRegEx": "al. et al\\.", "year": 2005}, {"title": "Online learning of approximate dependency parsing algorithms", "author": ["McDonald", "Pereira", "R.T. 2006] McDonald", "F.C. Pereira"], "venue": "In Proceedings of the 11th Conference of the European Chapter of the Association", "citeRegEx": "McDonald et al\\.,? \\Q2006\\E", "shortCiteRegEx": "McDonald et al\\.", "year": 2006}, {"title": "Arc-eager parsing with the tree constraint", "author": ["Nivre", "Fern\u00e1ndez-Gonz\u00e1lez", "J. 2014] Nivre", "D. Fern\u00e1ndez-Gonz\u00e1lez"], "venue": "Computational linguistics,", "citeRegEx": "Nivre et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Nivre et al\\.", "year": 2014}, {"title": "Maltparser: A data-driven parser-generator for dependency parsing", "author": ["Nivre et al", "J. 2006] Nivre", "J. Hall", "J. Nilsson"], "venue": "In Proceedings of LREC,", "citeRegEx": "al. et al\\.,? \\Q2006\\E", "shortCiteRegEx": "al. et al\\.", "year": 2006}, {"title": "A universal part-of-speech tagset", "author": ["Petrov et al", "S. 2011] Petrov", "D. Das", "R. McDonald"], "venue": "arXiv preprint arXiv:1104.2086", "citeRegEx": "al. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "al. et al\\.", "year": 2011}, {"title": "Branch and bound algorithm for dependency parsing with non-local features. Transactions of the Association for Computational Linguistics, 1:37\u201348", "author": ["Qian", "Liu", "X. 2013] Qian", "Y. Liu"], "venue": null, "citeRegEx": "Qian et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Qian et al\\.", "year": 2013}, {"title": "Fast unsupervised dependency parsing with arc-standard transitions", "author": ["Rasooli", "Faili", "M.S. 2012] Rasooli", "H. Faili"], "venue": "In Proceedings of the Joint Workshop on Unsupervised and Semi-Supervised Learning in NLP,", "citeRegEx": "Rasooli et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Rasooli et al\\.", "year": 2012}, {"title": "Development of a Persian syntactic dependency treebank", "author": ["Rasooli et al", "M.S. 2013] Rasooli", "M. Kouhestani", "A. Moloodi"], "venue": "In Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "al. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "al. et al\\.", "year": 2013}, {"title": "Joint parsing and disfluency detection in linear time", "author": ["Rasooli", "Tetreault", "M.S. 2013] Rasooli", "J. Tetreault"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Rasooli et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Rasooli et al\\.", "year": 2013}, {"title": "Non-monotonic parsing of fluent umm I mean disfluent sentences", "author": ["Rasooli", "Tetreault", "M.S. 2014] Rasooli", "J. Tetreault"], "venue": "In Proceedings of the 14th Conference of the European Chapter of the Association for Computational Linguistics,", "citeRegEx": "Rasooli et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Rasooli et al\\.", "year": 2014}, {"title": "Parser combination by reparsing", "author": ["Sagae", "Lavie", "K. 2006] Sagae", "A. Lavie"], "venue": "In Proceedings of the Human Language Technology Conference of the NAACL, Companion Volume: Short Papers,", "citeRegEx": "Sagae et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Sagae et al\\.", "year": 2006}, {"title": "Latent structured perceptrons for largescale learning with hidden information", "author": ["Sun et al", "X. 2013] Sun", "T. Matsuzaki", "W. Li"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "al. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "al. et al\\.", "year": 2013}, {"title": "Punctuation prediction with transition-based parsing. In Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)", "author": ["Zhang et al", "D. 2013a] Zhang", "S. Wu", "N. Yang", "M. Li"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "al. et al\\.", "year": 2013}, {"title": "Online learning for inexact hypergraph search", "author": ["Zhang et al", "H. 2013b] Zhang", "L. Huang", "K. Zhao", "R. McDonald"], "venue": "In Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "al. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "al. et al\\.", "year": 2013}, {"title": "Generalized higher-order dependency parsing with cube pruning", "author": ["Zhang", "McDonald", "H. 2012] Zhang", "R. McDonald"], "venue": "In Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning,", "citeRegEx": "Zhang et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2012}, {"title": "Enforcing structural diversity in cube-pruned dependency parsing", "author": ["Zhang", "McDonald", "H. 2014] Zhang", "R. McDonald"], "venue": "In Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics", "citeRegEx": "Zhang et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2014}, {"title": "A tale of two parsers: Investigating and combining graph-based and transition-based dependency parsing", "author": ["Zhang", "Clark", "Y. 2008] Zhang", "S. Clark"], "venue": "In Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing,", "citeRegEx": "Zhang et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2008}, {"title": "Transition-based dependency parsing with rich non-local features", "author": ["Zhang", "Nivre", "Y. 2011] Zhang", "J. Nivre"], "venue": "In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies,", "citeRegEx": "Zhang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Zhang et al\\.", "year": 2011}], "referenceMentions": [{"referenceID": 25, "context": "1 of the Persian dependency treebank (PerDT) [Rasooli et al., 2013]14 and tagged it with the same setting as WSJ data.", "startOffset": 45, "endOffset": 67}], "year": 2017, "abstractText": "Dependency parsers are among the most crucial tools in natural language processing as they have many important applications in downstream tasks such as information retrieval, machine translation and knowledge acquisition. We introduce the Yara Parser, a fast and accurate open-source dependency parser based on the arc-eager algorithm and beam search. It achieves an unlabeled accuracy of 93.32 on the standard WSJ test set which ranks it among the top dependency parsers. At its fastest, Yara can parse about 4000 sentences per second when in greedy mode (1 beam). When optimizing for accuracy (using 64 beams and Brown cluster features), Yara can parse 45 sentences per second. The parser can be trained on any syntactic dependency treebank and different options are provided in order to make it more flexible and tunable for specific tasks. It is released with the Apache version 2.0 license and can be used for both commercial and academic purposes. The parser can be found at https: //github.com/yahoo/YaraParser.", "creator": "LaTeX with hyperref package"}}}