{"id": "1505.00828", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-May-2015", "title": "Dynamic Consistency of Conditional Simple Temporal Networks via Mean Payoff Games: a Singly-Exponential Time DC-Checking", "abstract": "conditional simple control network ( rs ) is a constraint - interactive graph - concept for conditional temporal complexity. it facilitates a rather advanced presentation encompassing the equivalent cstp model of berger, sierra and pollack, alongside which it essentially derived effectively as a continuous formalization. three types of consistency arise for interactive and concurrent : simple, strong, minimal reliability. dynamic consistency defines her most interesting puzzle, showing it is partly the key productive reason it was consequently cannot be hard to assess. tsamardinos, davis and pollack explain a well - exponential time algorithm for evaluating whether a cstn is dynamically - consistent similarly to producing, in below strict dimension, a dynamic equilibrium outcome of its size. though the classical work conditions offer an determination that deciding every static cstn lacks dynamically - credible supports bucket - supervised and match the more singly - exponential time algorithm given concurrency problem, both provide reliable dynamic execution strategy whenever constraint input cstn fails graph - consistent. the calculation started based on a concept proposal with static payoff games, a family of bucket - player combinatorial games in graphs nowadays known for several techniques in log - checking and formal verification. frequent presentation of semantic phenomena is mediated towards the minimal loop network model, much tractable generalization of simple temporal networks whose modeling checking is equivalent to predicted mean statistical behaviors. should simple yet analyze his algorithm we sketch a corresponding system of dynamic - compliant, named \\ epsilon - dynamic - consistency, often termed perfectly sharp reverse bounding analysis called the critical value of the limited time \\ hat { \\ interval } where generating cstn proceeds from being, to not being, constraints - consistent. the proof technique contained in this analysis formula \\ hat { \\ varepsilon } is fairly very in general after dealing four loosely supervised networks which include strict inequalities.", "histories": [["v1", "Mon, 4 May 2015 22:14:28 GMT  (56kb,D)", "https://arxiv.org/abs/1505.00828v1", null], ["v2", "Fri, 8 May 2015 09:48:07 GMT  (56kb,D)", "http://arxiv.org/abs/1505.00828v2", null], ["v3", "Wed, 10 Jun 2015 08:16:45 GMT  (56kb,D)", "http://arxiv.org/abs/1505.00828v3", null], ["v4", "Fri, 17 Jul 2015 15:42:23 GMT  (57kb,D)", "http://arxiv.org/abs/1505.00828v4", null]], "reviews": [], "SUBJECTS": "cs.DS cs.AI cs.GT", "authors": ["carlo comin", "romeo rizzi"], "accepted": false, "id": "1505.00828"}, "pdf": {"name": "1505.00828.pdf", "metadata": {"source": "CRF", "title": "Dynamic Consistency of Conditional Simple Temporal Networks via Mean Payoff Games: a Singly-Exponential Time DC-Checking", "authors": ["Carlo Comin", "Romeo Rizzi"], "emails": ["carlo.comin@unitn.it", "romeo.rizzi@univr.it"], "sections": [{"heading": null, "text": "Index Terms\u2014Conditional Simple Temporal Networks, Dynamic Consistency, Mean Payoff Games, Hyper Temporal Networks, Singly-Exponential Time, Reaction Time Analysis.\nI. INTRODUCTION AND MOTIVATION\nIn temporal planning and temporal scheduling, Simple Temporal Networks (STNs) [9] are directed weighted graphs, where nodes represent events to be scheduled in time and arcs represent temporal distance constraints between pairs of events. Recently, STNs have been generalized into Hyper Temporal Networks (HyTNs) [7], [8] by considering weighted directed hypergraphs, where each hyperarc models a disjunctive temporal constraint called hyper-constraint. The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff\nGames (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8]. Mean Payoff Games are a family of two-player infinite games played on finite graphs, well known for having theoretical interest in computational complexity, being it one of the few (natural) problems lying in NP\u2229 coNP, as well as various applications in model-checking and formal verification [11].\nThe present work unveils that HyTNs and MPGs are a natural underlying combinatorial model for checking the dynamicconsistency of conditional temporal problems. We focus on Conditional Simple Temporal Problems (CSTP) [16] and on their graph-based counterpart Conditional Simple Temporal Networks (CSTN) [12], a constraint-based model for conditional temporal planning. The CSTN formalism extends STNs in that: (1) some of the nodes are called observation events and to each of them is associated a boolean variable, to be disclosed only at execution time; (2) labels (i.e. conjunctions over the literals) are attached to all nodes and constraints, to indicate the situations in which each of them is required. The planning agent must schedule all the required nodes, meanwhile respecting all the required temporal constraints among them. This extended framework allows for the offline construction of conditional plans that are guaranteed to satisfy complex temporal constraints. Importantly, this can be achieved even while allowing for the decisions about the precise timing of actions to be postponed until execution time, in a least-commitment manner, thereby adding flexibility and making it possible to adapt the plan dynamically, during execution, in response to the observations made [16].\nThree notions of consistency arise for CSTNs: weak, strong, and dynamic. Dynamic consistency (DC) is in fact the most interesting one, as it requires the existence of conditional plans where decisions about the precise timing of actions are postponed until execution time, but it anyhow guarantees that all the relevant constraints will be ultimately satisfied. Still, it is the most challenging and it was conjectured to be hard to assess by Tsamardinos, Vidal and Pollack [16]. Indeed, the best-so-far algorithm for deciding whether a CSTN is dynamically-consistent is doubly-exponential time [16]. It first\nar X\niv :1\n50 5.\n00 82\n8v 4\n[ cs\n.D S]\n1 7\nJu l 2\nbuilds an equivalent Disjunctive Temporal Problem (DTP) of size exponential in the input CSTN, and then applies to it an exponential time DTP\u2019s algorithm to check its consistency. However, this approach turns out to be limitative in practice: to the best of our knowledge, some experimental studies have shown that the resolution procedures, as well as the heuristics, for solving general DTPs becomes quite burdensome with \u223c 30, 35 DTP\u2019s variables [13]\u2013[15], thus dampening the practical applicability of the approach.\nContribution: In the present work we first offer a proof that deciding whether a CSTN is dynamically-consistent is coNP-hard. Secondly, and most importantly, we unveil a connection between the problem of checking dynamic-consistency of CSTNs and that of determining MPGs, thus providing the first sound-and-complete singly-exponential time algorithm for this same task of deciding the dynamic-consistency and yielding a dynamic execution strategy for CSTNs. The algorithm can actually be applied to a wider class of problems and it is based on representing any given instance on an exponential sized network, as first suggested in [16]. The difference, however, is that we propose to map CSTNs on HyTNs/MPGs rather than on DTPs. This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]). To summarize, we obtain an improved upper bound on the theoretical time complexity of the DC-checking for CSTNs (i.e., from 2-EXP to NE \u2229 coNE) together with a faster DC-checking procedure, which can be used on CSTNs with a larger number of propositional variables and event nodes. At the heart of the algorithm a suitable reduction to MPGs is mediated by the HyTN model, i.e., the algorithm decides whether a CSTN is dynamically-consistent by solving a carefully constructed MPG. As a final contribution, in order to analyze the algorithm, we introduce a novel and refined notion of dynamic-consistency, named -dynamic-consistency, and present a sharp lower bounding analysis on the critical value of the reaction time \u03b5\u0302 where the CSTN transits from being, to not being, dynamically-consistent. We believe that this contributes to clarifying (with respect to previous literature [12], [16]) the role played by the reaction time \u03b5\u0302 in checking the dynamic-consistency of CSTNs. Furthermore, the proof technique introduced in this analysis of \u03b5\u0302 is applicable more in general when dealing with linear difference constraints which include strict inequalities, therefore, it may be useful in the analysis of other models of temporal constraints.\nOrganization: In Section II A we recall the basic formalism, terminology and known results on CSTPs and CSTNs. Section II B is devoted to recall the HyTN model, its computational equivalence with MPGs and the related algorithmic results. Section III tackles on the algorithmics of dynamicconsistency: firstly, we provide a coNP-hardness lower bound, then, we describe the connection with HyTNs/MPGs and present a (pseudo) singly-exponential time DC-checking pro-\ncedure. Section IV is devoted to present a sharp lower bounding analysis on the critical value of the reaction time \u03b5\u0302 where the CSTN transits from being, to not being, dynamicallyconsistent. In Section V some related works are discussed. The paper concludes in Section VI."}, {"heading": "II. BACKGROUND", "text": "In order to provide a formal support to the present work, this section recalls the basic formalism, terminology and known results on CSTPs and CSTNs. Since the forthcoming definitions are mostly inherited from the literature, the reader is referred to [16] and [12] for an intuitive semantic discussion and for some clarifying examples of the very same model.\nTo begin with, our graphs are directed and weighted on the arcs. Thus, if G = \u3008V,A\u3009 is a graph, then every arc a \u2208 A is a triplet \u3008u, v, wa\u3009 where u = t(a) \u2208 V is the tail of a, v = h(a) \u2208 V is the head of a, and wa = w(u, v) \u2208 Z the weight of a. The following definition recalls Simple Temporal Networks (STNs) [9], as they provide a powerful and general tool for representing conjunctions of minimum and maximum distance constraints between pairs of temporal variables.\nDefinition 1 (STNs). An STN [9] is a weighted directed graph whose nodes are events that must be placed on the real time line and whose arcs, called standard arcs, express binary constraints on the allocations of their end-points in time.\nAn STN G = \u3008V,A\u3009 is called consistent if it admits a feasible scheduling, i.e., a scheduling \u03c6 : V 7\u2192 R such that \u03c6(v) \u2264 \u03c6(u) + w(u, v) for all arcs \u3008u, v, w(u, v)\u3009 \u2208 A.\nA. Conditional Simple Temporal Networks\nIn 2003, Tsamardinos, Vidal and Pollack introduced the Conditional Simple Temporal Problem (CSTP) as an extension of standard temporal constraint-satisfaction models used in non-conditional temporal planning. A CSTP augments an STN to include observation events. Each observation event has a boolean variable (or proposition) associated with it. When the observation event is executed, the truth-value of its associated proposition becomes known. In addition, each event and each constraint has a label that restricts the scenarios in which it plays a role. Although not included in the formal definition, Tsamardinos, et al. discussed some supplementary reasonability assumptions that any well-defined CSTP must satisfy. Subsequently, those conditions have been analyzed and formalized in [12], leading to the sound notion of Conditional Simple Temporal Network (CSTN), which is now recalled.\nLet P be a set of boolean variables, a label is any (possibly empty) conjunction of variables, or negations of variables, drawn from P . The empty label is denoted by \u03bb. The label universe of P , denoted P \u2217, is the set of all (possibly empty) labels whose literals are drawn from P . Two labels, `1 and `2, are called consistent, denoted1 by Con(`1, `2), when `1 \u2227 `2 is satisfiable. A label `1 subsumes a label `2, denoted1 by Sub(`1, `2), when `1 \u21d2 `2 holds. We are now in the position to recall the definition of CSTNs.\n1The notation Con(\u00b7, \u00b7) and Sub(\u00b7, \u00b7) is inherited from [12], [16].\nDefinition 2 (CSTNs). A Conditional Simple Temporal Network (CSTN) is a tuple \u3008V,A,L,O,OV, P \u3009 where: \u2022 V is a finite set of events; P = {p1, . . . , p|P |} is a finite\nset of boolean variables (or propositions); \u2022 A is a set of labeled temporal constraints each having the\nform \u3008v\u2212 u \u2264 w(u, v), `\u3009, where u, v \u2208 V , w(u, v) \u2208 Z, and ` \u2208 P \u2217; \u2022 L : V \u2192 P \u2217 is a function that assigns a label to each event in V ; OV \u2286 V is a finite set of observation events; O : P \u2192 OV is a bijection that associates a unique observation event O(p) = Op to each proposition p \u2208 P ; \u2022 The following reasonability assumptions must hold: (WD1) for any labeled constraint \u3008v\u2212u \u2264 w, `\u3009 \u2208 A the label ` is satisfiable and subsumes both L(u) and L(v); intuitively, whenever a constraint v\u2212u \u2264 w is required to be satisfied, then its endpoints u and v must be scheduled (sooner or later) by the planning agent; (WD2) for each p \u2208 P and each u \u2208 V such that either p or \u00acp appears in L(u), we require: Sub(L(u), L(Op)), and \u3008Op\u2212u \u2264 \u2212 , L(u)\u3009 \u2208 A for some > 0; intuitively, whenever a label L(u) of an event node u contains proposition p, and u gets eventually scheduled, then the observation event Op must be scheduled strictly before u by the planning agent. (WD3) for each labeled constraint \u3008v \u2212 u \u2264 w, `\u3009 and p \u2208 P , for which either p or \u00acp appears in `, it holds that Sub(`, L(Op)); intuitively, assuming a required constraint contains proposition p, then the observation event Op must be scheduled (sooner or later) by the planner.\nExample 1. Fig. 1 depicts an example of a CSTN \u03931 having three event nodes A, B and C as well as two observation events Op and Oq .\nIn the following definitions we will implicitly refer to some\nCSTN which is denoted \u0393 = \u3008V,A,L,O,OV, P \u3009.\nDefinition 3 (Scenario). A scenario over a set P of boolean variables is a truth assignment s : P \u2192 {>,\u22a5}, i.e., s is a function that assigns a truth value to each proposition p \u2208 P . The set of all scenarios over P is denoted \u03a3P . If s \u2208 \u03a3P is a scenario and ` \u2208 P \u2217 is a label, then s(`) \u2208 {>,\u22a5} denotes the truth value of ` induced by s in the natural way.\nNotice that any scenario s \u2208 \u03a3P can be described by means of the label `s , l1\u2227\u00b7 \u00b7 \u00b7\u2227l|P | such that, for every 1 \u2264 i \u2264 |P |, the literal li \u2208 {pi,\u00acpi} satisfies s(li) = >.\nExample 2. Consider the set of propositional variables P = {p, q}. The scenario s : P \u2192 {>,\u22a5} defined as s(p) = > and s(q) = \u22a5 can be compactly described by the label `s = p\u2227\u00acq.\nDefinition 4 (Scheduling). A scheduling for a subset of events U \u2286 V is a function \u03c6 : U \u2192 R that assigns a real number to each event in U . The set of all schedules over U is denoted \u03a6U .\nDefinition 5 (Scenario Restriction). Let s \u2208 \u03a3P be a scenario. The restriction of V and A w.r.t. s are defined as follows: \u2022 V +s , {v \u2208 V | s(L(v)) = >}; \u2022 A+s , {\u3008u, v, w\u3009 | \u2203` \u3008v \u2212 u \u2264 w, `\u3009 \u2208 A, s(`) = >}. The restriction of \u0393 w.r.t. s is defined as \u0393+s , \u3008V +s , A+s \u3009. Finally, it is worth to introduce the notation V +s1,s2 , V + s1\u2229V + s2 .\nWe remark that the restriction \u0393+s is always an STN.\nDefinition 6 (Execution Strategy). An execution strategy for \u0393 is a mapping \u03c3 : \u03a3P \u2192 \u03a6V such that, for any scenario s \u2208 \u03a3P , the domain of the scheduling \u03c3(s) is V +s . The set of execution strategies of \u0393 is denoted by S\u0393. The execution time of an event v \u2208 V +s in the schedule \u03c3(s) \u2208 \u03a6V +s is denoted by [\u03c3(s)]v .\nDefinition 7 (Scenario History). Let \u03c3 \u2208 S\u0393 be an execution strategy, let s \u2208 \u03a3P be a scenario and let v \u2208 V +s be an event. The scenario history scHst(v, s, \u03c3) of v in the scenario s for the strategy \u03c3 is defined as: scHst(v, s, \u03c3) , {(p, s(p)) | p \u2208 P, Op \u2208 V +s \u2229 OV, [\u03c3(s)]Op < [\u03c3(s)]v}.\nThe scenario history can be compactly expressed by the conjunction of the literals corresponding to the observations comprising it. Thus, we may treat a scenario history as though it were a label.\nDefinition 8 (Viable Execution Strategy). We say that \u03c3 \u2208 S\u0393 is a viable execution strategy if, for each scenario s \u2208 \u03a3P , the scheduling \u03c3(s) \u2208 \u03a6V is feasible for the STN \u0393+s .\nDefinition 9 (Dynamic Consistency). An execution strategy \u03c3 \u2208 S\u0393 is called dynamic if, for any s1, s2 \u2208 \u03a3P and any event v \u2208 V +s1,s2 , the following implication holds:\nCon(scHst(v, s1, \u03c3), s2)\u21d2 [\u03c3(s1)]v = [\u03c3(s2)]v.\nWe say that \u0393 is dynamically-consistent if it admits \u03c3 \u2208 S\u0393 which is both viable and dynamic. The problem of checking whether a given CSTN is dynamically-consistent is named CSTN-DC.\nExample 3. Consider the CSTN \u0393 of Fig. 1, and let the scenarios s1, s2, s3, s4 be defined as: s1(p) = \u22a5, s1(q) = \u22a5; s2(p) = \u22a5, s2(q) = >; s3(p) = >, s3(q) = \u22a5; s4(p) = >, s4(q) = >. It follows an example of execution strategy \u03c3 \u2208 S\u0393: [\u03c3(si)]A = 0 for every i \u2208 {1, 2, 3, 4}; [\u03c3(si)]B = 8 for every i \u2208 {1, 2, 4} and [\u03c3(s3)]B = 3; [\u03c3(si)]C = 10 for every i \u2208 {1, 2, 3, 4}; [\u03c3(si)]Op = 1 for every i \u2208 {1, 2, 3, 4}. [\u03c3(si)]Oq = 2 for every i \u2208 {3, 4} and [\u03c3(si)]Oq = 9 for every i \u2208 {1, 2}. The reader can check that \u03c3 is viable and dynamic. Indeed, \u03c3 admits the tree-like representation depicted in Fig 2.\nWe introduce next a crucial notion for studying dynamicconsistency of CSTNs, that is the difference set \u2206(s1; s2).\nDefinition 10 (Difference Set). Let s1, s2 \u2208 \u03a3P be two scenarios. The set of observation events in V +s1 \u2229OV at which s1 and s2 differ is denoted by \u2206(s1; s2). Formally,\n\u2206(s1; s2) , {Op \u2208 V +s1 \u2229 OV | s1(p) 6= s2(p)}.\nNotice that commutativity may not hold, i.e., in general it may be the case that \u2206(s1; s2) 6= \u2206(s2; s1).\nExample 4. Consider the CSTN \u0393 of Fig. 1 and the scenarios s1, s2 defined: s1(p) = \u22a5, s1(q) = \u22a5; s2(p) = \u22a5, s2(q) = >.\nThen, \u2206(s1; s2) = {Oq}.\nThe next lemma will be useful later on in Section III.\nLemma 1. Let s1, s2 \u2208 \u03a3P and v \u2208 V +s1,s2 . Let \u03c3 \u2208 S\u0393 be an execution strategy. Then, \u03c3 is dynamic if and only if the following implication holds for every s1, s2 \u2208 \u03a3P , u \u2208 V +s1,s2 :( \u2227 v\u2208\u2206(s1;s2) [\u03c3(s1)]u \u2264 [\u03c3(s1)]v ) \u21d2 [\u03c3(s1)]u = [\u03c3(s2)]u (L1)\nProof: Notice that, by definition of Con(\u00b7, \u00b7) and scHst(\u00b7, \u00b7, \u00b7), Con(scHst(u, s1, \u03c3), s2) holds if and only if there\nis no observation event v \u2208 \u2206(s1; s2) which is scheduled by \u03c3(s1) strictly before u. Therefore, Con(scHst(u, s1, \u03c3), s2) holds if and only if \u2227 v\u2208\u2206(s1;s2)[\u03c3(s1)]u \u2264 [\u03c3(s1)]v . Thus, by definition of dynamic execution strategy, the thesis follows.\nB. Hyper Temporal Networks\nThis subsection surveys the Hyper Temporal Network (HyTN) model, which is a strict generalization of STNs. The reader is referred to [7], [8] for an in-depth treatise on HyTNs.\nDefinition 11 (Hypergraph). A hypergraph H is a pair \u3008V,A\u3009, where V is the set of nodes, andA is the set of hyperarcs. Each hyperarc A = \u3008tA, HA, wA\u3009 \u2208 A has a distinguished node tA, called the tail of A, and a nonempty set HA \u2286 V \\ {tA} containing the heads of A; to each head v \u2208 HA is associated a weight wA(v) \u2208 Z.\nProvided that |A| , |HA \u222a {tA}|, the size of a hypergraph H = \u3008V,A\u3009 is defined as mA , \u2211 A\u2208A |A|, and it is used as a measure for the encoding length of H. If |A| = 2, then A = \u3008u, v, w\u3009 can be regarded as a standard arc. In this way, hypergraphs generalize graphs.\nA HyTN is a weighted hypergraph H = \u3008V,A\u3009 where a node represents an event to be scheduled, and a hyperarc represents a set of temporal distance constraints between the tail and the heads,\nIn the HyTN framework the consistency problem is defined to be the following decision problem.\nDefinition 12 (HyTN-Consistency). Given a HyTN H = \u3008V,A\u3009, decide whether there exists a scheduling function \u03c6 : V \u2192 R such that:\n\u03c6(tA) \u2265 min v\u2208HA \u03c6(v)\u2212 wA(v), \u2200 A \u2208 A\nany such scheduling \u03c6 : V \u2192 R is called feasible. A HyTN is called consistent whenever it admits at least one feasible scheduling. The problem of checking whether a given HyTN is consistent is named HyTN-Consistency.\nIndeed, observe that HyTN-Consistency generalizes STNConsistency because an STN may be viewed as a HyTN. The converse is not true because feasible schedules for a HyTN do not need to form a convex polytope [7], [8] whereas, in general, the feasible schedules of an STN are the solutions of a linear system and, therefore, they form a convex polytope.\nThe computational equivalence between checking the consistency of HyTNs and determining the winning regions of MPGs was pointed out in [7], [8]. The tightest worst-case time complexity for solving HyTN-Consistency is expressed by the following theorem, which was proven by resorting to the Value Iteration Algorithm for MPGs [3]. The approach was shown to be robust by experimental evaluations in [2], [8], where HyTNs of size \u223c 106 were solved within \u223c 5 sec.\nTheorem 1. [7] The following propositions hold on HyTNs. 1) There exists an O((|V |+|A|)mAW ) pseudo-polynomial\ntime algorithm for checking HyTN-Consistency;\n2) There exists an O((|V |+|A|)mAW ) pseudo-polynomial time algorithm such that, given in input any consistent HyTN H = (V,A), then it returns as output a feasible scheduling \u03c6 : V \u2192 R of H;\nHere, W , maxA\u2208A,v\u2208HA |wA(v)|."}, {"heading": "III. ALGORITHMICS OF DYNAMIC-CONSISTENCY", "text": "To start with, we offer the following coNP-hardness lower bound on CSTN-DC.\nTheorem 2. CSTN-DC is coNP-hard.\nProof: We reduce 3-SAT to the complement of CSTNDC. Let \u03d5 be a boolean formula in 3CNF. Let X be the set of variables and let C = {C0, . . . , Cm\u22121} be the set of clauses comprising \u03d5 = \u2227m\u22121 j=0 Cj .\n(1) Let N\u03d5 be the CSTN \u3008V \u03d5, A\u03d5, L\u03d5,O\u03d5,OV \u03d5, P\u03d5\u3009, where: V \u03d5 , X \u222a C, and all the nodes are given empty label, i.e., L\u03d5(v) = \u03bb for every v \u2208 V \u03d5; P\u03d5 , OV \u03d5 , X; O\u03d5 is the identity function; for every u, v \u2208 OV \u03d5 we have \u3008u \u2212 v \u2264 0, \u03bb\u3009 \u2208 A\u03d5; for every x \u2208 X and C \u2208 C we have \u3008x\u2212C \u2264 \u22121, \u03bb\u3009 \u2208 A\u03d5; for each j = 0, . . . ,m\u22121 and for each literal ` \u2208 Cj , we have \u3008Cj \u2212 C(j+1)mod m \u2264 \u22121, `\u3009 \u2208 A\u03d5. Notice that |V \u03d5| = n+m and |A\u03d5| = n2 + nm+ 3m.\n(2) Assume that \u03d5 is satisfiable. Let \u03bd be a satisfying truthassignment of \u03d5. In order to prove that N\u03d5 is not dynamicallyconsistent, observe that the restriction of N\u03d5 w.r.t. the scenario \u03bd is a non-consistent STN. Indeed, if for every j = 0, . . . ,m\u2212 1 we pick a standard arc \u3008Cj \u2212 C(j+1)mod m \u2264 \u22121, `j\u3009 with `j being a literal in Cj such that \u03bd(`j) = >, then we obtain a negative circuit.\n(3) Assume that \u03d5 is unsatisfiable. In order to prove that N\u03d5 is dynamically-consistent, we exhibit a viable and dynamic execution strategy \u03c3 for N\u03d5. First, schedule every x \u2208 X at \u03c3(x) , 0. Therefore, by time 1, the planner has full knowledge of the observed scenario \u03bd. Since \u03d5 is unsatisfiable, there exists an index j\u03bd such that \u03bd(Cj\u03bd ) = \u22a5. At this point, set \u03c3(C(j\u03bd+k)mod m) , k for k = 1, . . . ,m. The reader can verify that \u03c3 is viable and dynamic for N\u03d5.\nIt remains currently open whether CSTN-DC lies in PSPACE and whether it is PSPACE-hard.\nA. -Dynamic-Consistency\nIn CSTNs, decisions about the precise timing of actions are postponed until execution time, when informations meanwhile gathered at the observation nodes can be taken into account. However, the planner is allowed to factor in an outcome, and differentiate its strategy according to it, only strictly after the outcome has been observed (whence the strict inequality in Definition 7). Notice that this definition does not take into account the reaction time, which, in most applications, is nonnegligible. In order to deliver algorithms that can also deal with the reaction time of the planner, we employ a refined notion of dynamic-consistency.\nDefinition 13 ( -dynamic-consistency). Given any CSTN \u3008V,A,L,O,OV, P \u3009 and any real number \u2208 (0,+\u221e), an\nexecution strategy \u03c3 \u2208 S\u0393 is -dynamic if it satisfies all the H -constraints, namely, for any two scenarios s1, s2 \u2208 \u03a3P and any event u \u2208 V +s1,s2 , the execution strategy \u03c3 satisfies the following constraint, which is denoted H (s1; s2;u):\n[\u03c3(s1)]u \u2265 min ( {[\u03c3(s2)]u}\u222a{[\u03c3(s1)]v+ | v \u2208 \u2206(s1; s2)} ) We say that a CSTN \u0393 is -dynamically-consistent if it admits \u03c3 \u2208 S\u0393 which is both viable and -dynamic. The problem of checking whether a given CSTN is -dynamically-consistent is named CSTN- -DC.\nIt follows directly from Definition 13 that, whenever \u03c3 \u2208 S\u0393 satisfies some H (s1; s2;u), then \u03c3 satisfies H \u2032(s1; s2;u) for every \u2032 \u2208 (0, ] as well. This proves the following lemma.\nLemma 2. If \u0393 is -dynamically-consistent, for some > 0, then \u0393 is \u2032-dynamically-consistent for every \u2032 \u2208 (0, ].\nGiven any dynamically-consistent CSTN, we may ask for the maximum reaction time of the planner beyond which the network is no longer dynamically-consistent.\nDefinition 14 (Reaction time \u0302). Let \u0302 = \u0302(\u0393) be the greatest real number such that \u0393 is -dynamically-consistent.\nIf \u0393 is dynamically-consistent, then \u0302(\u0393) exists finite and \u0302(\u0393) > 0, as it is now proved in Lemma 3.\nLemma 3. Let \u03c3 be a dynamic execution strategy for the CSTN \u0393. Then, there exists a sufficiently small real number \u2208 (0,+\u221e) such that \u03c3 is -dynamic.\nProof: Let s1, s2 \u2208 \u03a3P be two scenarios and let us consider any event u \u2208 V +s1,s2 . Since \u03c3 is dynamic, then by Lemma 1 the following implication necessarily holds:( \u2227 v\u2208\u2206(s1;s2) [\u03c3(s1)]u \u2264 [\u03c3(s1)]v ) \u21d2 [\u03c3(s1)]u \u2265 [\u03c3(s2)]u (\u2217)\nNotice that, w.r.t. Lemma 1, we have relaxed the equality [\u03c3(s1)]u = [\u03c3(s2)]u in the implicand of (L1) by introducing the inequality [\u03c3(s1)]u \u2265 [\u03c3(s2)]u. At this point, we convert (\u2217) from implicative to disjunctive form, first by applying the rule of material implication2, and then De Morgan\u2019s law3. From this, we see that the following disjunction must hold:\n[\u03c3(s1)]u \u2265 [\u03c3(s2)]u \u2228 \u2228\nv\u2208\u2206(s1;s2)\n[\u03c3(s1)]u > [\u03c3(s1)]v (\u2217\u2217)\nThen, we argue that there exists a real number \u2208 (0,+\u221e) such that the following disjunction holds as well:\n[\u03c3(s1)]u \u2265 [\u03c3(s2)]u \u2228 \u2228\nv\u2208\u2206(s1;s2)\n[\u03c3(s1)]u \u2265 [\u03c3(s1)]v + .\nIn fact, since the disjunction (\u2217\u2217) necessarily holds, then one can define to be the minimum among all the values (s1; s2;u) \u2208 (0,+\u221e) such that for every \u3008s1, s2, u\u3009 \u2208 \u03a3P \u00d7\u03a3P \u00d7V +s1,s2 the following is satisfied: (s1; s2;u) = 1 if\n2The rule of material implication: |= p\u21d2 q \u21d0\u21d2 \u00acp \u2228 q 3De Morgan\u2019s law: |= \u00ac(p \u2227 q) \u21d0\u21d2 \u00acp \u2228 \u00acq\n[\u03c3(s1)]u \u2265 [\u03c3(s2)]u; otherwise, (s1; s2;u) = min{[\u03c3(s1)]u\u2212 [\u03c3(s1)]v | v \u2208 \u2206(s1, s2), [\u03c3(s1)]u > [\u03c3(s1)]v}.\nThis implies that \u03c3 satisfies every H -constraint of \u0393, and thus that \u03c3 is -dynamic.\nLemma 4. Let \u03c3 be an -dynamic execution strategy for the CSTN \u0393, for some \u2208 (0,+\u221e). Then, \u03c3 is dynamic.\nProof: For the sake of contradiction, let us suppose that \u03c3 is not dynamic. Let F be the non-empty set of all the triplets \u3008u, s1, s2\u3009 \u2208 V +s1,s2 \u00d7 \u03a3P \u00d7 \u03a3P , for which the implication (L1) does not hold. Then, \u3008u, s1, s2\u3009 \u2208 F if and only if the following two hold:\n1) [\u03c3(s1)]u \u2264 [\u03c3(s1)]v for every v \u2208 \u2206(s1; s2); 2) [\u03c3(s1)]u 6= [\u03c3(s2)]u.\nLet \u3008u\u0302, s\u03021\u3009 , arg min{[\u03c3(s1)]u | \u2203s2 \u3008u, s1, s2\u3009 \u2208 F} be an event whose scheduling time is minimum and for which (1) and (2) hold. Since \u3008u\u0302, s\u03021\u3009 is minimum in time, then [\u03c3(s\u03021)]u\u0302 \u2264 [\u03c3(s2)]u\u0302 for every s2 \u2208 \u03a3P such that \u3008u\u0302, s\u03021, s2\u3009 \u2208 F ; moreover, since \u3008u\u0302, s\u03021, s2\u3009 \u2208 F , then [\u03c3(s1)]u\u0302 6= [\u03c3(s2)]u\u0302 by (2), so that [\u03c3(s\u03021)]u\u0302 < [\u03c3(s2)]u\u0302. At this point, recall that \u03c3 is -dynamic by hypothesis, hence [\u03c3(s\u03021)]u\u0302 < [\u03c3(s2)]u\u0302 implies that there exists v \u2208 \u2206(s\u03021; s2) such that [\u03c3(s\u03021)]u\u0302 \u2265 [\u03c3(s\u03021)]v + > [\u03c3(s\u03021)]v , but this inequality contradicts (1). Indeed, F = \u2205 and \u03c3 is thus dynamic.\nIn Section IV, the following theorem is proved.\nTheorem 3. For any dynamically-consistent CSTN \u0393, where V is the set of events and \u03a3P is the set of scenarios, we have that \u0302(\u0393) \u2265 |\u03a3P |\u22121|V |\u22121.\nNotice that, in Definition 9, dynamic-consistency was defined by strict-inequality and equality constraints. However, by Theorem 4, dynamic-consistency can also be defined in terms of H -constraints only (i.e., no strict-inequalities are required).\nTheorem 4. Let , |\u03a3P |\u22121|V |\u22121. Then, \u0393 is dynamicallyconsistent if and only if \u0393 is -dynamically-consistent.\nBy Theorem 4, any algorithm for checking -dynamicconsistency can be used to check dynamic-consistency as well.\nB. A Singly-Exponential Time Algorithm for CSTN-DC\nIn this section, we present the first singly-exponential time algorithm for solving CSTN-DC, also producing a dynamic execution strategy whenever the input CSTN is dynamicallyconsistent. Hereafter, let us denote N0 , N \\ {0}. The main result of this paper is summarized in the following theorem, which is proven in this section.\nTheorem 5. The following two propositions hold. 1) There exists an O(|\u03a3P |2|A|2 + |\u03a3P |3|A||V ||P | + |\u03a3P |4|V |2|P |)WD time algorithm deciding CSTN- -DC on input \u3008\u0393, \u3009, for any CSTN \u0393 = \u3008V,A,L,O,OV, P \u3009 and any rational number = N/D where N,D \u2208 N0. In particular, given any -dynamically-consistent CSTN \u0393, the algorithm returns as output a viable and - dynamic execution strategy for \u0393.\n2) There exists an O(|\u03a3P |3|A|2|V | + |\u03a3P |4|A||V |2|P | + |\u03a3P |5|V |3|P |)W time algorithm for checking CSTN-DC on any input \u0393 = \u3008V,A,L,O,OV, P \u3009. In particular, given any dynamically-consistent CSTN \u0393, the algorithm returns a viable and dynamic execution strategy for \u0393.\nHere, W , maxa\u2208A |wa|.\nWe now present the reduction from CSTN-DC to HyTNConsistency.\nFirstly, we argue that any CSTN can be viewed as a succinct representation which can be expanded into an exponential sized STN. The Expansion of CSTNs is introduced below.\nDefinition 15 (Expansion \u3008V Ex\u0393 ,\u039bEx\u0393 \u3009). Let \u0393 be a CSTN \u3008V,A,L,O,OV, P \u3009. Consider the distinct STNs \u3008Vs, As\u3009, one for each scenario s \u2208 \u03a3P , defined as follows:\nVs , {vs | v \u2208 V +s } and As , {\u3008us, vs, w\u3009 | \u3008u, v, w\u3009 \u2208 A+s }.\nWe define the expansion \u3008V Ex\u0393 ,\u039bEx\u0393 \u3009 of \u0393 as follows: \u3008V Ex\u0393 ,\u039bEx\u0393 \u3009 , \u2329 \u22c3 s\u2208\u03a3P Vs, \u22c3 s\u2208\u03a3P As \u232a .\nNotice that Vs1 \u2229 Vs2 = \u2205 whenever s1 6= s2 and that \u3008V Ex\u0393 ,\u039bEx\u0393 \u3009 is an STN with at most |V Ex\u0393 | \u2264 |\u03a3P | |V | nodes and at most |\u039bEx\u0393 | \u2264 |\u03a3P | |A| standard arcs.\nWe now show that the expansion of a CSTN can be enriched with some hyperarcs in order to model -dynamic-consistency, by means of a particular HyTN which is denoted H (\u0393).\nDefinition 16 (HyTN H (\u0393)). Given any \u2208 (0,+\u221e) and any CSTN \u0393 = \u3008V,A,L,O,OV, P \u3009, a corresponding HyTN denoted by H (\u0393) can be defined as follows: \u2022 For every scenarios s1, s2 \u2208 \u03a3P and every event u \u2208 V +s1,s2 , define a hyperarc \u03b1 = \u03b1 (s1; s2;u) as follows (with the intention to model H (s1; s2;u), see Def. 13):\n\u03b1 (s1; s2;u) , \u3008t\u03b1, H\u03b1, w\u03b1\u3009,\nwhere: \u2013 t\u03b1 , us1 is the tail of the hyperarc \u03b1; \u2013 H\u03b1 , {us2} \u222a\u2206(s1; s2) is the set of the heads; \u2013 w\u03b1(us2) , 0; w\u03b1(v) , \u2212 for each v \u2208 \u2206(s1; s2).\n\u2022 Consider the expansion \u3008V Ex\u0393 ,\u039bEx\u0393 \u3009 of \u0393. Then, H (\u0393) is defined as H (\u0393) , \u3008V Ex\u0393 ,AH \u3009, where,\nAH , \u039bEx\u0393 \u222a \u22c3\ns1,s2\u2208\u03a3P u\u2208V +s1,s2\n\u03b1 (s1; s2;u).\nNotice that each \u03b1 (s1; s2;u) has size |\u03b1 (s1; s2;u)| = O(\u2206(s1; s2)) = O(|P |). In Fig. 3, Algorithm 1 presents the pseudocode for constructing H (\u0393). An excerpt of the HyTN corresponding to the CSTN of Fig. 1 is depicted in Fig. 4.\nThe following theorem establishes the connection between dynamic-consistency of CSTNs and consistency of HyTNs.\nTheorem 6. Given any CSTN \u0393 = \u3008V,A,L,O,OV, P \u3009, there exists a sufficiently small real number \u2208 (0,+\u221e) such that \u0393 is dynamically-consistent if and only if H (\u0393)\nis consistent. Moreover, H (\u0393) has at most |VH | \u2264 |\u03a3P | |V | nodes, |AH | = O(|\u03a3P | |A|+ |\u03a3P |2|V |) hyperarcs, and it has size at most mAH = O(|\u03a3P | |A|+ |\u03a3P | 2|V | |P |).\nProof: For any > 0, let H (\u0393) = \u3008V Ex\u0393 ,AH \u3009 be the HyTN of Definition 16.\n(1) Firstly, we prove that, for any > 0, H (\u0393) is consistent if and only if \u0393 is -dynamically-consistent. (\u21d2) Given any feasible scheduling \u03c6 : V Ex\u0393 \u2192 R for H (\u0393), let \u03c3\u03c6(s) \u2208 S\u0393 be the execution strategy defined as: [\u03c3\u03c6(s)]v , \u03c6(vs), for every vs \u2208 V E\u0393 , where v \u2208 V and s \u2208 \u03a3P . Notice that each hyperarc \u03b1 (s1; s2;u) is satisfied by \u03c6 if and only if the corresponding H -constraint H (s1; s2;u) is satisfied by \u03c3\u03c6; moreover, recall that \u039bEx\u0393 \u2286 AH , and that \u039bEx\u0393 contains all the original standard difference constraints of \u0393. At this point, since \u03c6 is feasible for H (\u0393), then \u03c3\u03c6 must be viable and -dynamic for \u0393. Hence, \u0393 is -dynamically-consistent.\n(\u21d0) Given any viable and -dynamic execution strategy \u03c3 \u2208 S\u0393, for some > 0, let \u03c6\u03c3 : V Ex\u0393 \u2192 R be the scheduling of H (\u0393) defined as: \u03c6\u03c3(vs) , [\u03c3(s)]v for every vs \u2208 V Ex\u0393 , where v \u2208 V and s \u2208 \u03a3P . Also in this case we have \u039bEx\u0393 \u2286 AH , and a moment\u2019s reflection reveals that each hyperarc \u03b1 (s1; s2;u) is satisfied by \u03c6\u03c3 if and only if H (s1; s2;u) is satisfied by \u03c3. At this point, since \u03c3 is viable and -dynamic for \u0393, then \u03c6\u03c3 must be feasible for H (\u0393). Hence H (\u0393) is consistent.\n(2) At this point, by composition with (1), Lemma 3 implies that there exists a sufficiently small > 0 such that \u0393 is dynamically-consistent if and only if H (\u0393) is consistent.\n(3) The size bounds follow directly from Definition 16. The pseudo-code for checking CSTN- -DC is given in Algorithm 2, whereas the pseudo-code for checking CSTNDC is provided in Algorithm 3. The latter algorithm goes as follows. Firstly, it computes a sufficiently small > 0 by resorting to Theorem 4, i.e., \u0302 = |\u03a3P |\u22121|V |\u22121 (at line 1 of Algorithm 3). Secondly, it constructs H\u0302(\u0393) (at line 1 of Algorithm 2) and then it scales every hyperarc\u2019s weight to Z (at lines 2-3). Thirdly, H\u0302(\u0393) is solved with the HyTNConsistency algorithm underlying Theorem 1 (at line 4), i.e., an instance of the HyTN-Consistency problem is solved by reduction to the decision problem for MPGs. If the HyTNConsistency algorithm outputs YES, together with a feasible scheduling \u03c6 of H\u0302(\u0393), then the time values of \u03c6 are scaled back to size w.r.t. \u0302 and then \u3008YES, \u03c6\u3009 is returned as output (lines 5-8); otherwise, the output is simply NO (at line 10).\nRemark 1. The same algorithm, with essentially the same upper bound on its running time and space, work also in case we allow for arbitrary boolean formulae as labels, rather than just conjunctions. At the same time, hyperarc constraints can also be allowed inside the input CSTNs, besides the standard arc constraints. Under this prospect, our algorithm actually solves a larger family of conditional temporal networks, that we may call Conditional Hyper Temporal Networks (CHyTNs).\nRemark 2. We remark that the HyTN/MPG algorithm that is at the heart of our approach requires integral weights (i.e., it requires that w(u, v) \u2208 Z for every (u, v) \u2208 A), and we could\nnot play it differently [7], [8]. Moreover, the algorithm always computes integral solution to HyTN/MPGs and, therefore, it always computes rational feasible schedules for the CSTNs given in input. As such, this \u201crequirement\u201c actually turns out to be a plus in practice. To conclude, it is indeed integrality that allows us to analyze the algorithm quantitatively and to present a sharp lower bounding analysis on the critical value of the reaction time \u0302, where the CSTN transits from being, to not being, dynamically consistent. We believe that these issues deserve much attention, going into them required an algorithmic discrete approach to the notion of numbers.\nNow, the correctness and the time complexity of Algorithm 3 is analyzed. To begin, notice that some of the temporal constraints introduced during the reduction step depends on a\nsufficiently small parameter > 0, whose magnitude turns out to depend on the size of the input CSTN. It is now proved that the time complexity of the algorithm depends multiplicatively on D, provided that = N/D for some N,D \u2208 N0. In Section IV we will present a sharp lower bounding analysis on \u0302, from which the (pseudo) singly-exponential time bound follows as corollary. So, assume for a moment line 1 to be valid, we prove it in Theorem 3. As a corollary of Theorem 6, we have that Algorithm 3 correctly decides CSTN-DC. The most time expensive step of the algorithm is clearly line 4 of Algorithm 2, which resorts to Theorem 1 in order to solve an instance of HyTN-Consistency. From Theorem 6 we have an upper bound on the size of H (\u0393), while Theorem 1 gives us a pseudo-polynomial upper bound for the computation time. Also, recall that we scale weights by a factor D at lines 2-3 of Algorithm 2, where = N/D for some N,D \u2208 N0. Thus, by composition, Algorithm 3 decides CSTN-DC in a time T|\u0393| which is bounded as follows, where W , maxa\u2208A |wa|:\nT|\u0393| = O((|VH (\u0393)|+ |AH (\u0393)|)mAH (\u0393))WD.\nWhence, the following holds:\nT|\u0393| = O(|\u03a3P |2|A|2 + |\u03a3P |3|A||V ||P |+ |\u03a3P |4|V |2|P |)WD.\nBy Theorem 3, it is sufficient to check -dynamicconsistency for = |\u03a3P |\u22121|V |\u22121. An O(|\u03a3P |3|V ||A|2 + |\u03a3P |4|A||V |2|P | + |\u03a3P |5|V |3|P |)W worst-case time bound follows for Algorithm 3. Since |\u03a3P | \u2264 2min(|P |,l) (where ` is the number of distinct labels that appear in \u0393), the singlyexponential time bound follows. This proves Theorem 5."}, {"heading": "IV. BOUNDING ANALYSIS ON THE REACTION TIME \u0302", "text": "In this section we present an asymptotically sharp lower bound for \u0302(\u0393), that is the critical value of reaction time where the CSTN transits from being, to not being, dynamicallyconsistent. The proof technique introduced in this analysis is applicable more in general, when dealing with linear difference constraints which include strict inequalities. Moreover, this bound implies that Algorithm 3 is a (pseudo) singlyexponential time algorithm for solving CSTN-DC. To begin, we are going to provide a proof of Theorem 3, but let us first introduce some further notation.\nLet \u0393 , \u3008V,A,L,O,OV, P \u3009 be a dynamically-consistent CSTN. By Theorem 6, there exists > 0 such that H (\u0393) is consistent. Then, let \u03c6 : V Ex\u0393 \u2192 R be a feasible scheduling for H (\u0393). For any hyperarc A = \u3008tA, HA, wA\u3009 \u2208 AH , define a standard arc aA as follows:\naA , \u3008tA, h\u0302, wA(h\u0302)\u3009, where h\u0302 , arg min h\u2208HA\n( \u03c6(h)\u2212 wA(h) ) .\nThen, notice that the network T\u03c6 (\u0393) , \u3008V Ex\u0393 , \u22c3 A\u2208AH\naA\u3009 is an STN. Moreover, \u03c6 is feasible for T\u03c6 (\u0393). At this point, assuming v \u2208 V Ex\u0393 , consider the fractional part rv of \u03c6v , i.e.,\nrv , \u03c6v \u2212 b\u03c6vc.\nThen, let R , {rv}v\u2208V Ex\u0393 be the set of all the fractional parts. Sort R by the common ordering on R and assume that S ,\n{r1, . . . , rk} is the resulting ordered set without repetitions, i.e., |S| = k, S = R, r1 < . . . < rk. Now, let pos(v) be the index position such that:\n1 \u2264 pos(v) \u2264 k and rpos(v) = rv.\nThen, we define a new fractional part as follows:\nr\u2032v , pos(v)\u2212 1 |\u03a3P ||V |\n(NFP)\nalso, we define a new scheduling function as follows:\n\u03c6\u2032v , b\u03c6vc+ r\u2032v (NSF)\nRemark 3. Notice that (NFP) doesn\u2019t alter the ordering relation among the fractional parts, i.e.,\nr\u2032u < r \u2032 v \u21d0\u21d2 ru < rv, for any u, v \u2208 V Ex\u0393 ,\nmoreover, observe that (NSF) doesn\u2019t change the value of any integral part, i.e.,\nb\u03c6\u2032uc = b\u03c6uc, for any u \u2208 V Ex\u0393 .\nWe are now in the position to prove Theorem 3. Proof of Theorem 3: Let \u0393 be dynamically-consistent, by Theorem 6 there exists \u2032 > 0 such that H \u2032(\u0393) is consistent and admits some feasible scheduling \u03c6 : V Ex\u0393 \u2192 R. Let , |\u03a3P |\u22121|V |\u22121. We argue that \u03c6\u2032, as defined in (NSF), is a feasible scheduling for the STN T\u03c6 (\u0393). Indeed, every difference constraint of T\u03c6 (\u0393) is of the form \u03c6v \u2212 \u03c6u \u2264 w, for some w \u2208 Z or w = \u2212 . Consider the case w \u2208 Z. Then,\n\u03c6\u2032v \u2212 \u03c6\u2032u \u2264 w holds because of Remark 3. Now, consider the case w = \u2212 . Then, \u03c6v \u2212 \u03c6u \u2264 \u2212 implies \u03c6v 6= \u03c6u. Hence, by Remark 3, we have \u03c6\u2032v 6= \u03c6\u2032u. At this point, observe that the difference between \u03c6\u2032u and \u03c6 \u2032 v is therefore at least , i.e.,\n\u03c6\u2032u \u2212 \u03c6\u2032v \u2265 |\u03a3P |\u22121|V |\u22121 = .\nThat is to say, \u03c6\u2032v\u2212\u03c6\u2032u \u2264 \u2212 . This proves that \u03c6\u2032 is a feasible scheduling for the STN T\u03c6 (\u0393). Since T \u03c6 (\u0393) is thus consistent, then H (\u0393) is consistent as well. Therefore, by Theorem 6, the CSTN \u0393 is -dynamically-consistent.\nAt this point, a natural question is whether the lower bound given by Theorem 3 can be improved up to \u0302(\u0393) = \u2126(|V |\u22121). In turn, this would improve the time complexity for Algorithm 3 by a factor |\u03a3P |. However, the following theorem shows that this is not the case by exhibiting a CSTN for which \u0302(\u0393) = 2\u2212\u2126(|P |). This proves that the lower bound given by Theorem 3 is (almost) asymptotically sharp.\nTheorem 7. For each n \u2208 N0 there exists a CSTN \u0393n such that \u0302(\u0393n) < 2\u2212n+1 = 2\u2212|P\nn|/3+1, where Pn is the set of boolean variables of \u0393n.\nProof: For each n \u2208 N0, define a CSTN \u0393n , \u3008V n, An, Ln,On,OV n, Pn\u3009 as follows. See Fig. 5 for a clarifying illustration. \u2022 V n , {Xi, Yi, Zi | 1 \u2264 i \u2264 n}; \u2022 An , B \u222a \u22c3n i=1 Ci \u222a \u22c3n\u22121 i=1 Di \u222a E\nwhere: \u2013 B , {\u3008X1 \u2212 v \u2264 0, \u03bb\u3009 | v \u2208 V n} \u222a {\u3008Z1 \u2212 X1 \u2264\n1, X1 \u2227 Y1\u3009}; \u2013 Ci , {\u3008Yi \u2212 Xi \u2264 2,\u00acXi\u3009, \u3008Xi \u2212 Yi \u2264 \u22122,\u00acXi\u3009, \u3008Zi\u2212Yi \u2264 2,\u00acYi\u3009, \u3008Yi\u2212Zi \u2264 \u22122,\u00acYi\u3009}; \u2013 Di , {\u3008Xi+1 \u2212 Xi \u2264 5, Zi\u3009, \u3008Xi \u2212 Xi+1 \u2264 \u22125, Zi\u3009, \u3008Xi+1 \u2212 Yi\u3009 \u2264 5,\u00acZi\u3009, \u3008Yi \u2212 Xi+1 \u2264 \u22125,\u00acZi\u3009, \u3008Zi+1 \u2212 Yi \u2264 5, Zi \u2227Xi+1 \u2227 Yi+1\u3009, \u3008Yi \u2212 Zi+1 \u2264 \u22125, Zi\u2227Xi+1\u2227Yi+1\u3009, \u3008Zi+1\u2212Zi \u2264 5,\u00acZi\u2227 Xi+1\u2227Yi+1\u3009, \u3008Zi\u2212Zi+1 \u2264 \u22125,\u00acZi\u2227Xi+1\u2227Yi+1\u3009}; \u2013 E , {\u3008Yn \u2212 Xn \u2264 2,\u00acXn\u3009, \u3008Xn \u2212 Yn \u2264 \u22122,\u00acXn\u3009, \u3008Zn \u2212 Yn \u2264 2,\u00acYn\u3009, \u3008Yn \u2212 Zn \u2264 \u22122,\u00acYn\u3009}; \u2022 Ln(v) , \u03bb for every v \u2208 V n; OV n , V n; On(v) , v for every v \u2208 OV n; Pn , V n.\nWe exhibit a viable and dynamic execution strategy \u03c3n : \u03a3Pn \u2192 \u03a6V n for \u0393n.\nLet {\u03b4i}ni=1 and {\u2206i}ni=1 be two real valued sequences s.t.:\n(1) \u22061 , 1; (2) 0 < \u03b4i < \u2206i; (3) \u2206i , min(\u03b4i\u22121,\u2206i\u22121\u2212\u03b4i\u22121).\nThen, the following also holds for every 1 \u2264 i \u2264 n:\n(4) 0 < \u2206i \u2264 2\u2212i+1,\nwhere the equality holds if and only if \u03b4i = \u2206i/2. In what follows, provided that s \u2208 \u03a3P and ` \u2208 P \u2217, we will denote 1s(`) , 1 if s(`) = > and 1s(`) , 0 if s(`) = \u22a5. We are ready to define \u03c3n(s) for any s \u2208 \u03a3P : \u2022 [\u03c3n(s)]X1 , 0;\n\u2022 [\u03c3n(s)]Y1 , \u03b411s(X1) + 21s(\u00acX1); \u2022 [\u03c3n(s)]Z1 , 1s(X1\u2227Y1) + (2 + [\u03c3n(s)]Y1)1s(\u00acX1\u2228\u00acY1); \u2022 [\u03c3n(s)]Xi , 5 + [\u03c3n(s)]Xi\u221211s(Zi\u22121) +\n+ [\u03c3n(s)]Yi\u221211s(\u00acZi\u22121), for any 2 \u2264 i \u2264 n; \u2022 [\u03c3n(s)]Yi , [\u03c3n(s)]Xi + \u03b4i1s(Xi) + 21s(\u00acXi), for any\n2 \u2264 i \u2264 n; \u2022 [\u03c3n(s)]Zi , ( 5 + [\u03c3n(s)]Yi\u221211s(Zi\u22121) +\n+ [\u03c3n(s)]Zi\u221211s(\u00acZi\u22121) ) 1s(Xi\u2227Yi) +\n+ (2 + [\u03c3n(s)]Yi)1s(\u00acXi\u2228\u00acYi), for any 2 \u2264 i \u2264 n; It is not difficult to prove, by induction on n \u2265 1, that \u03c3n is viable and dynamic for \u0393n.\nHere we show that \u0302(\u0393n) < 2\u2212n+1 = 2\u2212|P n|/3+1 for every n \u2265 1. Let us consider the following scenario s\u0302 for 1 \u2264 i \u2264 n:\ns\u0302(Xi) , s\u0302(Yi) , >; s\u0302(Zi) , { >, if \u03b4i \u2264 \u2206i/2 \u22a5, if \u03b4i > \u2206i/2 .\nWe assume that \u03c3 is an execution strategy for \u0393n and study necessary conditions to ensure that \u03c3 is viable and dynamic, provided that the observations follow scenario s\u0302. First, \u03c3 must schedule X1 at time [\u03c3(s\u0302)]X1 = 0. Then, since s\u0302(X1) = >,\nwe must have 0 < [\u03c3(s\u0302)]Y1 < 1, because of the constraint (Z1\u2212X1 \u2264 1, X1\u2227Y1). Stated otherwise, it is necessary that:\n0 < [\u03c3(s\u0302)]Y1 \u2212 [\u03c3(s\u0302)]X1 < \u22061.\nAfter that, since s\u0302(Y1) = >, then \u03c3 must schedule Z1 at time [\u03c3(s\u0302)]Z1 = 1 = \u22061. A moment\u2019s reflection reveals that almost identical necessary conditions now recur for X2, Y2, Z2, with the crucial variation that it will be necessary to require: 0 < [\u03c3(s\u0302)]Y2 < \u22062. Indeed, proceeding inductively, it will be necessary that for every 1 \u2264 i \u2264 n and every n \u2208 N0:\n0 < [\u03c3(s\u0302)]Yi \u2212 [\u03c3(s\u0302)]Xi < \u2206i.\nAs already observed in (4), we have 0 < \u2206n \u2264 2\u2212n+1. Thus, any viable and dynamic execution strategy \u03c3 for \u0393n must satisfy:\n0 < [\u03c3(s\u0302)]Yn \u2212 [\u03c3(s\u0302)]Xn < 1\n2n\u22121 =\n1\n2|Pn|/3\u22121 .\nThus, once the planner has observed the outcome s\u0302(Xn) = > from the observation event Xn, then he must react by scheduling Yn within time 2\u2212n+1 = 2\u2212|P\nn|/3+1 in the future w.r.t. [\u03c3(s\u0302)]Xn . Then \u0302(\u0393 n) < 2\u2212n+1 = 2\u2212|P n|/3+1 any n \u2265 1."}, {"heading": "V. RELATED WORKS", "text": "This section discusses of some alternative approaches offered by the current literature. Recall that the article of Tsamardinos, et al. [16] has been discussed already in the introduction. The work of Cimatti, et al. [5] provided the first sound-and-complete algorithm for checking the dynamiccontrollability of CSTNs with Uncertainty (CSTNU) and thus it can be employed for checking the dynamic-consistency of CSTNs as a special case. The algorithm reduces to the problem of solving Timed Game Automata (TGA). Nevertheless, no worst-case bound on the time complexity of the procedure was provided in [5]. We observe that solving TGAs is a problem of much higher complexity than solving MPGs, compare the following known facts: solving 1-player TGAs is PSPACEcomplete and solving 2-player TGAs is EXP-complete; on the contrary, the problem of determining MPGs lie in NP\u2229 coNP and it is currently an open problem to prove whether it lies in P. Indeed, the algorithm in [5] is not singly-exponential time bounded. Finally, a sound algorithm for checking the dynamiccontrollability of CSTNUs was given by Combi, Hunsberger, Posenato in [6]. However, it was not shown to be complete. To the best of our knowledge, it is currently open whether or not it can be extended in order to prove completeness."}, {"heading": "VI. CONCLUSION", "text": "We gave the first singly-exponential time algorithm to check the dynamic-consistency of CSTNs, also yielding dynamic execution strategies. The algorithm actually manages a few more general variants of the problem, where labels are not required to be conjunctions and hyperarc constraints can be empolyed in the input CSTNs, besides the classical binary constraints. To summarize, at the heart of the algorithm a reduction to MPGs is mediated by the HyTN model. The CSTN is dynamicallyconsistent if and only if the corresponding MPG is everywhere\nwon, and a dynamic execution strategy can be conveniently read out by an everywhere winning positional strategy. The size of this MPG is at most polynomial in the number of the possible scenarios; as such, the term at the exponent is linear, at worst, in the number of the observation events. The same holds for the running time of the resulting algorithm. In future works we would like to settle the exact computational complexity of CSTN-DC, as well as to extend our approach in order to check the dynamic-controllability of CSTN with Uncertainty [12]. Finally, an extensive experimental evaluation is on the way.\nAcknowledgment: This work was partially supported by Department of Computer Science, University of Verona, Italy under Ph.D. grant \u201cComputational Mathematics and Biology\u201c."}], "references": [{"title": "The tropical shadowvertex algorithm solves mean payoff games in polynomial time on average", "author": ["X. Allamigeon", "P. Benchimol", "S. Gaubert"], "venue": "ICALP 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part I, pages 89\u2013100,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2014}, {"title": "Using strategy improvement to stay alive", "author": ["L. Brim", "J. Chaloupka"], "venue": "Int. J. Found. Comput. Sci., 23(3):585\u2013608,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2012}, {"title": "Faster algorithms for mean-payoff games", "author": ["L. Brim", "J. Chaloupka", "L. Doyen", "R. Gentilini", "J.F. Raskin"], "venue": "Formal Methods in System Design, 38(2):97\u2013118,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Polynomial-time algorithms for energy games with special weight structures", "author": ["K. Chatterjee", "M. Henzinger", "S. Krinninger", "D. Nanongkai"], "venue": "Algorithmica, 70(3):457\u2013492,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2014}, {"title": "Sound and complete algorithms for checking the dynamic controllability of temporal networks with uncertainty, disjunction and observation", "author": ["A. Cimatti", "L. Hunsberger", "A. Micheli", "R. Posenato", "M. Roveri"], "venue": "21st Intern. Symp. on Temp. Repres. and Reasoning, TIME 2014, Verona, Italy, pages 27\u201336,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2014}, {"title": "An algorithm for checking the dynamic controllability of a conditional simple temporal network with uncertainty", "author": ["C. Combi", "L. Hunsberger", "R. Posenato"], "venue": "ICAART 2013 - Proc. of the 5th Intern. Conf. on Agents and Artif. Intell., Vol. 2, Spain, 2013, pages 144\u2013156,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2013}, {"title": "A tractable generalization of simple temporal networks and its relation to mean payoff games", "author": ["C. Comin", "R. Posenato", "R. Rizzi"], "venue": "21th International Symposium on Temporal Representation and Reasoning (TIME 2014), Verona, Italy, Sept", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "Hyper temporal networks", "author": ["C. Comin", "R. Posenato", "R. Rizzi"], "venue": "CoRR, abs/1503.03974,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2015}, {"title": "Temporal constraint networks", "author": ["R. Dechter", "I. Meiri", "J. Pearl"], "venue": "Artificial Intelligence, 49(1\u20133):61\u201395,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1991}, {"title": "Positional strategies for mean payoff games", "author": ["A. Ehrenfeucht", "J. Mycielski"], "venue": "International Journal of Game Theory, 8(2):109\u2013113,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1979}, {"title": "Automata Logics, and Infinite Games: A Guide to Current Research", "author": ["E. Gr\u00e4del", "W. Thomas", "T. Wilke", "editors"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2002}, {"title": "The dynamic controllability of conditional stns with uncertainty", "author": ["L. Hunsberger", "R. Posenato", "C. Combi"], "venue": "Proc. of the Plan. and Plan Exec. for Real-World Syst.: Princip. and Pract. (PlanEx), ICAPS-2012, page 121\u2013128, Atibaia, Sao Paulo, Brazil,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "Applying local search to disjunctive temporal problems", "author": ["M.D. Moffitt", "M.E. Pollack"], "venue": "IJCAI-05, Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence, Edinburgh, Scotland, UK, pages 242\u2013247,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2005}, {"title": "Constraint-based strategies for the disjunctive temporal problem: Some new results", "author": ["A. Oddi"], "venue": "Proceedings of the Sixth European Conference on Planning,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2014}, {"title": "Efficient solution techniques for disjunctive temporal reasoning problems", "author": ["I. Tsamardinos", "M.E. Pollack"], "venue": "Artif. Intell., 151(1-2):43\u201389,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2003}, {"title": "Ctp: A new constraint-based formalism for conditional, temporal planning", "author": ["I. Tsamardinos", "T. Vidal", "M. Pollack"], "venue": "Constraints, 8(4):365\u2013 388,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2003}, {"title": "The complexity of mean payoff games on graphs", "author": ["U. Zwick", "M. Paterson"], "venue": "Theoretical Computer Science, 158:343\u2013359,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1996}], "referenceMentions": [{"referenceID": 8, "context": "In temporal planning and temporal scheduling, Simple Temporal Networks (STNs) [9] are directed weighted graphs, where nodes represent events to be scheduled in time and arcs represent temporal distance constraints between pairs of events.", "startOffset": 78, "endOffset": 81}, {"referenceID": 6, "context": "Recently, STNs have been generalized into Hyper Temporal Networks (HyTNs) [7], [8] by considering weighted directed hypergraphs, where each hyperarc models a disjunctive temporal constraint called hyper-constraint.", "startOffset": 74, "endOffset": 77}, {"referenceID": 7, "context": "Recently, STNs have been generalized into Hyper Temporal Networks (HyTNs) [7], [8] by considering weighted directed hypergraphs, where each hyperarc models a disjunctive temporal constraint called hyper-constraint.", "startOffset": 79, "endOffset": 82}, {"referenceID": 2, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 132, "endOffset": 135}, {"referenceID": 9, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 137, "endOffset": 141}, {"referenceID": 16, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 143, "endOffset": 147}, {"referenceID": 6, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 175, "endOffset": 178}, {"referenceID": 7, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 180, "endOffset": 183}, {"referenceID": 1, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 272, "endOffset": 275}, {"referenceID": 6, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 277, "endOffset": 280}, {"referenceID": 7, "context": "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].", "startOffset": 282, "endOffset": 285}, {"referenceID": 10, "context": "Mean Payoff Games are a family of two-player infinite games played on finite graphs, well known for having theoretical interest in computational complexity, being it one of the few (natural) problems lying in NP\u2229 coNP, as well as various applications in model-checking and formal verification [11].", "startOffset": 293, "endOffset": 297}, {"referenceID": 15, "context": "We focus on Conditional Simple Temporal Problems (CSTP) [16] and on their graph-based counterpart Conditional Simple Temporal Networks (CSTN) [12], a constraint-based model for conditional temporal planning.", "startOffset": 56, "endOffset": 60}, {"referenceID": 11, "context": "We focus on Conditional Simple Temporal Problems (CSTP) [16] and on their graph-based counterpart Conditional Simple Temporal Networks (CSTN) [12], a constraint-based model for conditional temporal planning.", "startOffset": 142, "endOffset": 146}, {"referenceID": 15, "context": "Importantly, this can be achieved even while allowing for the decisions about the precise timing of actions to be postponed until execution time, in a least-commitment manner, thereby adding flexibility and making it possible to adapt the plan dynamically, during execution, in response to the observations made [16].", "startOffset": 312, "endOffset": 316}, {"referenceID": 15, "context": "Still, it is the most challenging and it was conjectured to be hard to assess by Tsamardinos, Vidal and Pollack [16].", "startOffset": 112, "endOffset": 116}, {"referenceID": 15, "context": "Indeed, the best-so-far algorithm for deciding whether a CSTN is dynamically-consistent is doubly-exponential time [16].", "startOffset": 115, "endOffset": 119}, {"referenceID": 12, "context": "However, this approach turns out to be limitative in practice: to the best of our knowledge, some experimental studies have shown that the resolution procedures, as well as the heuristics, for solving general DTPs becomes quite burdensome with \u223c 30, 35 DTP\u2019s variables [13]\u2013[15], thus dampening the practical applicability of the approach.", "startOffset": 269, "endOffset": 273}, {"referenceID": 14, "context": "However, this approach turns out to be limitative in practice: to the best of our knowledge, some experimental studies have shown that the resolution procedures, as well as the heuristics, for solving general DTPs becomes quite burdensome with \u223c 30, 35 DTP\u2019s variables [13]\u2013[15], thus dampening the practical applicability of the approach.", "startOffset": 274, "endOffset": 278}, {"referenceID": 15, "context": "The algorithm can actually be applied to a wider class of problems and it is based on representing any given instance on an exponential sized network, as first suggested in [16].", "startOffset": 173, "endOffset": 177}, {"referenceID": 6, "context": "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).", "startOffset": 108, "endOffset": 111}, {"referenceID": 7, "context": "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).", "startOffset": 113, "endOffset": 116}, {"referenceID": 0, "context": "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).", "startOffset": 317, "endOffset": 320}, {"referenceID": 1, "context": "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).", "startOffset": 322, "endOffset": 325}, {"referenceID": 3, "context": "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).", "startOffset": 327, "endOffset": 330}, {"referenceID": 7, "context": "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).", "startOffset": 332, "endOffset": 335}, {"referenceID": 11, "context": "We believe that this contributes to clarifying (with respect to previous literature [12], [16]) the role played by the reaction time \u03b5\u0302 in checking the dynamic-consistency of CSTNs.", "startOffset": 84, "endOffset": 88}, {"referenceID": 15, "context": "We believe that this contributes to clarifying (with respect to previous literature [12], [16]) the role played by the reaction time \u03b5\u0302 in checking the dynamic-consistency of CSTNs.", "startOffset": 90, "endOffset": 94}, {"referenceID": 15, "context": "Since the forthcoming definitions are mostly inherited from the literature, the reader is referred to [16] and [12] for an intuitive semantic discussion and for some clarifying examples of the very same model.", "startOffset": 102, "endOffset": 106}, {"referenceID": 11, "context": "Since the forthcoming definitions are mostly inherited from the literature, the reader is referred to [16] and [12] for an intuitive semantic discussion and for some clarifying examples of the very same model.", "startOffset": 111, "endOffset": 115}, {"referenceID": 8, "context": "The following definition recalls Simple Temporal Networks (STNs) [9], as they provide a powerful and general tool for representing conjunctions of minimum and maximum distance constraints between pairs of temporal variables.", "startOffset": 65, "endOffset": 68}, {"referenceID": 8, "context": "An STN [9] is a weighted directed graph whose nodes are events that must be placed on the real time line and whose arcs, called standard arcs, express binary constraints on the allocations of their end-points in time.", "startOffset": 7, "endOffset": 10}, {"referenceID": 11, "context": "Subsequently, those conditions have been analyzed and formalized in [12], leading to the sound notion of Conditional Simple Temporal Network (CSTN), which is now recalled.", "startOffset": 68, "endOffset": 72}, {"referenceID": 11, "context": "1The notation Con(\u00b7, \u00b7) and Sub(\u00b7, \u00b7) is inherited from [12], [16].", "startOffset": 56, "endOffset": 60}, {"referenceID": 15, "context": "1The notation Con(\u00b7, \u00b7) and Sub(\u00b7, \u00b7) is inherited from [12], [16].", "startOffset": 62, "endOffset": 66}, {"referenceID": 6, "context": "The reader is referred to [7], [8] for an in-depth treatise on HyTNs.", "startOffset": 26, "endOffset": 29}, {"referenceID": 7, "context": "The reader is referred to [7], [8] for an in-depth treatise on HyTNs.", "startOffset": 31, "endOffset": 34}, {"referenceID": 6, "context": "The converse is not true because feasible schedules for a HyTN do not need to form a convex polytope [7], [8] whereas, in general, the feasible schedules of an STN are the solutions of a linear system and, therefore, they form a convex polytope.", "startOffset": 101, "endOffset": 104}, {"referenceID": 7, "context": "The converse is not true because feasible schedules for a HyTN do not need to form a convex polytope [7], [8] whereas, in general, the feasible schedules of an STN are the solutions of a linear system and, therefore, they form a convex polytope.", "startOffset": 106, "endOffset": 109}, {"referenceID": 6, "context": "The computational equivalence between checking the consistency of HyTNs and determining the winning regions of MPGs was pointed out in [7], [8].", "startOffset": 135, "endOffset": 138}, {"referenceID": 7, "context": "The computational equivalence between checking the consistency of HyTNs and determining the winning regions of MPGs was pointed out in [7], [8].", "startOffset": 140, "endOffset": 143}, {"referenceID": 2, "context": "The tightest worst-case time complexity for solving HyTN-Consistency is expressed by the following theorem, which was proven by resorting to the Value Iteration Algorithm for MPGs [3].", "startOffset": 180, "endOffset": 183}, {"referenceID": 1, "context": "The approach was shown to be robust by experimental evaluations in [2], [8], where HyTNs of size \u223c 10 were solved within \u223c 5 sec.", "startOffset": 67, "endOffset": 70}, {"referenceID": 7, "context": "The approach was shown to be robust by experimental evaluations in [2], [8], where HyTNs of size \u223c 10 were solved within \u223c 5 sec.", "startOffset": 72, "endOffset": 75}, {"referenceID": 6, "context": "[7] The following propositions hold on HyTNs.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "not play it differently [7], [8].", "startOffset": 24, "endOffset": 27}, {"referenceID": 7, "context": "not play it differently [7], [8].", "startOffset": 29, "endOffset": 32}, {"referenceID": 9, "context": "p1 = \u22a5 C1 B1 A1 [10, 10]", "startOffset": 16, "endOffset": 24}, {"referenceID": 9, "context": "p1 = \u22a5 C1 B1 A1 [10, 10]", "startOffset": 16, "endOffset": 24}, {"referenceID": 4, "context": "2 0 [0, 5] [0, 9]", "startOffset": 4, "endOffset": 10}, {"referenceID": 8, "context": "2 0 [0, 5] [0, 9]", "startOffset": 11, "endOffset": 17}, {"referenceID": 9, "context": "[10, 10] 0", "startOffset": 0, "endOffset": 8}, {"referenceID": 9, "context": "[10, 10] 0", "startOffset": 0, "endOffset": 8}, {"referenceID": 4, "context": "[0, 5]", "startOffset": 0, "endOffset": 6}, {"referenceID": 8, "context": "[0, 9] 10", "startOffset": 0, "endOffset": 6}, {"referenceID": 1, "context": "[2],\u00acX1 [2],\u00acY1 [5], Z1 [5],\u00acZ1X2Y2", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[2],\u00acX1 [2],\u00acY1 [5], Z1 [5],\u00acZ1X2Y2", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "[2],\u00acX1 [2],\u00acY1 [5], Z1 [5],\u00acZ1X2Y2", "startOffset": 16, "endOffset": 19}, {"referenceID": 4, "context": "[2],\u00acX1 [2],\u00acY1 [5], Z1 [5],\u00acZ1X2Y2", "startOffset": 24, "endOffset": 27}, {"referenceID": 4, "context": "[5],\u00acZ1 [5], Z1X2Y2", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5],\u00acZ1 [5], Z1X2Y2", "startOffset": 8, "endOffset": 11}, {"referenceID": 1, "context": "[2],\u00acX2 [2],\u00acY2", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[2],\u00acX2 [2],\u00acY2", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "[5],\u00acZ2 [5], Z2X3Y3 [5], Z2 [5],\u00acZ2X3Y3", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5],\u00acZ2 [5], Z2X3Y3 [5], Z2 [5],\u00acZ2X3Y3", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "[5],\u00acZ2 [5], Z2X3Y3 [5], Z2 [5],\u00acZ2X3Y3", "startOffset": 20, "endOffset": 23}, {"referenceID": 4, "context": "[5],\u00acZ2 [5], Z2X3Y3 [5], Z2 [5],\u00acZ2X3Y3", "startOffset": 28, "endOffset": 31}, {"referenceID": 1, "context": "[2],\u00acXn [2],\u00acYn [5], Zn\u22121 [5],\u00acZn\u22121XnYn [5],\u00acZn\u22121 [5], Zn\u22121XnYn", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[2],\u00acXn [2],\u00acYn [5], Zn\u22121 [5],\u00acZn\u22121XnYn [5],\u00acZn\u22121 [5], Zn\u22121XnYn", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "[2],\u00acXn [2],\u00acYn [5], Zn\u22121 [5],\u00acZn\u22121XnYn [5],\u00acZn\u22121 [5], Zn\u22121XnYn", "startOffset": 16, "endOffset": 19}, {"referenceID": 4, "context": "[2],\u00acXn [2],\u00acYn [5], Zn\u22121 [5],\u00acZn\u22121XnYn [5],\u00acZn\u22121 [5], Zn\u22121XnYn", "startOffset": 26, "endOffset": 29}, {"referenceID": 4, "context": "[2],\u00acXn [2],\u00acYn [5], Zn\u22121 [5],\u00acZn\u22121XnYn [5],\u00acZn\u22121 [5], Zn\u22121XnYn", "startOffset": 40, "endOffset": 43}, {"referenceID": 4, "context": "[2],\u00acXn [2],\u00acYn [5], Zn\u22121 [5],\u00acZn\u22121XnYn [5],\u00acZn\u22121 [5], Zn\u22121XnYn", "startOffset": 50, "endOffset": 53}, {"referenceID": 15, "context": "[16] has been discussed already in the introduction.", "startOffset": 0, "endOffset": 4}, {"referenceID": 4, "context": "[5] provided the first sound-and-complete algorithm for checking the dynamiccontrollability of CSTNs with Uncertainty (CSTNU) and thus it can be employed for checking the dynamic-consistency of CSTNs as a special case.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "Nevertheless, no worst-case bound on the time complexity of the procedure was provided in [5].", "startOffset": 90, "endOffset": 93}, {"referenceID": 4, "context": "Indeed, the algorithm in [5] is not singly-exponential time bounded.", "startOffset": 25, "endOffset": 28}, {"referenceID": 5, "context": "Finally, a sound algorithm for checking the dynamiccontrollability of CSTNUs was given by Combi, Hunsberger, Posenato in [6].", "startOffset": 121, "endOffset": 124}, {"referenceID": 11, "context": "In future works we would like to settle the exact computational complexity of CSTN-DC, as well as to extend our approach in order to check the dynamic-controllability of CSTN with Uncertainty [12].", "startOffset": 192, "endOffset": 196}], "year": 2015, "abstractText": "Conditional Simple Temporal Network (CSTN) is a constraint-based graph-formalism for conditional temporal planning. It offers a more flexible formalism than the equivalent CSTP model of Tsamardinos, Vidal and Pollack, from which it was derived mainly as a sound formalization. Three notions of consistency arise for CSTNs and CSTPs: weak, strong, and dynamic. Dynamic consistency is the most interesting notion, but it is also the most challenging and it was conjectured to be hard to assess. Tsamardinos, Vidal and Pollack gave a doubly-exponential time algorithm for deciding whether a CSTN is dynamicallyconsistent and to produce, in the positive case, a dynamic execution strategy of exponential size. In the present work we offer a proof that deciding whether a CSTN is dynamicallyconsistent is coNP-hard and provide the first singly-exponential time algorithm for this problem, also producing a dynamic execution strategy whenever the input CSTN is dynamically-consistent. The algorithm is based on a novel connection with Mean Payoff Games, a family of two-player infinite games played on finite graphs, well known for having applications in model-checking and formal verification. The presentation of such connection is mediated by the Hyper Temporal Network model, a tractable generalization of Simple Temporal Networks whose consistency checking is equivalent to determining Mean Payoff Games. In order to analyze the algorithm we introduce a refined notion of dynamic-consistency, named -dynamic-consistency, and present a sharp lower bounding analysis on the critical value of the reaction time \u03b5\u0302 where the CSTN transits from being, to not being, dynamically-consistent. The proof technique introduced in this analysis of \u03b5\u0302 is applicable more generally when dealing with linear difference constraints which include strict inequalities.", "creator": "LaTeX with hyperref package"}}}