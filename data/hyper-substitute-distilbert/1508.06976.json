{"id": "1508.06976", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Aug-2015", "title": "Real-time Top-K Predictive Query Processing over Event Streams", "abstract": "research paper addresses the problem of predicting faster react variables that constituted rather likely to occur next, over less real - distant event streams. competing models to causal prediction initially imply a number of choices. ultimately, they spontaneously evolve across his interacting causal interface to simulate the most likely incident effect events ; however, data from several historical streams frequently reflect inverse causality. second, algorithms contain conservative assumptions intended to conceal all identifiable non - causal links in the causal network ; avoiding default to arbitrary omission below most less - likelihood outcomes important causal link. we determine these limitations following attempting a novel event precedence model : specific run - line causal inference mechanism. the event precedence model assigns a first order absorbing markov chain incrementally assessing event streams, where prior insertion between two components signifies a temporal precedence relationship for individuals, which is a necessary condition below causality. then, the run - time path inference mechanism learns causal relationships dynamically during query intervals. feedback is supported by presenting some of the concurrent stability models whereby don't exhibit shifts in stationary presence versus weakly stationary near general last consideration model. this aspect contrasts two query processing algorithms - - one involving exhaustive shopping on stationary model and the other performs near more consistently reduced extraction with corresponding information. experiments combining two coupled datasets ( cascading blackouts in power compression replacing web privacy views ) verify the sensitivity of relatively probabilistic top - over sampling solution and the progress of the algorithms. specifically, the reduced resource costs lowers runtime, relative less exhaustive search, perhaps 25 - 85 % ( depending on method application ) offering rather a small reduction in accuracy.", "histories": [["v1", "Wed, 26 Aug 2015 15:02:09 GMT  (819kb)", "http://arxiv.org/abs/1508.06976v1", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["saurav acharya", "byung suk lee", "paul hines"], "accepted": false, "id": "1508.06976"}, "pdf": {"name": "1508.06976.pdf", "metadata": {"source": "CRF", "title": "Real-time Top-K Predictive Query Processing over Event Streams", "authors": ["Saurav Acharya", "Byung Suk Lee", "Paul Hines"], "emails": ["phines}@uvm.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 8.\n06 97\n6v 1\n[ cs\n.D B\n] 2\nKeywords: top-k query; event stream; causal network; prediction."}, {"heading": "1 Introduction", "text": "Causal prediction (e.g. [14, 15, 39]) is emerging as an essential field for real-time monitoring, planning and decision support in diverse applications such as stock market analysis, electric power grid monitoring, sensor network monitoring, network intrusion detection, and web click-stream analysis. There is a need for active systems to continuously monitor the event streams from these applications to allow for the prediction of future effect events in real time. Specifically, given a sequence of potentially causal events, many applications would benefit from good algorithms to predict the next most likely (namely, top k) effect events. The potentially huge answer space, however, and the unknown dynamics as well as the streaming nature of data make such top-k prediction a challenging task.\nConsider the following two scenarios as motivating examples.\nExample 1 Web page click stream: Consider web-based online systems. A majority of them display the same content for everyone. However, the user experience can be more productive with a dynamic system where content is displayed based on real-time prediction of users\u2019 most likely activities, given historical data. One can use the results (i.e., the web pages/links most likely to be visited next) to display the most relevant links, content, and advertisements at each step of the user activity. Such an arrangement may help to retain the user longer by displaying the most relevant information, thereby increasing the content consumption (e.g., sales, page visits, ad clicks).\nExample 2 Electric power grid: Consider an electric power grid. When components of a power grid fail, as a result of a storm, malfunction or cyber-attack, a cascading sequence of subsequent component failures may result, which may lead to a very large blackouts (e.g., [43]). Thus, a timely prediction of the components that are most likely to fail next, given a list of a few components that have failed, may enable operators to take mitigating actions (like shutting down sections of the power grid) before a large-scale blackout occurs. Cascading blackouts typically progress slowly (minutes to tens of minutes) in the initial stages; a few seconds delay to compute and implement emergency controls is generally sufficient.\nIn this paper, we address the challenge of continuous prediction of the top-k most probable next effects in real time streams. To the best of our knowledge, there are no existing top-k query processing mechanisms that are sufficiently efficient to support time-critical applications, such as Examples 1 and 2. Moreover, most previous work on the prediction of effect events given one or more cause events is based on inefficient exhaustive search over a large search space of causal\nnetwork (e.g., [2, 46]). A causal network represents the cause and effect relationships, called causality, in a directed acyclic graph. This traditional causal network model (e.g., [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction. First, since it is acyclic, it cannot have loops, such as A \u2192 B \u2192 C \u2192 A or bidirectional relationships such as A \u2194 B, and consequently, does not support cyclic causality (e.g., [13, 34]). The event streams from many applications, however, do show cyclic relationships. For example, a visitor to a news web site may visit the home page, proceed to read an article, and then return to the home page, creating a cyclic relationship between these vertices in the graph. Second, the causal Markov condition, often considered an essential property of traditional causal networks, is conservative in the causal inference, and as a result removes many infrequent but important causal relationships from the causal network [31, 32, 34, 40]. That is, the causal Markov condition calls for the removal of those relationships which could potentially be independent in the presence of one or more events. The rationale for this is to avoid any suspicious and weak relationships. However, this approach often backfires by removing rare but important causal relationships [34]. We call this limitation the causal information loss.\nBased on these facts, we identify three central research problems \u2013 (1) how to model causal relationships among events in a stream to prevent causal information loss; (2) how to address cyclic causality in the causal model; (3) how to efficiently run a causal inference query on this causal model to continuously predict the top-k probable effects.\nTo address these problems, first, we propose an event precedence model that captures temporal precedence relationship between every two event types into a first order absorbing Markov chain. We refer to the resulting model as an event precedence network (EPN), in which an edge signifies the temporal relationship between two events. This inclusion of all temporal precedence \u2013 hence likely causal \u2013 relationships helps to avoid causal information loss. Note that EPN is a generative model of the observed event stream, which is built over a set of predefined event types instead of event instances. Second, we propose a run-time causal inference method. Due to cyclic causality, causal inference cannot be performed until the cause event whose effects are being predicted is known, but a cause event is only observed at run time, hence run-time causal inference. EPN encodes all cyclic as well as non-cyclic precedence relationships from event streams on its edges, and therefore these edges are examined by run-time causal test (i.e., conditional independence test) to determine causality. Note that this run-time causal inference overcomes the two limitations of traditional causal model discussed earlier (i.e., lack of support for cyclic causality and loss of many important causal relationships). Third, we present two query processing algorithms \u2013 the Exhaus-\ntive Search (ES) algorithm and the Reduced Search Early Termination (RSET) algorithm \u2013 to continuously predict top-k event types with the highest scores based on the inferred causal relationships. The ES algorithm formalizes the exhaustive search approach. The RSET algorithm is built upon the ES algorithm, and reduces the search space with possible early termination. As a result, it reduces the runtime with only marginal reduction in prediction accuracy.\nWe conduct experiments to evaluate the performance of the proposed ES and RSET algorithms using two real datasets. For each dataset we perform two sets of experiments to evaluate their accuracies and runtimes, respectively. In each evaluation, there are two objectives. The first objective is to compare the run-time causal inference mechanism of the proposed algorithms (i.e., ES, RSET) against the stateof-the-art traditional causal inference mechanism called the Fast Causal Network Inference (FCNI) algorithm [1]. The FCNI algorithm is essentially inapplicable to our problem due to its lack of ability to handle cyclic causality and run-time causal inference, but is the best available in the state of the art. The second objective is to compare the query processing mechanisms between the ES algorithm and the RSET algorithm.\nThe contributions of this paper are summarized as follows.\n1. It presents an event precedence model to represent the temporal precedence relationships between event types and proposes an algorithm to construct an event precedence network incrementally over event streams.\n2. It introduces a run-time causal inference mechanism to infer the causal relationships in real time, and proposes two query processing algorithms: Exhaustive Search and Reduced Search Early Termination, to continuously predict the top-k next effects over event streams.\n3. It empirically demonstrates the advantages of the proposed run-time causal inference mechanism and the query processing algorithms in terms of the prediction accuracy and the runtime.\nThe remainder of the paper is organized as follows. Section 2 discusses the related work, and Section 3 presents some preliminary concepts. Sections 4 and 5 describe the event precedence model and the query processing model, respectively. Section 6 evaluates the proposed query processing algorithms. Section 7 concludes the paper and suggests future work."}, {"heading": "2 Related Work", "text": "This section first discusses conventional causal inference techniques and then describes how this paper makes unique contributions relative to other work related to\ncausal prediction. There are two approaches for constructing a traditional causal network. The first approach, search and score based (e.g., [10, 17, 24, 28]), performs greedy search (usually hill climbing) over all possible causal networks of the data to select the network with the highest score. This approach, however, has two limitations. First, the computational complexity increases exponentially as the number of variables in the causal network increases. Second, the problem of equivalence classes [8], where two or more network structures represent the same probability distribution, makes the causal direction between nodes quite random and therefore unreliable. The second approach, constraint-based (e.g., [7, 33, 39, 40]), which performs a large number of conditional independence tests between variables to construct a causal network, does not have the problem of equivalence classes. The state-of-the-art Fast Causal Network Inference (FCNI) algorithm [1] presents a traditional constraint-based causal network inference mechanism over event streams. (Thus, we consider the FCNI algorithm as the representative of the traditional causal network approach in this paper.) The FCNI algorithm learns temporal precedence relationships from the event stream and performs causal inference between only those event types which exhibit temporal precedence relationship. Such an approach helps to reduce the number of conditional independence tests required for causal network inference. However, this algorithm assumes acyclic causality in the data. (The idea of temporal precedence-based conditional independence test has been incorporated in the work presented in this paper.)\nIn addition, there has been some work (e.g., [11, 22, 41]) to support cyclic Bayesian network which aims to handle the cyclic causality in Bayesian networks. This work, however, still carries the drawbacks inherent in the Bayesian network approach \u2013 that is, the ambiguity of equivalence classes and the inability to meet the requirement of a causal network that the parent node in the network should always represent the direct cause \u2013 and hence is not useful in our work.\nThe existing body of work on prediction only addresses inference of the likelihood of occurrence of an effect variable given a cause variable (e.g., [5, 6, 26, 30, 37, 47]), while the prediction of top-k effects requires finding the most likely k effects among all possible effect variables. Therefore, the only way to find the top-k next effects is to construct a traditional causal network, which ignores cyclic causality and suffers from causal information loss, over event streams and then infer the top-k effects of the cause exhaustively(e.g., [2, 19, 46]). To the best of our knowledge, there is no solution to address cyclic causality, mitigate the causal information loss, and perform only necessary partial search to find the top-k effects of the given causes over event streams.\nThe well-established association rule mining algorithms (e.g., [20, 35, 44]) are extensively used for prediction and recommendation. However, association does\nnot necessarily imply causation (e.g., [4, 25, 27, 29, 38, 45]). Therefore, they are not useful to our problem due to the exclusion of the fundamental concept of causality. That is, two variables that are associated require stronger conditions, such as temporality and strength, to be considered causally related. A few works on top-k query processing in the Internet domain, such as over social-tagging networks [16] and over web 2.0 stream [36], have been published. Unlike our work, however, these works do not address causal prediction in an event-based environment at all."}, {"heading": "3 Preliminaries", "text": "In this section, we introduce the concepts that are central to the techniques explained in the paper."}, {"heading": "3.1 Event Streams", "text": "An event stream is a discrete, indefinitely long sequence of event instances. An event instance (or event) refers to a timestamped action which may have an effect. A prototype for creating events is called an event type. Each event instance is created by one event owner. An event type can have many instances, and an event owner can create many instances of any type. Two events are related to each other if they share common attributes such as event owner, location, and time. These attributes are called common relational attributes (CRAs). In Example 1 and Example 2, the CRAs are the session id and the blackout id, respectively .\nAn event has the following schema: \u3008timestamp, type, CRA, attribute-set\u3009. That is, an event has the timestamp at which it was created, the event type it belongs to, the CRA value, and a set of additional attributes called the attribute-set. An event is denoted as eij where i is the value of the CRA and j (=1, 2, 3, ...) is its event type id (Ej).\nExample 3 Figure 1 shows an illustrative example of events in a user click event stream of Example 1. The first field in each line (e.g., e21) denotes the actual event instance shown in the remainder of the line (e.g., \u3008 05/05/11 1:12 pm, 1, 2, [200s, ...]\u3009). The session id serves as the CRA and the webpage categories (e.g., frontpage, news, weather, sports, entertainment, tech, local, etc) are the event types. For instance, in the event instance e32, 2 is the event type and 3 is the CRA. Note that the event type is represented by a numerical equivalent of the original event type (e.g., frontpage = E1, news = E2, weather = E3, sports = E4, entertainment = E5, tech = E6, local = E7).\nWe use a window, specifically called partitioned window [1], to accumulate the events from the stream for a user-specified observation period T. As a preprocessing step to group related events in the window, these events are partitioned by the CRA and then arranged in temporal order in each partition. Figure 2 shows what a partitioned window looks like for the event stream shown in Figure 1. Once the observation period expires, the window shifts to the next batch of events. The last event of one window overlaps the first event of the next window in order to ensure consistency in event precedence modeling across two consecutive windows.\nDefinition 1 (Partition) A partition Wi in a partitioned window is defined as a set of observed events sharing the same CRA value i and arranged in the temporal order over a time period T , that is\nWi = {eij(t)|t \u2264 T, i \u2208 A, j \u2208 [1, N ]}\nwhere t is the timestamp, A is the set of all possible CRA values, j is the event type id, and N is the number of event types.\nThe events which are being predicted are effect events while the events which are used for prediction are cause events. We denote the cause event type and the effect event type as Ci \u2208 E and Tj \u2208 E, respectively, where i and j are the positions of the events in each sequence. Note that Ci and Ei are not necessarily the same, and nor are Tj and Ej . Table 1 summarizes the key notations used in this paper."}, {"heading": "3.2 Causal Networks", "text": "A causal network (or causal Bayesian network) is a directed acyclic graph G = (V, \u039e) to encode causality, where V is the set of nodes (representing event types) and \u039e is the set of edges between nodes. For each directed edge, the parent node denotes the cause, and the child node denotes the effect.\nThe joint probability distribution of a set of N event types E \u2261 {E1, ..., EN} in a causal network is specified as\nP (E) = N \u220f\ni=1\nP (Ei|Pai)\nwhere Pai is the set of the parent nodes of event type Ei. Consider the event stream of Figure 2. The causal relationships among the event types in the stream may be modeled as a causal network like the one shown in Figure 3."}, {"heading": "3.3 Conditional Independence Tests", "text": "A popular approach for testing the conditional independence (CI) between two random variables X and Y in a set of random variables, C, is conditional mutual information (CMI) (e.g., [7, 9]).\nCMI(X,Y |C) = \u2211\nx\u2208X\n\u2211\ny\u2208Y\n\u2211\nc\u2208C\nP (x, y, c)log2 P (x, y|c)\nP (x|c)P (y|c)\nwhere P is the probability mass function calculated from the frequencies of variables. CMI gives the strength of dependency between variables in a measurable quantity, which helps to identify the weak (or spurious) causal relationships.\nIn the traditional CMI, two variables X and Y are said to be independent if CMI(X,Y |C) = 0, and dependent otherwise. This criterion itself offers no distinction between weak and strong dependencies. With a higher value of CMI(X,Y |C), the dependency between X and Y should be considered stronger. Thus, to prune out weak dependencies, we need a threshold CMI value, below which we consider\nthe evidence \u201ctoo weak\u201d. To do so, we relate CMI with the G2 test statistics [3, 39] as below.\nG2(X,Y |C) = 2 \u00b7Ns \u00b7 loge2 \u00b7 CMI(X,Y |C)\nwhere Ns is the number of samples (i.e., event instances). Under the independence assumption, G2 follows the \u03c72 distribution [23] with the degree of freedom df equal to (nx \u2212 1)(ny \u2212 1) \u220f\ns\u2208S ns, where nx, ny, and ns are the number of possible distinct values of X, Y, and S, respectively. So, we perform the test of independence between X and Y given C by using the calculated G2 test statistics as the \u03c72 test statistics in a \u03c72 test, which provides the threshold based on df and significance level \u03b1, to validate the result. We set \u03b1 as the generally accepted value of 95%.\nWe define a Boolean function IsIndependent(X,Y,C) to test the conditional independence between two variables X and Y given a condition set of variables C using the G2 test statistics. It returns true if these two variables are conditionally independent; otherwise, it returns false.\nThe unbounded and continuous nature of event streams of interest makes it infeasible to store all of the historical data. Therefore, we use an incremental approach such that when a new batch of events is processed, we only update the record of the frequency of observations without storing the old events."}, {"heading": "4 Event Precedence Model", "text": "In this section, we introduce the proposed incremental mechanism to model the precedence relationships between events in a network structure."}, {"heading": "4.1 Model", "text": "To overcome the limitations of the existing causal models described in Section 1, we propose the event precedence model (EPM). It represents the temporal precedence relationships in a first order absorbing Markov chain, called event precedence network (EPN), over which further analysis is done to predict the probable effect events based on the observed cause events. Note that the temporal precedence is a required criterion of a causal relationship. To avoid any information loss, evidence of the precedence between every two events in the stream is preserved. EPM takes the partitioned window (collected from the event stream) as an input and incrementally builds a model to reflect all precedence relationships in the input data. The actual data is discarded once a new batch of events arrives. Such an adaptive approach is essential for a streaming environment with continuous and unbounded data.\nWe make the following assumptions in the event precedence model.\n\u2022 Given an ordered sequence of cause event types {C0, C1, ...., C\u03b4}, an instance of the effect event type T0 cannot occur without the occurrence of an instance of the most recent cause event type C\u03b4. Moreover, while all past events influence the future events, the strongest influence is exerted by the immediately preceding event of the effect event. With this in mind, the precedence relationships only between every two consecutive events are considered.\n\u2022 There cannot be a causal relationship between events of the same type and, therefore, such precedence relationships are ignored.\n\u2022 The cause and effect events should share the same CRA value. As described in Section 3.1, the events are grouped into partitions based on their CRA values (e.g., session id and blackout id in Examples 1 and 2, respectively). In other words, two events are not related to each other if they have different CRA values.\nThe proposed EPM is a first order absorbing Markov chain [21] where an observation is independent of all previous observations except the most recent one and every state can reach an absorbing (a.k.a., terminating) state. Thus, the probability of occurrence of an effect event given past cause events is given as follows.\nP (T0|C0, C1, ..., C\u03b4) = P (T0|C\u03b4).\nP (T0|C\u03b4) can be rewritten as below.\nP (T0|C\u03b4) = P (T0, C\u03b4)\nP (C\u03b4)\nwhich, then, can be estimated as\nP (T0|C\u03b4) = f(T0, C\u03b4) \u2211\nEj\u2208children(C\u03b4) f(Ej, C\u03b4)\n(1)\nwhere f(Ei, Ej) denotes the number of observations in which instances of the type Ei precedes instances of the type Ej .\nIn summary, EPM allows us to automatically build a tractable probabilistic graphical model from the events, discovering the existing dependencies among the event types in the event stream. These dependencies are represented by a graph, as illustrated in Figure 4, where the conditional probabilities are stored at the node level."}, {"heading": "4.2 Algorithm", "text": "Algorithm 1 outlines the event precedence network construction algorithm. It has three steps: observation, graph generation, and evidence inscription. These steps are discussed below.\n1. Observation : This step observes adjacent neighbor events in each partition of the window to learn the precedence relationships and update the frequency matrix f . Note that, based on the assumptions stated earlier, the precedence relationships should be between events in the same partition and between events of different types. Suppose Ei and Ej are the event types of two adjacent events. Then, their count f(Ei, Ej) is increased by 1. Additionally, note that the frequency matrix f is updated incrementally for each new partition of events.\n2. Graph Generation : This step starts with an edgeless graph G = (V,\u039e) where V is the set of nodes (event types) and \u039e is an empty set of edges. Then, for any evidence of the precedence relationship between event types Ei and Ej (i.e., f(Ei, Ej) > 0), an edge is added between the two nodes representing these event types. Note that the graph supports anti-parallel edges between nodes; in addition, a cyclic loop of edges is also supported. Thus, the graphical model offers the flexibility to incorporate all possible types of relationships, unlike in the traditional systems where only directed edges are supported.\nIn addition, for every edge added in the graph, the probability of an event\nAlgorithm 1 Event Precedence Model\nRequire: A partitioned window P for a batch of new events. Observation:\n1: for each partition Wk \u2208 P where k is the CRA value do 2: for each pair of consecutive events (of type Ei and Ej such that i 6= j) in Wk do 3: f(Ei, Ej)++ i.e., increase the observed frequency by 1; 4: end for 5: end for\nGraph Generation: 6: Construct an edgeless network G = (V,\u039e); 7: for each pair of event types, Ei and Ej such that i 6= j, do 8: if f(Ei, Ej) > 0 then 9: \u039e \u2190 {\u039e \u222a {Ei \u2192 Ej}} i.e., add an edge Ei \u2192 Ej ;\n10: P (Ej |Ei) \u2190 f(Ei,Ej)\u2211\nEk\u2208children(Ei) f(Ei,Ek)\n;\n11: else 12: P (Ej |Ei) \u2190 0; 13: end if 14: if f(Ej, Ei) > 0 then 15: \u039e \u2190 {\u039e \u222a {Ej \u2190 Ei}} i.e., add an edge Ej \u2192 Ei; 16: P (Ei|Ej) \u2190 f(Ej ,Ei)\u2211\nEk\u2208children(Ej ) f(Ej ,Ek)\n;\n17: else 18: P (Ei|Ej) \u2190 0; 19: end if 20: end for\ntype given its parent event type is calculated using Equation 1. The calculated probabilities are then stored in the nodes.\nThe running time complexity of the algorithm is polynomial with the total number of events that have arrived thus far and the number of event types. The observation step counts every pair of consecutive events in every partition of the window. Clearly, for each partition, the number of the counts is always one less than the number of events in it. If Ne and Np are the number of events and the number of partitions, respectively, then the running time complexity is given as O ( \u2211Np\ni=1(Nei \u2212 1) ) \u2248 O ( Ne )\n, where Nei is the number of events in the i-th partition. The graph generation phase checks for the evidence of the precedence relationships between every pair of event types. In the worst case, the event prece-\ndence network is completely connected (including cyclic edges and self referencing edges) and has N2 edges. So, the running time complexity of this step is proportional to N(N \u2212 1) or O ( N2 ) . Hence, the total running time is given as O ( Ne )\n+ O ( N2 ) = O ( Ne +N 2 ) ."}, {"heading": "5 Top-K Predictive Query Processing", "text": "In this section, we first describe the predictive query processing model and its run-time causality test and then present the two top-k continuous predictive query processing algorithms \u2013 Exhaustive Search (ES) algorithm and the more efficient Reduced Search Early Termination (RSET) algorithm."}, {"heading": "5.1 Predictive Query Processing Model", "text": "The predictive query processing problem can be formulated as a search problem to find the possible effects of a given set of observed events in a causal network. However, the traditional causal network cannot be used for query processing due to the causal information loss and its lack of support for cyclic causality. To address this issue, since we already know that every causal relationship is always a temporal precedence relationship, we propose to infer causality during query processing from the event precedence network to determine the possible effects.\nIn our work, the predictive query is a standing continuous query, so the ranked result list may change every time a new event is observed. The idea is to explore the event precedence network (EPN), which represents all the precedence relationships (including cyclic precedence relationships) among the event types, to answer the predictive queries when evidence is available. Indeed, the effect events are always the descendants of the cause events. Therefore, an outward breadth first search on the EPN is required to find the effect events. In situations where a visited node is encountered again, as EPN is cyclic, we ignore it. As discussed in Section 4, the next effect events cannot occur without the existence of the most recent cause event. Therefore, the starting point for exploring the EPN is always the event type C\u03b4 of the most recent cause event. We call this event type the effect observation point (EOP). For instance, in Figure 4, consider the two event types E3 and E4. E3 is the effect of E4 when E4 is the EOP whereas E4 is the effect of E3 when E3 is the EOP, as illustrated in Figure 5.\nHowever, there are two issues which make EPN not directly usable to answer a predictive query. First, a precedence relationship is not necessarily a causal relationship. So, we have to remove from the precedence relationships those that are not causal. Second, two variables may have causal relationship in the absence\nof other variables, but may not exhibit causality in the presence of certain condition variables. For example, rain and wet ground are dependent variables, as rain causes wet ground. However, they are independent in the presence of a roof over the ground (which is a conditional variable), as rain does not cause wet ground, given the existence of a roof. Therefore, we test causal relationships to resolve these issues during query processing for finding possible effects. To determine causality, the conditional independence tests, as described in Section 3.3, are performed between two event types with an edge in the EPN.\nThe ranking score of the predicted effect event type Ei is calculated as P (Ei|C\u03b4) given its EOP C\u03b4. An EPN node stores the conditional probability of every child node given the current node as the parent node. Scores across a chain of event types, Eg \u2192 Ep \u2192 Ei (where Ep is a parent of Ei and Eg is a parent of Ep), in EPN is calculated using the multiplicative property of conditional probability P (Ei|Eg) = P (Ei|Ep) \u00b7 P (Ep|Eg)."}, {"heading": "5.2 Exhaustive Search Algorithm", "text": ""}, {"heading": "5.2.1 Approach", "text": "The most straightforward solution to the top-k prediction problem is to search for all possible effects exhaustively during the run-time causal inference over EPN and then sort them, according to their scores, in non-increasing order to determine the k effects with the top scores. We call this solution the Exhaustive Search (ES) approach.\nThe ES approach should have a robust strategy for exploring the EPN to infer effects. As discussed earlier, an outward breadth first search may be run over the EPN for run-time causal inference. However, the score calculation of the effects is not straight-forward. To apply multiplicative property of conditional probability described in Section 5.1, the scores of the parents of an event type should be known before its score is calculated, which is not always possible as demonstrated in Figure 6. Therefore, we define a search order, called causal search order, before\nexploring the EPN for run-time causal inference.\nDefinition 2 (Causal Search Order). The causal search order O is an ordered set of event types {S1, S2, ...., SN} observed during the outward breadth first search of the EPN such that Si+j is never an ancestor of Si, where j > 0 and i+ j \u2264 N .\nIn addition to guiding the search for possible effects, the causal search order provides us with an effective strategy to calculate the ranking score. It gives an order of the event types such that the probabilities of parents are always known before calculating the probabilities of their children.\nExample 4 Let us illustrate the causal search order considering the EPN shown in Figure 4. As described earlier, we run outward breadth first search in EPN from the EOP. Suppose E3 is the EOP. Initially, E3 is added to O and is explored. Then, the children of E3 are added, so O becomes {E3, E1, E4, E5}. Then, since E3 has already been explored, the next unexplored node in O, E1, is explored. However, no new nodes are added to O as E1 has no child. Then, we consider the next unexplored node (E4) in O. Similar to E1, no new nodes are added to O as E4 has no child. Now, the only remaining unexplored node in O is E5. So, the children of E5 are added to O, which then becomes {E3, E1, E4, E5, E6, E7}. The recently added unexplored nodes E6 and E7 do not have any children and, therefore, no new nodes are added to O. So, the final causal search order O is {E3, E1, E4, E5, E6, E7}. These steps are shown in Figure 7(a). Similarly, when EOP is E5, the causal search order O may be determined to be {E5, E7, E6, E3, E1, E4}, as shown in Figure 7(b)."}, {"heading": "5.2.2 Algorithm", "text": "Algorithm 2 outlines the ES algorithm. It has a two-pass strategy for exploring EPN to infer effects. In the first pass, breadth-first search is run over the EPN to determine causal search order. In the second pass, EPN is explored with this search order for run-time causal inference. The input to the algorithm is the size of the result k, the event precedence network G, and the set of the recently observed \u03b4 cause event types arranged in temporal order {C1, C2, ...., C\u03b4}. The four main steps of the algorithm are given as follows.\n1. First, an outward breadth first search over G from EOP (the most recent cause event type C\u03b4) is run to determine the causal search order O. Line 1 shows this step.\n2. Second, the marginal independence tests are performed between the event\ntypes during the search to remove any weak relationships (lines 2-7). (A marginal independence test disregards the effect of other event types; in other words, it is equivalent to a conditional independence test with an empty condition set.)\n3. Third, G is searched to find the effects of every unexplored node Ej based on the ordering of the event types in O. Lines 8 - 19 shows this step. The CI tests between Ej and each of its parents are performed as only the parents of Ej can have effect on it. These tests are required to make sure that the event types being considered are not independent in the presence of other event types. In case of independence between Ej and its parent, the edge representing their precedence relationship in G is removed. Lines 9 - 16 shows this step.\nThen, the score of the node Ej is calculated and stored, as shown in lines 17 and 18.\n4. Finally, the ranking scores of all event types explored in non-increasing order are sorted and then the k event types with the top scores are selected (line 20).\nExample 5 Let us illustrate the ES algorithm considering the EPN shown in Figure 4. Suppose C is {E2, E3} and k is 2.\n1. First, the causal search order O, from the EOP (i.e., E3), is determined as {E3, E1, E4, E5, E6, E7}.\n2. Then, the marginal independence tests are performed on each edge in EPN. For simplicity in illustration, we assume that these tests fail to remove any edges.\n3. Now, the score of each event type in O is calculated and stored into the buffer BT based on their ordering in O.\n(a) The score of the first unexplored event type E1 is calculated and updated in BT as follows.\n\u2022 Determine the parents of E1, Sparents = {E3} \u2022 Perform CI tests between every parent of E1 (i.e., Sparents) and E1. Suppose the CI test succeeds, and thus no edge is removed. \u2022 Calculate the score of E1: P (E1|C) = P (E1|E3) \u00b7 P (E3|C) = 0.333.\n\u2022 Update BT as {(E1, 0.333)}.\nAlgorithm 2 ES Algorithm\nRequire: A temporally ordered set of recently observed \u03b4 cause event types S = {C1, C2, ...., C\u03b4}, the size of the result k, an empty buffer BT to store the effect event types and their scores, and the event precedence network G = (V,\u039e).\n1: Determine causal search order, O, with the outward breadth first search in G from the EOP (C\u03b4). 2: for every edge Ei \u2192 Ej \u2208 \u039e do 3: isIndependent \u2190 IsIndependent(Ei , Ej , \u03c6)); 4: if isIndependent is true then 5: \u039e \u2190 \u039e\u2212 {Ei \u2192 Ej} (//remove the weak relationship.) 6: end if 7: end for 8: for every node Ej \u2208 (O \u2212 C\u03b4) do 9: Sparents \u2190 parents of Ej;\n10: for every parent node Ei \u2208 Sparents do 11: isIndependent \u2190 ICMI(Ei, Ej , Sparents \u2212 {Ei}) 12: if isIndependent is true then 13: \u039e \u2190 \u039e\u2212 {Ei \u2192 Ej}; 14: Sparents \u2190 Sparents \u2212 {Ei}; 15: end if 16: end for 17: P (Ej |C) \u2190 \u2211\nEp\u2208Sparents P (Ej |Ep)P (Ep|C);\n18: Insert the pair (Ej , P (Ej |C)) into BT ; 19: end for 20: Sort the nodes in BT in the non-increasing order of the score and return the\ntop-k results from BT .\n(b) The score of the next unexplored event type E4 is calculated similarly as above, and BT is updated to {(E1, 0.333), (E4 , 0.50)}.\n(c) Following the same step as above, BT is updated to {(E1, 0.333), (E4, 0.50), (E5, 0.167)} for the next event type E5.\n(d) Next, BT is updated to {(E1, 0.333), (E4 , 0.50), (E5, 0.167), (E6 , 0.0835)} for the event type E6.\n(e) BT is updated to {(E1, 0.333), (E4 , 0.50), (E5, 0.167), (E6 , 0.0835), (E7, 0)} for the event type E7. Note that the score P (E7|C) of E7 is assigned as zero. For the parent event type E5, the probability of its child E7 is much lower (half) than the probability of its other child E6. Thus, for this illustration, we assume the CI test between E7 and E5\nfails. Consequently, there is no edge between them.\n4. Finally, BT is sorted in non-increasing order of the score as {(E4, 0.50), (E1 , 0.333), (E5, 0.167), (E6, 0.0835), (E7 , 0)}. Then, the top-2 predicted next event types are selected from BT as {(E4, 0.50), (E1, 0.333)}."}, {"heading": "5.3 Reduced Search Early Termination Algorithm", "text": ""}, {"heading": "5.3.1 Approach", "text": "The ES algorithm searches exhaustively in the EPN during query processing to determine the top-k results and, therefore, may well be slow. More importantly, it scales very poorly and, therefore, this approach is likely to be intractable for a large network. Naturally there is a need for an alternative method that is faster. There are two issues to deal with for that purpose.\n1. Running time : With the exhaustive search of ES on EPN to find all possible results, the search space increases with the number of variables and it performs unnecessary computations. A good query processing method should avoid redundant and unnecessary computations to reduce the running time.\n2. Accuracy : Usually, the tradeoff for reducing running time is the loss in the accuracy of the results. The running time is decreased by reducing the search space, which may skip the correct effect events. The query processing method should avoid such an incident as much as possible.\nTo achieve faster running time while predicting accurate and consistent results, we propose a new algorithm called the Reduced Search Early Termination (RSET) algorithm. It is built upon the ES algorithm. The following strategies reduces the runtime with only marginal reduction in prediction accuracy.\n1. To reduce the running time. There are two ideas to reduce the running time. First, we reduce the search space in EPN by exploring only the descendants of the nodes in the current top-k during query execution. The nodes not in the top-k or their descendants have lower scores, due to multiplicative property of conditional probability described in Section 5.1, thereby disqualified from being top-k candidates. Second, we use a priority-based breadth-first search with an early termination criterion such that the query execution is stopped as soon as it is certain that the top-k results have been found. The prioritybased breadth-first search always chooses the unexplored descendant node with the highest score to explore its children. The early termination criterion\nis met if there is no change in the list of event types in the top-k; that means, there is no more descendant node whose score can be greater than those in the current top-k. Consequently, the search space is only partially explored. For this reason, even though the causal inference is done at runtime, it incurs only a small overhead.\n2. To predict accurate results. In an effort to achieve the same level of accuracy as the exhaustive search, we employ two ideas. First, we calculate the ranking score with the evidence from all explored nodes. Second, we perform the breadth-first search of the EPN in such a way that the events with greater score are processed earlier. It is worth noting that the ancestors always have higher or the same (in the worst condition) score as their descendants."}, {"heading": "5.3.2 Algorithm", "text": "Algorithm 3 outlines the RSET algorithm and can be described as follows.\n1. First, two empty buffers, BC and Bk, are created to store the event types explored during query processing and the top-k effect event types computed, respectively. Bk can hold maximum k event types. Line 1 states this step.\n2. Second, we add the EOP , C\u03b4, with 1 as its score to both these buffers. C\u03b4 has the probability of 1 since the event type has already been observed. Line 2 states this step.\n3. Then, the algorithm employs the following strategies to (a) reduce the search space, (b) predict accurate results, and (c) terminate as early as possible.\n\u2022 To reduce the search space. Two ideas are employed to reduce the search space. First, it explores only the children of EOP or the event types in the buffer Bk for further computation. Line 3 reflects this strategy. For any event type Ec not in Bk (i.e., top-k ), Ec and its descendants are ignored, thus reducing the search space. The probabilities of the children of Ec are much lower than that of Ec due to multiplicative property of conditional probability, or equal even in the (rare) best case. Second, the buffer Bk is always sorted in non-increasing order of the score after a new event type is added to it (lines 18\u201319 and 23\u201324). So, the priority for network exploration is always given to the unvisited node with the highest score. This means that we consider the fact that its children might have higher ranking scores than the unvisited nodes already in Bk. Consequently, the nodes with the lowest probability\n(Elowest) in Bk can be removed if Bk is full, which further reduces the search space. Lines 3 and 23 reflect this mechanism.\n\u2022 To predict accurate results. It keeps in Bc the record of all event types visited. Basically, the event types in EPN are explored in the breadth-first search. Therefore, the parents of a node have already been explored by the time the algorithm considers the child node. While doing so, the causal relationships are tested in lines 7 \u2013 14. Although the first strategy above reduces the search space, the algorithm still keeps all ancestors in Bc by recording all visited nodes so far. Due to this search strategy, only the nodes with lower scores are not visited. So, the ranking score calculation is not affected by the reduced search space. Consequently, the accuracy of prediction result is not degraded. Lines 7, 15, and 16 make use of this strategy.\n\u2022 To terminate as early as possible. An early termination is possible if there is no change in the list of event types in Bk after exploring their children. It means that there are no more event types further down the current level of exploration that can have higher probability than those already in Bk. Checking only unvisited nodes in line 3 reflects this strategy.\nThe computational complexities of the RSET and ES algorithms are dominated by the number of conditional independence tests, which is exponential in the worst case as shown in our prior work on the FCNI algorithm [1], and thus both the RSET and ES algorithms have exponential computational complexity in the worst case. In practice, however, the RSET algorithm achieves a significant reduction in the computational complexity due to pruning by reduced search space and early termination.\nExample 6 Let us illustrate the RSET algorithm considering the EPN shown in Figure 4. Suppose C is {E2, E3} and k is 2.\n1. First, two empty buffers BC and Bk are created to store all the event types explored so far and to store the current top-k predicted event types, respectively.\n2. Then, the search starts with the EOP (E3) and updates BC to {(E3, 1)}.\n3. Now, every unvisited event type is explored as follows. For simplicity in illustration, we assume that the CI tests return false and hence the edges are not removed.\nAlgorithm 3 RSET Algorithm\nRequire: A temporally ordered set of recently observed \u03b4 cause event types C = {C1, C2, ....., C\u03b4}, the size of the result k, and event precedence network G = (V,\u039e).\n1: BC \u2190 {}, Bk \u2190 {} i.e., create two buffers BC and Bk; 2: BC \u2190 BC \u222a {(C\u03b4 , 1)}; 3: for every unvisited node Ec \u2208 ({C\u03b4}\u222a (set of event types in Bk)) with the\nhighest score do 4: Mark Ec as visited. 5: Schildren \u2190 children of Ec; 6: for each node Ej \u2208 Schildren do 7: \u201cVisited\u201d parents Sparents \u2190 (set of parents of Ej) \u2229BC ; 8: for every node Ei \u2208 Sparents do 9: isIndependent \u2190 ICMI(Ei, Ej , Sparents \u2212 {Ei})\n10: if isIndependent is true then 11: \u039e \u2190 \u039e\u2212 {Ei \u2192 Ej}; 12: Sparents \u2190 Sparents \u2212 {Ei}; 13: end if 14: end for 15: P (Ej |C) \u2190 \u2211\nEp\u2208Sparents P (Ej |Ep)P (Ep|C);\n16: BC \u2190 BC \u222a {(Ej , P (Ej |C))}; 17: if |Bk| \u2264 k then 18: Bk \u2190 Bk \u222a {(Ej , P (Ej |C))}; 19: Sort the event types in Bk in non-increasing order of their scores; 20: else 21: Find the entry with the lowest score, (Elowest, Plowest), in Bk. 22: if P (Ej |C) > the lowest value in Bk then 23: Bk \u2190 (Bk \u2212 {(Elowest, Plowest)}) \u222a {(Ej , P (Ej |C))}; 24: Sort the event types in Bk in non-increasing order of their scores; 25: end if 26: end if 27: end for 28: end for\n(a) The first unvisited event type, E3, is marked as visited and its children, Schildren (= {E1, E4, E5}), are explored.\ni. The score of the first unexplored child, E1, is calculated and added to the two buffers as follows.\n\u2022 Determine the parents of E1; Sparents i set to {E3}. \u2022 Perform CI test of the edge between E1 and E3 given Sparents. \u2022 Calculate the score of E1 as P (E1|C) = P (E1|E3)P (E3|C) = 0.333.\n\u2022 Update BC to {(E3, 1), (E1, 0.333)}. \u2022 Update and sort Bk to {(E1, 0.333)}.\nii. The same steps as above are followed for the next unexplored child E4. The two buffers BC and Bk are updated to {(E3, 1), (E1, 0.333), (E4, 0.50)} and {(E4, 0.50), (E1 , 0.333)}, respectively.\niii. BC and Bk are updated to {(E3, 1), (E1, 0.333), (E4 , 0.50), (E5 , 0.167)} and {(E4, 0.50), (E1, 0.333)}, respectively, for the next unexplored child E5.\n(b) Now, the next unvisited event type, E4 in Bk, is marked as visited and its children are explored. However, there are no child of E4, i.e., Schildren is empty. Therefore, there is no computation to be performed.\n(c) The same result is seen for the next event type, E1, as well. As it has no child (i.e., Schildren is empty), there is no computation to be performed.\n4. The top-k result in Bk is obtained as {(E4, 0.50), (E1, 0.333)}.\nFor the same C, the RSET algorithm considered only four event types \u2013E3, E1, E4, E5 \u2013 and the ES algorithm considered all event types \u2013 E3, E1, E4, E5, E6, E7. Note that in this example, RSET produced the same result (i.e., Bk = {(E4, 0.50), (E1, 0.333)}) as ES (which is typical unless the value of k is significantly large). It shows the merit of the early terminating reduced search approach of the RSET algorithm against the exhaustive search approach of the ES algorithm."}, {"heading": "6 Performance Evaluation", "text": "We conduct experiments to evaluate the run-time causal inference model and the top-k query processing mechanism in the proposed RSET algorithm and the ES algorithm. One evaluation is with respect to the accuracy of the top-k results, and the other evaluation is with respect to the runtime. Section 6.1 describes the experiment setup, including the evaluation metrics, datasets and the platform used, and Section 6.2 presents the experiment results."}, {"heading": "6.1 Experiment Setup", "text": ""}, {"heading": "6.1.1 Evaluation Metrics", "text": "Intuitively, the performances of the top-k query processing algorithms are best evaluated by examining two important evaluation criteria \u2013 accuracy and runtime.\n1. Accuracy. Suppose Rk is the ranked list of the top-k effects predicted from the set of cause event types, C, observed so far in the test sequence. To measure accuracy, the next event type observed in the test sequence, Eo (o \u2208 [1, N ]), is checked against the predicted ranked list Rk. If Eo exists in Rk, we say the prediction is correct (hit); otherwise we say the prediction is incorrect (miss).\nThere are two methods for deciding the correctness of a top-k predicted result. First, in some scenarios, a hit may be a sufficient condition for correctness. In such a case, we say the accuracy is 100% for a hit and 0% for a miss. We call this perspective hit-or-miss (non-weighted). Second, in other scenarios, the rank of the predicted result may also play an important role in determining the accuracy. Clearly, if the algorithm predicts Eo as the most likely effect (i.e., at the top of Rk with the highest probability), then the accuracy is 100%. As we go down the list in Rk, the accuracy decreases. Therefore, to reflect this point, we take the probability of each event in Rk into consideration when calculating the prediction accuracy. We call this perspective weighted.\nHit-or-miss accuracy. Let nhits and nmisses be the number of hits and the number of misses, respectively out of ntests tests. Then, the hit-or-miss accuracy of the result, \u03b1hm, is calculated as follows.\n\u03b1hm = nhits ntests = nhits nhits + nmisses (2)\nWeighted accuracy. Suppose P (Eo) is the score of Eo in Rk. As discussed earlier, the rank of Eo in Rk contributes towards the calculation of the prediction accuracy. The rank is based on the score; therefore, we normalize the score such that the prediction accuracy decreases gradually with the decrease in the rank of Eo in Rk. The accuracy of Eo, in the case of a miss, is 0% whereas the accuracy of Eo, in the case of a hit, is\nP (Eo) max{P (Ej )|Ej\u2208Rk}\n, where the denominator is the highest probability among all event types in Rk. (Note that this measure gives the top event type the accuracy of 100%.)\nLet nhits and nmisses be the same as above. Then, the weighted accuracy of the result, \u03b1weighted, is computed as follows.\n\u03b1weighted =\n\u2211ntests i=1\nP (Eoi)\nmax{P (Eji )|Eji\u2208Rki}\nntests\nwhere Eoi is the i-th observed event type in the test data.\nAs mentioned earlier, the accuracy of a miss is 0%. Therefore, we can consider only the hits in the numerator.\n\u03b1weighted =\n\u2211nhits h=1 P (Eoh) max{P (Ejh )|Ejh\u2208Rkh}\nnhits + nmisses (3)\nwhere Eoh is the h-th observed event type which has the result hit in the test data.\n2. Runtime. The runtime is the CPU time taken during query processing. Note that the event precedence network construction is not part of the query processing mechanism. Therefore, we do not include it in the measurement of the runtime. In the query processing with the RSET algorithm and the ES algorithm, there is an overhead of run-time causal inference and it is included in the runtime. In contrast, the query processing with the traditional causal inference (i.e., FCNI algorithm) does not include the causal network construction time in the runtime as the causal inference is performed only once (during the causal network construction) prior to query processing. In our work, latency is the interval between the arrival of a new event and the identification of its top-k effect events. However, as the time for EPN update is insignificant (see the polynomial runtime in Section 4.2) compared to the time for query processing (which is exponential), latency is essentially the query processing time."}, {"heading": "6.1.2 Datasets", "text": "Experiments are conducted using two real-world datasets (summary in Table 2) to evaluate the proposed algorithms.\nElectric power grid dataset This dataset contains simulated temporal sequences of cascading electric power grid component outages, such as those that can lead to very large blackouts (e.g., [42]). The sequences were generated using a model of the Polish power network, which is described in [12]. Each sequence represents the\norder in which the components failed, as well as the time of the failure. Each grid component is considered an event type, whereas a component failure is an event instance. This dataset includes 4492 cascade sequences and 565 distinct event types.\nIn the original dataset, each file, representing one blackout, has a list of the components that failed in that blackout. The original schema of the power grid data is as follows: \u3008event indicator, timestamp, component id\u3009. The event indicator can be one of 0, 1, and -1, which refer to an initiating event, a dependent event, and a stop event, respectively. There is always at least one initiating event at the beginning of each component failure sequence (with 0 as its starting time). Since these events are always at the beginning of the sequence, there is no inward edge towards them in the event precedence network. A dependent event is the result of the initiating event or another dependent event. A blackout sequence always has at least one dependent event. We treat both an initiating event and a dependent event in the same way. On the other hand, a stop event denotes the end of the blackout and is not a real event. Therefore, we ignore stop events. The timestamp and the component id are respectively the starting time of an event and the attribute that uniquely identifies a grid component.\nTo create an event stream, we modify the schema and mix the data from the files in random order while preserving the temporal order of the component failures in each blackout. The modified schema, \u3008timestamp, component id, blackout id, event indicator\u3009, has an additional tag blackout id to identify the blackout to which the component failure belongs to. So, the blackout id is the CRA in the power grid dataset.\nMSNBC.com web dataset This dataset consists of click-stream data of 989818 sequences obtained from the University of California, Irvine\u2019s machine learning repository [18]. Each sequence reflects the browsing activities, arranged in temporal order, in one user session. The dataset gives a random sample of the length of visits of users browsing the msnbc.com web site on the whole day of September 28, 1999. The length of the visit is an estimate of the total number of clicks or\npages seen by each user and is based on the \u201cInternet Information Server (IIS) logs for msnbc.com and news-related portions of msn.com\u201d. A webpage category is an event type, and a webpage visit is an event instance. The session id of the visit is the CRA for its event instance.\nThe number of distinct event types is 17. That is, a sequence can have web activities related to 17 different webpage categories. These event types (i.e., webpage categories) are frontpage, news, technology, local, opinion, on-air, miscellaneous, weather, msn-news, health, living, business, msn-sports, sports, summary, bbs, and travel. The total number of event instances (i.e., page visits) is 4698795.\nTo create an event stream, we randomly mix the events while preserving the temporal order of the events for each session. The schema of the events is \u3008timestamp, webpage category, session id, \u03a6\u3009, where \u03a6 denotes an empty attribute set."}, {"heading": "6.1.3 Experiment Platform", "text": "The experiments are conducted on a 2.3 GHz Intel Core i5 machine with 4GB of memory, running Windows 7. The algorithms are implemented in Java 1.7.0."}, {"heading": "6.2 Experiment Results", "text": "We perform two sets of experiments to evaluate the RSET and ES algorithms. One set of experiments is to evaluate the prediction accuracy, and the other set of experiments is to evaluate the runtime. There are two objectives in each set of experiments. The first objective is to compare the query processing with the run-time causal inference mechanism (of RSET and ES) against the query processing with the traditional causal inference mechanism (of the FCNI algorithm). For a fair comparison, as the goal is only to compare the causal inference mechanisms, the query processing mechanism of either RSET algorithm or ES algorithm can be used in the FCNI algorithm, and, in this experiment, we choose the RSET algorithm. The second objective is to compare the query processing mechanism between the RSET algorithm and the ES algorithm. In addition, the effects of k on the proposed algorithms are studied in each set of experiments.\nWe divide each real dataset into 70% for training and 30% for testing the proposed algorithms. The division of MSNBC dataset is done by session id, and the division of electric power grid dataset is by blackout id. From the event stream of training dataset, EPN is constructed as an input to the RSET and ES algorithms, whereas a causal network is constructed as an input to the FCNI algorithm. The window observation period T is set to 10 msec for the MSNBC dataset and 10 sec for the electric power grid dataset. The testing data simulates event stream. As soon as a new event arrives, it is added to the partitioned window. Then, the top-k\nprediction query execution is triggered in response to the most recent event at position \u03b4 (called the EOP index) in the sequence of cause events in the same partition. Note that the RSET and ES algorithms perform query processing over the EPN whereas the FCNI algorithm does so over the causal network. Upon the arrival of a new event, the measurements of prediction accuracy and runtime are repeated and the calculated average accuracy and average runtime are reported."}, {"heading": "6.2.1 Accuracy", "text": "Figures 8 and 9, respectively, show the hit-or-miss and the weighted accuracies for the MSNBC dataset and Figures 10 and 11 show them for the power grid dataset. In these figures, the accuracies of the RSET algorithm, the ES algorithm, and the FCNI algorithm are compared for different values of the EOP index (\u03b4) over the sequence of events in the condition set. In addition, Figures 12 and 13 show the average hit-or-miss and weighted accuracies for different values of k in the MSNBC dataset and the power grid dataset, respectively.\nAs expected, for all cases, the hit-or-miss accuracy is never lower than the weighted accuracy. Clearly, a hit in the hit-or-miss accuracy always receives the score of 1 while a hit in the weighted accuracy receives a score lower than 1 unless the observed event type in the test data has the highest score in the ranked list. When k is one, the size of the result ranked list is one, hence Equation 3 reduces to Equation 2, and therefore the two accuracy measures give the same value.\nComparison of the causal inference mechanisms\nAll results show that the prediction accuracies of both ES and RSET algorithms are significantly higher than that of the FCNI algorithm at every EOP index (\u03b4). This difference in accuracy comes from the difference in their causal models. (Recall that for fairness the FCNI algorithm uses the same query processing mechanism used in the RSET algorithm.) Thus, it confirms the expectation that the traditional causal model (of the FCNI algorithm) is so limited due to its lack of support for cyclic causality and the loss of causal information that the prediction accuracy is compromised significantly. On the other hand, the RSET and ES algorithms both use run-time causal inference which can handle cyclic causality and causal information loss, thereby achieving higher prediction accuracies.\nThe results also show that the accuracy of all three algorithms increases with the increase of k. The reason for this is that more event types are considered as the probable next effects. Moreover, the accuracy in the ES and the RSET algorithms is always higher than in the FCNI algorithm. This indicates that the deficiencies of the FCNI algorithm (i.e., acyclic causality and causal information loss) leads\nto excluding many important causal relationships and, as a result, the accuracy is always much lower than that of the ES and the RSET algorithms regardless of the value of k.\nComparison of the query processing mechanisms\nThree observations are made from the results. First, all results show that the prediction accuracy of the ES algorithm is always higher than that of the RSET algorithm. This is evident from the fact that the ES algorithm performs an exhaustive search whereas the RSET algorithm performs only a partial search.\nSecond, the accuracy of the RSET algorithm is more comparable to that of the\nES algorithm in the power grid dataset than in the MSNBC dataset. This can be explained as follows. When the ratio of k to N is larger, both algorithms have higher probabilities of making correct predictions but the gap between their accuracies is larger because ES performs exhaustive search while RSET performs partial. Note that k/N is smaller in the power grid dataset (the largest k/N considered is 0.035) than in the MSNBC dataset (the largest k/N considered is 0.53), and therefore the gap is smaller for the power grid dataset.\nThird, as discussed earlier, as the value of k increases, the accuracies of all three algorithms increase. Here we add further evaluation on the ES algorithm and the RSET algorithm with a focus on their search mechanisms. As k increases, the search space of the RSET algorithm increases, leading to a higher gain in the accuracy. In the case of the ES algorithm, the search space remains constant regardless of k, but the number of candidate effects from which the highest k is selected increases and, consequently, the accuracy still increases. Intuitively, the\nrate of increase in the accuracy is higher for the hit-or-miss accuracy metric than the weighted accuracy metric in both algorithms."}, {"heading": "6.2.2 Runtime", "text": "In this experiment, we compare the runtime among the three algorithms (RSET, ES, FCNI). In addition, we analyze the effects of k on the runtime.\nFigures 14 and 15 show the runtime for the MSNBC dataset and the power grid dataset, respectively. In these figures, the runtime of the three algorithms are compared for different values of the EOP index (\u03b4) over the sequence of events in the condition set. In addition, Figure 16 shows the runtime for different values of\nk in the MSNBC and the power grid datasets.\nComparison of the causal inference mechanisms.\nThe results show that the runtimes of the RSET and ES algorithms are longer than that of the FCNI algorithm at every EOP index for every value of k. As discussed in Section 5.3, the RSET and ES algorithms have an overhead of the run-time\ncausal inference during query processing while FCNI algorithm does not as it uses a pre-built causal network for prediction. Therefore, the runtimes for the ES and RSET algorithms are always longer than that of the FCNI algorithm. Interestingly, the runtimes of the three algorithms are longer in the power grid dataset than the MSNBC dataset. This is due to a larger number of event types (i.e., N) in the power grid dataset.\nComparison of the query processing mechanisms.\nThe results suggest three observations. First, as expected, the runtime of the RSET algorithm is always shorter than the ES algorithm. The main reason is in the differen search scope (i.e., exhaustive in ES and partial in RSET) as discussed in Section 5. In addition, there is an overhead in the ES algorithm, unlike the RSET algorithm, to calculate the causal search order.\nSecond, the runtime difference between the RSET algorithm and the ES algorithm is smaller for the MSNBC dataset (Figure 14) than for the power grid dataset (Figure 15). This is due to the larger network size (i.e., N ) in the power grid dataset (than in the MSNBC dataset). That is, a larger network size results in a larger search space (which is typical over event streams) and thus requires longer runtime for query processing.\nThird, the runtime of the ES algorithm does not change with an increase in k. The ES algorithm always runs an exhaustive search, irrespective of the value of k, and uses k only to filter out the top-k event types out of N event types at the end, which has insignificant effect on the overall runtime. On the other hand, the runtime of the RSET algorithm does increase with an increase in k. The search space covered by the RSET algorithm increases with k, leading to the increased runtime."}, {"heading": "6.2.3 Discussion of experiment results", "text": "The proposed run-time causal inference mechanism, in the RSET and ES algorithms, handles cyclic causality and avoids the causal information loss, and thus improves prediction accuracy significantly. The FCNI algorithm, on the other hand, performs worse than both the RSET and ES algorithms as it cannot handle cyclic\ncausality. The ratios of the number of cycles over the number of edges in the EPN are 0.69 and 0.85 for the power grid dataset and the MSNBC dataset, respectively. Intuitively, the accuracy of the FCNI algorithm would suffer increasingly more as the number of cycles increases. Thus, despite its reduced runtime, the FCNI algorithm is not suitable for top-k predictive query processing over event streams.\nThe accuracy of the RSET algorithm is comparable to the accuracy of the ES algorithm. Therefore, the RSET algorithm, as it is much faster than the ES algorithm, is more suitable for real-time continuous top-k query processing over event streams whereas the ES algorithm is more suitable when the time is of lesser importance. This will become increasingly evident for real-time applications with hundreds (or possibly thousands) of event types because then the pruning effect of reduced search and early termination becomes increasingly more significant.\nBetween the two datasets, the runtime for the power grid dataset is much longer than the runtime for the MSNBC dataset. This is due to the difference in the numbers of event types in these two datasets. That is, the much larger number of event types in the power grid dataset leads to much more conditional independence tests during the run-time causal inference, thus resulting in slower query execution. In our work, the runtime measurements were made on a low-end laptop. The use of a more powerful computational setup (e.g., parallel processing) would further reduce the runtime."}, {"heading": "7 Conclusion and Future Work", "text": "This paper focused on the problem of continuous top-k prediction over event streams. We proposed a novel causal inference mechanism, called run-time causal inference, to support the cyclic causal relationships and overcome the causal information loss. Then, we proposed two query processing algorithms, called the Reduced Search with Early Termination (RSET) algorithm and the Exhaustive Search (ES) algorithm, which use run-time causal inference to predict top-k effects continuously. Finally, through experiments, we demonstrated that the proposed approach overcomes the two main limitations of the traditional causal inference approach \u2013 acyclic causality and causal information loss. We showed that the proposed RSET and ES algorithms greatly improved the causal inference power for real data seen these days in various applications.\nThere are a number of issues we plan to address in the future work. First, in this paper we assume events in a stream are in the correct temporal order. If, however, events arrive out of order, erroneous relationships are introduced in the event precedence network, thereby degrading the accuracy of prediction. One idea to deal with such an out-of-order stream is to allow for ambiguity in the edge direction by in-\ntroducing, for example, undirected edges and then allow the algorithm to resolve edge directions at query processing time. Second, in this paper we only support direct causality and, therefore, one level of prediction, under the assumption that an event is the most likely effect of only its immediately preceding event. Extended from this, supporting indirect causality between events, thus multiple levels of causal prediction through a chain of intermediate events, would be interesting. Since the mechanism to compute the propagation of probabilities through the event precedence network is already in place (see Examples 5 and 6) this extension is not conceptually difficult. However, the computational cost, which increases exponentially with the number of prediction levels, may be a challenge. Third, in this paper event types are assumed to be provided by domain experts. Some applications may require that the EPN constructor automatically identify and define event types from event streams."}], "references": [{"title": "Fast causal network inference over event streams. In Data Warehousing and Knowledge Discovery, volume 8057 of Lecture Notes in Computer Science, pages 222\u2013235", "author": ["S. Acharya", "B. Lee"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2013}, {"title": "Database-support for continuous prediction queries over streaming data", "author": ["M. Akdere", "U. \u00c7etintemel", "E. Upfal"], "venue": "Proc. VLDB Endow.,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2010}, {"title": "Discrete Multivariate Analysis: Theory and Practice", "author": ["Y.M. Bishop", "S.E. Fienberg", "P.W. Holland"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1975}, {"title": "A comparison of association rule discovery and bayesian network causal inference algorithms to discover relationships in discrete data", "author": ["J. Bowes", "E. Neufeld", "J. Greer", "J. Cooke"], "venue": "Advances in Artificial Intelligence,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2000}, {"title": "Ais-bn: An adaptive importance sampling algorithm for evidential reasoning in large Bayesian networks", "author": ["J. Cheng", "M.J. Druzdzel"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2000}, {"title": "Confidence inference in Bayesian networks", "author": ["J. Cheng", "M.J. Druzdzel"], "venue": "In Proceedings of the Seventeenth conference on Uncertainty in artificial intelligence,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2001}, {"title": "Learning Bayesian networks from data: an information-theory based approach", "author": ["J. Cheng", "R. Greiner", "J. Kelly", "D. Bell", "W. Liu"], "venue": "Artificial Intelligence,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "Learning equivalence classes of Bayesian-network structures", "author": ["D.M. Chickering"], "venue": "J. Machine Learning Research,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2002}, {"title": "A scoring function for learning Bayesian networks based on mutual information and conditional independence tests", "author": ["L.M. de Campos"], "venue": "J. Machine Learning Research,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2006}, {"title": "Learning causal Bayesian network structures from experimental data", "author": ["B. Ellis", "W.H. Wong"], "venue": "J. American Statistics Association,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "Biological Knowledge Discovery Handbook: Preprocessing, Mining and Postprocessing of Biological Data, volume 23", "author": ["M. Elloumi", "A.Y. Zomaya"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2013}, {"title": "A \u201dRandom Chemistry\u201d algorithm for identifying collections of multiple contingencies that initiate cascading failure", "author": ["M. Eppstein", "P. Hines"], "venue": "IEEE Transactions on Power Systems,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "Using Bayesian networks to analyze expression data", "author": ["N. Friedman", "M. Linial", "I. Nachman", "D. Pe\u2019er"], "venue": "In Proceedings of the Fourth Annual International Conference on Computational Molecular Biology,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2000}, {"title": "Learning, prediction and causal Bayes nets", "author": ["C. Glymour"], "venue": "Trends in cognitive sciences,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2003}, {"title": "Design and analysis of the causation and prediction challenge", "author": ["I. Guyon", "C.F. Aliferis", "G.F. Cooper", "A. Elisseeff", "J.-P. Pellet", "P. Spirtes", "A.R. Statnikov"], "venue": "In IEEE World Congress on Computational Intelligence Causation and Prediction Challenge,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2008}, {"title": "The gist of everything new: Personalized top-k processing over web 2.0 streams", "author": ["P. Haghani", "S. Michel", "K. Aberer"], "venue": "In Proceedings of the 19th ACM International Conference on Information and Knowledge Management,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "A Bayesian approach to learning causal networks", "author": ["D. Heckerman"], "venue": "In Proceedings of the Eleventh conference on Uncertainty in artificial intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1995}, {"title": "UCI machine learning repository [http://archive.ics.uci.edu/ml/datasets/msnbc.com+ anonymous+web+data", "author": ["D. Heckerman"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1999}, {"title": "Search-based methods to bound diagnostic probabilities in very large belief nets", "author": ["M. Henrion"], "venue": "In Proceedings of the Seventh conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1991}, {"title": "Microarray gene expression data association rules mining based on BSC-tree and FIS-tree", "author": ["X.-R. Jiang", "L. Gruenwald"], "venue": "Data & Knowledge Engineering,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2005}, {"title": "Finite Markov chains. University series in undergraduate mathematics", "author": ["J. Kemeny", "J. Snell"], "venue": "VanNostrand, New York, repr edition,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1969}, {"title": "Cyclic Bayesian network\u2013Markov process approach", "author": ["M.A. K\u0142opotek"], "venue": "Studia Informatica,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2006}, {"title": "Information Theory and Statistics", "author": ["S. Kullback"], "venue": "Dover Publication,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1968}, {"title": "Active learning for causal Bayesian network structure with non-symmetrical entropy", "author": ["G. Li", "T.-Y. Leong"], "venue": "In Proceedings of the 13th Pacific-Asia Conference on Advances in Knowledge Discovery and Data Mining,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2009}, {"title": "Data Mining: Foundations and Practice, volume 118 of Studies in Computational Intelligence", "author": ["T.Y. Lin", "Y. Xie", "A. Wasilewska", "C.-J. Liau", "editors"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2008}, {"title": "Introduction to Monte Carlo methods", "author": ["D.J.C. MacKay"], "venue": null, "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1999}, {"title": "Mining causality from imperfect data", "author": ["L.J. Mazlack"], "venue": "In Proceedings of the sixth International FLINS Conference on Applied Computational Intelligence Proceedings, Applied Computational Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2004}, {"title": "Learning causal Bayesian networks from observations and experiments: a decision theoretic approach", "author": ["S. Meganck", "P. Leray", "B. Manderick"], "venue": "In Proceedings of the Third international conference on Modeling Decisions", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2006}, {"title": "Mining causal relationships in multidimensional time series", "author": ["Y. Mohammad", "T. Nishida"], "venue": "Smart Information and Knowledge Management,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2010}, {"title": "An adaptive sequential Monte Carlo method for approximate Bayesian computation", "author": ["P. Moral", "A. Doucet", "A. Jasra"], "venue": "Statistics and Computing,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2012}, {"title": "Causal diagrams for empirical research", "author": ["J. Pearl"], "venue": "Biometrika, 82:669\u201388,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 1995}, {"title": "Graphs, causality, and structural equation models", "author": ["J. Pearl"], "venue": "Sociological Methods and Research,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1998}, {"title": "Causality: Models, Reasoning and Inference", "author": ["J. Pearl"], "venue": null, "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2009}, {"title": "Reasoning about causal relationships: Inferences on causal networks", "author": ["B.M. Rottman", "R. Hastie"], "venue": "Psychological Bulletin,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2014}, {"title": "Sequential event prediction with association rules", "author": ["C. Rudin", "B. Letham", "A. Salleb-Aouissi", "E. Kogan", "D. Madigan"], "venue": "In Proceedings of the 24th Annual Conference on Learning Theory, COLT", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2011}, {"title": "Efficient top-k querying over social-tagging networks", "author": ["R. Schenkel", "T. Crecelius", "M. Kacimi", "S. Michel", "T. Neumann", "J.X. Parreira", "G. Weikum"], "venue": "In Proceedings of the 31st Annual International ACM SIGIR Conference on Research and Development in Information Retrieval,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2008}, {"title": "Evidence absorption and propagation through evidence reversals", "author": ["R.D. Shachter"], "venue": "In Proceedings of the Fifth Annual Conference on Uncertainty in Artificial Intelligence,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 1990}, {"title": "Scalable techniques for mining causal structures", "author": ["C. Silverstein", "S. Brin", "R. Motwani", "J. Ullman"], "venue": "Data Mining and Knowledge Discovery,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2000}, {"title": "Causation, Prediction, and Search", "author": ["P. Spirtes", "C. Glymour", "R. Scheines"], "venue": null, "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2000}, {"title": "Causality from probability", "author": ["P. Spirtes", "C.N. Glymour", "R. Scheines"], "venue": "In Proceedings of the Conference on Advanced Computing for the Social Sciences, ACSS,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 1990}, {"title": "Directed cycles in Bayesian belief networks: probabilistic semantics and consistency checking complexity", "author": ["A.L. Tulupyev", "S.I. Nikolenko"], "venue": "In Proceedings of the 4th Mexican international conference on Advances in Artificial Intelligence,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2005}, {"title": "Risk assessment of cascading outages: Methodologies and challenges", "author": ["M. Vaiman", "K. Bell", "Y. Chen", "B. Chowdhury", "I. Dobson", "P. Hines", "M. Papic", "S. Miller", "P. Zhang"], "venue": "IEEE Transactions on Power Systems,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2012}, {"title": "Learning to rank at query-time using association rules", "author": ["A.A. Veloso", "H.M. Almeida", "M.A. Gon\u00e7alves", "W. Meira Jr."], "venue": "In Proceedings of the 31st Annual International ACM SIGIR Conference on Research and Development in Information Retrieval,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2008}, {"title": "Deming, data and observational studies", "author": ["S.S. Young", "A. Karr"], "venue": "Significance, 8(3):116\u2013120,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2011}, {"title": "Exploiting causal independence in Bayesian network inference", "author": ["N.L. Zhang", "D. Poole"], "venue": "J. Artif. Int. Res.,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 1996}, {"title": "A simple approach to Bayesian network computations", "author": ["P.D. Zhang.N.L"], "venue": "In Proceedings of the Tenth Canadian Conference on Artificial Intelligence,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 1994}], "referenceMentions": [{"referenceID": 13, "context": "[14, 15, 39]) is emerging as an essential field for real-time monitoring, planning and decision support in diverse applications such as stock market analysis, electric power grid monitoring, sensor network monitoring, network intrusion detection, and web click-stream analysis.", "startOffset": 0, "endOffset": 12}, {"referenceID": 14, "context": "[14, 15, 39]) is emerging as an essential field for real-time monitoring, planning and decision support in diverse applications such as stock market analysis, electric power grid monitoring, sensor network monitoring, network intrusion detection, and web click-stream analysis.", "startOffset": 0, "endOffset": 12}, {"referenceID": 38, "context": "[14, 15, 39]) is emerging as an essential field for real-time monitoring, planning and decision support in diverse applications such as stock market analysis, electric power grid monitoring, sensor network monitoring, network intrusion detection, and web click-stream analysis.", "startOffset": 0, "endOffset": 12}, {"referenceID": 41, "context": ", [43]).", "startOffset": 2, "endOffset": 6}, {"referenceID": 1, "context": ", [2, 46]).", "startOffset": 2, "endOffset": 9}, {"referenceID": 44, "context": ", [2, 46]).", "startOffset": 2, "endOffset": 9}, {"referenceID": 9, "context": ", [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction.", "startOffset": 2, "endOffset": 30}, {"referenceID": 16, "context": ", [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction.", "startOffset": 2, "endOffset": 30}, {"referenceID": 23, "context": ", [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction.", "startOffset": 2, "endOffset": 30}, {"referenceID": 27, "context": ", [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction.", "startOffset": 2, "endOffset": 30}, {"referenceID": 32, "context": ", [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction.", "startOffset": 2, "endOffset": 30}, {"referenceID": 38, "context": ", [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction.", "startOffset": 2, "endOffset": 30}, {"referenceID": 39, "context": ", [10, 17, 24, 28, 33, 39, 40]) has two major limitations to be used for causal prediction.", "startOffset": 2, "endOffset": 30}, {"referenceID": 12, "context": ", [13, 34]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 33, "context": ", [13, 34]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 30, "context": "Second, the causal Markov condition, often considered an essential property of traditional causal networks, is conservative in the causal inference, and as a result removes many infrequent but important causal relationships from the causal network [31, 32, 34, 40].", "startOffset": 248, "endOffset": 264}, {"referenceID": 31, "context": "Second, the causal Markov condition, often considered an essential property of traditional causal networks, is conservative in the causal inference, and as a result removes many infrequent but important causal relationships from the causal network [31, 32, 34, 40].", "startOffset": 248, "endOffset": 264}, {"referenceID": 33, "context": "Second, the causal Markov condition, often considered an essential property of traditional causal networks, is conservative in the causal inference, and as a result removes many infrequent but important causal relationships from the causal network [31, 32, 34, 40].", "startOffset": 248, "endOffset": 264}, {"referenceID": 39, "context": "Second, the causal Markov condition, often considered an essential property of traditional causal networks, is conservative in the causal inference, and as a result removes many infrequent but important causal relationships from the causal network [31, 32, 34, 40].", "startOffset": 248, "endOffset": 264}, {"referenceID": 33, "context": "However, this approach often backfires by removing rare but important causal relationships [34].", "startOffset": 91, "endOffset": 95}, {"referenceID": 0, "context": ", ES, RSET) against the stateof-the-art traditional causal inference mechanism called the Fast Causal Network Inference (FCNI) algorithm [1].", "startOffset": 137, "endOffset": 140}, {"referenceID": 9, "context": ", [10, 17, 24, 28]), performs greedy search (usually hill climbing) over all possible causal networks of the data to select the network with the highest score.", "startOffset": 2, "endOffset": 18}, {"referenceID": 16, "context": ", [10, 17, 24, 28]), performs greedy search (usually hill climbing) over all possible causal networks of the data to select the network with the highest score.", "startOffset": 2, "endOffset": 18}, {"referenceID": 23, "context": ", [10, 17, 24, 28]), performs greedy search (usually hill climbing) over all possible causal networks of the data to select the network with the highest score.", "startOffset": 2, "endOffset": 18}, {"referenceID": 27, "context": ", [10, 17, 24, 28]), performs greedy search (usually hill climbing) over all possible causal networks of the data to select the network with the highest score.", "startOffset": 2, "endOffset": 18}, {"referenceID": 7, "context": "Second, the problem of equivalence classes [8], where two or more network structures represent the same probability distribution, makes the causal direction between nodes quite random and therefore unreliable.", "startOffset": 43, "endOffset": 46}, {"referenceID": 6, "context": ", [7, 33, 39, 40]), which performs a large number of conditional independence tests between variables to construct a causal network, does not have the problem of equivalence classes.", "startOffset": 2, "endOffset": 17}, {"referenceID": 32, "context": ", [7, 33, 39, 40]), which performs a large number of conditional independence tests between variables to construct a causal network, does not have the problem of equivalence classes.", "startOffset": 2, "endOffset": 17}, {"referenceID": 38, "context": ", [7, 33, 39, 40]), which performs a large number of conditional independence tests between variables to construct a causal network, does not have the problem of equivalence classes.", "startOffset": 2, "endOffset": 17}, {"referenceID": 39, "context": ", [7, 33, 39, 40]), which performs a large number of conditional independence tests between variables to construct a causal network, does not have the problem of equivalence classes.", "startOffset": 2, "endOffset": 17}, {"referenceID": 0, "context": "The state-of-the-art Fast Causal Network Inference (FCNI) algorithm [1] presents a traditional constraint-based causal network inference mechanism over event streams.", "startOffset": 68, "endOffset": 71}, {"referenceID": 10, "context": ", [11, 22, 41]) to support cyclic Bayesian network which aims to handle the cyclic causality in Bayesian networks.", "startOffset": 2, "endOffset": 14}, {"referenceID": 21, "context": ", [11, 22, 41]) to support cyclic Bayesian network which aims to handle the cyclic causality in Bayesian networks.", "startOffset": 2, "endOffset": 14}, {"referenceID": 40, "context": ", [11, 22, 41]) to support cyclic Bayesian network which aims to handle the cyclic causality in Bayesian networks.", "startOffset": 2, "endOffset": 14}, {"referenceID": 4, "context": ", [5, 6, 26, 30, 37, 47]), while the prediction of top-k effects requires finding the most likely k effects among all possible effect variables.", "startOffset": 2, "endOffset": 24}, {"referenceID": 5, "context": ", [5, 6, 26, 30, 37, 47]), while the prediction of top-k effects requires finding the most likely k effects among all possible effect variables.", "startOffset": 2, "endOffset": 24}, {"referenceID": 25, "context": ", [5, 6, 26, 30, 37, 47]), while the prediction of top-k effects requires finding the most likely k effects among all possible effect variables.", "startOffset": 2, "endOffset": 24}, {"referenceID": 29, "context": ", [5, 6, 26, 30, 37, 47]), while the prediction of top-k effects requires finding the most likely k effects among all possible effect variables.", "startOffset": 2, "endOffset": 24}, {"referenceID": 36, "context": ", [5, 6, 26, 30, 37, 47]), while the prediction of top-k effects requires finding the most likely k effects among all possible effect variables.", "startOffset": 2, "endOffset": 24}, {"referenceID": 45, "context": ", [5, 6, 26, 30, 37, 47]), while the prediction of top-k effects requires finding the most likely k effects among all possible effect variables.", "startOffset": 2, "endOffset": 24}, {"referenceID": 1, "context": ", [2, 19, 46]).", "startOffset": 2, "endOffset": 13}, {"referenceID": 18, "context": ", [2, 19, 46]).", "startOffset": 2, "endOffset": 13}, {"referenceID": 44, "context": ", [2, 19, 46]).", "startOffset": 2, "endOffset": 13}, {"referenceID": 19, "context": ", [20, 35, 44]) are extensively used for prediction and recommendation.", "startOffset": 2, "endOffset": 14}, {"referenceID": 34, "context": ", [20, 35, 44]) are extensively used for prediction and recommendation.", "startOffset": 2, "endOffset": 14}, {"referenceID": 42, "context": ", [20, 35, 44]) are extensively used for prediction and recommendation.", "startOffset": 2, "endOffset": 14}, {"referenceID": 3, "context": ", [4, 25, 27, 29, 38, 45]).", "startOffset": 2, "endOffset": 25}, {"referenceID": 24, "context": ", [4, 25, 27, 29, 38, 45]).", "startOffset": 2, "endOffset": 25}, {"referenceID": 26, "context": ", [4, 25, 27, 29, 38, 45]).", "startOffset": 2, "endOffset": 25}, {"referenceID": 28, "context": ", [4, 25, 27, 29, 38, 45]).", "startOffset": 2, "endOffset": 25}, {"referenceID": 37, "context": ", [4, 25, 27, 29, 38, 45]).", "startOffset": 2, "endOffset": 25}, {"referenceID": 43, "context": ", [4, 25, 27, 29, 38, 45]).", "startOffset": 2, "endOffset": 25}, {"referenceID": 15, "context": "A few works on top-k query processing in the Internet domain, such as over social-tagging networks [16] and over web 2.", "startOffset": 99, "endOffset": 103}, {"referenceID": 35, "context": "0 stream [36], have been published.", "startOffset": 9, "endOffset": 13}, {"referenceID": 0, "context": "We use a window, specifically called partitioned window [1], to accumulate the events from the stream for a user-specified observation period T.", "startOffset": 56, "endOffset": 59}, {"referenceID": 6, "context": ", [7, 9]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 8, "context": ", [7, 9]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 2, "context": "To do so, we relate CMI with the G2 test statistics [3, 39] as below.", "startOffset": 52, "endOffset": 59}, {"referenceID": 38, "context": "To do so, we relate CMI with the G2 test statistics [3, 39] as below.", "startOffset": 52, "endOffset": 59}, {"referenceID": 22, "context": "Under the independence assumption, G2 follows the \u03c72 distribution [23] with the degree of freedom df equal to (nx \u2212 1)(ny \u2212 1) \u220f", "startOffset": 66, "endOffset": 70}, {"referenceID": 20, "context": "The proposed EPM is a first order absorbing Markov chain [21] where an observation is independent of all previous observations except the most recent one and every state can reach an absorbing (a.", "startOffset": 57, "endOffset": 61}, {"referenceID": 0, "context": "The computational complexities of the RSET and ES algorithms are dominated by the number of conditional independence tests, which is exponential in the worst case as shown in our prior work on the FCNI algorithm [1], and thus both the RSET and ES algorithms have exponential computational complexity in the worst case.", "startOffset": 212, "endOffset": 215}, {"referenceID": 11, "context": "The sequences were generated using a model of the Polish power network, which is described in [12].", "startOffset": 94, "endOffset": 98}, {"referenceID": 17, "context": "com web dataset This dataset consists of click-stream data of 989818 sequences obtained from the University of California, Irvine\u2019s machine learning repository [18].", "startOffset": 160, "endOffset": 164}], "year": 2014, "abstractText": "This paper addresses the problem of predicting the k events that are most likely to occur next, over historical real-time event streams. Existing approaches to causal prediction queries have a number of limitations. First, they exhaustively search over an acyclic causal network to find the most likely k effect events; however, data from real event streams frequently reflect cyclic causality. Second, they contain conservative assumptions intended to exclude all possible non-causal links in the causal network; it leads to the omission of many less-frequent but important causal links. We overcome these limitations by proposing a novel event precedence model and a runtime causal inference mechanism. The event precedence model constructs a first order absorbing Markov chain incrementally over event streams, where an edge between two events signifies a temporal precedence relationship between them, which is a necessary condition for causality. Then, the run-time causal inference mechanism learns causal relationships dynamically during query processing. This is done by removing some of the temporal precedence relationships that do not exhibit causality in the presence of other events in the event precedence model. This paper presents two query processing algorithms \u2013 one performs exhaustive search on the model and the other performs a more efficient reduced search with early termination. Experiments using two real datasets (cascading blackouts in power systems and web page views) verify the effectiveness of the probabilistic top-k prediction queries and the efficiency of the algorithms. Specifically, the reduced search algorithm reduced runtime, relative to exhaustive search, by 25\u2212 80% (depending on the application) with only a small reduction in accuracy.", "creator": "gnuplot 4.2 patchlevel 4 "}}}