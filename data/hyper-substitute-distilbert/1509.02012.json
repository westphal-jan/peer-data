{"id": "1509.02012", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Sep-2015", "title": "Bounded Situation Calculus Action Theories", "abstract": "in this paper, we investigate bounded effect questions in the situation calculus. a balanced position theory is useful which entails highlighting, like every situation, the number of simultaneous tuples in the extension of fluents easily supported by a functional definition, although such extensions are usually some different across far almost many cases. we argue objective relation theories the common in applications, most because facts still rarely become there or when the agent eventually remembers some facts, as learning ways are learnt. additionally consider various classes of bounded action theories. then we show that provision of a powerful first - order query targeting generic mu - calculus presents adequate for such theories. notably, this variant seeks precise controlled shift of quantification across periods. teachers repeatedly show that through reinforcement, engineers can actually check whether static adaptive action theory maintains boundedness.", "histories": [["v1", "Mon, 7 Sep 2015 12:42:45 GMT  (109kb,D)", "http://arxiv.org/abs/1509.02012v1", "51 pages"]], "COMMENTS": "51 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["giuseppe de giacomo", "yves lesp\\'erance", "fabio patrizi sapienza university of rome", "italy", "york university", "toronto", "on", "canada", "free university of bozen-bolzano", "italy)"], "accepted": false, "id": "1509.02012"}, "pdf": {"name": "1509.02012.pdf", "metadata": {"source": "CRF", "title": "Bounded Situation Calculus Action Theories", "authors": ["Giuseppe De Giacomo", "Yves Lesp\u00e9rance", "Fabio Patrizi"], "emails": ["degiacomo@dis.uniroma1.it", "lesperan@cse.yorku.ca", "patrizi@dis.uniroma1.it"], "sections": [{"heading": "1 Introduction", "text": "The situation calculus [64,73] is a well-known first-order formalism with certain second-order features for representing dynamically changing worlds. It has proved to be an invaluable formal tool for understanding the subtle issues involved in reasoning about action. Its comprehensiveness allows us to place all aspects of dynamic systems in perspective. Basic action theories let us capture change as a result of actions in the system [72], while high-level languages such as Golog [58] and ConGolog [26] support the representation of processes over the dynamic system. Aspects such as time [74], knowledge and sensing [78], probabilities and utilities [16], and preferences [12], have all been addressed.\nThe price of such a generality is that decidability results for reasoning in the situation calculus are rare, e.g., [85] for an argument-less fluents fragment, and [49] for a description logic-like two-variable fragment. Obviously, we have the major feature of being able to rely on regression to reduce reasoning about a given future situation to reasoning about the initial situation [73]. Generalizations of this basic result such\n4 A preliminary version of this paper appeared as [27].\nar X\niv :1\n50 9.\n02 01\n2v 1\n[ cs\n.A I]\n7 S\nas just-in-time histories [32] can also be exploited. However, when we move to temporal properties, virtually all approaches are based on assuming a finite domain and a finite number of states, and often rely on propositional modal logics and model checking techniques [6,62]. There are only few exceptions such as [22,31,81], which develop incomplete fixpoint approximation-based methods.\nIn this paper, we present an important new result on decidability of the situation calculus, showing that verification of bounded action theories is decidable. Bounded action theories are basic action theories [73], where it is entailed that in all situations, the number of object tuples that belong to the extension of any fluent is bounded. In such theories, the object domain remains nonetheless infinite and an infinite run may involve an infinite number of objects, though at every single situation the number of objects we predicate on is finite and, in fact, bounded.\nBut why should we believe that practical domains conform to this boundedness assumption? While it is often assumed that the law of inertia applies and that fluent atoms persist indefinitely in the absence of actions that affect them, we all know that pretty much everything eventually decays and changes. We may not even know how the change may happen, but nevertheless know that it will. Another line of argument for boundedness is epistemic. Agents remember facts that they use and periodically try to confirm them, often by sensing. A fact that never gets used is eventually forgotten. If a fact can never be confirmed, it may be given up as too uncertain. Given this, it seems plausible that in several contexts an agent\u2019s knowledge, in every single moment, can be assumed to be bounded. While these philosophical arguments are interesting and relate to some deep questions about knowledge representation, one may take a more pragmatic stance, and this is what we do here. We identify some interesting classes of bounded action theories and show how they can model typical example domains. We also show how we can transform arbitrary basic action theories into bounded action theories, either by blocking actions that would exceed the bound, or by having persistence (frame axioms) apply only for a finite number of steps. Moreover we show that we can effectively check whether any arbitrary theory with a bounded initial situation description remains bounded in all executable situations (to do so we need to use verification).\nThe main result of the paper is that verification of an expressive class of firstorder \u00b5-calculus temporal properties in bounded action theories is decidable and in fact EXPTIME-complete. This means that we can check whether a system or process specified over such a theory satisfies some specification even if we have an infinite domain and an infinite set of situations or states. In a nutshell, we prove our results by focussing on the active domain of situations, i.e., the set of objects for which some atomic fluent holds; we know that the set of such active objects is bounded. We show that essentially we can abstract situations whose active domains are isomorphic into a single state, and thus, by suitably abstracting also actions, we can obtain an abstract finite transition system that satisfies exactly the same formulas of our variant of the \u00b5-calculus.\nThis work is of interest not only for AI, but also for other areas of computer science. In particular it is of great interest for the work on data-aware business processes and services [53,45,38]. Indeed while there are well-established results and tools to analyze business processes and services, without considering the data manipulated, when data are taken into account results are scarce. The present work complements that in, e.g.,\n[36,4,9,5,10], and hints at an even more profund relevance of the situation calculus in those areas [63]. More generally, our results can be recast in other reasoning about action formalisms, both in AI and in CS.\nThe rest of the paper is organized as follows. In Section 2, we briefly review the situation calculus and basic action theories. Then in Section 3, we define bounded action theories. Following that in Section 4, we discuss various ways of obtaining bounded action theories, while showing that many practical domains can be handled. In Section 5, we introduce the \u00b5\u0141p language that we use to express first-order temporal properties and its semantics. After that, we show that verification of \u00b5\u0141p properties over bounded action theories is decidable, first in the case where we have complete information about the initial situation in Section 6, and then in the general incomplete information case in Section 7. Then in Section 8, we characterize the worst-case computational complexity of the problem as EXPTIME-complete. In Section 9, we give a technique based on our verification results to check whether an arbitrary basic action theory is maintains boundedness. In Section 10, we review the related literature. Finally, in Section 11, we conclude the paper mentioning topics for future work."}, {"heading": "2 Preliminaries", "text": "The situation calculus [64,73] is a sorted predicate logic language for representing and reasoning about dynamically changing worlds. All changes to the world are the result of actions, which are terms in the language. We denote action variables by lower case letters a, action types by capital letters A, and action terms by \u03b1, possibly with subscripts. A possible world history is represented by a term called a situation. The constant S0 is used to denote the initial situation where no actions have yet been performed. Sequences of actions are built using the function symbol do, where do(a, s) denotes the successor situation resulting from performing action a in situation s. Besides actions and situations, there is also the sort of objects for all other entities. Predicates and functions whose value varies from situation to situation are called fluents, and are denoted by symbols taking a situation term as their last argument (e.g., Holding(x, s), meaning that the robot is holding object x in situation s). For simplicity, and without loss of generality, we assume that there are no functions other than constants and no non-fluent predicates. We denote fluents by F and the finite set of primitive fluents by F . The arguments of fluents (apart from the last argument which is of sort situation) are assumed to be of sort object.\nWithin this language, one can formulate action theories that describe how the world changes as the result of the available actions. Here, we concentrate on basic action theories as proposed in [66,73]. We also assume that there is a finite number of action types. Moreover, we assume that there is a countably infinite set of object constants N for which the unique name assumption holds. But we do not assume domain closure for objects.5 As a result a basic action theory D is the union of the following disjoint sets of first-order (FO) and second-order (SO) axioms:\n5 Such an assumption is made in [27], where standard names [57] are used to denote objects. Thus, the results here generalize those in [27].\n\u2013 D0: (FO) initial situation description axioms describing the initial configuration of the world (such a description may be complete or incomplete); \u2013 Dposs: (FO) precondition axioms of the form\nPoss(A(x), s) \u2261 \u03c6A(x, s),\none per action type, stating the conditions \u03c6A(x, s) under which an action A(x) can be legally performed in situation s; these use a special predicate Poss(a, s) meaning that action a is executable in situation s; \u03c6A(x, s) is a formula of the situation calculus that is uniform in situation s, that is, a formula that mentions no other situation term but s and does not mention Poss (see [73] for a formal definition);\n\u2013 Dssa: (FO) successor state axioms of the form\nF (x, do(a, s)) \u2261 \u03c6F (x, a, s),\none per fluent, describing how the fluent changes when an action is performed; the right-hand side (RHS) \u03c6F (x, a, s) is again a situation calculus formula uniform in s; successor state axioms encode the causal laws of the world being modeled; they take the place of the so-called effect axioms and provide a solution to the frame problem; \u2013 Dca: (FO) unique name axioms for actions and (FO) domain closure on action types; \u2013 Duno: (FO) unique name axioms for object constants in N ; \u2013 \u03a3: (SO) foundational, domain independent, axioms of the situation calculus [66].\nWe say that a situation s is executable, written Executable(s), if every action performed in reaching s was executable in the situation in which it occurred.\nOne of the key features of basic action theories is the existence of a sound and complete regression mechanism for answering queries about situations resulting from performing a sequence of actions [66,73]. In a nutshell, the regression operator R\u2217 reduces a formula \u03c6 about a particular future situation to an equivalent formula R\u2217[\u03c6] about the initial situation S0, by basically substituting fluent relations with the righthand side formula of their successor state axioms. Here, we shall use a simple one-step only variant R of the standard regression operator R\u2217 for basic action theories. Let \u03c6(do(\u03b1, s)) be a formula uniform in the situation do(\u03b1, s). ThenR[\u03c6(do(\u03b1, s))] stands for the one-step regression of \u03c6 through the action term \u03b1, which is itself a formula uniform in s."}, {"heading": "3 Bounded Action Theories", "text": "Let b be some natural number. We use the notation |{x | \u03c6(x)}| \u2265 b, meaning that there exist at least b distinct tuples that satisfy \u03c6, to stand for the following FOL formula:\n\u2203x1, . . . ,xb.\u03c6(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c6(xb) \u2227 \u2227\ni,j\u2208{1,...,b},i6=j\nxi 6= xj .\nWe also use the notation |{x | \u03c6(x)}| < b, meaning that there are fewer than b distinct tuples that satisfy \u03c6, to stand for: \u00ac(|{x | \u03c6(x)}| \u2265 b).\nUsing this, we define the notion of a fluent F (x, s) in situation s being bounded by a natural number b as follows:\nBoundedF,b(s) . = |{x | F (x, s)}| < b,\ni.e., fluent F is bounded by b in situation s if there are fewer than b distinct tuples in the extension of F in situation s.\nThe notion of situation s being bounded by a natural number b is defined as follows:\nBoundedb(s) . = \u2227 F\u2208F BoundedF,b(s),\ni.e., every fluent is bounded by b in situation s. We say that an action theory D is bounded by b if every executable situation is bounded by b, formally:\nD |= \u2200s.Executable(s) \u2283 Boundedb(s).\nExample 1. Consider a warehouse where items are moved around by a robot (a similar example is formalized in [30]). There are k storage locations where items can be stored. There is also a shipping dock where new items may arrive and stored items may be shipped out. We can axiomatize this domain as follows.\nWe have the following action precondition axioms:6\nPoss(move(x, l, l\u2032), s) \u2261 At(x, l, s) \u2227 IsLoc(l\u2032) \u2227 \u00ac\u2203yAt(y, l\u2032, s) Poss(arrive(x), s) \u2261 \u00ac\u2203yAt(y, ShipDock) \u2227 \u00ac\u2203lAt(x, l, s) Poss(ship(x), s) \u2261 At(x, ShipDock, s)\nThe first axiom says that in situation s, the robot can perform action move(x, l, l\u2032), i.e., move object x from location l to l\u2032, if and only if x is at l in s and l\u2032 is a location where no object is present in s. The second precondition axiom says that action arrive(x) is executable in situation s, i.e., object x may arrive at the warehouse in s, if and only if the shipping dock is empty and x is not somewhere else in the warehouse. The last axiom says that object x can be shipped in situation s if it is at the shipping dock in s.\nFor the fluent At, we have the following successor state axiom:\nAt(x, l, do(a, s)) \u2261 \u03b3(x, l, a, s)+ \u2228At(x, l, s) \u2227 \u00ac\u03b3\u2212(x, l, a, s), where \u03b3+(x, l, a, s) = \u2203r.a = move(x, l\u2032, l) \u2227At(x, l\u2032, s) \u2227 IsLoc(l\u2032) \u2227 \u00ac\u2203yAt(y, l, s)\n\u2228 a = arrive(x) \u2227 l = ShipDock and \u03b3\u2212(x, l, a, s) = \u2203l\u2032.a = move(x, l, l\u2032) \u2227 l\u2032 6= l \u2227 IsLoc(l\u2032) \u2227 \u00ac\u2203yAt(y, l\u2032, s)\n\u2228 a = ship(x) \u2227At(x, ShipDoc, s) 6 Throughout this paper, we assume that all free variables in a formula are implicitly universally\nquantified from the outside. Occasionally, to be clear, we will write \u2200\u03d5 to denote the universal closure of \u03d5 explicitly.\nThis says that object x is at location l in the situation that results from doing action a in s if and only if \u03b3(x, l, a, s)+ holds or if x is already at l in s and \u03b3\u2212(x, l, a, s) doesn\u2019t hold. \u03b3(x, l, a, s)+ specifies the conditions under which action a makes object x be at location l in situation s, i.e., if a is to move x to a free location l from another location l\u2032 where x was in s, or a is x arriving and l is the shipping dock. \u03b3\u2212(x, l, a, s) specifies the conditions under which action a makes object x cease to be at location l in situation s, i.e., a is to move x to a different location that is free, or is to ship x.\nWe specify the initial situation with the following initial state axioms:\n\u00acAt(x, l, S0) IsLoc(l) \u2261 l = ShipDock \u2228 l = SL1 \u2228 . . . \u2228 l = SLk\nWe also have unique name axioms for the locations. For clarity, we make IsLoc a nonfluent predicate, although it is easy to recast it as a fluent that is unaffected by any action.\nIt is not difficult to show that this theory is in fact bounded by k + 1. First note that there are k + 1 locations initially and the set of locations never changes, so IsLoc is bounded by k + 1. For fluent At, it is initially bounded by 0, but the arrive action can augment its extension. However, the action theory ensures there can be at most one item at each of the k+1 locations. ThusAt remains bounded by k+1. Therefore, the theory is bounded by k + 1.\nObserve that, as there are infinitely many constants denoting distinct objects, effectively an unbounded number of items may be handled by subsequent arrive, move, and ship actions. Despite this, the theory remains bounded.\nWe shall see that for bounded action theories, verification of sophisticated temporal properties is decidable."}, {"heading": "4 Obtaining Bounded Action Theories", "text": "Before focusing on verification, in this section we look at various interesting sufficient conditions that guarantee that a basic action theory is bounded. Later in Section 9, we will see that it is actually possible to use verification itself to check whether any arbitrary basic action theory, with a bounded initial situation description, is indeed bounded."}, {"heading": "4.1 Bounding by Blocking", "text": "We observe that the formula Boundedb(s) is a FO formula uniform in s and hence it is regressable for basic action theories. This allows us to introduce a first interesting class of bounded action theories. Indeed, from any basic action theory, we can immediately obtain a bounded action theory by simply blocking the execution of actions whenever the result would exceed the bound.\nLet D be a basic action theory. We define the bounded basic action theory Db by replacing each action precondition axiom in D of the form Poss(a(x), s) \u2261 \u03a6(x, s) by a precondition axiom of the form\nPoss(a(x), s) \u2261 \u03a6(x, s) \u2227R[Boundedb(do(a(x), s))] (1)\nTheorem 1. Let D be a basic action theory with the initial description D0 such that D0 |= Boundedb(S0), for some b, and let Db be the basic action theory obtained as discussed above. Then, Db is bounded by b.\nProof. By (1) it is guaranteed that any executable action leads to a bounded situation. Hence by induction on executable situations, we get the thesis.\nExample 2. Suppose that we have a camera on a smart phone or tablet computer. We could model the storage of photos on the device using a fluent PhotoStored(p, s), meaning that photo p is stored in the device\u2019s memory. Such a fluent might have the following successor state axiom:\nPhotoStored(p, do(a, s)) \u2261 a = takePhoto(p) \u2228 PhotoStored(p, s) \u2227 a 6= deletePhoto(p)\nWe may also assume that action takePhoto(p) is always executable and that deletePhoto(p) is executable in s if p is stored in s:\nPoss(takePhoto(p), s) \u2261 True Poss(deletePhoto(p), s) \u2261 PhotoStored(p, s).\nNow such a device would clearly have a limited capacity for storing photos. If we assume for simplicity that photos come in only one resolution and file size, then we can model this by simply applying the transformation discussed above. This yields the following modified precondition axioms:\nPoss(takePhoto(p), s) \u2261 |{p\u2032 | PhotoStored(p\u2032, s)}| < b\u2212 1\nPoss(deletePhoto(p), s) \u2261 PhotoStored(p, s) \u2227 |{p\u2032 | PhotoStored(p\u2032, s)}| < b+ 1.\nNote how the condition on on the right hand side of the first axiom above ensures there are fewer than b photos stored after the action of taking a photo p occurs. Clearly, the resulting theory is bounded by b (assuming that the original theory is bounded by b in S0).\nNote that this way of obtaining a bounded action theory is far from realistic in modeling the actual constraints on the storage of photos. One could develop a more accurate model, taking into account the size of photos, the memory management scheme used, etc. This would also yield a bounded action theory, though one whose boundedness is a consequence of a sophisticated model of memory capacity.\nExample 3. Let\u2019s extend the previous example by supposing that the device also maintains a contacts directory. We could model this using a fluent InPhoneDir(name, number, photo, s), with the following successor state axiom:\nInPhoneDir(na, no, p, do(a, s)) \u2261 a = add(na, no, p) \u2228 InPhoneDir(na, no, p, s) \u2227 a 6= deleteName(na) \u2227 a 6= deleteNumber(no)\nWe could then apply our transformation to this new theory to obtain a bounded action theory, getting precondition axioms such as the following:\nPoss(add(na, no, p), s) \u2261 PhotoStored(p, s) \u2227 |{p\u2032 | PhotoStored(p\u2032, s)}| < b \u2227 |{\u3008na, no, p\u3009 | InPhoneDir(na, no, p, s)}| < b\u2212 1\nThe resulting theory blocks actions from being performed whenever the action would result in a number of tuples in some fluent exceeding the bound.\nWe observe that this kind of bounded action theories are really modeling a capacity constraint on every fluent,7 which may block actions from being executed. As a result, an action may be executable in a situation in the original theory, but not executable in the bounded one. Thus an agent may want to \u201cplan\u201d to find a sequence of actions that would make the action executable again. In general, to avoid dead-ends, one should carefully choose the original action theory on which the bound is imposed, in particular there should always be actions that remove tuples from fluents."}, {"heading": "4.2 Effect Bounded Action Theories", "text": "Let\u2019s consider another sufficient condition for boundedness. Without loss of generality we can take the general form of successor state axioms to be as follows:\nF (x, do(a, s)) \u2261 \u03a6+F (x, a, s) \u2228 (F (x, s) \u2227 \u00ac\u03a6 \u2212 F (x, a, s))\nWe say that fluent F is effect bounded if:\n|{x | \u03a6+F (x, a, s)}| \u2264 |{x | \u03a6 \u2212 F (x, a, s)}|,\ni.e., for every action and situation, the number of tuples added to the fluent is less than or equal to that deleted.\nWe say that a basic action theory is effect bounded if every fluent F \u2208 F is effect bounded.\nTheorem 2. Let D be an effect bounded basic action theory with the initial situation description D0 such that D0 |= Boundedb(S0), for some b. Then D is bounded by b. Proof. By induction on executable situations.\nExample 4. Many axiomatizations of the Blocks World are not effect bounded. For instance, suppose that we have fluents OnTable(x, s), i.e., block x is on the table in situation s, and On(x, y, s), i.e., block x is on block y in situation s, with the following successor state axioms:\nOnTable(x, do(a, s)) \u2261 a = moveToTable(x) \u2228OnTable(x, s) \u2227 \u00ac\u2203y.a = move(x, y)\nOn(x, y, do(a, s)) \u2261 a = move(x, y) \u2228On(x, y, s) \u2227 \u00ac\u2203z.(z 6= y \u2227 a = move(x, z)) \u2227 a 6= moveToTable(x)\n7 The bound b applies to each fluent individually, so the total number of tuples in a situation is bounded by |F|b. Instead, one could equivalently impose a global capacity bound on the total number of tuples for which some fluent holds in a situation.\nThen, performing the action moveToTable(B1) will result in a net increase in the number of objects that are on the table (assuming that the action is executable and that B1 is not already on the table). Thus, fluent OnTable is not effect bounded in this theory.\nHowever, it is easy to develop an alternative axiomatization of the Blocks World that is effect bounded. Suppose that we use only the fluent On(x, y, s) and the single action move(x, y), where y is either a block or the table, which is denoted by the constant Table. We can axiomatize the domain dynamics as follows:\nOn(x, y, do(a, s)) \u2261 a = move(x, y) \u2228On(x, y, s) \u2227 \u00ac\u2203z.(z 6= y \u2227 a = move(x, z))\nThat is, x is on y after action a is performed in situation s if and only if a is moving x onto y or x is already on y in situation s and a does not involve moving x onto an object other than y. We say that move(x, y) is executable in situation s if and only if x is not the table in s, x and y are distinct, x is clear and on something other than y in s, and y is clear unless it is the table in s:\nPoss(move(x, y), s) \u2261 x 6= Table \u2227 x 6= y \u2227 \u00ac\u2203z.On(z, x, s) \u2227 \u2203z.(z 6= y \u2227On(x, z, s)) \u2227 (y = Table \u2228 \u00ac\u2203z.On(z, y, s))\nThen it is easy to show that any occurence of move(x, y) in a situation s where the action is executable, adds \u3008x, y\u3009 toO = {\u3008x\u2032, y\u2032\u3009 | On(x\u2032, y\u2032, s)}while deleting \u3008x, y\u2032\u2032\u3009 for some y\u2032\u2032 s.t. y\u2032\u2032 6= y, leaving |O| unchanged. Note that we must require that x be on something in the action precondition axiom to get this. Any action other than move(x, y) leaves O unchanged. Thus On is effect bounded.\nThe precondition that x be on something formove(x, y) to be executable means that we cannot move a new unknown block onto another or the table. We must of course impose restrictions on \u201cmoving new blocks in\u201d if we want to preserve effect boundedness. One way to do this is to add an action replace(x, y), i.e. replacing x by y. We can specify its preconditions as follows:\nPoss(replace(x, y), s) \u2261 x 6= Table \u2227 y 6= Table \u2227 x 6= y \u2227 \u00ac\u2203z.On(z, x, s) \u2227 \u2203z.On(x, z, s) \u2227 \u00ac\u2203z.On(z, y, s) \u2227 \u00ac\u2203z.On(y, z, s)\nThat is, replace(x, y) is executable in situation s if and only if x and y are not the table and are distinct, x is clear and on something in s, and y is clear and not on something in s. We can modify the successor state axiom for On to be:\nOn(x, y, do(a, s)) \u2261 a = move(x, y) \u2228 \u2203z.(a = replace(z, x) \u2227On(z, y, s)) \u2228On(x, y, s) \u2227 \u00ac\u2203z.(z 6= y \u2227 a = move(x, z)) \u2227 \u00ac\u2203z.(z 6= y \u2227 a = replace(x, z)),\nwhereOn(x, y) becomes true if x replaces z and z was on y in s, andOn(x, y) becomes false if z replaces x and x was on y in s. It is straightforward to show that this change leaves On effect bounded.\nExample 5. For another simple example (perhaps more practical), let\u2019s look at how we could specify the \u201cfavorite web sites\u201d menu of an internet application. We can assume that there is a fixed number of favorite web sites positions on the menu, say 1 to k. We can replace what is at position n on the menu by the URL u by performing the action replace(n, u). This can be axiomatized as follows:\nFavoriteSites(n, u, do(a, s)) \u2261 a = replace(n, u) \u2228 FavoriteSites(n, u, s) \u2227 \u00ac\u2203u\u2032.(u\u2032 6= u \u2227 a = replace(n, u\u2032))\nPoss(replace(n, u), s) \u2261 n \u2208 [1..k] \u2227 \u2203u\u2032.FavoriteSites(n, u\u2032, s) It is easy to show that in this axiomatization, FavoriteSites is effect bounded. No action, including replace(n, u), causes the extension of the fluent to increase.\nThe FavoriteSites fluent is typical of many domain properties/relations, such as the passengers in a plane, the students in a class, or the cars parked in a parking lot, where we can think of the relation as having a finite capacity, and where we can reassign the objects that are in it. In some cases, the capacity bound may be difficult to pin down, e.g., the guests at a wedding, altough the capacity is by no means unbounded. As well, there are definitely examples where we need an unbounded theory, e.g., to model a pushdown automata that can recognize a particular context-free language. The situation calculus is a very expressive language that accomodates this, for instance, it has been used to model Turing machines [73]. One might arguably want an unbounded \u201cfavorite sites\u201d menu or contacts directory, although this seems hardly practical. Another interesting question is how such capacity constraints might apply to a complex agent such as a robot that is modeling its environment. Clearly, such a robot would have limitations with respect to how many environment features/objects/properties it can memorize and track. Finally, note that the condition |{x | \u03a6+F (x, a, s)}| \u2264 |{x | \u03a6 \u2212 F (x, a, s)}| is not a FO formula and it is difficult (in fact, undecidable) in general to determine whether a basic action theory is effect bounded. But as our examples illustrate, there are many instances where it is easy to show that the bounded effects condition holds."}, {"heading": "4.3 Fading Fluents Action Theories", "text": "Fading fluents action theories are based on the idea that information over time loses strength and fades away unless it is reinforced explicitly. A fading fluents action theory with fading length given by a natural number ` is an action theory where a fluent F (x, s) is defined by making use of some auxiliary fluents Fi(x, s), for 0 \u2264 i \u2264 ` where F (x, s) . = \u2228 0\u2264i\u2264` Fi(x, s) and the auxiliary fluents have successor state axioms of the following special form:\nF`(x, do(a, s)) \u2261 \u03a6+F (x, a, s) \u2227 |{x | \u2203a.\u03a6 + F (x, a, s)}| < b\nand for 0 \u2264 i < ` we have:\nFi(x, do(a, s)) \u2261 \u00ac\u03a6+F (x, a, s) \u2227 Fi+1(x, s) \u2227 \u00ac\u03a6 \u2212 F (x, a, s).\nThus, tuples are initially added to F`, and progressively lose their strength, moving from Fi to Fi\u22121 each time an action occurs that does not delete or re-add them; eventually they move out of F0 and are forgotten. Note that:\n\u2013 Technically, a fading fluents action theory is a basic action theory having as fluents only the auxiliary fluents. \u2013 It is simple to obtain a fading fluent version of any basic action theory. \u2013 It is often convenient to include explicit refreshF (x) actions, whose effect, when\napplied to a situation s, is simply to make F`(x, do(refreshF (x, s))) true, and Fi(x, do(refreshF (x, s))) false for 0 \u2264 i < `. Similarly it may be convenient to include forgetF (x) actions, whose effect is to make Fi(x, do(forgetF (x, s))) false, for all i.\nTheorem 3. Let D be a fading fluents action theory with fading length ` and initial database D0 such that D0 |= Boundedb(S0), for some b. Then, D is bounded by b.\nProof. By induction on executable situations. For the base case, we have that initially for each fluent, we have at most b facts, hence S0 is bounded by b. For the inductive case, by the inductive hypothesis we have that Boundedb(s). Now, take an arbitrary action a(t), and an arbitrary fluent F . Then: (i) BoundedF`,b(do(a(t), s)), since positive effects are bounded by b in its successor state axiom; and (ii) for all 0 \u2264 i < `, since Fi depends on Fi+1 in the previous situation in its successor state axioms, we have that BoundedFi,b(do(a(t), s)) since BoundedFi+1,b(s) and in the worst case the whole extension of Fi+1 in s is carried over to Fi in do(a(t), s).\nExample 6. Imagine a sort of \u201cvacuum cleaner world\u201d where a robotic vacuum cleaner may clean a room or region r [75]. If a room/region is used, then it becomes unclean. We could model this using a fluent IsClean(r, s) with the following successor state axiom:\nIsClean(r, do(a, s)) \u2261 a = clean(r) \u2228 IsClean(r, s) \u2227 \u00aca = use(r)\nClearly, cleanliness is a property that fades over time. By applying the proposed transformation to this specification, we obtain the following:\nIsClean`(r, do(a, s)) \u2261 a = clean(r) \u2227 1 < b\nand for 0 \u2264 i < ` we have:\nIsCleani(r, do(a, s)) \u2261 a 6= clean(r) \u2227 IsCleani+1(r, s) \u2227 a 6= use(r)\nThis is a somewhat more realistic model where after ` steps, we forget about a room being clean.\nExample 7. Consider a robot that can move objects around. We might model this using a fluent At(objet, location, s) with the following successor state axiom:\nAt(o, l, do(a, s)) \u2261 a = moveTo(o, l) \u2228 a = observe(o, l) \u2228 At(o, l, s) \u2227 a 6= takeAway(o) \u2227 \u00ac\u2203l\u2032.l\u2032 6= l \u2227 (a = moveTo(o, l\u2032) \u2228 a = observe(o, l\u2032))\nHere, moveTo(o, l) represents the robot\u2019s moving object o to location l. We also have an action observe(o, l) of observing that object o is at location l, a kind of exogenous\naction that might be produced by the robot\u2019s sensors. As well, we have another exogenous action takeAway(o), representing another agent\u2019s taking object o to an unknown location l. If the world is dynamic, most objects would not remain where they are indefinitely, even if the robot is unaware of anyone moving them. By applying the proposed transformation to this specification, we obtain a theory where information about the location of objects fades unless it is refreshed by the robot\u2019s observations or actions. After ` steps, the robot forgets the location of an object it has not observed or moved; moreover, this happens immediately if the object is taken away by another agent.\nExample 8. As a final example, consider a softbot that keeps track of which hosts are online. We might model this using a fluent NonFaulty(host, s) with the following successor state axiom:\nNonFaulty(h, do(a, s)) \u2261 a = pingS(h) \u2228NonFaulty(h, s) \u2227 a 6= pingF (r)\nHere the action pingS(h) means that the host h has been pinged successfully, and the action pingF (h) means that the host h has not responded to a pinging within the allocated time. As time passes, we may not want to assume that currently non-faulty hosts remain non-faulty. If we apply the proposed transformation to this specification, we obtain a theory where information about hosts being non-faulty fades. The agent must periodically ping the host successfully to maintain its knowledge that the host is non-faulty.\nAn interesting natural example of such fading representations is the pheromones left by insects. Note that it is also possible to model fading with time as opposed to fading with the number of actions, though in this case we have to bound how many actions can occur between clock ticks."}, {"heading": "5 Expressing Dynamic Properties", "text": "To express properties about Situation Calculus action theories, we introduce a specific logic, inspired by the \u00b5-calculus [40,17], one of the most powerful temporal logics, subsuming both linear time logics, such as Linear Temporal Logic (LTL) [68] and PropertySpecification Language (PSL) [39], and branching time logics such as Computational Tree Logic CTL [21] and CTL\u2217 [41]. The main characteristic of the \u00b5-calculus is its ability to express directly least and greatest fixpoints of (predicate-transformer) operators formed using formulae relating the current state to the next one. By using such fixpoint constructs one can easily express sophisticated properties defined by induction or co-induction. This is the reason why virtually all logics used in verification can be considered as fragments of \u00b5-calculus. Technically, the \u00b5-calculus separates local properties, asserted on the current state or on states that are immediate successors of the current one, from properties talking about states that are arbitrarily far away from the current one [17]. The latter are expressed through the use of fixpoints. Our variant of the \u00b5-calculus is able to express first-order properties over situation. At the same time, it allows for a controlled form of first-order quantification across situations, inspired by [5], where the quantification ranges over objects that persist in the extension of some fluents across situations.\nFormally, we define the logic \u00b5\u0141p as:\n\u03a6 ::= \u03d5 | \u00ac\u03a6 | \u03a61 \u2227 \u03a62 | \u2203x.LIVE(x) \u2227 \u03a6 | LIVE(x) \u2227 \u3008\u2212\u3009\u03a6 | LIVE(x) \u2227 [\u2212]\u03a6 | Z | \u00b5Z.\u03a6\nIn addition, we use the usual FOL abbreviations for \u2228, \u2283, \u2261, and \u2200, plus the standard \u00b5-calculus abbreviation \u03bdZ.\u03a6 = \u00ac\u00b5Z.\u00ac\u03a6[Z/\u00acZ]. Let us comment on some aspects of \u00b5\u0141p:\n\u2013 \u03d5 in the expression above is an arbitrary (possibly open) uniform situationsuppressed (i.e., with all situation arguments in fluents suppressed) situation calculus FO formula, in which the only constants that may appear are those explicitly mentioned in the situation calculus theory beyond Duno, i.e., those occurring in Dposs \u222a Dssa \u222a D0.8 Observe that quantification inside \u03d5 is not subject to any restriction; in particular, LIVE(\u00b7) is not required. \u2013 The boolean connectives have their usual meaning. Quantification over individuals in \u2203x.LIVE(x)\u2227\u03a6 and \u2200x.LIVE(x) \u2283 \u03a6 (i.e., \u00ac\u2203x.LIVE(x)\u2227\u00ac\u03a6) has the expected meaning, with the proviso that individuals over which quantification ranges must belong to the active domain of the current situation, i.e., belong to the extension of some fluent in the current situation, as required by LIVE(\u00b7). \u2013 Intuitively, the use of LIVE(\u00b7) in \u00b5\u0141p ensures that objects are only considered in quantification across situations if they persist along the system evolution, while the evaluation of a formula with objects that are not present in the current extension of the fluents trivially evaluates to either false for \u2203 or true for \u2200. In particular: \u2022 LIVE(x) \u2227 \u3008\u2212\u3009\u03a6 denotes the set of situations s such that for some action a\nthat is executable in s, we have that \u03a6 holds in do(a, s), with the variables occurring free in \u03a6, x, assigned to objects that are in the active domain of the current situation s. \u2022 LIVE(x) \u2227 [\u2212]\u03a6 denotes those situations s such that for all actions a that are\nexecutable in s, we have that \u03a6 holds in do(a, s) with the variables occurring free in \u03a6 are assigned to objects that are in the active domain of the current situation s. \u2022 LIVE(x) \u2283 \u3008\u2212\u3009\u03a6 (i.e., \u00ac(LIVE(x) \u2227 [\u2212]\u00ac\u03a6)) denotes those situations s such\nthat for some action a that is executable in s, we have that \u03a6 holds in do(a, s) as long as the variables occurring free in \u03a6 are assigned to objects that are in the active domain of the current situation s. \u2022 LIVE(x) \u2283 [\u2212]\u03a6 (i.e., \u00ac(LIVE(x) \u2227 \u3008\u2212\u3009\u00ac\u03a6)) denotes those situations s such\nthat for all actions a that are executable in s, we have that \u03a6 holds in do(a, s) as long as the variables occurring free in \u03a6 are assigned to objects that are in the active domain of the current situation s.\n\u2013 Z is an SO (0-ary) predicate variable. \u2013 \u00b5Z.\u03a6 and \u03bdZ.\u03a6 are fixpoint formulas and denote respectively the least and the\ngreatest fixpoint of the formula \u03a6 seen as a predicate transformer \u03bbZ.\u03a6. To guarantee the existence of such fixpoints, as usual in the \u00b5-calculus, formulae of the form\n8 Clearly, we can get around this assumption by adding to the initial situation description, a new \u201cdummy\u201d fluent that holds for a bounded number of constants.\n\u00b5Z.\u03a6 and \u03bdZ.\u03a6 must satisfy syntactic monotonicity of \u03a6 with respect to Z, which states that every occurrence of the variable Z in \u03a6 must be within the scope of an even number of negation symbols. \u2013 \u00b5Z.\u03a6 and \u03bdZ.\u03a6 may contain free individual variables, which are those of \u03a6; technically these act as parameters of the fixpoint formula, i.e., the value of fixpoints \u00b5Z.\u03a6 and \u03bdZ.\u03a6 is determined only once an assignment to the free individual variables is given, see, e.g., [59] (chap. 10). \u2013 Finally, with a slight abuse of notation, we write LIVE(x1, . . . , xn) =\u2227 i\u2208{1,...,n} LIVE(xi), and we assume that in LIVE(x)\u2227\u3008\u2212\u3009\u03a6 and LIVE(x)\u2227 [\u2212]\u03a6,\nthe variables x are exactly the free individual variables of \u03a6, after we have substituted each bound predicate variable Z in \u03a6 by the corresponding binding fixpoint formula \u00b5Z.\u03a6\u2032 or \u03bdZ.\u03a6\u2032.\nWe can express arbitrary temporal/dynamic properties using least and greatest fixpoint constructions. For instance, to say that it is possible to eventually achieve \u03d5, where \u03d5 is a closed situation suppressed formula, we use the least fixpoint formula \u00b5Z.\u03d5\u2228\u3008\u2212\u3009Z. Similarly, we can use a greatest fixpoint formula \u03bdZ.\u03d5\u2227 [\u2212]Z to express that \u03d5 must always hold.\nExample 9. We can give several examples of properties that we may want to verify for the warehouse robot domain of Example 1. First, suppose that we want to say that it is possible to eventually have shipped all items that are in the factory. This can be expressed in our language as a least fixpoint formula:\n\u00b5Z.\u00ac\u2203x\u2203l.At(x, l) \u2228 \u3008\u2212\u3009Z\nThis formula, let\u2019s call it \u03a6eg9, corresponds to the CTL formula EF\u00ac\u2203x\u2203l.At(x, l). In the above, we rely on the fact that if there are no items left in the factory, then all items that were there must have been shipped. It is easy to check that the theory of Example 1, D1, entails that this formula holds in the initial situation S0, formally D1 |= \u03a6eg9. In fact, we can also show that the above property always holds:\nD1 |= \u03bdZ.\u03a6eg9 \u2227 [\u2212]Z.\nThis corresponds to the CTL formula AGEF\u00ac\u2203x\u2203l.At(x, l). Note that more generally, a formula \u00b5Z.\u03d5 \u2228 \u3008\u2212\u3009Z, i.e., EF\u03d5 in CTL, represents an instance of a planning problem; it is entailed by a theory if there exists an executable sequence of actions such that the goal \u03d5 holds afterwards.\nA second example property that we may want to verify is that it is possible to eventually have all items shipped out of the factory and then later to eventually have all locations filled with items. This can be expressed as follows:\nD1 |= \u00b5Z.[(\u00ac\u2203l\u2203x.At(x, l)) \u2227 \u00b5Z.(\u2200l.IsLoc(l) \u2283 \u2203x.At(x, l)) \u2228 \u3008\u2212\u3009Z)] \u2228 \u3008\u2212\u3009Z\nor equivalently in CTL notation\nD1 |= EF ((\u00ac\u2203l\u2203x.At(x, l)) \u2227 EF (\u2200l.IsLoc(l) \u2283 \u2203x.At(x, l))).\nOur next example concerns a safety property; we can show that it is always the case that if an item is at the shipping dock it can be moved away or shipped out next:\nD1 |= \u03bdZ.[(\u2203x.At(x, ShipDock)) \u2283 \u3008\u2212\u3009(\u00ac\u2203x.At(x, ShipDock))] \u2227 [\u2212]Z\nor equivalently in CTL notation\nD1 |= AG[(\u2203x.At(x, ShipDock)) \u2283 \u3008\u2212\u3009(\u00ac\u2203x.At(x, ShipDock))].\nHowever, this is not the case for other locations, as it is possible for all locations to become occupied, at which point the agent must ship the item at the shipping dock before it can transfer the item at the location of interest there:\nD1 |= \u00ac\u03bdZ.[\u2200l.(LIVE(l) \u2283 (\u2203x.At(x, l) \u2283 (LIVE(l) \u2283 \u3008\u2212\u3009(\u00ac\u2203x.At(x, l)))))] \u2227 [\u2212]Z\nwhich simplifies to (also observing that \u2203x.At(x, l) implies LIVE(l)):\nD1 |= \u00ac\u03bdZ.[\u2200l.(\u2203x.At(x, l) \u2283 \u3008\u2212\u3009(\u00ac\u2203x.At(x, l)))] \u2227 [\u2212]Z.\nBut it is always possible to clear a location in two steps:\nD1 |= \u03bdZ.[\u2200l.(\u2203x.At(x, l) \u2283 (\u3008\u2212\u3009(LIVE(l) \u2227 \u3008\u2212\u3009(\u00ac\u2203x.At(x, l)))))] \u2227 [\u2212]Z\nThe above involves quantification across situations, and we require the location involved to persist (it trivially does).\nNow, let\u2019s consider another example were we quantify across situations. We may want to say that it is always the case that if an item is in the warehouse, it is possible to have it persist until it is eventually shipped out:\nD1 |= \u03bdZ.[\u2200x.(\u2203l.At(x, l)) \u2283 \u00b5Z.(\u00ac\u2203l.At(x, l)) \u2228 LIVE(x) \u2227 \u3008\u2212\u3009Z] \u2227 [\u2212]Z.\nor equivalently in CTL notation\nD1 |= AG[\u2200x.(\u2203l.At(x, l)) \u2283 EF\u00ac\u2203l.At(x, l)].\nNote that the weaker property that it is always the case that if an item is in the warehouse, it is possible to have it shipped out eventually if it persists also holds:\nD1 |= \u03bdZ.[\u2200x.(\u2203l.At(x, l)) \u2283 \u00b5Z.(\u00ac\u2203l.At(x, l)) \u2228 (LIVE(x) \u2283 \u3008\u2212\u3009Z)] \u2227 [\u2212]Z.\nFinally, consider the property that if an item is eventually shipped, it is possible for it to eventually come back:\n\u2200x.\u2203l.At(x, l)) \u2283 AG[\u00ac\u2203l.At(x, l) \u2283 EF\u2203l.At(x, l)].\nWe cannot express this property in \u00b5\u0141p because x does not persist after it has been shipped. The closest translation\n\u2200x.LIVE(x) \u2227 \u2203l.At(x, l) \u2283 \u03bdZ.[\u00ac\u2203l.At(x, l) \u2283 \u00b5Z.(\u2203l.At(x, l)) \u2228 LIVE(x) \u2227 \u3008\u2212\u3009Z] \u2227 [\u2212]Z.\nis always false because if x is not at some location, then it is not in the active domain and LIVE(x) is false.\nNext we turn to semantics. Since \u00b5\u0141p contains formulae with free individual and predicate variables, given a model M of an action theory D with object domain \u2206 and situation domain S, we introduce a valuation (v, V ) formed by an individual variable valuation v which maps each individual variable x to an object v(x) in \u2206, and a parametrized predicate variable valuation V , which, given the valuation of the individual variables v, maps each predicate variable to Z to subset V (v, Z) of situations in S (notice that for each individual variable valuation v the mapping may change). Given a valuation (v, V ), we denote by (v, V )[x/d] the valuation (v\u2032, V \u2032) such that: (i) for every individual variable y 6= x we have v\u2032(y) = v(y) and v\u2032(x) = d, (ii) for every predicate variableZ we have V \u2032(v\u2032, Z) = V (v\u2032, Z) Sometimes we also use the notation v[x/d] to denote v\u2032 such that for every individual variable y 6= x we have v\u2032(y) = v(y) and v\u2032(x) = d. To express that v assigns the values d to the variables x, we use the notation x/d. Analogously, we denote by (v, V )[Z/E ] the valuation (v\u2032, V \u2032) such that: (i) for every individual variable x we have v\u2032(x) = v(x), (ii) for every predicate variable Y 6= Z we have V \u2032(v\u2032, Y ) = V (v, Y ), and for Z we have V \u2032(v\u2032, Y ) = E . Also we denote by adomM(s), the active (object) domain of situation s in the modelM, which is the set of all objects occurring in some FM(s) (F \u2208 F) or as the denotation inM of a constant in the set C of object constants occurring in Dposs \u222a Dssa \u222a D0. Then we assign semantics to formulae by associating to a modelM, and a valuation (v, V ) an extension function (\u00b7)M(v,V ), which maps \u00b5\u0141p formulae to subsets of S as inductively defined as follows (for clarity, we interpret explicitly also the abbreviation \u03bdZ.\u03a6):\n(\u03d5)M(v,V ) = {s \u2208 S | M, v |= \u03d5[s]} (\u00ac\u03a6)M(v,V ) = S \u2212 (\u03a6) M (v,V ) (\u03a61 \u2227 \u03a62)M(v,V ) = (\u03a61) M (v,V ) \u2229 (\u03a62) M (v,V ) (\u2203x. LIVE(x) \u2227 \u03a6)M(v,V ) = {s \u2208 S | \u2203d \u2208 adom M(s). s \u2208 (\u03a6)M(v,V )[x/d]} (LIVE(x) \u2227 \u3008\u2212\u3009\u03a6)M(v,V ) = {s \u2208 S | x/d \u2208 v and d \u2286 adom M(s) and \u2203a. (a, s) \u2208 PossM and doM(a, s) \u2208 (\u03a6)M(v,V )} (LIVE(x) \u2227 [\u2212]\u03a6)M(v,V ) = {s \u2208 S | x/d \u2208 v and d \u2286 adom\nM(s) and \u2200a. (a, s) \u2208 PossM implies doM(a, s) \u2208 (\u03a6)M(v,V )}\n(Z)M(v,V ) = V (v, Z) (\u00b5Z.\u03a6)M(v,V ) = \u22c2 {E \u2286 S | (\u03a6)M(v,V )[Z/E] \u2286 E}\n(\u03bdZ.\u03a6)M(v,V ) = \u22c3 {E \u2286 S | E \u2286 (\u03a6)M(v,V )[Z/E]}\nNotice that given a (possibly open) uniform situation-suppressed situation calculus formula \u03d5, slightly abusing notation, we denote by \u03d5[s] the corresponding formula with situation calculus argument reintroduced and assigned to situation s.\nIntuitively, the extension function (\u00b7)M(v,V ) assigns the following meaning to the \u00b5\u0141p constructs:9\n9 By mentioning situations explicitly, it is also possible to define these operators directly in second-order logic as follows [33]:\n\u00b5Z.\u03a6[s] \u2261 \u2200Z.(\u2200s\u0302.\u03a6[s\u0302] \u2283 Z(s\u0302)) \u2283 Z(s) \u03bdZ.\u03a6[s] \u2261 \u2203Z.(\u2200s\u0302.Z(s\u0302) \u2283 \u03a6[s\u0302]) \u2227 Z(s)\n\u2013 The extension of \u00b5Z.\u03a6 is the smallest subset E\u00b5 of situations such that, assigning to Z the extension E\u00b5, the resulting extension of \u03a6 is contained in E\u00b5 (with the assignments of the individual variables and the other predicate variables given by v and V , respectively). That is, the extension of \u00b5Z.\u03a6 is the least fixpoint of the operator (\u03a6)M(v,V )[Z/E]. Notice that for each valuation of the free individual variables in \u03a6 this operator will be different: the free variables act as parameters of the predicate transformer \u03bbZ.\u03a6. \u2013 Similarly, the extension of \u03bdZ.\u03a6 is the greatest subset E\u03bd of situations such that, assigning to Z the extension E\u03bd , the resulting extension of \u03a6 contains E\u03bd . That is, the extension of \u03bdZ.\u03a6 is the greatest fixpoint of the operator (\u03a6)M(v,V )[X/E].\nNotice also that when a \u00b5\u0141p formula \u03a6 is closed, its extension (\u03a6)M(v,V ) does not depend on the valuation (v, V ). In fact, the only formulas of interest in verification are those that are closed.\nObservation 1 Observe that we do not have actions as parameters of [\u2212]\u00b7 and \u3008\u2212\u3009\u00b7. However we can easily remember the last action performed, and in fact a finite sequence of previous actions. To do this, for each action type A(x), we introduce a fluent LastA(x, s) with successor state axiom:\nLastA(x, do(a, s)) \u2261 a = A(x)\nWe can also remember the second last action by introducing fluents SecondLastA(x, s) with successor state axioms:\nSecondLastA(x, do(a, s)) \u2261 LastA(x, s)\nSimilarly for the third last action, etc. In this way we can store a finite suffix of the history in the current situation and write FO formulas relating the individuals in the parameters of actions occurring in the suffix. For example, we can write (assuming for simplicity that the mentioned fluents have all the same arity):\n\u00b5Z.(\u2203x.LastA(x) \u2227 SecondLastB(x)) \u2228 \u3008\u2212\u3009Z,\ni.e., it is possible to eventually do B(x) followed by A(x) for some x.\nObservation 2 Observe that while our \u00b5\u0141p allows for quantification over objects that persist across situations, the expressiveness of bounded action theories means that we can often to avoid its use. For instance, we can easily introduce a finite number of \u201cregisters\u201d, i.e., fluents that store only one tuple, which can be used to store and refer to tuples across situations. We can do this by introducing fluents Regi(x, s) and two\nNote that\u03a6may contain free individual and predicate variables, and indeed these remain free in \u00b5Z.\u03a6 and \u03bdZ.\u03a6. In this paper, we prefer to leave the situation implicit to allow for interpreting formulas over arbitrary transition systems, including finite ones, and hence relating our logic to standard \u00b5-calculus.\nactions setRegi(x) and clearRegi to set and clear the registerRegi respectively. These are axiomatized as follows:\nRegi(x, do(a, s)) \u2261 a = setRegi(x) \u2228 Regi(x, s) \u2227 a 6= clearRegi Poss(setRegi(x), s) \u2261 \u00ac\u2203x.Regi(x, s) Poss(clearRegi, s) \u2261 \u2203x.Regi(x, s)\nFor example, we can write (assuming for simplicity that the mentioned fluents have all the same arity):\n\u00b5Z.(\u2203x.Regi(x) \u2227 F (x) \u2227 \u3008\u2212\u3009\u2203y.Regi(y) \u2227 F \u2032(y)) \u2228 \u3008\u2212\u3009Z\nThis formula says that there exists a sequence of actions where eventually the tuple referred to by register i has property F and there is an action after which it has property F \u2032. Note also that this approach can be used to handle some cases of quantification over objects that don\u2019t persist across situations."}, {"heading": "6 Verification of Bounded Action Theories with Complete Information on S0", "text": "We now show that verifying \u00b5\u0141p properties against bounded action theories is decidable. In this section we focus on action theories with complete information on the initial situation. The case of incomplete information is addressed in the next section. In particular, we assume that the extension of all fluents in the initial situation S0 is given as a (bounded) database. We further assume that the domain of interpretation for objects \u2206 is also given. Notice that, as a consequence of the presence of infinitely many object constants and the unique name assumption on them Duno, such an object domain \u2206 must be infinite.10 As a result of these two assumptions, we have that the action theory D admits only one modelM\u2206 [66], which, with a little abuse of terminology, we call the model of the action theory D (though in order to define it we need \u2206 as well).\nOur main result is the following.\nTheorem 4. Let D be a bounded action theory with initial situation described by a (bounded) database and with infinite object domain \u2206, and let \u03a6 be a closed \u00b5\u0141p formula. Then checking whether D |= \u03a6 is decidable.\nThe proof is structured as follows. Firstly, we show that actions terms can be eliminated from \u00b5\u0141p formulas with out loss of generality (cf. Section 6.1). Exploiting this, we show that only the fluent extensions in each situation and not situations themselves are relevant when evaluating \u00b5\u0141p formulas (cf. Section 6.2). In this step, we also prove that checking FO formulas and answering FO queries locally, i.e., on a given situation, are, respectively, decidable and effectively computable, under boundedness.\n10 By the way in case of action theories with a given finite object domain, verification becomes easily reducible to model checking, since the corresponding situation calculus model it is bisimilar to a finite propositional transition system.\nThen, based on the observations above, we introduce transition systems as alternative structures (to the models of situation calculus action theories), over which \u00b5\u0141p formulas can be evaluated. Transition systems are less rich than the models of situation calculus action theories, as they do not reflect, in general, the structure of the situation tree. Yet, they can accommodate the information of models needed to evaluate \u00b5\u0141p formulas (cf. Section 6.3 and 6.4). In this step, we define the notion of persistencepreserving bisimulation, i.e., a variant of standard bisimulation which requires a certain kind of isomorphism to exist between bisimilar states and their successors (cf. page 24), and prove that persistence-preserving bisimilar transition systems preserve the truthvalue of \u00b5\u0141 formulas (cf. Theorem 13). This is a key step in the proof, which allows us to reduce the verification of \u00b5\u0141p formulas over an infinite transition system to that over a bisimilar transition system that is finite.\nIn the third and fundamental step (Section 6.5), we carry out a faithful abstraction operation, and show how to actually construct a finite transition system that is persistence-preserving bisimilar to the one, infinite, induced by the model of the action theory (cf. Procedure 1 and Theorems 15 and 16). Finally, we prove that verification is decidable on finite transition systems, thus on the one induced by the model of the action theory (cf. Theorem 17).\nThe rest of this section details these steps."}, {"heading": "6.1 Suppressing Action Terms", "text": "Under uniqueness of action names, domain closure for actions, and the fact that action types are finitely many, w.l.o.g., we can remove action terms from uniform situation calculus formulas.\nTheorem 5. For every, possibly open, situation calculus FO formula \u03d5(x, s) uniform in s and with free variables x, all of object sort, there exists a situation calculus formula \u03d5\u2032(x, s) uniform in s, where no action terms occur, such that\nDca |= \u2200(\u03d5(x, s) \u2261 \u03d5\u2032(x, s)).\nProof. By induction on the structure of \u03d5. For \u03d5 = F (t, s), we have that by definition t can only contain object terms so \u03d5\u2032 = \u03d5, else \u03d5\u2032 = \u03d5. For \u03d5 = A(y) = A\u2032(y\u2032), with x \u2286 y \u222a y\u2032, if A = A\u2032, then \u03d5\u2032 = y = y\u2032, else \u03d5\u2032 = \u22a5. The case of boolean connectives is straightforward. If \u03d5 = \u2203a.\u03c6(x, a, s), consider the formula \u03d5\u2032\u2032 = \u2228 A\u2208A \u2203yA.\u03c6A(x,yA, s), with \u03c6A obtained from \u03c6(x, a, s), by replacing each occurrence of a with A(yA), where yA are fresh variables. We obviously have: Dca |= \u2200(\u03d5 \u2261 \u03d5\u2032\u2032). Now, for each \u03c6A, let \u03c6\u2032A be a formula containing no action terms, such that Dca |= \u2200(\u03c6A \u2261 \u03c6\u2032A). By induction hypothesis, such a \u03c6\u2032A exists. Finally, let \u03d5\u2032 = \u2228 A\u2208A \u2203yA.\u03c6\u2032A(x,yA, s). Clearly, \u03d5\u2032 contains no action terms and is uniform in s. By considering unique name axioms for actions and domain closure for action types (Dca), we can see that Dca |= \u2200(\u03d5\u2032\u2032 \u2261 \u03d5\u2032). Thus, since Dca |= \u2200(\u03d5 \u2261 \u03d5\u2032\u2032), the thesis follows, i.e., Dca |= \u2200(\u03d5 \u2261 \u03d5\u2032).\nSuch a result immediately extends to \u00b5\u0141p, since in \u00b5\u0141p formulas only uniform (situation suppressed) situation calculus FO subformulas can occur.\nTheorem 6. Any \u00b5\u0141p formula \u03a6 can be rewritten into an equivalent \u00b5\u0141p formula \u03a6\u2032, where no action terms occur, such that Dca |= \u2200(\u03a6 \u2261 \u03a6\u2032).\nOn the basis of this theorem, w.l.o.g., we will always rewrite \u00b5\u0141p formulas so as that actions do not occur in them."}, {"heading": "6.2 Suppressing Situation Terms", "text": "Since the FO components of \u00b5\u0141p formulas are situation-suppressed, situations are obviously irrelevant when checking \u00b5\u0141p formulas; more precisely, the FO components (thus the whole logic) are sensitive only to the interpretation of fluents (and constants) at each situation, while the situations themselves are not relevant. The impact of this observation on the evaluation of \u00b5\u0141p formulas in the general case will become evident in Section 6.4. Here, we focus on the local evaluation of FO components (on the interpretation of a single situation), or more specifically of FO situation calculus formulas uniform in s, and present some notable results that, besides being interesting per se, will be useful later on.\nGiven a basic action theory D, we denote by F the set of its fluent symbols and by C the (finite) set of constants inN explicitly mentioned inD, beyondDuno. Then given a modelM ofD with object domain\u2206 and a situation s, it is natural to associate s with a FO interpretation IM(s) . = \u3008\u2206, \u00b7I\u3009, where: (i) for every c \u2208 C, cI = cM and (ii) for every (situation-suppressed) fluent F of D, F I = {d | \u3008d, s\u3009 \u2208 FM}. The following result is an obvious consequence of the definitions above.\nTheorem 7. For any possibly open FO situation-suppressed situation calculus formula \u03d5 uniform in s, any situation s and any object variable valuation v, we have that M, v |= \u03d5[s] if and only if IM(s), v |= \u03d5.\nIn other words, when evaluating a uniform FO situation-calculus formula on a situation, one needs only focus on the interpretation relative to the situation of interest.\nNext, we show that, for bounded action theories, we have decidability of evaluation of FO formulas in spite of the object domain being infinite. Even more, we obtain that we can compute the answers to FO queries on specific situations. Notice that the latter result is not obvious, in that the object domain is infinite and, thus, so could be the answer. Importantly, these results imply that we can check action executability and compute the effects of action executions, two facts that we will strongly leverage on when checking \u00b5\u0141p formulas.\nWe begin by showing some results concerning the decidability of FO formula evaluation in an interpretation with finite predicate extensions, but infinite domain. More precisely, we consider a finite set F of predicate symbols (situation-suppressed fluents) and a finite set C (a subset of N ) of constant symbols, a (FO) interpretation I, over an infinite domain \u2206 is a tuple I = \u3008\u2206, \u00b7I\u3009, where \u00b7I assigns an extension F I over \u2206 to each predicate symbol F \u2208 F , and a distinct object cI \u2208 \u2206 to every constant in C. The active domain of an interpretation I, denoted adom(I) is the set of all the individuals occurring in the extension of some fluent F \u2208 F , or interpreting some constant c \u2208 C, in I. Moreover, for simplicity, we assume that all constants mentioned in FO formulas of interest belong to C.\nFirst, let us recall a classical result saying that FO formulas (with no function symbols other than constants) can always be rewritten as formulas with quantified variables ranging only over the active domain of the interpretation. For an interpretation I = \u3008\u2206, \u00b7I\u3009, we define the restriction of I to its active domain as the interpretation I\u0303 = \u3008adom(I), \u00b7I\u3009. In words, I\u0303 is the same interpretation as I, except that the object domain is replaced by the active domain.\nTheorem 8 (Theorem 5.6.3 of [60]). For every FO formula \u03d5, one can effectively compute a formula \u03d5\u2032, with quantified variables ranging only over the active domain, such that for any interpretation I = \u3008\u2206, \u00b7I\u3009 with infinite domain \u2206, and any valuation v, we have that I, v |= \u03d5 if and only if I\u0303, v |= \u03d5\u2032.\nThis result says that checking whether I, v |= \u03d5\u2032 requires knowing only the interpretation function \u00b7I of I, while the interpretation domain \u2206 can be disregarded. In other words \u03d5\u2032 is a domain-independent formula [1]. One way to obtain domain-independent formulas is to avoid the use of negation and instead use logical difference with respect to the active domain. The above theorem says that it is always possible to transform a FO formula to be evaluated over an infinite domain to a domain-independent one to be evaluated over the active domain only (and actually its proof gives an effective procedure to do so).\nAn immediate consequence of Theorem 8 is that if adom(I) is finite, then checking whether I, v |= \u03d5 is decidable, no matter whether the interpretation domain of I is finite or infinite. Indeed, in the former case, decidability is obvious, while in the latter, one can simply check I\u0303, v |= \u03d5\u2032, which requires only lookups on the finite extensions of fluents and, in presence of quantified variables, iterating over the finitely many elements of the active domain. Thus, we have the following result.\nTheorem 9. Given a possibly open FO formula \u03d5 and an interpretation I = \u3008\u2206, \u00b7I\u3009 with infinite \u2206, if adom(I) is finite, then, for any valuation v, checking whether I, v |= \u03d5 is decidable.\nProof. See discussion above.\nTheorem 9 can be lifted to computing all the valuations v such that I, v |= \u03d5. Let \u03d5 be a FO formula with free variables x, and I = \u3008\u2206, \u00b7I\u3009 a FO interpretation. Then, the answer on I to \u03d5 is the relation \u03d5I .= {d \u2208\u2206 | I, v |= \u03d5, for v(x) = d}. Sometimes, it is useful to fix the valuation of some variables xin \u2286 x, say v(xin) = din, and then consider the answer to \u03d5 under this partial assignment, that is, the relation \u03d5Ixin/din . = {dout \u2208 \u2206 | I, v |= \u03d5, for v(xin) = din and v(x \\ xin) = dout}11. The following theorem says that if I has an infinite domain\u2206 but a finite active domain and the answer \u03d5Ixin/din is finite, then the objects occurring in the answer come necessarily from either the active domain, or the values assigned to xin by v.\nTheorem 10. Consider a FO formula \u03d5 with free variables x. Let I be an interpretation with infinite \u2206 and finite active domain. If \u03d5Ixin/din is finite, then \u03d5 I xin/din\n\u2286 (adom(I) \u222a din)n, where n = |x \\ xin|. 11 x \\ xin denotes the tuple obtained from x by projecting out the components of xin.\nProof. By contradiction. It can be easily proven that if I, v |= \u03d5, for v(xi) = di /\u2208 (adom(I)\u222adin) and xi \u2208 x\\xin, then for any other valuation v\u2032 = v[xi/d\u2032i] such that d\u2032i \u2208 \u2206 \\ (adom(I) \u222a din), we have that I, v\u2032 |= \u03d5. Since \u2206 is infinite and adom(I) is finite, such d\u2032i are infinitely many, thus \u03d5 I xin/din is infinite. Contradiction.\nIn other words, any \u201cnew\u201d object, with respect to those in adom(I), occurring in the answer, must come from din. A direct consequence of Theorems 9 and 10 is that one can actually compute the answer on I to \u03d5.\nTheorem 11. Consider a FO formula \u03d5 with free variables x. Let I = \u3008\u2206, \u00b7I\u3009 be an interpretation with infinite\u2206 and finite active domain. If, for some valuation v such that v(xin) = din, \u03d5Ixin/din is finite, then \u03d5 I xin/din is effectively computable.\nProof. It suffices to record in \u03d5Ixin/din all those tuples dout such that for some v with v(xin) = din and v(x\\xin) = dout, it is the case that I, v |= \u03d5. Since by Theorem 10 such dout are finitely many and can be obtained using values from adom(I) \u222a din, which is finite, and, by Theorem 9, checking whether I, v |= \u03d5 is decidable, it follows that \u03d5Ixin/din is computable.\nThese results find immediate application to the case of bounded action theories. Indeed, bounded action theories guarantee that IM(s), in Theorem 7, is finite, (for s executable). Thus, by Theorem 9, for \u03d5 and v as above, we have that checking whether IM(s), v |= \u03d5 is decidable. A useful implication of this is that it is decidable to check whether an action AM(o) is executable in a given situation s. Indeed, this requires checking whether M, v |= Poss(A(x), s), with v(x) = o, which, by Theorem 7, is equivalent to IM(s), v |= \u03c6A(x), with \u03c6A(x, s) the RHS of the the precondition axiom of A, which, in turn, is decidable. Moreover, Theorem 11, can be used to show that for a bounded action theory, the effects of executing an action at a given situation, as determined the successor-state axioms, are computable and depend only on IM(s) (and the action). Indeed, we can exploit these results to get a sort of one-step regression theorem in our setting [66,73].\nTheorem 12. Let M be a model of a bounded action theory D, s an executable situation, and a = AM(o) an action, with action type A(y). Then, for any fluent F , there exists a situation-suppressed action-term-free formula \u03c6 = \u03c6(x,y) such that F IM(do\nM(a,s)) = \u03c6 IM(s) y/o , and hence F IM(doM(a,s)) is effectively computable.\nProof. Let F (x, do(a, s)) \u2261 \u03c6F (x, a, s) be the successor-state axiom for fluent F . For the extension of F at situation s\u2032 = doM(a, s), we have that \u3008p, s\u2032\u3009 \u2208 F iff M, v |= \u03c6F (x, A(y), s), for some v such that v(x) = p and v(y) = o. Notice that \u03c6F contains, in general, action and situation terms, and is uniform in s. However, by Theorem 5, it can be rewritten as an equivalent action-term-free formula \u03c6AF (x,y, s). Then, by suppressing the situation argument, we obtain: p \u2208 F IM(s \u2032) iff IM(s), v |= \u03c6AF (x,y), for some v such that v(x) = p and v(y) = o. That is, for \u03c6 = \u03c6AF , F IM(s\u2032) = \u03c6 IM(s) y/o . Thus, since by boundedness of D, F\nIM(s\u2032) is finite, Theorem 11 implies the thesis.\nThis result implies that, given IM(s) and an action a = AM(o), we can obtain the interpretation of each F at doM(a, s) by simply \u201cquerying\u201d IM(s). Hence, by taking the same interpretation of constants as inM, we can construct IM(doM(a, s)), from IM(s) and the successor-state axioms of D."}, {"heading": "6.3 \u00b5\u0141p over Transition Systems", "text": "The results presented in Section 6.1 and 6.2 suggest that, for the purpose of verification of \u00b5\u0141p formulas, one can operate on simpler structures than the models of situation calculus action theories. Indeed, as we saw, both actions and situations can be essentially disregarded. In this section, we introduce such simpler structures, namely transition systems (TS), show how \u00b5\u0141p formulas are evaluated over them, and present some important results that allow us to perform the verification on TSs instead of on the original model. The connection between models of situation calculus theories and transition systems will be discussed in Section 6.4. By Theorem 5, we can focus, without loss of generality, on a variant of \u00b5\u0141p where action terms do not occur.\nBy IntF,C\u2206 , we denote the set of all possible interpretations of the situation suppressed fluents in F and constants in C, over the object domain \u2206. A transition system (TS) (over the situation-suppressed fluents F , constants C, and object domain \u2206) is a tuple T = \u3008\u2206,Q, q0,\u2192, I\u3009, where:\n\u2013 \u2206 is the object domain; \u2013 Q is the set of states; \u2013 q0 \u2208 Q is the initial state; \u2013 \u2192\u2286 Q\u00d7Q is the transition relation; and \u2013 I : Q 7\u2192 IntF,C\u2206 is the labeling function associating each state q with an interpre-\ntation I(q) = \u3008\u2206, \u00b7I(q)\u3009 such that the constants in C are interpreted in the same way in all the states over which I is defined.\nTo interpret a \u00b5\u0141p formula over a TS T = \u3008\u2206,Q, q0,\u2192, I\u3009, we use valuations (v, V ) formed by an individual variable valuation v and a parametrized predicate variable valuation V , as in Section 5. We define the extension function (\u00b7)T(v,V ), which maps \u00b5\u0141p formulas to subsets of Q, as follows:\n(\u03d5)T(v,V ) = {q \u2208 Q | I(q), v |= \u03d5} (\u00ac\u03a6)T(v,V ) = Q\u2212 (\u03a6) T (v,V ) (\u03a61 \u2227 \u03a62)T(v,V ) = (\u03a61) T (v,V ) \u2229 (\u03a62) T (v,V ) (\u2203x. LIVE(x) \u2227 \u03a6)T(v,V ) = {q \u2208 Q | \u2203d \u2208 adom(I(q)). q \u2208 (\u03a6) T (v,V )[x/d]} (LIVE(x) \u2227 \u3008\u2212\u3009\u03a6)T(v,V ) = {q \u2208 Q | x/d \u2208 v and d \u2286 adom(I(q)) and \u2203q\u2032.q \u2192 q\u2032 and q\u2032 \u2208 (\u03a6)T(v,V )} (LIVE(x) \u2227 [\u2212]\u03a6)T(v,V ) = {q \u2208 Q | x/d \u2208 v and d \u2286 adom(I(q)) and \u2200q\u2032. q \u2192 q\u2032 implies q\u2032 \u2208 (\u03a6)T(v,V )} (Z)T(v,V ) = V (Z)\n(\u00b5Z.\u03a6)T(v,V ) = \u22c2 {E \u2286 Q | (\u03a6)T(v,V )[Z/E] \u2286 E}\nGiven a \u00b5\u0141p formula \u03a6, we say that a transition system T satisfies \u03a6 at state q, under v and V , written T, q, (v, V ) |= \u03a6, if q \u2208 (\u03a6)T(v,V ). When \u03a6 is closed on predicate variables, we omit V , as irrelevant, and write T, q, v |= \u03a6. If \u03a6 is closed on both individual and predicate variables we simply write T, q |= \u03a6. For closed formulas, we say that T satisfies \u03a6, written T |= \u03a6, if T, q0 |= \u03a6.\nFor our TSs we can prove a suitable version of the classical bisimulation invariance results for the \u00b5-calculus, which state that bisimilar TSs satisfy exactly the same \u00b5calculus formulas, see e.g., [17]. Obviously, the notion of bisimulation needed here is not the classical one, but one that takes into account the FO interpretations labeling the states of the transition systems, as well as the controlled form of quantification across states allowed in \u00b5\u0141p.\nWe first recall the standard notions of isomorphism and isomorphic interpretations. Two FO interpretations I1 = \u3008\u22061, \u00b7I1\u3009 and I2 = \u3008\u22062, \u00b7I2\u3009, over the same fluents F and constants C, are said to be isomorphic, written I1 \u223c I2, if there exists a bijection (called isomorphism) h : \u22061 7\u2192 \u22062 such that: (i) for every F \u2208 F , x \u2208 F I1 if and only if h(x) \u2208 F I2 ; (ii) for every c \u2208 C, cI2 = h(cI1). It is immediate to see that if h is an isomorphism, then so is h\u22121, and that \u223c is an equivalence relation. Intuitively, for two interpretations to be isomorphic, it is required that one can be obtained from the other by renaming the individuals in the interpretation domain. Notice that, necessarily, the interpretation domains of isomorphic interpretations have same cardinality. When needed, to make it explicit that h is an isomorphism between I1 and I2, we write I1 \u223ch I2. We denote by h|D1 the restriction of h toD1, i.e., the mapping h|D1 : D1 7\u2192 h(D1), such that h|D1(d) = h(d), for every d \u2208 D1. In addition, recall that I\u0303 = \u3008adom(I), \u00b7I\u3009 denotes the restriction of an interpretation I = \u3008\u2206, \u00b7I\u3009 to its active domain.\nThe bisimulation relation that captures \u00b5\u0141p can be defined as follows. Let T1 = \u3008\u22061, Q1, q10,\u21921, I1\u3009 and T2 = \u3008\u22062, Q2, q20,\u21922, I2\u3009 be two transition systems (over the situation-suppressed fluents and constants of an action theory D), and let H be the set of all possible bijections h : D1 7\u2192 D2, for D1 \u2286 \u22061 and D2 \u2286 \u22062. A relation B \u2286 Q1 \u00d7 H \u00d7 Q2 is a persistence-preserving bisimulation between T1 and T2, if \u3008q1, h, q2\u3009 \u2208 B implies that:\n1. I\u03031(q1) \u223ch I\u03032(q2); 2. for each q\u20321 \u2208 Q1, if q1 \u21921 q\u20321 then there exists q\u20322 \u2208 Q2 such that:\n(a) q2 \u21922 q\u20322, (b) there exists a bijection h\u2032 : adom(I1(q1))\u222aadom(I1(q\u20321)) 7\u2192 adom(I2(q2))\u222a\nadom(I2(q\u20322)) such that its restriction h\u2032|adom(I1(q1)) coincides with h and its restriction h\u2032|adom(I1(q\u20321)) is such that \u3008q \u2032 1, h \u2032|adom(I1(q\u20321)), q \u2032 2\u3009 \u2208 B;\n3. for each q\u20322 \u2208 Q2, if q2 \u21922 q\u20322 then there exists q\u20321 \u2208 Q1 such that: (a) q1 \u21922 q\u20321, (b) there exists a bijection h\u2032 : adom(I1(q1))\u222aadom(I1(q\u20321)) 7\u2192 adom(I2(q2))\u222a\nadom(I2(q\u20322)) such that its restriction h\u2032|adom(I1(q1)) coincides with h and its restriction h\u2032|adom(I1(q\u20321)) is such that \u3008q \u2032 1, h \u2032|adom(I1(q\u20321)), q \u2032 2\u3009 \u2208 B.\nNotice that requirements 2b and 3b impose the existence of a bijection h\u2032 that preserves the bijection h (in fact, the isomorphism) between the objects in adom(I1(q1)) and those in adom(I2(q2)); this essentially means that the \u201cidentity\u201d of such objects is\npreserved along the transition. Moreover, h\u2032 is required to induce an isomorphism between adom(I1(q\u20321)) and adom(I2(q\u20322)), when restricted to adom(I1(q\u20321)), such that \u3008q\u20321, h\u2032|adom(I1(q\u20321)), q \u2032 2\u3009 \u2208 B.\nWe say that a state q1 \u2208 Q1 is (persistence-preserving) bisimilar to q2 \u2208 Q2, written q1 \u2248 q2, if there exists a persistence-preserving bisimulationB between T1 and T2 such that \u3008q1, h, q2\u3009 \u2208 B, for some h; when needed, we also write q1 \u2248h q2, to explicitly name h. Finally, a transition system T1 is said to be persistence-preserving bisimilar to T2, written T1 \u2248 T2, if q10 \u2248 q20. It is immediate to see that bisimilarity between states and transition systems, i.e., the (overloaded) relation \u2248, is an equivalence relation.\nNext, we prove a result (Theorem 13) saying that \u00b5\u0141p enjoys invariance under this notion of bisimulation. To this end, we first show the result for the simpler logic \u0141P , obtained from \u00b5\u0141p by dropping the fixpoint construct. Namely, \u0141P is defined as:\n\u03a6 ::= \u03d5 | \u00ac\u03a6 | \u03a61 \u2227 \u03a62 | \u2203x.LIVE(x) \u2227 \u03a6 | LIVE(x) \u2227 \u3008\u2212\u3009\u03a6 | LIVE(x) \u2227 [\u2212]\u03a6\nSuch a logic corresponds to a first-order variant of the Hennessy-Milner Logic [50]. Note that its semantics is completely independent from the second-order valuation.\nGiven an individual variable valuation v we denote by IM(v) its image on the object domain.\nLemma 1. Consider two transition systems T1 = \u3008\u22061, Q1, q10,\u21921, I1\u3009 and T2 = \u3008\u22062, Q2, q20,\u21922, I2\u3009, two states q1 \u2208 Q1, q2 \u2208 Q2, such that q1 \u2248h q2, and two individual variable valuations v1 and v2 mapping variables to \u22061 and \u22062, respectively. If there exists a bijection h\u0302 between adom(I1(q1))\u222a IM(v1) and adom(I2(q2))\u222a IM(v2) whose restriction h\u0302|adom(I1(q1)) coincides with h and such that for each individual variable x, h\u0302(v1(x)) = v2(x), then for every formula \u03a6 of \u0141P , possibly open on individual variables, we have that:\nT1, q1, v1 |= \u03a6 if and only if T2, q2, v2 |= \u03a6.\nProof. We proceed by induction on the structure of \u03a6. For \u03a6 = \u03d5, we observe that, by Theorem 8, Ii(qi), vi |= \u03d5 if and only if I\u0303i(qi), vi |= \u03d5\u2032 (i = 1, 2), for \u03d5\u2032 the rewriting of \u03d5 as its domain-independent version. Further, since I\u03031(q1) \u223ch I\u03032(q2), and there is a bijection h\u0302 between the objects assigned to variables by v1 and v2 (even if they are not in adom(I1(q1)) or adom(I2(q2))), by the invariance of FOL wrt isomorphic interpretations, it follows that I\u03031(q1), v1 |= \u03d5\u2032 if and only if I\u03032(q2), v2 |= \u03d5\u2032. These two facts easily imply the thesis. The cases of boolean connectives are obtained by straightforward induction using the same individual valuations v1 and v2 and the same bijection h\u0302.\nFor \u03a6 = \u2203y.LIVE(y)\u2227\u03a6\u2032. Suppose that T1, q1, v1 |= \u03a6. Then, for some d1, it is the case that T1, q1, v1[y/d1] |= LIVE(y)\u2227\u03a6\u2032. Notice that this implies d1 \u2208 adom(I1(q1)), then h\u0302(d1) = h(d1) = d2, for some d2 \u2208 adom(I2(q2)), as h\u0302 coincides with h on adom(I1(q1)). Consider the individual valuation v2[y/d2]. For every variable x we have h\u0302(v1[y/d1](x)) = v2[y/d2](x) (for y we have v2[y/d2](y) = d2 = h\u0302(d1) = h\u0302(v1[y/d1](y))). Hence, using these new valuations and the same bijection h\u0302, now restricted to IM(v1[y/d1]) and IM(v2[y/d2]) (to take into account the assignments\nto y), we can apply the induction hypothesis, and conclude that T2, q2, v2[y/d2] |= LIVE(y) \u2227 \u03a6\u2032, which implies T2, q2, v2 |= \u03a6. The other direction is proven symmetrically.\nFor \u03a6 = LIVE(x) \u2227 \u3008\u2212\u3009\u03a6\u2032. Suppose that T1, q1, v1 |= (LIVE(x) \u2227 \u3008\u2212\u3009\u03a6\u2032). By definition, this implies that v1(xi) \u2208 adom(I1(q1)) for each xi \u2208 x, and there exists a transition q1 \u21921 q\u20321 such that T1, q\u20321, v1 |= \u03a6\u2032. Since q1 \u2248h q2, there exist: (i) a transition q2 \u21922 q\u20322, and (ii) a bijection h\u2032 : adom(I1(q1)) \u222a adom(I1(q\u20321)) 7\u2192 adom(I2(q2)) \u222a adom(I2(q\u20322)) such that its restriction h\u2032|adom(I1(q1)) coincides with h, its restriction h\u2032|adom(I1(q\u20321)) is an isomorphism such that I\u03031(q \u2032 1) \u223ch\u2032|adom(I1(q\u20321)) I\u03032(q\u20322), and q\u20321 \u2248h\u2032|adom(I1(q\u20321)) q \u2032 2. Now consider two new variable valuations v \u2032 1 and v\u20322, defined as follows:\n\u2013 for xi \u2208 x (for which we have that v1(xi) \u2208 adom(I1(q1))), let v\u20321(xi) = v1(xi) and v\u20322(xi) = v2(xi); \u2013 choose d1 \u2208 \u22061 and, for all y 6\u2208 x, let v\u20321(y) = d1, then: if d1 \u2208 adom(I1(q1)) \u222a adom(I1(q\u20321)), for all y /\u2208 x, let v\u20322(y) = h\u2032(d1); else, choose d2 6\u2208 adom(I2(q2)) \u222a adom(I2(q\u20322)), let, for all y /\u2208 x, v\u20322(y) = d2, and contextually extend h\u2032 so that h\u2032(d1) = d2.\nAs a result, for all variables x, we have h\u2032(v\u20321(x)) = v \u2032 2(x) (for h \u2032 possibly extended as above). Consider the bijection h\u0302\u2032 = h\u2032|adom(I1(q\u20321))\u222aIM(v\u20321). With this new bijection and the valuations v\u20321 and v \u2032 2, we can apply the induction hypothesis, and obtain that T1, q \u2032 1, v1 |= \u03a6\u2032 implies T2, q\u20322, v\u20322 |= \u03a6\u2032, and since q2 \u21922 q\u20322, we have that T2, q2, v\u20322 |= (LIVE(x)\u2227\u3008\u2212\u3009\u03a6\u2032). Now, observe that the only free variables of (LIVE(x)\u2227\u3008\u2212\u3009\u03a6\u2032) are xi \u2208 x, and that, for these, we have v\u20321(xi) = v1(xi) and v\u20322(xi) = v2(xi). Therefore, we can conclude that T2, q2, v2 |= (LIVE(x)\u2227\u3008\u2212\u3009\u03a6\u2032). The other direction can be proven in a symmetric way.\nFor \u03a6 = LIVE(x) \u2227 [\u2212]\u03a6\u2032\u2032: we observe that we can rewrite \u03a6 as \u00ac(LIVE(x) \u2283 \u3008\u2212\u3009\u03a6\u2032), with \u03a6\u2032 = \u00ac\u03a6\u2032\u2032. Then, assume that T1, q1, v1 |= (LIVE(x) \u2283 \u3008\u2212\u3009\u03a6\u2032). By definition, this implies that: (i) either for some xi \u2208 xwe have v1(xi) 6\u2208 adom(I1(q1)); or (ii) for all xi \u2208 x we have v1(xi) \u2208 adom(I1(q1)) and there exists a transition q1 \u21921 q\u20321 such that T1, q\u20321, v1 |= \u03a6\u2032. We distinguish the two cases:\n\u2013 If for some xi \u2208 x, v1(xi) 6\u2208 adom(I1(q1)), then we have that v2(xi) 6\u2208 adom(I2(q2)). Indeed, assume toward contradiction that v2(xi) \u2208 adom(I2(q2)). Since I\u03031(q1) \u223ch I\u03032(q2) it follows that the inverse h\u22121 of h is unique, hence h\u22121(v2(xi)) = v1(xi) and v1(xi) \u2208 adom(I1(q1)), getting a contradiction. Thus, we have that T2, q2, v2 6|= LIVE(x) and so T2, q2, v2 |= (LIVE(x) \u2283 \u3008\u2212\u3009\u03a6\u2032). \u2013 If for all xi \u2208 x, vi(xi) \u2208 adom(I1(q1)), we can proceed in the same way as for the case of \u03a6 = LIVE(x) \u2227 \u3008\u2212\u3009\u03a6\u2032.\nThe other direction is proven symmetrically.\nWe can now extend the result to the whole \u00b5\u0141p.\nLemma 2. Consider two transition systems T1 = \u3008\u22061, Q1, q10,\u21921, I1\u3009 and T2 = \u3008\u22062, Q2, q20,\u21922, I2\u3009, two states q1 \u2208 Q1, q2 \u2208 Q2, such that q1 \u2248h q2, and two\nindividual variable valuations v1 and v2 mapping variables to\u22061 and\u22062, respectively. If there exists a bijection h\u0302 between adom(I1(q1))\u222aIM(v1) and adom(I(2q2))\u222aIM(v2) whose restriction h\u0302|adom(I1(q1)) coincides with h and such that for each individual variable x, h\u0302(v1(x)) = v2(x), then for every formula \u03a6 of \u00b5\u0141p, closed on the predicate variables but possibly open on the individual variables, we have:\nT1, q1, v1 |= \u03a6 if and only if T2, q2, v2 |= \u03a6.\nProof. We prove the theorem in two steps. First, we show that Lemma 1 can be extended to the infinitary version of \u0141P that supports arbitrary infinite disjunction of formulas sharing the same free variables [11]. Then, we recall that fixpoints can be translated into this infinitary logic, thus guaranteeing invariance for the whole \u00b5\u0141p logic. Let \u03a8 be a possibly infinite set of open \u0141P formulas. Given a transition system T = \u3008\u2206,Q, q0,\u2192 , I\u3009, the semantics of \u2228 \u03a8 is ( \u2228 \u03a8)T(v,V ) = \u22c3 \u03c8\u2208\u03a8 (\u03c8) T (v,V ). Therefore, given a state q of T and a variable valuation v, we have T, q, v |= \u03a8 if and only if T, q, v |= \u03c8 for some \u03c8 \u2208 \u03a8 . Arbitrary infinite conjunction is obtained for free through negation. Lemma 1 extends to this arbitrary infinite disjunction. By the induction hypothesis, under the assumption of the Lemma, we can assume that for every formula \u03c8 \u2208 \u03a8 , we have T1, q10, v1 |= \u03c8 if and only if T2, q20, v2 |= \u03c8. Given the semantics of \u2228 \u03a8 above, this\nimplies that T1, q10, v1 |= \u2228 \u03a8 if and only if T2, q20, v2 |= \u2228 \u03a8 .\nIn order to extend the result to the whole \u00b5\u0141p, we translate \u00b5-calculus approximates into the infinitary \u0141P by (see [17,11]), where the approximant of index \u03b1 is denoted by \u00b5\u03b1Z.\u03a6 for least fixpoint formulas \u00b5Z.\u03a6 and \u03bd\u03b1Z.\u03a6 for greatest fixpoint formulas \u03bdZ.\u03a6. This is a standard result that holds also for \u00b5\u0141p. In particular, such approximates are as follows:\n\u00b50Z.\u03a6 = false \u03bd0Z.\u03a6 = true \u00b5\u03b2+1Z.\u03a6 = \u03a6[Z/\u00b5\u03b2Z.\u03a6] \u03bd\u03b2+1Z.\u03a6 = \u03a6[Z/\u03bd\u03b2Z.\u03a6] \u00b5\u03bbZ.\u03a6 = \u2228 \u03b2<\u03bb \u00b5 \u03b2Z.\u03a6 \u03bd\u03bbZ.\u03a6 = \u2227 \u03b2<\u03bb \u03bd \u03b2Z.\u03a6\nwhere \u03bb is a limit ordinal, and the notation \u03a6[Z/\u03bd\u03b2Z.\u03a6] denotes the formula obtained from \u03a6 by replacing each occurrence of Z by \u03bd\u03b2Z.\u03a6. By Tarski and Knaster Theorem [84], the fixpoints and their approximates are connected by the following properties: given a transition system T and a state q of T ,\n\u2013 q \u2208 (\u00b5Z.\u03a6)T(v,V ) if and only if there exists an ordinal \u03b1 such that s \u2208 (\u00b5 \u03b1Z.\u03a6)T(v,V )\nand, for every \u03b2 < \u03b1, it holds that s 6\u2208 (\u00b5\u03b2Z.\u03a6)M(v,V ); \u2013 q 6\u2208 (\u03bdZ.\u03a6)T(v,V ) if and only if there exists an ordinal \u03b1 such that s 6\u2208 (\u03bd\n\u03b1Z.\u03a6)T(v,V ) and, for every \u03b2 < \u03b1, it holds that q \u2208 (\u03bd\u03b2Z.\u03a6)M(v,V ).\nSince each approximate, including the ones corresponding exactly to the least and greatest fixpoints, can be written as an infinitary \u0141P formula, we get the thesis.\nWith this lemma in place we can prove the invariance result.\nTheorem 13. Consider two transition systems T1 = \u3008\u22061, Q1, q10,\u21921, I1\u3009 and T2 = \u3008\u22062, Q2, q20,\u21922, I2\u3009. If T1 \u2248 T2, then, for every \u00b5\u0141p closed formula \u03a6\nT1 |= \u03a6 if and only if T2 |= \u03a6.\nProof. If T1 \u2248 T2 then for some bijection h we have q10 \u2248h q20. This implies that I\u03031(q10) \u223ch I\u03032(q20). Now consider the variable valuations v1 and v2 defined as follows (notice that since \u03a6 is closed such individual valuations are irrelevant in evaluating it): choose an arbitrary d1 \u2208 \u22061 and let, for all variables x, v1(x) = d1; if d1 \u2208 adom(I1(q1)), let, for all x, v2(x) = h(d1); else, choose d2 6\u2208 adom(I2(q2)) and let, for all x, v\u20322(x) = d2.\nNow, define a bijection h\u2032 such that for all d \u2208 adom(I(q1)), h\u2032(d) = h(d), and if d1 6\u2208 adom(I1(q1)), h\u2032(d1) = d2. It can be seen that h\u2032 is a bijection between adom(I1(q1) \u222a IM(v1) and adom(I2(q2) \u222a IM(v2) such that I\u03031(q1) \u223ch\u2032|adom(I1(q1)) I\u03032(q2) and for all variables x, h\u2032(v1(x)) = v2(x). Hence, by Lemma 2, we get the thesis.\nThus, to check whether a transition system T satisfies a \u00b5\u0141p formula \u03a6, one can perform the check on any transition system T \u2032 that is bisimilar to T . This is particularly useful in those cases where T is infinite-state but admits some finite-state bisimilar transition system. We exploit this result later on."}, {"heading": "6.4 Transition Systems Induced by a Situation Calculus Theory", "text": "Among the various TSs, we are interested in those induced by models of the situation calculus action theoryD. Consider a modelM ofD with object domain\u2206 and situation domain S. The TS induced byM is the labelled TS TM = \u3008\u2206,Q, q0, I,\u2192\u3009, such that:\n\u2013 Q = S is the set of possible states, each corresponding to a distinct executable situation in S; \u2013 q0 = SM0 \u2208 Q is the initial state, with SM0 the initial situation of D; \u2013 \u2192 \u2286 Q\u00d7Q is the transition relation such that q \u2192 q\u2032 iff there exists some action a such that \u3008a, q\u3009 \u2208 PossM and q\u2032 = doM(a, q). \u2013 I : Q 7\u2192 IntF,C\u2206 is the labeling function associating each state (situation) q with the interpretation I(q) = IM(q).\nAs it can be seen, the TS induced by a modelM is essentially the tree of executable situations, with each situation labelled by an interpretation of fluents (and constants), corresponding to the interpretation associated byM to that situation. Notice that transitions do not carry any information about the corresponding triggering action.\nWe can now show that the semantics of \u00b5\u0141p on a model can alternatively be given in terms of the corresponding induced TS.\nTheorem 14. LetD be an action theory,M a model ofD with (infinite) object domain \u2206 and situation domain S, and TM the corresponding induced TS. Then for every \u00b5\u0141p formula \u03a6 (with no occurrence of action terms) we have that:\n(\u03a6)M(v,V ) = (\u03a6) TM (v,V )\nProof. By induction on the structure of \u03a6. For the base case of an open uniform situation-suppressed situation calculus formula \u03d5, we need to prove that\n(\u03d5)M(v,V ) = {s \u2208 S | M, v |= \u03d5[s]} = (\u03d5) TM (v,V ) = {s \u2208 S | I(s), v |= \u03d5}.\nThis is indeed the case: since no action terms occur in \u03d5 and \u03d5 is uniform in s, the evaluation of \u03d5 depends only on the interpretation of each fluent (and constant) at s, i.e., on IM(s). Once this base case is settled, the inductive cases are straightforward."}, {"heading": "6.5 Abstract Finite-State Transition System", "text": "As shown above, satisfaction of \u00b5\u0141p formulas is preserved by persistence-preserving bisimulations. This holds even between an infinite- and a finite-state TS. When this is the case, the verification can be performed on the finite TS using standard \u00b5-calculus model checking techniques, which essentially perform fixpoint computations on a finite state space. We next show how, for the case of bounded theories, one can construct a finite TS TF that is bisimilar to the TS TM induced byM.\nWe construct TF using Procedure 1. The procedure takes as input an action theory D (with complete information on the initial situation) bounded by b and a model M of D with infinite object domain \u2206,12 and returns a finite-state TS TF bisimilar to TM. TF is built incrementally, through iterative refinements of the set of states Q, the interpretation function I, and the transition relation \u2192. Initially, Q contains only the initial state q0 (line 2); I(q0) interprets constants and fluents in the same way asM at the initial situation (line 3); and\u2192 is empty (line 4). The set Qte contains the states of TF to be \u201cexpanded\u201d (initially q0 only, line 5); this is done at each iteration of the while loop (lines 6\u201320), as explained next.\nFirstly, a state q is extracted from Qte (lines 7 and 8). Then, a finite subset O of objects from \u2206 is defined (line 9). The values from O, together with those from adom(I(q)), are used, in combination with the action types, to generate actions executable on the interpretation I(q)13 (lines 10,11). The particular choice ofO guarantees that the set of generated actions, while finite, is fully representative, for the purpose of verification, of all the (possibly infinitely many) actions executable on I(q) (see Theorem 16). Moreover, the objects are chosen so as to maximize reuse of the objects occurring in the interpretation of the states already in Q.\nThe actual expansion step consists in computing, for each generated action, the interpretation I \u2032 obtained by executing the action on (a situation with interpretation) I(q). This is done by computing, on I(q), the answers to the right-hand side \u03c6(a,y) of the (situation-suppressed) successor state axiom of each fluent F , with a set to the current action (line 12). Once I \u2032 has been computed, two cases are possible: either it is isomorphic to some interpretation I(q\u2032) labeling an existing state q\u2032 \u2208 Q (line 13), under some isomorphism that preserves I(q), or it is not (line 15). In the former case, the transition relation is simply updated with a transition from q to q\u2032 (line 14) and no new state is generated. We stress that, in this case, the isomorphism is defined over the whole \u2206, not only over the active domains of the interpretations. In the latter case, a\n12 In fact, given the object domain \u2206, the model M is fully determined by D modulo object renaming. 13 Notice that since Poss(a, s) is uniform in s, the situation does not play any role in establishing whether, for given a and s, Poss(a, s) holds. In fact, only the interpretation of fluents (and constants) at s matters. Consequently, one can take such an interpretation and safely suppress the situation argument.\nProcedure 1 Computation of a finite-state TS persistence-preserving bisimilar to TM. Input: A basic action theory D bounded by b, with complete information on S0, and a model M of D with infinite object domain \u2206 Output: A finite-state TS TF = \u3008\u2206,Q, q0, I,\u2192\u3009 persistence-preserving bisimilar to TM 1: let F the set of fluents of D, C the set of constants explicitly mentioned in D; 2: let Q := {q0}, for q0 a fresh state; 3: let I(q0) = IM(SM0 ); 4: let\u2192 := \u2205; 5: let Qte := {q0}; 6: while (Qte 6= \u2205) do 7: pick q \u2208 Qte; 8: let Qte := Qte \u2212 {q}; 9: let O \u2286 \u2206 be any (finite) set of objects such that:\n(i) |O| = max{|x| | A(x) \u2208 A}; (ii) O \u2229 adom(I(q)) = \u2205; (iii) |O \u2229 \u22c3 q\u2208Q adom(I(q))| is maximal (subject to (i) and (ii)).\n10: for all action types A(x) of D do 11: for all valuations v such that v(x) \u2208 (adom(I(q)) \u222aO)|x| and I(q), v |= Poss(A(x)) do 12: let I\u2032 = \u3008\u2206, \u00b7I \u2032 \u3009 be an interpretation such that: (i) cI = cM, for all constants in\nC; (ii) F I \u2032 = {d | I(q), v[y/d] |= \u03c6F (A(x),y)}, for \u03c6F (a,y) the (situation-\nsuppressed) RHS of the SSA of fluent F . 13: if (there exists q\u2032 \u2208 Q and an isomorphism h between I\u2032 and I(q\u2032) that is the identity on adom(I(q))) then 14: \u2192 :=\u2192\u222a {q \u2192 q\u2032}; 15: else 16: let Q := Q ] {q\u2032}, for q\u2032 a fresh state;\nI(q\u2032) := I\u2032; \u2192 :=\u2192\u222a {q \u2192 q\u2032}; Qte := Qte ] {q\u2032};\n17: end if 18: end for 19: end for 20: end while 21: return TF = \u3008\u2206,Q, q0, I,\u2192\u3009\nfresh state q\u2032 with labeling I(q\u2032) is added to Q, and the transition relation is updated with q \u2192 q\u2032 (lines 16). Further, q\u2032 is also added to Qte, so as to be expanded in future iterations. The procedure iterates over the expansion step until the set Qte is empty, i.e., unitl there are no more states to expand.\nWe observe that the choice of q\u2032 at line 14 guarantees the existence of an isomorphism h\u2032 between I \u2032 and I(q\u2032) that is the identity on adom(I(q)). That is, any object occurring in I \u2032 that comes from I(q) must be mapped into itself. The purpose of this choice is to avoid adding a fresh state q\u2032\u2032 (with interpretation I \u2032) toQ but reuse any state q\u2032 already in Q, if bisimilar to the candidate q\u2032\u2032. This is a key step for the procedure to construct a transition system that is both finite and persistence-preserving bisimilar to TM.\nWe can now show that Procedure 1 terminates and returns a TS persistencepreserving bisimilar to TM. This result is split into two main results: Theorem 15, which shows that the procedure terminates, returning a finite TS, and Theorem 16, which shows that the obtained TS is indeed persistence-preserving bisimilar to TM.\nTo prove termination, we first derive a bound on the active domain of the interpretations labeling the states in Q.\nLemma 3. There exists a value b\u2032 = \u2211 F\u2208F b \u00b7 aF + |C| such that, at any iteration of Procedure 1 and for any q \u2208 Q, |adom(I(q))| \u2264 b\u2032, where b is the value bounding D, aF the arity of fluent F , and C the set of constants explicitly mentioned in D.\nProof. We first show that: (\u2020) for every q \u2208 Q, there exists a situation s executable in D such that I(q) = IM(s). This intuitively means that, modulo situation suppression, every state of TF is labelled by an interpretation that matches that ofM on constants and fluents at some executable situation s.\nThe proof is by induction on Q. For q0, the thesis follows by the definition of I(q0) at line 3, as SM0 is executable. For the induction step, consider q \u2208 Q and assume, by the induction hypothesis, that I(q) is as above, for an executable situation s. Then, for any valuation (of object variables) v, we have that I(q), v |= Poss(A(x)) if and only if IM(s), v |= Poss(A(x)), that is, by Theorem 7, M, v\u2032 |= Poss(A(x), \u03c3), for \u03c3 a situation variable and v\u2032 a situation calculus variable assignment analogous to v on all individual variables and such that v\u2032(\u03c3) = s. Thus, by line 11, A(x) is executable at s (with respect to M and v). Similarly, for any fluent F and valuation v, we have that I(q), v |= \u03c6F (A(x),y) iff M, v\u2032 |= \u03c6F (A(x),y, \u03c3), that is, since F (y, do(a, \u03c3)) \u2261 \u03c6F (a,y, \u03c3) (by definition of successor-state axiom), I(q), v |= \u03c6F (A(x),y) iff M, v\u2032 |= F (y, do(A(x), \u03c3)). But then, since by line 12, F I \u2032 = {d \u2208 \u2206 | I(q), v[y/d] |= \u03c6F (A(x),y)}, it follows that I \u2032, v |= F (y) iff M, v\u2032[y/d] |= F (y, do(A(x), \u03c3)). Thus, F I\u2032 = {d \u2208 \u2206 | M, v\u2032[y/d] |= F (x, do(A(x), \u03c3))}. Therefore, when a state q\u2032 is added to Q (line 16), its labeling I(q\u2032) = I \u2032 is such that I(q\u2032) = IM(doM(AM(v(x)), s)). This proves (\u2020).\nObserve that (\u2020) and the boundedness of D imply, together, that |adom(I(q))| is bounded, for any q \u2208 Q. We denote by b\u2032 the bound on |adomM(s)|, for any executable situation s of D, and on |adom(I(q))|, for q \u2208 Q. Notice that, in general, b\u2032 is different than b, in that the former bounds the number of objects occurring in the interpretations, while the latter bounds the number of tuples in the interpretation of fluents. To obtain\nb\u2032, observe that if the theory is bounded by b, then, for any model, the extension of each fluent F \u2208 F at any executable situation contains at most b distinct tuples. Thus, the extension of the generic fluent F cannot contain, at any executable situation, more than aF \u00b7 b distinct objects, where aF is the arity of F (the maximum number of tuples, each with distinct objects, distinct also from all others in the extension). As a result, the extensions cannot contain, overall, more than \u2211 F\u2208F aF \u00b7 b distinct objects. Hence, considering that I(q) interprets both the fluents in F and the constants in C, it follows that |adom(I(q))| \u2264 \u2211 F\u2208F aF \u00b7 b+ |C| . = b\u2032.\nThen, we use the obtained bound to show that also the set of all objects occurring in the labelings of some state in Q, denoted adom(Q), is bounded.\nLemma 4. Let adom(Q) = \u22c3 q\u2208Q adom(I(q)). At any iteration of Procedure 1, we have that |adom(Q)| \u2264 2b\u2032 + N , for b\u2032 the bound on |adom(I(q))| defined as in Lemma 3, and N the maximum number of parameters of the action types in D.\nProof. By induction on the size of Q. For Q = {q0}, we have that adom(Q) = adom(I(q0)), thus the thesis follows as, by Lemma 3, |adom(I(q0))| < b\u2032. For Q = {q0, . . . , qn}, assume, by induction hypothesis, that |adom(Q)| < 2b\u2032+N . Since, by Lemma 3, the state q \u2208 Qte \u2286 Q picked at line 7 is such that |adom(I(q))| \u2264 b\u2032 and \u2206 is infinite, then, by Theorem 10 (after applying Theorem 5, if action terms have to be suppressed in \u03c6F ), I \u2032 (line 12) is such that adom(I \u2032) \u2286 adom(I(q)) \u222a v(x).14 Now, observe that v(x) may take values from O and that the constraints on the choice of O (line 9) require that the reuse of objects from adom(Q) be maximized. That is, including fresh objects (with respect to adom(Q)) in O is allowed (in fact, required) only if needed to guarantee that |O| = |x| (whileO\u2229adom(I(q)) = \u2205). Thus, two cases are possible: either |adom(Q) \\ adom(I(q))| < |x| (in which case fresh objects must be added to O), or not. In the first case, because |x| \u2264 N and adom(I(q)) \u2286 adom(Q), it follows that |adom(Q)| \u2212 |adom(I(q))| < N . Thus, since |adom(I(q))| \u2264 b\u2032, we have that |adom(Q)| < N + b\u2032. From this, observing that |adom(I(q\u2032))| \u2264 b\u2032, we obtain |adom(Q \u222a {q\u2032})| \u2264 2b\u2032 + N . In the second case, O contains no fresh objects, thus |adom(Q \u222a {q\u2032})| = |adom(Q)| \u2264 2b\u2032 +N .\nExploiting this result, we can prove termination.\nTheorem 15. Procedure 1 terminates and returns a finite-state transition system TF .\nProof. Firstly, observe that, as a consequence of Lemma 4: (i) checking whether I(q), v |= Poss(A(x)) (line 11) is decidable, and (ii) F I\u2032 (line 12) is computable. These, indeed, are implied by the fact that |adom(I(q))| is bounded, thus finite, and by Theorems 9 and 11, respectively. To apply these theorems, however, one needs to suppress action terms first, if present, in formulas \u03c6F (A(x),y) and \u03c6A(x). To this end, Theorem 5 can be used. Notice also that computability of F I(q0) (line 3) is a direct consequence of the fact that D has complete information and is bounded, therefore the extension of all fluents at S0 is finite. Items (i) and (ii) above guarantee that all the atomic steps of Procedure 1 can be completed in finite time.\n14 To simplify the notation, we use v(x) for the set {v(x1), . . . , v(xn)}.\nNext, we prove that eventually Qte = \u2205. Observe that, since A (i.e., the set of action types of D), Q, O, adomM(S0), and adom(I(q)) are finite, it follows that, at every iteration of the while-loop (lines 6\u201320), the nested loops (lines 10\u201319) terminate; thus, proving that Qte becomes empty in a finite number of steps is sufficient to prove that only a finite number of iterations are executed and, hence, the procedure terminates. Obviously, this also implies that the returned Q, thus TF , is finite.\nTo see that eventuallyQte = \u2205, notice thatQ is inflationary, i.e., states, once added, are never removed. Consequently, objects can be added to adom(Q) (when a fresh q\u2032 is added) but not removed. This, together with the fact that, by Lemma 4, |adom(Q)| is bounded, implies that, from some iteration i on, adom(Q) remains unchanged. Let AQi be adom(Q) at iteration i (and at subsequent steps). Obviously, after that point, if a fresh state q\u2032 is added, it must be such that adom(I(q\u2032)) \u2286 AQi. Notice that, even though adom(Q) cannot change, this is not the case for Q. Indeed, new states q\u2032 could still be added, as long as I(q\u2032) = I \u2032 contains only objects from AQi. However, since |adom(Q)|, thus |AQi|, is bounded, only finitely many interpretations I \u2032 can be built using values from AQi. Consequently, if new states keep being introduced after i, it follows that, from some step i\u2032 on, the interpretation I \u2032 generated at line 12 matches the interpretation I(q\u2032) of some q\u2032 already in Q. Hence, from i\u2032 on, the condition at line 13 is always satisfied (with h the identity function), and no fresh state q\u2032 can be added toQ any more. Therefore, no new state is added to Qte (line 16), which becomes eventually empty, as at every iteration one state is extracted from it (line 7). This completes the proof.\nFinally, we show that the returned TF retains all the information needed to check whetherM |= \u03a6. That is, by Theorem 13, we show that TF is persistence-preserving bisimilar to TM.\nTheorem 16. The TS TF computed by Procedure 1, on a basic action theory D (with complete information) bounded by b and a modelM for D, is persistence-preserving bisimilar to the TS TM induced byM.\nProof. Let TF = \u3008\u2206,Q, q0, IF ,\u2192F \u3009 and TM = \u3008\u2206,R, r0, IM,\u2192M\u3009, and define the relation B \u2286 Q \u00d7H \u00d7 R such that \u3008q, h, r\u3009 \u2208 B if and only if I\u0303F (q) \u223ch I\u0303M(r) (for any h). Notice that, since TF and TM have the same object domain \u2206, h can always be extended to a standard isomorphism h\u0302 between IF (q) and IM(r): namely, one can take any bijection h\u0302 : \u2206 7\u2192 \u2206 such that h\u0302|adom(IF (q)) = h.\nWe show that B is a persistence-preserving bisimulation between TF and TM. (page 24). Consider a tuple \u3008q, h, r\u3009 \u2208 B. Requirement 1 of the definition is trivially satisfied by the definition of B. As to requirement 2, let q\u2032 \u2208 Q be such that q \u2192F q\u2032. As shown in the proof of Theorem 15, there exists an executable situation s such that IF (q) = IM(s). Moreover, by the definition of TM, r is a situation such that IM(r) matches the interpretation given byM to fluents at r. Because q \u2192F q\u2032, by the construction of TF in Procedure 1 (line 11), we have that, for some valuation v and action type A, IF (q), v |= Poss(A(x)), that is, by the existence of s as above, M, v |= Poss(A(x), s). Then, by extending h to an isomorphism h\u0302 between IF (q) and IM(r), as discussed above, we can see that IM(r), v\u2032 |= Poss(A(x), r), for v\u2032 = h\u0302\u25e6v, which implies that M, v\u2032 |= Poss(A(x), r). Therefore, by the definition of TM, for\nr\u2032 = doM(AM(h\u0302(v(x)), r) \u2208 R, we have that r \u2192M r\u2032. Thus requirement 2a is fulfilled.\nNext, we show the existence of an isomorphism h\u0302\u2032 between IF (q\u2032) and IM(r\u2032) that extends h. Once proven, this implies the existence of a bijection h\u2032 : adom(q) \u222a adom(q\u2032) 7\u2192 adom(r) \u222a adom(r\u2032) such that h\u2032|adom(IF (q)) = h and I\u0303F (q\u2032) \u223ch\u2032|adom(IF (q\u2032)) I\u0303M(r \u2032). Indeed, it is sufficient to take h\u2032 = h\u0302\u2032|adom(q)\u222aadom(q\u2032). Thus, the existence of h\u0302\u2032 implies requirement 2b. To prove that such an h\u0302\u2032 exists, we distinguish two cases: (i) when the transition q \u2192F q\u2032 is added at line 16 (i.e., q\u2032 is a fresh state), and (ii) when it is added at line 14 (i.e., q\u2032 is already in Q). For case (i), observe that IM(r\u2032) can be obtained by applying the right-hand side of the successor-state axiom of each fluent F to IM(r) (see Theorem 12), which is also the way to obtain IF (q\u2032) from IF (q), according to Procedure 1. Then, since h\u0302 is an isomorphism between IF (q) and IM(r), we have that IM(r) = h\u0302(IF (q)), where h\u0302(IF (q)) denotes the interpretation obtained from IF (q) by renaming its objects according to h\u0302. Because v\u2032 = h\u0302 \u25e6 v, it can be checked that IM(r\u2032) = h\u0302(IF (q\u2032)), thus h\u0302\u2032 = h\u0302 is an isomorphism between IF (q\u2032) and IM(r\u2032), which obviously extends h. For case (ii), let I \u2032 be the interpretation obtained by applying the successor-state axioms to IF (q). By the discussion above, we have that IM(r\u2032) = h\u0302(I \u2032), while, in general, I \u2032 6= IF (q\u2032). However, the condition at line 13 guarantees the existence of an isomorphism g such that I \u2032 = g(IF (q\u2032)), that is the identity on adom(IF (q)). Now, consider h\u0302\u2032 = h\u0302 \u25e6 g. Being a composition of isomorphisms, h\u0302\u2032 is an isomorphism itself, in particular such that IM(r\u2032) = h\u0302\u2032(IF (q\u2032)). Moreover, h\u0302\u2032 extends h|adom(IF (q)). This is a straightforward consequence of the facts that h\u0302 extends h and g is the identity on adom(IF (q)), which imply that h\u0302\u2032 matches h on adom(IF (q)). Thus, requirement 2 is fulfilled. The proof for requirement 3 follows the same argument, with h replaced by its inverse h\u22121.\nSince B is a persistence-preserving bisimulation, the fact that \u3008q0, h0, r0\u3009 \u2208 B, for h0 the identity, completes the proof.\nNext we prove that checking whether TF satisfies a \u00b5\u0141p formula, is decidable.\nTheorem 17. Given a transition system T = \u3008\u2206,Q, q0, I,\u2192\u3009, if Q is finite and, for every q \u2208 Q, adom(I(q)) is finite, then for every \u00b5\u0141p formula \u03a6, checking whether T |= \u03a6 is decidable.\nProof. Firstly, by applying Theorem 6 followed by Theorem 8 to the FO components of \u03a6, we rewrite \u03a6 as an equivalent \u00b5\u0141p (closed) formula \u03a6\u2032 where no action terms occur and whose FO components are domain-independent. Once done so, the theorem is a consequence of the finiteness of Q and adom(q), for q \u2208 Q. Under these assumptions, (\u03a6\u2032)T(v,V ) is easily computable by recursive applications of the definition of (\u00b7)T(v,V ) (page 23). In particular, for the base case of \u03a6\n\u2032 a FO formula \u03d5\u2032, since \u03d5\u2032 is action-term-free and domain-independent, one can apply Theorem 9. As to quantified variables (outside the FO components), they can be easily dealt with, by the finiteness of adom(q). The other cases are straightforward.\nFinally, putting all the above results together, we obtain Theorem 4, by observing that one can compute TF using Procedure 1 and then check whether TF |= \u03a6 by Theorem 17. Termination and correctness of this construction are guaranteed by Theorems 13, 15, and 16.15"}, {"heading": "7 Dealing with Incomplete Information", "text": "In this section, we address the case of partial information on the initial situation, by assuming that D0 is a set of axioms characterizing a possibly infinite set of bounded initial databases. Also in this case, we focus on theories whose models have infinite object domains (as we have infinitely many distinct constants).\nWe first prove that whenever two models interpret their respective initial situations in isomorphic ways, they are persistence-preserving bisimilar. We observe that this result holds independently of the cardinalities of the object domains of the models.\nTheorem 18. Let D be a bounded basic action theory. For every two modelsM and M\u2032 of D, with possibly different infinite object domains \u2206 and \u2206\u2032, respectively, if I\u0303M(SM0 ) \u223c I\u0303M\u2032(SM \u2032 0 ), then TM \u2248 TM\u2032 .\nProof. Let TM = \u3008\u2206,Q, q0,\u2192, I\u3009 and TM\u2032 = \u3008\u2206\u2032, Q\u2032, q\u20320,\u2192\u2032, I \u2032\u3009. We prove a stronger claim, i.e., that the relation B \u2286 Q \u00d7 H \u00d7 Q\u2032 such that \u3008q1, h, q2\u3009 \u2208 B if and only if I\u0303(q1) \u223ch I\u0303 \u2032(q2) (for any h), is a persistence-preserving bisimulation relation between TM and TM\u2032 . This result, once proven, implies the thesis; indeed, by I\u0303M(SM0 ) \u223c I\u0303M\u2032(SM \u2032 0 ), we have that there exists h\u0304 such that I\u0303(SM0 ) \u223ch\u0304 I\u0303(SM \u2032\n0 ), thus, by the definition of B, \u3008SM0 , h\u0304, SM \u2032\n0 \u3009 \u2208 B, that is, \u3008q0, h\u0304, q\u20320\u3009 \u2208 B, as q0 = SM0 and q\u20320 = S M\u2032 0 .\nLet \u3008q1, h, q2\u3009 \u2208 B. Requirement 1 of the definition of bisimulation (page 24) is clearly satisfied. For requirement 2, first recall that, by definition of induced transition system (page 28), I(q1) = IM(q1) and I \u2032(q2) = IM\u2032(q2), thus I\u0303M(q1) \u223ch I\u0303M\u2032(q2). Assume that there exists q\u20321 \u2208 Q such that q1 \u2192 q\u20321. By definition of transition system induced by M (page 28), there exist an action type A and a valuation v such thatM, v |= \u03c6A(x, q1), for Poss(A(x), s) \u2261 \u03c6A(x, s) the precondition axiom of A. This is equivalent to IM(q1), v |= \u03c6A(x), for \u03c6A(x) the situation-suppressed version of \u03c6A(x, s). Now, let \u03c6\u2032A(x) be the domain-independent version of \u03c6A(x). By Theorem 8, we have that IM(q1), v |= \u03c6A(x) if and only if I\u0303M(q1), v |= \u03c6\u2032A(x). If we extend h to v(x) in a way such that we obtain a bijection h\u0302 (by a cardinality argument, this is always possible), then, because I\u0303M(q1) \u223ch I\u0303M\u2032(q2), we have that I\u0303M(q1), v |= \u03c6\u2032A(x) if and only if I\u0303M\u2032(q2), h\u0302 \u25e6 v |= \u03c6\u2032A(x). But then, again by Theorem 8, IM\u2032(q2), h\u0302 \u25e6 v |= \u03c6A(x). Thus, by reintroducing the situation argument in \u03c6A, we have thatM\u2032, v\u2032 |= \u03c6A(x, q2), that is, there exists an action a\u2032 = AM \u2032 (h\u0302(v(x)))\n15 Notice that no assumption is made on the object domain \u2206 ofM except for it to be infinite. Hence, these results hold also if we assume standard names for object domains, as done in [27]: in that case the object domain is infinite but numerable and coincides with the set of constantsN (this requires a second-order domain closure axiom).\nsuch that \u3008a\u2032, q2\u3009 \u2208 PossM \u2032 . Therefore, by the definition of TM\u2032 , it follows that q2 \u2192 q\u20322, for q\u20322 = doM(a\u2032, q2). This proves requirement 2a. For requirement 2b, we first show that I\u0303M(q\u20321) can be obtained from I\u0303M(q1), through the successor-state axioms. To this end, notice that IM(q\u20321) can be obtained by taking, for each fluent F , the right-hand side \u03c6(x, a, s) of the corresponding successorstate axiom (the subscript F is removed to simplify the notation), then deriving the equivalent action-term-free formula \u03c6(y,x), as shown in Theorem 12, for action a = AM(v(x)), and finally letting F IM(q \u2032 1) = \u03c6\nIM(q1) x/v(x) , that is, by interpreting each\nF as the answer to the corresponding query \u03c6 on the interpretation IM(q1), under the partial assignment x/v(x) (constants are always interpreted as in M). Now observe that, since the action theory is bounded, so is the extension of each fluent F at q1 and q\u20321. Thus, by Theorem 10, the extension of each fluent at q \u2032 1 contains only values from adom(IM(q1)) \u222a v(x), that is adom(IM(q\u20321)) \u2286 adom(IM(q1)) \u222a v(x). Hence, if we denote (for each F ) the domain-independent rewriting of \u03c6(y,x) as \u03c6\u2032(y,x), by Theorem 8, we have that F IM(q \u2032 1) = \u03c6\nIM(q1) x/v(x) = \u03c6 \u2032I\u0303M(q1) x/v(x) , that is, by answering \u03c6 \u2032 on\nI\u0303M(q1), we obtain the extension of F at q\u20321. Obviously, by doing so for every fluent F , we can obtain I\u0303M(q\u20321) from I\u0303M(q1). By an analogous argument, it can be shown that I\u0303M\u2032(q\u20322) can be obtained from I\u0303M\u2032(q2), for action a\u2032 = AM \u2032 (h\u0302(v(x))).\nNext, consider again the bijection h\u0302 defined above, and recall that h\u0302 extends h on v(x), and that I\u0303M(q1) \u223ch I\u0303M\u2032(q2). By the invariance of FO under isomorphic interpretations, we have that, for each fluent F , the answers to \u03c6\u2032 on I\u0303M(q1) and I\u0303M\u2032(q2), under the partial assignments, respectively, x/v(x) and x/h\u0302(v(x)), coincide, modulo the object renaming induced by h\u0302. But then, it is immediate to check that h\u2032 = h\u0302|adom(IM(q1))\u222aadom(IM(q\u20321)) is a bijection such that I\u0303M(q \u2032 1) \u223ch\u2032|adom(IM(q\u20321)) I\u0303M\u2032(q\u20322) and, hence, by the definition of B, \u3008q\u20321, h\u2032|adom(IM(q\u20321)), q \u2032 2\u3009 \u2208 B. This proves requirement 2b. The proof of requirement 3b is analogous.\nNow, consider a set Mod of models ofD having isomorphic interpretations at S0. By Theorem 18, all such models have induced TSs that are persistence-preserving bisimilar to each other. Thus, by Theorem 13, to check whether a \u00b5\u0141p formula \u03c6 holds in all models of Mod , one can perform the check on any arbitrary model of Mod , using, e.g., the technique discussed for the case of complete information. This result, together with the assumption of boundedness, will be exploited next, to prove our main theorem.\nTheorem 19. Let D be an action theory bounded by b with incomplete information on the initial situation, and let \u03a6 be a \u00b5\u0141p closed formula. Then, checking whether D |= \u03a6 is decidable.\nProof. Let ModD be the set of all models of D, and consider a partition of it such that each cell contains only models whose interpretations at S0 match, modulo object renaming. Formally, we define ModD = (Mod1D,Mod 2 D, . . .) such that, for every two modelsM andM\u2032 in Mod iD, I\u0303M(SM0 ) \u223c I\u0303M\u2032(SM \u2032\n0 ). As a consequence of the boundedness of D, the number of cells in the partition is finite. Indeed, a bounded number of objects yields, up to object renaming, only a bounded number of possible interpretations (of finitely many fluents and constants) at S0. Thus, for some finite n depending on the theory D and the bound b, we have that ModD = (Mod1D,Mod 2 D, . . . ,Mod n D).\nSince, by Theorem 18, any two modelsM andM\u2032 of the generic cell Mod iD induce persistence-preserving bisimilar transition systems, then, by Theorem 13, we have that all the models of Mod iD satisfy \u03a6 if and only if some modelM of Mod i D satisfies \u03a6. Thus, to check whether D |= \u03a6, we can simply choose one modelMi per cell Mod iD, and then check whether, for all i = 1, . . . , n, Mi |= \u03a6; if this is the case, then, and only then, we can conclude that D |= \u03a6. Obviously, for this approach to be effective, we need a modelMi per cell Mod iD and a way to perform the check. The rest of the proof addresses these two points.\nLet F be the set of situation-suppressed fluents of D, and C the (finite) set of constant symbols explicitly mentioned in D (beyond Duno). We observe that each cell Mod iD of the partition ModD = (Mod 1 D, . . . ,Mod n D) can be uniquely identified by an interpretation Ii of F and C over some infinite object domain\u2206. Indeed, by transitivity of \u223c, any two modelsM,M\u2032 of D such that I\u0303M(SM0 ) \u223c Ii and I\u0303 \u2032M(SM \u2032\n0 ) \u223c Ii are also such that I\u0303M(SM0 ) \u223c I\u0303 \u2032M(SM \u2032\n0 ). Notice that Ii certainly exists, as one can simply take I\u0303M(SM0 ), for some modelM\u2208 Mod i D. Clearly, each Ii contains only a bounded number of objects in the active domain and satisfies D0, i.e., Ii |= D0.\nNow, assume given one interpretation Ii per cell Mod iD (we show below how to obtain them) and observe that, from Ii, we can extract a complete initial situation description as a database Di0. This can be easily done, as Ii is finite. Consider the theory Di = (D \\ D0) \u222a Di0, obtained by replacing D0 with Di0, and assume the same interpretation of constants in C as that defined by Ii. Under this assumption, Di defines a family of models that differ only in the object domain and in the interpretation of constants outsideC (which, however, must satisfyDuno). In particular, the interpretation of fluents inF and constants inC, at S0, of all such models, is the same as that of Ii. Thus, the models of Di constitute a subset of Mod iD. To isolate one of such models, we fix an arbitrary infinite object domain\u2206 (such that adom(Ii) \u2286 \u2206), and arbitrarily extend the partial interpretation of constants over the constants outside C, satisfying Duno. Notice that this can always be done, as \u2206 is infinite and the set of constant symbols countable. With \u2206 and the denotation of all constants fixed, Di has complete information, i.e., yields a single modelMi, thus, by Theorem 4, we can check whether Di |= \u03a6 , i.e., whetherMi |= \u03a6 (notice that, as it turns out from Procedure 1, to perform the check, one does not even need to know the interpretation of constants outside C). This, by the discussion above, is equivalent to checking whether for all modelsM\u2208 Mod iD, it is the case thatM |= \u03a6. Therefore, if the set of interpretations \u0393 = {I1, . . . , In} is given, we can check whether D |= \u03a6.\nIt remains to explain how such a set of interpretations \u0393 = {I1, . . . , In} can be obtained. To this end, observe that, by Lemma 3, it follows that |adom(Ii)| \u2264\u2211 F\u2208F aF \u00b7 b + |C| . = b\u2032. Based on this, the set \u03a5 of interpretations Ii can be obtained by: (i) fixing a set O of b\u2032 arbitrary objects; (ii) generating a set \u03a5 \u2032 of all the finitely many interpretations of F and C over O, such that Duno is enforced on C and for every interpretation I \u2032 \u2208 \u03a5 \u2032, I \u2032 |= D0; (iii) for any set \u03a5 \u2032\u2032 \u2286 \u03a5 \u2032 of isomorphic interpretations, removing from \u03a5 \u2032 all but one of such interpretations (in fact, this step is not needed to our purposes, but avoids useless redundancies). The resulting \u03a5 \u2032 is the set of desired interpretations I1, . . . , In, which we rename simply as \u03a5 .\nNow, observe that, by the way it is defined, \u03a5 contains, up to object renaming, all possible interpretations of F and C over a set of b\u2032 distinct objects, that satisfy D0 and Duno (on C). Thus, since for a generic model M of D, the interpretation I\u0303M(SM0 ) contains at most b\u2032 distinct objects (by the boundedness of D), it turns out that there exists an interpretation Ii \u2208 \u03a5 such that I\u0303M(SM0 ) \u223c Ii. Therefore, the cell Mod i D such that M \u2208 Mod iD, is characterized by some interpretation Ii \u2208 \u03a5 , namely the interpretation at S0 shared, up to object renaming, by the models of the cell itself. On the other hand, because any Ii \u2208 \u03a5 enforces Duno and is such that I |= D0, it follows that there exists some model M of D such that I\u0303M(SM0 ) \u223c Ii. Therefore, every interpretation of \u03a5 characterizes some cell Mod iD, specifically, that of the models M such that I\u0303M(SM0 ) \u223c Ii. Therefore, \u03a5 is indeed the set of desired intepretations. This concludes the proof.\nThis result, besides stating decidability of the verification problem under incomplete information, provides us with an actual procedure to perform verification in this case."}, {"heading": "8 Computational Complexity", "text": "In this section, we asses the computational complexity of verifying \u00b5\u0141p formulas over a bounded situation calculus basic action theory D. In particular we show that the constructive techniques we have used for proving decidability are, in fact, optimal with respect to worst case computational complexity. We make the assumption that, for a basic action theory D, the maximum number of distinct objects occurring in the state of any situation, dominates the input size of D itself, and that there exists a bound a\u0304F on the maximum arity of fluents. This is a reasonable assumption, analogous to that, typical in databases, that the size of the database provides a higher bound on the size of the input along all dimensions, and that, in practical cases, there exists an upper bounds on the arity of relations. We exploit the constructive techniques introduced for showing decidability to get an exponential time upper-bound.\nTheorem 20. Verifying \u00b5\u0141p formulas over a situation calculus basic action theory bounded by b, with complete information on the initial situation, can be done in time exponential in b.\nProof. This is a consequence of Procedure 1 and the complexity of \u00b5\u0141p model checking. Firstly, consider Procedure 1 and observe that, by Lemma 4, at any iteration, the number m of distinct objects occurring, overall, in the interpretations of states (i.e. |adom(Q)| of Lemma 4) is bounded by 2b\u2032 + N , where b\u2032 = \u2211 F\u2208F b \u00b7 aF , aF is the arity of fluent F , and N is the maximum number of parameters in action types. Since we assume |F | and N bounded by b, and aF bounded by a constant, it turns out that m is polynomial in b. Now, observe that, with m distinct objects and aF bounded by a constant, one can obtain a number of interpretations of F and C that is at most exponential in m, i.e., in (a polynomial of) b. Then, because in Procedure 1 every state is associated with exactly one interpretation, and since no state is visited more than once, we have that the while-loop (lines 6\u201320) terminates after, at most, an exponential number of iterations.\nAs to each iteration, by our assumptions, we have that any loop inside the whileloop ends after at most exponentially many iterations. Indeed, for any action type with at most N parameters, we have at most mN possible assignments, thus mN \u2264 mb\u2032 , which gives an exponential bound, as both m and b\u2032 are polynomial with respect to b. Now, observe that the dominant operation in the while-loop is checking whether two interpretations are isomorphic. Since also this check can be performed in exponential time with respect to b (the problem is in NP), we obtain, overall, an exponential timebound for Procedure 1.\nNow, recall that propositional \u00b5-calculus model checking is polynomial with respect to the sizes of the input transition system and the input formula [40]. As to the transition system, the check is performed on the one returned by Procedure 1, which has size at most exponential in b (i.e., as many interpretations as one can obtain with at most m objects, plus a quadratic number of transitions wrt it). As to the formula, say \u03a6, we first rewrite it (in polynomial time) into its equivalent domain-independent version \u03a6\u2032, and then \u201cpropositionalize\u201d it, by quantifier elimination, using only the values that occur, overall, in the active domains of the interpretations of the states of the input transition system. This step can be done, again, in exponential time, and returns a quantifier-free formula exponentially larger than the original one, but equivalent to it, on the obtained finite transition system. Thus, since \u00b5-calculus model checking is polynomial wrt the size of both the transition system and the formula, we obtain that, overall, the check requires time at most exponential wrt b.\nSuch an exponential bound is, in fact, tight, as we can show the EXPTIME-hardness of the problem by reduction from acceptance in a polynomial-space bounded alternating Turing machine.\nTheorem 21. Verifying \u00b5\u0141p formulas over bounded situation calculus basic action theories with complete information on the initial situation is EXPTIME-hard.\nProof. We show a reduction from polynomial-space bounded alternating Turing machines, whose acceptance problem is EXPTIME-complete [19]. An (one-tape) Alternating Turing Machine (ATM) [19] is a tuple M = (Q,\u0393, \u03b4, q0, g) where\n\u2013 Q is the finite set of states; \u2013 \u0393 is the finite tape alphabet; \u2013 \u03b4 : Q \u00d7 \u0393 \u00d7 Q \u00d7 \u0393 \u00d7 {L,R} is called the transition table (L shifts the head left\nand R shifts the head right); \u2013 q0 \u2208 Q is the initial state; \u2013 g : Q\u2192 {and, or, accept} specifies the type of each state.\nIf M is in a state q \u2208 Q with g(q) = accept then that configuration is said to be accepting. A configuration with g(q) = and is said to be accepting if all configurations reachable in one step are accepting. A configuration with g(q) = or is said to be accepting when there exists some configuration reachable in one step which is accepting. (The latter is the type of all states in a Nondeterministic Turing Machine.) M is said to accept an input string w if the initial configuration of M (where the state of M is q0, the head is at the left end of the tape, and the tape contains w) is accepting. An ATM is\nsaid to be polynomial-space-bounded if it scans at most a number of tape cells that is polynomially-bounded by the size of the input.\nFollowing [73] (Chap. 4), we can axiomatize the ATM using the following fluents:\n\u2013 transTable(q, c, q\u2032, c\u2032,m, s). This is a situation-independent predicate (i.e., with a trivial successor-state-axioms preserving its content forever) describing the ATM\u2019s transition table \u03b4: when in state q scanning tape symbol c, the machine enters state q\u2032, overwrites c with tape symbol c\u2032, and moves its tape head in the direction m, which is one of L (left) or R (right). \u2013 gType(q, t, s). This is a situation-independent predicate assigning (once and for all) a type t \u2208 {and, or, accept} to the state q of the ATM. \u2013 cell(i, c, s). This means that tape cell i \u2208 [0, . . . , `] contains the symbol c \u2208 \u0393 \u222a {blank} in situation s. Notice that in every situation the number of facts of the form cell(i, \u03b3, s) is fixed and determined by the maximal length of the tape of the bounded ATM, `. Initially, the first cells contains the input word w while the others are blank. \u2013 state(q, s). This means that in situation s, the machine\u2019s state is q. Initially, we have state(q0, S0), where q0 is the initial state of the ATM. \u2013 scan(i, s). This means that the machine\u2019s head is scanning tape cell i \u2208 [0, . . . , `] in situation s. Initially, the head is scanning tape cell 0. In any situation, there will only be one fact of the form scan(i, s).\nWe need just one action type trans(q\u2032, c\u2032,m), meaning that the machine makes a transition from the current configuration to a new configuration where the state is q\u2032, tape symbol c\u2032 is written, and the tape head moves in directionm, whose precondition axiom is as follows:\nPoss(trans(q\u2032, c\u2032,m), s) \u2261 \u2203q, i, c. state(q, s) \u2227 scan(i, s) \u2227 cell(i, c, s) \u2227 transTable(q, c, q\u2032, c\u2032,m, s)\nThe successor state axioms for the fluents that can change are as follows:\nstate(q, do(a, s) \u2261 \u2203c,m.a = trans(q, c,m) \u2228 state(q, s) \u2227 \u00ac\u2203q\u2032, c,m.a = trans(q\u2032, c,m) \u2227 q\u2032 6= q\nscan(i, do(a, s) \u2261 \u2203q, c, i\u2032.a = trans(q, c, L) \u2227 scan(i\u2032, s) \u2227\n(i\u2032 = 0 \u2283 i = i\u2032) \u2227 (i\u2032 6= 0 \u2283 i = i\u2032 \u2212 1) \u2228 \u2203q, c.a = trans(q, c, R) \u2227 scan(i\u2032, s) \u2227 i = i\u2032 + 1 \u2228 scan(i, s) \u2227 \u00ac\u2203q, c,m.a = trans(q, c,m)\ncell(i, c, do(a, s) \u2261 \u2203q,m.a = trans(q, c,m) \u2227 scan(i, s) \u2228 cell(i, c, s) \u2227 \u00ac\u2203q, c\u2032,m.a = trans(q, c\u2032,m) \u2227 scan(i, s) \u2227 c\u2032 6= c\nFor initial situation description, assuming the input w = c0 . . . ci, we have:\nstate(q0, S0), scan(0, S0), cell(0, c0, S0), . . . , cell(i, ci, S0), cell(j, blank, S0), for j \u2208 [i, . . . , `]\nAcceptance of the ATM is defined using the following \u00b5\u0141p formula \u03a6:\n\u00b5Z. (\u2203q.state(q) \u2227 gType(q, accept) \u2228 (\u2203q.state(q) \u2227 gType(q, and)) \u2227 [\u2212]Z \u2228 (\u2203q.state(q) \u2227 gType(q, or)) \u2227 \u3008\u2212\u3009Z\nThen we have that D |= \u03a6 if and only if M accepts w. Notice that in any situation there is exactly one fact of the form gType(q, t, s). Notice also that the above condition does not require quantification across situations."}, {"heading": "9 Checking Boundedness", "text": "We now show that we can always check whether any BAT maintains boundedness for a given bound. That is, if the initial situation description is bounded, then the entire theory is too (for all executable situations).\nFirst notice that we can determine in a situation s whether every executable action a if performed next does not exceed the bound (i.e. in do(a, s)). We can capture the notion of a fluent F being bounded at the next step by the formula:\u2227\nA\u2208A \u2200x.Poss(A(x), s) \u2283 BoundedF,b(do(A(x), s)).\nNotice that eachBoundedF,b(do(A(x), s)) is regressable throughA(x). As a result the formula above is equivalent to a first-order situation calculus formula uniform in s; we call the latter formula NextOrigBoundedF,b(s), and we call NextOrigBoundedb(s) the formula \u2227 F\u2208F NextOrigBoundedF,b(s).\nTo check that the theory is bounded by b it is sufficient to verify that the theory entails the temporal formula:\nAGNextOrigBoundedb . = \u03bdZ.NextOrigBoundedb \u2227 [\u2212]Z,\nwhich expresses that always along any path NextOrigBoundedb holds. Unfortunately deciding whether this formula is entailed by the action theory is directly doable with the techniques in previous sections only if the theory is bounded, which is what we want to check. However it turns out that we can construct a modified version of the action theory that is guaranteed to be bounded and that we can use to do the checking.\nLet D be the action theory. We define a new action theory DD obtained by augmenting D as follows:\n\u2013 DDS0 = DS0 \u222a {\u03c6[F /F \u2032]|\u03c6 \u2208 DS0} \u2013 DDSS = DSS \u222a {F \u2032(x, do(a, s)) \u2261 \u03a6(x, a, s) \u2227NextOrigBoundedb(s) | F (x, do(a, s)) \u2261 \u03a6(x, a, s) \u2208 DSS} \u2013 DDap = {Poss(A(x), s) \u2261 \u03a8(x, a, s) \u2227NextOrigBoundedb(s) |\nPoss(A(x), s) \u2261 \u03a8(x, a, s) \u2208 DAP }\nIntuitively DD extends D with primed copies of fluents, which are axiomatized to act, in any situation, as the original ones as long as the original theory remains bounded by b in that situation, otherwise they become empty (and actions cannot be executed according to Poss.) It is easy to show the following key property for DD.\nLemma 5.\nDD |= \u2200s.(\u2200s\u0302.s\u0302 < s \u2283 NextOrigBoundedb(s\u0302)) \u2283 \u2200x.(F \u2032(x, s) \u2261 F (x, s)).\nProof. By induction on situations.\nNow we define a new action theory D\u2032 which can be considered a sort of projection of DD over the primed fluents only. Let D\u2032 be:\n\u2013 D\u2032S0 = {\u03c6[F /F \u2032]|\u03c6 \u2208 DS0}. \u2013 D\u2032SS = {F \u2032(x, do(a, s)) \u2261 \u03a6[F /F \u2032](x, a, s) \u2227NextOrigBoundedb[F/F \u2032](s) | F (x, do(a, s)) \u2261 \u03a6(x, a, s) \u2208 DSS} \u2013 D\u2032ap = {Poss(A(x), s) \u2261 \u03a8 [F /F \u2032](x, a, s) \u2227NextOrigBoundedb[F/F \u2032](s) | Poss(A(x), s) \u2261 \u03a8(x, a, s) \u2208 DAP }\nNotice that D\u2032 is bounded by construction if D\u2032S0 is, and furthermore it preserves the information about the original theory being bounded at the next step, though in terms of primed fluents. Exploiting the above lemma on DD and the construction of D\u2032, we can show that D\u2032 has the following notable property:\nLemma 6.\nD |= AGNextOrigBoundedb(S0) iff D\u2032 |= AGNextOrigBoundedb[F /F \u2032](S0).16\nProof. By Lemma 5, it is immediate to see that D |= AGNextOrigBoundedb(S0) implies D\u2032 |= AGNextOrigBoundedb[F /F \u2032](S0). For the opposite direction, suppose that D\u2032 |= AGNextOrigBoundedb[F /F \u2032](S0), but D |= AGNextOrigBoundedb(S0) does not hold. This means that there exists a model of D and a situation S where \u00acNextOrigBoundedb(S) holds, though in all previous situations s < S we have that NextOrigBoundedb(s) holds. Now by Lemma 5, we can construct a model forD\u2032 such that the truth values of F are replicated in F \u2032 as long as NextOrigBoundedb holds in the previous situation. So in S, we must have \u00acNextOrigBoundedb[F /F \u2032](S), which contradicts the assumption that D\u2032 |= AGNextOrigBoundedb[F /F \u2032](S0).\nBy Lemma 6, since D\u2032 is bounded by b if D\u2032S0 is, it follows that:\nTheorem 22. Given a BAT whose initial situation description is bounded by b, then checking whether the entire theory is bounded by b is decidable.\nNotice that we pose no restriction on the initial situation description except that it is representable in first-order logic, hence checking its boundedness remains undecidable:\nTheorem 23. Given a FO description of the initial situation D0 and a bound b, it is undecidable to check whether all models of D0 are bounded by b. 16 Notice that NextOrigBoundedb[F /F\n\u2032] expresses that in the original theory the next situations are bounded, though now syntactically replacing original fluents with their primed version.\nProof. By reduction to FO unsatisfiability. Suppose we have an algorithm to check whether a FO theory D0 is bounded by 0. Then we would have an algorithm to check (un)-satisfiability of D0. Indeed consider for a fixed fluent F\u0302 :\nD\u03020 = (D0 \u2227 \u2203x.F\u0302 (x, S0)) \u2228 ( \u2227 F\u2208F \u2200x.\u00acF (x, S0))\nNote that \u2227 F\u2208F \u2200x.\u00acF (x, S0) has only models bounded by 0, while \u2203x.F\u0302 (x, S0) has only models with at least one tuple (and thus one object) in F\u0302 . Hence we get that D\u03020 is bounded by 0 iff D0 is unsatisfiable. A similar argument holds for every bound b.\nNonetheless in many cases we know by construction that the initial situation is bounded. In such cases the proof technique of Theorem 22 provides an effective way to check if the entire theory is bounded."}, {"heading": "10 Related Work", "text": "Besides the situation calculus [64,73], many other formalisms for reasoning about actions have been developed in AI, including the event calculus [55,79,80], the features and fluents framework [76], action languages such as A [44] and C+ [47], the fluent calculus [86], and many others. In most of these, the focus is on addressing problems in the representation of action and change, such as the frame problem. Some attention has also been paid to specifying and verifying general temporal properties, especially in the context of planning. The Planning Domain Definition Language (PDDL) [65] has been developed for specifying planning domains and problems, and a recent version supports the expression of temporal constraints on the plan trajectory [46]. Approaches such as those in TLPlan [3], in TALplanner [56], or in planning via model checking [67] support planning with such temporal constraints. Within the situation calculus, temporal constraints for planning have been studied in, e.g., [12,7]. All these planningrelated approaches are essentially propositional and give rise to transition systems that are finite-state. One interesting attempt to interpret first-order linear temporal logic simultaneously as a declarative specification language and procedural execution language is that of MetateM [8], though verification is not addressed.\nMost work on verification has been done in computer science, generally focusing on finite-state systems and programs. Many logics have been developed to specify temporal properties of such systems and programs, including linear-time logics, such as Linear Temporal Logic (LTL) [68] and Property-Specification Language (PSL) [39], and branching time logics such as Computation Tree Logic (CTL) [21] and CTL\u2217 [41], the \u00b5-calculus [40,17], which subsumes the previous two, as well as Propositional Dynamic Logic (PDL) [42], which incorporates programs in the language. Model checking (and satisfiability) in these propositional modal logics is decidable [6], but they can only represent finite domains and finite state systems. Practical verification systems, e.g., [52,20], have been developed for many such logics, based on model checking techniques [6].\nIn AI, verification by model checking has become increasingly popular in the autonomous agents and multi-agent systems area. There, many logics have been proposed that additionally deal with the informational and motivational attitudes of agents\n[70,71,61,88,24,81]. Some recent work has been specifically concerned with formalizing multi-agent knowledge/belief and their dynamics [37,51]. Moreover, various BeliefDesire-Intention (BDI) agent programming languages have been developed that operationalize these mental attitudes [69,15,25,13]. Verification is important in this area as agent autonomy makes it crucial to be able to guarantee that the system behaves as required [43]. Furthermore, one generally wants to ensure that the agents\u2019 mental states as well as their behavior evolve in a way that satisfies certain properties. Agent logics can be used to specify such properties. Much of the verification work in this area focuses on the model checking of BDI programs. For instance, [14] shows how to use the SPIN model checker [52] to verify properties of finite-state AgentSpeak programs. [35,43] compile BDI programs and agent properties to verify into Java and use JPF [87] to model check them. [62] develops MCMAS, a symbolic model checker specifically for multi-agent systems. [2] develops a theorem proving-based verification framework for BDI programs that uses a PDL-like logic.\nIn the situation calculus, there is also some previous work on verification. Perhaps the first such work is [33], where verification of possibly non-terminating Golog [58] programs is addressed, though no effective techniques are given. Focusing on the propositional situation calculus (where fluents have only the situation as argument), [85] presents decidable verification techniques. In [48], these techniques are generalized to a one-object-argument fluents fragment of the situation calculus, and in [49] to theories expressed in two-object-argument fragment. Techniques for verification resorting to second-order theorem proving with no decidability guarantees are presented in [81,82], where the CASLve verification environment for multi-agent ConGolog [26] programs is described. In [22], characteristic graphs for programs are introduced to define a form of regression over programs to be used as a pre-image computation step in (sound) procedures for verifying Golog and ConGolog programs inspired by model checking. Verification of programs over a two-variable fragment of the situation calculus is shown to be decidable in [23]. [54] establishes conditions for verifying loop invariants and persistence properties. Finally, [31,77] propose techniques (with modelchecking ingredients) to reason about infinite executions of Golog and ConGolog programs based on second-order logic exploiting fixpoint approximates.\nMore recently, work closely related to ours [27,28,30,29] has shown that one gets robust decidability results for temporal verification of situation calculus action theories under the assumption that in every situation the number of object tuples forming the extension of each fluent is bounded by a constant. In particular, [27] introduced bounded situation calculus basic action theories; [27] however, assumes standard names for the object domain and, more significantly, disallows quantification across situations in the verification language. In the present paper, which is a direct extension of [27], both of these limitations are removed. In [28] an extended language with an explicit knowledge operator was considered, while in [30] online executions (i.e., executions where the agent only performs actions that it knows are executable) and progression are studied; like [27], these papers also assume standard names and rule out quantification across situations from the verification language. [29] addresses verification over online executions with sensing in bounded situation calculus theories, adopting as verification\nlanguage a first-order variant of Linear Temporal Logic (FO-LTL), again without quantification across situations.\nThe work in this paper is also closely related to [10]. There, an ad-hoc formalism for representing action and change is developed with the purpose of capturing data-aware artifact-centric processes. This formalism describes action preconditions and postconditions in first-order logic, and induces genericity [1] \u2014 there called uniformity \u2014 on the generated transition system. Intuitively genericity requires that if two states are isomorphic they induce the \u201csame\u201d transitions (modulo isomorphism). This means, in particular, that the system is essentially Markovian [73]. As verification language, they consider FO-CTL, a first-order variant of CTL that allows for quantifying across states without requiring object persistence, as, instead, we do here. Their results imply that one can construct a finite-state transition system over which the FO-CTL formula of interest can be verified. However, differently from our case, such a transition system depends also on the number of variables in the formula. While also bounded situation calculus action theories enjoy genericity, it is easy to see that, without assuming object persistence, we immediately lose the possibility of abstracting to a finite transition system independently from the formula to verify. This is true even if we drop completely fixpoints. Indeed, assume that we have an action replaces an object in the active domain by one in its parameters. Then, without persistence, for any bound n over the number of objects in a candidate finite abstraction, we can write a (fixpoint-free) formula saying that there exists a finite run with more than n distinct objects:\n\u2203x1.LIVE(x1) \u2227 \u3008\u2212\u3009(\u2203x2.LIVE(x2) \u2227 x2 6= x1 \u2227 \u3008\u2212\u3009(\u2203x3LIVE(x3) \u2227 x3 6= x1 \u2227 x3 6= x2 \u2227\n\u00b7 \u00b7 \u00b7 \u3008\u2212\u3009(\u2203xn+1LIVE(xn+1) \u2227 xn+1 6= x1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 xn+1 6= xn)))\nObviously, this formula is false in the finite abstraction, while true in the original transition system, where objects are not \u201creused\u201d. Notice that the formula belongs also to FO-CTL and this limitation applies to [10] as well. This observation shows that the persistence condition is crucial to get an abstraction that is independent from the formula.\nIt is interesting to observe that while dropping persistence is certainly a valuable syntactic simplification, the deep reason behind it is that generic transition systems, including those generated by situation calculus basic action theories, are essentially unable to talk about objects that are not in the current active domain. If some object that is in the active domain disappears from it and reappears again, after some steps, the basic action theory will treat it essentially as a fresh object (i.e., an object never seen before). Hence, any special treatment of such objects must come from the formula we are querying the transition system with: for example, we may isolate runs with special properties and only on those do verification. The fact that FO-CTL can drop persistence while maintaining decidability of verification over generic transition systems tells us that FO-CTL is not powerful enough to isolate interesting runs to be used as a further assumption for verification.\nThe results in this paper are relevant not only for AI, but also for other areas of computer science (CS). There is some work in CS that uses model checking techniques on infinite-state systems. However, in most of this work the emphasis is on studying recursive control rather than on a rich data oriented state description; typically data are either\nignored or finitely abstracted, see e.g., [18]. There has recently been some attention paid in the field of business processes and services to including data into the analysis of processes [53,45,38]. Interestingly, while we have verification tools that are quite good for dealing with data and processes separately, when we consider them together, we get infinite-state transition systems, which resist classical model checking approaches to verification. Only lately has there been some work on developing verification techniques that can deal with such infinite-state processes [36,4,9,5,10]. In particular, the form of controlled quantification across situations in our \u00b5\u0141p language, which requires object persistence in the active domain, is inspired by the one in [5], which in turn extends the verification logic presented in [27]. There, the infinite-state data-aware transition systems (with complete information) to verify are defined using an ad-hoc formalism based on database operations, and the decidability results are based on two conditions over the transition systems, namely run-boundedness and state-boundedness. The latter is analogous to our situation-boundedness. In this paper, we make the idea of boundedness flourish in the general setting offered by the situation calculus, detailing conditions needed for decidability, allowing for incomplete information, and exploiting the richness of the situation calculus for giving sufficient conditions for boundedness that can easily be used in practice. Such results can find immediate application in the analysis of data-aware business processes and services."}, {"heading": "11 Conclusion", "text": "In this paper, we have defined the notion of bounded action theory in the situation calculus, where the number of fluent atoms that hold remains bounded. We have shown that this restriction is sufficient to ensure that verification of an expressive class of temporal properties remains decidable, and is in fact EXPTIME-complete, despite the fact that we have an infinite domain and state space. Our result holds even in the presence of incomplete information. We have also argued that this restriction can be adhered to in practical applications, by identifying interesting classes of bounded action theories and showing that these can be used to model typical example dynamic domains. Decidability is important from a theoretical standpoint, but we stress also that our result is fully constructive being based on a reduction to model checking of an (abstract) finite-state transition system. An interesting future enterprise is to build on such a result to develop an actual situation calculus verification tool.\nA future research direction of particular interest is a more systematic investigation of specification patterns for obtaining boundedness. This includes patterns that provide bounded persistence and patterns that model bounded/fading memory. These questions should be examined in light of different approaches that have been proposed for modeling knowledge, sensing, and revision in the situation calculus and related temporal logics [78,34,83,37]. This work has already started. In particular, as mentioned earlier, the approach of this paper has been extended in [30,29] to allow verification temporal properties over online executions of an agent, where the agent may acquire new information through sensing as it executes and only performs actions that are feasible according to its beliefs. In that work, the agent\u2019s belief state is modeled meta-theoretically, as an action theory that is progressed as actions are performed and sensing results are\nobtained. In [28], temporal epistemic verification is tackled within a language-theoretic viewpoint, where the situation calculus is extended with a knowledge modality [78]. The form of boundedness studied in that case requires that the number of object tuples that the agent thinks may belong to any given fluent be bounded. In [30,29], instead, it is only required that number of distinct tuples entelied to belong to a fluent is bounded, while the number of tuples that are in the extension of a fluent in some model of the theory need not be bounded. More work is needed to fully reconcile these meta-theoretic and language-theoretic approaches.\nFinally, an important topic for future work is to tackle verification of agent programs [33], possibly expressed in a situation calculus-based high-level language like Golog [58] or ConGolog [26]. Some cases where verification of ConGolog programs is decidable are identified in [23]. It woud be interesting to extend our framework to support such a form of verification as well. This is not immediate, as a temporal property may hold over all executions of a program without holding over all branches of the situation tree. To extend our approach to programs, we need to ensure that not just the agent\u2019s beliefs but the whole program configuration remains bounded."}, {"heading": "Acknowledgements", "text": "The authors acknowledge the support of: Ripartizione Diritto allo Studio, Universita\u0300 e Ricerca Scientifica of Provincia Autonoma di Bolzano\u2013Alto Adige, under project VeriSynCoPateD (Verification and Synthesis from Components of Processes that Manipulate Data); EU Commission, under the IP project n. FP7-318338 Optique (Scalable End-user Access to Big Data); and the National Science and Engineering Research Council of Canada."}], "references": [], "referenceMentions": [], "year": 2015, "abstractText": "In this paper, we investigate bounded action theories in the situation<lb>calculus. A bounded action theory is one which entails that, in every situation,<lb>the number of object tuples in the extension of fluents is bounded by a given<lb>constant, although such extensions are in general different across the infinitely<lb>many situations. We argue that such theories are common in applications, either<lb>because facts do not persist indefinitely or because the agent eventually forgets<lb>some facts, as new ones are learnt. We discuss various classes of bounded action<lb>theories. Then we show that verification of a powerful first-order variant of the \u03bc-<lb>calculus is decidable for such theories. Notably, this variant supports a controlled<lb>form of quantification across situations. We also show that through verification,<lb>we can actually check whether an arbitrary action theory maintains boundedness.", "creator": "LaTeX with hyperref package"}}}