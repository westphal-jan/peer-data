{"id": "1509.03057", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Sep-2015", "title": "The World of Combinatorial Fuzzy Problems and the Efficiency of Fuzzy Approximation Algorithms", "abstract": "developers re - imagine a practical aspect of contemporary fuzzy modeling encompassing intermediate types, mainly search, transfer, optimization, and decision problems. we are focused around by those different theories that improve characteristics of continuous input objects and produce fuzzy shapes. helped solve such problems correctly, we design fast fuzzy algorithms, that us modeled by pure - time deterministic close coupled machines equipped specifically mesh - based auxiliary tapes around write - only output cells and also generate pure polynomial - size fuzzy circuits composed simply fuzzy gates. he essentially introduce fuzzy proof verification requirements on model maximal fuzzification numbering schemes. adaptive models may us assess four complexity classes : fuzzy - fpa of fuzzy squares, anti - pa and fuzzy - npa of fuzzy mapping problems, or fuzzy - knowledge of convex optimization questions. concentrated on matching relative order scheme calculating fuzzy membership values, we formulate rigorous notions of \" methods \" in unison to attain general computational complexity of two optimal problems. these combined notions help detection possible precisely locate the most difficult fuzzy problems in u - npa and in s - npao.", "histories": [["v1", "Thu, 10 Sep 2015 09:07:31 GMT  (19kb)", "http://arxiv.org/abs/1509.03057v1", "A4, 10pt, 10 pages. This extended abstract already appeared in the Proceedings of the Joint 7th International Conference on Soft Computing and Intelligent Systems (SCIS 2014) and 15th International Symposium on Advanced Intelligent Systems (ISIS 2014), December 3-6, 2014, Institute of Electrical and Electronics Engineers (IEEE), pp. 29-35, 2014"]], "COMMENTS": "A4, 10pt, 10 pages. This extended abstract already appeared in the Proceedings of the Joint 7th International Conference on Soft Computing and Intelligent Systems (SCIS 2014) and 15th International Symposium on Advanced Intelligent Systems (ISIS 2014), December 3-6, 2014, Institute of Electrical and Electronics Engineers (IEEE), pp. 29-35, 2014", "reviews": [], "SUBJECTS": "cs.AI cs.CC", "authors": ["tomoyuki yamakami"], "accepted": false, "id": "1509.03057"}, "pdf": {"name": "1509.03057.pdf", "metadata": {"source": "CRF", "title": "The World of Combinatorial Fuzzy Problems and the Efficiency of Fuzzy Approximation Algorithms", "authors": ["Tomoyuki Yamakami"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n50 9.\n03 05\n7v 1\n[ cs\n.A I]\n1 0\nSe p\n20 15\nsearch, counting, optimization, and decision problems. We are focused only on those fuzzy problems\nthat take series of fuzzy input objects and produce fuzzy values. To solve such problems efficiently, we\ndesign fast fuzzy algorithms, which are modeled by polynomial-time deterministic fuzzy Turing machines\nequipped with read-only auxiliary tapes and write-only output tapes and also modeled by polynomial-\nsize fuzzy circuits composed of fuzzy gates. We also introduce fuzzy proof verification systems to model\nthe fuzzification of nondeterminism. Those models help us identify four complexity classes: Fuzzy-FPA\nof fuzzy functions, Fuzzy-PA and Fuzzy-NPA of fuzzy decision problems, and Fuzzy-NPAO of fuzzy\noptimization problems. Based on a relative approximation scheme targeting fuzzy membership degree,\nwe formulate two notions of \u201creducibility\u201d in order to compare the computational complexity of two\nfuzzy problems. These reducibility notions make it possible to locate the most difficult fuzzy problems\nin Fuzzy-NPA and in Fuzzy-NPAO."}, {"heading": "1 Background and Results", "text": "Our purpose is to (1) make a theoretical groundwork necessary to carry out practical analyses of \u201cgeneralized\u201d fuzzy problems that have naturally arisen in industrial applications and (2) lay out a theoretical framework for \u201cgeneralized\u201d fuzzy algorithms that efficiently solve those \u201cgeneralized\u201d fuzzy problems."}, {"heading": "1.1 Practical Realm of Fuzzy Problems", "text": "In real-life situations, many objects naturally embody certain degrees of fuzziness, which can be in general expressed in terms of the uncertainty, ambiguity, vagueness, or imprecision of the objects. Based on a nonstandard logic, Zadeh [13] tried to capture this fuzziness mathematically by formulating a basic concept of fuzzy set. In his theory, an ordinary object without any fuzziness is distinctly called as a \u201ccrisp\u201d object, whereas a fuzzy object is a combination of crisp object and its membership degree (or certainty degree) that indicates intuitively how likely the crisp object actually exists. Since its introduction, fuzzy theory has found numerous applications from digital image processing to voice recognition, to telecommunication, further to a field of medicine and agriculture (see, e.g., [1, 7]). To handle a wide variety of practical fuzzy problems, we still need to lay out a groundwork in developing a general, coherent theory of fuzzy problems and fuzzy algorithms that efficiently solve them.\nIn the rest of this paper, we wish to limit our interest within combinatorial problems, which include search, counting, optimization, and decision problems. Let us first recall that, in an ordinary theory, those problems are viewed as functions that map every input instance to its desirable solution (or solutions). In the past literature, there have been numerous ways to fuzzificate ordinary combinatorial problems and those fuzzification methods significantly vary, depending on target areas of interests. We wish to re-examine a fuzzification of those problems to develop our general framework.\nIn many abstract treatments of fuzzy problems, input instances are merely pairs of crisp objects and their membership degrees, instead of more general \u201cfuzzy objects.\u201d To expand a scape of fuzzy-logic applications, it is more desirable to deal with the case where an input instance is a series of admissible fuzzy objects (or fuzzy data) and an output could be a desired \u201cfuzzy object\u201d as a solution derived from the given input. Formally, we define our \u201cfuzzy problem\u201d as a mapping from each series of fuzzy objects to another fuzzy object; thus, the term \u201cfuzzy problem\u201d becomes a synonym of \u201cfuzzy functions.\u201d To describe those fuzzy problems, we need to specify two items: fuzzy (input) instance and fuzzy output. For technical reason, we assume that the support of any fuzzy instance is finite, where the support of a fuzzy object over universe U is an ordinary set of elements in U having positive membership degrees. To distinguish our fuzzy problems\n\u2217This extended abstract appeared in the Proceedings of the Joint 7th International Conference on Soft Computing and Intelligent Systems (SCIS 2014) and 15th International Symposium on Advanced Intelligent Systems (ISIS 2014), December 3\u20136, 2014, Institute of Electrical and Electronics Engineers (IEEE), pp. 29\u201335, 2014.\n\u2020Present Affiliation: Department of Information Science, University of Fukui, 3-9-1 Bunkyo, Fukui 910-8507, Japan\nfrom the aforementioned conventional fuzzy problems, we sometimes emphasize the generosity of our fuzzy problems by calling them generic fuzzy problems.\n(Generic) Fuzzy Problem P :\n\u2022 Fuzzy instance: a series (s1, s2, . . . , sk) of admissible fuzzy objects having finite supports. \u2022 Fuzzy output: an admissible fuzzy object as a solution to this input (s1, s2, . . . , sk).\nDue to the page limit, we will discuss in later sections only two kinds of (generic) fuzzy problems: fuzzy decision problems and fuzzy optimization problems. Fuzzy decision problems are treated as a special case of the fuzzy problems whose outputs are limited to fuzzy subsets of {0, 1}. This gives rise to a new realm of fuzzy languages, each of which indicates input\u2019s \u201cacceptance\u201d and \u201crejection\u201d with separate precision degrees, whereas conventional \u201cfuzzy languages\u201d are defined simply as fuzzy subsets of \u03a3\u2217 for underlying alphabet \u03a3.\nFuzzy optimization problems are also a variant of (generic) fuzzy problems, which in general have the form (I, SOL,m, goal), where I is a finite set of fuzzy (admissible) input instances, SOL is a fuzzy function listing all fuzzy solutions, m is a fuzzy measure (or objective) function from I \u25e6 SOL to natural numbers, and goal \u2208 {max,min}. Here I \u25e6 SOL means the set {(s, t) | s \u2208 I, t \u2208 SOL(s)}. Let m\u2217(x) denote the optimal value m(x, y) over all solutions y \u2208 SOL(x)."}, {"heading": "1.2 Practical Realm of Fuzzy Algorithms", "text": "In Section 1.1, we have discussed our (generic) fuzzy problems. To solve those problems efficiently, we need to clarify how we model efficient fuzzy algorithms so that we can explore computational complexity issues of the fuzzy problems in a wider, generic framework.\nWe intend to model fuzzy algorithms by extending the existing realms of \u201csequential computation\u201d and \u201cparallel computation.\u201d Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) . In their formulations, deterministic fuzzy computation inherently embodies ordinary nondeterminism, and therefore it is not surprising to know that, under a certain suitable fuzzification of ordinary instances, fuzzy algorithms solve NP-complete problems in polynomial time (cf. Proposition 6.2).\nTo cope with a wide range of practical fuzzy problems, Doostfatemeh and Kremer [4] suggested how to expand the then-existing models of fuzzy algorithms by supplementing extra \u201csafe\u201d auxiliary operators to tune up the behaviors of those algorithms. Based on their spirit, we give a new formulation of deterministic fuzzy Turing machines (or DFTMs).\nAnother natural model that can represent fuzzy algorithms is fuzzy (logic) circuits (e.g., [6, 8]). In particular, we consider fuzzy circuits in which fuzzy gates are layered level by level. Such a fuzzy circuit takes a series of fuzzy input bits and proceeds by applying fuzzy gates at each level. This mechanism can realize fuzzified \u201cparallel computation.\u201d We prove that families of polynomial-size fuzzy circuits are equivalent in computational power to polynomial-time DFTMs.\nThe minimum amount of computational resources necessary to solve given problems is of great concern from a practical viewpoint. As in ordinary computational complexity theory, we are also interested in fuzzy algorithms running in polynomial time. For the purpose of solving a wider scope of fuzzy problems, we look for an approximation of the outcomes of fuzzy algorithms. We therefore define Fuzzy-FPA(\u03b3) as the class of fuzzy functions (or equivalently, fuzzy problems having output values) computed approximately with relative closeness of \u03b3 by DFTMs in polynomial time. Restricted to fuzzy decision problems, we also obtain Fuzzy-PA(\u03b3) as a natural fuzzification of the complexity class P.\nNondeterminism has been modeled as a proof-verification process, in which, for positive instances, there exists a \u201cproof\u201d (i.e., necessary key information) for which a \u201cverifier\u201d can easily confirm its validity and, for negative instances, the verifier refutes any proof provided to him as invalid. We recognize a naturallyinduced class Fuzzy-NPA(\u03b3) of fuzzy decision problems that are solved approximately with relative closeness \u03b3 by such fuzzy proof verification systems (or FPVS\u2019s, in short) in polynomial-time.\nTo discuss the computational complexity of fuzzy problems, we introduce a fundamental notion of polynomial-time approximate fuzzy reducibility (abbreviated as AF-reducibility) between two fuzzy problems. Such a reducibility notion among fuzzy decision problems makes it possible to designate \u201ccomplete\u201d problems, which indicate the most difficult problems in a given class of problems to solve in polynomial time, as for the notion of NP-complete problems (see [5]). We prove the existence of complete problems in Fuzzy-NPA(1) under AF-reductions.\nFor fuzzy optimization problems, similarly to Fuzzy-NPA(\u03b3), we define Fuzzy-NPAO(\u03b3), which is composed of all fuzzy optimization problems characterized by fuzzy functions in Fuzzy-FPA(\u03b3). Between two fuzzy optimization problems, we also introduce a notion of polynomial-time approximation-preserving fuzzy reducibility (or APF-reducibility) and prove that Fuzzy-NPAO(1) contains complete problems under APFreductions.\nAll omitted or abridged proofs will appear in a complete version of this extended abstract."}, {"heading": "2 Basic Notions and Notations", "text": "The notation Z (resp., Q, R) denotes the set of all integers (resp., rational numbers, real numbers). We use N to denote the set of all natural numbers (i.e., non-negative integers) and we set N+ = N\u2212 {0}. For two integers n,m with n \u2264 m, [n,m]Z stands for the integer interval {n, n+ 1, n+ 2, . . . ,m}. For simplicity, we write [n] to denote the interval [1, n]Z whenever n \u2265 1. The notation [0, 1]\n\u2217 (resp., [0, 1]+) denotes the union of [0, 1]k for any constant k \u2208 N (resp., k \u2208 N+). Given any propositional formula F , we set [F ] to be 1 if F is true, and 0 otherwise. For example, [x = y] equals 1 if and only if x = y. For any set A, P(A) denotes the power set of A.\nAn alphabet \u03a3 is a finite nonempty set of \u201csymbols\u201d and a string over \u03a3 is a finite sequence of symbols taken from \u03a3; in particular, the empty string is always denoted \u03bb. Let \u03a3\u2217 denote the set of all strings over \u03a3. For any logical proposition (or logical statement) P , the notation [P ] denotes 1 if P is true, and 0 otherwise. For example, we have [x = y] = 1 if x equals y, and [x = y] = 0 if x is different from y.\nDue to the page limit, we assume that the reader is familiar with basic concepts of fuzzy sets. Although a fuzzy (sub)set A of universe U is a map from U to [0, 1], it is also viewed as an ordinary set that is composed of pairs of the form (x, \u03b3), where x \u2208 U and \u03b3 \u2208 [0, 1]; that is, (x, \u03b3) \u2208 A iff \u03b3 = A(x). To simplify the descriptions of fuzzy sets in the rest of the paper, we will take those two different viewpoints interchangeably. For convenience, we write F(U) for the collection of all fuzzy subsets of U . Moreover, we use the notations core(s) for the core of fuzzy set s and Supp(s) for the support of s.\nDefinition 2.1 (fuzzy function) Given two universes U1 and U2, let A \u2286 F(U1) and B \u2286 F(U2). A (generic) fuzzy function f from A to B, written as f : A \u2192 B, satisfies that, for every s \u2208 A, f(s) is a fuzzy subset of U2 in B.\nRemark: It may be possible to expand our definition of fuzzy sets by replacing the unit interval [0, 1] with an arbitrary complete lattice and expand our results further. However, we leave such a challenging task to the interested reader."}, {"heading": "3 Combinatorial Fuzzy Problems", "text": "In pursuit of simplicity, we limit our attention within \u201ccombinatorial problems\u201d that inherently embody fuzziness. Now, we want to explain what \u201cfuzzy problems\u201d are. As described in Section 1.1, fuzzy problems with which we deal in this paper take series of fuzzy instances (such as fuzzy graphs, fuzzy numbers, fuzzy functions, etc.) as inputs and produce certain fuzzy objects as outputs. We treat such a problem as a mapping from a set of fuzzy objects (or fuzzy instances) to another fuzzy object.\nAs customarily in ordinary computational complexity theory, we will deal only with discrete objects as our input instances. For a general treatment of such discrete fuzzy instances, it is useful to assume a suitable encoding of those instances to a certain fixed object. In a way similar to defining \u201cstrings over alphabet\u201d in ordinary language theory, we will introduce an exquisite notion of \u201cfuzzy string,\u201d which expresses a certain degree of imprecision, uncertainty, or incompleteness of string information. Our definition of fuzzy string is inspired by the notion of LR-shape fuzzy numbers (see, e.g., [7]) and is closely related to \u201cdiscretized\u201d fuzzy numbers.\nA fuzzy string quantity s over \u03a3 is an element of F(\u03a3\u2217), namely, a fuzzy subset of \u03a3\u2217. We call each value s(x) a precision degree of x instead of \u201cmembership degree.\u201d A fuzzy string over \u03a3 (with respect to a suitably chosen distance measure d, e.g., the Hamming distance between two crisp strings) is a fuzzy string quantity s over \u03a3 that satisfies the following condition: there exist a crisp string x0 \u2208 \u03a3\n\u2217 and a crisp function \u03b7 : [0, 1] \u2192 [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) \u03b7 is strictly decreasing function with \u03b7(0) = 1 and \u03b7(1) = 0, and (3) Cut\u03b3(s) \u2286 Balld(x0, \u03b7(\u03b3)) holds for any real number \u03b3 \u2208 [0, 1], where Balld(x, \u03b3) = {z \u2208 \u03a3 \u2217 | d(x, z) \u2264 \u03b3}. This special string x0 is called a target of the fuzzy string s.\nLet F\u03a3\u2217 denote a collection of all (possible) fuzzy strings over \u03a3. It holds that core(s) = x0 by Conditions (2) and (4). Note that a fuzzy string is a convex fuzzy set. As usual in fuzzy theory, a fuzzy string s can be seen as the set {(x, s(x)) | x \u2208 \u03a3\u2217}. We also follow a standard convention that, when a fuzzy string s is crisp with a target x0 (i.e., s(x0) = 1 and s(x) = 0 for any x \u2208 \u03a3\n\u2217 \u2212 {x0}), we identify s with x0. This helps us treat all crisp strings as a special case of fuzzy strings.\nHenceforth, we will focus our attention only on any subset F\u0398 of F\u03a3\u2217 for a certain alphabet \u03a3 and a certain distance measure d. A (generic) fuzzy problem stated in Section 1.1 is now rephrased as follows. Fix our alphabet \u03a31,\u03a32 and consider two sets F\u03981 \u2286 F\u03a3 \u2217 1 and F\u03982 \u2286 F\u03a3 \u2217 2.\n(Generic) Fuzzy Problem L w.r.t. (F\u03981, F\u03982):\n\u2022 Fuzzy instance: a series (s1, s2, . . . , sk) of fuzzy strings in F\u03981. \u2022 Fuzzy Output: a fuzzy string in F\u03982.\nIn particular, we will study two types of fuzzy problems: fuzzy decision problems and fuzzy optimization problems, defined in Section 1.1."}, {"heading": "4 Models for Efficient Fuzzy Algorithms", "text": "To solve the fuzzy problems described in Section 3, we want to design efficient fuzzy algorithms."}, {"heading": "4.1 Auxiliary Operators for Practical Algorithms", "text": "The existing formulation of fuzzy Turing machine seems too restrictive to apply to many real-life fuzzy problems. For a wider range of practical applications of fuzzy machines, Doostfatemeh and Kremer [4] proposed a rigorous use of \u201cauxiliary functions\u201d to a design of fuzzy algorithms (actually, fuzzy finite automata in their case). For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u00b51, \u00b52, \u00b53, \u03be), where \u00b51 : [0, 1] 2 \u2192 [0, 1], \u00b52 : [0, 1] + \u2192 [0, 1], \u00b53 : [0, 1]\n+ \u2192 [0, 1], and \u03be : [0, 1]\u2217 \u2192 [0, 1]. The use of them will be clarified in Section 4.2.\nA tuple (\u00b51, \u00b52, \u00b53, \u03be) of auxiliary operators is said to be safe if those functions satisfy the following conditions: for any finite nonempty ordered set A and any finite ordered set B, (1) \u00b51(\u03b1, \u03b1) = \u03b1 for any \u03b1 \u2208 [0, 1], (2) \u00b52({\u03b1r}r\u2208A) = \u03b1 if \u03b1r = \u03b1 for all r \u2208 A, (3) \u00b53({\u03b1r}r\u2208A) = \u03b1 if \u03b1r = \u03b1 for all r \u2208 A, and (4) \u03be(\u00d8) = 0 and \u03be({\u03b1r}r\u2208B) = \u03b1 if \u03b1r = \u03b1 for r \u2208 B. As a concrete example, we present a standard safe tuple \u039e = (\u00b51, \u00b52, \u00b53, \u03be), which we will use later. Let \u2227 and \u2228 be any t-norms. We set \u00b51(\u03b1, \u03b2) = \u03b1 \u2227 \u03b2. For any finite nonempty ordered set A, let \u00b52({\u03b1r}r\u2208A) = \u2228 r\u2208A \u03b1r and \u00b53({\u03b1r}r\u2208A) = \u2228 r\u2208A \u03b1r. Moreover, for any finite ordered set B, let \u03be(\u00d8) = 0\nand \u03be({\u03b1r}r\u2208B) = \u2228 r\u2208B \u03b1r."}, {"heading": "4.2 Deterministic Fuzzy Turing Machines", "text": "In order to describe a fuzzified \u201csequential computation\u201d within our framework, we use a mathematical model of deterministic fuzzy Turing machines equipped with read-only auxiliary-input tapes, rewritable input/work tapes, and write-only output tapes supported by safe tuples of auxiliary operators. This model is considered as an extension of ordinary nondeterministic Turing machines.\nLet \u2206 and \u0393 be an input alphabet and an output alphabet including a designated blank symbol #. To operate a machine, we need two more tape alphabets \u03a31 (with |c, $,# \u2208 \u03a31) and \u03a32 (= {|c, $, 1,#}) for the machine\u2019s internal use. We fix F\u03981 \u2286 F(\u2206 \u2217) and F\u03982 \u2286 F(\u0393 \u2217) and also fix a safe tuple \u039e = (\u00b51, \u00b52, \u00b53, \u03be) of auxiliary operators. A deterministic fuzzy Turing machine with a write-only output tape (abbreviated as DFTM) is a triplet \u3008M,\u039e, I\u3009, where M is of the form (Q,\u2206,\u03a31,\u03a32,\u0393, \u03b4, q0, F ) and I is a target set pair (F\u03981, F\u03982). Moreover, Q is a finite nonempty set of the machine\u2019s (inner) states and \u03b4 is a fuzzy transition function mapping from (Q\u2212 F )\u00d7\u03a31 \u00d7\u03a32 to F(Q\u00d7\u03a31 \u00d7 \u0393\u00d7D1 \u00d7D2) with Di = {0,\u00b11}, q0 (\u2208 Q) is the initial state, and F (\u2286 Q) is a set of halting states. Whenever M enters a halting state, since \u03b4 is no longer applicable, M is considered to halt.\nSince \u039e and I are fixed, we often refer to M as a DFTM as long as it is clear from the context. Graphically speaking, M works as follows. A fuzzy input instance s to M is a fuzzy object in F\u03981. Let \u2113(s) = maxx\u2208Supp(s){|x|} be the length of s. The DFTM M takes s and eventually produces another fuzzy subset M(s) of F\u03982 as its output. In an initial setup process, M receives s, it automatically generates in\nparallel all crisp strings x \u2208 Supp(s), and writes down each x, surrounded by two endmarkers |c and $, on the input/work tape and the other tape cells initially hold the blank symbol #. Moreover, M generates |c1\u2113(s)$ on the read-only auxiliary input tape. All tape cells are indexed by integers and all tape heads are initially positioned at the 0th cell (where |c must be written on the first two tapes). An inner state of M is q0.\nAssume that, at an arbitrary moment, the tape head of M scans symbol \u03c31 on the input/work tape and \u03c32 on the read-only input tape in inner state q and the third tape head is situated at the first (i.e., the leftmost) blank cell. When \u03b4 is applied, M overwrites \u03c31 with \u03c4 , enters state p, move the first two tape heads in directions d1 and d2, and writes symbol \u03b7 on the output tape, together with possibility degree \u03b4(q, \u03c31, \u03c32)(p, \u03c4, \u03b7, d1, d2). If \u03b7 6= \u03bb, then the output tape head must move to the right; otherwise, it stays still.\nLet us explain how a DFTM generates a \u201cfuzzy computation,\u201d composed of a set of fuzzy computation paths (i.e., series of configurations). A (global) configuration is a string of the form uqv\u266er\u266ew with u, v \u2208 \u03a3\u22171, q \u2208 Q, r \u2208 [0, \u2113(s)]Z, and w \u2208 \u0393\n\u2217, where \u266e is a designated separator, and uqv\u266er\u266ew indicates that an input/work tape content is uv, the second tape head scans cell r, an output tape content is w, an inner state is q, and the first and third tape heads are respectively scanning the leftmost symbol of v and the first blank symbol to the right of w. Let CONFM denote the set of all (possible) configurations of M , namely, {uqv\u266er\u266ew | u, v \u2208 \u03a3\u22171, q \u2208 Q, r \u2208 [0, \u2113(s)]Z, w \u2208 \u0393\n\u2217}. A final configuration is a configuration of the form uqv\u266er\u266ew with q \u2208 F in CONFM . Each element of F(CONFM ) is called a fuzzy instance description or a fuzzy configuration.\nLet us describe how a \u201ctime evolution\u201d of fuzzy configurations takes place. To express a fuzzy configuration at time i, we inductively introduce a fuzzy set confi (i \u2208 N) as follows. Let conf0 be a fuzzy configuration at time 0 defined as\nconf0(upv\u266er\u266ew) = \u2211\nx\u2208Supp(s)\ns(x) \u00b7 [upv\u266er\u266ew = q0|cx$\u266e0\u266e\u03bb]\nfor any configuration upv\u266er\u266ew of M . Next, confi+1 is a fuzzy configuration at time i + 1 whose possibility degree confi+1(u\n\u2032pv\u2032\u266er\u266ew\u2032) is defined as follows. Taking pre-determined orderings on (Q \u2212 F ) \u00d7 \u03a31 \u00d7 \u03a32 and D1 \u00d7 D2 and also assuming that u\n\u2032pv\u2032\u266ew\u2032 has the form u\u03c41p\u03c42\u03c43v\u266er\u266ew\u03b7 with p \u2208 Q \u2212 F and , let confi+1(u \u2032pv\u2032\u266er\u266ew\u2032) be\n\u00b52({\u2113d1,d2(q, \u03c31, \u03c32)}(d1,d2)\u2208D1\u00d7D2,(q,\u03c31,\u03c32)\u2208(Q\u2212F )\u00d7\u03a31\u00d7\u03a32),\nwhere \u2113d1,d2(q, \u03c31, \u03c32) represents the following values. For example, when (d1, d2) = (+1,\u22121), \u2113+1,\u22121(q, \u03c31, \u03c32) equals\n\u00b51(confi(uq\u03c3\u03c42\u03c43v\u266e(r + 1)\u266ew), \u03b4(q, \u03c31, \u03c32)(p, \u03c41, \u03b7,+1,\u22121)),\nwhere \u03c32 is the symbol at cell r+1. Notice that each value \u2113d1,d2(q, \u03c31, \u03c32) is always defined. If either p \u2208 F or u\u2032pv\u2032\u266er\u266ew\u2032 has a wrong form, then we set confi+1(u\n\u2032pv\u2032\u266er\u266ew\u2032) = 0. A fuzzy computation of M on fuzzy input s is a series (conf0, conf1, . . .) of fuzzy configurations defined\nabove. Let finalM be an element of F(N\u00d7 CONFM ) defined as\nfinalM(t, uqv\u266er\u266ew) = [q \u2208 F ] \u00b7 \u00b53({confi(uqv\u266er\u266ew)}i\u2208[0,t]Z )\nfor any uqv\u266er\u266ew in CONFM . This value finalM (t, uqv\u266er\u266ew) is called the possibility degree of the (final) configuration uqv\u266er\u266ew at time t. Let FINM (t, s) be the set of all pairs (uqv, r) with q \u2208 F , u, v \u2208 \u03a3\n\u2217, |uv| \u2264 t, and r \u2208 [0, \u2113(s)]Z. Obviously, FINM (t, s) is a finite set.\nSince we are interested in time-bounded computation, we define the (absolute) running time of M on input s to be a unique number t \u2208 N for which (i) there exists a final configuration u\u2032q\u2032v\u2032\u266er\u266ew\u2032 satisfying finalM(t, u\n\u2032q\u2032v\u2032\u266er\u266ew\u2032) > 0 and (ii) finalM(i, uqv\u266er\u266ew) = 0 holds for all configurations uqv\u266er\u266ew and all i > t. For convenience, we say that M (absolutely) halts on input s in time t if t is at least the running time of M on s.\nNow, let t be the running time of M on s. If b is a fuzzy subset of \u0393\u2217 satisfying\nb(w) = \u03be({finalM(t, uqv\u266er\u266ew)}(uqv,r)\u2208FINM (t,s))\nfor every w \u2208 \u0393\u2217, then we say that M outputs b on input s in time t. For convenience, we write M(s) to denote this particular fuzzy object b. Obviously, if M outputs b in time t, then |Supp(b)| \u2264 |\u0393|t holds, and thus b has a finite support.\nWe say that a fuzzy problem L admits a DFTM M (or M solves L) if M(s) = L(s) holds for any s \u2208 F\u03981. In this case, the problem L is succinctly denoted by L(M)."}, {"heading": "4.3 Fuzzy Gates and Fuzzy Circuits", "text": "In an ordinary setting, uniform families of Boolean circuits composed of Boolean gates have been used to model efficient algorithms. Likewise, we will consider a fuzzification of those circuits to model our intended fuzzy algorithms. In what follows, we fix a safe tuple \u039e\u2032 = (\u00b51, \u00b5 \u2032 2, \u00b53, \u03be) of auxiliary operators. A fuzzy gate is specified by a finite set of input variables attached with distinguished labels and another finite set of output variables having specific labels. A fuzzy gate with m inputs and k outputs simply represents a function mapping {0, 1}m to F({0, 1}k). For a physical implementation of fuzzy circuits, it may be desirable to restrict the usable types of fuzzy gates but, meanwhile, we allow any types of fuzzy gates.\nIn our fuzzy circuit model, a finite number of fuzzy gates are layered by \u201clevels.\u201d At each middle level, no two fuzzy gates must share output variables with the same label; however, fuzzy gates are allowed to share input variables with the same labels. Nevertheless, all input variables at level 0 have distinct labels. We also permit the use of \u201cfuzzy constants\u201d (i.e., elements in F({0, 1}\u2113) for a fixed \u2113) as part of inputs.\nLet us explain how a fuzzy circuit operates on a given set of inputs. Let (x1, x2, . . . , xn) be a series of all input variables used for a given fuzzy circuit. We define a global configuration conft at level t as follows. At level 0, let conf0(x1x2 . . . xn) = s(x1x2 \u00b7 \u00b7 \u00b7xn). For t \u2265 0, let G1, G2, . . . , Gm be all fuzzy gates aligned at level t+1 and let each fuzzy gate Gk have input variables ~vk = (vi1 , vi2 , . . . , via k ) as well as output variables ~wk = (wj1 , wj2 , . . . , wjb k ). Let ~v = (v1, v2, . . . , vc) be the series of all input variables of G1, G2, . . . , Gm and let (w1, w2, . . . , wd) be the series of all output variables of them. Now, we define\n\u2022 \u2113 (k) ~v\u2032 (~v \u2032 k, ~w \u2032 k) = \u00b51(conft(v \u2032 1, . . . , v \u2032 c), Gk(~v \u2032 k)(~w \u2032 k)), and \u2022 g(v\u20321, . . . , v \u2032 c)(w \u2032 1, . . . , w \u2032 d) = \u00b5 \u2032 1({\u2113 (k) ~v\u2032 (~v \u2032 k, ~w \u2032 k)}k\u2208[m]),\nwhere, given a variable a, a\u2032 means its arbitrary value. Finally, we define conft+1(w \u2032 1, . . . , w \u2032 d) to be\n\u00b53({g(v \u2032 1, . . . , v \u2032 c)(w \u2032 1, . . . , w \u2032 d)}(v\u20321,...,v\u2032c)\u2208Supp(conft)).\nAn output (or outcome) of C on input s is conft when t is the number of levels in C and we write C(s) to denote the outcome of C on s. Moreover, the size of C is the total number of fuzzy gates plus the number of all wires between variables and gates used in C.\nNow, we consider the aforementioned standard safe tuple of auxiliary operators together with \u00b5\u20322({\u03b1r}r\u2208B) = \u2227 r\u2208B \u03b1r.\nTheorem 4.1 Let f be any fuzzy function from F\u03981 to F\u03982. (1) If there is a DFTM computing f in polynomial time, then there exists a uniform family of fuzzy circuits of polynomial size that computes f . (2) If there is a uniform family of polynomial-size fuzzy circuits computing f , then there exists a DFTM M that computes f in polynomial time.\nProof Sketch. We prove only (1). Let M = (Q,\u2206,\u03a31,\u03a32,\u0393, \u03b4, q0, F ) be a DFTM computing f in polynomial time. We want to construct a uniform family {Cn}n\u2208N of fuzzy circuits that \u201csimulates\u201d M , and thus computes f . For each fuzzy gate gk at level t, we prepare variables {vt,\u03c3,k, v \u2032 t,q,k}t,\u03c3,q,k, where t \u2208 N, q \u2208 \u2206 \u222a {|c, $}, q \u2208 Q, and k \u2208 Z, used for inputs and outputs. Intuitively, vt,\u03c3,k = v \u2032 t,q,k = 1, for example, means that M in state q is scanning \u03c3 on cell k at time t. We assume a natural and efficient ordering of those variables. It is easy to design a fuzzy gate that \u201cmimics\u201d the behavior of \u03b4(q, \u03c31, \u03c32). Since M halts in time polynomial in the length \u2113(s) of s, the size of Cn is also upper-bounded by a certain polynomial in \u2113(s). However, gk\u22121, gk, gk+1 may share the same output variables. To avoid this situation, it is enough to distinguish them by slightly modifying their labels. \u2737"}, {"heading": "4.4 Fuzzy Proof Verification Systems", "text": "Nondeterminism has played a significant role in the development of the theory of NP-completeness. In the past literature, the notion of polynomial time-bounded nondeterminism has been characterized in various ways. Among them, we are interested in a particular characterization of NP problems, using proof verification processes; namely, NP problems are decision problems that have efficiently verifiable solutions (or proofs). Likewise, we will introduce a model of fuzzy proof verification system, in which a verifier tries to check the validity (or correctness) of a given proof, because we believe that this model is more suitable for practical use.\nLet us recall the definition of DFTM from Section 4.2 and expand it significantly by adding a mechanism of handling proofs (or certificates). To store such a proof during a verification process, we use an extra read-only infinite tape, called a proof tape. A fuzzy proof verification system (or an FPVS, in short) is a tuple \u3008N,F\u0398,\u039e, I\u3009, where F\u0398 is a set of all possible fuzzy proofs with F\u0398 \u2286 F(\u2206\u22172) and N = (Q,\u22061,\u22062,\u03a31,\u03a32,\u03a33,\u0393, \u03b4, q0, F ) is a 4-tape DFTM whose first and second tapes are the same as before, whose third tape is a read-only proof tape, and whose fourth one is a write-only output tape. Here, a fuzzy transition function \u03b4 is a map from \u03b4 : (Q\u2212F )\u00d7\u03a31 \u00d7\u03a32\u00d7\u03a33 to F(Q\u00d7\u03a31\u00d7\u03a32\u00d7\u0393\u00d7D1\u00d7D2\u00d7D3), where the ith tape uses a tape alphabet \u03a3i and its tape head moves in directions specified as Di (= {0,\u00b11}) for each index i \u2208 [3]. A configuration is now of the form upv\u266er\u266ey1hy2\u266ew, where y = y1y2 particularly represents the content of the proof tape and y1hy2 indicates that its tape head is at the leftmost symbol of y2. On input s with proof \u03c6, a fuzzy configuration confi at time i is defined as follows. Let conf0(upv\u266er\u266ey1hy2\u266ew) denote\ns(x) \u00b7 \u03c6(y) \u00b7 [upv\u266er\u266ey1hy2\u266ew = q0|cx$\u266e0\u266ehy\u266e\u03bb].\nAt time i + 1, we assume that u\u2032pv\u2032\u266er\u266ey\u20321hy \u2032 2\u266ew \u2032 is of the form u\u03c41p\u03c42\u03c43\u266er\u266ey1\u03be1h\u03be2\u03be3y2\u266ew\u03b7. Let confi+1(u \u2032pv\u2032\u266er\u266ey\u20321hy \u2032 2\u266ew \u2032) denote\n\u00b52({\u2113d1,d2,d3(q, \u03c31, \u03c32, \u03c33)}(q,\u03c31,\u03c32,\u03c33),(d1,d2,d3)),\nwhere (q, \u03c31, \u03c32, \u03c33) \u2208 (Q \u2212 F ) \u00d7 \u03a31 \u00d7 \u03a32 \u00d7 \u03a33, d1, d2, d3 \u2208 {0,\u00b11}, each \u2113d1,d2,d3(q, \u03c31, \u03c32, \u03c33) is defined similarly to \u2113d1,d2(q, \u03c31, \u03c32) in Section 4.2; for example, \u2113+1,\u22121,+1(q, \u03c31, \u03c32, \u03c33) equals\n\u00b51(confi(u \u2032\u266er\u2032\u266ey\u2032\u266ew, \u03b4(q, \u03c31, \u03c32, \u03c33)(p, \u03c41, \u03b7,+1,\u22121,+1)),\nwhere r\u2032 = r + 1 and u\u2032\u266er\u2032\u266ey\u2032\u266ew expresses the string uq\u03c31\u03c42\u03c43v\u266er \u2032\u266ey1h\u03be1\u03be2\u03be3\u266ew.\nLet FINN (t, s, \u03c6) be the set of all (uqv, r, y1hy2) with u, v \u2208 \u03a3 \u2217 1, y1y2 \u2208 Supp(\u03c6), q \u2208 F , |uv| \u2264 t, and r \u2208 [0, \u2113(s)]Z. As in Section 4.2, finalN and the running time t of N are similarly defined. Write N(s, \u03c6) to denote an output (i.e., a fuzzy subset of {0, 1}) b of N on input s with proof \u03c6, where b(w) is defined as\n\u03be({finalN(t, uqv\u266er\u266ey1hy2\u266ew)}(uqv,r,y1hy2)\u2208FINN (t,s,\u03c6)).\nAn outcome N(s) of the FPVS N on input s is defined as \u2022 N(s)(1) = sup\u03c6\u2208F\u0398{N(s, \u03c6)(1)} and \u2022 N(s)(0) = inf\u03c6\u2208F\u0398{N(s, \u03c6)(0)}.\nWe say that L admits N (or N solves L) if N(s) = L(s) for all s \u2208 F\u03981. The notation L(N) expresses the fuzzy decision problem solved by N .\nAs a concrete example of fuzzy decision problems admitting FPVS\u2019s, we present the Fuzzy Circuit Satisfiability Problem (abbreviated as Fuzzy-Circuit-SAT).\nFuzzy-Circuit-SAT (w.r.t. F\u0398) \u2022 Fuzzy Instance: a (description of) fuzzy circuit C that takes inputs from F\u0398. \u2022 Fuzzy Output: output a fuzzy set b \u2208 F({0, 1}), where b(1) = sups\u2208F\u0398{C(s)(1)} and b(0) = infs\u2208F\u0398{C(s)(0)}.\nTo solve this Fuzzy-Circuit-SAT, it is possible to construct an FPVS using Theorem 4.1. Hence, we obtain the following.\nLemma 4.2 There exists an FPVS that solves Fuzzy-Circuit-SAT in polynomial time."}, {"heading": "5 Reductions among Fuzzy Problems", "text": "The notion of reducibility is a basis to NP-completeness and numerous forms of the reducibility have been proposed. Here, we will consider only its simple fuzzification. Firstly, we will define an important fuzzy function class Fuzzy-FPA(\u03b3) of polynomial-time approximately computable fuzzy functions. Using functions in Fuzzy-FPA(\u03b3), we will introduce AF- and APF-reducibilities, which are viewed as natural fuzzifications of Krentel\u2019s metric reducibility [9] and AP-reducibility [2]."}, {"heading": "5.1 Relative Approximation of Membership Degree", "text": "In Section 4.2, we have introduced a DFTM model to capture the notion of fuzzy algorithm. However, the exact use of DFTM\u2019s seems too restrictive to solve a wide range of practical fuzzy problems. It is thus desirable to allow the DFTM\u2019s to \u201capproximate\u201d the outcomes of the fuzzy problems.\nTo describe this \u201capproximation,\u201d let \u03b3 : N \u2192 [1,\u221e) be any crisp function, called an imprecision tolerance parameter. Let F\u0398 \u2286 F\u2206\u2217 for alphabet \u2206 as before. For any two fuzzy subsets F and G of the universe F\u0398, we say that F is a \u03b3-approximation of G if F (x)/\u03b3(|x|) \u2264 G(x) \u2264 \u03b3(|x|)F (x) for any element x in F\u0398.\nDefinition 5.1 (approximate solving) Let M be either an DFTM or an FPVS. We say that M \u03b3approximately solves fuzzy problem L if, for any admissible fuzzy input s, M takes s as an input and produces a certain fuzzy solution M(s) that is a \u03b3-approximation of L(s).\nIn ordinary computational complexity theory, FP denotes the set of all crisp functions on crisp strings computable in polynomial time. We introduce an analogous \u201cfuzzy\u201d function class denoted by Fuzzy-FPA(\u03b3) using the \u03b3-approximability.\nDefinition 5.2 (Fuzzy-FPA(\u03b3)) Let \u03b3 : N \u2192 [1,\u221e) be any imprecision tolerance parameter and fix a safe tuple \u039e. For convenience, we define Fuzzy-FPA\u039e(\u03b3) to be the set of all (combinatorial generic) fuzzy problems, each of which can be \u03b3-approximately solved by a certain polynomial-time DFTM. The \u201cPA\u201d stands for \u201cpolynomial-time approximate.\u201d When \u039e is clear from the context, we drop \u039e and write Fuzzy-FPA(\u03b3).\nLet us introduce four classes of fuzzy functions. The notation const expresses the set of all constant functions (which we usually identify with \u201cconstants\u201d), poly does the set of all polynomials, and exp does the set of all exponential functions. We then obtain the following chain of containments: Fuzzy-FPA(1) \u2286 Fuzzy-FPA(const) \u2286 Fuzzy-FPA(poly) \u2286 Fuzzy-FPA(exp).\nWe can show that FP is a crisp part of Fuzzy-FPA if we take the following method of fuzzifying crisp objects. For each crisp string x in \u2206\u2217, the notation x\u0302 denotes its specific fuzzified object {(x, 1)} \u222a {(y, 0) | y \u2208 \u2206\u2217 \u2212 {x}} in F(\u2206\u2217).\nLemma 5.3 For any crisp function f : \u2206\u2217 \u2192 \u0393\u2217 in FP, there exists a fuzzy function g \u2208 Fuzzy-FPA(1) such that, for every (x, y) \u2208 \u2206\u2217 \u00d7 \u0393\u2217, f(x) = y if and only if g(x\u0302) = y\u0302.\nLemma 5.4 Let F \u2208 {1, const, poly, exp}. Fuzzy-FPA(F) is closed under functional composition; namely, for any two elements f, g \u2208 Fuzzy-FPA(F), the function h defined as h(s) = g(f(s)) for every s is also in Fuzzy-FPA(F)."}, {"heading": "5.2 Approximate Fuzzy Reductions", "text": "To compare the computational complexities of two (generic) fuzzy problems, we need to devise a notion of \u201cfuzzy reducibility,\u201d which is a mechanism (similar to the metric reducibility in [9]) of transforming instances of one decision problem to instances of another decision problem so that corresponding outputs of those instances are close enough.\nDefinition 5.5 (AF-reducibility) Let F be any fuzzy function mapping F\u03981 to F\u03982 and let G be any fuzzy function from F\u03983 to F\u03984. We say that F is polynomial-time \u03b3-approximately fuzzy reducible (or AF(\u03b3)-reducible, in short) to G if there exist two functions f, g in Fuzzy-FPA(F) with f : F\u03981 \u2192 F\u03983 and g : F\u03981\u00d7F\u03984 \u2192 F\u03982 and a function \u03b3 \u2208 F such that, for any s \u2208 F\u03981, g(s,G(f(s))) is a \u03b3-approximation of F (s). In this case, we write F \u2264 (F) AF G. This triplet (f, g, \u03b3) is called an AF(F)-reduction of F to G.\nThe next lemma establishes the reflexivity and the transitivity of the AF-reducibility. Thus, the AF(F)reducibility forms a partial order in the set of all fuzzy problems.\nLemma 5.6 Let F \u2208 {1, const, poly, exp}. For any three fuzzy problems A,B,C having the same range, it holds that (1) A \u2264 (F) AF A and (2) A \u2264 (F) AF B and B \u2264 (F) AF C imply A \u2264 (F) AF C.\nReducibility between two fuzzy optimization problems, in contrast, requires a more delicate treatment. As a natural fuzzification of the ordinary AP-reducibility (see, e.g., [2]), we introduce the following APF-\nreducibility. Let R(s, t) = max{|m(s, u)/m\u2217(s)| , |m\u2217(s)/m(s, u)|} for a given fuzzy measure function m. We set Q>1 = {r \u2208 Q | r > 1}.\nDefinition 5.7 (APF-reducibility) For any two fuzzy optimization problems A = (I1, SOL1,m1, goal) and B = (I2, SOL2,m2, goal), we say that A is polynomial-time approximation-preserving fuzzy (APF) reducible to B with respect to F , denoted by A \u2264 (F) APF B, if the following condition holds: there exist a pair (f, g) of fuzzy functions and a constant c > 0 such that (1) f(s, r) \u2208 I2 for any s \u2208 I1 and r \u2208 Q\n>1; (2) SOL1(s) 6= \u00d8 implies SOL2(f(s, r)) 6= \u00d8; (3) u \u2208 SOL2(f(s, r)) implies g(s, u, r) \u2208 SOL1(s); (4) f, g \u2208 Fuzzy-FPA(F) for each fixed r \u2208 Q>1; (5) R2(f(s, r), u) \u2264 r \u2192 R1(s, g(s, u, r)) \u2264 1 + c(r \u2212 1)."}, {"heading": "6 Fuzzy Decision Problems", "text": "In ordinary complexity theory, decision problems are identified with sets of words (or strings) and they are also called languages. The fundamental complexity classes of languages are P and NP. Analogously, we recognize two special classes of fuzzy decision problems.\nDefinition 6.1 (Fuzzy-PA(\u03b3), Fuzzy-NPA(\u03b3)) Let Fuzzy-PA(\u03b3) be a subclass of Fuzzy-FPA(\u03b3), which consists only of fuzzy decision problems. Moreover, Fuzzy-NPA(\u03b3) denotes the set of all fuzzy decision problems that can be \u03b3-approximately solved by polynomial-time FPVS\u2019s.\nSince DFTMs are a special case of FPVS\u2019s, it immediately follows that Fuzzy-PA(\u03b3) \u2286 Fuzzy-NPA(\u03b3) for any \u03b3. As in Section 5.1, we write Fuzzy-PA (resp., Fuzzy-NPA) for Fuzzy-PA(const) (resp., Fuzzy-NPA(const)).\nNotice that DFTMs are in fact an extension of ordinary NTMs. Therefore, it is not surprising to show that all NP sets can be solved by DFTMs in polynomial time if we use an appropriate fuzzification (i.e., if we assign appropriately-chosen possibility degrees). Recall from Section 5.1 the fuzzification x\u0302 of crisp string x. If a fuzzification L\u0302 of crisp language L is defined to satisfy that L\u0302(x\u0302) = {(0, 0), (1, 1)} if x \u2208 L and L\u0302(x\u0302) = {(0, 1), (1, 0)} otherwise, we can show that, for any language L \u2208 NP, L\u0302 belongs to Fuzzy-PA(1).\nProposition 6.2 For every set A \u2208 NP over alphabet \u2206, there exists a fuzzy decision problem B \u2208 Fuzzy-PA(1) such that A = {x \u2208 \u2206\u2217 | B(x\u0302)(1) = 1} and A = {x \u2208 \u2206\u2217 | B(x\u0302)(1) = 0}.\nHereafter, we assume that F \u2208 {1, const, poly, exp}.\nLemma 6.3 The fuzzy complexity class Fuzzy-PA(F) is closed under AF(F)-reductions.\nProof Sketch. It suffices to show that, for any two fuzzy problems A and B, if A is AP-reducible to B and B is in Fuzzy-PA, then A is also in Fuzzy-PA(F). Since A \u2264 (F) AF B, take a reduction (f, g, \u03b3) with f, g \u2208 Fuzzy-FPA(F) that reduces A to B. Since B \u2208 Fuzzy-PA(F), take a DFTM M that solves B. It suffices to consider the following DFTM G: on input s, generate all x \u2208 Supp(s) in parallel, compute Mf on them, starts the simulation of N , and compute Mg. \u2737\nNow, we introduce a key concept of \u201ccompleteness.\u201d\nDefinition 6.4 (completeness) We say that a fuzzy decision problem A is complete for Fuzzy-NPA(F) (or simply, Fuzzy-NPA(F)-complete) if (i) A is in Fuzzy-NPA(F) and (ii) for every fuzzy decision problem B in Fuzzy-NPA(F), A is AF(F)-reducible to B.\nLemma 6.5 Let A be a fuzzy decision problem complete for Fuzzy-NPA(F). If A is in Fuzzy-PA(F), then Fuzzy-PA(F) = Fuzzy-NPA(F) holds.\nProof Sketch. The containment Fuzzy-PA \u2286 Fuzzy-NPA is obvious. Next, we will show the other containment. Take any fuzzy problem B in Fuzzy-NPA. By the definition of \u201ccompleteness,\u201d B is APreducible to A. Assume that A is in Fuzzy-PA. By Lemma 6.3, it follows that B is also in Fuzzy-PA. Thus,\nFuzzy-NPA \u2286 Fuzzy-PA. \u2737\nFinally, we will demonstrate the existence of complete problems for Fuzzy-NPA(1). Our choice of such problem is Fuzzy-Circuit-SAT, defined in Section 4.4.\nTheorem 6.6 The fuzzy problem Fuzzy-Circuit-SAT is complete for Fuzzy-NPA(1).\nProof Sketch. Recall from Lemma 4.2 that Fuzzy-Circuit-SAT is in Fuzzy-NPA(1). What remains to show is that any problem, say, A in Fuzzy-NPA(1) is AF-reducible to Fuzzy-Circuit-SAT . Given such A, take an FPVS N for A. By Theorem 4.1(1), we can choose a family of fuzzy circuits that \u201csimulates\u201d N when input s and proof \u03c6 are initially given. It thus suffices to define an AF-reduction pair (f, g) as follows. Let f(s) be a circuit obtained from C by incorporating it with s (treating \u03c6 as only a true input). The function g is defined as the identity function. \u2737"}, {"heading": "7 Fuzzy Optimization Problems", "text": "Briefly, we will discuss the computational complexity of fuzzy optimization problems. The theory of NP optimization problems has made a huge success in classifying \u201ccomplete\u201d problems in NPO (the class of NP optimization problems). We will pay our attention to \u201cfuzzy NPA\u201d optimization problems.\nDefinition 7.1 (Fuzzy-NPO(\u03b3)) A fuzzy NPA(\u03b3) optimization problem (or a fuzzy NPAO(\u03b3) problem) P is a fuzzy optimization problem (I, SOL,m, goal) as defined in Section 3 such that I \u25e6SOL is in Fuzzy-PA(\u03b3) and m is in Fuzzy-FPA(\u03b3). We write Fuzzy-NPAO(\u03b3) for the class of all fuzzy NPAO(\u03b3) problems.\nSimilar to Fuzzy-NPA(1), Fuzzy-NPAO(1) has complete problems under AFP(1)-reductions.\nTheorem 7.2 There exists a fuzzy optimization problem that is complete for Fuzzy-NPAO(1) under APF(1)reductions."}], "references": [{"title": "D", "author": ["M.F. Abbod"], "venue": "G. von Keyserlingk, D. A. Linkens, and M. Mahfouf. Survey of utilisation of fuzzy technology in medicine and healthcare. Fuzzy Sets and Systems 120, 331\u2013349", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2001}, {"title": "V", "author": ["G. Ausiello", "P. Crescenzi", "G. Gambosi"], "venue": "Kann, Marchetti-Spaccamela, and M. Protasi. Complexity and Approximation: Combinatorial Optimization Problems and Their Approximability Properties, Springer", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2003}, {"title": "Unified approach to fuzzy graph problems", "author": ["M. Blue", "B. Bush", "J. Puckett"], "venue": "Fuzzy Sets and Systems, 125, 355\u2013368", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2002}, {"title": "New directions in fuzzy automata", "author": ["M. Doostfatemeh", "S. Kremer"], "venue": "Int. J. Approx. Reason., 38, 175\u2013214", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2005}, {"title": "Computers and Intractability: Guide to the Theory of NP- Completeness", "author": ["M.R. Garey", "D.S. Johnson"], "venue": "W. H. Freeman and Company", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1979}, {"title": "and W", "author": ["R. Goetschel Jr"], "venue": "Voxman. Fuzzy circuits. Fuzzy Sets and Systems, 32, 35-43", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1989}, {"title": "Applied Fuzzy Arithmetic: An Introduction with Engineering Applications", "author": ["M. Hanss"], "venue": "Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2010}, {"title": "Fundamentals of fuzzy logical circuits", "author": ["K. Hirota"], "venue": "Proc. of IJCAI \u201991 Workshops on Fuzzy Logic and Fuzzy Control, Lecture Notes in Computer Science, vol. 833, pp. 143\u2013157", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1994}, {"title": "The complexity of optimization problems", "author": ["M.W. Krentel"], "venue": "J. Comput. Syst., 36, 490\u2013509", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1988}, {"title": "Note on fuzzy languages", "author": ["E.T. Lee", "L.A. Zadeh"], "venue": "Inform. Sci., 4, 421\u2013434", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1969}, {"title": "Fuzzy models for single-period inventory problem", "author": ["L. Li", "S.N. Kabadi", "K.P.K. Nair"], "venue": "Fuzzy Sets and Systems 132, 273\u2013289", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2002}, {"title": "Fuzzy algorithms", "author": ["E.S. Santos"], "venue": "Inform. Control, 17, 326\u2013339", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1970}, {"title": "Fuzzy sets", "author": ["L.A. Zadeh"], "venue": "Inform. Control 8, 338\u2013353", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1965}, {"title": "Fuzzy algorithms", "author": ["L.A. Zadeh"], "venue": "Inform. Control, 12, 94\u2013102", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1968}], "referenceMentions": [{"referenceID": 12, "context": "Based on a nonstandard logic, Zadeh [13] tried to capture this fuzziness mathematically by formulating a basic concept of fuzzy set.", "startOffset": 36, "endOffset": 40}, {"referenceID": 0, "context": ", [1, 7]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 6, "context": ", [1, 7]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 13, "context": "\u201d Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) .", "startOffset": 135, "endOffset": 139}, {"referenceID": 9, "context": "\u201d Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) .", "startOffset": 155, "endOffset": 159}, {"referenceID": 11, "context": "\u201d Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) .", "startOffset": 172, "endOffset": 176}, {"referenceID": 3, "context": "To cope with a wide range of practical fuzzy problems, Doostfatemeh and Kremer [4] suggested how to expand the then-existing models of fuzzy algorithms by supplementing extra \u201csafe\u201d auxiliary operators to tune up the behaviors of those algorithms.", "startOffset": 79, "endOffset": 82}, {"referenceID": 5, "context": ", [6, 8]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 7, "context": ", [6, 8]).", "startOffset": 2, "endOffset": 8}, {"referenceID": 4, "context": "Such a reducibility notion among fuzzy decision problems makes it possible to designate \u201ccomplete\u201d problems, which indicate the most difficult problems in a given class of problems to solve in polynomial time, as for the notion of NP-complete problems (see [5]).", "startOffset": 257, "endOffset": 260}, {"referenceID": 0, "context": "The notation [0, 1] \u2217 (resp.", "startOffset": 13, "endOffset": 19}, {"referenceID": 0, "context": ", [0, 1]) denotes the union of [0, 1] for any constant k \u2208 N (resp.", "startOffset": 2, "endOffset": 8}, {"referenceID": 0, "context": ", [0, 1]) denotes the union of [0, 1] for any constant k \u2208 N (resp.", "startOffset": 31, "endOffset": 37}, {"referenceID": 0, "context": "Although a fuzzy (sub)set A of universe U is a map from U to [0, 1], it is also viewed as an ordinary set that is composed of pairs of the form (x, \u03b3), where x \u2208 U and \u03b3 \u2208 [0, 1]; that is, (x, \u03b3) \u2208 A iff \u03b3 = A(x).", "startOffset": 61, "endOffset": 67}, {"referenceID": 0, "context": "Although a fuzzy (sub)set A of universe U is a map from U to [0, 1], it is also viewed as an ordinary set that is composed of pairs of the form (x, \u03b3), where x \u2208 U and \u03b3 \u2208 [0, 1]; that is, (x, \u03b3) \u2208 A iff \u03b3 = A(x).", "startOffset": 172, "endOffset": 178}, {"referenceID": 0, "context": "Remark: It may be possible to expand our definition of fuzzy sets by replacing the unit interval [0, 1] with an arbitrary complete lattice and expand our results further.", "startOffset": 97, "endOffset": 103}, {"referenceID": 6, "context": ", [7]) and is closely related to \u201cdiscretized\u201d fuzzy numbers.", "startOffset": 2, "endOffset": 5}, {"referenceID": 0, "context": ", the Hamming distance between two crisp strings) is a fuzzy string quantity s over \u03a3 that satisfies the following condition: there exist a crisp string x0 \u2208 \u03a3 \u2217 and a crisp function \u03b7 : [0, 1] \u2192 [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) \u03b7 is strictly decreasing function with \u03b7(0) = 1 and \u03b7(1) = 0, and (3) Cut\u03b3(s) \u2286 Balld(x0, \u03b7(\u03b3)) holds for any real number \u03b3 \u2208 [0, 1], where Balld(x, \u03b3) = {z \u2208 \u03a3 \u2217 | d(x, z) \u2264 \u03b3}.", "startOffset": 187, "endOffset": 193}, {"referenceID": 0, "context": ", the Hamming distance between two crisp strings) is a fuzzy string quantity s over \u03a3 that satisfies the following condition: there exist a crisp string x0 \u2208 \u03a3 \u2217 and a crisp function \u03b7 : [0, 1] \u2192 [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) \u03b7 is strictly decreasing function with \u03b7(0) = 1 and \u03b7(1) = 0, and (3) Cut\u03b3(s) \u2286 Balld(x0, \u03b7(\u03b3)) holds for any real number \u03b3 \u2208 [0, 1], where Balld(x, \u03b3) = {z \u2208 \u03a3 \u2217 | d(x, z) \u2264 \u03b3}.", "startOffset": 196, "endOffset": 202}, {"referenceID": 0, "context": ", the Hamming distance between two crisp strings) is a fuzzy string quantity s over \u03a3 that satisfies the following condition: there exist a crisp string x0 \u2208 \u03a3 \u2217 and a crisp function \u03b7 : [0, 1] \u2192 [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) \u03b7 is strictly decreasing function with \u03b7(0) = 1 and \u03b7(1) = 0, and (3) Cut\u03b3(s) \u2286 Balld(x0, \u03b7(\u03b3)) holds for any real number \u03b3 \u2208 [0, 1], where Balld(x, \u03b3) = {z \u2208 \u03a3 \u2217 | d(x, z) \u2264 \u03b3}.", "startOffset": 397, "endOffset": 403}, {"referenceID": 3, "context": "For a wider range of practical applications of fuzzy machines, Doostfatemeh and Kremer [4] proposed a rigorous use of \u201cauxiliary functions\u201d to a design of fuzzy algorithms (actually, fuzzy finite automata in their case).", "startOffset": 87, "endOffset": 90}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 139, "endOffset": 145}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 150, "endOffset": 156}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 163, "endOffset": 169}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 174, "endOffset": 180}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 187, "endOffset": 193}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 198, "endOffset": 204}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 214, "endOffset": 220}, {"referenceID": 0, "context": "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (\u03bc1, \u03bc2, \u03bc3, \u03be), where \u03bc1 : [0, 1] 2 \u2192 [0, 1], \u03bc2 : [0, 1] + \u2192 [0, 1], \u03bc3 : [0, 1] + \u2192 [0, 1], and \u03be : [0, 1] \u2192 [0, 1].", "startOffset": 223, "endOffset": 229}, {"referenceID": 0, "context": "A tuple (\u03bc1, \u03bc2, \u03bc3, \u03be) of auxiliary operators is said to be safe if those functions satisfy the following conditions: for any finite nonempty ordered set A and any finite ordered set B, (1) \u03bc1(\u03b1, \u03b1) = \u03b1 for any \u03b1 \u2208 [0, 1], (2) \u03bc2({\u03b1r}r\u2208A) = \u03b1 if \u03b1r = \u03b1 for all r \u2208 A, (3) \u03bc3({\u03b1r}r\u2208A) = \u03b1 if \u03b1r = \u03b1 for all r \u2208 A, and (4) \u03be(\u00d8) = 0 and \u03be({\u03b1r}r\u2208B) = \u03b1 if \u03b1r = \u03b1 for r \u2208 B.", "startOffset": 216, "endOffset": 222}, {"referenceID": 2, "context": "Here, a fuzzy transition function \u03b4 is a map from \u03b4 : (Q\u2212F )\u00d7\u03a31 \u00d7\u03a32\u00d7\u03a33 to F(Q\u00d7\u03a31\u00d7\u03a32\u00d7\u0393\u00d7D1\u00d7D2\u00d7D3), where the ith tape uses a tape alphabet \u03a3i and its tape head moves in directions specified as Di (= {0,\u00b11}) for each index i \u2208 [3].", "startOffset": 224, "endOffset": 227}, {"referenceID": 8, "context": "Using functions in Fuzzy-FPA(\u03b3), we will introduce AF- and APF-reducibilities, which are viewed as natural fuzzifications of Krentel\u2019s metric reducibility [9] and AP-reducibility [2].", "startOffset": 155, "endOffset": 158}, {"referenceID": 1, "context": "Using functions in Fuzzy-FPA(\u03b3), we will introduce AF- and APF-reducibilities, which are viewed as natural fuzzifications of Krentel\u2019s metric reducibility [9] and AP-reducibility [2].", "startOffset": 179, "endOffset": 182}, {"referenceID": 8, "context": "To compare the computational complexities of two (generic) fuzzy problems, we need to devise a notion of \u201cfuzzy reducibility,\u201d which is a mechanism (similar to the metric reducibility in [9]) of transforming instances of one decision problem to instances of another decision problem so that corresponding outputs of those instances are close enough.", "startOffset": 187, "endOffset": 190}, {"referenceID": 1, "context": ", [2]), we introduce the following APF-", "startOffset": 2, "endOffset": 5}], "year": 2015, "abstractText": "We re-examine a practical aspect of combinatorial fuzzy problems of various types, including search, counting, optimization, and decision problems. We are focused only on those fuzzy problems that take series of fuzzy input objects and produce fuzzy values. To solve such problems efficiently, we design fast fuzzy algorithms, which are modeled by polynomial-time deterministic fuzzy Turing machines equipped with read-only auxiliary tapes and write-only output tapes and also modeled by polynomialsize fuzzy circuits composed of fuzzy gates. We also introduce fuzzy proof verification systems to model the fuzzification of nondeterminism. Those models help us identify four complexity classes: Fuzzy-FPA of fuzzy functions, Fuzzy-PA and Fuzzy-NPA of fuzzy decision problems, and Fuzzy-NPAO of fuzzy optimization problems. Based on a relative approximation scheme targeting fuzzy membership degree, we formulate two notions of \u201creducibility\u201d in order to compare the computational complexity of two fuzzy problems. These reducibility notions make it possible to locate the most difficult fuzzy problems in Fuzzy-NPA and in Fuzzy-NPAO. 1 Background and Results Our purpose is to (1) make a theoretical groundwork necessary to carry out practical analyses of \u201cgeneralized\u201d fuzzy problems that have naturally arisen in industrial applications and (2) lay out a theoretical framework for \u201cgeneralized\u201d fuzzy algorithms that efficiently solve those \u201cgeneralized\u201d fuzzy problems. 1.1 Practical Realm of Fuzzy Problems In real-life situations, many objects naturally embody certain degrees of fuzziness, which can be in general expressed in terms of the uncertainty, ambiguity, vagueness, or imprecision of the objects. Based on a nonstandard logic, Zadeh [13] tried to capture this fuzziness mathematically by formulating a basic concept of fuzzy set. In his theory, an ordinary object without any fuzziness is distinctly called as a \u201ccrisp\u201d object, whereas a fuzzy object is a combination of crisp object and its membership degree (or certainty degree) that indicates intuitively how likely the crisp object actually exists. Since its introduction, fuzzy theory has found numerous applications from digital image processing to voice recognition, to telecommunication, further to a field of medicine and agriculture (see, e.g., [1, 7]). To handle a wide variety of practical fuzzy problems, we still need to lay out a groundwork in developing a general, coherent theory of fuzzy problems and fuzzy algorithms that efficiently solve them. In the rest of this paper, we wish to limit our interest within combinatorial problems, which include search, counting, optimization, and decision problems. Let us first recall that, in an ordinary theory, those problems are viewed as functions that map every input instance to its desirable solution (or solutions). In the past literature, there have been numerous ways to fuzzificate ordinary combinatorial problems and those fuzzification methods significantly vary, depending on target areas of interests. We wish to re-examine a fuzzification of those problems to develop our general framework. In many abstract treatments of fuzzy problems, input instances are merely pairs of crisp objects and their membership degrees, instead of more general \u201cfuzzy objects.\u201d To expand a scape of fuzzy-logic applications, it is more desirable to deal with the case where an input instance is a series of admissible fuzzy objects (or fuzzy data) and an output could be a desired \u201cfuzzy object\u201d as a solution derived from the given input. Formally, we define our \u201cfuzzy problem\u201d as a mapping from each series of fuzzy objects to another fuzzy object; thus, the term \u201cfuzzy problem\u201d becomes a synonym of \u201cfuzzy functions.\u201d To describe those fuzzy problems, we need to specify two items: fuzzy (input) instance and fuzzy output. For technical reason, we assume that the support of any fuzzy instance is finite, where the support of a fuzzy object over universe U is an ordinary set of elements in U having positive membership degrees. To distinguish our fuzzy problems This extended abstract appeared in the Proceedings of the Joint 7th International Conference on Soft Computing and Intelligent Systems (SCIS 2014) and 15th International Symposium on Advanced Intelligent Systems (ISIS 2014), December 3\u20136, 2014, Institute of Electrical and Electronics Engineers (IEEE), pp. 29\u201335, 2014. Present Affiliation: Department of Information Science, University of Fukui, 3-9-1 Bunkyo, Fukui 910-8507, Japan", "creator": "LaTeX with hyperref package"}}}