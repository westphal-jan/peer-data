{"id": "1510.04212", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Oct-2015", "title": "Inheritance in Object-Oriented Knowledge Representation", "abstract": "same paper addressed historical consideration of inheritance mechanism in natural knowledge reservoir models utilizing arbitrary - indexed programming, databases and object - driven dynamic schemes. in addition, weaknesses within representation of vague and isolated knowledge are presently considered. subset types of inheritance, general classification of all known inheritance types general approach, which ensure avoiding case - temporal problems especially exceptions, redundancy and exhaustion among object - oriented dynamic flows and their fuzzy extension, are contemplated regarding the paper. the proposed approach bases rational conception that global and inhomogeneous or heterogeneous class of inherited, there allow satisfying modular inheritance management tasks flexibly and efficiently.", "histories": [["v1", "Wed, 14 Oct 2015 17:34:11 GMT  (10kb)", "http://arxiv.org/abs/1510.04212v1", "in Information and Software Technologies, Communications in Computer and Information Science, Springer, 2015"]], "COMMENTS": "in Information and Software Technologies, Communications in Computer and Information Science, Springer, 2015", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["dmytro terletskyi"], "accepted": false, "id": "1510.04212"}, "pdf": {"name": "1510.04212.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Dmytro Terletskyi", "Taras Shevchenko"], "emails": ["dmytro.terletskyi@gmail.com,"], "sections": [{"heading": null, "text": "ar X\niv :1\n51 0.\n04 21\n2v 1\n[ cs\n.A I]\n1 4\nO ct\nKeywords: single inheritance, multiple inheritance, strong inheritance, weak inheritance, full inheritance, partial inheritance"}, {"heading": "1 Introduction", "text": "Nowadays the design and development of knowledge-based systems for solving problems in different domains are important tasks within area of artificial intelligence. Currently there are many different knowledge representation models (KRM), the most famous of which are logical models, production models, semantic networks, frames, scripts, conceptual graphs, ontologies, etc. All of these KRMs have their own specifics and allow representing of some types of knowledge. However, the certain programming paradigm should be chosen for implementation of any particular KRM. For today the most famous and commonly used programming paradigm is an object-oriented programming (OOP). It gives us an opportunity of efficient implementation of many existing KRM, in particular those that are object-oriented, e.g. frames, scripts. We should take into account that the knowledge in forms of any KRM must be somehow represented in the database. Object-oriented approach to knowledge representation is very suitable for this purpose, because it provides such powerful tool, as inheritance mechanism. It allows building of inheritance hierarchies and avoiding of redundancy of knowledge representation in database, because it partially implements the conception of reusability. In its turn, inheritance hierarchy as a type of\nknowledge structure provides an efficient mechanisms of reasoning about knowledge. Furthermore, the modern versions of most OOP-languages support such a programming technique as object-relational mapping (ORM), which provides convenient interaction among object-oriented programs and databases.\nHowever, despite all advantages of object-oriented approach to knowledge representation, it also has some drawbacks. Firstly, inheritance mechanism leads three main kinds of problems, such as problem of exceptions, problem of redundancy and problem of ambiguity [1], [13]. They arise during constructing of inheritance hierarchies and reasoning within them. Secondly, a lot of human knowledge have vague and imprecise nature [2], [6] and OOP does not support representation of such knowledge. Thirdly, OOP provides an opportunity to create and to operate only with homogeneous classes [10], that is why we need to create new class for every new type of objects, even when some of them are similar."}, {"heading": "2 Inheritance in Object-Oriented Programming", "text": "Nowadays there are two main approaches in modern OOP, which are implemented within class-based and prototype-based programming languages [3]. The main idea of first approach is an identification of common properties of some quantity of objects and their description within such structure as class. Objects exist only in runtime as a result of instantiating of a class. Within the second approach, the objects are results of cloning operation, which is applied to prototypes, where prototypes define stereotypical objects. The new prototype can be obtained as a modification of copy of other prototype. Currently, class-based programming approach is more commonly used than prototype-based one and most of modern OOP-languages support exactly class-based style. That is why all future considerations concerning OOP will be done within class-based programming approach.\nIn paradigm of OOP, class defines a kind of a concept, and objects are instances of it. Each class consists of fields and methods, where fields define the structure of the class and methods define its behavior. In other words, fields define properties of the concept and methods are functions that give an opportunity to manipulate them. When the program creates an object as an instance of some class, this object has the same fields, as its class and each method of the class can be called for this object. In such a way, class implements the mechanism of encapsulation, because the object has the same structure and behavior, but it has its own values of the fields, which can differ from corresponding values of class\u2019s fields and can be changed during program execution."}, {"heading": "2.1 Single Inheritance", "text": "Class-based approach provides an ability to define the class using the existing definition of another class. In this case, one class can inherit specifics of another one. Moreover, it can extend or specialize the inherited specifics by adding its\nown features. This process is called single inheritance [3]. Using this mechanism, we can build inheritance hierarchies, where concepts that are more general will have higher position in the hierarchy than those that are less general. Class which inherits another class is called a subclass of that class and the class, which was inherited by another class, is called a superclass. Single inheritance can be graphically represented as a tree.\nAccording to [3] there are at least three different interpretations of inheritance. We will consider inheritance in the context of modeling of classification hierarchies in the chosen application domain. Such interpretation is more common in OOP and is used in object-oriented knowledge representation.\nProposed approach has some benefits. Usage of inheritance allows more efficient using of computer memory and memory in a database by avoiding duplication of similar information, during description of classes. Almost all modern OOP-languages support single inheritance. However, it also has some drawbacks. When one class inherits another one, it inherits all its properties. There are some cases when it causes some redundancy of description of subclasses, moreover sometimes it causes conflicts among concepts, described by subclass and superclass. All these problems will be considered and discussed in more detail later."}, {"heading": "2.2 Multiple Inheritance", "text": "Under single inheritance, each subclass can have only one superclass, however class can have more than one superclass and there are cases when single inheritance is insufficient. For this purpose there is another form of inheritance, which is called an multiple inheritance [3]. It allows class to inherit specifics of many other classes. Multiple inheritance hierarchy can be graphically represented as an acyclic directed graph, or simply an direct inheritance graph.\nMultiple inheritance has almost the same benefits, as a single one. Moreover, it gives an opportunity to create more complex classes and objects via inheritance. However, multiple inheritance also has some drawbacks. Usage of multiple inheritance sometimes causes two types of semantic conflicts within the subclasses. In the first case, the class can simultaneously inherit a few copies of the same method or different values of the equivalent properties from different superclasses. In the second case, the subclass can inherit semantically incompatible properties and methods. In addition, in contrast to single inheritance, not every OOP-language supports multiple inheritance. Languages, which support multiple inheritance, are C++, Common Lisp, Eiffel, Scala, Perl, Python, etc. However, for example such commonly used OOP-languages as C#, Java, Objective-C, Ruby, Php do not do it. Most of them use an alternative approaches to multiple inheritance such as interfaces, that allow partial modelling of multiple inheritance principles."}, {"heading": "3 Object-Oriented Knowledge Representation", "text": "The main idea of object-oriented knowledge representation approach is representation of knowledge about a domain in terms of objects, classes and relations among them. OOP provides all opportunities for such representation, however in many books where models of knowledge representation are described, OOP is not mentioned. Nevertheless, we consider models, which are ideologically close to OOP, such as frames and object-oriented dynamic networks (OODN). We briefly consider these KRMs and implementation of inheritance mechanism within them."}, {"heading": "3.1 Frames", "text": "Frame is a data-structure for representation of knowledge about stereotypical situations [7]. Frame consists of set of slots, where each slot has its own filler. Name of a frame, relationships with other frames, attributes of frame, procedural attachments can be fillers for frame\u2019s slots. Every slot with its value represents particular property of object or class, which is represented by frame. Generally, there are two types of frames: individual or instance-frames for representation of single objects, and generic or class-frames for representation of classes [9].\nDifferent frames can be merged into one system via relationships [7]. There are three main types of relations among frames: generalization, aggregation and association. Generalization represents relationship between subclass and superclass or object and class, when subclass is a kind of superclass or object is an instance of its class. This type of relationships can be denoted using is-a, an-instance-of, a-kind-of, etc. links. Aggregation represents relationship among several subclasses and their superclass, when subclass is a part of superclass. Usually aggregation can be denoted as a-part-of, part-whole, etc. Association describes some semantic relationship among different classes, which are unrelated otherwise. Examples of such kind relationships are have, can, own, etc.\nUsually, frames can have some methods associated with them. They are called procedural attachments. Every procedure is a set of some instructions, which are associated with a frame and can be executed on request.\nSimilarly to OOP, frames use the inheritance mechanism for building framessystems, which also have hierarchical structure [9]. The conception of inheritance within frames is the same as in OOP. There is difference only between representation of structure of classes and objects within these approaches. OOP is more flexible and powerful for representation of class structure, because in contrast to frames, it has some set of basic built-in primitive data types, which can be used for creating more complex data structures, while frames has only three built-in primitive types: numeric, string and logical. However, frames have such feature as compound attributes which take a value from some set of values, which elements can have different types.\nIn terms of frames, class can inherit specifics of another class through generalization relationship, i.e. is-a slot. However, single and multiple inheritance cause the same problems in frames as in OOP [9], [13].\nAs we can see, problems of inheritance are common for all object-oriented KRMs, but they are related only to the specifics of inheritance mechanism."}, {"heading": "3.2 Problem of Exceptions", "text": "The first known problem of inheritance is the problem of exceptions. There are some classical examples, which illustrate it. They are known as examples about flying penguins or ostriches and about three-legged or white elephant [1], [13]. In general, the problem can be formulated as a situation, when superclass contains properties, which are not true for all its subclasses.\nAfter formulation of this problem, a few approaches to its solving were proposed. For example, in frame-based systems, subclasses can override the values of inherited slots from their superclass [9]. However, this approach is not efficient, because overriding of values of slots leads to the situation when the subclass goes beyond its superclass. After it, this class cannot be viewed as the subclass of its superclass, because all subclasses must inherit all properties of their superclass.\nThe main idea of another known approach is the usage of not-is-a links for modelling of exceptions [1], [13]. Such solution differs from others, because its main idea is not to avoid the exceptions in the hierarchy, but to describe them somehow. The conception of not-is-a link came from logical approach of knowledge representation and on the first glance such solution does not cause any suspicions. However it causes appearing of the contradictory classes, formation of inconsistent knowledge base and as result contradictory reasoning [1].\nIn OOP, solving of this problem relies on the programmer. In other words, the programmer should somehow constrain the generality of the superclass."}, {"heading": "3.3 Problem of Redundancy", "text": "One more kind of problem related to inheritance is the problem of redundancy. It appears within the inheritance tree, when the class inherits specifics from more than one related superclass [1], [13]. In this situation, there is a vertical chain of inheritance, where top level contains most general class and each of lower levels contains less general class, than its superclass. On the bottom level there is the most specific class of the hierarchy. The main features of this class is that it inherits all properties from its predecessors. Sometimes such inheritance is redundant, because the class can inherit unnecessary properties or methods and all objects of this class will have the same specifics.\nThere are some approaches, which avoid the inheritance of redundant properties. One of them is the choosing of the nearest value. However, it is not an efficient way, because the result of such choosing depends on appropriate algorithm. Various systems have different algorithms, which can return different results in the same situation [1], [13]."}, {"heading": "3.4 Problem of Ambiguity", "text": "Another kind of problem related to inheritance is the problem of ambiguity. There are a few classical examples, which illustrate this problem. They are known\nas examples about Quaker or Nixon and about elephant, who is a circus performer, etc. [1], [13]. This problem appears, when the class inherits specifics from more than one unrelated superclass of the same level, and these superclasses contain properties and methods with the same names. In this situation, subclass should somehow choose one of these variants.\nConcerning properties, sometimes they can have only similar name, but not a type or value. Sometimes, they can have the same type and different values or they can have the same type and value. In all these cases there is an ambiguity, because it is unknown, which particular property should be chosen and different variants can have totally different semantic contexts. Methods, similarly to properties can have only the same names and very different semantic contexts. However, even if their semantics are similar or close to similar, they can be implemented in different ways.\nThere are a few approaches for solving this problem [1], [13]. First of them uses the idea of choosing some particular version of property or method. In this case, there is a question how to choose them. There are appropriate algorithms, which are implemented in different systems, in particular in frame-based ones. However, they use different criteria for choosing the variant. Very often result depends on the behavior and time complexity of the algorithm. It means that different algorithms will give different results using the same inheritance structure. Second approach allows inheritance of all possible variations of properties and methods. In this situation results will be different in various systems [1]. However, both solutions are not efficient enough, because in the first case a system ignores some part of variants in different ways and in the second one, knowledge base becomes inconsistent."}, {"heading": "3.5 Object-Oriented Dynamic Networks", "text": "Another kind of object-oriented knowledge representation model is object-oriented dynamic networks, which was proposed in [11]. In some aspects, this KRM is similar to OOP and frames, however, despite this, it has some specific peculiarities, which are not typical for other models. Let us consider structure of this model.\nDefinition 1 Object-Oriented Dynamic Network is a 5-tuple\nOODN = (O,C,R,E,M),\nwhere:\n\u2013 O \u2013 a set of objects;\n\u2013 C \u2013 a set of classes of objects, which describe objects from set O;\n\u2013 R \u2013 a set of relations, which are defined on set O and C;\n\u2013 E \u2013 a set of exploiters, which are defined on set O and C;\n\u2013 M \u2013 a set of modifiers, which are defined on set O and C.\nAnalyzing this definition, we can conclude that usage of conceptions of objects, classes and relation among them is common for both OOP and frames. However, all these concepts have different implementations within mentioned KRMs. One of the main differences is the definition of the class. Within OOP, class is something like abstract description of some quantity of objects of the same nature [3]. According to this, such class is homogeneous, because all its instances have the same type. In this sense, definition of the class within frames is similar to appropriate one in OOP. However, there is another type of classes, which are inhomogeneous or heterogeneous [10]. Conception of a class, which is defined within OODN, takes into account both types of classes. Let us consider it in more details.\nDefinition 2 Class of objects T is a tuple T = (P (T ), F (T )), where P (T ) is specification (a set of properties) of some quantity of objects, and F (T ) is their signature (a set of methods).\nThe next definition proposes some classification of classes.\nDefinition 3 Homogeneous class of objects is a class of objects, which contains only similar objects.\nAccording to this, we can conclude that definition 2 describes homogeneous classes.\nNow let us consider the definition of inhomogeneous class.\nDefinition 4 Inhomogeneous (heterogeneous) class of objects T is a tuple\nT = (Core(T ), pr1(A1), . . . , prn(An)),\nwhere Core(T ) = (P (T ), F (T )) is the core of class of objects T , which includes only properties and methods similar to corresponding properties of specifications P (A1), . . . , P (An) and corresponding methods of signatures F (A1), . . . , F (An) respectively, and where pri(Ai) = (P (Ai), F (Ai)) , i = 1, n are projections of objects A1, . . . , An, which consist of properties and methods typical only for these objects.\nThis approach gives an opportunity to describe some quantity of objects, which have similar or even different nature within one class. While in OOP, we must define new class for each new type of objects, even if these types are close or similar.\nSome of main features of OODN are a set of exploitersE and a set of modifiers M . Both of them contain methods which can be applied to the objects and classes of objects from set O and C respectively. The difference between these two types of methods is character of their action. Exploiters use the objects and classes of objects, as the parameters for obtaining new knowledge, without any their changes, while, modifiers change the essence of objects and classes of objects and allow modelling of changes of basic knowledge over time.\nIn general, OODN can be viewed as two conceptual parts. First of them is declarative, which includes sets O, C, R, and allows representation of knowledge about particular domain. Second part is procedural one, it includes sets E, M and provides the tools for obtaining new knowledge from basic ones."}, {"heading": "4 Object-Oriented Representation of Fuzzy Knowledge", "text": "Currently there is variety of KRMs, which give an opportunity to represent the knowledge in different ways. Main of them were mentioned in the introduction part. However, a lot of human knowledge is vague and imprecise [2], [6] and cannot be represented in efficient way, using existing KRMs. That is why most of them were extended to the case of fuzzy knowledge, through the use of fuzzy sets theory [14]. Currently there are fuzzy logic, fuzzy semantic networks, fuzzy rule-based models, fuzzy neural networks, fuzzy ontologies, fuzzy frames, fuzzy UML, etc. However, classical paradigm of OOP does not provide an opportunity for representing fuzzy objects and classes. That is why, a few attempts to do this were done within object-oriented approach to representation of fuzzy knowledge [2], [6], [8].\nSimilarly to object-oriented knowledge representation, main concepts of objectoriented representation of fuzzy knowledge are fuzzy objects, classes of fuzzy objects and relationships among them. The object and class are fuzzy, when they have at least one fuzzy property, i.e. property that is defined by a fuzzy set. The relations among fuzzy objects and classes of fuzzy objects, which are usually considered are similar to corresponded relations in frames and OOP, i.e. generalization, aggregation and association."}, {"heading": "4.1 Fuzzy Frames", "text": "One of the most interesting extensions of classical KRMs to the case of fuzzy knowledge are fuzzy frames [4], [5]. There are two main differences between frames and fuzzy frames. Firstly, within fuzzy frames slots can contain fuzzy sets as values. Secondly, the inheritance through is-a slot can be partial. Such extension of frames allows describing of objects and classes which have partial properties, i.e. properties which inherent with some measure. It means that such properties are not strictly true or false for the object or class. This kind of inheritance is called weaker inheritance.\nProposed kind of inheritance can solve problem with exceptions in some cases, when the subclass inherits all properties of its superclass, but some of them are inherited with measure less than 1. It means that these properties are less expressed within the subclass than in its ancestor. However, such approach does not solve problems with redundancy and ambiguity, because it allows only the flexible description of inheritance relationships among classes."}, {"heading": "4.2 Fuzzy Object-Oriented Dynamic Networks", "text": "Similarly to OOP and frames, object-oriented-dynamic networks are not efficient for representation of fuzzy objects and classes. That is why concepts of fuzzy object, class of fuzzy objects which are basic for OODN were extended to the case of fuzzy knowledge [12]. Taking into account these extensions, the definition of fuzzy object-oriented dynamic networks can be formulated in the following way.\nDefinition 5 Fuzzy Object-Oriented Dynamic Network is a object-oriented dynamic network\nFOODN = (O,C,R,E,M),\nfor which at least one of the following conditions:\n\u2013 \u2203Ak, . . . , Am \u2208 O = {A1, . . . , An}, where 1 \u2264 k \u2264 m \u2264 n and Ak, . . . , Am are fuzzy objects; \u2013 \u2203Tp, . . . , Tq \u2208 C = {T1, . . . , Tw}, where 1 \u2264 p \u2264 q \u2264 w and Tp, . . . , Tq are classes of fuzzy objects; \u2013 \u2203Ri, . . . , Rj \u2208 R = {R1, . . . , Rv}, where 1 \u2264 i \u2264 j \u2264 v and Ri, . . . , Rj are fuzzy relations among fuzzy objects and classes of fuzzy objects.\nis true.\nThe most important feature of this extension is that general structure of the object and class of objects, types of classes and relations are the same for OODN and FOODN. There only difference is the type of properties, because in FOODN some properties of objects or classes of objects can be fuzzy."}, {"heading": "5 Types of Inheritance", "text": "As we can see from previous sections, there are two types of inheritance \u2013 single and multiple. Such inheritance types classification allows consideration of inheritance process in the context of different types of inheritance source. However, there is another classification, which divides inheritance on strong and weak. It allows consideration of inheritance from another point of view, namely how the inherited properties will be expressed within the subclass.\nNevertheless, there are other classifications. The common feature for single and multiple inheritance is that subclass inherits all properties and methods of inheritance source. We suppose that it is the source of majority of problems. In our opinion, if the class did not inherit all the properties of inheritance source, it would not cause the problems of redundancy and ambiguity. Moreover, such kind of inheritance allows building of inheritance hierarchy in more flexible way, without redundancy and ambiguity. According to this, we can conclude that inheritance can be also classified as full and partial. In the first case subclass inherits all the properties and methods from inheritance source, in the second case it inherits only selected properties and methods. All considered classifications of inheritance can be arranged within one classification, which is represented in the Table 1.\nNow, let us consider the process of inheritance within OODN and FOODN. Suppose we have three classes of object A1, A2 and A3, which are defined as follows\nT (A1) = (P (A1), F (A1)) = (p1(A1), p2(A1), f1(A1), f2(A1)),\nT (A2) = (P (A2), F (A2)) = (p1(A2), p2(A2), f1(A2)),\nT (A3) = (P (A3), F (A3)) = (p1(A3), f1(A3)).\nLet us consider types of inheritance, which are shown in Table 1, within OODN and FOODN. According to Table 1, there are eight different types of inheritance, but all of them can be reduced to two main kinds \u2013 single and multiple. That is why, let us consider these two types as the most general ones."}, {"heading": "5.1 Single Inheritance", "text": "Suppose we have the following sequence of inheritance\nA3 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A2 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A1.\nThe result of such inheritance is\nA3 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A2 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A1 = T = (Core(T ), pr1(T ), pr1(pr1(T ))),\nwhere\nCore(T ) = (p1(A1), p2(A1), f1(A1), f2(A1)),\npr1(T ) = (p1(A2), p2(A2), f1(A2)),\npr1(pr1(T )) = (p1(A3), f1(A3)).\nThe structures of classes A1, A2 and A3 in the heterogeneous class T can be expressed as follows:\nA1 = Core(T ),\nA2 = Core(T ) \u222a pr1(T ),\nA3 = Core(T ) \u222a pr1(T ) \u222a pr1(pr1(T ))."}, {"heading": "5.2 Multiple Inheritance", "text": "Suppose we have the following sequence of inheritance\nA3 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A1 and A3 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A2.\nThe result of such inheritance process is\nA3 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A1 and A3 inherits \u2212\u2212\u2212\u2212\u2212\u2192 A2 = T =\n= (pr1(T ), pr2(T ), pr1(pr1(T ), pr2(T ))),\nwhere\npr1(T ) = (p1(A1), p2(A1), f1(A1), f2(A1)),\npr2(T ) = (p1(A2), p2(A2), f1(A2)),\npr1(pr1(T ), pr2(T )) = (p1(A3), f1(A3)).\nThe structures of classes A1, A2 and A3 in the heterogeneous class T can be expressed as follows:\nA1 = pr1(T ),\nA2 = pr2(T ),\nA3 = pr1(pr1(T ), pr2(T ))."}, {"heading": "5.3 Special Cases", "text": "Let us consider example of partial and weak inheritance, using previously described classes A1, A2 and A3 for it. Suppose we have the situation, when the class A2 partially inherits the class A1, for example property p1(A1) and method f1(A1).\nA2 inherits (p1,f1) \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 A1 = T = (Core(T ), pr1(T ), pr2(T )),\nwhere\nCore(T ) = (p1(A1), f1(A1)),\npr1(T ) = (p2(A1), f2(A1)),\npr2(T ) = (p1(A2), p2(A2), f1(A2)).\nThe structures of classesA1 andA2 in the heterogeneous class T can be expressed as follows:\nA1 = Core(T ) \u222a pr1(T ),\nA2 = Core(T ) \u222a pr2(T ).\nSuppose we have the situation, when the class A2 weakly inherits the class A1, for example property p1(A1) with measure 0.5.\nA2 inherits (p1/0.5) \u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2192 A1 = T = (Core(T ), pr1(T ), pr2(T )),\nwhere\nCore(T ) = (p2(A1), f1(A1), f2(A1)),\npr1(T ) = (p1(A1)/1),\npr2(T ) = (p1(A1)/0.5, p1(A2), p2(A2), f1(A2)).\nThe structures of classesA1 andA2 in the heterogeneous class T can be expressed as follows:\nA1 = Core(T ) \u222a pr1(T ),\nA2 = Core(T ) \u222a pr2(T )."}, {"heading": "6 Conclusions", "text": "This paper contains analysis of inheritance process and its specifics in the context of knowledge representation within OOP, frames and OODN. Such kinds of inheritance problems as problems of exceptions, redundancy, ambiguity and some approaches for their solving were considered in different perspectives. In addition, the various kinds of inheritance classifications were considered.\nNew types of inheritance, which allow building of inheritance hierarchy in more flexible and efficient way, were proposed. Furthermore, general classification of all known inheritance types, which includes eight different types of inheritance, was introduced. The application of approach, which allows avoiding in many cases problems with exceptions, redundancy and ambiguity within OODN and FOODN was shown, using examples.\nProposed approach for organizing of inheritance hierarchies suggests new concepts, which can extend the OOP in many useful directions. However, despite all its benefits, it requires further research."}, {"heading": "1. Al-Asady, R.: Inheritance Theory: An Artificial Intelligence Approach. Ablex Publishing Corporation, Norwood, New Jersey (1995)", "text": ""}, {"heading": "2. Berzal, F., Marin, N., Pons, O., Vila, M.A.: Managing Fuzziness on Conventional Object-Oriented Platforms. International Journal of Intelligent Systems. 22, 781\u2013", "text": "803 (2007) 3. Craig, I.D.: Object-Oriented Programming Languages: Interpretation. Springer, London (2007) 4. Graham, I., Jones, P.L.: A Theory of Fuzzy Frames: Part-1. Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 109\u2013132 (1987) 5. Graham, I., Jones, P.L.: A Theory of Fuzzy Frames: Part-2. Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 120\u2013135 (1987) 6. Leung, K.S., Wong, M.H.: Fuzzy Concepts in an Object Oriented Expert System Shell. International Journal of Intelligent Systems. 7, 171\u2013192 (1992) 7. Minsky, M.: A Framework for Representing Knowledge. Technical Report No. 306, AI Laboratory, Massachusetts Institute of Technology (1974) 8. Ndousse, T.D.: Intelligent Systems Modeling with Reusable Fuzzy Objects. International Journal of Intelligent Systems. 12, 137\u2013152 (1997) 9. Negnevitsky, M.: Artificial Intelligence: A Guide to Intelligent Systems: Second Edition. Addison-Wesley, Herlow, Essex (2004) 10. Terletskyi, D.A., Provotar, O.I.: Mathematical Foundations for Designing and Development of Intelligent Systems of Information Analysis. Scientific Journal \u201cProblems in Programming\u201d. 15, 233\u2013241 (2014) 11. Terletskyi, D.O., Provotar, O.I.: Object-Oriented Dynamic Networks. In: Setlak, G., Markov, K. (eds.) Computational Models for Business and Engineering Domains. IBS ISC, vol. 30, pp. 123\u2013136. ITHEA (2014) 12. Terletskyi, D.A., Provotar, A.I.: Fuzzy Object-Oriented Dynamic Networks. I. International Scientific Journal \u201cCybernetics and System Analysis\u201d. 51, 34\u201340 (2015) 13. Touretzky, D.S.: The Mathematics of Inheritance Systems. Morgan Kaufmann Publishers, Los Altos, California (1986) 14. Zadeh, L.A.: Fuzzy Sets. Information and control. 8, 338\u2013353 (1965)"}], "references": [{"title": "Inheritance Theory: An Artificial Intelligence Approach", "author": ["R. Al-Asady"], "venue": "Ablex Publishing Corporation, Norwood, New Jersey", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1995}, {"title": "Managing Fuzziness on Conventional Object-Oriented Platforms", "author": ["F. Berzal", "N. Marin", "O. Pons", "M.A. Vila"], "venue": "International Journal of Intelligent Systems. 22, 781\u2013 803", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "Object-Oriented Programming Languages: Interpretation", "author": ["I.D. Craig"], "venue": "Springer, London", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2007}, {"title": "A Theory of Fuzzy Frames: Part-1", "author": ["I. Graham", "P.L. Jones"], "venue": "Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 109\u2013132", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1987}, {"title": "A Theory of Fuzzy Frames: Part-2", "author": ["I. Graham", "P.L. Jones"], "venue": "Bulletin for Studies and Exchanges on Fuzziness and its Applications. 32, 120\u2013135", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1987}, {"title": "Fuzzy Concepts in an Object Oriented Expert System Shell", "author": ["K.S. Leung", "M.H. Wong"], "venue": "International Journal of Intelligent Systems. 7, 171\u2013192", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1992}, {"title": "A Framework for Representing Knowledge", "author": ["M. Minsky"], "venue": "Technical Report No. 306, AI Laboratory, Massachusetts Institute of Technology", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1974}, {"title": "Intelligent Systems Modeling with Reusable Fuzzy Objects", "author": ["T.D. Ndousse"], "venue": "International Journal of Intelligent Systems. 12, 137\u2013152", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1997}, {"title": "Artificial Intelligence: A Guide to Intelligent Systems: Second Edition", "author": ["M. Negnevitsky"], "venue": "Addison-Wesley, Herlow, Essex", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2004}, {"title": "Mathematical Foundations for Designing and Development of Intelligent Systems of Information Analysis", "author": ["D.A. Terletskyi", "O.I. Provotar"], "venue": "Scientific Journal \u201cProblems in Programming\u201d. 15, 233\u2013241", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2014}, {"title": "Object-Oriented Dynamic Networks", "author": ["D.O. Terletskyi", "O.I. Provotar"], "venue": "Setlak, G., Markov, K. (eds.) Computational Models for Business and Engineering Domains. IBS ISC, vol. 30, pp. 123\u2013136. ITHEA", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2014}, {"title": "Fuzzy Object-Oriented Dynamic Networks", "author": ["D.A. Terletskyi", "A.I. Provotar"], "venue": "I. International Scientific Journal \u201cCybernetics and System Analysis\u201d. 51, 34\u201340", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2015}, {"title": "The Mathematics of Inheritance Systems", "author": ["D.S. Touretzky"], "venue": "Morgan Kaufmann Publishers, Los Altos, California", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1986}, {"title": "Fuzzy Sets", "author": ["L.A. Zadeh"], "venue": "Information and control. 8, 338\u2013353", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1965}], "referenceMentions": [{"referenceID": 0, "context": "Firstly, inheritance mechanism leads three main kinds of problems, such as problem of exceptions, problem of redundancy and problem of ambiguity [1], [13].", "startOffset": 145, "endOffset": 148}, {"referenceID": 12, "context": "Firstly, inheritance mechanism leads three main kinds of problems, such as problem of exceptions, problem of redundancy and problem of ambiguity [1], [13].", "startOffset": 150, "endOffset": 154}, {"referenceID": 1, "context": "Secondly, a lot of human knowledge have vague and imprecise nature [2], [6] and OOP does not support representation of such knowledge.", "startOffset": 67, "endOffset": 70}, {"referenceID": 5, "context": "Secondly, a lot of human knowledge have vague and imprecise nature [2], [6] and OOP does not support representation of such knowledge.", "startOffset": 72, "endOffset": 75}, {"referenceID": 9, "context": "Thirdly, OOP provides an opportunity to create and to operate only with homogeneous classes [10], that is why we need to create new class for every new type of objects, even when some of them are similar.", "startOffset": 92, "endOffset": 96}, {"referenceID": 2, "context": "Nowadays there are two main approaches in modern OOP, which are implemented within class-based and prototype-based programming languages [3].", "startOffset": 137, "endOffset": 140}, {"referenceID": 2, "context": "This process is called single inheritance [3].", "startOffset": 42, "endOffset": 45}, {"referenceID": 2, "context": "According to [3] there are at least three different interpretations of inheritance.", "startOffset": 13, "endOffset": 16}, {"referenceID": 2, "context": "For this purpose there is another form of inheritance, which is called an multiple inheritance [3].", "startOffset": 95, "endOffset": 98}, {"referenceID": 6, "context": "Frame is a data-structure for representation of knowledge about stereotypical situations [7].", "startOffset": 89, "endOffset": 92}, {"referenceID": 8, "context": "Generally, there are two types of frames: individual or instance-frames for representation of single objects, and generic or class-frames for representation of classes [9].", "startOffset": 168, "endOffset": 171}, {"referenceID": 6, "context": "Different frames can be merged into one system via relationships [7].", "startOffset": 65, "endOffset": 68}, {"referenceID": 8, "context": "Similarly to OOP, frames use the inheritance mechanism for building framessystems, which also have hierarchical structure [9].", "startOffset": 122, "endOffset": 125}, {"referenceID": 8, "context": "However, single and multiple inheritance cause the same problems in frames as in OOP [9], [13].", "startOffset": 85, "endOffset": 88}, {"referenceID": 12, "context": "However, single and multiple inheritance cause the same problems in frames as in OOP [9], [13].", "startOffset": 90, "endOffset": 94}, {"referenceID": 0, "context": "They are known as examples about flying penguins or ostriches and about three-legged or white elephant [1], [13].", "startOffset": 103, "endOffset": 106}, {"referenceID": 12, "context": "They are known as examples about flying penguins or ostriches and about three-legged or white elephant [1], [13].", "startOffset": 108, "endOffset": 112}, {"referenceID": 8, "context": "For example, in frame-based systems, subclasses can override the values of inherited slots from their superclass [9].", "startOffset": 113, "endOffset": 116}, {"referenceID": 0, "context": "The main idea of another known approach is the usage of not-is-a links for modelling of exceptions [1], [13].", "startOffset": 99, "endOffset": 102}, {"referenceID": 12, "context": "The main idea of another known approach is the usage of not-is-a links for modelling of exceptions [1], [13].", "startOffset": 104, "endOffset": 108}, {"referenceID": 0, "context": "However it causes appearing of the contradictory classes, formation of inconsistent knowledge base and as result contradictory reasoning [1].", "startOffset": 137, "endOffset": 140}, {"referenceID": 0, "context": "It appears within the inheritance tree, when the class inherits specifics from more than one related superclass [1], [13].", "startOffset": 112, "endOffset": 115}, {"referenceID": 12, "context": "It appears within the inheritance tree, when the class inherits specifics from more than one related superclass [1], [13].", "startOffset": 117, "endOffset": 121}, {"referenceID": 0, "context": "Various systems have different algorithms, which can return different results in the same situation [1], [13].", "startOffset": 100, "endOffset": 103}, {"referenceID": 12, "context": "Various systems have different algorithms, which can return different results in the same situation [1], [13].", "startOffset": 105, "endOffset": 109}, {"referenceID": 0, "context": "[1], [13].", "startOffset": 0, "endOffset": 3}, {"referenceID": 12, "context": "[1], [13].", "startOffset": 5, "endOffset": 9}, {"referenceID": 0, "context": "There are a few approaches for solving this problem [1], [13].", "startOffset": 52, "endOffset": 55}, {"referenceID": 12, "context": "There are a few approaches for solving this problem [1], [13].", "startOffset": 57, "endOffset": 61}, {"referenceID": 0, "context": "In this situation results will be different in various systems [1].", "startOffset": 63, "endOffset": 66}, {"referenceID": 10, "context": "Another kind of object-oriented knowledge representation model is object-oriented dynamic networks, which was proposed in [11].", "startOffset": 122, "endOffset": 126}, {"referenceID": 2, "context": "Within OOP, class is something like abstract description of some quantity of objects of the same nature [3].", "startOffset": 104, "endOffset": 107}, {"referenceID": 9, "context": "However, there is another type of classes, which are inhomogeneous or heterogeneous [10].", "startOffset": 84, "endOffset": 88}, {"referenceID": 1, "context": "However, a lot of human knowledge is vague and imprecise [2], [6] and cannot be represented in efficient way, using existing KRMs.", "startOffset": 57, "endOffset": 60}, {"referenceID": 5, "context": "However, a lot of human knowledge is vague and imprecise [2], [6] and cannot be represented in efficient way, using existing KRMs.", "startOffset": 62, "endOffset": 65}, {"referenceID": 13, "context": "That is why most of them were extended to the case of fuzzy knowledge, through the use of fuzzy sets theory [14].", "startOffset": 108, "endOffset": 112}, {"referenceID": 1, "context": "That is why, a few attempts to do this were done within object-oriented approach to representation of fuzzy knowledge [2], [6], [8].", "startOffset": 118, "endOffset": 121}, {"referenceID": 5, "context": "That is why, a few attempts to do this were done within object-oriented approach to representation of fuzzy knowledge [2], [6], [8].", "startOffset": 123, "endOffset": 126}, {"referenceID": 7, "context": "That is why, a few attempts to do this were done within object-oriented approach to representation of fuzzy knowledge [2], [6], [8].", "startOffset": 128, "endOffset": 131}, {"referenceID": 3, "context": "One of the most interesting extensions of classical KRMs to the case of fuzzy knowledge are fuzzy frames [4], [5].", "startOffset": 105, "endOffset": 108}, {"referenceID": 4, "context": "One of the most interesting extensions of classical KRMs to the case of fuzzy knowledge are fuzzy frames [4], [5].", "startOffset": 110, "endOffset": 113}, {"referenceID": 11, "context": "That is why concepts of fuzzy object, class of fuzzy objects which are basic for OODN were extended to the case of fuzzy knowledge [12].", "startOffset": 131, "endOffset": 135}], "year": 2015, "abstractText": "This paper contains the consideration of inheritance mechanism in such knowledge representation models as object-oriented programming, frames and object-oriented dynamic networks. In addition, inheritance within representation of vague and imprecise knowledge are also discussed. New types of inheritance, general classification of all known inheritance types and approach, which allows avoiding in many cases problems with exceptions, redundancy and ambiguity within objectoriented dynamic networks and their fuzzy extension, are introduced in the paper. The proposed approach bases on conception of homogeneous and inhomogeneous or heterogeneous class of objects, which allow building of inheritance hierarchy more flexibly and efficiently.", "creator": "LaTeX with hyperref package"}}}