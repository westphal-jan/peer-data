{"id": "1602.04498", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Feb-2016", "title": "Extending Consequence-Based Reasoning to SRIQ", "abstract": "consequence - computing calculi are quasi family dynamic autonomous circuits employing artificial logics ( dls ), and they modify hypertableau logical knowledge in a way... vastly achieves excellent performance from comprehension. initial to 1905, perhaps, they were proposed for either horn domain ( which otherwise mostly allow convergence ), optional for dls robust counting judgments. in this paper we developed. novel paradigm - based query for np - - - a rich dl that gives structural features. this extension became non - adaptive since the intermediate values that often quickly be observed whenever comprehension cannot being captured using dls approaches. the results of our preliminary performance evaluation suggest the feasibility of our approach in practice.", "histories": [["v1", "Sun, 14 Feb 2016 19:56:18 GMT  (102kb,D)", "https://arxiv.org/abs/1602.04498v1", null], ["v2", "Mon, 22 Feb 2016 16:04:55 GMT  (103kb,D)", "http://arxiv.org/abs/1602.04498v2", null], ["v3", "Tue, 23 Feb 2016 21:17:27 GMT  (103kb,D)", "http://arxiv.org/abs/1602.04498v3", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["andrew bate", "boris motik", "bernardo cuenca grau", "franti\\v{s}ek siman\\v{c}\\'ik", "ian horrocks"], "accepted": false, "id": "1602.04498"}, "pdf": {"name": "1602.04498.pdf", "metadata": {"source": "META", "title": "Extending Consequence-Based Reasoning to SRIQ", "authors": ["Andrew Bate", "Boris Motik", "Bernardo Cuenca Grau", "Franti\u0161ek Siman\u010d\u0131\u0301k", "Ian Horrocks"], "emails": ["firstname.lastname@cs.ox.ac.uk"], "sections": [{"heading": null, "text": "1 Introduction Description logics (DLs) (Baader et al. 2003) are a family of knowledge representation formalisms with numerous applications in practice. DL-based applications model a domain of interest by means of an ontology, in which key notions in the domain are described using concepts (i.e., unary predicates), and the relationships between concepts are described using roles (i.e., binary predicates). Subsumption is the problem of determining whether each instance of a concept C is also an instance of a conceptD in all models of an ontology, and it is a fundamental reasoning problem in applications of DLs. For expressive DLs, this problem is of high worst-case complexity, ranging from EXPTIME up to N2EXPTIME.\nDespite these discouraging complexity bounds, highly optimised reasoners such as FaCT++ (Tsarkov and Horrocks 2006), Pellet (Sirin et al. 2007), HermiT (Glimm et al. 2014), and Konclude (Steigmiller, Liebig, and Glimm 2014) have proved successful in practice. These systems are typically based on (hyper)tableau calculi, which construct a finite representation of a canonical model of the ontology disproving a postulated subsumption. While such calculi can handle many ontologies, in some cases they construct very large model representations, which is a source of performance problems; this is further exacerbated by the large number of subsumption tests often required to classify an ontology.\nA recent breakthrough in DL reasoning came in the form of consequence-based calculi. The reasoning algorithm by Baader, Brandt, and Lutz (2005) for the lightweight logic EL can be seen as the first such calculus. It was later extended to the more expressive DLs Horn-SHIQ (Kazakov 2009) and\nHorn-SROIQ (Ortiz, Rudolph, and Simkus 2010)\u2014DLs that support counting quantifiers, but not disjunctions between concepts. Consequence-based calculi were also developed for ALCH (Simanc\u030c\u0131\u0301k, Kazakov, and Horrocks 2011) and ALCI (Simanc\u030c\u0131\u0301k, Motik, and Horrocks 2014), which support concept disjunction, but not counting quantifiers. Such calculi can be seen as combining resolution and hypertableau (see Section 3 for details): as in resolution, they describe ontology models by systematically deriving relevant consequences; and as in (hyper)tableau, they are goaldirected and avoid drawing unnecessary consequences. Additionally, they are not only refutationally complete, but can also (dis)prove all relevant subsumptions in a single run, which can greatly reduce the overall computational work. Finally, unlike implemented (hyper)tableau reasoners, they are worst-case optimal for the logic they support. Steigmiller, Glimm, and Liebig (2014) presented a way of combining a consequence-based calculus with a traditional tableau-based prover; while such a combination seems to perform well in practice, the saturation rules are only known to be complete for EL ontologies, and the overall approach is not worst-case optimal for SRIQ.\nExisting consequence-based algorithms cannot handle DLs such as ALCHIQ that provide both disjunctions and counting quantifiers. As we argue in Section 3, extending these algorithms to handle such DLs is challenging: counting quantifiers require equality reasoning which, together with disjunctions, can impose complex constraints on ontology models; and, unlike existing consequence-based calculi, such constraints cannot be captured using DLs themselves, which makes the reasoning process much more involved.\nIn Section 4 we present a consequence-based calculus for ALCHIQ; by using the encoding of role chains by Kazakov (2008), our calculus can also handle SRIQ, which covers all of OWL 2 DL except for nominals, reflexive roles, and datatypes. Borrowing ideas from resolution theorem proving, we encode the calculus\u2019 consequences as first-order clauses of a specific form, and we handle equality using a variant of ordered paramodulation (Nieuwenhuis and Rubio 1995)\u2014a state of the art calculus for equational theorem proving used in modern theorem provers such as E (Schulz 2002) and Vampire (Riazanov and Voronkov 2002). Furthermore, we have carefully constrained the inference rules so that our calculus mimics existing calculi on ELH ontolo-\nar X\niv :1\n60 2.\n04 49\n8v 3\n[ cs\n.A I]\n2 3\nFe b\n20 16\ngies, which ensures robust performance of our calculus on \u2018mostly-ELH\u2019 ontologies.\nWe have implemented a prototype system and compared its performance with that of well-established reasoners. Our results in Section 5 suggest that our system can significantly outperform FaCT++, Pellet, or HermiT, and often exhibits comparable performance to that of Konclude.\n2 Preliminaries First-Order Logic. It is usual in equational theorem proving to encode atomic formulas as terms, and to use a multisorted signature that prevents us from considering malformed terms. Thus, we partition the signature into a set P of predicate symbols and a set F of function symbols; moreover, we assume that P has a special constant \u2118. A term is constructed as usual using variables and the signature symbols, with the restriction that predicate symbols are allowed to occur only at the outermost level; the latter terms are calledP-terms, while all other terms areF-terms. For example, for P a predicate and f a function symbol, f(P (x)) and P (P (x)) are both malformed; P (f(x)) is a well-formed Pterm; and f(x) and x are both well-formed F-terms. Term f(t) is an f -successor of t, and t is an f -predecessor of f(t).\nAn equality is a formula of the form s \u2248 t, where s and t are either both F- or both P-terms. An equality of the form P (~s) \u2248 \u2118 is called an atom and is written as just P (~s) whenever it is clear from the context that the expression denotes a formula, and not a P-term. An inequality is a negation of an equality and is written as s 6\u2248 t. We assume that\u2248 and 6\u2248 are implicitly symmetric\u2014that is, s ./ t and t ./ s are identical, for ./ \u2208 {\u2248, 6\u2248}. A literal is an equality or an inequality. A clause is a formula of the form \u2200~x.[\u0393\u2192 \u2206] where \u0393 is a conjunction of atoms called the body, \u2206 is a disjunction of literals called the head, and ~x contains all variables occurring in the clause; quantifier \u2200~x is usually omitted as it is understood implicitly. We often treat conjunctions and disjunctions as sets (i.e., they are unordered and without repetition) and use them in standard set operations; and we write the empty conjunction (disjunction) as > (\u22a5). For \u03b1 a term, literal, clause, or a set thereof, we say that \u03b1 is ground if it does not contain a variable; \u03b1\u03c3 is the result of applying a substitution \u03c3 to \u03b1; and we often write substitutions as \u03c3 = {x 7\u2192 t1, y 7\u2192 t2, . . .}. We use the standard notion of subterm positions; s|p is the subterm of s at position p; position p is proper in a term t if t|p 6= t; and s[t]p is the term obtained by replacing the subterm of s at position p with t.\nA Herbrand equality interpretation is a set of ground equalities satisfying the usual congruence properties. Satisfaction of a ground conjunction, a ground disjunction, or a (not necessarily ground) clause \u03b1 in an interpretation I , written I |= \u03b1, as well as entailment of a clause \u0393\u2192 \u2206 from a set of clauses O, written O |= \u0393\u2192 \u2206, are defined as usual. Note that a ground disjunction of literals \u2206 may contain inequalities so I |= \u2206 does not necessarily imply I \u2229\u2206 6= \u2205.\nUnless otherwise stated, (possibly indexed) letters x, y, and z denote variables; l, r, s, and t denote terms;A denotes an atom or a P-term (depending on the context); L denotes a literal; f and g denote function symbols; B denotes a unary predicate symbol; and S denotes a binary predicate symbol.\nOrders. A strict order on a universe U is an irreflexive, asymmetric, and transitive relation on U ; and is the non-strict order induced by . Order is total if, for all a, b \u2208 U , we have a b, b a, or a = b. Given \u25e6 \u2208 { , }, element b \u2208 U , and subset S \u2286 U , the notation S \u25e6 b abbreviates \u2203a \u2208 S : a \u25e6 b. The multiset extension mul of compares multisets M and N on U such that M mul N if and only if M 6= N and, for each n \u2208 N \\M , some m \u2208M \\N exists such that m n, where \\ is the multiset difference operator.\nA term order is a strict order on the set of all terms. We extend to literals by identifying each s 6\u2248 t with the multiset {s, s, t, t} and each s \u2248 t with the multiset {s, t}, and by comparing the result using the multiset extension of . We reuse the symbol for the induced literal order since the intended meaning should be clear from the context.\nDL-Clauses. Our calculus takes as input a set O of DLclauses\u2014that is, clauses restricted to the following form. Let P1 and P2 be countable sets of unary and binary predicate symbols, and letF be a countable set of unary function symbols. DL-clauses are written using the central variable x and variables zi. A DL-F-term has the form x, zi, or f(x) with f \u2208 F ; a DL-P-term has the form B(zi), B(x), B(f(x)), S(x, zi), S(zi, x), S(x, f(x)), S(f(x), x) with B \u2208 P1 and S \u2208 P2; and a DL-term is a DL-F-term or a DL-P-term. A DL-atom has the form A \u2248 \u2118 with A a DL-P-term. A DL-literal is a DL-atom, or it is of the form f(x) ./ g(x), f(x) ./ zi, or zi ./ zj with ./ \u2208 {\u2248, 6\u2248}. A DL-clause contains only DL-atoms of the form B(x), S(x, zi), and S(zi, x) in the body and only DL-literals in the head, and each variable zi occurring in the head also occurs in the body. An ontology O is a finite set of DL-clauses. A query clause is a DL-clause in which all literals are of the form B(x). Given an ontology O and a query clause \u0393\u2192 \u2206, our calculus decides whether O |= \u0393\u2192 \u2206 holds. SRIQ ontologies written using the DL-style syntax can be transformed into DL-clauses without affecting query clause entailment. First, we normalise DL axioms to the form shown on the left-hand side of Table 1: we transform away role chains and then replace all complex concepts with fresh atomic ones; this process is well understood (Kazakov 2009; 2008; Simanc\u030c\u0131\u0301k, Motik, and Horrocks 2014), so we omit the details. Second, using the well-known correspondence between DLs and first-order logic (Baader et al. 2003), we translate normalised axioms to DL-clauses as shown on the right-hand side of Table 1. The standard translation of B1 v 6nS.B2 requires atoms B2(zi) in clause bodies, which are not allowed in our setting. We address this issue by introducing a fresh role SB2 that we axiomatise as S(y, x) \u2227B2(x)\u2192 SB2(y, x); this, in turn, allows us to clausify the original axiom as if it were B1 v 6nSB2 . For an ELH ontology, O contains DL-clauses of type DL1 with m = n+ 1, DL2 with n = 1, DL3, and DL5.\n3 Motivation As motivation for our work, in Section 3.1 we discuss the drawbacks of existing DL reasoning calculi, and then in Section 3.2 we discuss how existing consequence-based calculi\nTable 1: Translating Normalised ALCHIQ Ontologies into DL-Clauses\nDL1\nd 1\u2264i\u2264n\nBi v\n\u2294\nn+1\u2264i\u2264m Bi\n\u2227\n1\u2264i\u2264n Bi(x)\u2192\n\u2228\nn+1\u2264i\u2264m Bi(x)\nDL2 B1 v >nS.B2 B1(x)\u2192 S(x, fi(x)) for 1 \u2264 i \u2264 n B1(x)\u2192 B2(fi(x)) for 1 \u2264 i \u2264 n B1(x)\u2192 fi(x) 6\u2248 fj(x) for 1 \u2264 i < j \u2264 n\nDL3 \u2203S.B1 v B2 S(z1, x) \u2227B1(x)\u2192 B2(z1)\nDL4 B1 v 6nS.B2 S(z1, x) \u2227B2(x)\u2192 SB2(z1, x) for fresh SB2 B1(x) \u2227 \u2227\n1\u2264i\u2264n+1 SB2(x, zi)\u2192 \u2228 1\u2264i<j\u2264n+1 zi \u2248 zj\nDL5 S1 v S2 S1(z1, x)\u2192 S2(z1, x)\naddress these problems by separating clauses into contexts in a way that considerably reduces the number of inferences. Next, in Section 3.3 we discuss the main contribution of this paper, which lies in extending the consequence-based framework to a DL with disjunctions and number restrictions. Handling the latter requires equality reasoning, which requires a more involved calculus and completeness proof."}, {"heading": "3.1 Why Consequence-Based Calculi?", "text": "Consider the EL ontology O1 in Figure 1; one can readily check thatO |= Bi(x)\u2192 Ci(x) holds for 0 \u2264 i \u2264 n. To proveO |= B0(x)\u2192 C0(x) using the (hyper)tableau calculus, we start with B0(a) and apply (1)\u2013(4) in a forwardchaining manner. Since O contains (1) for j \u2208 {1, 2}, this constructs a tree-shaped model of depth n and a fanout of two, where nodes at depth i are labelled by Bi and Ci. Forward chaining ensures that reasoning is goal-oriented; however, all nodes labelled with Bi are of the same type and they share the same properties, which reveals a weakness of (hyper)tableau calculi: the constructed models can be large (exponential in our example) and highly redundant; apart from causing problems in practice, this often prevents (hyper)tableau calculi from being worst-case optimal. Techniques such as caching (Gore\u0301 and Nguyen 2007) or any-\nwhere blocking (Motik, Shearer, and Horrocks 2009) can constrain model construction, but their effectiveness often depends on the order of rule applications. Thus, model size is a key limiting factor for (hyper)tableau-based reasoners (Motik, Shearer, and Horrocks 2009).\nIn contrast, resolution describes models using (universally quantified) clauses that \u2018summarise\u2019 the model. This eliminates redundancy and ensures worst-case optimality of many resolution decision procedures. Many resolution variants have been proposed (Bachmair and Ganzinger 2001), each restricting inferences in a specific way. However, to ensure termination, all decision procedure for DLs we are aware of perform inferences with the \u2018deepest\u2019 and the \u2018covering\u2019 clause atoms, so all of them will resolve all (1) with all (4) to obtain all 2n2 clauses of the form\nBi(x) \u2227 Ck+1(fi+1,j(x))\u2192 Ck(x) for 1 \u2264 i, k < n and 1 \u2264 j \u2264 2. (21)\nOf these 2n2 clauses, only those with i = k are relevant to proving our goal. If we extendO with additional clauses that contain Bi and Ci, each of these 2n2 clauses can participate in further inferences and give rise to more irrelevant clauses. This problem is particularly pronounced when O is satisfiable since we must then produce all consequences of O."}, {"heading": "3.2 Basic Notions", "text": "Consequence-based calculi combine \u2018summarisation\u2019 of resolution with goal-directed search of (hyper)tableau calculi. Simanc\u030c\u0131\u0301k, Motik, and Horrocks (2014) presented a framework for ALCI capturing the key elements of the related calculi by Baader, Brandt, and Lutz (2005), Kazakov (2009), Ortiz, Rudolph, and Simkus (2010), and Simanc\u030c\u0131\u0301k, Kazakov, and Horrocks (2011). Before extending this framework to ALCHIQ in Section 4, we next informally recapitulate the basic notions; however, to make this paper easier to follow, we use the same notation and terminology as in Section 4.\nOur consequence-based calculus constructs a directed graph D = \u3008V, E ,S, core, \u3009 called a context structure. The vertices in V are called contexts. Let I be a Herbrand model ofO; hence, the domain of I contains ground terms. Instead of representing each ground term of I separately as in (hyper)tableau calculi, D can represent the properties of several terms by a single context v. Each context v \u2208 V is associated with a (possibly empty) conjunction corev of core atoms that must hold for all ground terms that v represents; thus, corev determines the \u2018kind\u2019 of context v. Moreover, v is associated with a set Sv of clauses that capture the constraints that these terms must satisfy. Partitioning clauses into sets allows us to restrict the inferences between clause sets and thus eliminate certain irrelevant inferences. Clauses in Sv are \u2018relative\u2019 to corev: for each \u0393\u2192 \u2206 \u2208 Sv , we have O |= corev \u2227 \u0393\u2192 \u2206\u2014that is, we do not include corev in clause bodies since corev holds implicitly. Function provides each context v \u2208 V with a concept order v that restricts resolution inferences in the presence of disjunctions.\nContexts are connected by directed edges labelled with function symbols. If u is connected to v via an f -labelled edge, then the f -successor of each ground term represented by u is represented by v. Conversely, if u and v are not connected by an f -edge, then each ground term represented by v is not an f -successor of a ground term represented by u, so no inference between Su and Sv is ever needed.\nConsequence-based calculi are not just complete for refutation: they derive the required consequences. Figure 1 demonstrates this forO1 |= B0(x)\u2192 C0(x). The cores and the clauses shown above and below, respectively, each context, and clause numbers correspond to the derivation order. To prove B0(x)\u2192 C0(x), we introduce context vB0(x) with core B0(x) and add clause (5) to it. The latter says that B0 holds for a, and it is analogous to initialising a (hyper)tableau calculus with B0(a). The calculus then applies rules from Table 2 to derive new clauses and/or extend D. Hyper is the standard hyperresolution rule restricted to a single context at a time. Thus, we derive (6) from (1) and (5), and (7) from (2) and (5). Hyperresolution resolves all body atoms, which makes the resolvent relevant for the context and prevents the derivation of irrelevant clauses such as (21).\nContext vB0(x) contains atoms with function symbols f1,1 and f1,2, so the Succ rule must ensure that the f1,1- and f1,2-successors of the ground terms represented by vB0(x) are adequately represented in D. We can control context introduction via a parameter called an expansion strategy\u2014a function that determines whether to reuse an existing con-\ntext or introduce a fresh one; in the latter case, it also determines how to initialise the context\u2019s core. We discuss possible strategies in Section 4.1; in the rest of this example, we use the so-called cautious strategy, where the Succ rule introduces context vB1(x) and initialises it with (10) and (11). Note that (6) represents two clauses, both of which we satisfy (in separate applications of the Succ rule) using vB1(x).\nWe construct contexts vB2(x), . . . , vBn(x) analogously, we derive (16) by hyperresolving (3) and (14), and we derive (17) by hyperresolving (4), (14), and (16). Clause (17) imposes a constraint on the predecessor context, which we propagate using the Pred rule, deriving (19) and (20). Since clauses of vB0(x) are \u2018relative\u2019 to the core of vB0(x), clause (20) represents our query clause, as required.\n3.3 Extending the Framework to ALCHIQ In all consequence-based calculi presented thus far, the constraints that the ground terms represented by a context v must satisfy can be represented using standard DL-style axioms. For example, for ALCI, Simanc\u030c\u0131\u0301k, Motik, and Horrocks (2014) represented all relevant consequences using DL axioms of the following form:\nl Bi v \u2294 Bj t \u2294 \u2203Sk.Bk t \u2294 \u2200S`.B` (55)\nALCHIQ provides both counting quantifiers and disjunctions, the interplay of which may impose constraints that cannot be represented in ALCHIQ. Let O2 be as in Figure 2. To see that O2 |= B0(x)\u2192 B4(x) holds, we construct a Herbrand interpretation I from B0(a): (22) and (23) derive S(f1(a), a) and B1(f1(a)); and (25) and (26) derive S(f1(a), f2(f1(a))) and B2(f2(f1(a))), and S(f1(a), f3(f1(a))) and B3(f3(f1(a))). Due to (27) we derive B4(f2(f1(a))) and B4(f3(f1(a))). Finally, from (28) we derive the following clause:\nf2(f1(a)) \u2248 a \u2228 f3(f1(a)) \u2248 a \u2228 f3(f1(a)) \u2248 f2(f1(a)) (56)\nDisjunct f3(f1(a)) \u2248 f2(f1(a)) cannot be satisfied due to (24); but then, regardless of whether we choose to satisfy f3(f1(a)) \u2248 a or f2(f1(a)) \u2248 a, we derive B4(a).\nOur calculus must be able to capture constraint (56) and its consequences, but standard DL axioms cannot explicitly refer to specific successors and predecessors. Instead, we capture consequences using context clauses\u2014clauses over terms x, fi(x), and y, where variable x represents the ground terms that a context stands for, fi(x) represents fisuccessors of x, and y represents the predecessor of x. We can thus identify the predecessor and the successors of x \u2018by name\u2019, allowing us to capture constraint (56) as\nf2(x) \u2248 y \u2228 f3(x) \u2248 y \u2228 f3(x) \u2248 f2(x). (57)\nBased on this idea, we adapted the rules by Simanc\u030c\u0131\u0301k, Motik, and Horrocks (2014) to handle context clauses correctly, and we added rules that capture the consequences of equality. The resulting set of rules is shown in Table 2.\nFigure 2 shows how to verify O2 |= B0(x)\u2192 B4(x) using our calculus; the maximal literal of each clause is shown on the right. We next discuss the inferences in detail.\nWe first create context v0 and initialise it with (29); this ensures that each interpretation represented by the context structure contains a ground term for which B0 holds. Next, we derive (30) and (31) using hyperresolution. At this point, we could hyperresolve (25) and (31) to obtain > \u2192 S(f1(x), f2(f1(x))); however, this could easily lead to nontermination of the calculus due to increased term nesting. Therefore, we require hyperresolution to map variable x in the DL-clauses to variable x in the context clauses; thus, hyperresolution derives in each context only consequences about x, which prevents redundant derivations.\nThe Succ rule next handles function symbol f1 in clauses (30) and (31). To determine which information to propagate to a successor, Definition 2 in Section 4 introduces a set Su(O) of successor triggers. In our example, DL-clause (28) contains atoms B1(x) and S(x, zi) in its body, and zi can be mapped to a predecessor or a successor of x; thus, a context in which hyperresolution is applied to (28) will be interested in information about its predecessors, which we reflect by adding B1(x) and S(x, y) to Su(O). In this example we use the so-called eager strategy (see Section 4.1), so the Succ rule introduces context v1, sets its core to B1(x) and S(x, y), and initialises the context with (33) and (34).\nWe next introduce (35)\u2013(38) using hyperresolution, at which point we have sufficient information to apply hyperresolution to (28) to derive (39). Please note how the presence of (33) is crucial for this inference.\nWe use paramodulation to deal with equality in clause\n(39). As is common in resolution-based theorem proving, we order the literals in a clause and apply inferences only to maximal literals; thus, we derive (40).\nClauses (35), (36), and (40) contain function symbol f2, so the Succ rule introduces context v2. Due to clause (36), B2(x) holds for all ground terms that v2 represents; thus, we add B2(x) to corev2 . In contrast, atom B3(f2(x)) occurs in clause (40) in a disjunction, which means it may not hold in v2; hence, we add B3(x) to the body of clause (44). The latter clause allows us to derive (45) using hyperresolution.\nClause (45) essentially says \u2018B3(f2(x)) should not hold in the predecessor\u2019, which the Pred rule propagates to v1 as clause (49); one can understand this inference as hyperresolution of (40) and (45) while observing that term f2(x) in context v1 is represented as variable x in context v2.\nAfter two paramodulation steps, we derive clause (51), which essentially says \u2018the predecessor must satisfy B2(x) or B3(x)\u2019. The set Pr(O) of predecessor triggers from Definition 2 identifies this as relevant to v0: the DL-clauses in (27) containB2(x) andB3(x) in their bodies, which are represented in v1 as B2(y) and B3(y). Hence Pr(O) contains B2(y) and B3(y), allowing the Pred rule to derive (52).\nAfter two more steps, we finally derive our target clause (54). We could not do this if B4(x) were maximal in (53); thus, we require all atoms in the head of a goal clause to be smallest. A similar observation applies to Pr(O): if B3(y) were maximal in (50), we would not derive (51) and propagate it to v0; thus, all atoms in Pr(O) must be smallest too.\n4 Formalising the Algorithm In this section, we first present our consequence-based algorithm for ALCHIQ formally, and then we present an outline of the completeness proof; full proofs are given in the appendix."}, {"heading": "4.1 Definitions", "text": "Our calculus manipulates context clauses, which are constructed from context terms and context literals as described in Definition 1. Unlike in general resolution, we restrict context clauses to contain only variables x and y, which have a special meaning in our setting: variable x represents a ground term in a Herbrand model, and y represents the predecessor of x; this naming convention is important for the rules of our calculus. This is in contrast to the DL-clauses of an ontology, which can contain variables x and zi, and where zi refer to either the predecessor or a successor of x. Definition 1. A context F-term is a term of the form x, y, or f(x) for f \u2208 F; a context P-term is a term of the form B(y), B(x), B(f(x)), S(x, y), S(y, x), S(x, f(x)), or S(f(x), x) for B,R \u2208 P and f \u2208 F; and a context term is an F-term or a P-term. A context literal is a literal of the form A \u2248 \u2118 (called a context atom), f(x) ./ g(x), or f(x) ./ y, y ./ y, forA a context P-term and ./ \u2208 {\u2248, 6\u2248}. A context clause is a clause with only function-free context atoms in the body, and only context literals in the head.\nDefinition 2 introduces sets Su(O) and Pr(O), that identify the information that must be exchanged between adjacent contexts. Intuitively, Su(O) contains atoms that are of interest to a context\u2019s successor, and it guides the Succ rule whereas Pr(O) contains atoms that are of interest to a context\u2019s predecessor and it guides the Pred rule. Definition 2. The set Su(O) of successor triggers of an ontology O is the smallest set of atoms such that, for each clause \u0393\u2192 \u2206 \u2208 O, \u2022 B(x) \u2208 \u0393 implies B(x) \u2208 Su(O), \u2022 S(x, zi) \u2208 \u0393 implies S(x, y) \u2208 Su(O), and \u2022 S(zi, x) \u2208 \u0393 implies S(y, x) \u2208 Su(O). The set Pr(O) of predecessor triggers of O is defined as\nPr(O) = {A{x 7\u2192 y, y 7\u2192 x} | A \u2208 Su(O) } \u222a {B(y) | B occurs in O}.\nAs in resolution, we restrict the inferences using a term order . Definition 3 specifies the conditions that the order must satisfy. Conditions 1 and 2 ensure that F-terms are compared uniformly across contexts; however, P-terms can be compared in different ways in different contexts. Conditions 1 through 4 ensure that, if we ground the order by mapping x to a term t and y to the predecessor of t, we obtain a simplification order (Baader and Nipkow 1998)\u2014 a kind of term order commonly used in equational theorem proving. Finally, condition 5 ensures that atoms that might be propagated to a context\u2019s predecessor via the Pred rule are smallest, which is important for completeness. Definition 3. Let m be a total, well-founded order on function symbols. A context term order is an order on context terms satisfying the following conditions:\n1. for each f \u2208 F , we have f(x) x y; 2. for all f, g \u2208 F with f m g, we have f(x) g(x); 3. for all terms s1, s2, and t and each position p in t, if s1 s2, then t[s1]p t[s2]p;\n4. for each term s and each proper position p in s, we have s s|p; and 5. for each atom A \u2248 \u2118 \u2208 Pr(O) and each context term s 6\u2208 {x, y}, we have A 6 s.\nEach term order is extended to a literal order, also written , as described in Section 2.\nA lexicographic path order (LPO) (Baader and Nipkow 1998) over context F-terms and context P-terms, in which x and y are treated as constants such that x y, satisfies conditions 1 through 4. Furthermore, Pr(O) contains only atoms of the form B(y), S(x, y), and S(y, x), which we can always make smallest in the ordering; thus, condition 5 does not contradict the other conditions. Hence, an LPO that is relaxed for condition 5 satisfies Definition 3, and thus, for any given m, at least one context term order exists.\nApart from orders, effective redundancy elimination techniques are critical to efficiency of resolution calculi. Definition 4 defines a notion compatible with our setting.\nDefinition 4. A set of clauses U contains a clause \u0393\u2192 \u2206 up to redundancy, written \u0393\u2192 \u2206 \u2208\u0302 U , if\n1. {s \u2248 s\u2032, s 6\u2248 s\u2032} \u2286 \u2206 or s \u2248 s \u2208 \u2206 for some terms s and s\u2032, or 2. \u0393\u2032 \u2286 \u0393 and \u2206\u2032 \u2286 \u2206 for some clause \u0393\u2032 \u2192 \u2206\u2032 \u2208 U . Intuitively, if U contains \u0393\u2192 \u2206 up to redundancy, then\nadding \u0393\u2192 \u2206 to U will not modify the constraints that U represents because either \u0393\u2192 \u2206 is a tautology or U contains a stronger clause. Note that tautologies of the form A\u2192 A are not redundant in our setting as they are used to initialise contexts; however, whenever our calculus derives a clause A\u2192 A \u2228A\u2032, the set of clauses will have been initialised with A\u2192 A, which makes the former clause redundant by condition 2 of Definition 4. Moreover, clause heads are subjected to the usual tautology elimination rules; thus, clauses \u03b3 \u2192 \u2206 \u2228 s \u2248 s and \u0393\u2192 \u2206 \u2228 s \u2248 t \u2228 s 6\u2248 t can be eliminated. Proposition 1 shows that we can remove from U each clause C that is contained in U \\ {C} up to redundancy; the Elim uses this to support clause subsumption.\nProposition 1. For U a set of clauses and C and C \u2032 clauses with C \u2208\u0302 U \\ {C} and C \u2032 \u2208\u0302 U , we have C \u2032 \u2208\u0302 U \\ {C}.\nWe are finally ready to formalise the notion of a context structure, as well as a notion of context structure soundness. The latter captures the fact that context clauses from a set Sv do not contain corev in their bodies. We shall later show that our inference rules preserve context structure soundness, which essentially proves that all clauses derived by our calculus are indeed conclusions of the ontology in question.\nDefinition 5. A context structure for an ontology O is a tuple D = \u3008V, E ,S, core, \u3009, where V is a finite set of contexts, E \u2286 V \u00d7 V \u00d7 F is a finite set of edges each labelled with a function symbol, function core assigns to each context v a conjunction corev of atoms over the P-terms from\nSu(O), function S assigns to each context v a finite set Sv of context clauses, and function assigns to each context v a context term order v . A context structure D is sound for O if the following conditions both hold.\nS1. For each context v \u2208 V and each clause \u0393\u2192 \u2206 \u2208 Sv , we have O |= corev \u2227 \u0393\u2192 \u2206. S2. For each edge \u3008u, v, f\u3009 \u2208 E , we have O |= coreu \u2192 corev{x 7\u2192 f(x), y 7\u2192 x}.\nDefinition 6 introduces an expansion strategy\u2014a parameter of our calculus that determines when and how to reuse contexts in order to satisfy existential restrictions. Definition 6. An expansion strategy is a function strategy that takes a function symbol f , a set of atoms K, and a context structure D = \u3008V, E ,S, core, \u3009. The result of strategy(f,K,D) is computable in polynomial time and it is a triple \u3008v, core\u2032, \u2032\u3009 where core\u2032 is a subset of K; either v /\u2208 V is a fresh context, or v \u2208 V is an existing context inD such that corev = core\u2032; and \u2032 is a context term order.\nSimanc\u030c\u0131\u0301k, Motik, and Horrocks (2014) presented two basic strategies, which we can adapt to our setting as follows. \u2022 The eager strategy returns for each K1 the context vK1\nwith core K1. The \u2018kind\u2019 of ground terms that vK1 represents is then very specific so the set SvK1 is likely to be smaller, but the number of contexts can be exponential.\n\u2022 The cautious strategy examines the function symbol f : if f occurs in O in exactly one atom of the form B(f(x)) and if B(x) \u2208 K1, then the result is the context vB(x) with core B(x); otherwise, the result is the \u2018trivial\u2019 context v> with the empty core. Context vB(x) is then less constrained, but the number of contexts is at most linear.\nSimanc\u030c\u0131\u0301k, Motik, and Horrocks (2014) discuss extensively the differences between and the relative merits of the two strategies; although their discussion deals with ALCI only, their conclusions apply to SRIQ as well.\nWe are now ready to show soundness and completeness. Theorem 1 (Soundness). For any expansion strategy, applying an inference rule from Table 2 to an ontology O and a context structure D that is sound forO produces a context structure that is sound for O.\nTheorem 2 (Completeness). Let O be an ontology, and let D = \u3008V, E ,S, core, \u3009 be a context structure such that no inference rule from Table 2 is applicable to O and D. Then, \u0393Q \u2192 \u2206Q \u2208\u0302 Sq holds for each query clause \u0393Q \u2192 \u2206Q and each context q \u2208 V that satisfy conditions C1\u2013C3.\nC1. O |= \u0393Q \u2192 \u2206Q. C2. For each atom A \u2248 \u2118 \u2208 \u2206Q and each context term\ns 6\u2208 {x, y}, if A q s, then s \u2248 \u2118 \u2208 \u2206Q \u222a Pr(O). C3. For each A \u2208 \u0393Q, we have \u0393Q \u2192 A \u2208\u0302 Sq . Conditions C2 and C3 can be satisfied by appropriately initialising the corresponding context. Hence, Theorems 1 and 2 show that the following algorithm is sound and complete for deciding O |= \u0393Q \u2192 \u2206Q.\nA1. Create an empty context structure D and select an expansion strategy.\nTable 2: Rules of the Consequence-Based Calculus\nCore rule\nIf A \u2208 corev , and > \u2192 A /\u2208 Sv , then add > \u2192 A to Sv . Hyper rule\nIf \u2227n i=1Ai \u2192 \u2206 \u2208 O,\n\u03c3 is a substitution such that \u03c3(x) = x, \u0393i \u2192 \u2206i \u2228Ai\u03c3 \u2208 Sv s.t. \u2206i 6 v Ai\u03c3 for 1 \u2264 i \u2264 n, and \u2227n i=1 \u0393i \u2192 \u2206\u03c3 \u2228 \u2228n i=1 \u2206i 6\u2208\u0302 Sv ,\nthen add \u2227n i=1 \u0393i \u2192 \u2206\u03c3 \u2228 \u2228n i=1 \u2206i to Sv . Eq rule If \u03931 \u2192 \u22061 \u2228 s1 \u2248 t1 \u2208 Sv ,\ns1 v t1 and \u22061 6 v s1 \u2248 t1, \u03932 \u2192 \u22062 \u2228 s2 ./ t2 \u2208 Sv with ./ \u2208 {\u2248, 6\u2248}, s2 v t2 and \u22062 6 v s2 ./ t2, s2|p = s1, and \u03931 \u2227 \u03932 \u2192 \u22061 \u2228\u22062 \u2228 s2[t1]p ./ t2 6\u2208\u0302 Sv ,\nthen add \u03931 \u2227 \u03932 \u2192 \u22061 \u2228\u22062 \u2228 s2[t1]p ./ t2 to Sv . Ineq rule If \u0393\u2192 \u2206 \u2228 t 6\u2248 t \u2208 Sv and \u0393\u2192 \u2206 6\u2208\u0302 Sv , then add \u0393\u2192 \u2206 to Sv . Factor rule If \u0393\u2192 \u2206 \u2228 s \u2248 t \u2228 s \u2248 t\u2032 \u2208 Sv , \u2206 \u222a {s \u2248 t} 6 v s \u2248 t\u2032 and s v t\u2032 and \u0393\u2192 \u2206 \u2228 t 6\u2248 t\u2032 \u2228 s \u2248 t\u2032 6\u2208\u0302 Sv , then add \u0393\u2192 \u2206 \u2228 t 6\u2248 t\u2032 \u2228 s \u2248 t\u2032 to Sv . Elim rule If \u0393\u2192 \u2206 \u2208 Sv and \u0393\u2192 \u2206 \u2208\u0302 Sv \\ {\u0393\u2192 \u2206} then remove \u0393\u2192 \u2206 from Sv . Pred rule If \u3008u, v, f\u3009 \u2208 E ,\u2227l i=1Ai \u2192 \u2228l+n i=l+1Ai \u2208 Sv ,\n\u0393i \u2192 \u2206i \u2228Ai\u03c3 \u2208 Su s.t. \u2206i 6 u Ai\u03c3 for 1 \u2264 i \u2264 l, Ai \u2208 Pr(O) for each l + 1 \u2264 i \u2264 l + n, and \u2227l i=1 \u0393i \u2192 \u2228l i=1 \u2206i \u2228 \u2228l+n i=l+1Ai\u03c3 6\u2208\u0302 Su,\nthen add \u2227l i=1 \u0393i \u2192 \u2228l i=1 \u2206i \u2228 \u2228l+n i=l+1Ai\u03c3 to Su, where \u03c3 = {x 7\u2192 f(x), y 7\u2192 x}. Succ rule If \u0393\u2192 \u2206 \u2228A \u2208 Su s.t. \u2206 6 u A and A contains f(x), and, for each A\u2032 \u2208 K2 \\ corev , no edge \u3008u, v, f\u3009 \u2208 E exists such that A\u2032 \u2192 A\u2032 \u2208\u0302 Sv , then let \u3008v, core\u2032, \u2032\u3009 := strategy(f,K1,D); if v \u2208 V , then let v := v \u2229 \u2032, and otherwise let V := V \u222a {v}, v := \u2032,\ncorev := core \u2032, and Sv := \u2205;\nadd the edge \u3008u, v, f\u3009 to E ; and add A\u2032 \u2192 A\u2032 to Sv for each A\u2032 \u2208 K2 \\ corev;\nwhere \u03c3 = {x 7\u2192 f(x), y 7\u2192 x}, K1 = {A\u2032 \u2208 Su(O) | > \u2192 A\u2032\u03c3 \u2208 Su }, and K2 = {A\u2032 \u2208 Su(O) | \u0393\u2032 \u2192 \u2206\u2032 \u2228A\u2032\u03c3 \u2208 Su and\n\u2206\u2032 6 u A\u2032\u03c3 }.\nA2. Introduce a context q intoD; set coreq = \u0393Q; for each A \u2208 \u0393Q, add > \u2192 A to Sq to satisfy condition C3; and initialise q in a way that satisfies condition C2.\nA3. Apply the inference rules from Table 2 to D and O. A4. \u0393Q \u2192 \u2206Q holds if and only if \u0393Q \u2192 \u2206Q \u2208\u0302 Sv . Propositions 2 and 3 show that our calculus is worst-case optimal for both ALCHIQ and ELH. Proposition 2. For each expansion strategy that introduces at most exponentially many contexts, algorithm A1\u2013A4 runs in worst-case exponential time.\nProposition 3. For ELH ontologies and queries of the form B1(x)\u2192 B2(x), algorithm A1\u2013A4 runs in polynomial time with either the cautious or the eager strategy; and with the cautious strategy and the Hyper rule applied eagerly, the inferences in step A3 correspond directly to the inferences of the ELH calculus by Baader, Brandt, and Lutz (2005)."}, {"heading": "4.2 An Outline of the Completeness Proof", "text": "To prove Theorem 2, we fix an ontology O, a context structure D, a query clause \u0393Q \u2192 \u2206Q, and a context q such that properties C2 and C3 of Theorem 2 are satisfied and \u0393Q \u2192 \u2206Q 6\u2208\u0302 Sq holds, and we construct a Herbrand interpretation that satisfies O but refutes \u0393Q \u2192 \u2206Q. We reuse techniques from equational theorem proving (Nieuwenhuis and Rubio 1995) and represent this interpretation by a rewrite system R\u2014a finite set of rules of the form l\u21d2 r. Intuitively, such a rule says that that any two terms of the form f1(. . . fn(l) . . . ) and f1(. . . fn(r) . . . ) with n \u2265 0 are equal, and that we can prove this equality in one step by rewriting (i.e., replacing) l with r. Rewrite system R induces a Herbrand equality interpretation R\u2217 that contains each l \u2248 r for which the equality between l and r can be verified using a finite number of such rewrite steps. The universe of R\u2217 consists of F- and P-terms constructed using the symbols in F and P , and a special constant c; for convenience, let T be the set of all F-terms from this universe.\nWe obtainR by unfolding the context structureD starting from context q: we map each F-term t \u2208 T to a context Xt in D, and we use the clauses in SXt to construct a model fragment Rt\u2014the part of R that satisfies the DL-clauses of O when x is mapped to t. The key issue is to ensure compatibility between adjacent model fragments: when moving from a predecessor term t\u2032 to a successor term t = f(t\u2032), we must ensure that adding Rt to Rt\u2032 does not affect the truth of the DL-clauses of O at term t\u2032; in other words, the model fragment constructed at t must respect the choices made at t\u2032. We represent these choices by a ground clause \u0393t \u2192 \u2206t: conjunction \u0393t contains atoms that are \u2018inherited\u2019 from t\u2032 and so must hold at t, and disjunction \u2206t contains atoms that must not hold at t because t\u2032 relies on their absence.\nThe model fragment construction takes as parameters a term t, a context v = Xt, and a clause \u0393t \u2192 \u2206t. Let Nt be the set of ground clauses obtained from Sv by mapping x to t and y to the predecessor of t (if it exists), and whose body is contained in \u0393t. Moreover, let Sut and Prt be obtained from Su(O) and Pr(O) by mapping x to t and y to the predecessor of t if one exists; thus, Sut contains the ground atoms of\ninterest to the successors of t, and Prt contains the ground atoms of interest to the predecessor of t. The model fragment for t can be constructed if properties L1\u2013L3 hold:\nL1. \u0393t \u2192 \u2206t 6\u2208\u0302 Nt. L2. If t = c, then \u2206t = \u2206Q; and if t 6= c, then \u2206t \u2286 Prt. L3. For each A \u2208 \u0393t, we have \u0393t \u2192 A \u2208\u0302 Nt.\nThe construction produces a rewrite system Rt such that\nF1. R\u2217t |= Nt, and F2. R\u2217t 6|= \u0393t \u2192 \u2206t\u2014that is, all of \u0393t, but none of \u2206t hold\nin R\u2217t , and so the model fragment at t is compatible with the \u2018inherited\u2019 constraints.\nWe construct rewrite system Rt by adapting the techniques from paramodulation-based theorem proving. First, we order all clauses in Nt into a sequence Ci = \u0393i \u2192 \u2206i \u2228 Li, 1 \u2264 i \u2264 n, that is compatible with the context ordering v in a particular way. Next, we initialise Rt to \u2205, and then we examine each clauseCi in this sequence; ifCi does not hold in the model constructed thus far, we make the clause true by adding Li to Rt. To prove condition F1, we assume for the sake of a contradiction that a clause Ci with smallest i exists such that R\u2217t 6|= Ci, and we show that an application of the Eq, Ineq, or Factor rule to Ci necessarily produces a clause Cj such that R\u2217t 6|= Cj and j < i. Conditions L1 through L3 allow us to satisfy condition F2. Due to condition L2 and condition 5 of Definition 3, we can order the clauses in the sequence such that each clause Ci capable of producing an atom from \u2206t comes before any other clause in the sequence; and then we use condition L1 to show that no such clause actually exists. Moreover, condition L3 ensures that all atoms in \u0393t are actually produced in R\u2217t .\nTo obtain R, we inductively unfold D, and at each step we apply the model fragment construction to the appropriate parameters. For the base case, we map constant c to context Xc = q, and we define \u0393c = \u0393Q and \u2206c = \u2206Q; then, conditions L1 and L2 hold by definition, and condition L3 holds by property C3 of Theorem 2. For the induction step, we assume that we have already mapped some term t\u2032 to a context u = Xt\u2032 , and we consider term t = f(t\u2032) for each f \u2208 F . \u2022 If t does not occur in an atom inRt\u2032 , we letRt = {t\u21d2 c}\nand thus make t equal to c. Term t is thus interpreted in exactly the same way as c, so we stop the unfolding.\n\u2022 If Rt\u2032 contains a rule t\u21d2 s, then t and s are equal, and so we interpret t exactly as s; hence, we stop the unfolding.\n\u2022 In all other cases, the Succ rule ensures that D contains an edge \u3008u, v, f\u3009 such that v satisfies all preconditions of the rule, so we define Xt = v. Moreover, we let \u0393t = R\u2217t\u2032 \u2229 Sut be the set of atoms that hold at t\u2032 and are relevant to t , and we let \u2206t = Prt \\R\u2217t\u2032 be the set of atoms that do not hold at t\u2032 and are relevant to t. We finally show that such \u0393t and \u2206t satisfy condition L1: otherwise, the Pred rule derives a clause inNt\u2032 that is not true inR\u2217t\u2032 .\nAfter processing all relevant terms, we let R be the union of all Rt from the above construction. To show that R\u2217 satisfies O, we consider a DL-clause \u0393\u2192 \u2206 \u2208 O and a substitution \u03c4 that makes the clause ground. W.l.o.g. we can\nassume that \u03c4 is irreducible by R\u2014that is, it does not contain terms that can we rewritten using the rules in R. Since each model fragment satisfies condition F2, we can evaluate \u0393\u03c4 \u2192 \u2206\u03c4 in R\u2217\u03c4(x) instead of R\n\u2217. Moreover, we show that R\u2217\u03c4(x) |= \u0393\u03c4 \u2192 \u2206\u03c4 holds: if that were not the case, the Hyper rule derives a clause in N\u03c4(x) that violates condition F1. Finally, we show that the same holds for the query clause \u0393Q \u2192 \u2206Q, which completes our proof.\n5 Evaluation We have implemented our calculus in a prototype system called Sequoia. The calculus was implemented exactly as presented in this paper, with no optimisation other than a suitable indexing scheme for clauses. The system is written in Scala, and it can be used via the command line or the OWL API. It currently handles the SRIQ subset of OWL 2 DL (i.e., it does not support datatypes, nominals, or reflexive roles), for which it supports ontology classification and concept satisfiability; other standard services such as ABox realisation are currently not supported.\nWe have evaluated our system using the methodology by Steigmiller, Liebig, and Glimm (2014) by comparing Se-\nquoia with HermiT 1.3.8, Pellet 2.3.1, FaCT++ 1.6.4, and Konclude 1.6.1. We used all reasoners in single-threaded mode in order to compare the underlying calculi; moreover, Sequoia was configured to use the cautious strategy. All systems, ontologies, and test results are available online.1\nWe used the Oxford Ontology Repository2 from which we excluded 7 ontologies with irregular RBoxes. Since Sequoia does not support datatypes or nominals, we have systematically replaced datatypes and nominals with fresh classes and data properties with object properties, and we have removed ABox assertions. We thus obtained a corpus of 777 ontologies on which we tested all reasoners.\nWe run our experiments on a Dell workstation with two Intel Xeon E5-2643 v3 3.4 GHz processors with 6 cores per processor and 128 GB of RAM running Windows Server 2012 R2. We used Java 8 update 66 with 15 GB of heap memory allocated to each Java reasoner, and a maximum private working set size of 15 GB for each reasoner in native code. In each test, we measured the wall-clock classification time; this excludes parsing time for reasoners based on the OWL API (i.e., HermiT, Pellet, FaCT++, and Sequoia). Each test was given a timeout of 5 minutes. We report the average time over three runs, unless an exception or timeout occurred in one of the three runs, in which case we report failure.\nFigure 3 shows an overview of the classification times for the entire corpus. The y-axis shows the classification times in logarithmic scale, and timeouts are shown as infinity. A number n on the x-axis represents the n-th easiest ontology for a reasoner with ontologies sorted (for that reasoner) in the ascending order of classification time. For example, a point (50, 100) on a reasoner\u2019s curve means that the 50th easiest ontology for that reasoner took 100 ms to classify.\nSequoia could process most ontologies (733 out of 784) in under 10s, which is consistent with the other reasoners. The system was fairly robust, failing on only 22 ontologies; in contrast, HermiT failed on 42, Pellet on 138, FaCT++ on 132, and Konclude on 8 ontologies. Moreover, Sequoia succeeded on 21 ontologies on which all of HermiT, Pellet and FaCT++ failed. Finally, there was one ontology where Sequoia succeeded and all other reasoners failed; this was a hard version of FMA (ID 00285) that uses both disjunctions and number restrictions.\nFigure 4 shows an overview of how each reasoner performed on each type of ontology. We partitioned the ontologies in the following four groups: within a profile of OWL 2 DL (i.e., captured by OWL 2 EL, QL, or RL); Horn but not in a profile; disjunctive but without number restrictions; and disjunctive and with number restrictions. We used the OWL API to determine profile membership, and we identified the remaining three groups after structural transformation. In addition, for each reasoner, we categorise each ontology as either \u2018easy\u2019 (< 10s), \u2018medium\u2019 (10s to 5min), and \u2018hard\u2019 (timeout or exception). The figure depicts a bar for each reasoner and group, where each bar is divided into blocks representing the percentage of ontologies in each of the aforementioned categories of difficulty. For Sequoia, over 98% of\n1http://krr-nas.cs.ox.ac.uk/2015/KR/cr/ 2http://www.cs.ox.ac.uk/isg/ontologies/\nprofile ontologies and over 91% of out-of-profile Horn ontologies are easy, with the remainder being of medium difficulty. Sequoia timed out largely on ontologies containing both disjunctions and equality, and even in this case only Konclude timed out in fewer cases.\nIn summary, although only an early prototype, Sequoia is a competitive reasoner that comfortably outperforms HermiT, Pellet, and FaCT++, and which exhibits a nice payas-you-go behaviour. Furthermore, problematic ontologies seem to mostly contain complex RBoxes or large numbers in cardinality restrictions, which suggests promising directions for future optimisation.\n6 Conclusion and Future Work We have presented the first consequence based calculus for SRIQ\u2014a DL that includes both disjunction and counting quantifiers. Our calculus combines ideas from state of the art resolution and (hyper)tableau calculi, including the use of ordered paramodulation for equality reasoning. Despite its increased complexity, the calculus mimics existing calculi on ELH ontologies. Although it is an early prototype with plenty of room for optimisation, our system Sequoia is competitive with well-established reasoners and it exhibits nice pay-as-you-go behaviour in practice.\nFor future work, we are confident that we can extend the calculus to support role reflexivity and datatypes, thus handling all of OWL 2 DL except nominals. In contrast, handling nominals seems to be much more involved. In fact, adding nominals to ALCHIQ raises the complexity of reasoning to NEXPTIME so a worst-case optimal calculus must be nondeterministic, which is quite different from all consequence-based calculi we are aware of. Moreover, a further challenge is to modify the calculus so that it can effectively deal with large numbers in number restrictions.\nReferences Baader, F., and Nipkow, T. 1998. Term Rewriting and All That. Cambridge University Press. Baader, F.; Calvanese, D.; McGuinness, D.; Nardi, D.; and Patel-Schneider, P. F., eds. 2003. The Description Logic Handbook: Theory, Implementation and Applications. Cambridge University Press. Baader, F.; Brandt, S.; and Lutz, C. 2005. Pushing the EL Envelope. In Kaelbling, L. P., and Saffiotti, A., eds., Proc. of the 19th Int. Joint Conference on Artificial Intelligence (IJCAI 2005), 364\u2013369. Edinburgh, UK: Morgan Kaufmann Publishers. Bachmair, L., and Ganzinger, H. 2001. Resolution Theorem Proving. In Robinson, A., and Voronkov, A., eds., Handbook of Automated Reasoning, volume I. Elsevier Science. chapter 2, 19\u201399. Glimm, B.; Horrocks, I.; Motik, B.; Stoilos, G.; and Wang, Z. 2014. HermiT: An OWL 2 Reasoner. Journal of Automated Reasoning 53(3):245\u2013269. Gore\u0301, R., and Nguyen, L. A. 2007. EXPTIME Tableaux with Global Caching for Description Logics with Transitive Roles, Inverse Roles and Role Hierarchies. In Olivetti,\nN., ed., Proc. of the 16th Int. Conf. on Automated Reasoning with Tableaux and Related Methods (TABLEAUX 2007), volume 4548 of LNCS, 133\u2013148. Aix en Provence, France: Springer. Kazakov, Y. 2008. RIQ and SROIQ are Harder than SHOIQ. In Brewka, G., and Lang, J., eds., Proc. of the 11th Int. Joint Conf. on Principles of Knowledge Representation and Reasoning (KR 2008), 274\u2013284. Sydney, NSW, Australia: AAAI Press. Kazakov, Y. 2009. Consequence-Driven Reasoning for Horn SHIQ Ontologies. In Boutilier, C., ed., Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI 2009), 2040\u2013 2045. Motik, B.; Shearer, R.; and Horrocks, I. 2009. Hypertableau Reasoning for Description Logics. Journal of Artificial Intelligence Research 36:165\u2013228. Nieuwenhuis, R., and Rubio, A. 1995. Theorem Proving with Ordering and Equality Constrained Clauses. Journal of Symbolic Computation 19(4):312\u2013351. Ortiz, M.; Rudolph, S.; and Simkus, M. 2010. Worst-Case Optimal Reasoning for the Horn-DL Fragments of OWL 1 and 2. In Lin, F.; Sattler, U.; and Truszczynski, M., eds., Proc. of the 12th Int. Conf. on Knowledge Representation and Reasoning (KR 2010), 269\u2013279. Toronto, ON, Canada: AAAI Press. Riazanov, A., and Voronkov, A. 2002. The design and implementation of VAMPIRE. AI Communications 15(2\u20133):91\u2013 110. Schulz, S. 2002. E\u2014A Brainiac Theorem Prover. AI Communications 15(2\u20133):111\u2013126. Simanc\u030c\u0131\u0301k, F.; Kazakov, Y.; and Horrocks, I. 2011. Consequence-Based Reasoning beyond Horn Ontologies. In Walsh, T., ed., Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2011), 1093\u20131098. Simanc\u030c\u0131\u0301k, F.; Motik, B.; and Horrocks, I. 2014. Consequence-Based and Fixed-Parameter Tractable Reasoning in Description Logics. Artificial Intelligence 209:29\u201377. Sirin, E.; Parsia, B.; Cuenca Grau, B.; Kalyanpur, A.; and Katz, Y. 2007. Pellet: A practical OWL-DL reasoner. Journal of Web Semantics 5(2):51\u201353. Steigmiller, A.; Glimm, B.; and Liebig, T. 2014. Coupling Tableau Algorithms for Expressive Description Logics with Completion-Based Saturation Procedures. In Demri, S.; Kapur, D.; and Weidenbach, C., eds., Proc. of the 7th Int. Joint Conf. on Automated Reasoning (IJCAR 2014), volume 8562 of LNCS, 449\u2013463. Vienna, Austria: Springer. Steigmiller, A.; Liebig, T.; and Glimm, B. 2014. Konclude: System description. Journal of Web Semantics 27:78\u201385. Tsarkov, D., and Horrocks, I. 2006. FaCT++ Description Logic Reasoner: System Description. In Proc. of the 3rd Int. Joint Conf. on Automated Reasoning (IJCAR 2006), volume 4130 of LNAI, 292\u2013297. Seattle, WA, USA: Springer.\nA Proof of Theorem 1 In this chapter, we show that our calculus is sound, as stated in Theorem 1. The proof is analogous to the soundness proof of ordered superposition (Nieuwenhuis and Rubio 1995). Theorem 1 (Soundness). For any expansion strategy, applying an inference rule from Table 2 to an ontology O and a context structure D that is sound for O produces a context structure that is sound for O.\nProof. Let O be an ontology, let D = \u3008V, E ,S, core, \u3009 be a context structure that is sound for O, and consider an application of an inference rule from Table 2 to D and O. We show that each clause produced by the rule is a context clause and that it satisfies conditions S1 and S2 of Definition 5. Condition S1 holds obviously for the rules different from Hyper, Eq, and Pred. For condition S2, we rely on soundness of hyperresolution: for arbitrary formulas \u03c9, \u03c6i, \u03c8i, and \u03b3i, 1 \u2264 i \u2264 n, we have\n{ n\u2227 j=1 \u03c6j \u2192 \u03c9} \u222a \u22c3 1\u2264i\u2264n {\u03b3i \u2192 \u03c8i \u2228 \u03c6i} |= n\u2227 i=1 \u03b3i \u2192 n\u2228 i=1 \u03c8i \u2228 \u03c9. (58)\nTo prove the claim, we consider each rule from Table 2 and assume that the rule is applied to clauses, contexts, and edges as shown in the table; then, we show that the clause produced by the rule satisfies condition S1 of Definition 5; moreover, for the Succ rule, we show in addition that the edge introduced by the rule satisfies condition S2.\n(Core) For each A \u2208 corev , we clearly have O |= corev \u2192 A. (Hyper) Since D is sound for O, we have O |= corev \u2227 \u0393i \u2192 \u2206i \u2228Ai\u03c3 for each i with 1 \u2264 i \u2264 n. By (58), we have O |= corev \u2227 \u2227n i=1 \u0393i \u2192 \u2228n i=1 \u2206i \u2228\u2206\u03c3. Moreover, substitution \u03c3 satisfies \u03c3(x) = x, all premises are context clauses, and O contains only DL-clauses; thus, the inference rule can only match an atom S(x, zi) or S(zi, x) in an ontology clause to atoms S(y, x), S(x, y), S(f(x), x) or S(x, f(x)) in the context clause, and so \u03c3(zi) is either y or f(x); thus, the result is a context clause.\n(Eq) Since D is sound for O, properties (59) and (60) hold. Moreover, clause in (61) is a logical consequence of the clauses in (59) and (60), so property (61) holds, as required.\nO |= corev \u2227 \u03931 \u2192 \u22061 \u2228 s1 \u2248 t1 (59) O |= corev \u2227 \u03932 \u2192 \u22062 \u2228 s2 ./ t2 (60) O |= corev \u2227 \u03931 \u2227 \u03932 \u2192 \u22061 \u2228\u22062 \u2228 s2[t1]p ./ t2 (61)\nFinally, term s1 is always of the form g(f(x)), term t1 is of the form h(f(x)) or y, and term s2 is of the form g(f(x)), B(g(f(x))), S(f(x), g(f(x))), or S(g(f(x)), f(x)); thus, s2[t1]p is a context term, and so the result is a context clause.\n(Ineq) Since D is sound for O, we have O |= corev \u2227 \u0393\u2192 \u2206 \u2228 t 6\u2248 t; but then, we clearly have O |= corev \u2227 \u0393\u2192 \u2206, as required.\n(Factor) Since D is sound for O, property (62) holds. Moreover, clause in (63) is a logical consequence of the clause in (62), so property (63) holds, as required.\nO |= corev \u2227 \u0393\u2192 \u2206 \u2228 s \u2248 t \u2228 s \u2248 t\u2032 (62) O |= corev \u2227 \u0393\u2192 \u2206 \u2228 t 6\u2248 t\u2032 \u2228 s \u2248 t\u2032 (63)\n(Elim) The resulting context structure contains a subset of the clauses from D, so it is clearly sound for O. (Pred) Let \u03c3 = {x 7\u2192 f(x), y 7\u2192 x}. Since D is sound for O, properties (64)\u2013(66) hold. Now clause in (67) is an instance of the clause in (64), so property (67) holds. But then, by (58), properties (64) and (65) imply property (68). Finally, properties (66) and (68) imply property (69), as required.\nO |= corev \u2227 \u2227m i=1Ai \u2192 \u2228m+n j=m+1Aj (64)\nO |= coreu \u2227 \u0393i \u2192 \u2206i \u2228Ai\u03c3 for 1 \u2264 i \u2264 m (65) O |= coreu \u2192 corev\u03c3 (66) O |= corev\u03c3 \u2227 \u2227m i=1Ai\u03c3 \u2192 \u2228m+n j=m+1Aj\u03c3 (67)\nO |= corev\u03c3 \u2227 corev \u2227 \u2227m i=1 \u0393i \u2192 \u2228m+n j=m+1Aj\u03c3 (68)\nO |= coreu \u2227 \u2227m i=1 \u0393i \u2192 \u2228m+n j=m+1Aj\u03c3 (69)\nFor each m+ 1 \u2264 i \u2264 m+ n, we have Ai \u2208 Pr(O), so Ai is of the form B(y), S(x, y), or S(y, x); but then, the definition of \u03c3 ensures that Ai\u03c3 is a context atom, as required.\n(Succ) Let \u03c3 = {x 7\u2192 f(x), y 7\u2192 x}. For each clause A\u2192 A added to Sv , we clearly have O |= corev \u2227A\u2192 A, as required for condition S1 of Definition 5. Moreover, assume that the inference rule adds an edge \u3008u, v, fk\u3009 to E ; since D is sound for O, we have (70); by Definition 6, we have corev \u2286 K1.\nO |= coreu \u2192 A\u03c3 for each A \u2208 K1 (70) O |= coreu \u2192 corev\u03c3 (71)\nBut then, property (71) holds, as required for condition S2 of Definition 5.\nB Preliminaries: Rewrite Systems In the proof of Theorem 2 we construct a model of an ontology, which, as is common in equational theorem proving, we represent using a ground rewrite system. We next recapitulate the definitions of rewrite systems, following the presentation by Baader and Nipkow (1998).\nLet T be the set of all ground terms constructed using a distinguished constant c (of sort F), the function symbols from F , and the predicate symbols from P . A (ground) rewrite system R is a binary relation on T . Each pair (s, t) \u2208 R is called a rewrite rule and is commonly written as s\u21d2 t. The rewrite relation\u2192R forR is the smallest binary relation on T such that, for all terms s1, s2, t \u2208 T and each (not necessarily proper) position p in t, if s1 \u21d2 s2 \u2208 R, then t[s1]p \u2192R t[s2]p. Moreover,\n\u2217\u2192R is the reflexive\u2013transitive closure of\u2192R, and\n\u2217\u2194R is the reflexive\u2013symmetric\u2013transitive closure of\u2192R. A term s is irreducible by R if no term t exists such that s\u2192R t; and a literal, clause, or substitution \u03b1 is irreducible by R if no term occurring in \u03b1 is irreducible by R. Moreover, term t is a normal form of s w.r.t. R if s \u2217\u2194R t and t is irreducible by R. We consider the following properties of rewrite systems. \u2022 R is terminating if no infinite sequence s1, s2, . . . of terms exists such that, for each i, we have si \u2192R si+1. \u2022 R is left-reduced if, for each s\u21d2 t \u2208 R, the term s is irreducible by R \\ {s\u21d2 t}.\n\u2022 R is Church-Rosser if, for all terms t1 and t2 such that t1 \u2217\u2194R t2, a term z exists such that t1 \u2217\u2192R z and t2 \u2217\u2192R z.\nIf R is terminating and left-reduced, then R is Church-Rosser (Baader and Nipkow 1998, Theorem 2.1.5 and Exercise 6.7). If R is Church-Rosser, then each term s has a unique normal form t such that s \u2217\u2192R t holds. The Herbrand interpretation induced by a Church-Rosser system R is the set R\u2217 such that, for all s, t \u2208 T , we have s \u2248 t \u2208 R\u2217 if and only if s \u2217\u2194R t.\nTerm orders can be used to prove termination of rewrite systems. A term order is a simplification order if the following conditions hold: \u2022 for all terms s1, s2, and t, all positions p in t, and all substitutions \u03c3, we have that s1 s2 implies t[s1\u03c3]p t[s2\u03c3]p; and \u2022 for each term s and each proper position p in s, we have s s|p. Given a rewrite system R, if a simplification order exists such that s\u21d2 t \u2208 R implies s t, then R is terminating (Baader and Nipkow 1998, Theorems 5.2.3 and 5.4.8), and s\u2192R t implies s t.\nC Proof of Theorem 2 Theorem 2 (Completeness). LetO be an ontology, and letD = \u3008V, E ,S, core, \u3009 be a context structure such that no inference rule from Table 2 is applicable to O and D. Then, \u0393Q \u2192 \u2206Q \u2208\u0302 Sq holds for each query clause \u0393Q \u2192 \u2206Q and each context q \u2208 V that satisfy conditions C1\u2013C3.\nC1. O |= \u0393Q \u2192 \u2206Q. C2. For each atom A \u2248 \u2118 \u2208 \u2206Q and each context term s 6\u2208 {x, y}, if A q s, then s \u2248 \u2118 \u2208 \u2206Q \u222a Pr(O). C3. For each A \u2208 \u0393Q, we have \u0393Q \u2192 A \u2208\u0302 Sq . In this section, we fix an ontology O, a context structure D = \u3008V, E ,S, core, \u3009, a context q \u2208 V , and a query clause \u0393Q \u2192 \u2206Q such that conditions C3 and C2 of Theorem 2 are satisfied, and we show the contrapositive of condition C1: if \u0393Q \u2192 \u2206Q 6\u2208\u0302 Sq , then O 6|= \u0393Q \u2192 \u2206Q. To this end, we construct a rewrite system R such that the induced Herbrand model R\u2217 satisfies all clauses in O, but not \u0393Q \u2192 \u2206Q. We construct the model using a distinguished constant c, the unary function symbols from F , and the unary and binary predicate symbols from P1 and P2, respectively.\nLet t be a term. If t is of the form t = f(s), then s is the predecessor of t, and t is a successor of s; by these definitions, a constant has no predecessor. The F-neighbourhood of t is the set of F-terms containing t, f(t) with f \u2208 F , and the predecessor t\u2032 of t if one exists; the P-neighbourhood of t contains P-termsB(t), S(t, f(t)), S(f(t), t),B(f(t)), and, if t has the predecessor t\u2032, also P-terms S(t\u2032, t), S(t, t\u2032), and B(t\u2032), for all B \u2208 P1 and S \u2208 P2. Let \u03c3t be the substitution such that \u03c3t(x) = t and, if t has the predecessor t\u2032, then \u03c3t(y) = t\u2032. Finally, for each term t, we define sets of atoms Prt and Sut as follows:\nSut = {A\u03c3t | A \u2208 Su(O) and A\u03c3t is ground } (72) Prt = {A\u03c3t | A \u2208 Pr(O) and A\u03c3t is ground } (73)"}, {"heading": "C.1 Constructing a Model Fragment", "text": "In this section, we show how, given a term t, we can generate a part of the model of O that covers the neighbourhood of t. In the rest of Appendix C.1, we fix the following parameters to the model fragment generation process: \u2022 t is a ground F-term, \u2022 v is a context in D, \u2022 \u0393t is a conjunction of atoms, and \u2022 \u2206t is a disjunction of atoms. Let Nt be the set of ground clauses obtained from Sv as follows:\nNt = {\u0393\u03c3t \u2192 \u2206\u03c3t | \u0393\u2192 \u2206 \u2208 Sv, both \u0393\u03c3t and \u2206\u03c3t are ground, and \u0393\u03c3t \u2286 \u0393t} We assume that the following conditions hold.\nL1. \u0393t \u2192 \u2206t 6\u2208\u0302 Nt. L2. If t = c, then \u2206t = \u2206Q; and if t 6= c, then \u2206t \u2286 Prt. L3. For each A \u2208 \u0393t, we have \u0393t \u2192 A \u2208\u0302 Nt. We next construct a rewrite system Rt such that R\u2217t |= Nt and R\u2217t 6|= \u0393t \u2192 \u2206t holds. Throughout Appendix C.1, we treat the terms in the F-neighbourhood of t as if they were constants. Thus, even though the rewrite system R will contain terms t and f(t), we will not consider terms with further nesting."}, {"heading": "C.1.1 Grounding the Context Order", "text": "To construct Rt, we need an order on the terms in the neighbourhood of t that is compatible with v . To this end, let >t be a total, strict, simplification order on the set of ground terms constructed using the F-neighbourhood of t and the predicate symbols in P that satisfies the following conditions for all context terms s1 and s2 such that s1\u03c3t and s2\u03c3t are both ground, and where t\u2032 is the predecessor of t if it exists.\nO1. s1 v s2 implies s1\u03c3t >t s2\u03c3t. O2. s1\u03c3t \u2248 \u2118 \u2208 \u2206t and s1\u03c3t >t s2\u03c3t and s2\u03c3t 6\u2208 {t, t\u2032} imply s2\u03c3t \u2248 \u2118 \u2208 \u2206t.\nCondition C2 of Theorem 2 and condition 5 of Definition 3 ensure that the order v on (nonground) context terms can be grounded in a way compatible with condition L2. Moreover, since in this section we treat all F-terms as constants, we can make the P-terms of the form B(t\u2032), S(t\u2032, t), and S(t, t\u2032) smaller than other F- and P-terms (i.e., we do not need to worry about defining the order on the predecessor of t\u2032 or on the ancestors of f(t)). Thus, at least one such order exists, so in the rest of this section we fix an arbitrary such order >t. We extend >t to ground literals (also written >t) by identifying each s 6\u2248 t with the multiset {s, s, t, t} and each s \u2248 t with the multiset {s, t}, and then comparing the result using the multiset extension of the term order (as defined in Section 2). Finally, we further extend >t to disjunctions of ground literals (also written >t) by identifying each disjunction \u2228n i=1 Li with the multiset {L1, . . . , Ln} and then comparing the result using the multiset extension of the literal order."}, {"heading": "C.1.2 Constructing the Rewrite System Rt", "text": "We arrange all clauses in Nt into a sequence C1, . . . , Cn. Since the body of each Ci is a subset of \u0393t, no Ci can contain \u22a5 in its head as that would contradict condition L1; thus, we can assume that each Ci is of the form Ci = \u0393i \u2192 \u2206i \u2228 Li where Li >t \u2206\ni, literal Li is of the form Li = li ./ ri with ./ \u2208 {\u2248, 6\u2248}, and li \u2265t ri. For the rest of Appendix C.1, we reserve Ci, \u0393i, \u2206i, Li, li, and ri for referring to the (parts of) the clauses in this sequence. Finally, we assume that, for all 1 \u2264 i < j \u2264 n, we have \u2206j \u2228 Lj \u2265t \u2206i \u2228 Li.\nWe next define the sequence R0t , . . . , R n t of rewrite systems by setting R 0 t = \u2205 and defining each Rit with 1 \u2264 i \u2264 n induc-\ntively as follows: \u2022 Rit = Ri\u22121t \u222a {li \u21d2 ri} if Li is of the form li \u2248 ri such that\nR1. (Ri\u22121t ) \u2217 6|= \u2206i \u2228 li \u2248 ri, R2. li >t ri, R3. li is irreducible by Ri\u22121t , and R4. s \u2248 ri 6\u2208 (Ri\u22121t )\u2217 for each li \u2248 s \u2208 \u2206i;\n\u2022 Rit = Ri\u22121t in all other cases. Finally, let Rt = Rnt ; we call Rt the model fragment for t, v, \u0393t, and \u2206t. Each clause C\ni = \u0393i \u2192 \u2206i \u2228 li \u2248 ri that satisfies the first condition in the above construction is called generative, and the clause is said to generate the rule li \u21d2 ri in Rt."}, {"heading": "C.1.3 The Properties of the Model Fragment Rt", "text": "Lemma 1. The rewrite system Rt is Church-Rosser.\nProof. To see that Rt is terminating, simply note that, for each rule l\u21d2 r \u2208 Rt, condition R2 ensures l >t r, and that >t is a simplification order.\nTo see that Rt is left-reduced, consider an arbitrary rule l\u21d2 r \u2208 Rt that is added to Rt in step i of the clause sequence. By condition R3, l\u21d2 r is irreducible by Rit. Now consider an arbitrary rule l\u2032 \u21d2 r\u2032 \u2208 Rt that is added to Rt at any step j of the construction where j > i. The definition of the clause order implies l\u2032 \u2248 r\u2032 \u2265t l \u2248 r; since l\u2032 >t r\u2032 and l >t r by condition R2, by the definition of the literal order we have l\u2032 \u2265t l. Since l\u21d2 r \u2208 Rj\u22121t , condition R3 ensures l 6= l\u2032, and so we have l\u2032 >t l; consequently, l\u2032 is not a subterm of l, and thus l is irreducible by Rjt .\nLemma 2. For each 1 \u2264 i \u2264 n and each l 6\u2248 r \u2208 \u2206i \u2228 Li, we have (Ri\u22121t )\u2217 |= l \u2248 r if and only if R\u2217t |= l \u2248 r.\nProof. Consider an arbitrary clause Ci = \u0393i \u2192 \u2206i \u2228 Li and an arbitrary inequality l 6\u2248 r \u2208 \u2206i \u2228 Li. If l \u2248 r \u2208 (Ri\u22121t )\u2217, then Ri\u22121t \u2286 Rt implies l \u2248 r \u2208 R\u2217t , and so we have R\u2217t |= l \u2248 r, as required. Now assume that l \u2248 r 6\u2208 (Ri\u22121t )\u2217. Let l\u2032 and r\u2032 be the normal forms of l and r, respectively, w.r.t.Ri\u22121t . Now consider an arbitrary j with i \u2264 j \u2264 n such that lj \u21d2 rj is generated by Cj . We then have lj \u2248 rj >t l 6\u2248 r, which by the definition of literal order implies lj >t l \u2265t l\u2032 and lj >t r \u2265t r\u2032; since >t is a simplification order, lj is a subterm of neither l\u2032 nor r\u2032. Thus, l\u2032 and r\u2032 are the normal forms of l and r, respectively, w.r.t. Rjt , and so we have l \u2032 \u2248 r\u2032 6\u2208 (Rjt )\u2217; but then, we have l \u2248 r 6\u2208 (R j t ) \u2217, as required.\nLemma 3. For each generative clause \u0393i \u2192 \u2206i \u2228 li \u2248 ri, we have R\u2217t 6|= \u2206i.\nProof. Consider a generative clause Ci = \u0393i \u2192 \u2206i \u2228 li \u2248 ri and a literal L \u2208 \u2206i; condition R1 ensures that (Ri\u22121t )\u2217 6|= L. We next show that (Ri\u22121t )\n\u2217 6|= L. Assume that L is of the form l 6\u2248 r. Since l 6\u2248 r \u2208 \u2206i \u2228 li \u2248 ri, by Lemma 2 we have R\u2217t 6|= L, as required. Assume that L is of the form l \u2248 r with l >t r. We show by induction that, for each j with i \u2264 j \u2264 n, we have (Rjt )\u2217 6|= L.\nTo this end, we assume that (Rj\u22121t ) \u2217 6|= L. If Cj is not generational, then Rjt = R j\u22121 t , and so (R j t ) \u2217 6|= L. Thus, assume that Cj is generational. We consider the following two cases.\n\u2022 lj = l. We have the following two subcases. \u2013 j = i. Condition R4 then ensures r \u2248 ri 6\u2208 (Ri\u22121t )\u2217. Let r\u2032 and r\u2032\u2032 be the normal forms of r and ri, respectively, w.r.t. Ri\u22121t ; we have r\n\u2032 \u2248 r\u2032\u2032 6\u2208 (Ri\u22121t )\u2217. Moreover, l >t r \u2265t r\u2032 and l >t ri \u2265t r\u2032\u2032 hold; since >t is a simplification order, l is a subterm of neither r\u2032 nor r\u2032\u2032; therefore, r\u2032 and r\u2032\u2032 are the normal forms of r and ri, respectively, w.r.t. Rit, and therefore r\u2032 \u2248 r\u2032\u2032 6\u2208 (Rit)\u2217. Finally, since l\u21d2 ri \u2208 Rit, term r\u2032\u2032 is the normal form of l w.r.t. Rit, and so l \u2248 r 6\u2208 (Rit)\u2217. \u2013 j > i. But then, lj \u2248 rj \u2265t li \u2248 ri >t l \u2248 r implies lj = li = l. Furthermore, Ci is generational, so we have li \u21d2 ri \u2208 Rj\u22121t . But then, lj is not irreducible by R j\u22121 t , which contradicts condition R3. \u2022 lj >t l. Let l\u2032 and r\u2032 be the normal forms of l and r, respectively, w.r.t. Rj\u22121t . Then, we have lj >t l \u2265t l\u2032 and lj >t r \u2265t r\u2032; since >t is a simplification order, lj is a subterm of neither l\u2032 nor r\u2032. Thus, l\u2032 and r\u2032 are the normal forms of l and r, respectively, w.r.t. Rjt , and so l \u2032 \u2248 r\u2032 6\u2208 (Rjt )\u2217; hence, l \u2248 r 6\u2208 (R j t ) \u2217 holds.\nLemma 4. Let \u0393\u2192 \u2206 be a clause with \u0393\u2192 \u2206 \u2208\u0302 Nt. Then R\u2217t |= \u2206 holds if i with 1 \u2264 i \u2264 n+ 1 exists such that 1. for each 1 \u2264 j < i, we have R\u2217t |= \u2206j \u2228 Lj , and 2. if i \u2264 n (i.e., i is an index of a clause from Nt), then \u2206i \u2228 Li >t \u2206.\nProof. Assume that \u0393\u2192 \u2206 \u2208\u0302 Nt holds. If \u0393\u2192 \u2206 satisfies condition 1 of Definition 4, then we clearly have R\u2217t |= \u2206. Assume that \u0393\u2192 \u2206 satisfies condition 2 of Definition 4 due to some clause \u0393j \u2192 \u2206j \u2228 Lj \u2208 Nt such that \u0393j \u2286 \u0393 and \u2206j \u222a {Lj} \u2286 \u2206 hold; the latter clearly implies \u2206 \u2265t \u2206j \u2228 Lj . Let i be an integer satisfying this lemma\u2019s assumption. If i = n+ 1, then we clearly have j < i; otherwise, \u2206i \u2228 Li >t \u2206 implies \u2206i \u2228 Li >t \u2206j \u2228 Lj , and so we also have j < i. But then, by the lemma assumption we have R\u2217t |= \u2206j \u2228 Lj , which implies R\u2217t |= \u2206, as required.\nLemma 5. For each clause \u0393\u2192 \u2206 such that \u0393\u2192 \u2206 \u2208\u0302 Sv and \u0393\u03c3t \u2286 \u0393t hold, we have \u0393\u03c3t \u2192 \u2206\u03c3t \u2208\u0302 Nt.\nProof. Assume that \u0393\u2192 \u2206 \u2208\u0302 Sv holds. If \u0393\u2192 \u2206 satisfies condition 1 of Definition 4, then terms s and s\u2032 exist such that s \u2248 s \u2208 \u2206 or {s \u2248 s\u2032, s 6\u2248 s\u2032} \u2286 \u2206; but then, s\u03c3t \u2248 s\u2032\u03c3t \u2208 \u2206\u03c3t or {s\u03c3t \u2248 s\u2032\u03c3t, s\u03c3t 6\u2248 s\u2032\u03c3t} \u2286 \u2206\u03c3t, so \u0393\u03c3t \u2192 \u2206\u03c3t \u2208\u0302 Nt holds. Furthermore, if \u0393\u2192 \u2206 satisfies condition 2 of Definition 4, then clause \u0393\u2032 \u2192 \u2206\u2032 \u2208 Sv exists such that \u0393\u2032 \u2286 \u0393 and \u2206\u2032 \u2286 \u2206; but then, due to \u0393\u2032\u03c3t \u2286 \u0393\u03c3t \u2286 \u0393t, we have that \u0393\u2032\u03c3t \u2192 \u2206\u2032\u03c3t \u2208 Nt holds, and so \u0393\u03c3t \u2192 \u2206\u03c3t \u2208\u0302 Nt holds as well.\nLemma 6. For each \u0393\u2192 \u2206 \u2208 Nt, we have R\u2217t |= \u2206.\nProof. For the sake of a contraction, choose Ci = \u0393i \u2192 \u2206i \u2228 Li as the clause in the sequence of clauses from Appendix C.1.2 with the smallest i such that R\u2217t 6|= \u2206i \u2228 Li; please recall that Li >t \u2206i and that Li = li ./ ri with ./ \u2208 {\u2248, 6\u2248}. Due to our choice of i, condition 1 of Lemma 4 holds for Ci and i. By the definition of Nt, a clause \u0393\u2192 \u2206 \u2228 L \u2208 Sv exists such that\n\u0393\u03c3t = \u0393 i \u2286 \u0393t, \u2206\u03c3t = \u2206i, L\u03c3t = Li, and \u2206 6 v L. (74)\nWe next prove the claim of this lemma by considering the possible forms of Li.\nAssume Li = li \u2248 ri with li = ri. But then, we have R\u2217t |= Li, which contradicts our assumption that R\u2217t 6|= \u2206i \u2228 Li.\nAssume Li = li \u2248 ri with li >t ri. Then, literal L is of the form l \u2248 r such that l\u03c3t \u2248 r\u03c3t = li \u2248 ri. By the definition of>t, we have l v r. We first show that (Ri\u22121t )\u2217 6|= \u2206i \u2228 Li holds; towards this goal, note that, for each equality s1 \u2248 s2 \u2208 \u2206i \u2228 Li, properties R\u2217t 6|= s1 \u2248 s2 and Ri\u22121t \u2286 Rt imply (Ri\u22121t )\u2217 6|= s1 \u2248 s2; and for each inequality s1 6\u2248 s2 \u2208 \u2206i, Lemma 2 and R\u2217t 6|= s1 6\u2248 s2 imply (Ri\u22121t )\u2217 6|= s1 6\u2248 s2. Thus, clause Ci satisfies conditions R1 and R2; however, since R\u2217t 6|= li \u2248 ri, clause Ci is not generational and thus either condition R3 or condition R4 are not satisfied. We next consider both of these possibilities.\n\u2022 Condition R3 does not hold\u2014that is, li is reducible by Ri\u22121t . By the definition of reducibility, a position p and a clause Cj = \u0393j \u2192 \u2206j \u2228 lj \u2248 rj generating the rule lj \u21d2 rj exist such that j < i and li|p = lj . Due to j < i, we have li \u2248 ri \u2265t lj \u2248 rj ; together with lj \u2248 rj >t \u2206j , we have li \u2248 ri >t \u2206j . Lemma 3 ensures R\u2217t 6|= \u2206j , and the definition of Nt ensures that a clause \u0393\u2032 \u2192 \u2206\u2032 \u2228 l\u2032 \u2248 r\u2032 \u2208 Sv exists such that\n\u0393\u2032\u03c3t = \u0393 j \u2286 \u0393t, \u2206\u2032\u03c3t = \u2206j , l\u2032\u03c3t = lj , r\u2032\u03c3t = rj , \u2206\u2032 6 v l\u2032 \u2248 r\u2032, and l\u2032 v r\u2032. (75)\nBy the assumption of Theorem 2, the Eq rule is not applicable to (74) and (75), and so \u0393 \u2227 \u0393\u2032 \u2192 \u2206 \u2228\u2206\u2032 \u2228 l[r\u2032]p \u2248 r \u2208\u0302 Sv . Let \u2206\u2032\u2032 = \u2206i \u2228\u2206j \u2228 li[rj ]p \u2248 ri. Then clearly \u0393\u03c3t \u222a \u0393\u2032\u03c3t \u2286 \u0393t, so Lemma 5 ensures that \u0393i \u2227 \u0393j \u2192 \u2206\u2032\u2032 \u2208\u0302 Nt holds. Set R\u2217t is a congruence, so l\ni[rj ]p \u2248 ri 6\u2208 R\u2217t holds, and therefore R\u2217t 6|= \u2206\u2032\u2032 holds. Finally, >t is a simplification order, which ensures li \u2248 ri >t li[rj ]p \u2248 ri; together with li \u2248 ri >t \u2206i and li \u2248 ri >t \u2206j , we have li \u2248 ri >t \u2206\u2032\u2032. But then, Lemma 4 implies R\u2217t |= \u2206\u2032\u2032, which is a contradiction. \u2022 Condition R4 does not hold. Then, some term s exists such that li \u2248 s \u2208 \u2206i and s \u2248 ri \u2208 (Ri\u22121t )\u2217. Due to Ri\u22121t \u2286 Rt, we have s \u2248 ri \u2208 R\u2217t , and so R\u2217t 6|= s 6\u2248 ri. Furthermore, \u2206 \u2228 L is of the form \u2206\u2032 \u2228 l \u2248 r \u2228 l\u2032 \u2248 r\u2032 such that\nl\u03c3t = l i, r\u03c3t = s, l \u2032\u03c3t = l i, and r\u2032\u03c3t = ri. (76)\nBut then, we clearly have l\u2032 = l. By the assumption of Theorem 2, the Factor rule is not applicable to \u0393\u2192 \u2206 \u2228 L, and so we have \u0393\u2192 \u2206\u2032 \u2228 r 6\u2248 r\u2032 \u2228 l\u2032 \u2248 r\u2032 \u2208\u0302 Sv . Let \u2206\u2032\u2032 = \u2206\u2032\u03c3t \u2228 s 6\u2248 ri \u2228 li \u2248 ri. But then, \u0393\u03c3t \u2286 \u0393t and Lemma 5 ensure that \u0393i \u2192 \u2206\u2032\u2032 \u2208\u0302 Nt holds. By all the previous observations, we have R\u2217t 6|= \u2206\u2032\u2032. Moreover, li >t ri and li >t s imply li \u2248 ri >t s \u2248 ri; thus, \u2206i \u2228 li \u2248 ri >t \u2206\u2032\u2032 holds. But then, Lemma 4 implies R\u2217t |= \u2206\u2032\u2032, which is a contradiction.\nAssume Li = li 6\u2248 ri with li = ri. Then, literal L is of the form l 6\u2248 r such that l\u03c3t 6\u2248 r\u03c3t = li 6\u2248 ri. But then, li = ri implies l = r. By the assumption of Theorem 2, the Ineq rule is not applicable to clause \u0393\u2192 \u2206 \u2228 L, and so we have \u0393\u2192 \u2206 \u2208\u0302 Sv . Since \u0393\u03c3t \u2286 \u0393t, by Lemma 5 we have \u0393i \u2192 \u2206i \u2208\u0302 Nt. Clearly, \u2206i \u2228 li 6\u2248 ri >t \u2206i, and so Lemma 4 implies R\u2217t |= \u2206i, which is a contradiction.\nAssume Li = li 6\u2248 ri with li >t ri. Lemma 2 ensures (Ri\u22121t )\u2217 6|= li 6\u2248 ri; hence, li is reducible by Ri\u22121t so, by the definition of reducibility, a position p and a generative clause Cj = \u0393j \u2192 \u2206j \u2228 lj \u2248 rj exist such that j < i and li|p = lj . Due to j < i, we have li 6\u2248 ri >t lj \u2248 rj >t \u2206j . Lemma 3 ensures R\u2217t 6|= \u2206j , and the definition of Nt ensures that a clause \u0393\u2032 \u2192 \u2206\u2032 \u2228 l\u2032 \u2248 r\u2032 \u2208 Sv exists satisfying (75), as in the first case. By the assumption of Theorem 2, the Eq rule is not applicable to clauses (74) and (75), and so \u0393 \u2227 \u0393\u2032 \u2192 \u2206 \u2228\u2206\u2032 \u2228 l[r\u2032]p 6\u2248 r \u2208\u0302 Sv holds. Let \u2206\u2032\u2032 = \u2206i \u2228\u2206j \u2228 li[rj ]p 6\u2248 ri. We clearly have \u0393\u03c3t \u222a \u0393\u2032\u03c3t \u2286 \u0393t, so by Lemma 5 we have \u0393i \u2227 \u0393j \u2192 \u2206\u2032\u2032 \u2208\u0302 Nt. Since R\u2217t is a congruence, we have R\u2217t 6|= li[lj ]p 6\u2248 ri, and therefore R\u2217t 6|= \u2206\u2032\u2032 holds. Finally, >t is a simplification order, so li 6\u2248 ri >t li[lj ]p; together with li \u2248 ri >t \u2206i and li \u2248 ri >t \u2206j , we have li \u2248 ri >t \u2206\u2032\u2032. But then, Lemma 4 implies R\u2217t |= \u2206\u2032\u2032, which is a contradiction.\nLemma 7. For each clause \u0393\u2192 \u2206 with \u0393\u2192 \u2206 \u2208\u0302 Nt, we have R\u2217t |= \u2206.\nProof. Apply Lemma 4 for i = n+ 1 and Lemma 6.\nLemma 8. For each generative clause \u0393i \u2192 \u2206i \u2228 li \u2248 ri, disjunction \u2206i does not contain a literal of the form s 6\u2248 s.\nProof. For the sake of a contradiction, let us assume that clause Ci = \u0393i \u2192 \u2206i \u2228 li \u2248 ri \u2208 Nt is generative and that s 6\u2248 s \u2208 \u2206i holds for some term s. By the definition of Nt, a clause \u0393\u2032 \u2192 \u2206\u2032 \u2228 s\u2032 6\u2248 s\u2032 \u2228 l\u2032 \u2248 r\u2032 \u2208 Sv exists such that\n\u0393\u2032\u03c3t = \u0393 i \u2286 \u0393t, \u2206\u2032\u03c3t \u222a {s\u2032\u03c3t 6\u2248 s\u2032\u03c3t} = \u2206i, s\u2032\u03c3t = s, l\u2032\u03c3t = li, and r\u2032\u03c3t = ri. (77)\nBy assumption of Theorem 2, the Ineq rule is not applicable to this clause, and so we have \u0393\u2032 \u2192 \u2206\u2032 \u2228 l\u2032 \u2248 r\u2032 \u2208\u0302 Sv . Thus, we have \u0393i \u2192 \u2206\u2032\u03c3t \u2228 li \u2248 ri \u2208\u0302 Nt, and so \u0393\u2192 \u2206 \u2208 Nt holds for some \u0393 \u2286 \u0393i and some \u2206 ( \u2206i \u222a {li \u2248 ri}. Now Lemma 3 implies R\u2217t 6|= \u2206i; moreover, by condition R1, we have (Ri\u22121t )\u2217 6|= \u2206i \u2228 li \u2248 ri. However, by Lemma 6 we have R\u2217t |= \u0393\u2192 \u2206. Now let j be the index of clause \u0393\u2192 \u2206 in the sequence of clauses from Appendix C.1.2; due to (Rjt ) \u2217 \u2286 (Ri\u22121t )\u2217 and Lemma 2, we have (R j t ) \u2217 |= \u0393\u2192 \u2206. Since j < i, by the same argument we have (Ri\u22121t )\u2217 |= \u0393\u2192 \u2206. But then, \u2206 \u2286 \u2206i \u2228 li \u2248 ri implies (Ri\u22121t )\u2217 |= \u2206i \u2228 li \u2248 ri, which is a contradiction.\nLemma 9. R\u2217t 6|= \u0393t \u2192 \u2206t.\nProof. For R\u2217t |= \u0393t, note that condition L2 ensures \u0393t \u2192 A \u2208\u0302 Nt, and so Lemma 7 ensures R\u2217t |= A for each atom A \u2208 \u0393t. For R\u2217t 6|= \u2206t, assume for the sake of a contradiction that an atom A \u2208 \u2206t exists such that R\u2217t |= A. Then, a generative clause Ci = \u0393i \u2192 \u2206i \u2228 li \u2248 ri \u2208 Nt and a position p exist such that A|p = li; let \u2206 = \u2206i \u2228 li \u2248 ri. Since >t is a simplification order and li >t ri, we have A \u2265t li \u2248 ri; but then, since li \u2248 ri >t \u2206i, we have A \u2265t \u2206. We next consider an arbitrary literal l ./ r \u2208 \u2206 with ./ \u2208 {\u2248, 6\u2248} and l \u2265t r; by the observations made thus far, A \u2265t l ./ r holds. By condition O2, one of the following holds.\n1. l \u2208 {t, t\u2032}. Moreover, since l ./ r is obtained by grounding a context literal, both l and r can be of the form f(t) or t\u2032. Together with l \u2265t r, we have l = r = t\u2032. Now if l ./ r is t\u2032 \u2248 t\u2032, then clause Ci is not generative due to condition R1. Hence, the only remaining possibility is for l ./ r to be of the form t\u2032 6\u2248 t\u2032; but then, clause Ci is not generative by Lemma 8. Consequently, in either case we get a contradiction.\n2. l \u2248 r \u2208 \u2206t where r = \u2118. Thus, the second point above holds for arbitrary l ./ r \u2208 \u2206, and therefore we have \u2206 \u2286 \u2206t. But then, \u0393i \u2286 \u0393t implies that \u0393t \u2192 \u2206t \u2208\u0302 Nt holds, which contradicts condition L1.\nC.2 Interpreting the Ontology O We now combine the rewrite systems Rt constructed in Appendix C.1 into a single rewrite system R, and we then show that R\u2217 satisfies R\u2217 |= O and R\u2217 6|= \u0393Q \u2192 \u2206Q."}, {"heading": "C.2.1 Unfolding the Context Structure", "text": "We construct R by a partial induction over the terms in T . We define several partial functions: function X maps a term t to a context Xt \u2208 V; functions \u0393 and \u2206 assign to a term t a conjunction \u0393t and a disjunction \u2206t, respectively, of atoms; and function R maps each term into a model fragment Rt for t, Xt, \u0393t, and \u2206t. M1. For the base case, we consider the constant c.\nXc = q (78) \u0393c = \u0393Q\u03c3c (79) \u2206c = \u2206Q\u03c3c (80) Rc = the model fragment for c, q,\u0393c, and \u2206c (81)\nM2. For the inductive step, assume that Xt\u2032 has already been defined, and consider an arbitrary function symbol f \u2208 F such that f(t\u2032) is irreducible by Rt\u2032 . Let u = Xt\u2032 and t = f(t\u2032). We have two possibilities. M2.a. Term t occurs in Rt\u2032 . Then, term t = f(t\u2032) was generated in Rt\u2032 by some ground clause C = \u0393\u2192 \u2206 \u2228 L \u2208 Nt\u2032\nsuch that L >t \u2206 and f(t\u2032) occurs in L. By the definition of Nt, then a clause C \u2032 = \u0393\u2032 \u2192 \u2206\u2032 \u2228 L\u2032 \u2208 Su exists such that C = C \u2032\u03c3t\u2032 and L\u2032 contains f(x); moreover, L >t\u2032 \u2206 implies \u2206\u2032 6 u L\u2032. The Succ and Core rules are not applicable to D, so we can choose a context v \u2208 V such that \u3008u, v, f\u3009 \u2208 E and A\u2192 A \u2208\u0302 Sv for each A \u2208 K2, where K2 is as in the Succ rule. We define the following:\nXt = v (82) \u0393t = R \u2217 t\u2032 \u2229 Sut (83) \u2206t = Prt \\R\u2217t\u2032 (84) Rt = the model fragment for t, v,\u0393t, and \u2206t (85)\nM2.b. Term t does not occur in Rt\u2032 . Then, let Rt = {t\u21d2 c}, and we do not define any other functions for t. Finally, let R be the rewrite system defined by R = \u22c3 tRt. Lemma 10. The model fragments Rc and Rt constructed in lines (81) and (85) satisfy conditions L1 through L3 in Appendix C.1.\nProof. The proof is by induction on the structure of terms t \u2208 dom(X). For t = c, conditions L1 through L3 hold directly from conditions C1 through C3 of Theorem 2. We next assume that the lemma holds for some term t\u2032 \u2208 dom(X), and we consider an arbitrary term t of the form t = f(t\u2032); let u = Xt\u2032 and v = Xt. Condition L2 holds because \u2206t = Prt \\R\u2217t\u2032 due to (84), and hence \u2206t \u2286 Prt. Before proceeding, note that terms t and t\u2032 are irreducible by Rt\u2032 due to condition M2; but then, since \u0393t \u2286 R\u2217t\u2032 holds by (83), each each atom Ai \u2208 Rt\u2032 is generated by clause satisfying (86) (where subscript i does not necessarily indicate the position of the clause in sequence of clauses from Appendix C.1.2). By the definition of Nt\u2032 , then there exists a clause satisfying (87).\n\u0393i \u2192 \u2206i \u2228Ai \u2208 Nt\u2032 with Ai >t \u2206i (86) \u0393\u2032i \u2192 \u2206\u2032i \u2228A\u2032i \u2208 Su \u0393i = \u0393\u2032i\u03c3t\u2032 , \u2206i = \u2206\u2032i\u03c3t\u2032 , Ai = A\u2032i\u03c3t\u2032 , and \u2206\u2032i 6 u A\u2032i (87)\nFor condition L3, consider an arbitrary atom Ai \u2208 \u0393t, let (86) be the clause that generates Ai in Rt\u2032 , and let (87) be the corresponding nonground clause. Since Ai \u2208 Sut, atom A\u2032i is of the form A\u2032\u2032i \u03c3, where \u03c3 is the substitution from the Succ rule; but then, A\u2032\u2032i \u2208 K2, where K2 is as specified in the Succ rule. In condition M2.a we chose v so that the Succ rule is satisfied, and therefore A\u2032\u2032i \u2192 A\u2032\u2032i \u2208\u0302 Sv; but then, since A\u2032\u2032i \u03c3t = Ai, we have Ai \u2192 Ai \u2208\u0302 Nt, as required for condition L3.\nTo prove that condition L1 holds as well, assume for the sake of a contradiction that \u0393t \u2192 \u2206t \u2208\u0302 Nt holds. We have \u2206t \u2286 Prt due to (84). Therefore, due to condition 2 of Definition 4, set Nt contains a clause\nm\u2227 i=1 Ai \u2192 m+n\u2228 i=m+1 Ai with {Ai | 1 \u2264 i \u2264 m } \u2286 \u0393t and {Ai | m+ 1 \u2264 i \u2264 m+ n } \u2286 \u2206t \u2286 Prt. (88)\nBy the definition of Nt, set Sv contains a clause m\u2227 i=1 A\u2032i \u2192 m+n\u2228 i=m+1 A\u2032i where Ai = A \u2032 i\u03c3t for 1 \u2264 i \u2264 m+ n and A\u2032i \u2208 Pr(O) for m+ 1 \u2264 i \u2264 m+ n. (89)\nNow eachAi with 1 \u2264 i \u2264 m is generated by a ground clause (86), and the latter is obtained from the corresponding nonground clause (87). The Pred rule is not applicable to (87) and (89) so (90) holds; together with Lemma 5, this ensures (91).\nm\u2227 i=1 \u0393\u2032i \u2192 m\u2228 i=1 \u2206\u2032i \u2228 m+n\u2228 i=m+1 A\u2032i\u03c3 \u2208\u0302 Su for \u03c3 = {x 7\u2192 f(x), y 7\u2192 x} (90)\nm\u2227 i=1 \u0393i \u2192 m\u2228 i=1 \u2206i \u2228 m+n\u2228 i=m+1 Ai \u2208\u0302 Nt\u2032 (91)\nBy Lemma 3, we have R\u2217t\u2032 6|= \u2206i; and (84) ensures that R\u2217t\u2032 6|= \u2206t, and so R\u2217t\u2032 6|= Ai for each m+ 1 \u2264 i \u2264 m+ n; however, this contradicts (91) and Lemma 7."}, {"heading": "C.2.2 Termination, Confluence, and Compatibility", "text": "Lemma 11. The rewrite system R is Church-Rosser.\nProof. We show that R is terminating and left-reduced, and thus Church-Rosser. In the proof of the former, we use a total simplification order B on all ground F- and P-terms defined as follows. We extend the precedence m from Definition 3 to all F- and P-symbols in an arbitrary way, but ensuring that constant \u2118 is smallest in the order; then, let B be a lexicographic path order (Baader and Nipkow 1998) over such m. It is well known that such B is a simplification order, and that it satisfies the following properties for each F-term t with predecessor t\u2032 (if one exists), all function symbols f, g \u2208 F , and each P-term A:\n\u2022 f(t)B tB t\u2032, \u2022 f m g implies f(t)B g(t), and \u2022 AB \u2118.\nThus, conditions 1 and 2 of Definition 3 and the manner in which context orders are grounded in Appendix C.1.1 clearly ensure that, for each F-term t \u2208 dom(X) and for all terms s1 and s2 from the F-neighbourhood of t with s1 >t s2, we have s1 B s2.\nWe next show that R is terminating by arguing that each rule in R is embedded in B. To this end, consider an arbitrary rule l\u21d2 r \u2208 R. Clearly, a term t \u2208 dom(R) exists such that l\u21d2 r \u2208 Rt. This rule is obtained from a head l \u2248 r of a clause in Nt, and condition R2 of the definition of Rt ensures that l >t r. Moreover, l \u2248 r is obtained by grounding a context literal with \u03c3t, so we have the following possible forms of l \u2248 r.\n\u2022 Terms l and r are both from the F-neighbourhood of t. Then, l >t r implies l B r. \u2022 We have l \u2248 r = A \u2248 \u2118 for A a P-term. Then, AB \u2118 since \u2118 is smallest in m.\nWe next show that R is left-reduced. For the sake of a contradiction, assume that a rule l\u21d2 r \u2208 R exists such that l is reducible by R\u2032 = R \\ {l\u21d2 r}. Let p be the \u2018deepest\u2019 position at which some rule in R\u2032 reduces l (i.e., no rule in R\u2032 reduces l at position below p), and let l\u2032 \u21d2 r\u2032 \u2208 R\u2032 be the rule that reduces l at position p; thus, l\u2032 = l|p. By the definition of R, we have l\u2032 \u21d2 r\u2032 \u2208 Rt where t can be as follows.\n\u2022 Term t is handled in condition M2.a. Then l\u2032 \u21d2 r\u2032 is generated by an equality l\u2032 \u2248 r\u2032 in the head of a generative clause, and so l\u2032 is of the form f(t). Thus, f(t) is reducible by Rt, which contradicts condition M2 from the construction of R. \u2022 Term t is handled in condition M2.b. Then l\u2032 = t; moreover,R\u2032 does not contain t by the construction ofR, which contradicts the assumption that l\u2032 \u21d2 r\u2032 \u2208 R\u2032.\nLemma 12. For each term t, each f \u2208 F , and each atom A \u2208 Sut \u222a Prf(t) such that A \u2208 R\u2217 and all F-terms in A are irreducible by R, we have A \u2208 R\u2217t .\nProof. Let t be a term, let f \u2208 F be a function symbol, and let A \u2208 Sut \u222a Prf(t) be an atom such that all F-terms in A are irreducible by R; the latter ensures A\u21d2\u2118 \u2208 R. We next consider the possible forms of A.\nAssume A \u2208 Sut. By the definition of Sut in (72) and the fact that Su(O) contains only atoms of the form B(x), S(x, y), and S(y, x), atom A can be of the form B(t), S(t, t\u2032), or S(t\u2032, t), for t\u2032 the predecessor of t (if one exists). By the form of the generative clauses, we clearly have A \u2208 R\u2217t or A \u2208 R\u2217t\u2032 . Now assume A \u2208 R\u2217t\u2032 . Due to A \u2208 Sut and the definition of \u0393t in (83), we have A \u2208 \u0393t. Lemma 9 ensures that R\u2217t 6|= \u0393t \u2192 \u2206t. But then, we have A \u2208 R\u2217t , as required.\nAssumeA \u2208 Prf(t). By the definition of Prf(t) in (73) and the fact that Pr(O) contains only atoms of the formB(y), S(y, x), and S(x, y), atom A can be of the form B(t), S(t, f(t)), or S(f(t), t). By the form of the generative clauses, we clearly have A \u2208 R\u2217t orA \u2208 R\u2217f(t). Assume for the sake of a contradiction thatA 6\u2208 R \u2217 t , butA \u2208 R\u2217f(t). Due toA \u2208 Prf(t) and the definition of \u2206f(t) in (84), we have A \u2208 \u2206f(t); due to Lemma 9, we have R\u2217f(t) 6|= \u0393f(t) \u2192 \u2206f(t); therefore, we have A 6\u2208 R \u2217 f(t), which is a contradiction.\nLemma 13. Let s1 and s2 be DL-terms, and let \u03c4 be a substitution irreducible byR such that s1\u03c4 and s2\u03c4 are ground and each \u03c4(zi) (if defined) is in the F-neighbourhood of \u03c4(x). Then, for ./ \u2208 {\u2248, 6\u2248}, if R\u2217\u03c4(x) |= s1\u03c4 ./ s2\u03c4 , then R \u2217 |= s1\u03c4 ./ s2\u03c4 .\nProof. Let s1 and s2 and \u03c4 be as stated above, let t = \u03c4(x), and let t\u2032 be the predecessor of t (if one exists). Since t is irreducible by R, rewrite system Rt has been defined in Appendix C.2.1. We next consider the possible forms of ./.\n\u2022 Assume ./ = \u2248. But then, Rt \u2286 R and R\u2217t |= s1\u03c4 \u2248 s2\u03c4 imply R\u2217 |= s1\u03c4 \u2248 s2\u03c4 . \u2022 Assume ./ = 6\u2248. Let s\u20321 and s\u20322 be the normal forms of s1\u03c4 and s2\u03c4 , respectively, w.r.t. Rt. Due to the shape of DL-literals, s1 and s2 can be of the form f(x) or zi; therefore, s1\u03c4 and s2\u03c4 are of the form f(t) or t\u2032. Term t is irreducible by R, and thus t\u2032 is irreducible by R as well. Furthermore, due to the shape of context terms, the only rewrite system where f(t) could occur on the left-hand side of a rewrite rule is Rt. Consequently, f(t) is irreducible by R as well. But then, s\u20321 and s \u2032 2 are the\nnormal forms of s1\u03c4 and s2\u03c4 , respectively, w.r.t. R; thus, R\u2217 |= s\u20321 6\u2248 s\u20322, and thus R\u2217 |= s1\u03c4 6\u2248 s2\u03c4 holds, as required."}, {"heading": "C.2.3 The Completeness Claim", "text": "Lemma 14. For each DL-clause \u0393\u2192 \u2206 \u2208 O, we have R\u2217 |= \u0393\u2192 \u2206.\nProof. Consider an arbitrary DL-clause \u0393\u2192 \u2206 \u2208 O of the following form:\u2227n i=1Ai \u2192 \u2206 (92)\nLet \u03c4 \u2032 be an arbitrary substitution such that \u0393\u03c4 \u2032 \u2192 \u2206\u03c4 \u2032 is ground, and let \u03c4 be the substitution obtained from \u03c4 \u2032 by replacing each ground term with its normal form w.r.t. R. Since R\u2217 is a congruence, we have R\u2217 |= \u0393\u03c4 \u2032 \u2192 \u2206\u03c4 \u2032 if and only if R\u2217 |= \u0393\u03c4 \u2192 \u2206\u03c4 . We next assume that R\u2217 |= \u0393\u03c4 , and we show that R\u2217 |= \u2206\u03c4 holds as well.\nConsider an arbitrary atom Ai \u2208 \u0393. By the definition of DL-clauses, Ai is of the form B(x), S(x, zj), or S(zj , x). Substitution \u03c4 is irreducible by R, and so all F-terms in Ai\u03c4 are irreducible by R; but then, Ai\u03c4 \u2208 R\u2217 clearly implies Ai\u03c4 \u21d2\u2118 \u2208 R. Each such rule is obtained from a generative clause soAi\u03c4 is of the formB(t), S(t, f(t)), S(f(t), t), S(t, t\u2032), or S(t\u2032, t), where t = \u03c4(x) and t\u2032 is the predecessor of t (if it exists). We next prove that Ai\u03c4 \u2208 Sut \u222a Prf(t) holds by considering the possible forms of Ai.\n\u2022 Ai = B(x), so Ai\u03c4 = B(t). Then, we have B(x) \u2208 Su(O), which implies that B(t) \u2208 Sut holds. \u2022 Ai = S(x, zj), soAi\u03c4 is of the form S(t, t\u2032) or S(t, f(t)). Then, we have S(x, y) \u2208 Su(O), which implies that S(t, t\u2032) \u2208 Sut\nholds; moreover, we have S(y, x) \u2208 Pr(O), which implies that S(t, f(t)) \u2208 Prf(t) holds.\n\u2022 Ai = S(zj , x), soAi\u03c4 is of the form S(t\u2032, t) or S(f(t), t). Then, we have S(y, x) \u2208 Su(O), which implies that S(t\u2032, t) \u2208 Sut holds; moreover, we have S(x, y) \u2208 Pr(O), which implies that S(f(t), t) \u2208 Prf(t) holds.\nLemma 12 then implies Ai\u03c4 \u2208 Rt, and so Nt contains a generative clause of the form (93). Now let v = Xt; by the definition of Nt, set Sv contains a clause of the form (94).\n\u0393i \u2192 \u2206i \u2228Ai with Ai >t \u2206i and \u0393i \u2286 \u0393t (93) \u0393\u2032i \u2192 \u2206\u2032i \u2228A\u2032i with \u2206\u2032i 6 vA\u2032i and \u0393\u2032i\u03c3t = \u0393i, \u2206\u2032i\u03c3t = \u2206i, and A\u2032i\u03c3t = Ai (94)\nThe Hyper rule is not applicable to (92) and (94), and therefore (95) holds, where \u03c3 is the substitution obtained from \u03c4 by replacing each occurrence of t (possibly nested in another term) with x. Finally, Lemma 5 ensures that (96) holds as well.\nn\u2227 i=1 \u0393\u2032i \u2192 \u2206\u03c3 \u2228 n\u2228 i=1 \u2206\u2032i \u2208\u0302 Sv (95)\nn\u2227 i=1 \u0393i \u2192 \u2206\u03c4 \u2228 n\u2228 i=1 \u2206i \u2208\u0302 Nt (96)\nNow (96) and Lemma 7 imply R\u2217t |= \u2206\u03c4 \u2228 \u2228n i=1 \u2206i, but Lemma 3 implies R \u2217 t 6|= \u2206i; therefore, we have R\u2217t |= \u2206\u03c4 . Finally, Lemma 13 ensures R\u2217 |= \u2206\u03c4 , as required.\nLemma 15. R\u2217 6|= \u0393Q \u2192 \u2206Q.\nProof. The claim clearly follows from R\u2217 6|= \u0393c \u2192 \u2206c. Note that Lemma 9 ensures R\u2217c 6|= \u0393c \u2192 \u2206c; thus, R\u2217c |= \u0393c and R\u2217c 6|= \u2206c. The former observation and Lemma 13 ensure that R\u2217 |= \u0393c holds. Moreover, for each atom B(x) \u2208 \u2206Q, Definition 2 ensures B(y) \u2208 Pr(O); thus, for each f \u2208 F , we have B(c) \u2208 Prf(c), and so the contrapositive of Lemma 12 ensures R\u2217 6|= B(c). Thus, R\u2217 6|= \u2206c holds, as required.\nD Proof of Proposition 2 Proposition 2. For each expansion strategy that introduces at most exponentially many contexts, algorithm A1\u2013A4 runs in worst-case exponential time.\nProof. The number \u2118 of context clauses that can be generated using the symbols in O is at most exponential in the size of O, and the number m of clauses participating in each inference is linear in the size of O. Hence, with k contexts, the number of inferences is bounded by (k \u00b7 \u2118)m; if k is at most exponential in the size of O, the number of inferences is exponential as well. Thus, if at most exponentially many contexts are introduced, our algorithm runs in exponential time.\nE Proof of Proposition 3 Proposition 3. For ELH ontologies and queries of the form B1(x)\u2192 B2(x), algorithm A1\u2013A4 runs in polynomial time with either the cautious or the eager strategy; and with the cautious strategy and the Hyper rule applied eagerly, the inferences in step A3 correspond directly to the inferences of the ELH calculus by Baader, Brandt, and Lutz (2005).\nProof. Consider an ELH ontology that is transformed into a setO of DL-clauses as specified in Section 2, and consider a query of the form B1(x)\u2192 B2(x). Due to the form of the query, the core of q is initialised to B1(x).\nWe first consider applying algorithm A1\u2013A4 to O with the cautious strategy and the eager application of the Hyper rule. By induction on the application of the rules from Table 2, we next show that each context clause derived by the rules is of the form (97)\u2013(101) and that the core of each context is of the form B(x).\n> \u2192 B(x) (97) > \u2192 S(x, f(x)) (98) > \u2192 B(f(x)) (99)\nS(y, x)\u2192 B(y) (100) S1(y, x)\u2192 S2(y, x) (101)\nIn particular, in step A3 we can perform the following inferences, with the specified correspondence to the completion rules CR1\u2013CR4 and CR10 by Baader, Brandt, and Lutz (2005).\n\u2022 The core of each context is of the form B(x), so the Core rule introduces a clause of the form form (97). This corresponds to way in which Baader, Brandt, and Lutz (2005) initialise their mappings.\n\u2022 The Hyper rule can be applied to a DL-clause of type DL1. All other clauses participating in the inference are of the form (97), so the result is of the form (97). Such an inference corresponds to the completion rules CR1 or CR2.\n\u2022 The Hyper rule can be applied to a DL-clause of type DL2. The other clause participating in the inference is of the form (97), so the result is of the form (98) or (99). Moreover, function symbol f occurs inO in exactly one pair of clauses DL2, and the Hyper rule is applied eagerly; thus, whenever f occurs in a context in a clause of the form (98), it also occurs in a clause of the form (99). Now the Succ rule can be applied to the function symbol f , in which case the cautious strategy thus returns a context whose core is of the form B(x). All of these inferences correspond to the completion rule CR3.\n\u2022 The Hyper rule can be applied to a DL-clause of type DL3. The two other clauses participating in the inference are of the form (100) and (97), so the result is of the form (100); the Pred rule can then be applied to the latter clause, producing a clause of the form (97). Such a pair of inferences corresponds to the completion rule CR4.\n\u2022 The Hyper rule can be applied to a DL-clause of type DL5. The other clause participating in the inference is of the form (100), so the result is of the form (100) as well; the Pred rule can then be applied to the latter clause, producing a clause of the form (98). Such a pair of inferences corresponds to the completion rule CR10.\nOne can show in an analogous way that each inference of the calculus by Baader, Brandt, and Lutz (2005) corresponds to one or more inferences of our calculus. Furthermore, it is clear that our algorithm runs in polynomial time.\nWe next consider applying algorithm A1\u2013A4 to O with the eager strategy. One can show that the core of each context is of the form A(x), R(y, x), or A(x) \u2227R(y, x), and that context can contain clauses of the form (97)\u2013(103).\n> \u2192 S2(y, x) (102) > \u2192 B(y) (103)\nThe proof is analogous to the case of the cautions strategy (without correspondence to the completion rules) so we omit the details for the sake of brevity. The only minor difference is that, if an application of the the Pred to contexts u and v introduces a clause of the form (98) in u, then the Succ rule does not become applicable to u since the precondition of the Succ rule is still satisfied by v. Thus, the Succ rule never introduces contexts whose cores contain conjunctions of binary atoms. Thus, if O contains k1 unary and k2 binary predicates, the number of contexts is bounded by O(k1 \u00b7 k2), and each context can contain at most k1 + k2 + k1 \u00b7 k2 clauses. All rules can be applied in polynomial time, so the algorithm runs in polynomial time."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "Consequence-based calculi are a family of reasoning algorithms for description logics (DLs), and they combine hypertableau and resolution in a way that often achieves excellent performance in practice. Up to now, however, they were proposed for either Horn DLs (which do not support disjunction), or for DLs without counting quantifiers. In this paper we present a novel consequence-based calculus for SRIQ\u2014 a rich DL that supports both features. This extension is nontrivial since the intermediate consequences that need to be derived during reasoning cannot be captured using DLs themselves. The results of our preliminary performance evaluation suggest the feasibility of our approach in practice.", "creator": "TeX"}}}