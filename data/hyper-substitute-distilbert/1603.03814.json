{"id": "1603.03814", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Mar-2016", "title": "Solving MaxSAT by Successive Calls to a SAT Solver", "abstract": "the decision satisfiability ( maxsat ) parameter implementing the action of using a tree assignment typically maximizes the set of inclusive clauses of functions given boolean formula in conjunctive normal form ( convex ). reliable exact solvers for trees have been developed during recent developments, finding findings of work when presented in another individually - edited sat format. algorithms for maxsat generally fall into two categories : ( 1 ) vertices and bucket lists in ( 2 ) algorithms that produce topological calls to set sat solver ( sat - based ), see much paper in discussion. in practical problems, the - theoretical logic for been shown little remains economically efficient. last paper provides an experimental perspective to investigate the reliability of recent sat - based and branch and boundary implementations approaching the benchmarks of the weighted hierarchy.", "histories": [["v1", "Fri, 11 Mar 2016 22:54:28 GMT  (198kb,D)", "http://arxiv.org/abs/1603.03814v1", "Survey, 46 pages"]], "COMMENTS": "Survey, 46 pages", "reviews": [], "SUBJECTS": "cs.AI cs.CC cs.LO", "authors": ["mohamed el halaby"], "accepted": false, "id": "1603.03814"}, "pdf": {"name": "1603.03814.pdf", "metadata": {"source": "CRF", "title": "Solving MaxSAT by Successive Calls to a SAT Solver", "authors": ["Mohamed El Halaby"], "emails": ["halaby@sci.cu.edu.eg"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 3.\n03 81\n4v 1\n[ cs\n.A I]\n1 1\nM ar\n2 01\nContents"}, {"heading": "1 Introduction and Preliminaries 4", "text": ""}, {"heading": "2 Linear Search Algorithms 5", "text": ""}, {"heading": "3 Binary Search-based Algorithms 7", "text": ""}, {"heading": "4 Core-guided Algorithms 12", "text": "4.1 Fu and Malik\u2019s algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 4.2 WPM1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 4.3 Improved WPM1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 4.4 WPM2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 4.5 WMSU1-ROR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 4.6 WMSU3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 4.7 WMSU4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25"}, {"heading": "5 Core-guided Binary Search Algorithms 26", "text": ""}, {"heading": "6 Portfolio MaxSAT Techniques 31", "text": ""}, {"heading": "7 Translating Pseudo-Boolean Constraints into CNF 31", "text": "7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 7.2 Encoding method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 7.3 Complexity of the encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n7.3.1 Polynomial cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 7.3.2 Exponential cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n7.4 Other encoding techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34"}, {"heading": "8 Experimental Investigation 35", "text": "8.1 Solvers descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 8.2 Benchmarks descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 8.3 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n8.3.1 Random category . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 8.3.2 Crafted category . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 8.3.3 Industrial category . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n9 Acknowledgments 42\nList of Algorithms\n1 LinearUNSAT(\u03c6) Linear search UNSAT-based algorithm for solving WPMaxSAT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2 LinearSAT(\u03c6) Linear search SAT-based algorithm for solving WPMaxSAT. . 6 3 BinS-WPMaxSAT(\u03c6) Binary search based algorithm for solving WPMaxSAT. 8 4 BinLin-WPMaxSAT(\u03c6) Alternating binary and linear searches for solving WPMaxSAT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 5 BitBased-WPMaxSAT(\u03c6) A bit-based algorithm for solving WPMaxSAT. . . 11 6 Fu&Malik(\u03c6) Fu and Malik\u2019s algorithm for solving PMaxSAT. . . . . . . . . 13 7 WPM1(\u03c6) The WPM1 algorithm for WPMaxSAT. . . . . . . . . . . . . . . . 14 8 ImprovedWPM1(\u03c6) The stratified approach for WPM1 algorithm. . . . . . . 16 9 WPM2(\u03c6) The WPM2 algorithm for WPMaxSAT . . . . . . . . . . . . . . . 18 10 NewBound(AL,B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 11 WMSU1-ROR(\u03c6) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 12 Hard((Ci, wi), R) Determines if a clause is hard or not . . . . . . . . . . . . . 23 13 ROR((Ci, wi), R) Determines if a clause is hard or not or if its ancestors are used at most once . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 14 WMSU3(\u03c6) The WMSU3 algorithm for WPMaxSAT. . . . . . . . . . . . . . 24 15 WMSU4(\u03c6) The WMSU4 algorithm for WPMaxSAT. . . . . . . . . . . . . . 25 16 CoreGuided-BS(\u03c6) Core-guided binary search algorithm for solving WPMaxSAT. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 17 DisjointCoreGuided-BS(\u03c6) Core-guided binary search extended with disjoint\ncores for solving WPMaxSAT. . . . . . . . . . . . . . . . . . . . . . . . . . . 29"}, {"heading": "1 Introduction and Preliminaries", "text": "A Boolean variable x can take one of two possible values 0 (false) or 1 (true). A literal l is a variable x or its negation \u00acx. A clause is a disjunction of literals, i.e., \u2228n i=1 li. A CNF formula is a conjunction of clauses. Formally, a CNF formula \u03c6 composed of k clauses, where each clause Ci is composed of mi is defined as F = \u2227k i=1 Ci where Ci = \u2228mi j=1 li,j .\nIn this paper, a set of clauses {C1, C2, . . . , Ck} is referred to as a Boolean formula. A truth assignment satisfies a Boolean formula if it satisfies every clause.\nGiven a CNF formula \u03c6, the satisfiability problem (SAT) is deciding whether \u03c6 has a satisfying truth assignment (i.e., an assignment to the variables of \u03c6 that satisfies every clause). The Maximum Satisfiability (MaxSAT) problem asks for a truth assignment that maximizes the number of satisfied clauses in \u03c6.\nMany theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].\nLet \u03c6 = {(C1, w2), . . . , (Cs, ws)} \u222a {(Cs+1,\u221e), . . . , (Cs+h,\u221e)} be a CNF formula, where w1, . . . , ws are natural numbers. The Weighted Partial MaxSAT problem asks for an assignment that satisfies all Cs+1, . . . , Cs+h (called hard clauses) and maximizes the sum of the weights of the satisfied clauses in C1, . . . , Cs (called soft clauses).\nIn general, exact MaxSAT solvers follow one of two approaches: successively calling a SAT solver (sometimes called the SAT-based approach) and the branch and bound approach. The former converts each MaxSAT problem with different hypothesized maximum weights into multiple SAT problems and uses a SAT solver to solve these SAT problems to determine the actual solution. The SAT-based approach converts the WPMaxSAT problem into a sequence of SAT instances which can be solved using SAT solvers. One way to do this, given an unweighted MaxSAT instance, is to check if there is an assignment that falsifies no clauses. If such an assignment can not be found, we check if there is an assignment that falsifies only one clause. This is repeated and each time we increment the number of clauses that are allowed to be False until the SAT solver returns True, meaning that the minimum number of falsified clauses has been determined. Recent comprehensive surveys on SAT-based algorithms can be found in[43, 8].\nThe second approach utilizes a depth-first branch and bound search in the space of possible assignments. An evaluation function which computes a bound is applied at each search node to determine any pruning opportunity. This paper surveys the satisfiabilitybased approach and provides an experimental investigation and comparison between the performances of both approaches on sets of benchmarks.\nBecause of the numerous calls to a SAT solver this approach makes, any improvement to SAT algorithms immediately benefits MaxSAT SAT-based methods. Experimental results from the MaxSAT Evaluations1 have shown that SAT-based solvers are more competent to handle large MaxSAT instances from industrial applications than branch and bound methods.\n1Web page: http://www.maxsat.udl.cat"}, {"heading": "2 Linear Search Algorithms", "text": "A simple way to solve WPMaxSAT is to augment each soft clause Ci with a new variable (called a blocking variable) bi, then a constraint is added (specified in CNF) saying that the sum of the weights of the falsified soft clauses must be less than a given value k. Next, the formula (without the weights) together with the constraint is sent to a SAT solver to check whether or not it is satisfiable. If so, then the cost of the optimal solution is found and the algorithm terminates. Otherwise, k is decreased and the process continues until the SAT solver returns True. The algorithm can start searching for the optimal cost\nfrom a lower bound LB initialized with the maximum possible cost (i.e. LB = \u2211|\u03c6S | i=1 wi) and decrease it down to the optimal cost, or it can set LB = 0 and increase it up to the optimal cost. Solvers that employ the former approach is called satisfiability-based (not to be confused with the name of the general method) solvers, while the ones that follow the latter are called UNSAT-based solvers. A cost of 0 means all the soft clauses are satisfied and a cost of means all the soft clauses are falsified.\nAlgorithm 1 employs the first method to search for the optimal cost by maintaining (maintaining a lower bound initialized to 0) (line 1).\nAlgorithm 1: LinearUNSAT(\u03c6) Linear search UNSAT-based algorithm for solving WPMaxSAT. Input: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: A WPMaxSAT solution to \u03c6\n1 LB \u2190 0 2 foreach (Ci, wi) \u2208 \u03c6S do 3 let bi be a new blocking variable 4 \u03c6S \u2190 \u03c6S \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)} 5 while True do\n6 (state, I)\u2190 SAT ({C | (C,w) \u2208 \u03c6} \u222a CNF ( \u2211|\u03c6S | i=1 wibi \u2264 LB)) 7 if state = True then 8 return I\n9 LB \u2190 UpdateBound({w | (C,w) \u2208 \u03c6S}, LB)\nNext, the algorithm relaxes each soft clause with a new variable in lines 2-4. The formula \u03c6 now contains each soft clause augmented with a new blocking variable. The while loop in lines 5-9 sends the clauses of \u03c6 (without the weights) to a SAT solver (line 6). If the SAT solver returns True, then LinearUNSAT terminates returning a solution (lines 7-8). Otherwise, the lower bound is updated and the loop continues until the SAT solver returns True. The function UpdateBound in line 9 updates the lower bound either by simply increasing it or by other means that depend on the distribution of the weights of the input formula. Later in this paper we will see how the subset sum problem can be a possible implementation of UpdateBound. Note that it could be inefficient if UpdateBound changes LB by one in each iteration. Consider a WPMaxSAT formula with five soft clauses having the weights 1, 1, 1, 1 and 100. The cost of the optimal solution can not be anything else other than 0, 1, 2, 3, 4, 100, 101, 102, 103 and 104. Thus, assigning LB any of the values 5, . . . , 99 is unnecessary and will result in a large number of iterations.\nExample 2.1. Let \u03c6 = \u03c6S \u222a \u03c6H , where \u03c6S = {(x1, 5), (x2, 5), (x3, 10), (x4, 5), (x5, 10), (x6, 5), (\u00acx6, 10)} and \u03c6H = {\u00acx1 \u2228 \u00acx2,\u221e), (\u00acx2 \u2228 \u00acx3,\u221e), (\u00acx3 \u2228 \u00acx4,\u221e), (\u00acx4 \u2228\u00acx5,\u221e), (\u00acx5 \u2228\u00acx1,\u221e)}. If we run LinearUNSAT on \u03c6, the soft clauses will be be relaxed {(x1 \u2228 b1, 5), (x2 \u2228 b2, 5), (x3 \u2228 b3, 10), (x4 \u2228 b4, 5), (x5 \u2228 b5, 10), (x6 \u2228 b6, 5), (\u00acx6 \u2228 b7, 10)} and LB is initialized to 0. The sequence of iterations are\n1. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 0) is included, state = False, LB = 5.\n2. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 5) is included, state = False, LB = 10.\n3. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 10) is included, state = False, LB = 15.\n4. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 15) is included, state = False, LB = 20.\n5. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 20) is included, state = True. The SAT solver returns the assignment I = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b4 = True, b5 = False, b6 = True, b7 = False}, which leads to a WPMaxSAT solution if we ignore the values of the bi, (1 \u2264 i \u2264 7) variables with cost 20.\nThe next algorithm is describes the SAT-based technique. Algorithm 2 starts by initializing the upper bound to one plus the the sum of the weights of the soft clauses (line 1).\nAlgorithm 2: LinearSAT(\u03c6) Linear search SAT-based algorithm for solving WPMaxSAT. Input: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: A WPMaxSAT solution to \u03c6\n1 UB \u2190 1 + \u2211|\u03c6S | i=1 wi 2 foreach (Ci, wi) \u2208 \u03c6S do 3 let bi be a new blocking variable \u03c6S \u2190 \u03c6S \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)} 4 while True do\n5 (state, I)\u2190 SAT ({C | (C,w) \u2208 \u03c6} \u222a CNF ( \u2211|\u03c6S | i=1 wibi \u2264 UB \u2212 1)) 6 if state = False then 7 return lastI\n8 lastI \u2190 I 9 UB \u2190 \u2211|\u03c6S | i=1 wi(1\u2212 I(Ci \\ {bi}))\nIn each iteration of algorithm 2 except the last, the formula is satisfiable. The cost of the optimal solution is found immediately after the transition from satisfiable to unsatisfiable instance. LinearSAT begins by initializing the upper bound to one plus the sum of the weights of the soft clauses (line 1). The while loop (lines 4-8) continues until the formula becomes unsatisfiable (line 6), then the algorithm returns a WPMaxSAT solution and terminates (line 7). As long as the formula is satisfiable, the formula is sent to the SAT\nsolver along with the constraint assuring that the sum of the weights of the falsified soft clauses is less than UB \u2212 1 (line 5), and the upper bound is updated to the sum of the weights of the soft clauses falsified by the assignment returned by the SAT solver (line 8).\nNote that updating the upper bound to \u2211|\u03c6S | i=1 wi(1 \u2212 I(Ci \\ {bi})) is more efficient than simply decreasing the upper bound by one, because uses less iterations and thus the problem is solved with less SAT calls.\nExample 2.2. If we run LinearSAT on \u03c6 from the previous example, the soft clauses will be be relaxed {(x1\u2228b1, 5), (x2\u2228b2, 5), (x3\u2228b3, 10), (x4\u2228b4, 5), (x5\u2228b5, 10), (x6\u2228b6, 5), (\u00acx6\u2228 b7, 10)} and UB is initialized to 1 + (5 + 5 + 5 + 5 + 10 + 10 + 10) = 51. The sequence of iterations are\n1. The constraint CNF (5b1+5b2+10b3+5b4+10b5+5b6+10b7 \u2264 50) is included, state = True, I = {x1 = False, x2 = False, x3 = False, x4 = False, x5 = False, x6 = False, b1 = True, b2 = True, b3 = True, b4 = True, b5 = True, b6 = True, b7 = False}, UB = 5 + 5 + 10 + 5 + 10 + 5 = 40.\n2. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 40 \u2212 1) is included, state = True, I = {x1 = False, x2 = False, x3 = False, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = True, b4 = True, b5 = False, b6 = True, b7 = False}, UB = 5 + 5 + 10 + 5 + 5 = 30.\n3. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 30 \u2212 1) is included, state = True, I = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b4 = True, b5 = False, b6 = True, b7 = False}, UB = 5 + 5 + 5 + 5 = 20.\n4. The constraint CNF (5b1 + 5b2 + 10b3 + 5b4 + 10b5 + 5b6 + 10b7 \u2264 20\u22121) is included, state = False. The assignment from the previous step is indeed a solution to \u03c6 if we ignore the values of the bi, (1 \u2264 i \u2264 7) variables with cost 20."}, {"heading": "3 Binary Search-based Algorithms", "text": "The number of iterations linear search algorithms for WPMaxSAT can take is linear in the sum of the weights of the soft clauses. Thus, in the worst case the a linear search\nWPMaxSAT algorithm can take \u2211|\u03c6S | i=1 wi calls to the SAT solver. Since we are searching\nfor a value (the optimal cost) among a set of values (from 0 to \u2211|\u03c6S | i=1 wi), then binary search can be used, which uses less iterations than linear search. Algorithm 3 searches for the cost of the optimal assignment by using binary search.\nAlgorithm 3: BinS-WPMaxSAT(\u03c6) Binary search based algorithm for solving WPMaxSAT. Input: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: A WPMaxSAT solution to \u03c6\n1 state\u2190 SAT ({Ci | (Ci,\u221e) \u2208 \u03c6H}) 2 if state = False then 3 return \u2205 4 LB \u2190 \u22121 5 UB \u2190 1 + \u2211|\u03c6S | i=1 wi 6 foreach (Ci, wi) \u2208 \u03c6S do 7 let bi be a new blocking variable 8 \u03c6S \u2190 \u03c6S \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)} 9 while LB + 1 < UB do\n10 mid\u2190 bLB+UB 2 c 11 (state, I)\u2190 SAT ({C | (C,w) \u2208 \u03c6} \u222a CNF ( \u2211|\u03c6S | i=1 wibi \u2264 mid)) 12 if state = True then 13 lastI \u2190 I 14 UB \u2190 \u2211|\u03c6S | i=1 wi(1\u2212 I(Ci \\ {bi}))\n15 else 16 LB \u2190 UpdateBound({wi | 1 \u2264 i \u2264 |\u03c6S |},mid)\u2212 1\n17 return lastI\nBinS-WPMaxSAT begins by checking the satisfiability of the hard clauses (line 1) before beginning the search for the solution. If the SAT solver returns False (line 2), BinS-WPMaxSAT returns the empty assignment and terminates (line 3). The algorithm updates both a lower bound LB and an upper bound UB initialized respectively to -1 and one plus the sum of the weights of the soft clauses (lines 4-5). The soft clauses are augmented with blocking variables (lines 6-8). At each iteration of the main loop (lines 9-16), the middle value (mid) is changed to the average of LB and UB and a constraint is added requiring the sum of the weights of the relaxed soft clauses to be less than or equal to the middle value. This clauses describing this constraint are sent to the SAT solver along with the clauses of \u03c6 (line 11). If the SAT solver returns True (line 12), then the cost of the optimal solution is less than mid, and UB is updated (line 14). Otherwise, the algorithm looks for the optimal cost above mid, and so LB is updated (line 16). The main loop continues until LB + 1 = UB, and the number of iterations BinS-WPMaxSAT\nexecutes is proportional to log( \u2211|\u03c6S | i=1 wi) which is a considerably lower complexity than that of linear search methods. In the following example, UpdateBound assigns mid+ 1 to LB.\nExample 3.1. Consider \u03c6 in example 2.1 with all the weights of the soft clauses set to 1. At the beginning, LB = \u22121, UB = 8. The following are the sequence of iterations algorithm 3 executes.\n1. mid = b 8+(\u22121)2 c = 3, the constraint CNF (b1 + b2 + b3 + b4 + b5 + b6 + b7 \u2264 3) is included, state = False, LB = 3, UB = 8.\n2. mid = b 8+32 c = 5, the constraint CNF (b1 + b2 + b3 + b4 + b5 + b6 + b7 \u2264 5) is\nincluded, state = True, I = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b4 = True, b5 = False, b6 = True, b7 = False}, UB = 4, LB = 3. The assignment I is indeed an optimal one, falsifying four clauses.\nIt is often stated that a binary search algorithm performs better than linear search. Although this is true most of the time, there are instances for which linear search is faster than binary search. Let k be the sum of the soft clauses falsified by the assignment returned by the SAT solver in the first iteration. If k is indeed the optimal solution, linear search methods would discover this fact in the next iteration, while binary search ones would take log k iterations to declare k as the optimal cost. In order to benefit from both search methods, An et al.[3] developed a PMaxSAT algorithm called QMaxSAT (version 0.4) that alternates between linear search and binary search (see algorithm 4).\nAlgorithm 4: BinLin-WPMaxSAT(\u03c6) Alternating binary and linear searches for solving WPMaxSAT.\nInput: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: A WPMaxSAT solution to \u03c6\n1 state\u2190 SAT ({Ci | (Ci,\u221e) \u2208 \u03c6H}) 2 if state = False then 3 return \u2205 4 foreach (Ci, wi) \u2208 \u03c6S do 5 let bi be a new blocking variable 6 \u03c6S \u2190 \u03c6S \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)} 7 LB \u2190 \u22121 8 UB \u2190 1 + \u2211|\u03c6S | i=1 wi\n9 mode\u2190 binary 10 while LB + 1 < UB do 11 if mode = binary then 12 mid\u2190 bLB+UB\n2 c\n13 else 14 mid\u2190 UB \u2212 1\n15 (state, I)\u2190 SAT ({C | (C,w) \u2208 \u03c6} \u222a CNF ( \u2211|\u03c6S | i=1 wibi \u2264 mid)) 16 if state = True then 17 lastI \u2190 I 18 UB \u2190 \u2211|\u03c6S | i=1 wi(1\u2212 I(Ci \\ {bi}))\n19 else 20 if mode = binary then 21 LB \u2190 UpdateBound({wi | 1 \u2264 i \u2264 |\u03c6S |},mid)\u2212 1 22 else 23 LB \u2190 mid\n24 if mode = binary then 25 mode\u2190 linear 26 else 27 mode\u2190 binary\n28 return lastI\nAlgorithm 4 begins by checking that the set of hard clauses is satisfiable (line 1). If not, then the algorithm returns the empty assignment and terminates (line 3). Next, the soft clauses are relaxed (lines 4-6) and the lower and upper bounds are initialized respectively to -1 and one plus the sum of the weights of the soft clauses (lines 7-8). BinLin-WPMaxSAT has two execution modes, binary and linear. The mode of execution is initialized in line 9 to binary search. At each iteration of the main loop (lines 10-27), the SAT solver is called\non the clauses of \u03c6 with the constraint \u2211|\u03c6S | i=1 wibi bounded by the mid point (line 12), if the current mode is binary, or by the upper bound if the mode is linear (line 14). If the formula is satisfiable (line 16), the upper bound is updated. Otherwise, the lower bound is updated to the mid point. At the end of each iteration, the mode of execution is flipped (lines 24-27).\nSince the cost of the optimal solution is an integer, it can be represented as an array of\nbits. Algorithm 5 uses this fact to determine the solution bit by bit. BitBased-WPMaxSAT starts from the most significant bit and at each iteration it moves one bit closer to the least significant bit, at which the optimal cost if found.\nAlgorithm 5: BitBased-WPMaxSAT(\u03c6) A bit-based algorithm for solving WPMaxSAT. Input: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: A WPMaxSAT solution to \u03c6\n1 state\u2190 SAT ({Ci | (Ci,\u221e) \u2208 \u03c6H}) 2 if state = False then 3 return \u2205 4 foreach (Ci, wi) \u2208 \u03c6S do 5 let bi be a new blocking variable 6 \u03c6S \u2190 \u03c6S \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)}\n7 k \u2190 blg( \u2211|\u03c6S | i=1 wi)c 8 CurrBit\u2190 k 9 cost\u2190 2k\n10 while CurrBit \u2265 0 do 11 (state, I)\u2190 SAT ({C | (C,w) \u2208 \u03c6} \u222a CNF ( \u2211|\u03c6S | i=1 wibi < cost)) 12 if state = True then 13 lastI \u2190 I 14 let s0, . . . , sk \u2208 {0, 1} be constants such that\u2211|\u03c6S |\ni=1 wi(1\u2212 I(Ci \\ {bi})) = \u2211k j=0 2 jsj // s0, . . . , sk are the binary\nrepresentation of the current cost\n15 CurrBit\u2190 max({j | j < CurrBit and sj = 1} \u222a {\u22121}) 16 if CurrBit \u2265 0 then 17 cost\u2190 \u2211k j=CurrBit 2 jsj\n18 else 19 CurrBit\u2190 CurrBit\u2212 1 20 cost\u2190 cost+ 2CurrBit\n21 return lastI\nAt the beginning of the algorithm as in the previous ones, the satisfiability of the hard clauses are checked and the soft clauses are relaxed. The sum of the weights of the soft clauses k is an upper bound on the cost and thus it is computed to determine the number of bits needed to represent the optimal solution (line 7). The index of the current bit being considered is initialized to k (line 7), and the value of the solution being constructed is initialized (line 8). The main loop (lines 10-20) terminates when it reached the least significant bit (when CurrBit = 0). At each iteration, the SAT solver is called on \u03c6 with constraint saying that the sum of the weights of the falsified soft clauses must be less than cost (line 11). If the SAT solver returns True (line 12), the sum of the weights of the soft clauses falsified by the current assignment is computed and the set of bits needed to represent that number are determined as well (line 14), the index of the current bit is decreased to the next j < CurrBit such that sj = 1 (line 15). If such an index does not exist, then CurrBit becomes -1 and in the following iteration the algorithm terminates.\nOn the other hand, if the SAT solver returns False, the search continues to the most significant bit by decrementing CurrBit (line 19) and since the optimal cost is greater than the current value of cost, it is decreased by 2CurrBit (line 20).\nExample 3.2. Consider \u03c6 from example 2.1 with all the weights of the soft clauses being 1. At the beginning of the algorithm, the soft clauses are relaxed and the formula becomes {(x1\u2228 b1, 1), (x2\u2228 b2, 1), (x3\u2228 b3, 1), (x4\u2228 b4, 1), (x5\u2228 b5, 1), (x6\u2228 b6, 1), (\u00acx6\u2228 b7, 1)}\u222a\u03c6H . Also, the variables k, CurrBit and cost are initialized to 2, 2 and 22 respectively. The following are the iterations BitBased-WPMaxSAT executes.\n1. The constraint CNF (b1 + b2 + b3 + b4 + b5 + b6 + b7 < 2 2) is included, state = False,\nCurrBit = 1, cost = 22 + 21 = 6.\n2. The constraint CNF (b1 + b2 + b3 + b4 + b5 + b6 + b7 < 2 2 + 21), state = True,\nI = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b4 = True, b5 = False, b6 = True, b7 = False}, CurrBit = \u22121."}, {"heading": "4 Core-guided Algorithms", "text": "As in the previous method, UNSAT methods use SAT solvers iteratively to solve MaxSAT. Here, the purpose of iterative SAT calls is to identify and relax unsatisfiable formulas (unsatisfiable cores) in a MaxSAT instance. This method was first proposed in 2006 by Fu and Malik in[18] (see algorithm 6). The algorithms described in this section are\n1. Fu and Malik\u2019s algorithm[18]\n2. WPM1[4]\n3. Improved WPM1[5]\n4. WPM2[7]\n5. WMSU1-ROR[21]\n6. WMSU3[37]\n7. WMSU4[38]\nDefinition 4.1 (Unsatisfiable core). An unsatisfiable core of a CNF formula \u03c6 is a subset of \u03c6 that is unsatisfiable by itself.\nDefinition 4.2 (Minimum unsatisfiable core). A minimum unsatisfiable core contains the smallest number of the original clauses required to still be unsatisfiable.\nDefinition 4.3 (Minimal unsatisfiable core). A minimal unsatisfiable core is an unsatisfiable core such that any proper subset of it is not a core[15].\nModern SAT solvers provide the unsatisfiable core as a by-product of the proof of unsatisfiability. The idea in this paradigm is as follows: Given a WPMaxSAT instance \u03c6 = {(C1, w1), . . . , (Cs, ws)} \u222a {(Cs+1,\u221e), . . . , (Cs+h,\u221e)}, let \u03c6k be a SAT instance that is satisfiable iff \u03c6 has an assignment with cost less than or equal to k. To encode \u03c6k,\nwe can extend every soft clause Ci with a new (auxiliary) variable bi and add the CNF conversion of the constraint \u2211s i=1 wibi \u2264 k. So, we have\n\u03c6k = {(Ci \u2228 bi), . . . , (Cs \u2228 bs), Cs+1, . . . , Cs+h} \u222a CNF ( s\u2211 i=1 wibi \u2264 k )\nLet kopt be the cost of the optimal assignment of \u03c6. Thus, \u03c6k is satisfiable for all k \u2265 kopt, and unsatisfiable for all k < kopt, where k may range from 0 to \u2211s i=1 wi. Hence, the search for the optimal assignment corresponds to the location of the transition between satisfiable and unsatisfiable \u03c6k. This encoding guarantees that the all the satisfying assignments (if any) to \u03c6kopt are the set of optimal assignments to the WPMaxSAT instance \u03c6."}, {"heading": "4.1 Fu and Malik\u2019s algorithm", "text": "Fu and Malik implemented two PMaxSAT solvers, ChaffBS (uses binary search to find the optimal cost) and ChaffLS (uses linear search to find the optimal cost) on top of a SAT solver called zChaff[44]. Their PMaxSAT solvers participated in the first and second MaxSAT Evaluations[10]. Their method (algorithm 6 basis for many WPMaxSAT solvers that came later. Notice the input to algorithm 6 is a PMaxSAT instance since all the weights of the soft clauses are the same.\nAlgorithm 6: Fu&Malik(\u03c6) Fu and Malik\u2019s algorithm for solving PMaxSAT.\nInput: \u03c6 = {(C1, 1), . . . , (Cs, 1), (Cs+1,\u221e), . . . , (Cs+h,\u221e)} Output: The cost of the optimal assignment to \u03c6\n1 if SAT ({Cs+1, . . . , Cs+h}) = (False, ) then 2 return \u221e 3 opt\u2190 0 // The cost of the optimal solution 4 f \u2190 0 // The number of clauses falsified 5 while True do 6 (state, \u03c6C)\u2190 SAT ({Ci | (Ci, wi) \u2208 \u03c6}) 7 if state = True then 8 return opt\n9 f \u2190 f + 1 10 B \u2190 \u2205 11 foreach Ci \u2208 \u03c6C such that wi 6=\u221e do 12 let bi be a new blocking variable 13 \u03c6\u2190 \u03c6 \\ {(Ci, 1)} \u222a {(Ci \u2228 bi, 1)} 14 B \u2190 B \u222a {i} 15 \u03c6\u2190 \u03c6 \u222a {(C,\u221e) | C \u2208 \u2211 i\u2208B bi = 1} // Add the cardinality constraint as hard\nclauses\n16 opt\u2190 opt+ 1\nFu&Malik (algorithm 6) (also referred to as MSU1) begins by checking if a hard clause is falsified (line 1), and if so it terminates returning the cost\u221e (line 2). Next, unsatisfiable cores (\u03c6C) are identified by iteratively calling a SAT solver on the soft clauses (line 6).\nIf the working formula is satisfiable (line 7), the algorithm halts returning the cost of the optimal assignment (line 8). If not, then the algorithm starts its second phase by relaxing each soft clause in the unsatisfiable core obtained earlier by adding to it a fresh variable, in addition to saving the index of the relaxed clause in B (lines 11-14). Next, the new working formula constraints are added indicating that exactly one of bi variables should be True (line 15). Finally, the cost is increased by one (line 16) a clause is falsified. This procedure continues until the SAT solver declares the formula satisfiable."}, {"heading": "4.2 WPM1", "text": "Anso\u0301tegui, Bonet and Levy[4] extended Fu& Malik to WPMaxSAT. The resulting algorithm is called WPM1 and is described in algorithm 7.\nAlgorithm 7: WPM1(\u03c6) The WPM1 algorithm for WPMaxSAT.\nInput: A WPMaxSAT instance \u03c6 = {(H1,\u221e), . . . , (Hh,\u221e)} \u222a {(S1, w1), . . . , (Ss, ws)} Output: The optimal cost of the WPMaxSAT solution\n1 if SAT ({Hi | 1 \u2264 i \u2264 h}) = False then 2 return \u221e 3 cost\u2190 0 4 while True do 5 (state, \u03c6C)\u2190 SAT ({Ci | (Ci, wi) \u2208 \u03c6}) 6 if state = True then 7 return cost\n8 BV \u2190 \u2205 9 wmin \u2190 min{wi | Ci \u2208 \u03c6C and wi 6=\u221e}\n// Compute the minimum weight of all the soft clauses in \u03c6C 10 foreach Ci \u2208 \u03c6C do 11 if wi 6=\u221e then 12 Let bi be a new blocking variable 13 \u03c6\u2190 \u03c6 \\ {(Ci, wi)} \u222a {(Ci, wi \u2212 wmin)} \u222a {(Ci \u2228 bi, wmin)} 14 BV \u2190 BV \u222a {bi}\n15 if BV = \u2205 then 16 return False // \u03c6 is unsatisfiable\n17 else 18 \u03c6\u2190 \u03c6 \u222a CNF (\u2211 b\u2208BV b = 1 ) // Add the cardinality constraint as hard\nclauses\n19 cost\u2190 cost+ wmin\nJust as in Fu&Malik, algorithm 7 calls a SAT solver iteratively with the working formula, but without the weights (line 5). After the SAT solver returns an unsatisfiable core, the algorithm terminates if the core contains hard clauses and if it does not, then the algorithm computes the minimum weight of the clauses in the core, wmin (line 9). Next, the working formula is transformed by duplicating the core (line 13) with one copy having the clauses associated with the original weight minus the minimum weight and a second copy having having the clauses augmented with blocking variables with the original weight.\nFinally, the cardinality constraint on the blocking variable is added as hard clauses (line 18) and the cost is increased by the minimum weight (line 19).\nWPM1 uses blocking variables in an efficient way. That is, if an unsatisfiable core, \u03c6C = {C1, . . . , Ck}, appears l times, all the copies get the same set of blocking variables. This is possible because the two formulae \u03c61 = \u03c6 \\ \u03c6C \u222a {C1 \u2228 bi, . . . , Ci \u2228 bi | Ci \u2208 \u03c6C} \u222a CNF (\u2211k i=1 bi = 1 ) and \u03c62 = \u03c6 \\ \u03c6C \u222a {Ci \u2228 b1i , . . . , Ci \u2228 bli | Ci \u2208 \u03c6C} \u222a\nCNF (\u2211k\ni=1 b 1 i = 1\n) \u222a \u00b7 \u00b7 \u00b7 \u222a CNF (\u2211k i=1 b l i = 1 ) are MaxSAT equivalent, meaning that\nthe minimum number of unsatisfiable clause of \u03c61 and \u03c62 is the same. However, the algorithm does not avoid using more than one blocking variable per clause. This disadvantage is eliminated by WMSU3 (described later).\nExample 4.1. Consider \u03c6 = {(x1, 1), (x2, 2), (x3, 3), (\u00acx1 \u2228 \u00acx2,\u221e), (x1\u2228\u00acx3,\u221e), (x2\u2228\u00acx3,\u221e)}. In the following, bji is the relaxation variable added to clause Ci at the jth iteration. A possible execution sequence of the algorithm is:\n1. state = False, \u03c6C = {(\u00acx3), (\u00acx1 \u2228 \u00acx2), (x1 \u2228 \u00acx3), (x2 \u2228 \u00acx3)}, wmin = 3, \u03c6 = {(x1, 1), (x2, 2), (x3 \u2228 b13, 3),, (\u00acx1 \u2228\u00acx2,\u221e), (x1 \u2228\u00acx3,\u221e), (x2 \u2228\u00acx3,\u221e), (b13 = 1,\u221e)}.\n2. state = False, \u03c6C = {(x1), (x2), (\u00acx1\u2228\u00acx2)}, wmin = 1, \u03c6 = {(x1\u2228b21), (x2, 1), (x2\u2228 b22), (x3 \u2228 b13), (\u00acx1 \u2228 \u00acx2,\u221e),(x1 \u2228 \u00acx3,\u221e), (x2 \u2228 \u00acx3,\u221e), (b13 = 1,\u221e), (b21 + b22 = 1,\u221e).\n3. state = True, A = {x1 = 0, x2 = 1, x3 = 0} is an optimal assignment with\u2211 Ci is soft\nA satisfies Ci\nwi = 2"}, {"heading": "If the SAT solver returns a different unsatisfiable core in the first iteration, a different execution sequence is going to take place.", "text": ""}, {"heading": "4.3 Improved WPM1", "text": "In 2012, Anso\u0301tegui, Bonet and Levy presented a modification to WPM1 (algorithm 7)[5]. In WPM1, the clauses of the core are duplicated after computing their minimum weight wmin. Each clause Ci in the core, the (Ci, wi \u2212 wmin) and (Ci \u2228 bi, wmin) are added to the working formula and (Ci, wi) is removed. This process of duplication can be inefficient because a clause with weight w can be converted into w copies with weight 1. The authors provided the following example to illustrate this issue: consider \u03c6 = {(x1, 1), (x2, w), (\u00acx2, \u221e)}. If the SAT solver always includes the first clause in the identified core, the working formula after the first iteration will be {(x1 \u2228 b11, 1), (x2 \u2228 b12, 1), (x2, w\u2212 1), (\u00acx2,\u221e), (b11 + b12 = 1,\u221e)}. If at each iteration i, the SAT solver includes the first clause and with {(x2, w \u2212 i + 1), (\u00acx2,\u221e)} in the unsatisfiable core, then after i iterations the formula would be {(x1\u2228b11\u2228\u00b7 \u00b7 \u00b7\u2228bi1, 1), (x2\u2228b2\u22171, 1), . . . , (x2\u2228bi2, 1), (x2, w\u2212i), (\u00acx2,\u221e), (b11+b12 = 1,\u221e), . . . , (bi1 + bi2 = 1,\u221e)}. In this case, WPM1 would need w iterations to solve the problem.\nAlgorithm 8: ImprovedWPM1(\u03c6) The stratified approach for WPM1 algorithm.\nInput: A WPMaxSAT instance \u03c6 = {(C1, w1), . . . , (Cm, wm), (Cm+1,\u221e), . . . , (Cm+m\u2032 , wm+m\u2032)}\nOutput: The cost of the optimal WPMaxSAT solution to \u03c6 1 if SAT ({Ci | wi =\u221e}) = (False, ) then 2 return \u221e // cost =\u221e if the hard clauses can not be satisfied 3 cost\u2190 0 4 wmax \u2190 max{wi | (Ci, wi) \u2208 \u03c6 and wi < wmax} // Initialize wmax to the largest\nweight smaller than \u221e 5 while True do 6 (state, \u03c6C)\u2190 SAT ({Ci | (Ci, wi) \u2208 \u03c6 and wi \u2265 wmax}) 7 if state = True and wmax = 0 then 8 return cost\n9 else 10 if state = True then 11 wnax = max{wi | (Ci, wi) \u2208 \u03c6 and wi < wmax} 12 else 13 BV \u2190 \u2205 // Set of blocking variables of the unsatisfiable core 14 wmin \u2190 min{wi | Ci \u2208 \u03c6C and wi 6=\u221e} // Minimum weight of soft\nclauses in the unsatisfiable core\n15 foreach Ci \u2208 \u03c6C do 16 if wi 6=\u221e then 17 Let b be a new variable \u03c6\u2190 \u03c6 \\ {(Ci, wi)} \u222a {(Ci, wi \u2212 wmin), (Ci \u2228 b, wmin)} 18 BV \u2190 BV \u222a {b}\n19 \u03c6\u2190 \u03c6 \u222a {(C,\u221e) | C \u2208 CNF ( \u2211 b\u2208BV b = 1)} // The cardinality\nconstraint is added as hard clauses\n20 cost\u2190 cost+ wmin\nAlgorithm 8 overcomes this problem by utilizing a stratified approach. The aim is to restrict the clauses sent to the SAT solver to force it to concentrate on those with higher weights, which leads the SAT solver to return unsatisfiable cores with clauses having larger weights. Cores with clauses having larger weight are better because they contribute to increasing the cost faster. Clauses with lower weights are used after the SAT solver returns True. The algorithm starts by initializing wmax to the largest weight smaller than \u221e, then in line 6 only the clauses having weight greater than or equal to wmax are sent to the SAT solver. The algorithm terminates if the SAT solver returns True and wmax is zero (lines 7-8), but if wmax is not zero and the formula is satisfiable then wmax is decreased to the largest weight smaller than wmax (lines 10-11). When the SAT solver returns False, the algorithm proceeds as the regular WPM1.\nA potential problem with the stratified approach is that in the worst case the algorithm could use more calls to the SAT solver than the regular WPM1. This is because there is no contribution made to the cost when the SAT solver returns True and at the same time wmax > 0. The authors apply the diversity heuristic which decreases wmax faster when there is a big variety of distinct weights and assigns wmax to the next value of wi when there is a low diversity among the weights."}, {"heading": "4.4 WPM2", "text": "In 2007, Marques-Silva and Planes[37] discussed important properties of Fu&Malik that were not mentioned in[18]. If m is the number of clauses in the input formula, they proved that the algorithm performs O(m) iterations and the number of relaxation variables used in the worst case is O(m2). Marques-Silva and Planes also tried to improve the work of Fu and Malik. Fu&Malik use the pairwise encoding[19] for the constraints on the relaxation variables, which use a quadratic number of clauses. This becomes impractical when solving real-world instances. Instead, Marques-Silva and Planes suggested several other encodings all of which are linear in the number of variables in the constraint[57, 53, 17, 19].\nAnother drawback of Fu&Malik is that there can be several blocking variables associated with a given clause. This is due to the fact that a clause C can participate in more than one unsatisfiable core. Each time C is a part of a computed unsatisfiable core, a new blocking variable is added to C. Although the number of blocking variables per clause is possibly large (but still linear), at most one of these variables can be used to prevent the clause from participating in an unsatisfiable core. A simple solution to reduce the search space associated with blocking variables is to require that at most one of the blocking variables belonging to a given clause can be assigned True. For a clause Ci, let bi,j , (1 \u2264 j \u2264 ti) be the blocking variables associated with Ci. The condition\u2211ti j=1 bi,j \u2264 1 assures that at most one of the blocking variables of Ci is assigned True. This is useful when executing a large number of iterations, and many clauses are involved in a significant number of unsatisfiable cores. The resulting algorithm that incorporated these improvements is called MSU2.\nAnso\u0301tegui, Bonet and Levy also developed an algorithm for WPMaxSAT in 2010, called WPM2[7], where every soft clause Ci is extended with a unique fresh blocking variable bi. Note that a SAT solver will assign bi True if Ci is False. At every iteration, the algorithm modifies two sets of at-most and at-least constraints on the blocking variables, called AL and AM respectively. The algorithm relies of the notion of covers.\nDefinition 4.4 (Cover). Given a set of cores L, its set of covers Covers(L) is defined as the minimal partition of {1, . . . ,m} such that for every A \u2208 L and B \u2208 Covers(L), if A \u2229B 6= \u2205, then A \u2286 B.\nAlgorithm 9: WPM2(\u03c6) The WPM2 algorithm for WPMaxSAT\nInput: A WPMaxSAT instance \u03c6 = {(C1, w1), . . . , (Cm, wm), (Cm+1,\u221e), . . . , (Cm+m\u2032 ,\u221e)}\nOutput: The optimal WPMaxSAT solution to \u03c6 1 if SAT ({Ci \u2208 \u03c6 | wi =\u221e}) = (False, ) then 2 return \u221e 3 \u03c6e \u2190 {C1 \u2228 b1, . . . , Cm \u2228 bm, Cm+1, . . . , Cm+m\u2032} 4 Covers\u2190 {{1}, . . . , {m}} 5 AL\u2190 \u2205 6 AM \u2190 {w1b1 \u2264 0, . . . , wmbm \u2264 0} 7 while True do 8 (state, \u03c6C , I)\u2190 SAT (\u03c6e \u222a CNF (AL \u222aAM)) 9 if state = True then\n10 return I\n11 Remove the hard clauses from \u03c6C 12 if \u03c6C = \u2205 then 13 return \u2205 // \u03c6 has no solution 14 A\u2190 \u2205 15 foreach Ci \u2228 bi \u2208 \u03c6C do 16 A\u2190 A \u222a {i} 17 RC \u2190 {B \u2208 Covers | B \u2229A 6= \u2205} 18 B \u2190 \u22c3 B\u2032\u2208RC B \u2032 19 k \u2190 NewBound(AL,B) 20 Covers\u2190 Covers \\RC \u222aB 21 AL\u2190 AL \u222a { \u2211 i\u2208B wibi \u2265 k}\n22 AM \u2190 AM \\ { \u2211 i\u2208B\u2032 wibi \u2264 k \u2032 | B\u2032 \u2208 RC} \u222a { \u2211 i\u2208B wibi \u2264 k}\nThe constraints in AL give lower bounds on the optimal cost of \u03c6, while the ones in AM ensure that all solutions of the set AM \u222aAL are the solutions of AL of minimal cost. This in turn ensures that any solution of \u03c6e \u222a CNF (AL \u222a AM) (if there is any) is an optimal assignment of \u03c6.\nThe authors use the following definition of cores and introduced a new notion called covers to show how AM is computed given AL.\nDefinition 4.5 (Core). A core is a set of indices A such that(\u2211 i\u2208A wibi \u2265 k ) \u2208 AL\n. The function Core (\u2211 i\u2208A wibi \u2265 k )\nreturns the coreA, and Cores(AL) returns {Core(al) | al \u2208 AL}.\nDefinition 4.6 (Disjoint cores). Let U = {U1, . . . , Uk} be a set of unsatisfiable cores, each with a set of blocking variables Bi, (1 \u2264 i \u2264 k). A core Ui \u2208 U is disjoint if for all Uj \u2208 U we have (Ri \u2229Rj = \u2205 and i 6= j)\nGiven a set of AL constraints, AM is the set of at-most constraints \u2211 i\u2208A wibi \u2264 k\nsuch that A \u2208 Cover(Cores(AL)) and k is the solution minimizing \u2211 i\u2208A wibi subject to\nAL and bi \u2208 {True, False}. At the beginning, AL = {w1b1 \u2265 0, . . . , wmbm \u2265 0} and the corresponding AM = {w1b1 \u2264 0, . . . , wmbm \u2264 0} which ensures that the solution to AL \u222a AM is b1 = False, . . . , bm = False. At every iteration, when an unsatisfiable core \u03c6C is identified by the SAT solver, the set of indices of soft clauses in \u03c6C A \u2286 {1, . . . ,m} is computed, which is also called a core. Next, the set of covers RC = {B\u2032 \u2208 Covers | B\u2032\u2229 A 6= \u2205} that intersect with A is computed, as well as their union B = \u22c3 B\u2032\u2208RC B\n\u2032. The new set of covers is Covers = Covers \\RC \u222aB. The set of at-least constraints AL is enlarged by adding a new constraint \u2211 i\u2208B wibi \u2265 NewBound(AL,B), where NewBound(AL,B)\ncorrespond to minimize \u2211 i\u2208A wibi subject to the set of constraints { \u2211 wibi\u2265k}\u222aAL where\nk = 1 + \u2211 {k\u2032 | \u2211 i\u2208A\u2032 wibi \u2264 k\u2032 \u2208 AM and A\u2032 \u2286 A}. Given AL and B, the computation of NewBound can be difficult since it can be reduced to the subset sum problem in the following way: given {w1, . . . , wn} and k, minimize \u2211n j=1 wjxj subject to \u2211n j=1 wjxj > k and xj \u2208 {0, 1}. This is equivalent to NewBound(AL,B), where the weights are wj , B = {1, . . . , n} and AL = { \u2211n j=1 wjxj \u2265 k}. In the authors\u2019 implementation, NewBound is computed by algorithm 10.\nAlgorithm 10: NewBound(AL,B) 1 k \u2190 \u2211{ k\u2032 | \u2211 i\u2208B\u2032 wibi \u2264 k \u2032 \u2208 AM and B\u2032 \u2286 B } 2 repeat 3 k \u2190 SubsetSum({wi | i \u2208 B}, k) 4 until SAT ( CNF ( AL \u222a { \u2211 i\u2208B wibi = k}\n)) 5 return k\nThe SubsetSum function (called in line 3) is an optimization version of the decision subset sum problem. It returns the largest integer d \u2264 k such that there is a subset of {wi | i \u2208 B} that sums to d.\nExample 4.2. Consider \u03c6 in example 2.1 with all the weights of the soft clauses set to 1. Before the main loop of algorithm 9, we have \u03c6e = {(x1 \u2228 b1), (x2 \u2228 b2), (x3 \u2228 b3), (x4 \u2228 b4), (x5\u2228b5), (x6\u2228b6), (\u00acx6\u2228b7)}\u222a\u03c6H , Covers = {{1}, {2}, {3}, {4}, {5}, {6}, {7}}, AL = \u2205, AM = {b1 \u2264 0, b2 \u2264 0, b3 \u2264 0, b4 \u2264 0, b5 \u2264 0, b6 \u2264 0, b7 \u2264 0}. The following are the iterations the algorithm executes. The soft clauses in the core \u03c6C are denoted by Soft(\u03c6C).\n1. state = False, Soft(\u03c6C) = {(x6 \u2228 b6), (\u00acx6 \u2228 b7)}, A = {6, 7}, RC = {{6}, {7}}, B = {6, 7}, k = 1, Covers = {{1}, {2}, {3}, {4}, {5}, {6, 7}}, AL = {b6 + b7 \u2265 1}, AM = {b1 \u2264 0, b2 \u2264 0, b3 \u2264 0, b4 \u2264 0, b5 \u2264 0, b6 + b7 \u2264 1}.\n2. state = False, Soft(\u03c6C) = {(x1), (x2)}, A = {1, 2}, RC = {{1}, {2}}, B = {1, 2}, k = 1, Covers = {{1, 2}, {3}, {4}, {5}, {6, 7}}, AL = {b6 + b7 \u2265 1, b1 + b2 \u2265 1}, AM = {b3 \u2264 0, b4 \u2264 0, b5 \u2264 0, b6 + b7 \u2264 1, b1 + b2 \u2264 1}.\n3. state = False, Soft(\u03c6C) = {(x3), (x4)}, A = {3, 4}, RC = {{3}, {4}}, B = {3, 4}, k = 1, Covers = {{1, 2}, {3, 4}, {5}, {6, 7}}, AL = {b6 +b7 \u2265 1, b1 +b2 \u2265 1, b3 +b4 \u2265 1}, AM = {b1 + b2 \u2264 1, b5 \u2264 0, b6 + b7 \u2264 1, b3 + b4 \u2264 1}.\n4. state = False, Soft(\u03c6C) = {(x1), (x2), (x3), (x4), (x5)}, A = {1, 2, 3, 4, 5}, RC = {{1, 2}, {3, 4}, {5}}, B = {1, 2, 3, 4, 5}, k = 3, Covers = {{6, 7}, {1, 2, 3, 4, 5}}, AL = {b6 + b7 \u2265 1, b1 + b2 \u2265 1, b3 + b4 \u2265 1, b1 + b2 + b3 + b4 + b5 \u2265 3}, AM = {b1 + b2 \u2264 1, b1 + b2 + b3 + b4 + b5 \u2264 3}.\n5. state = True, I = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b4 = True, b5 = False, b6 = True, b7 = False}.\nTo sum up, the WPM2 algorithm groups the identified cores in covers, which are a decomposition of the cores into disjoint sets. Constraints are added so that the relaxation variables in each cover relax a particular weight of clauses k, which is changed to the next largest value the weights of the clauses can sum up to. Computing the next k can be expensive since it relies on the subset sum problem, which is NP-hard.\nIn[6], Anso\u0301tegui et at. invented three improvements to WPM2. First, they applied the stratification technique[5]. Second, they introduced a new criteria to decide when soft clauses can be hardened. Finally, they showed that by focusing search on solving to optimality subformulae of the original WPMaxSAT instance, they efficiency of WPM2 is increased. This allows to combine the strength of exploiting the information extracted from unsatisfiable cores and other optimization approaches. By solving these smaller optimization problems the authors obtained the most significant boost in their new WPM2 version."}, {"heading": "4.5 WMSU1-ROR", "text": "WMSU1-ROR[21] is a modification of WPM1. It attempts to avoid adding blocking variables by applying MaxSAT resolution to the clauses of the unsatisfiable core. Given an unsatisfiable core \u03c6C , a resolution refutation (a contradiction obtained by performing resolution) is calculated by a specialized tool. As much of this refutation as possible is copied by applying MaxSAT resolution steps to the working formula. If the transformation derived the empty clause, it means that the core is trivial and the sequence of calls to the SAT solver can continue without adding any relaxation variables for this step. Otherwise, the transformed core is relaxed as in WPM1. The classical resolution rule can not be applied in MaxSAT because it does not preserve the equivalence among weighted formulae. The MaxSAT resolution rule used in WMSU1-ROR is called Max-RES and is described in[26]. The following definition extends the resolution rule from SAT to WMaxSAT.\nDefinition 4.7 (WPMaxSAT resolution). {(x \u2228 A, u), (\u00acx \u2228 B,w)} \u2261 {(A \u2228 B,m), (x \u2228 A, u m), (\u00acx \u2228 B,w m), (x \u2228 A \u2228 \u00acB,m), (\u00acx \u2228 \u00acA \u2228 B,m)}, where A and B are disjunctions and is defined on weights u,w \u2208 {0, . . . ,>}, such that u \u2265 w, as\nu w = { u\u2212 w u 6= > > u = >\nand m = min(u,w). The clauses (x\u2228A, u) and (\u00acx\u2228B,w) are called the clashing clauses, (A\u2228B,m) is called the resolvent, (x\u2228A, u m) and (\u00acx\u2228B,w m) are called posterior clashing clauses, (x \u2228 A \u2228 \u00acB,m) and (\u00acx \u2228 \u00acA \u2228 B,m) are the compensation clauses (which are added to recover an equivalent MaxSAT formula).\nFor example, if Max-RES is applied on {(x\u2228y, 3), (\u00acx\u2228y\u2228z, 4)} with > > 4, we obtain {(y \u2228 y \u2228 z, 3), (x \u2228 y, 3 3), (\u00acx \u2228 y \u2228 z, 4 3), (x \u2228 y \u2228 \u00ac(y \u2228 z), 3), (\u00acx \u2228 \u00acy \u2228 y \u2228 z, 3)}.\nThe first and fourth clauses can be simplified by observing that (A \u2228 C \u2228 \u00ac(C \u2228B), u) \u2261 (A\u2228C\u2228\u00acB, u). The second and fifth clauses can be deleted since the former has weight zero and the latter is a tautology. De Morgan\u2019s laws can not be applied on MaxSAT instance for not preserving the equivalence among instances[26]. The following rule can be applied instead (A \u2228 \u00ac(l \u2228C), w) \u2261 {(A \u2228 \u00acC), (A \u2228 \u00acl \u2228C,w)}. A resolution proof is an ordered set R = {Ci = (Ci\u2032 ./ Ci\u2032\u2032), Ci+1 = (Ci\u2032+1 ./ Ci\u2032\u2032+1), . . . , Ci+k = (Ci\u2032+k ./ Ci\u2032\u2032+k)}, where (Ci, wi) = (Ci\u2032 , wi\u2032) ./ (Ci\u2032\u2032 , wi\u2032\u2032) is the the resolution step i of a resolution proof, (Ci, wi) is the resolvent and (Ci\u2032 , wi\u2032) and (Ci\u2032\u2032 , wi\u2032\u2032) are the clashing clauses. The set of compensation clauses will be denoted [(Ci\u2032 , wi\u2032) ./ (Ci\u2032\u2032 , wi\u2032\u2032)].\nThe ROR approach is captured in lines 12-22 in algorithm 11. WMSU1-ROR handles WPMaxSAT formulae the same way as[4]. It maintains a working formula \u03c6W and a lower bound LB. The resolution proof RC is obtained in line 12 and MaxSAT resolution is applied (lines 14-21) for each read-once step. In detail, the weights of the clashing clauses (Ci\u2032 , wi\u2032) and (Ci\u2032\u2032 , wi\u2032\u2032) are decreased by the minimum weight of the clauses in the unsatisfiable core \u03c6C (lines 15-16). If the clashing clauses are soft, they are deleted from \u03c6C (lines 17-18) and if their resolvent is not , it is added to \u03c6C (lines 21-22). On the other hand, if the clashing clauses are hard, they are kept in the core because they could be used in a different resolution step. Lastly, the compensation and clashing clauses are added to \u03c6W (lines 19-20).\nAlgorithm 11: WMSU1-ROR(\u03c6)\nInput: A WPMaxSAT instance \u03c6 = {(C1, w1), . . . , (Cm, wm), (Cm+1,\u221e), . . . , (Cm+m\u2032 , wm+m\u2032)}\nOutput: The cost of the optimal solution to \u03c6 1 if SAT ({Ci | wi =\u221e}) = False then 2 return \u221e 3 \u03c6W \u2190 \u03c6 4 LB \u2190 0 5 while True do 6 (state, \u03c6C)\u2190 SAT (\u03c6W ) 7 if state = True then 8 return LB\n9 \u03c6W \u2190 \u03c6W \\ \u03c6C 10 m\u2190 min ({w | (C,w) \u2208 \u03c6C and w < >}) 11 LB \u2190 LB +m\n// Beginning of read-once resolution\n12 RC \u2190 GetProof(\u03c6C) 13 foreach (Ci, wi) = (Ci\u2032 , wi\u2032) ./ (Ci\u2032\u2032 , wi\u2032\u2032) \u2208 RC do 14 if ROR((Ci, wi), RC) then 15 (Ci\u2032 , wi\u2032)\u2190 (Ci\u2032 , wi\u2032 m) 16 (Ci\u2032\u2032 , wi\u2032\u2032)\u2190 (Ci\u2032\u2032 , wi\u2032\u2032 m) 17 if wi\u2032 < > and wi\u2032\u2032 < > then 18 \u03c6C \u2190 \u03c6C \\ {(Ci\u2032 , wi\u2032), (Ci\u2032\u2032 , wi\u2032\u2032)} 19 \u03c6W \u2190 \u03c6W \u222a {(Ci\u2032 , wi\u2032), (Ci\u2032\u2032 , wi\u2032\u2032)} 20 \u03c6W \u2190 \u03c6W \u222a {[(Ci\u2032 , wi\u2032) ./ (Ci\u2032\u2032 , wi\u2032\u2032)]} 21 if Ci 6= then 22 \u03c6C \u2190 \u03c6C \u222a {(Ci,m)}\n// End of read-once resolution\n23 B \u2190 \u2205 24 foreach (Ci, wi) \u2208 {(C,w) | (C,w) \u2208 \u03c6C and w < >} do 25 Let b be a new relaxation variable B \u2190 B \u222a {b} \u03c6C \u2190 \u03c6C \u222a {(C \u2228 b,m)} if w > m then 26 (C,w)\u2190 (C,w m) 27 else 28 \u03c6C \u2190 \u03c6C \\ {(C,w)}\n29 \u03c6c \u2190 \u03c6C \u222a CNF (\u2211 b\u2208B b = 1 ) 30 \u03c6W \u2190 \u03c6W \u222a \u03c6C\nHard((Ci, wi), R) (algorithm 12) returns True if (Ci, wi) is a hard clause and all its ancestors are hard, otherwise it returns False. Input((Ci, wi), R) (called in line 1) returns True if (Ci, wi) is not a resolvent of any step in R (i.e., an original clause), otherwise it returns False. ancestors((Ci, wi), R) (called in line 5) returns the pair of clauses (Ci\u2032 , wi\u2032) and (Ci\u2032\u2032 , wi\u2032\u2032) from which (Ci, wi) was derived as dictated by R.\nAlgorithm 12: Hard((Ci, wi), R) Determines if a clause is hard or not\nInput: A proof R Output: True if (Ci, wi) is hard, or False otherwise\n1 if Input((Ci, wi), R) and wi = > then 2 return True\n3 if Input((Ci, wi), R) and wi 6= > then 4 return False\n5 {(Ci\u2032 , wi\u2032), (Ci\u2032\u2032 , wi\u2032\u2032)} \u2190 ancestors((Ci, wi), R) 6 return Hard((Ci\u2032 , wi\u2032), R) and Hard((Ci\u2032\u2032 , wi\u2032\u2032), R)\nThe function ROR (algorithm 13) returns True if (Ci, wi) is hard or if it and all of its soft ancestors have been used at most once in the resolution proof R. If (Ck, wk) = (Ck\u2032 , wk\u2032) ./ (Ck\u2032\u2032 , wk\u2032\u2032), where (Ck, wk) is the last resolvent in a resolution proof R. The entire proof is read-once if ROR((Ck, wk), R) returns True. In this case (when the last step is ROR), the resolvent of that step is ( ,m). If this situation occurs, the algorithm does not need to augment clauses with relaxation variables or cardinality constraints, which improves upon the original algorithm.\nAlgorithm 13: ROR((Ci, wi), R) Determines if a clause is hard or not or if its ancestors are used at most once Input: A proof R Output: True if (Ci, wi) is hard or if its ancestors are used exactly once, False otherwise\n1 if Hard((Ci, wi), R) then 2 return True\n3 if Input((Ci, wi), R) and Used((Ci, wi), R) = 1 then 4 return True\n5 if Used((Ci, wi), R) > 1 then 6 return False\n7 {(Ci\u2032 , wi\u2032), (Ci\u2032\u2032 , wi\u2032\u2032)} \u2190 ancestors((Ci, wi), R) 8 return ROR((Ci\u2032 , wi\u2032), R) and ROR((Ci\u2032\u2032 , wi\u2032\u2032), R)\nThe problem with this approach (applying Max-RES instead of adding blocking variables and cardinality constraints) is that when soft clauses with weights greater than zero are resolved more than once, MaxSAT resolution does not ensure to produce resolvents with weights greater than zero. For this technique to work, the authors restrict the application of resolution to the case where each clause is used at most once, which is referred to as read-once resolution (ROR). Unfortunately, ROR can not generate resolution proofs for some unsatisfiable clauses[23]."}, {"heading": "4.6 WMSU3", "text": "WMSU3 is a WPMaxSAT algorithm that adds a single blocking variable per soft clause, thus limiting the number of variables in the formula sent to the SAT solver in each iteration.\nAlgorithm 14: WMSU3(\u03c6) The WMSU3 algorithm for WPMaxSAT.\nInput: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: The cost of the optimal WPMaxSAT solution to \u03c6\n1 if SAT ({C | (C,\u221e) \u2208 \u03c6H}) = False then 2 return \u221e 3 B \u2190 \u2205 // Set of blocking variables 4 \u03c6W \u2190 \u03c6 // Working formula initialized to \u03c6 5 LB \u2190 0 // Lower bound initialized to 0 6 while True do 7 (state, \u03c6C)\u2190 SAT ({C | (C,w) \u2208 \u03c6W } \u222a CNF ( \u2211 bi\u2208B wibi \u2264 LB)) 8 if state = True then 9 return LB\n10 foreach (Ci, wi) \u2208 \u03c6C \u2229 \u03c6S do 11 if w 6=\u221e then 12 B \u2190 B \u222a {bi} 13 \u03c6W \u2190 \u03c6W \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)}\n14 LB \u2190 UpdateBound({wi | bi \u2208 B}, LB)\nAlgorithm 14 begins by initializing the set of blocking variables that will be augmented later to \u2205 (line 3), the working formula to \u03c6 (line 4) and the lower bound to zero (line 5). MSU3 then loops over unsatisfiable working formulae \u03c6W (while loop in lines 6-13) until it finds a satisfiable one in line 8. At each iteration, when an unsatisfiable core is returned by the SAT solver, the algorithm adds one blocking variable to each soft clause that has not been augmented with a blocking variable yet (line 13), unlike WPMaxSAT algorithms discussed previously such as WPM1 (algorithm 7). Indeed, at most one blocking variable is added to each clause because if at iteration i Ci was blocked by bi, then at iteration i+1 the clause Ci \u2228 bi will not be in \u03c6C \u2229 \u03c6S . The function UpdateBound in line 14 updates the lower bound LB, either by simply incrementing it or by the subset sum problem as in[7]. The following example illustrates how the algorithm works.\nExample 4.3. Let \u03c6 = {(x1, 1), (x2, 3), (x3, 1)} \u222a {(\u00acx1 \u2228 \u00acx2,\u221e), (\u00acx2 \u2228 \u00acx3,\u221e)}.\n1. state = False, \u03c6C = {(x1), (x2), (\u00acx1 \u2228 \u00acx2)}, \u03c6C \u2229 \u03c6S = {(x1), (x2)}, \u03c6W = {(x1 \u2228 b1, 1), (x2 \u2228 b2, 2), (x3, 1), (\u00acx1 \u2228 \u00acx2,\u221e), (\u00acx2 \u2228 \u00acx3,\u221e)}, LB = 1.\n2. The constraint CNF (b1 + 3b2 \u2264 1) is included and satisfying it implies that b2 must be falsified, and thus CNF (b1 + 3b2 \u2264 1) is replaced by (\u00acb2). state = False, \u03c6C = {(x2\u2228b2), (x3), (\u00acx2\u2228\u00acx3), (\u00acb2)}, \u03c6C\u2229\u03c6S = {(x3)}, \u03c6W = {(x1\u2228b1, 1), (x2\u2228 b2, 2), (x3 \u2228 b3, 1), (\u00acx1 \u2228 \u00acx2,\u221e), (\u00acx2 \u2228 \u00acx3,\u221e)}, LB = 2. As in the previous iteration, satisfying the constraint b1 + 3b2 + b3 \u2264 2 implies b2 must be falsified.\n3. The constraint CNF (b1+3b2+b3 \u2264 2) is included, state = True and the assignment I = {x1 = False, x2 = True, x3 = False, b1 = True, b2 = False, b3 = True} indeed satisfies \u03c6W of the last iteration. By ignoring the values of the blocking variables, I is indeed an optimal assignment for \u03c6. It falsifies the soft clauses (x1, 1) and (x3, 1) and satisfies (x2, 3)."}, {"heading": "4.7 WMSU4", "text": "Like WMSU3, WMSU4[38] (algorithm 15) adds at most one blocking variable to each soft clause. Thought, it maintains an upper bound (UB) as well as a lower bound (LB). If the current working formula is satisfiable (line 9), UB is changed to the sum of the weights of the falsified clauses by the solution (I) returned from the SAT solver. On the other hand, if the working formula is unsatisfiable, the SAT solver returns an unsatisfiable core, and the algorithm adds a blocking variable to each clause that has not yet been relaxed in that core. If all the soft clauses in the unsatisfiable core have been relaxed (line 16), then the algorithm updates the lower bound (line 17) and exists the main loop. The following example illustrates how the algorithm works.\nAlgorithm 15: WMSU4(\u03c6) The WMSU4 algorithm for WPMaxSAT.\nInput: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: The cost of the optimal WPMaxSAT solution to \u03c6\n1 if SAT ({C | (C,\u221e) \u2208 \u03c6H}) = False then 2 return \u221e 3 B \u2190 \u2205 // Set of blocking variables 4 \u03c6W \u2190 \u03c6 // Working formula initialized to \u03c6 5 LB \u2190 \u22121 // Lower bound initialized to 0 6 UB \u2190 1 + \u2211|\u03c6S | i=1 wi // Upper bound initialized to the sum of the weights\nof the soft clauses plus one\n7 while UB > LB + 1 do 8 (state, \u03c6C , I)\u2190 SAT ({C | (C,w) \u2208 \u03c6W } \u222a CNF ( \u2211 bi\u2208B wibi \u2264 UB \u2212 1))\n9 if state = True then 10 UB \u2190 \u2211 bi\u2208B wi(1\u2212 I(Ci \\ bi)) // Update UB to the sum of the\nweights of the falsified clauses without the blocking variables\n11 else 12 foreach (Ci, wi) \u2208 \u03c6C \u2229 \u03c6S do 13 if w 6=\u221e then 14 B\u2032 \u2190 B\u2032 \u222a {bi} 15 \u03c6W \u2190 \u03c6W \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)}\n16 if B\u2032 = \u2205 then 17 LB \u2190 UB \u2212 1 18 else 19 B \u2190 B \u222aB\u2032 20 LB \u2190 UpdateBound({wi | bi \u2208 B}, LB)\n21 return UB\nExample 4.4. Let \u03c6 = \u03c6S \u222a \u03c6H , where \u03c6S = {(x1, 1), (x2, 1), (x3, 1), (x4, 1)} and \u03c6H = {(\u00acx1\u2228\u00acx2,\u221e), (\u00acx1\u2228\u00acx3,\u221e), (\u00acx1\u2228\u00acx4,\u221e), (\u00acx2\u2228\u00acx3\u2228\u00acx4,\u221e)}. Before the first iteration of the while loop, we have LB = \u22121, UB = 1+(1+1+1+1) = 5\nand \u03c6W = \u03c6.\n1. state = False, \u03c6C\u2229\u03c6S = {(x2), (x3), (x4)}, LB = 0, \u03c6W = {(x1, 1), (x2\u2228b2, 1), (x3\u2228 b3, 1), (x4 \u2228 b4, 1)} \u222a \u03c6H .\n2. The constraint CNF (b2 + b3 + b4 \u2264 5 \u2212 1) is included, state = True, I = {x1 = True, x2 = False, x3 = False, x4 = False, b2 = True, b3 = True, b4 = True}, UB = 3.\n3. The constraint CNF (b2 + b3 + b4 \u2264 3 \u2212 1) is included, state = False, \u03c6C \u2229 \u03c6S = {(x1, 1), (x2 \u2228 b2, 1), (x3 \u2228 b3, 1), (x \u2212 4 \u2228 b4, 1)}, LB = 1, \u03c6W = {(x1 \u2228 b1), (x2 \u2228 b2, 1), (x3 \u2228 b3, 1), (x\u2212 4 \u2228 b4, 1)} \u222a \u03c6H .\n4. The constraint CNF (b1 + b2 + b3 + b4 \u2264 2) is included, state = SAT , I = {x1 = False, x2 = False, x3 = True, x4 = True, b1 = True, b2 = True, b3 = False, b4 = False}, UB = 2. The cost of the optimal assignment is indeed 2 (since (x1, 1) and (x2, 1) are falsified) by I."}, {"heading": "5 Core-guided Binary Search Algorithms", "text": "Core-guided binary search algorithms are similar to binary search algorithms described in the first section, except that they do not augment all the soft clauses with blocking variables before the beginning of the main loop. Heras, Morgado and Marques-Silva proposed this technique in[22] (see algorithm 16).\nAlgorithm 16: CoreGuided-BS(\u03c6) Core-guided binary search algorithm for solving WPMaxSAT.\nInput: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: The cost of the optimal WPMaxSAT solution to \u03c6\n1 state\u2190 SAT ({Ci | (Ci,\u221e) \u2208 \u03c6H}) 2 if state = False then 3 return \u2205 4 \u03c6W \u2190 \u03c6 5 LB \u2190 \u22121 6 UB \u2190 1 + \u2211|\u03c6S | i=1 wi 7 B \u2190 \u2205 8 while LB + 1 < UB do 9 mid\u2190 bLB+UB2 c\n10 (state, \u03c6C , I)\u2190 SAT ({C | (C,w) \u2208 \u03c6W } \u222a CNF ( \u2211 bi\u2208B wibi \u2264 mid)) 11 if state = True then\n12 UB \u2190 \u2211|\u03c6S | i=1 wi(1\u2212 I(Ci \\ {bi})) 13 lastI \u2190 I 14 else 15 if \u03c6C \u2229 \u03c6S = \u2205 then 16 LB \u2190 UpdateBound({wi | bi \u2208 B},mid)\u2212 1 17 else 18 foreach (Ci, wi) \u2208 \u03c6C \u2229 \u03c6S do 19 let bi be a new blocking variable 20 B \u2190 B \u222a {bi} 21 \u03c6W \u2190 \u03c6W \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)}\n22 return lastI\nSimilar to other algorithms, CoreGuided-BS begins by checking the satisfiability of the hard clauses (lines 1-3). Then it initializes the lower bound (line 4), the upper bound (line 5) and the set of blocking variables (line 6) respectively to -1, one plus the sum of the weights of the soft clauses and \u2205. At each iteration of the main loop (lines 7-21) a SAT solver is called on the working formula with a constraint ensuring that the sum of the weights of the relaxed soft clauses is less than or equal the middle value (line 9). If the formula is satisfiable (line 10), the upper bound is updated to the sum of the falsified soft clauses by the current assignment (line 11). Otherwise, if all the soft clauses have been relaxed (line 14), then the lower bound is updated (line 15), and if not, non-relaxed sot clauses belonging to the core are relaxed (lines 17-19). The main loop continues as long as LB + 1 < UB.\nExample 5.1. Consider \u03c6 in example 2.1 with all the weights of the soft clauses set to 1. At the beginning of the algorithm LB = \u22121, UB = 8, B = \u2205 and \u03c6H is satisfiable. The following are the iterations the algorithm executes.\n1. mid = b\u22121+82 c = 3. Since B = \u2205, no constraint is included. state = False, \u03c6C \u2229 \u03c6S = {(x6), (\u00acx6)}, B = {b6, b7}. \u03c6 = {(x1, 1), (x2, 1), (x3, 1),\n(x4, 1), (x5, 1), (x6 \u2228 b6, 1), (\u00acx6 \u2228 b7, 1)} \u222a \u03c6H .\n2. mid = 3, the constraint CNF (b6 + b7 \u2264 3) is included. state = False, \u03c6C \u2229 \u03c6S = {(x1), (x2)}, B = {b1, b2, b6, b7}, \u03c6 = {(x1\u2228b1, 1), (x2\u2228b2, 1), (x3, 1), (x4, 1), (x5, 1), (x6\u2228 b6, 1), (\u00acx6 \u2228 b7, 1)} \u222a \u03c6H .\n3. mid = 3, the constraint CNF (b1 + b2 + b6 + b7 \u2264 3) is included. state = False, \u03c6C \u2229\u03c6S = {(x3), (x4)}, B = {b1, b2, b3, b4, b6, b7}, \u03c6 = {(x1 \u2228 b1, 1), (x2 \u2228 b2, 1), (x3 \u2228 b3, 1), (x4 \u2228 b4, 1), (x5, 1), (x6 \u2228 b6, 1), (\u00acx6 \u2228 b7, 1)} \u222a \u03c6H .\n4. mid = 3, the constraint CNF (b1 + b2 + b3 + b4 + b6 + b7 \u2264 3) is included. state = False, \u03c6C \u2229\u03c6S = {(x1 \u2228 b1), (x2 \u2228 b2), (x3 \u2228 b3), (x4 \u2228 b4), (x6 \u2228 b6), (\u00acx6 \u2228 b7), (x5)}, B = {b1, b2, b3, b4, b5, b6, b7}, \u03c6 = {(x1\u2228b1, 1), (x2\u2228b2, 1), (x3\u2228b3, 1), (x4\u2228b4, 1), (x5\u2228 b5, 1), (x6 \u2228 b6, 1), (\u00acx6 \u2228 b7, 1)} \u222a \u03c6H .\n5. mid = 3, CNF (b1 + b2 + b3 + b4 + b5 + b6 + b7 \u2264 3) is included. state = False, \u03c6C \u2229 \u03c6S = {(x1 \u2228 b1), (x2 \u2228 b2), (x3 \u2228 b3), (x4 \u2228 b4), (x5 \u2228 b5), (x6 \u2228 b6), (\u00acx6 \u2228 b7)}, LB = 3.\n6. mid = 5, the constraint CNF (b1+b2+b3+b4+b6+b7 \u2264 5) is included. state = True, I = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b4 = True, b5 = False, b6 = True, b7 = False}, UB = 4. The values of the xi, (1 \u2264 i \u2264 6) variables in I indeed constitute an optimal assignment.\nThe core-guided binary search approach was improved by Heras[22] et al. with disjoint cores (see definition 4.6).\nAlgorithm 17: DisjointCoreGuided-BS(\u03c6) Core-guided binary search extended with disjoint cores for solving WPMaxSAT.\nInput: A WPMaxSAT instance \u03c6 = \u03c6S \u222a \u03c6H Output: A WPMaxSAT solution to \u03c6\n1 if SAT ({C | (C,\u221e) \u2208 \u03c6H}) = False then 2 return \u2205 3 \u03c6W \u2190 \u03c6 4 C \u2190 \u2205 5 repeat 6 foreach Ci \u2208 C do 7 if LBi + 1 = UBi then 8 midi \u2190 UBi 9 else\n10 midi \u2190 bLBi+UBi2 c\n11 (state, \u03c6C , I)\u2190 SAT ({C | (C,w) \u2208 \u03c6W } \u222a \u22c3 Ci\u2208C CNF ( \u2211 bi\u2208B wibi \u2264 midi)) 12 if state = True then 13 lastI \u2190 I 14 foreach Ci \u2208 C do 15 UBi \u2190 \u2211 br\u2208B wr(1\u2212 I(Cr \\ {br})))\n16 else 17 subC \u2190 IntersectingCores(\u03c6C , C) 18 if \u03c6C \u2229 \u03c6S = \u2205 and |subC| = 1 then 19 LB \u2190 mid // subC = {(B,LB,mid, UB)} 20 else 21 foreach (Ci, wi) \u2208 \u03c6C \u2229 \u03c6S do 22 let bi be a new blocking variable 23 B \u2190 B \u222a {bi} 24 \u03c6W \u2190 \u03c6W \\ {(Ci, wi)} \u222a {(Ci \u2228 bi, wi)} 25 LB \u2190 0 26 UB \u2190 1 + \u2211 bi\u2208B wi 27 foreach (Bi, LBi,midi, UBi) \u2208 subC do 28 B \u2190 B \u222aBi 29 LB \u2190 LB + LBi 30 UB \u2190 UB + UBi 31 C \u2190 C \\ subC \u222a {(B,LB, 0, UB)}\n32 until \u2200Ci\u2208CUBi \u2264 LBi + 1 33 return lastI\nCore-guided binary search methods with disjoint unsatisfiable cores maintains smaller lower and upper bounds for each disjoint core instead of just one global lower bound and one global upper bound. Thus, the algorithm will add multiple smaller cardinality constraints on the sum of the weights of the soft clauses rather than just one global constraint.\nTo maintain the smaller constraints, the algorithm keep information about the previous cores in a set called C initialized to \u2205 (line 4) before the main loop. Whenever\nthe SAT solver returns False (line 12) it also provides a new core and a new entry Ci = (Bi, LBi,midi, UBi) is added in C for Ui, where Bi is the set of blocking variables associated with the soft clauses in Ui, LBi is a lower bound, midi is the current middle value and UBi is an upper bound. The main loop terminates when for each Ci \u2208 C, LBi + 1 \u2265 UBi (line 33). For each entry in C, its middle value is calculated (lines 6- 10) and a constraint for each entry is added to the working formula before calling the SAT solver on it (line 11). If the working formula is unsatisfiable (line 16), then, using IntersectiongCores, every core that intersects the current core is identified and its corresponding entry is added to subC (line 17). If the core does not contain soft clauses that need to be relaxed and |subC| = 1 (line 18), then LB is assigned the value of the midpoint (line 19). On the other hand, if there exists clauses that has not been relaxed yet then the algorithm relaxes them (lines 21-24) and a new entry for the current core is added to C which accumulates the information of the previous cores in subC (lines 25-31).\nExample 5.2. Consider \u03c6 in example 2.1 with all the weights of the soft clauses set to 1. At the beginning of algorithm 17, we have \u03c6W = \u03c6 and C = \u2205. The following are the iterations the algorithm executes.\n1. No constraints to include. state = False, \u03c6C \u2229 \u03c6S = {(x6), (\u00acx6)}, subC = \u2205, B = {b6, b7}, \u03c6W = {(x1), (x2), (x3), (x4), (x5), (x6 \u2228 b6), (\u00acx6 \u2228 b7)} \u222a \u03c6H , LB = 0, UB = 3, C = {({b6, b7}, 0, 0, 3)}.\n2. The constraint CNF (b6+b7 \u2264 1) is included. state = False, \u03c6C\u2229\u03c6S = {(x1), (x2)}, subC = \u2205, B = {b1, b2}. \u03c6W = {(x1 \u2228 b1), (x2 \u2228 b2), (x3), (x4), (x5), (x6 \u2228 b6), (\u00acx6 \u2228 b7)} \u222a \u03c6H , LB = 0, UB = 3, C = {({b6, b7}, 0, 0, 3), ({b1, b2}, 0, 0, 3)}.\n3. The constraints {CNF (b6+b7 \u2264 1), CNF (b1+b2 \u2264 1)} are included. state = False, \u03c6C \u2229 \u03c6S = {(x3), (x4)}, subC = \u2205, B = {b3, b4}, \u03c6W = {(x1 \u2228 b1), (x2 \u2228 b2), (x3 \u2228 b3), (x4\u2228b4), (x5), (x6\u2228b6), (\u00acx6\u2228b7)}\u222a\u03c6H , LB = 0, UB = 3, C = {({b6, b7}, 0, 0, 3), ({b1, b2}, 0, 0, 3), ({b3, b4}, 0, 0, 3)}.\n4. The constraints {CNF (b6 + b7 \u2264 1), CNF (b1 + b2 \u2264 1), CNF (b3 + b4 \u2264 1)} are included. state = False, \u03c6C \u2229 \u03c6S = {(x1 \u2228 b1), (x2 \u2228 b2), (x3 \u2228 b3), (x4 \u2228 b4), (x5)}, subC = {({b1, b2}, 0, 0, 3), ({b3, b4}, 0, 0, 3)}, B = {b1, b2, b3, b4, b5}, \u03c6W = {(x1 \u2228 b1), (x2 \u2228 b2), (x3 \u2228 b3), (x4 \u2228 b4), (x5 \u2228 b5), (x6\u2228b6), (\u00acx6\u2228b7)}\u222a\u03c6H , LB = 0, UB = 8, C = {({b6, b7}, 0, 0, 3), ({b1, b2, b3, b4, b5}, 0, 0, 8)}.\n5. The constraints CNF (b6 + b7 \u2264 1), CNF (b1 + b2 + b3 + b4 + b5 \u2264 4) are included. state = True, I = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b3 = True, b5 = False, b6 = True, b7 = False}, C = {({b6, b7}, 0, 0, 1), ({b1, b2, b3, b4, b5}, 0, 0, 2)}.\n6. The constraints CNF (b6 + b7 \u2264 1), CNF (b1 + b2 + b3 + b4 + b5 \u2264 1) are included. state = False, \u03c6C \u2229\u03c6S = {(x1 \u2228 b1), (x2 \u2228 b2), (x3 \u2228 b3), (x4 \u2228 b4), (x5 \u2228 b5)}, subC = {({b1, b2, b3, b4, b5}, 0, 0, 2)}, C = {({b6, b7}, 0, 0, 1), ({b1, b2, b3, b4, b5}, 1, 0, 2)}.\n7. state = True, I = {x1 = False, x2 = False, x3 = True, x4 = False, x5 = True, x6 = False, b1 = True, b2 = True, b3 = False, b4 = True, b5 = False, b6 = True, b7 = False}.\nSAT-based WPMaxSAT solvers rely heavily on the hardness of the SAT formulae returned by the underlying SAT solver used. Obviously, the location of the optimum solution depends on the structure of the instances returned and the number of iterations it takes to switch from True to False (or from False to True)."}, {"heading": "6 Portfolio MaxSAT Techniques", "text": "The results of the MaxSAT Evaluations suggest there is no absolute best algorithm for solving MaxSAT. This is because the most efficient solver often depends on the type of instance. In other words, different solution approaches work well on different families of instances[40]. Having an oracle able to predict the most suitable MaxSAT solver for a given instance would result in the most robust solver. The success of SATzilla[59] for SAT was due to a regression function which was trained to predict the performance of every solver in the given set of solvers based on the features of an instance. When faced with a new instance, the solver with the best predicted runtime is run on the given instance. The resulting SAT portfolios excelled in the SAT Competitions in 2007 and in 2009 and pushed the state-of-the-art in SAT solving. When this approach is extended to (WP)MaxSAT, the resulting portfolio can achieve significant performance improvements on a representative set of instances.\nISAC[9] (Instance-Specific Algorithm Configuration) is one of the most successful WPMaxSAT portfolio algorithms. It works by computing a representative feature vector that characterizes the given input instance in order to identify clusters of similar instances. The data is therefore clustered into non-overlapping groups and a single solver is selected for each group based on some performance characteristic. Given a new instance, its features are computed and it is assigned to the nearest cluster. The instance is then solved by the solver assigned to that cluster."}, {"heading": "7 Translating Pseudo-Boolean Constraints into CNF", "text": "This section discusses translating pseudo-Boolean (PB) constraints into CNF. The procedure is needed in almost every SAT-based WPMaxSAT algorithm and its efficiency surely affects the overall performance of the solver."}, {"heading": "7.1 Introduction", "text": "A PB constraint is a linear constraint over Boolean variables. PB constraints are intensively used in expressing NP-hard problems. While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].\nDefinition 7.1 (PB constraint). A PB constraint is an inequality (equality) on a linear combination of Boolean literals li\nn\u2211 i=1 aili{<,\u2265,=,\u2264, >}K\nwhere a1, . . . , an and K (called the bound) are constant integers and l1, . . . , ln are literals.\nThere are at least two clear benefits of solving PB constraints by encoding them into CNF. First, high-performance SAT solvers are being enhanced continuously, and since they take a standard input format there is always a selection of good solvers to make use of. Second, solving problems involving Boolean combinations of constraints is straightforward. This approach is particularly attractive for problems which are naturally represented by a relatively small number of PB constraints (like the Knapsack problem) together which a large number of purely Boolean constraints."}, {"heading": "7.2 Encoding method", "text": "We present the method of Bailleux, Boufkhad and Roussel[13]. In their paper, they consider (without loss of generality) PB constraints of the form \u2211n i=1 aili \u2264 K, where a1 \u2264 a2 \u2264 \u00b7 \u00b7 \u00b7 \u2264 an. This type of constraint is denoted by the triple \u3008An, Ln,K\u3009, where An = (a1, . . . , an) and Ln = (l1, . . . , ln). For some bound b, the triple \u3008Ai, Li, b\u3009, for 1 \u2264 i \u2264 n, represents the PB constraint aili + a2l2 + \u00b7 \u00b7 \u00b7 + aili \u2264 b. When the tuples An and Ln are fixed, a triple \u3008Ai, Li, b\u3009 representing a PB constraint is defined with no ambiguity by the integer i and the bound b.\nFor each \u3008Ai, Li, b\u3009, a new variable Di,b is introduced. This new variable represents the satisfaction of the constraint \u3008Ai, Li, b\u3009, i.e., Di,b = True if and only if \u3008Ai, Li, b\u3009 is satisfied. The variable Dn,K represents \u3008An, Ln,K\u3009 and the correctness of the encoding is conditioned by the fact that an assignment satisfies \u3008An, Ln,K\u3009 if and only if it satisfies the encoded CNF formula and fixes Dn,K to True.\nThe variables Di,b such that b \u2264 0 or b \u2265 \u2211i j=1 aj are called terminal variables.\nThe encoding starts with a set of variables containing the original variables PB constraint and the variable Dn,K . The variables li are marked. At each step, an unmarked variable Di,b is considered. If Di,b is not terminal the two variables Di\u22121,b and Di\u22121,b\u2212ai are added to the set of variables if they are not already in it and the following four clauses are added\n(\u00acDi\u22121,b\u2212ai \u2228Di,b), (Di,b \u2228Di\u22121,b), (Di,b \u2228 li \u2228Di\u22121,b\u2212ai), (Di\u22121,b \u2228 li \u2228Di,b)\nNext, Di,b is marked so it won\u2019t be considered again. In case that Di,b is a terminal variable, then by definition either b \u2264 0 or b \u2265 \u2211i j=1 aj\nand Di,b is fixed as follows\nDi,b = { False if b < 0. The clause \u00acDi,b is added to the formula. True if \u2211i j=1 aj \u2264 b. The clause Di,b is added to the formula.\nWhen b = False, every variable in the constraint must be set to False. To achieve this, for every 1 \u2264 j \u2264 i, the clauses (Di,0\u2228lj) are added together with the clause (l1\u2228l2\u2228\u00b7 \u00b7 \u00b7\u2228Di,0). The procedure stops when there are no more unmarked variables.\nExample 7.1. This example illustrates the encoding of the PB constraint 2x1+3x2+4x3 \u2264 6. The formula \u03c6 = {(\u00acD2,2 \u2228 D3,6), (\u00acD3,6 \u2228 \u00acx3 \u2228 D2,2), (\u00acD2,6 \u2228 x3 \u2228 D3,6), (D2,6 \u2228 \u00acD1,\u22121\u2228D2,2), (\u00acD2,2\u2228D1,2), (\u00acD2,2\u2228\u00acx2\u2228D1,\u22121), (\u00acD1,2\u2228x2\u2228D2,2), (D1,2), (\u00acD1,\u22121)}. Thus, D3,6 = True only if at least one of x2 or x3 is False.\nThe correctness and the complexity of the encoding are discussed in the same paper[13]."}, {"heading": "7.3 Complexity of the encoding", "text": "The complexity of the encoding is measured in terms of the number of variables. The number of clauses produced is related by a constant factor to the number of variables. There are cases where the previous procedure produces a polynomial and others that produce an exponential number of variables."}, {"heading": "7.3.1 Polynomial cases", "text": "The encoding seems to generate an exponential number of variables: at each step a nonterminal variable creates two variables that will in turn create two other variables each and so on. However, this is not true for terminal variables and for variables that have already been considered by the procedure. When a terminal variable is met, it is said to be a cut in the procedure and when a variable already in the set of variables is met, it is said to have merged in the procedure. By the cuts and merges, the size of encodings can be polynomial in some cases. There are two restrictions on the PB constraint for it to have a polynomial-size encoding:\n1. The integers ai\u2019s are bounded by a polynomial in n, P (n). In this case, the potential number of Di,b variables for some i is 2\nn\u2212i but because of the merges, this number reduces to a polynomial since the variables Di,b for some i are such that m \u2264 b \u2264M where m is at least equal to K \u2212 \u2211i j=0 an\u2212j and M \u2264 K, b can take at most M?m\ndifferent values and then it can take at most \u2211i j=0 an?j different values, which is bounded by (n \u2212 i)P (n). Since there are n different possible values for i, the total number of variables is bounded by a polynomial in n. Figure 1 shows an example of this case.\n2. The weights are ai = \u03b1i where \u03b1 \u2265 2. In this case, for every non terminal variable Di,b considered in the procedure, at least one of the variables Di\u22121,b or Di\u22121,b?\u03b1i is a terminal variable. This is true because \u2211i?1 j=0 \u03b1\nj < \u03b1i. Either b \u2265 \u03b1i and then \u2211i\u22121 j=0 \u03b1 j < b and then Di\u22121,b is a terminal variable or b < \u03b1 i and in this case Di\u22121,b\u2212\u03b1i is a terminal variable. Thus, there is a cut each time a variable is considered in the procedure. Figure 2 shows an example for this case."}, {"heading": "7.3.2 Exponential cases", "text": "There are possible sequences of ai\u2019s that will give a tree with branches of length \u2126(n) and with no possible merge of nodes (which implies a tree of size \u2126(2n)). The idea here is simply to combine a constant sequence with a geometric sequence. Let n be the length of the PB constraint Q and let ai = \u03b1 + b\ni such that \u03b1 = bn+2. The key point is that the geometric term must be negligible compared to the constant term, that is \u2211n i=0 b\ni < \u03b1. For simplicity, we will choose b = 2. Note that in this case, ai = 2\nn+2 + 2i which is not bounded by a polynomial in n. Fix K = \u03b1\u00d7 n2 = n\u00d7 2 n+1.\nA terminal node is reached when we get a term Di,k such that k \u2264 0 or k \u2265 \u2211i j=1 aj . Because the constant term is predominant, the first condition cannot be met before i = K \u03b1 = n 2 . The earliest case where the second condition can be satisfied is when k remains\nequal to K. We have \u2211i j=1 aj = \u2211i j=1 \u03b1 + b j = \u03b1 \u00d7 i + \u2211i j=1 b\nj \u2265 \u03b1 \u00d7 i. Therefore, the earliest case where the second condition can be met is when \u03b1 \u00d7 n2 = \u03b1 \u00d7 i which means i = n2 . We can conclude that each branch is at least of length n 2 .\nIn addition, in the encoding, each node of the tree holds the term Di,k which corresponds to \u2211i j=1 ajxj \u2264 K \u2212 \u2211 j\u2208S aj , where S \u2282 [i + 1..n]. One key point is that in the\nbinary representation of K \u2212 \u2211 j\u2208S aj , the n least significant bits directly correspond to the indices in S. Therefore, these n least significant bits of the right term are necessarily different from one node to another. For this reason, no node can be merged. Because of this and since branches are of length at least equal to n2 , the size of the tree is at least 2 n 2 and the encoding of this particular constraint is of exponential size."}, {"heading": "7.4 Other encoding techniques", "text": "Incremental approaches[42, 39, 47] allow the constraint solver to retain knowledge from previous iterations that may be used in the upcoming iterations. The goal is to retain the inner state of the constraint solver as well as learned clauses that were discovered during the solving process of previous iterations. At each iteration, most MaxSAT algorithms create a new instance of the constraint solver and rebuild the formula losing most if not all the knowledge that could be derived from previous iterations."}, {"heading": "8 Experimental Investigation", "text": "We conducted an experimental investigation in order to compare the performance of different WPMaxSAT solvers to branch and bound solvers on a number of benchmarks instances.\nExperimental evaluations of MaxSAT solvers has gained great interest among SAT and MaxSAT researchers. This is due to the fact that solvers are becoming more and more efficient and adequate to handle WPMaxSAT instances coming from real-life applications. Thus, carrying out such an investigation and comparing the efficiency of different solvers is critical to knowing which solving technique is suitable for which category of inputs. In fact, an annual event called the MaxSAT Evaluations is scheduled just for this purpose. The first MaxSAT Evaluation was held in 2006. The objective of the MaxSAT Evaluation is comparing the performance of state of the art (weighted) (partial) MaxSAT solvers on a number of benchmarks and declaring a winner for each benchmark category.\nThe solvers that we investigate participated in the MaxSAT Evaluations of 2013 and 2014. A number of the solvers are available online while some of them were not and we had to contact the authors to get a copy. The benchmarks we used participated in the 2013 MaxSAT Evaluation and are WPMaxSAT instances of three categories: random, crafted and industrial.\nThe solvers were run on a machine with an IntelrCoreTM i5 CPU clocked at 2.4GHz, with 5.7GB of RAM running elementary OS Linux. The timeout is set to 1000 seconds and running the solvers on the benchmarks took roughly three months. We picked elementaryOS because it does not consume too many resources to run and thus giving enough room for the solvers to run. In addition, elementaryOS is compatible with popular Ubuntu distribution which makes it compatible with its repositories and packages."}, {"heading": "8.1 Solvers descriptions", "text": "The solvers we experimented with are:\n1. WMiFuMax is an unsatisfiability-based WPMaxSAT solver based on the technique of Fu and Malik[18] and on the algorithm by Manquinho, Marques-Silva, and Planes[32], which is works by identifying unsatisfiable sub-formulae. MiFuMax placed third in the WPMaxSAT industrial category of the 2013 MaxSAT evaluation. The solver (and the source code) is available online under the GNU General Public License. The SAT solver used is called MiniSAT[54]. Author: Mikola\u0301s\u030c Janota.\n2. QWMaxSAT is a weighted version of QMaxSAT developed by Koshimura, Zhang, Fujita and Hasegawa[25] and is available freely online. This solver is a satisfiabilitybased solver built on top of version 2.0 of the SAT solver MiniSAT[16]. The authors of QMaxSAT modified only the top-level part of MiniSat to manipulate cardinality constraints, and the other parts remain unchanged. Despite originally being a PMaxSAT solver, the authors developed a version of the solver for WPMaxSAT in 2014. Authors: Miyuki Koshimura, Miyuki Koshimura, Hiroshi Fujita and Ryuzo Hasegawa.\n3. Sat4j[27] is a satisfiability-based WPMaxSAT solver developed by Le Berre and Parrain. The solver works by translating WPMaxSAT instances into pseudo-Boolean optimization ones. The idea is to add a blocking variable per weighted soft clause that represents that such clause has been violated, and to translate the maximization\nproblem on those weighted soft clauses into a minimization problem on a linear function over those variables. Given a WPMaxSAT instance \u03c6 = {(C1, w1), . . . , (Cn, wn)}\u222a \u03c6H , Sat4j translates \u03c6 into \u03c6\n\u2032 = {(C1 \u2228 b1), . . . , (Cn \u2228 bn)} plus an objective function min : \u2211n i=1 wibi. Sat4j avoids adding blocking variables to both hard and unit clauses. the Sat4j framework includes the pseudo-Boolean solver Sat4j-PB-Res which is used to solve the encoded WPMaxSAT problem. Authors: Daniel Le Berre and Emmanuel Lonca.\n4. MSUnCore[35] is an unsatisfiability-based WPMaxSAT solver built on top the SAT solver PicoSAT[14]. This solver implements a number of algorithms capable of solving MaxSAT, PMaxSAT and W(P)MaxSAT. MSUnCore uses PicoSAT for iterative identification of unsatisfiable cores with larger weights. Although ideally a minimal core would be preferred, any unsatisfiable core can be considered. Clauses in identified core are then relaxed by adding a relaxation variable to each clause. Cardinality constraints are encoded using several encodings, such as the pairwise and bitwise encodings[49, 48], the ladder encoding[20], sequential counters[53], sorting networks[17], and binary decision diagrams (BDDs)[17]. Authors: Anto\u0301nio Morgado, Joao Marques-Silva, and Federico Heras.\n5. Maxsatz2013f is a very successful branch and bound solver that placed first in the WPMaxSAT random category of the 2013 MaxSAT evaluation. It is based on an earlier solver called Maxsatz[28], which incorporates the technique developed for the famous SAT solver, Satz[29]. At each node, it transforms the instance into an equivalent one by applying efficient refinements of unit resolution ((A\u2228B) and (\u00acB) yield A) which replaces {(x), (y), (\u00acx\u2228\u00acy)} with { , (x\u2228y)} and {(x), (\u00acx\u2228y), (\u00acx\u2228 z), (\u00acy\u2228\u00acz)} with { , (\u00acx\u2228y\u2228z), (x\u2228\u00acy\u2228\u00acz)}. Also, it implements a lower bound method (enhanced with failed literal detection) that increments the lower bound by one for every disjoint inconsistent subset that is detected by unit propagation. The variable selection heuristics takes into account the number of positive and negative occurrences in binary and ternary clauses. Maxsatz2013f is available freely online. Authors: Chu Min Li, Yanli LIU, Felip Manya\u0300, Zhu Zhu and Kun He.\n6. WMaxSatz-2009 and WMaxSatz+[31, 30] are branch and bound solvers that use transformation rules[28] which can be implemented efficiently as a by-product of unit propagation or failed literal detection. This means that the transformation rules can be applied at each node of the search tree. Authors: Josep Argelich, Chu Min Li, Jordi Planes and Felip Manya\u0300.\n7. ISAC+[9] (Instance-Specific Algorithm Configuration) is a portfolio of algorithm which, given a WPMaxSAT instance, selects the solver better suited for that instance. A regression function is trained to predict the performance of every solver in the given set of solvers based on the features of an instance. When faced with a new instance, the solver with the best predicted runtime is run on the given instance. ISAC+ uses a number of branch and bound solvers as well as SAT-based, including QMaxSAT, WMaxSatz-2009 and WMaxSatz+. Authors: Carlos Anso\u0301tegui, Joel Gabas, Yuri Malitsky and Meinolf Sellmann.\nSummary Technique Solver name Sub-technique\nSatisfiability-based WMiFuMax SAT-based QWMaxSAT SAT-based Sat4j SAT-based MSUnCore UNSAT-based Branch and bound Maxsatz2013f WMaxSatz-2009 WMaxSatz+ Portfolio ISAC+"}, {"heading": "8.2 Benchmarks descriptions", "text": "The benchmarks we used are the WPMaxSAT instances of the 2013 MaxSAT Evaluation and are divided into three categories:\n1. Random: This category consists of WPMax-2-SAT and WPMax-3-SAT instances generated uniformly at random. The WPMax-2-SAT instances are divided into formulae with low (lo), medium (me) and high (hi) numbers of variables and clauses. The WPMax-3-SAT instances contain three literals per clause and have a high number of variables and clauses.\n2. Crafted: These instances are specifically designed to give a hard time to the solver. There is an award for the smallest instance that can not be solved by any solver.\n3. Industrial: Consists of instances that come from various applications of practical interest, such as model checking, planning, encryption, bio-informatics, etc. encoded into MaxSAT. This category is intended to provide a snapshot of the current strength of solvers as engines for SAT-based applications.\nIn the MaxSAT Evaluations, a first, second and third place winners are declared for each of the three categories."}, {"heading": "8.3 Results", "text": "In this section, the results we obtained are presented and discussed. For each category, we present the constituting sets of instances and their sizes, the number of instances solved by each solver and the amount of time it took each solver to work on each set of instances."}, {"heading": "8.3.1 Random category", "text": "The three sets of instances in the random category are:\nName Abbreviation # of instances wpmax2sat-lo lo 30 wpmax2sat-me me 30 wpmax2sat-hi hi 30 wpmax3sat-hi 3hi 30\nThe branch and bound solvers MaxSatz2013f, WMaxSatz-2009 and WMaxSatz+ performed considerably better than the SAT-based solvers in the random category. In particular, MaxSatz2013f finished the four benchmarks under 16 minutes, while WMiFuMax, MSUnCore and Sat4j timedout on most instances. MaxSatz2013f placed first in the random category in the 2013 MaxSAT Evaluation, see http://www.maxsat.udl.cat/13/results/ index.html#wpms-random-pc. The top non branch and bound solver is ISAC+, which placed third in the random category in 2014 (see http://www.maxsat.udl.cat/14/results/index.html# wpms-random-pc)."}, {"heading": "8.3.2 Crafted category", "text": "The seven sets of instances in the crafted category are:\nAs it can be noticed from the results, ISAC+ is the winner of the crafted category. Indeed, the winner of this category in the 2014 MaxSAT Evaluation is ISAC+ (see http://www.maxsat.udl.cat/14/results/index.html#wpms-crafted), and in the 2013 evaluation it placed second (see http://www.maxsat.udl.cat/13/results/index.html#wpms-crafted-pc). Generally, SAT-based and branch and bound solvers perform nearly equally on crafted instances."}, {"heading": "8.3.3 Industrial category", "text": "The seven sets of instance in the industrial category are:\nName Abbreviation # of instances wcsp/spot5/dir wcsp-dir 21 wcsp/spot5/log wcsp-log 21 haplotyping-pedigrees HT 100 upgradeability-problem UP 100 preference planning PP 29 packup-wpms PWPMS 99 timetabling TT 26\nIt is clear that SAT-based solvers outperform branch and bound ones on industrial\ninstances. The winner solver of this category in the 2013 MaxSAT evaluation is ISAC+ (see http://www.maxsat.udl.cat/13/results/index.html#wpms-industrial) and the same solver placed second in the 2014 evaluation (see http://www.maxsat.udl.cat/14/results/index.html# wpms-industrial-pc).\nGenerally, we can notice that on industrial instances, SAT-based solvers are performed considerably better than branch and bound solvers which performed poorly. On the other hand, branch and bound solvers outperformed SAT-based ones on random instances."}, {"heading": "9 Acknowledgments", "text": "This paper is made possible through the help and support from Dr. Hassan Aly (Department of Mathematics, Cairo University, Egypt) and Dr. Rasha Shaheen (Department of Mathematics, Cairo University, Egypt). I would also like to thank Dr. Carlos Anso\u0301tegui (University of Lleida, Spain) for his advice to include a section on translating pseudo Boolean constraints and his encouraging review of this work."}], "references": [{"title": "Translating pseudo-boolean constraints into cnf", "author": ["Amir Aavani"], "venue": "Theory and Applications of Satisfiability Testing-SAT", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2011}, {"title": "New encoding for translating pseudo-boolean constraints into sat", "author": ["Amir Aavani", "David G Mitchell", "Eugenia Ternovska"], "venue": "In SARA,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Qmaxsat version", "author": ["Xuanye An", "Miyuki Koshimura", "Hiroshi Fujita", "Ryuzo Hasegawa"], "venue": "Proceedings of the International Workshop on First-Order Theorem Proving,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "Solving (weighted) partial maxsat through satisfiability testing", "author": ["Carlos Ans\u00f3tegui", "Ma\u0155\u0131a Bonet", "Jordi Levy"], "venue": "Theory and Applications of Satisfiability Testing-SAT", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Improving satbased weighted maxsat solvers", "author": ["Carlos Ans\u00f3tegui", "Maria Luisa Bonet", "Joel Gab\u00e0s", "Jordi Levy"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2012}, {"title": "Improving wpm2 for (weighted) partial maxsat", "author": ["Carlos Ans\u00f3tegui", "Maria Luisa Bonet", "Joel Gab\u00e0s", "Jordi Levy"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2013}, {"title": "A new algorithm for weighted partial maxsat", "author": ["Carlos Ans\u00f3tegui", "Maria Luisa Bonet", "Jordi Levy"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Sat-based maxsat algorithms", "author": ["Carlos Ans\u00f3tegui", "Maria Luisa Bonet", "Jordi Levy"], "venue": "Artificial Intelligence,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2013}, {"title": "Maxsat by improved instance-specific algorithm configuration", "author": ["Carlos Ans\u00f3tegui", "Yuri Malitsky", "Meinolf Sellmann"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2014}, {"title": "The first and second max-sat evaluations", "author": ["Josep Argelich", "Chu Min Li", "Felip Manya", "Jordi Planes"], "venue": "JSAT, 4(2-4):251\u2013278,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "Curriculum-based course timetabling with sat and maxsat", "author": ["Roberto A\u015b\u0131n Ach\u00e1", "Robert Nieuwenhuis"], "venue": "Annals of Operations Research,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2012}, {"title": "Efficient cnf encoding of boolean cardinality constraints", "author": ["Olivier Bailleux", "Yacine Boufkhad"], "venue": "In Principles and Practice of Constraint Programming\u2013CP", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2003}, {"title": "A translation of pseudoboolean constraints to sat", "author": ["Olivier Bailleux", "Yacine Boufkhad", "Olivier Roussel"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2006}, {"title": "Postponing optimization to speed up maxsat solving", "author": ["Jessica Davies", "Fahiem Bacchus"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2013}, {"title": "Minisat: A sat solver with conflict-clause", "author": ["Niklas Een", "Niklas S\u00f6rensson"], "venue": "minimization. Sat,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2005}, {"title": "Translating pseudo-boolean constraints into sat", "author": ["Niklas E\u00e9n", "Niklas S\u00f6rensson"], "venue": "JSAT, 2(1-4):1\u201326,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2006}, {"title": "On solving the partial max-sat problem", "author": ["Zhaohui Fu", "Sharad Malik"], "venue": "Theory and Applications of Satisfiability Testing-SAT", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2006}, {"title": "Arc consistency in sat", "author": ["Ian P Gent"], "venue": "In ECAI,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2002}, {"title": "A new encoding of alldifferent into sat", "author": ["Ian P Gent", "Peter Nightingale"], "venue": "In Proc. 3rd International Workshop on Modelling and Reformulating Constraint Satisfaction Problems,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2004}, {"title": "Read-once resolution for unsatisfiabilitybased max-sat algorithms", "author": ["Federico Heras", "Joao Marques-Silva"], "venue": "In Proceedings of the Twenty-Second international joint conference on Artificial Intelligence-Volume Volume One,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2011}, {"title": "Core-guided binary search algorithms for maximum satisfiability", "author": ["Federico Heras", "Antonio Morgado", "Joao Marques-Silva"], "venue": "In Proceedings of the AAAI National Conference (AAAI),", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2011}, {"title": "Intractability of read-once resolution", "author": ["Kazuo Iwama", "Eiji Miyano"], "venue": "In Structure in Complexity Theory Conference,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1995}, {"title": "Packup: Tools for package upgradability solving system description", "author": ["Mikol\u00e1\u0161 Janota", "In\u00eas Lynce", "Vasco Manquinho", "Joao Marques-Silva"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2012}, {"title": "Qmaxsat: A partial max-sat solver system description", "author": ["Miyuki Koshimura", "Tong Zhang", "Hiroshi Fujita", "Ryuzo Hasegawa"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2012}, {"title": "A logical approach to efficient max-sat solving", "author": ["Javier Larrosa", "Federico Heras", "Simon de Givry"], "venue": "Artificial Intelligence,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2008}, {"title": "The sat4j library, release 2.2 system description", "author": ["Daniel Le Berre", "Anne Parrain"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2010}, {"title": "Exploiting cycle structures in max-sat", "author": ["Chu Li", "Felip Many\u00e0", "Nouredine Mohamedou", "Jordi Planes"], "venue": "Theory and Applications of Satisfiability Testing-SAT", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2009}, {"title": "Heuristics based on unit propagation for satisfiability problems", "author": ["Chu Min Li", "Anbulagan Anbulagan"], "venue": "In Proceedings of the 15th international joint conference on Artifical intelligence-Volume", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1997}, {"title": "Resolutionbased lower bounds in maxsat", "author": ["Chu Min Li", "Felip Many\u00e0", "Nouredine Ould Mohamedou", "Jordi Planes"], "venue": null, "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2010}, {"title": "New inference rules for max-sat", "author": ["Chu Min Li", "Felip Many\u00e0", "Jordi Planes"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2007}, {"title": "Algorithms for weighted boolean optimization", "author": ["Vasco Manquinho", "Joao Marques-Silva", "Jordi Planes"], "venue": "Theory and Applications of Satisfiability Testing-SAT", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2009}, {"title": "A more compact translation of pseudo-boolean constraints into cnf such that generalized arc consistency is maintained", "author": ["Norbert Manthey", "Tobias Philipp", "Peter Steinke"], "venue": "In KI 2014: Advances in Artificial Intelligence,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2014}, {"title": "Timetabling based on sat encoding: a case study", "author": ["Filip Maric"], "venue": null, "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2008}, {"title": "The msuncore maxsat solver. SAT 2009 competitive events booklet: preliminary version, page", "author": ["Joao Marques-Silva"], "venue": null, "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2009}, {"title": "Towards robust cnf encodings of cardinality constraints. Principles and Practice of Constraint Programming\u2013CP", "author": ["Joao Marques-Silva", "In\u00eas Lynce"], "venue": null, "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "On using unsatisfiability for solving maximum satisfiability", "author": ["Joao Marques-Silva", "Jordi Planes"], "venue": "arXiv preprint arXiv:0712.1097,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2007}, {"title": "Algorithms for maximum satisfiability using unsatisfiable cores", "author": ["Joao Marques-Silva", "Jordi Planes"], "venue": "In Proceedings of the conference on Design, automation and test in Europe,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2008}, {"title": "Incremental cardinality constraints for maxsat", "author": ["Ruben Martins", "Saurabh Joshi", "Vasco Manquinho", "In\u00eas Lynce"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2014}, {"title": "A max-sat algorithm portfolio1", "author": ["Paulo Matos", "Jordi Planes", "Florian Letombe", "Joao Marques-Silva"], "venue": null, "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2008}, {"title": "A pso algorithm to solve a real course+ exam timetabling problem", "author": ["Elizabeth Montero", "Ma\u0155\u0131a-Cristina Riff", "Leopoldo Altamirano"], "venue": "In International Conference on Swarm Intelligence,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2001}, {"title": "Core-guided maxsat with soft cardinality constraints", "author": ["Antonio Morgado", "Carmine Dodaro", "Joao Marques-Silva"], "venue": "In Principles and Practice of Constraint Programming,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2014}, {"title": "Iterative and core-guided maxsat solving: A survey and assessment", "author": ["Antonio Morgado", "Federico Heras", "Mark Liffiton", "Jordi Planes", "Joao Marques- Silva"], "venue": null, "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2013}, {"title": "Chaff: Engineering an efficient sat solver", "author": ["Matthew W Moskewicz", "Conor F Madigan", "Ying Zhao", "Lintao Zhang", "Sharad Malik"], "venue": "In Proceedings of the 38th annual Design Automation Conference,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2001}, {"title": "Application of satisfiability algorithms to timetable problems", "author": ["Fahima NADER", "Mouloud KOUDIL", "Karima BENATCHBA", "Lotfi ADMANE", "Said GHAROUT", "Nacer HAMANI"], "venue": "Rapport Interne LMCS, INI,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2004}, {"title": "A comparative study of two boolean formulations of fpga detailed routing", "author": ["G-J Nam", "Fadi Aloul", "Karem A. Sakallah", "Rob A. Rutenbar"], "venue": "IEEE Transactions on,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2004}, {"title": "Maximum satisfiability using core-guided maxsat resolution", "author": ["Nina Narodytska", "Fahiem Bacchus"], "venue": "In AAAI,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2014}, {"title": "Variable dependency in local search: Prevention is better than cure", "author": ["Steven Prestwich"], "venue": "In Theory and Applications of Satisfiability Testing\u2013SAT", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2007}, {"title": "Protein structure alignment using maximum cliques and local search", "author": ["Wayne Pullan"], "venue": "In AI 2007: Advances in Artificial Intelligence,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2007}, {"title": "Improved design debugging using maximum satisfiability", "author": ["Sean Safarpour", "Hratch Mangassarian", "Andreas Veneris", "Mark H Liffiton", "Karem Sakallah"], "venue": "In Formal Methods in Computer Aided Design, 2007", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2007}, {"title": "A dynamic approach to mpe and weighted max-sat", "author": ["Tian Sang", "Paul Beame", "Henry Kautz"], "venue": "In Proceedings of the 20th international joint conference on Artifical intelligence,", "citeRegEx": "52", "shortCiteRegEx": "52", "year": 2007}, {"title": "Towards an optimal cnf encoding of boolean cardinality constraints. Principles and Practice of Constraint Programming-CP", "author": ["Carsten Sinz"], "venue": null, "citeRegEx": "53", "shortCiteRegEx": "53", "year": 2005}, {"title": "Pbliba c++ toolkit for encoding pseudo\u2013boolean constraints into cnf", "author": ["Peter Steinke", "Norbert Manthey"], "venue": null, "citeRegEx": "55", "shortCiteRegEx": "55", "year": 2014}, {"title": "A \u201clogic-constrained\u201d knapsack formulation and a tabu algorithm for the daily photograph scheduling of an earth observation satellite", "author": ["Michel Vasquez", "Jin-Kao Hao"], "venue": "Computational Optimization and Applications,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2001}, {"title": "A linear-time transformation of linear inequalities into conjunctive normal form", "author": ["Joost P Warners"], "venue": "Information Processing Letters,", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 1998}, {"title": "sub-sat: A formulation for relaxed boolean satisfiability with applications in routing", "author": ["Hui Xu", "Rob A Rutenbar", "Karem Sakallah"], "venue": "Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on,", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2003}, {"title": "Satzilla: portfoliobased algorithm selection for sat", "author": ["Lin Xu", "Frank Hutter", "Holger H Hoos", "Kevin Leyton-Brown"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2008}], "referenceMentions": [{"referenceID": 48, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 93, "endOffset": 97}, {"referenceID": 52, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 187, "endOffset": 191}, {"referenceID": 10, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 212, "endOffset": 228}, {"referenceID": 43, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 212, "endOffset": 228}, {"referenceID": 39, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 212, "endOffset": 228}, {"referenceID": 32, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 212, "endOffset": 228}, {"referenceID": 22, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 256, "endOffset": 260}, {"referenceID": 54, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 270, "endOffset": 278}, {"referenceID": 44, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 270, "endOffset": 278}, {"referenceID": 49, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 290, "endOffset": 294}, {"referenceID": 47, "context": "Many theoretical and practical problems can be encoded into SAT and MaxSAT such as debugging [51], circuits design and scheduling of how an observation satellite captures photos of Earth [56], course timetabling [11, 45, 41, 34], software package upgrades [24], routing [58, 46], reasoning [52] and protein structure alignment in bioinformatics [50].", "startOffset": 345, "endOffset": 349}, {"referenceID": 41, "context": "Recent comprehensive surveys on SAT-based algorithms can be found in[43, 8].", "startOffset": 68, "endOffset": 75}, {"referenceID": 7, "context": "Recent comprehensive surveys on SAT-based algorithms can be found in[43, 8].", "startOffset": 68, "endOffset": 75}, {"referenceID": 2, "context": "[3] developed a PMaxSAT algorithm called QMaxSAT (version 0.", "startOffset": 0, "endOffset": 3}, {"referenceID": 16, "context": "This method was first proposed in 2006 by Fu and Malik in[18] (see algorithm 6).", "startOffset": 57, "endOffset": 61}, {"referenceID": 16, "context": "Fu and Malik\u2019s algorithm[18]", "startOffset": 24, "endOffset": 28}, {"referenceID": 3, "context": "WPM1[4]", "startOffset": 4, "endOffset": 7}, {"referenceID": 4, "context": "Improved WPM1[5]", "startOffset": 13, "endOffset": 16}, {"referenceID": 6, "context": "WPM2[7]", "startOffset": 4, "endOffset": 7}, {"referenceID": 19, "context": "WMSU1-ROR[21]", "startOffset": 9, "endOffset": 13}, {"referenceID": 35, "context": "WMSU3[37]", "startOffset": 5, "endOffset": 9}, {"referenceID": 36, "context": "WMSU4[38]", "startOffset": 5, "endOffset": 9}, {"referenceID": 13, "context": "A minimal unsatisfiable core is an unsatisfiable core such that any proper subset of it is not a core[15].", "startOffset": 101, "endOffset": 105}, {"referenceID": 42, "context": "Fu and Malik implemented two PMaxSAT solvers, ChaffBS (uses binary search to find the optimal cost) and ChaffLS (uses linear search to find the optimal cost) on top of a SAT solver called zChaff[44].", "startOffset": 194, "endOffset": 198}, {"referenceID": 9, "context": "Their PMaxSAT solvers participated in the first and second MaxSAT Evaluations[10].", "startOffset": 77, "endOffset": 81}, {"referenceID": 3, "context": "Ans\u00f3tegui, Bonet and Levy[4] extended Fu& Malik to WPMaxSAT.", "startOffset": 25, "endOffset": 28}, {"referenceID": 4, "context": "In 2012, Ans\u00f3tegui, Bonet and Levy presented a modification to WPM1 (algorithm 7)[5].", "startOffset": 81, "endOffset": 84}, {"referenceID": 35, "context": "In 2007, Marques-Silva and Planes[37] discussed important properties of Fu&Malik that were not mentioned in[18].", "startOffset": 33, "endOffset": 37}, {"referenceID": 16, "context": "In 2007, Marques-Silva and Planes[37] discussed important properties of Fu&Malik that were not mentioned in[18].", "startOffset": 107, "endOffset": 111}, {"referenceID": 17, "context": "Fu&Malik use the pairwise encoding[19] for the constraints on the relaxation variables, which use a quadratic number of clauses.", "startOffset": 34, "endOffset": 38}, {"referenceID": 53, "context": "Instead, Marques-Silva and Planes suggested several other encodings all of which are linear in the number of variables in the constraint[57, 53, 17, 19].", "startOffset": 136, "endOffset": 152}, {"referenceID": 50, "context": "Instead, Marques-Silva and Planes suggested several other encodings all of which are linear in the number of variables in the constraint[57, 53, 17, 19].", "startOffset": 136, "endOffset": 152}, {"referenceID": 15, "context": "Instead, Marques-Silva and Planes suggested several other encodings all of which are linear in the number of variables in the constraint[57, 53, 17, 19].", "startOffset": 136, "endOffset": 152}, {"referenceID": 17, "context": "Instead, Marques-Silva and Planes suggested several other encodings all of which are linear in the number of variables in the constraint[57, 53, 17, 19].", "startOffset": 136, "endOffset": 152}, {"referenceID": 6, "context": "Ans\u00f3tegui, Bonet and Levy also developed an algorithm for WPMaxSAT in 2010, called WPM2[7], where every soft clause Ci is extended with a unique fresh blocking variable bi.", "startOffset": 87, "endOffset": 90}, {"referenceID": 5, "context": "In[6], Ans\u00f3tegui et at.", "startOffset": 2, "endOffset": 5}, {"referenceID": 4, "context": "First, they applied the stratification technique[5].", "startOffset": 48, "endOffset": 51}, {"referenceID": 19, "context": "WMSU1-ROR[21] is a modification of WPM1.", "startOffset": 9, "endOffset": 13}, {"referenceID": 24, "context": "The MaxSAT resolution rule used in WMSU1-ROR is called Max-RES and is described in[26].", "startOffset": 82, "endOffset": 86}, {"referenceID": 24, "context": "De Morgan\u2019s laws can not be applied on MaxSAT instance for not preserving the equivalence among instances[26].", "startOffset": 105, "endOffset": 109}, {"referenceID": 3, "context": "WMSU1-ROR handles WPMaxSAT formulae the same way as[4].", "startOffset": 51, "endOffset": 54}, {"referenceID": 21, "context": "Unfortunately, ROR can not generate resolution proofs for some unsatisfiable clauses[23].", "startOffset": 84, "endOffset": 88}, {"referenceID": 6, "context": "The function UpdateBound in line 14 updates the lower bound LB, either by simply incrementing it or by the subset sum problem as in[7].", "startOffset": 131, "endOffset": 134}, {"referenceID": 36, "context": "Like WMSU3, WMSU4[38] (algorithm 15) adds at most one blocking variable to each soft clause.", "startOffset": 17, "endOffset": 21}, {"referenceID": 20, "context": "Heras, Morgado and Marques-Silva proposed this technique in[22] (see algorithm 16).", "startOffset": 59, "endOffset": 63}, {"referenceID": 20, "context": "The core-guided binary search approach was improved by Heras[22] et al.", "startOffset": 60, "endOffset": 64}, {"referenceID": 38, "context": "In other words, different solution approaches work well on different families of instances[40].", "startOffset": 90, "endOffset": 94}, {"referenceID": 55, "context": "The success of SATzilla[59] for SAT was due to a regression function which was trained to predict the performance of every solver in the given set of solvers based on the features of an instance.", "startOffset": 23, "endOffset": 27}, {"referenceID": 8, "context": "ISAC[9] (Instance-Specific Algorithm Configuration) is one of the most successful WPMaxSAT portfolio algorithms.", "startOffset": 4, "endOffset": 7}, {"referenceID": 50, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 11, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 34, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 1, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 51, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 31, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 0, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 12, "context": "While there are dedicated solvers (such as Sat4j) for solving PB constraints, there are good reasons to be interested in transforming the constraints into SAT (CNF formulae), and a number of methods for doing this have been reported[53, 12, 36, 2, 55, 33, 1, 13].", "startOffset": 232, "endOffset": 262}, {"referenceID": 12, "context": "We present the method of Bailleux, Boufkhad and Roussel[13].", "startOffset": 55, "endOffset": 59}, {"referenceID": 12, "context": "The correctness and the complexity of the encoding are discussed in the same paper[13].", "startOffset": 82, "endOffset": 86}, {"referenceID": 40, "context": "Incremental approaches[42, 39, 47] allow the constraint solver to retain knowledge from previous iterations that may be used in the upcoming iterations.", "startOffset": 22, "endOffset": 34}, {"referenceID": 37, "context": "Incremental approaches[42, 39, 47] allow the constraint solver to retain knowledge from previous iterations that may be used in the upcoming iterations.", "startOffset": 22, "endOffset": 34}, {"referenceID": 45, "context": "Incremental approaches[42, 39, 47] allow the constraint solver to retain knowledge from previous iterations that may be used in the upcoming iterations.", "startOffset": 22, "endOffset": 34}, {"referenceID": 16, "context": "WMiFuMax is an unsatisfiability-based WPMaxSAT solver based on the technique of Fu and Malik[18] and on the algorithm by Manquinho, Marques-Silva, and Planes[32], which is works by identifying unsatisfiable sub-formulae.", "startOffset": 92, "endOffset": 96}, {"referenceID": 30, "context": "WMiFuMax is an unsatisfiability-based WPMaxSAT solver based on the technique of Fu and Malik[18] and on the algorithm by Manquinho, Marques-Silva, and Planes[32], which is works by identifying unsatisfiable sub-formulae.", "startOffset": 157, "endOffset": 161}, {"referenceID": 23, "context": "QWMaxSAT is a weighted version of QMaxSAT developed by Koshimura, Zhang, Fujita and Hasegawa[25] and is available freely online.", "startOffset": 92, "endOffset": 96}, {"referenceID": 14, "context": "0 of the SAT solver MiniSAT[16].", "startOffset": 27, "endOffset": 31}, {"referenceID": 25, "context": "Sat4j[27] is a satisfiability-based WPMaxSAT solver developed by Le Berre and Parrain.", "startOffset": 5, "endOffset": 9}, {"referenceID": 33, "context": "MSUnCore[35] is an unsatisfiability-based WPMaxSAT solver built on top the SAT solver PicoSAT[14].", "startOffset": 8, "endOffset": 12}, {"referenceID": 46, "context": "Cardinality constraints are encoded using several encodings, such as the pairwise and bitwise encodings[49, 48], the ladder encoding[20], sequential counters[53], sorting networks[17], and binary decision diagrams (BDDs)[17].", "startOffset": 103, "endOffset": 111}, {"referenceID": 18, "context": "Cardinality constraints are encoded using several encodings, such as the pairwise and bitwise encodings[49, 48], the ladder encoding[20], sequential counters[53], sorting networks[17], and binary decision diagrams (BDDs)[17].", "startOffset": 132, "endOffset": 136}, {"referenceID": 50, "context": "Cardinality constraints are encoded using several encodings, such as the pairwise and bitwise encodings[49, 48], the ladder encoding[20], sequential counters[53], sorting networks[17], and binary decision diagrams (BDDs)[17].", "startOffset": 157, "endOffset": 161}, {"referenceID": 15, "context": "Cardinality constraints are encoded using several encodings, such as the pairwise and bitwise encodings[49, 48], the ladder encoding[20], sequential counters[53], sorting networks[17], and binary decision diagrams (BDDs)[17].", "startOffset": 179, "endOffset": 183}, {"referenceID": 15, "context": "Cardinality constraints are encoded using several encodings, such as the pairwise and bitwise encodings[49, 48], the ladder encoding[20], sequential counters[53], sorting networks[17], and binary decision diagrams (BDDs)[17].", "startOffset": 220, "endOffset": 224}, {"referenceID": 26, "context": "It is based on an earlier solver called Maxsatz[28], which incorporates the technique developed for the famous SAT solver, Satz[29].", "startOffset": 47, "endOffset": 51}, {"referenceID": 27, "context": "It is based on an earlier solver called Maxsatz[28], which incorporates the technique developed for the famous SAT solver, Satz[29].", "startOffset": 127, "endOffset": 131}, {"referenceID": 29, "context": "WMaxSatz-2009 and WMaxSatz+[31, 30] are branch and bound solvers that use transformation rules[28] which can be implemented efficiently as a by-product of unit propagation or failed literal detection.", "startOffset": 27, "endOffset": 35}, {"referenceID": 28, "context": "WMaxSatz-2009 and WMaxSatz+[31, 30] are branch and bound solvers that use transformation rules[28] which can be implemented efficiently as a by-product of unit propagation or failed literal detection.", "startOffset": 27, "endOffset": 35}, {"referenceID": 26, "context": "WMaxSatz-2009 and WMaxSatz+[31, 30] are branch and bound solvers that use transformation rules[28] which can be implemented efficiently as a by-product of unit propagation or failed literal detection.", "startOffset": 94, "endOffset": 98}, {"referenceID": 8, "context": "ISAC+[9] (Instance-Specific Algorithm Configuration) is a portfolio of algorithm which, given a WPMaxSAT instance, selects the solver better suited for that instance.", "startOffset": 5, "endOffset": 8}], "year": 2016, "abstractText": "The Maximum Satisfiability (MaxSAT) problem is the problem of finding a truth assignment that maximizes the number of satisfied clauses of a given Boolean formula in Conjunctive Normal Form (CNF). Many exact solvers for MaxSAT have been developed during recent years, and many of them were presented in the well-known SAT conference. Algorithms for MaxSAT generally fall into two categories: (1) branch and bound algorithms and (2) algorithms that use successive calls to a SAT solver (SATbased), which this paper in on. In practical problems, SAT-based algorithms have been shown to be more efficient. This paper provides an experimental investigation to compare the performance of recent SAT-based and branch and bound algorithms on the benchmarks of the MaxSAT Evaluations. 1 ar X iv :1 60 3. 03 81 4v 1 [ cs .A I] 1 1 M ar 2 01 6", "creator": "LaTeX with hyperref package"}}}