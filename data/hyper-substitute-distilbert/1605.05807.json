{"id": "1605.05807", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-May-2016", "title": "Heuristics for Planning, Plan Recognition and Parsing", "abstract": "preceding these conference paper, \" explicitly shown the plan recognition programming diagrams will be formulated quickly solved using classical engineering methodology and computers. in this approach, we show that this formulation does the standard formulation model plan realization over libraries through a compilation xml files into strips graph. the groups default to and / ; graphs that may be cyclic and where children of constituent nodes likewise be partially sorted. limited libraries include context - free triangles though it special case, that the plan template problem becomes a parsing with missing tokens problem. plan improvement over the standard libraries constraint", "histories": [["v1", "Thu, 19 May 2016 04:22:35 GMT  (47kb,D)", "https://arxiv.org/abs/1605.05807v1", "Written: June 2009, Published: May 2016"], ["v2", "Sun, 22 May 2016 23:02:35 GMT  (47kb,D)", "http://arxiv.org/abs/1605.05807v2", "Written: June 2009, Published: May 2016"]], "COMMENTS": "Written: June 2009, Published: May 2016", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["miquel ramirez", "hector geffner"], "accepted": false, "id": "1605.05807"}, "pdf": {"name": "1605.05807.pdf", "metadata": {"source": "CRF", "title": "Heuristics for Planning, Plan Recognition and Parsing (Written: June 2009, Published: May 2016)", "authors": ["Miquel Ram\u0131\u0301rez", "Hector Geffner"], "emails": ["miquel.ramirez@protonmail.ch", "hector.geffner@upf.edu"], "sections": [{"heading": "Introduction", "text": "Plan Recognition is a common task in a number of areas where the goal and plan of an agent must be inferred from observations of its behavior (Schmidt, Sridharan, and Goodson 1978; Cohen, Perrault, and Allen 1981; Pentney et al. 2006). Plan Recognition is a form of Planning in reverse: while in Planning, we seek the actions that achieve a goal, in Plan Recognition, we seek the goals that explain the observed actions. Work in Plan Recognition, however, has proceeded independently of the work in Planning, using mostly handcrafted libraries or algorithms not related to Planning (Kautz and Allen 1986; Vilain 1990; Charniak and Goldman 1993; Lesh and Etzioni 1995; Goldman, Geib, and Miller 1999; Avrahami-Zilberbrand and Kaminka 2005).\nRecently, we have shown that Plan Recognition can be formulated and solved using Classical Planning algorithms (Ramirez and Geffner 2009). This is important since Classical Planning algorithms have become quite powerful in recent years. This formulation does not work over libraries but over STRIPS theories where a set G of possible goals is given. The Plan Recognition task is defined as the problem of identifying the goals G \u2208 G that have some optimal plan compatible with the observationsO. Such goals are grouped into the optimal goal set G\u2217, G\u2217 \u2286 G. The reason for focusing on the optimal plans is that they represent the possible\nbehaviors of a perfectly rational agent pursuing the goal G (Baker, Tenenbaum, and Saxe 2007). By suitable transformation, it is then shown in (Ramirez and Geffner 2009) that this optimal set G\u2217 can be computed exactly by means of optimal Planning algorithms and approximately by efficient suboptimal Planning algorithms and polynomial heuristics.\nIn this work, we show that this formulation subsumes the standard formulation of Plan Recognition over libraries through a compilation of libraries into STRIPS. The libraries correspond AND/OR graphs that may be cyclic and where children of AND nodes may be partially ordered. This libraries include Context-Free Grammars as a special case, where the Plan Recognition problem becomes a parsing problem. Plan Recognition over the standard Plan Libraries become simple Planning problems that can be easily solved by any modern planner, while recognition over more complex libraries, including CFGs, illustrate limitations of current Planning heuristics and improvements that may be relevant in other Planning problems as well.1\nThe paper is organized as follows. First we review the formulation of Plan Recognition over STRIPS theories in (Ramirez and Geffner 2009), then we consider Plan Recognition over libraries, present some experimental results, and draw some conclusions."}, {"heading": "Plan Recognition as Planning", "text": "A STRIPS Planning problem is a tuple P = \u3008F, I,A,G\u3009 where F is the set of fluents, I \u2286 F and G \u2286 F are the initial and goal situations, and A is a set of actions a with precondition, add, and delete lists Pre(a),Add(a), andDel(a) respectively, all of which are subsets of F . For each action a \u2208 A, we assume that there is a non-negative cost c(a) so that the cost of a sequential plan \u03c0 = a1, . . . , an is c(\u03c0) = \u2211 c(ai). A plan \u03c0 is optimal if it has minimum cost. For unit costs, i.e., c(a) = 1 for all a \u2208 A, plan cost is plan 1 Parsing in CFGs is polynomial while Planning is known to be NP\u2013hard. This worst complexity bounds, however, do not imply that the reduction of parsing to Planning is necessarily a bad idea. First, many Planning problems \u2013 like manySAT problems \u2013 can be solved quite efficiently; second, parsing with constraints, as required in Natural Language Processing, is also intractable, yet many of these constraints can be handled naturally in Planning. In addition, the mapping handles missing tokens in the input sentence and yields interesting lessons for Planning heuristics. ar X iv :1\n60 5.\n05 80\n7v 2\n[ cs\n.A I]\n2 2\nM ay\n2 01\n6\nlength, and the optimal plans are the shortest ones. Unless stated otherwise, action costs are assumed to be 1."}, {"heading": "Definition", "text": "The Plan Recognition problem given a plan library L for a set G of possible goals G can be understood, at an abstract level, as the problem of finding a goal G with a plan \u03c0 in the library, written \u03c0 \u2208 \u03a0L(G), such that \u03c0 satisfies the observations. We define the Plan Recognition problem over a domain theory in a similar way just changing the set \u03a0L(G) of plans for G in the library by the set \u03a0\u2217P (G) of optimal plans for G given the domain P . We use P = \u3008F, I,O\u3009 to represent Planning domains so that a Planning problem P (G) is obtained by concatenating a Planning domain with a goal G, which is a set of fluents. We define a Plan Recognition problem or theory as follows:\nDefinition 1 A Plan Recognition problem or theory is a triplet T = \u3008P,G, O\u3009 where P = \u3008F, I,A\u3009 is a Planning domain, G is the set of possible goals G, G \u2286 F , and O = o1, . . . , om is an observation sequence with each oi being an action in A.\nWe also need to make precise what it means for an action sequence to satisfy an observation sequence made up of actions. E.g., the action sequence \u03c0 = {a, b, c, d, e, a} satisfies the observation sequences O1 = {b, d, a} and O2 = {a, c, a}, but not O3 = {b, d, c}. This can be formalized with the help of a function that maps observation indices in O into action indices in A:\nDefinition 2 An action sequence \u03c0 = a1, . . . , an satisfies the observation sequence O = o1, . . . , om if there is a monotonic function f mapping the observation indices j = 1, . . . ,m into action indices i = 1, . . . , n, such that af(j) = oj .\nThe solution to a Plan Recognition theory T = \u3008P,G, O\u3009 is given by the goals G that admit an optimal plan that is compatible with the observations:\nDefinition 3 The exact solution to a theory T = \u3008P,G, O\u3009 is given by the optimal goal set G\u2217T which comprises the goals G \u2208 G such that for some \u03c0 \u2208 \u03a0\u2217P (G), \u03c0 satisfies O.\nFigure 1 shows a simple Plan Recognition problem. Room A (marked with a circle) is the initial position of the agent, while Rooms C, I and K (marked with a square) are its possible destinations. Arrows between Rooms A and B,\nand F and G, are the observed agent movements in that order. In the resulting theory T , the only possible goals that have optimal plans compatible with the observation sequence are I and K. In the terminology above, the set of possible goals G is given by the atoms at(C), at(I), and at(K), while the optimal goal set G\u2217T comprises at(I) and at(K), leaving out the possible goal at(C)."}, {"heading": "Computation", "text": "In order to solve the Plan Recognition problem using Planning algorithms, we get rid of the observations. For simplicity, we assume that no pair of observations oi and oj refer to the same action a in P . When this is not so, we create a copy a\u2032 of the action a in P so that oi refers to a\u2032 and oj refers to a.\nWe will eliminate observations by mapping the theory T = \u3008P,G, O\u3009 into an slightly different theory T \u2032 = \u3008P \u2032,G\u2032, O\u2032\u3009 with an empty set O\u2032 of observations, such that the solution set G\u2217T for T can be read off from the solution set G\u2217T \u2032 for T \u2032. Definition 4 For a theory T = \u3008P,G, O\u3009, the transformed theory is T \u2032 = \u3008P \u2032,G\u2032, O\u2032\u3009 with \u2022 P \u2032 = \u3008F \u2032, I \u2032, A\u2032\u3009 has fluents F \u2032 = F \u222a Fo, initial sit-\nuation I \u2032 = I , and actions A\u2032 = A \u222a Ao, where P = \u3008F, I,A\u3009, F0 = {pa | a \u2208 O}, and Ao = {oa | a \u2208 O}, \u2022 G\u2032 contains the goal G\u2032 = G \u222a Go for each goal G in G, where Go = Fo, \u2022 O\u2032 is empty\nThe new actions oa in P \u2032 have the same precondition, add, and delete lists as the actions a in P except for the new fluent pa that is added to Add(oa), and the fluent pb, for the action b that immediately precedes a in O, if any, that is added to Pre(oa).\nIn the transformed theory T \u2032, the observations a \u2208 O are encoded as extra fluents pa \u2208 Fo, extra actions oa \u2208 Ao, and extra goals pa \u2208 Go. Moreover, these extra goals pa can only be achieved by the new actions oa, that due to the precondition pb for the action b that precedes a in O, can be applied only after all the actions preceding a inO, have been executed. The result is that the plans that achieve the goal G\u2032 = G\u222aGo in P \u2032 are in correspondence with the plans that achieve the goal G in P that satisfy the observations O:\nProposition 5 \u03c0 = a1, . . . , an is a plan for G in P that satisfies the observations O = o1, . . . , om under the function f iff \u03c0\u2032 = b1, . . . , bn is a plan for G\u2032 in P \u2032 with bi = oai , if i = f(j) for some j \u2208 [1,m], and bi = ai otherwise.\nIt follows from this that \u03c0 is an optimal plan for G in P that satisfies the observations iff \u03c0\u2032 is an optimal plan in P \u2032 for two different goals: G, on the one hand, andG\u2032 = G\u222aGo on the other. If we let \u03a0\u2217P (G) stand for the set of optimal plans for G in P , we can thus test whether a goal G in G accounts for the observation as follows:2\n2 Note that while a plan for G\u2032 = G \u222a Go is always a plan for G, it is not true that an optimal plan for G\u2032 is an optimal plan for G, or even that a good plan for G\u2032 is a good plan for G.\nTheorem 6 G \u2208 G\u2217T iff there is an action sequence \u03c0 in \u03a0\u2217P \u2032(G) \u2229\u03a0\u2217P \u2032(G\u2032). Moreover, since G \u2286 G\u2032, if we let c\u2217P \u2032(G) stand for the optimal cost of achieving G in P \u2032, we can state this result in a simpler form: Theorem 7 G \u2208 G\u2217T iff c\u2217P \u2032(G) = c\u2217P \u2032(G\u2032)\nThe optimal goal set G\u2217 can be computed, using this result, by solving two optimal Planning problems for each possible goal G: one extending the domain P \u2032 with the goal G, the other extending P \u2032 with the goal G\u2032 made up of G and the dummy goals Go encoding the observations. The goal G explains the observations and thus belongs to G\u2217T iff the solutions to these two optimal Planning problems have the same cost. In (Ramirez and Geffner 2009), a more efficient method for computing this set exactly is introduced, where the cost of the first problem is used as the upper bound in the solution of the second. In addition, two methods that approximate G\u2217T and scale up much better are presented. For Plan Recognition over libraries, the situation is simpler, as the resulting Planning problems have zero action costs, and hence all plans are optimal."}, {"heading": "Plan Recognition over Libraries", "text": "As mentioned above, the Plan Recognition problem given a plan library L for a set G of possible goals G can be understood, at an abstract level, as the problem of finding a goalG with a plan \u03c0 \u2208 L, written \u03c0 \u2208 \u03a0L(G), such that \u03c0 satisfies the observations O. We show now that a library L for a goal G can be compiled intro a STRIPS Planning problem PL(G) so that \u03c0 is in \u03a0L(G) iff \u03c0 is a plan for PL(G). Provided with this correspondence and by setting the cost of all the actions in PL to zero, so that no plan in the library is ruled out due to their cost, a plan in the library for G will satisfy the observations O iff G is in the optimal goal set G\u2217T of the theory T = \u3008PL,G, O\u3009, a set that can be computed by using an off-the-shelf classical planner upon the Planning problems P \u2032L(G\n\u2032) obtained from the transformation that compiles the observation O in T away."}, {"heading": "Plan Libraries", "text": "As it is standard, we take a library L for a goal G to be a rooted, ordered AND/OR graph where each node is a AND node, an OR node, or a leaf. Leaves represent primitive task (actions), OR nodes represent non-primitive tasks, and AND nodes represent methods for decomposing nonprimitive task. The children of OR nodes are AND nodes or leaves, while the children of AND nodes are OR nodes or leaves. The children of an AND node n can be ordered partially; we write n\u2032 <n n\u2032\u2032 to express that child n\u2032 of n must come before child n\u2032\u2032. The root of the library is a task (OR node) that represents the goal G to be achieved. We will allow libraries to be cyclic, and thus, CFGs will be an special case where the OR nodes stand for the non-terminal symbols in the grammar, the AND nodes stands for the grammar rules, and the leaves stand for the grammar terminals. The children of the AND/OR graphs that represent CFGs are normally cyclic and the children of AND nodes (rules) are ordered linearly.\nThe set of solutions to one such AND/OR graph can be defined by means of derivations as it is common in parsing, with the only difference that a partially ordered rule X \u2192 Y1, . . . , Ym represented by an AND node, stands for the set of all totally ordered rules X \u2192 Yi1 , . . . , Yim compatible with the partial order. The set of plans \u03a0L(G) in the library forG denotes the set of \u2019strings\u2019 (sequences of terminal tasks or actions) that can be derived from the root node corresponding to G."}, {"heading": "Compilation", "text": "The compilation of the library L for a goal G into a STRIPS Planning problem PL(G) depends on a depth parameter N , and it ensures that the plans in PNL (G) are in correspondence with the set of plans (strings of primitive tasks) \u03a0L(G) that can be derived from the library by bounding the depth of the derivation to N . If the library is acyclic, it suffices to set N to the depth of the graph to ensure completeness; otherwise, the parameter N puts a bound on the number of derivations. For simplicity, we often drop the index N from the notation.\nThe Planning problem PL(G) = \u3008FL, IL, GL, AL\u3009 have a set of fluents FL, initial and goal situations IL and GL, and actions AL. For simplicity, we will describe the problem assuming a STRIPS language with negation. Negation, however, can be easily compiled away (Gazen and Knoblock 1997).\nThe fluents FL in PL are started(n, i), \u00acstarted(n, i), finished(n, i), \u00acfinished(n, i), and top(i), where n corresponds to the nodes in the AND/OR graph representing the library L, and i = [0 . . . N ]. The integers i aim to capture the possible levels of the stack, with the true level captured by the fluent top(i) that is mutex with top(k) for k 6= i. In a state, where top(i) is true, the fluents started(n, k) and finished(n, k) for k \u2264 i express the contents of the stack. In any such a state, all fluents started(n, k) and finished(n, k) for k > i will be false.\nThe initial and goal situations of PL are IL = {top(0)} and GL = {finished(n, 0)}, where n is the single (OR) root node of the library L. That is, the stack starts at level 0 empty with no node started, and the goal is to finish with the root node executed at the same level. For doing this, the stack will expand and contract, while the execution of a node will allow the execution of its children. Roughly the started(n, i) fluents flow downward in the graph, and the fluents finished(n, i) flow upward, with the actions start(n, i) and end(n, i) emulating the start and ending of the primitive and non-primitive tasks in the AND/OR graph. As a convenient abbreviation, we write i+1 and i\u22121 to denote constants i\u2032 defined as the successor and predecessor of the constant i in the encoding. The actions in PNL (G)are: \u2022 Calls from AND nodes n to non\u2013terminal children n\u2032 are repre-\nsented by actions start(n, n\u2032, i) with preconditions\nPre = {top(i), started(n, i),\u00acfinished(n\u2032)} \u222a {finished(n\u2032\u2032, i) |n\u2032\u2032 <n n\u2032} \u222a {\u00acstarted(n\u2032\u2032, i) |n\u2032\u2032 \u2208 children(n)}\nadd list Add = {top(i+1), started(n\u2032, i+1} and delete list Del = {top(i)}. For calls to terminal children n\u2032, the precon-\ndition of start(n, n\u2032, i) is the same as the one described above but Add = {finished(n\u2032, i)} and Del = \u2205.\n\u2022 Termination of calls made from AND nodes n are encoded with actions end(n, i), with preconditions\nPre = {top(i), started(n, i)} \u222a {finished(n\u2032) |n\u2032 \u2208 children(n)}\nand add list Add = {finished(n, i\u22121), top(i\u22121)} and delete list Del = Pre. \u2022 Calls from internal OR nodes n to children n\u2032 are represented by actions start(n, n\u2032, i) with precondition\nPre = {top(i), started(n, i)} \u222a {\u00acfinished(n\u2032\u2032, i+1) |n\u2032\u2032 \u2208 children(n)} \u222a {\u00acstarted(n\u2032\u2032, i+1) |n\u2032\u2032 \u2208 children(n)}\nadd list Add = {top(i+1), started(n\u2032, i+1)} and delete list Del = {top(i)}.\n\u2022 Termination of calls from internal OR nodes are represented by actions end(n, n\u2032, i), where n\u2032 is a child of n, with precondition Pre = {top(i), started(n, i), finished(n\u2032, i)}, add list Add = {finished(n, i\u2212 1), top(i\u2212 1)} and delete list Del = Pre.\n\u2022 Root OR nodes are handled like other OR nodes, except that the action end(n, i = 0) adds finished(n, 0) rather than adding finished(n, i\u22121). For a plan \u03c0 for PL(G), let us keep only the sequence of start(n, n\u2032, k) actions where n is a leaf node of L, and let us set fL(\u03c0) to the corresponding sequence with the start(n, n\u2032, k) actions replaced by the primitive actions associated with the nodes n.\nThe first result is about the correspondence between the set of plans in the library L for G with depth bounded by N , \u03a0NL (G), and the sequences of primitive actions f(\u03c0) for plans \u03c0 for PNL (G): Theorem 8 (Correspondence) For a library L for goal G and a positive integer N , \u03c0 \u2208 \u03a0NL (G) iff there is a plan \u03c0\u2032 for PL(G) such that \u03c0 = fL(\u03c0).\nThe second result exploits this correspondence for computing the plans in the library that comply with a set of observations O using an off-the-shelf classical planner, suboptimal or not, over the problem P \u2032L(G\n\u2032) obtained from PL(G) by compiling the observations O away (Definition 4): Theorem 9 (Computation) For a library L for a goal G, and a positive integerN ,G has a plan in \u03a0NL (G) compatible with the observations O iff there is a plan for the Planning problem P \u2032NL (G\n\u2032) obtained from PL(G) by compiling the observations O away.\nThe third result is semantic, and shows that this computational method follows from the general formulation for Plan Recognition from STRIPS theories when action costs are taken to be zero: Theorem 10 (Subsumption) Let G be a set of possible goals, and let L be the library for G \u2208 G. Then G has a plan in the library that satisfies the observations O with depth no greater than N iff there is an optimal plan for the problem PNL (G) that satisfies O, assuming action costs to be zero.\nIndeed, this result follows from the one above, as when all action costs are zero, any plan for P \u2032NL (G\n\u2032) is an optimal plan for P \u2032NL (G), which in turn from Proposition 5, represents a plan for the problem PL(G) that satisfies the observations."}, {"heading": "Experimental Results", "text": "We test below the Plan Recognition framework laid out above over plan libraries and Context-Free Grammars."}, {"heading": "The Soccer Plan Library", "text": "From the descriptions found (Tambe et al. 1999) on plan hierarchies for controlling simulated RoboSoccer teams, we have defined ourselves a set plan libraries for recognizing the intentions of the opposing soccer team. Each library considers one of the following four root tasks, namely, Frontal\u2013 Attack, Flank\u2013Attack, Fight\u2013Back and Fall\u2013Back 3. Plans in the first two libraries share a substantial amount of activities, e.g. kicking the ball, or running towards the general direction of the opposing team, which do not or hardly take place in plans conveyed by the latter two libraries. In Figure 2 we show the plan library for the task Frontal\u2013Attack.\nIn the experiments, we test which plan libraries are compatible with a sequence of observations drawn from a plan obtained from one of them. The planner we used to search for such plans is the satisfying classical planner FFV2.3.\nIn Table 1 we can see that the Planning problems we obtain from our compilation are handled easily by FF. It is important to note that the size of the observation sequence |O| does not seem to be related with the running time. While the plan library depicted in Figure 2 might be very simple, it is not simpler than the plan libraries typically found in the Plan Recognition literature."}, {"heading": "Context-Free Grammars", "text": "Context-free grammars (CFGs) appear to present more interesting Planning challenges than the common plan libraries. First, most, if not all, CFGs of interest in Natu-\n3Names of tasks loosely correspond with those of top\u2013level goals featured by the plan hierarchy found in the ISIS source distribution.\nral Language Processing (NLP) are cyclic, though in languages like English, the depth of the derivation is not big. On the other hand, CFGs used as benchmarks for parsers, like ATIS\u20133 or COMMANDTALK 4, feature thousands of rules. Compiling such grammars into Plan Libraries results in graphs with several thousand nodes. Until recently (Geib and Goldman 2009), there has not been any serious attempt at developing a set of challenging benchmarks for Plan Recognition algorithms.\nWe have tested our compilation in a toy CFG of the English language, described below: 1. S \u2192 NP V P 2. V P \u2192 V NP |V |V P PP 3. NP \u2192 Det N |Name|NP PP 4. PP \u2192 P NP 5. V \u2192 saw|ate|ran 6. N \u2192 boy|cookie|table|telescope|hill 7. Name\u2192 Jack|Bob 8. P \u2192 with|under 9. Det\u2192 the|a|my\nCompiling this simple CFG yields a Plan Library with 85 nodes, which in turn yields a Planning problem with about 800 actions after having fixed the maximum derivation depth to 10.\nTable 2 confirms our intuition that even very simple CFGs yield significantly more challenging Planning problems than Plan Libraries do. In general more search is required to find\n4These grammars can be found in the NLTK (http://www. nltk.org) Natural Language Processing toolkit corpora.\nSentence Type Time (secs) Expanded Plan Len Algorithm Covered 266.5, TO(1) 1,698 54.2 BFS\nIncomplete 271 393 34 BFS Not Covered TO 4,000 \u2013 \u2013\nTable 3: Average time, number of nodes expanded \u2013 for timeouts an educated guess is provided \u2013 and plan lengths obtained with the second grammar. TO stands for timeout (time limit was set to 600 seconds). Twelve sentences were divided into three sets. The Covered set contained full sentences covered by the grammar. The Incomplete set contained covered sentences with missing tokens. The final set, Not Covered, refers to non\u2013English sequences of tokens.\na parse tree for the input token sequence. One very interesting property inherent to our approach is its ability to \u201cinterpolate\u201d missing tokens from the input sentence, as is the case of sentence #3. In that sentence there is no verb, and the planner introduces one of the available productions for non\u2013terminal V in order to obtain a correct parse tree. In sentence #2 the subject is missing, and in this case the planner introduces a noun\u2013phrase.\nEncouraged by these results, we wanted to conduct an experiment with a \u201creal grammar\u201d. We aimed at obtaining a parse for sentences using the ATIS\u20133 benchmark CFG. Yet this grammar contains over 3,000 different production rules, which resulted in an AND/OR graph with over 6,000 nodes. The Planning problem resulting from compiling that graph featured over 300,000 actions and a disk footprint of about 2 Gigabytes.\nWe have thus tested our Plan Recognition framework over a CFG not as complex as ATIS\u20133 but a bit more complex than the toy CFG above. This second grammar features a much richer lexicon: 7 verbs with tenses and number, over twenty nouns, pronouns, auxiliary verbs and all of English prepositions. It also features rules for modeling pragmatics \u2013 statements, questions and commands \u2013 and taking as well into account applicable syntactic cases \u2013 declarative, imperative and interrogation \u2013 for each pragmatic. This second grammar, when compiled, resulted in an AND/OR graph with 251 nodes, which, after fixing the derivation depth N to 30 to ensure solubility, resulted in a Planning problem with over 10,000 actions.\nThe results of applying our scheme to this second grammar are shown in Table 3, where three types of sentences are considered. Interestingly FF, solved pretty well the sentences in the Covered set, but had trouble processing the non\u2013English token sequences in the Not Covered set. The timeout we get in the Covered set corresponds to the sentence \u201cwhy did you take the book\u201d, while the sentence \u201ctake the book\u201d was solved after having to expand just 441 nodes. This observation and the fact that incomplete sentences are much smaller than the average sentence in the Complete set, leads us to conclude that in the context of parsing as Planning, the length of the sentence to parse seems to be relevant for the hardness of the problem. We can also see that the \u201cinterpolating\u201d behavior of our scheme is biased towards providing a reasonably sized parse tree. It is also worthy to note that none of the problems was solved with the incomplete EHC procedure.\nThe result confirms that the search for plans in the resulting theories becomes much more expensive due to the limitations of current heuristics that make planners like FF get lost in much larger search spaces. Moreover, we have found that it is possible to incorporate some ideas from parsing algorithms like CYK (Younger 1967) into relaxed\u2013plan graph heuristics, while keeping the heuristic itself computable in polynomial time. We think that such heuristics will help the search to become more focused. Interestingly, the new heuristic is general and thus applies to Planning problems that are completely unrelated to parsing. Unfortunately, we haven\u2019t had the time to test these ideas yet, but would like to do that for the camera\u2013ready version if the paper is accepted for the workshop."}, {"heading": "Discussion", "text": "We have shown that the framework for plan recognition over STRIPS theories, formulated recently in (Ramirez and Geffner 2009), subsumes the Plan Recognition problem over libraries, as they can be compiled into STRIPS. We have also shown that recognition over standard libraries become Planning problems that can be easily solved by modern planners, while recognition over more complex libraries, including CFGs, illustrate limitations of current Planning heuristics and suggest improvements that may be relevant in other Planning problems as well (to be worked out and shown)."}], "references": [{"title": "Fast and complete symbolic plan recognition", "author": ["Avrahami-Zilberbrand", "G.A. Kaminka"], "venue": "In Proceedings of IJCAI,", "citeRegEx": "Avrahami.Zilberbrand et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Avrahami.Zilberbrand et al\\.", "year": 2005}, {"title": "Goal inference as inverse planning", "author": ["Tenenbaum Baker", "C.L. Saxe 2007] Baker", "J.B. Tenenbaum", "R.R. Saxe"], "venue": "In Proceedings of the Twenty-Ninth Annual Conference of the Cognitive Science Society", "citeRegEx": "Baker et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baker et al\\.", "year": 2007}, {"title": "A bayesian model of plan recognition", "author": ["Charniak", "E. Goldman 1993] Charniak", "R.P. Goldman"], "venue": "Artificial Intelligence", "citeRegEx": "Charniak et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Charniak et al\\.", "year": 1993}, {"title": "Beyond question answering", "author": ["Perrault Cohen", "P.R. Allen 1981] Cohen", "C.R. Perrault", "J.F. Allen"], "venue": null, "citeRegEx": "Cohen et al\\.,? \\Q1981\\E", "shortCiteRegEx": "Cohen et al\\.", "year": 1981}, {"title": "Combining the expressiveness of UCPOP with the efficiency of Graphplan", "author": ["Gazen", "B. Knoblock 1997] Gazen", "C. Knoblock"], "venue": "Recent Advances in AI Planning. Proc. 4th European Conf. on Planning (ECP-97). Lect. Notes in AI", "citeRegEx": "Gazen et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Gazen et al\\.", "year": 1997}, {"title": "A probabilistic plan recognition algorithm based on plan tree grammars", "author": ["Geib", "C.W. Goldman 2009] Geib", "R.P. Goldman"], "venue": "Artificial Intelligence", "citeRegEx": "Geib et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Geib et al\\.", "year": 2009}, {"title": "A new model of plan recognition", "author": ["Geib Goldman", "R.P. Miller 1999] Goldman", "C.W. Geib", "C.A. Miller"], "venue": "In Proceedings of the 1999 Conference on Uncertainty in Artificial Intelligence", "citeRegEx": "Goldman et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Goldman et al\\.", "year": 1999}, {"title": "Generalized plan recognition", "author": ["Kautz", "H. Allen 1986] Kautz", "J.F. Allen"], "venue": "In AAAI,", "citeRegEx": "Kautz et al\\.,? \\Q1986\\E", "shortCiteRegEx": "Kautz et al\\.", "year": 1986}, {"title": "A sound and fast goal recognizer", "author": ["Lesh", "N. Etzioni 1995] Lesh", "O. Etzioni"], "venue": "In Proc. IJCAI-95,", "citeRegEx": "Lesh et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Lesh et al\\.", "year": 1995}, {"title": "Sensor-based understanding of daily life via large-scale use of common sense", "author": ["Pentney"], "venue": "Proceedings of AAAI", "citeRegEx": "Pentney,? \\Q2006\\E", "shortCiteRegEx": "Pentney", "year": 2006}, {"title": "Plan recognition as planning", "author": ["Ramirez", "M. Geffner 2009] Ramirez", "H. Geffner"], "venue": "In Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence (IJCAI-09)", "citeRegEx": "Ramirez et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Ramirez et al\\.", "year": 2009}, {"title": "The plan recognition problem: an intersection of psychology and artificial intelligence", "author": ["Sridharan Schmidt", "C. Goodson 1978] Schmidt", "N. Sridharan", "J. Goodson"], "venue": "Artificial Intelligence", "citeRegEx": "Schmidt et al\\.,? \\Q1978\\E", "shortCiteRegEx": "Schmidt et al\\.", "year": 1978}, {"title": "Building Agent Teams Using an Explicit Teamwork Model and Learning", "author": ["Tambe"], "venue": "Artifical Intelligence", "citeRegEx": "Tambe,? \\Q1999\\E", "shortCiteRegEx": "Tambe", "year": 1999}, {"title": "Recognition and parsing of context\u2013free languages in time n. Information and Control 10:189\u2013208", "author": ["D.H. Younger"], "venue": null, "citeRegEx": "Younger,? \\Q1967\\E", "shortCiteRegEx": "Younger", "year": 1967}], "referenceMentions": [{"referenceID": 13, "context": "Moreover, we have found that it is possible to incorporate some ideas from parsing algorithms like CYK (Younger 1967) into relaxed\u2013plan graph heuristics, while keeping the heuristic itself computable in polynomial time.", "startOffset": 103, "endOffset": 117}], "year": 2016, "abstractText": "In a recent paper, we have shown that Plan Recognition over STRIPS can be formulated and solved using Classical Planning heuristics and algorithms (Ramirez and Geffner 2009). In this work, we show that this formulation subsumes the standard formulation of Plan Recognition over libraries through a compilation of libraries into STRIPS theories. The libraries correspond to AND/OR graphs that may be cyclic and where children of AND nodes may be partially ordered. These libraries include Context-Free Grammars as a special case, where the Plan Recognition problem becomes a parsing with missing tokens problem. Plan Recognition over the standard libraries become Planning problems that can be easily solved by any modern planner, while recognition over more complex libraries, including Context\u2013Free Grammars (CFGs), illustrate limitations of current Planning heuristics and suggest improvements that may be relevant in other Planning problems too.", "creator": "LaTeX with hyperref package"}}}