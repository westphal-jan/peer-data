{"id": "1605.07805", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "25-May-2016", "title": "Learning Moore Machines from Input-Output Traces", "abstract": "random problem requires learning automata addressing example traces ( but including equivalence or multiple queries ) is described in automata learning practice but practice. in this setting we study this problem for finite state machines with entry and outputs, and in particular for managed servers. we introduce all components formally solving this problem : ( 1 ) the ptap algorithm, randomly makes template set producing multi - output copies into no ordinary moore network and it implements that machine with pair - linking ; ( 2 ) the prpni algorithm, additionally demonstrates the randomly - informed rpni principle for automata learning to learn entire product of automata containing a convex machine ; arise ( now ) the mooremi algorithm, of directly terminates incomplete moore machine using ptap extended with efficient processors. we prove that its optimal learns - right machine ; the good customer is taking clean sample, which is generally not true for the other compression algorithms. we also compare the polynomial individually in terms of the size of ideal mimic machine through various bases of precision, explained in this work. finally, just explain instance ostia, an algorithm that learns a more general class labeled transducers, both verify that ostia admits to not learn normal moore machine, so when struggling with multiple target sample.", "histories": [["v1", "Wed, 25 May 2016 10:11:03 GMT  (36kb,D)", "http://arxiv.org/abs/1605.07805v1", null], ["v2", "Fri, 2 Sep 2016 09:27:40 GMT  (45kb,D)", "http://arxiv.org/abs/1605.07805v2", null]], "reviews": [], "SUBJECTS": "cs.FL cs.LG", "authors": ["georgios giantamidis", "stavros tripakis"], "accepted": false, "id": "1605.07805"}, "pdf": {"name": "1605.07805.pdf", "metadata": {"source": "CRF", "title": "Learning Moore Machines from Input-Output Traces", "authors": ["Georgios Giantamidis", "Stavros Tripakis"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "An abundance of data from the internet and from other sources (e.g., sensors) is revolutionizing many sectors of science, technology, and ultimately our society. At the heart of this revolution lies machine learning, a broad spectrum of techniques to derive information from data. Traditionally, objects studied by machine learning include classifiers, decision trees, and neural networks, with applications to fields as diverse as artificial intelligence, marketing, finance, or medicine [19].\nIn the context of system design, an important problem, with numerous applications, is automatically generating models from data. There are many variants of this problem, depending on what types of models and data are considered, as well as other assumptions or restrictions. Examples include, but are by no means limited to, the classic field of system identification [18], as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [25,11,23,22,3].\nIn this paper we consider a basic problem, that of learning a Moore machine from a set of input-output traces. A Moore machine is a type of finite-state machine (FSM) with inputs and outputs, where the output always depends on the current state, but not on the current input [16]. Moore machines are typically deterministic and complete, meaning that for given state and input, the next state is always defined and is unique; and for given state, the output is also always uniquely defined. Such machines are useful in many applications, for instance, for representing digital circuits or controllers. In this paper we are interested in learning deterministic and complete Moore machines.\nWe want to learn a Moore machine from a given set of input-output traces. One such trace is a sequence of inputs, \u03c1in, and the corresponding sequence of outputs, \u03c1out, that the machine must produce when fed with \u03c1in. As in standard machine learning methods, we call the set of traces given to the learning algorithm the training set. Obviously, we would like the learned machine M to be consistent w.r.t. the training set R, meaning that for every pair (\u03c1in, \u03c1out) \u2208 R, M must output \u03c1out when fed with \u03c1in. But in addition to consistency, we would like M to behave well w.r.t. several performance criteria, including complexity of the learning algorithm, size of the learned machine M (its number of states), and accuracy of M , which captures how well M performs on a testing set of traces, different from the training set.\n? This work was partially supported by the Academy of Finland and the U.S. National Science Foundation (awards #1329759 and #1139138).\nar X\niv :1\n60 5.\n07 80\n5v 1\n[ cs\n.F L\n] 2\n5 M\nay 2\n01 6\nEven though this is a basic problem, it appears not to have received much attention in the literature. In fact, to the best of our knowledge, this is the first paper which tackles precisely this problem. This is despite a large body of research on grammatical inference [7] which has studied similar, but not exactly the same problems, such as learning deterministic finite automata (DFA), which are special cases of Moore machines with a binary output, or subsequential transducers, which are more general than Moore machines.\nOur contributions are the following:\n1. We define formally the LMoMIO problem (learning Moore machines from input-output traces) and introduce several notions of accuracy. We also adapt the notion of characteristic sample, which is known for DFA [7], to the case of Moore machines. Intuitively, a characteristic sample of a machine M is a set of traces which contains enough information to \u201creconstruct\u201d M . The characteristic sample requirement (CSR) states that, when given as input a characteristic sample, the learning algorithm must produce a machine equivalent to the one that produced the sample. CSR is important, as it ensures identification in the limit: this is a key concept in automata learning theory which ensures that the learning algorithm will eventually learn the right machine when provided with a sufficiently large set of examples [9].\n2. We present three algorithms to solve the LMoMIO problem, and analyze them in terms of computational complexity and other properties. We show that although all three algorithms guarantee consistency of the learned machine with the training set, only the most advanced among them, called MooreMI, satisfies the characteristic sample requirement.\n3. We report on a prototype implementation of all three algorithms and experimental results. The experiments show that MooreMI outperforms the other two algorithms not only in theory, but also in practice.\n4. We show that the well-known transducer-learning algorithm OSTIA [21] cannot generally learn a Moore machine, even in the case where the training set is a characteristic sample of a Moore machine. This further justifies the study of specialized learning algorithms for Moore machines."}, {"heading": "2 Related Work", "text": "There is a large body of research on learning automata and state machines, which can be divided into two broad categories: learning with queries (or active learning), and learning from examples. A seminal work in the first category is Angluin\u2019s work on learning DFAs with membership and equivalence queries [4]. This work has been subsequently extended to other types of machines, such as (extended) Mealy machines or register automata [24,14,13,6]. These works are not directly applicable to the problem studied in this paper, since we explicitly forbid both membership and equivalence queries.\nA seminal work in the second category is Gold\u2019s algorithm for learning DFAs from sets of positive and negative examples [10]. Subsequent work includes the RPNI [20] algorithm (that learns DFAs), of which an incremental version also exists [8], and derivatives, like the EDSM [17] (that also learns DFAs, but unlike RPNI does not guarantee identification in the limit) and OSTIA [21] (that learns subsequential transducers) algorithms. All the RPNI-based algorithms operate by first building some sort of prefix tree FSM and then attempting to minimize it via state merging. This is the case also for the MooreMI algorithm that we present in this paper.\nApart from state merging algorithms like the above, learning from examples has also been attempted with techniques from artificial intelligence, such as genetic algorithms [2] and ant colony optimization [5], as well as with reduction to satisfiability [12,27].\n[26] is close to our work, but the algorithm described there does not always yield a deterministic Moore machine, while ours does. Related to ours is also the work in [15], which deals with learning finite state machine abstractions of non-linear analog circuits. The algorithm described in [15] is very different from ours, however, and uses the circuit\u2019s number of inputs to determine a subset of the states in the learned abstraction. Also, identification in the limit is not considered in [15]."}, {"heading": "3 Preliminaries", "text": ""}, {"heading": "3.1 Finite state machines and automata", "text": "A finite state machine (FSM) is a tuple M of the form M = (I,O,Q, q0, \u03b4, \u03bb), where:\n\u2013 I is a finite set of input symbols. \u2013 O is a finite set of output symbols. \u2013 Q is a finite set of states. \u2013 q0 \u2208 Q is the initial state. \u2013 \u03b4 : Q\u00d7 I \u2192 Q is the transition function. \u2013 \u03bb is the output function, which can be of two types: \u2022 \u03bb : Q\u2192 O, in which case the FSM is a Moore machine. \u2022 \u03bb : Q\u00d7 I \u2192 O, in which case the FSM is a Mealy machine.\nIf both \u03b4 and \u03bb are total functions, we say that the FSM is complete. If any of \u03b4 and \u03bb is a partial function, we say that the FSM is incomplete. Examples of a Moore and a Mealy machine are given in Figure 1. Both FSMs are complete.\nWe also define \u03b4\u2217 : Q \u00d7 I\u2217 \u2192 Q and \u03bb\u2217 : Q \u00d7 I\u2217 \u2192 O\u2217 as follows (X\u2217 denotes the set of all finite sequences over some set X; \u2208 X\u2217 denotes the empty sequence over X; w \u00b7w\u2032 denotes the concatenation of two sequences w,w\u2032 \u2208 X\u2217): For q \u2208 Q, w \u2208 I\u2217, and a \u2208 I:\n\u2013 \u03b4\u2217(q, ) = q \u2013 \u03b4\u2217(q, w \u00b7 a) = \u03b4(\u03b4\u2217(q, w), a)\nThe rest of this paper focuses on Moore machines, thus we define \u03bb\u2217 only in the case where M is a Moore machine (the adaptation to a Mealy machine is straightforward):\n\u2013 \u03bb\u2217(q, ) = \u03bb(q) \u2013 \u03bb\u2217(q, w \u00b7 a) = \u03bb\u2217(q, w) \u00b7 \u03bb(\u03b4\u2217(q, w \u00b7 a))\nTwo Moore machines M1 = (I1, O1, Q1, q0 1, \u03b41, \u03bb1) and M2 = (I2, O2, Q2, q0 2, \u03b42, \u03bb2), are said to be equivalent iff I1 = I2, O1 = O2, and \u2200w \u2208 I\u22171 : \u03bb\u22171(q0 1, w) = \u03bb\u22172(q0 2, w).\nA Moore machineM = (I,O,Q, q0, \u03b4, \u03bb) is minimal if for any other Moore machineM \u2032 = (I \u2032, O\u2032, Q\u2032, q\u20320, \u03b4 \u2032, \u03bb\u2032) such that M and M \u2032 are equivalent, we have |Q| \u2264 |Q\u2032|, where |X| denotes the size of a set X.\nNotice that in the case two Moore machines are minimal, testing equivalence is reduced to a graph isomorphism test.\nA deterministic finite automaton (DFA) is a tuple A = (\u03a3,Q, q0, \u03b4, F ), where:\n\u2013 \u03a3 (the alphabet) is a finite set of letters. \u2013 Q is a finite set of states. \u2013 q0 \u2208 S is the initial state. \u2013 \u03b4 : Q\u00d7\u03a3 \u2192 Q is the transition function.\n\u2013 F \u2286 Q is the set of accepting states.\nA DFA can be seen as a special case of a Moore machine, where the set of input symbols I is \u03a3, and the set of output symbols is binary, say O = {0, 1}, with 1 and 0 corresponding to accepting and non-accepting states, respectively. The concepts of complete and incomplete DFAs, as well as the definition of \u03b4\u2217, are similar to the corresponding ones for FSMs. Elements of \u03a3\u2217 are usually called words. A DFA A = (\u03a3,Q, q0, \u03b4, F ) is said to accept a word w if \u03b4\u2217(w) \u2208 F .\nA non-deterministic finite automaton (NFA) is a tuple A = (\u03a3,Q,Q0, \u2206, F ), where \u03a3, Q, and F are as in a DFA, and:\n\u2013 Q0 \u2286 Q is the set of initial states. \u2013 \u2206 \u2286 Q\u00d7\u03a3 \u00d7Q is the transition relation.\nExamples of a DFA and an NFA are given in Figure 2. Accepting states are drawn with double circles."}, {"heading": "3.2 Input-output traces and examples", "text": "Given sets of input and output symbols I and O, respectively, a Moore (I,O)-trace is a pair of finite sequences (x1x2 \u00b7 \u00b7 \u00b7xn, y0y1 \u00b7 \u00b7 \u00b7 yn), for some natural number n \u2265 0, such that xi \u2208 I and yi \u2208 O for all i \u2264 n. That is, a Moore (I,O)-trace is a pair of a input sequence and an output sequence, such that the output sequence has length one more than the input sequence. Note that n may be 0, in which case the input sequence is empty (i.e., has length 0), and the output sequence contains just one output symbol.\nGiven a Moore (I,O)-trace \u03c1 = (x1x2 \u00b7 \u00b7 \u00b7xn, y0y1 \u00b7 \u00b7 \u00b7 yn), and a Moore machine M = (I,O,Q, q0, \u03b4, \u03bb), we say that \u03c1 is consistent with M if y0 = \u03bb(q0) and for all i = 1, ..., n, yi = \u03bb(qi), where qi = \u03b4(qi\u22121, xi).\nSimilarly to the concept of a Moore (I,O)-trace we define a Moore (I,O)-example as a pair of a finite input symbol sequence and an output symbol: (x1x2 \u00b7 \u00b7 \u00b7xn, y), where xi \u2208 I, for i = 1, ..., n, and y \u2208 O. We say that a Moore machine M = (I,O,Q, q0, \u03b4, \u03bb) is consistent with a Moore (I,O)-example \u03c1 = (x1x2 \u00b7 \u00b7 \u00b7xn, y) if \u03bb(\u03b4\u2217(x1x2 \u00b7 \u00b7 \u00b7xn)) = y.\nSince a DFA can be seen as the special case of a Moore machine with a binary output alphabet, the concept of a Moore (I,O)-example is naturally carried over to DFAs, in the form of positive and negative examples. Specifically, a finite word w is a positive example for a DFA if it is accepted by the DFA, and a negative example if it is rejected. Viewing a DFA as a Moore machine with binary output, a positive example w corresponds to the Moore example (w, 1), while a negative example corresponds to the Moore example (w, 0)."}, {"heading": "3.3 Prefix tree acceptors and prefix tree acceptor products", "text": "Given a finite and non-empty set of positive examples over a given alphabet \u03a3, S+ \u2286 \u03a3\u2217, we can construct, in a non-unique way, a tree-shaped, incomplete DFA, that accepts all words in S+, and rejects all others. Such a DFA is called a prefix tree acceptor [7] (PTA) for S+. For example, a PTA for S+ = {b, aa, ab} is shown in Figure 3.\nWe extend the concept of PTA to Moore machines. Suppose that we have a set SIO of Moore (I,O)examples. Let N = dlog2 |O|e be the number of bits necessary to represent an element of O. Then, given a\nfunction f that maps elements of O to bit tuples of length N , we can map SIO to N pairs of positive and negative example sets, {(S1+, S1\u2212), (S2+, S2\u2212), \u00b7 \u00b7 \u00b7, (SN+, SN\u2212)}. In particular, for each pair (w, y) \u2208 SIO, if the i-th element of f(y) is 1, then Si+ should contain w and Si\u2212 should not. Similarly, if the i-th element of f(y) is 0, then Si\u2212 should contain w and Si+ should not.\nWe can subsequently construct a prefix tree acceptor product (PTAP), which is a collection of N PTAs, one for each positive example set, Si+, for i = 1, \u00b7 \u00b7 \u00b7 , N . An example of a PTAP consisting of two PTAs is given in Figure 4."}, {"heading": "4 Characteristic samples", "text": "An important concept in automata learning theory is that of a characteristic sample [7]. A characteristic sample for a DFA is a set of words that captures all information about that automaton\u2019s set of states and behavior. In this paper we extend the concept of characteristic sample to Moore machines."}, {"heading": "4.1 Characteristic samples for Moore machines", "text": "Let M = (I,O,Q, q0, \u03b4, \u03bb) be a minimal Moore machine. Let < denote a total order on input words, i.e., on I\u2217, such that w < w\u2032 iff either |w| < |w\u2032|, or |w| = |w\u2032| but w comes before w\u2032 in lexicographic order (|w| denotes the length of a word w). For example, b < aa and aaa < aba.\nGiven a state q \u2208 Q, we define the shortest prefix of q as the shortest input word which can be used to reach q:\nSP (q) = min<{w \u2208 I\u2217 | \u03b4\u2217(q0, w) = q}.\nNotice that M is minimal, which implies that all its states are reachable (otherwise we could remove unreachable states). Therefore, SP (q) is well-defined for every state q of M .\nNext, we define the set of shortest prefixes of M , denoted SP (M), as:\nSP (M) = {SP (q) | q \u2208 Q}\nWe can now define the nucleus of M which contains the empty word and all one-letter extensions of words in SP (M):\nNL(M) = { } \u222a {w \u00b7 a | w \u2208 SP (M), a \u2208 I}.\nWe also define the minimum distinguishing suffix for two different states qu and qv of M , as follows:\nMD(qu, qv) = min<{w \u2208 I\u2217 | (\u03bb\u2217(qu, w)) 6= \u03bb\u2217(qv, w)}.\nMD(qu, qv) is guaranteed to exist for any two states qu, qv because M is minimal. Let W be a set of input words, W \u2286 I\u2217. Pref(W ) denotes the set of all prefixes of all words in W :\nPref(W ) = {x \u2208 I\u2217 | \u2203w \u2208W, y \u2208 I\u2217 : x \u00b7 y = w}.\nDefinition 1. Let SIO be a set of Moore (I,O)-traces, and let SI be the corresponding set of input words: SI = {\u03c1I \u2208 I\u2217 | (\u03c1I , \u03c1O) \u2208 SIO}. SIO is a characteristic sample for a Moore machine M iff:\n1. NL(M) \u2286 Pref(SI). 2. \u2200u \u2208 SP (M) : \u2200v \u2208 NL(M) : \u2200w \u2208 I\u2217 :\n\u03b4\u2217(q0, u) 6= \u03b4\u2217(q0, v) \u2227 w = MD(\u03b4\u2217(q0, u), \u03b4\u2217(q0, v))\u21d2 {u \u00b7 w, v \u00b7 w} \u2286 Pref(SI).\nFor example, consider the Moore machine M1 from Figure 1. We have: SP (q0) = , SP (q1) = x2, SP (M1) = { , x2}, and NL(M1) = { , x1, x2, x2x1, x2x2}. The following set is a characteristic sample for M1:\nSIO = { (x1, y1y1), (x2x1, y1y2y1), (x2x2, y1y2y2) }.\nWhile it is intuitive that a characteristic sample should contain input words that in a sense cover all states and transitions of M (Condition 1 of Definition 1), it may not be obvious why Condition 2 of Definition 1 is necessary. This becomes clear if we look at machines having the same output on several states. For example, consider the Moore machine in Figure 5a. The set of (I,O)-traces S1IO = {(aa, 020), (ba, 012), (bb, 012), (aba, 0222), (abb, 0222)} satisfies Condition 1 but not Condition 2, and therefore is not a characteristic sample of the machine of Figure 5a. If we use S1IO to learn a Moore machine, we obtain the machine in Figure 5b (this machine was produced by our MooreMI algorithm, described in Section 5.2). Clearly, the two machines of Figure 5 are not equivalent. For instance, the input word baa results in different outputs when fed to the two machines. The reason why the learning algorithm produces the wrong machine is that the set S1IO does not contain enough information to clearly distinguish between states q2 and q3.\nInstead, consider the set S2IO = {(aa, 020), (baa, 0122), (bba, 0122), (abaa, 02220), (abba, 02220)}. S2IO satisfies both Conditions 1 and 2, and therefore is a characteristic sample. Given S2IO as input, our MooreMI algorithm is able to learn the correct machine, i.e., the machine of Figure 5a. In this case, the minimum distinguishing suffix of states q2 and q3 is simply the letter a, since \u03b4(q2, a) = q0, \u03b4(q3, a) = q2 and \u03bb(q0) = 0 6= 2 = \u03bb(q2). Notice that S2IO can be constructed from S1IO by extending with the letter a the input words of the latter that land on q2 or q3.\nThe intuition, then, behind Condition 2 is that states in M that have the same outputs cannot be distinguished by just those (outputs); additional suffixes that differentiate them are required."}, {"heading": "4.2 Computation, minimality, size, and other properties of characteristic samples", "text": "It is easy to see that adding more traces to a characteristic sample preserves the characteristic sample property, i.e., if SIO is a characteristic sample for a Moore machine M and S \u2032 IO \u2287 SIO, then S\u2032IO is also a characteristic sample for M . Also, arbitrarily extending the input word of an existing (I,O)-trace in SIO and accordingly extending the corresponding output word, again yields a new characteristic sample for M . The questions are raised, then, whether there exist characteristic samples that are minimal in some sense, how many elements they consist of, what are the lengths of their elements, and how can we construct them.\nIn the following, we outline a simple procedure that, given a minimal Moore machine M , returns a characteristic sample SIO that is minimal in the sense that removing any (I,O)-trace from it or dropping\nany number of letters at the end of an input word in it (and accordingly adjusting the corresponding output word) will result in a set that is not a characteristic sample. By doing so, we also constructively establish the existence of at least one characteristic sample for any minimal Moore machine M .\nLet M = (I,O,Q, q0, \u03b4, \u03bb) be a minimal Moore machine, SI an initially empty set of input words and SIO the set of (I,O)-traces formed by the elements of SI and the corresponding output words. We compute SP (M) and NL(M), and add the elements of the latter to SI . Then, for each pair of words (u, v) \u2208 SP (M)\u00d7NL(M) leading to different states qu = \u03b4 \u2217(q0, u), qv = \u03b4 \u2217(q0, v), we compute MD(qu, qv) and add it to SI . Now, SIO already is a characteristic sample. However, it may contain redundant elements that can safely be removed. We can do this by simply considering each element of SI and removing it if it is a prefix of another element (this step can be sped up by choosing an appropriate data structure to represent SI , e.g. using a trie, we would simply just keep the words represented by the leaf nodes). Note that since the prefix relation on words is a partial order, and therefore transitive, the order in which we remove the redundant elements does not affect the final result. It is easy to see now that, after this step, (1) no element of SI is the prefix of another, (2) SIO is still a characteristic sample, and (3) removing any element from SI or dropping any number of letters at the and of it, will result in SIO not being a characteristic sample.\nBy definition, there is a 1 \u2212 1 correspondence between the elements of SP (M) and the states of M . Therefore, |SP (M)| = |Q|. It follows that |NL(M)| \u2264 |SP (M)| \u00b7 |I| + 1 = |Q| \u00b7 |I| + 1 and, consequently, |SIO| = |SI | \u2264 |NL(M)| + |SP (M)| \u00b7 |NL(M)| = (|Q| \u00b7 |I| + 1) \u00b7 (|Q| + 1). In other words, the size of SIO is O(|Q|2|I|).\nWe now provide bounds on the lengths of the elements of SIO. The lengths of shortest prefixes are bounded by the longest non-looping path in M , which in turn is bounded by |Q|. It follows that the nucleus element lengths are bounded by |Q|+1. Let now qu and qv be different states of M and consider M1 = (I,O,Q, qu, \u03b4, \u03bb) and M2 = (I,O,Q, qv, \u03b4, \u03bb), i.e. M1 and M2 have qu and qv as initial states, respectively, but are otherwise identical to M . Finding a (minimum) distinguishing suffix of qu and qv is now reduced to finding a (minimum) input word that leads to different output words when transduced by M1 and M2. To find such a word, we first construct a DFA A = (I,Q \u00d7 Q, (qu, qv), \u03b4A, F ), where \u2200(q1, q2) \u2208 Q \u00d7 Q : \u2200a \u2208 I : \u03b4A((q1, q2), a) = (\u03b4(q1, a), \u03b4(q2, a)) and F = {(q1, q2) \u2208 Q\u00d7Q | \u03bb(q1) 6= \u03bb(q2)}. A word accepted by this DFA is a distinguishing suffix of qu and qv, and it is easy to see that we only need to test words of length up to |Q\u00d7Q| in order to find one. We can conclude from the above that the sum of lengths of elements in SIO is O(|Q|4|I|)."}, {"heading": "5 Learning Moore machines from Input-Output Traces", "text": ""}, {"heading": "5.1 Problem definition", "text": "The problem of learning Moore machines from input-output traces (LMoMIO) is defined as follows. Given an input alphabet I, an output alphabet O, and a set Rtrain of Moore (I,O)-traces, called the training set, we want to synthesize automatically a deterministic, complete Moore machine M = (I,O,Q, q0, \u03b4, \u03bb), such that M is consistent with Rtrain, i.e., \u2200 (\u03c1I , \u03c1O) \u2208 Rtrain : \u03bb\u2217(\u03c1I) = \u03c1O. (Rtrain is assumed to be itself consistent, in the sense it does not contain two different pairs with the same input word.)\nIn addition to consistency, we would like to evaluate our learning technique w.r.t. various performance criteria, including:\n\u2013 Size of M , in terms of number of states. Ideally, M should be minimal, that is, if M \u2032 is another machine which is also consistent with Rtrain, then M has no more states than M\n\u2032. \u2013 Accuracy of M , which, informally speaking, is a measure of how well M performs on a set of traces, Rtest,\ndifferent from the training set. Rtest is called the test set. Accuracy is a standard criterion in machine learning.\n\u2013 Complexity (e.g., running time) of the learning algorithm itself.\nIn the rest of this paper, we present three learning algorithms which solve the LMoMIO problem, and evaluate them w.r.t. the above criteria. Complexity of the algorithm and size of the learned machine are standard notions. Accuracy is standard in machine learning topics such as classification, but not in automata learning. Thus, we elaborate on this concept next.\nThere are more than one ways to measure the accuracy of a learned Moore machine M against a test set Rtest. We call an accuracy evaluation policy (AEP) any function that, given a Moore (I,O)-trace (\u03c1I , \u03c1O) and a Moore machine M = (I,O,Q, q0, \u03b4, \u03bb), will return a real number in [0, 1]. We will call that number the accuracy of M on (\u03c1I , \u03c1O). In this paper, we use three AEPs which we call strong, medium, and weak, defined below. Let (\u03c1I , \u03c1O) = (x1x2 \u00b7 \u00b7 \u00b7xn, y0y1 \u00b7 \u00b7 \u00b7 yn) and z0z1 \u00b7 \u00b7 \u00b7 zn = \u03bb\u2217(q0, \u03c1I).\n\u2013 Strong: if \u03bb\u2217(q0, \u03c1I) = \u03c1O then 1 else 0. \u2013 Medium: 1n+1 \u00b7 |{i | y0y1 \u00b7 \u00b7 \u00b7 yi = z0z1 \u00b7 \u00b7 \u00b7 zi}|. \u2013 Weak: 1n+1 \u00b7 |{i | yi = zi}|.\nThe strong AEP says that the output of the learned machine M must be identical to the output in the test set. The medium AEP returns the proportion of the largest output prefix that matches. The weak AEP returns the number of output symbols that match. For example, if the correct output is 0012 and M returns 0022 then the strong accuracy is 0, the medium accuracy is 24 , and the weak accuracy is 3 4 .\nGiven an accuracy evaluation policy f and a test set Rtest, we define the accuracy of M on Rtest as the averaged accuracy of M over all traces in Rtest, i.e.,\u2211\n(\u03c1I ,\u03c1O)\u2208Rtest f((\u03c1I , \u03c1O),M)\n|Rtest| .\nIt is often the case that the test set Rtest contains traces generated by a \u201cblack box\u201d, for which we are trying to learn a model. Suppose this black box corresponds to an unknown machine M?. Then, ideally, we would like the learned machine M to be equivalent to M?. In that case, no matter what test set is generated by M?, the learned machine M will always achieve 100% accuracy. Of course, achieving this ideal depends on the training set: if the latter is \u201cpoor\u201d then it does not contain enough information to identify the original machine M?. A standard requirement in automata learning theory states that when the training set is a characteristic sample of M?, then the learning algorithm should be able to produce a machine which is equivalent to M?. We call this the characteristic sample requirement (CSR). CSR is important, as it ensures identification in the limit, a key concept in automata learning theory [9]. In what follows, we show that among the algorithms that will be presented in \u00a75.2, only MooreMI satisfies CSR.\nBefore proceeding, we remark that a given Moore (I,O)-trace (\u03c1I , \u03c1O) = (x1x2 \u00b7 \u00b7 \u00b7xn, y0y1 \u00b7 \u00b7 \u00b7 yn) can be represented as a set of n + 1 Moore (I,O)-examples, specifically {( , y0), (x1, y1), (x1x2, y2), \u00b7 \u00b7 \u00b7, (x1x2 \u00b7 \u00b7 \u00b7xn, yn)}. Because of this observation, in all approaches discussed below, there is a preprocessing step to convert the training set, first into an equivalent set of Moore (I,O)-examples, and second, into an equivalent set of N pairs of positive and negative example sets (the latter conversion was described in \u00a73.3)."}, {"heading": "5.2 Algorithms to solve the LMoMIO problem", "text": "The PTAP algorithm This algorithm is a rather straightforward one.The set of Moore (I,O)-examples obtained after the preprocessing step described above is used to construct a PTAP, as described in \u00a73.3.Recall that a PTAP is a collection of N PTAs having the same state-transition structure. The synchronous product of these N PTAs is then formed, completed, and returned as the result of the algorithm. Completion in this case consists in adding self-loops to states that are missing outgoing transitions for some input symbols. The added self-loops are labeled with the missing input symbols.\nAlthough the PTAP algorithm is relatively easy to implement and runs efficiently, it has several drawbacks. First, since no state minimization is attempted, the resulting Moore machine can be unnecessarily large. Second, and most importantly, the produced machines generally have poor accuracy, since completion is done in a trivial manner.\nThe PRPNI algorithm Again, consider the N pairs of positive and negative example sets obtained after the preprocessing step. The PRPNI algorithm starts by executing the RPNI DFA learning algorithm [20] on each pair, thus obtaining N learned DFAs. Then, the synchronous product of these DFAs is formed, completed, and returned as the algorithm result.\nThe completion step of the PRPNI algorithm is more intricate than the completion step of the PTAP algorithm. The reason is that the synchronous product of the learned DFAs may contain reachable states whose bit encoding does not correspond to any valid output in O. For example, suppose O = {0, 1, 2}, so that we need 2 bits to encode it, and thus N = 2 and we use RPNI to learn 2 DFAs. Suppose the encoding is 0 7\u2192 00, 1 7\u2192 01, 2 7\u2192 10. This means that the code 11 does not correspond to any valid output in O. However, it can still be the case that in the product of the two DFAs there is a reachable state with the output 11, i.e., where both DFAs are in an accepting state. Note that this problem does not arise in the PTAP algorithm, because all PTAs there are guaranteed to have the same state-transition structure, which is also the structure of their synchronous product.\nTo solve this invalid-code problem, we assign all invalid codes to an arbitrary valid output. In our implementation, we use the lexicographic minimum. In the above example, the code 11 will be assigned to the output 0.\nCompared to the PTAP algorithm, the PRPNI algorithm has the advantage of being able to learn a minimal Moore machine when provided with enough (I,O)-traces. However, it can also perform worse in terms of both running time and size (number of states) of the learned machine, due to potential state explosion while forming the DFA product. The PTAP algorithm does not have this problem because, as explained above, the structure, and therefore also the number of states, of the product is identical to those of the component PTAs.\nThe MooreMI algorithm As we saw above, both the PTAP and PRPNI algorithms have several drawbacks. In this section we propose a novel algorithm, called, MooreMI, which remedies these. Moreover, we shall prove that MooreMI satisfies CSR.\nThe MooreMI algorithm begins by building a PTAP represented as N PTAs, as in the PTAP algorithm. Then, a merging phase follows, where a merge operation is accepted only if all resulting DFAs are consistent with their respective negative example sets. In addition, a merge operation is either performed on all DFAs at once or not at all. Finally, the synchronous product of the N learned DFAs is formed, completed by adding self loops for any missing input symbols, as in the PTAP algorithm, and returned. The pseudocode of the algorithm is given below. The main MooreMI procedure calls the merge function as a subroutine. merge\ncomputes the result of merging the given red and blue states of the given DFA component. It also performs additional potentially necessary state merges to preserve determinism.\n1 def MooreMI(trace set , \u03a3I , \u03a3O): 2\n3 (list of pos example sets ,\n4 list of neg example sets ,\n5 bits to output func) 6 := preprocess moore traces(trace set) 7 8 N := ceil( log2( |\u03a3O | ) ) 9\n10 DFA list := build prefix tree acceptor product( 11 list of pos example sets , \u03a3I , \u03a3O) 12 13 red = { q } 14 blue = { qa for a in \u03a3I } \u2229 DFA list[0].Q 15 16 while blue 6= \u2205: 17 18 q blue = pick next(blue) 19 blue := blue \u2212 {q blue} 20\n21 merge accepted := false\n22 23 for q red \u2208 red: 24 25 for i \u2208 {0, ..., N \u2212 1}: 26 new DFA list[i] := 27 merge(DFA list[i], q red , q blue) 28 29 if \u2200 i \u2208 {0, ..., N \u2212 1}: 30 is consistent( 31 new DFA list[i],\n32 list of neg example sets[i]):\n33 merge accepted := true\n34 break\n35\n36 if merge accepted:\n37 DFA list := new DFA list 38 blue := blue \u222a ( { one\u2212letter 39 successors of red states } 40 \u2229 DFA list[0].Q ) 41 else: 42 red := red \u222a {q blue} 43 blue := blue \u222a ( { one\u2212letter 44 successors of q blue } 45 \u2229 DFA list[0].Q ) 46 47 return product( 48 DFA list , 49 bits to output func).make complete()\n50 51 def merge(DFA, q red , q blue): 52 53 q u := unique parent of (q blue) 54 a u := unique input from to(q u , q blue) 55 56 DFA.\u03b4(q u , a u) := q red 57\n58 merge stack := [(q red , q blue)]\n59 60 while merge stack 6= []: 61 62 (q 1 , q 2) := pop(merge stack) 63\n64 if q 1 = q 2 : continue\n65 66 if (q 1 , q 2) 6= (q red , q blue) 67 and q 2 < q 1: 68 q 1 , q 2 := q 2 , q 1\n69 70 DFA.Q := DFA.Q \u2212 {q 2} 71 72 if q 2 \u2208 DFA.F : 73 DFA.F := DFA.F \u222a {q 1} 74 75 for a \u2208 DFA.\u03a3: 76 if is defined(DFA.\u03b4(q 2 , a)): 77 if is defined(DFA.\u03b4(q 1 , a)): 78 79 push(merge stack , 80 DFA.\u03b4(q 1 , a), 81 DFA.\u03b4(q 2 , a))) 82 else: 83 DFA.\u03b4(q 1 , a) := DFA.\u03b4(q 2 , a) 84\n85 return DFA\nAfter the initial preprocessing step (line 6), the algorithm builds a prefix tree acceptor product (line 10) and then repeatedly attempts to merge states in it, in a specific order (line 16). While not appearing in the original RPNI algorithm, the convention of marking states as red or blue was introduced later in [17]. States marked as red represent states that have been processed and will be part of the resulting machine. States marked as blue are immediate successors of red states and represent states that are currently being processed. Initially, the set of red states only contains the initial state q , and the set of blue states contains the one-letter successors of q (lines 13, 14). Unmarked states will eventually become blue (lines 38, 43), and then either merged with red ones (lines 27, 36) or become red states themselves (line 42).\nMost of the auxiliary functions whose implementations are not shown in the pseudocode above have self explanatory names. For instance, the push and pop functions push and pop, respectively, elements to / from a stack, and the functions in lines 53, 54 compute the unique parent of and corresponding input symbol leading to the given blue state (uniqueness of both is guaranteed by the tree-shaped nature of the initial PTA). The function pick next, however, deserves some additional explanation. Notice first that after the prefix tree acceptor product is constructed and before the merging phase of the algorithm begins, each state can reached by a unique input word which is used to identify that state. For example, the state reached by\nthe word abba is referred to as state qabba. The word used to identify a state may change during merging operations. The total order on words < defined in \u00a74.1 can now naturally be extended on states of the learned machine as follows: qu < qv \u21d0\u21d2 u < v, in which case we say that qu is smaller than qv. The pick next function above simply returns the smallest state of the blue set, according to the order we just defined.\nMooreMI is able to learn minimal Moore machines, while avoiding the state explosion and invalid code issues of PRPNI. To see this, notice first that, at every point of the algorithm, the N learned DFAs are identical in terms of states and transitions, modulo the marking of their states as final. Indeed, this invariant holds by construction for the N initial prefix tree acceptors, and the additional merge constraints make sure it is maintained throughout the algorithm. Therefore, the product formed at the end of the algorithm can be obtained by simply \u201coverlaying\u201d the N DFAs on top of one another, as in the PTAP approach, which implies no state explosion. The absence of invalid output codes is also easy to see. Invalid codes generally are results of problematic state tuples in the DFA product, that cannot appear in MooreMI due to the additional merge constraints. Indeed, if a state tuple occurs in the final product, it must also occur in the initial prefix tree acceptor product, and if it occurs there, its code cannot be invalid."}, {"heading": "5.3 Properties of the algorithms", "text": "All three algorithms described above satisfy consistency w.r.t. the input training set. For PTAP and PRPNI, this a direct consequence of the properties of PTAs, of the basic RPNI algorithm, and of the synchronous product. The proof for MooreMI is somewhat more involved:\nTheorem 1. The output of the MooreMI algorithm is a complete Moore machine, consistent with the training set. Formally, let SIO be the set of Moore (I,O)-traces used as input for the algorithm, and let M = (I,O,Q, q0, \u03b4, \u03bb) be the resulting Moore machine. Then, \u03b4 and \u03bb are total functions and \u2200 (\u03c1I , \u03c1O) \u2208 SIO : \u03bb\u2217(q0, \u03c1I) = \u03c1O.\nProof. The fact that \u03b4 and \u03bb are total is guaranteed by the final step of the algorithm (line 49). Consistency with the training set can be proved inductively. Let N denote the number of DFAs learned by the algorithm, which is equal to the number of bits required to represent an element of O. By definition, the Moore machine implicitly defined (by means of a synchronous product) by the N prefix tree acceptors initially built by the algorithm is consistent with the training set. Assume that, before a merge operation is performed, the Moore machine implicitly defined by the (possibly incomplete) DFAs learned so far is consistent with the training set. It suffices to show that the result of the next merge operation also has this property. Suppose it does not. This means that there exists a (\u03c1I , \u03c1O) \u2208 SIO, such that \u03bb\u2217(q0, \u03c1I) 6= \u03c1O, which implies that in at least one of the learned DFAs, at least one state was added to the corresponding set of final states, while it should not have been (note that performing a merge operation on a DFA always yields a result accepting a superset of the language accepted prior to the merge). In other words, there is at least one learned DFA that is not consistent with its corresponding projection of the training set. However, due to the additional merge constraints that were introduced, this cannot happen, since all DFAs must be compatible with a merge in order for it to take place (line 29).\nWe now show that MooreMI satisfies the characteristic sample requirement, i.e., if it is fed with a characteristic sample for a machine M , then it learns a machine equivalent to M . If M is minimal then the learned machine will in fact be isomorphic to M . We first introduce some auxiliary definitions and notation, and make some observations which are important for the proof of the result.\nLet M = (I,O,Qm, q0 m, \u03b4m, \u03bbm) be the minimal Moore machine from which we derive a characteristic sample, then given as input to the MooreMI algorithm. Let MA = (I,O,QA, q , \u03b4A, \u03bbA) be the machine produced by the algorithm. We will use plain Q and \u03b4 to denote the state set and possibly partial transition function of the learned machine in an intermediate step of the algorithm.\nIt can be seen in the pseudocode of the merge function (line 66) that when two states qu, qv are merged in order to preserve determinism, the input word used to identify the resulting state is min<{u, v}, where < is the total order defined in \u00a74.1. When we say that qu is smaller than qv or qv bigger than qu, we will\nmean u = min<{u, v}. We remark that when a blue state is merged with a red one, the latter is always smaller. This is a direct consequence of the tree-shaped nature of the initial prefix tree acceptor product, the fact that blue states are one-letter successors of red ones, and the specific order in which blue states are considered during the merging phase.\nBy saying that a state qu \u2208 Q corresponds to a shortest prefix of M , we mean that u \u2208 SP (M). By saying that a state qv \u2208 Q corresponds to an element in NL(M), we mean that the state qv can be reached from q using an element in NL(M).\nred and blue refer to the sets of red and blue states, as in the pseudocode of MooreMI. Given a red state qu, we will use Merged(qu) to denote the set of states that have been merged with / into qu.\nIn the following, we assume that the training set used as input to the MooreMI algorithm is a characteristic sample for a minimal Moore machine M .\nLemma 1.\n(a) Each red state corresponds to an element of SP (M) and as a consequence, to a state in M . (b) Each blue state corresponds to an element of NL(M). (c) \u2200qu \u2208 red : \u2200qv \u2208Merged(qu) : \u03b4\u2217m(q0 m, v) = \u03b4\u2217m(q0 m, u).\nProof. By induction. Initially, red = {q }, blue \u2286 {qa | a \u2208 I}, and (a), (b), (c) all hold trivially. We assume they hold for the current sets of red, blue and unmarked states and will show they still hold after all possible operations performed by the algorithm:\n\u2013 If a state qv \u2208 blue is merged into a state qu \u2208 red, then (a) trivially holds: The red state set remains the same, and the successors of qv are marked blue. Since they now are successors of a state corresponding to a shortest prefix (the red state qu), they correspond to elements in the nucleus of M , so (b) holds too. Suppose now that (c) does not hold, i.e. it is \u03b4\u2217m(q0 m, v) 6= \u03b4\u2217m(q0 m, u). Since, by the induction hypothesis, u \u2208 SP (M) and qv corresponds to an element in NL(M), by the characteristic sample definition, there exist (I,O)-traces that distinguish qv and qu and prohibit their merge. But qv and qu were successfully merged, therefore \u03b4\u2217m(q0 m, v) = \u03b4 \u2217 m(q0 m, u) and (c) holds. \u2013 If a state qv \u2208 blue is promoted to a red state, then it is distinct from all other red states. Moreover, since (i) the algorithm considers blue states in a specific order and (ii) whenever we perform a merge between two states qx and qy to preserve determinism the result is identified as qmin<(x,y), qv is the smallest state distinct from the existing red states, therefore it corresponds to a shortest prefix. Its successors are now marked blue and since qv corresponds to a shortest prefix, they correspond to states in NL(M). Also, since the newly promoted red state is a shortest prefix distinct from the previous ones, it corresponds to a unique, different state in M . The above imply that (a) and (b) hold. Moreover, (c) trivially holds too. \u2013 Regarding the additional state merges possibly required to maintain determinism after (1), they can occur between a red and a blue state, in which case the same as in (1) hold, between a blue state and a state that is either blue or unmarked, in which case we have what we want by the induction hypothesis, and between two unmarked states, in which case we do not need to show anything. However, we should mention here that for every pair of states being merged to preserve determinism, the two states involved necessarily represent the same state in M . Suppose, without loss of generality that after merging states qu and qv as in (1), states qua = \u03b4 \u2217(qu, a) and qva = \u03b4 \u2217(qv, a) need to also be merged to preserve\ndeterminism. If qua and qva do not represent the same state in M , their minimum distinguishing suffix w = MD(qua, qva) exists. But then, a \u00b7w is a distinguishing suffix for qu and qv, which means that qu and qv represent different states in M . However, this cannot be, because, since by the induction hypothesis u \u2208 SP (M) and qv corresponds to an element in NL(M), by the characteristic sample definition, if qu and qv were different states, (I,O)-traces prohibiting their merge would be present in the algorithm input. Therefore, qua and qva represent the same state in M . The same argument can now be made if e.g. states quab and qvab need to be merged to preserve determinism after qua and qva are merged, and so on.\nLemma 2. |Qm| \u2264 |QA|\nProof. Suppose that |Qm| > |QA|, i.e. there exists q \u2208 Qm such that there is no equivalent of q in QA. However, by the definition of the characteristic sample, the shortest prefix of q appears in the algorithm input, and, according to Lemma 1, it must eventually form a red state on its own. Therefore, there is no such state as q, and |Qm| \u2264 |QA| holds. Corollary 1. The previous lemmas imply the existence of a bijection fiso : QA \u2192 Qm such that fiso(qu) = \u03b4\u2217m(q0 m, u).\nLemma 3. \u2200qu \u2208 QA : \u03bbA(qu) = \u03bbm(fiso(qu)) Proof. We have shown that qu \u2208 QA corresponds to a unique state in M , specifically \u03b4\u2217m(q0 m, u). We have also shown that the algorithm is consistent with the training examples. This implies \u03bbA(qu) = \u03bbm(\u03b4 \u2217 m(q0 m, u)). Now, since, by definition, fiso(qu) = \u03b4 \u2217 m(q0 m, u), we have what we wanted.\nLemma 4. \u2200qu \u2208 QA : \u2200a \u2208 I : \u03b4m(fiso(qu), a) = fiso(\u03b4A(qu, a)) Proof. Let \u03b4A(qu, a) = \u03b4 \u2217 A(q , u \u00b7 a) = qv \u2208 QA. By definition, we have fiso(qu) = \u03b4\u2217m(q0 m, u) and fiso(qv) = \u03b4\u2217m(q0 m, v). In addition, \u03b4 \u2217 m(fiso(qu), a) = \u03b4m(\u03b4 \u2217 m(q0 m, u), a) = \u03b4 \u2217 m(q0 m, u \u00b7 a). But \u03b4\u2217A(q , u \u00b7 a) = qv = \u03b4\u2217A(q , v), therefore, from Lemma 1 (c) we have \u03b4 \u2217 m(q0 m, u \u00b7 a) = \u03b4\u2217m(q0 m, v). Finally, \u03b4m(fiso(qu), a) = \u03b4m(q0 m, u \u00b7 a) = \u03b4m(q0 m, v) = fiso(qv) = fiso(\u03b4A(qu, a)), as we wanted. Theorem 2. If the input to MooreMI is a characteristic sample of a minimal Moore machine M , then the algorithm returns a machine MA that is isomorphic to M .\nProof. Follows from Corollary 1, Lemmas 3, 4 and the observation that fiso(q ) = q0 m. The bijection fiso constitutes a witness isomorphism between M and MA."}, {"heading": "5.4 Performance optimizations", "text": "Compared to the pseudocode our implementation includes several optimizations. First, to limit the amount of copying involved in performing a merge operation, we perform the required state merges in-place, and at the same time record the actions needed to undo them in case the merge is not accepted.\nSecond, the merge function needs to know the unique (due to the tree-shaped nature of PTAs) parent of the blue state passed to it as an argument. The naive way of doing this, simply iterating over the states until we reach the parent, can seriously harm performance. Instead, in our implementation, we build during PTA construction, and maintain throughout the algorithm, a mapping of states to their parents, and consult this when needed.\nThird, in the negative examples consistency test, many of the acceptance checks involved are redundant. For example, suppose that starting from the initial state it is only possible to reach red states (i.e. not blue or unmarked ones) within n steps (transitions). Then, there is no need to include negative examples of length less than n in the consistency test. Our implementation optimizes such cases by integrating the consistency test with the merge operation."}, {"heading": "5.5 Complexity analysis", "text": "Let I and O be the input and output alphabets, and let SIO be the set of Moore (I,O)-traces provided as input to the learning algorithms. Let N = dlog2(|O|)e be the number of bits required to encode the symbols in O. Let S1+, S1\u2212, ..., SN+, SN\u2212 be the positive and negative example sets obtained by the preprocessing\nstep at the beginning of each algorithm. Let m+ = \u2211N i=1 \u2211 w\u2208Si+ |w|, m\u2212 = \u2211N i=1 \u2211 w\u2208Si\u2212 |w|, and k =\u2211\n(\u03c1I ,\u03c1O)\u2208SIO |\u03c1I | 2. The time required for the preprocessing step is O(N \u00b7 k), and is the same for all three\nalgorithms. The time required for the rest of the phases of each algorithm is\n\u2013 O((N + |I|) \u00b7m+) for PTAP, \u2013 O((N + |I|) \u00b7mN+ +N \u00b7m2+ \u00b7 (m+ +m\u2212)) for PRPNI, and \u2013 O((N + |I|) \u00b7m+ +N \u00b7m2+ \u00b7 (m+ +m\u2212)) for MooreMI.\nIt can be seen that the complexity of MooreMI is no more than logarithmic in the number of output symbols, linear in the number of inputs, and cubic in the total length of training traces."}, {"heading": "6 Implementation & Experiments", "text": "All three algorithms presented in \u00a75.2 have been implemented in Python. The source code, including random Moore machine and characteristic sample generation, learning algorithms and testing, spans roughly 2000 lines of code. The code and experiments are available upon request and will be made available online in a future version of this work."}, {"heading": "6.1 Experimental comparison", "text": "We randomly generated several minimal Moore machines of sizes 50 and 150 states, and input and alphabet sizes |I| = |O| = 25. From each such machine, we generated a characteristic sample, and ran each of the three algorithms on this characteristic sample. Then we took the learned machines generated by the algorithms, and evaluated these machines in terms of size (# states) and accuracy. For accuracy, we used a test set of size double the size of the training set. The length of words in the test set was double the maximum training word length.\nThe results are shown in Tables 1 and 2. \u201cAlgo 1,2,3\u201d refers to PTAP, PRPNI, and MooreMI, respectively. \u201cTime\u201d refers to the execution time of the learning algorithm (in seconds). \u201cStates\u201d refers to the number of states of the learned machines. For accuracy, we used the three AEPs, Strong, Medium, and Weak, defined in \u00a75.1. In the tables, each row represents the average performance of a specific algorithm over training sets generated by 5 different Moore machines. The only exception is row 2 of Table 1, where one of the 5 experiments timed out and the reported averages are over 4 experiments. \u201cTimeout\u201d means that the algorithm was unable to terminate within the given time limit (60 seconds) in any of the 5 experiments with 150 states.\nAs expected, MooreMI always achieves 100% accuracy, since the input is a characteristic sample (we verified that indeed the machines learned by MooreMI are in each case equivalent to the original machine that produced the training set). But as it can be seen from the tables, neither PTAP nor PRPNI learn the correct machines, even though the training set is a characteristic sample.\nThe tables also show that PTAP and PRPNI generate much larger machines than the correct ones. This in turn explains why MooreMI performs better in terms of running time than the other two algorithms, which spend a lot of time completing the large number of generated states."}, {"heading": "6.2 Comparison with OSTIA", "text": "OSTIA [21] is a well-known algorithm that learns onward subsequential transducers, a class of transducers more general than Moore and Mealy machines. Then, a question arising naturally is whether it is possible to use OSTIA for learning Moore machines. In particular, we would like to know what happens when the input\nto OSTIA is a set of Moore (I,O)-traces: will OSTIA learn a Moore machine? The answer here is negative, as indicated by an experiment we performed. We constructed a characteristic sample for the Moore machine in Figure 5a and ran the OSTIA algorithm on it (we used the open source implementation described in [1]). The resulting machine is depcited in Figure 6. Notice that there are transitions whose corresponding outputs are words of length more than 1 (e.g., transition label b/0122), or even the empty word (output of initial state q0). We conclude that in general OSTIA cannot learn Moore machines, even when the training set is a set of Moore traces, and is also a characteristic sample."}, {"heading": "7 Conclusion & Future Work", "text": "We presented three algorithms to learn Moore machines from input-output traces. The most advanced of the three algorithms, MooreMI, has desirable performance properties, both theoretical (it satisfies the characteristic sample requirement) as well as in practice.\nFuture work includes: (1) studying learning for Mealy and other types of state machines; (2) developing incremental versions of the learning algorithms presented here; (3) further implementation and experimentation; and (4) application of the methods presented here for learning models of various types of black-box systems."}], "references": [{"title": "C", "author": ["H.I. Akram"], "venue": "de la Higuera, H. Xiao, and C. Eckert. Grammatical inference algorithms in matlab. In ICGI\u201910, Proceedings, pages 262\u2013266. Springer,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2010}, {"title": "The use of evolutionary programming based on training examples for the generation of finite state machines for controlling objects with complex behavior", "author": ["A.V. Aleksandrov", "S.V. Kazakov", "A.A. Sergushichev", "F.N. Tsarev", "A.A. Shalyto"], "venue": "J. Comput. Sys. Sc. Int., 52(3):410\u2013425,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2013}, {"title": "Synthesizing Finite-state Protocols from Scenarios and Requirements", "author": ["R. Alur", "M. Martin", "M. Raghothaman", "C. Stergiou", "S. Tripakis", "A. Udupa"], "venue": "In HVC, volume 8855 of LNCS. Springer,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "Learning regular sets from queries and counterexamples", "author": ["D. Angluin"], "venue": "Inf. Comput., 75(2):87\u2013106,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1987}, {"title": "Inducing finite state machines from training samples using ant colony optimization", "author": ["I.P. Buzhinsky", "V.I. Ulyantsev", "D.S. Chivilikhin", "A.A. Shalyto"], "venue": "J. Comput. Sys. Sc. Int., 53(2):256\u2013266,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2014}, {"title": "Learning extended finite state machines", "author": ["S. Cassel", "F. Howar", "B. Jonsson", "B. Steffen"], "venue": "In SEFM 2014, Proceedings, pages 250\u2013264,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2014}, {"title": "Grammatical Inference: Learning Automata and Grammars", "author": ["C. de la Higuera"], "venue": "CUP,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Incremental regular inference", "author": ["P. Dupont"], "venue": "In ICGI-96, Proceedings, pages 222\u2013237,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 1996}, {"title": "Language identification in the limit", "author": ["E.M. Gold"], "venue": "Information and Control, 10(5):447\u2013474,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1967}, {"title": "Complexity of automaton identification from given data", "author": ["E.M. Gold"], "venue": "Information and Control, 37(3):302\u2013320,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1978}, {"title": "Automating string processing in spreadsheets using input-output examples", "author": ["S. Gulwani"], "venue": "In 38th POPL, pages 317\u2013330,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2011}, {"title": "Exact DFA identification using SAT solvers", "author": ["M.J.H. Heule", "S. Verwer"], "venue": "In J. M. Sempere and P. Gar\u0107\u0131a, editors, ICGI, pages 66\u201379. Springer,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "Inferring canonical register automata", "author": ["F. Howar", "B. Steffen", "B. Jonsson", "S. Cassel"], "venue": "In VMCAI 2012, Proceedings, pages 251\u2013266,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Learning of automata models extended with data", "author": ["B. Jonsson"], "venue": "In SFM 2011, Advanced Lectures, pages 327\u2013349,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "ABCD-NL: Approximating continuous non-linear dynamical systems using purely boolean models for analog/mixed-signal verification", "author": ["A.V. Karthik", "S. Ray", "P. Nuzzo", "A. Mishchenko", "R. Brayton", "J. Roychowdhury"], "venue": "In ASP-DAC, pages 250\u2013255,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2014}, {"title": "Switching and finite automata theory, 2nd ed", "author": ["Z. Kohavi"], "venue": "McGraw-Hill,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1978}, {"title": "Results of the abbadingo one DFA learning competition and a new evidence-driven state merging algorithm", "author": ["K.J. Lang", "B.A. Pearlmutter", "R.A. Price"], "venue": "In ICGI-98, Proceedings, pages 1\u201312,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1998}, {"title": "editor", "author": ["L. Ljung"], "venue": "System Identification (2nd Ed.): Theory for the User. Prentice Hall,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1999}, {"title": "Machine Learning", "author": ["T.M. Mitchell"], "venue": "McGraw-Hill,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1997}, {"title": "Identifying regular languages in polynomial time", "author": ["J. Oncina", "P. Garcia"], "venue": "In Advances in Structural and Syntactic Pattern Recognition, pages 99\u2013108,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1992}, {"title": "Learning subsequential transducers for pattern recognition interpretation tasks", "author": ["J. Oncina", "P. Gar\u0107\u0131a", "E. Vidal"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell., 15(5):448\u2013458,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1993}, {"title": "A large scale study of programming languages and code quality in github", "author": ["B. Ray", "D. Posnett", "V. Filkov", "P. Devanbu"], "venue": "In ACM SIGSOFT, FSE \u201914,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2014}, {"title": "Sciduction: Combining induction, deduction, and structure for verification and synthesis", "author": ["S.A. Seshia"], "venue": "In DAC, pages 356\u2013365, June", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2012}, {"title": "Inferring mealy machines", "author": ["M. Shahbaz", "R. Groz"], "venue": "In FM 2009, pages 207\u2013222,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2009}, {"title": "Program sketching", "author": ["A. Solar-Lezama"], "venue": "STTT, 15(5-6):475\u2013495,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "A polynomial time algorithm to infer sequential machines", "author": ["K. Takahashi", "A. Fujiyoshi", "T. Kasai"], "venue": "Systems and Computers in Japan, 34(1):59\u201367,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2003}, {"title": "Extended finite-state machine induction using SAT-solver", "author": ["V. Ulyantsev", "F. Tsarev"], "venue": "In ICMLA 2011, Volume 2: Special Sessions and Workshop, pages 346\u2013349,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2011}], "referenceMentions": [{"referenceID": 18, "context": "Traditionally, objects studied by machine learning include classifiers, decision trees, and neural networks, with applications to fields as diverse as artificial intelligence, marketing, finance, or medicine [19].", "startOffset": 208, "endOffset": 212}, {"referenceID": 17, "context": "Examples include, but are by no means limited to, the classic field of system identification [18], as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [25,11,23,22,3].", "startOffset": 93, "endOffset": 97}, {"referenceID": 24, "context": "Examples include, but are by no means limited to, the classic field of system identification [18], as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [25,11,23,22,3].", "startOffset": 200, "endOffset": 215}, {"referenceID": 10, "context": "Examples include, but are by no means limited to, the classic field of system identification [18], as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [25,11,23,22,3].", "startOffset": 200, "endOffset": 215}, {"referenceID": 22, "context": "Examples include, but are by no means limited to, the classic field of system identification [18], as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [25,11,23,22,3].", "startOffset": 200, "endOffset": 215}, {"referenceID": 21, "context": "Examples include, but are by no means limited to, the classic field of system identification [18], as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [25,11,23,22,3].", "startOffset": 200, "endOffset": 215}, {"referenceID": 2, "context": "Examples include, but are by no means limited to, the classic field of system identification [18], as well as more recent works on synthesizing programs, controllers, or other artifacts from examples [25,11,23,22,3].", "startOffset": 200, "endOffset": 215}, {"referenceID": 15, "context": "A Moore machine is a type of finite-state machine (FSM) with inputs and outputs, where the output always depends on the current state, but not on the current input [16].", "startOffset": 164, "endOffset": 168}, {"referenceID": 6, "context": "This is despite a large body of research on grammatical inference [7] which has studied similar, but not exactly the same problems, such as learning deterministic finite automata (DFA), which are special cases of Moore machines with a binary output, or subsequential transducers, which are more general than Moore machines.", "startOffset": 66, "endOffset": 69}, {"referenceID": 6, "context": "We also adapt the notion of characteristic sample, which is known for DFA [7], to the case of Moore machines.", "startOffset": 74, "endOffset": 77}, {"referenceID": 8, "context": "CSR is important, as it ensures identification in the limit: this is a key concept in automata learning theory which ensures that the learning algorithm will eventually learn the right machine when provided with a sufficiently large set of examples [9].", "startOffset": 249, "endOffset": 252}, {"referenceID": 20, "context": "We show that the well-known transducer-learning algorithm OSTIA [21] cannot generally learn a Moore machine, even in the case where the training set is a characteristic sample of a Moore machine.", "startOffset": 64, "endOffset": 68}, {"referenceID": 3, "context": "A seminal work in the first category is Angluin\u2019s work on learning DFAs with membership and equivalence queries [4].", "startOffset": 112, "endOffset": 115}, {"referenceID": 23, "context": "This work has been subsequently extended to other types of machines, such as (extended) Mealy machines or register automata [24,14,13,6].", "startOffset": 124, "endOffset": 136}, {"referenceID": 13, "context": "This work has been subsequently extended to other types of machines, such as (extended) Mealy machines or register automata [24,14,13,6].", "startOffset": 124, "endOffset": 136}, {"referenceID": 12, "context": "This work has been subsequently extended to other types of machines, such as (extended) Mealy machines or register automata [24,14,13,6].", "startOffset": 124, "endOffset": 136}, {"referenceID": 5, "context": "This work has been subsequently extended to other types of machines, such as (extended) Mealy machines or register automata [24,14,13,6].", "startOffset": 124, "endOffset": 136}, {"referenceID": 9, "context": "A seminal work in the second category is Gold\u2019s algorithm for learning DFAs from sets of positive and negative examples [10].", "startOffset": 120, "endOffset": 124}, {"referenceID": 19, "context": "Subsequent work includes the RPNI [20] algorithm (that learns DFAs), of which an incremental version also exists [8], and derivatives, like the EDSM [17] (that also learns DFAs, but unlike RPNI does not guarantee identification in the limit) and OSTIA [21] (that learns subsequential transducers) algorithms.", "startOffset": 34, "endOffset": 38}, {"referenceID": 7, "context": "Subsequent work includes the RPNI [20] algorithm (that learns DFAs), of which an incremental version also exists [8], and derivatives, like the EDSM [17] (that also learns DFAs, but unlike RPNI does not guarantee identification in the limit) and OSTIA [21] (that learns subsequential transducers) algorithms.", "startOffset": 113, "endOffset": 116}, {"referenceID": 16, "context": "Subsequent work includes the RPNI [20] algorithm (that learns DFAs), of which an incremental version also exists [8], and derivatives, like the EDSM [17] (that also learns DFAs, but unlike RPNI does not guarantee identification in the limit) and OSTIA [21] (that learns subsequential transducers) algorithms.", "startOffset": 149, "endOffset": 153}, {"referenceID": 20, "context": "Subsequent work includes the RPNI [20] algorithm (that learns DFAs), of which an incremental version also exists [8], and derivatives, like the EDSM [17] (that also learns DFAs, but unlike RPNI does not guarantee identification in the limit) and OSTIA [21] (that learns subsequential transducers) algorithms.", "startOffset": 252, "endOffset": 256}, {"referenceID": 1, "context": "Apart from state merging algorithms like the above, learning from examples has also been attempted with techniques from artificial intelligence, such as genetic algorithms [2] and ant colony optimization [5], as well as with reduction to satisfiability [12,27].", "startOffset": 172, "endOffset": 175}, {"referenceID": 4, "context": "Apart from state merging algorithms like the above, learning from examples has also been attempted with techniques from artificial intelligence, such as genetic algorithms [2] and ant colony optimization [5], as well as with reduction to satisfiability [12,27].", "startOffset": 204, "endOffset": 207}, {"referenceID": 11, "context": "Apart from state merging algorithms like the above, learning from examples has also been attempted with techniques from artificial intelligence, such as genetic algorithms [2] and ant colony optimization [5], as well as with reduction to satisfiability [12,27].", "startOffset": 253, "endOffset": 260}, {"referenceID": 26, "context": "Apart from state merging algorithms like the above, learning from examples has also been attempted with techniques from artificial intelligence, such as genetic algorithms [2] and ant colony optimization [5], as well as with reduction to satisfiability [12,27].", "startOffset": 253, "endOffset": 260}, {"referenceID": 25, "context": "[26] is close to our work, but the algorithm described there does not always yield a deterministic Moore machine, while ours does.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "Related to ours is also the work in [15], which deals with learning finite state machine abstractions of non-linear analog circuits.", "startOffset": 36, "endOffset": 40}, {"referenceID": 14, "context": "The algorithm described in [15] is very different from ours, however, and uses the circuit\u2019s number of inputs to determine a subset of the states in the learned abstraction.", "startOffset": 27, "endOffset": 31}, {"referenceID": 14, "context": "Also, identification in the limit is not considered in [15].", "startOffset": 55, "endOffset": 59}, {"referenceID": 6, "context": "Such a DFA is called a prefix tree acceptor [7] (PTA) for S+.", "startOffset": 44, "endOffset": 47}, {"referenceID": 6, "context": "An important concept in automata learning theory is that of a characteristic sample [7].", "startOffset": 84, "endOffset": 87}, {"referenceID": 0, "context": "We call an accuracy evaluation policy (AEP) any function that, given a Moore (I,O)-trace (\u03c1I , \u03c1O) and a Moore machine M = (I,O,Q, q0, \u03b4, \u03bb), will return a real number in [0, 1].", "startOffset": 171, "endOffset": 177}, {"referenceID": 8, "context": "CSR is important, as it ensures identification in the limit, a key concept in automata learning theory [9].", "startOffset": 103, "endOffset": 106}, {"referenceID": 19, "context": "The PRPNI algorithm starts by executing the RPNI DFA learning algorithm [20] on each pair, thus obtaining N learned DFAs.", "startOffset": 72, "endOffset": 76}, {"referenceID": 16, "context": "While not appearing in the original RPNI algorithm, the convention of marking states as red or blue was introduced later in [17].", "startOffset": 124, "endOffset": 128}, {"referenceID": 20, "context": "OSTIA [21] is a well-known algorithm that learns onward subsequential transducers, a class of transducers more general than Moore and Mealy machines.", "startOffset": 6, "endOffset": 10}, {"referenceID": 0, "context": "We constructed a characteristic sample for the Moore machine in Figure 5a and ran the OSTIA algorithm on it (we used the open source implementation described in [1]).", "startOffset": 161, "endOffset": 164}], "year": 2017, "abstractText": "The problem of learning automata from example traces (but no equivalence or membership queries) is fundamental in automata learning theory and practice. In this paper we study this problem for finite state machines with inputs and outputs, and in particular for Moore machines. We introduce three algorithms for solving this problem: (1) the PTAP algorithm, which transforms a set of inputoutput traces into an incomplete Moore machine and then completes that machine with self-loops; (2) the PRPNI algorithm, which uses the well-known RPNI algorithm for automata learning to learn a product of automata encoding a Moore machine; and (3) the MooreMI algorithm, which directly learns a Moore machine using PTAP extended with state merging. We prove that MooreMI always learns the right machine when the training set is a characteristic sample, which is generally not true for the other two algorithms. We also compare the algorithms experimentally in terms of the size of the learned machine and several notions of accuracy, introduced in this paper. Finally, we compare with OSTIA, an algorithm that learns a more general class of transducers, and find that OSTIA generally does not learn a Moore machine, even when fed with a characteristic sample.", "creator": "LaTeX with hyperref package"}}}