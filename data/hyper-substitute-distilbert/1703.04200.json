{"id": "1703.04200", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Mar-2017", "title": "Continual Learning Through Synaptic Intelligence", "abstract": "deep learning has led to semantic learning primarily applied on problems where socially predictable distribution does invariably flow over the seconds after learning. concerning stark contrast, biological neural networks continually adapt against changing signals, and overcome a diversity of crises involved. effectively, synapses in evolutionary neurons are not normally real - valued scalars, but possess complex molecular machinery enabling above - trivial learning gaps. in this presentation, we take a first step aboard bringing full biological complexity atop cellular neural networks. entropy evolved a program of intelligent responses that accumulate relatively relevant information saving time, and used this situation to fully consolidate events of old events to facilitate them from being overwritten as learning tasks being learned. we communicate technological concerns to learning strategies of experimental statistical approaches, and show that it dramatically reduces catastrophic forgetting while maintaining computational efficiency.", "histories": [["v1", "Mon, 13 Mar 2017 00:02:48 GMT  (255kb,D)", "https://arxiv.org/abs/1703.04200v1", null], ["v2", "Mon, 10 Apr 2017 17:54:57 GMT  (259kb,D)", "http://arxiv.org/abs/1703.04200v2", null], ["v3", "Mon, 12 Jun 2017 19:57:42 GMT  (1060kb,D)", "http://arxiv.org/abs/1703.04200v3", "ICML 2017"]], "reviews": [], "SUBJECTS": "cs.LG q-bio.NC stat.ML", "authors": ["friedemann zenke", "ben poole", "surya ganguli"], "accepted": true, "id": "1703.04200"}, "pdf": {"name": "1703.04200.pdf", "metadata": {"source": "META", "title": "Continual Learning Through Synaptic Intelligence", "authors": ["Friedemann Zenke", "Ben Poole", "Surya Ganguli"], "emails": ["<fzenke@stanford.edu>,", "<poole@cs.stanford.edu>."], "sections": [{"heading": "1. Introduction", "text": "Artificial neural networks (ANNs) have become an indispensable asset for applied machine learning, rivaling human performance in a variety of domain-specific tasks (LeCun et al., 2015). Although originally inspired by biology (Rosenblatt, 1958; Fukushima & Miyake, 1982), the underlying design principles and learning methods differ substantially from biological neural networks. For instance, parameters of ANNs are learned on a dataset in the training phase, and then frozen and used statically on new data in the deployment or recall phase. To accommodate changes in the data distribution, ANNs typically have to be retrained on the entire dataset to avoid overfitting and catastrophic forgetting (Choy et al., 2006; Goodfellow et al., 2013).\nOn the other hand, biological neural networks exhibit continual learning in which they acquire new knowledge over\n*Equal contribution 1Stanford University. Correspondence to: Friedemann Zenke <fzenke@stanford.edu>, Ben Poole <poole@cs.stanford.edu>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\na lifetime. It is therefore difficult to draw a clear line between a learning and recall phase. Somehow, our brains have evolved to learn from non-stationary data and to update internal memories or beliefs on-the-fly. While it is unknown how this feat is accomplished in the brain, it seems possible that the unparalleled biological performance in continual learning could rely on specific features implemented by the underlying biological wetware that are not currently implemented in ANNs.\nPerhaps one of the greatest gaps in the design of modern ANNs versus biological neural networks lies in the complexity of synapses. In ANNs, individual synapses (weights) are typically described by a single scalar quantity. On the other hand, individual biological synapses make use of complex molecular machinery that can affect plasticity at different spatial and temporal scales (Redondo & Morris, 2011). While this complexity has been surmised to serve memory consolidation (Fusi et al., 2005; Lahiri & Ganguli, 2013; Zenke et al., 2015; Ziegler et al., 2015; Benna & Fusi, 2016), few studies have illustrated how it benefits learning in ANNs.\nHere we study the role of internal synaptic dynamics to enable ANNs to learn sequences of classification tasks. While simple, scalar one-dimensional synapses suffer from catastrophic forgetting, in which the network forgets previously learned tasks when trained on a novel task, this problem can be largely alleviated by synapses with a more complex three-dimensional state space. In our model, the synaptic state tracks the past and current parameter value, and maintains an online estimate of the synapse\u2019s \u201cimportance\u201d toward solving problems encountered in the past. Our importance measure can be computed efficiently and locally at each synapse during training, and represents the local contribution of each synapse to the change in the global loss. When the task changes, we consolidate the important synapses by preventing them from changing in future tasks. Thus learning in future tasks is mediated primarily by synapses that were unimportant for past tasks, thereby avoiding catastrophic forgetting of these past tasks."}, {"heading": "2. Prior work", "text": "The problem of alleviating catastrophic forgetting has been addressed in many previous studies. These studies can be\nar X\niv :1\n70 3.\n04 20\n0v 3\n[ cs\n.L G\n] 1\n2 Ju\nn 20\n17\nbroadly partitioned into (1) architectural, (2) functional, and (3) structural approaches.\nArchitectural approaches to catastrophic forgetting alter the architecture of the network to reduce interference between tasks without altering the objective function. The simplest form of architectural regularization is freezing certain weights in the network so that they stay exactly the same (Razavian et al., 2014). A slightly more relaxed approach reduces the learning rate for layers shared with the original task while fine-tuning to avoid dramatic changes in the parameters (Donahue et al., 2014; Yosinski et al., 2014). Approaches using different nonlinearities like ReLU, MaxOut, and local winner-take-all have been shown to improve performance on permuted MNIST and sentiment analysis tasks (Srivastava et al., 2013; Goodfellow et al., 2013). Moreover, injecting noise to sparsify gradients using dropout also improves performance (Goodfellow et al., 2013). Recent work from Rusu et al. (2016) proposed more dramatic architectural changes where the entire network for the previous task is copied and augmented with new features while solving a new task. This entirely prevents forgetting on earlier tasks, but causes the architectural complexity to grow with the number of tasks.\nFunctional approaches to catastrophic forgetting add a regularization term to the objective that penalizes changes in the input-output function of the neural network. In Li & Hoiem (2016), the predictions of the previous task\u2019s network and the current network are encouraged to be similar when applied to data from the new task by using a form of knowledge distillation (Hinton et al., 2014). Similarly, Jung et al. (2016) regularize the `2 distance between the final hidden activations instead of the knowledge distillation penalty. Both of these approaches to regularization aim to preserve aspects of the input-output mapping for the old task by storing or computing additional activations using the old task\u2019s parameters. This makes the functional approach to catastrophic forgetting computationally expensive as it requires computing a forward pass through the old task\u2019s network for every new data point.\nThe third technique, structural regularization, involves penalties on the parameters that encourage them to stay close to the parameters for the old task. Recently, Kirkpatrick et al. (2017) proposed elastic weight consolidation (EWC), a quadratic penalty on the difference between the parameters for the new and the old task. They used a diagonal weighting proportional to the diagonal of the Fisher information metric over the old parameters on the old task. Exactly computing the diagonal of the Fisher requires summing over all possible output labels and thus has complexity linear in the number of outputs. This limits the application of this approach to low-dimensional output spaces."}, {"heading": "3. Synaptic framework", "text": "To tackle the problem of continual learning in neural networks, we sought to build a simple structural regularizer that could be computed online and implemented locally at each synapse. Specifically, we aim to endow each individual synapse with a local measure of \u201cimportance\u201d in solving tasks the network has been trained on in the past. When training on a new task we penalize changes to important parameters to avoid old memories from being overwritten. To that end, we developed a class of algorithms which keep track of an importance measure \u03c9\u00b5k which reflects past credit for improvements of the task objective L\u00b5 for task \u00b5 to individual synapses \u03b8k. For brevity we use the term \u201csynapse\u201d synonymously with the term \u201cparameter\u201d, which includes weights between layers as well as biases.\nThe process of training a neural network is characterized by a trajectory \u03b8(t) in parameter space (Fig. 1). The feat of successful training lies in finding learning trajectories for which the endpoint lies close to a minimum of the loss function L on all tasks. Let us first consider the change in loss for an infinitesimal parameter update \u03b4(t) at time t.\nIn this case the change in loss is well approximated by the gradient g = \u2202L\u2202\u03b8 and we can write\nL(\u03b8(t) + \u03b4(t))\u2212 L(\u03b8(t)) \u2248 \u2211\nk\ngk(t)\u03b4k(t) , (1)\nwhich illustrates that each parameter change \u03b4k(t) = \u03b8\u2032k(t) contributes the amount gk(t)\u03b4k(t) to the change in total loss.\nTo compute the change in loss over an entire trajectory through parameter space we have to sum over all infinitesimal changes. This amounts to computing the path integral of the gradient vector field along the parameter trajectory from the initial point (at time t0) to the final point (at time t1): \u222b\nC\ng(\u03b8(t))d\u03b8 = \u222b t1 t0 g(\u03b8(t)) \u00b7 \u03b8\u2032(t)dt. (2)\nAs the gradient is a conservative field, the value of the integral is equal to the difference in loss between the end point and start point: L(\u03b8(t1)) \u2212 L(\u03b8(t0)). Crucial to our approach, we can decompose Eq. 2 as a sum over the individual parameters\n\u222b t\u00b5\nt\u00b5\u22121 g(\u03b8(t)) \u00b7 \u03b8\u2032(t)dt =\n\u2211\nk\n\u222b t\u00b5\nt\u00b5\u22121 gk(\u03b8(t))\u03b8\n\u2032 k(t)dt\n\u2261 \u2212 \u2211\nk\n\u03c9\u00b5k . (3)\nThe \u03c9\u00b5k now have an intuitive interpretation as the parameter specific contribution to changes in the total loss. Note that we have introduced the minus sign in the second line, because we are typically interested in decreasing the loss.\nIn practice, we can approximate \u03c9\u00b5k online as the running sum of the product of the gradient gk(t) = \u2202L\u2202\u03b8k with the parameter update \u03b8\u2032k(t) = \u2202\u03b8k \u2202t . For batch gradient descent with an infinitesimal learning rate, \u03c9\u00b5k can be directly interpreted as the per-parameter contribution to changes in the total loss. In most cases the true gradient is approximated by stochastic gradient descent (SGD), resulting in an approximation that introduces noise into the estimate of gk. As a direct consequence, the approximated per-parameter importances will typically overestimate the true value of \u03c9\u00b5k .\nHow can the knowledge of \u03c9\u00b5k be exploited to improve continual learning? The problem we are trying to solve is to minimize the total loss function summed over all tasks, L = \u2211\u00b5 L\u00b5, with the limitation that we do not have access to loss functions of tasks we were training on in the past. Instead, we only have access to the loss function L\u00b5 for a single task \u00b5 at any given time. Catastrophic forgetting arises when minimizing L\u00b5 inadvertently leads to substantial increases of the cost on previous tasks L\u03bd with \u03bd < \u00b5\n(Fig. 1). To avoid catastrophic forgetting of all previous tasks (\u03bd < \u00b5) while training task \u00b5, we want to avoid drastic changes to weights which were particularly influential in the past. The importance of a parameter \u03b8k for a single task is determined by two quantities: 1) how much an individual parameter contributed to a drop in the loss \u03c9\u03bdk over the entire trajectory of training (cf. Eq. 3) and 2) how far it moved \u2206\u03bdk \u2261 \u03b8k(t\u03bd) \u2212 \u03b8k(t\u03bd\u22121). To avoid large changes to important parameters, we use a modified cost function L\u0303\u00b5 in which we introduced a surrogate loss which approximates the summed loss functions of previous tasks L\u03bd (\u03bd < \u00b5). Specifically, we use a quadratic surrogate loss that has the same minimum as the cost function of the previous tasks and yields the same \u03c9\u03bdk over the parameter distance \u2206k. In other words, if learning were to be performed on the surrogate loss instead of the actual loss function, it would result in the same final parameters and change in loss during training (Fig. 2). For two tasks this is achieved exactly by the following quadratic surrogate loss\nL\u0303\u00b5 = L\u00b5 + c \u2211\nk\n\u2126\u00b5k ( \u03b8\u0303k \u2212 \u03b8k )2\n\ufe38 \ufe37\ufe37 \ufe38 surrogate loss\n(4)\nwhere we have introduced the dimensionless strength parameter c, the reference weight corresponding to the parameters at the end of the previous task \u03b8\u0303k = \u03b8k(t\u00b5\u22121),\nand the per-parameter regularization strength:\n\u2126\u00b5k = \u2211\n\u03bd<\u00b5\n\u03c9\u03bdk (\u2206\u03bdk) 2 + \u03be . (5)\nNote that the term in the denominator (\u2206\u03bdk) 2 ensures that the regularization term carries the same units as the loss L. For practical reasons we also introduce an additional damping parameter, \u03be, to bound the expression in cases where \u2206\u03bdk \u2192 0. Finally, c is a strength parameter which trades off old versus new memories. If the path integral (Eq. 3) is evaluated precisely, c = 1 would correspond to an equal weighting of old and new memories. However, due to noise in the evaluation of the path integral (Eq. 3), c typically has to be chosen smaller than one to compensate. Unless otherwise stated, the \u03c9k are updated continuously during training, whereas the cumulative importance measures, \u2126\u00b5k , and the reference weights, \u03b8\u0303, are only updated at the end of each task. After updating the \u2126\u00b5k , the \u03c9k are set to zero. Although our motivation for Eq. 4 as a surrogate loss only holds in the case of two tasks, we will show empirically that our approach leads to good performance when learning additional tasks.\nTo understand how the particular choices of Eqs. 4 and 5 affect learning, let us consider the example illustrated in Figure 1 in which we learn two tasks. We first train on Task 1. At time t1 the parameters have approached a local minimum of the Task 1 loss L1. But, the same parameter configuration is not close to a minimum for Task 2. Consequently, when training on Task 2 without any additional precautions, the L1 loss may inadvertently increase (Fig. 1, black trajectory). However, when \u03b82 \u201cremembers\u201d that it was important to decreasing L1, it can exploit this knowledge during training on Task 2 by staying close to its current value (Fig. 1, orange trajectory). While this will almost inevitably result in a decreased performance on Task 2, this decrease could be negligible, whereas the gain in performance on both tasks combined can be substantial.\nThe approach presented here is similar to EWC (Kirkpatrick et al., 2017) in that more influential parameters are pulled back more strongly towards a reference weight with which good performance was achieved on previous tasks. However, in contrast to EWC, here we are putting forward a method which computes an importance measure online and along the entire learning trajectory, whereas EWC relies on a point estimate of the diagonal of the Fisher information metric at the final parameter values, which has to be computed during a separate phase at the end of each task."}, {"heading": "4. Theoretical analysis of special cases", "text": "In the following we illustrate that our general approach recovers sensible \u2126\u00b5k in the case of a simple and analytically tractable training scenario. To that end, we analyze what\nthe parameter specific path integral \u03c9uk and its normalized version \u2126\u00b5k (Eq. (5)), correspond to in terms of the geometry of a simple quadratic error function\nE(\u03b8) = 1 2 (\u03b8 \u2212 \u03b8\u2217)TH(\u03b8 \u2212 \u03b8\u2217), (6)\nwith a minimum at \u03b8\u2217 and a Hessian matrix H . Further consider batch gradient descent dynamics on this error function. In the limit of small discrete time learning rates, this descent dynamics is described by the continuous time differential equation\n\u03c4 d\u03b8 dt = \u2212\u2202E \u2202\u03b8 = \u2212H(\u03b8 \u2212 \u03b8\u2217), (7)\nwhere \u03c4 is related to the learning rate. If we start from an initial condition \u03b8(0) at time t = 0, an exact solution to the descent path is given by\n\u03b8(t) = \u03b8\u2217 + e\u2212H t \u03c4 (\u03b8(0)\u2212 \u03b8\u2217), (8)\nyielding the time dependent update direction\n\u03b8\u2032(t) = d\u03b8 dt = \u22121 \u03c4 He\u2212H t \u03c4 (\u03b8(0)\u2212 \u03b8\u2217). (9)\nNow, under gradient descent dynamics, the gradient obeys g = \u03c4 d\u03b8dt , so the \u03c9 \u00b5 k in (3) are computed as the diagonal elements of the matrix\nQ = \u03c4\n\u222b \u221e\n0\ndt d\u03b8\ndt\nd\u03b8\ndt\nT\n. (10)\nAn explicit formula for Q can be given in terms of the eigenbasis of the Hessian H . In particular, let \u03bb\u03b1 and u\u03b1 denote the eigenvalues and eigenvectors of H , and let d\u03b1 = u\u03b1 \u00b7 (\u03b8(0)\u2212\u03b8\u2217) be the projection of the discrepancy between initial and final parameters onto the \u03b1\u2019th eigenvector. Then inserting (9) into (10), performing the change of basis to the eigenmodes ofH , and doing the integral yields\nQij = \u2211\n\u03b1\u03b2\nu\u03b1i d \u03b1 \u03bb\n\u03b1\u03bb\u03b2\n\u03bb\u03b1 + \u03bb\u03b2 d\u03b2u\u03b2j . (11)\nNote that as a time-integrated steady state quantity, Q no longer depends on the time constant \u03c4 governing the speed of the descent path.\nAt first glance, the Q matrix elements depend in a complex manner on both the eigenvectors and eigenvalues of the Hessian, as well as the initial condition \u03b8(0). To understand this dependence, let\u2019s first consider averaging Q over random initial conditions \u03b8(0), such that the collection of discrepancies d\u03b1 constitute a set of zero mean iid random variables with variance \u03c32. Thus we have the average \u3008d\u03b1d\u03b2\u3009 = \u03c32\u03b4\u03b1\u03b2 . Performing this average overQ then yields\n\u3008Qij\u3009 = 1 2 \u03c32 \u2211\n\u03b1\nu\u03b1i \u03bb \u03b1u\u03b2j =\n1 2 \u03c32Hij . (12)\nThus remarkably, after averaging over initial conditions, the Q matrix, which is available simply by correlating parameter updates across pairs of synapses and integrating over time, reduces to the Hessian, up to a scale factor dictating the discrepancy between initial and final conditions. Indeed, this scale factor theoretically motivates the normalization in (5); the denominator in (5), at zero damping, \u03be averages to \u03c32, thereby removing the scale factor \u03c32 in (12)\nHowever, we are interested in what Qij computes for a single initial condition. There are two scenarios in which the simple relationship between Q and the Hessian H is preserved without averaging over initial conditions. First, consider the case when the Hessian is diagonal, so that u\u03b1i = \u03b4\u03b1iei where ei is the i\u2019th coordinate vector. Then \u03b1 and i indices are interchangeable and the eigenvalues of the Hessian are the diagonal elements of the Hessian: \u03bbi = Hii. Then (11) reduces to\nQij = \u03b4ij(d i)2Hii. (13)\nAgain the normalization in (5), at zero damping, removes the scale of movement in parameter space (di)2, and so the normalizedQ matrix becomes identical to the diagonal Hessian. In the second scenario, consider the extreme limit where the Hessian is rank 1 so that \u03bb1 is the only nonzero eigenvalue. Then (11) reduces to\nQij = 1\n2 (d1)2u1i\u03bb1u 1 j =\n1 2 (d1)2Hij . (14)\nThus again, the Q matrix reduces to the Hessian, up to a scale factor. The normalized importances then become the diagonal elements of the non-diagonal but low rank Hessian. We note that the low rank Hessian is the interesting case for continual learning; low rank structure in the error function leaves many directions in synaptic weight space\nunconstrained by a given task, leaving open excess capacity for synaptic modification to solve future tasks without interfering with performance on an old task.\nIt is important to stress that the path integral for importance is computed by integrating information along the entire learning trajectory (cf. Fig. 2). For a quadratic loss function, the Hessian is constant along this trajectory, and so we find a precise relationship between the importance and the Hessian. But for more general loss functions, where the Hessian varies along the trajectory, we cannot expect any simple mathematical correspondence between the importance \u2126\u00b5k and the Hessian at the endpoint of learning, or related measures of parameter sensitivity (Pascanu & Bengio, 2013; Martens, 2016; Kirkpatrick et al., 2017) at the endpoint. In practice, however, we find that our importance measure is correlated to measures based on such endpoint estimates, which may explain their comparable effectiveness as we will see in the next section."}, {"heading": "5. Experiments", "text": "We evaluated our approach for continual learning on the split and permuted MNIST (LeCun et al., 1998; Goodfellow et al., 2013), and split versions of CIFAR-10 and CIFAR-100 (Krizhevsky & Hinton, 2009)."}, {"heading": "5.1. Split MNIST", "text": "We first evaluated our algorithm on a split MNIST benchmark. For this benchmark we split the full MNIST training data set into 5 subsets of consecutive digits. The 5 tasks correspond to learning to distinguish between two consecutive digits from 0 to 10. We used a small multi-layer perceptron (MLP) with only two hidden layers consisting of 256 units each with ReLU nonlinearities, and a standard\ncategorical cross-entropy loss function plus our consolidation cost term (with damping parameter \u03be = 1\u00d7 10\u22123). To avoid the complication of crosstalk between digits at the readout layer due to changes in the label distribution during training, we used a multi-head approach in which the categorical cross entropy loss at the readout layer was computed only for the digits present in the current task. Finally, we optimized our network using a minibatch size of 64 and trained for 10 epochs. To achieve good absolute performance with a smaller number of epochs we used the adaptive optimizer Adam (Kingma & Ba, 2014) (\u03b7 = 1\u00d7 10\u22123, \u03b21 = 0.9, \u03b22 = 0.999). In this benchmark the optimizer state was reset after training each task.\nTo evaluate the performance, we computed the average classification accuracy on all previous tasks as a function of number of tasks trained. We now compare this performance between networks in which we turn consolidation dynamics on (c = 1) against cases in which consolidation was off (c = 0). During training of the first task the consolidation penalty is zero for both cases because there is no past experience that synapses could be regularized against. When trained on the digits \u201c2\u201d and \u201c3\u201d (Task 2), both the model with and without consolidation show accuracies close to 1 on Task 2. However, on average the networks without synaptic consolidation show substantial loss in accuracy on Task 1 (Fig. 3). In contrast to that, networks with consolidation only undergo minor impairment with respect to accuracy on Task 1 and the average accuracy for both tasks stays close to 1. Similarly, when the network has seen all MNIST digits, on average, the accuracy on the first two tasks, corresponding to the first four digits, has dropped back to chance levels in the cases without consolidation whereas the model with consolidation only shows minor degradation in performance on these tasks (Fig. 3)."}, {"heading": "5.2. Permuted MNIST benchmark", "text": "In this benchmark, we randomly permute all MNIST pixels differently for each task. We trained a MLP with two hidden layers with 2000 ReLUs each and softmax loss. We used Adam with the same parameters as before. However, here we used \u03be = 0.1 and the value for c = 0.1 was determined via a coarse grid search on a heldout validation set. The mini batch size was set to 256 and we trained for 20 epochs. In contrast to the split MNIST benchmark we obtained better results by maintaining the state of the Adam optimizer between tasks. The final test error was computed on data from the MNIST test set. Performance is measured by the ability of the network to solve all tasks.\nTo establish a baseline for comparison we first trained a network without synaptic consolidation (c = 0) on all tasks sequentially. In this scenario the system exhibits catastrophic forgetting, i.e. it learns to solve the most recent task, but\nrapidly forgets about previous tasks (blue line, Fig. 4). In contrast to that, when enabling synaptic consolidation, with a sensible choice for c > 0, the same network retains high classification accuracy on Task 1 while being trained on 9 additional tasks (Fig. 4). Moreover, the network learns to solve all other tasks with high accuracy and performs only slightly worse than a network which had trained on all data simultaneously (Fig. 4). Finally, these results were consistent across training and validation error and comparable to the results reported with EWC (Kirkpatrick et al., 2017).\nTo gain a better understanding of the synaptic dynamics during training, we visualized the pairwise correlations of the \u03c9\u00b5k across the different tasks \u00b5 (Fig. 5b). We found that without consolidation, the \u03c9\u00b5k in the second hidden layer are correlated across tasks which is likely to be the cause of catastrophic forgetting. With consolidation, however, these sets of synapses contributing to decreasing the loss are largely uncorrelated across tasks, thus avoiding interference when updating weights to solve new tasks."}, {"heading": "5.3. Split CIFAR-10/CIFAR-100 benchmark", "text": "To evaluate whether synaptic consolidation dynamics would also prevent catastrophic forgetting in more complex datasets and larger models, we experimented with a continual learning task based on CIFAR-10 and CIFAR100. Specifically, we trained a CNN (4 convolutional, followed by 2 dense layers with dropout; see Appendix for details). We used the same multi-head setup as in the case of split MNIST using Adam (\u03b7 = 1 \u00d7 10\u22123, \u03b21 = 0.9, \u03b22 = 0.999, minibatch size 256). First, we trained the network for 60 epochs on the full CIFAR-10 dataset (Task 1) and sequentially on 5 additional tasks each corresponding to 10 consecutive classes from the CIFAR-100 dataset (Fig. 6). To determine the best c, we performed this experiment for different values in the parameter range 1\u00d710\u22123 < c < 0.1. Between tasks the state of the optimizer was reset. Moreover, we obtained values for two specific control cases. On the one hand we trained the same network with c = 0 on all tasks consecutively. On the other hand we trained the same network from scratch on each task individually to assess generalization across tasks. Finally, to assess the magnitude of statistical fluctuations in accuracy, all runs were repeated n = 5 times.\nWe found that after training on all tasks, networks with consolidation showed similar validation accuracy across all tasks, whereas accuracy in the network without consolidation showed a clear age dependent decline in which old tasks were solved with lower accuracy (Fig. 6). Importantly, the performance of networks trained with consolidation was always better than without consolidation, except on the last task. Finally, when comparing the performance of networks trained with consolidation on all tasks with net-\nworks trained from scratch only on a single task (Fig. 6; green vs gray), the former either significantly outperformed the latter or yielded the same validation accuracy, while this trend was reversed in training accuracy. This suggests that networks without consolidation are more prone to over fitting. The only exception to that rule was Task 1, CIFAR-10 which is presumably due to its 10\u00d7 larger number of examples per class. In summary, we found that consolidation not only protected old memories from being slowly forgotten over time, but also allowed networks to generalize better on new tasks with limited data."}, {"heading": "6. Discussion", "text": "We have shown that the problem of catastrophic forgetting commonly encountered in continual learning scenarios can be alleviated by allowing individual synapses to estimate their importance for solving past tasks. Then by penalizing changes to the most important synapses, novel tasks can be learned with minimal interference to previously learned tasks.\nThe regularization penalty is similar to EWC as recently introduced by Kirkpatrick et al. (2017). However, our approach computes the per-synapse consolidation strength in an online fashion and over the entire learning trajectory in parameter space, whereas for EWC synaptic importance is computed offline as the Fisher information at the minimum of the loss for a designated task. Despite this difference, these two approaches yielded similar performance on the permuted MNIST benchmark which may be due to correlations between the two different importance measures.\nOur approach requires individual synapses to not simply correspond to single scalar synaptic weights, but rather act as higher dimensional dynamical systems in their own right. Such higher dimensional state enables each of our synapses to intelligently accumulate task relevant information during training and retain a memory of previous parameter values. While we make no claim that biological synapses behave like the intelligent synapses of our model, a wealth of experimental data in neurobiology suggests that biological synapses act in much more complex ways than the artificial scalar synapses that dominate current machine learning models. In essence, whether synaptic changes occur, and whether they are made permanent, or left to ultimately decay, can be controlled by many different biological factors. For instance, the induction of synaptic plasticity may depend on the history and the synaptic state of individual synapses (Montgomery & Madison, 2002). Moreover, recent synaptic changes may decay on the timescale of hours unless specific plasticity related chemical factors are released. These chemical factors are thought to encode the valence or novelty of a recent change (Redondo & Morris, 2011). Finally, recent synaptic changes can be reset by stereotypical neural activity, whereas older synaptic memories become increasingly insensitive to reversal (Zhou et al., 2003).\nHere, we introduced one specific higher dimensional synaptic model to tackle a specific problem: catastrophic forgetting in continual learning. However, this suggests new directions of research in which we mirror neurobiology to endow individual synapses with potentially complex dynamical properties, that can be exploited to intelligently control learning dynamics in neural networks. In essence, in machine learning, in addition to adding depth to our networks, we may need to add intelligence to our synapses."}, {"heading": "Acknowledgements", "text": "The authors thank Subhaneil Lahiri for helpful discussions. FZ was supported by the SNSF (Swiss National Science Foundation) and the Wellcome Trust. BP was supported by a Stanford MBC IGERT Fellowship and Stanford Interdisciplinary Graduate Fellowship. SG was supported by the Burroughs Wellcome, McKnight, Simons and James S. McDonnell foundations and the Office of Naval Research."}, {"heading": "A. Split CIFAR-10/100 CNN architecture", "text": "For our CIFAR-10/100 experiments, we used the default CIFAR-10 CNN from Keras:"}, {"heading": "B. Additional split CIFAR\u201310 experiments", "text": "As an additional experiment, we trained a CNN (4 convolutional, followed by 2 dense layers with dropout; cf. main text) on the split CIFAR-10 benchmark. We used the same multi-head setup as in the case of split MNIST using Adam (\u03b7 = 1 \u00d7 10\u22123, \u03b21 = 0.9, \u03b22 = 0.999, minibatch size 256). First, we trained the network for 60 epochs on the first 5 categories (Task A). At this point the training accuracy was close to 1. Then the optimizer was reset and the network was trained for another 60 epochs on the remaining 5 categories (Task B). We ran identical experiments for\nboth the control case (c = 0) and the case in which consolidation was active (c > 0). All experiments were repeated n = 10 times to quantify the uncertainty on the validation set accuracy.\nAfter training on both Task A and B, the network with consolidation performed significantly better on both tasks than the control network without consolidation (Fig. 7). While the large performance difference on Task A can readily be explained by the fact that consolidation alleviates the problem of catastrophic forgetting \u2014 the initial motivation for our model \u2014 the small but significant difference (\u2248 4.5%) in validation accuracy on Task B suggests that consolidation also improves transfer learning. The network without consolidation is essentially fine-tuning a model which has been pre-trained on the first five CIFAR-10 categories. In contrast to that, by leveraging the knowledge about the optimization of Task A stored at the individual synapses, the network with consolidation solves a different optimization problem which makes the network generalize better on Task B. This significant effect was observed consistently for different values of c in the range 0.1 < c < 10."}, {"heading": "C. Comparison of path integral approach to other metrics", "text": "Prior approaches toward measuring the sensitivity of parameters in a network have primarily focused on local metrics related to the curvature of the objective function at the final parameters (Martens, 2016). The Hessian is one possible metric, but it can be negative definite and computing even the diagonal adds additional overhead over standard backpropagation (Martens et al., 2012). An alternative choice is the Fisher information (see for instance Kirk-\npatrick et al. (2017)): F = Ex\u223cD,y\u223cp\u03b8(y|x) [( \u2202 log p\u03b8(y|x) \u2202\u03b8 )( \u2202 log p\u03b8(y|x) \u2202\u03b8 )T]\nWhile the Fisher information has a number of desirable properties (Pascanu & Bengio, 2013), it requires computing gradients using labels sampled from the model distribution instead of the data distribution, and thus would require at least one additional backpropagation pass to compute online. For efficiency, the Fisher is often replaced with an approximation, the empirical Fisher (Martens, 2016), that uses labels sampled from the data distribution and can be computed directly from the gradient of the objective at the current parameters:\nF\u0304 = E(x,y)\u223cD [(\n\u2202 log p\u03b8(y|x) \u2202\u03b8\n)( \u2202 log p\u03b8(y|x)\n\u2202\u03b8\n)T]\n= E(x,y)\u223cD [ g(\u03b8)g(\u03b8)T ]\nThe diagonal of the empirical Fisher yields a very similar formula to our local importance measure \u03c9 in Eq. 3 under gradient descent dynamics. However, the empirical Fisher is computed at a single parameter value \u03b8 whereas the path integral is computed over a trajectory \u03b8(t). This yields an important difference in the behavior of these metrics: for a quadratic the empirical Fisher at the minimum will be 0 while the path integral will be proportional to the diagonal of the Hessian. Thus the path integral based approach yields an efficient algorithm with no additional gradients required that still recovers a meaningful estimate of the curvature."}], "references": [{"title": "Computational principles of synaptic memory consolidation", "author": ["Benna", "Marcus K", "Fusi", "Stefano"], "venue": "Nat Neurosci, advance online publication,", "citeRegEx": "Benna et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Benna et al\\.", "year": 2016}, {"title": "Decaf: A deep convolutional activation feature for generic visual recognition", "author": ["Donahue", "Jeff", "Jia", "Yangqing", "Vinyals", "Oriol", "Hoffman", "Judy", "Zhang", "Ning", "Tzeng", "Eric", "Darrell", "Trevor"], "venue": "In International Conference in Machine Learning (ICML),", "citeRegEx": "Donahue et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Donahue et al\\.", "year": 2014}, {"title": "Neocognitron: A Self-Organizing Neural Network Model for a Mechanism of Visual Pattern Recognition", "author": ["Fukushima", "Kunihiko", "Miyake", "Sei"], "venue": "In Competition and Cooperation in Neural Nets,", "citeRegEx": "Fukushima et al\\.,? \\Q1982\\E", "shortCiteRegEx": "Fukushima et al\\.", "year": 1982}, {"title": "Cascade models of synaptically stored memories", "author": ["Fusi", "Stefano", "Drew", "Patrick J", "Abbott", "Larry F"], "venue": null, "citeRegEx": "Fusi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Fusi et al\\.", "year": 2005}, {"title": "An Empirical Investigation of Catastrophic Forgetting in Gradient-Based Neural Networks", "author": ["Goodfellow", "Ian J", "Mirza", "Mehdi", "Xiao", "Da", "Courville", "Aaron", "Bengio", "Yoshua"], "venue": null, "citeRegEx": "Goodfellow et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Goodfellow et al\\.", "year": 2013}, {"title": "Distilling the knowledge in a neural network", "author": ["Hinton", "Geoffrey", "Vinyals", "Oriol", "Dean", "Jeff"], "venue": "NIPS Deep Learning and Representation Learning Workshop,", "citeRegEx": "Hinton et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2014}, {"title": "Less-forgetting Learning in Deep Neural Networks", "author": ["Jung", "Heechul", "Ju", "Jeongwoo", "Minju", "Kim", "Junmo"], "venue": "[cs],", "citeRegEx": "Jung et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Jung et al\\.", "year": 2016}, {"title": "Adam: A Method for Stochastic Optimization", "author": ["Kingma", "Diederik", "Ba", "Jimmy"], "venue": "[cs],", "citeRegEx": "Kingma et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Kingma et al\\.", "year": 2014}, {"title": "Learning multiple layers of features from tiny images", "author": ["Krizhevsky", "Alex", "Hinton", "Geoffrey"], "venue": null, "citeRegEx": "Krizhevsky et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2009}, {"title": "A memory frontier for complex synapses", "author": ["Lahiri", "Subhaneil", "Ganguli", "Surya"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "Lahiri et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Lahiri et al\\.", "year": 2013}, {"title": "The MNIST database of handwritten digits", "author": ["LeCun", "Yann", "Cortes", "Corinna", "Burges", "Christopher JC"], "venue": null, "citeRegEx": "LeCun et al\\.,? \\Q1998\\E", "shortCiteRegEx": "LeCun et al\\.", "year": 1998}, {"title": "Learning without forgetting", "author": ["Li", "Zhizhong", "Hoiem", "Derek"], "venue": "In European Conference on Computer Vision,", "citeRegEx": "Li et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Li et al\\.", "year": 2016}, {"title": "Second-order optimization for neural networks", "author": ["Martens", "James"], "venue": "PhD thesis, University of Toronto,", "citeRegEx": "Martens and James.,? \\Q2016\\E", "shortCiteRegEx": "Martens and James.", "year": 2016}, {"title": "Estimating the hessian by back-propagating curvature", "author": ["Martens", "James", "Sutskever", "Ilya", "Swersky", "Kevin"], "venue": "arXiv preprint arXiv:1206.6464,", "citeRegEx": "Martens et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Martens et al\\.", "year": 2012}, {"title": "StateDependent Heterogeneity in Synaptic Depression between", "author": ["Montgomery", "Johanna M", "Madison", "Daniel V"], "venue": "Pyramidal Cell Pairs. Neuron,", "citeRegEx": "Montgomery et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Montgomery et al\\.", "year": 2002}, {"title": "Revisiting natural gradient for deep networks", "author": ["Pascanu", "Razvan", "Bengio", "Yoshua"], "venue": "arXiv preprint arXiv:1301.3584,", "citeRegEx": "Pascanu et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Pascanu et al\\.", "year": 2013}, {"title": "Cnn features off-theshelf: an astounding baseline for recognition", "author": ["Razavian", "Ali Sharif", "Azizpour", "Hossein", "Sullivan", "Josephine", "Carlsson", "Stefan"], "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition Workshops,", "citeRegEx": "Razavian et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Razavian et al\\.", "year": 2014}, {"title": "Making memories last: the synaptic tagging and capture hypothesis", "author": ["Redondo", "Roger L", "Morris", "Richard G. M"], "venue": "Nat Rev Neurosci,", "citeRegEx": "Redondo et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Redondo et al\\.", "year": 2011}, {"title": "The perceptron: A probabilistic model for information storage and organization in the brain", "author": ["Rosenblatt", "Frank"], "venue": "Psychological review,", "citeRegEx": "Rosenblatt and Frank.,? \\Q1958\\E", "shortCiteRegEx": "Rosenblatt and Frank.", "year": 1958}, {"title": "Progressive Neural Networks", "author": ["Rusu", "Andrei A", "Rabinowitz", "Neil C", "Desjardins", "Guillaume", "Soyer", "Hubert", "Kirkpatrick", "James", "Kavukcuoglu", "Koray", "Pascanu", "Razvan", "Hadsell", "Raia"], "venue": "[cs],", "citeRegEx": "Rusu et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Rusu et al\\.", "year": 2016}, {"title": "Split CIFAR-10/100 CNN architecture For our CIFAR-10/100 experiments, we used the default CIFAR-10 CNN from Keras: Operation Kernel Stride Filters Dropout Nonlin", "author": ["A. 10.1523/JNEUROSCI"], "venue": null, "citeRegEx": "10.1523.JNEUROSCI.3989.14.2015.,? \\Q2015\\E", "shortCiteRegEx": "10.1523.JNEUROSCI.3989.14.2015.", "year": 2015}], "referenceMentions": [{"referenceID": 4, "context": "To accommodate changes in the data distribution, ANNs typically have to be retrained on the entire dataset to avoid overfitting and catastrophic forgetting (Choy et al., 2006; Goodfellow et al., 2013).", "startOffset": 156, "endOffset": 200}, {"referenceID": 3, "context": "While this complexity has been surmised to serve memory consolidation (Fusi et al., 2005; Lahiri & Ganguli, 2013; Zenke et al., 2015; Ziegler et al., 2015; Benna & Fusi, 2016), few studies have illustrated how it benefits learning in ANNs.", "startOffset": 70, "endOffset": 175}, {"referenceID": 16, "context": "The simplest form of architectural regularization is freezing certain weights in the network so that they stay exactly the same (Razavian et al., 2014).", "startOffset": 128, "endOffset": 151}, {"referenceID": 1, "context": "A slightly more relaxed approach reduces the learning rate for layers shared with the original task while fine-tuning to avoid dramatic changes in the parameters (Donahue et al., 2014; Yosinski et al., 2014).", "startOffset": 162, "endOffset": 207}, {"referenceID": 4, "context": "Approaches using different nonlinearities like ReLU, MaxOut, and local winner-take-all have been shown to improve performance on permuted MNIST and sentiment analysis tasks (Srivastava et al., 2013; Goodfellow et al., 2013).", "startOffset": 173, "endOffset": 223}, {"referenceID": 4, "context": "Moreover, injecting noise to sparsify gradients using dropout also improves performance (Goodfellow et al., 2013).", "startOffset": 88, "endOffset": 113}, {"referenceID": 1, "context": "A slightly more relaxed approach reduces the learning rate for layers shared with the original task while fine-tuning to avoid dramatic changes in the parameters (Donahue et al., 2014; Yosinski et al., 2014). Approaches using different nonlinearities like ReLU, MaxOut, and local winner-take-all have been shown to improve performance on permuted MNIST and sentiment analysis tasks (Srivastava et al., 2013; Goodfellow et al., 2013). Moreover, injecting noise to sparsify gradients using dropout also improves performance (Goodfellow et al., 2013). Recent work from Rusu et al. (2016) proposed more dramatic architectural changes where the entire network for the previous task is copied and augmented with new features while solving a new task.", "startOffset": 163, "endOffset": 585}, {"referenceID": 5, "context": "In Li & Hoiem (2016), the predictions of the previous task\u2019s network and the current network are encouraged to be similar when applied to data from the new task by using a form of knowledge distillation (Hinton et al., 2014).", "startOffset": 203, "endOffset": 224}, {"referenceID": 5, "context": "In Li & Hoiem (2016), the predictions of the previous task\u2019s network and the current network are encouraged to be similar when applied to data from the new task by using a form of knowledge distillation (Hinton et al., 2014). Similarly, Jung et al. (2016) regularize the `2 distance between the final hidden activations instead of the knowledge distillation penalty.", "startOffset": 204, "endOffset": 256}, {"referenceID": 10, "context": "We evaluated our approach for continual learning on the split and permuted MNIST (LeCun et al., 1998; Goodfellow et al., 2013), and split versions of CIFAR-10 and CIFAR-100 (Krizhevsky & Hinton, 2009).", "startOffset": 81, "endOffset": 126}, {"referenceID": 4, "context": "We evaluated our approach for continual learning on the split and permuted MNIST (LeCun et al., 1998; Goodfellow et al., 2013), and split versions of CIFAR-10 and CIFAR-100 (Krizhevsky & Hinton, 2009).", "startOffset": 81, "endOffset": 126}], "year": 2017, "abstractText": "While deep learning has led to remarkable advances across diverse applications, it struggles in domains where the data distribution changes over the course of learning. In stark contrast, biological neural networks continually adapt to changing domains, possibly by leveraging complex molecular machinery to solve many tasks simultaneously. In this study, we introduce intelligent synapses that bring some of this biological complexity into artificial neural networks. Each synapse accumulates task relevant information over time, and exploits this information to rapidly store new memories without forgetting old ones. We evaluate our approach on continual learning of classification tasks, and show that it dramatically reduces forgetting while maintaining computational efficiency.", "creator": "LaTeX with hyperref package"}}}