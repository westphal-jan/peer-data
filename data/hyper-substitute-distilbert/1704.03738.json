{"id": "1704.03738", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Apr-2017", "title": "Counterexample Guided Inductive Optimization", "abstract": "this paper creates three definitions of a strongly guided inductive logic ( ave ) approach typically at numerical approximation complexity ( smt ) solvers. in research, cegio steps on computational tools to constrain multiple verification iteration, in order to capture additive generalization, based atop counterexamples available from smt solvers. cegio occurs able to successfully probe a dense vocabulary of functions, including time - linear supervised non - convex optimization problems based regarding fuzzy arrays, learning which data indexed by counterexamples provide compiled to guide the verification strategies, largely reducing the difficulty domain. unexpected present errors are evaluated using a wide set of benchmarks readily employed for rapid optimization efforts. simple reasoning indicates maximal efficiency and effectiveness involving independent input algorithms, namely enables ideally optimal fit in all evaluated benchmarks, some traditional techniques demonstrate usually trapped by local minima.", "histories": [["v1", "Tue, 11 Apr 2017 15:33:50 GMT  (151kb)", "http://arxiv.org/abs/1704.03738v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["rodrigo f araujo", "higo f albuquerque", "iury v de bessa", "lucas c cordeiro", "joao edgar c filho"], "accepted": false, "id": "1704.03738"}, "pdf": {"name": "1704.03738.pdf", "metadata": {"source": "CRF", "title": "Counterexample Guided Inductive Optimization", "authors": ["Rodrigo F. Ara\u00fajoa", "Higo F. Albuquerqueb", "Iury V. de Bessab", "Lucas C. Cordeiroc", "Jo\u00e3o Edgar C. Filhob"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n70 4.\n03 73\n8v 1\n[ cs\n.A I]\n1 1\nA pr\nThis paper describes three variants of a counterexample guided inductive optimization (CEGIO) approach based on Satisfiability Modulo Theories (SMT) solvers. In particular, CEGIO relies on iterative executions to constrain a verification procedure, in order to perform inductive generalization, based on counterexamples extracted from SMT solvers. CEGIO is able to successfully optimize a wide range of functions, including non-linear and non-convex optimization problems based on SMT solvers, in which data provided by counterexamples are employed to guide the verification engine, thus reducing the optimization domain. The present algorithms are evaluated using a large set of benchmarks typically employed for evaluating optimization techniques. Experimental results show the efficiency and effectiveness of the proposed algorithms, which find the optimal solution in all evaluated benchmarks, while traditional techniques are usually trapped by local minima.\nKeywords: Satisfiability Modulo Theories (SMT), Model checking, Global optimization, Non-convex optimization"}, {"heading": "1. Introduction", "text": "Optimization is an important research topic in many fields, especially in computer science and engineering [1]. Commonly, scientists and engineers have to find parameters, which optimize the behavior of a given system or the value of a given function (i.e., an optimal solution). Optimization characterizes and distinguishes the engineering gaze over a problem; for this particular reason, previous studies showed that optimization is one of the main differences between engineering design and technological design [2].\nComputer science and optimization maintain a symbiotic relationship. Many important advances of computer science are based on optimization theory. As example, planning and decidability problems (e.g., game theory [3]), resource allocation problems (e.g., hardware/software co-design [4]), and computational estimation and approximation (e.g., numerical analysis [5]) represent\nApril 13, 2017\nimportant optimization applications. Conversely, computer science plays an important role in recent optimization studies, developing efficient algorithms and providing respective tools for supporting model management and results analysis [6].\nThere are many optimization techniques described in the literature (e.g., simplex [7], gradient descent [8], and genetic algorithms [9]), which are suitable for different classes of optimization problems (e.g., linear or non-linear, continuous or discrete, convex or non-convex, and single- or multi-objective). These techniques are usually split into two main groups: deterministic and stochastic optimization. Deterministic optimization is the classic approach for optimization algorithms, which is based on calculus and algebra operators, e.g., gradients and Hessians [10]. Stochastic optimization employs randomness in the optima search procedure [10]. This paper presents a novel class of search-based optimization algorithm that employs non-deterministic representation of decision variables and constrains the state-space search based on counterexamples produced by an SMT solver, in order to ensure the complete global optimization without employing randomness. This class of techniques is defined here as counterexample guided inductive optimization (CEGIO), which is inspired by the syntax-guided synthesis (SyGuS) to perform inductive generalization based on counterexamples provided by a verification oracle [11].\nParticularly, a continuous non-convex optimization problem is one of the most complex problems. As a result, several traditional methods (e.g., NewtonRaphson [1] and Gradient Descent [8]) are inefficient to solve that specific class of problems [1]. Various heuristics are developed for obtaining approximated solutions to those problems; heuristics methods (e.g., ant colony [12] and genetic algorithms [9]) offer faster solutions for complex problems, but they sacrifice the system\u2019s correctness and are easily trapped by local optimal solutions. This paper presents a novel counterexample guided inductive optimization technique based on SMT solvers, which is suitable for a wide variety of functions, even for non-linear and non-convex functions, since most realworld optimization problems are non-convex. The function evaluation and the search for the optimal solution is performed by means of an iterative execution of successive verifications based on counterexamples extracted from SMT solvers. The counterexample provides new domain boundaries and new optima candidates. In contrast to other heuristic methods (e.g., genetic algorithms), which are usually employed for optimizing this class of function, the present approaches always find the global optimal point. This study extends the previous work of Ara\u00fajo et al. [13] and presents three variants of a counterexample guided inductive optimization approach based on SMT solvers, which improve the technique performance for specific class of functions. Furthermore, the experimental evaluation is largely expanded, since the algorithms are executed for additional optimization problems and the performance of each proposed algorithm is compared to six well-known optimization techniques. The present CEGIO approaches are able to find the correct global minima for 100% of the benchmarks, while other techniques are usually trapped by local minima, thus leading to incorrect so-\nlutions."}, {"heading": "1.1. Contributions", "text": "Our main original contributions are:\n\u2022 Novel counterexample guided inductive optimization approach. This work describes three novel variants of a counterexample guided induc-\ntive optimization approach based on SMT solvers: generalized, simplified, and fast algorithms. The generalized algorithm can be used for any constrained optimization problem and presents minor improvements w.r.t. Ara\u00fajo et al. [13]. The simplified algorithm is faster than the generalized one and can be employed if information about the minima location is provided, e.g., the cost function is semi-definite positive. The fast algorithm presents a significant speed-up if compared to the generalized and simplified ones, but it can only be employed for convex functions.\n\u2022 Convergence Proofs. This paper presents proofs of convergence and\ncompleteness (omitted in Ara\u00fajo et al. [13]) for the proposed counterexample guided inductive optimization algorithms.\n\u2022 SMT solvers performance comparison. The experiments are performed\nwith three different SMT solvers: Z3 [14], Boolector [15], and MathSAT [16]. The experimental results show that the solver choice can heavily influence the method performance.\n\u2022 Additional benchmarks. The benchmark suite is expanded to 30 opti-\nmization functions extracted from the literature [17].\n\u2022 Comparison with existing techniques. The proposed technique is com-\npared to genetic algorithm [9], particle swarm [18], pattern search [19], simulated annealing [20], and nonlinear programming [21], which are traditional optimization techniques employed for non-convex functions."}, {"heading": "1.2. Availability of Data and Tools", "text": "Our experiments are based on a set of publicly available benchmarks. All tools, benchmarks, and results of our evaluation are available on a supplementary web page http://esbmc.org/benchmarks/jscp2017.zip."}, {"heading": "1.3. Outline", "text": "Section 2 discusses related studies. Section 3 provides an overview of optimization problems and techniques, and describes background on software model checking. Section 4 describes the ANSI-C model developed for optimization problems that is suitable for the counterexample guided inductive optimization procedure. Section 5 describes the generalized and simplified optimization algorithms and respective completeness proofs. Section 6 describes the fast optimization algorithm and respective completeness proof. Section 7 reports the experimental results for evaluating all proposed optimization algorithms, while Section 8 concludes this work and proposes further studies."}, {"heading": "2. Related Work", "text": "SMT solvers have been widely applied to solve several types of verification, synthesis, and optimization problems. They are typically used to check the satisfiability of a logical formula, returning assignments to variables that evaluate the formula to true, if it is satisfiable; otherwise, the formula is said to be unsatisfiable. Nieuwenhuis and Oliveras [22] presented the first research about the application of SMT to solve optimization problems. Since then, SMT solvers have been used to solve different optimization problems, e.g., minimize errors in linear fixed-point arithmetic computations in embedded control software [23]; reduce the number of gates in FPGA digital circuits [24]; hardware/software partition in embedded systems to decide the most efficient system implementation [25\u201327]; and schedule applications for a multi-processor platform [28]. All those previous studies use SMT-based optimization over a Boolean domain to find the best system configuration given a set of metrics. In particular, in Cotton et al. [28] the problem is formulated as a multi-objective optimization problem. Recently, Shoukry et al. [29] proposed a scalable solution for synthesizing a digital controller and motion planning for under-actuated robots from LTL specifications. Such solution is more flexible and allows solving a wider variety of problems, but they are focused on optimization problems that can be split into a Boolean part and other convex part.\nIn addition, there were advances in the development of different specialized SMT solvers that employ generic optimization techniques to accelerate SMT solving, e.g., the ABsolver [30], which is used for automatic analysis and verification of hybrid-system and control-system. The ABsolver uses a non-linear optimization tool for Boolean and polynomial arithmetic and a lazy SMT procedure to perform a faster satisfiability checking. Similarly, CalCs [31] is also an SMT solver that combines convex optimization and lazy SMT to determine the satisfiability of conjunctions of convex non-linear constraints. Recently, Shoukry et al. [32] show that a particular class of logic formulas (named SMC formulas) generalizes a wide range of formulas over Boolean and nonlinear real arithmetic, and propose the Satisfiability Modulo Convex Optimization to solve satisfiability problems over SMC formulas. Our work differs from those previous studies [30\u201332] since it does not focus on speeding up SMT solvers, but it employs an SMT-based model-checking tool to guide (via counterexample) an optimization search procedure in order to ensure the global optimization.\nRecently, \u03bdZ [33] extends the SMT solver Z3 for linear optimization problems; Li et al. proposed the SYMBA algorithm [34], which is an SMT-based symbolic optimization algorithm that uses the theory of linear real arithmetic and SMT solver as black box. Sebastiani and Trentin [35] present OptiMathSat, which is an optimization tool that extends MathSAT5 SMT solver to allow solving linear functions in the Boolean, rational, and integer domains or a combination of them; in Sebastiani and Tomasi [36], the authors used a combination of SMT and LP techniques to minimize rational functions; the related work [37] extends their work with linear arithmetic on the mixed integer/rational domain, thus combining SMT, LP, and ILP techniques.\nAs an application example, Pavlinovic et al. [38] propose an approach which considers all possible compiler error sources for statically typed functional programming languages and reports the most useful one subject to some usefulness criterion. The authors formulate this approach as an optimization problem related to SMT and use \u03bdZ to compute an optimal error source in a given ill-typed program. The approach described by Pavlinovic et al., which uses MaxSMT solver \u03bdZ, shows a significant performance improvement if compared to previous SMT encodings and localization algorithms. Most previous studies related to SMT-based optimization can only solve linear problems over integer, rational, and Boolean domains in specific cases, leading to limitations in practical engineering applications. Only a few studies [29] are able to solve non-linear problems, but they are also constrained to convex functions. In contrast, this paper proposes a novel counterexample guided inductive optimization method based on SMT solvers to minimize functions, linear or non-linear, convex or non-convex, continuous or discontinuous. As a result, the proposed methods are able to solve optimization problems directly on the rational domain with adjustable precision, without using any other technique to assist the state-space search. Furthermore, our proposed methods employ a model-checking tool to generate automatically SMT formulas from an ANSI-C model of the optimization problem, which makes the representation of problems for SMT solving easy for engineers."}, {"heading": "3. Preliminaries", "text": ""}, {"heading": "3.1. Optimization Problems Overview", "text": "Let f : X \u2192 R be a cost function, such that X \u2282 Rn represents the decision variables vector x1, x2, ..., xn and f (x1, x2, ..., xn) \u2261 f (x). Let \u2126 \u2282 X be a subset settled by a set of constraints.\nDefinition 1. A multi-variable optimization problem consists in finding an optimal vector x, which minimizes f in \u2126.\nAccording to Definition 1, an optimization problem can be written as\nmin f (x), s.t. x \u2208 \u2126.\n(1)\nIn particular, this optimization problem can be classified in different ways w.r.t. constraints, decision variables domain, and nature of cost function f . All optimization problems considered here are constrained, i.e., decision variables are constrained by the subset \u2126. The optimization problem domain X that contains \u2126 can be the set of N, Z, Q, or R. Depending on the domain and constraints, the optimization search-space can be small or large, which influences the optimization algorithms performance.\nThe cost function can be classified as linear or non-linear; continuous, discontinuous or discrete; convex or non-convex. Depending on the cost function nature, the optimization problem can be hard to solve, given the time and memory resources [39]. Particularly, non-convex optimization problems are the most difficult ones w.r.t. the cost function nature. A non-convex cost\nfunction is a function whose epigraph is a non-convex set and consequently presents various inflexion points that can trap the optimization algorithm to a sub-optimal solution. A non-convex problem is necessarily a non-linear problem and it can also be discontinuous. Depending on that classification, some optimization techniques are unable to solve the optimization problem, and some algorithms usually point to suboptimal solutions, i.e., a solution that is not a global minimum of f , but it only locally minimizes f . Global optimal solutions of the function f , aforementioned, can be defined as\nDefinition 2. A vector x\u2217 \u2208 \u2126 is a global optimal solution of f in \u2126 iff f (x\u2217) \u2264 f (x), \u2200x \u2208 \u2126."}, {"heading": "3.2. Optimization Techniques", "text": "Different optimization problems offer different difficulties to their particular solutions. Such complexity is mainly related to the ruggedness (e.g., continuity, differentiability, and smoothness) and dimensionality of the problem (i.e., the dimension, and for the finite case, the number of elements of \u2126). Depending on these factors, different optimization techniques can be more efficient to solve a particular optimization problem. Generally, traditional optimization techniques can be divided into two groups: deterministic and stochastic optimization.\nThe deterministic techniques employ a search engine, where each step is directly and deterministically related to the previous steps [40]. In summary, deterministic techniques can be gradient-based or enumerative search-based. Gradient-based techniques search for points, where the gradient of cost function is null (\u2207 f (x) = 0), e.g., gradient-descent [41] and Newton\u2019s optimization [1]. Although they are fast and efficient, those techniques are unable to solve non-convex or non-differentiable problems. Enumerative search-based optimization consists in scanning the search-space by enumerating all possible points and comparing cost function with best previous values, e.g., dynamic programming, branch and bound [42], and pattern search [43].\nStochastic techniques employ randomness to avoid the local minima and to ensure the global optimization; such techniques are usually based on metaheuristics [44]. This class of techniques has become very popular in the last decades and has been used in all types of optimization problems. Among those stochastic techniques, simulated annealing [20], particle swarm [18], and evolutionary algorithms (e.g., genetic algorithms [9]) are usually employed in practice. Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space. The global optima is the set of values for the decision variables that makes an optimization proposition satisfiable. The technique presented here is the first optimization method based on SMT solvers and inductive generalization described in the literature, which is able to solve non-convex problems over R."}, {"heading": "3.3. Model Checking", "text": "Model checking is an automated verification procedure to exhaustively check all (reachable) system\u2019s states [46]. The model checking procedure typically consists of three steps: modeling, specification, and verification.\nModeling is the first step, where it converts the system to a formalism that is accepted by a verifier. The modeling step usually requires the use of an abstraction to eliminate irrelevant (or less) important system details [47]. The second step is the specification, which describes the system\u2019s behavior and the property to be checked. An important issue in the specification is the correctness. Model checking provides ways to check whether a given specification satisfies a system\u2019s property, but it is difficult to determine whether such specification covers all properties in which the system should satisfy.\nFinally, the verification step checks whether a given property is satisfied w.r.t. a given model, i.e., all relevant system states are checked to search for any state that violates the verified property. In case of a property violation, the verifier reports the system\u2019s execution trace (counterexample), which contains all steps from the (initial) state to the (bad) state that lead to the property violation. Errors could also occur due to incorrect system modeling or inadequate specification, thus generating false verification results."}, {"heading": "3.3.1. Bounded Model Checking (BMC)", "text": "BMC is an important verification technique, which has presented attractive results over the last years [48]. BMC techniques based on Boolean Satisfiability (SAT) [49] or Satisfiability Modulo Theories (SMT) [50] have been successfully applied to verify single- and multi-threaded programs, and also to find subtle bugs in real programs [51, 52]. BMC checks the negation of a given property at a given depth over a transition system M.\nDefinition 3. [49] \u2013 Given a transition system M, a property \u03c6, and a bound k; BMC unrolls the system k times and translates it into a verification condition (VC) \u03c8, which is satisfiable iff \u03c6 has a counterexample of depth less than or equal to k.\nIn this study, the ESBMC tool [53] is used as verification engine, as it represents one of the most efficient BMC tools that participated in the last software verification competitions [48]. ESBMC finds property violations such as pointer safety, array bounds, atomicity, overflows, deadlocks, data race, and memory leaks in single- and multi-threaded C/C++ software. It also verifies programs that make use of bit-level, pointers, structures, unions, fixed- and floating-point arithmetic. Inside ESBMC, the associated problem is formulated by constructing the following logical formula\n\u03c8k = I(S0) \u2227 k \u2228\ni=0\ni\u22121 \u2227\nj=0\n\u03b3(sj, sj+1) \u2227 \u03c6(s1) (2)\nwhere \u03c6 is a property and S0 is a set of initial states of M, and \u03b3(sj, sj+1) is the transition relation of M between time steps j and j+ 1. Hence, I(S0) \u2227 \u2227i\u22121\nj=0 \u03b3(sj, sj+1) represents the executions of a transition system M of length i. The above VC \u03c8 can be satisfied if and only if, for some i \u2264 k there exists\na reachable state at time step i in which \u03c6 is violated. If the logical formula (2) is satisfiable (i.e., returns true), then the SMT solver provides a satisfying assignment (counterexample).\nDefinition 4. A counterexample for a property \u03c6 is a sequence of states s0, s1, . . . , sk with s0 \u2208 S0, sk \u2208 Sk, and \u03b3 (si, si+1) for 0 \u2264 i < k that makes (2) satisfiable. If it is unsatisfiable (i.e., returns false), then one can conclude that there is no error state in k steps or less.\nIn addition to software verification, ESBMC has been applied to ensure correctness of digital filters and controllers [54\u201356]. Recently, ESBMC has been applied to optimize HW/SW co-design [25\u201327]."}, {"heading": "4. Verification Model for Counterexample Guided Inductive Optimization", "text": ""}, {"heading": "4.1. Modeling Optimization Problems using a Software Model Checker", "text": "There are two important directives in the C/C++ programming language, which can be used for modeling and controlling a verification process: ASSUME and ASSERT. The ASSUME directive can define constraints over (non-deterministic) variables, and the ASSERT directive is used to check system\u2019s correctness w.r.t. a given property. Using these two statements, any off-the-shelf C/C++ model checker (e.g., CBMC [52], CPAChecker [57], and ESBMC [53]) can be applied to check specific constraints in optimization problems, as described by Eq. (1).\nHere, the verification process is iteratively repeated to solve an optimization problem using intrinsic functions available in ESBMC (e.g., __ESBMC_assume and __ESBMC_assert). We apply incremental BMC to efficiently prune the state-space search based on counterexamples produced by an SMT solver. Note that completeness is not an issue here (cf. Definitions 1 and 2) since our optimization problems are represented by loop-free programs [58]."}, {"heading": "4.2. Illustrative Example", "text": "The Ursem03\u2019s function is employed to illustrate the present SMT-based optimization method for non-convex optimization problems [17]. The Ursem03\u2019s function is represented by a two-variables function with only one global minimum in f (x1, x2) = \u22123, and has four regularly spaced local minima positioned in a circumference, with the global minimum in the center. Ursem03\u2019s function is defined by Eq. (3); Fig. 1 shows its respective graphic.\nf (x1, x2) = \u2212 sin ( 2.2\u03c0x1 \u2212 \u03c0\n2\n) (2\u2212 |x1|)(3\u2212 |x1|)\n4 \u2212 sin\n( 2.2\u03c0x2 \u2212 \u03c0\n2\n) (2\u2212 |x2|)(3\u2212 |x2|)\n4 (3)"}, {"heading": "4.3. Modeling", "text": "The modeling process defines constraints, i.e., \u2126 boundaries (cf. Section 3.1).\nThis step is important for reducing the state-space search and consequently for avoiding the state-space explosion by the underlying model-checking procedure. Our verification engine is not efficient for unconstrained optimization;\nfortunately, the verification time can be drastically reduced by means of a suitable constraint choice. Consider the optimization problem given by Eq. (4), which is related to the Ursem03\u2019s function given in Eq. (3):\nmin f (x1, x2) s.t. x1 \u2265 0\nx2 \u2265 0. (4)\nNote that inequalities x1 \u2265 0 and x2 \u2265 0 are pruning the state-space search to the first quadrant; however, even so it produces a (huge) state-space to be explored since x1 and x2 can assume values with very high modules. The optimization problem given by Eq. (4) can be properly rewritten as Eq. (5) by introducing new constraints. The boundaries are chosen based on Jamil and Yang [17], which define the domain in which the optimization algorithms can evaluate the benchmark functions.\nmin f (x1, x2) s.t. \u22122 \u2264 x1 \u2264 2\n\u22122 \u2264 x2 \u2264 2. (5)\nFrom the optimization problem definition given by Eq. (5), the modeling step can be encoded, where decision variables are declared as non-deterministic variables constrained by the ASSUME directive. In this case, \u22122 \u2264 x1 \u2264 2 and \u22122 \u2264 x2 \u2264 2. Fig. 2 shows the respective C code for modeling Eq. (5). Note that in Figure 2, the decision variables x1 and x2 are declared as floatingpoint numbers initialized with non-deterministic values; we then constraint the state-space search using assume statements. The objective function of Ursem\u2018s function is then declared as described by Eq. 3."}, {"heading": "4.4. Specification", "text": "The next step of the proposed methodology is the specification, where the system behavior and the property to be checked are described. For the Ursem03\u2019s function, the result of the specification step is the C program shown in Fig. 3, which is iteratively checked by the underlying verifier. Note that the decision variables are declared as integer type and their initialization depends on a given precision p, which is iteratively adjusted once the counterexample is produced by the SMT solver. Indeed, the C program shown in Fig. 2 leads the verifier to produce a considerably large state-space exploration, if the decision variables are declared as non-deterministic floating-point type. In this study, decision variables are defined as non-deterministic integers, thus discretizing and reducing the state-space exploration; however, this also reduces the optimization process precision.\nTo trade-off both precision and verification time, and also to maintain convergence to an optimal solution, the underlying model-checking procedure has to be iteratively invoked, in order to increase its precision for each successive execution. An integer variable p = 10n is created and iteratively adjusted, such that n is the amount of decimal places related to the decision variables. Additionally, a new constraint is inserted; in particular, the new value of the objective function f (x(i)) at the i-th must not be greater than the value obtained in the previous iteration f (x(i\u22121)). Initially, all elements in the statespace search \u2126 are candidates for optimal points, and this constraint cutoffs several candidates on each iteration.\nIn addition, a property has to be specified to ensure convergence to the minimum point on each iteration. This property specification is stated by means of an assertion, which checks whether the literal loptimal given in Eq. (6) is satisfiable for every optimal candidate fc remaining in the state-space search (i.e., traversed from lowest to highest).\nloptimal \u21d0\u21d2 f (x) > fc (6)\nThe verification procedure stops when the literal loptimal is not satisfiable, i.e., if there is any x(i) for which f (x(i)) \u2264 fc; a counterexample shows such xi, approaching iteratively f (x) from the optimal x\u2217. Fig. 3 shows the initial specification for the optimization problem given by Eq. (5). The initial value of the objective function can be randomly initialized. For the example in Fig. 3, f (x(0)) is arbitrarily initialized to 100, but the present optimization algorithm works for any initial state."}, {"heading": "4.5. Verification", "text": "Finally, in the verification step, the C program shown in Fig. 3 is checked by the verifier and a counterexample is returned with a set of decision variables x, for which the objective function value converges to the optimal value. A specified C program only returns a successful verification result if the previous function value is the optimal point for that specific precision (defined by p), i.e., f (x(i\u22121)) = f (x\u2217). For the example shown in Fig. 3, the verifier shows a counterexample with the following decision variables: x1 = 2 and x2 = 0. These decision variable are used to compute a new minimum candidate, note that f (2, 0) = \u22121.5, which is the new minimum candidate solution provided by this verification step. Naturally, it is less than the initial value (100), and\nthis verification can be repeated with the new value of f (x(i\u22121)), in order to obtain an objective function value that is close to the optimal point on each iteration. Note that the data provided by the counterexample is crucial for the algorithm convergence and for the state-space search reduction."}, {"heading": "5. Counterexample Guided Inductive Optimization of Non-convex Functions", "text": "This section presents two variants of the Counterexample Guided Inductive Optimization (CEGIO) algorithm for global constrained optimization. A generalized CEGIO algorithm is explained in Subsection 5.1, together with a convergence proof in Subsection 5.2, while Subsection 5.3 presents a simplified version of that algorithm."}, {"heading": "5.1. CEGIO: the Generalized Algorithm (CEGIO-G)", "text": "The generalized SMT-based optimization algorithm previously presented by Ara\u00fajo et al. [13] is able to find the global optima for any optimization problem that can be modeled with the methodology presented in Section 4. The execution time of that algorithm depends on how the state-space search is restricted and on the number of the solution decimal places. Specifically, the algorithm presents a fixed-point solution with adjustable precision, i.e., the number of decimal places can be defined. Naturally, for integer optimal points, this algorithm returns the correct solution quickly. However, this algorithm might take longer for achieving the optimal solution of unconstrained optimization problems with non-integer solutions since it depends on the required precision. Although this algorithm frequently produces a longer execution time than other traditional techniques, its error rate is typically lower than other existing methods, once it is based on a complete and sound verification procedure. Alg. 1 shows an improved version of the algorithm presented by Ara\u00fajo et al. [13]; this algorithm is denoted here as \u201dGeneralized CEGIO algorithm\u201d (CEGIO-G).\nAlg. 1 repeats the specification and verification steps, described in Section 4, until the optimal solution x\u2217 is found. The precision of optimal solution defines the desired precision variable \u01eb. An unitary value of \u01eb results in integer solutions. Solution with one decimal place is obtained for \u01eb = 10, two decimal places are achieved for \u01eb = 100, i.e., the number of decimal places \u03b7 for the solution is calculated by means of the equation\n\u03b7 = log \u01eb. (7)\nAfter the variable initialization and declaration (lines 1-3 of Alg. 1), the search domain \u2126 is specified in line 5, which is defined by lower and upper bounds of the x variable, and in line 6, the model for function, f (x), is defined. The specification step (line 8) is executed for each iteration until the desired precision is achieved. In this specific step, the search-space is remodelled for the i-th precision and it employs previous results of the optimization process, i.e., f (x(i\u22121)). The verification step is performed in lines 9-10, where the candidate function fc, i.e., f (x(i\u22121)) is analyzed by means of the satisfiability check\ninput :A cost function f (x), the space for constraint set \u2126, and a desired precision \u01eb output :The optimal decision variable vector x\u2217, and the optimal value of\nfunction f (x\u2217)\n1 Initialize f (x(0)) randomly and i = 1 2 Initialize the precision variable with p = 1 3 Declare the auxiliary variables x as non-deterministic integer variables 4 while p \u2264 \u01eb do 5 Define bounds for x with the ASSUME directive, such that x \u2208 \u2126\u03b7 6 Describe a model for f (x) 7 do 8 Constrain f (x(i)) < f (x(i\u22121)) with the ASSUME directive 9 Verify the satisfiability of loptimal given by Eq. (6) with the ASSERT directive\n10 Update x\u2217 = x(i) and f (x\u2217) = f (x(i)) based on the counterexample 11 Do i = i+ 1 12 while \u00acloptimal is satisfiable 13 Update the precision variable p 14 end 15 x \u2217 = x(i\u22121) and f (x\u2217) = f (i\u22121)(x) 16 return x\u2217 and f (x\u2217)\nAlgorithm 1: CEGIO: the generalized algorithm.\nof \u00acloptimal. If there is a f (x) \u2264 fc that violates the ASSERT directive, then the candidate function is updated and the algorithm returns to the specification step (line 8) to remodel the state-space again. If the ASSERT directive is not violated, the last candidate fc is the minimum value with the precision variable p (initially equal to 1), thus p is multiplied by 10, adding a decimal place to the optimization solution, and the outer loop (while) is repeated.\nNote that Alg. 1 contains two nested loops, the outer (while) loop is related to the desired precision and the inner (do-while) loop is related to the specification and verification steps. This configuration speeds-up the optimization problem due to the complexity reduction if compared to the algorithm originally presented in Ara\u00fajo et al. [13]. The generalized CEGIO algorithm uses the manipulation of fixed-point number precision to ensure the optimization convergence."}, {"heading": "5.2. Proof of Convergence", "text": "A generic optimization problem described in the previous section is formalized as follow: given a set \u2126 \u2282 Rn, determine x\u2217 \u2208 \u2126, such that, f (x\u2217) \u2208 \u03a6 is the lowest value of the function f , i.e., min f (x), where \u03a6 \u2282 R is the image set of f (i.e., \u03a6 = Im( f )). Our approach solves the optimization problem with \u03b7 decimal places, i.e., the solution x\u2217 is an element of the rational domain \u2126\u03b7 \u2282 \u2126 such that \u2126\u03b7 = \u2126 \u2229 \u0398, where \u0398 = {x \u2208 Qn|x = k\u00d7 10\u2212\u03b7, \u2200k \u2208 Z}, i.e., \u2126\u03b7 is composed by rationals with \u03b7 decimal places in \u2126 (e.g., \u21260 \u2282 Zn). Thus, x\u2217,\u03b7 is the minima of function f in \u2126\u03b7 .\nLemma 1. Let \u03a6 be a finite set composed by all values f (x) < fc, where fc \u2208 \u03a6 is any minimum candidate and x \u2208 \u2126. The literal \u00acloptimal (Eq. 6) is UNSAT iff fc holds the lowest values in \u03a6; otherwise, \u00acloptimal is SAT iff there exists any xi \u2208 \u2126 such that f (xi) < fc.\nTheorem 1. Let \u03a6i be the i-th image set of the optimization problem constrained by \u03a6i = { f (x) < f i c}, where f i c = f (x\n(i\u22121)), \u2200i > 0, and \u03a60 = \u03a6. There exists an i\u2217 > 0, such that \u03a6i\u2217 = \u2205, and f (x \u2217) = f i \u2217 c .\nProof. Initially, the minimum candidate f 0c is chosen randomly from \u03a60. Considering Lemma 1, if \u00acloptimal is SAT, any f (x 0) (from the counterexample) is adopted as next candidate solution (i.e., f 1c = f (x (0)), and every element from \u03a61 is less than f 1 c . Similarly in the next iterations, while \u00acloptimal is SAT, f ic = f (x (i\u22121)), and every element from \u03a6i is less than f i c , consequently, the number of elements of \u03a6i\u22121 is always less than that of \u03a6i. Since \u03a60 is finite, in the i\u2217-th iteration, \u03a6i\u2217 will be empty and the \u00acloptimal is UNSAT, which leads to (Lemma 1) f (x\u2217) = f i\u2217c .\nTheorem 1 provides sufficient conditions for the global minimization over a finite set; it solves the optimization problem defined at the beginning of this section, iff the search domain \u2126\u03b7 is finite. It is indeed finite, once it is defined as an intersection between a bounded set (\u2126) and a discrete set (\u0398). Thus, the CEGIO-G algorithm will always provide the minimum x\u2217 with \u03b7 decimal places (i.e., x\u2217,\u03b7)."}, {"heading": "5.2.1. Avoiding the Local Minima", "text": "As previously mentioned, an important feature of this proposed CEGIO method is always to find the global minimum (cf. Theorem 1). Many optimization algorithms might be trapped by local minima and they might incorrectly solve optimization problems. However, the present technique ensures the avoidance of those local minima, through the satisfiability checking, which is performed by successive SMT queries. This property is maintained for any class of functions and for any initial state.\nFigures 4 and 5 show the aforementioned property of this algorithm, comparing its performance to the genetic algorithm. In those figures, Ursem03\u2019s function is adapted for a single-variable problem over x1, i.e., x2 is considered fixed and equals to 0.0, and the respective function is reduced to a plane crossing the global optimum in x1 = \u22123. The partial results after each iteration are illustrated by the various marks in these graphs. Note that the present method does not present continuous trajectory from the initial point to the optimal point; however, it always achieves the correct solution. Fig. 4 shows that both techniques (GA and SMT) achieve the global optimum. However, Fig. 5 shows that GA might be trapped by the local minimum for a different initial point. In contrast, the proposed CEGIO method can be initialized further away from the global minimum and as a result it can find the global minimum after some iterations, as shown in Figures 4 and 5."}, {"heading": "5.3. A Simplified Algorithm for CEGIO (CEGIO-S)", "text": "Alg. 1 is suitable for any class of functions, but there are some particular functions that contain further knowledge about their behaviour (e.g., positive semi-definite functions such as f (x) \u2265 0). Using that knowledge, Alg. 1 is slightly modified for handling this particular class of functions. This algorithm is named here as \u201cSimplified CEGIO algorithm\u201d (CEGIO-S) and it is presented in Alg. 2.\nNote that Alg. 2 contains three nested loops after the variable initialization and declaration (lines 1-4), which is similar to the algorithm presented in [13]. In each execution of the outer loop while (lines 5-25), the bounds and precision are updated accordingly. The main difference in this algorithm w.r.t the Alg. 1 is the presence of the condition in line 9, i.e., it is not necessary to generate new checks if that condition does not hold, since the solution is already at the minimum limit, i.e., f (x\u2217) = 0.\nFurthermore, there is another inner loop while (lines 12-15), which is responsible for generating multiple VCs through the ASSERT directive, using the interval between fm and f (x(i\u22121)). Note that this loop generates \u03b1 + 1 VCs through the step defined by \u03b4 in line 8.\nThese modifications allow Alg. 2 to converge faster than Alg. 1 for the positive semi-definite functions, since the chance of a check failure is higher due to the larger number of properties. However, if \u03b1 represents a large number, then the respective algorithm would produce many VCs, which could\ninput :A cost function f (x), the space for constraint set \u2126, a desired precision \u01eb, and a learning rate \u03b1 output :The optimal decision variable vector x\u2217, and the optimal value of\nfunction f (x\u2217)\n1 Initialize fm = 0 2 Initialize f (x(0)) randomly and i = 1 3 Initialize the precision variable with p = 1 4 Declare the auxiliary variables x as non-deterministic integer variables 5 while p \u2264 \u01eb do 6 Define bounds for x with the ASSUME directive, such that x \u2208 \u2126\u03b7 7 Describe a model for f (x) 8 Declare \u03b4 = ( f (x(i\u22121))\u2212 fm)/\u03b1\n9 if ( f (x(i\u22121))\u2212 fm > 0.00001) then 10 do 11 Constraint f (x(i)) < f (x(i\u22121)) with the ASSUME directive 12 while ( fm \u2264 f (x(i\u22121)) do 13 Verify the satisfiability of loptimal given by Eq. (6) with the ASSERT\ndirective\n14 Do fm = fm + \u03b4 15 end 16 Update x\u2217 = x(i) and f (x\u2217) = f (x(i)) based on the counterexample 17 Do i = i+ 1 18 while \u00acloptimal is satisfiable 19 end 20 else 21 break 22 end 23 Update the precision variable p\n24 end 25 x \u2217 = x(i\u22121) and f (x\u2217) = f (i\u22121)(x) 26 return x\u2217 and f (x\u2217)\nAlgorithm 2: CEGIO: a simplified algorithm.\ncause the opposite effect and even lead the verification process to exhaust the memory."}, {"heading": "6. Counterexample Guided Inductive Optimization of Convex Problems", "text": "This section presents the fast CEGIO algorithm for convex optimization problems. Subsection 6.1 presents the convex optimization problems, while the fast SMT algorithm is explained in Subsection 6.2. Additionally, a convergence proof of the CEGIO convex problem is described in Subsection 6.3."}, {"heading": "6.1. Convex Optimization Problems", "text": "Convex functions are an important class of functions commonly found in many areas of mathematics, physics, and engineering [59]. A convex optimization problem is similar to Eq. (1), where f (x) is a convex function, which satisfies Eq. (8) as\nf (\u03b1x1 + \u03b2x2) \u2264 \u03b1 f (x1) + \u03b2 f (x2) (8)\nfor all xi \u2208 R n, with i = 1, 2 and all \u03b1, \u03b2 \u2208 R with \u03b1+ \u03b2 = 1, \u03b1 \u2265 0, \u03b2 \u2265 0.\nTheorem 2 is an important theorem for convex optimization, which is used\nby most convex optimization algorithms.\nTheorem 2. A local minimum of a convex function f , on a convex subset, is always a global minimum of f [60].\nHere, Theorem 2 is used to ensure convergence of the CEGIO convex opti-\nmization algorithm presented in Subsection 6.2."}, {"heading": "6.2. Fast CEGIO (CEGIO-F)", "text": "Alg. 1 aforementioned evolves by increasing the precision of the decision variables, i.e., in the first execution of its while loop, the obtained global minimum is integer since p = 1, called x\u2217,0. Alg. 3 is an improved algorithm of that Alg. 1 for application in convex functions. It will be denoted here as fast CEGIO algorithm. Note that, the only difference of Alg. 1 is the insertion of line 13, which updates \u2126k before of p. For each execution of the while loop, the solution is optimal for precision p. A new search domain \u2126k \u2282 \u2126\u03b7 is obtained from a CEGIO process over \u2126k\u22121, defining \u2126k as follows: \u2126k = \u2126\u03b7 \u2229 [x\u2217,k\u22121 \u2212 p, x\u2217,k\u22121 + p], where x\u2217,k\u22121 is the solution with k\u2212 1 decimal places.\ninput :A cost function f (x), the space for constraint set \u2126, and a desired precision \u01eb output :The optimal decision variable vector x\u2217, and the optimal value of\nfunction f (x\u2217)\n1 Initialize f (x(0)) randomly and i = 1 2 Initialize the precision variable with p = 1 3 Declare the auxiliary variables x as non-deterministic integer variables 4 while p \u2264 \u01eb do 5 Define bounds for x with the ASSUME directive, such that x \u2208 \u2126k 6 Describe a model for f (x) 7 do 8 Constrain f (x(i)) < f (x(i\u22121)) with the ASSUME directive 9 Verify the satisfiability of loptimal given by Eq. (6) with the ASSERT directive\n10 Update x\u2217 = x(i) and f (x\u2217) = f (x(i)) based on the counterexample 11 Do i = i+ 1 12 while \u00acloptimal is satisfiable 13 Update set \u2126k 14 Update the precision variable p 15 end 16 x \u2217 = x(i\u22121) and f (x\u2217) = f (i\u22121)(x) 17 return x\u2217 and f (x\u2217)\nAlgorithm 3: Fast CEGIO."}, {"heading": "6.3. Proof of Convergence for the Fast CEGIO Algorithm", "text": "The fast CEGIO algorithm computes iteratively for every \u2126k, 0 \u2265 k \u2264 \u03b7. Theorem 1 ensures the global minimization for any finite \u2126k. The global convergence of the fast CEGIO algorithm is ensured iff the minima of any \u2126k\u22121 is inside \u2126k. It holds for the generalized algorithm since \u21261 \u2282 \u21262... \u2282 \u2126k\u22121 \u2282 \u2126k. However, the fast CEGIO algorithm modifies \u2126k boundaries using the k\u2212 1-th solution.\nLemma 2. Let f : \u2126k \u2192 R be a convex function, as \u2126k is a finite set, Theorem 1 ensures that the minimum, x\u2217,k in \u2126k is a local minimum for precision p, where k = log p. In addition, as f is a convex function, any element x \u2208 \u2126k+1 outside [x\u2217,k \u2212 p, x\u2217,k + p] has its image f (x) > f (x\u2217,k) ensured by Eq. (8).\nLemma 2 ensures that the solution is a local minimum of f , and Theorem 2 ensures that it is a global minimum. As a result, bounds of \u2126k can be updated on each execution of the outer while loop; this modification considerably reduces the state-space searched by the verifier, which consequently decreases the algorithm execution time."}, {"heading": "7. Experimental Evaluation", "text": "This section describes the experiments design, execution, and analysis for the proposed CEGIO algorithms. We use the ESBMC tool as verification engine to find the optimal solution for a particular class of functions. We also compare the present approaches to other exisiting techniques, including genetic algorithm, particle swarm, pattern search, simulated annealing, and nonlinear programming. Preliminary results allowed us to improve the experimental evaluation as follows.\n(i) There are functions with multiplication operations and large inputs, which\nlead to overflow in some particular benchmarks. Thus, the data-type float is replaced by double in some particular functions to avoid overflow.\n(ii) ESBMC uses different SMT solvers to perform program verification. Depending on the selected solver, the results, verification time, and coun-\nterexamples can be different. This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.\n(iii) There are functions that present properties which permits the formu-\nlation of invariants to prune the state-space search, e.g., functions that use absolute value operators (or polynomial functions with even degree); those functions will always present positive values. As a result, the optimization processes can be simplified, reducing the search domain to positive regions only. Such approach led to the development of Algorithm 2, which aims to reduce the verification time.\nAll experiments are conducted on a otherwise idle computer equipped with Intel Core i7-4790 CPU 3.60 GHz, with 16 GB of RAM, and Linux OS Ubuntu 14.10. All presented execution times are CPU times, i.e., only time periods spent in allocated CPUs, which were measured with the times system call (POSIX system)."}, {"heading": "7.1. Experimental Objectives", "text": "The experiments aim to answer two research questions:\nRQ1 (sanity check) what results do the proposed CEGIO algorithms obtain\nwhen searching for the functions optimal solution?\nRQ2 (performance) what is the proposed CEGIO algorithms performance if\ncompared to genetic algorithm, particle swarm, pattern search, simulated annealing, and non-linear programming?"}, {"heading": "7.2. Description of Benchmarks", "text": "In order to answer these research questions, we consider 30 reference functions of global optimization problems extracted from the literature [62]; all reference functions are multivariable with two decision variables. Those functions present different formats, e.g., polynomials, sine, cosine, floor, sum, square root; and can be continuous, differentiable, separable, non-separable, scalable, non-scalable, uni-modal, and multi-modal. The employed benchmark suite is described in Table 1 as follows: benchmark name, domain, and global minimum, respectively.\nIn order to perform the experiments with three different CEGIO algorithms, generalized (Alg. 1), simplified (Alg. 2), and fast (Alg. 3), a set of programs were developed for each function, taking into account each algorithm and varying the solver and the data-type accordingly. For the experiment with the generalized algorithm, all benchmarks are employed; for the simplified algorithm, 15 functions are selected from the benchmark suite. By previous observation, we can affirm that those 15 functions are semi-definite positive; lastly, we selected 10 convex functions from the benchmark suite to evaluate the fast algorithm. For the experiments execution with the proposed algorithms, random values are generated, belonging to the solutions space of each function, and they are used as initialization of the proposed algorithms, as described in Section 5. The other optimization techniques used for comparison, had all benchmarks performed by means of the Optimization Toolbox in MATLAB 2016b [63] with the entire benchmark suite. The time presented in the following tables are related to the average of 20 executions for each benchmark; the measuring unit is always in seconds based on the CPU time."}, {"heading": "7.3. Experimental Results", "text": "In the next subsections, we evaluate the proposed CEGIO algorithms per-\nformance; we also compare them to other traditional techniques."}, {"heading": "7.3.1. Generalized Algorithm (CEGIO-G) Evaluation", "text": "The experimental results presented in Table 2 are related to the performance evaluation of the Generalized Algorithm (CEGIO-G) (cf. Alg. 1). Here, the CPU time is measured in seconds to find the global minimum using the ESBMC tool with a particular SMT solver. Each column of Table 2 is described as follows: columns 1 and 5 are related to functions of the benchmark suite;\ncolumns 2 and 6 are related to the configuration of ESBMC with Boolector; columns 3 and 7 are related to ESBMC with Z3; and columns 4 and 8 are related to ESBMC with MathSAT.\nAll benchmarks are employed for evaluating the generalized algorithm performance. The correct global minima is found in all benchmarks using different SMT solvers: MathSAT, Z3, and Boolector. For all evaluated benchmarks, MathSAT is 4.6 times faster than Z3, although there are benchmarks in which MathSAT took longer than Z3, e.g., in Adjiman and Cosine functions. If we compare Boolector performance to other SMT solvers, we can also observe that it is routinely faster than both Z3 and MathSAT.\nInitially, all experiments were performed using float-type variables, but we noticed that there was either overflow or underflow in some particular benchmarks, e.g., the Cube functions. It occurs due to truncation in some arithmetic operations and series, e.g., sines and cosines, once the verification engine employs fixed-point for computations. This might lead to a serious problem if there are several operations being performed with very large inputs, in a way that causes errors that can be propagated; those errors thus lead to incorrect results. For this specific reason, we decided to use double-type variables for these particular benchmarks to increase precision. We observed that the global minimum value is always found using double precision, but it takes longer than using float-type variables. The cells with asterisks in Table 2 identify the benchmarks that we use double- instead of float-type.\nAdditionally, we observed that when the function has more than one global minimum, e.g.,Wayburn Seader 2 with the decision variables f{(0.2.1), (0.425, 1)}, the algorithm first finds the global minimum with the decision variables of less precision, then in this case f (0.2, 1). Analyzing Alg. 1, when an overall minimum value is found, the condition in line 9 is not satisfied since there is no candidate function with a value less than the current one found; on line 13 the precision is updated and the outer loop starts again. Even if there is another overall minimum in this new precision, it will not be considered by the ASSUME directive in line 8 since the decision variables define a candidate function with the same value as the current function f (x), and not less than the defined in Eq. 6. In order to find the other global minimum, it would be necessary to limit it with the ASSUME directive, disregarding the previous minimum."}, {"heading": "7.3.2. Simplified Algorithm (CEGIO-S) Evaluation", "text": "The simplified algorithm (CEGIO-S) is applied to functions that contain invariants about the global minimum, e.g., semi-definite positive functions, where it is not needed to search for their minimum in the f negative values. For instance, the leon function presented in Eq. (9) has the global minimum at f (1, 1) = 0 as follows\nf (x1, x2) = 100(x2 \u2212 x1 2)2 + (1\u2212 x1) 2. (9)\nBy inpesction it is possible to claim that there are no negative values for f (x). Therefore, in order to effectively evaluate Algorithm 2, 15 benchmarks are selected, which have modules or exponential pair, i.e., the lowest possible value to global minimum is a non-negative value. The experiments are performed using the float data-type, and double as needed to avoid overflow, using the same solvers as described in Subsection 7.3.1. According to the experimental results shown in Table 3, we confirmed that all obtained results match those described in the literature [62].\nAdditionally, we can see that the simplified algorithm reduces the optimization time considerably, with particular benchmarks reaching less than 1 second. However, the reduction with the MathSAT solver is less expressive since it models float-type variables using floating-point arithmetic in both CEGIO-S and CEGIO-G algorithms, while Boolector and Z3 uses fixed-point arithmetic. We conclude that either our fast algorithm is suitable for fixedpoint architectures or MathSAT implements more aggressive simplifications than Boolector and Z3 The purpose of this algorithm is to find the global minimum to reduce the verification time, for functions that have invariants about the global min-\nimum. However, the simplified algorithm run-time might be longer than the generalized one since it requires parameter settings according to the function. As described in Subsection 5.3, in line 8 of Algorithm 2, we have the variable \u03b4 that defines the state-space search segmentation; \u03b4 is obtained by the difference of the current f (x) and the boundary that we know, divided by the variable \u03b1 (previously established). If we have a very large absolute value for \u03b1, then we would have additional checks, thus creating many more properties to be checked by the verifier (and thus leading it to longer verification times). If we analyze function S2 in Eq. (10), then we can easily inspect that there is no f (x) less than 2; in this case, therefore, in line 1 of Algorithm 2, one can establish fm with the value 2. This slightly change in the initialization of fm in Algorithm 2 prunes the state-space search and the verification time accordingly.\nf (x1, x2) = 2+ (x2 \u2212 0.7) 2 (10)"}, {"heading": "7.3.3. Fast Algorithm (CEGIO-F) Evaluation", "text": "The experimental results for the fast algorithm (CEGIO-F) are presented in Table 4. This algorithm is applied to convex functions, where there is only a global minimum; in particular, the state-space is reduced on each iteration of the while-loop in Algorithm 3, ensuring that the global minimum is in the new (delimited) space, and then it performs a new search in that space to reduce the overall optimization time.\nIn order to evaluate the effectiveness of Algorithm 3, we selected approximately 10 convex functions of the benchmark suite; we also compare the fast algorithm (CEGIO-F) results with the generalized one (CEGIO-G). We observed that there are significant performance improvements if we compare CEGIO-F to CEGIO-G for convex function benchmarks, i.e., CEGIO-F algorithm is 1000 times faster using the SMT solver Boolector and 750 times faster using the SMT solver Z3 than the (original) CEGIO-G algorithm, as shown in Table 4."}, {"heading": "7.3.4. Comparison to Other Traditional Techniques", "text": "In this section, our CEGIO algorithms are compared to other traditional optimization techniques: genetic algorithm (GA), particle swarm (ParSwarm), pattern search (PatSearch), simulated annealing (SA), and nonlinear programming (NLP).\nTable 5 describes the hit rates and the mean time for each function w.r.t. our proposal (ESBMC) and other existing techniques (GA, ParSwarm, PatSearch, SA, and NLP). An identification for each algorithm is defined: (1) Generic, (2) Simplified, and (3) Fast. All traditional optimization techniques are executed 20 times using MATLAB, for obtaining the correctness rate and the mean time for each function. Our hit rate is omitted for the sake of space, but our algorithms have found the correct global minima in 100% of the experiments. The experiments show that our hit rate is superior than any other optimization technique, although the optimization time is usually longer.\nThe other optimization techniques are very sensitive to non-convexity; for this reason, they are usually trapped by local minima. The other optimization techniques presented better performance in convex functions. Specifically, they converge faster to the response and there are no local minimums that could lead to incorrect results, whereas with the non-convex functions, their hit rate is lower, precisely because there are local minimums."}, {"heading": "8. Conclusions", "text": "This paper presented three variants of a counterexample-guided inductive optimization approach for optimizing a wide range of functions based on counterexamples extracted from SMT solvers. In particular, this work proposed algorithms to perform inductive generalization based on counterexamples provided by a verification oracle for optimizing convex and non-convex functions and also presented respective proofs for global convergence. Fur-\nthermore, the present study provided an analysis about the influence of the solver and data-types in the performance of the proposed algorithms.\nAll proposed algorithms were exhaustively evaluated using a large set of public available benchmarks. We also evaluated the present algorithms performance using different SMT solvers and compared them to other state-of-art optimization techniques (genetic algorithm, particle swarm, pattern search, nonlinear programming, and simulated annealing). The counterexample-guided inductive optimization algorithms are able to find the global optima in 100% of the benchmarks, and the optimization time is significantly reduced if compared to Ara\u00fajo et al. [13]. Traditional optimization techniques are typically trapped by local minima and are unable to ensure the global optimization, although they still present lower optimization times than the proposed algorithms. In contrast to previous optimization techniques, the present approaches are suitable for every class of functions; they are also complete, providing an improved accuracy compared to other existing traditional techniques. Future studies include the application of the present approach to autonomous vehicles navigation systems, enhancements in the model-checking procedure for reducing the verification time by means of multi-core verification [25] and invariant generation [58, 64]. We also intend to improve Alg. 2 by implementing a dynamic learning rate since it is currently fixed in the proposed algorithm. Finally, we intend to extend all present approaches for multi-objective optimization problems."}], "references": [{"title": "Optimization for Engineering Design: Algorithms and Examples", "author": ["K. Deb"], "venue": "Prentice-Hall of India", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2004}, {"title": "Curricular value and instructional needs for infusing engineering design into k-12 technology education", "author": ["D.K. Gattie", "R.C. Wicklein"], "venue": "Journal of Technology Education 19 (1) ", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2007}, {"title": "Computer science and game theory", "author": ["Y. Shoham"], "venue": "Commun. ACM 51 (8) ", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2008}, {"title": "Hardware/software codesign: The past", "author": ["J. Teich"], "venue": "the present, and predicting the future, Proceedings of the IEEE 100 (Special Centennial Issue) ", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2012}, {"title": "Selected Topics in Approximation and Computation", "author": ["M. Kowalski", "C. Sikorski", "F. Stenger"], "venue": "Oxford University Press", "citeRegEx": "5", "shortCiteRegEx": null, "year": 1995}, {"title": "Optimization and Operations Research \u2013 Volume I", "author": ["U. Derigs"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2009}, {"title": "Integer programming", "author": ["R. Garfinkel", "G. Nemhauser"], "venue": "Series in decision and control, Wiley", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1972}, {"title": "The Steepest Descent Method", "author": ["M. Bartholomew-Biggs"], "venue": "Springer US, Boston, MA", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2008}, {"title": "Genetic Algorithms in Search", "author": ["D. Goldberg"], "venue": "Optimization, and Machine Learning, Artificial Intelligence, Addison-Wesley Publishing Company", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1989}, {"title": "Optimization Methods: From Theory to Design Scientific and Technological Aspects in Mechanics", "author": ["M. Cavazzuti"], "venue": "Springer Berlin Heidelberg", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Syntax-guided synthesis", "author": ["R. Alur", "R. Bodik", "G. Juniwal", "M.M.K. Martin", "M. Raghothaman", "S.A. Seshia", "R. Singh", "A. Solar-Lezama", "E. Torlak", "A. Udupa"], "venue": "in: 2013 Formal Methods in Computer-Aided Design", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Ant colony optimization", "author": ["M. Dorigo", "M. Birattari", "T. Stutzle"], "venue": "IEEE Computat. Intell. Mag. 1 (4) ", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "SMt-based verification applied to non-convex optimization problems", "author": ["R. Ara\u00fajo", "I. Bessa", "L. Cordeiro", "J.E.C. Filho"], "venue": "in: Proceedings of VI Brazilian Symposium on Computing Systems Engineering", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2016}, {"title": "Z3: An efficient SMT solver", "author": ["L. De Moura", "N. Bj\u00f8rner"], "venue": "in: TACAS, Springer-Verlag, Berlin, Heidelberg", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2008}, {"title": "Boolector: An Efficient SMT Solver for Bit- Vectors and Arrays", "author": ["R. Brummayer", "A. Biere"], "venue": "in: Tools and Algorithms for the Construction and Analysis of Systems (TACAS)", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2009}, {"title": "The mathSAT5 SMT solver", "author": ["A. Cimatti", "A. Griggio", "B. Schaafsma", "R. Sebastiani"], "venue": "in: Tools and Algorithms for the Construction and Analysis of Systems", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2013}, {"title": "A literature survey of benchmark functions for global optimisation problems", "author": ["M. Jamil", "X.-S. Yang"], "venue": "IJMMNO 4 (2) ", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2013}, {"title": "Particle Swarm Optimization: Theory", "author": ["A. Olsson"], "venue": "Techniques and Applications, Engineering tools, techniques and tables, Nova Science Publishers", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2011}, {"title": "Pattern search methods for user-provided points: Application to molecular geometry problems", "author": ["P. Alberto", "F. Nogueira", "H. Rocha", "L.N. Vicente"], "venue": "SIAM Journal on Optimization 14 (4) ", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2004}, {"title": "E", "author": ["P.J.M. Laarhoven"], "venue": "H. L. Aarts (Eds.), Simulated Annealing: Theory and Applications, Kluwer Academic Publishers, Norwell, MA, USA", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1987}, {"title": "A trust region method based on interior point techniques for nonlinear programming", "author": ["R.H. Byrd", "J.C. Gilbert", "J. Nocedal"], "venue": "Mathematical Programming 89 (1) ", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2000}, {"title": "On SATModulo Theories and Optimization Problems", "author": ["R. Nieuwenhuis", "A. Oliveras"], "venue": "Springer Berlin Heidelberg, Berlin, Heidelberg", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2006}, {"title": "An SMT based method for optimizing arithmetic computations in embedded software code", "author": ["H. Eldib", "C. Wang"], "venue": "IEEE CAD 33 (11) ", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2014}, {"title": "A note on designing logical circuits using SAT", "author": ["G.G. Estrada"], "venue": "in: ICES, Springer Berlin Heidelberg", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2003}, {"title": "Applying multi-core model checking to hardware-software partitioning in embedded systems", "author": ["A. Trindade", "H. Ismail", "L. Cordeiro"], "venue": "in: SBESC", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2015}, {"title": "L", "author": ["A. Trindade"], "venue": "Cordeiro, Aplicando verifica\u00e7\u00e3o de modelos para o particionamento de hardware/softw in: SBESC", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2014}, {"title": "Applying SMT-based verification to hardware/software partitioning in embedded systems", "author": ["A. Trindade", "L. Cordeiro"], "venue": "DES AUTOM EMBED SYST 20 (1) ", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2016}, {"title": "Multi-criteria optimization for mapping programs to multi-processors", "author": ["S. Cotton", "O. Maler", "J. Legriel", "S. Saidi"], "venue": "in: SIES", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2011}, {"title": "Scalable lazy SMT-based motion planning", "author": ["Y. Shoukry", "P. Nuzzo", "I. Saha", "A.L. Sangiovanni-Vincentelli", "S.A. Seshia", "G.J. Pappas", "P. Tabuada"], "venue": "in: 55th IEEE Conference on Decision and Control, CDC 2016, Las Vegas, NV, USA, December 12-14, 2016", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2016}, {"title": "Tool-support for the analysis of hybrid systems and models", "author": ["M. Pister", "M. Tautschnig", "A. Bauer"], "venue": "2007 10th Design, Automation and Test in Europe Conference and Exhibition 00 ", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2007}, {"title": "CalCS: SMT solving for non-linear convex constraints", "author": ["P. Nuzzo", "A.A.A. Puggelli", "S.A. Seshia", "A.L. Sangiovanni-Vincentelli"], "venue": "Tech. Rep. UCB/EECS-2010-100, EECS Department, University of California, Berkeley ", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2010}, {"title": "SMC: Satisfiability modulo convex optimization", "author": ["Y. Shoukry", "P. Nuzzo", "A.L. Sangiovanni-Vincentelli", "S.A. Seshia", "G.J. Pappas", "P. Tabuada"], "venue": "in: Proceedings of the 20th ACM International Conference on Hybrid Systems: Computation and Control, HSCC \u201917, ACM, New York, NY, USA", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2017}, {"title": "\u03bdZ - an optimizing SMT solver", "author": ["N. Bj\u00f8rner", "A.-D. Phan", "L. Fleckenstein"], "venue": "in: TACAS, Springer Berlin Heidelberg", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2015}, {"title": "Symbolic optimization with SMT solvers", "author": ["Y. Li", "A. Albarghouthi", "Z. Kincaid", "A. Gurfinkel", "M. Chechik"], "venue": "in: Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL \u201914, ACM, New York, NY, USA", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2014}, {"title": "OptiMathSAT: A tool for optimization modulo theories", "author": ["R. Sebastiani", "P. Trentin"], "venue": "in: CAV, Springer International Publishing", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2015}, {"title": "Optimization modulo theories with linear rational costs", "author": ["R. Sebastiani", "S. Tomasi"], "venue": "ACM TOCL 16 (2) ", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2015}, {"title": "Pushing the envelope of optimization modulo theories with linear-arithmetic cost functions", "author": ["R. Sebastiani", "P. Trentin"], "venue": "in: TACAS, Springer Berlin Heidelberg", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2015}, {"title": "Practical SMT-based type error localization", "author": ["Z. Pavlinovic", "T. King", "T. Wies"], "venue": "in: ICFP", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2015}, {"title": "Problem-method classification in optimization and control", "author": ["E.A. Galperin"], "venue": "Computers & Mathematics with Applications 21 (6?7) ", "citeRegEx": "39", "shortCiteRegEx": null, "year": 1221}, {"title": "Deterministic Global Optimization", "author": ["C. Floudas"], "venue": "Nonconvex Optimization and Its Applications, Springer", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2000}, {"title": "Practical Mathematical Optimization: An Introduction to Basic Optimization Theory and Classical and New Gradient-Based Algorithms", "author": ["J. Snyman"], "venue": "Applied Optimization, Springer", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2005}, {"title": "Deterministic Global Optimization: Geometric Branch-andbound Methods and their Applications", "author": ["D. Scholz"], "venue": "Springer Optimization and Its Applications, Springer New York", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2011}, {"title": "Pattern search for optimization", "author": ["N.V. Findler", "C. Lo", "R. Lo"], "venue": "Mathematics and Computers in Simulation 29 (1) ", "citeRegEx": "43", "shortCiteRegEx": null, "year": 1016}, {"title": "Stochastic Optimization Methods", "author": ["K. Marti"], "venue": "Springer", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2005}, {"title": "dReal: An SMT Solver for Nonlinear Theories over the Reals", "author": ["S. Gao", "S. Kong", "E.M. Clarke"], "venue": "Springer Berlin Heidelberg, Berlin, Heidelberg", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2013}, {"title": "Principles of Model Checking (Representation and Mind Series)", "author": ["C. Baier", "J.-P. Katoen"], "venue": "The MIT Press", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2008}, {"title": "Reliable and Reproducible Competition Results with BenchExec and Witnesses (Report on SV-COMP 2016)", "author": ["D. Beyer"], "venue": "Springer Berlin Heidelberg", "citeRegEx": "48", "shortCiteRegEx": null, "year": 2016}, {"title": "Bounded model checking", "author": ["A. Biere"], "venue": "in: Handbook of Satisfiability, IOS Press", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2009}, {"title": "Satisfiability modulo theories", "author": ["C.W. Barrett", "R. Sebastiani", "S.A. Seshia", "C. Tinelli"], "venue": "in: Handbook of Satisfiability, IOS Press", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2009}, {"title": "SMT-based bounded model checking for embedded ANSI-C software", "author": ["L. Cordeiro", "B. Fischer", "J. Marques-Silva"], "venue": "IEEE TSE 38 (4) ", "citeRegEx": "51", "shortCiteRegEx": null, "year": 2012}, {"title": "M", "author": ["D. Kroening"], "venue": "Tautschnig, CBMC \u2013 c bounded model checker ", "citeRegEx": "52", "shortCiteRegEx": null, "year": 2014}, {"title": "B", "author": ["J. Morse", "M. Ramalho", "L. Cordeiro", "D. Nicole"], "venue": "Fischer, ESBMC 1.22 - (competition contribution), in: TACAS", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2014}, {"title": "B", "author": ["B.R. Abreu", "Y.M.R. Gadelha", "C.L. Cordeiro"], "venue": "E. de Lima Filho, S. W. da Silva, Bounded model checking for fixed-point digital filters, JBCS 22 (1) ", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2016}, {"title": "Verification of fixed-point digital controllers using direct and delta forms realizations", "author": ["I.V. Bessa", "H.I. Ismail", "L.C. Cordeiro", "J.E.C. Filho"], "venue": "DES AUTOM EMBED SYST 20 (2) ", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2016}, {"title": "Verification of Delta Form Realization in Fixed-Point Digital Controllers Using Bounded Model Checking", "author": ["I. Bessa", "H. Ibrahim", "L. Cordeiro", "J.E. Filho"], "venue": "in: SBESC", "citeRegEx": "56", "shortCiteRegEx": null, "year": 2014}, {"title": "CPAchecker: A tool for configurable software verification", "author": ["D. Beyer", "M.E. Keremoglu"], "venue": "in: CAV, Springer Berlin Heidelberg", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2011}, {"title": "Handling loops in bounded model checking of C programs via k-induction", "author": ["M.Y.R. Gadelha", "H.I. Ismail", "L.C. Cordeiro"], "venue": "STTT 19 (1) ", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2017}, {"title": "Selected Applications of Convex Optimization", "author": ["L. Li"], "venue": "Springer Optimization and Its Applications, Springer Berlin Heidelberg", "citeRegEx": "59", "shortCiteRegEx": null, "year": 2015}, {"title": "Convex Optimization", "author": ["S. Boyd", "L. Vandenberghe"], "venue": "Cambridge University Press, New York, NY, USA", "citeRegEx": "60", "shortCiteRegEx": null, "year": 2004}, {"title": "Verifying CUDA programs using SMT-based context-bounded model checking", "author": ["P. Pereira", "H. Albuquerque", "H. Marques", "I. Silva", "C. Carvalho", "L. Cordeiro", "V. Santos", "R. Ferreira"], "venue": "in: Proceedings of the 31st Annual ACM Symposium on Applied Computing, SAC \u201916, ACM, New York, NY, USA", "citeRegEx": "61", "shortCiteRegEx": null, "year": 2016}, {"title": "Model checking embedded c software using k-induction and invariants", "author": ["H. Rocha", "H. Ismail", "L. Cordeiro", "R. Barreto"], "venue": "in: Proceedings of VI Brazilian Symposium on Computing Systems Engineering", "citeRegEx": "64", "shortCiteRegEx": null, "year": 2015}], "referenceMentions": [{"referenceID": 0, "context": "Optimization is an important research topic in many fields, especially in computer science and engineering [1].", "startOffset": 107, "endOffset": 110}, {"referenceID": 1, "context": "Optimization characterizes and distinguishes the engineering gaze over a problem; for this particular reason, previous studies showed that optimization is one of the main differences between engineering design and technological design [2].", "startOffset": 235, "endOffset": 238}, {"referenceID": 2, "context": ", game theory [3]), resource allocation problems (e.", "startOffset": 14, "endOffset": 17}, {"referenceID": 3, "context": ", hardware/software co-design [4]), and computational estimation and approximation (e.", "startOffset": 30, "endOffset": 33}, {"referenceID": 4, "context": ", numerical analysis [5]) represent", "startOffset": 21, "endOffset": 24}, {"referenceID": 5, "context": "Conversely, computer science plays an important role in recent optimization studies, developing efficient algorithms and providing respective tools for supporting model management and results analysis [6].", "startOffset": 201, "endOffset": 204}, {"referenceID": 6, "context": ", simplex [7], gradient descent [8], and genetic algorithms [9]), which are suitable for different classes of optimization problems (e.", "startOffset": 10, "endOffset": 13}, {"referenceID": 7, "context": ", simplex [7], gradient descent [8], and genetic algorithms [9]), which are suitable for different classes of optimization problems (e.", "startOffset": 32, "endOffset": 35}, {"referenceID": 8, "context": ", simplex [7], gradient descent [8], and genetic algorithms [9]), which are suitable for different classes of optimization problems (e.", "startOffset": 60, "endOffset": 63}, {"referenceID": 9, "context": ", gradients and Hessians [10].", "startOffset": 25, "endOffset": 29}, {"referenceID": 9, "context": "Stochastic optimization employs randomness in the optima search procedure [10].", "startOffset": 74, "endOffset": 78}, {"referenceID": 10, "context": "This class of techniques is defined here as counterexample guided inductive optimization (CEGIO), which is inspired by the syntax-guided synthesis (SyGuS) to perform inductive generalization based on counterexamples provided by a verification oracle [11].", "startOffset": 250, "endOffset": 254}, {"referenceID": 0, "context": ", NewtonRaphson [1] and Gradient Descent [8]) are inefficient to solve that specific class of problems [1].", "startOffset": 16, "endOffset": 19}, {"referenceID": 7, "context": ", NewtonRaphson [1] and Gradient Descent [8]) are inefficient to solve that specific class of problems [1].", "startOffset": 41, "endOffset": 44}, {"referenceID": 0, "context": ", NewtonRaphson [1] and Gradient Descent [8]) are inefficient to solve that specific class of problems [1].", "startOffset": 103, "endOffset": 106}, {"referenceID": 11, "context": ", ant colony [12] and genetic algorithms [9]) offer faster solutions for complex problems, but they sacrifice the system\u2019s correctness and are easily trapped by local optimal solutions.", "startOffset": 13, "endOffset": 17}, {"referenceID": 8, "context": ", ant colony [12] and genetic algorithms [9]) offer faster solutions for complex problems, but they sacrifice the system\u2019s correctness and are easily trapped by local optimal solutions.", "startOffset": 41, "endOffset": 44}, {"referenceID": 12, "context": "[13] and presents three variants of a counterexample guided inductive optimization approach based on SMT solvers, which improve the technique performance for specific class of functions.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13].", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13]) for the proposed counterexample guided inductive optimization algorithms.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "The experiments are performed with three different SMT solvers: Z3 [14], Boolector [15], and MathSAT [16].", "startOffset": 67, "endOffset": 71}, {"referenceID": 14, "context": "The experiments are performed with three different SMT solvers: Z3 [14], Boolector [15], and MathSAT [16].", "startOffset": 83, "endOffset": 87}, {"referenceID": 15, "context": "The experiments are performed with three different SMT solvers: Z3 [14], Boolector [15], and MathSAT [16].", "startOffset": 101, "endOffset": 105}, {"referenceID": 16, "context": "The benchmark suite is expanded to 30 optimization functions extracted from the literature [17].", "startOffset": 91, "endOffset": 95}, {"referenceID": 8, "context": "The proposed technique is compared to genetic algorithm [9], particle swarm [18], pattern search [19], simulated annealing [20], and nonlinear programming [21], which are traditional optimization techniques employed for non-convex functions.", "startOffset": 56, "endOffset": 59}, {"referenceID": 17, "context": "The proposed technique is compared to genetic algorithm [9], particle swarm [18], pattern search [19], simulated annealing [20], and nonlinear programming [21], which are traditional optimization techniques employed for non-convex functions.", "startOffset": 76, "endOffset": 80}, {"referenceID": 18, "context": "The proposed technique is compared to genetic algorithm [9], particle swarm [18], pattern search [19], simulated annealing [20], and nonlinear programming [21], which are traditional optimization techniques employed for non-convex functions.", "startOffset": 97, "endOffset": 101}, {"referenceID": 19, "context": "The proposed technique is compared to genetic algorithm [9], particle swarm [18], pattern search [19], simulated annealing [20], and nonlinear programming [21], which are traditional optimization techniques employed for non-convex functions.", "startOffset": 123, "endOffset": 127}, {"referenceID": 20, "context": "The proposed technique is compared to genetic algorithm [9], particle swarm [18], pattern search [19], simulated annealing [20], and nonlinear programming [21], which are traditional optimization techniques employed for non-convex functions.", "startOffset": 155, "endOffset": 159}, {"referenceID": 21, "context": "Nieuwenhuis and Oliveras [22] presented the first research about the application of SMT to solve optimization problems.", "startOffset": 25, "endOffset": 29}, {"referenceID": 22, "context": ", minimize errors in linear fixed-point arithmetic computations in embedded control software [23]; reduce the number of gates in FPGA digital circuits [24]; hardware/software partition in embedded systems to decide the most efficient system implementation [25\u201327]; and schedule applications for a multi-processor platform [28].", "startOffset": 93, "endOffset": 97}, {"referenceID": 23, "context": ", minimize errors in linear fixed-point arithmetic computations in embedded control software [23]; reduce the number of gates in FPGA digital circuits [24]; hardware/software partition in embedded systems to decide the most efficient system implementation [25\u201327]; and schedule applications for a multi-processor platform [28].", "startOffset": 151, "endOffset": 155}, {"referenceID": 24, "context": ", minimize errors in linear fixed-point arithmetic computations in embedded control software [23]; reduce the number of gates in FPGA digital circuits [24]; hardware/software partition in embedded systems to decide the most efficient system implementation [25\u201327]; and schedule applications for a multi-processor platform [28].", "startOffset": 256, "endOffset": 263}, {"referenceID": 25, "context": ", minimize errors in linear fixed-point arithmetic computations in embedded control software [23]; reduce the number of gates in FPGA digital circuits [24]; hardware/software partition in embedded systems to decide the most efficient system implementation [25\u201327]; and schedule applications for a multi-processor platform [28].", "startOffset": 256, "endOffset": 263}, {"referenceID": 26, "context": ", minimize errors in linear fixed-point arithmetic computations in embedded control software [23]; reduce the number of gates in FPGA digital circuits [24]; hardware/software partition in embedded systems to decide the most efficient system implementation [25\u201327]; and schedule applications for a multi-processor platform [28].", "startOffset": 256, "endOffset": 263}, {"referenceID": 27, "context": ", minimize errors in linear fixed-point arithmetic computations in embedded control software [23]; reduce the number of gates in FPGA digital circuits [24]; hardware/software partition in embedded systems to decide the most efficient system implementation [25\u201327]; and schedule applications for a multi-processor platform [28].", "startOffset": 322, "endOffset": 326}, {"referenceID": 27, "context": "[28] the problem is formulated as a multi-objective optimization problem.", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "[29] proposed a scalable solution for synthesizing a digital controller and motion planning for under-actuated robots from LTL specifications.", "startOffset": 0, "endOffset": 4}, {"referenceID": 29, "context": ", the ABsolver [30], which is used for automatic analysis and verification of hybrid-system and control-system.", "startOffset": 15, "endOffset": 19}, {"referenceID": 30, "context": "Similarly, CalCs [31] is also an SMT solver that combines convex optimization and lazy SMT to determine the satisfiability of conjunctions of convex non-linear constraints.", "startOffset": 17, "endOffset": 21}, {"referenceID": 31, "context": "[32] show that a particular class of logic formulas (named SMC formulas) generalizes a wide range of formulas over Boolean and nonlinear real arithmetic, and propose the Satisfiability Modulo Convex Optimization to solve satisfiability problems over SMC formulas.", "startOffset": 0, "endOffset": 4}, {"referenceID": 29, "context": "Our work differs from those previous studies [30\u201332] since it does not focus on speeding up SMT solvers, but it employs an SMT-based model-checking tool to guide (via counterexample) an optimization search procedure in order to ensure the global optimization.", "startOffset": 45, "endOffset": 52}, {"referenceID": 30, "context": "Our work differs from those previous studies [30\u201332] since it does not focus on speeding up SMT solvers, but it employs an SMT-based model-checking tool to guide (via counterexample) an optimization search procedure in order to ensure the global optimization.", "startOffset": 45, "endOffset": 52}, {"referenceID": 31, "context": "Our work differs from those previous studies [30\u201332] since it does not focus on speeding up SMT solvers, but it employs an SMT-based model-checking tool to guide (via counterexample) an optimization search procedure in order to ensure the global optimization.", "startOffset": 45, "endOffset": 52}, {"referenceID": 32, "context": "Recently, \u03bdZ [33] extends the SMT solver Z3 for linear optimization problems; Li et al.", "startOffset": 13, "endOffset": 17}, {"referenceID": 33, "context": "proposed the SYMBA algorithm [34], which is an SMT-based symbolic optimization algorithm that uses the theory of linear real arithmetic and SMT solver as black box.", "startOffset": 29, "endOffset": 33}, {"referenceID": 34, "context": "Sebastiani and Trentin [35] present OptiMathSat, which is an optimization tool that extends MathSAT5 SMT solver to allow solving linear functions in the Boolean, rational, and integer domains or a combination of them; in Sebastiani and Tomasi [36], the authors used a combination of SMT and LP techniques to minimize rational functions; the related work [37] extends their work with linear arithmetic on the mixed integer/rational domain, thus combining SMT, LP, and ILP techniques.", "startOffset": 23, "endOffset": 27}, {"referenceID": 35, "context": "Sebastiani and Trentin [35] present OptiMathSat, which is an optimization tool that extends MathSAT5 SMT solver to allow solving linear functions in the Boolean, rational, and integer domains or a combination of them; in Sebastiani and Tomasi [36], the authors used a combination of SMT and LP techniques to minimize rational functions; the related work [37] extends their work with linear arithmetic on the mixed integer/rational domain, thus combining SMT, LP, and ILP techniques.", "startOffset": 243, "endOffset": 247}, {"referenceID": 36, "context": "Sebastiani and Trentin [35] present OptiMathSat, which is an optimization tool that extends MathSAT5 SMT solver to allow solving linear functions in the Boolean, rational, and integer domains or a combination of them; in Sebastiani and Tomasi [36], the authors used a combination of SMT and LP techniques to minimize rational functions; the related work [37] extends their work with linear arithmetic on the mixed integer/rational domain, thus combining SMT, LP, and ILP techniques.", "startOffset": 354, "endOffset": 358}, {"referenceID": 37, "context": "[38] propose an approach which considers all possible compiler error sources for statically typed functional programming languages and reports the most useful one subject to some usefulness criterion.", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "Only a few studies [29] are able to solve non-linear problems, but they are also constrained to convex functions.", "startOffset": 19, "endOffset": 23}, {"referenceID": 38, "context": "Depending on the cost function nature, the optimization problem can be hard to solve, given the time and memory resources [39].", "startOffset": 122, "endOffset": 126}, {"referenceID": 39, "context": "The deterministic techniques employ a search engine, where each step is directly and deterministically related to the previous steps [40].", "startOffset": 133, "endOffset": 137}, {"referenceID": 40, "context": ", gradient-descent [41] and Newton\u2019s optimization [1].", "startOffset": 19, "endOffset": 23}, {"referenceID": 0, "context": ", gradient-descent [41] and Newton\u2019s optimization [1].", "startOffset": 50, "endOffset": 53}, {"referenceID": 41, "context": ", dynamic programming, branch and bound [42], and pattern search [43].", "startOffset": 40, "endOffset": 44}, {"referenceID": 42, "context": ", dynamic programming, branch and bound [42], and pattern search [43].", "startOffset": 65, "endOffset": 69}, {"referenceID": 43, "context": "Stochastic techniques employ randomness to avoid the local minima and to ensure the global optimization; such techniques are usually based on metaheuristics [44].", "startOffset": 157, "endOffset": 161}, {"referenceID": 19, "context": "Among those stochastic techniques, simulated annealing [20], particle swarm [18], and evolutionary algorithms (e.", "startOffset": 55, "endOffset": 59}, {"referenceID": 17, "context": "Among those stochastic techniques, simulated annealing [20], particle swarm [18], and evolutionary algorithms (e.", "startOffset": 76, "endOffset": 80}, {"referenceID": 8, "context": ", genetic algorithms [9]) are usually employed in practice.", "startOffset": 21, "endOffset": 24}, {"referenceID": 30, "context": "Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space.", "startOffset": 144, "endOffset": 163}, {"referenceID": 32, "context": "Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space.", "startOffset": 144, "endOffset": 163}, {"referenceID": 33, "context": "Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space.", "startOffset": 144, "endOffset": 163}, {"referenceID": 34, "context": "Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space.", "startOffset": 144, "endOffset": 163}, {"referenceID": 35, "context": "Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space.", "startOffset": 144, "endOffset": 163}, {"referenceID": 36, "context": "Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space.", "startOffset": 144, "endOffset": 163}, {"referenceID": 44, "context": "Recently, optimization techniques and tools that employ SMT solvers and non-deterministic variables were applied to solve optimization problems [29\u2013 31, 33\u201337, 45], which searches for the global optima in a search-space that is symbolically defined and uses counterexamples produced by SMT solvers to further constrain the search-space.", "startOffset": 144, "endOffset": 163}, {"referenceID": 45, "context": "The modeling step usually requires the use of an abstraction to eliminate irrelevant (or less) important system details [47].", "startOffset": 120, "endOffset": 124}, {"referenceID": 46, "context": "BMC is an important verification technique, which has presented attractive results over the last years [48].", "startOffset": 103, "endOffset": 107}, {"referenceID": 47, "context": "BMC techniques based on Boolean Satisfiability (SAT) [49] or Satisfiability Modulo Theories (SMT) [50] have been successfully applied to verify single- and multi-threaded programs, and also to find subtle bugs in real programs [51, 52].", "startOffset": 53, "endOffset": 57}, {"referenceID": 48, "context": "BMC techniques based on Boolean Satisfiability (SAT) [49] or Satisfiability Modulo Theories (SMT) [50] have been successfully applied to verify single- and multi-threaded programs, and also to find subtle bugs in real programs [51, 52].", "startOffset": 98, "endOffset": 102}, {"referenceID": 49, "context": "BMC techniques based on Boolean Satisfiability (SAT) [49] or Satisfiability Modulo Theories (SMT) [50] have been successfully applied to verify single- and multi-threaded programs, and also to find subtle bugs in real programs [51, 52].", "startOffset": 227, "endOffset": 235}, {"referenceID": 50, "context": "BMC techniques based on Boolean Satisfiability (SAT) [49] or Satisfiability Modulo Theories (SMT) [50] have been successfully applied to verify single- and multi-threaded programs, and also to find subtle bugs in real programs [51, 52].", "startOffset": 227, "endOffset": 235}, {"referenceID": 47, "context": "[49] \u2013 Given a transition system M, a property \u03c6, and a bound k; BMC unrolls the system k times and translates it into a verification condition (VC) \u03c8, which is satisfiable iff \u03c6 has a counterexample of depth less than or equal to k.", "startOffset": 0, "endOffset": 4}, {"referenceID": 51, "context": "In this study, the ESBMC tool [53] is used as verification engine, as it represents one of the most efficient BMC tools that participated in the last software verification competitions [48].", "startOffset": 30, "endOffset": 34}, {"referenceID": 46, "context": "In this study, the ESBMC tool [53] is used as verification engine, as it represents one of the most efficient BMC tools that participated in the last software verification competitions [48].", "startOffset": 185, "endOffset": 189}, {"referenceID": 52, "context": "In addition to software verification, ESBMC has been applied to ensure correctness of digital filters and controllers [54\u201356].", "startOffset": 118, "endOffset": 125}, {"referenceID": 53, "context": "In addition to software verification, ESBMC has been applied to ensure correctness of digital filters and controllers [54\u201356].", "startOffset": 118, "endOffset": 125}, {"referenceID": 54, "context": "In addition to software verification, ESBMC has been applied to ensure correctness of digital filters and controllers [54\u201356].", "startOffset": 118, "endOffset": 125}, {"referenceID": 24, "context": "Recently, ESBMC has been applied to optimize HW/SW co-design [25\u201327].", "startOffset": 61, "endOffset": 68}, {"referenceID": 25, "context": "Recently, ESBMC has been applied to optimize HW/SW co-design [25\u201327].", "startOffset": 61, "endOffset": 68}, {"referenceID": 26, "context": "Recently, ESBMC has been applied to optimize HW/SW co-design [25\u201327].", "startOffset": 61, "endOffset": 68}, {"referenceID": 50, "context": ", CBMC [52], CPAChecker [57], and ESBMC [53]) can be applied to check specific constraints in optimization problems, as described by Eq.", "startOffset": 7, "endOffset": 11}, {"referenceID": 55, "context": ", CBMC [52], CPAChecker [57], and ESBMC [53]) can be applied to check specific constraints in optimization problems, as described by Eq.", "startOffset": 24, "endOffset": 28}, {"referenceID": 51, "context": ", CBMC [52], CPAChecker [57], and ESBMC [53]) can be applied to check specific constraints in optimization problems, as described by Eq.", "startOffset": 40, "endOffset": 44}, {"referenceID": 56, "context": "Definitions 1 and 2) since our optimization problems are represented by loop-free programs [58].", "startOffset": 91, "endOffset": 95}, {"referenceID": 16, "context": "The Ursem03\u2019s function is employed to illustrate the present SMT-based optimization method for non-convex optimization problems [17].", "startOffset": 128, "endOffset": 132}, {"referenceID": 16, "context": "The boundaries are chosen based on Jamil and Yang [17], which define the domain in which the optimization algorithms can evaluate the benchmark functions.", "startOffset": 50, "endOffset": 54}, {"referenceID": 12, "context": "[13] is able to find the global optima for any optimization problem that can be modeled with the methodology presented in Section 4.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13]; this algorithm is denoted here as \u201dGeneralized CEGIO algorithm\u201d (CEGIO-G).", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13].", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "2 contains three nested loops after the variable initialization and declaration (lines 1-4), which is similar to the algorithm presented in [13].", "startOffset": 140, "endOffset": 144}, {"referenceID": 57, "context": "Convex functions are an important class of functions commonly found in many areas of mathematics, physics, and engineering [59].", "startOffset": 123, "endOffset": 127}, {"referenceID": 58, "context": "A local minimum of a convex function f , on a convex subset, is always a global minimum of f [60].", "startOffset": 93, "endOffset": 97}, {"referenceID": 26, "context": "This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.", "startOffset": 36, "endOffset": 52}, {"referenceID": 52, "context": "This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.", "startOffset": 36, "endOffset": 52}, {"referenceID": 53, "context": "This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.", "startOffset": 36, "endOffset": 52}, {"referenceID": 59, "context": "This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.", "startOffset": 36, "endOffset": 52}, {"referenceID": 14, "context": "This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.", "startOffset": 153, "endOffset": 157}, {"referenceID": 13, "context": "This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.", "startOffset": 162, "endOffset": 166}, {"referenceID": 15, "context": "This is observed in several studies [27, 54, 55, 61]; as a result, our evaluation here is also carried out using different SMT solvers such as Boolector [15], Z3 [14], and MathSAT [16], in order to check whether a particular solver heavily influences the performance of the CEGIO algorithms.", "startOffset": 180, "endOffset": 184}, {"referenceID": 12, "context": "[13].", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "Future studies include the application of the present approach to autonomous vehicles navigation systems, enhancements in the model-checking procedure for reducing the verification time by means of multi-core verification [25] and invariant generation [58, 64].", "startOffset": 222, "endOffset": 226}, {"referenceID": 56, "context": "Future studies include the application of the present approach to autonomous vehicles navigation systems, enhancements in the model-checking procedure for reducing the verification time by means of multi-core verification [25] and invariant generation [58, 64].", "startOffset": 252, "endOffset": 260}, {"referenceID": 60, "context": "Future studies include the application of the present approach to autonomous vehicles navigation systems, enhancements in the model-checking procedure for reducing the verification time by means of multi-core verification [25] and invariant generation [58, 64].", "startOffset": 252, "endOffset": 260}], "year": 2017, "abstractText": "This paper describes three variants of a counterexample guided inductive optimization (CEGIO) approach based on Satisfiability Modulo Theories (SMT) solvers. In particular, CEGIO relies on iterative executions to constrain a verification procedure, in order to perform inductive generalization, based on counterexamples extracted from SMT solvers. CEGIO is able to successfully optimize a wide range of functions, including non-linear and non-convex optimization problems based on SMT solvers, in which data provided by counterexamples are employed to guide the verification engine, thus reducing the optimization domain. The present algorithms are evaluated using a large set of benchmarks typically employed for evaluating optimization techniques. Experimental results show the efficiency and effectiveness of the proposed algorithms, which find the optimal solution in all evaluated benchmarks, while traditional techniques are usually trapped by local minima.", "creator": "LaTeX with hyperref package"}}}