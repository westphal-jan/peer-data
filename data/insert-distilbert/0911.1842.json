{"id": "0911.1842", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Nov-2009", "title": "Standards for Language Resources", "abstract": "roughly the goal of this paper is two - fold : to present perhaps an abstract data model for linguistic annotations and its implementation models using xml, rdf and related computational standards ; and to outline the work of a newly formed committee of consortium the international standards organization ( iso ), iso / tc 37 / sc 4 language use resource development management, which will use this work as its starting point.", "histories": [["v1", "Tue, 10 Nov 2009 07:12:03 GMT  (66kb)", "http://arxiv.org/abs/0911.1842v1", "Colloque avec actes et comit\\'e de lecture. internationale"]], "COMMENTS": "Colloque avec actes et comit\\'e de lecture. internationale", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["nancy ide", "laurent romary"], "accepted": false, "id": "0911.1842"}, "pdf": {"name": "0911.1842.pdf", "metadata": {"source": "CRF", "title": "Standards for Language Resources", "authors": [], "emails": ["ide@cs.vassar.edu", "romary@loria.fr"], "sections": [{"heading": null, "text": "Introduction The goal of this paper is two-fold: to present an abstract data model for linguistic annotations and its implementation using XML, RDF and related standards; and to outline the work of a newly formed committee of the International Standards Organization (ISO), ISO/TC 37/SC 4 Language Resource Management, which will use this work as its starting point. The primary motive for presenting the latter is to solicit the participation of members of the research community to contribute to the work of the committee. The objective of ISO/TC 37/SC 4 is to prepare international standards and guidelines for effective language resource management in applications in the multilingual information society. To this end, the committee will develop principles and methods for creating, coding, processing and managing language resources, such as written corpora, lexical corpora, speech corpora, dictionary compiling and classification\nschemes. The focus of the work is on data modeling, markup, data exchange and the evaluation of language resources other than terminologies (which have already been treated in ISO/TC 37). The worldwide use of ISO/TC 37/SC 4 standards should improve information management within industrial, technical and scientific environments, and increase efficiency in computer-supported language communication. The standardization of principles and methods for the collection, processing and presentation of language resources requires a distinct type of standardization activity. Basic standards should be produced with wide-ranging applications in view. In the area of language resources, for instance, these standards should provide various technical committees of ISO, IEC and other standardizing bodies with the groundwork for building more precise standards for language resource management. ISO/TC 37/SC 4 will liaison with ISLE (International Standards for Language Engineering), which has implemented various recent efforts to integrate EC and US efforts for language resources. Where possible, these and other standards set up in EAGLES will be incorporated into the ISO standards. ISO/TC 37/SC 4 will also broaden the work of EAGLES/ISLE by including languages (e.g. Asian languages) that are not currently covered by EAGLES/ISLE standards. We are aware that standardization is a difficult business, and that many members of the targeted communities are skeptical about imposing any sort of standards at all. There are two major arguments against the idea of standardization for language resources. First, the diversity of theoretical approaches to, in particular, the annotation of various linguistic phenomena\nsuggests that standardization is at least impractical, if not impossible. Second, it is feared that vast amounts of existing data and processing software, which may have taken years of effort and considerable funding to develop, will be rendered obsolete by the acceptance of new standards by the community. To answer both of these concerns, we stress that the efforts of the committee are geared toward defining abstract models and general frameworks for creation and representation of language resources that should, in principle, be abstract enough to accommodate diverse theoretical approaches. The model so far developed in ISO TC/37 for terminology, which has informed and been informed by work on representation schemes for dictionaries and other lexical data (Ide, et al., 2000) and syntactic annotation (Ide and Romary, 2001) demonstrates that this is not an unrealizable goal. Also, by situating all of the standards development squarely in the framework of XML and related standards such as RDF, we hope to ensure not only that the standards developed by the committee provide for compatibility with established and widely accepted web-based technologies, but also that transduction from legacy formats into XML formats conformant to the new standards is feasible. At present, we feel that language professionals and standardization experts are not sufficiently aware of the standardization efforts being undertaken by ISO/TC 37/SC 4. Promoting awareness of future activities and rising problems, therefore, will be a crucial factor in the future success of the committee, and will be required to ensure widespread adoption of the standards it develops. An even more critical factor for the success of the committee's work is to involve, from the outset, as many and as broad a range of potential users of the standards as possible. This paper serves in part as a call for participation to the linguistics and computational linguistics research communities. In the following sections, we describe the principles and architecture of a general framework for annotations that can serve to define an abstract format capable of representing the range of annotation types. We then provide\nexamples in which the format is applied to specific annotations types."}, {"heading": "1 Representing linguistic annotation", "text": "The goal of our work is to define a model for linguistic annotation that can (a) be instantiated in a standard representational format; and (b) can serve as a pivot format into and out of which proprietary formats can be transduced, in order to enable comparison and merging, as well as operation on the data by common tools, as shown in Figure 1.\nTo accomplish this, it is necessary to identify a consistent underlying data model for data and its annotations. A data model is a formalized description of the data objects (in terms of composition, attributes, class membership, applicable procedures, etc.) and relations among them, independent of their instantiation in any particular form. A data model capable of capturing the structure and relations in diverse types of data and annotations is a pre-requisite for developing a common corpus-handling environment: it impacts the design of annotation schema, encoding formats and data architectures, and tool architectures."}, {"heading": "1.1 Abstract model for annotation", "text": "At its highest level of abstraction, an annotation is a set of data or information (in our case, linguistic information) that is associated with some other data. The latter is what could be called \u201cprimary\u201d data (e.g., a part of a text or speech signal, etc.), but this need not be the case; consider, for example, the alignment of\nparallel translations, where the \"annotation\" is a link between two primary data objects (the aligned texts). Typically, primary data objects are represented by \u201clocations\u201d in an electronic file, for example, the span of characters comprising a sentence or word, or a point at which a given temporal event begins or ends (as in speech annotation). As such, at the base primary data objects are relatively simple in their structure; more complex data objects may consist of a list or set of contiguous or noncontiguous locations. Annotation objects, on the other hand, often have a more complex internal structure: syntactic annotation, for example, may be expressed as a tree structure, and may include more elemental annotations such as dependency relations (which is itself an annotation relating two objects, where the relation is directional (dependent-to-head)). Thus, we can conceive of, an annotation as a one- or two-way link between an annotation object and a point (or a list/set of points) or span (or a list/set of spans) within a base data set. Links may or may not have a semantics--i.e., a type--associated with them. Points and spans in the base data may themselves be objects, or sets or lists of objects. This abstract formulation can serve as the basis for defining a general model for linguistic annotation that can be realized in some representational format. However, we first make several observations:  the model assumes a fundamental linearity\nof objects in the base,1 e.g., as a time line (speech); a sequence of characters, words, sentences, etc.; or pixel data representing images;\n the granularity of the data representation and encoding is critical: it must be possible to uniquely point to the smallest possible component (e.g., character, phonetic component, pitch signal, morpheme, word, etc.);\n1 Note that this observation applies to the fundamental structure of stored data. Because the targets of a relation may be either individual objects, or sets or lists of objects, information with more than one dimension is accommodated.\n an annotation scheme must be mappable to the structures defined for annotation objects in the model;\n an encoding scheme must be able to capture the object structure and relations expressed in the model, including class membership and inheritance, therefore requiring a sophisticated means to specify linkage within and between documents;\n it is necessary to consider the logistics of identifying spans by enclosing them in start and end tags (thus enabling hierarchical grouping of objects in the data itself), vs. explicit addressing of start and end points;\n it must be possible to represent objects and relations in some (fairly straightforward) form that is both usable by a variety of tools and prevents information loss;\n ideally, it should be possible to represent the objects and relations in a variety of formats suitable to different tools and applications."}, {"heading": "1.2 A closer look at annotations", "text": "As noted above, annotation objects may be relatively complex. In order to define a generic model for linguistic annotation, it is necessary to consider the representational needs for annotations themselves. Linguistic annotation can be represented as a graph of elementary structural nodes to which one or more information units are attached. The distinction between the structure of annotations and the informational units of which it is comprised is, we feel, critical to the design of a truly general model for annotations. Annotations may be structured in several ways; perhaps the most common structure is hierarchical. For example, phrase structure analyses of syntax are structured as trees; in addition, hierarchy is often used to break annotation information into subcomponents, as in the case of lexical and terminological information, There are several special relations among annotations that must be represented in the model, including the following:\n1 Parallelism: two or more annotations refer to the same data object;\n2 Alternatives: two or more annotations comprise a set of mutually exclusive alternatives (e.g., two possible part-ofspeech assignments, before disambiguation);\n3 Aggregation: two or more annotations comprise a list or set that should be taken as a unit.\nInformation units or data categories provide the semantics of the annotation. Data categories are the most theory and application-specific part of an annotation scheme. We do not attempt to define the relevant data categories for given types of annotation. Rather, we propose the development of a Data Category Registry to provide a framework in which the research community can formally define data categories for reference and use in annotation, Data categories would be defined using RDF schemas to formalize the properties and relations associated with each. Note that RDF descriptions function much like class definitions in an object-oriented programming language: they provide, effectively, templates that describe how objects may be instantiated, but do not constitute the objects themselves. Thus, in a document containing an actual annotation, several objects with the same type may be instantiated, each with a different value. The RDF schema ensures that each instantiation is recognized as a sub-class of more general classes and inherits the appropriate properties. A formally defined set of categories will have several functions: (1) it will provide a precise semantics for annotation categories that can be either used \u201coff the shelf \u201c by annotators; (2) it will provide a set of reference categories onto which scheme-specific names can be mapped; and (3) it will provide a point of departure for definition of variant or more precise categories. Thus the overall goal of the Data Category Registry is not to impose a specific set of categories, but rather to ensure that the semantics of data categories included in annotations (whether they exist in the Registry or not) are well-defined and understood.\n0.2 The Generic Mapping Tool We instantiate the abstract format for annotations using the eXtensible Markup Language (XML). XML is the emerging standard for data representation and exchange on the World Wide Web (Bray, et al., 1998). Although at its most basic level XML is a document markup language directly derived from SGML (i.e., allowing tagged text (elements), element nesting, and element references), various features and extensions of XML (including XSLT, RDF, etc.) make it a powerful tool for data representation and access. The model is instantiated by the Generic Mapping Tool (GMT), which includes the following tags:  <struct> represents a structural node in\nthe annotation. <struct> elements may be recursively nested at any level to reflect a tree structure for the annotation. Attributes include  type : annotation type (e.g., \u201csyntax\u201d),\nwhere necessary or desirable;  ID: unique identifier for the node  ref : node this <struct> node\nrepresents (for implicit structures)  <feat> (feature) is used to provide\ninformation attached to the node represented by the enclosing <struct> element. A type attribute on the <feat> element identifies the data category of the feature. The tag may contain a string that provides an appropriate value for the data category (e.g., for type=CAT the value might be \u201cNP\u201d) or <feat> can be recursively refined to describe complex structures. Alternatively, it may point via a target attribute to an object in another document that provides the value. Note that this allows the possibility for generating a single instantiation of an annotation value in a separate document that can be referenced as needed within the annotation document.\n <alt> is used to provide one or more alternative annotations, where necessary.\n <rel> is used to point to a non-contiguous related element, e.g., to identify dependencies explicitly by pointing to the\nrelated <struct> node.  <seg> points to the data to which the\nannotation applies. We assume the use of stand-off annotation2\u2014i.e., annotation that is maintained in a document separate from the primary (annotated) data\u2014as first defined in the Corpus Encoding Standard (CES) (Ide, 1998a, b) and subsequently adopted by the research community. A target attribute on the <seg> element uses XML Pointers (Xpointer) (Daniel, et al., 2001) to specify the location of the relevant data.\n <brack> is used to group information to be regarded as a unit.\nThe GMT is sufficiently powerful to represent the information across all annotation types. We have already demonstrated its applicability to terminological and lexical information (Ide, et al., 2000) and syntactic annotation (Ide and Romary, 2001); we provide additional examples below. Existing formats (whether or not in XML) can be mapped to the GMT, in order to enable merging, comparison, and manipulation via common tools. The GMT version can then be re-mapped to the original formats for use in in-house tools and applications. etc."}, {"heading": "2 Examples", "text": ""}, {"heading": "2.1 Morpho-syntactic annotation", "text": "We illustrate a simple application of the framework presented above for the domain of morpho-syntactic annotation. Morpho-syntactic annotation involves the identification of word classes over a continuous stream of word tokens. The annotations may refer to the segmentation of the input stream into word tokens, but may also involve grouping together sequences of tokens or identifying sub-token units (or morphemes), depending on the language under consideration and, in particular, the definitions of \u201cword\u201d and \u201cmorpheme\u201d as applied to this\n2 In the original CES definition, the term remote markup was introduced (see http://www.cs.vassar.edu/CES/CES15.html#ToCOview), but has subsequently been replaced by the term stand-off annotation.\nlanguage. The description of word classes may include one or several features such as syntactic category, lemma, gender, number etc., which is again dependent on the language being analyzed. Morpho-syntactic annotation can be represented by a single type of structural node (named Wlevel) representing a word-level structure unit organized hierarchically. One or several information units are associated with each structural node. For the purposes of illustration, we identify the following data categories (in practice these would be defined in reference to the Data Category Registry):  /lemma/: contains or points to a reference\nword form for the token or sequence of tokens being described;\n /part of speech/: a reference to a morphosyntactic category;\n /confidence/: a confidence level assigned by the manual or automatic annotator in ambiguous cases.\n /gender/: the grammatical gender information associated with a word token or a sequence of word tokens;\n /number/: the grammatical gender information associated with a word token or a sequence of word tokens;\n /tense/: the grammatical tense information associated with a word token or a sequence of word tokens;\n /person/: the grammatical person information associated with a word token or a sequence of word tokens.\nThe following provides an example of the morpho-syntactic annotation of the sentence \u201cPaul aime les croissants\u201d in the GMT format:3 <struct type=\u201dMSAnnot\u201d> <struct type=\u201dW-level\u201d> <feat type=\u201dlemma\u201d>Paul</feat> <feat type=\u201dpos\u201d>PNOUN</feat> <seg target=\u201d#w1\u201d/> </struct> <struct type=\u201dW-level\u201d> <feat type=\u201dlemma\u201d>aimer</feat>\n3 For brevity, we use an abbreviated pointer syntax to refer to the primary data in this example.\n<feat type=\u201dpos\u201d>VERB</feat> <feat type=\u201dtense\u201d>present</feat> <feat type=\u201dperson\u201d>3</feat> <seg target=\u201d#w2\u201d/> </struct> <struct type=\u201dW-level\u201d> <feat type=\u201dlemma\u201d>le</feat> <feat type=\u201dpos\u201d>DET</feat> <feat type=\u201dnumber\u201d>plural</feat> <seg target=\u201d#w3\u201d/> </struct> <struct type=\u201dW-level\u201d> <feat type=\u201dlemma\u201d>croissant</feat> <feat type=\u201dpos\u201d>NOUN</feat> <feat type=\u201dnumber\u201d>plural</feat> <seg target=\u201d#w4\u201d/> </struct>\n</struct> Note that there is no limit to the number of information units that may be associated with a given structural node (as opposed to the text based representations that are usually provided by available POS taggers). It is also possible to structure the annotations by embedding <feat> elements to reflect a more complex featurebased annotation, or by pointing to a lexical entry providing the information, In some cases, the morpho-syntactic annotation of a word or sequence of words requires a hierarchy of word level structures (e.g., when a word token results from the combination of several morphemes that must be annotated independently). For example, some occurrences of the token \u201cdu\u201d in French can be analyzed as the fusion of the preposition \u201cde\u201d with the determiner \u201cle\u201d (as in \u201cla queue du chat\u201d). This is handled by embedding word-level structures as follows: <struct type=\u201dW-level\u201d> <seg target=\u201d#w1\u201d/> <struct type=\u201dW-level\u201d> <feat type=\u201dlemma\u201d>de</feat> <feat type=\u201dpos\u201d>PREP</feat> </struct> <struct type=\u201dW-level\u201d> <feat type=\u201dlemma\u201d>le</feat> <feat type=\u201dpos\u201d>DET</feat> </struct> </struct>\nConversely, annotation of compound words may involve associating a simgle lemma to a sequence of word tokens at the surface level. In this case, the lemma is attached to the higher\nlevel of embedding and reference to the source is given at the leaves of the hierarchy, as in the following representation of the compound \u201cpomme de terre\u201d in French : <struct type=\u201dW-level\u201d>\n<feat type=\u201dlemma\u201d> pomme_de_terre</feat> <feat type=\u201dpos\u201d>NOUN</feat> <struct type=\u201dW-level\u201d> <seg target=\u201d#w1\u201d/> <feat type=\u201dlemma\u201d>pomme</feat> <feat type=\u201dpos\u201d>NOUN</feat> </struct> <struct type=\u201dW-level\u201d> <seg target=\u201d#w2\u201d/> <feat type=\u201dlemma\u201d>de</feat> <feat type=\u201dpos\u201d>PREP</feat> </struct> <struct type=\u201dW-level\u201d> <seg target=\u201d#w3\u201d/> <feat type=\u201dlemma\u201d>terre</feat> <feat type=\u201dpos\u201d>NOUN</feat> </struct>\n</struct>\nThe ability to specify a hierarchical structure where needed enables specification of the level of granularity required. This is especailly critical for a representation scheme, since the granularity of the segmentation in (or associated with) the primary data may not directly correspond to the level of granularity required for the annotation."}, {"heading": "2.1.1 Alternatives", "text": "Morpho-syntactic annotation can be used to illustrate the representation of both structural and informational alternatives, which arises when a given word token is associated with two or more word classes. For example, the French word \u201cbouche\u201d which can be derived both from the verb \u201cboucher\u201d and the noun \u201cbouche\u201d, which can be represented as follows: <struct type=\u201dW-level\u201d> <seg target=\u201d#w1\u201d/> <alt>\n<feat type=\u201dlemma\u201d>boucher</feat> <feat type=\u201dpos\u201d>VERB</feat> <feat type=\u201dtense\u201d>present</feat> <feat type=\u201dconfidence\u201d>0.4</feat>\n</alt> <alt>\n<feat type=\u201dlemma\u201d>bouche</feat> <feat type=\u201dpos\u201d>NOUN</feat> <feat type=\u201dconfidence\u201d>0.6</feat>\n</alt>\n</struct>"}, {"heading": "2.2 Relating annotation levels", "text": "As noted above, we assume the use of stand-off annotation; that is, an annotated corpus is represented as a lattice of stand-off annotation documents pointing to a primary source or intermediate annotation levels. However, depending on the point of view, the relations between various annotation levels can be more or less explicit. It is possible to identify three major ways to relate different levels of annotation: temporal anchoring, event-based anchoring, and object-based anchoring. Temporal anchoring associates positional information to each structural level. This positional information is typically represented as a pair of numbers expressing the starting point and ending point of the segment being described. To do so in our framework, we introduce two attributes for the <seg> element:  /startPosition/: the temporal or offset\nposition of the beginning of the current structural node;\n /endPosition/: the temporal or offset position of the end of the current structural node. For example, the following associates a phonetic transcription with a given portion of a primary text: <struct type=\u201dphonetic\u201d>\n<seg startsAt=\u201d2300\u201d endsAt=\u201d3200\u201d/> <feat type=\u201dphone\u201d>iy</feat>\n</struct> We also define an event-based anchoring, which effectively introduces a structural node to represent a location in the text, to which all\nannotations for the object at that location can refer. This strategy is useful in two cases:  Situations where it is not possible or\ndesirable to modify the primary data by inserting markup to identify specific objects or points in the data (e.g., speech annotation, associated with a speech signal, or in general any \u201cread-only\u201d data).\n Primary data marked with \u201cmilestones\u201d, such as time stamps in speech data, where spans across the various milestones must be identified. In this case, the <struct> elements represent the markup for segmentation (e.g., segmentation into words, sentences, etc.). To represent this, we introduce a specific type of structural node, named landmark, which is referred to by annotations for the defined span, as follows: <struct type=\u201dlandmark\u201d>\n<seg startsAt=\u201d2300\u201d endsAt=\u201d3200\u201d/>\n</struct> The annotation graph (AG) formalism (Bird and Liberman, 2001) was explicitly designed to deal with time-stamped data. We can represent annotation graphs in the GMT as shown in\nFigure 2. We feel that the GMT representation is more general, for the following reasons:\n The AG formalism reifies the \u201carc\u201d and\ntreats it as a special\n<annotation> <arc><source id=\"0\" offset=\"0\"/><label att_1=\"P\" att_2=\"h#\"/><target id=\"1\" offset=\"2360\"/></arc> <arc><source id=\"1\" offset=\"2360\"/><label att_1=\"P\" att_2=\"sh\"/><target id=\"2\" offset=\"3270\"/></arc> <arc><source id=\"2\" offset=\"3270\"/><label att_1=\"P\" att_2=\"iy\"/><target id=\"3\" offset=\"5200\"/></arc> <arc><source id=\"1\" offset=\"2360\"/><label att_1=\"W\" att_2=\"she\"/><target id=\"3\" offset=\"5200\"/></arc> <arc><source id=\"3\" offset=\"5200\"/><label att_1=\"P\" att_2=\"hv\"/><target id=\"4\" offset=\"6160\"/></arc>\n<arc><source id=\"4\" offset=\"6160\"/><label att_1=\"P\" att_2=\"ae\"/><target id=\"5\" offset=\"8720\"/></arc> <arc><source id=\"5\" offset=\"8720\"/><label att_1=\"P\" att_2=\"dcl\"/><target id=\"6\" offset=\"9680\"/></arc> <arc><source id=\"3\" offset=\"5200\"/><label att_1=\"W\" att_2=\"had\"/><target id=\"6\" offset=\"9680\"/></arc> <arc><source id=\"6\" offset=\"9680\"/><label att_1=\"P\" att_2=\"y\"/><target id=\"7\" offset=\"10173\"/></arc> <arc><source id=\"7\" offset=\"10173\"/><label att_1=\"P\" att_2=\"axr\"/><target id=\"8\" offset=\"11077\"/></arc> <arc><source id=\"6\" offset=\"9680\"/><label att_1=\"W\" att_2=\"your\"/><target id=\"8\" offset=\"11077\"/></arc> </annotation>\nFigure 2a. XML instantiation of an annotation graph <struct type=\u201dlandmarkDesc>\n<struct type=\u201dlandmark\u201d id=\u201d0\u201d> <position>0</position> </struct> <struct type=\u201dlandmark\u201d id=\u201d1\u201d> <position>2360</position> </struct> <struct type=\u201dlandmark\u201d id=\u201d2\u201d> <position>5200</position> </struct> \u2026\n</struct> <struct type=\u201dphoneticAnnot\u201d>\n<struct type=\u201dphone\u201d> <startsAt target=\u201d#0\u201d/> <endsAt target=\u201d#1\u201d/> <phone>h#</phone> </struct>\n<struct type=\u201dphone\u201d> <startsAt target=\u201d#1\u201d/> <endsAt target=\u201d#2\u201d/> <phone>sh</phone> </struct> <struct type=\u201dphone\u201d>\n<startsAt target=\u201d#2\u201d/> <endsAt target=\u201d#3\u201d/> <phone>iy</phone>\n</struct> \u2026\n</struct> <struct type=\u201dmorphAnnot\u201d>\n<struct type=\u201dw\u201d> <startsAt target=\u201d#0\u201d/> <endsAt target=\u201d#3\u201d/> <source>she</source>\n</struct> \u2026 </struct>\nFigure 2b. Annotation graph representation in GMT The third mechanism, object-based anchoring, enables pointing from a given level to one or several structural nodes at another level. This mechanism is particularly useful to make dependencies between two or more annotation levels explicit. For example, syntactic annotation can refer directly to the relevant nodes in a morpho-syntactically annotated corpus, in order, for example, to identify the correct NP \u201cle chat\u201d in \u201cla queue du chat\u201d, as shown below: <!-- Morphosyntactic level --> <struct type=\u201dW-level\u201d> <seg target=\u201d#w3\u201d> <struct type=\u201dW-level\u201d> <seg target=\u201d#w3.1\u201d> <feat type=\u201dlemma\u201d>de</feat>\n<feat type=\u201dpos\u201d>PREP</feat> </struct> <struct type=\u201dW-level\u201d>\n<seg target=\u201d#w3.2\u201d> <feat type=\u201dlemma\u201d>le</feat>\n<feat type=\u201dpos\u201d>DET</feat> <feat type=\u201dgender\u201d>masc</feat> </struct> </struct> <struct type=\u201dW-level\u201d> <seg target=\u201d#w4\u201d> <feat type=\u201dlemma>chat</feat> <feat type=\u201dpos\u201d>NOUN</feat>\n</struct> </struct> <!-- Syntactic level (simplified) --> <struct> <feat type=\u201dsynCat\u201d>NP</feat> <seg targets=\u201dw3.2 w4\u201d/> </struct>\nConclusion\nThe framework presented here for linguistic annotation is intended to allow for variation in annotation schemes while at the same time enabling comparison and evaluation, merging of different annotations, and development of common tools for creating and using annotated data. We have developed an abstract model for annotations that is capable of representing the necessary information while providing a common encoding format that can be used as a pivot for combining and comparing annotations, as well as an underlying format that can be manipulated and accessed with common tools. The details presented here provide a look \u201cunder the hood\u201d in order to show the flexibility and representational power of the abstract scheme; however, the intention is that annotators and users of syntactic annotation schemes can continue to use their own or other formats with which they are comfortable, and translation into and out of the abstract format will be automatic. Our framework for linguistic annotation is built around some relatively straightforward ideas: separation of information conveyed by means of structure and information conveyed directly by specification of content categories; development of an abstract format that puts a layer of abstraction between site-specific annotation schemes and standard specifications; and creation of a Data Category Registry to provide a reference set of annotation categories. The emergence of XML and related standards, together with RDF, provides the enabling technology. We are, therefore, at a point where the creation and use of annotated data and concerns about the way it is represented can be treated separately\u2014that is, researchers can focus on the question of what to encode, independent of the question of how to encode it. The end result should be greater coherence, consistency, and ease of use and access for linguistic annotated data."}], "references": [{"title": "A formal framework for linguistic annotation", "author": ["S. Bird", "M. Liberman"], "venue": "Speech Communication,", "citeRegEx": "Bird and Liberman,? \\Q2001\\E", "shortCiteRegEx": "Bird and Liberman", "year": 2001}, {"title": "Extensible Markup Language (XML) Version 1.0", "author": ["T. Bray", "J. Paoli", "C.M. Sperberg-McQueen"], "venue": "W3C Recommendation", "citeRegEx": "Bray et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Bray et al\\.", "year": 1998}, {"title": "XML Pointer Language (XPointer) Version 1.0", "author": ["R. Daniel", "S. DeRose", "E. Maler"], "venue": "W3C Recommendation", "citeRegEx": "Daniel et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Daniel et al\\.", "year": 2001}, {"title": "Encoding Linguistic Corpora", "author": ["N. Ide"], "venue": "Proceedings of the Sixth Workshop on Very Large Corpora,", "citeRegEx": "Ide,? \\Q1998\\E", "shortCiteRegEx": "Ide", "year": 1998}, {"title": "A Formal Model of Dictionary Structure and Content", "author": ["N. Ide", "A. Kilgarriff", "L. Romary"], "venue": "Proceedings of Euralex", "citeRegEx": "Ide et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Ide et al\\.", "year": 2000}, {"title": "A Common Framework for Syntactic Annotation", "author": ["N. Ide", "L. Romary"], "venue": "Proceedings of ACL'2001,", "citeRegEx": "Ide and Romary,? \\Q2001\\E", "shortCiteRegEx": "Ide and Romary", "year": 2001}], "referenceMentions": [{"referenceID": 5, "context": ", 2000) and syntactic annotation (Ide and Romary, 2001) demonstrates that this is not an unrealizable goal.", "startOffset": 33, "endOffset": 55}, {"referenceID": 5, "context": ", 2000) and syntactic annotation (Ide and Romary, 2001); we provide additional examples below.", "startOffset": 33, "endOffset": 55}, {"referenceID": 0, "context": "The annotation graph (AG) formalism (Bird and Liberman, 2001) was explicitly designed to deal with time-stamped data.", "startOffset": 36, "endOffset": 61}], "year": 2009, "abstractText": "The goal of this paper is two-fold: to present an abstract data model for linguistic annotations and its implementation using XML, RDF and related standards; and to outline the work of a newly formed committee of the International Standards Organization (ISO), ISO/TC 37/SC 4 Language Resource Management, which will use this work as its starting point. The primary motive for presenting the latter is to solicit the participation of members of the research community to contribute to the work of the committee.", "creator": "PScript5.dll Version 5.2.2"}}}