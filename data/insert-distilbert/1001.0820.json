{"id": "1001.0820", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jan-2010", "title": "Abstract Answer Set Solvers with Learning", "abstract": "nieuwenhuis, oliveras, and tinelli ( 2006 ) showed how to describe enhancements of the davis - putnam - logemann - loveland algorithm using transition learning systems, instead usage of pseudocode. yet we design a similar framework for several algorithms that generate answer sets for logic programs : ao smodels, np smodels - cc, asp - sat with augmented learning ( cmodels ), and a smaller newly designed and implemented algorithm sup. this approach to computers describing answer finite set solvers makes it easier to prove they their correctness, to compare beyond them, and to design new systems.", "histories": [["v1", "Wed, 6 Jan 2010 05:53:29 GMT  (191kb,S)", "http://arxiv.org/abs/1001.0820v1", "Long version of the paper that will appear in special issue of Theory and Practice of Logic Programming"]], "COMMENTS": "Long version of the paper that will appear in special issue of Theory and Practice of Logic Programming", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["yuliya lierler"], "accepted": false, "id": "1001.0820"}, "pdf": {"name": "1001.0820.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": ["yuliya@cs.utexas.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n00 1.\n08 20\nv1 [\ncs .A\nI] 6\nJ an\n2 01\n0"}, {"heading": "Abstract Answer Set Solvers with Backjumping", "text": "and Learning (long version)"}, {"heading": "YULIYA LIERLER", "text": "Department of Computer Science\nUniversity of Texas at Austin\n1 University Station C0500\nTaylor Hall 2.124\nAustin, USA\nE-mail: yuliya@cs.utexas.edu"}, {"heading": "Abstract", "text": "Nieuwenhuis, Oliveras, and Tinelli (2006) showed how to describe enhancements of the Davis-Putnam-Logemann-Loveland algorithm using transition systems, instead of pseudocode. We design a similar framework for several algorithms that generate answer sets for logic programs: smodels, smodelscc , asp-sat with Learning (cmodels), and a newly designed and implemented algorithm sup. This approach to describing answer set solvers makes it easier to prove their correctness, to compare them, and to design new systems.\nKEYWORDS: answer set programming, inference, learning"}, {"heading": "1 Introduction", "text": "Answer Set Programming (ASP) is a methodology commonly used for solving combinatorial search problems (Lifschitz 2008). In the development of ASP solvers, computational ideas behind SAT solvers (Gomes et al. 2008) play an important role. Influence of SAT solvers development on ASP systems is twofold. On the one hand, such ASP solvers as assat1 and cmodels2 follow the so called SAT-based approach where a SAT solver is invoked for search, possibly multiple times. On the other hand, \u201cnative\u201d ASP solvers that implement search procedures specifically suited for logic programs often adopt computational techniques from SAT solvers. For instance, dlv3 implements backjumping (Ricca et al. 2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels5 by introducing restarts, conflict-driven\n1 http://assat.cs.ust.hk/ . 2 http://www.cs.utexas.edu/users/tag/cmodels . 3 http://www.dbai.tuwien.ac.at/proj/dlv/ . 4 http://www.nku.edu/\u223cwardj1/Research/smodels cc.html . 5 http://www.tcs.hut.fi/Software/smodels/ .\nbackjumping, learning, and forgetting \u2013 techniques widely used in SAT solvers. The ASP solver sup6 (Lierler 2008) implements these features also.\nIn this paper our main goal is to show how the \u201cabstract\u201d approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features. Usually computation procedures are described in terms of pseudocode. In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures. They introduced an abstract framework that captures what \u201dstates of computation\u201d are, and what transitions between states are allowed. In this way, it defines a directed graph such that every execution of the dpll procedure corresponds to a path in this graph. Some edges may correspond to unit propagation steps, some to branching, some to backtracking. This allows the authors to model a dpll-like algorithm by a mathematically simple and elegant object, graph, rather than a collection of pseudocode statements. In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning. In this paper, we expand our previous work on abstract answer set solvers to cover such features as backjumping and learning (and also forgetting and restart). We start by introducing an abstract framework that captures a general mechanism of these sophisticated features in ASP solvers. For instance, this framework provides the transition underlying the process of learning a clause, but it does not suggest which clause shall be learned. Similarly, it provides a general description of backjumping but it does not supply the means for computing a \u201cbackjump clause\u201d necessary for an answer set solver to perform backjumping. We then enhance this abstract framework to capture enough information about a state of computation for deriving a backjump clause.\nUsually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause. There are two common methods for describing a backjump clause construction. One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005). Ward and Schlipf (2004) extended the notion of an implication graph to the smodels algorithm. They then defined an algorithm for computing FirstUIP backjump clauses utilized by smodelscc to implement conflict-driven backjumping and learning. In this paper we introduce the algorithms BackjumpClause and BackjumpClauseFirstUIP based on resolution and the enhanced abstract framework that compute Decision and FirstUIP7 backjump clauses respectively.\nIn (Lierler 2008), we introduced the basic algorithm underlining the system sup but neglected some of its features: conflict-driven backjumping, learning, forgetting, and restarts. Here we account for these techniques and use an abstract framework designed in this paper for describing system sup. We emphasize that the work on this abstract framework helped us to develop ASP solver sup, to incorporate\n6 http://www.cs.utexas.edu/users/tag/sup . 7 The names of the backjump clauses follow (Mitchell 2005).\nlearning into its algorithm, and to prove its correctness. We analyzed performance of sup against such answer set solvers as cmodels, smodels, smodelscc, and clasp8. Overall, sup performs well against these rival systems.\nWe start the paper with Section 2 that reviews the abstract DPLL framework introduced in (Nieuwenhuis et al. 2006) and some logic programming concepts. In Section 3, we define a graph representing the application of the algorithm for finding supporting models of a logic program. This paves the way to defining a graph representing the application of the smodels algorithm to a program in Section 4. Section 4.2 elaborates on the relationship between previously defined abstract frameworks. Section 5 extends the abstract DPLL framework by introducing an additional inference rule so that the generate and test algorithm of the SAT-based ASP system cmodels may be characterized by this graph. In Section 6, we review the abstract framework that describes DPLL enhanced by backjumping and learning. In Section 7, we define a general abstract framework for describing ASP algorithms that implement such phenomena as backjumping and learning. In Section 7.2 we describe the algorithms of systems smodelscc and sup by means of this framework. In Section 8 we extend the abstract generate and test framework to accommodate backjumping and learning, and in Section 8.2 we use these findings to describe the cmodels algorithm. Section 9 extends the framework to capture additional information about a computation state of a solver, states the correctness results, and describes how the frameworks are related to each other. Section 10 provides the proofs for these results. In Section 10.3 and 11 we introduce the algorithms based on the extended framework for computing a backjump clause that are important in implementing conflict-driven backjumping and learning. In Section 12 we introduce the concept of an extended graph for the generate and test abstract framework and state the correctness results. Section 13 provides the proofs for these results. At last, in Section 14 we provide the experimental analysis that compares performance of sup with other answer set solvers."}, {"heading": "2 Review: Abstract DPLL and Logic Programs", "text": ""}, {"heading": "2.1 Abstract Classical DPLL", "text": "For a set \u03c3 of atoms, a record M relative to \u03c3 is a list of literals over \u03c3 where\n(i) some literals in M are annotated by \u2206 that marks them as decision literals,\n(ii) M contains no repetitions.\nThe concatenation of two such lists is denoted by juxtaposition. Frequently, we consider a record as a set of literals, ignoring both the annotations and the order between its elements. A literal l is unassigned by a record if neither l nor its complement l belongs to it.\n8 http://www.cs.uni-potsdam.de/clasp/ .\nA state relative to \u03c3 is either a distinguished state FailState or a record relative\nto \u03c3. For instance, the states relative to a singleton set {a} of atoms are\nFailState, \u2205, a, \u00aca, a\u2206, \u00aca\u2206, a\u00aca, a\u2206\u00aca,\na\u00aca\u2206, a\u2206\u00aca\u2206,\u00acaa, \u00aca\u2206a, \u00acaa\u2206, \u00aca\u2206a\u2206,\nwhere by \u2205 we denote the empty list.\nIf C is a disjunction (conjunction) of literals then by C we understand the conjunction (disjunction) of the complements of the literals occurring in C . We will sometimes identify C with the multi-set of its elements.\nFor any CNF formula F (a finite set of clauses), we will define its DPLL graph dpF . The nodes of dpF are the states relative to the set of atoms occurring in F . We use the terms \u201cstate\u201d and \u201cnode\u201d interchangeably. Recall that a node is called terminal in a graph if there is no edge leaving this node in the graph. If a state is consistent and complete then it represents a truth assignment for F .\nThe set of edges of dpF is described by a set of \u201ctransition rules.\u201d Each transition rule is an expressionM =\u21d2 M \u2032 followed by a condition, where M and M \u2032 are nodes of dpF . Whenever the condition is satisfied, the graph contains an edge from nodeM to M \u2032. Generally, an edge in the graph may be justified by several transition rules. Figure 1 presents four transition rules that characterize the edges of dpF .\nThis graph can be used for deciding the satisfiability of a formula F simply by constructing an arbitrary path leading from node \u2205 until a terminal node M is reached. The following proposition shows that this process always terminates, that F is unsatisfiable if M is FailState, and that M is a model of F otherwise.\nProposition 1 For any CNF formula F ,\n(a) graph dpF is finite and acyclic,\n(b) any terminal state of dpF other than FailState is a model of F , (c) FailState is reachable from \u2205 in dpF if and only if F is unsatisfiable.\nFor instance, let F be the set consisting of the clauses\na \u2228 b \u00aca \u2228 c.\nHere is a path in dpF :\n\u2205 =\u21d2 (Decide) a\u2206 =\u21d2 (Unit Propagate) a\u2206c =\u21d2 (Decide) a\u2206cb\u2206\n(1)\nThe name of the transition rule after each =\u21d2 shows which rule justifies the presence of this edge in the graph. Since the state a\u2206cb\u2206 is terminal, Proposition 1(b) asserts that {a, c, b} is a model of F . Here is another path in dpF from \u2205 to the same terminal node:\n\u2205 =\u21d2 (Decide) a\u2206 =\u21d2 (Decide) a\u2206\u00acc\u2206 =\u21d2 (Unit Propagate) a\u2206\u00acc\u2206c =\u21d2 (Backtrack) a\u2206c =\u21d2 (Decide) a\u2206cb\u2206\n(2)\nPath (1) corresponds to an execution of dpll in the sense of (Davis et al. 1962); path (2) does not, because it applies Decide to a\u2206 even though Unit Propagate could be applied in this state.\nNote that the graph dpF is a modification of the classical DPLL graph defined in (Nieuwenhuis et al. 2006, Section 2.3). It is different in three ways. First, its states are pairs M ||F for all CNF formulas F . For the purposes of this section, it is not necessary to include F . Second, the description of the classical DPLL graph involves a \u201cPureLiteral\u201d transition rule. We dropped this rule because it does not correspond to any of the propagation rules used in answer set solvers whose algorithms we will model in this paper. Third, in the definition of that graph, each M is required to be consistent. In case of DPLL, due to the simple structure of a clause, it is possible to characterize the applicability of Backtrack in a simple manner: when some of the clauses become inconsistent with the current partial assignment, Backtrack is applicable. In ASP, it is not easy to describe the applicability of Backtrack if only consistent states are taken into account. We introduced inconsistent states in the graph dpF to facilitate our work on extending this graph to model algorithms of answer set solvers.\nIn the rest of this section we give a proof of Proposition 1.\nLemma 1 For any CNF formula F and any state l1 . . . ln reachable from \u2205 in dpF , every model X of F satisfies li if it satisfies all decision literals l \u2206 j with j \u2264 i ."}, {"heading": "Proof", "text": "By induction on the path from \u2205 to l1 . . . ln . The property of X that we need to prove trivially holds in the initial state \u2205, and we will prove that all transition rules of dpF preserve it.\nTake a model X of F , and consider an edge M =\u21d2 M \u2032 where M is a list l1 . . . lk such that X satisfies li if it satisfies all decision literals l \u2206 j with j \u2264 i .\nIt is clear that the rule justifying the transition from M to M \u2032 is different from Fail . For each of the other three rules,M \u2032 is obtained from a prefix ofM by appending a list of literals containing at most one decision literal. Due to the inductive hypothesis, it is sufficient to show that if X satisfies all decision literals in M \u2032 then X satisfies all M \u2032.\nUnit Propagate: M \u2032 is M l . By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= l . From the definition of Unit Propagate, for some clause C \u2228 l \u2208 F , C \u2286 M . Consequently, M |= \u00acC . From the inductive hypothesis and the assumption that X satisfies all decision literals in M \u2032 and hence in M , it follows that X |= M . Since X is a model of F , we conclude that X |= l .\nDecide: M \u2032 is M l\u2206. Obvious. Backtrack : M has the form P l\u2206Q where Q contains no decision literals. M \u2032 is P l . By the inductive hypothesis, it trivially follows that for every literal in P the property in question holds. We need to show that X |= l . Assume that X |=l . Since Q does not contain decision literals, and the assumption that X satisfies all decision literals in M \u2032 and hence in P , X satisfies all decision literals in P l\u2206Q , that is M . By the inductive hypothesis, it follows that X satisfies M . This is impossible because M is inconsistent.\n\u0131Proof of Proposition 1\n(a) The finiteness of dpF is obvious. For any list N of literals by |N | we denote the length of N . Any state M other than FailState has the form M0 l \u2206 1 M1 . . . l \u2206 p Mp , where l\u22061 . . . l \u2206 p are all decision literals of M ; we define \u03b1(M ) as the sequence of nonnegative integers |M0|, |M1|, . . . , |Mp |, and \u03b1(FailState) = \u221e. By the definition of the transition rules defining the edges of dpF , if there is an edge from a state M to M \u2032 in dpF then \u03b1(M ) < \u03b1(M \u2032), where < is understood as the lexicographical order. It follows that if a state M \u2032 is reachable from M then \u03b1(M ) < \u03b1(M \u2032). Consequently the graph is acyclic.\n(b) Consider any terminal state M other than FailState. From the fact that Decide is not applicable, we conclude that M has no unassigned literals. Since neither Backtrack nor Fail is applicable,M is consistent. ConsequentlyM is an assignment. It follows that for any clause C \u2228 l \u2208 F if C 6\u2286 M then C \u2229M 6= \u2205. Furthermore, since Unit Propagate is not applicable, we conclude that if C \u2286 M then l \u2208 M . Consequently, M |= C \u2228 l . Hence M is a model of F .\n(c) Left-to-right: Since FailState is reachable from \u2205, there is an inconsistent stateM without decision literals that is reachable from \u2205. By Lemma 1, any model of F satisfies M . Since M is inconsistent we conclude that F has no models.\nRight-to-left: From (a) it follows that there is a path from \u2205 to some terminal state. By (b), this state cannot be different from FailState, because F is unsatisfiable."}, {"heading": "2.2 Logic Programs", "text": "We consider programs consisting of finitely many rules of the form\na \u2190 b1, . . . , bl , not bl+1, . . . , not bm (3)\nwhere a is an atom or symbol \u22a5, and each bi (1 \u2264 i \u2264 m) is an atom. We will identify the body of (3) with the conjunction\nb1 \u2227 . . . \u2227 bl \u2227 \u00acbl+1 \u2227 . . .\u00ac \u2227 bm (4)\nand also with the set of its conjunctive terms. If the head a of a rule (3) is an atom then we will identify (3) with the clause\na \u2228 \u00acb1 \u2228 . . . \u2228 \u00acbl \u2228 bl+1 \u2228 . . . \u2228 bm . (5)\nIf a is \u22a5 then we call rule (3) a constraint and identify (3) with the clause\n\u00acb1 \u2228 . . . \u2228 \u00acbl \u2228 bl+1 \u2228 . . . \u2228 bm . (6)\nWe will often omit the symbol \u22a5 when referring to a constraint.\nWe will use two abbreviated forms for a rule (3): The first is\na \u2190 B\nwhere B stands for b1, . . . , bl , not bl+1, . . . , not bm . The second abbreviation is\na \u2190 D ,F (7)\nwhere D stands for the positive part of the body b1, . . . , bl , and F stands for the negative part of the body not bl+1, . . . , not bm .\nThe reduct \u03a0X of a program \u03a0 with respect to a set X of atoms is obtained\nfrom \u03a0 by\n\u2022 removing each rule (7) such that F \u2229 X 6= \u2205, and \u2022 replacing each remaining rule (7) by a \u2190 D .\nA set X of atoms is an answer set for a program \u03a0 if X is minimal (with respect to\nset inclusion) among the sets of atoms that satisfy the reduct \u03a0X (Gelfond and Lifschitz 1988).\nFor example, let \u03a0 be the program\na \u2190 not b b \u2190 not a c \u2190 a d \u2190 d .\n(8)\nConsider set {a, c}. Reduct \u03a0{a,c} is\na \u2190 c \u2190 a d \u2190 d .\n(9)\nSet {a, c} satisfies the reduct and is minimal, hence {a, c} is an answer set of \u03a0. Consider set {a, c, d}. The reduct \u03a0{a,c,d} is (9). Set {a, c, d} satisfies the reduct but is not minimal and hence it is not an answer set of \u03a0.\nBy Bodies(\u03a0, a) we denote the set of the bodies of all rules of \u03a0 with head a. For any set M of literals, by M+ we denote the set of positive literals from M . For any consistent and complete set M of literals (that is, an assignment), if M+ is an answer set for a program \u03a0, then M is a model of \u03a0. Moreover, in this case M is a supported model of \u03a0, in the sense that for every atom a \u2208 M , M |= B for some B \u2208 Bodies(\u03a0, a).\nA set U of atoms occurring in a program\u03a0 is said to be unfounded (Van Gelder et al. 1991)\non a consistent set M of literals w.r.t. \u03a0 if for every a \u2208 U and every B \u2208 Bodies(\u03a0, a), B \u2229 M 6= \u2205 or U \u2229 B+ 6= \u2205. There is a tight relation between unfounded sets and answer sets: For any model M of a program \u03a0, M+ is an answer set for \u03a0 if and only if M contains no non-empty subsets unfounded on M w.r.t. \u03a0 (Corollary 2 from (Sacca\u0301 and Zaniolo 1990)9).\nFor instance, let \u03a0 be program (8) and let M be a consistent set {a,\u00acb, c, d} of literals. We already demonstrated that M+ = {a, c, d} is not an answer set of \u03a0. Accordingly, its subset {d} is unfounded on {a,\u00acb, c, d} w.r.t. \u03a0, because the only rule in \u03a0 with d in the head\nd \u2190 d\nis such that U \u2229 B+ = {d} \u2229 {d} 6= \u2205.\nWe say that a program \u03a0 entails a formula F when for any consistent and complete set M of literals, if M+ is an answer set for \u03a0, then M |= F . For instance, any program \u03a0 entails each rule occurring in \u03a0."}, {"heading": "3 Generating Supported Models", "text": "In Section 4 we will define, for an arbitrary program \u03a0, a graph sm\u03a0 representing the application of the smodels algorithm to \u03a0; the terminal nodes of sm\u03a0 are answer sets of \u03a0. As a step in this direction, we describe here a simpler graph atleast\u03a0."}, {"heading": "3.1 Graph atleast\u03a0", "text": "The terminal nodes of atleast\u03a0 are supported models of \u03a0. The transition rules defining atleast\u03a0 are closely related to procedure Atleast (Simons 2000, Sections 4.1), which is one of the core procedures of the smodels algorithm.\nThe nodes of atleast\u03a0 are the states relative to the set of atoms occurring in \u03a0. The edges of the graph atleast\u03a0 are described by the transition rules Decide, Fail , Backtrack introduced in Section 2.1 and the additional transition rules10 presented\n9 The Corollary 2 from (Sacca\u0301 and Zaniolo 1990) refers to \u201dassumption sets\u201d rather than unfounded sets. But as the authors noted, in the context of this corollary the two concepts are equivalent.\n10 The names of some of these rules follow (Ward 2004).\nin Figure 2. Note that each of the rules Unit Propagate LP and Backchain False is similar to Unit Propagate: the former corresponds to Unit Propagate on C \u2228 l where l is the head of the rule, and the latter corresponds to Unit Propagate on C \u2228 l where l is an element of the body of the rule.\nThis graph can be used for deciding whether program \u03a0 has a supported model\nby constructing a path from \u2205 to a terminal node:\nProposition 2 For any program \u03a0,\n(a) graph atleast\u03a0 is finite and acyclic, (b) any terminal state of atleast\u03a0 other than FailState is a supported model\nof \u03a0, (c) FailState is reachable from \u2205 in atleast\u03a0 if and only if \u03a0 has no supported\nmodels.\nFor instance, let \u03a0 be program (8). Here is a path in atleast\u03a0:\n\u2205 =\u21d2 (Decide) a\u2206 =\u21d2 (Unit Propagate LP) a\u2206c =\u21d2 (All Rules Cancelled) a\u2206c\u00acb =\u21d2 (Decide) a\u2206c\u00acbd\u2206\n(10)\nSince the state a\u2206c\u00acbd\u2206 is terminal, Proposition 2(b) asserts that {a, c,\u00acb, d} is a supported model of \u03a0.\nThe assertion of Proposition 2 will remain true if we drop the transition rules\nBackchain True and Backchain False from the definition of atleast\u03a0.\nIn the rest of this section we give a proof of Proposition 2.\nLemma 2 For any program \u03a0 and any state l1 . . . ln reachable from \u2205 in atleast\u03a0, every supported model X for \u03a0 satisfies li if it satisfies all decision literals l \u2206 j with j \u2264 i ."}, {"heading": "Proof", "text": "By induction on the path from \u2205 to l1 . . . ln . Similar to the proof of Lemma 1. We will show that the property in question is preserved when the transition from M to M \u2032 is justified by any of the four new rules.\nTake a supported model X for \u03a0, and consider an edge M =\u21d2 M \u2032 where M is a\nlist l1 . . . lk such that X satisfies li if it satisfies all decision literals l \u2206 j with j \u2264 i .\nAssume that X satisfies all decision literals in M \u2032. Unit Propagate LP : M \u2032 is M a. By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= a. By the definition of Unit Propagate LP , B \u2286 M for some rule a \u2190 B . Consequently, M |= B . From the inductive hypothesis and the assumption that X satisfies all decision literals in M \u2032 and hence in M , it follows that X |= M . Since X is a model of \u03a0 we conclude that X |= a.\nAll Rules Cancelled : M \u2032 is M \u00aca and B \u2229 M 6= \u2205 for every B \u2208 Bodies(\u03a0, a). Consequently, M |= \u00acB for every B \u2208 Bodies(\u03a0, a). By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= \u00aca. By contradiction. Assume that X |= a. From the inductive hypothesis and the assumption that X satisfies all decision literals in M \u2032 and hence in M , it follows that X |= M . Since M |= \u00acB for every B \u2208 Bodies(\u03a0, a), it follows that X |= \u00acB . We conclude that X is not a supported model of \u03a0.\nBackchain True: M \u2032 is M l . By the inductive hypothesis, for every literal in M the property in question holds. We need to show that X |= l . By contradiction. Assume X |= l . Consider the rule a \u2190 B corresponding to this application of Backchain True. Since l \u2208 B , X |= \u00acB . By the definition of Backchain True, B \u2032 \u2229M 6= \u2205 for every B \u2032 in Bodies(\u03a0, a) \\B . Consequently, M |= \u00acB \u2032 for every B \u2032 in Bodies(\u03a0, a) \\ B . From the inductive hypothesis and the assumption that X satisfies all decision literals in M \u2032 and hence in M , it follows that X |= M . We conclude that X |= \u00acB \u2032 for every B \u2032 in Bodies(\u03a0, a)\\B . Hence X is not supported by \u03a0.\nBackchain False: M \u2032 isM l . By the inductive hypothesis, for every literal inM the property in question holds. We need to show that X |= l . By contradiction. Assume that X |= l . By the definition of Backchain False there exists a rule a \u2190 l ,B in \u03a0 such that \u00aca \u2208 M and B \u2286 M . Consequently, M |= \u00aca and M |= B . From the inductive hypothesis and the assumption that X satisfies all decision literals in M \u2032 and hence in M , it follows that X |= M . We conclude that X |= \u00aca and X |= B . From the fact that X |= l , it follows that X does not satisfy the rule a \u2190 l ,B , so that it is not a model of \u03a0.\n\u0131Proof of Proposition 2 Parts (a) and (c) are proved as in the proof of Proposition 1, using Lemma 2. (b) Let M be a terminal state so that none of the rules are applicable. From the\nfact that Decide is not applicable, we conclude that M assigns all literals. Since neither Backtrack nor Fail is applicable, M is consistent. Consequently, M is an assignment. Since Unit Propagate LP is not applicable, it follows that for every rule a \u2190 B \u2208 \u03a0, if B \u2286 M then a \u2208 M . Consequently, if M |= B then M |= a. We conclude that M is a model of \u03a0. We will now show that M is a supported model of \u03a0. By contradiction. Suppose that M is not a supported model. Then, there is an atom a \u2208 M such that M 6|= B for every B \u2208 Bodies(\u03a0, a). Since M is consistent, B \u2229 M 6= \u2205 for every B \u2208 Bodies(\u03a0, a). Consequently, All Rules Cancelled is applicable. This contradicts the assumption that M is terminal.\nThe fact that the assertion of Proposition 2 remains true if we drop the transition rules Backchain True and Backchain False from the definition of atleast\u03a0 follows from the proof of Proposition 2 (b) that does not refer to those rules.\n3.2 Relation between dpF and atleast\u03a0\nIt is well known that the supported models of a program can be characterized as models of program\u2019s completion in the sense of (Clark 1978). It turns out that the graph atleast\u03a0 is identical to the graph dpF , where F is the (clausified) completion of \u03a0. To make this claim precise, we first review the notion of completion.\nFor any program \u03a0, its completion consists of \u03a0 and the formulas that can be\nwritten as\n\u00aca \u2228 \u2228\nB\u2208Bodies(\u03a0,a)\nB (11)\nfor every atom a in \u03a0. \u0131CNF \u2212 Comp(\u03a0) is the completion converted to CNF using straightforward equivalent transformations. In other words, \u0131CNF \u2212 Comp(\u03a0) consists of clauses of two kinds:\n1. the rules a \u2190 B of the program written as clauses\na \u2228 B , (12)\n2. formulas (11) converted to CNF using the distributivity of disjunction over\nconjunction11.\nProposition 3 For any program \u03a0, the graphs atleast\u03a0 and dpCNF-Comp(\u03a0) are equal.\nFor instance, let \u03a0 be the program\na \u2190 b, not c b. (13)\nIts completion is\n(a \u2194 b \u2227 \u00acc) \u2227 b \u2227 \u00acc, (14)\n11 It is essential that repetitions are not removed in the process of clausification. For instance, \u0131CNF \u2212 Comp(a \u2190 not a) is the formula (a \u2228 a) \u2227 (\u00aca \u2228 \u00aca).\nand \u0131CNF \u2212 Comp(\u03a0) is\n(a \u2228 \u00acb \u2228 c) \u2227 (\u00aca \u2228 b) \u2227 (\u00aca \u2228 \u00acc) \u2227 b \u2227 \u00acc. (15)\nProposition 3 asserts that atleast\u03a0 coincides with dpCNF-Comp(\u03a0).\nFrom Proposition 3, it follows that applying the Atleast algorithm to a program\nessentially amounts to applying dpll to its completion.\nIn the rest of this section we give a proof of Proposition 3.\nIt is easy to see that the states of the graphs atleast\u03a0 and dpCNF-Comp(\u03a0) coincide. We will now show that the edges of atleast\u03a0 and dpCNF-Comp(\u03a0) coincide also.\nIt is clear that there is an edge M =\u21d2 M \u2032 in atleast\u03a0 justified by the rule Decide if and only if there is an edge M =\u21d2 M \u2032 in dpCNF-Comp(\u03a0) justified by Decide. The same holds for the transition rules Fail and Backtrack .\nWe will now show that if there is an edge from a state M to a state M \u2032 in the graph dpCNF-Comp(\u03a0) justified by the transition rule Unit Propagate then there is an edge from M to M \u2032 in atleast\u03a0. Consider a clause C \u2228 l \u2208 \u0131CNF \u2212 Comp(\u03a0) such that C \u2286 M . We will consider two cases, depending on whether C \u2228 l comes from (12) or from the CNF of (11).\nCase 1. C \u2228 l is a \u2228 B corresponding to a rule a \u2190 B . Case 1.1. l is a. Then there is an edge from M to M \u2032 in atleast\u03a0 justified by\nthe transition rule Unit Propagate LP .\nCase 1.2. l is an element of B . Then B has the form l ,D and C is a \u2228D . From C \u2286 M we conclude that D \u2286 M and \u00aca \u2208 M . There is an edge from M to M \u2032 in the graph atleast\u03a0 justified by the following instance of Backchain False:\nM =\u21d2 M l if\n\n\n\na \u2190 l ,D \u2208 \u03a0, \u00aca \u2208 M , D \u2286 M .\nCase 2. C \u2228 l has the form \u00aca \u2228D , where D is one of the clauses of the CNF of \u2228\nB\u2208Bodies(\u03a0,a)\nB .\nThen D has the form \u2228\nB\u2208Bodies(\u03a0,a)\nf (B)\nwhere f is a function that maps every B \u2208 Bodies(\u03a0, a) to an element of B .\nCase 2.1. l is \u00aca. Then C is D , so that D \u2286 M . Consequently f (B) \u2208 B \u2229 D \u2286 B \u2229M , so that B \u2229M 6= \u2205 for every B \u2208 Bodies(\u03a0, a). There is an edge from M to M \u2032 in atleast\u03a0 justified by All Rules Cancelled .\nCase 2.2. l is an element of D . From the construction of D , it follows that l =\nf (B) \u2208 B for some rule a \u2190 B . Then C is\n\u00aca \u2228 \u2228\nB \u2032\u2208Bodies(\u03a0,a)\\B\nf (B \u2032).\nFrom C \u2286 M we conclude that a \u2208 M and that f (B \u2032) \u2208 M for every B \u2032 \u2208\nBodies(\u03a0, a)\\B . Since f (B \u2032) is a conjunctive term of B \u2032, it follows that B \u2032\u2229M 6= \u2205. Then there is an edge from M to M \u2032 in atleast\u03a0 justified by Backchain True.\nWe will now show that if there is an edge from a state M to a state M \u2032 in the graph atleast\u03a0 justified by one of the transition rules Unit Propagate LP , All Rules Cancelled , Backchain True, and Backchain False then there is an edge from M to M \u2032 in dpCNF-Comp(\u03a0).\nCase 1. The edge is justified byUnit Propagate LP . Then there is a rule a \u2190 B \u2208 \u03a0\nwhere B \u2286 M , and M \u2032 is M a. By the construction of \u0131CNF \u2212 Comp(\u03a0), a \u2228 B \u2208 \u0131CNF \u2212 Comp(\u03a0). There is an edge from M to M \u2032 in dpCNF-Comp(\u03a0) justified by the following instance of Unit Propagate:\nM =\u21d2 M a if\n{\nB \u2228 a \u2208 \u0131CNF \u2212 Comp(\u03a0) and B \u2286 M .\nCase 2. The edge is justified by All Rules Cancelled . By the definition of All Rules Cancelled , there is an atom a such that for all B \u2208 Bodies(\u03a0, a), B \u2229M 6= \u2205; and M \u2032 is M \u00aca. Consequently, M contains the complement of some literal in B . Denote one of such literals by f (B), so that f (B) \u2208 M . From the construction of \u0131CNF \u2212 Comp(\u03a0),\n\u00aca \u2228 \u2228\nB\u2208Bodies(\u03a0,a)\nf (B)\nbelongs to \u0131CNF \u2212 Comp(\u03a0). By the choice of f ,\n\u2228\nB\u2208Bodies(\u03a0,a)\nf (B) \u2286 M .\nThere is an edge from M to M \u2032 in dpCNF-Comp(\u03a0) justified by the following instance of Unit Propagate:\nM =\u21d2 M \u00aca if\n\n     \n     \n\u2228\nB\u2208Bodies(\u03a0,a)\nf (B) \u2228 \u00aca \u2208 \u0131CNF \u2212 Comp(\u03a0),\n\u2228\nB\u2208Bodies(\u03a0,a)\nf (B) \u2286 M .\nCase 3. The edge is justified by Backchain True. By the definition of Backchain True, there is a rule a \u2190 B \u2208 \u03a0 and a literal l \u2208 B such that a \u2208 M ; for all B \u2032 \u2208 Bodies(\u03a0, a) \\ B , B \u2032 \u2229M 6= \u2205; and M \u2032 is M l . Let f (B \u2032) be an element of B \u2032 such that f (B \u2032) \u2208 M . From the construction of \u0131CNF \u2212 Comp(\u03a0),\n\u00aca \u2228 l \u2228 \u2228\nB \u2032\u2208Bodies(\u03a0,a)\\B\nf (B \u2032)\nbelongs to \u0131CNF \u2212 Comp(\u03a0). By the choice of f ,\n\u2228\nB \u2032\u2208Bodies(\u03a0,a)\\B\nf (B \u2032) \u2286 M .\nThere is an edge from M to M \u2032 in dpCNF-Comp(\u03a0) justified by the following instance\nof Unit Propagate:\nM =\u21d2 M l if\n\n     \n     \n\u00aca \u2228 l \u2228 \u2228\nB \u2032\u2208Bodies(\u03a0,a)\\B\nf (B \u2032) \u2208 \u0131CNF \u2212 Comp(\u03a0),\n(\u00aca \u2228 \u2228\nB \u2032\u2208Bodies(\u03a0,a)\\B\nf (B \u2032)) \u2286 M .\nCase 4. The edge is justified by Backchain False. By the definition of Backchain False, there is a rule a \u2190 l ,B \u2208 \u03a0 such that \u00aca \u2208 M , B \u2286 M , and M \u2032 is M l . By the construction of \u0131CNF \u2212 Comp(\u03a0), a \u2228 B \u2228 l \u2208 \u0131CNF \u2212 Comp(\u03a0). There is an edge from M to M \u2032 in dpCNF-Comp(\u03a0) justified by the following instance of Unit Propagate:\nM =\u21d2 M l if\n{\na \u2228 B \u2228 l \u2208 \u0131CNF \u2212 Comp(\u03a0) and\na \u2228 B \u2286 M ."}, {"heading": "4 Answer Set Solver Smodels", "text": ""}, {"heading": "4.1 Abstract Smodels", "text": "We now describe the graph sm\u03a0 that represents the application of the smodels algorithm to program \u03a0. sm\u03a0 is a graph whose nodes are the same as the nodes of the graph atleast\u03a0. The edges of sm\u03a0 are described by the transition rules of atleast\u03a0 and the additional transition rule:\nUnfounded :\nM =\u21d2 M \u00aca if\n{\nM is consistent, and a \u2208 U for a set U unfounded on M w.r.t. \u03a0.\nThis transition rule of sm\u03a0 is closely related to procedure Atmost (Simons 2000, Sections 4.2), which together with the procedure Atleast forms the core of the smodels algorithm.\nThe graph sm\u03a0 can be used for deciding whether program \u03a0 has an answer set\nby constructing a path from \u2205 to a terminal node:\nProposition 4 For any program \u03a0,\n(a) graph sm\u03a0 is finite and acyclic, (b) for any terminal state M of sm\u03a0 other than FailState, M + is an answer set\nof \u03a0,\n(c) FailState is reachable from \u2205 in sm\u03a0 if and only if \u03a0 has no answer sets.\nTo illustrate the difference between sm\u03a0 and atleast\u03a0, assume again that \u03a0 is program (8). Path (10) in the graph atleast\u03a0 is also a path in sm\u03a0. But state a\u2206c\u00acbd\u2206, which is terminal in atleast\u03a0, is not terminal in sm\u03a0. This is not\nsurprising, since {a, c,\u00acb, d}+ = {a, c, d} is not an answer set of \u03a0. To get to a state that is terminal in sm\u03a0, we need two more steps:\n... a\u2206c\u00acbd\u2206 =\u21d2 (Unfounded, U = {d}) a\u2206c\u00acbd\u2206\u00acd =\u21d2 (Backtrack) a\u2206c\u00acb\u00acd\n(16)\nProposition 4(b) asserts that {a, c} is an answer set of \u03a0.\nThe assertion of Proposition 4 will remain true if we drop the transition rules All Rules Cancelled , Backchain True, and Backchain False from the definition of sm\u03a0.\nIn the rest of this section we give a proof of Proposition 4. We say that a model M of a program \u03a0 is unfounded-free if no non-empty subset\nof M is an unfounded set on M w.r.t. \u03a0.\nLemma 3 (Corollary 2 from (Sacca\u0301 and Zaniolo 1990)) For any model M of a program \u03a0, M+ is an answer set for \u03a0 if and only if M is unfounded-free.\nLemma 4 For any unfounded set U on a consistent set M of literals w.r.t. a program \u03a0, and any assignment X , if X |= M and X \u2229U 6= \u2205, then X+ is not an answer set for \u03a0."}, {"heading": "Proof", "text": "Assume that X+ is an answer set for \u03a0. Then X is a model of \u03a0. By Lemma 3, it follows that X is unfounded-free. Hence any non-empty subset of X including X \u2229 U is not unfounded on X . This means that for some rule a \u2190 B in \u03a0 such that a \u2208 X \u2229 U , B \u2229 X = \u2205 and X \u2229 U \u2229 B+ = \u2205. From X |= M (M \u2286 X ) and B \u2229X = \u2205 we conclude that B \u2229M = \u2205. Since B \u2229X = \u2205 and X is an assignment, B \u2286 X . It follows that B+ \u2286 X . Consequently U \u2229 B+ = X \u2229 U \u2229 B+ = \u2205. This contradicts the assumption that U is an unfounded set on M .\nLemma 5 For any program \u03a0, any state l1 . . . ln reachable from \u2205 in sm\u03a0, and any assignment X , if X+ is an answer set for \u03a0 then X satisfies li if it satisfies all decision literals l\u2206j with j \u2264 i ."}, {"heading": "Proof", "text": "By induction on the path from \u2205 to l1 . . . ln . Recall that for any assignment X , if X+ is an answer set for \u03a0, then X is a supported model of \u03a0, and that the transition system sm\u03a0 extends atleast\u03a0 only by the transition rule Unfounded . Given our proof of Lemma 2, we only need to demonstrate that application of Unfounded preserves the property.\nConsider a transition M =\u21d2 M \u2032 justified by Unfounded , where M is a sequence l1 . . . lk . M \u2032 is M \u00aca, such that a \u2208 U , where U is an unfounded set on M w.r.t \u03a0. Take any assignment X such that X+ is an answer set for \u03a0 and X satisfies all\ndecision literals l\u2206j with j \u2264 k . By the inductive hypothesis, X |= M . Then X |= \u00aca. Indeed, otherwise a would be a common element of X and U , and X \u2229 U would be non-empty, which contradicts Lemma 4.\n\u0131Proof of Proposition 4 Parts (a) and (c) are proved as in the proof of Proposition 1, using Lemma 5. (b) As in the proof of Proposition 2(b) we conclude that M is a model of \u03a0. Assume that M+ is not an answer set. Then, by Lemma 3, there is a non-empty unfounded set U on M w.r.t. \u03a0 such that U \u2286 M . It follows that Unfounded is applicable (with an arbitrary a \u2208 U ). This contradicts the assumption that M is terminal.\nThe fact that the assertion of Proposition 4 remains true if we drop the transition rules All Rules Cancelled , Backchain True, and Backchain False from the definition of sm\u03a0 follows from the proof of Proposition 4 (b) that does not refer to those rules."}, {"heading": "4.2 Smodels Algorithm", "text": "We can view a path in the graph sm\u03a0 as a description of a process of search for an answer set for a program \u03a0 by applying inference rules. Therefore, we can characterize the algorithm of an answer set solver that utilizes the inference rules of sm\u03a0 by describing a strategy for choosing a path in sm\u03a0. A strategy can be based, in particular, on assigning priorities to some or all inference rules of sm\u03a0, so that a solver will never apply a transition rule in a state if a rule with higher priority is applicable to the same state.\nWe use this method to describe the smodels algorithm. System smodels assigns\npriorities to the inference rules of sm\u03a0 as follows:\nBacktrack,Fail \u226b Unit Propagate LP,All Rules Cancelled,Backchain True,Backchain False \u226b Unfounded \u226b Decide.\nFor example, let \u03a0 be program (8). The smodels algorithm may follow a path\n\u2205 =\u21d2 (Decide) a\u2206 =\u21d2 (Unit Propagate LP) a\u2206c =\u21d2 (All Rules Cancelled) a\u2206c\u00acb =\u21d2 (Unfounded) a\u2206c\u00acb\u00acd\nin the graph sm\u03a0, whereas it may never follow path (10), because Unfounded has a higher priority than Decide."}, {"heading": "4.3 Tight Programs", "text": "We will now review the definitions of a positive dependency graph and a tight program. The positive dependency graph of a program \u03a0 is the directed graph G such that\n\u2022 the nodes of G are the atoms occurring in \u03a0, and \u2022 G contains the edges from a to bi (1 \u2264 i \u2264 l) for each rule\na \u2190 b1, . . . , bl , not bl+1, . . . , not bm\nin \u03a0 where a is an atom.\nA program is tight if its positive dependency graph is acyclic. For instance, program (8) is not tight since its positive dependency graph has a cycle due to the rule d \u2190 d . On the other hand, the program constructed from (8) by removing this rule is tight.\nRecall that for any program \u03a0 and any assignmentM , ifM+ is an answer set of \u03a0 then M is a supported model of \u03a0. For the case of tight programs, the converse holds also: M+ is an answer set for \u03a0 if and only if M is a supported model of \u03a0 (Fages 1994) or, in other words, is a model of the completion of \u03a0.\nIt turns out that for tight programs the graph sm\u03a0 is \u201calmost identical\u201d to the graph dpF , where F is the clausified completion of \u03a0. To make this claim precise, we need the following terminology.\nWe say that an edge M =\u21d2 M \u2032 in the graph sm\u03a0 is singular if\n\u2022 the only transition rule justifying this edge is Unfounded , and \u2022 some edge M =\u21d2 M \u2032\u2032 can be justified by a transition rule other than Un-\nfounded or Decide.\nFor instance, let \u03a0 be the program\na \u2190 b b \u2190 c.\nThe edge\na\u2206b\u2206\u00acc\u2206 =\u21d2 (Unfounded, U = {a, b}) a\u2206b\u2206\u00acc\u2206\u00aca\nin the graph sm\u03a0 is singular, because the edge\na\u2206b\u2206\u00acc\u2206 =\u21d2 (All Rules Cancelled) a\u2206b\u2206\u00acc\u2206\u00acb\nbelongs to sm\u03a0 also.\nWith respect to the actual smodels algorithm (Simons 2000), singular edges of the graph sm\u03a0 are inessential: in view of priorities for choosing a path in sm\u03a0 described in Section 4.2 smodels never follows a singular edge. Indeed, the transition rule Unfounded has the lower priority than any other transition rule but Decide. By sm\u2212\u03a0 we denote the graph obtained from sm\u03a0 by removing all singular edges.\nProposition 5 For any tight program \u03a0, the graph sm\u2212\u03a0 is equal to each of the graphs atleast\u03a0 and dpCNF-Comp(\u03a0).\nFor instance, let \u03a0 be the program (13). This program is tight, its completion is (14), and \u0131CNF \u2212 Comp(\u03a0) is formula (15). Proposition 5 asserts that, sm\u2212\u03a0 coincides with dpCNF-Comp(\u03a0) and with atleast\u03a0.\nFrom Proposition 5, it follows that applying the smodels algorithm to a tight program essentially amounts to applying dpll to its completion. A similar relationship, in terms of pseudocode representations of smodels and dpll, is established in (Giunchiglia and Maratea 2005).\nIn the rest of this section we give a proof of Proposition 5.\nLemma 6\nFor any tight program \u03a0 and any non-empty unfounded set U on a consistent set M of literals w.r.t. \u03a0 there is an atom a \u2208 U such that for every B \u2208 Bodies(\u03a0, a), B \u2229M 6= \u2205."}, {"heading": "Proof", "text": "By contradiction. Assume that, for every a \u2208 U there exists B \u2208 Bodies(\u03a0, a) such that B \u2229M = \u2205. By the definition of an unfounded set it follows that for every atom a \u2208 U there is B \u2208 Bodies(\u03a0, a) such that U \u2229B+ 6= \u2205. Consequently the subgraph of the positive dependency graph of \u03a0 induced by U has no terminal nodes. Then, the program \u03a0 is not tight.\n\u0131Proof of Proposition 5 In view of Proposition 3, it is sufficient to prove that sm\u2212\u03a0 equals atleast\u03a0; or, in other words, that every edge of sm\u03a0 justified by the rule Unfounded only is singular. Consider such an edge M =\u21d2 M \u2032. We need to show that some transition rule other than Unfounded or Decide is applicable to M . By the definition of Unfounded , M is consistent and there exists a non-empty set U unfounded on M w.r.t. \u03a0. By Lemma 6, it follows that there is an atom a \u2208 U such that for every B \u2208 Bodies(\u03a0, a), B \u2229M 6= \u2205. Therefore, the transition rule All Rules Cancelled is applicable to M ."}, {"heading": "5 Generate and Test", "text": "In this section, we present a modification of the graph dpF (Section 2.1) that includes testing \u201cpartial\u201d assignments of F found by dpll.\nLet F be a CNF formula, and let G be a formula formed from atoms occurring in F . The terminal nodes of the graph gtF ,G defined below are models of formula F \u2227G.\nThis modification of the graph dpF is of interest, for example, in connection with the fact that answer sets of a program \u03a0 can be characterized as models of its completion extended by so called loop formulas of \u03a0 (Lin and Zhao 2002). If \u0131CNF \u2212 Comp(\u03a0), as above, is the completion converted to CNF, and LF (\u03a0) is the conjunction of all loop formulas of \u03a0, then for any assignment M , M+ is an answer set of \u03a0 iff M is a model of \u0131CNF \u2212 Comp(\u03a0)\u2227LF (\u03a0). Hence, the terminal nodes of the graph gtCNF-Comp(\u03a0),LF(\u03a0) will correspond to answer sets of \u03a0.\nThe nodes of the graph gtF ,G are the same as the nodes of the graph dpF . The edges of gtF ,G are described by the transition rules of dpF and the additional\ntransition rule:\nTest :\nM =\u21d2 M l if\n\n\n\nM is consistent, G |= M , l \u2208 M\nIt is easy to see that the graph dpF is a subgraph of gtF ,G . The latter graph can be used for deciding whether a formula F \u2227 G has a model by constructing a path from \u2205 to a terminal node:\nProposition 6 For any CNF formula F and a formula G formed from atoms occurring in F ,\n(a) graph gtF ,G is finite and acyclic, (b) any terminal state of gtF ,G other than FailState is a model of F \u2227G, (c) FailState is reachable from \u2205 in gtF ,G if and only if F \u2227G is unsatisfiable.\nNote that to verify the applicability of the new transition rule Test we need a procedure for testing whether G entails a clause, but there is no need to explicitly write out G. This is important because LF (\u03a0) can be very long (Lin and Zhao 2002).\nFor instance, let \u03a0 be the nontight program\nd \u2190 d .\nIts completion is\nd \u2194 d ,\nand \u0131CNF \u2212 Comp(\u03a0) is\n(d \u2228 \u00acd).\nThis program has one loop formula\nd \u2192 \u22a5.\nProposition 6 asserts that a terminal state \u00acd of gtCNF-Comp(\u03a0),d\u2192\u22a5 is a model of \u0131CNF \u2212 Comp(\u03a0)\u2227LF (\u03a0). It follows that {\u00acd}+ = \u2205 is an answer set of \u03a0. To compare with the graph dpCNF-Comp(\u03a0): state d is a terminal state in dpCNF-Comp(\u03a0) whereas d is not a terminal state in gtCNF-Comp(\u03a0),d\u2192\u22a5 because the transition rule Test is applicable to this state.\nasp-sat with Backtracking (Giunchiglia et al. 2006) is a procedure that computes models of the completion of the given program using dpll, and tests them until an answer set is found. The application of this procedure to a program \u03a0 can be viewed as constructing a path from \u2205 to a terminal node in the graph gtCNF-Comp(\u03a0),LF(\u03a0) by adopting a strategy that Test is applied to a state M only when M is an assignment.\nIn the rest of this section we give a proof of Proposition 6.\nLemma 7 For any CNF formula F , a formula G formed from atoms occurring in F , and a path from \u2205 to a state l1 . . . ln in gtF ,G , any model X of F \u2227 G satisfies li if it satisfies all decision literals l\u2206j with j \u2264 i ."}, {"heading": "Proof", "text": "By induction on the path from \u2205 to l1 . . . ln . Similar to the proof of Lemma 1. We will show that the property in question is preserved by the transition rule Test .\nTake a model X of F \u2227 G and consider an edge M =\u21d2 M \u2032 where M is a list\nl1 . . . lk such that X satisfies li if it satisfies all decision literals l \u2206 j with j \u2264 i .\nAssume that X satisfies all decision literals from M . By the inductive hypothesis, X |= M . We will show that the rule justifying the transition from M to M \u2032 is different from Test . By contradiction. M \u2032 is M l . By the definition of Test , G |= M . Since X is a model of F \u2227G it follows that X |= M . This contradicts the fact that X |= M .\n\u0131Proof of Proposition 6 Part (a) and part (c) Right-to-left are proved as in the proof of Proposition 1. (b) Let M be any terminal state other than FailState. As in the proof of Proposition 1(b) it follows thatM is a model of F . The transition rule Test is not applicable. Hence G 6|= M . In other words M is a model of G. We conclude that M is a model of F \u2227G (c) Left-to-right: Since FailState is reachable from \u2205, there is a state M without decision literals such that M is reachable from \u2205 and the transition rule Fail is applicable in M . Then, M is inconsistent. By Lemma 7, any model of F \u2227 G satisfies M . Since M is inconsistent we conclude F \u2227G is unsatisfiable."}, {"heading": "6 Review: Abstract DPLL with Learning", "text": "Most modern SAT solvers implement such sophisticated techniques as backjumping and learning:\nBackjumping: Chronological Backtracking (used in classical dpll) can be seen as a prototype of Backjumping. Unlike Backtracking that undoes only the previously made decision, Backjumping is generally able to backtrack further in the search tree by undoing several decisions at once. Learning: Most modern SAT solvers implement so called conflict-driven backjumping and learning: whenever backjumping is performed they add (learn) a \u201cbackjump clause\u201d to the clause database of a solver. Learning backjump clauses prevents a solver from reaching \u201csimilar\u201c inconsistent states.\nIn this section we will extend the graph dpF to capture the ideas behind backjumping and learning. The new graph will be closely related to the DPLL System with Learning graph introduced in (Nieuwenhuis et al. 2006, Section 2.4).\nWe first note that the graph dpF is not adequate to capture such technique as learning since it is incapable to reflect a change in a state of computation related to newly learned clauses. We start by redefining a state so that it incorporates information about changes performed on a clause database.\nFor a CNF formula F , an augmented state relative to F is either a distinguished state FailState or a pair M ||\u0393 where M is a record relative to the set of atoms occurring in F , and \u0393 is a (multi-)set of clauses over atoms of F that are entailed by F .\nWe now define a graph dplF for any CNF formula F . Its nodes are the augmented states relative to F . The transition rules Decide and Fail of dpF are extended to dplF as follows: M ||\u0393 =\u21d2 M \u2032||\u0393 (M ||\u0393 =\u21d2 FailState) is an edge in dplF justified by Decide (Fail) if and only if M =\u21d2 M \u2032 (M =\u21d2 FailState) is an edge in dpF justified by Decide (Fail). Figure 3 presents the other transition rules of dplF . We refer to the transition rules Unit Propagate \u03bb, Backjump, Decide, and Fail of the graph dplF as Basic. We say that a node in the graph is semi-terminal if no rule other than Learn is applicable to it.\nWe will omit the word \u201caugmented\u201d before \u201cstate\u201d when this is clear from a\ncontext.\nThe graph dplF can be used for deciding the satisfiability of a formula F simply\nby constructing an arbitrary path from node \u2205||\u2205 to a semi-terminal node:\nProposition 7\nFor any CNF formula F ,\n(a) every path in dplF contains only finitely many edges justified by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||\u0393 of dplF reachable from \u2205||\u2205, M is a model\nof F ,\n(c) FailState is reachable from \u2205||\u2205 in dplF if and only if F is unsatisfiable.\nOn the one hand, Proposition 7 (a) asserts that if we construct a path from \u2205||\u2205 so that Basic transition rules periodically appear in it then some semi-terminal state will be eventually reached. On the other hand, Proposition 7 (b) and (c) assert that as soon as a semi-terminal state is reached the problem of deciding whether formula F is satisfiable is solved. The proof of this proposition is similar to the proof of Theorem 2.12 from (Nieuwenhuis et al. 2006).\nFor instance, let F be the formula\na \u2228 b \u00aca \u2228 c.\nHere is a path in dplF :\n\u2205||\u2205 =\u21d2 (Learn) \u2205||b \u2228 c =\u21d2 (Decide) \u00acb\u2206||b \u2228 c =\u21d2 (Unit Propagate \u03bb) \u00acb\u2206c||b \u2228 c =\u21d2 (Unit Propagate \u03bb) \u00acb\u2206ca||b \u2228 c\n(17)\nSince the state \u00acb\u2206ca is semi-terminal, Proposition 7 (b) asserts that {\u00acb, c, a} is a model of F .\nRecall that the transition rule Backtrack of the graph dpF \u2013 a prototype of Backjump \u2013 is applicable in any inconsistent state with a decision literal in dpF . The transition rule Backjump, on the other hand, is applicable in any inconsistent state with a decision literal that is reachable from \u2205||\u2205 (the proof of this statement is similar to the proof of Lemma 2.8 from (Nieuwenhuis et al. 2006)). The application of Backjump where l\u2206 is the last decision literal and l \u2032 is l can be seen as an application of Backtrack . This fact shows that Backjump is essentially a generalization of Backtrack . The subgraph of dpF induced by the nodes reachable from \u2205 is basically a subgraph of dplF ."}, {"heading": "7 Answer Set Solver with Learning", "text": "In this section we will extend the graph sm\u03a0 to capture backjumping and learning. As a result we will be able to model the algorithms of systems smodelscc and sup."}, {"heading": "7.1 Graph sml\u03a0", "text": "An (augmented) state relative to a program \u03a0 is either a distinguished state FailState or a pair of the form M ||\u0393 where M is a record relative to the set of atoms occurring in \u03a0, and \u0393 is a (multi-)set of constraints formed from atoms occurring in \u03a0 that are entailed by \u03a0.\nFor any program \u03a0, we will define a graph sml\u03a0. Its nodes are the augmented states relative to \u03a0. The transition rules Unit Propagate LP, All Rules Cancelled, Backchain True, Unfounded, Decide and Fail of sm\u03a0 are extended to sml\u03a0 as follows: M ||\u0393 =\u21d2 M \u2032||\u0393 (M ||\u0393 =\u21d2 FailState) is an edge in sml\u03a0 justified by a transition rule T if and only if M =\u21d2 M \u2032 (M =\u21d2 FailState) is an edge in sm\u03a0 justified by T . Figure 4 presents the other transition rules of sml\u03a0.\nWe refer to the transition rulesUnit Propagate LP, All Rules Cancelled, Backchain True, Backchain False \u03bb, Unfounded, Backjump LP, Decide, and Fail of the graph sml\u03a0 as Basic. We say that a node in the graph is semi-terminal if no rule other than Learn LP is applicable to it.\nThe graph sml\u03a0 can be used for deciding whether a program \u03a0 has an answer\nset by constructing a path from \u2205||\u2205 to a semi-terminal node:\nProposition 8 For any program \u03a0,\n(a) every path in sml\u03a0 contains only finitely many edges labeled by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||\u0393 of sml\u03a0 reachable from \u2205||\u2205, M + is an\nanswer set of \u03a0,\n(c) FailState is reachable from \u2205||\u2205 in sml\u03a0 if and only if \u03a0 has no answer sets.\nThus if we construct a path from \u2205||\u2205 so that Basic transition rules periodically appear in it then some semi-terminal state will be eventually reached; as soon as a semi-terminal state is reached the problem of finding an answer set is solved.\nFor instance, let \u03a0 be program (8). Here is a path in sml\u03a0 with every edge annotated by the name of a transition rule that justifies the presence of this edge in the graph :\n\u2205||\u2205 =\u21d2 (Decide) a\u2206||\u2205 =\u21d2 (Unit Propagate LP) a\u2206c||\u2205 =\u21d2 (All Rules Cancelled) a\u2206c\u00acb||\u2205 =\u21d2 (Decide) a\u2206c\u00acbd\u2206||\u2205 =\u21d2 (Unfounded) a\u2206c\u00acbd\u2206\u00acd ||\u2205 =\u21d2 (Backjump LP) a\u2206c\u00acb\u00acd ||\u2205 =\u21d2 (Learn LP) a\u2206c\u00acb\u00acd ||\u00aca \u2228 \u00acc \u2228 b \u2228 \u00acd\n(18)\nSince the state a\u2206c\u00acb\u00acd is semi-terminal, Proposition 8 (b) asserts that\n{a, c,\u00acb,\u00acd}+ = {a, c}\nis an answer set for \u03a0.\nProof of Proposition 8 is in Section 10. As in case of the graphs dpF and dplF , Backjump LP is applicable in any inconsistent state with a decision literal that is reachable from \u2205||\u2205 (Proposition 11 from Section 9), and is essentially a generalization of the transition rule Backtrack of the graph sm\u03a0.\nModern SAT solvers often implement such sophisticated techniques as restart\nand forgetting in addition to backjumping and learning:\nRestart: A solver restarts the dpll procedure whenever the search is not making \u201cenough\u201d progress. The idea is that upon a restart a solver will explore a new part of the search space using the clauses that have been learned. Forgetting: This technique is usually implemented in relation with conflictdriven backjumping and learning. When a solver \u201cnotes\u201d that earlier learned clauses are not helpful anymore it removes (forgets) them from the clause database. Forgetting allows a solver to avoid a possible exponential space blow-up introduced by learning.\nWe may extend the graph sml\u03a0 with the following transition rules that capture\nthe ideas behind these technique:\nRestart : M ||\u0393 =\u21d2 \u2205||\u0393\nForget LP : M || \u2190 B , \u0393 =\u21d2 M ||\u0393.\nThe transition rules Restart and Forget LP are similar to the analogous rules in (Nieuwenhuis et al. 2006) for extending dpll procedure with restart and forgetting techniques. It is easy to prove a result similar to Proposition 8 for the graph sml\u03a0 with Restart and Forget LP (for such graph a state is semi-terminal if no rule other than Learn LP , Restart , Forget LP is applicable to it.)\n7.2 Smodelscc and Sup Algorithms\nIn Section 4.2 we demonstrated a method for specifying the algorithm of an answer set solver by means of the graph sm\u03a0. In particular, we described the smodels algorithm by assigning priorities to transition rules of sm\u03a0. In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of sml\u03a0.\nSystem smodelscc enhances the smodels algorithm with conflict-driven backjumping and learning. Its strategy for choosing a path in the graph sml\u03a0 is similar to that of smodels. System smodelscc assigns priorities to inference rules of sml\u03a0 as follows:\nBackjump LP,Fail \u226b Unit Propagate LP,All Rules Cancelled,Backchain True,Backchain False \u03bb \u226b Unfounded \u226b Decide.\nAlso, smodelscc always applies the transition rule Learn LP in a non-semiterminal state reached by an application of Backjump LP , because it implements conflict-driven backjumping and learning.12 In Section 11 we discuss details on which clause is being learned during the application of Learn LP .\n12 System smodelscc (sup) also implements restarts and forgetting that may be modeled by the transition rules Restart and Forget LP . An application of these transition rules in sml\u03a0 relies on particular heuristics implemented by the solver.\nIn (Lierler 2008), we introduced the simplified sup algorithm that relies on backtracking rather than conflict-driven backjumping and learning that are actually implemented in the system. We now present the sup algorithm that takes these sophisticated techniques into account.\nSystem sup assigns priorities to inference rules of sml\u03a0 as follows:\nBackjump LP,Fail \u226b Unit Propagate LP,All Rules Cancelled,Backchain True,Backchain False \u03bb \u226b Decide \u226b Unfounded.\nSimilarly to smodelscc, sup always applies the transition rule Learn LP in a\nnon-semi-terminal state reached by an application of Backjump LP .\nFor example, let \u03a0 be program (8). Path (18) corresponds to an execution of system sup, but does not correspond to any execution of smodelscc because for the latter Unfounded is a rule of higher priority than Decide. Here is another path in sml\u03a0 from \u2205||\u2205 to the same semi-terminal node:\n\u2205||\u2205 =\u21d2 (Decide) a\u2206||\u2205 =\u21d2 (Unit Propagate LP) a\u2206c||\u2205 =\u21d2 (All Rules Cancelled) a\u2206c\u00acb||\u2205 =\u21d2 (Unfounded) a\u2206c\u00acb\u00acd ||\u2205\n(19)\nPath (19) corresponds to an execution of system smodelscc, but does not correspond to any execution of system sup because for the latter Decide is a rule of higher priority than Unfounded .\nThe strategy of sup of assigning the transition rule Unfounded the lowest priority may be reasonable for many problems. For instance, it is easy to see that transition rule Unfounded is redundant for tight programs. The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al. 2006) (see Section 8.2) in the fact that it will first compute a supported model of a program and only then will test whether this model is indeed an answer set, i.e., whether Unfounded is applicable in this state."}, {"heading": "8 Generate and Test with Learning", "text": "In this section we model backjumping and learning for the generate and test procedure by defining a graph gtlF ,G that extends gtF ,G (Section 5) in a similar manner as dplF (Section 6) extends dpF .\n8.1 Graph gtlF ,G\nAn (augmented) state relative to a CNF formula F and a formula G formed from atoms occurring in F is either a distinguished state FailState or a pair of the form M ||\u0393, where M is a record (Section 2.1) relative to the set of atoms occurring in F , and \u0393 is a (multi-)set of clauses formed from atoms occurring in F that are entailed by F \u2227G.\nThe nodes of the graph gtlF ,G are the augmented states relative to a CNF formula F and a formula G formed from atoms occurring in F . The edges of gtlF ,G are described by the transition rules Unit Propagate \u03bb, Decide, Fail of dplF , the transition rules\nBackjump GT :\nP l\u2206Q ||\u0393 =\u21d2 P l \u2032||\u0393 if\n{\nP l\u2206Q is inconsistent and F \u2227G |= l \u2032 \u2228 P\nLearn GT :\nM ||\u0393 =\u21d2 M ||C , \u0393 if\n{\nevery atom in C occurs in F and F \u2227G |= C\nand the transition rule Test of gtF ,G that is extended to gtlF ,G as follows: M ||\u0393 =\u21d2 M \u2032||\u0393 is an edge in gtlF ,G justified by Test if and only if M =\u21d2 M \u2032 is an edge in gtF ,G justified by Test .\nWe refer to the transition rules Unit Propagate \u03bb, Test, Decide, Fail , Backjump GT of the graph gtlF ,G as Basic. We say that a node in the graph is semi-terminal if no rule other than Learn GT is applicable to it.\nThe graph gtlF ,G can be used for deciding whether a formula F \u2227G has a model\nby constructing a path from \u2205||\u2205 to a terminal node:\nProposition 9 For any CNF formula F and a formula G formed from atoms occurring in F ,\n(a) every path in gtlF ,G contains only finitely many edges labeled by Basic\ntransition rules,\n(b) for any semi-terminal state M ||\u0393 of gtlF ,G reachable from \u2205||\u2205, M is a model\nof F \u2227G,\n(c) FailState is reachable from \u2205||\u2205 in gtlF ,G if and only if F \u2227G is unsatisfiable.\nAs in case of the graph dplF , the transition rule Backjump GT is applicable in any inconsistent state with a decision literal that is reachable from \u2205||\u2205. We call such states backjump states.\nProposition 10 For any CNF formula F and a formula G formed from atoms occurring in F , the transition rule Backjump GT is applicable in any backjump state in gtlF ,G .\nProofs of Propositions 9 and 10 are given in Section 13."}, {"heading": "8.2 Cmodels Algorithm", "text": "System cmodels implements an algorithm called asp-sat with Learning (Giunchiglia et al. 2006) that extends asp-sat with Backtracking by backjumping and learning.\nThe application of cmodels to a program \u03a0 can be viewed as constructing a\npath from \u2205||\u2205 to a terminal node in the graph gtlF ,G , where\n\u2022 F is the completion of \u03a0 converted to conjunctive normal form, and \u2022 G is LF (\u03a0).\nIn Sections 4.2 we demonstrated a method for specifying the algorithm of an answer set solver by means of the graph sm\u03a0. We use this method to describe the cmodels algorithm using the graph gtlF ,G . System cmodels assigns priorities to the inference rules of gtlF ,G as follows:\nBackjump GT,Fail \u226b Unit Propagate \u03bb \u226b Decide \u226b Test.\nAlso, cmodels always applies the transition rule Learn GT in a non-semi-\nterminal state reached by an application of Backjump GT .\nThe priorities imposed on the rules by cmodels guarantee that the transition rule Test is applied to a model of F\u222a\u0393 (clausified completion F extended by learned clauses \u0393). This allows cmodels to proceed with its search in case if a found model is not an answer set. Furthermore, the cmodels strategy guarantees that in a state reached by an application of Test , first Backjump GT will be applied and then in the resulting state Learn GT will be applied. The clause learned due to this application of Learn GT is derived by means of loop formulas (see (Giunchiglia et al. 2006)). In this sense cmodels uses loop formulas to guide its search.\nSystems sag (Lin et al. 2006) and clasp (Gebser et al. 2007) are answer set solvers that are enhancements of cmodels. First, they compute and clausify program\u2019s completion and then use unit propagate on resulting propositional formula as an inference mechanism. Second, they guide their search by means of loop formulas. Third, they implement conflict-driven backjumping and learning. Also, sag uses SAT solvers for search. The systems differ from cmodels in the following:\n\u2022 they maintain the data structure representing an input logic program through\nout the whole computation,\n\u2022 in addition to implementing inference rules of the graph gtlF ,G they also\nimplement the inference rule Unfounded of sm\u03a0. A hybrid graph combining the inference rule Unfounded of sm\u03a0 and the inference rules of gtlF ,G may be used to describe the sag and clasp algorithms.\nSystem sag assigns the same priorities to the inference rules of the hybrid graph as cmodels. Also, sag at random decides whether to apply the inference rule Unfounded in a state.\nOn the other hand, system clasp assigns priorities to the inference rules of the\nhybrid graph as follows:\nBackjump GT,Fail \u226b Unit Propagate \u03bb,Unfounded \u226b Decide.\nLike cmodels, both sag and clasp always apply the transition rule Learn GT\nin a non-semi-terminal state reached by an application of Backjump GT ."}, {"heading": "9 Backjumping and Extended Graph", "text": "Recall the transition rule Backjump LP of sml\u03a0\nBackjump LP :\nP l\u2206Q ||\u0393 =\u21d2 P l \u2032||\u0393 if\n{\nP l\u2206Q is inconsistent and \u03a0 entails l \u2032 \u2228 P .\nA state in the graph sml\u03a0 is a backjump state if it is inconsistent, contains a decision literal, and is reachable from \u2205||\u2205. Note that it may be not clear a priori whether Backjump LP is applicable to a backjump state and if so to which state the edge due to the application of Backjump LP leads. These questions are important if we want to base an algorithm on this framework. It turns out that Backjump LP is always applicable to a backjump state:\nProposition 11 For a program \u03a0, the transition rule Backjump LP is applicable to any backjump state in sml\u03a0.\nProposition 11 guarantees that a backjump state in sml\u03a0 is never semi-terminal. In the end of this section we show how Proposition 11 can be derived from the results proved later in this paper. Next question to answer is how to continue choosing a path in the graph after reaching a backjump state. To answer this question we introduce the notions of reason and extended graph.\nFor a program \u03a0, we say that a clause l \u2228 C is a reason for l to be in a list of literals P lQ w.r.t \u03a0 if \u03a0 entails l \u2228 C and C \u2286 P . We can equivalently restate the second condition of Backjump LP \u201c\u03a0 entails l \u2032 \u2228 P\u201d as \u201cthere exists a reason for l \u2032 to be in P l \u2032 w.r.t. \u03a0\u201d (note that l \u2032 \u2228 P is a reason for l \u2032 to be in P l \u2032). We call a reason for l \u2032 to be in P l \u2032 a backjump clause. Note that Proposition 11 asserts that a backjump clause always exists for a backjump state. It is clear that we may continue choosing a path in the graph after reaching a backjump state if we know how to compute a backjump clause for this state. We now define a graph sml\u2191\u03a0 that shares many properties of sml\u03a0 but allows us to give a simpler procedure for computing a backjump clause.\nAn extended record M relative to a program \u03a0 is a list of literals over the set of\natoms occurring in \u03a0 where\n(i) each literal l in M is annotated either by \u2206 or by a reason for l to be in M\nw.r.t. \u03a0,\n(ii) M contains no repetitions,\n(iii) for any inconsistent prefix of M its last literal is annotated by a reason.\nFor instance, let \u03a0 be the program\na \u2190 not b c.\nThe list of literals\nb\u2206a\u2206\u00acb\u00acb\u2228\u00aca\nis an extended record relative to \u03a0. On the other hand, the lists of literals\na\u2206\u00aca\u2206 a\u2206\u00acb\u00acb\u2228\u00aca b\u2206 b\u2206a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\nare not extended records.\nAn extended state relative to a program \u03a0 is either a distinguished state FailState or a pair of the form M ||\u0393 where M is an extended record relative to \u03a0, and \u0393 is the same as in the definition of an augmented state (i.e., \u0393 is a (multi-)set of constraints formed from atoms occurring in \u03a0 that are entailed by \u03a0.) It is easy to see that for any extended state S relative to a program \u03a0, the result of removing annotations from all nondecision literals of S is a state of sml\u03a0: we will denote this state by S \u2193.\nFor instance, consider program a \u2190 not b. All pairs\nFailState \u2205||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca ||\u2205 \u00aca\u2206bb\u2228a ||\u2205\nare among valid extended states relative to this program. The corresponding states S \u2193 are\nFailState \u2205||\u2205 a\u2206\u00acb||\u2205 \u00aca\u2206b||\u2205.\nWe now define a graph sml\u2191\u03a0 for any program \u03a0. Its nodes are the extended states relative to \u03a0. The transition rules of sml\u03a0 are extended to sml \u2191 \u03a0 as follows: S1 =\u21d2 S2 is an edge in sml \u2191 \u03a0 justified by a transition rule T if and only if S \u2193 1 =\u21d2 S \u2193 2 is an edge in sml\u03a0 justified by T .\nWe will omit the word \u201cextended\u201d before \u201crecord\u201d and \u201cstate\u201d when this is clear\nfrom a context.\nThe following lemma formally states the relationship between nodes of the graphs\nsml\u03a0 and sml \u2191 \u03a0:\nLemma 8 For any program \u03a0, if S \u2032 is a state reachable from \u2205||\u2205 in the graph sml\u03a0 then there is a state S in the graph sml\u2191\u03a0 such that S \u2193 = S \u2032.\nThe definitions of Basic transition rules and semi-terminal states in sml\u2191\u03a0 are\nsimilar to their definitions for sml\u03a0. Proposition 8\u2191 For any program \u03a0,\n(a) every path in sml\u2191\u03a0 contains only finitely many edges labeled by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||\u0393 of sml\u2191\u03a0, M + is an answer set of \u03a0, (c) sml\u2191\u03a0 contains an edge leading to FailState if and only if \u03a0 has no answer\nsets.\nNote that Proposition 8\u2191 (b), unlike Proposition 8 (b), is not limited to semiterminal states that are reachable from \u2205||\u2205. As in the case of the graph sml\u03a0, sml \u2191 \u03a0 can be used for deciding whether a program \u03a0 has an answer set. Furthermore, the new graph provides the means for computing a backjump clause that permits practical application of the transition rule Backjump LP : Sections 10.3\nand 11 describe the BackjumpClause (Algorithm 1) and BackjumpClauseFirstUIP (Algorithm 2) procedures that compute Decision and FirstUIP backjump clauses respectively.\nWe say that a state in the graph sml\u2191\u03a0 is a backjump state if its record is inconsistent and contains a decision literal. Unlike the definition of a backjump state in sml\u03a0, this definition does not require a backjump state to be reachable from \u2205||\u2205 in sml\u2191\u03a0. As in case of the graph sml\u03a0, any backjump state in sml \u2191 \u03a0 is not semiterminal:\nProposition 11\u2191 For a program \u03a0, the transition rule Backjump LP is applicable to any backjump state in sml\u2191\u03a0.\nProposition 8 (b), (c) and Proposition 11 easily follow from Lemma 8 and Proposition 8\u2191 (b), (c) and Proposition 11\u2191 respectively. Proof of Proposition 8 (a) is similar to the proof of Proposition 8\u2191 (a).\nNext section will present the proofs for Proposition 8\u2191, Lemma 8, and Proposition 11\u2191. It is interesting to note that the proofs of Lemma 8 and Proposition 11\u2191 implicitly provide the means for choosing a path in the graph sml\u2191\u03a0:\n\u2022 given a state M ||\u0393 and a transition rule Unit Propagate LP, All Rules Can-\ncelled, Backchain True, Backchain False \u03bb, or Unfounded applicable to M ||\u0393, the proof of Lemma 8 describes a clause that may be used to construct a record M \u2032 so that there is an edge M ||\u0393 =\u21d2 M \u2032||\u0393 due to this transition rule, \u2022 given a backjump state M ||\u0393, the proof of Proposition 11\u2191 describes a back-\njump clause that can be used to construct a record M \u2032 so that there is an edge M ||\u0393 =\u21d2 M \u2032||\u0393 due to Backjump LP .\nFurthermore, the construction of the proof of Proposition 11\u2191 paves the way for procedure BackjumpClause presented in Algorithm 1."}, {"heading": "10 Proofs of Proposition 8\u2191, Lemma 8, Proposition 11\u2191", "text": "10.1 Proof of Proposition 8\u2191\nLemma 9 For any program \u03a0, an extended record M relative to \u03a0, and every assignment X such that X+ is an answer set for \u03a0, if X satisfies all decision literals in M then X |= M ."}, {"heading": "Proof", "text": "By induction on the length ofM . The property trivially holds for \u2205. We assume that the property holds for any state with n elements. Consider any state M with n +1 elements. Let X be an assignment such that X+ is an answer set for \u03a0 and X satisfies all decision literals in M . We will now show that X |= M .\nCase 1. M has the form P l\u2206. By the inductive hypothesis, X |= P . Since X\nsatisfies all decision literals in M , X |= l .\nCase 2. M has the form P l l\u2228C . By the inductive hypothesis, X |= P . By the definition of a reason, (i) \u03a0 entails l \u2228 C and (ii) C \u2286 P . From (ii) it follows that P |= \u00acC . Consequently, X |= \u00acC . From (i) it follows that for any assignment X such that X+ is an answer set, X |= l \u2228 C . Consequently, X |= l .\nThe proof of Proposition 8\u2191 assumes the correctness of Proposition 11\u2191 that we\ndemonstrate in Section 10.3. Proposition 8\u2191 For any program \u03a0,\n(a) every path in sml\u2191\u03a0 contains only finitely many edges labeled by Basic tran-\nsition rules,\n(b) for any semi-terminal state M ||\u0393 of sml\u2191\u03a0, M + is an answer set of \u03a0, (c) sml\u2191\u03a0 contains an edge leading to FailState if and only if \u03a0 has no answer\nsets."}, {"heading": "Proof", "text": "(a) For any list N of literals by |N | we denote the length of N . Any state M ||\u0393 has the form M0 l \u2206 1 M1 . . . l \u2206 p Mp ||\u0393, where l \u2206 1 . . . l \u2206 p are all decision literals of M ; we define \u03b1(M ||\u0393) as the sequence of nonnegative integers |M0|, |M1|, . . . , |Mp |, and \u03b1(FailState) = \u221e. For any states S and S \u2032 of sml\u2191\u03a0, we understand \u03b1(S ) < \u03b1(S \u2032) as the lexicographical order. We first note that for any state M ||\u0393, value of \u03b1 is based only on the first component M of the state. Second, there is a finite number of distinct values of \u03b1 due to the fact that there is a finite number of distinct M s over \u03a0. We conclude that there is a finite number of distinct values of \u03b1 for the states of sml\u2191\u03a0, even though the number of distinct states in sml \u2191 \u03a0 is infinite.\nBy the definition of the transition rules of sml\u2191\u03a0, if there is an edge from M ||\u0393 to M \u2032||\u0393\u2032 in sml\u2191\u03a0 formed by any Basic transition rule then \u03b1(M ||\u0393) < \u03b1(M \u2032||\u0393\u2032). Then, due to the fact that there is a finite number of distinct values of \u03b1, it follows that there is only a finite number of edges due to the application of Basic rules possible in any path. (b) Let M ||\u0393 be a semi-terminal state so that none of the Basic rules are applicable. From the fact that Decide is not applicable, we conclude that M assigns all literals.\nFurthermore, M is consistent. Indeed, assume that M is inconsistent. Then, since Fail is not applicable, M contains a decision literal. Consequently, M ||\u0393 is a backjump state. By Proposition 11\u2191, the transition rule Backjump LP is applicable in M ||\u0393. This contradicts our assumption that M ||\u0393 is semi-terminal.\nAlso, M is a model of \u03a0: since Unit Propagate LP is not applicable in M ||\u0393, it\nfollows that for every rule a \u2190 B \u2208 \u03a0, if B \u2286 M then a \u2208 M .\nAssume that M+ is not an answer set. Then, by Lemma 3, there is a non-empty unfounded set U on M w.r.t. \u03a0 such that U \u2286 M . It follows that Unfounded is applicable (with an arbitrary a \u2208 U ) in M ||\u0393. This contradicts the assumption that M ||\u0393 is semi-terminal. (c) Left-to-right: There is a state M ||\u0393 in sml\u2191\u03a0 such that there is an edge between M ||\u0393 and FailState. By the definition of sml\u2191\u03a0, this edge is due to the transition rule Fail . Consequently, state M ||\u0393 is such that M is inconsistent and contains\nno decision literals. By Lemma 9, for every assignment X such that X+ is an answer set for \u03a0, X satisfies M . Since M is inconsistent we conclude that \u03a0 has no answer sets.\nRight-to-left: Consider the process of constructing a path consisting only of edges due to Basic transition rules. By (a), it follows that this path will eventually reach a semi-terminal state. By (b), this semi-terminal state cannot be different from FailState, because \u03a0 has no answer sets. We conclude that there is an edge leading to FailState."}, {"heading": "10.2 Proof of Lemma 8", "text": "The proof uses the notion of loop formula (Lin and Zhao 2004).\nGiven a set A of atoms by Bodies(\u03a0,A) we denote the set that consists of the elements of Bodies(\u03a0, a) for all a in A. Let \u03a0 be a program. For any set Y of atoms, the external support formula (Lee 2005) for Y is\n\u2228\nB\u2208Bodies(\u03a0,Y ),B+\u2229Y=\u2205\nB . (20)\nWe will denote the external support formula by ES\u03a0,Y . For any set Y of atoms, the loop formula for Y is the implication \u2228\na\u2208Y\na \u2192 ES\u03a0,Y .\nWe can rewrite this formula as the disjunction \u2227\na\u2208Y\n\u00aca \u2228 ES\u03a0,Y . (21)\nFrom the Main Theorem in (Lee 2005) we conclude:"}, {"heading": "Lemma on Loop Formulas", "text": "For any program \u03a0, \u03a0 entails loop formulas (21) for all sets Y of atoms that occur in \u03a0.\nFor a state S in the graph sml\u2191\u03a0, we say that S \u2193 in sml\u03a0 is the image of S .\nLemma 8 For any program \u03a0, if S \u2032 is a state reachable from \u2205||\u2205 in the graph sml\u03a0 then there is a state S in the graph sml\u2191\u03a0 such that S \u2193 = S \u2032."}, {"heading": "Proof", "text": "Since the property trivially holds for the initial state \u2205||\u2205, we only need to prove that all transition rules of sml\u03a0 preserve it.\nConsider an edge M ||\u0393 =\u21d2 M \u2032||\u0393\u2032 in the graph sml\u03a0 such that there is a state\nM1||\u0393 in the graph sml \u2191 \u03a0 satisfying the condition (M1||\u0393) \u2193 = M ||\u0393. We need to show that there is a state in the graph sml\u2191\u03a0 such that M \u2032||\u0393\u2032 is its image in sml\u03a0. Consider several cases that correspond to a transition rule leading from M ||\u0393 to M \u2032||\u0393\u2032:"}, {"heading": "Unit Propagate LP :", "text": "M ||\u0393 =\u21d2 M a||\u0393 if\n{\na \u2190 B \u2208 \u03a0 and B \u2286 M .\nM \u2032||\u0393\u2032 is M a||\u0393. It is sufficient to prove that M1aa\u2228B ||\u0393 is a state of sml \u2191 \u03a0. It is enough to show that a clause a \u2228B is a reason for a to be in M a. By applicability conditions of Unit Propagate LP , B \u2286 M . Since \u03a0 entails its rule a \u2190 B , \u03a0 entails a \u2228 B .\nAll Rules Cancelled :\nM ||\u0393 =\u21d2 M \u00aca||\u0393 if B \u2229M 6= \u2205 for all B \u2208 Bodies(\u03a0, a).\nM \u2032||\u0393\u2032 is M \u00aca||\u0393. Consider any B \u2208 Bodies(\u03a0, a). Since B \u2229M 6= \u2205, B contains a literal from M : call it f (B). It is sufficient to show that\n\u00aca \u2228 \u2228\nB\u2208Bodies(\u03a0,a)\nf (B) (22)\nis a reason for \u00aca to be in M \u00aca.\nFirst, by the choice of f (B), f (B) \u2208 M ; consequently, \u2228\nB\u2208Bodies(\u03a0,a)\nf (B) \u2286 M .\nSecond, since f (B) \u2208 B , the loop formula \u00aca \u2228 ES\u03a0,{a} entails (22). By Lemma\non Loop Formulas, it follows that \u03a0 entails (22).\nBackchain True:\nM ||\u0393 =\u21d2 M l ||\u0393 if\n\n  \n  \na \u2190 B \u2208 \u03a0, a \u2208 M , B \u2032 \u2229M 6= \u2205 for all B \u2032 \u2208 Bodies(\u03a0, a) \\ {B}, l \u2208 B .\nM \u2032||\u0393\u2032 is M l ||\u0393. Consider any B \u2032 \u2208 Bodies(\u03a0, a)\\B . Since B \u2032 \u2229M 6= \u2205, B \u2032 contains a literal from M : call it f (B \u2032). A clause\nl \u2228 \u00aca \u2228 \u2228\nB \u2032\u2208Bodies(\u03a0,a)\\B\nf (B \u2032) \u00b7 (23)\nis a reason for l to be in M l . The proof of this statement is similar to the case of All Rules Cancelled .\nBackchain False \u03bb:\nM ||\u0393 =\u21d2 M l ||\u0393 if\n\n\n\na \u2190 l ,B \u2208 \u03a0 \u222a \u0393, \u00aca \u2208 M or a = \u22a5, B \u2286 M .\nM \u2032||\u0393\u2032 is M l ||\u0393. A clause l \u2228B \u2228 a is a reason for l to be in M l . The proof of this statement is similar to the case of Unit Propagate LP .\nUnfounded :\nM ||\u0393 =\u21d2 M \u00aca||\u0393 if\n{\nM is consistent and a \u2208 U for a set U unfounded on M w.r.t. \u03a0.\nM \u2032||\u0393\u2032 is M \u00aca||\u0393. Consider any B \u2208 Bodies(\u03a0,U ) such that U \u2229B+ = \u2205. By the definition of an unfounded set, it follows that B \u2229M 6= \u2205. Consequently, B contains a literal from M : call it f (B). The clause\n\u00aca \u2228 \u2228\nBodies(\u03a0,U ),B+\u2229U=\u2205\nf (B) (24)\nis a reason for \u00aca to be in M \u00aca. The proof of this statement is similar to the case of All Rules Cancelled .\nBackjump LP , Decide, Fail , and Learn LP : obvious.\nThe process of turning a state of sml\u03a0 reachable from \u2205||\u2205 into a corresponding\nstate of sml\u2191\u03a0 can be illustrated by the following example: Consider a program \u03a0\na \u2190 not b b \u2190 not a, not c c \u2190 not f \u2190 k , d k \u2190 l , not b \u2190 m, not l , not b m \u2190 not k , not l\n(25)\nand a path in sml\u03a0\n\u2205||\u2205 =\u21d2 (Decide) a\u2206||\u2205 =\u21d2 (All Rules Cancelled) a\u2206\u00acb||\u2205 =\u21d2 (Decide) a\u2206\u00acbc\u2206||\u2205 =\u21d2 (Backchain True) a\u2206\u00acbc\u2206\u00acf ||\u2205 =\u21d2 (Decide) a\u2206\u00acbc\u2206\u00acf d\u2206||\u2205 =\u21d2 (Backchain False \u03bb) a\u2206\u00acbc\u2206\u00acf d\u2206\u00ack ||\u2205 =\u21d2 (Backchain False \u03bb) a\u2206\u00acbc\u2206\u00acf d\u2206\u00ack\u00acl ||\u2205 =\u21d2 (Backchain False \u03bb) a\u2206\u00acbc\u2206\u00acf d\u2206\u00ack\u00acl\u00acm||\u2205 =\u21d2 (Unit Propagate LP) a\u2206\u00acbc\u2206\u00acf d\u2206\u00ack\u00acl\u00acmm||\u2205\n(26)\nThe construction in the proof of Lemma 8 applied to the nodes in this path gives following states of sml\u2191\u03a0:\n\u2205||\u2205 a\u2206||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca ||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca c\u2206||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00acc||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd ||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k ||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k\u00acm\u00acm\u2228l\u2228b ||\u2205 a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k\u00acm\u00acm\u2228l\u2228bmm\u2228k\u2228l ||\u2205\n(27)\nIt is clear that these nodes form a path in sml\u2191\u03a0 with every edge justified by the\nsame transition rule as the corresponding edge in path (26) in sml\u03a0."}, {"heading": "10.3 Proof of Proposition 11\u2191", "text": "In this section \u03a0 is an arbitrary and fixed logic program.\nFor a record M , by lcp(M ) we denote its largest consistent prefix. We say that a clause C is conflicting on a list M of literals if \u03a0 entails C , and C \u2286 lcp(M ). For example, let M be the first component of the last state in (27):\na\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k\u00acm\u00acm\u2228l\u2228bmm\u2228k\u2228l . (28)\nThen, lcp(M ) is obtained by dropping the last element mm\u2228k\u2228l of M . It is clear that the reason m \u2228 k \u2228 l for m to be in M is a conflicting clause on M .\nLemma 10\nThe literal that immediately follows lcp(M ) in an inconsistent record M , has the form lC where C is a conflicting clause on M ."}, {"heading": "Proof", "text": "By the requirement (iii) of the definition of an extended record, the literal that immediately follows lcp(M ) may not be annotated by \u2206. Consequently, the literal has the form lC . We now show that C is a conflicting clause on M . Since C is a reason for l to be in lcp(M )lC , it immediately follows that \u03a0 entails C , C can be written as l\u2228C \u2032, and C \u2032 \u2286 lcp(M ). Since l immediately follows the largest consistent prefix of M , l \u2208 lcp(M ). Consequently, C \u2286 lcp(M ). We conclude that C is indeed a conflicting clause on M .\nFor any inconsistent record l1 \u00b7 \u00b7 \u00b7 ln and any conflicting clause C on this record, by \u03b2l1\u00b7\u00b7\u00b7ln (C ) we denote the set of numbers i such that li \u2208 C . (It is clear that every element from C equals to one of the literals in l1 \u00b7 \u00b7 \u00b7 ln .) The relation I < J between subsets I , J of {1 \u00b7 \u00b7 \u00b7n} is understood here as the lexicographical order between I and J sorted in descending order. For instance, {2 6 7} < {6 7 8} because {7 6 2} < {8 7 6} in lexicographical order.\nRecall that the resolution rule can be applied to clauses C \u2228 l and C \u2032 \u2228 \u00acl and\nproduces the clause C \u2228 C \u2032, called the resolvent of C \u2228 l and C \u2032 \u2228 \u00acl on l .\nLemma 11 Let M be a record and let lB be a nondecision literal from lcp(M ). If clause D is the resolvent of B and a clause C conflicting on M then\n(i) D is a clause conflicting on M ,\n(ii) \u03b2M (D) < \u03b2M (C ).\nFor instance, let M be (28), let reason \u00acm \u2228 l \u2228 b for \u00acm in lcp(M ) be B , and let conflicting clause m \u2228 k \u2228 l on M be C . Then D , the result of resolving B together with C , is clause k \u2228 l \u2228 b. Lemma 11 asserts that k \u2228 l \u2228 b is a conflicting clause on M and that \u03b2M (D) < \u03b2M (C ). Indeed, \u03b2M (D) = {2 6 7} and \u03b2M (C ) = {6 7 8}."}, {"heading": "Proof", "text": "(i) Clause D is a resolvent of B and C on some literal l \u2032. Then, for some literal l \u2032 \u2208 B , l \u2032 \u2208 C . The clause C can be written as l \u2032 \u2228 C \u2032.\nIn order to demonstrate that D is a conflicting clause we need to show that\nD \u2286 lcp(M ) and \u03a0 entails D .\nSince B is a reason for l to be in lcp(M ), \u03a0 entails B and B has the form l \u2228B \u2032 where B \u2032 \u2286 lcp(M ). Since C is a conflicting clause on M , C \u2286 lcp(M ) and \u03a0 entails C . From the fact that lcp(M ) is consistent, it follows that there is no literal in B \u2032 such that its complement occurs in C . Consequently, l \u2032 6\u2208 B \u2032 so that l \u2032 is l and D is B \u2032\u2228C \u2032. We conclude that D \u2286 lcp(M ). From the fact that \u03a0 entails B , \u03a0 entails C , and the construction of D , it follows that \u03a0 entails D .\n(ii) From the proof of (i) it follows that D is a resolvent of B and C on l where B has the form l \u2228 B \u2032. Since B is a reason for l to be in lcp(M ), every literal in B \u2032 precedes l in lcp(M ). Since D is derived by replacing l in C with B \u2032, \u03b2M (D) < \u03b2M (B).\nLet record M be l1 \u00b7 \u00b7 \u00b7 li \u00b7 \u00b7 \u00b7 ln , the decision level of a literal li is the number of decision literals in l1 \u00b7 \u00b7 \u00b7 li : we denote it by decM (li). We will also use this notation to denote the decision level of a set of literals: For a set P \u2286 M of literals, decM (P) is the decision level of the literal in P that occurs latest in M . For record M and a decision level j by M j we denote the prefix of M that consists of the literals in M that belong to decision level less than j and by M j ] we denote the prefix of M that consists of the literals in M that belong to decision level less than or equal to j . For instance, let M be record (28) then decM (\u00ack) = 3, decM (\u00acb c \u00ack) = 3, M 3 is a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00acc, and M 3] is M itself.\nLemma 12\nFor an inconsistent record M and a conflicting clause l \u2228 C on M , if decM (l) > decM (c) for all c \u2208 C then lcp(M )decM (C )] l l\u2228C is a record."}, {"heading": "Proof", "text": "We need to show that (i) l 6\u2208 lcp(M )dec(C )] and (ii) l \u2228 C is a reason for l to be in lcp(M )dec(C )] l , i.e, \u03a0 entails l \u2228C and C \u2286 lcp(M )dec(C )].\nSince l \u2228 C is conflicting on M , l \u2228 C \u2286 lcp(M ). From the consistency of lcp(M ) and the fact that l \u2208 lcp(M ), it follows that l 6\u2208 lcp(M ). Consequently, l 6\u2208 lcp(M )dec(C )].\nSince l\u2228C is conflicting on M , \u03a0 entails l\u2228C and l \u2228 C \u2286 lcp(M ). Consequently, C \u2286 lcp(M ). From the definition of decM (C ), it follows that decM (C ) is the decision level of the literal in C that occurs latest in lcp(M ). By the definition of a decision level, C \u2286 lcp(M )decM (C )].\nProposition 11\u2191 For a program \u03a0, the transition rule Backjump LP is applicable to any backjump state in sml\u2191\u03a0."}, {"heading": "Proof", "text": "LetM ||\u0393 be a backjump state in sml\u2191\u03a0. Let R be the list of reasons that are assigned to the nondecision literals in lcp(M ).\nConsider the process of building a sequence C1,C2, . . . of clauses so that\n\u2022 C1 is the reason of the member of M that immediately follows lcp(M ), and \u2022 Cj (j > 1) is a resolvent of Cj\u22121 and some clause in R\nwhile derivation of new clauses is possible. From Lemma 11 (i) and the choice of C1 and R, it follows that any clause in C1,C2 . . . is conflicting. By Lemma 11 (ii) we conclude that \u03b2M (Cj ) < \u03b2M (Cj\u22121) (j > 1). It is clear that this process will terminate after deriving some clause Cm , since the number of conflicting clauses on M is finite. It is clear that clause Cm cannot be resolved against any clause in R.\nCase 1. Cm is the empty clause. Since M ||\u0393 is a backjump state, M contains a decision literal l\u2206. By part (iii) of the definition of a record, l belongs to lcp(M ). Consequently, M can be represented in the form lcp(M )decM (l) l\u2206Q .\nBy the choice of C1, C1 is a reason and must consist of at least one literal. Consequently, m > 1. Clause Cm is derived from clauses Cm\u22121 and some clause in R. Since Cm is empty, Cm\u22121 is a unit clause l \u2032. We will show that\nlcp(M )decM (l) l\u2206Q ||\u0393 =\u21d2 lcp(M )decM (l) l \u2032l \u2032 ||\u0393\nis an application of Backjump LP . It is sufficient to demonstrate that lcp(M )decM (l) l \u2032l \u2032 is a record. Since lcp(M )decM (l) l\u2206Q is a record, we only need to show that l \u2032 6\u2208 lcp(M )decM (l) and clause l \u2032 is a reason for l \u2032 to be in lcp(M )decM (l) l \u2032. Recall that Cm\u22121, i.e., l \u2032, is a conflicting clause. Consequently, \u03a0 entails l \u2032 and l \u2032 \u2208 lcp(M ). Since lcp(M ) is consistent, l \u2032 6\u2208 lcp(M ) so that l \u2032 6\u2208 lcp(M )decM (l). On the other hand, from the fact that \u03a0 entails l \u2032 it immediately follows that clause l \u2032 is a reason for l \u2032 to be in lcp(M )decM (l) l \u2032.\nCase 2. Cm is not empty. Since Cm is a conflicting clause on M , the complement of any literal in Cm belongs to lcp(M ). Furthermore, every such complement is a decision literal in lcp(M ). Indeed, if this complement is l l\u2228B \u2208 lcp(M ) then l \u2228 B is one of the clauses Bi , and it can be resolved against Cm .\nBy the definition of a decision level, there is at most one decision literal that belongs to any decision level. It follows that Cm can be written as l \u2228 C \u2032m so that decM (l) > decM (c) for any c \u2208 C \u2032m . Consequently, M can be written as lcp(M )decM (l) l \u2206 Q . Note that\nlcp(M )decM (l) l \u2206 Q ||\u0393 =\u21d2 lcp(M )decM (C \u2032 m)] lCm ||\u0393\nis an application of Backjump LP . Indeed, by Lemma 12 lcp(M )decM (C \u2032 m)] lCm is a record.\nAlgorithm 1 presents procedure BackjumpClause that computes a backjump clause for any backjump state in the graph sml\u2191\u03a0. The algorithm follows from the construction of the proof of Proposition 11\u2191. It is based on the iterative application of the resolution rule on reasons of the smallest inconsistent prefix of a state. The"}, {"heading": "BackjumpClause (M ||\u0393);", "text": "Arguments : M ||\u0393 is a backjump state in sml\u2191 \u03a0 Return Value : C is a backjump clause begin\nC \u2190 the reason of the member of M that immediately follows lcp(M ); N \u2190 the list of the nondecision literals in lcp(M ); R \u2190 the list of the reasons that are assigned to the literals in N ; while C \u2229 N 6= \u2205 do l \u2190 a literal in C \u2229N ; B \u2190 the clause in R that contains l ; C \u2032 \u2190 the resolvent of C and B on l ; if C \u2032 = \u2205 then\nreturn C\nC \u2190 C \u2032 return C ;\nAlgorithm 1: A procedure for generating a backjump clause.\nproof of Proposition 11\u2191 allows to conclude the termination of BackjumpClause and asserts that a clause returned by the procedure is a backjump clause on a backjump state.\nFor instance, let \u03a0 be (25). Consider an execution of BackjumpClause on \u03a0 and backjump state (28). The table below gives the values of lcp(M ), C , N , and R during the execution of the BackjumpClause algorithm. By Ci we denote a value of C before the i-th iteration of the while loop.\nlcp(M ) a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k\u00acm\u00acm\u2228l\u2228b C1 m \u2228 k \u2228 l N \u00acb\u00acb\u2228\u00aca \u00acf \u00acf\u2228\u00acc\u00ack\u00ack\u2228\u00acd \u00acl\u00acl\u2228b\u2228k \u00acm\u00acm\u2228l\u2228b R \u00acb \u2228 \u00aca, \u00acf \u2228 \u00acc, \u00ack \u2228 \u00acd , \u00acl \u2228 b \u2228 k , \u00acm \u2228 l \u2228 b\nC2 k \u2228 l \u2228 b is the resolvent of C1 and \u00acm \u2228 l \u2228 b C3 k \u2228 b is the resolvent of C2 and \u00acl \u2228 b \u2228 k C4 \u00acd \u2228 b is the resolvent of C3 and \u00ack \u2228 \u00acd C5 \u00acd \u2228 \u00aca is the resolvent of C4 and \u00acb \u2228 \u00aca\n(29)\nThe algorithm will terminate with the clause \u00acd \u2228 \u00aca. Proof of Proposition 11\u2191 asserts that (i) this clause is a backjump clause such that d and a are decision literals in M and (ii) the transition\na\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k\u00acm\u00acm\u2228l\u2228bmm\u2228k\u2228l ||\u2205 =\u21d2 a\u2206\u00acb\u00acb\u2228\u00aca\u00acd\u00acd\u2228\u00aca ||\u2205 (30)\nin sml\u2191\u03a0 is an application of Backjump LP . Indeed, by Lemma 12 lcp(M ) decM (\u00aca)]\u00acd\u00acd\u2228\u00aca , in other words a\u2206\u00acb\u00acb\u2228\u00aca\u00acd\u00acd\u2228\u00aca , is a record.\nNote that a backjump clause may be derived in other ways than captured by BackjumpClause algorithm: the transition rule Backjump LP is applicable with an arbitrary backjump clause. Usually, dpll-like procedures implement conflictdriven backjumping and learning where a particular learning schema such as, for\ninstance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause. It turns out that the BackjumpClause algorithm captures the Decision learning schema for ASP. Typically, SAT solvers impose an order for resolving the literals during the process of Decision backjump clause derivation. We can impose similar order by replacing the line\nl \u2190 a literal in C \u2229 N\nin the algorithm BackjumpClause with\nl \u2190 a literal in C \u2229 N that occurs latest in lcp(M ).\nIn fact, the sample application of BackjumpClause algorithm described in (29) follows this ordering.\nThis section introduced BackjumpClause algorithm that derives a Decision backjump clause for an arbitrary backjump state. In the next section we will introduce an algorithm that will compute an ASP counterpart of FirstUIP backjump clause."}, {"heading": "11 FirstUIP Conflict-Driven Backjumping and Learning", "text": "Conflict-driven backjumping and learning proved to be a highly successful technique in modern SAT solving. Furthermore, in (Zhang et al. 2001) the authors investigated the performance of various learning schemes and established experimentally that FirstUIP clause is the most useful single clause to learn. Success of conflict-driven learning led to the implementation of its ASP counterpart in systems smodelscc, clasp, and sup. There are two common methods for describing a backjump clause construction in the SAT literature. The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005). Ward and Schlipf (Ward and Schlipf 2004) extended the definition of an implication graph to the smodels algorithm and implemented FirstUIP learning schema in answer set solver smodelscc. In the previous section we used sml \u2191 \u03a0 formalism and resolution to describe the BackjumpClause algorithm for computing an ASP counterpart of a Decision backjump clause. In (Gebser et al. 2007) the authors used the concepts from constraint processing to implement FirstUIP learning schema in answer set solver clasp.\nThis section presents the BackjumpClauseFirstUIP algorithm for computing an ASP counterpart of a FirstUIP backjump clause by means of sml\u2191\u03a0 formalism and resolution. The BackjumpClauseFirstUIP algorithm is employed by the system sup in its implementation of conflict-driven backjumping and learning.\nThe Algorithm 2 presents procedure BackjumpClauseFirstUIP that computes a\nFirstUIP backjump clause for any backjump state in the graph sml\u2191\u03a0.\nWe now state the correctness of the algorithm BackjumpClauseFirstUIP . We start by showing its termination. By C1 we will denote the initial value assigned to clause C . From Lemma 11 (i) and the choice of C1 we conclude that at any point of computation clause C is conflicting on M . By Lemma 11 (ii), the value of \u03b2M (C ) decreases with each new assignment of clause C in the while loop. It follows that the while loop will terminate since the number of conflicting clauses C on M such"}, {"heading": "BackjumpClauseFirstUIP (M ||\u0393);", "text": "Arguments : M ||\u0393 is a backjump state in sml\u2191 \u03a0 Return Value : C is a backjump clause begin\nC \u2190 the reason of the member of M that immediately follows lcp(M ); l \u2190 the literal in C that occurs latest in lcp(M ); P \u2190 the sublist of lcp(M ) that consists of the literals that belong to the decision level dec(l); R \u2190 the list of the reasons that are assigned to the literals in P ; while |C \u2229 P | > 1 do l \u2190 the literal in C that occurs latest in P ; B \u2190 the clause in R that contains l ; C \u2190 the resolvent of C and B on l ;\nreturn C ;\nAlgorithm 2: A procedure for generating a FirstUIP backjump clause.\nthat |C \u2229 P | > 1 is finite. By Cm we will denote the clause C with which the while loop terminates. In other words BackjumpClauseFirstUIP returns Cm . We now show that Cm is indeed a backjump clause. We already concluded that Cm is a conflicting clause on M . Furthermore, from the termination condition of the while loop |Cm \u2229P | \u2264 1. From the choice of C1 and P it follows that |Cm \u2229P | = 1. Consequently, Cm can be written as l \u2228 C \u2032m where l is in singleton Cm \u2229 P . By Lemma 11 (ii), \u03b2(Cm ) \u2264 \u03b2(C1). From the definition of \u03b2 and the choice of P it follows that decM (l) > decM (c) for all c \u2208 C \u2032 m . By Lemma 12, lcp(M ) decM (C \u2032m)] lCm is a record. In other words, transition\nM ||\u0393 =\u21d2 lcp(M )decM (C \u2032 m)] lCm ||\u0393\nis an application of Backjump LP . Consequently, Cm is a backjump clause.\nFor instance, let \u03a0 be (25). Consider an execution of BackjumpClauseFirstUIP on \u03a0 and a backjump state (28). The table below gives the values of lcp(M ), C , P , and R during the execution of BackjumpClauseFirstUIP . By Ci we denote a value of C before the i-th iteration of the while loop.\nlcp(M ) a\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k\u00acm\u00acm\u2228l\u2228b C1 m \u2228 k \u2228 l P d\u2206\u00ack\u00ack\u2228\u00acd \u00acl\u00acl\u2228b\u2228k \u00acm\u00acm\u2228l\u2228b R \u00ack \u2228 \u00acd , \u00acl \u2228 b \u2228 k , \u00acm \u2228 l \u2228 b\nC2 k \u2228 l \u2228 b is the resolvent of C1 and \u00acm \u2228 l \u2228 b C3 k \u2228 b is the resolvent of C2 and \u00acl \u2228 b \u2228 k .\nThe BackjumpClauseFirstUIP algorithm will terminate with the clause k \u2228 b. The proof of the correctness of BackjumpClauseFirstUIP asserts that k\u2228b is a backjump clause and the transition\na\u2206\u00acb\u00acb\u2228\u00aca c\u2206\u00acf \u00acf\u2228\u00accd\u2206\u00ack\u00ack\u2228\u00acd\u00acl\u00acl\u2228b\u2228k\u00acm\u00acm\u2228l\u2228bmm\u2228k\u2228l =\u21d2 a\u2206\u00acb\u00acb\u2228\u00aca kk\u2228b ||\u2205 (31)\nin sml\u2191\u03a0 is an application of Backjump LP ."}, {"heading": "12 Extended Graph: Generate and Test", "text": "In this section we introduce an extended graph gtl\u2191F ,G for the generate and test abstract framework gtlF ,G similar as in Section 9 we introduced sml \u2191 \u03a0 for sml\u03a0.\nFor a formula H , we say that a clause l \u2228C is a reason for l to be in a list P lQ\nof literals w.r.t. H if H |= l \u2228 C and C \u2286 P .\nAn (extended) record M relative to a formula H is a list of literals over the set\nof atoms occurring in H where\n(i) each literal l in M is annotated either by \u2206 or by a reason for l to be in M\nw.r.t. H ,\n(ii) M contains no repetitions,\n(iii) for any inconsistent prefix of M its last literal is annotated by a reason.\nAn (extended) state relative to a CNF formula F , and a formula G formed from atoms occurring in F is either a distinguished state FailState or a pair of the form M ||\u0393, where M is an extended record relative to F \u2227 G, and \u0393 is the same as in the definition of an augmented state (i.e., \u0393 is a (multi-)set of clauses formed from atoms occurring in F that are entailed by F \u2227G.) For any extended state S relative to F and G, the result of removing annotations from all nondecision literals of S is a state of gtlF ,G : we will denote this state by S \u2193.\nFor a CNF formula F and a formula G formed from atoms occurring in F , we will define a graph gtl\u2191F ,G . The set of the nodes of gtl \u2191 F ,G consists of the extended states relative to F and G. The transition rules of gtlF ,G are extended to gtl \u2191 F ,G as follows: S1 =\u21d2 S2 is an edge in gtl \u2191 F ,G justified by a transition rule T if and only if S \u21931 =\u21d2 S \u2193 2 is an edge in gtlF ,G justified by T .\nThe lemma below formally states the relationship between nodes of the graphs\ngtlF ,G and gtl \u2191 F ,G :\nLemma 13 For any CNF formula F and a formula G formed from atoms occurring in F , if S \u2032 is a state reachable from \u2205||\u2205 in the graph gtlF ,G then there is a state S in the graph gtl\u2191F ,G such that S \u2193 = S \u2032.\nThe definitions of Basic transition rules and semi-terminal states in gtl\u2191F ,G are\nsimilar to their definitions for gtlF ,G . Proposition 9\u2191 For any CNF formula F and a formula G formed from atoms occurring in F ,\n(a) every path in gtl\u2191F ,G contains only finitely many edges labeled by Basic\ntransition rules,\n(b) for any semi-terminal state M ||\u0393 of gtl\u2191F ,G , M is a model of F \u2227G, (c) gtl\u2191F ,G contains an edge leading to FailState if and only if F \u2227G is unsatis-\nfiable.\nWe say that a state in the graph gtl\u2191F ,G is a backjump state if its record is inconsistent and contains a decision literal. As in case of the graph gtlF ,G , any backjump state in gtl\u2191F ,G is not semi-terminal: Proposition 10\u2191 For any CNF formula F and a formula G formed from atoms occurring in F , the transition rule Backjump GT is applicable in any backjump state in gtl\u2191F ,G .\nProposition 9 (b), (c) and Proposition 10 easily follow from Lemma 13 and Proposition 9\u2191 (b), (c) and Proposition 10\u2191 respectively. Proof of Proposition 9 (a) is similar to the proof of Proposition 9\u2191 (a)."}, {"heading": "13 Proofs of Proposition 9\u2191, Lemma 13, Proposition 10\u2191", "text": "13.1 Proof of Proposition 9\u2191\nLemma 14\nFor any CNF formula F , a formula G formed from atoms occurring in F , an extended record M relative to F \u2227 G, and any model X of F \u2227 G, if X satisfies all decision literals in M then X |= M ."}, {"heading": "Proof", "text": "By induction on the length ofM . The property trivially holds for \u2205. We assume that the property holds for any state with n elements. Consider any state M with n +1 elements. Let X be a model of F \u2227G such that X satisfies all decision literals in M .\nCase 1. M has the form P l\u2206. By the inductive hypothesis, X |= P . Since X\nsatisfies all decision literals in M , X |= l\u2206.\nCase 2. M has the form P l l\u2228C . By the inductive hypothesis, X |= P . By the definition of a reason (i) F \u2227 G entails l \u2228 C and (ii) C \u2286 P . From (ii) it follows that P |= \u00acC . Consequently, X |= \u00acC . From (i) it follows that X |= l \u2228 C . We conclude that X |= l .\nThe proof of Proposition 9\u2191 assumes the correctness of Proposition 10\u2191 that we\ndemonstrate in Section 13.3.\n\u0131Proof of Proposition 9\u2191 Parts (a) and (c) are proved as in the proof of Proposition 8\u2191, using Lemma 14. (b) Let M ||\u0393 be a semi-terminal state so that none of the Basic rules are applicable. From the fact that Decide is not applicable, we conclude that M assigns all literals.\nFurthermore, M is consistent. Indeed, assume that M is inconsistent. Then, since Fail is not applicable, M contains a decision literal. Consequently, M ||\u0393 is a backjump state. By Proposition 10\u2191, the transition rule Backjump GT is applicable in M ||\u0393. This contradicts our assumption that M ||\u0393 is semi-terminal.\nAlso, M is a model of F : since Unit Propagate \u03bb is not applicable, it follows that for every clause C \u2228 l \u2208 F \u222a \u0393 if C \u2286 M then l \u2208 M . Consequently, M |= C \u2228 l . Furthermore, M is a model of G: since Test is not applicable, then G 6|= M . We conclude that M |= G. Consequently, M is a model of F \u2227G."}, {"heading": "13.2 Proof of Lemma 13", "text": "For a state S in the graph gtl\u2191F ,G , we say that S \u2193 in gtlF ,G is the image of S . Lemma 13 For any CNF formula F and a formula G formed from atoms occurring in F , if S \u2032 is a state reachable from \u2205||\u2205 in the graph gtlF ,G then there is a state S in the graph gtl\u2191F ,G such that S \u2193 = S \u2032."}, {"heading": "Proof", "text": "Since the property trivially holds for the initial state \u2205||\u2205, we only need to prove that all transition rules of gtlF ,G preserve it.\nConsider an edge M ||\u0393 =\u21d2 M \u2032||\u0393\u2032 in the graph gtlF ,G such that there is a\nstate M1||\u0393 in the graph gtl \u2191 F ,G satisfying the condition (M1||\u0393) \u2193 = M ||\u0393. We need to show that there is a state in the graph gtl\u2191F ,G such that M \u2032||\u0393\u2032 is its image in gtlF ,G . Consider several cases that correspond to a transition rule leading from M ||\u0393 to M \u2032||\u0393\u2032:\nUnit Propagate \u03bb:\nM ||\u0393 =\u21d2 M l ||\u0393 if\n{\nC \u2228 l \u2208 F \u222a \u0393 and C \u2286 M .\nM \u2032||\u0393\u2032 is M l ||\u0393. It is sufficient to prove that M1 l C\u2228l ||\u0393 is a state of gtl\u2191F ,G . It is enough to show that a clause C \u2228 l is a reason for l to be in M l w.r.t. F \u2227G, i.e, F\u2227G |= C \u2228l and C \u2286 M . By applicability conditions of Unit Propagate \u03bb, C \u2286 M . By the definition of a state F \u2227G entails \u0393. Since C \u2228 l \u2208 F \u2229 \u0393, F \u2227G |= C \u2228 l .\nTest :\nM ||\u0393 =\u21d2 M l ||\u0393 if\n\n\n\nM is consistent, G |= M , l \u2208 M .\nM \u2032||\u0393\u2032 is M l ||\u0393. It is sufficient to prove that M1 l M ||\u0393 is a state of gtl\u2191F ,G . M has the form l \u2228 C . It is enough to show that a clause l \u2228 C is a reason for l to be in M l w.r.t. F \u2227 G. It is trivial that C \u2286 M . By applicability condition of the rule, G |= l \u2228 C .\nBackjump GT , Decide, Fail , and Learn GT : obvious."}, {"heading": "13.3 Proof of Proposition 10\u2191", "text": "For a state M lC ||\u0393, we say that a reason C is a backjump clause if there is a transition Backjump GT leading to M lC ||\u0393 in gtlF ,G .\nIn this section F is an arbitrary and fixed CNF formula and G is an arbitrary\nand fixed formula formed from atoms occurring in F .\nFor a record M , by lcp(M ) we denote its largest consistent prefix. We say that a clause C is conflicting on a list M of literals if F \u2227G entails C , and C \u2286 lcp(M ).\nLemmas 10, 11, 12 hold for the case of extended record relative to a formula. The\nproofs of the lemmas have to be modified only by replacing \u03a0 with F \u2227G.\nProposition 10\u2191 is proved as Proposition 11\u2191.\nAlgorithms BackjumpClause and BackjumpClauseFirstUIP are applicable to the\nbackjump states of the graph gtl\u2191F ,G ."}, {"heading": "14 Experiments with Sup", "text": "Here we present experimental analysis that compares performance of the system sup versus cmodels, clasp, smodels, and smodelscc. We start by describing the implementation details of sup.\nThe implementation of sup utilizes\n\u2022 the interface of SAT-solver minisat (v1.12b) that supports non-clausal con-\nstraints described in (Een and So\u0308rensson 2003) in order to introduce additional inference possibilities, but unit propagation. In particular, sup implements Backchain True and All Rules Cancelled by means of non-clausal constraints and it uses the unit propagate of minisat to capture Unit Propagate LP and Backchain False. \u2022 parts of cmodels code that eliminate weight and choice rules; perform model\nverification; and compute loop formulas. In particular, sup uses the latter two parts of cmodels code to capture Unfounded .\nIn the experiments we used the following versions of the systems: sup v. 0.1, sup v. 0.2, cmodels v. 3.77 usingminisat v. 1.12b, clasp v. 1.0.5, smodels v. 2.32, smodelscc v. 1.08 (implemented on top of smodels v. 2.26). System sup (v. 0.1 and v. 0.2) extends the implementation of minisat v. 1.12b. Therefore, we compare sup performance against cmodels that uses minisat 1.12b for its inference. System sup v. 0.1 stands for a version of sup that implements Unit Propagate LP, All Rules Cancelled, and Backchain False \u03bb propagation rules, and does not implement Backchain True. System sup v 0.2, on the other hand, also implements Backchain True.\nAll considered solvers use preprocessor lparse (see Footnote 5) to ground the problems so that the systems are run on identical ground instances. Grounding time is not accounted for in solving time. All times are reported in seconds. Symbol tout stands for the fact that a system did not terminate with a solution after 10 minutes. Sup 0.1, Sup, Cm, Cl, Smcc, and Sm stand for sup v. 0.1, sup v. 0.2, cmodels, clasp, smodelscc, and smodels respectively. The symbol \u2212t abbreviates the flag \u2212temp that allows sup to forget learnt clauses due to loop formulas (by default sup adds these clauses into permanent clause database). The symbol \u2212a abbreviates the flag \u2212atomreason that forces cmodels, like sup, to add only a clause implied by some loop formula and unsatisfied by a current model rather than the complete loop formula unsatisfied by the model. By default, cmodels adds a complete loop formula unsatisfied by the model. All experiments were run on Intel(R) Pentium(R) D CPU 3.00GHz, 2 cpu cores, cache size 1024 KB, running Linux.\nTable 1 presents the experiments run on tight programs. Recall that for tight programs (i) the transition rule Unfounded of sup is never used for inference and (ii) the transition rule Test of cmodels is never used for inference.\nTable 2 presents the experiments run on nontight programs:\nOverall the results demonstrated by sup place the system in the class of highly\nefficient answer set solvers."}, {"heading": "15 Related Work", "text": "Simons (2000) andWard (2004) described the smodels and smodelscc algorithms, respectively, by means of pseudocode and demonstrated their correctness. In this paper we designed an abstract framework that was used as an alternative method for describing these algorithms and demonstrating their correctness.\nGebser and Schaub (2006) provided a deductive system for describing inferences involved in computing answer sets by tableaux methods. The abstract framework presented here can be viewed as a deductive system also, but of a very different kind. First, it accounts for phenomena such as backjumping and learning (and also forgetting and restart) whereas the Gebser-Schaub system does not. Second, we describe backtracking by an inference rule, and the Gebser-Schaub system does not. Accordingly, the derivations considered in this paper describe search process, and derivations in the Gebser-Schaub system do not. Also, the abstract framework\ndiscussed here does not have any inference rule similar to Cut; this is why its derivations are paths, rather than trees."}, {"heading": "16 Conclusions", "text": "In this paper we showed how to model advanced algorithms for computing answer sets of a program by means of simple mathematical objects, graphs. We extended the abstract frameworks proposed in (Lierler 2008) for describing native and SATbased ASP algorithms to capture such sophisticated features as backjumping and learning. We characterized the algorithms of systems smodelscc, sup, and cmodels that implement these features. We note that the work on this abstract framework suggested the implementation of answer set solver sup and the experimental analysis presented here demonstrates that sup is a competitive representative in the family of answer set solvers. The abstract framework simplifies the analysis of the correctness of algorithms and allows us to study the relationship between various algorithms by analyzing the differences in strategies of choosing a path in the graph. For example, the description of the smodelscc and sup algorithms in this framework reflects their differences in a simple manner via distinct assignments of priorities to edges of the graph that characterize these systems. Also we used this framework to describe two algorithms for computing Decision and FirstUIP backjump clauses for the implementation of conflict-driven backjumping and learning. This formalism provided the transparent means for specifying these algorithms. We believe that the development of this abstract framework powerful enough to describe advanced features of answer set solvers in a simple manner will promote the use of these sophisticated features in more solvers. This work helped us design the new solver sup, and we hope that in the future it will suggest designs of other systems for computing answer sets."}, {"heading": "Acknowledgments", "text": "We are grateful to Marco Maratea for bringing to our attention the work by Nieuwenhuis et al. (2006), to Vladimir Lifschitz for the numerous discussions, to Martin Gebser, Michael Gelfond, and Miros law Truszczyn\u0301ski for valuable ideas and comments, to anonymous referees for their suggestions. The author was supported by the National Science Foundation under Grant IIS-0712113."}], "references": [{"title": "Negation as failure", "author": ["K. Clark"], "venue": "Logic and Data Bases, H. Gallaire and J. Minker, Eds. Plenum Press, New York, 293\u2013322.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "A machine program for theorem proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communications of the ACM 5(7), 394\u2013397.", "citeRegEx": "Davis et al\\.,? 1962", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "An extensible sat-solver", "author": ["N. Een", "N. S\u00f6rensson"], "venue": "SAT.", "citeRegEx": "Een and S\u00f6rensson,? 2003", "shortCiteRegEx": "Een and S\u00f6rensson", "year": 2003}, {"title": "Consistency of Clark\u2019s completion and existence of stable models", "author": ["F. Fages"], "venue": "Journal of Methods of Logic in Computer Science 1, 51\u201360.", "citeRegEx": "Fages,? 1994", "shortCiteRegEx": "Fages", "year": 1994}, {"title": "Conflict-driven answer set solving", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "Proceedings of 20th International Joint Conference on Artificial Intelligence (IJCAI\u201907). MIT Press, 386\u2013392.", "citeRegEx": "Gebser et al\\.,? 2007", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "Tableau calculi for answer set programming", "author": ["M. Gebser", "T. Schaub"], "venue": "Proceedings of 22nd International Conference on Logic Programming (ICLP\u201906). Springer, 11\u201325.", "citeRegEx": "Gebser and Schaub,? 2006", "shortCiteRegEx": "Gebser and Schaub", "year": 2006}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium, R. Kowalski and K. Bowen, Eds. MIT Press, 1070\u20131080.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning 36, 345\u2013377.", "citeRegEx": "Giunchiglia et al\\.,? 2006", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2006}, {"title": "On the relation between answer set and SAT procedures (or, between smodels and cmodels)", "author": ["E. Giunchiglia", "M. Maratea"], "venue": "Proceedings of 21st International Conference on Logic Programming (ICLP\u201905). Springer, 37\u201351.", "citeRegEx": "Giunchiglia and Maratea,? 2005", "shortCiteRegEx": "Giunchiglia and Maratea", "year": 2005}, {"title": "Satisfiability solvers", "author": ["C.P. Gomes", "H. Kautz", "A. Sabharwal", "B. Selman"], "venue": "Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz, and B. Porter, Eds. Elsevier, 89\u2013134.", "citeRegEx": "Gomes et al\\.,? 2008", "shortCiteRegEx": "Gomes et al\\.", "year": 2008}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["J. Lee"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). Professional Book Center, 503\u2013508.", "citeRegEx": "Lee,? 2005", "shortCiteRegEx": "Lee", "year": 2005}, {"title": "Abstract answer set solvers", "author": ["Y. Lierler"], "venue": "Proceedings of International Conference on Logic Programming (ICLP\u201908). Springer, 377\u2013391.", "citeRegEx": "Lierler,? 2008", "shortCiteRegEx": "Lierler", "year": 2008}, {"title": "What is answer set programming? In Proceedings of the AAAI Conference on Artificial Intelligence", "author": ["V. Lifschitz"], "venue": "MIT Press, 1594\u20131597.", "citeRegEx": "Lifschitz,? 2008", "shortCiteRegEx": "Lifschitz", "year": 2008}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). MIT Press, 112\u2013117.", "citeRegEx": "Lin and Zhao,? 2002", "shortCiteRegEx": "Lin and Zhao", "year": 2002}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157, 115\u2013137.", "citeRegEx": "Lin and Zhao,? 2004", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "Fast SAT-based answer set solver", "author": ["Z. Lin", "Y. Zhang", "H. Hernandez"], "venue": "Proceedings of National Conference on Artificial Intelligence (AAAI). MIT Press, 92\u201397.", "citeRegEx": "Lin et al\\.,? 2006", "shortCiteRegEx": "Lin et al\\.", "year": 2006}, {"title": "Conflict analysis in search algorithms for propositional satisfiability", "author": ["J.P. Marques-Silva", "K.A. Sakallah"], "venue": "Proceedings of IEEE Conference on Tools with Artificial Intelligence.", "citeRegEx": "Marques.Silva and Sakallah,? 1996", "shortCiteRegEx": "Marques.Silva and Sakallah", "year": 1996}, {"title": "A SAT solver primer", "author": ["D.G. Mitchell"], "venue": "EATCS Bulletin (The Logic in Computer Science Column). Vol. 85. 112\u2013133.", "citeRegEx": "Mitchell,? 2005", "shortCiteRegEx": "Mitchell", "year": 2005}, {"title": "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)", "author": ["R. Nieuwenhuis", "A. Oliveras", "C. Tinelli"], "venue": "Journal of the ACM 53(6), 937\u2013977.", "citeRegEx": "Nieuwenhuis et al\\.,? 2006", "shortCiteRegEx": "Nieuwenhuis et al\\.", "year": 2006}, {"title": "A backjumping technique for disjunctive logic programming", "author": ["F. Ricca", "W. Faber", "N. Leone"], "venue": "AI Commun. 19, 2, 155\u2013172.", "citeRegEx": "Ricca et al\\.,? 2006", "shortCiteRegEx": "Ricca et al\\.", "year": 2006}, {"title": "Stable models and non-determinism in logic programs with negation", "author": ["D. Sacc\u00e1", "C. Zaniolo"], "venue": "Proceedings of ACM Symposium on Principles of Database Systems (PODS). 205\u2013217.", "citeRegEx": "Sacc\u00e1 and Zaniolo,? 1990", "shortCiteRegEx": "Sacc\u00e1 and Zaniolo", "year": 1990}, {"title": "Extending and implementing the stable model semantics", "author": ["P. Simons"], "venue": "Ph.D. thesis, Helsinki University of Technology. Adviser-Niemel\u00e4, Ilkka.", "citeRegEx": "Simons,? 2000", "shortCiteRegEx": "Simons", "year": 2000}, {"title": "The well-founded semantics for general logic programs", "author": ["A. Van Gelder", "K. Ross", "J. Schlipf"], "venue": "Journal of ACM 38, 3, 620\u2013650.", "citeRegEx": "Gelder et al\\.,? 1991", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}, {"title": "Answer set programming with clause learning", "author": ["J. Ward"], "venue": "Ph.D. thesis. AdviserLong, Timothy J. and Adviser-Schlipf, Johns S.", "citeRegEx": "Ward,? 2004", "shortCiteRegEx": "Ward", "year": 2004}, {"title": "Answer set programming with clause learning", "author": ["J. Ward", "J. Schlipf"], "venue": "Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904). 302\u2013313.", "citeRegEx": "Ward and Schlipf,? 2004", "shortCiteRegEx": "Ward and Schlipf", "year": 2004}, {"title": "Efficient conflict driven learning in a boolean satisfiability solver", "author": ["L. Zhang", "C.F. Madigan", "M.W. Moskewicz", "S. Malik"], "venue": "Proceedings ICCAD-01. 279\u2013285.", "citeRegEx": "Zhang et al\\.,? 2001", "shortCiteRegEx": "Zhang et al\\.", "year": 2001}], "referenceMentions": [{"referenceID": 12, "context": "Answer Set Programming (ASP) is a methodology commonly used for solving combinatorial search problems (Lifschitz 2008).", "startOffset": 102, "endOffset": 118}, {"referenceID": 9, "context": "In the development of ASP solvers, computational ideas behind SAT solvers (Gomes et al. 2008) play an important role.", "startOffset": 74, "endOffset": 93}, {"referenceID": 19, "context": "For instance, dlv implements backjumping (Ricca et al. 2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels by introducing restarts, conflict-driven", "startOffset": 41, "endOffset": 60}, {"referenceID": 24, "context": "2006), and smodelscc 4 (Ward and Schlipf 2004) extends the answer set solver smodels by introducing restarts, conflict-driven", "startOffset": 23, "endOffset": 46}, {"referenceID": 11, "context": "The ASP solver sup (Lierler 2008) implements these features also.", "startOffset": 19, "endOffset": 33}, {"referenceID": 18, "context": "In this paper our main goal is to show how the \u201cabstract\u201d approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features.", "startOffset": 105, "endOffset": 130}, {"referenceID": 18, "context": "In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures.", "startOffset": 3, "endOffset": 28}, {"referenceID": 11, "context": "In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning.", "startOffset": 3, "endOffset": 17}, {"referenceID": 17, "context": "Usually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause.", "startOffset": 160, "endOffset": 175}, {"referenceID": 16, "context": "One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005).", "startOffset": 34, "endOffset": 67}, {"referenceID": 17, "context": "One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005).", "startOffset": 101, "endOffset": 116}, {"referenceID": 11, "context": "In (Lierler 2008), we introduced the basic algorithm underlining the system sup but neglected some of its features: conflict-driven backjumping, learning, forgetting, and restarts.", "startOffset": 3, "endOffset": 17}, {"referenceID": 11, "context": "The ASP solver sup (Lierler 2008) implements these features also. In this paper our main goal is to show how the \u201cabstract\u201d approach to describing SAT solvers proposed in (Nieuwenhuis et al. 2006) can be extended to ASP solvers that use these sophisticated features. Usually computation procedures are described in terms of pseudocode. In (Nieuwenhuis et al. 2006), the authors proposed an alternative approach to describing dpll-like procedures. They introduced an abstract framework that captures what \u201dstates of computation\u201d are, and what transitions between states are allowed. In this way, it defines a directed graph such that every execution of the dpll procedure corresponds to a path in this graph. Some edges may correspond to unit propagation steps, some to branching, some to backtracking. This allows the authors to model a dpll-like algorithm by a mathematically simple and elegant object, graph, rather than a collection of pseudocode statements. In (Lierler 2008), we extended this framework for describing such ASP algorithms as smodels, asp-sat with Backtracking, and sup without Learning. In this paper, we expand our previous work on abstract answer set solvers to cover such features as backjumping and learning (and also forgetting and restart). We start by introducing an abstract framework that captures a general mechanism of these sophisticated features in ASP solvers. For instance, this framework provides the transition underlying the process of learning a clause, but it does not suggest which clause shall be learned. Similarly, it provides a general description of backjumping but it does not supply the means for computing a \u201cbackjump clause\u201d necessary for an answer set solver to perform backjumping. We then enhance this abstract framework to capture enough information about a state of computation for deriving a backjump clause. Usually, dpll-like procedures implement conflict-driven backjumping and learning where a particular learning schema such as, for instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause. There are two common methods for describing a backjump clause construction. One employs the implication graph (Marques-Silva and Sakallah 1996) and the other employs resolution (Mitchell 2005). Ward and Schlipf (2004) extended the notion of an implication graph to the smodels algorithm.", "startOffset": 20, "endOffset": 2322}, {"referenceID": 17, "context": "7 The names of the backjump clauses follow (Mitchell 2005).", "startOffset": 43, "endOffset": 58}, {"referenceID": 18, "context": "We start the paper with Section 2 that reviews the abstract DPLL framework introduced in (Nieuwenhuis et al. 2006) and some logic programming concepts.", "startOffset": 89, "endOffset": 114}, {"referenceID": 1, "context": "Path (1) corresponds to an execution of dpll in the sense of (Davis et al. 1962); path (2) does not, because it applies Decide to a even though Unit Propagate could be applied in this state.", "startOffset": 61, "endOffset": 80}, {"referenceID": 6, "context": "A set X of atoms is an answer set for a program \u03a0 if X is minimal (with respect to set inclusion) among the sets of atoms that satisfy the reduct \u03a0 (Gelfond and Lifschitz 1988).", "startOffset": 148, "endOffset": 176}, {"referenceID": 20, "context": "\u03a0 (Corollary 2 from (Sacc\u00e1 and Zaniolo 1990)).", "startOffset": 20, "endOffset": 44}, {"referenceID": 20, "context": "9 The Corollary 2 from (Sacc\u00e1 and Zaniolo 1990) refers to \u201dassumption sets\u201d rather than unfounded sets.", "startOffset": 23, "endOffset": 47}, {"referenceID": 23, "context": "10 The names of some of these rules follow (Ward 2004).", "startOffset": 43, "endOffset": 54}, {"referenceID": 0, "context": "It is well known that the supported models of a program can be characterized as models of program\u2019s completion in the sense of (Clark 1978).", "startOffset": 127, "endOffset": 139}, {"referenceID": 20, "context": "Lemma 3 (Corollary 2 from (Sacc\u00e1 and Zaniolo 1990)) For any model M of a program \u03a0, M is an answer set for \u03a0 if and only if M is unfounded-free.", "startOffset": 26, "endOffset": 50}, {"referenceID": 3, "context": "For the case of tight programs, the converse holds also: M is an answer set for \u03a0 if and only if M is a supported model of \u03a0 (Fages 1994) or, in other words, is a model of the completion of \u03a0.", "startOffset": 125, "endOffset": 137}, {"referenceID": 21, "context": "With respect to the actual smodels algorithm (Simons 2000), singular edges of the graph sm\u03a0 are inessential: in view of priorities for choosing a path in sm\u03a0 described in Section 4.", "startOffset": 45, "endOffset": 58}, {"referenceID": 8, "context": "A similar relationship, in terms of pseudocode representations of smodels and dpll, is established in (Giunchiglia and Maratea 2005).", "startOffset": 102, "endOffset": 132}, {"referenceID": 13, "context": "This modification of the graph dpF is of interest, for example, in connection with the fact that answer sets of a program \u03a0 can be characterized as models of its completion extended by so called loop formulas of \u03a0 (Lin and Zhao 2002).", "startOffset": 214, "endOffset": 233}, {"referenceID": 13, "context": "This is important because LF (\u03a0) can be very long (Lin and Zhao 2002).", "startOffset": 50, "endOffset": 69}, {"referenceID": 7, "context": "asp-sat with Backtracking (Giunchiglia et al. 2006) is a procedure that computes models of the completion of the given program using dpll, and tests them until an answer set is found.", "startOffset": 26, "endOffset": 51}, {"referenceID": 18, "context": "12 from (Nieuwenhuis et al. 2006).", "startOffset": 8, "endOffset": 33}, {"referenceID": 18, "context": "8 from (Nieuwenhuis et al. 2006)).", "startOffset": 7, "endOffset": 32}, {"referenceID": 18, "context": "The transition rules Restart and Forget LP are similar to the analogous rules in (Nieuwenhuis et al. 2006) for extending dpll procedure with restart and forgetting techniques.", "startOffset": 81, "endOffset": 106}, {"referenceID": 24, "context": "In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of sml\u03a0.", "startOffset": 61, "endOffset": 84}, {"referenceID": 11, "context": "In this section we use this method to describe the smodelscc (Ward and Schlipf 2004) and sup (Lierler 2008) algorithms by means of sml\u03a0.", "startOffset": 93, "endOffset": 107}, {"referenceID": 11, "context": "In (Lierler 2008), we introduced the simplified sup algorithm that relies on backtracking rather than conflict-driven backjumping and learning that are actually implemented in the system.", "startOffset": 3, "endOffset": 17}, {"referenceID": 14, "context": "The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al.", "startOffset": 75, "endOffset": 94}, {"referenceID": 7, "context": "The sup algorithm is similar to SAT-based answer set solvers such as assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al. 2006) (see Section 8.", "startOffset": 107, "endOffset": 132}, {"referenceID": 7, "context": "System cmodels implements an algorithm called asp-sat with Learning (Giunchiglia et al. 2006) that extends asp-sat with Backtracking by backjumping and learning.", "startOffset": 68, "endOffset": 93}, {"referenceID": 7, "context": "The clause learned due to this application of Learn GT is derived by means of loop formulas (see (Giunchiglia et al. 2006)).", "startOffset": 97, "endOffset": 122}, {"referenceID": 15, "context": "Systems sag (Lin et al. 2006) and clasp (Gebser et al.", "startOffset": 12, "endOffset": 29}, {"referenceID": 4, "context": "2006) and clasp (Gebser et al. 2007) are answer set solvers that are enhancements of cmodels.", "startOffset": 16, "endOffset": 36}, {"referenceID": 14, "context": "The proof uses the notion of loop formula (Lin and Zhao 2004).", "startOffset": 42, "endOffset": 61}, {"referenceID": 10, "context": "For any set Y of atoms, the external support formula (Lee 2005) for Y is", "startOffset": 53, "endOffset": 63}, {"referenceID": 10, "context": "From the Main Theorem in (Lee 2005) we conclude: Lemma on Loop Formulas For any program \u03a0, \u03a0 entails loop formulas (21) for all sets Y of atoms that occur in \u03a0.", "startOffset": 25, "endOffset": 35}, {"referenceID": 17, "context": "instance, Decision or FirstUIP (Mitchell 2005) is applied for computing a special kind of a backjump clause.", "startOffset": 31, "endOffset": 46}, {"referenceID": 25, "context": "Furthermore, in (Zhang et al. 2001) the authors investigated the performance of various learning schemes and established experimentally that FirstUIP clause is the most useful single clause to learn.", "startOffset": 16, "endOffset": 35}, {"referenceID": 16, "context": "The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005).", "startOffset": 45, "endOffset": 78}, {"referenceID": 17, "context": "The first one employes the implication graph (Marques-Silva and Sakallah 1996) and the second one employes resolution (Mitchell 2005).", "startOffset": 118, "endOffset": 133}, {"referenceID": 24, "context": "Ward and Schlipf (Ward and Schlipf 2004) extended the definition of an implication graph to the smodels algorithm and implemented FirstUIP learning schema in answer set solver smodelscc.", "startOffset": 17, "endOffset": 40}, {"referenceID": 4, "context": "In (Gebser et al. 2007) the authors used the concepts from constraint processing to implement FirstUIP learning schema in answer set solver clasp.", "startOffset": 3, "endOffset": 23}, {"referenceID": 2, "context": "12b) that supports non-clausal constraints described in (Een and S\u00f6rensson 2003) in order to introduce additional inference possibilities, but unit propagation.", "startOffset": 56, "endOffset": 80}, {"referenceID": 5, "context": "Gebser and Schaub (2006) provided a deductive system for describing inferences involved in computing answer sets by tableaux methods.", "startOffset": 0, "endOffset": 25}, {"referenceID": 11, "context": "We extended the abstract frameworks proposed in (Lierler 2008) for describing native and SATbased ASP algorithms to capture such sophisticated features as backjumping and learning.", "startOffset": 48, "endOffset": 62}, {"referenceID": 17, "context": "We are grateful to Marco Maratea for bringing to our attention the work by Nieuwenhuis et al. (2006), to Vladimir Lifschitz for the numerous discussions, to Martin Gebser, Michael Gelfond, and Miros law Truszczy\u0144ski for valuable ideas and comments, to anonymous referees for their suggestions.", "startOffset": 75, "endOffset": 101}], "year": 2010, "abstractText": "Answer Set Solvers with Backjumping and Learning (long version)", "creator": "LaTeX with hyperref package"}}}