{"id": "1005.1475", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-May-2010", "title": "How to correctly prune tropical trees", "abstract": "we present tropical games, a generalization of combinatorial parallel min - max games based on tropical algebras. importantly our model breaks the traditional linear symmetry of rational zero - sum games where players have exactly opposed goals ( min positive vs. max ), is more widely loosely applicable than min - max and also supports a form of pruning, especially despite it being less effective than explicit alpha - beta. actually, min - z max games may be seen as particular cases where both the game and its dual are tropical : when the dual of a tropical game is almost also tropical, the power span of alpha - beta equilibrium is completely recovered. therefore we formally develop the model and prove critically that the tropical pruning strategy curve is usually correct, then conclude by showing how the problem of approximated parsing properties can be modeled as a tropical game, profiting from pruning.", "histories": [["v1", "Mon, 10 May 2010 09:06:26 GMT  (65kb)", "https://arxiv.org/abs/1005.1475v1", "To appear in \"Artificial Intelligence and Symbolic Computation, 2010\"."], ["v2", "Tue, 11 May 2010 06:35:47 GMT  (54kb)", "http://arxiv.org/abs/1005.1475v2", "To appear in \"Artificial Intelligence and Symbolic Computation, 2010\"."]], "COMMENTS": "To appear in \"Artificial Intelligence and Symbolic Computation, 2010\".", "reviews": [], "SUBJECTS": "cs.AI cs.DM cs.GT cs.SC", "authors": ["jean-vincent loddo", "luca saiu"], "accepted": false, "id": "1005.1475"}, "pdf": {"name": "1005.1475.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Luca Saiu", "Jean-Vincent Loddo"], "emails": ["loddo@lipn.univ-paris13.fr", "saiu@lipn.univ-paris13.fr"], "sections": [{"heading": null, "text": "ar X\niv :1\n00 5.\n14 75\nv2 [\ncs .A\nI] 1\n1 M\nay 2\n01 0\nKey words: combinatorial game, search, alpha-beta pruning, rational game, tropical algebra, tropical game, term, rewriting, logic, parsing"}, {"heading": "1 Introduction", "text": "We are all familiar with games such as Chess or Checkers. Such games are purely rational as they do not involve any element of chance; they are also zero-sum, as the players\u2019 interests are dual: what one \u201cwins\u201d, the other \u201closes\u201d \u2014 which is the origin of the min-max evaluation mechanism. The two fundamental questions to be asked in a rational game are \u201cWho will win?\u201d and \u201cHow much will she win?\u201d. Answering such questions involves searching for a strategy trough a (typically large) game tree. Some optimized search techniques were developed, which in the case of combinatorial two-player games include the \u03b1-\u03b2 pruning technique [1,2]. \u03b1-\u03b2 is not an approximated algorithm: its correctness relies on the mutual distributive properties of min and max. In this work we explore the implications of assuming only one player to be rational, breaking the symmetry of the traditional \u201cdouble-sided\u201d rationality. Quite unsurprisingly our tropical \u03b1-pruning depends on just one distributive property, a requirement satisfied by tropical algebras (Section 3).\nFollowing the style introduced by [3] and [4], we will distinguish two aspects of two-player combinatorial games: a first one that we call syntactic, consisting\nThis work is partially financed by Marie Curie action n. 29849 Websicola and ANR06-JCJC-0122. The final publication of this paper is available at www.springerlink.com.\nin a description of the possible game positions and the valid moves leading from a position to another; the game syntax is the formal equivalent of the intuitive notion of the \u201cgame rules\u201d. By contrast the semantic aspect is concerned about the interpretation of the game according to the interests of the players, and ultimately about the answer to the two fundamental questions above. Our semantics will be based on tropical algebras, and as a consequence our technique is widely applicable, relying as it does only on their comparatively weak hypotheses.\nWe formally define tropical \u03b1-pruning and prove its soundness, as our main contribution (Section 4). A further contribution consists in our formalization of game evaluation and tropical (and \u03b1-\u03b2) cuts as a small-step semantics, so that proofs can reuse the results of term-rewriting theory.\nActually, our soundness result subsumes other works proving \u03b1-\u03b2\u2019s soundness over distributive lattices such as [4] and (later) [5], since distributive lattices are bi-tropical structures (Definition 8).\nWe conclude by proposing the algorithm design style Choose-How-To-Divide and Conquer meant for attacking even apparently unrelated search problems as tropical games; we develop approximated parsing as one such problem by showing how it profits from \u03b1-pruning (Section 5)."}, {"heading": "2 Combinatorial game syntax and semantics", "text": ""}, {"heading": "2.1 Syntax", "text": "We speak about \u201csyntax\u201d, hinting at formal grammars, in that some initial game positions are given, together with some \u201crule\u201d allowing to derive successive positions from those: in this way a game can be seen as the tree of all the possibilities of playing it \u2014 the tree of all the possible matches.\nDefinition 1 (Syntax). A game syntax or arena is a triple S = (P, \u03bb, succ), where:\n\u2013 P is the set of all game positions. \u2013 the turn function \u03bb : P \u2192 {P ,O}, says whose turn it is: P for \u201cplayer\u201d or\nO for \u201copponent\u201d. \u2013 the successor function succ, taking a game position and returning all the\npositions reachable with valid moves from there; succ : P \u2192 P\u2217.\nGiven S = (P, \u03bb, succ), we define:\n\u2013 the set of terminal positions PT = {\u03c0 \u2208 P | succ(\u03c0) = \u3008\u3009}. \u2013 the dual arena S\u22a5 = (P, \u03bb\u22a5, succ), of course with \u03bb\u22a5 : P \u2192 {P ,O}, where\nfor any \u03c0 \u2208 P we have \u03bb\u22a5(\u03c0) 6= \u03bb(\u03c0). \u2013 the move relation is the binary version of the succ relation: for all \u03c0, \u03c0\u2032 \u2208 P,\nmove(\u03c0, \u03c0\u2032) iff \u03c0\u2032 = \u03c0i for some i, where succ(\u03c0) = \u3008\u03c01...\u03c0n\u3009.\nThe arena is called alternate-turn iff move(\u03c0, \u03c0\u2032) implies \u03bb(\u03c0) 6= \u03bb(\u03c0\u2032). If move is N\u00f6therian we speak about N\u00f6therian or finite arena.\nRemark 1 (Alternate-turn arenas). It is possible to systematically make a game alternate-turn by \u201ccollapsing\u201d all the sequences of consecutive moves of the same player into single moves.\nOne of the most important ideas in Game Theory is the strategy, containing a plan to win the game \u2014 a player saying to herself \u201cif this happens I should do that, but if this other thing happens I should do that, and so on\u201d. It should be noticed that a strategy is only related to the syntactic part of a game, being independent, per se, from the game evaluation. In particular, a strategy may very well not be winning.\nDefinition 2 (Strategy). Let S = (P, \u03bb, succ) be an arena, and \u03c0 \u2208 P be a position. We define:\n\u2013 the reachable positions from \u03c0 as the right elements of the reflexive-transitive closure of the relation succ: \u03c0\u2193 = succ\u2217(\u03c0); \u2013 a global strategy \u03c3, as a subset of the relation succ which is: \u2022 deterministic in P positions: for all \u03c0 \u2208 P where \u03bb(\u03c0) = P, if succ(\u03c0) = \u3008\u03c01...\u03c0n\u3009 then \u03c3(\u03c0) = \u3008\u03c0i\u3009, for some i such that 1 \u2264 i \u2264 n.\n\u2022 complete in O positions: for all \u03c0 \u2208 P where \u03bb(\u03c0) = O, \u03c3(\u03c0) = succ(\u03c0).\n\u2013 a strategy for the initial position \u03c0 is a global strategy for the restricted arena S\u03c0 = (\u03c0\u2193, \u03bb|\u03c0\u2193, succ|\u03c0\u2193), where we indicate with f |D the restriction of a function f to the set D."}, {"heading": "2.2 Semantics", "text": "Let us assume a finite game with syntax S = (P, \u03bb, succ). Traditionally the two players have exactly opposed interests and we assume, by convention, that the player P will try to minimize the payoff of the final position while the opponent O will try to maximize it.\nThe ordinary way of evaluating such a finite game consists in labeling nonterminal nodes with the functions min and max (according to the turn), and terminal nodes with the payoff of the terminal position p(\u03c0). Such values are then \u201cpropagated\u201d back, applying the function at each node to its children\u2019s values. The final value at the root is called the game value: it says who wins and how much, supposing both players to be rational.\nHence, assuming p : PT \u2192 Z in accord to the tradition, the game value vp : P \u2192 Z could be simply defined as a function of the initial position:\nvp(\u03c0) =\n\n \n \np(\u03c0), \u03c0 \u2208 PT minni=1 vp(\u03c0i), succ(\u03c0) = \u3008\u03c01...\u03c0n\u3009, \u03bb(\u03c0) = P maxni=1 vp(\u03c0i), succ(\u03c0) = \u3008\u03c01...\u03c0n\u3009, \u03bb(\u03c0) = O\nThis classical definition has the obvious defect of only supporting the function min and max; often for resolving actual games the preferred structure is Z, Q (possibly extended with \u2212\u221e and +\u221e), floating point numbers, or some sort\nof tuples containing such structures on which a topological order is defined. Hence, in order to be more general, let us define U to be any set closed over two associative binary operations \u2295 and \u2299, where \u2295 will be associated to the player and \u2299 to the opponent. Assuming p : P \u2192 U, the definition above would become:\nvp(\u03c0) =\n\n      \n     \np(\u03c0), \u03c0 \u2208 PT n \u2295\ni=1\nvp(\u03c0i), succ(\u03c0) = \u3008\u03c01...\u03c0n\u3009, \u03bb(\u03c0) = P\nn \u2299\ni=1\nvp(\u03c0i), succ(\u03c0) = \u3008\u03c01...\u03c0n\u3009, \u03bb(\u03c0) = O\nThe extended vp above is a step forward, but it still has the problem of only being well-defined on finite games. We solve this problem by abandoning the functional definition of vp altogether, and giving a small-step semantics instead. Actually, this style will also be useful in Section 4.1 to prove the soundness of our pruning technique.\nRemark 2 (Invariance under alternate-turn transformation). It is easy to see that the transformation hinted at in Remark 1 does not alter semantics, because of the two associative properties.\nDefinition 3 (Game). A game is the triple G = (S,A, p), where S = (P, \u03bb, succ) is the syntax, A = (U,\u2295,\u2299) is an algebra with associative operations \u2295 and \u2299, and where p : PT \u2192 U is the payoff function.\nSometimes we informally refer to syntactic or semantic properties as if they belonged to a game, for example by speaking about \u201cN\u00f6therian game\u201d instead of \u201cGame with N\u00f6therian syntax\u201d.\nSmall-step operational semantics In the following, we assume a game G = (S,A, p), where S = (P, \u03bb, succ) and A = (U,\u2295,\u2299). The configurations of our system consist of (ground) terms of G, recursively defined as: Ter(G) = P \u228e U \u228e ({ \u2211 , \u220f } \u00d7 Ter(G)+):\n\u2013 positions in P indicate game positions still to be expanded (if not terminal) and evaluated (otherwise).\n\u2013 values in U denote the value, already fully computed, of some sub-terms. \u2013 a complex term such as \u2211 \u3008t1...tn\u3009 or \u220f\n\u3008t1...tn\u3009 indicates a position at some state of its evaluation; \u2211 or \u220f\nholding the turn information, and t1...tn representing the game subterms from that state on.\nIt is crucial not to mistake terms of G, which represent partially expanded game trees, for game positions, which in practice will also tend to be structured symbolic terms, but can be considered atomic at a high level: the rewrite rules shown in the following work on Ter(G), not on P.\nSyntactic conventions We use (possibly with subscripts or primes) \u03c0 to indicate positions in P, s and t for generic terms, v for values in U, t and z for of terms in Ter(G). Sequences are allowed to be empty, if not specified otherwise in a side condition. Just to make the notation more compact we will write \u2211\nt instead of ( \u2211 , t) and \u220f t for ( \u220f , t). We write \u039b instead of either \u2211 or \u220f\n, just to avoid duplicating otherwise identical rules. Sequences are written with no commas, and parentheses or brackets are used to group when needed.\n\u03c0 \u2208 PT p(\u03c0) = v [Payoff] \u03c0 \u2192 v\nsucc(\u03c0) = t \u03bb(\u03c0) = P [P-expand] #t \u2265 1\n\u03c0 \u2192 \u2211 t\nsucc(\u03c0) = t \u03bb(\u03c0) = O [O-expand] #t \u2265 1\n\u03c0 \u2192 \u220f t\nhack[P-reduce] v1 \u2295 v2 = v\u2211 t\u3008v1 v2\u3009z \u2192 \u2211 t\u3008v\u3009z\nhack[O-reduce] v1 \u2299 v2 = v\u220f t\u3008v1 v2\u3009z \u2192 \u220f t\u3008v\u3009z\nhack[Return] \u039b\u3008v\u3009 \u2192 v\nt \u2192 t\u2032[Context] for all contexts C C[t] \u2192c C[t \u2032]\n[Payoff] simply replaces a terminal position with its value in U, by means of the payoff function. [P-expand] and [O-expand] expand a position, generating its successors and keeping track of the turn, which will be important at reduction time. [P-reduce] and [O-reduce] combine two values into one, using \u2295 for the player and \u2299 for the opponent. Notice that these two rules are sources of non-determinism. [Return] unwraps a completely evaluated term containing a single value. [Context] allows to use the other rules within nested terms (also introducing non-determinism).\nNotice that keeping the relation \u2192c distinct from \u2192 allows us, when needed, to see our semantics as a term rewriting system (TRS) [6].\nProposition 1. \u2192c is strongly confluent.\nProof. For the purposes of this proof, we consider the small-step semantics as a pure term-rewriting system, expressed in a slightly sugared notation. The system does not need to be conditional (CTRS), since all the rule premises can in fact be seen as structural constraints on syntactic constructors. \u2295 and \u2299 should also be read as syntactic constructors, with their associative properties written as rewrite rules. What is a variable in the rules becomes a (syntactic) variable in the TRS; however, we will not exploit the full power of the formal system: reductions will only be applied to ground terms1.\n1 We do not need the full power of unification: from a programming point of view, pattern matching as used in ML or Haskell is enough for our purposes.\nOur TRS is trivially left- and right-linear, as no variable occurs more than once in each side of a rule. By showing that our system is also strongly closed, strong confluence follows by Huet\u2019s Lemma 3.2 in [7]: \u201cIf R is a left- and rightlinear strongly closed term rewriting system, \u2192R is strongly confluent\u201d.\nIn order to show that the system is strongly-closed, we have to show that for every critical pair s, t there exist s\u2032, t\u2032 such that s \u2192\u2217 t\u2032 \u2190\u2261 t and t \u2192\u2217 s\u2032 \u2190\u2261 s (as in [7] and [6]), where \u2190\u2261 is the reflexive closure of \u2190.\nThe left-hand side of [P-reduce] is \u2211\nt\u3008v1 v2\u3009z. When this rule is used to generate a critical pair with any other rule, only a variable in t or in z can match, with the whole left-hand side of the other rule. The resulting critical pair s, t reaches confluence (to s\u2032 = t\u2032) in one step because redexes are non-overlapping. The same holds for [O-reduce].\nThe only rule pairs candidate for overlapping are [P-reduce] with itself, and [O-reduce] with itself; we only show the first one. The only interesting case of overlapping is the term family \u2211\nt\u3008v1 v2 v3\u3009z, generating the critical pair s, t. Notice that s\u2032 \u2192 t\u2032 and vice-versa because of the associativity of \u2295:\n\u2211\nt\u3008v1 v2 v3\u3009z \u0582 \u0581\ns = \u2211 t\u3008(v1 \u2295 v2)v3\u3009z \u2211\nt\u3008v1(v2 \u2295 v3)\u3009z = t \u2193 \u2193\ns\u2032 = \u2211 t\u3008(v1 \u2295 v2)\u2295 v3\u3009z \u21c6 \u2211 t\u3008v1 \u2295 (v2 \u2295 v3)\u3009z = t \u2032 \u2293\u2294\nDefinition 4 (Game tree). Let _ be the sub-rewrite system of \u2192c, made only by the rules [P-expand], [O-expand] and [Context]: given an initial position \u03c00 \u2208 P, the set of game tree prefixes from \u03c00 is the set T\u03c00 = {t | \u03c00 _\n\u2217 t}. The game tree, if it exists, is the tree t\u03c00 \u2208 T\u03c00 whose positions are all terminal.\nThe game tree t\u03c00 is well-defined: when it exists it is unique. Actually, the TRS defining _\u2217 is non-ambiguous (there is no overlap among any reduction rules) and left-linear: such a TRS is called orthogonal, and any orthogonal TRS is confluent [8].\nProposition 2. \u2192c is normalizing for any N\u00f6therian game.\nProof. Let a game G = (S,A, p) where S = (P, \u03bb, succ) and A = (U,\u2295,\u2299) be given. We prove normalization by exhibiting a reduction order < compatible with our rules [6].\nLet us define a weight function w : P \u2192 N to be a particular instance of the higher-order function vp\u0304 : P \u2192 U, where p\u0304(\u03c0) = 2 for any \u03c0 \u2208 PT and \u2295n\ni=1 xi = \u2299n i=1 xi = 2+ \u2211n i=1 xi for any x \u2208 N \u2217. Intuitively, w returns 2 times\nthe number of nodes in the game tree for N\u00f6therian games. Let f : Ter(G) \u2192 N be:\nf(\u03c0) = w(\u03c0), \u03c0 \u2208 P f(v) = 1, v \u2208 U f(\u039b\u3008t1...tn\u3009) = 1 + \u2211n i=1 f(ti)\nIn the formula above and in the rest of this proof \u2211\nrepresents the sum operation over N. We define our order on terms by using the interpretation f on >N: by definition, let t0 > t1 iff f(t0) >N f(t1). The order > is trivially stable, as\nour terms do not contain variables. > is also monotonic (f is increasing because + : N \u00d7 N \u2192 N is increasing), strict (>N is strict) and well-founded (>N is well-founded). Hence, > is a reduction order.\nIn order to prove compatibility we show that for every rule l \u2192 r we have l > r, which by definition is equivalent to f(l) >N f(r). All equalities follow from definitions or trivial algebraic manipulations:\n\u2013 [Payoff]: f(\u03c0) = w(\u03c0) = p\u0304(\u03c0) = 2 >N 1 = f(v). \u2013 [P-expand], [O-expand]: f(\u03c0) = w(\u03c0) = 2+ \u2211n\ni=1 w(\u03c0i) >N 1+ \u2211n\ni=1 w(\u03c0i) = 1 + \u2211n\ni=1 f(ti) = f(\u039b t).\n\u2013 [P-reduce], [O-reduce]: f(\u039b t\u3008v1v2\u3009z) = \u2211#t i=1 f(ti)+f(v1)+f(v2)+ \u2211#z\ni=1 f(zi) = \u2211#t\ni=1 f(ti)+1+1+ \u2211#z i=1 f(zi) >N \u2211#t i=1 f(ti)+1+ \u2211#z i=1 f(zi) = f(\u039b t\u3008v\u3009z).\n\u2013 [Return]: f(\u039b\u3008v\u3009) = 1 + 1 >N 1 = f(v). \u2293\u2294\nIntuitively, if a term converges then its sub-terms also converge; said otherwise if a term converges in a context, then it must also converge in the trivial (empty) context. This is true because of the non-erasing nature of our system, different from, for example, the \u03bb-calculus having actual reduction steps [8]. More formally:\nLemma 1 (Sub-term normalization). Given a game G = (S,A, p) where A = (U,\u2295,\u2299), for any term t \u2208 Ter(G) and any context C, if there exists v \u2208 U such that C[t] \u2192\u2217c v then there exists v \u2032 \u2208 U such that t \u2192\u2217c v \u2032.\nProof. By induction over the derivation length n of C[t] \u2192\u2217c v. We look at the possible shape of the premise of the [Context] rule, s \u2192 s\u2032.\n\u2013 Base case, n = 1: C[t] \u2192c v. The only applicable rules are [Payoff] and [Return]: in the case of [Payoff], C[t] = t; in the case of [Return], t = v. In either case, t \u2192\u2217c v = v\n\u2032. \u2013 Recursive case n \u21d2 n+ 1: t0 = C[t] \u2192c t1 \u2192 \u2217 c v. The inductive hypothesis\nis that for any term t\u2032 and context C\u2032 if C\u2032[t\u2032] \u2192\u2217c v in n or fewer steps, then t\u2032 \u2192\u2217c v\n\u2032. Three cases: \u2022 s and t are disjoint sub-terms within C. Since the system is non-erasing t has not been erased, i.e. t1 = C \u2032[t]; for inductive hypothesis t \u2192\u2217c v \u2032. \u2022 s contains t. s \u2192 s\u2032 may have as its premise [Return], in which case s = \u039b\u3008v\u3009 and t = v. Otherwise the premise may be [P-Reduce] or [OReduce]: either t is one of the values, or it matches one of the variables, in which case there exists a context C\u2032 such that t1 = C\n\u2032[t]; then the inductive hypothesis applies. \u2022 t contains s. t = C\u2032[s], hence by definition of \u2192c we have that t can turn into C\u2032[s\u2032] = t\u2032. There exists a context C\u2032\u2032 where C[s] = C\u2032\u2032[C\u2032[s]], hence t1 = C \u2032\u2032[C\u2032[s\u2032]]. By induction hypothesis t\u2032 = C\u2032[s\u2032] \u2192\u2217c v \u2032. \u2293\u2294\nNormalization and confluence justify our re-definition of the game value vp as the transitive closure of the transition relation \u2192c:\nDefinition 5 (Game Value). Let a game, an initial position \u03c0 and a value v be given; we say that the game value from \u03c0 is v (and we write vp(\u03c0) = v) if and only if \u03c0 \u2192\u2217c v."}, {"heading": "3 \u03b1-\u03b2 pruning", "text": "The \u03b1-\u03b2 algorithm [1,2] is a method for computing the exact value of a min-max combinatorial game without exhaustively visiting all game positions.\nThe \u03b1-\u03b2 algorithm is traditionally presented as a recursive function written in imperative style (see Figure 1): the function alpha_beta analyzes a game position \u03c0 \u2208 P with two additional parameters, \u03b1 and \u03b2, each one denoting a sort of threshold not to be overstepped during the incremental computation of the value of P. Whenever the threshold is past the evaluation of an entire subtree is aborted, as it can be proven that it will not contribute to the result.\nThe correctness of \u03b1-\u03b2 relies on the algebraic properties of the min and max functions, notably their mutual distributive laws \u2014 something we can not count on under our weaker hypotheses on \u2295 and \u2299 [4,5,3].\nGoing back to our game semantics presentation we can model the \u03b1-\u03b2\u2019s behavior by adding four more rules \u2014 two per player:\nhack[P-will] \u2211 \u3008\u03b1 [ \u220f \u3008\u03b2 ( \u2211 t1)\u3009 t2]\u3009 t3 \u2192 \u2211 \u3008\u03b1 [ \u220f \u3008\u03b2 ( \u2211 \u3008\u03b1\u3009t1)\u3009 t2]\u3009 t3\nhack[O-will] \u220f \u3008\u03b2 [ \u2211 \u3008\u03b1 ( \u220f t1)\u3009 t2]\u3009 t3 \u2192 \u220f \u3008\u03b2 [ \u2211 \u3008\u03b1 ( \u220f \u3008\u03b2\u3009t1)\u3009 t2]\u3009 t3\n\u03b1\u2295 \u03b2 = \u03b1 [P-cut] \u2211\n\u3008\u03b1 ( \u220f \u3008\u03b2\u3009t1)\u3009 t2 \u2192 \u2211 \u3008\u03b1\u3009t2\n\u03b2 \u2299 \u03b1 = \u03b2 [O-cut] \u220f\n\u3008\u03b2 ( \u2211 \u3008\u03b1\u3009t1)\u3009 t2 \u2192 \u220f \u3008\u03b2\u3009t2\nThe initialization of v at line 6 should be read as a first \u201cvirtual\u201d move of the player, whose evaluation is the value \u03b1 inherited from an ancestor (the grandparent in an alternate-turn game). This explains the rationale of [P-will]2: whenever subtrees are nested with turns P-O-P , a grandparent may cross two levels and \u201cgive\u201d its grandchild its current accumulator as an initialization value. Of course line 10 is the dual version for the opponent and [O-will].\n[P-cut] and [O-cut] are a simple reformulation of the cut conditions at lines 7 and 11, where the explicit order <Z disappears\n3 from the condition, now expressed as an equality constraint in the rule premise: \u03b1 \u2295 \u03b2 = \u03b1 represents the fact that the player would prefer \u03b1 over \u03b2. Dually, \u03b2 \u2299 \u03b1 = \u03b2 means that the opponent would prefer \u03b2 over \u03b1.\nRemark 3 (Non-alternate turn games). Notice that the cut rules can just fire in alternate-turn contexts: this choice simplifies our exposition, but does not limit generality: see Remarks 1 and 2.\nThe presence of two exactly symmetrical behaviors is quite evident in either presentation; yet what we are interested in showing now is the fact that such duality is quite incidental: it occurs in a natural way in actual two-player games, yet many more search problems lend themselves to be modeled as games despite lacking an intrinsic symmetry.\nWe can see \u03b1-\u03b2 as the union of two separate techniques applied at the same time, breaking the algebraic symmetry of the player/opponent operations: in the following we are going to eliminate the rules [O-will] and [O-cut], or equivalently to turn alpha_beta into tropical (see Figure 1), exploiting the weaker properties of tropical algebras which only allow one threshold \u03b1."}, {"heading": "4 Tropical games", "text": "As we are dealing with a relatively young research topic, it is not surprising that the formalization of tropical algebras has not yet crystallized into a standard form. And since several details differ among the various presentations, we have to provide our own definition:\nDefinition 6 (Tropical Algebra). An algebra (U,\u2295,\u2299) is called a tropical algebra if it satisfies the following properties for any a, b and c in U:\n(i) Associativity of \u2295: a\u2295 (b\u2295 c) = (a\u2295 b)\u2295 c (ii) Associativity of \u2299: a\u2299 (b\u2299 c) = (a\u2299 b)\u2299 c (iii) Left-distributivity of \u2299 with respect to \u2295: a\u2299 (b\u2295 c) = (a\u2299 b)\u2295 (a\u2299 c) (iv) Right-distributivity of \u2299 with respect to \u2295: (a\u2295 b)\u2299 c = (a\u2299 c)\u2295 (b\u2299 c)\n2 \u201cWill\u201d should be interpreted as \u201cbequeath\u201d, in the sense of leaving something as inheritance to a descendent. 3 This is customary with lattices, when an order is derived from a least-upper-bound or greatest-lower-bound operation.\nSome particular choices of U, \u2295 and \u2299 are widely used: the min-plus algebra is obtained by defining U , R \u222a {+\u221e}, a\u2295 b , min{a, b} and, a little counterintuitively4, a\u2299 b , a+ b.\nSince U and \u2299 can also be usefully instantiated in other ways, we will not simply adopt a min-plus algebra; anyway in practice we will also choose \u2295 to be a minimum on U, which in practice will have a total order. This seems to be the only reasonable choice for the applications5 and helps to understand the idea, yet nothing in the theory depends on the existence of the order. Again, in practice, \u2295 will return one of its parameters, so if needed we will always be able to trivially define a total order as x \u2264 y iff x \u2295 y = x, for any x and y in U. \u2295 and \u2299 will also tend to be commutative in practice, making one of the two distributive properties trivial.\nWe will not make any of the supplementary hypotheses above; on the other hand, we will require the following rationality hypothesis6:\nDefinition 7 (Rationality). Let (U,\u2295,\u2299) be a tropical algebra such that 0 \u2208 U is a neutral element for \u2295 and 1 \u2208 U is a neutral element for \u22997. We call the algebra rational if, for any x, y, z \u2208 U we have x\u2295 (y \u2299 x\u2299 z) = x.\nIntuitively, the opponent accumulates costs with \u2299, \u201cworsening\u201d the game value for the player: the player will always choose just x over x \u201cworsened\u201d by something else. Notice that the notion of rationality for two-player games in Game Theory also includes the dual condition x\u2299(y\u2295x\u2295z) = x; such condition does not hold in general for tropical games.\nDefinition 8 (Tropical Game, Tropical Trees). A tropical game G = (S,A, p) is simply a game based on a rational tropical algebra A. We call tropical trees all the game trees of a tropical game, and tropical pruning the \u03b1-pruning of a tropical tree. A bi-tropical game is a tropical game whose dual G\u22a5 = (S\u22a5,A\u22a5, p) is also tropical, where A\u22a5 = (U,\u2299,\u2295) if A = (U,\u2295,\u2299)."}, {"heading": "4.1 Soundness of tropical pruning", "text": "Proposition 3 (Insertion property). Let (U,\u2295,\u2299) be a rational tropical algebra. Then for any x, y, \u03b1, \u03b2 \u2208 U we have \u03b1\u2295(\u03b2\u2299x\u2299y) = \u03b1\u2295(\u03b2\u2299(\u03b1\u2295x)\u2299y).\nProof (Using associativity implicitly). \u03b1\u2295(\u03b2\u2299(\u03b1\u2295x)\u2299y) = {right-distributivity} \u03b1\u2295(\u03b2\u2299((\u03b1\u2299y)\u2295(x\u2299y))) = {left-distributivity} (\u03b1\u2295(\u03b2\u2299\u03b1\u2299y)\u2295(\u03b2\u2299x\u2299y) = {rationality} \u03b1\u2295 (\u03b2 \u2299 x\u2299 y) \u2293\u2294\n4 The particular symbols used for indicating \u2295 and \u2299 are justified by the analogy with + and \u00b7 in how the distributive law works. 5 Logic programming is an example of an interesting problem lending itself to be interpreted as a combinatorial game on a universe with no total order [3,4]. Anyway the underlying game is a symmetrical inf-sup rather than simply tropical. 6 In lattice theory, the rationality hypothesis is one of the absorption identities. 7 The existence of neutral elements is not strictly necessary, but it simplifies many statements and proofs; without them several results should be given in both \u201cleft\u201d and \u201cright\u201d forms.\nThe insertion property is the semantic counterpart of the rule [P-will]: it explains why we can \u201ctransfer\u201d \u03b1 down in the tree (or more operationally, why we can \u201cstart\u201d from the same \u03b1 when choosing with \u2295 two plies below), without affecting the game value.\nDefinition 9 (P-irrelevance). Let (U,\u2295,\u2299) be a rational tropical algebra, and let \u03b1, \u03b2 \u2208 U. Then we call x \u2208 U P-irrelevant with respect to \u03b1 and \u03b2 if \u03b1 \u2295 (\u03b2 \u2299 x) = \u03b1.\nIntuitively, as the value of an opponent-level tree, x can\u2019t affect the value of the game because the player will not give the opponent the opportunity to be in that situation: in other word, the current optimal move for the player doesn\u2019t change because of x.\nLemma 2 (P-irrelevance). Let (U,\u2295,\u2299) be a rational tropical algebra, and \u03b1, \u03b2 \u2208 U. If \u03b1\u2295 \u03b2 = \u03b1 then any x \u2208 U is P-irrelevant with respect to \u03b1 and \u03b2.\nProof. \u03b1\u2295 (\u03b2 \u2299 x) = {hypothesis} (\u03b1\u2295 \u03b2)\u2295 (\u03b2 \u2299 x) = {associativity} \u03b1\u2295 (\u03b2 \u2295 (\u03b2 \u2299 x)) = {rationality} \u03b1\u2295 \u03b2 = {hypothesis} \u03b1 \u2293\u2294\nDefinition 10 (Simulation). Given a tropical game, we say that a term t\u2032 simulates a term t, and we write t \u2264 t\u2032, if t \u2192\u2217c v \u21d2 t \u2032 \u2192\u2217c v.\nLemma 3 (Tropical P-will simulation). Given a tropical game G = (S,A, p) where A = (U,\u2295,\u2299), for any term sequence \u03b1, \u03b2 \u2208 U, t0, t1, t2 \u2208 Ter(G) \u2217\n\u2211 \u3008\u03b1 [ \u220f \u3008\u03b2 ( \u2211 t0)\u3009 t1]\u3009 t2 \u2264 \u2211 \u3008\u03b1 [ \u220f \u3008\u03b2 ( \u2211 \u3008\u03b1\u3009 t0)\u3009 t1]\u3009 t2\nProof. By the Sub-term normalization Lemma, if t converges there will exist some value sequences v0,v1,v2 \u2208 U such that t0 \u2192 \u2217 v0, t1 \u2192 \u2217 v1, t2 \u2192\n\u2217 v2; let us call v0 the result of \u2295 v0, v1 the result of \u2299 v1 and v2 the result of \u2295\nv2. Then,\n\u2211 \u3008\u03b1 [ \u220f \u3008\u03b2 ( \u2211 t0)\u3009 t1]\u3009 t2 \u2211 \u3008\u03b1 [ \u220f \u3008\u03b2 ( \u2211\n\u3008\u03b1\u3009 t0)\u3009 t1]\u3009 t2 \u2193\u2217 \u2193\u2217\n\u2211 \u3008\u03b1 [ \u220f \u3008\u03b2 v0 v1\u3009] v2\u3009 \u2211 \u3008\u03b1 [ \u220f\n\u3008\u03b2 (\u03b1\u2295 v0) v1\u3009] v2\u3009 \u2193\u2217 {Insertion} \u2193\u2217\n\u03b1\u2295 [\u03b2 \u2299 v0 \u2299 v1]\u2295 v2 = \u03b1\u2295 [\u03b2 \u2299 (\u03b1\u2295 v0)\u2299 v1]\u2295 v2\nIn the reductions above we implicitly assume that some sequences are non-empty; the proof trivially generalizes to empty t1 and t2 by using neutral elements. \u2293\u2294\nLemma 4 (Tropical cut simulation). Given a tropical game G = (S,A, p) where A = (U,\u2295,\u2299), for any term sequence \u03b1, \u03b2 \u2208 U, t0, t1 \u2208 Ter(G)\n\u2217 we have that if \u03b1\u2295 \u03b2 = \u03b1, then \u2211 \u3008\u03b1 ( \u220f \u3008\u03b2\u3009 t0)\u3009 t1 \u2264 \u2211 \u3008\u03b1\u3009 t1.\nProof. Just like Lemma 3, with P-irrelevance at the end. \u2293\u2294\nTheorem 1 (Tropical rule soundness). Adding the rules [P-will] and [Pcut] \u201cdoes not alter semantics\u201d, i.e. if a term t converges to a value v in a system without the two new rules, it is guaranteed to have a reduction sequence converging to v also in the extended system. \u2293\u2294"}, {"heading": "5 Choose-How-To-Divide and Conquer", "text": "According to the classical Divide and Conquer technique a problem can be divided into subproblems, each of which will be solved recursively until a minimalsize instance is found; sub-solutions will then be recomposed.\nIn the traditional Divide and Conquer style, each division choice is final: it is considered taken once and for all, and cannot be undone. By contrast we present an alternative model based on tropical games. In the Choose-How-To-Divide and Conquer style we work with non-deterministic choices in a solution space, using a quality criterion to be optimized and some way of \u201ccombining\u201d sub-solutions.\nOf course many nondeterministic algorithms can be expressed this way: the challenge is finding a suitable mapping to the tropical game concepts, in term of both syntax and semantics (with the required properties). The problem must have both a suitable syntactic structure, and a semantic structure with the required properties.\nThe action of choosing a division corresponds to a player node where the \u2295 function (typically a minimization) returns the \u201cbest\u201d option; the points where sub-solutions have their cost accumulated (often something similar to a sum, intuitively \u201copposed\u201d to \u2295) become opponent nodes where \u2299 combines the values of a subtree sequence into a single result.\nTropical trees have the desirable property of supporting \u03b1-pruning, with the potential of significantly cutting down the search space. The more [P-will] and [P-cut] can fire, the more pruning is profitable: hence the problem should be represented as a tropical game having alternate turns and branching factor greater than 2 for O at least \u201coften enough\u201d. Search problems abound in Artificial Intelligence, and in particular we suspect that more symbolic computation problems than one might expect can be modeled this way. We now proceed to show an unusual application of Choose-HowTo-Divide and Conquer."}, {"heading": "5.1 Parsing as a tropical game", "text": "Let G be a given context-free grammar, defined over an alphabet of terminals A \u220b a and nonterminals N \u220b X . For simplicity8 let it have no \u01eb-production, nor any productions with two consecutive nonterminals or a single nonterminal alone in the right-hand side. Right-hand sides will hence be of the form [a1]X1a2X2...anXn[an+1], with n \u2265 0 and at least one ai. Given a string of terminals s \u2208 A+ our problem is finding the \u201cbest\u201d parse tree of s in G ; when s contains some errors our \u201cbest\u201d solution just ends up being the least wrong, according to some metric; just to keep things simple in this example out metric to minimize will be the total size of the substrings which cannot be matched, in terminals. Sometimes we may wish to have the set of all best parses, instead of being content with just one optimal solution.\n8 Such restrictions can be lifted at the cost of some complexity, but supporting a larger class of grammars would be quite inessential for our demonstrative purposes.\nSyntax. The set of game positions is defined as P = (A\u2217\u00d7N)\u228e (A\u2217 \u00d7N)\u2217, and the turn function is \u03bb(s,X) = P , \u03bb((s1, X1)...(sk, Xk)) = O. These definitions become easy to understand once the successor function succ is examined.\nA player position has the form \u03c0P = (s,X), since the player has to parse a string s with a nonterminalX . It has to choose a productionX ::= [a1]X1a2X2... anXn[an+1], and match the terminals ai with the terminals in s, in the right order. Each possible match of all terminals, for each production of X , is a valid player move generating strictly smaller subproblems for the opponent: the nonterminals Xi \u201cin between\u201d the matched terminals will have to be matched to substrings of s in the opponent position \u03c0O = (s1, X1)...(s1, Xn), for some n \u2265 0. If no match exists with any production then \u03c0P is terminal.\nIn an opponent position \u03c0O = (s1, X1)...(s1, Xn) the opponent has always exactly n moves: the opponent will give the player each pair (si, Xi) to solve \u201cone at the time\u201d. For this reason the successor of an opponent position is equal to the position itself: it is the sequence of the elements of \u03c0O, itself a sequence. An opponent position \u03c0O is terminal when it is empty.\nFigure 2 contains a practical example."}, {"heading": "E ::= n", "text": ""}, {"heading": "E ::= v", "text": ""}, {"heading": "E ::= ( E )", "text": "Semantics. We use a min-plus algebra for A = (U,\u2295,\u2299): we simply define U , N; we take \u2295 , min, since we want as few errors as possible; and finally \u2299 , +: the number of total errors in the parse tree is equal to the sum of the number of errors in all subtrees.\nThe payoff p(\u03c0) is defined as the length in characters of the input string for player positions (notice that the payoff is only defined on terminal positions, so such a length is actually the number of unmatched characters), and zero for opponent positions (if \u03c0O = \u3008\u3009 then there are no errors to accumulate: at the level above, the player matched the whole string): p(s,X) , #s, p(\u3008\u3009) , 0.\nExperiments We implemented a prototype system9 in ML supporting the grammar of Figure 2, which can be configured to do a simple exhaustive search or perform tropical \u03b1-pruning. The prototype supports two policies: first-minimal (henceforth FM) searches for only one optimal strategy at P \u2019s levels, and allminimals (henceforth AM) generates a sequence of strategies with non-increasing cost. Just as illustrative examples, we proceed to show our system behavior on some input strings belonging to different categories.\nNon-ambiguous input: the input string \"let x = 42 in x + if 84=42 then 55 else 77\" is parsable in a unique way, so the FM policy is clearly the right choice. Compared to an exhaustive search the \u03b1-pruning FM version avoids 98% of the recursive calls (460 vs 28473) and its completion time is 4%. By setting the policy to AM the number of recursive call grows a little, from 460 to 671 (still avoiding 97% of the calls).\nAmbiguous input: with the input string \"let x = 84 = 42 = 21 in 1 + 2 * 3\", which is parsable in several ways, the the \u03b1-pruning FM version avoids 99% of the recursive calls (260 vs 61980), and the run time is 1% of the exhaustivesearch version time. The \u03b1-pruning AM version still avoids 96% of the recursive calls (2148 vs 61980), and its run time is 3%.\n\u201cWrong\u201d input:with the input string \"if if if true then true else false then 10 else (1+(2+)+3)\", containing errors, the \u03b1-pruning FM version avoids 98% of the recursive calls (9640 vs 494344) and its run time is 3%, while the AM version avoids 97% of the recursive calls (13820 vs 494344); the AM version\u2019s run time is reduced to 3%. The best strategy has value 6, corresponding to the size of the substring \"if true\" (blanks are not counted) added to the size (0) of the empty substring delimited by the tokens \"+\" and \")\". The \u03b1-pruning algorithm has localized errors, guessing that the user should fix her string by replacing \"if true\" with something correct and writing something correct between \"+\" and \")\" \u2014 having the size of the unmatched substrings as the payoff function yields this \u201csmallest-incorrect-string\u201d heuristic. Of course other more elaborate criteria are also possible, such as \u201cminimum number of errors\u201d.\nMemoization: on a completely orthogonal axis, the implementation may be configured to perform memoization: when memoization is turned on all the already solved positions are cached, so that they are not computed more than once. We have compared a memoizing version of our tropical-\u03b1-pruning parser with a memoizing version performing exhaustive search. In the first case above, the string \"let x = 42 in x + if 84=42 then 55 else 77\" is now parsed with 131 calls instead of 460, again saving 98% of the calls (131 vs 7295) and cutting the run time to 1%. \"let x = 84 = 42 = 21 in 1 + 2 * 3\" is now parsed with 72 calls instead of 260, avoiding 99% of the calls (72 vs 14443) and reducing the run time to 7%. The string \"if if if true then true else false then 10 else (1+(2+)+3)\" is parsed with 1206 calls instead of 9640, avoiding 96% of calls (1206 vs 36575) and cutting the completion time to 10%.\n9 The prototype is freely available under the GNU GPL license at the address http://www-lipn.univ-paris13.fr/~loddo/aisc-2010.\nAt least in our small test cases, tropical \u03b1-pruning and memoization work well together: enabling either one does not significantly lessen the efficacy of the other."}, {"heading": "6 Conclusions and future work", "text": "We have introduced and formally proved correct tropical \u03b1-pruning, a variant of \u03b1-\u03b2-pruning applicable to the tropical games underlying Choose-How-To-Divide and Conquer problems. As a practical example of the technique we have shown how the problem of approximated parsing and error localization can be modeled as a game, and how our pruning technique can dramatically improve its efficiency; yet an asymptotic measure of the visited node reduction would be a worthy development.\nWe suspect that many more problems can be formalized as tropical games, and the problem of parsing itself can also definitely be attacked in a more general way, lifting our restrictions on the grammar; tropical parsing might prove to be particularly suitable for natural language problems, with their inherent ambiguity.\nThe correctness and efficiency of parallel tropical \u03b1-pruning implementations would be particularly interesting to study.\nAcknowledgments Christophe Fouquer\u00e9 first recognized tropical algebras in the properties required by our formalization."}], "references": [{"title": "The tree prune (TP) algorithm", "author": ["T.P. Hart", "D.J. Edwards"], "venue": "Artificial Intelligence Project Memo 30, Massachusetts Institute of Technology, Cambridge, Massachusetts", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1961}, {"title": "An analysis of alpha-beta pruning", "author": ["D.E. Knuth", "R.W. Moore"], "venue": "Artificial Intelligence 6", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1975}, {"title": "G\u00e9n\u00e9ralisation des Jeux Combinatoires et Applications aux Langages Logiques", "author": ["J.V. Loddo"], "venue": "PhD thesis, Universit\u00e9 Paris VII", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2002}, {"title": "Playing logic programs with the alpha-beta algorithm", "author": ["J.V. Loddo", "R.D. Cosmo"], "venue": "Logic for Programming and Automated Reasoning (LPAR). Number 1955 in LNCS, Springer", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2000}, {"title": "Alpha-beta pruning under partial orders", "author": ["M.L. Ginsberg", "A. Jaffray"], "venue": "In Games of No Chance II.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2001}, {"title": "First-order term rewriting systems", "author": ["J.W. Klop", "R. de Vrijer"], "venue": "In Terese, ed.: Term Rewriting Systems. Cambridge Universisty Press", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "Confluent reductions: Abstract properties and applications to term rewriting systems: Abstract properties and applications to term rewriting systems", "author": ["G. Huet"], "venue": "J. ACM 27(4)", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1980}, {"title": "Orthogonality", "author": ["J.W. Klop", "V.V. Oostrom", "R. de Vrijer"], "venue": "In Terese, ed.: Term Rewriting Systems. Cambridge Universisty Press", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 0, "context": "Some optimized search techniques were developed, which in the case of combinatorial two-player games include the \u03b1-\u03b2 pruning technique [1,2].", "startOffset": 135, "endOffset": 140}, {"referenceID": 1, "context": "Some optimized search techniques were developed, which in the case of combinatorial two-player games include the \u03b1-\u03b2 pruning technique [1,2].", "startOffset": 135, "endOffset": 140}, {"referenceID": 2, "context": "Following the style introduced by [3] and [4], we will distinguish two aspects of two-player combinatorial games: a first one that we call syntactic, consisting This work is partially financed by Marie Curie action n.", "startOffset": 34, "endOffset": 37}, {"referenceID": 3, "context": "Following the style introduced by [3] and [4], we will distinguish two aspects of two-player combinatorial games: a first one that we call syntactic, consisting This work is partially financed by Marie Curie action n.", "startOffset": 42, "endOffset": 45}, {"referenceID": 3, "context": "Actually, our soundness result subsumes other works proving \u03b1-\u03b2\u2019s soundness over distributive lattices such as [4] and (later) [5], since distributive lattices are bi-tropical structures (Definition 8).", "startOffset": 111, "endOffset": 114}, {"referenceID": 4, "context": "Actually, our soundness result subsumes other works proving \u03b1-\u03b2\u2019s soundness over distributive lattices such as [4] and (later) [5], since distributive lattices are bi-tropical structures (Definition 8).", "startOffset": 127, "endOffset": 130}, {"referenceID": 5, "context": "Notice that keeping the relation \u2192c distinct from \u2192 allows us, when needed, to see our semantics as a term rewriting system (TRS) [6].", "startOffset": 130, "endOffset": 133}, {"referenceID": 6, "context": "2 in [7]: \u201cIf R is a left- and rightlinear strongly closed term rewriting system, \u2192R is strongly confluent\u201d.", "startOffset": 5, "endOffset": 8}, {"referenceID": 6, "context": "In order to show that the system is strongly-closed, we have to show that for every critical pair s, t there exist s, t such that s \u2192 t \u2190 t and t \u2192 s \u2190 s (as in [7] and [6]), where \u2190 is the reflexive closure of \u2190.", "startOffset": 161, "endOffset": 164}, {"referenceID": 5, "context": "In order to show that the system is strongly-closed, we have to show that for every critical pair s, t there exist s, t such that s \u2192 t \u2190 t and t \u2192 s \u2190 s (as in [7] and [6]), where \u2190 is the reflexive closure of \u2190.", "startOffset": 169, "endOffset": 172}, {"referenceID": 7, "context": "Actually, the TRS defining _ is non-ambiguous (there is no overlap among any reduction rules) and left-linear: such a TRS is called orthogonal, and any orthogonal TRS is confluent [8].", "startOffset": 180, "endOffset": 183}, {"referenceID": 5, "context": "We prove normalization by exhibiting a reduction order < compatible with our rules [6].", "startOffset": 83, "endOffset": 86}, {"referenceID": 7, "context": "This is true because of the non-erasing nature of our system, different from, for example, the \u03bb-calculus having actual reduction steps [8].", "startOffset": 136, "endOffset": 139}, {"referenceID": 0, "context": "The \u03b1-\u03b2 algorithm [1,2] is a method for computing the exact value of a min-max combinatorial game without exhaustively visiting all game positions.", "startOffset": 18, "endOffset": 23}, {"referenceID": 1, "context": "The \u03b1-\u03b2 algorithm [1,2] is a method for computing the exact value of a min-max combinatorial game without exhaustively visiting all game positions.", "startOffset": 18, "endOffset": 23}, {"referenceID": 3, "context": "The correctness of \u03b1-\u03b2 relies on the algebraic properties of the min and max functions, notably their mutual distributive laws \u2014 something we can not count on under our weaker hypotheses on \u2295 and \u2299 [4,5,3].", "startOffset": 198, "endOffset": 205}, {"referenceID": 4, "context": "The correctness of \u03b1-\u03b2 relies on the algebraic properties of the min and max functions, notably their mutual distributive laws \u2014 something we can not count on under our weaker hypotheses on \u2295 and \u2299 [4,5,3].", "startOffset": 198, "endOffset": 205}, {"referenceID": 2, "context": "The correctness of \u03b1-\u03b2 relies on the algebraic properties of the min and max functions, notably their mutual distributive laws \u2014 something we can not count on under our weaker hypotheses on \u2295 and \u2299 [4,5,3].", "startOffset": 198, "endOffset": 205}, {"referenceID": 2, "context": "5 Logic programming is an example of an interesting problem lending itself to be interpreted as a combinatorial game on a universe with no total order [3,4].", "startOffset": 151, "endOffset": 156}, {"referenceID": 3, "context": "5 Logic programming is an example of an interesting problem lending itself to be interpreted as a combinatorial game on a universe with no total order [3,4].", "startOffset": 151, "endOffset": 156}], "year": 2013, "abstractText": "We present tropical games, a generalization of combinatorial min-max games based on tropical algebras. Our model breaks the traditional symmetry of rational zero-sum games where players have exactly opposed goals (min vs. max), is more widely applicable than min-max and also supports a form of pruning, despite it being less effective than \u03b1-\u03b2. Actually, min-max games may be seen as particular cases where both the game and its dual are tropical: when the dual of a tropical game is also tropical, the power of \u03b1-\u03b2 is completely recovered. We formally develop the model and prove that the tropical pruning strategy is correct, then conclude by showing how the problem of approximated parsing can be modeled as a tropical game, profiting from pruning.", "creator": "LaTeX with hyperref package"}}}