{"id": "1005.1716", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-May-2010", "title": "Heuristics in Conflict Resolution", "abstract": "modern solvers for boolean satisfiability ( sat ) calculation and answer set programming ( complete asp ) are based on sophisticated boolean constraint solving techniques. embedded in three both areas, conflict - driven learning and related techniques constitute key features whose application is otherwise enabled by conflict analysis. although various underlying conflict analysis schemes have been proposed, occasionally implemented, and already studied both theoretically and practically in the sat area, the heuristic aspects themselves involved frequently in conflict analysis have itself not yet actually received much attention. assuming a fixed conflict conflict analysis scheme, we may address the open question of just how to identify \" good'' reasons for conflicts, and we investigate several heuristics for conflict analysis in asp solving. to our knowledge, a systematic study like ours has not yet been performed in the sat area, thus, it might be beneficial for launching both the field of asp as well as the newer one of sat solving.", "histories": [["v1", "Tue, 11 May 2010 05:32:37 GMT  (104kb,D)", "http://arxiv.org/abs/1005.1716v1", null]], "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["christian drescher", "martin gebser", "benjamin kaufmann", "torsten schaub"], "accepted": false, "id": "1005.1716"}, "pdf": {"name": "1005.1716.pdf", "metadata": {"source": "CRF", "title": "Heuristics in Conflict Resolution", "authors": ["Christian Drescher", "Martin Gebser", "Torsten Schaub"], "emails": [], "sections": [{"heading": "Introduction", "text": "The popularity of Answer Set Programming (ASP; (Baral 2003)) as a paradigm for knowledge representation and reasoning is mainly due to two factors: first, its rich modeling language and, second, the availability of highperformance ASP systems. In fact, modern ASP solvers, such as clasp (Gebser et al. 2007a), cmodels (Giunchiglia, Lierler, & Maratea 2006), and smodelscc (Ward & Schlipf 2004), have meanwhile closed the gap to Boolean Satisfiability (SAT; (Mitchell 2005)) solvers. In both fields, conflict-driven learning and related techniques have led to significant performance boosts (Bayardo & Schrag 1997; Marques-Silva & Sakallah 1999; Moskewicz et al. 2001; Gebser et al. 2007d). The basic prerequisite for the application of such techniques is conflict analysis, that is, the extraction of non-trivial reasons for dead ends encountered during search. Even though ASP and SAT solvers exploit different inference patterns, their underlying search techniques are closely related to each other. For instance, the basic search strategy of SAT solver chaff (Moskewicz et al. 2001), nowadays a quasi standard in SAT solving, is also exploited by ASP solver clasp, in particular, the principles of conflict analysis are similar. Vice versa, the solution enumeration approach implemented in clasp (Gebser et al. 2007b) could also be applied by SAT solvers. Given these similarities, general search or, more specifically, conflict analysis techniques developed in one community can\n(almost) immediately be exploited in the other field too. In this paper, we address the problem of identifying \u201cgood\u201d reasons for conflicts to be recorded within an ASP solver. In fact, conflict-driven learning exhibits several degrees of freedom. For instance, several constraints may become violated simultaneously, in which case one can choose the conflict(s) to be analyzed. Furthermore, distinct schemes may be used for conflict analysis, such as the resolutionbased First-UIP and Last-UIP scheme (Zhang et al. 2001). Finally, if conflict analysis is based on resolution, several constraints may be suitable resolvents, likewise permitting to eliminate some literal in a resolution step.\nFor the feasibility of our study, it was necessary to prune dimensions of freedom in favor of predominant options. In the SAT area, the First-UIP scheme (Marques-Silva & Sakallah 1999) has empirically been shown to yield better performance than other known conflict resolution strategies (Zhang et al. 2001). We thus fix the conflict analysis strategy to conflict resolution according to the First-UIP scheme. Furthermore, it seems reasonable to analyze the first conflict detected by a solver (although conflicts encountered later on may actually yield \u201cbetter\u201d reasons). This leaves to us the choice of the resolvents to be used for conflict resolution, and we investigate this issue with respect to different goals: reducing the size of reasons to be recorded, skipping greater portions of the search space by backjumping (explained below), reducing the number of conflict resolution steps, and reducing the overall number of encountered conflicts (roughly corresponding to runtime). To this end, we modified the conflict analysis procedure of our ASP solver clasp1 for accommodating a variety of heuristics for choosing resolvents. The developed heuristics and comprehensive empirical results for them are presented in this paper."}, {"heading": "Logical Background", "text": "We assume basic familiarity with answer set semantics (see, for instance, (Baral 2003)). This section briefly introduces notations and recalls a constraint-based characterization of answer set semantics according to (Gebser et al. 2007c). We consider propositional (normal) logic programs over an alphabet P . A logic program is a finite set of rules\np0 \u2190 p1, . . . , pm,\u223cpm+1, . . . ,\u223cpn (1) 1http://www.cs.uni-potsdam.de/clasp\nar X\niv :1\n00 5.\n17 16\nv1 [\ncs .A\nI] 1\n1 M\nay 2\n01 0\nwhere 0 \u2264 m \u2264 n and pi \u2208 P is an atom for 0 \u2264 i \u2264 n. For a rule r as in (1), let head(r) = p0 be the head of r and body(r) = {p1, . . . , pm,\u223cpm+1, . . . ,\u223cpn} be the body of r. The set of atoms occurring in a logic program \u03a0 is denoted by atom(\u03a0), and the set of bodies in \u03a0 is body(\u03a0) = {body(r) | r \u2208 \u03a0}. For regrouping bodies sharing the same head p, define body(p) = {body(r) | r \u2208 \u03a0, head(r) = p}.\nFor characterizing the answer sets of a program \u03a0, we consider Boolean assignments A over domain dom(A) = atom(\u03a0) \u222a body(\u03a0). Formally, an assignment A is a sequence (\u03c31, . . . , \u03c3n) of (signed) literals \u03c3i of the form Tv or Fv for v \u2208 dom(A) and 1 \u2264 i \u2264 n. Intuitively, Tv expresses that v is true and Fv that it is false in A. We denote the complement of a literal \u03c3 by \u03c3, that is, Tv = Fv and Fv = Tv. Furthermore, we let A \u25e6 B denote the sequence obtained by concatenating two assignments A and B. We sometimes abuse notation and identify an assignment with the set of its contained literals. Given this, we access the true and false propositions in A via AT = {p \u2208 dom(A) | Tp \u2208 A} and AF = {p \u2208 dom(A) | Fp \u2208 A}. Finally, we denote the prefix of A up to a literal \u03c3 by\nA[\u03c3] = { (\u03c31, . . . , \u03c3m) if A = (\u03c31, . . . , \u03c3m, \u03c3, . . . , \u03c3n) A if \u03c3 /\u2208 A .\nIn our context, a nogood (Dechter 2003) is a set {\u03c31, . . . , \u03c3m} of literals, expressing a constraint violated by any assignment containing \u03c31, . . . , \u03c3m. An assignment A such that AT \u222aAF = dom(A) and AT \u2229AF = \u2205 is a solution for a set \u2206 of nogoods if \u03b4 6\u2286 A for all \u03b4 \u2208 \u2206. Given a logic program \u03a0, we below specify nogoods such that their solutions correspond to the answer sets of \u03a0.\nWe start by describing nogoods capturing the models of the Clark\u2019s completion (Clark 1978) of a program \u03a0. For (\u03b2 = {p1, . . . , pm,\u223cpm+1, . . . ,\u223cpn}) \u2208 body(\u03a0), let\n\u2206\u03b2 = {Tp1, . . . ,Tpm,Fpm+1, . . . ,Fpn,F\u03b2},{Fp1,T\u03b2}, . . . , {Fpm,T\u03b2},{Tpm+1,T\u03b2}, . . . , {Tpn,T\u03b2}  .\nObserve that every solution for \u2206\u03b2 must assign body \u03b2 equivalent to the conjunction of its elements. Similarly, for an atom p \u2208 atom(\u03a0), the following nogoods stipulate p to be equivalent to the disjunction of body(p) = {\u03b21, . . . , \u03b2k}:\n\u2206p = { {F\u03b21, . . . ,F\u03b2k,Tp}, {T\u03b21,Fp}, . . . , {T\u03b2k,Fp} } .\nCombining the above nogoods for \u03a0, we get \u2206\u03a0 = \u22c3 \u03b2\u2208body(\u03a0)\u2206\u03b2 \u222a \u22c3 p\u2208atom(\u03a0)\u2206p .\nThe solutions for \u2206\u03a0 correspond one-to-one to the models of the completion of \u03a0. If \u03a0 is tight (Fages 1994; Erdem & Lifschitz 2003), these models are guaranteed to match the answer sets of \u03a0. This can be formally stated as follows.\nTheorem 1 ((Gebser et al. 2007c)) Let \u03a0 be a tight logic program. Then, X \u2286 atom(\u03a0) is an answer set of \u03a0 iff X = AT \u2229 atom(\u03a0) for a (unique) solution A for \u2206\u03a0.\nWe proceed by considering non-tight programs \u03a0. As shown in (Lin & Zhao 2004), loop formulas can be added to the completion of \u03a0 to establish full correspondence to the answer sets of \u03a0. For U \u2286 atom(\u03a0), let EB\u03a0(U) be\n{body(r) | r \u2208 \u03a0, head(r) \u2208 U, body(r) \u2229 U = \u2205} .\nObserve that EB\u03a0(U) contains the bodies of all rules in \u03a0 that can externally support (Lee 2005) an atom in U . Given U = {p1, . . . , pj} and EB\u03a0(U) = {\u03b21, . . . , \u03b2k}, the following nogoods capture the loop formula of U :\n\u039bU = { {F\u03b21, . . . ,F\u03b2k,Tp1}, . . . , {F\u03b21, . . . ,F\u03b2k,Tpj} } .\nFurthermore, we define \u039b\u03a0 = \u22c3 U\u2286atom(\u03a0)\u039bU .\nBy augmenting \u2206\u03a0 with \u039b\u03a0, Theorem 1 can be extended to non-tight programs. Theorem 2 ((Gebser et al. 2007c)) Let \u03a0 be a logic program. Then, X \u2286 atom(\u03a0) is an answer set of \u03a0 iff X = AT\u2229atom(\u03a0) for a (unique) solutionA for \u2206\u03a0\u222a\u039b\u03a0.\nBy virtue of Theorem 2, the nogoods in \u2206\u03a0 \u222a \u039b\u03a0 provide us with a constraint-based characterization of the answer sets of \u03a0. However, it is important to note that the size of \u2206\u03a0 is linear in atom(\u03a0)\u00d7body(\u03a0), while \u039b\u03a0 contains exponentially many nogoods. As shown in (Lifschitz & Razborov 2006), under current assumptions in complexity theory, the exponential number of elements in \u039b\u03a0 is inherent, that is, it cannot be reduced significantly in the worst case. Hence, ASP solvers do not determine the nogoods in \u039b\u03a0 a priori, but include mechanisms to determine them on demand. This is illustrated further in the next section."}, {"heading": "Algorithmic Background", "text": "This section recalls the basic decision procedure of clasp (Gebser et al. 2007c), abstracting Conflict-Driven Clause Learning (CDCL; (Mitchell 2005)) for SAT solving from clauses, that is, Conflict-Driven Nogood Learning (CDNL)."}, {"heading": "Conflict-Driven Nogood Learning", "text": "Algorithm 1 shows our main procedure for deciding whether a program \u03a0 has some answer set. The algorithm starts with an empty assignment A and an empty set \u2207 of recorded nogoods (Lines 1\u20132). Note that dynamic nogoods added to \u2207 in Line 5 are elements of \u039b\u03a0, while those added in Line 9 result from conflict analysis (Line 8). In addition to conflict-driven learning, the procedure performs backjumping (Lines 10\u201311), guided by a decision level k determined by conflict analysis. Via decision level dl , we count decision literals, that is, literals in A that have been heuristically selected in Line 15. The initial value of dl is 0 (Line 3), and it is incremented in Line 16 before a decision literal is added to A (Line 17). All literals in A that are not decision literals have been derived by propagation in Line 5, and we call them implied literals. For any literal \u03c3 in A, we write dl(\u03c3) to refer to the decision level of \u03c3, that is, the value dl had when \u03c3 was added to A. After propagation, the main loop\nAlgorithm 1: CDNL Input : A program \u03a0. Output: An answer set of \u03a0. A\u2190 \u2205 // assignment over atom(\u03a0) \u222a body(\u03a0)1 \u2207 \u2190 \u2205 // set of (dynamic) nogoods2 dl \u2190 0 // decision level3 loop4 (A,\u2207)\u2190 PROPAGATION(\u03a0,\u2207, A)5 if \u03b5 \u2286 A for some \u03b5 \u2208 \u2206\u03a0 \u222a\u2207 then6\nif dl = 0 then return no answer set7 (\u03b4, k)\u2190 CONFLICTANALYSIS(\u03b5,\u03a0,\u2207, A)8 \u2207 \u2190 \u2207\u222a {\u03b4}9 A\u2190 A \\ {\u03c3 \u2208 A | k < dl(\u03c3)}10 dl \u2190 k11\nelse if AT \u222aAF = atom(\u03a0) \u222a body(\u03a0) then12 return AT \u2229 atom(\u03a0)13 else14 \u03c3d \u2190 SELECT(\u03a0,\u2207, A)15 dl \u2190 dl + 116 A\u2190 A \u25e6 (\u03c3d)17\n(Lines 4\u201317) distinguishes three cases: a conflict detected via a violated nogood (Lines 6\u201311), a solution (Lines 12\u2013 13), or a heuristic selection with respect to a partial assignment (Lines 14\u201317). Finally, note that a conflict at decision level 0 signals that \u03a0 has no answer set (Line 7)."}, {"heading": "Propagation", "text": "Our propagation procedure, shown in Algorithm 2, derives implied literals and adds them to A. Lines 3\u20139 describe unit propagation (cf. (Mitchell 2005)) on \u2206\u03a0\u222a\u2207. If a conflict is detected in Line 4, unit propagation terminates immediately (Line 5). Otherwise, in Line 6, we determine all nogoods \u03b4 that are unit-resulting wrt A, that is, the complement \u03c3 of some literal \u03c3 \u2208 \u03b4 must be added to A because all other literals of \u03b4 are already true inA. If there is some unit-resulting nogood \u03b4 (Line 7), A is augmented with \u03c3 in Line 8. Observe that \u03b4 is chosen non-deterministically, and several distinct nogoods may imply \u03c3 wrt A. This non-determinism gives rise to our study of heuristics for conflict resolution, selecting a resolvent among the nogoods \u03b4 that imply \u03c3.\nThe second part of Algorithm 2 (Lines 10\u201314) checks for unit-resulting or violated nogoods in \u039b\u03a0. If \u03a0 is tight (Line 10), sophisticated checks are unnecessary (cf. Theorem 1). Otherwise, we consider sets U \u2286 atom(\u03a0) such that EB\u03a0(U) \u2286 AF, called unfounded sets (Van Gelder, Ross, & Schlipf 1991). An unfounded set U is determined in Line 12 by a dedicated algorithm, whereU\u2229AF = \u2205. If such a nonempty unfounded set U exists, each nogood \u03b4 \u2208 \u039bU is either unit-resulting or violated wrt A, and an arbitrary \u03b4 \u2208 \u039bU is recorded in Line 14 for triggering unit propagation. Note that all atoms in U must be falsified before another unfounded set is determined (cf. Lines 11\u201312). Eventually, propagation terminates in Line 13 if no nonempty unfounded set has been detected in Line 12.\nAlgorithm 2: PROPAGATION Input : A program \u03a0, a set\u2207 of nogoods, and an\nassignment A. Output: An extended assignment and set of nogoods. U \u2190 \u2205 // unfounded set1 loop2 repeat3 if \u03b4 \u2286 A for some \u03b4 \u2208 \u2206\u03a0 \u222a\u2207 then4 return (A,\u2207)5 \u03a3\u2190 {\u03b4 \u2208 \u2206\u03a0 \u222a\u2207 | \u03b4 \\A = {\u03c3}, \u03c3 /\u2208 A}6 if \u03a3 6= \u2205 then let \u03c3 \u2208 \u03b4 \\A for some \u03b4 \u2208 \u03a3 in7\nA\u2190 A \u25e6 (\u03c3)8 until \u03a3 = \u22059 if TIGHT(\u03a0) then return (A,\u2207)10 U \u2190 U \\AF11 if U = \u2205 then U \u2190 UNFOUNDEDSET(\u03a0, A)12 if U = \u2205 then return (A,\u2207)13 let \u03b4 \u2208 \u039bU in\u2207 \u2190 \u2207\u222a {\u03b4}14\nAlgorithm 3: CONFLICTANALYSIS Input : A violated nogood \u03b4, a program \u03a0, a set \u2207 of\nnogoods, and an assignment A. Output: A derived nogood and a decision level. loop1 let \u03c3 \u2208 \u03b4 such that \u03b4 \\A[\u03c3] = {\u03c3}2 k \u2190 max ({dl(\u03c1) | \u03c1 \u2208 \u03b4 \\ {\u03c3}} \u222a {0})3 if k = dl(\u03c3) then4 \u03a3\u2190 {\u03b5 \u2208 \u2206\u03a0 \u222a\u2207 | \u03b5 \\A[\u03c3] = {\u03c3}}5 \u03b5\u2190 SELECTANTECEDENT(\u03a3)6 \u03b4 \u2190 (\u03b4 \\ {\u03c3}) \u222a (\u03b5 \\ {\u03c3})7\nelse return (\u03b4, k)8"}, {"heading": "Conflict Analysis", "text": "Algorithm 3 shows our conflict analysis procedure, which is based on resolution. Given a nogood \u03b4 that is violated wrt A, we determine in Line 2 the literal \u03c3 \u2208 \u03b4 added last to A. If \u03c3 is the single literal of its decision level dl(\u03c3) in \u03b4 (cf. Line 3), it is called a unique implication point (UIP; (Marques-Silva & Sakallah 1999)). Among a number of conflict resolution schemes, the First-UIP scheme, stopping conflict resolution as soon as the first UIP is reached, has turned out to be the most efficient and most robust strategy (Zhang et al. 2001). Our conflict analysis procedure follows the First-UIP scheme by performing conflict resolution only if \u03c3 is not a UIP (tested in Line 4) and, otherwise, returning \u03b4 along with the smallest decision level k at which \u03c3 is implied by \u03b4 after backjumping (Line 8).\nLet us take a closer look at conflict resolution steps in Lines 5\u20137. It is important to note that, if \u03c3 is not a UIP, it cannot be the decision literal of dl(\u03c3). Rather, it must have been implied by some nogood \u03b5 \u2208 \u2206\u03a0 \u222a \u2207. As a consequence, the set \u03a3 determined in Line 5 cannot be empty, and\nwe call its elements antecedents of \u03c3. Note that each antecedent \u03b5 contains \u03c3 and had been unit-resulting immediately before \u03c3 was added to A; we thus call \u03b5 \\ {\u03c3} a reason for \u03c3. Knowing that \u03c3 may have more than one antecedent, a non-deterministic choice among them is made in Line 6. Exactly this choice is subject to the heuristics studied below. Furthermore, as \u03c3 is the literal of \u03b4 added last toA, \u03b4\\{\u03c3} is also a reason for \u03c3. Since they imply complementary literals, no solution can jointly contain both reasons, viz., \u03b4\\{\u03c3} and \u03b5 \\ {\u03c3}. Hence, combining them in Line 7 gives again a nogood violated wrt A. Finally, note that conflict resolution is guaranteed to terminate at some UIP, but different heuristic choices in Line 6 may result in different UIPs."}, {"heading": "Implication Graphs and Conflict Graphs", "text": "To portray the matter of choosing among several distinct antecedents, we modify the notion of an implication graph (Beame, Kautz, & Sabharwal 2004). At a given state of CDNL, the implication graph contains a node for each literal \u03c3 in assignment A and, for a violated nogood \u03b4 \u2286 A, a node \u03c3 is included, where \u03c3 is the literal of \u03b4 added last toA, that is, \u03b4 \\ A[\u03c3] = {\u03c3}. Furthermore, for each antecedent \u03b4 of an implied literal \u03c3, the implication graph contains directed edges labeled with \u03b4 from all literals in the reason \u03b4 \\ {\u03c3} to \u03c3. Different from (Beame, Kautz, & Sabharwal 2004), where implication graphs reflect exactly one reason per implied literal, our implication graph thus includes all of them. If the implication graph contains both \u03c3 and \u03c3, we call them conflicting literals. Note that an implication graph contains at most one such pair {\u03c3, \u03c3}, called conflicting assignment, because our propagation procedure in Algorithm 2 stops as soon as a nogood becomes violated (cf. Lines 4\u20135).\nAn exemplary implication graph is shown in Figure 1. Each of its nodes (except for one among the two conflicting literals) corresponds to a literal that is true in assignment\nA = ( Fa,Fb,Fp,Tq,Tr,Ts,Fv,Tt,Fu,Fw,Tx ) .\nThe three decision literals in A are underlined, and all other literals are implied. For each literal \u03c3, its decision level dl(\u03c3) is also provided in Figure 1 in parentheses. Every edge is labeled with at least one antecedent of its target, that is, the edges represent the following nogoods:\nn0 = {Fa,Tb} n1 = {Tr,Fs} n2 = {Ts,Ft} n3 = {Ts,Tu} n4 = {Ts,Tw} n5 = {Tr,Tv} n6 = {Tq,Fv,Tw} n7 = {Tt,Fu,Fx} n8 = {Fp,Tt,Fx} n9 = {Fw,Tx} .\nFurthermore, nogood {Ta} is unit-resulting wrt the empty assignment, thus, implied literal Fa (whose decision level is 0) does not have any incoming edge. Observe that the implication graph contains conflicting assignment {Tx,Fx}, where Tx has been implied by nogood n7 and likewise by n8. It is also the last literal inA belonging to violated nogood n9, so that its complement Fx is the second conflicting literal in the implication graph. Besides Tx, literal Fw has multiple antecedents, namely, n4 and n6, which can be read off the labels of the incoming edges of Fw.\nThe conflict resolution done in Algorithm 3, in particular, the heuristic choice of antecedents in Line 6, can now be viewed as an iterative projection of the implication graph. In fact, if an implied literal has incoming edges with distinct labels, all edges with a particular label are taken into account, while the edges with different labels only are dropped. This observation motivates the following definition: a subgraph of an implication graph is a conflict graph if it contains a conflicting assignment and, for each implied literal \u03c3 in the subgraph, the set of predecessors of \u03c3 is a reason for \u03c3. Note that this definition allows us to drop all literals that do not have a path to any conflicting literal, such as Fa and Fb in Figure 1. Furthermore, the requirement that the predecessors of an implied literal form a reason corresponds to the selection of an antecedent, where only the incoming edges with a particular label are traced via conflict resolution.\nThe next definition accounts for a particularity of ASP solving related to unfounded set handling: a conflict graph is level-aware if each conflicting literal \u03c3 has some predecessor \u03c1 such that dl(\u03c1) = dl(\u03c3). In fact, propagation in Algorithm 2 is limited to falsifying unfounded atoms, thus, unit propagation on nogoods in \u039b\u03a0 is performed only partially and may miss implied literals corresponding to external bodies (cf. (Gebser et al. 2007c)). If a conflict graph is not level-aware, the violated nogood \u03b4 provided as input to Algorithm 3 already contains a UIP, thus, \u03b4 itself is returned without performing any conflict resolution inbetween. Given that we are interested in conflict resolution, we below consider level-aware conflict graphs only.\nFinally, we characterize nogoods derived by Algorithm 3 by cuts in conflict graphs (cf. (Zhang et al. 2001; Beame, Kautz, & Sabharwal 2004)). A conflict cut in a conflict graph is a bipartition of the nodes such that all decision literals belong to one side, called reason side, and the conflicting assignment is contained in the other side, called conflict side. The set of nodes on the reason side that have some edge into the conflict side form the conflict nogood associated with a particular conflict cut. For illustration, a First-New-Cut (Beame, Kautz, & Sabharwal 2004) is shown in Figure 2. For the underlying conflict graph, we can choose among the"}, {"heading": "Reason", "text": "incoming edges of Tx whether to include the edges labeled with n7 or the ones labeled with n8. With n7, we get conflict nogood {Tt,Fu,Fw}, while n8 yields {Fp,Tt,Fw}.\nDifferent conflict cuts correspond to different resolution schemes, where we are particularly interested in the FirstUIP scheme. Given a conflict graph and conflicting assignment {\u03c3, \u03c3}, a UIP \u03c3UIP can be identified as a node such that all paths from \u03c3d, the decision literal of decision level dl(\u03c3) = dl(\u03c3), to either \u03c3 or \u03c3 go through \u03c3UIP (cf. (Zhang et al. 2001)). In view of this alternative definition of a UIP, it becomes even more obvious than before that \u03c3d is indeed a UIP, also called the Last-UIP. In contrast, a literal \u03c3UIP is the First-UIP if it is the UIP \u201cclosest\u201d to the conflicting literals, that is, if no other UIP is reachable from \u03c3UIP . The First-UIP-Cut is then given by the conflict cut that has all literals lying on some path from the First-UIP to a conflicting literal, except for the First-UIP itself, on the conflict side and all other literals (including the First-UIP) on the reason side. The First-UIP-Nogood, that is, the conflict nogood associated with the First-UIP-Cut, is exactly the nogood derived by conflict resolution in Algorithm 3 when antecedents that contribute edges to the conflict graph are selected for conflict resolution. Also note that the First-UIP-Cut for a conflict graph is unique, thus, by projecting an implication graph to a conflict graph, we implicitly fix the First-UIP-Nogood. With this is mind, the next section deals with heuristics for extracting conflict graphs from implication graphs."}, {"heading": "Heuristics", "text": "In this section, we propose several heuristics for conflict resolution striving for different goals."}, {"heading": "Recording Short Nogoods", "text": "Under the assumption that short nogoods prune larger portions of the search space than longer ones, a First-UIPNogood looks the more attractive the less literals it contains. In addition, unit propagation on shorter nogoods is usually faster and might even be enabled to use particularly optimized data structures, for instance, specialized to binary or ternary nogoods (Ryan 2004). As noticed in (Mahajan, Fu,"}, {"heading": "Reason", "text": "& Malik 2005), a conflict nogood stays short when the resolvents are short, when the number of resolvents is small, or when the resolvents have many literals in common. In the SAT area, it has been observed that preferring short nogoods in conflict resolution may lead to resolution sequences involving mostly binary and ternary nogoods, so that derived conflict nogoods are not much longer than the originally violated nogoods (Mitchell 2005). Our first heuristics,Hshort , thus selects an antecedent containing the smallest number of literals among the available antecedents of a literal. Given the same implication graph as in Figure 1 and 2, Hshort may yield the conflict graph shown in Figure 3 by preferring antecedent n7 of Tx over n8 and antecedent n4 of Fw over n6 during conflict resolution. The corresponding FirstUIP-Nogood, {Ts}, is indeed short and enables CDNL to after backjumping derive Fs by unit propagation at decision level 0. However, the antecedents n7 and n8 of Tx are of the same size, thus, Hshort may likewise pick n8, in which case the First-UIP-Cut in Figure 4 is obtained. The corresponding First-UIP-Nogood, {Fp,Ts}, is longer. Nonetheless, our experiments below empirically confirm that Hshort tends to reduce the size of First-UIP-Nogoods. But before, we describe further heuristics focusing also on other aspects."}, {"heading": "Performing Long Backjumps", "text": "By backjumping, CDNL may skip the exhaustive exploration of regions of the search space, possibly escaping spare regions not containing any solution. Thus, it seems reasonable to aim at First-UIP-Nogoods such that their literals belong to small decision levels, as they are the determining factor for the lengths of backjumps. Our second heuristics, Hlex , thus uses a lexicographic order to rank antecedents according to the decision levels of their literals. Given an antecedent \u03b4 of a literal \u03c3, we arrange the literals in the reason \u03b4 \\ {\u03c3} for \u03c3 in descending order of their decision levels. The so obtained sequence (\u03c31, . . . , \u03c3m), where \u03b4 \\ {\u03c3} = {\u03c31, . . . , \u03c3m}, induces a descending list levels(\u03b4) = (dl(\u03c31), . . . , dl(\u03c3m)) of decision levels. An antecedent \u03b4 is then considered to be smaller than another antecedent \u03b5, viz., \u03b4 < \u03b5, if the first element that differs in levels(\u03b4) and levels(\u03b5) is smaller in levels(\u03b4) or if levels(\u03b4)"}, {"heading": "Reason", "text": "is a prefix of levels(\u03b5) and shorter than levels(\u03b5). Due to the last condition, Hlex also prefers an antecedent \u03b4 that is shorter than \u03b5, provided that literals of the same decision levels as in \u03b4 are also found in \u03b5. Reconsidering the implication graph in Figure 1 and 2, we obtain levels(n8) = (3, 1) < (3, 3) = levels(n7) for antecedents n7 and n8 of Tx, and we have levels(n4) = (3) < (3, 2) = levels(n6) for antecedents n4 and n6 of Fw. By selecting antecedents that are lexicographically smallest, Hlex leads us to the conflict graph shown in Figure 4. In this example, the corresponding First-UIP-Nogood, {Fp,Ts}, is weaker than {Ts}, which may be obtained with Hshort (cf. Figure 3).\nGiven that lexicographic comparisons are computationally expensive, we also consider a lightweight variant of ranking antecedents according to decision levels. Our third heuristics, Havg , prefers an antecedent \u03b4 over \u03b5 if the average of levels(\u03b4) is smaller than the average of levels(\u03b5). In our example, we get avg [levels(n8)] = avg(3, 1) = 2 < 3 = avg(3, 3) = avg [levels(n7)] and avg [levels(n6)] = avg(3, 2) = 2.5 < 3 = avg(3) = avg [levels(n4)], yielding the conflict graph shown in Figure 5. Unfortunately, the corresponding First-UIP-Nogood, {Fp,Tq,Tr}, does not match the goal of Havg as backjumping only returns to decision level 2, where Tr is then flipped to Fr. Note that this behavior is similar to chronological backtracking, which can be regarded as the most trivial form of backjumping."}, {"heading": "Shortening Conflict Resolution", "text": "Our fourth heuristics,Hres , aims at speeding up conflict resolution itself by shortening resolution sequences. In order to earlier encounter a UIP, Hres prefers antecedents such that the number of literals at the current decision level dl is smallest. In our running example,Hres prefers n8 over n7 as it contains fewer literals whose decision level is 3. However, antecedents n4 and n6 of Fw are indifferent, thus,Hres may yield either one of the conflict graphs in Figure 4 and 5."}, {"heading": "Search Space Pruning", "text": "The heuristics presented above rank antecedents merely by structural properties, thus disregarding their contribution in the past to solving the actual problem. The latter is estimated by nogood deletion heuristics of SAT solvers (Goldberg &"}, {"heading": "Reason", "text": "Novikov 2002; Mahajan, Fu, & Malik 2005), and clasp also maintains activity scores for nogoods (Gebser et al. 2007a). Our fifth heuristics, Hactive , makes use of them and ranks antecedents according to their activities.\nFinally, we investigate a heuristics,Hprop , that stores (and prefers) the smallest decision level at which a nogood has ever been unit-resulting. The intuition underlying Hprop is that the number of implied literals at small decision levels can be viewed as a measure for the progress of CDNL, in particular, as attesting unsatisfiability requires a conflict at decision level 0. Thus, it might be a good idea to prefer nogoods that gave rise to implications at small decision levels."}, {"heading": "Experiments", "text": "For their empirical assessment, we have implemented the heuristics proposed above in a prototypical extension of our ASP solver clasp version 1.0.2. (Even though there are newer versions of clasp, a common testbed, omitting some optimizations, is sufficient for a representative comparison.) Note that clasp (Gebser et al. 2007a) incorporates various advanced Boolean constraint solving techniques, e.g.: \u2022 lookback-based decision heuristics (Goldberg & Novikov\n2002), \u2022 restart and nogood deletion policies (Ee\u0301n & So\u0308rensson\n2003), \u2022 watched literals for unit propagation on \u201clong\u201d nogoods\n(Moskewicz et al. 2001), \u2022 dedicated treatment of binary and ternary nogoods (Ryan\n2004), and \u2022 early conflict detection (Mahajan, Fu, & Malik 2005). Due to this variety, the solving process of clasp is a complex interplay of different features. Thus, it is almost impossible to observe the impact of a certain feature, such as our conflict resolution heuristics, in isolation. However, we below use a considerable number of benchmark classes with different characteristics and shuffled instances, so that noise effects should be compensated at large.\nFor accommodating conflict resolution heuristics considering several antecedents per literal, the low-level implementation of clasp had to be modified. These modifications\nare less optimized than the original implementation, so that our prototype incurs some disadvantages in raw speed that can potentially be reduced by optimizing the implementation. However, for comparison, we include unmodified clasp version 1.0.2, not applying any particular heuristics in conflict resolution. Given that unit propagation in clasp privileges binary and ternary nogoods, they are more likely to be used as antecedents than longer nogoods, as original clasp simply stores the first antecedent it encounters and ignores others. In view of this, unit propagation of original clasp leads conflict resolution into the same direction as Hshort , though in a less exact way. The next table summarizes all clasp variants and conflict resolution heuristics under consideration, denoting the unmodified version simply by clasp:\nLabel Heuristics Goal clasp \u2014 speeding up unit propagation claspshort Hshort recording short nogoods clasplex Hlex performing long backjumps claspavg Havg performing long backjumps claspres Hres shortening conflict resolution claspactive Hactive search space pruning claspprop Hprop search space pruning\nNote that all clasp variants perform early conflict detection, that is, they encounter a unique conflicting assignment before beginning with conflict resolution. Furthermore, all of them perform conflict resolution according to the First-UIP scheme. Thus, we do not explore the first two among the three degrees of freedom mentioned in the introductory section and concentrate fully on the choice of resolvents.\nWe conducted experiments on the benchmarks used in categories SCore and SLparse of the first ASP system competition (Gebser et al. 2007d). Tables 1\u20134 group benchmark instances by their classes, viz., Classes 1\u201311. Via superscripts s and r in the first column, we indicate whether the n instances belonging to a class are structured (e.g., 15-Puzzle) or randomly generated (e.g., BlockedN-Queens). We omit classifying Factoring, which is a worst-case problem where an efficient algorithm would yield a cryptographic attack. Furthermore, Tables 1\u20134 show results for computing one answer set or deciding that an instance has no answer set. For each benchmark instance, we performed five runs on different shuffles, resulting in 5n runs per benchmark class. All experiments were run on a 3.4GHz PC under Linux; each run was limited to 600s time and 1GB RAM. Note that, in Tables 1\u20133, we consider only the instances on which runs were completed by all considered clasp variants.\nTable 1 shows the average lengths of First-UIP-Nogoods for the heuristics aiming at short nogoods, implemented by claspshort and clasplex , among which the latter uses the lengths of antecedents as a tie breaker. For comparison, we also include original clasp. On most benchmark classes, we observe that claspshort as well as clasplex tend to reduce the lengths of First-UIP-Nogoods, up to 14 percent shorter than the ones of clasp on BlockedN-Queens. But there remains only a slight reduction of about 6 percent shorter FirstUIP-Nogoods of clasplex in the summary of all benchmark classes (weighted equally). We also observe that claspshort , more straightly preferring short antecedents than clasplex ,\ndoes not reduce First-UIP-Nogood lengths any further. Interestingly, there is no clear distinction between structured and randomly generated instances, neither regarding magnitudes nor reduction rates of First-UIP-Nogood lengths.\nTable 2 shows the average backjump lengths in terms of decision levels for the clasp variants aiming at long backjumps, viz., claspavg and clasplex . We note that average backjump lengths of more than 2 decision levels indicate structured instances, except for BoundedSpanningTree. Regarding the increase of backjump lengths, claspavg does not exhibit significant improvements, and the polarity of differences to original clasp varies. Only the more sophisticated heuristics of clasplex almost consistently leads to increased backjump lengths (except for HamiltonianPath), but the amounts of improvements are rather small.\nTable 3 shows the average numbers of conflict resolution steps for claspres and clasplex , among which the former particularly aims at their reduction. Somewhat surprisingly, claspres in all performs more conflict resolution steps even than original clasp, while clasplex almost consistently exhibits a reduction of conflict resolution steps (except for Su-Doku). This negative result for claspres suggests that trimming conflict resolution regardless of its outcome is not advisable. The quality of recorded nogoods certainly is a key factor for the performance of conflict-driven learning solvers for ASP and SAT, thus, shallow savings in their retrieval are not worth it and might even be counterproductive globally.\nFinally, Table 4 provides average numbers of conflicts and average runtimes in seconds for all clasp variants. For each benchmark class, the first line provides the average numbers of conflicts encountered on instances where runs were completed by all clasp variants, while the second line gives the average times of completed runs and numbers of timeouts in parentheses. (Recall that all clasp variants were run on 5n shuffles of the n instances per class, leading to more than n timeouts on BlockedN-Queens and, with some clasp variants, also on Solitaire.) At the bottom of Table 4, we summarize average numbers of conflicts and average runtimes over all benchmark classes (weighted equally). Note that the last but one line provides the sums of timeouts in parentheses, while the last line penalizes timeouts with max-\nimum time, viz., 600 seconds. As mentioned above, original clasp is highly optimized and does not suffer from the overhead incurred by the extended infrastructure for applying heuristics in conflict resolution. As a consequence, we observe that original clasp outperforms its variants on most benchmark classes as regards runtime. Among the variants of clasp, claspavg in all exhibits the best average number of conflicts and runtime. However, it also times out most often and behaves unstable, as the poor performance on Classes 2 and 11 shows. In contrast, claspshort and clasplex lead to fewest timeouts (in fact, as many timeouts as clasp), and clasplex encounters fewer conflicts than claspshort . Variant claspactive , preferring \u201ccritical\u201d antecedents, exhibits a comparable performance, while claspres and claspprop yield more timeouts and also encounter relatively many conflicts. Overall, we notice that some clasp variants perform reasonably well, but without significantly decreasing the number of conflicts in comparison to original clasp. As there is no clear winner among our clasp variants, unfortunately, they do not suggest any \u201cuniversal\u201d conflict resolution heuristics."}, {"heading": "Discussion", "text": "We have proposed a number of heuristics for conflict resolution and conducted a systematic empirical study in the context of our ASP solver clasp. However, it is too early to conclude any dominant approach or to make general recommendations. As has also been noted in (Mitchell 2005), conflict resolution strategies are almost certainly important but have received little attention in the literature so far. In fact, dedicated approaches in the SAT area (Ryan 2004; Mahajan, Fu,\n& Malik 2005) merely aim at reducing the size of recorded nogoods. Though this might work reasonably well in practice, it is unsatisfactory when compared to sophisticated decision heuristics (Goldberg & Novikov 2002; Ryan 2004; Mahajan, Fu, & Malik 2005; Dershowitz, Hanna, & Nadel 2005) resulting from more profound considerations. We thus believe that heuristics in conflict resolution deserve further attention. Future lines of research may include developing more sophisticated scoring mechanisms than the ones proposed here, combining several scoring criterions, or even determining and possibly recording multiple reasons for a conflict (corresponding to different conflict graphs). Any future improvements in these directions may significantly boost the state-of-the-art in both ASP and SAT solving."}], "references": [{"title": "Knowledge Representation, Reasoning and Declarative Problem Solving", "author": ["C. Baral"], "venue": "Cambridge University Press.", "citeRegEx": "Baral,? 2003", "shortCiteRegEx": "Baral", "year": 2003}, {"title": "Using CSP look-back techniques to solve real-world SAT instances", "author": ["R. Bayardo", "R. Schrag"], "venue": "Proceedings of the Fourteenth National Conference on Artificial Intelligence (AAAI\u201997), 203\u2013208. AAAI Press/MIT Press.", "citeRegEx": "Bayardo and Schrag,? 1997", "shortCiteRegEx": "Bayardo and Schrag", "year": 1997}, {"title": "Towards understanding and harnessing the potential of clause learning", "author": ["P. Beame", "H. Kautz", "A. Sabharwal"], "venue": "Journal of Artificial Intelligence Research 22:319\u2013351.", "citeRegEx": "Beame et al\\.,? 2004", "shortCiteRegEx": "Beame et al\\.", "year": 2004}, {"title": "Negation as failure", "author": ["K. Clark"], "venue": "Gallaire, H., and Minker, J., eds., Logic and Data Bases, 293\u2013322. Plenum Press.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "Constraint Processing", "author": ["R. Dechter"], "venue": "Morgan Kaufmann Publishers.", "citeRegEx": "Dechter,? 2003", "shortCiteRegEx": "Dechter", "year": 2003}, {"title": "A clausebased heuristic for SAT solvers", "author": ["N. Dershowitz", "Z. Hanna", "A. Nadel"], "venue": "Bacchus, F., and Walsh, T., eds., Proceedings of the Eigth International Conference on Theory and Applications of Satisfiability Testing (SAT\u201905), 46\u201360. Springer-Verlag.", "citeRegEx": "Dershowitz et al\\.,? 2005", "shortCiteRegEx": "Dershowitz et al\\.", "year": 2005}, {"title": "An extensible SATsolver", "author": ["N. E\u00e9n", "N. S\u00f6rensson"], "venue": "Proceedings of the Sixth International Conference on Theory and Applications of Satisfiability Testing (SAT\u201903), 502\u2013518.", "citeRegEx": "E\u00e9n and S\u00f6rensson,? 2003", "shortCiteRegEx": "E\u00e9n and S\u00f6rensson", "year": 2003}, {"title": "Tight logic programs", "author": ["E. Erdem", "V. Lifschitz"], "venue": "Theory and Practice of Logic Programming 3(4-5):499\u2013 518.", "citeRegEx": "Erdem and Lifschitz,? 2003", "shortCiteRegEx": "Erdem and Lifschitz", "year": 2003}, {"title": "Consistency of Clark\u2019s completion and the existence of stable models", "author": ["F. Fages"], "venue": "Journal of Methods of Logic in Computer Science 1:51\u201360.", "citeRegEx": "Fages,? 1994", "shortCiteRegEx": "Fages", "year": 1994}, {"title": "clasp: A conflict-driven answer set solver", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "Baral et al. (2007), 260\u2013265.", "citeRegEx": "Gebser et al\\.,? 2007a", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "Conflict-driven answer set enumeration", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "Baral et al. (2007), 136\u2013148.", "citeRegEx": "Gebser et al\\.,? 2007b", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "Conflict-driven answer set solving", "author": ["M. Gebser", "B. Kaufmann", "A. Neumann", "T. Schaub"], "venue": "Veloso, M., ed., Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI\u201907), 386\u2013392. AAAI Press/MIT Press.", "citeRegEx": "Gebser et al\\.,? 2007c", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "The first answer set programming system competition", "author": ["M. Gebser", "L. Liu", "G. Namasivayam", "A. Neumann", "T. Schaub", "M. Truszczy\u0144ski"], "venue": "Baral et al. (2007), 3\u201317.", "citeRegEx": "Gebser et al\\.,? 2007d", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "Journal of Automated Reasoning 36(4):345\u2013377.", "citeRegEx": "Giunchiglia et al\\.,? 2006", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2006}, {"title": "BerkMin: A fast and robust SAT solver", "author": ["E. Goldberg", "Y. Novikov"], "venue": "Proceedings of the Fifth Conference on Design, Automation and Test in Europe (DATE\u201902), 142\u2013 149. IEEE Press.", "citeRegEx": "Goldberg and Novikov,? 2002", "shortCiteRegEx": "Goldberg and Novikov", "year": 2002}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["J. Lee"], "venue": "Kaelbling, L., and Saffiotti, A., eds., Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI\u201905), 503\u2013508. Professional Book Center.", "citeRegEx": "Lee,? 2005", "shortCiteRegEx": "Lee", "year": 2005}, {"title": "Why are there so many loop formulas", "author": ["V. Lifschitz", "A. Razborov"], "venue": "ACM Transactions on Computational Logic 7(2):261\u2013268", "citeRegEx": "Lifschitz and Razborov,? \\Q2006\\E", "shortCiteRegEx": "Lifschitz and Razborov", "year": 2006}, {"title": "ASSAT: computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157(1-2):115\u2013137.", "citeRegEx": "Lin and Zhao,? 2004", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "Zchaff2004: An efficient SAT solver", "author": ["Y. Mahajan", "Z. Fu", "S. Malik"], "venue": "Hoos, H., and Mitchell, D., eds., Proceedings of the Seventh International Conference on Theory and Applications of Satisfiability Testing (SAT\u201904), 360\u2013 375. Springer-Verlag.", "citeRegEx": "Mahajan et al\\.,? 2005", "shortCiteRegEx": "Mahajan et al\\.", "year": 2005}, {"title": "GRASP: A search algorithm for propositional satisfiability", "author": ["J. Marques-Silva", "K. Sakallah"], "venue": "IEEE Transactions on Computers 48(5):506\u2013521.", "citeRegEx": "Marques.Silva and Sakallah,? 1999", "shortCiteRegEx": "Marques.Silva and Sakallah", "year": 1999}, {"title": "A SAT solver primer", "author": ["D. Mitchell"], "venue": "Bulletin of the European Association for Theoretical Computer Science 85:112\u2013133.", "citeRegEx": "Mitchell,? 2005", "shortCiteRegEx": "Mitchell", "year": 2005}, {"title": "Chaff: Engineering an efficient SAT solver", "author": ["M. Moskewicz", "C. Madigan", "Y. Zhao", "L. Zhang", "S. Malik"], "venue": "Proceedings of the Thirty-eighth Conference on Design Automation (DAC\u201901), 530\u2013535. ACM Press.", "citeRegEx": "Moskewicz et al\\.,? 2001", "shortCiteRegEx": "Moskewicz et al\\.", "year": 2001}, {"title": "Efficient algorithms for clause-learning SAT solvers", "author": ["L. Ryan"], "venue": "Master\u2019s thesis, Simon Fraser University.", "citeRegEx": "Ryan,? 2004", "shortCiteRegEx": "Ryan", "year": 2004}, {"title": "The wellfounded semantics for general logic programs", "author": ["A. Van Gelder", "K. Ross", "J. Schlipf"], "venue": "Journal of the ACM 38(3):620\u2013650.", "citeRegEx": "Gelder et al\\.,? 1991", "shortCiteRegEx": "Gelder et al\\.", "year": 1991}, {"title": "Answer set programming with clause learning", "author": ["J. Ward", "J. Schlipf"], "venue": "Lifschitz, V., and Niemel\u00e4, I., eds., Proceedings of the Seventh International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR\u201904), 302\u2013313. Springer-Verlag.", "citeRegEx": "Ward and Schlipf,? 2004", "shortCiteRegEx": "Ward and Schlipf", "year": 2004}, {"title": "Efficient conflict driven learning in a Boolean satisfiability solver", "author": ["L. Zhang", "C. Madigan", "M. Moskewicz", "S. Malik"], "venue": "Proceedings of the International Conference on Computer-Aided Design (ICCAD\u201901), 279\u2013285.", "citeRegEx": "Zhang et al\\.,? 2001", "shortCiteRegEx": "Zhang et al\\.", "year": 2001}], "referenceMentions": [{"referenceID": 0, "context": "The popularity of Answer Set Programming (ASP; (Baral 2003)) as a paradigm for knowledge representation and reasoning is mainly due to two factors: first, its rich modeling language and, second, the availability of highperformance ASP systems.", "startOffset": 47, "endOffset": 59}, {"referenceID": 9, "context": "In fact, modern ASP solvers, such as clasp (Gebser et al. 2007a), cmodels (Giunchiglia, Lierler, & Maratea 2006), and smodelscc (Ward & Schlipf 2004), have meanwhile closed the gap to Boolean Satisfiability (SAT; (Mitchell 2005)) solvers.", "startOffset": 43, "endOffset": 64}, {"referenceID": 20, "context": "2007a), cmodels (Giunchiglia, Lierler, & Maratea 2006), and smodelscc (Ward & Schlipf 2004), have meanwhile closed the gap to Boolean Satisfiability (SAT; (Mitchell 2005)) solvers.", "startOffset": 155, "endOffset": 170}, {"referenceID": 21, "context": "In both fields, conflict-driven learning and related techniques have led to significant performance boosts (Bayardo & Schrag 1997; Marques-Silva & Sakallah 1999; Moskewicz et al. 2001; Gebser et al. 2007d).", "startOffset": 107, "endOffset": 205}, {"referenceID": 12, "context": "In both fields, conflict-driven learning and related techniques have led to significant performance boosts (Bayardo & Schrag 1997; Marques-Silva & Sakallah 1999; Moskewicz et al. 2001; Gebser et al. 2007d).", "startOffset": 107, "endOffset": 205}, {"referenceID": 21, "context": "For instance, the basic search strategy of SAT solver chaff (Moskewicz et al. 2001), nowadays a quasi standard in SAT solving, is also exploited by ASP solver clasp, in particular, the principles of conflict analysis are similar.", "startOffset": 60, "endOffset": 83}, {"referenceID": 10, "context": "Vice versa, the solution enumeration approach implemented in clasp (Gebser et al. 2007b) could also be applied by SAT solvers.", "startOffset": 67, "endOffset": 88}, {"referenceID": 25, "context": "Furthermore, distinct schemes may be used for conflict analysis, such as the resolutionbased First-UIP and Last-UIP scheme (Zhang et al. 2001).", "startOffset": 123, "endOffset": 142}, {"referenceID": 25, "context": "In the SAT area, the First-UIP scheme (Marques-Silva & Sakallah 1999) has empirically been shown to yield better performance than other known conflict resolution strategies (Zhang et al. 2001).", "startOffset": 173, "endOffset": 192}, {"referenceID": 0, "context": "We assume basic familiarity with answer set semantics (see, for instance, (Baral 2003)).", "startOffset": 74, "endOffset": 86}, {"referenceID": 11, "context": "This section briefly introduces notations and recalls a constraint-based characterization of answer set semantics according to (Gebser et al. 2007c).", "startOffset": 127, "endOffset": 148}, {"referenceID": 4, "context": "In our context, a nogood (Dechter 2003) is a set {\u03c31, .", "startOffset": 25, "endOffset": 39}, {"referenceID": 3, "context": "We start by describing nogoods capturing the models of the Clark\u2019s completion (Clark 1978) of a program \u03a0.", "startOffset": 78, "endOffset": 90}, {"referenceID": 8, "context": "If \u03a0 is tight (Fages 1994; Erdem & Lifschitz 2003), these models are guaranteed to match the answer sets of \u03a0.", "startOffset": 14, "endOffset": 50}, {"referenceID": 11, "context": "Theorem 1 ((Gebser et al. 2007c)) Let \u03a0 be a tight logic program.", "startOffset": 11, "endOffset": 32}, {"referenceID": 15, "context": "Observe that EB\u03a0(U) contains the bodies of all rules in \u03a0 that can externally support (Lee 2005) an atom in U .", "startOffset": 86, "endOffset": 96}, {"referenceID": 11, "context": "Theorem 2 ((Gebser et al. 2007c)) Let \u03a0 be a logic program.", "startOffset": 11, "endOffset": 32}, {"referenceID": 11, "context": "This section recalls the basic decision procedure of clasp (Gebser et al. 2007c), abstracting Conflict-Driven Clause Learning (CDCL; (Mitchell 2005)) for SAT solving from clauses, that is, Conflict-Driven Nogood Learning (CDNL).", "startOffset": 59, "endOffset": 80}, {"referenceID": 20, "context": "2007c), abstracting Conflict-Driven Clause Learning (CDCL; (Mitchell 2005)) for SAT solving from clauses, that is, Conflict-Driven Nogood Learning (CDNL).", "startOffset": 59, "endOffset": 74}, {"referenceID": 20, "context": "(Mitchell 2005)) on \u2206\u03a0\u222a\u2207.", "startOffset": 0, "endOffset": 15}, {"referenceID": 25, "context": "Among a number of conflict resolution schemes, the First-UIP scheme, stopping conflict resolution as soon as the first UIP is reached, has turned out to be the most efficient and most robust strategy (Zhang et al. 2001).", "startOffset": 200, "endOffset": 219}, {"referenceID": 11, "context": "(Gebser et al. 2007c)).", "startOffset": 0, "endOffset": 21}, {"referenceID": 25, "context": "(Zhang et al. 2001; Beame, Kautz, & Sabharwal 2004)).", "startOffset": 0, "endOffset": 51}, {"referenceID": 25, "context": "(Zhang et al. 2001)).", "startOffset": 0, "endOffset": 19}, {"referenceID": 22, "context": "In addition, unit propagation on shorter nogoods is usually faster and might even be enabled to use particularly optimized data structures, for instance, specialized to binary or ternary nogoods (Ryan 2004).", "startOffset": 195, "endOffset": 206}, {"referenceID": 20, "context": "In the SAT area, it has been observed that preferring short nogoods in conflict resolution may lead to resolution sequences involving mostly binary and ternary nogoods, so that derived conflict nogoods are not much longer than the originally violated nogoods (Mitchell 2005).", "startOffset": 259, "endOffset": 274}, {"referenceID": 9, "context": "Novikov 2002; Mahajan, Fu, & Malik 2005), and clasp also maintains activity scores for nogoods (Gebser et al. 2007a).", "startOffset": 95, "endOffset": 116}, {"referenceID": 9, "context": ") Note that clasp (Gebser et al. 2007a) incorporates various advanced Boolean constraint solving techniques, e.", "startOffset": 18, "endOffset": 39}, {"referenceID": 21, "context": "\u2022 watched literals for unit propagation on \u201clong\u201d nogoods (Moskewicz et al. 2001),", "startOffset": 58, "endOffset": 81}, {"referenceID": 22, "context": "\u2022 dedicated treatment of binary and ternary nogoods (Ryan 2004), and", "startOffset": 52, "endOffset": 63}, {"referenceID": 12, "context": "We conducted experiments on the benchmarks used in categories SCore and SLparse of the first ASP system competition (Gebser et al. 2007d).", "startOffset": 116, "endOffset": 137}, {"referenceID": 20, "context": "As has also been noted in (Mitchell 2005), conflict resolution strategies are almost certainly important but have received little attention in the literature so far.", "startOffset": 26, "endOffset": 41}, {"referenceID": 22, "context": "Though this might work reasonably well in practice, it is unsatisfactory when compared to sophisticated decision heuristics (Goldberg & Novikov 2002; Ryan 2004; Mahajan, Fu, & Malik 2005; Dershowitz, Hanna, & Nadel 2005) resulting from more profound considerations.", "startOffset": 124, "endOffset": 220}], "year": 2010, "abstractText": "Modern solvers for Boolean Satisfiability (SAT) and Answer Set Programming (ASP) are based on sophisticated Boolean constraint solving techniques. In both areas, conflict-driven learning and related techniques constitute key features whose application is enabled by conflict analysis. Although various conflict analysis schemes have been proposed, implemented, and studied both theoretically and practically in the SAT area, the heuristic aspects involved in conflict analysis have not yet received much attention. Assuming a fixed conflict analysis scheme, we address the open question of how to identify \u201cgood\u201d reasons for conflicts, and we investigate several heuristics for conflict analysis in ASP solving. To our knowledge, a systematic study like ours has not yet been performed in the SAT area, thus, it might be beneficial for both the field of ASP as well as the one of SAT solving.", "creator": "TeX"}}}