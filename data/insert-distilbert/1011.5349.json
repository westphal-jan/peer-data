{"id": "1011.5349", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Nov-2010", "title": "Distributed Graph Coloring: An Approach Based on the Calling Behavior of Japanese Tree Frogs", "abstract": "graph coloring, also known as graph vertex coloring, significantly considers the problem of assigning colors to the nodes of a graph block such requiring that adjacent nodes don't share the same color. the optimization version of the problem substantially concerns the minimization of the number of used colors. in this paper we here deal with the straightforward problem of finding valid colorings of embedded graphs in effectively a distributed way, that is, by means independent of an algorithm that only uses local information for deciding the color of the generated nodes. such algorithms prescind from any central control. due to yet the fact that quite a few practical applications require to find colorings in a typically distributed way, the interest in distributed layout algorithms for graph coloring calculations has been growing during the last decade. as an example consider wireless ad - hoc and virtual sensor networks, where tasks actions such as the assignment of frequencies or the assignment of tdma slots are strongly related to graph coloring.", "histories": [["v1", "Wed, 24 Nov 2010 11:47:59 GMT  (36kb)", "http://arxiv.org/abs/1011.5349v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["hugo hern\\'andez", "christian blum"], "accepted": false, "id": "1011.5349"}, "pdf": {"name": "1011.5349.pdf", "metadata": {"source": "CRF", "title": "Distributed Graph Coloring: An Approach Based on the Calling Behavior of Japanese Tree Frogs", "authors": [], "emails": ["hhernandez@lsi.upc.edu", "cblum@lsi.upc.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n01 1.\n53 49\nv1 [\ncs .A\nI] 2\nThe algorithm proposed in this paper is inspired by the calling behavior of Japanese tree frogs. Male frogs use their calls to attract females. Interestingly, groups of males that are located nearby each other desynchronize their calls. This is because female frogs are only able to correctly localize the male frogs when their calls are not too close in time. We experimentally show that our algorithm is very competitive with the current state of the art, using different sets of problem instances and comparing to one of the most competitive algorithms from the literature."}, {"heading": "1 Introduction", "text": "Given an undirected graph G = (V,E), where V is the node set and E is the edge set, and a number k > 0 of colors, a valid k-coloring of the graph is the assignment of exactly one color to each node such that adjacent nodes (that is, nodes that are connected by an edge) do not share the same color. Formally, we say that a k-coloring of an undirected graph G = (V,E) is a function c : V \u2192 {1, 2, . . . , k} such that c(u) 6= c(v) for each edge (u, v) \u2208 E. The optimization version of the graph coloring problem (GCP), which is NP -hard [22], consists in finding the minimum number k\u2217 of colors such that a valid k\u2217-coloring can be found. This number is called the chromatic number of graph G and is denoted by \u03c7(G). The GCP is a quite generic problem. Practical applications originate especially from problems that can be modelled by networks and graphs, for example, communication networks. Several tasks in modern wireless ad-hoc networks, such as sensor networks, are related to graph coloring. Examples include TDMA slot assignment [20], detection of mobile objects and reduction of\nsignaling actuators [38], distributed MAC layer management [18], energy-efficient coverage [9], delay efficient sleep scheduling [30] or wakeup scheduling [24]. Due to the distributed nature of these networks, algorithms for solving problems related to graph coloring are generally also required to be distributed [32]. Such algorithms make an exclusive use of local information for deciding the color of the nodes, that is, they are characterized by the absence of any central control mechanism. The goal of this paper is to device an algorithm for generating valid colorings in a distributed manner.\nThe distributed conception of an algorithm is generally beneficial for its scalability. Moreover, in comparison to centralized approaches it is generally much easier to adapt a distributed algorithm to dynamic changes during execution. Unfortunately, the exclusive use of local information is often not sufficient to completely capture the internal structure of certain graphs or networks. The following example helps to understand the tradeoff between generating colorings from a local and a global perspective. Figure 1 shows a graph which has been constructed using four different triangles, that is, complete graphs of three nodes. Hereby, we distinguish between three inner triangles (the three groups of nodes that are close together) and one outer triangle. The three inner triangles are connected to the outer triangle such that each node of a specific inner triangle is connected to a different node of the outer triangle. Even in a distributed manner it is fairly easy to obtain optimal colorings for each of the inner triangles. Depending on the specific color assignment concerning the three inner triangles the outer triangle may be colored with the same three colors (as in Figure 1(a)) or with three additional colors (as in Figure 1(b)). Unfortunately, probability for the latter case is quite high, especially when the complexity of the graph is increased by adding more inner triangles. As mentioned already above, one of the key difficulties when coloring graphs in a distributed manner is that each node is only provided with local information and, therefore, it is unable to detect situations such as the one from Figure 1(b)."}, {"heading": "1.1 Our Contribution", "text": "In this paper we propose a distributed algorithm for graph coloring based on the calling behavior exhibited by male Japanese tree frogs for the attraction of females. Several researchers have observed that male Japanese tree frogs decouple their calls [37]. This property has evolved because females can only localize the males when their calling is not too close in time. In [1] Aihara et al. proposed a theoretical model for simulating the behavior of these frogs. The authors describe an oscillator system, where each oscillator has a phase \u03b8 \u2208 [0, 2\u03c0] that changes over time with frequency \u03c9 (where 2\u03c0 is the time interval between two calls of the same frog). When the phase reaches 2\u03c0, the oscillator fires and returns to the baseline phase (\u03b8 = 0). The proposed system works such that oscillators try to maximize the distance between their phases. This model works nicely for the desynchronization of two oscillators. However, when more than two oscillators are concerned, the model does not accurately reflect the real behavior of the frogs. A subsequent work [2] mentions some potential applications of this model in artificial life and robotics. In both works the author(s) mention the limitations of the systems when operating with groups of more than two coupled oscillators. In fact, already with three oscillators the final solution (and its stability) strongly depends on the initial variable settings.\nThe desynchronization of the frogs\u2019 calls is achieved in a self-organized way. Therefore, the algorithm proposed in this paper, which is based on this self-desynchronization mechanism, can be regarded as a swarm intelligence approach [7, 5]. Swarm intelligence is a field of computer science which is inspired by the collective behavior of social animals and other selforganizing processes from nature. Successful examples from the literature include particle swarm optimization (PSO) [23], which is an algorithm for optimization inspired by bird flocking and fish schooling, and ant colony optimization (ACO) [11], which is inspired by the foraging behavior of ant colonies. One of the distinguishing properties of a swarm intelligence approach is the fact that the problem at hand is solved from a local perspective. Moreover, problem solving is based on the cooperation of rather simple entities. Instead of each entity trying to solve the problem by itself, they perform simple tasks from a local perspective. The global problem is solved as a result of cooperation. Therefore, swarm intelligence principles are well suited for their use in distributed algorithms.\nThe proposed algorithm uses a desynchronization method based on the original model by Aihara et al. [1], with some small modifications. The algorithm can be easily implemented, for example, in sensor networks. In addition to competitive results it comes with several advantages as, for example, a low consumption of energy resources or its potential ability to adapt to changes in the network topology. However, as mentioned before, the main goal of the algorithm is to obtain valid colorings that use an as-low-as-possible number of colors, while keeping the number of iterations necessary to reach these results as low as possible. An extensive experimental evaluation shows that the results of the algorithm are comparable or better than the ones of state-of-the-art algorithms for what concerns the number colors. In particular, the good performance of our algorithm for grid graphs of any size is remarkable. On the downside, the results also show that our algorithm may require a slightly higher number of communication rounds than other state-of-the-art algorithms."}, {"heading": "1.2 Prior Work on Graph Coloring", "text": "Concerning prior work, a distinction must be made between centralized and distributed algorithms. Concerning centralized algorithms, the literature offers both exact approaches that guarantee to find an optimal solution in bounded time and (meta-)heuristic approaches. A recent survey can be found in [33]. Due to the intractable nature of the GCP, larger problem instances can only be tackled efficiently by heuristic approaches. Especially effective are the tabu search algorithm from [4], a hybrid approach combining tabu search and evolutionary algorithms from [31] and a variable neighborhood search technique [21]. These algorithms are nowadays the best centralized metaheuristics for solving the GCP.\nWhen considering distributed algorithms, it is very difficult (if not impossible) to narrow down the state of the art to a small set of algorithms. This is because distributed algorithms may be designed with very different goals. These goals may concern, for example, the performance for particular topologies, the minimization of execution time (or communication rounds), the generation of the best colorings possible, or the performance for dynamically changing topologies. In addition, a general problem is that most proposals are not evaluated on publicly available sets of benchmark instances. Moreover, results are generally not shown per instance, making it difficult to compare to the proposed algorithms. In the following we only focus on algorithms that generate valid solutions and possibly refer to their simplicity, solution quality and time complexity.1 It must also be noted that many of the proposed distributed algorithms were developed for applications in networks of devices with scarce resources. For this reason authors often study the message load the algorithm implies and try to minimize the amount of calculus required by the algorithm. Typically, these algorithms are meant to work on a lower layer of the network in parallel with the applications or information flows that the user may require to send. In [15], Fraigniaud et al. study the effect of the amount of information shared between the nodes on the quality of the obtained colorings.\nOne of the most general works was presented by Finocchi et al. in [13]. The authors introduced three versions of a distributed algorithm and study its behavior under various conditions. The authors considered both the problem of obtaining O(\u2206 + 1)-colorings in as few communication rounds as possible, as well as the problem of generating the best possible colorings without any limit on the number of communication rounds. The authors provide extensive experimental results for both cases. Most of their experimentation is based on random graphs, which are not publicly available. However, they also offer results on a wellknown set of publicly available instances from the DIMACS challenge [14]. As the algorithm proposed in [13] was shown to outperform the state of the art, we have chosen this algorithm for comparison.\nConcerning distributed algorithms based on swarm intelligence principles, the literature offers, for example, a method inspired by the synchronous flashing of fireflies (see [27]). This algorithm, which allows a simple implementation, reaches valid colorings fast, in a constant number of communication rounds, regardless of the size of the network. However, this work does not focus on minimizing the number of colors. The first intent to use the calling behavior of frogs for graph coloring was presented in [29]. Valid colorings are obtained by assigning a color to each phase used by the nodes (that is, the oscillators). Therefore, if two nodes are synchronized to exactly the same phase, they will be sharing a common color (the authors consider a function f : [0, 2\u03c0] \u2192 (R,G,B), where 2\u03c0 is the time frame between two callings\n1In the scope of this paper the time complexity is, as usual, measured in terms of communication rounds. A communication round is the unit of time in which each node is allowed to send at most one message.\nof the same frog). The main drawback of this approach is that nodes with very near phases will be colored with different colors. As such small deviations usually occur when the number of nodes in the system increases, the algorithm does not obtain competitive results. This work was further extended by adding a parameter for setting a priori the number of allowed phases [28]. Experimentation shows that the system is able to find optimal solutions for small topologies, provided the optimal number of colors is known. Note that in contrast to these works, the algorithm that we propose aims for the minimization of the used number of colors without any prior knowledge about the optimal solution.\nThe literature also offers many works that consider distributed graph coloring from a theoretical point of view. Most of them concern upper bounds for the coloring quality as well as the time complexity under different constraints. Hansen et al. [19] proposed the distributed largest-first (DLF) algorithm that runs in O(\u22062logn) communication rounds for arbitrary graphs and that was proven to provide good upper bounds for specific topologies. This algorithm was based on the largest-first approach which consists in giving priority for choosing a color to the nodes with the highest degree (\u2206). This work was further extended by Kosowski and Kuszner [25] who reduced the time complexity to O(\u2206lognlog\u2206). These authors also proved that some other approaches, like smallest-last or dynamic-saturation, are not suitable for distributed environments. Later, in [34] Moscibroda and Wattenho\u0308fer introduced an algorithm for obtaining O(\u2206)-colorings in O(\u03b4logn) time when considering random geometric graphs and other well-known models for wireless multi-hop networks (no results are given for other topologies). Other theoretical works which may be of interest for the development of new algorithms are the game theoretic approach for efficient graph coloring from Panagopoulou and Spirakis [36] and the work by Kuhn and Wattenho\u0308fer [26], which introduces a new lower bound on the number of colors used by algorithms that are restricted to one single communication round and a new lower bound on the time complexity of obtaining a O(\u2206)-coloring of a graph."}, {"heading": "1.3 Organization of the Paper", "text": "The rest of this paper is organized as follows. Section 2 describes the behavior of frogs in nature, which has inspired our algorithm. Moreover, existing models are outlined. In Section 3 the algorithm is introduced. An extensive experimental evaluation of the proposed algorithm is presented in Section 4. Finally, Section 5 is dedicated to conclusions and the outline of future work."}, {"heading": "2 Modelling the Calling Behavior of Japanese Tree Frogs", "text": "Different studies (see, for example, [37]) have shown that male Japanese tree frogs use their calling to attract females. Apparently, females of this family of frogs can recognize the source of the calling in order to determine the current location of the corresponding male. A problem arises when two of these males are too close in space and communicate at the same time. In this case females are not able to properly recognize both calls independently and are, therefore, unable to detect where the calls came from. For this reason, males have evolved to desynchronize their sounds in time. They achieve to uniformly distribute the distance between each pair of calls, which allows the females to locate the males they can hear, and to choose one. In fact, this behavior is a prime example for self-organization in nature.\nMore recently, Aihara et al. [1] introduced a formal model based on a set of coupled oscillators each one simulating the phase change in the calling period of a single frog. As oscillators are associated to frogs, we will use both terms in the following with the same meaning. The basic way of working of this model is graphically illustrated in Figure 2. The circle represents\u2014in all three graphics\u2014the time frame between two calls of the same frog (2\u03c0), the calling period. The nodes marked by integer numbers 1 and 2 indicate the phase of the corresponding frogs, that is, the moment of time in which they call. Note that the oscillators are not able to reach perfect anti-phase in a single step. In general, an indefinite number of steps is needed before reaching the stable situation corresponding to perfect antiphase. Moreover, the difficulty of reaching the optimal configuration tends to increase with an increasing number of frogs and also with an increasing degree of interaction between them (note that two frogs that can not hear each other do not influence each other).\nTechnically, the system introduced by Aihara et al. [1] works as follows. Each oscillator i has a phase \u03b8i \u2208 [0, 2\u03c0] that changes over time with frequency \u03c9i (where 2\u03c0 is the time interval between two calls of the same frog, the calling period). When the phase reaches 2\u03c0, the oscillator fires and returns to the baseline. In addition, oscillators may be coupled with other oscillators. In case an oscillator j is coupled to an oscillator i, when oscillator i fires, oscillator j receives a boost and changes the frequency of firing in the next round depending on the gap \u2206ji \u2208 [0, 2\u03c0] (see below) between both oscillators. These changes do not happen instantly upon receiving the stimulus. The corresponding oscillator rather waits until it fires. The model can be summarized in the following equations. First, the behavior of an isolated oscillator i is modelled as follows:\nd\u03b8i dt = \u03c9i (1)\nAssuming that oscillators j and i are coupled, the gap between their (current) phases is defined as:\n\u2206ji = \u03b8j \u2212 \u03b8i (2)\nNow, the change in the behavior of oscillator j as influenced by oscillator i can be described as follows:\nd\u03b8j dt = \u03c9j + g(\u2206ji) , (3)\nwhere g(\u00b7) is the phase shift function which is responsible for changing the phase of the frogs that are influenced by other frogs. In [1], the authors suggest the use of the following phase shift function:\ng(x) = \u03b1 sin(x) (4)\nWe say that this system of oscillators is in a stable situation and in anti-phase when the following two conditions are satisfied:\n\u2206ij = \u2206ji , (5)\ng(\u2206ij) = 0 , (6)\nfor all i 6= j. The system presented in [1] is able to successfully locate two coupled oscillators in perfect anti-phase, independent of the initial settings of \u03b81 and \u03b82. Unfortunately, several problems arise when the number of oscillators grows. Figure 3 shows two examples for such problems. Given an undirected graph G = (V,E), henceforth we will assign one oscillator to each node in the graph. Therefore, in the following the terms node and oscillator will refer to the same. We consider that two oscillators are coupled if and only if their corresponding nodes are connected by an edge. Depending on the initial phases of the oscillators, for both topologies shown in Figures 3(a) and 3(d) it is possible to reach suboptimal desynchronizations (as shown in Figures 3(b) and 3(e)). The corresponding optimal desynchronizations are shown in Figures 3(c) and 3(f). In [1] the authors provide analytical results for using three oscillators and show that there is a high system sensitivity with respect to the initial phases (only a small subset of the possible initial settings leads to an optimal solution).\nThe initial model by Aihara et al. [1] was later extended by Mutazono et al. [35]. They used their extended model for anti-phase synchronization for the purpose of collision-free transmission scheduling in sensor networks. In order to make the system applicable to larger topologies (sensor networks may consists of hundreds of nodes), they introduced weights in order to regulate the coupling between each pair of oscillators. The resulting phase shift function as introduced in [35] can be described as follows:\n\u03b4(x) = min{x, 2\u03c0 \u2212 x} , (7) g(x) = \u03b1sin(x) \u00b7 e\u2212\u03b4(x) (8)\nThanks to these weights, the system reaches stable situations more easily, especially when rather small values of \u03b1 are used. The authors experimented with topologies of up to 20 nodes and although the system still showed certain difficulties to reach stable solutions, the sensitivity to initial conditions decreased significantly.\nMutazono et al. [35] compared the results of their system to another mechanism for coupled oscillator desynchronization proposed in [10]. Note that the mechanism from [10] is not based\non the calling behavior of Japanese tree frogs. The main difference to frog-inspired systems is the fact that the phase change of a node is made on the basis of only two other nodes. The phase values allow to order all the nodes sequentially from small to large phase values. The nodes whose phase values are used to change the phase value of a node are determined as the predecessor and the successor in this (cyclic) sequence. As shown in [35], both systems achieve similar results although no extensive experimentation is made on a broad-enough set of network topologies: mostly random geometric graphs and hand-made instances with at most eight nodes were used.\nAnother extension of the system by Aihara et al. [1] was introduced in [29]. The changes concern the use of different weights for the phase shift function and the introduction of a so-called frustration parameter which reduces the coupling between each pair of nodes. The authors show that their system is able to obtain better solutions than the original model for many different topologies as, for example, k-partite graphs, grids or platonic solids. Moreover, the authors make some interesting observations: (1) the number of oscillators is not the key factor for achieving desynchronization. It is rather the topology which most determines the problem complexity. (2) the time distance between phases is not uniformly distributed around the whole period. The number of nodes firing at each phase strongly affects the amount of time between the phases.\nAlgorithm 1 Sensor event of node i\n1: if less than K communication rounds executed then 2: \u03b8i := recalculateTheta() 3: ci := minimumColorNotUsed() 4: sendColoringMessage() 5: \u03b1i := \u03b1i/\u03c1 6: else 7: if first communication round of Phase II then 8: if (ci = 1) then pi := randomPositiveInteger() 9: else pi := 0 endif\n10: else if \u2203m \u2208 Mi | (powerm \u2265 pi) then 11: ci := minimumColorNotUsedByNeighborsWithHigherPower() 12: pi := adoptPowerFromStrongestNode() 13: end if 14: sendRefinementMessage() 15: end if 16: clearMessageQueue()"}, {"heading": "3 FrogSim: An Algorithm for Distributed Graph Coloring", "text": "Although the FrogSim algorithm will be described in terms of an algorithm applied in static sensor networks, it can be applied with very few modifications in any other communication network. The algorithm works iteratively using communication rounds. A communication round corresponds to the calling period (2\u03c0) as known from the models presented in the previous section. The only difference is that the length of a communication round is considered to be one time unit. Therefore, the numerical length of a communication round is denoted by 1, instead of 2\u03c0. Each sensor node executes exactly one sensor event in each communication round. The moment in time when a sensor node i \u2208 V executes its sensor event is denoted by \u03b8i \u2208 [0, 1). Note that \u03b8i corresponds to the phase of an oscillator from the models presented in the previous section. Apart from \u03b8i, a sensor node i also stores its current color, denoted by ci \u2208 N. For simplicity and without loss of generality, we assume that each color is uniquely identified by a natural number. Thereafter we will use natural numbers greater than zero to refer to colors. Moreover, a sensor event includes the sending of exactly one message. Therefore, each sensor node imaintains a message queueMi for sensor event messages received from other sensor nodes since the last execution of its own sensor event. The pseudo-code of a sensor event is shown in Algorithm 1. In the following we give a rough description of the algorithm. Detailed technical explanations of the functions of Algorithm 1 will be provided later on.\nBefore the algorithm can be started, it is actually necessary to determine a virtual treeshaped topology over the sensor network. This task is achieved by using any method from the literature to generate a minimum spanning tree in a distributed manner (see, for example, [16, 3, 17, 12]). This tree will determine a single root node that will become a distinguished node of the network (also called the master) with some additional functionalities in comparison to the rest of the nodes. Once this tree has been created, the master node runs a protocol to measure the number of hops (that is, communication rounds) necessary to reach the farthest node in the network. Note that this measure corresponds to the height of the\ntree. Next, the master node uses this tree to broadcasts an alert to start running the FrogSim algorithm, that is, the first communication round is triggered. This message also includes the height of the tree which will be used later on by each node to define the amount of information that it must store. The simulation of the FrogSim algorithm is composed of two distinct phases. The first phase (called phase I; see lines 1\u20135 of Algorithm 1) makes use of the model for the desynchronization of frog calling as introduced by Aihara et al. [1], with only a few modifications. The main difference to other distributed graph coloring algorithms inspired by this model is as follows. The \u03b8i values are used for determining the order in which the nodes are allowed to choose colors, whereas in previous algorithms these values were directly associated to specific colors. Note that our algorithm produces a valid coloring already in the first communication round. The second phase (called phase II, see lines 7\u201315 of Algorithm 1), which is initiated after K > 0 communication rounds of phase I, serves to improve the current coloring by means of a refinement technique, similar to distributed local search.\nPhases I and II of FrogSim will be described in detail in Sections 3.1 and 3.2. Moreover, we will outline how the initially computed tree structure will be used to communicate and store the best coloring found by the algorithm. In this process, each node collects the color identifiers used by its children, determines the highest color used, and sends this information to its parent node. In those cases in which the master node recognizes that the number of colors used in a certain communication round improves over the currently best solution it notifies all the other nodes. This procedure is explained in detail in Section 3.3."}, {"heading": "3.1 Phase I of FrogSim", "text": "During the first K > 0 communication rounds (where K is a parameter of the algorithm) each node i, when executing its sensor event, executes lines 2\u20135 of Algorithm 1. First, node i will examine its message queue Mi. If Mi contains more than one message from the same sender node, all these messages apart from the last one are deleted. In general, a message m \u2208 Mi sent in this phase has the following format:\nm =< thetam, colorm, relevancem > , (9)\nwhere thetam \u2208 [0.1) contains the \u03b8-value of the emitter, colorm is the color currently used by the emitter and relevancem is a parameter that depends on the number of messages received by the emitter during the last communication round. This parameter controls the weight that is given by node i to the corresponding message m. In particular, less weight is given to messages that were emitted by nodes that are influenced by many other nodes. The intuition for this definition of the weights is that the \u03b8-values of nodes that are little influenced by other nodes should converge first. This facilitates the convergence of the \u03b8-values of highlyinfluenced nodes, which in turn facilitates that the system reaches a stable situation, a term which refers to a situation in which the \u03b8-values do not change anymore.\nBased on the messages in Mi, function recalculateTheta() recalculates a new value for \u03b8i:\n\u03b8i := \u03b8i + \u03b1i \u2211\nm\u2208Mi\nrelevancem \u2217 inc[\u03b8m \u2212 \u03b8i] , (10)\nwhere \u03b1i is a parameter used to control the convergence of the system, initially set to 0.5. In general, the lower the value of \u03b1i the smaller the change applied to \u03b8i. Moreover, inc[\u00b7] is a\nfunction\u2014corresponding to the phase shift function of Equation 4\u2014that is defined as follows:\ninc[x] =\n{\nx\u2212 0.5 if x \u2265 0 x+ 0.5 if x < 0\n(11)\nNote that this function replaces the sinus function which was originally used in [1] as the phase shift function. This is because we have noticed that this function leads to a better convergence behavior than the sinus function. Next, node i decides for a possibly new color in function minimumColorNotUsed(). Formally, the possible color change by node i can be described as:\nci := min{c \u2208 N |6 \u2203m \u2208 Mi with colorm = c} (12)\nIn words, node i chooses among the colors that do not appear in any of the received messages m \u2208 Mi, the one with the lowest identifier. Finally, node i sends the following message m (see function sendColoringMessage()):\nm =< thetam := \u03b8i, colorm := ci, relevancem := 1\n|Mi|2 > (13)\nMoreover, node i decreases the value of \u03b1i (see line 5 of Algorithm 1). Hereby, \u03c1 is a parameter of the algorithm that controls the rate of convergence of the \u03b8-values. Note that once the \u03b8-values have converged the current coloring does not change anymore. To conclude a sensor event, node i deletes all messages from its queue Mi (see function clearMessageQueue()), that is, Mi = \u2205."}, {"heading": "3.2 Phase II of FrogSim", "text": "After K > 0 communication rounds, the sensor event of a node i consists of the execution of lines 6\u201315 of Algorithm 1. As mentioned before, this phase is used for the refinement of the current coloring, similar to a distributed local search. Note that in this phase the \u03b8-values of the nodes are not changed anymore. Within the scope of phase II, each node i additionally maintains a so-called power parameter pi. This parameter is initialized in the first communication round of phase II with a positive random integer for the nodes i with ci = 1, and 0 for the rest of the nodes. The values of these power parameters are used to resolve conflicts that may arise during the color changes executed in phase II. In particular, in case two neighboring nodes\u2014that is, two nodes that can communicate\u2014have chosen the same color, the one with the higher power value is allowed to keep it. In fact, the usage of such a parameter performs a distributed coloring starting from many nodes at the same time but assuring that it is as good as if the coloring started from a single node. This node will be chosen randomly among those nodes which have the lowest \u03b8-value in each neighborhood. Further down at the end of this section, a graphic example will illustrate the working of phase II.\nA message m sent by function sendRefinementMessage() (see line 14 of Algorithm 1) has the following format:\nm =< colorm,powerm > (14)\nIn case the current communication round is not the first communication round of phase II, node i first examines again its message queue Mi. If Mi contains more than one message from the same sender node, all these messages apart from the last one are deleted. Then, the remaining messages are examined, and a color change only occurs if there is a message\nm \u2208 Mi such that colorm = ci and powerm \u2265 pi. In words, node i only changes its color if there is an adjacent node with the same color and a higher (or equal) power value. The new color chosen by node i is the first free color that is not already in use by a node influencing node i and that has a power equal to or greater than the power value of node i. Formally, the new color ci is chosen in function minimumColorNotUsedByNeighborsWithHigherPower() as follows:\nci := min{c \u2208 N |6 \u2203m \u2208 Mi with colorm = c \u2227 powerm \u2265 pi} (15)\nIn addition, node i updates its power value in function adoptPowerFromStrongestNode() in the following way:\npi := argmaxm\u2208Mi{powerm} (16)\nThis is the highest power among the powers of the nodes that have forced node i to choose its current color. As a result, in following communication rounds node i will not be forced to change its color, because with the new power it has priority over all nodes with a lower power. Finally, node i sends a refinement message m in function sendRefinementMessage(), where m is defined as follows:\nm =< colorm := ci,power := pi > (17)\nThe last action of the sensor event consists again in deleting all messages from the message queue Mi, that is, Mi = \u2205. Figure 4 shows a small example of the kind of conflicts that phase II is supposed to resolve."}, {"heading": "3.3 Determining and Storing the Best Coloring Found", "text": "It is intuitively clear that the current coloring of our system\u2014that is, the coloring defined by colors ci for all nodes i\u2014does not only improve over time. In some communication rounds, especially during the second phase of the algorithm, the new coloring after the choice of new colors might actually be worse then the coloring of the previous communication round. This behavior is very natural, because the search space of a combinatorial optimization problem is characterized by rather many local minima. If we assume that the current solution corresponds to such a local minimum, the only way to find a better solution is to accept worse solutions for some iterations. In the context of metaheuristic algorithms such an action is known as escaping from a local minimum [6].\nIn order to store the best coloring found by our algorithm over the whole simulation time, the following mechanism is used. Remember that the first action of the algorithm (before simulating phases I and II) consisted in the generation of a virtual minimum spanning tree over the network, resulting in a root node (the master). This tree is characterized by its height h, which corresponds to the maximum number of communication rounds that a broadcast message sent by the root node needs in order to reach all nodes of the network. In this context, note that h may be minimized by using a priori some methods from the literature which are able to generate spanning trees with minimum diameter in a distributed manner [8].\nEach node is required to store its colors from the last 2h communication rounds. Moreover, we assume that each node stores the color it has used in the best-found coloring in a specific variable. The way in which this best-found coloring is determined is as follows. First, at each communication round a node sends the maximum color used by itself and its children (with respect to the tree) to its parent in the tree. Such a message only contains two integers (the maximum color and the communication round identifier). Moreover, no additional messages are required because this information can easily be added to the messages that are sent anyway (see lines 4 and 14 of Algorithm 1). Given the height h of the tree, it takes h communication rounds until all the information regarding a specific communication round has reached the root node. Moreover, the number of colors used at this communication round is the maximum color identifier that reaches the root node via one of its children. In case this maximum color is lower than the number of colors used in the currently best-found coloring, the root node broadcasts a message with the corresponding communication round identifier in which this coloring was obtained. In order for this information to reach all the nodes of the network, another h communication rounds are necessary. This is why all nodes must store their colors from last 2h communication rounds. Note that these alert messages from the root node can also be propagated using the normal messages of Algorithm 1."}, {"heading": "4 Experimental Results", "text": "We coded our algorithm by means of discrete event simulation, implemented from scratch in C++. For the experimental evaluation we chose a large set of different graph topologies: random geometric graphs of different densities, grid graphs of different sizes, and most of the graphs used for the DIMACS challenge [14]. All graphs that we used for the experimental evaluation can be found for download at http://www.lsi.upc.edu/\u02dchhernandez/graphcoloring. Note that an edge connecting two nodes indicates that both nodes are able to communicate directly with each other via their radio antennas.\nFor the purpose of comparison we re-implemented one of the currently best algorithms\nfrom the literature. This algorithm was presented by Finocchi et al. in [13]. For simplicity, this algorithm will henceforth be referred to by Finocchi. Unfortunately, the description of this algorithm in the original article contains some ambiguities, which required us to make some decisions regarding certain aspects in the context of the re-implementation. Fortunately, our own implementation of the Finocci algorithm provides generally better results than the ones reported in [13]. This can be verified by comparing the results of the original implementation with the results of our re-implementation for the graph topologies that are used both in [13] and in the present paper.\nIn the following we present the results of three algorithms: (1) Finocci [13], (2) FrogSim , which is the FrogSim algorithm without phase II, and (3) FrogSim, which is the complete FrogSim algorithm. In our opinion, the study of the results of FrogSim is worthwhile, because it reflects the power of the frog-based model without any additional improvements of the refinement phase. We applied each of these three stochastic algorithms 100 times to each graph topology and report the best coloring found in all 100 runs, as well as the average quality of the best colorings found per run. The number of rounds necessary to reach these solutions is\u2014due to space reasons\u2014not included in the result tables. However, it is important to note that algorithms such as Finocci and FrogSim, when used in sensor networks, are generally carried out continuously in a lower-level layer of the network. Therefore, the number of communication rounds necessary to reach the best solution are not that significant. Instead our algorithm continually tries to improve the current solution. As an informative note, our algorithm requires, on average, 10.34 communication rounds for finding its best solution in phase I. After entering phase II the best solution is reached, on average, after 3.46 communication rounds. In total, FrogSim requires, on average, 24.33 communication rounds for finding its best solution. The algorithm of Finocchi et al. uses, on average, a comparable number of communication rounds (19.83). It should be noted that, in the case of FrogSim, these numbers do not depend so much on the size of the network. However, FrogSim takes generally more communication rounds for those graphs that have a larger number of edges.\nAfter tuning by hand, we decided to use a communication round limit of 100 rounds for FrogSim. Moreover, parameter K, which specifies the number of communication rounds for phase I, was always set to 80. As a last remark, note that the size of the messages used in FrogSim is constant (O(1)). In other words, the message size does not depend on the network size. This is surely a desirably property of a distributed algorithm for graph coloring."}, {"heading": "4.1 Results for Random Geometric Graphs", "text": "Random geometric graphs are popular models for sensor networks. Therefore, they are frequently used for the evaluation of algorithms developed for such networks. They are generated by randomly distributing a set of n nodes in the [0, 1]2 area. Two vertices u and v are connected by an edge, if and only if d(u, v) \u2264 r, where d(., .) is the Euclidean distance and r > 0 is a threshold. More specifically, the three algorithms were applied to 40 random geometric graphs with n \u2208 {20, 50, 100, 200} and r = 0.05.\nTable 1 presents the results obtained for this set of instances. In particular, the first column shows the names of the instances and the second column provides a triple (n,\u2206, \u03c7), where n is the number of nodes, \u2206 the maximum degree, and \u03c7 the chromatic number of the corresponding graph. In case of a question mark, the chromatic number is not known. The following three groups of columns provide the results obtained by the three algorithms.\nFor each algorithm we first give the number of colors from the best coloring found over 100 independent runs. In the second column, we show the average number of colors used by the 100 colorings obtained in 100 runs. For ease of comparison the best performing algorithm for each instance is indicated in bold face. Hereby, the best performing algorithm is defined as the algorithm that finds the best coloring. Ties are broken (if possible) by the average values. The four bottom rows of the table provide a summary of the results. The first one of these rows gives averages for each column. In addition, the last three rows summarize how each algorithm is performing in comparison to the others. The first of these rows (labelled # times better) indicates for each algorithm the number of instances for which the corresponding algorithm was the sole winner, that is, better than the other two algorithms. The second row (labelled # times all equal) indicates for how many instances the results of the three algorithms were equal, whereas the last table row indicates for each algorithm the number of instances for which the corresponding algorithm was the sole looser.\nAs expected, the results show that the smaller the size of the graph, the easier it is to find good colorings. The algorithms obtain equivalent results for 24 out of 40 instances (note that all small instances with 20 and 50 nodes are included in this set). Although Finocchi is 3 times better than the other two algorithms it is also worse in 11 topologies. More importantly, Finocchi is not always able to match the FrogSim algorithms in terms of the best colorings for each instance. More specifically, Finocchi uses 0.250 colors more on average than both FrogSim algorithms. Although FrogSim is not able to outperform the other two algorithms for any given instance it only obtains the worst result for 5 instances. FrogSim improves over the results of FrogSim especially for the larger instances. It turns out to be the sole winner for 10 instances. It is interesting to note that in those cases where FrogSim is better than FrogSim this is due to the average solution quality. In this sense it can be said that in the context of random geometric graphs the use of phase II makes the FrogSim algorithm more robust. It is also important to note that the best colorings obtained are\u2014for almost all instances\u2014better than \u2206 + 1 colors.\nIn addition to Table 1, the results are also presented in a visual form in Figure 5. For each graph (x-axis) the improvement of FrogSim and FrogSim over Finocchi in terms of the best coloring (top graphic) and the average solution quality (bottom graphic) is presented. The 40 considered graphs are ordered from left to right as they appear in Table 1. These graphics show nicely that the FrogSim algorithms gain an advantage over Finocchi with growing instance size (from left to right). The bottom graphic shows that there are only three graphs for which Finocchi achieves a better average solution quality."}, {"heading": "4.2 Results for DIMACS Graphs", "text": "One of the most popular sets of instances in the context of graph coloring is the one introduced for the second DIMACS challenge [14]. This challenge had among its objectives to establish the state-of-the-art techniques for centralized graph coloring. These graphs are generally larger and more complex than, for example, random geometric graphs. The instances originate from very different contexts, ranging from industrial problems to hand-crafted cases that were created to show the ineffectiveness of certain algorithms. This set of instances is often used as a benchmark to study the quality of new algorithms, also in the context of distributed graph coloring (see, for example, [13, 27, 33, 31]).\nThe results are presented in Tables 2 and 3, in the same way as in the case of random\ngeometric graphs. Concerning the chromatic numbers, in many cases they are known. In the cases in which they are not known, we either provide an upper bound (in the form \u2264X) or a question mark. As a general remark before analyzing the results in depth, we would like to mention that for distributed algorithms it is very difficult, if not impossible, to capture the global structure of these graphs in many cases. Therefore, it is not surprising that the results obtained by distributed algorithms are often far away from the chromatic numbers.\nFirst it should be emphasized that the FrogSim algorithms achieve the best results for all instances except for instance zeroin.i.2.col (see Table 3), where Finocchi achieves a slightly better average solution quality. Moreover, only in seven further cases, Finocchi is able to match the results of the FrogSim algorithms. On the other side, for some instances the FrogSim algorithms improve remarkably over Finocchi. Consider, for example, instance DSJC1000.9.col\n(see Table 3) where the best colorings found by the FrogSim algorithms need 297 colors, while the best coloring found by Finocchi uses 315 colors. Other examples of remarkable improvements over Finocchi are the six flat\u2217 instances from Table 3. Concerning the comparison between FrogSim and FrogSim, we can state that the power of the algorithm can clearly be attributed to the first (frog-inspired) phase. As in the case of random geometric graphs, phase II of FrogSim basically helps to make the algorithm more robust. It should also be emphasized that, in all cases, the FrogSim colorings require a number of colors that is smaller than \u2206 + 1. Although in most cases the best solution obtained is not an optimal coloring\u2014respectively, we do not know whether it is or not\u2014for most of the instances of type mulsol.X, myciel.X and zeroin.X our algorithm generates optimal colorings in each of the 100 applications per instance.\nFinally, in Figures 6 and 7 the results of Tables 2 and 3 are provided again in a graphical form."}, {"heading": "4.3 Results for Grid Topologies", "text": "Grid topologies are frequently used in various application areas of sensor networks. In theory, the coloring of grids is very simple. They all can be painted as a chessboard, requiring only two colors. For an example see Figure 8.\nThe way in which an optimal coloring can easily be achieved is to start the coloring process in a single node with the first color, and then proceed incrementally. The next step consists in coloring all the neighbors of the starting node in the second color. All the neighbors of these nodes have to be painted in the first color again, and so on. However, when considering distributed computing, nodes only have local information, whereas information about the position in the grid is missing. Moreover, the incremental process described above is difficult to achieve without a global control. Therefore, when coloring grids in a distributed way, what usually happens is that the coloring process is initiated in several different nodes. If the coloring of these nodes does not follow the chessboard distribution of colors, eventually borders will form where additional colors are needed in order to obtain valid colorings. An example is shown in Figure 9. In this context, remember that numbers correspond to colors. The process of an incremental coloring is shown starting at the top left grid and ending at the\nbottom right grid. The first row shows several nodes where the coloring is initiated with color 1. These wrong initial decisions lead to borders (see the gray-colored nodes in the bottom row) where additional colors are needed.\nComputational results are shown in Table 4. Note that in this case all chromatic numbers are known as they can be established theoretically. While small grids can basically be colored correctly by all three algorithms, both Finocchi and FrogSim have\u2014as expected\u2014increasing difficulties when the grid size grows. Although this is the case, FrogSim has clear advantages over Finocchi. This is indicated by the average numbers given in the fourth but last table row, and also by the fact that Finocchi is the sole looser in 39 cases, whereas FrogSim is the sole looser in only 2 cases. In contrast to the deteriorating performance of Finocchi and FrogSim when the grid size grows, FrogSim achieves perfect colorings in all 100 applications for all\ninstances, which is a remarkable achievement. Even the large grids with periodic boundary conditions (see graphs Ising32x8.col and Ising32x8-torus.col used in [27]) do not pose any difficulty for FrogSim. In contrast, both Finocchi and FrogSim use four colors instead of the optimal two colors, in each coloring generated. Summarizing we can state that phase II of FrogSim is very useful when applied to grid topologies, helping the algorithm to achieve an excellent performance.\nFigure 10 summarizes graphically the results from Table 4. Note that the y-axis is differently scaled than the other summarizing figures in this section due to plotted data requirements. The significant improvement of FrogSim over both Finocchi and FrogSim can be nicely appreciated in these graphics. Also the growing advantage of the FrogSim algorithms over Finocchi can be seen by the fact that the height of the bars generally increases from left to right. Considering the bottom graphic, which concerns the average solutions quality, we can note that FrogSim is much less robust than FrogSim."}, {"heading": "4.4 Results for Small Instances from [27]", "text": "Finally, we present results obtained by the three algorithms for rather small instances used by S. Lee in [27] for the evaluation of a firefly-inspired distributed graph coloring algorithm. We do not directly compare with the results presented in [27], because the algorithm proposed\nin [27] assumes that the number of colors required for the coloring is known a priori, that is, the algorithm must be run for a pre-fixed number of colors. When graphs are large and chromatic numbers are unknown, such an algorithm is not practical. Anyway, FrogSim and the algorithm from [27] behave very similarly for most instances, with some exceptions: for hexagon-based instances, FrogSim is not quite able to match the average results obtained by the algorithm from [27]. Moreover, concerning icosahedron.col, the best solution by FrogSim is uses one color more than the best one by Lee\u2019s algorithm. On the other side, concerning 4-partite4-diff-sizes.col and dodecahedron.col, FrogSim improves over the average results obtained by Lee\u2019s algorithm.\nAs shown in Table 5, the three algorithms achieve equal results in 7 out of 14 cases. Only in one case (see 1hexagon-tess.col) Finocchi is slightly better than the FrogSim algorithms due to the fact that it achieves an optimal coloring in all 100 applications. In the remaining cases both FrogSim and FrogSim obtain better results than Finocchi. Moreover, it is remarkable that both FrogSim and FrogSim obtain for 12 of the 14 instances optimal solutions. The difference between FrogSim and FrogSim is again to be found in the fact that FrogSim is more robust, which is indicated by a better average solution quality.\nFigure 11 graphically summarizes the results as in the previous subsections. Again this graphical way of presenting the results helps to show the improvement of FrogSim over FrogSim in terms of the average solution quality."}, {"heading": "5 Conclusions and Future Work", "text": "Graph coloring is a classical problem of modern mathematics with more than 150 years of history. The problem has been extensively studied in theory and practice. However, its connection to problems that have arisen with the proliferation of wireless networks has sparked\na special interest in resolving the problem in a distributed manner. In such algorithms\u2014due to the lack of global knowledge\u2014the nodes have to base their color choices exclusively on information they receive from their direct neighborhood.\nThe algorithm we have presented in this paper is inspired by the behavior of a family of frogs native to Japan, namely the calling behavior of Japanese tree frogs. The results achieved by the proposed algorithm compare very favorably with current state-of-the-art algorithms. In particular, an improved performance has been measured for about 90% of\nthe studied instances. The benchmark set that we chose for comparison includes random geometric graphs, most of the graphs of the DIMACS challenge, and grid graphs. Apart from the favorable results, the proposed algorithms comes with some other benefits. It is possible, for example, to adjust the speed of convergence depending on the time the user wants to spend on the algorithm. Moreover, the number of communication rounds required is comparable to that required by other algorithms that provide high quality solutions. Finally, our algorithm provides a valid coloring already in the very first communication round.\nWith regard to future work, we consider the use of the proposed algorithm for time division multiplexing (TDM) which is a mechanism for collision-free communication in wireless networks, which is strongly related to graph coloring. Finally, due to its adaptive nature, our algorithm might also be interesting for mobile networks, or any dynamically changing network. The fact that nodes appear or disappear at certain points in time is nothing strange in wireless ad hoc networks."}, {"heading": "Acknowledgment", "text": "This work was supported by grant TIN2007-66523 (FORMALISM) of the Spanish government, and by the EU project FRONTS (FP7-ICT-2007-1). In addition, C. Blum acknowledges\nsupport from the Ramo\u0301n y Cajal program of the Spanish Government, and H. Herna\u0301ndez acknowledges support from the Comissionat per a Universitats i Recerca del Departament d\u2019Innovacio\u0301, Universitats i Empresa de la Generalitat de Catalunya and from the European Social Fund."}], "references": [{"title": "Mathematical modeling of frogs\u2019 calling behavior and its possible application to artificial life and robotics", "author": ["I. Aihara", "H. Kitahata", "K. Yoshikawa", "K. Aihara"], "venue": "Artificial Life and Robotics, 12(1):29\u201332,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2008}, {"title": "Modeling synchronized calling behavior of Japanese tree frogs", "author": ["Ikkyu Aihara"], "venue": "Physical Review E,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "Optimal distributed algorithms for minimum weight spanning tree, counting, leader election, and related problems", "author": ["B. Awerbuch"], "venue": "A. V. Aho, editor, Proceedings of STOC 87 \u2013 The 19 Annual ACM Symposium on Theory of Computing, pages 230\u2013240, New York, NY, USA,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1987}, {"title": "A graph coloring heuristic using partial solutions and a reactive tabu scheme", "author": ["I. Bl\u00f6chliger", "N. Zufferey"], "venue": "Computers & Operations Research, 35(3):960\u2013975,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2008}, {"title": "Swarm Intelligence: Introduction and Applications", "author": ["C. Blum", "D. Merkle", "editors"], "venue": "Natural Computing. Springer Verlag, Berlin,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "Metaheuristics in Combinatorial Optimization: Overview and Conceptual Comparison", "author": ["C. Blum", "A. Roli"], "venue": "ACM Computing Surveys, 35(3):268\u2013308,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2003}, {"title": "Swarm Intelligence: From Natural to Artificial Systems", "author": ["E. Bonabeau", "M. Dorigo", "G. Theraulaz"], "venue": "Oxford University Press, New York, NY,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 1999}, {"title": "A distributed algorithm for constructing a minimum diameter spanning tree", "author": ["M. Bui", "F. Butelle", "C. Lavault"], "venue": "Journal of Parallel and Distributed Computing, 64(5):571\u2013577,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2004}, {"title": "Wireless sensor networks with energy efficient organization", "author": ["M. Cardei", "E.D. MacCallum", "X. Cheng"], "venue": "Journal of Interconnection Networks, 3(4):213\u2013229,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2002}, {"title": "Towards desynchronization of multi-hop topologies", "author": ["J. Degesys", "R. Nagpal"], "venue": "Sven Brueckner, Paul Robertson, and Umesh Bellur, editors, Proceedings of the 2nd IEEE International Conference Self-Adaptive and Self-Organizing Systems, pages 129\u2013138. IEEE Press,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2008}, {"title": "Ant Colony Optimization", "author": ["M. Dorigo", "T. St\u00fctzle"], "venue": "MIT Press,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2004}, {"title": "A faster distributed protocol for constructing a minimum spanning tree", "author": ["M. Elkin"], "venue": "Journal of Computer and System Sciences, 72(8):1282\u20131308,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "An experimental analysis of simple, distributed vertex coloring algorithms", "author": ["I. Finocchi", "A. Panconesi", "R. Silvestri"], "venue": "Algorithmica, 41(1):1\u201323,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2005}, {"title": "Distributed computing with advice: Information sensitivity of graph coloring", "author": ["P. Fraigniaud", "C. Gavoille", "D. Ilcinkas", "A. Pelc"], "venue": "Distributed Computing, 21(6):395\u2013403,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2009}, {"title": "A distributed algorithm for minimumweight spanning trees", "author": ["R.G. Gallager", "P.A. Humblet", "P.M. Spira"], "venue": "ACM Transactions on Programming Languages and systems (TOPLAS), 5(1):77,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1983}, {"title": "A sublinear time distributed algorithm for minimum-weight spanning trees", "author": ["J.A. Garay", "S. Kutten", "D. Peleg"], "venue": "SIAM Journal on Computing, 27(1):302\u2013316,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1998}, {"title": "Low power distributed mac for ad hoc sensor radio networks", "author": ["C. Guo", "L.C. Zhong", "J.M. Rabaey"], "venue": "IEEE GLOBECOM \u201901 \u2013 IEEE Global Telecommunications Conference, 2001, volume 5, pages 2944 \u20132948,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2001}, {"title": "Distributed largest-first algorithm for graph coloring", "author": ["J. Hansen", "M. Kubale", "L. Kuszner", "A. Nadolski"], "venue": "Marco Danelutto, Marco Vanneschi, and Domenico Laforenza, editors, Euro-Par 2004 Parallel Processing \u2013 Proceedings of the 10 International Euro- Par Conference, pages 804\u2013811. Springer Berlin / Heidelberg,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2004}, {"title": "A distributed TDMA slot assignment algorithm for wireless sensor networks", "author": ["T. Herman", "S. Tixeuil"], "venue": "S. Nikoletseas and J. D. P. Rolim, editors, ALGOSENSORS 2004 \u2013 Proceedings of 1 International Workshop on Algorithmic Aspects of Wireless Sensor Networks, pages 45\u201358. Springer,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2004}, {"title": "Variable space search for graph coloring", "author": ["A. Hertz", "M. Plumettaz", "N. Zufferey"], "venue": "Discrete Applied Mathematics, 156(13):2551\u20132560,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2008}, {"title": "Reducibility among combinatorial problems", "author": ["R.M. Karp"], "venue": "Proceedings of the Symposium on Complexity of Computer Computations, page 85,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1972}, {"title": "Particle swarm optimization", "author": ["J. Kennedy", "R. Eberhart"], "venue": "Proceedings of the IEEE International Conference on Neural Networks., volume 4, pages 1942\u20131948. IEEE Press,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 1995}, {"title": "Wakeup scheduling in wireless sensor networks", "author": ["A. Keshavarzian", "H. Lee", "L. Venkatraman"], "venue": "MobiHoc 06 \u2013 Proceedings of the 7 ACM International Symposium on Mobile Ad-Hoc Networking and Computing, pages 322\u2013333, New York, NY, USA,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2006}, {"title": "On greedy graph coloring in the distributed model", "author": ["A. Kosowski", "L. Kuszner"], "venue": "Wolfgang Nagel, Wolfgang Walter, and Wolfgang Lehner, editors, Euro-Par 2006 Parallel Processing \u2013 Proceedings of the 12 International Euro-Par Conference, pages 592\u2013601. Springer Berlin / Heidelberg,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2006}, {"title": "On the complexity of distributed graph coloring", "author": ["F. Kuhn", "R. Wattenhofer"], "venue": "PODC 2006 \u2013 Proceedings of the 25 Annual ACM symposium on Principles of Distributed Computing, page 15. ACM,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2006}, {"title": "Firefly Inspired Distributed Graph Coloring Algorithms", "author": ["S.A. Lee"], "venue": "Hamid R. Arabnia and Youngsong Mun, editors, Proceedings of PDPTA 2008 \u2013 International Conference on Parallel and Distributed Processing Techniques and Applications, pages 211\u2013217. CSREA Press,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2008}, {"title": "k-Phase Oscillator Synchronization for Graph Coloring", "author": ["S.A. Lee"], "venue": "Mathematics in Computer Science, 3(1):61\u201372,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2010}, {"title": "Experiments in the dynamics of phase coupled oscillators when applied to graph coloring", "author": ["S.A. Lee", "R. Lister"], "venue": "Proceedings of ACSC 2008 \u2013 Proceedings of the thirtyfirst Australasian conference on Computer science, pages 83\u201389. Australian Computer Society, Inc.,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2008}, {"title": "Delay efficient sleep scheduling in wireless sensor networks", "author": ["G. Lu", "N. Sadagopan", "B. Krishnamachari", "A. Goel"], "venue": "Kia Makki and Edward Knightly, editors, IEEE INFOCOM 2005 \u2013 Proceedings of the 24 International Conference on Computer Communications, pages 2470\u20132481. IEEE,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2005}, {"title": "A memetic algorithm for graph coloring", "author": ["Z. L\u00fc", "J.K. Hao"], "venue": "European Journal of Operational Research, 203(1):241\u2013250,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2010}, {"title": "Distributed Algorithms", "author": ["N.A. Lynch"], "venue": "Elsevier,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2009}, {"title": "A survey on vertex coloring problems", "author": ["E. Malaguti", "P. Toth"], "venue": "International Transactions in Operational Research, 17(1):1\u201334,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2010}, {"title": "Coloring unstructured radio networks", "author": ["T. Moscibroda", "R. Wattenhofer"], "venue": "Distributed Computing, 21(4):271\u2013284,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 2008}, {"title": "Frog Call-Inspired Self-Organizing Anti- Phase Synchronization for Wireless Sensor Networks", "author": ["A. Mutazono", "M. Sugano", "M. Murata"], "venue": "INDS 09 \u2013 Proceedings of the 2 International Workshop on Nonlinear Dynamics and Synchronization, pages 81 \u2013 88. IEEE Press,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2009}, {"title": "A game theoretic approach for efficient graph coloring", "author": ["P. Panagopoulou", "P. Spirakis"], "venue": "Seok-Hee Hong, Hiroshi Nagamochi, and Takuro Fukunaga, editors, ISAAC 2008 \u2013 19 International Symposium on Algorithms and Computation, pages 183\u2013195. Springer Berlin / Heidelberg,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2008}, {"title": "The social behaviour of anuran amphibians", "author": ["K.D. Wells"], "venue": "Animal Behaviour, 25:666\u2013693,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 1977}, {"title": "Distributed stochastic search and distributed breakout: properties, comparison and applications to constraint optimization problems in sensor networks", "author": ["W. Zhang", "G. Wang", "Z. Xing", "L. Wittenburg"], "venue": "Artificial Intelligence, 161(1-2):55\u201387,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2005}], "referenceMentions": [{"referenceID": 20, "context": "The optimization version of the graph coloring problem (GCP), which is NP -hard [22], consists in finding the minimum number k of colors such that a valid k-coloring can be found.", "startOffset": 80, "endOffset": 84}, {"referenceID": 18, "context": "Examples include TDMA slot assignment [20], detection of mobile objects and reduction of", "startOffset": 38, "endOffset": 42}, {"referenceID": 36, "context": "signaling actuators [38], distributed MAC layer management [18], energy-efficient coverage [9], delay efficient sleep scheduling [30] or wakeup scheduling [24].", "startOffset": 20, "endOffset": 24}, {"referenceID": 16, "context": "signaling actuators [38], distributed MAC layer management [18], energy-efficient coverage [9], delay efficient sleep scheduling [30] or wakeup scheduling [24].", "startOffset": 59, "endOffset": 63}, {"referenceID": 8, "context": "signaling actuators [38], distributed MAC layer management [18], energy-efficient coverage [9], delay efficient sleep scheduling [30] or wakeup scheduling [24].", "startOffset": 91, "endOffset": 94}, {"referenceID": 28, "context": "signaling actuators [38], distributed MAC layer management [18], energy-efficient coverage [9], delay efficient sleep scheduling [30] or wakeup scheduling [24].", "startOffset": 129, "endOffset": 133}, {"referenceID": 22, "context": "signaling actuators [38], distributed MAC layer management [18], energy-efficient coverage [9], delay efficient sleep scheduling [30] or wakeup scheduling [24].", "startOffset": 155, "endOffset": 159}, {"referenceID": 30, "context": "Due to the distributed nature of these networks, algorithms for solving problems related to graph coloring are generally also required to be distributed [32].", "startOffset": 153, "endOffset": 157}, {"referenceID": 35, "context": "Several researchers have observed that male Japanese tree frogs decouple their calls [37].", "startOffset": 85, "endOffset": 89}, {"referenceID": 0, "context": "In [1] Aihara et al.", "startOffset": 3, "endOffset": 6}, {"referenceID": 1, "context": "A subsequent work [2] mentions some potential applications of this model in artificial life and robotics.", "startOffset": 18, "endOffset": 21}, {"referenceID": 6, "context": "Therefore, the algorithm proposed in this paper, which is based on this self-desynchronization mechanism, can be regarded as a swarm intelligence approach [7, 5].", "startOffset": 155, "endOffset": 161}, {"referenceID": 4, "context": "Therefore, the algorithm proposed in this paper, which is based on this self-desynchronization mechanism, can be regarded as a swarm intelligence approach [7, 5].", "startOffset": 155, "endOffset": 161}, {"referenceID": 21, "context": "Successful examples from the literature include particle swarm optimization (PSO) [23], which is an algorithm for optimization inspired by bird flocking and fish schooling, and ant colony optimization (ACO) [11], which is inspired by the foraging behavior of ant colonies.", "startOffset": 82, "endOffset": 86}, {"referenceID": 10, "context": "Successful examples from the literature include particle swarm optimization (PSO) [23], which is an algorithm for optimization inspired by bird flocking and fish schooling, and ant colony optimization (ACO) [11], which is inspired by the foraging behavior of ant colonies.", "startOffset": 207, "endOffset": 211}, {"referenceID": 0, "context": "[1], with some small modifications.", "startOffset": 0, "endOffset": 3}, {"referenceID": 31, "context": "A recent survey can be found in [33].", "startOffset": 32, "endOffset": 36}, {"referenceID": 3, "context": "Especially effective are the tabu search algorithm from [4], a hybrid approach combining tabu search and evolutionary algorithms from [31] and a variable neighborhood search technique [21].", "startOffset": 56, "endOffset": 59}, {"referenceID": 29, "context": "Especially effective are the tabu search algorithm from [4], a hybrid approach combining tabu search and evolutionary algorithms from [31] and a variable neighborhood search technique [21].", "startOffset": 134, "endOffset": 138}, {"referenceID": 19, "context": "Especially effective are the tabu search algorithm from [4], a hybrid approach combining tabu search and evolutionary algorithms from [31] and a variable neighborhood search technique [21].", "startOffset": 184, "endOffset": 188}, {"referenceID": 13, "context": "In [15], Fraigniaud et al.", "startOffset": 3, "endOffset": 7}, {"referenceID": 12, "context": "in [13].", "startOffset": 3, "endOffset": 7}, {"referenceID": 12, "context": "As the algorithm proposed in [13] was shown to outperform the state of the art, we have chosen this algorithm for comparison.", "startOffset": 29, "endOffset": 33}, {"referenceID": 25, "context": "Concerning distributed algorithms based on swarm intelligence principles, the literature offers, for example, a method inspired by the synchronous flashing of fireflies (see [27]).", "startOffset": 174, "endOffset": 178}, {"referenceID": 27, "context": "The first intent to use the calling behavior of frogs for graph coloring was presented in [29].", "startOffset": 90, "endOffset": 94}, {"referenceID": 26, "context": "This work was further extended by adding a parameter for setting a priori the number of allowed phases [28].", "startOffset": 103, "endOffset": 107}, {"referenceID": 17, "context": "[19] proposed the distributed largest-first (DLF) algorithm that runs in O(\u22062logn) communication rounds for arbitrary graphs and that was proven to provide good upper bounds for specific topologies.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "This work was further extended by Kosowski and Kuszner [25] who reduced the time complexity to O(\u2206lognlog\u2206).", "startOffset": 55, "endOffset": 59}, {"referenceID": 32, "context": "Later, in [34] Moscibroda and Wattenh\u00f6fer introduced an algorithm for obtaining O(\u2206)-colorings in O(\u03b4logn) time when considering random geometric graphs and other well-known models for wireless multi-hop networks (no results are given for other topologies).", "startOffset": 10, "endOffset": 14}, {"referenceID": 34, "context": "Other theoretical works which may be of interest for the development of new algorithms are the game theoretic approach for efficient graph coloring from Panagopoulou and Spirakis [36] and the work by Kuhn and Wattenh\u00f6fer [26], which introduces a new lower bound on the number of colors used by algorithms that are restricted to one single communication round and a new lower bound on the time complexity of obtaining a O(\u2206)-coloring of a graph.", "startOffset": 179, "endOffset": 183}, {"referenceID": 24, "context": "Other theoretical works which may be of interest for the development of new algorithms are the game theoretic approach for efficient graph coloring from Panagopoulou and Spirakis [36] and the work by Kuhn and Wattenh\u00f6fer [26], which introduces a new lower bound on the number of colors used by algorithms that are restricted to one single communication round and a new lower bound on the time complexity of obtaining a O(\u2206)-coloring of a graph.", "startOffset": 221, "endOffset": 225}, {"referenceID": 35, "context": "Different studies (see, for example, [37]) have shown that male Japanese tree frogs use their calling to attract females.", "startOffset": 37, "endOffset": 41}, {"referenceID": 0, "context": "[1] introduced a formal model based on a set of coupled oscillators each one simulating the phase change in the calling period of a single frog.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "[1] works as follows.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "In [1], the authors suggest the use of the following phase shift function: g(x) = \u03b1 sin(x) (4)", "startOffset": 3, "endOffset": 6}, {"referenceID": 0, "context": "The system presented in [1] is able to successfully locate two coupled oscillators in perfect anti-phase, independent of the initial settings of \u03b81 and \u03b82.", "startOffset": 24, "endOffset": 27}, {"referenceID": 0, "context": "In [1] the authors provide analytical results for using three oscillators and show that there is a high system sensitivity with respect to the initial phases (only a small subset of the possible initial settings leads to an optimal solution).", "startOffset": 3, "endOffset": 6}, {"referenceID": 0, "context": "[1] was later extended by Mutazono et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 33, "context": "[35].", "startOffset": 0, "endOffset": 4}, {"referenceID": 33, "context": "The resulting phase shift function as introduced in [35] can be described as follows:", "startOffset": 52, "endOffset": 56}, {"referenceID": 33, "context": "[35] compared the results of their system to another mechanism for coupled oscillator desynchronization proposed in [10].", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "[35] compared the results of their system to another mechanism for coupled oscillator desynchronization proposed in [10].", "startOffset": 116, "endOffset": 120}, {"referenceID": 9, "context": "Note that the mechanism from [10] is not based", "startOffset": 29, "endOffset": 33}, {"referenceID": 0, "context": "Figure 3: Two examples for graph topologies (graphics (a) and (d)) that may cause problems for the desynchronization as performed by the model proposed in [1].", "startOffset": 155, "endOffset": 158}, {"referenceID": 33, "context": "As shown in [35], both systems achieve similar results although no extensive experimentation is made on a broad-enough set of network topologies: mostly random geometric graphs and hand-made instances with at most eight nodes were used.", "startOffset": 12, "endOffset": 16}, {"referenceID": 0, "context": "[1] was introduced in [29].", "startOffset": 0, "endOffset": 3}, {"referenceID": 27, "context": "[1] was introduced in [29].", "startOffset": 22, "endOffset": 26}, {"referenceID": 14, "context": "This task is achieved by using any method from the literature to generate a minimum spanning tree in a distributed manner (see, for example, [16, 3, 17, 12]).", "startOffset": 141, "endOffset": 156}, {"referenceID": 2, "context": "This task is achieved by using any method from the literature to generate a minimum spanning tree in a distributed manner (see, for example, [16, 3, 17, 12]).", "startOffset": 141, "endOffset": 156}, {"referenceID": 15, "context": "This task is achieved by using any method from the literature to generate a minimum spanning tree in a distributed manner (see, for example, [16, 3, 17, 12]).", "startOffset": 141, "endOffset": 156}, {"referenceID": 11, "context": "This task is achieved by using any method from the literature to generate a minimum spanning tree in a distributed manner (see, for example, [16, 3, 17, 12]).", "startOffset": 141, "endOffset": 156}, {"referenceID": 0, "context": "[1], with only a few modifications.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "Note that this function replaces the sinus function which was originally used in [1] as the phase shift function.", "startOffset": 81, "endOffset": 84}, {"referenceID": 5, "context": "In the context of metaheuristic algorithms such an action is known as escaping from a local minimum [6].", "startOffset": 100, "endOffset": 103}, {"referenceID": 7, "context": "In this context, note that h may be minimized by using a priori some methods from the literature which are able to generate spanning trees with minimum diameter in a distributed manner [8].", "startOffset": 185, "endOffset": 188}, {"referenceID": 12, "context": "in [13].", "startOffset": 3, "endOffset": 7}, {"referenceID": 12, "context": "Fortunately, our own implementation of the Finocci algorithm provides generally better results than the ones reported in [13].", "startOffset": 121, "endOffset": 125}, {"referenceID": 12, "context": "This can be verified by comparing the results of the original implementation with the results of our re-implementation for the graph topologies that are used both in [13] and in the present paper.", "startOffset": 166, "endOffset": 170}, {"referenceID": 12, "context": "In the following we present the results of three algorithms: (1) Finocci [13], (2) FrogSim , which is the FrogSim algorithm without phase II, and (3) FrogSim, which is the complete FrogSim algorithm.", "startOffset": 73, "endOffset": 77}, {"referenceID": 0, "context": "They are generated by randomly distributing a set of n nodes in the [0, 1]2 area.", "startOffset": 68, "endOffset": 74}, {"referenceID": 12, "context": "This set of instances is often used as a benchmark to study the quality of new algorithms, also in the context of distributed graph coloring (see, for example, [13, 27, 33, 31]).", "startOffset": 160, "endOffset": 176}, {"referenceID": 25, "context": "This set of instances is often used as a benchmark to study the quality of new algorithms, also in the context of distributed graph coloring (see, for example, [13, 27, 33, 31]).", "startOffset": 160, "endOffset": 176}, {"referenceID": 31, "context": "This set of instances is often used as a benchmark to study the quality of new algorithms, also in the context of distributed graph coloring (see, for example, [13, 27, 33, 31]).", "startOffset": 160, "endOffset": 176}, {"referenceID": 29, "context": "This set of instances is often used as a benchmark to study the quality of new algorithms, also in the context of distributed graph coloring (see, for example, [13, 27, 33, 31]).", "startOffset": 160, "endOffset": 176}, {"referenceID": 25, "context": "col used in [27]) do not pose any difficulty for FrogSim.", "startOffset": 12, "endOffset": 16}, {"referenceID": 25, "context": "4 Results for Small Instances from [27]", "startOffset": 35, "endOffset": 39}, {"referenceID": 25, "context": "Lee in [27] for the evaluation of a firefly-inspired distributed graph coloring algorithm.", "startOffset": 7, "endOffset": 11}, {"referenceID": 25, "context": "We do not directly compare with the results presented in [27], because the algorithm proposed", "startOffset": 57, "endOffset": 61}, {"referenceID": 25, "context": "in [27] assumes that the number of colors required for the coloring is known a priori, that is, the algorithm must be run for a pre-fixed number of colors.", "startOffset": 3, "endOffset": 7}, {"referenceID": 25, "context": "Anyway, FrogSim and the algorithm from [27] behave very similarly for most instances, with some exceptions: for hexagon-based instances, FrogSim is not quite able to match the average results obtained by the algorithm from [27].", "startOffset": 39, "endOffset": 43}, {"referenceID": 25, "context": "Anyway, FrogSim and the algorithm from [27] behave very similarly for most instances, with some exceptions: for hexagon-based instances, FrogSim is not quite able to match the average results obtained by the algorithm from [27].", "startOffset": 223, "endOffset": 227}, {"referenceID": 25, "context": "Table 5: Results of the algorithms on instances from the article [27].", "startOffset": 65, "endOffset": 69}, {"referenceID": 25, "context": "Figure 11: Summary of results for the small graphs from [27].", "startOffset": 56, "endOffset": 60}], "year": 2010, "abstractText": "Graph coloring\u2014also known as vertex coloring\u2014considers the problem of assigning colors to the nodes of a graph such that adjacent nodes do not share the same color. The optimization version of the problem concerns the minimization of the number of used colors. In this paper we deal with the problem of finding valid colorings of graphs in a distributed way, that is, by means of an algorithm that only uses local information for deciding the color of the nodes. Such algorithms prescind from any central control. Due to the fact that quite a few practical applications require to find colorings in a distributed way, the interest in distributed algorithms for graph coloring has been growing during the last decade. As an example consider wireless ad-hoc and sensor networks, where tasks such as the assignment of frequencies or the assignment of TDMA slots are strongly related to graph coloring. The algorithm proposed in this paper is inspired by the calling behavior of Japanese tree frogs. Male frogs use their calls to attract females. Interestingly, groups of males that are located nearby each other desynchronize their calls. This is because female frogs are only able to correctly localize the male frogs when their calls are not too close in time. We experimentally show that our algorithm is very competitive with the current state of the art, using different sets of problem instances and comparing to one of the most competitive algorithms from the literature.", "creator": "LaTeX with hyperref package"}}}