{"id": "1102.5385", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Feb-2011", "title": "Back and Forth Between Rules and SE-Models (Extended Version)", "abstract": "rules in logic programming encode information about mutual interdependencies between literals that is not captured yet by any description of the commonly used semantics. recognizing this information becomes essential as for soon as a program needs to be modified or further manipulated.", "histories": [["v1", "Sat, 26 Feb 2011 03:06:55 GMT  (30kb)", "https://arxiv.org/abs/1102.5385v1", "25 pages"], ["v2", "Tue, 1 Mar 2011 18:08:20 GMT  (30kb)", "http://arxiv.org/abs/1102.5385v2", "25 pages; extended version of the paper accepted for LPNMR 2011"]], "COMMENTS": "25 pages", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["martin slota", "jo\\~ao leite"], "accepted": false, "id": "1102.5385"}, "pdf": {"name": "1102.5385.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Jo\u00e3o Leite"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n10 2.\n53 85\nv2 [\ncs .A\nI] 1\nM ar"}, {"heading": "1 Motivation", "text": "In this paper we take a closer look at the relationship between the SE-model semantics and individual rules of a logic program. We identify a set of representatives of rule equivalence classes, which we dub canonical rules, characterise the class of sets of SE-interpretations that are representable by a single rule, and show how the corresponding canonical rules can be reconstructed from them. We believe that these results pave the way to view and manipulate a logic program as the set of sets of SE-models of each rule inside it. This is important in situations when the set of SE-models of the whole program fails to capture essential information encoded in individual rules inside it, such as when the program needs to be modified or further manipulated. With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].\nIn many extensions of Answer-Set Programming, individual rules of a program are treated as first-class citizens \u2013 apart from their prime role of encoding the answer sets\n\u22c6 This is an extended version of the paper accepted for publication at LPNMR 2011. Changes on March 1, 2011: minor substitutions to be in line with the LPNMR version.\nassigned to the program, they carry essential information about mutual interdependencies between literals that cannot be captured by answer sets. Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]). These approaches look at subsets of logic programs in search of plausible conflict resolutions. Some of them go even further and consider particular literals in heads and bodies of rules in order to identify conflicts and find ways to solve them. This often leads to definitions of new notions which are too syntax-dependent. At the same time, however, semantic properties of the very same notions need to be analysed, and their syntactic basis then frequently turns into a serious impediment.\nArguably, a more syntax-independent method for this kind of operations would be desirable. Not only would it be theoretically more appealing, but it would also allow for a better understanding of its properties with respect to the underlying semantics. Moreover, such a more semantic approach could facilitate the establishment of bridges with the area of Belief Change (see [12] for an introduction), and benefit from the many years of research where semantic change operations on monotonic logics have been studied, desirable properties for such operations have been identified, and constructive definitions of operators satisfying these properties have been introduced.\nHowever, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand. Though their definition and analysis is technically possible and leads to very elegant and seemingly desirable properties, there are a number of simple examples for which these methods fail to provide results that would be in line with basic intuitions [4]. Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs. This can be demonstrated on simple programs P = { p., q. } and Q = { p., q \u2190 p. } which are strongly equivalent, thus indistinguishable from the semantic perspective, but while P does not contain any dependencies, Q introduces a dependence of atom q upon atom p. This has far-reaching consequences, at least with respect to important notions from the logic programming point of view, such as that of support, which are themselves defined in syntactic rather than semantic terms. For example, if we change our beliefs about p, and come to believe that it is false, we may expect different beliefs regarding q, depending on whether we start form P , in which case q would still be true, or Q, in which case q would no longer be true because it is no longer supported.\nWe believe that rules indeed contain information that, to the best of our knowledge, cannot be captured by any of the existing semantics for Logic Programs. In many situations, this information is essential for making further decisions down the line. Therefore, any operation on logic programs that is expected to respect syntax-based properties like support cannot operate solely on the semantic level, but rather has to look inside the program and acknowledge rules as the atomic pieces of knowledge. At the same time, however, rules need not be manipulated in their original form. The abstraction provided by Logic Programming semantics such as SE-models can be used to discard\nunimportant differences between the syntactic forms of rules and focus on their semantic content. Thus, while a program cannot be viewed as the set of its models for reasons described above, it can still be viewed as a set of sets of models of rules in it. Such a shift of focus should make the approach easier to manage theoretically, while not neglecting the importance of literal dependencies expressed in individual rules. It could also become a bridge between existing approaches to rule evolution and properties as well as operator constructions known from Belief Change, not only highlighting the differences between them, but also clarifying why such differences arise in the first place.\nHowever, before a deeper investigation of such an approach can begin, we do need to know more about the relation of SE-models and individual rules. This is the aim of this paper, where we:\n\u2013 identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; \u2013 show how to reconstruct canonical rules from their sets of SE-models; \u2013 based on the above, characterise the sets of SE-interpretations that are repre-\nsentable by a single rule; \u2013 reveal connections between the set of SE-models of a rule and convex sublattices\nof the set of classical interpretations; \u2013 introduce two new notions of equivalence \u2013 stronger than strong equivalence [1]\nand weaker than strong update equivalence [2] \u2013 and argue that they are more suitable when rules are to be treated as first-class citizens.\nWe believe that these results provide important insights into the workings of SE-models with respect to individual rules and will serve as a toolset for manipulating logic programs at the semantic level.\nThe rest of this document is structured as follows: We introduce syntax and semantics of logic programs in Sect. 2 while in Sect. 3 we define the set of representatives for rule equivalence classes and introduce transformations pinpointing the expressivity of SE-model semantics with respect to individual rules. We also give two characterisations of the sets of SE-interpretations that are representable by a single rule. In Sect. 4 we discuss the relevance of our results and propose the two new notions of equivalence."}, {"heading": "2 Preliminaries", "text": "We assume to be given a nonempty, finite set of propositional atoms L from which we construct both propositional formulae and rules.\nPropositional formulae are formed in the usual way from propositional atoms in L, the logical constants \u22a4 an \u22a5, and the connectives \u00ac,\u2227,\u2228,\u2282,\u2283,\u2261. An interpretation is any subset of L, naturally inducing a truth assignment to all propositional formulae. If a formula \u03c6 is true under interpretation I , we also say that I is a model of \u03c6. The set of all interpretations is denoted by I.\nSimilarly as for propositional formulae, the basic syntactic building blocks of rules are propositional atoms from L. A negative literal is an atom preceded by \u223c, denoting default negation. A literal is either an atom or a negative literal. As a convention, double\ndefault negation is absorbed, so that \u223c\u223cp denotes the atom p. Given a set of literals X , we introduce the following notation:\nX+ = { p \u2208 L | p \u2208 X } X\u2212 = { p \u2208 L | \u223cp \u2208 X } \u223cX = { \u223cp | p \u2208 X \u2229 L }\nGiven natural numbers k, l,m, n and atoms p1, . . . , pk, q1, . . . , ql, r1, . . . , rm, s1, . . . , sn, we say the pair of sets of literals\n\u3008{ p1, . . . , pk,\u223cq1, . . . ,\u223cql } , { r1, . . . , rm,\u223cs1, . . . ,\u223csn }\u3009 (1)\nis a rule. The first component of a rule (1) is denoted by H(r) and the second by B(r). We say H(r) is the head of r, H(r)+ is the positive head of r, H(r)\u2212 is the negative head of r, B(r) is the body of r, B(r)+ is the positive body of r and B(r)\u2212 is the negative body of r. Usually, for convenience, instead of a rule r of the form (1) we write the expression\np1; . . . ; pk;\u223cq1; . . . ;\u223cql \u2190 r1, . . . , rm,\u223cs1, . . . ,\u223csn. (2)\nor, alternatively, H(r)+;\u223cH(r)\u2212 \u2190 B(r)+,\u223cB(r)\u2212. A rule is called positive if its head and body contain only atoms. A program is any set of rules.\nWe also introduce the following non-standard notion which we will need throughout the rest of the paper:\nDefinition 1 (Canonical Tautology). Let p\u03b5 be an arbitrary but fixed atom. The canonical tautology, denoted by \u03b5, is the rule p\u03b5 \u2190 p\u03b5.\nIn the following, we define two semantics for rules. One is that of classical models, where a rule is simply treated as a classical implication. The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18]. This second semantics is strictly more expressive than both classical models and the stable model semantics [19].\nC-Models. We introduce the classical model of a rule by translating the rule into a propositional formula: Given a rule r of the form (2), we define the propositional formula r as \u2228 { p1, . . . , pk,\u00acq1, . . . ,\u00acql } \u2282 \u2227\n{ r1, . . . , rm,\u00acs1, . . . ,\u00acsn }. Note that \u2228 \u2205 \u2261 \u22a5 and \u2227\n\u2205 \u2261 \u22a4. A classical model, or C-model, of a rule r is any model of the formula r. The set of all C-models of a rule r is denoted by modC (r).\nWe say a rule r is a C-tautology, or C-tautological, if modC (r) = I. Otherwise, r is non-C-tautological. We say two rules r, r\u2032 are C-equivalent if they have the same set of C-models. Note that the canonical tautology \u03b5 (c.f. Definition 1) is C-tautological.\nSE-Models. Given a rule r and an interpretation J , we define the reduct of r relative to J , denoted by rJ , as follows: If some atom from H(r)\u2212 is false under J or some atom from B(r)\u2212 is true under J , then rJ is \u03b5; otherwise rJ is H(r)+ \u2190 B(r)+. Intuitively, the reduct rJ is the positive part of a rule r that \u201cremains\u201d after all its negative literals are interpreted under interpretation J . The two conditions in the definition check whether the rule is satisfied based on the negative atoms in its head and body, interpreted under J . If this is the case, the reduct is by definition the canonical tautology. If none of\nthese conditions is satisfied, the positive parts of r are kept in the reduct, discarding the negative ones.\nAn SE-interpretation is a pair of interpretations \u3008I, J\u3009 such that I is a subset of J . The set of all SE-interpretations is denoted by ISE. We say that an SE-interpretation \u3008I, J\u3009 is an SE-model of a rule r if J is a C-model of r and I is a C-model of rJ . The set of all SE-models of a rule r is denoted by modSE (r). The SE-models of a program P are the SE-models of all rules in P . A set of SE-interpretations S is called rule-representable if there exists a rule r such that S = modSE (r).\nWe say that a rule r is SE-tautological if modSE (r) = ISE. Note that the canonical tautology \u03b5 (c.f. Definition 1) is SE-tautological. We say that two rules r, r\u2032 are strongly equivalent, or SE-equivalent, if they have the same set of SE-models."}, {"heading": "3 Rule Equivalence Classes and their Canonical Rules", "text": "Our goal is to find useful insights into the inner workings of the SE-model semantics with respect to single rules. In order to do so, we first introduce a set of representatives of rule equivalence classes induced by SE-models and show how the representative of a class can be constructed given one of its members. Then we show how to reconstruct a representative from the set of its SE-models. Finally, we pinpoint the conditions under which a set of SE-interpretations is rule-representable."}, {"heading": "3.1 Canonical Rules", "text": "We start by bringing out simple but powerful transformations that simplify a given rule while preserving its SE-models. Most of these results have already been formulated in various ways [20, 2, 21]. The following result summarises the conditions under which a rule is SE-tautological:\nLemma 2 (Consequence of Theorem 4.4 in [2]; part i) of Lemma 2 in [21]). Let H and B be sets of literals and p be an atom. Then a rule is SE-tautological if it takes any of the following forms:\np;H \u2190 p,B. H ;\u223cp \u2190 B,\u223cp. H \u2190 B, p,\u223cp.\nProof. See Appendix A, page 16. \u2293\u2294\nThus, repeating an atom in different \u201ccomponents\u201d of the rule frequently causes the rule to be SE-tautological. In particular, this happens if the same atom occurs in the positive head and positive body, or in the negative head and negative body, or in the positive and negative bodies of a rule. How about the cases when the head contains a negation of a literal from the body? The following Lemma clarifies this situation:\nLemma 3 (Consequence of (3) and (4) in Lemma 1 in [21]). Let H and B be sets of literals and L be a literal. Then rules of the following forms are SE-equivalent:\nH ;\u223cL \u2190 L,B. H \u2190 L,B. (3)\nProof. See Appendix A, page 17. \u2293\u2294\nSo if a literal is present in the body of a rule, its negation can be removed from the head. Until now we have seen that a rule r that has a common atom in at least two of the sets H(r)+\u222aH(r)\u2212, B(r)+ and B(r)\u2212 is either SE-tautological, or SE-equivalent to a rule where the atom is omitted from the rule\u2019s head. So such a rule is always SE-equivalent either to the canonical tautology \u03b5, or to a rule without such repetitions. Perhaps surprisingly, repetitions in positive and negative head cannot be simplified away. For example, over the alphabet Lp = { p }, the rule \u201cp;\u223cp \u2190 .\u201d has two SE-models, \u3008\u2205, \u2205\u3009 and \u3008{ p } , { p }\u3009, so it is not SE-tautological, nor is it SE-equivalent to any of the facts \u201cp.\u201d and \u201c\u223cp.\u201d. Actually, it is not very difficult to see that it is not SE-equivalent to any other rule, even over larger alphabets. So the fact that an atom is in both H(r)+ and H(r)\u2212 cannot all by itself imply that some kind of SE-models preserving rule simplification is possible.\nThe final Lemma reveals a special case in which we can eliminate the whole negative head of a rule and move it to its positive body. This occurs whenever the positive head is empty.\nLemma 4 (Related to Corollary 4.10 in [20] and Corollary 1 in [21]). Let H\u2212 be a set of negative literals, B be a set of literals and p be an atom. Then rules of the following forms are SE-equivalent:\n\u223cp;H\u2212 \u2190 B. H\u2212 \u2190 p,B.\nProof. See Appendix A, page 17. \u2293\u2294\nArmed with the above results, we can introduce the notion of a canonical rule. Each such rule represents a different equivalence class on the set of all rules induced by the SE-model semantics. In other words, every rule is SE-equivalent to exactly one canonical rule. After the definition, we provide constructive transformations which show that this is indeed the case. Note that the definition can be derived directly from the Lemmas above:\nDefinition 5 (Canonical Rule). We say a rule r is canonical if either it is \u03b5, or the following conditions are satisfied:\n1. The sets H(r)+ \u222aH(r)\u2212, B(r)+ and B(r)\u2212 are pairwise disjoint. 2. If H(r)+ is empty, then H(r)\u2212 is also empty.\nThis definition is closely related with the notion of a fundamental rule introduced in Definition 1 of [21]. There are two differences between canonical and fundamental rules: (1) a fundamental rule must satisfy condition 1. above, but need not satisfy condition 2.; (2) no SE-tautological rule is fundamental. As a consequence, fundamental rules do not cover all rule-representable sets of SE-interpretations, and two distinct fundamental rules may still be SE-equivalent. From the point of view of rule equivalence classes induced by SE-model semantics, there is one class that contains no fundamental rule, and some classes contain more than one fundamental rule. In the following we show that canonical rules overcome both of these limitations of fundamental rules. In\nother words, every rule is SE-equivalent to exactly one canonical rule. To this end, we define constructive transformations that directly show the mutual relations between rule syntax and semantics.\nThe following transformation provides a direct way of constructing a canonical rule that is SE-equivalent to a given rule r.\nDefinition 6 (Transformation into a Canonical Rule). Given a rule r, by can(r) we denote a canonical rule constructed as follows: If any of the sets H(r)+ \u2229 B(r)+, H(r)\u2212 \u2229B(r)\u2212 and B(r)+ \u2229B(r)\u2212 is nonempty, then can(r) is \u03b5. Otherwise, can(r) is of the form H+;\u223cH\u2212 \u2190 B+,\u223cB\u2212. where\n\u2013 H+ = H(r)+ \\B(r)\u2212. \u2013 If H+ is empty, then H\u2212 = \u2205 and B+ = B(r)+ \u222aH(r)\u2212. \u2013 If H+ is nonempty, then H\u2212 = H(r)\u2212 \\B(r)+ and B+ = B(r)+. \u2013 B\u2212 = B(r)\u2212.\nCorrectness of the transformation follows directly from Lemmas 2 to 4.\nTheorem 7. Every rule r is SE-equivalent to the canonical rule can(r).\nProof. See Appendix A, page 18. \u2293\u2294\nWhat remains to be proven is that no two different canonical rules are SE-equivalent. In the next Subsection we show how every canonical rule can be reconstructed from the set of its SE-models. As a consequence, no two different canonical rules can have the same set of SE-models."}, {"heading": "3.2 Reconstructing Rules", "text": "In order to reconstruct a rule r from the set S of its SE-models, we need to understand how exactly each literal in the rule influences its models. The following Lemma provides a useful characterisation of the set of countermodels of a rule in terms of syntax:\nLemma 8 (Different formulation of Theorem 4 in [21]). Let r be a rule. An SE-interpretation \u3008I, J\u3009 is not an SE-model of r if and only if the following conditions are satisfied:\n1. H(r)\u2212 \u222aB(r)+ \u2286 J and J \u2286 L \\B(r)\u2212. 2. Either J \u2286 L \\H(r)+ or both B(r)+ \u2286 I and I \u2286 L \\H(r)+.\nProof. See Appendix A, page 18. \u2293\u2294\nThe first condition together with the first disjunct of the second condition hold if and only if J is not a C-model of r. The second disjunct then captures the case when I is not a C-model of rJ .\nIf we take a closer look at these conditions, we find that the presence of a negative body atom in J guarantees that the first condition is falsified, so \u3008I, J\u3009 is a model of r, regardless of the content of I . Somewhat similar is the situation with positive head atoms \u2013 whenever such an atom is present in I , it is also present in J , so the second\ncondition is falsified and \u3008I, J\u3009 is a model of r. Thus, if S is the set of SE-models of a rule r, then every atom p \u2208 B(r)\u2212 satisfies\np \u2208 J implies \u3008I, J\u3009 \u2208 S (CB\u2212)\nand every atom p \u2208 H(r)+ satisfies\np \u2208 I implies \u3008I, J\u3009 \u2208 S . (CH+ )\nIf we restrict ourselves to canonical rules different from \u03b5, we find that these conditions are not only necessary, but, when combined properly, also sufficient to decide what atoms belong to the negative body and positive head of the rule.\nFor the rest of this Subsection, we assume that r is a canonical rule different from \u03b5 and S is the set of SE-models of r. Keeping in mind that every atom that satisfies condition (CB\u2212) also satisfies condition (CH+ ) (because I is a subset of J), and that B(r)\u2212 is by definition disjoint from H(r)+, we arrive at the following results:\nLemma 9. An atom p belongs to B(r)\u2212 if and only if for all \u3008I, J\u3009 \u2208 ISE, the condition (CB\u2212) is satisfied. An atom p belongs to H(r)+ if and only if it does not belong to B(r)\u2212 and for all \u3008I, J\u3009 \u2208 ISE, the condition (CH+ ) is satisfied.\nProof. See Appendix A, page 19. \u2293\u2294\nAs can be seen from Lemma 8, the role of positive body and negative head atoms is dual to that of negative body and positive head atoms. Intuitively, their absence in J , and sometimes also in I , implies that \u3008I, J\u3009 is an SE-model of r. It follows from the first condition of Lemma 8 that if p belongs to H(r)\u2212 \u222aB(r)+, then the following condition is satisfied:\np /\u2208 J implies \u3008I, J\u3009 \u2208 S . (CH\u2212 )\nFurthermore, the second condition in Lemma 8 implies that every p \u2208 B(r)+ satisfies the following condition:\np /\u2208 I and J \u2229H(r)+ 6= \u2205 implies \u3008I, J\u3009 \u2208 S . (CB+ )\nThese observations lead to the following results:\nLemma 10. An atom p belongs to B(r)+ if and only if for all \u3008I, J\u3009 \u2208 ISE, the conditions (CH\u2212 ) and (CB+ ) are satisfied. An atom p belongs to H(r)\u2212 if and only if it does not belong to B(r)+ and for all \u3008I, J\u3009 \u2208 ISE, the condition (CH\u2212 ) is satisfied.\nProof. See Appendix A, page 21. \u2293\u2294\nTogether, the two Lemmas above are sufficient to reconstruct a canonical rule from its set of SE-models. The following definition sums up these results by introducing the notion of a rule induced by a set of SE-interpretations:\nDefinition 11 (Rule Induced by a Set of SE-Interpretations). Let S be a set of SE-interpretations. An atom p is called an S-negative-body atom if every SE-interpretation \u3008I, J\u3009 with p \u2208 J belongs to S. An atom p is called an S-positive-head atom if it is not an S-negative-body atom and every SE-interpretation \u3008I, J\u3009 with p \u2208 I belongs to S.\nAn atom p is called an S-positive-body atom if every SE-interpretation \u3008I, J\u3009 with p /\u2208 J belongs to S, and every SE-interpretation \u3008I, J\u3009 with p /\u2208 I and J containing some S-positive-head atom also belongs to S. An atom p is called an S-negative-head atom if it is not an S-positive-body atom and every SE-interpretation \u3008I, J\u3009 with p /\u2208 J belongs to S.\nThe sets of all S-negative-body, S-positive-head, S-positive-body and S-negative-head atoms are denoted by B(S)\u2212, H(S)+, B(S)+ and H(S)\u2212, respectively. The rule induced by S, denoted by rule(S), is defined as follows: If S = ISE, then rule(S) is \u03b5; otherwise, rule(S) is of the form\nH(S)+;\u223cH(S)\u2212 \u2190 B(S)+,\u223cB(S)\u2212.\nThe main property of induced rules is that every canonical rule is induced by its own set of SE-models and can thus be \u201creconstructed\u201d from its set of SE-models. This follows directly from Definition 11 and Lemmas 9 and 10.\nTheorem 12. For every canonical rule r, rule(modSE (r)) = r.\nProof. See Appendix A, page 21. \u2293\u2294\nThis result, together with Theorem 7, has a number of consequences. First, for any rule r, the canonical rule can(r) is induced by the set of SE-models of r.\nCorollary 13. For every rule r, rule(modSE (r)) = can(r).\nProof. Follows directly from Theorem 7 and Theorem 12. \u2293\u2294\nFurthermore, Theorem 12 directly implies that for two different canonical rules r1, r2 we have rule(modSE (r1)) = r1 and rule(modSE (r2)) = r2, so modSE (r1) and modSE (r2) must differ.\nCorollary 14. No two different canonical rules are SE-equivalent.\nProof. Follows directly from the Theorem 12. \u2293\u2294\nFinally, the previous Corollary together with Theorem 7 imply that for every rule there not only exists an SE-equivalent canonical rule, but this rule is also unique.\nCorollary 15. Every rule is SE-equivalent to exactly one canonical rule.\nProof. Follows directly from Theorem 7 and Corollary 14. \u2293\u2294\n3.3 Sets of SE-Interpretations Representable by a Rule\nNaturally, not all sets of SE-interpretations correspond to a single rule, otherwise any program could be reduced to a single rule. The conditions under which a set of SE-interpretations is rule-representable are worth examining.\nA set of SE-models S of a program is always well-defined, i.e. whenever S contains \u3008I, J\u3009, it also contains \u3008J, J\u3009. Moreover, for every well-defined set of SE-interpretations S there exists a program P such that S = modSE (P) [10].\nWe offer two approaches to find a similar condition for the class of rulerepresentable sets of SE-interpretations. The first is based on induced rules defined in the previous Subsection, while the second is formulated using lattice theory and is a consequence of Lemma 8.\nThe first characterisation follows from two properties of the rule(\u00b7) transformation. First, it can be applied to any set of SE-interpretations, even those that are not rulerepresentable. Second, if rule(S) = r, then it holds that modSE (r) is a subset of S.\nLemma 16. The set of all SE-models of a canonical rule r is the least among all sets of SE-interpretations S such that rule(S) = r.\nProof. See Appendix A, page 22. \u2293\u2294\nThus, to verify that S is rule-representable, it suffices to check that all interpretations from S are models of rule(S).\nThe second characterisation follows from Lemma 8 which tells us that if S is rulerepresentable, then its complement consists of SE-interpretations \u3008I, J\u3009 following a certain pattern. Their second component J always contains a fixed set of atoms and is itself contained in another fixed set of atoms. Their first component I satisfies a similar property, but only if a certain further condition is satisfied by J . More formally, for the sets\nI\u22a5 = B(r)+, I\u22a4 = L \\H(r)+, J\u22a5 = H(r)\u2212 \u222aB(r)+, J\u22a4 = L \\B(r)\u2212,\nit holds that all SE-interpretations from the complement of S are of the form \u3008I, J\u3009 where J\u22a5 \u2286 J \u2286 J\u22a4 and either J \u2286 I\u22a4 or I\u22a5 \u2286 I \u2286 I\u22a4. It turns out that this also holds vice versa: if the complement of S satisfies the above property, then S is rule-representable. Furthermore, to accentuate the particular structure that arises, we can substitute the condition J\u22a5 \u2286 J \u2286 J\u22a4 with saying that J belongs to a convex sublattice of I.1 A similar substitution can be performed for I , yielding:\nTheorem 17. Let S be a set of SE-interpretations. Then the following conditions are equivalent:\n1. The set of SE-interpretations S is rule-representable. 2. All SE-interpretations from S are SE-models of rule(S).\n1 A sublattice L of L\u2032 is convex if c \u2208 L whenever a, b \u2208 L and a \u2264 c \u2264 b holds in L\u2032. For more details see e.g. [22].\n3. There exist convex sublattices L1, L2 of \u3008I,\u2286\u3009 such that the complement of S relative to ISE is equal to\n{ \u3008I, J\u3009 \u2208 ISE \u2223 \u2223 I \u2208 L1 \u2227 J \u2208 L2 } \u222a { \u3008I, J\u3009 \u2208 ISE \u2223 \u2223 J \u2208 L1 \u2229 L2 } .\nProof. See Appendix A, page 24. \u2293\u2294"}, {"heading": "4 Discussion", "text": "The presented results mainly serve to facilitate the transition back and forth between a rule and the set of its SE-models. They also make it possible to identify when a given set of SE-models is representable by a single rule. We believe that in situations where information on literal dependencies, expressed in individual rules, is essential for defining operations on logic programs, the advantages of dealing with rules on the level of semantics instead of on the level of syntax are significant. The semantic view takes care of stripping away unnecessary details and since the introduced notions and operators are defined in terms of semantic objects, it should be much easier to introduce and prove their semantic properties.\nThese results can be used for example in the context of program updates to define an update semantics based on the rule rejection principle [4] and operating on sets of sets of SE-models. Such a semantics can serve as a bridge between syntax-based approaches to rule updates, and the principles and semantic distance measures known from the area of Belief Change. The next steps towards such a semantics involve a definition of the notion of support for a literal by a set of SE-models (of a rule). Such a notion can then foster a better understanding of desirable properties for semantic rule update operators.\nOn a different note, viewing a logic program as the set of sets of SE-models of rules inside it leads naturally to the introduction of the following new notion of program equivalence:\nDefinition 18 (Strong Rule Equivalence). Programs P1,P2 are SR-equivalent, denoted by P1 \u2261SR P2, if\n{modSE (r) | r \u2208 P1 \u222a { \u03b5 } } = {modSE (r) | r \u2208 P2 \u222a { \u03b5 } } .\nThus, two programs are SR-equivalent if they contain the same rules, modulo the SE-model semantics. We add \u03b5 to each of the two programs in the definition so that presence or absence of tautological rules in a program does not influence program equivalence. SR-equivalence is stronger than strong equivalence, in the following sense:\nDefinition 19 (Strength of Program Equivalence). Let \u22611,\u22612 be equivalence relations on the set of all programs. We say that \u22611 is at least as strong as \u22612, denoted by \u22611 \u22612, if P1 \u22611 P2 implies P1 \u22612 P2 for all programs P1,P2. We say that \u22611 is stronger than \u22612, denoted by \u22611\u227b\u22612, if \u22611 \u22612 but not \u22612 \u22611.\nThus, using the notation of the above definition, we can write \u2261SR \u227b\u2261S, where \u2261S denotes the relation of strong equivalence. An example of programs that are strongly\nequivalent, but not SR-equivalent is P = { p., q. } and Q = { p., q \u2190 p. }, which in many cases need to be distinguished from one another. We believe that this notion of program equivalence is much more suitable for cases when the dependency information contained in a program is of importance.\nIn certain cases, however, SR-equivalence may be too strong. For instance, it may be desirable to treat programs such as P1 = { p \u2190 q. } and P2 = { p \u2190 q., p \u2190 q, r. } in the same way because the extra rule in P2 is just a weakened version of the rule in P1. For instance, the notion of update equivalence introduced in [23], which is based on a particular approach to logic program updates, considers programs P1 and P2 as equivalent because the extra rule in P2 cannot influence the result of any subsequent updates. Since these programs are not SR-equivalent, we also introduce the following notion of program equivalence, which in terms of strength falls between strong equivalence and SR-equivalence.\nDefinition 20 (Strong Minimal Rule Equivalence). ProgramsP1,P2 are SMR-equivalent, denoted by P1 \u2261SMR P2, if\nmin {modSE (r) | r \u2208 P1 \u222a { \u03b5 } } = min {modSE (r) | r \u2208 P2 \u222a { \u03b5 } } ,\nwhere minS denotes the set of subset-minimal elements of S.\nIn order for programs to be SMR-equivalent, they need not contain exactly the same rules (modulo strong equivalence), it suffices if rules with subset-minimal sets of SE-models are the same (again, modulo strong equivalence). Certain programs, such as P1 and P2 above, are not SR-equivalent but they are still SMR-equivalent.\nRelated to this is the very strong notion of equivalence which was introduced in [2]:\nDefinition 21 (Strong Update Equivalence, c.f. Definition 4.1 in [2]). Two programs P1, P1 are SU-equivalent, denoted by P1 \u2261SU P2, if for any programs Q, R it holds that the program ((P1\\Q)\u222aR) has the same answer sets as the program ((P2\\Q)\u222aR).\nTwo programs are strongly update equivalent only under very strict conditions \u2013 it is shown in [2] that two programs are SU-equivalent if and only if their symmetric difference contains only SE-tautological rules. This means that programs such as Q1 = {\u223cp. }, Q2 = {\u2190 p. } and Q3 = {\u223cp \u2190 p. } are considered to be mutually nonequivalent, even though the rules they contain are mutually SE-equivalent. This may be seen as too sensitive to rule syntax.\nThe following result formally establishes the relations between the discussed notions of program equivalence:\nTheorem 22. SU-equivalence is stronger than SR-equivalence, which itself is stronger than SMR-equivalence, which in turn is stronger than strong equivalence. That is,\n\u2261SU\u227b\u2261SR\u227b\u2261SMR\u227b\u2261S .\nProof. See Appendix A, page 24. \u2293\u2294\nThe other notion of program equivalence introduced in [2], strong update equivalence on common rules, or SUC-equivalence, is incomparable in terms of strength to our new notions of equivalence. On the one hand, SR- and SMR-equivalent programs such as {\u223cp. } and {\u223cp.,\u2190 p. } are not SUC-equivalent. On the other hand, programs such as { p., q \u2190 p. } and { q., p \u2190 q. } are neither SR- nor SMR-equivalent, but they are SUC-equivalent. We believe that both of these examples are more appropriately treated by the new notions of equivalence.\nThe introduction of canonical rules, which form a set of representatives of rule equivalence classes induced by SE-models, also reveals the exact expressivity of SE-model semantics with respect to a single rule. From their definition we can see that SE-models are capable of distinguishing between any pair of rules, except for (1) a pair of rules that only differ in the number of repetitions of literals in their heads and bodies; (2) an integrity constraint and a rule whose head only contains negative literals. We believe that in the former case, there is little reason to distinguish between such rules and so the transition from rules to their SE-models has the positive effect of stripping away of unnecessary details. However, the latter case has more serious consequences. Although rules such as\n\u223cp \u2190 q. and \u2190 p, q.\nare usually considered to carry the same meaning, some existing work suggests that they should be treated differently \u2013 while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8]. If we view a rule through the set of its SE-models, we cannot distinguish these two kinds of rules anymore. Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17]."}, {"heading": "Acknowledgement", "text": "We would like to thank Han The Anh, Matthias Knorr and the anonymous reviewers for their comments that helped to improve the paper. Martin Slota is supported by FCT scholarship SFRH / BD / 38214 / 2007."}, {"heading": "A Proofs", "text": "Lemma 2. Let H and B be sets of literals and p be an atom. Then a rule is SE-tautological if it takes any of the following forms:\np;H \u2190 p,B. H ;\u223cp \u2190 B,\u223cp. H \u2190 B, p,\u223cp.\nProof. First assume that rule r is of the first form. We need to show that any SE-interpretation is an SE-model of r. Suppose \u3008I, J\u3009 is some SE-interpretation. Rule r is C-tautological, so J is a C-model of r. Furthermore, rJ is either \u03b5, or it inherits p in both its head and body from r. In any case, r is C-tautological, so I is a C-model of rJ . Consequently, \u3008I, J\u3009 is an SE-model of r.\nNow suppose r is of the second form. As before, given an SE-interpretation \u3008I, J\u3009, we see that J is a C-model of r because r is C-tautological. Furthermore, rJ will necessarily end up being equal to \u03b5 because of the atom p common to H(r)\u2212 and B(r)\u2212, regardless of how J interprets p. So I is a C-model of rJ , and, consequently, \u3008I, J\u3009 is an SE-model of r.\nFinally, suppose r takes the third form and take an SE-interpretation \u3008I, J\u3009. Rule r can again easily be verified to be C-tautological, so J is a C-model of r. If all atoms from B(r)\u2212 are false under J , then rJ contains the atom p in its body that is false under J , thus also false under I since I is a subset of J . Consequently, I is a C-model of rJ . On the other hand, if at least one of atoms from B(r)\u2212 is true under J , then rJ is equal to \u03b5, so again, I is a C-model of rJ . Consequently, \u3008I, J\u3009 is an SE-model of r. \u2293\u2294\nLemma 23. Let H and B be sets of literals and p be an atom. Then rules of the following forms are SE-equivalent:\np;H \u2190 B,\u223cp. H \u2190 B,\u223cp.\nProof. Let the first rule be denoted by r1 and the second by r2 and suppose \u3008I, J\u3009 is an SE-interpretation. We will show that \u3008I, J\u3009 is an SE-model of r1 if and only if it is an SE-model of r2. We can easily see that rules r1, r2 are C-equivalent. So J is either not a C-model of any of them or it is a C-model of both of them. In the former case, \u3008I, J\u3009 is not an SE-model of any of the two rules and we are finished. In the latter case, we need to distinguish two cases:\na) If J is a not a model of the bodies of r1 and r2 (the bodies are identical), then either rJ1 and r J 2 are equal to \u03b5, or they contain an atom in their bodies that is false under\nJ , thus also false under I because I is a subset of J . In any case, I is a C-model of both rJ1 and r J 2 , so \u3008I, J\u3009 is an SE-model of both r1 and r2. b) If J is a model of the bodies of r1 and r2, then p is false under J , and, since J is a C-model of r1, some literal from H must be true under J . Consequently, either both rJ1 and r J 2 are equal to \u03b5 and I is a C-model of both of them, or r J 1 and r J 2\nonly differ in the single extra atom p that rJ1 has in the head. However, since I is a subset of J and p is false under J , p cannot be true under I , so I is either not a C-model of any of rJ1 , r J 2 , or it is a C-model of both of them. In any case, \u3008I, J\u3009 is a SE-model of r1 if and only if it is an SE-model of r2.\nThus, we have proven that every SE-interpretation is an SE-model of r1 if and only if it is an SE-model of r2. In other words, r1 and r2 are SE-equivalent. \u2293\u2294\nLemma 24. Let H and B be sets of literals and p be an atom. Then rules of the following forms are SE-equivalent:"}, {"heading": "H ;\u223cp \u2190 p,B. H \u2190 p,B.", "text": "Proof. Let the first rule be denoted by r1 and the second by r2. Suppose \u3008I, J\u3009 is some SE-interpretation. If p is false under J , then J is a C-model of both r1 and r2. Furthermore, rJ1 is equal to \u03b5 and r J 2 is either equal to \u03b5 or its body contains p, and so is not true under I . In any case, I is a C-model of both rJ1 and r J 2 , so \u3008I, J\u3009 is an SE-model of both r1 and r2. On the other hand, if p is true under J , then J is a C-model of r1 if and only if it is a C-model of r2 because the extra literal \u223ca in the head of r1 cannot be satisfied. Also, rJ1 is identical to r J 2 , so I is a C-model of r J 1 if and only if it is a C-model of r J 2 . Consequently, \u3008I, J\u3009 is an SE-model of r1 if and only if it is an SE-model of r2. Thus, we have proven that every SE-interpretation is an SE-model of r1 if and only if it is an SE-model of r2. In other words, r1 and r2 are SE-equivalent. \u2293\u2294\nLemma 3. Let H and B be sets of literals and L be a literal. Then rules of the following forms are SE-equivalent:\nH ;\u223cL \u2190 L,B. H \u2190 L,B. (4)\nProof. Follows from Lemmas 23 and 24. \u2293\u2294\nLemma 4. Let H\u2212 be a set of negative literals, B be a set of literals and p be an atom. Then rules of the following forms are SE-equivalent:\n\u223cp;H\u2212 \u2190 B. H\u2212 \u2190 p,B.\nProof. Let the first rule be denoted by r1 and the second by r2. Suppose \u3008I, J\u3009 is some SE-interpretation. If p is false under J , then J is a C-model of both r1 and r2. Furthermore, rJ1 is equal to \u03b5 and the body of r J 2 cannot be satisfied by I because I is a subset of J and p is not in J . Thus, I is a C-model of both rJ1 and r J 2 , and \u3008I, J\u3009 is an SE-model of both r1 and r2. On the other hand, if p is true under J , then we need to consider two cases:\na) If J is not a C-model of r1, then it also cannot be a C-model of r2 because, as can easily be verified, r1 is C-equivalent to r2. Hence, \u3008I, J\u3009 is an SE-model of neither r1 nor r2. b) If J is a C-model of r1, then it must also be a C-model of r2 because r1 is C-equivalent to r2. Furthermore, rJ1 and r J 2 are either both equal to \u03b5, or their heads are\nempty and rJ2 has the extra atom p in the body. In the latter case, if I were a model of the body of rJ1 , then J would be a model of the body of r1 but not of its head (which contains only negative literals), which contradicts the assumption that J is a model of r1. Thus, I is not a model of the body of rJ1 , so it cannot be a model of the body of rJ2 either. So I is a C-model of both r J 1 and r J 2 and \u3008I, J\u3009 is an SE-model of both r1 and r2.\nThus, we have proven that every SE-interpretation is an SE-model of r1 if and only if it is an SE-model of r2. In other words, r1 and r2 are SE-equivalent. \u2293\u2294\nTheorem 7. Every rule r is SE-equivalent to the canonical rule can(r).\nProof. This can be shown by a careful iterative application of Lemmas 2 to 4. First observe that if can(r) is equal to \u03b5, then by Lemma 2 the rule r is indeed SE-equivalent to \u03b5.\nIn the principal case we can use Lemma 23 on all atoms shared between the positive head and negative body of r and remove them one by one from the positive head of r while preserving SE-equivalence. Similar situation occurs with atoms shared between the negative head and positive body of r, which can be, according to Lemma 24, removed from the negative head of r while preserving SE-equivalence. After these steps are performed, we obtain the rule\n(H(r)+ \\B(r)\u2212);\u223c(H(r)\u2212 \\B(r)+) \u2190 B(r)+,\u223cB(r)\u2212. (5)\nThis is also the result of the defined transformation, unless the set H(r)+ \\ B(r)\u2212 is empty. In that case, one can repeatedly apply Lemma 4 to move the atoms from the negative head of rule (5) into its positive body. In this case, the transformation returns the canonical rule\n\u2190 (B(r)+ \u222aH(r)\u2212),\u223cB(r)\u2212. \u2293\u2294\nLemma 8. Let r be a rule. An SE-interpretation \u3008I, J\u3009 is not an SE-model of r if and only if the following conditions are satisfied:\n1. H(r)\u2212 \u222aB(r)+ \u2286 J and J \u2286 L \\B(r)\u2212. 2. Either J \u2286 L \\H(r)+ or both B(r)+ \u2286 I and I \u2286 L \\H(r)+.\nProof. Suppose first that the above conditions hold. We will show that \u3008I, J\u3009 is not an SE-model of r. Due to the first condition, rJ is equal to H(r)+ \u2190 B(r)+ and due to the second condition, either J is not a C-model of r, or I contains the body of rJ but does not contain any atom from its head, which means I is not a C-model of rJ . Consequently, \u3008I, J\u3009 is not an SE-model of r.\nNow suppose I, J are two interpretations such that the above conditions do not hold. We will show that \u3008I, J\u3009 is an SE-model of r. We need to consider the following four cases:\na) If J does not contain some atom from the negative head of r or it contains an atom from the negative body of r, then J is a C-model of r and rJ is \u03b5, so I is a C-model of rJ . Consequently, \u3008I, J\u3009 is an SE-model of r. b) If J does not contain some atom from the positive body of r, then J is a C-model of r and I is a C-model of rJ due to the fact that I is a subset of J . Consequently, \u3008I, J\u3009 is an SE-model of r. c) If J contains an atom from the positive head of r and I does not include the positive body of r, then J is a C-model of r and I is a C-model of rJ . Consequently, \u3008I, J\u3009 is an SE-model of r. d) If J contains some atom from the positive head of r and I also contains some atom from the positive head of r, then J is a C-model of r and I is a C-model of rJ . Consequently, \u3008I, J\u3009 is an SE-model of r. \u2293\u2294\nCorollary 25. Let r be a canonical rule different from \u03b5, put I = B(r)+, J = H(r)\u2212\u222a B(r)+ and J \u2032 = L \\B(r)\u2212, and let p be an atom. Then the following holds:\n(1) The SE-interpretation \u3008I, J\u3009 is not an SE-model of r. (2) The SE-interpretation \u3008I, J \u222a { p }\u3009 is an SE-model of r if and only if p belongs to\nB(r)\u2212. (3) The SE-interpretation \u3008I \u222a { p } , J \u222a { p }\u3009 is an SE-model of r if and only if p\nbelongs to H(r)+ \u222aB(r)\u2212. (4) The SE-interpretation \u3008I, J \u2032\u3009 is not an SE-model of r.\nProof. All parts of the Corollary easily follow from Lemma 8 and the disjointness properties satisfied by canonical rules. \u2293\u2294\nLemma 26. Let r be a canonical rule different from \u03b5 and S be the set of SE-models of r. An atom p belongs to B(r)\u2212 if and only if for all \u3008I, J\u3009 \u2208 ISE,\np \u2208 J implies \u3008I, J\u3009 \u2208 S . (CB\u2212)\nProof. Suppose p belongs to B(r)\u2212 and take some SE-interpretation \u3008I, J\u3009 such that p is in J . Then J is a C-model of r and rJ is equal to \u03b5, so I is a C-model of rJ . Hence, \u3008I, J\u3009 is an SE-model of r, and since the choice of \u3008I, J\u3009 was arbitrary, we conclude that p satisfies condition (CB\u2212).\nNow let I0 = B(r)+ and J0 = H(r)\u2212\u222aB(r)+ and suppose p is an atom satisfying condition (CB\u2212). Then the SE-interpretation \u3008I0, J0 \u222a { p }\u3009 must belong to S and by Corollary 25(2) we conclude that p belongs to B(r)\u2212. \u2293\u2294\nLemma 27. Let r be a canonical rule different from \u03b5 and S be the set of SE-models of r. An atom p belongs to H(r)+ if and only if it does not belong to B(r)\u2212 and for all \u3008I, J\u3009 \u2208 ISE,\np \u2208 I implies \u3008I, J\u3009 \u2208 S . (CH+ )\nProof. Suppose p belongs to H(r)+. Since r is a canonical rule, p does not belong to B(r)\u2212. Take some SE-interpretation \u3008I, J\u3009 such that p belongs to I . Then p must also belong to J , so J is a C-model of r and, for the same reason, I is a C-model of rJ . Consequently, \u3008I, J\u3009 is an SE-model of r. Since the choice of \u3008I, J\u3009 was arbitrary, we conclude that p satisfies condition (CH+ ).\nNow let I0 = B(r)+ and J0 = H(r)\u2212\u222aB(r)+ and suppose p is an atom satisfying condition (CH+ ). Then the SE-interpretation \u3008I0 \u222a { p } , J0 \u222a { p }\u3009 must belong to S and by Corollary 25(3) we conclude that p belongs to H(r)+ \u222a B(r)\u2212. Moreover, by assumption we know that p does not belong to B(r)\u2212, so it belongs to H(r)+. \u2293\u2294\nLemma 9. An atom p belongs to B(r)\u2212 if and only if for all \u3008I, J\u3009 \u2208 ISE, the condition (CB\u2212) is satisfied.\nAn atom p belongs to H(r)+ if and only if it does not belong to B(r)\u2212 and for all \u3008I, J\u3009 \u2208 ISE, the condition (CH+ ) is satisfied.\nProof. Follows from Lemmas 26 and 27.\nLemma 28. Let r be a canonical rule different from \u03b5 and S be the set of SE-models of r. An atom p belongs to B(r)+ if and only if for all \u3008I, J\u3009 \u2208 ISE the following conditions are satisfied:\np /\u2208 J implies \u3008I, J\u3009 \u2208 S ; (CH\u2212 )\nJ \u2229H(r)+ 6= \u2205 and p /\u2208 I implies \u3008I, J\u3009 \u2208 S . (CB+ )\nProof. Suppose p belongs to B(r)+ and take some SE-interpretation \u3008I, J\u3009 such that p is not in J . Since I is a subset of J , we obtain p is not in I either. Hence, J is a C-model of r and I is a C-model of rJ and we conclude that \u3008I, J\u3009 is an SE-model of r. The choice of \u3008I, J\u3009 was arbitrary, so this implies that condition (CH\u2212 ) is satisfied for p.\nNow take some SE-interpretation \u3008I, J\u3009 such that J \u2229 H(r)+ 6= \u2205 and p is not in I . From the former it follows that J is a C-model of r and from the latter that I is a C-model of rJ . Thus, \u3008I, J\u3009 is an SE-model of r and since the choice of \u3008I, J\u3009 was arbitrary, we conclude that condition (CB+ ) holds for p.\nFor the converse implication, suppose p is an atom satisfying conditions (CH\u2212 ) and (CB+ ). We consider two cases:\n1. If H(r)+ is empty, then since r is canonical, we know that H(r)\u2212 is also empty. So according to Corollary 25(1), the SE-interpretation \u3008I0, J0\u3009, where I0 = J0 = B(r)+, does not belong to S. Furthermore, by condition (CH\u2212 ) we can conclude that \u3008I0 \\ { p } , J0 \\ { p }\u3009 belongs to S. Thus, J0 must be different from J0 \\{ p }, so p must belong to J0 = B(r)+. 2. If H(r)+ is nonempty, then it follows from Corollary 25(4) that the SE-interpretation \u3008I0, J0\u3009, where I0 = B(r)+ and J0 = L \\ B(r)\u2212, does not belong to S. We can also conclude that J contains some atom from H(r)+ because, since r is canonical, H(r)+ is disjoint from B(r)\u2212. Thus, by condition (CB+ ) we conclude that \u3008I0 \\ { p } , J0\u3009 belongs to S. Consequently, I0 must be different from I0\\{ p }, so p belongs to I0 = B(r)+. \u2293\u2294\nLemma 29. Let r be a canonical rule different from \u03b5 and S be the set of SE-models of r.An atom p belongs to H(r)\u2212 if and only if it does not belong to B(r)+ and for all \u3008I, J\u3009 \u2208 ISE,\np /\u2208 J implies \u3008I, J\u3009 \u2208 S . (CH\u2212 )\nProof. Suppose p is some atom from H(r)\u2212 and take some SE-interpretation \u3008I, J\u3009 such that p is not in J . Then J is a C-model of r and rJ is equal to \u03b5 so I is a C-model of rJ . Consequently, \u3008I, J\u3009 is an SE-model of r and since the choice of \u3008I, J\u3009 was arbitrary, we conclude that condition (CH\u2212 ) is satisfied for p.\nNow let I0 = B(r)+ and J0 = H(r)\u2212 \u222aB(r)+ and suppose p is an atom that does not belong to B(r)+ and it satisfies condition (CH\u2212 ). Corollary 25(1) guarantees that the SE-interpretation \u3008I0, J0\u3009 is not an SE-model of r. Furthermore, from condition (CH\u2212 ) we obtain that the SE-interpretation \u3008I0 \\ { p } , J0 \\ { p }\u3009 belongs to S. Thus, J0 must differ from J0 \\ { p }, which implies that p belongs to J0. Furthermore, since J0 = H(r)\n\u2212 \u222a B(r)+ and p does not belong to B(r)+, we conclude that p belongs to H(r)\u2212. \u2293\u2294\nLemma 10. An atom p belongs to B(r)+ if and only if for all \u3008I, J\u3009 \u2208 ISE, the conditions (CH\u2212 ) and (CB+ ) are satisfied.\nAn atom p belongs to H(r)\u2212 if and only if it does not belong to B(r)+ and for all \u3008I, J\u3009 \u2208 ISE, the condition (CH\u2212 ) is satisfied.\nProof. Follows from Lemmas 28 and 29.\nTheorem 12. For every canonical rule r, rule(modSE (r)) = r.\nProof. If r is equal to \u03b5, then modSE (r) = ISE and by Definition 11, the rule rule(ISE) is equal to \u03b5 so the identity is satisfied.\nIn the principal case, r is a canonical rule different from \u03b5. Let S be the set of SE-models of r. It follows from Definition 11 and Lemmas 26 to 29 that r = rule(S).\n\u2293\u2294\nLemma 30. Let S be a set of SE-interpretations different from ISE. Then the sets of H(S)+ \u222aH(S)\u2212, B(S)+ and B(S)\u2212 are pairwise disjoint.\nProof. Suppose that p is a member of both H(S)+\u222aH(S)\u2212 and B(S)+. Then, since p is an S-positive-body atom, it cannot be an S-negative-head atom by definition. Thus, p belongs to both H(S)+ and B(S)+. We will show that this is impossible given our assumption that S is different from ISE. Take an arbitrary SE-interpretation \u3008I, J\u3009. If p belongs to I , then since p is an S-positive-head atom, \u3008I, J\u3009 belongs to S. If p does not belong to I but it belongs to J , then J contains the S-positive-head atom p, so since p is an S-positive-body atom, \u3008I, J\u3009 belongs to S. Finally, if p does not belong to J , then since p is an S-positive-body atom, \u3008I, J\u3009 belongs to S. This means that S must contain all SE-interpretations and is in conflict with our assumption.\nNow suppose that p is a member of both H(S)+ \u222aH(S)\u2212 and B(S)\u2212. Then, since p is an S-negative-body atom, it cannot be an S-positive-head atom by definition. Thus, p belongs to both H(S)\u2212 and B(S)\u2212. We will show that this is impossible given our assumption that S is different from ISE. Take an arbitrary SE-interpretation \u3008I, J\u3009. If p belongs to J , then since p is an S-negative-body atom, \u3008I, J\u3009 belongs to S. On the other hand, if p does not belong to J , then since p is an S-negative-head atom, \u3008I, J\u3009 belongs to S. This means that S must contain all SE-interpretations and is in conflict with our assumption to the contrary.\nNext, suppose that p is a member of both B(S)+ and B(S)\u2212. By the same arguments as in the previous case, this implies that S must be equal to ISE, contrary to the assumption.\nLemma 31. For every set of SE-interpretations S, rule(S) is a canonical rule.\nProof. If S is equal to ISE, then rule(S) is equal to the canonical rule \u03b5 and the proof is finished. Otherwise, rule(S) is of the form\nH(S)+;\u223cH(S)\u2212 \u2190 B(S)+,\u223cB(S)\u2212.\nTo show that this rule is canonical, we need to prove that the following conditions are satisfied:\n1. The sets H(S)+ \u222aH(S)\u2212, B(S)+ and B(S)\u2212 are pairwise disjoint. 2. If H(S)+ is empty, then H(S)\u2212 is also empty.\nThe first condition follows from Lemma 30. To prove the second condition, suppose H(S)+ is empty. Then by definition B(S)+ contains all atoms whose absence in J implies that \u3008I, J\u3009 belongs to S. By definition, then, H(S)\u2212 stays empty. \u2293\u2294\nLemma 16. The set of all SE-models of a canonical rule r is the least among all sets of SE-interpretations S such that rule(S) = r.\nProof. Let r be a canonical rule with the set of SE-models Sr. From Theorem 12 we know that rule(Sr) = r, so it remains to show that Sr is a subset of every set of SE-interpretations S such that rule(S) = r. Take one such S. In case r is the canonical tautology p\u03b5 \u2190 p\u03b5, it follows that H(S)+ = B(S)+ = { p\u03b5 }. According to Lemma 30, this is possible only in case S = ISE = Sr, so it trivially holds that Sr is a subset of S.\nIn the principal case, r is different from the canonical tautology, so S must be different from ISE and from rule(S) = r we obtain that H(r)+ = H(S)+, H(r)\u2212 = H(S)\u2212, B(r)+ = B(S)+ and B(r)\u2212 = B(S)\u2212. Let \u3008I, J\u3009 be an SE-model of r. Then one of the conditions of Lemma 8 must be violated. We distinguish the following four possible violations:\na) If H(S)\u2212\u222aB(S)+ * J , then J does not contain some atom fromH(S)\u2212\u222aB(S)+. From the definitions of S-negative-head atoms and S-positive-body atoms we then obtain that \u3008I, J\u3009 belongs to S. b) If J * L \\ B(S)\u2212, then J contains some atom from B(S)\u2212. From the definition of S-negative-body atoms we then infer that \u3008I, J\u3009 belongs to S. c) If J * L \\H(S)+ and B(S)+ * I , then J contains some atom from H(S)+ and I does not contain some atom from B(S)+. By the definition of S-positive-body atoms, \u3008I, J\u3009 belongs to S. d) If J * L \\H(S)+ and I * L \\H(S)+, then I contains some atom from H(S)+. By the definition of S-positive-head atoms, \u3008I, J\u3009 belongs to S. \u2293\u2294\nProposition 32. A set of SE-interpretations S is rule-representable if and only if all SE-interpretations from S are SE-models of rule(S).\nProof. If S is a rule-representable set of SE-interpretations, then there exists some rule r such that S = modSE (r). Let r\u2032 be the canonical rule can(r). According to Theorem 7, S = modSE (r\u2032), and so Theorem 12 implies that rule(S) = rule(modSE (r\u2032)) = r\u2032. Thus, all SE-interpretations from S are SE-models of rule(S).\nOn the other hand, if all SE-interpretations in S are SE-models of the rule r = rule(S), then S is a subset of modSE (r). Also, by Lemma 31 it follows that r is canonical and so Lemma 16 implies that modSE (r) is a subset of S. Consequently, S = modSE (r). \u2293\u2294\nProposition 33. A set of SE-interpretations S is rule-representable if and only if there exist convex sublattices L1, L2 of \u3008I,\u2286\u3009 such that the complement of S relative to ISE is equal to {\n\u3008I, J\u3009 \u2208 ISE \u2223 \u2223 I \u2208 L1 \u2227 J \u2208 L2 } \u222a { \u3008I, J\u3009 \u2208 ISE \u2223 \u2223 J \u2208 L1 \u2229 L2 } .\nProof. Suppose that S is a rule-representable set of SE-interpretations. Then there exists some rule r such that S = modSE (r). Let the sets of interpretations L1, L2 be defined as follows:\nL1 = { I \u2208 I \u2223 \u2223 B(r)+ \u2286 I \u2286 L \\H(r)+ } L2 = { J \u2208 I \u2223 \u2223 H(r)\u2212 \u222aB(r)+ \u2286 J \u2286 L \\B(r)\u2212 }\nIt can be straightforwardly verified that these sets are convex sublattices of \u3008I,\u2286\u3009. It remains to prove that the complement of S relative to ISE is equal to the set of SE-interpretations\n{ \u3008I, J\u3009 \u2208 ISE \u2223 \u2223 I \u2208 L1 \u2227 J \u2208 L2 } \u222a { \u3008I, J\u3009 \u2208 ISE \u2223 \u2223 J \u2208 L1 \u2229 L2 } . (6)\nAccording to Lemma 8, an SE-interpretation \u3008I, J\u3009 does not belong to S if and only if these two conditions are satisfied:\n1. H(r)\u2212 \u222aB(r)+ \u2286 J and J \u2286 L \\B(r)\u2212. 2. Either J \u2286 L \\H(r)+ or both B(r)+ \u2286 I and I \u2286 L \\H(r)+.\nIt is not difficult to see that whenever the first condition and first disjunct of the second condition are satisfied, \u3008I, J\u3009 belongs to the second part of the set (6). Similarly, the first condition together with the second disjunct of the second condition imply that \u3008I, J\u3009 belongs to the first part of the set (6). Conversely, given the definitions of L1 and L2, it is easy to see that any SE-interpretation belonging to the set (6) satisfies the conditions of Lemma 8. Thus, the set (6) coincides with the complement of S relative to ISE.\nNow suppose that L1, L2 are two convex sublattices of \u3008I,\u2286\u3009 such that the complement of S relative to ISE is equal to the set (6). Let \u22a41, \u22a51 be the top and bottom elements of L1 and \u22a42, \u22a52 be the top and bottom elements of L2. Furthermore, let r be a rule of the form\nH+;\u223cH\u2212 \u2190 B+,\u223cB\u2212.\nwhere H+ = L \\ \u22a41, H\u2212 = \u22a52, B+ = \u22a51 and B\u2212 = L \\ \u22a42. We will show that S = modSE (r).\nSuppose first that the SE-interpretation \u3008I, J\u3009 is not an SE-model of r. Then, by Lemma 8, J includes H\u2212\u222aB+ = \u22a52\u222a\u22a51 and J is included in L\\B\u2212 = L\\(L\\\u22a42) = \u22a42. By convexity of L2 we now obtain that J belongs to L2. Lemma 8 also implies that either J is included in L \\ H+ = \u22a41, or I includes B+ = \u22a51 and is included in L \\H+ = \u22a41. The convexity of L1 now implies that in the former case J belongs to L1, while in the latter case I belongs L1. In any of these cases, \u3008I, J\u3009 is a member of the set (6).\nNow let \u3008I, J\u3009 be some SE-interpretation not belonging to S. If \u3008I, J\u3009 belongs to the first part of the set (6), then \u22a51 \u2286 I \u2286 \u22a41 and \u22a52 \u2286 J \u2286 \u22a42. Thus, I includes B+ and is included in L \\ H+, and J includes H\u2212 and is included in L \\ B\u2212. Also, since I is a subset of J , J includes B+. Lemma 8 then implies that \u3008I, J\u3009 is not an SE-model of r. If \u3008I, J\u3009 belongs to the second part of the set (6), then \u22a51 \u2286 J \u2286 \u22a41 and \u22a51 \u2286 J \u2286 \u22a42. Thus, J includes both H\u2212 and B+ and is included in L \\ B\u2212 and in L \\H+. As a consequence of Lemma 8, \u3008I, J\u3009 is not an SE-model of r. \u2293\u2294\nTheorem 17. Let S be a set of SE-interpretations. Then the following conditions are equivalent:\n1. The set of SE-interpretations S is rule-representable. 2. All SE-interpretations from S are SE-models of rule(S). 3. There exist convex sublattices L1, L2 of \u3008I,\u2286\u3009 such that the complement of S rel-\native to ISE is equal to {\n\u3008I, J\u3009 \u2208 ISE \u2223 \u2223 I \u2208 L1 \u2227 J \u2208 L2 } \u222a { \u3008I, J\u3009 \u2208 ISE \u2223 \u2223 J \u2208 L1 \u2229 L2 } .\nProof. Follows from Propositions 32 and 33. \u2293\u2294\nTheorem 22. SU-equivalence is stronger than SR-equivalence, which itself is stronger than SMR-equivalence, which in turn is stronger than strong equivalence. That is,\n\u2261SU\u227b\u2261SR\u227b\u2261SMR\u227b\u2261S .\nProof. We first need to show that if two programs are SU-equivalent, they are also SR-equivalent, but the converse does not hold. Suppose P1, P2 are SU-equivalent programs. Then, according to Theorem 4.3 in [2], their symmetric difference (P1 \\ P2) \u222a (P2 \\ P1) contains only SE-tautological rules.2 To show that P1 is SR-equivalent to P2, suppose S is a set of SE-interpretations belonging to the set\n{modSE (r) | r \u2208 P1 \u222a { \u03b5 } } . (7)\nThen there exists some rule r with S = modSE (r) that either belongs to P1, or is SE-tautological. Furthermore, P1 = (P1 \u2229 P2) \u222a (P1 \\ P2), so r either belongs to P2, or it belongs to P1 \\ P2, or it is SE-tautological. But all rules from P1 \\ P2 are SE-tautological, so we can conclude that r either belongs to P2 or it is SE-tautological. Consequently, S belongs to the set\n{modSE (r) | r \u2208 P2 \u222a { \u03b5 } } . (8)\nA similar argument yields that the set (8) is a subset of the set (7). Consequently, the two sets are equal, so P1 is SR-equivalent to P2.\nTo see that the converse does not hold, take the programs P1 = {\u223cp \u2190 . } and P2 = {\u2190 p. }. It can be easily verified that they are SR-equivalent, but since their symmetric difference contains rules that are not SE-tautological, they are not SU-equivalent (according to Theorem 4.3 in [2]).\nNext, need to show that if two programs are SR-equivalent, they are also SMR-equivalent, but the converse does not hold. It can be immediately seen that\n{modSE (r) | r \u2208 P1 \u222a { \u03b5 } } = {modSE (r) | r \u2208 P2 \u222a { \u03b5 } }\nimplies\nmin {modSE (r) | r \u2208 P1 \u222a { \u03b5 } } = min {modSE (r) | r \u2208 P2 \u222a { \u03b5 } } ,\n2 The Theorem actually states that the symmetric difference contains only valid rules. A rule is valid, as defined in [2], if and only if it is SE-tautological.\nso the first part of the proof is finished. As for the second part, it suffices to consider programs P1 = { p. } and P2 = { p., p \u2190 q. } which are SMR-equivalent, but not SR-equivalent.\nFinally, we need to prove that if two programs are SMR-equivalent, they are also strongly equivalent, but not vice versa. So take some SMR-equivalent programs P1, P2. Then\nmin {modSE (r) | r \u2208 P1 \u222a { \u03b5 } } = min {modSE (r) | r \u2208 P2 \u222a { \u03b5 } } . (9)\nFurthermore,\nmodSE (P1) = \u22c2 {modSE (r) | r \u2208 P1 }\n= \u22c2 ( {modSE (r) | r \u2208 P1 } \u222a { ISE })\n= \u22c2\n{modSE (r) | r \u2208 P1 \u222a { \u03b5 } } ,\nand whenever some set of SE-interpretations S is non-minimal within\n{modSE (r) | r \u2208 P1 \u222a { \u03b5 } } , (10)\nthere exists some set of SE-interpretations T from (10) such that T ( S. Thus, T \u2229S = T , and so such non-minimal sets are irrelevant when determining the intersection of all sets in the set (10). Consequently,\nmodSE (P1) = \u22c2 min {modSE (r) | r \u2208 P1 \u222a { \u03b5 } } .\nBy similar arguments we obtain that\nmodSE (P2) = \u22c2 min {modSE (r) | r \u2208 P2 \u222a { \u03b5 } } .\nThus, (9) implies that P1 is strongly equivalent to P2. To see that the converse does not hold, consider programs P1 = { p., q. } and P2 = { p \u2190 q., q. }, which are strongly equivalent, but not SMR-equivalent. \u2293\u2294\nProposition 34. If S1,S2 are rule-representable sets of SE-models, then S1 \u222a S2 is also rule-representable.\nProof. Let LI1, L J 1 , L I 2, L J 2 be convex sublattices of \u3008I,\u2286\u3009 such that\nS1 = { \u3008I, J\u3009 \u2223 \u2223 I \u2208 LI1 \u2227 J \u2208 L J 1 } \u222a { \u3008I, J\u3009 \u2223 \u2223 J \u2208 LI1 \u2229 L J 1 } , S2 = { \u3008I, J\u3009 \u2223 \u2223 I \u2208 LI2 \u2227 J \u2208 L J 2 } \u222a { \u3008I, J\u3009 \u2223 \u2223 J \u2208 LI2 \u2229 L J 2 } .\nFurthermore, let S = S1 \u2229 S2 and\nLI = { I | (\u2203J \u2208 I)(\u3008J, J\u3009 /\u2208 S1 \u2229 S2 \u2227 \u3008I, J\u3009 \u2208 S1 \u2229 S2 }\nLJ = { J | (\u2203I \u2208 I)(\u3008I, J\u3009 \u2208 S1 \u2229 S2 }\nWe need to prove that LI , LJ are convex sublattices of \u3008I,\u2286\u3009 and that\nS = { \u3008I, J\u3009 \u2223 \u2223 I \u2208 LI \u2227 J \u2208 LJ } \u222a { \u3008I, J\u3009 \u2223 \u2223 J \u2208 LI \u2229 LJ } ."}], "references": [{"title": "Strongly equivalent logic programs", "author": ["Vladimir Lifschitz", "David Pearce", "Agust\u0131\u0301n Valverde"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2001}, {"title": "Equivalence of logic programs under updates", "author": ["Katsumi Inoue", "Chiaki Sakama"], "venue": "Proceedings of the 9th European Conference on Logics in Artificial Intelligence,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2004}, {"title": "REVISE: Logic programming and diagnosis", "author": ["Carlos Viegas Dam\u00e1sio", "Lu\u0131\u0301s Moniz Pereira", "Michael Schroeder"], "venue": "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1997}, {"title": "Dynamic updates of non-monotonic knowledge bases", "author": ["Jos\u00e9 J\u00falio Alferes", "Jo\u00e3o Alexandre Leite", "Lu\u0131\u0301s Moniz Pereira", "Halina Przymusinska", "Teodor C. Przymusinski"], "venue": "The Journal of Logic Programming,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2000}, {"title": "On properties of update sequences based on causal rejection", "author": ["Thomas Eiter", "Michael Fink", "Giuliana Sabbatini", "Hans Tompits"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2002}, {"title": "An abductive framework for computing knowledge base updates", "author": ["Chiaki Sakama", "Katsumi Inoue"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2003}, {"title": "Logic program-based updates", "author": ["Yan Zhang"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2006}, {"title": "The refined extension principle for semantics of dynamic logic programming", "author": ["Jos\u00e9 J\u00falio Alferes", "Federico Banti", "Antonio Brogi", "Jo\u00e3o Alexandre Leite"], "venue": "Studia Logica,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2005}, {"title": "A preference-based framework for updating logic programs", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits"], "venue": "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2007}, {"title": "Belief revision of logic programs under answer set semantics", "author": ["James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Stefan Woltran"], "venue": "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "A Program-Level Approach to Revising Logic Programs under the Answer Set Semantics", "author": ["James P. Delgrande"], "venue": "Theory and Practice of Logic Programming, 26th Int\u2019l. Conference on Logic Programming Special Issue,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2010}, {"title": "Belief Revision, chapter Belief Revision: An Introduction, pages 1\u201328", "author": ["Peter G\u00e4rdenfors"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 1992}, {"title": "On semantic update operators for answer-set programs", "author": ["Martin Slota", "Jo\u00e3o Leite"], "venue": "Proceedings of the 19th European Conference on Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2010}, {"title": "Towards a theory of declarative knowledge", "author": ["Krzysztof R. Apt", "Howard A. Blair", "Adrian Walker"], "venue": "In Foundations of Deductive Databases and Logic Programming,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1988}, {"title": "A classification theory of semantics of normal logic programs: II", "author": ["J\u00fcrgen Dix"], "venue": "Weak properties. Fundamenta Informaticae,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1995}, {"title": "Die Logik und das Grundlagenproblem", "author": ["Jan \u0141ukasiewicz"], "venue": "In Les Entretiens de Zu\u0308rich sue les Fondements et la me\u0301thode des sciences mathe\u0301matiques", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 1938}, {"title": "A new logical characterisation of stable models and answer sets", "author": ["David Pearce"], "venue": "Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1997}, {"title": "Strong equivalence made easy: nested expressions and weight constraints", "author": ["Hudson Turner"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2003}, {"title": "The stable model semantics for logic programming", "author": ["Michael Gelfond", "Vladimir Lifschitz"], "venue": "Proceedings of the 5th International Conference and Symposium on Logic Programming,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1988}, {"title": "Negation as failure in the head", "author": ["Katsumi Inoue", "Chiaki Sakama"], "venue": "Journal of Logic Programming,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 1998}, {"title": "Minimal logic programs", "author": ["Pedro Cabalar", "David Pearce", "Agust\u0131\u0301n Valverde"], "venue": "Proceedings of the 23rd International Conference on Logic Programming (ICLP 2007),", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2007}, {"title": "Introduction to Lattices and Order", "author": ["Brian A. Davey", "Hilary A. Priestley"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1990}], "referenceMentions": [{"referenceID": 0, "context": "Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.", "startOffset": 106, "endOffset": 109}, {"referenceID": 1, "context": "Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.", "startOffset": 152, "endOffset": 155}, {"referenceID": 0, "context": "With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].", "startOffset": 103, "endOffset": 106}, {"referenceID": 1, "context": "With this in mind, we briefly discuss two new notions of equivalence, stronger than strong equivalence [1] and weaker than strong update equivalence [2].", "startOffset": 149, "endOffset": 152}, {"referenceID": 2, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 3, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 4, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 5, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 6, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 7, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 8, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 9, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 10, "context": "Examples that enjoy these characteristics include the numerous approaches that deal with dynamics of logic programs, where inconsistencies between older and newer knowledge need to be resolved by \u201csacrificing\u201d parts of an older program (such as in [3\u201311]).", "startOffset": 248, "endOffset": 254}, {"referenceID": 11, "context": "Moreover, such a more semantic approach could facilitate the establishment of bridges with the area of Belief Change (see [12] for an introduction), and benefit from the many years of research where semantic change operations on monotonic logics have been studied, desirable properties for such operations have been identified, and constructive definitions of operators satisfying these properties have been introduced.", "startOffset": 122, "endOffset": 126}, {"referenceID": 3, "context": "However, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand.", "startOffset": 57, "endOffset": 64}, {"referenceID": 12, "context": "However, as has repeatedly been argued in the literature [4, 13], fully semantic methods do not seem to be appropriate for the task at hand.", "startOffset": 57, "endOffset": 64}, {"referenceID": 3, "context": "Though their definition and analysis is technically possible and leads to very elegant and seemingly desirable properties, there are a number of simple examples for which these methods fail to provide results that would be in line with basic intuitions [4].", "startOffset": 253, "endOffset": 256}, {"referenceID": 12, "context": "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.", "startOffset": 18, "endOffset": 22}, {"referenceID": 13, "context": "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.", "startOffset": 249, "endOffset": 257}, {"referenceID": 14, "context": "Also, as shown in [13], these individual problems follow a certain pattern: intuitively, any purely semantic approach to logic program updates satisfying a few very straightforward and desirable properties cannot comply with the property of support [14, 15], which lies at the very heart of semantics for Logic Programs.", "startOffset": 249, "endOffset": 257}, {"referenceID": 0, "context": "\u2013 identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; \u2013 show how to reconstruct canonical rules from their sets of SE-models; \u2013 based on the above, characterise the sets of SE-interpretations that are representable by a single rule; \u2013 reveal connections between the set of SE-models of a rule and convex sublattices of the set of classical interpretations; \u2013 introduce two new notions of equivalence \u2013 stronger than strong equivalence [1] and weaker than strong update equivalence [2] \u2013 and argue that they are more suitable when rules are to be treated as first-class citizens.", "startOffset": 510, "endOffset": 513}, {"referenceID": 1, "context": "\u2013 identify a set of representatives of rule equivalence classes induced by the SE-model semantics, which we dub canonical rules; \u2013 show how to reconstruct canonical rules from their sets of SE-models; \u2013 based on the above, characterise the sets of SE-interpretations that are representable by a single rule; \u2013 reveal connections between the set of SE-models of a rule and convex sublattices of the set of classical interpretations; \u2013 introduce two new notions of equivalence \u2013 stronger than strong equivalence [1] and weaker than strong update equivalence [2] \u2013 and argue that they are more suitable when rules are to be treated as first-class citizens.", "startOffset": 556, "endOffset": 559}, {"referenceID": 15, "context": "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].", "startOffset": 50, "endOffset": 58}, {"referenceID": 16, "context": "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].", "startOffset": 50, "endOffset": 58}, {"referenceID": 17, "context": "The other is based on the logic of Here-and-There [16, 17], more accurately on a reformulation of the here-and-there semantics, called SE-model semantics, defined for rules [18].", "startOffset": 173, "endOffset": 177}, {"referenceID": 18, "context": "This second semantics is strictly more expressive than both classical models and the stable model semantics [19].", "startOffset": 108, "endOffset": 112}, {"referenceID": 19, "context": "Most of these results have already been formulated in various ways [20, 2, 21].", "startOffset": 67, "endOffset": 78}, {"referenceID": 1, "context": "Most of these results have already been formulated in various ways [20, 2, 21].", "startOffset": 67, "endOffset": 78}, {"referenceID": 20, "context": "Most of these results have already been formulated in various ways [20, 2, 21].", "startOffset": 67, "endOffset": 78}, {"referenceID": 1, "context": "4 in [2]; part i) of Lemma 2 in [21]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 20, "context": "4 in [2]; part i) of Lemma 2 in [21]).", "startOffset": 32, "endOffset": 36}, {"referenceID": 20, "context": "Lemma 3 (Consequence of (3) and (4) in Lemma 1 in [21]).", "startOffset": 50, "endOffset": 54}, {"referenceID": 19, "context": "10 in [20] and Corollary 1 in [21]).", "startOffset": 6, "endOffset": 10}, {"referenceID": 20, "context": "10 in [20] and Corollary 1 in [21]).", "startOffset": 30, "endOffset": 34}, {"referenceID": 20, "context": "This definition is closely related with the notion of a fundamental rule introduced in Definition 1 of [21].", "startOffset": 103, "endOffset": 107}, {"referenceID": 20, "context": "Lemma 8 (Different formulation of Theorem 4 in [21]).", "startOffset": 47, "endOffset": 51}, {"referenceID": 9, "context": "Moreover, for every well-defined set of SE-interpretations S there exists a program P such that S = modSE (P) [10].", "startOffset": 110, "endOffset": 114}, {"referenceID": 21, "context": "[22].", "startOffset": 0, "endOffset": 4}, {"referenceID": 3, "context": "These results can be used for example in the context of program updates to define an update semantics based on the rule rejection principle [4] and operating on sets of sets of SE-models.", "startOffset": 140, "endOffset": 143}, {"referenceID": 1, "context": "Related to this is the very strong notion of equivalence which was introduced in [2]:", "startOffset": 81, "endOffset": 84}, {"referenceID": 1, "context": "1 in [2]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 1, "context": "Two programs are strongly update equivalent only under very strict conditions \u2013 it is shown in [2] that two programs are SU-equivalent if and only if their symmetric difference contains only SE-tautological rules.", "startOffset": 95, "endOffset": 98}, {"referenceID": 1, "context": "The other notion of program equivalence introduced in [2], strong update equivalence on common rules, or SUC-equivalence, is incomparable in terms of strength to our new notions of equivalence.", "startOffset": 54, "endOffset": 57}, {"referenceID": 3, "context": "are usually considered to carry the same meaning, some existing work suggests that they should be treated differently \u2013 while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8].", "startOffset": 357, "endOffset": 363}, {"referenceID": 7, "context": "are usually considered to carry the same meaning, some existing work suggests that they should be treated differently \u2013 while the former rule gives a reason for atom p to become false whenever q is true, the latter rule simply states that the two atoms cannot be true at the same time, without specifying a way to resolve this situation if it were to arise [4, 8].", "startOffset": 357, "endOffset": 363}, {"referenceID": 15, "context": "Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17].", "startOffset": 261, "endOffset": 269}, {"referenceID": 16, "context": "Whenever this is important, either strong update equivalence is used, which is perhaps too sensitive to the syntax of rules, or a new characterisation of Answer-Set Programming needs to be discovered, namely one that is not based on the logic of Here-and-There [16, 17].", "startOffset": 261, "endOffset": 269}], "year": 2017, "abstractText": "Rules in logic programming encode information about mutual interdependencies between literals that is not captured by any of the commonly used semantics. This information becomes essential as soon as a program needs to be modified or further manipulated. We argue that, in these cases, a program should not be viewed solely as the set of its models. Instead, it should be viewed and manipulated as the set of sets of models of each rule inside it. With this in mind, we investigate and highlight relations between the SE-model semantics and individual rules. We identify a set of representatives of rule equivalence classes induced by SE-models, and so pinpoint the exact expressivity of this semantics with respect to a single rule. We also characterise the class of sets of SE-interpretations representable by a single rule. Finally, we discuss the introduction of two notions of equivalence, both stronger than strong equivalence [1] and weaker than strong update equivalence [2], which seem more suitable whenever the dependency information found in rules is of interest.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}