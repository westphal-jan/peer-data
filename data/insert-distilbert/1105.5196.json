{"id": "1105.5196", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-May-2011", "title": "Large-Scale Music Annotation and Retrieval: Learning to Rank in Joint Semantic Spaces", "abstract": "music prediction tasks range from predicting tags given a song or clip of audio, predicting the artists name track of the artist, or predicting related songs given a song, clip, artist name or tag. that is, we are interested in every semantic relationship between the different musical concepts in our database. in realistically sized databases, the number of songs is measured in the hundreds of thousands or more, and the number thousand of artists compiled in precisely the tens of thousands or more, providing a computational considerable challenge to designing standard machine learning techniques. in this work, we propose a method that scales to such datasets which attempts to capture essentially the semantic similarities between surrounding the database items by modeling corresponding audio, calculating artist names, and tags in a single low - dimensional semantic space. this rigorous choice of space is learnt by optimizing the baseline set of prediction tasks of various interest jointly using multi - task learning. our method both physically outperforms baseline methods and, in comparison to all them, is faster and consumes less memory. we then demonstrate how reading our method correctly learns an alternative interpretable model, where the semantic resource space space captures well the similarities of interest.", "histories": [["v1", "Thu, 26 May 2011 03:41:47 GMT  (52kb,S)", "http://arxiv.org/abs/1105.5196v1", null]], "reviews": [], "SUBJECTS": "cs.LG", "authors": ["jason weston", "samy bengio", "philippe hamel"], "accepted": false, "id": "1105.5196"}, "pdf": {"name": "1105.5196.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Philippe Hamel", "Jason Weston", "Samy Bengio"], "emails": ["jweston@google.com", "bengio@google.com", "hamelphi@google.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n10 5.\n51 96\nv1 [\ncs .L\nG ]\n2 6\nM ay"}, {"heading": "1 Introduction", "text": "Users of software for annotating, retrieving and suggesting music are interested in a variety of tools that are all more or less related to the semantic interpretation of the audio, as perceived by the human listener. Such tasks include: (i) suggesting the next song to play given either one or many previously played songs, possibly with a set of ratings provided by the user, (ii) suggesting an artist to discover who is previously unknown to the user, given a set of rated artists, albums or songs (iii) browsing or searching by genre, style or mood. Several well known systems such as iTunes, www.pandora.com or www.lastfm.com are attempting to perform these tasks.\nThe audio itself for these tasks, in the form of songs, can easily be counted in the hundreds of thousands or more, and the number of artists in the tens of thousands or more in a large scale system. We might note that such data exhibits a typical \u201clong tail\u201d distribution where a small number of artists are very popular. For these artists one can collect lots of labeled data in the form of user plays, ratings and tags, while for the remaining large number of artists one has significantly less information (which we will refer to as \u201cdata sparsity\u201d). At the extreme, users may have audio in their collection that was made by a local\nband or by themselves for which no other information is known (ratings, genres, or even the artist name). All one has in that case is the audio itself. Yet still, one may be interested in all the tasks described above with respect to these songs.\nIn this paper we describe a single unified model that can solve all the tasks described above in a large scale setting. The final model is lightweight in terms of memory usage, and provides reasonably fast test times, and hence could readily be used in a real system. The model we consider learns to represent audio, tags, and artist names jointly in a single low-dimensional embedding space. The lowdimension means our model has small capacity and we argue that this helps to deal with the problem of data sparsity. Simultaneously, the small number of parameters means that the memory usage is low.\nTo build a unified model, all of our tasks are trained jointly via multi-tasking, sharing the same embedding space, i.e. the same model parameters. In order to do that, we use a recently developed embedding algorithm [1], which was applied to a vision task, and extend it to perform multi-tasking (and apply it to the music annotation and retrieval domain). For each task, the parameters of the model that embed the entities of interest into the low dimensional space are learnt in order to optimize the criterion of interest, which is the precision at k of the ranked list of retrieved entities. Typically, the tasks aim to learn that particular entities (e.g. audio and tags) should be close to each other in the embedding space. Hence, the distances in the embedding space can then be used for annotation or providing similar entities.\nThe model that we learn exhibits strong performance on all the tasks we tried, outperforming the baselines, and we also show that by multi-tasking all the tasks together the performance of our model improves. We argue that the reason for this improvement is that all of the tasks rely on the same semantic understanding of audio, artists and tags, and hence learning them together provides more information for each task. Finally, we show that the model indeed learns a rich semantic structure by visualizing the learnt embedding space. Semantically consistent entities appear close to each other in the embedding space.\nThe structure of the rest of the paper is as follows. Section 2 defines the tasks that we will consider. Section 3 describes the joint embedding model that we will employ, and Section 4 describes how to train (i.e., learn the parameters of) this model. Section 5 details prior related work, Section 6 describes our experiments, and Section 7 concludes."}, {"heading": "2 Music Annotation and Retrieval Tasks", "text": "Task Definitions: In this work, we focus on being able to solve the following annotation and retrieval tasks:\n1. Artist prediction: Given a song or audio clip (not seen at training time), return a ranked list of the likely artists to have performed it. 2. Song prediction: Given an artist\u2019s name, return a ranked list of songs (not seen at training time) that are likely to have been performed by that artist.\n3. Similar Artists: Given an artist\u2019s name, return a ranked list of artists that are similar to that artist. Training data may or may not be provided for this task. 4. Similar Songs: Given a song or audio clip (not seen at training time), return a ranked list of songs that are similar to it. 5. Tag prediction: Given a song or audio clip (not seen at training time), return a ranked list of tags (e.g. rock, guitar, fast, . . . ) that might best describe the song.\nEvaluation: In all cases, when a ranked list is returned we are interested in the correctness of the top of the ranked list, e.g. in the first k \u2248 15 positions. For this reason, we measure the precision@k for various small values of k:\nprecision@k = number of true positives in the top k positions\nk .\nDatabase: We suppose we are given a database containing artist names, songs (in the form of features corresponding to their audio content), and tags. We will denote our training data as triplets of the following form:\nD = {(ai, ti, si)}i=1,...,m \u2208 {1, . . . , |A|} |ai| \u00d7 {1, . . . , |T |}|ti| \u00d7 R|S|,\nwhere each triplet represents a song indexed by i: ai are the artist features, ti are the tag features and si are the audio (sound) features.\nEach song has attributed to it a set of artists ai, where each artist is indexed from 1 to |A| (indices into a dictionary of artist names). Hence, a given song can have multiple artists, although it usually only has one and hence |ai| = 1. Similarly, each song may also have a corresponding set of tags ti, where each tag is indexed from 1 to |T | (indices into a dictionary of tags).\nThe audio of the song itself is represented as an |S|-dimensional real-valued feature vector si. In this work we do not focus on developing novel feature representations for audio (instead, we will develop learning algorithms that use these features). Hence, we will use standard feature representations that can be found in the literature. More details on the features we use to represent audio are given in Section 6.2."}, {"heading": "3 Semantic Embedding Model for Music Understanding", "text": "The core idea in our model is that songs, artists and tags attributed to music can all be reasoned about jointly by learning a single model to capture the semantics of, and hence the relationships between, each of these musical concepts.\nOur method makes the assumption that these semantic relationships can be modeled in a feature space of dimension d, where musical concepts (songs, artists or tags) are represented as coordinate vectors. The similarity between two concepts is measured using the dot product between their two vector representations. The vectors will be learnt to induce similarities relevant (i.e. optimize the precision@k metric) for the tasks defined in Section 2.\nFor a given artist, indexed by j \u2208 1, . . . , |A|, its coordinate vector is expressed as:\n\u03a6Artist(i) : {1, . . . , |A|} \u2192 R d = Ai.\nwhere A = [A1, . . . , A|A|] is a d \u00d7 |A| matrix of the parameters (vectors) of all the artists in the database. This entire matrix will be learnt during the learning phase of the algorithm.\nSimilarly, for a given tag, indexed by j \u2208 1, . . . , |T |, its coordinate vector is expressed as:\n\u03a6Tag(i) : {1, . . . , |T |} \u2192 R d = Ti.\nwhere T = [T1, . . . , T|T |] is a d \u00d7 |T | matrix of the parameters (vectors) of all the tags in the database. Again, this entire matrix will also be learnt during the learning phase of the algorithm.\nFinally, for a given song or audio clip we consider the following function that maps its audio features s\u2032 to a d-dimensional vector using a linear transform V :\n\u03a6Song(s \u2032) : R|S| \u2192 Rd = V s\u2032.\nThe d\u00d7 |S| matrix V will also be learnt. We also choose for our family of models to have constrained norm:\n||Ai||2 \u2264 C, i = 1, . . . , |A|, (1)\n||Ti||2 \u2264 C, i = 1, . . . , |T |, (2)\n||Vi||2 \u2264 C, i = 1, . . . , |S|, (3)\nusing the hyperparameter C which will act as a regularizer in a similar way as used in lasso [2].\nOur overall goal is, for a given input, to rank the possible outputs of interest depending on the task (see Section 2 for the list of tasks) such that the highest ranked outputs are the best semantic match for the input. For example, for the artist prediction task, we consider the following ranking function:\nfArtistPredi (s \u2032) = fAPi (s \u2032) = \u03a6Artist(i) \u22a4\u03a6Song(s \u2032) = A\u22a4i V s \u2032 (4)\nwhere the possible artists i \u2208 {1, . . . , |A|} are ranked according to the magnitude of fi(x), largest first. Similarly, for song prediction, similar artists, similar songs and tag prediction we have the following ranking functions:\nfSongPreds\u2032 (i) = f SP s\u2032 (i) = \u03a6Song(s \u2032)\u22a4\u03a6Artist(i) = (V s \u2032)\u22a4Ai (5)\nfSimArtistj (i) = f SA j (i) = \u03a6Artist(j) \u22a4\u03a6Artist(i) = A \u22a4 j Ai (6)\nfSimSongs\u2032 (s \u2032\u2032) = fSSs\u2032 (s \u2032\u2032) = \u03a6Song(s \u2032)\u22a4\u03a6Song(s \u2032\u2032) = (V s\u2032)\u22a4V s\u2032\u2032 (7)\nfTagPredi (s \u2032) = fTPi (s \u2032) = \u03a6Tag(i) \u22a4\u03a6Song(s \u2032) = T\u22a4i V s \u2032. (8)\nNote that many of these tasks share the same parameters, for example the song prediction and similar artist tasks share the matrix A whereas the tag prediction and song prediction tasks share the matrix V . As we shall see, it is possible to learn the parameters A, T and V of our model jointly to perform well on all our tasks, which is referred to as multi-task learning [3]. In the next section we describe how we train our model."}, {"heading": "4 Training the Semantic Embedding Model", "text": "During training, our objective is to learn the parameters of our model that provide good ranking performance on the training set, using the precision at k measure (with the overall goal that this also generalizes to performing well on our test data, of course). We want to achieve this simultaneously for all the tasks at once using multi-task learning."}, {"heading": "4.1 Multi-Task Training", "text": "Let us suppose we define the objective function for a given task as \u2211\ni err(f(xi), yi) where x is the set of input examples, and y are the set of targets for these examples, and err is a loss function that measures the quality of a given ranking (the exact form of this function will be discussed in Section 4.2).\nIn the case of the tag prediction task we wish to minimize the function \u2211\ni err(f TP (si), ti) and for the artist prediction task we wish to minimize the\nfunction \u2211 i err(f AP (si), ai). To multi-task these two tasks we simply consider the (unweighted) sum of the two objectives:\nerrAP+TP (D) = m \u2211\ni=1\nerr(fAP (si), ai) + m \u2211\ni=1\nerr(fTP (si), ti).\nWe will optimize this function by stochastic gradient descent [4]. This amounts to iteratively repeating the following procedure [3]:\n1. Pick one of the tasks at random. 2. Pick one of the training input-output pairs for this task. 3. Make a gradient step for this task and input-output pair.\nThe procedure is the same when considering more than two tasks."}, {"heading": "4.2 Loss Functions", "text": "We consider two loss functions, the standard margin ranking loss and the newly introduced WARP (Weighted Approximately Ranked Pairwise) Loss [1].\nAUC Margin Ranking Loss A standard loss function that is often using for retrieval is the margin ranking criterion [5, 6], in particular it was used for text embedding models in [7]. Assuming the input x and output y (which can be replaced by artists, songs or tags, depending on the task) the loss is:\nerrAUC(D) =\nm \u2211\ni=1\n\u2211\nj\u2208yi\n\u2211\nk/\u2208yi\nmax(0, 1 + fk(xi)\u2212 fj(xi)) (9)\nwhich considers all pairs of positive and negative labels, and assigns each a cost if the negative label is larger or within a \u201cmargin\u201d of 1 from the positive\nlabel. Optimizing this loss is similar to optimizing the area under the curve of the receiver operating characteristic curve. That is, all pairwise violations are considered equally if they have the same margin violation, independent of their position in the list. For this reason the margin ranking loss might not optimize precision at k very accurately.\nWARP Loss To focus more on the top of the ranked list, where the top k positions are those we care about using the precision at k measure, one can weigh the pairwise violations depending on their position in the ranked list. This type of ranking error functions was recently developed in [8], and then used in an image annotation application in [1]. These works consider a class of ranking error functions:\nerrWARP (D) =\nm \u2211\ni=1\n\u2211\nj\u2208yi\nL(rank1j (f(xi))) (10)\nwhere rank1j (f(xi)) is the margin-based rank of the true label j \u2208 yi given by f(xi):\nrank1j (f(xi)) = \u2211\nk/\u2208yi\nI(1 + fk(xi) \u2265 fj(xi))\nwhere I is the indicator function, and L(\u00b7) transforms this rank into a loss:\nL(r) =\nr \u2211\ni=1\n\u03b1i, with \u03b11 \u2265 \u03b12 \u2265 \u00b7 \u00b7 \u00b7 \u2265 0. (11)\nDifferent choices of \u03b1 define different weights (importance) of the relative position of the positive examples in the ranked list. In particular:\n\u2013 For \u03b1i = 1 for all i we have the same AUC optimization as equation (9). \u2013 For \u03b11 = 1 and \u03b1i>1 = 0 the precision at 1 is optimized. \u2013 For \u03b1i\u2264k = 1 and \u03b1i\u2265k = 0 the precision at k is optimized. \u2013 For \u03b1i = 1/i a smooth weighting over positions is given, where most weight is\ngiven to the top position, with rapidly decaying weight for lower positions. This is useful when one wants to optimize precision at k for a variety of different values of k at once [8].\nWe will optimize this function by stochastic gradient descent following the authors of [1], that is samples are drawn at random, and a gradient step is made for that sample. As in that work, due to the cost of computing the exact rank in (10) it is approximated by sampling. That is, for a given positive label, one draws negative labels until a violating pair is found, and then approximates the rank with1\nrank1j (f(xi)) \u2248\n\u230a\nY \u2212 1\nN\n\u230b\n1 In fact, this gives a biased estimator of the rank, but as we are free to choose the vector \u03b1 in any case one could imagine correcting it by slightly adjusting the weights. In fact, the sampling process gives an unbiased estimator if we consider a\nAlgorithm 1 Muslse training algorithm.\nInput: labeled data for several tasks. Initialize model parameters (we use mean 0, standard deviation 1\u221a\nd ).\nrepeat\nPick a random task, and let f(x\u2032) = \u03a6Output(y \u2032)\u22a4\u03a6Input(x \u2032) be the prediction function for that task, and let x and y be its input and output examples, where there are Y possible output labels. Pick a random labeled example (xi, yi) (for the task chosen). Pick a random positive label j \u2208 yi for xi. Compute fj(xi) = \u03a6Output(j)\n\u22a4\u03a6Input(xi) Set N = 0. repeat\nPick a random negative label k \u2208 {1, . . . , Y } /\u2208 yi. Compute fk(xi) = \u03a6Output(k)\n\u22a4\u03a6Input(xi) N = N + 1.\nuntil fk(xi) > fj(xi)\u2212 1 or N \u2265 Y \u2212 1 if fk(xi) > fj(xi)\u2212 1 then\nMake a gradient step to minimize: L( \u230a\nY \u22121 N \u230b\n)|1\u2212 fj(xi) + fk(xi)|+ Project weights to enforce constraints (1)-(3).\nend if\nuntil validation error does not improve.\nwhere \u230a.\u230b is the floor function, Y is the number of output labels (which is task dependent, e.g. Y = |T | for the tag prediction task) and N is the number of trials in the sampling step. Intuitively, if we need to sample more negative labels before we find a violator, then the rank of the true label is likely to be small (it is likely to be at the top of the list, as few negatives are above it).\nPseudocode of training our method which we call Muslse (Music Understanding by Semantic Large Scale Embedding, pronounced \u201cmuscles\u201d) using the WARP loss is given in Algorithm 1. We use a fixed learning rate \u03b3, chosen using a validation set (a decaying schedule over time t is also possible, but we did not implement that approach). The validation error in the last line of Algorithm 1 is in practice evaluated every so often for computational efficiency.\nTraining Ensembles In our experiments, we will use the training schemes just described above for models of dimension d = 100. To train models with larger dimension we build an ensemble of several Muslse models. That is, for dimension d = 300 we would train three models. As we use stochastic gradient descent, each of the models will learn slightly different model parameters. When\nnew function L\u0303 instead of L in Equation (10), with:\nL\u0303(k) = E [ L (\u230a\nY \u22121 Nk\n\u230b)]\n.\nHence, this approach defines a slightly different ranking error.\naveraging their ranking scores, fensemblei (x) = f 1 i (x) + f 2 i (x) + f 3 i (x) for a given label i one can obtain improved results, as has been shown in [1] on vision tasks."}, {"heading": "5 Related Approaches", "text": "The task of automatically annotating music consists of assigning relevant tags to a given audio clip. Tags can represent a wide range of concepts such as genre (rock, pop, jazz, etc.), instrumentation (guitar, violon, etc.), mood (sad, calm, dark, etc.), locale (Seattle, NYC, Indian), opinions (good, love, favorite) or any other general attribute of the music (fast, eastern, wierd, etc.). A set of tags gives us a high-level semantic representation of a clip than can the be useful for other tasks such as music recommendation, playlist generation or music similarity measure. Most automatic annotation systems are built around the following recipe. First, features are extracted from the audio. These features often include MFCCs (section 6.2) and other spectral or temporal features. The features can also be learnt directly from the audio [9]. Then, these features are aggregated or summarized over windows of a given length, or over the whole clip. Finally, some machine learning algorithm is trained over these features in order to obtain a classifier for each tag. Often, the machine learning algorithm attempts to model the semantic relations between the tags [10]. A few state-of-the-art automatic annotation systems are briefly described in section 6.3. A more extensive review of the automatic tagging of audio is presented in [11].\nArtist and song similarity is at the core of most music recommendation or playlist generation systems. However, music similarity measures are subjective, which makes it difficult to rely on ground truth. This makes the evaluation of such systems more complex. This issue is addressed in [12] and [13].\nThese tasks can be tackled using content-based features or meta-data from human sources. Features commonly used to predict music similarity include audio features, tags and collaborative filtering information.\nMeta-data such as tags and collaborative filtering data have the advantage of considering human perception and opinions. These concepts are important to consider when building a music similarity space. However, meta-data suffers from a popularity bias, because a lot of data is available for popular music, but very little information can be found on new or less known artists. In consequence, in systems that rely solely upon meta-data, everything tends to be similar to popular artists. Another problem, known as the cold-start problem, arises with new artists or songs for which no human annotation exists yet. It is then impossible to get a reliable similarity measure, and is thus difficult to correctly recommend new or less known artists.\nContent-based features such as MFCCs, spectral features and temporal features have the advantage of being easily accessible, given the audio, and do not suffer from the popularity bias. However, audio features cannot take into account the social aspect of music. Despite this, a number of music similarity systems rely only on acoustic features [14, 15].\nIdeally, we would like to integrate those complementary sources of information in order to improve the performance of the similarity measure. Several systems such as [16, 17] combine audio content with meta-data. One way to do this is to embed songs or artists in a Euclidean space using metric learning [18].\nWe should also note that other related work (outside of the music domain) includes learning embeddings for supervised document ranking [7], semi-supervised multi-task learning [19, 20] and for vision tasks [21, 1]."}, {"heading": "6 Experiments", "text": ""}, {"heading": "6.1 Datasets", "text": "TagATune Dataset The TagATune dataset consists of a set of 30 second clips with annotations. Each clip is annotated with one or more descriptors, or tags, that represent concepts that can be associated with the given clip. The set of descriptors also include negative concepts (no voice, not classical, no drums, etc.). The annotations of the dataset were collected with the help of a web-based game. Details of how the data was collected are described in [22].\nThe TagATune dataset was used in the MIREX 2009 contest on audio tag classification [23]. In order to be able to compare our results with the MIREX 2009 contestants, we used the same set of tags and the same train/test split as in the contest.\nBig-data Dataset We had access to a large proprietary database of tracks and artists, from which we took a subset for this experimental study.\nWe processed this data similarly to TagATune. In this case we only considered using MFCC features (see Section 6.2). We evaluate the artist prediction, song prediction and song similarity tasks on this dataset. The test set (which is the same test set for all tasks) contains songs not previously seen in the training set.\nAs mentioned in section 5, it is difficult to obtain reliable ground truth for music similarity tasks. In our experiments, song similarity is evaluated by taking all songs by the same artist as a given query song as positives, and all other songs as negatives. We do not evaluate the similar artist task due to not having labeled data, however our model would be perfectly capable of working on this type of data as well.\nTable 1 provides summary statistics of the number of songs and labels for the TagATune and Big-data datasets used in our experiments."}, {"heading": "6.2 Audio Feature Representation", "text": "In this work we focus on learning algorithms, not feature representations. We used the well-knownMel Frequency Cepstral Coefficient (MFCC) representation. MFCCs take advantage of source/filter deconvolution from the cepstral transform and perceptually-realistic compression of spectra from the Mel pitch scale. They have been used extensively in the speech recognition community for many\nyears [24] and are also the de facto baseline feature used in music modeling (see for instance [25]). In particular, the MFCCs are known to offer a reasonable representation of the musical timbre [26]. In this paper, 13 MFCCs were extracted every 10ms over a hamming window of 25ms, and first and second derivatives were concatenated, for a total of 39 features. We then computed a dictionary of d = 2000 typical MFCC vectors over the training set (using K-means) and represented each song as a vector of counts, over the set of frames in the given song, of the number of times each dictionary vector was nearest to the frame in the MFCC space. The resulting feature vectors thus have dimension d = 2000 with an average of |S|\u00f8\u0304 = 1032 non-zero values. It takes on average 2 seconds to extract these features per song.\nOur second set of features, Stabilized Auditory Image (SAI) features are based on adaptive pole-zero filter cascade (PZFC) auditory filterbanks, followed by a sparse coding step similar to the one used for our MFCC features. They have been used successfully in audio retrieval tasks [27]. Our implementation yields a sparse representation of d = 7168 features with an average of |S|\u00f8\u0304 = 4000 non-zero values. It takes on average 6 seconds to extract these features per song. In our experiments, we consider using either MFCC features, or we use jointly the two sets of features by concatenating their respective vector representation (MFCC+SAI)."}, {"heading": "6.3 Baselines", "text": "We compare our proposed approach to the following baselines: one-versus-rest large margin classifiers (one-vs-rest) of the form fi(x) = w \u22a4 i x trained using the margin perceptron algorithm, which gives similar results to support vector machines [28]. The loss function for tag prediction in that case is:\nm \u2211\ni=1\n|T | \u2211\nj=1\nmax(0, 1\u2212 \u03c6(ti, j)fi(ai))\nwhere \u03c6(t\u2032, j) = 1 if j \u2208 t\u2032, and \u22121 otherwise. For the similar song task we compare to using cosine similarity in the feature space, a classical information retrieval baseline [29]. Additionally, on the TagATune dataset we compare to all the entrants of the MIREX 2009 competition [23]. The performance of the different models are described in detail at http://www.music-ir.org/mirex/wiki/2009:Audio_Tag_\nClassification_Tagatune_Results. All the algorithms in the competition follow more or less the same general pattern described in Section 5. We present here the results of the four best contestants: Marsyas [30], Mandel [31], Manzagol [32] and Zhi [33]. Every submission uses MFCCs as features, except for Mandel, which computes another kind of cepstral transform, quite similar to MFCCs. Furthermore, Mandel also uses a set of temporal features and Marsyas adds a set of spectral features: spectral centroid, rolloff and flux. All the submissions use a temporal aggregation of the features, though the methods used vary. The classification algorithms also varied.\nThe Marsyas algorithm uses running means and standard deviations of the features as input to a two-stage SVM classifier. The second stage SVM helps to capture the relations between tags. The Mandel submission uses balanced SVMs for each tag. In order to balance the training set for a given tag, a number equal to the number of positive examples is chosen at random in the non-positive examples to form the training set for that given tag. Manzagol uses vector quantization and applies an algorithm called PAMIR (passive-aggressive model for image retrieval) [5]. Finally, Zhi also uses Gaussian Mixture Models to obtain a song-level representation and uses a semantic multiclass labeling model."}, {"heading": "6.4 Results", "text": "TagATune Results The results of comparing all the methods on the tag prediction task on the TagATune data are summarized in Table 2. Muslse outperforms the one-vs-rest baseline that we ran using the same features, as well as the competition entrants on the TagATune dataset. Results of choosing different embedding dimensions d for Muslse are given in Table 5 and show that the performance is relatively stable over different choices of d, although we see slight improvements for larger d. We give a more detailed analysis of the results, including time and space requirements in subsequent sections.\nAUC via WARP loss We compared Muslse embedding models trained with either WARP or AUC optimization for different embedding dimensions and feature types. The results given in Table 3 show WARP gives superior precision @ k for all the parameters tried.\nTag Embeddings on TagATune Example tag embeddings learnt by Muslse for the TagATune data are given in Table 4. We observe that the embeddings capture the semantic structure of the tags (and note that songs are also embedded in this same space).\nMulti-Tasking Results on Big-data Results comparing Muslse with the one-vs-rest and cosine similarity baselines for Big-data are given in Table 6. All methods use MFCC features, and Muslse uses d = 100. Two flavors of Muslse are presented: training on one of the tasks alone, or all three tasks jointly. The results show that Muslse performs well compared to the baseline approaches and\nthat multi-tasking improves performance on all the tasks compared to training on a single task.\nComputational Expense A summary of the test time and space complexity of one-vs-rest compared to Muslse is given in Table 7 (not including cost of feature computation, see Section 6.2) as well as concrete numbers on our particular datasets using a single computer, and assuming the data fits in memory. One-vs-rest artist prediction takes around 2 seconds per song on the Big-data and requires 1.85 GB of memory. In contrast Muslse takes 0.045 seconds, and requires far less memory, only 27.7 MB. Muslse can be feasibly run on a laptop using limited resources whereas the memory requirements of one-vs-rest are rather high (and will be worse for larger database sizes). Muslse has a second advantage that it is not much slower at test time if we choose a larger and denser set of features, as it maps these features into a low dimensional embedding space and the bulk of the computation is then in that space."}, {"heading": "7 Conclusions", "text": "We have introduced a music annotation and retrieval model that works by jointly learning several tasks by mapping entities of various types (audio, artist names and tags) into a single low-dimensional space where they all live. This appears to give a number of benefits, specifically:\n(i) semantic similarities between all the entity types are learnt in the embedding space,\n(ii) by multi-tasking all the tasks sharing the same embedding space we do have data for, accuracy improves for all tasks,\n(iii) optimizing (approximately) the precision at k leads to improved performance, (iv) as the model has low-capacity this makes it harder to overfit on the tail of the distribution (where data is sparse),\n(v) the model is also fast at test time and has low memory usage.\nOur resulting model performed well compared to baselines on two datasets, and is scalable enough to use in a real-world system."}, {"heading": "8 Acknowledgements", "text": "We thank Doug Eck, Ryan Rifkin and Tom Walters for providing us with the Big-data set and extracting the relevant features on it."}], "references": [{"title": "Large scale image annotation: Learning to rank with joint word-image embeddings", "author": ["J. Weston", "S. Bengio", "N. Usunier"], "venue": "European conference on Machine Learning.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2010}, {"title": "Regression shrinkage and selection via the lasso", "author": ["R. Tibshirani"], "venue": "Journal of the Royal Statistical Society. Series B (Methodological) 58(1)", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1996}, {"title": "Multitask Learning", "author": ["R. Caruana"], "venue": "Machine Learning 28(1)", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1997}, {"title": "A stochastic approximation method", "author": ["H. Robbins", "S. Monro"], "venue": "Annals of Mathematical Statistics 22", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1951}, {"title": "A discriminative kernel-based model to rank images from text queries", "author": ["D. Grangier", "S. Bengio"], "venue": "Transactions on Pattern Analysis and Machine Intelligence 30(8)", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2008}, {"title": "Kernel methods for multi-labelled classification and categorical regression problems", "author": ["A. Elisseeff", "J. Weston"], "venue": "Advances in neural information processing systems 14", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2002}, {"title": "Polynomial semantic indexing", "author": ["B. Bai", "J. Weston", "D. Grangier", "R. Collobert", "K. Sadamasa", "Y. Qi", "C. Cortes", "M. Mohri"], "venue": "Advances in Neural Information Processing Systems (NIPS 2009).", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2009}, {"title": "Ranking with ordered weighted pairwise classification", "author": ["N. Usunier", "D. Buffoni", "P. Gallinari"], "venue": "In Bottou, L., Littman, M., eds.: Proceedings of the 26th International Conference on Machine Learning, Montreal, Omnipress", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2009}, {"title": "Learning features from music audio with deep belief networks", "author": ["P. Hamel", "D. Eck"], "venue": "ISMIR.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Learning to tag from open vocabulary labels", "author": ["E. Law", "B. Settles", "T. Mitchell"], "venue": "ECML.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "Automatic tagging of audio: The stateof-the-art", "author": ["T. Bertin-Mahieux", "D. Eck", "M. Mandel"], "venue": "In Wang, W., ed.: Machine Audition: Principles, Algorithms and Systems. IGI Publishing", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2010}, {"title": "A Large-Scale Evaluation of Acoustic and Subjective MusicSimilarity Measures", "author": ["A. Berenzweig"], "venue": "Computer Music Journal 28(2)", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "The quest for ground truth in musical artist similarity", "author": ["D.P.W. Ellis", "B. Whitman", "A. Berenzweig", "S. Lawrence"], "venue": "ISMIR.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2002}, {"title": "On the evaluation of perceptual similarity measures for music", "author": ["E. Pampalk", "S. Dixon", "G. Widmer"], "venue": "Intl. Conf. on Digital Audio Effects.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2003}, {"title": "Improvements of audio-based music similarity and genre classificaton", "author": ["E. Pampalk", "A. Flexer", "G. Widmer"], "venue": "ISMIR.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2005}, {"title": "Generating transparent, steerable recommendations from textual descriptions of items", "author": ["S.J. Green", "P. Lamere", "J. Alexander", "F. Maillet", "S. Kirk", "J. Holt", "J. Bourque", "X.W. Mak"], "venue": "RecSys.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2009}, {"title": "Anchor space for classification and similarity measurement of music", "author": ["A. Berenzweig", "D. Ellis", "S. Lawrence"], "venue": "ICME", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2003}, {"title": "Learning similarity in heterogeneous data", "author": ["B. McFee", "G. Lanckriet"], "venue": "MIR \u201910: Proceedings of the international conference on Multimedia information retrieval, New York, NY, USA, ACM", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2010}, {"title": "A framework for learning predictive structures from multiple tasks and unlabeled data", "author": ["R.K. Ando", "T. Zhang"], "venue": "JMLR 6", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2005}, {"title": "Unlabeled Data Improves Word Prediction", "author": ["N. Loeff", "A. Farhadi", "I. Endres", "D. Forsyth"], "venue": "ICCV \u201909", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2009}, {"title": "Dimensionality reduction by learning an invariant mapping", "author": ["R. Hadsell", "S. Chopra", "Y. LeCun"], "venue": "Proc. Computer Vision and Pattern Recognition Conference.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2006}, {"title": "Input-agreement: A new mechanism for data collection using human computation games", "author": ["E. Law", "L. von Ahn"], "venue": "CHI.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2009}, {"title": "Evaluation of algorithms using games: the case of music tagging", "author": ["E. Law", "K. West", "M. Mandel", "M. Bay", "J.S. Downie"], "venue": "Proceedings of the 10th International Conference on Music Information Retrieval (ISMIR).", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2009}, {"title": "Fundamentals of Speech Recognition", "author": ["L.R. Rabiner", "B.H. Juang"], "venue": "Prentice-Hall", "citeRegEx": "24", "shortCiteRegEx": null, "year": 1993}, {"title": "Content-based retrieval of music and audio", "author": ["J.T. Foote"], "venue": "SPIE.", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1997}, {"title": "Perceptual distance in timbre space", "author": ["H. Terasawa", "M. Slaney", "J. Berger"], "venue": "Proceedings of the International Conference on Auditory Display (ICAD05).", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2005}, {"title": "Sound retrieval and ranking using sparse auditory representations", "author": ["R.F. Lyon", "M. Rehn", "S. Bengio", "T.C. Walters", "G. Chechik"], "venue": "Neural Computation 22(9)", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2010}, {"title": "Large margin classification using the perceptron algorithm", "author": ["Y. Freund", "R.E. Schapire"], "venue": "In Shavlik, J., ed.: Machine Learning: Proceedings of the Fifteenth International Conference, San Francisco, CA, Morgan Kaufmann", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1998}, {"title": "Modern information retrieval", "author": ["R. Baeza-Yates", "B Ribeiro-Neto"], "venue": "AddisonWesley Harlow, England", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1999}, {"title": "Marsyas submissions to MIREX 2009", "author": ["G. Tzanetakis"], "venue": "MIREX 2009.", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2009}, {"title": "Multiple-instance learning for music information retrieval", "author": ["M. Mandel", "D. Ellis"], "venue": "Proc. Intl. Symp. Music Information Retrieval.", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2008}, {"title": "Mirex special tagatune evaluation submission", "author": ["P.A. Manzagol", "S. Bengio"], "venue": "MIREX 2009.", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2009}, {"title": "On the Use of Anti-WordModels for Audio Music Annotation and Retrieval", "author": ["Z.S. Chen", "J.S.R. Jang"], "venue": "IEEE Transactions on Audio, Speech, and Language Processing 17(8)", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "In order to do that, we use a recently developed embedding algorithm [1], which was applied to a vision task, and extend it to perform multi-tasking (and apply it to the music annotation and retrieval domain).", "startOffset": 69, "endOffset": 72}, {"referenceID": 1, "context": "using the hyperparameter C which will act as a regularizer in a similar way as used in lasso [2].", "startOffset": 93, "endOffset": 96}, {"referenceID": 2, "context": "As we shall see, it is possible to learn the parameters A, T and V of our model jointly to perform well on all our tasks, which is referred to as multi-task learning [3].", "startOffset": 166, "endOffset": 169}, {"referenceID": 3, "context": "We will optimize this function by stochastic gradient descent [4].", "startOffset": 62, "endOffset": 65}, {"referenceID": 2, "context": "This amounts to iteratively repeating the following procedure [3]:", "startOffset": 62, "endOffset": 65}, {"referenceID": 0, "context": "We consider two loss functions, the standard margin ranking loss and the newly introduced WARP (Weighted Approximately Ranked Pairwise) Loss [1].", "startOffset": 141, "endOffset": 144}, {"referenceID": 4, "context": "AUC Margin Ranking Loss A standard loss function that is often using for retrieval is the margin ranking criterion [5, 6], in particular it was used for text embedding models in [7].", "startOffset": 115, "endOffset": 121}, {"referenceID": 5, "context": "AUC Margin Ranking Loss A standard loss function that is often using for retrieval is the margin ranking criterion [5, 6], in particular it was used for text embedding models in [7].", "startOffset": 115, "endOffset": 121}, {"referenceID": 6, "context": "AUC Margin Ranking Loss A standard loss function that is often using for retrieval is the margin ranking criterion [5, 6], in particular it was used for text embedding models in [7].", "startOffset": 178, "endOffset": 181}, {"referenceID": 7, "context": "This type of ranking error functions was recently developed in [8], and then used in an image annotation application in [1].", "startOffset": 63, "endOffset": 66}, {"referenceID": 0, "context": "This type of ranking error functions was recently developed in [8], and then used in an image annotation application in [1].", "startOffset": 120, "endOffset": 123}, {"referenceID": 7, "context": "This is useful when one wants to optimize precision at k for a variety of different values of k at once [8].", "startOffset": 104, "endOffset": 107}, {"referenceID": 0, "context": "We will optimize this function by stochastic gradient descent following the authors of [1], that is samples are drawn at random, and a gradient step is made for that sample.", "startOffset": 87, "endOffset": 90}, {"referenceID": 0, "context": "averaging their ranking scores, f i (x) = f 1 i (x) + f 2 i (x) + f 3 i (x) for a given label i one can obtain improved results, as has been shown in [1] on vision tasks.", "startOffset": 150, "endOffset": 153}, {"referenceID": 8, "context": "The features can also be learnt directly from the audio [9].", "startOffset": 56, "endOffset": 59}, {"referenceID": 9, "context": "Often, the machine learning algorithm attempts to model the semantic relations between the tags [10].", "startOffset": 96, "endOffset": 100}, {"referenceID": 10, "context": "A more extensive review of the automatic tagging of audio is presented in [11].", "startOffset": 74, "endOffset": 78}, {"referenceID": 11, "context": "This issue is addressed in [12] and [13].", "startOffset": 27, "endOffset": 31}, {"referenceID": 12, "context": "This issue is addressed in [12] and [13].", "startOffset": 36, "endOffset": 40}, {"referenceID": 13, "context": "Despite this, a number of music similarity systems rely only on acoustic features [14, 15].", "startOffset": 82, "endOffset": 90}, {"referenceID": 14, "context": "Despite this, a number of music similarity systems rely only on acoustic features [14, 15].", "startOffset": 82, "endOffset": 90}, {"referenceID": 15, "context": "Several systems such as [16, 17] combine audio content with meta-data.", "startOffset": 24, "endOffset": 32}, {"referenceID": 16, "context": "Several systems such as [16, 17] combine audio content with meta-data.", "startOffset": 24, "endOffset": 32}, {"referenceID": 17, "context": "One way to do this is to embed songs or artists in a Euclidean space using metric learning [18].", "startOffset": 91, "endOffset": 95}, {"referenceID": 6, "context": "We should also note that other related work (outside of the music domain) includes learning embeddings for supervised document ranking [7], semi-supervised multi-task learning [19, 20] and for vision tasks [21, 1].", "startOffset": 135, "endOffset": 138}, {"referenceID": 18, "context": "We should also note that other related work (outside of the music domain) includes learning embeddings for supervised document ranking [7], semi-supervised multi-task learning [19, 20] and for vision tasks [21, 1].", "startOffset": 176, "endOffset": 184}, {"referenceID": 19, "context": "We should also note that other related work (outside of the music domain) includes learning embeddings for supervised document ranking [7], semi-supervised multi-task learning [19, 20] and for vision tasks [21, 1].", "startOffset": 176, "endOffset": 184}, {"referenceID": 20, "context": "We should also note that other related work (outside of the music domain) includes learning embeddings for supervised document ranking [7], semi-supervised multi-task learning [19, 20] and for vision tasks [21, 1].", "startOffset": 206, "endOffset": 213}, {"referenceID": 0, "context": "We should also note that other related work (outside of the music domain) includes learning embeddings for supervised document ranking [7], semi-supervised multi-task learning [19, 20] and for vision tasks [21, 1].", "startOffset": 206, "endOffset": 213}, {"referenceID": 21, "context": "Details of how the data was collected are described in [22].", "startOffset": 55, "endOffset": 59}, {"referenceID": 22, "context": "The TagATune dataset was used in the MIREX 2009 contest on audio tag classification [23].", "startOffset": 84, "endOffset": 88}, {"referenceID": 23, "context": "years [24] and are also the de facto baseline feature used in music modeling (see for instance [25]).", "startOffset": 6, "endOffset": 10}, {"referenceID": 24, "context": "years [24] and are also the de facto baseline feature used in music modeling (see for instance [25]).", "startOffset": 95, "endOffset": 99}, {"referenceID": 25, "context": "In particular, the MFCCs are known to offer a reasonable representation of the musical timbre [26].", "startOffset": 94, "endOffset": 98}, {"referenceID": 26, "context": "They have been used successfully in audio retrieval tasks [27].", "startOffset": 58, "endOffset": 62}, {"referenceID": 27, "context": "We compare our proposed approach to the following baselines: one-versus-rest large margin classifiers (one-vs-rest) of the form fi(x) = w \u22a4 i x trained using the margin perceptron algorithm, which gives similar results to support vector machines [28].", "startOffset": 246, "endOffset": 250}, {"referenceID": 28, "context": "For the similar song task we compare to using cosine similarity in the feature space, a classical information retrieval baseline [29].", "startOffset": 129, "endOffset": 133}, {"referenceID": 22, "context": "Additionally, on the TagATune dataset we compare to all the entrants of the MIREX 2009 competition [23].", "startOffset": 99, "endOffset": 103}, {"referenceID": 29, "context": "We present here the results of the four best contestants: Marsyas [30], Mandel [31], Manzagol [32] and Zhi [33].", "startOffset": 66, "endOffset": 70}, {"referenceID": 30, "context": "We present here the results of the four best contestants: Marsyas [30], Mandel [31], Manzagol [32] and Zhi [33].", "startOffset": 79, "endOffset": 83}, {"referenceID": 31, "context": "We present here the results of the four best contestants: Marsyas [30], Mandel [31], Manzagol [32] and Zhi [33].", "startOffset": 94, "endOffset": 98}, {"referenceID": 32, "context": "We present here the results of the four best contestants: Marsyas [30], Mandel [31], Manzagol [32] and Zhi [33].", "startOffset": 107, "endOffset": 111}, {"referenceID": 4, "context": "Manzagol uses vector quantization and applies an algorithm called PAMIR (passive-aggressive model for image retrieval) [5].", "startOffset": 119, "endOffset": 122}], "year": 2011, "abstractText": "Music prediction tasks range from predicting tags given a song or clip of audio, predicting the name of the artist, or predicting related songs given a song, clip, artist name or tag. That is, we are interested in every semantic relationship between the different musical concepts in our database. In realistically sized databases, the number of songs is measured in the hundreds of thousands or more, and the number of artists in the tens of thousands or more, providing a considerable challenge to standard machine learning techniques. In this work, we propose a method that scales to such datasets which attempts to capture the semantic similarities between the database items by modeling audio, artist names, and tags in a single low-dimensional semantic space. This choice of space is learnt by optimizing the set of prediction tasks of interest jointly using multi-task learning. Our method both outperforms baseline methods and, in comparison to them, is faster and consumes less memory. We then demonstrate how our method learns an interpretable model, where the semantic space captures well the similarities of interest.", "creator": "dvips(k) 5.98 Copyright 2009 Radical Eye Software"}}}