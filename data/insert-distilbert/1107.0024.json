{"id": "1107.0024", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2011", "title": "Complexity Results and Approximation Strategies for MAP Explanations", "abstract": "map is the problem of finding a most probable instantiation of a set of variables given evidence. map has always been perceived to be probably significantly harder indeed than the commonly related problems of computing the probability of a variable instantiation pr, or often the problem of computing the most probable explanation ( estimate mpe ). this paper investigates the complexity of map in bayesian networks. specifically, we clearly show that map is complete for np ^ pp and provide further negative complexity results for algorithms themselves based totally on variable closure elimination. we also show that map remains hard even when mpe and pr times become easy. for example, we show specifically that map is np - complete when the networks computation are restricted to polytrees, and whatever even information then can not be effectively approximated. besides given the difficulty of computing map exactly, and the difficulty of approximating map while providing useful guarantees on the general resulting approximation, we investigate best competitive effort method approximations. we introduce a generic map approximation framework. we provide two instantiations of the framework ; one for networks which are directly amenable to exact inference pr, and one for networks for which even exact inference is too hard. this allows map approximation on networks that are too complex to even exactly easily solve the easier problems, pr and estimate mpe. all experimental results indicate that using ajax these approximation algorithms provides much bit better theoretical solutions than standard techniques, and provide accurate feasible map estimates in many cases.", "histories": [["v1", "Thu, 30 Jun 2011 20:33:03 GMT  (257kb)", "http://arxiv.org/abs/1107.0024v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["a darwiche", "j d park"], "accepted": false, "id": "1107.0024"}, "pdf": {"name": "1107.0024.pdf", "metadata": {"source": "CRF", "title": "Complexity Results and Approximation Strategies for MAP Explanations", "authors": ["James D. Park", "Adnan Darwiche"], "emails": ["jd@cs.ucla.edu", "darwiche@cs.ucla.edu"], "sections": [{"heading": null, "text": "Given the difficulty of computing MAP exactly, and the difficulty of approximating MAP while providing useful guarantees on the resulting approximation, we investigate best effort approximations. We introduce a generic MAP approximation framework. We provide two instantiations of the framework; one for networks which are amenable to exact inference (Pr), and one for networks for which even exact inference is too hard. This allows MAP approximation on networks that are too complex to even exactly solve the easier problems, Pr and MPE. Experimental results indicate that using these approximation algorithms provides much better solutions than standard techniques, and provide accurate MAP estimates in many cases."}, {"heading": "1. Introduction", "text": "The task of computing the Maximum a Posteriori Hypothesis (MAP) is to find the most likely configuration of a set of variables given partial evidence about the complement of that set. The focus of this paper is on the complexity of computing MAP in Bayesian networks, and on a class of best effort methods for approximating MAP.\nOne specialization of MAP which has received a lot of attention is the Most Probable Explanation (MPE). MPE is the problem of finding the most likely configuration of a set of variables given complete evidence about the complement of that set. The primary reason for this attention is that MPE seems to be a much simpler problem than its MAP generalization. Unfortunately, MPE is not always suitable for the task of providing explanations. Consider for example the problem of system diagnosis, where each component has an associated variable representing its health. Given some evidence about the system behavior, one is usually interested in computing the most probable configuration of health variables. This is a MAP problem since the available evidence does not usually specify the value of each\nc\u00a92004 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.\nnon\u2013health variable. It is common to approximate this problem using MPE, in which case one is finding the most likely configuration of every unknown variable, including health variables and some other variables of no particular interest, such as the inputs and outputs of system components. However, the projection of an MPE solution on health variables is usually not a most likely configuration. Neither is the configuration obtained by choosing the most likely state of each health variable separately.\nMAP turns out to be a very difficult problem, even when compared to the MPE problem, or to the Pr problem for computing the probability of evidence. Specifically, we provide in Section 2 some complexity results which indicate that neither exact nor approximate solutions can be guaranteed for MAP, even under very restricted circumstances. Yet, MAP remains an important problem for which we would like to generate solutions. Therefore, we propose in Section 3 a general framework based on local search for best\u2013effort approximation of MAP. We also provide two specific instances of the proposed framework, one is applicable to networks that are amenable to exact computation of Pr and is given in Section 3, while the other is applicable to networks that are not even amenable to Pr and is given in Section 4. We report on experimental results for each method using real\u2013world and randomly generated Bayesian networks, which illustrate the effectiveness of our proposed framework on a wide range of networks. We close our paper by some concluding remarks in Section 5."}, {"heading": "2. MAP Complexity", "text": "We begin this section by reviewing some complexity theory classes and terminology that pertain to the complexity of MAP. We then examine the complexity of MAP in the general case, followed by examining the complexity when the number of MAP variables is constrained. We then consider the complexity of MAP algorithms based on variable elimination. We conclude the complexity section by examining the complexity of MAP on polytrees."}, {"heading": "2.1 Complexity Review", "text": "We assume that the reader is familiar with the basic notions of complexity theory like the hardness and completeness of languages, as well as the complexity class NP.\nIn addition to NP, we will also be interested in the class PP and a derivative of it. Informally, PP is the class which contains the languages for which there exists a nondeterministic Turing machine where the majority of the nondeterministic computations accept if and only if the string is in the language. PP can be thought of as the decision version of the functional class #P. As such, PP is a powerful language. In fact NP \u2286 PP, and the inequality is strict unless the polynomial hierarchy collapses to the second level.1\nAnother idea we will need is the concept of an oracle. Sometimes it is useful to ask questions about what could be done if an operation were free. In complexity theory this is modeled as a Turing machine with an oracle. An oracle Turing machine is a Turing machine with the additional capability of being able to obtain answers to certain queries in a single time step. For example, we may want to designate the class of languages that could be\n1. This is a direct result of Toda\u2019s theorem (Toda, 1991). From Toda\u2019s theorem PPP contains the entire polynomial hierarchy (PH), so if NP = PP, then PH \u2286 PPP = PNP.\nrecognized in nondeterministic polynomial time if any PP query could be answered for free. The class of languages would be NP with a PP oracle, which is denoted NPPP.\nConsider now a Boolean expression \u03c6 over variables X1, . . . ,Xn. The following three classical problems are complete for the above complexity classes:\nSAT: Is there a truth assignment (world) that satisfies \u03c6? This problem is NP\u2013complete.\nMAJSAT: Do the majority of worlds satisfy \u03c6? This problem is PP\u2013complete.\nE-MAJSAT: Is there an instantiation of variables X1,. . . ,Xk, 1 \u2264 k \u2264 n, under which the majority of worlds satisfy \u03c6? This problem is NPPP\u2013complete.\nIntuitively, to solve an NP\u2013complete problem we have to search for a solution among an exponential number of candidates, where it is easy to decide whether a given candidate constitutes a solution. For example, in SAT, we are searching for a world that satisfies a sentence (testing whether a world satisfies a sentence can be done in time linear in the sentence size). To solve a PP\u2013complete problem, we have to add up the weights of solutions, where it is easy to decide whether a particular candidate constitutes a solution and it is also easy to compute the weight of a solution. For example, in MAJSAT, a solution is a world that satisfies the sentence and the weight of a solution is 1. Finally, to solve an NPPP\u2013complete problem, we have to search for a solution among an exponential number of candidates, but we also need to solve a PP\u2013complete problem in order to decide whether a particular candidate constitutes a solution. For example, in E-MAJSAT, we are searching for an instantiation x1, . . . , xk, but to test whether an instantiation satisfies the condition we want, we must solve a MAJSAT problem."}, {"heading": "2.2 Decision Problems", "text": "We will be dealing with the decision versions of Bayesian network problems in this paper, which we define formally in this section.\nA Bayesian network is a pair (G,\u0398), where G is a directed acyclic graph (DAG) over variables X, and \u0398 defines a conditional probability table (CPT) \u0398X|U for each variable X and its parents U in the DAG G. That is, for each value x of variable X and each instantiation u of parents U, the CPT \u0398X|U assigns a number in [0, 1], denoted by \u03b8x|u, to represent the probability of x given u.2 The probability distribution Pr induced by a Bayesian network (G,\u0398) is given as follows. For a complete instantiation x of the network variables X, the probability of x is given by\nPr(x) def =\n\u220f\nxu\u223cx\n\u03b8x|u,\nwhere xu is the instantiation of a family (a variable and its parents) and \u223c represents the compatibility relation among instantiations. That is, the probability assigned to a complete variable instantiation x is the product of all parameters that are consistent with that instantiation.\nThe following decision problems assume that we are given a Bayesian network (G,\u0398) that has rational parameters and induces the probability distribution Pr. Moreover, by evidence e, we mean an instantiation of variables E.\n2. Hence, we must have \u2211\nx \u03b8x|u = 1.\nD-MPE: Given a rational number p, evidence e, and the set of network variables X, is there an instantiation x such that Pr(x, e) > p?\nD-PR: Given a rational number p and evidence e, is Pr(e) > p?\nD-MAP: Given a rational number p, evidence e, and some set of variables Q, is there an instantiation q such that Pr(q, e) > p? Variables Q are called the MAP variables in this case.\nWhile decision problems are useful for examining the complexity of finding an exact solution, what we are really interested in is the functional problem of actually computing the solution. When we can\u2019t solve the problem exactly, we would also like to know how close we can get efficiently. For that we consider approximation algorithms. We now define the notion of an approximation factor which we will use when discussing the complexity of approximation algorithms. Specifically, we will say that an approximate solution M \u2032 is within the approximation factor \u01eb > 1 of the true solution M in case M\u01eb \u2264 M\n\u2032 \u2264 \u01ebM . Moreover, we will say that an algorithm provides an f(n)\u2013factor approximation in case for all problems of size n, the approximate solutions returned by the algorithm are within the approximation factor f(n)."}, {"heading": "2.3 MAP Complexity for the General Case", "text": "Computing MPE, Pr, and MAP are all NP\u2013Hard, but there still appears to be significant differences in their complexity. MPE is basically a combinatorial optimization problem. Computing the probability of a complete instantiation is trivial, so the only real difficulty is determining which instantiation to choose. D-MPE is NP-complete (Shimony, 1994). Pr is a completely different type of problem, characterized by counting instead of optimization, as we need to add up the probability of network instantiations. D-PR is PP-complete (Litmman, Majercik, & Pitassi, 2001)\u2014notice that this is the complexity of the decision version, not the functional version which is #P-complete (Roth, 1996). MAP combines both the counting and optimization paradigms. In order to compute the probability of a particular instantiation, a Pr query is needed. Optimization is also required, in order to be able to decide between the many possible instantiations. This is reflected in the complexity of MAP.\nTheorem 1 D-MAP is NPPP-complete.3\nProof: Membership in NPPP is immediate. Given any instantiation q of the MAP variables, we can verify if it is a solution by querying the PP oracle if Pr(q, e) > k.\nTo show hardness, we reduce E-MAJSAT (Littman, Goldsmith, & Mundhenk, 1998) to D-MAP by first creating a Bayesian network that models a Boolean formula \u03c6. For each variable Xi in the formula \u03c6, we create an analogous variable in the network with values {T, F} and a uniform prior probability. Then, for each logical operator, we create a variable with values {T, F} whose parents are the variables corresponding to its operands, and whose CPT encodes the truth table for that operator (see Figure 1 for a simple example). Let V\u03c6 be the network variable corresponding to the top level operand.\n3. This result was stated without proof by Littman (1999).\nFor a complete instantiation x of all of the variables X appearing in the Boolean expression \u03c6, with evidence V\u03c6 = T , we have:\nPr(x, V\u03c6 = T ) =\n{\n1 2n x satisfies \u03c6 0 otherwise\nFor a particular instantiation q of MAP variables X1, ...,Xk , and evidence V\u03c6 = T , we have:\nPr(q, V\u03c6 = T ) = \u2211\nxk+1,...,xn\nPr(q, xk+1, ..xn)\n= #q 2n\nwhere #q is the number of complete variable instantiations compatible with q that satisfies \u03c6. Since there are 2n\u2212k possible instantiations of Xk+1, ...,Xn, the fraction fq satisfied is #q/2 n\u2212k, so\nPr(q, V\u03c6 = T ) = fq 2k\nThus, an instantiation q of the MAP variables is compatible with more than half of the complete, satisfying instantiations if Pr(q, V\u03c6 = T ) > 1/2\nk+1. So the MAP query over variables X1, ...,Xk with evidence V\u03c6 = T and threshold 1/2\nk+1 is true if and only if the E-MAJSAT query is also true. \u2737\nIn fact, the above theorem can be strengthened.\nTheorem 2 D-MAP remains complete for NPPP even when (1) the network has depth 2, (2) there is no evidence, (3) all variables are Boolean, and (4) all network parameters lie in the interval [12 \u2212 \u01eb, 1 2 + \u01eb] for any fixed \u01eb > 0.\nThe proof appears in Appendix A. Unlike computing probabilities, which becomes easy when the number of evidence nodes is bounded by a constant and the parameters are bounded away from 0 (it falls into RP as described by Dagum & Luby, 1997), MAP retains its NPPP complexity even under these restrictive circumstances.4\n4. This is not altogether surprising since when evaluating the score of a possible solution, the MAP variables act as evidence variables.\nNPPP is a powerful class, even compared to NP and PP. NPPP contains other important AI problems, such as probabilistic planning problems (Littman et al., 1998). The three classes are related by NP \u2286 PP \u2286 NPPP, where the equalities are considered very unlikely. In fact, NPPP contains the entire polynomial hierarchy (Toda, 1991). Additionally, because MAP generalized Pr, MAP inherits the wild non\u2013approximability of Pr. From the \u201cBayesian network simulates SAT\u201d reduction we get:\nCorollary 3 Approximating MAP within any approximation factor f(n) is NP\u2013hard.\nProof: Using the evidence V\u03c6 = T , the exact MAP solution is the number of satisfying instantiations divided by 2n, which is 0 if it is unsatisfiable, and positive if it is satisfiable. If the formula is unsatisfiable, then the approximate solution must be 0 because 0/\u01eb = 0 \u2264 M \u2032 \u2264 \u01eb0 = 0, where \u01eb = f(n). If the formula is satisfiable, then the approximate solution must be positive since M/\u01eb > 0. Thus we can test satisfiability by testing if the approximate MAP solution is zero or not.\u2737"}, {"heading": "2.4 Complexity Parameterized by the Number of Maximization Variables", "text": "We now examine the complexity when we restrict the number of maximization variables. Let n be the number of non\u2013evidence variables, and k be the number of maximization variables. In the extreme case of k = 0, this is simply D-PR, so it is PP\u2013complete. At the other extreme, when k = n, it becomes D-MPE, and is NP\u2013complete. So constraining the number of maximization variables can have a dramatic impact on the complexity. We now examine this issue in detail. Let D-MAPm be the subset of D-MAP problems where k = O(m), and let D-MAPm be the subset of D-MAP problems where n\u2212k = O(m). We can then consider the complexity of these parameterized classes of problems. The primary results are the following:\nTheorem 4 D-MAPlogn is in P PP, and D-MAPlogn is in NP. However, for any \u01eb > 0, both D-MAPn\u01eb and D-MAP n\u01eb remain NPPP\u2013complete.\nProof: First, if k = O(log n), then the number of possible instantiations of the maximization variables is bounded by a polynomial. Thus, given a PP oracle, it is possible to decide the problem in polynomial time by asking for each instantiation q of the maximization variables whether Pr(q, e) exceeds the threshold. Similarly, if n \u2212 k = O(log n), then for any instantiation q of the maximization variables, we can test to see if Pr(q, e) exceeds the threshold by summing over the polynomial number of compatible instantiations.\nFor k = O(n\u01eb) we can provide a simple reduction to solve any D-MAP problem by creating a polynomially larger one satisfying the constraint on the number of maximization variables. From the unconstrained problem, we simply create a new problem by adding a polynomial number of irrelevant variables, with no parents or children. Similarly, we can provide a reduction of the general D-MAP problem to one constrained to have n \u2212 k = O(n\u01eb), by adding a polynomial number of maximization variables with no parents, no children, and deterministic priors. \u2737"}, {"heading": "2.5 Results for Elimination Algorithms", "text": "Solution to the general MAP problem seems out of reach, but what about for \u201ceasier\u201d networks? State\u2013of\u2013the\u2013art exact inference algorithms (variable elimination (Dechter, 1996), join trees (Lauritzen & Spiegelhalter, 1988; Shenoy & Shafer, 1986; Jensen, Lauritzen, & Olesen, 1990), recursive conditioning (Darwiche, 2001)) can compute Pr and MPE in space and time complexity that is exponential only in the width of a given elimination order. This allows many networks to be solved using reasonable resources even though the general problems are very difficult. Similarly, state\u2013of\u2013the\u2013art MAP algorithms can also solve MAP with time and space complexity that is exponential only in width of used elimination order but, for MAP, not all orders can be used. In this section, we investigate the complexity of variable elimination for MAP.\nBefore analyzing the complexity of variable elimination for MAP, we review variable elimination. First, we need the concept of a potential. A potential is simply a function over some subset of the variables, which maps each instantiation of its variables to a real number. The size of a potential is parameterized by the number of instantiations of its variables, and so is exponential in the number of variables. Notice that CPTs are potentials. In order to use variable elimination for Pr, MPE and MAP, we need three simple operations: multiplication, summing\u2013out, and maximization. Multiplication of two potentials \u03c61 and \u03c62 with variables XY and YZ respectively (where Y is the set of variables they have in common), is defined as (\u03c61\u03c62)(xyz) = \u03c61(xy)\u03c62(yz). Notice that if both X and Z are nonempty, then the size of \u03c61\u03c62 is greater than the size of either \u03c61 or \u03c62. SumOut(\u03c6,Y) where \u03c6 is over variables XY is defined as\nSumOut(\u03c6,Y)(x) = \u2211\ny\n\u03c6(xy),\nwhere y ranges over the instantiations of Y. Maximization is similar to summing out but maximizes out the unwanted variables:\nMaximize(\u03c6,Y)(x) = max y \u03c6(xy).\nIn order to handle evidence, we need the concept of an evidence indicator. The evidence indicator \u03bbE associated with evidence E = e is a potential over variable E where \u03bbE(e) = 1, and is zero for all other values.\nGiven a variable ordering \u03c0, variable elimination can be used to compute the probability of evidence e as follows:\n1. Initialize P to contain the evidence indicators for e and all of the conditional probability tables.\n2. For each variable X, according to order \u03c0,\n(a) Remove from P all potentials mentioning X.\n(b) Let MX be the product of all of those potentials.\n(c) add SumOut(MX ,X) to P .\n3. Return the product of all potentials in P .\nIn each iteration, a variable X is eliminated which leads to removing all mention of X from P . By step 3, all variables have been removed, so the potentials remaining are just constants and the resulting product is a single number representing the probability of evidence e. MPE is computed in the same way, except the projection in step 2c is replaced by maximization. The complexity of variable elimination is linear in the number of variables and linear in the size of the largest potential MX produced in step 2b. The size of the largest potential varies significantly based on the elimination order. The width of an elimination order is simply log2(size(MX))\u22121 whereMX is the largest potential produced using that elimination order. 5 The treewidth of a Bayesian network is the minimum width of all elimination orders. For Pr and MPE, any elimination order can be used, so the complexity is linear in the number of variables and exponential in the treewidth. The same is not true for MAP. Variable elimination for MAP is similar to the other methods, but with an extra constraint. In step 2c, if X is a MAP variable the projection is replaced with maximization. If it is not a MAP variable projection is used. The extra constraint is that not all orders are valid. Maximization and projection do not commute, and maximization must be performed last. This means that for an elimination order to be valid for performing MAP, whenX is a MAP variable, the potential in step 2b must not mention any non-MAP variables. In practice this is ensured by requiring that the elimination order eliminate all of the MAP variables last. This tends to produce elimination orders with widths much larger than those available for Pr and MPE, often placing exact MAP solutions out of reach.\nIn order to assess the magnitude of increase in width caused by restricting the elimination order, we randomly generated 100 Bayesian networks, each containing 100 variables, according to the first method in Appendix B. For each network, we computed the width using the min\u2013fill heuristic (Kjaerulff, 1990; Huang & Darwiche, 1996). Then, we repeatedly added a single variable to the set of MAP variables, and computed the constrained width, again using min\u2013fill, but eliminating the MAP variables last. This process was repeated until all variables were in the MAP variable set. Figure 2 contains statistics on these experiments. The X\u2013axis corresponds to the number of MAP variables (thus X = 0 corresponds to the unconstrained width). The Y \u2013axis corresponds to the width found. The graph details the minimum, maximum, mean, and weighted mean for each of the 100 networks. The weighted mean takes into account that the complexity is exponential in the width, and so provides a better representation of the average complexity. It was computed as log2( 1 n \u2211n i=1 2\nwi). Notice that the unconstrained widths range from 11 to 18, and that as the number of MAP variables increases, the width increases dramatically. For example, even when only a quarter of the variables are MAP variables (X = 25) the widths range between 22 and 34, (which corresponds roughly from difficult but doable to well beyond what today\u2019s inference algorithms can handle on today\u2019s computers) with a weighted average above 30. Notice also, that as we would expect from our complexity analysis, problems with very few or very many MAP variables are significantly easier than those in the middle range.\nWe now consider the question of whether there are less stringent conditions for valid elimination orders, that may allow for orders with smaller widths.\n5. The -1 in the definition is to preserve compatibility with the previously defined notion of treewidth in graph theory.\nAs described earlier, given an ordering, elimination algorithms work by stepping through the ordering, collecting the potentials mentioning the current variable, multiplying them, then replacing them with the potential formed by summing out (or maximizing) the current variable from the product. This process can be thought to induce an evaluation tree; see Figure 3. The evaluation tree for an elimination order \u03c0 is described as follows. The leaves correspond to the CPTs of given Bayesian network, and the internal nodes correspond to potentials created during the elimination process. The children of a potential \u03c6 represent other potentials that had to be multiplied together when constructing \u03c6. Note that each internal node in the elimination tree corresponds to variable in the order \u03c0, whose elimination leads to constructing the node; Figure 3(b). Therefore, an evaluation tree can be viewed as inducing a partial elimination order; see Figure 3(c).\nThe standard way of constructing a valid elimination order for MAP is to eliminate the MAP variables Q last. Two questions present themselves. First, are there valid orderings in which variables Q are not eliminated last? And second, if so, can they produce widths smaller than those generated by eliminating variables Q last?\nThe answer to the first question is yes, there are other valid elimination orders in which variables Q are not eliminated last. To see that, suppose we have a variable order \u03c0 which induces a particular evaluation tree T , and let \u03c3 be the partial elimination order corresponding to T . Any variable order \u03c0\u2032 which is consistent with the partial order \u03c3 will\nalso induce the tree T . Hence, if order \u03c0 was valid, then order \u03c0\u2032 will also be valid. Figure 3 shows the evaluation tree induced by using the order A,E,B,D,C for computing MAP over variables Q = C,D. The order A,B,D,E,C is consistent with this evaluation tree and, hence, is also valid for computing MAP over variables C,D. Yet, variables C,D do not appear last in the order.\nUnfortunately, orders in which variables Q are not eliminated last do not help.\nTheorem 5 For any elimination order \u03c0 which is valid for computing MAP over variables Q, there is an ordering of the same width in which variables Q are eliminated last.\nProof: Consider the evaluation tree induced by any valid elimination order, and the corresponding partial order it induces. No variable in Q is the parent of any variable in Q. To prove this, suppose that X is a parent of Y in the evaluation tree, where X \u2208 Q and Y \u2208 Q. This means that the potential which results from eliminating variable Y includes variable X, which also means that X must have appeared in some of the potentials we multiplied when elimination variable Y . But this is a contradiction since the evaluation tree and its underlying order are valid. Since no variable in Q is a parent of a variable in Q, all variables in Q can be eliminated first in any order consistent with the partial order defined by the evaluation tree. Then, all variables in Q can be eliminated, again obeying the partial ordering defined by the evaluation tree. Because the produced order has the same elimination tree as the original order, they have the same width. \u2737"}, {"heading": "2.6 MAP on Polytrees", "text": "Theorem 5 has significant complexity implications for elimination algorithms even on polytrees.\nTheorem 6 Elimination algorithms require exponential resources to perform MAP, even on some polytrees.\nProof: Consider computing MAP over variables X1, . . . ,Xn given evidence Sn = T for the network shown in Figure 4. By Theorem 5, there is no order whose width is smaller\nthan that of an order \u03c0 in which we eliminate variables S0, . . . , Sn first, and then variables X1, . . . ,Xn last. It is easy to show though that any such order \u03c0 will have width n. Hence, variable elimination will require exponential resources using such an order. \u2737\nThe set of MAP variables makes a crucial difference in the complexity of MAP computations. For example, if the MAP variables were X1, . . . ,Xn/2, S0, . . . , Sn/2 instead of X1, . . . ,Xn can be solved in linear time.\nThe above negative findings are specific to variable elimination algorithms. The question then is whether this difficulty is an idiosyncrasy of variable elimination which can be avoided if we were to use some other method for computing MAP. The following result, however, shows that finding a good general algorithm for MAP on polytrees is unlikely.\nTheorem 7 MAP is NP\u2013complete when restricted to polytrees.\nProof: Membership is immediate. Given a purported solution instantiation q, we can compute Pr(q, e) in linear time and test it against the bound. To show hardness, we reduce MAXSAT to MAP on a polytree.6 Similar reductions were used by Papadimitriou and Tsitsiklis (1987) and Littman et al. (1998) relating to partially observable Markov decision problems, and probabilistic planning respectively. The MAXSAT problem is defined as follows:\nGiven a set of clauses C1, ..., Cm over variables Y1, ..., Yn and an integer bound k, is there an assignment of the variables, such that more than k clauses are satisfied.\nThe idea behind the reduction is to model the random selection of a clause, and then successively checking whether the instantiation of each variable satisfies the selected clause. The clause selector variable S0 with possible values 1, 2, ...,m has a uniform prior. Each propositional variable Yi induces two network variables Xi and Si, where Xi represents the value of Yi, and has a uniform prior, and Si represents whether any of Y1, ..., Yi satisfy the selected clause. Si = 0 indicates that the selected clause was satisfied by one of Y1, ..., Yi. Si = c > 0 indicates that the selected clause Cc was not satisfied by Y1, ..., Yi. The parents of Si are Xi and Si\u22121 (the topology is shown in Figure 4). The CPT for Si, for i \u2265 1 is defined as\nPr(si|xi, si\u22121) =\n       \n      \n1 if si = si\u22121 = 0 1 if si = 0 and si\u22121 = j, and\nxi satisfies cj 1 if si = si\u22121 = j and xi does\nnot satisfy cj 0 otherwise\nIn words, if the selected clause was not satisfied by the first i\u2212 1 variables (si\u22121 6= 0), and xi satisfies it, then Si becomes satisfied (si = 0). Otherwise, we have si = si\u22121. Now, for a particular instantiation s0 of S0, and instantiation x of variables X1, ...,Xn,\nPr(s0,x, Sn = 0) =\n{\n1/(m2n) if x satisfies clause Cs0 ; 0 otherwise.\n6. Actually, we only need to reduce it to SAT, but the MAXSAT result will be used in Theorem 8.\nSumming over S0 yields Pr(x, Sn = 0) = #C/(m2 n) where #C is the number of clauses that x satisfies. Thus MAP over X1, ...,Xn with evidence Sn = 0 and bound k/(m2 n) solves the MAXSAT problem as well. \u2737\nSince MAXSAT has no polynomial time approximation scheme (unless P = NP), no polynomial time approximation scheme exists for MAP on polytrees. In fact, approximating MAP on polytrees appears to be much harder than approximating MAXSAT.\nTheorem 8 Approximating MAP on polytrees within a factor of 2n \u01eb\nis NP-hard for any fixed \u01eb, 0 \u2264 \u01eb < 1, where n is the size of the problem.\nThe proof appears in Appendix A. So, not only is it hard to approximate within a constant factor, it is hard to approximate within a polynomial factor, or even a subexponential factor.\nWe close this section by a summary of the complexity results in this section:\n\u2022 MAP is NPPP\u2013complete for arbitrary Bayesian networks, even if we have no evidence, every variable is binary, and the parameters are arbitrarily close to 1/2.\n\u2022 It is NP\u2013hard to approximate MAP within any factor f(n).\n\u2022 Variable elimination for MAP requires exponential time, even on some polytrees.\n\u2022 MAP is NP\u2013complete for networks with polytree structure.\n\u2022 Approximating MAP on polytrees within a factor of 2n \u01eb\nis NP\u2013hard for any fixed \u01eb \u2208 [0, 1)."}, {"heading": "3. Approximating MAP when Inference is Easy", "text": "Since exact MAP computation is often intractable, approximation techniques are needed. Unfortunately, in spite of MAP\u2019s utility, relatively little work has been done in approximating it. In fact, there are only two previous methods for approximating MAP which we are aware of. The first (Dechter & Rish, 1998) uses the mini\u2013bucket technique. The other (de Campos, Gamez, & Moral, 1999), uses genetic algorithms to approximate the best k configurations of the MAP variables (this problem is known as partial abduction). Practitioners typically resort to one of two simple approximation methods. One common approximation technique is to compute an MPE instantiation and then project the result on the MAP variables. That is, if we want to compute MAP for variables S given evidence e, and if S\u2032 is the complement of variables S \u222a E, we compute an instantiation s, s\u2032 that maximizes Pr(s, s\u2032 | e) and then return s. The other method computes posterior marginals\nfor the MAP variables, Pr(S | e), S \u2208 S, and then choose the most likely state s of each variable given e.\nWe propose a general framework for approximating MAP. MAP consists of two problems that are hard in general\u2014optimization and inference. A MAP approximation algorithm can be produced by substituting approximate versions of either the optimization or inference component (or both). The optimization problem is defined over the MAP variables, and the score for each solution candidate instantiation s of the MAP variables is the (possibly approximate) probability Pr(s, e) produced by the inference method. This allows solutions tailored to the specific problem. For networks whose treewidth is manageable, but contains a hard optimization component (e.g. the polytree examples discussed previously), exact structural inference can be used, coupled with an approximate optimization algorithm. Alternatively, if the optimization problem is easy (e.g. there are few MAP variables) but the network isn\u2019t amenable to exact inference, an exact optimization method could be coupled with an approximate inference routine. If both components are hard, both the optimization and inference components need to be approximated.\nWe investigate in this section a family of approximation algorithms based on local search. We first consider the case when inference is tractable, then develop an extension to handle the case when inference is infeasible. The local search algorithms work basically as follows:\n1. Start from an initial guess s at the solution.\n2. Iteratively try to improve the solution by moving to a better neighbor s\u2032: Pr(s\u2032 | e) > Pr(s | e), or equivalently Pr(s\u2032, e) > Pr(s, e).\nA neighbor of instantiation s is defined as an instantiation which results from changing the value of a single variable X in s. If the new value of X is x, we will denote the resulting neighbor by s \u2212X,x. In order to perform local search efficiently, we need to compute the scores for all of the neighbors s\u2212X,x efficiently. That is, we need to compute Pr(s\u2212X,x, e) for each X \u2208 S and each of its values x not in s. If variables have binary values, we will have | S | neighbors in this case.\nLocal search has been proposed as a method for approximating MPE (Kask & Dechter, 1999; Mengshoel, Roth, & Wilkins, 2000). For MPE, the MAP variables S contain all variables which are not in E (the evidence variables). Therefore, the score of a neighbor, Pr(s\u2212X,x, e), can be computed easily since s\u2212X,x, e is a complete instantiation. In fact, given that we have computed Pr(s, e), the score Pr(s\u2212X,x, e) can be computed in constant time.7\nUnlike MPE, computing the score of a neighbor, Pr(s \u2212 X,x, e), in MAP requires a global computation since s\u2212X,x, e may not be a complete instantiation. One of the main observations underlying our approach, however, is that the score Pr(s \u2212 X,x, e) can be computed in O(n exp(w)) time and space, where n is the number of network variables and\n7. This assumes that none of entries in the CPTs are 0. If there are 0 entries in the CPTs, it may take time linear in the number of network variables to compute the score. Pr(s, e) is the product of the single entry of each CPT that is compatible with s, e. When changing the state of variable X from x to x\u2032, the only values in the product that change are those from the CPTs of X and its children. If none of the CPT entries are 0, Pr(s\u2212X,x\u2032, e) can be computed by dividing Pr(s, e) by the old and multiplying by the new entry for the CPTs for X and its children. This can be done in constant time if the number of children is bounded by a constant.\nw is the width of an arbitrary elimination order, i.e., we can use any elimination order for this purpose, no need for any constraints. In fact, we can even do better than this by computing the scores of all neighbors, Pr(s \u2212 X,x, e) for all X \u2208 S and every value x of X, in O(n exp(w)) time and space. Thus, if we have an elimination order of width w for the given Bayesian network, then we can perform each search step in O(n exp(w)) time and space. As we shall see later, it takes a small number of search steps to obtain a good MAP solution. Hence, the overall runtime is often O(n exp(w)) too. Therefore, we can produce good quality MAP approximations in time and space which are exponential in the unconstrained width instead of the constrained one, which is typically much larger.\nThe local search method proposed in this section differs from the local search methods used for MPE in that the unconstrained width must be small enough so that a search step can be performed relatively efficiently. It is pointless to use this method to approximate MPE since in the time to take one step, the MPE could be computed exactly. This method is applicable when the unconstrained width is reasonable but the constrained width is not (see Figure 2)."}, {"heading": "3.1 Computing Neighbor Scores Efficiently", "text": "The key to computing the neighbor scores efficiently is to express the inference problem as a function over the evidence indicators. For each state x of variable X, the evidence indicator \u03bbx is one if it is compatible with the evidence, and zero otherwise. This is a common technique that is typically used to allow the modeling of a wider range of evidence assertions. For example, this allows evidence assertions such as X 6= x by setting \u03bbx = 0, and the remaining indicators forX to one. We will use them for a different purpose however. When the inference problem is cast as a function f of the evidence indicators (f(\u03bbe) = Pr(e), where \u03bbe consists of all of the evidence indicators, set so that they are compatible with e), then \u2202f\u2202\u03bbx (\u03bbe) = Pr(e \u2212 X,x). When our we add the current state to the evidence, this partial derivative yields Pr(s\u2212X,x, e), which is precisely the score for one of the neighbors.\nWe can use the jointree algorithm (Park & Darwiche, 2003), or the differential inference approach (Darwiche, 2003) to compute all of the partial derivatives efficiently. In the differential approach, these values are immediate, as the entire approach is based on evaluating and differentiating the expression f above. It can also be computed using jointrees by using the Shenoy\u2013Shafer propagation scheme. Specifically, an evidence indicator table is added for each variable, and evidence about that variable is entered by setting the appropriate indicator entries. The partial derivatives of all of the indicators associated with a variable are obtained by multiplying all other tables assigned to the same cluster, and all messages into the cluster, then projecting that product onto the variable. In either case, the partial derivatives for all indicators, and thus the score for all neighbors, can be computed in O(n exp(w)) time, which is the same complexity as simply computing the score for the current state."}, {"heading": "3.2 Search Methods", "text": "We tested two common local search methods, stochastic hill climbing and taboo search. Stochastic hill climbing proceeds by repeatedly either changing the the state of the variable\nthat creates the maximum probability change, or changing a variable at random. Figure 5 gives the algorithm explicitly.\nTaboo search is similar to hill climbing except that the next state is chosen as the best state that hasn\u2019t been visited recently. Because the number of iterations is relatively small we save all of the previous states so that at each iteration a unique point is chosen. Pseudocode for taboo search appears in Figure 6."}, {"heading": "3.3 Initialization", "text": "The quality of the solution returned by a local search routine depends to a large extent on which part of the search space it is given to explore. We implemented several algorithms to compare the solution quality with different initialization schemes. Suppose that n is the number of network variables, w is the width of a given elimination order, and m is the number of MAP variables.\n1. Random initialization (Rand). For each MAP variable, we select a value uniformly from its set of states. This method takes O(m) time.\n2. MPE based initialization (MPE). We compute the MPE solution given the evidence. Then, for each MAP variable, we set its value to the value that the variable takes on in the MPE solution. This method takes O(n exp(w)) time.\n3. Maximum likelihood initialization (ML). For each MAP variable X, we set its value to the instance x that maximizes Pr(x | e). This method takes O(n exp(w)) time.\n4. Sequential initialization (Seq). This method considers the MAP variables X1, . . . ,Xm, choosing each time a variable Xi that has the highest probability Pr(xi | e,y) for one\nof its values xi, where y is the instantiation of MAP variables considered so far. This method takes O(mn exp(w)) time."}, {"heading": "3.4 Experimental Results", "text": "Two search methods (Hill and Taboo) and four initialization methods (Rand, MPE, ML, Seq) lead to 8 possible algorithms. Each of the initialization methods can also be viewed as an approximation algorithm since one can simply return the computed initialization. This leads to a total of 12 different algorithms. We experimentally evaluated and compared 11 of these algorithms, leaving out the algorithm corresponding to random initialization.\nWe tested the algorithms on various synthetically generated data sets as well as real world networks. For the synthetic networks, we generated random network structures using two generation methods (see Appendix B). For each structure, we quantified the CPTs for different bias coefficients from 0 (deterministic except the roots), to .5 (values chosen uniformly) so we could evaluate the influence of CPT quantification on the solution quality. Each network consisted of 100 variables, with some of the root variables chosen as the MAP variables. If there were more than 25 root variables, we randomly selected 25 of them for the MAP variables. Otherwise we used all of the root variables. We chose root nodes for MAP variables because typically some subset of the root nodes are the variables of interest in diagnostic applications. Evidence was set by instantiating leaf nodes. Care was taken to insure that the instantiation had a non zero probability. Each algorithm was allowed 150 network evaluations.8 We computed the true MAP and compared it to the solutions found by each algorithm. Additionally, we measured the number of network evaluations needed to find the solution each algorithm subsequently returned, and the number of peaks discovered\n8. An evaluation takes O(n exp(w)) time and space, where n is the number of network variables and w is the width of given elimination order.\nbefore that solution was discovered. The hill climbing method used in these data sets is pure hill climbing with random walk restart. That is, it hill climbs until it reaches a peak, then randomly flips some of the values to move to a new location.\nWe generated 1000 random network structures for each of the two structural generation methods. For each random structure generated, and each quantification method, we quantified the network, computed the exact MAP, and applied each of the approximation\nalgorithms. Tables 1 and 2 show the solution quality of each of the methods by reporting the fraction of networks that were solved correctly; that is, the approximate answer had the same value as the exact answer.\nOne can draw a number of observations based on these experiments:\n\u2022 In each case, taboo search performed slightly better than hill climbing with random restarts.\n\u2022 The search methods were typically able to perform much better than the initialization alone.\n\u2022 Even from a random start, the search methods were able to find the optimal solution in the majority of the cases.\n\u2022 Overall, taboo search with sequential initialization performed the best, but required the most network evaluations.\nTable 3 contains some statistics on the number of network evaluations (including those used for initialization) needed to achieve the value that the method finally returned. The mean number of evaluations is quite small for all of the methods. Surprisingly, for the hill climbing methods, the maximum is also quite small. In fact, after analyzing the results we discovered that the hill climbing methods never improved over the first peak they discovered.9 This suggests that one viable method for quick approximation is to simply climb to the first peak and return the result. Taboo search on the other hand was able to improve on the first peak in some cases.\nWe ran ten MAP queries for each real world network we tested. For each query we randomly selected one fourth of the nodes to be the variables of interest, and selected one fourth of the nodes to be evidence nodes. The evidence values were chosen uniformly among the nonzero configurations. As our previous experiments demonstrated that a large number of iterations rarely helps, we reduced the number of iterations to 30. Also, we moved away from hill climbing with random restart to stochastic hill climbing (performing a random move with probability .35) since in our previous experiments the random restart never helped. Also, we ran a mini\u2013bucket approximation algorithm (the only other MAP approximation algorithm we are aware of that is not subsumed by our technique) to compare its performance to our algorithms. Since exact MAP computations on these networks is too hard for current algorithms to handle, we compare the algorithms based on relative performance only.\nTable 4 shows the number of times (out of ten) that each algorithm was able to produce the highest probability configuration discovered. The search based methods again performed much better than the other algorithms. Note that each of them outperformed the mini\u2013 bucket approximations on each network. Table 5 provides more specific details about the relative performance for each network. Each block contains the count of the number of times that each method produced solutions within some range of the best found solution.\n9. It appears that the random walk used in restarting does not make eventually selecting a better region very likely when using so few search steps. Often, when a sub optimal hill was encountered, the optimal hill was just 2 or 3 moves away. In those cases, the taboo search was usually able to find it (because its search was more guided), while random walking was not.\nSo for example, in the Barley group, in the MPE row, for the column labeled \u201c> .5\u201d there is a 3, indicating that in 3 of the 10 cases the solution found was between .5 and .9 times the best solution found for that query.\nQualitatively, these results are very similar to those obtained for the random networks. Again the search methods outperformed the static initialization methods. Note that for different networks, different initializations perform better. Notice also, that the search methods significantly outperformed the mini\u2013bucket approximations in every network."}, {"heading": "4. Approximating MAP when Inference is Hard", "text": "The techniques developed thus far depend on the ability to perform exact inference. For many networks, even inference is intractable. In these cases, approximate inference can be substituted in order to produce MAP approximations.\nWe investigate using belief propagation as the approximate inference scheme, and local search for the optimization scheme. Iterative belief propagation is a useful approximate inference algorithm for approximating MAP for a number of reasons and has proven to be a very effective and efficient approximation method for a variety of domains. It has the ability to approximate MPE, posterior marginals, and probability of evidence, allowing for the same initialization schemes as we used for exact inference. Additionally, as we will show in section 4.2, after a single inference call, the scores of neighbors in the search space can be computed locally, allowing us to obtain the same linear speed up that we obtained using a similar approach in the exact inference case. Thus belief propagation allows all of the techniques for approximating MAP for inference tractable networks to be applied approximately when inference is not tractable."}, {"heading": "4.1 Belief Propagation Review", "text": "Belief propagation was introduced as an exact inference method on polytrees (Pearl, 1988). It is a message passing algorithm in which each node in the network sends a message to its neighbors. These messages, along with the CPTs and the evidence can be used to compute posterior marginals for all of the variables. In networks with loops, belief propagation is no longer guaranteed to be exact, and successive iterations generally produce different results, so belief propagation is typically run until the message values converge. This has been shown to provide very good approximations for a variety of networks (McEliece, Rodemich, & Cheng, 1995; Murphy, Weiss, & Jordan, 1999), and has recently received a theoretical explanation (Yedidia, Freeman, & Weiss, 2000).\nBelief propagation works as follows. Each node X, has an evidence indicator \u03bbX where evidence can be entered. If the evidence sets X = x, then \u03bbX(x) = 1, and is 0 otherwise. If no evidence is set for X, then \u03bbX(x) = 1 for all x. After evidence is entered, each node X sends a message to each of its neighbors. The message a node X with parents U sends to child Y is computed as\nMXY = \u03b1 \u2211\nU\n\u03bbX Pr(X|U) \u220f\nZ 6=Y\nMZX\nwhere Z ranges over the neighbors of X and \u03b1 is a normalizing constant.10 Similarly, the message X sends to a parent U is\nMXU = \u03b1 \u2211\nXU\u2212{U}\n\u03bbX Pr(X|U) \u220f\nZ 6=U\nMZX .\n10. We use potential notation more common to join trees than the standard descriptions of belief propagation because we believe the many indices required in standard presentations mask the simplicity of the algorithm.\nMessage passing continues until the message values converge. The posterior of X is then approximated as\nPr\u2032(X|e) = \u03b1 \u2211\nU\n\u03bbX Pr(X|U) \u220f\nZ\nMZX .\nThe messages are all initialized to 1. There are two main schemes for ordering the messages. In the first scheme, all of the messages are computed simultaneously, based on the previous set of messages. In the other scheme, messages are updated incrementally, and in two phases, consistent with some ordering of the variables. In the first phase, in reverse order, each variable sends a message to its neighbors that precede it in the order. In the second phase, in order, each variable sends a message to its neighbors that come after it in the order. We implemented the second scheme since empirically it seems to converge faster than the first scheme (Murphy et al., 1999)."}, {"heading": "4.2 Approximating Neighbors\u2019 Scores", "text": "Belief propagation allows us to approximate the scores of neighbors in the local search space efficiently, similar to what we have done in the case of exact inference. The key as we shall show next is to be able to compute the quantity Pr(x|e\u2212X) for each variable X efficiently, as we can use this quantity to rank the neighbors according to the desired score.\nSpecifically, in polytrees, the incoming messages are independent of the value of the local CPT or any evidence entered. Hence, leaving the evidence out of the product yields\nPr(X|e\u2212X) = \u03b1 \u2211\nU\nPr(X|U) \u220f\nZ\nMZX .\nTherefore, we can compute the above quantity for each variable after a single belief propagation. In networks that are not polytrees, the incoming messages are not necessarily independent of the evidence or the local CPT, but as is done with other BP methods, we ignore that and hope that it is nearly independent. Empirically, the approximation seems to\nbe quite accurate. Figure 7 shows a representative example, comparing the correspondence between the approximate and exact retracted probabilities for 30 variables in the Barley network. The x axis corresponds to the true retracted probability, and the y axis to the approximation produced using belief propagation.\nStill, Pr(x|e\u2212X) is not quite what we want to score neighbors in the local search space. But this quantity can be used to compute the ratio of the neighboring score to the current score which allows such comparisons. Specifically, simple algebra shows that:\nPr(x, s\u2212X, e)\nPr(s, e) =\nPr(x|s\u2212X, e)\nPr(xs|s\u2212X, e)\nwhere xs is the value that X takes on in the current instantiation s. Thus, we can find the neighbor with the best score after a single belief propagation."}, {"heading": "4.3 Experimental Results", "text": "For the first experiment, we consider the improvement possible over what is typically done (MPE or ML) using it as a starting point and hill climbing from there. For the first experiment, we generated 100 synthetic networks with 100 variables each using the first method described in Appendix B with bias parameter 0.25 and width parameter of 13. We generated the networks to be small enough that we could often compute the exact MAP value, but large enough to make the problem challenging. We chose the MAP variables as the roots (typically between 20 and 25 variables), and the evidence values were chosen randomly from 10 of the leaves. We computed the true MAP for the ones which memory constraints (512 MB of RAM) allowed. We computed the true probability of the instantiations produced by the two standard methods. For both initialization methods we also computed the true probability of the instantiations returned by pure hill climbing11 (i.e. only greedy steps were taken), and stochastic hill climbing with 100 steps, where random moves were taken with probability pf = .3. Of the 100 networks, we were able to compute the exact MAP in 59 of them. Table 6 shows the number exactly solved for each method, as well as the worst instantiation produced, measured as the ratio of the probabilities of the found instantiation to the true MAP instantiation. All of the hill climbing methods improved significantly over their initializations in general, although for 2 of the networks, the hill climbing versions were slightly worse than the initial value (the worst was a ratio of .835), because of a slight mismatch in the true vs. approximate probabilities. Over all, the stochastic hill climbing routines outperformed the other methods.\nIn the second experiment, we generated 25 random MAP problems for the Barley network, each with 25 randomly chosen MAP variables, and 10 randomly chosen evidence assignments. We use the same parameters as in the previous experiment. The problems were too hard to compute the exact MAP, so we report only on the relative improvements over the initialization methods. Table 7 summarizes the results. Again, the stochastic hill climbing methods were able to significantly improve the quality of the instantiations created.\n11. We compare pure and stochastic hill climbing to evaluate what can be gained by stochastic methods. The initial hill climb usually requires very few evaluations, so if stochastic methods make little difference, efficiency considerations would dictate that pure hill climbing be used.\nIn the third experiment, we performed the same type of experiment on the Pigs network. None of the search methods were able to improve on ML initialization. We concluded that the problem was too easy. Pigs has over 400 variables, and it seemed that the evidence didn\u2019t force enough dependence among the variables. We ran another experiment with Pigs, this time using 200 MAP variables and 20 evidence values to make it more difficult. Table 8 summarizes the results. Again, the stochastic methods were able to improve significantly over the initialization methods.\nWe also ran these algorithms on the same queries on the real world networks that were used in Section 3.4 to be able to compare performance between the methods. Table 9 shows how they performed and compares their performance to the mini\u2013bucket algorithms. Table 10 gives a more detailed exposition of their performance. There are a couple of interesting items about this data set. One is the surprising performance of simple sequential initialization. Over all, it performed the best of the approximate algorithms. Another interesting thing to note is that hill climbing often negatively impacted performance. This suggests that marginal computations are often more accurate than probability of evidence computations. This problem is especially acute in networks with significant determinism. While belief propagation believes a configuration has significant probability, it may actually have 0 probability because one of its constraints is violated. These experiments suggest that it is possible to improve on the standard approaches used when inference is intractable (approximating MPE, or ML or using a mini\u2013bucket scheme) by using belief propagation to estimate the joint, and successively moving to states with higher approximate scores."}, {"heading": "5. Conclusion", "text": "MAP is a computationally very hard problem which is not in general amenable to exact solution even for very restricted classes (ex. polytrees). Even approximation is difficult. Still, we can produce approximations that are much better than those currently used by practitioners (MPE, ML) through using approximate optimization and inference methods. We showed one method based on belief propagation and stochastic hill climbing that produced significant improvements over those methods, extending the realm for which MAP can be approximated to networks that work well with belief propagation."}, {"heading": "Acknowledgement", "text": "This work has been partially supported by MURI grant N00014-00-1-0617"}, {"heading": "Appendix A. Proofs of Theorems", "text": "Proof of Theorem 2\nWe want to show that MAP remains NPPP-complete even when restricted to networks of depth 2, with no evidence, only binary variables, and parameters that are arbitrarily close to 1/2. Membership in NPPP was established in Theorem 1. We show hardness by providing a reduction from E-MAJSAT.\nThe flow of the proof is as follows. First, we construct a depth 2 Bayesian network from the E-MAJSAT problem. Then, we show that by asserting some evidence, we can overcome the constraint that all of the parameters lie within [1/2 \u2212 \u01eb, 1/2 + \u01eb], and use MAP to obtain the E-MAJSAT solution. Finally, we show that by including the evidence variables as MAP variables instead, no evidence is needed.\nThe network is constructed as follows. Each logical variable xi induces a network variable Xi with uniform prior. Each operand yi induces a network variable Yi with a uniform prior. Notice that they are not connected, so unlike the reduction in Theorem 1, the CPT entries do not enforce that an operator variable take on a value that is consistent its operands with respect to the to the logic of the formula. For example, the network will assign positive probability to an \u201cand\u201d node being true, and both of its operand variables being false. We say that a variable Yi is consistent with the variables Pi associated with its operands, if the logical function of operator yi yields the value of Yi on input pi. Consistency, instead of being enforced rigidly, is weighted by introducing r weight variables Wi1...Wir (the actual value of r will be discussed subsequently) associated with each Yi. The parents of Wij are the operator variable Yi and the variables corresponding to its operands. The CPT of Wij is defined as\nPr(Wij = T |Yi,Pi) =\n{\n1 2 + \u01eb Yi is consistent with Pi 1 2 otherwise\nwhere Pi are the variables associated with the operands of yi. Finally, as children of Ym (which corresponds to the top level operator) we add r additional binary variables W1...Wr,\nwhere\nPr(Wj = T |Ym) =\n{\n1 2 + \u01eb if Ym = T 1 2 otherwise\nfor the purpose of weighting states in which the formula is satisfied. See Figure 8 for an example network construction.\nNow, consider the probability of a complete instantiation of the variables, where all of the weight variables (which includes both the consistency weighting variables Wij, and satisfiability weighting variables Wi) are set to true, which we denote as W = T.\nPr(x,y,W = T) =\n(\n1\n2\n)m+n (1\n2 + \u01eb\n)kr (1\n2\n)(m\u2212k)r (1\n2 + \u01eb\n)sr (1\n2\n)(1\u2212s)r\nwhere x is an instantiation of X1...Xn, y is an instantiation of Y1...Ym, k is the number of operator variables that are consistent with their operands variables and s=1 if Ym = T , 0 otherwise. For a consistent satisfying assignment xy,\nPr(x,y,W = T) =\n(\n1\n2\n)m+n (1\n2 + \u01eb\n)(m+1)r\nwhile for an inconsistent, or unsatisfying assignment xy,\nPr(x,y,W = T) \u2264\n(\n1\n2\n)m+n+r\n( 1\n2 + \u01eb)mr.\nWe want to choose r such that the probability of a single consistent satisfying instance is greater than twice the sum of all of the probabilities of inconsistent or unsatisfying instances. The number of inconsistent or unsatisfying instances is bounded by 2n+m, so we want an r where\n(\n1\n2\n)m+n (1\n2 + \u01eb\n)(m+1)r > 2n+m+1 ( 1\n2\n)m+n+r\n( 1\n2 + \u01eb)mr.\nSolving for r yields\nr > (m+ n+ 1)\n1 + log2\n(\n1 2 + \u01eb\n)\nwhich is linear in the size of the formula, so the size of the reduction remains polynomially bounded.\nLet C = Pr(x,y,W = T) = (\n1 2 )m+n ( 1 2 + \u01eb )(m+1)r where xy is a consistent satisfying\ninstance. Then, for a particular instantiation q of X1...Xk,\nPr(q,W = T) = \u2211\nxk+1,...,xn,y1,...,ym\nPr(q, xk+1, ...xn, y1, ...ym,W = T)\n= #qC + \u2211\nxy\nPr(xy,W = T)\nwhere #q is the number of complete variable instantiations compatible with q that satisfies \u03c6 and xy ranges over the inconsistent and unsatisfying assignments compatible with x1...xk. Since for any instantiation of x there is only one compatible instantiation, #q\nalso corresponds to the number of satisfiable instantiations of \u03c6 consistent with q. The choice of r ensures that the sum of the unsatisfying or inconsistent instantiations is less than C/2, and is always greater than 0 assuming there is at least one operator (since there is some instantiation where the operator and its operands are not consistent). Thus #qC < Pr(q,W = T) < (#q+1/2)C. There are 2\nn\u2212k possible instantiations of Xk+1...Xn, so if half or less are satisfied then Pr(q,W = T ) < (2n\u2212k\u22121+1/2)C, while if more than half are satisfied then Pr(q,W = T ) > (2n\u2212k\u22121 + 1)C. Thus the D-MAP query, using MAP variables X1...Xk, evidence W = T, and threshold (2\nn\u2212k\u22121 + 1)C is true if and only if the E-MAJSAT query is also true.\nNow, notice that in every table that contains a weight variable, the value of the configuration where it takes on true is greater or equal to the value when it takes on false. Thus Pr(q,W = T) \u2265 Pr(q,W = w), for all q and w. It then follows that MAP(X1...Xk,W = T)=MAP(X1...XkW, \u2205). Therefore, the D-MAP query, using MAP variables X1...Xk,W and no evidence, with threshold (2n\u2212k\u22121+1)C is true if and only if the E-MAJSAT query is also true. \u2737\nProof of Theorem 8\nAs part of the proof of the theorem, we will use the following lemma.\nLemma 9 For all x \u2265 1, 4x+ 12 > 1\nln(1+ 1 4x\n) .\nProof: First, we show that f(x) = ln(1+ 14x)\u2212 1\n4x+ 1 2\nis monotonically decreasing for x \u2265 1.\ndf dx =\n\u22121\n4x2 + x +\n4\n(4x+ 12) 2\n= 16x2 + 4x\u2212 (4x+ 12) 2\n(4x+ 12) 2(4x2 + x)\n= \u22121\n4(4x+ 12 ) 2(4x2 + x)\nwhich is always negative for x \u2265 1, and hence f(x) is monotonically decreasing. Now, since f(x) is monotonically decreasing, and lim\nx\u2192\u221e f(x) = 0, f(x) must be strictly\npositive. Thus, for all x \u2265 1, ln(1 + 14x) > 1\n4x+ 1 2\nwhich implies 4x+ 12 > 1\nln(1+ 1 4x\n) . \u2737\nThe basic idea of the proof is to show by repeating the construction of Theorem 7 a polynomial number of times, that if we can approximate MAP on polytrees within relative error 2size \u01eb\nfor any \u01eb \u2208 [0, 1), where the size of the network is parameterized by the number of conditional probability parameters, then we can solve SAT in polynomial time.\nGiven a SAT problem instance with n variables, and m clauses, we create a Bayesian network by replicating the construction from Theorem 7 q times, and connecting them to form a polytree. Specifically, to each copy i of the construction, we add a variable Bi (we use superscripts to denote variables associated with a particular copy of the construction), with parents Sin, and if i > 1, parent B i\u22121 (see Figure 9). The conditional probability of Bi is uniform for all parent instantiations. We choose q to satisfy (1 + 14m) q > 2size \u01eb\n. We now show that q can be chosen so that the network size remains polynomial in the size of the logical formula. The resulting network has q(2n + 2) variables, and each conditional probability table has at most 2(m + 1)2 parameters, so the total size of the reduction is bounded by q(m+ 1)2(4n+ 4). Replacing size with the size bound places the constraint\n(\n1 + 1\n4m\n)q\n> 2(q(m+1) 2(4n+4))\n\u01eb\non q. Since 0 \u2264 \u01eb < 1, solving for q yields (\n1 + 1\n4m\n)q\n> 2(q(m+1) 2(4n+4))\n\u01eb\nq ln\n(\n1 + 1\n4m\n)\n> q\u01eb(m+ 1)2\u01eb(4n+ 4)\u01eb ln 2\nq1\u2212\u01eb > (m+ 1)2\u01eb(4n + 4)\u01eb ln 2\nln (\n1 + 14m\n)\nq >\n\n\n(m+ 1)2\u01eb(4n+ 4)\u01eb ln 2\nln (\n1 + 14m\n)\n\n\n1\n1\u2212\u01eb\nNow, from Lemma 9, 4m+1/2 > 1/ ln(1 + 1/4m), so substitution yields a stronger bound,\nq >\n((\n4m+ 1\n4\n)\n(m+ 1)2\u01eb(4n+ 4)\u01eb ln 2\n) 1\n1\u2212\u01eb\nwhich is polynomially bounded. Thus the network can be constructed in time polynomial in the size of the formula.\nThen, for a particular instantiation x of all X variables X11 ...X q n, and evidence s asserting\nSin = 0 for each i, the probability is\nPr(x, s) = \u220f\ni\nPr(xi, Sin = 0)\n= \u220f\ni\n# clauses satisfied by xi\nm2n\nbecause each subnetwork is independent. Thus the solution M to MAP over X11 ...X q n with evidence S1n = .... = S q n = 0 is ( k m2n )q where k is the maximum number of clauses that can be simultaneously satisfied in the original SAT problem. If the problem is satisfiable then k = m, and so the approximate solution M \u2032 obeys\nM \u2032 \u2265 M\n2size \u01eb >\n(\n4m\n4m+ 1\n)q ( m\nm2n\n)q\n>\n(\nm\u2212 14 m\n)q ( 1\n2n\n)q\n=\n(\nm\u2212 14 m2n\n)q\nOn the other hand, if it isn\u2019t satisfiable, then k \u2264 m\u2212 1, so\nM \u2032 \u2264 2size \u01eb M <\n(\n4m+ 1\n4m\n)q (m\u2212 1\nm2n\n)q\n=\n(\n(4m+ 1)(m\u2212 1)\n4m\n)q ( 1\nm2n\n)q\n<\n(\nm\u2212 34 m2n\n)q\nThe upper bound of M \u2032 if the SAT problem is unsatisfiable is bounded below the lower bound of M \u2032 if it is satisfiable. Because the network construction and the bound tests can be accomplished in polynomial time, if the MAP problem itself can be approximated within a factor of 2size \u01eb in polynomial time then SAT can be decided in polynomial time."}, {"heading": "Appendix B. Generating Random Networks", "text": "We generated several types of networks to perform our experiments. We used two methods for generating the structure, and a single parametric method for generating the quantification.\nB.1 Generating the Network Structure\nThe first method is parameterized by the number of variables N and the connectivity c. This method tends to produce structures with widths that are close to c. Darwiche (2001) provides an algorithmic description.\nThe second method is parameterized by the number of variables N , and the probability p of an edge being present. We generate an ordered list of N variables, and add an edge between variables X and Y with probability p. The edges added are directed toward the variable that appears later in the order.\nB.2 Quantifying the Dependencies\nThe quantification method is parameterized by a bias parameter b. The values of the CPTs for the roots were chosen uniformly. The values for the rest of the nodes were based on a bias, where one of the values v was chosen uniformly in [0, b), and the other as 1 \u2212 v. For\nexample, for b = .1, each non root variable given its parents has one value in [0, .1), and the other in (.9, 1]. Special cases b = 0, and b = .5 produce deterministic, and uniformly random quantifications respectively."}], "references": [{"title": "An optimal approximation algorithm for Bayesian inference", "author": ["P. Dagum", "M. Luby"], "venue": "Artificial Intelligence,", "citeRegEx": "Dagum and Luby,? \\Q1997\\E", "shortCiteRegEx": "Dagum and Luby", "year": 1997}, {"title": "Recursive conditioning", "author": ["A. Darwiche"], "venue": "Artificial Intelligence,", "citeRegEx": "Darwiche,? \\Q2001\\E", "shortCiteRegEx": "Darwiche", "year": 2001}, {"title": "A differential approach to inference in Bayesian networks", "author": ["A. Darwiche"], "venue": "Journal of the ACM,", "citeRegEx": "Darwiche,? \\Q2003\\E", "shortCiteRegEx": "Darwiche", "year": 2003}, {"title": "Partial abductive inference in Bayesian belief networks using a genetic algorithm", "author": ["L. de Campos", "J. Gamez", "S. Moral"], "venue": "Pattern Recognition Letters,", "citeRegEx": "Campos et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Campos et al\\.", "year": 1999}, {"title": "Mini-buckets: A general scheme for approximate inference", "author": ["R. Dechter", "I. Rish"], "venue": "Tech. rep. R62a,", "citeRegEx": "Dechter and Rish,? \\Q1998\\E", "shortCiteRegEx": "Dechter and Rish", "year": 1998}, {"title": "Bucket elimination: A unifying framework for probabilistic inference", "author": ["R. Dechter"], "venue": "In Proceedings of the 12th Conference on Uncertainty in Artificial Intelligence (UAI),", "citeRegEx": "Dechter,? \\Q1996\\E", "shortCiteRegEx": "Dechter", "year": 1996}, {"title": "Inference in belief networks: A procedural guide", "author": ["C. Huang", "A. Darwiche"], "venue": "International Journal of Approximate Reasoning,", "citeRegEx": "Huang and Darwiche,? \\Q1996\\E", "shortCiteRegEx": "Huang and Darwiche", "year": 1996}, {"title": "Bayesian updating in recursive graphical models by local computation", "author": ["F.V. Jensen", "S. Lauritzen", "K. Olesen"], "venue": "Computational Statistics Quarterly,", "citeRegEx": "Jensen et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Jensen et al\\.", "year": 1990}, {"title": "Stochastic local search for Bayesian networks", "author": ["K. Kask", "R. Dechter"], "venue": "In Seventh International Workshop on Artificial Intelligence,", "citeRegEx": "Kask and Dechter,? \\Q1999\\E", "shortCiteRegEx": "Kask and Dechter", "year": 1999}, {"title": "Triangulation of graphs\u2014algorithms giving small total state space", "author": ["U. Kjaerulff"], "venue": "Tech. rep. R-90-09,", "citeRegEx": "Kjaerulff,? \\Q1990\\E", "shortCiteRegEx": "Kjaerulff", "year": 1990}, {"title": "Local computations with probabilities on graphical structures and their application to expert systems", "author": ["S.L. Lauritzen", "D.J. Spiegelhalter"], "venue": "Journal of Royal Statistics Society, Series B,", "citeRegEx": "Lauritzen and Spiegelhalter,? \\Q1988\\E", "shortCiteRegEx": "Lauritzen and Spiegelhalter", "year": 1988}, {"title": "Stochastic boolean satisfiability", "author": ["M. Litmman", "S.M. Majercik", "T. Pitassi"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Litmman et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Litmman et al\\.", "year": 2001}, {"title": "Initial experiments in stochastic satisfiability", "author": ["M. Littman"], "venue": "In Sixteenth National Conference on Artificial Intelligence,", "citeRegEx": "Littman,? \\Q1999\\E", "shortCiteRegEx": "Littman", "year": 1999}, {"title": "The computational complexity of probabilistic planning", "author": ["M. Littman", "J. Goldsmith", "M. Mundhenk"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Littman et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Littman et al\\.", "year": 1998}, {"title": "The turbo decision algorithm", "author": ["R.J. McEliece", "E. Rodemich", "J.F. Cheng"], "venue": "In 33rd Allerton Conference on Communications, Control and Computing,", "citeRegEx": "McEliece et al\\.,? \\Q1995\\E", "shortCiteRegEx": "McEliece et al\\.", "year": 1995}, {"title": "Stochastic greedy search: Efficiently computing a most probable explanation in Bayesian networks", "author": ["O.J. Mengshoel", "D. Roth", "D.C. Wilkins"], "venue": "Tech. rep. UIUCDSR-2000-2150, U of Illinois Urbana-Champaign", "citeRegEx": "Mengshoel et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Mengshoel et al\\.", "year": 2000}, {"title": "Loopy belief propagation for approximate inference: an emperical study", "author": ["K.P. Murphy", "Y. Weiss", "M.I. Jordan"], "venue": "In Proceedings of Uncertainty in AI", "citeRegEx": "Murphy et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Murphy et al\\.", "year": 1999}, {"title": "The complexity of Markov decision processes", "author": ["C. Papadimitriou", "J. Tsitsiklis"], "venue": "Mathematics of Operations Research,", "citeRegEx": "Papadimitriou and Tsitsiklis,? \\Q1987\\E", "shortCiteRegEx": "Papadimitriou and Tsitsiklis", "year": 1987}, {"title": "A differential semantics for jointree algorithms", "author": ["J. Park", "A. Darwiche"], "venue": "In Neural Information Processing Systems (NIPS)", "citeRegEx": "Park and Darwiche,? \\Q2003\\E", "shortCiteRegEx": "Park and Darwiche", "year": 2003}, {"title": "Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference", "author": ["J. Pearl"], "venue": null, "citeRegEx": "Pearl,? \\Q1988\\E", "shortCiteRegEx": "Pearl", "year": 1988}, {"title": "On the hardness of approximate reasoning", "author": ["D. Roth"], "venue": "Artificial Intelligence,", "citeRegEx": "Roth,? \\Q1996\\E", "shortCiteRegEx": "Roth", "year": 1996}, {"title": "Propagating belief functions with local computations", "author": ["P.P. Shenoy", "G. Shafer"], "venue": "IEEE Expert,", "citeRegEx": "Shenoy and Shafer,? \\Q1986\\E", "shortCiteRegEx": "Shenoy and Shafer", "year": 1986}, {"title": "Finding MAPs for belief networks is NP\u2013hard", "author": ["S.E. Shimony"], "venue": "Artificial Intelligence,", "citeRegEx": "Shimony,? \\Q1994\\E", "shortCiteRegEx": "Shimony", "year": 1994}, {"title": "PP is as hard as the polynomial-time hierarchy", "author": ["S. Toda"], "venue": "SIAM Journal of Computing,", "citeRegEx": "Toda,? \\Q1991\\E", "shortCiteRegEx": "Toda", "year": 1991}, {"title": "Generalized belief propagation", "author": ["J. Yedidia", "W. Freeman", "Y. Weiss"], "venue": "In NIPS,", "citeRegEx": "Yedidia et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Yedidia et al\\.", "year": 2000}], "referenceMentions": [{"referenceID": 23, "context": "This is a direct result of Toda\u2019s theorem (Toda, 1991).", "startOffset": 42, "endOffset": 54}, {"referenceID": 22, "context": "D-MPE is NP-complete (Shimony, 1994).", "startOffset": 21, "endOffset": 36}, {"referenceID": 20, "context": "D-PR is PP-complete (Litmman, Majercik, & Pitassi, 2001)\u2014notice that this is the complexity of the decision version, not the functional version which is #P-complete (Roth, 1996).", "startOffset": 165, "endOffset": 177}, {"referenceID": 12, "context": "This result was stated without proof by Littman (1999).", "startOffset": 40, "endOffset": 55}, {"referenceID": 13, "context": "NP contains other important AI problems, such as probabilistic planning problems (Littman et al., 1998).", "startOffset": 81, "endOffset": 103}, {"referenceID": 23, "context": "In fact, NP contains the entire polynomial hierarchy (Toda, 1991).", "startOffset": 53, "endOffset": 65}, {"referenceID": 5, "context": "5 Results for Elimination Algorithms Solution to the general MAP problem seems out of reach, but what about for \u201ceasier\u201d networks? State\u2013of\u2013the\u2013art exact inference algorithms (variable elimination (Dechter, 1996), join trees (Lauritzen & Spiegelhalter, 1988; Shenoy & Shafer, 1986; Jensen, Lauritzen, & Olesen, 1990), recursive conditioning (Darwiche, 2001)) can compute Pr and MPE in space and time complexity that is exponential only in the width of a given elimination order.", "startOffset": 197, "endOffset": 212}, {"referenceID": 1, "context": "5 Results for Elimination Algorithms Solution to the general MAP problem seems out of reach, but what about for \u201ceasier\u201d networks? State\u2013of\u2013the\u2013art exact inference algorithms (variable elimination (Dechter, 1996), join trees (Lauritzen & Spiegelhalter, 1988; Shenoy & Shafer, 1986; Jensen, Lauritzen, & Olesen, 1990), recursive conditioning (Darwiche, 2001)) can compute Pr and MPE in space and time complexity that is exponential only in the width of a given elimination order.", "startOffset": 341, "endOffset": 357}, {"referenceID": 9, "context": "For each network, we computed the width using the min\u2013fill heuristic (Kjaerulff, 1990; Huang & Darwiche, 1996).", "startOffset": 69, "endOffset": 110}, {"referenceID": 15, "context": "6 Similar reductions were used by Papadimitriou and Tsitsiklis (1987) and Littman et al.", "startOffset": 34, "endOffset": 70}, {"referenceID": 12, "context": "6 Similar reductions were used by Papadimitriou and Tsitsiklis (1987) and Littman et al. (1998) relating to partially observable Markov decision problems, and probabilistic planning respectively.", "startOffset": 74, "endOffset": 96}, {"referenceID": 2, "context": "We can use the jointree algorithm (Park & Darwiche, 2003), or the differential inference approach (Darwiche, 2003) to compute all of the partial derivatives efficiently.", "startOffset": 98, "endOffset": 114}, {"referenceID": 19, "context": "Belief propagation was introduced as an exact inference method on polytrees (Pearl, 1988).", "startOffset": 76, "endOffset": 89}, {"referenceID": 16, "context": "We implemented the second scheme since empirically it seems to converge faster than the first scheme (Murphy et al., 1999).", "startOffset": 101, "endOffset": 122}, {"referenceID": 1, "context": "Darwiche (2001) provides an algorithmic description.", "startOffset": 0, "endOffset": 16}], "year": 2011, "abstractText": "MAP is the problem of finding a most probable instantiation of a set of variables given evidence. MAP has always been perceived to be significantly harder than the related problems of computing the probability of a variable instantiation (Pr), or the problem of computing the most probable explanation (MPE). This paper investigates the complexity of MAP in Bayesian networks. Specifically, we show that MAP is complete for NP and provide further negative complexity results for algorithms based on variable elimination. We also show that MAP remains hard even when MPE and Pr become easy. For example, we show that MAP is NP-complete when the networks are restricted to polytrees, and even then can not be effectively approximated. Given the difficulty of computing MAP exactly, and the difficulty of approximating MAP while providing useful guarantees on the resulting approximation, we investigate best effort approximations. We introduce a generic MAP approximation framework. We provide two instantiations of the framework; one for networks which are amenable to exact inference (Pr), and one for networks for which even exact inference is too hard. This allows MAP approximation on networks that are too complex to even exactly solve the easier problems, Pr and MPE. Experimental results indicate that using these approximation algorithms provides much better solutions than standard techniques, and provide accurate MAP estimates in many cases.", "creator": "dvips(k) 5.92a Copyright 2002 Radical Eye Software"}}}