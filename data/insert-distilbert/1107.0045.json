{"id": "1107.0045", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2011", "title": "Graduality in Argumentation", "abstract": "argumentation is based on the exchange and cognitive valuation of interacting arguments, followed by the selection of chosen the most acceptable of them ( for example, in either order to take a decision, to make a choice ). starting from the framework proposed by dung in 1995, our purpose is to introduce'graduality'in the selection of the best arguments, i. e., to be able to partition the set of the arguments in more than the two usual subsets of'selected'and'non - selected'arguments in order to represent different levels of selection. our basic principles idea is that an argument is all the more acceptable if it can be strongly preferred to its attackers. first, we discuss general principles underlying a'gradual'valuation of arguments based on their interactions. following these principles, we define several key valuation models for planning an abstract based argumentation system. then, we introduce'graduality'as in the concept of acceptability taxonomy of arguments. we propose new acceptability classes and a refinement of existing classes taking advantage of an available'gradual'valuation.", "histories": [["v1", "Thu, 30 Jun 2011 20:39:39 GMT  (328kb)", "http://arxiv.org/abs/1107.0045v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["c cayrol", "m c lagasquie-schiex"], "accepted": false, "id": "1107.0045"}, "pdf": {"name": "1107.0045.pdf", "metadata": {"source": "CRF", "title": "Graduality in Argumentation", "authors": ["Claudette Cayrol", "Marie-Christine Lagasquie-Schiex"], "emails": ["ccayrol@irit.fr", "lagasq@irit.fr"], "sections": [{"heading": "1. Introduction", "text": "As shown by Dung (1995), argumentation frameworks provide a unifying and powerful tool for the study of several formal systems developed for common-sense reasoning, as well as for giving a semantics to logic programs. Argumentation is based on the exchange and valuation of interacting arguments which support opinions and assertions. It can be applied, among others, in the legal domain, for collective decision support systems or for negotiation support.\nThe fundamental characteristic of an argumentation system is the interaction between arguments. In particular, a relation of attack may exist between arguments. For example, if the argument takes the form of a logical proof, arguments for a proposition and arguments against this proposition can be advanced. In that case, the attack relation relies on logical inconsistency.\nThe argumentation process is usually divided in two steps: a valuation of the relative strength of the arguments, followed by the selection of the most acceptable arguments.\nIn the valuation step, it is usual to distinguish two different types of valuations:\nintrinsic valuation: here, the value of an argument is independent of its interactions with the other arguments. This enables to simply express to what extent an argument increases the confidence in the statement it supports (see Pollock, 1992; Krause, Ambler, Elvang, & Fox, 1995; Parsons, 1997; Prakken & Sartor, 1997; Amgoud & Cayrol, 1998; Kohlas, Haenni, & Berzati, 2000; Pollock, 2001).\nc\u00a92005 AI Access Foundation. All rights reserved.\nFor example, in the work of Krause et al. (1995), using the following knowledge base, composed of (formula, probability) pairs {(\u03c61, 0.8), (\u03c62, 0.8), (\u03c63, 0.8), ((\u03c61 \u2227 \u03c62 \u2192 \u03c64), 1), ((\u03c61 \u2227 \u03c63 \u2192 \u03c64), 1)}, two arguments can be produced1:\nA1 =< {\u03c61, \u03c62, (\u03c61 \u2227 \u03c62 \u2192 \u03c64)}, \u03c64 > and A2 =< {\u03c61, \u03c63, (\u03c61 \u2227 \u03c63 \u2192 \u03c64)}, \u03c64 >.\nBoth arguments have the same weight 0.8 \u00d7 0.8 \u00d7 1 = 0.64, and the formula \u03c64 has the weight 0.64 + 0.64\u2212 0.512 = 0.7682. interaction-based valuation: here the value of an argument depends on its attackers (the arguments attacking it), the attackers of its attackers (the defenders), etc.3 Several approaches have been proposed along this line (see Dung, 1995; Amgoud & Cayrol, 1998; Jakobovits & Vermeir, 1999; Besnard & Hunter, 2001) which differ in the sets of values used. Usually, two values are considered. However, there are very few proposals which use more than two values (three values in Jakobovits & Vermeir, 1999, and an infinity of values in Besnard & Hunter, 2001). For example, in the work of Besnard and Hunter (2001), the set of values is the interval of the real line [0, 1]. In this case, with the set of arguments4 {A1, A2, A3} and considering that A1 attacks A2 which attacks A3, the value of the argument A1 (resp. A2, A3) is 1 (resp. 1 2 , 2 3).\nIntrinsic valuation and interaction-based valuation have often been used separately, according to the considered applications. Some recent works however consider a combination of both approaches (see Amgoud & Cayrol, 1998; Karacapilidis & Papadias, 2001; Pollock, 2001).\nConsidering now the selection of the more acceptable arguments, it is usual to distinguish two approaches:\nindividual acceptability : here, the acceptability of an argument depends only on its properties. For example, an argument can be said acceptable if and only if it does not have any attacker (in this case, only the interaction between arguments is considered, see Elvang-Goransson et al., 1993). In the context of an intrinsic valuation, an argument can also be said acceptable if and only if it is \u201cbetter\u201d than each of its attackers (see Amgoud & Cayrol, 1998).\ncollective acceptability: in this case, the acceptability of a set of arguments is explicitly defined. For example, to be acceptable, a set of arguments may not contain two\n1. Here, the arguments are under the form of an \u201cExplanation-Conclusion Pair\u201d. This is one possible way to compute arguments (see also Lin & Shoham, 1989; Vreeswijk, 1997; Pollock, 1992; Prakken & Sartor, 1997; Simari & Loui, 1992; Elvang-Goransson, Fox, & Krause, 1993; Kohlas et al., 2000; Amgoud & Cayrol, 2002). 2. Weights being probabilities, the weight of an argument is the probability of the conjunction of the formulae of the argument, and the weight of \u03c64 is the probability of the disjunction of A1 and A2. 3. Here, we consider only the interactions corresponding to attacks between arguments. There exist also some other types of interactions (for example, arguments which reinforce other arguments instead of attacking them, see Karacapilidis & Papadias, 2001; Verheij, 2002). For this kind of interaction, graduality has not been considered. 4. Here, the initial knowledge base is useless.\narguments such that one attacks the other (interactions between arguments are used). Dung\u2019s (1995) framework is well suited for this kind of approach but allows only for a binary classification: the argument belongs or does not belong to an acceptable set.\nIt is clear that except for intrinsic valuations, most proposals do not allow for any gradual notion of valuation or acceptability (i.e. there is a low number of levels to describe values and the acceptability is usually binary). Our aim is therefore to introduce graduality in these two steps. However, the processes of valuation and of selection are often linked together. This is the case when the selection is done on the basis of the value of arguments5 or when the selection defines a binary valuation on arguments. We will therefore:\nfirst consider and discuss the general principles concerning the definition of a gradual interaction-based valuation and then define some valuation models in an abstract argumentation system,\nthen, introduce the notion of graduality in the definition of the acceptability using the previously defined gradual valuations, but also some more classical mechanisms.\nSome graduality has already been introduced in argumentation systems. For instance, in the work of Pollock (2001), degrees of justification for beliefs are computed. Arguments are sequences of conclusive and/or prima-facie inferences. Arguments are collected in a graph where a node represents the conclusion of an argument, a support link ties a node to nodes from which it is inferred, and an attack link indicates an attack between nodes. The degree of justification of a belief is computed from the strength of the arguments concluding that belief and the strength of the arguments concluding on an attacker of the belief. Our work takes place in a more abstract framework since we do not consider any argument structure. Our valuation models are based on interactions between arguments and directly apply to arguments. We use the framework defined by Dung (1995): a set of arguments and a binary attack relation between arguments. We also use a graphical representation of argumentation systems (see Section 2). The gradualisation of interaction-based valuations will be presented in Section 3. Then, in Section 4, we will consider different mechanisms leading to gradual acceptability, sometimes relying on the gradual valuations defined in Section 3. We will conclude in Section 5. All the proofs of the properties stated in Sections 3 and 4 will be given in Appendix A."}, {"heading": "2. Dung\u2019s (1995) framework and its graphical representation", "text": "We consider the abstract framework introduced by Dung (1995). An argumentation system <A,R> is a set A of arguments and a binary relation R on A called an attack relation: consider Ai and Aj \u2208 A, AiRAj means that Ai attacks Aj or Aj is attacked by Ai (also denoted by (Ai, Aj) \u2208 R). 5. For example, using Besnard and Hunter\u2019s (2001) valuation, we can decide that all the arguments whose\nvalue is > 0.5 are selected, because 0.5 is the mean value of the set of values; Another possibility, with different valuations (interaction-based or intrinsic), is to accept an argument when its value is better than the value of each of its attackers.\nAn argumentation system is well-founded if and only if there is no infinite sequence A0, A1, . . . , An, . . . such that \u2200i, Ai \u2208 A and Ai+1RAi. Here, we are not interested in the structure of the arguments and we consider an arbitrary attack relation.\nNotation: <A,R> defines a directed graph G called the attack graph. Consider A \u2208 A, the set R\u2212(A) is the set of the arguments attacking A6 and the set R+(A) is the set of the arguments attacked by A7.\nExample 1 The system <A = {A1, A2, A3, A4},R = {(A2, A3), (A4, A3), (A1, A2)}> defines the following graph G with the root8 A3:\nA3\nA4\nA1 A2\nDefinition 1 (Graphical representation of an argumentation system) Let G be the attack graph associated with the argumentation system <A,R>, we define:\nLeaf of the attack graph A leaf of G is an argument A \u2208 A without attackers9.\nPath in the attack graph A path from A to B is a sequence of arguments C = A1 \u2212 . . .\u2212An such that:\nA = A1, A1RA2, . . . , An\u22121RAn, An = B.\nThe length of the path is n \u2212 1 (the number of edges that are used in the path) and will be denoted by lC.\nA special case is the path10 from A to A whose length is 0.\nThe set of paths from A to B will be denoted by C(A,B).\n6. R\u2212(A) = {Ai \u2208 A|AiRA}. 7. R+(A) = {Ai \u2208 A|ARAi}. 8. The word \u201croot\u201d is used in an informal sense (it just means that there are in the graph some paths\nleading to this node). This term and other terms (leaf, branch, path, . . . ) which are used in this document are standard in graph theory but may have a different definition. They are usual terms in the argumentation domain. Please see Definition 1 in order to know their precise meaning in this document. These definitions simply take into account the fact that the directed edges of our graph link attackers to attacked argument). 9. A is a leaf iff R\u2212(A) = \u2205. 10. We will assume that there exists an infinity of such paths. This assumption greatly simplifies the handling\nof leaves later in the paper.\nDependence, independence, root-dependence of a path Consider 2 paths CA \u2208 C(A1, An) and CB \u2208 C(B1, Bm). These two paths will be said dependent iff \u2203Ai \u2208 CA, \u2203Bj \u2208 CB such that Ai = Bj. Otherwise they are independent.\nThese two paths will be said root-dependent in An iff An = Bm and \u2200Ai 6= An \u2208 CA, 6 \u2203Bj \u2208 CB such that Ai = Bj.\nCycles in the attack graph A cycle11 is a path C = A1\u2212 . . .\u2212An \u2212A1 such that \u2200i, j \u2208 [1, n], if i 6= j, then Ai 6= Aj. A cycle C is isolated iff \u2200A \u2208 C, 6 \u2203B \u2208 A such that BRA and B 6\u2208 C. Two cycles CA = A1\u2212 . . .\u2212An \u2212A1 and CB = B1\u2212 . . .\u2212Bm \u2212B1 are interconnected iff \u2203i \u2208 [1, n],\u2203j \u2208 [1,m] such that Ai = Bj.\nWe use the notions of direct and indirect attackers and defenders. The notions introduced here are inspired by related definitions first introduced by Dung (1995) but are not strictly equivalent12.\nDefinition 2 (Direct/Indirect Attackers/Defenders of an argument) Consider A \u2208 A:\nThe direct attackers of A are the elements of R\u2212(A). The direct defenders of A are the direct attackers of the elements of R\u2212(A). The indirect attackers of A are the elements Ai defined by: \u2203C \u2208 C(Ai, A) such that lC = 2k + 1, with k \u2265 1. the indirect defenders of A are the elements Ai defined by:\n\u2203C \u2208 C(Ai, A) such that lC = 2k, with k \u2265 2.\nIf the argument A is an attacker (direct or indirect) of the argument B, we say that A attacks B (or that B is attacked by A). In the same way, if the argument A is a defender (direct or indirect) of the argument B, then A defends B (or B is defended by A).\nNote that an attacker can also be a defender (for example, if A1 attacks A2 which attacks A3, and A1 also attacks A3). In the same way, a direct attacker can be an indirect attacker (for example, if A1 attacks A2 which attacks A3 which attacks A4, and A1 also attacks A4) and the same thing may occur for the defenders.\nDefinition 3 (Attack branch and defence branch of an argument) Consider A \u2208 A, an attack branch (resp. defence branch) for A is a path in G from a leaf to A whose length is odd (resp. even). We say that A is the root of an attack branch (resp. a defence branch).\n11. This definition of a cycle corresponds to the definition of an elementary cycle in graph theory (an elementary cycle does not contain 2 edges with the same initial extremity, or the same ending extremity). 12. In Dung\u2019s (1995) work, direct attackers (resp. defenders) are also indirect attackers (resp. defenders) which is not true in our definitions.\nNote that this notion of defence is the basis of the usual notion of reinstatement (B attacks C, A attacks B and C is \u201creinstated\u201d because of A). In this paper, reinstatement is taken into account indirectly, because the value of the argument C and the possibility for selecting C will be increased thanks to the presence of A. All these notions are illustrated on the following example:\nExample 2\nA1 A2\nA3A4\nB2\nC1 C2\nD2\nC3\nD1\nE1\nB1\nA\nOn this graph G, we can see:\na path from C2 to A whose length is 2 (C2 \u2212B1 \u2212A), 2 cycles A1\u2212A3\u2212A2\u2212A1 and A1\u2212A3\u2212A4\u2212A1, of length 3, which are not isolated (note that A1 \u2212 A3 \u2212 A2 \u2212 A1 \u2212 A3 \u2212A4 \u2212A1 is not a cycle with our definition), the two previous cycles are interconnected (in A1 and A3), the paths D1\u2212C1\u2212B1 and C3\u2212B2\u2212A are independent, the paths D1\u2212C1\u2212B1\u2212A and C3\u2212B2\u2212A are root-dependent and the paths D1\u2212C1\u2212B1\u2212A and C2\u2212B1\u2212A are dependent, D1, C2, E1 are the leaves of G, D1\u2212C1\u2212B1\u2212A is an attack branch for A whose length is 3, C2 \u2212B1 \u2212A is a defence branch for A whose length is 2, C2, B1 and B2 are the direct attackers of A, C1, C2 (which is already a direct attacker of A) and C3 are the direct defenders of A,\nD1 and D2 are the two indirect attackers of A, E1 is the only indirect defender of A."}, {"heading": "3. Graduality in interaction-based valuations", "text": "We consider two different valuation methods for taking into account the quality of attackers and defenders of an argument in order to define the value of an argument using only the interaction between arguments13:\nIn the first approach, the value of an argument only depends on the values of the direct attackers of this argument. Therefore, defenders are taken into account through the attackers. This approach is called local.\nIn the second approach, the value of an argument represents the set of all the attack and the defence branches for this argument. This approach is called global.\nThe main difference between these two approaches is illustrated by the following example:\nB\nD C1\nC2\nC\u2019 B\u2019\n13. We pursue a work initiated in (Cayrol & Lagasquie-Schiex, 2003c) and propose some improvements.\nIn the local approach, B has two direct attackers (C2 and C1) whereas B \u2032 has only one (C \u2032). Thus B\u2032 is better than B (since B\u2032 suffers one attack whereas B suffers two attacks). In the global approach, two branches (one of attack and one of defence) lead to B whereas only one branch of attack leads to B\u2032. Thus B is better than B\u2032 (since it has at least one defence whereas B\u2032 has none). In this case, C1 loses its negative status of attacker, since it is in fact \u201ccarrying a defence\u201d for B."}, {"heading": "3.1 Local approach (generic valuation)", "text": "Some existing proposals can already be considered as examples of local valuations.\nIn Jakobovits and Vermeir\u2019s (1999) approach, a labelling of a set of arguments assigns a status (accepted, rejected, undecided) to each argument using labels from the set {+,\u2212, ?}. + (resp. \u2212, ?) represents the \u201caccepted\u201d (resp. \u201crejected\u201d, \u201cundecided\u201d) status. Intuitively, an argument labelled with ? is both supported and weakened.\nDefinition 4 (Jakobovits and Vermeir\u2019s labellings, 1999) Let <A,R> be an argumentation system. A complete labelling of <A,R> is a function Lab : A \u2192 {+, ?,\u2212} such that:\n1. If Lab(A) \u2208 {?,\u2212} then \u2203B \u2208 R\u2212(A) such that Lab(B) \u2208 {+, ?}\n2. If Lab(A) \u2208 {+, ?} then \u2200B \u2208 R\u2212(A) \u222aR+(A), Lab(B) \u2208 {?,\u2212}\nThe underlying intuition is that an argument can only be weakened (label \u2212 or ?) if one of its direct attackers is supported (condition 1); an argument can get a support only if all its direct attackers are weakened and an argument which is supported (label + or ?) weakens the arguments it attacks (condition 2). So:\nIf A has no attacker Lab(A) = +. If Lab(A) =? then \u2203B \u2208 R\u2212(A) such that Lab(B) =?. If (\u2200B \u2208 R\u2212(A), Lab(B) = \u2212) then Lab(A) = +. If Lab(A) = + then \u2200B \u2208 R\u2212(A) \u222aR+(A), Lab(B) = \u2212.\nEvery argumentation system can be completely labelled. The associated semantics is that S is an acceptable set of arguments iff there exists a complete labelling Lab of <A,R> such that S = {A|Lab(A) = +}. Other types of labellings are introduced by Jakobovits and Vermeir (1999) among which the so-called \u201crooted labelling\u201d which induces a corresponding \u201crooted\u201d semantics. The idea is to reject only the arguments attacked by accepted arguments: an attack by an \u201cundecided\u201d argument is not rooted since an \u201cundecided\u201d attacker may become rejected.\nDefinition 5 (Jakobovits and Vermeir\u2019s labellings, 1999 \u2013 continuation) The complete labelling Lab is rooted iff \u2200A \u2208 A, if Lab(A) = \u2212 then \u2203B \u2208 R\u2212(A) such that Lab(B) = +.\nThe rooted semantics enables to clarify the links between all the other semantics introduced by Jakobovits and Vermeir (1999) and some semantics introduced by Dung (1995).\nExample 3 On the following example: An An\u22121 A2 A1\nFor n even, we obtain Lab(An) = Lab(An\u22122) = . . . = Lab(A2) = + and Lab(An\u22121) = Lab(An\u22123) = . . . = Lab(A1) = \u2212. For n odd, we obtain Lab(An) = Lab(An\u22122) = . . . = Lab(A1) = + and Lab(An\u22121) = Lab(An\u22123) = . . . = Lab(A2) = \u2212\nAnother type of local valuation has been introduced recently by Besnard and Hunter (2001) for \u201cdeductive\u201d arguments. The approach can be characterised as follows. An argument is structured as a pair \u3008support, conclusion\u3009, where support is a consistent set of formulae that enables to prove the formula conclusion. The attack relation considered here is strict and cycles are not allowed. The notion of a \u201ctree of arguments\u201d allows a concise and exhaustive representation of attackers and defenders of a given argument, root of the tree. A function, called a \u201ccategoriser\u201d, assigns a value to a tree of arguments. This value represents the relative strength of an argument (root of the tree) given all its attackers and defenders. Another function, called an \u201caccumulator\u201d, synthesises the values assigned to all the argument trees whose root is an argument for (resp. against) a given conclusion. The phase of categorisation therefore corresponds to an interaction-based valuation. Besnard and Hunter (2001) introduce the following function Cat:\nif R\u2212(A) = \u2205, then Cat(A) = 1 if R\u2212(A) 6= \u2205 with R\u2212(A) = {A1, . . . , An}, Cat(A) = 11+Cat(A1)+...+Cat(An)\nIntuitively, the larger the number of direct attackers of an argument, the lower its value. The larger the number of defenders of an argument, the larger its value.\nExample 3 (continuation) We obtain: Cat(An) = 1, Cat(An\u22121) = 0.5, Cat(An\u22122) = 0.66, Cat(An\u22123) = 0.6, . . . , and Cat(A1) = ( \u221a 5\u2212 1)/2 when n \u2192 \u221e (this value is the inverse of the golden ratio14). So, we have: If n is even Cat(An\u22121) \u2264 . . . \u2264 Cat(A3) \u2264 Cat(A1) \u2264 Cat(A2) \u2264 . . . \u2264 Cat(An) = 1 If n is odd Cat(An\u22121) \u2264 . . . \u2264 Cat(A2) \u2264 Cat(A1) \u2264 Cat(A3) \u2264 . . . \u2264 Cat(An) = 1\nOur approach for local valuations is a generalisation of these two previous proposals in the sense that Besnard and Hunter\u2019s (2001) Cat function and Jakobovits and Vermeir\u2019s (1999) labellings are instances of our approach. The main idea is that the value of an argument is obtained with the composition of two functions:\none for aggregating the values of all the direct attackers of the argument; so, this function computes the value of the \u201cdirect attack\u201d;\nthe other for computing the effect of the \u201cdirect attack\u201d on the value of the argument: if the value of the \u201cdirect attack\u201d increases then the value of this argument decreases, if the value of the \u201cdirect attack\u201d decreases then the value of this argument increases.\n14. The golden ratio is a famous number since the antiquity which has several interesting properties in several domains (architecture, for example).\nLet (W,\u2265) be a totally ordered set with a minimum element (VMin) and a subset V of W , that contains VMin and with a maximum element VMax.\nDefinition 6 (Generic gradual valuation) Let <A,R> be an argumentation system. A valuation is a function v : A \u2192 V such that:\n1. \u2200A \u2208 A, v(A) \u2265 VMin\n2. \u2200A \u2208 A, if R\u2212(A) = \u2205, then v(A) = VMax\n3. \u2200A \u2208 A, if R\u2212(A) = {A1, . . . , An} 6= \u2205, then v(A) = g(h(v(A1), . . . , v(An)))\nwith h : V \u2217 \u2192 W such that (V \u2217 denotes the set of all finite sequences of elements of V )\nh(x) = x\nh() = VMin For any permutation (xi1, . . . , xin) of (x1, . . . , xn), h(xi1, . . . , xin) = h(x1, . . . , xn) h(x1, . . . , xn, xn+1) \u2265 h(x1, . . . , xn) if xi \u2265 x\u2032i then h(x1, . . . , xi, . . . , xn) \u2265 h(x1, . . . , x\u2032i, . . . , xn)\nand g : W \u2192 V such that\ng(VMin) = VMax g(VMax) < VMax g is non-increasing (if x \u2264 y then g(x) \u2265 g(y))\nNote that h(x1, . . . , xn) \u2265 max(x1, . . . , xn) is a logical consequence of the properties of the function h. A first property on the function g explains the behaviour of the local valuation in the case of an argument which is the root of only one branch (like in Example 3):\nProperty 1 The function g satisfies for all n \u2265 1:\ng(VMax) \u2264 g3(VMax) \u2264 . . . \u2264 g2n+1(VMax) \u2264 g2n(VMax) \u2264 . . . \u2264 g2(VMax) \u2264 VMax\nMoreover, if g is strictly non-increasing and g(VMax) > VMin, the previous inequalities become strict.\nA second property shows that the local valuation induces an ordering relation on arguments:\nProperty 2 (Complete preordering) Let v be a valuation in the sense of Definition 6. v induces a complete15 preordering on the set of arguments A defined by: A B iff v(A) \u2265 v(B).\nA third property handles the cycles:\n15. A complete preordering on A means that any two elements of A are comparable.\nProperty 3 (Value in a cycle) Let C be an isolated cycle of the attack graph, whose length is n. If n is odd, all the arguments of the cycle have the same value and this value is a fixpoint of the function g. If n is even, the value of each argument of the cycle is a fixpoint of the function gn.\nThe following property shows the underlying principles satisfied by all the local valuations defined according to our schema:\nProperty 4 (Underlying principles) The gradual valuation given by Definition 6 respects the following principles:\nP1 The valuation is maximal for an argument without attackers and non maximal for an attacked and undefended argument.\nP2 The valuation of an argument is a function of the valuation of its direct attackers (the \u201cdirect attack\u201d).\nP3 The valuation of an argument is a non-increasing function of the valuation of the \u201cdirect attack\u201d.\nP4 Each attacker of an argument contributes to the increase of the valuation of the \u201cdirect attack\u201d for this argument.\nThe last properties explain why Jakobovits and Vermeir (1999) and Besnard and Hunter (2001) propose instances of the local valuation described in Definition 6:\nProperty 5 (Link with Jakobovits & Vermeir, 1999) Every rooted labelling of <A,R> in the sense of Jakobovits and Vermeir (1999) can be defined as an instance of the generic valuation such that:\nV = W = {\u2212, ?,+} with \u2212 < ? < +, VMin = \u2212, VMax = +, g defined by g(\u2212) = +, g(+) = \u2212, g(?) =? and h is the function max.\nProperty 6 (Link with Besnard & Hunter, 2001) The gradual valuation of Besnard and Hunter (2001) can be defined as an instance of the generic valuation such that:\nV = [0, 1], W = [0,\u221e[, VMin = 0, VMax = 1, g : W \u2192 V defined by g(x) = 11+x and h defined by h(x1, . . . , xn) = x1 + . . .+ xn.\nNote that, in the work of Besnard and Hunter (2001), the valued graphs are acyclic. However, it is easy to show that the valuation proposed by Besnard and Hunter (2001) can be generalised to graphs with cycles (in this case, we must solve second degree equations \u2013 see Example 5).\nExample 4 Consider the following graph:\nB1 B2 B3 B4\nA\nD1 D2 D3\nC1 C3 C4C2\nE1\nIn this example, with the generic valuation, we obtain:\nv(E1) = v(D2) = v(D3) = v(C4) = v(B4) = VMax v(D1) = v(C2) = v(C3) = v(B3) = g(VMax) v(C1) = v(B2) = g 2(VMax) v(B1) = g(h(g 2(VMax), g(VMax))) v(A) = g(h(g(h(g2(VMax), g(VMax))), g 2(VMax), g(VMax), VMax))\nSo, we have: E1, D2, D3, C4, B4\nC1, B2\nD1, C2, C3, B3\nHowever, the constraints on v(A) and v(B1) are insufficient to compare A and B1 with the other arguments. The same problem exists if we reduce the example to the hatched part of the graph in the previous figure; we obtain E1, D2 C1 D1, C2, but A and B1 cannot be compared with the other arguments16. Now, we use the instance of the generic valuation proposed by Besnard and Hunter (2001):\nv(E1) = v(D2) = v(D3) = v(C4) = v(B4) = 1, v(D1) = v(C2) = v(C3) = v(B3) = 1 2 , v(C1) = v(B2) = 2 3 ,\n16. v(A) = g2(h(g2(VMax, g(VMax))) and v(B1) = g(h(g 2(VMax), g(VMax))).\nv(B1) = 6 13 , v(A) = 78283 .\nSo, we have: E1, D2, D3, C4, B4\nC1, B2\nD1, C2, C3, B3\nB1 A\nHowever, if we reduce the example to the hatched part of the graph, then the value of A is 13 19 . So, v(A) is better than v(B1) and v(D1), but also than v(C1) (A becomes better than its defender).\nExample 5 (Isolated cycle) Consider the following graph reduced to an isolated cycle:\nB\nA\n.\nA generic valuation gives v(A) = v(B) = fixpoint of g2. If we use the instance proposed by Besnard and Hunter (2001), v(A) and v(B) are solutions of the following second degree equation: x2 + x\u2212 1 = 0. So, we obtain: v(A) = v(B) = \u22121+ \u221a 5\n2 \u2248 0.618 (the inverse of the golden ratio again)."}, {"heading": "3.2 Global approach (with tuples)", "text": "We now consider a second approach for the valuation step, called the global approach. Here, the key idea is that the value of A must describe the subgraph whose root is A. So, we want to memorise the length of each branch leading to A in a tuple (for an attack branch, we have an odd integer, and for a defence branch, we have an even integer). In this approach, the main constraint is that we must be able to identify the branches leading to the argument and to compute their lengths. This is very easy in the case of an acyclic graph. We therefore introduce first a global gradual valuation for acyclic graphs. Then, in the next sections, we extend our proposition to the case of graphs with cycles, and we study the properties of this global gradual valuation."}, {"heading": "3.2.1 Gradual valuation with tuples for acyclic graphs", "text": "First, in order to record the lengths of the branches leading to the arguments, we use the notion of tuples and we define some operations on these tuples:\nDefinition 7 (Tuple) A tuple is a sequence of integers. The tuple (0, . . . , 0, . . .) \ufe38 \ufe37\ufe37 \ufe38\n\u221e\nwill be\ndenoted by 0\u221e. The tuple (1, . . . , 1, . . .) \ufe38 \ufe37\ufe37 \ufe38\n\u221e\nwill be denoted by 1\u221e.\nNotation 1 T denotes the set of the tuples built with positive integers.\nDefinition 8 (Operations on the tuples) We have two kinds of operations on tuples:\nthe concatenation of two tuples is defined by the function \u22c6 : T \u00d7 T \u2192 T such that\n0\u221e \u22c6 t = t \u22c6 0\u221e = t for t 6= () (x1, . . . , xn, . . .) \u22c6 (x \u2032 1, . . . , x \u2032 n, . . .) = Sort(x1, . . . , xn, . . . , x \u2032 1, . . . , x \u2032 n, . . .)\nSort being the function which orders a tuple by increasing values. the addition of a tuple and an integer is defined by the function \u2295 : T \u00d7N\u2192 T such that\n0\u221e \u2295 k = (k) ()\u2295 k = ()\n(x1, . . . , xn)\u2295 k = (x1 + k, . . . , xn + k) (x1, . . . , xn, . . .)\u2295 k = (x1 + k, . . . , xn + k, . . .) if (x1, . . . , xn, . . .) 6= 0\u221e\nNote that we allow infinite tuples, among other reasons, because they are needed later in order to compute the ordering relations described in Section 3.2.4 (in particular when the graph is cyclic). The operations on the tuples have the following properties:\nProperty 7 (Properties of \u22c6 and \u2295) The concatenation \u22c6 is commutative and associative. For any tuple t and any integers k and k\u2032, (t\u2295 k)\u2295 k\u2032 = t\u2295 (k + k\u2032). For any integer k and any tuples t and t\u2032 different from 0\u221e17, (t \u22c6 t\u2032)\u2295k = (t\u2295k) \u22c6 (t\u2032\u2295k).\nIn order to valuate the arguments, we split the set of the lengths of the branches leading to the argument in two subsets, one for the lengths of defence branches (even integers) and the other one for the lengths of attack branches (odd integers). This is captured by the notion of tupled values:\nDefinition 9 (Tupled value) A tupled value is a pair of tuples vt = [vtp, vti] with:\nvtp is a tuple of even integers ordered by increased values; this tuple is called the even component of vt;\nvti is a tuple of odd integers ordered by increased values; this tuple is called the odd component of vt.\n17. Otherwise it is false : (0\u221e \u22c6 (p))\u2295 k = (p+ k), whereas (0\u221e \u2295 k) \u22c6 ((p)\u2295 k) = (k) \u22c6 (p+ k) = (k, p+ k).\nNotation 2 V denotes the subset of T \u00d7 T of all tupled values (so, \u2200vt \u2208 V, vt is a pair of tuples satisfying Definition 9).\nUsing this notion of tupled-values, we can define the computation process of the gradual valuation with tuples18 in the case of acyclic graphs.\nDefinition 10 (Valuation with tuples for acyclic graphs) Let <A,R> be an argumentation system without cycles. A valuation with tuples is a function v : A \u2192 V such that:\nIf A \u2208 A is a leaf then v(A) = [0\u221e, ()].\nIf A \u2208 A has direct attackers denoted by B1, . . . , Bn, . . . then\nv(A) = [vp(A), vi(A)] with: vp(A) = (vi(B1)\u22951)\u22c6. . .\u22c6(vi(Bn)\u22951)\u22c6. . . vi(A) = (vp(B1)\u22951)\u22c6. . .\u22c6(vp(Bn)\u22951)\u22c6. . .\nNotes: The choice of the value [0\u221e, ()] for the leaves is justified by the fact that the value of an argument memorises all the lengths of the branches leading to the argument. Using the same constraint, either vp(A) or vi(A) may be empty but not both 19. Note also that the set of the direct attackers of an argument can be infinite (this property will be used when we take into account an argumentation graph with cycles).\nExample 6 On this graph, the valuation with tuples gives the following results:\nB2\nC1 C2\nD2\nC3\nD1\nE1\nB1\nA On this graph G, we have:\nv(D1) = v(C2) = v(E1) = [0 \u221e, ()], v(C1) = v(D2) = [(), (1)], v(C3) = [(2), ()], v(B1) = [(2), (1)], v(B2) = [(), (3)], v(A) = [(2, 4), (1, 3)].\n18. This definition is different from the definition given in (Cayrol & Lagasquie-Schiex, 2003c). The ideas are the same but the formalisation is different. 19. The proof is the following:.\nIf A is not a leaf, at least one of the tuples is not empty, because there exists at least one branch whose length is > 0 leading to A (see Definitions 8 and 10). And, if A is a leaf, there also exists at least one defence branch because the path from A to A is allowed and its length is 0 (in fact, there are an infinity of such paths \u2013 see Definition 1) and no attack branch leading to the leaf (see Definition 10).\nSo, the value of a leaf is [0\u221e, ()], and it is impossible that vp(A) = vi(A) = ()."}, {"heading": "3.2.2 Study of cycles", "text": "Handling cycles raises some important issues: the notion of branch is not always useful in a cycle (for example, in an unattacked cycle like in Examples 5 and 7), and when this notion is useful, the length of a branch can be defined in different ways.\nLet us consider different examples:\nExample 7 (Unattacked cycle) The graph is reduced to an unattacked cycle A\u2212B\u2212A which attacks the argument C:\nA B\nC\nThe notion of branch is useless in this case, because there is no leaf in the graph.\nThere are two possibilities:\nFirst, one can consider that the cycle is like an infinite branch; so A (resp. B) is the root of one branch whose length is \u221e. But the parity of the length of this branch is undefined, and it is impossible to say if this branch is an attack branch or a defence branch.\nThe second possibility is to consider that the cycle is like an infinity of branches; so A (resp. B) is the root of an infinity of attack branches and defence branches whose lengths are known and finite.\nThe second possibility means that the cycle may have two representations which are acyclic but also infinite graphs (one with the root A and the other one with the root B). This is a rewriting process of the cycle:\nA B\nB1 B2 B3 B4\nA1 A2 A3\nB5 B6\nA4\nA1 A2 A3 A4\nB1 B2 B3\nA5 A6\nB4\nThe Ai and Bi must be new arguments created during the rewriting process of the cycle.\nExample 8 (Attacked cycle) The cycle A\u2212B \u2212A is attacked by at least one argument which does not belong to the cycle (here, the attacker is the unattacked argument D):\nA B\nD\nC E\nIn this case, the notion of branch is useful because there exists one leaf in the graph, but the difficulty is to compute the length of this branch. As in Example 7, we can consider either that there is only one infinite branch (so, it is impossible to know if this branch is an attack or a defence branch), or that there is an infinity of attack branches and defence branches whose lengths are known and finite. In the second case, the graph can be rewritten into the following structures:\nA\nC\nB\nE\nD\nD\nB1 B2\nA1 A2\nB3\nA3\nA1 A2 A3\nB1 B2\nA4 A5\nB3\nA6\nD\nD\nD\nD\nThe Ai and Bi must be new arguments created during the rewriting process of the graph.\nFrom the previous examples, we have chosen to manage a cycle as an infinity of attack branches and defence branches whose lengths are known and finite because we would like to be able to apply Definition 10 in all cases (acyclic graphs and graphs with cycles). However, we need a rewriting process of the graph with cycles into an acyclic graph. There are two different cases, one for the unattacked cycles and one for the attacked cycles:\nDefinition 11 (Rewriting of an unattacked cycle) Let C = A0\u2212A1\u2212 . . .\u2212An\u22121\u2212A0 an unattacked cycle. The graph G which contains C is rewritten as follows:\n1. the cycle C is removed,\n2. and replaced by the infinite acyclic graphs, one for each Ai, i = 0 . . . n\u2212 1:\nAi \u0580 \u0580 . . . \u057f \u057f \u057f . . . Ai 1 1 Ai 2 1 . . . Ai n\u22121 1 Ai n 1 Ai n+1 1 . . .\n\u2191 . . . \u2191 \u2191 \u2191 . . . Ai 2 2 . . . Ai n\u22121 2 Ai n 2 Ai n+1 2 . . .\n. . . . . . . . . . . . . . . \u2191 \u2191 \u2191 . . .\nAi n\u22121 n\u22121 Ai n n\u22121 Ai n+1 n\u22121 . . .\n\u2191 \u2191 . . . Ai n n Ai\nn+1 n . . . \u2191 . . . Ai n+1 n+1 . . .\n3. the edges between each of the Ai and an argument which does not belong to C are kept.\nExample 7 \u2013 Unattacked cycle (continuation) The graph G containing the unattacked cycle A\u2212B \u2212A and the argument C, which is attacked by A, is rewritten as follows:\nC \u2191 A\n\u0580 \u0580 \u057f . . . A11 A 2 1 A 3 1 . . .\n\u2191 \u2191 . . . A22 A\n3 2 . . . \u2191 . . . A33 . . .\nB \u0580 \u0580 \u057f . . . B11 B 2 1 B 3 1 . . .\n\u2191 \u2191 . . . B22 B\n3 2 . . . \u2191 . . . B33 . . .\nwhere the Alk and B l k are new arguments.\nDefinition 12 (Rewriting of an attacked cycle) Let C = A0 \u2212 A1 \u2212 . . . \u2212 An\u22121 \u2212 A0 an attacked cycle, the direct attacker of each Ai is denoted Bi, if it exists. The graph G which contains C is rewritten as follows:\n1. the cycle C is removed,\n2. and replaced by the infinite acyclic graphs, one for each Ai i = 0 . . . n\u2212 1:\nAi \u0580 \u0580 . . . \u057f \u057f \u057f . . . Bi Ai 1 1 . . . Ai n\u22121 1 Ai n 1 Ai n+1 1 . . .\n\u2191 . . . \u2191 \u2191 \u2191 . . . B(i\u22121+n) mod n . . . Ai n\u22121 2 Ai n 2 Ai n+1 2 . . .\n. . . . . . . . . . . . . . . \u2191 \u2191 \u2191 . . .\nAi n\u22121 n\u22121 Ai n n\u22121 Ai n+1 n\u22121 . . .\n\u2191 \u2191 \u2191 . . . B(i+1) mod n Ai n n Ai n+1 n . . .\n\u2191 \u2191 . . . Bi Ai\nn+1 n+1 . . . \u2191 . . .\nB(i\u22121+n) mod n . . .\n(the branches leading to Bk exist iff Bk exists 20).\n3. the edges between each of the Ai and an argument which does not belong to C are kept.\n4. the edges between each of the Bi and an argument which does not belong to C are kept.\nExample 8 \u2013 Attacked cycle (continuation) The graph G containing the cycle A \u2212 B \u2212A attacked in A by the argument D and with the argument C (resp. E) attacked by A (resp. B) is rewritten as follows:\nC \u2191 A\n\u0580 \u2191 \u057f . . . D A21 A 4 1 . . .\n\u2191 \u2191 . . . A22 A 4 2 . . .\n\u2191 \u2191 . . . D A43 . . .\n\u2191 . . . A44 . . . \u2191 . . . D . . .\nE \u2191 B\n\u0580 \u2191 \u057f . . . B11 B 3 1 B 5 1 . . .\n\u2191 \u2191 \u2191 . . . D B32 B 5 2 . . .\n\u2191 \u2191 . . . B33 B 5 3 . . .\n\u2191 \u2191 . . . D B54 . . .\n\u2191 . . . B55 . . . \u2191 . . . D . . .\nwhere the Alk and B l k are new arguments.\n20. The operator mod is the modulo function.\nNote: If there exist several cycles in a graph, we have two cases.\nIf they are not interconnected, we rewrite each cycle, and the valuation of the resulting graph after rewriting does not depend on the order of cycles we select to rewrite because the valuation process only uses the length of the branches.\nIf they are interconnected, they are considered as a metacyle which is in turn attacked or unattacked and the previous methodology can be used leading to a more complex rewriting process which is not formalized here (see details and examples in Appendix B)."}, {"heading": "3.2.3 A gradual valuation with tuples for general graphs", "text": "Using the definitions given in Sections 3.2.1 and 3.2.2, the gradual valuation with tuples given by Definition 10 is applicable for arbitrary graphs after the rewriting process. Let us apply the rewriting process and Definition 10 on different examples.\nExample 7 \u2013 Unattacked cycle (continuation) Consider the following graph:\nA B\nC\nThe rewriting of this graph has been given in Section 3.2.2.\nDefinition 10 produces:\nvp(A) = (vi(A 1 1)\u2295 1) \u22c6 . . . \u22c6 (vi(An1 )\u2295 1) \u22c6 . . .\nvi(A) = (vp(A 1 1)\u2295 1) \u22c6 . . . \u22c6 (vp(An1 )\u2295 1) \u22c6 . . .\nApplying Definition 10 for different arguments in the rewritten graph produces the following equalities:\nv(Ann) = [0 \u221e, ()] for each n \u2265 1\nv(Ann\u22121) = [(), (1)] for each n \u2265 2\nv(Amn ) = [vp(A m n+2)\u2295 2, vi(Amn+2)\u2295 2] for each n \u2265 1 and m \u2265 n+ 2\nSo, using the above equalities in the formulae giving vp(A) and vi(A), we define two sequences of tuples : a sequence (xk, k \u2265 1) of infinite tuples of even integers, and a sequence (yk, k \u2265 1) of infinite tuples of odd integers\nxk = (2) \u22c6 (vi(A 2k+1 2k\u22121)\u2295 1) \u22c6 . . . \u22c6 (vi(An2k\u22121)\u2295 1) \u22c6 . . .\nyk = (1) \u22c6 (vp(A 2k+1 2k\u22121)\u2295 1) \u22c6 . . . \u22c6 (vp(An2k\u22121)\u2295 1) \u22c6 . . .\nFrom the results stated in Property 7, it is easy to prove that vp(A) = x1 and for each k \u2265 1, xk = (2) \u22c6 (xk+1 \u2295 2).\nSimilarly, vi(A) = y1 and for each k \u2265 1, yk = (1) \u22c6 (yk+1 \u2295 2).\nThese equations enable to prove that :\nFor each even integer p p > 0, p belongs to each tuple xi, i \u2265 1. For each odd integer p, p belongs to each tuple yi, i \u2265 1.\nThe proof is done by induction on p.\nSo, v(A) = v(B) = [(2, 4, 6, . . .), (1, 3, 5, . . .)]. Then, v(C) = [(2, 4, 6, . . .), (3, 5, 7, . . .)].\nNote that all the above results can be readily extended to an unattacked cycle of length n, n \u2265 2.\nProperty 8 (Properties of unattacked cycles) For each unattacked cycle, for each argument A of the cycle, v(A) = [(2, 4, 6, . . .), (1, 3, 5, . . .)].\nExample 8 \u2013 Attacked cycle (continuation) Consider the following graph:\nA B\nD\nC E\nThe rewriting of this graph has been given in Section 3.2.2.\nDefinition 10 produces:\nvp(A) = (vi(D)\u2295 1) \u22c6 (vi(A21)\u2295 1) \u22c6 . . . \u22c6 (vi(A2n1 )\u2295 1) \u22c6 . . .\nvi(A) = (vp(D)\u2295 1) \u22c6 (vp(A21)\u2295 1) \u22c6 . . . \u22c6 (vp(A2n1 )\u2295 1) \u22c6 . . . and also\nv(D) = [0\u221e, ()]\nv(Ann) = [(), (1)] for each n \u2265 2\nAs done in the treatment of Example 7, the formulae giving vp(A) and vi(A) can be rewritten in order to bring to light some interesting sequences of tuples.\nx\u2032k = (vi(A 2k 2k\u22121)\u2295 1) \u22c6 . . . \u22c6 (vi(A 2(k+p) 2k\u22121 )\u2295 1) \u22c6 . . .\ny\u2032k = (1) \u22c6 (vp(A 2k 2k\u22121)\u2295 1) \u22c6 . . . \u22c6 (vp(A 2(k+p) 2k\u22121 )\u2295 1) \u22c6 . . .\nThen, it is easy to prove that vp(A) = x \u2032 1 and for each k \u2265 1, x\u2032k = (x\u2032k+1 \u2295 2).\nSimilarly, vi(A) = y \u2032 1 and for each k \u2265 1, y\u2032k = (1) \u22c6 (y\u2032k+1 \u2295 2).\nThe first equation enables to prove that x\u20321 is the empty tuple 21.\nThe second equation has already been solved and produces y\u20321 = (1, 3, 5, . . .).\nSo, v(A) = [(), (1, 3, 5, . . .)]. For B, we can reason as for A, and we have v(B) = [(2, 4, 6, . . .), ()]. Then, v(C) = [(2, 4, 6, . . .), ()], v(E) = [(), (3, 5, 7 . . .)].\nNotation: in order to simplify the writing, we will not repeat the values inside the tuples (we will just indicate under each value how many times it appears). For example:\n[(2, 4, 4, 6, 6, 6, 8, 8, 8, 8 . . .), (3, 5, 5, 7, 7, 7, 9, 9, 9, 9 . . .)]\nwill be denoted by\n[(2, 4 \ufe38\ufe37\ufe37\ufe38\n2\n, 6 \ufe38\ufe37\ufe37\ufe38\n3\n, 8 \ufe38\ufe37\ufe37\ufe38\n4\n, . . .), (3, 5 \ufe38\ufe37\ufe37\ufe38\n2\n, 7 \ufe38\ufe37\ufe37\ufe38\n3\n, 9 \ufe38\ufe37\ufe37\ufe38\n4\n, . . .)]\nConclusion about cycles Cycles are expensive since all the values obtained are infinite. In appendix B, we introduce an algorithm for computing these tupled values. It uses a process of value propagation and is parameterised by a maximum \u201cnumber of runs through a cycle\u201d. This number will be used in order to stop the propagation mechanism and to obtain finite (thus incomplete) tupled values."}, {"heading": "3.2.4 Comparison of tupled values", "text": "In this section, we define the comparison relation between arguments (so, between some particular tupled values), using the following idea: an argument A is better than an argument B iff A has a better defence (for it) and a lower attack (against it). The first idea is to use a lexicographic ordering on the tuples. This lexicographic ordering denoted by \u2264lex\u221e on T is defined by: 21. The proof is the following:.\nx\u20321 contains only even integers. For each k, x\u2032k 6= 0 \u221e since x\u2032k is the result of the addition of a tuple and an integer. If x\u20321 is not empty, let e1 denote the least even integer present in x \u2032 1. As x \u2032 1 = x \u2032 2 \u2295 2, x \u2032\n2 is not empty and e2 will denote the least integer present in x \u2032\n2. We have e1 = e2 + 2. So, we are able to build a sequence of positive even integers e1, e2, . . ., which is strictly decreasing. That is impossible. So, x\u20321 = ().\nDefinition 13 (Lexicographic ordering on tuples) Let (x1, . . . , xn, . . .) and (y1, . . . , ym, . . .) be 2 finite or infinite tuples \u2208 T . (x1, . . . , xn, . . .) <lex\u221e (y1, . . . , ym, . . .) iff \u2203i \u2265 1 such that:\n\u2200j < i, xj = yj and yi exists and:\neither the tuple (x1, . . . , xn, . . .) is finite with a number of elements equal to i\u2212 1 (so, xi does not exist), or xi exists and xi < yi.\n(x1, . . . , xn, . . .) =lex\u221e (y1, . . . , ym, . . .) iff the tuples contain the same number p \u2208 N\u222a {\u221e} of elements and \u2200i, 1 \u2264 i \u2264 p, xi = yi. So, we define: (x1, . . . , xn, . . .) \u2264lex\u221e (y1, . . . , ym, . . .) iff\n(x1, . . . , xn, . . .) =lex\u221e (y1, . . . , ym, . . .) or (x1, . . . , xn, . . .) <lex\u221e (y1, . . . , ym, . . .).\nThe ordering <lex\u221e is a generalisation of the classical lexicographic ordering (see Xuong, 1992) to the case of infinite tuples. This ordering is complete but not well-founded (there exist infinite sequences which are strictly non-increasing: (0) <lex\u221e (0, 0) <lex\u221e . . .<lex\u221e (0, . . . , 0, . . .) <lex\u221e . . .<lex\u221e (0, 1)). Since the even values and the odd values in the tupled value of an argument do not play the same role, we cannot use a classical lexicographic comparison. So, we compare tupled values in two steps:\nThe \u201cfirst step\u201d compares the number of attack branches and the number of defence branches of each argument. So, we have two criteria (one for the defence and the other for the attack). These criteria are aggregated using a cautious method: we conclude if one of the arguments has more defence branches (it is better according to the defence criterion) and less attack branches than the other argument (it is also better according to the attack criterion). Note that we conclude positively only when all the criteria agree: if one of the arguments has more defence branches (it is better according to the defence criterion) and more attack branches than the other argument (it is worse according to the attack criterion), the arguments are considered to be incomparable.\nElse, the arguments have the same number of defence branches and the same number of attack branches, and a \u201csecond step\u201d compares the quality of the attacks and the quality of the defences using the length of each branch. This comparison is made with a lexicographic principle (see Definition 13) and gives two criteria which are again aggregated using a cautious method. In case of disagreement, the arguments are considered to be incomparable.\nLet us consider some examples:\n[(2), (1)] is better than [(2), (1, 1)] because there are less attack branches in the first tupled value than in the second tupled value, the numbers of defence branches being the same (first step).\n[(2), (1)] is incomparable with [(2, 2), (1, 1)] because there are less defence branches and less attack branches in the first tupled value than in the second tupled value (first step).\n[(2), (3)] is better than [(2), (1)] because there are weaker attack branches in the first tupled value than in the second tupled value (the attack branch of the first tupled value is longer than the one of the second tupled value), the defence branches being the same (second step, using the lexicographic comparison applied on even parts then on odd parts of the tupled values).\n[(2), (3)] is better than [(4), (3)] because there are stronger defence branches in the first tupled value than in the second tupled value (the defence branch is shorter in the first tupled value than in the second tupled value), the attack branches being the same (second step).\n[(2), (1)] is incomparable with [(4), (3)] because there are worse attack branches and better defence branches in the first tupled value than in the second tupled value (second step).\nThe comparison of arguments is done using Algorithm 1 which implements the principle of a double comparison (first quantitative, then qualitative) with two criteria (one defence criterion and one attack criterion) using a cautious method.\nAlgorithm 1: Comparison of two tupled values\n% Description of the parameters: % % v, w: 2 tupled values % % Notations: % % |vp| (resp. |wp|): number of elements in the even component of v (resp. w) % % if vp (resp. wp) is infinite then |vp| (resp. |wp|) is taken equal to \u221e % % |vi| (resp. |wi|): number of elements in the odd component of v (resp. w) % % if vi (resp. wi) is infinite then |vi| (resp. |wi|) is taken equal to \u221e % % As usual, \u227b will denote the strict relation associated with defined by: % % v \u227b w iff v w and not(w v). %\nbegin 1 if v = w then v w AND w v % Case 1 % 2 else 3 if |vi| = |wi| AND |vp| = |wp| then % lexicographic comparisons between vp and wp and between vi and wi % 4 if vp \u2264lex\u221e wp AND vi \u2265lex\u221e wi then v \u227b w % case 2 % 5 else 6 if vp \u2265lex\u221e wp AND vi \u2264lex\u221e wi then v \u227a w % case 3 % 7 else v 6 w AND v 6 w % Incomparable tupled values. case 4 % 8 else 9 if |vi| \u2265 |wi| AND |vp| \u2264 |wp| then v \u227a w % case 5 % 10 else 11 if |vi| \u2264 |wi| AND |vp| \u2265 |wp| then v \u227b w % case 6 % 12 else v 6 w AND v 6 w % Incomparable tupled values. Case 7 %\nend\nAlgorithm 1 defines a partial preordering on the set v(A): Property 9 (Partial preordering) Algorithm 1 defines a partial preordering on the set v(A).\nThe tupled value [0\u221e, ()] is the only maximal value of the partial preordering . The tupled value [(), 1\u221e] is the only minimal value of the partial preordering .\nNotation: the partial preordering on the set v(A) induces a partial preordering on the arguments (the partial preordering on A will be denoted like the partial preordering on v(A)): A B if and only if v(A) v(B)22. In order to present the underlying principles satisfied by the global valuation, we first consider the different ways for modifying the defence part or the attack part of an argument:\nDefinition 14 (Adding/removing a branch to an argument) Let A be an argument whose tupled value is v(A) = [vp(A), vi(A)] with vp(A) = (x p 1, . . . , x p n) and vi(A) = (x i 1, . . . , x i m) (vp(A) or vi(A) may be empty but not simultaneously). Adding (resp. removing) a defence branch to A is defined by: vp(A) becomes Sort(x p 1, . . . , x p n, x p n+1) where x p n+1 is the length of the added branch (resp. \u2203j \u2208 [1..n] such that vp(A) becomes (xp1, . . . , x p j\u22121, x p j+1, . . . , x p n)). And the same thing on vi(A) for adding (resp. removing) an attack branch to A.\nDefinition 15 (Increasing/decreasing the length of a branch of an argument) Let A be an argument whose tupled value is v(A) = [vp(A), vi(A)] with vp(A) = (x p 1, . . . , x p n) and vi(A) = (x i 1, . . . , x i m) (vp(A) or vi(A) may be empty but not simultaneously). Increasing (resp. decreasing) the length of a defence branch of A is defined by: \u2203j \u2208 [1..n] such that vp(A) becomes (xp1, . . . , x p j\u22121, x \u2032p j , x p j+1, . . . , x p n) where x \u2032p j > x p j (resp. x\u2032pj < x p j) and the parity of x \u2032p j is the parity of x p j . And the same thing on vi(A) for increasing (resp. decreasing) an attack branch to A.\nDefinition 16 (Improvement/degradation of the defences/attacks) Let A be an argument whose tupled value is v(A) = [vp(A), vi(A)] (vp(A) or vi(A) may be empty but not simultaneously). We define:\nAn improvement (resp. degradation) of the defence consists in\nadding a defence branch to A if initially vp(A) 6= 0\u221e (resp. removing a defence branch of A);\nor decreasing (resp. increasing) the length of a defence branch of A;\nor removing the only defence branch leading to A (resp. adding a defence branch leading to A if initially vp(A) = 0 \u221e);\nAn improvement (resp. degradation) of the attack consists in\nadding (resp. removing) an attack branch to A;\nor decreasing (resp. increasing) the length of an attack branch of A.\nProperty 10 (Underlying principles) Let v be a valuation with tuples (Definition 10) associated with Algorithm 1, v respects the following principles:\nP1\u2032 The valuation is maximal for an argument without attackers and non maximal for an argument which is attacked (whether it is defended or not).\n22. We will also use the notation B A defined by: B A iff A B.\nP2\u2032 The valuation of an argument takes into account all the branches which are rooted in this argument.\nP3\u2032 The improvement of the defence or the degradation of the attack of an argument leads to an increase of the value of this argument.\nP4\u2032 The improvement of the attack or the degradation of the defence of an argument leads to a decrease of the value of the argument.\nExample 4 (continuation) With the valuation with tuples, we obtain:\nv(E1) = v(D2) = v(D3) = v(C4) = v(B4) = [0 \u221e, ()], v(D1) = v(C2) = v(C3) = v(B3) = [(), (1)], v(C1) = v(B2) = [(2), ()], v(B1) = [(2), (3)], v(A) = [(2, 4), (1, 3, 3)].\nSo, we have:\nE1, D2, D3, C4, B4 \u227b\nC1, B2 E1, D2, D3, C4, B4 \u227b but also \u227b B1 A \u227b\nD1, C2, C3, B3\nA is incomparable with almost all the other arguments (except with the leaves of the graph). Similarly, on the hatched part of the graph, we obtain the following results:\nE1, D2 \u227b C1 \u227b B1 \u227b A \u227b D1, C2 A is now comparable with all the other arguments (in particular, A is \u201cworse\u201d than its defender C1 and than its direct attacker B1)."}, {"heading": "3.3 Main differences between \u201clocal\u201d and \u201cglobal\u201d valuations", "text": "Cayrol and Lagasquie-Schiex (2003c) give a comparison of these approaches with some existing approaches (Dung, 1995; Jakobovits & Vermeir, 1999; Besnard & Hunter, 2001), and also a comparison of the \u201clocal\u201d approaches and the \u201cglobal\u201d approach. The improvement of the global approach proposed in this paper does not modify the main results of this comparison. Let us recall here an example of the essential point which differentiates them (this example has already been presented at the beginning of Section 3):\nB\nD C1\nC2\nC\u2019 B\u2019\nIn the local approach, B\u2032 is better than B (since B\u2032 suffers one attack whereas B suffers two attacks). In the global approach, B is better than B\u2032 (since it has at least a defence whereas B\u2032 has none). In this case, C1 loses its negative status of attacker, since it is in fact \u201ccarrying a defence\u201d for B. The following table synthesises the results about the different proposed valuations:\nglobal approach\narguments having only attack branches\narguments having attack branches and defence branches\narguments having only defence branches\narguments never attacked\nlocal approach\narguments having several unattacked direct attackers\narguments having only one unattacked direct attacker\narguments having only one attacked direct attacker (possibly defended)\narguments having several attacked direct attackers (possibly defended)\narguments never attacked\nThe difference between the local approaches and the global approach is also illustrated by the following property:\nProperty 11 (Independence of branches in the global approach) Let A be an argument having the following direct attackers:\nA1 whose value is v(A1) = [(a 1 p1 , . . . , a1pm1 ), (a1i1 , . . . , a 1 im1 )], . . . , An whose value is v(An) = [(a n p1 , . . . , anpmn ), (a n i1 , . . . , animn )].\nLet A\u2032 be an argument having the following direct attackers:\nA1p1 whose value is v(A 1 p1 ) = [(a1p1)()], . . . , A1pm1 whose value is v(A1pm1 ) = [(a1pm1 )()], A1i1 whose value is v(A 1 i1 ) = [()(a1i1)], . . . , A1im1 whose value is v(A1im1 ) = [()(a1im1 )], . . . , Anp1 whose value is v(A n p1 ) = [(anp1)()], . . . ,\nAnpmn whose value is v(A n pmn ) = [(anpmn )()], Ani1 whose value is v(A n i1 ) = [()(ani1)], . . . , Animn whose value is v(A n imn ) = [()(animn )].\nThen v(A) = v(A\u2032).\nThis property illustrates the \u201cindependence\u201d of branches during the computation of the values in the global approach, even when these branches are not graphically independent. On the following example, A and A\u2032 have the same value [(2, 2)()] though they are the root of different subgraphs:\nAB\nC1\nC2\nC1\nC2 B2\nB1\nA\u2019\nThis property is not satisfied by the local approach since, using the underlying principles of the local approach (see Property 4), the value of the argument A must be at least as good as (and sometimes better than23) the value of the argument A\u2032 (A having one direct attacker, and A\u2032 having two direct attackers)."}, {"heading": "3.4 Conclusion about valuation step", "text": "We have proposed two different gradual valuation models and we are now able to make a distinction between different arguments using the preordering associated with a valuation model. These valuations will be used for the selection of the arguments (see Section 4)."}, {"heading": "4. Graduality and acceptability", "text": "In this section, we now shift to the selection step and introduce graduality in the notion of acceptability24. The basic idea is to select an argument depending on the non-selection of its direct attackers. Following this idea, we propose two different methods:\nThe first method consists in refining the classical partition issued from Dung\u2019s collective acceptability; this refinement may be achieved using the gradual valuations defined in Section 3.\nThe second method takes place in an individual acceptability and consists in defining a new acceptability using only the gradual valuations defined in Section 3."}, {"heading": "4.1 Dung\u2019s (1995) collective acceptability", "text": "In the framework of collective acceptability, we have to consider the acceptability of a set of arguments. This acceptability is defined with respect to some properties and the sets which satisfy these properties are called acceptable sets or extensions. An argument will be said acceptable if and only if it belongs to an extension.\n23. With the valuation proposed by Besnard and Hunter (2001), we obtain: v(A) = 3 4 and v(A\u2032) = 1 2 . 24. This work has been presented in a workshop (Cayrol & Lagasquie-Schiex, 2003b).\nDefinition 17 (Basic properties of extensions following Dung, 1995) Let <A,R> be an argumentation system, we have:\nConflict-free set A set E \u2286 A is conflict-free if and only if 6 \u2203A,B \u2208 E such that ARB.\nCollective defence Consider E \u2286 A, A \u2208 A. E collectively defends A if and only if \u2200B \u2208 A, if BRA,\u2203C \u2208 E such that CRB. E defends all its elements if and only if \u2200A \u2208 E, E collectively defends A.\nDung (1995) defines several semantics for collective acceptability: mainly, the admissible semantics, the preferred semantics and the stable semantics (with corresponding extensions: the admissible sets, the preferred extensions and the stable extensions).\nDefinition 18 (Some semantics and extensions following Dung, 1995) Let <A,R> be an argumentation system.\nAdmissible semantics (admissible set) A set E \u2286 A is admissible if and only if E is conflict-free and E defends all its elements.\nPreferred semantics (preferred extension) A set E \u2286 A is a preferred extension if and only if E is maximal for set inclusion among the admissible sets.\nStable semantics (stable extension) A set E \u2286 A is a stable extension if and only if E is conflict-free and E attacks each argument which does not belong to E (\u2200A \u2208 A\\E, \u2203B \u2208 E such that BRA).\nNote that in all the above definitions, each attacker of a given argument is considered separately (the \u201cdirect attack\u201d as a whole is not considered). Dung (1995) proves that:\nAny admissible set of <A,R> is included in a preferred extension of <A,R>. There always exists at least one preferred extension of <A,R>. If <A,R> is well-founded then there is only one preferred extension which is also the only stable extension.\nAny stable extension is also a preferred extension (the converse is false).\nThere is not always a stable extension.\nProperty 12 The set of leaves (i.e. {A|R\u2212(A) = \u2205}) is included in every preferred extension and in every stable extension."}, {"heading": "4.2 Different levels of collective acceptability", "text": "Under a given semantics, and following Dung, the acceptability of an argument depends on its membership to an extension under this semantics. We consider three possible cases25:\n25. The terminology used in this section is also used in the domain of nonmonotonic reasoning (see Pinkas & Loui, 1992): the word uni comes from the word universal which is a \u201csynonym\u201d of the word skeptical, and the word exi comes from the word existential which is a \u201csynonym\u201d of the word credulous. We have chosen to use the words uni and exi because they recall the logical quantificators \u2200 (for all) and \u2203 (exists at least one).\nthe argument can be uni-accepted, when it belongs to all the extensions of this semantics,\nor the argument can be exi-accepted, when it belongs to at least one extension of this semantics,\nor the argument can be not-accepted when it does not belong to any extension of this semantics.\nHowever, these three levels seem insufficient. For example, what should be concluded in the case of two arguments A and B which are exi-accepted and such that ARB or BRA?\nSo, we introduce a new definition which takes into account the situation of the argument w.r.t. its attackers. This refines the class of the exi-accepted arguments under a given semantics S.\nDefinition 19 (Cleanly-accepted argument) Consider A \u2208 A, A is cleanly-accepted if and only if A belongs to at least one extension of S and \u2200B \u2208 A such that BRA, B does not belong to any extension of S.\nThus, we capture the idea that an argument will be better accepted, if its attackers are not-accepted.\nProperty 13 Consider A \u2208 A and a semantics S such that each extension for S is conflictfree. If A is uni-accepted then A is cleanly-accepted. The converse is false.\nThe notion of cleanly-accepted argument refines the class of the exi-accepted arguments. For a semantics S and an argument A, we have the following states:\nA can be uni-accepted, if A belongs to all the extensions for S (so, it will also be cleanly-accepted);\nor A can be cleanly-accepted (so, it is by definition also exi-accepted); note that it is possible that the argument is also uni-accepted;\nor A can be only-exi-accepted, if A is not cleanly-accepted, but A is exi-accepted;\nor A is not-accepted if A does not belong to any extension for S.\nExample 9 Consider the following argumentation system.\nJ\nH\nI E A\nB\nC1D C2\nF\nG\nThere are two preferred extensions {D,C2, A,G} and {D,C2, E,G, I}. So, for the preferred semantics, the acceptability levels are the following:\nD, C2 and G are uni-accepted, I is cleanly-accepted but not uni-accepted,\nA and E are only-exi-accepted,\nB, C1, F , H and J are not-accepted.\nNote that, in all the cases where there is only one extension, the first three levels of acceptability coincide26. This is the case:\n26. If there is only one extension then the fact that A belongs to all the extensions is equivalent to the fact that A belongs to at least one extension. Moreover, with only one extension containing A, all the attackers of A do not belong to an extension. So, A is cleanly-accepted.\nUnder the preferred semantics, when there is no even cycle (see Doutre, 2002).\nUnder the basic semantics (another semantics proposed by Dung \u2013 see Dung, 1995; Doutre, 2002 \u2013 which is not presented here and which has only one extension).\nLooking more closely, we can prove the following result (proof in Appendix A):\nProperty 14 Under the stable semantics, the class of the uni-accepted arguments coincides with the class of the cleanly-accepted arguments.\nThen, using a result issued from the work of Dunne and Bench-Capon (2001, 2002) and reused by Doutre (2002) which shows that, when there is no odd cycle, all the preferred extensions are stable27, we apply Property 14 and we obtain the following consequence:\nConsequence 1 Under the preferred semantics, when there is no odd cycle, the class of the uni-accepted arguments coincides with the class of the cleanly-accepted arguments.\nFinally, the exploitation of the gradual interaction-based valuations (see Section 3) allows us to define new levels of collective acceptability.\nLet v be a gradual valuation and let be the associated preordering (partial or complete) on A. This preordering can be used inside each acceptability level (for example, the level of the exi-accepted arguments) in order to identify arguments which are better accepted than others.\nExample 9 (continuation) Two different gradual valuations are applied on the same graph:\nJ\nI H\nE A\nB\nC1D C2\nF\nG\n0,674 0,482\n0,5\n1 1\n0,590\n0,694 0,441\n0,666\n0,4\n0.5\nBesnard & Hunter\u2019s (2001) valuation\nWith the instance of the generic valuation proposed by Besnard and Hunter (2001) (see Section 3.1), we obtain the following comparisons:\nD,C2 \u227b I \u227b E \u227b G \u227b J \u227b C1, F \u227b A \u227b H \u227b B\n27. This corresponds to the consistent argumentation system proposed by Dung (1995).\n[(2,4,6,8,...), (3,5,7,9...)]\n[(4,6,8,10,...), (3,5,7,9,...)]\n{{ { 2 2 3\n{ { 2 3\n[(6,8,10,12,...),\n(5,7,9,11,...)]\n[(6,8,10,12,...),\n{ { { { { 2 3\n2 2 3\n(7,9,10,11,...)]\n{ {\n2 3\n{ { { 2 32\n[(4,6,8,10,...),\n(5,7,9,11,...)]\nA\nB\nC1D C2\n[(2),(1)]\n[(0,...,0),()] [(),(1)] [(0,...,0),()]\n[(),(1)]F\n[(2),()]G\nE\nHI\nJ\nValuation with tuples\nWith the global valuation with tuples presented in Section 3.2, we obtain the following comparisons:\nD,C2 \u227b G \u227b B \u227b F,C1 D,C2 \u227b A \u227b E\nD,C2 \u227b H \u227b E\nD,C2 \u227b I\nD,C2 \u227b J So, all the arguments belonging to a cycle are incomparable with G, B, F , C1 and, even between them, there are few comparison results.\nIf we apply the preordering induced by a valuation without respecting the acceptability levels defined in this section, counter-intuitive situations may happen. In Example 9, we obtain:\nWith the valuation of Besnard and Hunter (2001) and under the preferred semantics, E \u227b G despite the fact that G is uni-accepted and E is only-exi-accepted. With the valuation with tuples and under the preferred semantics, H \u227b E despite the fact that E is only-exi-accepted and H is not-accepted.\nThese counter-intuitive situations illustrate the difference between the acceptability definition and the valuation definitions (even if both use the interaction between arguments, they do not use it in the same way)."}, {"heading": "4.3 Towards a gradual individual acceptability", "text": "The individual acceptability is based on the comparison of an argument with its attackers.\nThe first proposal has been to select an argument if and only if it does not have any attacker (see Elvang-Goransson et al., 1993).\nThis has later been extended by Amgoud and Cayrol (1998) where, using a preference relation between arguments (an intrinsic valuation), an argument is accepted if and only if it is preferred to each of its attackers.\nFollowing this proposal, we propose the same mechanism but with the interaction-based valuation.\nGiven v a gradual valuation, the preordering induced by v can be directly used in order to compare, from the acceptability point of view, an argument and its attackers28. This defines a new class of acceptable arguments: well-defended arguments.\nDefinition 20 (Well-defended argument) Consider A \u2208 A, A is well-defended (for v) if and only if \u2200B \u2208 A such that BRA, B 6\u227b A.\nThus, we capture the idea that an argument will be better accepted if it is at least as good as its direct attackers (or incomparable with them in the case of a partial ordering). The set of well-defended arguments will depend on the valuation used.\nUsing this new notion, the set of the arguments is partitioned in three classes:\nthe first class contains the arguments which are not attacked,\nthe second class contains the arguments which are attacked but are well-defended,\nthe third class contains the other arguments (attacked and not well-defended).\nNote that the set of the well-defended arguments corresponds to the union of the two first classes. A further refinement uses the gradual valuation inside each of the classes as in Section 4.2.\nIn Example 9 presented in Section 4.2, the well-defended arguments are:\nD, C2, G, H and A (A is incomparable with B but better than E) for the valuation with tuples,\nthough with the valuation of Besnard and Hunter (2001) the well-defended arguments are D, C2, G, I and E (E is better than A).\nNote also that, as in the semantics of Dung (1995), Definition 20 considers the attackers one by one. It is not suitable for a valuation which handles the \u201cdirect attack\u201d as a whole (as the valuation of Besnard and Hunter (2001) \u2013 see the counterexamples presented in Section 4.4).\n28. This idea is also used in the notion of \u201cdefeat\u201d proposed by Bench-Capon (2002). So, there is a link between a \u201cwell-defended argument\u201d and an argument which is not \u201cattacked\u201d in the sense of BenchCapon (2002) by its direct attackers. Note that, in the work of Bench-Capon (2002), the valuation is an extra knowledge added in the argumentation framework. In contrast, here, the v-preference is extracted from the attack graph."}, {"heading": "4.4 Compatibility between acceptability and gradual valuation", "text": "Following the previous sections, the set of arguments can be partitioned in two different ways:\nFirst, given a semantics S and a gradual valuation v, it is possible to use the partition issued from Dung (1995) which we have refined:\nUni\u2212\nExi\u2212\naccepted\naccepted\naccepted\naccepted\nCleanly\u2212 accepted\nOnly\u2212Exi\u2212\nNot\u2212\nRefinement of each level with the gradual valuation v\nSecond, given a gradual valuation v, it is possible to use the partition induced by the notion of well-defended arguments:\nAttaked Arguments\nUnattacked Arguments\nArguments not Well\u2212defended\nAttaked but\nfor the valuation v\nWell\u2212Defended\nA very natural and interesting question is: is it possible to find a semantics S and a gradual valuation v such that the associated partitions have some compatibilities?\nThe following examples show that the class of the well-defended arguments does not correspond to the class of the cleanly-accepted arguments (in some cases, some uni-accepted arguments are even not well-defended)."}, {"heading": "4.4.1 Examples showing the non-compatibility in the general case", "text": "We give examples for each usual valuation (the global valuation with tuples and 2 instances of the generic local valuation: Besnard & Hunter, 2001; Jakobovits & Vermeir, 1999) and for the most classical semantics for acceptability (preferred semantics and stable semantics of Dung, 1995).\nCleanly-accepted argument but not well-defended: There are 3 examples (each using a distinct valuation: one for the global valuation and two for the two well-known instances of the local valuation):\nthe argument A is cleanly-accepted but it is not well-defended:\nB1\nC1\nA\nB2\nC2\nB3\nC3 1 1\n0.5 0.5 0.5\n1\n0.4\nOnly 1 preferred and stable extension = { C1, C2, C3, A} B1, B2, B3 do not belong to a preferred extension Bi A forall i = 1, 2, 3\nthe argument A is cleanly-accepted but it is not well-defended:\nC\nD\nB A\u2212 ?\n?\n?\nB doesn\u2019t belong to a preferred extension 2 preferred and stable extensions : {C,A} and {D,A} B A\nthe argument I is cleanly-accepted but it is not well-defended:\nA B C D E F G I\nH\n[(0,...0),()] [(),(1)] [(2),()] [(),(3)]\n[(),(3)]\n[(4,4),(3)]\n[(4),(5,5)] [(6,6),(5)] [(6),(7,7)]\nOnly 1 preferred and stable extension = {A,C,F,I} G doesn\u2019t belong to a preferred extension G I\nWell-defended argument but not cleanly-accepted: Similarly, for the same three valuations, we have:\nthe argument C is well-defended but it is not cleanly-accepted:\nD A C B\n?\n?? +\nOnly 1 preferred and stable extension : {D, B} C doesn\u2019t not belong to a preferred or a stable extension C B\nthe argument F is well-defended but it is not cleanly-accepted:\nB\nF\nE G H\nA\n0.618 0.618\n0.472\n0.679\n0.5 1\n2 preferred and stable extensions = {A,H,E} and {B,H,F} F belongs to a preferred and stable extension while E attacks F F E and E belongs also to a preferred and stable extension\nthe argument G is well-defended but it is not cleanly-accepted:\nA B C D E F G I\nH\n[(0,...,0),()] [(),(1)] [(2),()] [(),(3)]\n[(),(3)]\n[(4,4),(3)]\n[(4),(5,5)] [(6,6),(5)] [(6),(7,7)]\nOnly 1 preferred and stable extension = {A,C,F,I}\nG doesn\u2019t belong to a preferred or stable extension\nG F"}, {"heading": "4.4.2 Particular cases leading to compatibility", "text": "In the context of an argumentation system with a finite relation R without cycles29, the stable and the preferred semantics provide only one extension and the levels of uni-accepted, exi-accepted, cleanly-accepted coincide. In this context, there are at least two particular cases leading to compatibility.\nFirst case: It deals with the global valuation with tuples.\nTheorem 1 Let G be the graph associated with <A,R>, <A,R> being an argumentation system with a finite relation R without cycles and satisfying the following condition: \u2203 A \u2208 A such that\n\u2200Xi, leaf of G, \u2203 only one path from Xi to A, X1i \u2212 . . .\u2212X lii \u2212A with X1i = Xi and li the length of this path (if li is even, this path is a defence branch for A, else it is an attack branch),\nall the paths from Xi to A are root-dependent in A, \u2200Ai \u2208 A, \u2203Xj a leaf of G such that Ai belongs to a path from Xj to A.\nLet v be a valuation with tuples. Let S be a semantics \u2208 {preferred, stable}.\n1. \u2200B \u2208 A, B 6= A, B (exi, uni, cleanly) accepted for S iff B well-defended for v.\n2. If A is (exi, uni, cleanly) accepted for S then A is well-defended for v (the converse is false).\n3. If A is well-defended for v and if all the branches leading to A are defence branches for A then A is (exi, uni, cleanly) accepted for S.\n29. So, (A,R) is well-founded.\nNote that Theorem 1 is, in general, not satisfied by a local valuation. See the following counterexample for the valuation of Besnard and Hunter (2001):\nB1\nC1\nB2\nC2\nB3\nC3\nA0,4\n0,5 0,50,5\n1 1 1\nThe graph satisfies the condition stated in Theorem 1. The set of well-defended arguments is {C1, C2, C3} (so, A is not well-defended). Nevertheless, {C1, C2, C3, A} is the preferred extension.\nSecond case: This second case concerns the generic local valuation:\nTheorem 2 Let <A,R> be an argumentation system with a finite relation R without cycles. Let S be a semantics \u2208 {preferred, stable}. Let v be a generic local valuation satisfying the following condition (\u2217): (\u2200i = 1 . . . n, g(xi) \u2265 xi) \u21d2 (g(h(x1, . . . , xn)) \u2265 h(x1, . . . , xn)) (\u2217) \u2200A \u2208 A, A (exi, uni, cleanly) accepted for S iff A well-defended for v.\nThis theorem is a direct consequence of the following lemma:\nLemma 1 Let <A,R> be an argumentation system with a finite relation R without cycles. Let S be a semantics \u2208 {preferred, stable}. Let v be a generic local valuation satisfying the condition (\u2217).\n(i) If A is exi-accepted and A has only one direct attacker B then A B.\n(ii) If B is not-accepted and B has only one direct attacker C then C B.\nRemark: The condition (\u2217) stated in Theorem 2 is:\nfalse for the local valuation proposed by Besnard and Hunter (2001) as shown in the following graph:\nB1\nC1\nB2\nC2\nB3\nC3\nA0,4\n0,5 0,50,5\n1 1 1\nWe know that g(x) = 11+x and h(x1, . . . , xn) = \u03a3 n i=1xi (see Property 6). We get:\n\u2200i = 1 . . . 3, xi = v(Bi) = 0.5, \u2200i = 1 . . . 3, g(xi) = 0.66, so g(xi) \u2265 xi, and nevertheless g(h(x1, x2, x3)) = v(A) = 0.4 6\u2265 h(x1, x2, x3) = 1.5.\nfalse for the local valuations defined with h such that \u2203n > 1 with h(x1, . . . , xn) > max(x1, . . . , xn) (for all the functions g strictly non-increasing): see the previous graph where h(x1, x2, x3) = 1.5 and max(x1, x2, x3) = 0.5. true for the local valuations defined with h = max (for all the functions g): if h = max then g(h(x1, . . . , xn)) = g(max(x1, . . . , xn)) = g(xj), xj being the maximum of the xi; and, by assumption, g(xi) \u2265 xi, \u2200xi, so in particular for xj ; so, we get:\ng(h(x1, . . . , xn)) = g(xj) \u2265 xj = max(x1, . . . , xn) = h(x1, . . . , xn)."}, {"heading": "5. Conclusion", "text": "In this paper, we have introduced graduality in the two main related issues of argumentation systems:\nthe valuation of the arguments,\nthe acceptability of the arguments.\nRegarding the first issue, we have defined two formalisms introducing an interaction-based gradual valuation of arguments.\nFirst, a generic gradual valuation which covers existing proposals (for example Besnard & Hunter, 2001 and Jakobovits & Vermeir, 1999). This approach is essentially \u201clocal\u201d since it computes the value of the argument only from the value of its direct attackers.\nThen, an approach based on a labelling which takes the form of a pair of tuples; this labelling memorises the structure of the graph representing the interactions (the \u201cattack graph\u201d), associating each branch with its length (number of the edges from the leaf to the current node) in the attack graph (if the length of the branch is an even integer, the branch is a defence branch for the current node, otherwise the branch is an attack branch for the current node). This approach is said to be \u201cglobal\u201d since it computes the value of the argument using the whole attack graph influencing the argument.\nWe have shown that each of these valuations induces a preordering on the set of the arguments, and we have brought to light the main differences between these two approaches.\nRegarding the second issue, two distinct approaches have been proposed:\nFirst, in the context of the collective acceptability of Dung (1995): three levels of acceptability (uni-accepted, exi-accepted, not-accepted) were already defined. More graduality can be introduced in the collective acceptability using the notion of cleanlyaccepted arguments (those whose direct attackers are not-accepted).\nThen, in the context of individual acceptability: using the previously defined gradual valuations, the new notion of well-defended arguments has been introduced (those which are preferred to their direct attackers in the sense of a given gradual valuation v).\nThe first concept induces a refinement of the level of exi-accepted in two sublevels (cleanlyaccepted arguments and only-exi-accepted arguments). The gradual valuation allows graduality inside each level of this collective acceptability.\nThe second concept induces two new levels of acceptability (well-defended arguments and not-well-defended arguments). The gradual valuation also allows graduality inside each level of this individual acceptability.\nRegarding our initial purpose of introducing graduality in the definition of acceptability, we have adopted a basic principle:\nacceptability is strongly related to the interactions between arguments (represented on the graph of interactions),\nand an argument is all the more acceptable if it is preferred to its direct attackers.\nThen, we have followed two different directions. One is based on a refinement of an existing partition and remains in the framework of Dung\u2019s work. The other one is based on the original concept of \u201cbeing well-defended\u201d, and deserves further investigation, in particular from a computational point of view."}, {"heading": "Acknowledgements", "text": "Thanks to the reviewers for their very interesting and constructive comments.\nThanks to Thomas Schiex for his help."}, {"heading": "Appendix A. The proofs", "text": "In this section, we give the proofs of all the properties presented in Sections 3 and 4."}, {"heading": "Proof", "text": "(of Property 1) By induction from VMin \u2264 g(VMax) < VMax and by applying function g twice."}, {"heading": "Proof", "text": "(of Property 2) The valuation function v associates each argument A with a value v(A) belonging to a set V which is a subset of a completely ordered set W ."}, {"heading": "Proof", "text": "(of Property 3) Let C = An \u2212An\u22121 \u2212 . . .\u2212A2 \u2212A1 be a cycle:\nIf n is even: n = 2k and v(A1) = g(v(A2)) = . . . = g 2k\u22121(v(A2k)) = g2k(v(A1)); so, v(A1) is a fixpoint of g 2k = gn. It is the same for each Ai, 1 \u2264 i \u2264 2k. However, the Ai may have different values: for example, for n = 2, with the valuation of Jakobovits and Vermeir (1999), v(A1) = + and v(A2) = \u2212 with g(+) = \u2212 and g(\u2212) = +. If all the Ai have the same value, then this value will be a fixpoint of g (because v(A1) = g(v(A2)) = g(v(A1))).\nIf n is odd: n = 2k + 1 and v(A1) = g(v(A2)) = . . . = g 2k(v(A2k+1)) = g2k+1(v(A1)); so, v(A1) is a fixpoint of g 2k+1 = gn. It is the same for each Ai, 1 \u2264 i \u2264 2k + 1. Since the function g is non-increasing, the function g2k+1 is also nonincreasing and we can apply the following result: \u201cif a non-increasing function has fixpoints, these fixpoints are identical\u201d30. So, v(A1) = . . . = v(A2k+1). But, v(A1) = g(v(A2)) = g(v(A1)), so v(A1) is a fixpoint of g. So, for all the 1 \u2264 i \u2264 2k + 1, v(Ai) is a fixpoint of g."}, {"heading": "Proof (of Property 4)", "text": "P1 is satisfied because: \u2200A \u2208 A, if A has no direct attacker (R\u2212(A) is empty), then v(A) = VMax and g(VMax) < VMax. P2 is satisfied because if R\u2212(A) = {A1, . . . , An}, h(v(A1), . . . , v(An)) evaluates the \u201cdirect attack\u201d of A.\nP3 is satisfied because the function g is supposed to be non-increasing.\nP4 is satisfied due to the properties of the function h."}, {"heading": "Proof", "text": "(of Property 5) The valuation proposed by Jakobovits and Vermeir (1999) is the following:\nLet <A,R> be an argumentation system. A complete labelling of <A,R> is a function Et : A \u2192 {+, ?,\u2212} such that:\n1. If Et(A) \u2208 {?,\u2212} then \u2203B \u2208 R\u2212(A) such that Et(B) \u2208 {+, ?} 2. If Et(A) \u2208 {+, ?} then \u2200B \u2208 R\u2212(A) or \u2208 R+(A), Et(B) \u2208 {?,\u2212}\nMoreover, Jakobovits and Vermeir (1999) also define a complete rooted labelling Et with: \u2200A \u2208 A, if Et(A) = \u2212 then \u2203B \u2208 R\u2212(A) such that Et(B) = +. The translation of Et into a local gradual valuation is very easy:\ng is defined by g(\u2212) = +, g(+) = \u2212, g(?) =? and h is the function max."}, {"heading": "Proof", "text": "(of Property 6) Besnard and Hunter (2001) introduce the following function Cat (in the context of \u201cdeductive\u201d arguments and for an acyclic graph):\nif R\u2212(A) = \u2205, then Cat(A) = 1 30. Proof: let g be a non-increasing function, let \u03b1 and \u03b2 be two fixpoints of g. If \u03b1 6= \u03b2, we may suppose\nthat \u03b1 > \u03b2, so g(\u03b1) \u2264 g(\u03b2) (since g is non-increasing), so \u03b1 \u2264 \u03b2 (since \u03b1 and \u03b2 are fixpoints of g), which is in contradiction with the assumption \u03b1 > \u03b2.\nif R\u2212(A) 6= \u2205 with R\u2212(A) = {A1, . . . , An}, Cat(A) = 11+Cat(A1)+...+Cat(An) The translation of Cat into a gradual valuation is: V = [0, 1], W = [0,\u221e[, VMin = 0 and VMax = 1 and g : W \u2192 V is defined by g(x) = 11+x and h is defined by h({x1, . . . , xn}) = x1 + \u00b7 \u00b7 \u00b7+ xn."}, {"heading": "Proof", "text": "(of Property 7) Let t = (x1, . . . , xn, . . .), t\n\u2032 = (y1, . . . , yn, . . .), t\u2032\u2032 = (z1, . . . , zn, . . .) be tuples.\nCommutativity of \u22c6: t \u22c6 t\u2032 = t\u2032 \u22c6 t There are two cases:\nif t or t\u2032 = 0\u221e, the property is given by Definition 8. if t and t\u2032 6= 0\u221e:\nt \u22c6 t\u2032 = Sort(x1, . . . , xn, . . . , y1, . . . , yn, . . .)\n= Sort(y1, . . . , yn, . . . , x1, . . . , xn, . . .) = t\u2032 \u22c6 t\nAssociativity of \u22c6: (t \u22c6 t\u2032) \u22c6 t\u2032\u2032 = t \u22c6 (t\u2032 \u22c6 t\u2032\u2032) There are two cases:\nif t or t\u2032 or t\u2032\u2032 = 0\u221e, we can simplify the expression. For example, if t = 0\u221e:\n(t \u22c6 t\u2032) \u22c6 t\u2032\u2032 = t\u2032 \u22c6 t\u2032\u2032\n= t \u22c6 (t\u2032 \u22c6 t\u2032\u2032)\nif t, t\u2032 and t\u2032\u2032 6= 0\u221e:\n(t \u22c6 t\u2032) \u22c6 t\u2032\u2032 = Sort(x1, . . . , xn, . . . , y1, . . . , yn, . . . , z1, . . . , zn, . . .)\n= t \u22c6 (t\u2032 \u22c6 t\u2032\u2032)\nProperty of \u2295: (t\u2295 k)\u2295 k\u2032 = t\u2295 (k + k\u2032) We have:\n(t\u2295 k)\u2295 k\u2032 = (x1 + k, . . . , xn + k, . . .)\u2295 k\u2032 = (x1 + k + k \u2032, . . . , xn + k + k \u2032, . . .)\n= t\u2295 (k + k\u2032)\nDistributivity: (t \u22c6 t\u2032)\u2295 k = (t\u2295 k) \u22c6 (t\u2032 \u2295 k) We have:\n(t \u22c6 t\u2032)\u2295 k = Sort(x1, . . . , xn, . . . , x\u20321, . . . , x\u2032n, . . .)\u2295 k = Sort(x1 + k, . . . , xn + k, . . . , x \u2032 1 + k, . . . , x \u2032 n + k, . . .)\n= (t\u2295 k) \u22c6 (t\u2032 \u2295 k)"}, {"heading": "Proof", "text": "(of Property 9) First, we show that the relation defined by Algorithm 1 is a partial ordering:\nLet u, v, w be three tupled values, the relation defined by Algorithm 1 is:\nreflexive: u u because u = u, so u u AND u u (case 1 of Algorithm 1);\ntransitive: suppose that u v and v w and consider all the possible cases:\nif u = v:\nif v = w: then u = w so u w, if |vi| \u2264 |wi| AND |vp| > |wp|: then |vi| = |ui| \u2264 |wi| AND |vp| = |up| > |wp|, so u w, if |vi| < |wi| AND |vp| \u2265 |wp|: then |vi| = |ui| < |wi| AND |vp| = |up| \u2265 |wp|, so u w, if |vi| = |wi| AND |vp| = |wp| AND vp \u2264lex\u221e wp AND vi \u2265lex\u221e wi: then |vi| = |ui| = |wi| AND |vp| = |up| = |wp| AND vp = up \u2264lex\u221e wp AND vi = ui \u2265lex\u221e wi, so u w; if |ui| \u2264 |vi| AND |up| > |vp|: if v = w: then |ui| \u2264 |vi| = |wi| AND |up| > |vp| = |wp| so u w, if |vi| \u2264 |wi| AND |vp| > |wp|: then |ui| \u2264 |vi| \u2264 |wi| AND |up| > |vp| > |wp|, so u w, if |vi| < |wi| AND |vp| \u2265 |wp|: then |ui| \u2264 |vi| < |wi| AND |up| > |vp| \u2265 |wp|, so u w, if |vi| = |wi| AND |vp| = |wp|: then |ui| \u2264 |vi| = |wi| AND |up| > |vp| = |wp|, so u w; if |ui| < |vi| AND |up| \u2265 |vp|: if v = w: then |ui| < |vi| = |wi| AND |up| \u2265 |vp| = |wp| so u w, if |vi| \u2264 |wi| AND |vp| > |wp|: then |ui| < |vi| \u2264 |wi| AND |up| \u2265 |vp| > |wp|, so u w, if |vi| < |wi| AND |vp| \u2265 |wp|: then |ui| < |vi| < |wi| AND |up| \u2265 |vp| \u2265 |wp|, so u w, if |vi| = |wi| AND |vp| = |wp|: then |ui| < |vi| = |wi| AND |up| \u2265 |vp| = |wp|, so u w; if |ui| = |vi| AND |up| = |vp| AND up \u2264lex\u221e vp AND ui \u2265lex\u221e vi:\nif v = w: then |ui| = |vi| = |wi| AND |up| = |vp| = |wp| AND up \u2264lex\u221e vp = wp AND ui \u2265lex\u221e vi = wi so u w, if |vi| \u2264 |wi| AND |vp| > |wp|: then |ui| = |vi| \u2264 |wi| AND |up| = |vp| > |wp|, so u w,\nif |vi| < |wi| AND |vp| \u2265 |wp|: then |ui| = |vi| < |wi| AND |up| = |vp| \u2265 |wp|, so u w, if |vi| = |wi| AND |vp| = |wp| AND vp \u2264lex\u221e wp AND vi \u2265lex\u221e wi: then |ui| = |vi| = |wi| AND |up| = |vp| = |wp| AND up \u2264lex\u221e vp \u2264lex\u221e wp AND ui \u2265lex\u221e vi \u2265lex\u221e wi, so u w.\nIn all cases, u w.\nNow, consider the maximal and minimal values:\nThe tupled value [0\u221e, ()] is the unique maximal element for the preordering : let v be a tupled value such that v 6= [0\u221e, ()], then |vp| \u2264 \u221e and |vi| \u2265 0. Compare [0\u221e, ()] and v with Algorithm 1: [0\u221e, ()] 6= v so the case number 1 is not used; then, |()| = 0 \u2264 |vi| AND |0\u221e| = \u221e \u2265 |vp| so there are two cases:\nif |vp| = \u221e and |vi| = 0, the case 3 of Algorithm 1 is applied and [0\u221e, ()] \u227b v, else |vp| \u2264 \u221e and |vi| \u2265 0, the case 5 of Algorithm 1 is applied and [0\u221e, ()] \u227b v.\nThe tupled value [(), 1\u221e] is the unique minimal element for the preordering : let v be a tupled value such that v 6= [(), 1\u221e], then |vi| \u2264 \u221e and |vp| \u2265 0. Compare [(), 1\u221e] and v with Algorithm 1: [(), 1\u221e] 6= v so the case number 1 is not used; then, |()| = 0 \u2264 |vp| AND |1\u221e| = \u221e \u2265 |vi| so there are two cases:\nif |vi| = \u221e and |vp| = 0, the case 2 of Algorithm 1 is applied and [(), 1\u221e] \u227a v, else |vi| \u2264 \u221e and |vp| \u2265 0, the case 6 of Algorithm 1 is applied and [(), 1\u221e] \u227a v."}, {"heading": "Proof", "text": "(of Property 10) The principle P1\u2032 is satisfied by Definition 10 and by the fact that [0\u221e, ()] is the unique maximal element of v(A) (see Property 9). The principle P2\u2032 is satisfied because of Definition 10. The principles P3\u2032 and P4\u2032 are satisfied: all the possible cases of improvement/degradation of the defence/attack for a given argument (see Definition 16) are applied case by case31. Each case leads to a new argument. Using Algorithm 1, the comparison between the argument before and after the application of the case shows that the principle P3\u2032 (or P4\u2032, depending on the applied case)\n31. We work case by case in order to avoid the complex cases in which we have several simultaneous simple modifications. For example, the modification of the length of a branch which changes the status of the branch (an even integer replaced by an odd integer) is a complex case corresponding to two simple cases: the removal of a branch with a given status, then the addition of a new branch with a different status.\nis satisfied."}, {"heading": "Proof", "text": "(of Property 11) From Definition 10."}, {"heading": "Proof", "text": "(of Property 12) First, we consider the case of the preferred extensions: Let E be a preferred extension \u2286 A, we assume that E does not contain all the unattacked arguments of A. So, let A \u2208 A be an unattacked argument such that A 6\u2208 E. Consider E \u222a {A}:\nIf E \u222a {A} is conflict-free then, with A an unattacked argument and E a preferred extension, E \u222a {A} collectively defends itself, so E \u222a {A} is admissible and E \u2286 E\u222a{A}. This contradicts the fact that E is a preferred extension. If E \u222a {A} contains at least one conflict, then: \u2203B \u2208 E such that BRA. This is impossible since A is unattacked. or \u2203B \u2208 E such that ARB. But, since A is unattacked, \u2204C \u2208 E such that CRA. So, E does not collectively defend B, which is in contradiction with the fact that E is a preferred extension.\nSo, the assumption \u201cE does not contain all the unattacked arguments of A\u201d cannot hold.\nNow, we consider stable extensions: Let E be a stable extension \u2286 A, we assume that E does not contain all the unattacked arguments of A. So, let A \u2208 A be an unattacked argument such that A 6\u2208 E. Since A 6\u2208 E there exists in E another argument B which attacks A; This is impossible since A is unattacked. So, the assumption \u201cE does not contain all the unattacked arguments of A\u201d cannot hold."}, {"heading": "Proof", "text": "(of Property 13) An argument and one of its direct attackers cannot belong to the same extension in the sense of Dung (1995) because the extension must be conflict-free. So, since A is uni-accepted, it means that A belongs to all the extensions, and none of the direct attackers of A belongs to these extensions.\nFor the converse, we use the following counterexample in the case of the preferred semantics:\nJ\nK\nH\nB\nA\nC\nF\nE G\nThere are two preferred extensions {K,H,G} and {A,E,K,H}. The argument A is cleanly-accepted (B and C do not belong to any preferred extension, and A belongs to at least one of the two extensions). But, A is not uni-accepted because it does not belong to all preferred extensions."}, {"heading": "Proof", "text": "(of Property 14) First, A uni-accepted \u21d2 A cleanly-accepted is the result of Property 13.\nConversely, let A be a cleanly-accepted argument, there exists at least one stable extension E such that A \u2208 E and \u2200B,BRA, B 6\u2208 E\u2032, \u2200E\u2032 stable extension. Using a reductio ad absurdum, we assume that there exists a stable extension E\u2032\u2032 such that A 6\u2208 E\u2032\u2032; but, if A 6\u2208 E\u2032\u2032, it means that \u2203B \u2208 E\u2032\u2032 such that BRA, so, the direct attacker B of A belongs to a stable extension; so, there is a contradiction with the assumption (A is cleanly-accepted); so, E\u2032\u2032 does not exist and A is uni-accepted."}, {"heading": "Proof (of Theorem 1)", "text": "1. We consider the arguments B \u2208 A such that B 6= A. Let Xi be a leaf, the path C \u2208 C(Xi, A) is X1i \u2212 . . .\u2212X lii \u2212A with X1i = Xi and li denoting the length of the path (if li is even, this path is a defence branch for A, else it is an attack branch).\nThe constraints from X1i to X li i are the following:\nX1i \u227b X3i \u227b . . . \u227b X lii \u227b X li\u22121i \u227b . . . \u227b X4i \u227b X2i if li odd \u2265 1 or\nX1i \u227b X3i \u227b . . . \u227b X li\u22121i \u227b X lii \u227b . . . \u227b X4i \u227b X2i if li even \u2265 2\nSo, for the path X1i \u2212 . . .\u2212X lii , the set of the well-defended arguments is {X1i , X3i , . . . , X lii } if li is odd, {X1i , X3i , . . . , X li\u22121i } otherwise (this is the set of all the arguments having a value strictly better than those of their direct attackers). This set will denoted by Accepi. By definition, this set is conflict-free, it defends all its elements (because it contains only the leaf of the path and all the arguments which are defended by this leaf) and it attacks all the other arguments of the path. If we try\nto include another argument of the path X \u2208 {X1i , . . . , X lii }\\ Accepi, we obtain a conflict (because all the other arguments of the path are attacked by the elements of Accepi). So, for {X1i , . . . , X lii }, Accepi is the only preferred and stable extension. Consider A\u2032 = A \\ {A}, with R\u2032 being the restriction of R to A\u203232 and Union Accep= \u222ai Accepi, then Union Accep is the only preferred and stable extension of <A\u2032,R\u2032>. So, \u2200B \u2208 A, B 6= A, B is accepted iff B well-defended.\n2. Now, consider A. If A is accepted then Union Accep \u222a{A} is the only preferred and stable extension of <A,R>. So, \u2200i, X lii does not belong to the extension. Then, \u2200i, X li\u22121i \u227b X lii . Therefore, each branch leading to A is a defence branch for A. So, \u2200i, v(X lii ) = [()(li \u2212 1)]. So, v(A) = [(l1, l2, . . . , ln)()]. Then, \u2200i, v(A) \u227b v(X lii ). Therefore, A is well-defended. Using the following example, we show that the converse is false:\nB1\nC1\nB2\nC2\nB3\nC3\nA\n[(0...0)()] [(0...0)()] [(0...0)()]\n[()(1)] [()(1)] [()(1)]\nA1 [(2)()]\n[(2,2)(3)]\nA is well-defended (A \u227b B1, A \u227b B2 and A is incomparable with A1) but not accepted.\n3. Now, if A is well-defended and all the branches leading to A are defence branches for A, then Union Accep \u222a{A} is conflict-free and A is defended against each of its direct attackers (becauseX li\u22121i \u2208 Union Accep for each branch i). So, Union Accep \u222a{A} is the preferred and stable extension of <A,R> and A is accepted."}, {"heading": "Proof", "text": "(of Lemma 1) Let <A,R> be an argumentation system with a finite relation R without cycles (so, there is only one non empty preferred and stable extension denoted by E). We know that:\nif A is exi-accepted and if A has a direct attacker denoted by B then B is not-accepted,\n32. R\u2032 is the restriction of R to A\u2032 if and only if R\u2032 = {(a, b)|aRb, a \u2208 A\u2032, b \u2208 A\u2032}.\nif B is not-accepted then there exists at least one argument C such that CRB and C is exi-accepted (because B does not belong to E and E is stable, so C must \u2208 E). So, a fortiori, if B is not-accepted and has only one direct attacker C, then C will be exi-accepted.\nThe proof is done by induction on the depth of a proof tree for A or C.\nBasic case for (i): A is exi-accepted with only one direct attacker B (BRA) and C1 . . . Cn are the direct attackers of B; so, we have a proof tree whose depth is 2 for A and one of the unattacked Ci, for example C1; so:\nv(B) = g(h(v(C1), . . . , v(Cn)))\n\u2264 g(v(C1)) because h(v(C1), . . . , v(Cn)) \u2265 h(v(C1)) = v(C1) and g is non-increasing \u2264 g(VMax) because v(C1) = VMax\nso:\nv(A) = g(v(B))\n\u2265 g2(VMax)\nBut, Property 1 says that g2(VMax) \u2265 g(VMax), so v(A) \u2265 v(B). Basic case for (ii): CRB with C the only direct attacker of B; so, we have a proof tree whose depth is 0 for C, i.e. C is unattacked; so, v(C) = VMax and v(B) = g(VMax) \u2264 v(C) (following Definition 6). General case for (i): A is exi-accepted with only one direct attacker B (BRA) and C1 . . . Cn are the direct attackers of B, with one of the Ci exiaccepted, for example C1; we consider the subgraph leading to C1 to which we add C1RBRA, and we assume: g(v(C1)) \u2264 v(C1) (induction assumption issued from (ii)) So:\nv(B) = g(h(v(C1), . . . , v(Cn)))\n\u2264 g(v(C1)) for the same reasons as in the basic case \u2264 v(C1) by induction assumption \u2264 h(v(C1), . . . , v(Cn)) property of h\nand with the non-increasing of g:\nv(A) = g(v(B))\n\u2265 g(h(v(C1), . . . , v(Cn))) = v(B)\nGeneral case for (ii): B is not-accepted, so C is exi-accepted; we assume that C has several direct attackers D1 . . . Dp which are all not-accepted (because C is exi-accepted); we consider each subgraph leading to Di to which we add DiRCRB and we assume: \u2200i = 1 . . . p, g(v(Di)) \u2265 v(Di) (induction assumption issued from (i)) so:\nv(C) = g(h(v(D1), . . . , v(Dp)))\n\u2265 h(v(D1), . . . , v(Dp)) application of the condition (\u2217) since the induction assumption\ncorresponds to the premise of (\u2217)\nso:\nv(B) = g(v(C))\n\u2264 g(h(v(D1), . . . , v(Dp))) = v(C)"}, {"heading": "Proof", "text": "(of Theorem 2) Assume that (\u2217) is true and consider A \u2208 A which is exiaccepted. Let Bi, i = 1 . . . n, be the direct attackers of A. Then, for all i = 1 . . . n, in the subgraph leading to Bi and completed with BiRA, we apply the lemma and we obtain: g(v(Bi)) \u2265 v(Bi), \u2200i = 1 . . . n. Thus, we have:\nv(A) = g(h(v(B1), . . . , v(Bn)))\n\u2265 h(v(B1), . . . , v(Bn)) by applying (\u2217) \u2265 v(Bi),\u2200i = 1 . . . n property of h\nSo, A is well-defended.\nFor the converse, let A \u2208 A be well-defended. Let B1, . . . , Bn be the direct attackers of A and assume that A is not exi-accepted. Then, there exists at least one direct attacker Bi of A such that Bi is exi-accepted (because there is only one preferred and stable extension). We can apply (ii) of the lemma on the subgraph leading to Bi completed with BiRA and we obtain g(v(Bi)) \u2264 v(Bi). So, there exists Bi a direct attacker of A such that:\nv(A) = g(h(v(B1), . . . , v(Bn)))\n\u2264 g(v(Bi)) property of h and non-increasing of g \u2264 v(Bi) using the lemma\nThis is in contradiction with A well-defended. So, A is exi-accepted."}, {"heading": "Appendix B. Computation of tupled values", "text": "We propose an algorithm for computing the tupled values for an arbitrary graph (cyclic or acyclic, the cycles may be isolated or not). This algorithm uses a principle of propagation of values: an argument is evaluated when the values of its direct attackers are known. We must consider the cycles as meta-arguments which are evaluated when all the \u201cdirect attackers of the cycle\u201d (i.e. the direct attackers of one of the elements of the cycle which do not belong to the cycle) are evaluated. The beginning of the process is as follows: we consider that all the arguments have the initial value [0\u221e, ()], and only the leaves of the graph are \u201cmarked\u201d as having their final values. Thus, we have the following partition of the graph G:\nGv: the part of the graph already evaluated (at the beginning, this part contains only the leaves of the graph), G\u00acv: the part of the graph which is not evaluated (at the beginning, this part contains all the arguments of the graph G except the leaves).\nThe algorithm also relies on a special data structure denoted by L giving the list of the cycles in the graph and their main characteristics:\nlist of the arguments which belong to this cycle,\nlist of the arguments which belong to this cycle and which have direct attackers outside the cycle (these arguments are called inputs of the cycle; those which will be used in order to propagate the values across the cycle in the case of a non isolated cycle); this list will be empty in the case of an isolated cycle.\nRemark: For the sake of efficiency, the interconnected cycles (see Definition 1) will be considered as a \u201cwhole\u201d by the algorithm and will be used like a \u201cmeta-cycle\u201d. For example, the two cycles A \u2212 B \u2212 A and B \u2212 C \u2212 B which do not have any direct attacker outside of the cycles, will be described in the data structure L as only one \u201cmeta-cycle\u201d with the following lists:\nA, B, C,\nnothing (because it is an isolated \u201cmeta-cycle\u201d).\nIn order to avoid some ambiguity, these \u201cmeta-cycles\u201d are defined as mcycles:\nDefinition 21 (mcycle) Let G be an attack graph. Let CC be the set of all the cycles of G. Let CC\u2032 \u2286 CC and CC\u2032 = {C1, . . . , Cn} be a set of cycles. Let ACC\u2032 be the set: {Aj such that \u2203Ci \u2208 CC\u2032 and Aj \u2208 Ci}. If CC\u2032 satisfies the following properties:\n\u2200Aj , Ak \u2208 ACC\u2032 , \u2203 a path from Aj to Ak such that each element (arguments or edges between arguments) of the path belongs to cycles of CC\u2032, and \u2200Ck \u2208 CC \\ CC\u2032, 6 \u2203Ci \u2208 CC\u2032 such that Ck is interconnected with Ci.\nThen the union of the Ci belonging to CC\u2032 is a mcycle.\nThus, we make a partition of CC using the notion of interconnection between cycles, each element of the partition being a different mcycle. See on the following example:\nA\nB\nD\nJ\nK\nC E F G I\nL\nIn this graph, there are 6 cycles:\n{J}, {I, J,K}, {K,L}, {B,C,D}, {C,E}, {F,G}.\nand 3 mcycles:\n{I, J,K,L}, {B,C,D,E}, {F,G}.\nAlgorithm 2 is the main algorithm used for computing the tupled values. The function Add-Node (respectively Remove-Node) whose parameters are a subgraph Gx of the attack graph and a node s, adds (resp. removes) s in (resp. of) Gx. The other functions are described in (Cayrol & Lagasquie-Schiex, 2003a). Algorithm 2 has been applied on an example after the step of rewriting (see Figure 1). Note that in order to make the understanding of the results easier, we do not have created new arguments (as in Definitions 11 and 12), but of course, it would be necessary for a rigorous formalization.\nAlgorithm 2: Algorithm for computing tupled values\n% Description of parameters: % % G: attack graph (partitioned in Gv and G\u00acv) % % L: data structure describing the mcycles % % n: number of propagation steps for the mcycles % % Used variables: % % A: the current argument (to be evaluated) % % C: the current mcycle (to be evaluated) (containing A) % % LAD: list of the direct attackers of C % % Bi: the current direct attackers of A, or of C %\nbegin 1 while there is at least one argument in G\u00acv do 2 A = Choose-Argument(G\u00acv) 3 if A does not belong to a mcycle C described in L then 4 if \u2200Bi \u2208 R\u2212(A), Bi is already evaluated then 5 Gv = Add-Node(Gv,Evaluate-Node(A, R\u2212(A), 1)) % The value of A %\n% is the value of its % % direct attackers % % in which we add 1 % % see Definition 10 %\n6 G\u00acv = Remove-Node(G\u00acv, A)\n7 else 8 if C is isolated then 9 Gv = Add-Mcycle(Gv,Evaluate-Mcycle-Isolated(G, C, n))\n10 G\u00acv = Remove-Mcycle(G\u00acv, C) 11 else 12 LAD = Find-Direct-Attackers-Mcycle(C, G) 13 if \u2200Bi \u2208 LAD, Bi is already evaluated then 14 Gv = Add-Mcycle(Gv, Evaluate-Mcycle-Not-Isolated(G, C, LAD,n)) 15 G\u00acv = Remove-Mcycle(G\u00acv, C)\n16 return G end\nA\nB C D\nEG\nF\nThe previous argumentation graph can be rewritten as follows:\nA\nB\nC\nC\nB\nA\nB\nC\nA\nB\nC\nC\nE\nD\nB\nA\nB\nC\nB\nA\nA\nB\nC\nB\nC\nB\nC\nB\nA\nE\nD B\nC\nA\nB\nC\nC\nB\nA\nE\nA\nC\nD\nC\nB\nA\nB\nC\nD\nB\nA\nC\nB\nC\nD\n.... .... .... ....\nG\nF\nA\nB C D E\nThe results of the valuation obtained after one propagation step are:\nv(A) = [(0, . . . , 0)()],\nv(B) = [(6, 8, 8, . . .)(1, 3, 5, . . .)],\nv(C) = [(2, 4, 6, . . .)(5, . . .)],\nv(D) = [(6, . . .)(3, 5, . . .)],\nv(E) = [(4, 6, . . .)()],\nv(F ) = [(8, . . .)(3, 5, 5, 7, 7, . . .)],\nv(G) = [(2, 4, 6, . . .)(7, . . .)],\nFigure 1: Example of rewriting"}], "references": [{"title": "On the acceptability of arguments in preference-based argumentation", "author": ["L. Amgoud", "C. Cayrol"], "venue": "Proc. of the 14 Uncertainty in Artificial Intelligence,", "citeRegEx": "Amgoud and Cayrol,? \\Q1998\\E", "shortCiteRegEx": "Amgoud and Cayrol", "year": 1998}, {"title": "Inferring from inconsistency in preference-based argumentation frameworks", "author": ["L. Amgoud", "C. Cayrol"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Amgoud and Cayrol,? \\Q2002\\E", "shortCiteRegEx": "Amgoud and Cayrol", "year": 2002}, {"title": "Value based argumentation frameworks", "author": ["T.J. Bench-Capon"], "venue": "Proc. of the 9 International Workshop on Nonmonotonic Reasoning (session on Argument, Dialogue and Decision),", "citeRegEx": "Bench.Capon,? \\Q2002\\E", "shortCiteRegEx": "Bench.Capon", "year": 2002}, {"title": "A logic-based theory of deductive arguments", "author": ["P. Besnard", "A. Hunter"], "venue": "Artificial Intelligence,", "citeRegEx": "Besnard and Hunter,? \\Q2001\\E", "shortCiteRegEx": "Besnard and Hunter", "year": 2001}, {"title": "Critique et am\u00e9lioration de l\u2019\u00e9valuation graduelle par tuples pour le traitement des circuits", "author": ["C. Cayrol", "Lagasquie-Schiex", "M.-C"], "venue": "Rapport de recherche 2003-13-R, Institut de Recherche en Informatique de Toulouse (I.R.I.T.), France", "citeRegEx": "Cayrol et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Cayrol et al\\.", "year": 2003}, {"title": "Gradual acceptability in argumentation systems", "author": ["C. Cayrol", "Lagasquie-Schiex", "M.-C"], "venue": "In Proc. of the 3 CMNA (International workshop on computational models of natural argument),", "citeRegEx": "Cayrol et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Cayrol et al\\.", "year": 2003}, {"title": "Gradual handling of contradiction in argumentation frameworks", "author": ["C. Cayrol", "Lagasquie-Schiex", "M.-C"], "venue": "chap. Reasoning,", "citeRegEx": "Cayrol et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Cayrol et al\\.", "year": 2003}, {"title": "Autour de la s\u00e9mantique pr\u00e9f\u00e9r\u00e9e des syst\u00e8mes d\u2019argumentation", "author": ["S. Doutre"], "venue": null, "citeRegEx": "Doutre,? \\Q2002\\E", "shortCiteRegEx": "Doutre", "year": 2002}, {"title": "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games", "author": ["P.M. Dung"], "venue": "Artificial Intelligence,", "citeRegEx": "Dung,? \\Q1995\\E", "shortCiteRegEx": "Dung", "year": 1995}, {"title": "Coherence in finite argument systems", "author": ["P.E. Dunne", "T.J. Bench-Capon"], "venue": "Technical report 01-006,", "citeRegEx": "Dunne and Bench.Capon,? \\Q2001\\E", "shortCiteRegEx": "Dunne and Bench.Capon", "year": 2001}, {"title": "Coherence in finite argument system", "author": ["P.E. Dunne", "T.J. Bench-Capon"], "venue": "Artificial Intelligence,", "citeRegEx": "Dunne and Bench.Capon,? \\Q2002\\E", "shortCiteRegEx": "Dunne and Bench.Capon", "year": 2002}, {"title": "Dialectic reasoning with inconsistent information", "author": ["M. Elvang-Goransson", "J. Fox", "P. Krause"], "venue": "Proc. of the 9 UAI,", "citeRegEx": "Elvang.Goransson et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Elvang.Goransson et al\\.", "year": 1993}, {"title": "Robust semantics for argumentation frameworks", "author": ["H. Jakobovits", "D. Vermeir"], "venue": "Journal of logic and computation,", "citeRegEx": "Jakobovits and Vermeir,? \\Q1999\\E", "shortCiteRegEx": "Jakobovits and Vermeir", "year": 1999}, {"title": "Computer supported argumentation and collaborative decision making: the hermes system", "author": ["N. Karacapilidis", "D. Papadias"], "venue": "Information systems,", "citeRegEx": "Karacapilidis and Papadias,? \\Q2001\\E", "shortCiteRegEx": "Karacapilidis and Papadias", "year": 2001}, {"title": "Probabilistic argumentation systems and abduction", "author": ["J. Kohlas", "R. Haenni", "D. Berzati"], "venue": "In Proc. of the 8 International Workshop on Non-Monotonic Reasoning - special session on Uncertainty Frameworks in Non-Monotonic Reasoning,", "citeRegEx": "Kohlas et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Kohlas et al\\.", "year": 2000}, {"title": "A logic of argumentation for reasoning under uncertainty", "author": ["P. Krause", "S. Ambler", "M. Elvang", "J. Fox"], "venue": "Computational Intelligence,", "citeRegEx": "Krause et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Krause et al\\.", "year": 1995}, {"title": "Argument systems - a uniform basis for non-monotonic reasoning", "author": ["F. Lin", "Y. Shoham"], "venue": "In Proc. of the first International Conference On Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Lin and Shoham,? \\Q1989\\E", "shortCiteRegEx": "Lin and Shoham", "year": 1989}, {"title": "Normative argumentation and qualitative probability", "author": ["S. Parsons"], "venue": "In Proc. of the first International Joint Conference on Qualitative and quantitative practical reasoning, ECSQARU-FAPR,", "citeRegEx": "Parsons,? \\Q1997\\E", "shortCiteRegEx": "Parsons", "year": 1997}, {"title": "Reasoning from inconsistency: A taxonomy of principles for resolving conflict", "author": ["G. Pinkas", "R.P. Loui"], "venue": "Proc. of the 3 KR,", "citeRegEx": "Pinkas and Loui,? \\Q1992\\E", "shortCiteRegEx": "Pinkas and Loui", "year": 1992}, {"title": "How to reason defeasibly", "author": ["J.L. Pollock"], "venue": "Artificial Intelligence,", "citeRegEx": "Pollock,? \\Q1992\\E", "shortCiteRegEx": "Pollock", "year": 1992}, {"title": "Defeasible reasoning with variable degrees of justification", "author": ["J.L. Pollock"], "venue": "Artificial Intelligence,", "citeRegEx": "Pollock,? \\Q2001\\E", "shortCiteRegEx": "Pollock", "year": 2001}, {"title": "Argument-based extended logic programming with defeasible priorities", "author": ["H. Prakken", "G. Sartor"], "venue": "Journal of Applied Non-Classical Logics,", "citeRegEx": "Prakken and Sartor,? \\Q1997\\E", "shortCiteRegEx": "Prakken and Sartor", "year": 1997}, {"title": "A mathematical treatment of defeasible reasoning and its implementation", "author": ["G. Simari", "R. Loui"], "venue": "Artificial Intelligence,", "citeRegEx": "Simari and Loui,? \\Q1992\\E", "shortCiteRegEx": "Simari and Loui", "year": 1992}, {"title": "On the existence and multiplicity of extension in dialectical argumentation", "author": ["B. Verheij"], "venue": "Proceedings of the 9th International Workshop on Non-Monotonic Reasoning", "citeRegEx": "Verheij,? \\Q2002\\E", "shortCiteRegEx": "Verheij", "year": 2002}, {"title": "Abstract argumentation systems", "author": ["G. Vreeswijk"], "venue": "Artificial Intelligence,", "citeRegEx": "Vreeswijk,? \\Q1997\\E", "shortCiteRegEx": "Vreeswijk", "year": 1997}, {"title": "Math\u00e9matiques discr\u00e8tes et informatique", "author": ["N. Xuong"], "venue": null, "citeRegEx": "Xuong,? \\Q1992\\E", "shortCiteRegEx": "Xuong", "year": 1992}], "referenceMentions": [{"referenceID": 8, "context": "Introduction As shown by Dung (1995), argumentation frameworks provide a unifying and powerful tool for the study of several formal systems developed for common-sense reasoning, as well as for giving a semantics to logic programs.", "startOffset": 25, "endOffset": 37}, {"referenceID": 17, "context": "This enables to simply express to what extent an argument increases the confidence in the statement it supports (see Pollock, 1992; Krause, Ambler, Elvang, & Fox, 1995; Parsons, 1997; Prakken & Sartor, 1997; Amgoud & Cayrol, 1998; Kohlas, Haenni, & Berzati, 2000; Pollock, 2001).", "startOffset": 112, "endOffset": 278}, {"referenceID": 20, "context": "This enables to simply express to what extent an argument increases the confidence in the statement it supports (see Pollock, 1992; Krause, Ambler, Elvang, & Fox, 1995; Parsons, 1997; Prakken & Sartor, 1997; Amgoud & Cayrol, 1998; Kohlas, Haenni, & Berzati, 2000; Pollock, 2001).", "startOffset": 112, "endOffset": 278}, {"referenceID": 20, "context": "Some recent works however consider a combination of both approaches (see Amgoud & Cayrol, 1998; Karacapilidis & Papadias, 2001; Pollock, 2001).", "startOffset": 68, "endOffset": 142}, {"referenceID": 13, "context": "For example, in the work of Krause et al. (1995), using the following knowledge base, composed of (formula, probability) pairs {(\u03c61, 0.", "startOffset": 28, "endOffset": 49}, {"referenceID": 3, "context": "For example, in the work of Besnard and Hunter (2001), the set of values is the interval of the real line [0, 1].", "startOffset": 28, "endOffset": 54}, {"referenceID": 24, "context": "This is one possible way to compute arguments (see also Lin & Shoham, 1989; Vreeswijk, 1997; Pollock, 1992; Prakken & Sartor, 1997; Simari & Loui, 1992; Elvang-Goransson, Fox, & Krause, 1993; Kohlas et al., 2000; Amgoud & Cayrol, 2002).", "startOffset": 46, "endOffset": 235}, {"referenceID": 19, "context": "This is one possible way to compute arguments (see also Lin & Shoham, 1989; Vreeswijk, 1997; Pollock, 1992; Prakken & Sartor, 1997; Simari & Loui, 1992; Elvang-Goransson, Fox, & Krause, 1993; Kohlas et al., 2000; Amgoud & Cayrol, 2002).", "startOffset": 46, "endOffset": 235}, {"referenceID": 14, "context": "This is one possible way to compute arguments (see also Lin & Shoham, 1989; Vreeswijk, 1997; Pollock, 1992; Prakken & Sartor, 1997; Simari & Loui, 1992; Elvang-Goransson, Fox, & Krause, 1993; Kohlas et al., 2000; Amgoud & Cayrol, 2002).", "startOffset": 46, "endOffset": 235}, {"referenceID": 23, "context": "There exist also some other types of interactions (for example, arguments which reinforce other arguments instead of attacking them, see Karacapilidis & Papadias, 2001; Verheij, 2002).", "startOffset": 50, "endOffset": 183}, {"referenceID": 8, "context": "Dung\u2019s (1995) framework is well suited for this kind of approach but allows only for a binary classification: the argument belongs or does not belong to an acceptable set.", "startOffset": 0, "endOffset": 14}, {"referenceID": 18, "context": "For instance, in the work of Pollock (2001), degrees of justification for beliefs are computed.", "startOffset": 29, "endOffset": 44}, {"referenceID": 8, "context": "We use the framework defined by Dung (1995): a set of arguments and a binary attack relation between arguments.", "startOffset": 32, "endOffset": 44}, {"referenceID": 7, "context": "Dung\u2019s (1995) framework and its graphical representation We consider the abstract framework introduced by Dung (1995).", "startOffset": 0, "endOffset": 14}, {"referenceID": 7, "context": "Dung\u2019s (1995) framework and its graphical representation We consider the abstract framework introduced by Dung (1995). An argumentation system <A,R> is a set A of arguments and a binary relation R on A called an attack relation: consider Ai and Aj \u2208 A, AiRAj means that Ai attacks Aj or Aj is attacked by Ai (also denoted by (Ai, Aj) \u2208 R).", "startOffset": 0, "endOffset": 118}, {"referenceID": 3, "context": "For example, using Besnard and Hunter\u2019s (2001) valuation, we can decide that all the arguments whose value is > 0.", "startOffset": 19, "endOffset": 47}, {"referenceID": 8, "context": "The notions introduced here are inspired by related definitions first introduced by Dung (1995) but are not strictly equivalent12.", "startOffset": 84, "endOffset": 96}, {"referenceID": 8, "context": "In Dung\u2019s (1995) work, direct attackers (resp.", "startOffset": 3, "endOffset": 17}, {"referenceID": 12, "context": "In Jakobovits and Vermeir\u2019s (1999) approach, a labelling of a set of arguments assigns a status (accepted, rejected, undecided) to each argument using labels from the set {+,\u2212, ?}.", "startOffset": 3, "endOffset": 35}, {"referenceID": 12, "context": "In Jakobovits and Vermeir\u2019s (1999) approach, a labelling of a set of arguments assigns a status (accepted, rejected, undecided) to each argument using labels from the set {+,\u2212, ?}. + (resp. \u2212, ?) represents the \u201caccepted\u201d (resp. \u201crejected\u201d, \u201cundecided\u201d) status. Intuitively, an argument labelled with ? is both supported and weakened. Definition 4 (Jakobovits and Vermeir\u2019s labellings, 1999) Let <A,R> be an argumentation system. A complete labelling of <A,R> is a function Lab : A \u2192 {+, ?,\u2212} such that: 1. If Lab(A) \u2208 {?,\u2212} then \u2203B \u2208 R\u2212(A) such that Lab(B) \u2208 {+, ?} 2. If Lab(A) \u2208 {+, ?} then \u2200B \u2208 R\u2212(A) \u222aR+(A), Lab(B) \u2208 {?,\u2212} The underlying intuition is that an argument can only be weakened (label \u2212 or ?) if one of its direct attackers is supported (condition 1); an argument can get a support only if all its direct attackers are weakened and an argument which is supported (label + or ?) weakens the arguments it attacks (condition 2). So: If A has no attacker Lab(A) = +. If Lab(A) =? then \u2203B \u2208 R\u2212(A) such that Lab(B) =?. If (\u2200B \u2208 R\u2212(A), Lab(B) = \u2212) then Lab(A) = +. If Lab(A) = + then \u2200B \u2208 R\u2212(A) \u222aR+(A), Lab(B) = \u2212. Every argumentation system can be completely labelled. The associated semantics is that S is an acceptable set of arguments iff there exists a complete labelling Lab of <A,R> such that S = {A|Lab(A) = +}. Other types of labellings are introduced by Jakobovits and Vermeir (1999) among which the so-called \u201crooted labelling\u201d which induces a corresponding \u201crooted\u201d semantics.", "startOffset": 3, "endOffset": 1403}, {"referenceID": 11, "context": "The rooted semantics enables to clarify the links between all the other semantics introduced by Jakobovits and Vermeir (1999) and some semantics introduced by Dung (1995).", "startOffset": 96, "endOffset": 126}, {"referenceID": 8, "context": "The rooted semantics enables to clarify the links between all the other semantics introduced by Jakobovits and Vermeir (1999) and some semantics introduced by Dung (1995).", "startOffset": 159, "endOffset": 171}, {"referenceID": 3, "context": "Another type of local valuation has been introduced recently by Besnard and Hunter (2001) for \u201cdeductive\u201d arguments.", "startOffset": 64, "endOffset": 90}, {"referenceID": 3, "context": "Another type of local valuation has been introduced recently by Besnard and Hunter (2001) for \u201cdeductive\u201d arguments. The approach can be characterised as follows. An argument is structured as a pair \u3008support, conclusion\u3009, where support is a consistent set of formulae that enables to prove the formula conclusion. The attack relation considered here is strict and cycles are not allowed. The notion of a \u201ctree of arguments\u201d allows a concise and exhaustive representation of attackers and defenders of a given argument, root of the tree. A function, called a \u201ccategoriser\u201d, assigns a value to a tree of arguments. This value represents the relative strength of an argument (root of the tree) given all its attackers and defenders. Another function, called an \u201caccumulator\u201d, synthesises the values assigned to all the argument trees whose root is an argument for (resp. against) a given conclusion. The phase of categorisation therefore corresponds to an interaction-based valuation. Besnard and Hunter (2001) introduce the following function Cat: if R\u2212(A) = \u2205, then Cat(A) = 1 if R\u2212(A) 6= \u2205 with R\u2212(A) = {A1, .", "startOffset": 64, "endOffset": 1008}, {"referenceID": 3, "context": "Our approach for local valuations is a generalisation of these two previous proposals in the sense that Besnard and Hunter\u2019s (2001) Cat function and Jakobovits and Vermeir\u2019s (1999) labellings are instances of our approach.", "startOffset": 104, "endOffset": 132}, {"referenceID": 3, "context": "Our approach for local valuations is a generalisation of these two previous proposals in the sense that Besnard and Hunter\u2019s (2001) Cat function and Jakobovits and Vermeir\u2019s (1999) labellings are instances of our approach.", "startOffset": 104, "endOffset": 181}, {"referenceID": 11, "context": "The last properties explain why Jakobovits and Vermeir (1999) and Besnard and Hunter (2001) propose instances of the local valuation described in Definition 6:", "startOffset": 32, "endOffset": 62}, {"referenceID": 3, "context": "The last properties explain why Jakobovits and Vermeir (1999) and Besnard and Hunter (2001) propose instances of the local valuation described in Definition 6:", "startOffset": 66, "endOffset": 92}, {"referenceID": 12, "context": "Property 5 (Link with Jakobovits & Vermeir, 1999) Every rooted labelling of <A,R> in the sense of Jakobovits and Vermeir (1999) can be defined as an instance of the generic valuation such that: V = W = {\u2212, ?,+} with \u2212 < ? < +, VMin = \u2212, VMax = +, g defined by g(\u2212) = +, g(+) = \u2212, g(?) =? and h is the function max.", "startOffset": 98, "endOffset": 128}, {"referenceID": 3, "context": "Property 6 (Link with Besnard & Hunter, 2001) The gradual valuation of Besnard and Hunter (2001) can be defined as an instance of the generic valuation such that: V = [0, 1], W = [0,\u221e[, VMin = 0, VMax = 1, g : W \u2192 V defined by g(x) = 1 1+x and h defined by h(x1, .", "startOffset": 71, "endOffset": 97}, {"referenceID": 3, "context": "Note that, in the work of Besnard and Hunter (2001), the valued graphs are acyclic.", "startOffset": 26, "endOffset": 52}, {"referenceID": 3, "context": "Note that, in the work of Besnard and Hunter (2001), the valued graphs are acyclic. However, it is easy to show that the valuation proposed by Besnard and Hunter (2001) can be generalised to graphs with cycles (in this case, we must solve second degree equations \u2013 see Example 5).", "startOffset": 26, "endOffset": 169}, {"referenceID": 3, "context": "Now, we use the instance of the generic valuation proposed by Besnard and Hunter (2001): v(E1) = v(D2) = v(D3) = v(C4) = v(B4) = 1, v(D1) = v(C2) = v(C3) = v(B3) = 1 2 , v(C1) = v(B2) = 2 3 , 16.", "startOffset": 62, "endOffset": 88}, {"referenceID": 3, "context": "If we use the instance proposed by Besnard and Hunter (2001), v(A) and v(B) are solutions of the following second degree equation: x2 + x\u2212 1 = 0.", "startOffset": 35, "endOffset": 61}, {"referenceID": 8, "context": "3 Main differences between \u201clocal\u201d and \u201cglobal\u201d valuations Cayrol and Lagasquie-Schiex (2003c) give a comparison of these approaches with some existing approaches (Dung, 1995; Jakobovits & Vermeir, 1999; Besnard & Hunter, 2001), and also a comparison of the \u201clocal\u201d approaches and the \u201cglobal\u201d approach.", "startOffset": 163, "endOffset": 227}, {"referenceID": 7, "context": "1 Dung\u2019s (1995) collective acceptability In the framework of collective acceptability, we have to consider the acceptability of a set of arguments.", "startOffset": 2, "endOffset": 16}, {"referenceID": 3, "context": "With the valuation proposed by Besnard and Hunter (2001), we obtain: v(A) = 3 4 and v(A\u2032) = 1 2 .", "startOffset": 31, "endOffset": 57}, {"referenceID": 8, "context": "Dung (1995) proves that: Any admissible set of <A,R> is included in a preferred extension of <A,R>.", "startOffset": 0, "endOffset": 12}, {"referenceID": 2, "context": "Then, using a result issued from the work of Dunne and Bench-Capon (2001, 2002) and reused by Doutre (2002) which shows that, when there is no odd cycle, all the preferred extensions are stable27, we apply Property 14 and we obtain the following consequence:", "startOffset": 55, "endOffset": 108}, {"referenceID": 3, "context": "5 Besnard & Hunter\u2019s (2001) valuation With the instance of the generic valuation proposed by Besnard and Hunter (2001) (see Section 3.", "startOffset": 93, "endOffset": 119}, {"referenceID": 8, "context": "This corresponds to the consistent argumentation system proposed by Dung (1995).", "startOffset": 68, "endOffset": 80}, {"referenceID": 3, "context": "In Example 9, we obtain: With the valuation of Besnard and Hunter (2001) and under the preferred semantics, E \u227b G despite the fact that G is uni-accepted and E is only-exi-accepted.", "startOffset": 47, "endOffset": 73}, {"referenceID": 0, "context": "This has later been extended by Amgoud and Cayrol (1998) where, using a preference relation between arguments (an intrinsic valuation), an argument is accepted if and only if it is preferred to each of its attackers.", "startOffset": 32, "endOffset": 57}, {"referenceID": 3, "context": "D, C2, G, H and A (A is incomparable with B but better than E) for the valuation with tuples, though with the valuation of Besnard and Hunter (2001) the well-defended arguments are D, C2, G, I and E (E is better than A).", "startOffset": 123, "endOffset": 149}, {"referenceID": 7, "context": "Note also that, as in the semantics of Dung (1995), Definition 20 considers the attackers one by one.", "startOffset": 39, "endOffset": 51}, {"referenceID": 3, "context": "It is not suitable for a valuation which handles the \u201cdirect attack\u201d as a whole (as the valuation of Besnard and Hunter (2001) \u2013 see the counterexamples presented in Section 4.", "startOffset": 101, "endOffset": 127}, {"referenceID": 2, "context": "This idea is also used in the notion of \u201cdefeat\u201d proposed by Bench-Capon (2002). So, there is a link between a \u201cwell-defended argument\u201d and an argument which is not \u201cattacked\u201d in the sense of BenchCapon (2002) by its direct attackers.", "startOffset": 61, "endOffset": 80}, {"referenceID": 2, "context": "This idea is also used in the notion of \u201cdefeat\u201d proposed by Bench-Capon (2002). So, there is a link between a \u201cwell-defended argument\u201d and an argument which is not \u201cattacked\u201d in the sense of BenchCapon (2002) by its direct attackers.", "startOffset": 61, "endOffset": 210}, {"referenceID": 2, "context": "This idea is also used in the notion of \u201cdefeat\u201d proposed by Bench-Capon (2002). So, there is a link between a \u201cwell-defended argument\u201d and an argument which is not \u201cattacked\u201d in the sense of BenchCapon (2002) by its direct attackers. Note that, in the work of Bench-Capon (2002), the valuation is an extra knowledge added in the argumentation framework.", "startOffset": 61, "endOffset": 280}, {"referenceID": 8, "context": "First, given a semantics S and a gradual valuation v, it is possible to use the partition issued from Dung (1995) which we have refined:", "startOffset": 102, "endOffset": 114}, {"referenceID": 3, "context": "See the following counterexample for the valuation of Besnard and Hunter (2001):", "startOffset": 54, "endOffset": 80}, {"referenceID": 3, "context": "Remark: The condition (\u2217) stated in Theorem 2 is: false for the local valuation proposed by Besnard and Hunter (2001) as shown in the following graph:", "startOffset": 92, "endOffset": 118}, {"referenceID": 8, "context": "Regarding the second issue, two distinct approaches have been proposed: First, in the context of the collective acceptability of Dung (1995): three levels of acceptability (uni-accepted, exi-accepted, not-accepted) were already defined.", "startOffset": 129, "endOffset": 141}, {"referenceID": 12, "context": "However, the Ai may have different values: for example, for n = 2, with the valuation of Jakobovits and Vermeir (1999), v(A1) = + and v(A2) = \u2212 with g(+) = \u2212 and g(\u2212) = +.", "startOffset": 89, "endOffset": 119}, {"referenceID": 12, "context": "Proof (of Property 5) The valuation proposed by Jakobovits and Vermeir (1999) is the following: Let <A,R> be an argumentation system.", "startOffset": 48, "endOffset": 78}, {"referenceID": 12, "context": "Proof (of Property 5) The valuation proposed by Jakobovits and Vermeir (1999) is the following: Let <A,R> be an argumentation system. A complete labelling of <A,R> is a function Et : A \u2192 {+, ?,\u2212} such that: 1. If Et(A) \u2208 {?,\u2212} then \u2203B \u2208 R\u2212(A) such that Et(B) \u2208 {+, ?} 2. If Et(A) \u2208 {+, ?} then \u2200B \u2208 R\u2212(A) or \u2208 R+(A), Et(B) \u2208 {?,\u2212} Moreover, Jakobovits and Vermeir (1999) also define a complete rooted labelling Et with: \u2200A \u2208 A, if Et(A) = \u2212 then \u2203B \u2208 R\u2212(A) such that Et(B) = +.", "startOffset": 48, "endOffset": 371}, {"referenceID": 3, "context": "Proof (of Property 6) Besnard and Hunter (2001) introduce the following function Cat (in the context of \u201cdeductive\u201d arguments and for an acyclic graph): if R\u2212(A) = \u2205, then Cat(A) = 1", "startOffset": 22, "endOffset": 48}, {"referenceID": 8, "context": "Proof (of Property 13) An argument and one of its direct attackers cannot belong to the same extension in the sense of Dung (1995) because the extension must be conflict-free.", "startOffset": 119, "endOffset": 131}], "year": 2011, "abstractText": "Argumentation is based on the exchange and valuation of interacting arguments, followed by the selection of the most acceptable of them (for example, in order to take a decision, to make a choice). Starting from the framework proposed by Dung in 1995, our purpose is to introduce \u201cgraduality\u201d in the selection of the best arguments, i.e. to be able to partition the set of the arguments in more than the two usual subsets of \u201cselected\u201d and \u201cnon-selected\u201d arguments in order to represent different levels of selection. Our basic idea is that an argument is all the more acceptable if it can be preferred to its attackers. First, we discuss general principles underlying a \u201cgradual\u201d valuation of arguments based on their interactions. Following these principles, we define several valuation models for an abstract argumentation system. Then, we introduce \u201cgraduality\u201d in the concept of acceptability of arguments. We propose new acceptability classes and a refinement of existing classes taking advantage of an available \u201cgradual\u201d valuation.", "creator": "dvips(k) 5.92b Copyright 2002 Radical Eye Software"}}}