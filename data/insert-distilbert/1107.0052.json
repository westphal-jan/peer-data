{"id": "1107.0052", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "30-Jun-2011", "title": "Ordered Landmarks in Planning", "abstract": "many broadly known planning procedure tasks have inherent constraints concerning the best order in which to achieve the goals. a number of research efforts have been made to detect such constraints and to use them for guiding search, in the hope of speeding up the revised planning process. we go fast beyond the previous approaches conducted by considering ordering constraints established not only over the ( top - level ) goals, but also over the sub - goals that will necessarily arise during planning. landmarks examples are facts that must be true at some point in every valid solution plan. we extend koehler and hoffmann's definition of reasonable orders between top level goals to the more general case of landmarks. we show how landmarks can be found, examining how their reasonable orders only can be approximated, and how this information can be used to decompose a given planning task into several smaller sub - tasks. our methodology is completely domain - and planner - independent. the underlying implementation demonstrates that the approach can yield significant runtime performance improvements when used as a control loop around state - of - the - art sub - optimal planning systems, as exemplified by ff and lpg.", "histories": [["v1", "Thu, 30 Jun 2011 20:43:14 GMT  (235kb)", "http://arxiv.org/abs/1107.0052v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["j hoffmann", "j porteous", "l sebastia"], "accepted": false, "id": "1107.0052"}, "pdf": {"name": "1107.0052.pdf", "metadata": {"source": "CRF", "title": null, "authors": [], "emails": [], "sections": [{"heading": "Journal of Arti ial Intelligen e Resear h 22 (2004) 215-278 Submitted 05/04; published 11/04", "text": "Ordered Landmarks in PlanningJ org Ho mann hoffmann mpi-sb.mpg.deMax-Plan k-Institut f ur Informatik,Saarbr u ken, GermanyJulie Porteous Julie.Porteous is.strath.a .ukDepartment of Computer and Information S ien es,The University of Strath lyde,Glasgow, UKLaura Sebastia lstarin dsi .upv.esDpto. Sist. Inform ati os y Computa i on,Universidad Polit e ni a de Valen ia,Valen ia, Spain Abstra tMany known planning tasks have inherent onstraints on erning the best order inwhi h to a hieve the goals. A number of resear h e orts have been made to dete t su h onstraints and to use them for guiding sear h, in the hope of speeding up the planningpro ess.We go beyond the previous approa hes by onsidering ordering onstraints not onlyover the (top-level) goals, but also over the sub-goals that will ne essarily arise duringplanning. Landmarks are fa ts that must be true at some point in every valid solutionplan. We extend Koehler and Ho mann's de nition of reasonable orders between top levelgoals to the more general ase of landmarks. We show how landmarks an be found,how their reasonable orders an be approximated, and how this information an be usedto de ompose a given planning task into several smaller sub-tasks. Our methodology is ompletely domain- and planner-independent. The implementation demonstrates that theapproa h an yield signi ant runtime performan e improvements when used as a ontrolloop around state-of-the-art sub-optimal planning systems, as exempli ed by FF and LPG.1. Introdu tionGiven the inherent omplexity of the general planning problem it is learly important todevelop good heuristi strategies for both managing and navigating the sear h spa e involvedin solving a parti ular planning instan e. One way in whi h sear h an be informed is byproviding hints on erning the order in whi h planning goals should be addressed. This an make a signi ant di eren e to sear h e\u00c6 ien y by helping to fo us the planner ona progressive path towards a solution. Work in this area in ludes that of Koehler andHo mann (2000). They introdu e the notion of reasonable orders whi h states that a pairof goals A and B an be ordered so that B is a hieved before A if it isn't possible to rea h astate in whi h A and B are both true, from a state in whi h just A is true, without havingto temporarily destroy A. In su h a situation it is reasonable to a hieve B before A to avoidunne essary e ort. 2004 AI A ess Foundation. All rights reserved.\nHoffmann, Porteous & SebastiaThe main idea behind the work dis ussed in this paper is to extend those previousideas on orders by not only ordering the (top-level) goals, but also the sub-goals thatwill ne essarily arise during planning, i.e., by also taking into a ount what we all thelandmarks. The key feature of a landmark is that it must be true at some point on anysolution path to the given planning task. Consider the Blo ksworld task shown in Figure 1,whi h will be our illustrative example throughout the paper. A C D BD CBA initial state goal Figure 1: Example Blo ksworld task.For the reader who is weary of seeing toy examples like the one in Figure 1 in theliterature, we remark that our te hniques are not primarily motivated by this example. Ourte hniques are useful in mu h more omplex situations. We use the depi ted toy exampleonly for easy demonstration of some of the important points. In the example, lear(C) isa landmark be ause it will need to be a hieved in any solution plan. Immediately sta kingB on D from the initial state will a hieve one of the top level goals of the task but it willresult in wasted e ort if lear(C) is not a hieved rst. To order lear(C) before on(B D) is,however, not reasonable in terms of Koehler and Ho mann's de nition. First, lear(C) is nota top level goal so it is not onsidered by Koehler and Ho mann's te hniques. Se ond, thereare states where B is on D and from whi h lear(C) an be a hieved without unsta king Bfrom D again ( ompare the de nition of reasonable orders given above). But rea hing su ha state requires unsta king D from C, and thus a hieving lear(C), in the rst pla e. This,together with the fa t that lear(C) must be made true at some point, makes it sensible toorder lear(C) before on(B D).We propose a natural extension of Koehler and Ho mann's de nitions to the moregeneral ase of landmarks (trivially, all top level goals are landmarks, too). We also reviseparts of the original de nition to better apture the intuitive meaning of a goal ordering. Theextended and revised de nitions apture, in parti ular, situations of the kind demonstratedwith lear(C) on(B D) in the toy example above. We also introdu e a new kind of orderingthat often o urs between landmarks: A an be ordered before B if all valid solution plansmake A true before they make B true. We all su h orders ne essary. Typi ally, a fa tis a landmark be ause it is ne essarily ordered before some other landmark. For example, lear(C) is ne essarily ordered before holding(C), and holding(C) is ne essarily orderedbefore the top level goal on(C A), in the above Blo ksworld example.De iding if a fa t is a landmark, and de iding about our ordering relations, is PSPACE- omplete. We des ribe pre-pro essing te hniques that extra t landmarks, and that approx-imate ne essary orders between them. We introdu e su\u00c6 ient riteria for the existen eof reasonable orders between landmarks. The riteria are based on ne essary orders, andin onsisten ies between fa ts.1 Using an in onsisten y approximation te hnique from the1. Two fa ts are in onsistent if they are not true together in any rea hable world state.216\nOrdered Landmarks in Planningliterature, we approximate reasonable orders based on our su\u00c6 ient riteria. After thesepre-pro esses have terminated, what we get is a dire ted graph where the nodes are thefound landmarks, and the edges are the orders found between them. We all this graph thelandmark generation graph, short LGG. This graph may ontain y les be ause for some ofour orders there is no guarantee that there is a plan, or even an a tion sequen e, that obeysthem.2 Our method for stru turing the sear h for a plan an not handle y les in the LGG,so we remove y les by removing edges in ident upon them. We end up with a polytreestru ture.3On e turned into a polytree, the LGG an be used to de ompose the planning taskinto small hunks. We propose a method that does not depend on any parti ular planningframework. The landmarks provide a sear h ontrol loop that an be used around any baseplanner that is apable of dealing with STRIPS input. The sear h ontrol does not preserveoptimality so there is not mu h point in using it around optimal planners su h as Graphplan(Blum & Furst, 1997) and its relatives. Optimal planners are generally outperformed bysub-optimal planners anyway. It does make sense, however, to use the ontrol in orderto further improve the runtime performan e of sub-optimal approa hes to planning. Todemonstrate this, we used the te hnique for ontrol of two versions of FF (Ho mann, 2000;Ho mann & Nebel, 2001), and for ontrol of LPG (Gerevini, Saetti, & Serina, 2003). Weevaluated these planners a ross a range of 8 domains. We onsistently obtain, sometimesdramati , runtime improvements for the FF versions. We obtain runtime improvementsfor LPG in around half of the domains. The runtime improvement is, for all the planners,usually bought at the ost of slightly longer plans. But there are also some ases where theplans be ome shorter when using landmarks ontrol.The paper is organised as follows. Se tion 2 gives the basi notations. Se tion 3 de neswhat landmarks are, and in what relations between them we are interested. Exa t ompu-tation of the relevant pie es of information is shown to be PSPACE- omplete. Se tion 4explains our approximation te hniques, and Se tion 5 explains how we use landmarks tostru ture the sear h of an arbitrary base planner. Se tion 6 provides our empiri al results ina range of domains. Se tion 7 loses the paper with a dis ussion of related work, of our on-tributions, and of future work. Most proofs are moved into Appendix A, and repla ed in thetext by proof sket hes, to improve readability. Appendix B provides runtime distributiongraphs as supplementary material to the tables provided in Se tion 6. Appendix C dis ussessome details regarding our experimental implementation of landmarks ontrol around LPG.2. NotationsWe onsider sequential planning in the propositional STRIPS (Fikes & Nilsson, 1971) frame-work. In the following, all sets are assumed to be nite. A state s is a set of logi al fa ts(atoms). An a tion a is a triple a = (pre(a); add(a); del(a)) where pre(a) are the a tion'spre onditions, add(a) is its add list, and del(a) is its delete list, ea h a set of fa ts. The2. Also, none of our ordering relations is transitive. We sti k to the word \\order\" only be ause it is themost intuitive word for onstraints on the relative points in time at whi h planning fa ts an or shouldbe a hieved.3. Removing edges in ident on y les might, of ourse, throw away useful ordering information. Comingup with other methods to treat y les, or with methods that an exploit the information ontained inthem, is an open resear h topi . 217\nHoffmann, Porteous & Sebastiaresult of applying (the a tion sequen e onsisting of) a single a tion a to a state s is:Result(s; hai) = ( (s [ add(a)) n del(a) pre(a) sunde ned otherwiseThe result of applying a sequen e of more than one a tion to a state is re ursively de ned asResult(s; ha1; : : : ; ani) = Result(Result(s; ha1; : : : ; an 1i); hani). Applying an empty a tionsequen e hanges nothing, i.e., Result(s; hi) = s. A planning task (A; I;G) is a triple whereA is a set of a tions, and I (the initial state) and G (the goals) are sets of fa ts (we usethe word \\task\" rather than \\problem\" in order to avoid onfusion with the omplexity-theoreti notion of de ision problems). A plan, or solution, for a task (A; I;G) is an a tionsequen e P 2 A su h that G Result(I; P ).3. Ordered Landmarks: What They AreIn this se tion we introdu e our framework. We de ne what landmarks are, and in whatrelations between them we are interested. We show that all the orresponding de isionproblems are PSPACE- omplete. Se tion 3.1 introdu es landmarks and ne essary orders,Se tion 3.2 introdu es reasonable orders, and Se tion 3.3 introdu es obedient reasonableorders (orders that are reasonable if one has already ommitted to obey a given a-priori setof reasonable ordering onstraints).3.1 Landmarks, and Ne essary OrdersLandmarks are fa ts that must be true at some point during the exe ution of any solutionplan.De nition 1 Given a planning task (A; I;G). A fa t L is a landmark if for all P =ha1; : : : ; ani 2 A ; G Result(I; P ) : L 2 Result(I; ha1; : : : ; aii) for some 0 i n.Note that in an unsolvable task all fa ts are landmarks (by universal quanti ation overthe empty set of solution plans in the above de nition). The de nition thus only makessense if the task at hand is solvable. Indeed, while our landmark te hniques an help aplanning algorithm to nd a solution plan faster (as we will see later), they are not usefulfor proving unsolvability. The reasonable orders we will introdu e are based on heuristi notions that make sense intuitively, but that are not mandatory in the sense that everysolution plan obeys them, or even in the sense that there exists a solution plan that obeysthem. Details on this topi are given with the individual on epts below. We remark thatwe make these observations only to larify the meaning of our de nitions. Given the way weuse the landmarks information for planning, for our purposes it is not essential if or if notan ordering onstraint is mandatory. Our sear h ontrol loop only suggests to the plannerwhat might be good to a hieve next, it does not for e the planner to do so (see Se tion 5).Initial and goal fa ts are trivially landmarks: set i to 0 respe tively n in De nition 1.In general, it is PSPACE- omplete to de ide whether a fa t is a landmark or not.Theorem 1 Let LANDMARK denote the following problem: given a planning task (A; I;G),and a fa t L; is L a landmark?De iding LANDMARK is PSPACE- omplete.218\nOrdered Landmarks in PlanningProof Sket h: PSPACE-hardness follows by a straightforward redu tion of the omple-ment of PLANSAT{ the de ision problem of whether there exists a solution plan to agiven arbitrary STRIPS task (Bylander, 1994) { to the problem of de iding LANDMARK.PSPACE-membership follows vi e versa. 2Full proofs are in Appendix A. One of the most elementary ordering relations betweena pair L and L0 of landmarks is the following. In any a tion sequen e that makes L0 true insome state, L is true in the immediate pre eding state. Typi ally, a fa t L is a landmarkbe ause it is ordered in this way before some other landmark L0. The reason is typi allythat L is a ne essary prerequisite { a shared pre ondition { for a hieving L0. We will exploitthis for our approximation te hniques in Se tion 4.De nition 2 Given a planning task (A; I;G), and two fa ts L and L0. There is a ne essaryorder between L and L0, written L !n L0, if L0 62 I, and for all P = ha1; : : : ; ani 2 A : ifL0 2 Result(I; ha1; : : : ; ani) then L 2 Result(I; ha1; : : : ; an 1i).The de nition allows for arbitrary fa ts, but the ase that we will be interested in is the ase where L and L0 are landmarks. Note that if L0 2 Result(I; ha1; : : : ; ani) then n 1as L0 62 I. The intention behind a ne essary order L !n L0 is that one must have L truebefore one an have L0 true. So it does not make sense to allow su h orders for initial fa tsL0. It is important that L is postulated to be true dire tly before L0 { this way, if two fa tsL and L00 are ne essarily ordered before the same fa t L0, one an on lude that L and L00must be true together at some point. We make use of this observation in our approximationof reasonable orders (see Se tion 4.2).We denote ne essary orders, and all the other ordering relations we will introdu e, asdire ted graph edges \\!\" rather than with the more usual \\<\" symbol. We do this to avoid onfusion about the meaning of our relations. As said earlier, none of the ordering relationswe introdu e is transitive. (Note that !n would be transitive if L was only postulated tohold sometime before L0, not dire tly before it.)Ne essary orders are mandatory. We say that an a tion sequen e ha1; : : : ; ani obeys anorder L ! L0 if the sequen e makes L true the rst time before it makes L0 true the rsttime. Pre isely, ha1; : : : ; ani obeys L ! L0 if either L 2 I, or minfi j L 2 add(ai)g <minfi j L0 2 add(ai)g where the minimum over an empty set is 1. That is, either L istrue initially, or L0 is not added at all, or L is added before L0. By de nition, any a tionsequen e obeys ne essary orders. So one does not lose solutions if one for es a planner toobey ne essary orders, i.e. if one disallows plans violating the orders. (We reiterate thatthis is a purely theoreti al observation; as said above, our sear h ontrol does not enfor ethe found ordering onstraints.)Theorem 2 Let NECESSARY-ORD denote the following problem: given a planning task(A; I;G), and two fa ts L and L0; does L!n L0 hold?De iding NECESSARY-ORD is PSPACE- omplete.Proof Sket h: PSPACE-hardness follows by redu ing the omplement of PLANSAT toNECESSARY-ORD. PSPACE-membership follows with a non-deterministi algorithm thatguesses a tion sequen es and he ks if there is a ounter example to the ordering. 2219\nHoffmann, Porteous & SebastiaAnother interesting relation are greedy ne essary orders, a slightly weaker version of thene essary orders above. We postulate not that L is true prior to L0 in all a tion sequen es,but only in those a tion sequen es where L0 is a hieved for the rst time. These are theorders that we a tually approximate and use in our implementation (see Se tion 4).De nition 3 Given a planning task (A; I;G), and two fa ts L and L0. There is a greedyne essary order between L and L0, written L!gn L0, if L0 62 I, and for all P = ha1; : : : ; ani 2A : if L0 2 Result(I; ha1; : : : ; ani) and L0 62 Result(I; ha1; : : : ; aii) for 0 i < n, thenL 2 Result(I; ha1; : : : ; an 1i).Like above with the ne essary orders, the a tion sequen e a hieving L0 must ontain atleast one step as L0 62 I. Obviously, !n is stronger than !gn, that is, with L !n L0 fortwo fa ts L and L0, L !gn L0 follows. Greedy ne essary orders are still mandatory in thesense that every a tion sequen e obeys them.The de nition of greedy ne essary orders aptures the fa t that, really, what we areinterested in is what happens when we dire tly a hieve L0 from the initial state, rather thanin some remote part of the state spa e. The onsideration of these more remote parts ofthe state spa e, whi h is inherent in the de nition of the non-greedy ne essary orders, anmake us lose useful information. Consider the Blo ksworld example in Figure 1. There isa greedy ne essary order between lear(D) and lear(C), lear(D) !gn lear(C), but not ane essary order, lear(D) 6!n lear(C). If we make lear(C) true the rst time in an a tionsequen e from the initial state, then the a tion a hieving lear(C) will always be unsta k(DC), whi h requires lear(D) to be true. On the other hand, there an of ourse be a tionsequen es whi h a hieve lear(C) by di erent a tions (unsta k(A C), for example). Butrea hing a state where lear(C) an be a hieved by su h an a tion involves unsta king Dfrom C, and thus a hieving lear(C), in the rst pla e. We will see later (Se tion 4.2) thatthe order lear(D) !gn lear(C) an be used to make the important inferen e that lear(C)is reasonably ordered before on(B D).More generally, the de nition of greedy ne essary orders is made from the perspe tivethat we are interested in ordering the rst o uren e of the fa ts L in our desired solutionplan. All de nitions and algorithms in the rest of this paper are designed from this sameperspe tive. Sin e a fa t might (have to) be made true several times in a solution plan, one ould just as well fo us on ordering the fa t's last o uren e, or any o uren e, or severalo uren es of it. We hose to fo us on the rst o uren es of fa ts mainly in order to keepthings simple. It seems very hard to say anything useful a priori about exa tly how oftenand when some fa t will need to be ome true in a plan. The \\greedy assumption\" that ourapproa h thus makes is that all the landmarks need to be a hieved only on e, and that it isbest to a hieve them as early as possible. Of ourse this assumption is not always justi ed,and may lead to di\u00c6 ulties, su h as e.g. y les in the generated LGG (see also Se tions 4.4and 6.8). Generalising our approa h to take a ount of several o uren es of the same fa tis an open resear h topi .Theorem 3 Let GREEDY-NECESSARY-ORD denote the following problem: given a plan-ning task (A; I;G), and two fa ts L and L0; does L!gn L0 hold?De iding GREEDY-NECESSARY-ORD is PSPACE- omplete.220\nOrdered Landmarks in PlanningProof Sket h: By a minor modi ation of the proof to Theorem 2. 23.2 Reasonable OrdersReasonable orders were rst introdu ed by Koehler and Ho mann (2000), for top levelgoals. We extend their de nition, in a slightly revised way, to landmarks.Let us rst reiterate what the idea of reasonable orders was originally. The idea in-trodu ed by Koehler and Ho mann is this. If the planner is in a state s where one goalL0 has just been a hieved, but another goal L is still false, and L0 must be destroyed inorder to a hieve L, then it might have been better to a hieve L rst: to get to a goal statefrom s, the planner will have to delete and re-a hieve L0. If the same situation arises in allstates s where L0 has just been a hieved but L is false, then it seems reasonable to generallyintrodu e an ordering onstraint L! L0, indi ating that L should be a hieved prior to L0.The lassi al example for two fa ts with a reasonable ordering onstraint are on relationsin Blo ksworld, where on(B, C) is reasonably ordered before on(A, B) whenever the goal isto have both fa ts true in the goal state. Obviously, if one a hieves on(A, B) rst then onehas to unsta k A again in order to a hieve on(B, C).Think about an unmodi ed appli ation of Koehler and Ho mann's de nition to the aseof landmarks. Consider a state s where we have a landmark L0, but not another landmarkL, and a hieving L involves deleting L0. Does it matter? It might be that we do not needto a hieve L from s anyway. It might also be that we do not need L0 anymore on e wehave a hieved L. In both ases, there is no need to delete and re-a hieve L0, and it doesnot appear reasonable to introdu e the onstraint L ! L0. The question is, under whi h ir umstan es is it reasonable? The answer is given by the two mentioned ounter-examples.The situation matters if 1. we need to a hieve L from s, and 2. we must re-a hieve L0 againafterwards. Both onditions are trivially ful lled when L and L0 are top level goals. Ourde nition below makes sure they hold for the landmarks L and L0 in question.We say that there is a reasonable ordering onstraint between two landmarks L and L0if, starting from any state where L0 was a hieved before L: L0 must be true at some pointlater than the a hievement of L; and one must delete L0 on the way to L. Formally, we rstde ne the \\set of states where L0 was a hieved before L\", then we de ne what it meansthat \\L0 must be true at some point later than the a hievement of L\", then based on thatwe de ne what reasonable orders are.De nition 4 Given a planning task (A; I;G), and two fa ts L and L0.1. By S(L0;:L), we denote the set of states s su h that there exists P = ha1; : : : ; ani 2 A ,s = Result(I; P ), L0 2 add(an), and L 62 Result(I; ha1; : : : ; aii) for 0 i n.2. L0 is in the aftermath of L if, for all states s 2 S(L0;:L), and all solution plansP = ha1; : : : ; ani 2 A from s, G Result(s; P ), there are 1 i j n su h thatL 2 Result(s; ha1; : : : ; aii) and L0 2 Result(s; ha1; : : : ; aji).3. There is a reasonable order between L and L0, written L !r L0, if L0 is in theaftermath of L, and8 s 2 S(L0;:L) : 8 P 2 A : L 2 Result(s; P )) 9 a 2 P : L0 2 del(a)221\nHoffmann, Porteous & SebastiaLet us explain this de nition, and how it di ers from Koehler and Ho mann's originalone.1. S(L0;:L) ontains the states where L0 was just added, but L was not true yet. These arethe states we onsider: we are interested to know if, from every state s 2 S(L0;:L), wewill have to delete and re-a hieve L0. In Koehler and Ho mann's original de nition,S(L0;:L) ontained more states, namely all those states s where L0 was just added butL 62 s. This de nition allowed ases where L was a hieved already but was deletedagain. Our revised de nition aptures better the intuition that we want to onsiderall states where L0 was a hieved before L. The revised de nition also makes sure that,for a landmark L, any solution plan starting from s 2 S(L0;:L) must a hieve L at somepoint.2. The de nition of the aftermath relation just says that, in a solution plan startingfrom s 2 S(L0;:L), L0 must be true simultaneously with L, or at some later time point.Koehler and Ho mann didn't need su h a de nition sin e this ondition is triviallyful lled for top level goals.3. The de nition of L !r L0 then says that, from every s 2 S(L0;:L), every a tionsequen e a hieving L deletes L0 at some point. With the additional postulation thatL0 is in the aftermath of L, this implies that from every s 2 S(L0;:L) one needs todelete and re-a hieve L0. Koehler and Ho mann's de nition here is identi al ex eptthat they do not need to postulate the aftermath relation.Be ause in their de nition S(L0;:L) ontains more states, and top level goals are triviallyin the aftermath of ea h other, Koehler and Ho mann's!r de nition is stronger than ours,i.e. L!r L0 in the Koehler and Ho mann sense implies L!r L0 as de ned above (we givean example below where our, but not the Koehler and Ho mann L!r L0 relation holds).4It is important to note that reasonable orders are not mandatory. An order L !r L0only says that, if we a hieve L0 before L, we will need to delete and re-a hieve L0. Thismight mean that a hieving L0 before L is wasted e ort. But there are ases where, in thepro ess of a hieving some landmark L, one has no other hoi e but to a hieve, delete, andre-a hieve a landmark L0. In the Towers of Hanoi domain, for example, this is the ase fornearly all pairs of top level goals { namely, for all those pairs of goals that say that (L0)dis i must be lo ated on dis i + 1, and (L) dis i + 1 must be lo ated on dis i + 2. Insu h a situation, for ing a planner to obey the order L !r L0 uts out all solution paths.One an also easily onstru t ases where L !r L0 and L0 !r L hold for goals L and L0(that an not be a hieved simultaneously). Consider the following example. There are the4. Note that an order L!r L0 intends to tell us that we should not a hieve L0 before L. This leaves openthe option to a hieve L and L0 simultaneously. In that sense, our de nition (given above in Se tion 3.1)of what it means to obey an order L ! L0, namely to add L stri tly before L0, is a bit too restri tive.In our experien e, the restri tion is irrelevant in pra ti e. In none of the many ben hmarks we tried didwe observe fa ts that were reasonably ordered (ordered at all, in fa t) relative to ea h other and that ould be a hieved with the same a tion { remember that we onsider the sequential planning setting.We remark that one an easily adapt our framework to take a ount of simultaneous a hievement of Land L0. No hanges are needed ex ept in the approximation of obedient reasonable orders, whi h wouldbe ome slightly more ompli ated, see Se tion 4.3.222\nOrdered Landmarks in Planningseven fa ts L, L0, P1, P2, P 02, P3, and P 03. Initially only P1 is true, and the goal is to haveL and L0. The a tions are:name (pre; add; del)opL1 = (fP1g; fL;P2g; fP1g)opL01 = (fP1g; fL0; P 02g; fP1g)opL2 = (fP 02g; fL;P3g; fL0; P 02g)opL02 = (fP2g; fL0; P 03g; fL;P2g)opL3 = (fP 03g; fLg; fP 03g)opL03 = (fP3g; fL0g; fP3g)Figure 2 shows the state spa e of the example. There are exa tly two solution paths, hopL1, opL02, opL3 i and h opL01, opL2, opL03 i. The rst of these paths a hieves, deletes,and re-a hieves L, the se ond one does the same with L0. S(L0;:L) ontains the single statethat results from applying opL01 to the initial state. From that state, one has to apply opL2in order to a hieve L, deleting L0, so L!r L0 holds. Similarly, it an be seen that L0 !r Lholds. Note that either solution path disobeys one of the two reasonable orders. P\u2019 { L, 3P } { L\u2019, 3P\u2019 } { L, L\u2019 } opL 3 opL\u2019\nopL\u2019 3\nopL 1\n2\n{ P 1}\n1 opL\u2019\n} }\n2 opL 2 { L, 2P\n{ L\u2019,Figure 2: State spa e of the example.We reiterate that the above are purely theoreti al observations made to larify the mean-ing of our de nitions. Our sear h ontrol does not enfor e the found ordering onstraints,it only suggests them to the planner.While reasonable orders L !r L0 are not mandatory, they an help to redu e sear he ort in those ases where a hieving L0 before L does imply wasted e ort. Our Blo ksworldexample from Figure 1 onstitutes su h a ase. In the example, it makes no sense tosta k B onto D while D is still lo ated on C, be ause C has to end up on top of A. ByDe nition 4, lear(C) !r on(B D) holds: S(on(BD);: lear(C)) ontains only states where Bhas been sta ked onto D, but D is still on top of C. From these states, one must deleteon(B D) in order to a hieve lear(C). Further, on(B D) is a top-level goal so it is in theaftermath of lear(C), and lear(C) !r on(B D) follows. The order does not hold in termsof Koehler and Ho mann's de nition, be ause there the S(on(BD);: lear(C)) state set also ontains states where D was already removed from C.Like the previous de ision problems, those related to the aftermath relation and toreasonable orders are PSPACE- omplete.Theorem 4 Let AFTERMATH denote the following problem: given a planning task (A; I;G),and two fa ts L and L0; is L0 in the aftermath of L?De iding AFTERMATH is PSPACE- omplete.223\nHoffmann, Porteous & SebastiaProof Sket h: PSPACE-hardness follows by redu ing the omplement of PLANSAT toAFTERMATH. PSPACE-membership follows by a non-deterministi algorithm that guesses ounter examples. 2Theorem 5 Let REASONABLE-ORD denote the following problem: given a planning task(A; I;G), and two fa ts L and L0 su h that L0 is in the aftermath of L; does L!r L0 hold?De iding REASONABLE-ORD is PSPACE- omplete.Proof Sket h: PSPACE-hardness follows by redu ing the omplement of PLANSAT toREASONABLE-ORD, with the same onstru tion as used by Koehler and Ho mann (2000)for the original de nition of reasonable orders. PSPACE-membership follows by a non-deterministi algorithm that guesses ounter examples. 23.3 Obedient Reasonable OrdersSay we already have a set O of reasonable ordering onstraints L!r L0. The question wefo us on in the se tion at hand is, if a planner ommits to obey all the onstraints in O, doother reasonable orders arise? The answer is, yes, there might.Consider the following situation. Say we got landmarks L and L0, su h that we mustdelete L0 in order to a hieve L. Also, there is a third landmark L00 su h that L0 !n L00and L !r L00. Now, if the order L ! L00 was ne essary, L !n L00, then we would havea reasonable order L !r L0: L and L0 would need to be true together immediately priorto the a hievement of L00, so L0 would be in the aftermath of L. However, the ordering onstraint L ! L00 is \\only\" reasonable so there is no guarantee that a solution plan willobey it. A plan an hoose to a hieve L0 before L00 before L, and thereby avoid deletionand re-a hievement of L0. But if we enfor e the ordering onstraint L !r L00, disallowingplans that do not obey it, then a hieving L0 before L leads to deletion and re-a hievementof L0 and is thus not reasonable.With the above, the idea we pursue now is to de ne a weaker form of reasonable or-ders, whi h are obedient in the sense that they only arise if one ommits to a given set Oof (previously omputed) reasonable ordering onstraints. In our experiments, using (anapproximation of) su h obedient reasonable orders, on top of the reasonable orders them-selves, resulted in signi antly better planner performan e in a few domains (su h as theBlo ksworld), and made no di eren e in the other domains. Summarised, what we do is,we start from the set O of reasonable orders already omputed by our approximations, andthen insert new orders that are reasonable given one ommits to obey the onstraints inO. We do this just on e, i.e. we do not ompute a xpoint. The details are in Se tion 4.3.Right now, we de ne what obedient reasonable orders are.The de nition of obedient reasonable orders is almost the same as that of reasonableorders. The only di eren e lies in that we onsider only a tion sequen es that are obedientin the sense that they obey all ordering onstraints in the given set O. The de nition ofwhen an a tion sequen e ha1; : : : ; ani obeys an order L ! L0 was already given above: ifeither L 2 I, or minfi j L 2 add(ai)g < minfi j L0 2 add(ai)g where the minimum over anempty set is 1. 224\nOrdered Landmarks in PlanningDe nition 5 Given a planning task (A; I;G), a set O of reasonable ordering onstraints,and two fa ts L and L0.1. By SO(L0;:L), we denote the set of states s su h that there exists an obedient a tionsequen e P = ha1; : : : ; ani 2 A , with s = Result(I; P ), L0 2 add(an), and L 62Result(I; ha1; : : : ; aii) for 0 i n.2. L0 is in the obedient aftermath of L if, for all states s 2 SO(L0;:L), and all obedient solu-tion plans P = ha1; : : : ; ani 2 A , G Result(I; P ), where s = Result(I; ha1; : : : ; aki),there are k i j n su h that L 2 Result(I; ha1; : : : ; aii) and L0 2 Result(I;ha1; : : : ; aji).3. There is an obedient reasonable order between L and L0, written L !Or L0, if andonly if L0 is in the obedient aftermath of L, and8 s 2 SO(L0;:L) : 8 P 2 A : L 2 Result(s; P )) 9 a 2 P : L0 2 del(a)This de nition is very similar to De nition 4 and thus should be self-explanatory, inits formal aspe ts. The de nition of the aftermath relation looks a little more ompli atedbe ause the solution plan P starts from the initial state, not from s as in De nition 4, andrea hes s with a tion ak. This is just a minor te hni al devi e to over the ase where, forsome of the L1 !r L2 onstraints in O, L1 is ontained in s already (and thus does notneed to be added after s in order to obey L1 !r L2). Note that, in part 3 of the de nition,the a tion sequen es P a hieving L are not required to be obedient. While it would makesense to impose this requirement, our approximation te hniques (that will be introdu ed inSe tion 4.3) only take a ount of O in the omputation of the aftermath relation anyway. Itis an open question how our other approximation te hniques ould be made to take a ountof O.We remark that the modi ed de nitions do not hange the omputational omplexityof the orresponding de ision problems.5 As a qui k illustration of the new de nitions,re onsider the situation des ribed above. There, L0 is not in the aftermath of L, but inthe obedient aftermath of L be ause all a tion sequen es that obey the onstraint L!r L00make L0 true at a point simultaneously with or behind L (namely immediately prior to L00,assuming that there is no a tion that adds both L and L00). As L0 must be deleted in orderto a hieve L, we obtain the ordering L !fL!rL00gr L0. That is, if the planner obeys the onstraint L!r L00 then it is reasonable to also order L before L0.Just like the reasonable orders, the obedient reasonable orders are not mandatory. En-for ing an obedient reasonable order an ut out all solution paths. The reason is the sameas for the reasonable orders. An order L !Or L0 only says that, given we want to obeyO, a hieving L0 before L implies deletion and re-a hievement of L0. If this really meansthat a hieving L0 before L is wasted e ort, the order tells us nothing about. Consider thefollowing example. There are the ten fa ts L, L0, L00, P , A1, A2, A3, B1, B2, and B3.5. For the obedient aftermath relation, minor modi ations of the proof to Theorem 4 su\u00c6 e. PSPACE-hardness follows by using the empty set of ordering onstraints. PSPACE-membership follows by ex-tending the non-deterministi de ision algorithm with ags that he k if the ordering onstraints areadhered to. Similarly for obedient reasonable orders and the proof to Theorem 5.225\nHoffmann, Porteous & SebastiaInitially only P is true, and the goal is to have L, L0, and L00. The onstru tion is madeso that L!r L00, and L 6!r L0 but L!fL!rL00gr L0. Enfor ing L!fL!rL00gr L0 renders thetask unsolvable. The a tions are:name (pre; add; del)opA = (fPg; fA1g; fPg)opB = (fPg; fB1g; fPg)opA1 = (fA1g; fL0; L00; A2g; fA1g)opA2 = (fA2g; fL;A3g; fL00; A2g)opA3 = (fA3g; fL00g; fA3g)opB1 = (fB1g; fL0; B2g; fB1g)opB2 = (fB2g; fL;B3g; fL0; B2g)opB3 = (fB3g; fL0; L00g; fB3g)Figure 3 shows the state spa e of the example. One has to hoose one out of two options.First, one applies opA to the initial state and then pro eeds with opA1, opA2, and opA3.Se ond, one applies opB to the initial state and pro eeds with opB1, opB2, and opB3.The rst option is the only one where L00 be omes true before L. One has to delete L00 withopA2, and re-a hieve it with opA3. For this reason, the order L !r L00 holds. The orderL!r L0 does not hold be ause if one hooses the rst option then L0 be omes true prior toL, and is never deleted. However, ommitting to the order L !r L00 means ex luding the rst option. In the se ond option, L0 be omes true before L, and must then be deleted andre-a hieved, so we get the order L !fL!rL00gr L0. But there is no solution plan that obeysthis order be ause there is no way to make L true before (or, even, simultaneously with)L0. L\u2019, { 2 opB L, { L\u2019, L\u2019\u2019, A2} }{ 2 opA L, L\u2019, A3\nB }2 B3}\nopA 3 opB 3 { { L, L\u2019, L\u2019\u2019}{ P opB\nopA 1\n1 opB\n}\n}\n1\n1AopA\n}\nB{ { Figure 3: State spa e of the example.4. How to Find Ordered LandmarksWe now des ribe our methods to nd landmarks in a given planning task, and to approx-imate their inherent ordering onstraints. The result of the pro ess is a dire ted graph inthe obvious way, the landmarks generation graph (LGG). Se tion 4.1 des ribes how we ndlandmarks, and how we approximate greedy ne essary orders between them. Se tion 4.2gives a su\u00c6 ient riterion for reasonable orders, based on greedy ne essary orders and fa tin onsisten ies, and des ribes how we use the riterion for approximating reasonable orders.Se tion 4.3 adapts this te hnology to obedient reasonable orders. Se tion 4.4 des ribes our226\nOrdered Landmarks in Planninghandling of y les in the LGG, and Se tion 4.5 des ribes a preliminary form of \\lookahead\"orders that we have also implemented and used.4.1 Finding Landmarks and Approximating Greedy Ne essary OrdersWe nd (a subset of the) landmarks in a planning task, and approximate the greedy ne es-sary orders between them, both in one pro ess. The pro ess is split into two parts:1. Compute an LGG of landmark andidates together with approximatedgreedy ne essary orders between them. This is done with a ba k haining pro- ess. The goals form the rst landmark andidates. Then, for any andidate L0, the\\earliest\" a tions that an be used to a hieve L0 are onsidered. Here, \\early\" is agreedy approximation of rea hability from the initial state. The a tions are analysedto see if they have shared pre ondition fa ts L { fa ts that must be true before exe ut-ing any of the a tions. These fa ts L be ome new andidates if they have not alreadybeen pro essed, and the orders L!gn L0 are introdu ed. The pro ess is iterated untilthere are no new andidates. (Due to the greedy sele tion of a tions, L/the orderL!gn L0 is not proved to be a landmark/a greedy ne essary order.)2. Remove from the LGG the andidates (and their in ident edges) that annot be proved to be landmarks. This is done by evaluating a su\u00c6 ient onditionon ea h andidate L in the LGG. The ondition ignores all a tions that add L, and asksif a relaxed version of the task is still solvable. If not, L is proved to be a landmark.(Any relaxation an be used in prin iple; we use the relaxation that ignores deletelists as in M Dermott, 1999 and Bonet & Ge ner, 2001.)The next two subse tions fo us on these two steps in turn.4.1.1 Landmark CandidatesWe give pseudo- ode for our approximation algorithm below. As said, we make the algo-rithm greedy by using an approximation of rea hability from the initial state. The approx-imation we use is a relaxed planning graph (Ho mann & Nebel, 2001), short RPG. Let usexplain this data stru ture rst. An RPG is built just like a planning graph (Blum & Furst,1997), ex ept that the delete lists of all a tions are ignored; as a result, there are no mutexrelations in the graph. The RPG thus is a sequen e P0; A0; P1; A1; : : : ; Pm 1; Am 1; Pm ofproposition sets (layers) Pi and a tion sets (layers) Ai. P0 ontains the fa ts that are true inthe initial state, A0 ontains those a tions whose pre onditions are rea hed ( ontained) inP0, P1 ontains P0 plus the add e e ts of the a tions in A0, and so on. We have Pi Pi+1and Ai Ai+1 for all i. If the relaxed task (without delete lists) is unsolvable, then theRPG rea hes a xpoint before rea hing the goal fa ts, thereby proving unsolvability. Ifthe relaxed task is solvable, then eventually a layer Pm ontaining the goal fa ts will berea hed.66. Note that the RPG thus de ides solvability of the relaxed planning task. Indeed, building an RPG is avariation of the algorithm given by Bylander (1994) to prove that plan existen e is polynomial in theabsen e of delete lists. 227\nHoffmann, Porteous & SebastiaAn RPG en odes an over-approximation of rea hability in the planning task. We de nethe level of a fa t/a tion to be the index of the rst proposition/a tion layer that ontains thefa t/a tion. Then, if the level of a fa t/a tion is l, one must apply at least l parallel a tionsteps from the initial state before the fa t be omes true/the a tion be omes appli able. (Thefa t/a tion level orresponds to the \\h1\" heuristi de ned by Haslum & Ge ner, 2000.) Weuse this over-approximation of rea hability to insert some greediness into our approximationof \\greedy\" ne essary orders (more below). The approximation pro ess pro eeds as shownin Figure 4.initialise the LGG to (G; ;), and set C := Gwhile C 6= ; doset C 0 := ;for all L0 2 C; level(L0) 6= 0 dolet A be the set of all a tions a su h that L0 2 add(a), and level(a) = level(L0) 1 ( )for all fa ts L su h that 8a 2 A : L 2 pre(a) doif L is not yet a node in the LGG, set C 0 := C 0 [ fLgif L is not yet a node in the LGG, then insert that nodeif L!gn L0 is not yet an edge in the LGG, then insert that edgeendforendforset C := C 0endwhile Figure 4: Landmark andidate generation.The set of landmark andidates is initialised to omprise the goal fa ts. Ea h iterationof the while-loop pro esses all \\open\" andidates L0 { those L0 in C. Candidates L0 withlevel 0, i.e., initial fa ts, are not used to produ e greedy ne essary orders and new landmark andidates, be ause after all su h L0 are already true. For the other open andidates L0,the set A omprises all those a tions at the level below L0 that an be used to a hieveL0. Note that these are the earliest possible a hievers of L0 in the RPG, or else the levelof L0 would be lower. We take as the new landmark andidates those fa ts L that everya tion in A requires as a pre ondition, and update the LGG and the set of open andidatesa ordingly. Independently of the ( ) step, the algorithm terminates be ause there are only nitely many fa ts. Be ause we use the RPG level test in step ( ), the levels of the new andidates L are stri tly lower than the level of L0, and the while-loop terminates after atmost m iterations where m is the index of the topmost proposition layer in the RPG.If we skipped the test for the RPG level at the point in the algorithm marked ( ), thenthe new andidates L would be proved landmarks, and the generated orders would be provedto be ne essary and thus also greedy ne essary. Obviously, if all a tions that an a hievea landmark L0 require L to be true, then L is a landmark that must be true immediatelyprior to a hieving L0. Restri ting the hoi e of L0 a hievers with the RPG level test, thefound landmarks and orders may be unsound. Consider the following example, where wewant to move from ity A to ity D on the road map shown in Figure 5, using a standardmove operator. 228\nOrdered Landmarks in Planning A B C D\nEFigure 5: An example road map.The above algorithm will ome up with the following LGG: fat(A), at(E), at(D)g; fat(A)!gn at(E), at(E) !gn at(D)g { the RPG is only built until the goals are rea hed the rsttime, whi h happens in this example before move(C D) omes in. However, the a tionsequen e hmove(A B), move(B C), move(C D)i a hieves at(D) without making at(E) true.Therefore, at(E) is not really a landmark, and at(E) !gn at(D) is not really a greedyne essary order.By restri ting our hoi e of L0 a hievers with the RPG level test at step ( ) in Figure 4,as said we intend to insert greediness into our approximation of greedy ne essary orders.The generated orders L !gn L0 are only guaranteed to be sound if, in the RPG, the setof earliest a hievers of L0 ontains all a tions that an be used to make L0 true for the rst time from the initial state. Of ourse, it is hard to exa tly ompute that latter set ofa tions, and also it is highly non-trivial { if possible at all { to nd general onditions onwhen the earliest a hievers in the RPG ontain all these a tions. In the road map exampleabove, the a tions that an a hieve at(D) for the rst time are move(C D) and move(E D),but the only earliest a hiever in the RPG is move(E D). This leads to the unsound at(E)!gn at(D) order. In the following example taken from the well-known Logisti s domain,the earliest a hievers of L0 do ontain all a tions that an make L0 true for the rst time.Say L0 = at(P A) requires pa kage P to be at the airport A of its origin ity, and P is not atthis airport initially. The a tions that an a hieve L0 are to unload P from the lo al tru kT, or to unload it from any airplane. The only earliest a hiever in the RPG is the unloadfrom T, and indeed that's the only a tion that an a hieve L0 for the rst time { in order toget the pa kage into an airplane, the pa kage has to arrive at the airport in the rst pla e.Our approximation pro ess orre tly generates the new landmark andidate in(P T) as wellas the greedy ne essary order in(P T) !gn at(P A). Note that in(P T) 6!n at(P A).We show below in Se tion 4.1.2 how we re-establish the soundness of the landmark an-didates, removing andidates (and their asso iated orders) that are not provably landmarks.We did not nd a way to provably re-establish the soundness of the generated greedy ne es-sary orders, and unsound orders may stay in the LGG, potentially also ausing the inferen eof unsound reasonable/obedient reasonable orders (see the se tions below). We did observesu h unsoundness in a few domains during our experiments (individual dis ussions are inSe tion 6). We remark the following.1. While unsound approximated L !gn L0 orders are not valid with respe t to De ni-tion 3, they still make some sense intuitively. They are generated be ause L is in thepre onditions of all a tions that are the rst ones in the RPG to a hieve L0. Thismeans that going to L0 via L is probably a good option, in terms of distan e from theinitial state.2. Unless L is a landmark for some other reason (than for the unsound order L!gn L0),landmark veri ation will remove L, and in parti ular the order L !gn L0, from the229\nHoffmann, Porteous & SebastiaLGG (see the dis ussion of the Figure 5 example below in the se tion about landmarkveri ation).3. As said before, our sear h ontrol does not enfor e the orders in the LGG, it onlysuggests them to the planner. So even if there is no plan that obeys an order in theLGG, this does not mean that our sear h ontrol will make the planner fail.4. If we were to extra t only provably ne essary orders, by not using the RPG level test,we would miss the information that lies in those !gn orders that are not !n orders.For these reasons, in parti ular for the last one, we on entrated on the potentially unsoundRPG-based approximation in our experiments. We also ran some omparative tests to the\\safe\" strategy without the RPG level test, in domains where the RPG produ ed unsoundorders. See the details in Se tion 6.One ase where an !gn order, that is not an !n order, ontains potentially usefulinformation, is the Logisti s example given above. Another ase is the aforementioned order lear(D) !gn lear(C) in our running Blo ksworld example from Figure 1. To on lude thissubse tion, let us have a look at what our approximation algorithm from Figure 4 does inthat example. The RPG for the example is summarised in Figure 6.P0 A0 P1 A1 P2 A2 P3on-table(A) pi k-up(A) holding(A) sta k(B A) on(B A) sta k(C A) on(C A)on-table(B) pi k-up(B) holding(B) sta k(B D) on(B D) sta k(C B) on(C B)on-table(C) unsta k(D C) holding(D) sta k(B C) on(B C) sta k(C D) on(C D)on(D C) lear(C) put-down(B) . . . . . . . . . lear(A) . . . lear(B) pi k-up(C) holding(C) lear(D) . . . . . .arm-empty()Figure 6: Summarised RPG for the illustrative Blo ksworld example from Figure 1.As we explained above, the extra tion pro ess starts by onsidering the goals on(C A)and on(B D) as landmark andidates. The RPG level of on(C A) is 3, the level of on(B D) is2. There is only one a tion with level 2 that a hieves on(C A): sta k(C A). So, holding(C)(level 2) and lear(A) (level 0) are new andidates. The new LGG is: (fon(C A),on(BD),holding(C), lear(A)g; fholding(C) !gn on(C A), lear(A) !gn on(C A)g). Pro essingon(B D), we nd that its only earliest a hiever is sta k(B D), and we generate the new andidates holding(B) (level 1) and lear(D) (level 0) with the respe tive edges. In the nextiteration, holding(C) (level 2) produ es the new andidates lear(C) (level 1), on-table(C)(level 0), and arm-empty() (level 0) by the a hiever pi k-up(C); and holding(B) (level 1)produ es the new andidates on-table(B) (level 0) and lear(B) (level 0) by the a hieverpi k-up(B). In the third and nal iteration of the algorithm, lear(C) (level 1) produ esthe new andidate on(D C) (level 0) by the a hiever unsta k(D C). The pro ess ends upwith the LGG as shown in Figure 7 (the edges in the depi ted graph are all dire ted frombottom to top). Fa t sets of whi h our LGG suggests that they have to be true togetherat some point { be ause they are either top level goals, or !gn ordered before the same230\nOrdered Landmarks in Planningfa t { are grouped together in boxes. As said before, this information is important for theapproximation of reasonable orders des ribed below. on(c,a)\nclear(a)\non\u2212table(c)clear(c)\nholding(c)\nclear(d)holding(b)\non(b,d)\narm_empty on(d,c)on\u2212table(b) clear(b)Figure 7: LGG for the illustrative Blo ksworld task, ontaining the found landmarks and!gn orders.4.1.2 Landmark Verifi ationAs said before, we verify landmark andidates by evaluating a su\u00c6 ient ondition on them,and throwing away those andidates where the ondition fails. The ondition we use is thefollowing.Proposition 1 Given a planning task (A; I;G), and a fa t L. De ne a modi ed a tion setAL as follows.AL := f(pre(a); add(a); ;) j (pre(a); add(a); del(a)) 2 A;L 62 add(a)gIf (AL; I; G) is unsolvable, then L is a landmark in (A; I;G).Note that the inverse dire tion of the proposition does not hold { that is, if L is alandmark in (A; I;G) then (AL; I; G) is not ne essarily unsolvable { be ause ignoring thedelete lists simpli es the a hievement of the goals. As mentioned earlier, de iding aboutsolvability of planning tasks with empty delete lists an be done in polynomial time bybuilding the RPG. The task is unsolvable i the RPG an't rea h the goals. So our landmarkveri ation pro ess looks at all landmark andidates in turn. Candidates that are top levelgoals or initial fa ts are trivially landmarks, so they need not be veri ed. For ea h of theother andidates L, the RPG orresponding to (AL; I; G) is built, and if that RPG rea hesthe goals, then L and its in ident edges are removed from the LGG.Re onsider the road map example depi ted in Figure 5. The LGG built will be fat(A),at(E), at(D)g; fat(A) !gn at(E), at(E) !gn at(D)g. But at(E) is not really a landmarkbe ause the a tion sequen e hmove(A,B), move(B,C), move(C,D)i a hieves at(D). When231\nHoffmann, Porteous & Sebastiaverifying at(E), we dete t this. In the RPG, when ignoring all a tions that a hieve at(E),move(A,B), move(B,C), and move(C,D) stay in and so the goal remains rea hable. Thusat(E) and its edges (in parti ular, the invalid edge at(E) !gn at(D)) are removed, yieldingthe nal (trivial) LGT with node set fat(A), at(D)g and empty edge set. Note that, if at(E)was a landmark for some other reason than rea hing D (like, if one had to pi k up someobje t at E), then at(E) would not be removed by landmark veri ation and the invalidorder at(E) !gn at(D) would stay in.In the Blo ksworld example from Figure 1, landmark veri ation does not remove any andidates, and the LGG remains un hanged as depi ted in Figure 7.4.2 Approximating Reasonable OrdersOur pro ess to approximate reasonable orders starts from the LGG as omputed by themethods des ribed above, and enri hes the LGG with new edges orresponding to theapproximated reasonable orders. The pro ess has two main aspe ts:1. We approximate the aftermath relation based on the LGG. This is doneby evaluating a su\u00c6 ient ondition that overs ertain ases when greedy ne essaryorders imply the aftermath relation.2. We ombine the aftermath relation with interferen e information to ap-proximate reasonable orders. For ea h pair of landmarks L0 and L su h that L0 isin the aftermath of L a ording to the previous approximations, a su\u00c6 ient onditionis evaluated. The ondition overs ertain ases when L interferes with L0, i.e., whena hieving L (from a state in S(L0;:L)) involves deleting L0. If the ondition holds, areasonable order L!r L0 is introdu ed.The next two subse tions fo us on these two aspe ts in turn. In our implementation, the omputation of the aftermath relation is interleaved with its ombination with interfer-en e information. Pseudo- ode for the overall algorithm is given in the se ond subse tion,Figure 8.4.2.1 Aftermath RelationThe su\u00c6 ient ondition that we use to approximate the aftermath relation is the following.Lemma 1 Given a planning task (A; I;G), and two landmarks L and L0. If either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 for1 i n, and L0 !gn Ln+1,then L0 is in the aftermath of L.Proof Sket h: If L0 2 G then L0 is trivially in the aftermath of L. Otherwise, under thegiven ir umstan es, L0 and Ln must be true together at some point in any a tion sequen ea hieving the goal from a state in S(L0;:L), namely dire tly prior to a hievement of Ln+1.232\nOrdered Landmarks in PlanningAs L has a path of !gn orders to Ln, it has to be true prior to (or simultaneously with, ifn = 1) L0. 2Note that this lemma just aptures the property we mentioned before, when we an tellfrom the LGG that several fa ts must be true together at some point. In the se ond aseof the lemma, these fa ts are L0 and Ln. L0 and Ln are both ordered !gn before Ln+1and so must be true together before a hieving that fa t. The rst ase of the lemma anbe understood this way as impli itly assuming Ln as some other top-level goal that L hasa path of !gn orders to. (In our implementation, L must have su h a path in the LGGor it would not have been generated as a landmark andidate.) If L0 and Ln must be truetogether, and we additionally know that L must be true sometime before Ln, then we knowthat L0 is in the aftermath of L.7The most straightforward idea to make use of Lemma 1 would be to simply enumerateall pairs of nodes (landmarks) in the LGG, and evaluate the lemma, olle ting the pairsL and L0 of landmarks where the lemma ondition holds. While this would probably notbe prohibitively runtime- ostly, one an do better by having a loser look at the lemma ondition. Consider ea h node L0 in the LGG in turn. If L0 is a top level goal, then L0is in the aftermath of all other nodes L. If L0 is not a top level goal, then onsider allnodes Ln 6= L0 su h that L0 and Ln both have a !gn order before some other node Ln+1.The nodes L in the LGG that have an (possibly empty) outgoing !gn path to su h an Lnare exa tly those for whi h L0 is in the aftermath of L a ording to Lemma 1. As said,pseudo- ode for our overall approximation of reasonable orders is given below in Figure 8.Note that the inputs to Lemma 1 are!gn orders, while in pra ti e we evaluate the lemmaon the edges in the LGG as generated by the pro esses des ribed above in Se tion 4.1. Aswe dis ussed above, the edges in the LGG may be unsound, i.e. they do not provably orrespond to !gn orders. In e e t, neither an we guarantee that our approximation tothe aftermath relation is sound.4.2.2 Reasonable OrdersWe approximate reasonable orders by onsidering all pairs L and L0 where L0 is in theaftermath of L a ording to the above approximation. We test if L interferes with L0a ording to the de nition dire tly below. If the test su eeds, we introdu e the orderL!r L0.De nition 6 Given a planning task (A; I;G), and two fa ts L and L0. L interferes withL0 if one of the following onditions holds:1. L and L0 are in onsistent;2. there is a fa t x 2 Ta2A;L2add(a) add(a), x 6= L, su h that x is in onsistent with L0;3. L0 2 Ta2A;L2add(a) del(a);4. or there is a landmark x in onsistent with L0 su h that x!gn L.7. In theory, one ould also allow L0 = Ln 6= L in Lemma 1. In this ase, L has a path of !gn orders toL0, whi h trivially implies that L0 is in the aftermath of L. But in fa t, it is then impossible to a hieveL0 before L so an order L!r L0 would be meaningless.233\nHoffmann, Porteous & SebastiaAs said before, our (standard) de nition of in onsisten y is that fa ts x and y arein onsistent in a planning task if there is no rea hable state in the task that ontains bothx and y.8 Note that the onditions 1 to 4 of De nition 6, while they may look loselyrelated at rst sight (and presumably are related in many pra ti al examples), indeed overdi erent ases of when a hieving L involves deleting L0. More formally expressed, for ea h ondition i there are ases where i holds but no ondition j 6= i holds. For example, onsider ondition 2. In the following example, there is a reasonable order L!r L0, and L interfereswith L0 due to ondition 2 only. There are the six fa ts L, L0, x, P1, P2, and P 0. Initiallyonly P 0 is true, and the goal is to have L and L0. The a tions are:name (pre; add; del)opL0 = (fP 0g; fL0g; fxg)opP1 = (fP 0g; fP1g; fL0; P 0g)opP2 = (fP 0g; fP2g; fL0; P 0g)opL1 = (fP1g; fL; x; P 0g; fP1g)opL2 = (fP2g; fL; x; P 0g; fP2g)In this example, the only a tion sequen es that are possible are of the form (opL0 kopP1 \u00c6 opL1 k opP2 \u00c6 opL2) , in BNF-style notation. In e e t, L !r L0 be ause if wea hieve L0 rst, we have to apply one of opP1 and opP2, whi h both delete L0. Condition2 holds: x is in onsistent with L0 and added by both opL1 and opL2. As for ondition 1,L and L0 are not in onsistent be ause one an apply opL0 after, e.g., opL1. Condition 3is obviously not ful lled, and ondition 4 is not ful lled be ause there are two options toa hieve L so no fa t has a !gn order before L.Interferen e together with the aftermath relation implies reasonable orders betweenlandmarks.Theorem 6 Given a planning task (A; I;G), and two landmarks L and L0. If L interfereswith L0, and either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 for1 i n, and L0 !gn Ln+1,then there is a reasonable order between L and L0, L!r L0.Proof Sket h: By Lemma 1, L0 is in the aftermath of L. Let us look at the four possiblereasons for interferen e. If L is in onsistent with L0 then obviously a hieving L involvesdeleting L0. If all a tions that a hieve L add a fa t that is in onsistent with L0, the sameargument applies. The ase where all a tions that a hieve L delete L0 is obvious. As for8. De iding about in onsisten y is obviously PSPACE-hard. Just imagine a task where we insert one of thefa ts into the initial state, and the other fa t su h that it an only be made true on e the original goalhas been a hieved. We approximate in onsisten y with a sound but in omplete te hnique developed byMaria Fox and Derek Long (1998), see below. 234\nOrdered Landmarks in Planningthe last ase, say we are in a state s 2 S(L0;:L). Then x is not in s (be ause L0 is). Due tox!gn L, x must be a hieved dire tly prior to L, and thus L0 will be deleted. 2Overall, our method for approximating reasonable orders based on the LGG works asspe i ed in Figure 8. With what was said above, the algorithm should be self-explanatoryex ept for the interferen e tests. When doing these tests, we need information about fa tin onsisten ies, and, for ondition 4 of De nition 6, about !gn orders. Our approximationto the latter pie es of information are, as before, the (approximate) !gn edges in the LGG.Our approximation to the former pie e of information is a te hnique from the literature(Fox & Long, 1998), the TIM API. This provides a fun tion TIMin onsistent(x,y) that, forfa ts x and y, returns TRUE only if x and y are in onsistent. The fun tion is in omplete,i.e., it an return FALSE even if x and y are in onsistent.for all nodes L0 in the LGG doif L0 2 G thenfor all nodes L 6= L0 in the LGG doif L interferes with L0, then insert the edge L!r L0 into the LGGendforelsefor all nodes Ln 6= L0 in the LGGs.t. there are a node Ln+1 and edges L0 !gn Ln+1, Ln !gn Ln+1 in the LGG dofor all nodes L in the LGGs.t. L has an (possibly empty) outgoing path of !gn edges to Ln doif L interferes with L0, then insert the edge L!r L0 into the LGGendforendforendifendfor Figure 8: Approximating reasonable orders based on the LGG.Note that the algorithm from Figure 8 might generate orders L!r L0 in ases where Lalready has a path of !gn edges to L0. As noted earlier, in this ase L0 an not be a hievedbefore L so the order L!r L0 is meaningless. One ould avoid su h meaningless orders byan additional he k to see, for every generated pair L and L0, if L has an outgoing!gn pathto L0. We do this in our implementation only for the easy-to- he k spe ial ases where thelength of the !gn path from L to L0 is 1 or 2. Note that the super uous !r orders don'thurt anyway; in fa t they don't hange our sear h pro ess (Se tion 5.1) at all. The onlypurpose of our spe ial ase test is to avoid some unne essary evaluations of De nition 6.Be ause the inputs to our approximation algorithm are !gn edges in the LGG, andas dis ussed before these edges are not provably sound, the resulting !r orders are notprovably sound (whi h they otherwise would be by Theorem 6).Let us nish o our running Blo ksworld example, by showing how the order lear(C)!r on(B D), our motivating example from the introdu tion, is found. Have a look at theLGG in Figure 7. Say the pro ess depi ted in Figure 8 onsiders, in its outermost for-loop,the LGG node L0 = on(B D). L0 is a top level goal so all other nodes L in the LGG, inparti ular L = lear(C), are onsidered in the inner for-loop. Now, lear(C) interferes with235\nHoffmann, Porteous & Sebastiaon(B D) be ause of ondition 4 in De nition 6: lear(D) is in onsistent with on(B D), andhas an edge lear(D) !gn lear(C) in the LGG. Consequently the order lear(C) !r on(BD) is inferred and introdu ed into the LGG. Note that, to make this inferen e, we need theedge lear(D) !gn lear(C) whi h is not a !n order.4.3 Approximating Obedient Reasonable OrdersThe pro ess that approximates obedient reasonable orders starts from the LGG already ontaining the approximated reasonable orders, and inserts new orders that are reasonablegiven one ommits to the !r orders already present in the LGG. The te hnology is verysimilar to the te hnology we use to approximate reasonable orders. Largely, we do the samething as before and just treat the!r edges as if they were additional!gn edges. Formally,the di eren e lies in the su\u00c6 ient riterion for the, now obedient, aftermath relation.Lemma 2 Given a planning task (A; I;G), a set O of reasonable ordering onstraints, andtwo landmarks L and L0. If either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 orLi !r Li+1 2 O for 1 i n, and L0 !gn Ln+1,then L0 is in the obedient aftermath of L.Proof Sket h: By a simple modi ation of the proof to Lemma 1. The rst ase is obvious,in the se ond ase L0 must be true one step before Ln+1 be omes true, and L must be truesometime before that. 2Note that the proved property does not hold if there is only a reasonable order betweenL0 and Ln+1, L0 !r Ln+1 instead of L0 !gn Ln+1, even if we have ommitted to obeyL0 !r Ln+1. It is essential that L0 must be true dire tly before Ln+1.9The parts of our te hnology that do not depend on the aftermath relation remain un- hanged. Interferen e is de ned exa tly as before. Together with the obedient aftermathrelation, it implies obedient reasonable orders between landmarks.Theorem 7 Given a planning task (A; I;G), a set O of reasonable ordering onstraints,and two landmarks L and L0. If L interferes with L0, and either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 orLi !r Li+1 2 O for 1 i n, and L0 !gn Ln+1,then there is an obedient reasonable order between L and L0, L!Or L0.9. If obeying an oder L1 !r L2 is de ned to in lude the ase where L1 and L2 are a hieved simultaneously,the lemma does not hold. The fa ts L1; : : : ; Ln+1 ould then all be a hieved with a single a tion, giventhe orders between them are all (only) taken from the set O. One an \\repair\" the lemma by requiringthat, for at least one of the i where Li 6!gn Li+1 but Li !r Li+1 2 O, there is no a tion that has bothLi and Li+1 in its add list. 236\nOrdered Landmarks in PlanningProof Sket h: By Lemma 2 and the same arguments as in the proof to Theorem 6. 2Our overall method for approximating obedient reasonable orders based on the LGG isdepi ted in Figure 9. Compare the algorithm to the one depi ted in Figure 8. Similarlyto before, the new pro ess enumerates all fa t pairs L and L0 where L0 is in the obedientaftermath of L a ording to the !gn and !r edges in the LGG, and Lemma 2. Thosepairs L and L0 where L0 is a top level goal are skipped { these pairs have all already been onsidered by the pro ess from Figure 8. When L0 is not a top level goal, the more generousappli ability ondition of Lemma 2, see the lines marked ( ) in Figure 9, may allow us to nd more fa ts L that L0 is in the, now obedient, aftermath of. The generated pairs aretested for interferen e and, if the test su eeds, an order L !Or L0 is introdu ed. The testfor interferen e is exa tly the same as before. The TIM API (Fox & Long, 1998) delivers thein onsisten y approximation, and ondition 4 of De nition 6 uses the approximated !gnorders in the LGG. Note here that the x!gn L order in ondition 4 of De nition 6 an notbe repla ed by an x !r L order even if we have ommitted to obey the latter order. Thevalidity of the ondition depends on the fa t that, with x !gn L, x must be true dire tlybefore L.for all nodes L0 in the LGG, L0 62 G dofor all nodes Ln 6= L0 in the LGGs.t. there are a node Ln+1, an edge L0 !gn Ln+1, andeither Ln !gn Ln+1 or Ln !r Ln+1 in the LGG do ( )for all nodes L in the LGGs.t. L has an (possibly empty) outgoing path of !gn or !r edges to Ln do ( )if L interferes with L0, then insert the edge L!Or L0 into the LGGendforendforendfor Figure 9: Approximating obedient reasonable orders based on the LGG.Note that the approximation algorithm for L!Or L0 orders only makes use of the !gnand !r edges in the LGG as omputed previously, not of the newly generated L !Or L0edges. One ould, in prin iple, allow also these latter edges in the onditions marked ( )in Figure 9, and install a xpoint loop around the whole algorithm. This way one wouldgenerate obedient reasonable orders, and obedient obedient reasonable orders, and so onuntil a xpoint o urs. We did not try this, but our intuition is that it typi ally won't helpto improve performan e. It seems questionable if, in examples not espe ially onstru tedto provoke this, useful orders will ome up in xpoint iterations later than the rst one.Taking the LGG as input, our approximated !Or orders, like the approximated !rorders, inherit the potential unsoundness of the approximated !gn orders.4.4 Cy le HandlingAs mentioned earlier, the nal LGG in luding all !gn, !r, and !Or orders may ontain y les. An example for fa ts L and L0 where both L !r L0 and L0 !r L hold was given237\nHoffmann, Porteous & Sebastiain Se tion 3.2. Also, y les L !gn L0 and L0 !r L might arise if a landmark must bea hieved more than on e in a solution plan (in the Blo ksworld domain, y les of this kindsometimes arise for the fa t arm-empty()). In our urrent implementation, any y les inthe LGG are removed sin e the sear h pro ess an't handle them. The y les are removedby removing edges { ordering onstraints { that parti ipate in y les. Obviously, one wouldlike to remove as few edges as possible. But guring out the smallest edge set su\u00c6 ientto break all y les is NP-hard (FEEDBACK ARC SET, see Garey & Johnson, 1979). Weexperimented with a variety of methods that greedily remove edges until there are no more y les. In these experiments, done over a range of ben hmark domains, we generally foundthat there was little to be gained by the di erent methods. We settled on the followingsimple removal s heme: rst remove all !Or edges in ident on y les, then, if any y lesremain, remove all !r edges in ident on y les. After this, the y les are all removedbe ause !gn edges alone an not form y les due to the way they are omputed.We prioritise to keep (greedy) ne essary over reasonable over obedient reasonable or-dering onstraints in the LGG. This makes intuitive sense due to the stronger theoreti aljusti ation of the di erent types of orders. Of ourse, there are other methods one an tryto treat y les. One possible approa h (suggested to us by one of the anonymous reviewers)would be to ollapse all the y les, i.e., to ompute the a y li dire ted graph of the strongly onne ted omponents of the LGG, and say that L ! L0 i there is a path from L to L0in that graph of omponents. One ould then use this \\meta\"-order as input to the sear h ontrol. Another idea would be to try to analyse the y les for useful sear h information,or at least for hints as to what edges may be best to remove. Exploring su h alternativeapproa hes is an open resear h topi .4.5 Lookahead OrdersWe have implemented another form of orders, to over ome ertain short omings of thete hnology des ribed so far. As said, our approximation of (greedy) ne essary orders isbased on interse ting a tion pre onditions. We get an order L !gn L0 if all a hievers (inthe earliest RPG level) of L0 share the pre ondition L. Now, there are situations where theimmediate a hievers of L0 do not have a shared pre ondition, but the a hievers that are (atleast) two steps away have one. We observed this in the Logisti s domain. Let us use thisdomain for illustration. Say we are fa ing a Logisti s task where there are two planes and apa kage to be moved from la-post-o\u00c6 e to boston-post-o\u00c6 e. While extra ting landmarks,we will nd that L0 = at(pa k1 boston-airport) is a landmark (a landmark andidate, atthis point in the algorithm). L0 is a hieved by the two a tions a1 = unload(pa k1 plane1boston-airport) and a2 = unload(pa k1 plane2 boston-airport). The pre onditions of a1 areat(plane1 boston-airport) and in(pa k1 plane1), those of a2 are at(plane2 boston-airport)and in(pa k1 plane2). The interse tion of these pre onditions is empty, so the landmarkextra tion pro ess des ribed above would stop right here. But no matter if we use a1 or a2to a hieve L0, the pa kage has to be in a plane beforehand; and all the earliest a tions in theRPG that a hieve su h an in relation share the pre ondition L = at(pa k1 la-airport). (Thea tions are load(pa k1 plane1 la-airport) and load(pa k1 plane2 la-airport)). Thus at(pa k1la-airport) is a landmark, whi h an't be found by our above approximation te hniques.238\nOrdered Landmarks in PlanningWe designed a preliminary te hnique implementing a limited lookahead, during thelandmarks extra tion pro ess, in order to over ome the di\u00c6 ulty exempli ed above. Thegeneral situation where we an introdu e a lookahead ne essary order L !ln L0 betweenfa ts L and L0 is this. Say L0 is a landmark, and an be a hieved by the a tions a1; : : : ; an.Say fL1; : : : ; Lmg is a set of fa ts su h that the pre ondition of ea h a tion ai, 1 i n, ontains at least one fa t Lj, 1 j m. Then the disjun tion L1 _ : : :_Lm is a landmarkin the sense that one of these fa ts must be true at some point on every solution plan.Now, if all a tions that a hieve any of the fa ts Lj share some pre ondition fa t L, then itfollows that L is a landmark { a landmark that has to be true (at least) two steps beforeL0 be omes true. When interse ting pre onditions not over all a tions but only over theearliest a hievers in the RPG, we an apply this general prin iple to the Logisti s exampleabove: L0 is at(pa k1 boston-airport), L1 and L2 are in(pa k1 plane1) and in(pa k1 plane2),and L is at(pa k1 la-airport).The idea is to test, given a landmark andidate L0, if there is an intermediate fa t setfL1; : : : ; Lmg as above su h that the interse tion of the pre onditions of all a hievers offa ts in the set is non-empty. Candidates for su h intermediate fa t sets an be generatedby sele ting one pre ondition from ea h a hiever of L0. The obvious di\u00c6 ulty is that thenumber of su h andidates is exponential in the number of di erent a hievers of L0. Weimplemented an in omplete solution by restri ting the test to andidate sets where all fa tsare based on the same predi ate { as the in predi ate in in(pa k1 plane1) and in(pa k1plane2) above. If there is su h a fa t set fL1; : : : ; Lmg, then we he k if there is a sharedpre ondition L of the a tions a hieving the fa ts Lj at the respe tive earliest points in theRPG. If the test su eeds, L be omes a new landmark andidate. If, during landmarkveri ation, both L and L0 turn out to really be landmarks, then we introdu e the orderL!ln L0 into the LGT.When approximating reasonable or obedient reasonable orders, the !ln orders are onlyused at those points where the aftermath relation is he ked. More pre isely, the se ond ase of Lemma 1 an be updated to say:If there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 orLi !ln Li+1 for 1 i n, and L0 !gn Ln+1, then L0 is in the aftermath of L.The se ond ase of Lemma 2 an be updated to say:If there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 orLi !r Li+1 2 O or Li !ln Li+1 for 1 i n, and L0 !gn Ln+1, then L0 is in the obedientaftermath of L.The approximation algorithms from Figures 8 and 9 are updated a ordingly, by allowing!ln edges in the respe tive onditions (in Figure 9, marked with ( )). Note that Lemmas 1and 2 do not remain valid when allowing L0 !gn Ln+1 to be a !ln order, be ause it isimportant that L0 must be true dire tly before Ln+1.We found our implementation of this preliminary te hnique to work well in the Logisti sdomain, see also Se tion 6.8. From a more general point of view, the te hnique opens uptwo interesting lines of future resear h, regarding disjun tive landmarks and k-lookaheads.We say more on these topi s in the dis ussion, Se tion 7.239\nHoffmann, Porteous & Sebastia5. How to Use Ordered LandmarksHaving settled on algorithms for omputing the LGG, there is still the question of how touse this information to speed up planning. Porteous and Sebastia (2000) proposed a methodthat for es the planner to obey all onstraints in the LGG. The method is appli able (only)in forward state spa e sear h. By a leaf in a dire ted graph we mean, in what follows,a node that has no in oming edges. In Porteous and Sebastia's approa h, if applying ana tion a hieves a landmark L that is not a leaf of the urrent LGG, then they disallowthat a tion. If an a tion a hieves a landmark L that is a leaf, then they remove L (and allordering relations it parti ipates in) from the LGG. In short, they do not allow a hieving alandmark unless all of its prede essors have been a hieved already. Note that the approa hassumes, like the approa h we will des ribe below, that there are no y les in the LGG {otherwise, there are nodes in the LGG that will never be ome leaves.Apart from its restri tion to a forward sear h, the performan e improvements obtainableby Porteous and Sebastia's approa h appear rather limited. In many domains there are noimprovements at all.10 Here, we explore an alternative idea that uses landmarks in a more onstru tive manner, by ways of a de omposition method. Rather than telling the plannerwhat is probably not a good thing to do next, the landmarks now tell the planner whatprobably is a good thing to do next. This yields performan e improvements in domainsthat were previously una e ted, and is not restri ted to any parti ular kind of planningapproa h.Se tion 5.1 introdu es our de omposition method. Se tion 5.2 makes some remarksabout theoreti al properties of the method, and Se tion 5.3 dis usses a few variations of themethod that we have tried (and found to not work as well in pra ti e).5.1 Disjun tive Sear h ControlWe use the LGG to de ompose the planning task into a series of smaller sub-tasks. Thede omposition takes pla e in the form of a sear h ontrol algorithm that is wrapped aroundsome { any { planning algorithm, alled base planner in what follows. Similar to before(Porteous & Sebastia, 2000), the ore te hnique is to onsider the leaf nodes in an in re-mentally updated LGG. First, read in the task and ompute the LGG. Then, in any sear hiteration, onsider the leaf nodes of the urrent LGG and hand these leaves over to thebase planner as a goal. When the base planner has returned a plan, update the LGG byremoving the a hieved leaf nodes, and iterate. The main di\u00c6 ulty with this idea is that theleaf nodes of the LGG an often not be a hieved as a onjun tion. Our solution is to posethe leaf nodes as a disjun tive goal instead. See the algorithm in Figure 10.The depi ted algorithm keeps tra k of the urrent state s, the urrent plan pre x P , andthe urrent disjun tive goal Disj, whi h is always made up out of the urrent leaf nodes ofthe LGG.11 The initial fa ts are immediately removed be ause they are true anyway. When10. By this kind of sear h ontrol one does not get any bene t out of the ne essary orders, as these will beobeyed by the forward sear h anyway. But in many domains (like Logisti s-type problems) there are noor hardly no ordering onstraints other than the ne essary ones.11. Note that, in leaf removal, the plan fragment P 0 is not pro essed sequentially, i.e. it is not he ked whatnew LGG nodes be ome leaves as one applies the a tions. While one ould of ourse do the latter, thisdoes not seem to be relevant in pra ti e. We never observed plan fragments that a hieved LGG nodesthat were not yet leaves. 240\nOrdered Landmarks in Plannings := I, P := h iremove from LGG all initial fa ts and their edgesrepeatDisj := leaf nodes of LGG all base planner with a tions A, initial state s and goal ondition WDisjif base planner did not nd a solution P 0 then fail endifP := P \u00c6 P 0, s := result of exe uting P 0 in sremove from LGG all L 2 Disj with L 2 add(o) for some o in P 0until LGG is empty all base planner with a tions A, initial state s and goal VGif base planner did not nd a solution P 0 then fail endifP := P \u00c6 P 0, output PFigure 10: Disjun tive sear h ontrol algorithm for a planning task (A; I;G), repeatedly alling an arbitrary planner on a small sub-task.the LGG is empty { all landmarks have been pro essed { then the algorithm stops, and allsthe underlying base planner from the urrent state with the original (top level) goals. Thesear h ontrol fails if at some point the base planner did not nd a solution. A disjun tivegoal an be simulated by using an arti ial new fa t G as the goal, and adding one a tionfor ea h disjun t L, where the a tion's pre ondition is fLg and the add list is fGg (thiswas rst des ribed by Gazen & Knoblo k, 1997). So our sear h ontrol an be used aroundany base planner apable of dealing with STRIPS input. Note that, as all top-level goalsare landmarks, an empty LGG means that all goals have been a hieved at least on e. Sounless they have been destroyed again, the initial state for the last all of the base plannerwill already ontain the goals (some more on this below).Note that the sear h ontrol is ompletely unaware of destru tive intera tions betweendi erent parts of the overall planning task. It may be, for example, that a landmark L1 isneeded for (ne essarily ordered before) another landmark L01, that L2 is needed for L02, thatL1 and L2 are both leaves, and that L1 and L2 are in onsistent. With our sear h ontrol,the planner will make one of L1 or L2 true. Say L1 is made true. Then the planner is freeto hoose if, in the next iteration, it wants to make L01 true, or L2 instead. If the hoi eis to make L2 true, then L1 { whose purpose was to enable a hievement of L01 { will beinvalidated and the e ort spent in a hieving it will (may) be wasted. On a higher level ofabstra tion, this means that, with the purely disjun tive sear h ontrol, the planner may betempted to frequently \\swit h\" between di erent parts of the task/of the LGG, whi h maynot be bene ial for the overall performan e. We observed su h a phenomenon in the Griddomain, see Se tion 6.7; it is un lear to us how mu h e e t on performan e su h phenomenahave in our other experimental domains/if they have any e e t at all. Probably there is su han e e t in Blo ksworld, Depots, Free ell, and Rovers, but not in the rest of the domainswe tried, i.e. Logisti s, Tyreworld, and various domains where not many landmarks/orderswere found or where the orders did not have mu h e e t on performan e anyway. It isan open resear h topi to better investigate the empiri al e e ts of on i ting parts of241\nHoffmann, Porteous & Sebastiathe task/the LGG, and parti ularly to ome up with general de nitions and algorithmsto apture and utilise the nature of su h phenomena. While this may look simple in thesituation outlined above, the situations o uring in reality or even in simple ben hmarkdomains su h as the Blo ksworld are probably mu h more omplex and di\u00c6 ult to reasonabout.5.2 Theoreti al PropertiesThe sear h ontrol is obviously orre tness preserving { eventually, the planner is run onthe original goal. Likewise obviously, the method is not optimality preserving in general.Though we did not explore this topi in depth, we do not believe that there are interestingspe ial ases in whi h optimality is preserved. In the ben hmarks we tried, the runtimeimprovements were indeed often bought at the pri e of somewhat longer plans, see Se tion 6.With respe t to ompleteness, matters are a little more interesting. Even if the baseplanner is omplete { guarantees to nd a plan if the task is solvable { the sear h ontrol an fail be ause one of the en ountered sub-tasks is unsolvable. Now, one an of ourse tryto res ue ompleteness (as mu h as possible) by an appropriate rea tion if the sear h ontrolloop, as depi ted in Figure 10, fails. One an, for example, run the base planner on theoriginal initial state and goal in this ase. While this would trivially give us ompleteness,it would be more desirable to make some use of the information obtained in the sear hpro ess so far. An idea, whi h we refer to as the safety net in what follows, is to all thebase planner in ase of failure, with the original goal, but with the start state s of the failediteration as the initial state. The unsolvability of the failed sub-task might be due to thegoal ondition as given by the disjun tion of the urrent leaf landmarks. Of ourse, theunsolvability of the failed sub-task an also be due to the state s. If the latter an't happenin the task at hand, then the safety net solution is ompleteness-preserving. A little moreformally, we say that a state is a dead end if the (original) goal an not be rea hed from it.We all a task dead-end free if there are no dead ends in its state spa e. Obviously, if one alls a omplete base planner with the original goal in ase of failure, then in a dead-endfree task that is guaranteed to nd a plan.While the safety net solution preserves ompleteness in the absen e of dead ends, itspra ti al value is un lear, even in dead-end free tasks. The only way the sear h ontrol an possibly speed up the planning pro ess is if we get lose enough to a goal state beforethe base planner has to be alled with the original goal. If the whole LGG is pro essedbefore that happens, i.e., if the sear h ontrol as depi ted in Figure 10 does not fail, thenit is reasonable to assume that the nal state s will be lose to the goal { all goal fa tshave been a hieved at least on e on the path to s. If, however, the ontrol fails before theLGG is empty, then it is ompletely open how mu h progress we made. If we fail early onin the sear h pro ess, then it is likely that the last start state s is not far away from theoriginal initial state. The e ort invested into reating the LGG, and into solving the rstfew sub-tasks, was then in vain.The relevant remaining theoreti al question thus is, are there interesting spe ial aseswhere we an be sure to rea h the end of the ontrol loop without failing? The answer is,yes there are. We need a notation. A fa t L is alled re overable if, when s is a rea hable242\nOrdered Landmarks in Planningstate with L 2 s, and s0 with L 62 s0 is rea hable from s, then a state s00 is rea hable froms0 with L 2 s00.Theorem 8 Given a solvable planning task (A; I;G), and an LGG where ea h fa t L in thetree is a landmark su h that L 62 I. If the task is dead-end free, and for all fa ts L0 in thetree it holds that either L0 is re overable, or all orders L! L0 in the tree are ne essary, thenrunning any omplete planner within the sear h ontrol de ned by Figure 10 will pro ess theentire LGG without failing.Proof: Assume that the sear h ontrol fails at some point before pro essing the entireLGG. We prove that then, in ontradi tion to the assumption, the urrent start state s is adead end. Be ause the base planner is omplete, we know that the disjun tion of all urrentleaf nodes is unsolvable starting from s. Say L0 is su h a leaf. Say P 0 is a plan solving theoriginal goal from s. P 0 does not add L0, as it would otherwise solve the disjun tion. The on atenation of the urrent pre x P with P 0 is a solution plan, and L0 is a landmark not ontained in the initial state, so P adds L0. If L0 is re overable, we an a hieve it froms and have a ontradi tion to the unsolvability of the disjun tion. Therefore, L0 is notre overable, implying by prerequisite that all orders L ! L0 in the tree are ne essary. SayP = ha1; : : : ; ani, and L0 is rst added by ai. At this point, L0 was not in the disjun tion, asit would otherwise have been removed from the tree. So there is some L with L! L0 thatis rst added by some a tion between ai and an. But then, P does not obey the ordering onstraint L! L0, whi h is a ontradi tion to L!n L0. It follows that s is a dead end. 2Verifying landmarks with Proposition 1 ensures that all fa ts in the LGG really arelandmarks. The initial fa ts are removed before sear h begins. Many of the urrent planningben hmarks, for example Blo ksworld, Logisti s, Gripper, Hanoi, Depots, and Driverlog,are invertible in the sense that every a tion a has a ounterpart a that undoes a's e e ts.Su h tasks are dead-end free, and all fa ts in su h tasks are re overable. An example of adead-end free domain with only ne essary orders is Simple-Tsp. Examples of dead-end freedomains where non-ne essary orders apply only to re overable fa ts are Mi oni -STRIPSand Grid. All those domains (or rather, all tasks in those domains) ful ll the requirementsfor Theorem 8. Note that, in ases where the theorem applies, the sear h ontrol as depi tedin Figure 10 is guaranteed to nd a plan if the base planner is omplete.In our experiments, we ran the sear h ontrol without a safety net. Our reasons were thefollowing. First, if the sear h ontrol failed, it typi ally did so very early. Se ond, we rarelyobserved a ase where failure was due to unsolvability of the leaf landmarks disjun tion.Most of the time, the start state of the failed iteration was a dead end. Finally, in ourexperiments it happened very seldom that the sear h ontrol failed. The Free ell domainwas the only domain where we observed that the sear h ontrol failed in ases where thebase planner without the ontrol managed to nd a plan. So the issue of what to do in aseof failure didn't seem to be very relevant.5.3 Sear h Control VariationsThe disjun tive sear h ontrol in Figure 10 alls the base planner with the original goalon e the whole LGG has been pro essed. Our (only) hope is that the initial state s for that243\nHoffmann, Porteous & Sebastialast all of the base planner is mu h loser to a goal state than the original initial state was.Re all that all top level goals are a hieved at least on e on the path to s. They thus willbe true in s unless they have been deleted again in some later ontrol loop iteration. Anobvious idea to avoid the latter phenomenon is, on e a top level goal G has been a hieved,to for e the base planner to keep G true throughout the rest of the ontrol pro ess. This anbe done by keeping a onjun tive goal Conj in addition to the disjun tive goal Disj. Conjthen always ontains the top level goals that have been a hieved so far { that have been leaflandmarks and were removed { and the goal for the base planner is always Conj ^WDisj.The problem with this idea is that one or a set of already a hieved original goals mightbe in onsistent with the leaf landmarks in a later iteration. For ing the a hieved goals tobe true together with the disjun tion yields in this ase an unsolvable sub-task, makingthe ontrol algorithm fail. We observed this in various ben hmarks. We tried a numberof ideas based on dete ting in onsisten ies (with the TIM API) between Conj and Disj,and removing fa ts from Conj that parti ipate in an in onsisten y. However, this did nothelp mu h to avoid unsolvable sub-tasks, due to the in ompleteness of TIM's in onsisten yapproximation, and due to the fa t that only pairwise in onsisten ies are dete ted. Weobserved ases where the smallest unsolvable sub- onjun tion of landmarks had size 3.Apart from all this, even in ases where for ing truth of a hieved top level goals did notmake the sear h ontrol fail, the te hnique did not yield better runtime or solution lengthbehaviour in our experiments. This is probably due to the fa t that, unless su h goals arein onsistent with the landmarks ahead, they are kept true anyway.We remark that, if G is a top level goal that is in onsistent with a landmark L, then ourapproximation te hniques introdu e the order L !r G by Theorem 6, if the in onsisten yis dete ted. If all these edges L !r G are present in the LGG, G an not be ome a leaflandmark before any L it is in onsistent with, so on e a hieved as a leaf landmark G annot be in onsistent with any leaf landmark L in a later iteration. The problems are thatnon-binary in onsisten ies an o ur, that TIM's approximation of binary in onsisten iesis in omplete, and that edges L!r G might be removed during our (uninformed) removalof y les.There is another aspe t of the sear h ontrol de ned by Figure 10 that, at rst sight,appears to be an obvious short oming: while the leaf landmarks an often not be a hievedtogether in one pie e, this does not justify the assumption that all single leaves must bea hieved separately. But posing the leaves as a disjun tive goal suggests the latter to thebase planner. In some domains (like Logisti s), this in reases plan length onsiderably (seealso Se tion 6.8). A more pre ise way of dealing with in onsisten ies among leaf landmarksis to hand the leaves over to the base planner in the form of a DNF goal, where themembers of the disjun tion are a partition of the leaf landmarks into maximal onsistentsubsets. Similar to what we have seen above, an important di\u00c6 ulty with this idea is thatin onsisten y an not be determined exa tly (without solving the planning task in the rstpla e). One an approximate onsisten y by pairwise onsisten y a ording to the TIMAPI, and obtain a partition into maximal onsistent subsets in a greedy manner.12 Butof ourse undete ted or non-binary in onsisten ies an make the sear h ontrol fail. We12. Finding a partition (DNF) with minimal number of subsets (disjun ts) is NP-hard: this solves PARTI-TION INTO CLIQUES (Garey & Johnson, 1979) when the graph edges are the pairs of fa ts that are onsistent. 244\nOrdered Landmarks in Planningobserved this in various ben hmarks. Moreover, in our experiments, independently of thebase planner used, the e e t of the modi ed te hnique on performan e was not onvin ingeven in those ases were it preserved solvability. There are a few domains (e.g. Logisti s)were, ompared to the fully disjun tive ontrol, the te hnique improved plan length at the ost of longer runtimes. In other domains (e.g. Blo ksworld-arm) the modi ation madeno signi ant di eren e, in some domains (e.g. Free ell) the modi ation produ ed learlyworse runtime and plan length behaviour.We remark that, when using both modi ations outlined above, our sear h ontrolbe omes a generalisation of the \\Goal Agenda Manager\" proposed by Koehler and Ho mann(Koehler, 1998; Koehler & Ho mann, 2000). In the goal agenda, the top level goals arepartitioned into a series of subsets that respe ts their (approximated) reasonable ordering onstraints. The goal handed over to the base planner in any ontrol loop iteration i isthen the union ( onjun tion) of all partition subsets up to point i. Restri ted to top levelgoals, the modi ed disjun tive sear h ontrol be omes exa tly this. This is be ause theleaf goals in iteration i orrespond exa tly to the respe tive partition subset. Consider theworkings of the sear h ontrol under the above modi ations. Top level goals are onsistent(in solvable tasks) so will be posed as a single onjun tive goal when onsidering maximal onsistent subsets. The previously a hieved leaf landmarks will be exa tly the goals inprevious partition subsets, so when keeping them in the onjun tive goal Conj we end upwith exa tly what the Goal Agenda Manager does. The generalisation lies in that, in thepresen e of non-top level goal landmarks, the goal agenda pro ess is enri hed with morefa ts and ordering relations, and a ombination of onjun tive and disjun tive (sub-)goals.However, as outlined above, su h a ontrol pro ess su ers from di\u00c6 ulties arising fromin onsisten ies between goal fa ts and other landmarks, and the simpler fully disjun tivesear h ontrol framework from Figure 10 typi ally works better. So we have on entratedon this simple framework in our more extensive experiments.6. ResultsWe in lude subse tions des ribing how we set up our suite of testing examples (Se tion 6.1),des ribing the planners tested in the experiment (Se tion 6.2), and des ribing our resultsin the eight individual domains used in the tests (Se tions 6.3 to 6.10). We nally in- lude a subse tion summarizing our observations regarding unsound orders in the LGG(Se tion 6.11).6.1 Test SuiteTo ome up with a test suite, we ran preliminary tests in 19 di erent STRIPS ben hmarkdomains, in luding all (STRIPS) examples used in the AIPS-1998, AIPS-2000, and AIPS-2002 ompetitions. We sele ted 8 out of the 19 domains for more extensive tests. Thesele ted domains are: Blo ksworld-arm, Blo ksworld-no-arm, Depots, Free ell, Grid, Logis-ti s, Rovers, and Tyreworld. The reasons why we dis arded the other domains were thefollowing. The Movie instan es were trivial to solve for any planner on guration we tried.In Driverlog, Gripper, Mprime, Mystery, Satellite, and Zenotravel, no (or only very few)non-trivial landmarks/ordering relations were dete ted so the de omposition imposed byour disjun tive sear h ontrol essentially ame down to serialising the goal set (i.e., a hiev-245\nHoffmann, Porteous & Sebastiaing all goals one after the other).13 In Hanoi there was a non-trivial LGT but whether to useit or not made no signi ant di eren e to any planner's runtime performan e (intuitively,be ause the ordering information is overpowered by the exponentiality in the length of theHanoi solutions). In the STRIPS version of S hedule, where operators have a lot of param-eters, none of our planners ould ope with the pre-pro essing (namely, the grounding ofthe operator parameters with all available obje ts). In Ferry and Mi oni -STRIPS, nally,the performan e observations we made were basi ally the same as those that we made inLogisti s. As all these three domains are also semanti ally very similar, we fo ussed on onlya single representative of this lass of domains.For ea h of the 8 domains we sele ted for experimentation, we used a problem generatorto produ e a large suite of test examples. The examples s ale in the respe tive domain'ssize parameters (e.g., number of blo ks in the Blo ksworld variants), and of ea h size thereare several (in most domains, 20) random instan es.6.2 Tested PlannersWe hose to run our disjun tive sear h ontrol around the three planners FFv1.0, FFv2.3,and LPG. The reason for this hoi e was that we wanted to show the e e ts of our te h-niques on the state-of-the-art in sub-optimal planning. (As our te hniques do not preserveoptimality there is not mu h point in using them with optimal planners, whi h are gener-ally outperformed by suboptimal planners anyway.) FFv1.0 (Ho mann, 2000) is an earlySTRIPS version of FF that does not use any goal ordering te hniques. FFv2.3 (Ho mann& Nebel, 2001) is the version of FF that parti ipated in the AIPS-2000 and AIPS-2002planning ompetitions. The planner enhan es FFv1.0 with the Goal Agenda Manager te h-nique (as well as the ability to handle ADL). We onsider FFv2.3 a parti ularly interestingplanner to try our landmarks te hniques on as, by doing this, we give an example of howour sear h ontrol a e ts the performan e of a planner that already uses goal ordering te h-niques. The LPG version we used (Gerevini et al., 2003) is the one that parti ipated in theAIPS-2002 planning ompetition.The implementation of our landmarks te hniques is based on FFv1.0, and the disjun tivesear h ontrol is integrated in that planner's ode. For the other planners, FFv2.3 and LPG,we implemented a simple interfa e. For ea h iteration of the disjun tive sear h ontrol, therespe tive sub-task is spe i ed via two les in the STRIPS subset of PDDL (M Dermottet al., 1998). The implementations of FFv2.3 and LPG are modi ed to output a results le ontaining the spent running time, and a sequential solution plan (or a ag saying that noplan has been found). For FFv1.0, the runtime we measure is simply total exe ution time.For FFv2.3, the runtime we measure also is total exe ution time, ex ept the time takenin the interfa e, i.e. the time taken to reate the PDDL les { after all, this time is justan unne essary overhead due to our preliminary implementation. For LPG, matters area bit more ompli ated. LPG omputes in onsistent fa ts and a tions as a pre-pro ess toplanning (in onsistent a tions either interfere, or have in onsistent pre onditions). Repeat-13. In the transportation domains Driverlog, Gripper, Mprime,Mystery, and Zenotravel, due to the presen eof several vehi les (gripper hands in the ase of Gripper) there are no shared pre onditions of the a tionsthat an a hieve the goal position of an obje t. The only ordering relations we get refer to the initialposition and the goal position of obje ts. We elaborate this further in the dis ussion of Logisti s inSe tion 6.8. 246\nOrdered Landmarks in Planningedly alling LPG inside our landmarks ontrol results in repeatedly doing the in onsisten ypre-pro ess, produ ing a large runtime overhead. In a dire t implementation of landmarks ontrol within LPG, one would of ourse do the pre-pro ess only on e. Our idea for anexperimental implementation thus is to simply ignore the runtime overhead in urred bythe super uous pre-pro esses. However, in general the in onsisten ies omputed by theindividual pre-pro esses an be di erent, depending on the start state LPG is run on. Sothere is no guarantee that our experimental implementation will produ e the same resultsas a dire t implementation, unless it is the ase that LPG's pre-pro ess provably omputesthe same information throughout our landmarks ontrol loop. But we found that the latteris indeed the ase in 7 of our 8 domains. The reason for this is that state rea hability is(largely, in some ases) invertible in these domains; started in states that are rea hable fromea h other, LPG's pre-pro ess nds the same in onsisten ies. The detailed arguments arein Appendix C. The only domain where LPG's pre-pro ess might nd di erent informationfor the di erent start states is Free ell. There we ount the total runtime of our experimen-tal implementation, in luding all in onsisten y pre-pro esses. In the other 7 domains, we ount the runtime for only a single (the rst) one of these pre-pro esses.14 It is a pie e ofopen work to integrate landmarks ontrol more tightly with LPG, see also the outlook inSe tion 7. With the preliminary implementation we evaluate here, the LPG results shouldbe interpreted with are; still they show that one an obtain runtime improvements for LPGwhen using landmarks to stru ture the sear h.We also ran our disjun tive landmarks ontrol around IPP (Koehler, Nebel, Ho mann,& Dimopoulos, 1997), and a standard naive breadth- rst sear h. In both ases, we obtaineddramati runtime improvements in all the eight sele ted domains.In what follows, there are individual subse tions for the sele ted domains, in alphabeti alorder. In ea h subse tion, we give a brief des ription of the domain, provide a table withsolution per entage values as well as averaged runtimes and plan lengths (number of a tionsin the plan), and dis uss the results. We also dis uss what kind of landmarks and ordersour approximation methods nd in the respe tive domain, and how this information relatesto the orders that really are present in the domain. We deem this information important tounderstand the pra ti al impa t of our approximation te hniques. The dis ussions are notne essary to understand the rest of the paper, and the uninterested reader may skip overthem at the end of ea h subse tion.The presentation of the data in the form of tables was hosen be ause this is by far themost ompa t way to present the data gathered in su h a large experiment. To foster theunderstandability of the solution per entage and runtime results, we also provide runtimedistribution graphs (number of solved instan es plotted against runtime). These are movedinto Appendix B sin e they take a lot of spa e, and serve here only to larify a few spe i points.The experiments were run on an Athlon 1800 MHz ma hine with 1Gb RAM, runningLinux (Mandrake 9.0). Unsu essful runs were ut o after a time limit of 300 se onds.14. There is a further subtlety regarding another pre-pro ess that LPG performs before starting the sear h;see the dis ussion in Appendix C. 247\nHoffmann, Porteous & Sebastiasize 20 22 24 26 28 30%solvedFFv1.0 25 30 20 0 5 0FFv1.0+L 85 70 65 60 70 70FFv2.3 80 75 65 50 55 50FFv2.3+L 85 95 80 60 60 65LPG 100 100 90 50 35 30LPG+L 100 100 95 85 80 65timeFFv1.0 7.33 9.28 16.00 - 46.99 -FFv1.0+L 0.29 0.16 1.05 0.34 0.26 1.01FFv2.3 16.78 6.04 2.66 10.56 0.51 2.05FFv2.3+L 2.17 6.41 3.54 21.88 6.38 7.08LPG 38.60 61.58 97.44 145.20 206.48 211.43LPG+L 9.67 24.03 63.45 31.61 99.51 112.79lengthFFv1.0 77.20 80.50 74.67 - 92.00 -FFv1.0+L 60.00 68.50 85.33 80.83 74.00 99.57FFv2.3 64.29 64.86 75.45 78.50 88.25 88.75FFv2.3+L 276.43 319.00 346.55 406.50 485.25 439.75LPG 250.70 308.90 378.33 383.00 419.71 391.33LPG+L 219.90 255.10 313.56 317.00 338.29 456.67Table 1: Experimental Results in Blo ksworld-arm. Times are in se onds. Time/planlength in ea h table entry is averaged over the respe tive instan es solved by bothof ea h pair \\X\" and \\X+L\" of planners. Size parameter is the number of blo ks,20 random instan es per size.6.3 Blo ksworld-armBlo ksworld-arm is the variant of the Blo ksworld that we used in our illustrative example.A robot arm an be used to arrange blo ks on a table. There are four operators to sta ka blo k onto another blo k, to unsta k a blo k from another blo k, to put a blo k (thatthe arm is holding) down onto the table, and to pi k a blo k up from the table. Using thesoftware provided by Slaney and Thiebaux (2001), we generated examples with 20, 22, 24,26, 28, and 30 blo ks, 20 instan es per size. Our data is displayed in Table 1.From left to right, the entries in Table 1 provide the data for the instan es of in reasingsize. For planner \\X\", \\X+L\" denotes the same planner, but with our landmarks sear h ontrol. The top part of the table provides the per entage of instan es solved by ea hplanner in ea h lass of instan es. The middle part provides averaged runtimes, the bottompart provides averaged plan lengths. For ea h planner \\X\", the averages here are omputedover (only) those instan es that were solved by both \\X\" and \\X+L\". In unsolved ases,there is no plan length to in lude into the average omputation; we have tried to use theruntime uto value in the runtime average omputation but this generally obs ured ourresults more than it helped to understand them. We average over the instan es solved byindividual planners \\X\" and \\X + L\", rather than over instan es solved by all planners,be ause this way we obtain a learer pi ture of what the impa t of our te hniques on ea hindividual planner is. Note that, this way, omparisons between di erent planners have tobe made very arefully. In what follows, we will indeed on entrate on the e e ts of ourlandmarks te hniques and not say mu h on inter-planner omparisons.248\nOrdered Landmarks in PlanningOne might miss information about varian e in Table 1, and in all the other tables below.In our experiments, in all ases where planner \\X\" had a signi antly better/worse averageruntime/plan length value than planner \\X+L\", a ross a set of random instan es solvedby both planners, in fa t \\X\" was signi antly better/worse than \\X+L\" a ross all theindividual instan es that were solved by both planners. So the signi ant runtime/planlength results { those that we will draw on lusions from { are stable a ross the randomelements in our instan e generation pro esses.Looking at the solution per entage values, it is obvious that the landmarks help toimprove all of the tested planners. The improvement is drasti for FFv1.0 and LPG, andless drasti but still signi ant for FFv2.3. The runtimes get learly improved for FFv1.0and LPG; FFv2.3+L is a little slower than FFv2.3 in those ases solved by both planners.FFv1.0 does not solve a single instan e with 26 or 30 blo ks, and in the respe tive tableentries for FFv1.0+L, we averaged over all instan es solved by FFv1.0+L. For FFv1.0 andLPG, the impa t on plan length is a bit in on lusive; most of the time the plans be omesomewhat shorter when using landmarks. A di erent pi ture emerges for FFv2.3 where theplans be ome a lot longer.15There are all kinds of landmarks and ordering relations in Blo ksworld-arm, as we havealready seen during the dis ussions regarding our illustrative example. No unsound ordersare extra ted by our approximation methods. There is always just one single a tion that an a hieve a (non-initial) fa t for the rst time. It is easy to see that this a tion will also bethe rst one to a hieve the respe tive fa t in the RPG. Therefore, no unsound !gn orderswill be extra ted, .f. the dis ussion in Se tion 4.1.1. It follows that no unsound (obedient)reasonable orders will be extra ted either ( .f. Se tions 4.2 and 4.3), and that all landmark andidates really are landmarks. In ompleteness of our approximations an arise, e.g., inthe approximation of destru tive intera tions between fa ts L and L0, De nition 6. Say Lis a fa t on(A B), and L0 is a fa t on(C D) where in the state at hand D is lo ated aboveA in the same sta k of blo ks, but B is lo ated somewhere in/on a di erent sta k. Thena hieving L involves deleting L0 but none of the onditions given in De nition 6 res.6.4 Blo ksworld-no-armBlo ksworld-no-arm is a variant of the Blo ksworld where the blo ks are moved arounddire tly, i.e. without expli it referen e to a robot arm. There are three operators to movea blo k from another blo k onto a third blo k, to move a blo k from the table onto anotherblo k, and to move a blo k from another blo k onto the table. As in Blo ksworld-arm, weused Slaney and Thiebaux's software to generate random examples with 20, 22, 24, 26, 28,and 30 blo ks, 20 instan es per size. See the data in Table 2.Solution per entage gets dramati ally improved for FFv2.3; for LPG there is some im-provement, too, for FFv1.0 the results are a bit in on lusive but of the largest examples,FFv1.0+L solves a lot more than FFv1.0. The average runtimes in solved examples be ome learly better for FFv2.3. For FFv1.0 and LPG, they generally be ome somewhat bettertoo, but not signi antly. LPG and LPG+L solved di erent instan es in the largest exam-15. We suspe ted that the latter phenomenon is due to an intera tion between our landmarks ontrol and theGoal Agenda that FFv2.3 uses. Investigating this, we did however not nd su h an intera tion. Presum-ably, the odd plan length behaviour of FFv2.3+L is just an e e t of minor implementational di eren esbetween FFv1.0 and FFv2.3, su h as the ordering of fa ts and a tions in the internal representation.249\nHoffmann, Porteous & Sebastiasize 20 22 24 26 28 30%solvedFFv1.0 95 80 55 85 50 15FFv1.0+L 80 70 65 70 35 50FFv2.3 90 65 55 60 45 45FFv2.3+L 100 95 100 100 95 100LPG 100 100 100 100 80 5LPG+L 100 100 100 100 90 20timeFFv1.0 7.57 25.18 29.14 28.74 88.33 106.75FFv1.0+L 8.93 19.89 27.36 36.34 69.84 84.32FFv2.3 16.67 27.87 46.13 74.21 44.50 65.59FFv2.3+L 0.86 1.78 1.78 2.34 3.22 12.11LPG 21.71 43.19 80.45 135.58 197.32 -LPG+L 16.82 40.79 67.46 118.89 207.69 -lengthFFv1.0 28.00 32.69 36.00 37.17 42.60 46.67FFv1.0+L 65.20 81.38 80.12 90.92 110.00 112.67FFv2.3 47.56 49.67 58.82 69.33 64.89 76.44FFv2.3+L 46.67 54.67 62.18 68.17 78.44 78.78LPG 74.00 86.85 97.45 105.05 114.00 -LPG+L 97.60 130.00 143.95 154.80 188.50 -Table 2: Experimental Results in Blo ksworld-no-arm. Time/plan length in ea h tableentry is averaged over the respe tive instan es solved by both of ea h pair \\X\" and\\X+L\" of planners. Size parameter is the number of blo ks, 20 random instan esper size.ple group, whi h is why the respe tive table entries are empty. As for average plan length,this be omes slightly worse for FFv2.3 and signi antly worse for FFv1.0 and LPG.There are all kinds of landmarks and ordering relations between them in Blo ksworld-no-arm. For example, in order to move some blo k x onto a blo k y, x and y must always be lear (so these fa t are shared pre onditions). There are destru tive intera tions betweenthe di erent sub-goals (e.g. a blo k an not be lear and have some other blo k on top ofit), whi h lead to reasonable orders. Regarding soundness of our approximation methodsin this domain, it is easy to see (from the a tions that an be used to a hieve a fa t for the rst time) that the approximations will always be sound. In ompleteness an arise, e.g.,due to the same phenomenon as explained for Blo ksworld-arm above.While the ordering relations present in Blo ksworld-no-arm are similar to those inBlo ksworld-arm, in di eren e to the latter domain our observed performan e improve-ments are not as signi ant. One important reason for this is probably that, for all ofFFv1.0, FFv2.3, and LPG, Blo ksworld-no-arm is not as problemati as Blo ksworld-armanyway: in both domains our examples ontain the same numbers of blo ks, but the solutionper entages without using landmarks are usually mu h higher in Blo ksworld-no-arm.1616. Indeed, Ho mann (2002) proves that Blo ksworld-no-arm is an easier domain than Blo ksworld-arm forplanners (su h as FF and LPG) using heuristi s based on the relaxation that ignores all delete lists.250\nOrdered Landmarks in Planningsize 20 21 22 23 24 25%solvedFFv1.0 62.5 72.5 52.5 42.5 22.5 20FFv1.0+L 85 80 75 67.5 72.5 62.5FFv2.3 67.5 67.5 55 45 45 27.5FFv2.3+L 47.5 45 37.5 35 30 30LPG 100 100 100 100 100 82.5LPG+L 100 100 100 95 97.5 97.5timeFFv1.0 98.18 157.29 130.69 206.64 175.82 146.81FFv1.0+L 9.48 10.32 26.47 20.12 22.33 41.01FFv2.3 139.19 138.47 92.49 163.92 185.84 218.27FFv2.3+L 38.75 15.10 36.27 65.76 8.74 10.63LPG 32.39 47.59 63.89 78.72 87.23 111.45LPG+L 22.60 26.71 46.32 51.27 53.38 74.60lengthFFv1.0 108.86 118.00 121.00 129.64 131.00 127.43FFv1.0+L 128.48 146.17 152.47 154.27 170.44 161.14FFv2.3 118.42 118.00 118.00 132.38 132.20 130.00FFv2.3+L 133.50 141.21 150.09 159.62 154.00 159.50LPG 137.70 155.43 157.22 165.87 178.85 184.88LPG+L 154.38 156.03 176.22 194.76 197.41 200.09Table 3: Experimental Results in Depots. Time/plan length in ea h table entry is aver-aged over the respe tive instan es solved by both of ea h pair \\X\" and \\X+L\" ofplanners. Size parameter is the number of rates; all instan es have 10 lo ations,3 tru ks, 10 hoists, and 20 pallets. 40 random instan es per size.6.5 DepotsThe Depots domain is a mixture between Blo ksworld-arm and Logisti s, introdu ed byLong and Fox in the AIPS-2002 planning ompetition (Long & Fox, 2003). Sta ks of ratesat di erent lo ations must be re-arranged. There are ve operators to drive tru ks betweenpla es, to load/unload a rate onto/from a tru k using a hoist, and to drop/lift a rateonto/from a surfa e (another rate or a pallet) using a hoist. For our random instan es,we used the problem generator provided by Long and Fox. The instan es all feature 10lo ations, 3 tru ks, 10 hoists (one at ea h lo ation), and 20 pallets (at least one at ea hlo ation). The instan es s ale in terms of the number of rates. Here, we show the data forinstan es with 20 to 25 rates. The runtime of our planners on instan es of the same sizevaried more in Depots than in our other domains, and we generated 40 random instan esof ea h size instead of the usual 20. See the data in Table 3.For all the planners, with our te hnique the plans be ome somewhat longer. The solutionper entage and runtime values are harder to interpret. Solution per entage for FFv1.0 isdrasti ally improved, while for FFv2.3 it be omes signi antly worse. For both plannersthe average runtime in solved instan es be omes a lot better. To understand this, a lookat Figure 12 in Appendix B is helpful. This shows quite ni ely the \\greedy\" e e t thatthe landmarks ontrol has on the FF versions in Depots. While both FFv1.0 and FFv2.3solve a lot more examples qui kly when using the landmarks ontrol, without that ontrolthe planners tend to behave more reliably, i.e. an solve more instan es when given enoughtime. For FFv2.3 this happens before our time uto limit.251\nHoffmann, Porteous & SebastiaFor solution per entage and runtime of LPG, both the data in Table 3 and the plotsin Figure 12 are a bit in on lusive. The solution per entage data suggests that the usedinstan es are not yet at LPG's s aling limit. We generated larger instan es, with 26 to 30 rates, 3 random examples of ea h size. The solution per entage values we got for theseexamples are (LPG/LPG+L): 100/100, 66.6/100, 0/100, 0/66.6, 0/66.6. This suggests thatour landmarks te hniques pay o more for LPG as the instan es be ome harder. Theruntime and plan length behaviour in ases solved by both planners remained similar to thesmaller instan es: LPG + L was faster than LPG on average, but found somewhat longerplans.The hoists and rates in Depots roughly orrespond to the robot arm and blo ks inBlo ksworld-arm, and similarly to that domain our approximation methods nd variouslandmarks and orders regarding on relations, lear relations, and, for ea h lo ation, liftingrelations for the hoist at that lo ation. The orders L !gn L0 found by our methods, ifL0 is an on or a lear relation, are sound due to the same arguments as given above forBlo ksworld-arm. This is also true when L0 is a lifting relation regarding a rate that isinitially already o-lo ated with the respe tive hoist. If the rate is initially not o-lo atedwith the hoist, due to the presen e of several tru ks we get no !gn orders: the rate an be unloaded (and is then being lifted afterwards) from any tru k, and the unloadinga tions have no shared pre onditions. The only orders our methods nd regarding thetransportation part of the problem are L !ln L0 orders, .f. Se tion 4.5, where L0 is thelifting relation for a rate at its goal lo ation, and L is either the rate's at relation orits lifting relation at its initial lo ation. These orders are sound, L has to be true earlierthan L0. The orders are found be ause the unloading a tions for all tru ks { the a tionsthat a hieve L0 { all feature an in relation for the rate, and these in relations form anintermediate fa t set for whi h all earliest a hievers (loading a tions, namely) in the RPGshare the pre onditions L.17 Like we observed for Blo ksworld-arm and Blo ksworld-no-arm, in ompleteness of our approximations may, e.g., arise from the fa t that De nition 6does not over all destru tive intera tions that an arise from the way rates are arrangedon sta ks.6.6 Free ellThe Free ell domain is a STRIPS en oding of the well-known solitaire ard game that omes free with Mi rosoft Windows. The domain was introdu ed by Fahiem Ba hus in theAIPS-2000 planning ompetition, and was also in luded by Long and Fox into the AIPS-2002 planning ompetition. A brief des ription of the game is as follows. A set of ards isinitially randomly arranged a ross a number of sta ks, and all ards have to be put awayon goal sta ks in a ertain order. There are rules that guide in whi h ways ards an bemoved, and there are a number of \\free ells\" whi h an be used for intermediate storageof ards. The domain omprises 10 operators that implement the possible ard moves. Assaid above, in Free ell there is no guarantee that our experimental implementation behaves17. If there was only a single tru k, then we would get L!gn L0 orders where L0 is a lifting relation and Lis an at relation of the tru k. In e e t we would get L !gn L0 orders where both L and L0 are an atrelation of the tru k, L orresponding to the tru k's initial lo ation. These latter orders an be unsound,but do not a e t the rest of the approximation pro esses, or the sear h pro ess. The same phenomenon an o ur in all transportation domains, and is dis ussed in the se tion about Logisti s below.252\nOrdered Landmarks in Planningsize 11 12 13 14 15 16%solvedFFv1.0 95 85 80 50 35 15FFv1.0+L 95 65 60 50 10 5FFv2.3 100 90 85 60 20 15FFv2.3+L 100 70 70 30 20 5LPG 0 0 0 0 0 0LPG+L 10 0 0 0 0 0timeFFv1.0 3.95 46.82 54.28 92.60 - 261.65FFv1.0+L 1.62 2.15 3.05 5.45 - 9.34FFv2.3 6.02 24.93 62.53 66.56 - 140.37FFv2.3+L 1.80 2.41 3.31 4.45 - 8.63LPG - - - - - -LPG+L 240.23 - - - - -lengthFFv1.0 68.00 88.00 103.00 107.25 - 125.00FFv1.0+L 63.00 69.50 81.50 99.25 - 119.00FFv2.3 75.50 85.00 93.00 106.50 - 123.00FFv2.3+L 60.50 67.50 82.00 98.00 - 121.00LPG - - - - - -LPG+L 72.50 - - - - -Table 4: Experimental Results in Free ell. Time/plan length in ea h table entry is aver-aged over the respe tive instan es solved by both of ea h pair \\X\" and \\X+L\"of planners. Size parameter is the number of ards per suit; all instan es have 4di erent suits, 5 free ells, and 10 possible sta ks. 20 random instan es per size.like a dire t implementation of landmarks in LPG, so below we provide the total runtimetaken. We remark that a dire t LPG+L implementation might do better { when ountingthe time for only a single in onsisten ies pre-pro ess, we solved a few more examples withinthe time limit. To generate our test suite, we used the random generator provided by Longand Fox. A ross our instan es, we have 4 di erent suits of ards, 5 free ells, and 10 possiblesta ks; we s aled the instan es by in reasing the number of ards in ea h suit, 20 randominstan es per size. Table 4 provides our data for the examples with 11 to 16 ards per suit.For a reason we don't know, LPG behaved very badly in our Free ell experiments. Ithardly solved any instan e, and adding the landmarks ontrol helped in some, but not many, ases. Averaging over these ases, we got the runtime and plan length averages shown inthe LPG+L entries. For the FF versions, the impa t of our landmarks te hnique is moreinteresting. The impa t on both versions is similar: less tasks are solved, but the runtimein the solved tasks improves onsiderably, and the plans be ome somewhat shorter.18An intuitive explanation for the runtime behavior of FF is the following. When playingFree ell, the main di\u00c6 ulty is typi ally to avoid dead end situations where, due to somewrong ard moves in the past, one an not move any ard any longer, or make any moreprogress towards a solution. FF uses a forward hill- limbing style sear h. Pretty mu h as amatter of han e, this either gets lu ky and solves the task qui kly, or it gets stu k in a deadend state. Using the landmarks sear h ontrol, FF's hill- limbing sear h be omes even moregreedy, being a lot faster in the \\good\" ases but produ ing a few more \\bad\" ases. Now,18. In the examples with 15 ards per suit, the instan es solved by FFv1.0/FFv1.0+L (FFv2.3/FFv2.3+L)were di erent whi h is why the respe tive runtime and plan length table entries are empty.253\nHoffmann, Porteous & Sebastiaif FF (without our ontrol) en ounters a dead end during hill- limbing, the planner startsfrom s rat h, \\falling ba k\" onto a omplete best- rst sear h. If our landmarks ontrol endsup in a dead end, no su h omplete fall ba k sear h method is invoked (though one ouldof ourse do that, .f. Se tion 5.2). The instan es that FF's omplete sear h method solves ause most of the di eren e in the solution per entage values as depi ted in Table 4. (Thegreediness, and failure, of the FF versions with landmarks ontrol an also very ni ely beobserved in Appendix B, Figure 12.)In a fashion reminis ent of the Blo ksworld-like problems onsidered above, ards inFree ell an be sta ked on top ea h other (under ertain additional pre onditions regardingtheir value and their olour), and must be lear in order to be moved. From these stru tures,we get landmarks regarding on-relations and lear-relations similar as before. In addition,we get landmarks regarding ard values in ases where only one order of values is possible.Most parti ularly, the goal ondition is expressed in terms of home-relations for (only) thetopmost ards in the goal sta ks. As the order in whi h ards an be put onto the goalsta k is xed, for ea h single ard in the goal sta ks we get its home-relation as a landmark,ne essarily ordered before the respe tive next higher ard. We an get unsound!gn ordersbe ause the RPG is a very rude approximation to the semanti s of a Free ell game. Forexample, the earliest a tion in the RPG that an be used to put a ard home might beto move the ard to home from its initial position, while really the ard has to be storedin a free ell rst, and be moved home from there. The unsound !gn orders may lead tounsound !r orders. If one skips the RPG level test in Figure 4, i.e. if one generates theLGG using the \\safe\" approximation of !n orders that simply interse ts the pre onditionsof all a hieving a tions, then the only landmarks and orders one gets are the home-relationsof the ards, with their asso iated (!n) orders. Using this smaller LGG to ontrol FF,one gets slightly more reliable behaviour. A few examples are solved that are not solvedwith the potentially unsound approximations. It seems that the additional orders extra tedusing the RPG are sometimes too greedy and lead into dead ends.As one would expe t, our approximation methods are also in omplete in Free ell. Forexample, De nition 6 an overlook destru tive intera tions between fa ts that arise from thesta king order of ards, just like we observed for the blo ks/ rates in the domains dis ussedpreviously.6.7 GridGrid is a domain that was introdu ed by Drew M Dermott in the AIPS-1998 planning ompetition. A robot moves on a 2-dimensional grid of lo ations. The lo ations an belo ked, in whi h ase the robot an not move onto them. Lo ked lo ations an be openedwith a key of mat hing shape. The robot an arry one key at a time, and the task is totransport a subset of the keys to their goal lo ations. For our test examples, we used therandom generator provided on the FF homepage.19 We s aled the instan es in terms ofparameters n and m. The grid has extension n n, there are 4 di erent possible shapes ofkeys and lo ks, of ea h shape there arem keys andm lo ked lo ations. Half of the keys mustbe transported to goal lo ations. Randomly distributing the initial lo ations of the keys andthe lo ked lo ations, the generator sometimes produ es unsolvable instan es. We ltered19. At http://www.informatik.uni-freiburg.de/ hoffmann/ff-domains.html.254\nOrdered Landmarks in Planningsize 8/4 8/5 9/4 9/5 10/5 10/6%solvedFFv1.0 100 85 90 65 30 0FFv1.0+L 100 100 100 95 85 90FFv2.3 80 50 75 60 25 0FFv2.3+L 90 95 80 60 50 50LPG 40 15 35 5 0 0LPG+L 80 70 70 5 0 0timeFFv1.0 40.92 126.82 75.85 132.44 136.24 -FFv1.0+L 4.39 9.56 13.97 10.43 31.88 84.32FFv2.3 35.17 64.05 74.35 91.58 113.35 -FFv2.3+L 10.53 7.09 7.71 5.59 6.84 79.82LPG 123.37 204.63 141.80 - - -LPG+L 151.03 277.42 169.52 - - -lengthFFv1.0 127.15 171.71 155.17 159.77 185.33 -FFv1.0+L 131.75 166.24 153.33 153.00 176.67 251.61FFv2.3 127.13 145.60 149.42 149.00 152.00 -FFv2.3+L 122.93 135.50 148.50 125.33 143.75 250.10LPG 141.29 131.50 134.50 - - -LPG+L 149.14 131.00 141.50 - - -Table 5: Experimental Results in Grid. Time/plan length in ea h table entry is averagedover the respe tive instan es solved by both of ea h pair \\X\" and \\X+L\" of plan-ners. Size parameters n/m are the extension of the grid (n n) and the number mof keys and lo ks of ea h shape; all instan es have 4 di erent shapes. 20 randominstan es per size.these out by hand (whether a Grid instan e is solvable or not an be on luded from theoutput of simple pre-pro essing routines su h as are implemented in FF). Table 5 providesour data for the size values (n=m) 8/4, 8/5, 9/4, 9/5, 10/5, 10/6, 20 random instan es persize.The results for the FF versions are ex ellent. Solution per entage and average runtimeare improved signi antly. This performan e gain is not obtained at the ost of longerplans, rather di erently the plans using landmarks ontrol be ome slightly (but onsistently)shorter. For LPG, the solution per entage is also improved a lot, but the time taken to solvethe examples solved by both planners is somewhat worse for LPG+L. The runtimes are,in part, lose to our time uto limit so one might suspe t that the pi ture hanges when hanging that limit. The runtime distribution graph in Figure 13, Appendix B, shows thatthis is not the ase, and that the number of examples solved by LPG onsistently growsfaster in runtime when using the landmarks ontrol. LPG's plans be ome a little longer.The landmarks and orders our approximation te hniques nd in Grid are the following.The goal is given in the form of a set of at-relations of keys. These relations an bea hieved using putdown a tions, whi h all share the fa t that the robot must be holdingthe respe tive key. Now, in the RPG the earliest point at whi h holding a key is a hievedis by pi king the key up at its initial lo ation. So we get the respe tive landmarks forthe lo ation of the robot. In some spe ial ases, e.g. when the goal lo ation of a key islo ked, we also get landmarks regarding the opening of lo ked lo ations. In these ases,unsound !gn orders may be extra ted be ause a lo ation an in general be opened from255\nHoffmann, Porteous & Sebastiaseveral lo ations, only one of whi h may be the earliest one rea hed in the RPG. Similarly,when a landmark requires the robot to be at a ertain lo ation, that an be rea hed fromseveral other lo ations, the RPG may suggest just one of these lo ations as the prede essor.Su h unsound orders suggest to the planner one spe i way of moving to/of opening therespe tive lo ation. The unsound !gn orders may lead to unsound!r orders in our otherapproximation pro esses.Controlling FF and LPG with the \\safe\" LGG, !n orders approximated without usingthe RPG, we found the following. Only few orders were generated: all one gets are thelandmarks and !n orders saying, for ea h goal lo ation of a key, that the robot has tobe at this lo ation at some point, and that one has to be holding this key at some point.Somewhat surprisingly, the runtime performan e of FF and LPG be ame a little betterwith these rather trivial LGGs, as ompared to the ri her LGGs ontaining the RPG-approximated orders. Investigating this, we got the impression that the phenomenon isdue to on i ts between the individual sub-tasks/parts of the LGG asso iated with theindividual goal keys. With the ri her LGGs, the planners tended to keep swit hing betweenthe sub-tasks, i.e. they tended to keep hanging keys and opening lo ks, not keeping holdof a key and transporting it to its goal lo ation until very late in the planning pro ess. Inthe late iterations of the sear h ontrol, for a hieving the a tual goals omparatively longplans had to be generated. This did not happen as mu h with the sparser \\safe\" LGGs,where the goals be ame leaf nodes earlier on in the ontrol loop.Regarding ompleteness of our ordering approximations in Grid, as before De nition 6is not a ne essary ondition for destru tive intera tions between fa ts. E.g. there may be areasonable order between the goal lo ations of two keys, be ause the one key must be usedin order to open the path to the other key's goal lo ation. The simple su\u00c6 ient onditionslisted in De nition 6 do not over su h omplex ases.6.8 Logisti sThe well-known Logisti s domain is the lassi al transportation ben hmark in planning.Tru ks and planes are the means to transport pa kages between lo ations. The lo ationsare grouped together in ities, i.e. a single ity an ontain several lo ations. Tru ks anonly drive within ities, planes y between di erent ities. There is one tru k in ea h ity.There are 6 operators to drive tru ks, to y planes, to load/unload pa kages onto/fromtru ks, and to load/unload pa kages onto/from planes. To generate our test suite, as inGrid we used the random generator provided on the FF homepage. Our instan es all have10 ities with 10 lo ations ea h, and 10 planes. We s aled the instan es by the number ofpa kages (whi h must all be transported). Table 6 provides our data for the examples with40, 42, 44, 46, 48, and 50 pa kages, 20 random instan es per size.The solution per entage/runtime performan e of both FF versions is improved dras-ti ally by the landmarks te hnique, at the ost of longer plans. The runtimes withoutlandmarks are lose to the runtime uto , suggesting that signi antly more examples maybe solved when in reasing the uto . Figure 13 in Appendix B shows that this is not the ase. For LPG, the solution per entage data in Table 6 is a bit in on lusive but the aver-age runtime over those instan es solved by both LPG and LPG+L is better for LPG+L.Looking at Figure 13 one sees that LPG+L is very qui k to solve a lot of the examples, but256\nOrdered Landmarks in Planningsize 40 42 44 46 48 50%solvedFFv1.0 15 20 0 0 0 0FFv1.0+L 100 100 100 100 100 100FFv2.3 20 20 10 15 0 0FFv2.3+L 100 100 100 100 100 100LPG 100 80 90 65 55 35LPG+L 100 100 80 70 60 35timeFFv1.0 238.11 267.20 - - - -FFv1.0+L 25.84 28.49 32.35 35.39 42.39 46.55FFv2.3 207.11 233.54 226.60 228.82 - -FFv2.3+L 58.03 63.10 69.79 76.21 91.20 112.21LPG 124.05 170.75 189.95 204.73 246.80 202.65LPG+L 49.15 53.71 59.63 65.06 73.65 79.29lengthFFv1.0 351.00 351.00 - - - -FFv1.0+L 429.00 439.00 466.60 484.65 504.75 523.90FFv2.3 339.25 368.00 377.00 385.67 - -FFv2.3+L 424.75 449.75 469.00 480.67 506.50 526.50LPG 447.80 468.31 483.50 500.00 517.88 547.50LPG+L 468.95 484.38 508.36 522.89 556.88 568.00Table 6: Experimental Results in Logisti s. Time/plan length in ea h table entry is aver-aged over the respe tive instan es solved by both of ea h pair \\X\" and \\X+L\" ofplanners. Size parameter is the number of pa kages; all instan es have 10 airplanes,and 10 ities with 10 lo ations ea h. 20 random instan es per size.fails to solve the others even if given a lot of time { in di eren e to LPG without landmarks ontrol, whi h onsistently manages to solve more and more examples until the time uto .It is un lear to us why LPG+L stops to s ale at some point. LPG's plans be ome longerwith the landmarks ontrol.Let us take some time to explain the landmarks and orders found in Logisti s, in om-parison to other transportation domains. The goal in transportation domains is always aset of at-relations for transportable obje ts (sometimes also for vehi les). To a hieve the atgoal for an obje t, we must unload it from some vehi le, for whi h the obje t must be inthe vehi le. If there is only a single vehi le, like in Ferry and Mi oni -STRIPS, then thein-relation for the obje t is a shared pre ondition and is thus dete ted as a landmark, with ane essary order before the at-goal. If there are several vehi les, like in Driverlog, Logisti s,Mprime, Mystery, and Zenotravel, then our lookahead te hnique, .f. Se tion 4.5, omesinto the play: there is no shared pre ondition to the unload a tions, but the in-relations forall vehi les form an intermediate fa t set for whi h all earliest a hievers (loading a tions,namely) in the RPG share the \\earliest loading-at-relation of the obje t\". Now, for all thelisted domains ex ept Logisti s the earliest possible loading-at-relation of the obje t simplyis its initial lo ation; in Logisti s, for a tions that load the obje t onto a plane, the earliestpossible loading-at-relation is the airport of the obje t's (pa kage's) origin ity. So in Lo-gisti s we get a useful !ln lookahead order between the obje t being at its origin and itsdestination airport, while in the other ases we get a non-useful lookahead order betweenthe obje t being at its initial and goal lo ation. (A similar observation an be made inGripper where there are several gripper hands.) Overall, for ea h pa kage in Logisti s we257\nHoffmann, Porteous & Sebastiaget an order sequen e of the form at(p initial-lo ation)!gn in(p origin- ity-tru k)!gn at(porigin- ity-airport)!ln at(p destination- ity-airport)!gn in(p destination- ity-tru k)!gnat(p goal-lo ation).20 With our disjun tive landmarks ontrol, the de omposition we getdivides the pa kage transportation into very small steps and thus helps to improve runtime.The point where we get longer plans is probably the!ln order between the pa kage's originand destination airports: posing the at-relations at destination airports as a disjun tivegoal, the planner transports the pa kages between ities one-by-one, without trying to usethe same plane for several pa kages. (As we indi ated in Se tion 5.3, this in rease in planlength an be avoided, at the ost of longer runtimes, by posing the leaf landmarks as a DNFgoal of maximal onsistent subsets { all at-relations at destination airports are onsistentand the DNF we get is a single onjun tion.)In all transportation domains where the maps on whi h vehi les move are fully on-ne ted, the following phenomenon an o ur. Say v is a vehi le, l is its initial lo ation, andl0 is some other lo ation. When at(v l') be omes a landmark andidate, the order at(v l)!gn at(v l') is generated. But this order is unsound if there is at least one third lo ationl00 on v's map.21 Note, however, that at(v l) is true in the initial state so the unsoundorder will be removed before sear h begins. It is also easy to see that, in the transportationdomains we onsidered (in luding Depots), the only new orders that the unsound orderat(v l) !gn at(v l') an possibly lead to in the rest of our approximation pro esses are ofthe form at(v l) !r L0, and will be removed prior to sear h. We remark that, when usingthe \\safe\" LGG without RPG approximation, the only landmarks and orders one gets inLogisti s say, for ea h pa kage goal lo ation, that the respe tive tru k has to be at thislo ation at some point, and that the pa kage has to be in this tru k at some point. Theresulting \\de omposition\" makes the base planner start by, uselessly, moving all tru ks tothe pa kage goal lo ations, and then transport all the pa kages one-by-one. In omparisonto the RPG-approximated ri her LGGs, this yields longer plans, and a little more runtimetaken by the base planner. (The runtime performan e de rease in the base planner is onlyslight be ause FF and LPG are very e\u00c6 ient in transporting single pa kages to their goal.)Our approximations are omplete in Logisti s in the sense that the only valid ordersoverlooked by them are reasonable orders between fa ts L and L0 where there is a path ofgreedy ne essary (or lookahead) orders from L to L0 anyway. Obviously, our methods nd alllandmarks in Logisti s, and all greedy ne essary (as well as lookahead) orders between them.Reasonable orders between landmarks in Logisti s arise only between landmarks L and L0both stating the position of one pa kage/tru k/airplane, where the fa t interferen e respon-sible for the order is the in onsisten y of di erent positions of the pa kage/tru k/airplane.Now, TIM dete ts all these in onsisten ies, making ondition (1) of De nition 6 a ompleteapproximation of the relevant fa t interferen es in Logisti s. In reasonable orders L!r L0between positions of one tru k/airplane, L0 is in the aftermath of L due to situations thatare un overed by the greedy ne essary (or lookahead) orders, and Lemma 1. E.g., reason-able orders between tru k positions only arise due to situations like, at(origin- ity-tru k20. Note here that there is just one tru k in ea h ity in the standard Logisti s domain. With several tru ksin a single ity, we would get a sequen e of !ln orders between the pa kage's initial lo ation, origin ityairport, destination ity airport, and goal lo ation.21. In domains with expli it road map onne tions, like the Grid domain dis ussed above, the order isunsound if l0 an be rea hed from more than one lo ation on v's road map.258\nOrdered Landmarks in Planningp-initial-lo ation) !r at(origin- ity-tru k origin- ity-airport) be ause at(origin- ity-tru kp-initial-lo ation) !n in(p origin- ity-tru k) !n at(p origin- ity-airport) and at(origin- ity-tru k origin- ity-airport) !n at(p origin- ity-airport).22 The only reasonable orderswe overlook are those that refer to di erent positions of a single pa kage on its path at(pinitial-lo ation) !gn in(p origin- ity-tru k) : : : in(p destination- ity-tru k) !gn at(p goal-lo ation). Later fa ts on su h a path are in the aftermath of the earlier fa ts, and there arereasonable orders be ause all the fa ts are in onsistent. We do not nd these orders be ausewe skip (some of the) pairs of fa ts L and L0 where there is a path of greedy ne essary (orlookahead) orders from L to L0 anyway, .f. Se tion 4.2.6.9 RoversThe Rovers domain was introdu ed by Long and Fox in the AIPS-2002 planning ompeti-tion. The problem is to nd a plan for an interplanetary rovers mission. A set of rovers an navigate along road maps of way points (i.e. the viable road map an be di erent fordi erent rovers), take soil or ro k samples, take images, and ommuni ate their observationsba k to landers. The goal is to gather together a set of observations. There are 9 operatorsto navigate the rovers, to take soil/ro k samples, to drop su h samples (they o upy storagespa e), to alibrate ameras, to take images, and to ommuni ate soil/ro k/image data tolanders. We generated our random instan es with the software provided by Long and Fox.This software takes as inputs the number of rovers, the number of waypoints, the numberof ameras, the number of \\modes\" (di erent types of images that an be taken), and thenumber of obje tives (of whi h images an be taken). We generated instan es featuring onlya single rover, be ause we found that, with several rovers, similarly to what we observedin the transportation domains Driverlog, Mprime, Mystery, and Zenotravel, no non-triviallandmarks were dete ted (see also below). We s aled the instan es via a parameter n. Ea hinstan e has one rover, 40+n waypoints, 30+n ameras, 5 modes, and n obje tives. Table 7shows our data for the n values 30, 32, 34, 36, 38, and 40, 20 random instan es per size.The solution per entage/runtime performan e of both FF versions improves dramati- ally when using our landmarks ontrol. Figure 13 in Appendix B shows that the solutionper entage values for the FF versions without landmarks ontrol would not hange mu hwith a higher runtime uto value. For LPG's solution per entage/runtime performan e,the data in Table 7 is a bit in on lusive. LPG and LPG+L seem to s ale roughly similarly,whi h is also suggested by Figure 13. A ross all the planners, the landmarks te hniquesbring about an improvement in the length of the found plans. The improvement is parti -ularly strong for LPG, and there is only a single ase (for FFv1.0, size n = 38) where theplans be ome a little longer using landmarks.Our approximation methods an nd various kinds of landmarks and orders in Rovers.The goal is a set of ommuni ated-data-relations, where the data an be ro k or soil analysisdata, or images. For a ro k or soil pie e of data, the data an be gathered only by takinga sample at a spe i waypoint w; if there is only a single rover r that is equipped forthe right kind of analysis and that an navigate to w then we get at(r w) as a landmark.22. Note that several orders of this kind may lead to y les in the LGG, when the same tru k has to hangebetween two positions in both dire tions due to the transportation needs of di erent pa kages. Weobserved su h y les, and their removal, in our experiments.259\nHoffmann, Porteous & Sebastiasize 30 32 34 36 38 40%solvedFFv1.0 50 45 30 15 25 5FFv1.0+L 100 100 100 100 100 100FFv2.3 80 60 50 45 25 30FFv2.3+L 100 100 100 100 100 100LPG 60 70 55 40 35 10LPG+L 70 25 45 45 40 10timeFFv1.0 181.21 115.81 217.87 90.57 167.01 182.38FFv1.0+L 16.18 13.09 22.40 11.25 20.21 17.62FFv2.3 174.35 123.85 180.41 177.12 155.37 242.56FFv2.3+L 19.71 17.76 28.49 27.73 28.34 36.68LPG 153.42 75.40 202.18 175.65 176.25 247.36LPG+L 108.41 90.24 183.14 174.32 177.60 218.69lengthFFv1.0 206.10 130.78 229.50 88.67 145.80 186.00FFv1.0+L 193.60 126.56 216.50 88.67 150.20 160.00FFv2.3 254.19 164.50 263.20 222.67 177.20 236.00FFv2.3+L 245.62 159.42 262.70 219.44 170.60 226.50LPG 231.75 119.75 281.25 229.50 190.00 203.50LPG+L 218.38 115.00 246.88 211.00 172.57 178.00Table 7: Experimental Results in Rovers. Time/plan length in ea h table entry is averagedover the respe tive instan es solved by both of ea h pair \\X\" and \\X+L\" of plan-ners. Size parameter is the number n where the instan es have n rovers, 25 + nwaypoints, n ameras, 5 modes, and 5 + n obje tives. 20 random instan es persize.For taking an image of an obje tive o in a spe i mode m, we need a amera thatsupports m, on a rover r that an navigate to a point w from whi h o is visible. If thereis only one appropriate ombination of , r, and w, then we get at(r w) and alibrated( )as landmarks. In that ase, if there is only one appropriate alibration target for , we alsoget the respe tive rover position as a landmark. Reasonable orders arise, e.g., if there areseveral landmarks involving the position of the same rover. E.g., if a amera on a rover rmust be alibrated at a waypoint w, and be used to take an image at a waypoint w0, thenwe get a reasonable order at(r w) !r at(r w'). Unsound orders an arise when the RPGwrongly approximates the stru ture of the road map. For example, an unsound order at(rw) !gn at(r w') is extra ted when at(r w') is a landmark andidate, in the RPG r rstrea hes w0 from w, but really there are several lo ations from whi h r an rea h w0. Theunsound !gn orders an lead to unsound !r orders. The unsound orders are not bad forthe performan e, though. When we used the \\safe\" approximation of!n orders, the LGGswe got were non-trivial, namely basi ally the same as those with the RPG approximation,ex ept for the unsound orders due to the wrong approximation of the road map. In terms ofplanner performan e, ompared to the RPG-approximated LGGs the sparser \\safe\" LGGsyielded longer runtimes (by about a fa tor 2), and also somewhat longer plans, for FFv1.0;for FFv2.3 runtime and plan length stayed roughly the same, ex ept in the largest groupof examples where the \\safe\"' LGGs yielded longer runtimes by a fa tor of 3; for LPG nosigni ant hanges were observable. 260\nOrdered Landmarks in PlanningAs for ompleteness of our approximations, we did not he k this in full detail but itseems that our te hniques do not overlook any valid orders in Rovers. (Ex ept, as above inLogisti s, reasonable orders L!r L0 where there is a path of greedy ne esssary orders fromL to L0 anyway.) The only possible destru tive intera tions between landmarks are due todi erent positions of the same rover (whi h TIM dete ts as per fa t in onsisten y), or dueto ommon delete e e ts of all a hievers (as dete ted per ondition 3 of De nition 6). Theonly possible reasons for (greedy) ne essary orders, and for a fa t being a landmark, lie inthe form of the road maps of the individual rovers, and of their apabilities regarding takingro k/soil samples and images. All these stru tures are un overed when using the RPG, i.e.,for all fa ts P , the set of a tions that an be used to a hieve P (for the rst time) is asuperset of the set of a hievers of P that appear (earliest) in the RPG.In the presen e of several rovers, where ea h rover an navigate to most of the waypointsas in the instan es generated with Long and Fox's generator, only few landmarks and ordersexist (be ause most of the time there are several alternative ways to do a ertain job), makingthe de omposition imposed by our sear h ontrol uninteresting. As said above, this is whywe ran our experiments with instan es featuring only a single rover.6.10 TyreworldThe Tyreworld domain was rst designed by Stuart Russel (Russell & Norvig, 1995). Flatwheels on a ar must be ex hanged with spare tyres, whi h involves a number of di erentworking steps. Problem size s ales with the number of at wheels. There are 13 operatorsto open/ lose the boot, to fet h/put away something from/into the boot, to loosen/tightennuts, to ja k up/ja k down hubs, to do up/undo nuts, to put on/remove wheels, and toin ate wheels. To ex hange a single wheel, one has to open the boot, fet h the spare wheeland the pump and the ja k and the wren h, in ate the spare wheel, loosen the nuts on theright hub, ja k up the hub, undo the nuts, remove the at wheel, put on the spare wheel,do up the nuts, ja k down the hub, and tighten the nuts. The tools must be put ba k intothe boot at the end. There is only a single Tyreworld instan e per size, and we used thegenerator provided on the FF homepage to generate examples with up to 30 at wheels.23The results are very easy to interpret, so we do not in lude a detailed table here. FFv1.0 ansolve tasks with up to 22 wheels within our 300 se ond time limit. FFv1.0+L omfortablys ales up to the task with 30 wheels, whi h it solves in 14.28 se onds. For FFv2.3, whi heasily s ales up to the task with 30 wheels (solved in 7.57 se onds) landmarks do not bringa runtime improvement (indeed, the runtimes be ome somewhat worse). For LPG, whi halso easily s ales up to 30 wheels (14.55 se onds), the runtime behaviour is similar. As forplan length, this be omes somewhat longer for FFv1.0 and LPG when using landmarks; forFFv2.3, plan length remains the same.Let us onsider the (sub-)goals and orders in Tyreworld instan es. Su h instan es haverather many top level goals. There are in-boot goals for all tools, and a losed-boot goal.For ea h at wheel, we have an on goal for the respe tive spare wheel and hub, an in atedgoal for the spare wheel, a tight goal for the nuts on the hub, and an in-boot goal for23. It ertainly sounds funny to en ode a problem involving a ar with 30 wheels all at at the same time.But of ourse, what we are interested in here is the underlying stru ture of the problem, whi h does notdepend on the names given to the predi ates and operators.261\nHoffmann, Porteous & Sebastiathe at wheel. Reasonable orders between these goals tell us that, rst, we should in atethe spare wheels, then mount these on their respe tive hubs, then tighten the nuts, thenput the at wheels and the tools into the boot, then lose the boot. We do get somelandmarks and orders beyond this, stating that at some point we must hold ea h sparewheel, and that at some point the hubs with at wheels on must be made free. But thisadditional information is apparently not enough to make a signi ant di eren e over theGoal Agenda te hnique (whi h works with reasonable orders on top level goals). Thisexplains the behaviour of FFv1.0 and FFv2.3: remember that these planners are basi allythe same ex ept that FFv2.3 uses the Goal Agenda. Using landmarks, FFv1.0 be omesroughly as e\u00c6 ient as FFv2.3, at the ost of longer plans. For FFv2.3, in ontrast, nothingmu h hanges by using landmarks on top of the Goal Agenda, ex ept an additional overheadfor the landmarks omputation. For LPG, it seems that this planner is very e\u00c6 ient inTyreworld even without any goal ordering te hniques. Our approximation algorithms aresound in Tyreworld, whi h is easy to see from the simple stru ture of the operators andinitial states, whi h imply that all the approximated !gn orders are, in fa t, !n orders.We did not he k ompleteness in full detail, but ould not nd a ase of a valid order thatwasn't found by our approximation methods.6.11 Unsound OrdersBrie y summarised, our observations regarding (the e e t of) unsound orders in the RPG-approximated LGG are the following: Blo ksworld-arm { no unsound orders generated. Blo ksworld-no-arm { no unsound orders generated. Depots { no unsound orders generated. Free ell { unsound orders may be generated. With the sound approximation, one getsvery few landmarks, but slightly more reliable behaviour. Grid { unsound orders may be generated. With the sound approximation, one getsvery few landmarks, but somewhat better runtime behaviour. This is probably dueto on i ts between the individual sub-tasks asso iated with the individual goal keys,arising when using the ri her, potentially unsound, LGGs. Logisti s { unsound orders may be generated, but are all removed prior to sear hsin e they refer to initial state fa ts. With the sound approximation, one gets veryfew landmarks, and a bad problem de omposition resulting in worse runtime and planlength behaviour. Rovers { unsound orders may be generated. With the sound approximation, onegets only slighty smaller sets of landmarks, resulting in similar, or somewhat worse,performan e in our experiments. Tyreworld { no unsound orders generated.262\nOrdered Landmarks in Planning7. Dis ussionVarious attempts have been made in the past to dete t goal ordering onstraints and usethem for speeding up planning. All of these approa hes di er onsiderably from our work.We list the most losely related ones. Irani and Cheng (1987) order a goal B after a goalA if, roughly speaking, A must be a hieved before B an be a hieved. The same authorslater extended their notions to sets of goals (Cheng & Irani, 1989). In di eren e to ourwork, only top-level goals are onsidered. The same holds true for the work of H ullemet al. (1999) who de ne a number of di erent ordering relations between top-level goals,whi h they approximate using (non-instantiated) operator graphs (Smith & Peot, 1993). Asimilar idea is explored in the PRECEDE system of M Cluskey and Porteous (1997). Theylook at identifying ne essary orders between top level goals but the fo us of their approa his di erent: they develop a method for the onstru tion of planning domain models and,within this, orders are identi ed on e only for a given domain (rather than being probleminstan e spe i ) and are then exploited both for further validation of the domain modeland also at planning time. Knoblo k (1994) des ribes the ALPINE system, whi h does onsider problem sub-goals to ompute an \\abstra tion hierar hy\" for the Prodigy planner(Fink & Veloso, 1994). In ALPINE, a sub-goal A is ordered before a sub-goal B if A mustpossibly be a hieved rst in order to a hieve B. This is di erent from our work where ordersof this kind are inserted when A must ne essarily be a hieved rst in order to a hieve B(also, the way these orders are used to stru ture the sear h is very di erent). Further, indi eren e to our approa h, ALPINE does not onsider the possible negative intera tionsbetween sub-goals, whi h we use to extra t reasonable orders.Koehler and Ho mann (2000) provide the formal notion of reasonable orders betweentop-level goals, whi h they approximate and use for (potentially) splitting a planning taskinto several smaller sub-tasks. We extend this approa h by the new dimension of ne essarysub-goals, landmarks. By doing so, we obtain (potentially) more ordering information, e.g.in domains su h as Grid, Free ell, Logisti s, and Rovers, where the approa h previously ould do nothing to stru ture the sear h (be ause the a hievement of one top level goaldoes not, or only very subtly, a e t the a hievement of another one). We provide a naturalformal extension of reasonable orders to landmarks, larify the omputational omplex-ity of our notions, and des ribe domain-independent and planner-independent algorithmi methods to approximate our de nitions and to exploit the resulting ordering information.Our experiments show that our te hnology often speeds FF up signi antly, sometimesdramati ally, even when already using Koehler and Ho mann's goal ordering te hniques.A preliminary implementation of landmarks to ontrol LPG shows that runtime gains areobtainable for this planner, too.Various interesting resear h questions are open. For example, it is un lear to us whyour landmarks te hnique often has less runtime impa t on LPG than on FF; it ought to beinvestigated how our te hniques an be better integrated with the LPG ode. It might alsobe that, overall, there are alternative ways of using landmarks (e.g. as a plan initialisationte hnique rather than as a disjun tive sear h ontrol framework) that work better for LPG.As another open topi , as said before our urrent te hnology removes, prior to planning, all y les in the ordering relations. Instead, it ould be investigated if these y les an ontainuseful stru tural information, and how to exploit this information. Alternatively it ould263\nHoffmann, Porteous & Sebastiabe investigated how several distin t points of truth of the same fa t ould be taken a ountof in the LGG, thereby avoiding the y le problem altogether (or at least to a ertainextent). It remains open how to avoid the performan e loss that an arise if the plannerfrequently \\swit hes\" between on i ting parts of the LGG ( .f. our observations in Grid,Se tion 6.7). It also remains open how to lift our te hniques to more powerful planningparadigms, in parti ular ADL, numeri , and temporal planning. As for ADL, lifting ourde nitions is probably straightforward, but extending the approximation te hniques (e.g.the omputation of \\shared pre ondition fa ts\" when pre onditions are omplex formulas)seems di\u00c6 ult. It probably makes more sense to look at an extension of STRIPS with onditional a tion e e ts only (planners su h as FF (Ho mann & Nebel, 2001) and IPP(Koehler et al., 1997) ompile full-s ale ADL down into su h a format prior to planning).As for numeri planning, we believe that our de nitions and approximation te hniques anbe naturally extended based on the \\monotoni ity\" on ept introdu ed with Metri -FF byHo mann (2003). Su h te hniques are likely to be useful in domains like Settlers (Long &Fox, 2003) where the numeri variables arry most of the information of what is neededto solve the task. In temporal planning, it seems our te hniques ould, in prin iple, beused with no extensions whatsoever (ex ept adjusting them to the new syntax). It mightbe possible, however, to enri h the landmarks graph (the LGG) with information aboutthe time that is at least needed to get from one landmark (a shared pre ondition, e.g.) toanother one. Su h additional information an probably play a useful role in the temporalplanning pro ess.Finally, staying within the STRIPS setting, there are two interesting topi s opened upby our preliminary handling of \\lookahead ne essary\" orders. Currently we order L!ln L0if L0 is a landmark, and there is an intermediate fa t set fL1; : : : ; Lmg su h that all a hieversof L0 have (at least) one fa t Lj as pre ondition, and all a hievers of any of the fa ts Ljshare the pre ondition L. Now:1. The intermediate set fL1; : : : ; Lmg we use is a disjun tive landmark in the sense thatL1 _ : : : _Lm must be true at some point on every solution plan. While urrently weuse fL1; : : : ; Lmg only to possibly nd new landmarks L, disjun tive landmarks reallyare a generalisation of our approa h. The landmarks we onsidered in this paper arethe spe ial ase where the disjun tive landmarks are singleton sets. It remains toexplore the general ase. Interesting issues are to be resolved on erning the hoi e ofdisjun tion andidates, and the de nition of, e.g., reasonable orders.2. While urrently we look only one step ahead, in general one an look any number kof steps ahead: nd k intermediate sets by ba k haining over possible a hievers, su hthat at the kth level there is a shared pre ondition. Obviously, doing so it wouldbe riti al to nd good heuristi s for sele ting intermediate fa t sets, and to tradethe e ort invested for the extended ba k haining against the value of the obtainedordering information. 264\nOrdered Landmarks in PlanningA knowledgmentsThe authors wish to thank Maria Fox and Derek Long for providing the TIM API. We arealso very thankful to Alfonso Gerevini and Ivan Serina for their help with running/modifyingthe LPG system. We thank Malte Helmert for pointing out some NP-redu tions. We nallywish to thank the anonymous reviewers for their omments, whi h were very helpful toimprove the paper. This arti le is an extended and revised version of a paper (Porteous,Sebastia, & Ho mann, 2001) that was published at ECP-01.Appendix A. ProofsThis appendix ontains two kinds of proofs: rst, statements about the omputational omplexity of de iding about our ordering relations; se ond, statements about our su\u00c6 ient riteria for reasonable orders (i.e., impli ations from ne essary orders and in onsisten y toreasonable orders). Ea h kind of proofs is presented in one subse tion.A.1 Computational ComplexityTheorem 1 Let LANDMARK denote the following problem: given a planning task (A; I;G),and a fa t L; is L a landmark?De iding LANDMARK is PSPACE- omplete.Proof: Hardness is proven by polynomially redu ing the omplement of PLANSAT{ thede ision problem of whether there exists a solution plan to a given arbitrary STRIPS plan-ning task (Bylander, 1994) { to the problem of de iding LANDMARK. Given a planningtask (A; I;G), obtain the modi ed a tion set A0 by adding the three a tions(pre; add; del)(fFg; I; fFg);(fFg; fLg; fFg);(fLg; G; ;)and obtain the modi ed initial and goal states byI 0 := fFg; G0 := GHere, F and L are new fa ts. In words, atta h to (A; I;G) an arti ial way of by-passingthe task. On that by-pass, L must be added. L is a landmark in the modi ed task i (A; I;G) is not solvable.Membership follows be ause a fa t is a landmark if and only if it is an initial- or goal-fa t, or the task be omes unsolvable when ignoring all a tions that add the fa t. De idingunsolvability { the omplement of PLANSAT{ is in PSPACE. 2Theorem 2 Let NECESSARY-ORD denote the following problem: given a planning task(A; I;G), and two fa ts L and L0; does L!n L0 hold?265\nHoffmann, Porteous & SebastiaDe iding NECESSARY-ORD is PSPACE- omplete.Proof: Hardness is proven by polynomially redu ing the omplement of PLANSAT to theproblem of de iding NECESSARY-ORD. Given a planning task (A; I;G), obtain the modi eda tion set A0 by adding the three a tions(pre; add; del)(;; fLg; ;);(fLg; fL0g; ;)(G; fL0g; ;)and obtain the modi ed initial and goal states byI 0 := I; G0 := fL;L0gHere, L and L0 are new fa ts. The only han e of a hieving L0 without having L true apriori is when the original goal G has been a hieved. Thus, there is the ne essary orderL!n L0 if and only if the original task is unsolvable.A non-deterministi algorithm that de ides the omplement of NECESSARY-ORD inpolynomial spa e is the following. Iteratively guess a tions, keeping in memory always onlythe urrent state and its prede essor. If n is the total number of di erent fa ts in (A; I;G),2n su h guessing steps su\u00c6 e to visit all rea hable states (one an use a ounter to keeptra k of the number of guessing steps already made). L!n L0 does not hold if and only ifL0 is true initially, or there is a state that ontains L0 su h that the state's prede essor doesnot ontain L. Finished with NPSPACE = o-PSPACE = PSPACE. 2Note that L and L0 are landmarks in the hardness part to the proof of Theorem 2.Theorem 3 Let GREEDY-NECESSARY-ORD denote the following problem: given a planningtask (A; I;G), and two fa ts L and L0; does L!gn L0 hold?De iding GREEDY-NECESSARY-ORD is PSPACE- omplete.Proof: Hardness is proven by exa tly the same argument as in the proof to Theorem 2.For membership, one an use the same algorithm ex ept that now one must also rememberwhether or not L0 has been true yet, and he k only the prede essors of those states whereL0 is true the rst time. 2Theorem 4 Let AFTERMATH denote the following problem: given a planning task (A; I;G),and two fa ts L and L0; is L0 in the aftermath of L?De iding AFTERMATH is PSPACE- omplete.266\nOrdered Landmarks in PlanningProof: Hardness is proven by redu tion of the omplement of PLANSAT. Given a planningtask (A; I;G), obtain the modi ed a tion set A0 by adding the a tions(pre; add; del)(fFg; fL0g; fFg);(fL0g; fLg; fL0g);(fLg; I; fLg);(fLg; fL0g; ;);(fL;L0g; G; ;)and obtain the modi ed initial and goal states byI 0 := fFg; G0 := GHere, F , L, and L0 are new fa ts. In words, what happens is this. The only state ins 2 S(L0;:L) is the one that results from applying the rst new a tion to the initial state.One must then add L. Afterwards, there is the hoi e to either solve the original task, ora hieve L0 and solve the task using the last of the new a tions. There is a plan from s onwhi h L0 is not true at some point after L if and only if the original task is solvable.A non-deterministi algorithm that de ides the omplement of AFTERMATH in poly-nomial spa e is the following. Iteratively guess 2n a tions, where n is the total number ofdi erent fa ts in (A; I;G). L0 is not in the aftermath of L if and only if there is an a tionsequen e that ontains a state s 2 S(L0;:L) and that a hieves the goal, su h that either L isnot true between s and the rst goal state, or L0 is not true between L and the rst goalstate ( he king s 2 S(L0;:L) and points where L, L0, or the goal are true the rst time an bedone by keeping appropriate ags). Finished with NPSPACE = o-PSPACE = PSPACE.2Theorem 5 Let REASONABLE-ORD denote the following problem: given a planning task(A; I;G), and two fa ts L and L0 su h that L0 is in the aftermath of L; does L!r L0 hold?De iding REASONABLE-ORD is PSPACE- omplete.Proof: The hardness proof is exa tly the same that Koehler and Ho mann (Koehler &Ho mann, 2000) use for proving PSPACE-hardness of de iding about reasonable orders,pro eeding by a polynomial redu tion of (the omplement of) PLANSAT. Given an arbitraryplanning task (A; I;G), introdu e new atoms L, L0, F and F 0 and obtain the modi ed a tionset A0 by adding the three a tions (pre; add; del)(fFg; fL0; F 0g; fFg);(fL0; F 0g; I; fF 0g);(G; fLg; ;)and modify the initial and goal states byI 0 := fFg; G0 := G [ fL;L0g267\nHoffmann, Porteous & SebastiaHere, F , F 0, L, and L0 are new fa ts. L and L0 are goals in the modi ed task so in parti ularL0 is in the aftermath of L. In the modi ed task, S(L0;:L) ontains the single state fL0; F 0g.From there, all plans that a hieve L delete L0 if and only if there is no su h plan, i.e., if andonly if the original task is unsolvable.A non-deterministi algorithm that de ides the omplement of REASONABLE-ORD inpolynomial spa e is the following. Iteratively guess 2n a tions, where n is the total numberof di erent fa ts in (A; I;G), and he k whether there is an a tion sequen e that ontainsa state s 2 S(L0;:L), su h that, after s, L0 does not get deleted before L gets a hieved (thene essary information about the sequen e an be stored in ags). Finished with NPSPACE= o-PSPACE = PSPACE. 2A.2 Su\u00c6 ient CriteriaLemma 1 Given a planning task (A; I;G), and two landmarks L and L0. If either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 for1 i n, and L0 !gn Ln+1,then L0 is in the aftermath of L.Proof: The ase where L0 2 G is trivial. We prove the other ase. Let s 2 S(L0;:L),s = Result(I; P ), be a state where L0 was a hieved stri tly before L on the a tion sequen eP . As L = L1 has never been true on the path P from the initial state to s, neither hasL2 been true, or we have a ontradi tion to L1 !gn L2: L2 is not true initially so it wouldhave to be made true the rst time at some point; immediately before this point, L1 wouldneed to be true. The same argument applies iteratively upwards to all pairs Li and Li+1,implying that none of L1; : : : ; Ln have been true yet on the path to s. Likewise, Ln+1 annot have been true yet on the path to s.Now, observe that, on any solution plan P 0 from s, L0 is true one step before Ln+1 is truethe rst time. This simply follows from the greedy ne essary order between the two fa ts.Say P 0 = ha1; : : : ; ami is a solution plan from s, G Result(s; P 0). As Ln+1 is a landmark,and Ln+1 has not been true on the path to s, P 0 ful lls Ln+1 2 Result(s; ha1; : : : ; aji)for some 1 j n. Assume j is the lowest su h index. Then Ln+1 is made true the rst time at the end of the path P \u00c6 ha1; : : : ; aji. Therefore, with L0 !gn Ln+1 we haveL0 2 Result(s; ha1; : : : ; aj 1i). So the rst o urren e of Ln+1 is at a point j while ano urren e of L0 is at j 1.We now arrive at our desired property by a simple ba kward haining on the sequen eL1; : : : ; Ln. We know that Ln+1 is rst true at point j > 0 on the a tion sequen e P 0 =ha1; : : : ; ami. With Ln !gn Ln+1, we thus have that Ln is true at j 1. Be ause Lnhas not been true on the path to s, it rst be omes true at some point j0 on the a tionsequen e P 0, where j0 < j. We an apply the same argument downwards to L1, giving usL1 = L 2 Result(s; ha1; : : : ; aj00i) for some j00 < j. This on ludes the argument. 2268\nOrdered Landmarks in PlanningTheorem 6 Given a planning task (A; I;G), and two landmarks L and L0. If L interfereswith L0, and either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 for1 i n, and L0 !gn Ln+1,then there is a reasonable order between L and L0, L!r L0.Proof: By Lemma 1, we know that L0 is in the aftermath of L. Say s 2 S(L0;:L). We needto prove that any a tion sequen e a hieving L from s deletes L0. We need to over fourreasons for interferen e.1. L is in onsistent with L0: with in onsisten y, from any rea hable state were L0 is truewe must delete L0 in order to a hieve L.2. there is a fa t x 2 Ta2A;L2add(a) add(a) su h that x is in onsistent with L0: x willne essarily be true in the state after we a hieved L, so L0 must be deleted by somea tion on the way to that state.3. L0 2 Ta2A;L2add(a) del(a): obvious, the a tion adding L will delete L0.4. Say there is an x that is in onsistent with L0, and x !gn L. We know that s isrea hable, s = Result(I; P ), L0 2 s, and L is not true at any point on the pathto s. As L0 2 s, we have x 62 s with in onsisten y. Say P 0 = ha1; : : : ; ani 2 A is an a tion sequen e su h that L 2 Result(s; P 0), i.e., L 2 Result(s; ha1; : : : ; aii)su h that i is minimal. Be ause L is a hieved the rst time on the sequen e P \u00c6ha1; : : : ; aii, we an apply the greedy ne essary order x !gn L, so we know thatx 2 Result(I; P \u00c6 ha1; : : : ; ai 1i) (i 1 be ause L 62 s). With in onsisten y, L0 62Result(I; P \u00c6 ha1; : : : ; ai 1i), so i 1 > 0 and L0 2 del(aj) for some 1 j i 1. 2Lemma 2 Given a planning task (A; I;G), a set O of reasonable ordering onstraints, andtwo landmarks L and L0. If either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 orLi !r Li+1 2 O for 1 i n, and L0 !gn Ln+1,then L0 is in the obedient aftermath of L.Proof: The ase where L0 2 G is trivial. We prove the other ase. Let s 2 SO(L0;:L) be astate where L0 has been a hieved stri tly before L; let P be an obedient path from the initialstate to s on whi h L has not yet been true, and L0 has just been a hieved. As L = L1 hasnever been true on the path, neither has L2 been true, or we have a ontradi tion to theorder between L1 and L2. The same argument applies iteratively upwards to all pairs Li269\nHoffmann, Porteous & Sebastiaand Li+1, implying that none of L1; : : : ; Ln have been true yet on the path to s. Likewise,Ln+1 an not have been true yet on the path to s if the se ond ase of the prerequisiteholds. In parti ular, none of these fa ts is ontained in s itself.Now, observe that, on any solution plan P 0 from s, L0 is true one step before Ln+1 istrue the rst time. This simply follows from the greedy ne essary order between the twofa ts. Say P 0 = ha1; : : : ; ami is a solution plan from s, G Result(s; P 0), su h that P \u00c6 P 0is obedient. As Ln+1 is a landmark, and Ln+1 has not been true on the path to s, P 0 ful llsLn+1 2 Result(s; ha1; : : : ; aji) for some 1 j n. Assume j is the lowest su h index. ThenLn+1 is made true the rst time at the end of the path P \u00c6 ha1; : : : ; aji. Therefore, withL0 !gn Ln+1 we have L0 2 Result(s; ha1; : : : ; aj 1i). So the rst o urren e of Ln+1 is at apoint j while an o urren e of L0 is at j 1.We now arrive at our desired property by a simple ba kward haining on the sequen eL1; : : : ; Ln. We know that Ln+1 is rst true at point j > 0 on the a tion sequen e P 0 =ha1; : : : ; ami. If Ln !gn Ln+1, we thus have that Ln is true at j 1. If Ln !r Ln+1 2 O, wehave that Ln is true at some 0 < j0 < j, be ause P \u00c6P 0 is obedient and Ln has not been trueon the path to s. In both ases, we know that Ln be omes true the rst time at some pointj0 on the a tion sequen e P 0, where j0 < j. We an apply the same argument downwardsto L1, giving us L1 = L 2 Result(s; ha1; : : : ; aj00i) for some j00 < j. This on ludes theargument. 2Theorem 7 Given a planning task (A; I;G), a set O of reasonable ordering onstraints,and two landmarks L and L0. If L interferes with L0, and either1. L0 2 G, or2. there are landmarks L = L1; : : : ; Ln+1, n 1, Ln 6= L0, su h that Li !gn Li+1 orLi !r Li+1 2 O for 1 i n, and L0 !gn Ln+1,then there is an obedient reasonable order between L and L0, L Or L0.Proof: By Lemma 2, we know that L0 is in the obedient aftermath of L. Say s 2 SO(L0;:L).We need to prove that any a tion sequen e a hieving L from s deletes L0. For the fourreasons for interferen e, this an be proven with exa tly the same arguments as in the proofto Theorem 6. 2Appendix B. Runtime Distribution GraphsThis appendix provides supplementary material to the experimental data presented in Se -tion 6. In Figures 11, 12, and 13, we provide runtime distribution graphs for all the testingdomains (ex ept Tyreworld where, as des ribed in Se tion 6.10, the results are very easy tointerpret). We plot the number of solved instan es against the elapsed runtime. We do notmake a distin tion between the di erent sizes of the instan es in the example suites, i.e.,the numbers of solved instan es shown refer to the entire set of example instan es in therespe tive domain. The graphs are (only) intended to foster understandability of the datapresented in Se tion 6, and should be self-explanatory given the dis ussion in that se tion.270\nOrdered Landmarks in Planning\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nFFv1.0 FFv1.0+L\nFFv2.3 FFv2.3+L\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nLPG LPG+L\nBlo ksworld-arm (a) Blo ksworld-arm (b)\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nFFv1.0 FFv1.0+L\nFFv2.3 FFv2.3+L\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nLPG LPG+L\nBlo ksworld-no-arm (a) Blo ksworld-no-arm (b)\n0\n40\n80\n120\n160\n200\n240\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nFFv1.0 FFv1.0+L\nFFv2.3 FFv2.3+L\n0\n40\n80\n120\n160\n200\n240\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nLPG LPG+L\nDepots (a) Depots (b)Figure 11: Number of solved instan es (y-axis) plotted against se onds runtime (x-axis) for(a) FFv1.0 and FFv2.3, as well as for (b) LPG. Curves shown for ea h plannerwithout landmarks ontrol (\\X\"), and for ea h planner with landmarks ontrol(\\X+L\"), in the Blo ksworld-arm, Blo ksworld-no-arm, and Depots examplesuite from Se tion 6. 271\nHoffmann, Porteous & Sebastia\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nFFv1.0 FFv1.0+L\nFFv2.3 FFv2.3+L\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nLPG LPG+L\nFree ell (a) Free ell (b)\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nFFv1.0 FFv1.0+L\nFFv2.3 FFv2.3+L\n0\n20\n40\n60\n80\n100\n120\n0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nLPG LPG+L\nGrid (a) Grid (b)\n0\n20\n40\n60\n80\n100\n120\n20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nFFv1.0 FFv1.0+L\nFFv2.3 FFv2.3+L\n0\n20\n40\n60\n80\n100\n120\n20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nLPG LPG+L\nLogisti s (a) Logisti s (b)Figure 12: Number of solved instan es (y-axis) plotted against se onds runtime (x-axis) for(a) FFv1.0 and FFv2.3, as well as for (b) LPG. Curves shown for ea h plannerwithout landmarks ontrol (\\X\"), and for ea h planner with landmarks ontrol(\\X+L\"), in the Free ell, Grid, and Logisti s example suites from Se tion 6.272\nOrdered Landmarks in Planning\n0\n20\n40\n60\n80\n100\n120\n20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nFFv1.0 FFv1.0+L\nFFv2.3 FFv2.3+L\n0\n20\n40\n60\n80\n100\n120\n20 40 60 80 100 120 140 160 180 200 220 240 260 280 300\nLPG LPG+L\nRovers (a) Rovers (b)Figure 13: Number of solved instan es (y-axis) plotted against se onds runtime (x-axis) for(a) FFv1.0 and FFv2.3, as well as for (b) LPG. Curves shown for ea h plannerwithout landmarks ontrol (\\X\"), and for ea h planner with landmarks ontrol(\\X+L\"), in the Rovers example suites from Se tion 6.Appendix C. Experimental LPG+L ImplementationIn this appendix we dis uss our experimental implementation of landmarks ontrol aroundLPG. The implementation is preliminary in that it does not integrate landmarks ontroldire tly with LPG's ode, but rather implements a simple ontrol loop around an LPGexe utable. This auses a large runtime overhead due to the repetition of LPG's pre-pro essing ma hinery that omputes fa t (and a tion) in onsisten ies. Our approa h is tosimply ignore this unne essary overhead. This way, our experimental ode produ es thesame results as a dire t implementation that would do the pre-pro ess only on e { providedLPG's pre-pro ess omputes the same information throughout the ontrol loop. We showthat the latter is indeed the ase in all our 8 testing domains ex ept in Free ell. As explainedin Se tion 6 already, be ause of these results in Free ell we measure total running time ofour implementation, while in the other 7 domains we ount the runtime for only the rstone of LPG's in onsisten y pre-pro esses.Let us rst dis uss LPG's overall ar hite ture. As far as relevant for us here, it pro eedsas follows:1. Perform a pre-pro ess that dete ts in onsistent fa ts and a tions.2. Build a planning graph where the mutex reasoning is repla ed by inserting the pre- omputed in onsisten ies.3. Perform a lo al sear h in a spa e of sub-graphs of the resulting planning graph.We need a little more detail about steps 1 and 2. We summarise the algorithms des ribed byGerevini et al. (2003). Step 1 rst omputes in onsistent pairs of fa ts. The algorithm keepstra k of sets F and A of rea hed fa ts and a tions, and of a setM of potential in onsisten ies273\nHoffmann, Porteous & Sebastia(persistent mutex relations, in LPG's terminology). F is initialised with the initial state ofthe task that LPG is run on, A and M are initialised with the empty set. Then a xpointpro edure iterates until there are no more hanges to F andM . In ea h iteration, all a tionsare onsidered whose pre onditions are in F without an in onsisten y in M . Su h a tionsare used to identify new potential in onsisten ies (e.g., between the a tion's add and deletee e ts). Potential in onsisten ies are removed when there are a tions in A that either addboth fa ts, or add one fa t without deleting the other. When the xpoint is rea hed, thefa t pairs in M are proved to be in onsistent. The in onsistent a tions are then omputedas those that either interfere (delete ea h others add e e ts or pre onditions), or have ompeting needs (in onsistent pre onditions). Step 2 in LPG's ar hite ture then builds aplanning graph without mutex reasoning. Starting from the initial state, fa t layers Fi anda tion layers Ai are built alternatingly, where Ai ontains all a tions whose pre onditionsare in Fi, and Fi+1 ontains all add e e ts of the a tions in Ai. The pro ess stops witha layer where no new fa ts ome in, and the mutex pairs in the resulting graph are thein onsistent pairs omputed by step 1.As said, our experimental implementation repeatedly alls an LPG exe utable insidethe landmarks ontrol. So steps 1 and 2 are done over again, produ ing a large runtimeoverhead. In an implementation integrating the landmarks ontrol dire tly into LPG's ode,one ould avoid mu h of this overhead by using an overall ar hite ture that omputes thein onsisten ies only on e, and (only) does steps 2 and 3 of LPG's ar hite ture for everysub-task in the ontrol loop. We hen eforth refer to su h a hypotheti al implementation asdire t-LPG+L, and to our experimental implementation as LPG+L. The idea is to simulatedire t-LPG+L's behaviour by running LPG+L, and ounting the runtime taken by LPG instep 1 only for the rst iteration of the ontrol loop.24 The subtlety to be taken are of isthat the result of step 1 depends on the start (initial) state that LPG is run on. Rememberthat the sear h ontrol loop in LPG+L alls LPG on a sequen e of onse utive start statess, where the rst s is the initial state, and ea h su essor start state s0 results from theprevious start state s by applying the plan that LPG found for the last sub-task. Now,di erent found in onsisten ies (for di erent start states) in step 1 an result in di erentplanning graphs at the end of step 2, and di erent planning graphs an result in di erentsear h behaviour in step 3. So we an only safely simulate dire t-LPG+L in ases wherethe planning graph resulting from step 2 is always the same in LPG+L as it would be indire t-LPG+L. We found that the latter is indeed the ase in 7 of our 8 testing domains.The reason for this is that state rea hability is (largely, in some ases) invertible in thesedomains.Consider a state s0 that is rea hable from a state s. Denote by F (s), A(s) and M(s)the sets F , A, and M at the end of LPG's fa t in onsisten y xpoint omputation whenstarted with initial state s, similarly for s0. Then F (s0) F (s), A(s0) A(s), and M(s0) M(s)\\ (F (s0) F (s0)) hold. The reason is simply that everything that is rea hable from s0is also rea hable from s. The xpoint pro ess from s will eventually \\exe ute\" the a tionsequen e that leads from s to s0, i.e., in lude these a tions into the set A. At this point,24. The LPG implementation interleaves the omputations for step 1 and step 2, whi h is why the individualruntimes an not be separated, and our LPG+L implementation in fa t ignores the overhead for bothstep 1 and step 2 ex ept in the rst iteration of the ontrol loop. The time taken for step 2 is typi allynot signi ant. See also the dis ussion at the end of this appendix.274\nOrdered Landmarks in Plannings0 will be ontained in the set F , with no potential in onsisten ies. It follows that everyfa t or a tion that the pro ess rea hes when started in s0 will also be rea hed when startedin s. It also follows that every potential in onsisten y the pro ess removes from M whenstarted in s0 will also be removed when started in s. This proves the laim. (A tually,M(s0) M(s) \\ (F (s0) F (s0)) already follows be ause every fa t pair that is in onsistentbelow s must also be in onsistent below s0. We in lude the longer proof sket h to providea better ba kground for the proof arguments below.)If LPG's step 1 nds the same fa t in onsisten ies for two states, then it trivially followsthat the a tion in onsisten ies identi ed will also be the same. Thus, with the above, ifstates s and s0 are both rea hable from ea h other, then the out ome of step 1 is the samefor both states. This immediately shows that in invertible domains { domains where toea h a tion a there is an inverse a tion a that undoes exa tly a's e e ts { the out ome ofLPG's step 1 remains the same throughout our landmarks ontrol loop. Blo ksworld-arm,Blo ksworld-no-arm, Depots, and Logisti s are all invertible.The other three of our experimental domains where we an safely ignore the overhead aused by step 1 repetition are Grid, Rovers, and Tyreworld. For ea h of these domains,we show that the out ome of step 2 in dire t-LPG+L is the same as the out ome of step2 in LPG+L, for every iteration of the landmarks ontrol loop. Let us start with theTyreworld. Consider the information omputed by LPG's steps 1 and 2 in states s and s0,where s0 is rea hable from s. Tyreworld is not invertible only be ause one an not \\de- ate\" spare wheels that one has already in ated. From s0 one an get to a state s00 thatsubsumes s ex ept for, possibly, a set of not-in ated(?spare-wheel) fa ts. Su h fa ts serveonly as pre ondition for the a tions that in ate ?spare-wheel, whi h a tions only a hievein ated(?spare-wheel). These in ated(?spare-wheel) fa ts are already ontained in s0. Sothe fa t in onsisten y xpoint pro ess an rea h everything from s0 that it an rea h froms, ex ept the in ate ?spare-wheel a tions. It follows that the only di eren e of the out omeof step 1 in s0 ompared to its out ome in s is that from s there an be in onsisten iesinvolving the in ate ?spare-wheel a tions. But when step 2 is done in s0, these a tions arenever rea hed anyway as their not-in ated(?spare-wheel) pre onditions are not rea hable.So steps 2 in both LPG+L and dire t-LPG+L end up with the same planning graphs forthe state s0.A similar argument as in Tyreworld applies to states s and s0 in Grid tasks. The onlything that an not be undone in Grid tasks is the opening of lo ked lo ations. From s0 one an get to a state s00 that subsumes s ex ept, possibly, a set of lo ked(?lo ation) fa ts. Su hfa ts serve only as pre ondition for a tions that unlo k ?lo ation, whi h a tions only a hieveunlo ked(?lo ation). These unlo ked(?lo ation) fa ts are already ontained in s0, and theonly di eren e of the out ome of step 1 in s0 ompared to its out ome in s is that from sthere an be in onsisten ies involving a tions that unlo k ?lo ation. When dire t-LPG+Ldoes step 2 in s0, these a tions are never rea hed anyway.Finally, let's onsider the Rovers domain. When rea hing a state s0 from a state sin Rovers, one an in general not get ba k to s, be ause on e a soil or ro k sample hasbeen taken, it an not be put ba k to the waypoint it's been taken from. That is, froms0 one an get to a state s00 that subsumes s ex ept, possibly, a set of at-soil/ro k-sample275\nHoffmann, Porteous & Sebastiafa ts.25 This, in turn, an only a e t the rea hability of sample-soil/ro k a tions, have-soil/ro k-sample fa ts, full-storage-spa e fa ts, ommuni ate-soil/ro k-data a tions, and ommuni ated-ro k/soil-data fa ts. So the only di eren e of the out ome of step 1 ins0 ompared to its out ome in s is that from s there an be in onsisten ies involving thesefa ts and a tions. But when dire t-LPG+L does step 2 in s0, these fa ts and a tions arenever rea hed anyway.We nally remark the following. The LPG implementation interleaves the omputationsfor step 1 and step 2, and LPG outputs the runtime taken by step 1 together with step 2. Soour LPG+L implementation in fa t ignores the overhead for both step 1 and step 2 ex eptin the rst iteration of the ontrol loop. In personal ommuni ation, Alfonso Gereviniand Ivan Serina informed us that step 2 typi ally takes only a small fra tion (around 5%)of the time spent in pre-pro essing { whi h seems reasonable onsidering that step 2 isbasi ally the same as building a relaxed planning graph, i.e., a single heuristi evaluationin, e.g., FF. Nevertheless, we reiterate that our LPG+L implementation is preliminary,and that the runtime results should be treated with are. In a dire t implementation oflandmarks in LPG, step 2 would have to be done for every iteration of the ontrol loop,whi h runtime overhead we ould not ount due to the above implementational di\u00c6 ulties.On the other hand, in a dire t implementation one ould exploit various ideas regardingthe omputation of in onsisten ies for di erent start states. Alfonso Gerevini suggestedthat, e.g., one ould modify the in onsisten y omputation to only take a ount of the hanges in a new state. One ould also derive state invariants, like DISCOPLAN (Gerevini& S hubert, 2000) does, that are omputed only on e (independently of the initial state),and then pruned a ordingly every time a new start state omes up (pruning amounts toremoving those invariants that do not hold given a parti ular initial state). Finally, one ould try to repla e LPG's in onsisten y reasoning with the TIM in onsisten y fun tion,thereby avoiding step 1 altogether. As we said before, exploring su h possibilities is a topi for future work.Referen esBlum, A. L., & Furst, M. L. (1997). Fast planning through planning graph analysis. Arti ialIntelligen e, 90 (1-2), 279{298.Bonet, B., & Ge ner, H. (2001). Planning as heuristi sear h. Arti ial Intelligen e, 129 (1{2), 5{33.Bylander, T. (1994). The omputational omplexity of propositional STRIPS planning.Arti ial Intelligen e, 69 (1{2), 165{204.Cheng, J., & Irani, K. B. (1989). Ordering problem subgoals. In Sridharan, N. S. (Ed.), Pro- eedings of the 11th International Joint Conferen e on Arti ial Intelligen e (IJCAI-89), pp. 931{936, Detroit, MI. Morgan Kaufmann.Fikes, R. E., & Nilsson, N. (1971). STRIPS: A new approa h to the appli ation of theoremproving to problem solving. Arti ial Intelligen e, 2, 189{208.25. Taking an image deletes the alibration of the amera; but one an always re- alibrate the amera withthe same alibration target as was used before { no amera is alibrated initially.276\nOrdered Landmarks in PlanningFink, E., & Veloso, M. (1994). Prodigy planning algorithm. Te hni al report CMU-94-123,Carnegie Mellon University.Fox, M., & Long, D. (1998). The automati inferen e of state invariants in TIM. Journalof Arti ial Intelligen e Resear h, 9, 367{421.Garey, M. R., & Johnson, D. S. (1979). Computers and Intra tability|A Guide to theTheory of NP-Completeness. Freeman, San Fran is o, CA.Gazen, B. C., & Knoblo k, C. (1997). Combining the expressiveness of UCPOP with thee\u00c6 ien y of Graphplan.. In Steel, & Alami (Steel & Alami, 1997), pp. 221{233.Gerevini, A., & S hubert, L. (2000). Inferring state onstraints in DISCOPLAN: Some newresults. In Pro eedings of the 17th National Conferen e of the Ameri an Asso iationfor Arti ial Intelligen e (AAAI-00), pp. 761{767, Austin, TX. MIT Press.Gerevini, A., Saetti, A., & Serina, I. (2003). Planning through sto hasti lo al sear h andtemporal a tion graphs. Journal of Arti ial Intelligen e Resear h, 20, 239{290.Haslum, P., & Ge ner, H. (2000). Admissible heuristi s for optimal planning. In Chien,S., Kambhampati, R., & Knoblo k, C. (Eds.), Pro eedings of the 5th InternationalConferen e on Arti ial Intelligen e Planning Systems (AIPS-00), pp. 140{149. AAAIPress, Menlo Park.Ho mann, J. (2000). A heuristi for domain independent planning and its use in an en-for ed hill- limbing algorithm. In Pro eedings of the 12th International Symposiumon Methodologies for Intelligent Systems (ISMIS-00), pp. 216{227. Springer-Verlag.Ho mann, J. (2002). Lo al sear h topology in planning ben hmarks: A theoreti al analysis.In Ghallab, M., Hertzberg, J., & Traverso, P. (Eds.), Pro eedings of the 6th Interna-tional Conferen e on Arti ial Intelligen e Planning and S heduling (AIPS-02), pp.92{100, Toulouse, Fran e. Morgan Kaufmann.Ho mann, J. (2003). The Metri -FF planning system: Translating \\ignoring delete lists\"to numeri al state variables. Journal of Arti ial Intelligen e Resear h, 20, 291{341.Ho mann, J., & Nebel, B. (2001). The FF planning system: Fast plan generation throughheuristi sear h. Journal of Arti ial Intelligen e Resear h, 14, 253{302.H ullen, J., Mu~noz-Avila, H., & Weberskir h, F. (1999). Extra ting goal orderings to im-prove partial-order and Graphplan-based planning. Te hni al report, University ofKaiserslautern.Irani, K. B., & Cheng, J. (1987). Subgoal ordering and goal augmentation for heuristi problem solving. In M Dermott, J. (Ed.), Pro eedings of the 10th International JointConferen e on Arti ial Intelligen e (IJCAI-87), pp. 1018{1024, Milan, Italy. MorganKaufmann.Knoblo k, C. (1994). Automati ally generating abstra tions for planning. Arti ial Intel-ligen e, 68 (2), 243{302.Koehler, J. (1998). Solving omplex planning tasks through extra tion of subproblems. InSimmons, R., Veloso, M., & Smith, S. (Eds.), Pro eedings of the 4th InternationalConferen e on Arti ial Intelligen e Planning Systems (AIPS-98), pp. 62{69. AAAIPress, Menlo Park. 277\nHoffmann, Porteous & SebastiaKoehler, J., & Ho mann, J. (2000). On reasonable and for ed goal orderings and their usein an agenda-driven planning algorithm. Journal of Arti ial Intelligen e Resear h,12, 338{386.Koehler, J., Nebel, B., Ho mann, J., & Dimopoulos, Y. (1997). Extending planning graphsto an ADL subset.. In Steel, & Alami (Steel & Alami, 1997), pp. 273{285.Long, D., & Fox, M. (2003). The 3rd international planning ompetition: Results andanalysis. Journal of Arti ial Intelligen e Resear h, 20, 1{59.M Cluskey, T. L., & Porteous, J. M. (1997). Engineering and ompiling planning domainmodels to promote validity and e\u00c6 ien y. Arti ial Intelligen e, 95 (1), 1{65.M Dermott, D., et al. (1998). The PDDL Planning Domain De nition Language. TheAIPS-98 Planning Competition Comitee.M Dermott, D. V. (1999). Using regression-mat h graphs to ontrol sear h in planning.Arti ial Intelligen e, 109 (1-2), 111{159.Porteous, J., & Sebastia, L. (2000). Extra ting and ordering landmarks for planning. InPro eedings UK Planning and S heduling SIG Workshop.Porteous, J., Sebastia, L., & Ho mann, J. (2001). On the extra tion, ordering, and usageof landmarks in planning. In Cesta, A., & Borrajo, D. (Eds.), Re ent Advan es in AIPlanning. 6th European Conferen e on Planning (ECP'01), pp. 37{48, Toledo, Spain.Springer-Verlag.Russell, S., & Norvig, P. (1995). Arti ial Intelligen e: A Modern Approa h. Prenti e-Hall,Englewood Cli s, NJ.Slaney, J., & Thiebaux, S. (2001). Blo ks world revisited. Arti ial Intelligen e, 125, 119{153.Smith, D., & Peot, M. (1993). Postponing threats in partial-order planning. In Pro eedingsof the 11th National Conferen e of the Ameri an Asso iation for Arti ial Intelligen e(AAAI-93), pp. 500{506, Washington, DC. MIT Press.Steel, S., & Alami, R. (Eds.). (1997). Re ent Advan es in AI Planning. 4th European Con-feren e on Planning (ECP'97), Vol. 1348 of Le ture Notes in Arti ial Intelligen e,Toulouse, Fran e. Springer-Verlag.\n278"}], "references": [], "referenceMentions": [], "year": 2011, "abstractText": null, "creator": "dvips(k) 5.92b Copyright 2002 Radical Eye Software"}}}