{"id": "1201.6615", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Jan-2012", "title": "Feature Selection for Value Function Approximation Using Bayesian Model Selection", "abstract": "feature selection in reinforcement learning ( rl ), i. e. choosing basis functions such that useful approximations of the unkown value gamma function can be obtained, is another one of the main challenges in scaling rl to real - world applications. here we consider the gaussian process based quantitative framework gptd for approximate behavioral policy application evaluation, uniformly and confidently propose robust feature selection through marginal % likelihood optimization of the associated hyperparameters. our approach arguably has two strongly appealing benefits : ( 1 ) given just sample of transitions, we can routinely solve the policy evaluation problem fully estimated automatically ( without looking at the learning balancing task, and, in theory, independent of the dimensionality of the state loop space ), and ( 2 ) model selection allows us to consider more sophisticated kernels, by which in turn enable us to identify relevant subspaces and eliminate irrelevant state variables such that we can achieve substantial computational savings and improved prediction performance.", "histories": [["v1", "Tue, 31 Jan 2012 16:57:55 GMT  (397kb)", "http://arxiv.org/abs/1201.6615v1", "European Conference on Machine Learning (ECML'09)"]], "COMMENTS": "European Conference on Machine Learning (ECML'09)", "reviews": [], "SUBJECTS": "cs.AI cs.LG", "authors": ["tobias jung", "peter stone"], "accepted": false, "id": "1201.6615"}, "pdf": {"name": "1201.6615.pdf", "metadata": {"source": "CRF", "title": "Feature Selection for Value Function Approximation Using Bayesian Model Selection", "authors": ["Tobias Jung"], "emails": ["tjung@cs.utexas.edu", "pstone@cs.utexas.edu"], "sections": [{"heading": null, "text": "ar X\niv :1\n20 1.\n66 15\nv1 [\ncs .A\nI] 3\n1 Ja\nn 20"}, {"heading": "1 Introduction", "text": "In this paper, we address the problem of approximating the value function under a stationary policy \u03c0 for a continuous state space X \u2282 RD,\nV \u03c0(x) = E x \u2032|x,\u03c0(x) {R(x, \u03c0(x),x \u2032) + \u03b3V \u03c0(x\u2032)} (1)\nusing a linear approximation of the form V\u0303 (\u00b7 ;w) = \u2211m\ni=1 wi\u03c6i(x) to represent V \u03c0. Here x denotes the state, R the scalar reward and \u03b3 the discount factor. Given a trajectory of states x1, . . . ,xn and rewards r1, . . . , rn\u22121 sampled under \u03c0, the goal is to determine weights wi (and basis functions \u03c6i) such that V\u0303 is a good approximation of V \u03c0. This is the fundamental problem arising in the policy iteration framework of infinite-horizon dynamic programming and reinforcement learning (RL), e.g. see [21,3]. Unfortunately, this problem is also a very difficult problem that, at present, has no completely satisfying solution. In particular, deciding which features (basis functions \u03c6i) to use is rather challenging, and in general, needs to be done manually: thus it is tedious, prone to errors, and most important of all, requires considerable insight into the domain. Hence, it would be far more desirable if a learning system could automatically choose its own representation. In particular, considering efficiency, we want to adapt to the actual difficulties faced, without wasting resources: often, there are many factors\nthat can make a particular problem easier than it initially appears to be, for example, when only a few of the inputs are relevant, or when the input data lies on a low-dimensional submanifold of the input space.\nRecent work in applying nonparametric function approximation to RL, such as Gaussian processes (GP) [6,16,18,5], or equivalently, regularization networks [8], is a very promising step in this direction. Instead of having to explicitly specify individual basis functions, we only have to specify a more general kernel that just depends on a very small number of hyperparameters. The key contribution of this paper is to demonstrate that feature selection in RL from sample transitions can be automated, using any of several possible model selection methods for these hyperparameters, such as marginal likelihood optimization in a Bayesian setting, or leave-one-out (LOO) error minimization in a frequentist setting. Here, we will focus on the Bayesian setting, and adapt marginal likelihood optimization for the GP-based approximate policy evaluation method GPTD, introduced without model selection in [6]. Overall, this will have the following benefits: First, only by automatic model selection (as opposed to a grid-based search or manual tweaking of kernel parameters) will we be able to use more sophisticated kernels, which will allow us to uncover the \u201dhidden\u201d properties of given problem. For example, by choosing an RBF kernel with independent lengthscales for the individual dimensions of the state space, model selection will automatically drive those components to zero that correspond to state variables irrelevant (or redundant) to the task. This will allow us to concentrate our computational efforts on the parts of the input space that really matter and will improve computational efficiency. Second, because it is generally easier to learn in \u201dsmaller\u201d spaces, it may also benefit generalization and thus help us to reduce sample complexity.\nDespite its many promises, previous work with GPs in RL rarely explores the benefits of model selection: in [18], a variant of stochastic search was used to determine hyperparameters of the covariance for GPTD using as score function the online performance of an agent. In [16], standard GPs with marginal likelihood based model selection were employed; however, since their approach was based on fitted value iteration, the task of value function approximation was reduced to ordinary regression. The remaining paper is structured as follows: Section 2-3 contain background information and summarize the GPTD framework. As one of the benefits of model selection is the reduction of computational complexity, Section 4 describes how GPTD can be solved for large-scale problems using SR-approximation. Section 5 introduces model selection for GPTD and derives in detail the associated gradient computation. Finally, Section 6 illustrates our approach by providing experimental results."}, {"heading": "2 Related work", "text": "The overall goal of learning representations and feature selection for linearly parameterized V\u0303 is not new within the context of RL. Roughly, past methods can be categorized along two dimensions: how the basis functions are represented (e.g. either by parameterized and predefined basis functions such as RBF, or\nby nonparameterized basis functions directly derived from the data) and what quantity/target function is considered to guide their construction process (e.g. either supervised methods that consider the Bellman error and depend on the particular reward/goal, or unsupervised graph-based methods that consider connectivity properties of the state space). Conceptually closely related to our work is the approach described in [12], which adapts the hyperparameters of RBFbasis functions (both their location and lengthscales) using either gradient descent or the cross-entropy method on the Bellman error. However, because basis functions are adapted individually (and their number is chosen in advance), the method is prone to overfitting: e.g. by placing basis functions with very small width near discontinuities. The problem is compounded when only few data points are available. In contrast, using a Bayesian approach, we can automatically trade-off model fit and model complexity with the number of data points, choosing always the best complexity: e.g. for small data sets we will prefer larger lengthscales (less complex), for larger data sets we can afford smaller lengthscales (more complex).\nOther alternative approaches do not rely on predefined basis functions: The method in [9] is an incremental approach that uses dimensionality reduction and state aggregation to create new basis functions such that for every step the remaining Bellman error for a trajectory of states is successively reduced. A related approach is given in [14] which incrementally constructs an orthogonal basis for the Bellman error. A graph-based unsupervised approach is presented in [11], which derives basis functions from the eigenvectors of the graph Laplacian induced from the underlying MDP."}, {"heading": "3 Background: GPs for policy evaluation", "text": "In this section we briefly summarize how GPs [17] can be used for approximate policy evaluation; here we will follow the GPTD formulation of [6].\nSuppose we have observed the sequence of states x1,x2, . . . ,xn and rewards r1, . . . , rn\u22121, where xi \u223c p(\u00b7 |xi\u22121, \u03c0(xi\u22121)) and ri = R(xi, \u03c0(xi),xi+1). In practice, MDPs considered in RL will often be of an episodic nature with absorbing terminal states. Therefore we have to transform the problem such that the resulting Markov chain is still ergodic: this is done by introducing a zero reward transition from the terminal state of one episode to the start state of the next episode. In addition to the sequence of states and rewards our training data thus also includes a sequence \u03b31, . . . , \u03b3n\u22121, where \u03b3i = \u03b3 (the discount factor in Eq. (1)) if xi+1 was a non-terminal state, and \u03b3i = 0 if xi was a terminal state (in which case xi+1 is the start state of the next episode).\nAssume that the function values V (x) of the unknown value function V : X \u2282 RD \u2192 R from Eq. (1) form a zero-mean Gaussian process with covariance function k(x,x\u2032) for x,x\u2032 \u2208 X ; in short V \u223c GP(0, k(x,x\u2032)). In consequence, the function values for the n observed states, v := ( V (x1), . . . , V (xn) )T\n, will have a Gaussian distribution\nv |X, \u03b8 \u223c N (0,K), (2)\nwhere X := [x1, . . . ,xn] and K is the n \u00d7 n covariance matrix with entries [K]ij = k(xi,xj). Note that the covariance k(\u00b7, \u00b7) alone fully specifies the GP; here we will assume that it is a simple (positive definite) function parameterized by a number of scalar parameters collected in vector \u03b8 (see Section 4).\nHowever, unlike in ordinary regression, in RL we cannot observe samples from the target function V directly. Instead, the values can only be observed indirectly: from Eq. (1) we have that the value of one state is recursively defined through the value of the successor state(s) and the immediate reward. To this end, Engel et al. propose the following generative model:1\nR(xi,xi+1) = V (xi)\u2212 \u03b3iV (xi+1) + \u03b7i, (3)\nwhere \u03b7i is a noise term that may depend on the inputs. 2 Plugging in the observed training data, and defining r := ( r1, . . . , rn\u22121 )T , we obtain\nr = Hv + \u03b7, (4)\nwhere the (n\u2212 1)\u00d7 n matrix H is given by\nH :=\n\n  1 \u2212\u03b31 . . . . . .\n1 \u2212\u03b3n\u22121\n\n  (5)\nand noise \u03b7 := ( \u03b71, . . . , \u03b7n\u22121 )T\nhas distribution \u03b7 \u223c N (0,\u03a3). One first choice for the noise covariance \u03a3 would be \u03a3 = \u03c320I, where \u03c3 2 0 is an unknown hyperparameter (see Section 4). However, this model does not capture stochastic state transitions and hence would only be applicable for deterministic MDPs. If the environment is stochastic, the noise model \u03a3 = \u03c320HH\nT is more appropriate, see [6] for more detailed explanations. For the remainder we will solely consider the latter choice, i.e. \u03a3 = \u03c320HH\nT. Let D := {X, \u03b31, . . . , \u03b3n\u22121} be an abbreviation for the training inputs. Using Eq. (4), it can be shown that the joint distribution of the observed rewards r given inputs D is again a Gaussian,\nr | D, \u03b8 \u223c N (0,Q), (6)\nwhere the (n\u2212 1)\u00d7 (n\u2212 1) covariance matrix Q is given by\nQ = ( HKHT + \u03c320HH T ) . (7)\nTo predict the function value V (x\u2217) at a new state x\u2217, we consider the joint distribution of r and V (x\u2217)\n[\nr V (x\u2217)\n]\n| D,x\u2217, \u03b8 \u223c N\n([\n0 0\n]\n,\n[\nQ Hk(x\u2217) [Hk(x\u2217)]T k\u2217\n])\n1 Note that this model is just a linearly transformed version of the standard model in GP regression, i.e. yi = f(xi) + \u03b5i. 2 Formally, in GPTD noise is modeled by a second zero-mean GP that is independent from the value GP. See [6] for details.\nwhere n \u00d7 1 vector k(x\u2217) is given by k(x\u2217) := ( k(x\u2217,x1), . . . , k(x \u2217,xn) )T\nand scalar k\u2217 by k\u2217 := k(x\u2217,x\u2217). Conditioning on r, we then obtain\nV (x\u2217) | D, r,x\u2217, \u03b8 \u223c N (\u00b5(x\u2217), \u03c32(x\u2217)) (8)\nwhere\n\u00b5(x\u2217) := k(x\u2217)THTQ\u22121r (9)\n\u03c32(x\u2217) := k\u2217 \u2212 k(x\u2217)THTQ\u22121Hk(x\u2217). (10)\nThus, for any given single state x\u2217, GPTD produces the distribution p(V (x\u2217)|D, r,x\u2217, \u03b8) in Eq. (8) over function values."}, {"heading": "4 Computational considerations", "text": "Regarding its implementation, GPTD for policy evaluation shares the same weakness that GPs have in traditional machine learning tasks: solving Eq. (8) requires the inversion3 of a dense (n \u2212 1) \u00d7 (n \u2212 1) matrix, which when done exactly would require O(n3) operations and is hence infeasible for anything but small-scale problems (say, anything with n < 5000)."}, {"heading": "4.1 Subset of regressors", "text": "In the subset of regressors (SR) approach initially proposed for regularization networks [15,10], one chooses a subset {x\u0303}mi=1 of the data, with m \u226a n, and approximates the covariance for arbitrary x,x\u2032 by taking\nk\u0303(x,x\u2032) = km(x) TK\u22121mmkm(x \u2032). (11)\nHere km(\u00b7) denotes km(\u00b7) := ( k(x\u03031, \u00b7), . . . , k(x\u0303m, \u00b7) )T\n, andKmm is the submatrix [Kmm]ij = k(x\u0303i, x\u0303j) of K. The approximation in Eq. (11) can be motivated for example from the Nystro\u0308m approximation [22]. Let Knm denote the submatrix [Knm]ij = k(xi, x\u0303j) corresponding to the m columns of the data points in the subset. We then have the rank-reduced approximationK \u2248 K\u0303 = KnmK\u22121mmK T nm and k(x) \u2248 k\u0303(x) = KnmK \u22121 mmkm(x). Plugging these into Eq. (8), we obtain for the mean\n\u00b5(x\u2217) \u2248 k\u0303(x\u2217)THT ( HK\u0303HT + \u03c320HH T )\u22121 r\n= km(x \u2217)T\n( GTWG+ \u03c320Kmm )\u22121 GTWr, (12)\nwhere we have defined G := HKnm, W := (HH T)\u22121 and applied the SMW identity4 to show that\nK\u22121mmG T ( GK\u22121mmG T + \u03c320W \u22121 )\u22121 = ( GTWG+ \u03c320Kmm )\u22121 GTW. (13)\n3 For numerical reasons we implement this step using the Cholesky decomposition, which has the same computational complexity. 4 (A+BD\u22121C)\u22121BD\u22121 = A\u22121B(D+CA\u22121B)\u22121\nSimilarly, we obtain for the predictive variance\n\u03c3(x\u2217) \u2248 k\u0303(x\u2217,x\u2217)\u2212 k\u0303(x\u2217)THT ( HK\u0303HT + \u03c320HH T )\u22121 Hk\u0303(x\u2217)\n= \u03c320km(x \u2217)T\n( GTWG+ \u03c320Kmm )\u22121 km(x \u2217). (14)\nDoing this means a huge gain in computational savings: solving the reduced problem in Eq. (12) costs O(m2n) for initialization, requires O(m2) storage and every prediction costs O(m) (or O(m2) if we additionally evaluate the variance). This has to be compared with the complexity of the full problem: O(n3) initialization, O(n2) storage, and O(n) prediction. Thus computational complexity now only depends linearly on n (for constant m).\nNote that the SR-approximation produces a degenerate GP. As a consequence, the predictive variance in Eq. (14) will underestimate the true variance. In particular, it will be near zero when x is far from the subset {x\u0303}mi=1 (which is exactly the opposite of what we want, as the predictive variance should be high for novel inputs). The situation can be remedied by considering the projected process approximation [4,19], which results in the same expression for the mean in Eq. (12), but adds the term\nk(x\u2217,x\u2217)\u2212 km(x \u2217)TK\u22121mmkm(x \u2217) (15)\nto the variance in Eq. (14)"}, {"heading": "4.2 Selecting the subset (unsupervised)", "text": "Selecting the best subset is a combinatorial problem that cannot be solved effeciently. Instead, we try to find a compact subset that summarizes the relevant information by incremental forward selection. In every step of the procedure, we add that element from the set of remaining unselected elements to the active set that performs best with respect to a given specific criterion. In general, we distinguish between supervised and unsupervised approaches, i.e. those that consider the target variable we regress on, and those that do not. Here we focus on the incomplete Cholesky decomposition (ICD) as an unsupervised approach [7,1,2].\nICD aims at reducing at each step the error incurred from approximating the\ncovariance matrix: \u2225 \u2225 \u2225 K\u2212 K\u0303 \u2225 \u2225 \u2225\nF . Note that the ICD of K is the dual equivalent of\nperforming partial Gram-Schmidt on the Mercer-induced feature representation: in every step, we add that element to the active set whose distance from the span of the currently selected elements is largest (in feature space). The procedure is stopped when the residual of remaining (unselected) elements falls below a given threshold, or a given maximum number of allowed elements is exceeded. In [4,8,6] online variants thereof are considered (where instead of repeatedly inspecting all remaining elements only one pass over the dataset is made and every element is examined only once). In general, the number of elements selected by ICD will depend on the effective rank of K (and thus its eigenspectrum)."}, {"heading": "5 Model selection for GPTD", "text": "The major advantage of using GP-based function approximation (in contrast to, say, neural networks or tree-based approaches) is that both \u2019learning\u2019 of the weight vector and specification of the architecture/hyperparameters/basis functions can be handled in a principled and essentially automated way."}, {"heading": "5.1 Optimizing the marginal likelihood", "text": "To determine hyperparameters for GPTD, we consider the marginal likelihood of the process, i.e. the probability of generating the rewards we have observed given the sequence of states and a particular setting of the hyperparameter \u03b8. We then maximize this function (its logarithm) with respect to \u03b8. From Eq. (6) we see that for GPTD we have p(r|D, \u03b8) = N (0,Q). Thus plugging in the definition for a multivariate Gaussian and taking the logarithm, we obtain\nL(\u03b8) = \u2212 1\n2 log detQ\u2212\n1 2 rTQ\u22121r\u2212 n 2 log 2\u03c0. (16)\nOptimizing this function with respect to \u03b8 is a nonconvex problem and we have to resort to iterative gradient-based solvers (such as scaled conjugate gradients, e.g. see [13]). To do this we need to be able to evaluate the gradient of L. The partial derivatives of L with respect to each individual hyperparameter \u03b8i can be obtained in closed form as\n\u2202L \u2202\u03b8i = \u2212 1 2 tr\n(\nQ\u22121 \u2202Q\n\u2202\u03b8i\n)\n+ 1\n2 rTQ\u22121\n\u2202Q \u2202\u03b8i Q\u22121r. (17)\nNote that L automatically incorporates the trade-off between model fit (training error) and model complexity and can thus be regarded as an indicator for generalization capabilities, i.e. how well GPTD will predict the values of states not in its training set. The first term in Eq. (16) measures the complexity of the model, and will be large for \u2019flexible\u2019 and small for \u2019rigid\u2019 models.5 The second term measures the model fit and can shown to be the value of the error function for a penalized least-squares that would (in a frequentist setting) correspond to GPTD.\n5 A property that manifests itself in the eigenvalues of K (since the determinant equals the sum of the eigenvalues). In general, flexible models are achieved by smaller bandwidths in the covariance, meaning that K\u2019s effective rank will be large and its eigenvalues will fall off more slowly. On the other hand, more rigid models are achieved by larger bandwidths, meaning that K\u2019s effective rank will be low and its eigenvalues will fall off more quickly. Note that the effective rank of K is also important for the SR-approximation (see Section 3), since the effectiveness of SR depends on building a low-rank approximation of K spending as few resources as possible."}, {"heading": "5.2 Choosing the covariance", "text": "A common choice for k(\u00b7, \u00b7) is to consider a (positive definite) function parameterized by a small number of scalar parameters, such as the stationary isotropic Gaussian (or squared exponential), which is parameterized by the lengthscale (bandwidth h). In the following we will consider three variants of the form [13,17]:\nk(x,x\u2032) = v0 exp\n{\n\u2212 1\n2 (x\u2212 x\u2032)T\u2126(x\u2212 x\u2032)\n}\n+ b (18)\nwhere hyperparameter v0 > 0 denotes the vertical lengthscale, b > 0 the bias, and symmetric positive semidefinite matrix \u2126 is given by\n\u2013 Variant 1 (isotropic): \u2126 = hI with hyperparameter h > 0. \u2013 Variant 2 (axis-aligned ARD): \u2126 = diag(a1, . . . , aD) with hyperparameters a1, . . . , aD > 0. \u2013 Variant 3(factor analysis): \u2126 = MkM T\nk + diag(a1, . . . , aD) where D \u00d7 k matrix Mk is given by Mk := [m1, . . . ,mk], k < D, and both the entries of Mk, i.e. m11, . . . ,m1D, . . . ,mk1, . . . ,mkD and a1, . . . , aD > 0 are adjustable hyperparameters.6\nThe first variant (see Figure 1) assumes that every coordinate of the input (i.e. state-vector) is equally important for predicting its value. However, in particular for high-dimensional state vectors, this might be too simple: along some dimensions this will produce too much resolution where it will be wasted, along other dimensions this will produce too little resolution where it would otherwise be needed. The second variant is more powerful and includes a different parameter for every coordinate of the state vector, thus assigning a different scale to every state variable. This covariance implements automatic relevance determination (ARD): since the individual scaling factors are automatically adapted from the data via marginal likelihood optimization, they inform us about how relevant each state variable is for predicting the value. A large value of ai means that the i-th state variable is important and even small variations along this coordinate are relevant. A small value of aj means that the j-th state variable is less important and only large variations along this coordinate will impact the prediction (if at all). A value close to zero means that the corresponding coordinate is irrelevant and could be left out (i.e. the value function does not rely on that particular state variable). The benefit of removing irrelevant coordinates is that the complexity of the model will decrease while the fit of the model stays the same: thus likelihood will increase. The third variant first identifies relevant directions in the input space (linear combinations of state variables) and performs a rotation of the coordinate system (the number of relevant directions is specified in advance by k). As in the second variant, different scaling factors are then applied along the rotated axes.\n6 The number of directions k is also determined from model selection: we systematically try different values of k, find the corresponding remaining hyperparameters via"}, {"heading": "5.3 Example: gradient for ARD", "text": "As an example, we will now show how the gradient \u2207\u03b8L of Eq. (16) is calculated for the ARD covariance. Note that since all hyperparameters in this model, i.e. {v0, b, \u03c320 , a1, . . . , aD}, must be positive, it is more convenient to consider the hyperparameter vector \u03b8 in log space: \u03b8 = (\nlog v0, log b, log\u03c3 2 0 , log a1, . . . , log aD\n)\n. We start by establishing some useful identities: for any n\u00d7 n matrix A we have\n[HAHT]ij = aij \u2212 \u03b3iai+1,j \u2212 \u03b3jai,j+1 + \u03b3i\u03b3jai+1,j+1.\nFurthermore, we have\n[HHT]ij =\n\n \n \n1 + \u03b32i , i = j \u2212\u03b3i , i = j \u2212 1 or i = j + 1\n0 , otherwise\nNow writeK asK = v0C+b1n,n, where [C]ij = exp { \u22120.5 \u2211D d=1 ad ( x (i) d \u2212 x (j) d )2 } and 1n,n is the n\u00d7 n matrix of all ones. Computing the partial derivative of K, we then obtain\n\u2202K \u2202v0 = C, \u2202K \u2202b = 1n,n\n[\n\u2202K\n\u2202a\u03bd\n]\nij\n= \u2212 1\n2 v0cij\n(\nx(i)\u03bd \u2212 x (j) \u03bd )2 , \u03bd = 1 . . .D\nNext, we will compute the partial derivatives of Q = (HKHT+\u03c320HH T), giving for b:\n\u2202Q\n\u2202 log b = b\n\u2202Q\n\u2202b = bH\n[\n\u2202K\n\u2202b\n]\nHT = bH1n,nH T\n\u21d2\n[\n\u2202Q\n\u2202 log b\n]\nij\n= b(1\u2212 \u03b3i \u2212 \u03b3j + \u03b3i\u03b3j).\nscg-based likelihood optimization and compare the final scores (likelihood) of the resulting models.\nFor v0 we have\n\u2202Q\n\u2202 log v0 = v0\n\u2202Q \u2202v0 = v0H\n[\n\u2202K\n\u2202v0\n]\nHT = v0HCH T\n\u21d2\n[\n\u2202Q\n\u2202 log v0\n]\nij\n= v0(cij \u2212 \u03b3ici+1,j \u2212 \u03b3jci,j+1 + \u03b3i\u03b3jci+1,j+1).\nFor \u03c320 we have\n\u2202Q\n\u2202 log \u03c320 = \u03c320\n\u2202Q \u2202\u03c320 = \u03c320 \u2202 \u2202\u03c320 [\u03c320HH T] = \u03c320HH T\n\u21d2\n[\n\u2202Q\n\u2202 log \u03c320\n]\nij\n=\n\n \n \n\u03c320(1 + \u03b3 2 i ) , i = j \u2212\u03c320\u03b3i , i = j \u2212 1 or i = j + 1 0 , otherwise\nFinally, for each of the a\u03bd , \u03bd = 1, . . . , D we get\n\u2202Q\n\u2202 log a\u03bd = a\u03bd\n\u2202Q \u2202a\u03bd = a\u03bdH\n[\n\u2202K\n\u2202a\u03bd\n]\nHT\n\u21d2\n[\n\u2202Q\n\u2202 log a\u03bd\n]\nij\n= \u2212 1\n2 a\u03bdv0(cijd\n\u03bd ij \u2212 \u03b3ici+1,jd \u03bd i+1,j\n\u2212 \u03b3jci,j+1d \u03bd i,j+1 + \u03b3i\u03b3jci+1,j+1d \u03bd i+1,j+1)\nwhere we have defined d\u03bdij := ( x (i) \u03bd \u2212 x (j) \u03bd )2 . Thus, with w := Q\u22121r we have for Eq. (17)\ntr\n(\nQ\u22121 \u2202Q\n\u2202\u03b8\u03bd\n) = n\u22121 \u2211\ni=1\nn\u22121 \u2211\nj=1\n[ Q\u22121 ]\nij\n[\n\u2202Q\n\u2202\u03b8\u03bd\n]\nji\nwT \u2202Q\n\u2202\u03b8\u03bd w =\nn\u22121 \u2211\ni=1\nn\u22121 \u2211\nj=1\n[w]i[w]j\n[\n\u2202Q\n\u2202\u03b8\u03bd\n]\nij\nwhich can be used to calculate the partial derivates with computational complexity O(n2) each (except for \u03c320 , where the matrix of derivatives is tridiagonal)."}, {"heading": "6 Experiments", "text": "This section demonstrates that our proposed model selection can be used to solve the approximate policy evaluation problem in a completely automated way \u2013 without any manual tweaking of hyperparameters. We will also show some of the additional benefits of model selection, which are improved accuracy and reduced complexity: because we automatically set the hyperparameters we can use more sophisticated covariance functions (see Section 5.2) that depend on a\nlarger number7 of hyperparameters, thus better fit the regularities of a particular dataset, and therefore do not waste unnecessary resources on irrelevant aspects of the state-vector. The latter aspect is particularly interesting for computational reasons (see Section 4) and becomes important in large-scale applications.\n6.1 Pendulum swing-up task\nFirst, we consider the pendulum swing-up task, a common benchmark in RL. The goal is to swing up an underpowered pendulum and balance it around the inverted upright position (here formulated as an episodic task). More details and the equations of motion can be found in e.g. [5]. Since GPTD only solves (approximate) policy evaluation, to test our model selection approach we chose to generate a sample trajectory under the optimal policy (obtained from fitted value iteration). We generated a sequence of 1000 state-transitions under this policy (which corresponds to about 25 completed episodes) and applied GPTD for the three choices of covariance: isotropic (I), axis-aligned ARD (II), and factor analyis (III). In each case, the best setting of hyperparameters was found from running8 scaled conjugate gradients on Eq. (16), giving\nI: v0 = 18.19 \u03c3 2 0 = 0.05 b = 0.11 h = 7.48 II: v0 = 15.95 \u03c3 2 0 = 0.05 b = 0.10 a1 = 3.62 a2 = 6.63 III: v0 = 10.82 \u03c3 2 0 = 0.08 b = 0.10 s1 = 13.91 s2 = 0.36 u1 = [ 0.58 0.81 ] u2 = [ \u22120.81 0.58 ]\n(the last ones given in terms of the eigendecomposition of\u2126). Figure 3 shows the results: all three produce an adequate representation of the true value function shown in Figure 2 in and near the states visited in the trajectory (MSE in states of the sample trajectory: (I) 0.27, (II) 0.24, and (III) 0.26), but differ once they start predicting values of states not in the training data (MSE for states on a 50 \u00d7 50 grid: (I) 46.36, (II) 48.89, and (III) 12.24). Despite having a slightly higher error on the known training data, (III) substantially outperforms the other\n7 Setting these hyperparameters by hand would require even more trial and error; therefore, these covariances are seldom employed without model selection. 8 We used the full data set for model selection, to avoid the complexities involved with subset-based likelihood approximation, e.g. see [20]. In our implementation, model selection for all 1000 data points took about 15-30 secs on a 1.5GHz PC.\nmodels when it comes to predicting the values of new states. With respect to model selection, (III) also has the highest likelihood. Note that (III) chooses one dominant direction (u1 = [ 0.58 0.81 ] ) to which it assigns high relevance (s1 = 13.91); the remainder (u2 = [ \u22120.81 0.58 ]\n) has only little impact (s2 = 0.36). Taking a closer look at Figure 2, we see that indeed the value function varies more strongly along the diagonal direction lower left to upper right, whereas it varies only slowly along the opposite diagonal upper left to lower right. For (II), relevance can only be assigned along the \u03d5 and \u03d5\u0307 coordinates (state-variables), which in this case gives us no particular benefit; and (I) is not at all able to assign different importance to different state variables.\nAdditional insight is gained by looking at the eigenspectrum of K. Figure 4 (left) shows that (I)\u2019s eigenvalues decrease the slowest, whereas (III)\u2019s decrease the fastest. This has two consequences. First, the eigenspectrum is intimately related with complexity and generalization capabilities (see Eq. (16)) and thus helps explain why (III) delivers better prediction performance. Second, the eigenspectrum also indicates the effective rank ofK and strongly impacts our ability to build an efficient low-rank approximation ofK using as small a subset as possible (see Section 4). A small subset in turn is important for computational efficiency because its size is the dominant factor when we employ the SR-approximation: both for batch and online learning the operation count depends quadratically on the size of the subset (and only linear on the number of datapoints). Keeping this size as small as possible without losing predictive performance is essential. Figure 4 (center and right) shows that in this regard (III) performs best and (I) worst: for example, if we were to approximate K using SR-approximation with ICD selection at a tolerance level of 10\u22121, out of our 1000 samples (I) would choose \u223c 175, (II) would chose \u223c 140, and (III) would choose \u223c 80 elements."}, {"heading": "6.2 A 2D gridworld with 1 latent dimension", "text": "To illustrate in more detail how our approach handles irrelevant state variables, we use a specifically designed 2D gridworld with 11\u00d711 states. Every step entails a reward of \u22121 except when being in a state with x = 6, which starts a new episode (teleports to a new random state with zero reward). We consider the policy that moves left when x > 6 and right when x < 6. In addition, every time we move left or right we will also move randomly up or down (with 50% each). The corresponding value function is shown in Figure 5 (left). We generated 500 transitions and applied GPTD with covariance (I) and (II) with automatic model selection resulting in9\nHyperparameters \u03b8 Complexity Data fit L (smaller is better)\n(I) h = 2.89 -2378.2 54.78 -2323.4 (II) a1 = 3.53 a2 = 10\n\u22125 -2772.7 13.84 -2758.8 (II) without y a1 = 3.53 a2 = 0 -2790.7 13.84 -2776.8\n9 Here we do not include results for (III) which operates on linear combinations of states and in this scenario would have to find a direction that is perfectly aligned with the x-axis (which is more difficult).\nF\n, given the size of the subset.\nAs can be seen from Figure 5 (center and right), both obtain a very reasonable approximation. However, (II) automatically detects that the y-coordinate of the state is irrelevant and thus assigns a very small weight to it (a2 < 10\n\u22125). With a uniform lengthscale, (I) is unable to do that and has to put equal weight on both state variables. As a consequence, its estimate is less exact and more wiggly (MSE: (I) 0.030, and (II) 0.019). Additional insight can be gained by looking at the likelihood L of the models (cf. Eq. (16)). Here we see that (II) has lower complexity (cf. eigenspectrum of Q in Figure 6), fits the data better and thus has a higher combined likelihood (note that the values in the table show the negative log likelihood which we minimize). Moreover, if we completely remove the y state variable (setting a2 := 0), the eigenspectrum of Q decreases more rapidly; thus (II) without y has an even lower complexity while still having the same fit. This indicates that state component y can be safely ignored in this task/domain. In addition, as was mentioned before, the lower effective rank of K will also allow us to make more efficient use of SR-based approximations."}, {"heading": "7 Future work", "text": "It should be noted that the proposed framework for automatic feature generation and model selection should primarily be thought of as a practical tool: despite offering a principled solution to an important problem in RL, ultimately it does not come with any theoretical guarantees (due to some modeling assumptions from GPTD and the way the hyperparameters are obtained). For most practical applications this might be less of an issue, but in general care has to be taken.\nThe framework can be easily extended to perform policy evaluation over the joint state-action space to learn the model-free Q-function (instead of the V-function): we just have to choose a different covariance function, taking for example the product k([x, a], [x\u2032, a\u2032]) = k(x,x\u2032)k(a, a\u2032) with k(a, a\u2032) = \u03b4a,a\u2032 for problems with a small number of discrete actions [8]. This opens the way for\nmodel-free policy improvement and thus optimal control via approximate policy iteration. Our next step then is to apply this approach to real-world highdimensional control tasks, both in batch settings and hybrid batch/online settings; in the latter case exploiting the gain in computational efficiency obtained through model selection to improve [6]."}, {"heading": "Acknowledgments", "text": "This work has taken place in the Learning Agents Research Group (LARG) at the Artificial Intelligence Laboratory, The University of Texas at Austin. LARG research is supported in part by grants from the NSF (CNS-0615104), DARPA (FA8750-05-2-0283 and FA8650-08-C-7812), the Federal Highway Administration (DTFH61-07-H-00030), and General Motors."}], "references": [{"title": "Kernel independent component analysis", "author": ["F.R. Bach", "M.I. Jordan"], "venue": "JMLR, 3:1\u201348,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2002}, {"title": "Predictive low-rank decomposition for kernel methods", "author": ["F.R. Bach", "M.I. Jordan"], "venue": "In Proc. of ICML 22,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2005}, {"title": "Dynamic programming and Optimal Control, Vol", "author": ["D. Bertsekas"], "venue": "II. Athena Scientific,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2007}, {"title": "Sparse online Gaussian processes", "author": ["L. Csat\u00f3", "M. Opper"], "venue": "Neural Computation, 14(3):641\u2013668,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2002}, {"title": "Gaussian process dynamic programming", "author": ["M.P. Deisenroth", "C.E. Rasmussen", "J. Peters"], "venue": "Neurocomputing, 72(7-9):1508\u20131524,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2009}, {"title": "Reinforcement learning with Gaussian processes", "author": ["Y. Engel", "S. Mannor", "R. Meir"], "venue": "In Proc. of ICML 22,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2005}, {"title": "Efficient SVM training using low-rank kernel representation", "author": ["S. Fine", "K. Scheinberg"], "venue": "JMLR, 2:243\u2013264,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2001}, {"title": "Learning robocup-keepaway with kernels", "author": ["T. Jung", "D. Polani"], "venue": "JMLR: Workshop and Conference Proceedings (Gaussian Processes in Practice), 1:33\u201357,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "Automatic basis function construction for approximate dynamic programming and reinforcement learning", "author": ["P. Keller", "S. Mannor", "D. Precup"], "venue": "In Proc. of ICML 23,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2006}, {"title": "Hybrid adaptive splines", "author": ["Z. Luo", "G. Wahba"], "venue": "J. Amer. Statist. Assoc., 92:107\u2013 116,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1997}, {"title": "Proto-value functions: A Laplacian framework for learning representation and control in Markov decision processes", "author": ["S. Mahadevan", "M. Maggioni"], "venue": "JMLR, 8:2169\u2013 2231,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2007}, {"title": "Basis function adaptation in temporal difference reinforcement learning", "author": ["N. Menache", "N. Shimkin", "S. Mannor"], "venue": "Annals of Operations Research, 134:215\u2013238,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2005}, {"title": "Netlab : Algorithms for Pattern Recognition", "author": ["I.T. Nabney"], "venue": "Springer,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2002}, {"title": "Analyzing feature generation for value-function approximation", "author": ["R. Parr", "C. Painter-Wakefield", "L. Li", "M. Littman"], "venue": "In Proc. of ICML 24,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2007}, {"title": "Networks for approximation and learning", "author": ["T. Poggio", "F. Girosi"], "venue": "Proceedings of the IEEE, 78(9):1481\u20131497,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1990}, {"title": "Gaussian processes in reinforcement learning", "author": ["C.E. Rasmussen", "M. Kuss"], "venue": "In Advances in Neural Information Processing Systems 16, pages 751\u2013759. MIT Press,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2004}, {"title": "Gaussian Processes for Machine Learning", "author": ["C.E. Rasmussen", "C.K.I. Williams"], "venue": "MIT Press,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Online kernel selection for Bayesian reinforcement learning", "author": ["J. Reisinger", "P. Stone", "R. Miikkulainen"], "venue": "In Proc. of ICML 25,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "Fast forward selection to speed up sparse Gaussian process regression", "author": ["M. Seeger", "C.K.I. Williams", "N. Lawrence"], "venue": "In Proc. of 9th Int\u2019l Workshhop on AI and Statistics. Soc. for AI and Statistics,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2003}, {"title": "Sparse Gaussian processes using pseudo-inputs", "author": ["E. Snelson", "Z. Ghahramani"], "venue": "In NIPS 18,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}, {"title": "Reinforcement Learning: An Introduction", "author": ["R. Sutton", "A. Barto"], "venue": "MIT Press,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1998}, {"title": "Using the Nystr\u00f6m method to speed up kernel machines", "author": ["C. Williams", "M. Seeger"], "venue": "In NIPS 13, pages 682\u2013688,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2001}], "referenceMentions": [{"referenceID": 20, "context": "see [21,3].", "startOffset": 4, "endOffset": 10}, {"referenceID": 2, "context": "see [21,3].", "startOffset": 4, "endOffset": 10}, {"referenceID": 5, "context": "Recent work in applying nonparametric function approximation to RL, such as Gaussian processes (GP) [6,16,18,5], or equivalently, regularization networks [8], is a very promising step in this direction.", "startOffset": 100, "endOffset": 111}, {"referenceID": 15, "context": "Recent work in applying nonparametric function approximation to RL, such as Gaussian processes (GP) [6,16,18,5], or equivalently, regularization networks [8], is a very promising step in this direction.", "startOffset": 100, "endOffset": 111}, {"referenceID": 17, "context": "Recent work in applying nonparametric function approximation to RL, such as Gaussian processes (GP) [6,16,18,5], or equivalently, regularization networks [8], is a very promising step in this direction.", "startOffset": 100, "endOffset": 111}, {"referenceID": 4, "context": "Recent work in applying nonparametric function approximation to RL, such as Gaussian processes (GP) [6,16,18,5], or equivalently, regularization networks [8], is a very promising step in this direction.", "startOffset": 100, "endOffset": 111}, {"referenceID": 7, "context": "Recent work in applying nonparametric function approximation to RL, such as Gaussian processes (GP) [6,16,18,5], or equivalently, regularization networks [8], is a very promising step in this direction.", "startOffset": 154, "endOffset": 157}, {"referenceID": 5, "context": "Here, we will focus on the Bayesian setting, and adapt marginal likelihood optimization for the GP-based approximate policy evaluation method GPTD, introduced without model selection in [6].", "startOffset": 186, "endOffset": 189}, {"referenceID": 17, "context": "Despite its many promises, previous work with GPs in RL rarely explores the benefits of model selection: in [18], a variant of stochastic search was used to determine hyperparameters of the covariance for GPTD using as score function the online performance of an agent.", "startOffset": 108, "endOffset": 112}, {"referenceID": 15, "context": "In [16], standard GPs with marginal likelihood based model selection were employed; however, since their approach was based on fitted value iteration, the task of value function approximation was reduced to ordinary regression.", "startOffset": 3, "endOffset": 7}, {"referenceID": 11, "context": "Conceptually closely related to our work is the approach described in [12], which adapts the hyperparameters of RBFbasis functions (both their location and lengthscales) using either gradient descent or the cross-entropy method on the Bellman error.", "startOffset": 70, "endOffset": 74}, {"referenceID": 8, "context": "Other alternative approaches do not rely on predefined basis functions: The method in [9] is an incremental approach that uses dimensionality reduction and state aggregation to create new basis functions such that for every step the remaining Bellman error for a trajectory of states is successively reduced.", "startOffset": 86, "endOffset": 89}, {"referenceID": 13, "context": "A related approach is given in [14] which incrementally constructs an orthogonal basis for the Bellman error.", "startOffset": 31, "endOffset": 35}, {"referenceID": 10, "context": "A graph-based unsupervised approach is presented in [11], which derives basis functions from the eigenvectors of the graph Laplacian induced from the underlying MDP.", "startOffset": 52, "endOffset": 56}, {"referenceID": 16, "context": "In this section we briefly summarize how GPs [17] can be used for approximate policy evaluation; here we will follow the GPTD formulation of [6].", "startOffset": 45, "endOffset": 49}, {"referenceID": 5, "context": "In this section we briefly summarize how GPs [17] can be used for approximate policy evaluation; here we will follow the GPTD formulation of [6].", "startOffset": 141, "endOffset": 144}, {"referenceID": 5, "context": "If the environment is stochastic, the noise model \u03a3 = \u03c3 0HH T is more appropriate, see [6] for more detailed explanations.", "startOffset": 87, "endOffset": 90}, {"referenceID": 5, "context": "See [6] for details.", "startOffset": 4, "endOffset": 7}, {"referenceID": 14, "context": "1 Subset of regressors In the subset of regressors (SR) approach initially proposed for regularization networks [15,10], one chooses a subset {x\u0303}i=1 of the data, with m \u226a n, and approximates the covariance for arbitrary x,x by taking k\u0303(x,x) = km(x) K mmkm(x ).", "startOffset": 112, "endOffset": 119}, {"referenceID": 9, "context": "1 Subset of regressors In the subset of regressors (SR) approach initially proposed for regularization networks [15,10], one chooses a subset {x\u0303}i=1 of the data, with m \u226a n, and approximates the covariance for arbitrary x,x by taking k\u0303(x,x) = km(x) K mmkm(x ).", "startOffset": 112, "endOffset": 119}, {"referenceID": 21, "context": "(11) can be motivated for example from the Nystr\u00f6m approximation [22].", "startOffset": 65, "endOffset": 69}, {"referenceID": 3, "context": "The situation can be remedied by considering the projected process approximation [4,19], which results in the same expression for the mean in Eq.", "startOffset": 81, "endOffset": 87}, {"referenceID": 18, "context": "The situation can be remedied by considering the projected process approximation [4,19], which results in the same expression for the mean in Eq.", "startOffset": 81, "endOffset": 87}, {"referenceID": 6, "context": "Here we focus on the incomplete Cholesky decomposition (ICD) as an unsupervised approach [7,1,2].", "startOffset": 89, "endOffset": 96}, {"referenceID": 0, "context": "Here we focus on the incomplete Cholesky decomposition (ICD) as an unsupervised approach [7,1,2].", "startOffset": 89, "endOffset": 96}, {"referenceID": 1, "context": "Here we focus on the incomplete Cholesky decomposition (ICD) as an unsupervised approach [7,1,2].", "startOffset": 89, "endOffset": 96}, {"referenceID": 3, "context": "In [4,8,6] online variants thereof are considered (where instead of repeatedly inspecting all remaining elements only one pass over the dataset is made and every element is examined only once).", "startOffset": 3, "endOffset": 10}, {"referenceID": 7, "context": "In [4,8,6] online variants thereof are considered (where instead of repeatedly inspecting all remaining elements only one pass over the dataset is made and every element is examined only once).", "startOffset": 3, "endOffset": 10}, {"referenceID": 5, "context": "In [4,8,6] online variants thereof are considered (where instead of repeatedly inspecting all remaining elements only one pass over the dataset is made and every element is examined only once).", "startOffset": 3, "endOffset": 10}, {"referenceID": 12, "context": "see [13]).", "startOffset": 4, "endOffset": 8}, {"referenceID": 12, "context": "In the following we will consider three variants of the form [13,17]:", "startOffset": 61, "endOffset": 68}, {"referenceID": 16, "context": "In the following we will consider three variants of the form [13,17]:", "startOffset": 61, "endOffset": 68}, {"referenceID": 4, "context": "[5].", "startOffset": 0, "endOffset": 3}, {"referenceID": 19, "context": "see [20].", "startOffset": 4, "endOffset": 8}, {"referenceID": 7, "context": "The framework can be easily extended to perform policy evaluation over the joint state-action space to learn the model-free Q-function (instead of the V-function): we just have to choose a different covariance function, taking for example the product k([x, a], [x, a]) = k(x,x)k(a, a) with k(a, a) = \u03b4a,a\u2032 for problems with a small number of discrete actions [8].", "startOffset": 359, "endOffset": 362}, {"referenceID": 5, "context": "Our next step then is to apply this approach to real-world highdimensional control tasks, both in batch settings and hybrid batch/online settings; in the latter case exploiting the gain in computational efficiency obtained through model selection to improve [6].", "startOffset": 258, "endOffset": 261}], "year": 2012, "abstractText": "Feature selection in reinforcement learning (RL), i.e. choosing basis functions such that useful approximations of the unkown value function can be obtained, is one of the main challenges in scaling RL to real-world applications. Here we consider the Gaussian process based framework GPTD for approximate policy evaluation, and propose feature selection through marginal likelihood optimization of the associated hyperparameters. Our approach has two appealing benefits: (1) given just sample transitions, we can solve the policy evaluation problem fully automatically (without looking at the learning task, and, in theory, independent of the dimensionality of the state space), and (2) model selection allows us to consider more sophisticated kernels, which in turn enable us to identify relevant subspaces and eliminate irrelevant state variables such that we can achieve substantial computational savings and improved prediction performance.", "creator": "LaTeX with hyperref package"}}}