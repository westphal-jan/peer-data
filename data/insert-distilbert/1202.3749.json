{"id": "1202.3749", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-Feb-2012", "title": "Compact Mathematical Programs For DEC-MDPs With Structured Agent Interactions", "abstract": "to deal with the prohibitive complexity of calculating policies in decentralized mdps, researchers have proposed models worldwide that exploit freely structured agent interactions. settings where naturally most agent actions are independent except for few actions that affect the transitions and / or rewards of other agents can be freely modeled using event - driven interactions with complex rewards ( edi - cr ). finding like the optimal joint policy can be formulated as an optimization problem. however, existing formulations elsewhere are too verbose and / nor or lack optimality guarantees. we propose a compact mixed integer linear program formulation of edi - cr instances. the key insight is indeed that most action sequences of particular a group consisted of agents have the same effect on a given agent. this allows us to treat these sequences similarly and use fewer variables. experiments show that our formulation is more compact and leads to faster solution times and better solutions than existing formulations.", "histories": [["v1", "Tue, 14 Feb 2012 16:41:17 GMT  (191kb)", "http://arxiv.org/abs/1202.3749v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["hala mostafa", "victor lesser"], "accepted": false, "id": "1202.3749"}, "pdf": {"name": "1202.3749.pdf", "metadata": {"source": "CRF", "title": "Compact Mathematical Programs For DEC-MDPs With Structured Agent Interactions", "authors": ["Hala Mostafa", "Victor Lesser"], "emails": ["hmostafa@bbn.com", "lesser@cs.umass.edu"], "sections": [{"heading": null, "text": "To deal with the prohibitive complexity of calculating policies in Decentralized MDPs, researchers have proposed models that exploit structured agent interactions. Settings where most agent actions are independent except for few actions that affect the transitions and/or rewards of other agents can be modeled using Event-Driven Interactions with Complex Rewards (EDI-CR). Finding the optimal joint policy can be formulated as an optimization problem. However, existing formulations are too verbose and/or lack optimality guarantees. We propose a compact Mixed Integer Linear Program formulation of EDI-CR instances. The key insight is that most action sequences of a group of agents have the same effect on a given agent. This allows us to treat these sequences similarly and use fewer variables. Experiments show that our formulation is more compact and leads to faster solution times and better solutions than existing formulations."}, {"heading": "1 Introduction", "text": "Consider a robotic team dealing with a building on fire. One agent is in charge of putting out the fire, another locates and evacuates survivors and a third delivers first aid to the injured. Most of an agent\u2019s actions affect only itself (e.g. the first agent\u2019s exact approach to fire fighting and the kind of extinguisher it uses mainly affect its own progress). However, the decision-making problems of these agents are not completely independent. For example, the fire-fighting agent\u2019s decision of when to secure a given area affects how easy it will be for the rescue agent to locate survivors in that area.\n\u2217This work was done while the first author was a Ph.D. student at University of Massachusetts, Amherst.\nDecentralized Markov Decision Processes (DECMDPs) have been widely used to model situations like the above. However, DEC-MDPs obscure the structured agent interaction, thus missing the representational and computational savings that can be obtained due to the loose coupling among the agents.\nSeveral models have been proposed in an attempt to exploit structured interactions, with each model catering to a different kind of structure [11, 13, 12]. Settings like the above example, where agents are largely independent except for few actions that affect the transitions and/or rewards of other agents, can be modeled using Event-Driven Interactions with Complex Rewards (EDI-CR). EDI-CR is much more compact than DEC-MDPs [9] without sacrificing expressive power.\nFinding the optimal policy in decision-theoretic models can be formulated as a mathematical program. In this paper, we propose a compact formulation of EDICR as a Mixed Integer Linear Program (MILP). Starting with an existing non-linear formulation of general DEC-MDPs, we introduce new variables to linearize the program, but exploit structured interactions to minimize the number of variables introduced. We develop an exact formulation for the case of 2 agents and a relaxed formulation for the case of 3 or more agents.\nThis paper is organized as follows: the next section contains background material. Sections 3 and 4 present our 2- and 3-or-more-agents MILP formulations. Section 5 demonstrates the size and computational savings we obtain. Related work is discussed in Section 6, followed by conclusions and future work."}, {"heading": "2 Background", "text": ""}, {"heading": "2.1 EDI-CR", "text": "Event-Driven Interactions with Complex Rewards (EDI-CR) is a model developed for problems with structured transition and reward interactions [9]. It builds on the intuition that when agents are largely\nindependent of each other, it is more natural to describe each agent\u2019s decision problem separately and list the interactions that tie these processes together. Formally, an EDI-CR instance with n agents is a tuple < A, S,A, P1..n, R1..n, \u03c1, \u03c4, T > where: \u2022 A is the set of n agents \u2022 Si is agent i\u2019s local state space \u2022 Ai is agent i\u2019s local action space \u2022 Pi : Si \u00d7 Ai \u00d7 Si \u2192 [0, 1] is i\u2019s local transition\nfunction \u2022 Ri : Si \u00d7Ai \u00d7 Si \u2192 R is i\u2019s local reward function \u2022 \u03c1 = {<(sk1 , ak1), ..., (skm , akm), rk>k=1..|\u03c1|} is the\nset of reward interactions. Each interaction involves any subset of agents and lists rk, the reward/penalty of the team when the agents take the specified actions in the specified states. \u2022 \u03c4 = {<(sk1 , ak1), ..., (skm , akm), pk>k=1..|\u03c4 |} is the set of transition interactions. The kth entry specifies the new transition probability pk of the stateaction pair of the affected agent km when agents k1 to km\u22121 do the specified state-action pairs before km makes its transition.\n\u2022 T is the time horizon of the problem Individual states, actions, transitions and rewards describe each agent\u2019s decision process, while \u03c1 and \u03c4 capture the interactions among them. EDI-CR is as expressive as DEC-MDPs with local observability [9]."}, {"heading": "2.2 Sequence form policy representation", "text": "We use a policy representation that was first suggested by Koller et. al [7] for self-interested agents but has also been used for cooperative agents [3]. In game trees, the idea is that a policy can be characterized by the probability distribution it induces over the leaves of the tree. If two policies induce the same distribution, then they result in the same reward.\nFor models with local observability, a sequence (or history) of agent i, s1.a1..st.at, consists of i\u2019s actions and local states. A history containing T (time horizon) actions is a terminal history. For agent i, the set of all histories is denoted by Hi, terminal histories by Zi, and non-terminal histories by Ni. A joint history h \u2208 H is a tuple containing one history per agent. The realization weight of a history s1.a1..st.at under a policy is the probability that the policy assigns to taking actions a1..t given that states s1..t are encountered. A history\u2019s realization weight does not include chance outcome probabilities, so it can only be 0 or 1. The vector of all realization weights will be denoted as x and the weight of history hi by x(hi).\nA pure policy deterministically chooses one action at each decision making point. In cooperative settings\nthere is at least one optimal pure joint policy, so we restrict our attention to pure policies. But even a pure policy will have multiple terminal histories with nonzero weights, because it must specify an action at each state reachable under the policy. The set of i\u2019s terminal histories with weight 1 is called the policy\u2019s support set, \u03c3i, and its size is the support size \u2016\u03c3i\u2016. In what follows, the agents are i, j and k, g is an arbitrary agent, and the subscript \u2212g indicates a quantity belonging to all agents but g."}, {"heading": "2.3 Existing Mathematical Formulations", "text": "The formulation of DEC-MDP with local observability as a Non-Linear Program (NLP) is given in Table 1. In the objective function, R(h) = \u03b2(h)r(h) is the expected reward of terminal joint history h, where \u03b2(h) is the probability of encountering the joint states in h given the actions in h and r(h) is the sum of rewards of states and actions along the history. The constraints in the NLP are called policy constraints and guarantee that a solution to the NLP represents a legal policy where the sum of an agent\u2019s action probabilities in any state is 1. The first set of constraints ensures the sum of action probabilities at the start state is 1, while the second set ensures that the realization weights of a history\u2019s extensions add up to that history\u2019s weight.\nThe problem with the NLP formulation is that it results in a non-concave objective function for which no methods guarantee finding a globally optimal solution.\nAras and Dutech [3] developed a formulation for DECPOMDPs as a MILP, thereby guaranteeing that a locally optimal solution is also globally optimal. We modify their formulation for the case of DEC-MDP with local observability. For ease of explanation, Table 2 is for the case with only 2 agents i and j. Because the difficulty of solving a MILP increases with the number of integer variables, Aras only restricts weights of terminal histories to be integer. The constraints force the other variables to be integers as well.\nTo linearize the objective function, Aras introduces a compound variable zhi,hj for each pair of terminal his-\ntories. The variable is related to the existing x variables by the identity zhi,hj = x(hi)x(hj).\nTo enforce the identity by linear constraints, Aras uses combinatorics (knowing \u2016\u03c3i\u2016 and \u2016\u03c3j\u2016) and treats the z variables as counters. Constraint (1) guarantees that if hg is part of some agent g\u2019s support set (x(h) = 1), enough compound variables involving hg are set to 1, otherwise all compound variables involving hg should be 0. Constraint (2) limits the number of compound variables that can be simultaneously set to 1."}, {"heading": "3 Formulation of 2-agent EDI-CR", "text": ""}, {"heading": "3.1 Binning histories", "text": "For the 2-agent case, the NLP in Table 1 is a Quadratic Program (QP) whose objective function has the form xTQx where x = [xi, xj ] and Q is the reward matrix. Q(hi, hj) = R(hi, hj) if hi and hj are terminal histories, and is 0 otherwise. The MILP in Table 2 \u201cflattens\u201d this matrix, multiplying each matrix entry by a compound variable created for that entry. This approach makes sense for DEC-MDPs, because agents\u2019 decision processes are tightly coupled and the rewards/transitions of one agent strongly depend on the actions taken by another. For a given history hi, R(hi, hj) can vary widely depending on hj , and a given row or column in Q contains many distinct values, thus justifying the need for a variable per entry in Q.\nThe situation can be very different in the presence of structured interactions. An agent is only affected by a small subset of actions of another agent. So for a given hi, the rewards and transition along hi do not depend on the exact actions in the history of another agent. For example, suppose \u03c1 says that agents i and j get a bonus of 10 if they do actions a1 and a5, respectively, at any point in time, and \u03c4 says that action a3 of agent j affects the transition probability of a7 of i. Now suppose history hi \u2208 Zi involves doing action a1 at time 4 and a7 at time 6. In this case, all histories hj \u2208 Zj that involve doing a3 before time 6 and a5\nany time will have the same effect on the transitions and rewards of hi.\nBecause in EDI-CR agents have their local reward functions, we can express Q as Qi + Qj . Note that this does not assume that rewards are independent; each entry in these matrices can depend on the histories of both agents. The rows (resp. columns) in Qi (resp. Qj) will contain many duplicate entries, reflecting the fact that an agent is oblivious to many details of the other agent\u2019s history.\nThe main idea in our formulation is that for a history hg, we group all histories of the other agent that have the same effect on the transitions and rewards in hg into a single bin . For each history hg of some agent g, the set of bins it induces, Bhg , is a partition over the set of terminal histories of the other agent.\nInstead of creating a variable for every pair of terminal histories, we introduce a single variable zhg,b for every history hg and every bin b \u2208 Bhg associated with it. In other words, we create a variable for each distinct entry in Qi and Qj . Because structured interaction results in many duplicate entries, binning can significantly reduce the number of compound variables we introduce. Our MILP for EDI-CR is given in Table 3.\nIn the objective function, we fold into Rg(hg, b) those quantities of hg that are oblivious to which history in b is played, namely hg\u2019s transition probabilities and rewards. We therefore have Rg(hg, b) = rg(hg|b)\u03b2(hg|b). The factors on the right can be calculated using any history h\u2212g \u2208 b\nrg(hg|b) = T\u22121\u2211 t=1 Rg(st, at, st+1) + r\u03c1(hg, h\u2212g)/2\nwhere r\u03c1(h, hj) represents rewards (if any) that depend on actions of both agents, as specified in \u03c1. Dividing by 2 avoids double counting reward interactions. The transition probability is given by\n\u03b2(h|b) = T\u22121\u220f t=1 P\u03c4 (st+1|st, at, {a\u20321..a\u2032t})\nP\u03c4 depends on the local transition function Pg and, for transitions involved in \u03c4 , actions in h\u2212g done up to time t, {a\u20321..a\u2032t}. We fold into zhg,b quantities that depend on the particular h\u2212g in the bin, namely the transition probabilities along h\u2212g, given history hg, \u03b2(h\u2212g|hg). The identity defining a compound variable is therefore\nzhg,b = x(hg) \u2211\nh\u2212g\u2208b \u03b2(h\u2212g|hg)x(h\u2212g) (3)\nzhg,b is the probability that g plays hg, multiplied by that of the other agent playing a history in b.\nThe effect of the number of interactions on the size of the formulation is clear. As the number of interactions increases, we need more bins (thus more compound variables), since each bin represents a unique way in which an agent affects another. In the extreme case of a general DEC-MDP, an agent\u2019s history needs a separate bin for each of the other\u2019s histories, essentially creating a compound variable for every pair of histories as in the DEC-MDP MILP."}, {"heading": "3.2 Enforcing the identity", "text": "We need to enforce identity (3) by linear constraints. This is more challenging than in the DEC-MDP case where the binary nature of the compound variables allows the use of combinatorics to devise the constraints. In our formulation, the compound variables are not binary, and we must resort to other properties and relations to derive constraints equivalent to the identity.\nSumming both sides of (3) over all bins of hg gives \u2211\nb\u2208Bhg zhg,b = x(hg)\n\u2211\nb\u2208Bhg\n\u2211\nh\u2212g\u2208b \u03b2(h\u2212g|hg)x(h\u2212g)\nSince Bhg partitions Z\u2212g, the double sum reduces to a sum over all histories of the other agent, giving\n\u2211\nb\u2208Bhg zhg,b = x(hg)\n\u2211\nh\u2212g\u2208Z\u2212g \u03b2(h\u2212g|hg)x(h\u2212g) (4)\nA legal policy prescribes an action at each state reachable by a non-terminal history with non-zero weight. As a result, histories in the support set cover all possible transitions of actions along their parents. This means that the sum of probabilities of transitions along histories in the support set must be 1. Consequently, the sum in equation (4) is 1; only the xs of histories in \u03c3\u2212g are 1, so the sum is over their corresponding \u03b2s. We therefore have the following set of constraints, one per terminal history of each agent\n\u2211\nb\u2208Bhg zhg,b = x(hg) (5)\nThis constraint simply guarantees that if hg is not part of the support, all the compound variables involving hg and its bins should be 0. If hg is part of the support, it guarantees there is enough contribution from the compound variables associated with all bins of hg.\nHowever, the above constraint does not prevent one compound variable from taking too high a value at the expense of another. We can use identity (3) itself as a source of upper bounds on compound variables. Because in (3) x(hg) is either 0 or 1, we have that\nzhg,b \u2264 \u2211\nh\u2212g\u2208b \u03b2(h\u2212g|hg)x(h\u2212g) (6)\nTogether, constraints (5) and (6) strictly enforce the identity. One advantage of our constraints over the combinatorics-based constraints in the DEC-MDP formulation is that ours do not involve the size of the support set, which Aras calculates from the parameters of the problem by assuming that the number of states a state-action pair transitions to is constant. But in settings where this number depends on the particular action taken, determining the support size requires carefully looking at an agent\u2019s decision tree and the paths in it, which is non-trivial for large problems.\nAs for the number of constraints, the set of constraints in (5) has the same size as the constraints in the DECMDP MILP. The set in (6), however, is larger, because it has a constraint for each bin of each history of each agent. But as will be seen in Section 5, this does not prevent us from obtaining computational savings compared to the DEC-MDP formulation."}, {"heading": "4 MILP for 3 or more agents", "text": "The idea of binning histories naturally extends beyond 2 agents. With n agents, an agent\u2019s bin contains history tuples, where each tuple consists of histories of the n \u2212 1 other agents. Compound variables are defined by the identity\nzhg,b = x(hg) \u2211\nh\u2212g\u2208b\n\u220f\nhf\u2208h\u2212g \u03b2(hf |h, h\u2212g)x(hf ) (7)\nAs in the 2-agent case, the set of bins associated with hg is a partition over Z\u2212g, so we can use constraint (5). The greater challenge is devising linear constraints that impose upper bounds on the z variables, similar to constraint (6). With 2-agents, we simply obtained linear constraints by dropping the leading x in the identity. But with 3 or more agents, doing so would result in a non-linear constraint.\nIn the following, we use properties of legal policies and structured interactions to derive 2 linear constraints\nper z variable (in addition to constraint (5)) that attempt, but are not guaranteed, to enforce the identity. Note that even if the identity is violated, any feasible solution to the MILP still forms a legal set of policies, since legality is guaranteed by the policy constraints. Allowing the identity to be violated means we are solving a relaxed version of the problem.\nFor ease of exposition, we show the derivation of the constraints associated with a history hi of agent i when A contains three agents i, j and k. If we assume that an action of agent i can be affected by at most one other agent, we can decompose b into a bin for each affecting agent such that b = bj \u00d7 bk. Dropping the leading x in (7) and using the decomposition of b to break down the summation gives\nzhi,b\u2264 \u2211\nhj\u2208bj x(hj)\n\u2211\nhk\u2208bk x(hk)\u03b2(hj |hi, hk)\u03b2(hk|hi, hj)\n(8)\nWe can obtain two linear upper bounds from the above by setting all x(hj) (resp. x(hk)) to 1. But these bounds would be too loose; for a feasible solution < xs, zs > to the MILP, zs can be very different from the z calculated by applying the identity to xs. In other words, the solver has too much freedom to violate the identity and set some zs higher than the identity allows if this improves the value of the objective function. The reward reported by the solver (the value of the objective function at zs) is therefore higher than the true reward obtained when the agents follow the policies prescribed by xs. The solver is optimizing a relaxed version of the problem whose optimal solution does not necessarily correspond to an optimal of the original problem. We need to tighten the upper bound so that the relaxed problem corresponds more faithfully to the original problem.\nConsider the coefficient of some x(hj) in the nonlinearized constraint (8):\n\u2211\nhk\u2208bk x(hk)\u03b2(hj |hi, hk)\u03b2(hk|hi, hj) (9)\nSetting all x(hk) = 1\u2200hk \u2208 bk allows this coefficient to be higher than it can be under a legal policy. Regarding the coefficient as a sum over the contributions of each hk \u2208 bk, we can decrease the coefficient by limiting the contributions of the hks. To do this, we decompose the sum in (9) into a series of sums over bins of k\u2019s histories constructed from the perspective of j\u2019s history hj . We denote the bins of k\u2019s histories induced by hj as bhjk ( \u22c3 bhjk = bk). Because j\u2019s transition probability is the same under all hk in the same bin, we can factor this probability out. The coefficient\ncan be re-written as \u2211\nbhjk\n\u03b2(hj |hi, bhjk) \u2211\nhk\u2208bhjk x(hk)\u03b2(hk|hi, hj)\nNow we can use the same reasoning behind constraint (5) to get rid of x(hk) and bound the factor multiplying each \u03b2(hj |hi, bhjk) to be at most 1, thus restricting the coefficient of x(hj). The same can be done from the perspective of x(hk). These restrictions, together with the fact that a coefficient cannot exceed 1, allow us to approximately enforce identity (7) using constraint (5) and the following bounds\nzhi,b\u2264 \u2211\nhj\u2208bj x(hj)\n\u230a \u2211\nbhjk\n\u03b2(hj |hi, bhjk) \u230a \u2211\nhk\u2208bhjk \u03b2(hk|hi, hj)\n\u230b\u230b\nzhi,b\u2264 \u2211\nhk\u2208bk x(hk)\n\u230a \u2211\nbhkj\n\u03b2(hk|hi, bhkj) \u230a \u2211\nhj\u2208bhkj \u03b2(hj |hi, hk)\n\u230b\u230b\n(10)\nwhere bxc denotes min(x,1). The quest for tight linear relaxations for non-linear functions is common in the optimization literature. A trilinear term (of the form xyz) can be replaced by a new variable w and a set of constraints that form a linear relaxation of the term\u2019s convex envelope and guarantee that w is within a certain amount of the product xyz [8]. Although these constraints are somewhat similar to ours, they still do not guarantee that zhi,b > 0 if x(hi) = 1 and j and k play histories in b, which is key in bringing values of z in the relaxed problem in alignment with what the identity specifies.\nThe idea of further binning histories within a given bin to bound the values of coefficients can be used with any number of agents. For n agents, we have n\u2212 1 upper bounds per z1 and constraint (5) can be used as-is."}, {"heading": "5 Results and Discussion", "text": ""}, {"heading": "5.1 Results of 2-agent formulations", "text": "We compare 3 formulations of EDI-CR instances: 1) the NLP formulation in Table 1, but restricted to 2 agents, 2) the DEC-MDP MILP formulation in Table 2 and 3) the EDI-CR MILP formulation in Table 3. All 3 formulations were solved using IBM ILOG Cplex [1] under the default parameters; the first using Cplex Mixed Integer QP solver, and the other two using Cplex MILP solver.\nWe experimented with 22 instances of the modified Mars rovers problem [9]. Each rover has a set of sites\n1Also, relaxations of higher order terms can be obtained by repeated application of relaxations of lower order terms [6].\nand picks the sites to visit and their order. Probabilistically, visiting a site can be slow or fast and each outcome has an associated reward. A rover visiting a site can affect the outcome probability of another rover if the latter visits a dependent site. Each such transition dependence has an entry in \u03c4 (e.g., if rover j visits a site 4 before rover i visits site 8, j can collect samples that make it more likely that i process site 8 faster). Additional reward (for complementary sites) or penalty (for redundant sites) is collected when the rovers visit certain sets of sites. Each such reward interaction has an entry in \u03c1. The number of interactions ranges from 4 to 7.\nWe note that the time to generate the 3 formulations is almost the same; constructing the bins and objective function for the EDI-CR MILP is not more expensive than constructing the reward matrix for the QP or the objective function for the DEC-MDP MILP. In all 3 cases, we iterate over every pair of histories of the 2 agents to calculate their rewards and probabilities.\nFirst, we look at behavior with respect to optimality. Even after obtaining a solution that we know is optimal (by comparing to a known optimal), Cplex may spend a long time verifying optimality. We therefore have 5 possible outcomes of a run: 1) optimal found and verified, 2) optimal found but not verified before timeout2, 3) Locally optimal solution found, 4) Optimal not found before timeout, but a suboptimal solution was found, 5) No solution found before time out. Of our 22 instances, Table 4 compares how many fall in each category. Because a MILP solver never reports a solution that is only locally optimal, the corresponding entries are marked \u2019-\u2019. Our formulation resulted in a provably optimal solution in 17/22 instances. In the remaining instances, we obtained higher rewards than the other formulations, but Cplex could not verify optimality, so each of the remaining 5 instances falls into category 2 or 4. QP and DEC-MDP MILP were equally good at finding optimal solutions, although DEC-MDP MILP was better at verifying optimality. The table shows that the non-concavity of the QP can often lead the solver to just report a locally optimal solution. It also shows that in some cases, the number of compound variables introduced in the DEC-MILP is too large to allow the solver to find any solution before timeout (row 5).\nNext, we look at the size of the MILP with and without exploiting structured interactions. We break down our 22 instances into 3 groups G1, G2 and G3 containing 5, 9 and 8 instances, respectively. We grouped instances based based on size, rather than number of interactions. The average number of interactions is\n2Timeout is 60 seconds for small instances and 600 seconds for larger ones.\n4.8 for G1, 5.3 for G2 and 5.25 for G3. Table 5 shows the number of terminal histories for each agent |Zi| and |Zj |, the number of compound variables introduced in the DEC-MDP formulation|z|DEC and our EDI-CR formulation |z|EDI , and the number of constraints (besides the policy constraints). Results were averaged over instances in each group. Clearly, the DEC-MDP formulation introduces many more compound variables than our formulation which only create as many variables as needed to distinguish between bins induced by a given history. The difference in the number of variables becomes more pronounced as the problem size increases. Although our formulation has more constraints than the DEC-MDP MILP, we next show that the increased number of constraints is offset by the large reduction in the number of variables, resulting in MILPs that are overall easier to solve.\nTable 6 shows the results of comparing both the time needed to find the optimal solution (reported as \u2018Find\u2019), and the time needed to verify that the solution is indeed optimal (reported as \u2018Verify\u2019). The times are in seconds, averaged over instances in each group. For groups where some solutions were not found/verified within reasonable time, the number of instances over which the averaging was done is indicated in brackets. In general, solving the EDI-CR MILP formulation is significantly faster than solving the other 2 formulations. There is also a large difference in the time needed to verify optimality. In G1, only 3 instances could be solved provably optimally within 60 seconds using the DEC-MDP MILP and QP formulations. In G2, the differences in time to verify optimality among the different formulations is even more pronounced. In G3, Cplex found solutions for all the instances of the EDI-CR MILP formulation, but could not verify optimality. A solution with the same quality could not be found with any of the other formulations."}, {"heading": "5.2 Results of 3-agent formulations", "text": "The 3-agent case exacerbates the problem of the DECMDP MILP formulation which introduces hundreds of thousands to several millions variables in our test cases. Because Cplex was unable to solve (and usually even load) the DEC-MDP MILP of our instances, we omit this formulation from further discussion.\nWe compare the NLP in Table 1, solved using Knitro [2] (active-set algorithm), and EDI-CR 3-agent MILP solved using Cplex [1] under the default parameters. We used 25 instances of 3-agent Mars Rovers problem broken down by size into 4 groups G1..G4 containing increasingly larger instances (sizes given in Table 7). G1 contains 10 instances and each of the other groups contains 5 instances. The number of interactions ranges from 4 to 10.\nTable 7 summarizes our experimental results averaged over instances in each group. The first 4 columns show the sizes of the instances and the number of compound variables our formulation creates. The number of nonpolicy constraints introduced by our formulation can be calculated as |Zi| + |Zj | + |Zg| + 2|z|. The first 3 terms are due to constraint (5) and the last term is due to the upper bounds in (10). It is important to note that the constraint matrix, although large, is fairly sparse; the constraint of a terminal history only involves the zs of this history\u2019s bins, and the constraint of a zh,b only involves histories in b of 1 affecting agent. As will be shown presently, Cplex solves EDI-CR MILPs in very little time.\nTo generate the NLP\u2019s objective function and construct the bins for the MILP, we need to calculate rewards for each triplet < hi, hj , hk >. And to be able to solve large instances like the ones we experiment with, we need to identify and remove dominated histories as in [3]3. The times for these 2 steps are in the first 2 columns of the \u2018Times\u2019 section of Table 7. Although expensive, the first step is unavoidable and the second saves time and space for both NLP and MILP. Column \u2018Bin\u2019 shows the time to generate constraints (5) and (10) for the MILP. Although this step is rather expensive, it results in a MILP that is solved at least an order of magnitude faster than the NLP\n3None of the formulations would otherwise fit in memory. Reported numbers are those of undominated histories.\n(shown in the \u2018Sol.\u2019 columns). Even with our current implementation (unoptimized for speed), the time to solve the NLP far exceeds the constraints generation time and the MILP solving time combined. The difference becomes more pronounced with larger instances (for G4, we timed out Knitro and report the reward obtained after 30 minutes).\nFinally, Table 7 compares the rewards obtained by the policies from the NLP and MILP solutions. As explained in Section 4, our MILP is a relaxation of the original problem where some zs can be higher than their values under identity (7). The solution reported by the MILP is therefore an over-estimate of the optimal reward. The table shows the reward of the MILP and NLP policies as a percentage of this over-estimate. For smaller instances, MILP and NLP give comparable rewards, but on larger ones, Knitro is unable to produce good policies within 30 minutes.\nWhereas we do not know of a way to improve the quality of the NLP solution, the MILP can be improved by improving the correspondence between the MILP and the original problem, i.e. making the upper bounds on zs tighter and/or obtaining lower bounds on z. This would result in a space of feasible solutions that better resembles that of the original problem, and would prevent the solver from pursuing solutions that appear to be good, but are sub-optimal in the original space."}, {"heading": "6 Related Work", "text": "Researchers have formulated decision problems as mathematical programs with the aim of benefiting from available industrial-grade optimization packages. Besides formulations for the general DEC-MDPs [3], special cases were also addressed. TransitionIndependent DEC-MDPs [5] were formulated as MILP [14], but this formulation cannot be useful for EDI-CR because transition dependence adds significant complexity (TI-DEC-MDP is NP-complete while EDI-CR is NEXP-complete) and changes the way we approach the problem. Aras et. al [4] developed a QP for Network Distributed POMDPs (ND-POMDP) [10], a model where agents either do not interact, or interact very closely (coarse-grained independence). In EDICR, interactions are specified at the level of actions, and we exploit this fine-grained specification.\nSeveral variants and sub-classes of DEC-(PO)MDPs have been proposed, each catering to a different kind of structured interaction. For example, IDMG and DPCL [11, 12] address settings where interaction among agents is specific to a set of interaction states. We cannot (easily) represent situations where some agents\u2019 actions affect outcomes of other actions using these models because their agents are assumed to be\ntightly coupled in the interaction states, so all of an agent\u2019s actions taken in those states affect the other agent. Moreover, IDMG\u2019s solution approach assumes knowledge of the joint state (through free communication) when the agents are in the interaction states, an assumption not in EDI-CR. TD-POMDP [13] is a model somewhat similar to EDI-CR, but its solution approach is very different and has not been demonstrated in situations where all agents affect each other."}, {"heading": "7 Conclusion", "text": "This paper presents compact MILP formulations of a class of DEC-MDPs where there are structured transition and reward interactions among agents. Previously, this problem would be formulated as an NLP, which is expensive to solve and can result in suboptimal solutions, or using a general MILP formulation for DEC-MDPs, whose size is typically prohibitive. Our formulation successfully exploits structured interactions using the insight that most action histories of a group of agents have the same effect on a given agent, thereby allowing us to treat these histories similarly and use fewer variables in the formulation. Experiments show that our MILP is more compact and leads to faster solution times and generally better solutions than formulations ignoring the structure of interactions. Our formulation allows us to solve larger problems which would otherwise be intractable.\nOne future direction for this work involves approximately binning where histories whose effects are similar enough are grouped in the same bin, thus reducing the number of compound variables needed."}], "references": [], "referenceMentions": [], "year": 2011, "abstractText": "To deal with the prohibitive complexity of<lb>calculating policies in Decentralized MDPs,<lb>researchers have proposed models that ex-<lb>ploit structured agent interactions. Settings<lb>where most agent actions are independent<lb>except for few actions that affect the tran-<lb>sitions and/or rewards of other agents can<lb>be modeled using Event-Driven Interactions<lb>with Complex Rewards (EDI-CR). Finding<lb>the optimal joint policy can be formulated<lb>as an optimization problem. However, exist-<lb>ing formulations are too verbose and/or lack<lb>optimality guarantees. We propose a com-<lb>pact Mixed Integer Linear Program formula-<lb>tion of EDI-CR instances. The key insight<lb>is that most action sequences of a group of<lb>agents have the same effect on a given agent.<lb>This allows us to treat these sequences sim-<lb>ilarly and use fewer variables. Experiments<lb>show that our formulation is more compact<lb>and leads to faster solution times and better<lb>solutions than existing formulations.", "creator": " TeX output 2011.06.17:1618"}}}