{"id": "1204.6346", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Apr-2012", "title": "Magic Sets for Disjunctive Datalog Programs", "abstract": "simultaneously in this paper, a new technique for the possible optimization of ( partially ) bound queries over disjunctive datalog programs with stratified negation is presented. the technique exploits the propagation of query bindings and this extends the magic block set ( ms ) optimization technique technique.", "histories": [["v1", "Fri, 27 Apr 2012 23:17:00 GMT  (217kb)", "http://arxiv.org/abs/1204.6346v1", "67 pages, 19 figures, preprint submitted to Artificial Intelligence"]], "COMMENTS": "67 pages, 19 figures, preprint submitted to Artificial Intelligence", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["mario alviano", "wolfgang faber", "gianluigi greco", "nicola leone"], "accepted": false, "id": "1204.6346"}, "pdf": {"name": "1204.6346.pdf", "metadata": {"source": "CRF", "title": "Magic Sets for Disjunctive Datalog Programs", "authors": ["Mario Alviano", "Wolfgang Faber", "Gianluigi Greco", "Nicola Leone"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n20 4.\n63 46\nv1 [\ncs .A\nI] 2\n7 A\npr 2\n01 2\nIn this paper, a new technique for the optimization of (partially) bound queries over disjunctive Datalog programs with stratified negation is presented. The technique exploits the propagation of query bindings and extends the Magic Set optimization technique (originally defined for non-disjunctive programs).\nAn important feature of disjunctive Datalog programs is nonmonotonicity, which calls for nondeterministic implementations, such as backtracking search. A distinguishing characteristic of the new method is that the optimization can be exploited also during the nondeterministic phase. In particular, after some assumptions have been made during the computation, parts of the program may become irrelevant to a query under these assumptions. This allows for dynamic pruning of the search space. In contrast, the effect of the previously defined Magic Set methods for disjunctive Datalog is limited to the deterministic portion of the process. In this way, the potential performance gain by using the proposed method can be exponential, as could be observed empirically.\nThe correctness of the method is established and proved in a formal way thanks to a strong relationship between Magic Sets and unfounded sets that has not been studied in the literature before. This knowledge allows for extending the method and the correctness proof also to programs with stratified negation in a natural way.\nThe proposed method has been implemented in the DLV system and various experiments on synthetic as well as on real-world data have been conducted. The experimental results on synthetic data confirm the utility of Magic Sets for disjunctive Datalog, and they highlight the computational gain that may be obtained by the new method with respect to the previously proposed Magic Set method for disjunctive Datalog programs. Further experiments on data taken from a real-life application show the benefits of the Magic Set method within an application scenario that has received considerable attention in recent years, the problem of answering user queries over possibly inconsistent databases originating from integration of autonomous sources of information.\nKey words: Logic Programming, Stable Models, Magic Sets, Answer Set Programming, Data Integration\nPreprint submitted to Artificial Intelligence 1 May 2012"}, {"heading": "1 Introduction", "text": "Disjunctive Datalog is a language that has been proposed for modeling incomplete data [48]. Together with a light version of negation, in this paper stratified negation, this language can in fact express any query of the complexity class \u03a3P2 (i.e., NP NP) [22], under the stable model semantics. It turns out that disjunctive Datalog with stratified negation is strictly more expressive (unless the polynomial hierarchy collapses to its first level) than normal logic programming (i.e., non-disjunctive Datalog with unstratified negation), as the latter can express \u201conly\u201d queries in NP. As shown in [22], the high expressive power of disjunctive Datalog has also some positive practical implications in terms of modelling knowledge, since many problems in NP can be represented more simply and naturally in stratified disjunctive Datalog than in normal logic programming. For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21]. As a matter of fact, these systems are continuously enhanced to support novel optimization strategies, enabling them to be effective over increasingly larger application domains. In this paper, we contribute to this development by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic Set method [6,9,63].\nThe goal of the original Magic Set method (defined for non-disjunctive Datalog programs) is to exploit the presence of constants in a query for restricting the possible search space by considering only a subset of a hypothetical program instantiation that is sufficient to answer the query in question. In order to do this, a top-down computation for answering the query is simulated in an abstract way. This top-down simulation is then encoded by means of rules, defining new Magic Set predicates. The extensions of these predicates (sets of ground atoms) will contain the tuples that are calculated during a top-down computation. These predicates are inserted into the original program rules and can then be used by bottom-up computations to narrow the computation to what is needed for answering the query.\nExtending these ideas to disjunctive Datalog faces a major challenge: While non-disjunctive Datalog programs are deterministic, which in terms of the stable model semantics means that any non-disjunctive Datalog program has\n\u22c6 Preliminary portions of this paper appeared in the proceedings of the 20th International Conference on Logic Programming (ICLP\u201904).\nEmail addresses: alviano@mat.unical.it (Mario Alviano), faber@mat.unical.it (Wolfgang Faber), ggreco@mat.unical.it (Gianluigi Greco), leone@mat.unical.it (Nicola Leone).\nexactly one stable model, disjunctive Datalog programs are nondeterministic in the sense that they may have multiple stable models. Of course, the main goal is still isolating a subset of a hypothetical program instantiation, upon which the considered query will be evaluated in an equivalent way. There are two basic possibilities how this nondeterminism can be dealt with in the context of Magic Sets: The first is to consider static Magic Sets, in the sense that the definition of the Magic Sets is still deterministic, and therefore the extension of the Magic Set predicates is equal in each stable model. This static behavior is automatic for Magic Sets of non-disjunctive Datalog programs. The second possibility is to allow dynamic Magic Sets, which also introduce nondeterministic definitions of Magic Sets. This means that the extension of the Magic Set predicates may differ in various stable models, and thus can be viewed as being specialized for each stable model.\nWhile the nature of dynamic Magic Sets intuitively seems to be more fitting for disjunctive Datalog than static Magic Sets, considering the architecture of modern reasoning systems for disjunctive Datalog substantiates this intuition: These systems work in two phases, which may be considered as a deterministic (grounding) and a non-deterministic (model search) part. The interface between these two is by means of a ground program, which is produced by the deterministic phase. Static Magic Sets will almost exclusively have an impact on the grounding phase, while dynamic Magic Sets also have the possibility to influence the model search phase. In particular, some assumptions made during the model search may render parts of the program irrelevant to the query, which may be captured by dynamic Magic Sets, but not (or only under very specific circumstances) by static Magic Sets.\nIn the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set method for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work. The basic idea of SMS is that bindings need to be propagated not only from rule heads to rule bodies (as in traditional Magic Sets), but also from one head predicate to other head predicates. In addition to producing definitions for the predicates defining Magic Sets, the method also introduces additional auxiliary predicates called collecting predicates. These collecting predicates however have a peculiar effect: Their use keeps the Magic Sets static. Indeed, both magic and collecting predicates are guaranteed to have deterministic definitions, which implies that disjunctive Datalog systems can exploit the Magic Sets only during the grounding phase. Most systems will actually produce a ground program which does contain neither magic nor collecting predicates.\nIn this article, we propose a dynamic Magic Set method for disjunctive Datalog with stratified negation under the stable model semantics, provide an implementation of it in the system DLV, and report on an extensive experimental evaluation. In more detail, the contributions are:\n\u25ee We present a dynamic Magic Set method for disjunctive Datalog programs with stratified negation, referred to as Dynamic Magic Sets (DMS). Different from the previously proposed static method SMS, existing systems can exploit the information provided by the Magic Sets also during their nondeterministic model search phase. This feature allows for potentially exponential performance gains with respect to the previously proposed static method. \u25ee We formally establish the correctness of DMS. In particular, we prove that the program obtained by the transformation DMS is query-equivalent to the original program. This result holds for both brave and cautious reasoning. \u25ee We highlight a strong relationship between Magic Sets and unfounded sets, which characterize stable models. We can show that the atoms which are relevant for answering a query are either true or form an unfounded set, which eventually allows us to prove the query-equivalence results. \u25ee Our results hold for a disjunctive Datalog language with stratified negation under the stable model semantics. In the literature, several works deal with non-disjunctive Datalog with stratified negation under the well-founded or the perfect model semantics, which are special cases of our language. For the static method SMS, an extension to disjunctive Datalog with stratified negation has previously only been sketched in [33]. \u25ee We have implemented a DMS optimization module inside the DLV system [43]. In this way, we could exploit the internal data-structures of the DLV system and embed DMS in the core of DLV. As a result, the technique is completely transparent to the end user. The system is available at http: //www.dlvsystem.com/magic/. \u25ee We have conducted extensive experiments on synthetic domains that highlight the potential of DMS. We have compared the performance of the DLV system without Magic Set optimization with SMS and with DMS. The results show that in many cases the Magic Set methods yield a significant performance benefit. Moreover, we can show that the dynamic method DMS can yield drastically better performance than the static SMS. Importantly, in cases in which DMS cannot be beneficial (if all or most of the instantiated program is relevant for answering a query), the overhead incurred is very light. \u25ee We also report on experiments which evaluate the impact of DMS on an industrial application scenario on real-world data. The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs. By leveraging these results, DMS can be viewed as a query optimization method for inconsistent databases or for data integration systems. The results show that DMS can yield significant performance gains for queries of this application.\nOrganization. The main body of this article is organized as follows. In Section 2, preliminaries on disjunctive Datalog and on the Magic Set method for non-disjunctive Datalog queries are introduced. Subsequently, in Section 3 the extension DMS for the case of disjunctive Datalog programs is presented, and we show its correctness. In Section 4 we discuss the implementation and integration of the Magic Set method within theDLV system. Experimental results on synthetic benchmarks are reported in Section 5, while the application to data integration and its experimental evaluation is discussed in Section 6. Finally, related work is discussed in Section 7, and in Section 8 we draw our conclusions."}, {"heading": "2 Preliminaries", "text": "In this section, (disjunctive) Datalog programs with (stratified) negation are briefly described, and the standard Magic Set method is presented together with the notion of sideways information passing strategy (SIPS) for Datalog rules."}, {"heading": "2.1 Disjunctive Datalog Programs with Stratified Negation", "text": "In this paper, we adopt the standard Datalog name convention: Alphanumeric strings starting with a lowercase character are predicate or constant symbols, while alphanumeric strings starting with an uppercase character are variable symbols; moreover, we allow the use of positive integer constant symbols. Each predicate symbol is associated with a non-negative integer, referred to as its arity. An atom p(t\u0304) is composed of a predicate symbol p and a list t\u0304= t1, . . . , tk (k \u2265 0) of terms, each of which is either a constant or a variable. A literal is an atom p(t\u0304) or a negated atom not p(t\u0304); in the first case the literal is positive, while in the second it is negative.\nA disjunctive Datalog rule with negation (short: Datalog\u2228,\u00ac rule) r is of the form\np1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 q1(s\u03041), . . . , qj(s\u0304j),\nnot qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nwhere p1(t\u03041), . . . , pn(t\u0304n), q1(s\u03041), . . . , qm(s\u0304m) are atoms and n \u2265 1, m \u2265 j \u2265 0. The disjunction p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) is the head of r, while the conjunction q1(s\u03041), . . . , qj(s\u0304j), not qj+1(s\u0304j+1), . . . , not qm(s\u0304m) is the body of r. Moreover, H(r) denotes the set of head atoms, while B(r) denotes the set of body literals. We also use B+(r) and B\u2212(r) for denoting the sets of atoms appearing in\npositive and negative body literals, respectively. If r is disjunction-free, that is n = 1, and negation-free, that is B\u2212(r) is empty, then we say that r is a Datalog rule; if B+(r) is empty in addition, then we say that r is a fact. A disjunctive Datalog program P is a finite set of rules; if all the rules in it are disjunction- and negation-free, then P is a (standard) Datalog program.\nGiven a Datalog\u2228,\u00ac program P, a predicate belongs to the Intensional Database (IDB) if it is either in the head of a rule with non-empty body, or in the head of a disjunctive rule; otherwise, it belongs to the Extensional Database (EDB). The set of rules having IDB predicates in their heads is denoted by IDB(P), while EDB(P) denotes the remaining rules, that is, EDB(P) = P \\IDB(P). For simplicity, we assume that predicates will always be of the same type (EDB or IDB) in any program.\nThe set of all constants appearing in a program P is the universe of P and is denoted by UP ,\n1 while the set of ground atoms constructable from predicates in P with constants in UP is the base of P, denoted by BP . We call an atom (rule, or program) ground if it does not contain any variables. A substitution \u03d1 is a function from variables to elements of UP . For an expression S (atom, literal, rule), by S\u03d1 we denote the expression obtained from S by substituting all occurrences of each variable X in S with \u03d1(X). A ground atom p(t\u0304) (resp. ground rule rg) is an instance of an atom p(t\u0304\n\u2032) (resp. rule r) if there is a substitution \u03d1 from the variables in p(t\u0304\u2032) (resp. in r) to UP such that p(t\u0304) = p(t\u0304\u2032)\u03d1 (resp. rg = r\u03d1). Given a program P, Ground(P) denotes the set of all possible instances of rules in P.\nGiven an atom p(t\u0304) and a set of ground atoms A, by A|p(t\u0304) we denote the set of ground instances of p(t\u0304) belonging to A. For example, BP |p(t\u0304) is the set of all ground atoms obtained by applying to p(t\u0304) all the possible substitutions from the variables in p(t\u0304) to UP , that is, the set of all the instances of p(t\u0304). Abusing notation, if B is a set of atoms, by A|B we denote the union of all A|p(t\u0304), for each p(t\u0304) \u2208 B.\nA desirable property of Datalog\u2228,\u00ac programs is safety. A Datalog\u2228,\u00ac rule r is safe if each variable appearing in r appears in at least one atom of B+(r). A Datalog\u2228,\u00ac program is safe if all its rules are safe. Moreover, programs without recursion over negated literals constitute an interesting class of Datalog\u2228,\u00ac programs. Without going into details, a predicate p in the head of a rule r depends on all the predicates q in the body of r; p depends on q positively if q appears in B+(r), and p depends on q negatively if q appears in B\u2212(r). A program has recursion over negation if a cycle of dependencies with at least one negative dependency exists. If a program has no recursion over negation, then the program is stratified (short: Datalog\u2228,\u00acs). In this work only safe programs\n1 If P has no constants, an arbitrary constant is added to UP .\nwithout recursion over negation are considered.\nAn interpretation for a program P is a subset I of BP . A positive ground literal p(t\u0304) is true with respect to an interpretation I if p(t\u0304) \u2208 I; otherwise, it is false. A negative ground literal not p(t\u0304) is true with respect to I if and only if p(t\u0304) is false with respect to I, that is, if and only if p(t\u0304) 6\u2208 I. The body of a ground rule r is true with respect to I if and only if all the body literals of r are true with respect to I, that is, if and only if B+(r) \u2286 I and B\u2212(r)\u2229I = \u2205. An interpretation I satisfies a ground rule r \u2208 Ground(P) if at least one atom in H(r) is true with respect to I whenever the body of r is true with respect to I. An interpretation I is a model of a Datalog\u2228,\u00ac program P if I satisfies all the rules in Ground(P). Since an interpretation is a set of atoms, if I is an interpretation for a program P, and P \u2032 is another program, then by I|BP\u2032 we denote the restriction of I to the base of P \u2032.\nGiven an interpretation I for a program P, the reduct of P with respect to I, denoted by Ground(P)I , is obtained by deleting from Ground(P) all the rules rg with B\n\u2212(rg) \u2229 I 6= \u2205, and then by removing all the negative literals from the remaining rules.\nThe semantics of a Datalog\u2228,\u00ac program P is given by the set SM(P) of stable models of P, where an interpretation M is a stable model for P if and only if M is a subset-minimal model of Ground(P)M . It is well-known that there is exactly one stable model for any Datalog program, also in presence of stratified negation. However, for a Datalog\u2228,\u00acs program P, |SM(P)| \u2265 1 holds (Datalog\u2228,\u00ac programs, instead, can also have no stable model).\nGiven a ground atom p(t\u0304) and a Datalog\u2228,\u00ac program P, p(t\u0304) is a cautious (or certain) consequence of P, denoted by P |=c p(t\u0304), if p(t\u0304) \u2208 M for each M \u2208 SM(P); p(t\u0304) is a brave (or possible) consequence of P, denoted by P |=b p(t\u0304), if p(t\u0304) \u2208 M for some M \u2208 SM(P). Note that brave and cautious consequences coincide for Datalog programs, as these programs have a unique stable model. Moreover, cautious consequences of a Datalog\u2228,\u00acs program P are also brave consequences of P because |SM(P)| \u2265 1 holds in this case.\nGiven a query Q = g(t\u0304)? (an atom), 2 Ansc(Q,P) denotes the set of all substitutions \u03d1 for the variables of g(t\u0304) such that P |=c g(t\u0304)\u03d1, while Ansb(Q,P) denotes the set of substitutions \u03d1 for the variables of g(t\u0304) such that P |=b g(t\u0304)\u03d1.\nLet P and P \u2032 be two Datalog\u2228,\u00ac programs and Q a query. Then P and P \u2032"}, {"heading": "2 Note that more complex queries can still be expressed using appropriate rules.", "text": "We assume that each constant appearing in Q also appears in P; if this is not the case, then we can add to P a fact p(t\u0304) such that p is a predicate not occurring in P and t\u0304 are the arguments of Q. Question marks will be usually omitted when referring to queries in the text.\nare brave-equivalent with respect to Q, denoted by P\u2261bQP \u2032, if Ansb(Q,P \u222a F) = Ansb(Q,P \u2032 \u222a F) is guaranteed for each set of facts F defined over predicates which are EDB predicates of P or P \u2032; similarly, P and P \u2032 are cautious-equivalent with respect toQ, denoted by P\u2261cQP\n\u2032, if Ansc(Q,P\u222aF) = Ansc(Q,P\n\u2032 \u222a F) is guaranteed for each set of facts F defined over predicates which are EDB predicates of P or P \u2032."}, {"heading": "2.2 Bottom-up Disjunctive Datalog Computation", "text": "Many Datalog\u2228,\u00ac systems implement a two-phase computation. The first phase, referred to as program instantiation or grounding, is bottom-up. For an input program P, it produces a ground program which is equivalent to Ground(P), but significantly smaller. Most of the techniques used in this phase stem from bottom-up methods developed for classic and deductive databases; see for example [1] or [28,43] for details. Essentially, predicate instances which are known to be true or known to be false are identified and this knowledge is used for deriving further instances of this kind. Eventually, the truth values obtained in this way are used to produce rule instances which are not satisfied already. It is important to note that this phase behaves in a deterministic way with respect to stable models. No assumptions about truth or falsity of atoms are made, only definite knowledge is derived, which must hold in all stable models. For this reason, programs with multiple stable models cannot be solved by grounding.\nThe second phase is often referred to as stable model search and takes care of the non-deterministic computation. Essentially, one undefined atom is selected and its truth or falsity is assumed. The assumption might imply truth or falsity of other undefined atoms. Hence, the process is repeated until either an inconsistency is derived or all atoms have been interpreted. In the latter case an additional check is performed to ensure stability of the model. Details on this process can be found for example in [23]. Query answering is typically handled by storing all admissible answer substitutions as stable models are computed. For brave reasoning, each stable model can contribute substitutions to the set of answers. In this case the set of answers is initially empty. For cautious reasoning, instead, each stable model may eliminate some substitutions from the set of admissible answers. Therefore, in this case all possible substitutions for the input query are initially contained in the set of answers."}, {"heading": "2.3 Sideways Information Passing for Datalog Rules", "text": "The Magic Set method aims at simulate a top-down evaluation of a query Q, like for instance the one adopted by Prolog. According to this kind of\nevaluation, all the rules r such that p(t\u0304) \u2208 H(r) and H(r)\u03d1 = {Q\u03d1\u2032} (for some substitution \u03d1 for all the variables of r and some substitution \u03d1\u2032 for all the variables of Q) are considered in a first step. Then the atoms in B+(r)\u03d1 are taken as subqueries (we recall that standard Datalog rules have empty negative body), and the procedure is iterated. Note that, according to this process, if a (sub)query has some argument that is bound to a constant value, this information is \u201cpassed\u201d to the atoms in the body. Moreover, the body is considered to be processed in a certain sequence, and processing a body atom may bind some of its arguments for subsequently considered body atoms, thus \u201cgenerating\u201d and \u201cpassing\u201d bindings within the body. Whenever a body atom is processed, each of its argument is therefore considered to be either bound or free. We illustrate this mechanism by means of an example.\nExample 2.1 Let path(1, 5) be a query for a program having the following inference rules:\nr1 : path(X, Y) :\u2212 edge(X, Y). r2 : path(X, Y) :\u2212 edge(X, Z), path(Z, Y).\nSince this is a Datalog program, brave and cautious consequences coincide. Moreover, let F1 = {edge(1, 3), edge(2, 4), edge(3, 5)} be the EDB of the program. A top-down evaluation scheme considers r1 and r2 with X and Y bound to 1 and 5, respectively. In particular, when considering r1, the information about the binding of the two variables is passed to edge(X, Y), which is indeed the only query atom occurring in r1. Thus, the evaluation fails since edge(1, 5) does not occur in F1.\nWhen considering r2, instead, the binding information can be passed either to path(Z, Y) or to edge(X, Z). Suppose that atoms are evaluated according to their ordering in the rule (from left to right); then edge(X, Z) is considered before path(Z, Y). In particular, F1 contains the atom edge(1, 3), which leads us to map Z to 3. Eventually, this inferred binding information might be propagated to the remaining body atom path(Z, Y), which hence becomes path(3, 5).\nThe process has now to be repeated by looking for an answer to path(3, 5). Again, rule r1 can be considered, from which we conclude that this query is true since edge(3, 5) occurs in F1. Thus, path(1, 5) holds as well due to r2. \u2737\nNote that in the example above we have two degrees of freedom in the specification of the top-down evaluation scheme. The first one concerns which ordering is used for processing the body atoms. While Prolog systems are usually required to follow the ordering in which the program is written, Datalog has a purely declarative semantics which is independent of the body ordering, allowing for an arbitrary ordering to be adopted. The second degree of\nfreedom is slightly more subtle, and concerns the selection of the terms to be considered bound to constants from previous evaluations. Indeed, while we have considered the propagation of all the binding information that originates from previously processed body atoms, it is in general possible to restrict the top-down evaluation to partially propagate this information. For instance, one may desire to propagate only information generated from the evaluation of EDB predicates, or even just the information that is passed on via the head atom.\nThe specific propagation strategy adopted in the top-down evaluation scheme is called sideways information passing strategy (SIPS), which is just a way of formalizing a partial ordering over the atoms of each rule together with the specification of how the bindings originated and propagate [9,33]. To formalize this concept, in what follows, for each IDB atom p(t\u0304), we shall denote its associated binding information (originated in a certain step of the top-down evaluation) by means of a string \u03b1 built over the letters b and f , denoting \u201cbound\u201d and \u201cfree\u201d, respectively, for each argument of p(t\u0304).\nDefinition 2.2 (SIPS for Datalog rules) A SIPS for a Datalog rule r with respect to a binding \u03b1 for the atom p(t\u0304) \u2208 H(r) is a pair (\u227a\u03b1r , f \u03b1 r ), where:\n(1) \u227a\u03b1r is a strict partial order over the atoms in H(r) \u222a B +(r), such that\np(t\u0304) \u227a\u03b1r q(s\u0304), for all atoms q(s\u0304) \u2208 B +(r); and,\n(2) f\u03b1r is a function assigning to each atom q(s\u0304) \u2208 H(r) \u222aB +(r) a subset of\nthe variables in s\u0304\u2014intuitively, those made bound when processing q(s\u0304).\nIntuitively, for each atom q(s\u0304) occurring in r, the strict partial order \u227a\u03b1r specifies those atoms that have to be processed before processing atom q(s\u0304). Eventually, an argument X of q(s\u0304) is bound to a constant if there exists an atom q\u2032(s\u0304\u2032) such that q\u2032(s\u0304\u2032) \u227a\u03b1r q(s\u0304) and X \u2208 f \u03b1 r (q\n\u2032(s\u0304\u2032)). Note that the head atom p(t\u0304) precedes all other atoms in \u227a\u03b1r .\nExample 2.3 The SIPS we have adopted in Example 2.1 for r1 with respect to the binding bb (originating from the query path(1, 5)) can be formalized as the pair (\u227abbr1 , f bb r1 ), where path(X, Y) \u227abbr1 edge(X, Y), f bb r1 (path(X, Y)) = {X, Y}, and f bbr1 (edge(X, Y)) = \u2205. Instead, the SIPS we have adopted for r2 with respect to the binding bb can be formalized as the pair (\u227abbr2 , f bb r2 ), where path(X, Y) \u227abbr2 edge(X, Z) \u227abbr2 path(Z, Y), f bb r2 (path(X, Y)) = {X, Y}, f bbr2 (edge(X, Z)) = {Z}, and f bbr2 (path(Z, Y)) = \u2205. \u2737\nAll the algorithms and techniques we shall develop in this paper are orthogonal with respect to the underlying SIPSes to be used in the top-down evaluation. Thus, in Section 2.4, we shall assume that Datalog programs are provided in input together with some arbitrarily defined SIPS (\u227a\u03b1r , f \u03b1 r ), for each rule r and for each possible adornment \u03b1 for the head atom in H(r)."}, {"heading": "2.4 Magic Sets for Datalog Programs", "text": "The Magic Set method is a strategy for simulating the top-down evaluation of a query by modifying the original program by means of additional rules, which narrow the computation to what is relevant for answering the query. We next provide a brief and informal description of the Magic Set rewriting technique. The reader is referred to [63] for a detailed presentation.\nThe method is structured in four main phases, which are informally illustrated below by means of Example 2.1.\n(1) Adornment. The key idea is to materialize the binding information for IDB predicates that would be propagated during a top-down computation. In particular, the fact that an IDB predicate p(t\u0304) is associated with a binding information \u03b1 (i.e., a string over the letters b and f , one for each term in t\u0304) is denoted by the atom obtained adorning the predicate symbol with the binding at hand, that is, by p\u03b1(t\u0304). In what follows, the predicate p\u03b1 is said to be an adorned predicate.\nFirst, adornments are created for query predicates so that an argument occurring in the query is adorned with the letter b if it is a constant, or with the letter f if it is a variable. For instance, the adorned version of the query atom path(1, 5) is pathbb(1, 5), which gives rise to the adorned predicate pathbb.\nEach adorned predicate is eventually used to propagate its information into the body of the rules defining it according to a SIPS, thereby simulating a top-down evaluation. In particular, assume that the binding \u03b1 has to be propagated into a rule r whose head is p(t\u0304). Thus, the associated SIPS (\u227a\u03b1r , f \u03b1 r ) determines which variables will be bound in the evaluation of the various body atoms. Indeed, a variable X of an atom q(s\u0304) in r is bound if and only if either\n(1) X \u2208 f\u03b1r (q(s\u0304)) with q(s\u0304) = p(t\u0304); or, (2) X \u2208 f\u03b1r (b(z\u0304)) for an atom b(z\u0304) \u2208 B +(r) such that b(z\u0304) \u227a\u03b1r q(s\u0304) holds.\nAdorning a rule r with respect to an adorned predicate p\u03b1 means propagating the binding information \u03b1, starting from the head predicate p(t\u0304) \u2208 H(r), thereby creating a novel adorned rule where all the IDB predicates in r are substituted by the adorned predicates originating from the binding according to (1) and (2).\nExample 2.4 Adorning the query path(1, 5) generates pathbb(1, 5). Then, propagating the binding information bb into the rule r1, i.e., when adorning r1 with pathbb, produces the following adorned rule (recall here that adornments apply only to IDB predicates, whereas edge is an EDB predicate):\nra1 : path bb(X, Y) :\u2212 edge(X, Y).\nInstead, when propagating bb into the rule r2 according to the SIPS (\u227a bb r2 , f bbr2 ) defined in Example 2.3, we obtain the following adorned rule:\nra2 : path bb(X, Y) :\u2212 edge(X, Z), pathbb(Z, Y).\n\u2737\nWhile adorning rules, novel binding information in the form of yet unseen adorned predicates may be generated, which should be used for adorning other rules. In fact, the adornment step is repeated until all bindings have been processed, yielding the adorned program, which is the set of all adorned rules created during the computation. For instance, in the above example, the adorned program just consists of ra1 and r a 2 for no adorned predicate different from pathbb is generated.\n(2) Generation. In the second step of the Magic Set method, the adorned program is used to generate magic rules, which are used to simulate the topdown evaluation scheme and to single out the atoms relevant for answer the input query. For an adorned atom p\u03b1(t\u0304), let magic(p\u03b1(t\u0304)) be its magic version defined as the atom magic p\u03b1(t\u0304\u2032), where t\u0304\u2032 is obtained from t\u0304 by eliminating all arguments corresponding to an f label in \u03b1, and where magic p\u03b1 is a new predicate symbol (for simplicity denoted by attaching the prefix \u201cmagic \u201d to the predicate symbol p\u03b1). Intuitively, magic p\u03b1(t\u0304\u2032)\u03d1 (\u03d1 a substitution) is inferred by the rules of the rewritten program whenever a top-down evaluation of the original program would process a subquery of the form p\u03b1(t\u0304\u2032\u2032), where t\u0304\u2032\u2032 is obtained from t\u0304 by applying \u03d1 to all terms in t\u0304\u2032.\nThus, if q\u03b2ii (s\u0304i) is an adorned atom (i.e., \u03b2i is not the empty string) in the body of an adorned rule ra having p\u03b1(t\u0304) in head, a magic rule r\u2217 is generated such that (i)H(r\u2217) = {magic(q\u03b2ii (s\u0304i))} and (ii)B(r \u2217) is the union of {magic(p\u03b1(t\u0304))} and the set of all the atoms q \u03b2j j (s\u0304j) \u2208 B +(r) such that qj(s\u0304j) \u227a \u03b1 r qi(s\u0304i).\nExample 2.5 In our running example, only one magic rule is generated,\nr\u22172 : magic path bb(Z, Y) :\u2212 magic pathbb(X, Y), edge(X, Z).\nIn fact, the adorned rule ra1 does not produce any magic rule, since there is no adorned predicate in B+(ra1). \u2737\n(3) Modification. The adorned rules are subsequently modified by adding magic atoms to their bodies. These magic atoms limit the range of the head variables avoiding the inference of facts which cannot contribute to the derivation of the query. In particular, each adorned rule ra, whose head atom is p\u03b1(t\u0304), is modified by adding the atom magic(p\u03b1(t\u0304)) to its body. The resulting rules are called modified rules.\nExample 2.6 In our running example, the following modified rules are generated:\nr\u20321 : path bb(X, Y) :\u2212 magic pathbb(X, Y), edge(X, Y). r\u20322 : path bb(X, Y) :\u2212 magic pathbb(X, Y), edge(X, Z), pathbb(Z, Y). \u2737\n(4) Processing the Query. Finally, given the adorned predicate g\u03b1 obtained when adorning a query g(t\u0304), (1) a magic seed magic(g\u03b1(t\u0304)) (a fact) and (2) a rule g(t\u0304) :\u2212 g\u03b1(t\u0304) are produced. In our example, magic pathbb(1, 5) and path(X, Y) :\u2212 pathbb(X, Y) are generated.\nThe complete rewritten program according to the Magic Set method consists of the magic, modified, and query rules (together with the original EDB). Given a Datalog program P, a query Q, and the rewritten program P \u2032, it is well-known that P and P \u2032 are equivalent with respect to Q, i.e., P\u2261bQP\n\u2032 and P\u2261cQP \u2032 hold [63].\nExample 2.7 The complete rewriting of our running example is as follows: 3\nmagic pathbb(1, 5). path(X, Y) :\u2212 pathbb(X, Y).\nr\u22172 : magic path bb(Z, Y) :\u2212 magic pathbb(X, Y), edge(X, Z). r\u20321 : path bb(X, Y) :\u2212 magic pathbb(X, Y), edge(X, Y). r\u20322 : path bb(X, Y) :\u2212 magic pathbb(X, Y), edge(X, Z), pathbb(Z, Y).\nIn this rewriting, magic pathbb(X, Y) represents a potential sub-path of the paths from 1 to 5. Therefore, when answering the query, only these sub-paths will be actually considered in the bottom-up computation. One can check that this rewriting is in fact equivalent to the original program with respect to the query path(1, 5). \u2737"}, {"heading": "3 Magic Set Method for Datalog\u2228,\u00acs Programs", "text": "In this section we present the Dynamic Magic Set algorithm (DMS) for the optimization of disjunctive programs with stratified negation. Before discussing the details of the algorithm, we informally present the main ideas that have been exploited for enabling the Magic Set method to work on disjunctive programs (without negation)."}, {"heading": "3.1 Overview of Binding Propagation in Datalog\u2228 Programs", "text": "As first observed in [33], while in non-disjunctive programs bindings are propagated only head-to-body, a Magic Set transformation for disjunctive programs\n3 The Magic Set rewriting of a program P affects only IDB(P), so we usually omit EDB(P) in examples.\nhas to propagate bindings also head-to-head in order to preserve soundness. Roughly, suppose that a predicate p is relevant for the query, and a disjunctive rule r contains p(X) in the head. Then, besides propagating the binding from p(X) to the body of r (as in the non-disjunctive case), the binding must also be propagated from p(X) to the other head atoms of r. The reason is that any atom which is true in a stable model needs a supporting rule, which is a rule with a true body and in which the atom in question is the only true head atom. Therefore, r can yield support to the truth of p(X) only if all other head atoms are false, which is due to the implicit minimality criterion in the semantics.\nConsider, for instance, a Datalog\u2228 program P consisting of the rule p(X) \u2228 q(Y) :\u2212 a(X, Y), b(X), and the query p(1). Even though the query propagates the binding for the predicate p, in order to correctly answer the query we also need to evaluate the truth value of q(Y), which indirectly receives the binding through the body predicate a(X, Y). For instance, suppose that the program contains the facts a(1, 2) and b(1); then the atom q(2) is relevant for the query p(1) (i.e., it should belong to the Magic Set of the query), since the truth of q(2) would invalidate the derivation of p(1) from the above rule, due to the minimality of the semantics. It follows that, while propagating the binding, the head atoms of disjunctive rules must be all adorned as well.\nHowever, the adornment of the head of one disjunctive rule r may give rise to multiple rules, having different adornments for the head predicates. This process can be somehow seen as \u201csplitting\u201d r into multiple rules. While this is not a problem in the non-disjunctive case, the semantics of a disjunctive program may be affected. Consider, for instance, the program consisting of the rule p(X, Y) \u2228 q(Y, X) :\u2212 a(X, Y), in which p and q are mutually exclusive (due to minimality) since they do not appear in any other rule head. Assuming the adornments pbf and qbf to be propagated, we might obtain rules whose heads have the form pbf(X, Y) \u2228 qfb(Y, X) (derived while propagating pbf) and pfb(X, Y) \u2228 qbf(Y, X) (derived while propagating qbf). These rules could support two atoms pbf(m, n) and qbf(n, m), while in the original program p(m, n) and p(n, m) could not hold simultaneously (due to semantic minimality), thus changing the original semantics.\nThe method proposed in [33] circumvents this problem by using some auxiliary predicates that collect all facts coming from the different adornments. For instance, in the above example, two rules of the form collect p(X, Y) :\u2212 pfb(X, Y) and collect p(X, Y) :\u2212 pbf(X, Y) are added for the predicate p. The main deficiency of this approach is that collecting predicates will store a sizable superset of all the atoms relevant to answer the given query.\nAn important observation is that these collecting predicates are defined in a deterministic way. Since these predicates are used for restricting the compu-\ntation in [33], a consequence is that assumptions during the computation cannot be exploited for determining the relevant part of the program. In terms of bottom-up systems, this implies that the optimization affects only the grounding portion of the solver. Intuitively, it would be beneficial to also have a form of conditional relevance, exploiting also relevance for assumptions. In fact, in Section 5, we provide experimental evidence for this intuition.\nIn the following, we propose a novel Magic Set method that guarantees query equivalence and also allows for the exploitation of conditional or dynamic relevance, overcoming a major drawback of SMS.\n3.2 DMS Algorithm\nOur proposal to enhance the Magic Set method for disjunctive Datalog programs has two crucial features compared to the one of [33]:\n(1) First, the semantics of the program is preserved by stripping off the adornments from non-magic predicates in modified rules, and not by introducing collecting predicates that can introduce overhead in the grounding process, as discussed in Section 3.1. (2) Second, the proposed Magic Set technique is not just a way to cut irrelevant rules from the ground program; in fact, it allows for dynamic determination of relevance, thus optimizing also the nondeterministic computation by disabling parts of the programs which are not relevant in any extension of the current computation state.\nThe algorithm DMS implementing these strategies is reported in Figure 1 as pseudo-code. We assume that all variables are passed to functions by reference, in particular the variable S is modified inside BuildQuerySeed and Adorn .\nIts input is a Datalog\u2228,\u00acs program 4 P and a query Q. The algorithm uses two sets, S and D, to store adorned predicates to be propagated and already processed, respectively. After all the adorned predicates have been processed, the method outputs a rewritten program DMS(Q,P) consisting of a set of modified and magic rules, stored by means of the sets modifiedRulesQ,P and magicRulesQ,P , respectively (together with the original EDB). The main steps of the algorithm are illustrated by means of the following running example.\nExample 3.1 (Strategic Companies [15]) Let C = {c1, . . . , cm} be a collection of companies producing some goods in a set G, such that each company ci \u2208 C is controlled by a set of other companies Oi \u2286 C. A subset of the companies C \u2032 \u2286 C is a strategic set if it is a minimal set of companies satisfying the following conditions: Companies in C \u2032 produce all the goods in G; and Oi \u2286 C \u2032 implies ci \u2208 C \u2032, for each i = 1, . . . , m.\nWe assume that each product is produced by at most two companies and that each company is controlled by at most three companies. It is known that the problem retains its hardness (for the second level of the polynomial hierarchy; see [15]) under these restrictions. We assume that production of goods is represented by an EDB containing a fact produced by(p, c1, c2) for each product p produced by companies c1 and c2, and that the control is represented by facts controlled by(c, c1, c2, c3) for each company c controlled by companies c1, c2, and c3.\n5 This problem can be modeled via the following disjunctive program Psc:\nr3 : sc(C1) \u2228 sc(C2) :\u2212 produced by(P, C1, C2).\nr4 : sc(C) :\u2212 controlled by(C, C1, C2, C3), sc(C1), sc(C2), sc(C3).\nMoreover, given a company c \u2208 C, we consider a query Qsc = sc(c) asking whether c belongs to some strategic set of C. \u2737\nThe computation starts in step 1 by initializing S, D, and modifiedRulesQ,P to the empty set. Then, the function BuildQuerySeed(Q, S) is used for storing inmagicRulesQ,P the magic seed, and inserting in the set S the adorned predicate ofQ. Note that we do not generate any query rules because standard atoms in the transformed program will not contain adornments. Details of BuildQuerySeed(Q, S) are reported in Figure 2.\nExample 3.2 Given the query Qsc = sc(c) and the program Psc, function BuildQuerySeed(Qsc, S) creates the fact magic sc\nb(c) and inserts scb in S. \u2737\n4 Note that the algorithm can be used for non-disjunctive and/or positive programs as a special case. 5 If a product is produced by only one company, c2 = c1, and similarly for companies controlled by fewer than three companies.\nThe core of the algorithm (steps 3\u20138 ) is repeated until the set S is empty, i.e., until there is no further adorned predicate to be propagated. In particular, an adorned predicate p\u03b1 is moved from S to D in step 3, and its binding is propagated in each (disjunctive) rule r \u2208 P of the form\nr : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 q1(s\u03041), . . . , qj(s\u0304j),\nnot qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\n(with n \u2265 0) having an atom p(t\u0304) in the head (note that the rule r is processed a number of times that equals the number of head atoms with predicate p; steps 4\u20138 ).\n(1) Adornment. Step 5 in Figure 1 implements the adornment of the rule. Different from the case of non-disjunctive positive programs, the binding of the predicate p\u03b1 needs to be also propagated to the atoms p1(t\u03041), . . . , pn(t\u0304n) in the head. Therefore, binding propagation has to be extended to the head atoms different from p(t\u0304), which are therefore adorned according to a SIPS specifically conceived for disjunctive programs. Notation gets slightly more involved here: Since in non-disjunctive rules there is a single head atom, it was sufficient to specify an order and a function for each of its adornments (omitting the head atom in the notation). With disjunctive rules, an order and a function need to be specified for each adorned head atom, so it is no longer sufficient to include only the adornment in the notation, but we rather include the full adorned atom.\nDefinition 3.3 (SIPS for Datalog\u2228,\u00acs rules) A SIPS for a Datalog\u2228,\u00acs rule r with respect to a binding \u03b1 for an atom p(t\u0304) \u2208 H(r) is a pair (\u227ap\n\u03b1(t\u0304) r , f p\u03b1(t\u0304) r ), where:\n(1) \u227ap \u03b1(t\u0304) r is a strict partial order over the atoms in H(r) \u222a B +(r) \u222a B\u2212(r),\nsuch that: (a) p(t\u0304) \u227ap\n\u03b1(t\u0304) r q(s\u0304), for all atoms q(s\u0304) \u2208 H(r) \u222a B +(r) \u222a B\u2212(r) different from p(t\u0304);\n(b) for each pair of atoms q(s\u0304) \u2208 (H(r) \\ {p(t\u0304)}) \u222a B\u2212(r) and b(z\u0304) \u2208 H(r) \u222a B+(r) \u222a B\u2212(r), q(s\u0304) \u227ap\n\u03b1(t\u0304) r b(z\u0304) does not hold; and,\n(2) f p \u03b1(t\u0304) r is a function assigning to each atom q(s\u0304) \u2208 H(r) \u222a B +(r) \u222a B\u2212(r)\na subset of the variables in s\u0304\u2014intuitively, those made bound when processing q(s\u0304).\nAs for Datalog rules, for each atom q(s\u0304) occurring in r, the strict partial order \u227ap\n\u03b1(t\u0304) r specifies those atoms that have to be processed before processing atom q(s\u0304), and an argument X of q(s\u0304) is bound to a constant if there exists an atom q\u2032(s\u0304\u2032) occurring in r such that q\u2032(s\u0304\u2032) \u227ap\n\u03b1(t\u0304) r q(s\u0304) and X \u2208 f p\u03b1(t\u0304) r (q \u2032(s\u0304\u2032)). The difference with respect to SIPSes for Datalog rules is precisely in the dependency from p(t\u0304) in addition to \u03b1, and in condition (1.b) stating that head atoms different from p(t\u0304) and negative body literals cannot provide bindings to variables of other atoms.\nThe underlying idea is that a rule which is used to \u201cprove\u201d the truth of an atom in a top-down method will be a rule which supports that atom. This implies that all other head atoms in that rule must be false and that the body must be true. Head atoms and atoms occurring in the negative body cannot \u201ccreate\u201d bindings (that is, restrict the values of variables), but these atoms are still relevant to the query, which leads to the restrictions in Definition 3.3.\nNote that this definition considers each rule in isolation and is therefore independent of the inter-rule structure of a program. In particular, it is not\nimportant for the SIPS definition whether a program is cyclic or contains head cycles.\nIn the following, we shall assume that each Datalog\u2228,\u00acs program is provided in input together with some arbitrarily defined SIPS for Datalog\u2228,\u00acs rules (\u227ap\n\u03b1(t\u0304) r , f p\u03b1(t\u0304) r ). In fact, armed with (\u227a p\u03b1(t\u0304) r , f p\u03b1(t\u0304) r ), the adornment can be carried out precisely as we discussed for Datalog programs; in particular, we recall here that a variable X of an atom q(s\u0304) in r is bound if and only if either:\n(1) X \u2208 f p \u03b1(t\u0304)\nr (q(s\u0304)) with q(s\u0304) = p(t\u0304); or, (2) X \u2208 f p\n\u03b1(t\u0304) r (b(z\u0304)) for an atom b(z\u0304) \u2208 B +(r) such that b(z\u0304) \u227ap \u03b1(t\u0304)\nr q(s\u0304) holds.\nThe function Adorn(r, p\u03b1(t\u0304), S,D) produces an adorned disjunctive rule ra from an adorned atom p\u03b1(t\u0304) and a suitable unadorned rule r (according to the bindings defined in the points (1) and (2) above), by inserting all newly adorned predicates in S. Hence, in step 5 the rule ra is of the form\nra : p\u03b1(t\u0304) \u2228 p\u03b111 (t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 p \u03b1n n (t\u0304n) :\u2212 q \u03b21 1 (s\u03041), . . . , q \u03b2j j (s\u0304j),\nnot q \u03b2j+1 j+1 (s\u0304j+1), . . . , not q \u03b2m m (s\u0304m).\nDetails of Adorn(r, p\u03b1(t\u0304), S,D) are reported in Figure 3.\nExample 3.4 Let us resume from Example 3.2. We are supposing that the adopted SIPS is passing the bindings via produced by and controlled by to the variables of sc atoms, in particular\nsc(C1)\u227a scb(C1) r3 produced by(P, C1, C2) sc(C1)\u227a scb(C1) r3 sc(C2)\nproduced by(P, C1, C2)\u227a scb(C1) r3 sc(C2)\nsc(C2)\u227a scb(C2) r3 produced by(P, C1, C2) sc(C2)\u227a scb(C2) r3 sc(C1)\nproduced by(P, C1, C2)\u227a scb(C2) r3 sc(C1)\nsc(C) \u227asc b(C)\nr4 controlled by(C, C1, C2, C3)\nsc(C) \u227asc b(C)\nr4 sc(C1)\nsc(C) \u227asc b(C)\nr4 sc(C2)\nsc(C) \u227asc b(C)\nr4 sc(C3)\ncontrolled by(C, C1, C2, C3) \u227a scb(C) r4 sc(C1)\ncontrolled by(C, C1, C2, C3) \u227a scb(C) r4 sc(C2) controlled by(C, C1, C2, C3) \u227a scb(C) r4 sc(C3)\nf sc b(C1)\nr3 (sc(C1)) = {C1}\nf sc b(C1)\nr3 (produced by(P, C1, C2)) = {P, C2}\nf sc b(C1)\nr3 (sc(C2)) = \u2205\nf sc b(C2)\nr3 (sc(C2)) = {C2}\nf sc b(C2)\nr3 (produced by(P, C1, C2)) = {P, C1}\nf sc b(C2)\nr3 (sc(C1)) = \u2205\nf sc b(C)\nr4 (sc(C)) = {C}\nf sc b(C)\nr4 (controlled by(C, C1, C2, C3)) = {C1, C2, C3}\nf sc b(C)\nr4 (sc(C1)) = f scb(C) r4 (sc(C2)) = f scb(C) r4 (sc(C3)) = \u2205\nWhen scb is removed from the set S, we first select rule r3 and the head predicate sc(C1). Then the adorned version is\nra3,1 : sc b(C1) \u2228 sc b(C2) :\u2212 produced by(P, C1, C2).\nNext, r3 is processed again, this time with head predicate sc(C2), producing\nra3,2 : sc b(C2) \u2228 sc b(C1) :\u2212 produced by(P, C1, C2).\nFinally, processing r4 we obtain\nra4 : sc b(C) :\u2212 controlled by(C, C1, C2, C3), sc b(C1), sc b(C2), sc b(C3). \u2737\n(2) Generation. The algorithm uses the adorned rule ra for generating and collecting the magic rules in step 6 (Figure 1). More specifically, Generate(r, p\u03b1(t\u0304), ra) produces magic rules according to the following schema: if p\u03b1ii (t\u0304i) is an adorned atom (i.e., \u03b1i is not the empty string) occurring in ra and different from p\u03b1(t\u0304), a magic rule r\u2217 is generated such that (i) H(r\u2217) = {magic(p\u03b1ii (t\u0304i))} and (ii) B(r \u2217) is the union of {magic(p\u03b1(t\u0304))} and the set of all the atoms q \u03b2j j (s\u0304j) \u2208 B +(r) such that qj(s\u0304j) \u227a \u03b1 r pi(t\u0304i). Details of Generate(r, p\u03b1(t\u0304), ra) are reported in Figure 4.\nExample 3.5 Continuing with our running example, by invoking Generate(r3, sc b(C1), r a 3,1), the following magic rule is produced:\nr\u22173,1 : magic sc b(C2) :\u2212 magic sc b(C1), produced by(P, C1, C2).\nSimilarly, by invoking Generate(r3, sc b(C2), r a 3,2), the following magic rule is produced:\nr\u22173,2 : magic sc b(C1) :\u2212 magic sc b(C2), produced by(P, C1, C2).\nFinally, the following magic rules are produced by Generate(r4, sc b(C), ra4):\nr\u22174,1 : magic sc b(C1) :\u2212 magic sc b(C), controlled by(C, C1, C2, C3).\nr\u22174,2 : magic sc b(C2) :\u2212 magic sc b(C), controlled by(C, C1, C2, C3).\nr\u22174,3 : magic sc b(C3) :\u2212 magic sc b(C), controlled by(C, C1, C2, C3). \u2737\n(3) Modification. In step 7 the modified rules are generated and collected. The only difference with respect to the Datalog case is that the adornments are stripped off the original atoms. Specifically, given an adorned rule ra associated with a rule r, a modified rule r\u2032 is obtained from r by adding to its body an atommagic(p\u03b1(t\u0304)) for each atom p\u03b1(t\u0304) occurring inH(ra). Hence, the function Modify(r, ra), reported in Figure 5, constructs a rule r\u2032 of the form\nr\u2032 : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 magic(p \u03b1(t\u0304)), magic(p\u03b111 (t\u03041)), . . . ,\nmagic(p\u03b1nn (t\u0304n)), q1(s\u03041), . . . , qj(s\u0304j), not qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nFinally, after all the adorned predicates have been processed, the algorithm outputs the program DMS(Q,P).\nExample 3.6 In our running example, we derive the following set of modified rules:\nr\u20323,1 : sc(C1) \u2228 sc(C2) :\u2212 magic sc b(C1), magic sc b(C2),\nproduced by(P, C1, C2).\nr\u20323,2 : sc(C2) \u2228 sc(C1) :\u2212 magic sc b(C2), magic sc b(C1),\nproduced by(P, C1, C2).\nr\u20324 : sc(C) :\u2212 magic sc b(C), controlled by(C, C1, C2, C3),\nsc(C1), sc(C2), sc(C3).\nHere, r\u20323,1 (resp. r \u2032 3,2, r \u2032 4) is derived by adding magic predicates and stripping off adornments for the rule ra3,1 (resp. r a 3,2, r a 4). Thus, the optimized program DMS(Qsc,Psc) comprises the above modified rules as well as the magic rules in Example 3.5, and the magic seed magic scb(c) (together with the original EDB). \u2737\nBefore establishing the correctness of the technique, we briefly present an example of the application of DMS on a program containing disjunction and stratified negation.\nExample 3.7 Let us consider a slight variant of the Strategic Companies problem described in Example 3.1 in which we have to determine whether a given company c does not belong to any strategic set. We can thus consider the query nsc(c) for the program Pnsc obtained by adding to Psc the following rule:\nrnsc : nsc(C) :\u2212 company(C), not sc(C).\nwhere company is an EDB predicate. Company c does not belong to any strategic set if the query is cautiously false.\nIn this case, processing the query produces the query seed magic nscb(c) (a fact) and the adorned predicate nscb (which is added to set S). After that, nscb is moved from S to D and rule rnsc is considered. Assuming the following\nSIP:\nnsc(C) \u227ansc b(C)\nrnsc company(C) nsc(C) \u227ansc b(C) rnsc sc(C)\nf nsc b(C) rnsc (nsc(C)) = {C} f nsc b(C) rnsc (company(P)) = f nsc b(C) rnsc (sc(C)) = \u2205\nby invoking Adorn(rnsc, nsc b(C), S,D) we obtain the following adorned rule:\nransc : nsc b(C) :\u2212 company(C), not scb(C).\nThe new adorned predicate scb is added to S. Then, Generate(rnsc, nsc b(C), ransc) and Modify(rnsc, r a nsc) produce the following magic and modified rules:\nr\u2217nsc : magic sc b(C) :\u2212 magic nscb(C).\nr\u2032nsc : nsc(C) :\u2212 magic nsc b(C), company(C), not sc(C).\nThe algorithm then processes the adorned atom scb. Hence, if the SIPS presented in Example 3.4 is assumed, the rewritten program comprises the following rules: r\u2032nsc, r \u2032 3,1, r \u2032 3,2, r \u2032 4, r \u2217 nsc, r \u2217 3,1, r \u2217 3,2, r \u2217 4,1, r \u2217 4,2 and r \u2217 4,3. \u2737"}, {"heading": "3.3 Query Equivalence Result", "text": "We conclude the presentation of the DMS algorithm by formally proving its correctness. We would like to point out that all of these results hold for any kind of SIPS, as long as it conforms to Definition 3.3. Therefore, in the remainder of this section, we assume that any program comes with some associated SIPS. In the proofs, we use the well established notion of unfounded set for disjunctive Datalog programs (possibly with negation) defined in [44]. Before introducing unfounded sets, however, we have to define partial interpretations, that is, interpretations for which some atoms may be undefined.\nDefinition 3.8 (Partial Interpretation) Let P be a Datalog\u2228,\u00ac program. A partial interpretation for P is a pair \u3008T,N\u3009 such that T \u2286 N \u2286 BP . The atoms in T are interpreted as true, while the atoms in N are not false and those in N \\ T are undefined. All other atoms are false.\nNote that total interpretations are a special case in which T = N . We can then formalize the notion of unfounded set.\nDefinition 3.9 (Unfounded Sets) Let \u3008T,N\u3009 be a partial interpretation for a Datalog\u2228,\u00ac program P, and X \u2286 BP be a set of atoms. Then, X is an\nunfounded set for P with respect to \u3008T,N\u3009 if and only if, for each ground rule rg \u2208 Ground(P) with X \u2229H(rg) 6= \u2205, at least one of the following conditions holds: (1.a) B+(rg) 6\u2286 N ; (1.b) B \u2212(rg) \u2229 T 6= \u2205; (2) B +(rg) \u2229 X 6= \u2205; (3) H(rg) \u2229 (T \\X) 6= \u2205.\nIntuitively, conditions (1.a), (1.b) and (3) check if the rule is satisfied by \u3008T,N\u3009 regardless of the atoms in X , while condition (2) checks whether the rule can be satisfied by taking the atoms in X as false.\nExample 3.10 Consider again the program Psc of Example 3.1 and assume EDB(Psc) = {produced by(p, c, c1)}. Then Ground(Psc) consists of the rule\nrsc : sc(c) \u2228 sc(c1) :\u2212 produced by(p, c, c1).\n(together with facts, and rules having some ground instance of EDB predicate not occurring in EDB(Psc), omitted for simplicity). Consider now a partial interpretation \u3008Msc, BPsc\u3009 such thatMsc = {produced by(p, c, c1), sc(c)}. Thus, {sc(c1)} is an unfounded set for P with respect to \u3008Msc, BPsc\u3009 (rsc satisfies condition (3) of Definition 3.9), while {sc(c), sc(c1)} is not (rsc violates all conditions). \u2737\nThe following is an adaptation of Theorem 4.6 in [44] to our notation.\nTheorem 3.11 ([44]) Let \u3008T,N\u3009 be a partial interpretation for a Datalog\u2228,\u00ac program P. Then, for any stable model M of P such that T \u2286 M \u2286 N , and for each unfounded set X of P with respect to \u3008T,N\u3009, M \u2229X = \u2205 holds.\nExample 3.12 In Example 3.10, we have shown that {sc(c1)} is an unfounded set for P with respect to \u3008Msc, BPsc\u3009. Note that the total interpretation Msc is a stable model of Psc, and that the unfounded set {sc(c1)} is disjoint from Msc. \u2737\nEquipped with these notions and Theorem 3.11, we now proceed to prove the correctness of the DMS strategy. In particular, we shall first show that the method is sound in that, for each stable model M of DMS(Q,P), there is a stable model M \u2032 of P such that M \u2032|Q = M |Q (i.e., the two models coincide when restricted to the query). Then, we prove that the method is also complete, i.e., for each stable model M \u2032 of P, there is a stable model M of DMS(Q,P) such that M \u2032|Q = M |Q.\nIn both parts of the proof, we shall exploit the following (syntactic) relationship between the original program and the transformed one.\nLemma 3.13 Let P be a Datalog\u2228,\u00acs program, Q a query, and let magic(p\u03b1(t\u0304)) be a ground atom 6 in BDMS(Q,P) (the base of the transformed\n6 Note that in this way the lemma refers only to rules that contain a head atom\nprogram). Then the ground rule\nrg : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 q1(s\u03041), . . . , qj(s\u0304j),\nnot qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nbelongs to Ground(P) if and only if the ground rule\nr\u2032g : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 magic(p \u03b1(t\u0304)), magic(p\u03b111 (t\u03041)), . . . ,\nmagic(p\u03b1nn (t\u0304n)), q1(s\u03041), . . . , qj(s\u0304j), not qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nbelongs to Ground(DMS(Q,P)).\nProof. (\u21d2) Consider the following rule r \u2208 P such that rg = r\u03d1 for some substitution \u03d1:\nr : p(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j),\nnot qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nSince magic(p\u03b1(t\u0304)) is a ground atom in BDMS(Q,P), p \u03b1 has been inserted in the set S at some point of the Magic Set transformation, and it has eventually been used to adorn and modify r, thereby producing the following rule r\u2032 \u2208 DMS(Q,P):\nr\u2032 : p(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 magic(p \u03b1(t\u0304\u2032)), magic(p\u03b111 (t\u0304 \u2032 1)), . . . ,\nmagic(p\u03b1nn (t\u0304 \u2032 n)), q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j), not qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nClearly enough, the substitution \u03d1 mapping r into rg can also be used to map r\u2032 into r\u2032g, since the magic atoms added into the positive body of r\n\u2032 are defined over a subset of the variables occurring in head atoms.\n(\u21d0) Let r\u2032 \u2208 DMS(Q,P) be a rule such that r\u2032g = r \u2032\u03d1 for some substitution \u03d1:\nr\u2032 : p(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 magic(p \u03b1(t\u0304\u2032)), magic(p\u03b111 (t\u0304 \u2032 1)), . . . ,\nmagic(p\u03b1nn (t\u0304 \u2032 n)), q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j), not qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nBy the construction of DMS(Q,P), r\u2032 is a modified rule produced by adding some magic atom to the positive body of a rule r \u2208 P of the form:\nr : p(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j),\nnot qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nfor which a magic predicate has been generated during the transformation.\nThus, the substitution \u03d1 mapping r\u2032 to r\u2032g can also be used to map r to rg, since r and r\u2032 have the same variables. \u2737"}, {"heading": "3.3.1 Soundness of the Magic Set Method", "text": "Let us now start with the first part of the proof, in particular, by stating some further definitions and notations. Given a model M \u2032 of DMS(Q,P), and a model N \u2032 \u2286 M \u2032 of Ground(DMS(Q,P))M \u2032\n, we next define the set of atoms which are relevant for Q but are false with respect to N \u2032.\nDefinition 3.14 (Killed Atoms) Given a model M \u2032 for DMS(Q,P), and a model N \u2032 \u2286 M \u2032 of Ground(DMS(Q,P))M \u2032 , the set killedM \u2032\nQ,P(N \u2032) of the killed\natoms with respect to M \u2032 and N \u2032 is defined as:\n{k(t\u0304) \u2208 BP \\N \u2032 | either k is an EDB predicate, or\nthere is a binding \u03b1 such that magic(k\u03b1(t\u0304)) \u2208 N \u2032}.\nExample 3.15 We consider the program DMS(Qsc,Psc) presented in Section 3.2 (we recall that Qsc = sc(c)), the EDB {produced by(p, c, c1)} introduced in Example 3.10, and a stable model M \u2032sc = {produced by(p, c, c1), sc(c), magic sc\nb(c), magic scb(c1)} for DMS(Qsc,Psc). Thus, Ground(DMS(Qsc,Psc)) Msc consists of the following rules:\nmagic scb(c). magic scb(c1) :\u2212 magic sc b(c).\nsc(c) \u2228 sc(c1) :\u2212 magic sc b(c), magic scb(c1), produced by(p, c, c1).\nSince M \u2032sc is also a model of the program above, we can compute killed M \u2032sc Qsc,Psc(M \u2032 sc) and check that sc(c1) belongs to it because of magic sc\nb(c1) in M \u2032sc. Note that, by definition, also false ground instances of EDB predicates like produced by(p, c1, c) or controlled by(c, c1, c1, c1) belong to killed M \u2032sc Qsc,Psc(M \u2032 sc). Moreover, note that no other atom belongs to this set. \u2737\nThe intuition underlying the definition above is that killed atoms are either false ground instances of some EDB predicate, or false atoms which are relevant with respect to Q (for there exists an associated magic atom in the model N \u2032); since N \u2032 is a model of Ground(DMS(Q,P))M \u2032\ncontained in M \u2032, we expect that these atoms are also false in any stable model for P containing M \u2032|BP (which, we recall here, is the model M \u2032 restricted on the atoms originally occurring in P).\nExample 3.16 Let us resume from Example 3.15. We have that M \u2032sc|Psc = {produced by(p, c, c1), sc(c)}, which coincides with model Msc of Example 3.10. Hence, we already know that {sc(c1)} is an unfounded set for Psc with respect to \u3008Msc, BPsc\u3009. Since each other atom k(t\u0304) in killed M \u2032sc Qsc,Psc(M \u2032 sc)\nis such that k is an EDB predicate, we also have that killed M \u2032sc Qsc,Psc(M \u2032 sc) is an unfounded set for Psc with respect to \u3008Msc, BPsc\u3009. Therefore, as a consequence of Theorem 3.11, each stable model M of Psc such that Msc \u2286 M \u2286 BPsc (in this case only Msc itself) is disjoint from killed M \u2032sc Qsc,Psc(M \u2032 sc). \u2737\nThis intuition is formalized below.\nProposition 3.17 Let M \u2032 be a model for DMS(Q,P), and N \u2032 \u2286 M \u2032 be a model of Ground(DMS(Q,P))M \u2032 . Then, killedM \u2032\nQ,P(N \u2032) is an unfounded set for P with\nrespect to \u3008M \u2032|BP , BP\u3009.\nProof. According to Definition 3.9 of unfounded sets (for P with respect to \u3008M \u2032|BP , BP\u3009), given any rule rg in Ground(P) of the form\nrg : k(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 q1(s\u03041), . . . , qj(s\u0304j),\nnot qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nwe have to show that if k(t\u0304) \u2208 killedM \u2032 Q,P(N \u2032) \u2229H(rg), then at least one of the following conditions holds: (1.a) B+(rg) 6\u2286 BP ; (1.b) B \u2212(rg) \u2229M\n\u2032|BP 6= \u2205; (2) B+(rg) \u2229 killed M \u2032 Q,P(N \u2032) 6= \u2205; (3) H(rg) \u2229 (M \u2032|BP \\ killed M \u2032 Q,P(N \u2032)) 6= \u2205.\nNote that the properties above refer to the original program P. However, our hypothesis is formulated over the transformed one DMS(Q,P) (for instance, we know that M \u2032 is a model of DMS(Q,P)). The line of the proof is then to analyze DMS(Q,P) in the light of its syntactic relationships with P established via Lemma 3.13. In particular, recall first that, by Definition 3.14, there is a binding \u03b1 such that magic(k\u03b1(t\u0304)) \u2208 N \u2032 (and, hence, magic(k\u03b1(t\u0304)) is a ground atom in BDMS(Q,P)). Thus, we can apply Lemma 3.13 and conclude the existence of a ground rule r\u2032g \u2208 Ground(DMS(Q,P)) such that:\nr\u2032g : k(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 magic(k \u03b1(t\u0304)), magic(p\u03b111 (t\u03041)), . . . ,\nmagic(p\u03b1nn (t\u0304n)), q1(s\u03041), . . . , qj(s\u0304j), not qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nSince M \u2032 is a model of DMS(Q,P), the proof is just based on analyzing the following three scenarios that exhaustively cover all possibilities (concerning the fact that the rule r\u2032g is satisfied by M \u2032): (S1) B\u2212(r\u2032g) \u2229 M \u2032 6= \u2205, i.e., the negative body of r\u2032g is false with respect to\nM \u2032; (S2) B+(r\u2032g) 6\u2286 M \u2032, i.e., the positive body of r\u2032g is false with respect to M \u2032; (S3) B\u2212(r\u2032g) \u2229M \u2032 = \u2205, B+(r\u2032g) \u2286 M \u2032, and H(r\u2032g) \u2229M \u2032 6= \u2205, i.e., none of the\nprevious cases holds, and hence the head of r\u2032g is true with respect to M \u2032.\nIn the remaining, we shall show that (S1) implies condition (1.b), (S2) implies condition (2), and (S3) implies either (2) or (3). In fact, note that condition (1.a) cannot hold.\n(S1) Assume that B\u2212(r\u2032g) \u2229 M \u2032 6= \u2205. Since B\u2212(rg) = B \u2212(r\u2032g) and B \u2212(rg) \u2286\nBP , from B \u2212(r\u2032g) \u2229M \u2032 6= \u2205 we immediately conclude B\u2212(rg) \u2229M \u2032|BP 6= \u2205, i.e., (1.b) holds.\n(S2) Assume that B+(r\u2032g) 6\u2286 M \u2032, and let r\u2032 \u2208 DMS(Q,P) be a modified rule\nsuch that r\u2032g = r \u2032\u03d1 for some substitution \u03d1:\nr\u2032 : k(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 magic(k \u03b1(t\u0304\u2032)), magic(p\u03b111 (t\u0304 \u2032 1)), . . . ,\nmagic(p\u03b1nn (t\u0304 \u2032 n)), q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j), not qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nWe first claim that B+(r\u2032g)|BP 6\u2286 N \u2032 must hold in this case. To prove the claim, observe that during the Generation step preceding the production of r\u2032, a magic rule r\u2217i such that H(r \u2217 i ) = {magic(p \u03b1i i (t\u0304 \u2032 i))} and B\n+(r\u2217i ) \u2286 {magic(k\u03b1(t\u0304\u2032)), q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j)} has been produced for each 1 \u2264 i \u2264 n (we recall that magic rules have empty negative bodies). Hence, since the variables of r\u2217i are a subset of the variables of r\n\u2032, by applying the substitution \u03d1 to r\u2217i we obtain a ground rule r \u2217 i,g such thatH(r \u2217 i,g) = {magic(p \u03b1i i (t\u0304i))} and B+(r\u2217i,g) \u2286 {magic(k \u03b1(t\u0304)), q1(s\u03041), . . . , qj(s\u0304j)} = {magic(k\n\u03b1(t\u0304))}\u222aB+(r\u2032g)|BP . Thus, if B+(r\u2032g)|BP \u2286 N\n\u2032, from the above magic rules and since N \u2032 is a model containing magic(k\u03b1(t\u0304)) by assumption, then we would conclude that B+(r\u2032g) \u2286 N \u2032. However, this is impossible, since N \u2032 \u2286 M \u2032 and B+(r\u2032g) 6\u2286 M \u2032 imply B+(r\u2032g) 6\u2286 N \u2032.\nNow, B+(r\u2032g)|BP 6\u2286 N \u2032 implies the existence of an atom qi(s\u0304i) \u2208 B +(r\u2032g)|BP such that qi(s\u0304i) 6\u2208 N \u2032, that is, qi(s\u0304i) \u2208 BP \\N \u2032. In particular, we can assume w.l.o.g. that, for any q(s\u0304) \u2208 B+(r\u2032g)|BP with q(s\u0304 \u2032) \u227ak \u03b1(t\u0304\u2032) r qi(s\u0304 \u2032 i), it is the case that q(s\u0304) \u2208 N \u2032, where r is the rule in P from which the modified rule r\u2032 has been generated (just take a \u227ak\n\u03b1(t\u0304\u2032) r -minimum element in B +(r\u2032g)|BP \\ N \u2032).\nIf qi is an EDB predicate, the atom qi(s\u0304i) belongs to killed M \u2032 Q,P(N \u2032) by the definition of killed atoms. Otherwise, qi is an IDB predicate. In this case, there is a magic rule r\u2217i , produced during the Generation step preceding the production of r\u2032, such that H(r\u2217i ) = {magic(q \u03b2i i (s\u0304 \u2032 i))} and B(r \u2217 i ) = {magic(k\u03b1(t\u0304\u2032))} \u222a {q(s\u0304\u2032) \u2208 B+(r) | q(s\u0304\u2032) \u227ak \u03b1(t\u0304\u2032)\nr qi(s\u0304 \u2032 i)}. Thus, r \u2217 i,g = r \u2217 i \u03d1\nbelongs to Ground(DMS(Q,P)). In particular, B+(r\u2217i,g) \u2286 N \u2032 holds because magic(k\u03b1(t\u0304)) belongs to N \u2032 and by the properties of qi(s\u0304i). Therefore, since N \u2032 is a model of Ground(DMS(Q,P))M \u2032\n, magic(q\u03b2ii (s\u0304i)) belongs to N \u2032, from\nwhich qi(s\u0304i) \u2208 killed M \u2032 Q,P(N \u2032) follows from the definition of killed atoms. Thus, independently of the type (EDB, IDB) of qi, (2) holds.\n(S3) Assume that B+(r\u2032g) \u2286 M \u2032, B\u2212(r\u2032g)\u2229M \u2032 = \u2205, and H(r\u2032g)\u2229M \u2032 6= \u2205. First,\nobserve that from B\u2212(r\u2032g) \u2229 M \u2032 = \u2205 we can conclude that there is a rule in Ground(DMS(Q,P))M \u2032\nobtained from r\u2032g by removing its negative body\nliterals. Consider now the rules r\u2217i,g produced during the Generation step, for each 1 \u2264 i \u2264 n (as in (S2)). We distinguish two cases. If {q1(s\u03041), . . . , qj(s\u0304j)} \u2286 N\n\u2032, since magic(k\u03b1(t\u0304)) \u2208 N \u2032, we can conclude that B+(r\u2217i,g) \u2286 N \u2032, for each 1 \u2264 i \u2264 n. Moreover, since N \u2032 is a model of Ground(DMS(Q,P))M \u2032\n, the latter implies that magic(p\u03b1ii (t\u0304i)) \u2208 N \u2032, for each\n1 \u2264 i \u2264 n. Then B+(r\u2032g) \u2286 N \u2032 holds, and so H(r\u2032g) \u2229N \u2032 6= \u2205 (because N \u2032 is a model of Ground(DMS(Q,P))M \u2032\n). We now observe that H(r\u2032g) \u2229 (M \u2032|BP \\\nkilledM \u2032 Q,P(N \u2032)) 6= \u2205 is equivalent to (H(r\u2032g) \u2229 M \u2032|BP ) \\ killed M \u2032 Q,P(N \u2032) 6= \u2205. Moreover, the latter is equivalent to (H(rg)\u2229M \u2032)\\killedM \u2032 Q,P(N \u2032) 6= \u2205 because H(r\u2032g) contains only standard atoms and H(r \u2032 g) = H(rg). In addition, from N \u2032 \u2286 M \u2032 we conclude H(rg) \u2229 N \u2032 \u2286 H(rg) \u2229 M\n\u2032, and by Definition 3.14, N \u2032\u2229killedM \u2032\nQ,P(N \u2032) = \u2205 holds. Hence, (H(rg)\u2229M \u2032)\\killedM \u2032 Q,P(N \u2032) \u2287 H(rg)\u2229\nN \u2032, which is not empty, and so condition (3) holds. Otherwise, {q1(s\u03041), . . . , qj(s\u0304j)} 6\u2286 N\n\u2032. Let i \u2208 {1, . . . , j} be such that qi(s\u0304i) 6\u2208 N \u2032 and, for any q(s\u0304) \u2208 B+(r\u2032g)|BP , q(s\u0304 \u2032) \u227ak \u03b1(t\u0304\u2032) r qi(s\u0304 \u2032 i) implies q(s\u0304) \u2208 N \u2032 (where r is the rule in P from which the modified rule r\u2032 has been generated). If qi is an EDB predicate, the atom qi(s\u0304i) belongs to killedM \u2032\nQ,P(N \u2032) by the definition of killed atoms. Otherwise, qi is an IDB\npredicate and there is a magic rule r\u2217i,g \u2208 Ground(DMS(Q,P)) having an atom magic(q\u03b2ii (s\u0304i)) in head, and such that B +(r\u2217i,g) \u2286 N \u2032. Therefore, magic(q\u03b2ii (s\u0304i)) belongs to N \u2032, from which qi(s\u0304i) \u2208 killed M \u2032 Q,P(N \u2032) follows from the definition of killed atoms. Thus, independently of the type (EDB, IDB) of qi, (2) holds. \u2737\nWe can now complete the first part of the proof.\nLemma 3.18 For each stable model M \u2032 of DMS(Q,P), there is a stable model M of P such that M \u2287 M \u2032|BP .\nProof. Let M be a stable model of P \u222a M \u2032|BP , the program obtained by adding to P a fact for each atom in M \u2032|BP . We shall show that M is in fact a stable model of P such that M \u2287 M \u2032|BP . Of course, M is a model of P such that M \u2287 M \u2032|BP . So, the line of the proof is to show that if M is not stable, then it is possible to build a model N \u2032 of Ground(DMS(Q,P))M \u2032\nsuch that N \u2032 \u2282 M \u2032, thereby contradicting the minimality of M \u2032 over the models of Ground(DMS(Q,P))M \u2032 .\nAssume, for the sake of contradiction, thatM is not stable and letN \u2282 M be a model ofGround(P)M . DefineN \u2032 as the interpretation (N\u2229M \u2032|BP )\u222a(M\n\u2032\\BP). By construction, note thatN \u2032 \u2286 M \u2032, sinceM \u2032 coincides withM \u2032|BP\u222a(M\n\u2032\\BP). In fact, in the case where N \u2032 = M \u2032, we would have that N \u2287 M \u2032|BP , since (N \u2229M \u2032|BP ) and (M\n\u2032 \\BP) are disjoint. Hence, N would not only be a model for Ground(P)M but also a model for Ground(P \u222a M \u2032|BP )\nM , while on the other hand N \u2282 M holds. However, this is impossible, since M is a stable\nmodel of P \u222a M \u2032|BP . So, N \u2032 \u2282 M \u2032 must hold. Hence, to complete the proof and get a contradiction, it remains to show that N \u2032 is actually a model of Ground(DMS(Q,P))M \u2032 , i.e., it satisfies all the rules in Ground(DMS(Q,P))M \u2032\n. To this end, we have to consider the following two kinds of rules:\n(1) Consider a ground magic rule r\u2217g \u2208 Ground(DMS(Q,P)) M \u2032 such that\nB+(r\u2217g) \u2286 N \u2032, and let magic(p\u03b1(t\u0304)) be the (only) atom in H(r\u2217g). Since N \u2032 \u2282 M \u2032, B+(r\u2217g) \u2286 N \u2032 implies that B+(r\u2217g) \u2282 M\n\u2032. In fact, since M \u2032 is a model of DMS(Q,P) and |H(r\u2217g)| = 1, magic(p\n\u03b1(t\u0304)) \u2208 M \u2032 must hold (we recall that B\u2212(r\u2217g) = \u2205). Moreover, since BP does not contain any magic atom, magic(p\u03b1(t\u0304)) is also contained in M \u2032 \\BP . Thus, by the construction of N \u2032, we can conclude that H(r\u2217g) \u2229N \u2032 6= \u2205.\n(2) Consider a rule obtained by removing the negative literals from a ground modified rule r\u2032g \u2208 Ground(DMS(Q,P)) where\nr\u2032g : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 magic(p \u03b1(t\u0304)), magic(p\u03b111 (t\u03041)), . . . ,\nmagic(p\u03b1nn (t\u0304n)), q1(s\u03041), . . . , qj(s\u0304j), not qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nand where B+(r\u2032g) \u2286 N \u2032. Observe that B\u2212(r\u2032g) \u2229 M \u2032 = \u2205 holds by the definition of reduct. Moreover, let rg be the rule of Ground(P) associated with r\u2032g (according to Lemma 3.13):\nrg : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 q1(s\u03041), . . . , qj(s\u0304j),\nnot qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nWe have to show that H(r\u2032g)\u2229N \u2032 6= \u2205. The proof is based on establishing\nthe following properties on r\u2032g and rg:\n\u2022 M \u2229 killedM \u2032 Q,P(M \u2032) = \u2205; (1)\n\u2022 (H(r\u2032g) \\M \u2032) \u2229M = \u2205; (2)\n\u2022 B\u2212(r\u2032g) \u2229M = \u2205; (3)\n\u2022 H(r\u2032g) \u2229M \u2032 = H(r\u2032g) \u2229M \u2032|BP = H(r \u2032 g) \u2229M ; (4)\n\u2022 H(rg) \u2229N 6= \u2205. (5)\nIn particular, we shall directly prove (1), and show the following implications: (1)\u2192(2)\u2227(3), (2)\u2192(4), and (3)\u2192(5). Eventually, based on (4) and (5), the fact that H(r\u2032g) \u2229 N\n\u2032 6= \u2205 can be easily derived as follows: Since H(rg) \u2286 BP , by the definition of N\n\u2032 we can conclude that H(rg)\u2229N \u2032 = H(rg)\u2229 (N \u2229M \u2032|BP ) = (H(rg)\u2229N)\u2229 (H(rg)\u2229M\n\u2032|BP ). Moreover, because of (4) and the fact that H(rg) = H(r \u2032 g), H(rg) \u2229N \u2032 coincides\nin turn with (H(rg) \u2229 N) \u2229 (H(rg) \u2229M). Then, recall that N \u2282 M . Thus, H(rg) \u2229N\n\u2032 = H(rg) \u2229N , which is not empty by (5). In order to complete the proof, we have to show that all the above equa-\ntions actually hold.\nProof of (1). We recall that, by Proposition 3.17, we already know that killedM \u2032\nQ,P(M \u2032) is an unfounded set for P with respect to \u3008M \u2032|BP , BP\u3009. In fact,\none may notice that killedM \u2032 Q,P(M \u2032) is an unfounded set for P \u222aM \u2032|BP with respect to \u3008M \u2032|BP , BP\u3009 too, since the rules added to P are facts corresponding to the atoms inM \u2032|BP andM \u2032|BP\u2229killed M \u2032 Q,P(M \u2032) = \u2205 by Definition 3.14. Thus, since M \u2287 M \u2032|BP and M is a stable model of P\u222aM \u2032|BP , we can apply Theorem 3.11 in order to conclude that M \u2229 killedM \u2032\nQ,P(M \u2032) = \u2205.\nProof of (2). After (1), we can just show that H(r\u2032g)\\M \u2032 \u2286 killedM\n\u2032\nQ,P(M \u2032).\nIn fact, since N \u2032 \u2282 M \u2032, we note that B+(r\u2032g) \u2286 N \u2032 implies B+(r\u2032g) \u2282 M \u2032. Thus, H(r\u2032g) \\M \u2032 \u2286 killedM \u2032 Q,P(M \u2032) follows by Definition 3.14 and the form of rule r\u2032g.\nProof of (3). After (1), we can just show that B\u2212(r\u2032g) \u2286 killed M \u2032 Q,P(M \u2032).\nActually, we show that the IDB atoms in B\u2212(r\u2032g) belong to killed M \u2032 Q,P(M \u2032), as EDB atoms in B\u2212(r\u2032g) clearly belong to killed M \u2032 Q,P(M \u2032) because B\u2212(r\u2032g) \u2229 M \u2032 = \u2205 by assumption. To this end, consider a modified rule r\u2032 \u2208 DMS(Q,P) such that r\u2032g = r \u2032\u03d1 for some substitution \u03d1:\nr\u2032 : p(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 magic(p \u03b1(t\u0304\u2032)), magic(p\u03b111 (t\u0304 \u2032 1)), . . . ,\nmagic(p\u03b1nn (t\u0304 \u2032 n)), q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j), not qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nDuring the Generation step preceding the production of r\u2032, a magic rule r\u2217i with H(r\u2217i ) = {magic(q \u03b2i i (s\u0304 \u2032 i))} and where B +(r\u2217i ) \u2286 B +(r\u2032) has been produced for each j+1 \u2264 i \u2264 m such that qi is an IDB predicate. Hence, since the variables of r\u2217i are a subset of the variables of r\n\u2032, the substitution \u03d1 can be used to map r\u2217i to a ground rule r \u2217 i,g = r \u2217 i \u03d1 with H(r \u2217 i,g) = {magic(q \u03b2i i (s\u0304i))} and B+(r\u2217i,g) \u2286 B +(r\u2032g). Now, since B +(r\u2032g) \u2286 N \u2032 \u2282 M \u2032, we can conclude that B+(r\u2217i,g) is in turn contained in M \u2032. Thus, the head of r\u2217i,g must be true with respect to M \u2032 (we recall that magic rules have empty negative bodies). That is, magic(q\u03b2ii (s\u0304i)) \u2208 M\n\u2032 holds, for each j+1 \u2264 i \u2264 m such that qi is an IDB predicate. Moreover, B\u2212(r\u2032g) \u2229M \u2032 = \u2205 implies that q\u03b2ii (s\u0304i) \u2208 BP \\M \u2032, as q\u03b2ii (s\u0304i) \u2208 B \u2212(r\u2032g). Thus, by Definition 3.14, q \u03b2i i (s\u0304i) \u2208 killed M \u2032 Q,P(M \u2032).\nProof of (4). The property immediately follows from (2) and the fact that H(r\u2032g) \u2286 BP and M \u2287 M \u2032|BP .\nProof of (5). Note that B\u2212(rg) = B \u2212(r\u2032g), and so (3) implies that there is a rule in Ground(P)M obtained from rg by removing the atoms in B \u2212(rg). Note also that B+(rg) = B +(r\u2032g) \u2229 BP \u2286 N \u2032 \u2229 BP (since B +(r\u2032g) \u2286 N\n\u2032). Thus, by the definition of N \u2032, B+(rg) \u2286 N (more specifically, B +(rg) \u2286\nN\u2229M \u2032|BP ). Moreover, since N is a model of Ground(P) M , the latter entails that H(rg) \u2229N 6= \u2205. \u2737\nTheorem 3.19 Let Q be a query for a Datalog\u2228,\u00acs program P. Then, for each stable model M \u2032 of DMS(Q,P), there is a stable model M of P such that M \u2032|Q = M |Q.\nProof. Because of Lemma 3.18, for each stable model M \u2032 of DMS(Q,P), there is a stable model M of P such that M \u2287 M \u2032|BP . Thus, we trivially have that M |Q \u2287 M \u2032|Q holds. We now show that the inclusion cannot be proper.\nIn fact, by the definition of DMS(Q,P), the magic seed is associated to any ground instance of Q. Then BP |Q \\ M \u2032 \u2286 killedM \u2032 Q,P(M \u2032) by Definition 3.14 (we recall that BP |Q denotes the ground instances of Q). By Proposition 3.17, killedM \u2032\nQ,P(M \u2032) is an unfounded set for P with respect to \u3008M \u2032|BP , BP\u3009. Hence,\nby Theorem 3.11, we have that M \u2229 killedM \u2032 Q,P(M \u2032) = \u2205. It follows that M \u2229 (BP |Q\\M \u2032) = \u2205. Thus, M |Q\\M \u2032|Q = \u2205, which combined with M |Q \u2287 M \u2032|Q implies M |Q = M \u2032|Q. \u2737"}, {"heading": "3.3.2 Completeness of the Magic Set Method", "text": "For the second part of the proof, we construct an interpretation for DMS(Q,P) based on one for P.\nDefinition 3.20 (Magic Variant) Let I be an interpretation for P. We define an interpretation variant\u221eQ,P(I) for DMS(Q,P), called the magic variant of I with respect to Q and P, as the limit of the following sequence:\nvariant0Q,P(I) = EDB(P); and\nvarianti+1Q,P(I) = variant i Q,P(I) \u222a\n{p(t\u0304) \u2208 I | there is a binding \u03b1 such that\nmagic(p\u03b1(t\u0304)) \u2208 variantiQ,P(I)} \u222a\n{magic(p\u03b1(t\u0304)) | \u2203 r\u2217g \u2208 Ground(DMS(Q,P)) such that\nmagic(p\u03b1(t\u0304)) \u2208 H(r\u2217g) and B +(r\u2217g) \u2286 variant i Q,P(I)}, \u2200i \u2265 0.\nExample 3.21 Consider the program DMS(Qsc,Psc) presented in Section 3.2, the EDB {produced by(p, c, c1)} and the interpretation Msc = {produced by(p, c, c1), sc(c)}. We next compute the magic variant variant\u221eQsc,Psc(Msc) of Msc with respect to Qsc and Psc. We start the sequence with the original EDB: variant0Qsc,Psc(Msc) = {produced by(p, c, c1)}. For variant1Qsc,Psc(Msc), we add magic sc\nb(c) (the query seed), while for variant2Qsc,Psc(Msc), we add sc(c) (because sc(c) \u2208 Msc and\nmagic scb(c) \u2208 variant0Qsc,Psc(Msc)), and magic sc b(c1) (because magic scb(c1) :\u2212 magic sc b(c). is a rule of Ground(DMS(Qsc,Psc)) and magic scb(c) \u2208 variant0Qsc,Psc(Msc)). Any other element of the sequence coincides with variant2Qsc,Psc(Msc), and so also variant \u221e Qsc,Psc(Msc). \u2737\nBy definition, for a magic variant variant\u221eQ,P(I) of an interpretation I with respect toQ and P, variant\u221eQ,P(I)|BP \u2286 I holds. More interestingly, the magic variant of a stable model for P is in turn a stable model for DMS(Q,P).\nExample 3.22 The magic variant ofMsc with respect toQsc and Psc (see Example 3.21) coincides with the interpretation M \u2032sc introduced in Example 3.15. From previous examples, we know that Msc is a stable model of Psc, and M \u2032 sc is a stable model of DMS(Qsc,Psc). \u2737\nThe following two lemmas formalize the intuition above, with the latter being the counterpart of Lemma 3.18.\nLemma 3.23 For each stable model M of P, the magic variant M \u2032 = variant\u221eQ,P(M) of M is a model of Ground(DMS(Q,P)) M \u2032 with M \u2287 M \u2032|BP .\nProof. As M \u2032 is the magic variant of the stable model M , we trivially have that M \u2287 M \u2032|BP holds. We next show that M\n\u2032 is a model of Ground(DMS(Q,P))M \u2032 . To this end, consider a rule in Ground(DMS(Q,P))M \u2032 having the body true, that is, a rule obtained by removing the negative body literals from a rule r\u2032g \u2208 Ground(DMS(Q,P)) such that B \u2212(r\u2032g) \u2229M \u2032 = \u2205 and B+(r\u2032g) \u2286 M \u2032 hold. We have to show that H(r\u2032g) \u2229M \u2032 6= \u2205.\nIn the case where r\u2032g is a magic rule, then B +(r\u2032g) \u2286 M \u2032 implies that the (only) atom inH(r\u2032g) belongs toM\n\u2032 (by Definition 3.20). The only remaining (slightly more involved) case to be analyzed is where r\u2032g is a modified rule of the form\nr\u2032g : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 magic(p \u03b1(t\u0304)), magic(p\u03b111 (t\u03041)), . . . ,\nmagic(p\u03b1nn (t\u0304n)), q1(s\u03041), . . . , qj(s\u0304j), not qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nIn this case, we first apply as usual Lemma 3.13 in order to conclude the existence of a rule rg \u2208 Ground(P) of the form\nrg : p(t\u0304) \u2228 p1(t\u03041) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304n) :\u2212 q1(s\u03041), . . . , qj(s\u0304j),\nnot qj+1(s\u0304j+1), . . . , not qm(s\u0304m).\nThen, we claim that the following two properties hold:\n\u2022 B\u2212(rg) \u2229M = \u2205; (6)\n\u2022 B+(rg) \u2286 M. (7)\nThese properties are in fact what we just need to establish the result. Indeed, since M is a model of Ground(P)M , (6) and (7) imply H(rg) \u2229 M 6= \u2205. So, we can recall that H(rg) = H(r \u2032 g), and hence let pi(t\u0304i) be an atom in H(rg)\u2229M = H(r \u2032 g)\u2229M and magic(p \u03b1i i (t\u0304i)) be its corresponding magic atom in B+(r\u2032g) (i \u2208 {\u01eb, 1, . . . , n}, where \u01eb is the empty string). Since B +(r\u2032g) \u2286 M \u2032 (by hypothesis) and since pi(t\u0304i) \u2208 M , we can then conclude that pi(t\u0304i) is in M \u2032 as well by Definition 3.20. That is, H(r\u2032g) \u2229M \u2032 6= \u2205.\nLet now finalize the proof, by showing that the above properties actually hold.\nProof of (6). Consider a modified rule r\u2032 \u2208 DMS(Q,P) such that r\u2032g = r \u2032\u03d1 for a substitution \u03d1:\nr\u2032 : p(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 magic(p \u03b1(t\u0304\u2032)), magic(p\u03b111 (t\u0304 \u2032 1)), . . . ,\nmagic(p\u03b1nn (t\u0304 \u2032 n)), q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j), not qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nand the rule r \u2208 P from which r\u2032 is produced (such that rg = r\u03d1):\nr : p(t\u0304\u2032) \u2228 p1(t\u0304 \u2032 1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 pn(t\u0304 \u2032 n) :\u2212 q1(s\u0304 \u2032 1), . . . , qj(s\u0304 \u2032 j),\nnot qj+1(s\u0304 \u2032 j+1), . . . , not qm(s\u0304 \u2032 m).\nDuring the Generation step preceding the production of r\u2032, a magic rule r\u2217i such that H(r\u2217i ) = {magic(q \u03b2i i (s\u0304 \u2032 i))} has been produced for each j + 1 \u2264 i \u2264 m such that qi is an IDB predicate. Hence, since the variables of r \u2217 i are a subset of the variables of r\u2032, the substitution \u03d1 can be used to map r\u2217i to a ground rule r\u2217i,g = r \u2217 i \u03d1 such that H(r \u2217 i,g) = {magic(q \u03b2i i (t\u0304i))} and B\n+(r\u2217i,g) \u2286 B+(r\u2032g) (we recall that magic rules have empty negative body). Now, since B+(r\u2032g) \u2286 M \u2032, we can conclude that B+(r\u2217i,g) is in turn contained in M \u2032. Thus, by the construction of M \u2032, the head of r\u2217i,g must be true with respect to M \u2032, that is, magic(q\u03b2ii (t\u0304i)) \u2208 M \u2032 holds for each j + 1 \u2264 i \u2264 m such that qi is an IDB predicate. So, if some (IDB) atom qi(s\u0304i) \u2208 B \u2212(rg) belongs to M , by Definition 3.20 we can conclude that qi(s\u0304i) \u2208 M \u2032, which contradicts the assumption that B\u2212(r\u2032g) \u2229 M \u2032 = \u2205 (we recall that B\u2212(rg) = B\n\u2212(r\u2032g)). This proves that IDB predicates in B\u2212(rg) do not occur in M . The same trivially holds for EDB predicates too, since B\u2212(rg) \u2229 M \u2032 = B\u2212(r\u2032g) \u2229 M \u2032 = \u2205 and M \u2032 \u2287 EDB(P) (by the definition of magic variant).\nProof of (7). The equation straightforwardly follows from the fact that B+(rg) = B +(r\u2032g)|BP , and sinceM \u2287 M \u2032|BP and B +(r\u2032g) \u2286 M \u2032 hold by the construction of M \u2032 and by the initial hypothesis on the choice of r\u2032g, respectively. \u2737\nLemma 3.24 For each stable model M of P, there is a stable model M \u2032 of DMS(Q,P) (which is the magic variant of M) such that M \u2287 M \u2032|BP .\nProof. After Lemma 3.23, we can show that M \u2032 = variant\u221eQ,P(M) is also minimal over all the models of Ground(DMS(Q,P))M \u2032\n. Let N \u2032 \u2286 M \u2032 be a minimal model of Ground(DMS(Q,P))M \u2032\n. We prove by induction on the definition of the magic variant that M \u2032 is in turn contained in N \u2032. The base case (i.e., variant0Q,P(M) \u2286 N \u2032) is clearly true, since variant0Q,P(M) contains only EDB facts. Suppose variantiQ,P(M) \u2286 N \u2032 in order to prove that varianti+1Q,P(M) \u2286 N \u2032 holds as well.\nWhile considering an atom in varianti+1Q,P(M)\\variant i Q,P(M), we distinguish two cases:\n(a) For a magic atom magic(p\u03b1(t\u0304)) in varianti+1Q,P(M) \\ variant i Q,P(M), by\nDefinition 3.20 there must be a rule r\u2217g \u2208 Ground(DMS(Q,P)) having H(r\u2217g) = {magic(p \u03b1(t\u0304))} and B+(r\u2217g) \u2286 variant i Q,P(M) (we recall that magic rules have empty negative body and so r\u2217g \u2208 Ground(DMS(Q,P)) M \u2032 holds). We can then conclude that B+(r\u2217g) \u2286 N \u2032 holds by the induction hypothesis and so magic(p\u03b1(t\u0304)) \u2208 N \u2032 (because N \u2032 is a model of Ground(DMS(Q,P))M \u2032\n). (b) For a standard atom p(t\u0304) in varianti+1Q,P(M) \\ variant i Q,P(M), by Defi-\nnition 3.20 there is a binding \u03b1 such that magic(p\u03b1(t\u0304)) \u2208 variantiQ,P(M) and the atom p(t\u0304) belongs to M . Assume for the sake of contradiction that p(t\u0304) 6\u2208 N \u2032. Since M \u2032 is a model of DMS(Q,P) and N \u2032 is a model of Ground(DMS(Q,P))M \u2032 , we can compute the set killedM \u2032\nQ,P(N \u2032) as introduced\nin Section 3.3.1 and note, in particular, that p(t\u0304) \u2208 killedM \u2032 Q,P(N \u2032) holds (by definition). Moreover, by Proposition 3.17, killedM \u2032\nQ,P(N \u2032) is an unfounded set\nfor P with respect to \u3008M \u2032|BP , BP\u3009. In addition, M \u2287 M \u2032|BP holds by Definition 3.20. Thus, M is a stable model for P such thatM \u2287 M \u2032|BP , and we can hence apply Theorem 3.11 in order to conclude that M \u2229killedM \u2032\nQ,P(N \u2032) = \u2205.\nThe latter is in contradiction with p(t\u0304) \u2208 killedM \u2032 Q,P(N \u2032) and p(t\u0304) \u2208 M . Hence, p(t\u0304) \u2208 N \u2032. \u2737\nWe can then prove the correspondence of stable models with respect to queries.\nTheorem 3.25 Let Q be a query for a Datalog\u2228,\u00acs program P. Then, for each stable model M of P, there is a stable model M \u2032 of DMS(Q,P) (which is the magic variant of M) such that M \u2032|Q = M |Q.\nProof. Let M be a stable model of P and M \u2032 = variant\u221eQ,P(M) its magic variant. Because of Lemma 3.24, M \u2032 is a stable model of DMS(Q,P) such that M \u2287 M \u2032|BP . Thus, we trivially have that M |Q \u2287 M\n\u2032|Q holds. We now show the reverse inclusion.\nSince M \u2032 is a stable model of DMS(Q,P), we can determine the set killedM \u2032\nQ,P(M \u2032) as defined in Section 3.3.1. Hence, by Definition 3.14 we can\nconclude that (a) BP |Q \\M \u2032 \u2286 killedM\n\u2032\nQ,P(M \u2032) because M \u2032 contains the magic\nseed by construction (we recall that BP |Q denotes the ground instances of Q). Moreover, since M is a stable model of P with M \u2287 M \u2032|BP and killed M \u2032 Q,P(M \u2032) is an unfounded set for P with respect to \u3008M \u2032|BP , BP\u3009 by Proposition 3.17, we can conclude that (b) M \u2229 killedM \u2032\nQ,P(M \u2032) = \u2205 by Theorem 3.11. Thus, by\ncombining (a) and (b) we obtain that (BP |Q\\M \u2032)\u2229M = \u2205, which is equivalent to M |Q \u2286 M \u2032|Q. \u2737\nFinally, we show the correctness of the Magic Set method with respect to query answering, that is, we prove that the original and rewritten programs provide the same answers for the input query on all possible EDBs.\nTheorem 3.26 Let P be a Datalog\u2228,\u00acs program, and let Q be a query. Then DMS(Q,P)\u2261bQP and DMS(Q,P)\u2261 c QP hold.\nProof. We want to show that, for any set of facts F defined over the EDB predicates of P (and DMS(Q,P)), Ansb(Q, DMS(Q,P) \u222a F) = Ansb(Q,P \u222a F) and Ansc(Q, DMS(Q,P) \u222a F) = Ansc(Q,P \u222a F) hold. We first observe that the Magic Set rewriting does not depend on EDB facts; thus, DMS(Q,P) \u222a F = DMS(Q,P \u222a F) holds. Moreover, note that Datalog\u2228,\u00acs programs always have stable models. Therefore, as a direct consequence of Theorem 3.19 and Theorem 3.25, we can conclude Ansb(Q, DMS(Q,P \u222a F)) = Ansb(Q,P \u222a F) and Ansc(Q, DMS(Q,P \u222a F)) = Ansc(Q,P \u222a F). \u2737"}, {"heading": "3.4 Magic Sets for Stratified Datalog Programs without Disjunction", "text": "Stratified Datalog programs without disjunction have exactly one stable model [29]. However, the Magic Set transformation can introduce new dependencies between predicates, possibly resulting in unstratified programs (we refer to the analysis in [38]). Clearly, original and rewritten programs agree on the query, as proved in the previous section, but the question whether the rewritten program admits a unique stable model is also important. In fact, for programs having the unique stable model property, brave and cautious reasoning coincide and a solver can immediately answer the query after the first (and unique) stable model is found. The following theorem states that the rewritten program of a stratified program indeed has a unique stable model.\nTheorem 3.27 Let P be a disjunction-free Datalog program with stratified negation and Q a query. Then DMS(Q,P) has a unique stable model.\nProof. Let M be the unique stable model of P, and M \u2032 = variant\u221eQ,P(M) its magic variant as presented in Definition 3.20. By Lemma 3.24 we already\nknow that M \u2032 is a stable model of DMS(Q,P). We now show that any stable model N \u2032 of DMS(Q,P) contains M \u2032 by induction on the structure of M \u2032. The base case (variant0Q,P(M) \u2286 N \u2032) is clearly true, since variant0Q,P(M) contains only EDB facts. Suppose variantiQ,P(M) \u2286 N \u2032 in order to prove that varianti+1Q,P(M) \u2286 N \u2032 holds as well. Thus, while considering an atom in varianti+1Q,P(M) \\ variant i Q,P(M), two cases are possible:\n(1) For a magic atom magic(p\u03b1(t\u0304)) in varianti+1Q,P(M) \\ variant i Q,P(M), by\nDefinition 3.20 there must be a rule r\u2217g \u2208 Ground(DMS(Q,P)) having H(r\u2217g) = {magic(p \u03b1(t\u0304))} and B+(r\u2217g) \u2286 variant i Q,P(M) (we recall that magic rules have empty negative bodies and so r\u2217g \u2208 Ground(DMS(Q,P)) N \u2032 holds). We can then conclude that B+(r\u2217g) \u2286 N \u2032 holds by the induction hypothesis and so magic(p\u03b1(t\u0304)) \u2208 N \u2032 (because N \u2032 is a model of Ground(DMS(Q,P))N \u2032\n). (2) For a standard atom p(t\u0304) in varianti+1Q,P(M) \\ variant i Q,P(M), by Defi-\nnition 3.20 there is a binding \u03b1 such that magic(p\u03b1(t\u0304)) \u2208 variantiQ,P(M) and the atom p(t\u0304) belongs to M . Assume for the sake of contradiction that p(t\u0304) 6\u2208 N \u2032. Since N \u2032 is a stable model of DMS(Q,P), we can compute the set killedN \u2032\nQ,P(N \u2032) as introduced in Section 3.3.1 and note, in particular, that\np(t\u0304) \u2208 killedN \u2032 Q,P(N \u2032) holds, by definition. Moreover, by Proposition 3.17, killedN \u2032\nQ,P(N \u2032) is an unfounded set for P with respect to \u3008N \u2032|BP , BP\u3009. In ad-\ndition, by Lemma 3.25 there is a stable model N of P such that N \u2287 N \u2032|BP , which would mean that p(t\u0304) 6\u2208 N holds. Hence, we can conclude that N and M are two different stable models of P, obtaining a contradiction, as P has a unique stable model.\nSince stable models are incomparable with respect to containment, M \u2032 \u2286 N \u2032 implies M \u2032 = N \u2032. Hence, M \u2032 is the unique stable model of DMS(Q,P). \u2737"}, {"heading": "4 Implementation", "text": "The Dynamic Magic Set method (DMS) has been implemented and integrated into the core of the DLV [43] system. In this section, we shall first briefly describe the architecture of the system and its usage. We then briefly present an optimization for eliminating redundant rules, which are sometimes introduced during the Magic Set rewriting."}, {"heading": "4.1 System Architecture and Usage", "text": "We have created a prototype system by implementing the Magic Set technique described in Section 3 inside DLV, as shown in the architecture reported in Figure 6. DLV supports both brave and cautious reasoning, and for a completely ground query it can be also used for computing all stable models in which the query is true. DLV performs brave reasoning if invoked with the command-line option -FB, while -FC indicates cautious reasoning.\nIn our prototype, the DMS algorithm is applied automatically by default when the user invokes DLV with -FB or -FC together with a (partially) bound query. Magic Sets are not applied by default if the query does not contain any constant. The user can modify this default behavior by specifying the commandline options -ODMS (for applying Magic Sets) or -ODMS- (for disabling Magic Sets).\nIf a completely bound query is specified, DLV can print the magic variant of the stable model (not displaying magic predicates), which witnesses the truth (for brave reasoning) or the falsity (for cautious reasoning) of the query, by specifying the command-line option --print-model.\nWithin DLV, DMS is applied immediately after parsing the program and the query by the Magic Set Rewriter module. The rewritten (and optimized as described in Section 4.2) program is then processed by the Intelligent Grounding module and the Model Generator module using the implementation of DLV. The only other modification is for the output and its filtering: For ground queries, the witnessing stable model is no longer printed by default, but only if --print-model is specified, in which case the magic predicates are omitted from the output.\nThe SIPS schema 7 implemented in the prototype is as follows: For a rule r, head atom p(t\u0304) and binding \u03b1, \u227ap\n\u03b1(t\u0304) r satisfies the conditions of Definition 3.3,\nin particular p(t\u0304) \u227ap \u03b1(t\u0304) r q(s\u0304) holds for all q(s\u0304) 6= p(t\u0304) in r, and q(s\u0304) 6\u227a p\u03b1(t\u0304) r b(z\u0304) holds for all head or negative body atoms q(s) 6= p(t\u0304) and any atom b(z\u0304) in r. Moreover, all the positive body literals of r form a chain in \u227ap\n\u03b1(t\u0304) r . This chain\nis constructed by iteratively inserting those atoms containing most bound arguments (considering \u03b1 and also the partially formed chain and f p\n\u03b1(t\u0304) r ) into\nthe chain. Among the atoms with most bindings an arbitrary processing order (usually the order appearing in the original rule body) is used. Furthermore, f p\n\u03b1(t\u0304) r (q(s\u0304)) = X holds if and only if q(s\u0304) belongs to the positive body of r, has at least one bound argument and X occurs in s\u0304."}, {"heading": "7 Since technically a SIPS has a definition for every single rule, implementations", "text": "use a schema for creating the SIPS for a given rule.\nThis means that apart from the head atom via which the rule is adorned, only positive body atoms can yield variable bindings and only if at least one of their arguments is bound, but both atoms with EDB and IDB predicates can do so. Moreover, atoms with more bound arguments will be processed before those with fewer bound arguments.\nNote that in this work we did not study the impact of trying different SIPS schemas, as we wanted to focus on showing the impact that our technique can have, rather than fine-tuning its parameters. While we believe that the SIPS schema employed is well-motivated, there probably is quite a bit of room for improvement, which we leave for future work.\nAn executable of the DLV system supporting the Magic Set optimization is available at http://www.dlvsystem.com/magic/."}, {"heading": "4.2 Dealing with Redundant Rules", "text": "Even though our rewriting algorithm keeps the amount of generated rules low, it might happen that some redundant rules are generated when adorning disjunctive rules, thereby somewhat deteriorating the optimization effort. For\ninstance, in Example 3.6 the first two modified rules are semantically equivalent, and this might happen even if the two head predicates differ. In general not only duplicated rules might be created, but also rules which are logically subsumed by other rules in the program. Let us first give the definition of subsumption for Datalog\u2228,\u00acs rules.\nDefinition 4.1 Let P be a Datalog\u2228,\u00ac program, and let r and r\u2032 be two rules of P. Then, r is subsumed by r\u2032 (denoted by r \u2291 r\u2032) if there exists a substitution \u03d1 for the variables of r\u2032, such that H(r\u2032)\u03d1 \u2286 H(r) and B(r\u2032)\u03d1 \u2286 B(r). A rule r is redundant if there exists a rule r\u2032 such that r \u2291 r\u2032.\nIdeally, a Magic Set rewriting algorithm should be capable of identifying all the possible redundant rules and removing them from the output. Unfortunately, this approach is unlikely to be feasible in polynomial time, given that subsumption checking on first-order expressions is NP-complete (problem [LO18] in [27]).\nThus, in order to identify whether a rule r produced during the Magic Set transformation is redundant, we pragmatically apply a greedy subsumption algorithm in our implementation, for checking whether r \u2291 r\u2032 holds for some rule r\u2032. In particular, the employed heuristics aims at building the substitution \u03d1 (as in Definition 4.1) by iteratively choosing an atom p(t\u0304) (which is not yet processed) from r\u2032 and by matching it (if possible) with some atom of r. The greedy approach prefers those atoms of r\u2032 with the maximum number of variables not yet matched.\nTo turn on subsumption checking (applied once after the Magic Set rewriting), DLV has to be invoked with the command-line option -ODMS+."}, {"heading": "5 Experiments on Standard Benchmarks", "text": "We performed several experiments for assessing the effectiveness of the proposed technique. In this section we present the results obtained on various standard benchmarks, most of which have been directly adopted from the literature. Further experiments on an application scenario using real-world data will be discussed in detail in Section 6. We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems. In both publications the impact of magic sets is stated explicitly."}, {"heading": "5.1 Compared Methods, Benchmark Problems and Data", "text": "In order to evaluate the impact of the proposed method, we have compared DMS (using the SIPS defined outlined in Section 4) both with the traditional DLV evaluation without Magic Sets and with the SMS method proposed in [33]. Concerning SMS, we were not able to obtain an implementation, and have therefore performed the rewriting manually. As a consequence, the runtime measures obtained for SMS do not contain the time needed for rewriting, while it is included for DMS.\nFor the comparison, we consider the following benchmark problems. The first three of them had been already used to assess SMS in [33], to which we refer for details:\n\u2022 Simple Path: Given a directed graph G and two nodes a and b, does there exist a unique path connecting a to b in G? The instances are encoded by facts edge(v1, v2) for each arc (v1, v2) in G, while the problem itself is encoded by the program 8\nsp(X, X) \u2228 not sp(X, X) :\u2212 edge(X, Y).\nsp(X, Y) \u2228 not sp(X, Y) :\u2212 sp(X, Z), edge(Z, Y).\npath(X, Y) :\u2212 sp(X, Y).\npath(X, Y) :\u2212 not sp(X, Y).\nnot sp(X, Z) :\u2212 path(X, Y1), path(X, Y2), Y1 <> Y2,\nedge(Y1, Z), edge(Y2, Z).\nwith the query sp(a, b). The structure of the graph, which is the same as the one reported in [33], consists of a square matrix of nodes connected as shown in Figure 7, and the instances have been generated by varying of the number of nodes. \u2022 Related: Given a genealogy graph storing information about relationships (father/brother) among people and given two people p1 and p2, is p1 an ancestor of p2? The instances are encoded by facts related(p1, p2) when p1 is known to be related to p2, that is, when p1 is the father or a brother of"}, {"heading": "8 The first rule of the program models that for each node X of G, a unique path", "text": "connecting X with itself can either exist or not.\np2. The problem can be encoded by the program\nfather(X, Y) \u2228 brother(X, Y) :\u2212 related(X, Y).\nancestor(X, Y) :\u2212 father(X, Y).\nancestor(X, Y) :\u2212 father(X, Z), ancestor(Z, Y).\nand the query is ancestor(p1, p2). The structure of the \u201cgenealogy\u201d graph is the same as the one presented in [33] and coincides with the one used for testing Simple Path. Also in this case, the instances are generated by varying the number of nodes (thus the number of persons in the genealogy) of the graph. \u2022 Strategic Companies: This is a slight variant of the problem domain used in the running example. The description here is of the problem as posed in the Third ASP Competition. We consider a collection C of companies, where each company produces some goods in a set G and each company ci \u2208 C is controlled by a set of owner companies Oi \u2286 C. A subset of the companies C \u2032 \u2282 C is a strategic set if it is a minimal set of companies producing all the goods in G, such that if Oi \u2286 C \u2032 for some i = 1, . . . , m then ci \u2208 C \u2032 must\nhold. As in the Second Answer Set Competition, 9 we assume that each product is produced by at most four companies, and that each company is controlled by at most four companies (the complexity of the problem under these restrictions is as hard as without them). Given two distinct companies ci, cj \u2208 C, is there a strategic set of C which contains both ci and cj? The instances are encoded by facts produced by(p, c1, c2, c3, c4) when product p is produced by companies c1, c2, c3, and c4; if p is produced by fewer than four companies (but at least one), then c1, c2, c3, c4 contains repetitions of companies. Moreover, facts controlled by(c, c1, c2, c3, c4) represent that company c is controlled by companies c1, c2, c3, and c4; again, if c is controlled by fewer than four companies, then c1, c2, c3, c4 contains repetitions.\n9 http://www.cs.kuleuven.be/~dtai/events/ASP-competition/index.shtml\nThe problem can be encoded by the program\nst(C1) \u2228 st(C2) \u2228 st(C3) \u2228 st(C4) :\u2212 produced by(P, C1, C2, C3, C4).\nst(C) :\u2212 controlled by(C, C1, C2, C3, C4), st(C1), st(C2), st(C3), st(C4).\nwith the query st(ci), st(cj). While the language presented in the previous sections allowed only for one atom in a query for simplicity, the implementation in DLV allows for a conjunction in a query; it is easy to see that a conjunctive query can be emulated by a rule with the conjunction in the body and an atom with a new predicate in the head, which contains all body arguments, and finally replacing the query conjunction with this atom. In this case this would mean adding a rule q(ci, cj) :\u2212 st(ci), st(cj) and replacing the query by q(ci, cj). For this benchmark we used the instances submitted for the Second Answer Set Competition. \u2022 Conformant Plan Checking: In addition, we have included a benchmark problem, which highlights the fact that our Magic Set technique can yield improvements not only for the grounding, but also for the model generation phase, as discussed in Section 7. This problem is inspired by a setting in planning, in particular testing whether a given plan is conformant with respect to a state transition diagram [30]. Such a diagram is essentially a directed graph formed of nodes representing states, and in which arcs are labeled by actions, meaning that executing the action in the source state will lead to the target state. In the considered setting nondeterminism is allowed, that is, executing an action in one state might lead nondeterministically to one of several successor states. A plan is a sequence of actions, and it is conformant with respect to a given initial state and a goal state if each possible execution of the action sequence leads to the goal state. In our benchmark, we assume that the action selection process has al-\nready been done, thus having reduced the state transition diagram to those transitions that actually occur when executing the given plan. Furthermore we assume that there are exactly two possible non-goal successor states for any given state. This can also be viewed as whether all outgoing paths of a node in a directed graph reach a particular confluence node. We encoded instances by facts ptrans(s0, s1, s2) meaning that one of states s1 and s2 will be reached in the plan execution starting from s0. The problem is encoded using\ntrans(X, Y) \u2228 trans(X, Z) :\u2212 ptrans(X, Y, Z).\nreach(X, Y) :\u2212 trans(X, Y).\nreach(X, Y) :\u2212 reach(X, Z), trans(Z, Y).\nand the query reach(0, 1), where 0 is the initial state and 1 the goal state. If the query is cautiously true, the plan is conformant. The transition graphs\nin our experiments have the shape of a binary tree rooted in state 0, and from each leaf there is an arc to state 1, as depicted in Figure 7.\nIn addition, we have performed further experiments on an application scenario modeled from real-world data for answering user queries in a data integration setting. These latter experiments will be discussed in more detail in Section 6."}, {"heading": "5.2 Results and Discussion", "text": "The experiments have been performed on a 3GHz IntelR\u00a9 XeonR\u00a9 processor system with 4GB RAM under the Debian 4.0 operating system with a GNU/Linux 2.6.23 kernel. The DLV prototype used has been compiled using GCC 4.3.3. For each instance, we have allowed a maximum running time of 600 seconds (10 minutes) and a maximum memory usage of 3GB.\nOn all considered problems, DMS outperformed SMS, even if SMS does not include the rewriting time, as discussed in Section 5.1. Let us analyze the results for each problem in more detail.\nThe results for Simple Path are reported in Figure 8. DLV without Magic Sets solves only the smallest instances, with a very steep increase in execution time. SMS does better than DLV, but scales much worse than DMS. The difference between SMS and DMS is mostly due to the grounding of the additional predicates that SMS introduces.\nFigure 9 reports the results for Related. Compared to Simple Path, DLV without Magic Sets exhibits an even steeper increase in runtime, while in contrast\nboth SMS and DMS scale better than on Simple Path. Comparing SMS and DMS, we note that DMS appears to have an exponential speedup over SMS. In this case, the computational gain of DMS over SMS is due to the dynamic optimization of the model search phase resulting from our Magic Sets definition. This aspect is better highlighted by the Conformant Plan Checking benchmark, and will be discussed later in this section.\nFor Strategic Companies, we report the results in Figure 10 as a bar diagram, because the instances do not have a uniform structure. The instances are, however, ordered by size. Also here, DLV without Magic Sets is clearly the least efficient of the tested systems, resolving only the smallest two instances in the allotted time (600 seconds). Concerning the other systems, SMS and DMS essentially show equal performance. In fact, the situation here is quite different to Simple Path and Related, because grounding the program produced by the Magic Set rewriting takes only a negligible amount of time for SMS and DMS. For this benchmark the important feature is reducing the ground program to the part which is relevant for the query, and we could verify that the ground programs produced by SMS and DMS are precisely the same.\nFinally, the results for Conformant Plan Checking are shown in Figure 11. While DLV shows a similar behavior as for Simple Path and Related, here also SMS does not scale well at all, and in fact DMS appears to have an exponential speedup over SMS. There is a precise reason for this: While the Magic Set rewriting of SMS always creates a deterministic program defining the magic predicates, this is not true for DMS. As a consequence, all magic predicates are completely evaluated during the grounding phase of DLV for SMS, while for DMS this is not the case. At the first glance, this may seem like a disadvantage of DMS, as one might believe that the ground program becomes larger.\nHowever, it is actually a big advantage of DMS, because it offers a more precise identification of the relevant part of the program. Roughly speaking, whatever SMS identifies as relevant for the query will also be identified as relevant in DMS, but DMS can also include nondeterministic relevance information, which SMS cannot. This means that in DMS Magic Sets can be exploited also during the nondeterministic search phase of DLV, dynamically disabling parts of the ground program. In particular, after having made some choices, parts of the program may no longer be relevant to the query, but only because of these choices, and the magic atoms present in the ground program can render these parts satisfied, which means that they will no longer be considered in this part of the search. SMS cannot induce any behavior like this and its effect is limited to the grounding phase of DLV, which can make a huge difference, as evidenced by Conformant Plan Checking."}, {"heading": "5.3 Experimenting DMS with other Disjunctive Datalog Systems", "text": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37]. ClaspD is based on advanced Boolean constraint solving techniques, featuring backjumping and conflict-driven learning. Cmodels is based on the definition of program completion and loop formula for disjunctive programs [40,47], and uses a SAT solver for generating candidate solutions and testing them. GnT1 is based on Smodels [61], a system handling Datalog programs with unstratified negation (normal programs): A disjunctive program is translated into a normal program, the stable models of which are computed by Smodels and represent stable model candidates of the orig-\ninal program. Each of these candidates is then checked to be a stable model of the original program by invoking Smodels on a second normal program. GnT2 is a variant of GnT1 in which the number of candidates produced by the first normal program is reduced by means of additional rules that discard unsupported models, i.e., models containing some atom a for which there is no rule r such that B(r) is true and a is the only true atom in H(r).\nAll of the benchmarks presented in the previous section were tested on these systems. Since DMS is not implemented in these systems, rewritten programs were produced by DLV during the preparation of the experiment. We recall that DMS does not depend on EDB relations and point out that DLV computes rewritten programs for the considered encodings in 1-2 hundredths of a second. The results of our experiment are reported in Figures 12\u201316. In general, we tried use a consistent scales in the graphs in order to ease comparability. However, for some graphs we chose a different scale in order to keep them readable for the main purpose (comparing performances with and without DMS), and we mention this explicitly in the accompanying text.\nConcerning Simple Path, the advantages of DMS over the unoptimized encoding are evident on all tested systems. In fact, as shown in Figure 12, without DMS all tested systems did not answered in the allotted time (600 seconds) on instances with more than 400 nodes (900 for Cmodels). On the other hand, all of the instances considered in the benchmark (up to 40 thousands of nodes) were solved by all tested solvers with the DMS encoding. We also observe that with DMS the tested systems are faster than DLV in this benchmark, which is a clear indication of the optimization potential that can be provided to these systems by our Magic Set technique.\nFor Related we obtained a similar result, reported in Figure 13 (we used a different scale for the y-axis for Cmodels for readability). Without DMS only the smallest instances were solved in the allotted time (up to 2025 nodes for ClaspD and Cmodels, up to 625 nodes for GnT1 and GnT2). With DMS, instead, all tested systems solved the biggest instances of the benchmark (up to 10 thousands of nodes). In particular, with DMS Cmodels is as performant as DLV in this benchmark.\nThe effectiveness of DMS is also evident in the Strategic Companies benchmark (Figures 14\u201315). In fact, we observed sensible performance gains of all systems on all tested instances. GnT1, which is already faster than the other tested systems in this benchmark, draws particular advantage from DMS, solving all\ninstances in few seconds. We give another evidence of the optimization potential provided by DMS to these systems by comparing the number of solved instances: Of a total of 60 tests, we counted 37 timeouts on the unoptimized encoding (10 on ClaspD, 14 on Cmodels, 3 on GnT1 and 10 on GnT2), while just one on the encoding obtained by applying DMS. We point out that the timeout on the rewritten program was obtained by the Cmodels system, which alone collected 14 timeouts on the unoptimized encoding and is thus the least performant on this benchmark.\nFinally, consider the results for Conformant Plan Checking reported in Figure 16 (we used a different scale on the y-axis for ClaspD for readability; note also that ClaspD and GnT2 only solved the smallest instances of this\nbenchmark, and we thus used a different scale for their x-axes). The performance of ClaspD is poor in this benchmark, nonetheless we observed a slight improvement in execution time if DMS is applied on the encoding reported in Section 5.1. Cmodels performs better than ClaspD in this case and the optimization potential of DMS emerges with an exponential improvement in performance. A similar result was observed for GnT1, while GnT2 on this benchmark is the only outlier of the experiment: Its performance deteriorates if the original program is processed by DMS. However, in this benchmark GnT2 performs worse that GnT1 also with the original encoding. In fact, while GnT1 solved the biggest instance (more than 65 thousands of states) in 209.74 seconds (12.28 seconds with the DMS encoding), the execution of GnT2 did not terminate in the allotted time (600 seconds) on instances containing more than\n10 thousands of states. We finally note that with DMS GnT1 and Cmodels are faster than DLV in this benchmark. In fact, for the biggest instance in the benchmark, GnT1 and Cmodels required 12.28 and 19.13 seconds, respectively, while DLV terminated in 279.41 seconds. The significant performance gain of GnT1 and Cmodels due to DMS is a further confirmation of the potential of our optimization technique."}, {"heading": "6 Application to Data Integration", "text": "In this section we give a brief account of a case study that evidences the impact of the Magic Set method when used on programs that realize data integration systems. We first give an overview of data integration systems, show how they can be implemented using Datalog\u2228,\u00acs, and finally assess the impact of Magic Sets on a data integration system involving real-world data."}, {"heading": "6.1 Data Integration Systems in a Nutshell", "text": "The main goal of data integration systems is to offer transparent access to heterogeneous sources by providing users with a global schema, which users can query without having to know from what sources the data come from. In fact, it is the task of the data integration system to identify and access the data sources which are relevant for finding the answer to a query over the global schema, followed by a combination of the data thus obtained. The data integration system uses a set of mapping assertions, which specify the\nrelationship between the data sources and the global schema. Following [41], we formalize a data integration system I as a triple \u3008G,S,M\u3009, where:\n(1) G is the global (relational) schema, that is, a pair \u3008\u03a8,\u03a3\u3009, where \u03a8 is a finite set of relation symbols, each with an associated positive arity, and \u03a3 is a finite set of integrity constraints (ICs) expressed on the symbols in \u03a8. ICs are first-order assertions that are intended to be satisfied by database instances. (2) S is the source schema, constituted by the schemas of the various sources that are part of the data integration system. We assume that S is a relational schema of the form S = \u3008\u03a8\u2032, \u2205\u3009, which means that there are no integrity constraints on the sources. This assumption implies that data stored at the sources are locally consistent; this is a common assumption in data integration, because sources are in general external to the integration system, which is not in charge of analyzing or restoring their consistency. (3) M is the mapping which establishes the relationship between G and S. In our framework, the mapping follows the GAV approach, that is, each global relation is associated with a view\u2014a Datalog\u2228,\u00acs query over the sources.\nThe main semantic issue in data integration systems is that, since integrated sources are originally autonomous, their data, transformed via the mapping assertions, may not satisfy the constraints of the global schema. An approach to remedy to this problem that has lately received a lot of interest in the literature (see, e.g., [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4]. Roughly speaking, a repair of a database is a new database that satisfies the constraints in the schema, and minimally differs from the original one. Since an inconsistent database might possess multiple repairs, the standard approach in answering user queries is to return those answers that are true in every possible repair. These are called consistent answers in the literature."}, {"heading": "6.2 Consistent Query Answering via Datalog\u2228,\u00acs Queries", "text": "There is an intuitive relation between consistent answers to queries over data integration systems and queries over Datalog\u2228,\u00acsprograms: Indeed, if one could find a translation from data sources, mapping, and the query to a Datalog\u2228,\u00acs program, which possesses a stable model for each possible repair, and a query over it, the consistent answers within the data integration system will correspond to cautious consequences of the obtained Datalog\u2228,\u00acs setting.\nIn fact, various authors [5,7,14,16,17,31] considered the idea of encoding the\nconstraints of the global schema G into various kinds of logic programs, such that the stable models of this program yield the repairs of the database retrieved from the sources. Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalog programs together with unstratified negation have been considered in [13,51].\nIt has already been realized earlier that Magic Sets are a crucial optimization technique in this context, and indeed the availability of the transformational approach using stable logic programming as its core language was a main motivation for the research presented in this article, since in this way a Magic Set method for stable logic programs immediately yields an optimization technique for data integration systems. Indeed, the benefits of Magic Sets in the context of optimizing logic programs with unstratified negation (but without disjunction) have been discussed in [24]. The Magic Set technique defined in [24] is quite different from the one defined in this article, as it does not consider disjunctive rules, and works only for programs, which are consistent, that is, have at least one stable model. In [51] our preliminary work reported in [20], which eventually led to the present article, has been expanded in an ad-hoc way to particular kinds of Datalog programs with disjunction and unstratified negation. It is ad-hoc in the sense that it is tailored to programs which are created by the transformation described in [51]. The experimental results reported in [51] show huge computational advantages when using Magic Sets.\nWe now report an alternative transformation which produces Datalog\u2228,\u00acs programs (therefore different to [51], there are no unstratified occurrences of negation). This rewriting has been devised and used within the INFOMIX system on data integration [42].\nLet I = \u3008G,S,M\u3009 be a data integration system where G = \u3008\u03a8,\u03a3\u3009, and let D be a database for G, which is represented as a set of facts over the relational predicates in G. We assume that constraints over the global schema are key and exclusion dependencies. In particular, we recall that a set of attributes x\u0304 is a key for the relation r if:\n(r(x\u0304, y\u0304) \u2227 r(x\u0304, z\u0304)) \u2192 y\u0304 = z\u0304, \u2200{r(x\u0304, y\u0304), r(x\u0304, z\u0304)} \u2286 D\nand that an exclusion dependency holds between a set of attributes x\u0304 of a relation r and a set of attributes w\u0304 of a relation s if\n(r(x\u0304, y\u0304) \u2227 s(w\u0304, z\u0304)) \u2192 y\u0304 6= z\u0304, \u2200{r(x\u0304, y\u0304), s(w\u0304, z\u0304)} \u2286 D\nThen, the disjunctive rewriting of a query q with respect to I is the Datalog\u2228,\u00acs program \u03a0(I) = \u03a0KD \u222a\u03a0ED \u222a\u03a0M \u222a\u03a0coll where:\n\u2022 For each relation r in G and for each key defined over its set of attributes x\u0304, \u03a0KD contains the rules:\nrout(x\u0304, y\u0304) \u2228 rout(x\u0304, z\u0304) :\u2212 rD(x\u0304, y\u0304) , rD(x\u0304, z\u0304), Y1 6= Z1. ...\nrout(x\u0304, y\u0304) \u2228 rout(x\u0304, z\u0304) :\u2212 rD(x\u0304, y\u0304) , rD(x\u0304, z\u0304), Ym 6= Zm.\nwhere y\u0304 = Y1, . . . , Ym, and z\u0304 = Z1, . . . , Zm. \u2022 For each exclusion dependency between a set of attributes x\u0304 of a relation r and a set of attributes w\u0304 of a relation s, \u03a0ED contains the following rule:\nrout(x\u0304, y\u0304) \u2228 sout(w\u0304, z\u0304) :\u2212 rD(x\u0304, y\u0304) , sD(w\u0304, z\u0304), X1 = W1, . . . , Xm = Wm.\nwhere x\u0304 = X1, . . . , Xm, and w\u0304 = W1, . . . ,Wm. In the implementation the following equivalent rule is used:\nrout(x\u0304, y\u0304) \u2228 sout(x\u0304, z\u0304) :\u2212 rD(x\u0304, y\u0304), sD(x\u0304, z\u0304).\n\u2022 For each relation r in G, \u03a0coll contains the rule:\nr(w\u0304) :\u2212 rD(w\u0304) , not rout(w\u0304).\n\u2022 For each Datalog rule r in M such that:\nk(t\u0304) :\u2212 q1(s\u03041), . . . , qm(s\u0304m).\nwhere k is a relation in G and qi (for 1 \u2264 i \u2264 m) is a relation in S, \u03a0M contains the rule:\nkD(t\u0304) :\u2212 q1(s\u03041), . . . , qm(s\u0304m).\nIt can be shown that for each user query Q (over G) and for each source database F (over S), consistent query answers to Q precisely coincide with the set Ansc(Q,\u03a0(I)\u222aF). Actually, within the INFOMIX project also inclusion dependencies have been considered according to the rewriting discussed in [16], whose details we omit for clarity. Since the rewriting for inclusion dependencies also modifies queries, in the INFOMIX project queries have been limited to conjunctive queries. It is however important to notice that the program \u03a0(I) contains only stratified negation and is therefore a Datalog\u2228,\u00acs program, making the Magic Set method defined in this article applicable."}, {"heading": "6.3 Experimental Results", "text": "The effectiveness of the Magic Set method in this crucial application context has then been assessed via a number of experiments carried out on the demonstration scenario of the INFOMIX project, which refers to the information system of the University \u201cLa Sapienza\u201d in Rome. The global schema consists of 14\nglobal relations with 29 constraints, while the data sources include 29 relations of 3 legacy databases and 12 wrappers generating relational data from web pages. This amounts to more than 24MB of data regarding students, professors and exams in several faculties of the university. For a detailed description of the INFOMIX project see https://www.mat.unical.it/infomix/.\nOn this schema, we have tested five typical queries with different characteristics, which model different use cases. For the sake of completeness, the full encodings of the tested queries are reported in the Appendix. In particular, we measured the average execution time of DLV computing Ansc(Q,\u03a0(I) \u222a F) and Ansc(Q, DMS(Q,\u03a0(I)) \u222a F) on datasets of increasing size. The experiments were performed by running the INFOMIX prototype system on a 3GHz IntelR\u00a9 XeonR\u00a9 processor system with 4GB RAM under the Debian 4.0 operating system with a GNU/Linux 2.6.23 kernel. The DLV prototype used as the computational core of the INFOMIX system had been compiled using GCC 4.3.3. For each instance, we allowed a maximum running time of 10 minutes and a maximum memory usage of 3GB.\nThe results, reported in Figure 17, confirm that on these typical queries the performance is considerably improved by Magic Sets. On Queries 1 to 4 in Figure 17 the response time scales much better with Magic Sets than without,\nappearing essentially linear on the tested instance sizes, while without Magic Sets the behavior has a decidedly non-linear appearance. We also observe that there is basically no improvement on Query 5. We have analyzed this query and for this use case all data seems to be relevant to the query, which means that Magic Sets cannot have any positive effect. It is however important to observe that the Magic Set rewriting does not incur any significant overhead."}, {"heading": "7 Related Work", "text": "In this section we first discuss the main body of work which is related to DMS, the technique developed in this paper for query answering optimization. In particular, we discuss Magic Set techniques for Datalog languages. The discussion is structured in paragraphs grouping techniques which cover the same language. After that, we discuss some applications for which DMS have already been exploited. All these applications refer to the preliminary work published in [20].\nMagic Sets for Datalog. In order to optimize query evaluation in bottomup systems, like deductive database systems, several works have proposed the simulation of top-down strategies by means of suitable transformations introducing new predicates and rewriting clauses. Among them, Magic Sets for Datalog queries are one of the best known logical optimization techniques for database systems. The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63]. These works form the foundations of DMS.\nMagic Sets for Datalog\u00acs. Many authors have addressed the issue of extending the Magic Set technique in order to deal with Datalog queries involving stratified negation. The main problem related to the extension of the technique to Datalog\u00acs programs is how to assign a semantics to the rewritten programs. Indeed, while Datalog\u00acs programs have a natural and accepted semantics, namely the perfect model semantics [2,64], the application of Magic Sets can introduce unstratified negation in the rewritten programs. A solution has been presented in [10,38,39,59]. In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog\u00ac programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined. All of these methods exploit a property of Datalog\u00acs which is not present in disjunctive Datalog, uniqueness of the intended model. This property in turn implies that query answering just consists in establishing the truth value of some atoms in one\nintended model. Using our terminology, brave and cautious reasoning coincide for these programs. Therefore, all these methods are quite different from DMS, the technique developed in this paper.\nMagic Sets for Datalog\u00ac. Extending the Magic Set technique to Datalog\u00ac programs must face two major difficulties. First, for a Datalog\u00ac program uniqueness of the intended model is no more guaranteed, thus query answering in this setting involves a set of stable models in general. The second difficulty is that parts of a Datalog\u00ac program may act as constraints, thus impeding a relevant interpretation to be a stable model. In [24] a Magic Set method for Datalog\u00ac programs has been defined and proved to be correct for coherent programs, i.e., programs admitting at least one stable model. This method takes special precautions for relevant parts of the program that act as constraints, called dangerous rules in [24]. We observe that dangerous rules cannot occur in Datalog\u2228,\u00acs programs, which allows for the simpler DMS algorithm to work correctly for this class of programs.\nMagic Sets for Datalog\u2228. The first extension of the Magic Set technique to disjunctive Datalog is due to [32,33], where the SMSmethod has been presented and proved to be correct for Datalog\u2228 programs. We point out that the main drawback of this method is the introduction of collecting predicates. Indeed, magic and collecting predicates of SMS have deterministic definitions. As a consequence, their extension can be completely computed during program instantiation, which means that no further optimization is provided for the subsequent stable model search. Moreover, while the correctness of DMS has been formally established for Datalog\u2228,\u00acs programs in general, the applicability of SMS to Datalog\u2228,\u00acs programs has only been outlined in [32,33].\nApplications. Magic Sets have been applied in many contexts. In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS. In particular, in [13,51] a data integration system has been presented. The system is based on disjunctive Datalog and exploits DMS for fast query answering. In [36,53], instead, an algorithm for answering queries over description logic knowledge bases has been presented. More specifically, the algorithm reduces a SHIQ knowledge base to a disjunctive Datalog program, so that DMS can be exploited for query answering optimization."}, {"heading": "8 Conclusion", "text": "The Magic Set method is one of the best-known techniques for the optimization of positive recursive Datalog programs due to its efficiency and its generality. Just a few other focused methods such as the supplementary Magic Set and other special techniques for linear and chain queries have gained similar visibility (see, e.g., [34,56,63]). After seminal papers [6,9], the viability of the approach was demonstrated e.g., in [35,55]. Later on, extensions and refinements were proposed, addressing e.g., query constraints in [62], the wellfounded semantics in [38], or integration into cost-based query optimization in [60]. The research on variations of the Magic Set method is still going on. For instance, in [24] an extension of the Magic Set method was discussed for the class of unstratified logic programs (without disjunction). In [10] a technique for the class of soft-stratifiable programs was given. Finally, in [33] the first variant of the technique for disjunctive programs (SMS) was described.\nIn this paper, we have elaborated on the issues addressed in [32,33]. Our approach is similar to SMS, but differs in several respects:\n\u2022 DMS is a dynamic optimization of query answering, in the sense that in addition to the optimization of the grounding process (which is the only optimization performed by SMS), DMS can drive the model generation phase by dynamically disabling parts of the program that become irrelevant in the considered partial interpretations. \u2022 DMS has a strong relationship with unfounded sets, allowing for a clean application to disjunctive Datalog programs also in presence of stratified negation. \u2022 DMS can be further improved by performing a subsequent subsumption check. \u2022 DMS is integrated into the DLV system [43], profitably exploiting the DLV internal data-structures and the ability of controlling the grounding module.\nWe have conducted experiments on several benchmarks, many of which taken from the literature. The results of our experimentation evidence that our implementation outperforms SMS in general, often by an exponential factor. This is mainly due to the optimization of the model generation phase, which is specific to our Magic Set technique. In addition, we have conducted further experiments on a real application scenario, which show that Magic Sets can play a crucial role in optimizing consistent query answering over inconsistent databases. Importantly, other authors have already recognized the benefits of our optimization strategies with respect to this very important application domain [51], thereby confirming the validity and the robustness of the work discussed in this paper.\nWe conclude by observing that it has been noted in the literature (e.g., in [38])\nthat in the non-disjunctive case memoing techniques lead to similar computations as evaluations after Magic Set transformations. Also in the disjunctive case such techniques have been proposed (e.g., Hyper Tableaux [8]), for which similar relations might hold. While [38] has already evidenced that an advantage of Magic Sets over such methods is that they may be more easily combined with other optimization techniques, we believe that achieving a deeper comprehension of the relationships among these techniques constitutes an interesting avenue for further research.\nAnother issue that we leave for future work is to study the impact of changing some parameters of the DMS method, in particular the impact of different SIPSes."}, {"heading": "A Queries on the INFOMIX Demo Scenario", "text": "INFOMIX is a project that was funded by the European Commission in its Information Society Technologies track of the Sixth Framework Programme for providing an advanced system for information integration. A detailed description of the project, including references in the literature, can be found at https://www.mat.unical.it/infomix/. Five typical queries of the INFOMIX demo scenario have been considered for assessing Dynamic Magic Sets. The full encodings of the tested queries are reported in Figures A.1\u2013A.2. Note that the encodings include the transformation described in Section 6, and that underlined predicates denote source relations."}], "references": [{"title": "Scalar aggregation in fd-inconsistent databases", "author": ["Marcelo Arenas", "Leopoldo Bertossi", "Jan Chomicki"], "venue": "In International Conference on Database Theory (ICDT-2001),", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2001}, {"title": "Consistent query answers in inconsistent databases", "author": ["Marcelo Arenas", "Leopoldo E. Bertossi", "Jan Chomicki"], "venue": "In Proc. of the 18th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1999}, {"title": "Specifying and querying database repairs using logic programs with exceptions", "author": ["Marcelo Arenas", "Leopoldo E. Bertossi", "Jan Chomicki"], "venue": "In Proc. of the 4th Int. Conf. on Flexible Query Answering Systems (FQAS", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2000}, {"title": "Magic Sets and Other Strange Ways to Implement Logic Programs", "author": ["Fran\u00e7ois Bancilhon", "David Maier", "Yehoshua Sagiv", "Jeffrey D. Ullman"], "venue": "In Proc. Int. Symposium on Principles of Database Systems,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1986}, {"title": "Repairing databases with annotated predicate logic", "author": ["Pablo Barcel\u00f3", "Leopoldo Bertossi"], "venue": "In Proc. the 10th Int. Workshop on Non-Monotonic Reasoning (NMR", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2002}, {"title": "Hyper Tableaux", "author": ["Peter Baumgartner", "Ulrich Furbach", "Ilkka Niemel\u00e4"], "venue": "In Proceedings of the European Workshop on Logics in Artificial Intelligence (JELIA\u201996),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1996}, {"title": "On the power of magic", "author": ["Catriel Beeri", "Raghu Ramakrishnan"], "venue": "Journal of Logic Programming,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1991}, {"title": "Soft stratification for magic set based query evaluation in deductive databases", "author": ["Andreas Behrend"], "venue": "Proceedings of the twenty-second ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2003}, {"title": "Query answering in inconsistent databases", "author": ["Leo Bertossi", "Jan Chomicki"], "venue": "Logics for Emerging Applications of Databases,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2003}, {"title": "Consistent answers from integrated data sources", "author": ["Leopoldo Bertossi", "Jan Chomicki", "Alvaro Cortes", "Claudio Gutierrez"], "venue": "In Proc. of the 6th Int. Conf. on Flexible Query Answering Systems (FQAS", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2002}, {"title": "Consistent query answers in virtual data integration systems", "author": ["Leopoldo E. Bertossi", "Loreto Bravo"], "venue": "In Inconsistency Tolerance,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2005}, {"title": "Logic programming for consistently querying data integration systems", "author": ["Loreto Bravo", "Leopoldo Bertossi"], "venue": "In Proc. of the 18th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2003}, {"title": "Default Logic as a Query Language", "author": ["Marco Cadoli", "Thomas Eiter", "Georg Gottlob"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1997}, {"title": "Query rewriting and answering under constraints in data integration systems", "author": ["Andrea Cal\u0300\u0131", "Domenico Lembo", "Riccardo Rosati"], "venue": "In Proc. of the 18th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2003}, {"title": "Minimal-change integrity maintenance using tuple deletions", "author": ["Jan Chomicki", "Jerzy Marcinkowski"], "venue": "Information and Computation,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2005}, {"title": "Computing consistent query answers using conflict hypergraphs", "author": ["Jan Chomicki", "Jerzy Marcinkowski", "Slawomir Staworko"], "venue": "In Proc. 13th ACM Conference on Information and Knowledge Management (CIKM-2004),", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2004}, {"title": "Hippo: A System for Computing Consistent Answers to a Class of SQL Queries", "author": ["Jan Chomicki", "Jerzy Marcinkowski", "Slawomir Staworko"], "venue": "9th International Conference on Extending Database Technology (EDBT-2004),", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2004}, {"title": "Enhancing the magic-set method for disjunctive datalog programs", "author": ["Chiara Cumbo", "Wolfgang Faber", "Gianluigi Greco", "Nicola Leone"], "venue": "In Proceedings of the the 20th International Conference on Logic Programming \u2013 ICLP\u201904,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2004}, {"title": "Conflict-Driven Disjunctive Answer Set Solving", "author": ["Christian Drescher", "Martin Gebser", "Torsten Grote", "Benjamin Kaufmann", "Arne K\u00f6nig", "Max Ostrowski", "Torsten Schaub"], "venue": "Proceedings of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2008}, {"title": "Disjunctive Datalog", "author": ["Thomas Eiter", "Georg Gottlob", "Heikki Mannila"], "venue": "ACM Transactions on Database Systems,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1997}, {"title": "Enhancing Efficiency and Expressiveness in Answer Set Programming Systems", "author": ["Wolfgang Faber"], "venue": "PhD thesis, Institut fu\u0308r Informationssysteme, Technische Universita\u0308t Wien,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2002}, {"title": "Magic Sets and their Application to Data Integration", "author": ["Wolfgang Faber", "Gianluigi Greco", "Nicola Leone"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2007}, {"title": "Conquer: Efficient management of inconsistent databases", "author": ["Ariel Fuxman", "Elham Fazli", "Ren\u00e9e J. Miller"], "venue": "In SIGMOD Conference,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2005}, {"title": "First-order query rewriting for inconsistent databases", "author": ["Ariel Fuxman", "Ren\u00e9e J. Miller"], "venue": "Proceedings of the 10th International Conference on Database Theory (ICDT 2005),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2005}, {"title": "Computers and Intractability, A Guide to the Theory of NP-Completeness", "author": ["Michael R. Garey", "David S. Johnson"], "venue": "W.H. Freeman and Company,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1979}, {"title": "Gringo : A new grounder for answer set programming", "author": ["Martin Gebser", "Torsten Schaub", "Sven Thiele"], "venue": "Logic Programming and Nonmonotonic Reasoning \u2014 9th International Conference, LPNMR\u201907,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2007}, {"title": "The Stable Model Semantics for Logic Programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "In Logic Programming: Proceedings Fifth Intl Conference and Symposium,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 1988}, {"title": "Expressive Planning and Explicit Knowledge", "author": ["R. Goldman", "M. Boddy"], "venue": "In Proceedings AIPS-96,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1996}, {"title": "A logic programming approach to the integration, repairing and querying of inconsistent databases", "author": ["Gianluigi Greco", "Sergio Greco", "Ester Zumpano"], "venue": "In Proc. of the 17th Int. Conf. on Logic Programming (ICLP\u201901),", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2001}, {"title": "Optimization of Disjunction Queries", "author": ["Sergio Greco"], "venue": "Danny De Schreye, editor, Proceedings of the 16th International Conference on Logic Programming (ICLP\u201999),", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 1999}, {"title": "Binding Propagation Techniques for the Optimization of Bound Disjunctive Queries", "author": ["Sergio Greco"], "venue": "IEEE Transactions on Knowledge and Data Engineering,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2003}, {"title": "The PushDown Method to Optimize Chain Logic Programs (Extended Abstract)", "author": ["Sergio Greco", "Domenico Sacc\u00e0", "Carlo Zaniolo"], "venue": "In Proc. Int. Colloquim on Automata, Languages and Programming,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1995}, {"title": "Magic-sets Transformation in Nonrecursive Systems", "author": ["Ashish Gupta", "Inderpal Singh Mumick"], "venue": "In Proceedings of the Thirteenth ACM SIGACT SIGMOD-SIGART Symposium on Principles of Database Systems", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 1992}, {"title": "Reasoning in description logics by a reduction to disjunctive datalog", "author": ["Ullrich Hustadt", "Boris Motik", "Ulrike Sattler"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "Unfolding Partiality and Disjunctions in Stable Model Semantics", "author": ["Tomi Janhunen", "Ilkka Niemel\u00e4", "Dietmar Seipel", "Patrik Simons", "Jia-Huai You"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2006}, {"title": "Bottom-up evaluation and query optimization of well-founded models", "author": ["David B. Kemp", "Divesh Srivastava", "Peter J. Stuckey"], "venue": "Theoretical Computer Science,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 1995}, {"title": "Efficient query answering on stratified databases", "author": ["Jean-Marc Kerisit", "Jean-Marc Pugin"], "venue": "In FGCS,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 1988}, {"title": "Loop Formulas for Disjunctive Logic Programs", "author": ["Joohyung Lee", "Vladimir Lifschitz"], "venue": "In Proceedings of the Nineteenth International Conference on Logic Programming", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2003}, {"title": "Data integration: A theoretical perspective", "author": ["Maurizio Lenzerini"], "venue": "In Proc. of the 21st ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2002}, {"title": "The INFOMIX System for Advanced Integration of Incomplete and Inconsistent Data", "author": ["Nicola Leone", "Georg Gottlob", "Riccardo Rosati", "Thomas Eiter", "Wolfgang Faber", "Michael Fink", "Gianluigi Greco", "Giovambattista Ianni", "Edyta Ka  lka", "Domenico Lembo", "Maurizio Lenzerini", "Vincenzino Lio", "Bartosz Nowicki", "Marco Ruzzi", "Witold Staniszkis", "Giorgio Terracina"], "venue": "In Proceedings of the 24th ACM SIGMOD International Conference on Management of Data (SIGMOD", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2005}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["Nicola Leone", "Gerald Pfeifer", "Wolfgang Faber", "Thomas Eiter", "Georg Gottlob", "Simona Perri", "Francesco Scarcello"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2006}, {"title": "Disjunctive Stable Models: Unfounded Sets, Fixpoint Semantics and Computation", "author": ["Nicola Leone", "Pasquale Rullo", "Francesco Scarcello"], "venue": "Information and Computation,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1997}, {"title": "OpenRuleBench: An analysis of the performance of rule engines", "author": ["Senlin Liang", "Paul Fodor", "Hui Wan", "Michael Kifer"], "venue": "Proceedings of the 18th International Conference on World Wide Web (WWW", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2009}, {"title": "Disjunctive Answer Set Programming via Satisfiability", "author": ["Yuliya Lierler"], "venue": "Logic Programming and Nonmonotonic Reasoning \u2014 8th International Conference,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2005}, {"title": "ASSAT: Computing Answer Sets of a Logic Program by SAT Solvers", "author": ["Fangzhen Lin", "Yuting Zhao"], "venue": "In Proceedings of the Eighteenth National Conference on Artificial Intelligence (AAAI-2002),", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2002}, {"title": "Foundations of Disjunctive Logic Programming", "author": ["Jorge Lobo", "Jack Minker", "Arcot Rajasekar"], "venue": null, "citeRegEx": "48", "shortCiteRegEx": "48", "year": 1992}, {"title": "The HiLeX system for semantic information extraction. Transactions on Large-Scale Data- and Knowledge-Centered Systems", "author": ["Marco Manna", "Massimo Ruffolo", "Ermelinda Oro", "Mario Alviano", "Nicola Leone"], "venue": "Science 7100:91\u2013125,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 2012}, {"title": "On the complexity of regular-grammars with integer attributes", "author": ["Marco Manna", "Francesco Scarcello", "Nicola Leone"], "venue": "Journal of Computer and System Sciences (JCSS),", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 2011}, {"title": "The consistency extractor system: Querying inconsistent databases using answer set programs", "author": ["M\u00f3nica Caniup\u00e1n Marileo", "Leopoldo E. Bertossi"], "venue": "SUM", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2007}, {"title": "Foundations of Deductive Databases and Logic Programming", "author": ["Jack Minker", "editor"], "venue": null, "citeRegEx": "52", "shortCiteRegEx": "52", "year": 1988}, {"title": "Reasoning in Description Logics using Resolution and Deductive Databases. PhD thesis, Fakult\u00e4t f\u00fcr Wirtschaftswissenschaften, Universit\u00e4t", "author": ["Boris Motik"], "venue": "Fridericiana zu Karlsruhe,", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 2006}, {"title": "A comparison of reasoning techniques for querying large description logic aboxes", "author": ["Boris Motik", "Ulrike Sattler"], "venue": "Logic for Programming, Artificial Intelligence, and Reasoning, 13th International Conference (LPAR 2006),", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 2006}, {"title": "Magic is relevant", "author": ["Inderpal Singh Mumick", "Sheldon J. Finkelstein", "Hamid Pirahesh", "Raghu Ramakrishnan"], "venue": "In Proceedings of the 1990 ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 1990}, {"title": "Logical Query Optimization by Proof-Tree Transformation", "author": ["Raghu Ramakrishnan", "Yehoshua Sagiv", "Jeffrey D. Ullman", "Moshe Y. Vardi"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 1993}, {"title": "A logic-based system for e-tourism", "author": ["Francesco Ricca", "Mario Alviano", "Antonella Dimasi", "Giovanni Grasso", "Salvatore Maria Ielpa", "Salvatore Iiritano", "Marco Manna", "Nicola Leone"], "venue": null, "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2010}, {"title": "Team-building with answer set programming in the Gioia-Tauro seaport", "author": ["Francesco Ricca", "Giovanni Grasso", "Mario Alviano", "Marco Manna", "Vincenzino Lio", "Salvatore Iiritano", "Nicola Leone"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2012}, {"title": "Modular Stratification and Magic Sets for Datalog Programs with Negation", "author": ["K.A. Ross"], "venue": "Journal of the ACM,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 1994}, {"title": "Cost-based optimization for magic: Algebra and implementation", "author": ["Praveen Seshadri", "Joseph M. Hellerstein", "Hamid Pirahesh", "T.Y. Cliff Leung", "Raghu Ramakrishnan", "Divesh Srivastava", "Peter J. Stuckey", "S. Sudarshan"], "venue": "Proceedings of the 1996 ACM SIGMOD International Conference on Management of Data,", "citeRegEx": "60", "shortCiteRegEx": "60", "year": 1996}, {"title": "Extending and Implementing the Stable Model Semantics", "author": ["Patrik Simons", "Ilkka Niemel\u00e4", "Timo Soininen"], "venue": "Artificial Intelligence,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2002}, {"title": "Compiling query constraints", "author": ["Peter J. Stuckey", "S. Sudarshan"], "venue": "In Proceedings of the Thirteenth Symposium on Principles of Database Systems", "citeRegEx": "62", "shortCiteRegEx": "62", "year": 1994}, {"title": "Principles of Database and Knowledge-Base Systems, Volume II", "author": ["Jeffrey D. Ullman"], "venue": "Computer Science Press,", "citeRegEx": "63", "shortCiteRegEx": "63", "year": 1989}], "referenceMentions": [{"referenceID": 45, "context": "Disjunctive Datalog is a language that has been proposed for modeling incomplete data [48].", "startOffset": 86, "endOffset": 90}, {"referenceID": 19, "context": ", NP NP) [22], under the stable model semantics.", "startOffset": 9, "endOffset": 13}, {"referenceID": 19, "context": "As shown in [22], the high expressive power of disjunctive Datalog has also some positive practical implications in terms of modelling knowledge, since many problems in NP can be represented more simply and naturally in stratified disjunctive Datalog than in normal logic programming.", "startOffset": 12, "endOffset": 16}, {"referenceID": 39, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 46, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 47, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 54, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 55, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 105, "endOffset": 121}, {"referenceID": 40, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 208, "endOffset": 212}, {"referenceID": 34, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 218, "endOffset": 222}, {"referenceID": 43, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 232, "endOffset": 236}, {"referenceID": 18, "context": "For this reason, it is not surprising that disjunctive Datalog has found several real-world applications [42,49,50,57,58], also encouraged by the availability of some efficient inference engines, such as DLV [43], GnT [37], Cmodels [46], or ClaspD [21].", "startOffset": 248, "endOffset": 252}, {"referenceID": 3, "context": "In this paper, we contribute to this development by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic Set method [6,9,63].", "startOffset": 185, "endOffset": 193}, {"referenceID": 6, "context": "In this paper, we contribute to this development by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic Set method [6,9,63].", "startOffset": 185, "endOffset": 193}, {"referenceID": 60, "context": "In this paper, we contribute to this development by providing a novel optimization technique, inspired by deductive database optimization techniques, in particular the Magic Set method [6,9,63].", "startOffset": 185, "endOffset": 193}, {"referenceID": 17, "context": "In the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set method for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work.", "startOffset": 46, "endOffset": 50}, {"referenceID": 29, "context": "In the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set method for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work.", "startOffset": 156, "endOffset": 163}, {"referenceID": 30, "context": "In the literature, apart from our own work in [20], there is only one previous attempt for defining a Magic Set method for disjunctive Datalog, reported in [32,33], which will be referred to as Static Magic Sets (SMS) in this work.", "startOffset": 156, "endOffset": 163}, {"referenceID": 30, "context": "For the static method SMS, an extension to disjunctive Datalog with stratified negation has previously only been sketched in [33].", "startOffset": 125, "endOffset": 129}, {"referenceID": 40, "context": "\u25ee We have implemented a DMS optimization module inside the DLV system [43].", "startOffset": 70, "endOffset": 74}, {"referenceID": 2, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 4, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 11, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 13, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 14, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 28, "context": "The application involves data integration and builds on several results in the literature (for example [5,7,14,16,17,31]), which transform the problem of query answering over inconsistent databases (in this context stemming from integrating autonomous data sources) into query answering over disjunctive Datalog programs.", "startOffset": 103, "endOffset": 120}, {"referenceID": 25, "context": "Most of the techniques used in this phase stem from bottom-up methods developed for classic and deductive databases; see for example [1] or [28,43] for details.", "startOffset": 140, "endOffset": 147}, {"referenceID": 40, "context": "Most of the techniques used in this phase stem from bottom-up methods developed for classic and deductive databases; see for example [1] or [28,43] for details.", "startOffset": 140, "endOffset": 147}, {"referenceID": 20, "context": "Details on this process can be found for example in [23].", "startOffset": 52, "endOffset": 56}, {"referenceID": 6, "context": "The specific propagation strategy adopted in the top-down evaluation scheme is called sideways information passing strategy (SIPS), which is just a way of formalizing a partial ordering over the atoms of each rule together with the specification of how the bindings originated and propagate [9,33].", "startOffset": 291, "endOffset": 297}, {"referenceID": 30, "context": "The specific propagation strategy adopted in the top-down evaluation scheme is called sideways information passing strategy (SIPS), which is just a way of formalizing a partial ordering over the atoms of each rule together with the specification of how the bindings originated and propagate [9,33].", "startOffset": 291, "endOffset": 297}, {"referenceID": 60, "context": "The reader is referred to [63] for a detailed presentation.", "startOffset": 26, "endOffset": 30}, {"referenceID": 60, "context": ", P\u2261bQP \u2032 and P\u2261cQP \u2032 hold [63].", "startOffset": 27, "endOffset": 31}, {"referenceID": 30, "context": "As first observed in [33], while in non-disjunctive programs bindings are propagated only head-to-body, a Magic Set transformation for disjunctive programs 3 The Magic Set rewriting of a program P affects only IDB(P), so we usually omit EDB(P) in examples.", "startOffset": 21, "endOffset": 25}, {"referenceID": 30, "context": "The method proposed in [33] circumvents this problem by using some auxiliary predicates that collect all facts coming from the different adornments.", "startOffset": 23, "endOffset": 27}, {"referenceID": 30, "context": "Dynamic Magic Set algorithm (DMS) for Datalog\u2228,\u00acs programs tation in [33], a consequence is that assumptions during the computation cannot be exploited for determining the relevant part of the program.", "startOffset": 69, "endOffset": 73}, {"referenceID": 30, "context": "Our proposal to enhance the Magic Set method for disjunctive Datalog programs has two crucial features compared to the one of [33]:", "startOffset": 126, "endOffset": 130}, {"referenceID": 12, "context": "1 (Strategic Companies [15]) Let C = {c1, .", "startOffset": 23, "endOffset": 27}, {"referenceID": 12, "context": "It is known that the problem retains its hardness (for the second level of the polynomial hierarchy; see [15]) under these restrictions.", "startOffset": 105, "endOffset": 109}, {"referenceID": 41, "context": "In the proofs, we use the well established notion of unfounded set for disjunctive Datalog programs (possibly with negation) defined in [44].", "startOffset": 136, "endOffset": 140}, {"referenceID": 41, "context": "6 in [44] to our notation.", "startOffset": 5, "endOffset": 9}, {"referenceID": 41, "context": "11 ([44]) Let \u3008T,N\u3009 be a partial interpretation for a Datalog program P.", "startOffset": 4, "endOffset": 8}, {"referenceID": 26, "context": "Stratified Datalog programs without disjunction have exactly one stable model [29].", "startOffset": 78, "endOffset": 82}, {"referenceID": 35, "context": "However, the Magic Set transformation can introduce new dependencies between predicates, possibly resulting in unstratified programs (we refer to the analysis in [38]).", "startOffset": 162, "endOffset": 166}, {"referenceID": 40, "context": "The Dynamic Magic Set method (DMS) has been implemented and integrated into the core of the DLV [43] system.", "startOffset": 96, "endOffset": 100}, {"referenceID": 24, "context": "Unfortunately, this approach is unlikely to be feasible in polynomial time, given that subsumption checking on first-order expressions is NP-complete (problem [LO18] in [27]).", "startOffset": 169, "endOffset": 173}, {"referenceID": 42, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 17, "endOffset": 24}, {"referenceID": 51, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 17, "endOffset": 24}, {"referenceID": 42, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 80, "endOffset": 84}, {"referenceID": 51, "context": "We also refer to [45,54] that contain performance evaluations involving DMS; in [45] DLV with DMS was tested on Semantic Web reasoning tasks and confronted with a heterogeneous set of systems, in [54] the system KAON2, which includes a version of DMS, is confronted against other ontology systems.", "startOffset": 196, "endOffset": 200}, {"referenceID": 30, "context": "In order to evaluate the impact of the proposed method, we have compared DMS (using the SIPS defined outlined in Section 4) both with the traditional DLV evaluation without Magic Sets and with the SMS method proposed in [33].", "startOffset": 220, "endOffset": 224}, {"referenceID": 30, "context": "The first three of them had been already used to assess SMS in [33], to which we refer for details:", "startOffset": 63, "endOffset": 67}, {"referenceID": 30, "context": "The structure of the graph, which is the same as the one reported in [33], consists of a square matrix of nodes connected as shown in Figure 7, and the instances have been generated by varying of the number of nodes.", "startOffset": 69, "endOffset": 73}, {"referenceID": 30, "context": "The structure of the \u201cgenealogy\u201d graph is the same as the one presented in [33] and coincides with the one used for testing Simple Path.", "startOffset": 75, "endOffset": 79}, {"referenceID": 27, "context": "This problem is inspired by a setting in planning, in particular testing whether a given plan is conformant with respect to a state transition diagram [30].", "startOffset": 151, "endOffset": 155}, {"referenceID": 25, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 101, "endOffset": 105}, {"referenceID": 18, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 141, "endOffset": 145}, {"referenceID": 43, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 155, "endOffset": 159}, {"referenceID": 34, "context": "In order to assess the effectiveness of DMS on other systems than DLV, we tested the grounder Gringo [28] with the following solvers: ClaspD [21], Cmodels [46], GnT1 and GnT2 [37].", "startOffset": 175, "endOffset": 179}, {"referenceID": 37, "context": "Cmodels is based on the definition of program completion and loop formula for disjunctive programs [40,47], and uses a SAT solver for generating candidate solutions and testing them.", "startOffset": 99, "endOffset": 106}, {"referenceID": 44, "context": "Cmodels is based on the definition of program completion and loop formula for disjunctive programs [40,47], and uses a SAT solver for generating candidate solutions and testing them.", "startOffset": 99, "endOffset": 106}, {"referenceID": 58, "context": "GnT1 is based on Smodels [61], a system handling Datalog programs with unstratified negation (normal programs): A disjunctive program is translated into a normal program, the stable models of which are computed by Smodels and represent stable model candidates of the orig-", "startOffset": 25, "endOffset": 29}, {"referenceID": 38, "context": "Following [41], we formalize a data integration system I as a triple \u3008G,S,M\u3009, where:", "startOffset": 10, "endOffset": 14}, {"referenceID": 0, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 8, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 9, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 11, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 13, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 14, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 15, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 16, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 22, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 23, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 2, "endOffset": 26}, {"referenceID": 1, "context": ", [3,11,12,14,16\u201319,25,26]) is based on the notion of repair for an inconsistent database as introduced in [4].", "startOffset": 107, "endOffset": 110}, {"referenceID": 2, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 4, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 11, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 13, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 14, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 28, "context": "In fact, various authors [5,7,14,16,17,31] considered the idea of encoding the", "startOffset": 25, "endOffset": 42}, {"referenceID": 13, "context": "Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalog programs together with unstratified negation have been considered in [13,51].", "startOffset": 72, "endOffset": 76}, {"referenceID": 10, "context": "Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalog programs together with unstratified negation have been considered in [13,51].", "startOffset": 175, "endOffset": 182}, {"referenceID": 48, "context": "Some of these approaches use logic programs with unstratified negation, [16], whereas disjunctive Datalog programs together with unstratified negation have been considered in [13,51].", "startOffset": 175, "endOffset": 182}, {"referenceID": 21, "context": "Indeed, the benefits of Magic Sets in the context of optimizing logic programs with unstratified negation (but without disjunction) have been discussed in [24].", "startOffset": 155, "endOffset": 159}, {"referenceID": 21, "context": "The Magic Set technique defined in [24] is quite different from the one defined in this article, as it does not consider disjunctive rules, and works only for programs, which are consistent, that is, have at least one stable model.", "startOffset": 35, "endOffset": 39}, {"referenceID": 48, "context": "In [51] our preliminary work reported in [20], which eventually led to the present article, has been expanded in an ad-hoc way to particular kinds of Datalog programs with disjunction and unstratified negation.", "startOffset": 3, "endOffset": 7}, {"referenceID": 17, "context": "In [51] our preliminary work reported in [20], which eventually led to the present article, has been expanded in an ad-hoc way to particular kinds of Datalog programs with disjunction and unstratified negation.", "startOffset": 41, "endOffset": 45}, {"referenceID": 48, "context": "It is ad-hoc in the sense that it is tailored to programs which are created by the transformation described in [51].", "startOffset": 111, "endOffset": 115}, {"referenceID": 48, "context": "The experimental results reported in [51] show huge computational advantages when using Magic Sets.", "startOffset": 37, "endOffset": 41}, {"referenceID": 48, "context": "We now report an alternative transformation which produces Datalogs programs (therefore different to [51], there are no unstratified occurrences of negation).", "startOffset": 101, "endOffset": 105}, {"referenceID": 39, "context": "This rewriting has been devised and used within the INFOMIX system on data integration [42].", "startOffset": 87, "endOffset": 91}, {"referenceID": 13, "context": "Actually, within the INFOMIX project also inclusion dependencies have been considered according to the rewriting discussed in [16], whose details we omit for clarity.", "startOffset": 126, "endOffset": 130}, {"referenceID": 17, "context": "All these applications refer to the preliminary work published in [20].", "startOffset": 66, "endOffset": 70}, {"referenceID": 3, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 31, "endOffset": 34}, {"referenceID": 6, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 52, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 59, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 60, "context": "The method, first developed in [6], has been analyzed and refined by many authors; see, for instance, [9,55,62,63].", "startOffset": 102, "endOffset": 114}, {"referenceID": 7, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 35, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 36, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 56, "context": "A solution has been presented in [10,38,39,59].", "startOffset": 33, "endOffset": 46}, {"referenceID": 35, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 18, "endOffset": 25}, {"referenceID": 56, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 18, "endOffset": 25}, {"referenceID": 7, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 206, "endOffset": 213}, {"referenceID": 36, "context": "In particular, in [38,59] rewritten programs have been evaluated according to the well-founded semantics, a three-valued semantics for Datalog programs which is two-valued for stratified programs, while in [10,39] ad-hoc semantics have been defined.", "startOffset": 206, "endOffset": 213}, {"referenceID": 21, "context": "In [24] a Magic Set method for Datalog programs has been defined and proved to be correct for coherent programs, i.", "startOffset": 3, "endOffset": 7}, {"referenceID": 21, "context": "This method takes special precautions for relevant parts of the program that act as constraints, called dangerous rules in [24].", "startOffset": 123, "endOffset": 127}, {"referenceID": 29, "context": "The first extension of the Magic Set technique to disjunctive Datalog is due to [32,33], where the SMSmethod has been presented and proved to be correct for Datalog programs.", "startOffset": 80, "endOffset": 87}, {"referenceID": 30, "context": "The first extension of the Magic Set technique to disjunctive Datalog is due to [32,33], where the SMSmethod has been presented and proved to be correct for Datalog programs.", "startOffset": 80, "endOffset": 87}, {"referenceID": 29, "context": "Moreover, while the correctness of DMS has been formally established for Datalogs programs in general, the applicability of SMS to Datalogs programs has only been outlined in [32,33].", "startOffset": 175, "endOffset": 182}, {"referenceID": 30, "context": "Moreover, while the correctness of DMS has been formally established for Datalogs programs in general, the applicability of SMS to Datalogs programs has only been outlined in [32,33].", "startOffset": 175, "endOffset": 182}, {"referenceID": 10, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 33, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 48, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 50, "context": "In particular, [13,36,51,53] have profitably exploited the optimization provided by DMS.", "startOffset": 15, "endOffset": 28}, {"referenceID": 10, "context": "In particular, in [13,51] a data integration system has been presented.", "startOffset": 18, "endOffset": 25}, {"referenceID": 48, "context": "In particular, in [13,51] a data integration system has been presented.", "startOffset": 18, "endOffset": 25}, {"referenceID": 33, "context": "In [36,53], instead, an algorithm for answering queries over description logic knowledge bases has been presented.", "startOffset": 3, "endOffset": 10}, {"referenceID": 50, "context": "In [36,53], instead, an algorithm for answering queries over description logic knowledge bases has been presented.", "startOffset": 3, "endOffset": 10}, {"referenceID": 31, "context": ", [34,56,63]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 53, "context": ", [34,56,63]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 60, "context": ", [34,56,63]).", "startOffset": 2, "endOffset": 12}, {"referenceID": 3, "context": "After seminal papers [6,9], the viability of the approach was demonstrated e.", "startOffset": 21, "endOffset": 26}, {"referenceID": 6, "context": "After seminal papers [6,9], the viability of the approach was demonstrated e.", "startOffset": 21, "endOffset": 26}, {"referenceID": 32, "context": ", in [35,55].", "startOffset": 5, "endOffset": 12}, {"referenceID": 52, "context": ", in [35,55].", "startOffset": 5, "endOffset": 12}, {"referenceID": 59, "context": ", query constraints in [62], the wellfounded semantics in [38], or integration into cost-based query optimization in [60].", "startOffset": 23, "endOffset": 27}, {"referenceID": 35, "context": ", query constraints in [62], the wellfounded semantics in [38], or integration into cost-based query optimization in [60].", "startOffset": 58, "endOffset": 62}, {"referenceID": 57, "context": ", query constraints in [62], the wellfounded semantics in [38], or integration into cost-based query optimization in [60].", "startOffset": 117, "endOffset": 121}, {"referenceID": 21, "context": "For instance, in [24] an extension of the Magic Set method was discussed for the class of unstratified logic programs (without disjunction).", "startOffset": 17, "endOffset": 21}, {"referenceID": 7, "context": "In [10] a technique for the class of soft-stratifiable programs was given.", "startOffset": 3, "endOffset": 7}, {"referenceID": 30, "context": "Finally, in [33] the first variant of the technique for disjunctive programs (SMS) was described.", "startOffset": 12, "endOffset": 16}, {"referenceID": 29, "context": "In this paper, we have elaborated on the issues addressed in [32,33].", "startOffset": 61, "endOffset": 68}, {"referenceID": 30, "context": "In this paper, we have elaborated on the issues addressed in [32,33].", "startOffset": 61, "endOffset": 68}, {"referenceID": 40, "context": "\u2022 DMS is integrated into the DLV system [43], profitably exploiting the DLV internal data-structures and the ability of controlling the grounding module.", "startOffset": 40, "endOffset": 44}, {"referenceID": 48, "context": "Importantly, other authors have already recognized the benefits of our optimization strategies with respect to this very important application domain [51], thereby confirming the validity and the robustness of the work discussed in this paper.", "startOffset": 150, "endOffset": 154}, {"referenceID": 35, "context": ", in [38])", "startOffset": 5, "endOffset": 9}, {"referenceID": 5, "context": ", Hyper Tableaux [8]), for which similar relations might hold.", "startOffset": 17, "endOffset": 20}, {"referenceID": 35, "context": "While [38] has already evidenced that an advantage of Magic Sets over such methods is that they may be more easily combined with other optimization techniques, we believe that achieving a deeper comprehension of the relationships among these techniques constitutes an interesting avenue for further research.", "startOffset": 6, "endOffset": 10}], "year": 2012, "abstractText": "In this paper, a new technique for the optimization of (partially) bound queries over disjunctive Datalog programs with stratified negation is presented. The technique exploits the propagation of query bindings and extends the Magic Set optimization technique (originally defined for non-disjunctive programs). An important feature of disjunctive Datalog programs is nonmonotonicity, which calls for nondeterministic implementations, such as backtracking search. A distinguishing characteristic of the new method is that the optimization can be exploited also during the nondeterministic phase. In particular, after some assumptions have been made during the computation, parts of the program may become irrelevant to a query under these assumptions. This allows for dynamic pruning of the search space. In contrast, the effect of the previously defined Magic Set methods for disjunctive Datalog is limited to the deterministic portion of the process. In this way, the potential performance gain by using the proposed method can be exponential, as could be observed empirically. The correctness of the method is established and proved in a formal way thanks to a strong relationship between Magic Sets and unfounded sets that has not been studied in the literature before. This knowledge allows for extending the method and the correctness proof also to programs with stratified negation in a natural way. The proposed method has been implemented in the DLV system and various experiments on synthetic as well as on real-world data have been conducted. The experimental results on synthetic data confirm the utility of Magic Sets for disjunctive Datalog, and they highlight the computational gain that may be obtained by the new method with respect to the previously proposed Magic Set method for disjunctive Datalog programs. Further experiments on data taken from a real-life application show the benefits of the Magic Set method within an application scenario that has received considerable attention in recent years, the problem of answering user queries over possibly inconsistent databases originating from integration of autonomous sources of information.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}