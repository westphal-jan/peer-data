{"id": "1205.4839", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-May-2012", "title": "Off-Policy Actor-Critic", "abstract": "this paper presents the first actor - critic algorithm for off - policy reinforcement learning. our algorithm is equally online and incremental, and its per - time - step complexity scales linearly with the number of learned weights. previous work on actor - critic algorithms is limited to the on - policy setting and does dare not take advantage even of the recent advances in off - policy gradient temporal - difference learning. off - policy techniques, such as greedy - gq, enable a target policy to be learned while following and obtaining relative data from another ( behavior ) policy. for many problems, however, actor - critic methods are more practical than action value sampling methods ( like greedy - gq ) because they explicitly readily represent the policy ; consequently, the policy can safely be stochastic and utilize a relative large action price space. in this paper, we illustrate how to practically combine the generality and learning potential of off - policy learning with the minimum flexibility in action selection given by actor - critic methods. we derive an incremental, linear time and space complexity algorithm that includes eligibility traces, prove convergence under assumptions similar to previous off - policy algorithms, and empirically show better or comparable performance to existing algorithms on standard reinforcement - learning benchmark problems.", "histories": [["v1", "Tue, 22 May 2012 08:36:41 GMT  (1034kb,D)", "http://arxiv.org/abs/1205.4839v1", "Full version of the paper including the appendix; Proceedings of the 2012 International Conference on Machine Learning"], ["v2", "Wed, 23 May 2012 14:36:42 GMT  (1034kb,D)", "http://arxiv.org/abs/1205.4839v2", "Full version of the paper, appendix included"], ["v3", "Tue, 17 Jul 2012 20:40:47 GMT  (1034kb,D)", "http://arxiv.org/abs/1205.4839v3", "Full version of the paper, appendix included"], ["v4", "Tue, 14 Aug 2012 07:08:17 GMT  (1034kb,D)", "http://arxiv.org/abs/1205.4839v4", "Full version of the paper, appendix included; Proceedings of the 2012 International Conference on Machine Learning"], ["v5", "Thu, 20 Jun 2013 10:53:42 GMT  (1035kb,D)", "http://arxiv.org/abs/1205.4839v5", "Full version of the paper, appendix and errata included; Proceedings of the 2012 International Conference on Machine Learning"]], "COMMENTS": "Full version of the paper including the appendix; Proceedings of the 2012 International Conference on Machine Learning", "reviews": [], "SUBJECTS": "cs.LG", "authors": ["thomas degris", "martha white", "richard s sutton"], "accepted": false, "id": "1205.4839"}, "pdf": {"name": "1205.4839.pdf", "metadata": {"source": "META", "title": "Off-Policy Actor-Critic", "authors": ["Thomas Degris", "Richard S. Sutton"], "emails": ["thomas.degris@inria.fr", "whitem@cs.ualberta.ca", "sutton@cs.ualberta.ca"], "sections": [{"heading": null, "text": "The reinforcement learning framework is a general temporal learning formalism that has, over the last few decades, seen a marked growth in algorithms and applications. Until recently, however, practical online\nAppearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s).\nmethods with convergence guarantees have been restricted to the on-policy setting, in which the agent learns only about the policy it is executing.\nIn an off-policy setting, on the other hand, an agent learns about a policy or policies different from the one it is executing. Off-policy methods have a wider range of applications and learning possibilities. Unlike onpolicy methods, off-policy methods are able to, for example, learn about an optimal policy while executing an exploratory policy (Sutton & Barto, 1998), learn from demonstration (Smart & Kaelbling, 2002), and learn multiple tasks in parallel from a single sensorimotor interaction with an environment (Sutton et al., 2011). Because of this generality, off-policy methods are of great interest in many application domains.\nThe most well known off-policy method is Q-learning (Watkins & Dayan, 1992). However, while Q-Learning is guaranteed to converge to the optimal policy for the tabular (non-approximate) case, it may diverge when using linear function approximation (Baird, 1995). Least-squares methods such as LSTD (Bradtke & Barto, 1996) and LSPI (Lagoudakis & Parr, 2003) can be used off-policy and are sound with linear function approximation, but are computationally expensive; their complexity scales quadratically with the number of features and weights. Recently, these problems have been addressed by the new family of gradientTD (Temporal Difference) methods (e.g., Sutton et al., 2009), such as Greedy-GQ (Maei et al., 2010), which are of linear complexity and convergent under off-policy training with function approximation.\nAll action-value methods, including gradient-TD methods such as Greedy-GQ, suffer from three important limitations. First, their target policies are deterministic, whereas many problems have stochastic optimal policies, such as in adversarial settings or in partially observable Markov decision processes. Second, finding the greedy action with respect to the action-\nar X\niv :1\n20 5.\n48 39\nv1 [\ncs .L\nG ]\n2 2\nM ay\n2 01\nvalue function becomes problematic for larger action spaces. Finally, a small change in the action-value function can cause large changes in the policy, which creates difficulties for convergence proofs and for some real-time applications.\nThe standard way of avoiding the limitations of actionvalue methods is to use policy-gradient algorithms (Sutton et al., 2000) such as actor-critic methods (e.g., Bhatnagar et al., 2009). For example, the natural actor-critic, an on-policy policy-gradient algorithm, has been successful for learning in continuous action spaces in several robotics applications (Peters & Schaal, 2008).\nThe first and main contribution of this paper is to introduce the first actor-critic method that can be applied off-policy, which we call Off-PAC, for Off-Policy Actor\u2013Critic. Off-PAC has two learners: the actor and the critic. The actor updates the policy weights. The critic learns an off-policy estimate of the value function for the current actor policy, different from the (fixed) behavior policy. This estimate is then used by the actor to update the policy. For the critic, in this paper we consider a version of Off-PAC that uses GTD(\u03bb) (Maei, 2011), a gradient-TD method with eligibitity traces for learning state-value functions. We define a new objective for our policy weights and derive a valid backward-view update using eligibility traces. The time and space complexity of Off-PAC is linear in the number of learned weights.\nThe second contribution of this paper is an off-policy policy-gradient theorem and a convergence proof for Off-PAC when \u03bb = 0, under assumptions similar to previous off-policy gradient-TD proofs.\nOur third contribution is an empirical comparison of Q(\u03bb), Greedy-GQ, Off-PAC, and a soft-max version of Greedy-GQ that we call Softmax-GQ, on three benchmark problems in an off-policy setting. To the best of our knowledge, this paper is the first to provide an empirical evaluation of gradient-TD methods for off-policy control (the closest known prior work is the work of Delp (2011)). We show that Off-PAC outperforms other algorithms on these problems."}, {"heading": "1. Notation and Problem Setting", "text": "In this paper, we consider Markov decision processes with a discrete state space S, a discrete action spaceA, a distribution P : S \u00d7 S \u00d7A \u2192 [0, 1], where P (s\u2032|s, a) is the probability of transitioning into state s\u2032 from state s after taking action a, and an expected reward function R : S\u00d7A\u00d7S \u2192 R that provides an expected reward for taking action a in state s and transitioning\ninto s\u2032. We observe a stream of data, which includes states st \u2208 S, actions at \u2208 A, and rewards rt \u2208 R for t = 1, 2, . . . with actions selected from a fixed behavior policy, b(a|s) \u2208 (0, 1].\nGiven a termination condition \u03b3 : S \u2192 [0, 1] (Sutton et al., 2011), we define the value function for \u03c0 : S\u00d7A \u2192 (0, 1] to be:\nV \u03c0,\u03b3(s) = E [rt+1 + . . .+ rt+T |st = s] \u2200s \u2208 S (1)\nwhere policy \u03c0 is followed from time step t and terminates at time t + T according to \u03b3. We assume termination always occurs in a finite number of steps.\nThe action-value function, Q\u03c0,\u03b3(s, a), is defined as:\nQ\u03c0,\u03b3(s, a) =\u2211 s\u2032\u2208S P (s\u2032|s, a)[R(s, a, s\u2032) + \u03b3(s\u2032)V \u03c0,\u03b3(s\u2032)] (2) for all a \u2208 A and for all s \u2208 S. Note that V \u03c0,\u03b3(s) =\u2211 a\u2208A \u03c0(a|s)Q\u03c0,\u03b3(s, a), for all s \u2208 S.\nThe policy \u03c0u : A\u00d7S \u2192 [0, 1] is an arbitrary, differentiable function of a weight vector, u \u2208 RNu , Nu \u2208 N, with \u03c0u(a|s) > 0 for all s \u2208 S, a \u2208 A. Our aim is to choose u so as to maximize the following scalar objective function:\nJ\u03b3(u) = \u2211 s\u2208S db(s)V \u03c0u,\u03b3(s) (3)\nwhere db(s) = limt\u2192\u221e P (st = s|s0, b) is the limiting distribution of states under b and P (st = s|s0, b) is the probability that st = s when starting in s0 and executing b. The objective function is weighted by db because, in the off-policy setting, data is obtained according to this behavior distribution. For simplicity of notation, we will write \u03c0 and implicitly mean \u03c0u."}, {"heading": "2. The Off-PAC Algorithm", "text": "In this section, we present the Off-PAC algorithm in three steps. First, we explain the basic theoretical ideas underlying the gradient-TD methods used in the critic. Second, we present our off-policy version of the policy-gradient theorem. Finally, we derive the forward view of the actor and convert it to a backward view to produce a complete mechanistic algorithm using eligibility traces."}, {"heading": "2.1. The Critic: Policy Evaluation", "text": "Evaluating a policy \u03c0 consists of learning its value function, V \u03c0,\u03b3(s), as defined in Equation 1. Since it is often impractical to explicitly represent every\nstate s, we learn a linear approximation of V \u03c0,\u03b3(s): V\u0302 (s) = vTxs where xs \u2208 RNv , Nv \u2208 N, is the feature vector of the state s, and v \u2208 RNv is another weight vector.\nGradient-TD methods (Sutton et al., 2009) incrementally learn the weights, v, in an off-policy setting, with a guarantee of stability and a linear per-time-step complexity. These methods minimize the \u03bb-weighted mean-squared projected Bellman error:\nMSPBE(v) = ||V\u0302 \u2212\u03a0T\u03bb,\u03b3\u03c0 V\u0302 ||2D\nwhere V\u0302 = Xv; X is the matrix whose rows are all xs; \u03bb is the decay of the eligibility trace; D is a matrix with db(s) on its diagonal; \u03a0 is a projection operator that projects a value function to the nearest representable value function given the function approximator; and T\u03bb,\u03b3\u03c0 is the \u03bb-weighted Bellman operator for the target policy \u03c0 with termination probability \u03b3 (e.g., see Maei & Sutton, 2010). For a linear representation, \u03a0 = X(XTDX)\u22121XTD.\nIn this paper, we consider the version of Off-PAC that updates its critic weights by the GTD(\u03bb) algorithm introduced by Maei (2011)."}, {"heading": "2.2. Off-policy Policy-gradient Theorem", "text": "Like other policy gradient algorithms, Off-PAC updates the weights approximately in proportion to the gradient of the objective:\nut+1 \u2212 ut \u2248 \u03b1u,t\u2207uJ\u03b3(ut) (4)\nwhere \u03b1u,t \u2208 R is a positive step-size parameter. Starting from Equation 3, the gradient can be written:\n\u2207uJ\u03b3(u) = \u2207u [\u2211 s\u2208S db(s) \u2211 a\u2208A \u03c0(a|s)Q\u03c0,\u03b3(s, a) ] = \u2211 s\u2208S db(s) \u2211 a\u2208A [\u2207u\u03c0(a|s)Q\u03c0,\u03b3(s, a)\n+ \u03c0(a|s)\u2207uQ\u03c0,\u03b3(s, a) ]\nThe final term in this equation, \u2207uQ\u03c0,\u03b3(s, a), is difficult to estimate in an incremental off-policy setting. The first approximation involved in the theory of OffPAC is to omit this term. That is, we work with an approximation to the gradient, which we denote g(u) \u2208 RNu , defined by\n\u2207uJ\u03b3(u) \u2248 g(u) = \u2211 s\u2208S db(s) \u2211 a\u2208A \u2207u\u03c0(a|s)Q\u03c0,\u03b3(s, a)\n(5) The two theorems below provide justification for this approximation.\nTheorem 1 (Policy Improvement). Given any policy parameter u, let\nu\u2032 = u + \u03b1g(u)\nThen there exists an > 0 such that, for all positive \u03b1 < ,\nJ\u03b3(u \u2032) \u2265 J\u03b3(u)\nFurther, if \u03c0 has a tabular representation (i.e., separate weights for each state), then V \u03c0u\u2032 ,\u03b3(s) \u2265 V \u03c0u,\u03b3(s) for all s \u2208 S.\n(Proof in Appendix).\nIn the conventional on-policy theory of policy-gradient methods, the policy-gradient theorem (Marbach & Tsitsiklis, 1998; Sutton et al., 2000) establishes the relationship between the gradient of the objective function and the expected action values. In our notation, that theorem essentially says that our approximation is exact, that g(u) = \u2207uJ\u03b3(u). Although, we can not show this in the off-policy case, we can establish a relationship between the solutions found using the true and approximate gradient:\nTheorem 2 (Off-Policy Policy-Gradient Theorem). Given U \u2282 RNu a non-empty, compact set, let\nZ\u0303 = {u \u2208 U | g(u) = 0} Z = {u \u2208 U | \u2207uJ\u03b3(u) = 0}\nwhere Z is the true set of local maxima and Z\u0303 the set of local maxima obtained from using the approximate gradient, g(u). If the value function can be represented by our function class, then Z \u2282 Z\u0303. Moreover, if we use a tabular representation for \u03c0, then Z = Z\u0303.\n(Proof in Appendix).\nThe proof of Theorem 2, showing that Z = Z\u0303, requires tabular \u03c0 to avoid update overlap: updates to a single parameter influence the action probabilities for only one state. Consequently, both parts of the gradient (one part with the gradient of the policy function and the other with the gradient of the action-value function) locally greedily change the action probabilities for only that one state. Extrapolating from this result, in practice, more generally a local representation for \u03c0 will likely suffice, where parameter updates influence only a small number of states. Similarly, in the non-tabular case, the claim will likely hold if \u03b3 is small (the return is myopic), again because changes to the policy mostly affect the action-value function locally.\nFortunately, from an optimization perspective, for all u \u2208 Z\u0303\\Z, J\u03b3(u) < minu\u2032\u2208Z J\u03b3(u\u2032), in other words,\nZ represents all the largest local maxima in Z\u0303 with respect to the objective, J\u03b3 . Local optimization techniques, like random restarts, should help ensure that we converge to larger maxima and so to u \u2208 Z. Even with the true gradient, these approaches would be incorporated into learning because our objective, J\u03b3 , is non-convex."}, {"heading": "2.3. The Actor: Incremental Update Algorithm with Eligibility Traces", "text": "We now derive an incremental update algorithm using observations sampled from the behavior policy. First, we rewrite Equation 5 as an expectation:\ng(u) = E [\u2211 a\u2208A \u2207u\u03c0(a|s)Q\u03c0,\u03b3(s, a) \u2223\u2223\u2223\u2223\u2223s \u223c db ]\n= E [\u2211 a\u2208A b(a|s)\u03c0(a|s) b(a|s) \u2207u\u03c0(a|s) \u03c0(a|s) Q\u03c0,\u03b3(s, a) \u2223\u2223\u2223\u2223\u2223s \u223c db ]\n= E [ \u03c1(s, a)\u03c8(s, a)Q\u03c0,\u03b3(s, a) \u2223\u2223s \u223c db, a \u223c b(\u00b7|s)] = Eb [\u03c1(s, a)\u03c8(s, a)Q \u03c0,\u03b3(s, a)]\nwhere \u03c1(s, a) = \u03c0(a|s)b(a|s) , \u03c8(s, a) = \u2207u\u03c0(a|s) \u03c0(a|s) , and we introduce the new notation Eb [\u00b7] to denote the expectation conditional on the states and actions being generated by the behavior policy, as indicated above. A standard result (e.g., see Sutton et al., 2000) is that an arbitrary function of state can be introduced into the above equation as a baseline without changing the expected value. We use the approximate state-value function provided by the critic, V\u0302 (s), in this way:\ng(u) = Eb\n[ \u03c1(s, a)\u03c8(s, a) ( Q\u03c0,\u03b3(s, a)\u2212 V\u0302 (s) )] The next step is to replace the action value, Q\u03c0,\u03b3(s, a), by the off-policy \u03bb-return. Consider a sequence of states, actions, and rewards {st, at, rt+1}\u221et=0 generated by following the behavior policy. Then g(u) can be approximated by:\ng(u) \u2248 g\u0302(u) = Eb [ \u03c1(st, at)\u03c8(st, at) ( R\u03bbt \u2212 V\u0302 (s) )] where the off-policy \u03bb-return is defined by:\nR\u03bbt = rt+1 + (1\u2212 \u03bb)\u03b3(st+1)V\u0302 (st+1) + \u03bb\u03b3(st+1)\u03c1(st+1, at+1)R \u03bb t+1\nThe quantity g\u0302(u) is an approximation because the \u03bbreturn involves the approximate state-value function, V\u0302 . Finally, based on this equation, we can write the forward view of Off-PAC:\nut+1 \u2212 ut = \u03b1u,t\u03c1(st, at)\u03c8(st, at) ( R\u03bbt \u2212 V\u0302 (s) )\nAlgorithm 1 The Off-PAC algorithm\nInitialize the vectors ev, eu, and w to zero Initialize the vectors v and u arbitrarily Initialize the state s For each step:\nChoose an action, a, according to b(\u00b7|s) Observe resultant reward, r, and next state, s\u2032 \u03b4 \u2190 r + \u03b3(s\u2032)vTxs\u2032 \u2212 vTxs \u03c1\u2190 \u03c0u(a|s)/b(a|s) Update the critic (GTD(\u03bb) algorithm):\nev \u2190 \u03c1 (xs + \u03b3(s)\u03bbev) v\u2190 v + \u03b1v [ \u03b4ev \u2212 \u03b3(s\u2032)(1\u2212 \u03bb)(wTev)xs ] w\u2190 w + \u03b1w [ \u03b4ev \u2212 (wTxs)xs\n] Update the actor:\neu \u2190 \u03c1 [ \u2207u\u03c0u(a|s) \u03c0u(a|s) + \u03b3(s)\u03bbeu ] u\u2190 u + \u03b1u\u03b4eu\ns\u2190 s\u2032\nThe forward view is useful for understanding and analyzing algorithms, but for a mechanistic implementation it must be converted to a backward view that does not involve the \u03bb-return. The key step, proved in the appendix, is the observation that\n\u03c1(st, at)\u03c8(st, at)E [ R\u03bbt \u2212 V\u0302 (st) \u2223\u2223\u2223st, at] = E [\u03b4tet|st, at] (6)\nwhere \u03b4t = rt+1 + \u03b3(st+1)V\u0302 (st+1) \u2212 V\u0302 (st) is the conventional temporal difference error, and et \u2208 RNu is the eligibility trace of \u03c8, updated by:\net = \u03c1(st, at) (\u03c8(st, at) + \u03bbet\u22121)\nFinally, combining the three previous equations, the backward view of the actor update can be written simply as:\nut+1 \u2212 ut = \u03b1u,t\u03b4tet\nThe complete Off-PAC algorithm is given above as Algorithm 1. Note that although the algorithm is written in terms of states s and s\u2032, it really only ever needs access to the corresponding feature vectors, xs and xs\u2032 . Also note that Off-PAC is fully incremental and has per-time step computation and memory complexity that is linear in the number of weights, Nu +Nv.\nWith discrete actions, a common policy distribution is the Gibbs distribution, which uses a linear combination of features \u03c0(a|s) = e uT\u03c6s,a\u2211 b e uT\u03c6s,b where \u03c6s,a are state-action features for state s, action a, and where\n\u03c8(s, a) = \u2207u\u03c0(a|s)\u03c0(a|s) = \u03c6s,a \u2212 \u2211 b \u03c0(b|s)\u03c6s,b. The stateaction features, \u03c6s,a, are potentially unrelated to the feature vectors xs used in the critic."}, {"heading": "3. Convergence Analysis", "text": "Our algorithm has the same recursive stochastic form as the off-policy value-function algorithms\nut+1 = ut + \u03b1t(h(ut,vt) +Mt+1)\nwhere h : RN \u2192 RN is a differentiable function and {Mt}t\u22650 is a noise sequence. Following previous offpolicy gradient proofs (Maei, 2011), we study the behavior of the ordinary differential equation\nu\u0307(t) = u(h(u(t),v))\nThe two updates (for the actor and for the critic) are not independent on each time step; we analyze two separate ODEs using a two timescale analysis (Borkar, 2008). The actor update is analyzed given fixed critic parameters, and vice versa, iteratively (until convergence). We make the following assumptions.\n(A1) The policy viewed as a function of u, \u03c0(\u00b7)(a|s) : RNu \u2192 (0, 1], is continuously differentiable, \u2200s \u2208 S, a \u2208 A.\n(A2) The update on ut includes a projection operator, \u0393 : RNu \u2192 RNu , that projects any u to a compact set U = {u | qi(u) \u2264 0, i = 1, . . . , s} \u2282 RNu , where qi(\u00b7) : RNu \u2192 R are continuously differentiable functions specifying the constraints of the compact region. For u on the boundary of U , the gradients of the active qi are linearly independent. Assume the compact region is large enough to contain at least one (local) maximum of J\u03b3 .\n(A3) The behavior policy has a minimum positive value bmin \u2208 (0, 1]: b(a|s) \u2265 bmin \u2200s \u2208 S, a \u2208 A\n(A4) The sequence (xt,xt+1, rt+1)t\u22650 is i.i.d. and has uniformly bounded second moments.\n(A5) For every u \u2208 U (the compact region to which u is projected), V \u03c0,\u03b3 : S \u2192 R is bounded.\nRemark 1: It is difficult to prove the boundedness of the iterates without the projection operator. Since we have a bounded function (with range (0, 1]), we could instead assume that the gradient goes to zero exponentially as u \u2192 \u221e, ensuring boundedness. Previous work, however, has illustrated that the stochasticity in practice makes convergence to an unstable equilibrium unlikely (Pemantle, 1990); therefore, we avoid restrictions on the policy function and do not include the projection in our algorithm\nFinally, we have the following (standard) assumptions on features and step-sizes.\n(P1) ||xt||\u221e <\u221e, \u2200t, where xt \u2208 RNv\n(P2) Matrices C = E[xtxt T], A = E[xt(xt \u2212 \u03b3xt+1)T]\nare non-singular and uniformly bounded. A, C and E[rt+1xt] are well-defined because the distribution of (xt,xt+1, rt+1) does not depend on t.\n(S1) \u03b1v,t, \u03b1w,t, \u03b1u,t > 0, \u2200t are deterministic such that\u2211 t \u03b1v,t = \u2211 t \u03b1w,t = \u2211 t \u03b1u,t =\u221e and \u2211 t \u03b1 2 v,t <\n\u221e, \u2211 t \u03b1 2 w,t <\u221e and \u2211 t \u03b1 2 u,t <\u221e with \u03b1u,t \u03b1v,t \u2192 0.\n(S2) Define H(A) . = (A + AT)/2 and let\n\u03bbmin(C \u22121H(A)) be the minimum eigenvalue of the matrix C\u22121H(A)1. Then \u03b1w,t = \u03b7\u03b1v,t for some \u03b7 > max(0,\u2212\u03bbmin(C\u22121H(A))).\nRemark 2: The assumption \u03b1u,t/\u03b1v,t \u2192 0 in (S1) states that the actor step-sizes go to zero at a faster rate than the value function step-sizes: the actor update moves on a slower timescale than the critic update (which changes more from its larger step sizes). This timescale is desirable because we effectively want a converged value function estimate for the current policy weights, ut. Examples of suitable step sizes are \u03b1v,t = 1 t , \u03b1u,t = 1 1+t log t or \u03b1v,t = 1 t2/3 , \u03b1u,t = 1 t . (with \u03b1w,t = \u03b7\u03b1v,t for \u03b7 satisfying (S2)).\nThe above assumptions are actually quite unrestrictive. Most algorithms inherently assume bounded features with bounded value functions for all policies; unbounded values trivially result in unbounded value function weights. Common policy distributions are smooth, making \u03c0(a|s) continuously differentiable in u. The least practical assumption is that the tuples (xt,xt+1, rt+1) are i.i.d., in other words, Martingale noise instead of Markov noise. For Markov noise, our proof as well as the proofs for GTD(\u03bb) and GQ(\u03bb), require Borkar\u2019s (2008) two-timescale theory to be extended to Markov noise (which is outside the scope of this paper). Finally, the proof for Theorem 3 assumes \u03bb = 0, but should extend to \u03bb > 0 similarly to GTD(\u03bb) (see Maei, 2011, Section 7.4, for convergence remarks).\nWe give a proof sketch of the following convergence theorem, with the full proof in the appendix.\nTheorem 3 (Convergence of Off-PAC). Let \u03bb = 0 and consider the Off-PAC iterations with GTD(0)2 for the critic. Assume that (A1)-(A5), (P1)-(P2) and (S1)(S2) hold. Then the policy weights, ut, converge to Z\u0302 = {u \u2208 U | g\u0302(u) = 0} and the value function weights, vt, converge to the corresponding TD-solution with probability one.\nProof Sketch: We follow a similar outline to the two timescale analysis for on-policy policy gradient\n1Minimum exists as all eigenvalues real-valued (Lemma 4) 2GTD(0) is GTD(\u03bb) with \u03bb = 0, not the different algorithm called GTD(0) by Sutton, Szepesvari & Maei (2008)\nactor-critic (Bhatnagar et al., 2009) and for nonlinear GTD (Maei et al., 2009). We analyze the dynamics for our two weights, ut and zt T = (wt Tvt\nT), based on our update rules. The proof involves satisfying seven requirements from Borkar (2008, p. 64) to ensure convergence to an asymptotically stable equilibrium."}, {"heading": "4. Empirical Results", "text": "This section compares the performance of Off-PAC to three other off-policy algorithms with linear memory and computational complexity: 1) Q(\u03bb) (called QLearning when \u03bb = 0), 2) Greedy-GQ (GQ(\u03bb) with a greedy target policy), and 3) Softmax-GQ (GQ(\u03bb) with a Softmax target policy). The policy in Off-PAC is a Gibbs distribution as defined in section 2.3.\nWe used three benchmarks: mountain car, a pendulum problem and a continuous grid world. These problems all have a discrete action space and a continuous state space, for which we use function approximation. The behavior policy is a uniform distribution over all the possible actions in the problem for each time step. Note that Q(\u03bb) may not be stable in this setting (Baird, 1995), unlike all the other algorithms.\nThe goal of the mountain car problem (see Sutton & Barto, 1998) is to drive an underpowered car to the top of a hill. The state of the system is composed of the current position of the car (in [\u22121.2, 0.6]) and its velocity (in [\u2212.07, .07]). The car was initialized with a position of -0.5 and a velocity of 0. Actions are a throttle of {\u22121, 0, 1}. The reward at each time step is \u22121. An episode ends when the car reaches the top of the hill on the right or after 5,000 time steps.\nThe second problem is a pendulum problem (Doya, 2000). The state of the system consists of the angle (in radians) and the angular velocity (in [\u221278.54, 78.54]) of the pendulum. Actions, the torque applied to the base, are {\u22122, 0, 2}. The reward is the cosine of the angle of the pendulum with respect to its fixed base. The pendulum is initialized with an angle and an angular velocity of 0 (i.e., stopped in a horizontal position). An episode ends after 5,000 time steps.\nFor the pendulum problem, it is unlikely that the behavior policy will explore the optimal region where the pendulum is maintained in a vertical position. Consequently, this experiment illustrates which algorithms make best use of limited behavior samples.\nThe last problem is a continuous grid-world. The state is a 2-dimensional position in [0, 1]2. The actions are the pairs {(0.0, 0.0), (\u2212.05, 0.0), (.05, 0.0), (0.0,\u2212.05), (0.0, .05)}, representing moves in both dimensions. Uniform noise in [\u2212.025, .025] is added\nto each action component. The reward at each time step for arriving in a position (px, py) is defined as: \u22121 + \u22122(N (px, .3, .1) \u00b7 N (py, .6, .03) + N (px, .4, .03)\u00b7N (py, .5, .1)+N (px, .8, .03)\u00b7N (py, .9, .1)) where N (p, \u00b5, \u03c3) = e\u2212 (p\u2212\u00b5)2 2\u03c32 /\u03c3 \u221a\n2\u03c0. The start position is (0.2, 0.4) and the goal position is (1.0, 1.0). An episode ends when the goal is reached, that is when the distance from the current position to the goal is less than 0.1 (using the L1-norm), or after 5,000 time steps. Figure 1 shows a representation of the problem.\nThe feature vectors xs were binary vectors constructed according to the standard tile-coding technique (Sutton & Barto, 1998). For all problems, we used ten tilings, each of roughly 10 \u00d7 10 over the joint space of the two state variables, then hashed to a vector of dimension 106. An addition feature was added that was always 1. State-action features, \u03c8s,a, were also 106 + 1 dimensional vectors constructed by also hashing the actions. We used a constant \u03b3 = 0.99. All the weight vectors were initialized to 0. We performed a parameter sweep to select the following parameters: 1) the step size \u03b1v for Q(\u03bb), 2) the step-sizes \u03b1v and \u03b1w for the two vectors in Greedy-GQ, 3) \u03b1v, \u03b1w and the temperature \u03c4 of the target policy distribution for Softmax-GQ and 4) the step sizes \u03b1v, \u03b1w and \u03b1u for Off-PAC. For the step sizes, the sweep was done over the following values: {10\u22124, 5 \u00b7 10\u22124, 10\u22123, . . . , .5, 1.} divided by 10+1=11, that is the number of tilings plus 1. To compare TD methods to gradient-TD methods, we also used \u03b1w = 0. The temperature parameter, \u03c4 , was chosen from {.01, .05, .1, .5, 1, 5, 10, 50, 100} and \u03bb from {0, .2, .4, .6, .8, .99}. We ran thirty runs\nwith each setting of the parameters.\nFor each parameter combination, the learning algorithm updates a target policy online from the data generated by the behavior policy. For all the problems, the target policy was evaluated at 20 points in time during the run by running it 5 times on another instance of the problem. The target policy was not updated during evaluation, ensuring that it was learned only with data from the behavior policy.\nFigure 2 shows results on three problems. SoftmaxGQ and Off-PAC improved their policy compared to the behavior policy on all problems, while the improvements for Q(\u03bb) and Greedy-GQ is limited on the continuous grid world. Off-PAC performed best on all problems. On the continuous grid world, Off-PAC was the only algorithm able to learn a policy that reliably found the goal after 5,000 episodes (see Figure 1). On all problems, Off-PAC had the lowest standard error."}, {"heading": "5. Discussion", "text": "Off-PAC, like other two-timescale update algorithms, can be sensitive to parameter choices, particularly the step-sizes. Off-PAC has four parameters: \u03bb and the\nthree step sizes, \u03b1v and \u03b1w for the critic and \u03b1u for the actor. In practice, the following procedure can be used to set these parameters. The value of \u03bb, as with other algorithms, will depend on the problem and it is often better to start with low values (less than .4). A common heuristic is to set \u03b1v to 0.1 divided by the norm of the feature vector, xs, while keeping the value of \u03b1w low. Once GTD(\u03bb) is stable learning the value function with \u03b1u = 0, \u03b1u can be increased so that the policy of the actor can be improved. This corroborates the requirements in the proof, where the step-sizes should be chosen so that the slow update (the actor) is not changing as quickly as the fast inner update to the value function weights (the critic).\nAs mentioned by Borkar (2008, p. 75), another scheme that works well in practice is to use the restrictions on the step-sizes in the proof and to also subsample updates for the slow update. Subsampling updates means only updating every {tN, t \u2265 0}, for some N > 1: the actor is fixed in-between tN and (t+ 1)N while the critic is being updated. This further slows the actor update and enables an improved value function estimate for the current policy, \u03c0.\nIn this work, we did not explore incremental natural\nactor-critic methods (Bhatnagar et al., 2009), which use the natural gradient as opposed to the conventional gradient. The extension to off-policy natural actorcritic should be straightforward, involving only a small modification to the update and analysis of this new dynamical system (which will have similar properties to the original update).\nFinally, as pointed out by Precup et al. (2006), offpolicy updates can be more noisy compared to onpolicy learning. The results in this paper suggest that Off-PAC is more robust to such noise because it has lower variance than the action-value based methods. Consequently, we think Off-PAC is a promising direction for extending off-policy learning to a more general setting such as continuous action spaces."}, {"heading": "6. Conclusion", "text": "This paper proposed a new algorithm for learning control off-policy, called Off-PAC (Off-Policy ActorCritic). We proved that Off-PAC converges in a standard off-policy setting. We provided one of the first empirical evaluations of off-policy control with the new gradient-TD methods and showed that Off-PAC has the best final performance on three benchmark problems and consistently has the lowest standard error. Overall, Off-PAC is a significant step toward robust off-policy control."}, {"heading": "7. Acknowledgments", "text": "This work was supported by MPrime, the Alberta Innovates Centre for Machine Learning, the Glenrose Rehabilitation Hospital Foundation, Alberta Innovates\u2014 Technology Futures, NSERC and the ANR MACSi project. Computational time was provided by Westgrid and the Me\u0301socentre de Calcul Intensif Aquitain."}, {"heading": "Appendix: see http://arxiv.org", "text": ""}, {"heading": "Baird, L. (1995). Residual algorithms: Reinforcement", "text": "learning with function approximation. In Proceedings of the Twelfth International Conference on Machine Learning, pp. 30\u201337. Morgan Kaufmann."}, {"heading": "Bhatnagar, S., Sutton, R. S., Ghavamzadeh, M., Lee, M.", "text": "(2009). Natural actor-critic algorithms. Automatica 45 (11):2471\u20132482. Borkar, V. S. (2008). Stochastic approximation: A dynamical systems viewpoint. Cambridge Univ Press."}, {"heading": "Bradtke, S. J., Barto, A. G. (1996). Linear least-squares", "text": "algorithms for temporal difference learning. Machine Learning 22 :33\u201357."}, {"heading": "Delp, M. (2010). Experiments in off-policy reinforcement", "text": "learning with the GQ(\u03bb) algorithm. Masters thesis,\nUniversity of Alberta.\nDoya, K. (2000). Reinforcement learning in continuous time and space. Neural computation 12 :219\u2013245. Lagoudakis, M., Parr, R. (2003). Least squares policy iteration. Journal of Machine Learning Research 4 :1107\u2013 1149. Maei, H. R., Sutton, R. S. (2010). GQ(\u03bb): A general gradient algorithm for temporal-difference prediction learning with eligibility traces. In Proceedings of the Third Conf. on Artificial General Intelligence. Maei, H. R. (2011). Gradient Temporal-Difference Learning Algorithms. PhD thesis, University of Alberta."}, {"heading": "Maei, H. R., Szepesva\u0301ri, C., Bhatnagar, S., Precup, D.,", "text": "Silver, D., Sutton, R. S. (2009). Convergent temporaldifference learning with arbitrary smooth function approximation. Advances in Neural Information Processing Systems 22 :1204\u20131212."}, {"heading": "Maei, H. R., Szepesva\u0301ri, C., Bhatnagar, S., Sutton, R. S.", "text": "(2010). Toward off-policy learning control with function approximation. Proceedings of the 27th International Conference on Machine Learning. Marbach, P., Tsitsiklis, J. N. (1998). Simulation-based optimization of Markov reward processes. Technical report LIDS-P-2411. Pemantle, R. (1990). Nonconvergence to unstable points in urn models and stochastic approximations. The Annals of Probability 18 (2):698\u2013712. Peters, J., Schaal, S. (2008). Natural actor-critic. Neurocomputing 71 (7):1180\u20131190."}, {"heading": "Precup, D., Sutton, R.S., Paduraru, C., Koop, A., Singh,", "text": "S. (2006). Off-policy learning with recognizers. Neural Information Processing Systems 18. Smart, W.D., Pack Kaelbling, L. (2002). Effective reinforcement learning for mobile robots. In Proceedings of International Conference on Robotics and Automation, volume 4, pp. 3404\u20133410. Sutton, R. S., Barto, A. G. (1998). Reinforcement Learning: An Introduction. MIT Press."}, {"heading": "Sutton, R. S., McAllester, D., Singh, S., Mansour, Y.", "text": "(2000). Policy gradient methods for reinforcement learning with function approximation. Advances in Neural Information Processing Systems 12. Sutton, R. S., Szepesva\u0301ri, Cs., Maei, H. R. (2008). A convergent O(n) algorithm for off-policy temporaldifference learning with linear function approximation. In Advances in Neural Information Processing Systems 21, pp. 1609\u20131616."}, {"heading": "Sutton, R. S., Maei, H. R., Precup, D., Bhatnagar, S.,", "text": "Silver, D., Szepesva\u0301ri, Cs., Wiewiora, E. (2009). Fast gradient-descent methods for temporal-difference learning with linear function approximation. In Proceedings of the 26th Annual International Conference on Machine Learning, pp. 993\u20131000."}, {"heading": "Sutton, R. S., Modayil, J., Delp, M., Degris, T., Pilarski,", "text": "P. M., and Precup, D. (2011). Horde: A scalable realtime architecture for learning knowledge from unsupervised sensorimotor interaction. In Proceedings of the 10th International Conference on Autonomous Agents and Multiagent Systems. Watkins, C. J. C. H., Dayan, P. (1992). Q-learning. Machine Learning 8 (3):279\u2013292."}, {"heading": "A. Appendix of Off-Policy Actor-Critic", "text": ""}, {"heading": "A.1. Policy Improvement and Policy Gradient Theorems", "text": "Theorem 1 [Off-Policy Policy Improvement Theorem] Given any policy parameter u, let\nu\u2032 = u + \u03b1g(u)\nThen there exists an > 0 such that, for all positive \u03b1 < ,\nJ\u03b3(u \u2032) \u2265 J\u03b3(u)\nFurther, if \u03c0 has a tabular representation (i.e., separate weights for each state), then V \u03c0u\u2032 ,\u03b3(s) \u2265 V \u03c0u,\u03b3(s) for all s \u2208 S.\nProof. Notice first that for any (s, a), the gradient \u2207u\u03c0(a|s) is the direction to increase the probability of action a according to function \u03c0(\u00b7|s). For an appropriate step size \u03b1u,t (so that the update to \u03c0u\u2032 increases the objective with the action-value function Q\u03c0u,\u03b3 , fixed as the old action-value function), we can guarantee that\nJ\u03b3(u) = \u2211 s\u2208S db(s) \u2211 a\u2208A \u03c0u(a|s)Q\u03c0u,\u03b3(s, a)\n\u2264 \u2211 s\u2208S db(s) \u2211 a\u2208A \u03c0u\u2032(a|s)Q\u03c0u,\u03b3(s, a)\nNow we can proceed similarly to the Policy Improvement theorem proof provided by Sutton and Barto (1998) by extending the right-hand side using the definition of Q\u03c0,\u03b3(s, a) (equation 2):\nJ\u03b3(ut) \u2264 \u2211 s\u2208S db(s) \u2211 a\u2208A \u03c0u\u2032(a|s)E [rt+1 + \u03b3t+1V \u03c0u,\u03b3(st+1)|\u03c0u\u2032 , \u03b3]\n\u2264 \u2211 s\u2208S db(s) \u2211 a\u2208A \u03c0u\u2032(a|s)E [rt+1 + \u03b3t+1rt+2 + \u03b3t+2V \u03c0u,\u03b3(st+2)|\u03c0u\u2032 , \u03b3]\n...\n\u2264 \u2211 s\u2208S db(s) \u2211 a\u2208A \u03c0u\u2032(a|s)Q\u03c0u\u2032 ,\u03b3(s, a) = J\u03b3(u \u2032)\nThe second part of the Theorem has similar proof to the above. With a tabular representation for \u03c0, we know that the gradient satisfies: \u2211\na\u2208A \u03c0u(a|s)Q\u03c0u,\u03b3(s, a) \u2264 \u2211 a\u2208A \u03c0u\u2032(a|s)Q\u03c0u,\u03b3(s, a)\nbecause the probabilities can be updated independently for each state with separate weights for each state.\nNow for any s \u2208 S: V \u03c0u,\u03b3(s) = \u2211 a\u2208A \u03c0u(a|s)Q\u03c0u,\u03b3(s, a)\n\u2264 \u2211 a\u2208A \u03c0u\u2032(a|s)Q\u03c0u,\u03b3(s, a)\n\u2264 \u2211 a\u2208A \u03c0u\u2032(a|s)E [rt+1 + \u03b3t+1V \u03c0u,\u03b3(st+1)|\u03c0u\u2032 , \u03b3]\n\u2264 \u2211 a\u2208A \u03c0u\u2032(a|s)E [rt+1 + \u03b3t+1rt+2 + \u03b3t+2V \u03c0u,\u03b3(st+2)|\u03c0u\u2032 , \u03b3]\n...\n\u2264 \u2211 a\u2208A \u03c0u\u2032(a|s)Q\u03c0u\u2032 ,\u03b3(s, a) = V \u03c0u\u2032 ,\u03b3(s)\nTheorem 2 [Off-Policy Policy Gradient Theorem] Let Z = {u \u2208 U | \u2207uJ\u03b3(u) = 0} and Z\u0303 = {u \u2208 U | g(u) = 0}, which are both non-empty by Assumption (A2). If the value function can be represented by our function class, then\nZ \u2282 Z\u0303\nMoreover, if we use a tabular representation for \u03c0, then\nZ = Z\u0303\nProof. This theorem follows from our policy improvement theorem.\nAssume there exists u\u2217 \u2208 Z such that u\u2217 /\u2208 Z\u0303. Then \u2207u\u2217J\u03b3(u) = 0 but g(u\u2217) 6= 0. By the policy improvement theorem (Theorem 1), we know that J\u03b3(u \u2217 + \u03b1u,tg(u \u2217)) > J\u03b3(u), for some positive \u03b1u,t. However, this is a contradiction, as the true gradient is zero. Therefore, such an u\u2217 cannot exist.\nFor the second part of the theorem, we have a tabular representation, in other words, each weight corresponds to exactly one state. Without loss of generality, assume each state s is represented with m \u2208 N weights, indexed by let is,1 . . . is,m in the vector u. Therefore, for any state, s\u2211\ns\u2032\u2208S db(s\u2032) \u2211 a\u2208A \u2202 \u2202uis,j \u03c0u(a|s\u2032)Q\u03c0u,\u03b3(s\u2032, a) = db(s) \u2211 a\u2208A \u2202 \u2202uis,j \u03c0u(a|s)Q\u03c0u,\u03b3(s, a) . = g1(uis,j )\nAssume there exists s \u2208 S such that g1(uis,j ) = 0 \u2200j but there exists 1 \u2264 k \u2264 m for g2(uis,k) . =\u2211\ns\u2032\u2208S d b(s\u2032) \u2211 a\u2208A \u03c0u(a|s\u2032)\n\u2202 \u2202uis,k Q\u03c0u,\u03b3(s\u2032, a) such that g2(uis,k) 6= 0. \u2202\u2202uisQ \u03c0u,\u03b3(s\u2032, a) can only increase the\nvalue of Q\u03c0u,\u03b3(s, a) locally (i.e., shift the probabilities of the actions to increase return), because it cannot change the value in other states (uis is only used for state s and the remaining weights are fixed when this partial derivative is computed). Therefore, since g2(uis,k) 6= 0, we must be able to increase the value of state s by changing the probabilities of the actions in state s\n=\u21d2 m\u2211 j=1 \u2211 a\u2208A \u2202 \u2202uis,j \u03c0u(a|s)Q\u03c0u,\u03b3(s, a) 6= 0\nwhich is a contradiction (since we assumed g1(uis,j ) = 0 \u2200j). Therefore, in the tabular case, whenever \u2211 s d b(s) \u2211 a\u2207u\u03c0u(a|s)Q\u03c0u,\u03b3(s, a) = 0, then\u2211\ns d b(s) \u2211 a \u03c0u(a|s)\u2207uQ\u03c0u,\u03b3(s, a) = 0, implying that Z\u0303 \u2282 Z. Since we already know that Z \u2282 Z\u0303, then\nwe can conclude that for a tabular representation for \u03c0, Z = Z\u0303.\nA.2. Forward/Backward view analysis\nIn this section, we prove Equation 6, the key relationship between the forward and backward views: \u03c1(st, at)\u03c8(st, at)E [ R\u03bbt \u2212 V\u0302 (st) \u2223\u2223\u2223st, at] = E [\u03b4tet|st, at] where in these expectations, and in all the expectations in this section, the indicated state\u2013action pair, (st, at), is considered given (non-stochastic) and the future states and actions are presumed given stochastically by the environment and the behavior policy respectively. The expectation is over these future random variables. We also assume that the behavior policy is stationary and that the Markov chain is aperiodic and irreducible (i.e., we have reached the limiting distribution, db over s \u2208 S).\nTo simplify the notation for this section, we define \u03c1t = \u03c1(st, at), \u03c8t = \u03c8(st, at), \u03b3t = \u03b3(st), and \u03b4 \u03bb t = R \u03bb t \u2212 V\u0302 (st). With this notation, the expression to be proved can be written:\n\u03c1t\u03c8tE [ \u03b4\u03bbt \u2223\u2223st, at] = E [\u03b4tet|st, at]\nProof. First we note that \u03b4\u03bbt , which might be called the forward-view TD error, can be written recursively:\n\u03b4\u03bbt = R \u03bb t \u2212 V\u0302 (st)\n= rt+1 + (1\u2212 \u03bb)\u03b3t+1V\u0302 (st+1) + \u03bb\u03b3t+1\u03c1t+1R\u03bbt+1 \u2212 V\u0302 (st) = rt+1 + \u03b3t+1V\u0302 (st+1)\u2212 \u03bb\u03b3t+1V\u0302 (st+1) + \u03bb\u03b3t+1\u03c1t+1R\u03bbt+1 \u2212 V\u0302 (st)\n= rt+1 + \u03b3t+1V\u0302 (st+1)\u2212 V\u0302 (st) + \u03bb\u03b3t+1 ( \u03c1t+1R \u03bb t+1 \u2212 V\u0302 (st+1) ) = \u03b4t + \u03bb\u03b3t+1 ( \u03c1t+1R \u03bb t+1 \u2212 \u03c1t+1V\u0302 (st+1)\u2212 (1\u2212 \u03c1t+1)V\u0302 (st+1)\n) = \u03b4t + \u03bb\u03b3t+1 ( \u03c1t+1\u03b4 \u03bb t+1 \u2212 (1\u2212 \u03c1t+1)V\u0302 (st+1) ) (7)\nwhere \u03b4t = rt+1 + \u03b3t+1V\u0302 (st+1)\u2212 V\u0302 (st) is the conventional one-step TD error.\nWith this groundwork, we are ready to prove the main result. To simplify notation, in the expectations below the conditioning on st, at is suppressed:\n\u03c1t\u03c8tE [ \u03b4\u03bbt ]\n= E [ \u03c1t\u03c8t ( \u03b4t + \u03bb\u03b3t+1 ( \u03c1t+1\u03b4 \u03bb t+1 \u2212 (1\u2212 \u03c1t+1)V\u0302 (st+1) ))] (using (7))\n= E [\u03c1t\u03c8t\u03b4t] + E [ \u03c1t\u03c8t\u03bb\u03b3t+1\u03c1t+1\u03b4 \u03bb t+1 ] \u2212 \u03c1t\u03c8t\u03bbE [ \u03b3t+1(1\u2212 \u03c1t+1)V\u0302 (st+1) ] = E [\u03c1t\u03c8t\u03b4t] + E [ \u03c1t\u03c8t\u03bb\u03b3t+1\u03c1t+1\u03b4 \u03bb t+1 ] \u2212 \u03c1t\u03c8t\u03bb\n\u2211 s\u2032 P (s\u2032|st, at)\u03b3(s\u2032)\n( 1\u2212\n\u2211 a\u2032 b(a\u2032|s\u2032)\u03c1(s\u2032, a\u2032)\n) V\u0302 (s\u2032)\n= E [\u03c1t\u03c8t\u03b4t] + E [ \u03c1t\u03c8t\u03bb\u03b3t+1\u03c1t+1\u03b4 \u03bb t+1 ] \u2212 \u03c1t\u03c8t\u03bb \u2211 s\u2032 P (s\u2032|st, at)\u03b3(s\u2032)\n( 1\u2212\n\u2211 a\u2032 b(a\u2032|s\u2032)\u03c0(a \u2032|s\u2032) b(a\u2032|s\u2032)\n) V\u0302 (s\u2032)\n= E [\u03c1t\u03c8t\u03b4t] + E [ \u03c1t\u03c8t\u03bb\u03b3t+1\u03c1t+1\u03b4 \u03bb t+1 ] = E [\u03c1t\u03c8t\u03b4t] + E [ \u03c1t\u22121\u03c8t\u22121\u03bb\u03b3t\u03c1t\u03b4 \u03bb t ] (shifting by 1, because all time steps are the same)\n= E [\u03c1t\u03c8t\u03b4t] + E [ \u03c1t\u22121\u03c8t\u22121\u03bb\u03b3t\u03c1t ( \u03b4t + \u03bb\u03b3t+1 ( \u03c1t+1\u03b4 \u03bb t+1 \u2212 (1\u2212 \u03c1t+1)V\u0302 (st+1) ))] = E [\u03c1t\u03c8t\u03b4t] + E [\u03c1t\u22121\u03c8t\u22121\u03bb\u03b3t\u03c1t\u03b4t] + E [ \u03c1t\u22121\u03c8t\u22121\u03bb\u03b3t\u03c1t\u03bb\u03b3t+1\u03c1t+1\u03b4 \u03bb t+1\n] = E [\u03c1t\u03b4t (\u03c8t + \u03bb\u03b3t\u03c1t\u22121\u03c8t\u22121)] + E [ \u03bb2\u03c1t\u22122\u03c8t\u22122\u03b3t\u22121\u03c1t\u22121\u03b3t\u03c1t\u03b4 \u03bb t\n] = E [\u03c1t\u03b4t (\u03c8t + \u03bb\u03b3t\u03c1t\u22121\u03c8t\u22121)] + E [ \u03bb2\u03c1t\u22122\u03c8t\u22122\u03b3t\u22121\u03c1t\u22121\u03b3t\u03c1t ( \u03b4t + \u03bb\u03b3t+1 ( \u03c1t+1\u03b4 \u03bb t+1 \u2212 (1\u2212 \u03c1t+1)V\u0302 (st+1)\n))] = E [\u03c1t\u03b4t (\u03c8t + \u03bb\u03b3t\u03c1t\u22121\u03c8t\u22121)] + E [ \u03bb2\u03c1t\u22122\u03c8t\u22122\u03b3t\u22121\u03c1t\u22121\u03b3t\u03c1t\u03b4t ] + E [ \u03bb2\u03c1t\u22122\u03c8t\u22122\u03b3t\u22121\u03c1t\u22121\u03b3t\u03c1t\u03bb\u03b3t+1\u03c1t+1\u03b4 \u03bb t+1\n] = E [\u03c1t\u03b4t (\u03c8t + \u03bb\u03b3t\u03c1t\u22121 (\u03c8t\u22121 + \u03bb\u03b3t\u22121\u03c1t\u22122\u03c8t\u22122))] + E [ \u03bb3\u03c1t\u22123\u03c8t\u22123\u03b3t\u22122\u03c1t\u22122\u03b3t\u22121\u03c1t\u22121\u03b3t\u03c1t\u03b4 \u03bb t\n] ...\n= E [\u03c1t\u03b4t (\u03c8t + \u03bb\u03b3t\u03c1t\u22121 (\u03c8t\u22121 + \u03bb\u03b3t\u22121\u03c1t\u22122 (\u03c8t\u22122 + \u03bb\u03b3t\u22122\u03c1t\u22123 . . .)))]\n= E [\u03b4tet]\nwhere et = \u03c1t (\u03c8t + \u03bb\u03b3tet\u22121)."}, {"heading": "A.3. Convergence Proofs", "text": "Our algorithm has the same recursive stochastic form that the two-timescale off-policy value-function algorithms have:\nut+1 = ut + \u03b1t(h(ut, zt) +Mt+1)\nzt+1 = zt + \u03b1t(f(ut, zt) +Nt+1)\nwhere x \u2208 Rd, h : Rd \u2192 Rd is a differentiable functions, {\u03b1t}k\u22650 is a positive step-size sequence and {Mt}k\u22650 is a noise sequence. Again, following the GTD(\u03bb) and GQ(\u03bb) proofs, we study the behavior of the ordinary differential equation\nu\u0307(t) = h(u(t), z)\nSince we have two updates, one for the actor and one for the critic, and those time updates are not linearly separable, we have to do a two timescale analysis (Borkar, 2008). In order to satisfy the conditions for the two-timescale analysis, we will need the following assumptions on our objective, the features and the step-sizes. Note that it is difficult to prove the boundedness of the iterates without the projection operator we describe below, though the projection was not necessary during experiments.\n(A1) The policy function, \u03c0(\u00b7)(a|s) : RNu \u2192 [0, 1], is continuously differentiable in u, \u2200s \u2208 S, a \u2208 A.\n(A2) The update on ut includes a projection operator, \u0393 : RNu \u2192 RNu that projects any u to a compact set U = {u | qi(u) \u2264 0, i = 1, . . . , s} \u2282 RNu , where qi(\u00b7) : RNu \u2192 R are continuously differentiable functions specifying the constraints of the compact region. For each u on the boundary of U , the gradients of the active qi are considered to be linearly independent. Assume that the compact region, U , is large enough to contain at least one local maximum of J\u03b3 .\n(A3) The behavior policy has a minimum positive weight for all actions in every state, in other words, b(a|s) \u2265 bmin \u2200s \u2208 S, a \u2208 A, for some bmin \u2208 (0, 1].\n(A4) The sequence (xt,xt+1, rt+1)t\u22650 is i.i.d. and has uniformly bounded second moments.\n(A5) For every u \u2208 U (the compact region to which u is projected), V \u03c0u,\u03b3 : S \u2192 R is bounded.\n(P1) ||xt||\u221e <\u221e, \u2200t, where xt \u2208 RNv\n(P2) The matrices C = E[xtxt T] and A = E[xt(xt \u2212 \u03b3xt+1)T] are non-singular and uniformly bounded. A, C\nand E[rt+1xt] are well-defined because the distribution of (xt,xt+1, rt+1) does not depend on t.\n(S1) \u03b1v,t, \u03b1w,t, \u03b1u,t > 0, \u2200t are deterministic such that \u2211 t \u03b1v,t = \u2211 t \u03b1w,t = \u2211 t \u03b1u,t = \u221e and \u2211 t \u03b1 2 v,t < \u221e,\u2211\nt \u03b1 2 w,t <\u221e and \u2211 t \u03b1 2 u,t <\u221e with \u03b1u,t \u03b1v,t \u2192 0.\n(S2) Define H(A) . = (A + AT)/2 and let \u03c7min(C \u22121H(A)) be the minimum eigenvalue of the matrix C\u22121H(A). Then \u03b1w,t = \u03b7\u03b1v,t for some \u03b7 > max 0,\u2212\u03c7min(C\u22121H(A)).\nTheorem 3 (Convergence of Off-PAC) Let \u03bb = 0 and consider the Off-PAC iterations for the critic (GTD(\u03bb), i.e., TDC with importance sampling correction) and the actor (for weights ut). Assume that (A1)-(A5), (P1)(P2) and (S1)-(S2) hold. Then the policy weights, ut, converge to Z\u0302 = {u \u2208 U | g\u0302(u) = 0} and the value function weights, vt, converge to the corresponding TD-solution with probability one.\nProof. We follow a similar outline to that of the two timescale analysis proof for TDC (Sutton et al., 2009). We will analyze the dynamics for our two weights, ut, and zt T = (wt Tvt\nT), based on our update rules. We will take ut as the slow timescale update and zt as the fast inner update.\nFirst, we need to rewrite our updates for v, w and u, amenable to a two timescale analysis:\nvt+1 = vt + \u03b1v,t\u03c1t[\u03b4txt \u2212 \u03b3xtTwxt] wt+1 = wt + \u03b1v,t\u03b7[\u03c1t\u03b4txt \u2212 xtTwxt] zt+1 = zt + \u03b1v,t\u03c1t[Gut,t+1zt + qut,t+1] (8)\nut+1 = \u0393 ( ut + \u03b1u,t\u03b4t\n\u2207ut\u03c0t(at|st) b(at|st)\n) (9)\nwhere \u03c1t = \u03c1(st, at), \u03b4t = rt+1 + \u03b3(st+1)V\u0302 (st+1)\u2212 V\u0302 (st), \u03b7 = \u03b1w,t/\u03b1v,t, qut,t+1T = (\u03b7\u03c1trt+1xtT, \u03c1trt+1xtT), and\nGut,t+1 =\n( \u2212\u03b7xtxtT \u03b7\u03c1t(ut)xt(\u03b3xt+1 \u2212 xt)T\n\u2212\u03b3\u03c1t(ut)xt+1xtT \u03c1t(ut)xt(\u03b3xt+1 \u2212 xt)T\n) .\nNote that Gu = E[Gu,t|u] and qu = E[qu,t|u] are well defined because we assumed that the process (xt,xt+1, rt+1)t\u22650 is i.i.d., 0 < \u03c1t \u2264 b\u22121min, and we have fixed ut. Now we can define h and f :\nh(zt,ut) = Gutzt + qut\nf(zt,ut) = E [ \u03b4t \u2207ut\u03c0t(at|st) b(at|st) |zt,ut ]\nMt+1 = (Gut,t+1 \u2212Gut) zt + qut,t+1 \u2212 qut Nt+1 = \u03b4t \u2207ut\u03c0t(at|st) b(at|st) \u2212 f(zt,ut)\nWe have to satisfy the following conditions from Borkar (2008, p. p64):\n(B1) h : RNu+2Nv \u2192 R2Nv and f : RNu+2Nv \u2192 RNu are Lipschitz.\n(B2) \u03b1v,t, \u03b1u,t \u2200t are deterministic and \u2211 t \u03b1v,t = \u2211 t \u03b1u,t =\u221e, \u2211 t \u03b1 2 v,t <\u221e, \u2211 t \u03b1 2 u,t <\u221e, \u03b1u,t \u03b1v,t \u2192 0 (i.e., the\nsystem in Equation 9 moves on a slower timescale than Equation 8).\n(B3) The sequences {Mt}k\u22650 and {Nt}k\u22650 are Martingale difference sequences w.r.t. the increasing \u03c3-fields, Ft . = \u03c3(zm,um,Mm, Nm, m \u2264 n) (i.e., E[Mt+1|Ft] = 0)\n(B4) For some constant K > 0, E[||Mt+1||2|Ft] \u2264 K(1+||xt||2+||yt||2) and E[||Nt+1||2|Ft] \u2264 K(1+||xt||2+||yt||2) holds for any k \u2265 0.\n(B5) The ODE z\u0307(t) = h(z(t),u) has a globally asymptotically stable equilibrium \u03c7(u) where \u03c7 : RNu \u2192 RNv is a Lipschitz map.\n(B6) The ODE u\u0307(t) = f(\u03c7(u(t)),u(t)) has a globally asymptotically stable equilibrium, u\u2217.\n(B7) supt(||zt||+ ||ut||) <\u221e, a.s.\nAn asymptotically stable equilibrium for a dynamical system is an attracting point for which small perturbations still cause convergence back to that point. If we can verify these conditions, then we can use Theorem 2 by Borkar (2008) that states that (zt,ut)\u2192 (\u03c7(u\u2217),u\u2217) a.s. Note that the previous actor-critic proofs transformed the update to the negative update, assuming they were minimizing costs, \u2212R, rather than maximizing and so converging to a (local) minimum. This is unnecessary because we simply need to prove we have a stable equilibrium, whether a maximum or minimum; therefore, we keep the update as in the algorithm and assume a (local) maximum.\nFirst note that because we have a bounded function, \u03c0(:)(s, a) : U \u2192 (0, 1], we can more simply satisfy some of the properties from Borkar (2008). Mainly, we know our policy function is Lipschitz (because it is bounded and continuously differentiable), so we know the gradient is bounded, in other words, there exists B\u2207u \u2208 R such that ||\u2207u\u03c0(a|s)|| \u2264 B\u2207u.\nFor requirement (B1), h is clearly Lipschitz because it is linear in z and \u03c1t(u) is continuously differentiable and bounded (\u03c1t(u) \u2264 b\u22121min). f is Lipschitz because it is linear in v and \u2207u\u03c0(a|s) is bounded and continuously differentiable (making J\u03b3 with a fixed Q\u0302 \u03c0,\u03b3 continuously differentiable with a bounded derivative).\nRequirement (B2) is satisfied by our assumptions.\nRequirement (B3) is satisfied by the construction of Mt and Nt.\nFor requirement (B4), we can first notice that Mt satisfies the requirement because rt+1,xt and xt+1 have uniformly bounded second moments (which is the justification used in the TDC proof (Sutton et al., 2009) and because 0 < \u03c1t \u2264 b\u22121min.\nE[||Mt+1||2|Ft] = E[|| (Gut,t \u2212Gut) zt + (qut,t \u2212 qut)||2|Ft] \u2264 E[|| (Gut,t \u2212Gut) zt||2 + ||(qut,t \u2212 qut)||2|Ft] \u2264 E[||c1zt||2 + c2|Ft] \u2264 K(||zt||2 + 1) \u2264 K(||zt||2 + ||ut||2 + 1)\nwhere the second inequality is by the Cauchy Schwartz inequality, (Gut,t\u2212Gut)zt \u2264 c1|zt| and ||qut,t\u2212qut ||2 \u2264 c2 (because rt+1,xt and xt+1 have uniformly bounded second moments), with c1, c2 \u2208 R+. When then simply set K = max(c1, c2).\nFor Nt, since the iterates are bounded as we show below for requirement (B7) (giving supt ||ut|| < Bu and supt ||zt|| < Bz for some Bu, Bz \u2208 R. ), we see that\nE[||Nt+1||2|Ft]\n\u2264 E [\u2223\u2223\u2223\u2223\u2223\u2223\u2223\u2223\u03b4t\u2207ut\u03c0t(at|st)b(at|st) \u2223\u2223\u2223\u2223\u2223\u2223\u2223\u22232 + \u2223\u2223\u2223\u2223\u2223\u2223\u2223\u2223E [\u03b4t\u2207ut\u03c0t(at|st)b(at|st) |zt,ut ]\u2223\u2223\u2223\u2223\u2223\u2223\u2223\u22232 |Ft ]\n\u2264 E [\u2223\u2223\u2223\u2223\u2223\u2223\u2223\u2223\u03b4t\u2207ut\u03c0t(at|st)b(at|st) \u2223\u2223\u2223\u2223\u2223\u2223\u2223\u22232 + E [\u2223\u2223\u2223\u2223\u2223\u2223\u2223\u2223\u03b4t\u2207ut\u03c0t(at|st)b(at|st) \u2223\u2223\u2223\u2223\u2223\u2223\u2223\u22232 |zt,ut ] |Ft ]\n\u2264 2E [\u2223\u2223\u2223\u2223 \u03b4tb(at|st) \u2223\u2223\u2223\u22232 ||\u2207ut\u03c0t(at|st)||2|Ft ]\n\u2264 2 b2min\nE [ |\u03b4t|2B2\u2207u|Ft ] \u2264 K(||vt||2 + 1) \u2264 K(||zt||2 + ||ut||2 + 1)\nfor some K \u2208 R because E[|\u03b4|2|Ft] \u2264 c1(1 + ||vt||) for some c1 \u2208 R because rt+1,xt and xt+1 have uniformly bounded second moments and since ||\u2207u\u03c0(a|s)|| \u2264 B\u2207u \u2200 s \u2208 S, a \u2208 A (as stated above because \u03c0(a|s) is Lipschitz continuous).\nFor requirement (B5), we know that every policy, \u03c0, has a corresponding bounded V \u03c0,\u03b3 (by assumption). We need to show that for each u, there is a globally asymptotically stable equilibrium of the system, h(z(t),u) (which has yet to be shown for weighted importance sampling TDC, i.e., GTD(\u03bb = 0)). To do so, we use the Hartman-Grobman Theorem, that requires us to show that G has all negative eigenvalues. For readability, we show this in a separate lemma (Lemma 4 below). Using Lemma 4, we know that there exists a function \u03c7 : RNu \u2192 RNv such that \u03c7(u) = (vuT wuT) T\n, where vu is the unique TD-solution value-function weights for policy \u03c0 and wu is the corresponding expectation estimate. This function, \u03c7, is continuously differentiable with bounded gradient (by Lemma 5 below) and is therefore a Lipschitz map.\nFor requirement (B6), we need to prove that our update f(\u03c7(\u00b7), \u00b7) has an asymptotically stable equilibrium. This requirement can be relaxed to a local rather than global asymptotically stable equilibrium, because we simply need convergence. Our objective function, J\u03b3 , is not concave because our policy function, \u03c0(a|s) may not be concave in u. Instead, we need to prove that all (local) equilibria are asymptotically stable.\nWe define a vector field operator, \u0393\u0302 : C(RNu)\u2192 C(RNu) that projects any gradients leading outside the compact\nregion, U , back into U :\n\u0393\u0302(g(y)) = lim h\u21920 \u0393(y + hg(y))\u2212 y h\nBy our forward-backward view analysis and from the same arguments following from Lemma 3 by Bhatnagar et al. (2009), we know that the ODE u\u0307(t) = f(\u03c7(u(t)),u(t)) is g(u). Given that we have satisfied requirements 1-5 and given our step-size conditions, using standard arguments (c.f. Lemma 6 in Bhatnagar et al., 2009), we can deduce that ut converges almost surely to the set of asymptotically stable fixed points, Z\u0303, of u\u0307 = \u0393\u0302g(u).\nFor requirement (B7), we know that ut is bounded because it is always projected to U . Since u stays in U , we know that v stays bounded (by assumption, otherwise V \u03c0,\u03b3 would not be bounded) and correspondingly w(v) must stay bounded, by the same argument as by Sutton et al. (2009). Therefore, we have that supt ||ut|| < Bu and that supt ||zt|| < B\u03c1 for some Bu, Bz \u2208 R.\nLemma 4. Under assumptions (A1)-(A5), (P1)-(P2) and (S1)-(S2), for any fixed set of actor weights, u \u2208 U , the GTD(\u03bb = 0) update for the critic weights, vt, converge to the TD solution with probability one.\nProof. Recall that\nGu,t+1 =\n( \u2212\u03b7xtxtT \u03b7\u03c1t(u)xt(\u03b3xt+1 \u2212 xt)T\n\u2212\u03b3\u03c1t(u)xt+1xtT \u03c1t(u)xt(\u03b3xt+1 \u2212 xt)T\n) .\nand Gu = E [Gu,t], meaning\nGu = ( \u2212\u03b7C \u2212\u03b7A\u03c1(u) \u2212F\u03c1(u)T \u2212A\u03c1(u) ) .\nwhere F\u03c1(u) = \u03b3E [ \u03c1t(u)xt+1xt T ] , with C\u03c1(u) = A\u03c1(u)\u2212 F\u03c1(u). For the remainder of the proof, we will simply write A\u03c1 and C\u03c1, because it is clear that we have a fixed u \u2208 U .\nBecause GTD(\u03bb) is solely for value function approximation, the feature vector, x, is only dependent on the state: E [ \u03c1txtxt T ] = \u2211 st,at d(st)b(at|st)\u03c1tx(st)xtT\n= \u2211 st,at d(st)\u03c0(at|st)x(st)xtT\n= \u2211 st d(st)x(st)xt T (\u2211 at \u03c0(at|st) ) = \u2211 st d(st)x(st)xt T = E[xtxt T]\nbecause \u2211 at \u03c0(at|st) = 1. A similar argument shows that E [ \u03c1txt+1xt T ] = E [ xt+1xt T ] . Therefore, we get that F\u03c1(u) = \u03b3E[xxt T] and A\u03c1(u) = E[xt(\u03b3xt+1 \u2212 xt)T]. The expected value of the update, G, therefore, is that same as for TDC, which has been shown to converge under our assumptions (see Maei, 2011).\nLemma 5. Under assumptions (A1)-(A5), (P1)-(P2) and (S1)-(S2), let \u03c7 : U \u2192 V be the map from policy weights to corresponding value function, V \u03c0,\u03b3 , obtained from using GTD(\u03bb = 0) (proven to exist by Lemma 4). Then \u03c7 is continuously differentiable with a bounded gradient for all u \u2208 U .\nProof. To show that \u03c7 is continuous, we use the Weierstrass definition (\u03b4 \u2212 definition). Because \u03c7(u) = \u2212G(u)\u22121q(u) = zu, which is a complicated function of u, we can luckily break it up and prove continuity about parts of it. Recall that 1) the inverse of a continuous function is continuous at every point that represents a non-singular matrix and 2) the multiplication of two continuous functions is continuous. Since G(u) is always nonsingular, we simply need to proof that a(u) \u2192 G(u) and b(u) \u2192 q(u) are continuous. G(u) is composed of\nseveral block matrices, including C, F\u03c1(u) and A\u03c1(u). We will start by showing that u \u2192 F\u03c1(u) is continuous, where F\u03c1(u) = \u2212E [ \u03b7\u03c1t(u)xt+1xt T \u2223\u2223b]. The remaining entries are similar.\nTake any s \u2208 S, a \u2208 A, and u \u2208 U . We know that \u03c0(a|s) : U \u2192 [0, 1] is continuous for all u \u2208 U (by assumption). Let 1 =\n\u03b3|A|E[xt+1xtT|b] (well-defined because E\n[ xt+1xt T \u2223\u2223b] is nonsingular). Then we know there exists a \u03b4 > 0\nsuch that for any u2 \u2208 U with ||u1 \u2212 u2|| < \u03b4, then ||\u03c0u1(at|st)\u2212 \u03c0u2(at|st)|| < 1. Now ||F\u03c1(u1)\u2212 F\u03c1(u2)|| = \u03b3||E [ \u03c1t(u1)xt+1xt T ] \u2212 E [ \u03c1t(u2)xt+1xt T ] ||\n= \u03b3 \u2223\u2223\u2223\u2223\u2223 \u2223\u2223\u2223\u2223\u2223\u2211 st,at db(st)b(at|st) \u03c0u1(at|st) b(at|st) xt+1xt T \u2212 \u2211 st,at db(st)b(at|st) \u03c0u2(at|st) b(at|st) xt+1xt T \u2223\u2223\u2223\u2223\u2223 \u2223\u2223\u2223\u2223\u2223\n= \u03b3 \u2223\u2223\u2223\u2223\u2223 \u2223\u2223\u2223\u2223\u2223\u2211 st,at db(st)[\u03c0u1(at|st)\u2212 \u03c0u2(at|st)]xt+1xtT \u2223\u2223\u2223\u2223\u2223 \u2223\u2223\u2223\u2223\u2223\n< \u03b3 \u2211 st,at db(st)||\u03c0u1(at|st)\u2212 \u03c0u2(at|st)||xt+1xtT\n< \u03b3 1 \u2211 st,at db(st)xt+1xt T\n= \u03b3 1|A|E [ xt+1xt T \u2223\u2223b] =\nTherefore, u\u2192 F\u03c1(u) is continuous. This same process can be done for A\u03c1(u) and E [\u03c1t(u)rtxt|b] in q(u).\nSince u\u2192 G and u\u2192 q are continuous for all u, we know that \u03c7(u) = \u2212G(u)\u22121q(u) is continuous.\nThe above can also be accomplished to show that \u2207u\u03c7 is continuous, simply by replacing \u03c0 with \u2207u\u03c0 above. Finally, because our policy function is Lipschitz (because it is bounded and continuously differentiable), we know that is has a bounded gradient. As a result, the gradient of \u03c7 is bounded (since we have nonsingular and bounded expectation matrices), which would again follow from a similar analysis as above."}], "references": [{"title": "Residual algorithms: Reinforcement learning with function approximation", "author": ["L. Baird"], "venue": "Proceedings of the Twelfth International Conference on Machine Learning, pp. 30\u201337. Morgan Kaufmann.", "citeRegEx": "Baird,? 1995", "shortCiteRegEx": "Baird", "year": 1995}, {"title": "Natural actor-critic algorithms", "author": ["S. Bhatnagar", "R.S. Sutton", "M. Ghavamzadeh", "M. Lee"], "venue": "Automatica 45 (11):2471\u20132482.", "citeRegEx": "Bhatnagar et al\\.,? 2009", "shortCiteRegEx": "Bhatnagar et al\\.", "year": 2009}, {"title": "Stochastic approximation: A dynamical systems viewpoint", "author": ["V.S. Borkar"], "venue": "Cambridge Univ Press.", "citeRegEx": "Borkar,? 2008", "shortCiteRegEx": "Borkar", "year": 2008}, {"title": "Linear least-squares algorithms for temporal difference learning", "author": ["S.J. Bradtke", "A.G. Barto"], "venue": "Machine Learning 22 :33\u201357.", "citeRegEx": "Bradtke and Barto,? 1996", "shortCiteRegEx": "Bradtke and Barto", "year": 1996}, {"title": "Experiments in off-policy reinforcement learning with the GQ(\u03bb) algorithm", "author": ["M. Delp"], "venue": "Masters thesis,", "citeRegEx": "Delp,? 2010", "shortCiteRegEx": "Delp", "year": 2010}, {"title": "Reinforcement learning in continuous time and space", "author": ["K. Doya"], "venue": "Neural computation 12 :219\u2013245.", "citeRegEx": "Doya,? 2000", "shortCiteRegEx": "Doya", "year": 2000}, {"title": "Least squares policy iteration", "author": ["M. Lagoudakis", "R. Parr"], "venue": "Journal of Machine Learning Research 4 :1107\u2013 1149.", "citeRegEx": "Lagoudakis and Parr,? 2003", "shortCiteRegEx": "Lagoudakis and Parr", "year": 2003}, {"title": "GQ(\u03bb): A general gradient algorithm for temporal-difference prediction learning with eligibility traces", "author": ["H.R. Maei", "R.S. Sutton"], "venue": "Proceedings of the Third Conf. on Artificial General Intelligence.", "citeRegEx": "Maei and Sutton,? 2010", "shortCiteRegEx": "Maei and Sutton", "year": 2010}, {"title": "Gradient Temporal-Difference Learning Algorithms", "author": ["H.R. Maei"], "venue": "PhD thesis, University of Alberta.", "citeRegEx": "Maei,? 2011", "shortCiteRegEx": "Maei", "year": 2011}, {"title": "Convergent temporaldifference learning with arbitrary smooth function approximation", "author": ["H.R. Maei", "C. Szepesv\u00e1ri", "S. Bhatnagar", "D. Precup", "D. Silver", "R.S. Sutton"], "venue": "Advances in Neural Information Processing Systems 22 :1204\u20131212.", "citeRegEx": "Maei et al\\.,? 2009", "shortCiteRegEx": "Maei et al\\.", "year": 2009}, {"title": "Toward off-policy learning control with function approximation", "author": ["H.R. Maei", "C. Szepesv\u00e1ri", "S. Bhatnagar", "R.S. Sutton"], "venue": "Proceedings of the 27th International Conference on Machine Learning.", "citeRegEx": "Maei et al\\.,? 2010", "shortCiteRegEx": "Maei et al\\.", "year": 2010}, {"title": "Simulation-based optimization of Markov reward processes", "author": ["P. Marbach", "J.N. Tsitsiklis"], "venue": "Technical report LIDS-P-2411.", "citeRegEx": "Marbach and Tsitsiklis,? 1998", "shortCiteRegEx": "Marbach and Tsitsiklis", "year": 1998}, {"title": "Nonconvergence to unstable points in urn models and stochastic approximations", "author": ["R. Pemantle"], "venue": "The Annals of Probability 18 (2):698\u2013712.", "citeRegEx": "Pemantle,? 1990", "shortCiteRegEx": "Pemantle", "year": 1990}, {"title": "Natural actor-critic", "author": ["J. Peters", "S. Schaal"], "venue": "Neurocomputing 71 (7):1180\u20131190.", "citeRegEx": "Peters and Schaal,? 2008", "shortCiteRegEx": "Peters and Schaal", "year": 2008}, {"title": "Off-policy learning with recognizers", "author": ["D. Precup", "R.S. Sutton", "C. Paduraru", "A. Koop", "S. Singh"], "venue": "Neural Information Processing Systems 18.", "citeRegEx": "Precup et al\\.,? 2006", "shortCiteRegEx": "Precup et al\\.", "year": 2006}, {"title": "Effective reinforcement learning for mobile robots", "author": ["W.D. Smart", "L. Pack Kaelbling"], "venue": "Proceedings of International Conference on Robotics and Automation, volume 4, pp. 3404\u20133410.", "citeRegEx": "Smart and Kaelbling,? 2002", "shortCiteRegEx": "Smart and Kaelbling", "year": 2002}, {"title": "Reinforcement Learning: An Introduction", "author": ["R.S. Sutton", "A.G. Barto"], "venue": "MIT Press.", "citeRegEx": "Sutton and Barto,? 1998", "shortCiteRegEx": "Sutton and Barto", "year": 1998}, {"title": "Policy gradient methods for reinforcement learning with function approximation", "author": ["R.S. Sutton", "D. McAllester", "S. Singh", "Y. Mansour"], "venue": "Advances in Neural Information Processing Systems 12.", "citeRegEx": "Sutton et al\\.,? 2000", "shortCiteRegEx": "Sutton et al\\.", "year": 2000}, {"title": "A convergent O(n) algorithm for off-policy temporaldifference learning with linear function approximation", "author": ["R.S. Sutton", "Szepesv\u00e1ri", "Cs.", "H.R. Maei"], "venue": "Advances in Neural Information Processing Systems 21, pp. 1609\u20131616.", "citeRegEx": "Sutton et al\\.,? 2008", "shortCiteRegEx": "Sutton et al\\.", "year": 2008}, {"title": "Fast gradient-descent methods for temporal-difference learning with linear function approximation", "author": ["R.S. Sutton", "H.R. Maei", "D. Precup", "S. Bhatnagar", "D. Silver", "Szepesv\u00e1ri", "Cs.", "E. Wiewiora"], "venue": "Proceedings of the 26th Annual International Conference on Machine", "citeRegEx": "Sutton et al\\.,? 2009", "shortCiteRegEx": "Sutton et al\\.", "year": 2009}, {"title": "Horde: A scalable realtime architecture for learning knowledge from unsupervised sensorimotor interaction", "author": ["R.S. Sutton", "J. Modayil", "M. Delp", "T. Degris", "P.M. Pilarski", "D. Precup"], "venue": "Proceedings of the 10th International Conference on Autonomous Agents", "citeRegEx": "Sutton et al\\.,? 2011", "shortCiteRegEx": "Sutton et al\\.", "year": 2011}, {"title": "Q-learning", "author": ["Watkins", "C.J.C.H.", "P. Dayan"], "venue": "Machine Learning 8 (3):279\u2013292.", "citeRegEx": "Watkins et al\\.,? 1992", "shortCiteRegEx": "Watkins et al\\.", "year": 1992}, {"title": "An asymptotically stable equilibrium for a dynamical system is an attracting point for which small perturbations still cause convergence back to that point", "author": ["supt(||zt||+ ||ut", "a.s"], "venue": null, "citeRegEx": "<\u221e and a.s.,? \\Q2008\\E", "shortCiteRegEx": "<\u221e and a.s.", "year": 2008}, {"title": "2009), we can deduce that ut converges almost surely to the set of asymptotically stable fixed points, Z\u0303, of u\u0307 = \u0393\u0302g(u). For requirement (B7), we know that ut is bounded because it is always projected to U . Since u stays in U , we know that v stays bounded (by assumption, otherwise V \u03c0,\u03b3 would not be bounded) and correspondingly w(v) must stay", "author": ["Bhatnagar"], "venue": null, "citeRegEx": "Bhatnagar,? \\Q2009\\E", "shortCiteRegEx": "Bhatnagar", "year": 2009}], "referenceMentions": [{"referenceID": 20, "context": "Unlike onpolicy methods, off-policy methods are able to, for example, learn about an optimal policy while executing an exploratory policy (Sutton & Barto, 1998), learn from demonstration (Smart & Kaelbling, 2002), and learn multiple tasks in parallel from a single sensorimotor interaction with an environment (Sutton et al., 2011).", "startOffset": 310, "endOffset": 331}, {"referenceID": 0, "context": "However, while Q-Learning is guaranteed to converge to the optimal policy for the tabular (non-approximate) case, it may diverge when using linear function approximation (Baird, 1995).", "startOffset": 170, "endOffset": 183}, {"referenceID": 10, "context": ", 2009), such as Greedy-GQ (Maei et al., 2010), which are of linear complexity and convergent under off-policy training with function approximation.", "startOffset": 27, "endOffset": 46}, {"referenceID": 17, "context": "The standard way of avoiding the limitations of actionvalue methods is to use policy-gradient algorithms (Sutton et al., 2000) such as actor-critic methods (e.", "startOffset": 105, "endOffset": 126}, {"referenceID": 8, "context": "For the critic, in this paper we consider a version of Off-PAC that uses GTD(\u03bb) (Maei, 2011), a gradient-TD method with eligibitity traces for learning state-value functions.", "startOffset": 80, "endOffset": 92}, {"referenceID": 4, "context": "To the best of our knowledge, this paper is the first to provide an empirical evaluation of gradient-TD methods for off-policy control (the closest known prior work is the work of Delp (2011)).", "startOffset": 180, "endOffset": 192}, {"referenceID": 20, "context": "Given a termination condition \u03b3 : S \u2192 [0, 1] (Sutton et al., 2011), we define the value function for \u03c0 : S\u00d7A \u2192 (0, 1] to be:", "startOffset": 45, "endOffset": 66}, {"referenceID": 19, "context": "Gradient-TD methods (Sutton et al., 2009) incrementally learn the weights, v, in an off-policy setting, with a guarantee of stability and a linear per-time-step complexity.", "startOffset": 20, "endOffset": 41}, {"referenceID": 8, "context": "In this paper, we consider the version of Off-PAC that updates its critic weights by the GTD(\u03bb) algorithm introduced by Maei (2011).", "startOffset": 120, "endOffset": 132}, {"referenceID": 17, "context": "In the conventional on-policy theory of policy-gradient methods, the policy-gradient theorem (Marbach & Tsitsiklis, 1998; Sutton et al., 2000) establishes the relationship between the gradient of the objective function and the expected action values.", "startOffset": 93, "endOffset": 142}, {"referenceID": 8, "context": "Following previous offpolicy gradient proofs (Maei, 2011), we study the behavior of the ordinary differential equation u\u0307(t) = u(h(u(t),v))", "startOffset": 45, "endOffset": 57}, {"referenceID": 2, "context": "The two updates (for the actor and for the critic) are not independent on each time step; we analyze two separate ODEs using a two timescale analysis (Borkar, 2008).", "startOffset": 150, "endOffset": 164}, {"referenceID": 12, "context": "Previous work, however, has illustrated that the stochasticity in practice makes convergence to an unstable equilibrium unlikely (Pemantle, 1990); therefore, we avoid restrictions on the policy function and do not include the projection in our algorithm", "startOffset": 129, "endOffset": 145}, {"referenceID": 2, "context": "For Markov noise, our proof as well as the proofs for GTD(\u03bb) and GQ(\u03bb), require Borkar\u2019s (2008) two-timescale theory to be extended to Markov noise (which is outside the scope of this paper).", "startOffset": 80, "endOffset": 96}, {"referenceID": 8, "context": "Proof Sketch: We follow a similar outline to the two timescale analysis for on-policy policy gradient Minimum exists as all eigenvalues real-valued (Lemma 4) GTD(0) is GTD(\u03bb) with \u03bb = 0, not the different algorithm called GTD(0) by Sutton, Szepesvari & Maei (2008)", "startOffset": 253, "endOffset": 265}, {"referenceID": 1, "context": "actor-critic (Bhatnagar et al., 2009) and for nonlinear GTD (Maei et al.", "startOffset": 13, "endOffset": 37}, {"referenceID": 9, "context": ", 2009) and for nonlinear GTD (Maei et al., 2009).", "startOffset": 30, "endOffset": 49}, {"referenceID": 0, "context": "Note that Q(\u03bb) may not be stable in this setting (Baird, 1995), unlike all the other algorithms.", "startOffset": 49, "endOffset": 62}, {"referenceID": 5, "context": "The second problem is a pendulum problem (Doya, 2000).", "startOffset": 41, "endOffset": 53}, {"referenceID": 1, "context": "actor-critic methods (Bhatnagar et al., 2009), which use the natural gradient as opposed to the conventional gradient.", "startOffset": 21, "endOffset": 45}, {"referenceID": 14, "context": "Finally, as pointed out by Precup et al. (2006), offpolicy updates can be more noisy compared to onpolicy learning.", "startOffset": 27, "endOffset": 48}], "year": 2017, "abstractText": "This paper presents the first actor-critic algorithm for off-policy reinforcement learning. Our algorithm is online and incremental, and its per-time-step complexity scales linearly with the number of learned weights. Previous work on actor-critic algorithms is limited to the on-policy setting and does not take advantage of the recent advances in offpolicy gradient temporal-difference learning. Off-policy techniques, such as Greedy-GQ, enable a target policy to be learned while following and obtaining data from another (behavior) policy. For many problems, however, actor-critic methods are more practical than action value methods (like Greedy-GQ) because they explicitly represent the policy; consequently, the policy can be stochastic and utilize a large action space. In this paper, we illustrate how to practically combine the generality and learning potential of offpolicy learning with the flexibility in action selection given by actor-critic methods. We derive an incremental, linear time and space complexity algorithm that includes eligibility traces, prove convergence under assumptions similar to previous off-policy algorithms, and empirically show better or comparable performance to existing algorithms on standard reinforcement-learning benchmark problems. The reinforcement learning framework is a general temporal learning formalism that has, over the last few decades, seen a marked growth in algorithms and applications. Until recently, however, practical online Appearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s). methods with convergence guarantees have been restricted to the on-policy setting, in which the agent learns only about the policy it is executing. In an off-policy setting, on the other hand, an agent learns about a policy or policies different from the one it is executing. Off-policy methods have a wider range of applications and learning possibilities. Unlike onpolicy methods, off-policy methods are able to, for example, learn about an optimal policy while executing an exploratory policy (Sutton & Barto, 1998), learn from demonstration (Smart & Kaelbling, 2002), and learn multiple tasks in parallel from a single sensorimotor interaction with an environment (Sutton et al., 2011). Because of this generality, off-policy methods are of great interest in many application domains. The most well known off-policy method is Q-learning (Watkins & Dayan, 1992). However, while Q-Learning is guaranteed to converge to the optimal policy for the tabular (non-approximate) case, it may diverge when using linear function approximation (Baird, 1995). Least-squares methods such as LSTD (Bradtke & Barto, 1996) and LSPI (Lagoudakis & Parr, 2003) can be used off-policy and are sound with linear function approximation, but are computationally expensive; their complexity scales quadratically with the number of features and weights. Recently, these problems have been addressed by the new family of gradientTD (Temporal Difference) methods (e.g., Sutton et al., 2009), such as Greedy-GQ (Maei et al., 2010), which are of linear complexity and convergent under off-policy training with function approximation. All action-value methods, including gradient-TD methods such as Greedy-GQ, suffer from three important limitations. First, their target policies are deterministic, whereas many problems have stochastic optimal policies, such as in adversarial settings or in partially observable Markov decision processes. Second, finding the greedy action with respect to the actionar X iv :1 20 5. 48 39 v1 [ cs .L G ] 2 2 M ay 2 01 2 Off-Policy Actor-Critic value function becomes problematic for larger action spaces. Finally, a small change in the action-value function can cause large changes in the policy, which creates difficulties for convergence proofs and for some real-time applications. The standard way of avoiding the limitations of actionvalue methods is to use policy-gradient algorithms (Sutton et al., 2000) such as actor-critic methods (e.g., Bhatnagar et al., 2009). For example, the natural actor-critic, an on-policy policy-gradient algorithm, has been successful for learning in continuous action spaces in several robotics applications (Peters & Schaal, 2008). The first and main contribution of this paper is to introduce the first actor-critic method that can be applied off-policy, which we call Off-PAC, for Off-Policy Actor\u2013Critic. Off-PAC has two learners: the actor and the critic. The actor updates the policy weights. The critic learns an off-policy estimate of the value function for the current actor policy, different from the (fixed) behavior policy. This estimate is then used by the actor to update the policy. For the critic, in this paper we consider a version of Off-PAC that uses GTD(\u03bb) (Maei, 2011), a gradient-TD method with eligibitity traces for learning state-value functions. We define a new objective for our policy weights and derive a valid backward-view update using eligibility traces. The time and space complexity of Off-PAC is linear in the number of learned weights. The second contribution of this paper is an off-policy policy-gradient theorem and a convergence proof for Off-PAC when \u03bb = 0, under assumptions similar to previous off-policy gradient-TD proofs. Our third contribution is an empirical comparison of Q(\u03bb), Greedy-GQ, Off-PAC, and a soft-max version of Greedy-GQ that we call Softmax-GQ, on three benchmark problems in an off-policy setting. To the best of our knowledge, this paper is the first to provide an empirical evaluation of gradient-TD methods for off-policy control (the closest known prior work is the work of Delp (2011)). We show that Off-PAC outperforms other algorithms on these problems. 1. Notation and Problem Setting In this paper, we consider Markov decision processes with a discrete state space S, a discrete action spaceA, a distribution P : S \u00d7 S \u00d7A \u2192 [0, 1], where P (s\u2032|s, a) is the probability of transitioning into state s\u2032 from state s after taking action a, and an expected reward function R : S\u00d7A\u00d7S \u2192 R that provides an expected reward for taking action a in state s and transitioning into s\u2032. We observe a stream of data, which includes states st \u2208 S, actions at \u2208 A, and rewards rt \u2208 R for t = 1, 2, . . . with actions selected from a fixed behavior policy, b(a|s) \u2208 (0, 1]. Given a termination condition \u03b3 : S \u2192 [0, 1] (Sutton et al., 2011), we define the value function for \u03c0 : S\u00d7A \u2192 (0, 1] to be: V (s) = E [rt+1 + . . .+ rt+T |st = s] \u2200s \u2208 S (1) where policy \u03c0 is followed from time step t and terminates at time t + T according to \u03b3. We assume termination always occurs in a finite number of steps. The action-value function, Q(s, a), is defined as: Q(s, a) = \u2211 s\u2032\u2208S P (s\u2032|s, a)[R(s, a, s\u2032) + \u03b3(s\u2032)V \u03c0,\u03b3(s\u2032)] (2) for all a \u2208 A and for all s \u2208 S. Note that V (s) = \u2211 a\u2208A \u03c0(a|s)Q(s, a), for all s \u2208 S. The policy \u03c0u : A\u00d7S \u2192 [0, 1] is an arbitrary, differentiable function of a weight vector, u \u2208 Ru , Nu \u2208 N, with \u03c0u(a|s) > 0 for all s \u2208 S, a \u2208 A. Our aim is to choose u so as to maximize the following scalar objective function:", "creator": "LaTeX with hyperref package"}}}