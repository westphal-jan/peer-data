{"id": "1206.1270", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jun-2012", "title": "Factoring nonnegative matrices with linear programs", "abstract": "this paper describes a new approach for computing nonnegative matrix factorizations ( nmfs ) with linear programming. the key idea is a data - driven sampling model for the factorization, in which the most salient features in the data are used to express the corresponding remaining features. more precisely, given a data matrix x, the algorithm identifies a matrix c that satisfies x is approximately equal to cx and some linear constraints. the matrix c selects features, which are then used to compute a low - rank nmf of priority x. a theoretical analysis demonstrates that this approach has created the same type of guarantees as the recent nmf algorithm of arora et al. ( 2012 ). in contrast with dismissing this equally earlier work, the proposed method ( 1 ) has better noise tolerance, ( 2 ) extends to more general noise models, and ( 3 ) leads to efficient, scalable algorithms. experiments with synthetic and real datasets provide evidence that the new technique approach is unfortunately also frequently superior in practice. an optimized c + + implementation of the new algorithm can factor even a multi - gigabyte matrix in a matter of minutes.", "histories": [["v1", "Wed, 6 Jun 2012 16:42:27 GMT  (66kb,D)", "https://arxiv.org/abs/1206.1270v1", "16 pages, 10 figures"], ["v2", "Sat, 2 Feb 2013 23:40:56 GMT  (67kb,D)", "http://arxiv.org/abs/1206.1270v2", "17 pages, 10 figures. Modified theorem statement for robust recovery conditions. Revised proof techniques to make arguments more elementary. Results on robustness when rows are duplicated have been superseded by arxiv.org/1211.6687"]], "COMMENTS": "16 pages, 10 figures", "reviews": [], "SUBJECTS": "math.OC cs.LG stat.ML", "authors": ["ben recht", "christopher r\u00e9", "joel a tropp", "victor bittorf"], "accepted": true, "id": "1206.1270"}, "pdf": {"name": "1206.1270.pdf", "metadata": {"source": "CRF", "title": "Factoring nonnegative matrices with linear programs", "authors": ["Victor Bittorf", "Benjamin Recht", "Christopher R\u00e9", "Joel A. Tropp"], "emails": [], "sections": [{"heading": null, "text": "Keywords. Nonnegative Matrix Factorization, Linear Programming, Stochastic gradient descent, Machine learning, Parallel computing, Multicore."}, {"heading": "1 Introduction", "text": "Nonnegative matrix factorization (NMF) is a popular approach for selecting features in data [15\u2013 17, 22]. Many machine-learning and data-mining software packages (including Matlab [3], R [11], and Oracle Data Mining [1]) now include heuristic computational methods for NMF. Nevertheless, we still have limited theoretical understanding of when these heuristics are correct.\nThe difficulty in developing rigorous methods for NMF stems from the fact that the problem is computationally challenging. Indeed, Vavasis has shown that NMF is NP-Hard [26]; see [4] for further worst-case hardness results. As a consequence, we must instate additional assumptions on the data if we hope to compute nonnegative matrix factorizations in practice.\nIn this spirit, Arora, Ge, Kannan, and Moitra (AGKM) have exhibited a polynomial-time algorithm for NMF that is provably correct\u2014provided that the data is drawn from an appropriate model, based on ideas from [7]. The AGKM result describes one circumstance where we can be sure that NMF algorithms are capable of producing meaningful answers. This work has the potential to make an impact in machine learning because proper feature selection is an important preprocessing step for many other techniques. Even so, the actual impact is damped by the fact that the AGKM algorithm is too computationally expensive for large-scale problems and is not tolerant to departures from the modeling assumptions. Thus, for NMF, there remains a gap between the theoretical exercise and the actual practice of machine learning.\nar X\niv :1\n20 6.\n12 70\nv2 [\nm at\nh. O\nC ]\n2 F\neb 2\n01 3\nThe present work presents a scalable, robust algorithm that can successfully solve the NMF problem under appropriate hypotheses. Our first contribution is a new formulation of the nonnegative feature selection problem that only requires the solution of a single linear program. Second, we provide a theoretical analysis of this algorithm. This argument shows that our method succeeds under the same modeling assumptions as the AGKM algorithm with an additional margin constraint that is common in machine learning. We prove that if there exists a unique, well-defined model, then we can recover this model accurately; our error bound improves substantially on the error bound for the AGKM algorithm in the high SNR regime. One may argue that NMF only \u201cmakes sense\u201d (i.e., is well posed) when a unique solution exists, and so we believe our result has independent interest. Furthermore, our algorithm can be adapted for a wide class of noise models.\nIn addition to these theoretical contributions, our work also includes a major algorithmic and experimental component. Our formulation of NMF allows us to exploit methods from operations research and database systems to design solvers that scale to extremely large datasets. We develop an efficient stochastic gradient descent (SGD) algorithm that is (at least) two orders of magnitude faster than the approach of AGKM when both are implemented in Matlab. We describe a parallel implementation of our SGD algorithm that can robustly factor matrices with 105 features and 106 examples in a few minutes on a multicore workstation. Our formulation of NMF uses a data-driven modeling approach to simplify the factorization problem. More precisely, we search for a small collection of rows from the data matrix that can be used to express the other rows. This type of approach appears in a number of other factorization problems, including rank-revealing QR [14], interpolative decomposition [19], subspace clustering [9, 23], dictionary learning [10], and others. Our computational techniques can be adapted to address large-scale instances of these problems as well."}, {"heading": "2 Separable Nonnegative Matrix Factorizations and Hott Topics", "text": "Notation. For a matrix M and indices i and j, we write Mi\u00b7 for the ith row of M and M\u00b7j for the jth column of M . We write Mij for the (i, j) entry.\nLet Y be a nonnegative f \u00d7 n data matrix with columns indexing examples and rows indexing features. Exact NMF seeks a factorization Y = FW where the feature matrix F is f \u00d7 r, where the weight matrix W is r \u00d7 n, and both factors are nonnegative. Typically, r min{f, n}.\nUnless stated otherwise, we assume that each row of the data matrix Y is normalized so it sums to one. Under this hypothesis, we may also assume that each row of F and of W also sums to one [4].\nIt is notoriously difficult to solve the NMF problem. Vavasis showed that it is NP-complete to decide whether a matrix admits a rank-r nonnegative factorization [26]. AGKM proved that an exact NMF algorithm can be used to solve 3-SAT in subexponential time [4].\nThe literature contains some mathematical analysis of NMF that can be used to motivate algorithmic development. Thomas [24] developed a necessary and sufficient condition for the existence of a rank-r NMF. More recently, Donoho and Stodden [7] obtained a related sufficient condition for uniqueness. AGKM exhibited an algorithm that can produce a nonnegative matrix factorization under a weaker sufficient condition. To state their results, we need a definition.\nDefinition 2.1 A set of vectors {v1, . . . ,vr} \u2282 Rd is simplicial if no vector vi lies in the convex hull of {vj : j 6= i}. The set of vectors is \u03b1-robust simplicial if, for each i, the `1 distance from vi to the convex hull of {vj : j 6= i} is at least \u03b1. Figure 1 illustrates these concepts.\nAlgorithm 1: AGKM: Approximably Separable Nonnegative Matrix Factorization [4]\n1: Initialize R = \u2205. 2: Compute the f \u00d7 f matrix D with Dij = \u2016Xi\u00b7 \u2212Xj\u00b7\u20161. 3: for k = 1, . . . f do 4: Find the set Nk of rows that are at least 5 /\u03b1+ 2 away from Xk\u00b7. 5: Compute the distance \u03b4k of Xk\u00b7 from conv({Xj\u00b7 : j \u2208 Nk}). 6: if \u03b4k > 2 , add k to the set R. 7: end for 8: Cluster the rows in R as follows: j and k\nare in the same cluster if Djk \u2264 10 /\u03b1+ 6 . 9: Choose one element from each cluster to\nyield W . 10: F = arg minZ\u2208Rf\u00d7r \u2225\u2225X \u2212ZW\u2225\u2225\u221e,1\nThese ideas support the uniqueness results of Donoho and Stodden and the AGKM algorithm. Indeed, we can find an NMF of Y efficiently if Y contains a set of r rows that is simplicial and whose convex hull contains the remaining rows.\nDefinition 2.2 An NMF Y = FW is called separable if the rows of W are simplicial and there is a permutation matrix \u03a0 such that\n\u03a0F = [ Ir M ] . (1)\nTo compute a separable factorization of Y , we must first identify a simplicial set of rows from Y . Afterward, we compute weights that express the remaining rows as convex combinations of this distinguished set. We call the simplicial rows hott and the corresponding features hott topics.\nThis model allows us to express all the features for a particular instance if we know the values of the instance at the simplicial rows. This assumption can be justified in a variety of applications. For example, in text, knowledge of a few keywords may be sufficient to reconstruct counts of the other words in a document. In vision, localized features can be used to predict gestures. In audio data, a few bins of the spectrogram may allow us to reconstruct the remaining bins.\nWhile a nonnegative matrix one encounters in practice might not admit a separable factorization, it may be well-approximated by a nonnnegative matrix with separable factorization. AGKM derived an algorithm for nonnegative matrix factorization of a matrix that is well-approximated by a separable factorization. To state their result, we introduce a norm on f \u00d7 n matrices:\n\u2225\u2225\u2206\u2225\u2225\u221e,1 := max1\u2264i\u2264f n\u2211 j=1 |\u2206ij | .\nTheorem 2.3 (AGKM [4]) Let and \u03b1 be nonnegative constants satisfying \u2264 \u03b1220+13\u03b1 . Let X be a nonnegative data matrix. Assume X = Y + \u2206 where Y is a nonnegative matrix whose rows\nhave unit `1 norm, where Y = FW is a rank-r separable factorization in which the rows of W are \u03b1-robust simplicial, and where \u2225\u2225\u2206\u2225\u2225\u221e,1 \u2264 . Then Algorithm 1 finds a rank-r nonnegative factorization F\u0302 W\u0302 that satisfies the error bound\n\u2225\u2225X \u2212 F\u0302 W\u0302\u2225\u2225\u221e,1 \u2264 10 /\u03b1+ 7 . In particular, the AGKM algorithm computes the factorization exactly when = 0. Although this method is guaranteed to run in polynomial time, it has many undesirable features. First, the algorithm requires a priori knowledge of the parameters \u03b1 and . It may be possible to calculate , but we can only estimate \u03b1 if we know which rows are hott. Second, the algorithm computes all `1 distances between rows at a cost of O(f\n2n). Third, for every row in the matrix, we must determine its distance to the convex hull of the rows that lie at a sufficient distance; this step requires us to solve a linear program for each row of the matrix at a cost of \u2126(fn). Finally, this method is intimately linked to the choice of the error norm\n\u2225\u2225\u00b7\u2225\u2225\u221e,1. It is not obvious how to adapt the algorithm for other noise models. We present a new approach, based on linear programming, that overcomes these drawbacks."}, {"heading": "3 Main Theoretical Results: NMF by Linear Programming", "text": "This paper shows that we can factor an approximately separable nonnegative matrix by solving a linear program. A major advantage of this formulation is that it scales to very large data sets.\nHere is the key observation: Suppose that Y is any f \u00d7 n nonnegative matrix that admits a rank-r separable factorization Y = FW . If we pad F with zeros to form an f \u00d7 f matrix, we have\nY = \u03a0T [\nIr 0 M 0\n] \u03a0Y =: CY\nWe call the matrix C factorization localizing. Note that any factorization localizing matrix C is an element of the polyhedral set\n\u03a6(Y ) := {C \u2265 0 : CY = Y , Tr(C) = r, Cjj \u2264 1 \u2200j, Cij \u2264 Cjj \u2200i, j}.\nThus, to find an exact NMF of Y , it suffices to find a feasible element of C \u2208 \u03a6(Y ) whose diagonal is integral. This task can be accomplished by linear programming. Once we have such a C, we construct W by extracting the rows of X that correspond to the indices i where Cii = 1. We construct the feature matrix F by extracting the nonzero columns of C. This approach is summarized in Algorithm 2. In turn, we can prove the following result.\nTheorem 3.1 Suppose Y is a nonnegative matrix with a rank-r separable factorization Y = FW . Then Algorithm 2 constructs a rank-r nonnegative matrix factorization of Y .\nAs the theorem suggests, we can isolate the rows of Y that yield a simplicial factorization by solving a single linear program. The factor F can be found by extracting columns of C."}, {"heading": "3.1 Robustness to Noise", "text": "Suppose we observe a nonnegative matrix X whose rows sum to one. Assume that X = Y + \u2206 where Y is a nonnegative matrix whose rows sum to one, which has a rank-r separable factorization\nAlgorithm 2 Separable Nonnegative Matrix Factorization by Linear Programming\nRequire: An f \u00d7 n nonnegative matrix Y with a rank-r separable NMF. Ensure: An f \u00d7 r matrix F and r \u00d7 n matrix W with F \u2265 0, W \u2265 0, and Y = FW . 1: Find the unique C \u2208 \u03a6(Y ) to minimize pT diag(C) where p is any vector with distinct values. 2: Let I = {i : Cii = 1} and set W = YI\u00b7 and F = C\u00b7I .\nAlgorithm 3 Approximably Separable Nonnegative Matrix Factorization by Linear Programming\nRequire: An f \u00d7 n nonnegative matrix X that satisfies the hypotheses of Theorem 3.2. Ensure: An f \u00d7 r matrix F and r\u00d7 n matrix W with F \u2265 0, W \u2265 0, and \u2225\u2225X \u2212 FW\u2225\u2225\u221e,1 \u2264 2 . 1: Find C \u2208 \u03a62 (X) that minimizes pT diagC where p is any vector with distinct values. 2: Let I = {i : Cii = 1} and set W = XI\u00b7. 3: Set F = arg minZ\u2208Rf\u00d7r\n\u2225\u2225X \u2212ZW\u2225\u2225\u221e,1 Y = FW such that the rows of W are \u03b1-robust simplicial, and where\n\u2225\u2225\u2206\u2225\u2225\u221e,1 \u2264 . Define the polyhedral set\n\u03a6\u03c4 (X) := { C \u2265 0 : \u2225\u2225CX \u2212X\u2225\u2225\u221e,1 \u2264 \u03c4,Tr(C) = r, Cjj \u2264 1 \u2200j, Cij \u2264 Cjj \u2200i, j} The set \u03a6(X) consists of matrices C that approximately locate a factorization of X. We can prove the following result.\nTheorem 3.2 Suppose that X satisfies the assumptions stated in the previous paragraph. Furthermore, assume that for every row Yj,\u00b7 that is not hott, we have the margin constraint \u2016Yj,\u00b7\u2212Yi,\u00b7\u2016 \u2265 d0 for all hott rows i. Then we can find a nonnegative factorization satisfying \u2225\u2225X \u2212 F\u0302 W\u0302\u2225\u2225\u221e,1 \u2264 2 provided that < min{\u03b1d0,\u03b1\n2} 9(r+1) . Furthermore, this factorization correctly identifies the hott topics\nappearing in the separable factorization of Y .\nAlgorithm 3 requires the solution of two linear programs. The first minimizes a cost vector over \u03a62 (X). This lets us find W\u0302 . Afterward, the matrix F\u0302 can be found by setting\nF\u0302 = arg min Z\u22650 \u2225\u2225X \u2212ZW\u0302\u2225\u2225\u221e,1 . (2) Our robustness result requires a margin-type constraint assuming that the original configuration consists either of duplicate hott topics, or topics that are reasonably far away from the hott topics. On the other hand, under such a margin constraint, we can construct a considerably better approximation than that guaranteed by the AGKM algorithm. Moreover, unlike AGKM, our algorithm does not need to know the parameter \u03b1.\nThe proofs of Theorems 3.1 and 3.2 can be found in the appendix. The main idea is to show that we can only represent a hott topic efficiently using the hott topic itself. Some earlier versions of this paper contained incomplete arguments, which we have remedied. For a signifcantly stronger robustness analysis of Algorithm 3, see the recent paper [12].\nHaving established these theoretical guarantees, it now remains to develop an algorithm to solve the LP. Off-the-shelf LP solvers may suffice for moderate-size problems, but for large-scale matrix factorization problems, their running time is prohibitive, as we show in Section 5. In Section 4, we turn to describe how to solve Algorithm 3 efficiently for large data sets."}, {"heading": "3.2 Related Work", "text": "Localizing factorizations via column or row subset selection is a popular alternative to direct factorization methods such as the SVD. Interpolative decomposition such as Rank-Revealing QR [14] and CUR [19] have favorable efficiency properties as compared to factorizations (such as SVD) that are not based on exemplars. Factorization localization has been used in subspace clustering and has been shown to be robust to outliers [9, 23].\nIn recent work on dictionary learning, Esser et al. and Elhamifar et al. have proposed a factorization localization solution to nonnegative matrix factorization using group sparsity techniques [8,10]. Esser et al. prove asymptotic exact recovery in a restricted noise model, but this result requires preprocessing to remove duplicate or near-duplicate rows. Elhamifar shows exact representative recovery in the noiseless setting assuming no hott topics are duplicated. Our work here improves upon this work in several aspects, enabling finite sample error bounds, the elimination of any need to preprocess the data, and algorithmic implementations that scale to very large data sets."}, {"heading": "4 Incremental Gradient Algorithms for NMF", "text": "The rudiments of our fast implementation rely on two standard optimization techniques: dual decomposition and incremental gradient descent. Both techniques are described in depth in Chapters 3.4 and 7.8 of Bertsekas and Tstisklis [5].\nWe aim to minimize pT diag(C) subject to C \u2208 \u03a6\u03c4 (X). To proceed, form the Lagrangian\nL(C, \u03b2,w) = pT diag(C) + \u03b2(Tr(C)\u2212 r) + f\u2211 i=1 wi (\u2016Xi\u00b7 \u2212 [CX]i\u00b7\u20161 \u2212 \u03c4)\nwith multipliers \u03b2 and w \u2265 0. Note that we do not dualize out all of the constraints. The remaining ones appear in the constraint set \u03a60 = {C : C \u2265 0, diag(C) \u2264 1, and Cij \u2264 Cjj for all i, j}.\nDual subgradient ascent solves this problem by alternating between minimizing the Lagrangian over the constraint set \u03a60, and then taking a subgradient step with respect to the dual variables\nwi \u2190 wi + s (\u2016Xi\u00b7 \u2212 [C?X]i\u00b7\u20161 \u2212 \u03c4) and \u03b2 \u2190 \u03b2 + s(Tr(C?)\u2212 r)\nwhere C? is the minimizer of the Lagrangian over \u03a60. The update of wi makes very little difference in the solution quality, so we typically only update \u03b2.\nWe minimize the Lagrangian using projected incremental gradient descent. Note that we can rewrite the Lagrangian as\nL(C, \u03b2,w) = \u2212\u03c41Tw \u2212 \u03b2r + n\u2211 k=1  \u2211 j\u2208supp(X\u00b7k) wj\u2016Xjk \u2212 [CX]jk\u20161 + \u00b5j(pj + \u03b2)Cjj  . Here, supp(x) is the set indexing the entries where x is nonzero, and \u00b5j is the number of nonzeros in row j divided by n. The incremental gradient method chooses one of the n summands at random and follows its subgradient. We then project the iterate onto the constraint set \u03a60. The projection onto \u03a60 can be performed in the time required to sort the individual columns of C plus a linear-time operation. The full procedure is described in Appendix B. In the case where we expect a unique solution, we can drop the constraint Cij \u2264 Cjj , resulting in a simple clipping procedure: set all\nAlgorithm 4 Hottopixx: Approximate Separable NMF by Incremental Gradient Descent\nRequire: An f \u00d7 n nonnegative matrix X. Primal and dual stepsizes sp and sd. Ensure: An f \u00d7 r matrix F and r\u00d7 n matrix W with F \u2265 0, W \u2265 0, and \u2225\u2225X \u2212 FW\u2225\u2225\u221e,1 \u2264 2 . 1: Pick a cost p with distinct entries. 2: Initialize C = 0, \u03b2 = 0 3: for t = 1, . . . , Nepochs do 4: for i = 1, . . . n do 5: Choose k uniformly at random from [n]. 6: C \u2190 C + sp \u00b7 sign(X\u00b7k \u2212CX\u00b7k)XT\u00b7k \u2212 sp diag(\u00b5 \u25e6 (\u03b21\u2212 p)). 7: end for 8: Project C onto \u03a60. 9: \u03b2 \u2190 \u03b2 + sd(Tr(C)\u2212 r) 10: end for 11: Let I = {i : Cii = 1} and set W = XI\u00b7. 12: Set F = arg minZ\u2208Rf\u00d7r\n\u2225\u2225X \u2212ZW\u2225\u2225\u221e,1 negative items to zero and set any diagonal entry exceeding one to one. In practice, we perform a tradeoff. Since the constraint Cij \u2264 Cjj is used solely for symmetry breaking, we have found empirically that we only need to project onto \u03a60 every n iterations or so.\nThis incremental iteration is repeated n times in a phase called an epoch. After each epoch, we update the dual variables and quit after we believe we have identified the large elements of the diagonal of C. Just as before, once we have identified the hott rows, we can form W by selecting these rows of X. We can find F just as before, by solving (2). Note that this minimization can also be computed by incremental subgradient descent. The full procedure, called Hottopixx, is described in Algorithm 4."}, {"heading": "4.1 Sparsity and Computational Enhancements for Large Scale.", "text": "For small-scale problems, Hottopixx can be implemented in a few lines of Matlab code. But for the very large data sets studied in Section 5, we take advantage of natural parallelism and a host of lowlevel optimizations that are also enabled by our formulation. As in any numerical program, memory layout and cache behavior can be critical factors for performance. We use standard techniques: in-memory clustering to increase prefetching opportunities, padded data structures for better cache alignment, and compiler directives to allow the Intel compiler to apply vectorization.\nNote that the incremental gradient step (step 6 in Algorithm 4) only modifies the entries of C where X\u00b7k is nonzero. Thus, we can parallelize the algorithm with respect to updating either the rows or the columns of C. We store X in large contiguous blocks of memory to encourage hardware prefetching. In contrast, we choose a dense representation of our localizing matrix C; this choice trades space for runtime performance.\nEach worker thread is assigned a number of rows of C so that all rows fit in the shared L3 cache. Then, each worker thread repeatedly scans X while marking updates to multiple rows of C. We repeat this process until all rows of C are scanned, similar to the classical block-nested loop join in relational databases [21]."}, {"heading": "5 Experiments", "text": "Except for the speedup curves, all of the experiments were run on an identical configuration: a dual Xeon X650 (6 cores each) machine with 128GB of RAM. The kernel is Linux 2.6.32-131.\nIn small-scale, synthetic experiments, we compared Hottopixx to the AGKM algorithm and the linear programming formulation of Algorithm 3 implemented in Matlab. Both AGKM and Algorithm 3 were run using CVX [13] coupled to the SDPT3 solver [25]. We ran Hottopixx for 50 epochs with primal stepsize 1e-1 and dual stepsize 1e-2. Once the hott topics were identified, we fit F using two cleaning epochs of incremental gradient descent for all three algorithms.\nTo generate our instances, we sampled r hott topics uniformly from the unit simplex in Rn. These topics were duplicated d times. We generated the remaining f \u2212 r(d+ 1) rows to be random convex combinations of the hott topics, with the combinations selected uniformly at random. We then added noise with (\u221e, 1)-norm error bounded by \u03b7\u00b7 \u03b1220+13\u03b1 . Recall that AGKM algorithm is only guaranteed to work for \u03b7 < 1. We ran with f \u2208 {40, 80, 160}, n \u2208 {400, 800, 1600}, r \u2208 {3, 5, 10}, d \u2208 {0, 1, 2}, and \u03b7 \u2208 {0.25, 0.95, 4, 10, 100}. Each experiment was repeated 5 times.\nBecause we ran over 2000 experiments with 405 different parameter settings, it is convenient to use the performance profiles to compare the performance of the different algorithms [6]. Let P be the set of experiments and A denote the set of different algorithms we are comparing. Let Qa(p) be the value of some performance metric of the experiment p \u2208 P for algorithm a \u2208 A. Then the performance profile at \u03c4 for a particular algorithm is the fraction of the experiments where the value of Qa(p) lies within a factor of \u03c4 of the minimal value of minb\u2208AQb(p). That is,\nPa(\u03c4) = # {p \u2208 P : Qa(p) \u2264 \u03c4 mina\u2032\u2208AQa\u2032(p)}\n#(P) .\nIn a performance profile, the higher a curve corresponding to an algorithm, the more often it outperforms the other algorithms. This gives a convenient way to contrast algorithms visually.\nOur performance profiles are shown in Figure 2. The first two figures correspond to experiments with f = 40 and n = 400. The third figure is for the synthetic experiments with all other values of f and n. In terms of (\u221e, 1)-norm error, the linear programming solver typically achieves the lowest error. However, using SDPT3, it is prohibitively slow to factor larger matrices. On the other hand, Hottopixx achieves better noise performance than the AGKM algorithm in much less time. Moreover, the AGKM algorithm must be fed the values of and \u03b1 in order to run. Hottopixx does not require this information and still achieves about the same error performance.\nWe also display a graph for running only four epochs (hott (fast)). This algorithm is by far the fastest algorithm, but does not achieve as optimal a noise performance. For very high levels of noise, however, it achieves a lower reconstruction error than the AGKM algorithm, whose performance degrades once \u03b7 approaches or exceeds 1 (Figure 2(f)). We also provide performance profiles for the root-mean-square error of the nonnegative matrix factorizations (Figure 2 (d) and (e)). The performance is qualitatively similar to that for the (\u221e, 1)-norm.\nWe also coded Hottopixx in C++, using the design principles described in Section 4.1, and ran on three large data sets. We generated a large synthetic example (jumbo) as above with r = 100. We generated a co-occurrence matrix of people and places from the ClueWeb09 Dataset [2], normalized by TFIDF. We also used Hottopixx to select features from the RCV1 data set to recognize the class CCAT [18]. The statistics for these data sets can be found in Table 1.\nIn Figure 3 (left), we plot the speed-up over a serial implementation. In contrast to other parallel methods that exhibit memory contention [20], we see superlinear speed-ups for up to 20 threads\ndue to hardware prefetching and cache effects. All three of our large data sets can be trained in minutes, showing that we can scale Hottopixx on both synthetic and real data. Our algorithm is able to correctly identify the hott topics on the jumbo set. For clueweb, we plot the RMSE Figure 3 (middle). This curve rolls off quickly for the first few hundred topics, demonstrating that our algorithm may be useful for dimensionality reduction in Natural Language Processing applications. For RCV1, we trained an SVM on the set of features extracted by Hottopixx and plot the misclassification error versus the number of topics in Figure 3 (right). With 1500 hott topics, we achieve 7% misclassification error as compared to 5.5% with the entire set of features."}, {"heading": "6 Discussion", "text": "This paper provides an algorithmic and theoretical framework for analyzing and deploying any factorization problem that can be posed as a linear (or convex) factorization localizing program.\nFuture work should investigate the applicability of Hottopixx to other factorization localizing algorithms, such as subspace clustering, and should revisit earlier theoretical bounds on such prior art."}, {"heading": "Acknowledgments", "text": "The authors would like to thank Sanjeev Arora, Michael Ferris, Rong Ge, Nicolas Gillis, Ankur Moitra, and Stephen Wright for helpful suggestions. BR is generously supported by ONR award N00014-11-1-0723, NSF award CCF-1139953, and a Sloan Research Fellowship. CR is generously supported by NSF CAREER award under IIS-1054009, ONR award N000141210041, and gifts or research awards from American Family Insurance, Google, Greenplum, and Oracle. JAT is generously supported by ONR award N00014-11-1002, AFOSR award FA9550-09-1-0643, and a Sloan Research Fellowship.\nReferences\n[1] docs.oracle.com/cd/B28359_01/datamine.111/b28129/algo_nmf.htm.\n[2] lemurproject.org/clueweb09/.\n[3] www.mathworks.com/help/toolbox/stats/nnmf.html.\n[4] S. Arora, R. Ge, R. Kannan, and A. Moitra. Computing a nonnegative matrix factorization \u2013 provably. To appear in STOC 2012. Preprint available at \\arxiv.org/abs/1111.0952, 2011.\n[5] D. P. Bertsekas and J. N. Tsitsiklis. Parallel and Distributed Computation: Numerical Methods. Athena Scientific, Belmont, MA, 1997.\n[6] E. D. Dolan and J. J. More\u0301. Benchmarking optimization software with performance profiles. Mathematical Programming, Series A, 91:201\u2013213, 2002.\n[7] D. Donoho and V. Stodden. When does non-negative matrix factorization give a correct decomposition into parts? In Advances in Neural Information Processing Systems, 2003.\n[8] E. Elhamifar, G. Sapiro, and R. Vidal. See all by looking at a few: Sparse modeling for finding representative objects. In Proceedings of CVPR, 2012.\n[9] E. Elhamifar and R. Vidal. Sparse subspace clustering. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2009.\n[10] E. Esser, M. Mo\u0308ller, S. Osher, G. Sapiro, and J. Xin. A convex model for non-negative matrix factorization and dimensionality reduction on physical space. IEEE Transactions on Image Processing, 2012. To appear. Preprint available at arxiv.org/abs/1102.0844.\n[11] R. Gaujoux and C. Seoighe. NMF: A flexible R package for nonnegative matrix factorization. BMC Bioinformatics, 11:367, 2010. doi:10.1186/1471-2105-11-367.\n[12] N. Gillis. Robustness analysis of hotttopixx, a linear programming model for factoring nonnegative matrices. arxiv.org/1211.6687, 2012.\n[13] M. Grant and S. Boyd. CVX: Matlab software for disciplined convex programming, version 1.21. http://cvxr.com/cvx, May 2010.\n[14] M. Gu and S. C. Eisenstat. Efficient algorithms for computing a strong rank-revealing QR factorization. SIAM Journal on Scientific Computing, 17:848\u2013869, 1996.\n[15] T. Hofmann. Probabilistic latent semantic indexing. In Proceedings of the 22nd Annual International SIGIR Conference on Research and Development in Information Retrieval, 1999.\n[16] D. D. Lee and H. S. Seung. Learning the parts of objects by non-negative matrix factorization. Nature, 401:788\u2013791, 1999.\n[17] D. D. Lee and H. S. Seung. Algorithms for non-negative matrix factorization. In Advances in Neural Information Processing Systems, 2001.\n[18] D. Lewis, Y. Yang, T. Rose, and F. Li. RCV1: A new benchmark collection for text categorization research. Journal of Machine Learning Research, 5:361\u2013397, 2004.\n[19] M. W. Mahoney and P. Drineas. CUR matrix decompositions for improved data analysis. Proceedings of the National Academy of Sciences, 106:697\u2013702, 2009.\n[20] F. Niu, B. Recht, C. Re\u0301, and S. J. Wright. HOGWILD!: A lock-free approach to parallelizing stochastic gradient descent. In Advances in Neural Information Processing Systems, 2011.\n[21] L. D. Shapiro. Join processing in database systems with large main memories. ACM Transactions on Database Systems, 11(3):239\u2013264, 1986.\n[22] P. Smaragdis. Non-negative matrix factorization for polyphonic music transcription. In IEEE Workshop on Applications of Signal Processing to Audio and Acoustics, pages 177\u2013180, 2003.\n[23] M. Soltanolkotabi and E. J. Cande\u0300s. A geometric analysis of subspace clustering with outliers. Preprint available at arxiv.org/abs/1112.4258, 2011.\n[24] L. B. Thomas. Problem 73-14, rank factorization of nonnegative matrices. SIAM Review, 16(3):393\u2013394, 1974.\n[25] K. C. Toh, M. Todd, and R. H. Tu\u0308tu\u0308ncu\u0308. SDPT3: A MATLAB software package for semidefinitequadratic-linear programming. Available from http://www.math.nus.edu.sg/~mattohkc/sdpt3.html.\n[26] S. A. Vavasis. On the complexity of nonnegative matrix factorization. SIAM Joural on Optimization, 20(3):1364\u20131377, 2009."}, {"heading": "A Proofs", "text": "Let Y be a nonnegative matrix whose rows sum to one. Assume that Y admits an exact separable factorization of rank r. In other words, we can write Y = FW where the rows of W are \u03b1-robust simplicial and\n\u03a0F = [ Ir M ] for some permutation \u03a0. Let I denote the indices of the rows in Y that correspond with the identity matrix in the factorization, which we have called the hott rows. Then we can write each row j that is not hott as a convex combination of the hott rows:\nYj\u00b7 = \u2211 k\u2208I MjkYk\u00b7 for each j /\u2208 I.\nAs we have discussed, we may assume that \u2211\nkMjk = 1 for each j /\u2208 I because each row of Y sums to one.\nThe first lemma offers a stronger bound on the coefficients Mjk in terms of the distance between row j and the hott rows.\nLemma A.1 For an index `, suppose that the row Y`\u00b7 has distance greater than \u03b4 from a hott topic Yi\u00b7 with i \u2208 I. Then M`i \u2264 1\u2212 \u03b4/2.\nProof We can express the `th row as a convex combination of hott rows: Y`\u00b7 = \u2211\nk\u2208IM`kYk\u00b7. For each i \u2208 I, we can bound M`i as follows.\n\u03b4 \u2264 \u2016Yi\u00b7 \u2212 Y`\u00b7\u20161 = \u2225\u2225\u2225\u2225\u2225Yi\u00b7 \u2212\u2211 k\u2208I M`kYk\u00b7 \u2225\u2225\u2225\u2225\u2225 1\n= \u2225\u2225\u2225\u2225\u2225\u2225(1\u2212M`i)Yi \u2212 \u2211\nk\u2208I\\{i}\nM`kYk\u00b7 \u2225\u2225\u2225\u2225\u2225\u2225 1\n\u2264 \u2016(1\u2212M`i)Yi\u20161 + \u2211\nk\u2208I\\{i}\nM`k \u2016Yk\u00b7\u20161\n= 2(1\u2212M`i) .\nThe inequality is the triangle inequality. To reach the last line, we use the fact that each row of Y has `1 norm equal to one. Furthermore, \u2211 k\u2208I\\{i}M`k = 1 \u2212M`i \u2265 0 because each row of M consists of nonnegative numbers that sum to one. Rearrange to complete the argument.\nThe next lemma is the central tool in our proofs. It tells us that any representation of a hott row has to involve rows that are close in `1 norm to a hott row. To state the result, we define for each hott row i\nB\u03b4(i) = {j : \u2016Yi\u00b7 \u2212 Yj\u00b7\u20161 \u2264 \u03b4}.\nIn other words, B\u03b4(i) contains the indices of all rows with `1 distance no greater than \u03b4 from the hott topic Yi\u00b7.\nLemma A.2 Let c \u2208 Rf be a nonnegative vector whose entries sum to one. For some hott row i \u2208 I, suppose that \u2016cTY \u2212 Yi\u00b7\u20161 \u2264 \u03c4 . Then\u2211\nj\u2208B\u03b4(i)\ncj \u2265 1\u2212 2\u03c4\nmin{\u03b1\u03b4, \u03b12} . (3)\nProof Let us introduce notation for the quantity of interest: wi = wi(c) = \u2211\nj\u2208B\u03b4(Xi\u00b7) cj . We may assume that wi < 1, or else the result holds trivially. Since the entries of c sum to one, we have\n0 < 1\u2212 wi = \u2211 j cj \u2212 \u2211\nj\u2208B\u03b4(i)\ncj = \u2211\nj /\u2208B\u03b4(i)\ncj .\nNext, we introduce the extra assumption that \u03b4 < \u03b1. It is clear that wi increases monotonically with \u03b4, so any lower bound on wi that we establish in this case extends to a bound that holds for larger \u03b4. Since the hott topics are \u03b1-robust simplicial, all the other hott topics are at least \u03b4 away from Yi\u00b7 in `1 norm. Therefore, the hott row i is the unique hott row listed in B\u03b4(i).\nTo establish the result, we may as well assume that wi(c) achieves its minimum possible value subject to the constraints that the value of cTY is fixed and that c is a nonnegative vector that sums to one. We claim that this minimum such wi occurs if and only if cj = 0 for all j \u2208 B\u03b4(i)\\{i}. We complete the proof under this additional surmise.\nThe assertion in the last paragraph follows from an argument by contradiction. Suppose that wi(c) were minimized at a vector c where cj > 0 for some j \u2208 B\u03b4(i) \\ {i}. Then we can construct another set of coefficients c\u0303 that satisfies the constraints and leads to a smaller value of wi. We have the representation Yj\u00b7 = \u2211 k\u2208IMjkYk\u00b7. Set c\u0303j = 0; set c\u0303k = ck + cjMjk for each k \u2208 I, and set c\u0303k = ck for all remaining k /\u2208 I \u222a {j}. It is easy to verify that c\u0303TY = cTY and that c\u0303 is a nonnegative vector whose entries sum to one. But the value of wi is strictly smaller with the coefficients c\u0303:\nwi(c\u0303) = \u2211\nk\u2208B\u03b4(i)\nc\u0303k < \u2211\nk\u2208B\u03b4(i)\nck = wi(c)\nIn this relation, all the summands cancel, except for the one with index j. But c\u0303j = 0 < cj . It follows that the minimum value of wi cannot occur when cj > 0. Compactness of the constraint set assures us that there is some vector c of coefficients that minimizes wi(c), so we must conclude that the minimizer c satisfies cj = 0 for j \u2208 B\u03b4(i) \\ {i}.\nLet us continue. Owing to the assumption that Yi\u00b7 is no farther than \u03c4 from c TY , we have\n\u03c4 \u2265 \u2225\u2225\u2225\u2225\u2225\u2225Yi\u00b7 \u2212 \u2211 j cjYj\u00b7 \u2225\u2225\u2225\u2225\u2225\u2225 1\n= \u2225\u2225\u2225\u2225\u2225\u2225(1\u2212 wi)Yi\u00b7 \u2212 \u2211\nj /\u2208B\u03b4(i)\ncjYj\u00b7 \u2225\u2225\u2225\u2225\u2225\u2225 1\n= (1\u2212 wi) \u2225\u2225\u2225\u2225\u2225\u2225Yi\u00b7 \u2212 11\u2212 wi \u2211\nj /\u2208B\u03b4(i)\n\u2211 k\u2208I cjMjkYk\u00b7 \u2225\u2225\u2225\u2225\u2225\u2225 1 . (4)\nThe first line follows when we split the sum over j based on whether or not the components fall in B\u03b4(i). Then we apply the property that cj = 0 for j \u2208 B\u03b4(i) \\ {i}, and we identify the quantity wi. In the last line, we factored out 1\u2212 wi, and we introduced the separable factorization of Y .\nNext, for each k \u2208 I, define \u03c0k :=\n1\n1\u2212 wi \u2211 j /\u2208B\u03b4(i) cjMjk ,\nand note that \u03c0k \u2265 0. Furthermore,\u2211 k\u2208I \u03c0k = 1 1\u2212 wi \u2211 j /\u2208B\u03b4(i) cj \u2211 k\u2208I Mjk = 1 1\u2212 wi \u2211 j /\u2208B\u03b4(i) cj = 1\nbecause the rows of M sum to one and because of the definition of wi. Lemma A.1 implies that \u03c0i satisfies the bound\n\u03c0i = 1\n1\u2212 wi \u2211 j /\u2208B\u03b4(i) cjMji \u2264 1\u2212 \u03b4/2 1\u2212 wi \u2211 j /\u2208B\u03b4(i) cj = 1\u2212 \u03b4/2. (5)\nIndeed, the lemma is valid because Yj\u00b7 is at least a distance of \u03b4 away from Yi\u00b7 for every j /\u2208 B\u03b4(i). With these observations, we can continue our calculation from (4):\n\u03c4 \u2265 (1\u2212 wi) \u2225\u2225\u2225\u2225\u2225Yi\u00b7 \u2212\u2211 k\u2208I \u03c0kYk\u00b7 \u2225\u2225\u2225\u2225\u2225 1\n= (1\u2212 wi)(1\u2212 \u03c0i) \u2225\u2225\u2225\u2225\u2225\u2225Yi\u00b7 \u2212 \u2211\nk\u2208I\\{i}\n\u03c0k 1\u2212 \u03c0i Yk\u00b7 \u2225\u2225\u2225\u2225\u2225\u2225 1\n\u2265 (1\u2212 wi)(1\u2212 \u03c0i)\u03b1 \u2265 (1\u2212 wi)(\u03b4/2)\u03b1.\nThe first identity follows when we combine the ith term in the sum with Yi\u00b7. The inequality depends on the assumption that W is \u03b1-robust simplicial; any convex combination of {Yk\u00b7 : k /\u2208 I} is at least \u03b1 away from Yi\u00b7 in `1 norm. Afterward, we use the bound (5). Rearrange the final expression to complete the argument.\nA.1 Proof of Theorem 3.1\nThis result is almost obvious when there are no duplicated rows. Indeed, since the hott topics form a simplicial set and the matrix Y admits a separable factorization, the only way we can represent all r hott topics exactly is to have Cii = 1 for every hott row i. This exhausts the trace constraint, and we see that every other diagonal entry Ckk = 0 for every not hott row k. The only matrices that are feasible identify the hott rows on the diagonal. They must represent the remaining rows using linear combinations of the hott topics because of the constraints CY = Y and Cij \u2264 Cjj . It follows that the only feasible matrices are factorization localizing matrices.\nWhen there are duplicated rows, the analysis is slightly more delicate. By the same argument as above, all the weight on the diagonal must be concentrated on hott rows. But the objective pT diag(C) ensures that, out of any set of duplicates of a given topic, we always pick the duplicate row j where pj is smallest; otherwise, we could reduce the objective further. Therefore, the diagonal of C identifies all r distinct hott topics, and we select each one duplicate of each topic. As before, the other constraints ensure that the remaining rows are represented with this distinguished choice of hott topic exemplars. Therefore, the only minimizers are factorization localizing matrices that identify each hott topic exactly once.\nA.2 Proof of Theorem 3.2\nLet X = Y + \u2206. The matrix X is the observed data, with rows scaled to have unit sum, and the perturbation matrix \u2206 satisfies \u2225\u2225\u2206\u2225\u2225\u221e,1 \u2264 . We assume that Y is a nonnegative matrix whose rows sum to one, and we posit that it admits a rank-r separable NMF Y = FW where W is \u03b1-robust simplicial. We write I for the set of rows corresponding to hott topics in Y .\nSuppose that C0 is a factorization localizing matrix for the underlying matrix Y . That is, C0Y = Y and each row of C0 sums to one. It follows that\u2225\u2225C0\u2206\u2212\u2206\u2225\u2225\u221e,1 \u2264 (\u2225\u2225C0\u2225\u2225\u221e,1 + \u2225\u2225I\u2225\u2225\u221e,1)\u2225\u2225\u2206\u2225\u2225\u221e,1 \u2264 2 . Using our decomposition X = Y + \u2206, we quickly verify that\u2225\u2225C0X \u2212X\u2225\u2225\u221e,1 \u2264 \u2225\u2225C0Y \u2212 Y \u2225\u2225\u221e,1 + \u2225\u2225C0\u2206\u2212\u2206\u2225\u2225\u221e,1 \u2264 2 . The point here is that a factorization localizing matrix for Y serves as an approximate factorization localizing matrix for X.\nOur approach for constructing an approximate factorization of X requires us to minimize a cost function tT diag(C) over the constraint set\n\u03a62 (X) = { C \u2265 0 : \u2225\u2225CX \u2212X\u2225\u2225\u221e,1 \u2264 2 ,Tr(C) = r, Cjj \u2264 1 \u2200j, Cij \u2264 Cjj \u2200i, j} . (6) Note that the factorization localizing matrix C0 for Y is a member of this set, so the optimization problem we solve in Theorem 3.2 is feasible.\nSuppose that C \u2208 \u03a62 (X) is arbitrary. Let us check that the row sums of C are not much larger than one. To that end, note that\nC1 = CX1 = X1 + (CX \u2212X)1 = 1 + (CX \u2212X)1.\nWe have twice used the fact that every row of X sums to one. For any row c of the matrix C, this formula yields cT1 \u2264 1 + 2 since \u2225\u2225CX \u2212X\u2225\u2225\u221e,1 \u2264 2 . As a consequence,\u2225\u2225C\u2206\u2212\u2206\u2225\u2225\u221e,1 \u2264 (\u2225\u2225C\u2225\u2225\u221e,1 + \u2225\u2225I\u2225\u2225\u221e,1)\u2225\u2225\u2206\u2225\u2225\u221e,1 \u2264 (1 + 2 + 1) = 2 + 2 2. We may conclude that\u2225\u2225CY \u2212 Y \u2225\u2225\u221e,1 \u2264 \u2225\u2225CX \u2212X\u2225\u2225\u221e,1 + \u2225\u2225C\u2206\u2212\u2206\u2225\u2225\u221e,1 \u2264 4 + 2 2.\nThe margin assumption states that \u2016Y`\u00b7 \u2212 Yi\u00b7\u2016 > d0 for every hott topic i \u2208 I and every row ` /\u2208 I. For any i \u2208 I, Lemma A.2 ensures that any approximate representation cTY of the ith row Yi\u00b7 with error at most 4 + 2 2 satisfies\nci = \u2211\nj\u2208Bd0 (i)\ncj \u2265 1\u2212 8 + 4 2\nmin{\u03b1d0, \u03b12} .\nIn particular, every matrix C in the set \u03a62 (X) has Cii \u2265 1 \u2212 (8 + 4 2)/min{\u03b1d0, \u03b12} for each hott topic i. To ensure that hott topic i has weight Cii greater than 1 \u2212 1/(r + 1) for each i, we need\n< \u221a 1 +\nmin{\u03b1d0, \u03b12} 4(r + 1) \u2212 1 < min{\u03b1d0, \u03b1 2} 9(r + 1)\nSince there are r hott rows, they carry total weight greater than r(1\u2212 1/(r + 1)). Given the trace constraint, that leaves less than 1 \u2212 1/(r + 1) for the remaining rows. We see that each of the r hott rows must carry more weight than every row that is not hott, so we can easily identify them.\nOnce we have identified the set I of hott topics, we simply solve the second linear program\nminimize B \u2225\u2225X \u2212 [ I B ] XI \u2225\u2225 \u221e,1 (7)\nto find a 2 -accurate factorization."}, {"heading": "B Projection onto \u03a60", "text": "To project onto the set \u03a60, note that we can compute the projection one column at a time. Moreover, the projection for each individual column amounts to (after permuting the entries of the column),\n{x \u2208 Rf : 0 \u2264 xi \u2264 x1 \u2200i , x1 \u2264 1} .\nAssume, again without loss of generality, that we want to project a vector z with z2 \u2265 z3 \u2265 . . . \u2265 zn. Then we need to solve the quadratic program\nminimize 12\u2016z \u2212 x\u2016 2 subject to 0 \u2264 xi \u2264 x1 \u2200i , x1 \u2264 1 (8)\nThe optimal solution can be found as follows. Let kc be the largest k \u2208 {2, . . . , f} such that\nzkc+1 \u2264 \u03a0[0,1] ( kc\u2211 k=1 zk ) =: \u00b5\nwhere \u03a0[0,1] denotes the projection onto the interval [0, 1]. Set\nx\u0302i = { \u00b5 i \u2264 kc (zi)+ i > kc .\nThen x\u0302 is the optimal solution. A linear time algorithm for computing x\u0302 is given by Algorithm 5 To prove that x\u0302 is optimal, define\nyi = { zi \u2212 \u00b5 i \u2264 kc min(zi, 0) i > kc .\nyi is the gradient of 1 2\u2016x\u2212 z\u2016 2 at x\u0302. Consider the LP\nminimize \u2212yTx subject to 0 \u2264 xi \u2264 x1 \u2200i , x1 \u2264 1 .\nx\u0302 is an optimal solution for this LP because the cost is negative on the negative entries, 0 on the nonnegative entries that are larger than kc, positive for 2 \u2264 k \u2264 kc, and nonpositive for k = 1. Hence, by the minimum principle, x\u0302 is also a solution of (8).\nAlgorithm 5 Column Squishing\nRequire: A vector z \u2208 Rf with z2 \u2265 z3 \u2265 . . . \u2265 zn. Ensure: The projection of z onto {x \u2208 Rf : 0 \u2264 xi \u2264 x1 \u2200i , x1 \u2264 1}. 1: \u00b5\u2190 z1. 2: for k = 2, . . . , f do 3: if zk \u2264 \u03a0[0,1](\u00b5), Set kc = k \u2212 1 and break 4: else set \u00b5 = k\u22121k \u00b5+ 1 kzk.\n5: end for 6: x1 \u2190 \u03a0[0,1](\u00b5) 7: for k = 2, . . . , kc set xk = \u03a0[0,1](\u00b5). 8: for k = (kc + 1), . . . , f set xk = (zi)+. 9: return x"}], "references": [], "referenceMentions": [], "year": 2013, "abstractText": "<lb>This paper describes a new approach, based on linear programming, for computing nonneg-<lb>ative matrix factorizations (NMFs). The key idea is a data-driven model for the factorization<lb>where the most salient features in the data are used to express the remaining features. More<lb>precisely, given a data matrix X, the algorithm identifies a matrix C that satisfies X \u2248 CX<lb>and some linear constraints. The constraints are chosen to ensure that the matrix C selects<lb>features; these features can then be used to find a low-rank NMF of X. A theoretical analysis<lb>demonstrates that this approach has guarantees similar to those of the recent NMF algorithm<lb>of Arora et al. (2012). In contrast with this earlier work, the proposed method extends to more<lb>general noise models and leads to efficient, scalable algorithms. Experiments with synthetic and<lb>real datasets provide evidence that the new approach is also superior in practice. An optimized<lb>C++ implementation can factor a multigigabyte matrix in a matter of minutes.", "creator": "TeX"}}}