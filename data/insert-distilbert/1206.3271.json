{"id": "1206.3271", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "13-Jun-2012", "title": "Learning Arithmetic Circuits", "abstract": "empirical graphical models are usually learned without regard to the cost of doing inference with them. as a result, even if a good model is learned, it may perform poorly at prediction, obviously because it requires approximate inference. we propose an alternative : learning models with a score function that directly penalizes the cost of inference. specifically, we learn arithmetic circuits with a penalty on the number of edges in the circuit ( in which the cost of inference is linear ). our algorithm is equivalent to learning a bayesian network with context - specific independence by greedily splitting conditional distributions, directed at essentially each step scoring the candidates by compiling the resulting network into an arithmetic circuit, and using its size as the penalty. we show how this can be simply done efficiently, without compiling a circuit from scratch for each candidate. experiments on several real - world statistics domains show that our algorithm method is normally able to learn tractable models with very large treewidth, and continuously yields more accurate predictions than a standard context - specific bayesian network learner, in far less polynomial time.", "histories": [["v1", "Wed, 13 Jun 2012 15:38:26 GMT  (383kb)", "http://arxiv.org/abs/1206.3271v1", "Appears in Proceedings of the Twenty-Fourth Conference on Uncertainty in Artificial Intelligence (UAI2008)"]], "COMMENTS": "Appears in Proceedings of the Twenty-Fourth Conference on Uncertainty in Artificial Intelligence (UAI2008)", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["daniel lowd", "pedro domingos"], "accepted": false, "id": "1206.3271"}, "pdf": {"name": "1206.3271.pdf", "metadata": {"source": "CRF", "title": "Learning Arithmetic Circuits", "authors": ["Daniel Lowd"], "emails": ["lowd@cs.washington.edu", "pedrod@cs.washington.edu"], "sections": [{"heading": null, "text": "Graphical models are usually learned without regard to the cost of doing inference with them. As a result, even if a good model is learned, it may perform poorly at prediction, because it requires approximate inference. We propose an alternative: learning models with a score function that directly penalizes the cost of inference. Specifically, we learn arithmetic circuits with a penalty on the number of edges in the circuit (in which the cost of inference is linear). Our algorithm is equivalent to learning a Bayesian network with context-specific independence by greedily splitting conditional distributions, at each step scoring the candidates by compiling the resulting network into an arithmetic circuit, and using its size as the penalty. We show how this can be done efficiently, without compiling a circuit from scratch for each candidate. Experiments on several real-world domains show that our algorithm is able to learn tractable models with very large treewidth, and yields more accurate predictions than a standard context-specific Bayesian network learner, in far less time."}, {"heading": "1 INTRODUCTION", "text": "Bayesian networks are a powerful language for probabilistic modeling, capable of compactly representing very complex dependences. Unfortunately, the compactness of the representation does not necessarily translate into efficient inference. Networks with relatively few edges per node can still require exponential inference time. As a consequence, approximate inference methods must often be used, but these can yield poor and unreliable results. If the network represents manually encoded expert knowledge, this is perhaps inevitable. But when the network is learned from data, the cost of inference can potentially be greatly reduced, without compromising accuracy, by suitably directing the\nlearning process.\nBayesian networks can be learned using local search to maximize a likelihood or Bayesian score, with operators like edge addition, deletion and reversal (Heckerman et al., 1995). Typically, the number of parameters or edges in the network is penalized to avoid overfitting, but this is only very indirectly related to the cost of inference. Two edge additions that produce the same improvement in likelihood can result in vastly difference inference costs. In this case, it seems reasonable to prefer the edge yielding the lowest inference cost. In this paper, we propose a learning method that accomplishes this, by directly penalizing the cost of inference in the score function.\nOur method takes advantage of recent advances in exact inference by compilation to arithmetic circuits (Darwiche, 2003). An arithmetic circuit is a representation of a Bayesian network capable of answering arbitrary marginal and conditional queries, with the property that the cost of inference is linear in the size of the circuit. When contextspecific independences are present, arithmetic circuits can be much more compact than the corresponding junction trees. We take advantage of this by learning arithmetic circuits that are equivalent to Bayesian networks with contextspecific independence, using likelihood plus a penalty on the circuit size as the score function. Arithmetic circuits can also take advantage of other structural properties such as deterministic dependencies and latent variables; utilizing these in addition to context-specific independence is an important item of future work.\nPrevious work on learning graphical models with the explicit goal of limiting the complexity of inference falls into two main classes: mixture models with polynomialtime inference (e.g.: Meila and Jordan (2000); Lowd and Domingos (2005)) and graphical models with thin junction trees (e.g.: Srebro (2000); Chechetka and Guestrin (2008)). The former are limited in the range of distributions that they can compactly represent. The latter are computationally viable (at both learning and inference time) only for very low treewidths. Our approach can flexibly and compactly learn a wide variety of models, including models with very large\ntreewidth, while guaranteeing efficient inference, by taking advantage of the properties of arithmetic circuits.\nThe prior work most closely related to ours is Jaeger et al.\u2019s (2006). Jaeger et al. define probabilistic decision graphs, a new language related to binary decision diagrams. In contrast, we use standard arithmetic circuits, and our models are equivalent to standard Bayesian networks. Jaeger et al. speculate that learning arithmetic circuits directly from data would be very difficult. In this paper we propose one approach to doing this.\nThe remainder of our paper is organized as follows. In Sections 2 and 3, we provide background on Bayesian networks and arithmetic circuits, respectively. We describe in detail our algorithm for learning arithmetic circuits in Section 4. Section 5 contains our empirical evaluation on three real-world datasets, and we conclude in Section 6."}, {"heading": "2 BAYESIAN NETWORKS", "text": "A Bayesian network encodes the joint probability distribution of a set of n variables, {X1, . . . , Xn}, as a directed acyclic graph and a set of conditional probability distributions (CPDs) (Pearl, 1988). Each node corresponds to a variable, and the CPD associated with it gives the probability of each state of the variable given every possible combination of states of its parents. The set of parents of Xi, denoted \u03a0i, is the set of nodes with an arc to Xi in the graph. The structure of the network encodes the assertion that each node is conditionally independent of its non-descendants given its parents. The joint distribution of the variables is thus given by P (X1, . . . , Xn) = \u220fn i=1 P (Xi|\u03a0i).\nFor discrete domains, the simplest form of CPD is a conditional probability table. When the structure of the network is known, learning reduces to estimating CPD parameters. When the structure is unknown, it can be learned by starting with an empty or prior network and greedily adding, deleting and reversing arcs to optimize some score function (Heckerman et al., 1995). The score function is usually log-likelihood plus a complexity penalty or a Bayesian score (product of prior and marginal likelihood).\nThe goal of inference in Bayesian networks is to answer arbitrary marginal and conditional queries (i.e., to compute the marginal distribution of a set of query variables, possibly conditioned on the values of a set of evidence variables). One common method is to construct a junction tree from the Bayesian network and pass messages from the leaves of this tree to the root and back. A junction tree is constructed by connecting parents of the same variable, removing arrows, and triangulating the resulting undirected graph (i.e., ensuring that all cycles of length four or more have a chord). Each node in the junction tree corresponds to a clique (maximal completely connected subset of variables) in the triangulated graph. Ordering cliques by the\nhighest-ranked variable they contain, each clique is connected to a predecessor sharing the highest number of variables with it. The intersection of the variables in two adjacent cliques is called the separator of the two cliques. A junction tree satisfies two important properties: each variable in the Bayesian network appears in some clique with all of its parents; and if a variable appears in two cliques, it appears in all the cliques on the path between them (the running intersection property). The treewidth of a junction tree is one less than the maximum clique size. The complexity of inference is exponential in the treewidth. Finding the minimum-treewidth junction tree is NP-hard (Arnborg et al., 1987). Inference in Bayesian networks is #Pcomplete (Roth, 1996).\nBecause exact inference is intractable, approximate methods are often used, of which the most popular is Gibbs sampling, a form of Markov chain Monte Carlo (Gilks et al., 1996). A Gibbs sampler proceeds by sampling each nonevidence variable in turn conditioned on its Markov blanket (parents, children and parents of children). The distribution of the query variables is then approximated by computing, for each possible state of the variables, the fraction of samples in which it occurs. Gibbs sampling can be very slow to converge, and many MCMC variations have been developed, but choosing and tuning one for a given application remains a difficult, labor-intensive task. Diagnosing convergence is also difficult."}, {"heading": "2.1 LOCAL STRUCTURE", "text": "Table CPDs require exponential space in the number of parents of the variable. A more scalable approach is to use decision trees as CPDs, taking advantage of contextspecific independencies (i.e., a child variable is independent of some of its parents given some values of the others) (Boutilier et al., 1996; Friedman & Goldszmidt, 1996; Chickering et al., 1997). The algorithm we present in this paper learns arithmetic circuits that are equivalent to this type of Bayesian network.\nIn a decision tree CPD for variable Xi, each interior node is labeled with one of the parent variables, and each of its outgoing edges is labeled with a value of that variable.1 Each leaf node is a multinomial representing the marginal distribution of Xi conditioned on the parent variable values specified by its ancestor nodes and edges in the tree.\nThe following two definitions will be useful in describing our algorithm.\n1In general, each outgoing edge can be labeled with any subset of the variable\u2019s values, as long as the sets of labels assigned to all child edges include every variable value and are disjoint with each other. For simplicity, we limit our discussion to the case in which each edge has a single label, which Chickering et al. (1997) refer to as a complete split. For Boolean variables, as in our experiments, all types of splits are equivalent.\nDefinition 1. For leaf node D and k-valued variable Xj , the split S(D,Xj) replaces D with k new leaves, each conditioned on a particular value of Xj in addition to the parent values on the path to D. Definition 2. Let D be a leaf from the tree CPD for Xi. Split S(D,Xj) is valid iff Xj is not a descendant of Xi in the Bayesian network and no decision tree ancestor of D is labeled with Xj .\nThe first definition describes a structural update to the Bayesian network; the second one gives the conditions necessary for that update to be consistent and meaningful.\nA Bayesian network can now be learned by greedily applying the best valid splits according to some criterion, such as the likelihood of the data penalized by the number of parameters. This is one version of Chickering et al.\u2019s algorithm (1997). A number of other methods have also been proposed, such as merging leaves to obtain decision graphs (Chickering et al., 1997) or searching through Bayesian network structures and inducing decision trees conditioned on the global structure (Friedman & Goldszmidt, 1996)."}, {"heading": "3 ARITHMETIC CIRCUITS", "text": "The probability distribution represented by a Bayesian network can be equivalently represented by a multilinear function known as the network polynomial (Darwiche, 2003):\nP (X1 = x1, . . . , Xn = xn)\n= \u2211\nX\nn\u220f\ni=1\nI(Xi = xi)P (Xi = xi|\u03a0i = \u03c0i)\nwhere the sum ranges over all possible instantiations of the variables, I() is the indicator function (1 if the argument is true, 0 otherwise), and the P (Xi|\u03a0i) are the parameters of the Bayesian network. The probability of any partial instantiation of the variables can now be computed simply by setting to 1 all indicators consistent with the instantiation, and to 0 all others. This allows arbitrary marginal and conditional queries to be answered in time linear in the size of the polynomial.\nUnfortunately, the size of the network polynomial is exponential in the number of variables, but it can be more compactly represented using an arithmetic circuit. An arithmetic circuit is a rooted, directed acyclic graph whose leaves are numeric constants or variables, and whose interior nodes are addition and multiplication operations. The value of the function for an input tuple is computed by setting the variable leaves to the corresponding values and computing the value of each node from the values of its children, starting at the leaves. In the case of the network polynomial, the leaves are the indicators and network parameters. The arithmetic circuit avoids the redundancy present in the network polynomial, and can be exponentially more compact.\nEvery junction tree has a corresponding arithmetic circuit, with an addition node for every instantiation of a separator, a multiplication node for every instantiation of a clique, and an addition node as the root. Thus one way to compile a Bayesian network into an arithmetic circuit is via a junction tree. However, when the network contains context-specific independences, a much more compact circuit can be obtained. Darwiche (2003) describes one way to do this, by encoding the network into a special logical form, factoring the logical form, and extracting the corresponding arithmetic circuit."}, {"heading": "4 LEARNING ARITHMETIC CIRCUITS", "text": ""}, {"heading": "4.1 SCORING AND SEARCHING", "text": "Instead of learning a Bayesian network and then compiling it into a circuit, we induce an arithmetic circuit directly from data using a score function that penalizes circuits with more edges. The score of an arithmetic circuit C on an i.i.d. training sample T is\nscore(C, T ) = log P (T |C)\u2212 kene(C)\u2212 kpnp(C)\nwhere the first term is the log-likelihood of the training data, P (T |C) = \u220f X\u2208T P (X|C), ke \u2265 0 is the per-edge penalty, ne(C) is the number of edges in the circuit, kp \u2265 0 is the per-parameter penalty, and np(C) is the number of parameters in the circuit. The last two allow us to easily combine our inference-cost penalty with a more traditional one based on model complexity.\nWe use this formulation for simplicity; our algorithm would work equally well with a Bayesian Dirichlet score (Heckerman et al., 1995), with a prior of the form exp(\u2212kene(C) \u2212 kpnp(C)), since the computation of the marginal likelihood would be the same as in standard Bayesian network learning. Aside from its practical utility, a prior penalizing inference cost is meaningful if we believe the inference task being modeled can be carried out quickly, for example because humans do it. Either way, the main difficulty is that the penalty (or prior) is no longer node-decomposable, and repeatedly computing it might be very expensive. Reducing this cost is one of the key technical issues addressed in this paper.\nArithmetic circuits can be learned in the same way as Bayesian networks with local structure, by starting with an empty network and greedily applying the best splits, except that candidate structures are scored by compiling them into arithmetic circuits. However, compiling an arithmetic circuit can be computationally costly, and doing so for every candidate structure would be prohibitive. A better approach is to incrementally compile the circuit as splits are applied. Table 1 shows pseudo-code for this algorithm.\nThe algorithm begins by constructing the initial arithmetic\ncircuit C as a product of marginal distributions:\nC = \u220f\ni\n\u2211\nj\nI(Xi = xij)P (Xi = xij)\nThis initial circuit is equivalent to a Bayesian network with no edges. In each iteration, the algorithm greedily chooses and applies the best valid split, where split validity is defined according to the equivalent Bayesian network. Each split is scored by applying it to the current circuit and counting the edges and parameters.2 Learning ends when the algorithm reaches a local optimum, where no valid split improves the score."}, {"heading": "4.2 SPLITTING DISTRIBUTIONS", "text": "The key subroutine is SplitAC, which updates an arithmetic circuit without recompiling it from scratch. Given an arithmetic circuit C that is equivalent to a Bayesian network B and a valid split S(D,V ), SplitAC returns a modified circuit C \u2032 that is equivalent to B after applying split S(D,V ). We will use the following notation to refer to distributions, parameter nodes, and indicator nodes:\ndj: Parameter node corresponding to the jth probability in the multinomial distribution D.\nDi: Leaf distribution resulting from split S(D,V ) that replaces D when V = i.\ndij: Parameter node corresponding to the jth probability in Di.\nvi: Indicator node I(V = i). 2All model parameters are MAP estimates, using a Dirichlet prior with all hyperparameters \u03b1ijk = 1, where k ranges over the leaves of the decision tree for variable Xi.\nTable 2 contains pseudo-code for the splitting algorithm. It might at first appear that to split D on V it suffices to replace references to each dj with a sum of products,\u2211\ni dijvi. However, the resulting circuit would then be correct only when V is fixed to a particular value, and summing out V would produce inconsistent results. Intuitively, the circuit must maintain the running intersection property of the corresponding junction tree, so that no variable can take on different values in different subcircuits. SplitAC maintains a consistent probability distribution by preserving three properties, analogous to those defined by Darwiche (2002) for logical circuits.\nDefinition 3. For an arithmetic circuit, C:\nC is smooth if, for each addition node, all children are ancestors of indicator nodes for the same variables and pa-\nrameter nodes from distributions of the same variables.\nC is decomposable if, for each multiplication node, no two children are ancestors of indicator nodes for the same variable or parameter nodes from distributions of the same variable.\nC is deterministic if, for each addition node, there is a variable V such that each child is the ancestor of some non-empty set of indicator nodes for V , and their sets are disjoint.\nThe network polynomial for a Bayesian network contains one term for each configuration of its variables; each term includes exactly one indicator variable and one conditional probability parameter per variable. Intuitively, if C is not smooth, then some terms in the polynomial it computes may not have an indicator variable and a conditional probability parameter for every variable. If C is not decomposable, then some terms in the polynomial may have more than one indicator variable or conditional probability parameter for some variable. If C is not deterministic, then there may be multiple terms for the same set of indicator variables.\nDefinition 4. We define three special types of node in the circuit as follows:\nA D-ancestor is any leaf dj corresponding to a parameter of D, or any parent of a D-ancestor.\nA V -ancestor is any leaf vi corresponding to an indicator of V , or any parent of a V -ancestor.\nA mutual ancestor (MA) of D and V is a node that is both a D-ancestor and a V -ancestor, and has no child that is both a D-ancestor and a V -ancestor.\nNote that every MA must be a multiplication node, or the circuit would not be smooth. Furthermore, from decomposability, each MA must have exactly one D-ancestor child, nD, and one V -ancestor child, nV . Naively replacing dj with \u2211\ni dijvi would cause both nV and nD to be ancestors of vi, violating decomposability.\nTo avoid this, SplitAC duplicates the subcircuits between the MAs and the parameter nodes dj , and between the MAs and the indicator nodes vi, \u201cconditioning\u201d each copy on a different value of V . Each nV and nD are replaced by a new addition node, n+, that sums over products of vi and copies of nV and nD conditioned on vi. This duplication of subcircuits is the reason different splits can have widely different edge costs. We now describe the details of which nodes are duplicated and how they are connected.\nLet N be the set of all D-ancestors and V -ancestors that are also descendants of a mutual ancestor. These are all the nodes \u201cin between\u201d D and V that must agree on the value of V . For each value i in the domain of V , SplitAC creates a copy Ni of the nodes in N .\nLet ni \u2208 Ni be the copy of node n \u2208 N . SplitAC inserts edges from ni to its children as follows. If n has a child c \u2208 N , then it inserts an edge from ni to the corresponding copy ci. If n has a child c &\u2208 N , then it inserts an edge from ni to c. This minimizes node duplication by linking to existing nodes or copies whenever possible.\nA few additional changes are required for Ni to properly depend on vi. If ni \u2208 Ni has some parameter node dj as a child, SplitAC replaces it with dij . This is how the new leaf distributions, conditioned on V , are integrated into the circuit. Secondly, if ni has vi as a child, it should be omitted: every node in Ni will depend on vi, so this is redundant. Finally, if ni has a child that is an ancestor of some vj but not of vi, then that child is inconsistent with conditioning on vi and must be removed.\nFinally, SplitAC connects each mutual ancestor, m, to a sum over these copies. SplitAC removes the D-ancestor, nD, and the V -ancestor, nV , as children of m and replaces them with an addition node with one child for each value of V . The ith child of the addition node is a product of vi, the copy of nD from Ni, and the copy of nV from Ni. (If m was an ancestor of only certain values of V , the addition node sums only over those values.)\nIntuitively, the resulting circuit represents the correct probability distribution because D has been replaced with the split distributions Di, each conditioned on vi, and because the circuit satisfies the running intersection property, since all nodes between V and D now depend on V .\nTheorem 1. After each iteration of LearnAC, C computes the network polynomial of a Bayesian network constructed by starting with an empty network and applying the same splits that were applied to C up to that iteration.\nA proof sketch is in the appendix; a complete proof can be found in (Lowd & Domingos, 2008)."}, {"heading": "4.3 OPTIMIZATIONS", "text": "We now discuss optimizations necessary to make this algorithm practical for real-world datasets with many variables.\nConsider once again the high-level overview in Table 1. Scoring every possible circuit in every iteration would be very expensive. Choosing the split that leads to the best scoring circuit is equivalent to choosing the split that leads to the greatest increase in score, so we can store changes in score instead. The improvement in log-likelihood is not affected by other splits, and so this only needs to be computed once for each potential split. Unfortunately, the number of edges that a split adds to the circuit can increase or decrease due to other splits. For convenience, we will refer to the number of edges added by the application of a split as its edge cost.\nAs a simple example, consider a chain-structured junction\ntree of 5 variables: AB-BC-CD-DE-EF. If we add an arc from A to F, then A is added to every other cluster: ABABC-ACD-ADE-AEF. However, this also reduces the cost of adding an arc from A to E, since the two variables now appear together in a cluster. As a second example, suppose that we instead added an arc from B to F: AB-BC-BCDBDE-BEF. Now the cost of adding an arc from A to F is greatly increased, since adding a variable to a larger cluster costs more edges than adding a variable to a smaller cluster.\nEvaluating the edge cost of every potential split in every iteration is expensive. The number of potential splits is linear in the number of splits that have been performed so far, leading to a time complexity that is at least quadratic in the total number of splits. Further, computing the edge cost for a single candidate may be linear in the size of the current circuit. With a non-zero edge cost, circuit size tends to be linear in the number of iterations, leading to an O(n3) algorithm. While this is still polynomial, it makes learning models with thousands of splits intractable in practice.\nFortunately, most splits only change a fraction of edge costs. Determining exactly which costs need to be updated is difficult, but we can rule out many splits whose costs do not need to be updated using the following conservative rule. Applying one split may change the edge cost of another split S(D,V ) if the applied split changes a node that is an ancestor of D and not V , or of V and not D. This covers all nodes that lie between D or V and their mutual ancestors, and thus all nodes that are copied by the splitting procedure. An applied split changes a node when it copies that node or reduces the number of children it has. In practice, this single heuristic lets us avoid recomputing over 95% of the edge costs.\nAs an alternative to this optimization, we have found a heuristic that leads to even larger speed-ups, but at the cost of no longer being perfectly greedy. We noticed that when edge costs changed, they rarely decreased. If a split\u2019s last computed edge cost was always a valid lower bound on the true value, then we could ignore any split whose total estimated score was worse than the best split found so far in this iteration. This assumption is often not valid in practice, but it lets us learn models that are nearly as effective in an order of magnitude less time.\nTwo other optimizations combine well with either of the above to offer further gains. First, we can reduce the number of computations by placing potential splits in order of decreasing likelihood gain, so that we consider the splits with the highest possible scores first. Since the likelihood gain is an upper bound on the score gain, once the score of the best split found so far is greater than the next likelihood gain, this split is guaranteed to be the highest-scoring one overall.\nSecond, we can exit the edge calculation procedure once we know that the edge cost is sufficient to make the overall\nscore negative. It is also possible to exit once we know that the score of the current split will be worse than the best split so far, but this interferes with the other optimizations. If we only compute an upper bound on the score, we will often have to recompute the edge cost when the next iteration requires a slightly lower upper bound."}, {"heading": "5 EXPERIMENTS", "text": ""}, {"heading": "5.1 DATASETS", "text": "We evaluated our methods on three widely used realworld datasets. The KDD Cup 2000 clickstream prediction dataset (Kohavi et al., 2000) consists of web session data taken from an online retailer. Using the subset of Hulten and Domingos (2002), each example consists of 65 Boolean variables, corresponding to whether or not a particular session visited a web page matching a certain category. Anonymous MSWeb is visit data for 294 areas (Vroots) of the Microsoft web site, collected during one week in February 1998. It can be found in the UCI machine learning repository (Blake & Merz, 2000). EachMovie3 is a collaborative filtering dataset in which users rate movies they have seen. We took a 10% sample of the original dataset, focused on the 500 most-rated movies, and reduced each variable to \u201crated\u201d or \u201cnot rated\u201d. For KDD Cup and MSWeb, we used the training and test partitions provided with the datasets. For EachMovie, we randomly selected 10% of the data for the test set and used the remainder for training.\nBasic statistics for each dataset are shown in Table 3. Density refers to the fraction of non-zero entries across all examples and all variables."}, {"heading": "5.2 LEARNING", "text": "For each dataset, we randomly split the training data into tuning and validation sets, corresponding to 90% and 10% of the training data, respectively. All parameters were tuned by training models on the tuning data and selecting the parameter sets that led to the highest log likelihood of the validation set. Finally, models were retrained using the full training set. All experiments were run on CPUs with 4 GB of RAM running at 2.8 GHz.\n3Provided by Compaq at http://research.compaq.com/SRC/eachmovie/; no longer available for download, as of October 2004.\nWe used two versions of the algorithm for learning arithmetic circuits from Section 4: AC-Greedy, which guarantees that we pick the best split in each iteration, and ACQuick, which uses a heuristic to avoid recomputing edge costs but may sometimes choose worse splits. We varied the per-edge cost ke from 1.0 to 0.01. Not surprisingly, our models were most accurate on the validation set with low per-edge costs (0.01 or 0.02). We also tuned the perparameter cost kp. For KDD Cup, the best cost was 0.0; for MSWeb and EachMovie, the best costs were 1.0 for greedy ACs and 0.5 for quick ACs.\nWe used the WinMine Toolkit (Chickering, 2002) as a baseline. WinMine implements the algorithm for learning Bayesian networks with local structure described in Section 2 (Chickering et al., 1997), and has a number of other state-of-the-art features. We tuned WinMine\u2019s multiplicative per-parameter penalty \u03ba; the best values were: 1 (no penalty) for KDD Cup, 0.1 for MSWeb, and 0.01 for EachMovie. We looked into using thin junction trees as a second baseline, but they do not scale to datasets of these dimensions.\nA summary of the learned models appears in Table 4. For each dataset, we report the log-likelihood per example on the test data, the number of edges in the arithmetic circuit, the number of leaves across all decision trees, the average and maximum number of parents across all variables, the treewidth (estimated using a min-fill heuristic), the number of edges generated by compiling the Bayesian network using c2d4, and the training time. On each model for which c2d ran out of memory, we obtained a lower bound by compiling a model with fewer splits, obtained by halting the learning process early. We varied the number of splits until we found the most complex sub-model that could still be compiled, within 10 splits. For WinMine, the chosen sub-models had less than one quarter of the original splits.\nThe test-set log-likelihoods of the AC learners and WinMine are very similar, with WinMine having a slight edge. This is not surprising, given that WinMine is free to choose expensive splits. Perhaps more remarkable is that this freedom translates to very little improvement in likelihood. The difference in accuracy between quick and greedy ACs is negligible except in the case of EachMovie, where the greedy AC is actually less accurate because it did not converge in the allowed time (72h).\nNot surprisingly, WinMine is much faster than the AC learners. It is worth noting that the cost of learning is only incurred once, while the cost of inference is incurred many times. Also, the AC learner directly outputs an arithmetic circuit, while WinMine\u2019s Bayesian network would still have to be compiled into one, which can be very time-\n4Available at http://reasoning.cs.ucla.edu/c2d/. We also tried using the ACE package, but it does not support decision tree CPDs and, for our models, tabular CPDs would be prohibitively large.\nconsuming. Finally, the quick heuristic offers up to an order-of-magnitude speedup with similar accuracy; additional heuristics might offer additional improvements."}, {"heading": "5.3 INFERENCE", "text": "For each dataset, we used the test data to generate queries with varied numbers of randomly selected query and evidence variables. Each query asked the probability of the configuration of the query variables in the test example conditioned on the configuration of the evidence variables in the same test example.\nWe estimate inference accuracy as the mean log probability of the test examples\u2019s configuration across all test examples. This is an approximation (up to an additive constant) of the Kullback-Leibler divergence between the inferred distribution and the true one, estimated using the test samples. For KDD Cup and MSWeb, we generated queries from 1000 test examples; for EachMovie, we gen-\n5AC-Greedy did not finish running in the maximum allowed time of 72h. As a result, it has fewer edges and lower loglikelihood than AC-Quick.\nerated queries from all 593 test examples.\nFor the arithmetic circuits, we used exact inference. For the Bayesian networks learned using WinMine, we used Gibbs sampling. We initialized the sampler to a random state, ran it for a burn-in period, and then collected samples to estimate the probability of the queried marginal or conditional event. All estimates were smoothed by uniformly distributing a count of 1 across all states of the query variables. Since convergence is difficult to diagnose and may take prohibitively long, we ran Gibbs sampling in four scenarios: fast (one chain, 100 burn-in iterations, 1000 sampling iterations); medium (ten chains, 100 burn-in iterations, 1000 sampling iterations); slow (ten chains, 1000 burn-in iterations, 10,000 sampling iterations); and very slow (ten chains, 10,000 burn-in iterations, 100,000 sampling iterations).\nFigure 1 shows the relative accuracy of the different methods on each dataset. Per-variable query log-likelihood is on the y axis. In the graphs on the left, each query included 30% of the variables in the domain, conditioned on 0% to 50% of the domain variables as evidence. In the graphs on the right, the number of query variables varies from 10% to 50%, conditioned on 30% of the variables in the domain as evidence. Inference times (averaged over all queries) are listed in Table 5. Note that AC inference times are in milliseconds, while Gibbs inference times are in seconds.\nThe ACs were roughly one order of magnitude faster than the fastest runs of Gibbs sampling, and four orders of magnitude faster than the slowest. Except when the number of query variables is very small, the ACs also easily dominate even the slowest runs of Gibbs sampling on accuracy. Because of the approximate inference, the slightly higher test-set log-likelihood of WinMine\u2019s models does not translate into higher accuracy in answering queries. Presumably, given enough time Gibbs sampling will eventually catch up with the ACs in accuracy, but by then it will be many orders of magnitude slower. Further, Gibbs sampling (like other approximate inference methods) requires tuning for best results, and we can never be sure that it has converged. In contrast, the AC inference is reliable, the time it takes is predetermined, and the time is short enough for online or interactive use."}, {"heading": "6 CONCLUSION", "text": "In the past, work on learning and inference in graphical models has been largely separate. This has had the somewhat paradoxical result that much effort is often expended to learn accurate models, only to result in less accurate predictions when approximate inference becomes necessary. Our work seeks to ameliorate this by more closely integrating learning and inference. In particular, we presented an algorithm for learning arithmetic circuits by maximizing likelihood with a penalty on circuit size. This ensures efficient inference while still providing great modeling flexibility. In experiments on real-world domains, our algorithm outperformed standard Bayesian network learning on both accuracy of query answers and speed of inference.\nDirections for future work include: investigating other algorithms for learning arithmetic circuits; extending our approach to handle learning with missing data and hidden variables; applying it to Markov networks, continuous domains, and relational representations; etc."}, {"heading": "Acknowledgements", "text": "The authors wish to thank Mark Chavira, Adnan Darwiche, and Knot Pipatsrisawat for help applying c2d to our Bayesian networks. This research was partly funded by a Microsoft Research fellowship awarded to the first author, DARPA contracts NBCH-D030010/02000225, FA8750-07-D-0185, and HR0011-07-C-0060, DARPA grant FA8750-05-2-0283, NSF grant IIS-0534881, and ONR grant N-00014-05-1-0313. The views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the official policies, either expressed or implied, of DARPA, NSF, ONR, or the United States Government."}, {"heading": "APPENDIX: PROOF SKETCH FOR", "text": "THEOREM 1\nLemma 2. At every iteration of LearnAC, C is smooth, decomposable, and deterministic.\nThis can be proved by induction on the calls to SplitAC in each iteration. It is easy to verify that the initial circuit is smooth, decomposable, and deterministic. Verifying that these properties are preserved by each call to SplitAC involves a second induction over the structure of the circuit, working up from the leaf nodes. The proof can be found in Lowd and Domingos (2008).\nProof Sketch for Theorem 1. (By induction over the number of splits performed.) The initial circuit is a product of marginal distributions, equivalent to a Bayesian network with no arcs, so the base case is satisfied.\nAssuming the circuit C was equivalent to a Bayesian network B after the last iteration of LearnAC, we must demonstrate that, after applying split S(D,V ), the resulting circuit C \u2032 is equivalent to B with the split S(D,V ).\nFor an arithmetic circuit, C, we can construct the logical image of C by replacing addition with disjunction and multiplication with conjunction. In order to make the different values of each variable mutually exclusive, we replace indicator nodes vi with conjunctions of vi and the negation of every other vj for j &= i. We apply an analogous transformation to the conditional probability parameters for each variable.\nIt is straightforward to show that if C is a smooth, decomposable, and deterministic AC, then its logical image satisfies the equivalent properties of a logical circuit, as defined by Darwiche (2002).\nLet L be the logical image of C and L\u2032 be the logical image of C \u2032. From Lemma 2 and the discussion of logical images, we know that C, C \u2032, L, and L\u2032 are all smooth, deterministic, and decomposable.\nIt can be shown inductively that the models of L are the terms of the network polynomial for B. It can also be shown that exactly one indicator variable vi is true for each variable V in every model of L and L\u2032. This means that each logical circuit can be expressed as a disjunction over the values of V : L = \u2228i(vi\u2227L), L\u2032 = \u2228i(vi\u2227L\u2032). In every model of (vi \u2227 L), a node that is an ancestor of vj and not of vi is guaranteed to be false. (This can be shown using smoothness.) We can therefore remove links in (vi \u2227 L) to any such node from nodes in between MAs and V without affecting the truth value of the logical circuit.\nWe can also simplify (vi \u2227 L\u2032). For any MA in L\u2032, the new addition node (disjunction in L\u2032) can be replaced with its ith child since all other children are known to be false. The ith child is a conjunction of vi (already assumed to be true) and a copy of two children of the MA conditioned on vi. Since conjunction is associative, we can simplify the MA by linking it directly to the children of this conjunction rather than to the conjunction.\nHaving performed these simplifications, we can see that: (vi \u2227 L) is logically equivalent to (vi \u2227 L\u2032), except that parameters dj have been replaced with dij in (vi \u2227 L\u2032). Taking the disjunction over all vi, we can conclude that the models of L are identical to those of L\u2032, except that whenever dj and vi are true in a model of L, dij and vi are true in the corresponding model of L\u2032. This is sufficient to demonstrate that the models of L\u2032 are the terms of the network polynomial for B after applying split S(D,V ).\nSince L\u2032 is smooth, deterministic, and decomposable, by Theorem 1 from Darwiche (2002), C \u2032 computes the network polynomial of B with the split S(D,V )."}], "references": [{"title": "Complexity of finding embeddings in a k-tree", "author": ["S. Arnborg", "D.W. Corneil", "A. Proskurowski"], "venue": "SIAM J. Algebraic & Discrete Methods,", "citeRegEx": "Arnborg et al\\.,? \\Q1987\\E", "shortCiteRegEx": "Arnborg et al\\.", "year": 1987}, {"title": "Context-specific independence in Bayesian networks", "author": ["C. Boutilier", "N. Friedman", "M. Goldszmidt", "D. Koller"], "venue": "Proc. UAI-96", "citeRegEx": "Boutilier et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Boutilier et al\\.", "year": 1996}, {"title": "Efficient principled learning of thin junction trees", "author": ["A. Chechetka", "C. Guestrin"], "venue": null, "citeRegEx": "Chechetka and Guestrin,? \\Q2008\\E", "shortCiteRegEx": "Chechetka and Guestrin", "year": 2008}, {"title": "A Bayesian approach to learning Bayesian networks with local structure", "author": ["D. Chickering", "D. Heckerman", "C. Meek"], "venue": "Proc. UAI-97", "citeRegEx": "Chickering et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Chickering et al\\.", "year": 1997}, {"title": "The WinMine toolkit", "author": ["D.M. Chickering"], "venue": "(Tech. Rept. MSR-TR-2002-103). Microsoft,", "citeRegEx": "Chickering,? \\Q2002\\E", "shortCiteRegEx": "Chickering", "year": 2002}, {"title": "A logical approach to factoring belief networks", "author": ["A. Darwiche"], "venue": "Proc. KR-02", "citeRegEx": "Darwiche,? \\Q2002\\E", "shortCiteRegEx": "Darwiche", "year": 2002}, {"title": "A differential approach to inference in Bayesian networks", "author": ["A. Darwiche"], "venue": "J. ACM,", "citeRegEx": "Darwiche,? \\Q2003\\E", "shortCiteRegEx": "Darwiche", "year": 2003}, {"title": "Learning Bayesian networks with local structure", "author": ["N. Friedman", "M. Goldszmidt"], "venue": "Proc. UAI-96", "citeRegEx": "Friedman and Goldszmidt,? \\Q1996\\E", "shortCiteRegEx": "Friedman and Goldszmidt", "year": 1996}, {"title": "Mining complex models from arbitrarily large databases in constant time", "author": ["G. Hulten", "P. Domingos"], "venue": "Proc. KDD-02", "citeRegEx": "Hulten and Domingos,? \\Q2002\\E", "shortCiteRegEx": "Hulten and Domingos", "year": 2002}, {"title": "Learning probabilistic decision graphs", "author": ["M. Jaeger", "J. Nielsen", "T. Silander"], "venue": "Intl. J. Approx. Reasoning,", "citeRegEx": "Jaeger et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Jaeger et al\\.", "year": 2006}, {"title": "organizers\u2019 report: Peeling the onion", "author": ["R. Kohavi", "C. Brodley", "B. Frasca", "L. Mason", "Z. Zheng"], "venue": "KDD-Cup", "citeRegEx": "Kohavi et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Kohavi et al\\.", "year": 2000}, {"title": "Naive Bayes models for probability estimation", "author": ["D. Lowd", "P. Domingos"], "venue": "Proc. ICML-05", "citeRegEx": "Lowd and Domingos,? \\Q2005\\E", "shortCiteRegEx": "Lowd and Domingos", "year": 2005}, {"title": "Learning arithmetic circuits (Tech", "author": ["D. Lowd", "P. Domingos"], "venue": "Rept.). Dept. CSE,", "citeRegEx": "Lowd and Domingos,? \\Q2008\\E", "shortCiteRegEx": "Lowd and Domingos", "year": 2008}, {"title": "Learning with mixtures of trees", "author": ["M. Meila", "M. Jordan"], "venue": "J. Mach. Learn. Research,", "citeRegEx": "Meila and Jordan,? \\Q2000\\E", "shortCiteRegEx": "Meila and Jordan", "year": 2000}, {"title": "Probabilistic reasoning in intelligent systems", "author": ["J. Pearl"], "venue": null, "citeRegEx": "Pearl,? \\Q1988\\E", "shortCiteRegEx": "Pearl", "year": 1988}, {"title": "On the hardness of approximate reasoning", "author": ["D. Roth"], "venue": "Artif. Intel.,", "citeRegEx": "Roth,? \\Q1996\\E", "shortCiteRegEx": "Roth", "year": 1996}, {"title": "Maximum likelihood Markov networks: An algorithmic approach", "author": ["N. Srebro"], "venue": "Master\u2019s thesis,", "citeRegEx": "Srebro,? \\Q2000\\E", "shortCiteRegEx": "Srebro", "year": 2000}, {"title": "Let L be the logical image of C and L\u2032 be the logical image of C \u2032. From Lemma 2 and the discussion of logical images, we know", "author": ["L C"], "venue": null, "citeRegEx": "C et al\\.,? \\Q2002\\E", "shortCiteRegEx": "C et al\\.", "year": 2002}], "referenceMentions": [{"referenceID": 6, "context": "Our method takes advantage of recent advances in exact inference by compilation to arithmetic circuits (Darwiche, 2003).", "startOffset": 103, "endOffset": 119}, {"referenceID": 10, "context": ": Meila and Jordan (2000); Lowd and Domingos (2005)) and graphical models with thin junction trees (e.", "startOffset": 2, "endOffset": 26}, {"referenceID": 10, "context": ": Meila and Jordan (2000); Lowd and Domingos (2005)) and graphical models with thin junction trees (e.", "startOffset": 27, "endOffset": 52}, {"referenceID": 10, "context": ": Meila and Jordan (2000); Lowd and Domingos (2005)) and graphical models with thin junction trees (e.g.: Srebro (2000); Chechetka and Guestrin (2008)).", "startOffset": 27, "endOffset": 120}, {"referenceID": 2, "context": ": Srebro (2000); Chechetka and Guestrin (2008)).", "startOffset": 17, "endOffset": 47}, {"referenceID": 9, "context": "The prior work most closely related to ours is Jaeger et al.\u2019s (2006). Jaeger et al.", "startOffset": 47, "endOffset": 70}, {"referenceID": 14, "context": ", Xn}, as a directed acyclic graph and a set of conditional probability distributions (CPDs) (Pearl, 1988).", "startOffset": 93, "endOffset": 106}, {"referenceID": 0, "context": "Finding the minimum-treewidth junction tree is NP-hard (Arnborg et al., 1987).", "startOffset": 55, "endOffset": 77}, {"referenceID": 15, "context": "Inference in Bayesian networks is #Pcomplete (Roth, 1996).", "startOffset": 45, "endOffset": 57}, {"referenceID": 1, "context": ", a child variable is independent of some of its parents given some values of the others) (Boutilier et al., 1996; Friedman & Goldszmidt, 1996; Chickering et al., 1997).", "startOffset": 90, "endOffset": 168}, {"referenceID": 3, "context": ", a child variable is independent of some of its parents given some values of the others) (Boutilier et al., 1996; Friedman & Goldszmidt, 1996; Chickering et al., 1997).", "startOffset": 90, "endOffset": 168}, {"referenceID": 3, "context": "For simplicity, we limit our discussion to the case in which each edge has a single label, which Chickering et al. (1997) refer to as a complete split.", "startOffset": 97, "endOffset": 122}, {"referenceID": 3, "context": "A number of other methods have also been proposed, such as merging leaves to obtain decision graphs (Chickering et al., 1997) or searching through Bayesian network structures and inducing decision trees conditioned on the global structure (Friedman & Goldszmidt, 1996).", "startOffset": 100, "endOffset": 125}, {"referenceID": 3, "context": "This is one version of Chickering et al.\u2019s algorithm (1997). A number of other methods have also been proposed, such as merging leaves to obtain decision graphs (Chickering et al.", "startOffset": 23, "endOffset": 60}, {"referenceID": 6, "context": "The probability distribution represented by a Bayesian network can be equivalently represented by a multilinear function known as the network polynomial (Darwiche, 2003):", "startOffset": 153, "endOffset": 169}, {"referenceID": 5, "context": "Darwiche (2003) describes one way to do this, by encoding the network into a special logical form, factoring the logical form, and extracting the corresponding arithmetic circuit.", "startOffset": 0, "endOffset": 16}, {"referenceID": 5, "context": "SplitAC maintains a consistent probability distribution by preserving three properties, analogous to those defined by Darwiche (2002) for logical circuits.", "startOffset": 118, "endOffset": 134}, {"referenceID": 10, "context": "The KDD Cup 2000 clickstream prediction dataset (Kohavi et al., 2000) consists of web session data taken from an online retailer.", "startOffset": 48, "endOffset": 69}, {"referenceID": 8, "context": "Using the subset of Hulten and Domingos (2002), each example consists of 65 Boolean variables, corresponding to whether or not a particular session visited a web page matching a certain category.", "startOffset": 20, "endOffset": 47}, {"referenceID": 4, "context": "We used the WinMine Toolkit (Chickering, 2002) as a baseline.", "startOffset": 28, "endOffset": 46}, {"referenceID": 3, "context": "WinMine implements the algorithm for learning Bayesian networks with local structure described in Section 2 (Chickering et al., 1997), and has a number of other state-of-the-art features.", "startOffset": 108, "endOffset": 133}], "year": 2008, "abstractText": "Graphical models are usually learned without regard to the cost of doing inference with them. As a result, even if a good model is learned, it may perform poorly at prediction, because it requires approximate inference. We propose an alternative: learning models with a score function that directly penalizes the cost of inference. Specifically, we learn arithmetic circuits with a penalty on the number of edges in the circuit (in which the cost of inference is linear). Our algorithm is equivalent to learning a Bayesian network with context-specific independence by greedily splitting conditional distributions, at each step scoring the candidates by compiling the resulting network into an arithmetic circuit, and using its size as the penalty. We show how this can be done efficiently, without compiling a circuit from scratch for each candidate. Experiments on several real-world domains show that our algorithm is able to learn tractable models with very large treewidth, and yields more accurate predictions than a standard context-specific Bayesian network learner, in far less time.", "creator": "TeX"}}}