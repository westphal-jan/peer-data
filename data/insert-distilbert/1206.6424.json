{"id": "1206.6424", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "27-Jun-2012", "title": "Anytime Marginal MAP Inference", "abstract": "this paper presents a notable new anytime algorithm for avoiding the marginal map problem in graphical models. the algorithm is described in detail, its infinite complexity and convergence rate are mainly studied, citations and relations to previous formal theoretical results for the iteration problem are discussed. it is shown that the algorithm runs in polynomial - time if the underlying graph of the model has bounded tree - width, and that it provides guarantees to the lower and upper bounds obtained consistently within a fixed amount of computational resources. experiments with both real and synthetic generated models highlight its main characteristics \u2014 and show that it compares favorably against park and darwiche's systematic search, particularly in the limiting case of problems with many map variables and moderate tree - width.", "histories": [["v1", "Wed, 27 Jun 2012 19:59:59 GMT  (346kb)", "http://arxiv.org/abs/1206.6424v1", "Appears in Proceedings of the 29th International Conference on Machine Learning (ICML 2012)"]], "COMMENTS": "Appears in Proceedings of the 29th International Conference on Machine Learning (ICML 2012)", "reviews": [], "SUBJECTS": "cs.AI stat.ML", "authors": ["denis deratani mau\u00e1", "cassio polpo de campos"], "accepted": true, "id": "1206.6424"}, "pdf": {"name": "1206.6424.pdf", "metadata": {"source": "META", "title": "Anytime Marginal Maximum a Posteriori Inference", "authors": ["Denis Deratani Mau\u00e1", "Cassio Polpo de Campos"], "emails": ["denis@idsia.ch", "cassio@idsia.ch"], "sections": [{"heading": "1. Introduction", "text": "The maximum a posteriori (MAP) assignment problem consists in finding an assignment that maximizes the posterior probability of a given set of variables. To facilitate modeling, the model often includes latent variables that are neither to be maximized nor observed, but marginalized. It is this more general form of the problem (a.k.a. partial or marginal MAP) that we tackle in this paper. Moreover, we assume that the probability distribution is represented as a discrete graphical model, which allows for compactness.\nComputationally, this is a very hard problem. It is NPPP-hard even if all variables are binary, and NP-hard if either the underlying graph has bounded treewidth or there are no latent variables (Park & Darwiche, 2004). Also producing a provably good approximate solution is NP-hard, even if the treewidth of the underlying graph is bounded (Park & Darwiche, 2004). A positive result has recently been given by de Campos (2011), which derived a fully polynomial-time approximation scheme when both treewidth and number of states per variable are bounded.\nMAP assignment problems can be seen as a composition of two different tasks: the computation of marginal probabilities and the combinatorial search\nAppearing in Proceedings of the 29 th International Conference on Machine Learning, Edinburgh, Scotland, UK, 2012. Copyright 2012 by the author(s)/owner(s).\nover assignments. The former is responsible for evaluating the quality of a candidate assignment produced by the latter. When the marginal probability inference is tractable, standard combinatorial search approaches such as branch-and-bound for exact solutions and local search for approximate results have been used (Park & Darwiche, 2003; Yuan et al., 2004). When it is hard, researchers have resorted to loopy belief propagation algorithms (Liu & Ihler, 2011; Jiang et al., 2011) and factor decomposition (Meek & Wexler, 2011).\nIn this paper, we present a new anytime algorithm to perform marginal MAP inference in graphical models of bounded treewidth. The algorithm implements a clique-tree propagation scheme that propagates sets of factors instead of single factors. Efficiency is achieved by verifying sub-optimality locally. We show empirically that the algorithm compares well to the systematic search algorithm of Park & Darwiche (2003). We derive theoretical bounds for the error produced by the algorithm within a given amount of computational resources (time and memory), and show that this error can be made arbitrarily small with enough resources."}, {"heading": "2. Notation", "text": "A finite integer set {1, 2, . . . , n} is denoted by [n]. Random variables are represented by capital letters, e.g., X, Y , Z; real-valued functions by greek letters, e.g., \u03c6, \u03c8; sets by calligraphic letters, e.g., I=[3], P={\u03c6, \u03c8}, S = {I,P}; vectors in boldface, e.g., V = (X,Y, Z). The number of elements in a set X is denoted by |X |. We identify a variable with its sample space. Hence, the finite set of values a variable X can assume is also denoted by X. Given a vector of variables X = (X1, . . . , Xn), we write X =X1 \u00d7\u00b7 \u00b7 \u00b7 \u00d7 Xn to denote the space of configurations or assignments of the variables in X, where \u00d7 denotes the Cartesian product. We also identify a vector of variables to its joint sample space, so that the notation x \u2208 X is welldefined, and |X| denotes the number of assignments x\nto X and not the number of variables in the vector. For X = (X1, . . . , Xn) and I \u2286 [n], the notation XI denotes the vector (Xi)i\u2208I . We write xI to denote the vector (xi)i\u2208I obtained by projecting x \u2208 X onto XI .\nA factor \u03c6 over a vector of variables X=(X1, . . . , Xn) is a |X|-dimensional vector of non-negative real values. The value of the factor corresponding to a particular assignment x \u2208 X is denoted by \u03c6(x). Given an assignment z for a vector of variables X, the indicator factor \u03b4z assigns value one for x=z and zero for all others. Product and sum-marginalization of factors are defined as usual: (\u03c6\u03c8)(x) = \u03c6(xI)\u03c8(xJ ), for X=(X1, . . . , Xn), I\u222aJ =[n], \u03c6 defined over XI and \u03c8 defined over XJ ; (\u2211 XI \u03c6 ) (y)= \u2211\nx\u2208X \u03c6(x)\u03b4y(xI) for \u03c6 defined over X=(X1, . . . , Xn), I \u2286 [n] and y \u2208 XI .\nGiven a tree T over [n] and a root node r \u2208 [n], we say that a node p is the parent of a neighboring node i if p is closer to r than i, in which case, we say that i is a child of p. The parent and the children of a node i are denoted by pa(i) and ch(i), respectively. The set of descendants of i (i.e., its children, the children of its children, and so on) is denoted by de(i). Nodes containing no children are called leaves, and nodes containing at least one child are called internal."}, {"heading": "3. Graphical Models", "text": "Let X = (X1, . . . , Xn) be a vector of discrete random variables, J1, . . . ,Jm be a collection of index sets satisfying J1 \u222a\u00b7 \u00b7 \u00b7 \u222a Jm=[n], and P={\u03c61, . . . , \u03c6m} be a set of factors over vectors XJ1 , . . . ,XJm , respectively. We call P a graphical model if it specifies a joint probability distribution over assignments x \u2208 X by\nPr(X=x) = 1\nZ \u220f i\u2208[m] \u03c6i(xJi) ,\nwhere Z = \u2211\nX \u220f \u03c6\u2208P \u03c6 is a normalizing constant\nknown as the partition function. The graph in the left-hand side of Figure 1 depicts a graphical model.\nLet D and H be index sets partitioning the variables into decision and latent variables, respectively. The MAP assignment problem consists in finding\nd\u2217 = argmax d\u2208XD Pr(XD=d)\n= argmax d\u2208XD \u2211 h\u2208XH Pr(XD=d,XH=h)\n= argmax d\u2208XD \u2211 X \u220f i\u2208[m] \u03c6i \u220f j\u2208D \u03b4dj . (1)\nFor each fixed assignment d, we can represent the factorization in (1) by a new graphical model Pd =P \u222a\n\u22c3 j\u2208D{\u03b4dj}. The partition function of this new model\nsatisfies Zd = \u2211\nX \u220f i\u2208[m] \u03c6i \u220f j\u2208D \u03b4dj . This way, we\ncan re-state the MAP assignment problem as a search over graphical models Pd. Assume without loss of generality that D={1, . . . , d} and H={d+ 1, . . . , n}, and define Ki = {\u03c6i} for i = 1, . . . ,m, and Ki+m = {\u03b4xi : xi \u2208 Xi} for each decision i \u2208 D. Each combination of factors \u03c61, . . . , \u03c6m+d from sets K1, . . . ,Km+d, respectively, specifies the graphical model Pd corresponding to an assignment d. Let M= {{\u03c61, . . . , \u03c6m+d} : \u03c6i \u2208 Ki} denote all graphical models obtained in such a way. Finding a MAP assignment is equivalent to finding a graphical model P\u2217= argmaxP\u2208M \u2211 X \u220f \u03c6\u2208P \u03c6. An assignment d\u2217 is a MAP assignment iff it satisfies d\u2217=argmaxd\u2208XD \u220fm+d i=m+1 \u03c6i(di) for some optimal P\u2217.\nExample 1. Consider the graphical model in Figure 1, and assume that variables are binary, D={1, 2} and H= {3, 4}. We denote the values a binary variable Xi can assume by xi and x\u0303i, and reformulate this MAP assignment problem as a search over graphical models as follows. Let K1 = {\u03c61}, K2 = {\u03c62}, K3 = {\u03c63}, K4 = {\u03c64}, K5 = {\u03c65}, K6 = {\u03c66}, K7 = {\u03c67}, K8 = {\u03c68}, K9 = {\u03b4x1 , \u03b4x\u03031} and K10 = {\u03b4x2 , \u03b4x\u03032}. Each combination of factors \u03c61, . . . , \u03c610 \u2208 K1, . . . ,K10 corresponds to the graphical model induced by the assignment d = argmaxx \u03c69(x1)\u03c610(x2). Suppose that P\u2217 = {\u03c61, . . . , \u03c68, \u03b4x1 , \u03b4x\u03032} is a solution to argmaxP\u2208M \u2211 X1,X2,X3,X4 \u220f i\u2208[10] \u03c6i. Then d \u2217 = (x1, x\u03032) = argmaxd \u03b4x1(d1)\u03b4x\u03032(d2) is a MAP assignment."}, {"heading": "4. Clique-Tree Computation", "text": "Let T be a tree over [m], I1, . . . , Im be a collection of index sets satisfying I1 \u222a \u00b7 \u00b7 \u00b7 \u222a Im = [n] for some positive integer n. We call T a clique tree if for i = 1, . . . , n the subgraph obtained by removing from T all nodes j such that i /\u2208 Ij remains a tree. Clique trees\nare so called because the index sets usually represent the cliques in the triangulated underlying graph of a graphical model. Let P be a graphical model whose factors \u03c61, . . . , \u03c6k are defined over sets XJ1 , . . . ,XJk , respectively, and J1\u222a\u00b7 \u00b7 \u00b7\u222aJk=[n]. We say that T is a clique tree for P if for i = 1, . . . , k there is 1 \u2264 j \u2264 m such that Ji \u2286 Ij . In the following, we assume for ease of exposition and without loss of generality that if T is a clique tree for P then m = k and Ji \u2286 Ii for all i, which allows us to unambiguously associate each factor \u03c6i to the clique tree node i. The tree on the right-hand side in Figure 1 is a clique tree for the graphical model on the left.\nThe width of a clique tree is the cardinality of the largest index set minus one. For example, the width of the tree in Figure 1 is two. Since the complexity of algorithms that operate on clique trees is (at least) exponential in the tree width, one usually seeks to obtain a clique tree of low width. Finding a minimum-width clique tree for a given graphical model is an NP-hard problem, and one usually resorts to heuristics to obtain low-width trees.\nThe basic computation scheme with clique trees is the factor-elimination procedure in Algorithm 1, which computes the partition function of a graphical model P = {\u03c61, . . . , \u03c6m} associated to a clique tree T over [m].1 In the algorithm, we assume that each factor \u03c6i is assigned to node i in the clique tree (hence its associated index set Ji \u2286 Ii). In a nutshell, the algorithm roots the tree in an arbitrary node r, and then propagates messages from the leaves towards the root. For ease of exposition, we assume in line 5 that Ipa(r) =\u2205. The propagation of messages halts when the root receives a message from every child, in which case the partition function is obtained by Z =\u00b5r. The algorithm runs in O(msw+1) time, where s= maxi |Xi| is the maximum number of values a variable in the model can assume, and w=maxi |Ii| \u2212 1 is the width of the clique tree. Thus when the width w is bounded, the computations take polynomial time.\nLet h(i) = \u22c3 j\u2208de(i)\u222a{i} Ij \\ Ipa(i). It can be shown that for i = 1, . . . ,m the factor \u00b5i satisfies \u00b5i = \u2211 Xh(i) \u03c6i \u220f j\u2208de(i) \u03c6j (Koller & Friedman, 2009). Since h(r) = [n] by definition of clique trees, the correctness of the computations follows easily by applying this result to the root: Z=\u00b5r= \u2211 X \u220f i\u2208[m] \u03c6i. Hence, we can evaluate the quality of a candidate solution d to the MAP assignment problem by building a clique tree T for the corresponding graphical model Pd and then running factor-elimination, which produces\n1The name collect algorithm has also been used to describe the same algorithm.\nAlgorithm 1 factor-elimination Require: A clique tree T over a graphical model P Ensure: Z= \u2211 X \u220f \u03c6\u2208P \u03c6\n1: select a node r as root 2: label all nodes as inactive 3: while there is an inactive node i do 4: select an inactive node i with all children active 5: compute \u00b5i= \u2211 XIi\\Ipa(i) \u03c6i \u220f j\u2208ch(i) \u00b5j 6: label i as active 7: end while 8: Z=\u00b5r\nZd = \u2211\nX \u220f \u03c6\u2208Pd \u03c6. Note that the same clique tree\ncan be used to evaluate different candidates.\nExample 2. Consider the graphical model and clique tree in Figure 1 and assume again that variables are binary D = {1, 2} and H = {3, 4}. We can evaluate the assignment d = (x1, x\u03032) to (X1, X2) by replacing \u03c61 and \u03c62 with \u03c6 \u2032 1 = \u03c61\u03b4x1 and \u03c6 \u2032 2 = \u03c62\u03b4x\u03032 , respectively, and then running factor-elimination, which obtains Z(x1,x\u03032) = \u2211 X1,X2,X3,X4 \u220f8 i=1 \u03c6i\u03b4x1\u03b4x\u03032 \u221d Pr(X1 =x1, X2 = x\u03032).\nThe algorithm can be straightforwardly modified to find a MAP assignment when there are no latent variables (i.e., when H = \u2205) by substituting sums with maximizations in the computation of factors \u00b5i (Koller & Friedman, 2009). This naturally suggests an approach to the computation of MAP assignments in the presence of latent variables (i.e., when H 6= \u2205), which consists in redefining the factors \u00b5i so that latent variables are summed out while decision variables are maximized. A factor-max-elimination version of the algorithm thus obtains factors \u00b5i = maxXDi \u2211 XHi \u03c6i \u220f j\u2208ch(i) \u00b5j , where Di = (Ii \u2229 D) \\ Ipa(i) and Hi=(Ii \u2229 H) \\ Ipa(i). Variants of this procedure have recently been justified as an approximation by variational inference (Liu & Ihler, 2011; Jiang et al., 2011). These approaches retain the efficiency of message-passing algorithms, but produce only an upper bound to the real value, unless the root node r contains all decision variables. Enforcing the clique tree to contain a node over all decision variables results in an exponential complexity in the number of decision variables (Park & Darwiche, 2004), unless the factors in the root node are factorized (Meek & Wexler, 2011).\nAnother simple but often effective approach to the MAP assignment problem is to perform a search over the space of assignments, and to use factorelimination to evaluate candidate solutions. An upper bound for any partial assignment can be obtained by running factor-max-elimination, which poten-\nAlgorithm 2 factor-set-elimination Require: A clique tree T over the sets of factors K1, . . . ,Km and positive integers k1, . . . , km Ensure: Zl \u2264 Z\u2217 \u2264 Zu 1: select a node r as root and let \u03c3 be an empty\ndictionary 2: for all leaf node i do 3: let Mi be an empty set 4: for all \u03c6i \u2208 Ki do 5: add \u00b5i= \u2211 XIi\\Ipa(i)\n\u03c6i to Mi 6: set \u03c3(\u00b5i)\u2190 \u00b5i 7: end for 8: Li=prune(Mi, \u03c3i, ki) 9: end for\n10: label leaves as active and internal nodes as inactive 11: while there is an inactive node do 12: select an inactive node i whose children are all active 13: let Mi be empty sets 14: for all \u03c6i \u2208 Ki, \u00b5j \u2208 Lj , j \u2208 ch(i) do 15: add \u00b5i= \u2211 XIi\\Ipa(i) \u03c6i \u220f j\u2208ch(i) \u00b5j to Mi\n16: set \u03c3(\u00b5i)\u2190 \u2211 XIi\\Ipa(i) \u03c6i \u220f j\u2208ch(i) \u03c3(\u00b5j) 17: end for 18: Li=prune(Mi, \u03c3, ki) 19: label i as active 20: end while 21: Zl=max{\u00b5r : \u00b5r \u2208 Lr} 22: Zu=max{\u03c3(\u00b5r) : \u00b5r \u2208 Lr}\ntially narrows the search space. The algorithm of Park & Darwiche (2003), against which we compare the algorithm we devise here, builds on this idea."}, {"heading": "5. Propagating Sets", "text": "Recall from the previous section that we can compare the quality of different candidate solutions to the MAP assignment problem by running factor-elimination with the same clique tree structure but different indicator factors. More generally, let K1, . . . ,Km be a collection of sets of factors such that each P = {\u03c61, . . . , \u03c6m} obtained by selecting a factor \u03c6i from Ki, i = 1, . . . ,m, is a graphical model. Let P be a graphical model obtained in this way, and let T be a clique tree for this model. Then T is also a clique tree for any other graphical model induced byK1, . . . ,Km. This insight is the base of the factor-set-elimination procedure in Algorithm 2, which performs a search over the space of assignments while it propagates sets of factors over the clique tree.\nThe algorithm resembles factor-elimination, but\ninstead of propagating factors \u00b5i, it propagates sets of factors Li \u2286Mi={ \u2211 XIi\\Ipa(i) \u03c6i \u220f j\u2208ch(i) \u00b5j : \u03c6i \u2208 Ki, \u00b5j \u2208 Lj}. The elements \u03c3(\u00b5i) obtained in lines 6 and 16 are local upper bounds which we discuss later on. The pruning operations in lines 8 and 18 return a subset Li \u2286 Mi of cardinality ki and recompute the upper bounds \u03c3(\u00b5i) to account for the discarded elements. So, if ki \u2265 |Mi|, then the pruning operation returns Li=Mi. The algorithm outputs lower and upper bounds Zl and Zu, respectively, to the maximum partition function Z\u2217= max{ \u2211 X \u220f i\u2208[m] \u03c6i : \u03c6i \u2208 Ki} of a graphical model induced by the sets in the input. The following result shows the correspondence of factors \u00b5i computed by this algorithm to those computed with factor-elimination.\nTheorem 1. For i = 1, . . . ,m, any \u00b5i \u2208 Li satisfies \u00b5i = \u2211 Xh(i) \u03c6i \u220f j\u2208de(i) \u03c6j for some combination of \u03c6i \u2208 Ki and \u03c6j \u2208 Kj for all j \u2208 de(i).\nProof. First, note that the definition of \u00b5i in factorset-elimination is identical to the definition in factor-elimination. Assume the prunining operations are not performed, that is, that prune(Mi, \u03c3i, ki) returns Mi. Then it is not difficult to see that \u00b5i matches the computation in factor-elimination for some graphical model induced by K1, . . . ,Km. But since the pruning operation returns a subset of Mi, this holds also for any \u00b5i \u2208 Li.\nThe following result follows immediately from the above theorem.\nCorollary 1. Zl = \u2211\nX \u220f i\u2208[m] \u03c6i for some combina-\ntion of factors (\u03c61, . . . , \u03c6m) \u2208 K1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Km.\nIf the algorithm is run with factor sets K1, . . . ,Km that induce graphical models corresponding to different assignments to decision variables as explained in Section 3, the numbers Zl and Zu returned are lower and upper bounds for the MAP assignment probability Z\u2217=maxd Pr(XD=d). In fact, if ki= |Mi| for all i = 1, . . . ,m, the algorithm is equivalent to an exhaustive search over the space of assignments, and thus returns Zl = Z\n\u2217. Moreover, the value of Zl is actually achieved by some assignment, and hence denotes the value of a feasible solution. The assignment corresponding to Zl can be obtained by tracking back the indicator factors \u03b4i, i \u2208 D, that were propagated to generate the number \u00b5r=Zl.\nThe complexity of the algorithm is determined by the number of additions and multiplications needed to compute each factor \u00b5i in a set Mi plus the complexity of the pruning operation. Similarly to factorelimination, the complexity of computing each \u00b5i\nis O(msw+1). Let k be the maximum of k1, . . . , km and |K1|, . . . , |Km|. By design, each set Mi contains |Ki| \u220f j\u2208ch(i) |Lj | = |Ki| \u220f j\u2208ch(i) kj \u2264 kc elements, where c is the maximum number of neighbors of a node. Hence, the algorithm runs in O(kcmsw). If the clique tree given as input contains a bounded number of children for each node and bounded width, the algorithm runs in time polynomial in the inputs k1, . . . , km and K1, . . . ,Km. Note that for any given any graphical model of bounded treewidth we can obtain a clique tree of bounded width and bounded number of children per node (e.g., a binary clique tree)."}, {"heading": "5.1. Pruning", "text": "The pruning operations are responsible for reducing the size of the propagated sets, enabling efficient inference. The trade-off between the quality of the solution and the computation time is determined by the parameters k1, . . . , km in the input. In the following, we discuss how the pruning operations are implemented.\nConsider a set of factors \u00b5 (1) i , . . . , \u00b5 (k) i which we wish to discard to reduce the size of a set Mi produced during factor-set-elimination. Our first insight is that convex combinations can be safely removed, as they are certainly outperformed by some extrema.\nA factor \u00b5 (1) i is a convex combination of factors \u00b5 (2) i and \u00b5 (3) i if there is a real 0 \u2264 \u03bb \u2264 1 such that \u00b5 (1) i = \u03bb\u00b5 (2) i + (1 \u2212 \u03bb)\u00b5 (3) i . Given a set of factors Mi, we say that \u00b5i \u2208 Mi is an extreme if it is not a convex combination of any two other elements in the set. Nonextreme factors can be safely removed fromMi, as the following result shows.\nTheorem 2. Let \u00b5 (1) i , \u00b5 (2) i and \u00b5 (3) i be three different factors in a set Mi such that \u00b5(1)i is a convex combination of \u00b5\n(2) i and \u00b5 (3) i . Then any solution value \u00b5 (1) r\ndifferent from \u00b5 (2) r and \u00b5 (3) r , where \u00b5 (`) r is obtained by propagating \u00b5 (`) i up to the root, is not an optimal solution.\nProof. Let \u00b5 (1) j = \u2211 XIj\\Ip \u03c6j\u00b5 (1) i \u220f k\u2208ch(j)\\{i} \u00b5k, \u00b5 (2) j = \u2211 XIj\\Ip \u03c6j\u00b5 (2) i \u220f k\u2208ch(j)\\{i} \u00b5k and \u00b5\n(3) j =\u2211\nXIj\\Ip \u03c6j\u00b5\n(3) i \u220f k\u2208ch(j)\\{i} \u00b5k be factors in Mj ,\nwhere j = pa(i) and p = pa(j). Then \u00b5 (1) j is a convex combination of \u00b5 (2) j and \u00b5 (3) j . By induction in the nodes of the clique tree, we find that any number \u00b5 (1) r \u2208Mr obtained by propagating \u00b5(1)i up to the root is a convex combination of numbers \u00b5 (2) r and \u00b5 (3) r obtained by propagating \u00b5 (2) i and \u00b5 (3) i , respectively, up\nto the root. Hence, \u00b5 (1) r is necessarily (strictly) less than max{\u00b5(2)r , \u00b5(3)r }, which is less than or equal to the optimal solution Z\u2217.\nThere is also another condition between factors which if verified allows us to safely discard a factor from Mi. Let \u00b5(1)i and \u00b5 (2) i be two factors in Mi. We say that \u00b5 (2) i (weakly Pareto-)dominates \u00b5 (1) i , and write \u00b5 (2) i \u2265 \u00b5 (1) i , if \u00b5 (2) i (x) \u2265 \u00b5 (1) i (x) for all x \u2208 XIi\u2229Ipa(i) . As the following result shows, we can safely remove dominated factors.\nTheorem 3. Let \u00b5 (1) i and \u00b5 (2) i be two different factors in a set Mi such that \u00b5(2)i \u2265 \u00b5 (1) i . Then any solution \u00b5 (1) r 6=\u00b5(2)r , where \u00b5(`)r is obtained by propagating \u00b5(`)i up to the root, is not an optimal solution.\nProof. Let \u00b5 (1) j = \u2211 XIj\\Ip \u03c6j\u00b5 (1) i \u220f k\u2208ch(j)\\{i} \u00b5k and \u00b5 (2) j = \u2211 XIj\\Ip \u03c6j\u00b5 (2) i \u220f k\u2208ch(j)\\{i} \u00b5k be factors in Mj , where j = pa(i) and p = pa(j). Since the factors contain only nonnegative values, it follows that \u00b5 (2) j \u2265 \u00b5 (1) j . By induction in the nodes of the clique tree, we find that any number \u00b5 (1) r \u2208 Mr generated by propagating \u00b5 (1) i up to the root is dominated by a number \u00b5 (2) r obtained by propagating \u00b5 (2) i , and therefore (strictly) less than the optimal solution Z\u2217.\nThe pruning operation prune(Mi, \u03c3, ki) first discards non-extreme and dominated factors from Mi. Albeit accurate, these operations are seldom enough to produce a set Li whose cardinality is less than the desired ki. To be able to meet the cardinality constraint, we partition the remaining factors in Mi (after nonextreme and dominated elements have been removed) in ki clusters C(1)i . . . , C (ki) i , and obtain Li by selecting one representative factor \u00b5(`) i\nin each cluster C(`)i . These representatives are valid solutions in that they can be produced from combination of factors from the input sets. Hence, they provide attainable lower bounds for the optimal solution. To account for the (worst-case) errors introduced by the pruning operations we introduce upper bound factors \u03c3(\u00b5i) for each discarded factor \u00b5i \u2208 C(`)i \\ {\u00b5(`)i }. We first discuss how to obtain upper bounds for discarded factors.\nConsider a set of factors \u00b5 (1) i , . . . , \u00b5 (k) i which we intend to discard, and let \u00b5i be a factor such that \u00b5i(x) = max{\u00b5(1)i (x), . . . , \u00b5 (k) i (x)} for all x \u2208 XIi\u2229Ipa(i) . Then \u00b5i \u2265 \u00b5 (`) i for ` = 1, . . . , k, and it follows from Theorem 3 that any value \u00b5r obtained by propagating \u00b5i up to the root is greater than or equal to a solution\n\u00b5 (`) r obtained by propagating \u00b5 (`) i up to the root, for ` = 1, . . . , k. Thus, we can use the factor \u00b5i as an upper bound of the factors we wish to discard. We could introduce one upper bound for each discarded factor, but this would cause the propagation of an exponential number of upper bounds (therefore more than the limit ki). On the other extreme, we might produce a single upper bound for all factors discarded fromMi, but this would create too loose a bound. Instead, we generate and propagate one upper bound for each cluster. Let \u00b5(`)\ni be the representative of a clus-\nter C(`)i . To account for the removal of the elements in the cluster, we update the upper bound \u03c3(\u00b5(`)\ni ) to be\nmax{\u03c3(\u00b5i) : \u00b5i \u2208 C(`)i }. Figure 2 depicts the pruning of a set Mi = {\u00b5(1)i , \u00b5 (2) i , \u00b5 (3) i , \u00b5 (4) i , \u00b5 (5) i }, and the induced upper bounds. Let \u00b5 (`) r be a solution obtained by propagating the representative \u00b5(`) i\nof cluster C(`)i , and let \u03c3(\u00b5 (`) r ) be the corresponding propagated upper bound. Then it follows that \u00b5 (`) r \u2264 Z\u2217 \u2264 \u03c3(\u00b5(`)r ), where Z\u2217 is the optimal solution of the problem.\nThere still remains to decide how to select good representatives. To this end, we define the following divergence metric \u3008\u00b5(1)i , \u00b5 (2) i \u3009 that assesses the quality of \u201crepresenting\u201d a factor \u00b5 (1) i by a factor \u00b5 (2) i as \u3008\u00b5(1)i , \u00b5 (2) i \u3009=max{\u00b5 (1) i (x)/\u00b5 (2) i (x) : x \u2208 X}. The metric matches the worst-case (multiplicative) error in discarding \u00b5 (1) i while selecting \u00b5 (2) i as representative, that is \u00b5 (1) i \u2264 \u00b5 (2) i \u3008\u00b5 (1) i , \u00b5 (2) i \u3009. Note that the divergence is asymmetric, and that it is greater than one if and only if \u00b5 (1) i is not dominated by \u00b5 (2) i .\nGiven a set of representatives Vi={\u00b5(1)i , . . . , \u00b5 (ki) i } in Mi, we assign each factor \u00b5i \u2208 Mi to a cluster C(`)i such that \u3008\u00b5i, \u00b5(`)i \u3009 = minl\u2208[ki]\u3008\u00b5i, \u00b5 (`) i \u3009. The overall performance of the clustering can be conservatively measured by the largest divergence within a cluster:\n(Vi) = max `\u2208[ki] max{\u3008\u00b5i, \u00b5(`)i \u3009 : \u00b5i \u2208 C (`) i } . (2)\nIdeally, we would like to find a set Vi \u2286 Mi of ki representatives that obtains the minimum (Vi) over all sets. However, this would add an extra complexity to the computations. Instead, we use a greedy search that at each step attempts to replace a factor inMi\\Vi with a factor in Vi such that (Vi) is decreased.\nThe following result shows that the the solution found by the algorithm improves monotonically by improving the clusterings at any node of the clique tree. Theorem 4. The outputs Zl and Zu satisfy Zu \u2264 Zl \u220f i\u2208[m] (Vi).\nProof. Consider some inactive node i whose children j are all active, and assume by inductive hypothesis that for any \u00b5j \u2208 Lj it holds that \u03c3(\u00b5j) \u2264 \u00b5jej , where ej is defined as (Vj) \u220f k\u2208de(j) (Vk). Then any\n\u00b5i \u2208 Mi satisfies \u03c3(\u00b5i)= \u2211 XIi\\Ip \u03c6j \u220f j\u2208ch(i) \u03c3(\u00b5j) \u2264\u220f\nk\u2208de(i) (Vk)[ \u2211 XIi\\Ip \u03c6j \u220f j\u2208ch(i) \u00b5j ] = \u00b5iei/ (Vi), where p = pa(i) and \u00b5j \u2208 Lj . Let \u00b5i be the representative of a cluster Ci \u2286 Mi, with \u03c3(\u00b5i) = max{\u00b5i : \u00b5i \u2208 Ci}. It follows from (2) that \u03c3(\u00b5i) \u2264 (Vi)\u00b5i. After the clustering, the new upper bound assigned to \u00b5 i\nis (by design) given by \u00b5i = max{\u03c3(\u00b5i) : \u00b5i \u2208 Ci}, which satisfies \u00b5i \u2264 \u03c3(\u00b5i)ei/ (Vi) \u2264 ei\u00b5i.\nThe above result guarantees that the algorithm finds lower and upper bounds whose ratio is not worse than the product of the clustering quality measures\u220f i\u2208[m] (Vi). The quality of each cluster (Vi) can be improved by increasing the maximum allowed number of elements ki in the set. Since each set cannot have more than |K1|\u00b7 \u00b7 \u00b7 |Km| elements, the algorithm is guaranteed to converge to the optimum in finite time. In fact, each maximum set size ki needs only to be as high as the number of extrema and non-dominated factors in Mi, since these are shown to lead to exact computations. These remarks lead naturally to the anytime algorithm we present in the next section."}, {"heading": "6. Anytime Inference", "text": "An anytime algorithm is a procedure that can be interrupted at any time with a meaningful solution whose quality is a monotonic function of runtime. Hence, anytime algorithms allow a trade-off between computation time and quality of solutions.\nWe can easily transform factor-set-elimination into an anytime algorithm that continuously improve the lower and upper bounds by increasing the maximum set cardinalities k1, . . . , km. The procedure is described in Algorithm 3. The anytime algorithm starts by running factor-set-elimination with all maxi-\nAlgorithm 3 anytime-inference Require: A clique tree T over sets K1, . . . ,Km and integer c\n1: let k (0) 1 = 1, . . . , k (0) m = 1, Z (0) l =0 and Z (0) u =1 2: set t\u2190 0 3: while Z\n(t) l < Z (t) u and not interrupted do\n4: find the node i with highest (Vi) 5: run factor-set-elimination with\nk (t) 1 , . . . , k (t) m and let (Zl, Zu) be its output\n6: set Z (t+1) l = max{Zl, Z (t) l }, Z (t+1) u =\nmin{Zu, Z(t)u } and k(t+1)i =k (t) i + c, i = 1, . . . ,m\n7: set t\u2190 t+ 1 8: end while\nmum set cardinalities k (0) 1 , . . . , k (0) m set to one. This produces an arbitrary (but feasible) lower bound Z (0) l , and an upper bound Z (0) u that matches the value returned by factor-max-elimination. Then, for each time step, the algorithm increases the maximum set cardinality ki of the node i with poorest clustering quality (Vi) by a given constant c. In principle, even if we improve the clustering quality we might obtain a worse solution, as the metric that evaluates clustering quality optimizes worst case. This can be circumvented by enlarging each set Li incrementally."}, {"heading": "7. Experiments", "text": "We performed experiments with three groups of graphical models, which range from simple to very challenging problems. The first group, which appears in the top five lines of Table 1, consists of benchmark Bayesian networks used in real applications.2 In these networks, the MAP inference asks for optimum assignments of the root nodes given some evidence on every leaf. This creates MAP problems where every variable in the network is relevant to the solution and obtaining an exact solution by factor-max-elimination would take time (at least) exponential in the number of decision variables. The second group (lines 6\u20138 of the table) contains graphical models designed to solve multiple knapsack problems with three bags and varying number of items (20, 50 and 100). The graphs are structured in a chain of latent variables with root decision nodes as parents. Besides the importance of the multiple knapsack itself, this group allows us to evaluate the performance of the methods when the search space is large but the treewidth is low. Finally, the third group (last seven lines of the table) consists of grid-structured graphical models whose pa-\n2At the time of this submission, they were available at http://www.cs.huji.ac.il/site/labs/compbio/Repository/.\nrameters were uniformly sampled. Each Grid-x-y-z model contains x rows, y columns and z planes. For z = 2, variables are quaternary and the grid has two planes: one is the grid itself and the other is formed by decision variables that are linked to grid variables in a one-to-one correspondence; for z= 1, the models are usual planar binary grids, with all border variables chosen as decision variables. These experiments allow us to better evaluate how the performance is affected by the treewidth and the size of the search space.\nWe compare our algorithm against SamIam\u2019s implementation of the systematic search algorithm of Park & Darwiche (2003), which we refer to as SI. We chose SI because (i) it is a state-of-the-art algorithm, (ii) its implementation is publicly available, (iii) it is an anytime procedure, and (iv) it returns feasible solutions.\nTable 1 shows the results of the experiments, comparing the proposed method (named AFSE for short) and SI. The table presents names, total number of variables, number of decision variables, amount of time that SI and AFSE, respectively, spent to solve the instances, and errors of the obtained solution (in case one of the methods was unable to solve the instances in a reasonable amount of time and memory). The error corresponds to the worst of the two methods and it was obtained by calculating the ratio of the returned value and the optimum (the worst of the two methods can be identified in the columns corresponding to the time they spent, indicated by a \u201c> t\u201d, where t is the time-limit used for the given method).\nSome results from Table 1 deserve an additional discussion. Firstly, models in the second group and the two-plane grids of the third group of experiments in-\ndicate that AFSE is by far faster when treewidth is small. Still, SI was able to find the best solution in the models of the second group (even though it was not aware of it, so the search have not stopped), but clearly degrades in the two-plane grids, as can be seen in the error column of the table, which reaches 55% in Grid-4-30-2. This means that not only the algorithm did not finish but the best solution found was far from the optimum. Such situation justifies the use of methods that can provide anytime lower and upper bounds for the solution. Secondly, AFSE performed similarly to SI in (real) Bayesian networks, with the largest differences in the Barley and Pigs networks (the former favorable to SI, the latter favorable to AFSE). We see on the squared grids of the third group that SI can handle better the increase of treewidth, indeed a known characteristic of SI. The exception is Grid-1818-1, where SI exhausted the 8 GB of memory granted without being able to produce a (candidate) solution. Finally, the time-accuracy trade-off of the algorithms can be seen in Figure 3, which shows the accuracy of AFSE and SI on models Grid-4-30-2 and Grid-4-25-2 as a function of time. Lower and upper bounds converge to the optimal solution, and while SI starts with a better lower bound, it gets stuck in the search and does not converge within the allowed time."}, {"heading": "8. Conclusion", "text": "We present a new anytime algorithm for the marginal MAP assignment problem in graphical models. We show theoretically that the algorithm produces feasible solutions whose quality are a function of the amount of computational resources granted. The convergence and error bounds are analyzed.\nBy performing experiments with real and synthetic graphical models, we show that the proposed algorithm is competitive against the systematic search of Park & Darwiche (2003). In particular, our algorithm compares favorably when the problems exhibit moderate treewidth but large search space. Unfortunately, as the treewidth increases, the bounds returned by the algorithm become too loose. This could be mitigated by decomposing the propagated factors into smaller domains, as in the work of Meek & Wexler (2011).\nUnderstanding how the numerical parameters of the input affect the complexity of the algorithm is an important question that remains open. Finally, in the spirit of the result by de Campos (2011) it is possible to show that the anytime algorithm is also a fully polynomial-time approximation scheme for graphical models if we assume that both the treewidth and the number of values a variable can assume are bounded."}, {"heading": "Acknowledgments", "text": "This work was partially supported by the Swiss NSF grants no. 200020 134759/1 and 200020 132252."}], "references": [{"title": "New complexity results for MAP in Bayesian networks", "author": ["C.P. de Campos"], "venue": "In IJCAI", "citeRegEx": "Campos,? \\Q2011\\E", "shortCiteRegEx": "Campos", "year": 2011}, {"title": "Message-passing for approximate MAP inference with latent variables", "author": ["J. Jiang", "P. Rai", "III", "H. Daume"], "venue": "In NIPS", "citeRegEx": "Jiang et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Jiang et al\\.", "year": 2011}, {"title": "Probabilistic Graphical Models: Principles and Techniques", "author": ["D. Koller", "N. Friedman"], "venue": null, "citeRegEx": "Koller and Friedman,? \\Q2009\\E", "shortCiteRegEx": "Koller and Friedman", "year": 2009}, {"title": "Variational algorithms for marginal MAP", "author": ["Q. Liu", "A. Ihler"], "venue": "In UAI", "citeRegEx": "Liu and Ihler,? \\Q2011\\E", "shortCiteRegEx": "Liu and Ihler", "year": 2011}, {"title": "Approximating max-sumproduct problems using multiplicative error bounds", "author": ["C. Meek", "Y. Wexler"], "venue": "Bayesian Statistics,", "citeRegEx": "Meek and Wexler,? \\Q2011\\E", "shortCiteRegEx": "Meek and Wexler", "year": 2011}, {"title": "Solving MAP exactly using systematic search", "author": ["J.D. Park", "A. Darwiche"], "venue": "In UAI", "citeRegEx": "Park and Darwiche,? \\Q2003\\E", "shortCiteRegEx": "Park and Darwiche", "year": 2003}, {"title": "Complexity results and approximation strategies for MAP explanations", "author": ["J.D. Park", "A. Darwiche"], "venue": "JAIR, 21:101\u2013133,", "citeRegEx": "Park and Darwiche,? \\Q2004\\E", "shortCiteRegEx": "Park and Darwiche", "year": 2004}], "referenceMentions": [{"referenceID": 0, "context": "A positive result has recently been given by de Campos (2011), which derived a fully polynomial-time approximation scheme when both treewidth and number of states per variable are bounded.", "startOffset": 48, "endOffset": 62}, {"referenceID": 1, "context": "When it is hard, researchers have resorted to loopy belief propagation algorithms (Liu & Ihler, 2011; Jiang et al., 2011) and factor decomposition (Meek & Wexler, 2011).", "startOffset": 82, "endOffset": 121}, {"referenceID": 1, "context": "Variants of this procedure have recently been justified as an approximation by variational inference (Liu & Ihler, 2011; Jiang et al., 2011).", "startOffset": 101, "endOffset": 140}, {"referenceID": 0, "context": "Finally, in the spirit of the result by de Campos (2011) it is possible to show that the anytime algorithm is also a fully polynomial-time approximation scheme for graphical models if we assume that both the treewidth and the number of values a variable can assume are bounded.", "startOffset": 43, "endOffset": 57}], "year": 2012, "abstractText": "This paper presents a new anytime algorithm for the marginal MAP problem in graphical models of bounded treewidth. We show asymptotic convergence and theoretical error bounds for any fixed step. Experiments show that it compares well to a state-of-the-art systematic search algorithm.", "creator": "LaTeX with hyperref package"}}}