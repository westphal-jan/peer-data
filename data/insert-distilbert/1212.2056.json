{"id": "1212.2056", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-Dec-2012", "title": "Soft Constraint Logic Programming for Electric Vehicle Travel Optimization", "abstract": "soft structured constraint logic programming is a natural and flexible fully declarative programming formalism, which allows to continually model and solve real - life problems involving constraints of different types.", "histories": [["v1", "Mon, 10 Dec 2012 13:30:23 GMT  (20kb)", "http://arxiv.org/abs/1212.2056v1", "17 pages; 26th Workshop on Logic Programming - 2012"]], "COMMENTS": "17 pages; 26th Workshop on Logic Programming - 2012", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["giacoma valentina monreale", "ugo montanari", "nicklas hoch"], "accepted": false, "id": "1212.2056"}, "pdf": {"name": "1212.2056.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Giacoma Valentina Monreale", "Ugo Montanari", "Nicklas Hoch"], "emails": ["vale@di.unipi.it,", "ugo@di.unipi.it", "nicklas.hoch@volkswagen.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n21 2.\n20 56\nv1 [\ncs .A\nI] 1\n0 D\nIn this paper, after providing a slightly more general and elegant presentation of the framework, we show how we can apply it to the e-mobility problem of coordinating electric vehicles in order to overcome both energetic and temporal constraints and so to reduce their running cost. In particular, we focus on the journey optimization sub-problem, considering sequences of trips from a user\u2019s appointment to another one. Solutions provide the best alternatives in terms of time and energy consumption, including route sequences and possible charging events."}, {"heading": "1 Introduction", "text": "Classical constraint satisfaction problems (CSPs) [12] represent an expressive and natural formalism useful to specify different types of real-life problems. A CSP can be described as a set of variables associated with a domain of values, and a set of constraints. A constraint is a limitation of the possible combinations of the values of some variables. So, solving a CSP consists in finding an assignment of values to all its variables guaranteeing that all constraints are satisfied.\nDespite their applicability, the main limit suffered by CSPs is the ability of just stating if an assignment of certain values to the variables is allowed or not. This is indeed not enough to model scenarios where the knowledge is not either entirely available or not crisp. In these cases constraints are preferences and, when the problem is overconstrained, one would like to find a solution that is not so bad, i.e., the best solution according to the levels of preferences. For this reason, in [2,3], the soft CSP framework has been proposed. It extends classical constraints by adding to the usual notion of CSP the concept of a structure representing the levels of satisfiability or the costs of a constraint. Such a structure is represented by a semiring, that is, a set with two operations: one (usually denoted by +) is used to generate an ordering over the levels, while\n\u22c6 Research partially supported by the EU FP7-ICT IP ASCEns.\nthe other one (denoted by \u00d7) is used to define how two levels can be combined and which level is the result of such a combination.\nConstraint logic programming (CLP) [10] extends logic programming (LP) by embedding constraints in it: term equalities is replaced with constraints and the basic operation of LP languages, the unification, is replaced by constraint handling in a constraint system. It therefore inherits the declarative approach of LP, according to which the programmer specifies what to compute while disregarding how to compute it, by also offering efficient constraint-solving algorithms.\nHowever, only classical constraints can be handled in the CLP framework. So, in [4], it has been extended to also handle soft constraints. This has led to a highlevel and flexible declarative programming formalism, called Soft CLP (SCLP), allowing to easily model and solve real-life problems involving constraints of different types. Roughly speaking, SCLP programs are logic programs where constraints are represented by predicates which are defined by clauses whose body is a value of the semiring modelling the levels of satisfiability or the costs of the constraints. The flexibility of the approach is due to the fact that the same framework can be used to handle different kinds of soft constraints by simply choosing different semirings. It can indeed be used to handle fuzzy, probabilistic, prioritized and optimization problems, as well as classical constraints.\nIn this paper, before presenting an application of the SCLP framework to the e-mobility, we provide a slightly more general and elegant presentation of the SCSP framework based on the notion of named semiring, as briefly presented in [7]. In particular, soft constraints are elements of the named semiring which, besides the additive and multiplicative operations useful to combine the constraints, is equipped by a permutation algebra and a hiding operator allowing an explicit handling of names. The permutation algebra indeed allows to characterize the support of each constraint, that is, the subset of variables on which the constraint really depends, while the hiding operator allows us to remove variables from the support of a constraint. Then, the SCLP framework can be seen as the general case of the SCSP one.\nWe propose the SCLP framework as a high-level specification formalism useful to naturally model and also solve some e-mobility optimization problems. With e-mobility indeed new constraints must be considered: electric vehicles (EVs) have a limited range and they take long time to charge. So, it is needed to guarantee that throughout the user\u2019s itinerary the EV never underruns a limit energy level and that the user always arrives in time to all his appointments.\nWe consider the EV travel optimization problem described in [9]. In it the user has a set of appointments and he makes a series of decisions about the sequences of trips from an appointment to another one, for example which route to take, if and where to charge the EV and so on. The aim is to find the optimal combination of travel choices which minimizes the users cost criteria. In [9], the authors propose a hierarchical presentation of the mobility framework, which they exploit to decompose the optimization problem in sub-problems, and in particular, they study the journey level one. Here, beside it, we consider the optimization problem of the lower level, i.e., the one of the trip level. This last\nproblem consists in finding the best trips in terms of travel time and energy consumption, while the former one consists in finding the optimal journey, that is, the optimal sequence of coupled trips, again in terms of the same criteria, guaranteeing that the user reaches each appointment in time and that the state of charge (SoC) of the EV never falls below a given threshold.\nThe trip level problem substantially coincides with the multicriteria version of the shortest path problem modelled in [5] as an SCLP program. So, starting from a slightly different specification of this problem, we propose an SCLP program modelling the journey problem. In order to also actually execute both the SCLP programs, we propose CIAO Prolog [6], a system supporting constraint logic programming. We therefore explicitly implement the soft framework, by defining two predicates, the plus and the times ones, which respectively model the additive and the multiplicative operations of the semiring.\nThis work arises from the research activity in the European project ASCENS (Autonomic Service Component ENSembles) aiming at studying formal models, languages, and programming tools, for the modelling and the development of autonomous, self-aware adaptive systems. E-mobility is right one of the case studies of the project and our work represents a first answer to the need of a high-level, declarative, executable specification language and of a powerful and flexible programming environment where e-mobility problems can be easily and naturally modelled and solved. We indeed show as the SCLP framework is able to satisfy all these requirements and it can thus be used as a support for rapid prototyping and exploratory programming for this kind of problems.\nThe paper is organized as follows. Section 2 introduces the SCSP framework as an instantiation of the named semiring framework. Section 3 briefly recalls the SCLP language and then Section 4 shows how the trip and journey optimization problems can be modelled and solved through (S)CLP programs. Finally, Section 5 concludes the paper by illustrating some open venues for further works."}, {"heading": "2 Soft Constraints by means of Named Semirings", "text": "This section presents the soft CSP framework based on semiring [2,3] as an instantiation of the more general framework based on named semiring [7].\nThe notion of named semiring is based on the ones of c-semiring (c stands for constraint) and permutation algebra."}, {"heading": "2.1 C-Semiring", "text": "Definition 1 (c-semiring). A c-semiring is a tuple \u3008A,+,\u00d7, 0, 1\u3009 such that:\n\u2013 A is a set and 0, 1 \u2208 A; \u2013 + : A\u00d7A \u2192 A is a commutative, associative and idempotent operation, such\nthat 0 is its unit element and 1 is its absorbing element; \u2013 \u00d7 : A \u00d7 A \u2192 A is a commutative and associative operation, such that it\ndistributes over +, 1 is its unit element, and 0 is its absorbing element.\nThanks to the idempotence of the + operator, the relation \u3008A,\u2264\u3009, defined as a \u2264 b if a+ b = b, is a partial order. Intuitively, a \u2264 b means that b is better than a or that a implies b.\nIt is possible to prove that: (i) the two operations + and \u00d7 are monotone on \u2264; (ii) 0 is its minimum and 1 its maximum; (iii)\u3008A,\u2264\u3009 is a complete lattice and + is its least upper bound3. Finally, if \u00d7 is idempotent then: (iv)+ distribute over \u00d7; (v) \u3008A,\u2264\u3009 is a distributive lattice, and (vi) \u00d7 is its greatest lower bound."}, {"heading": "2.2 Permutation Algebra", "text": "Here we briefly recall the notion of permutation algebra. We refer the reader to [8] for a detailed introduction.\nIn the following, we fix a chosen infinite, countable, totally ordered set N of names, which we denote by x, y, z, . . . .\nDefinition 2 (Permutations). A name substitution is a function \u03c3 : N \u2192 N , while a permutation \u03c1 is a bijective name substitution. The set of all such permutations on N is denoted by P(N ).\nDefinition 3 (Kernel). Let \u03c1 \u2208 P(N ) be a permutation on N . The kernel of \u03c1 is the set of the names that are changed by the permutation, formally, K(\u03c1) = {x \u2208 N|\u03c1(x) 6= x}.\nA permutation \u03c1 is finite if its kernel is finite.\nFrom now on we consider only finite permutations. In the following, we introduce the notion of permutation algebra. It consists of a pair composed of a carrier set and a description of how the elements of the carrier set are transformed by permutations.\nDefinition 4 (Permutation Algebras). The permutation signature \u03a3p on N is defined as the set of unary operators {\u03c1\u0302|\u03c1 \u2208 P(N )} plus the two axioms\ni\u0302d(a) = a and \u03c1\u03021(\u03c1\u03022(a)) = \u03c1\u03021\u03c12(a). A permutation algebra A = (A, {\u03c1\u0302A}) consists of a carrier set A and the set of the interpreted operations \u03c1\u0302A.\nDefinition 5 (Support). Let A be a permutation algebra and a an element of its carrier set. The support of a, supp(a), is the smallest set of names such that, given a permutation \u03c1, if \u03c1(x) = x for all x \u2208 supp(a), then \u03c1\u0302A(a) = a.\nIntuitively, supp(a) represents the free names of a: indeed the permutations which do not modify them are not influent on a.\nDefinition 6 (Finitely supported algebra). A permutation algebra A is finitely-supported if each element of its carrier has finite support.\n3 Actually, in order to prove this result, we must assume that the sum of an infinite number of elements exists."}, {"heading": "2.3 Named c-Semiring.", "text": "A named semiring [7] is a c-semiring plus a finitely-supported permutation algebraA and a hiding operator (\u03bdx.). The permutation algebra allows characterizing the finite set of free names of each element c of the named semiring (represented by the support of c), while (\u03bdx.) applied to c makes the name x local in c.\nDefinition 7 (Fusion). A (name) fusion is a total equivalence relation on N with only finitely many non-singular equivalence classes. We denote by x = y the fusion with a unique non-singular equivalence class consisting of x and y.\nDefinition 8 (Named c-semiring). A named c-semiring C = \u3008C,+,\u00d7, \u03bdx., {\u03c1\u0302C}, 0, 1\u3009 is a tuple where:\n\u2013 x = y \u2208 C for x, y \u2208 N ; \u2013 \u3008C,+,\u00d7, 0, 1\u3009 is a c-semiring; \u2013 \u3008C, {\u03c1\u0302C}\u3009 is a finite-support permutation algebra; \u2013 \u03bdx. : C \u2192 C, for each name x, is a unary operation; \u2013 for all c, d \u2208 C and for all \u03c1 the following axioms hold:\n(FUSE) x = y \u00d7 c iff x = y \u00d7 [y/x]c (HIDE) \u03bdx.1 = 1 \u03bdx.\u03bdy.c = \u03bdy.\u03bdx.c \u03bdx.(c\u00d7 d) = c\u00d7 \u03bdx.d if x 6\u2208 supp(c) \u03bdx.(c + d) = c+ \u03bdx.d if x 6\u2208 supp(c) \u03bdx.c = \u03bdy.[y/x]c if y 6\u2208 supp(c) (PERM) \u03c1\u0302C0 = 0 \u03c1\u0302C1 = 1 \u03c1\u0302C(c\u00d7 d) = \u03c1\u0302Cc\u00d7 \u03c1\u0302Cd \u03c1\u0302C(c+ d) = \u03c1\u0302Cc+ \u03c1\u0302Cd\n\u03c1\u0302C(\u03bdx.c) = \u03bdx.(\u03c1\u0302Cc) if x 6\u2208 K(\u03c1)\nIn the (FUSE) axiom, [y/x]c denotes c where y is replaced by x."}, {"heading": "2.4 The Named SCSP Framework", "text": "As briefly shown in [7], named c-semirings can be suitably instantiated to model SCSPs.\nDefinition 9 (Constraints). Let S = \u3008A,+,\u00d7, 0, 1\u3009 be a c-semiring, N a set of totally ordered names, and D a finite domain of interpretation for N . A soft constraint is a function (N \u2192 D) \u2192 A, which associates a value of A to each assignment \u03b7 : N \u2192 D of the names.\nWe define C as the set of all soft constraints over N , D and A.\nDefinition 10. Let S = \u3008A,+,\u00d7, 0, 1\u3009 be a c-semiring, N a set of totally ordered names, and D a finite domain of interpretation for N . Moreover, let C be the set of all soft constraints over N , D and A. We define the CSCSP as the named c-semiring \u3008C,+\u2032,\u2297, \u03bdx., {\u03c1\u0302C}, 0\u2032, 1\u2032\u3009, where fusions x = y are defined as (x = y)\u03b7 = 1 if \u03b7(x) = \u03b7(y) and (x = y)\u03b7 = 0 otherwise; (c1 + \u2032 c2)\u03b7 = c1\u03b7 + c2\u03b7; (c1 \u2297 c2)\u03b7 = c1\u03b7 \u00d7 c2\u03b7; (\u03bdx.c)\u03b7 = \u2211\nd\u2208D(c\u03b7[d/x]); (\u03c1\u0302Cc)\u03b7 = c\u03b7 \u2032 with \u03b7\u2032(x) = \u03b7(\u03c1(x)); 0\u2032\u03b7 = 0 and 1\u2032\u03b7 = 1\u2032 for all \u03b7.\nThe assignment \u03b7[d/x] is defined as usual: \u03b7[d/x](y) = d if x = y and \u03b7[d/x](y) = \u03b7(y) otherwise.\nNote that, by definition, each constraint c \u2208 C involves all the names in N , but it really depends on the assignment of the names in supp(c), and intuitively, restricting means eliminating a name from the support of the constraint, by choosing the best value for it.\nDefinition 11 (Soft CSP). A soft constraint satisfaction problem (SCSP) is a pair \u3008C, Y \u3009, where C \u2286 C is a set of constraints and Y \u2286 N is a set of names.\nIntuitively, Y represents the set of interface names of the constraint set C.\nDefinition 12 (Solution). Let P = \u3008C, Y \u3009 be an SCSP. The solution of P is the constraint Sol(P ) = (\u03bdx1) . . . (\u03bdxn)( \u2297 C), with {x1, . . . , xn} =\u22c3\nci\u2208C supp(ci) \\ Y .\nDefinition 13 (Best level). Let P = \u3008C, Y \u3009 be an SCSP. Then, the best level of consistency of P is defined as the constraint blevel(P ) = (\u03bdx1) . . . (\u03bdxn)( \u2297 C), where {x1, . . . , xn} = \u22c3 ci\u2208C supp(ci).\nVarying the semiring S, on which the named semiring CSCSP is based, several kinds of problems can be represented: we consider the semiring SCSP = \u3008{true, false},\u2228,\u2227, false, true\u3009 for classical CSPs; SFCSP = \u3008{x|x \u2208 [0, 1]},max,min, 0, 1\u3009 for fuzzy CSPs; and SWCSP = \u3008N\u222a{+\u221e},min,+,+\u221e, 0\u3009 for optimization CSPs.\nExample 1. Let P be the SCSP with three names N = {x, y, z}, which can take values in D = {red, blue, green}. We assume that only x and y are of interest, while the constraints model the fact that all names must take different values.\nWe consider the semiring SWCSP , introduced above, and we define three constraints, one for each pair of names, cxy, cyz and czx, associating the worst semiring value to the assignments which give the same color to both the names of interest for the constraint. In particular, we associate +\u221e to all the assignments giving the same color to both names, if at most one name takes the color red then we associate 1, otherwise we associate 2.\nIn Horn logic this problem can be expressed as the predicate P (x, y) below: P (x, y) : \u2212Q(x, y), Q(y, z), Q(z, x) Q(v, w) : \u2212 if v = w then +\u221e else if either v or w are red then 1 else 2. The predicate Q(v, w) represents the constraint shown on the left of Fig. 1, where the names v and w represents the only names of the support. Note that in this representation we only show the assignment for the names of the support of the constraint. Therefore, each table entry actually represents different entries, one for each possible color of the names which are not in the support. The constraint representing the problem is then represented by the combination of three constraints. Indeed, Q(x, y), Q(y, z) and Q(z, x) respectively represent the three constraints cxy, cyz and czx, obtained by applying to the constraint represented by Q(v, w) the permutations mapping the names of the support v and w to the\nnames of interest of the three constraints. As said above, the relevant names of the problem are just x and y, thus the solution of the problem is obtained by combining the three constraints and restricting the scope of the name z. It can be expressed as (\u03bdz)(cxy \u2297 cyz \u2297 czx). The resulting constraint, represented by the predicate P (x, y), is shown on the right of Fig. 1. Also in this case, we show the assignment of just the two names of the support. Each table entry is the minimum value among the ones of the solutions providing a different color for z. In this case, the best level of solution is 4, the minimum over all the entries."}, {"heading": "3 Soft Constraint Logic Programming", "text": "This section briefly introduces the soft constraint logic programming (SCLP). For a more detailed and complete introduction, we refer the reader to [4].\nThe SCLP framework extends the classical constraint logic programming to also handle SCSPs. We can say that an SCLP program over a certain c-semiring S is just a CLP program where constraints are defined over S. In the following, we fix a semiring S = \u3008A,+,\u00d7, 0, 1\u3009.\nAn SCLP program is hence a set of clauses composed of a head and a body, plus a goal. The head of a clause is simply an atom, while the body can be either a collection of atoms, or a c-semiring value, or a special symbol \u2737, denoting that it is empty. In this two last cases clauses are called facts and define predicates representing constraints. When the body is empty, we interpret it as 1, the best element of the semiring. Atoms are n-ary predicate symbols followed by a tuple of n terms, which can be either a constant or a variable or an n-ary function symbol followed by n terms. Ground terms are terms without variables, and finally, a goal is a collection of atoms.\nExample 2. As an example, consider the simple SCLP program on the left of Fig. 2, previously proposed in [4]. We consider the semiring SKCSP and the domain D = {a, b, c}. The program is composed of six clauses. The last two are facts and the semiring values 2 and 3, associated respectively with the atoms\nt(a) and r(a), mean that they respectively cost 2 and 3 units. The set N of the semiring contains all possible costs, and the operations min and + allows us to minimize the sum of the costs. We consider as goal the atom :-s(a): later on we will show its semantics.\nThree equivalent semantics for the SCLP languages have been defined in [4]: the model-theoretic, the fix-point, and the operational one. These semantics are conservative extensions of the corresponding ones for logic programming: this means that by choosing the c-semiring SCSP we get exactly the LP semantics.\nActually, we can see the SCLP framework as the general case of the SCSP one. As shown in Example 1, we can indeed express an SCSP program as a set of predicates representing the constraints together with a unique clause which represents the problem and combines all constraints. In the case of the SCLP, the main difference is that the depth of clause nesting is unlimited and the possible values D of variables are elements of the Herbrand universe. So, the meaning of a predicate P (x, y) assigns a semiring value to all evaluations of variables x and y to the Herbrand domain. This is exactly what for example the fix-point semantics of the SCLP language does.\nIn order to present the fix-point semantics, we need to introduce the notion of interpretation and the TP operator, mapping interpretations into interpretations.\nDefinition 14 (Interpretation). An interpretation I consists of a domain D, representing the Herbrand universe, together with a function which takes a predicate and an instantiation of its arguments (that is, a ground atom), and returns an element of the semiring: I : \u22c3 n(Pn \u2192 (D\nn \u2192 A)), where Pn represents the set of n-ary predicates and A is the set of the values of the semiring.\nSince interpretations are functions from ground atoms to semiring values, we consider programs composed of clauses where the head and the body contain only ground atoms. So, for example, in the SCLP program of Example 2, the clause s(X) :- p(X,Y) is replaced with all its instantiations. In particular, for each d \u2208 D, we have three clauses s(d) :- p(d,a), s(d) :- p(d,b), and s(d) :- p(d,c).\nDefinition 15 (TP Operator). Let P be an SCLP program and ISP the set of all its interpretations. Moreover let I be an interpretation and GA a ground\natom, such that P contains k clauses defining the predicate in GA and the clause i is of the shape GA : \u2212Bi1, . . . , B i ni . Then, we define the operator TP : ISP \u2192\nISP as TP (I)(GA) = \u2211k i=1( \u220fni j=1 I(B i j)). Whenever B i j is a semiring value, its meaning I(Bij) is fixed in any interpretation I and it is the semiring value itself.\nDefinition 16 (Partial Order of Interpretations). Let P be a program and ISP the set of all its interpretations. We define the structure \u3008ISP , \u3009, where \u2200I1, I2 \u2208 ISP , I1 I2 if I1(GA) \u2264 I2(GA) for any ground atom GA, where \u2264 is the order induced by the semiring.\nNote that \u3008ISP , \u3009 is a complete partial order and its glb coincides with the glb operation in the lattice A (extended to interpretations). Since the function TP is monotone and continuous over this complete partial order, then TP has a least fix-point lfp(TP ) = glb({I|TP (I) I}) and it can be obtained by computing TP \u2191 \u03c9, i.e., by applying TP to the bottom of the partial order of interpretations, and then repeatedly applying it until a fix-point.\nExample 3. Consider again the SCLP program in Fig. 2. In the definition of the TP operator we have to consider the additive and multiplicative operations of the semiring SKCSP , that is, the min and + operations. As in [4], we start the computing of the semantics from the bottom of the partial order of interpretations, I0, which maps each semiring element into itself and each ground atom into +\u221e. The table on the right of Fig. 2 shows the value associated by the interpretations to the most interesting ground atoms. The interpretation I4 represents the fix-point of TP . As an example, we show the computation for one of the most interesting case, the ground atom s(a), which also corresponds to our goal. We said that the clause s(X) :- p(X,Y) is considered equivalent to all its instantiations. Therefore, I4(s(a)) = min{I3(p(a, a)), I3(p(a, b)), I3(p(a, c))} = min{+\u221e, 2, 3} = 2."}, {"heading": "4 The Electric Vehicle Travel Optimization Problem", "text": "This section presents the EV travel optimization problem, introduced in [9], and shows how it can be naturally modelled and solved in the SCLP framework.\nGeneral description of the problem. A user has a set of appointments, each of them is in a location and has a starting time and a duration. The user makes a series of decisions regarding the sequences of trips from an appointment to another one. For example, he decides which route he wants to follow, where to park and if and how to charge the EV at the appointment location.\nAll possible combinations of travel choices form the choice set. A travel choice is optimal if it minimizes the users cost criteria.\nIn particular, finding a single optimal trip consists in finding the best trips in terms of travel time and energy consumption. Finding instead the optimal journey, that is, the optimal sequence of coupled trips, consists in finding the best journeys not only in terms of travel time and energy consumption, but\nalso in terms of other important criteria for the user, such as the charging cost, the number of charging events, etc. However, in finding the solution it needs to guarantee that the user reaches each appointment in time and that the state of charge (SoC) of the vehicle never falls below a predefined threshold.\nIn [9], the authors propose a hierarchical presentation of the e-mobility framework, which they exploit to decompose the optimization problem in suboptimization problems. In particular, they identify four levels of mobility: the component level, whose main tasks are the inter- and intra-component coordination; the trip level, whose main task is the time and energy optimal routing; the journey level, which handles sequences of trips together with charging and parking strategies; and the mobility level, which handles mobility services, such as, car and ride service.\nEach level represents a different optimization problem and the results of the lower level will be inputs of the higher level. However, since, in general, the best solution of the lower level could be not optimal for the higher one, the results of the lower level could contains several solutions and not only the best one.\nIn the following, we consider only the trip level and the journey level optimization problems. In particular, we first present their formalization and then we show how we can model them in the SCLP framework.\nFormalizations of the trip and journey level optimization problems. The trip level optimization problem substantially coincides with the multicriteria shortest path problem. The road network is indeed represented by a directed graph G := (N,E), where each arc e \u2208 E from a node p to a node q has associated a label \u3008cT , cE\u3009, that is, a pair whose elements represent the costs, respectively in terms of time and energy consumption, of the arc from p to q.\nSo, given the road network G, such as the one on the left of Fig. 3, a source node ns and a destination node nd, the problem consists in finding all the best paths between ns and nd in terms of time and energy consumption. Note that, since the costs of the arcs are elements of a partially ordered set, the solution can contain several paths, that is, all paths which are not dominated by others, but which have different incomparable costs. For example, if we want to know the best paths from p to t in the graph of Fig. 3, the solution will contain both the paths {p, t} with cost \u30083, 9\u3009 and {p, q, t} with cost \u30084, 8\u3009. The former is indeed better in terms of time while the latter in terms of energy consumption.\nAs far as the journey level optimization problem is concerned, we use the formalization presented in [9]. Actually, we consider a simpler version of it, which avoids to consider car parks and the time that the users would take to go from either the car park or the charging station to the location of the appointment. Moreover, we consider only the time and energy consumption as cost criteria to be minimized. All these simplifications allows a slender and more readable presentation of the SCLP program modelling the problem.\nLet A = {A1, . . . , An} be the set of the user\u2019s appointments. In order to describe the problem, we use different time variables. All of them have the shape it Y Z , where i denotes the appointment, Y \u2208 {D,A} (D stands for drive and A for appointment), and Z \u2208 {S,E} (S stands for start and E for end).\nEach appointments is defined by a location Li, a starting time it A S , an end\ntime it A E and therefore a duration id A. In order to go from an appointment Ai to the next one Ai+1, the user leaves with an EV from the location Li at time it D S and drive to location Li+1. The user travels along the route alternative iRD (computed by the trip level problem), which consumes energy and hence reduces the SoC. Obviously, the chosen route must allow the user to arrive to destination with the SoC of his EV. We assume that the SoC always decreases during driving and increases during charging events4. The user arrives at it D E and the appointment starts at it A S . The user must arrive in time to the appointment, so it is required that it D E \u2264 it A S . During the appointment, it is also possible to schedule a charging event if the SoC of the EV is not enough to continue the journey. We assume to have a set of charging stations. Each of them is simply defined by its name CSname, the number of available charging spots SpotsNum, and the location L where it is.\nTherefore, given the road network G, a set of appointments, as the ones described in the table in the middle of Fig. 3, and a set of charging stations, as the ones in the rightmost table of Fig. 3, the problem consists in finding all the best journeys through all the appointment locations in terms of time and energy consumption. As for the travel optimization problem, also here the solution can contain several journeys, that is, all the non-dominated ones.\nSCLP programs for the optimization problems. In the following, we show how the SCLP framework can be used as a linguistic support and a high-level and flexible programming environment where naturally modeling and solving the two optimization problems presented above.\nAs far as the trip level optimization problem, we propose a slightly different version of the model proposed in [5] for the multi-criteria shortest path problem. So, as there, we consider an SCLP program over the c-semiring denoted PH(S) which, given a source node ns and a target node nd, allows us to obtain the set of the costs of all non-dominated paths from ns to nd.\n4 This is the typical behaviour of EVs, however, as explained in [9], in particular cases it might also increase during driving and decreases during charging.\nThe semiring PH(S) is obtained starting from a semiring S = \u3008A,+,\u00d7, 0, 1\u3009, which in our case is the one modelling the costs associated to each edge, i.e, S = \u3008N2,min\u2032,+\u2032, \u3008\u221e,\u221e\u3009, \u30080, 0\u3009\u3009, where min\u2032 and +\u2032 are the min and + operations extended to pairs. Indeed, in general we want to minimize the sum of each cost, but, since we want to obtain all the non dominated paths, we consider PH(S).\nGiven a semiring S, we define PH(S) = \u3008PH(A),\u228e,\u00d7\u2217, \u2205, A\u3009, where PH(A) is the Hoare Power Domain of A, that is, PH(A) = {S \u2286 A|x \u2208 S, y \u2264S x implies y \u2208 S}. These sets are isomorphic to those containing just the nondominated values, thus, in the following, we will use this more compact and efficient representation, where each element of PH(A) will represent the costs of all non-dominated paths from a node to another one. The top element of the semiring is the set A (its compact form is {1}, which in our example is {\u30080, 0\u3009}); the bottom element is the empty set; \u228e is the formal union that takes two sets and gives their union; \u00d7\u2217 takes two sets and produces another one obtained by multiplying (using the multiplicative operation of the original semiring, in our case +\u2032) each element of the first set with each element of the second one.\nNote that, in the partial order induced by the additive operation of this semiring, a \u2264PH(S) b intuitively means that for each element of a, there exists an element of b which dominates it (in the partial order of the original semiring).\nFollowing [5], in order to also really execute the SCLP program, we model the problem with a program in CIAO Prolog [6], a system supporting CLP, by explicitly implementing the soft framework. The program is shown in Fig. 4.\nHere we consider the road network presented in Fig. 3, so we have a set of clauses modelling it. In particular, we have a set of facts modelling all the edges\nof the graph. Each fact has the shape edge(ns, nd, [cT , cE ]), where ns represents the source node, nd represents the destination node and the pair [cT , cE ] represents the costs of the edge in term of time and energy. Note that, differently from what would happen in the pure SCLP framework, these facts (representing constraints) have the cost in the head of the clauses and not in the body. This is needed for implementing the soft framework, and in particular the two operations of the semiring.\nMoreover, there are two clauses path describing the structure of paths: the upper one models the base case, where a path is simply an edge, while the lower one represents the recursive case, where a path is an edge plus another path. The head of the path clauses has the following shape path(ns, nd, LN , LV , [cT , cE ], Lim), where ns and nd are respectively the source and destination nodes, LN is the list needed to remember, at the end, all the visited nodes of the path in the ordering of the visit, LV is the list of the already visited nodes needed to avoid infinite recursion where there are graph loops, [cT , cE ] is used to remember the cost of the path in terms of time and energy, and finally, Lim represents the maximum amount of energy that the EV can consume. It is used to retrieve only the paths with a total cost in terms of energy equal to or less than the passed value.\nThe times and plus clauses are useful to model the soft framework. In particular, the first clause is useful to model the multiplicative operation of the semiring allowing us to compose the global costs of the edges together, time with time and energy with energy. The plus predicate instead mimics the additive operation and it is useful to find the best, i.e. non-dominated, paths among all the possible solutions. The plus predicate is indeed used in the body of the paths clause, which collects all the paths from a given source node to a given destination node and returns the best solutions chosen with the help of the plus predicate. So, if we want to know the best paths, in the graph of Fig. 3, from p to t with a total cost in terms of energy consumption less than or equal to 10, we have to perform the CIAO query paths(p, t, 10, BestPaths), where the BestPaths variable will be instantiated with the list containing all the nondominated paths. In particular, for each of them, the list will contain the sequence of the nodes in the path and the total cost of the path in terms of time and energy. The output of the CIAO program for this query is shown in Fig. 5.\nNow, by using the SCLP program modelling the travel optimization problem, we can also show the one modelling the journey level problem. Also in this case, as before, we consider the PH(S) semiring and we propose a CIAO program, where we also model the soft framework. The CIAO program modelling the journey optimization problem is presented in Fig. 6.\nWe have a set of facts modelling the user\u2019s appointments and the charging stations. In particular, for each appointment Ai, there is a clause appointment(Li, it A S , id\nA), while for each charging station we have a clause chargingStation(CSname, SpotsNum,L).\nMoreover, there are four journey clauses describing the structure of journeys. The upper two represent the base case, while the other two represent the recursive case. The first clause models the case where a journey is simply a path with a cost in terms of energy less than or equal to the SoC of the EV. The second clause models the case where the SoC of the EV is not enough to do any path and so a charging event, incrementing the energy level, must be scheduled. The third journey clause represents the case where a journey is a path with a cost in terms of energy less than or equal to the SoC of the EV, plus another journey. Finally, the last clause models the recursive case where a charging event is needed. In all cases we check that the paths allow the user to arrive in time.\nThe head of the journey clauses has the shape journey(LL, LP , LChEv, [CT , CE ], SoC), where LL is the list of the locations of the appointments, LP is the list needed to remember, at the end, all the paths of the journey in the correct ordering, LChEv is the list needed to\nremember all the charging events needed to complete the journey, [CT , CE ] represents the cost of the journey in terms of time and energy, and finally, SoC represents the current energy level of the EV.\nTo make the program as readable as possible, we omit the predicates newSoC and timeSum, useful to respectively compute the new energy level of the EV after a charging event and the arriving time of the user to an appointment.\nThe plus clauses are useful to model the soft framework and they are very similar to the ones of the trip level problem. The only difference is that here we have to consider the charging events. Moreover, note that we reuse the times predicate defined in the CIAO program in Fig. 4.\nThe journeys clause collects all the journeys through a set of locations (the ones of the user\u2019s appointments) and returns the best solutions chosen with the help of the plus predicate. So, if we want to know the best journeys, in the graph of Fig. 3, through the locations where the user has the appointments, with an EV having an energy level equal to 10, we have to perform the CIAO Prolog query journeys([p, r, t], 10, BestJourneys), where p, r, t are the locations of the appointments and the BestJourneys variable will be instantiated with the list containing all the non-dominated journeys. In particular, for each of them, the list will contain the sequence of the paths of the journey, the total cost of the journey in terms of time and energy, and the list of the charging events, each of them described by the name of the charging station and its location. The output of the CIAO program for this query is shown in Fig. 7."}, {"heading": "5 Conclusion", "text": "In this paper we proposed the SCLP framework as a high-level declarative, executable specification notation to model in a natural way some aspects of the e-mobility optimization problem [9], consisting in coordinating electric vehicles in order to overcome both energetic and temporal constraints. In particular, we considered the trip and journey optimization sub-problems, consisting in finding respectively the energy- and time-optimal route from one destination to another one, and the optimal sequence of coupled trips, in terms of the same criteria, guaranteeing that the user reaches each appointment in time. For both the optimization problems, we provided an SCLP program in CIAO Prolog, by\nexplicitly implementing the soft framework, that is, the additive and the multiplicative operations of the chosen semiring. The former is a slight variant of the CIAO program proposed in [5, Section 4.4] to specify the multicriteria version of the shortest path problem. With respect to the program proposed there, here we implemented a different semiring, (also proposed in [5]), i.e., the one based on the Hoare Power Domain operator, which allowed us to obtain only the best (i.e. non-dominated) routes in terms of time and energy consumption. We thus provided an implementation of the two operations of this semiring, by defining two predicates modelling them. The SCLP program modelling the journey optimization problem then uses the trip optimization problem results as inputs. It is also based on the same semiring that, in this case, allowed us to find the best journeys in terms of the two cost criteria.\nAs said above, the soft framework is explicitly implemented into each CIAO program: there is for example a different plus predicate in each optimization program we have proposed. However, it would be interesting to study a general way to embed the soft framework in Ciao Prolog. Trivially, one could provide a library offering a more general implementation of the operations of the semiring of each type of problem. Most interestingly, one could instead think to provide a meta-level implementing more efficiently the soft framework.\nDifferently from our solution, which allows us to obtain the set of all the optimal journeys, in the mathematical model proposed in [9] a form of approximation is introduced, by considering an aggregated cost function to be optimized. Their goal is indeed to minimize this cost function, which considers different cost criteria: besides the travel time and the consumed energy, they also take into account the charging cost, the number of charging events, etc. In modelling the problem, here we introduced a simplification by considering just the two main cost criteria, that allows us a slender presentation of the work. However, it is obvious that the SCLP programs can be easily modified to also take into account several other cost criteria. On the other side, we preferred not to introduce any approximation of the solution, by instead returning all optimal journeys considered equivalently feasible. However, since the use of partially ordered structures, as in our case, can in general lead to a potentially exponential number of undominated solutions, sometimes it becomes crucial to keep the number of configurations as low as possible through some form of approximation allowing us to adopt a total order. In this case, the right solution could be to adopt a function that composes all the criteria in a single one and then to choose the best tuple of costs according to the total ordering that the function induces [5, Section 6.1].\nAs said above, our aim is mainly to propose the SCLP framework as an expressive and natural specification language to model optimization problems. We indeed think that not only problems representing an extension of the one treated here can be modelled by adapting the solution we presented easily enough, but that in general our approach can be followed to model hierarchical optimization problems. All the SCLP programs we proposed are effective only when data of small size are considered. We are indeed conscious that the proposed encodings cannot be used to really solve the problem on practical cases, but on the other\nside, we think that CIAO represents a powerful system programming environment allowing us not only to write declarative specifications but also to reason about them.\nIt is therefore clear that here we do not take care of the performances of the proposed programs and that our aim is not to compare the performance with existing algorithms solving these problems. We indeed leave as future work the study of how to improve the performance of our programs. In [5, Section 8], the authors show some possible solutions that could be used towards this end, such as tabling and branch-and-bound techniques (implementable for example in ECLiPSe [1]). We however would also like to study how our programs can take advantage of the use of dynamic programming techniques based, for example, on the perfect relaxation algorithm for CSPs [11].\nFinally, from a theoretical point of view, as future work, we plan to propose a more general framework based on named semiring, allowing us to give a unifying presentation of the SCSP and SCLP frameworks, providing an explicit handling of the names."}], "references": [{"title": "Constraint logic programming using Eclipse", "author": ["K.R. Apt", "M. Wallace"], "venue": "Cambridge University Press", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2007}, {"title": "Constraint solving over semirings", "author": ["S. Bistarelli", "U. Montanari", "F. Rossi"], "venue": "IJCAI (1). pp. 624\u2013630", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1995}, {"title": "Semiring-based constraint satisfaction and optimization", "author": ["S. Bistarelli", "U. Montanari", "F. Rossi"], "venue": "J. ACM 44(2), 201\u2013236", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1997}, {"title": "Semiring-based contstraint logic programming: syntax and semantics", "author": ["S. Bistarelli", "U. Montanari", "F. Rossi"], "venue": "ACM TOPLAS 23(1), 1\u201329", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2001}, {"title": "Unicast and multicast QoS routing with soft-constraint logic programming", "author": ["S. Bistarelli", "U. Montanari", "F. Rossi", "F. Santini"], "venue": "ACM TOCL 12(1), 5", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "The ciao prolog system", "author": ["F. Bueno", "D. Cabeza", "M. Carro", "M. Hermenegildo", "P. L\u00f3pez-Gar\u0107\u0131a", "G. Puebla"], "venue": "Reference manual. Tech. Rep. CLIP3/97.1, School of Computer Science, Technical University of Madrid (UPM)", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1997}, {"title": "Cc-pi: A constraint-based language for specifying service level agreements", "author": ["M. Buscemi", "U. Montanari"], "venue": "ESOP. LNCS, vol. 4421, pp. 18\u201332. Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "About permutation algebras, (pre)sheaves and named sets", "author": ["F. Gadducci", "M. Miculan", "U. Montanari"], "venue": "HOSC 19(2-3), 283\u2013304", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2006}, {"title": "Electric vehicle travel optimization - customer satisfaction despite resource constraints", "author": ["N. Hoch", "K. Zemmer", "B. Werther", "R.Y. Siegwarty"], "venue": "IEEE IVS", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2012}, {"title": "Constraint logic programming", "author": ["J. Jaffar", "J.L. Lassez"], "venue": "POPL. pp. 111\u2013119. ACM Press", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1987}, {"title": "Perfect relaxation in constraint logic programming", "author": ["U. Montanari", "F. Rossi"], "venue": "ICLP. pp. 223\u2013237", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1991}, {"title": "Foundations of constraint satisfaction", "author": ["E. Tsang"], "venue": "Computation in cognitive science, Academic Press", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1993}], "referenceMentions": [{"referenceID": 11, "context": "Classical constraint satisfaction problems (CSPs) [12] represent an expressive and natural formalism useful to specify different types of real-life problems.", "startOffset": 50, "endOffset": 54}, {"referenceID": 1, "context": "For this reason, in [2,3], the soft CSP framework has been proposed.", "startOffset": 20, "endOffset": 25}, {"referenceID": 2, "context": "For this reason, in [2,3], the soft CSP framework has been proposed.", "startOffset": 20, "endOffset": 25}, {"referenceID": 9, "context": "Constraint logic programming (CLP) [10] extends logic programming (LP) by embedding constraints in it: term equalities is replaced with constraints and the basic operation of LP languages, the unification, is replaced by constraint handling in a constraint system.", "startOffset": 35, "endOffset": 39}, {"referenceID": 3, "context": "So, in [4], it has been extended to also handle soft constraints.", "startOffset": 7, "endOffset": 10}, {"referenceID": 6, "context": "In this paper, before presenting an application of the SCLP framework to the e-mobility, we provide a slightly more general and elegant presentation of the SCSP framework based on the notion of named semiring, as briefly presented in [7].", "startOffset": 234, "endOffset": 237}, {"referenceID": 8, "context": "We consider the EV travel optimization problem described in [9].", "startOffset": 60, "endOffset": 63}, {"referenceID": 8, "context": "In [9], the authors propose a hierarchical presentation of the mobility framework, which they exploit to decompose the optimization problem in sub-problems, and in particular, they study the journey level one.", "startOffset": 3, "endOffset": 6}, {"referenceID": 4, "context": "The trip level problem substantially coincides with the multicriteria version of the shortest path problem modelled in [5] as an SCLP program.", "startOffset": 119, "endOffset": 122}, {"referenceID": 5, "context": "In order to also actually execute both the SCLP programs, we propose CIAO Prolog [6], a system supporting constraint logic programming.", "startOffset": 81, "endOffset": 84}, {"referenceID": 1, "context": "This section presents the soft CSP framework based on semiring [2,3] as an instantiation of the more general framework based on named semiring [7].", "startOffset": 63, "endOffset": 68}, {"referenceID": 2, "context": "This section presents the soft CSP framework based on semiring [2,3] as an instantiation of the more general framework based on named semiring [7].", "startOffset": 63, "endOffset": 68}, {"referenceID": 6, "context": "This section presents the soft CSP framework based on semiring [2,3] as an instantiation of the more general framework based on named semiring [7].", "startOffset": 143, "endOffset": 146}, {"referenceID": 7, "context": "We refer the reader to [8] for a detailed introduction.", "startOffset": 23, "endOffset": 26}, {"referenceID": 6, "context": "A named semiring [7] is a c-semiring plus a finitely-supported permutation algebraA and a hiding operator (\u03bdx.", "startOffset": 17, "endOffset": 20}, {"referenceID": 6, "context": "As briefly shown in [7], named c-semirings can be suitably instantiated to model SCSPs.", "startOffset": 20, "endOffset": 23}, {"referenceID": 0, "context": "Varying the semiring S, on which the named semiring CSCSP is based, several kinds of problems can be represented: we consider the semiring SCSP = \u3008{true, false},\u2228,\u2227, false, true\u3009 for classical CSPs; SFCSP = \u3008{x|x \u2208 [0, 1]},max,min, 0, 1\u3009 for fuzzy CSPs; and SWCSP = \u3008N\u222a{+\u221e},min,+,+\u221e, 0\u3009 for optimization CSPs.", "startOffset": 215, "endOffset": 221}, {"referenceID": 3, "context": "For a more detailed and complete introduction, we refer the reader to [4].", "startOffset": 70, "endOffset": 73}, {"referenceID": 3, "context": "2, previously proposed in [4].", "startOffset": 26, "endOffset": 29}, {"referenceID": 3, "context": "Three equivalent semantics for the SCLP languages have been defined in [4]: the model-theoretic, the fix-point, and the operational one.", "startOffset": 71, "endOffset": 74}, {"referenceID": 3, "context": "As in [4], we start the computing of the semantics from the bottom of the partial order of interpretations, I0, which maps each semiring element into itself and each ground atom into +\u221e.", "startOffset": 6, "endOffset": 9}, {"referenceID": 8, "context": "This section presents the EV travel optimization problem, introduced in [9], and shows how it can be naturally modelled and solved in the SCLP framework.", "startOffset": 72, "endOffset": 75}, {"referenceID": 8, "context": "In [9], the authors propose a hierarchical presentation of the e-mobility framework, which they exploit to decompose the optimization problem in suboptimization problems.", "startOffset": 3, "endOffset": 6}, {"referenceID": 8, "context": "As far as the journey level optimization problem is concerned, we use the formalization presented in [9].", "startOffset": 101, "endOffset": 104}, {"referenceID": 4, "context": "As far as the trip level optimization problem, we propose a slightly different version of the model proposed in [5] for the multi-criteria shortest path problem.", "startOffset": 112, "endOffset": 115}, {"referenceID": 8, "context": "4 This is the typical behaviour of EVs, however, as explained in [9], in particular cases it might also increase during driving and decreases during charging.", "startOffset": 65, "endOffset": 68}, {"referenceID": 1, "context": "edge(p,q,[2,4]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 3, "context": "edge(p,q,[2,4]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 1, "context": "edge(q,t,[2,4]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 3, "context": "edge(q,t,[2,4]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 1, "context": "edge(p,r,[2,7]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 6, "context": "edge(p,r,[2,7]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 2, "context": "edge(r,s,[3,3]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 2, "context": "edge(r,s,[3,3]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 2, "context": "edge(p,t,[3,9]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 8, "context": "edge(p,t,[3,9]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 0, "context": "edge(r,q,[1,1]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 0, "context": "edge(r,q,[1,1]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 0, "context": "edge(q,r,[1,1]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 0, "context": "edge(q,r,[1,1]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 0, "context": "edge(s,t,[1,1]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 0, "context": "edge(s,t,[1,1]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 3, "context": "edge(q,s,[4,8]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 7, "context": "edge(q,s,[4,8]).", "startOffset": 9, "endOffset": 14}, {"referenceID": 4, "context": "Following [5], in order to also really execute the SCLP program, we model the problem with a program in CIAO Prolog [6], a system supporting CLP, by explicitly implementing the soft framework.", "startOffset": 10, "endOffset": 13}, {"referenceID": 5, "context": "Following [5], in order to also really execute the SCLP program, we model the problem with a program in CIAO Prolog [6], a system supporting CLP, by explicitly implementing the soft framework.", "startOffset": 116, "endOffset": 119}, {"referenceID": 8, "context": "In this paper we proposed the SCLP framework as a high-level declarative, executable specification notation to model in a natural way some aspects of the e-mobility optimization problem [9], consisting in coordinating electric vehicles in order to overcome both energetic and temporal constraints.", "startOffset": 186, "endOffset": 189}, {"referenceID": 4, "context": "With respect to the program proposed there, here we implemented a different semiring, (also proposed in [5]), i.", "startOffset": 104, "endOffset": 107}, {"referenceID": 8, "context": "Differently from our solution, which allows us to obtain the set of all the optimal journeys, in the mathematical model proposed in [9] a form of approximation is introduced, by considering an aggregated cost function to be optimized.", "startOffset": 132, "endOffset": 135}, {"referenceID": 0, "context": "In [5, Section 8], the authors show some possible solutions that could be used towards this end, such as tabling and branch-and-bound techniques (implementable for example in ECLiPSe [1]).", "startOffset": 183, "endOffset": 186}, {"referenceID": 10, "context": "We however would also like to study how our programs can take advantage of the use of dynamic programming techniques based, for example, on the perfect relaxation algorithm for CSPs [11].", "startOffset": 182, "endOffset": 186}], "year": 2012, "abstractText": "Soft Constraint Logic Programming is a natural and flexible declarative programming formalism, which allows to model and solve real-life problems involving constraints of different types. In this paper, after providing a slightly more general and elegant presentation of the framework, we show how we can apply it to the e-mobility problem of coordinating electric vehicles in order to overcome both energetic and temporal constraints and so to reduce their running cost. In particular, we focus on the journey optimization sub-problem, considering sequences of trips from a user\u2019s appointment to another one. Solutions provide the best alternatives in terms of time and energy consumption, including route sequences and possible charging events.", "creator": "LaTeX with hyperref package"}}}