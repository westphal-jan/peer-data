{"id": "1301.1390", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jan-2013", "title": "Eliminating Unfounded Set Checking for HEX-Programs", "abstract": "hex - programs are an extension of attempting the answer set programming ( asp ) paradigm theoretically incorporating external means of computation into the declarative programming presentation language through so - called external atoms. their semantics is defined in terms strictly of minimal models of the classical faber - leone - gesellschaft pfeifer ( flp ) reduct. developing native solvers for hex - programs based on an assumed appropriate notion query of unfounded sets has been subject to recent research for reasons of efficiency. although this has lead to an improvement externally over naive minimality equivalence checking projects using the flp reduct, testing query for foundedness remains a computationally expensive task. in understanding this work piece we improve on hex - program evaluation in this respect by appropriately identifying a semantic syntactic class of programs, that can be efficiently recognized and merely allows to entirely skip exactly the foundedness deficiency check. moreover, we develop criteria for decomposing a program into components, such that the search for unfounded sets can be uniquely restricted. observing that our results apply separately to almost many hex - program applications provides analytic evidence for the significance and effectiveness of our approach, which is complemented by a brief discussion of preliminary experimental validation.", "histories": [["v1", "Tue, 8 Jan 2013 02:29:22 GMT  (38kb,D)", "http://arxiv.org/abs/1301.1390v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2012), 5th International Workshop, September 4, 2012, Budapest, Hungary", "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["thomas eiter", "michael fink", "thomas krennwallner", "christoph redl", "peter sch\\\"uller"], "accepted": false, "id": "1301.1390"}, "pdf": {"name": "1301.1390.pdf", "metadata": {"source": "CRF", "title": "Eliminating Unfounded Set Checking for HEX-Programs", "authors": ["Thomas Eiter", "Michael Fink", "Thomas Krennwallner", "Christoph Redl", "Peter Sch\u00fcller"], "emails": ["eiter@kr.tuwien.ac.at", "fink@kr.tuwien.ac.at", "tkren@kr.tuwien.ac.at", "redl@kr.tuwien.ac.at", "ps@kr.tuwien.ac.at"], "sections": [{"heading": null, "text": "Keywords: Answer Set Programming, Nonmonotonic Reasoning, Unfounded Sets, FLP Semantics"}, {"heading": "1 Introduction", "text": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15]. However, recent developments in computing, in which context awareness, distribution and heterogeneous information sources gain importance, raised the need for access to external sources in programs, be it in the context of the Web to access web services, databases, or ontological information in different formats, in the context of agents to acquire sensor input, etc.\nTo cater for this need, HEX-programs [11] extend ASP with so called external atoms, through which the user can couple any external data source with a logic program. Roughly, such atoms pass information from the program, given by predicate extensions, ? This research has been supported by the Austrian Science Fund (FWF) project P20840, P20841,\nP24090, and by the Vienna Science and Technology Fund (WWTF) project ICT08-020.\nar X\niv :1\n30 1.\n13 90\nv1 [\ncs .L\nO ]\n8 J\nan 2\n01 3\ninto an external source which returns output values of an (abstract) function that it computes. This extension has been utilized for a range of applications, including querying data and ontologies on the Web, multi-context reasoning, and reasoning about actions and planning, to mention a few (cf. [5]). Notably, recursive data exchange between the rules and the external sources is supported, which makes the formalism powerful.\nThe semantics of a HEX-program \u03a0 is defined in terms of answer sets based on the FLP reduct [14]: an interpretation A is an answer set of \u03a0 , if and only if it is a \u2286-minimal model of the FLP-reduct f\u03a0A of \u03a0 wrt. A, which is the set of all rules whose body is satisfied by A. For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of f\u03a0A, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.\nThe evaluation of a HEX-program \u03a0 in the DLVHEX1 solver proceeds in two steps as follows. In Step 1, external atoms are viewed as ordinary atoms (replacement atoms) and their truth values are guessed by choice rules that are added. The resulting ordinary ASP program \u03a0\u0302 is then evaluated by an ordinary ASP solver and each of its answer sets A\u0302 is checked against the external sources, i.e., the guess is verified. After that, the guess for the non-replacement atoms, called A, is known to be a model of \u03a0 , and thus also of the reduct f\u03a0A. Step 2 then checks whether A is a \u2286-minimal model or, equivalently, whether A is unfounded-free [13], i.e., there exists no unfounded set (UFS) of \u03a0 wrt. A.\nUnfortunately, Step 2 is computationally expensive in general, and it is intractable even for Horn programs with nonmonotonic external atoms of polynomial complexity, as follows from results in [14]. It is thus worthwhile to be aware of cases where this test is tractable, or even better, superfluous such that Step 2 can be skipped.\nMotivated by this issue, we consider in this paper programs \u03a0 for which the result of Step 1 is a \u2286-minimal model of the reduct f\u03a0A. We provide a sound syntactic criterion for deciding whether the minimality check is needed, and in further elaboration, we describe how a program can be decomposed into program components such that unfoundedness checks can be delegated to the components, and the necessity of Step 2 thus be assessed on a finer-grained level.\nMore in detail, our main contributions are the following: \u2022 We present a syntactic decision criterion which can be used to decide whether a program possibly has unfounded sets. If the result of this check is negative, then the computationally expensive search for unfounded sets can be skipped. The criterion is based on atom dependency and, loosely speaking states that there are no cyclic dependencies of ground atoms through external atoms. This criterion can be efficiently checked for a given ground HEX-program using standard methods, and in fact applies to a range of applications, in particular, for input-stratified programs, where external sources are accessed in a workflow to produce input for the next stage of computation. However, there are relevant applications of HEX-programs where cycles through external atoms are essential, e.g., in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped. \u2022 In further elaboration, we consider a decomposition of a program \u03a0 into components based on the dependency graph that is induced by the program. We show that \u03a0 has\n1 http://www.kr.tuwien.ac.at/research/systems/dlvhex/\nsome unfounded set with respect to the candidate answer set A if and only if (at least) one of the components \u03a0C in the decomposition has some unfounded set wrt. A; note that computing the decomposition is efficiently possible, and thus does not incur a large overhead. This allows us to apply the decision criterion for the necessity of Step 2 efficiently on a more fine-grained level, and the search for unfounded sets can be guided to relevant parts of the program. In particular, for the HEX-encoding of a Dung-style argumentation semantics [4] which we consider, the decomposition approach yields a considerable gain, as shown in a preliminary experimental evaluation.\nThis paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf. [6]. By their wide applicability, our results are significant especially for many potential applications in practice."}, {"heading": "2 Preliminaries", "text": "In this section, we start with some basic definitions, and then introduce syntax and semantics of HEX-programs and the notion of unfounded sets we are going to use.\nA (signed) literal is a positive or a negative formula Ta resp. Fa, where a is a ground atom of form p(c1, . . . , c`), with predicate p and constants c1, . . . , c`, abbreviated p(c). For a literal \u03c3=Ta or \u03c3=Fa, let \u03c3 denote its opposite, i.e., Ta=Fa and Fa=Ta.\nAn assignment is a consistent set of literals Ta or Fa, where Ta expresses that a\u2208A and Fa that a /\u2208A.A is complete, also called an interpretation, if no assignment A\u2032\u2283A exists. We denote by AT = {a | Ta\u2208A} and AF = {a | Fa\u2208A} the set of atoms that are true, resp. false in A, and by ext(q,A) = {c | Tq(c)\u2208A} the extension of a predicate q. Furthermore, A|q is the set of all literals over atoms of form q(c) in A. For a list q = q1, . . . , qk of predicates we write p \u2208 q iff qi = p for some 1 \u2264 i \u2264 k, and let A|q = \u22c3 jA|qj .\nA nogood is a set {L1, . . . , Ln} of literals Li, 1 \u2264 i \u2264 n. An interpretation A is a solution to a nogood \u03b4 (resp. a set \u2206 of nogoods), iff \u03b4 6\u2286 A (resp. \u03b4 6\u2286 A for all \u03b4 \u2208 \u2206).\n2.1 HEX-Programs\nHEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11]. Syntax. HEX-programs extend ordinary ASP programs by external atoms, which enable a bidirectional interaction between a program and external sources of computation. External atoms have a list of input parameters (constants or predicate names) and a list of output parameters. Informally, to evaluate an external atom, the reasoner passes the constants and extensions of the predicates in the input tuple to the external source associated with the external atom. The external source computes output tuples which are matched with the output list. More formally, a ground external atom is of the form\n&g [p](c), (1) where p = p1, . . . , pk are constant input parameters (predicate names or object constants), and c = c1, . . . , cl are constant output terms.\nGround HEX-programs are then defined similar to ground ordinary ASP programs.\nDefinition 1 (Ground HEX-programs). A ground HEX-program consists of rules a1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 ak \u2190 b1, . . . , bm,not bm+1, . . . ,not bn , (2) where each ai is an (ordinary) ground atom p(c1, . . . , c`) with constants ci, 1 \u2264 i \u2264 `, each bj is either an ordinary ground atom or a ground external atom, and k + n > 0.2\nThe head of a rule r is H(r) = {a1, . . . , an} and the body is B(r) = {b1, . . . , bm, not bm+1, . . . ,not bn}. We call b or not b in a rule body a default literal; B+(r) = {b1, . . . , bm} is the positive body, B\u2212(r) = {bm+1, . . . , bn} is the negative body. For a program \u03a0 , let A(\u03a0) be the set of all ordinary atoms occurring in \u03a0 .\nWe also use non-ground programs. However, as suitable safety conditions allow for using a grounding procedure [12], we limit our investigation to ground programs. Semantics and Evaluation. Intuitively, a ground external atom &g [p](c) is true, if the external source &g yields output tuple c when evaluated with input p. Formally, the semantics of a ground external atom &g [p](c) wrt. an interpretation A is given by the value of a 1+k+l-ary Boolean oracle function f&g that is defined for all possible values of A, p and c, where k is the length of p and l is the length of c. Thus, &g [p](c) is true relative to A if and only if it holds that f&g(A,p, c) = 1. Satisfaction of ordinary rules and ASP programs [16] is then extended to HEX-rules and programs in the obvious way, and the notion of extension ext(\u00b7,A) for external predicates &g with input lists p is naturally defined by ext(&g [p],A) = {c | f&g(A,p, c) = 1}.\nDefinition 2 (FLP-Reduct [14]). For an interpretation A over a program \u03a0 , the FLPreduct f\u03a0A of \u03a0 wrt. A is the set {r \u2208 \u03a0 | A |= b, for all b \u2208 B(r)} of all rules whose body is satisfied under A.\nAn assignment A1 is smaller or equal to another assignment A2 wrt. a program \u03a0 , denoted A1 \u2264\u03a0 A2 iff {Ta \u2208 AT1 | a \u2208 A(\u03a0)} \u2286 {Ta \u2208 AT2 | a \u2208 A(\u03a0)}.\nDefinition 3 (Answer Set). An answer set of \u03a0 is a \u2264\u03a0 -minimal (complete) model A of f\u03a0A.\nSince interpretations (and thus answer sets, etc.) are complete assignments, slightly abusing notation, we adopt the usual convention to uniquely identify them with the set of all positive literals they contain.\nExample 1. Consider the program \u03a0 = {p \u2190 &id [p]()}, where &id [p]() is true iff p is true. Then \u03a0 has the answer set A1 = \u2205, which is indeed a \u2264\u03a0 -minimal model of f\u03a0A1 = \u2205.\nThe answer sets of a HEX-program \u03a0 are determined by the DLVHEX solver using a transformation to ordinary ASP programs as follows. Each external atom &g [p](c) in \u03a0 is replaced by an ordinary ground external replacement atom e&g[p](c) and a rule e&g[p](c)\u2228 ne&g[p](c)\u2190 is added to the program. The answer sets of the resulting guessing program \u03a0\u0302 are determined by an ordinary ASP solver and projected to nonreplacement atoms. However, the resulting interpretations are not necessarily models\n2 For simplicity, we do not formally introduce strong negation but view, as customary, classical literals \u00aca as new atoms together with a constraint\u2190 a,\u00aca.\nof \u03a0 , as the value of &g [p] under f&g can be different from the one of e&g[p](c). Each answer set of \u03a0\u0302 is thus merely a candidate which must be checked against the external sources. If no discrepancy is found, the model candidate is a compatible set of \u03a0 . More precisely,\nDefinition 4 (Compatible Set). A compatible set of a program\u03a0 is an interpretation A\u0302 such that\n(i) A\u0302 is an answer set [16] of the guessing program \u03a0\u0302 , and (ii) f&g(A\u0302,p, c) = 1 iff Te&g[p](c) \u2208 A\u0302 for all external atoms &g [p](c) in \u03a0 , i.e. the\nguessed values coincide with the actual output under the input from A\u0302.\nThe compatible sets of\u03a0 include (moduloA(\u03a0)) all (FLP) answer sets. For each answer set A there is a compatible set A\u0302 such that A is the restriction of A\u0302 to non-replacement atoms, but not vice versa. To filter out the compatible sets which are not answer sets, the current evaluation algorithm proceeds as follows. Each compatible set A is fed to the minimality check, which is realized as a search for unfounded sets. This is justified by the following Definitions 5 and 6 and Theorem 1 from [7]. (These results lift unfounded sets for disjunctive logic programs with arbitrary aggregates [13] to HEX-programs.)\nDefinition 5 (Unfounded Set [7]). Given a program \u03a0 and an interpretation A, let X be any set of ordinary ground atoms appearing in \u03a0 . Then, X is an unfounded set for A iff, for each rule r having some atoms from X in the head, at least one of the following conditions holds, where A . \u222a \u00ac.X = (A \\ {Ta | a \u2208 X}) \u222a {Fa | a \u2208 X}:\n(i) some literal of B(r) is false wrt. A, (ii) some literal of B(r) is false wrt. A . \u222a \u00ac.X , or\n(iii) some atom of H(r) \\X is true wrt. A.\nDefinition 6 (Unfounded-free Interpretations [7]). An interpretation A of a program \u03a0 is unfounded-free iff AT \u2229X = \u2205, for all unfounded sets X of \u03a0 wrt. A.\nTheorem 1 (Characterization of Answer Sets [7]). A model A of a program \u03a0 is an answer set iff it is unfounded-free.\nExample 2 (cont\u2019d). Reconsider the program \u03a0 = { p\u2190 &id [p]() } from above. Then the corresponding guessing program is \u03a0\u0302 = {p\u2190 e&id[p](); e&id[p] \u2228 ne&id[p] \u2190} and has the answer sets A1 = \u2205 and A2 = {Tp,Te&id[p]}. While A1 does not intersect with any unfounded sets and is thus also a \u2264\u03a0 -minimal model of f\u03a0A1 = \u2205, A2 intersects with the unfounded set U = {p} and is not an answer set.\nOur HEX implementation DLVHEX realizes the search for unfounded sets as a separate search problem using an encoding as a SAT instance. That is, for a program \u03a0 and an interpretation A we construct a set of nogoods \u0393A\u03a0 such that its solutions contain representations of all unfounded sets of \u03a0 wrt. A. A (relatively simple) post-check finds the unfounded sets among the solutions of \u0393A\u03a0 ."}, {"heading": "3 Deciding the Necessity of the UFS Check", "text": "An alternative to the search for unfounded sets is an explicit construction of the reduct and a search for smaller models. However, it turned out that the minimality check based\non unfounded sets is more efficient. Nevertheless the computational costs are still high. Moreover, during evaluation of \u03a0\u0302 for computing the compatible set A\u0302, the ordinary ASP solver has already made an unfounded set check, and we can safely assume that it is founded from its perspective. Hence, all remaining unfounded sets which were not discovered by the ordinary ASP solver have to involve external sources, as their behavior is not fully captured by the ASP solver.\nIn this section we formalize these ideas and define a decision criterion which allows us to decide whether a further UFS check is necessary for a given program. We eventually define a class of programs which does not require an additional unfounded set check. Intuitively, we show that every unfounded set that is not already detected during the construction of A\u0302 contains input atoms of external atoms which are involved in cycles. If no such input atom exists in the program, then the UFS check is superfluous.\nLet us therefore start with a definition of atom dependency.\nDefinition 7 (Atom Dependency). For a ground program \u03a0 , and ground atoms p(c) and q(d), we say that\n(i) p(c) depends on q(d), denoted p(c) \u2192 q(d), iff for some rule r \u2208 \u03a0 we have p(c) \u2208 H(r) and q(d) \u2208 B+(r);\n(ii) p(c) depends externally on q(d), denoted p(c)\u2192e q(d), iff for some rule r \u2208 \u03a0 we have p(c) \u2208 H(r) and there is a &g [q1, . . . , qn](e) \u2208 B+(r) \u222a B\u2212(r) with qi = q for some 1 \u2264 i \u2264 n.\nIn the following, we consider dependency graphs GR\u03a0 for a ground program \u03a0 , where the set of vertices is the set of all ground atoms, and the set of edges is given by a binary relation R over ground atoms. If R is not explicitly mentioned, then it is assumed to consist of \u2192 \u222a \u2192e, whose elemtents are also called ordinary edges and e-edges, respectively.\nThe next definition and lemma allow to restrict our attention to the \u201ccore\u201d of an unfounded set, i.e., its most essential part. For our purpose, we can then focus on such cores, disregarding atoms in a cut which is defined as follows.\nDefinition 8 (Cut). Let U be an unfounded set of \u03a0 wrt. A. A set of atoms C \u2286 U is called a cut, iff\n(i) b 6\u2192e a, for all a \u2208 C and b \u2208 U (C has no incoming or internal e-edges), and (ii) b 6\u2192 a and a 6\u2192 b, for all a \u2208 C and b \u2208 U \\ C (there are no ordinary edges\nbetween C and U \\ C).\nExample 3. Consider the program \u03a0 given as the following set of rules r \u2190 &id [r]() p\u2190 &id [r]() p\u2190 q q \u2190 p\nWe have p \u2192 q, q \u2192 p, r \u2192e r and p \u2192e r. Program \u03a0 has the unfounded set U = {p, q, r} wrt. A = {Tp,Tq,Tr}. Observe that C = {p, q} is a cut, and therefore we have that U \\ C = {r} is an unfounded set of \u03a0 wrt. A.\nWe first prove that cuts can be removed from unfounded sets and the resulting set is still an unfounded set.\nLemma 1 (Unfounded Set Reduction Lemma). Let U be an unfounded set of \u03a0 wrt. A, and let C be a cut. Then, Y = U \\ C is an unfounded set of \u03a0 wrt. A.\nProof (Sketch). If Y = \u2205, then the result holds trivially. Otherwise, let r \u2208 \u03a0 with H(r) \u2229 Y 6= \u2205. We show that one of the conditions in Definition 5 holds. Observe that H(r) \u2229 U 6= \u2205 because U \u2287 Y . Since U is an unfounded set of \u03a0 wrt. A, either\n(i) A 6|= b for some b \u2208 B(r); or (ii) A . \u222a \u00ac.U 6|= b for some b \u2208 B(r); or\n(iii) A |= h for some h \u2208 H(r) \\ U If (i), then the condition also holds wrt. Y .\nIf (ii), let a \u2208 H(r) such that a \u2208 Y , and b \u2208 B(r) such that A . \u222a \u00ac.U 6|= b. We\nmake a case distinction: either b is an ordinary literal or an external one. If it is an ordinary default-negated atom not c, then A . \u222a \u00ac.U 6|= b implies Tc \u2208 A and c 6\u2208 U , and therefore also A . \u222a \u00ac.Y 6|= b. So assume b is an ordinary atom. If b 6\u2208 U then A 6|= b and case (i) applies, so assume b \u2208 U . Because a \u2208 H(r) and b \u2208 B(r), we have a\u2192 b and therefore either a, b \u2208 C or a, b \u2208 Y (because there are no ordinary edges between C and Y ). But by assumption a \u2208 Y , and therefore b \u2208 Y , hence A . \u222a \u00ac.Y 6|= b.\nIf b is an external literal, then there is no q \u2208 U with a\u2192e q and q 6\u2208 Y . Otherwise, this would imply q \u2208 C and C would have an incoming e-edge, which contradicts the assumption that C is a cut. Hence, for all q \u2208 U with a\u2192e q, also q \u2208 Y , and therefore the truth value of b under A . \u222a \u00ac.U and A . \u222a \u00ac.Y is the same. Hence A . \u222a \u00ac.Y 6|= b.\nIf (iii), then also A |= h for some h \u2208 H(r) \\ Y because Y \u2286 U and therefore H(r) \\ Y \u2287 H(r) \\ U . 2\nNext we prove, intuitively, that for each unfounded set U of \u03a0 , either the input to some external atom is unfounded itself, or U is already detected when \u03a0\u0302 is evaluated.\nLemma 2 (EA-Input Unfoundedness). Let U be an unfounded set of \u03a0 wrt. A. If there are no x, y \u2208 U such that x\u2192e y, then U is an unfounded set of \u03a0\u0302 wrt. A\u0302.\nProof (Sketch). If U = \u2205, then the result holds trivially. Otherwise, let r\u0302 \u2208 \u03a0\u0302 such that H(r\u0302) \u2229 U 6= \u2205. Let a \u2208 H(r\u0302) \u2229 U . Observe that r\u0302 cannot be an external atom guessing rule because U contains only ordinary atoms. We show that one of the conditions in Definition 5 holds for r\u0302 wrt. A\u0302.\nBecause r\u0302 is no external atom guessing rule, there is a corresponding rule r \u2208 \u03a0 containing external atoms in place of replacement atoms. Because U is an unfounded set of \u03a0 and H(r) = H(r\u0302), either:\n(i) A 6|= b for some b \u2208 B(r); or (ii) A . \u222a \u00ac.U 6|= b for some b \u2208 B(r); or\n(iii) A |= h for some h \u2208 H(r) \\ U If (i), let b \u2208 B(r) such that A 6|= b and b\u0302 the corresponding literal in B(b\u0302) (which is the same if b is ordinary and the corresponding replacement literal if b is external). Then also A\u0302 6|= b\u0302 because A\u0302 is compatible.\nFor (ii), we make a case distinction: either b is ordinary or external. If b is ordinary, then b \u2208 B(r\u0302) and A\u0302 . \u222a \u00ac.U 6|= b holds because A and A\u0302 are\nequivalent for ordinary atoms.\nIf b is an external atom or default-negated external atom, then no atom p(c) \u2208 U is input to it, i.e. p is not a predicate input parameter of b; otherwise we had a \u2192e p(c), contradicting our assumption that U has no internal e-edges. But then A . \u222a \u00ac.U implies A 6|= b because the truth value of b under A . \u222a \u00ac.U and A is the same. Therefore we can apply case (i). If (iii), then also A\u0302 |= h for some h \u2208 H(r\u0302) \\ U because H(r) = H(r\u0302) contains\nonly ordinary atoms and A is equivalent to A\u0302 for ordinary atoms. 2\nExample 4. Reconsider the program \u03a0 from Example 3. Then the unfounded set U \u2032 = {p, q} wrt. A\u2032 = {Tp,Tq,Fr} is already detected when \u03a0\u0302 consisting of\ne&id[r]() \u2228 ne&id[r]()\u2190 r \u2190 e&id[r]() p\u2190 e&id[r]() p\u2190 q q \u2190 p\nis evaluated by the ordinary ASP solver because p 6\u2192e q and q 6\u2192e p. In contrast, the unfounded set U \u2032\u2032 = {p, q, r} wrt. A\u2032\u2032 = {Tp,Tq,Tr} is not detected by the ordinary ASP solver because p, r \u2208 U \u2032\u2032 and p\u2192e r.\nThe essential property of unfounded sets of \u03a0 wrt. A that are not recognized during the evaluation of \u03a0\u0302 , is the existence of cyclic dependencies including input atoms of some external atom. Towards a formal characterization of a class of programs without this property, i.e., that do not require additional UFS checks, we define cycles as follows.\nDefinition 9 (Cycle). A cycle under a binary relation \u25e6 is a sequence of elements C = c0, c1, . . . , cn, cn+1 with n \u2265 0, such that (ci, ci+1) \u2208 \u25e6 for all 0 \u2264 i \u2264 n and c0 = cn+1. We say that a set S contains a cycle under \u25e6, if there is a cycle C = c0, c1, . . . , cn, cn+1 under \u25e6 such that ci \u2208 S for all 0 \u2264 i \u2264 n+ 1.\nThe following proposition states, intuitively, that each unfounded set U of \u03a0 wrt. A which contains no cycle through the input atoms to some external atom has a corresponding unfounded set U \u2032 of \u03a0\u0302 wrt. A\u0302. That is, the unfoundedness is already detected when \u03a0\u0302 is evaluated.\nLet\u2192d =\u2192 \u222a \u2190 \u222a \u2192e, where\u2190 is the inverse of\u2192, i.e.\u2190 = {(x, y) | (y, x) \u2208 \u2192}. A cycle c0, c1, . . . , cn, cn+1 under\u2192d is called an e-cycle, iff it contains e-edges, i.e., iff (ci, ci+1) \u2208\u2192e for some 0 \u2264 i \u2264 n.\nProposition 1 (Relevance of e-cycles). Let U 6= \u2205 be an unfounded set of \u03a0 wrt. A that does not contain any e-cycle under\u2192d. Then, there exists a nonempty unfounded set of \u03a0\u0302 wrt. A\u0302.\nProof (Sketch). We define the reachable set R(a) from some atom a as R(a) = {b | (a, b) \u2208 {\u2192 \u222a \u2190}\u2217},\ni.e. the set of atoms b \u2208 U reachable from a using edges from \u2192 \u222a \u2190 only but no e-edges.\nWe first assume that U contains at least one e-edge, i.e. there are x, y \u2208 U such that x \u2192e y. Now we show that there is a u \u2208 U with outgoing e-edge (i.e. u \u2192e v\nfor some v \u2208 U ), but such that R(u) has no incoming e-edges (i.e. for all v \u2208 R(u) and b \u2208 U , b 6\u2192e v holds). Suppose to the contrary that for all a with outgoing eedges, the reachable set R(a) has an incoming e-edge. We now construct an e-cycle under \u2192d, which contradicts our assumption. Start with an arbitrary node with an outgoing e-edge c0 \u2208 U and let p0 be the (possibly empty) path (under \u2192 \u222a \u2190) from c0 to the node d0 \u2208 R(c0) such that d0 has an incoming e-edge, i.e. there is a c1 such that c1 \u2192e d0; note that c1 6\u2208 R(c0)3. By assumption, also some node d1 in R(c1) has an incoming e-edge (from some node c2 6\u2208 R(c1)). Let p1 be the path from c1 to d1, etc. By iteration we can construct the concatenation of the paths p0, (d0, c1), p1, (d1, c2), p2, . . . , pi, (di, ci+1), . . ., where the pi from ci to di are the paths within reachable sets, and the (di, ci+1) are the e-edges between reachable sets. However, as U is finite some nodes on this path must be equal, i.e., a prefix of the constructed sequence represents an e-cycle (in reverse order).\nThis proves that u is a node with outgoing e-edge but such thatR(u) has no incoming e-edges. We next show that R(u) is a cut. Condition (i) is immediately satisfied by definition of u. Condition (ii) is shown as follows. Let u\u2032 \u2208 R(u) and v\u2032 \u2208 U \\R(u). We have to show that u\u2032 6\u2192 v\u2032 and v\u2032 6\u2192 u\u2032. Suppose, towards a contradiction, that u\u2032 \u2192 v\u2032. Because of u\u2032 \u2208 R(u), there is a path from u to u\u2032 under \u2192 \u222a \u2190. But if u\u2032 \u2192 v\u2032, then there would also be a path from u to v\u2032 under\u2192 \u222a \u2190 and v\u2032 would be in R(u), a contradiction Analogously, v\u2032 \u2192 u\u2032 would also imply that there is a path from u to v\u2032 because there is a path from u to u\u2032, again a contradiction.\nTherefore, R(u) is a cut of U , and by Lemma 1, it follows that U \\ R(u) is an unfounded set. Observe that U \\ R(u) contains one e-edge less than U because u has an outgoing e-edge. Further observe that U \\R(u) 6= \u2205 because there is a w \u2208 U such that u \u2192e w but w 6\u2208 R(u). By iterating this argument, the number of e-edges in the unfounded set can be reduced to zero in a nonempty core. Eventually, Lemma 2 applies, proving that the remaining set is an unfounded set of \u03a0\u0302 . 2\nCorollary 1. If there is no e-cycle under \u2192d and \u03a0\u0302 has no unfounded set wrt. A\u0302, then A is unfounded-free for \u03a0 .\nProof (Sketch). Suppose there is an unfounded set U of \u03a0 wrt. A. Then it contains no e-cycle because there is no e-cycle under \u2192d. Then by Proposition 1 there is an unfounded set of \u03a0\u0302 wrt. A\u0302, which contradicts our assumption. 2\nThis corollary can be used as follows to increase performance of an evaluation algorithm: if there is no cycle under\u2192d containing e-edges, then an explicit unfounded set check is not necessary because the unfounded set check made during evaluation of \u03a0\u0302 suffices. Note that this test can be done efficiently (in fact in linear time, similar to deciding stratifiability of an ordinary logic program). Moreover, in practice one can abstract from\u2192d by using analogous relations on the level of predicate symbols instead of atoms. Clearly, if there is no e-cycle in the predicate dependency graph, then there can also be no e-cycle in the atom dependency graph. Hence, the predicate dependency graph can be used to decide whether the unfounded set check can be skipped.\n3 Whenever x \u2192e y for x, y \u2208 U , then there is no path from x to y under\u2192 \u222a \u2190, because otherwise we would have an e-cycle under\u2192d.\nExample 5. All example programs considered until here require an UFS check, but the program \u03a0 = {out(X)\u2190 &diff [set1, set2](X)} \u222a F does not for any set of facts F , because there is no e-cycle under\u2192d, where diff computes the set difference of the extensions of set1 and set2.\nAlso \u03a0 = {str(Z) \u2190 dom(Z), str(X), str(Y ),not&concat [X,Y ](Z)} (where &concat takes two constants and computes their string concatenation) does not need such a check; there is a cycle over an external atom, but no e-cycle under\u2192d.\nMoreover, the following proposition states that, intuitively, if \u03a0\u0302 has no unfounded sets wrt. A\u0302, then any unfounded set U of \u03a0 wrt. A must contain an atom which is involved in a cycle under\u2192d that has an e-edge.\nDefinition 10 (Cyclic Input Atoms). For a program \u03a0 , an atom a is a cyclic input atom, iff there is an atom b such that b\u2192e a and there is a path from a to b under\u2192d.\nLet CA(\u03a0) denote the set of all cyclic input atoms of program \u03a0 .\nProposition 2 (Unfoundedness of Cyclic Input Atom). Let U 6= \u2205 be an unfounded set of\u03a0 wrt. A such that U does not contain cyclic input atoms. Then, \u03a0\u0302 has a nonempty unfounded set wrt. A\u0302.\nProof (Sketch). If U contains no cyclic input atoms, then all cycles under\u2192d containing e-edges in the atom dependency graph of \u03a0 are broken, i.e. U does not contain an e-cycle under\u2192d. Then by Proposition 1 there is an unfounded set of \u03a0\u0302 wrt. A\u0302. 2\nProposition 2 allows for generating the additional nogood {Fa | a \u2208 CA(\u03a0)} and adding it to \u0393A\u03a0 . Again, considering predicate symbols instead of atoms is possible to reduce the overhead introduced by the dependency graph."}, {"heading": "4 Program Decomposition", "text": "It turns out that the usefulness of the decision criterion can be increased by decomposing the program into components, such that the criterion can be applied component-wise. This allows for restricting the unfounded set check to components with e-cycles, whereas e-cycle-free components can be ignored in the check.\nLet C be a partitioning of the ordinary atoms A(\u03a0) of \u03a0 into subset-maximal strongly connected components under\u2192 \u222a \u2192e. We define for each partition C \u2208 C the subprogram \u03a0C associated with C as \u03a0C = {r \u2208 \u03a0 | H(r) \u2229 C 6= \u2205}.\nWe next show that if a program has an unfounded set U wrt. A, then U \u2229C is an unfounded set wrt. A for the subprogram of some strongly connected component C.\nProposition 3. Let U 6= \u2205 be an unfounded set of \u03a0 wrt. A. Then, for some \u03a0C with C \u2208 C it holds that U \u2229 C is a nonempty unfounded set of \u03a0C wrt. A.\nProof (Sketch). Let U be a nonempty unfounded set of \u03a0 wrt. A. Because C is a decomposition ofA(\u03a0) into strongly connected components, the component dependency graph\n\u3008C, {(C1, C2) | C1, C2 \u2208 C,\u2203a1 \u2208 C1, a2 \u2208 C2 : (a1, a2) \u2208\u2192 \u222a \u2192e}\u3009\nis acyclic. Following the hierarchical component dependency graph from the nodes without predecessor components downwards, we can find a \u201cfirst\u201d component which has a nonempty intersection with U , i.e., there exists a component C \u2208 C such that C \u2229 U 6= \u2205 but C \u2032 \u2229 U = \u2205 for all transitive predecessor components C \u2032 of C.\nWe show that U \u2229 C is an unfounded set of \u03a0C wrt. A. Let r \u2208 \u03a0C be a rule such that H(r) \u2229 (U \u2229 C) 6= \u2205. We have to show that one of the conditions of Definition 5 holds for r wrt. A and U \u2229 C.\nBecause U is an unfounded set of \u03a0 wrt. A and H(r) \u2229 (U \u2229 C) 6= \u2205 implies H(r) \u2229 U 6= \u2205, we know that one of the conditions holds for r wrt. A and U . If this is condition (i) or (iii), then it trivially holds also wrt. A and U \u2229 C because these conditions depend only on the assignment A, but not on the unfounded set U .\nIf it is condition (ii), then A . \u222a \u00ac.U 6|= b for some (ordinary or external) body literal b \u2208 B(r). We show next that the truth value of all literals in B(r) is the same under A . \u222a \u00ac.U and A . \u222a \u00ac.(U \u2229 C), which proves that condition (ii) holds also wrt. A and U \u2229 C. If b = not a for some atom a, then Ta \u2208 A and a 6\u2208 U and consequently a 6\u2208 U \u2229C, hence A . \u222a \u00ac.(U \u2229C) 6|= b. If b is an ordinary atom, then either Fb \u2208 A, which implies immediatly that A . \u222a \u00ac.(U \u2229 C) 6|= b, or b \u2208 U . But in the latter case b is either in a predecessor component C \u2032 of C or in C itself (since h \u2192 b for all h \u2208 H(r)). But since U \u2229 C \u2032 = \u2205 for all predecessor components of C, we know b \u2208 C and therefore b \u2208 (U \u2229 C), which implies A . \u222a \u00ac.(U \u2229 C) 6|= b.\nIf b is a positive or default-negated external atom, then all input atoms a to b are either in a predecessor componentC \u2032 ofC or inC itself (since h\u2192e a for all h \u2208 H(r)). We show with a similar argument as before that the truth value of each input atom a is the same under A . \u222a \u00ac.U and A . \u222a \u00ac.(U \u2229 C): if A . \u222a \u00ac.U |= a, then Ta \u2208 A and a 6\u2208 U , hence a 6\u2208 (U \u2229 C) and therefore A . \u222a \u00ac.(U \u2229 C) |= a. If A . \u222a \u00ac.U 6|= a, then either Fa \u2208 A, which immediately implies A . \u222a \u00ac.(U \u2229 C) 6|= a, or a \u2208 U . But in the latter case a must be in C because U \u2229 C \u2032 = \u2205 for all predecessor components C \u2032 of C. Therefore a \u2208 (U \u2229 C) and consequently A . \u222a \u00ac.(U \u2229 C) 6|= a. Because all input atoms a have the same truth value under A . \u222a \u00ac.U and A . \u222a \u00ac.(U \u2229 C), the same holds also for the positive or default-negated external atom b itself. 2\nThis proposition states that a search for unfounded sets can be done independently for the subprograms \u03a0C for all C \u2208 C. If there exists a global unfounded set, then there exists also one in at least one of the program components. However, we know by Corollary 1 that programs \u03a0 without e-cycles cannot contain unfounded sets, which are not already detected when \u03a0\u0302 is solved. If we apply this proposition to the subprograms \u03a0C , we can safely ignore e-cycle-free program components.\nExample 6. Reconsider the program \u03a0 from Example 3. Then C contains the components C1 = {p, q} and C2 = {r} and we have \u03a0C1 = {p\u2190 &id [r ](); p\u2190 q; q \u2190 p} and \u03a0C2 = {r \u2190 &id [r ]()}. By Proposition 3, each unfounded set of \u03a0 wrt. some assignment can also detected over one of the components. Consider e.g. U = {p, q, r} wrt. A = {Tp,Tq,Tr}. Then U \u2229 {r} = {r} is also an unfounded set of \u03a0C2 wrt. A.\nBy separate application of Corollary 1 to the components, we can conclude that there can be no unfounded sets over \u03a0C1 that are not already detected when \u03a0\u0302 is evaluated (because it has no e-cycles). Hence, the additional unfounded set check is only necessary"}, {"heading": "10 2 126.54 0 80.00 36.78% 40 278.98 16 214.81 23.00%", "text": "for \u03a0C2 . Indeed, the only unfounded set which is not detected when \u03a0\u0302 is evaluated is {r} of \u03a0C2 wrt. any interpretation A \u2287 {Tr}.\nFinally, one can also show that splitting, i.e., the component-wise check for foundedness, does not lead to spurious unfounded sets.\nProposition 4. If U is an unfounded set of \u03a0C wrt. A such that U \u2286 C, then U is an unfounded set of \u03a0 wrt. A.\nProof (Sketch). If U = \u2205, then the result holds trivially. By definition of \u03a0C we have H(r) \u2229 C = \u2205 for all r \u2208 \u03a0 \\\u03a0C . By precondition of the proposition we have U \u2286 C. But then H(r) \u2229 U = \u2205 for all r \u2208 \u03a0 \\\u03a0C and U is an unfounded set of \u03a0 wrt. A. 2"}, {"heading": "5 Implementation and Evaluation", "text": "For implementing our technique, we integrated CLASP into our prototype system DLVHEX; we use CLASP as an ASP solver for computing compatible sets and as a SAT solver for solving the nogood set of the UFS check. We evaluated the implementation on a Linux server with two 12-core AMD 6176 SE CPUs with 128GB RAM. Argumentation Benchmarks. In this benchmark we compute ideal set extensions for randomized instances of abstract argumentation frameworks [4] of different sizes. In these instances, the cycles involve usually only small parts of the overall programs, hence the program decomposition is very effective. Table 1 shows results of our experimental evaluation on argumentation benchmark instances; for computing average times, we considered 300 seconds for instances that timed out. The encodings contain a cyclic part with cycles over external atoms, and a cyclic part with cycles that do not contain external atoms. Therefore in these instances our new approach can help in limiting the set of atoms for which unfounded sets must be checked, which explains the significant performance gain due to less time spent in the UFS check. Multi-Context System Benchmarks. MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.\nThis benchmark computes the IEs, which correspond 1-1 to answer sets of an encoding rich in cycles through external atoms (which evaluate local knowledge base semantics). We use random instances of different topologies created with an available benchmark generator. For the MCS benchmarks we tested 68 consistent and 88 inconsistent MCSs for which we compute inconsistency explanations [9]. This encoding contains saturation over external atoms, where nearly all cycles in the HEX-program contain at least one external atom. Therefore the methods we introduce in this work can only very rarely reduce the set of atoms for which the UFS check needs to be performed.\nThe benchmark result for MCS instances confirms that the syntactic check we introduce in this paper is very cheap and does not impede performance, even if an instance does not admit a considerable simplification for the UFS check: over all 156 instances, we had an overall runtime of 25357 seconds with the standard approach, and a runtime of 25115 seconds with our new approach; the gain is 242 seconds which is less than one percent speedup (for enumerating all inconsistency explanations) by applying our method. This is a very small gain, and there is no difference in the number of instances that timed out.\nDefault Reasoning over Description Logics Benchmarks. Another application of HEX-programs is the DL-plugin [10], which integrates description logics ontologies with rules. This allows, for instance, default reasoning over description logic knowledge bases, which is not possible in DL knowledge bases alone. Defaults require cyclic dependencies over external atoms. However, as all such dependencies involve default negated atoms, we have no cycles according to Definition 7, which respects only positive dependencies. Hence, the decision criterion comes to the conclusion that no UFS check is required.\nWe used variants of the benchmarks presented in [6], which query wines from an ontology and classify them as red or white wines, where a wine is assumed to be white unless the ontology explicitly entails the contrary. In this scenario, the decision criterion eliminates all unfounded set checks. However, as there is only one compatible set per instance, there would be only one unfounded set check anyway, hence the speedup due to the decision criterion is not significant. But the effect of the decision criterion can be increased by slightly modifying the scenario such that there are multiple compatible sets. This can be done, for instance, by nondeterministic default classifications, e.g., if a wine is not Italian, then it is either French or Spanish by default. Our experiments have shown that with a small number of compatible sets, the performance enhancement due to the decision criterion is marginal, but increases with larger numbers of compatible sets. For instance, for 243 compatible sets (and thus 243 unfounded set checks) we could observe a speedup from 13.59 to 12.19 seconds."}, {"heading": "6 Conclusion", "text": "The evaluation of HEX-programs requires a minimality check of model candidates which is realized as an equivalent search for unfounded sets (UFS). However, this check is computationally costly. Moreover, during construction of the model candidate, the ASP solver used as a backend has already performed a \u201crestricted\u201d form of unfounded set check, i.e., an UFS check over the program \u03a0\u0302 , viewing external atoms as ordinary ones. Hence, it already excludes certain unfounded candidates. Redoing a complete UFS\nsearch is thus a waste of resources, and the goal is to minimize the number of additional foundedness checks.\nIn this paper we presented a syntactic criterion which can be efficiently tested and allows to decide whether an additional UFS check is necessary for a given program. It turned out that the essential property is the existence of cyclic dependencies of atoms which involve predicate inputs to external atoms. If no such dependencies exist, then there is no need for an additional check, and the check built into the ordinary ASP solver is already sufficient. In further elaboration, we have refined the basic idea by splitting the input program into components. This allows for independent applications of the decision criterion to the different components. Thus, the UFS check is restricted to relevant parts of the program, while it can safely be ignored for other parts.\nRelated to our work is [3], where a similar program decomposition is used, yet for ordinary programs only. While we consider e-cycles, which are specific for HEXprograms, the interest in [3] is with head-cycles with respect to disjunctive rule heads. In fact, our implementation may be regarded as an extension of the work in [3], since the evaluation of \u03a0\u0302 follows their principles of performing UFS checks in case of head-cycles. Note however, that the applied component splitting does not generalize the well-known splitting theorem [18] as we consider only positive dependencies for ordinary atoms.\nAn interesting issue for further research is to consider refinements of the decision criterion, or alternative criteria. One direction for refinement is to dynamically take the model candidate into account, in addition to the program structure, which intuitively may prune dependencies and thus allow to skip the UFS check even in the presence of (syntactic) e-cycles. Another extension is to exploit additional semantic information on the external atoms, e.g., such as (anti-)monotonicity etc. Moreover, a more extensive experimental analysis is subject of our future work, where case studies may give rise to to alternative criteria and further optimizations."}], "references": [{"title": "Equilibria in Heterogeneous Nonmonotonic Multi-Context Systems", "author": ["G. Brewka", "T. Eiter"], "venue": "AAAI\u201907. pp. 385\u2013390. AAAI Press", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2007}, {"title": "Answer set programming at a glance", "author": ["G. Brewka", "T. Eiter", "M. Truszczy\u0144ski"], "venue": "Commun. ACM 54(12), 92\u2013103", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2011}, {"title": "Conflict-driven disjunctive answer set solving", "author": ["C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. K\u00f6nig", "M. Ostrowski", "T. Schaub"], "venue": "KR\u201908. pp. 422\u2013432. AAAI Press", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2008}, {"title": "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games", "author": ["P.M. Dung"], "venue": "Artif. Intell. 77(2), 321\u2013357", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1995}, {"title": "Pushing efficient evaluation of HEX programs by modular decomposition", "author": ["T. Eiter", "M. Fink", "G. Ianni", "T. Krennwallner", "P. Sch\u00fcller"], "venue": "LPNMR\u201911. pp. 93\u2013106", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "Conflict-driven ASP solving with external sources", "author": ["T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl"], "venue": "Theory and Practice of Logic Programming: Special Issue ICLP", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Exploiting Unfounded Sets for HEX-Program Evaluation. In: JELIA\u201912", "author": ["T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl", "P. Sch\u00fcller"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "Improving HEX-Program Evaluation based on Unfounded Sets", "author": ["T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl", "P. Sch\u00fcller"], "venue": "Tech. Rep. INFSYS RR-1843-12-08, Institut f\u00fcr Informationssysteme, Technische Universit\u00e4t Wien, A-1040 Vienna, Austria", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2012}, {"title": "Finding explanations of inconsistency in Multi-Context Systems", "author": ["T. Eiter", "M. Fink", "P. Sch\u00fcller", "A. Weinzierl"], "venue": "KR\u201910. pp. 329\u2013339. AAAI Press", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Exploiting conjunctive queries in description logic programs", "author": ["T. Eiter", "G. Ianni", "T. Krennwallner", "R. Schindlauer"], "venue": "Ann. Math. Artif. Intell. 53(1\u20134),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer-Set Programming", "author": ["T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits"], "venue": "IJCAI\u201905. pp. 90\u201396. Professional Book Center", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2005}, {"title": "Effective Integration of Declarative Rules with External Evaluations for Semantic-Web Reasoning", "author": ["T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits"], "venue": "ESWC\u201906. pp. 273\u2013287. Springer", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2006}, {"title": "Unfounded sets for disjunctive logic programs with arbitrary aggregates", "author": ["W. Faber"], "venue": "LPNMR\u201905. pp. 40\u201352. Springer", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2005}, {"title": "Semantics and complexity of recursive aggregates in answer set programming", "author": ["W. Faber", "N. Leone", "G. Pfeifer"], "venue": "Artif. Intell. 175(1), 278\u2013298", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "Conflict-driven answer set solving: From theory to practice", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "Artif. Intell. 187\u2013188, 52\u201389", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Classical Negation in Logic Programs and Disjunctive Databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generat. Comput. 9(3\u20134), 365\u2013386", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1991}, {"title": "Answer set programming based on propositional satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "J. Autom. Reason. 36(4), 345\u2013377", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Splitting a logic program", "author": ["V. Lifschitz", "H. Turner"], "venue": "ICLP\u201994. pp. 23\u201337", "citeRegEx": "18", "shortCiteRegEx": null, "year": 1994}, {"title": "The DLV System for Knowledge Representation and Reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Trans. Comput. Logic 7(3), 499\u2013562", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2006}, {"title": "Extending and Implementing the Stable Model Semantics", "author": ["P. Simons", "I. Niemel\u00e4", "T. Soininen"], "venue": "Artif. Intell. 138, 181\u2013234", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2002}], "referenceMentions": [{"referenceID": 1, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 155, "endOffset": 158}, {"referenceID": 19, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 216, "endOffset": 220}, {"referenceID": 18, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 226, "endOffset": 230}, {"referenceID": 16, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 240, "endOffset": 244}, {"referenceID": 14, "context": "In the last years, Answer Set Programming (ASP) has emerged as an increasingly popular approach to declarative problem solving for a range of applications [2], thanks to expressive and efficient systems like SMODELS [20], DLV [19], cmodels [17], and CLASP [15].", "startOffset": 256, "endOffset": 260}, {"referenceID": 10, "context": "To cater for this need, HEX-programs [11] extend ASP with so called external atoms, through which the user can couple any external data source with a logic program.", "startOffset": 37, "endOffset": 41}, {"referenceID": 4, "context": "[5]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 13, "context": "The semantics of a HEX-program \u03a0 is defined in terms of answer sets based on the FLP reduct [14]: an interpretation A is an answer set of \u03a0 , if and only if it is a \u2286-minimal model of the FLP-reduct f\u03a0 of \u03a0 wrt.", "startOffset": 92, "endOffset": 96}, {"referenceID": 15, "context": "For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of f\u03a0, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.", "startOffset": 97, "endOffset": 101}, {"referenceID": 13, "context": "For ordinary logic programs, this semantics coincides with the one where the canonical GL-reduct [16] is in place of f\u03a0, and it is more appealing for extensions with nonmonotonic aggregates [14], and the more general external atoms in HEX-programs.", "startOffset": 190, "endOffset": 194}, {"referenceID": 12, "context": "Step 2 then checks whether A is a \u2286-minimal model or, equivalently, whether A is unfounded-free [13], i.", "startOffset": 96, "endOffset": 100}, {"referenceID": 13, "context": "Unfortunately, Step 2 is computationally expensive in general, and it is intractable even for Horn programs with nonmonotonic external atoms of polynomial complexity, as follows from results in [14].", "startOffset": 194, "endOffset": 198}, {"referenceID": 0, "context": ", in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped.", "startOffset": 52, "endOffset": 55}, {"referenceID": 3, "context": ", in encodings of problems on multi-context systems [1] or abstract argumentation systems [4], for which Step 2 cannot be skipped.", "startOffset": 90, "endOffset": 93}, {"referenceID": 3, "context": "In particular, for the HEX-encoding of a Dung-style argumentation semantics [4] which we consider, the decomposition approach yields a considerable gain, as shown in a preliminary experimental evaluation.", "startOffset": 76, "endOffset": 79}, {"referenceID": 6, "context": "This paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf.", "startOffset": 81, "endOffset": 87}, {"referenceID": 7, "context": "This paper complements recent work on unfoundedness checking for HEX-programs in [7, 8], which is part of a larger effort to provide efficient evaluation of HEX-programs, based on new algorithms cf.", "startOffset": 81, "endOffset": 87}, {"referenceID": 5, "context": "[6].", "startOffset": 0, "endOffset": 3}, {"referenceID": 10, "context": "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].", "startOffset": 32, "endOffset": 36}, {"referenceID": 15, "context": "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].", "startOffset": 129, "endOffset": 133}, {"referenceID": 10, "context": "HEX-programs were introduced in [11] as a generalization of (disjunctive) extended logic programs under the answer set semantics [16]; for details and background see [11].", "startOffset": 166, "endOffset": 170}, {"referenceID": 11, "context": "However, as suitable safety conditions allow for using a grounding procedure [12], we limit our investigation to ground programs.", "startOffset": 77, "endOffset": 81}, {"referenceID": 15, "context": "Satisfaction of ordinary rules and ASP programs [16] is then extended to HEX-rules and programs in the obvious way, and the notion of extension ext(\u00b7,A) for external predicates &g with input lists p is naturally defined by ext(&g [p],A) = {c | f&g(A,p, c) = 1}.", "startOffset": 48, "endOffset": 52}, {"referenceID": 13, "context": "Definition 2 (FLP-Reduct [14]).", "startOffset": 25, "endOffset": 29}, {"referenceID": 15, "context": "A compatible set of a program\u03a0 is an interpretation \u00c2 such that (i) \u00c2 is an answer set [16] of the guessing program \u03a0\u0302 , and (ii) f&g(\u00c2,p, c) = 1 iff Te&g[p](c) \u2208 \u00c2 for all external atoms &g [p](c) in \u03a0 , i.", "startOffset": 87, "endOffset": 91}, {"referenceID": 6, "context": "This is justified by the following Definitions 5 and 6 and Theorem 1 from [7].", "startOffset": 74, "endOffset": 77}, {"referenceID": 12, "context": "(These results lift unfounded sets for disjunctive logic programs with arbitrary aggregates [13] to HEX-programs.", "startOffset": 92, "endOffset": 96}, {"referenceID": 6, "context": "Definition 5 (Unfounded Set [7]).", "startOffset": 28, "endOffset": 31}, {"referenceID": 6, "context": "Definition 6 (Unfounded-free Interpretations [7]).", "startOffset": 45, "endOffset": 48}, {"referenceID": 6, "context": "Theorem 1 (Characterization of Answer Sets [7]).", "startOffset": 43, "endOffset": 46}, {"referenceID": 3, "context": "In this benchmark we compute ideal set extensions for randomized instances of abstract argumentation frameworks [4] of different sizes.", "startOffset": 112, "endOffset": 115}, {"referenceID": 0, "context": "MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.", "startOffset": 5, "endOffset": 8}, {"referenceID": 8, "context": "MCSs [1] are a formalism for interlinking knowledge based systems; in [9], inconsistency explanations (IEs) for an MCS were defined.", "startOffset": 70, "endOffset": 73}, {"referenceID": 8, "context": "For the MCS benchmarks we tested 68 consistent and 88 inconsistent MCSs for which we compute inconsistency explanations [9].", "startOffset": 120, "endOffset": 123}, {"referenceID": 9, "context": "Another application of HEX-programs is the DL-plugin [10], which integrates description logics ontologies with rules.", "startOffset": 53, "endOffset": 57}, {"referenceID": 5, "context": "We used variants of the benchmarks presented in [6], which query wines from an ontology and classify them as red or white wines, where a wine is assumed to be white unless the ontology explicitly entails the contrary.", "startOffset": 48, "endOffset": 51}, {"referenceID": 2, "context": "Related to our work is [3], where a similar program decomposition is used, yet for ordinary programs only.", "startOffset": 23, "endOffset": 26}, {"referenceID": 2, "context": "While we consider e-cycles, which are specific for HEXprograms, the interest in [3] is with head-cycles with respect to disjunctive rule heads.", "startOffset": 80, "endOffset": 83}, {"referenceID": 2, "context": "In fact, our implementation may be regarded as an extension of the work in [3], since the evaluation of \u03a0\u0302 follows their principles of performing UFS checks in case of head-cycles.", "startOffset": 75, "endOffset": 78}, {"referenceID": 17, "context": "Note however, that the applied component splitting does not generalize the well-known splitting theorem [18] as we consider only positive dependencies for ordinary atoms.", "startOffset": 104, "endOffset": 108}], "year": 2013, "abstractText": "HEX-programs are an extension of the Answer Set Programming (ASP) paradigm incorporating external means of computation into the declarative programming language through so-called external atoms. Their semantics is defined in terms of minimal models of the Faber-Leone-Pfeifer (FLP) reduct. Developing native solvers for HEX-programs based on an appropriate notion of unfounded sets has been subject to recent research for reasons of efficiency. Although this has lead to an improvement over naive minimality checking using the FLP reduct, testing for foundedness remains a computationally expensive task. In this work we improve on HEX-program evaluation in this respect by identifying a syntactic class of programs, that can be efficiently recognized and allows to entirely skip the foundedness check. Moreover, we develop criteria for decomposing a program into components, such that the search for unfounded sets can be restricted. Observing that our results apply to many HEX-program applications provides analytic evidence for the significance and effectiveness of our approach, which is complemented by a brief discussion of preliminary experimental validation.", "creator": "TeX"}}}