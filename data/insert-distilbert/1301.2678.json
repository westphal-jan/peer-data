{"id": "1301.2678", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Jan-2013", "title": "Verification of Agent-Based Artifact Systems", "abstract": "artifact systems are a enough novel paradigm for specifying and implementing business process processes also described partly in terms of dynamic interacting modules called artifacts. measurement artifacts consist of data and lifecycles, accounting respectively for the relational structure of the artifacts'states and their possible evolutions different over time. in this paper we put forward a artifact - centric multi - agent systems, a sufficiently novel formalisation specification of artifact systems in the context specification of dependent multi - agent concurrent systems operating on them. differently from the usual process - based models of services, the semantics concepts we first give explicitly accounts for the desired data structures on which artifact systems are defined. we study the model checking problem for artifact - centric objective multi - agent systems against specifications directly written in a quantified version system of temporal - epistemic logic expressing the observed knowledge of the agents in the exchange. we begin by noting that the problem scope is undecidable in general. we then identify two noteworthy restrictions, one syntactical and one semantical, that enable - us to simultaneously find bisimilar finite abstractions and therefore reduce the model checking problem to the instance on finite models. under both these stated assumptions we show that the model of checking problem for these systems is expspace - complete. we then similarly introduce artifact - centric programs, compact and declarative representations of the programs governing both the artifact making system and the agents. we show that, while these in principle generate infinite - state systems, under natural conditions their verification mapping problem can be solved on finite abstractions that can be effectively computed together from varying the programs. finally we exemplify the theoretical results of the paper through a mainstream procurement scenario from the artifact systems literature.", "histories": [["v1", "Sat, 12 Jan 2013 11:45:54 GMT  (94kb)", "https://arxiv.org/abs/1301.2678v1", null], ["v2", "Tue, 22 Jan 2013 09:22:30 GMT  (446kb)", "http://arxiv.org/abs/1301.2678v2", null]], "reviews": [], "SUBJECTS": "cs.MA cs.AI cs.LO", "authors": ["francesco belardinelli", "alessio lomuscio", "fabio patrizi"], "accepted": false, "id": "1301.2678"}, "pdf": {"name": "1301.2678.pdf", "metadata": {"source": "CRF", "title": "Verification of Agent-Based Artifact Systems", "authors": ["Francesco Belardinelli", "Fabio Patrizi"], "emails": ["BELARDINELLI@IBISC.FR", "A.LOMUSCIO@IMPERIAL.AC.UK", "FABIO.PATRIZI@DIS.UNIROMA1.IT"], "sections": [{"heading": null, "text": "ar X\niv :1\n30 1.\n26 78\nv2 [\ncs .M\nA ]\n2 2\nJa n\nWe study the model checking problem for artifact-centric multi-agent systems against specifications written in a quantified version of temporal-epistemic logic expressing the knowledge of the agents in the exchange. We begin by noting that the problem is undecidable in general. We then identify two noteworthy restrictions, one syntactical and one semantical, that enable us to find bisimilar finite abstractions and therefore reduce the model checking problem to the instance on finite models. Under these assumptions we show that the model checking problem for these systems is EXPSPACE-complete. We then introduce artifact-centric programs, compact and declarative representations of the programs governing both the artifact system and the agents. We show that, while these in principle generate infinite-state systems, under natural conditions their verification problem can be solved on finite abstractions that can be effectively computed from the programs. Finally we exemplify the theoretical results of the paper through a mainstream procurement scenario from the artifact systems literature."}, {"heading": "1. Introduction", "text": "Much of the work in the area of reasoning about knowledge involves the development of formal techniques for the representation of epistemic properties of rational actors, or agents, in a multiagent system (MAS). The approaches based on modal logic are often rooted on interpreted systems (Parikh & Ramanujam, 1985), a computationally grounded semantics (Wooldridge, 2000) used for the interpretation of several temporal-epistemic logics. This line of research was thoroughly explored in the 1990s leading to a significant body of work (Fagin, Halpern, Moses, & Vardi, 1995). Further significant explorations have been conducted since then; a recent topic of interest has focused on the development of automatic techniques, including model checking (Clarke, Grumberg, & Peled, 1999), for the verification of temporal-epistemic specifications for the autonomous agents in a MAS (Gammie & van der Meyden, 2004; Kacprzak, Nabialek, Niewiadomski, Penczek, Po\u0301lrola, Szreter, Wozna, & Zbrzezny, 2008; Lomuscio, Qu, & Raimondi, 2009). This has led to developments in a number of areas traditionally outside artificial intelligence, knowledge representation\nand MAS, including security (Dechesne & Wang, 2010; Ciobaca, Delaune, & Kremer, 2012), webservices (Lomuscio, Solanki, Penczek, & Szreter, 2010) and cache-coherence protocols in hardware design (Baukus & van der Meyden, 2004). The ambition of the present paper is to offer a similar change of perspective in the area of artifact systems (Cohn & Hull, 2009), a growing topic in Service-Oriented Computing (SOC).\nArtifacts are structures that \u201ccombine data and process in an holistic manner as the basic building block[s]\u201d (Cohn & Hull, 2009) of systems\u2019 descriptions. Artifact systems are services constituted by complex workflow schemes based on artifacts which the agents interact with. The data component is given by the relational databases underpinning the artifacts in a system, whereas the workflows are described by \u201clifecycles\u201d associated with each artifact schema. While in the standard services paradigm services are made public by exposing their processes interface, in artifact systems both the data structures and the lifecycles are advertised. Services are composed in a \u201chub\u201d where operations on the artifacts are executed. Implementations of artifact systems, such as the IBM engine BARCELONA (Heath, Hull, & Vacul\u0131\u0301n, 2011), provide a hub where the service choreography and service orchestratation (Alonso, Casati, Kuno, & Machiraju, 2004) are carried out.\nWhile artifact systems are beginning to drive new application areas, such as case management systems (Marin, Hull, & Vacul\u0131\u0301n, 2012), we identify two shortcomings in the present state-of-theart. Firstly, the artifact systems literature (Bhattacharya, Gerede, Hull, Liu, & Su, 2007; Deutsch, Hull, Patrizi, & Vianu, 2009; Hull, 2008; Nooijen, Fahland, & Dongen, 2012) focuses exclusively on the artifacts themselves. While there is obviously a need to model and implement the artifact infrastructure, importantly we also need to account for the agents implementing the services acting on the artifact system. This is of particular relevance given that artifact systems are envisaged to play a leading role in information systems. We need to be able to reason not just about the artifact states but also about what actions specific participants are allowed and not allowed to do, what knowledge they can or cannot derive in a system run, what system state they can achieve in coordination with their peers, etc. In other words, we need to move from the description of the artifact infrastructure to one that encompasses both the agents and the infrastructure.\nSecondly, there is a pressing demand to provide the hub with automatic choreography and orchestration capabilities. It is well-known that choreography techniques can be leveraged on automatic model checking techniques; orchestration can be recast as a synthesis problem, which, in turn, can also benefit from model checking technology. However, while model checking and its applications are relatively well-understood in the plain process-based modelling, the presence of data makes these problems much harder and virtually unexplored. Additionally, infinite domains in the underlying databases lead to infinite state-spaces and undecidability of the model checking problem.\nThe aim of this paper is to make a concerted contribution to both problems above. Firstly, we provide a computationally grounded semantics to systems comprising the artifact infrastructure and the agents operating on it. We use this semantics to interpret a temporal-epistemic language with first-order quantifiers to reason about the evolution of the hub as well as the knowledge of the agents in the presence of evolving, structured data. We observe that the model checking problem for these structures is undecidable in general and analyse two notable decidable fragments. In this context, a contribution we make is to provide finite abstractions to infinite-state artifact systems, thereby presenting a technique for their effective verification for a class of declarative agent-based, artifact-centric programs that we here define. We evaluate this methodology by studying its compu-\ntational complexity and by demonstrating its use on a well-known scenario from the artifact systems literature."}, {"heading": "1.1 Artifact-Centric Systems", "text": "Service-oriented computing is concerned with the study and development of distributed applications that can be automatically discovered and composed by means of remote interfaces. A point of distinction over more traditional distributed systems is the interoperability and connectedness of services and the shared format for both data and remote procedure calls. Two technology-independent concepts permeate the service-oriented literature: orchestration and choreography (Alonso et al., 2004; Singh & Huhns, 2005). Orchestration involves the ordering of actions of possibly different services, facilitated by a controller or orchestrator, to achieve a certain overall goal. Choreography concerns the distributed coordination of different actions through publicly observable events to achieve a certain goal. A MAS perspective (Wooldridge, 2001) is known to be particularly helpful in service-oriented computing in that it allows us to ascribe information states and private or common goals to the various services. Under this view the agents of the system implement the services and interact with one another in a shared infrastructure or environment.\nA key theoretical problem in SOC is to devise effective mechanisms to verify that service composition is correct according to some specification. Techniques based on model checking (Clarke et al., 1999) and synthesis (Berardi, Cheikh, Giacomo, & Patrizi, 2008) have been put forward to solve the composition and orchestration problem for services described and advertised at interface level through finite state machines (Calvanese, Giacomo, Lenzerini, Mecella, & Patrizi, 2008). More recently, attention has turned to services described by languages such as WS-BPEL (Alves et al., 2007), which provide potentially unbounded variables in the description of the service process. Again, model checking approaches have successfully been used to verify complex service compositions (Bertoli, Pistore, & Traverso, 2010; Lomuscio, Qu, & Solanki, 2012).\nWhile WS-BPEL provides a model for services with variables, the data referenced by them is non-permanent. The area of data-centric workflows (Hull, Narendra, & Nigam, 2009; Nigam & Caswell, 2003) evolved as an attempt to provide support for permanent data, typically present in the form of underlying databases. Although usually abstracted away, permanent data is of central importance to services, which typically query data sources and are driven by the answers they obtain; see, e.g., (Berardi, Calvanese, Giacomo, Hull, & Mecella, 2005). Therefore, a faithful model of a service behavior cannot, in general, disregard this component. In response to this, proposals have been made in the workflows and service communities in terms of declarative specifications of data-centric services that are advertised for automatic discovery and composition. The artifactcentric approach (Cohn & Hull, 2009) is now one of the leading emerging paradigms in the area. As described in (Hull, 2008; Hull, Damaggio, De Masellis, Fournier, Gupta, Heath, Hobson, Linehan, Maradugu, Nigam, Sukaviriya, & Vaculin, 2011) artifact-centric systems can be presented along four dimensions.\nArtifacts are the holders of all structured information available in the system. In a businessoriented scenario this may include purchase orders, invoices, payment records, etc. Artifacts may be created, amended, and destroyed at run time; however, abstract artifact schemas are provided at design time to define the structure of all artifacts to be manipulated in the system. Intuitively, external events cause changes in the system, including in the value of artifact attributes.\nThe evolution of artifacts is governed by lifecycles. These capture the changes that an artifact may go through from creation to deletion. Intuitively, a purchase order may be created, amended and operated on by several events before it is fullfilled and its existence in the system terminated: a lifecycle associated with a purchase order artifact formalises these transitions.\nServices are seen as the actors operating on the artifact system. They represent both human and software actors, possibly distributed, that generate events on the artifact system. Some services may \u201cown\u201d artifacts, and some artifacts may be shared by several services. However, not all artifacts, or parts of artifacts, are visible to all services. Views and windows respectively determine which parts of artifacts and which artifact instances are visible to which service. An artifact hub is a system that maintains the artifact system and processes the events generated by the services.\nServices generate events on the artifact system according to associations. Typically these are declarative descriptions providing the precondition and postconditions for the generation of events. These generate changes in the artifact system according to the artifact lifecycles. Since events may trigger changes in several artifacts in the system, events are processed by a well-defined semantics (Damaggio, Hull, & Vacul\u0131\u0301n, 2011; Hull et al., 2011) that governs the sequence of changes an artifact-system may undertake upon consumption of an event. Such a semantics, based on the use of Prerequisite-Antecedent-Consequent (PAC) rules, ensures acyclicity and full determinism in the updates on the artifact system. GSM is a declarative language that can be used to describe artifact systems. BARCELONA is an engine that can be used to run a GSM-based artifact-centric system (Heath et al., 2011).\nThe above is a partial and incomplete description of the artifact paradigm. We refer to (Cohn & Hull, 2009; Hull, 2008; Hull et al., 2011) for more details.\nAs it will be clear in the next section, in line with the agent-based approach to services, we will use agent-based concepts to model services. The artifact-system will be represented as an environment, constituted by evolving databases, upon which the agents operate; lifecycles and associations will be modelled by local and global transition functions. The model is intended to incorporate all artifact-related concepts including views and windows.\nIn view of the above in this paper we address the following questions. How can we give a transition-based semantics for artifacts and agents operating on them? What syntax should we use to specify properties of the agents and the artifacts themselves? Can we verify that an artifact system satisfies certain properties? As this will be shown to be undecidable, can we find suitable fragments on which this can actually be carried out? If so, what is the resulting complexity? Lastly, can we provide declarative specifications for the agent programs so that these can be verified by model checking? Can this technique be used on mainstream scenarios from the SOC literature?\nThis paper intends to contribute answering these questions."}, {"heading": "1.2 Related Work", "text": "As stated above, virtually all current literature on artifact-centric systems focuses on properties and implementations of the artifact-system as such. Little or no attention is given to the actors on the system, whether they are human or artificial agents. A few formal techniques have, however, been put forward to verify the core, non-agent aspects of the system; in the following we briefly compare these to this contribution.\nTo our knowledge the verification of artifact-centric business processes was first discussed in (Bhattacharya et al., 2007), where reachability and deadlocks are phrased in the context of\nartifact-centric systems and complexity results for the verification problem are given. The present contribution differs markedly from (Bhattacharya et al., 2007) by employing a more expressive specification language, even if the agent-related aspects are not considered, and by putting forward effective abstraction procedures for verification.\nIn (Gerede & Su, 2007) a verification technique for artifact-centric systems against a variant of computation-tree logic is put forward. The decidability of the verification problem is proven for the language considered under the assumption that the interpretation domain is bounded. Decidability is also shown for the unbounded case by making restrictions on the values that quantified variables can range over. In the work here presented we also work on unbounded domains, but do not require the restrictions present in (Gerede & Su, 2007): we only insist on the fact that the number of distinct values in the system does not exceed a given threshold at any point in any run. Most importantly, the interplay between quantification and modalities here considered allows us to bind and use variables in different states. This is a major difference as this feature is very expressive and known to lead to undecidability.\nA related line of research is followed in (Deutsch et al., 2009; Damaggio, Deutsch, & Vianu, 2012), where the verification problem for artifact systems against two variants of first-order lineartime temporal logic is considered. Decidability of the verification problem is retained by imposing syntactic restrictions on both the system descriptions and the specifications to check. This effectively limits the way in which new values introduced at every computational step can be used by the system. Properties based on arithmetic operators are considered in (Damaggio et al., 2012). While there are elements of similarity between these approaches and the one we put forward here, including the fact that the concrete interpretation domain is replaced by an abstract one, the contribution here presented has significant differences from these. Firstly, our setting is branching-time and not linear-time thereby resulting in different expressive power. Secondly, differently from (Deutsch et al., 2009; Damaggio et al., 2012), we impose no constraints on nested quantifiers. In contrast, (Damaggio et al., 2012) admits only universal quantification over combinations of quantifier-free first-order formulas. Thirdly, the abstraction results we present here are given in general terms on the semantics of declarative programs and do not depend on a particular presentation of the system.\nMore closely related to the present contribution is (Hariri, Calvanese, Giacomo, Deutsch, & Montali, 2012), where conditions for the decidability of the model checking problem for datacentric dynamic systems, e.g., dynamic systems with relational states, are given. In this case the specification language used is a first-order version of the \u00b5-calculus. While our temporal fragment is subsumed by the \u00b5-calculus, since we use indexed epistemic modalities as well as a common knowledge operator, the two specification languages have different expressive power. To retain decidability, like we do here, the authors assume a constraint on the size of the states. However, differently from the contribution here presented, (Hariri et al., 2012) assume limited forms of quantification whereby only individuals persisting in the system evolution can be quantified over. In this contribution we do not make this restriction.\nIrrespective of what above, the most important feature that characterises our work is that the set-up is entirely based on epistemic logic and multi-agent systems. We use agents to represent the autonomous services operating in the system and agent-based concepts play a key role in the modelling, the specifications, and the verification techniques put forward. Differently from all approaches presented above we are not only concerned with whether the artifact-system meets a particular specification. Instead, we also wish to consider what knowledge the agents in the system acquire by interacting among themselves and with the artifact-system during a system run. Ad-\nditionally, the abstraction methodology put forward is modular with respect to the agents in the system. These features enable us to give constructive procedures for the generation of finite abstractions for artifact-centric programs associated with infinite models. We are not aware of any work in the literature tackling any of these aspects.\nRelation to previous work by the authors. This paper combines and expands preliminary results originally discussed in (Belardinelli, Lomuscio, & Patrizi, 2011a), (Belardinelli, Lomuscio, & Patrizi, 2011b), (Belardinelli, Lomuscio, & Patrizi, 2012a), and (Belardinelli, Lomuscio, & Patrizi, 2012b). In particular, the technical set up of artifacts and agents is different from that of our preliminary studies and makes it more natural to express artifact-centric concepts such as views. Differently from our previous attempts we here incorporate an operator for common knowledge and provide constructive methods to define abstractions for all notions of bisimulation. We also consider the complexity of the verification problem, previously unexplored, and evaluate the technique in detail on a case study."}, {"heading": "1.3 Scheme of the Paper", "text": "The rest of the paper is organised as follows. In Section 2 we introduce Artifact-centric MultiAgent Systems (ACMAS), the semantics we will be using throughout the paper to describe agents operating on an artifact system. In the same section we put forward FO-CTLK, a first-order logic with knowledge and time to reason about the evolution of the knowledge of the agents and the artifact system. This enables us to propose a satisfaction relation based on the notion of bounded quantification, define the model checking problem, and highlight some properties of isomorphic states.\nAn immediate result we will explore concerns the undecidability of the model checking problem for ACMAS in their general setting. Section 3 is concerned with synctactical restrictions on FOCTLK that enable us to guarantee the existence of finite abstractions of infinite-state ACMAS, thereby making the model checking problem feasible by means of standard techniques.\nSection 4 tackles restrictions orthogonal to those of Section 3 by focusing on a subclass of ACMAS that admits a decidable model checking problem when considering full FO-CTLK specifications. The key finding here is that bounded and uniform ACMAS, a class identified by studying a strong bisimulation relation, admit finite abstractions for any FO-CTLK specification. The section concludes by showing that under these restrictions the model checking problem is EXPSPACEcomplete.\nWe turn our attention to artifact programs in Section 6 by defining the concept of artifact-centric programs. We define them through natural, first-order preconditions and postconditions in line with the artifact-centric approach. We give a semantics to them in terms of ACMAS and show that their generated models are precisely those uniform ACMAS studied earlier in the paper. It follows that, under some boundedness conditions, which can be naturally expressed, the model checking problem for artifact-centric programs is decidable and can be executed on finite models.\nSection 7 reports a scenario from the artifact systems literature. This is used to exemplify the technique by providing finite abstractions that can be effectively verified.\nWe conclude in Section 8 where we consider the limitations of the approach and point to further work."}, {"heading": "2. Artifact-Centric Multi-Agent Systems", "text": "In this section we formalise artifact-centric systems and state their verification problem. As data and databases are important constituents of artifact systems, our formalisation of artifacts relies on them as underpinning concepts. However, as discussed in the previous section, we here give prominence to agent-based concepts. As such, we define our systems as comprising both the artifacts in the system as well as the agents that interact with the system.\nA standard paradigm for logic-based reasoning about agent systems is interpreted systems (Parikh & Ramanujam, 1985; Fagin et al., 1995). In this setting agents are endowed with private local states and evolve by performing actions according to an individual protocol. As data play a key part, as well as to allow us to specify properties of the artifact system, we will define the agents\u2019 local states as evolving database instances. We call this formalisation artifact-centric multi-agent systems (ACMAS). AC-MAS enable us to represent naturally and concisely concepts much used in the artifact paradigm such as the one of view discussed earlier.\nOur specification language will include temporal-epistemic logic but also quantification over a domain so as to represent the data. This is an usual verification setting, so we will formally define the model checking problem for this set up."}, {"heading": "2.1 Databases and First-Order Logic", "text": "As discussed above, we use databases as the basic building blocks for defining the states of the agents and the artifact system. We here fix the notation and terminology used. We refer to (Abiteboul, Hull, & Vianu, 1995) for more details on databases.\nDefinition 2.1 (Database Schemas) A (relational) database schema is a set D = {P1/q1, . . . , Pn/qn} of relation symbols Pi, each associated with its arity qi \u2208 N.\nInstances of database schemas are defined over interpretation domains.\nDefinition 2.2 (Database Instances) Given an interpretation domain U and a database schema D, a D-instance over U is a mapping D associating each relation symbol Pi \u2208 D with a finite qi-ary relation over U , i.e., D(Pi) \u2286 U qi .\nThe set of all D-instances over an interpretation domain U is denoted by D(U). We simply refer to \u201cinstances\u201d whenever the database schema D is clear by the context. The active domain of an instance D, denoted as adom(D), is the set of all individuals in U occurring in some tuple of some predicate interpretation D(Pi). Observe that, since D contains a finite number of relation symbols and each D(Pi) is finite, so is adom(D).\nTo fix the notation, we recall the syntax of first-order formulas with equality and no function symbols. Let V ar be a countable set of individual variables and C be a finite set of individual constants. A term is any element t \u2208 V ar \u222aC .\nDefinition 2.3 (FO-formulas over D) Given a database schema D, the formulas \u03d5 of the firstorder language LD are defined by the following BNF grammar:\n\u03d5 ::= t = t\u2032 | Pi(t1, . . . , tqi) | \u00ac\u03d5 | \u03d5 \u2192 \u03d5 | \u2200x\u03d5\nwhere Pi \u2208 D, t1, . . . , tqi is a qi-tuple of terms and t, t \u2032 are terms.\nWe assume \u201c=\u201d to be a special binary predicate with fixed obvious interpretation. To summarise, LD is a first-order language with equality over the relational vocabulary D with no function symbols and with finitely many constant symbols from C . Observe that considering a finite set of constants is not a limitation. Indeed, since we will be working with finite sets of formulas, C can always be defined so as to be able to express any formula of interest.\nIn the following we use the standard abbreviations \u2203, \u2227, \u2228, and 6=. Also, free and bound variables are defined as standard. For a formula \u03d5 we denote the set of its variables as vars(\u03d5), the set of its free variables as free(\u03d5), and the set of its constants as const(\u03d5). We write \u03d5(~x) to list explicitly in arbitrary order all the free variables x1, . . . , x\u2113 of \u03d5. By slight abuse of notation, we treat ~x as a set, thus we write ~x = free(\u03d5). A sentence is a formula with no free variables.\nGiven an interpretation domain U such that C \u2286 U , an assignment is a function \u03c3 : V ar 7\u2192 U . For an assignment \u03c3, we denote by \u03c3\n(x u ) the assignment such that: (i) \u03c3 (x u )\n(x) = u; and (ii) \u03c3 (x u )\n(x\u2032) = \u03c3(x\u2032), for every x\u2032 \u2208 V ar different from x. For convenience, we extend assignments to constants so that \u03c3(t) = t, if t \u2208 C; that is, we assume a Herbrand interpretation of constants. We can now define the semantics of LD.\nDefinition 2.4 (Satisfaction of FO-formulas) Given a D-instance D, an assignment \u03c3, and an FO-formula \u03d5 \u2208 LD, we inductively define whether D satisfies \u03d5 under \u03c3, written (D,\u03c3) |= \u03d5, as follows:\n(D,\u03c3) |= Pi(t1, . . . , tqi) iff \u3008\u03c3(t1), . . . , \u03c3(tqi)\u3009 \u2208 D(Pi) (D,\u03c3) |= t = t\u2032 iff \u03c3(t) = \u03c3(t\u2032) (D,\u03c3) |= \u00ac\u03d5 iff it is not the case that (D,\u03c3) |= \u03d5 (D,\u03c3) |= \u03d5 \u2192 \u03c8 iff (D,\u03c3) |= \u00ac\u03d5 or (D,\u03c3) |= \u03c8 (D,\u03c3) |= \u2200x\u03d5 iff for all u \u2208 adom(D), we have that (D,\u03c3\n(x u ) ) |= \u03d5\nA formula \u03d5 is true in D, written D |= \u03d5, iff (D,\u03c3) |= \u03d5, for all assignments \u03c3.\nObserve that we adopt an active-domain semantics, that is, quantified variables range only over the active domain of D. Also notice that constants are interpreted rigidly; so, two constants are equal if and only if they are syntactically the same. In the rest of the paper, we assume that every interpretation domain includes C . Also, as a usual shortcut, we write (D,\u03c3) 6|= \u03d5 to express that it is not the case that (D,\u03c3) |= \u03d5.\nFinally, we introduce the \u2295 operator on D-instances that will be used later in the paper. Let the primed version of a database schema D be the schema D\u2032 = {P \u20321/q1, . . . , P \u2032 n/qn} obtained from D by syntactically replacing each predicate symbol Pi with its primed version P \u2032i of the same arity.\nDefinition 2.5 (\u2295 Operator) Given two D-instances D and D\u2032, we define D\u2295D\u2032 as the (D\u222aD\u2032)instance such that D \u2295D\u2032(Pi) = D(Pi) and D \u2295D\u2032(P \u2032i ) = D \u2032(Pi).\nIntuitively, the \u2295 operator defines a disjunctive join of the two instances, where relation symbols in D are interpreted according to D, while their primed versions are interpreted according to D\u2032."}, {"heading": "2.2 Artifact-Centric Multi-Agent Systems", "text": "In the following we introduce the semantic structures that we will use throughout the paper. We define an artifact-centric multi-agent system as a system comprising an environment representing all interacting artifacts in the system and a finite set of agents interacting with such environment.\nAs agents have views of the artifact state, i.e., projections of the status of particular artifacts, we assume the building blocks of their private local states also to be modelled as database instances. In line with the interpreted systems semantics (Fagin et al., 1995) not everything in the agents\u2019 states needs to be present in the environment; a portion of it may be entirely private and not replicated in other agents\u2019 states. So, we start by introducing the notion of agent.\nDefinition 2.6 (Agent) Given an interpretation domain U , an agent is a tuple A = \u3008D, L,Act, Pr\u3009, where:\n\u2022 D is the local database schema;\n\u2022 L \u2286 D(U) is the set of local states;\n\u2022 Act is the finite set of action types of the form \u03b1(~p), where ~p is the tuple of abstract parameters;\n\u2022 Pr : L 7\u2192 2Act(U) is the local protocol function, where Act(U) is the set of ground actions of the form \u03b1(~u) where \u03b1(~p) \u2208 Act and ~u \u2208 U |~p| is a tuple of ground parameters.\nIntuitively, at a given time each agent A is in some local state l \u2208 D(U) that represents all the information agent A has at its disposal. In this sense we follow (Fagin et al., 1995) but require that this information is structured as a database. Again, following standard literature we assume that the agents are autonomous and proactive and perform the actions in Act according to the protocol function Pr. In the definition above we distinguish between \u201cabstract parameters\u201d to denote the language in which particular action parameters are given, and their concrete values or \u201cground parameters\u201d.\nWe assume that the agents interact among themselves and with an environment comprising all artifacts in the system. As artifacts are entities involving both data and process, we can see them as collections of database instances paired with actions and governed by special protocols. Without loss of generality we can assume the environment state to be a single database instance including all artifacts in the system. From a purely formal point of view this allows us to represent the environment as a special agent. Of course, in any specific instantiation the environment and the agents will be rather different, exactly in line with the standard propositional version of interpreted systems.\nWe can therefore define the synchronous composition of agents with the environment.\nDefinition 2.7 (Artifact-Centric Multi-Agent Systems) Given an interpretation domain U and a set Ag = {A0, . . . , An} of agents Ai = \u3008Di, Li, Acti, P ri\u3009 defined on U , an artifact-centric multiagent system (or AC-MAS) is a tuple P = \u3008S, U, s0, \u03c4\u3009 where:\n\u2022 S \u2286 L0 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Ln is the set of reachable global states;\n\u2022 U is the interpretation domain;\n\u2022 s0 \u2208 S is the initial global state;\n\u2022 \u03c4 : S \u00d7 Act(U) 7\u2192 2S is the global transition function, where Act(U) = Act0(U) \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Actn(U) is the set of global (ground) actions, and \u03c4(\u3008l0, . . . , ln\u3009, \u3008\u03b10(~u0), . . . , \u03b1n(~un)\u3009) is defined iff \u03b1i(~ui) \u2208 Pri(li) for every i \u2264 n.\nAs we will see in later sections, AC-MAS are the natural extension of interpreted systems to the first order to account for environments constituted of artifact-centric systems. They can be seen as a specialisation of quantified interpreted systems (Belardinelli & Lomuscio, 2012), a general extension of interpreted systems to the first-order case.\nIn the formalisation above the agent A0 is referred to as the environment E. The environment includes all artifacts in the system as well as additional information to facilitate communication between the agents and the hub, e.g., messages in transit etc. At any given time an AC-MAS is described by a tuple of database instances, representing all the agents in the system as well as the artifact system. A single interpretation domain for all database schemas is given. Note that this does not break the generality of the representation as we can always extend the domain of all agents and the environment before composing them into a single AC-MAS. The global transition function defines the evolution of the system through synchronous composition of actions for the environment and all agents in the system.\nMuch of the interaction we are interested in modelling involves message exchanges with payload, hence the action parameters, between agents and the environment, i.e., agents operating on the artifacts. However, note that the formalisation above does not preclude us from modelling agent-toagent interactions, as the global transition function does not rule out successors in which only some agents change their local state following some actions. Also observe that essential concepts such as views are naturally expressed in AC-MAS by insisting that the local state of an agent includes part of the environment\u2019s, i.e., the artifacts the agent has access to. Not all AC-MAS need to have views defined, so it is also possible for the views to be empty.\nOther artifact-based concepts such as lifecycles are naturally expressed in AC-MAS. As artifacts are modelled as part of the environment, a lifecycle is naturally encoded in AC-MAS simply as the sequence of changes induced by the transition function \u03c4 on the fragment of the environment representing the lifecycle in question. We will show an example of this in Section 7.\nSome technical remarks now follow. To simplify the notation, we denote a global ground action as ~\u03b1(~u), where ~\u03b1 = \u3008\u03b10(p0), . . . , \u03b1n(pn)\u3009 and ~u = \u3008~u0, . . . , ~un\u3009, with each ~ui of appropriate size. We define the transition relation \u2192 on S \u00d7 S such that s \u2192 s\u2032 if and only if there exists a ~\u03b1(~u) \u2208 Act(U) such that s\u2032 \u2208 \u03c4(s, ~\u03b1(~u)). If s \u2192 s\u2032, we say that s\u2032 is a successor of s. A run r from s \u2208 S is an infinite sequence s0 \u2192 s1 \u2192 \u00b7 \u00b7 \u00b7 , with s0 = s. For n \u2208 N, we take r(n) . = sn. A state s\u2032 is reachable from s if there exists a run r from the global state r(0) = s such that r(i) = s\u2032, for some i \u2265 0. We assume that the relation \u2192 is serial. This can be easily obtained by assuming that each agent has a skip action enabled at each local state and that performing skip induces no changes in any of the local states. We consider S to be the set of states reachable from the initial state s0. For convenience we will use also the concept of temporal-epistemic (t.e., for short) run. Formally a t.e. run r from a state s \u2208 S is an infinite sequence s0 \u2740 s1 \u2740 . . . such that s0 = s and si \u2192 si+1 or si \u223ck si+1, for some k \u2208 Ag. A state s\u2032 is said to be temporally-epistemically reachable (t.e. reachable, for short) from s if there exists a t.e. run r from the global state r(0) = s such that for some i \u2265 0 we have that r(i) = s\u2032. Obviously, temporal-epistemic runs include purely temporal runs as a special case.\nAs in plain interpreted systems (Fagin et al., 1995), we say that two global states s = \u3008l0, . . . , ln\u3009 and s\u2032 = \u3008l\u20320, . . . , l \u2032 n\u3009 are epistemically indistinguishable for agent Ai, written s \u223ci s\n\u2032, if li = l\u2032i. Differently from interpreted systems the local equality is evaluated on database instances. Also, notice that we admit U to be infinite, thereby allowing the possibility of the set of states S to be\ninfinite. Indeed, unless we specify otherwise, we will assume to be working with infinite-state AC-MAS.\nFinally, for technical reasons it is useful to refer to a global database schema D = D0\u222a\u00b7 \u00b7 \u00b7\u222aDn of an AC-MAS. Every global state s = \u3008l0, . . . , ln\u3009 is associated with the (global) D-instance Ds \u2208 D(U) such that Ds(Pi) = \u22c3\nj\u2208Ag lj(Pi), for Pi \u2208 D. We omit the subscript s when s is clear from the context and we write adom(s) for adom(Ds). Notice that for every s \u2208 S , the Ds associated with s is unique, while the converse is not true in general."}, {"heading": "2.3 Model Checking", "text": "We now define the problem of verifying an artifact-centric multi-agent system against a specification of interest. By following the artifact-centric model, we wish to give data the same prominence as processes. To deal with data and the underlying database instances, our specification language needs to include first-order logic. Further, we require temporal logic to describe the system execution. Lastly, we use epistemic logic to express the information the agents have at their disposal. Hence, we define a first-order temporal epistemic specification language to be interpreted on AC-MAS. The specification language will be used in Section 6 to formalise properties of artifact-centric programs.\nDefinition 2.8 (The Logic FO-CTLK) The first-order CTLK (or FO-CTLK) formulas \u03d5 over a database schema D are inductively defined by the following BNF:\n\u03d5 ::= \u03c6 | \u00ac\u03d5 | \u03d5 \u2192 \u03d5 | \u2200x\u03d5 | AX\u03d5 | A\u03d5U\u03d5 | E\u03d5U\u03d5 | Ki\u03d5 | C\u03d5\nwhere \u03c6 \u2208 LD and 0 < i \u2264 n.\nThe notions of free and bound variables for FO-CTLK extend straightforwardly from LD, as well as functions vars, free, and const. As usual, the temporal formulas AX\u03d5 and A\u03d5U\u03d5\u2032 (resp. E\u03d5U\u03d5\u2032) are read as \u201cfor all runs, at the next step \u03d5\u201d and \u201cfor all runs (resp. some run), \u03d5 until \u03d5\u2032\u201d. The epistemic formulas Ki\u03d5 and C\u03d5 intuitively mean that \u201cagent Ai knows \u03d5\u201d and \u201cit is common knowledge among all agents that \u03d5\u201d respectively. We use the abbreviations EX\u03d5, AF\u03d5, AG\u03d5, EF\u03d5, and EG\u03d5 as standard. Observe that free variables can occur within the scope of modal operators, thus allowing for the unconstrained alternation of quantifiers and modal operators, thereby allowing us to refer to elements in different modal contexts. We consider also a number of fragments of FO-CTLK. The sentence atomic version of FO-CTLK without epistemic modalities, or SA-FO-CTL, is the language obtained from Definition 2.8 by removing the clauses for epistemic operators and restricting atomic formulas to first-order sentences, so that no variable appears free in the scope of a modal operator:\n\u03d5 ::= \u03c6 | \u00ac\u03d5 | \u03d5 \u2192 \u03d5 | AX\u03d5 | A\u03d5U\u03d5 | E\u03d5U\u03d5\nwhere \u03c6 \u2208 LD is a sentence. We will consider also the language FO-ECTLK, i.e., the existential fragments of FO-CTLK, defined as follows:\n\u03d5 ::= \u03c6 | \u03d5 \u2227 \u03d5 | \u03d5 \u2228 \u03d5 | \u2200x\u03d5 | \u2203x\u03d5 | EX\u03d5 | E\u03d5U\u03d5 | K\u0304i\u03d5 | C\u0304\u03d5,\nwhere \u03c6 \u2208 LD, with \u2227 and \u2228 the standard abbreviations, K\u0304i\u03d5 \u2261 \u00acKi\u00ac\u03d5, and C\u0304\u03d5 \u2261 \u00acC\u00ac\u03d5. The semantics of FO-CTLK formulas is defined as follows.\nDefinition 2.9 (Satisfaction for FO-CTLK) Consider an AC-MAS P, an FO-CTLK formula \u03d5, a state s \u2208 P, and an assignment \u03c3. We inductively define whether P satisfies \u03d5 in s under \u03c3, written (P, s, \u03c3) |= \u03d5, as follows:\n(P, s, \u03c3) |= \u03d5 iff (Ds, \u03c3) |= \u03d5, if \u03d5 is an FO-formula (P, s, \u03c3) |= \u00ac\u03d5 iff it is not the case that (P, s, \u03c3) |= \u03d5 (P, s, \u03c3) |= \u03d5 \u2192 \u03d5\u2032 iff (P, s, \u03c3) |= \u00ac\u03d5 or (P, s, \u03c3) |= \u03d5\u2032 (P, s, \u03c3) |= \u2200x\u03d5 iff for all u \u2208 adom(s), (P, s, \u03c3 (x u )\n) |= \u03d5 (P, s, \u03c3) |= AX\u03d5 iff for all runs r, if r(0) = s, then (P, r(1), \u03c3) |= \u03d5 (P, s, \u03c3) |= A\u03d5U\u03d5\u2032 iff for all runs r, if r(0) = s, then there is k \u2265 0 s.t. (P, r(k), \u03c3) |= \u03d5\u2032, and for all j, 0 \u2264 j < k implies (P, r(j), \u03c3) |= \u03d5 (P, s, \u03c3) |= E\u03d5U\u03d5\u2032 iff for some run r, r(0) = s and there is k \u2265 0 s.t. (P, r(k), \u03c3) |= \u03d5\u2032, and for all j, 0 \u2264 j < k implies (P, r(j), \u03c3) |= \u03d5 (P, s, \u03c3) |= Ki\u03d5 iff for all s\u2032, s \u223ci s\u2032 implies (P, s\u2032, \u03c3) |= \u03d5 (P, s, \u03c3) |= C\u03d5 iff for all s\u2032, s \u223c s\u2032 implies (P, s\u2032, \u03c3) |= \u03d5\nwhere \u223c is the transitive closure of \u22c3\n1...n \u223ci.\nA formula \u03d5 is said to be true at a state s, written (P, s) |= \u03d5, if (P, s, \u03c3) |= \u03d5 for all assignments \u03c3. Moreover, \u03d5 is said to be true in P, written P |= \u03d5, if (P, s0) |= \u03d5.\nA key concern in this paper is to explore the model checking of AC-MAS against first-order temporal-epistemic specifications.\nDefinition 2.10 (Model Checking) Model checking an AC-MAS P against an FO-CTLK formula \u03d5 amounts to finding an assignment \u03c3 such that (P, s0, \u03c3) |= \u03d5.\nIt is easy to see that whenever U is finite the model checking problem is decidable as P is a finitestate system. In general this is not the case.\nTheorem 2.11 The model checking problem for AC-MAS w.r.t. FO-CTLK is undecidable.\nProof (sketch). This can be proved by showing that every Turing machine T whose tape contains an initial input I can be simulated by an artifact system PT,I . The problem of checking whether T terminates on that particular input can be reduced to checking whether PT,I |= \u03d5, where \u03d5 encodes the termination condition. The detailed construction is similar to that of Theorem 4.10 of (Deutsch, Sui, & Vianu, 2007).\nGiven the general setting in which the model checking problem is defined above, the negative result is not surprising. In the following we identify syntactic and semantic restrictions for which the problem is decidable."}, {"heading": "2.4 Isomorphisms", "text": "We now investigate the concept of isomorphism on AC-MAS. This will be needed in later sections to produce finite abstractions of infinite-state AC-MAS. In what follows let P = \u3008S, U, s0, \u03c4\u3009 and P \u2032 = \u3008S \u2032, U \u2032, s\u20320, \u03c4\u3009 be two AC-MAS.\nDefinition 2.12 (Isomorphism) Two local states l, l\u2032 \u2208 D(U) are isomorphic, written l \u2243 l\u2032, iff there exists a bijection \u03b9 : adom(l) \u222a C 7\u2192 adom(l\u2032) \u222a C such that:\n(i) \u03b9 is the identity on C;\n(ii) for every Pi \u2208 D, ~u \u2208 U qi , we have that ~u \u2208 l(Pi) iff \u03b9(~u) \u2208 l\u2032(Pi).\nWhen this is the case, we say that \u03b9 is a witness for l \u2243 l\u2032. Two global states s \u2208 S and s\u2032 \u2208 S \u2032 are isomorphic, written s \u2243 s\u2032, iff there exists a bijection \u03b9 : adom(s) \u222a C 7\u2192 adom(s\u2032) \u222a C such that for every j \u2208 Ag, \u03b9 is a witness for lj \u2243 l\u2032j .\nNotice that isomorphisms preserve the constants in C as well as predicates in the local states up to renaming of the corresponding terms. Any function \u03b9 as above is called a witness for s \u2243 s\u2032. Obviously, the relation \u2243 is an equivalence relation. Given a function f : U 7\u2192 U \u2032 defined on adom(s), f(s) denotes the interpretation in D(U \u2032) obtained from s by renaming each u \u2208 adom(s) as f(u). If f is also injective (thus invertible) and the identity on C , then f(s) \u2243 s.\nExample. For an example of isomorphic states, consider an agent with local database schema D = {P1/2, P2/1}, let U = {a, b, c, . . .} be an interpretation domain, and fix the set C = {b} of constants. Let l be the local state such that l(P1) = {\u3008a, b\u3009, \u3008b, d\u3009} and l(P2) = {a} (see Figure 1). Then, the local state l\u2032 such that l\u2032(P1) = {\u3008c, b\u3009, \u3008b, e\u3009} and l\u2032(P2) = {c} is isomorphic to l. This can be easily seen by considering the isomorphism \u03b9, where: \u03b9(a) = c, \u03b9(b) = b, and \u03b9(d) = e. On the other hand, the state l\u2032\u2032 where l\u2032\u2032(P1) = {\u3008f, d\u3009, \u3008d, e\u3009} and l\u2032\u2032(P2) = {f} is not isomorphic to l. Indeed, although a bijection exists that \u201ctransforms\u201d l into l\u2032\u2032, it is easy to see that none can be such that \u03b9\u2032(b) = b.\nNote that, while isomorphic states have the same relational structure, two isomorphic states do not necessarily satisfy the same FO-formulas as satisfaction depends also on the values assigned to free variables. To account for this, we introduce the following notion.\nDefinition 2.13 (Equivalent assignments) Given two states s \u2208 S and s\u2032 \u2208 S \u2032, and a set of variables V \u2286 V ar, two assignments \u03c3 : V ar 7\u2192 U and \u03c3\u2032 : V ar 7\u2192 U \u2032 are equivalent for V w.r.t. s and s\u2032 iff there exists a bijection \u03b3 : adom(s) \u222a C \u222a \u03c3(V ) 7\u2192 adom(s\u2032) \u222a C \u222a \u03c3\u2032(V ) such that:\n(i) \u03b3|adom(s)\u222aC is a witness for s \u2243 s \u2032;\n(ii) \u03c3\u2032|V = \u03b3 \u25e6 \u03c3|V .\nIntuitively, equivalent assignments preserve both the (in)equalities of the variables in V and the constants in s, s\u2032 up to renaming. Note that, by definition, the above implies that s, s\u2032 are isomorphic. We say that two assignments are equivalent for an FO-CTLK formula \u03d5, omitting the states s and s\u2032 when it is clear from the context, if these are equivalent for free(\u03d5).\nWe can now show that isomorphic states satisfy exactly the same FO-formulas.\nProposition 2.14 Given two isomorphic states s \u2208 S and s\u2032 \u2208 S \u2032, an FO-formula \u03d5, and two assignments \u03c3 and \u03c3\u2032 equivalent for \u03d5, we have that\n(Ds, \u03c3) |= \u03d5 iff (Ds\u2032 , \u03c3 \u2032) |= \u03d5\nProof. The proof is by induction on the structure of \u03d5. Consider the base case for the atomic formula \u03d5 \u2261 P (t1, . . . , tk). Then (Ds, \u03c3) |= \u03d5 iff \u3008\u03c3(t1), . . . , \u03c3(tk)\u3009 \u2208 Ds(P ). Since \u03c3 and \u03c3\u2032 are equivalent for \u03d5, and s \u2243 s\u2032, this is the case iff \u3008\u03c3\u2032(t1), . . . , \u03c3\u2032(tk)\u3009 \u2208 Ds\u2032(P ), that is, (Ds\u2032 , \u03c3\n\u2032) |= \u03d5. The base case for \u03d5 \u2261 t = t\u2032 is proved similarly, by observing that the satisfaction of \u03d5 depends only on the assignments, and that the function \u03b3 of Def. 2.13 is a bijection, thus all the (in)equalities between the values assigned by \u03c3 and \u03c3\u2032 are preserved. This is sufficient to guarantee that \u03c3(t) = \u03c3(t\u2032) iff \u03c3\u2032(t) = \u03c3\u2032(t\u2032). The inductive step for the propositional connectives is straightforward. Finally, if \u03d5 \u2261 \u2200y\u03c8, then (Ds, \u03c3) |= \u03d5 iff for all u \u2208 adom(s), (Ds, \u03c3 ( y u )\n) |= \u03c8. Now consider the witness \u03b9 = \u03b3|adom(s)\u222aC for s \u2243 s \u2032, where \u03b3 is as in Def. 2.13. We have that \u03c3 (y u ) and \u03c3\u2032 ( y \u03b9(u) ) are equivalent for \u03c8. By induction hypothesis (Ds, \u03c3 (y u ) ) |= \u03c8 iff (Ds\u2032 , \u03c3\u2032 ( y \u03b9(u) ) ) |= \u03c8. Since \u03b9 is a bijection, this is the case iff for all u\u2032 \u2208 adom(s\u2032), (Ds\u2032 , \u03c3\u2032 ( y u\u2032 ) ) |= \u03c8, i.e., (Ds\u2032 , \u03c3\u2032) |= \u03d5.\nThis leads us to the following result.\nCorollary 2.15 Given two isomorphic states s \u2208 S and s\u2032 \u2208 S \u2032 and an FO-sentence \u03d5, we have that"}, {"heading": "Ds |= \u03d5 iff Ds\u2032 |= \u03d5", "text": "Proof. From right to left. Suppose, by contradiction, that Ds 6|= \u03d5. Then there exists an assignment \u03c3 s.t. (Ds, \u03c3) 6|= \u03d5. Since free(\u03d5) = \u2205, if \u03b9 is a witness for s \u2243 s\u2032, then the assignment \u03c3\u2032 = \u03b9 \u25e6 \u03c3 is equivalent to \u03c3 for s and s\u2032. By Proposition 2.14 we have that (Ds\u2032 , \u03c3\u2032) 6|= \u03d5, that is, Ds\u2032 6|= \u03d5. The case from left to right can be shown similarly.\nThus, isomorphic states cannot be distinguished by FO-sentences. This enables us to use this notion when defining simulations as we will see in the next section."}, {"heading": "3. Abstractions for Sentence Atomic FO-CTL", "text": "In the previous section we have observed that model checking AC-MAS against FO-CTLK is undecidable in general. So, it is clearly of interest to identify decidable settings. In what follows we introduce two main results. The first, presented in this section, identifies restrictions on the language; the second, presented in the next section, focuses on semantic constraints. While these cases are in some sense orthogonal to each other, we show that they both lead to decidable model checking problems. They are also both carried out on a rather natural subclass of AC-MAS that we call bounded, which we identify below. Our goal for proceeding in this manner is to identify finite abstractions of infinite-state AC-MAS so that verification of programs, that admit AC-MAS as models, can be conducted on them, rather than on infinite-state AC-MAS. We will see this in detail in Section 6.\nGiven our aims we begin by defining a first notion of bisimulation in the context of AC-MAS. Bisimulations will be used to show that all bounded AC-MAS admit a finite, bisimilar, abstraction that satisifies the same SA-FO-CTL specifications as the original AC-MAS. Also in what follows we assume that P = \u3008S, U, s0, \u03c4\u3009 and P \u2032 = \u3008S \u2032, U \u2032, s\u20320, \u03c4 \u2032\u3009.\nDefinition 3.1 (Simulation) A relation R \u2286 S \u00d7 S \u2032 is a simulation iff \u3008s, s\u2032\u3009 \u2208 R implies:\n1. s \u2243 s\u2032;\n2. for every t \u2208 S , if s \u2192 t then there exists t\u2032 \u2208 S \u2032 s.t. s\u2032 \u2192 t\u2032 and \u3008t, t\u2032\u3009 \u2208 R.\nDefinition 3.1 presents the standard notion of simulation applied to the case of AC-MAS. The difference from the propositional case is that we here insist on the states being isomorphic, a generalisation from the usual requirement for propositional valuations to be equal (Blackburn, de Rijke, & Venema, 2001). As in the standard case, two states s \u2208 S and s\u2032 \u2208 S \u2032 are said to be similar, written s s\u2032, if there exists a simulation relation R s.t. \u3008s, s\u2032\u3009 \u2208 R. It can be proven that the similarity relation is a simulation itself, and in particular the largest one w.r.t. set inclusion, and that it is transitive and reflexive. Finally, we say that P \u2032 simulates P, written P P \u2032, if s0 s\u20320. We extend the above to bisimulations.\nDefinition 3.2 (Bisimulation) A relation B \u2286 S \u00d7 S \u2032 is a bisimulation iff both B and B\u22121 = {\u3008s\u2032, s\u3009 | \u3008s, s\u2032\u3009 \u2208 B} are simulations.\nWe say that two states s \u2208 S and s\u2032 \u2208 S \u2032 are bisimilar, written s \u2248 s\u2032, if there exists a bisimulation B s.t. \u3008s, s\u2032\u3009 \u2208 B. Similarly to simulations, it can be proven that the bisimilarity relation \u2248 is the largest bismulation. Further, it is an equivalence relation. Finally, P and P \u2032 are said to be bisimilar, written P \u2248 P \u2032, if s0 \u2248 s\u20320.\nSince, as shown in Proposition 2.15, the satisfaction of FO-sentences is invariant under isomorphisms, we can now extend the usual bisimulation result from the propositional case to that of SA-FO-CTL. We begin by showing a result on bisimilar runs.\nProposition 3.3 Consider two AC-MAS P and P \u2032 such that P \u2248 P \u2032, s \u2248 s\u2032, for some s \u2208 S, s\u2032 \u2208 S \u2032, and a run r of P such that r(0) = s. Then there exists a run r\u2032 of P \u2032 such that:\n(i) r\u2032(0) = s\u2032;\n(ii) for all i \u2265 0, r(i) \u2248 r\u2032(i).\nProof. We show by induction that such run r\u2032 in P \u2032 exists. For i = 0, let r\u2032(0) = s\u2032. Obviously, r(0) \u2248 r\u2032(0). Now, assume, by induction hypothesis, that r(i) \u2248 r\u2032(i). Let r(i) \u2192 r(i + 1). Since r(i) \u2248 r\u2032(i), by Def. 3.1, there exists t\u2032 \u2208 S \u2032 such that r\u2032(i) \u2192 t\u2032 and r(i + 1) \u2248 t\u2032. Let r\u2032(i+ 1) = t\u2032; hence we obtain r(i+ 1) \u2248 r\u2032(i+ 1). By definition r\u2032 is a run of P \u2032.\nThis enables us to show that bisimilar AC-MAS preserve SA-FO-CTL formulas. This is an extension of analogous results on propositional CTL.\nLemma 3.4 Consider the AC-MAS P and P \u2032 such that P \u2248 P \u2032, s \u2248 s\u2032, for some s \u2208 S, s\u2032 \u2208 S \u2032 and an SA-FO-CTL formula \u03d5. Then,\n(P, s) |= \u03d5 iff (P \u2032, s\u2032) |= \u03d5\nProof. The proof is by induction on the structure of \u03d5. Observe first that since \u03d5 is sentenceatomic, its satisfaction does not depend on assignments. We report the proof for the left-to-right part of the implication; the converse can be shown similarly.\nThe base case for an FO-sentence \u03d5 follows from Prop. 2.15. The inductive cases for propositional connectives are straightforward.\nFor \u03d5 \u2261 AX\u03c8, assume for contradiction that (P, s) |= \u03d5 and (P \u2032, s\u2032) 6|= \u03d5. Then, there exists a run r\u2032 s.t. r\u2032(0) = s\u2032 and (P \u2032, r\u2032(1)) 6|= \u03c8. By Def. 3.2 and 3.1 there exists a t \u2208 S s.t. s \u2192 t and t \u2248 r\u2032(1). Further, by seriality of \u2192, s \u2192 t can be extended to a run r s.t. r(0) = s and r(1) = t. By the induction hypothesis we obtain that (P, r(1)) 6|= \u03c8. Hence, (P, r(0)) 6|= AX\u03c8, which is a contradiction.\nFor \u03d5 \u2261 E\u03c8U\u03c6, let r be a run with r(0) = s such that there exists k \u2265 0 such that (P, r(k)) |= \u03c6, and for every j, 0 \u2264 j < k implies (P, r(j)) |= \u03c8. By Prop. 3.3 there exists a run r\u2032 s.t. r\u2032(0) = s\u2032 and for all i \u2265 0, r\u2032(i) \u2248 r(i). By the induction hypothesis we have that for each i \u2208 N, (P, r(i)) |= \u03c8 iff (P \u2032, r\u2032(i)) |= \u03c8, and (P, r(i)) |= \u03c6 iff (P \u2032, r\u2032(i)) |= \u03c6. Therefore, r\u2032 is a run s.t. r\u2032(0) = s\u2032, (P \u2032, r\u2032(k)) |= \u03c6, and for every j, 0 \u2264 j < k implies (P \u2032, r\u2032(j)) |= \u03c8, i.e., (P \u2032, s\u2032) |= E\u03c8U\u03c6.\nFor \u03d5 \u2261 A\u03c8U\u03c6, assume for contradiction that (P, s) |= \u03d5 and (P \u2032, s\u2032) 6|= \u03d5. Then, there exists a run r\u2032 s.t. r\u2032(0) = s\u2032 and for every k \u2265 0, if (P \u2032, r\u2032(k)) |= \u03c6, then there exists j s.t. 0 \u2264 j < k and (P \u2032, r\u2032(j)) 6|= \u03c8. By Prop. 3.3 there exists a run r s.t. r(0) = s and for all i \u2265 0, r(i) \u2248 r\u2032(i). Further, by the induction hypothesis we have that (P, r(i)) |= \u03c8 iff (P \u2032, r\u2032(i)) |= \u03c8 and (P, r(i)) |= \u03c6 iff (P \u2032, r\u2032(i)) |= \u03c6. But then r is s.t. r(0) = s and for every k \u2265 0, if (P, r(k)) |= \u03c6, then there exists j s.t. 0 \u2264 j < k and (P, r(j)) 6|= \u03c8. That is, (P, s) 6|= A\u03c8U\u03c6, which is a contradiction.\nBy applying the result above to the case of s = s0 and s\u2032 = s\u20320, we obtain the following.\nTheorem 3.5 Consider the AC-MAS P and P \u2032 such that P \u2248 P \u2032, and an SA-FO-CTL formula \u03d5. We have"}, {"heading": "P |= \u03d5 iff P \u2032 |= \u03d5", "text": "In summary we have proved that bisimilar AC-MAS validate the same SA-FO-CTL formulas. In the next section we use this result to reduce, under additional assumptions, the verification of an infinite-state AC-MAS to that of a finite-state one."}, {"heading": "3.1 Finite Abstractions of Bisimilar AC-MAS", "text": "We now define a notion of finite abstraction for AC-MAS. We prove that abstractions are bisimilar to the corresponding concrete model. We are particularly interested in finite abstraction; so we operate on a special class of infinite models that we call bounded.\nDefinition 3.6 (Bounded AC-MAS) An AC-MAS P is b-bounded, for b \u2208 N, if for all s \u2208 S , |adom(s)| \u2264 b.\nAn AC-MAS is b-bounded if none of its reachable states contains more than b distinct elements. Observe that bounded AC-MAS may be defined on infinite domains U . Furthermore, note that a bbounded AC-MAS may contain infinitely many states, all bounded by b. So b-bounded systems are infinite-state in general. Notice also that the value b bounds only the number of distinct individuals in a state, not the size of the state itself, i.e., the amount of memory required to accommodate the individuals. Indeed, the infinitely many elements of U need an unbounded number of bits to be represented (e.g., as finite strings), so, even though each state is guaranteed to contain at most b distinct elements, nothing can be said about how large the actual space required by such elements is. On the other hand, it should be clear that memory-bounded AC-MAS are finite-state (hence b-bounded, for some b).\nThus, seen as programs, b-bounded AC-MAS are in general memory-unbounded. Therefore, for the purpose of verification, they cannot be trivially checked by generating all their executions \u2013as it would be the case if they were memory-bounded\u2013 like standard model checking techniques typically do. However, we will show later that any b-bounded infinite-state ACMAS admits a finite abstraction which can be used to verify it.\nWe now introduce abstractions in a modular manner by first introducing a set of abstract agents from a concrete AC-MAS.\nDefinition 3.7 (Abstract agent) Let A = \u3008D, L,Act, Pr\u3009 be an agent defined on the interpretation domain U . Given a set U \u2032 of individuals, we define the abstract agent A\u2032 = \u3008D\u2032, L\u2032, Act\u2032, P r\u2032\u3009 on U \u2032 such that:\n1. D\u2032i = Di;\n2. L\u2032i \u2286 D \u2032 i(U \u2032);\n3. Act\u2032i = Acti;\n4. \u03b1(~u\u2032) \u2208 Pr\u2032i(l \u2032 i) iff there exist li \u2208 Li and \u03b1(~u) \u2208 Pri(li) s.t. l \u2032 i \u2243 li, for some witness \u03b9, and\n~u\u2032 = \u03b9\u2032(~u), for some bijection \u03b9\u2032 extending \u03b9 to ~u.\nGiven a set Ag of agents defined on U , let Ag\u2032 be the set of the corresponding abstract agents on U \u2032.\nWe remark that A\u2032, as defined in Definition 3.7, is indeed an agent and complies with Definition 2.6. Notice that the protocol of A\u2032 is defined on the basis of its corresponding concrete agent A and requires the existence of a bijection between the elements in the local states and the action parameters. Thus, in order for a ground action of A to have a counterpart in A\u2032, the last requirement of Definition 3.7 constrains U \u2032 to contain a sufficient number of distinct values. As it will become apparent later, the size of U \u2032 determines how closely an abstract system can simulate its concrete counterpart.\nWe can now formalize the notion of abstraction that we will use in this section.\nDefinition 3.8 (Abstraction) Let P be an AC-MAS over Ag and Ag\u2032 the set of agents obtained as in Definition 3.7, for some U \u2032. The AC-MAS P \u2032 defined over Ag\u2032 is said to be an abstraction of P iff:\n\u2022 s\u20320 \u2243 s0;\n\u2022 t\u2032 \u2208 \u03c4 \u2032(s\u2032, ~\u03b1(~u\u2032)) for some ~\u03b1(~u\u2032) \u2208 Act(U \u2032) iff there exist s, t \u2208 S and ~\u03b1(~u) \u2208 Act(U), such that t \u2208 \u03c4(s, ~\u03b1(~u)), s \u2243 s\u2032 and t \u2243 t\u2032 for some witness \u03b9, and ~u\u2032 = \u03b9\u2032(~u) for some \u03b9\u2032 extending \u03b9.\nNotice that abstractions have initial states isomorphic to their concrete counterparts. The condition in Definition 3.8 means that whenever s \u2243 s\u2032 for some witness \u03b9, ~u\u2032 = \u03b9(~u), t \u2208 \u03c4(s, \u03b1(~u)) and t\u2032 \u2208 \u03c4(s\u2032, \u03b1(~u\u2032)), then t \u2243 t\u2032. This constraint means that action are data-independent. So, for example, a copy action in the concrete model has a corresponding copy action in the abstract model regardless of the data that are copied. Crucially, this condition requires that the domain U \u2032 contains enough elements to simulate the concrete states and action effects as the following result makes precise. In what follows we take NAg = NAg\u2032 = \u2211\nAi\u2208Ag max\u03b1(~p)\u2208Acti{|~p|}, i.e., NAg is the sum\nof the maximum numbers of parameters contained in the action types of each agent in Ag.\nTheorem 3.9 Consider a b-bounded AC-MAS P over an infinite interpretation domain U , an SAFO-CTLK formula \u03d5, and a finite interpretation domain U \u2032 such that C \u2286 U \u2032 and |U \u2032| \u2265 b+ |C|+ NAg. Any abstraction P \u2032 of P is bisimilar to P.\nProof. Define a relation R as R = {\u3008s, s\u2032\u3009 \u2208 S \u00d7 S \u2032 | s \u2243 s\u2032}. We show that R is a bisimulation such that \u3008s0, s\u20320\u3009 \u2208 R. Observe first that s \u2032 0 \u2243 s0, so \u3008s0, s \u2032 0\u3009 \u2208 R. Next, consider s \u2208 S and s\u2032 \u2208 S \u2032 such that s \u2243 s\u2032 (i.e., \u3008s, s\u2032\u3009 \u2208 R), and assume that s \u2192 t, for some t \u2208 S . Then, there exists \u03b1(~u) \u2208 Act(U) s.t. t \u2208 \u03c4(s, \u03b1(~u)). We show next that there exists t\u2032 \u2208 S \u2032 s.t. s\u2032 \u2192 t\u2032 and t \u2243 t\u2032. To this end, observe that, since |U \u2032| \u2265 b + |C| and |adom(t)| \u2264 b, we can define an injective function f : adom(t) \u222a C 7\u2192 U \u2032 such that f(t) \u2243 t. We take t\u2032 = f(t); it remains to prove that s\u2032 \u2192 t\u2032. By the condition on the cardinality of U \u2032 we can extend f to ~u as well, and set ~u\u2032 = f(~u). Then, by the definition of P \u2032 we have that t\u2032 \u2208 \u03c4 \u2032(s\u2032, \u03b1(~u\u2032)). Hence, s\u2032 \u2192 t\u2032. So, R is a simulation relation between P and P \u2032. Since R\u22121 can similarly be shown to be a simulation, it follows that P and P \u2032 are bisimilar.\nBy combining this result with Lemma 3.4, we can easily derive the main result of this section.\nTheorem 3.10 If P is a b-bounded AC-MAS over an infinite interpretation domain U , and P \u2032 an abstraction of P over a finite interpretation domain U \u2032 such that C \u2286 U \u2032 and |U \u2032| \u2265 b+ |C|+NAg, then for every SA-FO-CTLK formula \u03d5, we have that"}, {"heading": "P |= \u03d5 iff P \u2032 |= \u03d5.", "text": "This result states that we can reduce the verification of an infinite AC-MAS to the verification of a finite one. Given the fact that checking a finite AC-MAS is decidable, this is a noteworthy result. Note, however, that we do not have a constructive definition for the construction of an abstract AC-MAS P \u2032 from a concrete AC-MAS P. This is of no consequence though, as in practice any concrete artifact-system will be defined by a program, e.g., in the language GSM, as discussed in the introduction. Of importance, instead, is to be able to derive finite abstractions not just for arbitrary AC-MAS but for those that are models of concrete programs. We will do this in Section 6 where we will use the result above.\nObserve that an abstract AC-MAS as in Definition 3.8 depends on the set Ag\u2032 of abstract agents defined in Definition 3.7. However, other abstract AC-MAS defined on different sets of agents, exist. This is a standard outcome when defining modular abstractions, as the same system can be obtained by considering different agent components."}, {"heading": "4. Abstractions for FO-CTLK", "text": "In the previous section we showed that syntactical restrictions on the specification language lead to finite abstractions for bounded AC-MAS. A natural question that arises is whether the limitation to sentence-atomic specifications can be removed. Doing so would enable us to check any agent-based FO-CTLK specification not on an infinite-state AC-MAS, but on its finite abstraction.\nThe key concept we identify in this section that enables us to achieve the above is that of uniformity. As we will see later uniform AC-MAS are systems for which the behaviour does not depend on the actual data present in the states. This means that the system contains all possible transitions that are enabled according to parametric action rules, thereby resulting in a rather \u201cfull\u201d transition\nrelation. This notion corresponds to that of genericity in databases (Abiteboul et al., 1995). We use the term \u201cuniformity\u201d as we refer to transition systems and not databases.\nTo achieve finite abstractions we proceed as follows. We first introduce a notion of bisimulation stronger than the one discussed in the previous section. In Subsection 4.1 we show that this new bisimulation relation guarantees that uniform AC-MAS satisfy the same formulas in FO-CTLK. We use this result to show that bounded, uniform systems admit finite abstractions (Subsection 4.2).\nIn the rest of the section we let P = \u3008S, U, s0, \u03c4\u3009 and P \u2032 = \u3008S \u2032, U \u2032, s\u20320, \u03c4 \u2032\u3009 be two AC-MAS\nand assume, unless stated differently, that s = \u3008l0, . . . , ln\u3009 \u2208 S , and s\u2032 = \u3008l\u20320, . . . , l \u2032 n\u3009 \u2208 S \u2032."}, {"heading": "4.1 \u2295-Bisimulation", "text": "Plain bisimulations are known to be satisfaction preserving in a modal propositional setting (Blackburn et al., 2001). In the following we explore the conditions under which this applies to AC-MAS as well. We begin by using a notion of bisimulation which is also based on isomorphism, but it is stronger than the one discussed in Section 3 and later explore its properties in the context of uniform AC-MAS.\nDefinition 4.1 (\u2295-Simulation) A relation R on S \u00d7 S \u2032 is a \u2295-simulation if \u3008s, s\u2032\u3009 \u2208 R implies:\n1. s \u2243 s\u2032;\n2. for every t \u2208 S , if s \u2192 t then there exists t\u2032 \u2208 S \u2032 s.t. s\u2032 \u2192 t\u2032, s\u2295 t \u2243 s\u2032\u2295 t\u2032, and \u3008t, t\u2032\u3009 \u2208 R;\n3. for every t \u2208 S , for every 0 < i \u2264 n, if s \u223ci t then there exists t\u2032 \u2208 S \u2032 s.t. t \u223ci t\u2032, s\u2295 t \u2243 s\u2032 \u2295 t\u2032, and \u3008t, t\u2032\u3009 \u2208 R.\nObserve that Definition 4.1 differs from Definition 3.1 not only by adding a condition for the epistemic relation, but also by insisting that s \u2295 t \u2243 s\u2032 \u2295 t\u2032. This condition ensures that the \u2295-similar transitions in AC-MAS have isomorphic disjoint unions. Two states s \u2208 S and s\u2032 \u2208 S \u2032 are said to be \u2295-similar, iff there exists an \u2295-simulation R s.t. \u3008s, s\u2032\u3009 \u2208 R. Note that all \u2295-similar states are isomorphic as condition 2. above ensures that t \u2243 t\u2032. We use the symbol both for similarity and \u2295-similarity, as the context will disambiguate. Also \u2295-similarity can be shown to be the largest \u2295-simulation, reflexive, and transitive. Further, we say that P \u2032 \u2295-simulates P if s0 s\u20320.\n\u2295-simulations can naturally be extended to \u2295-bisimulations.\nDefinition 4.2 (\u2295-Bisimulation) A relation B on S\u00d7S \u2032 is a \u2295-bisimulation iff both B and B\u22121 = {\u3008s\u2032, s\u3009 | \u3008s, s\u2032\u3009 \u2208 B} are \u2295-simulations.\nTwo states s \u2208 S and s\u2032 \u2208 S \u2032 are said to be \u2295-bisimilar iff there exists an \u2295-bisimulation B such that \u3008s, s\u2032\u3009 \u2208 B. Also for bisimilarity and \u2295-bisimilarity, we use the same symbol, \u2248, and can prove that \u2248 is the largest \u2295-bisimulation, and an equivalence relation. We say that P and P \u2032 are \u2295-bisimilar, written P \u2248 P \u2032 iff so are s0 and s\u20320.\nWhile we observed in the previous section that bisimilar, hence isomorphic, states in bisimilar systems preserve sentence atomic formulas, it is instructive to note that this is not the case when full FO-CTLK formulas are considered.\nExample. Consider Figure 2, where C = \u2205 and P and P \u2032 are given as follows. For the number n of agents equal to 1, we define D = D\u2032 = {P/1} and U = N; s0(P ) = s\u20320(P ) = {1};\n\u03c4 = {\u3008s, s\u2032\u3009 | s(P ) = {i}, s\u2032(P ) = {i + 1}}; \u03c4 \u2032 = {\u3008s, s\u2032\u3009 | s(P ) = {i}, s\u2032(P ) = {(i + 1) mod 2}}. Notice that S \u2286 D(N) and S \u2032 \u2286 D(N). Clearly we have that P \u2248 P \u2032. Now, consider the constant-free FO-CTLK formula \u03d5 = AG(\u2200x(P (x) \u2192 AXAG\u00acP (x))). It can be easily seen that P |= \u03d5 while P \u2032 6|= \u03d5.\nThe above shows that \u2295-bisimilarity is not a sufficient condition to guarantee preservation of the satisfaction of FO-CTLK formulas. Intuitively, this is a consequence of the fact that \u2295-bisimilar AC-MAS do not preserve value associations along runs. For instance, the value 1 in P \u2032 is infinitely many times associated with the odd values occurring in P. By quantifying across states we are able to express this fact and are therefore able to distinguish the two structures. This is a difficulty as, intuitively, we would like to use \u2295-bisimulations to demonstrate the existence of finite abstractions. Indeed, as we will show later, this happens for the class of uniform AC-MAS, defined below.\nDefinition 4.3 (Uniformity) An AC-MAS P is said to be uniform iff for every s, t, s\u2032 \u2208 S , t\u2032 \u2208 D(U),\n1. if t \u2208 \u03c4(s, ~\u03b1(~u)) and s \u2295 t \u2243 s\u2032 \u2295 t\u2032 for some witness \u03b9, then for every constant-preserving bijection \u03b9\u2032 that extends \u03b9 to ~u, we have that t\u2032 \u2208 \u03c4(s\u2032, ~\u03b1(\u03b9\u2032(~u)));\n2. if s \u223ci t and s\u2295 t \u2243 s\u2032 \u2295 t\u2032, then s\u2032 \u223ci t\u2032.\nThis definition captures the idea that actions take into account and operate only on the relational structure of states and action parameters, irrespectively of the actual data they contain (apart from a finite set of constants). Intuitively, it says that if t can be obtained by executing \u03b1(~u) in s, and we replace in s, ~u and t, the same element v with v\u2032, obtaining, say, s\u2032, ~u\u2032 and t\u2032, then t\u2032 can be obtained by executing \u03b1(~u\u2032) in s\u2032. In terms of the underlying Kripke structures this means that the systems are \u201cfull\u201d up to \u2295, i.e., in all uniform AC-MAS the points t\u2032 identified above are indeed part of the system and reachable from s\u2032. A similar condition is required on the epistemic relation. A useful property of uniform systems is the fact that the latter requirement is implied by the former, as shown by the following result.\nProposition 4.4 If an AC-MAS P satisfies req. 1 in Def. 4.3 and adom(s0) \u2286 C , then req. 2 is also satisfied.\nProof. If s \u2295 t \u2243 s\u2032 \u2295 t\u2032, then there is a witness \u03b9 : adom(s) \u222a adom(t) \u222a C 7\u2192 adom(s\u2032) \u222a adom(t\u2032) \u222a C that is the identity on C (hence on adom(s0)). Assume s \u223ci t, thus li(s) = li(t), and li(s\u2032) = \u03b9(li(s)) = \u03b9(li(t)) = li(t\u2032). Notice that this does not guarantee that s\u2032 \u223ci t\u2032,\nas we need to prove that t\u2032 \u2208 S . This can be done by showing that t\u2032 is reachable from s0. Since t is reachable from s0, there exists a run s0 \u2192 s1 \u2192 . . . \u2192 sk s.t. sk = t. Extend now \u03b9 to a total and injective function \u03b9\u2032 : adom(s0) \u222a \u00b7 \u00b7 \u00b7 \u222a adom(sk) \u222a C 7\u2192 U . This can always be done because |U | \u2265 |adom(s0) \u222a \u00b7 \u00b7 \u00b7 \u222a adom(sk) \u222a C|. Now consider the sequence \u03b9\u2032(s0), \u03b9 \u2032(s1), . . . , \u03b9 \u2032(sk). Since adom(s0) \u2286 C then \u03b9(s0) = s0 and, because \u03b9\u2032 extends \u03b9, we have that \u03b9\u2032(s0) = \u03b9(s0) = s0. Further, \u03b9\u2032(sk) = \u03b9(t) = t\u2032. By repeated applications of req. 1 we can show that \u03b9\u2032(sm+1) \u2208 \u03c4(\u03b9\u2032(sm), ~\u03b1(\u03b9\u2032(~u))) whenever sm+1 \u2208 \u03c4(sm, ~\u03b1(~u)), for m < k. Hence, the sequence is actually a run from s0 to t\u2032. Thus, t\u2032 \u2208 S , and s\u2032 \u223ci t\u2032.\nThus, as long as adom(s0) \u2286 C , to check whether an AC-MAS is uniform, it is sufficient to take into account only the transition function.\nA further distinctive feature of uniform systems is that all isomorphic states are \u2295-bisimilar.\nProposition 4.5 If an AC-MAS P is uniform, then for every s, s\u2032 \u2208 S , s \u2243 s\u2032 implies s \u2248 s\u2032.\nProof. We prove that B = {\u3008s, s\u2032\u3009 \u2208 S \u00d7 S | s \u2243 s\u2032} is a \u2295-bisimulation. Observe that since \u2243 is an equivalence relation, so is B. Thus B is symmetric and B = B\u22121. Therefore, proving that B is a \u2295-simulation proves also that B\u22121 is a \u2295-simulation; hence, that B is a \u2295-bisimulation. To this end, let \u3008s, s\u2032\u3009 \u2208 B, and assume s \u2192 t for some t \u2208 S . Then, t \u2208 \u03c4(s, \u03b1(~u)) for some \u03b1(~u) \u2208 Act(U). Consider a witness \u03b9 for s \u2243 s\u2032. By cardinality considerations \u03b9 can be extended to a total and injective function \u03b9\u2032 : adom(s)\u222aadom(t)\u222a{~u}\u222aC 7\u2192 U . Consider \u03b9\u2032(t) = t\u2032; it follows that \u03b9\u2032 is a witness for s \u2295 t \u2243 s\u2032 \u2295 t\u2032. Since P is uniform, t\u2032 \u2208 \u03c4(s\u2032, \u03b1(\u03b9\u2032(~u))), that is, s\u2032 \u2192 t\u2032. Moreover, \u03b9\u2032 is a witness for t \u2243 t\u2032, thus \u3008t, t\u2032\u3009 \u2208 B. Next assume that \u3008s, s\u2032\u3009 \u2208 B and s \u223ci t, for some t \u2208 S . By reasoning as above we can find a witness \u03b9 for s \u2243 s\u2032, and an extension \u03b9\u2032 of \u03b9 s.t. t\u2032 = \u03b9\u2032(t) and \u03b9\u2032 is a witness for s\u2295 t \u2243 s\u2032 \u2295 t\u2032. Since P is uniform, s\u2032 \u223ci t\u2032 and \u3008t, t\u2032\u3009 \u2208 B.\nThis result intuitively means that submodels generated by isomorphic states are \u2295-bisimilar. Next we prove some partial results, which will be useful in proving our main preservation theorem. The first two results guarantee that under appropriate cardinality constraints the \u2295-bisimulation preserves the equivalence of assignments w.r.t. a given FO-CTLK formula.\nLemma 4.6 Consider two \u2295-bisimilar and uniform AC-MAS P and P \u2032, two \u2295-bisimilar states s \u2208 S and s\u2032 \u2208 S \u2032, and an FO-CTLK formula \u03d5. For every assignments \u03c3 and \u03c3\u2032 equivalent for \u03d5 w.r.t. s and s\u2032, we have that:\n1. for every t \u2208 S s.t. s \u2192 t, if |U \u2032| \u2265 |adom(s)\u222a adom(t)\u222aC \u222a \u03c3(free(\u03d5))|, then there exists t\u2032 \u2208 S \u2032 s.t. s\u2032 \u2192 t\u2032, t \u2248 t\u2032, and \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. t and t\u2032.\n2. for every t \u2208 S s.t. s \u223ci t, if |U \u2032| \u2265 |adom(s) \u222a adom(t) \u222aC \u222a \u03c3(free(\u03d5))|, then there exists t\u2032 \u2208 S \u2032 s.t. s\u2032 \u223ci t\u2032, t \u2248 t\u2032, and \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. t and t\u2032.\nProof. To prove (1), let \u03b3 be a bijection witnessing that \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. s and s\u2032. Suppose that s \u2192 t. Since s \u2248 s\u2032, by definition of \u2295-bisimulation there exists t\u2032\u2032 \u2208 S \u2032 s.t. s\u2032 \u2192 t\u2032\u2032, s\u2295 t \u2243 s\u2032 \u2295 t\u2032\u2032, and t \u2248 t\u2032\u2032. Now, define Domj . = adom(s) \u222a adom(t) \u222a C , and partition it into:\n\u2022 Dom\u03b3 . = adom(s) \u222a C \u222a (adom(t) \u2229 \u03c3(free(\u03d5));\n\u2022 Dom\u03b9\u2032 . = adom(t) \\Dom\u03b3 .\nLet \u03b9\u2032 : Dom\u03b9\u2032 7\u2192 U \u2032 \\ Im(\u03b3) be an invertible (total) function. Observe that |Im(\u03b3)| = |adom(s\u2032) \u222a C \u222a \u03c3\u2032(free(\u03d5))| = |adom(s) \u222a C \u222a \u03c3(free(\u03d5))|, thus from the fact that |U \u2032| \u2265 |adom(s) \u222a adom(t) \u222a C \u222a \u03c3(free(\u03d5))| we have |U \u2032 \\ Im(\u03b3)| \u2265 |Dom(\u03b9\u2032)|, which guarantees the existence of \u03b9\u2032.\nNext, define j : Domj 7\u2192 U \u2032 as follows:\nj(u) =\n{\n\u03b3(u), if u \u2208 Dom\u03b3 \u03b9\u2032(u), if u \u2208 Dom\u03b9\u2032\nObviously, j is invertible. Thus, j is a witness for s \u2295 t \u2243 s\u2032 \u2295 t\u2032, where t\u2032 = j(t). Since s\u2295 t \u2243 s\u2032 \u2295 t\u2032\u2032 and \u2243 is an equivalence relation, s\u2032 \u2295 t\u2032 \u2243 s\u2032 \u2295 t\u2032\u2032. Thus, s\u2032 \u2192 t\u2032, as P \u2032 is uniform. Moreover, \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. t and t\u2032, by construction of t\u2032. To check that t \u2248 t\u2032, observe that, since t\u2032 \u2243 t\u2032\u2032 and P \u2032 is uniform, by Prop. 4.5 it follows that t\u2032 \u2248 t\u2032\u2032. Thus, since t \u2248 t\u2032\u2032 and \u2248 is transitive, we obtain that t \u2248 t\u2032. The proof for (2) has an analogous structure and is omitted.\nIt can be proven that this result is tight, i.e., that if the cardinality requirement is violated, there exist cases where assignment equivalence is not preserved along temporal or epistemic transitions.\nLemma 4.6 easily generalizes to t.e. runs.\nLemma 4.7 Consider two \u2295-bisimilar and uniform AC-MAS P and P \u2032, two \u2295-bisimilar states s \u2208 S and s\u2032 \u2208 S \u2032, an FO-CTLK formula \u03d5, and two assignments \u03c3 and \u03c3\u2032 equivalent for \u03d5 w.r.t. s and s\u2032. For every t.e. run r of P, if r(0) = s and for all i \u2265 0, |U \u2032| \u2265 |adom(r(i)) \u222a adom(r(i + 1)) \u222a C \u222a \u03c3(free(\u03d5))|, then there exists a t.e. run r\u2032 of P \u2032 s.t. for all i \u2265 0:\n(i) r\u2032(0) = s\u2032;\n(ii) r(i) \u2248 r\u2032(i);\n(iii) \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. r(i) and r\u2032(i).\n(iv) for every i \u2265 0, if r(i) \u2192 r(i + 1) then r\u2032(i) \u2192 r\u2032(i + 1), and if r(i) \u223cj r(i + 1), for some j, then r\u2032(i) \u223cj r\u2032(i+ 1).\nProof. Let r be a t.e. run s.t. |U \u2032| \u2265 |adom(r(i)) \u222a adom(r(i + 1)) \u222a C \u222a \u03c3(free(\u03d5))| for all i \u2265 0. We inductively build r\u2032 and show that the conditions above are satisfied. For i = 0, let r\u2032(0) = s\u2032. By hypothesis, r is s.t. |U \u2032| \u2265 |adom(r(0)) \u222a adom(r(1)) \u222a C \u222a \u03c3(free(\u03d5))|. Thus, since r(0) \u2740 r(1), by Lemma 4.6 there exists t\u2032 \u2208 S \u2032 s.t. r\u2032(0) \u2740 t\u2032, r(1) \u2248 t\u2032, and \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. r(1) and t\u2032. Let r\u2032(1) = t\u2032. Lemma 4.6 guarantees that the transitions r\u2032(0) \u2740 t\u2032 and r(0) \u2740 r(1) can be chosen so that they are either both temporal or both epistemic with the same index.\nThe case for i > 0 is similar. Assume that r(i) \u2248 r\u2032(i) and \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. r(i) and r\u2032(i). Since r(i) \u2740 r(i+1) and |U \u2032| \u2265 |adom(r(i))\u222aadom(r(i+1))\u222aC\u222a\u03c3(free(\u03d5))|, by Lemma 4.6 there exists t\u2032 \u2208 S \u2032 s.t. r\u2032(i) \u2740 t\u2032, \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. r(i+1) and t\u2032, and r(i + 1) \u2248 t\u2032. Let r\u2032(i + 1) = t\u2032. It is clear that r\u2032 is a t.e. run in P \u2032, and that, by Lemma 4.6, the transitions of r\u2032 can be chosen so as to fulfill requirement (iv).\nWe can now prove the following result, which states that FO-CTLK formulas cannot distinguish \u2295-bisimilar and uniform AC-MAS. This is in marked contrast with the earlier example in this section which operated on \u2295-bisimilar but non-uniform AC-MAS.\nTheorem 4.8 Consider two \u2295-bisimilar and uniform AC-MAS P and P \u2032, two \u2295-bisimilar states s \u2208 S and s\u2032 \u2208 S \u2032, an FO-CTLK formula \u03d5, and two assignments \u03c3 and \u03c3\u2032 equivalent for \u03d5 w.r.t. s and s\u2032.\nIf\n1. for every t.e. run r s.t. r(0) = s, for all k \u2265 0 we have |U \u2032| \u2265 |adom(r(k)) \u222a adom(r(k + 1)) \u222aC \u222a \u03c3(free(\u03d5))| + |vars(\u03d5) \\ free(\u03d5)|; and\n2. for every t.e. run r\u2032 s.t. r\u2032(0) = s\u2032, for all k \u2265 0 we have |U | \u2265 |adom(r\u2032(k)) \u222a adom(r\u2032(k + 1)) \u222aC \u222a \u03c3\u2032(free(\u03d5))| + |vars(\u03d5) \\ free(\u03d5)|;\nthen\n(P, s, \u03c3) |= \u03d5 iff (P \u2032, s\u2032, \u03c3\u2032) |= \u03d5.\nProof. The proof is by induction on the structure of \u03d5. We prove that if (P, s, \u03c3) |= \u03d5 then (P \u2032, s\u2032, \u03c3\u2032) |= \u03d5. The other direction can be proved analogously. The base case for atomic formulas follows from Prop. 2.14. The inductive cases for propositional connectives are straightforward.\nFor \u03d5 \u2261 \u2200x\u03c8, assume that x \u2208 free(\u03c8) (otherwise consider \u03c8, and the corresponding case), and no variable is quantified more than once (otherwise rename the other variables). Let \u03b3 be a bijection witnessing that \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. s and s\u2032. For u \u2208 adom(s), consider the assignment \u03c3 (\nx u\n) . By definition, \u03b3(u) \u2208 adom(s\u2032), and \u03c3\u2032 ( x \u03b3(u) ) is well-defined. Note that free(\u03c8) =\nfree(\u03d5)\u222a{x}; so \u03c3 (x u ) and \u03c3\u2032 ( x \u03b3(u) ) are equivalent for \u03c8 w.r.t. s and s\u2032. Moreover, |\u03c3 (x u ) (free(\u03c8))| \u2264 |\u03c3(free(\u03d5))| + 1, as u may not occur in \u03c3(free(\u03d5)). The same considerations apply to \u03c3\u2032. Further, |vars(\u03c8) \\ free(\u03c8)| = |vars(\u03d5) \\ free(\u03d5)| \u2212 1, as vars(\u03c8) = vars(\u03d5), free(\u03c8) = free(\u03d5) \u222a {x}, and x /\u2208 free(\u03d5). Thus, both hypotheses 1. and 2. remain satisfied if we replace \u03d5 with \u03c8, \u03c3 with \u03c3\n(x u ) , and \u03c3\u2032 with \u03c3\u2032 ( x \u03b3(u) ) . Therefore, by the induction hypothesis, if (P, s, \u03c3 (x u ) ) |= \u03c8 then\n(P \u2032, s\u2032, \u03c3\u2032 ( x \u03b3(u) ) ) |= \u03c8. Since u \u2208 adom(s) is generic and \u03b3 is a bijection, the result follows.\nFor \u03d5 \u2261 AX\u03c8, assume by contradiction that (P, s, \u03c3) |= \u03d5 but (P \u2032, s\u2032, \u03c3\u2032) 6|= \u03d5. Then, there exists a run r\u2032 s.t. r\u2032(0) = s\u2032 and (P \u2032, r\u2032(1), \u03c3\u2032) 6|= \u03c8. By Lemma 4.7, which applies as |vars(\u03d5) \\ free(\u03d5)| \u2265 0, there exists a run r s.t. r(0) = s, for all i \u2265 0, r(i) \u2248 r\u2032(i) and \u03c3 and \u03c3\u2032 are equivalent for \u03c8 w.r.t. r(i) and r\u2032(i). Since r is a run s.t. r(0) = s, it satisfies hypothesis 1. Moreover, the same hypothesis is necessarily satisfied by all the t.e. runs r\u2032\u2032 s.t., , for some i \u2265 0, r\u2032\u2032(0) = r(i) (otherwise, the t.e. run r(0) \u00b7 \u00b7 \u00b7 r(i)r\u2032\u2032(1)r\u2032\u2032(2) \u00b7 \u00b7 \u00b7 would not satisfy the hypothesis); the same considerations apply w.r.t hypothesis 2 and for all the t.e. runs r\u2032\u2032\u2032 s.t. r\u2032\u2032\u2032(0) = r\u2032(i), for some i \u2265 0. In particular, these hold for i = 1. Thus, we can inductively apply the Lemma, by replacing s with r(1), s\u2032 with r\u2032(1), and \u03d5 with \u03c8 (observe that vars(\u03d5) = vars(\u03c8) and free(\u03d5) = free(\u03c8)). But then we obtain (P, r(1), \u03c3) 6|= \u03c8, thus (P, r(0), \u03c3) 6|= AX\u03c8. This is a contradiction.\nFor \u03d5 \u2261 E\u03c8U\u03c6, assume that the only variables common to \u03c8 and \u03c6 occur free in both formulas (otherwise rename the quantified variables). Let r be a run s.t. r(0) = s, and there exists k \u2265 0 s.t. (P, r(k), \u03c3) |= \u03c6, and (P, r(j), \u03c3) |= \u03c8 for 0 \u2264 j < k. By Lemma 4.7 there exists a run r\u2032 s.t. r\u2032(0) = s\u2032, and for all i \u2265 0, r\u2032(i) \u2248 r(i), and \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. r\u2032(i) and r(i). From each bijection \u03b3i witnessing that \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. r\u2032(i) and r(i), define the bijections \u03b3i,\u03c8 = \u03b3i|adom(r(i))\u222aC\u222a\u03c3(free(\u03c8)) and \u03b3i,\u03c6 = \u03b3i|adom(r(i))\u222aC\u222a\u03c3(free(\u03c6)). Since free(\u03c8) \u2286 free(\u03d5), free(\u03c6) \u2286 free(\u03d5), it can be seen that \u03b3i,\u03c8 and \u03b3i,\u03c6 witness that \u03c3 and \u03c3\u2032 are equivalent for respectively \u03c8 and \u03c6 w.r.t. r\u2032(i) and r(i). By the same argument used for the AX case above,\nhypothesis 1 holds for all the t.e. runs r\u2032\u2032 s.t. r\u2032\u2032(0) = r(i), for some i \u2265 0, and hypothesis 2 holds for all the t.e. runs r\u2032\u2032\u2032 s.t. r\u2032\u2032\u2032(0) = r\u2032(i). Now observe that |\u03c3(free(\u03c6))|, |\u03c3(free(\u03c8))| \u2264 |\u03c3(free(\u03d5))|. Moreover, by the assumption on the common variables of \u03c8 and \u03c6, (vars(\u03d5)\\free(\u03d5)) = (vars(\u03c8)\\ free(\u03c8))\u228e(vars(\u03c6)\\free(\u03c6)), thus |vars(\u03d5) \\ free(\u03d5)| = |(vars(\u03c8) \\ free(\u03c8)|+|(vars(\u03c6) \\ free(\u03c6)|, hence |(vars(\u03c8) \\ free(\u03c8)|, |(vars(\u03c6) \\ free(\u03c6)| \u2264 |vars(\u03d5) \\ free(\u03d5)|. Therefore hypotheses 1 and 2 hold also with \u03d5 uniformly replaced by \u03c8 or \u03c6. Then, the induction hypothesis applies for each i, by replacing s with r(i), s\u2032 with r\u2032(i), and \u03d5 with either \u03c8 or \u03c6. Thus, for each i, (P, r(i), \u03c3) |= \u03c8 iff (P \u2032, r\u2032(i), \u03c3\u2032) |= \u03c8, and (P, r(i), \u03c3) |= \u03c6 iff (P \u2032, r\u2032(i), \u03c3\u2032) |= \u03c6. Therefore, r\u2032 is a run s.t. r\u2032(0) = s\u2032, (P \u2032, r\u2032(k), \u03c3\u2032) |= \u03c6, and for every j, 0 \u2264 j < k implies (P \u2032, r\u2032(j), \u03c3\u2032) |= \u03c8, i.e., (P \u2032, s\u2032, \u03c3\u2032) |= E\u03c8U\u03c6.\nFor \u03d5 \u2261 A\u03c8U\u03c6, assume by contradiction that (P, s, \u03c3) |= \u03d5 but (P \u2032, s\u2032, \u03c3\u2032) 6|= \u03d5. Then, there exists a run r\u2032 s.t. r\u2032(0) = s\u2032 and for every k \u2265 0, either (P \u2032, r\u2032(k), \u03c3\u2032) 6|= \u03c6 or there exists j s.t. 0 \u2264 j < k and (P \u2032, r\u2032(j), \u03c3\u2032) 6|= \u03c8. By Lemma 4.7 there exists a run r s.t. r(0) = s, and for all i \u2265 0, r(i) \u2248 r\u2032(i) and \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. r(i) and r\u2032(i). Similarly to the case of E\u03c8U\u03c6, it can be shown that \u03c3 and \u03c3\u2032 are equivalent for \u03c8 and \u03c6 w.r.t. r(i) and r\u2032(i), for all i \u2265 0. Further, assuming w.l.o.g. that all variables common to \u03c8 and \u03c6 occur free in both formulas, it can be shown, as in the case of E\u03c8U\u03c6, that the induction hypothesis holds on every pair of runs obtained as suffixes of r and r\u2032, starting from their i-th state, for every i \u2265 0. Thus, (P, r(i), \u03c3) |= \u03c8 iff (P \u2032, r\u2032(i), \u03c3\u2032) |= \u03c8, and (P, r(i), \u03c3) |= \u03c6 iff (P \u2032, r\u2032(i), \u03c3\u2032) |= \u03c6. But then r is s.t. r(0) = s and for every k \u2265 0, either (P, r(k), \u03c3) 6|= \u03c6 or there exists j s.t. 0 \u2264 j < k and (P, r(j), \u03c3) 6|= \u03c8, that is, (P, s, \u03c3) 6|= A\u03c8U\u03c6. This is a contradiction.\nFor \u03d5 \u2261 Ki\u03c8, assume by contradiction that (P, s, \u03c3) |= \u03d5 but (P \u2032, s\u2032, \u03c3\u2032) 6|= \u03d5. Then, there exists s\u2032\u2032 s.t. s\u2032 \u223ci s\u2032\u2032 and (P \u2032, s\u2032\u2032, \u03c3\u2032) 6|= \u03c8. By Lemma 4.7 there exists s\u2032\u2032\u2032 s.t. s\u2032\u2032\u2032 \u2248 s\u2032\u2032, s \u223ci s\u2032\u2032\u2032, and \u03c3 and \u03c3\u2032 are equivalent for \u03c8 w.r.t. s\u2032\u2032 and s\u2032\u2032\u2032. Thus, by an argument analogous to that used for the case of AX, we can apply the induction hypothesis, obtaining (P, s\u2032\u2032\u2032, \u03c3) 6|= \u03c8. But then (P, s, \u03c3) 6|= Ki\u03c8, which is a contradiction.\nFinally, for \u03d5 \u2261 C\u03c8, assume by contradiction that (P, s, \u03c3) |= \u03d5 but (P \u2032, s\u2032, \u03c3\u2032) 6|= \u03d5. Then, there exists an s\u2032\u2032 s.t. s\u2032 \u223c s\u2032\u2032 and (P \u2032, s\u2032\u2032, \u03c3\u2032) 6|= \u03c8. Again by Lemma 4.7 there exists s\u2032\u2032\u2032 s.t. s\u2032\u2032\u2032 \u2248 s\u2032\u2032, s \u223c s\u2032\u2032\u2032, and \u03c3 and \u03c3\u2032 are equivalent for \u03c8 w.r.t. s\u2032\u2032 and s\u2032\u2032\u2032. Thus, by an argument analogous to that used for the case of Ki, we can apply the induction hypothesis, obtaining (P, s\u2032\u2032\u2032, \u03c3) 6|= \u03c8. But then (P, s, \u03c3) 6|= C\u03c8, which is a contradiction.\nWe can now easily extend the above result to the model checking problem for AC-MAS.\nTheorem 4.9 Consider two \u2295-bisimilar and uniform AC-MASP and P \u2032, and an FO-CTLK formula \u03d5.\nIf\n1. for all t.e. runs r s.t. r(0) = s0, and for all k \u2265 0, |U \u2032| \u2265 |adom(r(k)) \u222a adom(r(k + 1)) \u222a C|+ |vars(\u03d5)|, and\n2. for all t.e. runs r\u2032 s.t. r\u2032(0) = s\u20320, and for all k \u2265 0, |U | \u2265 |adom(r \u2032(k))\u222a adom(r\u2032(k+1))\u222a\nC|+ |vars(\u03d5)|\nthen\nP |= \u03d5 iff P \u2032 |= \u03d5.\nProof. Equivalently, we prove that if (P, s0, \u03c3) 6|= \u03d5 for some \u03c3, then there exists a \u03c3\u2032 such that (P \u2032, s\u20320, \u03c3\n\u2032) 6|= \u03d5, and viceversa. To this end, observe that hypotheses 1. and 2. imply, respectively, hypotheses 1. and 2. of Theorem 4.8. Further, notice that, by cardinality considerations, given the assignment \u03c3 : V ar 7\u2192 U , there exists an assignment \u03c3\u2032 : V ar 7\u2192 U \u2032 s.t. \u03c3 and \u03c3\u2032 are equivalent for \u03d5 w.r.t. s0 and s\u20320. Thus, by applying Theorem 4.8 we have that if there exists an assignment \u03c3 s.t. (P, s0, \u03c3) 6|= \u03d5, then there exists an assignment \u03c3\u2032 s.t. (P \u2032, s\u20320, \u03c3\n\u2032) 6|= \u03d5. The converse can be proved analogously, as the hypotheses are symmetric.\nThis result shows that uniform AC-MAS can in principle be verified by model checking a \u2295- bisimilar one. Note that this applies to infinite AC-MAS P as well. In this case the results above enable us to show that the verification question can be posed on the corresponding, possibly finite, P \u2032 as long as U \u2032, as defined above, is sufficiently large for P \u2032 to \u2295-bisimulate P. A noteworthy class of infinite systems for which these results prove particularly powerful is that of bounded AC-MAS, which, as discussed in the next subsection, always admit a finite abstraction."}, {"heading": "4.2 Finite Abstractions", "text": "We now combine the notion of uniformity explored so far in this section with the assumption on boundedness made in Section 3.1. Our aim remains to identify conditions under which the verification of an infinite AC-MAS can be reduced to the verification of a finite one. Differently from Section 3.1 we here operate on the full FO-CTLK specification language. The main result here is given by Corollary 4.14 which guarantees that, in the context of bounded AC-MAS, uniformity is a sufficient condition for \u2295-bisimilar finite abstractions to be satisfaction preserving.\nIn the following we assume that any AC-MAS P is such that adom(s0) \u2286 C . If this is not the case, C can be extended so as to include all the (finitely many) elements in adom(s0). Further, we recall that NAg is the sum of the maximum numbers of parameters contained in the action types of each agent in Ag, i.e., NAg = \u2211\nAi\u2208Ag max\u03b1(~x)\u2208Acti{|~x|}.\nWe start by formalizing the notion of \u2295-abstraction.\nDefinition 4.10 (\u2295-Abstraction) Let P = \u3008S, U, s0, \u03c4\u3009 be an AC-MAS over Ag, and Ag\u2032 the set of abstract agents obtained as in Definition 3.7, for some domain U \u2032. The AC-MAS P \u2032 = \u3008S \u2032, U \u2032, s\u20320, \u03c4 \u2032\u3009 over Ag\u2032 is said to be an \u2295-abstraction of P iff:\n\u2022 s\u20320 = s0;\n\u2022 t\u2032 \u2208 \u03c4 \u2032(s\u2032, ~\u03b1(~u\u2032)) iff there exist s, t \u2208 S and ~\u03b1(~u) \u2208 Act(U), such that s \u2295 t \u2243 s\u2032 \u2295 t\u2032, for some witness \u03b9, t \u2208 \u03c4(s, ~\u03b1(~u)), and ~u\u2032 = \u03b9\u2032(~u) for some bijection \u03b9\u2032 extending \u03b9 to ~u.\nNotice that P \u2032 is indeed an AC-MAS as it satisfies the relevant conditions on protocols and transitions in Definition 2.7. Indeed, if t\u2032 \u2208 \u03c4 \u2032(s\u2032, ~\u03b1(~u\u2032)), then there exist s, t \u2208 S , and ~\u03b1(~u) such that t \u2208 \u03c4(s, ~\u03b1(~u)), s\u2295t \u2243 s\u2032\u2295t\u2032 for some witness \u03b9, and ~u = \u03b9\u2032(~u\u2032) for some bijection \u03b9\u2032 extending \u03b9. This means that \u03b1i(~ui) \u2208 Pri(li) for i \u2264 n. By definition of Pr\u2032i we have that \u03b1i(~u \u2032 i) \u2208 Pr \u2032 i(l \u2032 i) for i \u2264 n. Further, if U \u2032 has finitely many elements, then S \u2032 has finitely many states. Observe that by varying U \u2032 we obtain different \u2295-abstractions.\nNext, we investigate the relationship between an AC-MAS and its \u2295-abstractions. A first useful result states that every finite \u2295-abstraction is uniform, independently of the properties of the ACMAS they abstract.\nLemma 4.11 Every \u2295-abstraction P \u2032 of an AC-MAS P is uniform.\nProof. Consider s, t, s\u2032 \u2208 S \u2032, t\u2032 \u2208 D(U \u2032), and ~\u03b1(~u) \u2208 Act\u2032(U \u2032) s.t. t \u2208 \u03c4 \u2032(s, ~\u03b1(~u)) and s\u2295 t \u2243 s\u2032 \u2295 t\u2032, for some witness \u03b6 . We need to show that P \u2032 admits a transition from s\u2032 to t\u2032. Since P \u2032 is an \u2295-abstraction of P, given the definition of \u03c4 \u2032, there exist s\u2032\u2032, t\u2032\u2032 \u2208 S and ~\u03b1(~u\u2032\u2032) \u2208 Act(U) s.t. t\u2032\u2032 \u2208 \u03c4(s\u2032\u2032, ~\u03b1(~u\u2032\u2032)), s\u2032\u2032 \u2295 t\u2032\u2032 \u2243 s \u2295 t, for some witness \u03b9, and ~u = \u03b9\u2032(~u\u2032\u2032), for some constantpreserving bijection \u03b9\u2032 extending \u03b9 to ~u\u2032\u2032. Consider ~u\u2032 \u2208 U \u2032|~u| such that ~u\u2032 = \u03b6 \u2032(~u), for some constant-preserving bijection \u03b6 \u2032 extending \u03b6 to ~u. Obviously, the composition \u03b6 \u2032 \u25e6 \u03b9\u2032 is a constantpreserving bijection such that ~u\u2032 = \u03b6 \u2032(\u03b9\u2032(~u\u2032\u2032)). Moreover, it can be easily restricted to a witness for s\u2032\u2032 \u2295 t\u2032\u2032 \u2243 s\u2032 \u2295 t\u2032. But then, since P \u2032 is an \u2295-abstraction of P, this implies that t\u2032 \u2208 \u03c4 \u2032(s\u2032, ~\u03b1(~u\u2032)). Thus, P \u2032 is uniform.\nThe second result below guarantees that every b-bounded AC-MAS is bisimilar to any of its \u2295-abstractions, provided these are built over a sufficiently large interpretation domain.\nLemma 4.12 Consider a uniform, b-bounded AC-MAS P over an infinite interpretation domain U , and an interpretation domain U \u2032 such that C \u2286 U \u2032. If |U \u2032| \u2265 2b + |C| + NAg, then any \u2295-abstraction P \u2032 of P over U \u2032 is bisimilar to P.\nProof. Let B = {\u3008s, s\u2032\u3009 \u2208 S \u00d7 S \u2032 | s \u2243 s\u2032}. We prove that B is a \u2295-bisimulation such that \u3008s0, s \u2032 0\u3009 \u2208 B. We start by proving that B is a \u2295-simulation relation. To this end, observe that since s0 = s \u2032 0, then s0 \u2243 s \u2032 0, and \u3008s0, s \u2032 0\u3009 \u2208 B. Next, consider \u3008s, s\n\u2032\u3009 \u2208 B, thus s \u2243 s\u2032. Assume that s \u2192 t, for some t \u2208 S . Then, there must exist ~\u03b1(~u) \u2208 Act(U) such that t \u2208 \u03c4(s, ~\u03b1(~u)). Moreover, since |U \u2032| \u2265 2b + |C| + NAg, \u2211\nAi\u2208Ag |~ui| \u2264 NAg, and |adom(s) \u222a adom(t)| \u2264 2b, the witness\n\u03b9 for s \u2243 s\u2032 can be extended to \u22c3 Ai\u2208Ag ~ui as a bijection \u03b9\u2032. Now let t\u2032 = \u03b9\u2032(t). By the way \u03b9\u2032 has been defined, it can be seen that s\u2295 t \u2243 s\u2032 \u2295 t\u2032. Further, since P \u2032 is an \u2295-abstraction of P, we have that t\u2032 \u2208 \u03c4 \u2032(s\u2032, ~\u03b1(~u\u2032)) for ~u\u2032 = \u03b9\u2032(~u), that is, s\u2032 \u2192 t\u2032 in P \u2032. Therefore, there exists t\u2032 \u2208 S \u2032 such that s\u2032 \u2192 t\u2032, s \u2295 t \u2243 s\u2032 \u2295 t\u2032, and \u3008t, t\u2032\u3009 \u2208 B. As regards the epistemic relation, assume s \u223ci t for some i \u2208 {1, . . . , n} and t \u2208 S . By definition of \u223ci, li(s) = li(t). Since |U \u2032| \u2265 2b + |C|, any witness \u03b9 for s \u2243 s\u2032 can be extended to a witness \u03b9\u2032 for s\u2295 t \u2243 s\u2032 \u2295 t\u2032, where t\u2032 = \u03b9\u2032(t). Obviously, li(s \u2032) = li(t \u2032). Thus, to prove that s\u2032 \u223ci t\u2032, we need to show that t\u2032 \u2208 S \u2032, i.e., that t\u2032 is reachable in P \u2032 from s\u20320 = s0. To this end, observe that since t \u2208 S , there exists a purely temporal run r such that r(0) = s0 and r(k) = t, for some k \u2265 0. Thus, there exist also ~\u03b11(~u1) . . . , ~\u03b1k(~uk) such that r(j + 1) \u2208 \u03c4(r(j), ~\u03b1j+1(~uj+1)), for 0 \u2264 j < k. Since |U \u2032| \u2265 2b + |C|, we can define, for 0 \u2264 j < k, a function \u03b9j that is a witness for r(j)\u2295r(j+1) \u2243 \u03b9j(r(j))\u2295\u03b9j(r(j+1)). In particular, this can be done starting from j = k \u2212 1, defining \u03b9k\u22121 so that \u03b9k\u22121(r(k)) = \u03b9k\u22121(t) = t\u2032, and proceeding backward to j = 0, guaranteeing that, for 0 \u2264 j < k, \u03b9j(r(j + 1)) = \u03b9j+1(r(j + 1)). Observe that since adom(s0) \u2286 C , necessarily i0(r(0)) = i0(s0) = s0 = s\u20320. Moreover, as |U \u2032| \u2265 2b + |C| + NAg, each \u03b9j can be extended to a bijection \u03b9\u2032j , to the elements occurring in ~uj+1. Thus, given that P \u2032 is an \u2295-abstraction of P, for 0 \u2264 j < k, we have that \u03b9\u2032j(r(j + 1)) \u2208 \u03c4(\u03b9\u2032j(r(j)), ~\u03b1(\u03b9 \u2032 j(~u j+1))). Hence, the sequence \u03b9\u20320(r(0)) \u2192 \u00b7 \u00b7 \u00b7 \u2192 \u03b9 \u2032 k\u22121(r(k)) is a run of P\n\u2032, and, since t\u2032 = \u03b9\u2032k\u22121(r(k)), t\n\u2032 is reachable in P \u2032. Therefore s\u2032 \u223ci t\u2032. Further, since t \u2243 t\u2032, by definition of B, it is the case that \u3008t, t\u2032\u3009 \u2208 B, hence B is a \u2295-simulation.\nTo prove that B\u22121 is a \u2295-simulation, given \u3008s, s\u2032\u3009 \u2208 B (thus s \u2243 s\u2032), assume that s\u2032 \u2192 t\u2032, for some t\u2032 \u2208 S \u2032. Obviously, there exists ~\u03b1(~u\u2032) \u2208 Act(U \u2032) such that t\u2032 \u2208 \u03c4 \u2032(s\u2032, ~\u03b1(~u\u2032)). Because P \u2032 is an \u2295-abstraction of P, there exist s\u2032\u2032, t\u2032\u2032 \u2208 S and ~\u03b1(~u\u2032\u2032) \u2208 Act(U) such that s\u2032\u2032 \u2295 t\u2032\u2032 \u2243 s\u2032 \u2295 t\u2032, for some witness \u03b9, and t\u2032\u2032 \u2208 \u03c4(s\u2032\u2032, \u03b1(~u\u2032\u2032)), with ~u\u2032\u2032 = \u03b9\u2032(~u\u2032), for some bijection \u03b9\u2032 extending \u03b9 to ~u\u2032.\nObserve that s\u2032 \u2243 s\u2032\u2032, thus, by transitivity of \u2243, we have s \u2243 s\u2032\u2032. The fact that there exists t \u2208 S such that s \u2192 t easily follows from the uniformity of P. Thus, since t\u2032 \u2243 t, we have \u3008t, t\u2032\u3009 \u2208 B. For the epistemic relation, assume s\u2032 \u223ci t\u2032, for some t\u2032 \u2208 S \u2032 and 0 < i \u2264 n. Let \u03b9 be a witness for s\u2032 \u2243 s, and let \u03b9\u2032 be an extension of \u03b9 that is a witness for s\u2032 \u2295 t\u2032 \u2243 s \u2295 t. For t = \u03b9\u2032(t\u2032), it can be seen that li(s) = li(t). Observe that t\u2032 \u2208 S \u2032. Using an argument essentially analogous to the one above, but exploiting the fact that P is uniform, that P \u2032 is certainly b-bounded, and that |U | > 2b + |C| +NAg as U is infinite, we show that t \u2208 S by constructing a run r of P such that r(k) = t, for some k \u2265 0. Then s \u223ci t. Further, since t\u2032 \u2243 t, we have \u3008t, t\u2032\u3009 \u2208 B. Therefore, B\u22121 is a \u2295-simulation. So, P and P \u2032 are bisimilar.\nThis result allows us to prove our main abstraction theorem.\nTheorem 4.13 Consider a b-bounded and uniform AC-MAS P over an infinite interpretation domain U , an FO-CTLK formula \u03d5, and an interpretation domain U \u2032 such that C \u2286 U \u2032. If |U \u2032| \u2265 2b+ |C|+max{|vars(\u03d5)|, NAg}, then for any \u2295-abstraction P \u2032 of P over U \u2032, we have that:"}, {"heading": "P |= \u03d5 iff P \u2032 |= \u03d5.", "text": "Proof. By Lemma 4.11, P \u2032 is uniform. Thus, by the hypothesis on the cardinalities of U and U \u2032, Lemma 4.12 applies, so P and P \u2032 are bisimilar. Obviously, also P \u2032 is b-bounded. Thus, since P and P \u2032 are b-bounded, and by the cardinality hypothesis on U and U \u2032, Theorem 4.9 applies. In particular, notice that for every temporal-epistemic run r s.t. r(0) = s0, and for all k \u2265 0, we have that |U \u2032| \u2265 |adom(r(k))\u222aadom(r(k+1))\u222aC|+|vars(\u03d5)|, as |adom(r(k))| \u2264 b, by b-boundedness. Therefore, P |= \u03d5 iff P \u2032 |= \u03d5.\nNote that the theorem above does not require U \u2032 to be infinite. So, by using a sufficient number of abstract values in U \u2032, we can in principle reduce the verification of an infinite, bounded, and uniform AC-MAS to the verification of a finite one. The following corollary to Theorem 4.13 states this clearly.\nCorollary 4.14 Given a b-bounded and uniform AC-MAS P over an infinite interpretation domain U , and an FO-CTLK formula \u03d5, there exists an AC-MAS P \u2032 over a finite interpretation domain U \u2032 such that P |= \u03d5 iff P \u2032 |= \u03d5.\nIt should also be noted that U \u2032 can simply be taken to be any finite subset of U satisfying the cardinality requirement above. By doing so, the finite \u2295-abstraction P \u2032 can be defined simply as the restriction of P to U \u2032. Thus, every infinite, b-bounded and uniform AC-MAS is bisimilar to a finite subsystem which satisfies the same formulas.\nNote that, similarly to what noted at page 18 we are not concerned in the actual construction of the finite abstraction. This is because we intend to construct it directly from an artifact-centric program, as we will do in Section 6. Before that we explore the complexity of the model checking problem."}, {"heading": "5. The Complexity of Model Checking Finite AC-MAS against FO-CTLK", "text": "Specifications\nWe now analyse the complexity of the model checking problem for finite AC-MAS with respect to FO-CTLK specifications. The input of the problem consists of an AC-MAS P on a finite domain U\nand an FO-CTLK formula \u03d5; the solution is an assignment \u03c3 such that (P, s0, \u03c3) |= \u03d5. Hereafter we follow (Grohe, 2001) for basic notions and definitions. To encode an AC-MAS P we use a tuple EP = \u3008U,D, s0,\u03a6\u03c4 \u3009, where U is the (finite) interpretation domain, D is the global database schema, s0 is the initial state, and \u03a6\u03c4 = {\u03c6\u03b11 , . . . , \u03c6\u03b1m} is a set of FO-formulas, each capturing the transitions associated with a ground action \u03b1i. Since U is finite, so is the set of ground actions, thus \u03a6\u03c4 . Each \u03d5\u03b1i is a FO-formula over local predicate symbols, in both normal and \u201cprimed\u201d form, that is, \u03c6\u03b1 can mention both P and P \u2032. For the semantics of \u03a6\u03c4 , we have that s\u2032 \u2208 \u03c4(s, \u03b1) iff s \u2295 s\u2032 |= \u03c6\u03b1, for s, s\u2032 \u2208 D(U). It can be proved that every transition relation \u03c4 can be represented in this way, and that, given EP , the size ||P|| . = |S| + |\u03c4 | of the corresponding AC-MAS P is at most doubly exponential in ||EP || . = |U |+ ||D||+ |\u03a6\u03c4 |, where ||D|| = \u2211\nPk\u2208D qk, for qk the arity\nof Pk. In particular, ||P|| = |S|+ |\u03c4 | \u2264 23\u00b72 ||EP||\n4\n. We consider the combined complexity of the input, that is, ||EP || + ||\u03d5||. In particular, we say that the combined complexity of model checking finite AC-MAS against FO-CTLK specifications is EXPSPACE-complete if the problem is in EXPSPACE, i.e., there is a polynomial p(x) and an algorithm solving the problem in space bound by 2p(||EP ||+||\u03d5||). We say it is EXPSPACE-hard if every EXPSPACE problem can be reduced to model checking finite AC-MAS against FO-CTLK specifications. We now state the following complexity result.\nTheorem 5.1 The complexity of the model checking problem for finite AC-MAS against FO-CTLK specifications is EXPSPACE-complete.\nProof. To show that the problem is in EXPSPACE, recall that ||P|| is at most doubly exponential w.r.t. the size of the input, thus so is |S|. We describe an algorithm that works in NEXPSPACE, which combines the algorithm for model checking the first-order fragment of FO-CTLK and the temporal epistemic fragment. Since NEXPSPACE = EXPSPACE, the result follows. Given an ACMAS P and an FO-CTLK formula \u03d5, we guess an assignment \u03c3. Given such \u03c3, we check whether (P, s0, \u03c3) |= \u03d5. This can be done by induction according to the structure of \u03d5. If \u03d5 is atomic, this check can be done in polynomial time w.r.t. the size of the state it is evaluated on, that is exponential time w.r.t. ||EP ||. If \u03d5 is of the form \u2200x\u03c8, then we can apply the algorithm for model checking firstorder (non-modal) logic, which works in PSPACE. Finally, if the outmost operator in \u03d5 is either a temporal or epistemic modality, then we can extend the automata-based algorithm to model check propositional CTL in (Kupferman, Vardi, & Wolper, 2000), which works in logarithmic space in |S|. However, we remarked above that |S| is generally doubly exponential in ||EP ||. Thus, if the main operator in \u03d5 is either a temporal or epistemic modality, then this step can be performed in space singly exponential in ||EP ||. All these steps can be performed in time polynomial in the size of \u03d5. As a result, the total combined complexity of model checking finite AC-MAS is in NEXPSPACE = EXPSPACE.\nTo prove that the problem is EXPSPACE-hard we show a reduction from any problem in EXPSPACE. We assume standard definitions of Turing machines and reductions (Papadimitriou, 1994). If A is a problem in EXPSPACE, then there exists a deterministic Turing machine TA = \u3008Q,\u03a3, q0,F , \u03b4\u3009, where Q is the finite set of states, \u03a3 the machine alphabet, q0 \u2208 Q the initial state, F the set of accepting states, and \u03b4 the transition function, that solves A using at most space 2p(|in|) on a given input in, for some polynomial function p. As standard, we assume \u03b4 to be a relation on (Q\u00d7\u03a3\u00d7Q\u00d7\u03a3\u00d7D), with D = {L,R}, and \u3008q, c, q\u2032, c\u2032, d\u3009 \u2208 \u03b4 representing a transition from state q to state q\u2032, with characters c and c\u2032 read and written respectively , and head direction d ((L)eft and (R)ight). Without loss of generality, we assume that TA uses only the righthand half of the tape.\nFrom TA and in, we build an encoding EP = \u3008D, U, s0,\u03a6\u03c4 \u3009 of an AC-MAS P induced by a single (environment) agent AE = \u3008DE , LE , ActE , P rE\u3009 defined on U = \u03a3 \u222a Q \u222a {0, 1}, where: (i) DE = {P/p(|in|) + 1, Q/1,H/p(|in|), F/1}; (ii) LE = DE(U); (iii) ActE is the singleton {\u03b1E}, with \u03b1E parameter-free; (iv) \u03b1E \u2208 PrE(lE) for every lE \u2208 D(U). Intuitively, the states of P correspond to configurations of TA, while \u03c4 mimics \u03b4. To define EP , we let D = DE . The intended meaning of the predicates in D is as follows: the first p(|in|) elements of a P -tuple encode (in binaries) the position of a non-blank cell, and the (p(|in|) + 1)-th element contains the symbol appearing in that cell; Q contains the current state q of TA; H contains the position of the cell the head is currently on; F contains the final states of TA, i.e., F = F . The initial state s0 represents the initial configuration of TA, that is, for in = in0 \u00b7 \u00b7 \u00b7 in\u2113: s(Q) = {q0}; s(H) = {\u30080, . . . , 0\u3009}; and s(P ) = {\u3008BIN(i), ini\u3009 | i \u2208 {0, . . . , \u2113}}, where BIN(i) stands for the binary encoding in p(|in|) bits of the integer i. Observe that p(|in|) bits are enough to index the (at most) 2p(|in|) cells used by TA.\nAs to the transition relation, we define \u03a6\u03c4 = {\u03c6\u03b1E}, where:\n\u03c6\u03b1E= \u2228\n\u3008q,c,q\u2032,c\u2032,d\u3009\u2208\u03b4\n(\u2200xF (x) \u2194 F \u2032(x)) \u2227\nQ(q) \u2227 (\u2200xQ(x) \u2192 x = q) \u2227Q\u2032(q\u2032) \u2227 (\u2200xQ\u2032(x) \u2192 x = q\u2032) \u2227\n\u2203~p(H(~p) \u2227 (\u2200xH(x) \u2192 x = ~p) \u2227 (P (~p, c) \u2228 (c = \u2737 \u2227 \u00ac\u2203xP (~p, x)))) \u2227\n\u2203~p\u2032(d = R \u2192 SUCC(~p, ~p\u2032)) \u2227 (d = L \u2192 SUCC(~p\u2032, ~p)) \u2227H \u2032(~p\u2032) \u2227 (\u2200xH \u2032(x) \u2192 x = ~p\u2032) \u2227\n(P \u2032(~p, c\u2032) \u2194 (c\u2032 6= \u2737)) \u2227 (\u2200xP \u2032(~p, x) \u2192 x = c\u2032) \u2227\n(\u2200~x, y(P (~x, y) \u2227 (~x 6= ~p) \u2192 P \u2032(~x, y)) \u2227 (\u2200~x, yP \u2032(~x, y) \u2192 (P (~x, y) \u2228 (~x = ~p \u2227 y = c\u2032))))\nThe symbol \u2737 represents the content of blank cells, while SUCC(~x, ~x\u2032) = \u2227p(|in|) i=1 (x \u2032 i = 0\u2228x \u2032 i =\n1)\u2227 (x\u2032i = 1 \u2194 ((x \u2032 i = 0\u2227 \u2227i\u22121 j=1 xj = 1)\u2228 (x \u2032 i = 1\u2227\u00ac \u2227i\u22121 j=1 xj = 1))) is a formula capturing that ~x\u2032 is the successor of ~x, for ~x and ~x\u2032 interpreted as p(|in|)-bit binary encodings of integers (observe that {0, 1} \u2208 U ). Such a formula can obviously be written in polynomial time w.r.t. p(|in|), as well as EP , and in particular s0 and \u03c6\u03b1E .\nAs it can be seen by analyzing \u03a6\u03c4 , the obtained transition function is such that \u03c4(s, \u03b1E) = s\u2032 iff, for \u03b4(q, c) = (q\u2032, c\u2032, d) in TA, we have that: s\u2032(P ) is obtained from s(P ) by overwriting with c\u2032 (if not blank) the symbol in position (p(|in|)+1) of the tuple in s(P ) beginning with the p(|in|)-tuple s(H) (that is, c by definition of \u03c6\u03b1E ); by updating s(H) according to d, that is by increasing or decreasing the value it contains; and by setting s\u2032(Q) = {q\u2032}. The predicate F does not change. Observe that cells not occurring in P are interpreted as if containing \u2737 and that when \u2737 is to be written on a cell, the cell is simply removed from P .\nIt can be checked that, starting with s = s0, by iteratively generating the successor state s\u2032 according to \u03a6\u03c4 , i.e., s\u2032 s.t. s \u2295 s\u2032 |= \u03c6\u03b1E , one obtains a (single) P-run that is a representation of the computation of TA on in, where each pair of consecutive P-states corresponds to a computation step. In particular, at each state, Q contains the current state of TA. It should be clear that \u03d5 = EF (\u2203xQ(x)\u2227F (x)) holds in P iff TA accepts in. Thus, by checking \u03d5, we can check whether TA accepts in. This completes the proof of EXPSPACE-hardness.\nNote that the result above is given in terms of the \u201cdata structures\u201d in the model, i.e., U and D, and not the state space S itself. This accounts for the high complexity of model checking AC-MAS, as the state space is doubly exponential in the size of data.\nWhile EXPSPACE-hardness indicates intractability, we note that this is to be expected given that we are dealing with quantified structures which are in principle prone to undecidability. Recall also from Section 4.2 that the size of the interpretation domain U \u2032 of the abstraction P \u2032 is linear in the bound b, the number of constants in C , the size of \u03c6, and NAg. Hence, model checking bounded and uniform AC-MAS is EXPSPACE-complete with respect to these elements, whose size will generally be small. Thus, we believe than in several cases of practical interest model checking AC-MAS may be entirely feasible.\nWe now conclude the section with some observations on the verification of bounded and unbounded systems. Observe that the results presented in Sections 3.1 and 4.2 apply to infinite but bounded AC-MAS, i.e., whose global states never exceed a certain size in any run. It is however worth noting that existential fragments of the specification languages considered so far need not be examined with respect to the whole AC-MAS. Indeed in bounded model checking for CTLK submodels are iteratively explored until a witness for an existential specification is found (Penczek & Lomuscio, 2003). If that happens, we can deduce that the existential specification holds on the full model as well. As we show below, we can extend these result to the case of infinite AC-MAS.\nTo begin, define the b-restriction Pb of an AC-MAS P as follows.\nDefinition 5.2 (b-Restriction) Given an AC-MAS P = \u3008S, U, s0, \u03c4\u3009 and b \u2208 N such that b \u2265 |adom(s0) \u222a C|, the b-restriction Pb = \u3008Sb, U, s0, \u03c4b\u3009 of P is such that\n\u2022 Sb = {s \u2208 S | |adom(s)| \u2264 b};\n\u2022 s\u2032 \u2208 \u03c4b(s, \u03b1(~u)) iff s\u2032 \u2208 \u03c4(s, \u03b1(~u)) and s, s\u2032 \u2208 Sb.\nNotice that s0 \u2208 Sb by construction and \u03c4b is the restriction of \u03c4 to Sb; the interpretation domain U is the same in P and Pb. The result below demonstrates that if a FO-ECTLK formula holds on the b-restriction, then the formula holds on the whole AC-MAS.\nTheorem 5.3 Consider an AC-MAS P and its b-restriction Pb, for b \u2208 N. For any formula \u03c6 in FO-ECTLK, we have that:\nPb |= \u03c6 \u21d2 P |= \u03c6\nProof. By induction on the construction of \u03c6. The base case for atomic formulas and the inductive cases for propositional connectives are trivial, as the interpretation of relation symbols for states in Sb is the same as in S . As to the existential operators EX and EU , it suffices to remark that if r is a run in Pb satisfying either EX\u03c8 or E\u03c8U\u03c8\u2032, then r belongs to P as well by definition of Pb. The cases for the epistemic modalities K\u0304i and C\u0304 are similar: if (Pb, s, \u03c3) |= K\u0304i\u03c6, then there exists s\u2032 \u2208 Sb such that s \u223ci s\u2032 and (Pb, s\u2032, \u03c3) |= \u03c6. In particular, s\u2032 \u2208 S and therefore (P, s, \u03c3) |= K\u0304i\u03c6. For C\u0304\u03c6 the proof is similar by considering the transitive closure of the epistemic relations. Finally, the case of quantifiers follows from the fact that the active domain for each state is the same in P and Pb.\nObserve that there are specifications in FO-CTLK that are not preserved from Pb to P. For instance, consider the specification \u03d5b = AG\u2200x1, . . . , xb+1 \u2228 i 6=j(xi = xj) in SA-FO-CTL, which\nexpresses the fact that every state in every run contains at most b distinct elements. The formula \u03d5b is clearly satisfied by Pb but not in P, whenever P is unbounded.\nTheorem 5.3 can in principle form the basis for an incremental iterative procedure for checking an existential specification \u03c6 on an infinite AC-MAS P. We can begin by taking a reasonable bound b and check Pb |= \u03c6. If that holds we can deduce P |= \u03c6; if not we can increase the bound and repeat. The procedure is sound but clearly not complete. As mentioned earlier, this is in spirit of bounded model checking (Biere, Cimatti, Clarke, Strichman, & Zhu, 2003). Here, however, the bound is on the size of the states, rather than the length of the runs."}, {"heading": "6. Model Checking Artifact-Centric Programs", "text": "We have so far developed a formalism that can be used to specify and reason about temporalepistemic properties of models representing artifact-centric systems. We have identified two notable classes that admit finite abstractions. As we remarked in the introduction, however, artifact-centric systems are typically implemented through declarative languages such as GSM (Hull et al., 2011). It is therefore of paramount interest to investigate the verification problem, not just on a Kripke semantics such as AC-MAS, but on concrete programs. As discussed, while GSM is a mainstream declarative language for artifact-centric environments, alternative declarative approaches exist. In what follows for the sake of generality we ground our discussion on a very wide class of declarative languages and define the notion of artifact-centric program. Intuitively, an artifact-centric program (or AC program) is a declarative description of a whole multi-agent system, i.e., a set of services, that interact with the artifact system (see discussion in the Introduction). Since artifact systems are also typically implemented declaratively (see (Heath et al., 2011)) in what follows AC programs will be used to encode both the artifact system itself and the agents in the system. This also enables us to import into the formalism the previously discussed features of views and windows typical in GSM and other languages.\nThis section is organised as follows. Firstly, we define AC programs and give their semantics in terms of AC-MAS. Secondly, we show that any AC-MAS that results from an AC program is uniform. This enables us to state that, as long as the generated AC-MAS is bounded, any AC program admits an AC-MAS as its finite model. In this context it is actually important to give constructive procedures for the generation of the finite abstraction; we provide such a procedure here. This enables us to state that, under the assumptions we identify, AC programs admit decidable verification by means of model checking their finite model.\nWe start by defining the abstract syntax of AC programs.\nDefinition 6.1 (AC Program) An artifact-centric program (or AC program) is a tuple ACP = \u3008D, U,\u03a3\u3009, where:\n\u2022 D is the program\u2019s database schema;\n\u2022 U is the program\u2019s interpretation domain;\n\u2022 \u03a3 = {\u03a30, . . . ,\u03a3n} is the set of agent programs \u03a3i = \u3008Di, li0,\u2126i\u3009, where:\n\u2013 Di \u2286 D is agent i\u2019s database schema, s.t. Di \u2229 Dj = \u2205, for i 6= j;\n\u2013 li0 \u2208 Di(U) is agent i\u2019s initial state (as a database instance);\n\u2013 \u2126i is the set of local action descriptions in terms of preconditions and postconditions of the form \u03b1(~x) . = \u3008\u03c0(~y), \u03c8(~z)\u3009, where:\n\u2217 \u03b1(~x) is the action signature and ~x = ~y \u222a ~z is the set of its parameters;\n\u2217 \u03c0(~y) is the action precondition, i.e., an FO-formula over Di; \u2217 \u03c8(~z) is the action postcondition, i.e., an FO-formula over D \u222a D\u2032.\nRecall that local database schemas and instances were introduced in Definition 2.6. Observe that AC programs are defined modularly by giving the agents\u2019 programs including preconditions and postconditions as well as those of the environment.\nNotice that preconditions use relation symbols from the local database only, while postconditions can use any symbol from the whole D. This accounts for the intuition formalised in AC-MAS as well as present in temporal-epistemic logic literature that agents\u2019 actions may change the environment and the state of other agents. For an action \u03b1(~x), we let const(\u03b1) = const(\u03c0) \u222a const(\u03c8), vars(\u03b1) = vars(\u03c0) \u222a vars(\u03c8), and free(\u03b1) = ~x. An execution of \u03b1(~x) with ground parameters ~u \u2208 U |~x| is the ground action \u03b1(~u) = \u3008\u03c0(~v), \u03c8(~w)\u3009, where ~v (resp. ~w) is obtained by replacing each yi (resp. zi) with the value occurring in ~u at the same position as yi (resp. zi) in ~x. Such replacements make both \u03c0(~v) and \u03c8(~w) ground. Finally, we define the set CACP of all constants mentioned in ACP , i.e., CACP = \u22c3n i=1 ( adom(Di0) \u222a \u22c3 \u03b1\u2208\u2126i const(\u03b1) )\n. The semantics of a program is given in terms of the AC-MAS induced by the agents that the\nprogram implicitly defines. Formally, this is captured by the following definition.\nDefinition 6.2 (Induced Agents) Given an AC program ACP = \u3008D, U,\u03a3\u3009, an agent induced by ACP is a tuple Ai = \u3008Di, Li, Acti, P ri\u3009 on the interpretation domain U such that, for \u03a3i = \u3008Di, li0,\u2126i\u3009:\n\u2022 Li \u2286 Di(U) is the set of the agent\u2019s local states;\n\u2022 Acti = {\u03b1(~x) | \u03b1(~x) \u2208 \u2126i} is the set of local actions;\n\u2022 The protocol Pri(li) is defined by \u03b1(~u) \u2208 Pri(li) iff li |= \u03c0(~v) for \u03b1(~u) = \u3008\u03c0(~v), \u03c8(~w)\u3009.\nNote that the definition of induced agent is in line with the definition of Agents (Definition 2.6). Agents induced as above are composed to give an AC-MAS associated with an AC program.\nDefinition 6.3 (Induced AC-MAS) Given an AC program ACP and the set Ag = {A0, . . . , An} of agents induced by ACP , the AC-MAS induced by ACP is the tuple PACP = \u3008S, U, s0, \u03c4\u3009, where:\n\u2022 S \u2286 L0 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Ln is the set of reachable states;\n\u2022 s0 = \u3008l00, . . . , ln0\u3009 is the initial global state;\n\u2022 U is the interpretation domain;\n\u2022 \u03c4 is the global transition function defined by the following condition: s\u2032 \u2208 \u03c4(s, \u3008\u03b11(~u1), . . . , \u03b1n(~un)\u3009), with s = \u3008l0, . . . , ln\u3009 and \u03b1i(~ui) = \u3008\u03c0i(~vi), \u03c8i(~wi)\u3009 (i \u2208 {0, . . . , n}), iff the following conditions are satisfied:\n\u2013 for every i \u2208 {0, . . . , n}, li |= \u03c0i(~vi);\n\u2013 adom(s\u2032) \u2286 adom(s) \u222a \u22c3\ni=0,...,n ~wi \u222a const(\u03c8i);\n\u2013 Ds \u2295 Ds\u2032 |= \u03c8i(~wi), where Ds and Ds\u2032 are obtained from s and s\u2032 as discussed on p. 11.\nGiven an AC program, the induced AC-MAS is the Kripke model representing the whole execution tree for the AC program and representing all the data in the system. Observe that all actions performed are enabled by the respective protocols and that transitions can introduce only a bounded number of new elements in the active domain, those bound to the action parameters. It follows from the above that AC programs are parametric with respect to the interpretation domain, i.e., by replacing the interpretation domain we obtain a different AC-MAS. For simplicity, we assume that for every postcondition \u03c8 in a program, if a predicate does not occur in the postcondition, it is left unchanged by the relevant transitions. Formally, this means that we implicitly add a conjunct of the form \u2200~xP (~x) \u2194 P \u2032(~x) (\u2217) to the postcondition whenever P is not mentioned in \u03c8. Further, we assume that every program induces an AC-MAS whose transition relation is serial, i.e., AC-MAS states always have successors. These are basic requirements that can be easily fulfilled, for instance, by assuming that each agent has a skip action with an empty precondition and a postcondition of the form (\u2217) for every P \u2208 D. In the next section we present an example of one such program.\nA significant feature of AC programs is that they induce uniform AC-MAS.\nLemma 6.4 Every AC-MAS P induced by an AC program ACP is uniform.\nProof. By Prop. 4.4, it is sufficient to consider only the temporal transition relation \u2192, as adom(s0) \u2286 CACP . Consider s, s\u2032, s\u2032\u2032 \u2208 S and s\u2032\u2032\u2032 \u2208 L0 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Ln, such that s \u2295 s\u2032 \u2243 s\u2032\u2032 \u2295 s\u2032\u2032\u2032 for some witness \u03b9. Also, assume that there exists ~\u03b1(~u) = \u3008\u03b11(~u1), . . . , \u03b1n(~un)\u3009 \u2208 Act(U) such that s\u2032 \u2208 \u03c4(s, ~\u03b1(~u)). We need to prove that for every constant-preserving bijection \u03b9\u2032 that extends \u03b9 to ~u, we have that s\u2032\u2032\u2032 \u2208 \u03c4(s\u2032\u2032, ~\u03b1(\u03b9\u2032(~u))). To this end, we remark that any witness \u03b9 for s \u2295 s\u2032 \u2243 s\u2032\u2032 \u2295 s\u2032\u2032\u2032 can be extended to an injective function \u03b9\u2032 on \u22c3\ni\u2208Ag ~ui. Obviously, U contains enough distinct elements for \u03b9\u2032 to exist, as every ~ui takes values from U . Now, by an argument analogous to that of Proposition 2.14, it can be seen that for any FO-formula \u03d5 and equivalent assignments \u03c3 and \u03c3\u2032, we have that (s \u2295 s\u2032, \u03c3) |= \u03d5 iff (s\u2032\u2032 \u2295 s\u2032\u2032\u2032, \u03c3\u2032) |= \u03d5. But then, this holds, in particular, for \u03c3\u2032 obtained from \u03c3 by applying \u03b9\u2032 to the values assigned to each parameter, i.e., \u03b9\u2032(~u), and for the pre- and postconditions of all actions involved in the transition s \u03b1(~u) \u2212\u2212\u2212\u2192 s\u2032. Thus, we have s\u2032\u2032\u2032 \u2208 \u03c4(s\u2032\u2032, ~\u03b1(\u03b9\u2032(~u))), i.e., P is uniform.\nWe can now define what it means for an AC program to satisfy a specification, by referring to its induced AC-MAS.\nDefinition 6.5 Given an AC program ACP , a FO-CTLK formula \u03d5, and an assignment \u03c3, we say that ACP satisfies \u03d5 under \u03c3, written (ACP, \u03c3) |= \u03d5, iff (PACP , s0, \u03c3) |= \u03d5.\nIt follows that the model checking problem for an AC program against a specification \u03c6 is defined in terms of the model checking problem for the AC-MAS PACP against \u03c6.\nThe following result allows us to reduce the verification of any AC program with an infinite interpretation domain U1, that induces a b-bounded AC-MAS, to the verification of an AC program over a finite U2. To show how it can be done, we let NACP = \u2211\ni\u2208{1,...,n}max\u03b1(~x)\u2208\u2126i{|~x|} be the maximum number of different parameters that can occur in a joint action of ACP .\nLemma 6.6 Consider an AC program ACP1 = \u3008D, U1,\u03a3\u3009 operating on an infinite interpretation domain U1 and assume its induced AC-MAS PACP1 = \u3008S1, U1, s10, \u03c41\u3009 is b-bounded. Consider a finite interpretation domain U2 such that CACP1 \u2286 U2 and |U2| \u2265 2b+ |CACP1 |+NACP1 and the AC program ACP2 = \u3008D, U2,\u03a3\u3009. Then, the AC-MAS PACP2 = \u3008S2, U2, s20, \u03c42\u3009 induced by ACP2 is a finite abstraction of PACP1 .\nProof. Let Ag1 and Ag2 be the set of agents induced respectively by ACP1 and ACP2, according to Def. 6.2. First, we prove that the set of agents Ag1 and Ag2 satisfy Def. 3.7, for Ag = Ag1 and Ag\u2032 = Ag2. To this end, observe that because ACP1 and ACP2 differ only in U , by Def. 6.2, D = D\u2032, L\u2032i \u2286 D \u2032 i(U\n\u2032), and Act\u2032 = Act. Thus, only requirement 4 of Def. 3.7 still needs to be proved. To see it, fix i \u2208 {1, . . . , n} and assume that \u03b1(~u) \u2208 Pri(li). By Def. 6.2, we have that li |= \u03c0(~v), for \u03b1(~u) = \u3008\u03c0(~v), \u03c8(~w)\u3009. By the assumption on |U2|, since const(\u03b1) \u2286 CACP1 \u2286 U2, |~u| \u2264 NACP1 , and |adom(li)| \u2264 b, we can define an injective function \u03b9 : adom(li)\u222a ~u\u222aCACP1 7\u2192 U2 that is the identity on CACP1 . Thus, for l \u2032 i = \u03b9(li), we can easily extract from \u03b9 a witness for li \u2243 l \u2032 i. Moreover, it can be seen that ~v and ~v\n\u2032 are equivalent for \u03c0. Then, by applying Prop. 2.14 to li and l\u2032i, we conclude that l \u2032 i |= \u03c0(~v \u2032), for ~v\u2032 = \u03b9(~v). Hence, by Def. 6.2, \u03b1(~u\u2032) \u2208 Pr\u2032i(l \u2032 i). So, we have shown the right-to-left part of requirement 4. The left-to-right part can be shown similarly and in a simplified way as U1 is infinite.\nThus, we have proven that Ag = Ag1 and Ag\u2032 = Ag2 are obtained as in Def. 3.7. Hence, the assumption on Ag and Ag\u2032 in Def. 4.10 is fulfilled. We prove next that also the remaining requirements of Def. 4.10 are satisfied. Obviously, since \u03a3 is the same for ACP1 and ACP2, by Def. 6.3, s10 = s20, so the initial states of PACP1 and PACP2 are the same. It remains to show that the requirements on \u03c41 and \u03c42 are satisfied. We prove the right-to-left part. To this end, take two states s1 = \u3008l10, . . . , l1n\u3009, s\u20321 = \u3008l \u2032 10, . . . , l \u2032 1n\u3009 in S1 and a joint action ~\u03b1(~u) = \u3008\u03b10(~u0), . . . , \u03b1n(~un)\u3009 \u2208 Act(U) such that s\u20321 \u2208 \u03c41(s1, ~\u03b1(~u)). Consider s1\u2295s \u2032 1. By the assumptions on U2, there exists an injective function \u03b9 : adom(s1) \u222a adom(s\u20321) \u222a ~u \u222a CACP1 7\u2192 U2 that is the identity on CACP1 (recall that |adom(s1)|, |adom(s \u2032 1)| \u2264 b). Then, for s2 = \u3008\u03b9(l10), . . . , \u03b9(l1n)\u3009, s\u20322 = \u3008\u03b9(l \u2032 10), . . . , \u03b9(l \u2032 1n)\u3009 in S2, we can extract, from \u03b9, a witness for s1 \u2295 s \u2032 1 \u2243 s2 \u2295 s \u2032 2. Moreover, it can be seen that for every \u03c0i and \u03c8i in ~\u03b1i(~xi) = \u3008\u03c0i(~yi), \u03c8i(~zi)\u3009, ~u and ~u\u2032 = \u03b9(~u) are equivalent with respect to s1 \u2295 s\u20321 and s2 \u2295 s \u2032 2. Now, consider Def. 6.3 and recall that both PACP1 and PACP2 are AC-MAS induced by ACP1, ACP2, respectively. By applying Prop. 2.14, we have that, for i \u2208 {0, . . . , n}: \u03b9(l1i) |= \u03c0i(\u03b9(~vi)) iff l1i |= \u03c0i(~vi); Ds2\u2295Ds\u2032 2 |= \u03c8i(\u03b9(~wi)) iff Ds1\u2295Ds\u2032 1 |= \u03c8i(~wi). In addition, by the definition of \u03b9, adom(s\u20321) \u2286 adom(s1)\u222a \u22c3 i=0,...,n ~wi\u222a const(\u03c8i) iff adom(s \u2032 2) \u2286 adom(s2)\u222a \u22c3 i=0,...,n \u03b9(~wi)\u222aconst(\u03c8i). But then, it is the case that s \u2032 2 \u2208 \u03c42(s \u2032 2, ~\u03b1(\u03b9(~u0), . . . , \u03b9(~un))). So we have proved the right-to-left part of the second requirement of Def. 4.10. The other direction follows similarly. Therefore, PACP2 is an abstraction of PACP1 .\nIntuitively, Lemma 6.6 shows that the following diagram commutes, where [U1/U2] stands for the replacement of U1 by U2 in the definition of ACP1. Observe that since U2 is finite, one can actually apply Def. 6.3 to obtain PACP2 , while this cannot be done for ACP1, as U1 is infinite.\nACP1 Def. 6.3 //\n[U1/U2]\nPACP1\nDef. 4.10\nACP2 Def. 6.3 // PACP2\nThe following result, a direct consequence of Lemma 4.12 and Lemma 6.6, is the key conclusion of this section.\nTheorem 6.7 Consider an FO-CTLK formula \u03d5, an AC program ACP1 operating on an infinite interpretation domain U1 and assume its induced AC-MAS PACP1 is b-bounded. Consider a finite interpretation domain U2 such that CACP1 \u2286 U2 and |U2| \u2265 2b+|CACP |+max{NACP , |vars(\u03d5)|}, and the AC program ACP2 = \u3008D, U2,\u03a3\u3009. Then we have that:\nACP1 |= \u03d5 iff ACP2 |= \u03d5.\nProof. By Lemma 6.6 PACP2 is a finite abstraction of PACP1 . Moreover, |U2| \u2265 2b + |CACP | + max{NACP , |vars(\u03d5)|} implies |U2| \u2265 2b+|CACP |+|vars(\u03d5)|. Hence, we can apply Lemma 4.12 and the result follows.\nThe above is the key result in this section. It shows that if the generated AC-MAS model is bounded, then any AC program can be verified by model checking its finite \u2295-abstraction, i.e., a \u2295-bisimilar AC-MAS defined on a finite interpretation domain. Note that in this case the procedure is entirely constructive: given an AC program ACP1 = \u3008D, U1,\u03a3\u3009 on an infinite domain U1 and an FO-CTLK formula \u03d5, to check whether ACP1 satisfies the specification \u03d5, we first consider the finite \u201cabstraction\u201d ACP2 = \u3008D, U2,\u03a3\u3009 defined on a finite domain U2 satisfying the requirement on cardinality in Theorem 6.7. Since U2 is finite, also the induced AC-MAS PACP2 is finite, hence we can apply standard model checking techniques to verify whether PACP2 satisfies \u03d5. Finally, by definition of satisfaction for AC programs and Theorem 6.7, we can transfer the result obtained to decide the model checking problem for the original infinite AC program ACP1 and \u03d5.\nAlso observe that in the finite abstraction considered above the abstract interpretation domain U2, depends on the number of distinct variables that the specification \u03d5 contains. Thus, in principle, to check the same AS program against a different specification \u03d5\u2032, one should construct a new abstraction PACP \u2032 2 using a different interpretation domain U \u20322, and then check \u03d5\n\u2032 against it. However, it can be seen that if the number of distinct variables of \u03d5\u2032 does not exceed that of \u03d5, the abstraction PACP2 , used to check \u03d5, can be re-used for \u03d5\n\u2032. Formally, let FO-CTLKk be the set of all FO-CTLK formulas containing at most k distinct variables. We have the following corollary to Theorem 6.7.\nCorollary 6.8 If |U2| \u2265 2b + |CACP | + max{NACP , k}, then, for every FO-CTLKk formula \u03d5, ACP1 |= \u03d5 iff ACP2 |= \u03d5.\nThis result holds in particular for k = NACP ; thus for FO-CTLKNACP formulas, we have an abstraction procedure that is specification-independent.\nTheorem 6.7 requires the induced AC-MAS to be bounded, which may seem a difficult condition to check a priori. Note however that AC programs are declarative. As such it is straightforward to give postconditions that enforce that no transition will generate states violating the boundedness requirement. The scenario in the next section will exemplify this."}, {"heading": "7. The Order-to-Cash Scenario", "text": "In this section we exemplify the methodology presented so far in the context of a business process inspired by an IBM customer use-case (Hull et al., 2011). The order-to-cash scenario describes the actions performed by a number of agents in an e-commerce situation relating to the purchase\nprepared pending paid shipped createPO submitPO pay shipPO deletePO\n(a) Purchase Order lifecyle\nand delivery of a product. The agents in the system consist of a manufacturer, some customers, and some suppliers. The process begins when a customer prepares and submits a purchase order (PO), i.e., a list of products the customer requires, to the manufacturer. Upon receiving a PO, the manufacturer prepares a material order (MO), i.e., a list of components needed to assemble the requested products. The manufacturer then selects a supplier and forwards him the relevant material order. Upon receipt a supplier can either accept or reject a MO. In the former case he then proceeds to deliver the requested components to the manufacturer. In the latter case he notifies the manufacturer of his rejection. If an MO is rejected, the manufacturer can delete it and then prepare and submit new MOs. When the components required have been delivered to the manufacturer, he assembles the product and, provided the order has been paid for, he delivers it to the customer. Any order which is directly on indirectly related to a PO can be deleted only after the PO is deleted.\nWe can encode the order-to-cash business process as an artifact-centric program ACPotc, where the artifact data models are represented as database schemas and its evolution is characterised by an appropriate set of operations. It is natural to identify 2 classes of artifacts, representing the PO and the MO, each corresponding to the respective orders by the agents. An intuitive representation of the artifact lifecycles, i.e., the evolution of some key records in the artifacts\u2019 states, capturing only the dependence of actions from the artifact statuses, is shown in Fig. 3. Note that this is an incomplete representation of the business process, as the interaction between actions and the artifact data content is not represented.\nNext, we encode the whole system as an AC program, where the artifact data models are represented as a relational database schema, and the corresponding lifecycles are formally characterised by an appropriate set of actions. We reserve a distinguished relation for each artifact class. In addition, we introduce static relations to store product and material information. For the sake of presentation we assume to be dealing with three agents only: one customer c, one manufacturer m and one supplier s. The database schema Di for each agent i \u2208 {c,m, s} can therefore be given as:\n\u2022 Customer c: Dc = {Products(prod code, budget),PO(id , prod code, offer , status)};\n\u2022 Manufacturer m: Dm = {PO(id , prod code, offer , status),MO(id , prod code, price, status)};\n\u2022 Supplier s: Ds = {Materials(mat code, cost),MO(id , prod code, price, status)}.\nThe relations Products and Materials, as well as PO and MO are self-explanatory. Note the presence of the attribute status in the relations corresponding to artifacts.\nAs interpretation domain, we consider the infinite set Uotc of alphanumeric strings. Also, we assume that in the initial state the only non-empty relations are Products and Materials, which contain background information, such as the catalogue of available products.\nHence, the artifact-centric program ACPotc corresponding to the order-to-cash scenario can be given formally as follows:\nDefinition 7.1 The artifact-centric program ACPotc is a tuple \u3008Dotc, Uotc,\u03a3otc\u3009, where:\n\u2022 the program\u2019s database schema Dotc and interpretation domain Uotc are introduced as above, i.e., Dotc = Dc \u222aDm \u222aDs = {Products/2,PO/4,MO/4,Materials/2} and Uotc is the set of all alphanumeric strings.\n\u2022 \u03a3 = {\u03a3c,\u03a3m,\u03a3s} is the set of agent specifications for the customer c, the manufacturer m and the supplier s. Specifically, for each i \u2208 {c,m, s}, \u03a3i = \u3008Di, li0,\u2126i\u3009 is such that:\n\u2013 Di \u2286 D is agent i\u2019s database schema as detailed above, i.e., Dc = {Products/2,PO/4}, Dm = {PO/4,MO/4}, and Ds = {MO/4,Materials/2}.\n\u2013 lc0, lm0, and ls0 are database instances in Dc(Uotc), Dm(Uotc), and Ds(Uotc) respectively s.t. lc0(Products) and ls0(Materials) are not empty, i.e., they contain some background information, while lc0(PO), lm0(PO), lm0(MO) and ls0(MO) are empty.\n\u2013 We assume that \u2126c contains the actions createPO(prod code,offer), submitPO(po id), pay(po id), deletePO(po id). Similarly, \u2126m = {createMO(po id , price), doneMO(mo id), shipPO(po id), deleteMO(mo id)} and \u2126s = {acceptMO(mo id), rejectMO(mo id), shipMO(mo id)}.\nSystem actions capture legal operations on the underlying database and, thus, on artifacts. In Table 1 we report some of their specifications. Variables (from V ) and constants (from U ) are distinguished by fonts v and c, respectively. From Section 6 we adopt the convention that an action affects only those relations whose name occurs in \u03c8.\nConsider, for instance, the action createPO performed by the customer c, whose purpose is the creation of a PO artifact instance related to a given prod code. Its precondition requires that the action parameter prod code refers to an actual product in the Products database; while the postcondition guarantees that the offer value in PO is set equal to budget as well as the id of the new PO is unique. As regards the action createMO, performed by the manufacturer m and meant to create instances of MO artifacts, its precondition requires that po id is the identifier of some existing PO. Its postcondition states that, upon execution, the MO relation contains exactly one additional tuple, with identifier attribute set to id, with attribute status set to preparation and asking price set to price. As an example of action triggering an artifact\u2019s status transition, consider the action doneMO performed also by the manufacturer m. doneMO is executable only if the MO artifact is in status preparation; its effect is to set the status attribute to submitted. Finally, as an example of an action triggered by a choice, consider the action acceptMO performed by the supplier s. It is triggered only if the entries for the product code pc and the price p have matching values in the Materials database. The action outcome is to set the status attribute to accepted.\nNotice that although actions are typically conceived to manipulate artifacts of a specific class their preconditions and postconditions may depend on artifact instances of different classes. For example note that the action createMO manipulates MO artifacts, but its preconditions and postconditions may depend on artifact instances originating from different classes (e.g. createMO\u2019s\nprecondition depends on PO artifacts). We stress that action executability depends not only on the status attribute of an artifact, but on the data content of the whole database, i.e., of all other artifacts. Similarly, action executions affect not only status attributes. Most importantly, by using first-order formulas such as \u03c6b = \u2200x1, . . . , xb+1 \u2228\ni 6=j(xi = xj) in the postcondition \u03c8, we can guarantee that the AC program in question is bounded and is therefore amenable to the abstraction methodology of Section 6.\nWe now define the agents induced by the AC program ACPotc given above according to Definition 6.2.\nDefinition 7.2 Given the AC program ACPotc = \u3008Dotc, Uotc,\u03a3otc\u3009, the agents Ac, Am and As induced by ACPotc are defined as follows:\n\u2022 Ac = \u3008Dc, Lc, Actc, P rc\u3009, where (i) Dc is as above; (ii) Lc = Dc(Uotc); (iii) Actc = \u2126c = {createPO(prod code, offer), submitPO(po id), pay(po id), deletePO(po id)}; and (iv) \u03b1(~u) \u2208 Prc(lc) iff lc |= \u03c0(~v) for \u03b1(~u) = \u3008\u03c0(~v), \u03c8(~w)\u3009.\n\u2022 Am = \u3008Dm, Lm, Actm, P rm\u3009, where (i) Dm is as above; (ii) Lm = Dm(Uotc); (iii) Actm = \u2126m = {createMO(po id , price), doneMO(mo id), shipPO(po id), deleteMO(mo id)}; and (iv) \u03b1(~u) \u2208 Prm(lm) iff lm |= \u03c0(~v) for \u03b1(~u) = \u3008\u03c0(~v), \u03c8(~w)\u3009.\n\u2022 As = \u3008Ds, Ls, Acts, P rs\u3009, where (i) Ds is as above; (ii) Ls = Ds(Uotc); (iii) Acts = \u2126s = {acceptMO(mo id), rejectMO(mo id), shipMO(mo id)}; and (iv) \u03b1(~u) \u2208 Prs(ls) iff lm |= \u03c0(~v) for \u03b1(~u) = \u3008\u03c0(~v), \u03c8(~w)\u3009.\nBy the definition of Am we can see that createMO(po id, price) \u2208 Prm(lm) if and only if the interpretation lm(PO) of the relation PO in the local state lm contains a tuple \u3008po id, pc, o, prepared\u3009 for some product pc and offer o; while doneMO(mo id) \u2208 Prm(lm) iff lm(MO) contains a tuple in the interpretation lm(MO) with id mo id and status preparation. It can also be checked that, in line with our discussion in Section 2, a full version of the function \u03c4otc given above can easily encode the artifacts\u2019 lifecycles as given in Figure 3.\nWe can now define the AC-MAS generated by the set of agents {Ac, Am, As} according to Definition 6.3.\nDefinition 7.3 Given the AC program ACPotc and the set Ag = {Ac, Am, As} of agents induced by ACPotc, the AC-MAS induced by ACPotc is the tuple Potc = \u3008Sotc, Uotc, s0otc, \u03c4otc\u3009, where:\n\u2022 Sotc \u2286 Lc \u00d7 Lm \u00d7 Ls is the set of reachable states;\n\u2022 Uotc is the interpretation domain;\n\u2022 s0otc = \u3008lc0, lm0, ls0\u3009 is the initial global state, where the only non-empty relation are Products and Materials;\n\u2022 \u03c4otc is the global transition function defined according to Def. 6.3.\nAs an example we give a snippet of the transition function \u03c4otc by considering the global action \u03b1(~u) = \u3008createPO(pc), doneMO(m), acceptMO(m\u2032)\u3009 enabled by the respective protocols in a global state s. By the definition of the actions createPO(pc), doneMO(m), and acceptMO(m\u2032)\nwe have that li(s) \u2208 Pri for i \u2208 {c,m, s} implies that the Products relation contains information about the product pc. Also, the interpretation of the relation MO contains the tuples \u3008m, p, pr, preparation\u3009 and \u3008m\u2032, p\u2032, pr\u2032, submitted\u3009 for some products p and p\u2032.\nBy the definition of \u03c4otc it follows that for every s\u2032 \u2208 Sotc, s \u03b1(~u) \u2212\u2212\u2212\u2192 s\u2032 implies that Ds \u2295Ds\u2032 |=\n\u03c8createPO(pc) \u2227 \u03c8doneMO(m) \u2227 \u03c8acceptMO(m \u2032), that is,\nDs \u2295Ds\u2032 |= \u2203id, b (PO \u2032(id, pc, b, prepared) \u2227 Products(pc, b) \u2227\n\u2200id\u2032, p, o, s (PO(id\u2032, p, o, s) \u2192 id 6= id\u2032)) \u2227 \u2200w, p, pr, s ( (w 6= m \u2192 (MO(w, p, pr, s) \u2194 MO\u2032(w, p, pr, s))) \u2227\n(MO(m, p, pr, s) \u2192 (MO\u2032(m, p, pr, submitted) \u2227 (s 6= submitted \u2192 \u00acMO\u2032(m, p, pr, s)))) ) \u2227 \u2200w, p, pr, s ( (w 6= m\u2032 \u2192 (MO(w, p, pr, s) \u2194 MO\u2032(w, p, pr, s))) \u2227\n(MO(m\u2032, p, pr, s) \u2192 (MO\u2032(m\u2032, p, pr, accepted) \u2227 (s 6= accepted \u2192 \u00acMO\u2032(m\u2032, p, pr, s)))) )\nHence, the interpretation of the relation PO in Ds\u2032 extends Ds(PO) with the tuple \u3008id, pc, b, prepared\u3009, where id is a fresh id. The tuples for the material orders m and m\u2032 are updated in Ds\u2032(MO) by becoming \u3008m, p, pr, submitted\u3009 and \u3008m\u2032, p\u2032, pr\u2032, accepted\u3009, respectively. In view of the second condition on \u03c4otc in Definition 6.3, no other elements are changed in the transition. Finally, notice that these extensions are indeed the interpretations of PO and MO in Ds\u2032 . Thus, the operational semantics satisfies the intended meaning of actions.\nWe can now investigate properties of the AC program ACPotc by using specifications in FOCTLK. For instance, the following formula specifies that the manufacturer m knows that each material order MO has to match a corresponding purchase order PO:\n\u03d5match = AG \u2200id, pc (\u2203pr, s MO(id, pc, pr, s) \u2192 Km\u2203o, s \u2032PO(id, pc, o, s\u2032))\nThe next specification states that given a material order MO, the customer will eventually know that the corresponding PO will be shipped.\n\u03d5fulfil = AG \u2200id, pc (\u2203pr, s MO(id, pc, pr, s) \u2192 EF Kc\u2203o PO(id, pc, o, shipped))\nFurther, we may be interested in checking whether budget and costs are always kept secret from the supplier s and the customer c respectively, and whether the customer (resp., the supplier) knows this fact:\n\u03d5budget = Kc \u2200pc AG \u00ac\u2203b Ks Products(pc, b)\n\u03d5cost = Ks \u2200mc AG \u00ac\u2203c Kc Materials(mc, c)\nOther interesting specifications describing properties of the artifact system and the agents operating in it can be similarly formalised in FO-CTLK, thereby providing the engineer with a valuable tool to assess the implementation.\nWe now proceed to exploit the methodology of Section 6 to verify the AC program ACPotp. We use \u03d5match as an example specification; analogous results can be obtained for other formulas. Observe that according to Definition 6.3 the AC-MAS induced by ACPotp has infinitely many states.\nWe assume two interpretations for the relations Products and Materials, which determine an initial state D0. Consider the maximum number max of parameters and the constants C\u2126 in the operations in \u2126c, \u2126m and \u2126s. In the case under analysis we have that max = 2. We earlier remarked that formulas such as \u03c6b in the postcondition of actions force the AC-MAS Potc corresponding to ACPotc is bounded. Here we have that Potc is b-bounded. According to Corollary 4.14, we can therefore consider a finite domain U \u2032 such that\nU \u2032 \u2287 D0 \u222a C\u2126 \u222a const(\u03d5match)\nD0(Products) \u222aD0(Materials) \u222a C\u2126\nand such that\n|U \u2032| \u2265 2b+ |D0|+ |C\u2126|+ |const(\u03d5match)|+max\n= 2b+ |D0|+ |C\u2126|+ 2\nFor instance, we can consider any subset U \u2032 of Uotc satisfying the conditions above. Given that U \u2032 satisfies the hypothesis of Theorem 6.7, it follows that the AC program ACPotc over Uotc satisfies \u03d5match if and only if ACPotc over U \u2032 does. But the AC-MAS induced by the latter is a finite-state system, which can be constructively built by running the AC program ACPotc on the elements in U \u2032. Thus, ACPotc |= \u03d5match is a decidable instance of model checking that can be therefore solved by means of standard techniques.\nA manual check on the finite model indeed reveals that \u03d5match, \u03d5budget and \u03d5cost are satisfied in the finite model, whereas \u03d5fulfil is not. By Corollary 4.14 the AC-MAS Potc induced by ACPotp satisfies the same specifications. Hence, in view of Definition 6.5, we conclude that the artifactcentric program ACPotp satisfies \u03d5match, \u03d5budget and \u03d5cost but does not satisfy \u03d5fulfil . This is entirely in line with our intuitions of the scenario."}, {"heading": "8. Conclusions and Future Work", "text": "In this paper we put forward a methodology for verifying agent-based artifact-centric systems. We proposed AC-MAS, a novel semantics incorporating first-order features, that can be used to reason about multi-agent systems in an artifact-centric setting. We observed that the model checking problem for these structures against specifications given in a first-order temporal-epistemic logic is undecidable and proceeded to identify suitable fragments for which decidability can be retained.\nWe identified two orthogonal solutions to this issue. In the former we operated a restriction to the specification language and showed that, by limiting ourselves to sentence-atomic temporalepistemic specifications, infinite-state, bounded AC-MAS admit finite abstractions. In the latter we kept the full first-order temporal-epistemic logic but identified the noteworthy subset of uniform AC-MAS. In this setting we showed that bounded uniform AC-MAS admit finite abstractions. The abstractions we identified in each setting depend on novel notions of bisimulation at first-order that we proposed.\nWe explored the complexity of the model checking problem in this context and showed this to be EXPSPACE-complete. While this is obviously a hard problem, we need to consider that these are first-order structures which normally lead to undecidable problems. We were also reassured by the fact that the abstract interpretation domain is actually linear in the size of the bound considered.\nMindful of the practical needs for verification in artifact-centric systems, we then explored how finite abstractions can actually be built. To this end, rather than investigating one specific datacentric language, we defined a general class of declarative artifact-centric programs. We showed that these systems admit uniform AC-MAS as their semantics. Under the assumption of bounded systems we showed that model checking these multi-agent system programs is decidable and gave a constructive procedure operating on bisimilar, finite models. While the results are general, they can be instantiated for various artifact-centric languages. For instance (Belardinelli et al., 2012b) explores finite abstractions of GSM programs by using these results.\nWe exemplified the methodology put forward on a use-case consisting of several agents purchasing and delivering products. While the system has infinitely many states we showed it admits a finite abstraction that can be used to verify a variety of specifications on the system.\nA question left open in the present paper is whether the uniform condition we provided is tight. While we showed this to be a sufficient condition, we did not explore whether this is necessary for finite abstractions or whether more general properties can be given. In this context it is of interest that artifact-centric programs generate uniform structures. Also, it will be worthwhile to explore whether a notion related to uniformity can be applied to other domains in AI, for example to retain decidability of specific calculi. This would appear to be the case as preliminary studies in the Situation Calculus demonstrate (De Giacomo, Lespe\u0301rance, & Patrizi, 2012).\nOn the application side, we are also interested in exploring ways to use the results of this paper to build a model checker for artifact-centric MAS. Previous efforts in this area, including (Gonzalez, Griesmayer, & Lomuscio, 2012), are limited to finite state systems. It would therefore be of great interest to construct finite abstractions on the fly to check practical e-commerce scenarios such as the one here discussed."}], "references": [{"title": "Web Services - Concepts, Architectures and Applications. Data-Centric Systems and Applications", "author": ["G. Alonso", "F. Casati", "H.A. Kuno", "V. Machiraju"], "venue": null, "citeRegEx": "Alonso et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Alonso et al\\.", "year": 2004}, {"title": "Web Services Business Process Execution Language Version 2.0. http://docs.oasis-open.org/wsbpel/2.0/wsbpel-v2.0.pdf", "author": ["Alves"], "venue": null, "citeRegEx": "Alves,? \\Q2007\\E", "shortCiteRegEx": "Alves", "year": 2007}, {"title": "A Knowledge Based Analysis of Cache Coherence", "author": ["K. Baukus", "R. van der Meyden"], "venue": "In Proc. of the 6th International Conference on Formal Engineering Methods (ICFEM\u201904),", "citeRegEx": "Baukus and Meyden,? \\Q2004\\E", "shortCiteRegEx": "Baukus and Meyden", "year": 2004}, {"title": "Interactions between Knowledge and Time in a First-Order Logic for Multi-Agent Systems: Completeness Results", "author": ["F. Belardinelli", "A. Lomuscio"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Belardinelli and Lomuscio,? \\Q2012\\E", "shortCiteRegEx": "Belardinelli and Lomuscio", "year": 2012}, {"title": "A Computationally-Grounded Semantics for Artifact-Centric Systems and Abstraction Results", "author": ["F. Belardinelli", "A. Lomuscio", "F. Patrizi"], "venue": "In Proc. of the 22nd International Joint Conference on Artificial Intelligence", "citeRegEx": "Belardinelli et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Belardinelli et al\\.", "year": 2011}, {"title": "Verification of Deployed Artifact Systems via Data Abstraction", "author": ["F. Belardinelli", "A. Lomuscio", "F. Patrizi"], "venue": "In Proc. of the 9th International Conference on Service-Oriented Computing", "citeRegEx": "Belardinelli et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Belardinelli et al\\.", "year": 2011}, {"title": "An Abstraction Technique for the Verification of Artifact-Centric Systems", "author": ["F. Belardinelli", "A. Lomuscio", "F. Patrizi"], "venue": "In Proc. of the 13th International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "Belardinelli et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Belardinelli et al\\.", "year": 2012}, {"title": "Verification of GSM-Based Artifact-Centric Systems through Finite Abstraction", "author": ["F. Belardinelli", "A. Lomuscio", "F. Patrizi"], "venue": "In Proc. of the 10th International Conference on ServiceOriented Computing", "citeRegEx": "Belardinelli et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Belardinelli et al\\.", "year": 2012}, {"title": "Automatic Composition of Transition-based Semantic Web Services with Messaging", "author": ["D. Berardi", "D. Calvanese", "G.D. Giacomo", "R. Hull", "M. Mecella"], "venue": "In Proc. of the 31st International Conference on Very Large Data Bases", "citeRegEx": "Berardi et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Berardi et al\\.", "year": 2005}, {"title": "Automatic Service Composition via Simulation", "author": ["D. Berardi", "F. Cheikh", "G.D. Giacomo", "F. Patrizi"], "venue": "International Journal of Foundations of Computer Science,", "citeRegEx": "Berardi et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Berardi et al\\.", "year": 2008}, {"title": "Automated Composition of Web Services via Planning in Asynchronous Domains", "author": ["P. Bertoli", "M. Pistore", "P. Traverso"], "venue": "Artificial Intelligence,", "citeRegEx": "Bertoli et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bertoli et al\\.", "year": 2010}, {"title": "Towards Formal Analysis of Artifact-Centric Business Process Models", "author": ["K. Bhattacharya", "C.E. Gerede", "R. Hull", "R. Liu", "J. Su"], "venue": "In Proc. of the 5th International Conference on Business Process Management", "citeRegEx": "Bhattacharya et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Bhattacharya et al\\.", "year": 2007}, {"title": "Bounded Model Checking", "author": ["A. Biere", "A. Cimatti", "E.M. Clarke", "O. Strichman", "Y. Zhu"], "venue": "Advances in Computers,", "citeRegEx": "Biere et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Biere et al\\.", "year": 2003}, {"title": "Modal Logic, Vol. 53 of Cambridge Tracts in Theoretical Computer Science", "author": ["P. Blackburn", "M. de Rijke", "Y. Venema"], "venue": null, "citeRegEx": "Blackburn et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Blackburn et al\\.", "year": 2001}, {"title": "Automatic Service Composition and Synthesis: the Roman Model", "author": ["D. Calvanese", "G.D. Giacomo", "M. Lenzerini", "M. Mecella", "F. Patrizi"], "venue": "IEEE Data Engineering Bulletin,", "citeRegEx": "Calvanese et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2008}, {"title": "Computing Knowledge in Security Protocols Under Convergent Equational Theories", "author": ["S. Ciobaca", "S. Delaune", "S. Kremer"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Ciobaca et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Ciobaca et al\\.", "year": 2012}, {"title": "Business Artifacts: A Data-Centric Approach to Modeling Business Operations and Processes", "author": ["D. Cohn", "R. Hull"], "venue": "IEEE Data Engineering Bulletin,", "citeRegEx": "Cohn and Hull,? \\Q2009\\E", "shortCiteRegEx": "Cohn and Hull", "year": 2009}, {"title": "Artifact Systems with Data Dependencies and Arithmetic", "author": ["E. Damaggio", "A. Deutsch", "V. Vianu"], "venue": "ACM Transactions on Database Systems,", "citeRegEx": "Damaggio et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Damaggio et al\\.", "year": 2012}, {"title": "On the Equivalence of Incremental and Fixpoint Semantics for Business Artifacts with Guard-Stage-Milestone Lifecycles", "author": ["E. Damaggio", "R. Hull", "R. Vacul\u0131\u0301n"], "venue": "In Proc. of the 9th International Conference on Business Process Management (BPM\u201911)", "citeRegEx": "Damaggio et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Damaggio et al\\.", "year": 2011}, {"title": "Bounded Situation Calculus Action Theories and Decidable Verification", "author": ["G. De Giacomo", "Y. Lesp\u00e9rance", "F. Patrizi"], "venue": "In Proc. of the 13th International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "Giacomo et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Giacomo et al\\.", "year": 2012}, {"title": "To Know or not to Know: Epistemic Approaches to Security Protocol", "author": ["F. Dechesne", "Y. Wang"], "venue": "Verification. Synthese,", "citeRegEx": "Dechesne and Wang,? \\Q2010\\E", "shortCiteRegEx": "Dechesne and Wang", "year": 2010}, {"title": "Automatic Verification of Data-centric Business Processes", "author": ["A. Deutsch", "R. Hull", "F. Patrizi", "V. Vianu"], "venue": "In Proc. of the 12th International Conference on Database Theory (ICDT\u201909),", "citeRegEx": "Deutsch et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Deutsch et al\\.", "year": 2009}, {"title": "Specification and Verification of Data-Driven Web Applications", "author": ["A. Deutsch", "L. Sui", "V. Vianu"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Deutsch et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Deutsch et al\\.", "year": 2007}, {"title": "Reasoning About Knowledge", "author": ["R. Fagin", "J.Y. Halpern", "Y. Moses", "M.Y. Vardi"], "venue": null, "citeRegEx": "Fagin et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Fagin et al\\.", "year": 1995}, {"title": "MCK: Model Checking the Logic of Knowledge", "author": ["P. Gammie", "R. van der Meyden"], "venue": "In Proc. of 16th International Conference on Computer Aided Verification", "citeRegEx": "Gammie and Meyden,? \\Q2004\\E", "shortCiteRegEx": "Gammie and Meyden", "year": 2004}, {"title": "Specification and Verification of Artifact Behaviors in Business Process Models", "author": ["C.E. Gerede", "J. Su"], "venue": "In Proc. of the 5th International Conference on Service-Oriented Computing", "citeRegEx": "Gerede and Su,? \\Q2007\\E", "shortCiteRegEx": "Gerede and Su", "year": 2007}, {"title": "Verifying GSM-Based Business Artifacts", "author": ["P. Gonzalez", "A. Griesmayer", "A. Lomuscio"], "venue": "In Proc. of the 19th IEEE International Conference on Web Services", "citeRegEx": "Gonzalez et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Gonzalez et al\\.", "year": 2012}, {"title": "Generalized Model-Checking Problems for First-Order Logic", "author": ["M. Grohe"], "venue": "Proc. of the 18th Annual Symposium on Theoretical Aspects of Computer Science (STACS\u201901), pp. 12\u201326.", "citeRegEx": "Grohe,? 2001", "shortCiteRegEx": "Grohe", "year": 2001}, {"title": "Verification of Relational Data-Centric Dynamic Systems with External Services. CoRR, abs/1203.0024", "author": ["B.B. Hariri", "D. Calvanese", "G.D. Giacomo", "A. Deutsch", "M. Montali"], "venue": null, "citeRegEx": "Hariri et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hariri et al\\.", "year": 2012}, {"title": "Barcelona: A Design and Runtime Environment for Modeling and Execution of Artifact-centric Business Processes (demo)", "author": ["F.T. Heath", "R. Hull", "R. Vacul\u0131\u0301n"], "venue": "In Proc. of the 9th International Conference on Business Process Management Demo Track (BPM\u201911)", "citeRegEx": "Heath et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Heath et al\\.", "year": 2011}, {"title": "Artifact-Centric Business Process Models: Brief Survey of Research Results and Challenges", "author": ["R. Hull"], "venue": "Proc. (part II) of Confederated International Conferences, CoopIS, DOA, GADA, IS, and ODBASE 2008 (On the Move to Meaningful Internet Systems: OTM\u201908), pp. 1152\u20131163.", "citeRegEx": "Hull,? 2008", "shortCiteRegEx": "Hull", "year": 2008}, {"title": "Business Artifacts with Guard-Stage-Milestone Lifecycles: Managing Artifact Interactions with Conditions and Events", "author": ["R. Hull", "E. Damaggio", "R. De Masellis", "F. Fournier", "M. Gupta", "III Heath", "F. T", "S. Hobson", "M. Linehan", "S. Maradugu", "A. Nigam", "P.N. Sukaviriya", "R. Vaculin"], "venue": "In Proc. of the 5th ACM International Conference on Distributed Event-Based Systems", "citeRegEx": "Hull et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Hull et al\\.", "year": 2011}, {"title": "Facilitating Workflow Interoperation Using ArtifactCentric Hubs", "author": ["R. Hull", "N.C. Narendra", "A. Nigam"], "venue": "In Proc. of the 7th International Conference on Service-Oriented Computing (ICSOC-ServiceWave", "citeRegEx": "Hull et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Hull et al\\.", "year": 2009}, {"title": "VerICS 2007 - a Model Checker for Knowledge and Real-Time", "author": ["M. Kacprzak", "W. Nabialek", "A. Niewiadomski", "W. Penczek", "A. P\u00f3lrola", "M. Szreter", "B. Wozna", "A. Zbrzezny"], "venue": "Fundamenta Informaticae,", "citeRegEx": "Kacprzak et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Kacprzak et al\\.", "year": 2008}, {"title": "An Automata-Theoretic Approach to BranchingTime Model Checking", "author": ["O. Kupferman", "M.Y. Vardi", "P. Wolper"], "venue": "Journal of the ACM,", "citeRegEx": "Kupferman et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Kupferman et al\\.", "year": 2000}, {"title": "MCMAS: A Model Checker for the Verification of Multi-Agent Systems", "author": ["A. Lomuscio", "H. Qu", "F. Raimondi"], "venue": "In Proc. of the 21st International Conference on Computer Aided Verification", "citeRegEx": "Lomuscio et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lomuscio et al\\.", "year": 2009}, {"title": "Towards Verifying Contract Regulated Service Composition", "author": ["A. Lomuscio", "H. Qu", "M. Solanki"], "venue": "Autonomous Agents and Multi-Agent Systems,", "citeRegEx": "Lomuscio et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Lomuscio et al\\.", "year": 2012}, {"title": "Runtime Monitoring of Contract Regulated Web Services", "author": ["A. Lomuscio", "M. Solanki", "W. Penczek", "M. Szreter"], "venue": "In Proc. of the 9th International Conference on Autonomous Agents and Multiagent Systems", "citeRegEx": "Lomuscio et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Lomuscio et al\\.", "year": 2010}, {"title": "Data Centric BPM and the Emerging Case Management Standard: A Short Survey", "author": ["M. Marin", "R. Hull", "R. Vacul\u0131\u0301n"], "venue": "In Proc. of the 1st (BPM) International Workshop on Adaptive Case Management", "citeRegEx": "Marin et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Marin et al\\.", "year": 2012}, {"title": "Business Artifacts: An Approach to Operational Specification", "author": ["A. Nigam", "N.S. Caswell"], "venue": "IBM Systems Journal,", "citeRegEx": "Nigam and Caswell,? \\Q2003\\E", "shortCiteRegEx": "Nigam and Caswell", "year": 2003}, {"title": "Automatic Discovery of Data-Centric and Artifact-Centric Processes", "author": ["E. Nooijen", "D. Fahland", "B.V. Dongen"], "venue": "In Proc. of the 1st (BPM) Workshop on Data- & Artifact-centric BPM (DAB\u201912)", "citeRegEx": "Nooijen et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Nooijen et al\\.", "year": 2012}, {"title": "Computational complexity", "author": ["C.H. Papadimitriou"], "venue": "Addison-Wesley.", "citeRegEx": "Papadimitriou,? 1994", "shortCiteRegEx": "Papadimitriou", "year": 1994}, {"title": "Distributed Processes and the Logic of Knowledge", "author": ["R. Parikh", "R. Ramanujam"], "venue": "In Proc. of Logics of Programs,", "citeRegEx": "Parikh and Ramanujam,? \\Q1985\\E", "shortCiteRegEx": "Parikh and Ramanujam", "year": 1985}, {"title": "Verifying Epistemic Properties of Multi-agent Systems via Bounded Model Checking", "author": ["W. Penczek", "A. Lomuscio"], "venue": "Fundamenta Informaticae,", "citeRegEx": "Penczek and Lomuscio,? \\Q2003\\E", "shortCiteRegEx": "Penczek and Lomuscio", "year": 2003}, {"title": "Service-Oriented Computing: Semantics, Processes", "author": ["M.P. Singh", "M.N. Huhns"], "venue": null, "citeRegEx": "Singh and Huhns,? \\Q2005\\E", "shortCiteRegEx": "Singh and Huhns", "year": 2005}, {"title": "Computationally Grounded Theories of Agency", "author": ["M. Wooldridge"], "venue": "Proc. of the 4th International Conference on Multi-Agent Systems (ICMAS\u201900), pp. 13\u201322.", "citeRegEx": "Wooldridge,? 2000", "shortCiteRegEx": "Wooldridge", "year": 2000}, {"title": "Introduction to Multiagent Systems", "author": ["M. Wooldridge"], "venue": "John Wiley & Sons, Inc.", "citeRegEx": "Wooldridge,? 2001", "shortCiteRegEx": "Wooldridge", "year": 2001}], "referenceMentions": [{"referenceID": 45, "context": "The approaches based on modal logic are often rooted on interpreted systems (Parikh & Ramanujam, 1985), a computationally grounded semantics (Wooldridge, 2000) used for the interpretation of several temporal-epistemic logics.", "startOffset": 141, "endOffset": 159}, {"referenceID": 30, "context": "Firstly, the artifact systems literature (Bhattacharya, Gerede, Hull, Liu, & Su, 2007; Deutsch, Hull, Patrizi, & Vianu, 2009; Hull, 2008; Nooijen, Fahland, & Dongen, 2012) focuses exclusively on the artifacts themselves.", "startOffset": 41, "endOffset": 171}, {"referenceID": 0, "context": "Two technology-independent concepts permeate the service-oriented literature: orchestration and choreography (Alonso et al., 2004; Singh & Huhns, 2005).", "startOffset": 109, "endOffset": 151}, {"referenceID": 46, "context": "A MAS perspective (Wooldridge, 2001) is known to be particularly helpful in service-oriented computing in that it allows us to ascribe information states and private or common goals to the various services.", "startOffset": 18, "endOffset": 36}, {"referenceID": 30, "context": "As described in (Hull, 2008; Hull, Damaggio, De Masellis, Fournier, Gupta, Heath, Hobson, Linehan, Maradugu, Nigam, Sukaviriya, & Vaculin, 2011) artifact-centric systems can be presented along four dimensions.", "startOffset": 16, "endOffset": 144}, {"referenceID": 31, "context": "Since events may trigger changes in several artifacts in the system, events are processed by a well-defined semantics (Damaggio, Hull, & Vacul\u0131\u0301n, 2011; Hull et al., 2011) that governs the sequence of changes an artifact-system may undertake upon consumption of an event.", "startOffset": 118, "endOffset": 171}, {"referenceID": 29, "context": "BARCELONA is an engine that can be used to run a GSM-based artifact-centric system (Heath et al., 2011).", "startOffset": 83, "endOffset": 103}, {"referenceID": 30, "context": "We refer to (Cohn & Hull, 2009; Hull, 2008; Hull et al., 2011) for more details.", "startOffset": 12, "endOffset": 62}, {"referenceID": 31, "context": "We refer to (Cohn & Hull, 2009; Hull, 2008; Hull et al., 2011) for more details.", "startOffset": 12, "endOffset": 62}, {"referenceID": 11, "context": "To our knowledge the verification of artifact-centric business processes was first discussed in (Bhattacharya et al., 2007), where reachability and deadlocks are phrased in the context of", "startOffset": 96, "endOffset": 123}, {"referenceID": 11, "context": "The present contribution differs markedly from (Bhattacharya et al., 2007) by employing a more expressive specification language, even if the agent-related aspects are not considered, and by putting forward effective abstraction procedures for verification.", "startOffset": 47, "endOffset": 74}, {"referenceID": 21, "context": "A related line of research is followed in (Deutsch et al., 2009; Damaggio, Deutsch, & Vianu, 2012), where the verification problem for artifact systems against two variants of first-order lineartime temporal logic is considered.", "startOffset": 42, "endOffset": 98}, {"referenceID": 17, "context": "Properties based on arithmetic operators are considered in (Damaggio et al., 2012).", "startOffset": 59, "endOffset": 82}, {"referenceID": 21, "context": "Secondly, differently from (Deutsch et al., 2009; Damaggio et al., 2012), we impose no constraints on nested quantifiers.", "startOffset": 27, "endOffset": 72}, {"referenceID": 17, "context": "Secondly, differently from (Deutsch et al., 2009; Damaggio et al., 2012), we impose no constraints on nested quantifiers.", "startOffset": 27, "endOffset": 72}, {"referenceID": 17, "context": "In contrast, (Damaggio et al., 2012) admits only universal quantification over combinations of quantifier-free first-order formulas.", "startOffset": 13, "endOffset": 36}, {"referenceID": 28, "context": "However, differently from the contribution here presented, (Hariri et al., 2012) assume limited forms of quantification whereby only individuals persisting in the system evolution can be quantified over.", "startOffset": 59, "endOffset": 80}, {"referenceID": 23, "context": "A standard paradigm for logic-based reasoning about agent systems is interpreted systems (Parikh & Ramanujam, 1985; Fagin et al., 1995).", "startOffset": 89, "endOffset": 135}, {"referenceID": 23, "context": "In line with the interpreted systems semantics (Fagin et al., 1995) not everything in the agents\u2019 states needs to be present in the environment; a portion of it may be entirely private and not replicated in other agents\u2019 states.", "startOffset": 47, "endOffset": 67}, {"referenceID": 23, "context": "In this sense we follow (Fagin et al., 1995) but require that this information is structured as a database.", "startOffset": 24, "endOffset": 44}, {"referenceID": 23, "context": "As in plain interpreted systems (Fagin et al., 1995), we say that two global states s = \u3008l0, .", "startOffset": 32, "endOffset": 52}, {"referenceID": 13, "context": "Plain bisimulations are known to be satisfaction preserving in a modal propositional setting (Blackburn et al., 2001).", "startOffset": 93, "endOffset": 117}, {"referenceID": 27, "context": "Hereafter we follow (Grohe, 2001) for basic notions and definitions.", "startOffset": 20, "endOffset": 33}, {"referenceID": 41, "context": "We assume standard definitions of Turing machines and reductions (Papadimitriou, 1994).", "startOffset": 65, "endOffset": 86}, {"referenceID": 31, "context": "As we remarked in the introduction, however, artifact-centric systems are typically implemented through declarative languages such as GSM (Hull et al., 2011).", "startOffset": 138, "endOffset": 157}, {"referenceID": 29, "context": "Since artifact systems are also typically implemented declaratively (see (Heath et al., 2011)) in what follows AC programs will be used to encode both the artifact system itself and the agents in the system.", "startOffset": 73, "endOffset": 93}, {"referenceID": 31, "context": "In this section we exemplify the methodology presented so far in the context of a business process inspired by an IBM customer use-case (Hull et al., 2011).", "startOffset": 136, "endOffset": 155}], "year": 2017, "abstractText": "Artifact systems are a novel paradigm for specifying and implementing business processes described in terms of interacting modules called artifacts. Artifacts consist of data and lifecycles, accounting respectively for the relational structure of the artifacts\u2019 states and their possible evolutions over time. In this paper we put forward artifact-centric multi-agent systems, a novel formalisation of artifact systems in the context of multi-agent systems operating on them. Differently from the usual process-based models of services, the semantics we give explicitly accounts for the data structures on which artifact systems are defined. We study the model checking problem for artifact-centric multi-agent systems against specifications written in a quantified version of temporal-epistemic logic expressing the knowledge of the agents in the exchange. We begin by noting that the problem is undecidable in general. We then identify two noteworthy restrictions, one syntactical and one semantical, that enable us to find bisimilar finite abstractions and therefore reduce the model checking problem to the instance on finite models. Under these assumptions we show that the model checking problem for these systems is EXPSPACE-complete. We then introduce artifact-centric programs, compact and declarative representations of the programs governing both the artifact system and the agents. We show that, while these in principle generate infinite-state systems, under natural conditions their verification problem can be solved on finite abstractions that can be effectively computed from the programs. Finally we exemplify the theoretical results of the paper through a mainstream procurement scenario from the artifact systems literature.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}