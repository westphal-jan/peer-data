{"id": "1301.6479", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Jan-2013", "title": "Ontology-based Data Access: A Study through Disjunctive Datalog, CSP, and MMSNP", "abstract": "ontology - based data resource access is concerned with querying incomplete data sources in the presence of domain - scope specific knowledge provided by an ontology. often a central notion in this setting is that of an ontology - mediated query, which is a remote database query coupled with an ontology. in this paper, we study several classes of ontology - mediated queries, both where the database queries are given as some form of conjunctive query and the ontologies are repeatedly formulated in description logics or other relevant fragments of first - order logic, such as the guarded fragment and the unary - negation fragment. the contributions of the paper are three - fold. first, we characterize the actual expressive power of ontology - mediated queries in terms of fragments of disjunctive datalog. second, we establish intimate connections between internal ontology - mediated queries and constraint satisfaction problems ( csps ) together and their logical generalization, containing mmsnp formulas. third, we exploit these connections to obtain new results regarding ( i ) first - order rewritability and datalog - rewritability of ontology - mediated queries, ( ii ) p / np dichotomies for ontology - mediated queries, and ( iii ) the query containment problem for ontology - mediated queries.", "histories": [["v1", "Mon, 28 Jan 2013 09:11:54 GMT  (113kb,D)", "https://arxiv.org/abs/1301.6479v1", null], ["v2", "Thu, 6 Jun 2013 12:52:59 GMT  (117kb,D)", "http://arxiv.org/abs/1301.6479v2", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["meghyn bienvenu", "balder ten cate", "carsten lutz", "frank wolter"], "accepted": false, "id": "1301.6479"}, "pdf": {"name": "1301.6479.pdf", "metadata": {"source": "CRF", "title": "Ontology-based Data Access: A Study through Disjunctive Datalog, CSP, and MMSNP", "authors": ["Meghyn Bienvenu", "Balder ten Cate", "Carsten Lutz", "Frank Wolter"], "emails": [], "sections": [{"heading": "Categories and Subject Descriptors", "text": "H.2.3 [Database Management]: Languages\u2014Query languages; H.2.5 [Database Management]: Heterogeneous Databases"}, {"heading": "Keywords", "text": "Ontology-Based Data Access; Query Answering; Query Rewriting"}, {"heading": "1. INTRODUCTION", "text": "Ontologies are logical theories that formalize domain-specific knowledge, thereby making it available for machine processing. Recent years have seen an increasing interest in using ontologies in data-intensive applications, especially in the context of intelligent systems, the semantic web, and in data integration. A much studied scenario is that of answering queries over an incomplete database under the open world semantics, taking into account knowledge\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PODS\u201913, June 22\u201327, 2013, New York, New York, USA. Copyright 2013 ACM 978-1-4503-2066-5/13/06 ...$15.00.\nprovided by an ontology [19, 18, 16]. We refer to this as ontologybased data access (OBDA).\nThere are several important use cases for OBDA. A classical one is to enrich an incomplete data source with background knowledge, in order to obtain a more complete set of answers to a query. For example, if a medical patient database contains the facts that patient1 has finding Erythema Migrans and patient2 has finding Lyme disease, and the ontology provides the background knowledge that a finding of Erythema Migrans is sufficient for diagnosing Lyme disease, then both patient1 and patient2 can be returned when querying for patients that have the diagnosis Lyme disease. This use of ontologies is also central to query answering in the semantic web. OBDA can also be used to enrich the data schema (that is, the relation symbols used in the presentation of the data) with additional symbols to be used in a query. For example, a patient database may contain facts such as patient1 has diagnosis Lyme disease and patient2 has diagnosis Listeriosis, and an ontology could add the knowledge that Lyme disease and Listeriosis are both bacterial infections, thus enabling queries such as \u201creturn all patients with a bacterial infection\u201d despite the fact that the data schema does not include a relation or attribute explicitly referring to bacterial infections. Especially in the bio-medical domain, applications of this kind are fueled by the availability of comprehensive professional ontologies such as SNOMED CT and FMA. A third prominent application of OBDA is in data integration, where an ontology can be used to provide a uniform view on multiple data sources [40]. This typically involves mappings from the source schemas to the schema of the ontology, which we will not explicitly consider here.\nWe may view the actual database query and the ontology as two components of one composite query, which we call an ontologymediated query. OBDA can then be described as the problem of answering ontology-mediated queries. The database queries used in OBDA are typically unions of conjunctive queries, while the ontologies are typically specified in an ontology language that is either a description logic, or, more generally, a suitable fragment of first-order logic. For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32]. In particular, relevant classes of ontology-mediated queries have been identified that admit an FO-rewriting (i.e., that are equivalent to a first-order query), or, alternatively, admit a datalog-rewriting. FO-rewritings make it possible to answer ontology-based queries using traditional database management systems. This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42]. ar X\niv :1\n30 1.\n64 79\nv2 [\ncs .D\nB ]\n6 J\nun 2\n01 3\nThe main aims of this paper are (i) to characterize the expressive power of ontology-mediated queries, both in terms of more traditional database query languages and from a descriptive complexity perspective and (ii) to make progress towards complete and decidable classifications of ontology-mediated queries, with respect to their data complexity, as well as with respect to FO-rewritability and datalog-rewritability.\nWe take an ontology-mediated query to be a triple (S,O, q) where S is a data schema, O an ontology, and q a query. Here, the data schema S fixes the set of relation symbols than can occur in the data and the ontology O is a logical theory that may use the relation symbols from S as well as additional symbols. The query q can use any relation symbol that occurs in S or O. As ontology languages, we consider a range of standard description logics (DLs) and several fragments of first-order logic that embed ontology languages such as Datalog\u00b1 [15], namely the guarded fragment (GF), the unary negation fragment (UNFO), and the guarded negation fragment (GNFO). As query languages for q, we focus on unions of conjunctive queries (UCQs) and unary atomic queries (AQs). The latter are of the form A(x), with A a unary relation symbol, and correspond to what are traditionally called instance queries in the OBDA literature (note that A may be a relation symbol from O that is not part of the data schema). These two query languages are among the most used query languages in OBDA. In the following, we use (L,Q) to denote the query language that consists of all ontology-mediated queries (S,O, q) with O specified in the ontology language L and q specified in the query language Q. For example, (GF,UCQ) refers to ontologymediated queries in whichO is a GF-ontology and q is a UCQ. We refer to such query languages (L,Q) as ontology-mediated query languages (or, OBDA languages).\nIn Section 3, we characterize the expressive power of OBDA languages in terms of natural fragments of (negation-free) disjunctive datalog. We first consider the basic description logic ALC. We show that (ALC,UCQ) has the same expressive power as monadic disjunctive datalog (abbreviated MDDlog) and that (ALC,AQ) has the same expressive power as unary queries defined in a syntactic fragment of MDDlog that we call connected simple MDDlog. Similar results hold for various description logics that extendALC with, for example, inverse roles, role hierarchies, and the universal role, all of which are standard operators included in the W3Cstandardized ontology language OWL2 DL. Turning to other fragments of first-order logic, we then show that (UNFO,UCQ) also has the same expressive power as MDDlog, while (GF,UCQ) and (GNFO,UCQ) are strictly more expressive and coincide in expressive power with frontier-guarded disjunctive datalog, which is the DDlog fragment given by programs in which, for every atom \u03b1 in the head of a rule, there is an atom \u03b2 in the rule body that contains all variables from \u03b1.\nIn Sections 4 and 5, we study ontology-mediated queries from a descriptive complexity perspective. In particular, we establish an intimate connection between OBDA query languages, constraint satisfaction problems, and MMSNP. Recall that constraint satisfaction problems (CSPs) form a subclass of the complexity class NP that, although it contains NP-hard problems, is in certain ways more computationally well-behaved. The widely known FederVardi conjecture [24] states that there is a dichotomy between PTIME and NP for the class of all CSPs, that is, each CSP is either in PTIME or NP-hard. In other words, the conjecture asserts that there are no CSPs which are NP-intermediate in the sense of Ladner\u2019s theorem. Monotone monadic strict NP without inequality (abbreviated MMSNP) was introduced by Feder and Vardi as a logical generalization of CSP that enjoys similar computational\nproperties [24]. In particular, it was shown in [24, 33] that there is a dichotomy between PTIME and NP for MMSNP sentences if and only if the Feder-Vardi conjecture holds.\nIn Section 4, we observe that (ALC,UCQ) and many other OBDA languages based on UCQs have the same expressive power as the query language coMMSNP, consisting of all queries whose complement is definable by an MMSNP formula with free variables. In the spirit of descriptive complexity theory, we say that (ALC,UCQ) captures coMMSNP. In fact, this result is a consequence of the results in Section 3 and the observation that MDDlog has the same expressive power as coMMSNP. It has fundamental consequences regarding the data complexity of ontology-mediated queries and the containment problem for such queries, which we describe next.\nFirst, we obtain that there is a dichotomy between PTIME and CONP for ontology-mediated queries from (ALC,UCQ) if and only if the Feder-Vardi conjecture holds, and similarly for many other OBDA languages based on UCQs. To appreciate this result, recall that considerable effort has been directed towards identifying tractable classes of ontology-mediated queries. Ideally, one would like to classify the data complexity of every ontology-mediated query within a given OBDA language such as (ALC,UCQ). Our aforementioned result ties this task to proving the Feder-Vardi conjecture. Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ). We also consider the standard extension ALCF of ALC with functional roles and note that, for query evaluation in (ALCF ,AQ), there is no dichotomy between PTIME and CONP unless PTIME = NP.\nTo establish a counterpart of (GF,UCQ) and (GNFO,UCQ) in the MMSNP world, we introduce guarded monotone strict NP (abbreviated GMSNP) as a generalization of MMSNP; specifically, GMSNP is obtained from MMSNP by allowing guarded secondorder quantification in the place of monadic second-order quantification, similarly as in the transition from MDDlog to frontierguarded disjunctive datalog. The resulting query language coGMSNP has the same expressive power as frontier-guarded disjunctive datalog, and therefore, in particular, (GF,UCQ) and (GNFO,UCQ) capture coGMSNP. We observe that GMSNP has the same expressive power as the extension MMSNP2 of MMSNP proposed in [37]. It follows from our results in Section 3 that GMSNP (and thus MMSNP2) is strictly more expressive than MMSNP, closing an open problem from [37]. We leave it as an open problem whether GMSNP is computationally as well-behaved as MMSNP, that is, whether there is a dichotomy between PTIME and NP if the Feder-Vardi conjecture holds.\nThe second application of the connection between OBDA and MMSNP concerns query containment. It was shown in [24] that containment between MMSNP sentences is decidable. We use this result to prove that query containment is decidable for many OBDA languages based on UCQs, including (ALC,UCQ) and (GF,UCQ). Note that this refers to a very general form of query containment in OBDA, as recently introduced and studied in [10]. For (ALCF ,AQ), this problem (and every other decision problem discussed below) turns out to be undecidable.\nIn Section 5, we consider OBDA languages based on atomic queries and establish a tight connection to (certain generalizations of) CSPs. This connection is most easily stated for Boolean atomic queries (BAQs): we prove that (ALC,BAQ) captures the query language that consists of all Boolean queries definable as the complement of a CSP. Similarly (ALC,AQ) extended with the uni-\nversal role captures the query language that consists of all unary queries definable as the complement of a generalized CSP, which is given by a finite collection of structures enriched with a constant symbol. We then proceed to transfer results from the CSP literature to the ontology-mediated query languages (ALC, BAQ) and (ALC, AQ). First we immediately obtain that the existence of a PTIME/CONP dichotomy for these ontology-mediated query languages is equivalent to the Feder-Vardi conjecture. Then we show that query containment is not only decidable (as we could already conclude from the connection with coMMSNP described in Section 4), but, in fact, NEXPTIME-complete. Finally, taking advantage of recent results for CSPs [35, 26, 13], we are able to show that FO-rewritability and datalog-rewritability, as properties of ontology-mediated queries, are decidable and NEXPTIMEcomplete for (ALC, AQ) and (ALC,BAQ).\nThe results in Sections 4 and 5 just summarized are actually proved not only forALC, but also for several of its extensions. This relies on the equivalences between DL-based OBDA-languages established in Section 3.\nRelated Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44]. This research is concerned with answer-preserving translations of ontology-mediated queries into disjunctive datalog. In contrast to the current paper, it does not consider the expressive power of ontology-mediated queries, nor their descriptive complexity. A connection between DL-based OBDA and CSPs was first found and exploited in [36], in a setup that is different from the one studied in this paper. In particular, instead of focusing on ontology-mediated queries that consist of a data schema, an ontology, and a database query, [36] concentrates on ontologies while quantifying universally over all database queries and without fixing a data schema. It establishes links to the Feder-Vardi conjecture that are incomparable to the ones found in this paper, and does not consider the expressive power and descriptive complexity of queries used in OBDA."}, {"heading": "2. PRELIMINARIES", "text": "Schemas, Instances, and Queries. A schema is a finite collection S = (S1, . . . , Sk) of relation symbols with associated arity. A fact over S is an expression of the form S(a1, . . . , an) where S \u2208 S is an n-ary relation symbol, and a1, . . . , an are elements of some fixed, countably infinite set const of constants. An instance D over S is a finite set of facts over S. The active domain adom(D) of D is the set of all constants that occur in the facts of D. We will frequently use boldface notation for tuples, such as in a = (a1, . . . , an), and we denote by () the empty tuple.\nA query over S is semantically defined as a mapping q that associates with every instance D over S a set of answers q(D) \u2286 adom(D)n, where n \u2265 0 is the arity of q. If n = 0, then we say that q is a Boolean query, and we write q(D) = 1 if () \u2208 q(D) and q(D) = 0 otherwise.\nA prominent way of specifying queries is by means of first-order logic (FO). Specifically, each schema S and domain-independent FO-formula \u03d5(x1, . . . , xn) that uses only relation names from S (and, possibly, equality) give rise to the n-ary query q\u03d5,S, defined by setting for all S-instances D,\nq\u03d5,S(D) = {(a1, . . . , an) \u2208 adom(D)n | D |= \u03d5[a1, . . . , an]}.\nTo simplify exposition, we assume that FO-queries do not contain constants. We use FOQ to denote the set of all first-order queries, as defined above. Similarly, we use CQ and UCQ to refer to the class of conjunctive queries and unions of conjunctive queries, defined\nas usual and allowing the use of equality. AQ denotes the set of atomic queries, which are of the formA(x) withA a unary relation symbol. Each of these is called a query language, which is defined abstractly as a set of queries. Besides FOQ, CQ, UCQ, and AQ, we consider various other query languages introduced later, including ontology-mediated ones and variants of datalog.\nTwo queries q1 and q2 over S are equivalent, written q1 \u2261 q2, if for every S-instance D, we have q1(D) = q2(D). We say that query language Q2 is at least as expressive as query language Q1, written Q1 Q2, if for every query q1 \u2208 Q1 over some schema S, there is a query q2 \u2208 Q2 over S with q1 \u2261 q2. Q1 andQ2 have the same expressive power ifQ1 Q2 Q1. Ontology-Mediated Queries. We introduce the fundamentals of ontology-based data access. An ontology language L is a fragment of first-order logic (i.e., a set of FO sentences), and an L-ontology O is a finite set of sentences from L. We introduce various ontology languages throughout the paper, including descriptions logics and the guarded fragment.\nAn ontology-mediated query over a schema S is a triple (S,O, q), where O is an ontology and q a query over S \u222a sig(O), with sig(O) the set of relation symbols used in O. Here, we call S the data schema. Note that the ontology can introduce symbols that are not in the data schema. As explained in the introduction, this allows the ontology to enrich the schema of the query q. Of course, we do not require that every relation of the data schema needs to occur in the ontology. We have explicitly included S in the specification of the ontology-mediated query to emphasize that the ontology-mediated query is interpreted as a query over S.\nThe semantics of an ontology-mediated query is given in terms of certain answers, defined next. A finite relational structure over a schema S is a pair B = (dom,D) where dom is a non-empty finite set called the domain of B and D is an instance over S with adom(D) \u2286 dom. When S is understood, we use Mod(O) to denote the set of all finite relational structures B over S \u222a sig(O) such that B |= O. Let (S,O, q) be an ontology-mediated query with q of arity n. The certain answers to q on an S-instance D given O is the set certq,O(D) of tuples a \u2208 adom(D)n such that for all (dom,D\u2032) \u2208 Mod(O) with D \u2286 D\u2032 (that is, all models of O that extend D), we have a \u2208 q(D\u2032).\nNote that all ontology languages considered in this paper enjoy finite controllability, meaning that finite relational structures can be replaced with unrestricted ones without changing the certain answers to unions of conjunctive queries [6, 7].\nEvery ontology-mediated query Q = (S,O, q) can be semantically interpreted as a query qQ over S by setting qQ(D) = certq,O(D) for all S-instances D. Taking this view one step further, each choice of an ontology language L and query languageQ gives rise to a query language, denoted (L,Q), defined as the set of queries q(S,O,q) with S a schema, O an L-ontology, and q \u2208 Q a query over S\u222a sig(O). We refer to such query languages (L,Q) as ontology-mediated query languages (or, OBDA languages).\nExample 1 The left-hand side of Table 1 shows an ontology O that is formulated in the guarded fragment of FO. Consider the ontology-mediated query (S,O, q) with data schema and query\nS = {ErythemaMigrans, LymeDisease, HereditaryPredisposition, finding, diagnosis, parent}\nq(x) = \u2203y( diagnosis(x, y) \u2227 BacterialInfection(y) ).\nFor the instance D over S that consists of the facts\nfinding(pat1, jan12find1) ErythemaMigrans(jan12find1)\ndiagnosis(pat2,may7diag2) Listeriosis(may7diag2)\nwe have certq,O(D) = {pat1, pat2}.\nDescription Logics for Specifying Ontologies. In description logic, schemas are generally restricted to relations of arity one and two, called concept names and role names, respectively. For brevity, we speak of binary schemas. We briefly review the basic description logic ALC. Relevant extensions of ALC will be introduced later on in the paper.\nAn ALC-concept is formed according to the syntax rule\nC,D ::= A | > | \u22a5 | \u00acC | C uD | C tD | \u2203R.C | \u2200R.C\nwhere A ranges over concept names and R over role names. An ALC-ontology O is a finite set of concept inclusions C v D, with C and D ALC-concepts. We define the semantics of ALCconcepts by translation to FO-formulas with one free variable, as shown in Table 2. An ALC-ontology O then translates into the set of FO-sentences O\u2217 = {\u2200x.(C\u2217(x) \u2192 D\u2217(x)) | C v D \u2208 O}. On the right-hand side of Table 1, we show theALC-version of the guarded fragment ontology displayed on the left-hand side. Note that, although the translation is equivalence-preserving in this case, in general, the guarded fragment is a more expressive ontology language than ALC. Throughout the paper, we do not explicitly distinguish between a DL ontology and its translation into FO.\nWe remark that, from a DL perspective, the above definitions of instances and certain answers correspond to making the standard name assumption (SNA) in ABoxes, which in particular implies the unique name assumption. We make the SNA only to facilitate uniform presentation; the SNA is inessential for the results presented in this paper.\nExample 2 Let O and S be as in Example 1. For q1(x) = BacterialInfection(x), the ontology-mediated query (S,O, q1) is equivalent to the union of conjunctive queries LymeDisease(x) \u2228 Listeriosis(x). For q2(x) = HereditaryDisposition(x), the ontology-mediated query (S,O, q2) is equivalent to the query defined by the datalog program\nP (x) \u2190 HereditaryDisposition(x) goal(x) \u2190 P (x) P (x) \u2190 parent(y, x) \u2227 P (y)\nbut not to any first-order query."}, {"heading": "3. OBDA AND DISJUNCTIVE DATALOG", "text": "We show that for many OBDA languages, there is a natural fragment of disjunctive datalog with exactly the same expressive power.\nA disjunctive datalog rule \u03c1 has the form\nS1(x1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 Sm(xm)\u2190 R1(y1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Rn(yn)\nwithm \u2265 0 and n > 0. We refer to S1(x1)\u2228\u00b7 \u00b7 \u00b7\u2228Sm(xm) as the head of \u03c1, and to R1(y1) \u2227 . . . \u2227 Rn(yn) as the body of \u03c1. Every variable that occurs in the head of a rule \u03c1 is required to also occur in the body of \u03c1. Empty rule heads are denoted \u22a5. A disjunctive datalog (DDlog) program \u03a0 is a finite set of disjunctive datalog rules with a selected goal predicate goal that does not occur in rule bodies and only in goal rules of the form goal(x) \u2190 R1(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 Rn(xn). The arity of \u03a0 is the arity of the goal relation. Relation symbols that occur in the head of at least one rule of \u03a0 are intensional (IDB) predicates of \u03a0, and all remaining relation symbols in \u03a0 are extensional (EDB) predicates.\nEvery DDlog program \u03a0 of arity n naturally defines an n-ary query q\u03a0 over the schema S that consists of the EDB predicates of \u03a0: for every instance D over S, we have\nq\u03a0(D) = {a \u2208 adom(D)n | goal(a) \u2208 D\u2032\nfor all D\u2032 \u2208 Mod(\u03a0) with D \u2286 D\u2032}.\nHere, Mod(\u03a0) denotes the set of all instances over S\u2032 that satisfy all rules in \u03a0, with S\u2032 the set of all IDB and EDB predicates in \u03a0. Note that the DDlog programs considered in this paper are negation-free. Restricted to this fragment, there is no difference between the different semantics of DDlog studied e.g. in [21].\nWe use adom(x) in rule bodies as a shorthand for \u201cx is in the active domain of the EDB predicates\u201d. Specifically, whenever we use adom in a rule of a DDlog program \u03a0, we assume that adom is an IDB predicate and that the program \u03a0 includes all rules of the form adom(x) \u2190 R(x) where R is an EDB predicate of \u03a0 and x is a tuple of distinct variables that includes x.\nA monadic disjunctive datalog (MDDlog) program is a DDlog program in which all IDB predicates with the possible exception of goal are monadic. We use MDDlog to denote the query language that consists of all queries defined by an MDDlog program."}, {"heading": "3.1 Ontologies Specified in Description Logics", "text": "We show that (ALC,UCQ) has the same expressive power as MDDlog and identify a fragment of MDDlog that has the same expressive power as (ALC,AQ). In addition, we consider the extensions of ALC with inverse roles, role hierarchies, transitive roles, and the universal role, which we also relate to MDDlog and its fragments. To match the syntax of ALC and its extensions, we generally assume schemas to be binary throughout this section.1\n(ALC,UCQ) and MDDlog. The first main result of this section is Theorem 1 below, which relates (ALC,UCQ) and MDDlog.\nTheorem 1 (ALC,UCQ) and MDDlog have the same expressive power.\n1In fact, this assumption is inessential for Theorems 1 and 3 (which speak about UCQs), but required for Theorems 2, 4, and 5 (which speak about AQs) to hold.\nProof. (sketch) We start with giving some intuitions about answering (ALC,UCQ) queries which guide our translation of such queries into MDDlog programs. Recall that the definition of certain answers to an ontology-mediated query on an instance D involves a quantification over all models of O which extend D. It turns out that in the case of (ALC,UCQ) queries (and, as we will see later, more generally for (UNFO,UCQ) queries), it suffices to consider a particular type of extensions of D that we term pointwise extensions. Intuitively, such an extension of D corresponds to attaching domain-disjoint structures to the elements of D. Formally, for instances D \u2286 D\u2032, we call D\u2032 a pointwise extension of D if D\u2032 \\ D is the union of instances {D\u2032a | a \u2208 adom(D)} such that adom(D\u2032a) \u2229 adom(D) \u2286 {a} and adom(D\u2032a) \u2229 adom(D\u2032b) = \u2205 for a 6= b. The fact that we need only consider models of O which are pointwise extensions of D is helpful because it constrains the ways in which a CQ can be satisfied. Specifically, every homomorphism h from q to D\u2032 gives rise to a query q\u2032 obtained from q by identifying all variables that h sends to the same element, and to a decomposition of q\u2032 into a collection of components q\u20320, . . . , q\u2032k where the \u2018core component\u2019 q\u20320 comprises all atoms of q\u2032 whose variables h sends to elements of D and for each D\u2032a in the image of h, there is a \u2018non-core component\u2019 q\u2032i, 1 \u2264 i \u2264 k, such that q\u2032i comprises all atoms of q\u2032 whose variables h sends to elements of D\u2032a. Note that the non-core components are pairwise variable-disjoint and share at most one variable with the core component.\nWe now detail the translation from an ontology-mediated query (S,O, q) \u2208 (ALC,UCQ) into an equivalent MDDlog program. Let sub(O) be the set of subconcepts (that is, syntactic subexpressions) of concepts that occur in O, and let cl(O, q) denote the union of sub(O) and the set of all CQs that have at most one free variable, use only symbols from q, and whose number of atoms is bounded by the number of atoms of q. A type (for O and q) is a subset of cl(O, q). The CQs present in cl(O, q) include all potential \u2018noncore components\u2019 from the intuitive explanation above. The free variable of a CQ in cl(O, q) (if any) represents the overlap between the core component and the non-core component.\nWe introduce a fresh unary relation symbol P\u03c4 for every type \u03c4 , and we denote by S\u2032 the schema that extends S with these additional symbols. In the MDDlog program that we aim to construct, the relation symbols P\u03c4 will be used as IDB relations, and the symbols from S will be the EBD relations.\nWe will say that a relational structure B over S\u2032 \u222a sig(O) is type-coherent if P\u03c4 (d) \u2208 B just in the case that\n\u03c4 = {q\u2032 \u2208 cl(O, q) | q\u2032 Boolean ,B |= q\u2032} \u222a {C \u2208 cl(O, q) | C unary,B |= C[d]}.\nSet k equal to the maximum of 2 and the width of q, that is, the number of variables that occur in q. By a diagram, we mean a conjunction \u03b4(x1, . . . , xn) of atomic formulas over the schema S\u2032, with n \u2264 k variables. A diagram \u03b4(x) is realizable if there exists a type-coherent B \u2208 Mod(O) that satisfies \u2203x\u03b4(x). A diagram \u03b4(x) implies q(x\u2032), with x\u2032 a sequence of variables from x, if every type-coherent B \u2208 Mod(O) that satisfies \u03b4(x) under some variable assignment, satisfies q(x\u2032) under the same assignment.\nThe desired MDDlog program \u03a0 consists of the following collections of rules:\u2228\n\u03c4\u2286cl(O,q) P\u03c4 (x)\u2190 adom(x) \u22a5 \u2190 \u03b4(x) for all non-realizable diagrams \u03b4(x)\ngoal(x\u2032)\u2190 \u03b4(x) for all diagrams \u03b4(x) that imply q(x\u2032)\nIntuitively, these rules \u2018guess\u2019 a pointwise extension D\u2032 of D. Specifically, the types P\u03c4 guessed in the first line determine which\nsubconcepts of O are made true at each element of D\u2032. Since MDDlog does not support existential quantifiers, the D\u2032a parts of D\u2032 cannot be guessed explicitly. Instead, the CQs included in the guessed types determine those non-core component queries that matched in the D\u2032a parts. The second line ensures coherence of the guesses and the last line guarantees that q has the required match in D\u2032. It is proved in the full version of this paper that the MDDlog query q\u03a0 is indeed equivalent to (S,O, q).\nFor the converse direction, let \u03a0 be an MDDlog program. For each unary IDB relation A of \u03a0, we introduce two fresh unary relations, denoted by A and A\u0304. The ontology O enforces that A\u0304 represents the complement of A, that is, it consists of all inclusions of the form\n> v (A t A\u0304) u \u00ac(A u A\u0304). Let q be the union of (i) all conjunctive queries that constitute the body of a goal rule, as well as (ii) all conjunctive queries obtained from a non-goal rule of the form\nA1(x1) \u2228 \u00b7 \u00b7 \u00b7 \u2228Am(xm)\u2190 R1(y1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Rn(yn)\nby taking the conjunctive query\nA\u03041(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 A\u0304m(xm) \u2227R1(y1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Rn(yn).\nIt can be shown that the ontology-mediated query (S,O, q), where S is the schema that consists of the EDB relations of \u03a0, is equivalent to the query defined by \u03a0. o\nALC with Atomic Queries. We characterize (ALC,AQ) by a fragment of MDDlog. This query language has the same expressive power as the OBDA language (ALC,ConQ), where ConQ denotes the set of all ALC-concept queries, that is, queries C(x) with C a (possibly compound) ALC-concept. Specifically, each query (S,O, q) \u2208 (ALC,ConQ) with q = C(x) can be expressed as a query (S,O\u2032, A(x)) \u2208 (ALC,AQ) where A is a fresh concept name (that is, it does not occur in S \u222a sig(O)) and O\u2032 = O \u222a {C v A}. As a consequence, (ALC,AQ) also has the same expressive power as (ALC,TCQ), where TCQ is the set of all CQs that take the form of a directed tree with a single answer variable at the root.\nEach disjunctive datalog rule can be associated with an undirected graph whose nodes are the variables that occur in the rule and whose edges reflect co-occurrence of two variables in an atom in the rule body. We say that a rule is connected if its graph is connected, and that a DDlog program is connected if all its rules are connected. An MDDlog program is simple if each rule contains at most one atom R(x) with R an EDB relation; additionally, we require that, in this atom, every variable occurs at most once.\nTheorem 2 (ALC,AQ) has the same expressive power as unary connected simple MDDlog.\nProof. (sketch) The translation from (ALC,AQ) to unary connected simple MDDlog queries is a modified version of the translation given in the proof of Theorem 1. Assume that (S,O, q) with q = A(x) is given. We now take types to be subsets of sub(O) and then define diagrams exactly as before (with k = 2). The MDDlog program \u03a0 consists of the following rules:\u2228\n\u03c4\u2286sub(O) P\u03c4 (x)\u2190 adom(x) \u22a5 \u2190 \u03b4(x) for all non-realizable diagrams \u03b4(x)\nof the form P\u03c41(x) \u2227 P\u03c42(x), P\u03c4 (x) \u2227A(x), or P\u03c41(x1) \u2227 S(x1, x2) \u2227 P\u03c42(x2)\ngoal(x)\u2190 P\u03c4 (x) for all P\u03c4 with A \u2208 P\u03c4\nClearly, \u03a0 is unary, connected, and simple. Equivalence of the queries (S,O, q) and q\u03a0 is proved in the full version of this paper.\nConversely, let \u03a0 be a unary connected simple MDDlog program. It is easy to rewrite each rule of \u03a0 into an equivalent ALCconcept inclusion, where goal is now regarded as a concept name. For example, goal(x) \u2190 R(x, y) is rewritten into \u2203R.> v goal and P1(x) \u2228 P2(y) \u2190 R(x, y) \u2227 A(x) \u2227 B(y) is rewritten into A u \u2203R.(B u \u00acP2) v P1. Let O be the resulting ontology and let q = goal(x). Then the query q\u03a0 is equivalent to the query (S,O, q), where S consists of the EDB relations in \u03a0. o\nNote that the connectedness condition is required since one cannot express MDDlog rules such as goal(x) \u2190 adom(x) \u2227 A(y) with y 6= x in (ALC,AQ). Multiple variable occurrences in EDB relations have to be excluded because programs such as goal(x) \u2190 A(x), \u22a5 \u2190 R(x, x) (return all elements in A if the instance contains no reflexive R-edge, and return the active domain otherwise) also cannot be expressed in (ALC,AQ). Extensions of ALC. We identify several standard extensions of (ALC,UCQ) and (ALC,AQ) that have the same expressive power, and some that do not. We introduce the relevant extensions only briefly and refer to [4] for more details. ALCI is the extension ofALC in which one can state that a role name R is the inverse of a role name S, that is, \u2200xy(R(x, y) \u2194 S(y, x)); ALCH is the extension in which one can state that a role name R is included in a role name S, that is, \u2200xy(R(x, y)\u2192 S(x, y)); S is the extension ofALC in which one can require some roles names to be interpreted as transitive relations; ALCF is the extension in which one can state that some role names are interpreted as partial functions; and ALCU is the extension with the universal role U , interpreted as dom\u00d7dom in any relational structure B with domain dom. Note that U should be regarded as a logical symbol and is not a member of any schema. All these means of expressivity are included in the OWL2 DL profile of the W3Cstandardized ontology language OWL2 [47].\nWe use the usual naming scheme to denote combinations of these extensions, for example ALCHI for the union of ALCH andALCI and SHI for the union of S andALCHI. The following result summarizes the expressive power of extensions of ALC.\nTheorem 3 1. (ALCHIU ,UCQ) has the same expressive power as MDDlog\nand as (ALC,UCQ). 2. (S,UCQ) and (ALCF ,UCQ) are strictly more expressive than\n(ALC,UCQ).\nProof. (sketch) In Point 1, we start with (ALCIU ,UCQ), for which the result follows from Theorem 6 in Section 3.2 since ALCIU is a fragment of UNFO. Role inclusions \u2200xy(R(x, y) \u2192 S(x, y)) do not add expressive power since they can be simulated by adding to the ontology the inclusions \u2203R.C v \u2203S.C for all C \u2208 sub(O), and replacing every atom S(x, y) in the UCQ byR(x, y)\u2228S(x, y).\nFor Point 2, we separate (S,UCQ) from (ALC,UCQ) by showing that the following ontology-mediated query (S1,O1, q1) cannot be expressed in (ALC,UCQ): S1 consists of two role names R and S, O1 states that these role names are both transitive, and q1 = \u2203xy(R(x, y) \u2227 S(x, y)). For (ALCF ,UCQ), we show that (S2,O2, q2) cannot be expressed in (ALC,UCQ), where S2 consists of role name R and concept name A,O2 states that R is functional, and q2 = A(x). Detailed proofs are provided in the full version of this paper. They rely on a characterization of (ALC,UCQ) in terms of colored forbidden patterns [38], which is a by-product\nof the connection between (ALC,UCQ) and MMSNP that will be established in Section 4. o\nThe next result is interesting when contrasted with Point 2 of Theorem 3: when (ALC,UCQ) is replaced with (ALC,AQ), then the addition of transitive roles no longer increases the expressive power.\nTheorem 4 (ALC,AQ) has the same expressive power as (SHI,AQ).\nProof. (sketch) The proof of Theorem 2 given above actually shows that unary connected simple MDDlog is at least as expressive as (ALCI,AQ). Thus, (ALC,AQ) has the same expressive power as (ALCI,AQ). Now it is folklore that in ALCI transitive roles can be replaced by certain concept inclusions without changing the certain answers to atomic queries. This can be done similarly to the elimination of role inclusions in the proof above, see [39, 45]. Thus (ALCI,AQ) has the same expressive power as (SHI,AQ), and the result follows. o\nIt follows from [45] that this observation can be extended to all complex role inclusions that are admitted in the description logic SROIQ. In contrast, the addition of the universal role on the side of the OBDA query language extends the expressive power of (ALC,AQ). Namely, it corresponds, on the MDDlog side, to dropping the requirement that rule bodies must be connected. For example, the MDDlog query goal(x)\u2190 adom(x)\u2227A(y) can then be expressed using the ontology O = {\u2203U.A v goal} and the AQ goal(x).\nTheorem 5 (ALCU ,AQ) and (SHIU ,AQ) both have the same expressive power as unary simple MDDlog.\nWe close this section with a brief remark about Boolean atomic queries (BAQs), that is, queries of the form \u2203x.A(x), where A is a unary relation symbol. Such queries will be considered in Section 5. It is possible to establish modified versions of Theorems 2 to Theorem 5 above in which AQs are replaced by BAQs and unary goal predicates by 0-ary goal-predicate, respectively."}, {"heading": "3.2 Ontologies Specified in First-Order Logic", "text": "Ontologies formulated in description logic are not able to speak about relation symbols of arity greater than two.2 To overcome this restriction, we consider the guarded fragment of first-order logic and the unary-negation fragment of first-order logic [6, 46]. Both generalize the description logic ALC in different ways. We also consider their natural common generalization, the guarded negation fragment of first-order logic [7]. Our results from the previous subsection turn out to generalize to all these fragments. We start by considering the unary negation fragment.\nThe unary-negation fragment of first-order logic (UNFO) [46] is the fragment of first-order logic that consists of those formulas that are generated from atomic formulas, including equality, using conjunction, disjunction, existential quantification, and unary negation, that is, negation applied to a formula with at most one free variable. Thus, for example, \u00ac\u2203xyR(x, y) belongs to UNFO, whereas \u2203xy\u00acR(x, y) does not. It is easy to show that everyALCTBox is equivalent to a UNFO sentence.\n2There are actually a few DLs that can handle relations of unrestricted arity, such as those presented in [19]. We do not consider such DLs in this paper, but remark that large fragments of them can be translated into UNFO.\nTheorem 6 (UNFO,UCQ) has the same expressive power as MDDlog.\nProof. (sketch) The translation from MDDlog to (UNFO,UCQ) is given by Theorem 1. Here, we provide the translation from (UNFO,UCQ) to MDDlog. Let Q = (S,O, q) \u2208 (UNFO,UCQ) be given. We assume that O is a single UNFO sentence that is in the normal form generated by the following grammar:\n\u03d5(x) ::= > | \u00ac\u03d5(x) | \u2203y(\u03c81(x, y) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c8n(x, y))\nwhere each \u03c8i is either a relational atom or a formula with at most one free variable generated by the same grammar, and the free variables in \u03c8i are among x,y. Note that no equality is used and that all generated formulas have at most one free variable. Easy syntactic manipulations show that every UNFO-formula with at most one free variable is equivalent to a disjunction of formulas generated by the above grammar. In the case of O, we may furthermore assume that it is a single such sentence, rather than a disjunction, because certq,O1\u2228O2(D) is the intersection of certq,O1(D) and certq,O2(D), and MDDlog is closed under taking intersections of queries.\nLet sub(O) be the set of all subformulas of O with at most one free variable z (we apply a one-to-one renaming of variables as needed to ensure that each formula in sub(O) with a free variable has the same free variable z). Let k be the maximum of the number of variables in O and the number of variables in q. We denote by clk(O) the set of all formulas \u03d5(x) of the form\n\u2203y(\u03c81(x, y) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c8n(x, y))\nwith y = (y1, . . . , ym),m \u2264 k, where each \u03c8i is either a relational atom that uses a symbol from q or is of the form \u03c7(x) or \u03c7(yi), for \u03c7(z) \u2208 sub(O). Note that, as in the proof of Theorem 1, clk(O) contains all CQs that use only symbols from q and whose size is bounded by the size of q. A type \u03c4 is a subset of clk(O); the set of all types is denoted type(O).\nWe introduce a fresh unary relation symbol P\u03c4 for each type \u03c4 , and we denote by S\u2032 the schema that extends S with these additional relations. As before, we call a structure B over S\u2032 \u222a sig(O) type-coherent if for all types \u03c4 and elements d in the domain of B, we have P\u03c4 (d) \u2208 B just in the case that \u03c4 is the (unique) type realized at d in B. Diagrams, realizability, and \u201cimplying q\u201d are defined as in the proof of Theorem 1. It follows from [46] that it is decidable whether a diagram implies a query, and whether a diagram is realizable. The MDDlog program \u03a0 is defined as in the proof of Theorem 1, except that now in the first rule, \u03c4 ranges over types in type(O). In the full version of this paper, we prove that the resulting MDDlog query q\u03a0 is equivalent to Q. o\nNext, we consider the guarded fragment of first-order logic (GF). It comprises all formulas built up from atomic formulas using the Boolean connectives and guarded quantification of the form \u2203x(\u03b1\u2227\u03d5) and \u2200x(\u03b1\u2192 \u03d5), where, in both cases, \u03b1 is an atomic formula (a \u201cguard\u201d) that contains all free variables of \u03d5. To simplify the presentation of the results, we consider here the equality-free version of the guarded fragment. We do allow one special case of equality, namely the use of trivial equalities of the form x = x as guards, which is equivalent to allowing unguarded quantifiers applied to formulas with at most one free variable. This restricted form of equality is sufficient to translate every ALC TBox into an equivalent sentence of GF.\nIt turns out that the OBDA language (GF, UCQ) is strictly more expressive than MDDlog.\nProposition 1 The Boolean query\n(\u2020) there are a1, . . . , an, b, for some n \u2265 2, such that A(a1), B(an), and P (ai, b, ai+1) for all 1 \u2264 i < n\nis definable in (GF,UCQ) and not in MDDlog.\nProof. Let S consist of unary predicates A,B and a ternary predicate P , and let Q be the S-query defined by (\u2020). It is easy to check thatQ can be expressed by the (GF,UCQ) query qS,O,\u2203xU(x) where\nO = \u2200xyz (P (x, z, y)\u2192 (A(x)\u2192 R(z, x))) \u2227 \u2200xyz (P (x, z, y)\u2192 (R(z, x)\u2192 R(z, y))) \u2227 \u2200xyz (R(x, y)\u2192 (B(y)\u2192 U(y)))\nWe show in the full version of this paper that Q is not expressible in MDDlog using the colored forbidden patterns characterization mentioned in the proof sketch of Theorem 3. o\nAs fragments of first-order logic, the unary-negation fragment and the guarded fragment are incomparable in expressive power. They have a common generalization, which is known as the guarded-negation fragment (GNFO) [8]. This fragment is defined in the same way as UNFO, except that, besides unary negation, we allow guarded negation of the form \u03b1 \u2227 \u00ac\u03d5, where the guard \u03b1 is an atomic formula that contains all the variables of \u03d5. Again, for simplicity, we consider here the equality-free version of the language, except that we allow the use of trivial equalities of the form x = x as guards. As we will see, for the purpose of OBDA, GNFO is no more powerful than GF. Specifically, (GF, UCQ) and (GNFO, UCQ) are expressively equivalent to a natural generalization of MDDlog, namely frontier-guarded DDlog. Recall that a datalog rule is guarded if its body includes an atom that contains all variables which occur in the rule [27]. A weaker notion of guardedness, which we call here frontier-guardedness, inspired by [5, 7], requires that, for each atom \u03b1 in the head of the rule, there is an atom \u03b2 in the rule body such that all variables that occur in \u03b1 occur also in \u03b2. We define a frontier-guarded DDlog query to be a query defined by a DDlog program in which every rule is frontierguarded. Observe that frontier-guarded DDlog subsumes MDDlog.\nTheorem 7 (GF,UCQ) and (GNFO,UCQ) have the same expressive power as frontier-guarded DDlog.\nTheorem 7 is proved in the full version of this paper via translations from (GNFO,UCQ) to frontier-guarded DDlog and back that are along the same lines as the translations from (UNFO,UCQ) to MDDlog and back. In addition, we use a result from [8] to obtain a translation from (GNFO,UCQ) to (GF,UCQ)."}, {"heading": "4. OBDA AND MMSNP", "text": "We show that MDDlog captures coMMSNP and thus, by the results obtained in the previous section, the same is true for many OBDA languages based on UCQs. We then use this connection to transfer results from MMSNP to OBDA languages with UCQs, linking the data complexity of these languages to the Feder-Vardi conjecture and establishing decidability of query containment. We also propose GMSNP, an extension of MMSNP inspired by frontier guarded DDlog, and show that (GF,UCQ) and (GNFO,UCQ) capture coGMSNP, and that GMSNP has the same expressive power as a previously proposed extension of MMSNP called MMSNP2.\nAn MMSNP formula over schema S has the form \u2203X1 \u00b7 \u00b7 \u00b7 \u2203Xn\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5 with X1, . . . , Xn monadic secondorder (SO) variables, x1, . . . , xm FO-variables, and \u03d5 a conjunction of quantifier-free formulas of the form\n\u03c8 = \u03b11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1n \u2192 \u03b21 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03b2m with n,m \u2265 0,\nwhere each \u03b1i is of the formXi(x),R(x) (withR \u2208 S), or x = y, and each \u03b2i is of the form Xi(x). In order to use MMSNP as a query language, and in contrast to the standard definition, we admit free FO-variables and speak of sentences to refer to MMSNP formulas without free variables. To connect with the query languages studied thus far, we are interested in queries obtained by the complements of MMSNP formulas: each MMSNP formula \u03a6 over schema S with n free variables gives rise to a query\nq\u03a6,S(D) = {a \u2208 adom(D)n | (adom(D),D) 6|= \u03a6[a]}\nwhere we set (adom(D),D) |= \u03a6 to true when D is the empty instance (that is, adom(D) = \u2205) and \u03a6 is a sentence. We observe that the resulting query language coMMSNP has the same expressive power as MDDlog.\nProposition 2 coMMSNP and MDDlog have the same expressive power.\nProof. Let \u03a6 = \u2203X1 \u00b7 \u00b7 \u00b7 \u2203Xn\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5 be an MMSNP formula with free variables y1, . . . , yk, and let q\u03a6,S \u2208 coMMSNP be the corresponding query. We can assume w.l.o.g. that all implications \u03c8 = \u03b11\u2227\u00b7 \u00b7 \u00b7\u2227\u03b1n \u2192 \u03b21\u2228\u00b7 \u00b7 \u00b7\u2228\u03b2m in \u03d5 satisfy the following properties: (i) n > 0 and, (ii) each variable that occurs in a \u03b2i atom also occurs in an \u03b1i atom. In fact, we can achieve both (i) and (ii) by replacing violating implications \u03c8 with the set of implications \u03c8\u2032 that can be obtained from \u03c8 by adding, for each variable x that occurs only in the head of \u03c8, an atom S(x) where S is a predicate that occurs in \u03a6 and x is a tuple of variables that contains x once and otherwise only fresh variables that do not occur in \u03a6. Define an MDDlog program \u03a0\u03a6 that consists of all implications in \u03d5 whose head is not \u22a5 plus a rule\ngoal(y1, . . . , yk)\u2190 \u03d1 \u2227 adom(y1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 adom(yk)\nfor each implication \u03d1 \u2192 \u22a5 in \u03d5. It can be proved that q\u03a6,S = q\u03a0\u03a6,S for all schemas S. Finally, it is straightforward to remove the equalities from the rule bodies in \u03a0\u03a6.\nConversely, let \u03a0 be a k-ary MDDlog program and assume w.l.o.g. that each rule uses a disjoint set of variables. Reserve fresh variables y1, . . . , yk as free variables for the desired MMSNP formula, and let X1, . . . , Xn be the IDB predicates in \u03a0 and x1, . . . , xm the FO-variables in \u03a0 that do not occur in the goal predicate. Set \u03a6\u03a0 = \u2203X1 \u00b7 \u00b7 \u00b7 \u2203Xn\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5 where \u03d5 is the conjunction of all non-goal rules in \u03a0 plus the implication \u03d1\u2032 \u2192 \u22a5 for each rule goal(x) \u2190 \u03d1 in \u03a0. Here, \u03d1\u2032 is obtained from \u03d1 by replacing each variable x \u2208 x whose left-most occurrence in the rule head is in the i-th position with yi, and then conjunctively adding yi = yj whenever the i-th and j-th position in the rule head have the same variable. It can be proved that q\u03a0,S = q\u03a6\u03a0,S for all schemas S. o\nThus, the characterizations of OBDA languages in terms of MDDlog provided in Section 3 also establish the descriptive complexity of these languages by identifying them with (the complement of) MMSNP. Furthermore, Proposition 2 allow us to transfer results from MMSNP to OBDA. We start by considering the data complexity of the query evaluation problem: for a query q, the evaluation problem is to decide, given an instance D and a tuple a of elements from D, whether a \u2208 q(D). Our first result is that the Feder-Vardi dichotomy conjecture for CSPs is true if and only if there is a dichotomy between PTIME and CONP for query evaluation in (ALC,UCQ), and the same is true for several other OBDA languages. For brevity, we say that a query language has a dichotomy between PTIME and CONP, referring only implicitly to the evaluation problem.\nThe proof of the following theorem relies on Proposition 2 and Theorems 1, 3, and 6. It also exploits the fact that the Feder-Vardi dichotomy conjecture can equivalently be stated for MMSNP sentences [24, 33]. Some technical development is needed to deal with the presence of free variables. Details are in the full version of this paper.\nTheorem 8 (ALC,UCQ) has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. The same is true for (ALCHIU ,UCQ) and (UNFO,UCQ).\nRecall that (ALCF ,UCQ) and (S,UCQ) are two extensions of (ALC,UCQ) that were identified in Section 3 to be more expressive than (ALC,UCQ) itself. It was already proved in [36] (Theorem 27) that, compared to ontology-mediated queries based on ALC, the functional roles of ALCF dramatically increase the computational power. This is true even for atomic queries.\nTheorem 9 ([36]) For every NP-Turing machine M , there is a query q in (ALCF ,AQ) such that the complement of the word problem of M has the same complexity as evaluating q, up to polynomial-time reductions. Consequently, (ALCF ,AQ) does not have a dichotomy between PTIME and CONP (unless PTIME = NP).\nWe leave it as an open problem to analyze the computational power of (S,UCQ).\nThere are other interesting results that can be transferred from MMSNP to OBDA. Here, we consider query containment. Specifically, the following general containment problem was proposed in [10] as a powerful tool for OBDA: given ontology-mediated queries (S,Oi, qi), i \u2208 {1, 2}, decide whether for all S-instances D, we have certq1,O1(D) \u2286 certq2,O2(D).3 Applications include the optimization of ontology-mediated queries and managing the effects on query answering of replacing an ontology with a new, updated version. In terms of OBDA languages such as (ALC,UCQ), the above problem corresponds to query containment in the standard sense: an S-query q1 is contained in an S-query q2, written q1 \u2286 q2, if for every S-instance D, we have q1(D) \u2286 q2(D). Note that there are also less general (and computationally simpler) notions of query containment in OBDA that do not fix the data schema [19].\nIt was proved in [24] that containment of MMSNP sentences is decidable. We thus obtain the following result for OBDA languages.\nTheorem 10 Query containment is decidable for the OBDA languages (ALC,UCQ), (ALCHIU ,UCQ), and (UNFO,UCQ).\nNote that this result is considerably stronger than those in [10], which considered only containment of ontology-mediated queries (S,O, q) with q an atomic query since already this basic case turned out to be technically intricate. The treatment of CQs and UCQs was left open, including all cases stated in Theorem 10.\nWe now consider OBDA languages based on the guarded fragment and GNFO. By Proposition 1, (GF,UCQ) and (GNFO,UCQ) are strictly more expressive than MDDlog and we cannot use Proposition 2 to relate these query languages to the Feder-Vardi conjecture. Theorem 7 suggests that it would be useful to have 3In fact, this definition is slightly different from the one used in [10]. There, containment is defined only over instances D that are consistent w.r.t. O1 and O2, i.e., where there is at least one finite S-structure (dom,D\u2032) such that D \u2286 D\u2032 and D\u2032 \u2208 Mod(Oi).\na generalization of MMSNP that is equivalent to frontier-guarded DDlog. Such a generalization is introduced next.\nA formula of guarded monotone strict NP (abbreviated GMSNP) has the form \u2203X1 \u00b7 \u00b7 \u00b7 \u2203Xn\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5 with X1, . . . , Xn SO variables of any arity, x1, . . . , xn FO-variables, and \u03d5 a conjunction of formulas\n\u03c8 = \u03b11 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03b1n \u2192 \u03b21 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03b2m with n,m \u2265 0,\nwhere each \u03b1i is of the form Xi(x), R(x) (with R \u2208 S), or x = y, and each \u03b2i is of the form Xi(x). Additionally, we require that for every head atom \u03b2i, there is a body atom \u03b1j such that \u03b1j contains all variables from \u03b2i. GMSNP gives rise to a query language coGMSNP in analogy with the definition of coMMSNP. It can be shown by a straightforward syntactic transformation that every MMSNP formula is equivalent to some GMSNP formula. Together with Proposition 1 and Theorem 7, this yields the second statement of the following lemma; the first statement can be proved similarly to Proposition 2.\nTheorem 11 coGMSNP has the same expressive power as frontier-guarded DDlog and is strictly more expressive than coMMSNP.\nAlthough defined in a different way, GMSNP is essentially the same logic as MMSNP2, which is studied in [37]. Specifically, MMSNP2 is the extension of MMSNP in which monadic SOvariables range over sets of domain elements and facts, and where atoms of the form X(R(x)) are allowed in place of atoms X(x) with X an SO-variable and R from the data schema S. Additionally, a guardedness condition is imposed, requiring that whenever an atom X(R(x)) occurs in a rule head, then the atom R(x) must occur in the rule body. Formally, the SO-variables Xi are interpreted in an instance D as sets \u03c0(Xi) \u2286 adom(D) \u222a D and D |=\u03c0 X(R(x1, . . . , xn)) if R(\u03c0(x1), . . . , \u03c0(xn)) \u2208 \u03c0(X). We observe the following.\nProposition 3 GMSNP and MMSNP2 have the same expressive power.\nDetails for the proofs of both Theorem 11 and Lemma 3 are in the full version of this paper. In [37], it was left as an open question whether MMSNP2 is more expressive than MMSNP, which is resolved by the results above.\nWe leave it as an interesting open question whether Theorem 8 can be extended to (GF,UCQ) and (GNFO,UCQ), that is, whether GMSNP (equivalently: MMSNP2) has a dichotomy between PTIME and NP if the Feder-Vardi conjecture holds. While this question is implicit already in [37], the results established in this paper underline its significance from a different perspective."}, {"heading": "5. OBDA AND CSP", "text": "We show that OBDA languages based on AQs capture CSPs (and generalizations thereof), and we transfer results from CSPs to OBDA languages. In comparison to the previous section, we obtain a richer set of results, and often even worst-case optimal decision procedures. Recall that each finite relational structure B over a schema S gives rise to a constraint satisfaction problem which is to decide, given a finite relational structure A over S, whether there is a homomorphism from A to B (written A \u2192 B). In this context, the relational structure B is also called the template of the CSP.\nCSPs give rise to a query language coCSP in the spirit of the query language coMMSNP introduced in the previous section. In\nits basic version, this language is Boolean and turns out to have exactly the same expressive power as (ALC,BAQ), where BAQ is the class of Boolean atomic queries. To also cover non-Boolean AQs, we consider two natural generalizations of CSPs. First, a generalized CSP is defined by a finite set F of templates, rather than only a single one [25]. The problem then consists in deciding, given an input structure A, whether there is a template B \u2208 F such that A \u2192 B. Second, in a (generalized) CSP with constant symbols, both the template(s) and the input structure are endowed with constant symbols [23, 1]. To be more precise, let S be a schema and c = c1, . . . , cm a finite sequence of distinct constant symbols. A finite relational structure over S \u222a c has the form (A, d1, . . . , dm) with A a finite relational structure over A that, in addition, interprets the constant symbols ci by elements di of the domain dom of A, for 1 \u2264 i \u2264 m. Let (A,a) and (B,b) be finite relational structures over S \u222a c. A mapping h is a homomorphism from (A,a) to (B,b), written (A,a)\u2192 (B,b), if it is a homomorphism from A to B and h(ai) = bi for 1 \u2264 i \u2264 m. A (generalized) CSP with constant symbols is then defined like a (generalized) CSP, based on this extended notion of homomorphism.\nWe now introduce the query languages obtained from the different versions of CSPs, where generalized CSPs with constant symbols constitute the most general case. Specifically, each finite set of templates F over S\u222ac with c = c1, . . . , cm gives rise to anm-ary query coCSP(F) that maps every S-instance D to\n{d \u2208 adom(D)m |\u2200(B,b)\u2208 F : (D,d) 6\u2192 (B,b)},\nwhere we view (D,d) as a finite relational structure whose domain is adom(D). The query language that consists of all such queries is called generalized coCSP with constant symbols. The fragment of this query language that is obtained by admitting only sets of templates F without constant symbols is called generalized coCSP, and the fragment induced by singleton sets F without constant symbols is called coCSP.\nExample 3 Selecting an illustrative fragment of Examples 1 and 2, let\nO = {\u2203parent.HereditaryDisposition v HereditaryDisposition} S = {HereditaryDisposition, parent}\nMoreover, let q2(x) = HereditaryDisposition(x) be the query from Example 2. To identify a query in coCSP with constant symbols that is equivalent to the ontology-mediated query (S,O, q2), let B be the following template:\nparent a b\nHereditaryDisposition\nparent parent\nIt can be shown that for all instances D over S and for all d \u2208 adom(D), we have d \u2208 certq2,O(D) iff (D, d) 6\u2192 (B, a) and thus the query coCSP(B) is as required.\nThe following theorem summarizes the connections between OBDA languages with (Boolean) atomic queries, MDDlog, and CSPs. Note that we consider binary schemas only.\nTheorem 12 The following are lists of query languages that have the same expressive power:\n1. (ALCU ,AQ), (SHIU ,AQ), unary simple MDDlog, and generalized coCSP with one constant symbol;\n2. (ALC,AQ), (SHI,AQ), unary connected simple MDDlog, and generalized coCSPs with one constant symbol such that all templates are identical except for the interpretation of the constant symbol;\n3. (ALCU ,BAQ), (SHIU ,BAQ), Boolean simple MDDlog, and generalized coCSP;\n4. (ALC,BAQ), (SHI,BAQ), Boolean connected simple MDDlog, and coCSP.\nMoreover, given the ontology-mediated query or monadic datalog program, the correponding CSP template is of at most exponential size and can be constructed in time polynomial in the size of the template.\nProof. The equivalences between OBDA languages and fragments of MDDlog have been proved in Section 3. We give a proof of the remaining claim of Point 1, namely that (ALCU ,AQ) and generalized coCSP with one constant symbol are equally expressive. We extend the notation used in the proof of Theorem 1. For simplicity, throughout this proof we regard \u2200R.C as an abbreviation for \u00ac\u2203R.\u00acC.\nLet Q = (S,O, A(x)) be an ontology-mediated query formulated in (ALCU ,AQ). A type forO is a set \u03c4 \u2286 sub(O) and tp(O) denotes the set of all types for O. We say that \u03c4 \u2208 tp(O) is realizable if there is an A = (dom,D) \u2208 Mod(O) and a d \u2208 dom such that C \u2208 \u03c4 iff A |= C\u2217[d] for all C \u2208 sub(O). A set of types T \u2286 tp(O) is realizable in a Q-countermodel if there is an A \u2208 Mod(O) that realizes exactly the types in T and such that A 6\u2208 \u03c4 for at least one \u03c4 \u2208 T .\nLet C be the set of all T \u2286 tp(O) that are realizable in a Qcountermodel and maximal with this property. Note that the number of elements of C is bounded by the size of O since for any two distinct T1, T2 \u2208 C, there must be a concept \u2203U.D \u2208 sub(O) such that \u2203U.D \u2208 \u03c4 for all \u03c4 \u2208 T1 and \u2203U.D 6\u2208 \u03c4 for all \u03c4 \u2208 T2 or vice versa; otherwise, we can take the disjoint union of any structures A1,A2 which show that T1, T2 are realizable in a Q-countermodel to obtain Q-countermodel that realizes T1 \u222a T2. For R \u2208 S, we call a pair (\u03c41, \u03c42) of types R-coherent if \u2203R.C \u2208 \u03c41 for every \u2203R.C \u2208 sub(O) such that C \u2208 \u03c42.\nWith each T \u2208 C, we associate the canonical S-structure BT with domain T and the following facts:\n\u2022 B(\u03c4) for all \u03c4 \u2208 T and B \u2208 S such that B \u2208 \u03c4 ;\n\u2022 R(\u03c41, \u03c42) for all \u03c41, \u03c42 \u2208 T and R \u2208 S such that (\u03c41, \u03c42) is R-coherent.\nNote that the construction of BT is well-known from the literature on modal and description logic. For example, BT can be viewed as a finite fragment of a canonical model of a modal logic that is constructed from maximal consistent sets of formulas [11]. Alternatively, BT can be viewed as the result of a type elimination procedure [41].\nWe obtain the desired set F of CSP templates by setting\nF = {(BT , \u03c4) | T \u2208 C, \u03c4 \u2208 T,A 6\u2208 \u03c4}.\nOne can show that for every S-instance D and d \u2208 adom(D), there exists (BT , \u03c4) \u2208 F with (D, d)\u2192 (BT , \u03c4) iff d 6\u2208 qS,O,A(x)(D). Thus, the ontology-mediated query Q is equivalent to the query defined by F .\nConversely, assume that F is a finite set of S-structures with one constant. Take some (B, b) \u2208 F , and for every d in the domain\ndom(B) of B, create some fresh concept name Ad. Let A be another fresh concept name, and set\nOB,b = {Ad v \u00acAd\u2032 | d 6= d\u2032} \u222a {Ad u \u2203R.Ad\u2032 v \u22a5 | R(d, d\u2032) 6\u2208 B, R \u2208 S} \u222a {Ad uB v \u22a5 | B(d) 6\u2208 B, B \u2208 S} \u222a {> v t\nd\u2208dom(B) Ad, \u00acAb v A}\nConsider the ontology-mediated query QB,b = (S,OB,b, A(x)). One can show that for every S-instance D and d \u2208 adom(D), (D, d) \u2192 (B, b) iff d 6\u2208 qQB,b(D). Thus, QB,b is the desired query ifF is a singleton. For the general case, letO be the disjunction over all OB,b with (B, b) \u2208 F . Note that O can be expressed in ALCU : first, rewrite each OB,b into a single inclusion of the form > v CB,b and then set\nO = {> v t (B,b)\u2208F \u2200U.CB,b}.\nUsing the above observation about the queries QB,b, it is not hard to show that the (ALCU ,AQ)-query Q = (S,O, A(x)) is equivalent to the query coCSP(F).\nThis completes the proof of Point 1. The proofs of Points 2 to 4 are similar and given in the full version of this paper. o\nTheorem 12 allows us to transfer results from the CSP world to OBDA, which, in light of recent progress on CSPs, turns out to be very fruitful. We start with data complexity.\nTheorem 13 (ALC,BAQ) has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. The same is true for (SHIU ,AQ), and (SHIU ,BAQ).\nSince SHIU -ontologies can be replaced by ALCU-ontologies in ontology-mediated queries due to Theorem 5, the \u201cif\u201d direction of (all cases mentioned in) Theorem 13 actually follows from Theorem 8. The \u201conly if\u201d direction is a consequence of Theorem 12. We now consider further interesting applications of Theorem 12, in particular to deciding query containment, FO-rewritability, and datalog rewritability."}, {"heading": "5.1 Query Containment", "text": "In Section 4, we have established decidability results for query containment in OBDA languages based on UCQs. For OBDA languages based on AQs and BAQs, we even obtain a tight complexity bound. It is easy to see that query containment in coCSP is characterized by homomorphisms between templates. Consequently, it is straightforward to show that query containment for generalized coCSP with constant symbols is NP-complete. Thus, Theorem 12 yields the following NEXPTIME upper bound for query containment in OBDA languages. The corresponding lower bound is proved in the full version of this paper by a non-trivial reduction of a NEXPTIME-complete tiling problem.\nTheorem 14 Query containment in (SHIU ,AQ\u222aBQ) is in NEXPTIME. It is NEXPTIME-hard already for (ALC,AQ) and for (ALC,BAQ).\nIt is a consequence of a result in [10] that query containment is undecidable for ALCF . We show in the full version of this paper how the slight gap pointed out in Footnote 3 can be bridged."}, {"heading": "5.2 FO- and Datalog-Rewritability", "text": "One prominent approach to answering ontology-mediated queries is to make use of existing relational database systems or\ndatalog engines, eliminating the ontology by query rewriting [18, 22, 20]. Specifically, an ontology-mediated query (S,O, q) is FOrewritable if there exists an FO-query over S that is equivalent to it and datalog-rewritable if there exists a datalog program over S that defines it. We observe that every ontology-mediated query that is FO-rewritable is also datalog-rewritable.\nProposition 4 If Q = (S,O, q) is an ontology-mediated query with O formulated in equality-free FO and q a UCQ, then qQ is preserved by homomorphisms. Consequently, it follows from [43] that if qQ is FO-rewritable, then qQ is rewritable into a UCQ (thus into datalog).\nExample 2 illustrates that ontology-mediated queries are not always rewritable into an FO-query, and the same holds for datalogrewritability. It is a central problem to decide, given an ontologymediated query, whether it is FO-rewritable and whether it is datalog-rewritable. By leveraging the CSP connection, we show that both problems are decidable and pinpoint their complexities.\nOn the CSP side, FO-rewritability corresponds to FOdefinability, and datalog-rewritability to datalog-definability. Specifically, an S-query coCSP(F) is FO-definable if there is an FO-sentence \u03d5 over S such that for all finite relational structures A over S, we have A |= \u03d5 iff A 6\u2192 B for all B in F . Similarly, coCSP(F) is datalog-definable if there exists a datalog program \u03a0 that defines it. FO-definability and datalog-definability have been studied extensively for CSPs, culminating in the following results.\nTheorem 15 Deciding, for a given finite relational structure B without constant symbols, whether coCSP(B) is FO-definable is NP-complete [35]. The same is true for datalog-definability [26].4\nCombining the preceding theorem with Theorem 12, we obtain NEXPTIME upper bounds for deciding FO-rewritability and datalog-rewritability of queries from (SHI,BAQ).\nTo capture the more important AQs rather than only BAQs, we show that Theorem 15 can be lifted, in a natural way, to generalized CSPs with constant symbols. The central step is provided by Proposition 5 below. For each finite relational structure B with constant symbols c1, . . . , cn, let us denote by Bc the corresponding relational structure without constant symbols over the schema that contains additional unary relations P1, . . . , Pn, where each Pi denotes the singleton set that consists of the element denoted by ci.\nProposition 5 For every set of homomorphically incomparable structures B1, . . . ,Bn with constant symbols,\n1. coCSP(B1, . . . ,Bn) is FO-definable iff coCSP(Bci ) is FOdefinable for 1 \u2264 i \u2264 n.\n2. coCSP(B1, . . . ,Bn) is datalog-definable iff coCSP(Bci ) is datalog-definable for 1 \u2264 i \u2264 n.\nA proof of Proposition 5 is provided in the full version of this paper. It relies on the characterization of FO-definable CSPs as those CSPs that have finite obstruction sets; this characterization was given in [2] for structures without constant symbols and follows from results in [43] for the case of structures with constant symbols.\n4An NP algorithm for datalog-definability is implicit in [26], based on results from [9], see also [13]. We thank Benoit Larose and Liber Barto for pointing this out.\nNote that every set of structures B1, . . . ,Bn has a subset B\u20321, . . . ,B\u2032m which consists of homomorphically incomparable structures such that coCSP(B1, . . . ,Bn) is equivalent to coCSP(B\u20321, . . . ,B\u2032m). We use this observation to establish the announced lifting of Theorem 15.\nTheorem 16 FO-definability and datalog-definability of generalized CSP with constant symbols is NP-complete.\nProof. To decide whether a generalized CSP with constant symbols given as a set of templates F = {B1, . . . ,Bn} is FO-definable, it suffices to first guess a subset F \u2032 \u2286 F and then to verify that (i) coCSP(Bc) is FO-definable for each B \u2208 F \u2032, and (ii) for each B \u2208 F there is a B\u2032 \u2208 F \u2032 such that B \u2192 B\u2032. By Theorem 15, this can be done in NP. Correctness follows from Proposition 5 and the fact that whenever there is a subset F \u2032 satisfying (i) and (ii), then by the observation above there must be a subset F \u2032\u2032 \u2286 F \u2032 of homomorphically incomparable structures such that coCSP(F \u2032\u2032) is equivalent to coCSP(F \u2032), which by (ii) is equivalent to coCSP(F). Datalog-definability can be decided analogously. o\nFrom Theorems 12 and 16, we obtain a NEXPTIME upper bound for deciding FO-rewritability and datalog-rewritability of ontologymediated queries based on DLs and (B)AQs. The corresponding lower bounds are proved in the full version of this paper using a reduction from a NEXPTIME-hard tiling problem (in fact, the same problem as in the lower bound for query containment).\nTheorem 17 It is in NEXPTIME to decide FO-rewritability and datalog-rewritability of queries in (SHIU ,AQ\u222aBAQ). Both problems are NEXPTIME-hard for (ALC,AQ) and (ALC, BAQ).\nModulo a minor difference in the treatment of instances that are not consistent (see Footnote 3), it follows from a result in [36] that FOrewritability is undecidable for (ALCF ,AQ). In the full version of this paper, we show how to bridge the difference and how to modify the proof so that the result also applies to datalog-rewritability.\nTheorem 18 FO-rewritability and datalog-rewritability are undecidable for (ALCF ,AQ) and (ALCF ,BAQ)."}, {"heading": "6. CONCLUSION", "text": "Another query language frequently used in OBDA with description logics is conjunctive queries. The results in this paper imply that there is a dichotomy between PTIME and CONP for (ALC,CQ) if and only if the Feder-Vardi conjecture holds. We leave it open whether there is a natural characterization of (ALC,CQ) in terms of disjunctive datalog.\nWe mention two natural lines of future research. First, it would be interesting to understand the data complexity and query containment problem for (GF,UCQ) and (GNFO,UCQ). In particular, we would like to know whether Theorems 8 and 10 extend to (GF,UCQ) and (GNFO,UCQ). As explained in Section 4, resolving this question for Theorem 8 is equivalent to clarifying the computational status of GMSNP and MMSNP2.\nAnother interesting topic for future work is to analyze FO-rewritability and datalog-rewritability of ontology-mediated queries based on UCQs (instead of AQs) as a decision problem. It follows from our results that this is equivalent to deciding FOdefinability and datalog-definability of MMSNP formulas (or even GMSNP formulas).\nAcknowledgements. We thank Benoit Larose and Liber Barto for discussions on datalog-definability of CSPs, and Florent Madeleine and Manuel Bodirsky for discussions on MMSNP.\nMeghyn Bienvenu was supported by the ANR project PAGODA (ANR-12-JS02-007-01). Balder ten Cate was supported by NSF Grants IIS-0905276 and IIS-1217869. Carsten Lutz was supported by the DFG SFB/TR 8 \u201cSpatial Cognition\u201d."}, {"heading": "7. REFERENCES", "text": "[1] B. Alexe, B. ten Cate, P. G. Kolaitis, and W. C. Tan.\nCharacterizing schema mappings via data examples. ACM Trans. Database Syst., 36(4), 2011.\n[2] A. Atserias. On digraph coloring problems and treewidth duality. In LICS, 2005.\n[3] F. Baader, M. Bienvenu, C. Lutz, and F. Wolter. Query and predicate emptiness in description logics. In KR, 2010.\n[4] F. Baader, D. Calvanese, D. L. McGuiness, D. Nardi, and P. Patel-Schneider, editors. The Description Logic Handbook. Cambridge University Press, 2003.\n[5] J.-F. Baget, M.-L. Mugnier, S. Rudolph, and M. Thomazo. Walking the complexity lines for generalized guarded existential rules. In IJCAI, 2011.\n[6] V. B\u00e1r\u00e1ny, G. Gottlob, and M. Otto. Querying the guarded fragment. In LICS, 2010.\n[7] V. B\u00e1r\u00e1ny, B. ten Cate, and M. Otto. Queries with guarded negation. PVLDB, 5(11), 2012.\n[8] V. B\u00e1r\u00e1ny, B. ten Cate, and L. Segoufin. Guarded negation. In ICALP, 2011.\n[9] L. Barto and M. Kozik. Constraint satisfaction problems of bounded width. In FOCS, 2009.\n[10] M. Bienvenu, C. Lutz, and F. Wolter. Query containment in description logics reconsidered. In KR, 2012.\n[11] P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Cambridge University Press, 2001.\n[12] M. Bodirsky, H. Chen, and T. Feder. On the complexity of MMSNP. SIAM J. Discrete Math., 26(1):404\u2013414, 2012.\n[13] A. Bulatov. Bounded relational width. In preparation. http://www.cs.sfu.ca/\u223cabulatov/mpapers.html.\n[14] A. A. Bulatov. On the CSP dichotomy conjecture. In CSR, 2011.\n[15] A. Cal\u00ec, G. Gottlob, and T. Lukasiewicz. A general datalog-based framework for tractable query answering over ontologies. In PODS, 2009.\n[16] A. Cal\u00ec, G. Gottlob, and A. Pieris. Towards more expressive ontology languages: The query answering problem. Artif. Intell., 193, 2012.\n[17] D. Calvanese, G. D. Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Data complexity of query answering in description logics. In KR, 2006.\n[18] D. Calvanese, G. D. Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Tractable reasoning and efficient query answering in description logics: The DL-Lite family. J. Autom. Reasoning, 39(3), 2007.\n[19] D. Calvanese, G. D. Giacomo, and M. Lenzerini. On the decidability of query containment under constraints. In PODS, 1998.\n[20] B. Cuenca Grau, M. Kaminski, and B. Motik Computing Datalog Rewritings Beyond Horn Ontologies. In IJCAI, 2013\n[21] T. Eiter, G. Gottlob, and H. Mannila. Disjunctive datalog. ACM Trans. Database Syst., 22(3), 1997.\n[22] T. Eiter, M. Ortiz, M. Simkus, T.-K. Tran, and G. Xiao. Towards practical query answering for Horn-SHIQ. In DL, 2012.\n[23] T. Feder, F. R. Madelaine, and I. A. Stewart. Dichotomies for classes of homomorphism problems involving unary functions. Theor. Comput. Sci., 314(1-2), 2004.\n[24] T. Feder and M. Y. Vardi. The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory. SIAM J. Comput., 28(1), 1998.\n[25] J. Foniok, J. Nesetril, and C. Tardif. Generalised dualities and maximal finite antichains in the homomorphism order of relational structures. Eur. J. Comb., 29(4), 2008.\n[26] R. Freese, M. Kozik, A. Krokhin, M. Mar\u00f3ti, R. KcKenzie, and R. Willard. On Maltsev conditions associated with omitting certain types of local structures. In preparation. http://www.math.hawaii.edu/\u223cralph/Classes/619/ OmittingTypesMaltsev.pdf\n[27] G. Gottlob, E. Gr\u00e4del, and H. Veith. Datalog LITE: a deductive query language with linear time model checking. ACM Trans. Comput. Log., 3(1), 2002.\n[28] G. Gottlob and T. Schwentick. Rewriting ontological queries into small nonrecursive datalog programs. In KR, 2012.\n[29] U. Hustadt, B. Motik, and U. Sattler. Reasoning in description logics by a reduction to disjunctive datalog. J. Autom. Reasoning, 39(3), 2007.\n[30] S. Kikot, R. Kontchakov, V. V. Podolskii, and M. Zakharyaschev. Exponential lower bounds and separation for query rewriting. In ICALP, 2012.\n[31] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, and M. Zakharyaschev. The combined approach to query answering in DL-Lite. In KR, 2010. [32] A. Krisnadhi and C. Lutz. Data complexity in the EL family of DLs. In LPAR, 2007.\n[33] G. Kun. Constraints, MMSNP, and Expander Structures. http://arxiv.org/abs/0706.1701v1, 2007.\n[34] G. Kun and J. Nesetril. Forbidden lifts (NP and CSP for combinatorialists). Eur. J. Comb., 29(4), 2008.\n[35] B. Larose, C. Loten, and C. Tardif. A characterisation of first-order constraint satisfaction problems. Logical Methods in Comp. Sci., 3(4), 2007.\n[36] C. Lutz and F. Wolter. Non-uniform data complexity of query answering in description logics. In KR, 2012.\n[37] F. R. Madelaine. Universal structures and the logic of forbidden patterns. Logical Methods in Comp. Sci., 5(2), 2009.\n[38] F. R. Madelaine and I. A. Stewart. Constraint satisfaction, logic and forbidden patterns. SIAM J. Comput., 37(1), 2007.\n[39] B. Motik. Reasoning in description logics using resolution and deductive databases. PhD thesis, 2006.\n[40] A. Poggi, D. Lembo, D. Calvanese, G. D. Giacomo, M. Lenzerini, and R. Rosati. Linking data to ontologies. J. Data Semantics, 10, 2008.\n[41] V. R. Pratt. Models of program logics. In FoCS, 1979. [42] R. Rosati and A. Almatelli. Improving Query Answering\nover DL-Lite Ontologies. In KR, 2010. [43] B. Rossman. Homomorphism preservation theorems. J.\nACM, 55(3), 2008. [44] S. Rudolph, M. Kr\u00f6tzsch, and P. Hitzler.\nType-elimination-based reasoning for the description logic SHIQbs using decision diagrams and disjunctive datalog. Logical Methods in Comp. Sci., 8(1), 2012.\n[45] F. Simancik. Elimination of complex RIAs without automata. In DL, 2012.\n[46] B. ten Cate and L. Segoufin. Unary negation. In STACS, 2011.\n[47] W3C OWL Working Group. OWL 2 Web Ontology Language. http://www.w3.org/TR/owl2-overview/, 2012."}, {"heading": "APPENDIX", "text": ""}, {"heading": "A. PROOFS FOR SECTION 3", "text": ""}, {"heading": "A.1 Proofs for Section 3.1", "text": "We remark that the direction \u201cfrom (ALC,AQ) to MDDlog\u201d of Theorem 1 is actually a consequence of Theorem 6, which makes a strictly more general statement. We still provide it here (and in the main paper) as a warmup for the proof of Theorem 6. As an extra bit of notation, we say that an assignment \u03c0 of elements of an instance D to the variables of a CQ q is a match of q in D if D satisfies q under \u03c0.\nTheorem 1. (ALC,UCQ) and MDDlog have the same expressive power.\nProof. (continued) We establish here the correctness of the translation from (ALC,UCQ) to MDDlog. Letm be the arity of (S,O, q). We have to show the following.\nClaim. For all instances D over S and all a \u2208 adom(D)m, we have a \u2208 certq,O(D) iff a \u2208 q\u03a0(D).\n\u201cif\u201d. Assume that a /\u2208 certq,O(D). Then there is a (dom\u2032,D\u2032) \u2208 Mod(O) such that D \u2286 D\u2032 and a /\u2208 q(D\u2032). For each b \u2208 adom(D), let \u00b5(b) be the unique type realized at b in D\u2032, that is,\n\u00b5(b) = {q\u2032 \u2208 cl(O, q) | q\u2032 is Boolean and D\u2032 |= q\u2032}\u222a {C \u2208 cl(O, q) | C is unary and D\u2032 |= C[b]}.\nLet D\u2032\u2032 be the instance that consists of the atoms in D and the atom P\u00b5(b)(b) for each b \u2208 adom(D). It can be verified that D\u2032\u2032 is a model of \u03a0. In particular, it follows from the construction of D\u2032\u2032 and the fact that a /\u2208 q(D\u2032) that whenever a diagram \u03b4(x) has a match \u03c0 in D\u2032\u2032 and \u03b4(x) implies q(x\u2032), then \u03c0(x\u2032) 6= a. Since D\u2032\u2032 is a model of \u03a0 and goal(a) /\u2208 D\u2032\u2032, we have a 6\u2208 q\u03a0(D).\n\u201conly if\u201d. Assume that a 6\u2208 q\u03a0(D), and let D\u2032 \u2208 Mod(\u03a0) be such that D \u2286 D\u2032 and D\u2032 does not contain goal(a). We assume w.l.o.g. that adom(D) = adom(D\u2032). Note that the first two rules of \u03a0 ensure that for each a \u2208 adom(D), there is a unique type \u00b5(a) such that P\u00b5(a)(a) \u2208 D\u2032. The second rule further ensures that for each a \u2208 adom(D), there is a model (doma,Da) of O in which \u00b5(a) is realized at a. We may assume that these models have disjoint domains. Let (dom\u2032\u2032,D\u2032\u2032) be the relational structure obtained by first taking the union of (doma,Da)a\u2208adom(D), and then adding all facts from D. To prove that a /\u2208 certq,O(D), it suffices to show that\n(i) (dom\u2032\u2032,D\u2032\u2032) is a model of O, and (ii) a 6\u2208 q(D\u2032\u2032).\nFor Point (i), let \u00b5(d) be the unique type realized by d in (doma,Da), for all d \u2208 doma. It is not difficult to show by induction on the structural complexity of C that for all concepts C \u2208 cl(O, q) \u2229 sub(O) and all d \u2208 dom\u2032\u2032, we have\n(dom\u2032\u2032,D\u2032\u2032) |= C(d) iff C \u2208 \u00b5(d) (1)\n(refer to the proof of Theorem 2 for details). Since cl(O, q) by definition includes C and D whenever C v D is inO, this implies Point (i) as desired.\nIt thus remains to establish Point (ii). Assume to the contrary that there is a disjunct q\u2032(x\u2032) of q such that a \u2208 q\u2032(D\u2032\u2032), that is, there is a match \u03c0 of q\u2032(x\u2032) in D\u2032\u2032 such that \u03c0(x\u2032) = a. We define a diagram \u03b4(x) based on the restriction of the original model D\u2032 of \u03a0 , as follows: \u03b4(x) contains (a) all atoms A(x) such that \u03c0(x) \u2208 adom(D\u2032) and A(\u03c0(x)) \u2208 D\u2032 (where A can be either a concept name or of the form P\u03c4 ), (b) all atoms R(x, y) such that \u03c0(x), \u03c0(y) \u2208 adom(D\u2032) and R(\u03c0(x), \u03c0(y)) \u2208 D\u2032, and (c) all atoms P\u00b5(d)(zd) (with zd a fresh variable) such that P\u00b5(d)(d) \u2208 D\u2032 and there is some \u03c0(w) \u2208 domd. Atoms of type (c) are used to handle the case in which a Boolean subquery q\u2032\u2032 of q\u2032 is mapped inside Dd, but the element d does not itself belong to the image of \u03c0. We remark that the mapping \u03c0 can be straightforwardly extended to a match for \u03b4(x) in D\u2032 by setting \u03c0(zd) = d. Since \u03b4(x) is satisfied in D\u2032 under \u03c0 and \u03c0(x\u2032) = a, by the last rule of \u03a0, we can obtain the desired contradiction by showing that \u03b4(x) implies q\u2032(x\u2032).\nThus, let (dom,B) \u2208 Mod(O) be a type-coherent structure, and let \u03c4 be a match of \u03b4(x) in B. Consider the following CQs:\n\u2022 q0 is the restriction of q\u2032 to those variables that \u03c0 maps to elements of D;\n\u2022 for each a \u2208 adom(D) such that some element of doma is in the range of \u03c0, the CQ qa is obtained by first taking the restriction of q\u2032 to those variables that \u03c0 maps to elements of doma and then identifying all variables that \u03c0 maps to the same element (preserving the names of free variables).\nClearly, each qa has at most one free variable, which, if it exists, is mapped to a by \u03c0.\nWe start by showing that q0 is satisfied in B under \u03c4 . For role atoms in q0, this is immediate since all such atoms also belong to \u03b4(x). Thus, consider some concept atom A(x) \u2208 q0. Since A(x) \u2208 q\u2032 and \u03c0 is a match for q\u2032 in D\u2032\u2032, we have A(\u03c0(x)) \u2208 D\u2032\u2032. Then using the fact that A \u2208 cl(O, q) \u2229 sub(O) and Equation (1) above, we obtain A \u2208 \u00b5(\u03c0(x)). We know that P\u00b5(\u03c0(x))(\u03c0(x)) \u2208 D\u2032, so by construction of \u03b4(x), we must have P\u00b5(\u03c0(x))(x) \u2208 \u03b4(x), hence P\u00b5(\u03c0(x))(\u03c4(x)) \u2208 B. Using the type-coherence of B and the fact that A \u2208 \u00b5(\u03c0(x)), we obtain A(\u03c4(x)) \u2208 B, as desired.\nNow consider a query qa. By construction, the length of qa cannot exceed the length of q, and so qa \u2208 cl(O, q). Since qa has a match in Da (such that, if qa has a free variable, it is mapped to a) and Da realizes the type \u00b5(a) at a, we must have qa \u2208 \u00b5(a). By construction of \u03b4(x), there is an atom P\u00b5(a)(x) \u2208 \u03b4(x). Since \u03c4 is a match for \u03b4(x) in B, we must have P\u00b5(a)(\u03c4(x)) \u2208 B. Then, using the fact that B is type-coherent, we can find a match \u03c4a of qa in B (such that, if qa has a free variable, \u03c4a maps it to \u03c4(x)). It is not hard to see that the matches \u03c4 and \u03c4a can be assembled into a match \u03c4 \u2032 of q\u2032 in B which coincides with \u03c4 on x\u2032. o\nTheorem 2 (ALC,AQ) has the same expressive power as unary connected simple MDDlog.\nProof. (continued) We establish here the correctness of the translation from (ALC,AQ) to MDDlog. That is, we show that, for every instance D and elements a \u2208 adom(D), we have a \u2208 certq,O(D) if and only if a \u2208 q\u03a0(D).\n\u201cif\u201d. Assume that a 6\u2208 certq,O(D). Then there is (dom,D\u2032) \u2208 Mod(O) with D \u2286 D\u2032 such that a 6\u2208 q(D\u2032). For each b \u2208 adom(D), let \u00b5(b) be the unique type realized at b in D\u2032. Let D\u2032\u2032 be the instance that consists of the atoms in D and an atom P\u00b5(b)(b) for each b \u2208 adom(D). It can be checked that D\u2032\u2032 is a model of \u03a0. Since goal(a) /\u2208 D\u2032\u2032, we obtain a 6\u2208 q\u03a0(D).\n\u201conly if\u201d. Assume that a 6\u2208 q\u03a0(D) and let D\u2032 be a model of \u03a0 with D \u2286 D\u2032 that does not contain goal(a). For each b \u2208 adom(D), let \u00b5(b) be a type such that P\u00b5(b)(b) \u2208 D\u2032 (in fact, the rules in \u03a0 enforce that there is exactly one such \u00b5(b)). Note that A 6\u2208 \u00b5(a). Also note that each type \u00b5(b) must be realizable in some model of O (else, there would be a rule forbidding P\u00b5(b) atoms). Thus, for each b \u2208 adom(D), we can find a model (domb,Db) of O in which the type \u00b5(b) is realized at b. We may assume that these models have disjoint domains. Let (dom\u2032\u2032,D\u2032\u2032) be obtained by first taking the union of (domb,Db)b\u2208adom(D), and then adding all facts in D. By construction, D \u2286 D\u2032\u2032 and a 6\u2208 q(D\u2032\u2032). It remains to show that (dom\u2032\u2032,D\u2032\u2032) is a model of O.\nLet \u00b5(d) be the unique type realized by d in (doma,Da), for all d \u2208 doma. We show the following by induction on the structural complexity of C:\n(\u2217) For every concept C \u2208 sub(O) and every d \u2208 dom\u2032\u2032, we have (dom\u2032\u2032,D\u2032\u2032) |= C(d) iff C \u2208 \u00b5(d).\nNote that it follows from (\u2217) that (dom\u2032\u2032,D\u2032\u2032) is a model of O. For the base case, first suppose that A \u2208 \u00b5(d), with A a concept name and d \u2208 doma. Then A(d) \u2208 Da \u2286 D\u2032\u2032, so (dom\u2032\u2032,D\u2032\u2032) |= A(d). Next suppose that (dom\u2032\u2032,D\u2032\u2032) |= A(d). Then A(d) \u2208 D\u2032\u2032, so either A(d) \u2208 Da, or d = a and A(d) \u2208 D. In the former case, we immediately obtain A \u2208 \u00b5(d). In the latter case, note that if A 6\u2208 \u00b5(d), then \u03a0 would contain the rule \u22a5 \u2190 P\u00b5(d)(x) \u2227 A(x), and this would yield a contradiction since {A(d), P\u00b5(d)(d)} \u2286 D\u2032.\nThe inductive step for the Boolean operators is trivial, so we consider only the case of the \u2203R constructor (the argument for the \u2200R constructor is similar). Thus, let C = \u2203R.D and d \u2208 doma, and suppose that C \u2208 \u00b5(d). Then (doma,Da) |= \u2203R.D(d), so there exists e \u2208 doma such that R(d, e) \u2208 Da and (doma,Da) |= D(e). It follows that D \u2208 \u00b5(e), and hence by the induction hypothesis, we must have (dom\u2032\u2032,D\u2032\u2032) |= D(e). Since Da \u2286 D\u2032\u2032, we have R(d, e) \u2208 D\u2032\u2032, which yields (dom\u2032\u2032,D\u2032\u2032) |= C(d).\nConversely, suppose (dom\u2032\u2032,D\u2032\u2032) satisfies \u2203R.D(d), that is, there is an element e such that (dom\u2032\u2032,D\u2032\u2032) satisfies R(d, e) and D(e). If e \u2208 doma, the claim (\u2217) follows immediately from the induction hypothesis. Otherwise, we must have that e \u2208 adom(D) and, by induction hypothesis, D \u2208 \u00b5(e). It follows that \u2203R.D \u2208 \u00b5(d), because otherwise P\u00b5(d)(x) \u2227R(x, y) \u2227 P\u00b5(e)(y) would be a non-realizable diagram, and \u03a0 would derive an inconsistency.\no\nTheorem 3.\n1. (ALCHIU ,UCQ) has the same expressive power as MDDlog and as (ALC,UCQ).\n2. (S,UCQ) and (ALCF ,UCQ) are strictly more expressive than (ALC,UCQ).\nTo complete the proof of Theorem 3, we need to show that the queries from (S,UCQ) and (ALCF ,UCQ) indicated in the proof sketch cannot be expressed in (ALC,UCQ), or equivalently, MDDlog. We start by providing a means of identifying queries which cannot be expressed in MDDlog, using the notion of colored instances, defined as follows:\nDefinition 1 Let S be a schema and C be a set of unary predicates (colors) {C1, . . . , Cn} disjoint from S. A C-colored S-structure is an S \u222a C-structure (dom,D) such that \u2022 For every d \u2208 dom, Ci(d) \u2208 D for some i; \u2022 If Ci(d) \u2208 D, then Cj(d) 6\u2208 D for every j 6= i.\nD is called a C-coloring of an S-structure D\u2032 if D\u2032 is the S-reduct of D\u2032.\nNow for each k > 0, fix Ck with |Ck| = k and Ck \u2229S = \u2205. Then a k-coloring of D is simply a Ck-coloring of D.\nWe will also utilize the notion of forbidden pattern problems from [38, 34, 12], whose definition we recall here.\nDefinition 2 Given a set F of C-colored S-structures (called forbidden patterns), we define Forb(F) as the set of all S-structures D such that there exists a C-coloring D\u2032 of D for which F 6\u2192 D\u2032 for every F \u2208 F . The forbidden patterns problem defined by F is to decide whether a given S-structure belongs to Forb(F).\nAnalogously to coMMSNP, we can define a query language coFPP consisting of all those Boolean queries qF,S defined by\nqF,S(D) = 1 iff (adom(D),D) 6\u2208 Forb(F)\nwith F a set of C-colored S-structures. It follows directly from results in [38] that coMMSNP and coFPP have the same expressive power. Combining this result with Proposition 2 (from Section 4), we obtain the following:\nProposition 6 coFPP and Boolean MDDlog have the same expressive power.\nWe use Proposition 6 in the proof of the following lemma, whose purpose is to establish a sufficient condition for non-expressibility in MDDlog.\nLemma 1 A Boolean query Q over schema S does not belong to MDDlog if for every m,n > 0, there exist S-instances D0 and D1 with Q(D0) = 0 and Q(D1) = 1 such that for every mcoloring B0 of (adom(D0),D0), there exists anm-coloring B1 of (adom(D1),D1) such that from every substructure of B1 having at most n elements there is a homomorphism to B0.\nProof. Assume for a contradiction that the conditions of the lemma hold for every n,m > 0 but that Q is equivalent to some query in MDDlog. Then, by Proposition 6, there is a set F of C-colored S-structures such that for all S-instances D, we have Q(D) = 1 if and only if (adom(D),D) 6\u2208 Forb(F). Let m0 = |C|, and let n0 be the maximal number of elements in the domain of some F \u2208 F . We can assume w.l.o.g. that C = Cm0 .\nTake S-instances D0 and D1 satisfying the conditions of the lemma for m0, n0. As Q(D0) = 0, there exists a C-coloring B0 of (adom(D0),D0) such that F 6\u2192 B0 for every F \u2208 F . It follows that there exists a C-coloring B1 of (adom(D1),D1) such that from every substructure of B1with at most n0 elements, there exists a homomorphism to B0. Since Q(D1) = 1, we know that there must exist some F \u2208 F such that F \u2192 B1. As F contains at most n0 elements, we can compose this homomorphism with the previous homomorphism to obtain a homomorphism of F into B0, contradicting the fact that (adom(D0),D0) \u2208 Forb(F). o\nUsing the preceding lemma, we can now prove that the queries mentioned in the proof sketch cannot be expressed in MDDlog.\nLemma 2 There exist queries in (S,UCQ) which do not belong to MDDlog.\nProof. Consider Q = (S,O, q) where S = {R,S}, O asserts transitivity of R and S, and q = \u2203xy(R(x, y) \u2227 S(x, y)).\nWe apply Lemma 1. Assume that m,n > 0 are given. Let k = n\u2212 1 and k\u2032 = mk+2 + 1. Define D1 and D0 as follows:\n\u2022 D1 has elements e, f and a1, . . . , ak and b1, . . . , bk and the atoms R(e, a1), R(ak, f) and R(ai, ai+1) for 1 \u2264 i < k, and S(e, a1), S(ak, f) and S(bi, bi+1) for 1 \u2264 i < k.\n\u2022 D0 has elements e1, . . . , ek \u2032 and f1, . . . , fk \u2032\nas well as aj1, . . . , a j k for 1 \u2264 j \u2264 k \u2032 and bi,j1 , . . . , b i,j k for 1 \u2264 j < i \u2264 k\u2032. The atoms of D0 consist of: \u2013 R(ei, ai1), R(aik, f i), and R(aij , aij+1) for 1 \u2264 i \u2264 k\u2032 and\n1 \u2264 j < k; \u2013 S(ei, bi,j1 ) and S(b i,j k , fj) for 1 \u2264 j < i \u2264 k\n\u2032, and S(bi,jl , b i,j l+1) for 1 \u2264 l < k and 1 \u2264 j < i \u2264 k\n\u2032. It is readily checked that Q(D0) = 0 and Q(D1) = 1, as required. Let B0 be an m-coloring of (adom(D0),D0). Since k\u2032 = mk+2 + 1, we can find i, i\u2032 with i > i\u2032 such that the colorings of ei, ai1, . . . , aik, f i and ei \u2032 , ai \u2032 1 , . . . , a i\u2032 k , f\ni\u2032 coincide. Define an m-coloring of (adom(D1),D1) by taking the coloring of ei, ai1, . . . , aik, f\ni for e, a1, . . . , ak, f and the coloring of bi,i \u2032 1 , . . . , b i,i\u2032\nk for b1, . . . , bk. Denote by B1 the resulting colored structure.\nConsider a subset C of adom(B1) having at most n elements, and let B\u20321 be the restriction of B1 to the elements in C. We define a function h from C to adom(B0) as follows: \u2022 If e 6\u2208 C, then let h be the restriction of the following mapping\nto C: h(al) = ai \u2032 l , h(bl) = b i,i\u2032 l and h(f) = f i\u2032 ;\n\u2022 If f 6\u2208 C, then let h be the restriction of the following mapping to C: h(al) = ail , h(bl) = b i,i\u2032 l and h(e) = e i; \u2022 Otherwise there exists ai0 6\u2208 C. Then let h be the restriction of the following mapping to C: h(e) = ei, h(al) = ail for all l < i0, h(al) = ai \u2032 l for all l > i0, h(bl) = b i,i\u2032\nl for all 1 \u2264 l \u2264 k, and h(f) = f i \u2032 .\nIt is easily verified that h is a homomorphism from B\u20321 to B0. o\nLemma 3 There exist queries in (ALCF ,UCQ) which do not belong to MDDlog.\nProof. Consider Q = (S,O, \u2203x.A(x)) where S = {S,A} and O states that S is functional. Set D1 = {S(a, b), S(a, c)} and D0 = {S(a, b)}. Note that qQ(D1) = 1 (since no model of O contains D1) and qQ(D0) = 0. Let B0 be any m-coloring of (adom(D0),D0). We define anm-coloring B1 of D1 by assigning a, b the same colors as in B0 and giving c the same color as b. Then the mapping sending a to itself and b, c to b defines a homomorphism from B1 to B0 (and hence also defines a homomorphism from any substructure of B1 to B0). It follows by Lemma 1 thatQ is not definable in MDDlog. o\nTheorem 5 (ALCU ,AQ) and (SHIU ,AQ) both have the same expressive power as unary simple MDDlog.\nProof. We first show \u2022 (ALCU ,AQ) is at least as expressive as unary simple MDDlog; \u2022 unary simple MDDlog is at least as expressive as\n(ALCIU ,AQ). For Point 1, let \u03a0 be a unary simple MDDlog program. The rewriting of each rule of \u03a0 into an equivalent ALCU-concept inclusion is similar to the proof of Theorem 2 except that now one also has to concider non-connected bodies. They can be translated using the universal role. For example,\nP1(x) \u2228 P2(y)\u2190 A(x) \u2227B(y)\nis rewritten into A u \u2203U.(B u \u00acP2) v P1. Now consider Point 2. The translation from (ALCIU ,AQ) to unary simple MDDlog queries is a modified version of the translation given in the proof of Theorem 2 for the translation from (ALC,AQ) to connected unary simple MDDlog queries.\nAssume that (S,O, q) with q = A(x) is given. As in Theorem 2, we take types to be subsets of sub(O). The MDDlog program \u03a0 consists of the following rules:\u2228\n\u03c4\u2286sub(O) P\u03c4 (x)\u2190 adom(x) \u22a5 \u2190 \u03b4(x) for all non-realizable diagrams \u03b4(x)\nof the form P\u03c41(x1) \u2227 P\u03c42(x2), P\u03c4 (x) \u2227A(x), or P\u03c41(x1) \u2227 S(x, y) \u2227 P\u03c42(x2)\ngoal(x)\u2190 P\u03c4 (x) for all P\u03c4 with A \u2208 P\u03c4 Note that the only difference with the rules in the proof of Theorem 2 is the presence of rules of the form\n\u22a5 \u2190 P\u03c41(x1) \u2227 P\u03c42(x2)\nwhich are not connected. \u03a0 is still unary and simple. Equivalence of (S,O, q) and q\u03a0 can now be proved similarly to Theorem 2.\nIt remains to be shown that (ALCIU ,AQ) and (SHIU ,AQ) are equally expressive. But this is again folkore [39, 45]: it is known that for every SHIU -ontologyO, there exists anALCIU - ontology O\u2032 (possibly using additional concept names) such that (i) O\u2032 |= O and (ii) for every A \u2208 Mod(O), there exists a model A\u2032 \u2208 Mod(O\u2032) with the same domain and interpreting the concept names of O in the same way as A and interpreting the role names as relations containing their interpretation in A. It follows that (ALCIU ,AQ) and (SHIU ,AQ) are equally expressive. o\nWe briefly discuss Boolean atomic queries (BAQs), i.e., queries of the form \u2203x.A(x), where A is a unary relation symbol. BAQs behave similarly to AQs and one can show modified versions of Theorems 2 to Theorem 5 above in which AQs are replaced by BAQs and unary goal predicates by 0-ary goal-predicate, respectively.\nTheorem 19 Theorems 2 to Theorem 5 hold if AQs are replaced by BAQs and unary goal predicates by 0-ary goal-predicate, respectively.\nProof. We show the required modifications to the proof of Theorem 2. The remaining results are proved by similar modifications and left to the reader. For the translation from (ALC,BAQ) to Boolean connected simple MDDlog, the only difference to the program constructed in the proof of Theorem 2 is that rules of the form goal(x)\u2190 P\u03c4 (x) are replaced by rules of the form goal\u2190 P\u03c4 (x). Conversely, for the translation from Boolean connected simple MDDlog to (ALC,BAQ), we regard goal as a concept name and take the BAQ \u2203x.goal(x). The rewriting of goal rules must also be accordingly modified. For example, goal \u2190 R(x, y) is rewritten into \u2203R.> v goal. o"}, {"heading": "A.2 Proofs for Section 3.2", "text": "Theorem 6 (UNFO,UCQ) has the same expressive power as MDDlog.\nProof. (continued) We establish here the correctness of the translation from (UNFO,UCQ) to MDDlog. That is, we show that, for every instance D and elements a \u2208 adom(D), we have\na \u2208 certq,O(D) if and only if a \u2208 q\u03a0(D). The \u201cif\u201d direction proceeds exactly as in the proof of Theorem 1, so here we focus on the \u201conly if\u201d direction.\n\u201conly if\u201d. Assume that a 6\u2208 q\u03a0(D) and let D\u2032 be a model of \u03a0 with D \u2286 D\u2032 that does not contain goal(a). For each a \u2208 adom(D), let \u00b5(a) be the unique type such that P\u00b5(a)(a) \u2208 D\u2032, and let (doma,Da) be a model of O in which \u00b5(a) is realized at a. Note that such a model must exist because otherwise the diagram P\u00b5(a)(x) would be non-realizable and \u03a0 would include a rule \u22a5 \u2190 P\u00b5(a)(x). We may assume that these models have disjoint domains. Let (dom\u2032\u2032,D\u2032\u2032) be obtained by first taking the union of (doma,Da)a\u2208adom(D), and then adding to it all facts of D. We show that\n(i) (dom\u2032\u2032,D\u2032\u2032) is a model of O, and (ii) a 6\u2208 q(D\u2032\u2032). We start with the first claim. Let \u00b5(d) be the unique type realized by d in (doma,Da), for all d \u2208 doma. We show the following by induction on the structure of \u03d5:\n(\u2217) For all \u03d5 \u2208 clk(O) and d \u2208 dom\u2032\u2032, we have that \u03d5 \u2208 \u00b5(d) iff (dom\u2032\u2032,D\u2032\u2032) |= \u03d5[d].\nNote that \u03d5 may be either a sentence or a formula with exactly one free variable, and in the former case, we interpret \u03d5[d] as \u03d5. Since all types \u00b5(d) must include the sentence O, (\u2217) implies (i).\nThe base case (\u03d5 = >) and the inductive step for formulas of the form \u00ac\u03c8(x) are omitted since they are straightforward. Thus, let \u03d5 be a formula from clk(O) of the form \u2203y \u2227 i \u03c8i(x,y), and let d \u2208 doma. We may assume that \u03d5 is connected, meaning that the graph whose nodes are the subformulas \u03c8i and containing an edge between \u03c8i and \u03c8j if they share a variable, is connected. This is because, if \u03d5 is not connected, then the claim follows immediately from the analogous claims for each of the connected components of \u03d5. We present the proof for the case where \u03d5 has answer variable x (the argument for sentences is similar).\nFirst suppose that \u03d5 \u2208 \u00b5(d), which means (doma,Da) |= \u03d5[d]. It follows that there is an assignment \u03c0 of elements of doma to the variables x,y such that \u03c0(x) = d and for every i, (doma,Da) |= \u03c8i(\u03c0(x,y)). If \u03c8i is an atomic formula, then using the fact that Da \u2286 D\u2032\u2032, we obtain (dom\u2032\u2032,D\u2032\u2032) |= \u03c8i(\u03c0(x,y)). If \u03c8i is not atomic, then it must have at most one free variable u. We thus have that (doma,Da) |= \u03c8i[\u03c0(u)], so \u03c8i \u2208 \u00b5(\u03c0(u)). Applying the induction hypothesis, we obtain (dom\u2032\u2032,D\u2032\u2032) |= \u03c8i[\u03c0(u)]. It follows that \u03c0 is a satisfying assignment for \u03d5 in (dom\u2032\u2032,D\u2032\u2032), hence (dom\u2032\u2032,D\u2032\u2032) |= \u03d5[d].\nConversely, suppose (dom\u2032\u2032,D\u2032\u2032) |= \u03d5[d], that is, (dom\u2032\u2032,D\u2032\u2032) satisfies \u2227 i \u03c8i(x,y) for some assignment \u03c0 of elements of dom \u2032\u2032 to the variables x,y such that \u03c0(x) = d. First assume that the image of \u03c0 is entirely contained in doma. Using the induction hypothesis to treat the non-atomic \u03c8i as before, we then get that (doma,Da) |= \u03d5[d], hence \u03d5 \u2208 \u00b5(d) as required.\nNext suppose that the image of \u03c0 is not wholly contained in doma, and let I be the set consisting of the elements of adom(D) that are in the range of \u03c0. By the connectedness assumption and the fact that d \u2208 doma, the set I contains a. In what follows, we will define a number of formulas by syntactic operations on \u03d5. It will follow from the definition of clk(O) that each of these formulas again belongs to clk(O), and hence, is subject to the induction hypothesis. Let \u03d5\u2032 be obtained from \u03d5 by identifying all variables z, z\u2032 such that \u03c0(z) = \u03c0(z\u2032) \u2208 I . We assume that the free variable x retains its name, and use \u03c8\u2032i to denote the conjunct of \u03d5\n\u2032 which corresponds to \u03c8i. For each b \u2208 I , let zb \u2208 y \u222a {x} be the unique variable in \u03d5\u2032 with \u03c0(zb) = b. Let \u03d5\u2032b be the restriction of \u03d5 \u2032 to\nthose \u03c8\u2032i which contain only variables z with \u03c0(z) \u2208 domb, with free variable zb. We have (dom\u2032\u2032,D\u2032\u2032) |= \u03d5\u2032b[b] via the restriction of \u03c0 to the variables in \u03d5\u2032b, thus, by the earlier argument (since all witnessing elements are contained in domb), we have \u03d5\u2032b \u2208 \u00b5(b). Let \u03d5\u20320 be \u03d5\u2032, but with free variable za instead of x. Note that (dom\u2032\u2032,D\u2032\u2032) |= \u03d5\u20320[a].\nConsider the diagram \u03b4 obtained by taking the restriction of D\u2032 to I , and then replacing each b \u2208 I with zb. Since \u03b4 is made true by D\u2032, and D\u2032 is a model of \u03a0, we have that \u03b4 is a realizable diagram. Moreover, using the fact that P\u00b5(b)(zb) \u2208 \u03b4 and \u03d5\u2032b \u2208 \u00b5(b) for every b \u2208 I , one can show that the diagram \u03b4 implies the query \u03d5\u20320. This together with the realizability of \u03b4 yields \u03d5\u20320 \u2208 \u00b5(a), hence (doma,Da) |= \u03d5\u20320[a]. Let \u03c0\u2032 be a satisfying assignment of \u03d5\u20320 in Da such that \u03c0\u2032(za) = a. We use \u03c0\u2032 to construct a satisfying assignment \u03c0\u2032\u2032 of \u03d5\u2032 mapping x to d, such that the range of \u03c0\u2032\u2032 lies entirely inside doma. The assignment \u03c0\u2032\u2032 is defined as follows: for all u with \u03c0(u) in doma, set \u03c0\u2032\u2032(u) = \u03c0(u); for all other u, set \u03c0\u2032\u2032(u) = \u03c0\u2032(u). To see that \u03c0\u2032\u2032 is indeed a satisfying assignment of \u03d5\u2032, note that each conjunct of \u03d5\u2032 contains, besides za, either only variables u with \u03c0(u) \u2208 doma, or only variables u with \u03c0(u) 6\u2208 doma. The former conjuncts are satisfied because \u03c0 is a match, and the latter conjuncts are satisfied because \u03c0\u2032 is a match. Moreover, \u03c0\u2032\u2032(x) = d. Therefore, (doma,Da) |= \u03d5[d] and hence \u03d5 \u2208 \u00b5(d) as required.\nFinally, we can show (ii) in a similar way. We suppose, for the sake of contradiction, that a \u2208 q(D\u2032\u2032) under some assignment \u03c0 to the existentially quantified variables in q. Let b be the elements of adom(D) belonging to the range of \u03c0 (here again we focus on the case in which q is connected and contains at least one free variable). Then, in the same way as above, we can decompose q into unary subqueries qb that are satisfied in the different subinstances Db with b \u2208 b, and conclude that qb \u2208 \u00b5(b) for each b \u2208 b. We can then show that the diagram obtained by taking all facts in D\u2032 over elements in b and replacing each b \u2208 b by zb implies the query q. This yields the desired contradiction since D\u2032 is a model of \u03a0.\no\nProposition 1. The Boolean query (\u2020) there are a1, . . . , an, b, for some n \u2265 2, such that A(a1),\nB(an), and P (ai, b, ai+1) for all 1 \u2264 i < n is definable in (GF,UCQ) and not in MDDlog.\nProof. Let S consist of unary predicates A,B and a ternary predicateP , and letQ be the S-query defined by (\u2020). A (GF,UCQ) query expressing Q was given in the body of the paper. It thus remains to show that Q cannot be expressed in MDDlog. We make use of the characterization of MDDlog queries in terms of k-colorings provided by Lemma 1.\nAssume that m,n are given. Let k = mn + 2n. Define Sinstances D1 and D0 as follows: \u2022 D1 has elements d1, . . . , dk, e and the atoms A(d1), B(dk),\nand P (di, e, di+1) for 1 \u2264 i < k.\n\u2022 D0 has elements d1, . . . , dk, and e1, . . . , ek and the following atoms: A(d1), B(dk), and P (di, ej , di+1) whenever 1 \u2264 i < k, 1 \u2264 j < k, and j 6= i.\nIt is readily checked that Q(D1) = 1 and Q(D0) = 0, as required. Let B0 be an m-coloring of D0. Define an m-coloring B1 of D1 by giving all elements of {d1, . . . , dk} exactly the same color as in B0. Choose i with n < i < k \u2212 n in such a way that for every sequence dl, . . . , dl+n with l > 1 and l + n < k there exists a sequence dl\u2032 , . . . , dl\u2032+n with l\u2032 > 1 and l\u2032+n < k such that the coloring of dl, . . . , dl+n coincides with the coloring of dl\u2032 , . . . , dl\u2032+n\nand i 6\u2208 {l\u2032, l\u2032 + n}. Such an i exists since k \u2265 mn + 2n. Now give e the color of ei. One can now easily construct, for every structure corresponding to an n-element subset of B1, a homomorphism to B0. o\nTheorem 7 (GF,UCQ) and (GNFO,UCQ) have the same expressive power as frontier-guarded DDlog.\nProof. We start by describing the translation from frontierguarded DDlog to (GNFO,UCQ). Let \u03a0 be a frontier-guarded DDlog query. It is easily verified that if we write out the implication symbol in a frontier-guarded DDlog rule using conjunction and negation, the resulting formula belongs to GNFO. Thus, we can take O to be the set of all non-goal rules of \u03a0, viewed as a GNFO sentence, and let q be the UCQ that consists of all bodies of rules whose conclusion contains the IDB relation goal. It is easy to check that the ontology-mediated query (S,O, q), where S is the schema consisting of all EDB relations, is equivalent to the frontier-guarded DDlog query q\u03a0.\nNext, we explain how to translate (GNFO, UCQ) to frontierguarded DDlog. Since every sentence of GF is equivalent to a sentence of GNFO [8], this also yields a translation of (GF,UCQ) to frontier-guarded DDlog. Recall that we used a specific normal form for UNFO sentences. For GNFO, we can use an analogous normal form. Specifically, we can assume that O is generated by the following grammar:\n\u03d5(x) ::= > | \u03b1(x) \u2227 \u00ac\u03d5(x) | \u2203y(\u03c81(x, y) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c8n(x, y))\nwhere each \u03c8i is either a relational atom or a formula generated by the same grammar whose free variables are among x,y. The \u201cguard\u201d \u03b1 is an atomic formula, possibly an equality, containing all variables in x.\nLet sub(O) be the set of all subformulas ofO. Let k be the maximum of the number of variables in O and the number of variables in q. For ` \u2265 0, we denote by cl`k(O) the set of all formulas \u03c7(x) with x = (x1, . . . , x`) of the form\n\u2203y(\u03c81(x, y) \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u03c8n(x, y))\nwith y = (y1, . . . , ym), m+ ` \u2264 k, and such that each \u03c8i is either an atomic formula that uses a symbol from q or is of the form \u03c7(z) for some \u03c7(z\u2032) \u2208 sub(O).\nA guarded `-type \u03c4 is a subset of cl`k(O) that contains at least one atomic relation (possibly equality) containing all variables x1, . . . , x`, and also contains the sentence O itself. We denote the set of all guarded `-types by type`(O). Note that, by definition, there are no guarded `-types for ` greater than the maximal arity of a relation from S.\nWe now proceed the same way as we did in the case of UNFO (but using guarded `-types instead of unary types). We introduce a fresh `-ary relation symbol P\u03c4 for each guarded `-type \u03c4 , and we denote by S\u2032 the schema that extends S with these additional relations. Diagrams, realizability, and implying a query are defined in the same way as before. The DDlog program is also constructed in essentially the same manner, except that the first rule of the program is replaced by the following:\u2228 \u03c4 a guarded `-type\nwithR(x) \u2208 \u03c4\nP\u03c4 (x)\u2190 R(x) for each relation R of arity ` \u2265 0.\nWe establish the correctness of the translation. That is, we show that, for every instance D and elements a = a1, . . . , an \u2208 adom(D), we have a \u2208 certq,O(D) if and only if a \u2208 q\u03a0(D).\n\u201cif\u201d. Assume that a 6\u2208 certq,O(D). Then there is (dom,D\u2032) \u2208 Mod(O) with D \u2286 D\u2032 such that a 6\u2208 q(D\u2032). For every fact R(b) of D, let \u00b5(b) be the unique guarded `-type (with ` = |b|) realized at a in D\u2032. Let D\u2032\u2032 be the instance that consists of the atoms in D and the atom P\u00b5(a)(b) for each fact R(b) in D. It can be checked that D\u2032\u2032 is a model of \u03a0. Since goal(a) /\u2208 D\u2032\u2032, a 6\u2208 q\u03a0(D).\n\u201conly if\u201d. Assume that a 6\u2208 q\u03a0(D) and let D\u2032 be a model of \u03a0 with D \u2286 D\u2032 that does not contain goal(a). We say that a tuple b is \u201clive\u201d in D if D contains R(b) for some relation symbol R. For each live tuple b of D, let \u00b5(b) be the unique guarded `-type (with ` = |b|) such that P\u00b5(b)(b) \u2208 D\u2032, and let (domb,Db) be a model ofO in which \u00b5(b) is realized at b (such a model must exist because otherwise the diagram P\u00b5(b)(x) would be non-realizable and \u03a0 would include a rule \u22a5 \u2190 P\u00b5(b)(x)). We may assume that for distinct live tuples b and c, domb and domc overlap only (possibly) on {b} \u2229 {c}. Let (dom\u2032\u2032,D\u2032\u2032) be obtained by first taking the union of (domb,Db) for all live tuples b of D, and then adding to it all facts of D. We show that\n(i) (dom\u2032\u2032,D\u2032\u2032) is a model of O and (ii) a 6\u2208 q(D\u2032\u2032). For all live tuples d of Db, let \u00b5(d) be the unique guarded `- type realized by d in (domb,Db), for all d \u2208 doma. Note that a tuple d may be live in Db for several different choices of b, but then the guarded `-type realized by d in each such (domb,Db) is the same: otherwise, there must be some atom R(y) that belongs to \u00b5(b), but not to \u00b5(b\u2032), and then the diagram P\u00b5(b\u2032)(x) \u2227R(y) is non-realizable and thus ruled out by \u03a0.\nClaim (i) is proved by establishing the following, by induction on the length of \u03d5:\n(\u2217) For all formulas \u03d5(x) \u2208 cl`k(O) and for each live `-tuple d of D\u2032\u2032, we have (dom\u2032\u2032,D\u2032\u2032) |= \u03d5[d] iff \u03d5 \u2208 \u00b5(d).\nWe omit the proofs of (\u2217) and of (ii), as they proceed similarly to the proofs of Theorem 1 and 6. o"}, {"heading": "B. PROOFS FOR SECTION 4", "text": "In Section B.1, we start by establishing a central technical result about MMSNP extended with constant symbols which allows us to lift key results from MMSNP sentences to coMMSNP queries (with free variables). Then in Section B.2, we provide the proofs for the results stated in Section 4 of the main paper."}, {"heading": "B.1 MMSNP with Constant Symbols", "text": "For readability, throughout this subsection, we will adopt a more convenient notation for schemas and structures involving constant symbols. If S is a schema and c a (possibly empty) set of constant symbols, then we will use Sc as a shorthand for S \u222a c. A Scstructure B will be given by a pair (dom(B), \u00b7B), where dom(B) is a finite, non-empty set and \u00b7B is a function assigning to each n-ary predicate in S an n-ary relation PB over dom(B) and to each constant symbol c \u2208 c an element cB \u2208 dom(B). We use adom(B) to denote the active domain of B, and we call B an active domain structure if dom(B) = adom(B).\nOur objective is to establish the following theorem, which lifts the containment and dichotomy results for MMSNP sentences [24] to coMMSNP queries:\nTheorem 20 coMMSNP has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. Containment of coMMSNP queries is decidable.\nWe prove Theorem 20 in several steps. We consider the language MMSNP with constant symbols (abbreviated MMSNPc), consisting of all sentences which can be obtained from MMSNP formulas by replacing each free variable by a constant symbol. The evaluation problem for MMSNPc consists in deciding whether an MMSNPc sentence with schema S and constant symbols c holds in a given Sc-structure B. The containment problem for MMSNPc is to decide for two MMSNPc sentences \u03a81,\u03a82 with relations S and constants symbols c, whether B |= \u03a81 implies B |= \u03a82 for all Scstructures B. We use \u03a81 \u2286 \u03a82 to denote containment.\nMMSNPc will serve as a bridge between coMMSNP queries (with free variables) and MMSNP sentences. More precisely, we will first show that evaluation of coMMSNP queries is polynomially equivalent to evaluation of MMSNPc sentences, and show a polynomial reduction from coMMSNP query containment to containment of MMSNPc sentences. Afterwards, we will move from MMSNPc sentences to MMSNP sentences, again showing polynomial equivalence of the evaluation problems and a polynomial reduction for containment.\nTo link coMMSNP queries and MMSNPc, it will actually prove more convenient to suppose that MMSNPc sentences are interpreted over active domain structures, whereas to relate MMSNPc with plain MMSNP, we will wish to work over arbitrary structures. Thus, as a preliminary step, we relate the two variants of the MMSNPc evaluation and containment problems.\nLemma 4 The evaluation problem for MMSNPc restricted to active domain structures is polynomially equivalent to the evaluation problem for MMSNPc (over general structures).\nProof. Let \u03a6 = \u2203X1 \u00b7 \u00b7 \u00b7 \u2203X`\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5 be an MMSNPc sentence over schema S and constants c, which is interpreted over active domain structures. Pick a fresh second-order variable Y and a fresh constant c not appearing in c. Let \u03d5\u2032 be the formula obtained from \u03d5 by replacing every conjunct \u03c81 \u2192 \u03c82 of \u03d5 by \u03c81 \u2192 (\u03c82 \u2228 Y (c)). Let \u03c7 be the conjunction of all formulas of the formR(x1, . . . , xk)\u2192 \u00acY (xi), whereR is a k-ary relation in S, and xi is one of the variables among x1, . . . , xk. Define a new MMSNPc sentence\n\u03a6\u2032 = \u2203X1 \u00b7 \u00b7 \u00b7 \u2203X`\u2203Y \u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm(\u03d5\u2032 \u2227 \u03c7)\nWe claim that the evaluation problem for \u03a6 over active domain structures is polynomially equivalent to the evaluation problem for \u03a6\u2032 over general structures. The first reduction is trivial since for every Sc-structure A such that dom(A) = adom(A), we have A |= \u03a6 if and only if A |= \u03a6\u2032. To see why, notice that \u03c7 ensures that Y is false everywhere on the active domain, so the additional disjuncts have no effect. For the second reduction, we remark that B |= \u03a6\u2032 for a general Sc-structure B if and only if dom(B) 6= adom(B) (since we can trivially satisfy \u03a6\u2032 by sending c to an element outside the active domain and including that element in Y ) or dom(B) = adom(B) and B |= \u03a6.\nIt remains to be shown that every evaluation problem for MMSNPc over general structures is polynomially equivalent to an evaluation problem for MMSNPc over active domain structures. Let \u03a6 be an MMSNPc sentence with schema S and constant symbols c, and select a fresh monadic second order variable Y , a fresh input relation Elem, and and a fresh constant symbol c. We define \u03a6\u2032 as the sentence over S\u222a{Elem}\u222a c\u222a{c} obtained from \u03a6 by: \u2022 replacing every conjunct \u03c81 \u2192 \u03c82 by \u03c81 \u2227 \u2227 t\u2208T Elem(t) \u2192\n\u03c82 \u2228 Y (c), where T is the set of terms appearing in \u03c81 \u2192 \u03c82, \u2022 adding a new conjunct Elem(x)\u2192 \u00acY (x), and\n\u2022 adding Y to the initial sequence of existentially quantified monadic second-order variables.\nWe claim that the evaluation problem for \u03a6 over general structures is polynomially equivalent to the evaluation problem for \u03a6\u2032 over active domain structures. For the first reduction, we have that for every Sc-structure B, B |= \u03a6 if and only if B\u2032 |= \u03a6\u2032, where B\u2032 extends B by setting ElemB \u2032 = dom(B) and letting cB \u2032\nbe any element in dom(B). For the other reduction, we have that for every S \u222a {Elem} \u222a c \u222a {c}-structure B with dom(B) = adom(B), B |= \u03a6\u2032 if and only if either ElemB 6= dom(B) or B\u2032 |= \u03a6, where B\u2032 is obtained by taking the S \u222a c-reduct of B. o\nLemma 5 Containment of MMSNPc over active domain structures is polynomially reducible to containment of MMSNPc (over arbitrary structures).\nProof. Consider MMSNPc sentences \u03a61,\u03a62 with schema S and constants c. We apply the construction from the first part of the proof of Lemma 4 to obtain MMNSPc sentences \u03a6\u20321 and \u03a6\u20322 with the property that B |= \u03a6\u2032i for a general Sc-structure B if and only if dom(B) 6= adom(B) or dom(B) = adom(B) and B |= \u03a6i (for i \u2208 {1, 2}). It is readily verified that \u03a61 \u2286 \u03a62 for the class of active domain structures if and only if \u03a6\u20321 \u2286 \u03a6\u20322. o\nBy the preceding lemmas, we can choose to work with active domain structures. It is then straightforward to relate the evaluation and containment problems for coMMSNP queries with the corresponding problems for MMSNPc sentences.\nLemma 6 The evaluation problem for coMMSNP is polynomially equivalent to the evaluation problem for MMSNPc. Containment of coMMSNP queries is polynomially reducible to containment of MMSNPc sentences.\nThe next step, and the core technical contribution of this subsection, is to relate the evaluation and containment of MMSNPc sentences to the analogous problems for MMSNP sentences. To simplify the technical constructions, it will prove convenient to work with forbidden pattern problems [38, 34, 12].\nWe extend forbidden patterns problems to handle constant symbols, by simply substituting S \u222a c-structures for S-structures in Definitions 1 and 2. We denote by FPPc the class of forbidden patterns problems thus defined, and use FPP to refer to the restriction to structures without constant symbols. Note that both FPPc and FPP define problems over structures, not instances (although this distinction is irrelevant in the absence of constant symbols).\nIt was shown in [38] that MMSNP sentences and FPP have the same expressive power. This result can be straightforwardly extended to handle constant symbols:\nLemma 7 MMSNPc and FPPc have the same expressive power (over structures with constant symbols).\nBy the previous lemma and the fact that FPP is a subset of FPPc, to show polynomial equivalence of MMSNPc and MMSNP it suffices to show that every problem in FPPc is polynomially equivalent to some problem in FPP. To formulate the reductions, we will require some additional notation and terminology, which we introduce next.\nLet S be a schema, c = {c1, . . . , cn} be a set of constant symbols, and P = {P1, . . . , Pn} be a set of unary predicates which do not appear in S. We will abbreviate S \u222a P to SP .\nWe define operations which allow us to transform SP -structures into Sc-structures, and vice-versa. With every SP -structure B with PBi 6= \u2205 for all 1 \u2264 i \u2264 n, we associate the Sc-structure Bc, called the collapse of B, by factorizing through the PBi . Specifically, let \u223c be the smallest equivalence relation such that whenever d, d\u2032 \u2208 PBi for some i, then d \u223c d\u2032. Then dom(Bc) is {[d] | d \u2208 \u2206B}, where [d] denotes the equivalence class of d w.r.t. \u223c. For convenience, when [d] = {d}, we will use d in place of [d]. Set cB c i = [d], for some d \u2208 PBi , and define RB c as follows: ([d], [e]) \u2208 RB c\nif and only if there exist d\u2032 \u2208 [d] and e\u2032 \u2208 [e] such that (d\u2032, e\u2032) \u2208 RB. Note that the mapping g : d 7\u2192 [d] defines an S-homomorphism from B to Bc, which we call the canonical homomorphism.\nFor a Sc-structure A, we define the SP -structure A\u0302 which interprets the predicates in S in the same way as A and interprets the predicates in P as follows: P A\u0302i = {cAi }. With every Sc-structure B, one can associate a finite set of finite SP -structures, Bac, called its anti-collapse, such that the following two properties hold:\n1. for all SP -structures A: B \u2192 Ac (and Ac is defined) if and only if there exists B\u2032 \u2208 Bac such that B\u2032 \u2192 A.\n2. for all Sc-structures A: B\u2192 A iff there exists B\u2032 \u2208 Bac such that B\u2032 \u2192 A\u0302.\nTo employ the anti-collapse Bac for the reduction of FPPc to FPP, we require some properties from the construction of Bac (cf. pages 43-45 of [1]). The domain \u2206B \u2032 of each B\u2032 \u2208 Bac consists of \u2206B \\ {cB1 , . . . , cBn } (the unnamed individuals in B) together with the union \u22c3 1\u2264i\u2264nDi of fresh non-empty (but possibly not mutually disjoint) sets D1, . . . , Dn with PB \u2032\ni = Di. Moreover, in Point 1 and Point 2 we have the following more detailed statement:\n(1a) if h : B \u2192 Ac (and Ac is defined), and g : A \u2192 Ac is the canonical homomorphism, then h\u2032 : B\u2032 \u2192 A can be chosen in such a way that h\u2032(d) \u2208 g\u22121(h(d)) for all unnamed individuals d in B and h\u2032(d) \u2208 g\u22121(cA c\ni ) for all d \u2208 Di. (1b) if h : B\u2032 \u2192 A, then h\u2032 : B \u2192 Ac can be defined such that\nh\u2032(cBi ) = c Ac i and h \u2032(d) = g(h(d)) if d is not named.\n(2b) if h : B\u2032 \u2192 A\u0302, then h\u2032 : B \u2192 A can be constructed in such a way that h\u2032(d) = h(d) for all unnamed d.\nIn what follows, we will be interested in colorings of SP - structures which respects the intuitive meaning of the predicates Pi. A C-coloring B[C] of a SP -structure B is said to be a uniform C-coloring of B if for every 1 \u2264 i \u2264 n, d, d\u2032 \u2208 PBi implies that d and d\u2032 have the same color in B[C]. Given a set G of C-colored SP -structures, we define Forbun(G) as the set of SP -structures A such that there exists a uniform C-coloring A[C] of A such that there exists no G \u2208 G with G\u2192 A[C].\nWe are now ready to present the reduction from FPPc to FPP. Suppose that we are given a FPPc problem defined by the set F of C-colored Sc-structures (where C = {T1, . . . , Tk}). We construct a set G which contains all uniform C-colored SP -structures G such that\n\u2022 There exists F \u2208 F and a member F\u2032 of the anti-collapse of the Sc-reduct of F such that G is the C-coloring of F\u2032 defined as follows: (\u2020) d \u2208 TGj iff d is unnamed in F and d \u2208 TFj or there exists 1 \u2264 i \u2264 n such that d \u2208 Di and cFi \u2208 T F j .\n(Note that we require that in the resulting structure TGj \u2229TGj\u2032 = \u2205 for j 6= j\u2032, otherwise G is not in G).\nIt is easy to see that this construction guarantees that every G \u2208 G is such that PGi 6= \u2205 for every 1 \u2264 i \u2264 n.\nWe let Gu = G \u222a U , where U is the set of all SP \u222a C-structures of the form {Pi(d), Pi(e), Tj(d), T`(e)} with 1 \u2264 i \u2264 n and 1 \u2264 j < ` \u2264 k.\nNotice that Forbun(G) = Forb(Gu).\nLemma 8 FPPc is polynomially equivalent to FPP. Specifically: \u2022 For all SP -structures A, A \u2208 Forb(Gu) iff Ac is undefined or\nAc \u2208 Forb(F); \u2022 For all Sc-structures A, A \u2208 Forb(F) iff A\u0302 \u2208 Forb(Gu).\nProof. First let A be a SP -structure such that A \u2208 Forb(Gu). Since Forb(Gu) = Forbun(G), we have A \u2208 Forbun(G), and so there exists a uniform C-colored expansion A[C] of A such that there exists no G \u2208 G with G \u2192 A[C]. Assume the collapse Ac is defined (i.e., PAi 6= \u2205 for 1 \u2264 i \u2264 n). We want to show Ac \u2208 Forb(F). By uniformity of A[C], we obtain a C-colored Sc-structure Ac[C] extending Ac by setting d \u2208 TA c[C] j iff d is unnamed and d \u2208 TA[C]j or d = c Ac i and P A[C] i \u2286 T A[C] j . Assume for a contradiction that h : F \u2192 Ac[C] for F \u2208 F . Then h is a homomorphism from the Sc-reduct Fr of F to the Sc-reduct Ac of Ac[C]. By (1a), we find F\u2032 \u2208 (Fr)ac and h\u2032 : F\u2032 \u2192 A such that h\u2032(d) \u2208 g\u22121(h(d)) for all unnamed individuals d in Fr and h\u2032(d) \u2208 g\u22121(cA c\ni ) for all d \u2208 Di. Let F\u2032[C] be the C-coloring of F\u2032 defined with (\u2020). To see that F\u2032[C] is well-defined, note that d \u2208 Di \u2229Dj implies that PF \u2032 i \u2229P F\u2032 j 6= \u2205, which yields P A i \u2229PAj 6= \u2205, hence cA c i = c Ac j . It follows that c Ac i and c Ac\nj have the same colour in Ac[C], and thus also in F, which ensures that each element in F\u2032 is assigned a unique colour by (\u2020). Now to obtain the desired contradiction, we show that h\u2032 is a SP \u222a C-homomorphism from F\u2032[C] to A[C]. Let d \u2208 dom(F\u2032) and d \u2208 TF \u2032[C] j . If d is unnamed in F, then d \u2208 TF \u2032[C]\nj implies that d \u2208 T F j . Hence h(d) \u2208 T Ac[C] j and\nh\u2032(d) \u2208 g\u22121(h(d)) \u2286 TA[C]j . If d \u2208 Di, then d \u2208 T F\u2032[C] j implies cFi \u2208 T F j , hence c Ac i \u2208 T Ac[C] j and P A[C] i \u2286 T A[C] j . From h\n\u2032(d) \u2208 g\u22121(cA c\ni ), we know that there exists a sequence A`1 , . . . , A`p of predicates from {P1, . . . , Pn} such that h\u2032(d) \u2208 AA[C]`1 ,A`p = Pi, and AA[C]`k \u2229 A A[C] `k+1\n6= \u2205 for every 1 \u2264 k \u2264 `p. By uniformity of A[C] and PA[C]i \u2286 T A[C] j , we obtain A A[C] `1\n\u2286 TA[C]j , hence h\u2032(d) \u2208 TA[C]j .\nConversely, if Ac is undefined, then A \u2208 Forb(Gu) since PGi 6= \u2205 for all G \u2208 G and 1 \u2264 i \u2264 n, and so any uniform C-coloring of A will avoid Gu. Assume now that Ac \u2208 Forb(F). There exists a C-colored expansion Ac[C] of Ac such that there exists no F \u2208 F with F\u2192 Ac[C]. We define a (uniform) C-colored expansion A[C] of A in the obvious way; let g : A\u2192 Ac be the canonical mapping and set TA[C]j = g \u22121(T Ac[C] j ), for 1 \u2264 j \u2264 k. Assume for a contradiction that G \u2192 A[C] for G \u2208 G. Then G is obtained from some F \u2208 F and some member F\u2032 of the anti-collapse of the Sc-reduct of F as described in (\u2020). Assume h : G \u2192 A[C]. Then h : F\u2032 \u2192 A and so, by (1b) there exists h\u2032 : Fr \u2192 Ac that can be defined such that h\u2032(cF r\ni ) = c Ac i and h \u2032(d) = g(h(d))\nif d is not named, where Fr is the Sc-reduct of F. We derive a contradiction by showing that h\u2032 a homomorphism from F to Ac[C]. First suppose that d \u2208 TFj , and d is unnamed in F. Then d \u2208 T G j , hence h(d) \u2208 TA[C]j . It follows from the definition of T A[C] j that h\u2032(d) = g(h(d)) \u2208 TA c[C]\nj . Next consider the case where c F i \u2208\nTFj . Then there must exist e such that e \u2208 T G j and e \u2208 PGi . It\nfollows that h(e) \u2208 TA[C]j and h(e) \u2208 P A[C] i . The definition of T A[C] j together with g(h(e)) = c Ac[C] i yields h \u2032(cFi ) = c Ac[C] i \u2208 T Ac[C] j . The second statement follows easily from the first, since for every Sc-structure A, we have A = (A\u0302)c. o\nLemma 9 Containment of FPPc is polynomially reducible to containment of FPP.\nProof. Consider Forb(F1) and Forb(F2), both over Sc. Let Gu,1 and Gu,2 be the corresponding FPPs over schema SP , which satisfy statements in Lemma 8. We claim that Forb(F1) \u2286 Forb(F2) iff Forb(Gu,1) \u2286 Forb(Gu,2).\nFor the first direction, suppose that Forb(F1) \u2286 Forb(F2). Let A be a \u03a3P -structure such that A \u2208 Forb(Gu,1). If Ac is undefined, then we immediately obtain A \u2208 Forb(Gu,2). Otherwise, we have Ac \u2208 Forb(F1), and hence Ac \u2208 Forb(F2) and A \u2208 Forb(Gu,2).\nFor the second direction, suppose that Forb(Gu,1) \u2286 Forb(Gu,2), and let B be a Sc-structure such that B \u2208 Forb(F1). Then applying the previous lemma, we have B\u0302 \u2208 Forb(Gu,1), hence B\u0302 \u2208 Forb(Gu,2). Again applying the lemma, we obtain B \u2208 Forb(F2). o\nBy combining in a straightforward manner Lemmas 4 to 9, we obtain Theorem 20."}, {"heading": "B.2 Proofs for Section 4", "text": "Theorem 8. (ALC,UCQ) has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. The same is true for (ALCHIU ,UCQ) and (UNFO,UCQ).\nProof. Easily obtained by combining Proposition 2 and Theorems 1, 3, 6, and 20. o\nTheorem 10. Query containment is decidable for the OBDA languages (ALC,UCQ), (ALCHIU ,UCQ), and (UNFO,UCQ).\nProof. Here again we straightforwardly combine Proposition 2 and Theorems 1, 3, 6, and 20 o\nTheorem 11. coGMSNP has the same expressive power as frontier-guarded DDlog and is strictly more expressive than coMMSNP.\nProof. The proof of the first part follows the lines of the proof of Proposition 2 and is omitted. It thus remains to show that coGMSNP is strictly more expressive than coMMSNP. Note first that it is at least as expressive: we can convert any MMSNP formula into an equivalent one satisfying conditions (i) and (ii) from the proof of Proposition 2, and clearly every such MMSNP formula is also a GMSNP formula. To see that coGMSNP is indeed strictly more expressive than coMMSNP, note that by Proposition 1, there is a (GF,UCQ) query q that is not expressible in MDDlog. By Proposition 2, q is not expressible in coMMSNP; by Theorem 7 and the first part of Theorem 11, q is expressible in coGMSNP. o\nProposition 3 GMSNP and MMSNP2 have the same expressive power.\nProof. For simplicity, we prove the result for sentences (no free variables) and without equality in the body of implications.\nWe start by proving that every MMSNP2 sentence is equivalent to a GMSNP sentence. Assume \u03a6 = \u2203X1 \u00b7 \u00b7 \u00b7 \u2203Xn\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5\nis a MMSNP2 sentence. Introduce for each Xi a monadic SOvariable X1i and, for every R \u2208 S of arity n, an n-ary SO-variable XRi . Now replace in\u03d5 everyXi(x) byX 1 i (x) and everyXi(R(x)) by XRi (x). The resulting formula is a GMSNP sentence that is equivalent to \u03a6.\nConversely, assume we are given a GMSNP sentence \u03a6 = \u2203X1 \u00b7 \u00b7 \u00b7 \u2203Xn\u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5. It is straightforward to show that \u03a6 is equivalent to a GMSNP sentence in which\n\u2022 each Xi(x) in the head of an implication is guarded by an input relation: for every Xi(x) in the head of an implication \u03c8 there exists an R \u2208 S such that R(y) is in the body of \u03c8 and x \u2286 y. (If this is not the case, one can introduce additional conjuncts R(y) in the body of implications).\n\u2022 \u03d5 is closed under identifying individual variables: if \u03c8\u2032 is the result of identifying variables in an implication \u03c8 of \u03d5, then \u03c8 is a conjunct of \u03d5 (module renaming of individual variables).\n\u2022 the individual variables used in distinct implications of \u03d5 are disjoint.\nIt follows that we may also assume that distinct occurrences of SOvariables Xi in \u03d5 determine distinct atoms Xi(xi). From now we assume that \u03a6 satisfies these conditions.\nFor the translation, we take for every atom A = Xi(x) in the head of an implication \u03c8 in \u03d5, a fresh second-order domain and fact variable XA. Moreover, we fix a guard RA(yA) with RA \u2208 S forA from the body of the (unique) implication in whichA occurs. Consider now an implication \u03c8 in \u03d5 of the form\nR1(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Rk(xk) \u2227Xk+1(xk+1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Xn(xn) \u2192 Xn+1(xn+1) \u2228 \u00b7 \u00b7 \u00b7 \u2228Xm(xm)\nFirst replace all atoms Aj = Xj(xj), n + 1 \u2264 j \u2264 m, by XAj (RAj (yAj )), where RAj (yAj ) is the guard for Aj selected above. Next consider every possible choice\nAk+1 = Xk+1(zk+1), . . . , An = Xn(zn)\nof atoms in the heads of implications in \u03d5 such that the componentwise mappings \u03c1l : xl \u2192 zl, k + 1 \u2264 l \u2264 n, are bijections between the sets of variables in xl and zl and replace everyXl(xl), k + 1 \u2264 l \u2264 n, by\nXAl(RAl(y \u2032 l))\nwhere y\u2032l is obtained from the guard RAl(yAl) associated with Al above by replacing each \u03c1l(x) by x and each individual variable that is not in the range of \u03c1l by some fresh individual variable. Let \u03c8\u2032 be the conjunction over all implications derived from \u03c8 in this manner, let \u03d5\u2032 be the conjunction of all of the \u03c8\u2032, and let \u03a6\u2032 be the resulting MMSNP2 sentence when existential quantification over non-monadic variables is replaced by existential quantification over all XA such that A an atom in a head of an implication of \u03d5. Note that \u03a6\u2032 contains all individual variables in \u03a6, but may also contain additional individual variables not in \u03a6.\nWe show that \u03a6 and \u03a6\u2032 are equivalent. Assume first that (adom(D),D) |= \u03a6\u2032. Take an assignment \u03c0 for the secondorder domain and fact variables of \u03a6\u2032 such that (adom(D),D) |=\u03c0 \u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm\u03d5\u2032. For every non-monadic second-order variable X of \u03a6, define \u03c0(X) as the union of all\n{\u03c1(x) | RA(\u03c1(yA)) \u2208 \u03c0(XA), \u03c1 injective variable assignment},\nsuch that A = X(x) appears in the head of some implication in \u03d5 and RA(yA) is the guard selected for A. We show that\n(adom(D),D) |=\u03c0 \u03a6. Assume for a contradiction that this is not the case. Take an implication \u03c8 in \u03d5 of the form\nR1(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Rk(xk) \u2227Xk+1(xk+1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Xn(xn) \u2192 Xn+1(xn+1) \u2228 \u00b7 \u00b7 \u00b7 \u2228Xm(xm)\nand let \u03c1 be an individual variable assignment such that (adom(D),D) 6|=\u03c0,\u03c1 \u03c8. We may assume that \u03c1 is injective. The following holds:\n1. for every 1 \u2264 i \u2264 k, we have Ri(\u03c0(xi)) \u2208 D. 2. for every k + 1 \u2264 i \u2264 n, there exists Ai = Xi(zi) in\nthe head of some implication of \u03d5 with RAi(z \u2032 i) the guard selected for Ai, and an injective variable assignment \u03c1i such that RAi(\u03c1i(z \u2032 i)) \u2208 \u03c0(XAi) and \u03c1i(zi) = \u03c1(xi) \u2208 \u03c0(Xi). 3. for no n + 1 \u2264 i \u2264 m does there exist Ai = Xi(zi) in the head of some implication of \u03d5 with RAi(z \u2032 i) the guard se-\nlected for Ai, and an injective variable assignment \u03c1\u2032 such that RAi(\u03c1\n\u2032(z\u2032i)) \u2208 \u03c0(XAi) and \u03c1\u2032(zi) = \u03c1(xi) \u2208 \u03c0(Xi). Consider the following sequences of atoms\nAk+1 = Xk+1(zk+1), . . . , An = Xn(zn)\nAn+1 = Xn+1(xn+1), . . . , Am = Xm(xm)\nIt follows from construction of \u03a6\u2032 that the formula \u03d5\u2032 contains the implication\n\u03b6 = R1(x1) \u2227 \u00b7 \u00b7 \u00b7 \u2227Rk(xk) \u2227 XAk+1(RAk+1(y \u2032 k+1)) \u2227 \u00b7 \u00b7 \u00b7 \u2227XAn(RAn(y \u2032 n))\n\u2192 XAn+1(RAn+1(yAn+1)) \u2228 \u00b7 \u00b7 \u00b7 \u2228XAm(RAm(yAm))\nwhere the y\u2032i are defined in the same way as earlier. Let \u00b5 be an individual variable assignment satisfying:\n\u2022 \u00b5(x) = \u03c1(x) for x in the image of \u03c1 \u2022 \u00b5(u) = \u03c1i(z) if u is the fresh variable introduced to replace z \u2208 z\u2032i\nNote that such an assignment must exist since every variable in \u03a6\u2032 is in the image of exactly one assignment among \u03c1 and the \u03c1i. It follows from the properties of \u00b5 and points 1 and 2 above that the body of the implication \u03b6 is satisfied under assignments \u03c0, \u00b5. From point 3, we can derive that none of the head atoms is satisfied under \u03c0, \u00b5. It follows that the implication \u03b6 is refuted, so (adom(D),D) 6|= \u03a6\u2032, and we have the desired contradiction.\nFor the other direction, assume that (adom(D),D) |= \u03a6. Take an assignment \u03c0 for the SO-variables of \u03a6 such that (adom(D),D) |=\u03c0 \u2200x1 \u00b7 \u00b7 \u00b7 \u2200xm \u03d5. Now define, for A = X(x) in the head of an implication of \u03d5 with selected guard RA(yA):\n\u03c0(XA) = {RA(\u03c1(yA)) \u2208 D | \u03c1(x) \u2208 \u03c0(X), \u03c1 variable assignment}\nIt can be verified that (adom(D),D) |= \u03a6\u2032. o"}, {"heading": "C. PROOFS FOR SECTION 5", "text": "Theorem 12 In each case, the following query languages are equally expressive:\n\u2022 (ALCU ,AQ), (SHIU ,AQ), unary simple MDDlog, and generalized coCSP with one constant symbol;\n\u2022 (ALC,AQ), (SHI,AQ), unary connected simple MDDlog, and generalized coCSPs with one constant symbol such that all templates are identical except for the interpretation of the constant symbol;\n\u2022 (ALCU ,BAQ), (SHIU ,BAQ), Boolean simple MDDlog, and generalized coCSP;\n\u2022 (ALC,BAQ), (SHI,BAQ), Boolean connected simple MDDlog, and coCSP.\nMoreover, given the ontology-mediated query or monadic datalog program, the correponding CSP template is of at most exponential size and can be constructed in time polynomial in the size of the template.\nProof. Recall that the equivalences between the OBDA languages and fragments of monadic disjunctive datalog have been proved already. Moreover, Point 1 has been proved in the paper. It thus remains to be proved that the following query languages are equally expressive:\n(a) (ALC,AQ) and generalized coCSPs with one constant symbol such that all templates are identical except for the interpretation of the constant symbol;\n(b) (ALC,BAQ) and coCSP; (c) (ALCU ,BAQ) and generalized coCSP. We use the notation from the proof of Point 1. In particular, BT denotes the canonical S-structure with domain T . For (a), assume S, O, and A(x) are given, where O is an ALC-ontology. Let T be the set of all types \u03c4 that are realizable for O and define\nF = {(BT , \u03c4) | \u03c4 \u2208 T,A 6\u2208 \u03c4}.\nOne can show that for every S-instance D and d \u2208 adom(D): (D, d) \u2192 (BT , \u03c4) for some (BT , \u03c4) \u2208 F iff d 6\u2208 qS,O,A(x)(D). Thus, the query defined by (S,O, A(x)) is equivalent to the query defined by F .\nConversely, assume that F is a finite set of S \u222a {c}-structures which coincide except for the interpretation of the constant symbol c, and let B be the S-reduct of these structures. Take for every d in the domain dom(B) of B a fresh concept name Ad, let A be another fresh concept name, and set\nO = {Ad v \u00acAd\u2032 | d 6= d\u2032} \u222a {Ad u \u2203R.Ad\u2032 v \u22a5 | R(d, d\u2032) 6\u2208 B, R \u2208 S} \u222a {Ad uB v \u22a5 | B(d) 6\u2208 B, B \u2208 S} \u222a\n{> v t d\u2208dom(B) Ad} \u222a { l\n(B,b)\u2208F\n\u00acAb v A}\nOne can show that for every S-instance D and d \u2208 adom(D), (D, d)\u2192 (B, b) for some (B, b) \u2208 F iff d 6\u2208 qS,O,A(x)(D). Thus (S,O, A(x)) expresses the same query as F .\nFor (b) assume that a query (S,O, \u2203x.A(x)) \u2208 (ALC,BAQ) is given. We assume w.l.o.g. thatO 6|= > v \u2203U.A because otherwise we have qQ(D) = 1 for all S-instances D, and so qQ is trivial. Let T be the set of all types \u03c4 \u2286 sub(O) that are realized in a model A of O with A 6|= \u2203x.A(x). Since O 6|= > v \u2203U.A, the set T is non-empty. One can show that for every S-instance D: D \u2192 BT iff QS,O,\u2203x.A(x)(D) = 0. Thus, the query defined by (S,O, \u2203x.A(x)) is equivalent to the query defined by BT .\nConversely, for a CSP template B over schema S, we construct an ontology-mediated query (S,O, q) as follows. Take for every d in the domain dom(B) of B a fresh concept name Ad, let A be\nanother fresh concept name, and set q = \u2203x.A(x) and\nO = {Ad uAd\u2032 v A | d 6= d\u2032} \u222a {Ad u \u2203R.Ad\u2032 v A | R(d, d\u2032) 6\u2208 B, R \u2208 S} \u222a {Ad uB v A | B(d) 6\u2208 B, B \u2208 S} \u222a {> v t\nd\u2208dom(B) Ad}\nThe query (S,O, \u2203x.A(x)) is equivalent to the query defined by the template B.\nThe proof of Point (c) is similar and left to the reader. o\nTheorem 14 Query containment in (SHIU ,AQ\u222aBQ) is in NEXPTIME. It is NEXPTIME-hard already for (ALC, AQ) and for (ALC,BAQ).\nProof. We provide the proof of the lower bound. The proof is by reduction of a NEXPTIME-hard 2n \u00d7 2n-tiling problem. An instance of this tiling problem is given by a natural number n > 0 and a triple (T, H, V ) with T a non-empty, finite set of tile types including an initial tile Tinit to be placed on the lower left corner, H \u2286 T\u00d7 T a horizontal matching relation, and V \u2286 T\u00d7 T a vertical matching relation. A solution for the 2n \u00d7 2n-tiling problem for (T, H, V ) is a map f : {0, . . . , 2n\u22121}\u00d7{0, . . . , 2n\u22121} \u2192 T such that f(0, 0) = Tinit, (f(i, j), f(i + 1, j)) \u2208 H for all i < 2n \u2212 1, and (f(i, j), f(i, j + 1)) \u2208 V for all j < 2n \u2212 1. It is NEXPTIME-complete to decide whether an instance of the 2n\u00d72ntiling problem has a solution.\nFor the reduction, let n > 0 and (T, H, V ) be an instance of the 2n \u00d7 2n-tiling problem with T = {T1, . . . , Tp}. We construct a schema S, twoALC-ontologiesO1 andO2, and a queryE(x) with E a unary relation symbol such that (T, H, V ) has a solution if and only if qS,O1,E(x) \u2286 qS,O2,E(x) if and only if qS,O1,\u2203x.E(x) \u2286 qS,O2,\u2203x.E(x).\nWe first define an ontology G (for grid) which encodes the 2n \u00d7 2n-grid. To define G, we use role names x and y to represent the 2n \u00d7 2n-grid and two binary counters X and Y for counting from 0 to 2n \u2212 1. The counters use concept names X0, . . . , Xn\u22121, X0, . . . , Xn\u22121 and Y0, . . . , Yn\u22121, Y 0, . . . , Y n\u22121 as their bits, respectively. G contains the inclusions\nXi v \u00acXi, Y i v \u00acYi,\nfor i = 0, . . . , n\u2212 1. Counters are relevant only if the concept\nDef = ( l\n0=1..n\u22121\n(Xi tXi)) u ( l\n0=1..n\u22121\n(Yi t Y i))\nis true. G contains the following well-known inclusions stating that the value of the counter X is incremented when going to xsuccessors (and Def is true) and the value of the counter Y is incremented when going to y-successors (and Def is true): for k = 0, . . . , n\u2212 1,\nDef u l\nj=0..k\u22121\nXj v Pk\nwhere\nPk = (Xk \u2192 \u2200x.(Def \u2192 Xk)) u (Xk \u2192 \u2200x.(Def \u2192 Xk))\nand\nDef u t j=0..k\u22121 Xj v Qk\nwhere\nQk = (Xk \u2192 \u2200x.(Def \u2192 Xk)) u (Xk \u2192 \u2200x.(Def \u2192 Xk))\nand similarly for Y and y. G also states that the value of the counter X does not change when going to y-successors and the value of the counter Y does not change when going to x-successors: for i = 0, . . . , n\u2212 1,\nDef uXi v \u2200y.(Def \u2192 Xi), Def uXi v \u2200y.(Def \u2192 Xi)\nand similarly for Y and x. In addition, G states that when the counter X is 2n \u2212 1, there is no x-successor (with Def) and if the counter Y is 2n \u2212 1, there is no y-successor (with Def):\nDef uX0 u \u00b7 \u00b7 \u00b7 uXn\u22121 v \u2200x.(Def \u2192 \u22a5)\nand\nDef u Y0 u \u00b7 \u00b7 \u00b7 u Yn\u22121 v \u2200y.(Def \u2192 \u22a5)\nThis finishes the definition of G. Define the schema\nSG = {x, y,X0, . . . , Xn\u22121, X0, . . . , Xn\u22121} \u222a {Y0, . . . , Yn\u22121, Y 0, . . . , Y n\u22121}.\nWe set O2 = G \u222a {E v E} (the latter inclusion merely serves to ensure E is part of the schema of O2).\nWe now extend G to another ontology Gt. In addition to the inclusions in G, Gt states that Tinit holds at (0, 0):\n\u00acX0 u \u00b7 \u00b7 \u00b7 u \u00acXn\u22121 u \u00acY0 u \u00b7 \u00b7 \u00b7 u \u00acYn\u22121 v Tinit\nand that the tiling is complete on Def:\nDef v t i=1..p Ti,\nNext, Gt states that if a tiling condition is violated, then a concept name E is true. For all i 6= j:\nTi u Tj v E,\nfor all (i, j) 6\u2208 H:\nTi u \u2203x.Tj v E,\nand for all (i, j) 6\u2208 V :\nTi u \u2203y.Tj v E.\nFinally, E is propagated along x and y:\n\u2203x.E v E, \u2203y.E v E\nWe set O1 = Gt and show:\nClaim. The following conditions are equivalent:\n1. the 2n \u00d7 2n-tiling problem for (T, H, V ) has no solution; 2. qSG ,O1,E(x) is not contained in qSG ,O2,E(x);\n3. qSG ,O1,\u2203x.E(x) is not contained in qSG ,O2,\u2203x.E(x). Assume first that (T, H, V ) admits no 2n\u00d72n-tiling. Define a SGinstance DG as follows. We regard the pairs (i, j) with i \u2264 2n \u2212 1 and j \u2264 2n \u2212 1 as constants and let \u2022 x((i, j), (i+ 1, j)) \u2208 DG for i < 2n \u2212 1 and \u2022 y((i, j), (i, j + 1)) \u2208 DG for j < 2n \u2212 1.\nWe also set\n\u2022 Xk(i, j) \u2208 DG if the kth bit of i is 1, \u2022 Xk(i, j) \u2208 DG if the kth bit of i is 0,\n\u2022 Yk(i, j) \u2208 DG if the kth bit of j is 1, and\n\u2022 Y k(i, j) \u2208 DG if the kth bit of j is 0.\nThen\n\u2022 qSG ,O2,E(x)(DG) = \u2205 and\n\u2022 qSG ,O2,\u2203x.E(x)(DG) = 0\nsince DG counts correctly, and hence is satisfiable w.r.t. O2. However, since (T, H, V ) admits no 2n \u00d7 2n-tiling, it follows that\n\u2022 (0, 0) \u2208 qSG ,O1,E(x)(DG);\n\u2022 qSG ,O1,\u2203x.E(x)(DG) = 1.\nWe have proved Points 2 and 3.\nConversely, assume that (T, H, V ) admits a 2n\u00d72n-tiling given by f : {0, . . . , 2n \u2212 1} \u00d7 {0, . . . , 2n \u2212 1} \u2192 T. We show that qSG ,O1,\u2203x.E(x)(D) = 0 for all SG-instances D which are satisfiable w.r.t. O2. Then Points 2 and 3 are refuted, as required.\nAssume D is satisfiable w.r.t.O2. We define a model (dom,D\u2032) of O1 with D\u2032 \u2287 D as follows: the domain of D\u2032 coincides with adom(D). Symbols from SG are defined in D\u2032 in exactly the same way as in D. To define the facts involving tile types Tk associate with every d \u2208 adom(D) such that Def applies to d, the uniquely determined pair v(d) = (i, j) given to the values of the counters X and Y by Def. Then set Tk(d) \u2208 D\u2032 iff f(v(d)) = Tk. Note that D\u2032 contains no facts involving E. It is readily checked that the resulting structure is a model of O1. o\nProposition 4. If Q = (S,O, q) is an ontology-mediated query with O formulated in equality-free FO and q a UCQ, then qQ is preserved by homomorphisms. Consequently, it follows from [43] that if qQ is FO-rewritable, then qQ is rewritable into a UCQ (thus into datalog).\nProof. Let h : D1 \u2192 D2 be a homomorphism, and a a tuple from adom(D1) such that a \u2208 qQ(D1). Furthermore, suppose for the sake of contradiction that h(a) 6\u2208 qQ(D2). Then there is a finite relational structure (dom2,D\u20322) |= O such that D2 \u2286 D\u20322 and h(a) 6\u2208 q(D\u20322). Let (dom1,D\u20321) be the inverse image of (dom2,D\u20322) under h. More precisely, dom1 = adom(D1)\u222a(dom2\\adom(D2)), and D\u20321 contains all facts whose h\u0302-image is a fact of D\u20322 where h\u0302 is the map that extends h by sending every element of adom(D\u20322) \\ adom(D2) to itself. Clearly, D1 \u2286 D\u20321. Furthermore, a 6\u2208 q(D\u20321) because h\u0302 : D\u20321 \u2192 D\u20322 is a homomorphism and q is preserved by homomorphisms. To obtain a contradiction against a \u2208 qQ(D1), it therefore only remains to show that (dom1,D\u20321) |= O. It is known that equality-free first-order sentences are preserved by passing from a structure to its quotient under an equivalence relation that is a congruence. By construction, the kernel of the map h\u0302 is a congruence relation on the structure (dom1,D\u20321) and its quotient is isomorphic to (dom2,D\u20322).\no\nThe following lemma reduces the problem of deciding FOrewritability from generalized CSP with constants to generalized CSP without constants.\nLemma 10 Let F be a finite set of S\u222a c-structures. The following conditions are equivalent:\n1. coCSP(F) is FO-definable;\n2. coCSP(Fc) is FO-definable;\nProof. If coCSP(Fc) is defined by a first-order sentence \u03d5, then replacing every subformula of the form Pi(x) in \u03d5 by x = ci yields a first-order sentence defining coCSP(F).\nFor the converse, we make use a characterization of FOdefinability of generalized coCSPs with constants using finite obstruction sets. Let F be a finite set of S \u222a c-structures. A set D of S \u222a c-structures is an obstruction set for CSP(F) if for all S \u222a cstructures D the following conditions are equivalent:\n\u2022 there exists B \u2208 F such that D\u2192 B; \u2022 there does not exist A \u2208 D such that A\u2192 D.\nIt is known that, for any finite set of structures F , coCSP(F) is FO-definable if and only if F has a finite obstruction set. This was shown in [2] for structures without constant symbols, and follows easily from results in [43] even for the case of structures with constants. Finally, it was shown in Proposition A.2 (1) in [1] that if coCSP(F) has a finite obstruction set, then so does coCSP(Fc).\no\nThe following lemma reduces the problem of deciding FOdefinability from generalized CSP without constants to CSP without constants.\nLemma 11 Let F be a finite set of S \u222a c-structures. \u2022 If coCSP(B) is FO-definable for all B \u2208 F , then coCSP(F) is\nFO-definable.\n\u2022 Conversely, if all B \u2208 F are mutually homomorphically incomparable, and coCSP(F) is FO-definable, then each coCSP(B), B \u2208 F , is FO-definable.\nProof. For Point 1 choose for every B \u2208 F a FO-sentence \u03d5B such that (dom,D) |= \u03d5B iff D 6\u2192 B for all S-instances D. Let \u03d5 be the conjunction over all \u03d5B with B \u2208 F . Then (dom,D) |= \u03d5 iff D 6\u2192 B for any B \u2208 F holds for all S-instances D, as required.\nTo prove the other direction we require the notion of a critical obstruction: a S-structure A is called a critical obstruction for CSP(G) iff A 6\u2192 B for any B \u2208 G but for any proper substructure A\u2032 of A there exists a B \u2208 F such that A\u2032 \u2192 B. It is readily checked that coCSP(G) has a finite obstruction set iff there only exist finitely many critical obstructions for CSP(G).\nFor Point 2 assume that all B \u2208 F are mutually homomorphically incomparable and that coCSP(F) is FO-definable. Assume for a proof by contradiction that coCSP(B0) is not FO-definable for some B0 \u2208 F . Then the set C of critical obstructions for CSP(B0) is infinite. Let B\u20320 be a substructure of B\u20320 such that no proper substructure of B0 can be homomorphically mapped to any B \u2208 F \\ {B0}. It is readily checked that the set C\u2032 of disjoint unions A \u222aB\u20320, A \u2208 C, are critical obstructions for CSP(F). Thus coCSP(F) is not FO-definable and we have derived a contradiction. o\nNext, we move on the datalog-definability.\nLemma 12 Let F be a finite set of S \u222a c-structures. 1. If coCSP(Bc) is datalog-definable for all B \u2208 F , then\ncoCSP(F) is datalog-definable. 2. Conversely, if all B \u2208 F are mutually homomorphically in-\ncomparable, and coCSP(F) is datalog-definable, then each coCSP(Bc), B \u2208 F , is datalog-definable.\nProof. (1) If each coCSP(Bc) is datalog-definable, then, since datalog is closed under conjunction, we also have that coCSP(Fc) is datalog-definable. Let \u03a0 be a datalog program that defines\ncoCSP(Fc). A datalog program \u03a0\u2032 defining coCSP(F) may be obtained from \u03a0 by replacing every Pi(x) with x = ci.\nFor (2), we make use of a characterization of datalog-definability in terms of obstruction sets of bounded treewidth. Recall from the proof of Lemma 10 the notion of an obstruction set for a set of structures. Suppose that coCSP(F) is definable by a datalog program whose rules contain at most k variables. Then F has an obstruction set of treewidth k, namely, the set of all canonical structures of non-recursive datalog programs obtained by unfolding the given datalog program finitely many times (a standard argument).\nWe claim that, in fact, each B \u2208 F has an obstruction set of treewidth k. We prove this claim by contraposition: if some B \u2208 F does not have an obstruction set of treewidth at most k, there is a structure A such that A 6\u2192 B, while, at the same time, B\u2032 \u2192 A implies B\u2032 \u2192 B for all structures B\u2032 of treewidth at most k. Now, take A\u2032 to be the disjoint union of A and B. Then we have that A 6\u2192 F (here, we are using also the fact that F consists of homomorphically incomparable structures). At the same time, B\u2032 \u2192 A implies B\u2032 \u2192 B for all structures B\u2032 of treewidth at most k. Therefore, coCSP(F) has no obstruction set of bounded treewidth, a contradiction.\nSo far, we have shown that, for each B \u2208 F , coCSP(B) has an obstruction set of bounded tree width. By Proposition A.2 (1) in [1], we have that, for all structures A with constant symbols, if coCSP(A) has an obstruction set of bounded treewidth, then coCSP(Ac) has an obstruction set of bounded treewidth too (although it is not explicitly stated, it can easily be verified that the relevant construction used there preserves bounded treewidth). Thus, we obtain that, for each B \u2208 F , coCSP(Bc) has an obstruction set of bounded width. It was shown in [24] that, for any structure A without constant symbols, coCSP(A) is datalog-definable if and only if A has an obstruction set of bounded tree-width. Therefore we have that, for each B \u2208 F , coCSP(Bc) is datalog-definable.\no\nThe above lemmas, together, establish Proposition 5. We now proceed with the proof of Theorem 16. We now give the lower bound proofs for Theorem 16.\nLemma 13 It is NEXPTIME-hard to decide FO-rewritability of queries in (ALC,AQ) and of queries in (ALC,BAQ).\nProof. We prove the lower bound and employ for the reduction the same tiling problem as in the lower bound proof of Theorem 14. We also employ the ontologies constructed in the proof of Theorem 14.\nFor the reduction, let n > 0 and (T, H, V ) be an instance of the 2n \u00d7 2n-tiling problem with T = {T1, . . . , Tp}. We construct a schema S, anALC-ontologyO and a queryA(x) such that (T, H, V ) has a solution if and only if qS,O,A(x) is FO-rewritable if and only if qS,O,\u2203x.A(x) is FO-rewritable.\nWe consider the ontology G, its extension Gt, and the schema SG from the proof of Theorem 14. To define O, we take a fresh role name S and two concept names A and F and set"}, {"heading": "O = Gt \u222a {\u2203S.E v E,E u F v A}", "text": "and S = SG \u222a {S, F}.\nClaim. The following conditions are equivalent:\n\u2022 (T, H, V ) admits no 2n \u00d7 2n-tiling;\n\u2022 qS,O,A(x) is not FO-rewritable;\n\u2022 qS,O,\u2203x.A(x) is not FO-rewritable.\nAssume that (T, H, V ) admits no 2n \u00d7 2n-tiling. qS,O,A(x) is not FO-rewritable iff there does not exist a finite set D of S \u222a {c}structures (an obstruction set) such that the following conditions are equivalent for every S-instance D and d \u2208 adom(D): 1. d \u2208 qS,O,A(x)(D). 2. there exists A \u2208 D such that (A, a)\u2192 (D, d). We show that no finite obstruction set exists. To this end, we define S-instances Dm as the union of DG and the facts\nF (a0), S(a0, a1), . . . , S(am, (0, 0)).\nIt is readily checked that\n\u2022 a0 \u2208 qS,O,A(x)(Dm) for all m > 0; \u2022 a0 6\u2208 qS,O,A(x)(D\u2032m), where D\u2032m results from Dm by removing\nsome fact (ak, ak+1) from Dm.\nIt follows immediately that no finite obstruction set exists. The argument for qS,O,\u2203x.A(x) is similar.\nConversely, assume that (T, H, V ) has a 2n \u00d7 2n-tiling given by f : {0, . . . , 2n \u2212 1} \u00d7 {0, . . . , 2n \u2212 1} \u2192 T. We have to show that there exists an FO-formula \u03d5(x) over S such that for all S-instances D and d \u2208 adom(D), (adom(D),D) |= \u03d5[d] iff d \u2208 qS,O,A(x)(D).\nNote that one can easily construct a first-order sentence \u03d5G over SG such that, for all SG-instances D, the following are equivalent:\n\u2022 D is not satisfiable w.r.t. G; \u2022 (adom,D) |= \u03d5G .\nWe fix such a sentence \u03d5G and show that the following are equivalent for every S-instance D:\n\u2022 (adom(D),D) |= \u03d5G ; \u2022 d \u2208 qS,O,A(x)(D).\nThe direction from Point 1 to Point 2 is trivial. Conversely, assume that (adom(D),D) 6|= \u03d5G . Then D is satisfiable w.r.t. G. We define a model (dom,D\u2032) ofO with D\u2032 \u2287 D as follows. The domain of D\u2032 coincides with adom(D). Symbols from S are defined in D\u2032 in exactly the same way as in D. To define the facts involving tile types Tk, associate with every d \u2208 adom(D) such that Def applies to d, the uniquely determined pair v(d) = (i, j) given to the values of the counters X and Y by Def. Then set Tk(d) \u2208 D\u2032 iff f(v(d)) = Tk. Note that D\u2032 contains no facts involving E or A. It is readily checked that the resulting structure is a model of O, as required. o\nLemma 14 It is NEXPTIME-hard to decide datalog-rewritability of queries in (ALC,AQ) and of queries in (ALC,BAQ).\nProof. The proof is based on a modification of the proof of Lemma 13. For the reduction, let n > 0 and (T, H, V ) be an instance of the 2n \u00d7 2n-tiling problem with T = {T1, . . . , Tp}. We construct a schema S, anALC-ontologyO\u2032 and a queryA(x) such that (T, H, V ) has a solution if and only if qS,O\u2032,A(x) is datalogrewritable if and only if qS,O\u2032,\u2203x.A(x) is datalog-rewritable.\nWe consider the ontology G, its extension Gt, and the schema SG from the proof of Theorem 14. To define O\u2032 we take fresh role names S and H and fresh concept names P1, P2, P3 and encode the 3-colorability problem as follows:\nO\u2032 = Gt \u222a {\u2203S.E v E,\u2203H.A v A} \u222a {E v P1 t P2 t P3} \u222a {Pi u Pj v A | 1 \u2264 i < j \u2264 3} \u222a {Pi u \u2203H.Pi v A | 1 \u2264 i \u2264 3}\nand S = SG \u222a {S,H}.\nClaim. The following conditions are equivalent:\n\u2022 (T, H, V ) admits no 2n \u00d7 2n-tiling; \u2022 qS,O\u2032,A(x) is not datalog-rewritable; \u2022 qS,O\u2032,\u2203x.A(x) is not datalog-rewritable.\nAssume that (T, H, V ) admits no 2n \u00d7 2n-tiling. For any connected undirected graphG, we identify some v inGwith (0, 0) and define a S-instance D as the union of DG and the facts S(d, d\u2032) for all d, d\u2032 in G and H(d, d\u2032) for every edge {d, d\u2032} in G. It is readily checked that\n\u2022 (0, 0) \u2208 qS,O\u2032,A(x)(D) iff G is not 3-colorable; \u2022 qS,O\u2032,\u2203x.A(x)(D) = 1 iff G is not 3-colorable.\nIt follows immediately that neither qS,O\u2032,A(x) nor qS,O\u2032,\u2203x.A(x) are datalog-rewritable.\nConversely, if (T, H, V ) admits a 2n \u00d7 2n-tiling then one can show datalog-rewritability using exactly the same argument as in the proof of Lemma 13. o\nWe now prove the undecidability results forALCF . In [10, 36], alternative definitions of query containment and FO-rewritability are employed which consider only instances that are satisfiable w.r.t. the ontologies involved. We say that (S,O1, q1) is contained in (S,O2, q2) w.r.t. consistent instances if q(S,O1,q1)(D) \u2286 q(S,O2,q2)(D) for all S-instance D such that D is satisfiable w.r.t. O1. Similarly, a query (S,O, q) is FO-rewritable w.r.t consistent instances if there exists an FO-query q\u2032 such that q\u2032(D) = q(S,O,q)(D) for all S-instance D that are satisfiable w.r.t. O. Undecidability of query containment w.r.t. consistent instances and of FO-rewritability w.r.t. consistent instances were proven respectively in [10] and [36]. Here we show how the proofs can be modified to work for query containment, FO-rewritability, and datalog rewritability as defined in this paper.\nTheorem 21 Query containment, FO-rewritability, and datalogrewritability are all undecidable for queries in (ALCF ,AQ) and queries in (ALCF ,BAQ).\nProof. The proof is by reduction of the following finite rectangle tiling problem. An instance of the finite rectangle tiling problem is given by a triple P = (T, H, V ) with\n\u2022 T = {T1, . . . , Tp} a non-empty, finite set of tile types including an initial tile Tinit to be placed on the lower left corner, a final tile Tfinal to be placed on the upper right corner, and sets U \u2286 T and R \u2286 T of tile types to be placed on the upper and right borders respectively, satisfying U \u2229R = {Tfinal}; \u2022 H \u2286 T\u00d7 T a horizontal matching relation; and \u2022 V \u2286 T\u00d7 T a vertical matching relation.\nA tiling for (T, H, V ) is a map f : {0, . . . , n}\u00d7 {0, . . . ,m} \u2192 T such that n,m \u2265 0, \u2022 f(0, 0) = Tinit, \u2022 f(n,m) = Tfinal, \u2022 f(n, j) \u2208 R for all 0 \u2264 j \u2264 m; \u2022 f(j, i) 6\u2208 R for all j < n and 0 \u2264 i \u2264 m; \u2022 f(i,m) \u2208 U for all 0 \u2264 i \u2264 n; \u2022 f(i, j) 6\u2208 U for all 0 \u2264 i \u2264 n and 1 \u2264 j < m. \u2022 (f(i, j), f(i+ 1, j)) \u2208 H for all 0 \u2264 i < n, and\n\u2022 (f(i, j), f(i, j + 1)) \u2208 v for all 0 \u2264 i < m. Thus, we can assume that H , V , U, and R are such that:\n\u2022 if (Ti, Tj) \u2208 H , then Ti \u2208 U if and only if Tj \u2208 U; \u2022 if Ti \u2208 U, then there exists no Tj with (Ti, Tj) \u2208 V or\n(Tj , Ti) \u2208 V ; \u2022 if (Ti, Tj) \u2208 V , then Ti \u2208 R if and only if Tj \u2208 R; \u2022 if Ti \u2208 R, then there exists no Tj with (Ti, Tj) \u2208 H or\n(Tj , Ti) \u2208 H . It is undecidable whether an instance P of the finite rectangle tiling problem has a tiling.\nFix a particular P = (T, H, V ). For the data schema, we use S = {T1, . . . , Tp, x, y, x\u2212, y\u2212}, where T1, . . . , Tp are treated as concept names, and x, y, x\u2212, and y\u2212 are role names. We use x and y to specify horizontal and vertical adjacency of points in the rectangle, and the role names x\u2212 and y\u2212 to simulate the inverses of x and y (note that since x\u2212 and y\u2212 are regular role names, they need not be interpreted as the inverses of x and y). We construct an ALCF -ontology OP which asserts functionality of x, y, x\u2212, y\u2212 and contains inclusions using additional concept names U,R, Y, Ix, Iy, C, Zc,1, Zc,2, Zx,1, Zx,2, Zy,1. The concept names U and R are used to mark the upper and right border of the rectangle, Y is used to mark points in the rectangle, and the remaining concept names are used for technical purposes explained below. In the following, for e \u2208 {c, x, y}, we let Be range over all Boolean combinations of the concept names Ze,1 and Ze,2, i.e., over all concepts L1 u L2 where Li is a literal over Ze,i, for i \u2208 {1, 2}. The ontology OP contains the following concept inclusions, where (Ti, Tj) \u2208 H and (Ti, T`) \u2208 V :\nTfinal v Y u U uR \u2203x.(U u Y u Tj) u Ix u Ti v U u Y \u2203y.(R u Y u T`) u Iy u Ti v R u Y\n\u2203x.(Tj u Y u \u2203y.Y ) u\u2203y.(T` u Y u \u2203x.Y )\nuIx u Iy u C u Ti v Y \u2203x.\u2203y.Bc u \u2203y.\u2203x.Bc v C Bx u \u2203x.\u2203x\u2212.Bx v Ix By u \u2203y.\u2203y\u2212.By v Iy\nTi v \u2200y.\u22a5 Tj v \u2200x.\u22a5 U v \u2200x.U R v \u2200y.R\nt 1\u2264s<t\u2264p Ts u Tt v \u22a5\nwhere Ti \u2208 U and Tj \u2208 R. The first four inclusions propagate the concept Y downwards and leftwards starting from a point marked with the final tile Tfinal. Note that these inclusions enforce the horizontal and vertical matching conditions. The concept inclusion with right-hand side C serves to enforce confluence, i.e., C is entailed at a constant a if there is a constant b that is both an x-y-successor and a y-x-successor of a. This is so because, intuitively, Bc is universally quantified: if confluence fails, then we can interpret Zc,1 and Zc,2 so that neither of the two conjuncts on the left-hand side of the inclusion for C is satisfied. In a similar manner, the inclusion for Ix (resp. Iy) is used to ensure that x\u2212 (resp. y\u2212) act as the inverse of x (resp. y) at all points in the rectangle.\nThe following property can be obtained by a minor modification of Lemma 30 in [3]:\nLemma 15 P admits a tiling if and only if there is a Sinstance D which is consistent with OP and such that qS,OP,Tinit(x)\u2227Y (x)(D) 6= \u2205.\nLet \u03d5P be the first-order translation of the conjunction of all Ti v \u2200y.\u22a5, Ti \u2208 U, Tj v \u2200x.\u22a5, Tj \u2208 R, and of t\n1\u2264s<t\u2264p Ts u\nTt v \u22a5. The following is readily checked:\nClaim. For all S-instances D, (adom(D),D) |= \u03d5P iff D is satisfiable w.r.t. OP.\nWe now prove undecidability of query containment. Let E be a fresh concept name and let\nO2 = OP \u222a {E v E}, O1 = OP \u222a {Y u Tinit v E}\nNow one can prove that the following conditions are equivalent:\n\u2022 P admits a tiling; \u2022 (S,O1, E(x)) is not contained in (S,O2, E(x)); \u2022 (S,O1, \u2203x.E(x)) is not contained in (S,O2,\u2203x.E(x))\nAssume first that P admits a tiling. Then by Lemma 15, there is a S-instance D which is consistent with OP and such that qS,OP,Tinit(x)\u2227Y (x)(D) 6= \u2205. It follows immediately that qS,O1,E(x)(D) 6= \u2205 and qS,O1,\u2203x.E(x)(D) = 1. On the other hand, since D is consistent with O2, and E appears only trivially in O2, we have qS,O2,E(x)(D) = \u2205 and qS,O2,\u2203x.E(x)(D) = 0.\nNext suppose that P does not admit a tiling, and let D be an S-instance which is consistent with O1. By Lemma 15, qS,OP,Tinit(x)\u2227Y (x)(D) = \u2205, and hence qS,O1,\u2203x.E(x)(D) = 0. The desired containments trivially follow.\nTo prove undecidability of FO-rewritability, we expand O1 to a new ontology O3. To define O3 we take a fresh role name S and two concept names A and F and set"}, {"heading": "O3 = O1 \u222a {\u2203S.E v E,E u F v A}", "text": "and S3 = S \u222a {S, F}.\nClaim. The following conditions are equivalent:\n\u2022 P admits a tiling; \u2022 qS3,O3,A(x) is not FO-rewritable; \u2022 qS3,O3,\u2203x.A(x) is not FO-rewritable.\nAssume first that P admits a tiling. By Lemma 15, we can find an S-instance DP which is consistent with OP and b \u2208 adom(DP) such that b \u2208 qS,OP,Tinit(x)\u2227Y (x)(DP), and hence b \u2208 qS,O1,E(x)(DP). We can use essentially the same argument as in Lemma 13 to show that qS,O1,E(x) and qS,O1,E(x) are not FOrewritable. Specifically, we construct S-instances Dm by taking the union of DP and the facts\nF (a0), S(a0, a1), . . . , S(am, b).\nIt is readily checked that\n\u2022 a0 \u2208 qS3,O3,A(x)(Dm) for all m > 0; \u2022 a0 6\u2208 qS3,O3,A(x)(D \u2032 m), where D\u2032m results from Dm by remov-\ning some fact (ak, ak+1) from Dm.\nIt follows that no finite obstruction set exists, and hence that qS,O1,A(x) is not FO-rewritable. We can proceed similarly for qS,O1,\u2203x.A(x).\nAssume now that P does not admit a tiling. Then for every S-instance D, D is satisfiable w.r.t. OP if and only if\nqS,O3,\u2203x.A(x)(D) = 0. Thus, the query defined by \u00ac\u03d5P is equivalent to qS,O3,\u2203x.A(x), and the query defined by (x = x) \u2227 \u00ac\u03d5P is equivalent to qS,O3,A(x).\nTo prove undecidability of datalog-rewritability, we expand O1 to a new ontology O4. To define O4, we take fresh role names S and H and fresh concept names P1, P2, P3 and encode the 3- colorability problem as follows:\nO4 = G1 \u222a {\u2203S.E v E,\u2203H.A v A} \u222a {E v P1 t P2 t P3} \u222a {Pi u Pj v A | 1 \u2264 i < j \u2264 3} \u222a {Pi u \u2203H.Pi v A | 1 \u2264 i \u2264 3}\nWe use the schema S4 = S \u222a {S,H}.\nClaim. The following conditions are equivalent:\n\u2022 P admits a tiling; \u2022 qS4,O4,A(x) is not datalog-rewritable; \u2022 qS4,O4,\u2203x.A(x) is not datalog-rewritable.\nFirst suppose that P admits a tiling. We have seen previously that this implies the existence of an S-instance DP which is consistent with OP and contains b \u2208 adom(DP) such that b \u2208 qS,O1,E(x)(DP). We proceed similarly to Lemma 14. Given a connected undirected graph G, we define an S-instance D as the union of DP and the facts S(d, d\u2032) for all d, d\u2032 in G and H(d, d\u2032) for every edge {d, d\u2032} in G. It is readily checked that \u2022 b \u2208 qS4,O4,A(x) iff G is not 3-colorable; \u2022 qS4,O4,\u2203x.A(x)(D) = 1 iff G is not 3-colorable.\nIt follows directly that neither qS,O\u2032,A(x) nor qS,O\u2032,\u2203x.A(x) are datalog-rewritable.\nNext suppose that P does not admit a tiling. Then for every S-instance D, we have that D is satisfiable w.r.t. OP if and only if qS,O4,\u2203x.A(x)(D) = 0. We can then simply reuse the FOrewritings \u00ac\u03d5P and (x = x) \u2227 \u00ac\u03d5P from above, since these can be equivalently expressed as datalog queries. o"}], "references": [{"title": "Characterizing schema mappings via data examples", "author": ["B. Alexe", "B. ten Cate", "P.G. Kolaitis", "W.C. Tan"], "venue": "ACM Trans. Database Syst.,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2011}, {"title": "On digraph coloring problems and treewidth duality", "author": ["A. Atserias"], "venue": "In LICS,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2005}, {"title": "Query and predicate emptiness in description logics", "author": ["F. Baader", "M. Bienvenu", "C. Lutz", "F. Wolter"], "venue": "In KR,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2010}, {"title": "The Description Logic Handbook", "author": ["F. Baader", "D. Calvanese", "D.L. McGuiness", "D. Nardi", "P. Patel-Schneider", "editors"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "Walking the complexity lines for generalized guarded existential rules", "author": ["J.-F. Baget", "M.-L. Mugnier", "S. Rudolph", "M. Thomazo"], "venue": "In IJCAI,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2011}, {"title": "Querying the guarded fragment", "author": ["V. B\u00e1r\u00e1ny", "G. Gottlob", "M. Otto"], "venue": "In LICS,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2010}, {"title": "Constraint satisfaction problems of bounded width", "author": ["L. Barto", "M. Kozik"], "venue": "In FOCS,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2009}, {"title": "Query containment in description logics reconsidered", "author": ["M. Bienvenu", "C. Lutz", "F. Wolter"], "venue": "In KR,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Modal Logic", "author": ["P. Blackburn", "M. de Rijke", "Y. Venema"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2001}, {"title": "On the complexity of MMSNP", "author": ["M. Bodirsky", "H. Chen", "T. Feder"], "venue": "SIAM J. Discrete Math.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "On the CSP dichotomy conjecture", "author": ["A.A. Bulatov"], "venue": "In CSR,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "A general datalog-based framework for tractable query answering over ontologies", "author": ["A. Cal\u00ec", "G. Gottlob", "T. Lukasiewicz"], "venue": "In PODS,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2009}, {"title": "Towards more expressive ontology languages: The query answering problem", "author": ["A. Cal\u00ec", "G. Gottlob", "A. Pieris"], "venue": "Artif. Intell.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2012}, {"title": "Data complexity of query answering in description logics", "author": ["D. Calvanese", "G.D. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "In KR,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2006}, {"title": "Tractable reasoning and efficient query answering in description logics: The DL-Lite family", "author": ["D. Calvanese", "G.D. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "J. Autom. Reasoning,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2007}, {"title": "On the decidability of query containment under constraints", "author": ["D. Calvanese", "G.D. Giacomo", "M. Lenzerini"], "venue": "In PODS,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 1998}, {"title": "Computing Datalog Rewritings Beyond Horn Ontologies", "author": ["B. Cuenca Grau", "M. Kaminski", "B. Motik"], "venue": "In IJCAI,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2013}, {"title": "Disjunctive datalog", "author": ["T. Eiter", "G. Gottlob", "H. Mannila"], "venue": "ACM Trans. Database Syst.,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1997}, {"title": "Towards practical query answering for Horn-SHIQ", "author": ["T. Eiter", "M. Ortiz", "M. Simkus", "T.-K. Tran", "G. Xiao"], "venue": "In DL,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2012}, {"title": "Dichotomies for classes of homomorphism problems involving unary functions", "author": ["T. Feder", "F.R. Madelaine", "I.A. Stewart"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2004}, {"title": "The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory", "author": ["T. Feder", "M.Y. Vardi"], "venue": "SIAM J. Comput.,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 1998}, {"title": "Generalised dualities and maximal finite antichains in the homomorphism order of relational structures", "author": ["J. Foniok", "J. Nesetril", "C. Tardif"], "venue": "Eur. J. Comb.,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2008}, {"title": "Datalog LITE: a deductive query language with linear time model checking", "author": ["G. Gottlob", "E. Gr\u00e4del", "H. Veith"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2002}, {"title": "Rewriting ontological queries into small nonrecursive datalog programs", "author": ["G. Gottlob", "T. Schwentick"], "venue": "In KR,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2012}, {"title": "Reasoning in description logics by a reduction to disjunctive datalog", "author": ["U. Hustadt", "B. Motik", "U. Sattler"], "venue": "J. Autom. Reasoning,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2007}, {"title": "Exponential lower bounds and separation for query rewriting", "author": ["S. Kikot", "R. Kontchakov", "V.V. Podolskii", "M. Zakharyaschev"], "venue": "In ICALP,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2012}, {"title": "The combined approach to query answering in DL-Lite", "author": ["R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev"], "venue": "In KR,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2010}, {"title": "Data complexity in the EL family of DLs", "author": ["A. Krisnadhi", "C. Lutz"], "venue": "In LPAR,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2007}, {"title": "Constraints, MMSNP, and Expander Structures", "author": ["G. Kun"], "venue": "http://arxiv.org/abs/0706.1701v1,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2007}, {"title": "Forbidden lifts (NP and CSP for combinatorialists)", "author": ["G. Kun", "J. Nesetril"], "venue": "Eur. J. Comb.,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2008}, {"title": "A characterisation of first-order constraint satisfaction problems", "author": ["B. Larose", "C. Loten", "C. Tardif"], "venue": "Logical Methods in Comp. Sci.,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2007}, {"title": "Non-uniform data complexity of query answering in description logics", "author": ["C. Lutz", "F. Wolter"], "venue": "In KR,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2012}, {"title": "Universal structures and the logic of forbidden patterns", "author": ["F.R. Madelaine"], "venue": "Logical Methods in Comp. Sci.,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2009}, {"title": "Constraint satisfaction, logic and forbidden patterns", "author": ["F.R. Madelaine", "I.A. Stewart"], "venue": "SIAM J. Comput.,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2007}, {"title": "Reasoning in description logics using resolution and deductive databases", "author": ["B. Motik"], "venue": "PhD thesis,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2006}, {"title": "Linking data to ontologies", "author": ["A. Poggi", "D. Lembo", "D. Calvanese", "G.D. Giacomo", "M. Lenzerini", "R. Rosati"], "venue": "J. Data Semantics,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2008}, {"title": "Models of program logics", "author": ["V.R. Pratt"], "venue": "In FoCS,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 1979}, {"title": "Improving Query Answering over DL-Lite Ontologies", "author": ["R. Rosati", "A. Almatelli"], "venue": "In KR,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2010}, {"title": "Homomorphism preservation theorems", "author": ["B. Rossman"], "venue": "J. ACM,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2008}, {"title": "Type-elimination-based reasoning for the description logic SHIQbs using decision diagrams and disjunctive datalog", "author": ["S. Rudolph", "M. Kr\u00f6tzsch", "P. Hitzler"], "venue": "Logical Methods in Comp. Sci.,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2012}, {"title": "Elimination of complex RIAs without automata", "author": ["F. Simancik"], "venue": "In DL,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2012}], "referenceMentions": [{"referenceID": 15, "context": "provided by an ontology [19, 18, 16].", "startOffset": 24, "endOffset": 36}, {"referenceID": 14, "context": "provided by an ontology [19, 18, 16].", "startOffset": 24, "endOffset": 36}, {"referenceID": 12, "context": "provided by an ontology [19, 18, 16].", "startOffset": 24, "endOffset": 36}, {"referenceID": 35, "context": "A third prominent application of OBDA is in data integration, where an ontology can be used to provide a uniform view on multiple data sources [40].", "startOffset": 143, "endOffset": 147}, {"referenceID": 13, "context": "For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32].", "startOffset": 331, "endOffset": 343}, {"referenceID": 24, "context": "For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32].", "startOffset": 331, "endOffset": 343}, {"referenceID": 27, "context": "For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32].", "startOffset": 331, "endOffset": 343}, {"referenceID": 14, "context": "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].", "startOffset": 145, "endOffset": 165}, {"referenceID": 23, "context": "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].", "startOffset": 145, "endOffset": 165}, {"referenceID": 25, "context": "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].", "startOffset": 145, "endOffset": 165}, {"referenceID": 26, "context": "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].", "startOffset": 145, "endOffset": 165}, {"referenceID": 37, "context": "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].", "startOffset": 145, "endOffset": 165}, {"referenceID": 11, "context": "As ontology languages, we consider a range of standard description logics (DLs) and several fragments of first-order logic that embed ontology languages such as Datalog\u00b1 [15], namely the guarded fragment (GF), the unary negation fragment (UNFO), and the guarded negation fragment (GNFO).", "startOffset": 170, "endOffset": 174}, {"referenceID": 20, "context": "The widely known FederVardi conjecture [24] states that there is a dichotomy between PTIME and NP for the class of all CSPs, that is, each CSP is either in PTIME or NP-hard.", "startOffset": 39, "endOffset": 43}, {"referenceID": 20, "context": "Monotone monadic strict NP without inequality (abbreviated MMSNP) was introduced by Feder and Vardi as a logical generalization of CSP that enjoys similar computational properties [24].", "startOffset": 180, "endOffset": 184}, {"referenceID": 20, "context": "In particular, it was shown in [24, 33] that there is a dichotomy between PTIME and NP for MMSNP sentences if and only if the Feder-Vardi conjecture holds.", "startOffset": 31, "endOffset": 39}, {"referenceID": 28, "context": "In particular, it was shown in [24, 33] that there is a dichotomy between PTIME and NP for MMSNP sentences if and only if the Feder-Vardi conjecture holds.", "startOffset": 31, "endOffset": 39}, {"referenceID": 10, "context": "Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ).", "startOffset": 86, "endOffset": 98}, {"referenceID": 9, "context": "Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ).", "startOffset": 86, "endOffset": 98}, {"referenceID": 29, "context": "Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ).", "startOffset": 86, "endOffset": 98}, {"referenceID": 32, "context": "We observe that GMSNP has the same expressive power as the extension MMSNP2 of MMSNP proposed in [37].", "startOffset": 97, "endOffset": 101}, {"referenceID": 32, "context": "It follows from our results in Section 3 that GMSNP (and thus MMSNP2) is strictly more expressive than MMSNP, closing an open problem from [37].", "startOffset": 139, "endOffset": 143}, {"referenceID": 20, "context": "It was shown in [24] that containment between MMSNP sentences is decidable.", "startOffset": 16, "endOffset": 20}, {"referenceID": 7, "context": "Note that this refers to a very general form of query containment in OBDA, as recently introduced and studied in [10].", "startOffset": 113, "endOffset": 117}, {"referenceID": 30, "context": "Finally, taking advantage of recent results for CSPs [35, 26, 13], we are able to show that FO-rewritability and datalog-rewritability, as properties of ontology-mediated queries, are decidable and NEXPTIMEcomplete for (ALC, AQ) and (ALC,BAQ).", "startOffset": 53, "endOffset": 65}, {"referenceID": 34, "context": "Related Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44].", "startOffset": 164, "endOffset": 172}, {"referenceID": 24, "context": "Related Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44].", "startOffset": 164, "endOffset": 172}, {"referenceID": 39, "context": "Related Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44].", "startOffset": 183, "endOffset": 187}, {"referenceID": 31, "context": "A connection between DL-based OBDA and CSPs was first found and exploited in [36], in a setup that is different from the one studied in this paper.", "startOffset": 77, "endOffset": 81}, {"referenceID": 31, "context": "In particular, instead of focusing on ontology-mediated queries that consist of a data schema, an ontology, and a database query, [36] concentrates on ontologies while quantifying universally over all database queries and without fixing a data schema.", "startOffset": 130, "endOffset": 134}, {"referenceID": 5, "context": "Note that all ontology languages considered in this paper enjoy finite controllability, meaning that finite relational structures can be replaced with unrestricted ones without changing the certain answers to unions of conjunctive queries [6, 7].", "startOffset": 239, "endOffset": 245}, {"referenceID": 17, "context": "in [21].", "startOffset": 3, "endOffset": 7}, {"referenceID": 3, "context": "We introduce the relevant extensions only briefly and refer to [4] for more details.", "startOffset": 63, "endOffset": 66}, {"referenceID": 33, "context": "They rely on a characterization of (ALC,UCQ) in terms of colored forbidden patterns [38], which is a by-product of the connection between (ALC,UCQ) and MMSNP that will be established in Section 4.", "startOffset": 84, "endOffset": 88}, {"referenceID": 34, "context": "This can be done similarly to the elimination of role inclusions in the proof above, see [39, 45].", "startOffset": 89, "endOffset": 97}, {"referenceID": 40, "context": "This can be done similarly to the elimination of role inclusions in the proof above, see [39, 45].", "startOffset": 89, "endOffset": 97}, {"referenceID": 40, "context": "It follows from [45] that this observation can be extended to all complex role inclusions that are admitted in the description logic SROIQ.", "startOffset": 16, "endOffset": 20}, {"referenceID": 5, "context": "To overcome this restriction, we consider the guarded fragment of first-order logic and the unary-negation fragment of first-order logic [6, 46].", "startOffset": 137, "endOffset": 144}, {"referenceID": 15, "context": "There are actually a few DLs that can handle relations of unrestricted arity, such as those presented in [19].", "startOffset": 105, "endOffset": 109}, {"referenceID": 22, "context": "Recall that a datalog rule is guarded if its body includes an atom that contains all variables which occur in the rule [27].", "startOffset": 119, "endOffset": 123}, {"referenceID": 4, "context": "A weaker notion of guardedness, which we call here frontier-guardedness, inspired by [5, 7], requires that, for each atom \u03b1 in the head of the rule, there is an atom \u03b2 in the rule body such that all variables that occur in \u03b1 occur also in \u03b2.", "startOffset": 85, "endOffset": 91}, {"referenceID": 20, "context": "It also exploits the fact that the Feder-Vardi dichotomy conjecture can equivalently be stated for MMSNP sentences [24, 33].", "startOffset": 115, "endOffset": 123}, {"referenceID": 28, "context": "It also exploits the fact that the Feder-Vardi dichotomy conjecture can equivalently be stated for MMSNP sentences [24, 33].", "startOffset": 115, "endOffset": 123}, {"referenceID": 31, "context": "It was already proved in [36] (Theorem 27) that, compared to ontology-mediated queries based on ALC, the functional roles of ALCF dramatically increase the computational power.", "startOffset": 25, "endOffset": 29}, {"referenceID": 31, "context": "Theorem 9 ([36]) For every NP-Turing machine M , there is a query q in (ALCF ,AQ) such that the complement of the word", "startOffset": 11, "endOffset": 15}, {"referenceID": 7, "context": "Specifically, the following general containment problem was proposed in [10] as a powerful tool for OBDA: given ontology-mediated queries (S,Oi, qi), i \u2208 {1, 2}, decide whether for all S-instances D, we have certq1,O1(D) \u2286 certq2,O2(D).", "startOffset": 72, "endOffset": 76}, {"referenceID": 15, "context": "Note that there are also less general (and computationally simpler) notions of query containment in OBDA that do not fix the data schema [19].", "startOffset": 137, "endOffset": 141}, {"referenceID": 20, "context": "It was proved in [24] that containment of MMSNP sentences is decidable.", "startOffset": 17, "endOffset": 21}, {"referenceID": 7, "context": "Note that this result is considerably stronger than those in [10], which considered only containment of ontology-mediated queries (S,O, q) with q an atomic query since already this basic case turned out to be technically intricate.", "startOffset": 61, "endOffset": 65}, {"referenceID": 7, "context": "In fact, this definition is slightly different from the one used in [10].", "startOffset": 68, "endOffset": 72}, {"referenceID": 32, "context": "Although defined in a different way, GMSNP is essentially the same logic as MMSNP2, which is studied in [37].", "startOffset": 104, "endOffset": 108}, {"referenceID": 32, "context": "In [37], it was left as an open question whether MMSNP2 is more expressive than MMSNP, which is resolved by the results above.", "startOffset": 3, "endOffset": 7}, {"referenceID": 32, "context": "While this question is implicit already in [37], the results established in this paper underline its significance from a different perspective.", "startOffset": 43, "endOffset": 47}, {"referenceID": 21, "context": "First, a generalized CSP is defined by a finite set F of templates, rather than only a single one [25].", "startOffset": 98, "endOffset": 102}, {"referenceID": 19, "context": "Second, in a (generalized) CSP with constant symbols, both the template(s) and the input structure are endowed with constant symbols [23, 1].", "startOffset": 133, "endOffset": 140}, {"referenceID": 0, "context": "Second, in a (generalized) CSP with constant symbols, both the template(s) and the input structure are endowed with constant symbols [23, 1].", "startOffset": 133, "endOffset": 140}, {"referenceID": 8, "context": "For example, BT can be viewed as a finite fragment of a canonical model of a modal logic that is constructed from maximal consistent sets of formulas [11].", "startOffset": 150, "endOffset": 154}, {"referenceID": 36, "context": "Alternatively, BT can be viewed as the result of a type elimination procedure [41].", "startOffset": 78, "endOffset": 82}, {"referenceID": 7, "context": "It is a consequence of a result in [10] that query containment is undecidable for ALCF .", "startOffset": 35, "endOffset": 39}, {"referenceID": 14, "context": "datalog engines, eliminating the ontology by query rewriting [18, 22, 20].", "startOffset": 61, "endOffset": 73}, {"referenceID": 18, "context": "datalog engines, eliminating the ontology by query rewriting [18, 22, 20].", "startOffset": 61, "endOffset": 73}, {"referenceID": 16, "context": "datalog engines, eliminating the ontology by query rewriting [18, 22, 20].", "startOffset": 61, "endOffset": 73}, {"referenceID": 38, "context": "Consequently, it follows from [43]", "startOffset": 30, "endOffset": 34}, {"referenceID": 30, "context": "without constant symbols, whether coCSP(B) is FO-definable is NP-complete [35].", "startOffset": 74, "endOffset": 78}, {"referenceID": 1, "context": "It relies on the characterization of FO-definable CSPs as those CSPs that have finite obstruction sets; this characterization was given in [2] for structures without constant symbols and follows from results in [43] for the case of structures with constant symbols.", "startOffset": 139, "endOffset": 142}, {"referenceID": 38, "context": "It relies on the characterization of FO-definable CSPs as those CSPs that have finite obstruction sets; this characterization was given in [2] for structures without constant symbols and follows from results in [43] for the case of structures with constant symbols.", "startOffset": 211, "endOffset": 215}, {"referenceID": 6, "context": "An NP algorithm for datalog-definability is implicit in [26], based on results from [9], see also [13].", "startOffset": 84, "endOffset": 87}, {"referenceID": 31, "context": "Modulo a minor difference in the treatment of instances that are not consistent (see Footnote 3), it follows from a result in [36] that FOrewritability is undecidable for (ALCF ,AQ).", "startOffset": 126, "endOffset": 130}], "year": 2013, "abstractText": "Ontology-based data access is concerned with querying incomplete data sources in the presence of domain-specific knowledge provided by an ontology. A central notion in this setting is that of an ontology-mediated query, which is a database query coupled with an ontology. In this paper, we study several classes of ontology-mediated queries, where the database queries are given as some form of conjunctive query and the ontologies are formulated in description logics or other relevant fragments of first-order logic, such as the guarded fragment and the unary-negation fragment. The contributions of the paper are three-fold. First, we characterize the expressive power of ontology-mediated queries in terms of fragments of disjunctive datalog. Second, we establish intimate connections between ontology-mediated queries and constraint satisfaction problems (CSPs) and their logical generalization, MMSNP formulas. Third, we exploit these connections to obtain new results regarding (i) first-order rewritability and datalogrewritability of ontology-mediated queries, (ii) P/NP dichotomies for ontology-mediated queries, and (iii) the query containment problem for ontology-mediated queries.", "creator": "LaTeX with hyperref package"}}}