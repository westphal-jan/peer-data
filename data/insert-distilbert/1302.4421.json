{"id": "1302.4421", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Feb-2013", "title": "Towards a theory of good SAT representations", "abstract": "additionally we aim at providing a foundation of a theory of \" good \" sat representations f of modified boolean functions f. we argue that the mathematical hierarchy uc _ k of unit - refutation complete clause - sets of level k, though introduced by the authors, provides the most basic target classes, that is, f in uc _ k is to be achieved for k as small as feasible. if f does not contain specifically new variables, i. e., f is equivalent ( as a cnf ) to f, then f in uc _ 1 is similar to \" achieving ( generalised ) arc consistency \" known from the literature ( it is somewhat weaker, but almost theoretically much nicer to handle ). we show that for polysize representations of boolean block functions in this sense, the hierarchy uc _ k is strict. the boolean functions for these separations are \" doped \" minimally unsatisfiable clause - sets of deficiency 1 ; these functions have been introduced in [ sloan, soerenyi, turan, 2007 ], and we generalise their construction and show a correspondence to a strengthened notion of irredundant sub - clause - sets. turning from lower bounds to upper bounds, we believe that many common cnf representations fit into the uc _ k scheme, and we give some basic basic tools to construct such representations in uc _ 1 with new variables, based on the tseitin translation. note that regarding new variables the uc _ category 1 - representations are stronger than mere \" arc consistency \", since the new variables are not excluded from consideration.", "histories": [["v1", "Mon, 18 Feb 2013 20:40:06 GMT  (46kb)", "https://arxiv.org/abs/1302.4421v1", "43 pages"], ["v2", "Tue, 5 Mar 2013 00:04:46 GMT  (48kb)", "http://arxiv.org/abs/1302.4421v2", "45 pages; second version with some extended discussions and editorial corrections"], ["v3", "Thu, 21 Mar 2013 00:46:37 GMT  (51kb)", "http://arxiv.org/abs/1302.4421v3", "43 pages; second version with some extended discussions and editorial corrections, third version with extended introduction, more examples and explanations, and some editorial improvements"], ["v4", "Fri, 10 May 2013 17:45:54 GMT  (74kb)", "http://arxiv.org/abs/1302.4421v4", "59 pages; second version with some extended discussions and editorial corrections, third version with extended introduction, more examples and explanations, and some editorial improvements, fourth version with further examples, explanations and discussions, and with added computational experiments"]], "COMMENTS": "43 pages", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["matthew gwynne", "oliver kullmann"], "accepted": false, "id": "1302.4421"}, "pdf": {"name": "1302.4421.pdf", "metadata": {"source": "CRF", "title": "Towards a theory of good SAT representations", "authors": ["Matthew Gwynne"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n30 2.\n44 21\nv4 [\ncs .A\nI] 1\nThe hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F \u2208 UCk is to be achieved for k as small as feasible. Here UC1 = UC has been introduced in [26] for the purpose of knowledge compilation. In general, UCk is the set of clause-sets F such that unsatisfiable instantiations (by partial assignments) are recognisable by k-times nested unit-clause propagation. We also touch upon the hierarchy PCk of propagation complete clause-sets of level k, where PC1 = PC has been introduced in [15]. The hierarchy PCk refines the hierarchy UCk by providing intermediate layers. In order to make use of full resolution, we consider the hierarchy WCk of width-refutation complete clauses-sets of level k, employing an improved notion of width (so that we always have UCk \u2286 WCk).\nVia the absolute condition, the quality of the representation F is fully captured by the target class, and the only relation between f and F is that F must \u201crepresent\u201d f . If F does not contain new variables, then this means that F is equivalent to f , while with new variables the satisfying assignments of F projected to the variables of f must be precisely the satisfying assignments of f . Without new variables, the relative and absolute condition coincide, but with new variables, the absolute condition is stronger. As we remark in this article, for the relative condition and new variables at least the hierarchies UCk and PCk collapse, and we also conjecture that the WCk hierarchy collapses. The main result of this article is that without new variables, none of these hierarchies collapses. That means that there are boolean functions with only exponential-size equivalent clause-sets at level k, but with poly-size equivalent clause-sets at level k + 1.\nRepresentations with new variables in general allow shorter representations. However representations without new variables can be systematically searched for, opening a new algorithmic avenue for good SAT representations, where in a pre-processing phase the representation is being optimised. When using a two-stage approach, then first non-algorithmically a representation with new variables can be constructed, which then can be optimised by searching for an equivalent better clause-set.\nWe believe that many common CNF representations either already fit into the UCk scheme or can be made fit by slight improvements. We give some basic tools to construct representations in UC1, now with new variables and based on the Tseitin translation. We conclude with a discussion of open problems and future directions, with special emphasis on separations for the various hierarchies involved.\nContents"}, {"heading": "1 Introduction 3", "text": "1.1 A general framework: hierarchies and measurement . . . . . . . . . . 4 1.2 Representation of boolean functions . . . . . . . . . . . . . . . . . . 6 1.3 Strictness of hierarchies . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.4 Understanding the combinatorial structure of satisfiable clause-sets . 7 1.5 The UC hierarchy is strict regarding equivalence . . . . . . . . . . . 7 1.6 Relevance of these hierarchies for SAT solving . . . . . . . . . . . . . 8 1.7 Tools for good representations . . . . . . . . . . . . . . . . . . . . . . 9 1.8 Experimental results . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.9 Remarks on the term \u201chardness\u201d . . . . . . . . . . . . . . . . . . . . 10 1.10 Overview on results . . . . . . . . . . . . . . . . . . . . . . . . . . . 11"}, {"heading": "2 Preliminaries 12", "text": "2.1 Clause-sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.2 CNF versus DNF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.3 On \u201cgood\u201d equivalent clause-sets . . . . . . . . . . . . . . . . . . . . 14"}, {"heading": "3 Measuring \u201cSAT representation complexity\u201d 14", "text": "3.1 Hardness and UCk . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.2 W-Hardness and WCk . . . . . . . . . . . . . . . . . . . . . . . . . . 17"}, {"heading": "4 Minimal premise sets and doped clause-sets 18", "text": "4.1 Minimal premise sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 4.2 Doping clause-sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 4.3 Hardness of doped clause-sets . . . . . . . . . . . . . . . . . . . . . . 21"}, {"heading": "5 Doping tree clause-sets 22", "text": "5.1 Preliminaries on minimal unsatisfiability . . . . . . . . . . . . . . . . 22 5.2 Total minimal premise sets . . . . . . . . . . . . . . . . . . . . . . . 24 5.3 Doping SMU\u03b4=1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27"}, {"heading": "6 Lower bounds 28", "text": "6.1 Trigger hypergraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 6.2 Extremal trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 6.3 The exponential lower bound . . . . . . . . . . . . . . . . . . . . . . 33"}, {"heading": "7 Analysing the Tseitin translation 35", "text": "7.1 CNF-representations . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 7.2 The canonical translation . . . . . . . . . . . . . . . . . . . . . . . . 36 7.3 XOR-clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42"}, {"heading": "8 Hardness under union 43", "text": ""}, {"heading": "9 Basic experiments 44", "text": "9.1 The instances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 9.2 Solver performances . . . . . . . . . . . . . . . . . . . . . . . . . . . 46"}, {"heading": "10 Conclusion and open problems 49", "text": "10.1 Strictness of hierarchies . . . . . . . . . . . . . . . . . . . . . . . . . 50 10.2 Separating the different hierarchies . . . . . . . . . . . . . . . . . . . 50 10.3 Compilation procedures . . . . . . . . . . . . . . . . . . . . . . . . . 51 10.4 Exploring w-hardness . . . . . . . . . . . . . . . . . . . . . . . . . . 52 10.5 Hard boolean functions handled by oracles . . . . . . . . . . . . . . . 52"}, {"heading": "1 Introduction", "text": "It has been shown that the practical performance of SAT solvers can depend heavily on the SAT representation used. See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography. In order to obtain \u201cgood\u201d representations, until now the emphasis has been on translating constraints into SAT such that \u201carc-consistency\u201d is \u201cmaintained\u201d, via unit-clause propagation; for an introduction into the literature see Section 22.6.7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5]. That is, for all (partial) assignments to the variables of the constraint, the task is to ensure that if there is a forced assignment (i.e., some variable which must be set to a particular value to avoid inconsistency), then unit-clause propagation (UCP) is sufficient to find and set this assignment. In a similar vein, there is the class PC of propagation-complete clause-sets (see [15]), containing all clause-sets for which unit-clause propagation is sufficient to detect all forced assignments.\nMaintaining arc-consistency and propagation-completeness may at a glance seem the same concept. However there is an essential difference. When translating a constraint into SAT, typically one does not just use the variables of the constraint, but one adds auxiliary variables to allow for a compact representation. Now when speaking of maintaining arc-consistency, one only cares about assignments to the constraint variables. But propagation-completeness deals only with the representing clause-set, thus can not know about the distinction between original and auxiliary variables, and thus it is a property on the (partial) assignments over all variables! So a SAT representation, which maintains arc-consistency via UCP, will in general not be propagation-complete, due to assignments over both constraint and new variables yielding a forced assignment or even an inconsistency which UCP doesn\u2019t detect; see Example 7.10 and Lemma 7.11. In contrast to this, for the basic concepts of \u201cgood\u201d representations investigated in this paper, considering all variables is a fundamental feature. This motivates our focus on classes of clause-sets (as the target of good SAT representations), rather than maintaining consistency over some higher level constraint network, since in this way we have full control of the properties at the level of the SAT solver (at the CNF-level).\nIn [45] it is shown that conflict-driven solvers with branching restricted to input variables have only superpolynomial run-time on EPHP\u2032n, an Extended Resolution\nextension to the pigeon-hole formulas, while unrestricted branching determines unsatisfiability quickly (see Subsection 10.5 for more on this). Also experimentally it is demonstrated in [47] that input-restricted branching can have a detrimental effect on solver times and proof sizes for modern CDCL solvers. This adds motivation to our fundamental choice of considering all variables (rather than just input variables), when deciding what properties we want for SAT translations. We call this the \u201cabsolute (representation) condition\u201d, taking also the auxiliary variables into account, while the \u201crelative condition\u201d only considers the original variables. Besides avoiding the creation of hard unsatisfiable sub-problems, the absolute condition also enables one to study the target classes, like PC, on their own, without relation to what is represented.\nIn a certain sense, the underlying idea of maintaining arc-consistency and propagation-complete translations is to compress all of the constraint knowledge into the SAT translation, and then to use UCP to extract this knowledge when appropriate. Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties. Rather than requiring that UCP detects all forced assignments (as for PC), a clause-set is in UC iff for all partial assignments resulting in an unsatisfiable clause-set UCP detects this.\nSo we have UC and PC as potential target classes for \u201cgood\u201d SAT representations. In both cases we know, that if the SAT solver ends up in an unsatisfiable part of the search space, then the ubiquitous unit-clause propagation will immediately determine this and the solver will avoid potentially exponential work. However, how to come up with representations in UC? There are easy examples of \u201cgood\u201d clause-sets which are not in UC, e.g., 2-CNF. Given that UCP is a relatively simple mechanism, perhaps it would be better to consider more powerful inference methods allowing for a greater variety and possibly shorter representations (\u201cmore compression\u201d)? For this end, to add more power, we introduce \u201chardness measurement\u201d."}, {"heading": "1.1 A general framework: hierarchies and measurement", "text": "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of \u201chardness\u201d at most k, that is, refutation is (always) possible via rk. Replacing r1 with rk in the same way in PC yields the propagation-completeness hierarchy PCk (with PC1 = PC). In the limit these hierarchies cover all clause-sets, with the levels of the hierarchy offering the possibility to trade complexity of the inference method (rk) for size of the representation. Generalising existing results we show in Lemma 6.5 of [37, 38] that various poly-time solvable SAT classes are contained within levels of the UCk hierarchy. That is HO \u2282 RHO \u2282 UC1 (Horn and renamable Horn clause-sets), 2\u2013CLS \u2282 QHO \u2282 UC2 (2-clause-sets and q-Horn clauses-sets, see Section 6.10.2 in [22] and [85]) and HOk \u2282 UCk (generalised Horn clause-sets, see [51]).\nThere are strong proof theoretic connections for UCk to tree-resolution. In [46] the argument is made that tree-resolution complexity can not provide a good measure of hardness of instances for SAT solving, citing the ability of CDCL solvers to simulate exponentially more powerful full resolution (see [2] for evidence that CDCL solvers can simulate full resolution). However, the aim of UCk is not to measure hardness, but to offer a target class for SAT translation. In this respect tree-resolution complexity measures are ideal, because they provide the strongest translations, and upper-bound measures for full resolution.\nOn the other hand, for tighter target classes in the case of full resolution, we also consider the notion of width-hardness as introduced in [37, 38], based on the\nwidth-based hierarchies of unsatisfiable clause-sets in [53, 59]. That is, a clause-set is in WCk, the hierarchy of clause-sets of width-hardness k, iff under any partial assignment resulting in an unsatisfiable clause-set there is a \u201ck-resolution\u201d refutation as introduced in [51]. Here, unlike the typical notion, we allow resolutions where only one parent clause needs to have length at most k, and thus properly generalising unit-resolution (one could speak of \u201casymmetric width\u201d here, compared to the standard \u201csymmetric width\u201d). This allows to simulate nested input resolution, and thus we have UCk \u2286 WCk for all k, whereas otherwise in the standard (symmetrical) sense even Horn clause-sets require unbounded width (recall that HO \u2282 UC1).\nFundamental for each hierarchy is an underlying measure h0 : USAT \u2192 CLS, measuring the \u201chardness\u201d of unsatisfiable clause-sets, which is extended to h : CLS \u2192 N0, where h(F ) for an arbitrary clause-set F measures the \u201chardness\u201d to derive any conclusion F |= C for clauses C, by letting h(F ) be the maximum of h0(\u03d5\u2217F ) over all partial assignments \u03d5 such that application yields an unsatisfiable result \u03d5 \u2217 F . The hierarchy at level k collects all F with h(F ) \u2264 k. For the PCUC hierarchy the corresponding measure phd(F ) resp. hd(F ) can be described in many ways; most intuitive from a SAT point of view is to say that it measures the necessary nesting level of UCP, that is, which rk is required.\nA precursor A generalisation of UC was already discussed in [27]. Assuming a polytime SAT-decision algorithm P : C \u2192 {0, 1} for some C \u2286 CLS, the class PC \u2286 CLS of \u201cP-complete\u201d clause-sets is defined as the set of F \u2208 CLS such that for all implicates C holds P (\u03d5C \u2217 F ) = 0.1) This is an obvious generalisation of UCk, when using Ck := {F \u2208 CLS : rk(F ) \u2208 {\u22a4, {\u22a5}}} and Pk : Ck \u2192 {0, 1} with Pk(F ) = 1 \u21d4 rk(F ) = \u22a4. But it does not cover the hierarchies PCk or WCk, which are based on different principles.2) We note the conceptual weakness of demanding a SAT-decision algorithm P , where actually only a means for detecting unsatisfiability is needed.\n[27] continues by considering the (generic) hierarchy (\u03a0k)k\u2208N0 from [71], a precursor of [53]. \u03a00 \u2286 CLS in principal is arbitrary, but is assumed to be polytime decidable and SAT-decidable. Then \u03a0k for k > 0 is the set of F \u2208 CLS such that F \u2208 \u03a0k\u22121 or there is a literal x \u2208 lit(F ) with \u3008x \u2192 1\u3009 \u2217 F \u2208 \u03a0k\u22121 and \u3008x \u2192 1\u3009 \u2217 F \u2208 \u03a0k. We note that if we choose \u03a00 = {F \u2208 CLS : \u22a5 \u2208 F}, then \u03a0k = UCk \u2229 USAT for all k \u2265 0. However this choice for \u03a00 was never considered for that hierarchy from [71], which might have two reasons: Implicit preference is given to classes \u03a00 closed under sub-clause-set formation (see Section 6.3 in [38] for more discussions on this issue). And furthermore SAT and UNSAT is not distinguished in [71] and in subsequent work directly relying on it; see Subsection 1.2 in [53] for a discussion of this. So the four choices for \u03a00 considered in [27] are HO, 2\u2013CLS, RHO and QHO. Accordingly UC0\u2229USAT is not contained at any \u03a0k, and so not even r1 on unsatisfiable clause-set is covered by the considered hierarchies.\nDue to these weaknesses, [27] does not consider a hierarchy generalising UC. From our point of view one could say, that \u03a0k is only considered as a resource for polytime recognition of certain instances for UCk resp. UCk+1; compare Subsections 6.2, 6.3 in [38] for results in this direction.\n1)[27] actually favours adding unit-clauses to F , but we consider applying partial assignments as more fundamental.\n2)This is obvious for k \u2265 1 and PCk , since PCk \u2229 USAT = UCk \u2229 USAT , while PCk \u2229 SAT \u2282 UCk \u2229SAT . We conjecture that for k \u2265 3 there is no (polytime) P with PC = WCk (as remarked in Subsection 3.2, for k \u2208 {0, 1, 2} there exists such a P )."}, {"heading": "1.2 Representation of boolean functions", "text": "By definition each PCk,UCk,WCk is just a class of clause-sets. However when using these classes for representing boolean functions, then there are further aspects. In general, for translations to SAT a typical path is\nProblem \u2192 Constraints \u2192 Boolean functions \u2192 SAT \ufe38 \ufe37\ufe37 \ufe38\nour focus\n.\nBy considering target classes for \u201cgood\u201d SAT representations. we focus our attention on the final stage, the translation of boolean functions to SAT, ignoring the issue of encoding non-boolean domains into the boolean. Now there are three main dimensions to consider (choices to make):\n1. Inference properties (PCk versus UCk versus WCk, and the value of k): How strong a property we require of the clause-set we translate to (PCk is strongest, WCk weakest, and the lower k the stronger the condition).\n2. Logical equivalence versus new variables: whether the SAT translation is equivalent to the input function (i.e., no new variables), or uses new variables to extend the original function.\n3. Relative versus absolute condition: in case new variables are used, whether the property we require for the translation refers to partial assignments only on the original variables or also on the new variables.\nSee Subsection 7.1 for more on the relative condition; our point of view is that the absolute condition is fundamental for the representation of boolean functions, not the relative condition (which has been dominant in the literature until now).\nIn the area of Knowledge Compilation, the task is also to represent (\u201ccompile\u201d) boolean functions to allow good inference under (repeated) queries. In particular, one wants to find a representation for a boolean function which allows queries such as clausal entailment (F |= C), equivalence, and model counting to be answered efficiently (in polynomial time). In this sense, we can think of \u201cfinding a good representation\u201d as a form of SAT knowledge compilation, where we care (only) about clausal entailment, since CNF-clauses directly correspond to falsifying partial assignments. [18] gives an overview of the CNF-based target languages (prime implicates, UC, 2\u2013CLS, Horn clause-sets). [29] consider disjunctions of simple CNF classes. [25] provides an overview of target compilation languages based on \u201cnested\u201d (graph-based) classes, namely variants of NNF, DNNF and BDDs. In all cases query complexity and succinctness is investigated. We focus on CNF representations, since we want good representations for current resolution-based SAT solvers. All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2\u2013CLS in UC2. Translations from target classes such as DNNF to CNF are also of interest and fit into the framework of UCk via using new variables; see Section 7.2 for the most basic positive considerations. And see [49] for a basic negative result, characterising what can be represented under the relative condition (i.e., arc consistency)."}, {"heading": "1.3 Strictness of hierarchies", "text": "A fundamental question is the strictness of these hierarchies PCk, UCk, and WCk in each of those two remaining dimensions. That is, whether each level offers new possibilities for polysize representations of (sequences of) boolean functions within the confines of the specified dimensions, i.e., relative versus absolute and without versus with new variables. Using the basic choice of the absolute condition, we\nhave six proper hierarchies (3 conjectured, 3 proven), namely PCk, UCk and WCk for representations without (Theorem 6.14) and with new variables (Conjecture 7.3).3) However when using representations based on the relative condition (and using new variables), then all these hierarchies collapse to their first level: two collapses are similar to existing results, while the collapse for WCk should follow also in this way, and is spelled out as Conjecture 7.5.\nConsidered together, under the relative condition only the levels PC0 \u2282 UC0 \u2282 PC1 are strict regarding polysize representations, where the two classes PC0 \u2282 UC0 do not gain anything from the new variables, while everything of PCk, UCk and WCk for k \u2265 1 can be reduced (in polytime, with exponent depending on k) to PC1 = PC. And PC under the relative condition is the same as the well-known condition of \u201carc consistency\u201d for SAT translation. The main result of this paper, that PCk, UCk and WCk for the absolute condition and without new variables do not collapse, shows that a rich structure was hidden under the carpet of the relative condition aka arc consistency. A basic difference between relative and absolute condition is that under the relative condition the new variables can be used to perform certain \u201ccomputations\u201d, since there are no conditions on the new variable other than not to distort the satisfying assignments. This is used to show the collapse to arc consistency, by encoding the stronger condition into the clause-sets in such a way that UCP can perform the \u201ccomputations\u201d."}, {"heading": "1.4 Understanding the combinatorial structure of satisfiable clause-sets", "text": "To be able to prove properties about all equivalent representations of some clause-set F , we must be able to understand its combinatorial structure in relation to the set of all its prime implicates. The notion of minimal unsatisfiability (MU) and minimally unsatisfiable subsets (MUS) is important in understanding the combinatorics of unsatisfiable clause-sets (see [52, 66]). To understand the structure of satisfiable clause-sets and their associated boolean functions, we now consider the concept of \u201cminimal premise sets\u201d (MPS) introduced in [62]. The notion of MPS generalises that of MU by considering clause-sets F which are minimal w.r.t implying any clause C rather than just those implying \u22a5. And accordingly we consider the minimal-premise subsets (MPSS) of a clause-set F .\nEvery prime implicate C of a clause-set F has an associated MPSS (just consider the minimal sub-clause-set of F that implies C), but not every MPSS of F yields a prime implicate (e.g., consider the MPSS {C} for some non-prime clause C \u2208 F ). However, by \u201cdoping\u201d the clause-set, i.e., adding a new unique variable to every clause, every clause in an MPSS F \u2032 makes a unique contribution to its derived clause C. This results in a new clause-set D(F ) which has an exact correspondence between its minimal premise sets (which are (essentially) also those of F ) and its prime implicates. In this way, by considering clause-sets F with a very structured set of minimal premise subsets, we can derive clause-sets D(F ) with very structured set of prime implicates."}, {"heading": "1.5 The UC hierarchy is strict regarding equivalence", "text": "A sequence (fh)h\u2208N of boolean functions, which separates UCk+1 from UCk w.r.t. clause-sets equivalent to fh in UCk+1 resp. UCk, should have the following properties:\n1. A large number of prime implicates: the number of prime implicates for fh should at least grow super-polynomially in h, since otherwise already\n3)Regarding PCk we get only a separation of PCk and PCk+2; this will be addressed in future work.\nthe set of prime implicates is a small clause-set in UC0 (see Definition 3.3) equivalent to fh.\n2. Easily characterised prime implicates: the prime implicates of fh should be easily characterised, since otherwise we can not understand how clause-sets equivalent to fh look like.\n3. Poly-size representations: there must exist short clause-sets in UCk+1 equivalent to fh for all h \u2208 N.\n[75] introduced a special type of boolean functions, called Non-repeating Unate Decision trees (NUD) there, by adding new variables to each clause of clause-sets in SMU\u03b4=1, which is the class of unsatisfiable hitting clause-sets of deficiency \u03b4 = 1. These boolean functions have a large number of prime implicates (the maximum regarding the original number of clauses), and thus are natural to consider as candidates to separate the levels of UCk. In Section 4 we show that it is actually the underlying SMU\u03b4=1 clause-sets that contribute the structure. The clause-sets in SMU\u03b4=1 are exactly those with the maximum number of minimal premise sets, and then doping elements of SMU\u03b4=1 yields clause-sets with the maximal number of prime implicates. We utilise the tree structure of SMU\u03b4=1 to prove lower bounds on the size of equivalent representations of doped SMU\u03b4=1 clause-sets in UCk.\nIn Section 6 we introduce the basic method (see Theorem 6.4) for lower bounding the size of equivalent clause-sets of a given hardness, via the transversal number of \u201ctrigger hypergraphs\u201d. Using this lower bound method, in Theorem 6.13 we show a lower bound on the matching number of the trigger hypergraph of doped \u201cextremal\u201d SMU\u03b4=1-clause-sets. From this follows immediately Theorem 6.14, that for every k \u2208 N0 there are polysize clause-sets in UCk+1, where every equivalent clause-set in WCk is of exponential size. Thus the UCk as well as the WCk hierarchy is strict regarding equivalence of polysize clause-sets.\nIn [26] (Example 2) a separation was already shown between UC0 (clause-sets containing all of their prime implicates) and UC1 = UC, and the question was raised of the worst-case growth when compiling from an arbitrary CNF clause-set F to some equivalent F \u2032 \u2208 UC. This question was partly answered in [8] (although the connection was not made), where the authors provide examples of poly-size clausesets with only super-polynomial size representations in UC, even when allowing new variables (see Subsections 7.1, 10.5, and [9] for more on the connection between [8] and UCk). This shows a super-polynomial lower-bound on the worst-case growth, but no method or new (larger) target-class for knowledge-compilation. Our separation result now answers the question of worst-case growth from [26] in full generality with the hierarchy UCk. Each level of UCk is exponentially more expressive than the previous (i.e., with possible exponential blow-up when compiling from some F \u2208 UCk+1 to equivalent F \u2032 \u2208 UCk), and so each level offers its own new, larger class for knowledge compilation, at the expense of increased query time (now O(\u2113(F ) \u00b7n(F )2k\u22122) for UCk compared to O(\u2113(F )) for UC). This separation, between UCk+1 and UCk for arbitrary k, is more involved than the simple separation in [26], due to the parameterised use of more advanced polynomial-time methods than r1 (UCP). Especially the separation between UC0 and UC1 is rather simple, since UC0 does not allow any form of compression."}, {"heading": "1.6 Relevance of these hierarchies for SAT solving", "text": "The poly-time methods used to detect unsatisfiability of instantiations of clause-sets in UCk resp. WCk have a running-time with an exponent depending on k, and in the latter case also space-complexity depends in the exponent on k.\n1. This seems a necessary condition for showing a separation result as shown in this paper. It is needed that the different levels are qualitatively different. And this seems very unlikely to be achievable with a parameter which would allow fixed-parameter tractability, and which thus would only be a quantitative parameter (like the number of variables), only expressing a gradual increase in complexity. See Lemma 10.4 for an example of a collapsing hierarchy.\n2. The class UCk uses generalised UCP, namely the reduction rk. Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]). Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique. Furthermore, in general rk is used, in even stronger versions, in the St\u030aalmarck-solver (see [81, 40, 73], and see Section 3.5 of [53] for a discussion of the connections to rk), and via breadth-first \u201cbranch/merge\u201d rules in HeerHugo (see [33]).\n3. Our example class G1k,h (see Section 9) shows experimentally that higher levels of hardness may still be solved easily by SAT solvers. These examples have such read-once resolution refutations (linear in the size of the input) which are detectable by \u201c2-subsumption resolution\u201d, i.e., the replacement of two clauses C \u222a{v}, C \u222a {v} by one clause C. So with this preprocessing SAT solvers can solve them in linear time. But also without this preprocessing SAT solvers seem to solve these problems in linear time. The alternative representations have lower hardness, but due to their bigger sizes SAT solvers perform orders of magnitudes worse on the larger instances.\n4. In general, a SAT solver does not need to have these mechanisms built-in in general: as practical experience shows, SAT solvers are rather good in finding resolution refutations, and the parameter k in UCk resp. WCk is just a general way of bounding resolution complexity. In [68, 69] it is argued that modern SAT solvers can simulate full resolution \u2014 and this is considered to be a good property of SAT solvers. Thus they are also capable in general of finding the refutations guaranteed by UCk resp. WCk. An important point here is, that for theoretical reasoning all unsatisfiable instantiations must be handled, while in a SAT-solver run only a selected set of instantiations is encountered, and thus \u201cleaner means\u201d can suffice (as the practical success of SAT solving shows)."}, {"heading": "1.7 Tools for good representations", "text": "We conclude our investigations by considering translations based on the Tseitin translation in Section 7, and show that interesting classes of boolean function can be polynomially translated to UC under the absolute condition using new variables. First we discuss the notion of \u201crepresentation\u201d in general in Subsection 7.1, with special emphasise on the \u201crelative\u201d versus the \u201cabsolute condition\u201d.\nThe Tseitin translation for DNF\u2019s we call \u201ccanonical translation\u201d, and we investigate it in Subsection 7.2. In particular, in Lemma 7.12 we show that every orthogonal (or \u201cdisjoint\u201d, or \u201chitting\u201d) DNF is translated to UC, while in Lemma 7.17 we show that actually every DNF is translated to UC, when using the \u201creduced\u201d canonical translation, which uses only the necessary part of the equivalences constitutive for the Tseitin translation. Applied to our examples yielding the separation of UCk+1 from WCk (Theorem 6.14, regarding polysize representations without new variables), we obtain a representation in UC in Theorem 7.14 (for the canonical translation), demonstrating the power of using new variables.\nIt has been noted in the literature at several places (see [70, 44, 28]), that one might use only one of the two directions of the equivalences in the Tseitintranslation. Regarding the canonical translation we have the full translation (Definition 7.6) versus the reduced translation (Definition 7.15). The full translation yields UC for special inputs (Lemma 7.12), and has relative hardness 1 for general DNF (Lemma 7.9), however (absolute) hardness for arbitrary DNF-inputs can be arbitrarily high as shown in Lemma 7.11. On the other hand, the reduced translation yields always UC (Lemma 7.17). So we have the following explanations why using either both directions or only one direction in the Tseitin translation, in the context of translating DNF\u2019s, can perform better than the other form:\n\u2022 When using both directions (i.e., the canonical translation), splitting on the auxiliary variables is powerful, which is an advantage over using only one direction (i.e., the reduced canonical translation), where setting an auxiliary variable to false says nothing.\n\u2022 On the other hand, the canonical translation, when applied to non-hitting DNFs, can create hard unsatisfiable sub-problems (via partial assignments), which can not happen for the reduced translation.\nIt seems very interesting to us to turn these arguments into theorems (for concrete examples), and also to experimentally evaluate them. In this way we hope that in the future more precise directions can be given when to use which form of the Tseitin translation.\nIn Subsection 7.3 we turn to the translation of \u201cXOR-clauses\u201d. Section 1.5 of [37, 38] discusses the translation of the so-called \u201cSchaefer classes\u201d into the UCk hierarchy; see Section 12.2 in [24] for an introduction, and see [23] for an in-depth overview on recent developments. All Schaefer classes except affine equations have natural translations into either UC1 or UC2. The open question is whether systems of XOR-clauses (i.e., affine equations) can be translated into UCk for some fixed k. We consider the most basic questions in a sense. On the positive side, for single XOR clauses, we show in Lemma 7.19 that the Tseitin translation of a typical XOR summation circuit is in UC. On the negative side, in Theorem 8.5, we show for all k \u2265 3 that applying this translation piecewise to systems of just two largeenough XOR clauses yields a SAT translation not in UCk. Conjecture 7.21 then hypothesises that, in general, systems of XOR-clauses have no representation of bounded hardness."}, {"heading": "1.8 Experimental results", "text": "In Section 9 we consider the usage of the class of boolean functions f used for the lower bound as a constraint in a general SAT problem. We have equivalent clausesets in UCk for the optimal k, as well as short orthogonal DNF representations, which enable us to apply the canonical translation as well as the reduced canonical translation. We complement these three constraint-representations in a fixed way to obtain an unsatisfiable clause-set. The experiments show that for all solver types the optimal UCk representations performs much better in terms of running time. This yields some evidence to our claim that equivalent representations in UCk even for higher k (in our experiments we considered k \u2264 5) might outperform representations obtained by introducing new variables, due to using (possibly) much less variables and clauses."}, {"heading": "1.9 Remarks on the term \u201chardness\u201d", "text": "In general, if one speaks of the \u201chardness measure\u201d hd : CLS \u2192 N0 (Definition 3.3) in context with other measures, then one should call it more specifically\ntree-hardness (\u201ct-hardness\u201d), denoted by thd(F ), due to its close relation to treeresolution (and its space complexity). So we have three basic types of hardnessmeasures, namely t-hardness thd(F ), the minimum k with F \u2208 UCk, p-hardness phd(F ), the minimum k with F \u2208 PCk, and w-hardness, the minimum k with in F \u2208 WCk. In this article, since thd(F ) is still most important here, we denote it by hd(F ) = thd(F ).\nIn what respect is the terminology \u201chardness\u201d appropriate? The hardness measure hd(F ) has been introduced in [53, 59], based on quasi-automatisation of tree-resolution, that is, on a specific algorithmic approach (close to St\u030aalmarcks approach).4) In [1], hd(F ) for unsatisfiable F was proposed as measure of SAT-solverhardness in general. This was criticised in [46] by the argument, that conflict-driven SAT solvers would be closer to dag-resolution (full resolution) than tree-resolution. Due to their heuristical nature, it seems to us that there is no robust measure of SAT-solver-hardness. Instead, our three basic measures, which are robust and mathematically meaningful, measure how good a clause-set F is in representing an underlying boolean function in the following sense:\n\u2022 Regarding instantiation we take a worst-case approach, that is, we consider all partial assignments \u03d5 and their applications \u03d5 \u2217 F (insofar they create unsatisfiability or forced literals).\nA SAT-solver only uses certain partial assignments, and thus this worst-case approach is overkill. However when using F in any context, then it makes sense to consider all partial assignments.\n\u2022 Regarding algorithms, we take a breadth-first approach, that is, the smallest k such that rk or k-resolution succeeds. For k > 1 a SAT-solver might not find these inferences. In Subsection 1.6 we have discussed the issue of incorporating these reductions into SAT solving. From a theoretical point of view, the maximisation over all partial assignments needs to be complemented with a minimisation (over k) in order to yield something interesting."}, {"heading": "1.10 Overview on results", "text": "The preliminaries (Section 2) define the basic notions. The classes UCk andWCk are introduced in Section 3. In Section 4 we investigate minimal premise sets and doping in general, while in Section 5 we apply these notions to our source of hard examples. In Section 6 we are then able to show the separation result. In Section 7 we then turn from lower bounds to upper bounds, and analyse the Tseitin translation. To investigate the hardness of a special case, we present some tools for determining (w-)hardness in Section 8. Section 9 discusses our basic experiments. Finally, in Section 10 one finds many open problems.\nThe main results on minimal premise sets and doping are:\n1. Theorem 4.18 shows the correlation between prime implicates of doped clausesets and minimal premise-sets of the original (undoped) clause-sets.\n2. Theorem 5.12 characterises unsatisfiable clause-sets where every non-empty sub-clause-set is a minimal premise set.\n3. Theorem 5.22 gives basic characteristics of doped SMU\u03b4=1-clause-sets.\nThe main results on size lower bounds for the hardness are:\n4)Using the simplest oracle, on unsatisfiable instances the measure from [53, 59] yields hd(F ). But on satisfiable instances the approach of [53, 59] is very different, namely an algorithmic polynomial-time approach is taken, extending the breadth-first search for tree-resolution refutations in a natural way.\n1. Theorem 6.4 introduces the basic method for lower bounding the size of equivalent clause-sets of a given hardness, via the transversal number of \u201ctrigger hypergraphs\u201d.\n2. Theorem 6.13 shows a lower bound on the matching number of the trigger hypergraph of doped \u201cextremal\u201d SMU\u03b4=1-clause-sets.\n3. Theorem 6.14 shows that for every k \u2208 N0 there are polysize clause-sets in UCk+1, where every equivalent clause-set in WCk is of exponential size.\nAnd regarding upper bounds, that is, short representations (with new variables) with low hardness, we have the following main results:\n1. Lemmas 7.12, 7.17 show how the canonical translation can yield results in UC.\n2. Theorem 7.14 shows that all doped SMU\u03b4=1-clause-sets (and in fact all doped unsatisfiable hitting clause-sets) have short CNF-representations in UC via the canonical translation.\n3. Lemma 7.19 shows that translating a single XOR-clause to UC is easy, while Theorem 8.5 shows that applying this translation to just two XOR-clauses already yields high hardness."}, {"heading": "2 Preliminaries", "text": "We follow the general notations and definitions as outlined in [52]. We use N = {1, 2, . . .}, N0 = N \u222a {0}, and P(M) for the set of subsets of set M ."}, {"heading": "2.1 Clause-sets", "text": "Let VA be the infinite set of variables, and let LIT = VA \u222a {v : v \u2208 VA} be the set of literals, the disjoint union of variables as positive literals and complemented variables as negative literals. We use L := {x : x \u2208 L} to complement a set L of literals. A clause is a finite subset C \u2282 LIT which is complement-free, i.e., C\u2229C = \u2205; the set of all clauses is denoted by CL. A clause-set is a finite set of clauses, the set of all clause-sets is CLS. By var(x) \u2208 VA we denote the underlying variable of a literal x \u2208 LIT , and we extend this via var(C) := {var(x) : x \u2208 C} \u2282 VA for clauses C, and via var(F ) := \u22c3\nC\u2208F var(C) for clause-sets F . The possible literals\nin a clause-set F are denoted by lit(F ) := var(F ) \u222a var(F ). Measuring clausesets happens by n(F ) := |var(F )| for the number of variables, c(F ) := |F | for the number of clauses, and \u2113(F ) := \u2211\nC\u2208F |C| for the number of literal occurrences. A special clause-set is \u22a4 := \u2205 \u2208 CLS, the empty clause-set, and a special clause is \u22a5 := \u2205 \u2208 CL, the empty clause.\nA partial assignment is a map \u03d5 : V \u2192 {0, 1} for some finite V \u2282 VA, where we set var(\u03d5) := V , and where the set of all partial assignments is PASS . For v \u2208 var(\u03d5) let \u03d5(v) := \u03d5(v) (with 0 = 1 and 1 = 0). We construct partial assignments by terms \u3008x1 \u2192 \u03b51, . . . , xn \u2192 \u03b5n\u3009 \u2208 PASS for literals x1, . . . , xn with different underlying variables and \u03b5i \u2208 {0, 1}. We use \u03d5C := \u3008x \u2192 0 : x \u2208 C\u3009 for the partial assignment setting precisely the literals in clause C \u2208 CL to false.\nFor \u03d5 \u2208 PASS and F \u2208 CLS we denote the result of applying \u03d5 to F by \u03d5 \u2217 F , removing clauses C \u2208 F containing x \u2208 C with \u03d5(x) = 1, and removing literals x with \u03d5(x) = 0 from the remaining clauses. By SAT := {F \u2208 CLS | \u2203\u03d5 \u2208 PASS : \u03d5\u2217F = \u22a4} the set of satisfiable clause-sets is denoted, and by USAT := CLS\\SAT the set of unsatisfiable clause-sets.\nSo clausal entailment, that is the relation F |= C for F \u2208 CLS and C \u2208 CL, which by definition holds true iff for all \u03d5 \u2208 PASS with \u03d5 \u2217 F = \u22a4 we have \u03d5 \u2217 {C} = \u22a4, is equivalent to \u03d5C \u2217 F \u2208 USAT .\nTwo clauses C,D \u2208 CL are resolvable iff they clash in exactly one literal x, that is, C \u2229D = {x}, in which case their resolvent is C \u22c4D := (C \u222aD) \\ {x, x} (with resolution literal x). A resolution tree is a full binary tree formed by the resolution operation. We write T : F \u22a2 C if T is a resolution tree with axioms (the clauses at the leaves) all in F and with derived clause (at the root) C. A resolution tree T : F \u22a2 C is regular iff along each path from the root of T to a leaf no resolutionvariable is used more than once. In this article we use only resolution trees, even when speaking of unrestricted resolution, that is, we always unfold dag-resolution proofs to (full) binary resolution trees. Completeness of resolution means that F |= C (semantic implication) is equivalent to F \u22a2 C, i.e., there is some C\u2032 \u2286 C and some T with T : F \u22a2 C\u2032.\nA prime implicate of F \u2208 CLS is a clause C such that a resolution tree T with T : F \u22a2 C exists, but no T \u2032 exists for some C\u2032 \u2282 C with T \u2032 : F \u22a2 C\u2032; the set of all prime implicates of F is denoted by prc\n0 (F ) \u2208 CLS. The term \u201cimplicate\u201d refers\nto the implicit interpretation of F as a conjunctive normal form (CNF). Considering clauses as combinatorial objects one can speak of \u201cprime clauses\u201d, and the \u201c0\u201d in our notation reminds of \u201cunsatisfiability\u201d, which is characteristic for CNF. Two clause-sets F, F \u2032 \u2208 CLS are equivalent iff prc0(F ) = prc0(F \u2032). A clause-set F is unsatisfiable iff prc0(F ) = {\u22a5}. The set of prime implicants of a clause-set F \u2208 CLS is denoted by prc1(F ) \u2208 CLS, and is the set of all clauses C \u2208 CL such that for all D \u2208 F we have C \u2229D 6= \u2205, while this holds for no strict subset of C."}, {"heading": "2.2 CNF versus DNF", "text": "As we said, the default interpretation of a clause-set F is as a CNF, which we can emphasise by speaking of the \u201cCNF-clause-set F\u201d, that is, the interpretation as a boolean function is\nF \u2740 \u2227\nC\u2208F\n\u2228\nx\u2208C x.\nWe might consider F also as a DNF-clause-set, which does not change F itself, but only changes the interpretation of F in considerations regarding the semantics:\nF \u2740 \u2228\nC\u2208F\n\u2227\nx\u2208C x.\nNote that by the de Morgan rules from the CNF-formula we obtain the DNFformula via negating the whole formula together with negating the literals (in other words, the underlying boolean function of a CNF-clause-set F is the \u201cdual\u201d of the underlying boolean function of the DNF-clause-set F ; see [22]). Thus the logical negation (as CNF) of a clause-set F (as CNF) is obtained from a DNF-clause-set equivalent to F by negating all literals.\nExample 2.1 The clause-set F = {{v}} has the equivalent DNF-clause-set F = {{v}} (the underlying boolean function is \u201cself-dual\u201d; see [22]), while the negation is {{v}}. And F = {{v, w}} has the equivalent DNF-clause-set {{v}, {w}}, while the negation is {{v}, {w}}.\nThe above description of the sets prc0(F ), prc1(F ) as the set of prime implicates resp. implicants holds for the default interpretation of F as CNF, while for the DNFinterpretation prc0(F ) becomes the set of prime implicants, while prc1(F ) becomes the set of prime implicates (of the boolean function underlying F ). A CNF-clauseset F is equivalent to a DNF-clause-setG iff prc0(F ) = prc1(G). The total satisfying\nassignments of a (CNF-)clause-set F can be identified with the elements of the canonical DNF of F , which is defined via the map DNF : CLS \u2192 CLS, where for F \u2208 CLS we set DNF(F ) := {C \u2208 CL | var(C) = var(F ) \u2227 \u2200D \u2208 F : C \u2229D 6= \u2205}.\nWhile clause-sets and partial assignments themselves are neutral regarding CNFor DNF-interpretation, the application \u03d5 \u2217 F is based on the CNF-interpretation of F ; if we wish to use the DNF-interpretation of F , then we use \u03d5 \u2217 F , where \u03d5 := \u3008v \u2192 \u03d5(v) : v \u2208 var(\u03d5)\u3009. While \u22a4 in the CNF-interpretation stands for \u201ctrue\u201d, in the DNF-interpretation it becomes \u201cfalse\u201d.\nExample 2.2 Consider F := {{a}, {b}} \u2208 CLS (with n(F ) = c(F ) = \u2113(F ) = 2). Then DNF(F ) = {{a, b}}, and for \u03d5 := \u3008a, b \u2192 1\u3009 we have \u03d5 \u2217 F = \u22a4. This corresponds to the CNF-interpretation a \u2227 b of F , which has exactly one satisfying assignment \u03d5. If we consider the DNF-interpretation a \u2228 b of F , then we have three satisfying total assignments for the DNF-clause-set F , and for example the satisfying assignment \u03c8 := \u3008a \u2192 1\u3009 is recognised via \u03c8 \u2217 F = \u3008a \u2192 0\u3009 \u2217 F = {\u22a5, {b}}, where the result as DNF is a tautology, since \u22a5 as a DNF-clause becomes the constant 1 (as the empty conjunction)."}, {"heading": "2.3 On \u201cgood\u201d equivalent clause-sets", "text": "A basic problem considered in this article is for a given F \u2208 CLS to find a \u201cgood\u201d equivalent F \u2032 \u2208 CLS. How \u201cgood\u201d F \u2032 is depends in our context on two factors, which have to be balanced against each other:\n\u2022 the size of F \u2032: we measure c(F \u2032), and the smaller the better;\n\u2022 the inference power of F \u2032: inference from F \u2032 should be \u201cas easy as possible\u201d, and we consider two measures in this article, (tree-)hardness in Subsection 3.1, and width-hardness in Subsection 3.2; the smaller these measures, the easier inference w.r.t. tree resolution resp. (generalised) width-bounded resolution.\nThe basic size-lower-bound for F \u2032 is given by the essential prime implicates, which are those C \u2208 prc0(F ) such that prc0(F ) \\ {C} is not equivalent to F :\nLemma 2.3 Consider F \u2208 CLS, and let P \u2286 prc0(F ) be the set of essential prime implicates of F . Now for every F \u2032 \u2208 CLS equivalent to F there exists an injection i : P \u2192 F \u2032 such that for all C \u2208 P holds C \u2286 i(C). Thus c(F \u2032) \u2265 c(P ).\nProof: For every C\u2032 \u2208 F \u2032 there exists a C \u2208 prc0(F ) such that C \u2286 C\u2032; replacing every C\u2032 \u2208 F by such a chosen C we obtain F \u2032\u2032 \u2286 prc0(F ) with P \u2286 F \u2032\u2032.\nNote that Lemma 2.3 crucially depends on not allowing new variables (see Subsection 7.1 for what it means that an F \u2032 with new variable \u201crepresents\u201d F ) \u2014 when allowing new variable, then we currently do not have any overview on the possibilities for \u201cbetter\u201d F \u2032. The most powerful representation regarding inference alone (with or without new variables) is given by the set prc0(F ) of all prime implicates of F , and will have \u201chardness\u201d 0, as defined in the following section. (The problem is of course that in most cases this representation is too large, and thus higher hardness must be allowed.)"}, {"heading": "3 Measuring \u201cSAT representation complexity\u201d", "text": "In this section we define and discuss the measures hd, phd,whd : CLS \u2192 N0 and the corresponding classes UCk,PCk,WCk \u2282 CLS. It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.\n3.1 Hardness and UCk First we turn to the most basic hardness measurement. It can be based on resolution refutation trees, as we do here, but it can also be defined algorithmically, via generalised unit-clause propagation (see Lemma 3.4).\nDefinition 3.1 For a full binary tree T the height ht(T ) \u2208 N0 and the HortonStrahler number hs(T ) \u2208 N0 are defined as follows:\n1. If T is trivial (i.e., #nds(T ) = 1), then ht(T ) := 0 and hs(T ) := 0.\n2. Otherwise let T1, T2 be the two subtrees of T :\n(a) ht(T ) := 1 +max(ht(T1), ht(T2))\n(b) If hs(T1) = hs(T2), then hs(T ) := 1 + max(hs(T1), hs(T2)), otherwise hs(T ) := max(hs(T1), hs(T2)).\nObviously we always have hs(T ) \u2264 ht(T ).\nExample 3.2 For the tree T from Example 5.3 we have ht(T ) = 3, hs(T ) = 2. The Horton-Strahler numbers of the subtrees are as follows:\n2\n2 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\n1 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\n0 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n0 \u2744\u2744\n\u2744\u2744 \u2744\u2744\n\u2744 1 \u2756\u2756\u2756\n\u2756\u2756\u2756 \u2756\u2756\u2756\n\u2756\u2756\u2756 \u2756\n0 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n0 \u2744\u2744\n\u2744\u2744 \u2744\u2744\n\u2744\n1 \u2756\u2756\u2756\n\u2756\u2756\u2756 \u2756\u2756\u2756\n\u2756\u2756\u2756 \u2756\n0 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n0 \u2744\u2744\n\u2744\u2744 \u2744\u2744\n\u2744\nDefinition 3.3 The hardness hd : CLS \u2192 N0 is defined for F \u2208 CLS as follows:\n1. If F \u2208 USAT , then hd(F ) is the minimum hs(T ) for T : F \u22a2 \u22a5.\n2. If F = \u22a4, then hd(F ) := 0.\n3. If F \u2208 SAT \\ {\u22a4}, then hd(F ) := max\u03d5\u2208PASS{hd(\u03d5 \u2217 F ) : \u03d5 \u2217 F \u2208 USAT }.\nHardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38]. Definition 3.3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):\nLemma 3.4 Consider the reductions rk : CLS \u2192 CLS for k \u2208 N0 as introduced in [53]; it is r1 unit-clause propagation, while r2 is (full, iterated) failed-literal elimination. Then hd(F ) for F \u2208 CLS is the minimal k \u2208 N0 such that for all \u03d5 \u2208 PASS with \u03d5 \u2217F \u2208 USAT holds rk(\u03d5 \u2217F ) = {\u22a5}, i.e., the minimal k such that rk detects unsatisfiability of any instantiation.\nWe can now define our main hierarchy, the UCk-hierarchy (with \u201cUC\u201d for \u201cunitrefutation complete\u201d) via (tree-)hardness:\nDefinition 3.5 For k \u2208 N0 let UCk := {F \u2208 CLS : hd(F ) \u2264 k}.\nUC1 = UC is the class of unit-refutation complete clause-sets, as introduced in [26]. In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]). Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k \u2265 1. The class UC2 is the class of all clause-sets where unsatisfiability for any partial assignment is detected by failed-literal reduction (see Section 5.2.1 in [42] for the usage of failed literals in SAT solvers).\nA basic fact is that the classes UCk are stable under application of partial assignments, in other words, for F \u2208 CLS and \u03d5 \u2208 PASS we have hd(\u03d5\u2217F ) \u2264 hd(F ). For showing lower bounds on the hardness for unsatisfiable clause-sets, we can use the methodology developed in Subsection 3.4.2 of [53]. A simplified version of Lemma 3.17 from [53], sufficient for our purposes, is as follows (with a technical correction, as explained in Example 3.7):\nLemma 3.6 Consider C \u2286 USAT and a function h : C \u2192 N0. For k \u2208 N0 let Ck := {F \u2208 C : h(F ) \u2265 k}. Then \u2200F \u2208 C : hd(F ) \u2265 h(F ) holds if and only if UC0 \u2229 C1 = \u2205, and for all k \u2208 N, F \u2208 Ck and x \u2208 lit(F ) there exist clause-sets F0, F1 \u2208 CLS fulfilling the following three conditions:\n(i) n(F\u03b5) < n(F ) for both \u03b5 \u2208 {0, 1};\n(ii) hd(F\u03b5) \u2264 hd(\u3008x \u2192 \u03b5\u3009 \u2217 F ) for both \u03b5 \u2208 {0, 1};\n(iii) F0 \u2208 Ck or F1 \u2208 Ck\u22121.\nProof: The given conditions are necessary for \u2200F \u2208 C : hd(F ) \u2265 h(F ), since we can choose F\u03b5 := \u3008v \u2192 \u03b5\u3009 \u2217 F for \u03b5 \u2208 {0, 1}. To see sufficiency, assume for the sake of contradiction that there is F \u2208 C with hd(F ) < h(F ), and consider such an F with minimal n(F ). If hd(F ) = 0, so h(F ) = 0 by assumption, and thus hd(F ) \u2265 1 would hold. So assume hd(F ) \u2265 1. It follows that there is a literal x \u2208 lit(F ) with hd(\u3008x \u2192 1\u3009 \u2217 F ) < hd(F ). Let k := h(F ); so F \u2208 Ck. By assumption there are F0, F1 \u2208 CLS with hd(F\u03b5) \u2264 hd(\u3008x \u2192 \u03b5\u3009 \u2217 F ) for both \u03b5 \u2208 {0, 1}, and F0 \u2208 Ck or F1 \u2208 Ck\u22121. If F0 \u2208 Ck, then hd(F0) \u2264 hd(F ) < k \u2264 h(F0), while n(F0) < n(F ), contradicting minimality of F . And if F1 \u2208 Ck\u22121, then hd(F1) \u2264 hd(F ) \u2212 1 < k \u2212 1 \u2264 h(F1), while n(F1) < n(F ), contradicting again minimality of F .\nLemma 3.17 in [53] doesn\u2019t state the condition (i) from Lemma 3.6. The following example shows that this condition actually needs to be stated (that is, if we just have (ii) and (iii), then h doesn\u2019t need to be a lower bound for hd); fortunately in all applications in [53] this (natural) condition is fulfilled.\nExample 3.7 Consider C := UC1 \u2229 USAT . Define h : C \u2192 {0, 1, 2} as h(F ) = 0 iff \u22a5 \u2208 F , and h(F ) = 1 iff \u22a5 /\u2208 F and there is v \u2208 var(F ) with {v}, {v} \u2208 F . So we have h(F ) = 2 if and only if for all literals x \u2208 lit(F ) holds hd(\u3008x \u2192 1\u3009 \u2217 F ) = hd(\u3008x \u2192 0\u3009 \u2217F ) = 1. By definition we have UC0 \u2229C1 = \u2205. Now consider k \u2208 {1, 2}, F \u2208 Ck and x \u2208 lit(F ). If h(F ) = 1, then let F\u03b5 := \u3008x \u2192 \u03b5\u3009 \u2217 F , while otherwise F\u03b5 := F for \u03b5 \u2208 {0, 1}. Now Conditions (ii), (iii) of Lemma 3.6 are fulfilled (if h(F ) = 1, then for Condition (iii) always F1 \u2208 Ck\u22121 holds, while in case of h(F ) = 2 we always have F0 \u2208 Ck). But by definition h is not a lower bound on hd.\nComplementary to \u201cunit-refutation completeness\u201d, there is the notion of \u201cpropagation-completeness\u201d as investigated in [69, 15], yielding the class PC \u2282 UC. This was captured and generalised by a measure phd : CLS \u2192 N0 of \u201cpropagationhardness\u201d along with the associated hierarchy, defined in [37, 38] as follows:\nDefinition 3.8 For F \u2208 CLS we define the propagation-hardness (for short \u201cp-hardness\u201d) phd(F ) \u2208 N0 as the minimal k \u2208 N0 such that for all partial assignments \u03d5 \u2208 PASS we have rk(\u03d5 \u2217 F ) = r\u221e(\u03d5 \u2217 F ), where rk : CLS \u2192 CLS is generalised UCP ([53, 59]), and r\u221e : CLS \u2192 CLS applies all forced assignments, and can be defined by r\u221e(F ) := rn(F )(F ). For k \u2208 N0 let PCk := {F \u2208 CLS : phd(F ) \u2264 k} (the class of propagation-complete clause-sets of level k).\nWe have PC = PC1. For k \u2208 N0 we have PCk \u2282 UCk \u2282 PCk+1.\n3.2 W-Hardness and WCk A basic weakness of the standard notion of width-restricted resolution, which demands that both parent clauses must have length at most k for some fixed k \u2208 N0 (the \u201cwidth\u201d; see [7]), is that even Horn clause-sets require unbounded width in this sense. The correct solution, as investigated and discussed in [53, 59], is to use the notion of \u201ck-resolution\u201d as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution). Nested input-resolution ([53, 59]) is the proof-theoretic basis of hardness, and approximates tree-resolution. In the same vein, k-resolution is the proof-theoretic basis of \u201cw-hardness\u201d, and approximates dag-resolution (see Theorem 6.12 in [59]):\nDefinition 3.9 The w-hardness whd : CLS \u2192 N0 (\u201cwidth-hardness\u201d) is defined for F \u2208 CLS as follows:\n1. If F \u2208 USAT , then whd(F ) is the minimum k \u2208 N0 such that k-resolution refutes F , that is, such that T : F \u22a2 \u22a5 exists where for each resolution step R = C \u22c4D in T we have |C| \u2264 k or |D| \u2264 k (this corresponds to Definition 8.2 in [53], and is a special case of widU introduced in Subsection 6.1 of [59]).\n2. If F = \u22a4, then whd(F ) := 0. 3. If F \u2208 SAT \\ {\u22a4}, then whd(F ) := max\n\u03d5\u2208PASS {whd(\u03d5 \u2217 F ) : \u03d5 \u2217 F \u2208 USAT }.\nFor k \u2208 N0 let WCk := {F \u2208 CLS : whd(F ) \u2264 k}.\nWe haveWC0 = UC0, WC1 = UC1, and for all k \u2208 N0 holds UCk \u2286 WCk (this follows by Lemma 6.8 in [59] for unsatisfiable clause-sets, which extends to satisfiable clausesets by definition). For unsatisfiable F , whether whd(F ) = k holds for k \u2208 {0, 1, 2} can be decided in polynomial time; this is non-trivial for k = 2 ([17]) and unknown for k > 2. Nevertheless, the clausal entailment problem F |= C for F \u2208 WCk and fixed k \u2208 N0 is decidable in polynomial time, as shown in Subsection 6.5 of [59], by actually using a slight strengthening of k-resolution, which combines width-bounded resolution and input resolution. While space-complexity of the decision F |= C for F \u2208 UCk is linear (for fixed k), now for WCk space-complexity is O(\u2113(F )\u00b7n(F )O(k)).\nAs a special case of Theorem 6.12 in [59] we obtain for F \u2208 USAT , n(F ) 6= 0, the following general lower bound on resolution complexity:\nCompR(F ) > b whd(F )2 n(F ) ,\nwhere b := e 1 8 = 1.1331484 . . ., while CompR(F ) \u2208 N is the minimal number of different clauses in a (tree-)resolution refutation of F . Similar to Theorem 14 in [36] resp. Theorem 5.7 in [37, 38] we thus obtain:\nLemma 3.10 For F \u2208 CLS and k \u2208 N0, such that for every C \u2208 prc0(F ) with |C| < n(F ) there exists a resolution proof of C from F using at most b (k+1)2 n(F )\u2212|C| different clauses, we have whd(F ) \u2264 k."}, {"heading": "4 Minimal premise sets and doped clause-sets", "text": "In this section we study \u201cminimal premise sets\u201d, \u201cmps\u2019s\u201d for short, introduced in [62], together with the properties of \u201cdoped\u201d clause-sets, generalising a construction used in [75]. Mps\u2019s are generalisations of minimally unsatisfiable clause-sets stronger than irredundant clause-sets, while doping relates prime implicates and sub-mps\u2019s.\nRecall that a clause-set F is minimally unsatisfiable if F \u2208 USAT , while for all C \u2208 F holds F \\ {C} \u2208 SAT . The set of all minimally unsatisfiable clause-sets is MU \u2282 CLS; see [52] for more information. In other words, for F \u2208 CLS we have F \u2208 MU if and only if F |= \u22a5 and F is minimal regarding this entailment relation. Now an mps is a clause-set F which minimally implies some clause C, i.e., F |= C, while F \u2032 6|= C for all F \u2032 \u2282 F . In Subsection 4.1 we study the basic properties of mps\u2019s F , and determine the unique minimal clause implied by F as puc(F ), the set of pure literals of F .\nFor a clause-set F its doped version D(F ) \u2208 CLS receives an additional new (\u201cdoping\u201d) variable for each clause. The basic properties are studied in Subsection 4.2, and in Theorem 4.18 we show that the prime implicates of D(F ) correspond 1-1 to the mps\u2019s contained in F . In Subsection 4.3 we determine the hardness of doped clause-sets."}, {"heading": "4.1 Minimal premise sets", "text": "In Section 4.1 in [62] basic properties of minimal premise sets are considered:\nDefinition 4.1 A clause-set F \u2208 CLS is a minimal premise set (\u201cmps\u201d) for a clause C \u2208 CL if F |= C and \u2200F \u2032 \u2282 F : F \u2032 6|= C, while F is a minimal premise set if there exists a clause C such that F is a minimal premise set for C. The set of all minimal premise (clause-)sets is denoted by MPS.\nRemarks:\n1. \u22a4 is not an mps (since no clause follows from \u22a4).\n2. An unsatisfiable clause-set is an mps iff it is minimally unsatisfiable, i.e., MPS \u2229 USAT = MU . In Corollary 4.8 we will see that the minimally unsatisfiable clause-sets are precisely the mps\u2019s without pure literals.\n3. Every minimal premise clause-set is irredundant (no clause follows from the other clauses).\n4. For a clause-set F and any implicate F |= C there exists a minimal premise sub-clause-set F \u2032 \u2286 F for C.\n5. A single clause C yields an mps {C}.\n6. Two clauses C 6= D yield an mps {C,D} iff C,D are resolvable.\n7. If F1, F2 \u2208 MPS with var(F1)\u2229 var(F2) = \u2205, then F1 \u222aF2 /\u2208 MPS except in case of F1 = F2 = {\u22a5}.\nExample 4.2 {{a}, {b}} for variables a 6= b is irredundant but not an mps.\nWith Corollary 4.5 in [62] we see that no clause-set can minimally entail more than one clause:\nLemma 4.3 For F \u2208 MPS there exists exactly one C \u2208 prc0(F ) such that C is a minimal premise set for C, and C is the smallest element of the set of clauses for which F is a minimal premise set.\nWe remark that Lemma 4.3 does not mean that |prc0(F )| = 1 for F \u2208 MPS; indeed, F can have many F \u2032 \u2282 F with F \u2032 \u2208 MPS, and each such F \u2032 might contribute a prime implicate, as we will see later. We wish now to determine that unique prime implicate C which follows minimally from an mps F . It is clear that C must contain all pure literals from F , since all clauses of F must be used, and we can not get rid off pure literals.\nDefinition 4.4 For F \u2208 CLS the pure clause of F , denoted by puc(F ) \u2208 CL, is the set of pure literals of F , that is, puc(F ) := L \\ (L \u2229 L), where L := \u22c3F is the set of literals occurring in F .\nExample 4.5 For F = {{a, b}, {a, c}} we have puc(F ) = {b, c}.\nThe main observation for determining C is that the conclusion of a regular resolution proof consists precisely of the pure literals of the axioms (this follows by definition):\nLemma 4.6 For a regular resolution proof T : F \u22a2 C, where every clause of F is used in T , we have C = puc(F ).\nDue to the completeness of regular resolution we thus see, that puc(F ) is the desired unique prime implicate:\nLemma 4.7 For F \u2208 MPS the unique prime implicate C, for which F is a minimal premise set (see Lemma 4.3), is C = puc(F ).\nProof: Consider a regular resolution proof T : F \u22a2 C (recall that regular resolution is complete); due to F \u2208 MPS every clause of F must be used in T , and thus the assertion follows by Lemma 4.6.\nCorollary 4.8 If we have F \u2208 MPS with puc(F ) = \u22a5, then F \u2208 MU.\nBy Lemma 4.4 in [62] we get the main characterisation of mps\u2019s, namely that after elimination of pure literals they must be minimally unsatisfiable:\nLemma 4.9 Consider a clause-set F \u2208 CLS. Then F \u2208 MPS if and only if the following two conditions hold for \u03d5 := \u03d5puc(F ) (setting precisely the pure literals of F to false):\n1. \u03d5\u2217F \u2208 MU (after removing the pure literals we obtain a minimal unsatisfiable clause-sets).\n2. \u03d5 is contraction-free for F , that is, for clauses C,D \u2208 F with C 6= D we have \u03d5 \u2217 {C} 6= \u03d5 \u2217 {D}.\nThese two conditions are equivalent to stating that \u03d5 \u2217 F as a multi-clause-set (not contracting equal clauses) is minimally unsatisfiable.\nThus we obtain all mps\u2019s by considering some minimally unsatisfiable clause-sets and adding new variables in the form of pure literals:\nCorollary 4.10 The following process generates precisely the F \u2032 \u2208 MPS:\n1. Choose F \u2208 MU .\n2. Choose a clause P with var(P ) \u2229 var(F ) = \u2205 (\u201cP\u201d like \u201cpure\u201d).\n3. Choose a map e : F \u2192 P(P ) (\u201ce\u201d like \u201cextension\u201d).\n4. Let F \u2032 := {C \u222a e(C) : C \u2208 F}. For unsatisfiable clause-sets the set of minimally unsatisfiable sub-clause-sets has been studied extensively in the literature; see [66] for a recent overview. The set of subsets which are mps\u2019s strengthen this notion (now for all clause-sets):\nDefinition 4.11 For a clause-set F \u2208 CLS by mps(F ) \u2282 CLS the set of all minimal premise sub-clause-sets is denoted: mps(F ) := P(F ) \u2229MPS.\nWe have |mps(F )| \u2264 2c(F )\u22121.5) The minimal elements of mps(F ) are {C} \u2208 mps(F ) for C \u2208 F . Since every prime implicate of a clause-set has some minimal premise sub-clause-set, we get that running through all sub-mps\u2019s in a clause-set F and extracting the clauses with the pure literals we obtain at least all prime implicates:\nLemma 4.12 For F \u2208 CLS the map F \u2032 \u2208 mps(F ) 7\u2192 puc(F \u2032) \u2286 {C \u2208 CL : F |= C} covers prc0(F ) (i.e., its range contains the prime implicates of F ).\nExample 4.13 Examples where we have more minimal premise sub-clause-sets than prime implicates are given by F \u2208 MU , where prc0(F ) = {\u22a5}, while in the most extreme case every non-empty subset of F can be a minimal premise subclause-set (see Theorem 5.12)."}, {"heading": "4.2 Doping clause-sets", "text": "\u201cDoping\u201d is the process of adding a unique new variable to every clause of a clauseset. It enables us to follow the usage of this clause in derivations:\nDefinition 4.14 For every clause-set F \u2208 CLS we assume an injection uF : F \u2192 VA\\var(F ) in the following, assigning to every clause C a different variable uFC. For a clause C \u2208 CL and a clause-set F \u2208 CLS we then define the doping DF (C) := C \u222a {uFC} \u2208 CL, while D(F ) := {DF (C) : C \u2208 F} \u2208 CLS.\nRemarks:\n1. In the following we drop the upper index in \u201cuFC\u201d, i.e., we just use \u201cuC\u201d.\n2. We have D : CLS \u2192 SAT .\n3. For F \u2208 CLS we have n(D(F )) = n(F ) + c(F ) and c(D(F )) = c(F ).\n4. For F \u2208 CLS we have puc(D(F )) = puc(F ) \u222a {uC : C \u2208 F}. We are interested in the prime implicates of doped clause-sets. It is easy to see that all doped clauses are themselves essential prime implicates:\nLemma 4.15 For F \u2208 CLS we have D(F ) \u2286 prc0(D(F )), and furthermore all elements of D(F ) are essential prime implicates.\nProof: Every resolvent of clauses from D(F ) contains at least two doping variables, and thus the clauses of D(F ) themselves (which contain only one doping variable) are prime and necessary. Thus by Lemma 2.3 among all the clause-sets equivalent to D(F ) this clause-set itself is the smallest. Directly by Lemma 4.9 we get that a clause-set is an mps iff its doped form is an mps:\n5)There is a typo in Corollary 4.6 of [62], misplacing the \u201c\u22121\u201d into the exponent.\nLemma 4.16 For F \u2208 CLS holds F \u2208 MPS \u21d4 D(F ) \u2208 MPS. Thus the map F \u2032 \u2208 mps(F ) 7\u2192 D(F \u2032) is a bijection from mps(F ) to mps(D(F )).\nFor doped clause-sets the surjection of Lemma 4.12 is bijective:\nLemma 4.17 Consider a clause-set F \u2208 CLS, and let G := D(F ).\n1. The map F \u2032 \u2208 mps(G) 7\u2192 puc(F \u2032) \u2208 CL is a bijection from mps(G) to prc0(G).\n2. The inverse map from prc0(G) to mps(G) obtains from C \u2208 prc0(G) the clause-set F \u2032 \u2208 mps(G) with puc(F \u2032) = C as F \u2032 = {D(D) : D \u2208 F \u2227 uD \u2208 var(C)}.\nProof: By Lemma 4.12 it remains to show that the map of Part 1 is injective and does not have subsumptions in the image. Assume for the sake of contradiction there are G\u2032, G\u2032\u2032 \u2208 mps(G), G\u2032 6= G\u2032\u2032, with puc(G\u2032) \u2286 puc(G\u2032\u2032). Since every clause of F has a different doping-variable, G\u2032 \u2282 G\u2032\u2032 must hold. Consider the F \u2032, F \u2032\u2032 \u2208 mps(F ) with D(F \u2032) = G\u2032 and D(F \u2032\u2032) = G\u2032\u2032. We have F \u2032 \u2282 F \u2032\u2032, and thus puc(F \u2032) 6\u2286 puc(F \u2032\u2032), since for every F \u2208 MPS the clause puc(F ) is a prime implicate of F . It follows that puc(G\u2032) 6\u2286 puc(G\u2032\u2032), contradicting the assumption.\nBy Lemma 4.16 and Lemma 4.17 we obtain:\nTheorem 4.18 Consider F \u2208 CLS. Then the map F \u2032 \u2208 mps(F ) 7\u2192 puc(D(F \u2032)) \u2208 CL is a bijection from mps(F ) to prc0(D(F )).\nTheorem 4.18 together with the description of the inversion map in Lemma 4.17 yields computation of the set mps(F ) for F \u2208 CLS via computation of prc0(D(F )).\nCorollary 4.19 For F \u2208 CLS we obtain a map from prc0(D(F )) to the set of implicates of F covering prc0(F ) by the mapping C \u2208 prc0(D(F )) 7\u2192 C \\ V for V := {uC : C \u2208 F}.\nProof: The given map can be obtained as a composition as follows: For C \u2208 prc0(D(F )) take (the unique) F\n\u2032 \u2208 mps(F ) with puc(D(F \u2032)) = C, and we have C \\ V = puc(F \u2032)."}, {"heading": "4.3 Hardness of doped clause-sets", "text": "The hardness of a doped clause-set is the maximal hardness of sub-clause-sets of the original clause-set:\nLemma 4.20 For F \u2208 CLS we have hd(D(F )) = maxF \u2032\u2286F hd(F \u2032).\nProof: We have hd(F \u2032) \u2264 hd(D(F )) for all F \u2032 \u2286 F , since via applying a suitable partial assignment we obtain F \u2032 from F , setting the doping-variables in F \u2032 to false, and the rest to true. And if we consider an arbitrary partial assignment \u03d5 with \u03d5\u2217D(F ) \u2208 USAT , then w.l.o.g. all doping variables are set (we can set the dopingvariables not used by \u03d5 to true, since these variables are all pure), and then we have a partial assignment making F \u2032 unsatisfiable for that F \u2032 \u2208 USAT given by all the doping variables set by \u03d5 to false.\nExample 4.21 For an example of a clause-set F \u2208 USAT with hd(D(F )) > hd(F ) consider any clause-set F \u2032 \u2208 CLS with hd(F \u2032) > 0, and then take F := F \u2032 \u222a {\u22a5} (note that \u22a5 /\u2208 F \u2032). Thus hd(F ) = 0. And by Part 1 of Lemma 6.5 in [37, 38], all UCk are closed under partial assignments, so for \u03d5 := \u3008u\u22a5 \u2192 1\u3009\u222a\u3008uC \u2192 0 | C \u2208 F \u2032\u3009 we have hd(D(F )) \u2265 hd(\u03d5 \u2217D(F )) = hd(F \u2032) > hd(F ) = 0."}, {"heading": "5 Doping tree clause-sets", "text": "As explained in Subsection 1.5, we want to construct boolean functions (given by clause-sets) with a large number of prime implicates, and where we have strong control over these prime implicates. For this purpose we dope \u201cminimally unsatisfiable clause-sets of deficiency 1\u201d, that is the elements of SMU\u03b4=1. First we review in Subsection 5.1 the background (for more information see [52]). In Subsection 5.2 we show that these clause-sets are the core of \u201ctotal minimal premise sets\u201d, which have as many minimal-premise sub-clause-sets as possible. In Theorem 5.12 we show that F \u2208 SMU\u03b4=1 are precisely the unsatisfiable clause-sets such that every non-empty subset is an mps. Then in Subsection 5.3 we consider doping of these special clause-sets, and in Theorem 5.22 we determine basic properties of D(F )."}, {"heading": "5.1 Preliminaries on minimal unsatisfiability", "text": "A minimally unsatisfiable F \u2208 MU is saturated minimally unsatisfiable iff for all clauses C \u2208 F and for every literal x with var(x) /\u2208 var(C) the clause-set (F \\C) \u222a (C \u222a {x}) is satisfiable. The set of all saturated minimally unsatisfiable clause-sets is denoted by SMU \u2282 MU . By SMU\u03b4=k we denote the set of F \u2208 SMU with \u03b4(F ) = k, where the deficiency of a clause-set F is given by \u03b4(F ) := c(F )\u2212 n(F ). In [56] (generalised in [62]) it is shown that the elements of SMU\u03b4=1 are exactly the clause-sets introduced in [21]. The details are as follows. For rooted trees T we use nds(T ) for the set of nodes and lvs(T ) \u2286 lvs(T ) for the set of leaves, and we set #nds(T ) := |nds(T )| and #lvs(T ) := |lvs(T )|. In our context, the nodes of rooted trees are just determined by their positions, and do not have names themselves. Another useful notation for a tree T and a node w is Tw, which is the sub-tree of T with root w; so lvs(T ) = {w \u2208 nds(T ) : #nds(Tw) = 1}. Recall that for a full binary tree T (every non-leaf node has two children) we have #nds(T ) = 2#lvs(T )\u2212 1.\nDefinition 5.1 Consider a full binary tree T and an injective vertex labelling u : (nds(T ) \\ lvs(T )) \u2192 VA for the inner nodes; the set of all such pairs is denoted by T1. The induced edge-labelling assigns to every edge from an inner node w to a child w\u2032 the literal u(w) resp. u(w) for a left resp. right child. We define the clause-set representation F1(T, u) (where \u201c1\u201d reminds of deficiency 1 here; see Lemma 5.2) to be F1(T, u) := {Cw : w \u2208 lvs(T )}, where clause Cw consists of all the literals (i.e., edge-labels) on the path from the root of T to w.\nBy Lemma C.5 in [56]:\nLemma 5.2 F1 : T1 \u2192 SMU\u03b4=1 is a bijection.\nBy T1 : SMU\u03b4=1 \u2192 T1 we denote the inversion of F1. Typically we identify (T, u) \u2208 T1 with T , and let the context determine u. So T1(F ) is the full binary tree, where the variable v labelling the root (for F 6= {\u22a5}) is the unique variable occurring in every clause of F , and the clause-sets determining the left resp. right subtree are \u3008v \u2192 0\u3009\u2217F resp. \u3008v \u2192 1\u3009\u2217F . By wC for C \u2208 F we denote the leaf w of T1(F ) such that Cw = C. Furthermore we identify the literals of F with the edges of T1(F ). Note that c(F ) = #lvs(T1(F )) and n(F ) = #nds(T1(F ))\u2212#lvs(T1(F )).\nExample 5.3 Consider the following labelled binary tree T :\nv1\nv2\nv1 \u2666\u2666\u2666 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\u2666 \u2666\nv3\nv2 \u2666\u2666\u2666 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\u2666\u2666\n1\nv3 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n2\nv3\n\u2744\u2744 \u2744\u2744\n\u2744\u2744 \u2744 v4\nv2\n\u2756\u2756\u2756 \u2756\u2756\u2756\n\u2756\u2756\u2756 \u2756\u2756\u2756\n3\nv4 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n4\nv4\n\u2744\u2744 \u2744\u2744\n\u2744\u2744 \u2744\nv5\nv1\n\u2756\u2756\u2756 \u2756\u2756\u2756\n\u2756\u2756 \u2756\u2756\u2756\n\u2756\n5\nv5 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n6\nv5\n\u2744\u2744 \u2744\u2744\n\u2744\u2744 \u2744\nThen F1(T ) = {{v1, v2, v3}, {v1, v2, v3}, {v1, v2, v4}, {v1, v2, v4}, {v1, v5}, {v1, v5}}, where for example C3 = {v1, v2, v4} and w{v1,v5} = 6.\nWe note in passing, that those F1(T ) with hs(T ) \u2264 1 can be easily characterised as follows. A clause C \u2208 F for F \u2208 CLS is called full if var(C) = var(F ), that is, C contains all variables of F .\nLemma 5.4 F \u2208 SMU\u03b4=1 contains a full clause if and only if hs(T1(F )) \u2264 1.\nSee Example 6.10 for more on these special clause-sets. The effect of applying a partial assignment to some element of SMU\u03b4=1 is easily described as follows:\nLemma 5.5 Consider F \u2208 SMU\u03b4=1 and x \u2208 lit(F ), and let F \u2032 := \u3008x \u2192 1\u3009 \u2217 F . We have:\n1. F \u2032 \u2208 SMU\u03b4=1.\n2. Let T := T1(F ) and T \u2032 := T1(F \u2032). The tree T \u2032 is obtained from T as follows:\n(a) Consider the node w \u2208 T labelled with var(x). Let Tx, Tx be the two subtrees hanging at w, following the edge labelled with x resp. x. (b) Now T \u2032 is obtained from T \u2032 by removing subtree Tx, and attaching Tx directly at position w.\nExample 5.6 Consider the labelled binary tree T from Example 5.3 where\nF1(T ) = {{v1, v2, v3} \ufe38 \ufe37\ufe37 \ufe38\nC1\n, {v1, v2, v3} \ufe38 \ufe37\ufe37 \ufe38\nC2\n, {v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\nC3\n, {v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\nC4\n, {v1, v5} \ufe38 \ufe37\ufe37 \ufe38\nC5\n, {v1, v5} \ufe38 \ufe37\ufe37 \ufe38\nC6\n}\nNow consider the application of the partial assignment \u3008v2 \u2192 1\u3009 to F1(T ):\n1. Clauses C1 and C2 are satisfied, and so are removed (both contain v2).\n2. Clauses C3 and C4 both contain v2 and so this literal is removed.\nThis yields:\n\u3008v2 \u2192 1\u3009 \u2217 F1(T ) = { {v1, v4} \ufe38 \ufe37\ufe37 \ufe38\nC3 \\ {v2}\n, {v1, v4} \ufe38 \ufe37\ufe37 \ufe38\nC4 \\ {v2}\n, {v1, v5} \ufe38 \ufe37\ufe37 \ufe38\nC5\n, {v1, v5} \ufe38 \ufe37\ufe37 \ufe38\nC6\n}\nThe satisfaction (removal) of clauses and removal of literals is illustrated directly on T in Figure 1 with dotted and dashed lines for clause and literal removal respectively. The tree corresponding to \u3008v2 \u2192 1\u3009 \u2217 F1(T ) is illustrated in Figure 2.\nCorollary 5.7 SMU\u03b4=1 is stable under application of partial assignments, that is, for F \u2208 SMU\u03b4=1 and \u03d5 \u2208 PASS holds \u03d5 \u2217 F \u2208 SMU\u03b4=1.\nFrom Lemma 5.2 follows SMU\u03b4=1 \u2282 UHIT , where HIT \u2282 CLS is the set of hitting clause-sets, that is, those F \u2208 CLS where every two clauses clash in at least one literal, i.e., for all C,D \u2208 F , C 6= D, we have |C \u2229 D| \u2265 1, and UHIT := HIT \u2229USAT . It is well-known that UHIT \u2282 SMU holds (for a proof see Lemma 2 in [63])."}, {"heading": "5.2 Total minimal premise sets", "text": "We are interested in clause-sets which have as many sub-mps\u2019s as possible:\nDefinition 5.8 A clause-set F 6= \u22a4 is a total mps if mps(F ) = P(F ) \\ {\u22a4}.\nEvery total mps is an mps.\nExample 5.9 {{a, b}, {a, b}, {b}} is a total mps, while {{a, b}, {a}, {b}} is an mps (since minimally unsatisfiable), but not a total mps.\nTo determine all total mps\u2019s, the central task to determine the minimally unsatisfiable total mps\u2019s. Before we can prove that these are precisely the saturated minimally unsatisfiable clause-sets of deficiency 1, we need to state a basic property of these clause-sets, which follows by definition of T1(F ) for F \u2208 SMU\u03b4=1 (recall Subsection 5.1):\nLemma 5.10 Consider F \u2208 SMU\u03b4=1 and F \u2032 \u2286 F . Let T := T1(F ). The set puc(F \u2032) of pure literals of F \u2032 can be determined as follows:\n1. Let WF \u2032 := {wC : C \u2208 F \u2032} \u2286 lvs(T ) be the set of leaves corresponding to the clauses of F \u2032.\n2. For a literal x \u2208 lit(F ) let w \u2208 nds(T ) be the node labelled with var(x), and let Tx the the subtree of w reached by x, and let Tx be the subtree of w reached by x.\n3. Now x \u2208 puc(F \u2032) if and only if WF \u2032 \u2229 lvs(Tx) 6= \u2205 and WF \u2032 \u2229 lvs(Tx) = \u2205.\nExample 5.11 Consider the clause-set\nF := { {v1, v2, v3} \ufe38 \ufe37\ufe37 \ufe38\nC1\n, {v1, v2, v3} \ufe38 \ufe37\ufe37 \ufe38\nC2\n, {v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\nC3\n, {v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\nC4\n,\n{v1, v5, v6} \ufe38 \ufe37\ufe37 \ufe38\nC5\n, {v1, v5, v6} \ufe38 \ufe37\ufe37 \ufe38\nC6\n, {v1, v5} \ufe38 \ufe37\ufe37 \ufe38\nC7\n}\nand the subset F \u2032 := {C1, C3, C4, C7}. The tree T1(F ) is as follows, with the dashed edges representing literals not in \u22c3 F \u2032 = {v1, v2, v3, v4, v1, v2, v4, v5}:\nv1\nv2\nv1\n\u2765\u2765\u2765 \u2765\u2765\u2765\n\u2765\u2765\u2765 \u2765\u2765\u2765\n\u2765\u2765\u2765 \u2765\nv3\nv2\n\u2666\u2666\u2666 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\u2666\n1\nv3 \u2467\u2467 \u2467\u2467 \u2467\u2467\n2\nv3\n\u2744 \u2744\n\u2744 v4\nv2\n\u2756\u2756\u2756 \u2756\u2756\u2756\n\u2756\u2756\u2756 \u2756\u2756\n3\nv4 \u2467\u2467 \u2467\u2467 \u2467\u2467\n4\nv4 \u2744\u2744 \u2744\u2744\n\u2744\u2744\nv5\nv1\n\u275a\u275a\u275a \u275a\u275a\u275a\n\u275a\u275a\u275a \u275a\u275a\u275a\n\u275a\u275a\u275a \u275a\nv6\nv5 \u2467 \u2467 \u2467\n5\nv6 \u2467 \u2467 \u2467\n6\nv6\n\u2744 \u2744\n\u2744 7\nv5 \u2744\u2744 \u2744\u2744\n\u2744\u2744\nWe have WF \u2032 = {1, 3, 4, 7} and\npuc(F \u2032) = \u22c3\nF \u2032 \\ { v2, v2 \ufe38 \ufe37\ufe37 \ufe38\nC1, C3\n, v1, v1 \ufe38 \ufe37\ufe37 \ufe38\nC1, C7\n, v4, v4 \ufe38 \ufe37\ufe37 \ufe38\nC3, C4\n} = {v3, v5}.\nNow consider x \u2208 lit(F ):\n1. For x = v3 holds lvs(Tv3)\u2229WF \u2032 = {1} and Tv3 \u2229WF \u2032 = \u2205, thus v3 \u2208 puc(F \u2032).\n2. For x = v5 holds lvs(Tv5)\u2229WF \u2032 = {7} and Tv5 \u2229WF \u2032 = \u2205, thus v5 \u2208 puc(F \u2032).\n3. Considering for example x = v1, we have lvs(Tv1)\u2229WF \u2032 = {1, 3} and lvs(Tv1)\u2229 WF \u2032 = {7}, thus v1 /\u2208 puc(F \u2032), while for x = v6 we have lvs(Tv6) \u2229WF \u2032 = \u2205 and lvs(Tv6) \u2229WF \u2032 = \u2205, thus v6 /\u2208 puc(F \u2032).\nTheorem 5.12 An unsatisfiable clause-set F \u2208 USAT is a total mps if and only if F \u2208 SMU\u03b4=1.\nProof: First assume that F is a total mps. Then every two clauses C,D \u2208 F , C 6= D, clash in exactly one literal (otherwise {C,D} /\u2208 MPS). In [58], Corollary 34, it was shown that that an unsatisfiable clause-sets F has precisely one clash between any pair of different clause-sets iff F \u2208 SMU\u03b4=1 holds (an alternative proof was found in [75]).6) Now assume F \u2208 SMU\u03b4=1, and we have to show that F\n6)In [58] the notation \u201cUHIT \u201d was used to denote \u201cuniform hitting clause-sets\u201d, which is now more appropriately called \u201c(conflict-)regular hitting clause-sets\u201d, while \u201cU\u201d now stands for \u201cunsatisfiable\u201d.\nis a total mps. So consider F \u2032 \u2208 P(F ) \\ {\u22a4}, and let C := puc(F ), \u03d5 := \u03d5C . Since F \u2032 is a hitting clause-set, \u03d5 is contraction-free for F \u2032, and according to Lemma 4.9 it remains to show that F \u2032\u2032 := \u03d5 \u2217 F \u2032 is unsatisfiable (recall that hitting clause-sets are irredundant). Assume that F \u2032\u2032 is satisfiable, and consider a partial assignment \u03c8 with \u03c8 \u2217 F \u2032\u2032 = \u22a4 and var(\u03c8) \u2229 var(\u03d5) = \u2205. We show that then \u03d5 \u222a \u03c8 would be a satisfying assignment for F , contradicting the assumption. To this end it suffices to show that for all D \u2208 F \\ F \u2032 holds C \u2229D 6= \u2205. Consider T := T1(F ), and let WF \u2032 be defined as in Lemma 5.10. Starting from the leaf wD, let w be the first node on the path to the root of T such that one of the two subtrees of w contains a leaf of WF \u2032 . Let x be the literal at w on the path to wD. So by Lemma 5.10 we have x \u2208 C, while by definition x \u2208 D.\nCorollary 5.13 For a clause-set F \u2208 CLS the following properties are equivalent:\n1. F is a total mps.\n2. \u03d5puc(F ) \u2217 F \u2208 SMU\u03b4=1, and \u03d5puc(F ) is contraction-free for F .\nProof: Let F \u2032 := \u03d5puc(F ) \u2217 F . If F is a total mps, then by Lemma 4.9 follows F \u2032 \u2208 MU , where \u03d5puc(F ) is contraction-free for F . Also by Lemma 4.9 follows then, that F \u2032 \u2208 MPS, and thus by Theorem 5.12 we obtain F \u2032 \u2208 SMU\u03b4=1. For the other direction, if F \u2032 \u2208 SMU\u03b4=1 holds, where \u03d5puc(F ) is contraction-free for F , then by Theorem 5.12 follows that F \u2032 is a total mps, which by Lemma 4.9 yields that F is a total mps.\nThus we can precisely construct all total mps\u2019s, if we start the process described in Corollary 4.10 not with an arbitrary F \u2208 MU , but with an F \u2208 SMU\u03b4=1.\nExample 5.14 That every 2-element sub-clause-set of F \u2208 CLS is an mps, that is, every two (different) clauses of F clash in precisely one literal, says that F is 1-regular hitting in the terminology of [62], Section 6. For F \u2208 USAT the proof of Theorem 5.12 shows, that F is a total mps iff F is 1-regular hitting. However for F \u2208 SAT this is not true, and the simplest example is F := {{a, b}, {b, c}, {c, a}}: F is 1-regular hitting, but has no pure literal and is satisfiable, and thus F /\u2208 MPS. In this case we have \u03b4(F ) = 0. For an interesting example with deficiency 1 see Section 5 in [58].\nWe arrive at a simple and perspicuous proof of the main result of [75], that the clause-sets F with |prc0(F )| = 2c(F ) \u2212 1 are precisely the clause-sets D(F ) for F \u2208 SMU\u03b4=1 when allowing to replace the single doping variable of a clause by any non-empty set of new (pure) literals:\nLemma 5.15 For F \u2208 CLS \\ {\u22a4} holds |prc0(F )| = 2c(F ) \u2212 1 if and only if the following two conditions hold:\n1. F is a total mps.\n2. For every clause C \u2208 F there is x \u2208 C such that var(x) /\u2208 var(F \\ {C}).\nProof: First assume |prc0(F )| = 2c(F ) \u2212 1. Thus the map F \u2032 \u2208 mps(F ) 7\u2192 puc(F \u2032) \u2286 {C \u2208 CL : F |= C}, which according to Lemma 4.12 covers prc0(F ), must indeed be a bijection from mps(F ) to prc0(F ), and hence F is a total mps (here we need F 6= \u22a4). If there would be C \u2208 F such that for all x \u2208 C we have var(x) \u2208 var(F \\ {C}), then puc(F ) \u2286 puc(F \\ {C}), and thus F \\ {C} could not yield a prime implicate different from the prime implicate obtained from F .\nThe inverse direction follows by the observation, that the existence of the unique \u201cdoping literals\u201d x \u2208 C has the consequence, that for \u22a4 \u2282 F \u2032, F \u2032\u2032 \u2286 F with F \u2032 6= F \u2032\u2032 we get puc(F \u2032) 6= puc(F \u2032\u2032), since these doping literals make a difference."}, {"heading": "5.3 Doping SMU\u03b4=1", "text": "We are turning now our attention to a closer understanding of the prime implicates C of doped F \u2208 SMU\u03b4=1. We start with their identification with non-empty subclause-sets F \u2032 of D(F ):\nLemma 5.16 Consider a clause-set F \u2208 SMU\u03b4=1. By Theorem 5.12 each nonempty subset yields a minimal premise set. Thus by Theorem 4.18 we have:\n1. prc0(D(F )) = {puc(F \u2032) | \u22a4 6= F \u2032 \u2286 D(F )}.\n2. |prc0(D(F ))| = 2c(F ) \u2212 1.\nSince the clauses of D(F ) can be identified with leaves of the tree T1(F ), we obtain a bijection between non-empty sets V of leaves of the tree T1(F ) and prime implicates of D(F ):\nDefinition 5.17 For F \u2208 SMU\u03b4=1 and \u2205 6= V \u2286 lvs(T1(F )) the clause CV is the prime implicate puc({Cw \u2208 F | w \u2208 V }) of D(F ) according to Lemma 5.16. For w \u2208 lvs(T1(F )) we furthermore set uw := uCw .\nBy Lemma 5.16:\nLemma 5.18 For F \u2208 SMU\u03b4=1 holds prc0(D(F )) = {CV | \u2205 6= V \u2286 lvs(T1(F ))}.\nHow precisely from V \u2286 lvs(T1(F )) the prime implicate CV is constructed shows the following lemma:\nLemma 5.19 Consider F \u2208 SMU\u03b4=1 and \u2205 6= V \u2286 lvs(T1(F )). We have CV = UV \u222a PV , UV \u2229 PV = \u2205, where\n1. UV := {uw | w \u2208 V }, and\n2. PV := puc(F \u2032) for F \u2032 := {Cw : w \u2208 V } as given in Lemma 5.10, that is, PV\nis the set of literals x such that V \u2229 lvs(Tx) 6= \u2205 and V \u2229 lvs(Tx) = \u2205.\nExample 5.20 Consider the clause-set\nF := {{v1, v2}, {v1, v2}, {v1, v3}, {v1, v3}} \u2208 SMU\u03b4=1\ncorresponding to the tree\nv1\nv2\nv1 \u2666\u2666\u2666 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\u2666\u2666\n1\nv2 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n2\nv2\n\u2744\u2744 \u2744\u2744\n\u2744\u2744 \u2744 v3\nv1\n\u2756\u2756\u2756 \u2756\u2756\u2756\n\u2756\u2756 \u2756\u2756\u2756\n\u2756\n3\nv3 \u2467\u2467 \u2467\u2467 \u2467\u2467 \u2467\n4\nv3\n\u2744\u2744 \u2744\u2744\n\u2744\u2744 \u2744\nwith the doped clause-set\nD(F ) = {{v1, v2, u1}, {v1, v2, u2}, {v1, v3, u3}, {v1, v3, u4}}.\nNow consider the set V := {1, 3}. According to Definition 5.17 we have that CV = puc({{v1, v2, u1}, {v1, v3, u3}}) = {v2, v3, u1, u3}. By Lemma 5.19 we have that CV = UV \u222a PV , where UV = {u1, u3} and PV = puc({{v1, v2}, {v1, v3}} = {v2, v3}. Note that for both x \u2208 {v2, v3} = PV we have that lvs(Tx)\u2229V 6= \u2205 and lvs(Tx)\u2229V = \u2205, but we do not have this for x \u2208 lit(F ) \\ {v2, v3}.\nThe hardness of F as well as D(F ) is the Horton-Strahler number of T1(F ):\nLemma 5.21 Consider F \u2208 SMU\u03b4=1, and let k := hs(T1(F )). Then we have hd(F ) = hd(D(F )) = k.\nProof: Let T := T1(F ). First we show hd(F ) = k. We have hd(F ) \u2264 k, since T is by definition of F = F1(T ) already a resolution tree (when extending the labelling of leaves to all nodes), deriving \u22a5 from F . To show hd(F ) \u2265 k, we use Lemma 3.6 with C := SMU\u03b4=1 and h(F ) := hs(T1(F )). Based on Lemma 5.5, we consider the effect on the Horton-Strahler number of assigning a truth value to one variable v \u2208 var(F ). Let w \u2208 nds(T ) be the (inner) node labelled with v, and let Tw0 , Tw1 be the left resp. right subtree hanging at w. Now the effect of assigning \u03b5 \u2208 {0, 1} to v is to replace Tw with T w \u03b5 . Let T\u03b5 be the (whole) tree obtained by assigning \u03b5 to v, that is, T\u03b5 := T 1(\u3008v \u2192 \u03b5\u3009 \u2217 F ). If hs(Tw0 ) = hs(Tw1 ), then we have hs(T\u03b5) \u2265 k \u2212 1, since at most one increase of the Horton-Strahler number for subtrees is missed out now. Otherwise we have hs(T0) = hs(T ) or hs(T1) = hs(T ), since removal of the subtree with the smaller Horton-Strahler number has no influence on the HortonStrahler number of the whole tree. So altogether Lemma 3.6 is applicable, which concludes the proof of hd(F ) = k.\nFor showing hd(D(F )) = k we use Lemma 4.20: so consider F \u2032 \u2286 F and \u03d5 \u2208 PASS with \u03d5 \u2217 F \u2032 \u2208 USAT , let F \u2032\u2032 := \u03d5 \u2217 F \u2032, and we have to show hd(F \u2032\u2032) \u2264 k. W.l.o.g. var(\u03d5) \u2286 var(F \u2032). By Corollary 5.7 we have that \u03d5 \u2217 F \u2208 SMU\u03b4=1, and thus \u03d5 \u2217 F = F \u2032\u2032 must hold, and hd(F \u2032\u2032) = hs(T1(F \u2032\u2032)) (by the first part). By Lemma 5.5, T1(F \u2032\u2032) results from T by a sequence of removing subtrees, and it is easy to see, that thus hs(T1(F \u2032\u2032)) \u2264 k holds.\nWe summarise what we have learned about D(F ) for F \u2208 SMU\u03b4=1:\nTheorem 5.22 Consider F \u2208 SMU\u03b4=1.\n1. For each clause-set F \u2032 equivalent to D(F ) there is an injection i : D(F ) \u2192 F \u2032 with \u2200C \u2208 D(F ) : C \u2286 i(C) (by Lemma 4.15).\n2. D(F ) is a total mps (by Corollary 5.13).\n3. The prime implicates of D(F ) are given by Lemmas 5.18, 5.19.\n4. hd(D(F )) = hs(T1(F )) (by Lemma 5.21)."}, {"heading": "6 Lower bounds", "text": "This section proves the main result of this article, Theorem 6.14, which exhibits for every k \u2265 0 sequences (F kh )h\u2208N of small clause-sets of hardness k + 1, where every equivalent clause-set of hardness k (indeed of w-hardness k) is of exponential size. In this way we show that the UCk hierarchy is useful, i.e., equivalent clause-sets with higher hardness can be substantially shorter. These F kh are doped versions of clause-sets from SMU\u03b4=1 (recall Theorem 5.22), which are \u201cextremal\u201d, that is, their underlying trees T1(F kh ) are for given Horton-Strahler number k+1 and height h as large as possible.\nThe organisation of this section is as follows: In Subsection 6.1 the main tool for showing size-lower-bounds for equivalent clause-sets of a given (w-)hardness is established in Theorem 6.4. Subsection 6.2 introduces the \u201cextremal trees\u201d. Subsection 6.3 shows the main lower bound in Theorem 6.13, and applies it to show the separation Theorem 6.14."}, {"heading": "6.1 Trigger hypergraphs", "text": "Our goal is to construct clause-sets F kh of hardness k + 1, which have no short equivalent clause-set F with whd(F ) \u2264 k, where w.l.o.g. F \u2286 prc0(F kh ) = prc0(F ). This subsection is about the general lower-bound method. How are we going to find a lower bound on the number of clauses of F ? The property whd(F ) \u2264 k means, that for every C \u2208 prc0(F ) the unsatisfiable clause-set \u03d5C \u2217 F can be refuted by k-resolution. In order for k-resolution to have a chance, there must be at least one clause of length at most k in \u03d5C \u2217 F \u2014 and this necessary condition is all what we consider. So our strategy is to show that every F \u2286 prc0(F kh ), such that for all C \u2208 prc0(F kh ) there is a clause of length at most k in \u03d5C \u2217 F , is big.\nIt is useful to phrase this approach in hypergraph terminology. Recall that a hypergraph is a pair G = (V,E), where V is a set (of \u201cvertices\u201d) and E \u2286 P(V ) (the set of hyperedges), where one uses V (G) := V and E(G) := E. A transversal of G is a set T \u2286 V (G) such that for all E \u2208 E(G) holds T \u2229E 6= \u2205. The minimum size of a transversal is denoted by \u03c4(G), the transversal number.\nDefinition 6.1 Consider k \u2208 N0 and F \u2208 CLS. The trigger hypergraph Tk(F ) is the hypergraph with the prime implicates of F as its vertices, and for every prime implicate C of F a hyperedge EkC . The hyperedge E k C contains all prime implicates C\u2032 \u2208 prc0(F ) which are not satisfied by \u03d5C and yield a clause of size at most k under \u03d5C . That is,\n1. V (Tk(F )) := prc0(F ), and\n2. E(Tk(F )) := {EkC | C \u2208 prc0(F )}, where EkC := {C\u2032 \u2208 prc0(F ) | C\u2032 \u2229 C = \u2205 \u2227 |C\u2032 \\ C| \u2264 k}.\nNote that the trigger hypergraph of F \u2208 CLS depends only on the underlying boolean function of F , and thus for every equivalent F \u2032 we have Tk(F \u2032) = Tk(F ).\nExample 6.2 Consider the clause-set\nF := { {v1, v3, v4} \ufe38 \ufe37\ufe37 \ufe38\nC1\n, {v2, v3, v4} \ufe38 \ufe37\ufe37 \ufe38\nC2\n, {v2, v3, v4} \ufe38 \ufe37\ufe37 \ufe38\nC3\n, {v2, v3, v4} \ufe38 \ufe37\ufe37 \ufe38\nC4\n, {v1, v3, v4} \ufe38 \ufe37\ufe37 \ufe38\nC5\n, {v1, v2} \ufe38 \ufe37\ufe37 \ufe38\nC6\n} .\nAs shown in Example 8.2 of [37, 38] we have prc0(F ) = F . The trigger hypergraph T0(F ) is (as always) the hypergraph with all singleton sets, i.e., E(T0(F )) ={ {C1}, . . . , {C6} } . The hypergraphs Tk(F ) for k \u2208 {1, 2} are represented by Figures 3, 4.\nC1++\nC2 ss\nC5 ss\nww C333 ** C6RR\n``\u2747\u2747\u2747\u2747\u2747\u2747\u2747\u2747 OO >>\u2464\u2464\u2464\u2464\u2464\u2464\u2464\u2464 oo C4 kk OO\nFigure 3: T1(F )\nC1++\n\u2747 \u2747\u2747\n\u2747\u2747 \u2747\u2747\n\u2747 C2 ss\nC5 ss\n~~\u2464\u2464 \u2464\u2464 \u2464\u2464 \u2464\u2464\nC333 // C6RR\n`` OO >>\noo C4 kk\nOO\nFigure 4: T2(F )\nTo interpret the diagrams:\n1. An arrow from a clause C to a clause D represents that C \u2208 EkD.\n2. A dotted arrow from C to D represents that |D \\ C| > k (so C /\u2208 EkD), but C \u2229D = \u2205, and thus for some large enough k\u2032 > k we will have C \u2208 Ek\u2032D .\n3. No arrow between C and D indicates that C \u2229D 6= \u2205 (i.e., for all k\u2032 we have C /\u2208 EkD and D /\u2208 EkC).\n4. The size of a hyperedge EkD is the in-degree of the vertex D.\nConsider E1C6 = {C6} and E2C6 = {C1, C2, C3, C5, C6}. As we will see in Lemma 6.3, therefore every F \u2032 \u2286 F equivalent to F such that F \u2032 \u2208 UC1 must have C6 \u2208 F \u2032. However, E2C6 contains more clauses than E 1 C6\n, and for example F \\ {C6} \u2208 UC2 \\ UC1 as shown in Example 8.2 of [37, 38]. Using the above diagrammatic notation, we can also see that for all k\u2032 \u2265 2 we have Tk\u2032(F ) = T2(F ), as there are no dotted lines for T2(F ) (i.e., no clauses C and D such that |D \\ C| > 2 but C \u2229D = \u2205).\nThe point of the trigger hypergraph Tk(F ) is, that every clause-set equivalent to F and of w-hardness at most k must be a transversal of it:\nLemma 6.3 Consider k \u2208 N0 and F \u2208 CLS with whd(F ) \u2264 k. Then there is a clause-set F \u2032 such that\n1. F \u2032 \u2286 prc0(F ) and F \u2032 is equivalent to F ;\n2. there is an injection i : F \u2032 \u2192 F such that \u2200C \u2208 F \u2032 : C \u2286 i(C);\n3. whd(F \u2032) \u2264 k;\n4. F \u2032 is a transversal of Tk(F ).\nProof: Obtain F \u2032 from F by choosing for every C \u2208 F some C\u2032 \u2208 prc0(F ) with C\u2032 \u2286 C. Then the first two properties are obvious, while Property 3 follows from Part 1 of Lemma 6.1 in [59]. Assume that F \u2032 is not a transversal of Tk(F ), that is, there is C \u2208 prc0(F ) with F \u2032 \u2229 EkC = \u2205. Then \u03d5C \u2217 F \u2032 \u2208 USAT , but every clause has length strictly greater than k, and thus k-resolution does not derive \u22a5 from \u03d5C \u2217 F \u2032, contradicting whd(F \u2032) \u2264 k.\nOur lower bound method is now captured by the following theorem, which directly follows from Lemma 6.3:\nTheorem 6.4 For k \u2208 N0 and F \u2208 WCk we have c(F ) \u2265 \u03c4(Tk(F )).\nInstead of lower-bounding the transversal number of Tk(F ), we use that every transversal has to have at least as many elements as there are disjoint hyperedges. So let \u03bd(G) be the matching number of hypergraph G, the maximum number of pairwise disjoint hyperedges; we have \u03c4(G) \u2265 \u03bd(G) for all hypergraphs G. So we have to show that there is a set S \u2286 prc0(F kh ) of exponential size, such that the hyperedges EkC for C \u2208 S are pairwise disjoint. For F kh we use the doped clause-set D(F1(T )) as considered in Subsection 5.3, where the special trees T are constructed in the subsequent subsection."}, {"heading": "6.2 Extremal trees", "text": "For a given hardness k \u2265 1 we need to construct (full binary) trees which are as large as possible; this is achieved by specifying the height, and using trees which are \u201cfilled up\u201d completely for the given parameter values:\nDefinition 6.5 A pair (k, h) \u2208 N20 with h \u2265 k and k = 0 \u21d2 h = 0 is called an allowed parameter pair. For an allowed parameter pair (k, h) a full binary tree T is called an extremal tree of Horton-Strahler number k and height h if\n1. hs(T ) = k, ht(T ) = h;\n2. for all T \u2032 with hs(T \u2032) \u2264 k and ht(T \u2032) \u2264 h we have nds(T \u2032) \u2264 nds(T ). We denote the set of all extremal trees with Horton-Strahler number k and height h by HS(k, h).\nNote that for allowed parameter pairs (k, h) we have k = 0 \u21d4 h = 0. Extremal trees are easily characterised and constructed as follows:\n1. HS(0, 0) contains only the trivial tree (with one node).\n2. HS(1, h) for h \u2208 N consists exactly of the full binary trees T with hs(T ) = 1 and ht(T ) = h, which can also be characterised as those full binary trees T with ht(T ) = h such that every node has at least one child which is a leaf.\n3. For k \u2265 2 and h \u2265 k we have T \u2208 HS(k, h) iff T has the left subtree T0 and the right subtree T1, and there is \u03b5 \u2208 {0, 1} with T\u03b5 \u2208 HS(k \u2212 1, h \u2212 1) and T1\u2212\u03b5 \u2208 HS(min(k, h\u2212 1), h\u2212 1).\nLemma 6.6 For all allowed parameter pair (k, h) we have HS(k, h) 6= \u2205. The unique elements of HS(k, k) for k \u2208 N0 are the perfect binary trees of height k, which are the smallest binary trees of Horton-Strahler number k.\nLemma 6.7 For an allowed parameter pair (k, h) and for T \u2208 HS(k, h) we have #lvs(T ) = \u03b1(k, h) :=\n\u2211k i=0 ( h i ) . We have \u03b1(k, h) = \u0398(hk) for fixed k.\nProof: For k \u2264 1 we have \u03b1(0, 0) = 1 and \u03b1(1, h) = 1 + h. which are obviously correct. Now consider k \u2265 2. By induction hypothesis we get\n#nds(T ) = \u03b1(k \u2212 1, h\u2212 1) + \u03b1(min(k, h\u2212 1), h\u2212 1). If h = k, then \u03b1(k, h) = 2k (for all k), and we get #nds(T ) = \u03b1(k \u2212 1, k \u2212 1) + \u03b1(k \u2212 1, k \u2212 1) = 2 \u00b7 2k\u22121 = 2k = \u03b1(k, k). Otherwise we have\n#nds(T ) = \u03b1(k \u2212 1, h\u2212 1) + \u03b1(k, h\u2212 1) = k\u22121\u2211\ni=0\n( h\u2212 1 i ) + k\u2211\ni=0\n( h\u2212 1 i ) = ( h\u2212 1 0 ) + k\u2211\ni=1\n( h\u2212 1 i\u2212 1 ) + ( h\u2212 1 i ) =\n( h\u2212 1 0 ) + k\u2211\ni=1\n( h\ni\n)\n=\nk\u2211\ni=0\n( h\ni\n)\n= \u03b1(k, h).\nExample 6.8 Consider the following labelled binary tree T :\nv1\nv2\nv1\n\u2765\u2765\u2765 \u2765\u2765\u2765\n\u2765\u2765\u2765 \u2765\u2765\u2765\n\u2765\u2765\u2765 \u2765\nv3\nv2\n\u2666\u2666\u2666 \u2666\u2666\u2666\n\u2666\u2666\u2666 \u2666\u2666\n10\nv3 \u2467\u2467 \u2467\u2467 \u2467\n21\nv3 \u2744\u2744\n\u2744\u2744 \u2744\nv4\nv2\n\u2756\u2756\u2756 \u2756\u2756\u2756\n\u2756\u2756\u2756 \u2756\u2756\n31\nv4 \u2467\u2467 \u2467\u2467 \u2467\n42\nv4 \u2744\u2744\n\u2744\u2744 \u2744\nv5\nv1\n\u275a\u275a\u275a \u275a\u275a\u275a\n\u275a\u275a\u275a \u275a\u275a\u275a\n\u275a\u275a\u275a \u275a\nv6\nv5 \u2467\u2467 \u2467\u2467 \u2467\u2467\n51\nv6 \u2467\u2467 \u2467\u2467 \u2467\n62\nv6 \u2744\u2744\n\u2744\u2744 \u2744 72\nv5 \u2744\u2744\n\u2744\u2744 \u2744\nApplying the recursive construction/characterisation we see T \u2208 HS(2, 3). By simple counting we see that T has 7 leaves, in agreement with Lemma 6.7, i.e., \u22112\nj=0 ( 3 j ) = ( 3 0 ) + ( 3 1 ) + ( 3 2 ) = 1 + 3 + 3 = 7. Assuming that of the two subtrees at an inner node, the left subtree has Horton-Strahler numbers as least as big as the right subtree, the idea is that the sum runs over the number j of right turns in a path from the root to the leaves. In the above tree T , the number of right turns is indicated as an index to the leaf-name. If the Horton-Strahler number is k, with at most k right-turns we must be able to reach every leaf.\nWe summarise the additional knowledge over Theorem 5.22 (using additionally that most leaves of T \u2208 HS(k, h) have depth precisely h):\nLemma 6.9 Consider an allowed parameter pair (k, h) and T \u2208 HS(k, h), and let F := F1(T ).\n1. n(D(F )) = 2 \u00b7 \u03b1(k, h)\u2212 1 (= \u0398(hk) for fixed k).\n2. c(D(F )) = \u03b1(k, h) (= \u0398(hk) for fixed k).\n3. \u2113(D(F )) \u2264 h \u00b7 \u03b1(k, h) (= \u0398(hk+1) for fixed k).\n4. D(F ) \u2208 UCk \\ UCk\u22121 (for k \u2265 1).\nIn Theorem 6.14 we will see that these D(F ) from Lemma 6.9 do not have short equivalent clause-sets of hardness k \u2212 1. A simple example demonstrates the separation between UC0 and UC1 (similar to [26], Example 2, which uses Example 6.1 from [50]):\nExample 6.10 The strongest separation is obtained by using Fh := D(F 1(T )) for T \u2208 HS(1, h) and h \u2208 N:\n1. F1(T ), when considering all possible T , covers precisely the saturated minimally unsatisfiable renamable Horn clause-set with h variables, which is up to isomorphism equal to {{v1}, {v1, v2}, . . . , {v1, . . . , vh\u22121, vh}, {v1, . . . , vh}}. By Lemma 5.4 these are precisely those F \u2208 SMU\u03b4=1 with n(F ) \u2265 1 which contain a full clause.\n2. n(Fh) = 2h+ 1, c(Fh) = h+ 1, and hd(Fh) = 1.\n3. |prc0(Fh)| = 2h+1 \u2212 1.\nConsidering Gn := {{v1}, . . . , {vn}, {v1, . . . , vn}} for n \u2265 2 and Fn := D(Gn) we obtain an example similar (but simpler) to Example 6.1 from [50]:\n1. n(Gn) = n and c(Gn) = n+ 1.\n2. Gn \u2208 MU\u03b4=1 \\ SMU\u03b4=1. The above clause-sets F1(T ) are obtained precisely as saturations of the Gn (due to Lemma 5.4; a saturation adds literal occurrences until we obtain a saturated minimally unsatisfiable clause-set).\n3. mps(Gn) consists precisely of the subsets of Gn containing the negative clause, plus the singleton-subsets given by the unit-clauses.\n4. Thus |mps(Gn)| = 2n + n.\n5. n(Fn) = 2n+ 1, c(Fn) = n+ 1, and hd(Fn) = 1.\n6. |prc0(Fn)| = 2n + n."}, {"heading": "6.3 The exponential lower bound", "text": "The task is to find many disjoint hyperedges in Tk(F k h ), where F k h := D(F 1(T )) for T \u2208 HS(k+1, h). Our method for this is to show that there are many \u201cincomparable\u201d subsets of leaves in T in the following sense. The depth of a node w in a rooted tree T , denoted by dT (w) \u2208 N0, is the length of the path from the root of T to w. Recall that two sets A,B are incomparable iff A 6\u2286 B and B 6\u2286 A. Furthermore we call two sets A,B incomparable on a set C if the sets A \u2229 C and B \u2229 C are incomparable.\nDefinition 6.11 Consider a full binary tree T , where every leaf has depth at least k + 1. Consider furthermore \u2205 \u2282 V, V \u2032 \u2286 lvs(T ). Then V and V \u2032 are depth-kincomparable for T if V and V \u2032 are incomparable on lvs(Tw) for all w \u2208 nds(T ) with dT (w) = k.\nNote that for all allowed parameter pairs (k, h) and T \u2208 HS(k, h) every leaf has depth at least k.\nLemma 6.12 Consider k \u2208 N0, T \u2208 T1, and \u2205 6= V0, V1 \u2286 lvs(T ) which are depthk-incomparable for T . Let F := F1(T ) and consider Tk(F ) (recall Definition 6.1). Then the hyperedges EkCV0 , EkCV1 are disjoint (recall Definition 5.17).\nProof: Assume that EkCV0 , EkCV1 are not disjoint; thus there is \u2205 6= V \u2286 lvs(T ) with CV \u2208 EkCV0 \u2229 E k CV1\n. We will show that there is \u03b5 \u2208 {0, 1} with |CV \\ CV\u03b5 | \u2265 k + 1, which contradicts the definition of Tk(F ).\nSince V 6= \u2205, there is w \u2208 V . Consider the first k + 1 nodes w1, . . . , wk+1 on the path from the root to w. Let w\u2032i be the child of wi\u22121 different from wi for i \u2208 {2, . . . , k + 1}, and let Ti := Tw\u2032 i+1 for i \u2208 {1, . . . , k}, while Tk+1 := Twk+1 ; see Figure 5. We show that each of T1, . . . , Tk+1 contributes at least two unique literals to |CV \\CV0 |+ |CV \\CV1 |, so that we get |CV \\CV0 |+ |CV \\CV1 | \u2265 (k+1) \u00b7 2, from which follows that there is \u03b5 \u2208 {0, 1} with |CV \\ CV\u03b5 | \u2265 k + 1 as claimed.\nDue to the depth-k-incomparability of V, V \u2032, for each i \u2208 {1, . . . , k+1} and each \u03b5 \u2208 {0, 1} there are nodes v\u03b5i with v\u03b5i \u2208 (lvs(Ti) \u2229 V\u03b5) \\ V\u03b5. We have two cases now:\nI If v\u03b5i \u2208 V , then uv\u03b5i \u2208 CV \\ CV\u03b5 .\nII If v\u03b5i /\u2208 V , then consider the first node v on the path from v\u03b5i to the root such that for the other child v\u2032 of v, not on that path to the root, holds lvs(Tv\u2032)\u2229 V 6= \u2205: now for the literal x labelling the edge from v to v\u2032 we have x \u2208 CV \\ CV\u03b5 . Note that v is below or equal to wi (due to w \u2208 V ).\nFor each \u03b5 \u2208 {0, 1}, the literals collected in CV \\ CV\u03b5 from these k + 1 sources do not coincide, due to the pairwise node-disjointness of the trees T1, . . . , Tk+1.\nTheorem 6.13 Consider k \u2208 N0, h \u2265 k + 1, and T \u2208 HS(k + 1, h); let F := D(F1(T )) and m := \u03b1(1, h\u2212 k) = 1 + h\u2212 k. We have\n\u03bd(Tk(F )) \u2265 ( m\n\u230am2 \u230b\n)\n> 1\u221a 2 2m\u221a m = \u0398( 2h\u221a h ),\nwhere the second inequality assumes h \u2265 k+5, while the \u0398-estimation assumes fixed k.\nProof: For every S \u2286 P(lvs(T )) with \u2205 /\u2208 S, such that every two different elements of S are depth-k-incomparable for T , we have \u03bd(Tk(F )) \u2265 |S| by Lemma 6.12. We can actually determine the maximal size of such an S, which is M :=\n( m m\u2032 ) , where\nm\u2032 := \u230am2 \u230b, as follows. Let T := {Tw : w \u2208 nds(T ) \u2227 dT (w) = k}; note that for T \u2032, T \u2032\u2032 \u2208 T with T \u2032 6= T \u2032\u2032 we have lvs(T \u2032)\u2229lvs(T \u2032\u2032) = \u2205. Choose T0 \u2208 T with minimal #lvs(T0); by Lemma 6.7 we have #lvs(T0) = m. Let S0 := {V \u2229 lvs(T0) : V \u2208 S}. Then S0 is an antichain (i.e., the elements of S0 are pairwise incomparable) and |S0| = |S|. By Sperner\u2019s Theorem ([80]) holds |S0| \u2264 M , and this upper bound M is realised, just observing the antichain-condition, by choosing for S0 the set( lvs(T0) m\u2032 ) of subsets of lvs(T0) of size m\n\u2032. This construction of S0 can be extended to a construction of S (of the same size) by choosing for each T \u2032 \u2208 T an injection jT \u2032 : S0 \u2192 ( lvs(T \u2032) m\u2032 ) and defining S := {\u22c3T \u2032\u2208T jT \u2032(V )}V \u2208S0 . The given estimation of M follows from Stirling\u2019s approximation.\nWe are now able to state the main result of this article, proving Conjecture 1.1 from [37, 38] that UCk, and indeed also WCk, is a proper hierarchy of boolean functions regarding polysize representations without new variables (see Subsection 7.1 for a discussion of \u201crepresentations\u201d in general):\nTheorem 6.14 Consider k \u2208 N0. For h \u2265 k + 1 choose one Th \u2208 HS(k + 1, h) (note there is up to left-right swaps exactly one element in HS(k + 1, h)), and let Fh := D(Th). Consider the sequence (Fh)h\u2265k+1.\n1. By Lemma 6.9 we have n(Fh) = \u0398(h k+1) as well as c(Fh) = \u0398(h k+1), and Fh \u2208 UCk+1.\n2. Consider a sequence (F \u2032h)h\u2265k+1 of clause-sets with F \u2032 h equivalent to Fh, such\nthat F \u2032h \u2208 WCk. By Theorems 6.13, 6.4 we have c(F \u2032h) = \u2126( 2 h \u221a h ).\nWe conjecture that Theorem 6.14 can be strengthened by including the PChierarchy in the following way:\nConjecture 6.15 For every k \u2208 N0 there exists a sequence (Fn)n\u2208N of clausesets in PCk+1, where for convenience we assume n(Fn) = n for all n, such that (\u2113(Fn))n\u2208N is polynomially bounded, and such that for every sequence (F \u2032n)n\u2208N in WCk, where for all n \u2208 N holds that F \u2032n is equivalent to Fn, the sequence (\u2113(F \u2032n))n\u2208N is not polynomially bounded."}, {"heading": "7 Analysing the Tseitin translation", "text": "We now turn to upper bounds, investigating cases where the Tseitin translation yields representations in UC. We consider two main cases: translating a DNF into a CNF, or translating an XOR-circuit. In Subsection 7.1 we discuss the general notion of \u201cCNF representation\u201d. In Subsection 7.2 we discuss translating DNF into CNF, which we consider as a map from CLS to CLS, and which we call the \u201ccanonical translation\u201d. Lemma 7.11 shows that the hardness of canonical translation results can be arbitrarily high. On the other hand, Lemma 7.12 shows that for hitting DNF the canonical translation result is in UC, and Theorem 7.14 applies this to our lower bound examples, in contrast to Theorem 6.14 (so we see that new variables here help). Finally by using only the necessary direction of the equivalences in the Tseitin translation, in Lemma 7.17 we see that for this \u201creduced canonical translation\u201d the result is always in UC. We conclude by discussing representations of XOR-clause-sets in Subsection 7.3."}, {"heading": "7.1 CNF-representations", "text": "In Subsections 1.4 and 9.2 of [37, 38] we discussed representations of boolean functions in general. The most general notion useful in the SAT-context seems to allow existentially quantified new variables, which yields the following basic definition:\nDefinition 7.1 A CNF-representation of F \u2208 CLS (as CNF) is a clause-set F \u2032 \u2208 CLS with var(F ) \u2286 var(F \u2032) such that the satisfying assignments of F \u2032 (as CNF) projected to var(F ) are precisely the satisfying assignments of F .\nExample 7.2 Consider F := {{a, b}}. Then F \u2032 := F \u222a {{v, a}} is a CNFrepresentation of F , since the satisfying assignments of F can be extended to satisfying assignments of F \u2032 by assigning v \u2192 1, while no new satisfying assignments are present, since F \u2032 is a superset of F . Also F \u222a{{v}} is a CNF-representation of F , but F \u222a {{a}} is not, since the satisfying assignment \u3008a \u2192 0, b \u2192 1\u3009 of F would be lost. Also {{v, a, b}} is not a CNF-representation of F , since here now we would obtain a new satisfying assignment for F , namely \u3008a, b \u2192 0\u3009.\nThe CNF-representations F \u2032 of F without new variables, that is, with var(F \u2032) = var(F ), are precisely the clause-sets F \u2032 equivalent to F with var(F \u2032) = var(F ). We have conjectured in [37, 38] (Conjecture 9.4) that Theorem 6.14 (and Conjecture 6.15) also holds when allowing new variables, which in this context we can rephrase as follows, also extending the conjecture by including WCk (see Conjecture 10.2 for a further strengthening):\nConjecture 7.3 For every k \u2208 N0 there exists a sequence (Fn)n\u2208N of clause-sets, such that there is a sequence (F \u2032n)n\u2208N, where\n\u2022 each F \u2032n is a CNF-representation of Fn,\n\u2022 \u2113(F \u2032n) is polynomial in n,\n\u2022 and we have F \u2032n \u2208 PCk+1,\nbut where there is no such sequence (F \u2032\u2032n )n\u2208N with F \u2032\u2032 n \u2208 WCk.\nOur basic condition for a \u201cgood\u201d representation F \u2032 of F \u2208 CLS is that F \u2032 \u2208 UCk holds for some \u201clow\u201d k (a constant if F depends on parameters). This is what we call the absolute condition \u2014 regarding the requirement of detecting unsatisfiability of \u03d5 \u2217 F \u2032 for some partial assignment \u03d5 we do not distinguish between original variables (those in var(F )) and new variables (those in var(F \u2032) \\ var(F )), that is, var(\u03d5) \u2286 var(F \u2032) is considered. If we consider only var(\u03d5) \u2286 var(F ), then we obtain the relative condition:\nDefinition 7.4 For F \u2208 CLS and V \u2286 VA the relative hardness hdV (F ) \u2208 N0 is defined as the minimum k \u2208 N0 such that for all partial assignments \u03d5 \u2208 PASS with var(\u03d5) \u2286 V and \u03d5 \u2217 F \u2208 USAT we have rk(\u03d5 \u2217 F ) = {\u22a5}. And the relative w-hardness whdV (F ) \u2208 N0 is defined as the minimum k \u2208 N0 such that for all partial assignments \u03d5 \u2208 PASS with var(\u03d5) \u2286 V and \u03d5 \u2217 F \u2208 USAT we have that k-resolution derives \u22a5 from \u03d5 \u2217 F .\nObviously hdV (F ) \u2264 hd(F ) and hdvar(F )(F ) = hd(F ), as well as whdV (F ) \u2264 whd(F ) and whdvar(F )(F ) = whd(F ). Having a representation F \u2032 of F with hdvar(F )(F \u2032) \u2264 1 is closely related to what is typically called \u201cmaintaining arc consistency\u201d; it would be precisely that if we would use p-hardness instead of hardness, while using (only) hardness is a certain weakening. Having hdvar(F )(F \u2032) = 0 here is equivalent to prc0(F ) \u2286 F \u2032, and thus for hardness 0 new variables are not helpful, neither for the relative nor the absolute condition.\nConjecture 7.3 is false for relative hardness, since regarding relative hardness the hierarchy collapses to the first level: we will present the details in a future paper, but they are not difficult \u2014 since there are no conditions on the new variables, the rk-computations for k > 1 can be encoded into CNF, only relying on r1. Such an encoding is an extension of Theorem 1 in [8], using similar techniques. More involved is the collapse of the WCk-hierarchy to the first level regarding relative hardness; we believe we can also show this, but we better formulate it explicitly as a conjecture:\nConjecture 7.5 For every k \u2265 1 there is a polytime function t(F, V ), which takes a clause-set F and a finite set V of variables as arguments, such that in case of whdV (F ) \u2264 k the output t(F, V ) is a representation of F with whdV (t(F )) \u2264 1.\nNote that for all F \u2208 CLS and V \u2286 VA holds whdV (F ) \u2264 1 \u21d4 hdV (F ) \u2264 1. The collapse of all considered hierarchies to their first level, when considering the relative condition, is for us a major argument in favour of the absolute condition: Within the class of representations of relative hardness at most 1 (when using new variables) there is a lot of structure, and many representations fulfil absolute conditions; some basic examples follow in the remainder of this section."}, {"heading": "7.2 The canonical translation", "text": "If for the F \u2208 CLS to be represented we have an equivalent DNF G \u2208 CLS, then we can apply the Tseitin translation, using one new variable v to express one DNFclause, i.e., using prc0(v \u2194 \u2227\nx\u2208C x) for C \u2208 G. The details are as follows. We assume that an injection vct : {(F,C) | F \u2208 CLS \u2227C \u2208 F} \u2192 VA is given, yielding the variables of the canonical translation, such that these variables are\nnew for F , that is, var(F ) \u2229 {vct(F,C)}C\u2208F = \u2205 holds for all F \u2208 CLS. We write vctC\nF := vct(F,C).\nDefinition 7.6 The map ct : CLS \u2192 CLS is defined for F \u2208 CLS as\nct(F ) := { {vctCF , x} : C \u2208 F \u2227 x \u2208 C } \u222a { {vctCF } \u222aC : C \u2208 F } \u222a\n{ {vctCF }C\u2208F } .\nThe first two types of clauses are the prime implicates of the boolean functions vctCF \u2194 \u2227\nx\u2208C x, while the last type (a long, single clause) says that one of the (DNF-)clauses from F must be true. To emphasise: the map ct is a map from clausesets to clause-sets, where the (implicit) interpretation of the input and the output is different: the input F \u2208 CLS is interpreted as DNF, while the output ct(F ) \u2208 CLS is interpreted as CNF. Some basic properties of the canonical translation:\n1. The basic measures of the canonical translation for F \u2208 CLS are given by\n(a) n(ct(F )) = n(F ) + c(F )\n(b) c(ct(F )) = 1 + c(F ) + \u2113(F ) for F 6= {\u22a5}. (c) \u2113(ct(F )) = 2c(F ) + 3\u2113(F ) for F 6= {\u22a5}.\n2. ct(\u22a4) = {\u22a5} and ct({\u22a5}) = {{vct\u22a5{\u22a5}}}.\n3. Consider \u03d5 \u2208 PASS with var(\u03d5) \u2286 var(F ), and treat F as a multi-clause-set, that is, if application of \u03d5 to different non-satisfied clauses from F makes these clauses equal, then no contractions are performed. Then the canonical translation behaves homomorphic regarding application of partial assignments in the sense that ct(\u03d5 \u2217 F ) (recall that we need to treat F here as a DNF) is isomorphic to (\u03d5\u222a\u03c8) \u2217 ct(F ), where \u03c8 sets those vctCF to 0 for which there is x \u2208 C with \u03d5(x) = 0.\nExample 7.7 We give some simple examples for canonical translations.\n1. For F := {{v1} \ufe38\ufe37\ufe37\ufe38\nC1\n,\u22a5} we have\nct(F ) = {{vctC1F , v1}, {vctC1F , v1} \ufe38 \ufe37\ufe37 \ufe38\nv1 \u2194 vct C1\nF\n, {vct\u22a5F } \ufe38 \ufe37\ufe37 \ufe38\n1 \u2194 vct\u22a5 F\n, {vctC1F , vct\u22a5F } \ufe38 \ufe37\ufe37 \ufe38\nvctC1 F \u2228 vct\u22a5 F\n}.\n2. For F := {{v1, v2, v3} \ufe38 \ufe37\ufe37 \ufe38\nC1\n, {v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\nC2\n} we have\nct(F ) = {{vctC1F , v1}, {vctC1F , v2}, {vctC1F , v3}, {vctC1F , v1, v2, v3} \ufe38 \ufe37\ufe37 \ufe38\n(v1 \u2227 v2 \u2227 v3) \u2194 vct C1\nF\n,\n{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v4}, {vctC2F , v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\n(v1 \u2227 v2 \u2227 v4) \u2194 vct C2\nF\n, {vctC1F , vctC2F } \ufe38 \ufe37\ufe37 \ufe38\nvctC1 F \u2228 vctC2 F\n}.\n3. Applying \u03d5 := \u3008v3 \u2192 1, v4 \u2192 1\u3009 to the last example (Case 2) yields\n\u03d5 \u2217 ct(F ) = {{vctC1F , v1}, {vctC1F , v2}, {vctC1F , v1, v2} \ufe38 \ufe37\ufe37 \ufe38\n(v1 \u2227 v2) \u2194 vct C1\nF\n,\n{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v1, v2} \ufe38 \ufe37\ufe37 \ufe38\n(v1 \u2227 v2) \u2194 vct C2\nF\n, {vctC1F , vctC2F } \ufe38 \ufe37\ufe37 \ufe38\nvctC1 F \u2228 vctC2 F\n}.\n4. Applying \u03d5 := \u3008v3 \u2192 0\u3009 to Case 2 yields\n\u03d5 \u2217 ct(F ) = {{vctC1F , v1}, {vctC1F , v2}, {vctC1F } \ufe38 \ufe37\ufe37 \ufe38\nvctC1 F\n,\n{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v4}, {vctC2F , v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\n(v1 \u2227 v2 \u2227 v4) \u2194 vct C2\nF\n, {vctC1F , vctC2F } \ufe38 \ufe37\ufe37 \ufe38\nvctC1 F \u2228 vctC2 F\n}.\n5. While applying \u03d5 := \u3008v3 \u2192 0\u3009 and \u03c8 := {vctC1F \u2192 0} to Case 2 yields\n(\u03d5 \u222a \u03c8) \u2217 ct(F ) = {{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v4}, {vctC2F , v1, v2, v4} \ufe38 \ufe37\ufe37 \ufe38\n(v1 \u2227 v2 \u2227 v4) \u2194 vct C2\nF\n, {vctC2F } \ufe38 \ufe37\ufe37 \ufe38\nvctC2 F\n}.\nIn Case 3 we see an example of why for the canonical translation to have the homomorphism property we must consider F as a multi-clause-set. That is, \u03d5 \u2217 F = {{v1, v2}}, and so \u03d5 \u2217 ct(F ) 6= ct(\u03d5 \u2217 F ): the clause {v1, v2} is represented by two separate new variables in \u03d5 \u2217 ct(F ) compared to only one in ct(\u03d5 \u2217 F ).\nIn Case 4 we see an example where for the homomorphism property of the canonical translation not just renaming, but also some unit-clause elimination is needed. These unit-clauses are added in Case 5, extending the assignment to falsify the new variable vctC1F corresponding to falsified DNF-clause C1.\nLemma 7.8 Consider F \u2208 CLS (as CNF) and an equivalent DNF-clause-set G \u2208 CLS. Then ct(G) is a CNF-representation of F . Proof: ct(F ) is true iff at least one of its vct-variables is set to true, which is precisely the case iff at least one of DNF-clauses of G is satisfied, where the (DNF)clauses of G cover precisely the satisfying assignments of F .\nLemma 7.9 For F \u2208 CLS we have hdvar(F )(ct(F )) \u2264 1 (recall Definition 7.4).\nProof: Consider \u03d5 \u2208 PASS with var(\u03d5) \u2286 var(F ) and \u03d5 \u2217 ct(F ) \u2208 USAT . Then all DNF-clauses of F are falsified, which yields via UCP that all vct-variables are set to false, and thus r1(\u03d5 \u2217 ct(F )) = {\u22a5}. In [49] a more general version of Lemma 7.9 is proven, showing that for all \u201csmooth\u201d DNNFs (Disjoint Negation Normal Form) the Tseitin translation yields a clauseset which maintains arc-consistency via UCP (a somewhat stronger property than relative hardness \u2264 1 as in Lemma 7.9).7) That Lemma 7.9 only establishes the\n7)There is a mistake in [49] in that it claims that the Tseitin translation of all DNNFs maintain arc-consistency via UCP, however this is shown only for smooth DNNFs as confirmed by George Katirelos via e-mail in January 2012.\nrelative condition, and not the absolute one, is due to the fact that setting vctvariables to 0 can pose arbitrarily hard conditions; a concrete example follows, while a more drastic general construction is given in Lemma 7.11. However the difficulties can be overcome, by just removing them: In Lemma 7.17 we will see that when dropping the part of the canonical translation which gives meaning to setting vct-variables to 0, that then we actually can establish the absolute condition.\nExample 7.10 Consider the following clause-set with variables x1, . . . , x5:\nF := { {x1, x2, x3} \ufe38 \ufe37\ufe37 \ufe38\nC1\n, {x1, x2, x4} \ufe38 \ufe37\ufe37 \ufe38\nC2\n, {x1, x2, x5} \ufe38 \ufe37\ufe37 \ufe38\nC3\n} .\nThe canonical translation is\nct(F ) = {{x1, vctC1F }, {x2, vctC1F }, {x3, vctC1F }}, {x1, x2, x3, vctC1F } \ufe38 \ufe37\ufe37 \ufe38\nvctC1 F \u2194 (x1 \u2227 x2 \u2227 x3)\n\u222a\n{{x1, vctC2F }, {x2, vctC2F }, {x4, vctC2F }}, {x1, x2, x4, vctC2F } \ufe38 \ufe37\ufe37 \ufe38\nvctC2 F \u2194 (x1 \u2227 x2 \u2227 x4)\n\u222a\n{{x1, vctC3F }, {x2, vctC3F }, {x5, vctC3F }}, {x1, x2, x5, vctC3F } \ufe38 \ufe37\ufe37 \ufe38\nvctC3 F \u2194 (x1 \u2227 x2 \u2227 x5)\n\u222a\n{{vctC1F , vctC2F , vctC3F }} \ufe38 \ufe37\ufe37 \ufe38\n(vctC1 F \u2228 vctC2 F \u2228 vctC3 F )\n.\nApplying the partial assignment \u03d5 := \u3008x3 \u2192 1, x4 \u2192 1, x5 \u2192 1, vctC3F \u2192 0\u3009 yields F \u2032 := \u03d5 \u2217 ct(F ) = {{x1, vctC1F }, {x2, vctC1F }}, {x1, x2, vctC1F }\n\ufe38 \ufe37\ufe37 \ufe38\nvctC1 F \u2194 (x1 \u2227 x2)\n\u222a\n{{x1, vctC2F }, {x2, vctC2F }}, {x1, x2, vctC2F } \ufe38 \ufe37\ufe37 \ufe38\nvctC2 F \u2194 (x1 \u2227 x2)\n\u222a\n{{x1, x2}} \ufe38 \ufe37\ufe37 \ufe38\n\u00ac(x1 \u2227 x2)\n\u222a {{vctC1F , vctC2F }} \ufe38 \ufe37\ufe37 \ufe38\n(vctC1 F \u2228 vctC2 F )\n.\nWe have F \u2032 \u2208 USAT , where F \u2032 has no unit-clauses, whence hd(F \u2032) \u2265 2, and so ct(F ) /\u2208 UC1.\nFor general input-DNFs, the hardness of the canonical translation can be arbitrary high:\nLemma 7.11 Consider F \u2208 CLS. Let v \u2208 VA\\var(F ) and F \u2032 := F \u222a{{v}}. Then hd(ct(F \u2032)) \u2265 hd(F ).\nProof: Let \u03d5 := \u3008vctCF \u2032 \u2192 0 : C \u2208 F \u3009 \u222a \u3008v, vct {v} F \u2032 \u2192 1\u3009. Then \u03d5 \u2217 ct(F \u2032) = F \u2032\u2032 := {C : C \u2208 F}, where hd(ct(F \u2032)) \u2265 hd(F \u2032\u2032) = hd(F ).\nIf we do not have just a DNF, but a \u201cdisjoint\u201d or \u201corthogonal\u201d DNF (see Section 1.6 and Chapter 7 in [22]), which are as clause-sets precisely the hitting clause-sets, then we obtain absolute hardness 1:\nLemma 7.12 For F \u2208 HIT we have ct(F ) \u2208 UC, where ct(F ) is a representation of the DNF-clause-set F .\nProof: Consider a partial assignment \u03d5 such that \u03d5 \u2217 ct(F ) is unsatisfiable. Since HIT is stable under application of partial assignments, and furthermore here no contractions take place, w.l.o.g. we can assume that var(\u03d5) \u2229 var(F ) = \u2205. If \u03d5 sets two or more vct-variables to true, then UCP yields a contradiction, since any two clauses from F clash. If \u03d5 would set precisely one vct-variable to true, then we had \u03d5 \u2217 ct(F ) = \u22a4. So assume that \u03d5 sets no vct-variable to true. Now \u03d5 must set all vct-variables to false, since, as already mentioned, just setting one vct-variable to true satisfies ct(F ). And thus \u22a5 \u2208 ct(F ).\nWe now want to show that via the canonical translation we can obtain representations of D(F ) for F \u2208 UHIT . For this we show first that all such D(F ) have short hitting DNF clause-sets. For F \u2208 CLS let #sat(F ) \u2208 N0 denote the number of satisfying assignments for F , that is, #sat(F ) = |DNF(F )|.\nLemma 7.13 Consider F \u2208 UHIT , and let m := n(F ) + c(F ).\n1. #sat(D(F )) = 2m\u22121.\n2. Let F \u2032 := { C\u222a{uC} | C \u2208 F } ; by definition we have F \u2032 \u2208 HIT . Furthermore\n#sat(F \u2032) = 2m\u22121.\n3. F \u2032 as a DNF-clause-set is equivalent to the CNF-clause-set D(F ).\nProof: We have \u2211 C\u2208F 2 \u2212|C| = 1 (see [52]). Thus \u2211 C\u2208D(F ) 2 \u2212|C| = 12 , which proves Part 1 (note m = n(D(F )) and D(F ) \u2208 HIT ). Part 2 follows from Part 1, since F \u2032 results from D(F ) by flipping literals. Finally we consider Part 3. All elements of F \u2032, as DNF-clauses (i.e., conjunctions of literals), represent satisfying assignments for D(F ), that is, for all C \u2208 F \u2032 and D \u2208 D(F ) we have C \u2229D 6= \u2205. By Part 2, precisely half of the total assignments of DNF-clause-set F \u2032 are falsifying, and thus precisely half of the total assignments are satisfying: since this is the same number as the satisfying assignments of D(F ), we obtain that the DNF-clause-set F \u2032 is equivalent to the CNF-clause-set F .\nAn alternative line of argumentation is that for F \u2208 UHIT the (logical) negation of D(F ) (as a CNF) is given by D(F )\u2032, which is obtained from D(F ) by flipping all doping literals, i.e., replacing clauses C \u222a{uC} by C\u222a{uC}. That this is indeed the negation, follows from the two facts, that D(F ) \u222aD(F )\u2032 \u2208 HIT by definition, and that D(F ) \u222aD(F )\u2032 results from F by replacing each clause C with the two clauses C \u222a {uC}, C \u222a {uC}, which are together equivalent to C.\nBy Lemma 7.13 and Lemma 7.12 we obtain now that doped unsatisfiable hitting clause-sets have good representations via the canonical translation:\nTheorem 7.14 For F \u2208 UHIT there is a short CNF-representation (using new variables) of D(F ) in UC, namely F \u2032 := ct({C \u222a {uC} : C \u2208 F}) \u2208 UC, where:\n1. n(F \u2032) = n(F ) + 2c(F ).\n2. c(F \u2032) = 1 + 2c(F ) + \u2113(F ).\nThis applies especially for F \u2208 SMU\u03b4=1 \u2282 UHIT .\nFinally we show that when relaxing the canonical translation, using only the necessary direction of the constitutive equivalences, then we actually obtain representations in UC for every DNF-clause-set:\nDefinition 7.15 The map ct\u2013 : CLS \u2192 CLS (\u201creduced canonical translation\u201d) is defined for F \u2208 CLS as ct\u2013(F ) := {{vctCF , x} : C \u2208 F \u2227 x \u2208 C} \u222a {{vctCF }C\u2208F}.\nNote that all clauses of ct\u2013(F ) are binary except of the long clause stating that one of the vct-variables must become true. And also note that in case of \u22a5 /\u2208 F the additional clauses of ct(F ), that is, the C \u2208 ct(F ) \\ ct\u2013(F ), are all blocked for ct(F ) (see [54, 55]), since C can not be resolved on the vct-variable in it. We have var(ct\u2013(F )) = var(ct(F )), while the basic measure for F \u2208 CLS are given as follows:\n1. n(ct\u2013(F )) = n(F ) + c(F )\n2. c(ct\u2013(F )) = 1 + \u2113(F )\n3. \u2113(ct\u2013(F )) = c(F ) + 2\u2113(F ).\nWith the same proof as Lemma 7.8 we get:\nLemma 7.16 Consider F \u2208 CLS (as CNF) and an equivalent DNF-clause-set G \u2208 CLS. Then ct\u2013(G) is a CNF-representation of F .\nWe show now that dropping the additional (blocked) clauses, present in the full form ct(F ), actually leads to the hardness dropping to 1 for arbitrary input-DNFs (recall Lemma 7.11), exploiting that now there are less possibilities for making ct\u2013(F ) unsatisfiable by instantiation:\nLemma 7.17 For F \u2208 CLS we have ct\u2013(F ) \u2208 UC (i.e., ct\u2013 : CLS \u2192 UC).\nProof: For the sake of contradiction consider a partial assignment \u03d5 such that F \u2032 := r1(\u03d5 \u2217 ct\u2013(F )) \u2208 USAT but F \u2032 6= {\u22a5}. Note that F \u2032 contains neither \u22a5 nor a unit-clause, and thus F \u2032 is a subset of ct\u2013(F ) except of the possibly shortened or satisfied long vct-clause. If F \u2032 contains no new variables, then thus F \u2032 = \u22a4, a contradiction. So there exists some C \u2208 F such that vctCF occurs in F \u2032. Consider the assignment \u03d5\u2032, which sets vctCF and all x \u2208 C to true, while setting all other (remaining) new variables to false: \u03d5\u2032 satisfies F \u2032, a contradiction.\nExample 7.18 We conclude our basic considerations of \u201ccanonical translations\u201d by discussing \u201cunique extension properties\u201d. A representation F \u2032 of F has the unique extension property (\u201cuep\u201d) if for every total satisfying assignment of F there is exactly one extension to a satisfying assignment of F \u2032. For every F \u2208 CLS the representation ct(F ) of F has the uep, since a variable vctCF must be set to 1 precisely for those C \u2208 F which are satisfied by \u03d5 in the DNF-sense (i.e., \u03d5 \u2217 {C} = {\u22a5}). On the other hand, the representation ct\u2013(F ) of F in general has not the uep: The total satisfying assignments for ct(F ) extending \u03d5 are exactly those which set at least one of the variables vctCF true for those C \u2208 F which are satisfied in the DNF-sense.\nA representation F \u2032 of F has the strong unique extension property if for every partial assignment \u03d5 with \u22a5 \u2208 \u03d5 \u2217 F (i.e., \u03d5 satisfied at least one of the DNFclauses) there is exactly one extension on the new variables (alone) to a satisfying assignment of F \u2032. For F \u2208 HIT the representation ct(F ) of F has the strong uep, since the satisfying assignments given by the clauses of F are inconsistent with each other."}, {"heading": "7.3 XOR-clauses", "text": "For the n-bit parity function x1 \u2295 \u00b7 \u00b7 \u00b7 \u2295 xn = 0 the unique equivalent clause-set prc0(x1 \u2295 \u00b7 \u00b7 \u00b7 \u2295 xn = 0) (unique since the prime implicates are not resolvable) has 2n\u22121 clauses. We now show that a typical SAT translation of the n-bit parity function, using new variables yi (for i \u2208 {2, . . . , n\u2212 1}) to compute the xor of the first i bits, is in UC.\nLemma 7.19 Consider n \u2265 3, literals x1, . . . , xn with different underlying variables, and new variables y2, . . . , yn\u22121. Let F := P2 \u222a ( \u22c3n\u22121 i=3 Pi ) \u222a Pn, where\n1. P2 := prc0(x1\u2295x2 = y2) = {{x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2}}\n2. Pi := prc0(yi\u22121 \u2295 xi = yi) = {{yi\u22121, xi, yi}, {yi\u22121, xi, yi}, {yi\u22121, xi, yi}, {yi\u22121, xi, yi}}\n3. Pn := prc0(yn\u22121 \u2295 xn = 0) = {{yn\u22121, xn}, {yn\u22121, xn}}.\nWe have F \u2208 UC, and F represents prc0(x1 \u2295 \u00b7 \u00b7 \u00b7 \u2295 xn = 0).\nProof: Assume for the sake of contradiction that F /\u2208 UC. Thus there exists a partial assignment \u03d5 such that for F \u2032 := r1(\u03d5 \u2217 F ) we have F \u2032 \u2208 USAT , but F \u2032 6= {\u22a5}. By definition F \u2032 has no clauses of size \u2264 1 and is non-empty. Observe that setting any variable in Pi for i \u2208 {2, . . . , n\u2212 1} yields a pair of binary clauses representing an equivalence or anti-equivalence between the two remaining variables. Also if Pi \u2229 F \u2032 6= \u2205 for some i \u2208 {2, . . . , n \u2212 1}, then we have Pi \u2286 F \u2032, since all clauses of Pi contain all variables of Pi. Therefore we have F\n\u2032 = E \u222a \u22c3i\u2208I Pi for some subset I \u2286 {2, . . . , n\u2212 1}, where E is a set of clauses representing a chain of equalities and inequalities. Consider the assignment \u03d5\u2032 := \u3008xi \u2192 0 : i \u2208 I\u3009. We have \u03d5\u2032 \u2217 Pi = \u03d5\u2032 \u2217 prc0(yi\u22121 + xi = yi) = prc0(yi\u22121 = yi); note that xi is only in Pi, and so \u3008xi \u2192 1\u3009 only touches Pi. So \u03d5\u2032 \u2217 F \u2032 now contains only variable-disjoint chains of equivalences and anti-equivalences, each trivially satisfiable, yielding a contradiction.\nExample 7.20 For n = 3 we get\nF = { {x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2} \ufe38 \ufe37\ufe37 \ufe38\nx1 \u2295 x2 = y2\n, {y2, x3}, {y2, x3} \ufe38 \ufe37\ufe37 \ufe38\ny2 \u2295 x3 = 0\n} .\nA very interesting question is how much the (simple) Lemma 7.19 can be extended, towards representing arbitrary systems of linear equations. It seems to us, that we do not have polysize representations with bounded hardness in the UC-framework:\nConjecture 7.21 As usual, an \u201cXOR-clause\u201d is a (boolean) constraint of the form x1 \u2295 \u00b7 \u00b7 \u00b7 \u2295 xn = 0 for literals x1, . . . , xn, which we just represent by the clause {x1, . . . , xn} \u2208 CL. An \u201cXOR-clause-set\u201d F is a set of XOR-clauses, which is just represented by an ordinary clause-set F \u2208 CLS (with an alternative interpretation). The conjecture now is that XOR-clause-sets do not have good representations with bounded hardness, not even when using relative hardness. That is, there is no k \u2208 N0 and no polynomial p(x) such that for all clause-sets F \u2208 CLS there exists a CNF-representation F \u2032 \u2208 CLS (possibly using new variables), taking F as an XOR-clause-set, with \u2113(F \u2032) \u2264 p(\u2113(F )) and hdvar(F )(F \u2032) \u2264 k.\nBasic results for showing such a lower bound are obtained in [8]. As we have already remarked (after Definition 7.4), regarding relative hardness only k \u2208 {0, 1} are of relevance (because we allow new variables), while regarding absolute hardness we conjecture that also with new variables we have a proper hierarchy (Conjecture 7.3).\nWe conclude now our initial study on \u201cgood representations\u201d by the basic observations regarding the naive approach for translating XOR-clause-sets."}, {"heading": "8 Hardness under union", "text": "When applied piecewise to a system of linear equations (with different auxiliary variables for each single equation), the translation from Lemma 7.19 does not yield a clause-set in UC, as we show in Theorem 8.5. To facilitate the precise computation of the hardness of the union of two such XOR-clause-translations, we present two general tools for upper bounds on hardness and one for lower bounds.\nLemma 8.1 Consider F \u2208 CLS and V \u2286 var(F ). Let P be the set of partial assignments \u03c8 with var(\u03c8) = V . Then hd(F ) \u2264 |V |+max\u03c8\u2208P hd(\u03c8 \u2217 F ).\nProof: Consider a partial assignment \u03d5 with \u03d5 \u2217 F \u2208 USAT ; we have to show hd(\u03d5 \u2217F ) \u2264 |V |+max\u03c8\u2208P hd(\u03c8 \u2217F ). Build a resolution refutation of \u03d5 \u2217F by first creating a splitting tree (possibly degenerated) on the variables of V ; this splitting tree (a perfect binary tree) has height |V |, and at each of its leaves we have a clause-set \u03d5\u2217(\u03c8\u2217F ) for some appropriate \u03c8 \u2208 P . Thus at each leaf we can attach a splitting tree of Horton-Strahler number of hardness at most max\u03c8\u2208P hd(\u03c8\u2217F ), and from that (via the well-known correspondence of splitting trees and resolution trees; see [53, 59] for details) we obtain a resolution tree fulfilling the desired hardness bound.\nWe obtain an upper bound on the hardness of the union of two clause-sets:\nCorollary 8.2 For F1, F2 \u2208 CLS holds hd(F1 \u222a F2) \u2264 max(hd(F1), hd(F2)) + |var(F1) \u2229 var(F2)|.\nProof: Apply Lemma 8.1 with F := F1\u222aF2 and V := var(F1)\u2229var(F2), and apply the general upper bound hd(F1 \u222a F2) \u2264 max(hd(F1), hd(F2)) for variable-disjoint F1, F2 (Lemma 15 in [36]).\nSubstitution of literals can not increase (w-)hardness:\nLemma 8.3 Consider a clause-set F \u2208 USAT and (arbitrary) literals x, y. Denote by Fx\u2190y \u2208 USAT the result of replacing x by y and x by y in F , followed by removing clauses containing complementary literals. Then we have hd(Fx\u2190y) \u2264 hd(F ) and whd(Fx\u2190y) \u2264 whd(F ).\nProof: Consider T : F \u22a2 \u22a5. It is a well-known fact (and a simply exercise), that the substitution of y into x can be performed in T , obtaining Tx\u2190y : Fx\u2190y \u22a2 \u22a5. This is easiest to see by performing first the substitution with T itself, obtaining a tree T \u2032 which as a binary tree is identical to T , using \u201cpseudo-clauses\u201d with (possibly) complementary literals; the resolution rule for sets C,D of literals with x \u2208 C and x \u2208 D allows to derive the clause (C \\ {x}) \u222a (D \\ {x}), where the resolution-variables are taken over from T . Now \u201ctautological\u201d clauses (containing complementary literals) can be cut off from T \u2032: from the root (labelled with \u22a5) go to a first resolution step where the resolvent is non-tautological, while one of the parent clauses is tautological (note that not both parent clauses can be tautological)\n\u2014 the subtree with the tautological clause can now be cut off, obtaining a new pseudo-resolution tree where clauses only got (possibly) shorter (see Lemma 6.1, part 1, in [59]). Repeating this process we obtain Tx\u2190y as required. Obviously hs(Tx\u2190y) \u2264 hs(T ), and if in T for every resolution step at least one of the parent clauses has length at most k for some fixed (otherwise arbitrary) k \u2208 N0, then this also holds for Tx\u2190y.\nExample 8.4 The simplest example showing that for satisfiable clause-sets F (w)hardness can be increased by substitution is given by F := {{x}, {y}} for var(x) 6= var(y). Here hd(F ) = 0, while Fx\u2190y = {{y}, {y}}, and thus hd(Fx\u2190y) = 1.\nNow we are ready to determine the (high) hardness of the union of the (piecewise) translation of two XOR-clauses for a basic special case:\nTheorem 8.5 For n \u2265 3 consider the system x1 \u2295 x2 \u2295 \u00b7 \u00b7 \u00b7 \u2295 xn = 0 x1 \u2295 x2 \u2295 \u00b7 \u00b7 \u00b7 \u2295 xn = 0.\nLet F := F1 \u222a F2, where F1 is the translation of the first equation by Lemma 7.19, and F2 is the translation of the second equation, using different auxiliary variables (so n(F ) = 2 \u00b7 (n+ (n\u2212 2))\u2212 n = 3n\u2212 4). We have F \u2208 USAT with hd(F ) = n. Proof: From Corollary 8.2 and Lemma 7.19 we obtain hd(F ) \u2264 n + 1. Better is to apply Lemma 8.1 with V := var({x2, . . . , xn\u22121}). By definition we see that \u03c8 \u2217 F \u2208 2\u2013CLS (i.e., all clauses have length at most two) for \u03c8 with var(\u03c8) = V . By Lemma 19 in [36] we have hd(\u03c8 \u2217 F ) \u2264 2, and thus hd(F ) \u2264 (n \u2212 2) + 2 = n. The lower bound is obtained by an application of Lemma 3.6. Consider any literal x \u2208 lit(Fn), where the subscript in Fn = F makes explicit the dependency on n. Setting x to true or false results either in an equivalence or in an anti-equivalence. Propagating this (anti-)equivalence yields a clause-set F \u2032 isomorphic to Fn\u22121, where by Lemma 8.3 this propagation does not increase hardness, so we have hd(\u3008x \u2192 1\u3009 \u2217 Fn) \u2265 hd(F \u2032) = hd(Fn\u22121). The argumentation can be trivially extended for n \u2208 {0, 1, 2}, and so by Lemma 3.6 we get hd(F ) \u2265 n. If F1, F2 in Theorem 8.5 were the direct translations (with hd(F1) = hd(F2) = 0), then hd(F ) = n would follow easily with Lemma 3.18 in [53], since then F would be simply the clause-set with all 2n clauses of length n. Of course, regarding a good translation of the system from Theorem 8.5 we can just use {\u22a5}, easily computed by preprocessing \u2014 however the content of Conjecture 7.21 is, that no preprocessing is powerful enough to handle arbitrary (satisfiable!) systems of linear equations (over the two-element field)."}, {"heading": "9 Basic experiments", "text": "In this section we perform some experiments on the use of the three different mechanisms for representing boolean functions f studied in this article:\n1. clause-sets F equivalent to f with F \u2208 UCk where k is as low as feasible; 2. the canonical translation ct(G) for a DNF-clause-set G equivalent to f ;\n3. and the reduced canonical translation ct\u2013(G).\nThe instances are described in Subsection 9.1, while the experimental results are discussed in Subsection 9.2. Our focus is on gaining a better understanding of the interaction between solver behaviour and problem representation, and so we consider various representative complete SAT solvers."}, {"heading": "9.1 The instances", "text": "For our experiments we want to take a boolean function fk,h as a constraint in a bigger SAT problem Gk,h. The \u201coptimal\u201d equivalent representation Fk,h of fk,h shall have hardness k, and fk,h should also have a small equivalent DNF, so that the canonical and reduced canonical translation are available.\nFor fk,h we take the boolean functions from Theorem 6.13, which have the short CNF\u2019s (without new variables) Fk,h := D(F\n1(Tk,h)) for k \u2265 2 and h \u2265 k + 1, where Tk,h \u2208 HS(k, h). So Fk,h has hardness k, while every equivalent clause-set of hardness at most k\u22121 contains at least b(m) := ( m\n\u230am2 \u230b ) many clauses for m := h\u2212k.\nFor the \u201ccompletion\u201d to Gk,h let F \u2032 k,h be the negation of Fk,h according to the remarks to Lemma 7.13, that is, F \u2032k,h is obtained from Fk,h by complementing the doping literals in each clause. Let F := {C : C \u2208 F} for F \u2208 CLS. Note that F \u2032k,h is the DNF for Fk,h. We define G i k,h for i = 1, 2, 3 as always including F \u2032 k,h, and additionally\n1. G1k,h uses Fk,h, i.e., G 1 k,h := F \u2032 k,h \u222a Fk,h.\n2. G2k,h uses the canonical translation according to Theorem 7.14 (and Lemma\n7.13), i.e., G2k,h := F \u2032 k,h \u222a ct(F \u2032k,h).\n3. G3k,h uses the reduced canonical translation according to Lemma 7.17 (and\nLemma 7.13), i.e., G3k,h := F \u2032 k,h \u222a ct\u2013(F \u2032k,h),\nThe sizes of the Gik,h are determined as follows:\n\u2022 By Lemma 6.9 we have c(Fk,h) = \u03b1(k, h), while n(Fk,h) = 2c(Fk,h) \u2212 1 = 2\u03b1(k, h)\u2212 1.\n\u2022 The size of F \u2032k,h is precisely the same.\n\u2022 So n(G1k,h) = 2\u03b1(k, h)\u2212 1 and c(G1k,h) = 2\u03b1(k, h), while \u2113(G1k,h) = 2\u2113(Fk,h).\n\u2022 n(G2k,h) = n(G3k,h) = 3\u03b1(k, h)\u2212 1.\n\u2022 c(G3k,h) = 1 + \u03b1(k, h) + \u2113(Fk,h) and \u2113(G3k,h) = \u03b1(k, h) + 3\u2113(Fk,h).\n\u2022 c(G2k,h) = 1 + 2\u03b1(k, h) + \u2113(Fk,h) and \u2113(G3k,h) = 2\u03b1(k, h) + 4\u2113(Fk,h).\nSee Figure 6 for the numerical data. The lower bounds b(h\u2212k) there for the number of clauses in any clause-set F equivalent to Fk,h and with F \u2208 WCk\u22121 show that these representations are infeasible here. As an amusing fact one can note here that the number of clauses in F \u2208 WC0 would be (precisely) 2c \u2212 1, which even for the smallest example considered is a rather astronomical number. We can determine the hardness of the Gik,h precisely; first an auxiliary lemma:\nLemma 9.1 For F \u2208 CLS and F \u2032 \u2208 {ct(F ), ct\u2013(F )} holds F \u222a F \u2032 \u2208 USAT and hd(F \u222a F \u2032) \u2264 2.\nProof: Due to ct\u2013(F ) \u2286 ct(F ) w.l.o.g. F \u2032 = ct\u2013(F ), since UC2 \u2229 USAT is closed under formation of super-clause-sets by Lemma 6.7 in [38]. For all C \u2208 F and x \u2208 C the binary clause vctC \u2192 x is in F \u2032. Thus setting vctC to 1 in F \u222a F \u2032 results in setting x to 1 via r1, which altogether falsifies C \u2208 F . Thus r2 applied to F \u222a F \u2032 sets all vctC to 0, which falsifies {vctC : C \u2208 F} \u2208 F \u2032.\nNow the (total) hardness of the unsatisfiable SAT problems Gk,h is as follows:\nLemma 9.2 Consider k, h \u2208 N with k \u2265 2 and h \u2265 k + 1. We have: 1. hd(G1k,h) = k + 1.\n2. hd(G2k,h) = hd(G 3 k,h) = 2.\nProof: hd(G1k,h) = k+1 follows from the fact, that by definition G 1 k,h \u2208 SMU \u03b4=1 holds, where the corresponding tree T := T1(G1k,j) has Horton-Strahler number k + 1 (recall Lemma 5.21): T is obtained from the underlying Tk,h by replacing each leaf with the full binary tree with three nodes. G2k,h and G 3 k,h have hardness at least 2 since they are unsatisfiable and contain no unit-clauses. The remaining assertions follow by Lemma 9.1."}, {"heading": "9.2 Solver performances", "text": "For the experiments we used a 64-bit workstation with 32 GB RAM and Intel i52320 CPUs (6144 KB cache) running with 3 GHz, where we only employed a single CPU. To emphasise again, the aim of these experiments is to obtain a qualitative picture of the behaviour of a range of contemporary SAT solvers, and not to find out which solver is \u201cfastest\u201d. For our experimentation we use the following solvers:\n1. OKsolver ([57]): a look-ahead solver, used as a \u201ctheoretical\u201d solver.\n2. MiniSat-family:\n(a) MiniSat, version 2.2 (see [79]).\n(b) CryptoMiniSat, version 2.9.6 (see [76]).\n(c) Glucose, version 2.0 (see [3]).\n3. Lingeling-family:\n(a) PicoSAT, version 913 (see[10, 12]).\n(b) PrecoSAT, version 570 ([11]).\n(c) Lingeling, version ala-b02aa1a-121013 (see [12, 13]).\nFirst we consider the OKsolver (see Figure 6), as a look-ahead solver (see [42, 60] for the general concepts), as well as a solver with a \u201cclean\u201d behaviour, due to the minimisation of the use of heuristical shortcuts. For example, the OKsolver seems to be the only SAT-solver computing r2, while all other solvers (recall the discussion in Subsection 1.6) only test selected literals for failed literals. We see that the G1k,h are far easier than the G 2,3 k,h, although they require branching. Indeed, the straightforward heuristics choosing a variable occurring most often will find a backtracking tree of optimal, i.e., linear size (note that all F \u2208 SMU\u03b4=1 have exactly one variable occurring in every clause, and splitting on this variable creates two variable-disjoint instances). In conformance with this, linear regression shows with high correlation that the instances G1k,h are solved by the OKsolver in linear time, i.e., O(\u2113). Considering now G2,3k,h, recall that by Lemma 9.2 all these instances have hardness 2, that is, they can be solved without branching. And in fact the number of r2-reductions of the OKsolver for these instances is precisely c(Fk,h)\u2212 1, in accordance with Lemma 9.1. The worst-case running time for r2 is O(n\n2 \u00b7 \u2113), but in this case going once through the list of all variables is sufficient to find the contradiction. Again in conformance with this, linear regression shows with high correlation that the instances G2,3k,h are solved in time O(n \u00b7 \u2113). We note here that the OKsolver is actually the fastest solver on these instances, for all three types, though this is not the focus of these experiments.\nOther look-ahead solvers performed badly on these instances. satz performs very badly even on the very easy ones: on G12,22 it needed 4.3 sec, and on G 1 2,32 already 2 hours. Thus it was not considered further. march pl performed somewhat better, but was also not able to complete even the easier instancesG1k,h; furthermore it crashed on various instances, and was thus also not considered further.\nNow we turn to the conflict-driven solvers (see [67] for a general introduction), where we consider the MiniSat-family (Figure 7) and the Lingeling-family (Figure 8). Considering G1k,h, we note that MiniSat as well as PrecoSAT always solve these instances by preprocessing. And actually MiniSat -no-pre (without preprocessing) solves these instances faster (by branching) than with preprocessing. While PicoSAT, which also does not use preprocessing, is not much slower than PrecoSAT. With the largest instance G15,35, all solvers except of PrecoSAT have considerable difficulties, but all can handle it (only PicoSAT aborts, likely due to a bug). That OKsolver is much faster here we believe is due to the fact, that in general look-ahead solvers should be better than conflict-driven solvers on unsatisfiable instances, where the shortest refutations are (close to) tree-like (and in this case the tree-like refutation of F \u2208 SMU\u03b4=1 given by the underlying tree T1(F ) is the shortest possible overall).\nTurning to G2,3k,h, we see that CryptoMiniSat as well as PicoSAT solve the easier instances with failed-literal elimination (without branching). Most of the time these instances are harder than their G1k,h counterparts, and for k \u2208 {4, 5} much more so, and actually no solver here was able to handle k = 5 with h = 35. There seems to be no essential difference between G2k,h and G 3 k,h (different from the OKsolver, whose running time was proportionally larger for G2k,h, according to the bigger size)."}, {"heading": "10 Conclusion and open problems", "text": "We have discussed three hierarchies PCk, UCk and WCk of target classes for \u201cgood\u201d SAT representations. We showed that each level of UCk+1 contains clause-sets without equivalent short clause-sets inWCk. And we showed conditions under which\nthe Tseitin translation produces translations in UC. We conclude by directions for future research."}, {"heading": "10.1 Strictness of hierarchies", "text": "A fundamental question is the strictness of the hierarchies PCk, UCk and WCk in each of the dimensions. In Theorem 6.14 we have shown w.r.t. logical equivalence (i.e., without new variables) that the UCk and WCk hierarchies are strict. It follows that for PCk at least every second level yields an advance regarding logical equivalence (and polysize). This offer evidence that these hierarchies are useful, for example using failed literal reduction can allow one to use exponentially smaller SAT translations. Open are the questions of strictness for the hierarchies allowing new variables. To summarise, the main conjectures are:\n1. Conjecture 6.15 strengthens Theorem 6.14 by taking the PC-hierarchy into account.\n2. Conjecture 7.3 roughly says that all of PCk, UCk and WCk are strict (similar to Theorem 6.14), when allowing new variables under the absolute condition.\n3. Conjecture 7.5 says that the WCk hierarchy collapses to WC1 (and thus to PC1), when allowing new variables under the relative condition."}, {"heading": "10.2 Separating the different hierarchies", "text": "For stating our three main conjectures relating the three hierarchies, we use the following notions:\n\u2022 A sequence (F \u2032n)n\u2208N is called a CNF-representation of (Fn)n\u2208N if for all n \u2208 N the clause-set F \u2032n is a CNF-representation of Fn.\n\u2022 A polysize sequence in C \u2286 CLS is a sequence (Fn)n\u2208N with Fn \u2208 C for all n \u2208 N, such that (\u2113(Fn))n\u2208N is polynomially bounded (i.e., there is a polynomial p(x) with \u2113(Fn) \u2264 p(n) for all n \u2208 N).\nWe conjecture that WC2 even without new variables offers possibilities for good representations not offered by any UCk:\nConjecture 10.1 There exists a polysize (Fn)n\u2208N in WC2, such that for no k \u2208 N0 there exists a polysize CNF-representation (F \u2032n)n\u2208N of (Fn)n\u2208N in UCk. A proof of Conjecture 10.1 needed, besides the novel handling of the new variables, to develop lower-bounds methods specifically for hardness, since the method via trigger hypergraphs yields already lower bounds for w-hardness.\nWe conjecture that new variables can not simulate higher hardness, strengthening Theorem 6.14, Conjecture 6.15 and Conjecture 7.3:\nConjecture 10.2 For every k \u2208 N0 there exists a polysize (Fn)n\u2208N in PCk+1, such that there is no polysize CNF-representation (F \u2032n)n\u2208N of (Fn)n\u2208N in WCk.\nFinally we conjecture that there is a sequence of boolean functions which has polysize arc-consistent representations, but no polysize representations of bounded hardness, even for the w-hardness:\nConjecture 10.3 There exists a polysize (Fn)n\u2208N in CLS, such that there is a polysize CNF-representation (F \u2032n)n\u2208N of (Fn)n\u2208N with hd\nvar(Fn)(F \u2032n) \u2264 1 for all n \u2208 N, while for no k \u2208 N0 there is a polysize CNF-representation (F \u2032\u2032n )n\u2208N of (Fn)n\u2208N in WCk.\nRegarding our notion of a \u201cpolysize sequence\u201d (Fn)n\u2208N, this is a very liberal notion, allowing to express arbitrary boolean functions, since the number of variables could be logarithmic in the index, and thus Fn could contain exponentially many clauses in the number of variables. The sequence of Theorem 6.14 also fulfils n(Fn) = \u2126(n), and making this provision one could speak of \u201csimple\u201d boolean functions, however this would complicate the formulations of our conjectures, and so we abstained from it.\nWe conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR\u2217(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38]. From the point of view of polysize representations without new variables, the hierarchy CANON(k) collapses to CANON(0) = UC0:\nLemma 10.4 For F \u2208 CLS let k(F ) be the minimal k \u2208 N0 such that F \u2208 CANON(k). Then the function prc0 : CLS \u2192 CANON(0) = UC0 can be computed in time O(c(F )3\u00b72 k \u00b7 \u2113(F )), when the input is F together with k := k(F ).\nProof: Let K := 2k. So for every C \u2208 prc0(F ) there exists F \u2032 \u2286 F with F \u2032 |= C and c(F \u2032) \u2264 K, since a resolution tree of height k has at most K leaves. Now we compute prc0(F ) as follows:\n1. Set P := \u2205.\n2. Run through all F \u2032 \u2286 F with c(F \u2032) \u2264 K; their number is O(c(F )K ).\n3. For each F \u2032 determine whether F \u2032 |= puc(F \u2032) holds, in which case clause puc(F \u2032) is added to P ; note that the test can be performed in time O(2K \u00b7K).\n4. The final P obtained has O(c(F )K ) many elements. After performing subsumption elimination (in cubic time) we obtain prc0(F ) (by Lemma 4.7).\nIt seems an interesting question whether the two other hierarchies SLUR(k), SLUR\u2217(k) collapse or not, and whether they can be reduced to some UCk."}, {"heading": "10.3 Compilation procedures", "text": "For a given boolean function f and k \u2208 N0, how do we find algorithmically a \u201csmall\u201d equivalent F \u2208 UCk ? In [38], Section 8, the notion of a \u201ck-base for f\u201d is introduced, which is an F \u2208 UCk equivalent to f , with F \u2286 prc0(f) and where no clause can be removed without increasing the hardness or destroying equivalence. It is shown that if f is given as a 2-CNF, then a smallest k-base is computable in polynomial time, but even for f with given prc0(f), where prc0(f) is a Horn clause-set, deciding whether a k-base of a described size for a fixed k \u2265 1 exists is NP-complete.\nThere are interesting applications where prc0(f) is given (or can be computed), and where then some small equivalent F \u2208 UCk is sought. The most basic approach filters out unneeded prime implicates; see [35, 34] for some initial applications to cryptanalysis. A simple filtering heuristic, used in [35, 34], is to favour (keeping) short-clauses. In a first phase, starting with the necessary elements of prc0(f), further elements are added (when needed) in ascending order of size for building up the initial F \u2208 UCk (which in general is not a base). In the second phase, clauses from F are removed in descending order of size when reducing to a k-base. The intuition behind this heuristic is that small clauses cover more total assignments (so fewer are needed), and they are also more likely to trigger rk, making them more useful in producing small, powerful representations. Essentially the same heuristic is considered in [15] (called \u201clength-increasing iterative empowerment\u201d) when generating representations in PC.\nFor the case that f is given by a CNF F0, in [26] one finds refinements of the resolution procedure applied to F0, which would normally compute prc0(f), i.e., the 0-base in UC0, and where by some form of \u201ccompression\u201d now an equivalent F \u2208 UC1 is computed. This approach needed to be generalised to arbitrary UCk."}, {"heading": "10.4 Exploring w-hardness", "text": "It is to be expected that w-hardness can behave very differently from hardness. For example, as expressed by Conjecture 10.1, already its second level should enable contain short clause-sets not representable in any UCk. However yet we do not have tools at hand to handle w-hardness (we do not even have yet a conjectured example for such a separation). A first task is to investigate which of the results on hardness from this article and from [38] can be adapted to w-hardness. In [9] we will present some basic methods for w-hardness bounds.\nCan the classes WCk go beyond monotone circuits, which were shown in [8] to be strongly related to the expressive power of arc-consistent CNF representations (see the following subsection for some further remarks)? Conjecture 7.5 would show the contrary, namely that in the (unrestricted) presence of new variables also whardness boils down, modulo polytime computations, to PC1 (under the relative condition!). If this is true, then the believable greater power of WCk over UCk would all take place inside arc-consistency; and by Conjecture 10.3 it would take place strictly inside arc-consistency."}, {"heading": "10.5 Hard boolean functions handled by oracles", "text": "Finally we turn to concrete (sequences of) boolean functions which are currently out of reach of good presentations, and where the use of oracles thus is necessary.\nConjecture 7.21 says that systems of XOR-clauses (affine equations) have no good representation, even when just considering arc-consistency. So the conjecture is that here we have another example for the limitations of arc-consistent representations as shown in [8]. To overcome these (conjectured) limitations, the theory started here has to be generalised via the use of oracles as developed in [53, 59], and further discussed in Subsection 9.4 of [37, 38]. The point of these oracles, which are just sets U \u2286 USAT of unsatisfiable clause-sets stable under application of partial assignments, is to discover hard unsatisfiable (sub-)instances (typically in polynomial time). Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).\nAn important aspect of the theory to be developed must be the usefulness of the representation (with oracles) in context, that is, as a \u201cconstraint\u201d in a bigger problem: a boolean function f represented by a clause-set F is typically contained in F \u2032 \u2283 F , where F \u2032 is the SAT problem to be solved (containing also other constraints). One approach is to require from the oracle also stability under addition of clauses, as we have it already for the resolution-based reductions like rk, so that the (relativised) reductions rUk can always run on the whole clause-set (an instantiation of F \u2032). However for example for the oracle mentioned below, based on semidefinite programming, this would be prohibitively expensive. And for some oracles, like detection of minimally unsatisfiable clause-sets of a given deficiency, the problems would turn from polytime to NP-hard in this way ([30, 16]). Furthermore, that we have some representation of a constraint which would benefit for example from some XOR-oracle, does not mean that in other parts of the problems that oracle will also be of help. So in many cases it is better to restrict the application of the oracle U to that subset F \u2282 F \u2032 where to achieve the desired hardness the oracle is actually required.\nAnother example of a current barrier is given by the satisfiable pigeonhole clausesets PHPmm, which have variables pi,j for i, j \u2208 {1, . . . ,m}, and where the satisfying assignments correspond precisely to the permutations of {1, . . . ,m}. The question is about \u201cgood\u201d representations. In [9] we show hd(PHPmm) = whd(PHP m m) = m \u2212 1, and so the (standard representation) PHPmm \u2208 CLS itself is not a good representation (it is small, but has high w-hardness). Actually, as explained in [9], from [8] it follows that PHPmm has no polysize arc-consistent representation at all! So again, here oracles are needed; see Subsection 9.4 of [37, 38] for a proposal of an interesting oracle (with potentially good stability properties)."}], "references": [{"title": "Measuring the hardness of SAT instances", "author": ["Carlos Ans\u00f3tegui", "Ma\u0155\u0131a Luisa Bonet", "Jordi Levy", "Felip Many\u00e0"], "venue": "Proceedings of the 23th AAAI Conference on Artificial Intelligence", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}, {"title": "Predicting learnt clauses quality in modern SAT solvers", "author": ["Gilles Audemard", "Laurent Simon"], "venue": "Proceedings of the 21st International Joint Conference on Artificial intelligence,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2009}, {"title": "Efficient CNF encoding of boolean cardinality constraints", "author": ["Olivier Bailleux", "Yacine Boufkhad"], "venue": "In Principles and Practice of Constraint Programming \u2013 CP 2003,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2003}, {"title": "On hierarchies over the SLUR class", "author": ["Tom\u00e1\u0161 Balyo", "\u0160tefan Gursk\u00fd", "Petr Ku\u010dera", "V\u00e1clav Vl\u010dek"], "venue": "In Twelfth International Symposium on Artificial Intelligence and Mathematics (ISAIM", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2012}, {"title": "Short proofs are narrow \u2014 resolution made simple", "author": ["Eli Ben-Sasson", "Avi Wigderson"], "venue": "In Proceedings of the 31th Annual ACM Symposium on Theory of Computing", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1999}, {"title": "Circuit complexity and decompositions of global constraints", "author": ["Christian Bessiere", "George Katsirelos", "Nina Narodytska", "Toby Walsh"], "venue": "In Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence (IJCAI-", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2009}, {"title": "Hardness measures and resolution lower bounds, with applications to Pigeonhole principles", "author": ["Olaf Beyersdorff", "Matthew Gwynne", "Oliver Kullmann"], "venue": "In preparation,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "Picosat essentials", "author": ["Armin Biere"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2008}, {"title": "Lingeling, Plingeling, PicoSAT and PrecoSAT at SAT Race", "author": ["Armin Biere"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2010}, {"title": "Lingeling and friends entering the SAT Challenge", "author": ["Armin Biere"], "venue": "Proceedings of SAT Challenge 2012: Solver and Benchmark Descriptions,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2012}, {"title": "Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications", "author": ["Armin Biere", "Marijn J.H. Heule", "Hans van Maaren", "Toby Walsh", "editors"], "venue": null, "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2009}, {"title": "Knowledge compilation with empowerment", "author": ["Lucas Bordeaux", "Joao Marques-Silva"], "venue": "SOFSEM 2012: Theory and Practice of Computer Science,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "The complexity of read-once resolution", "author": ["Hans Kleine B\u00fcning", "Xishun Zhao"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2002}, {"title": "On resolution with short clauses", "author": ["Michael Buro", "Hans Kleine B\u00fcning"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1996}, {"title": "A survey of knowledge compilation", "author": ["Marco Cadoli", "Francesco M. Donini"], "venue": "AI Communications,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1997}, {"title": "Properties of SLUR formulae", "author": ["Ond\u0159ej \u010cepek", "Petr Ku\u010dera", "V\u00e1clav Vl\u010dek"], "venue": "SOFSEM 2012: Theory and Practice of Computer Science,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2012}, {"title": "An exponential example for analytic tableaux", "author": ["Stephen A. Cook"], "venue": null, "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1973}, {"title": "Boolean Functions: Theory, Algorithms, and Applications, volume 142 of Encyclopedia of Mathematics and Its Applications", "author": ["Yves Crama", "Peter L. Hammer"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2011}, {"title": "Complexity of Constraints: An Overview of Current Research Themes, volume 5250 of Lecture Notes in Computer", "author": ["Nadia Creignou", "Phokion Kolaitis", "Heribert Vollmer", "editors"], "venue": "Science (LNCS). Springer,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2008}, {"title": "A knowledge compilation map", "author": ["Adnan Darwiche", "Pierre Marquis"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2002}, {"title": "Tractable databases: How to make propositional unit resolution complete through compilation", "author": ["Alvaro del Val"], "venue": "In Proceedings of the 4th International Conference on Principles of Knowledge Representation and Reasoning", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1994}, {"title": "On some tractable classes in deduction and abduction", "author": ["Alvaro del Val"], "venue": "Artificial Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2000}, {"title": "Translating pseudo-boolean constraints into SAT", "author": ["Niklas E\u00e9n", "Niklas S\u00f6rensson"], "venue": "Journal on Satisfiability, Boolean Modeling and Computation,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 2006}, {"title": "Extending the knowledge compilation map: Krom, Horn, Affine and beyond", "author": ["H\u00e9l\u00e8ne Fargier", "Piere Marquis"], "venue": "ECAI 2008,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2008}, {"title": "Polynomial\u2013time recognition of minimal unsatisfiable formulas with fixed clause\u2013variable difference", "author": ["Herbert Fleischner", "Oliver Kullmann", "Stefan Szeider"], "venue": "Theoretical Computer Science,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2002}, {"title": "A perspective on certain polynomial-time solvable classes of satisfiability", "author": ["John Franco", "Allen Van Gelder"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2003}, {"title": "Arc consistency in SAT", "author": ["Ian P. Gent"], "venue": "Proceedings of the 15th European Conference on Artificial Intelligence (ECAI", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2002}, {"title": "The propositional formula checker HeerHugo", "author": ["Jan Friso Groote", "Joost P. Warners"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2000}, {"title": "Towards a better understanding of hardness", "author": ["Matthew Gwynne", "Oliver Kullmann"], "venue": "In The Seventeenth International Conference on Principles and Practice of Constraint Programming (CP 2011): Doctoral Program Proceedings,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2011}, {"title": "Towards a better understanding of SAT translations", "author": ["Matthew Gwynne", "Oliver Kullmann"], "venue": "Logic and Computational Complexity (LCC\u201911),", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2011}, {"title": "Generalising and unifying SLUR and unit-refutation completeness", "author": ["Matthew Gwynne", "Oliver Kullmann"], "venue": "SOFSEM 2013: Theory and Practice of Computer Science,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2013}, {"title": "Generalising unit-refutation completeness and SLUR via nested input resolution", "author": ["Matthew Gwynne", "Oliver Kullmann"], "venue": "Technical Report arXiv:1204.6529v5 [cs.LO],", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2013}, {"title": "Generalising unit-refutation completeness and SLUR via nested input resolution", "author": ["Matthew Gwynne", "Oliver Kullmann"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2013}, {"title": "When boolean satisfiability meets Gaussian elimination in a Simplex way", "author": ["Cheng-Shen Han", "Jie-Hong Roland Jiang"], "venue": "Computer Aided Verification,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2012}, {"title": "St\u030aalmarck\u2019s algorithm as a HOL derived rule. In Theorem proving in higher order logics: 9th International Conference, TPHOLs\u201996", "author": ["John Harrison"], "venue": "Lecture Notes in Computer Science", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 1996}, {"title": "Marcheq: Implementing additional reasoning into an efficient look-ahead SAT solver", "author": ["Marijn Heule", "Mark Dufour", "Joris van Zwieten", "Hans van Maaren"], "venue": "In Hoos and Mitchell", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2034}, {"title": "Limitations of restricted branching in clause", "author": ["Matti J\u00e4rvisalo", "Tommi Junttila"], "venue": "learning. Constraints,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 2009}, {"title": "\u017divn\u00fd. Relating proof complexity measures and practical hardness of SAT", "author": ["Matti J\u00e4rvisalo", "Arie Matsliah", "Jakob Nordstr\u00f6m", "Stanislav"], "venue": "Principles and Practice of Constraint Programming - CP 2012,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2012}, {"title": "The effect of structural branching on the efficiency of clause learning SAT solving: An experimental study", "author": ["Matti J\u00e4rvisalo", "Ilkka Niemel\u00e4"], "venue": "Journal of Algorithms,", "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2008}, {"title": "Algebraic attacks using SAT-solvers", "author": ["Philipp Jovanovic", "Martin Kreuzer"], "venue": "Groups-Complexity-Cryptology,", "citeRegEx": "48", "shortCiteRegEx": "48", "year": 2010}, {"title": "Two encodings of DNNF theories, July 2008. Presented at ECAI\u201908 Workshop on Inference methods based on Graphical Structures of Knowledge", "author": ["Jean Christoph Jung", "Pedro Barahoma", "George Katsirelos", "Toby Walsh"], "venue": "Proceedings at http://www.irit.fr/LC/", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 2008}, {"title": "An incremental method for generating prime implicants/implicates", "author": ["Alex Kean", "George Tsiknis"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "50", "shortCiteRegEx": "50", "year": 1990}, {"title": "On generalized Horn formulas and k-resolution", "author": ["Hans Kleine B\u00fcning"], "venue": "Theoretical Computer Science,", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 1993}, {"title": "Investigating a general hierarchy of polynomially decidable classes of CNF\u2019s based on short tree-like resolution proofs", "author": ["Oliver Kullmann"], "venue": "Technical Report TR99-041, Electronic Colloquium on Computational Complexity (ECCC), October", "citeRegEx": "53", "shortCiteRegEx": "53", "year": 1999}, {"title": "New methods for 3-SAT decision and worst-case analysis", "author": ["Oliver Kullmann"], "venue": "Theoretical Computer Science,", "citeRegEx": "54", "shortCiteRegEx": "54", "year": 1999}, {"title": "On a generalization of extended resolution", "author": ["Oliver Kullmann"], "venue": "Discrete Applied Mathematics,", "citeRegEx": "55", "shortCiteRegEx": "55", "year": 1999}, {"title": "An application of matroid theory to the SAT problem", "author": ["Oliver Kullmann"], "venue": "In Fifteenth Annual IEEE Conference on Computational Complexity", "citeRegEx": "56", "shortCiteRegEx": "56", "year": 2000}, {"title": "Investigating the behaviour of a SAT solver on random formulas", "author": ["Oliver Kullmann"], "venue": "Technical Report CSR 23-2002,", "citeRegEx": "57", "shortCiteRegEx": "57", "year": 2002}, {"title": "The combinatorics of conflicts between clauses", "author": ["Oliver Kullmann"], "venue": "In Enrico Giunchiglia and Armando Tacchella, editors, Theory and Applications of Satisfiability Testing 2003,", "citeRegEx": "58", "shortCiteRegEx": "58", "year": 2004}, {"title": "Upper and lower bounds on the complexity of generalised resolution and generalised constraint satisfaction problems", "author": ["Oliver Kullmann"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2004}, {"title": "Theory and Applications of Satisfiability Testing - SAT 2009, volume 5584 of Lecture", "author": ["Oliver Kullmann", "editor"], "venue": "Notes in Computer Science. Springer,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2009}, {"title": "Constraint satisfaction problems in clausal form II: Minimal unsatisfiability and conflict structure", "author": ["Oliver Kullmann"], "venue": "Fundamenta Informaticae,", "citeRegEx": "62", "shortCiteRegEx": "62", "year": 2011}, {"title": "On Davis-Putnam reductions for minimally unsatisfiable clause-sets", "author": ["Oliver Kullmann", "Xishun Zhao"], "venue": "Technical Report arXiv:1202.2600v5 [cs.DM],", "citeRegEx": "63", "shortCiteRegEx": "63", "year": 2012}, {"title": "Conflict-driven XOR-clause learning", "author": ["Tero Laitinen", "Tommi Junttila", "Ilkka Niemel\u00e4"], "venue": "Theory and Applications of Satisfiability Testing SAT 2012, volume LNCS 7317 of Lecture Notes in Computer Science,", "citeRegEx": "64", "shortCiteRegEx": "64", "year": 2012}, {"title": "Heuristics based on unit propagation for satisfiability problems", "author": ["Chu Min Li", "Anbulagan"], "venue": "In Proceedings of 15th International Joint Conference on Artificial Intelligence", "citeRegEx": "65", "shortCiteRegEx": "65", "year": 1997}, {"title": "Computing minimally unsatisfiable subformulas: State of the art and future directions", "author": ["Joao Marques-Silva"], "venue": "Journal of Multiple-Valued Logic and Soft Computing,", "citeRegEx": "66", "shortCiteRegEx": "66", "year": 2012}, {"title": "On the power of clause-learning SAT solvers with restarts", "author": ["Knot Pipatsrisawat", "Adnan Darwiche"], "venue": "Principles and Practice of Constraint Programming - CP 2009,", "citeRegEx": "68", "shortCiteRegEx": "68", "year": 2009}, {"title": "On the power of clause-learning SAT solvers as resolution engines", "author": ["Knot Pipatsrisawat", "Adnan Darwiche"], "venue": "Artificial Intelligence,", "citeRegEx": "69", "shortCiteRegEx": "69", "year": 2011}, {"title": "A structure-preserving clause form translation", "author": ["David A. Plaisted", "Steven Greenbaum"], "venue": "Journal of Symbolic Computation,", "citeRegEx": "70", "shortCiteRegEx": "70", "year": 1986}, {"title": "Hierarchies of polynomially solvable satisfiability problems", "author": ["Daniele Pretolani"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "71", "shortCiteRegEx": "71", "year": 1996}, {"title": "A tutorial on St\u030aalmarck\u2019s proof procedure for propositional logic", "author": ["Mary Sheeran", "Gunnar St\u030aalmarck"], "venue": "In FMCAD\u201998,", "citeRegEx": "73", "shortCiteRegEx": "73", "year": 1998}, {"title": "Towards an optimal CNF encoding of boolean cardinality constraints", "author": ["Carsten Sinz"], "venue": "In Principles and Practice of Constraint Programming \u2013 CP 2005,", "citeRegEx": "74", "shortCiteRegEx": "74", "year": 2005}, {"title": "On k-term DNF with the largest number of prime implicants", "author": ["Robert H. Sloan", "Bal\u00e1zs S\u00f6r\u00e9nyi", "Gy\u00f6rgy Tur\u00e1n"], "venue": "SIAM Journal on Discrete Mathematics,", "citeRegEx": "75", "shortCiteRegEx": "75", "year": 2007}, {"title": "Cryptominisat 2.5.0", "author": ["Mate Soos"], "venue": "http://baldur.iti.uka.de/ sat-race-2010/descriptions/solver_13.pdf,", "citeRegEx": "76", "shortCiteRegEx": "76", "year": 2010}, {"title": "Enhanced Gaussian elimination in DPLL-based SAT solvers", "author": ["Mate Soos"], "venue": "Pragmatics of SAT,", "citeRegEx": "77", "shortCiteRegEx": "77", "year": 2010}, {"title": "Ein Satz \u00fcber Untermengen einer endlichen Menge", "author": ["Emanuel Sperner"], "venue": "Mathematische Zeitschrift,", "citeRegEx": "80", "shortCiteRegEx": "80", "year": 1928}, {"title": "Modeling and verifying systems and software in propositional logic", "author": ["Gunnar St\u030aalmarck", "M. S\u00e4flund"], "venue": "Safety of Computer Control Systems", "citeRegEx": "81", "shortCiteRegEx": "81", "year": 1990}, {"title": "Compiling finite linear CSP into SAT", "author": ["Naoyuki Tamura", "Akiko Taga", "Satoshi Kitagawa", "Mutsunori Banbara"], "venue": null, "citeRegEx": "82", "shortCiteRegEx": "82", "year": 2009}, {"title": "A compact and efficient SAT-encoding of finite domain CSP", "author": ["Tomoya Tanjo", "Naoyuki Tamura", "Mutsunori Banbara"], "venue": "Theory and Applications of Satisfiability Testing - SAT 2011, volume LNCS 6695 of Lecture Notes in Computer Science,", "citeRegEx": "83", "shortCiteRegEx": "83", "year": 2011}, {"title": "The complexity of propositional proofs", "author": ["Alasdair Urquhart"], "venue": "The Bulletin of Symbolic Logic,", "citeRegEx": "84", "shortCiteRegEx": "84", "year": 1995}, {"title": "A short note on some tractable cases of the satisfiability problem", "author": ["Hans van Maaren"], "venue": "Information and Computation,", "citeRegEx": "85", "shortCiteRegEx": "85", "year": 2000}, {"title": "Classes of boolean formulae with effectively solvable SAT", "author": ["V. Vl\u010dek"], "venue": "In Jana Safrankova and Jiri Pavlu, editors, Proceedings of the 19th Annual Conference of Doctoral Students - WDS 2010,", "citeRegEx": "86", "shortCiteRegEx": "86", "year": 2010}], "referenceMentions": [{"referenceID": 30, "context": "The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F \u2208 UCk is to be achieved for k as small as feasible.", "startOffset": 84, "endOffset": 96}, {"referenceID": 31, "context": "The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F \u2208 UCk is to be achieved for k as small as feasible.", "startOffset": 84, "endOffset": 96}, {"referenceID": 32, "context": "The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F \u2208 UCk is to be achieved for k as small as feasible.", "startOffset": 84, "endOffset": 96}, {"referenceID": 20, "context": "Here UC1 = UC has been introduced in [26] for the purpose of knowledge compilation.", "startOffset": 37, "endOffset": 41}, {"referenceID": 11, "context": "We also touch upon the hierarchy PCk of propagation complete clause-sets of level k, where PC1 = PC has been introduced in [15].", "startOffset": 123, "endOffset": 127}, {"referenceID": 2, "context": "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.", "startOffset": 16, "endOffset": 27}, {"referenceID": 61, "context": "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.", "startOffset": 16, "endOffset": 27}, {"referenceID": 22, "context": "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.", "startOffset": 16, "endOffset": 27}, {"referenceID": 67, "context": "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.", "startOffset": 65, "endOffset": 73}, {"referenceID": 68, "context": "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.", "startOffset": 65, "endOffset": 73}, {"referenceID": 39, "context": "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.", "startOffset": 123, "endOffset": 131}, {"referenceID": 29, "context": "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.", "startOffset": 123, "endOffset": 131}, {"referenceID": 26, "context": "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].", "startOffset": 53, "endOffset": 75}, {"referenceID": 2, "context": "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].", "startOffset": 53, "endOffset": 75}, {"referenceID": 61, "context": "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].", "startOffset": 53, "endOffset": 75}, {"referenceID": 22, "context": "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].", "startOffset": 53, "endOffset": 75}, {"referenceID": 40, "context": "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].", "startOffset": 53, "endOffset": 75}, {"referenceID": 11, "context": "In a similar vein, there is the class PC of propagation-complete clause-sets (see [15]), containing all clause-sets for which unit-clause propagation is sufficient to detect all forced assignments.", "startOffset": 82, "endOffset": 86}, {"referenceID": 36, "context": "In [45] it is shown that conflict-driven solvers with branching restricted to input variables have only superpolynomial run-time on EPHPn, an Extended Resolution", "startOffset": 3, "endOffset": 7}, {"referenceID": 38, "context": "Also experimentally it is demonstrated in [47] that input-restricted branching can have a detrimental effect on solver times and proof sizes for modern CDCL solvers.", "startOffset": 42, "endOffset": 46}, {"referenceID": 30, "context": "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.", "startOffset": 40, "endOffset": 52}, {"referenceID": 31, "context": "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.", "startOffset": 40, "endOffset": 52}, {"referenceID": 32, "context": "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.", "startOffset": 40, "endOffset": 52}, {"referenceID": 20, "context": "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.", "startOffset": 156, "endOffset": 160}, {"referenceID": 30, "context": "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of \u201chardness\u201d at most k, that is, refutation is (always) possible via rk.", "startOffset": 3, "endOffset": 15}, {"referenceID": 31, "context": "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of \u201chardness\u201d at most k, that is, refutation is (always) possible via rk.", "startOffset": 3, "endOffset": 15}, {"referenceID": 32, "context": "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of \u201chardness\u201d at most k, that is, refutation is (always) possible via rk.", "startOffset": 3, "endOffset": 15}, {"referenceID": 43, "context": "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of \u201chardness\u201d at most k, that is, refutation is (always) possible via rk.", "startOffset": 96, "endOffset": 104}, {"referenceID": 49, "context": "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of \u201chardness\u201d at most k, that is, refutation is (always) possible via rk.", "startOffset": 96, "endOffset": 104}, {"referenceID": 31, "context": "5 of [37, 38] that various poly-time solvable SAT classes are contained within levels of the UCk hierarchy.", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "5 of [37, 38] that various poly-time solvable SAT classes are contained within levels of the UCk hierarchy.", "startOffset": 5, "endOffset": 13}, {"referenceID": 17, "context": "2 in [22] and [85]) and HOk \u2282 UCk (generalised Horn clause-sets, see [51]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 70, "context": "2 in [22] and [85]) and HOk \u2282 UCk (generalised Horn clause-sets, see [51]).", "startOffset": 14, "endOffset": 18}, {"referenceID": 42, "context": "2 in [22] and [85]) and HOk \u2282 UCk (generalised Horn clause-sets, see [51]).", "startOffset": 69, "endOffset": 73}, {"referenceID": 37, "context": "In [46] the argument is made that tree-resolution complexity can not provide a good measure of hardness of instances for SAT solving, citing the ability of CDCL solvers to simulate exponentially more powerful full resolution (see [2] for evidence that CDCL solvers can simulate full resolution).", "startOffset": 3, "endOffset": 7}, {"referenceID": 31, "context": "On the other hand, for tighter target classes in the case of full resolution, we also consider the notion of width-hardness as introduced in [37, 38], based on the", "startOffset": 141, "endOffset": 149}, {"referenceID": 32, "context": "On the other hand, for tighter target classes in the case of full resolution, we also consider the notion of width-hardness as introduced in [37, 38], based on the", "startOffset": 141, "endOffset": 149}, {"referenceID": 43, "context": "width-based hierarchies of unsatisfiable clause-sets in [53, 59].", "startOffset": 56, "endOffset": 64}, {"referenceID": 49, "context": "width-based hierarchies of unsatisfiable clause-sets in [53, 59].", "startOffset": 56, "endOffset": 64}, {"referenceID": 42, "context": "That is, a clause-set is in WCk, the hierarchy of clause-sets of width-hardness k, iff under any partial assignment resulting in an unsatisfiable clause-set there is a \u201ck-resolution\u201d refutation as introduced in [51].", "startOffset": 211, "endOffset": 215}, {"referenceID": 21, "context": "A precursor A generalisation of UC was already discussed in [27].", "startOffset": 60, "endOffset": 64}, {"referenceID": 21, "context": "[27] continues by considering the (generic) hierarchy (\u03a0k)k\u2208N0 from [71], a precursor of [53].", "startOffset": 0, "endOffset": 4}, {"referenceID": 59, "context": "[27] continues by considering the (generic) hierarchy (\u03a0k)k\u2208N0 from [71], a precursor of [53].", "startOffset": 68, "endOffset": 72}, {"referenceID": 43, "context": "[27] continues by considering the (generic) hierarchy (\u03a0k)k\u2208N0 from [71], a precursor of [53].", "startOffset": 89, "endOffset": 93}, {"referenceID": 59, "context": "However this choice for \u03a00 was never considered for that hierarchy from [71], which might have two reasons: Implicit preference is given to classes \u03a00 closed under sub-clause-set formation (see Section 6.", "startOffset": 72, "endOffset": 76}, {"referenceID": 32, "context": "3 in [38] for more discussions on this issue).", "startOffset": 5, "endOffset": 9}, {"referenceID": 59, "context": "And furthermore SAT and UNSAT is not distinguished in [71] and in subsequent work directly relying on it; see Subsection 1.", "startOffset": 54, "endOffset": 58}, {"referenceID": 43, "context": "2 in [53] for a discussion of this.", "startOffset": 5, "endOffset": 9}, {"referenceID": 21, "context": "So the four choices for \u03a00 considered in [27] are HO, 2\u2013CLS, RHO and QHO.", "startOffset": 41, "endOffset": 45}, {"referenceID": 21, "context": "Due to these weaknesses, [27] does not consider a hierarchy generalising UC.", "startOffset": 25, "endOffset": 29}, {"referenceID": 32, "context": "3 in [38] for results in this direction.", "startOffset": 5, "endOffset": 9}, {"referenceID": 21, "context": "1)[27] actually favours adding unit-clauses to F , but we consider applying partial assignments as more fundamental.", "startOffset": 2, "endOffset": 6}, {"referenceID": 14, "context": "[18] gives an overview of the CNF-based target languages (prime implicates, UC, 2\u2013CLS, Horn clause-sets).", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[29] consider disjunctions of simple CNF classes.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[25] provides an overview of target compilation languages based on \u201cnested\u201d (graph-based) classes, namely variants of NNF, DNNF and BDDs.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2\u2013CLS in UC2.", "startOffset": 34, "endOffset": 46}, {"referenceID": 19, "context": "All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2\u2013CLS in UC2.", "startOffset": 34, "endOffset": 46}, {"referenceID": 23, "context": "All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2\u2013CLS in UC2.", "startOffset": 34, "endOffset": 46}, {"referenceID": 40, "context": "And see [49] for a basic negative result, characterising what can be represented under the relative condition (i.", "startOffset": 8, "endOffset": 12}, {"referenceID": 55, "context": "The notion of minimal unsatisfiability (MU) and minimally unsatisfiable subsets (MUS) is important in understanding the combinatorics of unsatisfiable clause-sets (see [52, 66]).", "startOffset": 168, "endOffset": 176}, {"referenceID": 51, "context": "To understand the structure of satisfiable clause-sets and their associated boolean functions, we now consider the concept of \u201cminimal premise sets\u201d (MPS) introduced in [62].", "startOffset": 169, "endOffset": 173}, {"referenceID": 62, "context": "[75] introduced a special type of boolean functions, called Non-repeating Unate Decision trees (NUD) there, by adding new variables to each clause of clause-sets in SMU\u03b4=1, which is the class of unsatisfiable hitting clause-sets of deficiency \u03b4 = 1.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "In [26] (Example 2) a separation was already shown between UC0 (clause-sets containing all of their prime implicates) and UC1 = UC, and the question was raised of the worst-case growth when compiling from an arbitrary CNF clause-set F to some equivalent F \u2032 \u2208 UC.", "startOffset": 3, "endOffset": 7}, {"referenceID": 5, "context": "This question was partly answered in [8] (although the connection was not made), where the authors provide examples of poly-size clausesets with only super-polynomial size representations in UC, even when allowing new variables (see Subsections 7.", "startOffset": 37, "endOffset": 40}, {"referenceID": 6, "context": "5, and [9] for more on the connection between [8] and UCk).", "startOffset": 7, "endOffset": 10}, {"referenceID": 5, "context": "5, and [9] for more on the connection between [8] and UCk).", "startOffset": 46, "endOffset": 49}, {"referenceID": 20, "context": "Our separation result now answers the question of worst-case growth from [26] in full generality with the hierarchy UCk.", "startOffset": 73, "endOffset": 77}, {"referenceID": 20, "context": "This separation, between UCk+1 and UCk for arbitrary k, is more involved than the simple separation in [26], due to the parameterised use of more advanced polynomial-time methods than r1 (UCP).", "startOffset": 103, "endOffset": 107}, {"referenceID": 47, "context": "Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]).", "startOffset": 142, "endOffset": 146}, {"referenceID": 35, "context": "Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]).", "startOffset": 156, "endOffset": 160}, {"referenceID": 54, "context": "Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]).", "startOffset": 172, "endOffset": 176}, {"referenceID": 63, "context": "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.", "startOffset": 52, "endOffset": 56}, {"referenceID": 7, "context": "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.", "startOffset": 71, "endOffset": 79}, {"referenceID": 8, "context": "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.", "startOffset": 71, "endOffset": 79}, {"referenceID": 8, "context": "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.", "startOffset": 140, "endOffset": 148}, {"referenceID": 9, "context": "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.", "startOffset": 140, "endOffset": 148}, {"referenceID": 66, "context": "Furthermore, in general rk is used, in even stronger versions, in the St\u030aalmarck-solver (see [81, 40, 73], and see Section 3.", "startOffset": 93, "endOffset": 105}, {"referenceID": 34, "context": "Furthermore, in general rk is used, in even stronger versions, in the St\u030aalmarck-solver (see [81, 40, 73], and see Section 3.", "startOffset": 93, "endOffset": 105}, {"referenceID": 60, "context": "Furthermore, in general rk is used, in even stronger versions, in the St\u030aalmarck-solver (see [81, 40, 73], and see Section 3.", "startOffset": 93, "endOffset": 105}, {"referenceID": 43, "context": "5 of [53] for a discussion of the connections to rk), and via breadth-first \u201cbranch/merge\u201d rules in HeerHugo (see [33]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 27, "context": "5 of [53] for a discussion of the connections to rk), and via breadth-first \u201cbranch/merge\u201d rules in HeerHugo (see [33]).", "startOffset": 114, "endOffset": 118}, {"referenceID": 56, "context": "In [68, 69] it is argued that modern SAT solvers can simulate full resolution \u2014 and this is considered to be a good property of SAT solvers.", "startOffset": 3, "endOffset": 11}, {"referenceID": 57, "context": "In [68, 69] it is argued that modern SAT solvers can simulate full resolution \u2014 and this is considered to be a good property of SAT solvers.", "startOffset": 3, "endOffset": 11}, {"referenceID": 58, "context": "It has been noted in the literature at several places (see [70, 44, 28]), that one might use only one of the two directions of the equivalences in the Tseitintranslation.", "startOffset": 59, "endOffset": 71}, {"referenceID": 22, "context": "It has been noted in the literature at several places (see [70, 44, 28]), that one might use only one of the two directions of the equivalences in the Tseitintranslation.", "startOffset": 59, "endOffset": 71}, {"referenceID": 31, "context": "5 of [37, 38] discusses the translation of the so-called \u201cSchaefer classes\u201d into the UCk hierarchy; see Section 12.", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "5 of [37, 38] discusses the translation of the so-called \u201cSchaefer classes\u201d into the UCk hierarchy; see Section 12.", "startOffset": 5, "endOffset": 13}, {"referenceID": 18, "context": "2 in [24] for an introduction, and see [23] for an in-depth overview on recent developments.", "startOffset": 39, "endOffset": 43}, {"referenceID": 43, "context": "In what respect is the terminology \u201chardness\u201d appropriate? The hardness measure hd(F ) has been introduced in [53, 59], based on quasi-automatisation of tree-resolution, that is, on a specific algorithmic approach (close to St\u030aalmarcks approach).", "startOffset": 110, "endOffset": 118}, {"referenceID": 49, "context": "In what respect is the terminology \u201chardness\u201d appropriate? The hardness measure hd(F ) has been introduced in [53, 59], based on quasi-automatisation of tree-resolution, that is, on a specific algorithmic approach (close to St\u030aalmarcks approach).", "startOffset": 110, "endOffset": 118}, {"referenceID": 0, "context": "In [1], hd(F ) for unsatisfiable F was proposed as measure of SAT-solverhardness in general.", "startOffset": 3, "endOffset": 6}, {"referenceID": 37, "context": "This was criticised in [46] by the argument, that conflict-driven SAT solvers would be closer to dag-resolution (full resolution) than tree-resolution.", "startOffset": 23, "endOffset": 27}, {"referenceID": 43, "context": "The main results on size lower bounds for the hardness are: 4)Using the simplest oracle, on unsatisfiable instances the measure from [53, 59] yields hd(F ).", "startOffset": 133, "endOffset": 141}, {"referenceID": 49, "context": "The main results on size lower bounds for the hardness are: 4)Using the simplest oracle, on unsatisfiable instances the measure from [53, 59] yields hd(F ).", "startOffset": 133, "endOffset": 141}, {"referenceID": 43, "context": "But on satisfiable instances the approach of [53, 59] is very different, namely an algorithmic polynomial-time approach is taken, extending the breadth-first search for tree-resolution refutations in a natural way.", "startOffset": 45, "endOffset": 53}, {"referenceID": 49, "context": "But on satisfiable instances the approach of [53, 59] is very different, namely an algorithmic polynomial-time approach is taken, extending the breadth-first search for tree-resolution refutations in a natural way.", "startOffset": 45, "endOffset": 53}, {"referenceID": 17, "context": "Note that by the de Morgan rules from the CNF-formula we obtain the DNFformula via negating the whole formula together with negating the literals (in other words, the underlying boolean function of a CNF-clause-set F is the \u201cdual\u201d of the underlying boolean function of the DNF-clause-set F ; see [22]).", "startOffset": 296, "endOffset": 300}, {"referenceID": 17, "context": "1 The clause-set F = {{v}} has the equivalent DNF-clause-set F = {{v}} (the underlying boolean function is \u201cself-dual\u201d; see [22]), while the negation is {{v}}.", "startOffset": 124, "endOffset": 128}, {"referenceID": 43, "context": "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.", "startOffset": 67, "endOffset": 87}, {"referenceID": 49, "context": "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.", "startOffset": 67, "endOffset": 87}, {"referenceID": 30, "context": "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.", "startOffset": 67, "endOffset": 87}, {"referenceID": 31, "context": "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.", "startOffset": 67, "endOffset": 87}, {"referenceID": 32, "context": "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.", "startOffset": 67, "endOffset": 87}, {"referenceID": 43, "context": "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].", "startOffset": 57, "endOffset": 65}, {"referenceID": 49, "context": "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].", "startOffset": 57, "endOffset": 65}, {"referenceID": 0, "context": "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].", "startOffset": 141, "endOffset": 144}, {"referenceID": 30, "context": "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].", "startOffset": 176, "endOffset": 188}, {"referenceID": 31, "context": "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].", "startOffset": 176, "endOffset": 188}, {"referenceID": 32, "context": "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].", "startOffset": 176, "endOffset": 188}, {"referenceID": 30, "context": "3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):", "startOffset": 163, "endOffset": 175}, {"referenceID": 31, "context": "3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):", "startOffset": 163, "endOffset": 175}, {"referenceID": 32, "context": "3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):", "startOffset": 163, "endOffset": 175}, {"referenceID": 43, "context": "4 Consider the reductions rk : CLS \u2192 CLS for k \u2208 N0 as introduced in [53]; it is r1 unit-clause propagation, while r2 is (full, iterated) failed-literal elimination.", "startOffset": 69, "endOffset": 73}, {"referenceID": 20, "context": "UC1 = UC is the class of unit-refutation complete clause-sets, as introduced in [26].", "startOffset": 80, "endOffset": 84}, {"referenceID": 30, "context": "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).", "startOffset": 3, "endOffset": 15}, {"referenceID": 31, "context": "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).", "startOffset": 3, "endOffset": 15}, {"referenceID": 32, "context": "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).", "startOffset": 3, "endOffset": 15}, {"referenceID": 25, "context": "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).", "startOffset": 130, "endOffset": 134}, {"referenceID": 15, "context": "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k \u2265 1.", "startOffset": 6, "endOffset": 10}, {"referenceID": 30, "context": "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k \u2265 1.", "startOffset": 27, "endOffset": 39}, {"referenceID": 31, "context": "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k \u2265 1.", "startOffset": 27, "endOffset": 39}, {"referenceID": 32, "context": "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k \u2265 1.", "startOffset": 27, "endOffset": 39}, {"referenceID": 43, "context": "2 of [53].", "startOffset": 5, "endOffset": 9}, {"referenceID": 43, "context": "17 from [53], sufficient for our purposes, is as follows (with a technical correction, as explained in Example 3.", "startOffset": 8, "endOffset": 12}, {"referenceID": 43, "context": "17 in [53] doesn\u2019t state the condition (i) from Lemma 3.", "startOffset": 6, "endOffset": 10}, {"referenceID": 43, "context": "The following example shows that this condition actually needs to be stated (that is, if we just have (ii) and (iii), then h doesn\u2019t need to be a lower bound for hd); fortunately in all applications in [53] this (natural) condition is fulfilled.", "startOffset": 202, "endOffset": 206}, {"referenceID": 57, "context": "Complementary to \u201cunit-refutation completeness\u201d, there is the notion of \u201cpropagation-completeness\u201d as investigated in [69, 15], yielding the class PC \u2282 UC.", "startOffset": 118, "endOffset": 126}, {"referenceID": 11, "context": "Complementary to \u201cunit-refutation completeness\u201d, there is the notion of \u201cpropagation-completeness\u201d as investigated in [69, 15], yielding the class PC \u2282 UC.", "startOffset": 118, "endOffset": 126}, {"referenceID": 31, "context": "This was captured and generalised by a measure phd : CLS \u2192 N0 of \u201cpropagationhardness\u201d along with the associated hierarchy, defined in [37, 38] as follows:", "startOffset": 135, "endOffset": 143}, {"referenceID": 32, "context": "This was captured and generalised by a measure phd : CLS \u2192 N0 of \u201cpropagationhardness\u201d along with the associated hierarchy, defined in [37, 38] as follows:", "startOffset": 135, "endOffset": 143}, {"referenceID": 43, "context": "8 For F \u2208 CLS we define the propagation-hardness (for short \u201cp-hardness\u201d) phd(F ) \u2208 N0 as the minimal k \u2208 N0 such that for all partial assignments \u03c6 \u2208 PASS we have rk(\u03c6 \u2217 F ) = r\u221e(\u03c6 \u2217 F ), where rk : CLS \u2192 CLS is generalised UCP ([53, 59]), and r\u221e : CLS \u2192 CLS applies all forced assignments, and can be defined by r\u221e(F ) := rn(F )(F ).", "startOffset": 230, "endOffset": 238}, {"referenceID": 49, "context": "8 For F \u2208 CLS we define the propagation-hardness (for short \u201cp-hardness\u201d) phd(F ) \u2208 N0 as the minimal k \u2208 N0 such that for all partial assignments \u03c6 \u2208 PASS we have rk(\u03c6 \u2217 F ) = r\u221e(\u03c6 \u2217 F ), where rk : CLS \u2192 CLS is generalised UCP ([53, 59]), and r\u221e : CLS \u2192 CLS applies all forced assignments, and can be defined by r\u221e(F ) := rn(F )(F ).", "startOffset": 230, "endOffset": 238}, {"referenceID": 4, "context": "A basic weakness of the standard notion of width-restricted resolution, which demands that both parent clauses must have length at most k for some fixed k \u2208 N0 (the \u201cwidth\u201d; see [7]), is that even Horn clause-sets require unbounded width in this sense.", "startOffset": 178, "endOffset": 181}, {"referenceID": 43, "context": "The correct solution, as investigated and discussed in [53, 59], is to use the notion of \u201ck-resolution\u201d as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution).", "startOffset": 55, "endOffset": 63}, {"referenceID": 49, "context": "The correct solution, as investigated and discussed in [53, 59], is to use the notion of \u201ck-resolution\u201d as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution).", "startOffset": 55, "endOffset": 63}, {"referenceID": 42, "context": "The correct solution, as investigated and discussed in [53, 59], is to use the notion of \u201ck-resolution\u201d as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution).", "startOffset": 121, "endOffset": 125}, {"referenceID": 43, "context": "Nested input-resolution ([53, 59]) is the proof-theoretic basis of hardness, and approximates tree-resolution.", "startOffset": 25, "endOffset": 33}, {"referenceID": 49, "context": "Nested input-resolution ([53, 59]) is the proof-theoretic basis of hardness, and approximates tree-resolution.", "startOffset": 25, "endOffset": 33}, {"referenceID": 49, "context": "12 in [59]):", "startOffset": 6, "endOffset": 10}, {"referenceID": 43, "context": "2 in [53], and is a special case of widU introduced in Subsection 6.", "startOffset": 5, "endOffset": 9}, {"referenceID": 49, "context": "1 of [59]).", "startOffset": 5, "endOffset": 9}, {"referenceID": 49, "context": "8 in [59] for unsatisfiable clause-sets, which extends to satisfiable clausesets by definition).", "startOffset": 5, "endOffset": 9}, {"referenceID": 13, "context": "For unsatisfiable F , whether whd(F ) = k holds for k \u2208 {0, 1, 2} can be decided in polynomial time; this is non-trivial for k = 2 ([17]) and unknown for k > 2.", "startOffset": 132, "endOffset": 136}, {"referenceID": 49, "context": "5 of [59], by actually using a slight strengthening of k-resolution, which combines width-bounded resolution and input resolution.", "startOffset": 5, "endOffset": 9}, {"referenceID": 49, "context": "12 in [59] we obtain for F \u2208 USAT , n(F ) 6= 0, the following general lower bound on resolution complexity:", "startOffset": 6, "endOffset": 10}, {"referenceID": 30, "context": "Similar to Theorem 14 in [36] resp.", "startOffset": 25, "endOffset": 29}, {"referenceID": 31, "context": "7 in [37, 38] we thus obtain:", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "7 in [37, 38] we thus obtain:", "startOffset": 5, "endOffset": 13}, {"referenceID": 51, "context": "In this section we study \u201cminimal premise sets\u201d, \u201cmps\u2019s\u201d for short, introduced in [62], together with the properties of \u201cdoped\u201d clause-sets, generalising a construction used in [75].", "startOffset": 82, "endOffset": 86}, {"referenceID": 62, "context": "In this section we study \u201cminimal premise sets\u201d, \u201cmps\u2019s\u201d for short, introduced in [62], together with the properties of \u201cdoped\u201d clause-sets, generalising a construction used in [75].", "startOffset": 177, "endOffset": 181}, {"referenceID": 51, "context": "1 in [62] basic properties of minimal premise sets are considered:", "startOffset": 5, "endOffset": 9}, {"referenceID": 51, "context": "5 in [62] we see that no clause-set can minimally entail more than one clause:", "startOffset": 5, "endOffset": 9}, {"referenceID": 51, "context": "4 in [62] we get the main characterisation of mps\u2019s, namely that after elimination of pure literals they must be minimally unsatisfiable:", "startOffset": 5, "endOffset": 9}, {"referenceID": 55, "context": "For unsatisfiable clause-sets the set of minimally unsatisfiable sub-clause-sets has been studied extensively in the literature; see [66] for a recent overview.", "startOffset": 133, "endOffset": 137}, {"referenceID": 51, "context": "6 of [62], misplacing the \u201c\u22121\u201d into the exponent.", "startOffset": 5, "endOffset": 9}, {"referenceID": 31, "context": "5 in [37, 38], all UCk are closed under partial assignments, so for \u03c6 := \u3008u\u22a5 \u2192 1\u3009\u222a\u3008uC \u2192 0 | C \u2208 F \u2032\u3009 we have hd(D(F )) \u2265 hd(\u03c6 \u2217D(F )) = hd(F \u2032) > hd(F ) = 0.", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "5 in [37, 38], all UCk are closed under partial assignments, so for \u03c6 := \u3008u\u22a5 \u2192 1\u3009\u222a\u3008uC \u2192 0 | C \u2208 F \u2032\u3009 we have hd(D(F )) \u2265 hd(\u03c6 \u2217D(F )) = hd(F \u2032) > hd(F ) = 0.", "startOffset": 5, "endOffset": 13}, {"referenceID": 46, "context": "In [56] (generalised in [62]) it is shown that the elements of SMU\u03b4=1 are exactly the clause-sets introduced in [21].", "startOffset": 3, "endOffset": 7}, {"referenceID": 51, "context": "In [56] (generalised in [62]) it is shown that the elements of SMU\u03b4=1 are exactly the clause-sets introduced in [21].", "startOffset": 24, "endOffset": 28}, {"referenceID": 16, "context": "In [56] (generalised in [62]) it is shown that the elements of SMU\u03b4=1 are exactly the clause-sets introduced in [21].", "startOffset": 112, "endOffset": 116}, {"referenceID": 46, "context": "5 in [56]:", "startOffset": 5, "endOffset": 9}, {"referenceID": 52, "context": "It is well-known that UHIT \u2282 SMU holds (for a proof see Lemma 2 in [63]).", "startOffset": 67, "endOffset": 71}, {"referenceID": 48, "context": "In [58], Corollary 34, it was shown that that an unsatisfiable clause-sets F has precisely one clash between any pair of different clause-sets iff F \u2208 SMU\u03b4=1 holds (an alternative proof was found in [75]).", "startOffset": 3, "endOffset": 7}, {"referenceID": 62, "context": "In [58], Corollary 34, it was shown that that an unsatisfiable clause-sets F has precisely one clash between any pair of different clause-sets iff F \u2208 SMU\u03b4=1 holds (an alternative proof was found in [75]).", "startOffset": 199, "endOffset": 203}, {"referenceID": 48, "context": "Now assume F \u2208 SMU\u03b4=1, and we have to show that F 6)In [58] the notation \u201cUHIT \u201d was used to denote \u201cuniform hitting clause-sets\u201d, which is now more appropriately called \u201c(conflict-)regular hitting clause-sets\u201d, while \u201cU\u201d now stands for \u201cunsatisfiable\u201d.", "startOffset": 55, "endOffset": 59}, {"referenceID": 51, "context": "14 That every 2-element sub-clause-set of F \u2208 CLS is an mps, that is, every two (different) clauses of F clash in precisely one literal, says that F is 1-regular hitting in the terminology of [62], Section 6.", "startOffset": 192, "endOffset": 196}, {"referenceID": 48, "context": "For an interesting example with deficiency 1 see Section 5 in [58].", "startOffset": 62, "endOffset": 66}, {"referenceID": 62, "context": "We arrive at a simple and perspicuous proof of the main result of [75], that the clause-sets F with |prc0(F )| = 2 ) \u2212 1 are precisely the clause-sets D(F ) for F \u2208 SMU\u03b4=1 when allowing to replace the single doping variable of a clause by any non-empty set of new (pure) literals:", "startOffset": 66, "endOffset": 70}, {"referenceID": 31, "context": "2 of [37, 38] we have prc0(F ) = F .", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "2 of [37, 38] we have prc0(F ) = F .", "startOffset": 5, "endOffset": 13}, {"referenceID": 31, "context": "2 of [37, 38].", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "2 of [37, 38].", "startOffset": 5, "endOffset": 13}, {"referenceID": 49, "context": "1 in [59].", "startOffset": 5, "endOffset": 9}, {"referenceID": 20, "context": "A simple example demonstrates the separation between UC0 and UC1 (similar to [26], Example 2, which uses Example 6.", "startOffset": 77, "endOffset": 81}, {"referenceID": 41, "context": "1 from [50]):", "startOffset": 7, "endOffset": 11}, {"referenceID": 41, "context": "1 from [50]:", "startOffset": 7, "endOffset": 11}, {"referenceID": 65, "context": "By Sperner\u2019s Theorem ([80]) holds |S0| \u2264 M , and this upper bound M is realised, just observing the antichain-condition, by choosing for S0 the set ( lvs(T0) m\u2032 ) of subsets of lvs(T0) of size m \u2032.", "startOffset": 22, "endOffset": 26}, {"referenceID": 31, "context": "1 from [37, 38] that UCk, and indeed also WCk, is a proper hierarchy of boolean functions regarding polysize representations without new variables (see Subsection 7.", "startOffset": 7, "endOffset": 15}, {"referenceID": 32, "context": "1 from [37, 38] that UCk, and indeed also WCk, is a proper hierarchy of boolean functions regarding polysize representations without new variables (see Subsection 7.", "startOffset": 7, "endOffset": 15}, {"referenceID": 31, "context": "2 of [37, 38] we discussed representations of boolean functions in general.", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "2 of [37, 38] we discussed representations of boolean functions in general.", "startOffset": 5, "endOffset": 13}, {"referenceID": 31, "context": "We have conjectured in [37, 38] (Conjecture 9.", "startOffset": 23, "endOffset": 31}, {"referenceID": 32, "context": "We have conjectured in [37, 38] (Conjecture 9.", "startOffset": 23, "endOffset": 31}, {"referenceID": 5, "context": "Such an encoding is an extension of Theorem 1 in [8], using similar techniques.", "startOffset": 49, "endOffset": 52}, {"referenceID": 40, "context": "In [49] a more general version of Lemma 7.", "startOffset": 3, "endOffset": 7}, {"referenceID": 40, "context": "9 only establishes the 7)There is a mistake in [49] in that it claims that the Tseitin translation of all DNNFs maintain arc-consistency via UCP, however this is shown only for smooth DNNFs as confirmed by George Katirelos via e-mail in January 2012.", "startOffset": 47, "endOffset": 51}, {"referenceID": 17, "context": "6 and Chapter 7 in [22]), which are as clause-sets precisely the hitting clause-sets, then we obtain absolute hardness 1:", "startOffset": 19, "endOffset": 23}, {"referenceID": 44, "context": "And also note that in case of \u22a5 / \u2208 F the additional clauses of ct(F ), that is, the C \u2208 ct(F ) \\ ct(F ), are all blocked for ct(F ) (see [54, 55]), since C can not be resolved on the vct-variable in it.", "startOffset": 138, "endOffset": 146}, {"referenceID": 45, "context": "And also note that in case of \u22a5 / \u2208 F the additional clauses of ct(F ), that is, the C \u2208 ct(F ) \\ ct(F ), are all blocked for ct(F ) (see [54, 55]), since C can not be resolved on the vct-variable in it.", "startOffset": 138, "endOffset": 146}, {"referenceID": 5, "context": "Basic results for showing such a lower bound are obtained in [8].", "startOffset": 61, "endOffset": 64}, {"referenceID": 43, "context": "Thus at each leaf we can attach a splitting tree of Horton-Strahler number of hardness at most max\u03c8\u2208P hd(\u03c8\u2217F ), and from that (via the well-known correspondence of splitting trees and resolution trees; see [53, 59] for details) we obtain a resolution tree fulfilling the desired hardness bound.", "startOffset": 206, "endOffset": 214}, {"referenceID": 49, "context": "Thus at each leaf we can attach a splitting tree of Horton-Strahler number of hardness at most max\u03c8\u2208P hd(\u03c8\u2217F ), and from that (via the well-known correspondence of splitting trees and resolution trees; see [53, 59] for details) we obtain a resolution tree fulfilling the desired hardness bound.", "startOffset": 206, "endOffset": 214}, {"referenceID": 30, "context": "1 with F := F1\u222aF2 and V := var(F1)\u2229var(F2), and apply the general upper bound hd(F1 \u222a F2) \u2264 max(hd(F1), hd(F2)) for variable-disjoint F1, F2 (Lemma 15 in [36]).", "startOffset": 154, "endOffset": 158}, {"referenceID": 49, "context": "1, part 1, in [59]).", "startOffset": 14, "endOffset": 18}, {"referenceID": 30, "context": "By Lemma 19 in [36] we have hd(\u03c8 \u2217 F ) \u2264 2, and thus hd(F ) \u2264 (n \u2212 2) + 2 = n.", "startOffset": 15, "endOffset": 19}, {"referenceID": 43, "context": "18 in [53], since then F would be simply the clause-set with all 2 clauses of length n.", "startOffset": 6, "endOffset": 10}, {"referenceID": 32, "context": "7 in [38].", "startOffset": 5, "endOffset": 9}, {"referenceID": 47, "context": "OKsolver ([57]): a look-ahead solver, used as a \u201ctheoretical\u201d solver.", "startOffset": 10, "endOffset": 14}, {"referenceID": 63, "context": "6 (see [76]).", "startOffset": 7, "endOffset": 11}, {"referenceID": 1, "context": "0 (see [3]).", "startOffset": 7, "endOffset": 10}, {"referenceID": 7, "context": "(a) PicoSAT, version 913 (see[10, 12]).", "startOffset": 29, "endOffset": 37}, {"referenceID": 8, "context": "(a) PicoSAT, version 913 (see[10, 12]).", "startOffset": 29, "endOffset": 37}, {"referenceID": 8, "context": "(c) Lingeling, version ala-b02aa1a-121013 (see [12, 13]).", "startOffset": 47, "endOffset": 55}, {"referenceID": 9, "context": "(c) Lingeling, version ala-b02aa1a-121013 (see [12, 13]).", "startOffset": 47, "endOffset": 55}, {"referenceID": 71, "context": "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR\u2217(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].", "startOffset": 105, "endOffset": 109}, {"referenceID": 15, "context": "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR\u2217(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].", "startOffset": 134, "endOffset": 138}, {"referenceID": 3, "context": "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR\u2217(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].", "startOffset": 167, "endOffset": 170}, {"referenceID": 30, "context": "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR\u2217(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].", "startOffset": 218, "endOffset": 230}, {"referenceID": 31, "context": "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR\u2217(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].", "startOffset": 218, "endOffset": 230}, {"referenceID": 32, "context": "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR\u2217(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].", "startOffset": 218, "endOffset": 230}, {"referenceID": 32, "context": "3 Compilation procedures For a given boolean function f and k \u2208 N0, how do we find algorithmically a \u201csmall\u201d equivalent F \u2208 UCk ? In [38], Section 8, the notion of a \u201ck-base for f\u201d is introduced, which is an F \u2208 UCk equivalent to f , with F \u2286 prc0(f) and where no clause can be removed without increasing the hardness or destroying equivalence.", "startOffset": 133, "endOffset": 137}, {"referenceID": 29, "context": "The most basic approach filters out unneeded prime implicates; see [35, 34] for some initial applications to cryptanalysis.", "startOffset": 67, "endOffset": 75}, {"referenceID": 28, "context": "The most basic approach filters out unneeded prime implicates; see [35, 34] for some initial applications to cryptanalysis.", "startOffset": 67, "endOffset": 75}, {"referenceID": 29, "context": "A simple filtering heuristic, used in [35, 34], is to favour (keeping) short-clauses.", "startOffset": 38, "endOffset": 46}, {"referenceID": 28, "context": "A simple filtering heuristic, used in [35, 34], is to favour (keeping) short-clauses.", "startOffset": 38, "endOffset": 46}, {"referenceID": 11, "context": "Essentially the same heuristic is considered in [15] (called \u201clength-increasing iterative empowerment\u201d) when generating representations in PC.", "startOffset": 48, "endOffset": 52}, {"referenceID": 20, "context": "For the case that f is given by a CNF F0, in [26] one finds refinements of the resolution procedure applied to F0, which would normally compute prc0(f), i.", "startOffset": 45, "endOffset": 49}, {"referenceID": 32, "context": "A first task is to investigate which of the results on hardness from this article and from [38] can be adapted to w-hardness.", "startOffset": 91, "endOffset": 95}, {"referenceID": 6, "context": "In [9] we will present some basic methods for w-hardness bounds.", "startOffset": 3, "endOffset": 6}, {"referenceID": 5, "context": "Can the classes WCk go beyond monotone circuits, which were shown in [8] to be strongly related to the expressive power of arc-consistent CNF representations (see the following subsection for some further remarks)? Conjecture 7.", "startOffset": 69, "endOffset": 72}, {"referenceID": 5, "context": "So the conjecture is that here we have another example for the limitations of arc-consistent representations as shown in [8].", "startOffset": 121, "endOffset": 124}, {"referenceID": 43, "context": "To overcome these (conjectured) limitations, the theory started here has to be generalised via the use of oracles as developed in [53, 59], and further discussed in Subsection 9.", "startOffset": 130, "endOffset": 138}, {"referenceID": 49, "context": "To overcome these (conjectured) limitations, the theory started here has to be generalised via the use of oracles as developed in [53, 59], and further discussed in Subsection 9.", "startOffset": 130, "endOffset": 138}, {"referenceID": 31, "context": "4 of [37, 38].", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "4 of [37, 38].", "startOffset": 5, "endOffset": 13}, {"referenceID": 64, "context": "Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).", "startOffset": 116, "endOffset": 136}, {"referenceID": 33, "context": "Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).", "startOffset": 116, "endOffset": 136}, {"referenceID": 53, "context": "Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).", "startOffset": 116, "endOffset": 136}, {"referenceID": 24, "context": "And for some oracles, like detection of minimally unsatisfiable clause-sets of a given deficiency, the problems would turn from polytime to NP-hard in this way ([30, 16]).", "startOffset": 161, "endOffset": 169}, {"referenceID": 12, "context": "And for some oracles, like detection of minimally unsatisfiable clause-sets of a given deficiency, the problems would turn from polytime to NP-hard in this way ([30, 16]).", "startOffset": 161, "endOffset": 169}, {"referenceID": 6, "context": "In [9] we show hd(PHPmm) = whd(PHP m m) = m \u2212 1, and so the (standard representation) PHPmm \u2208 CLS itself is not a good representation (it is small, but has high w-hardness).", "startOffset": 3, "endOffset": 6}, {"referenceID": 6, "context": "Actually, as explained in [9], from [8] it follows that PHPmm has no polysize arc-consistent representation at all! So again, here oracles are needed; see Subsection 9.", "startOffset": 26, "endOffset": 29}, {"referenceID": 5, "context": "Actually, as explained in [9], from [8] it follows that PHPmm has no polysize arc-consistent representation at all! So again, here oracles are needed; see Subsection 9.", "startOffset": 36, "endOffset": 39}, {"referenceID": 31, "context": "4 of [37, 38] for a proposal of an interesting oracle (with potentially good stability properties).", "startOffset": 5, "endOffset": 13}, {"referenceID": 32, "context": "4 of [37, 38] for a proposal of an interesting oracle (with potentially good stability properties).", "startOffset": 5, "endOffset": 13}], "year": 2013, "abstractText": "We consider the fundamental task of representing a boolean function f by a conjunctive normal form (clause-set) F for the purpose of SAT solving. The boolean function f here acts as a kind of constraint, like a cardinality constraint or an S-box in a cryptosystem, while F is a subset of the whole SAT problem to be solved. The traditional approach towards \u201cgood\u201d properties of F considers \u201carc consistency\u201d, which demands that for every partial instantiation of f , all forced assignments can be recovered from the corresponding partial assignment to F via unit-clause propagation (UCP). We propose to consider a more refined framework: First, instead of considering the above relative condition, a relation between f and F , we consider an absolute condition, namely that goodness of F is guaranteed by F being element of a suitable target class. And second, instead of just considering UCP, we consider hierarchies of target classes, which allow for different mechanisms than UCP and allow for size/complexity trade-offs. The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F \u2208 UCk is to be achieved for k as small as feasible. Here UC1 = UC has been introduced in [26] for the purpose of knowledge compilation. In general, UCk is the set of clause-sets F such that unsatisfiable instantiations (by partial assignments) are recognisable by k-times nested unit-clause propagation. We also touch upon the hierarchy PCk of propagation complete clause-sets of level k, where PC1 = PC has been introduced in [15]. The hierarchy PCk refines the hierarchy UCk by providing intermediate layers. In order to make use of full resolution, we consider the hierarchy WCk of width-refutation complete clauses-sets of level k, employing an improved notion of width (so that we always have UCk \u2286 WCk). Via the absolute condition, the quality of the representation F is fully captured by the target class, and the only relation between f and F is that F must \u201crepresent\u201d f . If F does not contain new variables, then this means that F is equivalent to f , while with new variables the satisfying assignments of F projected to the variables of f must be precisely the satisfying assignments of f . Without new variables, the relative and absolute condition coincide, but with new variables, the absolute condition is stronger. As we remark in this article, for the relative condition and new variables at least the hierarchies UCk and PCk collapse, and we also conjecture that the WCk hierarchy collapses. The main result of this article is that without new variables, none of these hierarchies collapses. That means that there are boolean functions with only exponential-size equivalent clause-sets at level k, but with poly-size equivalent clause-sets at level k + 1.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}