{"id": "1307.0024", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Jun-2013", "title": "Investigation of \"Enhancing flexibility and robustness in multi-agent task scheduling\"", "abstract": "ian wilson et al. propose a measure of flexibility in project scheduling problems and currently propose several ways of distributing flexibility over tasks without overrunning the deadline. these distributing schedules did prove extremely quite robust : delays of some tasks don't necessarily lead to delays of subsequent tasks. the number of tasks that finish late depends, among others, on the simpler way of distributing flexibility.", "histories": [["v1", "Fri, 28 Jun 2013 20:20:27 GMT  (32kb,D)", "http://arxiv.org/abs/1307.0024v1", null]], "reviews": [], "SUBJECTS": "cs.DS cs.AI", "authors": ["daan wilmer"], "accepted": false, "id": "1307.0024"}, "pdf": {"name": "1307.0024.pdf", "metadata": {"source": "CRF", "title": "Empirical Evaluation of Algorithms: Final assignment", "authors": [], "emails": [], "sections": [{"heading": null, "text": "In this paper I study the different flexibility distributions proposed by Wilson et al. and the differences in number of violations (tasks that finish too late). I show one factor in the instances that causes differences in the number of violations, as well as two properties of the flexibility distribution that cause them to behave differently. Based on these findings, I propose three new flexibility distributions. Depending on the nature of the delays, these new flexibility distributions perform as good as or better than the distributions by Wilson et al."}, {"heading": "1 Introduction", "text": "Scheduling problems are very common in the real world. Tasks can often be split up in several activities that have to be performed, with some activities being dependent on the result of other activities. Equally common in the real world are delays: regularly, unforeseen circumstances extend the needed time for activities beyond their original planning. The question is: how to cope with these delays?\nWhen the completion time of the whole project is at stake, the answer is simple: start every activity as soon as possible, so the project is finished as soon as possible. However, sometimes it is not just the project itself, but the individual activities that must be finished in time \u2014 for example because of contracts with other parties. In this case the number of delayed activities should be minimised. Wilson, Witteveen, Klos and Huisman studied this problem in [2], using the notion of flexibility: the amount of leeway in the schedule. They propose adding flexibility to the schedule, distributing it over tasks, to increase robustness.\nWilson et al. test their algorithms using instances from PSPLIB, adding 10% to the minimal required to be the deadline. They then randomly extend activities to simulate delays, and test how many violations (delayed activities) there are. To stabilise the output they run the simulation 150 times. A more detailed description can be found in their paper[2].\nThe results they show are quite interesting. However they give little reasoning about causes for the variations. The goal of this paper is to look for the underlying causes that drive the differences between algorithms, and differences between results of the same algorithm."}, {"heading": "2 Problem", "text": "In this section I will provide a more detailed picture of the problem area. I will start with describing the problem that is being solved, followed by the contributions by Wilson et al. Finally I will describe the problem statement and objective of this paper."}, {"heading": "2.1 Project Scheduling Problem", "text": "The project scheduling problem can be defined as follows: given a set of tasks T , each having a length lt, and a set of precedence constraints C \u2282 T \u00d7 T , assign each task a start time st such that \u2200(t, u) \u2208 C : st + lt \u2264 su. In other words: there is a set of tasks with a certain length, and some tasks require others to be finished before they can start. The tasks that need to be completed\nar X\niv :1\n30 7.\n00 24\nv1 [\ncs .D\nS] 2\n8 Ju\nn 20\n13\nfor another task to start are called its predecessors, and the tasks that require that task to finish before they can start are called its successors. To state it in a more formal way: let Pt and St be the set of predecessors and successors of t, respectively. Then Pt = {u \u2208 T : (u, t) \u2208 C} and St = {u \u2208 T : (t, u) \u2208 C}.\nThis problem is quite simple and can be solved in polynomial time. It serves, however, as the base algorithm for some more interesting problems, for example the Resource Constrained Project Scheduling Problem.\nWilson et al. study this problem in a multi-agent setting. The problem is the same, but tasks are executed by different agents. These agents want some freedom to decide on when they execute the task, so they need some kind of flexibility.\nWilson et al. add this flexibility by assigning each task not a start time, but a start interval [at, bt] in which the task can be started. The flexibility of this task is defined as the length of this interval. The total flexibility of a schedule (an assignment of intervals to tasks) is then defined as the sum of all flexibilities.\nTo ensure autonomy, the problem needs a small adaptation. Considering the start interval [at, bt] of task t, the following must hold: \u2200(t, u) \u2208 C : bt + lt \u2264 au. In other words: the beginning of the start interval of a task cannot be earlier than the latest possible ending time of all its predecessors. This way both tasks can be started anytime in their own interval, without being hindered by other tasks.\nSuch a schedule is also quite robust: when one task is delayed, this does not necessarily mean that all following tasks are delayed. The flexibility can in this case be used to cancel out the delay. However, sometimes this is not enough and the tasks finishes after it should have been finished; this is called a violation. The question now becomes: how can flexibility be assigned to tasks in such a way that the number of violations is minimal?\nTo check the answer to this question, Wilson et al. simulate delays; they randomly pick a portion of the tasks, and these will be delayed by a certain amount. The number of tasks that is delayed and the amount by which they are delayed are parameters of the simulation. Of course, they cannot add an infinite amount of flexibility: they impose a deadline at 1.1 times the shortest possible makespan. To eliminate fluctuations due to randomisation they run this simulation 150 times."}, {"heading": "2.2 Algorithm and outcomes", "text": "Wilson et al. describe three main methods of assigning flexibility to the tasks: maximal, equalised and weighted. For the equalised distribution they calculate for each task the maximum possible flexibility, and then minimise the squared flexibility loss. For the weighted version they assign weights to the different tasks before minimising the flexibility loss, resulting in an increased flexibility for tasks with a higher weight. They propose three ways of weighting: by the number of direct predecessors, the number of predecessors N steps away (its predecessors, its predecessors\u2019 predecessors, etc. . . up to a distance of N), and the total number of predecessors (its predecessors, its predecessors\u2019 predecessors, etc. . . until there are no more). Finally, the maximal distribution maximises the total amount of flexibility in the schedule, and then equalises this flexibility without reducing the total flexibility.\nIn total this comes down to five distributions: maximal, equalised, weighted by number of predecessors, weighted by number of distance-N predecessors and weighted by all predecessors. These are all tested, and the results are quite interesting. The equalised distribution results in the least amount of violations, followed by the weighted distribution by number of predecessors, then the distribution weighted by the number of predecessors at most 5 steps away and finally the distribution weighted by the total number of predecessors. (see also Figure 3 in [2]). An interesting case is the maximal distribution: when the number of delays and the amount by which tasks are delayed are low, this distribution performs the worst of all distributions. However, when the number of delays or the length of the delays increase, this distribution gains on the others, resulting in less violations than the weighted distributions by total predecessors or distance-5 predecessors when the number of delays or the length of delays become relatively large.\nFurthermore, the spread of the number of violations is quite large \u2014 also within results for one distribution. This can be seen very well in Figure 4 of [2]: the variation in the number of violations is quite large, and differs from distribution to distribution."}, {"heading": "2.3 Problem statement", "text": "The results in [2] are quite interesting, but a real explanation is missing. The two questions that I will try to answer in this paper are:\n1. What properties of the instances cause them to produce more or less violations than other instances and why?\n2. What properties of the flexibility distributions cause them to perform better or worse and why?"}, {"heading": "3 Study", "text": "To develop hypotheses about the problem that answer the questions of the problem statement, I performed a study to investigate the algorithm and currently available results. In this study I looked for correlations between characteristics of the problem and performance in terms of number of violations.\nThese correlations were calculated using the cor() function in R,1 calculating the correlation coefficient between two data sets. I chose for this approach over graphs because of the amount of data points: there are 600 instances and four algorithms to compare. This produces a very dense cloud in which none but the strongest correlations can be seen."}, {"heading": "3.1 Instance properties", "text": "I first studied some instance properties to find correlations to the output. These instances have many measurable properties, but I narrowed the number of options down to four. I chose these, based on network descriptiveness \u2014 how much information does the metric give on the network of tasks \u2014 and ease of implementation, to increase time available for research.\nAverage tight width The average number of simultaneous tasks per time unit when all tasks are scheduled at their earliest start time. For each task at = bt = estt, and it is counted for all time units in [at, bt + lt). This measures the amount of parallelism \u2014 the number of tasks that can be scheduled in parallel \u2014 of the instance. This metric is similar to the inverse of the I2 metric defined in [1] for measuring network characteristics.\nAverage filled width The average number of simultaneous tasks per time unit with a filled schedule. This schedule is calculated as follows: at = est, bt = min(t,u)\u2208C{estu} \u2212 lt. Each task is counted in all time units where it could be active: [at, bt + lt). This metric is similar to the previous one, but also takes the flexibility in the system into account.\nNatural flexibility In the tight schedule, with all tasks scheduled at their earliest start time, not all tasks end at the start time of their earliest successor. This extra room I call the natural flexibility of an instance. This calculated as follows: flex = \u2211 t\u2208T min(t,u)\u2208C{estu} \u2212 estt.\nComplexity In Software Engineering, the Cyclomatic or McCabe complexity is a metric that describes the complexity of a function.2 This is done by converting a function into blocks of statements with edges between them if they are reachable, and then taking the difference between the number of edges and the number of nodes. Since PSP instances are basically directed graphs with an entry point and exit point, they are similar enough to be able to calculate the cyclomatic complexity for these. This metric measures the number of linearly independent paths (paths that cover at least one edge that has not been covered by other paths) through the network of tasks."}, {"heading": "3.1.1 Results", "text": "All correlation data gathered in this part of the study can be found in Appendix A. In those numbers, the following three observations can be made:\n1. It seems that with few and small delays there seems to be no correlation at all. When the size of delays increases, the correlations grow stronger, but much more when the number of delays increases.\n2. The average tight width does not seem to be correlated at all with the number of violations.\n3. The complexity seems to be quite strongly correlated to the number of violations.\nOf those three observations, the last one shows the strongest correlation between a metric and algorithm performance. I therefore focus on that observation. Apparently, instances that have a higher complexity tend to have more violations. Since the number of tasks is equal in all cases,\n1http://www.r-project.org/ 2See also https://en.wikipedia.org/wiki/Cyclomatic_complexity\na higher complexity directly implies that a tasks has more precedence constraints. This means that, in instances that have a higher complexity, tasks have on average more predecessors and more successors.\nOne explanation can be found in a causal connection between the number of successors of a tasks and the number of violations. After all: when a task is delayed more than it has flexibility, the \u201cexcess delay\u201d propagates to its successors. Depending on how tight the successors are scheduled to the task (at least one is scheduled tight, otherwise the task itself would have more flexibility), the excess delay propagates to one or more successors. When a task has on average more successors, excess delays can propagate to more tasks, thereby increasing the number of violations.\nAnother explanation could be, taken from the paper by Wilson et al.[2], that tasks that have more predecessors are more likely to have at least one predecessor having \u201cexcess delay\u201d. Since graphs with a higher complexity have more predecessors per task, the probability that a task gets propagated delay is higher, thereby increasing the number of violations. However, an algorithm based on this reasoning already failed to perform better than \u2014 or even as good as \u2014 a similar algorithm that does not take this reasoning into account[2]. It is therefore less likely that this explanation is correct, although I still take it into consideration."}, {"heading": "3.2 Flexibility distribution", "text": "To gain more insight in the flexibility distribution, I first analysed the distributions. The graphs can be found in Section C. In these graphs the bins are chosen [\u22122, 0], (0, 2], (2, 3] . . ., so that the first bin only counts tasks with a flexibility of zero (negative flexibilities are not possible).\nThe first thing that stands out is the large spike in the first bin, indicating that, on average, between 30% and 45% of the tasks get no flexibility at all. Since this varies almost 15 percentage points, the number of tasks that get no flexibility is the first property of the flexibility distribution to measure and correlate with number of violations.\nI add two more properties to measure, in order to further investigate the two explanations from the previous section concerning correlations between complexity and number of violations. Combined these measures form the following list:\nNumber of zeros The number of tasks that have exactly 0 (zero) flexibility.\nFlexibility \u00d7 number of predecessors For each task, multiply the flexibility by the number of predecessors that task has, and then take the sum over all tasks. This measures how much the flexibility is concentrated in tasks that have many predecessors.\nFlexibility \u00d7 number of successors For each task, multiply the flexibility by the number of successors that task has, and then take the sum over all tasks. This measures how much the flexibility is concentrated in tasks that have many successors.\nI investigated these metrics independently of the type of distribution they were generated with."}, {"heading": "3.2.1 Results", "text": "All correlation results can be found in Appendix B. Table 9 shows the correlations between these metrics and the number of violations, and some very interesting observations can be made.\nDepending on the number of delayed tasks and the amount by which they are delayed, the correlation between number of zero-flexibility tasks and number of violations can be quite strong. The correlation seems the strongest when there are many small delays, and the weakest when there are many large delays. I suspect this is because of delay propagation: when a task has no flexibility at all, any delay it gets will be propagated to its successors. This way, when more tasks have no flexibility, delays will be propagated more, resulting in more violations. However, when the total amount of delay becomes too high, this effect might be negated because tasks get more delay than can be handled by flexibility. In this case the number of zeros makes little difference: delays will be propagated anyway. When there are only few delays, the correlation is weaker\nThe second observation that can be made is that the flexibility multiplied by the number of predecessors is not correlated with the number of violations. This matches the results in [2], refuting the second explanation \u2014 regarding predecessors \u2014 for the correlation between complexity and number of violations.\nThe third observation is that the flexibility multiplied by the number of successors has a negative correlation with the number of violations. This supports the first explanation \u2014 regarding the number of successors \u2014 for the correlation between complexity and number of violations."}, {"heading": "4 Hypotheses", "text": "Concluding from this study, I propose two hypotheses that give an answer to the main question:\n1. Differences in algorithm performance on different instances are caused by differences in instance complexity, because in instances with higher complexity tasks have more successors so that delays are propagated to more tasks, increasing the number of violations.\n2. Differences between algorithms are caused by two factors:\n\u2022 The number of tasks that have no flexibility, because when there are more tasks without flexibility delays will be propagated more, causing more violations; \u2022 The assignment of flexibility to tasks that have many successors, because when a task has more successors delays will be propagated to more tasks, causing more violations; this can be partially prevented by assigning more flexibility to tasks that have many successors.\nOf these two factors the first one has more impact when delays are relatively small, while the second one has more impact when the total delay is much larger.\nThe first hypothesis links variance in performance to variance in complexity. To test this, experiments could be run in which the complexity of the instances is fixed. All other parameters being equal, this should result in lower variance in the number of violations.\nThe second hypothesis can be tested by experiments where new flexibility distributions are used. The two different factors can be tested separately, and might show the best results (least amount of violations, compared to other distributions) at different parameter settings for the delays. If they are both correct, the first factor will yield the best results with small delays, while experiments regarding the second factor will produce the strongest results when there are many large delays.\nIf the first factor is correct, a distribution that has less tasks with zero flexibility should perform better. One such distribution could calculate a minimum flexibility fmin that acts as a lower bound for the flexibility per task. This fmin should, of course, be as large as possible. After every task has this flexibility assigned, the remaining flexibility can be divided according to any of the other distributions.\nIf the second factor is true, a distribution that assigns more weight to task with many successors will perform better. One such distribution could be the weighted distribution, where the number of successors per task is used as the weight for that task.\nThese two distributions do not necessarily exclude eachother. Therefore, a combination of these two could also be created, by using the lower bound for flexibility for each task and then use the weighted distribution based on number of successors to divide the remaining flexibility. The performance of this combination distribution will probably be better than that of the equalized distribution, although it might \u2014 for specific parameter settings \u2014 not be as good as the specific distributions"}, {"heading": "5 Experiments", "text": "In order to test the hypotheses, I conducted another study and performed several experiments. For each hypothesis I describe what I did and show the results, concluding on whether the hypotheses are supported by the data."}, {"heading": "5.1 First hypothesis", "text": "To test the first hypothesis I studied the original data. This is possible because the used instances have only three complexity values: 63, 100 and 137. I divided the instances by complexity level and took the number of violations for the weighted distribution, based on all predecessors, with 80 % of tasks delayed by 80 %. This settings were chosen because the correlations are the strongest at these settings, from all measurements.\nFigure 1 shows the spread of the number of violations in instances with different complexity values. It can quite clearly be seen that the means of the three sets are different, which is verified by a t-test. What is most important, however, is the variance. For the combined set the variance is 99.3; the variance of the subsets with a complexity of 63, 100 and 137 are 66.1, 49.6 and 30.0, respectively. This supports the statement that differences in instance complexity cause a difference in the number of violations. There are, however, more factors that cause variance in the number of violations."}, {"heading": "5.2 Second hypothesis", "text": "In order to test the second hypothesis, I experimented with the distribution functions by adapting the original code by Michel Wilson[2]. I added three more flexibility distribution functions:\nwsucc Equalise the flexibility over tasks, weighted by number of successors.\nmax minflex Maximise the value fmin such that every task can get assigned this value as flexibility while the schedule will still be finished before the deadline. Then maximise the total flexibility in the schedule while keeping fmin as a lower bound for the flexibility of each task. Finally equalise the flexibility while ensuring the total flexibility is equal to the maximal flexibility, while keeping fmin as lower bound for the flexibility of each task.\nwsucc minflex Maximise fmin as described in the previous distribution function, and then equalise the flexibility over the tasks, weighted by number of successors, while keeping fmin as a lower bound for the flexibility of each task.\nI used two settings for the delay parameters: 80% of tasks delayed by 5% and 80% of tasks delayed by 80%. I chose these settings because they yielded the strongest correlations in previous experiments. The consolidated results of this experiment can be seen in Table 1.\nIt can clearly be seen that, when delays are small, max minflex perform best: tasks are never delayed more than their flexibility can compensate. This makes sense: because the deadline is set at 10% after the minimum execution time, each task gets assigned at least 10% of the average task length as flexibility. Since tasks are delayed 5 % of their length, violations only occur in tasks that are more than twice as long as the average task and are on the critical path. Tasks that are not on\nthe critical path can get more flexibility assigned, and therefore need to be even larger to cause a violation when they are delayed. Apparently such large tasks are not present in the istances. When delays are larger it performs only marginally better than the equalised algorithm. This matches the weak correlations between the number of zeros and the number of violations.\nThe distribution that assigns more weight to tasks with many successors, wsucc, shows the opposite effect: when there are many delays, it outperforms the equalised algorithm in all cases. When delays are smaller, it performs mostly worse than the equalised algorithm.\nThe distribution that is a combination of the other two introduced distributions, wsucc minflex, has also results that are a combination of the results of the other two. When delays are small, there are no violations; when delays are large, it outperforms the equalised algorithm in most cases. However, in the latter case, it does not perform as good as the wsucc distribution.\nThese results conform to the predictions about the second hypothesis stated in Section 4. I can therefore conclude that these experiments support the hypothesis."}, {"heading": "6 Conclusion and Future Work", "text": "In this paper I investigated the results by Wilson et al.[2] I raised two questions, which I both answered in this paper.\n1. What properties of the instances cause them to produce more or less violations than other instances and why? I found a strong correlation of instances with the number of violations that are created when delays are introduced. A causal relation is probable, but has not yet been verified or refuted by further investigation.\n2. What properties of the flexibility distributions cause them to perform better or worse and why? The study of flexibility distribution showed that it, depending on the delays, the difference between performance are caused by the number of tasks that receive zero flexibility and by the concentration of flexibility in tasks with many successors. Further experiments support this conclusion, improving the algorithms from the original paper in two different cases.\nThe studies and experiments are by no means exhaustive, and therefore the answers to the questions might not be entirely complete. However, they are quite accurate and help understand the problem and the algorithms.\nPossibilities for future work can be found in running more simulations to get a more complete overview of performance with respect to delay parameters. Besides that, the metrics for the instances and metrics for the flexibility distributions are quite limited in scope. In further work they could be expanded or improved, to find out whether the answers provided here are the only answers or that there are more factors at work.\nOther interesting research can be done investigating other ways of distributing flexibility. The proposed minflex distribution maximises the lower bound, but it could be interesting to find out if this is not maximised. Other distributions can include a relative flexibility assignment: assigning a percentage of the task length as flexibility. For example, when every task gets 10% flexibility, delays of 10% can be handled withouth violations. It should be investigated whether such a distribution is also desirable when delays grow larger."}, {"heading": "A Correlations of instance properties", "text": ""}, {"heading": "B Correlations of flexibility distribution properties", "text": ""}, {"heading": "C Flexibility distribution over tasks", "text": ""}], "references": [{"title": "An evaluation of the adequacy of project network generators with systematically sampled networks", "author": ["Mario Vanhoucke", "Jos Coelho", "Dieter Debels", "Broos Maenhout", "Lus V. Tavares"], "venue": "European Journal of Operational Research,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2008}], "referenceMentions": [{"referenceID": 0, "context": "This metric is similar to the inverse of the I2 metric defined in [1] for measuring network characteristics.", "startOffset": 66, "endOffset": 69}], "year": 2013, "abstractText": "Wilson et al. propose a measure of flexibility in project scheduling problems and propose several ways of distributing flexibility over tasks without overrunning the deadline. These schedules prove quite robust: delays of some tasks do not necessarily lead to delays of subsequent tasks. The number of tasks that finish late depends, among others, on the way of distributing flexibility. In this paper I study the different flexibility distributions proposed by Wilson et al. and the differences in number of violations (tasks that finish too late). I show one factor in the instances that causes differences in the number of violations, as well as two properties of the flexibility distribution that cause them to behave differently. Based on these findings, I propose three new flexibility distributions. Depending on the nature of the delays, these new flexibility distributions perform as good as or better than the distributions by Wilson et al.", "creator": "LaTeX with hyperref package"}}}