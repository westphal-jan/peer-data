{"id": "1311.2106", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Nov-2013", "title": "Submodular Optimization with Submodular Cover and Submodular Knapsack Constraints", "abstract": "we thus investigate two new quantitative optimization test problems - - minimizing a submodular screening function subject to a submodular lower bound constraint ( submodular cover ) and more maximizing a submodular density function subject to a submodular upper bound constraint ( submodular knapsack ). we are motivated by a number of real - world applications in machine learning including sensor placement efficiency and data subset selection, which require maximizing just a certain possible submodular function ( like coverage or diversity ) while simultaneously minimizing another ( like cooperative cost ). essentially these problems are often posed as minimizing than the difference between submodular functions [ 14, 35 ] which is in the worst case inapproximable. we show, however, that illustrate by phrasing these problems as fully constrained optimization, whereas which is more natural for many applications, we achieve a number of bounded approximation guarantees. we also show that considering both these problems are closely related and an approximation algorithm solving one can be used repeatedly to obtain an approximation guarantee argument for the other. we provide hardness results for both problems ; thus showing consistently that our approximation factors are tight limited up somewhat to log - factors. finally, we empirically demonstrate the performance and retain good scalability comparison properties of our approximate algorithms.", "histories": [["v1", "Fri, 8 Nov 2013 23:28:02 GMT  (53kb,D)", "http://arxiv.org/abs/1311.2106v1", "23 pages. A short version of this appeared in Advances of NIPS-2013"]], "COMMENTS": "23 pages. A short version of this appeared in Advances of NIPS-2013", "reviews": [], "SUBJECTS": "cs.DS cs.AI cs.DM", "authors": ["rishabh k iyer", "jeff a bilmes"], "accepted": true, "id": "1311.2106"}, "pdf": {"name": "1311.2106.pdf", "metadata": {"source": "CRF", "title": "Submodular Optimization with Submodular Cover and Submodular Knapsack Constraints", "authors": ["Rishabh Iyer", "Jeff Bilmes"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "A set function f : 2V \u2192 R is said to be submodular [8] if for all subsets S, T \u2286 V , it holds that f(S) + f(T ) \u2265 f(S \u222a T ) + f(S \u2229 T ). Defining f(j|S) , f(S \u222a j) \u2212 f(S) as the gain of j \u2208 V in the context of S \u2286 V , then f is submodular if and only if f(j|S) \u2265 f(j|T ) for all S \u2286 T and j /\u2208 T . The function f is monotone iff f(j|S) \u2265 0,\u2200j /\u2208 S, S \u2286 V . For convenience, we assume the ground set is V = {1, 2, \u00b7 \u00b7 \u00b7 , n}. While general set function optimization is often intractable, many forms of submodular function optimization can be solved near optimally or even optimally in certain cases, and hence submodularity is also often called the discrete analog of convexity [34]. Submodularity, moreover, is inherent in a large class of real-world applications, particularly in machine learning, therefore making them extremely useful in practice. In this paper, we study a new class of discrete optimization problems that have the following form:\nProblem 1 (SCSC): min{f(X) | g(X) \u2265 c}, and Problem 2 (SCSK): max{g(X) | f(X) \u2264 b},\nwhere f and g are monotone non-decreasing submodular functions that also, w.l.o.g., are normalized (f(\u2205) = g(\u2205) = 0)1, and where b and c refer to budget and cover parameters respectively. The corresponding constraints are called the submodular cover [47] and submodular knapsack [1] respectively and hence we refer to Problem\n1A monotone non-decreasing normalized (f(\u2205) = 0) submodular function is called a polymatroid function.\nar X\niv :1\n31 1.\n21 06\nv1 [\ncs .D\nS] 8\nN ov\n1 as Submodular Cost Submodular Cover (henceforth SCSC) and Problem 2 as Submodular Cost Submodular Knapsack (henceforth SCSK). Our motivation stems from an interesting class of problems that require minimizing a certain submodular function f while simultaneously maximizing another submodular function g. We shall see that these naturally occur in applications like sensor placement, data subset selection, and many other machine learning applications. A standard approach used in literature [14, 37, 22] has been to transform these problems into minimizing the difference between submodular functions (also called DS optimization):\nProblem 0: min X\u2286V\n( f(X)\u2212 g(X) ) . (1)\nWhile a number of heuristics are available for solving Problem 0, and while these heuristics often work well in practice [14, 37], in the worst-case it is NP-hard and inapproximable [14], even when f and g are monotone. Although an exact branch and bound algorithm has been provided for this problem [22], its complexity can be exponential in the worst case. On the other hand, in many applications, one of the submodular functions naturally serves as part of a constraint. For example, we might have a budget on a cooperative cost, in which case Problems 1 and 2 become applicable."}, {"heading": "1.1 Motivation", "text": "The utility of Problems 1 and 2 become apparent when we consider how they occur in real-world applications and how they subsume a number of important optimization problems. Sensor Placement and Feature Selection: Often, the problem of choosing sensor locations A from a given set of possible locations V can be modeled [27, 14] by maximizing the mutual information between the chosen variables A and the unchosen set V \\A (i.e.,f(A) = I(XA;XV \\A)). Note that, while the symmetric mutual information is not monotone, it can be shown to approximately monotone [27]. Alternatively, we may wish to maximize the mutual information between a set of chosen sensors XA and a quantity of interest C (i.e., f(A) = I(XA;C)) assuming that the set of features XA are conditionally independent given C [27, 14]. Both these functions are submodular. Since there are costs involved, we want to simultaneously minimize the cost g(A). Often this cost is submodular [27, 14]. For example, there is typically a discount when purchasing sensors in bulk (economies of scale). Moreover, there may be diminished cost for placing a sensor in a particular location given placement in certain other locations (e.g., the additional equipment needed to install a sensor in, say, a precarious environment could be re-used for multiple sensor installations in similar environments). Hence this becomes a form of Problem 2 above. An alternate view of this problem is to find a set of sensors with minimal cooperative cost, under a constraint that the sensors cover a certain fraction of the possible locations, naturally expressed as Problem 1. Data subset selection: A data subset selection problem in speech and NLP involves finding a limited vocabulary which simultaneously has a large coverage. This is particularly useful, for example in speech recognition and machine translation, where the complexity of the algorithm is determined by the vocabulary size. The motivation for this problem is to find the subset of training examples which will facilitate evaluation of prototype systems [33]. This problem then occurs in the form of Problem 1, where we want to find a small vocabulary subset (which is often submodular [33]), subject to a constraint that the subset acoustically spans the entire data set (which is also often submodular [30, 31]). This can also be phrased as Problem 2, where we ask for maximizing the acoustic coverage and diversity subject to a bounded vocabulary size constraint. Privacy Preserving Communication: Given a set of random variables X1, \u00b7 \u00b7 \u00b7 , Xn, denote I as an information source, and P as private information that should be filtered out. Then one way of formulating the problem of choosing a information containing but privacy preserving set of random variables can be posed as instances of Problems 1 and 2, with f(A) = H(XA|I) and g(A) = H(XA|P), where H(\u00b7|\u00b7) is the conditional entropy. An alternative strategy would be to formulate the problem with f(A) = H(XA) +H(XA|I) and g(A) = H(XA) +H(XA|P). Machine Translation: Another application in machine translation is to choose a subset of training data that is optimized for given test data set, a problem previously addressed with modular functions [35]. Defining\na submodular function with ground set over the union of training and test sample inputs V = Vtr \u222a Vte, we can set f : 2Vtr \u2192 R+ to f(X) = f(X|Vte), and take g(X) = |X|, and b \u2248 0 in Problem 2 to address this problem. We call this the Submodular Span problem. Probabilistic Inference: Many problems in computer vision and graphical model inference involve finding an assignment to a set of random variables. The most-probable explanation (MPE) problem finds the assignment that maximizes the probability. In computer vision and high-tree-width Markov random fields, this has been addressed using graph-cut algorithms [2], which are applicable when the MRF\u2019s energy function is submodular and limited degree, and more general submodular function minimization in the case of higher degree. Moreover, many useful non-submodular energy functions have also recently been phrased as forms of constrained submodular minimization [20] which still have bounded approximation guarantees. Some of these non-submodular energy functions can be modeled through Problems 1 and 2, where f is still the submodular energy function to be minimized while g represents a submodular constraint. For example, in image co-segmentation [40], V = V1 \u222a V2 can represent the set of pixels in two images, f is the submodular energy function of the two images, while g represents the similarity between the two histograms of the hypothesized foreground regions in the two images, a function shown to be submodular in [40]2. Apart from the real-world applications above, both Problems 1 and 2 generalize a number of well-studied discrete optimization problems. For example the Submodular Set Cover problem (henceforth SSC) [47] occurs as a special case of Problem 1, with f being modular and g is submodular. Similarly the Submodular Cost Knapsack problem (henceforth SK) [42] is a special case of problem 2 again when f is modular and g submodular. Both these problems subsume the Set Cover and Max k-Cover problems [6]. When both f and g are modular, Problems 1 and 2 are called knapsack problems [23].Furthermore, Problem 1 also subsumes the cardinality constrained submodular minimization problem [43] and more generally the problem of minimizing a submodular function subject to a knapsack constraints. It also subsumes the problem of minimizing a submodular function subject to a matroid span constraint (by setting g as the rank function of the matroid, and c as the rank of the matroid). This in turn subsumes the minimum submodular spanning tree problem [10], when f is monotone submodular."}, {"heading": "1.2 Our Contributions", "text": "The following are some of our contributions. We show that Problems 1 and 2 are intimately connected, in that any approximation algorithm for either problem can be used to provide guarantees for the other problem as well. We then provide a framework of combinatorial algorithms based on optimizing, sometimes iteratively, subproblems that are easy to solve. These subproblems are obtained by computing either upper or lower bound approximations of the cost functions or constraining functions. We also show that many combinatorial algorithms like the greedy algorithm for SK [42] and SSC [47] (both of which seemingly use different techniques) also belong to this framework and provide the first constant-factor bi-criterion approximation algorithm for SSC [47] and hence the general set cover problem [6]. We then show how with suitable choices of approximate functions, we can obtain a number of bounded approximation guarantees and show the hardness for Problems 1 and 2, which in fact match some of our approximation guarantees up to log-factors. Our guarantees and hardness results depend on the curvature of the submodular functions [3]. We observe a strong asymmetry in the results that the factors change polynomially based on the curvature of f but only by a constant-factor with the curvature of g, hence making the SK and SSC much easier compared to SCSK and SCSC. Finally we empirically evaluate the performance of our algorithms showing that the typical case behavior is much better than these worst case bounds.\n2 [40] showed that \u2212g is supermodular."}, {"heading": "2 Background and Main Ideas", "text": "We first introduce several key concepts used throughout the paper. Given a submodular function f , we define the total curvature, \u03baf , and the curvature of f with respect to a set X, \u03baf (X), as 3:\n\u03baf = 1\u2212min j\u2208V f(j|V \\j) f(j) , and \u03baf (X) = 1\u2212min{min j\u2208X f(j|X\\j) f(j) ,min j /\u2208X f(j|X) f(j) }. (2)\nThe total curvature \u03baf is then \u03baf (V ) [3, 45]. Intuitively, the curvature 0 \u2264 \u03baf \u2264 1 measures the distance of f from modularity and \u03baf = 0 if and only if f is modular (or additive, i.e., f(X) = \u2211 j\u2208X f(j)). Totally normalized [4] and saturated functions like matroid rank have a curvature \u03baf = 1. A number of approximation guarantees in the context of submodular optimization have been refined via the curvature of the submodular function [3, 18, 17]. For example, when maximizing a monotone submodular function under cardinality upper bound constraints, the bound of 1 \u2212 e\u22121 has been refined to 1\u2212e \u2212\u03baf\n\u03baf [3]. Similar bounds have also been\nshown in the context of constrained submodular minimization [18, 17, 16]. In this paper, we shall witness the role of curvature also in determining the approximations and the hardness of problems 1 and 2.\nAlgorithm 1 General algorithmic framework to address both Problems 1 and 2\n1: for t = 1, 2, \u00b7 \u00b7 \u00b7 , T do 2: Choose surrogate functions f\u0302t and g\u0302t for f and g respectively, tight at X\nt\u22121. 3: Obtain Xt as the optimizer of Problem 1 or 2 with f\u0302t and g\u0302t instead of f and g. 4: end for\nThe main idea of this paper is a framework of algorithms based on choosing appropriate surrogate functions for f and g to optimize over. This framework is represented in Algorithm 1. We would like to choose surrogate functions f\u0302t and g\u0302t such that using them, Problems 1 and 2 become easier. If the algorithm is just single stage (not iterative), we represent the surrogates as f\u0302 and g\u0302. The surrogate functions we consider in this paper are in the forms of bounds (upper or lower) and approximations. Our algorithms using upper and lower bounds are analogous to the majorization/ minimization algorithms proposed in [18, 16], where we provided a unified framework of fast algorithms for submodular optimization. We show there in that this framework subsumes a large class of known combinatorial algorithms and also providing a generic recipe for different forms of submodular function optimization. We extend these ideas to the more general context of problems 1 and 2, to obtain a fast family of algorithms. The other type of surrogate functions we consider are those obtained from other approximations of the functions. One such classical approximation is the ellipsoidal approximations [11]. While computing this approximation is time consuming, it turns out to provide the tightest theoretical guarantees. Modular lower bounds: Akin to convex functions, submodular functions have tight modular lower bounds. These bounds are related to the subdifferential \u2202f (Y ) of the submodular set function f at a set Y \u2286 V , which is defined [8] as:\n\u2202f (Y ) = {y \u2208 Rn : f(X)\u2212 y(X) \u2265 f(Y )\u2212 y(Y ) for all X \u2286 V } (3)\nFor a vector x \u2208 RV and X \u2286 V , we write x(X) = \u2211 j\u2208X x(j). Denote a subgradient at Y by hY \u2208 \u2202f (Y ). The extreme points of \u2202f (Y ) may be computed via a greedy algorithm: Let \u03c0 be a permutation of V that assigns the elements in Y to the first |Y | positions (\u03c0(i) \u2208 Y if and only if i \u2264 |Y |). Each such permutation defines a chain with elements S\u03c00 = \u2205, S\u03c0i = {\u03c0(1), \u03c0(2), . . . , \u03c0(i)} and S\u03c0|Y | = Y . This chain defines an\n3We can assume, w.l.o.g that f(j) > 0, g(j) > 0, \u2200j \u2208 V , since if for any j \u2208 V , f(j) = 0, it follows from submodularity and monotonicity that f(j|X) = 0,\u2200X \u2286 V . Hence we can effectively remove that element j from the ground set.\nextreme point h\u03c0Y of \u2202f (Y ) with entries\nh\u03c0Y (\u03c0(i)) = f(S \u03c0 i )\u2212 f(S\u03c0i\u22121). (4)\nDefined as above, h\u03c0Y forms a lower bound of f , tight at Y \u2014 i.e., h \u03c0 Y (X) = \u2211 j\u2208X h \u03c0 Y (j) \u2264 f(X),\u2200X \u2286 V and h\u03c0Y (Y ) = f(Y ). Modular upper bounds: We can also define superdifferentials \u2202f (Y ) of a submodular function [20, 15] at Y :\n\u2202f (Y ) = {y \u2208 Rn : f(X)\u2212 y(X) \u2264 f(Y )\u2212 y(Y ); for all X \u2286 V } (5)\nIt is possible, moreover, to provide specific supergradients [15, 18, 16] that define the following two modular upper bounds (when referring either one, we use mfX):\nmfX,1(Y ) , f(X)\u2212 \u2211\nj\u2208X\\Y\nf(j|X\\j) + \u2211\nj\u2208Y \\X\nf(j|\u2205),\nmfX,2(Y ) , f(X)\u2212 \u2211\nj\u2208X\\Y\nf(j|V \\j) + \u2211\nj\u2208Y \\X\nf(j|X).\nThen mfX,1(Y ) \u2265 f(Y ) and m f X,2(Y ) \u2265 f(Y ),\u2200Y \u2286 V and m f X,1(X) = m f X,2(X) = f(X). MM algorithms using upper/lower bounds: Using the modular upper and lower bounds above in Algorithm 1, provide a class of Majorization-Minimization (MM) algorithms, akin to the algorithms proposed in [18, 16] for submodular optimization and in [37, 14] for DS optimization (Problem 0 above). An appropriate choice of the bounds ensures that the algorithm always improves the objective values for Problems 1 and 2. In particular, choosing f\u0302t as a modular upper bound of f tight at X\nt, or g\u0302t as a modular lower bound of g tight at Xt, or both, ensures that the objective value of Problems 1 and 2 always improves at every iteration as long as the corresponding surrogate problem can be solved exactly. Unfortunately, Problems 1 and 2 are NP-hard even if f or g (or both) are modular [6], and therefore the surrogate problems themselves cannot be solved exactly. Fortunately, the surrogate problems are often much easier than the original ones and can admit log or constant-factor guarantees. In practice, moreover, these factors are almost 1. In order to guarantee improvement from a theoretical stand-point however, the iterative schemes can be slightly modified using the following trick. Notice that the only case when the true valuation of Xt is better than Xt+1 is when the surrogate valuation of Xt is better than Xt+1 (since Xt+1 is only near-optimal and not optimal). In such case, we terminate the algorithm at Xt. What is also fortunate and perhaps surprising, as we show in this paper below, is that unlike the case of DS optimization (where the problem is inapproximable in general [14]), the constrained forms of optimization (Problems 1 and 2) do have approximation guarantees. Ellipsoidal Approximation: We also consider ellipsoidal approximations (EA) of f . The main result of Goemans et. al [11] is to provide an algorithm based on approximating the submodular polyhedron by an ellipsoid. They show that for any polymatroid function f , one can compute an approximation of the form \u221a wf (X)\nfor a certain modular weight vector wf \u2208 RV , such that \u221a wf (X) \u2264 f(X) \u2264 O( \u221a n log n) \u221a wf (X),\u2200X \u2286 V . A simple trick then provides a curvature-dependent approximation [17] \u2014 we define the \u03baf -curve-normalized version of f as follows:\nf\u03ba(X) , f(X)\u2212 (1\u2212 \u03baf )\n\u2211 j\u2208X f(j)\n\u03baf . (6)\nThe function f\u03ba essentially contains the zero curvature component of the submodular function f and the modular upper bound \u2211 j\u2208X f(j) contains all the linearity. The main idea is to then approximate only the polymatroidal part and retain the linear component. This simple trick improves many of the approximation bounds. We then have the following lemma.\nLemma 2.1. [17] Given a polymatroid function f with a curvature \u03baf < 1, the submodular function fea(X) = \u03baf \u221a wf\u03ba(X) + (1\u2212 \u03baf ) \u2211 j\u2208X f(j) satisfies:\nfea(X) \u2264 f(X) \u2264 O ( \u221a n log n\n1 + ( \u221a n log n\u2212 1)(1\u2212 \u03baf )\n) fea(X),\u2200X \u2286 V (7)\nf ea is multiplicatively bounded by f by a factor depending on \u221a n and the curvature. The dependence on the curvature is evident from the fact that when \u03baf = 0, we get a bound of O(1), which is not surprising since a modular f is exactly represented as f(X) = \u2211 j\u2208X f(j). We shall use the result above in providing approximation bounds for Problems 1 and 2. In particular, the surrogate functions f\u0302 or g\u0302 in Algorithm 1 can be the ellipsoidal approximations above, and the multiplicative bounds transform into approximation guarantees for these problems."}, {"heading": "3 Relation between SCSC and SCSK", "text": "In this section, we show a precise relationship between Problems 1 and 2. From the formulation of Problems 1 and 2, it is clear that these problems are duals of each other. Indeed, in this section we show that the problems are polynomially transformable into each other.\nAlgorithm 2 Approx. algorithm for SCSK using an approximation algorithm for SCSC using Linear search.\nAlgorithm 3 Approx. algorithm for SCSC using an approximation algorithm for SCSK using Linear search.\nWe first introduce the notion of bicriteria algorithms. An algorithm is a [\u03c3, \u03c1] bi-criterion algorithm for Problem 1 if it is guaranteed to obtain a set X such that f(X) \u2264 \u03c3f(X\u2217) (approximate optimality) and g(X) \u2265 c\u2032 = \u03c1c (approximate feasibility), where X\u2217 is an optimizer of Problem 1. Similarly, an algorithm is a [\u03c1, \u03c3] bi-criterion algorithm for Problem 2 if it is guaranteed to obtain a set X such that g(X) \u2265 \u03c1g(X\u2217) and f(X) \u2264 b\u2032 = \u03c3b, where X\u2217 is the optimizer of Problem 2. In a bi-criterion algorithm for Problems 1 and 2, typically \u03c3 \u2265 1 and \u03c1 \u2264 1. We call these type of approximation algorithms, bi-criterion approximation algorithms of type 1. We can also view the bi-criterion approximations from another angle. We can say that for Problem 1, X\u0302 is a feasible solution (i.e., it satisfies the constraint), and is a [\u03c3, \u03c1] bi-criterion approximation, if f(X\u0302) \u2264 \u03c3f(X\u0302\u2217), where X\u0302\u2217 is the optimal solution to the problem min{f(X)|g(X) \u2265 c/\u03c1}. Similarly for Problem 2, we can say that X\u0302 is a feasible solution (i.e., it satisfies the constraint), and is a [\u03c1, \u03c3] bi-criterion approximation, if g(X\u0302) \u2265 \u03c1g(X\u0302\u2217), where X\u0302\u2217 is the optimal solution to the problem max{g(X)|f(X) \u2264 b\u03c3}. We call these the bi-criterion approximation algorithms of type 2. It is easy to see that these algorithms can easily be transformed into each other. For example, for problem 1, a bi-criterion algorithm of type-I can obtain a guarantee of type-II if we run it till a covering constraint of\nc\u2032/\u03c1 (where c\u2032 in this case, is the approximate covering constraint which the type-I algorithm needs to satisfy \u2013 note that it need not be the actual covering constraint of the problem). Similarly an algorithm of type-II can obtain a guarantee of type-I if run till a covering constraint of \u03c1c (in this case, c is the actual \u2019covering\u2019 constraint, since a type-II approximate algorithm provides a feasible set). We can similarly transform these guarantees for problem 2. In particular, a bi-criterion algorithm of type-I can be used to obtain a guarantee of type-II if we run it till a budget of b\u2032\u03c3 (again, here b\u2032 is the approximate budget of the type-I algorithm). Similarly an algorithm of type-II can obtain a guarantee of type-I if run till a covering constraint of b/\u03c3 (in this case, b is the budget of the original problem). Though both type-I and type-II guarantees are easily transformable into each other, through the rest of this paper whenever we refer to bi-criterion approximations, we shall consider only the type-I approximations. A non-bicriterion algorithm for Problem 1 is when \u03c1 = 1 and a non-bicriterion algorithm for Problem 2 is when \u03c3 = 1. Algorithms 2 and 3 provide the schematics for using an approximation algorithm for one of the problems for solving the other. The main idea of Algorithm 2 is to start with the ground set V and reduce the value of c (which governs SCSC), until the valuation of f just falls below \u03c3b. At that point, we are guaranteed to get a ((1\u2212 )\u03c1, \u03c3) solution for SCSK. Similarly in Algorithm 3, we increase the value of b starting at the empty set, until the valuation at g falls above \u03c1c. At this point we are guaranteed a ((1 + )\u03c3, \u03c1) solution for SCSC. In order to avoid degeneracies, we assume that f(V ) \u2265 b \u2265 minj f(j) and g(V ) \u2265 c \u2265 minj g(j), else the solution to the problem is trivial.\nTheorem 3.1. Algorithm 2 is guaranteed to find a set X\u0302c which is a [(1\u2212 )\u03c1, \u03c3] approximation of SCSK in at most log1/(1\u2212 )[g(V )/minj g(j)] calls to the [\u03c3, \u03c1] approximate algorithm for SCSC. Similarly, Algorithm 3 is guaranteed to find a set X\u0302b which is a [(1 + )\u03c3, \u03c1] approximation of SCSC in log1+ [f(V )/minj f(j)] calls to a [\u03c1, \u03c3] approximate algorithm for SCSK.\nProof. We start by proving the first part, for Algorithm 2. Notice that Algorithm 2 converges when f(X\u0302c) just falls below \u03c3b. Hence f(X\u0302c) \u2264 \u03c3b (is approximately feasible) and at the previous step c\u2032 = c/(1\u2212 ), we have that f(X\u0302c\u2032) > \u03c3b. Denoting X \u2217 c\u2032 as the optimal solution for SCSC at c \u2032, we have that f(X\u2217c\u2032) > b (a fact which follows from the observation that X\u0302c is a [\u03c3, \u03c1] approximation of SCSC at c). Hence if X \u2217 is the optimal solution of SCSK, it follows that g(X\u2217) < c\u2032. The reason for this is that, suppose, g(X\u2217) \u2265 c\u2032. Then it follows that X\u2217 is a feasible solution for SCSC at c\u2032 and hence f(X\u2217) \u2265 f(X\u2217c\u2032) > b. This contradicts the fact that X\u2217 is an optimal solution for SCSK (since it is then not even feasible). Next, notice that X\u0302c satisfies that g(X\u0302c) \u2265 \u03c1c, using the fact that X\u0302c is obtained from a (\u03c3, \u03c1) bi-criterion algorithm for SCSC. Hence,\ng(X\u0302c) \u2265 \u03c1c = \u03c1(1\u2212 )c\u2032 > \u03c1(1\u2212 )g(X\u2217) (8)\nHence the Algorithm 2 is a ((1\u2212 )\u03c1, \u03c3) approximation for SCSK. In order to show the converge rate, notice that c \u2265 minj g(j) > 0. Since \u03c3 \u2265 1 and b \u2265 minj f(j), we can guarantee that this algorithm will stop before c reaches minj g(j). The reason is that, when c = minj g(j), the minimum value of f(X) such that g(X) \u2265 c is minj f(j), which is smaller than b. Moreover, since \u03c3 > 1, it implies that the algorithm would have terminated before this point. The proof for the second part of the statement, for Algorithm 3, is omitted since it is shown using a symmetric argument.\nAlgorithm 4 Approx. algorithm for SCSK using an approximation algorithm for SCSC using Binary search.\nAlgorithm 5 Approx. algorithm for SCSC using an approximation algorithm for SCSK using Binary search.\nTheorem 3.1 implies that the complexity of Problems 1 and 2 are identical, and a solution to one of them provides a solution to the other. Furthermore, as expected, the hardness of Problems 1 and 2 are also almost identical. When f and g are polymatroid functions, moreover, we can provide bounded approximation guarantees for both problems, as shown in the next section. Alternatively we can also do a binary search instead of a linear search to transform Problems 1 and 2. This essentially turns the factor of O(1/ ) into O(log 1/ ). Algorithms 4 and 5 show the transformation algorithms using binary search. While the binary search also ensures the same performance guarantees, it does so more efficiently.\nTheorem 3.2. Algorithm 4 is guaranteed to find a set X\u0302c which is a [(1\u2212 )\u03c1, \u03c3] approximation of SCSK in at most log2 [g(V )/minj g(j)] calls to the [\u03c3, \u03c1] approximate algorithm for SCSC. Similarly, Algorithm 5 is guaranteed to find a set X\u0302b which is a [(1 + )\u03c3, \u03c1] approximation of SCSC in log2 [f(V )/minj f(j)]\ncalls to a [\u03c1, \u03c3] approximate algorithm for SCSK. When f and g are integral, moreover, Algorithm 4 obtains a [\u03c1, \u03c3] bi-criterion approximate solution for SCSK in log2 g(V ) iterations, and similarly Algorithm 5 obtains a [\u03c3, \u03c1] bi-criterion approximate solution for SCSC in log2 g(V ) iterations. Proof. To show this theorem, we use the result from Theorem 3.1. Let c = cmin and c \u2032 = cmax. An important observation is that throughout the algorithm, the values of cmin satisfy f(X\u0302cmin) \u2264 \u03c3b and f(X\u0302cmax) > \u03c3b. Hence, f(X\u0302c) \u2264 \u03c3b and f(X\u0302c\u2032) > \u03c3b. Moreover, notice that c\u2032/c = cmax/cmin = 1/(1\u2212 ). Hence using the proof of Theorem 3.1 the approximation guarantee follows. In order to show the complexity, notice that cmax \u2212 cmin is decreasing throughout the algorithm. At the beginning, cmax \u2212 cmin \u2264 g(V ) and at convergence, cmax \u2212 cmin \u2265 cmax/2 \u2265 minj g(j)/2. The bound at convergence holds since, let c\u2032max and c \u2032 min be the values at the previous step. It holds that c \u2032 max\u2212c\u2032min \u2265 c\u2032max. Moreover, cmax \u2212 cmin = (c\u2032max \u2212 c\u2032min)/2 \u2265 c\u2032max/2 \u2265 cmax. Hence the number of iterations is bounded by log2 [2g(V )/minj g(j)] . Moreover, when f and g are integral, the analysis is much simpler. In particular, notice that once cmax \u2212 cmin = 1, the algorithm will stop at the next iteration (this is because at this point, c = (cmax + cmin)/2 is equivalent to c = cmax). Hence, the number of iterations is bounded by log2 g(V ), and we can exactly obtain a [\u03c1, \u03c3] bi-criterion approximation algorithm. The proof for the second part of the statement, for Algorithm 3, similarly follows using a symmetric argument.\nWhen f and g are integral, this removes the dependence on the factors and could potentially be much faster in practice. We also remark that a specific instance of such a transformation has been used [26], for a specific class of functions f and g. We shall show in section 4.3 that their algorithm is in fact a special case of Algorithm 4 through a specific construction to convert the non-submodular problem into an instance of a submodular one. Algorithm 2 and Algorithm 3 indeed provide an interesting theoretical result connecting the complexity of Problems 1 and 2. In the next section however, we provide distinct algorithms for each problem when f and g are polymatroid functions \u2014 this turns out to be faster than having to resort to the iterative reductions above."}, {"heading": "4 Approximation Algorithms", "text": "We consider several algorithms for Problems 1 and 2, which can all be characterized by the framework of Algorithm 1, using the surrogate functions of the form of upper/lower bounds or approximations."}, {"heading": "4.1 Approximation Algorithms for SCSC", "text": "We first describe our approximation algorithms designed specifically for SCSC, leaving to \u00a74.2 the presentation of our algorithms slated for SCSK. We first investigate a special case, the submodular set cover (SSC), and then provide two algorithms, one of them (ISSC) is very practical with a weaker theoretical guarantee, and another one (EASSC) which is slow but has the tightest guarantee. Submodular Set Cover (SSC): We start by considering a classical special case of SCSC (Problem 1) where f is already a modular function and g is a submodular function. This problem occurs naturally in a number of problems related to active/online learning [12] and summarization [31, 32]. This problem was first investigated by Wolsey [47], wherein he showed that a simple greedy algorithm achieves bounded (in fact, log-factor) approximation guarantees. We show that this greedy algorithm can naturally be viewed in the\nframework of our Algorithm 1 by choosing appropriate surrogate functions f\u0302t and g\u0302t. The idea is to use the modular function f as its own surrogate f\u0302t and choose the function g\u0302t as a modular lower bound of g. Akin to the framework of algorithms in [18], the crucial factor is the choice of the lower bound (or subgradient). Define the greedy subgradient (equivalently the greedy permutation) as:\n\u03c0(i) \u2208 argmin { f(j)\ng(j|S\u03c0i\u22121) \u2223\u2223\u2223\u2223 j /\u2208 S\u03c0i\u22121, g(S\u03c0i\u22121 \u222a j) < c} . (9) Once we reach an i where the constraint g(S\u03c0i\u22121 \u222a j) < c can no longer be satisfied by any j /\u2208 S\u03c0i\u22121, we choose the remaining elements for \u03c0 arbitrarily. Let the corresponding subgradient be referred to as h\u03c0. Let N be the minimum i such that g(S\u03c0i ) \u2265 c and \u03b8i = minj /\u2208S\u03c0i\u22121 f(j) g(j|S\u03c0i\u22121) . Then we have the following lemma, which is an extension of [47]:\nLemma 4.1. Choosing the surrogate function f\u0302 as f and g\u0302 as h\u03c0 (with \u03c0 defined in Eqn. (9)) in Algorithm 1, at the end of the first iteration, we are guaranteed to obtain a set Xg such that\nf(Xg) f(X\u2217) \u2264 1 + loge min{\u03bb1, \u03bb2, \u03bb3} (10)\nwhere \u03bb1 = max{ 11\u2212\u03bag(S\u03c0i ) | i : c(S \u03c0 i ) < 1}, \u03bb2 = \u03b8N\u03b81 and \u03bb3 = g(V )\u2212g(\u2205) g(V )\u2212g(S\u03c0N\u22121) . Furthermore if g is integral, f(Xg) f(X\u2217) \u2264 H(maxj g(j)), where H(d) = \u2211d i=1 1 i for a positive integer d.\nProof. The permutation \u03c0 is chosen based on a greedy ordering associated with the submodular set cover problem, and therefore h\u03c0(S\u03c0N ) = g(S \u03c0 N ) \u2265 c (where the inequality follows from the definition of N), and thus S\u03c0N is a feasible solution in the surrogate problem (where g is replaced by h \u03c0). The resulting knapsack problem can be addressed using the greedy algorithm [23], but this exactly corresponds to the greedy algorithm of submodular set cover [47] and hence the guarantee follows from Theorem 1 in [47].\nThe surrogate problem in this instance is a simple knapsack problem that can be solved nearly optimally using dynamic programming [44]. As stated in the proof, the greedy algorithm for the submodular set cover problem [47] is in fact equivalent to using the greedy algorithm for the knapsack problem [23], which is in fact suboptimal. When g is integral, the guarantee of the greedy algorithm is Hg , H(maxj g(j)), where H(d) = \u2211d i=1 1 i [47] (henceforth we will use Hg for this quantity). This factor is tight up to lower-order terms [6]. Furthermore, since this algorithm directly solves SSC, we call it the primal greedy. We could also solve SSC by looking at its dual, which is SK [42]. Although SSC does not admit any constant-factor approximation algorithms [6], we can obtain a constant-factor bi-criterion guarantee:\nLemma 4.2. Using the greedy algorithm for SK [42] as the approximation oracle in Algorithm 3 provides a [1 + , 1\u2212 e\u22121] bi-criterion approximation algorithm for SSC, for any > 0.\nProof. We call this the dual greedy. This result follows immediately from the guarantee of the submodular cost knapsack problem [42] and Theorem 3.1.\nWe remark that we can also use a simpler version of the greedy iteration at every iteration [31, 24] and we obtain a guarantee of (1 + , 1/2(1\u2212 e\u22121)). In practice, however, both these factors are almost 1 and hence the simple variant of the greedy algorithm suffices. An interesting connection between the greedy algorithm and the induced orderings, allows us to further simplify this dual algorithm. A nice property of the greedy algorithm for the submodular knapsack problem is that it can be completely parameterized by the chain of sets (this holds for the greedy algorithm of [31, 24] for knapsack constraints and the basic greedy algorithm of [38] under cardinality constraints). In particular, having computed the greedy chain of sets, and given a value of b or the budget, we can easily find the corresponding set in O(log n) time using binary search. Moreover, this also implies that we can do the transformation algorithms by just iterating through the chain of sets once. In particular, the linear search over the different values of is equivalent to the linear search over the different chain of sets. Moreover, we could also do the much faster binary search. Hence the complexity of the dual greedy algorithm is almost identical to the primal greedy one for the submodular set cover problem. It is also important to put the bicriterion result into perspective. Notice that the bicriterion guarantee suggests that we find only an approximate feasible solution. In particular, the dual greedy algorithm provides a type-I bi-criterion approximation, \u2013 that the solution obtained by running the algorithm with a cover constraint of (1\u2212 1/e)c is competitive to the optimal solution with a cover constraint of c. However, we can also obtain a type-II bi-criterion approximation by running the dual greedy algorithm until it satisfies the cover constraint of c. In this case, we would obtain a feasible solution. The guarantee, however, would say that the resulting solution would be competitive to the optimal solution obtained with a cover constraint of c/(1\u2212 e\u22121). Furthermore, these factors are in practice close to 1, and the primal and dual greedy algorithms would both perform very well empirically. Iterated Submodular Set Cover (ISSC): We next investigate an algorithm for the general SCSC problem when both f and g are submodular. The idea here is to iteratively solve the submodular set cover problem which can be done by replacing f by a modular upper bound at every iteration. In particular, this can be seen as a variant of Algorithm 1, where we start with X0 = \u2205 and choose f\u0302t(X) = mfXt,2(X) at every iteration (alternatively, we can choose f\u0302t(X) = m f Xt,1(X)). At the first iteration with X\n0 = \u2205, either variant then corresponds to the set cover problem with the simple modular upper bound f(X) \u2264 mf\u2205(X) = \u2211 j\u2208X f(j)\nwhere mfXt refers to either variant. The surrogate problem at each iteration becomes:\nminimize mfXt(X)\nsubject to g(X) \u2265 c.\nHence, each iteration is an instance of SSC and can be solved nearly optimally using the greedy algorithm. We can continue this algorithm for T iterations or until convergence. An analysis very similar to the ones in [14, 18] will reveal polynomial time convergence. Since each iteration is only the greedy algorithm, this approach is also highly practical and scalable. Since there are two approaches to solve the set cover problem (the primal approach of Lemma 4.1 and the dual greedy approach of Lemma 4.2), we have two forms of ISSC, the primal ISSC and the dual ISSC. The following shows the resulting theoretical guarantees:\nTheorem 4.3. The primal ISSC algorithm obtains an approximation factor of KgHg 1+(Kg\u22121)(1\u2212\u03baf ) \u2264 n\n1+(n\u22121)(1\u2212\u03baf )Hg where Kg = 1 + max{|X| : g(X) < c} and Hg is the approximation factor of the submodular set cover using g. Similarly the dual ISSC obtains a bi-criterion guarantee of [ (1+ )Kg 1+(Kg\u22121)(1\u2212\u03baf ) , 1\u2212 e \u22121 ] .\nProof. The first part of the result follows directly from Theorem 5.4 in [18]. In particular, the result from [18] ensures a guarantee of\n\u03b2|X\u2217| 1 + (|X\u2217| \u2212 1)(1\u2212 \u03baf )\n(11)\nfor the problem of min{f(X)|X \u2208 C} where \u03b2 is the approximation guarantee of solving a modular function over C where C is the feasible set. In this case, \u03b2 = Hg and |X\u2217| \u2264 Kg. When using the dual greedy approach at every iteration, we can use a similar form of the result in the bi-criterion sense. Consider only the first iteration of this algorithm (due to the monotonicity of the algorithm, we will only improve the objective value). We are then guaranteed to obtain a set X\u0302 such that (denote X1 as the solution after the first iteration)\nf(X\u0302) \u2264 f(X1) \u2264 mf\u2205(X 1) \u2264 (1 + )mf\u2205(X \u2217) \u2264 Kg(1 + ) 1 + (Kg \u2212 1)(1\u2212 \u03baf ) f(X\u2217) (12)\nThe inequalities above follow from the fact that the modular upper bound mf\u2205(X) satisfies [17],\nmf\u2205(X) \u2264 f(X) \u2264 |X|\n1 + (|X| \u2212 1)(1\u2212 \u03baf ) f(X) (13)\nand the fact that X1 which is the solution obtained through the dual set cover with a cover constraint (1 \u2212 e\u22121)c satisfies mf\u2205(X 1) \u2264 (1 + )mf\u2205(X \u2217). In the above, X\u2217 is the optimal solution to the problem min{f(X)|g(X) \u2265 c}. We could also run the dual set cover algorithm to obtain a feasible solution (i.e., a type-II guarantee). In this case, the guarantee would compete with the optimal solution satisfying a cover constraint of c/(1\u2212 e\u22121).\nFrom the above, it is clear that Kg \u2264 n. Notice also that Hg is essentially a log-factor. We also see an interesting effect of the curvature \u03baf of f . When f is modular (\u03baf = 0), we recover the approximation guarantee of the submodular set cover problem. Similarly, when f has restricted curvature, the guarantees can be much better. For example, using square-root over modular function f(X) = \u2211k i=1 \u221a wi(X), which is\ncommon model used in applications [14, 29, 19], the worst case guarantee is Hg \u221a Kg. This follows directly from the results in [17]. Moreover, the approximation guarantee already holds after the first iteration, so additional iterations can only further improve the objective.\nWe remark here that a special case of ISSC, using only the first iteration (i.e., the simple modular upper bound of f) was considered in [46, 5]. Our algorithm not only possibly improves upon theirs, but our approximation guarantee is also more explicit than theirs. In particular, they show a guarantee of \u03bdfHg,\nwhere \u03bdf = min{ \u2211 i\u2208X f(i)\nf(X) |g(X) = g(V )}. Since this factor \u03bdf itself involves an optimization problem, it is not clear how to efficiently compute this factor. Moreover given a submodular function f , it is also not evident how good this factor is. While our guarantee is an upper bound of \u03bdfHg, it is much more explicit in its dependence on the parameters of the problem. It can also be computed efficiently and has an intuitive significance related to the curvature of the function. Furthermore, our bound is also tight since with, for example, f(X) = min{|X|, 1}, our exactly matches the bound of [46, 5]. Lastly our algorithm also potentially improves upon theirs thanks to its iterative nature. For another variant of this algorithm, we can replace g with its greedy modular lower bound at every iteration. Then, rather than solving every iteration through the greedy algorithm, we can solve every iteration as a knapsack problem (minimizing a modular function over a modular lower bound constraint) [23], using say, a dynamic programming based approach. This could potentially improve over the greedy variant, but at a potentially higher computational cost. Ellipsoidal Approximation based Submodular Set Cover (EASSC): In this setting, we use the ellipsoidal approximation discussed in \u00a72. We can compute the \u03baf -curve-normalized version of f (f\u03ba, see \u00a72), and then compute its ellipsoidal approximation \u221a wf\u03ba . We then define the function f\u0302(X) = f ea(X) =\n\u03baf \u221a wf\u03ba(X) + (1\u2212 \u03baf ) \u2211 j\u2208X f(j) and use this as the surrogate function f\u0302 for f . We choose g\u0302 as g itself. The surrogate problem becomes:\nmin \u03baf \u221a wf\u03ba(X) + (1\u2212 \u03baf ) \u2211 j\u2208X f(j) \u2223\u2223\u2223\u2223 g(X) \u2265 c  . (14)\nWhile function f\u0302(X) = f ea(X) is not modular, it is a weighted sum of a concave over modular function and a modular function. Fortunately, we can use the result from [39], where they show that any function of the form of \u221a w1(X) +w2(X) can be optimized over any polytope P with an approximation factor of \u03b2(1 + ) for any > 0, where \u03b2 is the approximation factor of optimizing a modular function over P. The complexity of this algorithm is polynomial in n and 1 . The main idea of their paper is to reduce the problem of minimizing\u221a w1(X) + w2(X), into log n problems of minimizing a modular function over the polytope. We use their algorithm to minimize f ea(X) over the submodular set cover constraint and hence we call this algorithm EASSC. Again we have the two variants, primal EASSC and dual EASSC, which essentially use at every iteration the primal and dual forms of set cover. Theorem 4.4. The primal EASSC obtains a guarantee of O( \u221a n lognHg\n1+( \u221a n logn\u22121)(1\u2212\u03baf ) ), where Hg is the approxi-\nmation guarantee of the set cover problem. Moreover, the dual EASSC obtains a bi-criterion approximation of [ O( \u221a n logn\n1+( \u221a n logn\u22121)(1\u2212\u03baf )\n), 1\u2212 e\u22121 ] .\nProof. The idea of the proof is to use the result from [39] where they show that any function of the form \u03bb1 \u221a m1(X) + \u03bb2m2(X) where \u03bb1 \u2265 0, \u03bb2 \u2265 0 and m1 and m2 are positive modular functions has a FPTAS, provided a modular function can easily be optimized over C. Note that our function is exactly of that form. Hence, f\u0302(X) can be approximately optimized over C. It now remains to show that this translates into the approximation guarantee. From Lemma 2.1, we know that there exists a f\u0302 such that f\u0302(X) \u2264 f(X) \u2264 \u03b2(n)f\u0302(X),\u2200X where\n\u03b2(n) = O\n( \u221a n log n\n( \u221a n log n\u2212 1)(1\u2212 \u03baf ) + 1)\n) . (15)\nThen, if X\u0302 is the 1 + approximately optimal solution for minimizing f\u0302 over {X : g(X) \u2265 c}, we have that:\nf(X\u0302) \u2264 \u03b2(n)f\u0302(X\u0302) \u2264 Hg\u03b2(n)(1 + )f\u0302(X\u2217) \u2264 Hg\u03b2(n)(1 + )f(X\u2217), (16)\nwhere X\u2217 is the optimal solution. We can set to any constant, say 1, and we get the result. The dual guarantee again follows in a very similar manner thanks to the guarantee for the dual SSC.\nIf the function f has \u03baf = 1, we can use a much simpler algorithm. In particular, since the ellipsoidal approximation is of the form of f ea(X) = \u221a wf (X), we can minimize (f ea(X))2 = wf (X) at every iteration, giving a surrogate problem of the form\nmin{wf (X)|g(X) \u2265 c}. (17)\nThis is directly an instance of SSC, and in contrast to EASSC, we just need to solve SSC once. We call this algorithm EASSCc. This guarantee is tight up to log factors when \u03baf = 1. Corollary 4.5. The primal EASSCc obtains an approximation guarantee of O( \u221a n log n \u221a Hg). Similarly, the dual EASSCc obtains a bicriterion guarantee of [O( \u221a n log n), 1\u2212 e\u22121].\nProof. Let X\u0302 be a set such that,\nw(X\u0302) \u2265 Hg min{w(X)|g(X) \u2265 c} (18)\nThen denote \u03b1(n) = O( \u221a n log n).\nf(X\u0302) \u2264 \u03b1(n) \u221a w(X\u0302) \u2264 \u221a Hg\u03b1(n) \u221a w(X\u2217) \u2264 \u221a Hg\u03b1(n)f(X \u2217) (19)\nIn the above, X\u2217 = argmin{f(X)|g(X) \u2265 c}. The result for the dual variant can also be similarly shown."}, {"heading": "4.2 Approximation Algorithms for SCSK", "text": "In this section, we describe our approximation algorithms for SCSK. We note the dual nature of the algorithms in this current section to those given in \u00a74.1. We first investigate a special case, the submodular knapsack (SK), and then provide three algorithms, two of them (Gr and ISK) being practical with slightly weaker theoretical guarantee, and another one (EASK) which is not scalable but has the tightest guarantee. Submodular Cost Knapsack (SK): We start with a special case of SCSK (Problem 2), where f is a modular function and g is a submodular function. In this case, SCSK turns into the SK problem for which the greedy algorithm with partial enumeration provides a 1\u2212 e\u22121 approximation [42]. The greedy algorithm can be seen as an instance of Algorithm 1 with g\u0302 being the modular lower bound of g and f\u0302 being f , which is already modular. In particular, we then get back the framework of [18], where the authors show that choosing a permutation based on a greedy ordering, exactly analogous to Eqn. (9), provides the bounds. In particular, define:\n\u03c0(i) \u2208 argmax { g(j|S\u03c0i\u22121) f(j) \u2223\u2223\u2223\u2223 j /\u2208 S\u03c0i\u22121, f(S\u03c0i\u22121 \u222a {j}) \u2264 b} , (20) where the remaining elements are chosen arbitrarily. A slight catch however is that for the analysis to work, [42] needs to consider ( n 3 ) instances of such orderings (partial enumeration), chosen by fixing the first three elements in the permutation [18]. We can however just choose the simple greedy ordering in one stage, to get a slightly worse approximation factor of 1\u2212 e\u22121/2 [18, 31, 24].\nLemma 4.6. [18] Choosing the surrogate function f\u0302 as f and g\u0302 as h\u03c0 in Algorithm 1 yields a set Xg:\nmax{ max i:f(i)\u2264b\ng(i), g(Xg)} \u2265 1/2(1\u2212 1/e)g(X\u2217). (21)\nLet \u03c0ijk be a permutation with i, j, k in the first three positions, and the remaining arrangement greedy. Running O(n3) restarts of one iteration of Algorithm 1 yields sets Xijk with\nmax i,j,k\u2208V\nf(Xijk) \u2265 (1\u2212 1/e)f(X\u2217). (22)\nGreedy (Gr): A similar greedy algorithm can provide approximation guarantees for the general SCSK problem, with submodular f and g. Unlike the knapsack case in (20), however, at iteration i we choose an element j /\u2208 Si\u22121 : f(S\u03c0i\u22121 \u222a {j}) \u2264 b which maximizes g(j|Si\u22121). In terms of Algorithm 1, this is analogous to choosing a permutation, \u03c0 such that:\n\u03c0(i) \u2208 argmax{g(j|S\u03c0i\u22121)|j /\u2208 S\u03c0i\u22121, f(S\u03c0i\u22121 \u222a {j}) \u2264 b}. (23)\nTheorem 4.7. The greedy algorithm for SCSK obtains an approx. factor of 1\u03bag (1\u2212 ( Kf\u2212\u03bag Kf )kf ) \u2265 1Kf , where Kf = max{|X| : f(X) \u2264 b} and kf = min{|X| : f(X) \u2264 b & \u2200j \u2208 X, f(X \u222a j) > b}.\nProof. The proof of this result follows directly from [3, 18]. In particular, it holds for any down monotone constraint. It is easy to see that the constraint {f(X) \u2264 b} is down-monotone when f is a monotone submodular function.\nIn the worst case, kf = 1 and Kf = n, in which case the guarantee is 1/n. The bound above follows from a simple observation that the constraint {f(X) \u2264 b} is down-monotone for a monotone function f . However, in this variant, we do not use any specific information about f . In particular it holds for maximizing a submodular function g over any down monotone constraint [3]. Hence it is conceivable that an algorithm that uses both f and g to choose the next element could provide better bounds. We do not, however, currently have the analysis for this. Iterated Submodular Cost Knapsack (ISK): Here, we choose f\u0302t(X) as a modular upper bound of f , tight at Xt. Let g\u0302t = g. Then at every iteration, we solve:\nmax{g(X)|mfXt(X) \u2264 b}, (24)\nwhich is a submodular maximization problem subject to a knapsack constraint (SK). As mentioned above, greedy can solve this nearly optimally. We start with X0 = \u2205, choose f\u03020(X) = \u2211 j\u2208X f(j) and then iteratively continue this process until convergence (note that this is an ascent algorithm). We have the following theoretical guarantee:\nTheorem 4.8. Algorithm ISK obtains a set Xt such that g(Xt) \u2265 (1\u2212 e\u22121)g(X\u0303), where X\u0303 is the optimal solution of max { g(X) | f(X) \u2264 b(1+(Kf\u22121)(1\u2212\u03baf )Kf } and where Kf = max{|X| : f(X) \u2264 b}.\nProof. We are given that X\u0303 is the optimal solution to the problem:\nmax { g(X) | f(X) \u2264 b(1 + (Kf \u2212 1)(1\u2212 \u03baf )\nKf\n} (25)\nX\u0303 is also a feasible solution to the problem:\nmax g(X) | \u2211 j\u2208X f(j) \u2264 b  (26) The reason for this is that:\u2211\nj\u2208X f(j) \u2264 Kf 1 + (Kf \u2212 1)(1\u2212 \u03baf ) f(X) \u2264 Kf 1 + (Kf \u2212 1)(1\u2212 \u03baf ) b(1 + (Kf \u2212 1)(1\u2212 \u03baf )) Kf \u2264 b\nNow, at the first iteration we are guaranteed to find a set X1 such that g(X1) \u2265 (1\u2212 1/e)g(X\u0303). The further iterations will only improve the objective since this is a ascent algorithm.\nIt is worth pointing out that the above bound holds even after the first iteration of the algorithm. It is interesting to note the similarity between this approach and the iterated submodular set cover ISSC. Notice that the bound above is a form of a bicriterion approximation factor of type-II. In particular, we obtain a feasible solution at the end of the algorithm. We can obtain a type-I bicriterion approximation bound, by running this for a larger budget constraint. In particular, we run the above algorithm with a budget constraint of\nbKf 1+(Kf\u22121)(1\u2212\u03baf ) instead of b. The following guarantee then follows.\nLemma 4.9. The ISK algorithm of type-I is guaranteed to obtain a set X which has a bicriterion approximation factor of [1\u2212 e\u22121, Kf1+(Kf\u22121)(1\u2212\u03baf ) ], where Kf = max{|X| : f(X) \u2264 b}.\nProof. This result directly follows from the Lemma above, and the transformation from a type-II approximation algorithm to a type-I one.\nEllipsoidal Approximation based Submodular Cost Knapsack (EASK): Choosing the Ellipsoidal Approximation fea of f as a surrogate function, we obtain a simpler problem:\nmax g(X) \u2223\u2223\u2223\u2223 \u03baf\u221awf\u03ba(X) + (1\u2212 \u03baf )\u2211\nj\u2208X f(j) \u2264 b  . (27) In order to solve this problem, we look at its dual problem (i.e., Eqn. (14)) and use Algorithm 2 to convert the guarantees. Recall that Eqn. (14) itself admits two variants of the ellipsoidal approximation, which we had referred to as the primal EASSC and the dual EASSC. Hence, we call the combined algorithms, primal and dual EASK, which admit the following guarantees:\nLemma 4.10. The primal EASK obtains a guarantee of [ 1 + , O(\n\u221a n lognHg\n1+( \u221a n logn\u22121)(1\u2212\u03baf )\n) ] . Similarly, the dual\nEASK obtains a guarantee of [ (1 + )(1\u2212 1/e), O(\n\u221a n logn\n1+( \u221a n logn\u22121)(1\u2212\u03baf )\n) ] .\nProof. This Lemma directly follows from Theorem 3.1 and Theorem 4.4.\nThese factors are akin to those of Theorem 4.4, except for the additional factor of 1 + . Unlike the greedy algorithm, ISSC and ISK, note that both EASK and EASSC are enormously costly and complicated algorithms. Hence, it also seems at first thought that EASK would need to run multiple versions of EASSC at each conversion round of Algorithm 2. Fortunately, however, we need to compute the Ellipsoidal Approximation just once and the algorithm can reuse it for different values of c. Furthermore, since construction of the approximation is often the bottleneck, this scheme is likely to be as costly as EASSC in practice. In the case when the submodular function has a curvature \u03baf = 1, we can actually provide a simpler algorithm without needing to use the conversion algorithm (Algorithm 2). In this case, we can directly choose the ellipsoidal approximation of f as \u221a wf (X) and solve the surrogate problem:\nmax{g(X) : wf (X) \u2264 b2}. (28)\nThis surrogate problem is a submodular cost knapsack problem, which we can solve using the greedy algorithm. We call this algorithm EASKc. This guarantee is tight up to log factors if \u03baf = 1. Corollary 4.11. Algorithm EASKc obtains a bi-criterion guarantee of [1\u2212 e\u22121, O( \u221a n log n)].\nProof. Let X\u0302 be the approximate optimizer of Eqn. (28). First we show that g(X\u0302) \u2265 (1 \u2212 1/e)g(X\u2217) where X\u2217 is the optimizer of problem 2. Notice that f(X\u2217) \u2264 b since it feasible in problem 2. Also,\u221a wf (X\u2217) \u2264 f(X\u2217) \u2264 b and hence X\u2217 is feasible in Eqn. (28). Hence it holds that g(X\u0302) \u2265 (1\u2212 1/e)g(X\u2217). We now show that f(X\u0302) \u2264 b \u221a n log n. Notice that,\nf(X\u0302) \u2264 \u221a n log n \u221a wf (X\u0302) \u2264 b \u221a n log n (29)"}, {"heading": "4.3 Extensions beyond SCSC and SCSK", "text": "SCSC is in fact more general and can be extended to more flexible and complicated constraints which can arise naturally in many applications [26, 13]. Notice first that\n{g(X) \u2265 \u03b1} \u21d4 {g\u2032(X) = g\u2032(V )} (30)\nwhere g\u2032(X) = min{g(X), \u03b1}. We can also have \u201cand\u201d constraints as g1(X) = g1(V ) and g2(X) = g2(V ). These have a simple equivalence:\n{g1(X) = g1(V ) \u2227 g2(X) = g2(V )} \u21d4 {g(X) = g(V )} (31)\nwhen g(X) = g1(X) + g2(X) [26]. Moreover, we can also handle k \u2018and\u2019 constraints, by defining g(X) =\u2211k i=1 gi(X). Similarly we can have \u201cor\u201d constraints, i.e., g1(X) = g1(V ) or g2(X) = g2(V ). These also have a nice equivalence:\n{g1(X) = g1(V ) \u2228 g2(X) = g2(V )} \u21d4 {g(X) = g(V )} (32)\nby defining g(X) = g1(X)g2(V ) + g2(X)g1(V )\u2212 g1(X)g2(X) [13]. We can also extend these recursively to multiple \u2018or\u2019 constraints. Hence our algorithms can directly solve all these variants of SCSC. SCSK can also be extended to handle more complicated forms of functions g. In particular, consider the function\ng(X) = min{g1(X), g2(X), . . . , gk(X)} (33)\nwhere the functions g1, g2, . . . , gk are submodular. Although g(X) in this case is not submodular, this scenario occurs naturally in many applications, particularly sensor placement [26]. The problem in [26] is in fact a special case of Problem 2, using a modular function f . Often, however, the budget functions involve a cooperative cost, in which case f is submodular. Using Algorithm 2, however, we can easily solve this by iteratively solving the dual problem. Notice that the dual problem is in the form of Problem 1 with a non-submodular constraint g(X) \u2265 c. It is easy to see that this is equivalent to the constraint gi(X) \u2265 c, \u2200i = 1, 2, . . . , k, which can be solved thanks to the techniques above. We can also handle multiple constraints in SCSK. In particular, consider multiple \u2018and\u2019 constraints \u2013 {fi(X) \u2264 bi, i = 1, 2, \u00b7 \u00b7 \u00b7 , k}, for monotone submodular functions fi and g. A first observation is that the greedy algorithm can almost directly extended to these cases, since we do not use any specific property of the constraints, while providing the approximation guarantees. Hence Theorem 4.7 can directly be extended to this case. We can also provide bi-criterion approximation guarantees with \u2018and\u2019 constraints. The approximate feasibility for a [\u03c1, \u03c3] bi-criterion approximation in this setting would be to have a set X such that fi(X) \u2264 \u03c3bi. Algorithm ISK can easily then be used in this scenario, and at every iteration we would solve a monotone submodular maximization problem subject to multiple linear (or knapsack constraints). Surprisingly this problem also has a constant factor (1 \u2212 1/e) approximation guarantee [28]. Hence we can retain the same approximation guarantees as in Theorem 4.8. We can also use algorithm EASKc, and obtain a curvature-independent approximation bound for this problem. The reason for this is the Ellipsoidal Approximation is of the form \u221a wfi(X), for each i and squaring it will lead to knapsack constraints. If we add the curvature terms (i.e., try to implement EASK in this setting), we obtain a much more complicated class of constraints, which we do not currently know how to handle. We can also extend SCSC and SCSK to non-monotone submodular functions. In particular, recall that the submodular knapsack has constant factor approximation guarantees even when g is non-monotone submodular [7]. Hence, we can obtain bi-criterion approximation guarantees for the Submodular Set Cover (SSC) problem, by solving the Submodular Knapsack (SK) problem multiple times. We can similarly do SCSC and SCSK when f is monotone submodular and g is non-monotone submodular, by extending ISSC, EASSC, ISK and EASK (note that in all these cases, we need to solve a submodular set cover or submodular knapsack problem with a non-monotone g). These algorithms, however, do not extend if f is non-monotone, and we do not currently know how to implement these."}, {"heading": "4.4 Hardness", "text": "In this section, we provide the hardness for Problems 1 and 2. The lower bounds serve to show that the approximation factors above are almost tight.\nTheorem 4.12. For any \u03ba > 0, there exists submodular functions with curvature \u03ba such that no polynomial time algorithm for Problems 1 and 2 achieves a bi-criterion factor better than \u03c3\u03c1 = n1/2\u2212 1+(n1/2\u2212 \u22121)(1\u2212\u03ba) for any\n> 0.\nProof. We prove this result using the hardness construction from [11, 43]. The main idea of their proof technique is to construct two submodular functions f(X) and fR(X) that with high probability are indistinguishable. Thus, also with high probability, no algorithm can distinguish between the two functions and the gap in their values provides a lower bound on the approximation. We shall see that this lower bound in fact matches the approximation factors up to log factors and hence this is the hardness of the problem. Define two monotone submodular functions f(X) = \u03baf min{|X|, \u03b1}+ (1\u2212 \u03baf )|X| and fR(X) = \u03baf min{\u03b2 + |X \u2229 R\u0304|, |X|, \u03b1}+ (1\u2212 \u03baf )|X|, where R \u2286 V is a random set of cardinality \u03b1. Let \u03b1 and \u03b2 be an integer such that \u03b1 = x \u221a n/5 and \u03b2 = x2/5 for an x2 = \u03c9(log n). Both f and fR have curvature \u03baf . We also assume a very simple function g(X) = |X|. Given an arbitrary > 0, set x2 = n2 = \u03c9(log n). Then the ratio between f \u03baf R (R) and g \u03baf (R) is n 1/2\u2212 1+(n1/2\u2212 \u22121)(1\u2212\u03baf ) . A Chernoff bound analysis very similar to [43] reveals that any algorithm that uses a polynomial number of queries can distinguish h\u03ba and f\u03baR with probability only n \u2212\u03c9(1), and therefore cannot reliably distinguish the functions with a polynomial number of queries. We first prove the first part of this theorem (i.e., for SCSC). In this case, we consider the problem\nmin{h(X)||X| \u2265 \u03b1} (34)\nwith h chosen as f and fR respectively. It is easy to see that R is the optimal set in both cases. However the ratio between the two is\n\u03b3(n) = n1/2\u2212\n1 + (n1/2\u2212 \u2212 1)(1\u2212 \u03baf ) (35)\nNow suppose there exists an algorithm which is guaranteed to obtain an approximation factor better than \u03b3(n). Then by running this algorithm, we are guaranteed to find different answers for Eqn (34) above. This must imply that this algorithm can distinguish between fR and g which is a contradiction. Hence no algorithm for Problem 1 can obtain an approximation guarantee n 1/2\u2212\n1+(n1/2\u2212 \u22121)(1\u2212\u03baf ) .\nIn order to extend the result to the bi-criterion case, we need to show that no bi-criterion approximation algorithm can obtain a factor better than \u03c3\u03c1 = \u03b3(n). Assume there exists a bi-criterion algorithm with a factor [\u03c3, \u03c1] such that:\n\u03c3 \u03c1 < \u03b3(n) =\nn1/2\u2212\n1 + (n1/2\u2212 \u2212 1)(1\u2212 \u03baf ) (36)\nThen, we are guaranteed to obtain a set S in equation (34) such that h(S) \u2264 \u03c3OPT and |S| \u2265 \u03c1\u03b1, where \u03c3 \u2265 1 and \u03c1 \u2264 1. Now we run this algorithm with h = f and h = fR respectively. With h = f , it is easy to see that the algorithm obtains a set S1 such that f(S1) \u2264 \u03c3\u03b1 and |S1| \u2265 \u03c1\u03b1. Similarly, with h = fR, the algorithm finds a set S2 such that f(S2) \u2264 \u03c3(\u03ba\u03b2 + (1 \u2212 \u03ba)\u03b1) and |S2| \u2265 \u03c1\u03b1. Since fR and f are indistinguishable, S1 = S2 = S. We first assume that |S| < \u03b1. Then f(S) = |S| \u2265 \u03c1\u03b1. We then have that,\nfR(S) \u2264 \u03c3(\u03ba\u03b2 + (1\u2212 \u03ba)\u03b1 (37) \u2264 \u03c3n2 (1 + (n1/2\u2212 \u2212 1)(1\u2212 \u03baf ) (38) < \u03c1\u03b3(n)n2 (1 + (n1/2\u2212 \u2212 1)(1\u2212 \u03baf ) (39) < \u03c1n1/2+ (40)\n< \u03c1\u03b1 (41)\nThis implies that the algorithm can distinguish between fR and f which is a contradiction. Now consider the second case when |S| \u2265 \u03b1. In this case, f(S) = \u03b1. Again the chain of inequalities above shows that fR(S) < \u03c1\u03b1 < \u03b1 since \u03c1 \u2264 1. This again implies that the algorithm can distinguish between fR and f which is a contradiction. Hence no bi-criterion approximation algorithm can obtain a factor better than \u03b3(n). To show the second part (for SCSK), we can simply invoke Theorem 3.1 and argue that any [\u03c1, \u03c3] bi-criterion approximation algorithm for problem 2 with\n\u03c3 \u03c1 < \u03b3(n) 1 + (42)\ncan be used in algorithm 3, to provide a [\u03c3, \u03c1] bi-criterion algorithm with \u03c3\u03c1 < \u03b3(n). This contradicts the first part above and hence the same hardness applies to problem 2 as well.\nThe above result shows that EASSC and EASK meet the bounds above to log factors. We see an interesting curvature-dependent influence on the hardness. We also see from our approximation guarantees also that the curvature of f plays a more influential role than the curvature of g on the approximation quality. In particular, as soon as f becomes modular, the problem becomes easy, even when g is submodular. This is not surprising since the submodular set cover problem and the submodular cost knapsack problem both have constant factor guarantees."}, {"heading": "5 Experiments", "text": "In this section, we empirically compare the performance of the various algorithms discussed in this paper. We are motivated by the speech data subset selection application [30, 33, 21] with the submodular function f encouraging limited vocabulary while g tries to achieve acoustic variability. A natural choice of the function f is a function of the form |\u0393(X)|, where \u0393(X) is the neighborhood function on a bipartite graph constructed between the utterances and the words [33]. For the coverage function g, we use two types of coverage: one is a facility location function\ng1(X) = \u2211 i\u2208V max j\u2208X sij (43)\nwhile the other is a saturated sum function g2(X) = \u2211 i\u2208V min{ \u2211 j\u2208X sij , \u03b1 \u2211 j\u2208V sij}. (44)\nBoth these functions are defined in terms of a similarity matrix S = {sij}i,j\u2208V , which we define on the TIMIT corpus [9], using the string kernel metric [41] for similarity. Since some of our algorithms, like the Ellipsoidal Approximations, are computationally intensive, we restrict ourselves to 50 utterances. We compare our different algorithms on Problems 1 and 2 with f being the bipartite neighborhood and g being the facility location and saturated sum respectively. Since the primal and dual variants of the submodular set cover problem are similar, we just use the primal variants of ISSC and EASSC. Furthermore, in our experiments, we observe that the neighborhood function f has a curvature \u03baf = 1. Thus, it suffices to use the simpler versions of algorithm EA (i.e., algorithm EASSCc and EASKc). The results are shown in Figure 3. We observe that on the real-world instances, all our algorithms perform almost comparably. This implies, moreover, that the iterative variants, viz. Gr, ISSC and ISK, perform comparably to the more complicated EA-based ones, although EASSC and EASK have better theoretical guarantees. We also compare against a baseline of selecting random sets (of varying cardinality), and we see that our algorithms all perform much better. In terms of the running time, computing the Ellipsoidal Approximation for |\u0393(X)| with |V | = 50 takes about 5 hours while all the iterative variants (i.e., Gr, ISSC and ISK) take less than a second. This difference is much more prominent on larger instances (for example |V | = 500)."}, {"heading": "6 Discussions and related work", "text": "In this paper, we propose a unifying framework for problems 1 and 2 based on suitable surrogate functions. We provide a number of iterative algorithms which are very practical and scalable (like Gr, ISK and ISSC), and also algorithms like EASSC and EASK, which though more intensive, obtain tight approximation bounds. Finally, we empirically compare our algorithms, and show that the iterative algorithms compete empirically with the more complicated and theoretically better approximation algorithms. To our knowledge, this paper provides the first general framework of approximation algorithms for Problems 1 and 2 for monotone submodular functions f and g. A number of papers, however, investigate related problems and approaches. For example, [8] investigates an exact algorithm for solving problem 1, with equality instead of inequality. However, since problem 1 subsumes the problem of minimizing a monotone submodular function subject to a cardinality equality constraint, and is hence NP hard [36]. Hence this algorithm in the worst case, must be exponential. Furthermore, a similar problem was considered in [25] with one specific instance of a function f , which is not submodular. They also use, a considerably different algorithm. Also, an algorithm equivalent to the first iteration of ISSC was proposed in [46, 5] and ISSC not only generalizes this, but we also provide a more explicit approximation guarantee (we provide an elaborate discussion on this in the section describing ISSC). We also point out that, a special case of SCSK was considered in [29], with f being submodular, and g modular (we called this the submodular span problem). The authors there use an algorithm very similar to Algorithm 2, to convert this problem into an instance of minimizing a submodular function subject to a knapsack constraint, for which they use the algorithm of [43]. Unfortunately, the algorithm of [43] does not scale very well. Our algorithms for this problem, on the other hand, would continue to scale very well in practice. Similarly, a number of approximation algorithms have been shown for Problem 0 [14, 37, 22]. The algorithms in [14, 37] are scalable and practical, but lack theoretical guarantees. The algorithm of [22] though exact, employs a branch and bound technique which is often inefficient in practice (the timing analysis from [22] also depicts that). These facts are not surprising, since problem 0 is not only NP hard but also inapproximable. Moreover, these algorithms are not comparable to ours, since we directly model the hard constraints and our bicriteria results give worst-case bounds on the deviation from the constraints and the optimal solution.\nThis is often important, since there are hard constraints in many practical applications (in the form of power constraints, or budget constraints). Casting it as Problem 0, however, no longer has guarantees on the deviation from the constraints. For future work, we would like to empirically evaluate our algorithms on many of the real world problems described above, particularly the limited vocabulary data subset selection application for speech corpora, and the machine translation application. Acknowledgments: Special thanks to Kai Wei and Stefanie Jegelka for discussions, to Bethany Herwaldt for going through an early draft of this manuscript and to the anonymous reviewers for useful reviews. This material is based upon work supported by the National Science Foundation under Grant No. (IIS-1162606), a Google and a Microsoft award, and by the Intel Science and Technology Center for Pervasive Computing."}], "references": [{"title": "The submodular knapsack polytope", "author": ["A. Atamt\u00fcrk", "V. Narayanan"], "venue": "Discrete Optimization,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2009}, {"title": "Interactive graph cuts for optimal boundary and region segmentation of objects in n-d images", "author": ["Y. Boykov", "M. Jolly"], "venue": "ICCV,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2001}, {"title": "Submodular set functions, matroids and the greedy algorithm: tight worstcase bounds and some generalizations of the Rado-Edmonds theorem", "author": ["M. Conforti", "G. Cornuejols"], "venue": "Discrete Applied Mathematics, 7(3):251\u2013274,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1984}, {"title": "Decomposition of submodular functions", "author": ["W.H. Cunningham"], "venue": "Combinatorica, 3(1):53\u201368,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1983}, {"title": "On minimum submodular cover with submodular cost", "author": ["H. Du", "W. Wu", "W. Lee", "Q. Liu", "Z. Zhang", "D.-Z. Du"], "venue": "Journal of Global Optimization, 50(2):229\u2013234,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2011}, {"title": "A threshold of ln n for approximating set cover", "author": ["U. Feige"], "venue": "Journal of the ACM (JACM),", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1998}, {"title": "Maximizing non-monotone submodular functions", "author": ["U. Feige", "V. Mirrokni", "J. Vondr\u00e1k"], "venue": "SIAM J. COMPUT., 40(4):1133\u20131155,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2011}, {"title": "Submodular functions and optimization, volume 58", "author": ["S. Fujishige"], "venue": "Elsevier Science,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2005}, {"title": "Timit, acoustic-phonetic continuous speech corpus", "author": ["J. Garofolo", "L.F. Lamel", "J. W", "Fiscus", "D. Pallet", "N. Dahlgren"], "venue": "In DARPA,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1993}, {"title": "Approximability of combinatorial problems with multi-agent submodular cost functions", "author": ["G. Goel", "C. Karande", "P. Tripathi", "L. Wang"], "venue": "FOCS,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "Approximating submodular functions everywhere", "author": ["M. Goemans", "N. Harvey", "S. Iwata", "V. Mirrokni"], "venue": "SODA, pages 535\u2013544,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2009}, {"title": "Interactive submodular set cover", "author": ["A. Guillory", "J. Bilmes"], "venue": "ICML,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2010}, {"title": "Simultaneous learning and covering with adversarial noise", "author": ["A. Guillory", "J. Bilmes"], "venue": "ICML,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2011}, {"title": "Algorithms for approximate minimization of the difference between submodular functions, with applications", "author": ["R. Iyer", "J. Bilmes"], "venue": "UAI,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "The submodular Bregman and Lov\u00e1sz-Bregman divergences with applications", "author": ["R. Iyer", "J. Bilmes"], "venue": "NIPS,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2012}, {"title": "Mirror descent like algorithms for submodular optimization", "author": ["R. Iyer", "S. Jegelka", "J. Bilmes"], "venue": "NIPS Workshop on Discrete Optimization in Machine Learning (DISCML),", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2012}, {"title": "Curvature and Optimal Algorithms for Learning and Minimizing Submodular Functions", "author": ["R. Iyer", "S. Jegelka", "J. Bilmes"], "venue": "NIPS,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2013}, {"title": "Fast semidifferential based submodular function optimization", "author": ["R. Iyer", "S. Jegelka", "J. Bilmes"], "venue": "ICML,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2013}, {"title": "Submodularity beyond submodular energies: coupling edges in graph cuts", "author": ["S. Jegelka", "J. Bilmes"], "venue": "Computer Vision and Pattern Recognition (CVPR),", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Submodularity beyond submodular energies: coupling edges in graph cuts", "author": ["S. Jegelka", "J.A. Bilmes"], "venue": "CVPR,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2011}, {"title": "On fast approximate submodular minimization", "author": ["S. Jegelka", "H. Lin", "J. Bilmes"], "venue": "NIPS,", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "Prismatic algorithm for discrete dc programming problems", "author": ["Y. Kawahara", "T. Washio"], "venue": "NIPS,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "Knapsack problems", "author": ["H. Kellerer", "U. Pferschy", "D. Pisinger"], "venue": "Springer Verlag,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2004}, {"title": "A note on the budgeted maximization on submodular functions", "author": ["A. Krause", "C. Guestrin"], "venue": "Technical Report CMU-CALD-05-103, Carnegie Mellon University,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2005}, {"title": "Near-optimal sensor placements: Maximizing information while minimizing communication cost", "author": ["A. Krause", "C. Guestrin", "A. Gupta", "J. Kleinberg"], "venue": "IPSN,", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2006}, {"title": "Robust submodular observation selection", "author": ["A. Krause", "B. McMahan", "C. Guestrin", "A. Gupta"], "venue": "Journal of Machine Learning Research (JMLR), 9:2761\u20132801,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2008}, {"title": "Near-optimal sensor placements in Gaussian processes: Theory, efficient algorithms and empirical studies", "author": ["A. Krause", "A. Singh", "C. Guestrin"], "venue": "JMLR, 9:235\u2013284,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2008}, {"title": "Maximizing submodular set functions subject to multiple linear constraints", "author": ["A. Kulik", "H. Shachnai", "T. Tamir"], "venue": "SODA,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2009}, {"title": "Submodularity in Natural Language Processing: Algorithms and Applications", "author": ["H. Lin"], "venue": "PhD thesis, University of Washington, Dept. of EE,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2012}, {"title": "How to select a good training-data subset for transcription: Submodular active selection for sequences", "author": ["H. Lin", "J. Bilmes"], "venue": "Interspeech,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2009}, {"title": "Multi-document summarization via budgeted maximization of submodular functions", "author": ["H. Lin", "J. Bilmes"], "venue": "NAACL,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2010}, {"title": "A class of submodular functions for document summarization", "author": ["H. Lin", "J. Bilmes"], "venue": "The 49th Meeting of the Assoc. for Comp. Ling. Human Lang. Technologies (ACL/HLT-2011), Portland, OR, June", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2011}, {"title": "Optimal selection of limited vocabulary speech corpora", "author": ["H. Lin", "J. Bilmes"], "venue": "Interspeech,", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2011}, {"title": "Submodular functions and convexity", "author": ["L. Lov\u00e1sz"], "venue": "Mathematical Programming,", "citeRegEx": "34", "shortCiteRegEx": null, "year": 1983}, {"title": "Intelligent selection of language model training data", "author": ["R.C. Moore", "W. Lewis"], "venue": "Proceedings of the ACL 2010 Conference Short Papers, pages 220\u2013224. Association for Computational Linguistics,", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2010}, {"title": "Size-constrained submodular minimization through minimum norm base", "author": ["K. Nagano", "Y. Kawahara", "K. Aihara"], "venue": "ICML,", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2011}, {"title": "A submodular-supermodular procedure with applications to discriminative structure learning", "author": ["M. Narasimhan", "J. Bilmes"], "venue": "UAI,", "citeRegEx": "37", "shortCiteRegEx": null, "year": 2005}, {"title": "Best algorithms for approximating the maximum of a submodular set function", "author": ["G. Nemhauser", "L. Wolsey"], "venue": "Mathematics of Operations Research, 3(3):177\u2013188,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1978}, {"title": "Approximation algorithms for offline risk-averse combinatorial optimization", "author": ["E. Nikolova"], "venue": null, "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2010}, {"title": "Cosegmentation of image pairs by histogram matching-incorporating a global constraint into MRFs", "author": ["C. Rother", "T. Minka", "A. Blake", "V. Kolmogorov"], "venue": "CVPR, volume 1, pages 993\u20131000. IEEE,", "citeRegEx": "40", "shortCiteRegEx": null, "year": 2006}, {"title": "Efficient computation of gapped substring kernels on large alphabets", "author": ["J. Rousu", "J. Shawe-Taylor"], "venue": "Journal of Machine Learning Research, 6(2):1323,", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2006}, {"title": "A note on maximizing a submodular set function subject to a knapsack constraint", "author": ["M. Sviridenko"], "venue": "Operations Research Letters, 32(1):41\u201343,", "citeRegEx": "42", "shortCiteRegEx": null, "year": 2004}, {"title": "Submodular approximation: Sampling-based algorithms and lower bounds", "author": ["Z. Svitkina", "L. Fleischer"], "venue": "FOCS, pages 697\u2013706,", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2008}, {"title": "Approximation algorithms", "author": ["V.V. Vazirani"], "venue": "springer,", "citeRegEx": "44", "shortCiteRegEx": null, "year": 2004}, {"title": "Submodularity and curvature: the optimal algorithm", "author": ["J. Vondr\u00e1k"], "venue": "RIMS Kokyuroku Bessatsu, 23,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2010}, {"title": "Greedy approximations for minimum submodular cover with submodular cost", "author": ["P.-J. Wan", "D.-Z. Du", "P. Pardalos", "W. Wu"], "venue": "Computational Optimization and Applications, 45(2):463\u2013474,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 2010}, {"title": "An analysis of the greedy algorithm for the submodular set covering problem", "author": ["L.A. Wolsey"], "venue": "Combinatorica, 2(4):385\u2013393,", "citeRegEx": "47", "shortCiteRegEx": null, "year": 1982}], "referenceMentions": [{"referenceID": 13, "context": "These problems are often posed as minimizing the difference between submodular functions [14, 37] which is in the worst case inapproximable.", "startOffset": 89, "endOffset": 97}, {"referenceID": 36, "context": "These problems are often posed as minimizing the difference between submodular functions [14, 37] which is in the worst case inapproximable.", "startOffset": 89, "endOffset": 97}, {"referenceID": 7, "context": "A set function f : 2 \u2192 R is said to be submodular [8] if for all subsets S, T \u2286 V , it holds that f(S) + f(T ) \u2265 f(S \u222a T ) + f(S \u2229 T ).", "startOffset": 50, "endOffset": 53}, {"referenceID": 33, "context": "While general set function optimization is often intractable, many forms of submodular function optimization can be solved near optimally or even optimally in certain cases, and hence submodularity is also often called the discrete analog of convexity [34].", "startOffset": 252, "endOffset": 256}, {"referenceID": 46, "context": "The corresponding constraints are called the submodular cover [47] and submodular knapsack [1] respectively and hence we refer to Problem", "startOffset": 62, "endOffset": 66}, {"referenceID": 0, "context": "The corresponding constraints are called the submodular cover [47] and submodular knapsack [1] respectively and hence we refer to Problem", "startOffset": 91, "endOffset": 94}, {"referenceID": 13, "context": "A standard approach used in literature [14, 37, 22] has been to transform these problems into minimizing the difference between submodular functions (also called DS optimization):", "startOffset": 39, "endOffset": 51}, {"referenceID": 36, "context": "A standard approach used in literature [14, 37, 22] has been to transform these problems into minimizing the difference between submodular functions (also called DS optimization):", "startOffset": 39, "endOffset": 51}, {"referenceID": 21, "context": "A standard approach used in literature [14, 37, 22] has been to transform these problems into minimizing the difference between submodular functions (also called DS optimization):", "startOffset": 39, "endOffset": 51}, {"referenceID": 13, "context": "While a number of heuristics are available for solving Problem 0, and while these heuristics often work well in practice [14, 37], in the worst-case it is NP-hard and inapproximable [14], even when f and g are monotone.", "startOffset": 121, "endOffset": 129}, {"referenceID": 36, "context": "While a number of heuristics are available for solving Problem 0, and while these heuristics often work well in practice [14, 37], in the worst-case it is NP-hard and inapproximable [14], even when f and g are monotone.", "startOffset": 121, "endOffset": 129}, {"referenceID": 13, "context": "While a number of heuristics are available for solving Problem 0, and while these heuristics often work well in practice [14, 37], in the worst-case it is NP-hard and inapproximable [14], even when f and g are monotone.", "startOffset": 182, "endOffset": 186}, {"referenceID": 21, "context": "Although an exact branch and bound algorithm has been provided for this problem [22], its complexity can be exponential in the worst case.", "startOffset": 80, "endOffset": 84}, {"referenceID": 26, "context": "Sensor Placement and Feature Selection: Often, the problem of choosing sensor locations A from a given set of possible locations V can be modeled [27, 14] by maximizing the mutual information between the chosen variables A and the unchosen set V \\A (i.", "startOffset": 146, "endOffset": 154}, {"referenceID": 13, "context": "Sensor Placement and Feature Selection: Often, the problem of choosing sensor locations A from a given set of possible locations V can be modeled [27, 14] by maximizing the mutual information between the chosen variables A and the unchosen set V \\A (i.", "startOffset": 146, "endOffset": 154}, {"referenceID": 26, "context": "Note that, while the symmetric mutual information is not monotone, it can be shown to approximately monotone [27].", "startOffset": 109, "endOffset": 113}, {"referenceID": 26, "context": ", f(A) = I(XA;C)) assuming that the set of features XA are conditionally independent given C [27, 14].", "startOffset": 93, "endOffset": 101}, {"referenceID": 13, "context": ", f(A) = I(XA;C)) assuming that the set of features XA are conditionally independent given C [27, 14].", "startOffset": 93, "endOffset": 101}, {"referenceID": 26, "context": "Often this cost is submodular [27, 14].", "startOffset": 30, "endOffset": 38}, {"referenceID": 13, "context": "Often this cost is submodular [27, 14].", "startOffset": 30, "endOffset": 38}, {"referenceID": 32, "context": "The motivation for this problem is to find the subset of training examples which will facilitate evaluation of prototype systems [33].", "startOffset": 129, "endOffset": 133}, {"referenceID": 32, "context": "This problem then occurs in the form of Problem 1, where we want to find a small vocabulary subset (which is often submodular [33]), subject to a constraint that the subset acoustically spans the entire data set (which is also often submodular [30, 31]).", "startOffset": 126, "endOffset": 130}, {"referenceID": 29, "context": "This problem then occurs in the form of Problem 1, where we want to find a small vocabulary subset (which is often submodular [33]), subject to a constraint that the subset acoustically spans the entire data set (which is also often submodular [30, 31]).", "startOffset": 244, "endOffset": 252}, {"referenceID": 30, "context": "This problem then occurs in the form of Problem 1, where we want to find a small vocabulary subset (which is often submodular [33]), subject to a constraint that the subset acoustically spans the entire data set (which is also often submodular [30, 31]).", "startOffset": 244, "endOffset": 252}, {"referenceID": 34, "context": "Machine Translation: Another application in machine translation is to choose a subset of training data that is optimized for given test data set, a problem previously addressed with modular functions [35].", "startOffset": 200, "endOffset": 204}, {"referenceID": 1, "context": "In computer vision and high-tree-width Markov random fields, this has been addressed using graph-cut algorithms [2], which are applicable when the MRF\u2019s energy function is submodular and limited degree, and more general submodular function minimization in the case of higher degree.", "startOffset": 112, "endOffset": 115}, {"referenceID": 19, "context": "Moreover, many useful non-submodular energy functions have also recently been phrased as forms of constrained submodular minimization [20] which still have bounded approximation guarantees.", "startOffset": 134, "endOffset": 138}, {"referenceID": 39, "context": "For example, in image co-segmentation [40], V = V1 \u222a V2 can represent the set of pixels in two images, f is the submodular energy function of the two images, while g represents the similarity between the two histograms of the hypothesized foreground regions in the two images, a function shown to be submodular in [40].", "startOffset": 38, "endOffset": 42}, {"referenceID": 39, "context": "For example, in image co-segmentation [40], V = V1 \u222a V2 can represent the set of pixels in two images, f is the submodular energy function of the two images, while g represents the similarity between the two histograms of the hypothesized foreground regions in the two images, a function shown to be submodular in [40].", "startOffset": 314, "endOffset": 318}, {"referenceID": 46, "context": "For example the Submodular Set Cover problem (henceforth SSC) [47] occurs as a special case of Problem 1, with f being modular and g is submodular.", "startOffset": 62, "endOffset": 66}, {"referenceID": 41, "context": "Similarly the Submodular Cost Knapsack problem (henceforth SK) [42] is a special case of problem 2 again when f is modular and g submodular.", "startOffset": 63, "endOffset": 67}, {"referenceID": 5, "context": "Both these problems subsume the Set Cover and Max k-Cover problems [6].", "startOffset": 67, "endOffset": 70}, {"referenceID": 22, "context": "When both f and g are modular, Problems 1 and 2 are called knapsack problems [23].", "startOffset": 77, "endOffset": 81}, {"referenceID": 42, "context": "Furthermore, Problem 1 also subsumes the cardinality constrained submodular minimization problem [43] and more generally the problem of minimizing a submodular function subject to a knapsack constraints.", "startOffset": 97, "endOffset": 101}, {"referenceID": 9, "context": "This in turn subsumes the minimum submodular spanning tree problem [10], when f is monotone submodular.", "startOffset": 67, "endOffset": 71}, {"referenceID": 41, "context": "We also show that many combinatorial algorithms like the greedy algorithm for SK [42] and SSC [47] (both of which seemingly use different techniques) also belong to this framework and provide the first constant-factor bi-criterion approximation algorithm for SSC [47] and hence the general set cover problem [6].", "startOffset": 81, "endOffset": 85}, {"referenceID": 46, "context": "We also show that many combinatorial algorithms like the greedy algorithm for SK [42] and SSC [47] (both of which seemingly use different techniques) also belong to this framework and provide the first constant-factor bi-criterion approximation algorithm for SSC [47] and hence the general set cover problem [6].", "startOffset": 94, "endOffset": 98}, {"referenceID": 46, "context": "We also show that many combinatorial algorithms like the greedy algorithm for SK [42] and SSC [47] (both of which seemingly use different techniques) also belong to this framework and provide the first constant-factor bi-criterion approximation algorithm for SSC [47] and hence the general set cover problem [6].", "startOffset": 263, "endOffset": 267}, {"referenceID": 5, "context": "We also show that many combinatorial algorithms like the greedy algorithm for SK [42] and SSC [47] (both of which seemingly use different techniques) also belong to this framework and provide the first constant-factor bi-criterion approximation algorithm for SSC [47] and hence the general set cover problem [6].", "startOffset": 308, "endOffset": 311}, {"referenceID": 2, "context": "Our guarantees and hardness results depend on the curvature of the submodular functions [3].", "startOffset": 88, "endOffset": 91}, {"referenceID": 39, "context": "2 [40] showed that \u2212g is supermodular.", "startOffset": 2, "endOffset": 6}, {"referenceID": 2, "context": "The total curvature \u03baf is then \u03baf (V ) [3, 45].", "startOffset": 39, "endOffset": 46}, {"referenceID": 44, "context": "The total curvature \u03baf is then \u03baf (V ) [3, 45].", "startOffset": 39, "endOffset": 46}, {"referenceID": 3, "context": "Totally normalized [4] and saturated functions like matroid rank have a curvature \u03baf = 1.", "startOffset": 19, "endOffset": 22}, {"referenceID": 2, "context": "A number of approximation guarantees in the context of submodular optimization have been refined via the curvature of the submodular function [3, 18, 17].", "startOffset": 142, "endOffset": 153}, {"referenceID": 17, "context": "A number of approximation guarantees in the context of submodular optimization have been refined via the curvature of the submodular function [3, 18, 17].", "startOffset": 142, "endOffset": 153}, {"referenceID": 16, "context": "A number of approximation guarantees in the context of submodular optimization have been refined via the curvature of the submodular function [3, 18, 17].", "startOffset": 142, "endOffset": 153}, {"referenceID": 2, "context": "For example, when maximizing a monotone submodular function under cardinality upper bound constraints, the bound of 1 \u2212 e\u22121 has been refined to 1\u2212e \u2212\u03baf \u03baf [3].", "startOffset": 155, "endOffset": 158}, {"referenceID": 17, "context": "Similar bounds have also been shown in the context of constrained submodular minimization [18, 17, 16].", "startOffset": 90, "endOffset": 102}, {"referenceID": 16, "context": "Similar bounds have also been shown in the context of constrained submodular minimization [18, 17, 16].", "startOffset": 90, "endOffset": 102}, {"referenceID": 15, "context": "Similar bounds have also been shown in the context of constrained submodular minimization [18, 17, 16].", "startOffset": 90, "endOffset": 102}, {"referenceID": 17, "context": "Our algorithms using upper and lower bounds are analogous to the majorization/ minimization algorithms proposed in [18, 16], where we provided a unified framework of fast algorithms for submodular optimization.", "startOffset": 115, "endOffset": 123}, {"referenceID": 15, "context": "Our algorithms using upper and lower bounds are analogous to the majorization/ minimization algorithms proposed in [18, 16], where we provided a unified framework of fast algorithms for submodular optimization.", "startOffset": 115, "endOffset": 123}, {"referenceID": 10, "context": "One such classical approximation is the ellipsoidal approximations [11].", "startOffset": 67, "endOffset": 71}, {"referenceID": 7, "context": "These bounds are related to the subdifferential \u2202f (Y ) of the submodular set function f at a set Y \u2286 V , which is defined [8] as: \u2202f (Y ) = {y \u2208 R : f(X)\u2212 y(X) \u2265 f(Y )\u2212 y(Y ) for all X \u2286 V } (3)", "startOffset": 123, "endOffset": 126}, {"referenceID": 19, "context": "Modular upper bounds: We can also define superdifferentials \u2202 (Y ) of a submodular function [20, 15] at Y :", "startOffset": 92, "endOffset": 100}, {"referenceID": 14, "context": "Modular upper bounds: We can also define superdifferentials \u2202 (Y ) of a submodular function [20, 15] at Y :", "startOffset": 92, "endOffset": 100}, {"referenceID": 14, "context": "It is possible, moreover, to provide specific supergradients [15, 18, 16] that define the following two modular upper bounds (when referring either one, we use mfX): mfX,1(Y ) , f(X)\u2212 \u2211", "startOffset": 61, "endOffset": 73}, {"referenceID": 17, "context": "It is possible, moreover, to provide specific supergradients [15, 18, 16] that define the following two modular upper bounds (when referring either one, we use mfX): mfX,1(Y ) , f(X)\u2212 \u2211", "startOffset": 61, "endOffset": 73}, {"referenceID": 15, "context": "It is possible, moreover, to provide specific supergradients [15, 18, 16] that define the following two modular upper bounds (when referring either one, we use mfX): mfX,1(Y ) , f(X)\u2212 \u2211", "startOffset": 61, "endOffset": 73}, {"referenceID": 17, "context": "MM algorithms using upper/lower bounds: Using the modular upper and lower bounds above in Algorithm 1, provide a class of Majorization-Minimization (MM) algorithms, akin to the algorithms proposed in [18, 16] for submodular optimization and in [37, 14] for DS optimization (Problem 0 above).", "startOffset": 200, "endOffset": 208}, {"referenceID": 15, "context": "MM algorithms using upper/lower bounds: Using the modular upper and lower bounds above in Algorithm 1, provide a class of Majorization-Minimization (MM) algorithms, akin to the algorithms proposed in [18, 16] for submodular optimization and in [37, 14] for DS optimization (Problem 0 above).", "startOffset": 200, "endOffset": 208}, {"referenceID": 36, "context": "MM algorithms using upper/lower bounds: Using the modular upper and lower bounds above in Algorithm 1, provide a class of Majorization-Minimization (MM) algorithms, akin to the algorithms proposed in [18, 16] for submodular optimization and in [37, 14] for DS optimization (Problem 0 above).", "startOffset": 244, "endOffset": 252}, {"referenceID": 13, "context": "MM algorithms using upper/lower bounds: Using the modular upper and lower bounds above in Algorithm 1, provide a class of Majorization-Minimization (MM) algorithms, akin to the algorithms proposed in [18, 16] for submodular optimization and in [37, 14] for DS optimization (Problem 0 above).", "startOffset": 244, "endOffset": 252}, {"referenceID": 5, "context": "Unfortunately, Problems 1 and 2 are NP-hard even if f or g (or both) are modular [6], and therefore the surrogate problems themselves cannot be solved exactly.", "startOffset": 81, "endOffset": 84}, {"referenceID": 13, "context": "What is also fortunate and perhaps surprising, as we show in this paper below, is that unlike the case of DS optimization (where the problem is inapproximable in general [14]), the constrained forms of optimization (Problems 1 and 2) do have approximation guarantees.", "startOffset": 170, "endOffset": 174}, {"referenceID": 10, "context": "al [11] is to provide an algorithm based on approximating the submodular polyhedron by an ellipsoid.", "startOffset": 3, "endOffset": 7}, {"referenceID": 16, "context": "A simple trick then provides a curvature-dependent approximation [17] \u2014 we define the \u03baf -curve-normalized version of f as follows:", "startOffset": 65, "endOffset": 69}, {"referenceID": 16, "context": "[17] Given a polymatroid function f with a curvature \u03baf < 1, the submodular function f(X) = \u03baf \u221a wf(X) + (1\u2212 \u03baf ) \u2211 j\u2208X f(j) satisfies: f(X) \u2264 f(X) \u2264 O ( \u221a n log n 1 + ( \u221a n log n\u2212 1)(1\u2212 \u03baf ) ) f(X),\u2200X \u2286 V (7)", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "We also remark that a specific instance of such a transformation has been used [26], for a specific class of functions f and g.", "startOffset": 79, "endOffset": 83}, {"referenceID": 11, "context": "This problem occurs naturally in a number of problems related to active/online learning [12] and summarization [31, 32].", "startOffset": 88, "endOffset": 92}, {"referenceID": 30, "context": "This problem occurs naturally in a number of problems related to active/online learning [12] and summarization [31, 32].", "startOffset": 111, "endOffset": 119}, {"referenceID": 31, "context": "This problem occurs naturally in a number of problems related to active/online learning [12] and summarization [31, 32].", "startOffset": 111, "endOffset": 119}, {"referenceID": 46, "context": "This problem was first investigated by Wolsey [47], wherein he showed that a simple greedy algorithm achieves bounded (in fact, log-factor) approximation guarantees.", "startOffset": 46, "endOffset": 50}, {"referenceID": 17, "context": "Akin to the framework of algorithms in [18], the crucial factor is the choice of the lower bound (or subgradient).", "startOffset": 39, "endOffset": 43}, {"referenceID": 46, "context": "Then we have the following lemma, which is an extension of [47]:", "startOffset": 59, "endOffset": 63}, {"referenceID": 22, "context": "The resulting knapsack problem can be addressed using the greedy algorithm [23], but this exactly corresponds to the greedy algorithm of submodular set cover [47] and hence the guarantee follows from Theorem 1 in [47].", "startOffset": 75, "endOffset": 79}, {"referenceID": 46, "context": "The resulting knapsack problem can be addressed using the greedy algorithm [23], but this exactly corresponds to the greedy algorithm of submodular set cover [47] and hence the guarantee follows from Theorem 1 in [47].", "startOffset": 158, "endOffset": 162}, {"referenceID": 46, "context": "The resulting knapsack problem can be addressed using the greedy algorithm [23], but this exactly corresponds to the greedy algorithm of submodular set cover [47] and hence the guarantee follows from Theorem 1 in [47].", "startOffset": 213, "endOffset": 217}, {"referenceID": 43, "context": "The surrogate problem in this instance is a simple knapsack problem that can be solved nearly optimally using dynamic programming [44].", "startOffset": 130, "endOffset": 134}, {"referenceID": 46, "context": "As stated in the proof, the greedy algorithm for the submodular set cover problem [47] is in fact equivalent to using the greedy algorithm for the knapsack problem [23], which is in fact suboptimal.", "startOffset": 82, "endOffset": 86}, {"referenceID": 22, "context": "As stated in the proof, the greedy algorithm for the submodular set cover problem [47] is in fact equivalent to using the greedy algorithm for the knapsack problem [23], which is in fact suboptimal.", "startOffset": 164, "endOffset": 168}, {"referenceID": 46, "context": "When g is integral, the guarantee of the greedy algorithm is Hg , H(maxj g(j)), where H(d) = \u2211d i=1 1 i [47] (henceforth we will use Hg for this quantity).", "startOffset": 104, "endOffset": 108}, {"referenceID": 5, "context": "This factor is tight up to lower-order terms [6].", "startOffset": 45, "endOffset": 48}, {"referenceID": 41, "context": "We could also solve SSC by looking at its dual, which is SK [42].", "startOffset": 60, "endOffset": 64}, {"referenceID": 5, "context": "Although SSC does not admit any constant-factor approximation algorithms [6], we can obtain a constant-factor bi-criterion guarantee:", "startOffset": 73, "endOffset": 76}, {"referenceID": 41, "context": "Using the greedy algorithm for SK [42] as the approximation oracle in Algorithm 3 provides a [1 + , 1\u2212 e\u22121] bi-criterion approximation algorithm for SSC, for any > 0.", "startOffset": 34, "endOffset": 38}, {"referenceID": 41, "context": "This result follows immediately from the guarantee of the submodular cost knapsack problem [42] and Theorem 3.", "startOffset": 91, "endOffset": 95}, {"referenceID": 30, "context": "We remark that we can also use a simpler version of the greedy iteration at every iteration [31, 24] and we obtain a guarantee of (1 + , 1/2(1\u2212 e\u22121)).", "startOffset": 92, "endOffset": 100}, {"referenceID": 23, "context": "We remark that we can also use a simpler version of the greedy iteration at every iteration [31, 24] and we obtain a guarantee of (1 + , 1/2(1\u2212 e\u22121)).", "startOffset": 92, "endOffset": 100}, {"referenceID": 30, "context": "A nice property of the greedy algorithm for the submodular knapsack problem is that it can be completely parameterized by the chain of sets (this holds for the greedy algorithm of [31, 24] for knapsack constraints and the basic greedy algorithm of [38] under cardinality constraints).", "startOffset": 180, "endOffset": 188}, {"referenceID": 23, "context": "A nice property of the greedy algorithm for the submodular knapsack problem is that it can be completely parameterized by the chain of sets (this holds for the greedy algorithm of [31, 24] for knapsack constraints and the basic greedy algorithm of [38] under cardinality constraints).", "startOffset": 180, "endOffset": 188}, {"referenceID": 37, "context": "A nice property of the greedy algorithm for the submodular knapsack problem is that it can be completely parameterized by the chain of sets (this holds for the greedy algorithm of [31, 24] for knapsack constraints and the basic greedy algorithm of [38] under cardinality constraints).", "startOffset": 248, "endOffset": 252}, {"referenceID": 13, "context": "An analysis very similar to the ones in [14, 18] will reveal polynomial time convergence.", "startOffset": 40, "endOffset": 48}, {"referenceID": 17, "context": "An analysis very similar to the ones in [14, 18] will reveal polynomial time convergence.", "startOffset": 40, "endOffset": 48}, {"referenceID": 17, "context": "4 in [18].", "startOffset": 5, "endOffset": 9}, {"referenceID": 17, "context": "In particular, the result from [18] ensures a guarantee of", "startOffset": 31, "endOffset": 35}, {"referenceID": 16, "context": "The inequalities above follow from the fact that the modular upper bound mf\u2205(X) satisfies [17], mf\u2205(X) \u2264 f(X) \u2264 |X| 1 + (|X| \u2212 1)(1\u2212 \u03baf ) f(X) (13)", "startOffset": 90, "endOffset": 94}, {"referenceID": 13, "context": "For example, using square-root over modular function f(X) = \u2211k i=1 \u221a wi(X), which is common model used in applications [14, 29, 19], the worst case guarantee is Hg \u221a Kg.", "startOffset": 119, "endOffset": 131}, {"referenceID": 28, "context": "For example, using square-root over modular function f(X) = \u2211k i=1 \u221a wi(X), which is common model used in applications [14, 29, 19], the worst case guarantee is Hg \u221a Kg.", "startOffset": 119, "endOffset": 131}, {"referenceID": 18, "context": "For example, using square-root over modular function f(X) = \u2211k i=1 \u221a wi(X), which is common model used in applications [14, 29, 19], the worst case guarantee is Hg \u221a Kg.", "startOffset": 119, "endOffset": 131}, {"referenceID": 16, "context": "This follows directly from the results in [17].", "startOffset": 42, "endOffset": 46}, {"referenceID": 45, "context": ", the simple modular upper bound of f) was considered in [46, 5].", "startOffset": 57, "endOffset": 64}, {"referenceID": 4, "context": ", the simple modular upper bound of f) was considered in [46, 5].", "startOffset": 57, "endOffset": 64}, {"referenceID": 45, "context": "Furthermore, our bound is also tight since with, for example, f(X) = min{|X|, 1}, our exactly matches the bound of [46, 5].", "startOffset": 115, "endOffset": 122}, {"referenceID": 4, "context": "Furthermore, our bound is also tight since with, for example, f(X) = min{|X|, 1}, our exactly matches the bound of [46, 5].", "startOffset": 115, "endOffset": 122}, {"referenceID": 22, "context": "Then, rather than solving every iteration through the greedy algorithm, we can solve every iteration as a knapsack problem (minimizing a modular function over a modular lower bound constraint) [23], using say, a dynamic programming based approach.", "startOffset": 193, "endOffset": 197}, {"referenceID": 38, "context": "Fortunately, we can use the result from [39], where they show that any function of the form of \u221a w1(X) +w2(X) can be optimized over any polytope P with an approximation factor of \u03b2(1 + ) for any > 0, where \u03b2 is the approximation factor of optimizing a modular function over P.", "startOffset": 40, "endOffset": 44}, {"referenceID": 38, "context": "The idea of the proof is to use the result from [39] where they show that any function of the form \u03bb1 \u221a m1(X) + \u03bb2m2(X) where \u03bb1 \u2265 0, \u03bb2 \u2265 0 and m1 and m2 are positive modular functions has a FPTAS, provided a modular function can easily be optimized over C.", "startOffset": 48, "endOffset": 52}, {"referenceID": 41, "context": "In this case, SCSK turns into the SK problem for which the greedy algorithm with partial enumeration provides a 1\u2212 e\u22121 approximation [42].", "startOffset": 133, "endOffset": 137}, {"referenceID": 17, "context": "In particular, we then get back the framework of [18], where the authors show that choosing a permutation based on a greedy ordering, exactly analogous to Eqn.", "startOffset": 49, "endOffset": 53}, {"referenceID": 41, "context": "A slight catch however is that for the analysis to work, [42] needs to consider ( n 3 ) instances of such orderings (partial enumeration), chosen by fixing the first three elements in the permutation [18].", "startOffset": 57, "endOffset": 61}, {"referenceID": 17, "context": "A slight catch however is that for the analysis to work, [42] needs to consider ( n 3 ) instances of such orderings (partial enumeration), chosen by fixing the first three elements in the permutation [18].", "startOffset": 200, "endOffset": 204}, {"referenceID": 17, "context": "We can however just choose the simple greedy ordering in one stage, to get a slightly worse approximation factor of 1\u2212 e\u22121/2 [18, 31, 24].", "startOffset": 125, "endOffset": 137}, {"referenceID": 30, "context": "We can however just choose the simple greedy ordering in one stage, to get a slightly worse approximation factor of 1\u2212 e\u22121/2 [18, 31, 24].", "startOffset": 125, "endOffset": 137}, {"referenceID": 23, "context": "We can however just choose the simple greedy ordering in one stage, to get a slightly worse approximation factor of 1\u2212 e\u22121/2 [18, 31, 24].", "startOffset": 125, "endOffset": 137}, {"referenceID": 17, "context": "[18] Choosing the surrogate function f\u0302 as f and \u011d as h in Algorithm 1 yields a set X:", "startOffset": 0, "endOffset": 4}, {"referenceID": 2, "context": "The proof of this result follows directly from [3, 18].", "startOffset": 47, "endOffset": 54}, {"referenceID": 17, "context": "The proof of this result follows directly from [3, 18].", "startOffset": 47, "endOffset": 54}, {"referenceID": 2, "context": "In particular it holds for maximizing a submodular function g over any down monotone constraint [3].", "startOffset": 96, "endOffset": 99}, {"referenceID": 25, "context": "SCSC is in fact more general and can be extended to more flexible and complicated constraints which can arise naturally in many applications [26, 13].", "startOffset": 141, "endOffset": 149}, {"referenceID": 12, "context": "SCSC is in fact more general and can be extended to more flexible and complicated constraints which can arise naturally in many applications [26, 13].", "startOffset": 141, "endOffset": 149}, {"referenceID": 25, "context": "when g(X) = g1(X) + g2(X) [26].", "startOffset": 26, "endOffset": 30}, {"referenceID": 12, "context": "These also have a nice equivalence: {g1(X) = g1(V ) \u2228 g2(X) = g2(V )} \u21d4 {g(X) = g(V )} (32) by defining g(X) = g1(X)g2(V ) + g2(X)g1(V )\u2212 g1(X)g2(X) [13].", "startOffset": 149, "endOffset": 153}, {"referenceID": 25, "context": "Although g(X) in this case is not submodular, this scenario occurs naturally in many applications, particularly sensor placement [26].", "startOffset": 129, "endOffset": 133}, {"referenceID": 25, "context": "The problem in [26] is in fact a special case of Problem 2, using a modular function f .", "startOffset": 15, "endOffset": 19}, {"referenceID": 27, "context": "Surprisingly this problem also has a constant factor (1 \u2212 1/e) approximation guarantee [28].", "startOffset": 87, "endOffset": 91}, {"referenceID": 6, "context": "In particular, recall that the submodular knapsack has constant factor approximation guarantees even when g is non-monotone submodular [7].", "startOffset": 135, "endOffset": 138}, {"referenceID": 10, "context": "We prove this result using the hardness construction from [11, 43].", "startOffset": 58, "endOffset": 66}, {"referenceID": 42, "context": "We prove this result using the hardness construction from [11, 43].", "startOffset": 58, "endOffset": 66}, {"referenceID": 42, "context": "A Chernoff bound analysis very similar to [43] reveals that any algorithm that uses a polynomial number of queries can distinguish h and f R with probability only n \u2212\u03c9(1), and therefore cannot reliably distinguish the functions with a polynomial number of queries.", "startOffset": 42, "endOffset": 46}, {"referenceID": 29, "context": "We are motivated by the speech data subset selection application [30, 33, 21] with the submodular function f encouraging limited vocabulary while g tries to achieve acoustic variability.", "startOffset": 65, "endOffset": 77}, {"referenceID": 32, "context": "We are motivated by the speech data subset selection application [30, 33, 21] with the submodular function f encouraging limited vocabulary while g tries to achieve acoustic variability.", "startOffset": 65, "endOffset": 77}, {"referenceID": 20, "context": "We are motivated by the speech data subset selection application [30, 33, 21] with the submodular function f encouraging limited vocabulary while g tries to achieve acoustic variability.", "startOffset": 65, "endOffset": 77}, {"referenceID": 32, "context": "A natural choice of the function f is a function of the form |\u0393(X)|, where \u0393(X) is the neighborhood function on a bipartite graph constructed between the utterances and the words [33].", "startOffset": 179, "endOffset": 183}, {"referenceID": 8, "context": "Both these functions are defined in terms of a similarity matrix S = {sij}i,j\u2208V , which we define on the TIMIT corpus [9], using the string kernel metric [41] for similarity.", "startOffset": 118, "endOffset": 121}, {"referenceID": 40, "context": "Both these functions are defined in terms of a similarity matrix S = {sij}i,j\u2208V , which we define on the TIMIT corpus [9], using the string kernel metric [41] for similarity.", "startOffset": 154, "endOffset": 158}, {"referenceID": 7, "context": "For example, [8] investigates an exact algorithm for solving problem 1, with equality instead of inequality.", "startOffset": 13, "endOffset": 16}, {"referenceID": 35, "context": "However, since problem 1 subsumes the problem of minimizing a monotone submodular function subject to a cardinality equality constraint, and is hence NP hard [36].", "startOffset": 158, "endOffset": 162}, {"referenceID": 24, "context": "Furthermore, a similar problem was considered in [25] with one specific instance of a function f , which is not submodular.", "startOffset": 49, "endOffset": 53}, {"referenceID": 45, "context": "Also, an algorithm equivalent to the first iteration of ISSC was proposed in [46, 5] and ISSC not only generalizes this, but we also provide a more explicit approximation guarantee (we provide an elaborate discussion on this in the section describing ISSC).", "startOffset": 77, "endOffset": 84}, {"referenceID": 4, "context": "Also, an algorithm equivalent to the first iteration of ISSC was proposed in [46, 5] and ISSC not only generalizes this, but we also provide a more explicit approximation guarantee (we provide an elaborate discussion on this in the section describing ISSC).", "startOffset": 77, "endOffset": 84}, {"referenceID": 28, "context": "We also point out that, a special case of SCSK was considered in [29], with f being submodular, and g modular (we called this the submodular span problem).", "startOffset": 65, "endOffset": 69}, {"referenceID": 42, "context": "The authors there use an algorithm very similar to Algorithm 2, to convert this problem into an instance of minimizing a submodular function subject to a knapsack constraint, for which they use the algorithm of [43].", "startOffset": 211, "endOffset": 215}, {"referenceID": 42, "context": "Unfortunately, the algorithm of [43] does not scale very well.", "startOffset": 32, "endOffset": 36}, {"referenceID": 13, "context": "Similarly, a number of approximation algorithms have been shown for Problem 0 [14, 37, 22].", "startOffset": 78, "endOffset": 90}, {"referenceID": 36, "context": "Similarly, a number of approximation algorithms have been shown for Problem 0 [14, 37, 22].", "startOffset": 78, "endOffset": 90}, {"referenceID": 21, "context": "Similarly, a number of approximation algorithms have been shown for Problem 0 [14, 37, 22].", "startOffset": 78, "endOffset": 90}, {"referenceID": 13, "context": "The algorithms in [14, 37] are scalable and practical, but lack theoretical guarantees.", "startOffset": 18, "endOffset": 26}, {"referenceID": 36, "context": "The algorithms in [14, 37] are scalable and practical, but lack theoretical guarantees.", "startOffset": 18, "endOffset": 26}, {"referenceID": 21, "context": "The algorithm of [22] though exact, employs a branch and bound technique which is often inefficient in practice (the timing analysis from [22] also depicts that).", "startOffset": 17, "endOffset": 21}, {"referenceID": 21, "context": "The algorithm of [22] though exact, employs a branch and bound technique which is often inefficient in practice (the timing analysis from [22] also depicts that).", "startOffset": 138, "endOffset": 142}], "year": 2013, "abstractText": "We investigate two new optimization problems \u2014 minimizing a submodular function subject to a submodular lower bound constraint (submodular cover) and maximizing a submodular function subject to a submodular upper bound constraint (submodular knapsack). We are motivated by a number of real-world applications in machine learning including sensor placement and data subset selection, which require maximizing a certain submodular function (like coverage or diversity) while simultaneously minimizing another (like cooperative cost). These problems are often posed as minimizing the difference between submodular functions [14, 37] which is in the worst case inapproximable. We show, however, that by phrasing these problems as constrained optimization, which is more natural for many applications, we achieve a number of bounded approximation guarantees. We also show that both these problems are closely related and an approximation algorithm solving one can be used to obtain an approximation guarantee for the other. We provide hardness results for both problems thus showing that our approximation factors are tight up to log-factors. Finally, we empirically demonstrate the performance and good scalability properties of our algorithms.", "creator": "LaTeX with hyperref package"}}}