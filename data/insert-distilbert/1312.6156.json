{"id": "1312.6156", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Dec-2013", "title": "Negation in the Head of CP-logic Rules", "abstract": "cp - logic is a probabilistic extension of the logic fo ( id ). unlike both asp, both of these logics adhere to principally a tarskian informal semantics, in which interpretations represent objective states - of - affairs. in other words, these logics lack the epistemic component philosophy of asp, in which interpretations represent the beliefs or knowledge of finding a rational agent. consequently, neither their cp - logic nor fo ( id ) shall have the need for two narrower kinds of negations : there existed is only one negation, and its meaning is that implication of objective falsehood. nevertheless, the formal semantics of this objective negation is mathematically more similar to asp's negation - as - failure than to its classical negation. the reason is that both cp - logic and fo ( id ) have a constructive semantics in which all atoms start out as statements false, and may only become true as the result of a rule application. this paper investigates the possibility of adding the well - known asp feature of allowing negation in the head of rules to cp - logic. because cp - logic only has one kind of negation, it is of necessity this'' negation - as - failure like'' negation that will be allowed in the head. we investigate the intuitive meaning of such a construct and the benefits that arise from it.", "histories": [["v1", "Fri, 20 Dec 2013 21:41:20 GMT  (22kb,D)", "http://arxiv.org/abs/1312.6156v1", "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey"]], "COMMENTS": "Proceedings of Answer Set Programming and Other Computing Paradigms (ASPOCP 2013), 6th International Workshop, August 25, 2013, Istanbul, Turkey", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["joost vennekens"], "accepted": false, "id": "1312.6156"}, "pdf": {"name": "1312.6156.pdf", "metadata": {"source": "CRF", "title": "Negation in the Head of CP-logic Rules", "authors": ["Joost Vennekens"], "emails": ["joost.vennekens@cs.kuleuven.be"], "sections": [{"heading": "1 Introduction", "text": "This paper is part of a long-term research project that aims to develop a Tarskian view on Answer Set Programming (ASP). Historically, the origins of ASP lie in the seminal papers by Gelfond and Lifschitz on the stable semantics for normal (1988) and extended logic programs (1991). These papers develop an epistemic view on logic programs, in which an answer set is seen as an exhaustive enumeration of a rational agent\u2019s atomic beliefs. In this view, an atom A belonging to an answer set X means that the agent believes A; A 6\u2208 X means that A is not believed; and \u00acA \u2208 X means that a is believed to be false. A rule such as:\nA\u2190 B1, . . . , Bn, not C1, . . . , not Cm. (1)\ntells the agent that if he believes all of the Bi and does not believe any of the Cj , he should believe A. In addition, the agent also obeys the rationality principle, believing only what he has reason to believe. The stable model semantics then computes what a perfectly rational agent would believe under all these rules.\nWhile these epistemic intuitions have played a crucial role in the history of ASP, current practice seems to have largely drifted away from them. In particular,\nar X\niv :1\n31 2.\n61 56\nv1 [\ncs .A\nI] 2\n0 D\nec 2\n01 3\nprograms written according to the currently prevalent Generate-Define-Testmethodology (GDT) (term coined by Lifschitz, 2002) are typically no longer explicitly concerned with the beliefs of an agent. A typical example is the graph colouring problem, in which we generate the search space of all assignments of colours to nodes, we define that two nodes are in conflict if they share an edge and have the same colour, and then test that there are no conflicts. Unlike early ASP examples\u2014such as, e.g., Gelfond\u2019s example (1991) of interviewing all students for which we do not know whether they are eligible for a grant\u2014the statement of the graph colouring problems is not concerned with anyone\u2019s knowledge or beliefs, but only with the objective colour of the nodes.\nSuppose now that we have an ASP representation of a purely objective GDT problem, such as graph coloring. How should we intuitively interpret this program? Falling back on the papers by Gelfond and Lifschitz, every single statement in the program will be interpreted as an epistemic statement about some agent\u2019s knowledge. Obviously, this is a poor match with the objective intuitions behind the problem. Therefore, an alternative informal semantics is needed, which omits this agent, and explains how rules of the program can be interpreted as statements about the real world, in this same way as formulas in classical first-order logic (FO) are. There are now two important and related questions:\n\u2013 If we view a semantical object such as an answer set as a representation of an objective state of the world, instead of some agent\u2019s beliefs, how should we then interpret a rule such as (1)? \u2013 How does this objective interpretation of ASP compare to the classical way of representing such objective information about the world, namely FO?\nAn extensive study of these two questions has been performed by Denecker and several coauthors. Recent summaries of these results were published by Denecker et al. (2010) and Denecker et al. (2012). A goal of this research program is to reconstruct ASP as a series of conservative extensions of FO. One of its main achievements has been the development of the language of FO(ID) (Denecker and Ternovska, 2007), which extends FO with a construct for representing inductive definitions. FO(ID) can be seen as a variant of ASP, which adheres to a strict objective interpretation of its semantical constructs, i.e., a model of an FO(ID) theory does not represent beliefs, but an objective state of the world.\nThe language of FO(ID) has been further extended in many ways. This paper is concerned with one particular such extension, namely, CP-logic (Vennekens et al., 2009), which extends the inductive definition construct of FO(ID) with a means for expressing non-deterministic choice. One application is to represent non-deterministic inductive definitions. For instance, an execution trace of a non-deterministic Turing machine may be defined by means of a rule that states that if the machine reads a character c in a state s at time \u03b1, it will be in a state s\u2032 at time \u03b1 + 1, where s\u2032 is one of the states that it may transition to from (s, c). CP-logic represents such non-determinism by allowing disjunction in the head of rules. This is similar in syntax to the kind of rules allowed by, for instance, the DLV language. This is, therefore, another way in which one of ASP\u2019s features can be conservatively added to the classical framework. However,\nto correctly formalise non-deterministic inductive definitions, not the minimal model semantics must be used, but the possible world semantics of Sakama and Inoue (1994).\nA more important application of CP-logic, however, is to represent probabilistic causal laws. Such relations have received a great deal of attention in the AI community, especially since the influential work by Pearl (2000) on this topic. As shown by Vennekens et al. (2010), CP-logic can actually be seen as a refinement of Pearl\u2019s theory, which allows for a more compact and modular representation of certain phenomena. As an example, consider three gear wheels, each of which has an attached crank that can be used to turn it. The first gear wheel is connected to the second, which is in turn connected to the third, so that in 90% of the cases, when one turns the other also turns; however, there is some damage to the gear wheels\u2019 teeth, which in 10% of the cases prevents this. In CP-logic, we can represent this by means of seven independent probabilistic causal laws:\nTurns(Gear1)\u2190 Crank1. (2) Turns(Gear2)\u2190 Crank2. (3) Turns(Gear3)\u2190 Crank3. (4)\n(Turns(Gear1) : 0.9)\u2190 Turns(Gear2). (5) (Turns(Gear2) : 0.9)\u2190 Turns(Gear1). (6) (Turns(Gear2) : 0.9)\u2190 Turns(Gear3). (7) (Turns(Gear3) : 0.9)\u2190 Turns(Gear2). (8)\nBy contrast, Pearl would represent it in a less modular way, by means of three structural equations, each of which defines precisely when a particular gear wheel will turn :\nTurns(Gear1) := Crank1 \u2228 (Crank2 \u2227 Trans1,2) \u2228 (Crank3 \u2227 Trans3,2 \u2227 Trans2,1) Turns(Gear2) := Crank2 \u2228 (Crank1 \u2227 Trans1,2) \u2228 (Crank3 \u2227 Trans3,2) Turns(Gear3) := Crank3 \u2228 (Crank2 \u2227 Trans2,3) \u2228 (Crank1 \u2227 Trans1,2 \u2227 Trans2,3)\nCP-logic has certain similarities to P-log, a probabilistic extension of ASP (Baral et al., 2008). However, it differs by its focus on representing individual probabilistic causal laws, as discussed by Vennekens et al. (2010, 2009).\nAs this example illustrates, a causal law in CP-logic may cause some atom(s) to become true, and it may also fail to do so. What is currently not possible, however, is that such a laws causes an atom to be false. For instance, suppose that the first gear wheel may be locked, in order to prevent it from turning. The current way to represent this would be to replace rules (2) and (5) by:\n(Turns(Gear1) : 0.9)\u2190 Crank1 \u2227 \u00acLocked(1). (Turns(Gear1) : 0.9)\u2190 Turns(Gear2) \u2227 \u00acLocked(1).\nHowever, this goes against our desire for a modular representation of the individual causal laws. Our goal in the current paper is to extend CP-logic to allow instead\nto keep rules (2) and (5) as they are, and instead add a rule:\n\u00acTurns(Gear1)\u2190 Locked(1).\nIn other words, we will examine how CP-logic can be extended with the familiar ASP feature of negation in the head Gelfond and Lifschitz (1991). Again, the traditional ASP interpretation of a classical negation literal is rooted in the epistemic tradition: whereas not A means that A is not believed to be true, a classical negation literal \u00acA means that A is believed to be false. Since FO(ID) and CP-logic have no beliefs, the only thing that negation can mean in this context is that A is objectively false. Nevertheless, as this paper will show, there is still a place for negation-in-the-head in such a logic. Our two main contributions are therefore as follows:\n\u2013 By adding this additional feature to CP-logic, we extend its ability to represent causal laws in a modular way, as illustrated by the above example. \u2013 From the point of view of the larger research project, negation-in-the-head is an ASP feature that, until now, could not yet be given a place within the FO(ID)/CP-logic framework and its Tarskian semantics. This paper offers one way in which this gap can be filled.\nThis paper is structured as follows. First, Section 2 recalls the definition of CP-logic. Section 2.1 elaborates further on the role of negation in the current version of CP-logic, before Section 3 then discusses our proposed extension with negation in the head. Several uses of this new feature are then discussed in Sections 4 to 6. Finally, Section 7 discusses the implementation of this new language feature."}, {"heading": "2 Preliminaries: CP-logic", "text": "A theory in CP-logic consists of a set of rules. These rules are called causal probabilistic laws, or CP-laws for short, and they are statements of the form:\n\u2200x (A1 : \u03b11) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (An : \u03b1n)\u2190 \u03c6. (9)\nHere, \u03c6 is a first-order formula and the Ai are atoms, such that the tuple of variables x contains all free variables in \u03c6 and the Ai. The \u03b1i are non-zero probabilities with \u2211 \u03b1i \u2264 1. Such a CP-law expresses that \u03c6 causes some (implicit) non-deterministic event, of which each Ai is a possible outcome with probability \u03b1i. If \u2211 i \u03b1i = 1, then at least one of the possible effects Ai must result if the event caused by \u03c6 happens; otherwise, it is also possible that the event happens without any (visible) effect on the state of the world. For mathematical uniformity, we introduce the notation r= to refer to r itself if the equality holds, and otherwise to the CP-law:\n\u2200x (A1 : \u03b11) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (An : \u03b1n) \u2228 (\u2014 : 1\u2212 \u2211 i \u03b1i)\u2190 \u03c6.\nHere, the dash is a new symbol that explicitly represents the possibility that none of the effects Ai are caused. Whenever we add this dash to some set X, it does not change X, i.e., X \u222a {\u2014} = X.\nThe semantics of a theory in CP-logic is defined in terms of its grounding, so from now on we will restrict attention to ground theories, i.e., we assume that for each CP-law, the tuple of variables x is empty. For now, we also assume that the rule bodies \u03c6 do not contain negation.\nFor a CP-law r, we refer to \u03c6 as the body of r, and to the sequence (Ai, \u03b1i) n i=1 as the head of r. We denote these objects as body(r) and head(r), respectively. In CP-laws of form (9), the precondition \u03c6 may be omitted for events that are vacuously caused. If a CP-law has a deterministic effect, i.e., it is of the form (A : 1)\u2190 \u03c6, then we also write it simply as A\u2190 \u03c6.\nExample 1. Suzy and Billy might each decide to throw a rock at a bottle. If Suzy does so, her rock breaks the bottle with probability 0.8. Billy\u2019s aim is slightly worse and his rock only hits with probability 0.6. Assuming that Suzy decides to throw with probability 0.5 and that Billy always throws, this domain corresponds to the following set of causal laws:\n(Throws(Suzy) : 0.5). (10)\nThrows(Billy). (11)\n(Broken : 0.8)\u2190 Throws(Suzy). (12) (Broken : 0.6)\u2190 Throws(Billy). (13)\nIn causal modeling, a distinction is commonly made between endogenous properties, whose values are completely determined by the causal mechanisms described by the model, and exogenous properties, whose values are somehow determined outside the scope of the model. Following this convention, the predicates of a CP-theory are also divided into exogenous and endogenous predicates. We define the semantics of a theory in the presence of a given, fixed interpretation X for the exogenous predicates.\nA second common assumption (see e.g. Hall, 2007) is that each of the endogenous properties has some default value, which represents its \u201cnatural state\u201d. In other words, the default value of an endogenous property is the value that it has whenever there are no causal mechanisms acting upon it. The effect of the causal mechanisms in the model is then of course precisely to flip the value of some of the properties from its default to a deviant value.\nTheories in CP-logic have a straightforward execution semantics. We consider probability trees, in which each node is labeled with an Herbrand interpretation for the endogenous predicates. The root of the tree\u2014i.e., the initial state of our causal process\u2014is labeled with the universally false interpretation {}. This incorporates our second assumption: w.l.o.g. we force the user to choose his vocabulary in such a way that the default value for each endogenous atom is false. We then constructively extend the tree by applying the following operation as long as possible:\n1. Choose a pair (s, r) of a leaf s of the tree and a rule r of the theory, such that (X \u222aI(s)) |= body(r) and there exists no ancestor s\u2032 of s such that (s\u2032, r) has already been chosen\n2. Extend s with children s0, . . . , sm, where each si corresponds to one of the disjuncts (hi : \u03b1i) in head(r\n=), in the sense that I(si) = Is \u222a {hi} and the edge from s to si is labeled by \u03b1.\nWe call a tree T constructed in this way an execution model of the CP-theory under X. We define a probability distribution \u03c0T over the set of all Herbrand interpretations as: \u03c0T (I) = \u2211 I(l)=I \u03c0T (l), where the sum is taken over all leaves l of T whose interpretation equals I and the probability \u03c0T (l) of such a leaf consists of the product of all probability labels that are encountered on the path to this leaf.\nThe following picture represents an execution model for the CP-theory of Example 1. The states s in which the bottle is broken (i.e., for which Broken \u2208 I(s)) are represented by an empty circle, and those in which it is still whole by a full one. This pictures does not show the interpretations I(s); instead, we have just written the effects of each event in natural language as labels on the edges.\n\u2022\n0.5\nSuzy throws\nvv 0.5 doesn\u2019t throw\n(( \u2022\n0.8\nBottle breaks vv 0.2 doesn\u2019t break ((\n\u2022 1 Billy throws\n\u25e6\n1 Billy throws\n\u2022 1 Billy throws\n\u2022 0.6 Bottle breaks\n0.4 doens\u2019t break\n(( \u25e6\n0.6 Bottle breaks 0.4 doesn\u2019t break\n((\n\u2022 0.6 Bottle breaks\n0.4 doesn\u2019t break\n((\n\u25e6 \u2022\n\u25e6 \u25e6 \u25e6 \u2022\nThe third branch of this execution model consists of five nodes (s0, . . . , s4). The progression of the associated states of the world (I(s0), . . . , I(s4)) is as follows:\n({}, {Throws(Suzy)}, {Throws(Suzy)}, {Throws(Suzy), Throws(Billy)},\n{Throws(Suzy), Throws(Billy), Broken}).\nNote that, in keeping with the Tarskian setting of CP-logic, each interpretation represents an objective state of the world.\nEven when starting from the same interpretation X for the exogenous predicates, the same CP-theory may have many execution models, which differ in their selection of a rule to apply in each node (step 1). It was shown by Vennekens et al. (2009) that, because each applicable rule must eventually be applied, the differences between these execution models are irrelevant, as long as we only care about the final states that may be reached. In other words, all execution models T of the same CP-theory T that start from the same interpretation X generate the same distribution \u03c0T . We also denote this unique distribution as \u03c0 X T .\nAn interesting special case is that in which each rule r is deterministic, i.e., it causes a single atom with probability 1. In this case, each execution model is a degenerate tree consisting of a single branch, in which all edges are labeled with probability 1. The successive interpretations in this branch are constructed by adding to the previous interpretation the head of a rule whose body is satisfied. The single leaf of this tree is therefore precisely the least Herbrand model of the set of rules. In this way, positive logic programs and monotone inductive definitions in FO(ID) are embedded in CP-logic."}, {"heading": "2.1 Negation in CP-logic", "text": "Consider again the role that the CP-law\n(Broken : 0.9)\u2190 Throws(Suzy)\nplays in the above execution model. Initially, when the atom Throws(Suzy) is still at its default, this law is dormant. Once Throws(Suzy) has been caused, this law becomes active and will (eventually) be executed, causing Broken with probability 0.9. Now, suppose we had instead assumed that the default is for Suzy to throw unless she decides to refuse:\n(Broken : 0.9)\u2190 \u00acRefusesThrow(Suzy). (RefusesThrow(Suzy) : 0.5).\nUnder the semantics given so far, this first CP-law would be active in any state where RefusesThrow(Suzy) has not deviated from its default. For instance, this law would always be active in the initial state. This means that there would be an execution model in which this law first causes the bottle to break and then, afterwards, Suzy decides to refuse the throw. Such execution models are not very meaningful, or useful.\nFor this reason, when allowing negation, an additional condition is imposed on the execution models of a CP-theory. The basic idea is to read \u00acA not simply as \u201cA is currently at its default vaue\u201d, but instead as \u201cA will not deviate from its default\u201d. Under this interpretation, the law will only become active once our causal process is far enough along to be able to say with certainty that no deviation will occur. For the above example, this would mean that the first CP-law can only become active after the second one has taken place and has failed to cause RefusesThrow(Suzy).\nThis idea is formalized by means of concepts from three-valued logic, where atoms can be unknown (u) in addition to true (t) or false (f). Given a three-valued interpretation \u03bd, that assigns one of these three truth values to each atom, the standard Kleene truth tables can be used to assign a corresponding truth value \u03bd(\u03c6) to each formula \u03c6. A two-valued interpretation I is said to be approximated by a three-valued interpretation \u03bd if it can be constructed from it by switching atoms from u to t or f. If I is approximated by \u03bd, then for each formula \u03c6, the truth value \u03bd(\u03c6) also approximates the truth of \u03c6 according to I; that is, if \u03bd(\u03c6) = t then I |= \u03c6 and if \u03bd(\u03c6) = f then I 6|= \u03c6.\nNow, for each state s of an execution model, we construct an overestimate of the set of atoms that might still be caused in the part of the tree following s. First, the set of events that could potentially happen in this state itself is Pot(s) = {r \u2208 R(s) | I(s) |= body(r)}, where R(s) denotes the set of all rules that have not yet happened in the ancestors of s. For each child s\u2032 of s, I(s\u2032) will therefore differ from I(s) by including at most one atom A 6\u2208 I(s) from the head of one of the rules r \u2208 Pot(s). Therefore, if we construct a three-valued interpretation \u03bd0 that labels all such atoms A as u and coincides with I(s) on all other atoms, then we end up with an approximation of each I(s\u2032) for which s\u2032 is a child of s. Now, if an event r is to happen in one of these children s\u2032 of s, then it must be the case that that I(s\u2032) |= body(r), which implies that \u03bd1(body(r)) 6= f. We now derive a \u03bd2 from \u03bd1 by turning into u all atoms A for which \u03bd1(A) = f and A appears in the head of an r for which \u03bd0(body(r)) 6= f. This \u03bd2 is then an approximation of all I(s\u2032\u2032) for which s\u2032\u2032 is a grandchild of s. We can now iterate this principle and construct a sequence (\u03bd1, \u03bd2, . . .) of three-valued interpretations, where each \u03bdi approximates all the I(t) for which t is a descendant of s, separated from s by at most i\u2212 1 intermediary nodes. This process will make more and more atoms u, until eventually it reaches a fixpoint, which we denote as U(s). This fixpoint approximates all the I(t) for which t is a descendant of s. Therefore, if an atom is f in U(s), then it will not be caused anywhere below s.\nTo illustrate, consider the rightmost branch (s\u20320, s \u2032 1, . . . , s \u2032 3) of the execution model shown in Section 2. The associated three-valued interpretations are as follows, where we abbreviate Throws and Broken by T and B, and Billy and Suzy by By and Sy.\nNode s U(s) t u f\ns\u20320 {} {T (Sy), T (By), B} {} s\u20321 {} {T (By), B} {T (Sy)} s\u20322 {T (By)} {B} {T (Sy)} s\u20323 {T (By)} {} {T (Sy), B}\nThe following additional condition is now imposed on the execution models of a CP-theory:\nFor a rule r to be allowed to happen in a node s, it is not enough that simply I(s) |= body(r); in addition, it must also be the case that the truth value of body(r) according to U(s) is t instead of u.\nTherefore, if the CP-theory of the above example contained an additional rule with body \u00acThrows(Suzy), this could be applied from state s\u20321 onwards in the above branch, whereas a rule with body \u00acBroken would have to wait until s\u20323.\nWith this additional condition, it now becomes possible for execution models to become stuck, in that sense that, in some leaf l, there remain some rules r such that I(l) |= body(r), yet r cannot happen because body(r) is u in U(s). This can happen only when the CP-theory contains loops over negation. Such theories\nare viewed as unsound, and no semantics is defined for them. An important class of sound theories are those which are stratified, but there also exist useful sound theories outside of this class (see Vennekens et al. (2009) for a discussion).\nAgain, an interesting special case is when all rules of the CP-theory are deterministic. In this case, the CP-theory syntactically coincides with a normal logic program, and all of its execution models end in a single leaf l, such that U(l) is the well-founded model of this program. If the CP-theory is sound, U(l) = I(l) is the two-valued well-founded model and therefore also the unique stable model of the program. In this way, normal logic programs with a two-valued wellfounded model are embedded in CP-logic. While the limitation to two-valued well-founded models may seem restrictive, in practice this is often mitigated by the fact predicates may be declared as exogenous, which has the same effect as \u201copening them up\u201d with a loop over negation. Also in FO(ID), definitions whose well-founded model is not two-valued are considered inconsistent, so CP-logic is indeed a true generalization of FO(ID)\u2019s inductive definition construct."}, {"heading": "3 Negation in the head", "text": "A CP-theory represents a set of causal mechanisms, that are activated one after the other, and together construct the final state of the domain. Each such causal mechanism has the same kind of effect: for some set of atoms, it causes at most one of these atoms to deviate from their default value f to the deviant value t. If multiple causal mechanisms affect the same atom, the result is simple: there are no additive effects and the outcome is simply that the atom is t if and only if at least one mechanism causes it. If subsequent rules end up \u201ccausing\u201d an effect that is already t, then this changes absolutely nothing.\nIt is to this setting that we now want to add negation-in-the-head. We will call such a negated literal in the head a negative effect literal. To be more precise, from now on, we allow rules of the form:\n\u2200x (L1 : \u03b11) \u2228 \u00b7 \u00b7 \u00b7 \u2228 (Ln : \u03b1n)\u2190 \u03c6.\nHere, \u03c6 is again a first-order logic formula with x as free variables and the \u03b1i \u2208 [0, 1] are again such that \u03a3\u03b1i \u2264 1. Each of the Li is now either a positive effect literal A (i.e., an atom) or a negative effect literal \u00acA.\nWhile the goal of this extension is of course to be able to represent such phenomena as the locking of the gear wheel described in the introduction, let us first take a step back and consider, in the abstract, which possible meanings this construct could reasonably have. Clearly, if for some atom A only positive effect literals are caused, the atom should end up being true, just as it always has. Similarly, if only negative effect literals \u00acA are caused, the atom A should be false. However, this does not even depend on the negative effect literals being present: because false is the default value in CP-logic, an atom will already be false whenever there are no positive effect literals for it, even if there are no negative effect literals either.\nThe only question, therefore, is what should happen if, for some A, both a positive and a negative effect literal are caused. One alternative could be that the result would somehow depend on the relative strength of the negative and positive effects, e.g., whether the power of aspirin to prevent a fever is \u201cstronger\u201d than the power of flu to cause it. However, such a semantics would be a considerable departure from the original version of CP-logic, in which cumulative effects are strictly ignored. In other words, CP-logic currently makes no distinction whatsoever between a headache that is simultaneously caused by five different conditions and a headache that has just a single cause. This design decision was made to avoid a logic that, in addition to probabilities, would also need to keep track of the degree to which a property holds. A logic combining probabilities with such fuzzy truth degrees would, in our opinion, become quite complex and hard to understand.\nIn this paper, we want to preserve the relative simplicity of CP-logic, and we will therefore again choose not to work with degrees of truth. Therefore, only two options remain: when both effect literals A and \u00acA are caused, the end result must be that A is either true of false. This basically means that, in the presence of both kinds of effect literals, we will have to choose to ignore one kind. It is obvious what this choice should be: the negative effect literals already have no impact on the semantics when there are only positive effect literals or when there are no positive effect literals, so if they would also have no impact when positive and negative effect literals are both present, then they would have never have any impact at all and we would have introduced a completely superfluous language construct. Therefore, the only reasonable choice is to give negative effect literals precedence over positive ones, that is, an atom A will be true if and only if it is caused at least once and no negative effect literal \u00acA is caused.\nThis can be formally defined by a minor change to the existing semantics of CP-logic. Recall that, in the current semantics, each node s of an execution model has an associated interpretation I(s), representing the current state of the world, and an associated three-valued interpretation U(s), representing an overestimate of all that could still be caused in s. We now add to this a third set, namely a set of atoms N (s), containing all atoms for which a negative effect literal has already been caused. The sets I(s) and N (s) evolve throughout an execution model as follows:\n\u2013 In the root of the tree, I(s) = N (s) = {} \u2013 When a negative effect literal \u00acA is caused in a node s, the execution model\nadds a child s\u2032 to s such that: \u2022 N (s\u2032) = N (s) \u222a {A}; \u2022 I(s\u2032) = I(s) \\ {A}.\n\u2013 When a positive effect literal A is caused in a node s, the execution model adds a child s\u2032 to s such that: \u2022 N (s\u2032) = N (s); \u2022 if A \u2208 N (s), then I(s\u2032) = I(s), else I(s\u2032) = I(s) \u222a {A}.\nNote that, throughout the execution model, we maintain the property that N (s) \u2229 I(s) = {}.\nThe overestimate U(s) is again constructed as the limit of a sequence of threevalued interpretations \u03bdi. To go from such a \u03bdi to \u03bdi+1, we make \u03bdi+1(A) = u for all atoms A satisfying both of the following conditions:\n\u2013 as before, \u03bdi(A) = f and the positive effect literal A appears in the head of a rule r \u2208 R(s) with \u03bdi(body(r)) 6= f;\n\u2013 but now also A 6\u2208 N (s). In this way, U(s) always assigns t to all atoms in I(s) and f to all those in N (s)."}, {"heading": "4 Encoding interventions", "text": "One of the interesting uses of negation-in-the-head is related to the concept of interventions, introduced by Pearl (2000). Let us briefly recall this notion. Pearl works in the context of structural models. Such a model is built from a number of random variables. For simplicity, we only consider boolean variables, i.e., atoms. These are again divided into exogenous and endogenous atoms. A structural model now consists of one equation X := \u03d5 for each endogenous atom X, which defines that X is true if and only if the boolean formula \u03d5 holds. This set of equations should be acyclic (i.e., if we order the variables by defining that X < Y if X appears in the equation defining Y , then this < should be a strict order), in order to ensure that an assignment of values to the exogenous atoms induces a unique assignment of values to the endogenous ones.\nA crucial property of causal models is that they can not only be used to predicts the normal behaviour of a system, but also to predict what would happen if outside factors unexpectedly intervene with its normal operation. For instance, consider the following simple model of which students must repeat a class:\nFail := \u00acSmart \u2227 \u00acEffort. Repeat := Fail \u2227Required.\nUnder the normal operation of this \u201csystem\u201d, only students who are not smart can fail classes and be forced to repeat them. Suppose now that we catch a student cheating on an assignment and decide to fail him for the class. This action was not foreseen by the causal model, so it does not follow from the normal behaviour. In particular, failing the student may cause him to have to repeat the class, but if the student is actually smart, then failing him will not make him stupid. Pearl shows that we can model our action of failing the student by means of an intervention, denoted do(Fail = t). This is a simple syntactic transformation, which removes and replaces the original equation for Fail:\nFail := t. Repeat := Fail \u2227Required.\nAccording to this updates set of equations, the student fails and may have to repeat the class, but he has not been made less smart.\nIn the context of CP-logic, let us consider the following simple medical theory:\n(HighBloodPressure : 0.6)\u2190 BadLifeStyle. (14) (HighBloodPressure : 0.9)\u2190 Genetics. (15)\n(Fatigue : 0.3)\u2190 HighBloodPressure. (16)\nHere, BadLifeStyle and Genetics are two exogenous predicates, which are both possible causes for HighBloodPressure. Suppose now that we observe a patient who suffers from Fatigue. Given our limited theory, this patient must be suffering from HighBloodPressure, caused by at least one of its two possible causes.\nNow, suppose that a doctor is wondering whether it is a good idea to prescribe this patient some pills that cure high blood pressure. Again, the proper way to answer such a question is by means of an intervention, that first prevents the causal mechanisms that normally determine someone\u2019s blood pressure and then substitutes a new \u201cmechanism\u201d that just makes HighBloodPressure false. This can be achieved by simply removing the two rules (14) and (15) from the theory. This is an instance of a general method, developed by Vennekens et al. (2010), of performing Pearl-style interventions in CP-logic. The result is that probability of Fatigue drops to zero, i.e., P (Fatigue | do(\u00acHighBloodPressure)) = 0.\nIn this way, we can evaluate the effect of prescribing the pills without actually having these pills in our model. This is a substantial difference to the way in which reasoning about actions is typically done in the field of knowledge representation, where formalisms such as situation or event calculus require an explicit enumeration of all available actions and their effects. Using an intervention, by contrast, we can envisage the effects of actions that we never even considered when writing our model.\nEventually, however, we may want to transform the above descriptive theory into a prescriptive one that tells doctors how to best treat a patient, given his or her symptoms. In this case, we would need rules such as this:\nBPMedicine\u2190 Fatigue. (17)\nObviously, this requires us to introduce the action BPMedicine of prescribing the medicine, which previously was implicit in our intervention, as an explicit action in our vocabulary. Negation-in-the-head allows us to syntactically express the effect of this new action: \u00acHighBloodPressure\u2190 BPMedicine.\nThis transformation can be applied in general, as the following theorem shows.\nTheorem 1. Let T be a CP-theory over a propositional vocabulary \u03a3. For an atom A \u2208 \u03a3, let T \u2032 be the theory T \u222a {r} with r the rule \u00acA \u2190 B and B an exogenous atom not in \u03a3. For each interpretation X for the exogenous atoms of T \u2032, if B \u2208 X, then \u03c0XT \u2032 = \u03c0Xdo(T,\u00acA) and if B 6\u2208 X, then \u03c0 X T \u2032 = \u03c0 X T .\nThis theorem shows that negation-in-the-head allows CP-theories to \u201cinternalize\u201d the intervention of doing \u00acA. The result is a theory T \u2032 in which the intervention can be switched on or off by simply choosing the appropriate interpretation for the exogenous predicate that now explicitly represents this intervention. Once the intervention has been syntactically added to the theory in this way, additional rules such as (17) may of course be added to turn it from an exogenous to an endogenous property.\nIt is important to note that this is a fully modular and elaboration tolerant encoding of the intervention, i.e., the original CP-theory is left untouched and the rules that describe the effect of the intervention-turned-action are simply added to it. This is something that we can only achieve using negation-in-the-head."}, {"heading": "5 Representing defaults", "text": "An interesting test case for logic programs has always been the representation of defaults. The typical example concerns the default \u03b4 = Bird(x) : Flies(x) Flies(x) together with the background knowledge: \u2200x Penguin(x) \u21d2 \u00acFlies(x). In an extended logic program, the two kinds of negation can be exploited to represent the default in an elegant way:\nFlies(x)\u2190 Bird(x) \u2227 not \u00acFlies(x). \u00acFlies(x)\u2190 Penguin(x).\nIn a normal logic program or deterministic CP-theory, defaults are typically represented using an abnormality predicate.\nFlies(x)\u2190 Bird(x) \u2227 \u00acAb\u03b4(x). Ab\u03b4(x)\u2190 Penguin(x).\nUsing CP-logic\u2019s new negation-in-the-head, the abnormality predicate can be omitted.\nFlies(x)\u2190 Bird(x). (18) \u00acFlies(x)\u2190 Penguin(x). (19)\nHowever, we do now lose the ability to distinguish between defeasible and nondefeasible rules, since negative effect literals can always be added to block any effect. In fact, this is necessary because of our desire to use negation-in-the-head to syntactically represent interventions (Section 4). It is after all a key property of Pearl\u2019s interventions that any causal relation in the model should, in principle, be open to intervention.\nEven though, as this section shows, it is possible to use CP-logic to represent certain defaults, it is important to remember that it is not intended as a default logic. In particular, rule (18) should not actually be read as saying that birds normally fly. Instead, it says that, for each x, x being a bird causes it to be able to fly. Similarly, rule (19) says that being a penguin is a cause for being unable to fly. Note also that this is not a generally applicable methodology for representing defaults. For instance, if we wanted to state that penguins with jetpacks are an exception to rule (19), we would still have to introduce an abnormality predicate."}, {"heading": "6 Probabilities and defaults", "text": "An interesting consequence of adding negation-in-the-head to CP-logic is that we can combine the encoding of defaults as in the previous section with uncertainty. For instance, let us suppose that there is, in general, a 5% change with which being a bird does not cause one to be able to fly. This may be the result, for instance, of a birth defect or some accident. This could be represented as follows:\n(Flies(x) : 0.95)\u2190 Bird(x). (20) \u00acFlies(x)\u2190 Penguin(x). (21)\nThe first rule describes the normal situation for birds, whereas the second rule still serves to give an exception to the general rule. Note that, even for penguins, the causal mechanism underlying the first rule still happens, i.e., the rule is still fired, but it just fails to produce the outcomes of flying. Intuitively, we can think of this as the penguins still being born and being raised by their parents\u2014i.e., they go through the same process of growing up that any bird goes through. It is just that, whereas this process causes the ability to fly for 95% of the normal birds, it never has this outcome for penguins. Of course, since learning to fly is actually the only possible effect of the first rule, the fact that this rule is still fired for penguins has no effect on anything.\nThe following example shows that this is not always the case.\n(Wound(x) : 0.7) \u2228 (HoleInWall : 0.3)\u2190 Shoot(x). (22) \u00acWound(x)\u2190 Superhero(x). (23)\nHere, this first rule states that shooting a gun at someone might produce two possible effects: either the person ends up being wounded or the shot misses and causes instead a hole in the wall. The second rule adds an exception: if x happens to be a superhero, then x cannot be wounded. So, firing a gun at a superhero never causes Wound(x), but with probability 0.3 still causes a hole in the wall.\nThis example also reveals a further way in which CP-logic is at heart a causal logic and not a logic of defaults. While we have so far been getting away with reading a rule such as (23) as expressing an exception to a default, this is not what it actually says: what this rule states is that being a superhero causes one to become \u201cunwoundable\u201d. This does not only apply to wounds that would be caused by rule (22), but to all wounds. Therefore, if the CP-theory were to contain other causes for wounds, such as (Wound(x) : 0.9) \u2190 FallFromBuilding(x), then superheroes are automatically also protected against these."}, {"heading": "7 Implementation", "text": "To implement the feature of negation-in-the-head, a simple transformation to regular CP-logic may be used. This transformation is based on the way in which Denecker and Ternovska (2007) encode causal ramifications in their inductive definition modelling of the situation calculus.\nFor a CP-theory T in vocabulary \u03a3, let \u03a3\u00ac consist of all atoms A for which a negative effect literal \u00acA appears in T . For each atom A \u2208 \u03a3\u00ac, we introduce two new atoms, CA and C\u00acA. Intuitively, CA means that there is a cause for A, and C\u00acA means that there is a cause for \u00acA. Let \u03c4A be the following transformation:\n\u2013 Replace all positive effect literals A in the heads of rules by CA \u2013 Replace all negative effect literals \u00acA in the heads of rules by C\u00acA \u2013 Add this rule: A\u2190 CA \u2227 \u00acC\u00acA\nLet \u03c4\u00ac(T ) denote the result of applying to T , in any order, all the transformations \u03c4A for which A \u2208 \u03a3\u00ac. It is clear that \u03c4\u00ac(T ) is a regular CP-theory, i.e., one\nwithout negation-in-the-head. As the following theorem shows, this reduction preserves the semantics of the theory.\nTheorem 2. For each interpretation X for the exogenous predicates, the projection of \u03c0X\u03c4\u00ac(T ) onto the original vocabulary \u03a3 of T is equal to \u03c0 X T .\nWhen comparing the transformed theory \u03c0\u03c4\u00ac(T ) to the original theory T , we see that the main benefit of having negation-in-the-head lies in its elaboration tolerance: there is no need to know before-hand for which atoms we later might wish to add negative effect literals, since we can always add these later, without having to change to original rules. Both in the example of syntactically representing an intervention (Section 4) and that of representing exceptions to defaults (Section 5), this feature may be useful."}, {"heading": "8 Conclusion", "text": "This paper is part of a long-term research project which aims to develop a Tarskian alternative to ASP: instead of relying on ASP\u2019s original epistemic intuitions, our goal is to have a language in which every expression can be interpreted as an objective statement about the real world. The first motivation for this is simplicity: many problems that are solved using present-day ASP systems and the GDT-methodology do not have an inherent epistemic component, so it would just be simpler if we could understand such programs in terms of what they say about the real world directly, instead of having to make a detour through the beliefs of some (irrelevant) rational agent. A second motivation is the unity of science: a huge effort has gone into both theoretical and practical research on classical logic. Its roots in Non-monotonic Reasoning have made ASP an antithesis to the classical approach, in which the desire to express objective knowledge is abandoned in favor of epistemic knowledge. Even though applications of ASPsolvers and SAT-solvers are often quite similar in practice, the \u201cofficial\u201d reading of ASP programs and classical theories is therefore radically different. The second goal is to bridge this gap.\nAn important part of this research project was the development of the language FO(ID), which showed how normal logic programs could be interpreted as inductive definitions and added in a meaningful way to classical logic. An extension of this work was the development of the language CP-logic, which allows non-deterministic and probabilistic causal processes to be expressed. In this paper, we have investigated the useful ASP feature of negation-in-the-head. We presented a meaningful interpretation of this feature in the context of CP-logic and discussed possibles uses of it. Finally, we also showed a simple transformation that reduces it to regular CP-logic."}], "references": [{"title": "Probabilistic reasoning with answer sets. Theory and Practice of Logic Programming", "author": ["C. Baral", "M. Gelfond", "N. Rushton"], "venue": null, "citeRegEx": "Baral et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Baral et al\\.", "year": 2008}, {"title": "Inductive situation calculus", "author": ["M. Denecker", "E. Ternovska"], "venue": "Artificial Intelligence,", "citeRegEx": "Denecker and Ternovska.,? \\Q2007\\E", "shortCiteRegEx": "Denecker and Ternovska.", "year": 2007}, {"title": "Well-founded semantics and the algebraic theory of non-monotone inductive definitions", "author": ["M. Denecker", "J. Vennekens"], "venue": "In LPNMR,", "citeRegEx": "Denecker and Vennekens.,? \\Q2007\\E", "shortCiteRegEx": "Denecker and Vennekens.", "year": 2007}, {"title": "Answer set programming\u2019s contributions to classical logic. An analysis of ASP methodology", "author": ["M. Denecker", "J. Vennekens", "H. Vlaeminck", "J. Wittocx", "M. Bruynooghe"], "venue": "In MG-65: Symposium on Constructive Mathematics in Computer Science,", "citeRegEx": "Denecker et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Denecker et al\\.", "year": 2010}, {"title": "A tarskian informal semantics for asp", "author": ["M. Denecker", "Y. Lierler", "M. Truszczynski", "J. Vennekens"], "venue": "In Technical Communications of the 28th International Conference on Logic Programming,", "citeRegEx": "Denecker et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Denecker et al\\.", "year": 2012}, {"title": "Strong introspection", "author": ["M. Gelfond"], "venue": "In AAAI, pages 386\u2013391,", "citeRegEx": "Gelfond.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond.", "year": 1991}, {"title": "Classical negation in logic programs and disjunctive databases", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "New Generation Computing,", "citeRegEx": "Gelfond and Lifschitz.,? \\Q1991\\E", "shortCiteRegEx": "Gelfond and Lifschitz.", "year": 1991}, {"title": "The stable model semantics for logic programming. In ICLP/SLP, pages 1070\u20131080", "author": ["M. Gelfond", "V. Lifschitz"], "venue": null, "citeRegEx": "Gelfond and Lifschitz.,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz.", "year": 1988}, {"title": "Structural equations and causation", "author": ["N. Hall"], "venue": "Philosophical Studies,", "citeRegEx": "Hall.,? \\Q2007\\E", "shortCiteRegEx": "Hall.", "year": 2007}, {"title": "Answer set programming and plan generation", "author": ["V. Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "Lifschitz.,? \\Q2002\\E", "shortCiteRegEx": "Lifschitz.", "year": 2002}, {"title": "Causality: Models, Reasoning, and Inference", "author": ["J. Pearl"], "venue": null, "citeRegEx": "Pearl.,? \\Q2000\\E", "shortCiteRegEx": "Pearl.", "year": 2000}, {"title": "An alternative approach to the semantics of disjunctive logic programs and deductive databases", "author": ["C. Sakama", "K. Inoue"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Sakama and Inoue.,? \\Q1994\\E", "shortCiteRegEx": "Sakama and Inoue.", "year": 1994}, {"title": "CP-logic: A language of causal probabilistic events and its relation to logic programming", "author": ["J. Vennekens", "M. Denecker", "M. Bruynooghe"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Vennekens et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Vennekens et al\\.", "year": 2009}, {"title": "Embracing events in causal modelling: Interventions and counterfactuals in CP-logic", "author": ["J. Vennekens", "M. Denecker", "M. Bruynooghe"], "venue": "In JELIA,", "citeRegEx": "Vennekens et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Vennekens et al\\.", "year": 2010}], "referenceMentions": [{"referenceID": 5, "context": "Historically, the origins of ASP lie in the seminal papers by Gelfond and Lifschitz on the stable semantics for normal (1988) and extended logic programs (1991).", "startOffset": 62, "endOffset": 126}, {"referenceID": 5, "context": "Historically, the origins of ASP lie in the seminal papers by Gelfond and Lifschitz on the stable semantics for normal (1988) and extended logic programs (1991). These papers develop an epistemic view on logic programs, in which an answer set is seen as an exhaustive enumeration of a rational agent\u2019s atomic beliefs.", "startOffset": 62, "endOffset": 161}, {"referenceID": 5, "context": ", Gelfond\u2019s example (1991) of interviewing all students for which we do not know whether they are eligible for a grant\u2014the statement of the graph colouring problems is not concerned with anyone\u2019s knowledge or beliefs, but only with the objective colour of the nodes.", "startOffset": 2, "endOffset": 27}, {"referenceID": 1, "context": "One of its main achievements has been the development of the language of FO(ID) (Denecker and Ternovska, 2007), which extends FO with a construct for representing inductive definitions.", "startOffset": 80, "endOffset": 110}, {"referenceID": 12, "context": "This paper is concerned with one particular such extension, namely, CP-logic (Vennekens et al., 2009), which extends the inductive definition construct of FO(ID) with a means for expressing non-deterministic choice.", "startOffset": 77, "endOffset": 101}, {"referenceID": 2, "context": "Recent summaries of these results were published by Denecker et al. (2010) and Denecker et al.", "startOffset": 52, "endOffset": 75}, {"referenceID": 2, "context": "Recent summaries of these results were published by Denecker et al. (2010) and Denecker et al. (2012). A goal of this research program is to reconstruct ASP as a series of conservative extensions of FO.", "startOffset": 52, "endOffset": 102}, {"referenceID": 10, "context": "to correctly formalise non-deterministic inductive definitions, not the minimal model semantics must be used, but the possible world semantics of Sakama and Inoue (1994). A more important application of CP-logic, however, is to represent probabilistic causal laws.", "startOffset": 146, "endOffset": 170}, {"referenceID": 10, "context": "Such relations have received a great deal of attention in the AI community, especially since the influential work by Pearl (2000) on this topic.", "startOffset": 117, "endOffset": 130}, {"referenceID": 10, "context": "Such relations have received a great deal of attention in the AI community, especially since the influential work by Pearl (2000) on this topic. As shown by Vennekens et al. (2010), CP-logic can actually be seen as a refinement of Pearl\u2019s theory, which allows for a more compact and modular representation of certain phenomena.", "startOffset": 117, "endOffset": 181}, {"referenceID": 0, "context": "CP-logic has certain similarities to P-log, a probabilistic extension of ASP (Baral et al., 2008).", "startOffset": 77, "endOffset": 97}, {"referenceID": 5, "context": "In other words, we will examine how CP-logic can be extended with the familiar ASP feature of negation in the head Gelfond and Lifschitz (1991). Again, the traditional ASP interpretation of a classical negation literal is rooted in the epistemic tradition: whereas not A means that A is not believed to be true, a classical negation literal \u00acA means that A is believed to be false.", "startOffset": 115, "endOffset": 144}, {"referenceID": 12, "context": "It was shown by Vennekens et al. (2009) that, because each applicable rule must eventually be applied, the differences between these execution models are irrelevant, as long as we only care about the final states that may be reached.", "startOffset": 16, "endOffset": 40}, {"referenceID": 12, "context": "An important class of sound theories are those which are stratified, but there also exist useful sound theories outside of this class (see Vennekens et al. (2009) for a discussion).", "startOffset": 139, "endOffset": 163}, {"referenceID": 10, "context": "One of the interesting uses of negation-in-the-head is related to the concept of interventions, introduced by Pearl (2000). Let us briefly recall this notion.", "startOffset": 110, "endOffset": 123}, {"referenceID": 11, "context": "This is an instance of a general method, developed by Vennekens et al. (2010), of performing Pearl-style interventions in CP-logic.", "startOffset": 54, "endOffset": 78}, {"referenceID": 1, "context": "This transformation is based on the way in which Denecker and Ternovska (2007) encode causal ramifications in their inductive definition modelling of the situation calculus.", "startOffset": 49, "endOffset": 79}], "year": 2017, "abstractText": "CP-logic is a probabilistic extension of the logic FO(ID). Unlike ASP, both of these logics adhere to a Tarskian informal semantics, in which interpretations represent objective states-of-affairs. In other words, these logics lack the epistemic component of ASP, in which interpretations represent the beliefs or knowledge of a rational agent. Consequently, neither CP-logic nor FO(ID) have the need for two kinds of negations: there is only one negation, and its meaning is that of objective falsehood. Nevertheless, the formal semantics of this objective negation is mathematically more similar to ASP\u2019s negation-as-failure than to its classical negation. The reason is that both CP-logic and FO(ID) have a constructive semantics in which all atoms start out as false, and may only become true as the result of a rule application. This paper investigates the possibility of adding the well-known ASP feature of allowing negation in the head of rules to CP-logic. Because CP-logic only has one kind of negation, it is of necessity this \u201cnegation-as-failure like\u201d negation that will be allowed in the head. We investigate the intuitive meaning of such a construct and the benefits that arise from it.", "creator": "LaTeX with hyperref package"}}}