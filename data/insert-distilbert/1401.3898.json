{"id": "1401.3898", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "First-Order Stable Model Semantics and First-Order Loop Formulas", "abstract": "lin and zhaos theorem on loop formulas states that in the propositional case the stable model semantics of a logic program can be completely characterized instantly by propositional loop formulas, ( but this stability result does not fully carry over to the formal first - priority order case. we investigate the precise relationship between the first - order stable model semantics and some first - order loop test formulas, modelling and study conditions under which the former can be represented by the latter. in order to facilitate the comparison, we extend above the definition of a first - order loop formula which was limited to a nondisjunctive program, to a disjunctive base program and one to an arbitrary first - order verification theory. based on the studied relationship we extend inside the syntax of a logic program with explicit dependency quantifiers, which allows telling us to do reasoning diagrams involving non - expressive herbrand stable test models involving using first - order reasoners. such programs can be also viewed as a special class of first - order theories under the stable model semantics, which yields more succinct loop formulas than the general language due to their restricted syntax.", "histories": [["v1", "Thu, 16 Jan 2014 05:18:54 GMT  (541kb)", "http://arxiv.org/abs/1401.3898v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["joohyung lee", "yunsong meng"], "accepted": false, "id": "1401.3898"}, "pdf": {"name": "1401.3898.pdf", "metadata": {"source": "CRF", "title": "First-Order Stable Model Semantics and First-Order Loop Formulas", "authors": ["Joohyung Lee", "Yunsong Meng"], "emails": ["joolee@asu.edu", "Yunsong.Meng@asu.edu"], "sections": [{"heading": "1. Introduction", "text": "According to the theorem on loop formulas (Lin & Zhao, 2004), the stable models of a logic program (Gelfond & Lifschitz, 1988) can be characterized as the models of the logic program that satisfy all its loop formulas. This idea has turned out to be widely applicable in relating the stable model semantics to propositional logic, and has resulted in an efficient method for computing answer sets using SAT solvers. Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008). The theorem has also been applied to other nonmonotonic formalisms, such as nonmonotonic causal theories (Lee, 2004) and McCarthy\u2019s circumscription (Lee & Lin, 2006). The notion of a loop was further refined as an \u201celementary loop\u201d (Gebser & Schaub, 2005; Gebser, Lee, & Lierler, 2006, 2011). However, all this work is restricted to the propositional case. Variables contained in a program are first eliminated by grounding\u2014the process which replaces every variable with every object constant\u2014and then loop formulas are obtained from the ground program. As a result, loop formulas were defined as formulas in propositional logic.\nc\u00a92011 AI Access Foundation. All rights reserved.\nChen, Lin, Wang, and Zhang\u2019s definition (2006) of a first-order loop formula is different in that loop formulas are directly obtained from a non-ground program, so that they are first-order logic formulas which retain variables. However, since the semantics of a logic program that they refer to is based on grounding, these first-order loop formulas are simply understood as schemas for ground loop formulas, and only Herbrand models of the loop formulas were considered in this context.\nThe stable model semantics that does not involve grounding appeared a year later (Ferraris, Lee, & Lifschitz, 2007, 2011). The authors define the stable models of a firstorder sentence F as the models of the second-order sentence that is obtained by applying the \u201cstable model operator\u201d SM to F . The definition of SM is close to the definition of the circumscription operator CIRC (McCarthy, 1980, 1986). Under the first-order stable model semantics, logic programs are viewed as a special class of first-order theories. A similar definition of a stable model was given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992). The first-order stable model semantics is also closely related to quantified equilibrium logic (Pearce & Valverde, 2005), and indeed, Ferraris et al. (2011) showed that they are essentially equivalent.\nA natural question arising is how first-order loop formulas and the first-order stable model semantics are related to each other. In general, the first-order stable model semantics is more expressive than first-order logic, and as such cannot be completely characterized by first-order loop formulas. Like circumscription, the concept of transitive closure can be represented in the first-order stable model semantics, but not in any set of first-order formulas, even if that set is allowed to be infinite.1 However, as we show in this paper, understanding the precise relationship between them gives us insights into the first-order stable model semantics and its computational properties.\nIn order to facilitate the comparison, we extend the definition of a first-order loop formula which was limited to nondisjunctive programs, to disjunctive programs and to arbitrary first-order theories. Also we present a reformulation of SM[F ] in the style of loop formulas, which includes the characterization of a loop by a syntactic formula. From this formulation, we derive several conditions, under which a first-order theory under the stable model semantics can be equivalently rewritten as first-order loop formulas.\nBased on the relationship between the first-order stable model semantics and first-order loop formulas, we extend the syntax of logic programs with explicit quantifiers, which may be useful in overcoming some limitations of traditional answer set programs in reasoning about non-Herbrand models. We define the semantics of such extended programs by identifying them as a special class of first-order theories under the stable model semantics. Such programs inherit from the general language the ability to handle nonmonotonic reasoning under the stable model semantics even in the absence of the unique name and the domain closure assumptions that are built into the grounding-based answer set semantics. On the other hand, the restricted syntax of an extended program leads to more succinct loop formulas. The following program \u03a01 is a simple insurance policy example represented in\n1. Vladimir Lifschitz, personal communication.\nthis syntax.\nHasWife(x) \u2190 \u2203y Spouse(x, y) HasWife(x) \u2190 Man(x), Married(x) Married(x) \u2190 Man(x), HasWife(x)\n\u2203w Discount(x,w) \u2190 Married(x), not \u2203z Accident(x, z).\nThe second and the third rules express that Married(x) and HasWife(x) are synonymous to each other when x is a Man. The last rule states that x is eligible for some discount plan (with the name unknown) if x is married and has no record of accident. The quantifier in the first rule can be dropped without affecting the meaning, but the other quantifiers cannot. We will say that a program \u03a0 entails a query F (under the stable model semantics) if every stable model of \u03a0 satisfies F . For example,\n\u2022 \u03a01 conjoined with \u03a02 = {Man(John)} entails each of \u00ac\u2203x Married(x) and \u00ac\u2203xy Discount(x, y).\n\u2022 \u03a01 \u222a \u03a02 conjoined with \u03a03 = {\u2203y Spouse(John, y)} entails neither \u00ac\u2203x Married(x) nor \u00ac\u2203xy Discount(x, y), but entails each of \u2203x Married(x), \u2203xyDiscount(x, y), and \u2200xy(Discount(x, y)\u2192 x = John).\n\u2022 \u03a01 \u222a\u03a02 \u222a\u03a03 conjoined with \u03a04 = {\u2203z Accident(John, z)} does not entail \u2200xy(Discount(x, y)\u2192 x = John), but entails \u00ac\u2203w Discount(John, w).\nThe nonmonotonic reasoning of this kind requires non-Herbrand models since the names (or identifiers) of discount plans, spouses and accident records may be unknown. However, the traditional answer set semantics is limited to Herbrand models due to the reference to grounding. By turning the program into first-order loop formulas we can automate the example reasoning using a first-order theorem prover.\nThe paper is organized as follows. The next section reviews the first-order stable model semantics by Ferraris et al. (2007, 2011). Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models. Section 4 extends these results to allow non-Herbrand stable models as well (possibly allowing functions) under a certain semantic condition, and compare the first-order stable model semantics with loop formulas by reformulating the former in terms of the latter. In Section 5, we present a series of syntactic conditions that imply the semantic condition in Section 4. Section 6 provides an extension of logic programs that contain explicit quantifiers and shows how query answering for such extended programs can sometimes be reduced to entailment checking in first-order logic via loop formulas. In Section 7, the results are further extended to distinguish between intensional and non-intensional predicates. Related work is described in Section 8, and long proofs are given in Appendix A.\nThis article is an extended version of a conference paper by Lee and Meng (2008)."}, {"heading": "2. Review of the First-Order Stable Model Semantics", "text": "This review follows a journal paper by Ferraris et al. (2011) that extends a conference paper by the same authors (Ferraris et al., 2007) by distinguishing between intensional and non-intensional predicates.\nA formula is defined the same as in first-order logic. A signature consists of function constants and predicate constants. Function constants of arity 0 are called object constants. We assume the following set of primitive propositional connectives and quantifiers:\n\u22a5 (falsity), \u2227, \u2228, \u2192, \u2200, \u2203 .\n\u00acF is an abbreviation of F \u2192 \u22a5, symbol > stands for \u22a5 \u2192 \u22a5, and F \u2194 G stands for (F \u2192 G) \u2227 (G \u2192 F ). We distinguish between atoms and atomic formulas as follows: an atom of a signature \u03c3 is an n-ary predicate constant followed by a list of n terms that can be formed from function constants in \u03c3 (including object constants) and object variables; atomic formulas of \u03c3 are atoms of \u03c3, equalities between terms of \u03c3, and the 0-place connective \u22a5.\nThe stable models of F relative to a list of predicates p = (p1, . . . , pn) are defined via the stable model operator with the intensional predicates p, denoted by SM[F ; p].2 Let u be a list of distinct predicate variables u1, . . . , un of the same length as p. By u = p we denote the conjunction of the formulas \u2200x(ui(x)\u2194 pi(x)), where x is a list of distinct object variables of the same length as the arity of pi, for all i = 1, . . . , n. By u \u2264 p we denote the conjunction of the formulas \u2200x(ui(x) \u2192 pi(x)) for all i = 1, . . . , n, and u < p stands for (u \u2264 p)\u2227\u00ac(u = p). For any first-order sentence F , the expression SM[F ; p] stands for the second-order sentence\nF \u2227 \u00ac\u2203u((u < p) \u2227 F \u2217(u)), (1)\nwhere F \u2217(u) is defined recursively:\n\u2022 pi(t)\u2217 = ui(t) for any list t of terms;\n\u2022 F \u2217 = F for any atomic formula F (including \u22a5 and equality) that does not contain members of p;\n\u2022 (F \u2227G)\u2217 = F \u2217 \u2227G\u2217;\n\u2022 (F \u2228G)\u2217 = F \u2217 \u2228G\u2217;\n\u2022 (F \u2192 G)\u2217 = (F \u2217 \u2192 G\u2217) \u2227 (F \u2192 G);\n\u2022 (\u2200xF )\u2217 = \u2200xF \u2217;\n\u2022 (\u2203xF )\u2217 = \u2203xF \u2217.\n(There is no clause for negation here, because we treat \u00acF as shorthand for F \u2192 \u22a5.) A model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies SM[F ; p]. We will often simply write SM[F ] instead of SM[F ; p] when p is the list of all predicate constants occurring in F , and call a model of SM[F ] simply a stable model of F . We distinguish between the terms \u201cstable models\u201d and \u201canswer sets\u201d as follows.3 By \u03c3(F ) we denote the signature consisting of the function and predicate constants occurring in F .\n2. The intensional predicates p are the predicates that we \u201cintend to characterize\u201d by F . 3. The distinction is useful because in the first-order setting, stable models are no longer Herbrand inter-\npretations and may not be represented by sets of atoms.\nIf F contains at least one object constant, an Herbrand interpretation4 of \u03c3(F ) that satisfies SM[F ] is called an answer set of F . The answer sets of a logic program \u03a0 are defined as the answer sets of the FOL-representation of \u03a0 (i.e., the conjunction of the universal closures of implications corresponding to the rules).\nExample 1 For program \u03a0 that contains three rules\np(a) q(b) r(x)\u2190 p(x),not q(x)\nthe FOL-representation F of \u03a0 is\np(a) \u2227 q(b) \u2227 \u2200x((p(x) \u2227 \u00acq(x))\u2192 r(x)) (2)\nand SM[F ] is\np(a) \u2227 q(b) \u2227 \u2200x((p(x) \u2227 \u00acq(x))\u2192 r(x)) \u2227\u00ac\u2203uvw(((u, v, w) < (p, q, r)) \u2227 u(a) \u2227 v(b)\n\u2227\u2200x(((u(x) \u2227 (\u00acv(x) \u2227 \u00acq(x)))\u2192 w(x)) \u2227 ((p(x) \u2227 \u00acq(x))\u2192 r(x)))),\nwhich is equivalent to the first-order sentence\n\u2200x(p(x)\u2194 x = a) \u2227 \u2200x(q(x)\u2194 x = b) \u2227 \u2200x(r(x)\u2194 (p(x) \u2227 \u00acq(x))) (3)\n(See Example 3 in the work of Ferraris et al., 2007). The stable models of F are any firstorder models of (3). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}."}, {"heading": "3. First-Order Loop Formulas and Herbrand Models", "text": "We review the definition of a first-order loop formula for a nondisjunctive program given by Chen et al. (2006) and extend it to a disjunctive program and to an arbitrary first-order sentence."}, {"heading": "3.1 Review of First-Order Loop Formulas Defined by Chen et al. (2006)", "text": "We call a formula negative if every occurrence of every predicate constant in it belongs to the antecedent of an implication. For instance, any formula of the form \u00acF is negative because this expression is shorthand for F \u2192 \u22a5. An equality t1 = t2 is also negative because it contains no predicate constants.\nA nondisjunctive program is a finite set of rules of the form\nA\u2190 B,N, (4)\n4. Recall that an Herbrand interpretation of a signature \u03c3 (containing at least one object constant) is an interpretation of \u03c3 such that its universe is the set of all ground terms of \u03c3, and every ground term represents itself. An Herbrand interpretation can be identified with the set of ground atoms to which it assigns the value true.\nwhere A is an atom, B is a set of atoms, and N is a negative formula. The rules may contain function constants of positive arity.5\nWe will say that a nondisjunctive program is in normal form if, for all rules (4) in it, A is of the form p(x) where x is a list of distinct variables. It is clear that every program can be turned into normal form using equality in the body. For instance, p(a, b)\u2190 q(a) can be rewritten as p(x, y)\u2190 x=a, y=b, q(a).\nLet \u03a0 be a nondisjunctive program and let Norm(\u03a0) be a normal form of \u03a0. By \u03c3(\u03a0) we denote the signature consisting of function and predicate constants occurring in \u03a0. Given a finite set Y of atoms, we assume that Norm(\u03a0) does not contain variables in Y , by renaming the variables in Norm(\u03a0). The (first-order) external support formula of Y for \u03a0, denoted by ES \u03a0(Y ), is the disjunction of\u2228\n\u03b8:A\u03b8\u2208Y \u2203z ( B\u03b8 \u2227N\u03b8 \u2227 \u2227 p(t)\u2208B\u03b8 p(t\u2032)\u2208Y (t 6= t\u2032) )\n(5)\nfor all rules (4) in Norm(\u03a0),6 where \u03b8 is a substitution that maps variables in A to terms occurring in Y , and z is the list of all variables that occur in\nA\u03b8 \u2190 B\u03b8,N\u03b8\nbut not in Y .\nThe (first-order) loop formula of Y for \u03a0, denoted by LF \u03a0(Y ), is the universal closure of \u2227\nY \u2192 ES \u03a0(Y ). (6)\n(The expression \u2227 Y in the antecedent stands for the conjunction of all elements of Y .) When \u03a0 is a propositional program, LF \u03a0(Y ) is equivalent to a conjunctive loop formula as defined by Ferraris et al. (2006).\nThe definition of a first-order dependency graph and the definition of a first-order loop are as follows. We say that an atom p(t) depends on an atom q(t\u2032) in a rule (4) if p(t) is A and q(t\u2032) is in B. The (first-order) dependency graph of \u03a0 is an infinite directed graph (V,E) such that\n\u2022 V is the set of atoms of signature \u03c3(\u03a0);7\n\u2022 (p(t)\u03b8, q(t\u2032)\u03b8) is in E if p(t) depends on q(t\u2032) in a rule of \u03a0 and \u03b8 is a substitution that maps variables in t and t\u2032 to terms (including variables) of \u03c3(\u03a0).\nA nonempty subset L of V is called a (first-order) loop of \u03a0 if the subgraph of the first-order dependency graph of \u03a0 induced by L is strongly connected.\n5. The original definition by Chen et al. (2006) does not allow function constants of positive arity. 6. For any lists of terms t = (t1, . . . , tn) and t \u2032 = (t\u20321, . . . , t \u2032 n) of the same length, t = t\n\u2032 stands for (t1 = t \u2032 1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 (tn = t\u2032n).\n7. Note that V is infinite since infinitely many object variables can be used to form atoms.\nExample 2 Let \u03a0 be the following program:\np(x)\u2190 q(x) q(y)\u2190 p(y) p(z)\u2190 not r(z).\n(7)\nThe following sets of atoms are first-order loops (among many others): Y1 = {p(u)}, Y2 = {q(u)}, Y3 = {r(u)}, Y4 = {p(u), q(u)}. Their loop formulas are\nLF \u03a0(Y1) = \u2200u(p(u)\u2192 (q(u) \u2228 \u00acr(u))), LF \u03a0(Y2) = \u2200u(q(u)\u2192 p(u)), LF \u03a0(Y3) = \u2200u(r(u)\u2192 \u22a5), LF \u03a0(Y4) = \u2200u(p(u) \u2227 q(u)\u2192 (q(u) \u2227 u 6= u) \u2228 (p(u) \u2227 u 6= u) \u2228 \u00acr(u)).\nExample 3 Let \u03a0 be the one-rule program\np(x)\u2190 p(y). (8)\nIts finite first-order loops are Yk = {p(x1), . . . , p(xk)} where k > 0. Formula LF \u03a0(Yk) is \u2200x1 . . . xk ( p(x1) \u2227 . . . \u2227 p(xk)\u2192 \u2203y(p(y) \u2227 (y 6= x1) \u2227 . . . \u2227 (y 6= xk)) ) . (9)\nThe following is a reformulation of Theorem 1 from the work of Chen et al. (2006).\nTheorem 1 Let \u03a0 be a nondisjunctive program that contains at least one object constant but no function constants of positive arity, and let I be an Herbrand interpretation of \u03c3(\u03a0) that satisfies \u03a0.8 The following conditions are equivalent to each other:\n(a) I is a stable model of \u03a0;\n(b) for every nonempty finite set Y of atoms of \u03c3(\u03a0), I satisfies LF \u03a0(Y ); 9\n(c) for every finite first-order loop Y of \u03a0, I satisfies LF \u03a0(Y ).\nThe sets of first-order loop formulas considered in conditions (b) and (c) above have obvious redundancies. For instance, the loop formula of {p(x)} is equivalent to the loop formula of {p(y)}; the loop formula of {p(x), p(y)} entails the loop formula of {p(z)}. Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution \u03b8 that maps variables in Y1 to terms so that Y1\u03b8 = Y2.\nProposition 1 (Chen et al., 2006, Proposition 7) For any nondisjunctive program \u03a0 and any loops Y1 and Y2 of \u03a0, if Y1 subsumes Y2, then LF \u03a0(Y1) entails LF \u03a0(Y2).\nTherefore in condition (c) from Theorem 1, it is sufficient to consider a set \u0393 of loops such that, for every loop L of \u03a0, there is a loop L\u2032 in \u0393 that subsumes L. Chen et al. (2006) called such \u0393 a complete set of loops. In Example 2, set {Y1, Y2, Y3, Y4} is a finite complete set of loops of program (7). Program (8) in Example 3 has no finite complete set of loops.\n8. We say that I satisfies \u03a0 if I satisfies the FOL-representation of \u03a0. 9. Note that Y may contain variables."}, {"heading": "3.2 Extension to Disjunctive Programs", "text": "A disjunctive program is a finite set of rules of the form\nA\u2190 B,N, (10)\nwhere A and B are sets of atoms, and N is a negative formula. Similar to a nondisjunctive program, we say that a disjunctive program is in normal form if, for all rules (10) in it, all atoms in A are of the form p(x) where x is a list of distinct variables.\nLet \u03a0 be a disjunctive program and let Norm(\u03a0) be a normal form of \u03a0. Given a finite set Y of atoms, we first rename variables in Norm(\u03a0) so that no variables in Norm(\u03a0) occur in Y . The (first-order) external support formula of Y for \u03a0, denoted by ES \u03a0(Y ), is the disjunction of\u2228\n\u03b8:A\u03b8\u2229Y 6=\u2205\n\u2203z ( B\u03b8 \u2227N\u03b8 \u2227 \u2227 p(t)\u2208B\u03b8 p(t\u2032)\u2208Y (t 6= t\u2032) \u2227 \u00ac ( \u2228 p(t)\u2208A\u03b8 ( p(t) \u2227 \u2227 p(t\u2032)\u2208Y t 6= t\u2032 )))\n(11)\nfor all rules (10) in Norm(\u03a0), where \u03b8 is a substitution that maps variables in A to terms occurring in Y or to themselves, and z is the list of all variables that occur in\nA\u03b8 \u2190 B\u03b8,N\u03b8\nbut not in Y . The (first-order) loop formula of Y for \u03a0, denoted by LF \u03a0(Y ), is the universal closure of \u2227\nY \u2192 ES \u03a0(Y ).\nClearly, (11) is equivalent to (5) when \u03a0 is nondisjunctive. When \u03a0 and Y are propositional, LF \u03a0(Y ) is equivalent to the conjunctive loop formula for a disjunctive program as defined by Ferraris et al. (2006).\nExample 4 Let \u03a0 be the program\np(x, y) ; p(y, z) \u2190 q(x)\nand let Y = {p(u, v)}. Formula LF \u03a0(Y ) is the universal closure of\np(u, v)\u2192 \u2203z(q(u) \u2227 \u00ac(p(v, z) \u2227 ((v, z) 6= (u, v)))) \u2228 \u2203x(q(x) \u2227 \u00ac(p(x, u) \u2227 ((x, u) 6= (u, v)))).\nSimilar to the nondisjunctive case, we say that p(t) depends on q(t\u2032) in \u03a0 if there is a rule (10) in \u03a0 such that p(t) is in A and q(t\u2032) is in B. The definitions of a first-order dependency graph and a first-order loop are extended to disjunctive programs in a straightforward way. Using these extended notions, the following theorem extends Theorem 1 to a disjunctive program. It is also a generalization of the main theorem by Ferraris et al. (2006) which was restricted to a propositional disjunctive program.\nTheorem 1 d Let \u03a0 be a disjunctive program that contains at least one object constant but no function constants of positive arity, and let I be an Herbrand interpretation of \u03c3(\u03a0) that satisfies \u03a0. The following conditions are equivalent to each other:\n(a) I is a stable model of \u03a0;\n(b) for every nonempty finite set Y of atoms of \u03c3(\u03a0), I satisfies LF \u03a0(Y );\n(c) for every finite first-order loop Y of \u03a0, I satisfies LF \u03a0(Y )."}, {"heading": "3.3 Extension to Arbitrary Sentences", "text": "In this section we extend the definition of a first-order loop formula to an arbitrary firstorder sentence.\nAs with a propositional loop formula defined for an arbitrary propositional theory (Ferraris et al., 2006), it is convenient to introduce a formula whose negation is close to ES . We define formula NESF (Y ) (\u201cNegation of (First-order) External Support Formula\u201d), where F is a first-order formula and Y is a finite set of atoms, as follows. As before we assume that no variables in Y occur in F , by renaming variables.\n\u2022 NES pi(t)(Y ) = pi(t) \u2227 \u2227 pi(t\u2032)\u2208Y t 6= t \u2032;\n\u2022 NES t1=t2(Y ) = (t1 = t2);\n\u2022 NES\u22a5(Y ) = \u22a5;\n\u2022 NESF\u2227G(Y ) = NESF (Y ) \u2227NESG(Y );\n\u2022 NESF\u2228G(Y ) = NESF (Y ) \u2228NESG(Y );\n\u2022 NESF\u2192G(Y ) = (NESF (Y )\u2192NESG(Y )) \u2227 (F\u2192G);\n\u2022 NES\u2200xG(Y ) = \u2200xNESG(Y );\n\u2022 NES\u2203xG(Y ) = \u2203xNESG(Y ).\nThe (first-order) loop formula of Y for F , denoted by LFF (Y ), is the universal closure of \u2227\nY \u2192 \u00acNESF (Y ). (12)\nNote that the definition of NES looks similar to the definition of F \u2217 given in Section 2. When F and Y are propositional, LFF (Y ) is equivalent to a conjunctive loop formula for a propositional formula that is defined by Ferraris et al. (2006). The following lemma tells us that the definition of a loop formula in this section generalizes the definition of a loop formula for a disjunctive program in the previous section.\nLemma 1 Let \u03a0 be a disjunctive program in normal form, F an FOL-representation of \u03a0, and Y a finite set of atoms. Formula NESF (Y ) is equivalent to \u00acES \u03a0(Y ) under the assumption F .\nIn order to extend the first-order dependency graph to an arbitrary formula, we introduce a few notions. We say that an occurrence of a subformula G in a formula F is positive if the number of implications in F containing that occurrence in the antecedent is even; it is strictly positive if that number is 0. A rule of a first-order formula F is an implication that occurs strictly positively in F . We will say that a formula is rectified if it has no variables that are both bound and free, and if all quantifiers in the formula refer to different variables. Any formula can be easily rewritten into a rectified formula by renaming bound variables.\nWe say that an atom p(t) depends on an atom q(t\u2032) in an implication G\u2192 H if\n\u2022 p(t) has a strictly positive occurrence in H, and\n\u2022 q(t\u2032) has a positive occurrence in G that does not belong to any negative subformula of G.10\nThe definition of a first-order dependency graph is extended to formulas as follows. The (first-order) dependency graph of a rectified formula F is the infinite directed graph (V,E) such that\n\u2022 V is the set of atoms of signature \u03c3(F );\n\u2022 (p(t)\u03b8, q(t\u2032)\u03b8) is in E if p(t) depends on q(t\u2032) in a rule of F and \u03b8 is a substitution that maps variables in t and t\u2032 to terms of \u03c3(F ).\nNote that the rectified formula assumption is required in order to distinguish between dependency graphs of formulas such as\n\u2200x(p(x)\u2192 q(x))\nand \u2200x p(x)\u2192 \u2200x q(x).\nOnce the definition of a dependency graph is given, a loop of a first-order formula is defined in the same way as with a disjunctive program. Theorem 1 can be extended to first-order sentences using these extended notions.\nTheorem 1 f Let F be a rectified sentence that contains at least one object constant but no function constants of positive arity, and let I be an Herbrand interpretation of \u03c3(F ) that satisfies F . The following conditions are equivalent to each other:\n(a) I is a stable model of F (i.e., I satisfies SM[F ]);\n(b) for every nonempty finite set Y of atoms of \u03c3(F ), I satisfies LFF (Y );\n(c) for every finite first-order loop Y of F , I satisfies LFF (Y ).\nExample 2 (continued) Consider the FOL-representation F of the program in Example 2, for which {Y1, Y2, Y3, Y4} is a complete set of loops. Under the assumption F ,\n10. Recall the definition of a negative formula in Section 3.1.\n\u2022 LFF (Y1) is equivalent to the universal closure of p(u)\u2192 \u00ac ( \u2200x(q(x)\u2192 p(x) \u2227 x 6= u) \u2227 \u2200y(p(y) \u2227 y 6= u\u2192 q(y))\n\u2227 \u2200z(\u00acr(z)\u2192 p(z) \u2227 z 6= u) ) ;\n\u2022 LFF (Y2) is equivalent to the universal closure of q(u)\u2192 \u00ac ( \u2200x(q(x) \u2227 x 6= u\u2192 p(x)) \u2227 \u2200y(p(y)\u2192 q(y) \u2227 y 6= u) ) ;\n\u2022 LFF (Y3) is equivalent to the universal closure of\nr(u)\u2192 \u22a5;\n\u2022 LFF (Y4) is equivalent to the universal closure of p(u) \u2227 q(u)\u2192 \u00ac ( \u2200x(q(x) \u2227 x 6= u\u2192 p(x) \u2227 x 6= u)\n\u2227 \u2200y(p(y) \u2227 y 6= u\u2192 q(y) \u2227 y 6= u) \u2227 \u2200z(\u00acr(z)\u2192 p(z) \u2227 z 6= u) ) .\nProposition 1 can be straightforwardly extended to arbitrary sentences even without restricting the attention to loops.\nProposition 1 f For any sentence F and any nonempty finite sets of atoms Y1 and Y2 of \u03c3(F ), if Y1 subsumes Y2, then LFF (Y1) entails LFF (Y2).\nProof. Note that LFF (Y1) is \u2200z (\u2227 Y1 \u2192 \u00acNESF (Y1) ) , (13)\nwhere z is the set of all variables in Y1. If Y1 subsumes Y2, by definition, there is a substitution \u03b8 from variables in Y1 to terms in Y2 such that Y1\u03b8 = Y2. It is clear that (13) entails\n\u2200z\u2032 (\u2227 Y1\u03b8 \u2192 \u00acNESF (Y1\u03b8) ) , (14)\nwhere z\u2032 is the set of all variables in Y1\u03b8. (14) is exactly LFF (Y2).\nTheorem 2 from the work of Ferraris et al. (2006) is a special case of Theorem 1f when F is restricted to a propositional formula.\nCorollary 1 (Ferraris et al., 2006, Thm. 2) For any propositional formula F , the following formulas are equivalent to each other under the assumption F .\n(a) SM[F ];\n(b) the conjunction of LFF (Y ) for all nonempty sets Y of atoms occurring in F ;\n(c) the conjunction of LFF (Y ) for all (ground) loops Y of F ."}, {"heading": "4. Comparing First-Order Stable Model Semantics and First-Order Loop", "text": "Formulas\nThe theorems in the previous section were restricted to Herbrand stable models. This section extends the results to allow non-Herbrand stable models as well, and compare the idea of loop formulas with SM by reformulating the latter in the style of loop formulas."}, {"heading": "4.1 Loop Formulas Relative to an Interpretation", "text": "Recall that Theorem 1 and its extensions do not allow function constants of positive arity and are limited to Herbrand models of the particular signature obtained from the given theory. Indeed, the statements become wrong if these conditions are dropped.\nExample 5 The following program contains a unary function constant f .\np(a) p(x)\u2190 p(f(x)).\nThe loops of this program are all singleton sets of atoms, and their loop formulas are satisfied by the Herbrand model {p(a), p(f(a)), p(f(f(a))), . . . } of the program, but this model is not stable.\nExample 3 (continued) The mismatch can happen even in the absence of function constants of positive arity. Consider the program in Example 3 and an interpretation I such that the universe is the set of all integers, and pI contains all integers. Interpretation I satisfies all first-order loop formulas (9), but it is not a stable model.\nThese examples suggest that the mismatch between the first-order stable model semantics and the first-order loop formulas is related to the presence of an infinite path in the dependency graph that visits infinitely many vertices. In the following we will make this idea more precise, and extend Theorem 1f to allow non-Herbrand interpretations under a certain condition.\nFirst, we define a dependency graph relative to an interpretation. Let F be a rectified formula whose signature is \u03c3 and let I be an interpretation of \u03c3. For each element \u03be of the universe |I| of I, we introduce a new symbol \u03be , called an object name. By \u03c3I we denote the signature obtained from \u03c3 by adding all object names \u03be as additional object constants. We will identify an interpretation I of signature \u03c3 with its extension to \u03c3I defined by I(\u03be ) = \u03be (For details, see the work of Lifschitz, Morgenstern, & Plaisted, 2008).\nThe dependency graph of F w.r.t. I is the directed graph (V,E) where\n\u2022 V is the set of all atoms of the form pi(\u03be ) where pi belongs to \u03c3(F ) and \u03be is a list of object names for |I|, and\n\u2022 (pi(\u03be ), pj(\u03b7 )) is in E if there are atoms pi(t), pj(t\u2032) such that pi(t) depends on pj(t\u2032) in a rule of F and there is a substitution \u03b8 that maps variables in t and t\u2032 to object names such that (t\u03b8)I = \u03be and (t\u2032\u03b8)I = \u03b7.\nWe call a nonempty subset L of V a loop of F w.r.t. I if the subgraph of the dependency graph of F w.r.t. I that is induced by L is strongly connected. We say that F is bounded w.r.t. I if every infinite path in the dependency graph of F w.r.t. I whose vertices are satisfied by I visits only finitely many vertices. If F is bounded w.r.t. I, then, clearly, every loop L of F w.r.t. I such that I |= L is finite. The definition is extended to a non-rectified formula by first rewriting it as a rectified formula. It also applies to the program syntax by referring to its FOL-representation.\nTheorem 2 Let F be a rectified sentence of a signature \u03c3 (possibly containing function constants of positive arity), and let I be an interpretation of \u03c3 that satisfies F . If F is bounded w.r.t. I, then the following conditions are equivalent to each other:\n(a) I |= SM[F ];\n(b) for every nonempty finite set Y of atoms formed from predicate constants in \u03c3(F ) and object names for |I|, I satisfies LFF (Y );\n(c) for every finite loop Y of F w.r.t. I, I satisfies LFF (Y ).\nThe condition that F is bounded w.r.t. I is sufficient for ensuring the equivalence among (a), (b), and (c), but it is not a necessary condition. For instance, consider F to be\n\u2200x p(x) \u2227 \u2200xy(p(x)\u2192 p(y))\nand I to be a model of F whose universe is infinite. Formula F is not bounded w.r.t. I, but I satisfies every loop formula, as well as SM[F ].\nWhen I is an Herbrand model of \u03c3(F ), the dependency graph of F w.r.t. I is isomorphic to the subgraph of the first-order dependency graph of F that is induced by vertices containing ground atoms. A set of ground atoms of \u03c3(F ) is a loop of F iff it is a loop of F w.r.t. I. Hence Theorem 2 is essentially a generalization of Theorem 1f .\nNote that the programs considered in Examples 3 and 5 are not bounded w.r.t. the interpretations considered there.\nClearly, if the universe of I is finite, then F is bounded w.r.t. I. This fact leads to the following corollary.\nCorollary 2 For any rectified sentence F and any model I of F whose universe is finite, conditions (a), (b), and (c) of Theorem 2 are equivalent to each other.\nIn view of Proposition 1f and Corollary 2, if the size of the universe is known to be a finite number n, it is sufficient to consider at most 2|p| \u2212 1 loop formulas, where p is the set of all predicate constants occurring in the sentence. Each loop formula is to check the external support of \u22c3 p\u2208K{p(x1), . . . , p(xnr)} for each K where\n\u2022 K is a nonempty subset of p;\n\u2022 r is the arity of p and each xi is a list of variables of the length r such that all variables in x1, . . . ,xnr are pairwise distinct.\nFor instance, consider program (8). If the size of the universe is known to be 3, it is sufficient to consider only one loop formula (9) where k = 3.\nTheorem 1f essentially follows from Corollary 2 as the Herbrand universe of \u03c3(F ) is finite when F contains no function constants of positive arity.\nAnother corollary to Theorem 2 is acquired when F has only \u201ctrivial\u201d loops. We say that a formula F is atomic-tight w.r.t. I if every path in the dependency graph of F w.r.t. I whose vertices are satisfied by I is finite. Clearly, this is a special case of boundedness condition, and every loop L of an atomic-tight formula F w.r.t. I such that I |= L is a singleton. The following is a corollary to Theorem 2, which tells us the condition under which stable models can be characterized by loop formulas of singleton loops only. By SLF[F ] (\u201cloop formulas of singletons\u201d) we denote\n{LFF ({p(x)}) | p is a predicate constant in \u03c3(F ), and x is a list of distinct object variables whose length is the same as the arity of p}. (15)\nCorollary 3 Let F be a rectified sentence (possibly containing function constants of positive arity), and let I be a model of F . If F is atomic-tight w.r.t. I, then I satisfies SM[F ] iff I satisfies SLF[F ].\nSLF[F ] is similar to Clark\u2019s completion. In the propositional case, the relationship between the loop formulas of singletons and the completion is studied by Lee (2005). Below we describe their relationship in the first-order case. A sentence F is in Clark normal form (Ferraris et al., 2011) if it is a conjunction of formulas of the form\n\u2200x(G\u2192 p(x)), (16)\none for each predicate constant p occurring in F , where x is a list of distinct variables, and G has no free variables other than x. The completion of a sentence F in Clark normal form, denoted by Comp[F ], is obtained from F by replacing each conjunctive term (16) with\n\u2200x(p(x)\u2194 G).\nAny nondisjunctive program can be turned into Clark normal form (Ferraris et al., 2011, Section 6.1).\nCorollary 4 Let F be the FOL-representation of a nondisjunctive program \u03a0, and let F \u2032 be the Clark normal form of F as obtained by the process described in the work of Ferraris et al. (2011, Section 6.1). If F is atomic-tight w.r.t. an interpretation I, then I |= SM[F ] iff I |= Comp[F \u2032].\nProof. Since F is atomic-tight w.r.t. I, by Corollary 3, I |= SM[F ] iff I |= F \u2227 SLF[F ]. It is sufficient to show that, for each predicate constant p occurring in F , under the assumption that F is atomic-tight w.r.t. I,\nI |= \u2200x ( p(x)\u2192 \u2228 p(t\u2032)\u2190B,N\u2208\u03a0 \u2203z ( (x = t\u2032) \u2227B \u2227N \u2227 \u2227 p(t)\u2208B (t 6= x) ))\n(17)\niff\nI |= \u2200x ( p(x)\u2192 \u2228 p(t\u2032)\u2190B,N\u2208\u03a0 \u2203z ( (x = t\u2032) \u2227B \u2227N )) , (18)\nwhere z is the list of all free variables in p(x)\u2190 (x = t\u2032), B,N that are not in x. Note that (17) is equivalent to saying that\nI |= \u2200x ( p(x)\u2192 \u2228 p(t\u2032)\u2190B,N\u2208\u03a0 \u2203z ( (x = t\u2032) \u2227B \u2227N \u2227 \u2227 p(t)\u2208B (t 6= t\u2032) )) . (19)\nFrom the assumption that F is atomic-tight w.r.t. I, it follows that, for any rule p(t\u2032) \u2190 B,N in \u03a0 and any atom of p(t) in B, I |= \u2200y(t 6= t\u2032), where y is the list of all variables in t and t\u2032 (otherwise we find a singleton loop with a self-cycle, which contradicts that F is atomic tight w.r.t. I). Consequently, (19) is equivalent to (18).\nFor example, let F be the FOL-representation of the program\np(b) \u2190 p(a) \u2190 a 6= b (20)\nSLF[p(a)\u2192 p(b)] is \u2200x(p(x)\u2192 x = b\u2227 p(a)\u2227 x 6= a), while Comp[\u2200x(x = b\u2227 p(a)\u2192 p(x))] is \u2200x(p(x) \u2194 x = b \u2227 p(a)). The additional conjunctive term x 6= a can be dropped when we consider any model I of F , for which aI 6= bI .\nCorollary 4 is an enhancement of Theorem 11 from the work of Ferraris et al. (2011), which states the equivalence between SM[F ] and Comp[F ] for any tight sentence F in Clark normal form. (Tight sentences are defined in a similar way, but in terms of a predicate dependency graph, whose vertices are predicate constants instead of atoms.) Every tight sentence is atomic-tight w.r.t. any model of the sentence. On the other hand, program (20) is atomic-tight w.r.t. any model of the program, but is not tight.\nTheorem 2 tells us that one of the limitations of first-order loop formulas is that, even if infinitely many first-order loop formulas are considered, they cannot ensure the external support of a certain infinite set that forms an infinite path in the dependency graph of F w.r.t. I. In the next section, by reformulating SM[F ], we show that the definition of SM[F ] essentially encompasses loop formulas, ensuring the external support of any sets of atoms, including those \u201cdifficult\u201d infinite sets."}, {"heading": "4.2 A Reformulation of SM", "text": "As before, let F be a first-order formula of a signature \u03c3, let p = (p1, . . . , pn) be the list of all predicate constants occurring in F , and let u and v be lists of predicate variables of the same length as p. We define NSESF (u) (\u201cNegation of Second-Order External Support Formula\u201d) recursively as follows.\n\u2022 NSES pi(t)(u) = pi(t) \u2227 \u00acui(t);\n\u2022 NSES t1=t2(u) = (t1 = t2);\n\u2022 NSES\u22a5(u) = \u22a5;\n\u2022 NSESF\u2227G(u) = NSESF (u) \u2227NSESG(u);\n\u2022 NSESF\u2228G(u) = NSESF (u) \u2228NSESG(u);\n\u2022 NSESF\u2192G(u) = (NSESF (u)\u2192NSESG(u)) \u2227 (F\u2192G);\n\u2022 NSES\u2200xF (u) = \u2200xNSESF (u);\n\u2022 NSES\u2203xF (u) = \u2203xNSESF (u).\nLemma 2 Let F be a rectified sentence of a signature \u03c3, I an interpretation of \u03c3, p the list of predicate constants occurring in F , q a list of predicate names 11 of the same length as p and Y a set of atoms formed from predicate constants from \u03c3(F ) and object names such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be ),\nwhere \u03be is a list of object names. If Y is finite, then\nI |= NSESF (q) iff I |= NESF (Y ).\nProof. By induction on F . We only list the case when F is an atom. The other cases are straightforward. Let F be an atom pi(\u03be ).\nI |= NSESF (q) iff I |= pi(\u03be ) \u2227 \u00acqi(\u03be ) iff I |= pi(\u03be ) and pi(\u03be ) /\u2208 Y iff I |= pi(\u03be ) and for all \u03b7 such that pi(\u03b7 ) \u2208 Y, it holds that \u03be 6= \u03b7 iff I |= pi(\u03be ) \u2227 \u2227 pi(\u03b7 )\u2208Y \u03be 6= \u03b7 iff I |= NESF (Y ).\nSM[F ] can be written in terms of NSES as follows. By Nonempty(u) we denote the formula\n\u2203x1u1(x1) \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u2203xnun(xn),\nwhere each xi is a list of distinct variables whose length is the same as the arity of pi.\nProposition 2 For any sentence F , SM[F ] is equivalent to\nF \u2227 \u2200u((u \u2264 p) \u2227Nonempty(u)\u2192 \u00acNSESF (u)). (21)\nNow we represent the notion of a loop by a second-order formula. Given a rectified formula F , by EF (v,u) we denote\u2228\n(pi(t),pj(t \u2032)) :\npi(t) depends on pj(t \u2032) in a rule of F\n\u2203z(vi(t) \u2227 uj(t\u2032) \u2227 \u00acvj(t\u2032)),\n11. Like object names, for every n > 0, each subset of |I|n has a name, which is an n-ary predicate constant not from the underlying signature.\nwhere z is the list of all object variables in t and t\u2032. By LoopF (u) we denote the second-order formula Nonempty(u) \u2227 \u2200v((v < u) \u2227Nonempty(v)\u2192 EF (v,u)). (22) Formula (22) represents the concept of a loop without referring to the notion of a dependency graph explicitly. This is based on the following observation. Consider a finite propositional program \u03a0. A nonempty set U of atoms that occur in \u03a0 is a loop of \u03a0 iff, for every nonempty proper subset V of U , there is an edge from an atom in V to an atom in U \\ V in the dependency graph of \u03a0 (Gebser et al., 2006).\nRecall the definition of a dependency graph relative to an interpretation. Let F be a rectified sentence of a signature \u03c3, and let I be an interpretation of \u03c3. The following proposition describes the relationship between formula (22) and a loop of F w.r.t. I.\nProposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be ),\nwhere \u03be is a list of object names. Then I |= LoopF (q) iff Y is a loop of F w.r.t. I.\nOne might expect that, similar to the equivalence between conditions (a) and (c) from Theorem 2, formula SM[F ] is equivalent to the following formula:\nF \u2227 \u2200u((u \u2264 p) \u2227 LoopF (u)\u2192 \u00acNSESF (u)). (23)\nHowever, the equivalence does not hold in general, as the following example illustrates.\nExample 6 Consider the FOL-representation F of the following program\np(x, y)\u2190 q(x, z) q(x, z)\u2190 p(y, z),\nand an interpretation I whose universe is the set of all nonnegative integers such that\npI = {(m,m) | m is a nonnegative integer}, qI = {(m,m+1) | m is a nonnegative integer}.\nFormula F is not bounded w.r.t. I since the dependency graph of F w.r.t. I contains an infinite path such as\n\u3008p(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . .\u3009. (24)\nThe interpretation I satisfies every loop formula of every finite loop of F w.r.t. I, but it is not a stable model.\nIn the example, what distinguishes the set\n{p(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . . } (25)\nfrom a loop is that, for every loop contained in (25), there is an outgoing edge in the dependency graph. This is an instance of what we call \u201cunbounded set.\u201d Given a dependency graph of F w.r.t. I, we say that a nonempty set Y of vertices is unbounded w.r.t. I if, for every subset Z of Y that is a loop, there is an edge from a vertex in Z to a vertex in Y \\Z.\nThe following proposition tells us how an unbounded set can be characterized by a second-order formula.\nProposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be ),\nwhere \u03be is a list of object names. Then\nI |= Nonempty(q) \u2227 \u2200v((v \u2264 q) \u2227 LoopF (v)\u2192 EF (v,q))\niff Y is an unbounded set of F w.r.t. I.\nIn order to check the stability of a model, we need to check the external support of every loop and every unbounded set. An extended loop of F w.r.t. I is a loop or an unbounded set of F w.r.t. I. We define Ext-LoopF (u) as\nLoopF (u) \u2228 (Nonempty(u) \u2227 \u2200v((v \u2264 u) \u2227 LoopF (v)\u2192 EF (v,u))). (26)\nFrom Propositions 3 and 4, it follows that I |= Ext-LoopF (q) iff Y is an extended loop of F w.r.t. I.\nIf we replace LoopF (u) with Ext-LoopF (u) in (23), the formula is equivalent to SM[F ], as the following theorem states.\nTheorem 3 For any rectified sentence F , the following sentences are equivalent to each other:\n(a) SM[F ];\n(b) F \u2227 \u2200u((u \u2264 p) \u2227Nonempty(u)\u2192 \u00acNSESF (u));\n(c) F \u2227 \u2200u((u \u2264 p) \u2227 Ext-LoopF (u)\u2192 \u00acNSESF (u)).\nIn the following example we use the following fact to simplify the formulas.\nProposition 5 For any negative formula F , formula\nNSESF (u)\u2194 F\nis logically valid.\nExample 2 (continued) Consider program (7) from Example 2:\np(x)\u2190 q(x) q(y)\u2190 p(y) p(z)\u2190 not r(z).\nLet F be the FOL-representation of the program:\n\u2200x ( q(x)\u2192 p(x) ) \u2227 \u2200y ( p(y)\u2192 q(y) ) \u2227 \u2200z ( \u00acr(z)\u2192 p(z) ) .\n1. SM[F ] is equivalent to\nF \u2227 \u00ac\u2203u1u2u3((u1, u2, u3) < (p, q, r))\u2227 \u2200x(u2(x)\u2192 u1(x)) \u2227 \u2200y(u1(y)\u2192 u2(y)) \u2227 \u2200z(\u00acr(z)\u2192 u1(z)))."}, {"heading": "2. Formula in Theorem 3 (b):", "text": "F \u2227 \u2200u(u \u2264 p \u2227Nonempty(u)\u2192 \u00acNSESF (u))\nis equivalent to\nF \u2227 \u2200u1u2u3((u1, u2, u3) \u2264 (p, q, r) \u2227 (\u2203x u1(x) \u2228 \u2203x u2(x) \u2228 \u2203x u3(x)) \u2192 \u00ac(\u2200x[q(x) \u2227 \u00acu2(x)\u2192 p(x) \u2227 \u00acu1(x)]\n\u2227\u2200y[p(y) \u2227 \u00acu1(y)\u2192 q(y) \u2227 \u00acu2(y)] \u2227\u2200z[\u00acr(z)\u2192 p(z) \u2227 \u00acu1(z)])).\n(27)\n3. Formula in Theorem 3 (c): Similar to (27) except that\n\u2203xu1(x) \u2228 \u2203xu2(x) \u2228 \u2203xu3(x)\nin (27) is replaced with Ext-LoopF (u), which is\nLoopF (u) \u2228 [(\u2203xu1(x) \u2228 \u2203xu2(x) \u2228 \u2203xu3(x)) \u2227 \u2200v1v2v3(((v1, v2, v3) \u2264 (u1, u2, u3)) \u2227 LoopF (v)\n\u2192 (\u2203x(v1(x) \u2227 u2(x) \u2227 \u00acv2(x)) \u2228 \u2203y(v2(y) \u2227 u1(y) \u2227 \u00acv1(y))))],\nwhere LoopF (u) is\n(\u2203xu1(x) \u2228 \u2203xu2(x) \u2228 \u2203xu3(x)) \u2227 \u2200v1v2v3(((\u2203x v1(x) \u2228 \u2203x v2(x) \u2228 \u2203x v3(x)) \u2227 (v1, v2, v3) < (u1, u2, u3)) \u2192 (\u2203x(v1(x) \u2227 u2(x) \u2227 \u00acv2(x)) \u2228 \u2203y(v2(y) \u2227 u1(y) \u2227 \u00acv1(y)))).\nThe proof of Theorem 2 follows from Theorem 3 using the following lemma.\nLemma 3 Let F be a rectified sentence of a signature \u03c3 (possibly containing function constants of positive arity), and let I be an interpretation of \u03c3 that satisfies F . If F is bounded w.r.t. I,\nI |= \u2203u(u \u2264 p \u2227 Ext-LoopF (u) \u2227NSESF (u))\niff there is a finite loop Y of F w.r.t. I such that I |= (\u2227 Y \u2227NESF (Y ) ) ."}, {"heading": "5. Representing First-Order Stable Model Semantics by First-Order", "text": "Loop Formulas\nWe noted in the previous section that if a sentence is bounded w.r.t. a model, then loop formulas can be used to check the stability of the model. In this section, we provide a few syntactic counterparts of the boundedness condition."}, {"heading": "5.1 Bounded Formulas", "text": "We say that a rectified formula F is bounded if every infinite path in the first-order dependency graph of F visits only finitely many vertices. If F is bounded, then, clearly, every loop of F is finite. Again, the definition is extended to a non-rectified formula by first rewriting it as a rectified formula. It also applies to a program by referring to its FOL-representation.\nOne might wonder if the syntactic notion of boundedness ensures the semantic notion of boundedness: that is, if a formula is bounded, then it is bounded w.r.t. any interpretation. However, the following example tells us that this is not the case in general.\nExample 7 Consider the FOL-representation F of the following program\np(a)\u2190 q(x) q(x)\u2190 p(b), (28)\nand an interpretation I whose universe |I| is the set of all nonnegative integers, aI = bI = 0, pI = {0} and qI = |I|. Formula (28) is bounded according to the above definition, but not bounded w.r.t. I: the dependency graph of F w.r.t. I contains an infinite path such as\n\u3008p(0 ), q(1 ), p(0 ), q(2 ), . . . \u3009."}, {"heading": "5.1.1 Bounded Formulas and Clark\u2019s Equational Theory", "text": "On the other hand, such a relationship holds if the interpretation satisfies Clark\u2019s equational theory (1978). Clark\u2019s equational theory of a signature \u03c3, denoted by CET\u03c3, is the union of the universal closures of the following formulas\nf(x1, . . . , xm) 6= g(y1, . . . , yn), (29)\nfor all pairs of distinct function constants f , g,\nf(x1, . . . , xn) = f(y1, . . . , yn)\u2192 (x1 = y1 \u2227 . . . \u2227 xn = yn), (30)\nfor all function constants f of arity > 0, and\nt 6= x, (31)\nwhere t is any term which contains the variable x.\nProposition 6 If a rectified formula F of a signature \u03c3 is bounded, then F is bounded w.r.t. any interpretation of \u03c3 that satisfies CET\u03c3.\nThe following lemma relates loops and loop formulas of different notions of dependency graphs.\nProposition 7 For any rectified sentence F of a signature \u03c3 and for any interpretation I of \u03c3 that satisfies CET\u03c3, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of {LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe following theorem follows from Theorem 2, Proposition 6 and Proposition 7.\nTheorem 4 Let F be a rectified sentence of a signature \u03c3 (possibly containing function constants of positive arity), and let I be an interpretation of \u03c3 that satisfies F and CET\u03c3. If F is bounded, then the following conditions are equivalent to each other:\n(a) I |= SM[F ];\n(b) for every nonempty finite set Y of atoms of \u03c3(F ), I satisfies LFF (Y );\n(c) for every finite first-order loop Y of F , I satisfies LFF (Y ).\nProof. By Proposition 6, if F is bounded then F is bounded w.r.t. any interpretation that satisfies CET\u03c3. Then the equivalence between (a) and (b) follows from the equivalence between (a) and (b) of Theorem 2. The equivalence between (a) and (c) follows from the equivalence between (a) and (c) of Theorem 2 and by Proposition 7.\nAs every Herbrand interpretation of \u03c3 satisfies CET\u03c3, Theorem 4 applies to Herbrand interpretations as a special case.\nThe theorem also applies to logic programs, since they can be viewed as a special case of formulas. For example, consider the following program, which is bounded.\np(f(x))\u2190 q(x) q(x)\u2190 p(x), r(x) p(a) r(a) r(f(a)).\n(32)\nThe set {p(a), p(f(a)), p(f(f(a))), q(a), q(f(a)), r(a), r(f(a))} is an answer set of (32). In accordance with Theorem 4, it is also the Herbrand interpretation of the signature obtained from the program that satisfies the FOL-representation of (32) and the loop formulas, which are the universal closures of\np(z)\u2192 (q(x) \u2227 z = f(x)) \u2228 z = a q(z)\u2192 p(z) \u2227 r(z) r(z)\u2192 z = a \u2228 z = f(a).\nConsider another example program by Bonatti (2004), where a, . . . , z, nil are object constants.\nletter(a) . . . letter(z) atomic([x])\u2190 letter(x) atomic([x|y])\u2190 letter(x), atomic(y).\n(33)\nThe expression [x|y] is a list whose head is x and whose tail is y, which stands for a function cons(x, y). The expression [x] stands for cons(x, nil) where nil is a special symbol for\nthe empty list. This program is bounded. The only answer set of the program is the only Herbrand interpretation of the FOL-representation of (33) and the universal closures of\nletter(u)\u2192 u = a \u2228 . . . \u2228 u = z atomic(u)\u2192 \u2203v (letter(v) \u2227 u = cons(v, nil))\n\u2228 \u2203xy (letter(x) \u2227 atomic(y) \u2227 y 6= u \u2227 u = cons(x, y)).\nIn fact, the definitions of standard list processing predicates, such as member, append, and reverse (Bonatti, 2004, Figure 1) are bounded, so they can be represented by first-order formulas on Herbrand interpretations.12\nWe say that a formula F is atomic-tight if the first-order dependency graph of F has no infinite paths. Every tight sentence is atomic-tight, but not vice versa. For example, the FOL-representations of programs (32) and (33) are atomic-tight, but are not tight. Similar to Proposition 6, if F is atomic-tight, then F is atomic-tight w.r.t. any interpretation that satisfies CET\u03c3, so that the following statement is derived from Corollary 3.\nCorollary 5 Let F be a rectified sentence of a signature \u03c3 (possibly containing function constants of positive arity), and let I be an interpretation of \u03c3 that satisfies F and CET\u03c3. If F is atomic-tight, then I satisfies SM[F ] iff I satisfies SLF[F ].\nThe statement of Corollary 5 is restricted to interpretations that satisfy CET\u03c3. Indeed, the statement becomes wrong if this restriction is dropped. For example, program (28) in Example 7 is atomic-tight, but the non-stable model considered there satisfies all loop formulas, including those of singleton loops."}, {"heading": "5.1.2 Bounded Formulas and Normal Form", "text": "Normal form is another syntactic condition that can be imposed so that the syntactic notion of boundedness ensures the semantic notion of boundedness. We say that a formula is in normal form if every strictly positive occurrence of an atom is of the form p(x), where x is a list of distinct variables. It is clear that every formula can be turned into normal form using equality.\nProposition 8 If a rectified formula F in normal form is bounded, then F is bounded w.r.t. any interpretation.\nProposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of\n{LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe following theorem follows from Theorem 2, Proposition 8 and Proposition 9.\n12. They actually satisfy a stronger condition called \u201cfinitely recursive\u201d (Bonatti, 2004). See Section 8 for more details.\nTheorem 5 Let F be a rectified sentence in normal form (possibly containing function constants of positive arity). If F is bounded, then the following formulas are equivalent to each other:\n(a) SM[F ];\n(b) {F} \u222a {LFF (Y ) | Y is a nonempty finite set of atoms of \u03c3(F )};\n(c) {F} \u222a {LFF (Y ) | Y is a finite first-order loop of F}.\nProof. By Proposition 8, if F is bounded then F is bounded w.r.t. any interpretation I. Then the equivalence between (a) and (b) follows from the equivalence between (a) and (b) of Theorem 2. The equivalence between (a) and (c) follows from the equivalence between (a) and (c) of Theorem 2 and by Proposition 9.\nConsider a program in normal form\np(x)\u2190 x = a, q(a) q(y)\u2190 p(b) (34)\nand an interpretation I such that |I| = {1}, aI = bI = 1 and pI = qI = {1}. This interpretation does not satisfy Clark\u2019s equational theory, and is not a stable model. In accordance with Theorem 5, I does not satisfy the loop formula of the loop {p(b), q(a)}, which is\np(b) \u2227 q(a)\u2192 (b = a \u2227 q(a) \u2227 a 6= a) \u2228 (p(b) \u2227 b 6= b).\nOn the other hand, consider another program in non-normal form that has the same stable models as (34):\np(a)\u2190 q(a) q(y)\u2190 p(b) (35)\nProgram (35) has a finite complete set of loops, {{p(z)}, {q(z)}}; their loop formulas are the universal closures of\np(z)\u2192 z = a \u2227 q(a) q(z)\u2192 p(b)\nand I satisfies all loop formulas. This example illustrates the role of normal form assumption in Theorem 5 (in place of Clark\u2019s equational theory in Theorem 4).\nNote that a normal form conversion may turn a bounded sentence into a non-bounded sentence. For instance, the normal form of the bounded program (32) is\np(y)\u2190 y = f(x), q(x) q(x)\u2190 p(x), r(x) p(x)\u2190 x = a r(x)\u2190 x = a r(x)\u2190 x = f(a),\n(36)\nwhich is not bounded. Unlike in Corollary 5, if a program is in normal form, atomic-tightness is not more general than tightness. It is not difficult to check that a program in normal form is atomictight iff it is tight."}, {"heading": "5.1.3 Decidability of Boundedness and Finite Complete Set of Loops", "text": "In general, checking whether F is bounded is not decidable, but it becomes decidable if F contains no function constants of positive arity. The same is the case for checking whether F is atomic-tight.\nProposition 10 For any rectified sentence F (allowing function constants of positive arity),\n(a) checking whether F is bounded is not decidable;\n(b) checking whether F is atomic-tight is not decidable.\nIf F contains no function constants of positive arity,\n(c) checking whether F is bounded is decidable;\n(d) checking whether F is atomic-tight is decidable.\nThe proof of Proposition 10 (c) is based on the following fact and the straightforward extension of Theorem 2 by Chen et al. (2006) to first-order formulas, which asserts that checking if F has a finite complete set of loops is decidable.\nProposition 11 For any rectified formula F that contains no function constants of positive arity, F is bounded iff F has a finite complete set of loops.\nNote that Proposition 11 does not hold if F is allowed to contain function constants of positive arity. For instance,\np(x)\u2190 p(f(x))\nis not bounded, but has a finite complete set of loops {{p(x)}}. The following corollary follows from Theorem 4 and Proposition 11.\nCorollary 6 Let F be a rectified sentence of a signature \u03c3 that has no function constants of positive arity, and let I be an interpretation of \u03c3 that satisfies F and CET\u03c3. If F has a finite complete set of loops, then conditions (a), (b), and (c) of Theorem 4 are equivalent to each other.\nThe following corollary follows from Theorem 5 and Proposition 11.\nCorollary 7 Let F be a rectified sentence in normal form that has no function constants of positive arity. If F has a finite complete set of loops, formulas in (a), (b), and (c) of Theorem 5 are equivalent to each other."}, {"heading": "5.2 Semi-Safe Formulas", "text": "Semi-safety is another decidable syntactic condition that ensures that SM[F ] can be expressed by first-order sentences.\nWe assume that there are no function constants of positive arity. According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the \u201csmall predicate property\u201d: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F . We will show that any semi-safe sentence under the stable model semantics can be turned into a sentence in first-order logic.\nFirst, we review the notion of semi-safety by Lee et al. (2009).13 As a preliminary step, we assign to every formula F a set RV(F ) of its restricted variables as follows:\n\u2022 For an atomic formula F ,\n\u2013 if F is an equality between two variables, then RV(F ) = \u2205; \u2013 otherwise, RV(F ) is the set of all variables occurring in F ;\n\u2022 RV(G \u2227H) = RV(G) \u222a RV(H);\n\u2022 RV(G \u2228H) = RV(G) \u2229 RV(H);\n\u2022 RV(G\u2192 H) = \u2205;\n\u2022 RV(QvG) = RV(G) \\ {v} where Q \u2208 {\u2200,\u2203}.\nWe say that a variable x is restricted in F if x \u2208 RV(F ). A rectified formula F is semisafe if every strictly positive occurrence of every variable x belongs to a subformula G\u2192 H where x is restricted in G.\nIf a sentence has no strictly positive occurrence of a variable, then it is obviously semisafe. The FOL-representation of a disjunctive program is semi-safe if, for each rule (10) of the program, every variable occurring in the head of the rule occurs in B as well.\nExample 8 The FOL-representation of (8) is not semi-safe. Formula\np(a) \u2227 q(b) \u2227 \u2200xy((p(x) \u2228 q(y))\u2192 p(y))\nis not semi-safe, while\np(a) \u2227 q(b) \u2227 \u2200xy((p(x) \u2227 q(y))\u2192 p(y)) (37)\nis semi-safe.\nFor any finite set c of object constants, inc(x) stands for the formula\u2228 c\u2208c x = c.\n13. The definition here is slightly more general in that it does not refer to prenex form. Instead we require a formula to be rectified.\nThe small predicate property can be expressed by the conjunction of the sentences \u2200v1, . . . , vn ( p(v1, . . . , vn)\u2192 \u2227 i=1,...,n inc(vi) )\nfor all predicate constants p occurring in F , where v1, . . . , vn are distinct variables. We denote this conjunction of the sentences by SPPc. By c(F ) we denote the set of all object constants occurring in F .\nProposition 12 (Lee et al., 2009) For any semi-safe sentence F , formula SM[F ] entails SPPc(F ).\nFor example, for the semi-safe sentence (37), SM[(37)] entails \u2200x ( p(x)\u2192 (x = a \u2228 x = b)) \u2227 \u2200x(q(x)\u2192 (x = a \u2228 x = b) ) . (38)\nThe following proposition tells us that for a semi-safe sentence F , formula SM[F ] can be equivalently rewritten as a first-order sentence.\nTheorem 6 Let F be a rectified sentence that has no function constants of positive arity. If F is semi-safe, then SM[F ] is equivalent to the conjunction of F , SPPc(F ) and a finite number of first-order loop formulas.\nProof. If F is semi-safe, then SM[F ] entails SPPc(F ). So it is sufficient to prove that under the assumption SPPc(F ), SM[F ] is equivalent to the conjunction of F and a finite number of first-order loop formulas. It follows from I |= SPPc(F ) that F is bounded w.r.t. I. Since every finite loop of F w.r.t. I can be represented by a finite set of atoms whose terms are object variables, it follows from Theorem 2 that I satisfies SM[F ] iff I satisfies the loop formulas of those sets.\nFor example, SM[(37)] is equivalent to the conjunction of F , (38) and the universal closures of\np(z) \u2192 z = a \u2228 (p(x) \u2227 q(z) \u2227 z 6= x) q(z) \u2192 z = b\nNote that the condition on a finite complete set of loops in Corollaries 6 and 7, and the condition on semi-safety in Theorem 6 do not entail each other. For instance, formula (37) is semi-safe, but has no finite complete set of first-order loops, while \u2203x p(x) has a finite complete set of loops {{p(x)}}, but it is not semi-safe. Also program \u03a01 in Section 1 has a finite complete set of loops, but it is not semi-safe due to w in the fourth rule."}, {"heading": "6. Programs with Explicit Quantifiers", "text": "In the following we extend the syntax of a logic program by allowing explicit quantifiers. A rule with quantifiers is of the form\nH \u2190 G, (39)\nwhere G and H are first-order formulas such that every occurrence of every implication in G and H belongs to a negative formula. A program with quantifiers is a finite set of rules\nwith quantifiers. Program \u03a01 in Section 1 is an example. The semantics of such a program is defined by identifying the program with its FOL-representation under the stable model semantics. By restricting the syntax of a program like the one above, in comparison with the syntax of an arbitrary formula, we are able to write a more succinct loop formulas, as we show below.\nLet F be a formula and Y a finite set of atoms. By FY we denote the formula obtained from F by replacing every occurrence of every atom p(t) in F that does not belong to a negative formula with p(t) \u2227 \u2227 p(t\u2032)\u2208Y t 6= t\u2032. Let \u03a0 be a program with quantifiers. Given a finite set Y of atoms of \u03c3(\u03a0), we first rename variables in \u03a0 so that no variables in \u03a0 occur in Y . We define the formula QES \u03a0(Y ) (\u201cExternal Support Formula for Programs with Quantifiers\u201d) to be the disjunction of\n\u2203z(GY \u2227 \u00acHY ) (40)\nfor every rule (39) such that H contains a strictly positive occurrence of a predicate constant that occurs in Y , and z is the list of all free variables in the rule that do not occur in Y .\nThe loop formula of Y for \u03a0 is the universal closure of\u2227 Y \u2192 QES \u03a0(Y ). (41)\nThe following proposition tells us that (41) is equivalent to (12) when the notions are applied to a program with explicit quantifiers. It also shows that (41) is a generalization of the definition of a loop formula for a disjunctive program.\nProposition 13 Let \u03a0 be a program with quantifiers, F the FOL-representation of \u03a0, and Y a finite set of atoms. Under the assumption \u03a0, formula QES \u03a0(Y ) is equivalent to \u00acNESF (Y ). If \u03a0 is a disjunctive program in normal form, then QES \u03a0(Y ) is also equivalent to ES \u03a0(Y ) under the assumption \u03a0.\nNote that the size of (41) for each Y is polynomial to the size of the given program. This is not the case when we apply (12) to the FOL-representation of the program, due to the expansion of NES for nested implications. On the other hand, the syntactic condition imposed on the rule with quantifiers avoids such an exponential blow up, as the following lemma tells us.\nLemma 4 Let F be a formula such that every occurrence of an implication in F belongs to a negative formula and let Y be a set of atoms. NESF (Y ) is equivalent to FY .\nProof. By induction on F .\nExample 2 (continued) First-Order Loop Formula when \u03a0 is understood as an extended program (Using QES\u03a0(Y )) : Under the assumption \u03a0,\n\u2022 LF \u03a0(Y1) is equivalent to the universal closure of\np(u)\u2192 (\u2203x(q(x) \u2227 \u00ac(p(x) \u2227 x 6= u)) \u2228 \u2203z(\u00acr(z) \u2227 \u00ac(p(z) \u2227 z 6= u))).\n\u2022 LF \u03a0(Y2) is equivalent to the universal closure of\nq(u)\u2192 \u2203y(p(y) \u2227 \u00ac(q(y) \u2227 y 6= u)).\n\u2022 LF \u03a0(Y3) is equivalent to the universal closure of\nr(u)\u2192 \u22a5.\n\u2022 LF \u03a0(Y4) is equivalent to the universal closure of\n(p(u) \u2227 q(u))\u2192 (\u2203x((q(x) \u2227 x 6= u) \u2227 \u00ac(p(x) \u2227 x 6= u)) \u2228 \u2203y((p(y) \u2227 y 6= u) \u2227 \u00ac(q(y) \u2227 y 6= u)) \u2228 \u2203z(\u00acr(z) \u2227 \u00ac(p(z) \u2227 z 6= u))).\nA finite set \u0393 of sentences entails a sentence F under the stable model semantics (symbolically, \u0393 |=SM F ), if every stable model of \u0393 satisfies F .\nIf SM[F ] can be reduced to a first-order sentence, as described in Theorem 5 and Theorem 6, then\n\u0393 |=SM F iff \u0393 \u222a\u2206 |= F,\nwhere \u2206 is the set of first-order loop formulas required (and possibly including SPPc(F ) when Theorem 6 is applied). This fact allows us to use first-order theorem provers to reason about query entailment under the stable model semantics.\nExample 9 Consider program \u03a01 in Section 1, which has the following finite complete set of loops: {Man(u)}, {Spouse(u, v)}, {HasWife(u)}, {Married(u)}, {Accident(u, v)}, {Discount(u, v)}, and {HasWife(u),Married(u)}. Their loop formulas for \u03a01\u222a\u03a02\u222a\u03a03 are equivalent to the universal closure of\nMan(u)\u2192 \u00ac ( Man(John) \u2227 John 6= u ) ; Spouse(u, v)\u2192 \u00ac ( \u2203y ( Spouse(John, y) \u2227 (John, y) 6= (u, v) )) ; HasWife(u)\u2192 \u2203x ( \u2203y Spouse(x, y) \u2227 \u00ac(HasWife(x) \u2227 x 6= u)\n) \u2228 \u2203x ( Man(x) \u2227Married(x) \u2227 \u00ac(HasWife(x) \u2227 x 6= u) ) ;\nMarried(u)\u2192 \u2203x ( Man(x) \u2227HasWife(x) \u2227 \u00ac(Married(x) \u2227 x 6= u) ) ;\nAccident(u, v)\u2192 \u22a5;\nDiscount(u, v)\u2192 \u2203x ( Married(x) \u2227 \u00ac\u2203zAccident(x, z) \u2227 \u00ac(\u2203w(Discount(x,w) \u2227 (x,w) 6= (u, v))) ) ;\nMarried(u) \u2227HasWife(u)\u2192 \u2203x ( \u2203y Spouse(x, y) \u2227 \u00ac(HasWife(x) \u2227 (x 6= u)) ) \u2228 \u2203x ( Man(x) \u2227Married(x) \u2227 x 6= u \u2227 \u00ac(HasWife(x) \u2227 x 6= u)\n) \u2228 \u2203x ( Man(x) \u2227HasWife(x) \u2227 x 6= u \u2227 \u00ac(Married(x) \u2227 x 6= u) ) .\nThese loop formulas, conjoined with the FOL-representation of \u03a01 \u222a \u03a02 \u222a \u03a03, entail under first-order logic each of \u2203x Married(x) and \u2200xy(Discount(x, y) \u2192 x = John). We verified the answers using a first-order theorem prover Vampire 14."}, {"heading": "7. Extension to Allow Extensional Predicates", "text": "The definition of a stable model in the journal paper by Ferraris et al. (2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al., 2007) in that it allows us to distinguish between intensional and non-intensional (a.k.a. extensional) predicates. Similar to Datalog, intensional (output) predicates are characterized in terms of extensional (input) predicates. For instance, consider Example 9 again, but now assume that Man and Spouse are non-intensional. \u03a01\u222a\u03a02\u222a\u03a03 still entails \u2203xyDiscount(x, y) but no longer entails \u2200xy(Discount(x, y)\u2192 x = John) because there may be a person other than John who has a spouse.\nThe results in the earlier sections can be extended to this general semantics in view of Proposition 14 below, which characterizes SM[F ; p] in terms of SM[F ]. By pr(F ) we denote the list of all predicate constants occurring in F ; by Choice(p) we denote the conjunction of \u201cchoice formulas\u201d \u2200x(p(x) \u2228 \u00acp(x)) for all predicate constants p in p, where x is a list of distinct object variables; by False(p) we denote the conjunction of \u2200x\u00acp(x) for all predicate constants p in p. We sometimes identify a list with the corresponding set when there is no confusion.\nProposition 14 For any list p of predicate constants, formula SM[F ; p] is equivalent to\nSM[F \u2227 Choice(pr(F )\\p) \u2227 False(p\\pr(F ))] (42)\nand to\nSM[F\u00ac\u00ac \u2227 Choice(pr(F )\\p) \u2227 False(p\\pr(F ))], (43)\nwhere F\u00ac\u00ac is obtained from F by replacing every atom of the form q(t) in F such that q does not belong to p by \u00ac\u00acq(t).\nThis proposition allows us to extend the results established for SM[F ] to SM[F ; p]. For instance, Theorem 3 can be extended to SM[F ; p] by first rewriting it into the form SM[G], where G is\nF\u00ac\u00ac \u2227 Choice(pr(F )\\p) \u2227 False(p\\pr(F )). (44)\nIn the next three corollaries, \u03c3 is a signature, F is a rectified sentence of \u03c3 (possibly containing function constants of positive arity), p is any finite list of predicate constants from \u03c3, and G is (44).\nThe first corollary follows from Theorem 2 and Proposition 14.\nCorollary 8 For any interpretation I of \u03c3 that satisfies F , if G is bounded w.r.t. I, then the following conditions are equivalent to each other:\n(a) I |= SM[F ; p];\n14. http://www.vampire.fm .\n(b) for every nonempty finite set Y of atoms formed from predicate constants in p and object names for |I|, I satisfies LFF (Y );\n(c) for every finite loop Y of G w.r.t. I whose predicate constants are contained in p, I satisfies LFF (Y ).\nThe next corollary follows from Theorem 4 and Proposition 14.\nCorollary 9 If G is bounded, then, for any interpretation I of \u03c3 that satisfies F and CET\u03c3, the following conditions are equivalent to each other:\n(a) I |= SM[F ; p];\n(b) for every nonempty finite set Y of atoms of \u03c3(G) whose predicate constants are contained in p, I satisfies LFF (Y );\n(c) for every finite first-order loop Y of G whose predicate constants are contained in p, I satisfies LFF (Y ).\nThe last corollary follows from Theorem 5 and Proposition 14.\nCorollary 10 If G is in normal form and is bounded, then the following formulas are equivalent to each other:\n(a) SM[F ; p];\n(b) {F} \u222a {LFF (Y ) | Y is a nonempty finite set of atoms of \u03c3(G) whose predicate constants are contained in p};\n(c) {F} \u222a {LFF (Y ) | Y is a finite first-order loop of G whose predicate constants are contained in p}.\nExample 10 Consider Example 9 again, assuming that Man and Spouse are extensional. Let F be the FOL-presentation of \u03a01 \u222a \u03a02 \u222a \u03a03 and let G be the formula (44). The loops of G are the same as the loops of F . The loop formulas remain the same as before except for the following loop formulas of Man(u) and Spouse(u, v):\nMan(u)\u2192 \u00ac ( Man(John) \u2227 John 6= u ) \u2228 \u2203x\u00ac ( (Man(x) \u2227 x 6= u) \u2228 \u00acMan(x) ) ; Spouse(u, v)\u2192 \u00ac ( \u2203y ( Spouse(John, y) \u2227 (John, y) 6= (u, v) )) \u2228\n\u2203xy \u00ac ( (Spouse(x, y) \u2227 (x, y) 6= (u, v)) \u2228 \u00acSpouse(x, y) ) .\nThese two formulas are tautologies. As a result, the loop formulas of all loops, conjoined with G, entail \u2203xyDiscount(x, y), but no longer entail \u2200xy (Discount(x, y)\u2192 x = John).\nIn general, there are no loops of G that contain both intensional and extensional predicates. Also every loop of G that contains an extensional predicate is a singleton, and the loop formula of such a loop is a tautology.\nCorollary 3 is extended to allow extensional predicates as in the following. By SLF[F ; p], we denote\n{LFF ({p(x)}) | p is a predicate constant in p, and x is a list of distinct object variables whose length is the same as the arity of p}.\nWe say that a formula F is p-atomic-tight w.r.t. I if every infinite path in the dependency graph of F w.r.t. I whose vertices are satisfied by I contains an atom whose predicate constant is not in p.\nCorollary 11 Let F be a rectified sentence (possibly containing function constants of positive arity), and let I be a model of F . If F is p-atomic-tight w.r.t. I, then I satisfies SM[F ; p] iff I satisfies SLF[F ; p].\nThe definition of semi-safety is extended to distinguish between intensional and nonintensional predicates as follows. Let F be a formula that has no function constants of positive arity. To every first-order formula F we assign a set RVp(F ) of restricted variables relative to p as follows.\n\u2022 For an atomic formula F (including equality and \u22a5),\n\u2013 if F is an equality between two variables, or is an atom whose predicate constant is not in p, then RVp(F ) = \u2205;\n\u2013 otherwise, RVp(F ) is the set of all variables occurring in F ;\n\u2022 RVp(G \u2227H) = RVp(G) \u222a RVp(H);\n\u2022 RVp(G \u2228H) = RVp(G) \u2229RVp(H);\n\u2022 RVp(G\u2192 H) = \u2205.\n\u2022 RVp(QvG) = RVp(G) \\ {v} where Q \u2208 {\u2200, \u2203}.\nWe say that a variable x is p-restricted in F if x \u2208 RVp(F ). A rectified formula F is semi-safe relative to p if every strictly positive occurrence of every variable x belongs to a subformula G\u2192 H, where x is p-restricted in G.\nThe small predicate property is generalized as follows. Formula SPPpc is the conjunction of the sentences \u2200v1, . . . , vn ( p(v1, . . . , vn)\u2192 \u2227 i=1,...,n inc(vi) )\nfor all predicate constants p in p, where v1, . . . , vn are distinct variables.\nProposition 15 (Lee et al., 2009) For any semi-safe sentence F relative to p, formula SM[F ; p] entails SPPpc(F ).\nThe following proposition tells us that for a semi-safe sentence F , formula SM[F ; p] can be equivalently rewritten as a first-order sentence.\nTheorem 7 Let F be a rectified sentence that has no function constants of positive arity. If F is semi-safe relative to p, then SM[F ; p] is equivalent to the conjunction of F , SPPpc(F ) and a finite number of first-order loop formulas.\nProof. Let F be a sentence of the signature \u03c3. If F is semi-safe relative to p, then SM[F ; p] entails SPPpc(F ), so it is sufficient to prove that under the assumption SPP p c(F ), SM[F ; p] is equivalent to the conjunction of F and a finite number of first-order loop formulas. By Proposition 14, SM[F ; p] is equivalent to SM[G], where G is (44). Consider any interpretation I of \u03c3 that satisfies G and SPPpc(F ). Note that the dependency graph of G w.r.t. I contains no outgoing edges from a vertex whose predicate constant does not belong to p. Together with the fact that I |= SPPpc(F ), we conclude that each path in the dependency graph whose vertices are satisfied by I visits only finitely many vertices. Consequently, G is bounded w.r.t. I. Since every finite loop of G w.r.t. I can be represented by a finite set of atoms whose terms are object variables, it follows from Theorem 2 that I satisfies SM[G] iff I satisfies the loop formulas of those sets."}, {"heading": "8. Related Work", "text": "The notion of a bounded program is related to the notion of a finitely recursive program studied by Bonatti (2004), where a different definition of a dependency graph was considered. The atom dependency graph of a nondisjunctive ground program defined by Bonatti is a directed graph such that the vertices are the set of ground atoms, and the edges go from the atom in the head to atoms in the body of every rule, including those in the negative body. A program is called finitely recursive if, for every atom, there are only finitely many atoms reachable from it in the atom dependency graph. It is clear that every finitely recursive program is bounded, but the converse does not hold. For instance, the program\np(x)\u2190 not p(f(x))\nis bounded, but is not finitely recursive because there are infinite paths that involve negative edges. Also the program\np(a)\u2190 q(f(x))\nis bounded, but is not finitely recursive because infinitely many atoms q(f(a)), q(f(f(a))), . . . can be reached from p(a) in the atom dependency graph. Like bounded programs, checking finitely recursive programs is undecidable in the presence of function constants of positive arity.\nLin and Wang (2008) extended answer set semantics with functions by extending the definition of a reduct, and also provided loop formulas for such programs. We can provide an alternative account of their results by considering the notions there as special cases of the definitions presented in this paper. For simplicity, we assume non-sorted languages.15 Essentially, they restricted attention to a special case of non-Herbrand interpretations such that object constants form the universe, and ground terms other than object constants are mapped to object constants. According to Lin and Wang, an LW-program P consists of\n15. Lin and Wang (2008) consider essentially many-sorted languages. The result of this section can be extended to that case by considering many-sorted SM (Kim, Lee, & Palla, 2009).\ntype definitions and a set of rules. Type definitions introduce the domains for a many-sorted signature consisting of some object constants, and includes the evaluation of each function symbol of positive arity that maps a list of object constants to an object constant. Since we assume non-sorted languages, we consider only a single domain (universe). We say that an interpretation I is a P -interpretation if the universe is the set of object constants specified by P , object constants are evaluated to itself, and ground terms other than object constants are evaluated conforming to the type definitions of P .\nProposition 16 Let P be an LW-program and let F be the FOL-representation of the set of rules in P . The following conditions are equivalent to each other:\n(a) I is an answer set of P according to Lin and Wang (2008);\n(b) I is a P -interpretation that satisfies SM[F ];\n(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.r.t. I.\nThe equivalence between (b) and (c) follows from Proposition 2 since the universe is finite. The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c).\nSince the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels. Chen, Lin, Zhang, and Zhou (2011) present a condition called \u201cloop-separable,\u201d which is more refined than finite complete set of loops under which the finite answer sets of a program can be captured by first-order sentences. However, like the condition of finite complete set of loops, this condition is disjoint with semi-safety. The following program is semi-safe but not loop-separable:\np(x)\u2190 p(y), q(x, y).\nHowever, all this work is limited to nondisjunctive programs that contain no function constants of positive arity. Our work is not limited to finite structures, and considers function constants of positive arity as well. Nonetheless the above papers on first-order definability are closely related to our work and more insights would be gained from the relationship between them.\nThe use of first-order theorem provers for the stable model semantics was already investigated by Sabuncu and Alpaslan (2007), but their results are limited in several ways. They\nconsidered nondisjunctive logic programs with \u201ctrivial\u201d loops only, in which case the stable model semantics is equivalent to the completion semantics. They also restricted attention to Herbrand models."}, {"heading": "9. Conclusion", "text": "This paper puts first-order loop formulas in the context of first-order reasoning and studies how they are related to first-order stable model semantics. The similarities and mismatches found in this paper provide useful insights into first-order reasoning with stable models. Future work is to find further restrictions that make first-order stable model reasoning decidable and computable in an efficient manner, like the conditions imposed in \u201cfinitary\u201d programs (Bonatti, 2004). Recently, the first-order stable model semantics was shown to be used as a unifying nonmonotonic logic for integrating rules and ontologies (de Bruijn, Pearce, Polleres, & Valverde, 2010; Lee & Palla, 2011), in which ontology predicates are identified with extensional predicates. Based on the studied relationship between first-order stable model semantics and first-order loop formulas, one may find further restrictions that are tailored to the hybrid knowledge bases for efficient computation."}, {"heading": "Acknowledgments", "text": "We are grateful to Joseph Babb, Michael Bartholomew, Piero Bonatti, Vladimir Lifschitz, and Ravi Palla for useful discussions, and to the anonymous referees for their useful comments. The authors were partially supported by the National Science Foundation under Grant IIS-0916116 and by the IARPA SCIL program."}, {"heading": "Appendix A. Proofs", "text": "The proofs are presented in the order of dependencies. Theorem 3 is the main theorem. The proof of Theorem 2 uses Theorem 3. The proofs of Theorems 4 and 5 follow from Theorem 2. The proof of Lemma 1 follows from Proposition 13.\nIn the following, unless otherwise noted, F is a rectified first-order sentence, p is the list of distinct predicate constants p1, . . . , pn occurring in F , symbols u, v are lists of distinct predicate variables of the same length as p, and symbols q, r are lists of distinct predicate names of the same length as p."}, {"heading": "A.1 Proof of Theorem 3", "text": "Theorem 3 For any rectified sentence F , the following sentences are equivalent to each other:\n(a) SM[F ];\n(b) F \u2227 \u2200u((u \u2264 p) \u2227Nonempty(u)\u2192 \u00acNSESF (u));\n(c) F \u2227 \u2200u((u \u2264 p) \u2227 Ext-LoopF (u)\u2192 \u00acNSESF (u)).\nThe notation that we use in the proof involves predicate expressions (Lifschitz, 1994, Section 3.1) of the form\n\u03bbxF (x), (45)\nwhere F (x) is a formula. If e is (45) and G(p) is a formula containing a predicate constant p of the same arity as the length of x then G(e) stands for the result of replacing each atomic part of the form p(t) in G(p) with F (t), after renaming the bound variables in G(p) in the usual way, if necessary. For instance, if G(p) is p(a) \u2228 p(b) then G(\u03bby(x = y)) is x = a \u2228 x = b. Substituting a tuple e of predicate expressions for a tuple p of predicate constants is defined in a similar way.\nLemma 5 Let v be the list of \u03bbyi(pi(y i) \u2227 \u00acui(yi)). The following formulas are logically valid:\n\u2022 u \u2264 p\u2192 (F \u2217(u)\u2194 NSESF (v));\n\u2022 u \u2264 p\u2192 (F \u2217(v)\u2194 NSESF (u)).\nProof. By induction."}, {"heading": "A.1.1 Proof of Equivalence between (a) and (b) of Theorem 3", "text": "It is sufficient to show that\n\u2203u(u < p \u2227 F \u2217(u))\nis equivalent to\n\u2203v(v \u2264 p \u2227Nonempty(v) \u2227NSESF (v)).\nFrom left to right: Take u such that u<p\u2227F \u2217(u). Let v be the list of \u03bbyi(pi(yi) \u2227 \u00acui(yi)).\n\u2022 Clearly, v \u2264 p holds.\n\u2022 From u < p, it follows that there are x and i such that pi(x) \u2227 \u00acui(x), from which\u2228 i \u2203xivi(xi) follows, so that Nonempty(v) follows.\n\u2022 By Lemma 5, NSESF (v) follows from u < p and F \u2217(u).\nFrom right to left: Take v such that v \u2264 p\u2227Nonempty(v)\u2227NSESF (v). Let u be the list of \u03bbyi(pi(y i) \u2227 \u00acvi(yi)).\n\u2022 Clearly, u \u2264 p holds. Moreover \u00ac(u = p) holds. Indeed, if u = p, then \u2200xi\u00acvi(xi) follows, which contradicts the assumption Nonempty(v). Consequently, u < p follows.\n\u2022 By Lemma 5, F \u2217(u) follows from v \u2264 p and NSESF (v)."}, {"heading": "A.1.2 Proof of Proposition 3", "text": "Lemma 6 Let I be an interpretation of \u03c3 that contains \u03c3(F ), and let q, r be lists of predicate names corresponding to p. Let Z and Y be sets of atoms in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be )\nand\npi(\u03be ) \u2208 Z iff I |= ri(\u03be ),\nwhere \u03be is a list of object names. Then\nI |= r \u2264 q \u2227 EF (r,q)\niff Z is a subset of Y and there is an edge from an atom in Z to an atom in Y \\ Z in the dependency graph of F w.r.t. I.\nProof. From left to right: Assume I |= r \u2264 q \u2227 EF (r,q). The fact that Z is a subset of Y follows from the assumption that I |= r \u2264 q and the construction of Z and Y . Since\nI |= \u2228\n(pi(t),pj(t \u2032)) : pi(t) depends on pj(t\u2032)\nin a rule of F\n\u2203z(ri(t) \u2227 qj(t\u2032) \u2227 \u00acrj(t\u2032)),\nwhere z is the list of all object variables in t and t\u2032, there is a substitution \u03b8 that maps object variables in t and t\u2032 to object names such that\nI |= \u2228\n(pi(t),pj(t \u2032)) : pi(t) depends on pj(t\u2032)\nin a rule of F\nri(t\u03b8) \u2227 qj(t\u2032\u03b8) \u2227 \u00acrj(t\u2032\u03b8).\nConsequently, there are atoms pi(t), pj(t \u2032) such that pi(t) depends on pj(t \u2032) in a rule of F and I |= ri(t\u03b8)\u2227qj(t\u2032\u03b8)\u2227\u00acrj(t\u2032\u03b8). From I |= ri(t\u03b8) and the construction of Z, it follows that pi(((t\u03b8)\nI) ) belongs to Z. Also from I |= qj(t\u2032\u03b8)\u2227\u00acrj(t\u2032\u03b8), it follows that that pj(((t\u2032\u03b8)I) ) belongs to Y \\Z. Therefore, there is an edge from an atom in Z to an atom in Y \\Z in the dependency graph of F w.r.t. I.\nFrom right to left: Assume that Z is a subset of Y and there is an edge from an atom pi(\u03be ) in Z to an atom pj(\u03b7 ) in Y \\ Z in the dependency graph of F w.r.t. I. Clearly, I |= r \u2264 q. From the assumption that pi(\u03be\n) \u2208 Z, pj(\u03b7 ) \u2208 Y \\Z and the construction of Y and Z, it follows that I |= ri(\u03be ) \u2227 qj(\u03b7 ) \u2227 \u00acrj(\u03b7 ). From the definition of the dependency graph w.r.t. I, it follows that there are pi(t), pj(t \u2032) such that pi(t) depends on pj(t \u2032) in a rule of F with a substitution \u03b8 that maps object variables in t and t\u2032 to object names such that (t\u03b8)I = \u03be and (t\u2032\u03b8)I = \u03b7.\nConsequently, I |= \u2228\n(pi(t),pj(t \u2032)) : pi(t) depends on pj(t\u2032)\nin a rule of F\nri(t\u03b8) \u2227 qj(t\u2032\u03b8) \u2227 \u00acrj(t\u2032\u03b8),\nwhich is equivalent to saying that I |= \u2228\n(pi(t),pj(t \u2032)) : pi(t) depends on pj(t\u2032)\nin a rule of F\n\u2203z(ri(t) \u2227 qj(t\u2032) \u2227 \u00acrj(t\u2032)),\nwhere z is the list of all variables in t and t\u2032.\nLemma 7 A graph (V,E) is strongly connected iff, for any nonempty proper subset U of V , there is an edge from U to V \\ U .\nProof. Follows from the definition of a strongly connected graph.\nProposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be ),\nwhere \u03be is a list of object names. Then I |= LoopF (q) iff Y is a loop of F w.r.t. I.\nProof. From left to right: Assume that I |= LoopF (q). From I |= Nonempty(q), it follows that Y is nonempty.\nTake any nonempty proper subset Z of Y . Let r be the list of predicate names such that\nI |= ri(\u03be ) iff pi(\u03be ) \u2208 Z.\nIt is clear that I |= Nonempty(r) \u2227 r < q.\nConsequently, from I |= LoopF (q), it follows that I |= EF (r,q). By Lemma 6, there is an edge from an atom in Z to an atom in Y \\ Z. Consequently, by Lemma 7, Y induces a strongly connected subgraph and thus a loop of F w.r.t. I.\nFrom right to left: Let Y be loop of F w.r.t. I and q a list of predicate names such that\nI |= qi(\u03be ) iff pi(\u03be ) \u2208 Y.\nSince Y is nonempty, I |= Nonempty(q). Consider any list of predicate names r such that\nI |= Nonempty(r) \u2227 r < q.\nLet Z be a set of vertices in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Z iff I |= ri(\u03be ).\nClearly, Z is a nonempty proper subset of Y . Since Y induces a strongly connected subgraph, by Lemma 7, there is an edge from an atom in Z to an atom in Y \\ Z. Consequently by Lemma 6, I |= EF (r,q)."}, {"heading": "A.1.3 Proof of Proposition 4", "text": "Proposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be ),\nwhere \u03be is a list of object names. Then\nI |= Nonempty(q) \u2227 \u2200v((v \u2264 q) \u2227 LoopF (v)\u2192 EF (v,q))\niff Y is an unbounded set of F w.r.t. I.\nProof. From left to right: Assume\nI |= Nonempty(q) \u2227 \u2200v(v \u2264 q \u2227 LoopF (v)\u2192 EF (v,q)). (46)\nSince I |= Nonempty(q), it is clear that Y is nonempty. Take any subset Z of Y that is a loop of F w.r.t. I. Let r be a list of predicate names such that\nI |= ri(\u03be ) iff pi(\u03be ) \u2208 Z.\nSince Z is a subset of Y , it is clear that I |= r \u2264 q. Since Z is a loop of F w.r.t. I, by Proposition 3, I |= LoopF (r). Consequently, from (46) it follows that I |= EF (r,q). By Lemma 6, there is an edge from an atom in Z to an atom in Y \\ Z. Therefore, Y is an unbounded set of F w.r.t. I.\nFrom right to left: Let Y be an unbounded set of F w.r.t. I. Since Y is nonempty, it is clear that I |= Nonempty(q).\nTake any list of predicate names r such that I |= r \u2264 q \u2227 LoopF (r). Let Z be a set of vertices in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Z iff I |= ri(\u03be ).\nBy Proposition 3, Z is a loop of F w.r.t. I. It is clear that Z is a subset of Y . Since Y is an unbounded set of F w.r.t. I, there is an edge from Z to Y \\Z. Consequently by Lemma 6, I |= EF (r,q)."}, {"heading": "A.1.4 Proof of Proposition 5", "text": "Proposition 5 For any negative formula F , formula\nNSESF (u)\u2194 F\nis logically valid.\nProof. The proof follows immediately from the following two lemmas, which can be proved by induction.\nLemma 8 For any formula F , NSESF (u)\u2192 F\nis logically valid.\nLemma 9 Let F be a formula, and let SF be the set of pi(t) that has a strictly positive occurrence in F . Formula\nF \u2227 \u2227\npi(t)\u2208SF\n\u2200z\u00acvi(t)\u2192 NSESF (v) (47)\nis logically valid, where z is the tuple of variables in t that are not free in F ."}, {"heading": "A.1.5 Proof of Equivalence between (b) and (c) of Theorem 3", "text": "Lemma 10 Let F be a rectified formula, let S+F be the set of all atoms pi(t) that have a positive occurrence in F that does not belong to a negative formula, and let S\u2212F be the set of all atoms pi(t) that have a negative occurrence in F that does not belong to a negative formula.16 The following formulas are logically valid, where z is the list of all variables in t that are not free in F .\n(a) (v \u2264 u) \u2227 \u2227 pi(t)\u2208S+F \u2200z(ui(t)\u2192vi(t)) \u2227NSESF (v)\u2192NSESF (u);\n(b) (v \u2264 u) \u2227 \u2227 pi(t)\u2208S\u2212F \u2200z(ui(t)\u2192vi(t)) \u2227NSESF (u)\u2192NSESF (v).\nProof. Both parts are proved simultaneously by induction on F .\nCase 1: F is an atom pi(t).\nPart (a): NSESF (v) entails NSESF (u) under the assumption\u2227 pi(t)\u2208S+F \u2200z(ui(t)\u2192vi(t)).\nPart (b): NSESF (u) entails NSESF (v) under the assumption v \u2264 u.\nCase 2: F is \u22a5 or an equality. It is clear since NSESF (v) and NSESF (u) are the same as F .\nCase 3: F is G \u2227H or G \u2228H. Follows from I.H.\nCase 4: F is G\u2192 H. Part (a): Assume\n(v \u2264 u) \u2227 \u2227\npi(t)\u2208S+F\n\u2200z(ui(t)\u2192 vi(t)). (48)\nWe need to show that\n(NSESG(v)\u2192 NSESH(v)) \u2227 (G\u2192 H)\n16. Note that we distinguish between formula being negative and an occurrence being negative. See at the end of Section 2.\nentails (NSESG(u)\u2192 NSESH(u)) \u2227 (G\u2192 H). Note that \u2227 pi(t)\u2208S\u2212G \u2200z(ui(t)\u2192 vi(t)) and \u2227 pi(t)\u2208S+H \u2200z(ui(t)\u2192 vi(t))\nare entailed by formula (48). By I.H., NSESG(u) entails NSESG(v) and NSESH(v) entails NSESH(u).\nPart (b): Similar to Part (a).\nCase 5: F is \u2200xG Part (a): Assume\n(v \u2264 u) \u2227 \u2227\npi(t)\u2208S+F\n\u2200z(ui(t)\u2192vi(t)) \u2227 \u2200xNSESG(v).\nFrom the assumption NSESG(v), G follows by Lemma 8. Also\u2227 pi(t)\u2208S+G \u2200z\u2032(ui(t)\u2192vi(t))\nfollows, where z\u2032 is the list of all variables in t that are not free in G, so that by I.H. on G, NSESG(u) holds from the assumption. Since x is not free in the assumption, \u2200xNSESG(u) holds as well.\nPart (b): Similar to Part (a).\nCase 6: F is \u2203x G. Part (a): Assume\n(v \u2264 u) \u2227 \u2227\npi(t)\u2208S+F\n\u2200z(ui(t)\u2192vi(t)) \u2227 \u2203xNSESG(v). (49)\nTake x such that\n(v \u2264 u) \u2227 \u2227\npi(t)\u2208S+F\n\u2200z(ui(t)\u2192vi(t)) \u2227NSESG(v). (50)\nFrom NSESG(v), by Lemma 8, G follows. Also\u2227 pi(t)\u2208S+G \u2200z\u2032(ui(t)\u2192vi(t))\nfollows, where z\u2032 is the list of all variables in t that are not free in G. By I.H. on G, NSESG(u) holds under the assumption (50). Consequently, \u2203xNSESG(u) holds from the\nsame assumption. Since x is not free in (49), we conclude that \u2203xNSESG(u) holds from the assumption (49).\nPart (b): Similar to Part (a).\nLemma 11 For any rectified formula F ,\n(v \u2264 u) \u2227 \u00acEF (v,u) \u2227NSESF (u)\u2192 NSESF (v)\nis logically valid.\nProof. By induction on F .\nCase 1: F is an atom pi(t). NSESF (u) entails NSESF (v) under the assumption v \u2264 u.\nCase 2: F is \u22a5 or equality. It is clear since NSESF (v) and NSESF (u) are the same as F .\nCase 3: F is G \u2227H or G \u2228H. Follows from I.H.\nCase 4: F is G\u2192 H. Assume\n(v \u2264 u) \u2227 \u00acEF (v,u) \u2227NSESF (u)\nand NSESG(v). From NSESF (u), by Lemma 8, we conclude G \u2192 H. From NSESG(v), by Lemma 8, G follows, and consequently H.\nAssume \u00acNSESH(v) for the sake of contradiction. By Lemma 9, fromH and \u00acNSESH(v), it follows that \u2228\npi(t) : pi(t) occurs strictly positively in H\n\u2203xvi(t) (51)\n, where x is the list of variables in t that are not free in H.\nSince F is rectified, the variables in F can be partitioned into three sets: the list of variables x that are not free in H, the list of variables y that are not free in G, and the rest. Note that \u00acEF (v,u) entails\u2227\n(pi(t),pj(t \u2032)) : pi(t) depends on pj(t\u2032) in a rule G\u2192H in F pi(t) occurs in H,pj(t \u2032) occurs in G\n( \u2203xvi(t)\u2192 \u2200y(uj(t\u2032)\u2192 vj(t\u2032)) ) , (52)\nwhere x is the list of all variables in t that are not free in H, and y is the list of all variables in t\u2032 that are not free in G. From (51) and (52), we conclude\u2227\npj(t\u2032) : pj(t\u2032) occurs positively and not in a negative subformula of G\n\u2200y(uj(t\u2032)\u2192 vj(t\u2032)).\nFrom this, together with the assumption (v \u2264 u) and NSESG(v), by Lemma 10 (a), NSESG(u) follows. Thus NSESH(u) follows from NSESF (u) and NSESG(u). Since \u00acEF (v,u) entails \u00acEH(v,u), by I.H. on H, NSESH(v) follows, which contradicts the assumption.\nCase 5: F is \u2200xG or \u2203xG. Follows from I.H.\nLemma 12\nNonempty(u)\u2192 \u2203v(v \u2264 u \u2227 Ext-LoopF (v) \u2227 \u00acEF (v,u))\nis logically valid.\nProof. Take any list q of predicate names, and any interpretation I that satisfies Nonempty(q). Let Y be a set of vertices in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be ).\nConsider the subgraph G of the dependency graph of F w.r.t. I that is induced by Y . If Y is an unbounded set w.r.t. I, by Proposition 4, I |= Ext-LoopF (q). So\nI |= q \u2264 q \u2227 Ext-LoopF (q) \u2227 \u00acEF (q,q).\nOtherwise, consider the graph G\u2032 that is obtained from G by collapsing strongly connected components of G, i.e., the vertices of G\u2032 are the strongly connected components of G and G\u2032 has an edge from V to V \u2032 if G has an edge from a vertex in V to a vertex in V \u2032. Since we assumed that Y is not an unbounded set w.r.t. I, there exists a vertex Z in G\u2032 that has no outgoing edges. Consider the list of predicate names r such that\nI |= ri(\u03be ) iff pi(\u03be ) \u2208 Z.\nIt is clear that I |= r \u2264 q. By Proposition 3, I |= LoopF (r) thus I |= Ext-LoopF (r). Since there is no edge from Z to Y \\ Z, by Lemma 6, I |= \u00acEF (r,q). Consequently, the claim follows."}, {"heading": "Proof of Equivalence Between (b) and (c) of Theorem 3", "text": "From (b) to (c): Clear from that the formula Ext-LoopF (u) \u2192 Nonempty(u) is logically valid.\nFrom (c) to (b): Assume\nF \u2227 \u2200v(v \u2264 p \u2227 Ext-LoopF (v)\u2192 \u00acNSESF (v)).\nTake any u such that u \u2264 p \u2227 Nonempty(u). By Lemma 12, it follows from Nonempty(u) that there exists v such that v \u2264 u \u2227 Ext-LoopF (v) \u2227 \u00acEF (v,u). It is clear that v \u2264 p follows from v \u2264 u and u \u2264 p. It follows from the assumption that \u00acNSESF (v). Then by Lemma 11, \u00acNSESF (u) follows from v \u2264 u and \u00acEF (v,u)."}, {"heading": "A.2 Proof of Theorem 2", "text": "Lemma 3 Let F be a rectified sentence of a signature \u03c3 (possibly containing function constants of positive arity), and let I be an interpretation of \u03c3 that satisfies F . If F is bounded w.r.t. I,\nI |= \u2203u(u \u2264 p \u2227 Ext-LoopF (u) \u2227NSESF (u))\niff there is a finite loop Y of F w.r.t. I such that I |= (\u2227 Y \u2227NESF (Y ) ) .\nProof. From left to right: Assume\nI |= q \u2264 p \u2227 Ext-LoopF (q) \u2227NSESF (q)\nfor some list of predicate names q. Consider Y to be the set of vertices in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Y iff I |= qi(\u03be ).\nSince I |= Ext-LoopF (q), by Proposition 3 and Proposition 4, it follows that Y is an extended loop of F w.r.t. I. Since I |= qi(\u03be ) for all pi(\u03be ) \u2208 Y and I |= q \u2264 p, it follows that I satisfies every atom in Y . Together with the assumption that F is bounded w.r.t. I, this implies that set Y is finite. Since I |= NSESF (q) and Y is finite, by Lemma 2, it follows that I |= NESF (Y ).\nFrom right to left: Consider any finite loop Y of F w.r.t. I. Assume I |= \u2227 Y \u2227NESF (Y ).\nLet q be a list of predicate names such that\nI |= qi(\u03be ) iff pi(\u03be ) \u2208 Y.\n\u2022 I |= q \u2264 p follows from the construction of q and I |= \u2227 Y .\n\u2022 Since Y is a loop of F w.r.t. I, by Proposition 3, I |= LoopF (q), and consequently, I |= Ext-LoopF (q).\n\u2022 From I |= NESF (Y ), by Lemma 2, I |= NSESF (q).\nConsequently, I |= \u2203u(u \u2264 p \u2227 Ext-LoopF (u) \u2227NSESF (u)).\nTheorem 2 Let F be a rectified sentence of a signature \u03c3 (possibly containing function constants of positive arity), and let I be an interpretation of \u03c3 that satisfies F . If F is bounded w.r.t. I, then the following conditions are equivalent to each other:\n(a) I satisfies SM[F ];\n(b) for every nonempty finite set Y of atoms formed from predicate constants in \u03c3(F ) and object names for |I|, I satisfies LFF (Y );\n(c) for every finite loop Y of F w.r.t. I, I satisfies LFF (Y ).\nProof. Between (a) and (c): By Theorem 3 and Lemma 3.\nBetween (b) and (c):\n\u2022 From (b) to (c): Clear.\n\u2022 From (c) to (b): Assume that I satisfies LFF (L) for every finite loop L of F w.r.t I. Consider any nonempty finite set Y of atoms formed from predicate constants in \u03c3(F ) and object names such that I |= \u2227 Y . Let q be a list of predicate names such that\nI |= qi(\u03be ) iff pi(\u03be ) \u2208 Y.\nSince Y is nonempty, it is clear that Nonempty(q) follows. In view of Lemma 12, there is a list of predicate names r such that\nI |= r \u2264 q \u2227 Ext-LoopF (r) \u2227 \u00acEF (r,q). (53)\nConsider Z to be the set of vertices in the dependency graph of F w.r.t. I such that\npi(\u03be ) \u2208 Z iff I |= ri(\u03be ).\nSince I |= Ext-LoopF (r), by Proposition 3 and Proposition 4, Z is an extended loop of F w.r.t. I. Clearly, I |= \u2227 Z since Z \u2286 Y and I |= \u2227 Y . Since F is bounded w.r.t. I, and Z is satisfied by I, it follows that Z is a finite loop of F w.r.t. I. Since I |= r \u2264 q \u2227 \u00acEF (r,q), Z is a subset of Y and, by Lemma 6, there is no edge from Z to Y \\ Z in the dependency graph of F w.r.t. I. Since I |= LFF (Z), we conclude that I |= \u00acNESF (Z), and by Lemma 2, I |= \u00acNSESF (r). From (53) and that I |= \u00acNSESF (r), by Lemma 11, we have I |= \u00acNSESF (q). By Lemma 2 again, I |= \u00acNESF (Y ). Consequently, I |= LFF (Y )."}, {"heading": "A.3 Proof of Proposition 6", "text": "Proposition 6 If a rectified formula F of a signature \u03c3 is bounded, then F is bounded w.r.t. any interpretation of \u03c3 that satisfies CET\u03c3.\nLemma 13 For any terms t1 and t2 of signature \u03c3, any interpretation I that satisfies CET\u03c3, and any substitution \u03b8 from object variables in t1 and t2 to object names such that (t1\u03b8) I = (t2\u03b8) I , Robinson\u2019s unification algorithm (Robinson, 1965), when applied to t1 and t2, returns a most general unifier (mgu) \u03b3 of t1 and t2 such that\n(a) t1\u03b3 = t2\u03b3, and\n(b) for every variable x in t1 or t2, (x\u03b3\u03b8) I = (x\u03b8)I .\nProof. From the assumptions, by Lemma 5.1 from the work of Kunen (1987), t1 and t2 are unifiable, in which case Robinson\u2019s algorithm returns a mgu for t1 and t2 that maps variables occurring in t1 and t2 into terms. Given this, part (b) can be proven by induction.\nThe proof of Proposition 6 follows from the following lemma.\nLemma 14 Let F be a rectified sentence of a signature \u03c3, and let I be an interpretation of \u03c3 that satisfies CET\u03c3. For any path\n\u3008p1(\u03be 1), p2(\u03be 2), . . . , pk(\u03be k), pk+1(\u03be k+1)\u3009 (54)\nin the dependency graph of F w.r.t I, there is a path\n\u3008p1(u1), p2(u2), . . . , pk(uk), pk+1(uk+1)\u3009\nin the first-order dependency graph of F with a substitution \u03b8 that maps object variables in ui to object names such that (ui\u03b8) I = \u03bei for all i.\nProof. Each edge (pi(\u03be i ), pi+1(\u03be i+1)) in (54) is obtained from a pair of atoms (pi(ti), pi+1(t \u2032 i)) and a substitution \u03b8i such that pi(ti) depends on pi+1(t \u2032 i) in a rule of F , and\n(t1\u03b81) I = \u03be1, (t \u2032 i\u03b8i) I = (ti+1\u03b8i+1) I = \u03bei+1(1 \u2264 i < k), (t\u2032k\u03b8k)I = \u03bek+1. (55)\nFor simplicity we assume that each pair (pi(ti), pi+1(t \u2032 i)) considered above has no common variables with another pair by first renaming variables. This allows us to use one substitution \u03b8 = \u03b81 . . . \u03b8k in place of individual \u03b8i in the rest of the proof.\nWe will show by induction that, for each j where j \u2208 {1 . . . k}, there are substitutions \u03c3ji (1 \u2264 i \u2264 j) from variables in ti and t\u2032i to terms such that\n(a) \u3008p1(t1)\u03c3j1, p2(t2)\u03c3 j 2, . . . , pj(tj)\u03c3 j j , pj+1(t \u2032 j)\u03c3 j j \u3009 is a path in the first-order dependency\ngraph of F , and\n(b) (ti\u03c3 j i \u03b8) I = \u03bei for all 1 \u2264 i \u2264 j, and (t\u2032j\u03c3 j j\u03b8) I = \u03bej+1.\nWhen j = 1, we take \u03c3ji to be an identity substitution. Clearly, conditions (a) and (b) are satisfied.\nOtherwise, by I.H. we assume that, for some j in {1, . . . , k\u22121}, there are substitutions \u03c3j1, . . . , \u03c3 j j such that conditions (a) and (b) are satisfied. We will prove that there are substitutions \u03c3j+1i (1 \u2264 i \u2264 j+1) from variables in ti and t\u2032i to terms such that\n(a\u2019) \u3008p1(t1)\u03c3j+11 , p2(t2)\u03c3 j+1 2 , . . . , pj+1(tj+1)\u03c3 j+1 j+1, pj+2(t \u2032 j+1)\u03c3 j+1 j+1\u3009 is a path in the first-order de-\npendency graph of F , and\n(b\u2019) (ti\u03c3 j+1 i \u03b8) I = \u03bei for all 1 \u2264 i \u2264 j+1, and (t\u2032j+1\u03c3 j+1 j+1\u03b8) I = \u03bej+2.\nFrom I.H., we have (t\u2032j\u03c3 j j\u03b8) I = \u03bej+1 and from (55) we have (tj+1\u03b8) I = \u03bej+1. By Lemma 13\nthere is a substitution \u03b3 from variables in t\u2032j\u03c3 j j or tj+1 to terms such that t \u2032 j\u03c3 j j\u03b3 = tj+1\u03b3 and for any variable x in t\u2032j\u03c3 j j or tj+1,\n(x\u03b3\u03b8)I = (x\u03b8)I . (56)\nWe define \u03c3j+1i as\n\u2022 \u03c3ji \u03b3 when 1 \u2264 i \u2264 j and\n\u2022 \u03b3 when i = j+1.\nIt is easy to check that condition (a\u2019) is satisfied. To check that condition (b\u2019) is satisfied, consider any variable x in the set\n{t1\u03c3j1, t2\u03c3 j 2, . . . , tj\u03c3 j j , t \u2032 j\u03c3 j j , tj+1, t \u2032 j+1}. (57)\nIf x is in t\u2032j\u03c3 j j or tj+1, by (56), (x\u03b3\u03b8) I = (x\u03b8)I . Otherwise, since \u03b3 does not change the variables that are not in t\u2032j\u03c3 j j or tj+1, (x\u03b3\u03b8) I = (x\u03b8)I . Consequently, for any variable x in (57), we get (x\u03b3\u03b8)I = (x\u03b8)I . It remains to check the following.\n\u2022 For 1 \u2264 i \u2264 j, (ti\u03c3j+1i \u03b8)I = (ti\u03c3 j i \u03b3\u03b8) I = (ti\u03c3 j i \u03b8) I . The last one is equal to \u03bei by I.H.\n\u2022 (tj+1\u03c3j+1j+1\u03b8)I = (tj+1\u03b3\u03b8)I = (tj+1\u03b8)I . The last one is equal to \u03bej+1 by (55).\n\u2022 (t\u2032j+1\u03c3 j+1 j+1\u03b8) I = (t\u2032j+1\u03b3\u03b8) I = (t\u2032j+1\u03b8) I . The last one is equal to \u03bej+2 by (55)."}, {"heading": "A.4 Proof of Proposition 7", "text": "Proposition 7 For any rectified sentence F of a signature \u03c3 and for any interpretation I of \u03c3 that satisfies CET\u03c3, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of {LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe proof follows immediately from the following fact and Lemma 15.\nFact 1 Let F be a rectified sentence of a signature \u03c3, and let I be an interpretation of \u03c3. For any first-order loop Y of F and any substitution \u03b8 that maps variables in Y to object names, Y \u2032 = {pi(\u03be ) | pi(t) \u2208 Y \u03b8, tI = \u03be} is a loop of F w.r.t. I.\nLemma 15 Let F be a rectified sentence of a signature \u03c3, and let I be an interpretation of \u03c3. If I satisfies CET\u03c3, then, for any finite loop Y\n\u2032 of F w.r.t. I, there is a finite loop Y of F with a substitution \u03b8 that maps variables in Y to object names such that Y \u2032 = {pi(\u03be ) | pi(t) \u2208 Y, (t\u03b8)I = \u03be}.\nProof. Without loss of generality, consider a path\n\u3008p1(\u03be 1), p2(\u03be 2), . . . , pk(\u03be k), p1(\u03be 1)\u3009\n(k \u2265 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y \u2032. Since I |= CET\u03c3, by Lemma 14, there is a path\n\u3008p1(u1), p2(u2), . . . , pk(uk), p1(uk+1)\u3009\nin the first-order dependency graph of F with a substitution \u03b8 that maps variables in ui to object names such that (ui\u03b8)\nI = \u03bei for all 1 \u2264 i \u2264 k, and (uk+1\u03b8)I = \u03be1. Since (uk+1\u03b8) I = (u1\u03b8) I , by Lemma 13, there is a unifier \u03b3 for uk+1 and u1 such that, for any variable x in uk+1 or u1, (x\u03b3\u03b8) I = (x\u03b8)I . Consequently,\n{p1(u1\u03b3), p2(u2\u03b3), . . . , pk(uk\u03b3)}\ninduces a finite strongly connected subgraph such that (ui\u03b3\u03b8) I = (ui\u03b8) I = \u03bei."}, {"heading": "A.5 Proof of Proposition 8", "text": "Proposition 8 If a rectified formula F in normal form is bounded, then F is bounded w.r.t. any interpretation.\nThe proof follows from the following lemma.\nLemma 16 Let F be a rectified sentence of a signature \u03c3 in normal form, and let I be an interpretation of \u03c3. For any path\n\u3008p1(\u03be 1), p2(\u03be 2), . . . , pk(\u03be k), pk+1(\u03be k+1)\u3009\nin the dependency graph of F w.r.t I, there exists a path\n\u3008p1(u1), p2(u2), . . . , pk(uk), pk+1(uk+1)\u3009\nin the first-order dependency graph of F with a substitution \u03b8 that maps object variables in ui to object names such that (ui\u03b8) I = \u03bei for all i, and u1 is a list of object variables.\nProof. The proof is similar to the proof of Lemma 14 except that we do not require that I satisfy CET\u03c3. Instead, the existence of a unifier \u03b3 for t \u2032 j\u03c3 j j and tj+1 is ensured by the assumption on normal form that tj+1 is a list of variables and the assumption that t \u2032 j\u03c3 j j contains none of those variables (due to variable renaming)."}, {"heading": "A.6 Proof of Proposition 9", "text": "Proposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of {LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe proof follows from Fact 1 and the following lemma.\nLemma 17 If a rectified sentence F in normal form is bounded, then for any finite loop Y \u2032 of F w.r.t. I, there is a finite loop Y of F with a substitution \u03b8 that maps variables in Y to object names such that Y \u2032 = {pi(\u03be ) | pi(t) \u2208 Y, (t\u03b8)I = \u03be}.\nProof. Let Y \u2032 be a finite loop of F w.r.t. I. Without loss of generality, there is a path\n\u3008p1(\u03be 1), p2(\u03be 2), . . . , pk(\u03be k), p1(\u03be 1)\u3009\n(k \u2265 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y \u2032. Since F is in normal form, by Lemma 16, there are a path\n\u3008p1(u1), p2(u2), . . . , pk(uk), p1(uk+1)\u3009 (58)\nin the first-order dependency graph of F , where u1 consists of object variables only, and a substitution \u03b8 that maps variables in ui to object names such that (ui\u03b8)\nI = \u03bei for all 1 \u2264 i \u2264 k, and (uk+1\u03b8)I = \u03be1. There are two cases to consider.\n\u2022 Case 1: There is a unifier \u03b3 for u1 and uk+1 that maps variables in u1 to terms in uk+1 so that u1\u03b3 = uk+1. It follows that, for any variable x in uk+1 or u1, (x\u03b3\u03b8)\nI = (x\u03b8)I . Consequently,\n{p1(u1\u03b3), p2(u2\u03b3), . . . , pk(uk\u03b3)}\ninduces a finite strongly connected subgraph such that (ui\u03b3\u03b8) I = (ui\u03b8) I = \u03bei.\n\u2022 Case 2: There is no such unifier \u03b3. Consider another path\n\u3008p1(v1), p2(v2), . . . , pk(vk), p1(vk+1)\u3009\nthat is obtained similar to (58) except that the variables in the path are disjoint from the variables in (58). Clearly, there is a unifier \u03b3\u2032 for uk+1 and v1 that maps the variables v1 to terms, so that\n\u3008p1(u1), p2(u2), . . . , pk(uk), p1(v1\u03b3\u2032), p2(v2\u03b3\u2032), . . . , pk(vk\u03b3\u2032)\u3009\nis another path in the first-order dependency graph of F . It is clear that using the same construction repeatedly, we can form an infinite path that visits infinitely many vertices in the first-order dependency graph. But this contradicts the assumption that F is bounded."}, {"heading": "A.7 Proof of Proposition 11", "text": "We will use the following lemma in this section and the next section, which extends Theorem 2 in the work of Chen et al. (2006) that provides a few equivalent conditions for a program to have a finite complete set of loops to a disjunctive program and a sentence.\nLemma 18 (Chen et al., 2006, Thm. 2) For any formula F that contains no function constants of positive arity, the following conditions are equivalent:\n(a) F has a finite complete set of loops.\n(b) There is a nonnegative integer N such that for every loop L of F , the number of variables in L is bounded by N .\n(c) For any loop L of F and any atom A1 and A2 in L, the variables occurring in A1 are identical to the variables occurring in A2.\n(d) For any loop L of Ground\u03c3(F )\u222a{c1,c2}(F ) where c1, c2 are two new object constants, there are no two atoms A1 and A2 in L such that A1 mentions c1 but A2 does not or A1 mentions c2 but A2 does not.\nProposition 11 For any rectified formula F that contains no function constants of positive arity, F is bounded iff F has a finite complete set of loops.\nProof. From left to right: Assume that F is bounded. Then every loop of F is finite. It follows that there exists a nonnegative integer N such that the number of variables in any loop is bounded by N . By Lemma 18 (b), F has a finite complete set of loops.\nFrom right to left: Assume that F has a finite complete set of loops and, for the sake of contradiction, assume that it is not bounded. Without loss of generality, there is an infinite path \u3008p1(t1)\u03c31, p2(t2)\u03c32, . . .\u3009 (59) in the first-order dependency graph of F that visits infinitely many vertices, where pi(ti) are atoms occurring in F and \u03c3i are substitutions.\nSince F is a finite string, it contains finitely many atoms. It follows that there is an atom pi(ti) occurring in F with arbitrarily many substitutions \u03c3 such that atoms pi(ti)\u03c3 are contained in (59). Without loss of generality, consider the path\n\u3008pi(ti)\u03c3i, pi+1(ti+1)\u03c3i+1, . . . , pi(ti)\u03c3k\u3009\nthat is contained in (59), where \u03c3k and \u03c3i agree on substituting object constants for variables in ti. Since ti\u03c3i and ti\u03c3k contain no function constant, there exists a substitution \u03c30 that maps variables in ti\u03c3k to terms in ti\u03c3i so that ti\u03c3k\u03c30 = ti\u03c3i. Consequently,\n{pi(xi)\u03c3i\u03c30, pi+1(xi+1)\u03c3i+1\u03c30, . . . , pi(xi)\u03c3k\u03c30}\nis a loop of F . Since the length of the path is arbitrarily large, there are arbitrarily many variables occurring in the loop. By Lemma 18 (b), it follows that F has no finite complete set of loops."}, {"heading": "A.8 Proof of Proposition 10", "text": "Proposition 10 For any rectified sentence F (allowing function constants of positive arity),\n(a) checking whether F is bounded is not decidable;\n(b) checking whether F is atomic-tight is not decidable.\nIf F contains no function constants of positive arity,\n(c) checking whether F is bounded is decidable;\n(d) checking whether F is atomic-tight is decidable."}, {"heading": "A.8.1 Proof of Part (a) and (b)", "text": "We show the proof of Part (a) first. The proof repeats, with minor modifications, the argument from the proof of Theorem 26 from the work of Bonatti (2004), which considers the following program \u03a0M to simulate deterministic Turing machines M.\nt(s, L, v, [V | R], C)\u2190 t(s\u2032, [v\u2032 | L], V,R,C+1) for all instr.\u3008s, v, v\u2032, s\u2032, right\u3009 t(s, L, v, [ ], C)\u2190 t(s\u2032, [v\u2032 | L], b, [ ], C+1) for all instr.\u3008s, v, v\u2032, s\u2032, right\u3009 t(s, [V | L], v, R,C)\u2190 t(s\u2032, L, V, [v\u2032 | R], C+1) for all instr.\u3008s, v, v\u2032, s\u2032, left\u3009 t(s, [ ], v, R,C)\u2190 t(s\u2032, [ ], b, [v\u2032 | R], C+1) for all instr.\u3008s, v, v\u2032, s\u2032, left\u3009 t(s, L, v,R,C) for all final states s.\nThe Halting problem can be reduced to the problem of checking bounded formulas. More precisely, we show that \u03a0M is bounded iff M terminates from every configuration.\nWe first establish the following facts:\n(i) for every non-terminating computation of M on input x, there is a corresponding infinite path in the first-order dependency graph of \u03a0M that visits infinitely many vertices;\n(ii) if there is an infinite path in the first-order dependency graph of \u03a0M, then there is an infinite path starting with a legal encoding of an input and corresponds to a non-terminating computation of M.\nFact (i) is immediate from the definition of \u03a0M: Note that the step counter (the last argument of t) ensures that the dependency graph is acyclic. Then, whenever M falls into a cycle, the dependency graph contains an infinite acyclic path that visits infinitely many vertices and hence the program is not bounded.\nFact (ii) can be proven as follows. Assume that there is an infinite path in the dependency graph. We observe that the first argument of every vertex in the path must be a legal state and the third argument of every vertex must be a legal tape value. Otherwise, there is no outgoing edge from the vertices in the dependency graph of \u03a0M. So only the second, fourth and fifth arguments can contain variables or illegal values which were obtained from substitutions from the variables L, R, V and C. In this case, we can easily find substitutions from these variables or illegal values to legal values and apply them uniformly along the path, so that we obtain another infinite path starting from the vertex that correctly encodes a configuration of M and thus M has a corresponding non-terminating computation.\nThe claim follows immediately from the two facts: if M does not terminate on some computation, then by (i), \u03a0M is unbounded. If \u03a0M is unbounded, then by (ii), M does not terminate.\nThe same proof works for Part (b) as well. This is because the step counter (the last argument of t) ensures that the dependency graph is acyclic. Consequently, every infinite path in the dependency graph visits infinitely many vertices, so that \u03a0M is atomic-tight iff \u03a0M is bounded."}, {"heading": "A.8.2 Proof of Part (c)", "text": "In view of the equivalence between (a) and (d) in Lemma 18, checking whether a formula F containing no function constants of positive arity has a finite complete set of loops can\nbe done by examining a finite number of loops from a finite dependency graph, which is decidable. By Proposition 11, it follows that checking whether F is bounded is decidable."}, {"heading": "A.8.3 Proof of Part (d)", "text": "For any sentence F that has no function constants of positive arity and any finite set c of object constants, Groundc(F ) is defined recursively. If F is an atomic formula thenGroundc(F ) is F . The function Groundc commutes with all propositional connectives; quantifiers turn into finite conjunctions and disjunctions over all object constants occurring in c.\nLemma 19 Let c be the set consisting of all object constants occurring in F , and possibly a new object constant if F contains no object constants. F has a non-trivial loop iff Groundc(F ) has a non-trivial loop.\nIn order to check whether F is atomic-tight, we first check whether F is bounded, which is decidable. If F is not bounded, then F is not atomic-tight. Otherwise, in view of Lemma 19, checking whether F is atomic-tight is the same as checking whether Groundc(F ) is atomic-tight. Since F contains no function constants of positive arity, the dependency graph of Groundc(F ) is finite. So it is decidable to check whether the dependency graph of Groundc(F ) has a non-trivial loop."}, {"heading": "A.9 Proof of Proposition 13", "text": "Lemma 20 Let F be a formula and Y a set of atoms. If no predicate constant occurring in Y occurs strictly positively in F , then NESF (Y ) is equivalent to F .\nProof. By induction.\nProposition 13 Let \u03a0 be a program with quantifiers, F the FOL-representation of \u03a0, and Y a finite set of atoms. Under the assumption \u03a0, formula QES \u03a0(Y ) is equivalent to \u00acNESF (Y ). If \u03a0 is a disjunctive program in normal form, then QES \u03a0(Y ) is also equivalent to ES \u03a0(Y ) under the assumption \u03a0.\nProof. Between QES \u03a0(Y ) and \u00acNESF (Y ): \u00acNESF (Y ) is\n\u00ac \u2227\nH\u2190G\u2208\u03a0 \u2200x[(G\u2192 H) \u2227 (NESG(Y )\u2192 NESH(Y ))]. (60)\nUnder the assumption F , formula (60) is equivalent to\u2228 H\u2190G\u2208\u03a0 \u2203x(NESG(Y ) \u2227 \u00acNESH(Y )). (61)\nIn view of Lemma 20, if H does not contain any strictly positive occurrence of a predicate constant that belongs to Y , NESH(Y ) is equivalent to H. Also, it follows from Lemma 2 and Lemma 8 that NESG(Y ) implies G. So NESG(Y )\u2227\u00acNESH(Y ) conflicts the assumption\nG \u2192 H when H does not contain any strictly positive occurrence of a predicate constant that belongs to Y . As a result, under the assumption F , formula (61) is equivalent to the disjunction of\n\u2203x(NESG(Y ) \u2227 \u00acNESH(Y )) (62)\nfor all rules H \u2190 G, where H contains a strictly positive occurrence of a predicate constant that belongs to Y . Note that G and H are formulas such that every occurrence of an implication in G and H belongs to a negative formula. By Lemma 4, (62) is equivalent to QES \u03a0(Y ).\nBetween QES \u03a0(Y ) and ES \u03a0(Y ): When \u03a0 is a disjunctive program, QES \u03a0(Y ) is the disjunction of\n\u2203z ( B \u2227N \u2227 \u2227 p(t)\u2208B p(t\u2032)\u2208Y (t 6= t\u2032) \u2227 \u00ac ( \u2228 p(t)\u2208A (p(t) \u2227 \u2227 p(t\u2032)\u2208Y t 6= t\u2032) ))\n(63)\nover all rules (10) such that A contains a predicate constant that occurs in Y , where z is a list of variables in (10) but not in Y . On the other hand, ES \u03a0(Y ) is the disjunction of\n\u2203z\u2032 ( B\u03c3 \u2227N\u03c3 \u2227 \u2227 p(t)\u2208B\u03c3 p(t\u2032)\u2208Y (t 6= t\u2032) \u2227 \u00ac ( \u2228 p(t)\u2208A\u03c3 (p(t) \u2227 \u2227 p(t\u2032)\u2208Y t 6= t\u2032) ))\n(64)\nover all rules (10) such that A contains a predicate constant that occurs in Y and A\u03c3\u2229Y 6= \u2205, where z\u2032 is a list of variables in A\u03c3 \u2190 B\u03c3,N\u03c3 but not in Y .\nIt is clear that (64) implies (63). To prove that (63) implies (64), assume\nB \u2227N \u2227 \u2227\np(t)\u2208B p(t\u2032)\u2208Y\n(t 6= t\u2032) \u2227 \u00ac ( \u2228 p(t)\u2208A (p(t) \u2227 \u2227 p(t\u2032)\u2208Y t 6= t\u2032) )\n(65)\nand consider two cases. If \u2227 p(t\u2032)\u2208Y t 6= t\u2032 for all p(t) \u2208 A, then (65) is equivalent to\nB \u2227N \u2227 \u2227\np(t)\u2208B p(t\u2032)\u2208Y\n(t 6= t\u2032) \u2227 \u00ac \u2228\np(t)\u2208A\np(t)\nwhich contradicts the assumption \u03a0.\nOtherwise, there exists p(t) \u2208 A and p(t\u2032) \u2208 Y such that t = t\u2032. Since \u03a0 is in normal form, there exists \u03c3 that maps t to t\u2032, so that A\u03c3 \u2229 Y 6= \u2205. Consequently, (65) is equivalent to\nB\u03c3 \u2227N\u03c3 \u2227 \u2227\np(t)\u2208B\u03c3 p(t\u2032)\u2208Y\n(t 6= t\u2032) \u2227 \u00ac ( \u2228 p(t)\u2208A\u03c3 (p(t) \u2227 \u2227 p(t\u2032)\u2208Y t 6= t\u2032) ) .\nThus the claim follows."}, {"heading": "A.10 Proof of Proposition 16", "text": "Proposition 16 Let P be an LW-program and let F be the FOL-representation of the set of rules in P . The following conditions are equivalent to each other:\n(a) I is an answer set of P according to Lin and Wang (2008);\n(b) I is a P -interpretation that satisfies SM[F ];\n(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.r.t. I.\nGiven a program \u03a0, Norm(\u03a0) is a normal form of \u03a0 and Ground(\u03a0) is a ground program obtained from \u03a0 as described by Lin and Wang (2008). The proof of Proposition 16 follows from the following lemma. We refer readers to the work of Lin and Wang for the definition of ES (\u00b7, \u00b7, \u00b7) defined there.\nLemma 21 For any program \u03a0 and any set Y of ground atoms, ESNorm(\u03a0)(Y ) is equivalent to \u2228 p(c)\u2208Y ES (p(c), Y,Ground(\u03a0)).\nProof. By definition, ESNorm(\u03a0)(Y ) is\u2228 p(x)\u2190B,N,x=t is in Norm(\u03a0)\n\u03b8:p(x)\u03b8\u2208Y\n\u2203z ( B\u03b8 \u2227N\u03b8 \u2227 x\u03b8 = t\u03b8 \u2227 \u2227 q(t)\u2208B\u03b8 q(t\u2032)\u2208Y (t 6= t\u2032) ) , (66)\nwhere x is a list of distinct object variables, \u03b8 is a substitution that maps variables in x to object constants occurring in Y , and z is the list of all variables that occur in the rule p(x)\u03b8 \u2190 B\u03b8,N\u03b8,x\u03b8 = t\u03b8. (66) is equivalent to\u2228\np(t)\u2190B,N\u2208\u03a0 p(c)\u2208Y\n\u2203z\u2032 ( B \u2227N \u2227 t = c \u2227 \u2227 q(t)\u2208B q(t\u2032)\u2208Y (t 6= t\u2032) ) , (67)\nwhere z\u2032 is the list of all variables that occur in the rule p(t) \u2190 B,N . In turn, (67) is equivalent to \u2228\np(d)\u2190B\u2032,N\u2032\u2208Ground(\u03a0) p(c)\u2208Y\n( B\u2032 \u2227N \u2032 \u2227 d = c \u2227 \u2227 q(tg)\u2208B\u2032 q(t\u2032)\u2208Y (tg 6= t\u2032) ) . (68)\nNote that when d does not cover c, there exists di \u2208 d such that di mentions only constants and pre-interpreted functions and di can not be evaluated to ci independent of interpretations. In that case, d = c is equivalent to \u22a5. Thus (68) is equivalent to\u2228\np(c)\u2208Y \u2228 p(d)\u2190B\u2032,N\u2032\u2208Ground(\u03a0) p(d) can cover p(c) ( B\u2032 \u2227N \u2032 \u2227 d = c \u2227 \u2227 q(tg)\u2208B\u2032 q(t\u2032)\u2208Y (tg 6= t\u2032) ) , (69)\nwhich is essentially \u2228 p(c)\u2208Y ES (p(c), Y,Ground(\u03a0))."}], "references": [{"title": "Ordered completion for first-order logic programs on finite structures", "author": ["V. Asuncion", "F. Lin", "Y. Zhang", "Y. Zhou"], "venue": "In AAAI,", "citeRegEx": "Asuncion et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Asuncion et al\\.", "year": 2010}, {"title": "Reasoning with infinite stable models", "author": ["P.A. Bonatti"], "venue": "Artificial Intelligence, 156 (1), 75\u2013111.", "citeRegEx": "Bonatti,? 2004", "shortCiteRegEx": "Bonatti", "year": 2004}, {"title": "First-order loop formulas for normal logic programs", "author": ["Y. Chen", "F. Lin", "Y. Wang", "M. Zhang"], "venue": "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Chen et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2006}, {"title": "Loop-separable programs and their firstorder definability", "author": ["Y. Chen", "F. Lin", "Y. Zhang", "Y. Zhou"], "venue": "Artificial Intelligence,", "citeRegEx": "Chen et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2011}, {"title": "First-order indefinability of answer set programs on finite structures", "author": ["Y. Chen", "Y. Zhang", "Y. Zhou"], "venue": "In AAAI,", "citeRegEx": "Chen et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Chen et al\\.", "year": 2010}, {"title": "Negation as failure", "author": ["K. Clark"], "venue": "Gallaire, H., & Minker, J. (Eds.), Logic and Data Bases, pp. 293\u2013322. Plenum Press, New York.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "A semantical framework for hybrid knowledge bases", "author": ["J. de Bruijn", "D. Pearce", "A. Polleres", "A. Valverde"], "venue": "Knowl. Inf. Syst.,", "citeRegEx": "Bruijn et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bruijn et al\\.", "year": 2010}, {"title": "A generalization of the Lin-Zhao theorem", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Ferraris et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2006}, {"title": "A new perspective on stable models", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Ferraris et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2007}, {"title": "Stable models and circumscription", "author": ["P. Ferraris", "J. Lee", "V. Lifschitz"], "venue": "Artificial Intelligence,", "citeRegEx": "Ferraris et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ferraris et al\\.", "year": 2011}, {"title": "Elementary sets for logic programs", "author": ["M. Gebser", "J. Lee", "Y. Lierler"], "venue": "In Proceedings of National Conference on Artificial Intelligence (AAAI),", "citeRegEx": "Gebser et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2006}, {"title": "On elementary loops of logic programs", "author": ["M. Gebser", "J. Lee", "Y. Lierler"], "venue": "Theory and Practice of Logic Programming,", "citeRegEx": "Gebser et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "Loops: Relevant or redundant", "author": ["M. Gebser", "T. Schaub"], "venue": "In Proceedings of the Eighth International Conference on Logic Programming and Nonmonotonic Reasoning", "citeRegEx": "Gebser and Schaub,? \\Q2005\\E", "shortCiteRegEx": "Gebser and Schaub", "year": 2005}, {"title": "The stable model semantics for logic programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of International Logic Programming Conference and Symposium,", "citeRegEx": "Gelfond and Lifschitz,? \\Q1988\\E", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "Circumscriptive event calculus as answer set programming", "author": ["Kim", "T.-W", "J. Lee", "R. Palla"], "venue": "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),", "citeRegEx": "Kim et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Kim et al\\.", "year": 2009}, {"title": "Negation in logic programming", "author": ["K. Kunen"], "venue": "The Journal of Logic Programming, 4 (4), 289 \u2013 308.", "citeRegEx": "Kunen,? 1987", "shortCiteRegEx": "Kunen", "year": 1987}, {"title": "Nondefinite vs", "author": ["J. Lee"], "venue": "definite causal theories. In Proceedings 7th Int\u2019l Conference on Logic Programming and Nonmonotonic Reasoning, pp. 141\u2013153.", "citeRegEx": "Lee,? 2004", "shortCiteRegEx": "Lee", "year": 2004}, {"title": "A model-theoretic counterpart of loop formulas", "author": ["J. Lee"], "venue": "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 503\u2013508.", "citeRegEx": "Lee,? 2005", "shortCiteRegEx": "Lee", "year": 2005}, {"title": "Representing synonymity in causal logic and in logic programming", "author": ["J. Lee", "Y. Lierler", "V. Lifschitz", "F. Yang"], "venue": "In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR). http://peace.eas.asu.edu/joolee/papers/syn.pdf", "citeRegEx": "Lee et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2010}, {"title": "Loop formulas for disjunctive logic programs", "author": ["J. Lee", "V. Lifschitz"], "venue": "In Proceedings of International Conference on Logic Programming (ICLP),", "citeRegEx": "Lee and Lifschitz,? \\Q2003\\E", "shortCiteRegEx": "Lee and Lifschitz", "year": 2003}, {"title": "Safe formulas in the general theory of stable models", "author": ["J. Lee", "V. Lifschitz", "R. Palla"], "venue": "Technical Report. http://peace.eas.asu.edu/joolee/papers/safety.pdf", "citeRegEx": "Lee et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lee et al\\.", "year": 2009}, {"title": "Loop formulas for circumscription", "author": ["J. Lee", "F. Lin"], "venue": "Artificial Intelligence,", "citeRegEx": "Lee and Lin,? \\Q2006\\E", "shortCiteRegEx": "Lee and Lin", "year": 2006}, {"title": "On loop formulas with variables", "author": ["J. Lee", "Y. Meng"], "venue": "In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR),", "citeRegEx": "Lee and Meng,? \\Q2008\\E", "shortCiteRegEx": "Lee and Meng", "year": 2008}, {"title": "Integrating rules and ontologies in the first-order stable model semantics (preliminary report)", "author": ["J. Lee", "R. Palla"], "venue": "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),", "citeRegEx": "Lee and Palla,? \\Q2011\\E", "shortCiteRegEx": "Lee and Palla", "year": 2011}, {"title": "Circumscription", "author": ["V. Lifschitz"], "venue": "Gabbay, D., Hogger, C., & Robinson, J. (Eds.), Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298\u2013352. Oxford University Press.", "citeRegEx": "Lifschitz,? 1994", "shortCiteRegEx": "Lifschitz", "year": 1994}, {"title": "Knowledge representation and classical logic", "author": ["V. Lifschitz", "L. Morgenstern", "D. Plaisted"], "venue": "Handbook of Knowledge Representation,", "citeRegEx": "Lifschitz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2008}, {"title": "A logic of knowledge and justified assumptions", "author": ["F. Lin", "Y. Shoham"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Shoham,? \\Q1992\\E", "shortCiteRegEx": "Lin and Shoham", "year": 1992}, {"title": "Answer set programming with functions", "author": ["F. Lin", "Y. Wang"], "venue": "Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Lin and Wang,? \\Q2008\\E", "shortCiteRegEx": "Lin and Wang", "year": 2008}, {"title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Zhao,? \\Q2004\\E", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "From answer set logic programming to circumscription via logic of GK", "author": ["F. Lin", "Y. Zhou"], "venue": "Artificial Intelligence,", "citeRegEx": "Lin and Zhou,? \\Q2011\\E", "shortCiteRegEx": "Lin and Zhou", "year": 2011}, {"title": "Properties and applications of programs with monotone and convex constraints", "author": ["L. Liu", "M. Truszczynski"], "venue": "J. Artif. Intell. Res. (JAIR),", "citeRegEx": "Liu and Truszczynski,? \\Q2006\\E", "shortCiteRegEx": "Liu and Truszczynski", "year": 2006}, {"title": "Circumscription\u2014a form of non-monotonic reasoning", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 13, 27\u201339,171\u2013172.", "citeRegEx": "McCarthy,? 1980", "shortCiteRegEx": "McCarthy", "year": 1980}, {"title": "Applications of circumscription to formalizing common sense knowledge", "author": ["J. McCarthy"], "venue": "Artificial Intelligence, 26 (3), 89\u2013116.", "citeRegEx": "McCarthy,? 1986", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "A first order nonmonotonic extension of constructive logic", "author": ["D. Pearce", "A. Valverde"], "venue": "Studia Logica,", "citeRegEx": "Pearce and Valverde,? \\Q2005\\E", "shortCiteRegEx": "Pearce and Valverde", "year": 2005}, {"title": "A machine-oriented logic based on the resolution principle", "author": ["J.A. Robinson"], "venue": "J. ACM, 12, 23\u201341.", "citeRegEx": "Robinson,? 1965", "shortCiteRegEx": "Robinson", "year": 1965}, {"title": "Computing answer sets using model generation theorem provers", "author": ["O. Sabuncu", "F.N. Alpaslan"], "venue": null, "citeRegEx": "Sabuncu and Alpaslan,? \\Q2007\\E", "shortCiteRegEx": "Sabuncu and Alpaslan", "year": 2007}, {"title": "Loop formulas for logic programs with arbitrary constraint atoms", "author": ["You", "J.-H", "G. Liu"], "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI),", "citeRegEx": "You et al\\.,? \\Q2008\\E", "shortCiteRegEx": "You et al\\.", "year": 2008}, {"title": "On the progression semantics and boundedness of answer set programs", "author": ["Y. Zhang", "Y. Zhou"], "venue": "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Zhang and Zhou,? \\Q2010\\E", "shortCiteRegEx": "Zhang and Zhou", "year": 2010}], "referenceMentions": [{"referenceID": 17, "context": "Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008).", "startOffset": 292, "endOffset": 342}, {"referenceID": 16, "context": "The theorem has also been applied to other nonmonotonic formalisms, such as nonmonotonic causal theories (Lee, 2004) and McCarthy\u2019s circumscription (Lee & Lin, 2006).", "startOffset": 105, "endOffset": 116}, {"referenceID": 22, "context": "According to the theorem on loop formulas (Lin & Zhao, 2004), the stable models of a logic program (Gelfond & Lifschitz, 1988) can be characterized as the models of the logic program that satisfy all its loop formulas. This idea has turned out to be widely applicable in relating the stable model semantics to propositional logic, and has resulted in an efficient method for computing answer sets using SAT solvers. Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008).", "startOffset": 110, "endOffset": 519}, {"referenceID": 13, "context": "The stable model semantics that does not involve grounding appeared a year later (Ferraris, Lee, & Lifschitz, 2007, 2011). The authors define the stable models of a firstorder sentence F as the models of the second-order sentence that is obtained by applying the \u201cstable model operator\u201d SM to F . The definition of SM is close to the definition of the circumscription operator CIRC (McCarthy, 1980, 1986). Under the first-order stable model semantics, logic programs are viewed as a special class of first-order theories. A similar definition of a stable model was given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992).", "startOffset": 92, "endOffset": 594}, {"referenceID": 7, "context": "The first-order stable model semantics is also closely related to quantified equilibrium logic (Pearce & Valverde, 2005), and indeed, Ferraris et al. (2011) showed that they are essentially equivalent.", "startOffset": 134, "endOffset": 157}, {"referenceID": 2, "context": "Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models.", "startOffset": 62, "endOffset": 81}, {"referenceID": 2, "context": "Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models. Section 4 extends these results to allow non-Herbrand stable models as well (possibly allowing functions) under a certain semantic condition, and compare the first-order stable model semantics with loop formulas by reformulating the former in terms of the latter. In Section 5, we present a series of syntactic conditions that imply the semantic condition in Section 4. Section 6 provides an extension of logic programs that contain explicit quantifiers and shows how query answering for such extended programs can sometimes be reduced to entailment checking in first-order logic via loop formulas. In Section 7, the results are further extended to distinguish between intensional and non-intensional predicates. Related work is described in Section 8, and long proofs are given in Appendix A. This article is an extended version of a conference paper by Lee and Meng (2008).", "startOffset": 62, "endOffset": 1081}, {"referenceID": 8, "context": "(2011) that extends a conference paper by the same authors (Ferraris et al., 2007) by distinguishing between intensional and non-intensional predicates.", "startOffset": 59, "endOffset": 82}, {"referenceID": 7, "context": "Review of the First-Order Stable Model Semantics This review follows a journal paper by Ferraris et al. (2011) that extends a conference paper by the same authors (Ferraris et al.", "startOffset": 88, "endOffset": 111}, {"referenceID": 2, "context": "First-Order Loop Formulas and Herbrand Models We review the definition of a first-order loop formula for a nondisjunctive program given by Chen et al. (2006) and extend it to a disjunctive program and to an arbitrary first-order sentence.", "startOffset": 139, "endOffset": 158}, {"referenceID": 2, "context": "1 Review of First-Order Loop Formulas Defined by Chen et al. (2006) We call a formula negative if every occurrence of every predicate constant in it belongs to the antecedent of an implication.", "startOffset": 49, "endOffset": 68}, {"referenceID": 7, "context": ") When \u03a0 is a propositional program, LF \u03a0(Y ) is equivalent to a conjunctive loop formula as defined by Ferraris et al. (2006). The definition of a first-order dependency graph and the definition of a first-order loop are as follows.", "startOffset": 104, "endOffset": 127}, {"referenceID": 2, "context": "The original definition by Chen et al. (2006) does not allow function constants of positive arity.", "startOffset": 27, "endOffset": 46}, {"referenceID": 2, "context": "The following is a reformulation of Theorem 1 from the work of Chen et al. (2006).", "startOffset": 63, "endOffset": 82}, {"referenceID": 2, "context": "Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution \u03b8 that maps variables in Y1 to terms so that Y1\u03b8 = Y2.", "startOffset": 28, "endOffset": 47}, {"referenceID": 2, "context": "Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution \u03b8 that maps variables in Y1 to terms so that Y1\u03b8 = Y2. Proposition 1 (Chen et al., 2006, Proposition 7) For any nondisjunctive program \u03a0 and any loops Y1 and Y2 of \u03a0, if Y1 subsumes Y2, then LF \u03a0(Y1) entails LF \u03a0(Y2). Therefore in condition (c) from Theorem 1, it is sufficient to consider a set \u0393 of loops such that, for every loop L of \u03a0, there is a loop L\u2032 in \u0393 that subsumes L. Chen et al. (2006) called such \u0393 a complete set of loops.", "startOffset": 28, "endOffset": 538}, {"referenceID": 7, "context": "When \u03a0 and Y are propositional, LF \u03a0(Y ) is equivalent to the conjunctive loop formula for a disjunctive program as defined by Ferraris et al. (2006).", "startOffset": 127, "endOffset": 150}, {"referenceID": 7, "context": "It is also a generalization of the main theorem by Ferraris et al. (2006) which was restricted to a propositional disjunctive program.", "startOffset": 51, "endOffset": 74}, {"referenceID": 7, "context": "As with a propositional loop formula defined for an arbitrary propositional theory (Ferraris et al., 2006), it is convenient to introduce a formula whose negation is close to ES .", "startOffset": 83, "endOffset": 106}, {"referenceID": 7, "context": "When F and Y are propositional, LFF (Y ) is equivalent to a conjunctive loop formula for a propositional formula that is defined by Ferraris et al. (2006). The following lemma tells us that the definition of a loop formula in this section generalizes the definition of a loop formula for a disjunctive program in the previous section.", "startOffset": 132, "endOffset": 155}, {"referenceID": 7, "context": "Theorem 2 from the work of Ferraris et al. (2006) is a special case of Theorem 1f when F is restricted to a propositional formula.", "startOffset": 27, "endOffset": 50}, {"referenceID": 9, "context": "A sentence F is in Clark normal form (Ferraris et al., 2011) if it is a conjunction of formulas of the form", "startOffset": 37, "endOffset": 60}, {"referenceID": 5, "context": "SLF[F ] is similar to Clark\u2019s completion. In the propositional case, the relationship between the loop formulas of singletons and the completion is studied by Lee (2005). Below we describe their relationship in the first-order case.", "startOffset": 22, "endOffset": 170}, {"referenceID": 6, "context": "Corollary 4 is an enhancement of Theorem 11 from the work of Ferraris et al. (2011), which states the equivalence between SM[F ] and Comp[F ] for any tight sentence F in Clark normal form.", "startOffset": 61, "endOffset": 84}, {"referenceID": 10, "context": "A nonempty set U of atoms that occur in \u03a0 is a loop of \u03a0 iff, for every nonempty proper subset V of U , there is an edge from an atom in V to an atom in U \\ V in the dependency graph of \u03a0 (Gebser et al., 2006).", "startOffset": 188, "endOffset": 209}, {"referenceID": 5, "context": "1 Bounded Formulas and Clark\u2019s Equational Theory On the other hand, such a relationship holds if the interpretation satisfies Clark\u2019s equational theory (1978). Clark\u2019s equational theory of a signature \u03c3, denoted by CET\u03c3, is the union of the universal closures of the following formulas f(x1, .", "startOffset": 23, "endOffset": 159}, {"referenceID": 1, "context": "Consider another example program by Bonatti (2004), where a, .", "startOffset": 36, "endOffset": 51}, {"referenceID": 1, "context": "They actually satisfy a stronger condition called \u201cfinitely recursive\u201d (Bonatti, 2004).", "startOffset": 71, "endOffset": 86}, {"referenceID": 2, "context": "The proof of Proposition 10 (c) is based on the following fact and the straightforward extension of Theorem 2 by Chen et al. (2006) to first-order formulas, which asserts that checking if F has a finite complete set of loops is decidable.", "startOffset": 113, "endOffset": 132}, {"referenceID": 16, "context": "According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the \u201csmall predicate property\u201d: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F .", "startOffset": 13, "endOffset": 46}, {"referenceID": 16, "context": "According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the \u201csmall predicate property\u201d: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F . We will show that any semi-safe sentence under the stable model semantics can be turned into a sentence in first-order logic. First, we review the notion of semi-safety by Lee et al. (2009).13 As a preliminary step, we assign to every formula F a set RV(F ) of its restricted variables as follows: \u2022 For an atomic formula F , \u2013 if F is an equality between two variables, then RV(F ) = \u2205; \u2013 otherwise, RV(F ) is the set of all variables occurring in F ; \u2022 RV(G \u2227H) = RV(G) \u222a RV(H); \u2022 RV(G \u2228H) = RV(G) \u2229 RV(H); \u2022 RV(G\u2192 H) = \u2205; \u2022 RV(QvG) = RV(G) \\ {v} where Q \u2208 {\u2200,\u2203}.", "startOffset": 13, "endOffset": 476}, {"referenceID": 20, "context": "Proposition 12 (Lee et al., 2009) For any semi-safe sentence F , formula SM[F ] entails SPPc(F ).", "startOffset": 15, "endOffset": 33}, {"referenceID": 8, "context": "(2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al., 2007) in that it allows us to distinguish between intensional and non-intensional (a.", "startOffset": 93, "endOffset": 116}, {"referenceID": 7, "context": "Extension to Allow Extensional Predicates The definition of a stable model in the journal paper by Ferraris et al. (2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al.", "startOffset": 99, "endOffset": 122}, {"referenceID": 20, "context": "Proposition 15 (Lee et al., 2009) For any semi-safe sentence F relative to p, formula SM[F ; p] entails SPPpc(F ).", "startOffset": 15, "endOffset": 33}, {"referenceID": 1, "context": "Related Work The notion of a bounded program is related to the notion of a finitely recursive program studied by Bonatti (2004), where a different definition of a dependency graph was considered.", "startOffset": 113, "endOffset": 128}, {"referenceID": 27, "context": "Lin and Wang (2008) extended answer set semantics with functions by extending the definition of a reduct, and also provided loop formulas for such programs.", "startOffset": 0, "endOffset": 20}, {"referenceID": 25, "context": "Lin and Wang (2008) consider essentially many-sorted languages.", "startOffset": 0, "endOffset": 20}, {"referenceID": 27, "context": "The following conditions are equivalent to each other: (a) I is an answer set of P according to Lin and Wang (2008); (b) I is a P -interpretation that satisfies SM[F ]; (c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.", "startOffset": 96, "endOffset": 116}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c).", "startOffset": 136, "endOffset": 156}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics.", "startOffset": 136, "endOffset": 393}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures.", "startOffset": 136, "endOffset": 869}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels.", "startOffset": 136, "endOffset": 1038}, {"referenceID": 27, "context": "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program \u03a0 that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels. Chen, Lin, Zhang, and Zhou (2011) present a condition called \u201cloop-separable,\u201d which is more refined than finite complete set of loops under which the finite answer sets of a program can be captured by first-order sentences.", "startOffset": 136, "endOffset": 1207}, {"referenceID": 35, "context": "The use of first-order theorem provers for the stable model semantics was already investigated by Sabuncu and Alpaslan (2007), but their results are limited in several ways.", "startOffset": 98, "endOffset": 126}, {"referenceID": 1, "context": "Future work is to find further restrictions that make first-order stable model reasoning decidable and computable in an efficient manner, like the conditions imposed in \u201cfinitary\u201d programs (Bonatti, 2004).", "startOffset": 189, "endOffset": 204}, {"referenceID": 34, "context": "Lemma 13 For any terms t1 and t2 of signature \u03c3, any interpretation I that satisfies CET\u03c3, and any substitution \u03b8 from object variables in t1 and t2 to object names such that (t1\u03b8) I = (t2\u03b8) I , Robinson\u2019s unification algorithm (Robinson, 1965), when applied to t1 and t2, returns a most general unifier (mgu) \u03b3 of t1 and t2 such that (a) t1\u03b3 = t2\u03b3, and (b) for every variable x in t1 or t2, (x\u03b3\u03b8) I = (x\u03b8)I .", "startOffset": 228, "endOffset": 244}, {"referenceID": 15, "context": "1 from the work of Kunen (1987), t1 and t2 are unifiable, in which case Robinson\u2019s algorithm returns a mgu for t1 and t2 that maps variables occurring in t1 and t2 into terms.", "startOffset": 19, "endOffset": 32}, {"referenceID": 2, "context": "7 Proof of Proposition 11 We will use the following lemma in this section and the next section, which extends Theorem 2 in the work of Chen et al. (2006) that provides a few equivalent conditions for a program to have a finite complete set of loops to a disjunctive program and a sentence.", "startOffset": 135, "endOffset": 154}, {"referenceID": 1, "context": "The proof repeats, with minor modifications, the argument from the proof of Theorem 26 from the work of Bonatti (2004), which considers the following program \u03a0M to simulate deterministic Turing machines M.", "startOffset": 104, "endOffset": 119}, {"referenceID": 27, "context": "The following conditions are equivalent to each other: (a) I is an answer set of P according to Lin and Wang (2008); (b) I is a P -interpretation that satisfies SM[F ]; (c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.", "startOffset": 96, "endOffset": 116}, {"referenceID": 27, "context": "Given a program \u03a0, Norm(\u03a0) is a normal form of \u03a0 and Ground(\u03a0) is a ground program obtained from \u03a0 as described by Lin and Wang (2008). The proof of Proposition 16 follows from the following lemma.", "startOffset": 115, "endOffset": 135}], "year": 2011, "abstractText": "Lin and Zhao\u2019s theorem on loop formulas states that in the propositional case the stable model semantics of a logic program can be completely characterized by propositional loop formulas, but this result does not fully carry over to the first-order case. We investigate the precise relationship between the first-order stable model semantics and first-order loop formulas, and study conditions under which the former can be represented by the latter. In order to facilitate the comparison, we extend the definition of a first-order loop formula which was limited to a nondisjunctive program, to a disjunctive program and to an arbitrary first-order theory. Based on the studied relationship we extend the syntax of a logic program with explicit quantifiers, which allows us to do reasoning involving non-Herbrand stable models using first-order reasoners. Such programs can be viewed as a special class of firstorder theories under the stable model semantics, which yields more succinct loop formulas than the general language due to their restricted syntax.", "creator": "TeX"}}}