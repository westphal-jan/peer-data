{"id": "1401.3900", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "16-Jan-2014", "title": "Decidability and Undecidability Results for Propositional Schemata", "abstract": "we define a logic of propositional formula schemata adding to the syntax of propositional logic between indexed propositions and iterated connectives ranging over intervals parameterized by arithmetic variables. the satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called basic bound - linear, for which this assignment problem becomes decidable. this result is frequently obtained by reduction to a particular class of schemata called regular, for fixing which properties we provide a sound and complete terminating proof collection procedure. this schemata calculus allows one to capture proof patterns corresponding independently to a large class of problems specified in propositional logic. we also show that the resulting satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound - linear schemata represent a good compromise between expressivity and finite decidability.", "histories": [["v1", "Thu, 16 Jan 2014 05:20:30 GMT  (349kb)", "http://arxiv.org/abs/1401.3900v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["vincent aravantinos", "ricardo caferra", "nicolas peltier"], "accepted": false, "id": "1401.3900"}, "pdf": {"name": "1401.3900.pdf", "metadata": {"source": "CRF", "title": "Decidability and Undecidability Results for Propositional Schemata", "authors": ["Vincent Aravantinos", "Ricardo Caferra", "Nicolas Peltier"], "emails": ["Vincent.Aravantinos@imag.fr", "Ricardo.Caferra@imag.fr", "Nicolas.Peltier@imag.fr"], "sections": [{"heading": null, "text": "\u2228 or \u2227 ranging over\nintervals parameterized by arithmetic variables (e.g., \u2227n\ni=1 pi, where n is a parameter). The satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called bound-linear, for which this problem becomes decidable. This result is obtained by reduction to a particular class of schemata called regular, for which we provide a sound and complete terminating proof procedure. This schemata calculus (called stab) allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. We also show that the satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound-linear schemata represent a good compromise between expressivity and decidability."}, {"heading": "1. Introduction", "text": "Being able to solve classes of problems \u2013 possibly efficiently and elegantly \u2013 strongly depends on the language in which they are specified. This is decisive in a lot of applications of Artificial Intelligence. One language long used by humans is that of schemata. As very general characterizations of the notion of schema would be useless, we have focused on a particular class of schemata arising naturally in practice, quite expressive and (as will be shown) with \u201cgood\u201d computational properties. These schemata are those generated by unbounded repetitions of patterns, we call them \u2018iterated schemata\u2019.\nWe motivate our approach via an example, frequently used and well-known by the AI community: circuit verification. Circuit verification problems are often modeled as sequences of propositional problems parameterized by a natural number n that encodes the size of the data (e.g., the number of bits, number of layers in the circuit, etc.). We call these sequences iterated schemata, or simply schemata. A typical example is an n-bit sequential adder circuit i.e. a circuit which computes the sum of two bit-vectors of length n. Such a circuit is built by composing n 1-bit adders. The ith bits of each operand are written pi and qi. ri is the i\nth bit of the result and ci+1 is carried over to the next bit (thus c1 = 0). We set the notations (\u2295 denotes exclusive or):\nSumi(p, q, c, r) def = ri \u21d4 (pi \u2295 qi)\u2295 ci\nc\u20dd2011 AI Access Foundation. All rights reserved.\nand\nCarryi(p, q, c) def = ci+1 \u21d4 (pi \u2227 qi) \u2228 (ci \u2227 pi) \u2228 (ci \u2227 qi).\nThen the formula:\nAdder(p, q, c, r) def = n\u2227 i=1 Sumi(p, q, c, r) \u2227 n\u2227 i=1 Carryi(p, q, c) \u2227 \u00acc1\nwith the constraint n \u2265 1, schematises the adder circuit (it states that r encodes the sum of p and q). Adder contains iterations ranging on intervals depending on n. If n is instantiated by a natural number then the expression reduces to a propositional formula. Therefore each instance of this schema can be solved in propositional logic. However, proving that the schema is unsatisfiable (or satisfiable) for every instance of n is much harder. This problem cannot be specified in propositional logic and, as we shall see, this is even out of the scope of first-order logic. It can be expressed in higher order logics but it is well-known that such languages are less suitable for automation (see Section 3 for details).\nSuch iteration schemata are ubiquitous in formalized reasoning. Problems over finite domains can be specified as generic propositional formulae fitting the same pattern, the parameter being the (finite but unbounded) size of the domain. Among these patterns, those corresponding to the pigeonhole principle, Ramsey theory, coloring graphs problems or constraint programming specifications such as the n-queens problem (Marriott, Nethercote, Rafeh, Stuckey, Garc\u0301\u0131a de la Banda, & Wallace, 2008) should be mentioned. Iterated schemata are also extremely useful for the formalization of mathematical proofs, because they allow one to express infinite proof sequences, which can avoid, for instance, explicit use of the induction principle. This idea has been used, e.g., in the work of Hetzl, Leitsch, Weller, and Woltzenlogel Paleo (2008).\nIn this paper we present the first (to the best of our knowledge) thorough analysis of propositional iterated schemata. We define a logic handling arithmetic variables, indexed propositions and iterated connectives. The satisfiability problem is obviously semi-decidable in the sense that a (straightforward) algorithm exists to enumerate all satisfiable schemata (i.e. all schemata with a satisfiable instance). However the set of (unrestricted) unsatisfiable schemata is not recursively enumerable. Thus we restrict ourselves to a particular class of schemata, called bound-linear and we provide a decision procedure for this class. This procedure is based on a reduction to a very simple class of schemata, called regular, for which a tableaux-based proof procedure is presented. Then we provide some undecidability results for (rather natural) extensions of this class.\nThe rest of the paper is structured as follows.\n\u2022 In Section 2 we introduce a logic (syntax and semantics) for handling propositional schemata and we establish some of its basic properties. The propositional symbols are indexed by arithmetic expressions (e.g., pn+1) containing arithmetic variables. These variables can be either parameters (i.e. free variables), or bound variables introduced by generalized connectives of the form \u2228b i=a or \u2227b i=a. These connectives can be read as\n\u2203i \u2208 [a, b] or \u2200i \u2208 [a, b], where a, b are arithmetic expressions possibly containing (free or bound) variables. We restrict ourselves to monadic schemata (i.e. the propositions\nare indexed by at most one expression) and to linear arithmetic expressions1. We then introduce a particular subclass of schemata, called bound-linear. Intuitively, a schema is bound-linear if every arithmetic expression occurring in it contains at most one bound variable. Furthermore, the coefficient of this variable in the expression should be \u00b11 (or 0). Thus expressions such as 1, n, 2n \u2212 i or i + 2 are allowed (where n is the parameter and i a bound variable), but 2i or i+ j (where i, j are both bound) are not. The coefficient of the parameter n is not constrained.\n\u2022 Section 3 contains a brief survey of existing work on propositional schemata as well as (informal) comparisons with related logics.\n\u2022 In Section 4 we introduce a simpler class of schemata, called regular, and we provide an algorithm to transform every bound-linear schema into a (sat-)equivalent regular schema.\n\u2022 In Section 5 a tableaux-based proof procedure, called stab (standing for schemata tableaux), is introduced for reasoning with propositional schemata. This proof procedure is sound and complete (w.r.t. satisfiability) and terminates on every regular schema. Together with the results in Section 4 this implies that the class of boundlinear schemata is decidable.\n\u2022 Section 6 shows that relaxing very slightly the conditions on bound-linear schemata makes the satisfiability problem undecidable. Thus this class can be seen as \u201ccanonical\u201d, with a good trade-off between expressivity, simplicity of the definition and decidability.\n\u2022 Finally, Section 7 summarizes the results and provides some lines of future work."}, {"heading": "2. Schemata of Propositional Formulae", "text": "In this section, we introduce the syntax and semantics of propositional schemata."}, {"heading": "2.1 Syntax", "text": "The set of linear arithmetic expressions (denoted by N ) is built as usual on the signature 0, s,+,\u2212 and on a fixed and countably infinite set of arithmetic variables V, quotiented by the usual properties of the arithmetic symbols (e.g., n + s(0) + n + s(s(s(0))) and n + n + s(s(s(s(0)))) are assumed to be equivalent). As usual, s\u03ba(0) is denoted by \u03ba and i + . . . + i (\u03ba times) is \u03ba.i. If n is an arithmetic variable we denote by N\u00d7n the set of arithmetic expressions of the form \u03b1.n + \u03b2 where \u03b1, \u03b2 \u2208 Z (with possibly \u03b1 = 0) and by Nn the set of expressions of the form n + \u03b2 where \u03b2 \u2208 Z. Obviously Nn \u2282 N\u00d7n \u2282 N . If n+ \u03b1, n+ \u03b2 \u2208 Nn we write n+ \u03b1 \u2264 n+ \u03b2 iff \u03b1 \u2264 \u03b2.\n1. If one of these two conditions does not hold then the satisfiability problem is trivially undecidable. For instance, the Post correspondence problem can be easily encoded into schemata with non monadic variables (Aravantinos, Caferra, & Peltier, 2009b). Similarly, if non linear arithmetic expressions are considered then the 10th Hilbert\u2019s problem can be encoded.\nFor the sake of readability, we adopt the following conventions. Integers are denoted by Greek letters \u03b1, \u03b2, \u03b3, \u03b42, natural numbers by \u03ba or \u03b9, arithmetic variables by i, j, k, n, propositional variables by p, q, r (with indices). Arithmetic expressions are denoted by a, b, c, d. Schemata are denoted by \u03d5, \u03c8. \u03a0 and \u0393 denote generic iteration connectives \u2228 or\u2227\n.\nDefinition 2.1 (Indexed propositions) Let P be a fixed and countably infinite set of propositional symbols. An indexed proposition is an expression of the form pa where p \u2208 P and a is a linear arithmetic expression (the index ). An indexed proposition pa s.t. a \u2208 Z is called a propositional variable. A literal is an indexed proposition or its negation.\nIn contrast to our previous work (Aravantinos et al., 2009b) we only consider monadic propositions, i.e. every proposition has only one index.\nDefinition 2.2 (Schemata) The set of formula schemata is the smallest set satisfying the following properties.\n\u2022 \u22a4, \u22a5 are formula schemata.\n\u2022 If a, b are integer expressions then a < b is a formula schema.\n\u2022 Each indexed proposition is a formula schema.\n\u2022 If \u03d51, \u03d52 are schemata then \u03d51 \u2228 \u03d52, \u03d51 \u2227 \u03d52 and \u00ac\u03d51 are formula schemata.\n\u2022 If \u03d5 is a formula schema not containing <, and if a, b \u2208 N , and i is an arithmetic variable, then \u2227b i=a \u03d5 and \u2228b i=a \u03d5 are formula schemata.\nNotice that, by definition, every schema must be finite. Schemata of the form a < b, pa or \u22a4,\u22a5 are called atoms. Schemata of the form \u2227b i=a \u03d5 and \u2228b i=a \u03d5 are called iterations, a and b are the bounds of the iteration and b\u2212 a is its length (notice that b\u2212 a may contain variables). A schema is an arithmetic formula iff it contains no iteration and if every atom occurring in it is of the form \u22a4,\u22a5 or a < b. In particular, every boolean combination of arithmetic atoms is a schema. a \u2264 b (or b \u2265 a) and a = b are used as abbreviations for \u00ac(b < a) and \u00ac(b < a) \u2227 \u00ac(a < b) respectively. As for arithmetic expressions, arithmetic formulae are taken up to arithmetic equivalence, e.g., n = 1 and n < 2\u2227n > 0 are considered identical. The usual priority rules apply to disambiguate the reading of formula schemata. Analogously to first-order logic quantifiers, the iteration operators have the highest priority (e.g., \u2227n i=1 pi \u2228 pn \u2227 \u00acp1 should be read as ( \u2227n i=1 pi) \u2228 (pn \u2227 \u00acp1)). Example 2.3\n\u03d5 = q1 \u2227 n\u2227\ni=1 pi+2n \u2227 2n+1\u2228 j=n (\u00acqn\u2212j \u2228 qj+1)  \u2227 n \u2265 0 is a formula schema. q1, pi, qj and qj+1 are indexed propositions. \u2227n i=1 ( pi+2n \u2227 \u22282n+1 j=n (\u00acqn\u2212j \u2228 qj+1)\n) and\u22282n+1\nj=n (\u00acqn\u2212j \u2228 qj+1) are the only iterations occurring in S.\n2. This slightly unusual convention is used to avoid confusion between arithmetic variables and integers.\nRemark 2.4 Notice that the arithmetic atoms of the form a < b can only occur outside the iterations, i.e. n \u2265 1 \u21d2 \u2228n i=1 pi is allowed, but neither \u2228n i=1(i \u2264 3 \u2228 pi) nor \u2228n i=1(n \u2265 1 \u21d2 pi). This restriction is only used to simplify technicalities. As we shall see in Definition 2.5 (semantics of schemata), an arithmetic atom of the form a < b is equivalent to the schema \u2228b i=a+1\u22a4.\nA variable i is bound in \u03d5 if \u03d5 contains an iteration of the form \u03a0bi=a\u03c8 (\u03a0 \u2208 { \u2228 , \u2227 }), it is free (or is a parameter of \u03d5) if it has an occurrence in \u03d5 which is not in the scope of an iteration \u03a0bi=a\u03c8. From now on, we assume that no variable is simultaneously free and bound in a schema \u03d5 (thus schemata such as pn \u2227 \u222810 n=1 \u00acpn are not well-formed) and that if \u03a0bi=a\u03c8 and \u0393 d j=c\u03c8 \u2032 (where \u03a0,\u0393 \u2208 { \u2228 , \u2227 }) are two distinct iterations occurring in \u03d5 then i and j are distinct.\nA substitution is a function mapping every arithmetic variable to a linear arithmetic expression. We write [a1/i1, . . . , a\u03ba/i\u03ba] for the substitution mapping respectively i1, . . . , i\u03ba to a1, . . . , a\u03ba. The application of a substitution \u03c3 to a schema (or arithmetic expression) \u03d5 is defined as usual and denoted by \u03d5\u03c3. Notice that if a is an arithmetic expression and \u03c3 a substitution mapping every variable in a to a ground term (i.e. a term with no variable) then a\u03c3 is an integer (since we identify, e.g., 2\u2212 1 and 1).\nThe previous notation is also used to denote the replacement of subexpressions: If \u03d5 is a schema, \u03c8 is an expression (schema or arithmetic expression) occurring in \u03d5 and \u03c8\u2032 is an expression of the same type as \u03c8, then \u03d5[\u03c8\u2032/\u03c8] denotes the formula obtained by replacing all the occurrences of \u03c8 in \u03d5 by \u03c8\u2032."}, {"heading": "2.2 Semantics", "text": "An interpretation of the schemata language is a function mapping every integer variable to an integer and every propositional variable to a truth value T or F. If I is an interpretation and \u03c3 a substitution, we denote by I\u03c3 the interpretation defined as follows: I\u03c3 and I coincide on every propositional variable and for every variable n, I\u03c3(n) def= I(n\u03c3). Consider for instance the following interpretation I:\nn 7\u2192 5 m 7\u2192 2 p1 7\u2192 T p2 7\u2192 F p3 7\u2192 F p4 7\u2192 F\nand whose definition is unsignificant for other (integer or propositional) variables. Let also be \u03c3 the substitution {n 7\u2192 n\u2212 1,m 7\u2192 m\u2212 2}. Then I\u03c3 is:\nn 7\u2192 4 m 7\u2192 0 p1 7\u2192 T p2 7\u2192 F p3 7\u2192 F p4 7\u2192 F\nIf I is an interpretation, we denote by \u03c3I the restriction of I to V, i.e. the substitution mapping every variable n to I(n). If a is an arithmetic expression, we denote by JaKI the expression a\u03c3I . Since a\u03c3I is ground, it is (equivalent to) an integer.\nDefinition 2.5 (Semantics) The truth value J\u03d5KI of a propositional schema in an interpretation I is inductively defined as:\n\u2022 J\u22a4KI = T, J\u22a5KI = F \u2022 Ja < bKI = T iff JaKI < JbKI . \u2022 JpaKI = I(pJaKI ) for p \u2208 P. \u2022 J\u00ac\u03a6KI = T iff J\u03a6KI = F. \u2022 J\u03a6 \u2228 \u03a6\u2032KI = T iff J\u03a6KI = T or J\u03a6\u2032KI = T. \u2022 J\u03a6 \u2227 \u03a6\u2032KI = T iff J\u03a6KI = T and J\u03a6\u2032KI = T. \u2022 J\u2228bi=a \u03d5KI = T iff there is an integer \u03b1 s.t. JaKI \u2264 \u03b1 \u2264 JbKI and J\u03d5KI[\u03b1/i] = T. \u2022 J\u2227bi=a \u03d5KI = T iff for every integer \u03b1 s.t. JaKI \u2264 \u03b1 \u2264 JbKI : J\u03d5KI[\u03b1/i] = T.\nA schema \u03d5 is satisfiable iff there is an interpretation I s.t. J\u03d5KI = T. I is called a model of \u03d5 (written I |= \u03d5). Two schemata \u03d5, \u03c8 are equivalent (written \u03d5 \u2261 \u03c8) iff I |= \u03d5 \u21d4 I |= \u03c8. \u03d5 and \u03c8 are sat-equivalent (written \u03d5 \u2261S \u03c8) iff \u03d5 and \u03c8 are both satisfiable or both unsatisfiable.\nIn the following, we assume that for every free variable n in \u03d5 and for every model I of \u03d5, I(n) \u2208 N. This can be ensured by explicitly adding the arithmetic atom n \u2265 0 to \u03d53.\nLet S be the following system of rewrite rules:\n3. Thus we assume that parameters are mapped to natural numbers. This convention is convenient because it allows one to use mathematical induction on the parameters (see Section 5.2). It is not restrictive since a schema \u03d5 where n \u2208 Z could be replaced by the (equivalent) disjunction of the schemata \u03d5 \u2227 n \u2265 0 and \u03d5[\u2212m/n] \u2227m \u2265 0 (i.e. in the case in which n is negative, every occurrence of n is simply replaced by \u2212m).\nS =  \u2228\u03b2 i=\u03b1 \u03d5 \u2192 \u22a5 if \u03b1, \u03b2 \u2208 Z, \u03b2 < \u03b1\u2227\u03b2 i=\u03b1 \u03d5 \u2192 \u22a4 if \u03b1, \u03b2 \u2208 Z, \u03b2 < \u03b1\u2228\u03b2 i=\u03b1 \u03d5 \u2192 ( \u2228\u03b2\u22121 i=\u03b1 \u03d5) \u2228 \u03d5[\u03b2/i] if \u03b1, \u03b2 \u2208 Z, \u03b2 \u2265 \u03b1\u2227\u03b2\ni=\u03b1 \u03d5 \u2192 ( \u2227\u03b2\u22121 i=\u03b1 \u03d5) \u2227 \u03d5[\u03b2/i] if \u03b1, \u03b2 \u2208 Z, \u03b2 \u2265 \u03b1\nFor instance the following formula:\n\u00acp1 \u2227 3\u2227\ni=1\n(pi \u21d2 pi+1)\nis rewritten into:\n\u00acp1 \u2227 (p1 \u21d2 p2) \u2227 (p2 \u21d2 p3) \u2227 (p3 \u21d2 p4) Notice that no rule of S applies on \u00acp1\u2227 \u2227n\ni=1(pi \u21d2 pi+1) as the upper bound of the iteration contains a parameter. S is actually designed to be used only on schemas whose parameters have been instantiated by a number.\nProposition 2.6 S is convergent and preserves equivalence."}, {"heading": "Proof", "text": "Termination is immediate since the length of an iteration strictly decreases at each step. Confluence is obvious since the critical pairs are trivially joinable. The fact that the obtained schema is equivalent to the original one is a straightforward consequence of Definition 2.5.\nWe denote by \u03d5\u2193S the (unique) normal form of \u03d5. If \u03c3 is a substitution mapping every free variable in \u03d5 to a natural number, \u03d5\u03c3\u2193S is called a propositional realization of \u03d5.\nIt is trivially semi-decidable to know if a schema is satisfiable:\nProposition 2.7 The set of satisfiable schemata is recursively enumerable."}, {"heading": "Proof", "text": "By Definition 2.5, for every interpretation I and for every schema \u03d5, we have (I |= \u03d5) \u21d4 (I |= \u03d5\u03c3), where \u03c3 = \u03c3I . Thus \u03d5 is satisfiable iff there exists a substitution \u03c3 such that \u03d5\u03c3 is satisfiable. We now prove that there exists an algorithm for checking the satisfiability of \u03d5\u03c3. By Proposition 2.6, we have \u03d5\u03c3 \u2261 \u03d5\u03c3 \u2193S . By definition of \u03c3, \u03d5\u03c3 contains no free variable. Let \u03a0bi=a\u03d5 be an outermost iteration in \u03d5. By definition a and b must be ground, thus one of the rules in S applies which is impossible. Thus \u03d5\u03c3 \u2193S contains no iteration hence \u03d5\u03c3\u2193S is a propositional formula (in the usual sense) built on the set of propositional variables. Consequently, there exists an algorithm to check whether the formula \u03d5\u03c3\u2193S\u2261 \u03d5\u03c3 is satisfiable or not. Since the set of ground substitutions is recursively enumerable, and since \u03d5 is satisfiable iff \u03d5\u03c3 is satisfiable for at least one substitution \u03c3, this implies that it is semi-decidable to check whether \u03d5 is satisfiable or not.\nFor every schema \u03d5 and for every substitution \u03c3 we denote by [\u03d5]\u03c3 the formula \u03d5\u03c3\u2193S . For every arithmetic expression a (possibly containing bound variables) in a schema \u03d5, we compute an interval [min\u03d5(a),max\u03d5(a)] where min\u03d5(a),max\u03d5(a) are arithmetic expressions only containing variables that are free in \u03d5. The intuition is that a always \u201cbelongs\u201d to this interval. Lemma 2.8 formalizes this property.\n\u2022 If a is an integer or a variable that is free in \u03d5 then min\u03d5(a) def = max\u03d5(a) def = a.\n\u2022 If a is of the form b+ c then min\u03d5(a) def = min\u03d5(b)+min\u03d5(c) and max\u03d5(a) def = max\u03d5(b)+\nmax\u03d5(c).\n\u2022 If a is of the form \u2212b then max\u03d5(a) def = \u2212min\u03d5(b) and min\u03d5(a) def = \u2212max\u03d5(b).\n\u2022 If i is a bound variable, occurring in an iteration of the form \u03a0bi=a\u03d5 then min\u03d5(i) def =\nmin\u03d5(a) and max\u03d5(i) def = max\u03d5(b).\nA ground substitution \u03c3\u2032 is a \u03d5-expansion of another ground substitution \u03c3 for a subschema \u03c8 in \u03d5 iff for every variable i that is bound in \u03c8, \u03c3\u2032(i) \u2208 [\u03c3(min\u03d5(i)), \u03c3(max\u03d5(i))] (since \u03c3, \u03c3\u2032 are ground, the expressions \u03c3\u2032(i), \u03c3(min\u03d5(i)), \u03c3(max\u03d5(i)) are considered as integers). The intuition behind \u03d5-expansions is the following: A substitution \u03c3 does not affect the bound variables of a schema; so the values given by \u03c3 to such bound variables are unsignificant; on the contrary, the definition of a \u03d5-expansion \u03c3\u2032 imposes that:\n1. the value given to a variable i bound in \u03d5 indeed falls in the set of values that i can take in the context of \u03d5 ;\n2. the value given by \u03c3\u2032 to a variable free in \u03d5 is the same as the one given by \u03c3.\nW.r.t. substitution application, there is no difference between \u03c3 and \u03c3\u2032. The next lemma shows the importance of \u03d5-expansions.\nLemma 2.8 Let \u03d5 be a schema and let i be a variable (possibly bound) occurring in \u03d5. The expressions min\u03d5(i) and max\u03d5(i) are well-defined. Moreover, for every ground substitution \u03c3 and for all atoms p\u03b1 occurring in [\u03d5]\u03c3 there exist an atom pa occurring in \u03d5 and a \u03d5-expansion \u03c3 \u2032 of \u03c3 for pa s.t. \u03c3 \u2032(a) = \u03b1."}, {"heading": "Proof", "text": "This is an immediate consequence of Definition 2.5 (by a straightforward induction on the depth of the schema).\nWe write IC (\u03d5) (standing for \u201cInterval Constraints\u201d) for the conjunction of arithmetic constraints of the form min\u03d5(i) \u2264 i \u2227 i \u2264 max\u03d5(i) where i is a variable that is bound in \u03d5. IC (\u03d5) can be extended to sets of schemata by handling them as conjunctions.\nConsider, e.g., \u03d5 = p0 \u2227 \u2227n\u22121\ni=1 (pi+1 \u2227 \u00acqi). We have: min\u03d5(i) = 1 and max\u03d5(i) = n\u2212 1. Consider furthermore \u03c3 = {n 7\u2192 4} and p\u03b1 = p3. Then we can take pa = pi+1 (which indeed occurs in \u03d5) and \u03c3\u2032 = {n 7\u2192 4, i 7\u2192 2}.\nWe see informally the use of \u03d5-expansions: they allow, in some sense, to make the connection between a propositional variable occurring in the instance of a schema and the indexed proposition where it \u201ccomes from\u201d."}, {"heading": "2.3 The Class of Bound-Linear Schemata", "text": "As we shall see (in, e.g., Theorem 6.2) the satisfiability problem is undecidable for schemata. In order to characterize a decidable subclass, we introduce the following definition:\nDefinition 2.9 A schema \u03d5 is bound-linear iff the following conditions hold:\n1. \u03d5 contains at most one free arithmetic variable n (called the parameter of \u03d5).\n2. Every non arithmetic atom in \u03d5 is of the form p\u03b1.n+\u03b2.i+\u03b3 where p \u2208 P and i is a bound variable, \u03b1, \u03b3 \u2208 Z and \u03b2 \u2208 {\u22121, 0, 1}.\n3. If \u03a0bi=a\u03c8 is an iteration in \u03d5 (where \u03a0 \u2208 { \u2228 , \u2227 }) then a, b are respectively of the form\n\u03b1.n+\u03b2 and \u03b3.n+ \u03b4+ \u03f5.j where \u03b1, \u03b2, \u03b3, \u03b4 \u2208 Z, \u03f5 \u2208 {\u22121, 0, 1} and j is a bound variable.\nThis class is comprehensive enough with respect to decidable satisfiability. The key point is that all the indices and iteration bounds contain at most one bound variable. Furthermore, the coefficient of this variable must be 1 (or 0)."}, {"heading": "2.4 Expressiveness of Bound-Linear Schemata", "text": "In order to show evidence that the class of bound-linear schemata is not an artificial or too narrow one, we provide in this section some examples of problems that can be naturally encoded into bound-linear schemata.\nIt is easy to check that the schema Adder(p, q, c, r) defined in the Introduction (formalizing a sequential adder) is bound-linear. Various properties of this circuit can be encoded. For instance, the following schema checks that 0 is a (left) neutral element:\n(Adder(p, q, c, r) \u2227 n\u2227\ni=1\n\u00acpi) \u21d2 n\u2227\ni=1\n(ri \u21d4 qi)\nThe schema below checks that the adder is a function i.e. that the sum of two operands is unique.\n(Adder(p, q, c, r) \u2227Adder(p, q, c\u2032, r\u2032)) \u21d2 n\u2227\ni=1\n(ri \u21d4 r\u2032i)\nThe next one checks that it is commutative:\n(Adder(p, q, c, r) \u2227Adder(q, p, c\u2032, r\u2032)) \u21d2 n\u2227\ni=1\n(ri \u21d4 r\u2032i)\nMany similar circuits can be formalized in a similar way, such as a carry look-ahead adder (a faster version of the n-bit adder that reduces the amount of time required to compute carry bits):\nCLA-Adder(p, q, c) def = n\u2227 i=1 (ri \u21d4 ((pi \u2295 qi)\u2295 ci)) \u2227 n\u2227 i=1 (ci+1 \u21d4 (pi \u2227 qi) \u2228 (ci \u2227 (pi \u2228 qi)))\nThe equivalence of the two definitions is encoded as follows:\n(Adder(p, q, c, r) \u2227 CLA-Adder(p, q, c\u2032, r\u2032)) \u21d2 n\u2227\ni=1\n(ri \u21d4 r\u2032i)\nComparison between two natural numbers can easily be formalized, e.g. rn holds iff p \u2265 q:\nr0 \u2227 n\u2227\ni=1\n(ri \u21d4 (ri\u22121 \u2227 (pi \u21d4 qi) \u2228 pi \u2227 \u00acqi))\nBy composing the previous schemata, any (quantifier-free) formula of Presburger arithmetic can be encoded.\nMore generally, one can formalize every circuit composed by serially putting together n layers of the same basic circuit. These circuits are usually defined inductively, which can be easily encoded into our formalism with a formula of the form:\n(p0 \u21d4 \u03d5base) \u2227 n\u22121\u2227 i=0 (pi+1 \u21d4 \u03d5ind),\nwhere \u03d5base and \u03d5ind are the formulae corresponding to the base case and inductive case, respectively. \u03d5ind contains some occurrences of pi and encodes the basic circuit to be composed in sequence. Of course, for most complex circuits, pi may be replaced by a vector of bits pi, qi, ri defined inductively from the pi\u22121, qi\u22121, ri\u22121,. . . . Such inductively-defined circuits appear very frequently in practice (Gupta & Fisher, 1993).\nIf the index of the proposition denotes the time, then various finite state sequential systems can be encoded. The state of the system is described by a set of propositional variables, and pi encodes the value of p at step i. The parameter n denotes the number of steps in the transformation (which is assumed to be finite but unbounded). The transition function from state i to i + 1 can easily be formalized by a bound-linear schema. For instance, the inclusion of two automata can be encoded (the parameter being the length of the run). We provide another example. Consider a register with three cells p, q, r and assume that there are two possible actions rl and rr that rotate the values of the cells to the left and to the right respectively. The behavior of this system is modeled by the following schema (the propositions rli and rri indicate which action is applied at step i). First L(i) expresses the state of the registers at time i depending on their state at time i \u2212 1, when rli has been applied to it:\nL(i) \u2261 rli \u21d2 ((pi \u21d4 qi\u22121) \u2227 (qi \u21d4 ri\u22121) \u2227 (ri \u21d4 pi\u22121))\nThen R(i) is similar for rr:\nR(i) \u2261 rri \u21d2 ((pi \u21d4 ri\u22121) \u2227 (qi \u21d4 pi\u22121) \u2227 (ri \u21d4 qi\u22121))\nFinally, we state that this holds at any time:\n\u03d5n \u2261 n\u2227\ni=1\nL(i) \u2227 n\u2227\ni=1\nR(i)\nWe can then express properties on such registers. For instance, the following formula states that n rotations to the right followed by n rotations to the left are equivalent to identity:\n(\u03d52n \u2227 n\u2227\ni=1\nrri \u2227 2n\u2227\ni=n+1\nrli) \u21d2 (p0 \u21d4 p2n) \u2227 (q0 \u21d4 q2n) \u2227 (r0 \u21d4 r2n)"}, {"heading": "3. Related Work", "text": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of \u2018schema\u2019 is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given. The authors overview the state of the art (by describing and comparing most powerful existing systems in use) but structuring proofs is not explicitly mentioned (maybe this feature can be included in what they call \u201cmathematical style\u201d or \u201csupport reasoning with gaps\u201d). In our approach to schemata it is clear that they are a way of structuring proofs and can also help to overcome one of the obstacles to the automation of reasoning pointed out by Wos (1988), i.e. the size of deduction steps.\nThere exist term languages expressive enough to denote iteration schemata as those introduced in Definition 2.2: In particular, term schematisation languages can be used to denote infinite sequences of structurally similar terms or formulae. For instance the primal grammar (Hermann & Galbavy\u0301, 1997) f\u0302(n) \u2192 (p(n) \u2228 f\u0302(n\u2212 1)), f\u0302(0) \u2192 \u22a5 denotes the iteration \u2228n i=1 pi. It is worth mentioning that this iteration cannot be denoted by other term schematisation languages (Chen, Hsiang, & Kong, 1990; Comon, 1995) because the inductive context is not constant. However, term schematisation languages do not allow to reason on such iterations (they are only useful to represent them).\nEncoding schemata into first-order logic is a very natural idea, interpreting iterated connectives as bounded quantifiers. Additional axioms can be added to express arithmetic properties if needed. For instance the schema ( \u2228n i=1 pi) \u2227 ( \u2227n i=1 \u00acpi) can be encoded by \u2203i.(1 \u2264 i \u2227 i \u2264 n \u2227 p(i)) \u2227 \u2200i.(1 \u2264 i \u2227 i \u2264 n \u21d2 \u00acp(i)) which is obviously unsatisfiable. However, since inductive domains cannot be defined in first-order logic, such a translation necessarily introduces some unintended interpretations hence does not yield a complete procedure (satisfiability is not always preserved, although the unsatisfiability of the obtained formula necessarily entails the unsatisfiability of the original one). For instance, the schema p0\u2227 \u2227n i=1(pi\u22121 \u21d2 pi)\u2227\u00acpn is translated into p(0)\u2227\u2200i.(1 \u2264 i\u2227i \u2264 n\u2227p(i\u22121) \u21d2 p(i)\u2227\u00acp(n)),\nwhich is actually satisfiable (we do not know that n \u2208 N and there is no way to express this property). In order to obtain an unsatisfiable formula, some inductive axioms must be added to allow (necessarily restricted) applications of the induction principle. In this particular case, the proof can be obtained by a simple induction on i using the inductive lemma \u2200i.(i \u2264 n \u21d2 p(i)), thus we could add the axiom: [q(0)\u2227\u2200i.(q(i) \u21d2 q(i+1))] \u21d2 \u2200i.q(i) where q(i) \u2261 i \u2264 n \u21d2 p(i). With this axiom, it is easy to check that the previous formula becomes unsatisfiable. However, in the general case it is hard to determine a priori the right axiom (if there is one). Actually the termination proof in Section 5 implicitly provides a way to determine candidate axioms (for the particular class of regular schemata): every looping node in the tableaux constructed by the proof procedure stab (see Section 5) corresponds to an application of the induction principle, hence to an induction axiom. The termination proof precisely shows that the size of these inductive lemmata is bounded, thus the whole set of potential induction axioms could be in principle computed and added to the formula before the beginning of the search. But the practical interest of this transformation is obviously highly questionable.\nSeveral procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001). Since schemata can be seen as an \u201cexplicit way\u201d of handling mathematical induction, using such proof procedures for proving them is a very natural idea. In general, induction is used to define terms (e.g., recursive functions operating on inductive data structures), whereas in our case the formulae themselves are defined inductively. Obviously this problem could be solved by using an appropriate encoding of the formulae. However there are very few decidability results in inductive theorem proving and known classes (Giesl & Kapur, 2001) are not expressive enough to encode propositional schemata. Notice that most systems concentrate on universal quantifications, where we have to handle both iterated conjunctions (which can be interpreted as universal quantification on a finite domain) and iterated disjunctions (i.e. the analogous of existential quantifications). Adding existential quantification in inductive theorem proving is known to be a difficult problem. Most inductive theorem provers are designed to prove universal theorems of the form \u2200x\u20d7.\u03c8 where \u03c8 is a quantifier-free formula (usually a clause) and the variables in x\u20d7 range over the set of (finite) terms. In our context, \u03c8 would contain finite quantification (over intervals constrained by n), corresponding to the iterated connectives. In particular, schemata may have several models, thus implicit induction (Comon, 2001) (which explicitly requires that the underlying Herbrand model is unique) cannot be (directly) used.\nOf course, these problems can be overcome by encoding interpretations as terms (for instance by vectors or ordered lists of truth values) and schemata as functions mapping every interpretation to a truth value. Then inductive theorem provers may be used to prove inductive properties of these functions (showing for instance that their value is \u22a5 for every interpretation). However these provers are not complete (due to well-known theoretical limitations) thus the practical interest of this encoding is unclear. For instance, we have tried to use the theorem prover acl2 to prove the validity of some of the benchmarks considered in Section 5, but it fails on all non trivial examples. We conjecture that this is not only due to efficiency problems, but that additional inductive lemmata are needed, which are very hard to determine in advance.\nThe above definitions should also remind the reader of fixed point logics. Indeed iterated schemata are obviously particular cases of fixed points, e.g., the schema \u2227n i=1 pi might be represented as (\u00b5X(i).i \u2264 0\u2228(p(i)\u2227X(i\u22121)))(n). The \u201cstandard\u201d fixed point logic is the (propositional) modal \u00b5-calculus (Bradfield & Stirling, 2007) in which many temporal logics can be encoded, e.g., LTL or CTL. However the involved logic is very different from ours and actually simpler from a theoretical point of view. Indeed modal \u00b5-calculus is decidable (and thus complete) whereas \u2013 as we shall see in Section 6 \u2013 iterated schemata are not (nor are they complete). Furthermore, our language allows one to use complex (though carefully restricted) arithmetic operations in the definition of the iterations, both in the indices and in the bounds. For instance we may relate the truth values of two propositions whose index are arbitrary far from each other (such as pi and pn\u2212i). As far as we are aware, these operations cannot be directly encoded into propositional \u00b5-calculus.\nActually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables. However we do no know of any calculus for deciding the satisfiability in LFP. We see two reasons for this: first, LFP is undecidable and not complete, second the purposes of this logic are mainly theoretical, hence the fact that research in this field has not focussed on decision procedures for some subclasses. In contrast with propositional \u00b5calculus, first-order \u00b5-calculus (Park, 1976) clearly embeds iterated schemata (allowing for instance the above fixed-point expression of \u2227n i=1 pi), but no published research seems to be focused on the identification of complete subclasses. With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it.\nAs we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Gore\u0301, 1999), or \u00b5-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction. A particular advantage of cyclic proofs is that finding an invariant is not needed, making them particularly suited to automation. However, once again those studies are essentially theoretical and there are no completeness results for particular subclasses.\nTo summarize, known decidable logics (such as propositional \u00b5-calculus) or even semidecidable ones such as first-order logic are not expressive enough to directly embed iterated schemata, whereas those that are sufficiently expressive (such as fixpoint or higher order logics) are not suitable for automation. Together with the potential applications mentioned in Section 2.4, this justifies to our opinion the interest of the considered language."}, {"heading": "4. Reduction to Regular Schemata", "text": "In this section we reduce the satisfiability problem for bound-linear schemata (see Definition 2.9) to a much simpler class of schemata, called regular. This class is defined as follows:\nDefinition 4.1 A schema \u03d5 is:\n\u2022 flat if for every iteration \u03a0bi=a\u03c8 occurring in \u03d5, \u03c8 does not contain any iteration (i.e. iterations cannot be nested in \u03d5).\n\u2022 of bounded propagation if every atom that occurs in an iteration \u03a0bi=a\u03c8 in \u03d5 is of the form pi+\u03b3 for some \u03b3 \u2208 Z. Since the number of atoms is finite, there exist \u03b1, \u03b2 \u2208 Z s.t. for every atom pi+\u03b3 occurring in an iteration we have \u03b3 \u2208 [\u03b1, \u03b2]. \u03b1, \u03b2 are called the propagation limits.\n\u2022 aligned on [c, d] if all iterations occurring in \u03d5 are of the form \u03a0di=c\u03c8 (i.e. all iterations must have the same bounds).\n\u2022 regular if it has a unique parameter n and if it is flat, of bounded propagation and aligned on [\u03b1, n\u2212 \u03b2] for some \u03b1, \u03b2 \u2208 Z.\nAs an example, the schema Adder defined in the Introduction is regular, but the last example in Section 2.4 (three cells register with shift) is not. Obviously, every regular schema is also bound-linear (see Definition 2.9). We now define an algorithm that transforms every bound-linear schema into a sat-equivalent regular one. This result is somewhat surprising because the class of regular schemata seems much simpler than bound-linear schemata. In some sense, it points at regular schemata as a canonical decidable class of schemata."}, {"heading": "4.1 Overview of the Transformation Algorithm", "text": "We first give an informal overview of the algorithm reducing every bound-linear schema into a regular one, together with examples illustrating each transformation steps. This very high level description is intended to help the reader to grasp the intuitive ideas behind the formal definitions and more technical explanations provided in the next section. The transformation is divided into several steps.\n\u2022 The first step is the elimination of iterations occurring inside an iteration. Consider for instance the following schema \u03d5 : \u2228n i=1(pi \u21d2 \u2227n j=1 qj). The reader can check\nthat \u03d5 is bound-linear but non regular. It is easy to transform \u03d5 into a sat-equivalent regular schema: since \u2227n j=1 qj does not depend on the counter i, one can simply replace\nthis formula by a new propositional variable r and add the equivalence r \u21d4 \u2227n\nj=1 qj outside the iteration. This yields the schema: \u2228n i=1(pi \u21d2 r) \u2227 (r \u21d4 \u2227n j=1 qj), which is clearly regular and sat-equivalent (but not equivalent) to \u03d5. This process can be generalized; however, replacing an iteration by a proposition is only possible if the iteration contains no variable that is bound in the original schema. Consider the schema: \u03d5\u2032 : \u2228n i=1 \u2227n j=1(pi \u21d2 qj). Here \u2227n j=1(pi \u21d2 qj) cannot be replaced by a variable r, since it depends on i. The solution is to get the variable pi containing i\nout of the iteration \u2227n\nj=1(pi \u21d2 qj): as pi does not involve j, it is easily seen that we can turn \u2227n j=1(pi \u21d2 qj) into pi \u21d2 \u2227n j=1 qj . This transformation can be generalized by using case-splitting: indeed, it is well-known that every formula \u03c8 is equivalent to (r \u2227 \u03c8[\u22a4/r]) \u2228 (\u00acr \u2227 \u03c8[\u22a5/r]), for every propositional variable r. Applying this decomposition scheme to \u2227n j=1(pi \u21d2 qj) and pi we get: \u2227n j=1(pi \u21d2 qj) \u2261 (pi \u2227\u2227n\nj=1(\u22a4 \u21d2 qj)) \u2228 (\u00acpi \u2227 \u2227n j=1(\u22a5 \u21d2 qj)), i.e. (by usual transformations): \u2227n\nj=1(pi \u21d2 qj) \u2261 (pi\u2227 \u2227n j=1 qj)\u2228\u00acpi. Afterwards, the remaining iteration \u2227n j=1 qj can be replaced by a new variable r.\nThe decomposition scheme just explained can be applied on every variable occurring in an iteration, but not containing the counter of this iteration. By definition of bound-linear schemata, the propositional symbols have only one index and this index contains at most one bound variable, thus this technique actually removes every atom containing a counter variable distinct from the one of the considered iteration. However, it does not remove the variables that occur in the bound of the iteration. Consider for instance the following formula: \u03d5\u2032\u2032 def = \u2228n i=1 \u2227i j=1 qj . Here i occurs in the bound of the iteration and thus cannot be removed by the previous technique. The idea is then to encode the formula \u2227i j=1 qj by a new variable ri, that can be defined inductively as follows: r0 is \u22a4 and ri+1 is ri \u2227 qi+1. This is expressed by the schema: r0 \u2227 \u2227n\u22121 i=0 (ri+1 \u21d4 (ri \u2227 qi+1)).\nNotice that ri needs only to be defined for i = 0, . . . , n because i ranges over the interval [1, n] in \u03d5\u2032\u2032.\n\u2022 In order to get a regular schema one has to guarantee that every iteration ranges over the same interval of the form [\u03b1, n \u2212 \u03b2] (where \u03b2 \u2208 Z). This is actually simple to ensure by unfolding and shifting the iterations. For instance a schema \u22282n i=1 pi can\nbe transformed into \u2228n i=1 pi \u2228 \u22282n i=n+1 pi and then into \u2228n i=1 pi \u2228 \u2228n\ni=1 pi+n. Similarly\u2228n i=2 pi\u2228 \u2228n\u22121 j=1 qj can be reduced to \u2228n\u22121 i=2 pi\u2228pn\u2228q1\u2228 \u2228n\u22121 j=2 qj to get iterations defined on the same interval.\n\u2022 A major difference between regular schemata and bound-linear ones is that, in a regular schema, the indexed variables occurring inside an iteration cannot contain parameters (e.g., an iteration such as \u2228n i=1 pi+n is forbidden). Therefore we have to\nreplace every variable of the form p\u03b1.n+\u03b2\u00b1i by a new variable qi, depending only on i. The problem is that in order to preserve sat-equivalence, one also has to encode the relation between these variables. For instance, assume that pn+i is replaced by qi and that p2n\u2212j is replaced by rj . Then obviously, we must have qi \u2261 rj if n+i = 2n\u2212j, i.e. qi \u2261 rn\u2212i. This step may be problematic because in general there are infinitely many such axioms. However, by defining the translation carefully, we will show that actually only finitely many equivalences are required. To this aim, we have to assume that the initial coefficient of the parameter is even in every index (see Definition 4.2), which is easy to ensure by case splitting. Then the maximal number of overlaps between the newly defined variable is actually bounded (this is shown by the crucial lemma 4.6).\nFor instance, a formula \u2228n i=0(\u00acpi \u2228 p2n\u2212i) is replaced by \u2228n\ni=0(\u00acpi \u2228 qi) \u2227 (pn \u21d4 qn). qi denotes the atom p2n\u2212i and the equivalence encodes the fact that qn \u2261 p2n\u2212n = pn.\nSince i ranges over the interval [0..n] this is the only equation which is relevant w.r.t. \u03d5 (e.g. p0 \u21d4 q2n is useless).\nThe algorithm for transforming every bound-linear schema \u03d5 into a sat-equivalent regular schema \u03c8 is specified as a sequence of rewriting rules, operating on schemata and preserving sat-equivalence. The rules are depicted in Figure 1. They must be applied in the order of their presentation. As we shall see in Section 4.3, the rewrite system terminates (in exponential time). Moreover satisfiability is preserved and irreducible schemata are regular (see Section 4.4)."}, {"heading": "4.2 Formal Definition of the Algorithm", "text": "We now give a more detailed and precise description of the transformation algorithm (readers not interested in technical details can skip this section). We assume that the initial schema satisfies the following condition:\nDefinition 4.2 A bound-linear schema is normalized if the coefficient of the parameter n is even in any expression occurring in the formula (either as the index of a symbol in P or as the bound of an iteration).\nConsidering exclusively normalized schemata is not restrictive because a schema \u03d5 not satisfying this property can be replaced by \u03d5[2n/n] \u2228 \u03d5[2n + 1/n] (e.g. p3n is turned into p6n \u2228 p6n+3). The obtained schema is obviously sat-equivalent to \u03d5 and normalized4. The use of normalized schemata will be explained later (see Remark 4.7).\nRemark 4.3 The property of being normalized is only useful for the algorithm of Figure 1 to be welldefined. But the schema obtained after application of this algorithm is actually not normalized in general.\nWe now explain in more details the different steps of the transformation."}, {"heading": "4.2.1 Elimination of Nested Iterations", "text": "As explained in Section 4.1, the first step is to remove the iterations \u03a0bi=a\u03d5 occurring inside another iteration \u0393dj=c\u03c8. This is done by the rules \u03c41, \u03c42, \u03c43, \u03c44. \u03c42 moves \u03a0 b i=a\u03d5 out by introducing a new variable p as explained before. This is possible only if \u03d5 does not contain any free variable except i and the parameter n. Removing all other variables is precisely the role of \u03c41:\n\u03c41 \u03a0 b i=a\u03d5 \u2192 (pc \u2227\u03a0bi=a\u03d5[\u22a4/pc]) \u2228 (\u00acpc \u2227\u03a0bi=a\u03d5[\u22a5/pc])\nIf the variables in c are free in \u03a0bi=a\u03d5, pc occurs in \u03d5 and if for every iteration \u0393dj=c\u03d5 \u2032 containing \u03a0bi=a\u03d5, pc contains either j or a variable bound in \u0393dj=c\u03d5 \u2032.\n4. But the two formulae are not equivalent in general. For instance, if \u03d5 = pn, then the interpretation\ndefined by I(n) def= 1 and I(p\u03ba) def = T iff \u03ba = 1 validates pn but obviously not p2n \u2228 p2n+1.\nThis rule aims at eliminating, in the body of an iteration \u03a0bi=a\u03d5, every variable distinct from the iteration counter i and from the (unique) parameter n. This is feasible because no index can contain two variables distinct from n (by definition of bound-linear schemata). This implies that the indexed variables containing an arithmetic variable distinct from i and n cannot contain i thus they can be taken out of the iteration \u03a0bi=a\u03d5 by case splitting. Notice that the rule \u03c41 can increase exponentially the size of the formula.\nOnce \u03d5 contains no free variable except n and i, \u03a0bi=a\u03d5 may be taken out of the global iteration \u0393dj=c\u03c8 by renaming. This is very easy if the bounds of the iteration only depend on n, because in this case \u03a0bi=a\u03d5 contains no free variable except n, thus it may be replaced by a fresh variable p and the equivalence p \u21d4 \u03a0bi=a\u03d5 may be added as an axiom. This is done by the rule \u03c42:\n\u03c42 \u03c8 \u2192 (p \u21d4 \u03a0bi=a\u03d5) \u2227 \u03c8[p/\u03a0bi=a\u03d5] If p is a fresh symbol, \u03c8 is the global schema, \u03a0bi=a\u03d5 occurs in an iteration in \u03c8 and contains no free variable except n.\nThings get more complicated if the bounds of the iteration contain a bound variable j (e.g., the schema \u2228n j=1(qi \u21d2 \u2228j i=1 ri)) because in this case the iteration cannot be taken out and j cannot be eliminated by \u03c41. Notice that, in this case, the lower bound a cannot contain j and the coefficient of j in the upper bound b must be \u00b11. In this case, \u03a0bi=a\u03d5 can be replaced by a new variable pj that can be defined inductively. For instance in the previous\nexample, \u2228j i=1 ri is replaced by a variable pj defined as follows: \u00acp0\u2227 \u2227n\nj=1[pj \u21d4 (rj\u2228pj\u22121)]. The transformation is formally specified by the rules \u03c43 (if the coefficient of j is 1) and \u03c44 (if the coefficient of j is \u22121). Notice that if \u03c8 denotes the global schema, then pj must be defined for every j \u2208 [min\u03c8(j),max\u03c8(j)].\n\u03c43 \u03d5 \u2192 \u2227a\u2212b\u22121\nj=min\u03d5(j) \u00acpj \u2227 \u2227max\u03d5(j) j=a\u2212b (pj \u21d4 (pj\u22121 \u2228 \u03c8[b+ j/i])) \u2227 (\u03d5[pj/ \u2228b+j i=a \u03c8])\nIf p is a fresh symbol, \u2228b+j\ni=a \u03c8 occurs in an iteration of \u03d5, j is bound in \u03d5, a, b and \u03c8 contain no free variable except n, \u03d5 is the global schema.\n\u03c44 \u03d5 \u2192 \u2227max\u03d5(j)\nj=b\u2212a+1 \u00acpj \u2227 \u2227b\u2212a j=min\u03d5(j) (pj \u21d4 (pj+1 \u2228 \u03c8[b\u2212 j/i])) \u2227 (\u03d5[pj/ \u2228b\u2212j i=a \u03c8])\nIf p is a fresh symbol, \u2228b\u2212j\ni=a \u03c8 occurs in an iteration of \u03d5, j is bound in \u03d5, a, b and \u03c8 contain no free variable except n, \u03d5 is the global schema.\nThe rules \u03c4 \u20323 and \u03c4 \u2032 4 for\n\u2227 are defined in a similar way (see Figure 1)."}, {"heading": "4.2.2 Transforming every Iteration into Iterations over Intervals of the", "text": "Form [\u03b1, n\u2212 \u03b2]\nThe next step is to ensure that for every iteration \u03a0bi=a\u03d5, a is an integer \u03b1 and that b is of the form n\u2212 \u03b2, where \u03b2 is a constant (initially both a and b must be of the form 2.\u03b4.n+ \u03b3 (since the initial schema is normalized and no iteration is contained inside another one so no bound variable occurs in the upper bound). The first point is easily performed by an\nappropriate translation of the iteration counter (rule \u03c45):\n\u03c45 \u03a0 \u03b3.n\u2212\u03b4 i=\u03b1.n+\u03b2\u03d5 \u2192 \u03a0 (\u03b3\u2212\u03b1).n\u2212\u03b4 i=\u03b2 \u03d5[i+ \u03b1.n/i]\nIf \u03b1 \u0338= 0, \u03b2 \u2208 Z.\nThen we ensure that the coefficient of n in b is positive. Fortunately, if this coefficient is negative then there is \u03ba \u2208 N s.t. for every interpretation I s.t. I(n) > \u03ba, the interval [I(a), I(b)] is empty, in which case \u03a0bi=a\u03d5 is either \u22a4 or \u22a5 (depending on \u03a0). Since the value of n is positive, there exist finitely many values for n s.t. the iteration is non empty. One can eliminate the iteration by considering these cases separately. This is done by the rule \u03c46:\n\u03c46 \u03c8 \u2192 [\u03c8]n 7\u21920 \u2228 . . . \u2228 [\u03c8]n7\u2192\u03ba \u2228 (n > \u03ba \u2227 \u03c8[\u22c4/\u03a0\u03b1.n\u2212\u03b2i=\u03b3 \u03d5]) If \u03c8 contains \u03a0\u03b1.n\u2212\u03b2i=\u03b3 \u03d5, with \u03b1, \u03b2, \u03b3 \u2208 Z, \u03b1 < 0 and \u03a0 \u2208 { \u2227 , \u2228 },\nwhere \u03ba = \u2308\u03b3\u2212\u03b2\u03b1 \u2309 and \u03a0 is \u2228 then \u22c4 = \u22a5 and if \u03a0 = \u2227 then \u22c4 = \u22a4.\nFinally, we obtain the desired result by (recursively) decomposing an iteration interval of the form [\u03b3, \u03b1.n + \u03b2] (where \u03b1 > 1) into two smaller intervals [\u03b3, (\u03b1 \u2212 1).n + \u03b2] and [(\u03b1\u2212 1).n+ \u03b2 + 1, \u03b1.n+ \u03b2]. Obviously, this is possible only if (\u03b1\u2212 1).n+ \u03b2 \u2265 \u03b3, thus the case where (\u03b1\u2212 1).n+ \u03b2 < \u03b3 must be considered separately. This is easy to achieve, since in this case there are only finitely many possible values of n, namely 0, 1, . . . , \u230a\u03b3\u2212\u03b2\u03b1\u22121\u230b.\n\u03c47 \u03c8 \u2192 ((\u03b1\u2212 1).n\u2212 \u03b2 \u2265 \u03b3 \u2227 \u03c8[\u03c8\u2032/\u03a0\u03b1.n\u2212\u03b2i=\u03b3 \u03d5]) \u2228 ([\u03c8]n 7\u21920 \u2228 . . . \u2228 [\u03c8]n7\u2192\u03ba) where \u03c8 contains an iteration \u03a0\u03b1.n\u2212\u03b2i=\u03b3 \u03d5 with \u03b1 > 1,\n\u03c8\u2032 is \u03a0 (\u03b1\u22121).n\u2212\u03b2 i=\u03b3 \u03d5 \u22c6\u03a0 n i=1\u03d5[i+ (\u03b1\u2212 1).n\u2212 \u03b2/i], with \u03a0 \u2208 {\n\u2227 , \u2228 },\nwhere \u03ba = \u230a\u03b3\u2212\u03b2\u03b1\u22121\u230b, \u03a0 = \u2227 then \u22c6 = \u2227, if \u03a0 = \u2228 then \u22c6 = \u2228."}, {"heading": "4.2.3 Removing the Parameter from the Indices in the Iterations", "text": "The next phase consists in removing the indexed variables of the form p\u03b1.n+\u03f5.i+\u03b2 where \u03b2 \u2208 Z and either \u03b1 \u0338= 0 or \u03f5 = \u22121 (to get variables indexed by expressions of the form i + \u03b2 only). We first ensure that \u03b1 is even. Although initially the coefficient of every occurrence of n is even, this property does not hold anymore at this point because of the rule \u03c47. Suppose a variable p(2\u03b3+1).n+c, where c does not contain n, occurs in an iteration \u03a0bi=a\u03d5. Then (since the schema is normalized) this variable must have been introduced by the rule \u03c47 and i has been shifted by (\u03b1 \u2212 \u03ba).n for some \u03ba (by definition of \u03c47). This shift is applied to every index containing i (by definition of \u03c47), i.e. to every index of a variable occurring in \u03a0bi=a\u03d5 (otherwise the iteration would be reducible by \u03c41). As a consequence every index in this iteration has an odd coefficient for n. Hence if we add n to each index we retrieve even coefficients in all the iteration. Fortunately by commutativity of \u2228 and \u2227, any iteration \u03a0bi=a\u03d5 is equivalent to \u03a0 b\u2212a i=0\u03d5[b \u2212 i/i]. In our case b is of the form n \u2212 \u03b2 for some \u03b2 \u2208 Z so applying this transformation precisely adds n to each index (and substracts a \u03b2). For instance, the iteration \u2228n i=1(pn+i \u2228 pn\u2212i) can be replaced by \u2228n\u22121 i=0 (p2n\u2212i \u2228 pi). This idea is formalized by the rule \u03c48:\n\u03c48 \u03a0 n\u2212\u03b2 i=\u03b3 \u03d5 \u2192 \u03a0 n\u2212\u03b3 i=\u03b2 \u03d5[n\u2212 i/i]\nIf the indices of the variables in \u03d5 are of the form (2\u03b1+ 1).n+ c, where c \u2208 Ni.\nOnce the coefficient of n in every indexed variable is even, we introduce, for every variable p and for every integer \u03ba, two new (fresh) variables p\u03ba + and p\u03ba \u2212 s.t. p\u03ba + a and p \u03ba\u2212 a denote respectively p2.\u03ba.n+a and p2.\u03ba.n\u2212a where a \u2208 Ni \u222a Z i.e. a is of the form \u03b2.i + \u03b3 where \u03b2 \u2208 {0, 1}, \u03b3 \u2208 Z (rule \u03c49). Then the index of p\u03ba +\na does not contain n anymore. Furthermore, the index of p\u03ba \u2212 a now contains +i instead of \u2212i. Thus this transformation indeed achieves our goal however it does not preserve sat-equivalence because two variables p2\u03b1.n+a and p2\u03b2.n\u2212b (respectively p2\u03b1.n+a and p2\u03b2.n+b, p2\u03b1.n\u2212a and p2\u03b2.n\u2212b) s.t. 2\u03b1.n + a = 2\u03b2.n \u2212 b (respectively 2\u03b1.n + a = 2\u03b2.n + b and 2\u03b1.n \u2212 a = 2\u03b2.n \u2212 b) may be replaced by distinct variables p\u03b1 + a and p \u03b2\u2212 b (respectively p \u03b1+ a and p \u03b2+ b , p \u03b1\u2212 a and p \u03b2\u2212\nb ). Notice that it is important to distinguish the sign + or \u2212 in front of a and b, as both are not integers but expressions of Ni \u222a Z. In order to preserve sat-equivalence one would have to explicitly add the following axioms to the schema:\n2\u03b1.n+ \u03b3 = 2\u03b2.n\u2212 \u03b4 \u21d2 (p\u03b1+\u03b3 \u21d4 p \u03b2\u2212 \u03b4 )\nand\n2\u03b1.n+ \u03b3 = 2\u03b2.n+ \u03b4 \u21d2 (p\u03b1+\u03b3 \u21d4 p \u03b2+ \u03b4 )\nand\n2\u03b1.n\u2212 \u03b3 = 2\u03b2.n\u2212 \u03b4 \u21d2 (p\u03b1\u2212\u03b3 \u21d4 p \u03b2\u2212 \u03b4 )\nfor every tuple (\u03b1, \u03b2, \u03b3, \u03b4) \u2208 Z4. This transformation is problematic, because there exist infinitely many such formulae. Fortunately, we do not have to add all these equivalences, but only those concerning propositional variables that occur in a propositional realization of the schema. As we shall see, this set (denoted by \u03a8(\u03d5)) is finite, because each expression \u03b3, \u03b4 ranges over a set of the form [\u2212\u03b9, \u03b9] \u222a [n\u2212 \u03b9, n+ \u03b9], where \u03b9 \u2208 N.\nMore formally, let V + and V \u2212 be two disjoint subsets of P, distinct from the symbols already occurring in the considered formula. We assume that every pair (p, \u03b1) where p is a variable occurring in the formula and \u03b1 an integer is mapped to two variables p\u03b1\n+ \u2208 V + and p\u03b1\n\u2212 \u2208 V \u2212. p\u03b1+i and p\u03b1 \u2212\ni will denote the atoms p2\u03b1.n+i and p2\u03b1.n\u2212i respectively. We denote by \u03d5 the schema obtained from \u03d5 by replacing every variable of the form p2\u03b1.n+a (where a \u2208 Ni \u222aN for some bound variable i) by p\u03b1 +\na and each variable of the form p2\u03b1.n\u2212a by p\u03b1 \u2212 a (in both cases we may have \u03b1 = 0, moreover, if a = 0 then the replacement may be done arbitrarily by p\u03b1 +\n0 or p \u03b1\u2212 0 ). Notice that all atoms in \u03d5 are of the form p \u03b1+ a or p \u03b1\u2212 a ,\nwhere a \u2208 Ni \u222a N for some bound variable i. \u03c49 is defined as follows:\n\u03c49 \u03d5 \u2192 \u03d5 \u2227 \u2227 \u03c8\u2208\u03a8(\u03d5) \u03c8\nIf \u03d5 contains a variable p not occurring in V \u2212 \u222a V +, and where \u03a8(\u03d5) is defined by Definitions 4.4, 4.5 and Lemma 4.6."}, {"heading": "4.2.4 Aligning Iterations", "text": "Finally, it remains to ensure that all the iterations have the same bounds. At this point every iteration is of the form \u03a0n\u2212\u03b2i=\u03b1 \u03d5 where \u03b1, \u03b2 \u2208 Z. Let \u03b1\u2032, \u03b2\u2032 be the greatest integers \u03b1, \u03b2. If we have \u03b1 \u0338= \u03b1\u2032 or \u03b2 \u0338= \u03b2\u2032, then we unfold the iteration once, yielding \u03a0n\u2212\u03b2\u22121i=\u03b1 \u03d5\u22c6\u03d5[n\u2212\u03b2/i]. By translation of the iteration counter, \u03a0n\u2212\u03b2\u22121i=\u03b1 is equivalent to \u03a0 n\u2212\u03b2\u22121+\u03b1\u2032\u2212\u03b1 i=\u03b1\u2032 \u03d5[i\u2212\u03b1\n\u2032+\u03b1/i]. The lower bound of the obtained iteration is now identical to \u03b1\u2032 and its length has been\ndecreased. This is repeated until we obtain an iteration on the interval [\u03b1\u2032, \u03b2\u2032]. The rule \u03c410 formalizes this transformation:\n\u03c410 \u03a0 n\u2212\u03b2 i=\u03b1 \u03d5 \u2192 (n < \u03b1+ \u03b2 \u2227 \u22c4) \u2228\n(n \u2265 \u03b1+ \u03b2 \u2227\u03a0n\u2212\u03b2\u22121+\u03b1 \u2032\u2212\u03b1\ni=\u03b1\u2032 \u03d5[i\u2212 \u03b1 \u2032 + \u03b1/i] \u22c6 \u03d5[n\u2212 \u03b2/i])\nwhere \u03b1\u2032 is the maximal lower bound of an iteration occurring in the whole formula and \u03b2\u2032 is the minimal upper bound, \u03b1 \u0338= \u03b1\u2032 or \u03b2 \u0338= \u03b2\u2032, and if \u03a0 is \u2228 then \u22c4 = \u22a5, \u22c6 = \u2228 and if \u03a0 = \u2227 then \u22c4 = \u22a4, \u22c6 = \u2227."}, {"heading": "4.2.5 Definition of \u03a8(\u03d5)", "text": "The most difficult part of the transformation is the removal of the variable n in the index performed by the rule \u03c49, and more precisely the definition of \u03a8(\u03d5). We now establish the results ensuring the feasability of this transformation.\nDefinition 4.4 We denote by \u03a8 the set of schemata of the form:\n2\u03b1.n+ a = 2\u03b2.n\u2212 b \u21d2 (p\u03b1+a \u21d4 p \u03b2\u2212 b )\nor\n2\u03b1.n+ a = 2\u03b2.n+ b \u21d2 (p\u03b1+a \u21d4 p \u03b2+ b )\nor\n2\u03b1.n\u2212 a = 2\u03b2.n\u2212 b \u21d2 (p\u03b1\u2212a \u21d4 p \u03b2\u2212 b )\nwhere \u03b1, \u03b2 \u2208 Z, a, b \u2208 Nn \u222a Z.\nThe set \u03a8 is infinite. Thus we add a further restriction:\nDefinition 4.5 Let \u03d5 be a schema containing a unique parameter n. A schema \u03c8 \u21d2 (p \u21d4 q) occurring in \u03a8 is said to be relevant w.r.t. \u03d5 iff the following conditions hold:\n\u2022 p and q are not syntactically identical.\n\u2022 There exists a natural number \u03ba s.t. \u03c8[\u03ba/n] is true and \u03d5[\u03ba/n] contains both p[\u03ba/n] and q[\u03ba/n]\nNotice that p and q do not necessarily occur in \u03d5 itself. For instance, take \u03d5 =\u2227n i=1(p2n\u2212i \u2228 \u00acpi). So \u03d5 = \u2227n i=1(p 2\u2212 i \u2228 \u00acp0 + i ). Then 2n \u2212 n = 4 \u21d2 (p2 \u2212 n \u21d4 p0 + 4 ) is easily seen to be relevant, however both p2 \u2212\nn and p 0+ 4 do not occur in \u03d5.\nThe next lemma provides a very simple necessary condition on relevant equivalences in \u03a8. It also shows that for every schema \u03d5 the number of relevant equivalences in \u03a8 is finite (up to equivalence).\nLemma 4.6 Let \u03d5 be a schema containing a unique parameter n. Assume that the coefficient of n is even in every index in \u03d5 and that every iteration in \u03d5 is of the form \u03a0n+\u03b6i=\u03f5 \u03c8, where \u03f5, \u03b6 \u2208 Z\n(\u03f5, \u03b6 may depend on the iteration). Let \u03b9 be the greatest natural number occurring in \u03d5 (possibly as a coefficient of n or in an expression of the form \u2212\u03b9).\nFor every relevant formula of the form 2\u03b1.n+ a = 2\u03b2.n\u2212 b \u21d2 (p\u03b1+a \u21d4 p \u03b2\u2212 b ), 2\u03b1.n+ a =\n2\u03b2.n + b \u21d2 (p\u03b1+a \u21d4 p \u03b2+ b ) or 2\u03b1.n \u2212 a = 2\u03b2.n \u2212 b \u21d2 (p \u03b1\u2212 a \u21d4 p \u03b2\u2212\nb ) in \u03a8, we have, for every \u03ba \u2208 N: \u03b1, \u03b2 \u2208 [\u2212\u03b9, \u03b9] and a[\u03ba/n], b[\u03ba/n] \u2208 [\u22122\u03b9, 6\u03b9] \u222a [\u03ba\u2212 2\u03b9, \u03ba+ 2\u03b9]."}, {"heading": "Proof", "text": "Let \u03c3 stand for the substitution [\u03ba/n]. By definition of a relevant formula, there must exist \u03ba \u2208 N such that p\u03b1+a \u03c3 and p \u03b2\u2212 b \u03c3 (respectively p \u03b2+ b \u03c3) occur in [\u03d5]\u03c3 (but notice that p \u03b1+ a , p \u03b2\u2212 b and p\u03b2 +\nb do not necessarily occur in \u03d5). Furthermore we must have 2\u03b1.\u03ba+ a\u03c3 = 2\u03b2.\u03ba\u2212 b\u03c3 (resp. 2\u03b1.\u03ba+ a\u03c3 = 2\u03b2.\u03ba+ b\u03c3).\nSince the coefficient of n is even in every index in \u03d5 and since a, b \u2208 Nn \u222a Z, 2\u03b1, 2\u03b2 necessarily occur in \u03d5. Thus \u03b1, \u03b2 \u2208 [\u2212\u03b9/2, \u03b9/2] \u2286 [\u2212\u03b9, \u03b9].\nMoreover, by Lemma 2.8, there exist two atoms p\u03b1 + a\u2032 and p \u03b2\u2212 b\u2032 (respectively p \u03b2+ b\u2032 ) which\noccur in \u03d5 and two \u03d5-expansions \u03c3\u2032 and \u03c3\u2032\u2032 of \u03c3 for p\u03b1 + a\u2032 and p \u03b2\u2212 b\u2032 (respectively p \u03b2+\nb\u2032 ) s.t. we have a\u03c3 = a\u2032\u03c3\u2032 and b\u03c3 = b\u2032\u03c3\u2032\u2032. By definition, a\u2032, b\u2032 come from the replacement of some proposition p2\u03b1.n+a\u2032 (resp. p2\u03b2.n\u2212b\u2032 and p2\u03b2.n+b\u2032) by p k+ a\u2032 (resp. p k\u2212 b\u2032 and p k+\nb\u2032 ). Thus a\u2032 and b\u2032 do not contain n. Thus a\u2032 and b\u2032 are either in Z (and in this case we must have a\u03c3, b\u03c3 \u2208 [\u2212\u03b9, \u03b9] \u2286 [\u22122\u03b9, \u03ba + 2\u03b9]) or respectively of the form i + \u03b3 and i + \u03b4 where i is a bound variable and \u03b3, \u03b4 \u2208 Z. Then since \u03c3\u2032, \u03c3\u2032\u2032 are \u03d5-expansions of \u03c3 we have i\u03c3\u2032, i\u03c3\u2032\u2032 \u2208 [min\u03d5(i)\u03c3,max\u03d5(i)\u03c3]. We have min\u03d5(i) = \u03f5 \u2265 \u2212\u03b9 and max\u03d5(i) = n + \u03b6 \u2264 n + \u03b9. Thus a\u03c3, b\u03c3 \u2208 [\u22122\u03b9, \u03ba+ 2\u03b9].\nAssume that we have 2\u03b1.\u03ba+ a\u03c3 = 2\u03b2.\u03ba\u2212 b\u03c3. Then a\u03c3 + b\u03c3 = 2.(\u03b2 \u2212 \u03b1).\u03ba.\n\u2022 If \u03b2 \u2264 \u03b1 then a\u03c3 + b\u03c3 \u2264 0. Since a\u03c3, b\u03c3 \u2265 \u22122\u03b9, we deduce a\u03c3, b\u03c3 \u2264 2\u03b9. Thus a\u03c3, b\u03c3 \u2208 [\u22122\u03b9, 6\u03b9].\n\u2022 If \u03b2 > \u03b1 then a\u03c3 + b\u03c3 \u2265 2\u03ba. Since a\u03c3 \u2264 \u03ba + 2\u03b9 and b\u03c3 \u2264 \u03ba + 2\u03b9 we must have a\u03c3 \u2265 \u03ba\u2212 2\u03b9 and b\u03c3 \u2265 \u03ba\u2212 2\u03b9. Thus a\u03c3, b\u03c3 \u2208 [\u03ba\u2212 2\u03b9, \u03ba+ 2\u03b9].\nNow, assume that 2\u03b1.\u03ba+ a\u03c3 = 2\u03b2.\u03ba+ b\u03c3. Then a\u03c3 \u2212 b\u03c3 = 2.(\u03b2 \u2212 \u03b1).\u03ba.\n\u2022 If \u03b1 = \u03b2 then we must have a\u03c3 = b\u03c3. This contradicts the first condition in Definition 4.5 (the indexed variables cannot be syntactically identical).\n\u2022 If \u03b1 < \u03b2 then a\u03c3 \u2212 b\u03c3 > 2\u03ba. This is possible only if a\u03c3 > 2\u03ba + b\u03c3 > 2\u03ba \u2212 2\u03b9, hence \u03ba+2\u03b9 > 2\u03ba\u22122\u03b9, i.e. 4\u03b9 > \u03ba. Then since we must have a\u03c3, b\u03c3 \u2208 [\u22122\u03b9, \u03ba+2\u03b9] we deduce a\u03c3, b\u03c3 \u2208 [\u22122\u03b9, 6\u03b9].\n\u2022 The proof is symmetric if \u03b1 > \u03b2.\nFinally if 2\u03b1.\u03ba\u2212 a\u03c3 = 2\u03b2.\u03ba\u2212 b\u03c3 then a\u03c3 \u2212 b\u03c3 = 2.(\u03b1\u2212 \u03b2).\u03ba and the proof follows exactly as in the previous case.\nLemma 4.6 implies that the set of relevant formulae is finite (up to equivalence). Indeed, it suffices to instantiate \u03b1, \u03b2 by every integer in [\u2212\u03b9, \u03b9] and a, b either by elements of [\u2212\u03b9, 6\u03b9]\nor by expressions of the form n + \u03b3, where \u03b3 is an integer in [\u22122\u03b9, 2\u03b9]. Thus we denote by \u03a8(\u03d5) a finite subset of \u03a8 containing all relevant formulae (up to equivalence). Such a set can be easily computed by applying Lemma 4.6, but using refined criteria is possible, thus we opt for a generic definition.\nRemark 4.7 The fact that the coefficient of n is even (see Definition 4.2 of normalized schemata) is essential at this point. If arbitrary coefficients are allowed for n, then the coefficients 2\u03b1 and 2\u03b2 must be replaced by \u03b1 and \u03b2 respectively. Then in the second item in the proof of Lemma 4.6 we obtain \u03b1\u03c3 + b\u03c3 \u2265 \u03ba (instead of a\u03c3 + b\u03c3 \u2265 2\u03ba). Thus we get eventually \u03b1\u03c3, b\u03c3 > \u22122\u03b9 (instead of a\u03c3 \u2265 \u03ba \u2212 2\u03b9). This means that a\u03c3, b\u03c3 range over the interval [\u22122\u03b9, \u03ba+ 2\u03b9] instead of [\u2212\u03b9, 6\u03b9] \u222a [\u03ba\u2212 2\u03b9, \u03ba+ 2\u03b9]. But this interval is unbounded, thus \u03a8(\u03d5) is infinite (even up to equivalence).\nFor instance, suppose that we allow any coefficient for n (i.e. odd or even) and that p\u03b1.n+\u03b2 is turned into p 1+ \u03b2 . Consider then \u03d5 = \u2228n i=1(pi\u2228pn\u2212i). We get: \u03d5 = \u2228n i=0(p 0+ i \u2228p1 \u2212 i ). But the equivalence p0 +\ni \u21d4 p1 \u2212\nn\u2212i is obviously needed for every i \u2208 [1, n], which cannot be expressed by a finite number of equivalences.\nOn the other hand, if we only allow normalized schemata, i.e. even coefficients for n, then we first have to turn \u03d5 into \u03c8 = \u22282n i=1(pi \u2228 p2n\u2212i) hence (by \u03c47) \u03c8 = \u2228n i=1(pi \u2228\np2n\u2212i) \u2228 \u2228n i=1(pn+i \u2228 pn\u2212i), and (by \u03c48) \u03c8 = \u2228n i=1(pi \u2228 p2n\u2212i) \u2228 \u2228n\u22121\ni=0 (p2n\u2212i \u2228 pi). Then \u03c8 = \u2228n i=1(p 0+ i \u2228 p1 \u2212 i ) \u2228 \u2228n\u22121 i=0 (p 1\u2212 i \u2228 p0 + i ). No equivalence is needed in this simple case.\nLemma 4.8 Let \u03d5 be a schema containing a unique parameter n s.t. every iteration in \u03d5 is of the form \u03a0n+\u03b2i=\u03b1 \u03c8, where \u03b1, \u03b2 \u2208 Z. \u03d5 is satisfiable iff \u03d5 \u222a\u03a8(\u03d5) is satisfiable."}, {"heading": "Proof", "text": "Let I be an interpretation satisfying \u03d5. Let \u03ba = I(n). We define an interpretation J as follows: J (n) def= \u03ba and for every pair of integers (\u03b1, \u03b2): J (p\u03b1+\u03b2 ) def = \u22a4 iff I(p2\u03b1.\u03ba+\u03b2) = \u22a4 and J (p\u03b1\u2212\u03b2 ) def = \u22a4 iff I(p2\u03b1.\u03ba\u2212\u03b2) = \u22a4. By definition for all \u03c8 \u2208 \u03a8, J |= \u03c8. \u03d5 is obtained from \u03d5 by replacing every atom of the form p2\u03b1.n+a (respectively p2\u03b1.n\u2212a) where a \u2208 Ni \u222aZ (for some bound variable i) by p\u03b1 + a (respectively p \u03b1\u2212 a ). By definition of J , J |= p\u03b1 + \u03b2 iff I |= p2\u03b1.n+\u03b2 and J |= p\u03b1 \u2212\n\u03b2 iff I |= p2\u03b1.n\u2212\u03b2. Since I |= \u03d5 it is clear that we have J |= \u03d5. Thus J |= \u03d5 \u222a\u03a8(\u03d5).\nConversely, let I |= \u03d5 \u222a \u03a8(\u03d5). Let \u03ba = I(n). Let J be the interpretation defined as follows. J (n) def= \u03ba, J (p2\u03b1.\u03ba+\u03b2) = I(p\u03b1 + \u03b2 ) if p \u03b1+ \u03b2 occurs in [\u03d5]I , and J (p2\u03b1.\u03ba\u2212\u03b2) = I(p\u03b1 \u2212 \u03b2 ) if p\u03b1 \u2212\n\u03b2 occurs in [\u03d5]I . It is easy to check that J is well-defined since I |= \u03a8(\u03d5) and \u03a8(\u03d5) contains all the necessary equivalences. By definition, p\u03b1 + a (respectively p \u03b1\u2212 a ) occurs in \u03d5 iff p2\u03b1.n+a (respectively p2\u03b1.n+a) occurs in \u03d5. Thus, since I |= \u03d5 we have J |= \u03d5."}, {"heading": "4.3 Termination and Complexity", "text": "In this section, we investigate the complexity of the transformation algorithm and show that it is exponential. For every schema \u03d5, we denote by |\u03d5| the size of \u03d5, i.e. the number of symbols occurring in \u03d5. \u03c4 denotes the system of rewrite rules of Figure 1.\nTheorem 4.9 Let \u03d5 be a normalized bound-linear schema. A normal form \u03c8 of \u03d5 w.r.t. \u03c4 can be computed in O(2|\u03d5|) rewriting steps. Moreover, |\u03c8| = O(2|\u03d5|)."}, {"heading": "Proof", "text": "We first notice that the rules are always applied sequentially: it is easy to check that a rule cannot introduce a formula on which a previous rule applies. Thus we consider each rule in sequence.\nFirst, we consider the rule \u03c41. We call \u03c41-atoms the atoms pc on which the rule possibly applies, i.e. the atom occurring in an iteration \u03a0bi=a\u03c8 but not containing the iteration counter i. This rule removes an atom occurring in an iteration but not containing the iteration counter. Due to the control (i.e. the application conditions of the rules), no atom satisfying this condition can be introduced into the formula (indeed, if the atom pc occurs in an iteration then, because of the second application condition of the rule, it must contain the corresponding iteration counter of this iteration). Therefore, the number of applications of this rule on an iteration is bounded by the number of \u03c41-atoms it contains. Since the rule duplicates the considered iteration the total number of applications of the rule is bounded by 2m, where m is the total number of \u03c41-atoms. Obviously m \u2264 |\u03d5|.\nThis is not sufficient to prove the second result, i.e. that the size of the formula is O(2|\u03d5|), since each application of the rule can double the size of the formula (which would yield a double exponential blow-up since there are 2m rule applications). Consider the set of leaf positions of the considered formula. For each position p in this set, we denote by |p| the length of p and by rp the number of possible applications of the rule \u03c41 along p. Each application of the rule \u03c41 removes some positions p from this set (those corresponding to the leaves of the subformula on which the rule is applied) and replaces them by new positions p\u20321, . . . , p \u2032 \u03ba. Both the number of these positions and their length possibly increase. However, we remark that the rule can only increase the length of these positions by 2 (by adding a disjunction of conjunctions), i.e. we have \u2200\u03b9 \u2208 [1, \u03ba], |p\u2032\u03b9| \u2264 |p|+2. Furthermore, the number rp necessarily decreases: \u2200\u03b9 \u2208 [1, \u03ba], rp\u2032\u03b9 < rp. Consequently, the value |p| + 2 \u00d7 rp cannot increase (i.e. we have \u2200\u03b9 \u2208 [1, \u03ba], |p\u2032\u03b9|+ 2\u00d7 rp\u2032\u03b9 \u2264 |p|+ 2\u00d7 rp), which implies that the length of the final positions (when rp\u2032\u03b9 = 0) are lower than |pmax| + 2 \u00d7 rmax, where rmax denotes the maximal number of possible applications of the rule \u03c41 along some position in the initial formula (i.e. the max of the rp in the initial formula) and pmax is the position of maximal length in the initial formula. Both |pmax| and rmax are O(|\u03d5|), thus the depth of the final formula is O(|\u03d5|), which implies that it size is O(2|\u03d5|).\nWe now consider the other rules. First we analyze the transformation due to a single application of each of those rules (then we will analyze the number of such applications). Since the proofs for the different cases are actual very similar, we do not consider each rule separately, but we rather factorize some part of the analysis.\n\u2022 Each application of the rule \u03c42 only increases the size of the formula by a constant number of symbols, since a fixed number of new connectives is added and no part of the formula is duplicated.\n\u2022 The application of the rules \u03c43, \u03c4 \u20323, \u03c44, \u03c4 \u20324, \u03c45, \u03c48 and \u03c410 adds a constant number of new connectives in the formula and replaces each occurrence of the counter i in the\nformula \u03d5 by an expression of the form b+ j, b\u2212 j, i+\u03b1.n or n\u2212 i. The size of these expressions is bounded by the size of the original formula, thus the size of the formula increases quadratically (since the number of occurrences of i is also bound by the size of the formula).\n\u2022 Now consider the rules \u03c46 and \u03c47. These rules introduce a constant number of new connectives and occurrences of atoms and duplicate \u03ba times a subformula \u03c8. The value of \u03ba is bounded by the natural number \u03b3 that occurs in \u03d5, thus the size of the formula increases polynomially (since natural numbers are encoded as unary terms s(. . . (s(0)) . . .) is our setting, hence \u03ba is bounded by the size of the formula \u2013 notice that this would not be the case if the numbers were encoded as sequences of digits5).\nThus we only have to show that the number of applications of each of these rules is polynomially bounded by the size of the initial formula. Once again, we distinguish several cases:\n\u2022 The rules \u03c42, \u03c43, \u03c4 \u20323, \u03c44, \u03c4 \u20324 only apply on iterations occurring inside another iteration. During the application of the rule, this iteration is replaced by an atom, hence removed from the outermost iteration. The rule introduces new iterations, however they only occur at the root level, outside the scope of any iteration. Thus the total number of possible applications of these rules is bounded by the number of iterations initially occurring inside another iteration, hence by |\u03d5|.\n\u2022 The rules \u03c45, \u03c46 and \u03c48 apply at most once on each iteration: \u03c45 applies on an iteration in which the lower bound contain n and gets rid of any occurrence of n in the lower bound. \u03c46 applies on iterations in which the upper bound contains \u2212n and replaces these iterations by purely propositional formulae. \u03c48 applies if the coefficient of n in every index is odd. Since the rule adds n to each index, after the application of the rule, the coefficient of n must be even and the rule cannot apply again on the same iteration.\n\u2022 The rule \u03c47 decreases the value of the coefficient \u03b1 of n in the upper bound by 1. Thus the number of applications of the rule \u03c47 on each iteration is lower than the initial value of \u03b1 (which is bound by the size of the formulae since integers are encoded as terms). Similarly, since \u03c410 unfolds an iteration until an iteration of length n\u2212\u03b2\u2032\u2212\u03b1\u2032 is obtained, the number of applications of the rule \u03c410 on each iteration is bound by the value of \u2212\u03b2 + \u03b1+ \u03b2\u2032 \u2212 \u03b1\u2032.\n\u2022 Finally, the rule \u03c49 applies only once on the whole schema. The rule adds a conjunction of equivalence to the schema, but by Lemma 4.6, the size of the conjunction is polynomially bounded by the greatest natural number \u03b9 occurring in the schema, hence by the size of the formula.\nFor every schema \u03d5, we denote by \u03d5 \u2193\u03c4 a normal form of \u03d5 w.r.t. the rules in \u03c4 .\n5. Actually the translation is doubly exponential in this case."}, {"heading": "4.4 Soundness and Completeness", "text": "We prove that the rules in \u03c4 preserve sat-equivalence and that every irreducible formula is regular. We need the two propositions below:\nLemma 4.10 Let \u03c8, \u03d5 and \u03d5\u2032 be schemata. Let I be an interpretation such that for every ground substitution \u03c3 of the parameters of \u03c8 and for every \u03c8-expansion \u03b8 of \u03c3 for \u03d5, \u03d5\u2032, we have:J\u03d5\u03b8KI = J\u03d5\u2032\u03b8KI . Then J\u03c8KI = J\u03c8[\u03d5\u2032/\u03d5]KI ."}, {"heading": "Proof", "text": "The proof is by induction on \u03c8. If \u03c8 does not contain \u03d5 the proof is trivial. If \u03c8 = \u03d5 then \u03c8[\u03d5\u2032/\u03d5] = \u03d5\u2032. By definition J\u03d5KI = J\u03d5\u03c3IKI and J\u03d5\u2032KI = J\u03d5\u2032\u03c3IKI . But \u03c3I is a ground substitution of the parameters of \u03c8 = \u03d5 and thus is of course a \u03c8-expansion of itself for \u03d5 and \u03d5\u2032. Thus J\u03d5\u03c3IKI = J\u03d5\u2032\u03c3IKI hence J\u03c8KI = J\u03c8\u2032KI .\nAssume that \u03c8 = \u00ac\u03c8\u2032. We have J\u03c8[\u03d5\u2032/\u03d5]KI = \u00acJ\u03c8\u2032[\u03d5\u2032/\u03d5]KI = \u00acJ\u03c8\u2032KI (by induction). Thus J\u03c8[\u03d5\u2032/\u03d5]KI = J\u03c8KI . The proof is similar if \u03c8 = (\u03c81 \u2228 \u03c82) or if \u03c8 = (\u03c81 \u2227 \u03c82).\nNow assume that \u03c8 = \u2227b i=a \u03c8 \u2032. I |= \u03c8 iff for every integer \u03ba \u2208 [JaKI , JbKI ] we have I[\u03ba/i] |= \u03c8\u2032. Let \u03c3\u2032 be the substitution such that \u03c3\u2032(i) = \u03ba and \u03c3\u2032(x) def= \u03c3(x) if x \u0338= i. Let \u03b8 be a \u03c8-expansion of \u03c3\u2032 for \u03c8\u2032. By definition \u03ba \u2208 [Jmin\u03c8(i)KI , Jmax\u03c8(i)KI ], thus \u03b8 is also a \u03c8-expansion of \u03c3. Therefore we have J\u03d5\u03b8KI = J\u03d5\u2032\u03b8KI , hence J\u03d5\u03b8KI[\u03ba/i] = J\u03d5\u2032\u03b8KI[\u03ba/i] (since \u03d5\u03b8 and \u03d5\u2032\u03b8 do not contain i). Consequently, by the induction hypothesis, we haveJ\u03c8\u2032KI[\u03ba/i] = J\u03c8\u2032[\u03d5\u2032/\u03d5]KI[\u03ba/i]. Hence I |= \u03c8 iff for every integer \u03ba \u2208 [JaKI , JbKI ] we have I[\u03ba/i] |= \u03c8\u2032[\u03d5\u2032/\u03d5] i.e. iff I |= \u03c8[\u03d5\u2032/\u03d5]. The proof is similar if \u03c8 = \u2228b i=a \u03c8 \u2032.\nLemma 4.11 For every schema \u03d5 and for every indexed proposition p that does not contain any variable bound in \u03d5:\n\u03d5 \u2261 (p \u2227 \u03d5[\u22a4/p]) \u2228 (\u00acp \u2227 \u03d5[\u22a5/p])"}, {"heading": "Proof", "text": "We have p \u2228 \u00acp \u2261 \u22a4 hence by distributivity \u03d5 \u2261 (p \u2227 \u03d5) \u2228 (\u00acp \u2227 \u03d5). We now show that for every interpretation I, Jp\u2227\u03d5KI = Jp\u2227\u03d5[\u22a4/p]KI . If JpKI = F then both p\u2227\u03d5 and p\u2227\u03d5[\u22a4/p] are false in I. Otherwise, by Lemma 4.10, we have J\u03d5KI = J\u03d5[\u22a4/p]KI . Similarly, we haveJ\u00acp \u2227 \u03d5KI = J\u00acp \u2227 \u03d5[\u22a5/p]KI . Hence \u03d5 \u2261 (p \u2227 \u03d5[\u22a4/p]) \u2228 (\u00acp \u2227 \u03d5[\u22a5/p]). Theorem 4.12 Let \u03d5 be a normalized bound-linear schema. \u03d5 is satisfiable iff \u03d5 \u2193\u03c4 is satisfiable."}, {"heading": "Proof", "text": "The proof is by inspection of the different rules (see the definition of the rules for the notations):\n\u2022 \u03c41. The proof is a direct application of Lemma 4.11.\n\u2022 \u03c42. For every model I of \u03c8, one can construct an interpretation J of (p \u21d4 \u03a0bi=a\u03d5) \u2227 \u03c8[p/\u03a0bi=a\u03d5] by interpreting p as J\u03a0bi=a\u03d5KI . By definition we have J |= (p \u21d4 \u03a0bi=a\u03d5).\nSince I |= \u03c8 we have J |= \u03c8. By Lemma 4.10 we deduce that I |= \u03c8[p/\u03a0bi=a\u03d5]. Hence J |= (p \u21d4 \u03a0bi=a\u03d5) \u2227 \u03c8[p/\u03a0bi=a\u03d5]. Conversely, if I is a model of (p \u21d4 \u03a0bi=a\u03d5)\u2227\u03c8[p/\u03a0bi=a\u03d5], then due to the first conjunct \u03a0bi=a\u03d5 and p have the same truth value in I hence since I |= \u03c8[p/\u03a0bi=a\u03d5], we deduce I |= \u03c8, by Lemma 4.10.\n\u2022 \u03c43. Assume that I |= \u03d5. Let J be the extension of I obtained by interpreting p\u03ba asJ\u2228b+\u03bai=a \u03c8KI . By Lemma 4.10 we have J |= (\u03d5[pj/\u2228b+ji=a \u03c8]). Furthermore by definition of the semantics, we have J\u2228b+\u03bai=a \u03c8KI = F if Jb+\u03ba\u2212aKI < 0 hence J |= \u00acp\u03ba if \u03ba < a\u2212b. Thus J |= \u00acpa\u2212b\u22121\u2227 \u2227a\u2212b\u22121 j=min\u03d5(j)\n(pj \u21d4 pa\u2212b\u22121). Furthermore, for every \u03b9 \u2265 Ja\u2212bKI , we have J\u2228b+\u03b9i=a \u03c8KI = T iff either J\u2228b+\u03b9\u22121i=a \u03c8KI = T or J\u03c8[b+\u03b9/j]KI = T. Hence Jp\u03b9KI = T iff either Jp\u03b9\u22121KI = T or J\u03c8[b+ \u03b9/j]KI = T. Therefore I |= \u2227max\u03d5(j)j=a\u2212b (pj \u21d4 (pj\u22121\u2228\u03c8)). Conversely, let I be a model of \u00acpa\u2212b\u22121 \u2227 \u2227a\u2212b\u22121 j=min\u03d5(j) (pj \u21d4 pa\u2212b\u22121) \u2227 \u2227max\u03d5(j)\nj=a\u2212b (pj \u21d4 (pj\u22121 \u2228 \u03c8[b + j/i])) \u2227 (\u03d5[pj/ \u2228b+j i=a \u03c8]). We show by induction on \u03b9 that I |= (p\u03b9 \u21d4\u2228b+\u03b9\ni=a \u03c8) for every \u03b9 \u2208 [Jmin\u03d5(j)KI , Jmax\u03d5(j)KI ]: \u2013 If \u03b9 < Ja \u2212 bKI then by definition J\u2228b+\u03b9i=a \u03c8KI = F. Moreover by the first two\nconjuncts in the previous formula we must have Jp\u03b9KI = F. \u2013 Otherwise, we have J\u2228b+\u03b9i=a \u03c8KI = J\u2228b+\u03b9\u22121i=a \u03c8\u2228\u03c8[b+\u03b9/i]KI . Hence by the induction\nhypothesis: J\u2228b+\u03b9i=a \u03c8KI = Jp\u03b9\u22121KI \u2228 \u03c8[b + \u03b9/i], and by the third conjunct in the formula above, we get: J\u2228b+\u03b9i=a \u03c8KI = Jp\u03b9KI .\nThen by Lemma 4.10 we deduce that I |= \u03c8. The proofs for the rules \u03c4 \u20323, \u03c44 and \u03c4 \u20324 are similar.\n\u2022 \u03c45. Assume that \u03a0 = \u2228 (the case \u03a0 = \u2227 is similar). By definition I |= \u2228\u03b3.n+\u03f5\ni=\u03b1.n+\u03b2 \u03d5 iff there exists \u03ba \u2208 [J\u03b1.n+ \u03b2KI , J\u03b3.n+ \u03f5KI ] such that I |= \u03d5[\u03ba/i], i.e. iff there exists \u03ba \u2208 [J\u03b2KI , J(\u03b3\u2212\u03b1).n+\u03f5KI ] such that I |= \u03d5[\u03ba+J\u03b1.nKI/i], i.e. iff I |= \u2228(\u03b3\u2212\u03b1).n+\u03f5i=\u03b2 \u03d5[i+\u03b1.n/i].\n\u2022 \u03c46. We assume that \u03a0 = \u2228 and \u22c4 = \u22a5 (the case \u03a0 = \u2227, \u22c4 = \u22a4 is similar). Since we assume that I(n) \u2265 0 for every parameter n, we have I |= (n = 0\u2228 . . .\u2228n = \u03ba\u2228n > \u03ba) hence \u03c8 is equivalent to: (n = 0 \u2228 . . . \u2228 n = \u03ba \u2228 n > \u03ba) \u2227 \u03c8. By distributivity we get \u03c8 \u2261 (n = 0\u2227\u03c8)\u2228 . . . (n = \u03ba\u2227\u03c8)\u2228(n > \u03ba\u2227\u03c8). But \u2228\u03b1.n+\u03b2 i=\u03b3 \u03d5 is empty (thus equivalent\nto \u22a5) if I(n) > \u03ba \u2265 \u03b3\u2212\u03b2\u03b1 , hence, by Lemma 4.10, we have \u03c8 \u2261 (n = 0 \u2227 \u03c8) \u2228 . . . (n = \u03ba \u2227 \u03c8) \u2228 (n > \u03ba \u2227 \u03c8[\u22a5/ \u2228\u03b1.n+\u03b2 i=\u03b3 \u03d5]). For every \u03b9 \u2208 [0, \u03ba], we have n = \u03b9 \u2227 \u03c8 |= [\u03c8]n 7\u2192\u03b9,\nhence \u03c8 |= [\u03c8]n 7\u21920 \u2228 . . . \u2228 [\u03c8]n7\u2192\u03ba \u2228 (n > \u03ba \u2227 \u03c8[\u22a5/ \u2228\u03b1.n+\u03b2 i=\u03b3 \u03d5]). Conversely, if I |= [\u03c8]n 7\u2192\u03b9 holds, then I can be straightforwardly extended into a model of n = \u03b9\u2227\u03c8 by interpreting n as \u03b9. Thus for any model of [\u03c8]n 7\u21920\u2228 . . .\u2228 [\u03c8]n 7\u2192\u03ba\u2228 (n > \u03ba \u2227 \u03c8[\u22a5/ \u2228\u03b1.n+\u03b2 i=\u03b3 \u03d5]) there exists a model of \u03c8, and \u03c46 preserves satisfiability.\n\u2022 \u03c47. Again, we assume that \u03a0 = \u2228\nand \u22c4 = \u22a5. We have ((\u03b1\u22121).n+\u03b2 < \u03b3\u2228(\u03b1\u22121).n+ \u03b2 \u2265 \u03b3) \u2261 \u22a4 hence \u03c8 \u2261 ((\u03b1\u22121).n+\u03b2 < \u03b3 \u2228 ((\u03b1\u22121).n+\u03b2 \u2265 \u03b3)\u2227\u03c8 \u2261 ((\u03b1\u22121).n+\u03b2 \u2265 \u03b3 \u2227 \u03c8) \u2228 ((\u03b1 \u2212 1).n + \u03b2 < \u03b3 \u2227 \u03c8). Since the parameters are interpreted as natural\nnumbers, we have I |= (\u03b1 \u2212 1).n + \u03b2 < \u03b3 iff I(n) \u2208 [0, \u2308\u03b3\u2212\u03b2\u03b1\u22121\u2309]. Then by definitionJ\u03c8KI = J[\u03c8]n 7\u2192I(n)KI . If I |= (\u03b1 \u2212 1).n + \u03b2 \u2265 \u03b3 then, by unfolding, J\u2228\u03b1.n+\u03b2i=\u03b3 \u03d5KI =J\u2228(\u03b1\u22121).n+\u03b2i=\u03b3 \u03d5 \u2228 \u2228\u03b1.n+\u03b2i=(\u03b1\u22121).n+\u03b2+1 \u03d5KI = J\u2228(\u03b1\u22121).n+\u03b2i=\u03b3 \u03d5 \u2228 \u2228ni=1 \u03d5[i + (\u03b1 \u2212 1).n + \u03b2/i]KI . Hence \u03c47 preserves satisfiability.\n\u2022 \u03c48: the proof is similar to the one of \u03c46.\n\u2022 The soundness of the rule \u03c49 is a direct consequence of Lemma 4.8. \u2022 \u03c410. We assume that \u03a0 = \u2228 and \u22c4 = \u22a5. We have \u2228n\u2212\u03b2 i=\u03b1 \u03d5 \u2261 (n < \u03b1+\u03b2\u2227 \u2228n\u2212\u03b2\ni=\u03b1 \u03d5)\u2228(n \u2265 \u03b1 + \u03b2 \u2227 \u2228n\u2212\u03b2 i=\u03b1 \u03d5). For every interpretation I, if I(n) < \u03b1 + \u03b2 then J\u2228n\u2212\u03b2i=\u03b1 \u03d5KI = F\nthus n < \u03b1 + \u03b2 \u2227 \u2228n\u2212\u03b2 i=\u03b1 \u03d5 \u2261 (n < \u03b1 + \u03b2 \u2227 \u22c4). If I(n) \u2265 \u03b1 + \u03b2, then J\u2228n\u2212\u03b2i=\u03b1 \u03d5KI \u2261J\u03d5[\u03b1/i] \u2228 \u2228n\u2212\u03b2i=\u03b1+1 \u03d5KI . Furthermore by translation of the iteration counter we have\u2228n\u2212\u03b2 i=\u03b1+1 \u03d5 \u2261 \u2228n\u2212\u03b2\u2032 i=\u03b1+1\u2212\u03b2\u2032+\u03b2 \u03d5[i+ \u03b2 \u2032 \u2212 \u03b2/i]. Hence \u03c410 preserves equivalence.\nTheorem 4.13 Let \u03d5 be a normalized bound-linear schema. \u03d5 \u2193\u03c4 is regular."}, {"heading": "Proof", "text": "Firstly, we remark that the application of the rules in \u03c4 on a bound-linear schema generates a schema that is still bound-linear. Notice however that the obtained schema is not normalized in general.\nLet \u03d5 be a bound-linear formula, irreducible by \u03c4 . Assume that \u03d5 has been obtained from a normalized schema by application of the rules in \u03c4 . We need to prove that \u03d5 is regular.\nWe first prove that \u03d5 contains no nested iteration. Let \u03c8 = \u03a0bi=a\u03c7 be an iteration occurring in \u03d5. Assume that \u03c7 contains an iteration \u0393dj=c\u03b3. W.l.o.g. we assume that \u03b3 contains no iteration (otherwise we could simply take \u03c8 = \u03c7). By irreducibility w.r.t. the rule \u03c41, all the indices in \u03b3 must contain j. By definition of the class of bound-linear schemata, this implies that these indices cannot contain i. If j occurs in d then one of the rule \u03c43,\u03c4 \u2032 3, \u03c44 or \u03c4 \u2032 4 applies. Consequently the only free variable in \u0393 d j=c\u03b3 is n. Thus the rule \u03c42 applies which is impossible by irreducibility.\nThen we remark that for all iterations \u03a0bi=a\u03c8 in \u03d5, a \u2208 Z and b is of the form n + \u03b1 where \u03b1 \u2208 Z. Indeed, if a contains n then the rule \u03c45 applies and if the coefficient of n in b is different from 1 then the rule \u03c46 or \u03c47 applies.\nThe rule \u03c48 eliminates all indexed propositions in which the coefficient of n is odd (since the initial schema is normalized, these indexed variables have been necessarily introduced by the rule \u03c47, thus they must occur in an iteration and all the indices in the iteration must have an odd coefficient in front of n).\n\u03c49 eliminates all the variables of the form p2\u03b1.n\u00b1a, where \u03b1 \u2208 Z and a \u2208 Ni\u222aN, for some bound variable i, and replaces them by variables indexed only by a.\nFinally \u03c410 ensures that all the iterations have the same bounds."}, {"heading": "5. STAB: A Decision Procedure for Regular Schemata", "text": "Now that we have shown how to transform a bound linear schema into a regular one, we show that the satisfiability problem is decidable for regular schemata. This is done by providing a set of block tableaux rules (Smullyan, 1968) that are complete w.r.t. satisfiability. Those rules are concise and natural, and, compared to the naive procedure described in the proof of Proposition 2.7, they are much more efficient and terminate more often (see the end of Section 5.1). The procedure is called stab (standing for schemata tableaux). Notice that it applies on any schema (not only on regular ones). We assume (w.l.o.g) that schemata are in negative normal form."}, {"heading": "5.1 Inference Rules", "text": "Definition 5.1 (Tableau) A tableau is a tree T s.t. each node N occurring in T is labeled by a set of schemata written \u03a6T (N).\nAs usual a tableau is generated from another tableau by applying some extension rules. Let r = P\nC1 . . . C\u03ba be a rule where P denotes a set of schemata (the premises), and\nC1, . . . , C\u03ba denote the conclusions. Let N be a leaf of a tree T . If a subset S of \u03a6T (N) matches P then we can extend the tableau by adding \u03ba children to N , each of them labeled with C\u03b9\u03c3 \u222a (\u03a6T (N) \\ S) where \u03b9 = 1, . . . , \u03ba and \u03c3 is the matching substitution. A leaf N is closed iff the set of arithmetic formulae (i.e. schemata containing only atoms of the form . . . < . . . and no iteration) in \u03a6T (N) is unsatisfiable. This can be detected using decision procedures for arithmetic without multiplication (Cooper, 1972).\nDefinition 5.2 (Extension rules) The extension rules of stab are defined as follows.\n\u2022 The usual rules of propositional tableaux:\n(\u2227): \u03d5 \u2227 \u03c8\n\u03d5 \u03c8 (\u2228):\n\u03d5 \u2228 \u03c8\n\u03d5 \u03c8\n\u2022 Rules proper to schemata (\u201citeration rules\u201d)6:\n(Iterated \u2227):\n\u2227b i=a \u03d5\nb \u2265 a\u2227b\u22121 i=a \u03d5 \u2227 \u03d5[b/i]\nb < a (Iterated \u2228):\n\u2228b i=a \u03d5\nb \u2265 a\u2228b\u22121 i=a \u03d5 \u2228 \u03d5[b/i]\n6. The right branch in the conclusion of the Iterated \u2227 rule is required, e.g., to detect that \u2227n\ni=1 \u22a5 is satisfiable with n = 0.\n\u2022 The closure rule adds the constraints needed for the branch not to be closed. The rule is applied only if a \u0338= b does not already occur in the branch.\n(Closure):\npa \u00acpb pa,\u00acpb, a \u0338= b\nstab without the loop detection rule described in the next section is already better than the straightforward procedure introduced in the proof of Proposition 2.7. First, it terminates in some cases where the schema is unsatisfiable (whereas the naive procedure never terminates in such a case, unless the schema is just an unsatisfiable propositional formula). This is trivially the case for any schema \u2227n i=1 \u03d5 with n \u2265 1, where \u03d5 is propositionally unsatisfiable. Second, it can find a model much faster than the naive procedure. Consider, e.g., ( \u222710000 i=n p)\u2227(\u00acp\u2228\u03d5) where \u03d5 is an unsatisfiable formula. In this case stab immediately finds a model where n > 10000 and p is interpreted as F.\nRemark 5.3 Using a tableaux-based system for deciding regular schemata may seem surprising, since DPLL procedures (Davis, Logemann, & Loveland, 1962) are usually more efficient in propositional logic. However, extending such procedures to schemata is not straightforward. The main problem is that evaluating an atom in a schema is not immediate, since this atom may well appear in some realization of the schema without appearing in the schema itself. Thus, in contrast to the propositional case, it is not sufficient to replace syntactically the atom by its truth value. For instance, the atom p2 (implicitly) appears in the schema \u2228n i=1 pi if\nn > 1. Thus evaluating p2 to, say, F would yield two distinct branches: ( \u2228n\ni=1 pi) \u2227 n \u2264 1 and (p1 \u2228 \u2228n i=3 pi)\u2227n > 1. Thus one would have to define rules operating at deep positions in the schema in order to unfold the iterations and instantiate the counter variables when needed. In contrast, the tableaux method operates only on formulae occurring at root level and compares literals only after they have been instantiated (using unfolding). This makes the procedure much easier to define and reason with (in particular the termination behavior is easier to control). Actually a DPLL procedure for schemata is presented in our previous work (Aravantinos, Caferra, & Peltier, 2009a, 2010), but it is much more complicated than the calculus presented here.\nOf course, one could combine the iteration rules of the tableaux procedure with a SATsolver used as a \u201cblack box\u201d that could be in charge of the purely propositional part. However this is also not straightforward, mainly due to the fact that a partial evaluation is needed to propagate the values of the propositional variables into the iterations."}, {"heading": "5.2 Discarding Infinite Derivations: the Looping Rule", "text": "stab does not terminate in general. The reason is that an iteration is, in general, infinitely unfolded by the iteration rules. Assume for instance that \u03d5 is a propositional unsatisfiable formula. Then starting from \u2228n i=1 \u03d5 one could derive an infinite sequence of formulae of the\nform \u2228n\u22121 i=1 \u03d5, . . . , \u2228n\u2212\u03ba\ni=1 \u03d5, for every \u03ba \u2208 N. We now introduce a loop detection rule that aims at improving the termination behavior of stab. Detecting looping is the most natural way to avoid this divergence: if, while extending the tableau, we find a schema that has already been seen, possibly up to a shift of arithmetic variables, then there is no need to\nconsider it again and we can stop the procedure. Such loopings can also be interpreted as well-foundedness arguments in an inductive proof.\nDefinition 5.4 (Looping) A shift is a substitution mapping every variable n to an expression of the form n\u2212 \u03b9, where \u03b9 \u2208 N s.t. there is at least one variable n s.t. n\u03c3 < n (which is not always the case since we may have \u03b9 = 0).\nIf I,J are two interpretations, we write I < J iff there exists a shift \u03c3 s.t. J = I\u03c3. Let \u03d5, \u03c8 be two schemata (or sets of schemata). We write \u03d5 |=s \u03c8 iff for every model I\nof \u03d5, there exists J < I s.t. J |= \u03c8. Let N,N \u2032 be two nodes of a tableau T . Then N \u2032 loops on N iff \u03a6T (N \u2032) |=s \u03a6T (N).\nIn existing work on cyclic proofs, N \u2032 is sometimes called a bud node and N is the companion node of N \u2032 (Brotherston, 2005). When a leaf loops, it is treated as a closed leaf (though it is not necessarily unsatisfiable). To distinguish this particular case of closed leaf from the usual one, we say that it is blocked (blocked leaves are closed). Notice that N and N \u2032 may be on different branches, thus looping may occur more often, allowing more simplifications.\nExample 5.5 Let \u03a6 = { \u2228n i=1 pi} and \u03a8 = { \u2228n i=2 qi}. Intuitively, \u03a6 and \u03a8 have the same \u201cstructure\u201d: stab will behave similarly on both formulae. The relation |=s is supposed to formalize this notion. We show on this example that it is the case, as expected, i.e. that we have \u03a8 |=s \u03a6. Indeed, consider a model I of \u03a8. We construct an interpretation J as follows: J (n) def= I(n) \u2212 1 and for every \u03ba \u2208 [1,J (n)], J (p\u03ba) def = I(q\u03ba+1). Since I |= \u03a8 there exists \u03ba \u2208 [2, I(n)] such that I(q\u03ba) = T. Thus there exists \u03ba \u2208 [1, I(n)\u22121] such that I(q\u03ba+1) = T, i.e. there exists \u03ba \u2208 [1,J (n)] such that J (p\u03ba) = T. Therefore J |= \u03a6.\nProposition 5.6 Let \u03d5 be a schema. If \u03d5 is satisfiable then \u03d5 has a model I that is minimal w.r.t. < (i.e. for every interpretation J , if J < I then J \u0338|= \u03d5)."}, {"heading": "Proof", "text": "Let V be the set of parameters of \u03d5. Notice that V is finite. For every interpretation I we denote by I(V ) the integer: I(V ) def= \u03a3n\u2208V I(n). Since we assumed that I(n) \u2208 N for every variable n, we deduce that I(V ) \u2265 0.\nLet I be a model of \u03d5 such that I(V ) is minimal. Since the truth value of \u03d5 does not depend on the values of the variables that are not in V , we may assume that \u2200n \u0338\u2208 V, I(n) = 0. Let J be a model of \u03d5 such that J < I. By definition there exists a shift \u03c3 such that J = I\u03c3. For every arithmetic variable n, we have n\u03c3 = n\u2212 \u03b9n, where \u03b9n \u2208 N; furthermore, there exists at least one variable m such that \u03b9m > 0. Thus J (n) = I(\u03c3(n)) \u2264 I(n) and J (m) < I(m). Consequently we must have J (V ) \u2264 I(V ), thus J (V ) = I(V ) (since I(V ) is minimal). By definition, this entails that \u03b9n = 0 for every n \u2208 V . Thus m \u0338\u2208 V , but in this case I(m) = 0 hence J (m) < 0 which is impossible (since we assume that parameters are interpreted by natural numbers).\nTo apply the looping rule in practice one has to find a shift and check that the implication holds. Unfortunately, the relation |=s is obviously undecidable (for instance if \u03c8 = \u22a5, then\nit can be easily checked that \u03d5 |=s \u03c8 iff \u03d5 is unsatisfiable, and as we shall see in Section 6 the satisfiability problem is undecidable for propositional schemata). Thus, in the following, we shall use a much stronger criterion that is sufficient for our purpose. An obvious solution would be to use set inclusion: indeed, \u03d5 |=s \u03c8 if there exists a shift \u03c3 s.t. \u03d5 \u2287 \u03c8\u03c3. However, this criterion is too strong, as the following example shows.\nExample 5.7 The schema \u03d5 = pn \u2227 (pn \u21d2 qn) \u2227 \u00acq0 \u2227 \u2227n i=1(qi \u21d2 qi\u22121) is obviously unsatisfiable. The reader can easily check that stab generates an infinite sequence of sets of schemata of the form:\n{pn, qn,\u00acq0, qn\u22121, . . . , qn\u2212\u03ba, n\u2212\u03ba\u2227 i=1 (qi \u21d2 qi\u22121)}, where \u03ba \u2208 N\nNone of these sets contains a previous one up to a shift on n because of the indexed proposition pn that must occur in every set.\nThus we introduce a refinement of set inclusion based on the purity principle. The pure literal rule is standard in propositional theorem proving. It consists in evaluating a literal L to \u22a4 in a formula \u03d5 (in NNF) if the complement of L does not occur in \u03d5. Such a literal is called pure. It is well-known that this operation preserves satisfiability and may allow many simplifications.\nWe show how to extend the pure literal rule to schemata. The conditions on L have to be strengthened in order to take iterations into account. For instance, if L = pn and \u03d5 contains \u22282n i=1 \u00acpi then L is not pure in \u03d5, since \u00acpi is the complement of L for i = n (and since 1 \u2264 n \u2264 2n). On the other hand p2n+1 may be pure in \u03d5 (since 2n+ 1 \u0338\u2208 [1, 2n]). For every set of schemata \u03a6 we denote by \u03a6N the conjunction of purely arithmetic formulae in \u03a6: \u03a6N def = \u2227 \u03d5\u2208\u03a6,\u03d5 is arithmetic \u03d5. 7\nDefinition 5.8 (Pure literal) A literal pa (respectively \u00acpa) is pure in a set of schemata \u03a6 iff for every occurrence of a literal \u00acpb (respectively pb) in \u03a6, the arithmetic formula \u03a6N \u2227IC (\u03a6)\u2227a = b is unsatisfiable8.\nDefinition 5.9 Let \u03a6,\u03a8 be two sets of schemata. We write \u03a6 \u2287s \u03a8 iff there exists a shift \u03c3 for the set of parameters in \u03a6 and \u03a8 s.t. for every \u03c8 \u2208 \u03a8:\n\u2022 Either \u03c8 is an arithmetic formula and \u03a6N |= \u03c8\u03c3.\n\u2022 Or \u03c8 is a pure literal in \u03a8.\n\u2022 Or \u03c8\u03c3 \u2208 \u03a6.\nThe first and third items correspond roughly to set inclusion (up to arithmetic properties). The second item only deals with \u03a8 and not with \u03a6. It corresponds to the informal idea that a pure literal can be removed. Of course it is the most important one.\n7. A possible improvement would be to add in \u03a6N formulae that are obvious logical consequences of \u03a6. For instance, if \u03a6 = {pn \u2227 (n > 1),\u00acp1} then \u03a6N would contain n > 1. This would make the notion of \u2018pure literal\u2019 slightly more general, e.g., pn would be pure in \u03a6, which is not the case with our current definition. 8. See page 606 for the definition of IC (\u03a6).\nExample 5.10 Let \u03a8 = {n \u2265 0, pn+1, pn, \u2227n i=1(\u00acpi \u2228 pi\u22121),\u00acp0} and \u03a6 = {n \u2265 1, pn\u22121, \u2227n\u22121 i=1 (\u00acpi \u2228 pi\u22121),\u00acp0}. We have \u03a6 \u2287s \u03a8. Indeed, consider the shift \u03c3 = {n 7\u2192 n \u2212 1}. By definition \u03a6N = {n \u2265 1}. We have (n \u2265 0)\u03c3 = n \u2212 1 \u2265 0 \u2261 n \u2265 1, thus \u03a6N |= (n \u2265 0)\u03c3. Since n \u2265 0 and i \u2208 [1, n], pi cannot be identical to pn+1, thus pn+1 is pure in \u03a8. Finally, we have pn\u03c3 = pn\u22121 \u2208 \u03a6 and \u2227n i=1(\u00acpi \u2228 pi\u22121)\u03c3 = \u2227n\u22121 i=1 (\u00acpi \u2228 pi\u22121) \u2208 \u03a6.\nWe now show that \u2287s is decidable. First of all, it is trivial that syntactic equality is decidable as shown by the following definition and proposition:\nDefinition 5.11 Let U(\u03d5, \u03c8) be the arithmetic formula defined as follows:\n\u2022 If \u03d5 = pa and \u03c8 = pb then U(\u03d5, \u03c8) def = (a = b).\n\u2022 If \u03d5 = (a \u25b9 b) and \u03c8 = (c \u25b9 d) (with \u25b9 \u2208 {\u2264, <}) then U(\u03d5, \u03c8) def= (a = c) \u2227 (b = d).\n\u2022 If \u03d5 = \u00ac\u03d5\u2032 and \u03c8 = \u00ac\u03c8\u2032 then U(\u03d5, \u03c8) = U(\u03d5\u2032, \u03c8\u2032).\n\u2022 If \u03d5 = (\u03d51\u03c0\u03d52) (with \u03c0 \u2208 {\u2228,\u2227}) and \u03c8 = (\u03c81\u03c0\u03c82) then U(\u03d5, \u03c8) = U(\u03d51, \u03c81) \u2227 U(\u03d52, \u03c82).\n\u2022 If \u03d5 = \u03a0bi=a\u03d5\u2032 and \u03c8 = \u03a0di=c\u03c8\u2032 then U(\u03d5, \u03c8) def = (a = c) \u2227 (b = d) \u2227 U(\u03d5\u2032, \u03c8\u2032).\n\u2022 Otherwise U(\u03d5, \u03c8) def= \u22a5.\nProposition 5.12 Let \u03d5, \u03c8 be two schemata. For every substitution \u03c3, U(\u03d5, \u03c8)\u03c3 is valid iff \u03d5\u03c3 and \u03c8\u03c3 are syntactically identical."}, {"heading": "Proof", "text": "By a straightforward induction on the formulae.\nWe can prove the decidability of \u2287s:\nProposition 5.13 \u2287s is decidable."}, {"heading": "Proof", "text": "Since linear arithmetic is decidable, it is possible to check whether a literal is pure or not in a set of formulae \u03a8. Then these pure literals can be simply removed from \u03a8 (since they satisfy the second condition in Definition 5.9). One now has to find a shift \u03c3 such that every remaining formula in \u03a8 satisfies the first or third condition. Let n1, . . . , n\u03ba be the variables in \u03a6,\u03a8. Let \u03c3 be a substitution mapping every parameter n\u03b9 (1 \u2264 \u03b9 \u2264 \u03ba) to n\u03b9 \u2212 l\u03b9, where the l\u03b9 are distinct variables not occurring in \u03a6,\u03a8. One has to check that there exists a substitution \u03b8 mapping every variable l\u03b9 to an integer such that:\n\u2022 \u2200\u03b9 \u2208 [1, \u03ba], \u03b8(l\u03b9) \u2265 0 and \u2203\u03b9 \u2208 [1, \u03ba], \u03b8(l\u03b9) > 0. Since \u03ba is fixed, this condition can be stated as an arithmetic formula.\n\u2022 For every formula \u03c8 \u2208 \u03a8, one of the following conditions holds:\n\u2013 \u03c8 is an arithmetic formula and \u03a6N |= \u03c8\u03c3\u03b8, i.e. the formula \u2200n1, . . . , n\u03ba.\u03a6N \u21d2 \u03c8\u03c3\u03b8 is valid.\n\u2013 \u03c8\u03c3\u03b8 occurs in \u03a6. This holds iff \u03a6 contains a formula \u03d5, such that \u03c8\u03c3\u03b8 and \u03d5 are identical for every value of the parameters, i.e., by Proposition 5.12, iff \u2200n1, . . . , nk.U(\u03d5, \u03c8\u03c3\u03b8) is valid.\nSince every condition above is equivalent to an arithmetic formula, the whole condition can be expressed as an arithmetic formula (taking the conjunction of the formulae corresponding to each \u03c8 \u2208 \u03a8 and \u03d5 \u2208 \u03a6). This formula is satisfiable iff there exists a substitution \u03b8 satisfying the desired property. Then the proof follows straightforwardly from the decidability of linear arithmetic.\nNow we prove that \u2287s is stronger than the relation |=s. Proposition 5.14 Let \u03a6,\u03a8 be two sets of schemata. If \u03a6 \u2287s \u03a8 then \u03a6 |=s \u03a8."}, {"heading": "Proof", "text": "Let \u03c3 be the shift satisfying the conditions of Definition 5.9. Let I be an interpretation satisfying \u03a6. Let \u03b8 = \u03c3I . We have to show that there exists J < I s.t. J |= \u03c8, i.e. that there exists a shift \u03c3\u2032 s.t. J = I\u03c3\u2032 and J |= \u03c8. Equivalently, we can show that there exists a model J of \u03c8\u03c3, i.e. that \u03c3\u2032 = \u03c3 is convenient. Let J be an interpretation s.t. J (L) = T if L is a literal that is pure in \u03a8\u03c3 and J (L) def= I(L) otherwise. Let \u03c8 \u2208 \u03a8. We have to show that J |= \u03c8\u03c3. We distinguish three cases, according to the three items in Definition 5.9.\n\u2022 If \u03a6N |= \u03c8\u03c3, then since I |= \u03a6 and since J and I coincide on every arithmetic variable we must have J |= \u03c8\u03c3.\n\u2022 If \u03c8 is a literal pure in \u03a8 then \u03c8\u03c3 is pure in \u03a8\u03c3, thus we have J |= \u03c8\u03c3 by definition.\n\u2022 If \u03c8\u03c3 \u2208 \u03a6, then I |= \u03c8\u03c3. Thus every literal that is pure in \u03a6 must be pure in \u03c8\u03c3. The complementary of these literals cannot occur in [\u03c8\u03c3]\u03b8. Since I and J coincide on all other literals and since \u03c8 is in negative normal form, we must have J |= \u03c8\u03c3.\nConsequently J |= \u03c8\u03c3, hence J \u03c3 |= \u03c8.\n\u2287s is strictly less general than |=s as evidenced by the following: Example 5.15 Let \u03a6 = { \u2228n i=1 pi} and \u03a8 = { \u2228n i=2 pi}. We have shown that \u03a8 |=s \u03a6 (see Example 5.5).\nHowever, we have \u03a8 \u0338\u2287s \u03a6, since there is no shift \u03c3 such that ( \u2228n i=1 pi)\u03c3 = \u2228n\ni=2 pi (this is obvious since 1\u03c3 cannot be equal to 2 whatever is \u03c3)."}, {"heading": "5.3 Examples", "text": "Before proving the soundness, completeness and termination of stab, we provide some examples of tableaux."}, {"heading": "5.3.1 A Simple Example", "text": "Let \u03d5 be the following formula: (n \u2265 0) \u2227 p0 \u2227 \u2227n\ni=1(\u00acpi\u22121 \u2228 pi) \u2227 \u00acpn. We construct a tableau for \u03d5. First the \u2227-rule applies to transform the conjunction into a set of schemata. The closure rule applies on pn and p0, yielding the constraint n \u0338= 0. Then the iteration rule applies on the schema \u2227n i=1(\u00acpi\u22121\u2228 pi), yielding two branches. The first one corresponds to the case in which the iteration is non empty and can be unfolded, yielding \u2227n\u22121 i=1 (\u00acpi\u22121\u2228pi) and \u00acpn\u22121\u2228pn and the second one corresponds to the case where the iteration is empty (hence true), yielding the constraint n < 1. The latter branch can be closed immediately due to the constraints n \u2265 0 and n \u0338= 0. In the former branch, the \u2228-rule applies on the formula \u00acpn\u22121 \u2228 pn, yielding two branches with \u00acpn\u22121 and pn respectively. The closure rule applies on the latter one, yielding the unsatisfiable constraint n \u0338= n hence the branch can be closed. The last remaining branch loops on the initial one, with the shift n 7\u2192 n\u22121. The obtained tableau is depicted in Figure 2. Closed leaves (resp. blocked leaves looping on \u03b1) are marked by \u00d7 (resp. (\u03b1)). Only new (w.r.t. the previous block) formulae are presented in the blocks.\n5.3.2 n-Bit Adder\nIn this section we provide a slightly more complicated example. We use stab to prove a simple property of the n-bit Adder defined in the Introduction. We aim at proving that A + 0 = A. A SAT-solver can easily refute this formula for a fixed n (say n = 10). We prove it for all n \u2208 N. This simple example has been chosen for the sake of readability and conciseness, notice that commutativity or associativity of the n-bit adder could be proven too (see Section 5.7).\nWe express the fact that the second operand is null: \u2227n\ni=1 \u00acqi, and the fact that the result equals the first operand: \u2227n i=1(pi \u21d4 ri), which gives \u2228n i=1(pi \u2295 ri) by refutation. So\nwe want to prove that Adder \u2227 \u2227n i=1 \u00acqi \u2227 \u2228n\ni=1(pi \u2295 ri) is unsatisfiable. Notice that this schema is regular.\nThe corresponding tableau is sketched in Figure 3. Sequences of propositional extension rules are not detailed.\nExplanations. The first big step decomposes all the iterations. The branching is due to \u2228n i=1 pi \u2295 ri: first we have pn \u2295 rn, then \u2228n\u22121 i=1 pi \u2295 ri. The right branch loops after a\nfew steps as all iterated conjunctions \u2227n i=1 . . . contain \u2227n\u22121\ni=1 . . . The left one is extended by propositional rules (the reader can easily check that Sumn, Carryn, pn \u2295 rn and \u00acqn indeed lead to the presented branches, notice that cn must hold, otherwise we would have pn \u21d4 rn).\nIn (2) we start by decomposing all iterations a second time. Iterations are aligned on [1, n \u2212 1] so they all introduce the same constraints i.e. either n \u2212 1 \u2265 1 (first branch) or n \u2212 1 < 1 (second branch). In the second case, the introduced constraint implies that n = 1, thus cn = c1 which closes the branch. In the first case we decompose Carryn\u22121 and consider the various cases. Two of them are trivially discarded as they imply qn\u22121, whereas we easily obtain \u00acqn\u22121 by an unfolding of \u2227n i=1 \u00acqi. It only remains one case which is easily seen to loop on (2). The branch (2\u2032) is very similar to (2)."}, {"heading": "5.4 Soundness and Completeness", "text": "A leaf is irreducible if no extension rule applies to it. A derivation is a (possibly infinite) sequence of tableaux (T\u03b9)\u03b9\u2208I s.t. I is either [0, \u03ba] for some \u03ba \u2265 0, or N and s.t. for all \u03b9 \u2208 I \\ {0}, T\u03b9 is obtained from T\u03b9\u22121 by applying one of the extension rules. A derivation is fair if either there is \u03b9 \u2208 I s.t. T\u03b9 contains an irreducible not closed leaf or if for all \u03b9 \u2208 I and every not closed and not blocked leaf N in T\u03b9 there is \u03bb \u2265 \u03b9 s.t. a rule is applied on N in T\u03bb (i.e. no leaf can be \u201cfreezed\u201d).\nDefinition 5.16 (Tableau Semantics) For every node N in a tableau T , \u03a6T (N) is interpreted as the conjunction of its elements. T is satisfied in an interpretation I iff there exists a leaf N in T s.t. I |= \u03a6T (N).\nLemma 5.17 If T \u2032 is a tableau obtained by applying one of the extension rules on a leaf N of a tableau T then I |= \u03a6T (N) iff there exists a leaf N \u2032 of T \u2032 s.t. N \u2032 is a child of N in T \u2032 and I |= \u03a6T \u2032(N \u2032) (i.e. the rules are sound and invertible)."}, {"heading": "Proof", "text": "Obvious, by inspection of the extension rules.\nLemma 5.18 If a leaf N in T is irreducible and not closed then T is satisfiable."}, {"heading": "Proof", "text": "Let \u03a8 be the set of arithmetic formulae in \u03a6T (N) and \u03a6 def = \u03a6T (N) \\\u03a8. As N is not closed \u03a8 is satisfiable (by definition), so let \u03c3 be a solution of \u03a8. If \u03a6 contains a formula \u03d5 that is not a literal, one of the extension rules applies and deletes \u03d5, which is impossible. Let cT (N) be the number of pairs pa, \u00acpb \u2208 \u03a6T (N) s.t. there is an interpretation I validating \u03a8 s.t. JaKI = JbKI . If cT (N) \u0338= 0, then the closure rule applies on pa, pb which is impossible. Hence cT (N) = 0 and in particular this implies that \u03a6\u03c3 is propositionally satisfiable (i.e. contains no pair of complementary literals). Thus \u03a6T (N)\u03c3 is satisfiable and by definition T is satisfiable.\nTheorem 5.19 (Soundness and Completeness w.r.t. Satisfiability) Let (T\u03ba)\u03ba\u2208I be a derivation.\n\u2022 If there exists \u03b9 \u2208 I s.t. T\u03b9 contains an irreducible, not closed leaf then T0 is satisfiable.\n\u2022 If the derivation is fair and if T0 is satisfiable then there exist \u03b9 \u2208 I and a leaf in T\u03b9 that is irreducible and neither closed nor blocked."}, {"heading": "Proof", "text": "The first item (i.e. soundness) follows from Lemmata 5.17 and 5.18.\nWe now prove that the procedure is complete w.r.t. satisfiability (the second item). Let I be an interpretation and \u03d5 a schema. We define mI(\u03d5) as follows:\n\u2022 mI(\u03d5) def = 0 if \u03d5 is an arithmetic atom (i.e. an atom of the form . . . < . . .).\n\u2022 mI(\u03d5) def = 1 if \u03d5 is an indexed proposition or its negation, or \u03d5 is \u22a4 or \u22a5.\n\u2022 mI(\u03d51 \u22c6 \u03d52) def = mI(\u03d51) +mI(\u03d52) if \u22c6 \u2208 {\u2228,\u2227}. \u2022 mI(\u03a0bi=a\u03d5) def = 2 if JbKI < JaKI\n\u2022 mI(\u03a0bi=a\u03d5) def = \u03b2 \u2212 \u03b1+ 2+\u03a3\u03b2\u03b9=\u03b1mI[\u03b9/\u0131](\u03d5) where \u03a0 \u2208 { \u2227 , \u2228 }, \u03b1 = JaKI , \u03b2 = JbKI , and\n\u03b2 \u2265 \u03b1.\nIf \u03a6 is a set, then mI(\u03a6) def = {mI(\u03d5) | \u03d5 \u2208 \u03a6}. If T is a tableau and N is a leaf in T then mI(N, T ) def = (mI(\u03a6T (N)), cT (N)) where cT (N) is defined in the proof of Lemma 5.18. This measure is ordered using the multiset and lexicographic extensions of the usual ordering on natural numbers. Thus, it is obviously well-founded. We need the following:\nLemma 5.20 Let I be an interpretation. Let T be a tableau. If T \u2032 is deduced from T by applying an extension rule on a leaf N s.t. I |= \u03a6T (N), then for every child N \u2032 of N in T \u2032 s.t. I |= \u03a6T \u2032(N \u2032), we have mI(N \u2032, T \u2032) < mI(N, T )."}, {"heading": "Proof", "text": "All the rules except the iteration rule and the closure rule replace a formula by simpler ones, hence it is easy to see that mI(\u03a6T (N)) decreases. The iteration rules replace an iteration of length \u03b9 either by \u22a4 or by a disjunction/conjunction of an iterated disjunction/conjunction of length \u03b9\u2212 1, and a smaller formula. Since \u03b9 > \u03b9\u2212 1, mI(\u03a6T (N)) decreases. The closure rule does not affect mI(\u03a6T (N)) but obviously decreases cT (N).\nLet I be a model of T0. By Proposition 5.6, we can assume that I is minimal w.r.t the ordering < introduced in Definition 5.4.\nBy Lemma 5.17, for all \u03b9 \u2208 I, T\u03b9 contains a leaf N\u03b9 s.t. I |= \u03a6T\u03b9(N\u03b9). Let \u03ba \u2208 I s.t. mI(N\u03ba, T\u03ba) is minimal (\u03ba exists since mI(Ni, Ti) is well-founded). Assume a rule is applied on N\u03ba in the derivation, on some tableau T\u03bb. By Lemma 5.17 there is a child N \u2032 of N\u03ba s.t. I |= \u03a6T\u03bb(N \u2032). By Lemma 5.20 we have mI(N \u2032, T\u03bb) < mI(Nk, T\u03ba) which is impossible. Thus no rule is applied on N\u03ba. Assume that N\u03ba is blocked. Then there exists a node N \u2032 s.t. N\u03ba loops on N \u2032. By Definition 5.4 there exists an interpretation J s.t. J |= N \u2032 and\nJ <V I. But then by Lemma 5.17 (\u201conly if\u201d implication), J |= T0, which contradicts the minimality of I. Since the derivation is fair, N\u03ba is irreducible (or there is another leaf that is irreducible). Furthermore, N\u03ba cannot be closed since it is satisfiable (I |= \u03a6T\u03ba(N\u03ba)).\nIt is worth emphasizing that stab is sound and complete (w.r.t. satisfiability) for any schema, not only for bound-linear or regular ones. But the termination result in the next section only holds for regular schemata."}, {"heading": "5.5 Termination on Regular Schemata", "text": "We consider the following strategy ST for applying the extension rules:\n\u2022 The propositional extension rules, the looping and closure rules are applied as soon as possible on all leaves, with the highest priority. These rules obviously terminate on any schema.\n\u2022 The iteration rules are applied only on iterations of maximal length (w.r.t. the natural partial ordering on arithmetic expressions). For instance if we have the schema\u2227n\ni=1 pi\u2228 \u2228n\u22121 j=1 qj then the iteration rules will only apply on the first iteration \u2227n i=1 pi.\n\u2022 The relation \u2287s introduced in Section 5.2 is used to block looping nodes.\nTheorem 5.21 ST terminates on every regular schema."}, {"heading": "Proof", "text": "Let \u03b1, \u03b2, \u03b3, \u03b4 \u2208 Z and \u03d5 be a regular schema aligned on [\u03b1, n\u2212\u03b2], of propagation limits \u03b3, \u03b4. Assume that an infinite branch is constructed. By definition of the strategy, after some time, the \u03ba last ranks of every iteration have been unfolded by the iteration rules. Thus all the remaining iterations are of the form \u03a0n\u2212\u03b2\u2212\u03bai=\u03b1 \u03d5\n\u2032 and we have the arithmetic constraint n\u2212 \u03b2 \u2212 \u03ba\u2212 \u03b1+ 1 \u2265 0, i.e. n \u2265 \u03b2 + \u03ba+ \u03b1\u2212 1.\nFrom now on, we only consider nodes that are irreducible w.r.t. propositional rules. We show that a finite set of formulae are generated by stab, up to a shift on n. As a consequence the looping rule must apply, at worst when all possible formulae have been generated.\nThe arithmetic formulae occurring in the initial formula must be of the form \u00b5.n > \u03bd or \u00b5.n < \u03bd. After the last \u03ba ranks have been unfolded, the constraint n \u2265 \u03b2 + \u03ba + \u03b1 \u2212 1 must have been added. Thus if \u03ba is sufficiently big, \u00b5.n > \u03bd is equivalent to \u22a4 and \u00b5.n < \u03bd is equivalent to \u22a5. Thus every arithmetic formula occurring in the initial formula is either false or redundant w.r.t. n \u2265 \u03b2 + \u03ba + \u03b1 \u2212 1. The remaining arithmetic formulae must have been introduced by the closure rule (since the iterations contain no occurrence of <). They are necessarily of the form a \u0338= b where a, b are arithmetic expressions (appearing as indices in some formula of the derivation). If a, b both contain n, or if a, b \u2208 Z then a \u0338= b is equivalent either to \u22a5 or to \u22a4. Thus we only consider the case in which a contains n and b \u2208 Z. If a occurs in the initial formula then it must be of the form \u00b5.n + \u03bd for \u00b5, \u03bd \u2208 Z. Since n \u2265 \u03b2 + \u03ba + \u03b1 \u2212 1, if \u03ba is sufficiently big, the disequation \u00b5.n + \u03bd \u0338= b must be false. If a did not occur in the initial formula then it must come from the (\u03ba\u2212 \u03b9)th unfolding of some iteration, for some \u03b9 \u2208 [0, \u03ba\u22121]. Since (by definition of a regular schema)\nthe indices are of the form i + \u03bb, where \u03bb \u2208 [\u03b3, \u03b4], the disequation is actually of the form n \u2212 \u03b2 \u2212 \u03ba + \u03b9 + \u03bb \u0338= b, where \u03bb \u2208 [\u03b3, \u03b4], \u03b9 \u2208 [0, \u03ba \u2212 1] (since the iteration counter i may be replaced by n\u2212 \u03b2, n\u2212 \u03b2 \u2212 1, . . . , n\u2212 \u03b2 \u2212 \u03ba+ 1) and b occurs in the initial formula. If the previous equation is not equivalent to \u22a4, then, since we have the constraint n \u2265 \u03b2+\u03ba+\u03b1\u22121, we must have \u03b9 \u2208 [0, b\u2212 \u03b1+ 1\u2212 \u03bb]. Hence there are finitely many such formulae, up to the translation n 7\u2192 n\u2212 \u03ba.\nNow, consider the non arithmetic formulae occurring in the branch. These schemata must be either iterations or literals (by irreducibility w.r.t. the propositional extension rules).\nAll the iterations are of the form \u03a0n\u2212\u03b2\u2212\u03bai=\u03b1 \u03d5 \u2032, where \u03a0n\u2212\u03b2i=\u03b1 \u03d5 \u2032 is an iteration occurring in the initial formula. Obviously, the number of such iterations is finite up to the translation n 7\u2192 n\u2212 \u03ba.\nThe literals occurring in the branch (but not in the scope of an iteration) are either literals of the initial schema or literals introduced by previous applications of the iteration rules. The former are indexed by expressions of the form \u00b5 \u00d7 n+ \u03bd for some \u00b5, \u03bd \u2208 Z and the latter by n\u2212 \u03b2 \u2212 \u03ba+ \u03f5, where \u03f5 \u2208 [\u03b3 + 1, \u03b4 + \u03ba].\nIf a literal is indexed by an expression \u00b5\u00d7n+\u03bd that is outside [\u03b1+\u03b3, n\u2212\u03b2\u2212\u03ba+\u03b4], then it must be pure in every iteration, hence (by irreducibility w.r.t. the closure rule) must be pure in the node. Actually, if \u03ba is large enough then, by the above arithmetic constraints, \u00b5 \u00d7 n + \u03bd cannot be in [\u03b1 + \u03b3, n \u2212 \u03b2 \u2212 \u03ba + \u03b4] if \u00b5 \u0338= 0. Indeed, if \u00b5 is negative, then it suffices to take \u03ba > \u03b1+\u03b3\u2212\u03bd\u00b5 \u2212\u03b2\u2212\u03b1+1 to ensure \u00b5\u00d7n+ \u03bd < \u03b1+ \u03b3, otherwise \u03ba \u2265 \u03b4\u2212\u03b2\u2212 \u03bd is enough to have \u00b5 \u00d7 n + \u03bd > n \u2212 \u03b2 \u2212 \u03ba + \u03b4 (as \u00b5, n \u2265 1). Thus every literal indexed by integer terms of this form are pure, since by definition its index cannot be unifiable with an index occurring in an iteration (after unfolding).\nSimilarly literals indexed by expressions of the form n\u2212 \u03b2\u2212 \u03ba+ \u03f5 where \u03f5 > \u03b4 are pure, thus we may assume that \u03f5 \u2208 [\u03b3, \u03b4]. Consequently there are finitely many such literals up to the shift n 7\u2192 n\u2212 \u03ba.\nThis implies that the number of possible schemata obtained after \u03ba unfolding steps is finite, up to a translation of n. By the pigeonhole principle, the looping rule necessarily applies at some point in the branch, which contradicts our initial assumption that an infinite branch is constructed.\nTermination of the strategy also ensures fairness:\nLemma 5.22 Any derivation constructed by ST (applied until irreducibility) is fair."}, {"heading": "Proof", "text": "Let (T\u03b9)\u03b9\u2208I be a derivation constructed by ST. Since ST terminates, there cannot be any infinite derivation, thus I is necessarily of the form [0, \u03ba] for some \u03ba \u2208 N. By definition, every node in T\u03ba is either blocked or closed or irreducible (the strategy is applied until irreducibility). If T\u03ba contains a not closed irreducible leaf then the proof is completed (by definition of the notion of fairness). Otherwise, consider T\u03b9 with \u03b9 \u2264 \u03ba. Let then N be a not irreducible, not closed and not blocked leaf occurring in T\u03b9. Assume that there is no \u03bb \u2265 \u03b9 s.t. a rule is applied on N in T\u03bb (which would contradict our definition of fairness). This means that no extension can possibly affect N , thus N must also occur in the final tableau\nT\u03ba (and is labeled by the same set of schemata than in T\u03b9). Thus N must be not closed and not irreducible. Moreover it cannot be blocked in T\u03ba, since no rule can affect the nodes on the branch behind N . But this is impossible since the nodes in T\u03ba must be either blocked or closed or irreducible.\nAs an immediate corollary, we have the following:\nTheorem 5.23 The satisfiability problem is decidable for bound-linear schemata."}, {"heading": "Proof", "text": "By Theorems 4.12 and 4.13, every bound-linear schema can be transformed into a satequivalent regular one. Theorem 5.21 shows that stab terminates on every regular schema, hence by Theorem 5.19 and Lemma 5.22, stab can be used to decide the satisfiability problem for regular schemata.\nA fine analysis of the previous termination proof ensures that we can solve the satisfiability problem for regular schemata in exponential time (if natural numbers are written in unary notation). As we have seen furthermore (Theorem 4.9) that the translation of boundlinear schemata into regular ones was exponential, we can conclude that the satisfiability problem for bound-linear schemata can be solved in double exponential time."}, {"heading": "5.6 Model Building", "text": "The existence of a non closed irreducible branch ensures that the root schema is satisfiable, as shown in Theorem 4.12. The arithmetic constraints in the branch specify the possible values of the parameter. The remaining formulae must be literals, since the extension rules apply on any complex formula (in particular, there can be no iteration schema). These literals specify the truth value of propositional variables exactly as in the usual case of propositional logic (the value of the propositional variables that do not appear in the branch may be chosen arbitrarily). Since the branch is not closed, it cannot contain any pair of complementary literals.\nWe illustrate this construction by a simple example. We consider the following tableau:\npn,\u00acq2,\u00acr1, \u2228n i=1(\u00acpi \u2227 qi \u2227 ri)\nn \u2265 1, \u2228n\u22121\ni=1 (\u00acpi \u2227 qi \u2227 ri)\nn \u2265 1, \u2228n\u22122\ni=1 \u00acpi \u2227 qi \u2227 ri\n. . .\nn\u2212 1 \u2265 1,\u00acpn\u22121 \u2227 qn\u22121 \u2227 rn\u22121\n\u00acpn\u22121, qn\u22121, rn\u22121\nn\u2212 1 \u0338= n, n\u2212 1 \u0338= 2, n\u2212 1 \u0338= 1\n(1)\nn \u2265 1,\u00acpn \u2227 qn \u2227 rn\n\u00acpn, qn, rn\nn \u0338= n\n\u00d7\nThe branch (1) is irreducible. It contains the following formulae: pn, \u00acq2, \u00acr1, n\u22121 \u2265 1, \u00acpn\u22121, qn\u22121, rn\u22121, n\u2212 1 \u0338= n, n\u2212 1 \u0338= 2, n\u2212 1 \u0338= 1. The value of n can be determined by finding a solution to the above arithmetic constraints. We choose for instance the solution n = 4. After instantiation we get the remaining formulae: {p4,\u00acq2,\u00acr1,\u00acp3, q3, r3}, which gives for instance the following interpretation of p, q and r: p\u03ba is true iff \u03ba = 4 and q\u03ba, r\u03ba are true iff \u03ba = 3. It is easy to check that the obtained interpretation satisfies the initial schema.\nA possible extension of this simple algorithm would be, from a given tableau, to compute a symbolic representation of the whole set of models of the root schema. This set is infinite and must be defined by induction. The closed irreducible branches correspond to concrete models, or base cases, whereas the loops correspond to inductive construction rules. These rules take a model I and construct a new model J of a strictly greater cardinality (the values of the parameters increase strictly). This would require to define a formal language for denoting sets of interpretations (one could use, e.g., automata recognizing sequences of tuples of Boolean values)."}, {"heading": "5.7 The System", "text": "The decision procedure has been implemented and the program (called RegStab) is freely available on the web page http://regstab.forge.ocamlcore.org/. It is written in OCaml and was successfully tested on MacOSX (10.5), Win32 (Windows XP SP3) and GNU Linux (Ubuntu 9.04) x86 platforms. The system comes with a manual including installation and usage instructions and a description of the input syntax. Functions can be defined to make the input file more readable (see Sum(i) and Carry(i) below). Here is an input file for the adder example in Section 5.3.2.\n// A+0=A let Sum(i) := S_i <-> (A_i (+) B_i (+) C_i) in let Carry(i) := C_i+1 <-> (A_i /\\ B_i \\/ C_i /\\ A_i \\/ C_i /\\ B_i) in let Adder := /\\i=1..n (Sum(i) /\\ Carry(i)) /\\ ~C_1 in let NullB := /\\i=1..n ~B_i in let Conclusion := \\/i=1..n (A_i (+) S_i) in"}, {"heading": "Adder() /\\ NullB() /\\ Conclusion()", "text": "The software simply prints the status of the schema (satisfiable or unsatisfiable). Options are provided to get more information about the search space (number of inference rules, depth of unfolding etc.), see the manual for details. An additional tool is offered to expand the schema into a propositional formula in DIMACS format (by fixing the value of n).\nFigure 4 gives some examples of problems that can be solved by RegStab and the corresponding running times (please refer to the distribution for input files and additional information).\nHere is an example of output, proving that 0 is a neutral element for the carry-propagate adder. We ran the system in verbose mode, in which it prints some useful information about the search: number of application of extension rules, number of closed and looping leaves, unfolding depth and set of lemmata (companion nodes)."}, {"heading": "Conjecture:", "text": "(((/\\i=1..n ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i))))) /\\ ~C_1) /\\ (/\\i=1..n ~B_i)) /\\ (\\/i=1..n (A_i (+) S_i))\nApplications of tableau rules: /\\: 67 \\/: 84 (+): 38 <->: 32 ->: 0 Iterated /\\: 12 Iterated \\/: 3 ------- Total propositional rules: 221 Total iterated rules: 15\nNumber of closed leaves: 137 Number of looping leaves: 30 Number of lemmas: 4\nMaximum number of unfoldings: 3 (if this number is surprising, notice that the tableau is constructed depth-first)"}, {"heading": "Lemmas:", "text": "[\\/i=1..n (A_i (+) S_i) ; /\\i=1..n ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n ~B_i ; ~C_1] [\\/i=1..n-1 (A_i (+) S_i) ; /\\i=1..n-1 ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n-1 ~B_i ; ~C_n ; ~C_1] (n > 0) [/\\i=1..n-2 ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n-2 ~B_i ; C_n-1 ; ~C_1] (n > 1) [\\/i=1..n-2 (A_i (+) S_i) ; /\\i=1..n-2 ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n-2 ~B_i ; C_n-1 ; ~C_1] (n > 1)\nUNSATISFIABLE"}, {"heading": "6. Undecidability Results", "text": "We provide some undecidability results for two natural extensions of the class of regular schemata."}, {"heading": "6.1 Homothetic Transformations on the Iteration Counters", "text": "We consider the class of schemata Ch defined as follows.\nDefinition 6.1 Ch (h stands for \u201chomothetic\u201d) is the set of schemata \u03d5 satisfying the following properties:\n\u2022 \u03d5 contains at most one parameter n. \u2022 Every iteration in \u03d5 is of the form \u2227n i=1 \u03d5 or \u2228n i=1 \u03d5, where:\n\u2013 \u03d5 contains no iteration.\n\u2013 Every atomic formula in \u03d5 belongs to {pi, p2i, pi\u00b11, p2i\u00b11} where p is a variable.\n\u2022 The atomic formulae occurring in \u03d5 but not in the scope of an iteration are of the form p0 or pn where p is a variable 9.\nCh is rather simple and very close to the class of regular schemata. There is only one parameter n, all the iterations have the same bounds 1 and n, there is no nested iteration and the indices of the symbol in P must be affine images of the iteration counter. The only difference with the regular class is that, in Ch the coefficient of the iteration counter in the indexed variables may be equal to 2 whereas it must be equal to 0 or 1 in regular schemata. Thus regular schemata only contain translations of the iteration counter, whereas Ch may involve (very simple) homothetic transformations.\nDue to this closeness, one could expect that the satisfiability problem is decidable for Ch, but the next theorem shows that this is not the case.\nTheorem 6.2 The set of unsatisfiable formulae in Ch is not recursively enumerable.\nThe proof of Theorem 6.2 is difficult and the remaining part of this section is devoted to it. More precisely, we shall prove that the Post correspondence problem can be encoded into Ch. Notice that this problem is easily encoded with general schemata (Aravantinos et al., 2009b), whereas, here, the whole difficulty of the proof lies in the strong restrictions imposed by Ch. Observe that the difficult proof is really worth it as one would easily believe that just allowing multiplication by a constant is an unsignificant change."}, {"heading": "6.1.1 Notations", "text": "We first recall some basic definitions and introduce some useful notations. Let A be an alphabet. Let \u03ba be a natural number. Let a = (a1, . . . , a\u03ba) and b = (b1, . . . , b\u03ba) be two sequences of words in A\u2217. If w \u2208 {a, b} and \u03b9 \u2208 [1, \u03ba], |w\u03b9| denotes the length of w\u03b9 and w\u03bb\u03b9 denotes the \u03bb-th character of the word w\u03b9 (1 \u2264 \u03bb \u2264 |w\u03b9|).\n9. Notice that p0 and pn can occur in the scope of a negation.\nIf \u2206 = (\u22061, . . . ,\u2206\u03b9) is a sequence of indices in [1, \u03ba] and if w = (w1, . . . , w\u03ba) is a \u03ba-tuple of words in A\u2217 (where w \u2208 {a, b}) we denote by w\u2206 the word w\u22061 . \u00b7 \u00b7 \u00b7 .w\u2206\u03b9 (where \u201c.\u201d denotes the concatenation operator). A solution of the Post correspondence problem is a sequence \u2206 s.t. a\u2206 = b\u2206. The witness of this solution is the word a\u2206.\nFor technical convenience, we assume (this is obviously not restrictive) that \u03ba > 1, \u2206\u03b9 = \u03ba, \u2206\u03bb \u0338= \u03ba if \u03bb < \u03b9 and that a\u03ba = b\u03ba = \u22a5 where \u22a5 is a special character (not occurring in a1, . . . , a\u03b9\u22121, b1, . . . , b\u03b9\u22121) denoting the end of the sequence."}, {"heading": "6.1.2 Overview of the Encoding", "text": "The intuition behind the encoding is the following. We show how to encode any instance of the problem into a schema \u03d5 so that \u03d5 is satisfiable iff this instance has a solution. More precisely, we construct \u03d5 of parameter n s.t. for all \u03ba \u2208 N , \u03d5[\u03ba/n] is satisfiable iff there is a solution of length \u03ba.\nWe first present the encoding used to represent the potential solutions a\u2206 and b\u2206; then we will see how to check that those are really solutions. We represent the potential solution w\u2206 (where w = a, b) by a one-dimensional array of length n. More precisely, we do not store the characters themselves but rather, for each character, a pair containing the index \u2206\u03bd of the word w\u2206\u03bd in which it occurs and its position in this word (as we shall see this is useful to find the next character in w\u2206). For instance the first index should contain the pair (\u22061, 1) (first word, first character). Then the next index contains either (\u22061, 2) (if |w\u22061 | > 1, first word, second character) or (\u22062, 1) (if |w\u22061 | = 1, second word, first character).\nFor example, if A = {\u2217, \u25e6, \u22c6}, a = (\u2217\u25e6, \u22c6) and \u2206 = (1, 2), then the obtained array would be the following one:\nValues (1, 1) (1, 2) (2, 1) Indices 1 2 3\nHowever, the word w\u2206 is not stored into consecutive indices in the array. Indeed, as we shall see, we also need to store, for each character w\u2206\u03bb of the witness, the indices \u2206\u03bb+1, . . . ,\u2206\u03b9 of the remaining words, occurring after w\u2206\u03bb in w\u2206. This sequence is called the tail of the potential solution. Since the length of this sequence is unbounded, it cannot be encoded simply by indexed propositions: it must be stored into the array and the simplest solution is to store these indices just after the character itself. Notice that only the indices of words are stored in the tail i.e. there is no character position. Thus we get:\nValues (1, 1) 2 (1, 2) 2 (2, 1) Indices 1 2 3 4 5\nThe easiest way to proceed would be to store the first character of the witness at position 0, the indices of the remaining words at position 1, 2, . . . , \u03b9, then the second character of the witness at position \u03b9 + 1 etc. That way, the \u03bb-th character of the witness would be stored at position (\u03bb\u2212 1)\u00d7 (\u03b9+1) and the following characters in the sequence at positions (\u03bb\u22121)\u00d7 (\u03b9+1)+1, . . . , (\u03bb\u22121)\u00d7 (\u03b9+1)+ \u03b9. For any character stored in an index \u03bb, the next character would be stored at the index \u03bb + \u03b9 + 1. But this simple solution is not suitable because it is outside the considered class. Indeed, it requires the use of another parameter \u03b9 (the first parameter being n: the length of the array) and also the use of this parameter\nin the indices (to relate the character stored in index \u03bb to the one at index \u03bb+ \u03b9), which is forbidden in the class Ch.\nThus we need to find another encoding of the previous array. The idea is to store the first character at some index \u00b5 (where \u00b5 is assumed to be greater than \u03b9), the second character at the index 2 \u00d7 \u00b5, . . . and more generally the \u03bb-th character at the index \u00b5 \u00d7 2\u03bb\u22121. The tail of the sequence is then stored at the indices (\u00b5 + 1) \u00d7 2\u03bb\u22121, . . . , (\u00b5 + \u03b9) \u00d7 2\u03bb\u22121. This encoding ensures that the index of the next character after the one at index i is simply 2.i, and such homethetic transformations are precisely those allowed for the indices in Ch.\nFinally, the array corresponding to our recurrent example is the following one (with \u00b5 = 2):\nValues (1, 1) 2 (1, 2) 2 (2, 1) Indices 1 2 3 4 5 6 7 8\nThe witness is obtained by considering the characters stored at the indices 2,4 (= 2\u00d72) and 8 (= 2\u00d722), namely \u2217 (first character of the first word), \u25e6 (first word, second character), and \u22c6 (second word, first character). Obviously there are \u201choles\u201d in the array, they are simply ignored."}, {"heading": "6.1.3 The Signature", "text": "The array is encoded by two indexed propositions: car(w, \u03bd, \u03bb) and t(w, \u03bd) (t stands for \u201ctail\u201d) where w \u2208 {a, b}, 1 \u2264 \u03bd \u2264 \u03ba, 1 \u2264 \u03bb \u2264 |w\u03bd |. The intuition behind car(w, \u03bd, \u03bb)l is that it holds iff the index l in the array corresponding to w\u2206 contains the pair (\u03bd, \u03bb) (representing the character w\u03bb\u03bd ). t(w, \u03bd)l states that the index l of the array corresponding to w\u2206 contains \u03bd."}, {"heading": "6.1.4 Formal Definition of the Encoding", "text": "Let n be a variable (intended to denote the unique parameter of the schema). As explained in the previous section, we store the characters in an array, at the indices \u00b5, 2\u00b5, 4\u00b5, etc. Intuitively, \u00b5 should be encoded as another parameter, but only one parameter n is allowed. However, we can encode \u00b5 with a new proposition symbol in P. We first define two symbols p, q s.t. p\u03bd holds iff \u03bd = \u00b5 and s.t. q\u03bd holds iff \u03bd \u2208 [0, \u00b5 \u2212 1]. The first schema defines q in such a way that it holds exactly on an interval of the form [0, \u00b5\u2212 1]:\nq0 \u2227 \u00acqn \u2227 n\u2227\ni=1\n(qi+1 \u21d2 qi)\nThe last formula obviously implies that if q\u03bd holds for some \u03bd \u2208 [1..n] then it must also hold for every \u03bb \u2208 [1..\u03bd]. Then \u00b5 is simply the first index \u03bd such that q\u03bd does not hold (this element necessarily exists, since qn does not hold).\nThe second schema defines p such that it holds exactly on the successor of the maximal element of the interval (i.e. \u00b5). Notice that due to the previous formula we must have \u00b5 \u0338= 0 and \u00b5 \u2264 n:\nn\u2227 i=1 [pi \u21d4 (qi\u22121 \u2227 \u00acqi)]\nFor the sake of clarity, we shall denote by (\u03bb = \u00b5) the atom p\u03bb and by (\u03bb < \u00b5) the atom q\u03bb (this makes the formulae much more readable).\nWe then define a variable wt s.t. wt\u03bd holds iff there exists \u03bb \u2208 N s.t. \u03bd = \u00b5.2\u03bb: wt stands for \u201cwitness\u201d, because wt\u03bd holds iff \u03bd is the index of a character in the witness of a solution, as explained before:\n\u2227n i=1[((i = \u00b5) \u21d2 wti) \u2227 ((i < \u00b5) \u21d2 \u00acwti) (1)\n\u2227(\u00ac(2i+ 1 = \u00b5) \u21d2 \u00acwt2i+1) \u2227 (\u00ac(2i < \u00b5) \u2227 \u00ac(2i = \u00b5)) \u21d2 (wti \u21d4 wt2i)]\nThe first line states that wt\u00b5 holds and that wti is false if i < \u00b5. The second line defines that value of wti for i > \u00b5: wt2i+1 is always false (except if 2i+1 = \u00b5) and wt2i is equivalent to wti if 2i > \u00b5. By an easy induction on the set of natural numbers, these properties imply that wt\u03bd holds iff \u2203\u03bb.\u03bd = \u00b5.2\u03bb. Notice the crucial use of the homothetic transformation here.\nThe following formula states that an index cannot represent two distinct characters (pairs) in the same sequence:\nn\u2227 i=1 (\u00accar(w, \u03bd, \u03bb)i \u2228 \u00accar(w, \u03bd \u2032, \u03bb\u2032)i)\nfor every w \u2208 {a, b}, (\u03bd, \u03bd \u2032) \u2208 [1, \u03ba]2, \u03bb \u2208 [1, |w\u03bd |], \u03bb\u2032 \u2208 [1, |w\u03bd\u2032 |] s.t. (\u03bd, \u03bb) \u0338= (\u03bd \u2032, \u03bb\u2032)\nSimilarly, we state that every index contains at most one word in each sequence:\nn\u2227 i=1 (\u00act(w, \u03bd)i \u2228 \u00act(w, \u03bd \u2032)i) for every w \u2208 {a, b}, \u03bd, \u03bd \u2032 \u2208 [1, \u03ba]2, \u03bd \u0338= \u03bd \u2032\nBoth initial elements of the sequences corresponding to a and b must be of the form (\u03bd, 1) (\u03bd is the same in both sequences and is distinct from \u03ba, since the word |w\u03ba| marks the end of the sequence):\nn\u2227 i=1 ((i = \u00b5) \u21d2 \u2203\u03bd \u2208 [1, \u03ba\u2212 1](car(a, \u03bd, 1)i \u2227 car(b, \u03bd, 1)i))\nWe use existential quantification over intervals of natural numbers for the sake of clarity, but these quantifiers can be easily eliminated and transformed into finite (not iterated) disjunctions.\nThe next formula defines e(w) to mark the end of the sequence corresponding to w. e(w)l should hold iff l is of the form \u00b5.2\n\u03bb for some \u03bb > 0 and if the character stored at the index l is the first character of the word \u03ba (remember that by convention a\u03ba = b\u03ba = \u22a4 where \u22a4 marks the end of the witness). Besides, we must ensure that the end of the sequence is eventually reached i.e. that there exists an index l such that e(a)l and e(b)l both hold:\nn\u2228 i=1 (e(a)i \u2227 e(b)i) \u2227 n\u2227 i=1 ((wti \u2227 car(w, \u03ba, 1)i) \u21d4 e(w)i) (\u22c6)\nfor every w \u2208 {a, b}\nWe also have to ensure that the two sequences (i.e. the words a\u2206 and b\u2206) are identical. It suffices to check that for every index l s.t. wtl holds (i.e. for every index l of the form \u00b5\u00d7 2\u03bb), the character stored in l is the same in the sequences of a and b:\nn\u2227 i=1 (wti \u21d2 (\u00accar(a, \u03bd, \u03bb)i \u2228 \u00accar(b, \u03bd \u2032, \u03bb\u2032)i)) (\u22c6)\nfor every \u03bd, \u03bd \u2032 \u2208 [1, \u03ba]2, \u03bb \u2208 [1, |a\u03bd |], \u03bb\u2032 \u2208 [1, |b\u03bd\u2032 |] s.t. a\u03bb\u03bd \u0338= b\u03bb \u2032 \u03bd\u2032\nSo far, we have ensured that at most one character and word index can be stored in every index. We have defined the starting point and the end of the two sequences and ensured that the two represented words are identical. The next (and most difficult) step is to ensure that these sequences really encode two words of the form a\u2206 and b\u2206 respectively. To this aim, we shall relate the value of the character stored in every index \u00b5.2\u03bb+1 to the one stored in \u00b5.2\u03bb, to ensure that the former is really the successor of the latter in the witness. Since each character c is represented by a pair (\u03bd, \u03b9) where \u03bd denotes the index of a word in w and \u03b9 is the position of c in w\u03bd , it is easy to find the next character: if \u03b9 < |w\u03bd | (i.e. if c is not the last character in w\u03bd) then the next character is simply (\u03bd, \u03b9 + 1) (same word w\u03bd , next position \u03b9+1). If \u03b9 = |w\u03bd | (i.e. if c is the last character in w\u03bd) then the next character is (\u03bd \u2032, 1) where \u03bd \u2032 denotes the next word index in the solution sequence (word w\u03bd\u2032 , first position).\nIn order to determine the index word \u03bd \u2032 we use the fact that (as explained in the informal overview above) the remaining indices in the solution are stored in the index \u00b5.2\u03bb + 1, \u00b5.2\u03bb + 2, . . .. Thus, we simply need to pick up the first element of this sequence.\nAfter checking that the character stored at \u00b5.2\u03bb+1 is the successor of the one in \u00b5.2\u03bb it remains to ensure that the indices stored at \u00b5.2\u03bb+1 + 1, \u00b5.2\u03bb+1 + 2,. . . correspond to the remaining part of the solution. If \u03b9 < |w\u03bd | then the sequence must actually be identical to the one stored at \u00b5.2\u03bb + 1, \u00b5.2\u03bb + 2,. . . If \u03b9 = |w\u03bd | then the first element of the sequence must be deleted (since we have entered into a new word).\nThe next formula states that if an index l of the form \u00b5.2\u03bb (i.e. an index s.t. wtl holds) contains a pair (\u03bd, \u03b9) and if w\u03bd contains more that \u03b9 characters then \u00b5.2\n\u03bb+1 should encode the next character in the word w\u03bd , namely (\u03bd, \u03b9+1). Moreover the tail of the sequence does not change, which is expressed using the variable c(w)l (c stands for \u201ccopy\u201d) that will be specified thereafter:\nn\u2227 i=1 [(wti \u2227 car(w, \u03bd, \u03bb)i) \u21d2 (car(w, \u03bd, \u03bb+ 1)2i \u2227 c(w)i+1)] (2)\nfor every w \u2208 {a, b}, \u03bd \u2208 [1, \u03ba], \u03bb \u2208 [1, |w\u03bd | \u2212 1].\nNow we define the formula encoding the copy of the tail. The most simple way to proceed would be to copy the values stored into the indices l, l+1, . . . , l+\u00b5\u22121 into 2l+1, . . . , 2l+\u00b5\u22121. Unfortunately this cannot be done in this simple way because expressions of the form l+ j\nwould be required in the indices, which is forbidden in our class (only \u00b11 can be added). As explained before, we overcome this problem by copying the indices l + 1, . . . , l + \u00b5 \u2212 1 into 2l + 2, 2l + 4, . . . , 2l + 2\u00b5 \u2212 2, which can be done by doubling the iteration counter. The indices 2l+1, 2l+3, . . . , 2l+2\u00b5\u2212 1 are left empty (holes). This is not disturbing since such empty indices will simply be ignored. An important consequence is that the length of the sequence is doubled each time it is copied (we assume that the value of the parameter n and the natural number \u00b5 are sufficiently large to ensure that there is enough \u201cspace\u201d in the array).\nThis is expressed by the following formula:\nn\u2227 i=1 (c(w)i \u21d2 [\u00act(w, \u03bd)2i\u22121 \u2227 (t(w, \u03bd)i \u21d4 t(w, \u03bd)2i) \u2227 (\u00acwti+1 \u21d2 c(w)i+1)]) (3)\nfor every \u03bd \u2208 [1, \u03ba], w \u2208 {a, b} We illustrate this construction by an example. Let A = {\u2217, \u25e6, \u22c6, \u22c4}, a = (\u2217\u25e6, \u22c6, \u22c4\u25e6) and \u2206 = (1, 2, 3). In the second line, we provide for every index l the pair (\u03bd, \u03b9) such that car(a, \u03bd, \u03b9)l holds (if any). The third line gives the represented character (\u2217,\u25e6,\u22c6 or \u22c4). In the fourth line we provide the integer \u03bd such that t(a, \u03bd)l holds. The fifth line gives the value of c(a). The indices between \u00b5+ 2 and 2\u00b5 are empty (we assume that \u00b5 = 3).\ni \u00b5 \u00b5+ 1 \u00b5+ 2 2\u00b5 2\u00b5+ 1 2\u00b5+ 2 2\u00b5+ 3 2\u00b5+ 4 car (1, 1) (1, 2) character \u2217 \u25e6 t 2 3 2 3 c(a) T T\nBy formula (2) we must have c\u00b5+1. By formula (3), the value of c(a)\u00b5+1 is propagated to c(a)\u00b5+2,. . . , c(a)2\u00b5\u22121 (it is not propagated to c(a)2\u00b5 since wt2\u00b5 holds). Still by (2), if c(a)l holds then we have t(a, \u03bd)l \u21d4 t(a, \u03bd)2l, and the cells corresponding to odd indices are left empty. Thus we get the array above.\nIf an index \u00b5.2\u03bb contains a pair (\u03bd, \u03b9) where |w\u03bd | = \u03b9 (such as 2\u00b5 in the previous example), then one must proceed to the next word. To this aim, we need to know what is the first character of the next word (after the current one). Because of the holes introduced by the special copying mechanism, the next word is not necessarily at index l+1. A simple solution is to change the contents of the tail so that each element contains not only the index of a word but also its first character. This is stated by the following formula:\nn\u2227 i=1 [\u00acwti \u21d2 (t(w, \u03bd)i \u21d2 car(w, \u03bd, 1)i)] (4)\nFurthermore, we copy this character into all the holes preceding the element. As a particular case we get what we wanted for the first non-empty word.10 This is stated by\n10. Notice that we could have as well copied the word\u2019s index instead of its first character, since the index contains all the information we need to retrieve the corresponding character. However it will be useful in the following to know that there is no word index stored in a particular cell, so we store only the information that is useful for the problem we want to solve at this point, i.e. the first character of the word.\nthe following formula:\nn\u2227 i=1 [(\u00acwti\u22121 \u2227 \u00acwti \u2227 \u2200\u03bb \u2208 [1, \u03ba] \u00act(w, \u03bb)i\u22121) \u21d2 (car(w, \u03bd, 1)i \u21d4 car(w, \u03bd, 1)i\u22121)] (5)\nfor every \u03bd \u2208 [1, \u03ba], w \u2208 {a, b}\nNow, if the pair stored in \u03b9 is (\u03bd, |w\u03bd |) and if this word is not the final word in the sequence (i.e. e(w)\u03b9 does not hold) then one has to store into 2\u03b9 the first character of the next word, which is, due to the two previous formulae, the character represented by \u03b9+ 1. The previous picture must thus be completed as follows:\ni \u00b5 \u00b5+ 1 \u00b5+ 2 2\u00b5 2\u00b5+ 1 2\u00b5+ 2 2\u00b5+ 3 2\u00b5+ 4 car (1, 1) (2, 1) (3, 1) (1, 2) (2, 1) (2, 1) (3, 1) (3, 1) character \u2217 \u22c6 \u22c4 \u25e6 \u22c6 \u22c6 \u22c4 \u22c4 t 2 3 2 3\nBy the formula (4) above, if t(a, \u03bd)i holds then car(a, \u03bd, 1)i also holds. Then by the formula (5), the value of car(a, \u03bd, 1)l is recursively propagated to car(a, \u03bd, 1)l\u22121 until we have l \u2212 1 = \u00b5.2\u03bb or t(a, \u03bd)l\u22121 holds for some \u03bd. Notice that a character is now stored in every index l but only the characters in the indices \u00b5.2\u03bb form the witness.\nThanks to this trick, finding the next character after the one stored in \u00b5.2\u03bb is now trivial: this is simply the one stored in \u00b5.2\u03bb + 1, which, by the previous formula, actually corresponds to the first position of the word stored in (\u00b5+1).2\u03bb (of course, we also need to check that the character is not final). This is expressed by the following formula:\nn\u2227 l=1 [(wtl \u2227 \u00ace(w)l \u2227 car(w, \u03bd, |w\u03bd |)l) \u21d2 (car(w, \u03bb, 1)2l \u21d4 car(w, \u03bb, 1)l+1) \u2227 s(w)l+1]\nfor every \u03bd, \u03bb \u2208 [1, \u03ba], w \u2208 {a, b}\nThe propositional variable s(w)l+1 (s stands for \u201cshift\u201d) indicates that the tail at 2l is obtained by removing the first word in the tail at l. This is done as follows: the indices 2l + 2, . . . , 2l + 2\u00b5 \u2212 1 are obtained by copying the indices l + 1, . . . , l + \u00b5 \u2212 1, except the first one, that is left empty. As for c(w), the indices 2l\u2212 1, . . . , 2l+ 2\u00b5\u2212 3 are empty. s(w) is defined by the three following formulae.\ns(w) actually erases everything until it finds a non-empty index, which is expressed by the first formula: if s(w)l holds then the indices stored at 2l and 2l \u2212 1 must be empty (furthermore, we also check that the end of the tail has not been reached):\nn\u2227 l=1 (s(w)l \u21d2 \u00acwtl \u2227 \u00act(w, \u03bd)2l \u2227 \u00act(w, \u03bd)2l\u22121) for every \u03bd \u2208 [1, \u03ba], w \u2208 {a, b} (6)\nThe second one propagates the erasure if the current index is empty:\nn\u2227 l=1 [(s(w)l \u2227 \u00acwtl+1 \u2227 \u2200\u03bd \u2208 [1, \u03ba] \u00act(w, \u03bd)l) \u21d2 s(w)l+1] for every w \u2208 {a, b} (7)\nThe third one states that once we have reached a non-empty index then we go on by copying everything (which is done by using the previous variable c(w)):\nn\u2227 l=1 (s(w)l \u2227 \u2203\u03bb \u2208 [1, \u03ba] t(w, \u03bb)l \u21d2 c(w)l+1) for every w \u2208 {a, b} (8)\nWe illustrate this construction by showing how the erasure works on the previous example:\ni 2\u00b5 2\u00b5+ 1 2\u00b5+ 2 2\u00b5+ 3 2\u00b5+ 4 car (1, 2) (2, 1) (2, 1) (3, 1) (3, 1) character \u25e6 \u22c6 \u22c6 \u22c4 \u22c4 t 2 3 c(a) T T s(a) T T\ni 4\u00b5 4\u00b5+ 1 4\u00b5+ 2 4\u00b5+ 3 4\u00b5+ 4 4\u00b5+ 5 4\u00b5+ 6 4\u00b5+ 7 4\u00b5+ 8 car (2, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3,1) character \u22c6 \u22c4 \u22c4 \u22c4 \u22c4 \u22c4 \u22c4 \u22c4 \u22c4 t 3\nThe character stored in 2\u00b5 is the last one of the first word thus we have to remove the first word in the tail of the solution. As explained before, the character stored in 4\u00b5 is the same as the one stored in 2\u00b5+1, namely (2, 1), i.e. \u22c6 (since we have car(a, \u03bd, 1)4\u00b5 \u21d4 car(a, \u03bd, 1)2\u00b5+1). Furthermore, s(a)2\u00b5+1 holds. This implies by (6) that the indices 4\u00b5 + 2 and 4\u00b5 + 1 of t must be empty. Since t is empty for \u03b9 = 2\u00b5 + 1 (i.e. there is no \u03bd such that t(a, \u03bd)2\u00b5+1 holds), the value of s(a)2\u00b5+1 is propagated to s(a)2\u00b5+2, by (7). Thus by (6), the indices 4\u00b5 + 4 and 4\u00b5 + 3 of t must also be empty. This time, however, t(a, 2)2\u00b5+2 holds. Thus the value of s(a) is not propagated and c(a)2\u00b5+3 must hold (by (8)). As before, this implies that the remaining part of the sequence (i.e. the cells 2\u00b5+ 3, 2\u00b5+ 4 of t) is copied (in the cells 4\u00b5+6, 4\u00b5+8, leaving the cells 4\u00b5+5, 4\u00b5+7 empty) until 4\u00b5 is reached. This implies in particular that t(a, 3)4\u00b5+8 holds (since t(a, 3)2\u00b5+4 holds). Hence we have car(a, 3, 1)4\u00b5+8. Since t is empty for l \u2208 [4\u00b5 + 1, . . . , 4\u00b5 + 7], this value of car(a, 3, 1) is propagated to the indices 4\u00b5 + 7, . . . , 4\u00b5 + 1 as explained before. We obtain the desired result, i.e. the first word in the sequence (namely 2) have been erased and the first character of the next word is stored into 4\u00b5+ 1.\nFinally, in order to ensure that the obtained sequence is really a solution to the Post correspondence problem, it only remains to check that the two sequences are identical, i.e. that the words contained in \u00b5+ 1, \u00b7 \u00b7 \u00b7 , 2\u00b5\u2212 1 are the same for both sequences a and b. To this purpose we define a variable rl that is true iff l < 2\u00b5.\nr0 \u2227 \u00acrn \u2227 n\u2227\nl=1\n[(rl \u21d2 rl\u22121) \u2227 (l = \u00b5) \u21d2 (r2l\u22121 \u2227 \u00acr2l)] (\u22c6)\nn\u2227 l=1 [(rl \u2227 \u00ac(l < \u00b5)) \u21d2 (t(a, \u03bd)l \u21d4 t(b, \u03bd)l)] (\u22c6)\nfor every \u03bd \u2208 [1, \u03ba]\nIt is straightforward to check that the obtained formula is in Ch. The reader acquainted with Post\u2019s correspondence problem shall now be convinced that the obtained formula is satisfiable iff there exists a solution to the above Post problem, and can thus skip the end of this section. Otherwise we give in the following a sketch of the formal steps to this proof.\nWe denote by \u03d5 the conjunction of the above formulae, except the formulae marked (\u22c6). We first notice that \u03d5 is satisfiable (for every value of n). Indeed, as explained before, the formulae above impose that:\n\u2022 There exists a unique natural number \u00b5 such that p\u03bd holds iff \u03bd = \u00b5 and q\u03bd holds iff \u03bd \u2208 [0, \u00b5\u2212 1].\n\u2022 car(w, \u03bd, \u03bb) and t(w, \u03bd) encode (partial) functions fw, gw mapping every index in [1, n] to a pair (\u03bd, \u03bb) (where \u03bd \u2208 [1, \u03ba], \u03bb \u2208 [1, |w\u03bd |]) and to a word index in [1, \u03ba] respectively. Moreover we must have fa(\u00b5) = (\u03bd, 1) and fb(\u00b5) = (\u03bd, 1) for some \u03bd \u2208 [1..\u03ba\u2212 1].\n\u2022 wt\u03bd holds iff there exists \u03bb \u2208 N s.t. \u03bd = \u00b5.2\u03bb.\nThis obviously defines a partial interpretation. Then the remaining formulae in \u03d5 simply give the values of car(w, \u03bd, \u03bb)\u03b9, t(w, \u03bd)\u03b9, c(w)\u03b9, s(w)\u03b9 for \u03b9 \u2265 2\u00b5. It is easy to check that distinct formulae cannot give distinct values to the same propositional variable, hence satisfiability is guaranteed.\nLet I be an interpretation of \u03d5. Let \u03b9 \u2208 [1..n]. We define the following sequences.\n\u2022 hw(\u03b9) is a sequence of word indices defined as follows: If wt\u03b9+1 holds then hw(\u03b9) is empty. Otherwise, if gw(\u03b9) = \u03bd then hw(\u03b9) def = \u03bd.hw(\u03b9 + 1) and if gw(\u03b9) is undefined\nthen hw(\u03b9) def = hw(\u03b9+1). Intuitively, hw(\u03b9) is the sequence of word indices stored juste after \u03b9 (i.e. the tail) ignoring empty cells.\n\u2022 jw(\u03b9) is a word defined as follows: if \u03b9 > n then jw(\u03b9) is empty. Otherwise, jw(\u03b9) def =\nw\u03bb\u03bd .jw(2\u03b9) if fw(\u03b9) is a pair (\u03bd, \u03bb) distinct from (\u03ba, 1), jw(\u03b9) def = \u22a4 if fw(\u03b9) = (\u03ba, 1) and jw(\u03b9) def = jw(2\u03b9) if fw(\u03b9) is undefined. jw(\u03b9) denotes the word stored at the cells \u03b9, 2\u03b9 . . . in the array corresponding to w ((\u03ba, 1) marks the end of the word).\n\u2022 If fw(\u03b9) = (\u03bd, \u03bd \u2032) then kw(\u03b9) denotes the suffix of length |w\u03bd | \u2212 \u03bd \u2032 + 1 of the word w\u03bd (notice that by construction we must have \u03bd \u2032 \u2264 |\u03bd|).\nBy definition of the copying/erasing mechanism above, if fw(\u00b5.2 \u03bb) is of the form (\u03bd, |w\u03bd |)\n(i.e. we are at the end of the word \u03bd) then hw(\u00b5.2 \u03bb) = \u03bd \u2032.hw(\u00b5.2 \u03bb+1), where fw(\u00b5.2 \u03bb+1) =\n(\u03bd \u2032, 1) (i.e. the tail is equal to the next word followed by the next tail). Otherwise (i.e. if we are in the middle of a word) we have hw(\u00b5.2 \u03bb) = hw(\u00b5.2 \u03bb+1) and fw(\u00b5.2\n\u03bb+1) = (\u03bd, \u03bd \u2032 + 1) where fw(\u00b5.2\n\u03bb) = (\u03bd, \u03bd \u2032) (\u03bd \u2032 \u0338= |w\u03bd |)). By an easy induction on the length of jw(\u00b5.2\u03bb), we deduce that jw(\u00b5.2 \u03bb) is a prefix of kw(\u00b5.2 \u03bb).whw(\u00b5.2\u03bb): kw(\u00b5.2\n\u03bb) represents the end of the word considered at the character \u03bb, and whw(\u00b5.2\u03bb) is the concatenation of all words in the tail.\nFor \u03bb = 0 we get in particular that jw(\u00b5) is a prefix of kw(\u00b5).whw(\u00b5). But by definition kw(\u00b5) = w\u03bd for some \u03bd (not depending on w). Thus jw(\u00b5) is a prefix of w\u03bd.hw(\u00b5).\nThe formulae occurring in the conjunction but not in \u03d5 check that ha(\u00b5) = hb(\u00b5) (same sequence of word indices for a and b), that ja(\u00b5) = jb(\u00b5) and that ja(\u00b5) ends with a character \u22a4 (marking the end of the witness).\nIf I is a model of the whole formula, then jw(\u00b5) is a prefix of w\u03bd.hw(\u00b5), ending with \u22a4, thus must be of the form w\u03bd.\u2206 where \u2206 is a prefix of hw(\u00b5). Hence \u03bd.\u2206 is a solution to the Post\u2019s correspondence problem.\nConversely, if such a solution \u03bd.\u2206 exists, then we simply consider a model I of \u03d5 such that ha(\u00b5) = hb(\u00b5) = \u2206 (this implies that \u00b5 > |\u2206|, notice that the values of fw(l) and gw(l) can be fixed arbitrarily for l < 2\u00b5) and I(n) > \u00b5.2\u03bb, where \u03bb = |a\u03bd.\u2206|. jw(\u00b5) is a prefix of w\u03bd.hw(\u00b5). Since the length jw(\u00b5) cannot be greater than the one of w\u03bd.\u2206, jw(\u00b5) must end with \u22a4. Thus we must have jw(\u00b5) = w\u03bd.\u2206 (since \u22a4 is the last character in w\u03bd.\u2206). Moreover since \u03bd.\u2206 is a solution we have ja(\u00b5) = jb(\u00b5). Thus I validates all the formulae above."}, {"heading": "6.2 Unbounded Translation", "text": "One can wonder whether the decidability of the class of regular schemata still holds when unbounded translations are allowed in the indices, i.e. translations of the form i+m where i denotes the iteration counter and m a parameter (the case m \u2208 Z is covered by the regular class). The following definition and theorem show that the answer is negative.\nDefinition 6.3 Ct (t stands for \u201ctranslation\u201d) is the set of schemata S satisfying the following properties.\n\u2022 S contains at most two parameters n,m. \u2022 Every iteration in S is of the form \u2227n i=1 \u03d5 or \u2228n i=1 \u03d5, where:\n\u2013 \u03d5 contains no iteration.\n\u2013 Every atomic formula in \u03d5 is of the form p\u03b1.i+\u03b2+\u03b3.m, where p is a variable, \u03b1, \u03b3 \u2208 {0, 1} and \u03b2 \u2208 {\u22121, 0, 1}.\n\u2022 The atomic propositions occurring in \u03d5 but not in the scope of an iteration are of the form p0 or pn where p is a variable.\nTheorem 6.4 The set of unsatisfiable formulae in Ct is not recursively enumerable."}, {"heading": "Proof", "text": "(Sketch) We do not detail the proof since it is very similar to the previous one. We reuse the same encoding as in the proof of Theorem 6.2, except that the pairs (\u03bd, \u03bb) in the array\nare stored in indices of the form \u00b5+m\u00d7 \u03b9 instead of \u00b5.2\u03b9. Formally, the formulae (1), (2), (3) and (6) are replaced by the following ones, respectively:\nn\u2227 l=1 [((l = \u00b5) \u21d2 wtl) \u2227 ((l < \u00b5) \u21d2 \u00acwtl) \u2227 (\u00ac(l < \u00b5) \u2227 \u00ac(l = \u00b5)) \u21d2 (wtl \u21d4 wtl+m)]\n(i.e. wtl holds now iff there exists \u03b9 s.t. l = \u00b5+m\u03b9).\nn\u2227 l=1 [wtl \u2227 car(w, \u03bd, \u03bb)l \u21d2 (car(w, \u03bd, \u03bb+ 1)l+m \u2227 c(w)l+1)]\n(i.e. the index 2l is now replaced by l +m).\nn\u2227 l=1 (c(w)l \u21d2 [(t(w, \u03bd)l \u21d4 t(w, \u03bd)l+m) \u2227 (\u00acwti+1 \u21d2 c(w)l+1)])\nn\u2227 l=1 (s(w)l \u21d2 \u00acwtl \u2227 \u00act(w, \u03bd)l+m)"}, {"heading": "7. Conclusion", "text": "We introduced the first (to the best of our knowledge) logic for reasoning with iterated propositional schemata. We defined a class of schemata called bound-linear for which the satisfiability problem is decidable. The decidability proof is constructive and divided into two parts: first we show how to transform every bound-linear schema into a sat-equivalent schema of a simpler form, called regular. Then a proof procedure is defined to decide the satisfiability of regular schemata. This proof procedure is sound and complete w.r.t. satisfiability for every schema (even if it is not regular or not bound-linear) and terminates on every regular schema. Termination relies on a special looping detection rule. This procedure has been implemented in the software RegStab.\nThe class of bound-linear schemata is expressive enough to capture specifications of many important problems in AI, especially in automated (or interactive) theorem proving (e.g., parameterized circuit verification problems). We proved that even a very slight relaxation of the conditions on bound-linear schemata makes the satisfiability problem undecidable (this is shown by a tricky reduction to the Post correspondence problem). As a consequence, bound-linear schemata can be considered as a \u201ccanonical\u201d decidable class, providing a good compromise between expressivity and tractability.\nAs for future work, two ways are the most promising. Firstly, the extension of the previous results to particular classes of non-monadic schemata (i.e. schemata containing symbols with several indices, e.g., \u2228n i=1 \u2227n j=1 pi,j) would enlarge considerably applications of propositional schemata. Secondly, extending our approach to more expressive logics,\nsuch as first-order logic, description logics or modal logics, also deserves to be considered. The presented results should extend straightforwardly to many-valued propositional logic (provided the number of truth values is fixed and finite). This would allow to capture infinite constraint satisfaction languages."}, {"heading": "Acknowledgments", "text": "This work has been partly funded by the project ASAP of the French Agence Nationale de la Recherche (ANR-09-BLAN-0407-01). The authors wish to thank the anonymous referees for their insightful comments which helped improve an earlier version of this paper."}], "references": [{"title": "An Introduction to Inductive Definitions", "author": ["P. Aczel"], "venue": "Barwise, K. J. (Ed.), Handbook of Mathematical Logic, pp. 739\u2013782. North-Holland, Amsterdam.", "citeRegEx": "Aczel,? 1977", "shortCiteRegEx": "Aczel", "year": 1977}, {"title": "A DPLL proof procedure for propositional iterated schemata. In Workshop \u201cStructures and Deduction 2009", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": null, "citeRegEx": "Aravantinos et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2009}, {"title": "A schemata calculus for propositional logic", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "In TABLEAUX 09 (International Conference on Automated Reasoning with Analytic Tableaux and Related Methods),", "citeRegEx": "Aravantinos et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2009}, {"title": "A Decidable Class of Nested Iterated Schemata", "author": ["V. Aravantinos", "R. Caferra", "N. Peltier"], "venue": "In IJCAR 2010 (International Joint Conference on Automated Reasoning),", "citeRegEx": "Aravantinos et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Aravantinos et al\\.", "year": 2010}, {"title": "Note on the generalization of calculations", "author": ["M. Baaz"], "venue": "Theoretical Computer Science, 224, 3\u201311.", "citeRegEx": "Baaz,? 1999", "shortCiteRegEx": "Baaz", "year": 1999}, {"title": "Short proofs of tautologies using the schema of equivalence", "author": ["M. Baaz", "R. Zach"], "venue": "In Computer Science Logic (CSL\u201993),", "citeRegEx": "Baaz and Zach,? \\Q1994\\E", "shortCiteRegEx": "Baaz and Zach", "year": 1994}, {"title": "The challenge of computer mathematics", "author": ["H. Barendregt", "F. Wiedijk"], "venue": "Philosophical Transactions of the Royal Society A,", "citeRegEx": "Barendregt and Wiedijk,? \\Q2005\\E", "shortCiteRegEx": "Barendregt and Wiedijk", "year": 2005}, {"title": "SPIKE, an automatic theorem prover", "author": ["A. Bouhoula", "E. Kounalis", "M. Rusinowitch"], "venue": "In Proceedings of the International Conference on Logic Programming and Automated Reasoning (LPAR\u201992),", "citeRegEx": "Bouhoula et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Bouhoula et al\\.", "year": 1992}, {"title": "A computational logic", "author": ["R.S. Boyer", "J.S. Moore"], "venue": null, "citeRegEx": "Boyer and Moore,? \\Q1979\\E", "shortCiteRegEx": "Boyer and Moore", "year": 1979}, {"title": "Local model checking for infinite state spaces", "author": ["J. Bradfield", "C. Stirling"], "venue": "In Selected papers of the Second Workshop on Concurrency and compositionality,", "citeRegEx": "Bradfield and Stirling,? \\Q1992\\E", "shortCiteRegEx": "Bradfield and Stirling", "year": 1992}, {"title": "Modal Mu-Calculi", "author": ["J. Bradfield", "C. Stirling"], "venue": null, "citeRegEx": "Bradfield and Stirling,? \\Q2007\\E", "shortCiteRegEx": "Bradfield and Stirling", "year": 2007}, {"title": "Cyclic Proofs for First-Order Logic with Inductive Definitions", "author": ["J. Brotherston"], "venue": "Beckert, B. (Ed.), Automated Reasoning with Analytic Tableaux and Related Methods: Proceedings of TABLEAUX 2005, Vol. 3702 of LNAI, pp. 78\u201392. Springer-Verlag.", "citeRegEx": "Brotherston,? 2005", "shortCiteRegEx": "Brotherston", "year": 2005}, {"title": "The automation of proof by mathematical induction", "author": ["A. Bundy"], "venue": "Robinson, J. A., & Voronkov, A. (Eds.), Handbook of Automated Reasoning, pp. 845\u2013911. Elsevier and MIT Press.", "citeRegEx": "Bundy,? 2001", "shortCiteRegEx": "Bundy", "year": 2001}, {"title": "The Oyster-Clam system", "author": ["A. Bundy", "F. van Harmelen", "C. Horn", "A. Smaill"], "venue": "In Proceedings of the 10th International Conference on Automated Deduction,", "citeRegEx": "Bundy et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Bundy et al\\.", "year": 1990}, {"title": "On finite representations of infinite sequences of terms", "author": ["H. Chen", "J. Hsiang", "H. Kong"], "venue": "In Conditional and Typed Rewriting Systems, 2nd International Workshop,", "citeRegEx": "Chen et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Chen et al\\.", "year": 1990}, {"title": "Tableau-based model checking in the propositional mu-calculus", "author": ["R. Cleaveland"], "venue": "Acta Inf., 27 (9), 725\u2013747.", "citeRegEx": "Cleaveland,? 1990", "shortCiteRegEx": "Cleaveland", "year": 1990}, {"title": "Inductionless induction", "author": ["H. Comon"], "venue": "Robinson, A., & Voronkov, A. (Eds.), Handbook of Automated Reasoning, chap. 14, pp. 913\u2013962. North-Holland.", "citeRegEx": "Comon,? 2001", "shortCiteRegEx": "Comon", "year": 2001}, {"title": "On unification of terms with integer exponents", "author": ["H. Comon"], "venue": "Mathematical System Theory, 28, 67\u201388.", "citeRegEx": "Comon,? 1995", "shortCiteRegEx": "Comon", "year": 1995}, {"title": "Theorem proving in arithmetic without multiplication", "author": ["D. Cooper"], "venue": "Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 7, chap. 5, pp. 91\u201399. Edinburgh University Press.", "citeRegEx": "Cooper,? 1972", "shortCiteRegEx": "Cooper", "year": 1972}, {"title": "A Machine Program for Theorem Proving", "author": ["M. Davis", "G. Logemann", "D. Loveland"], "venue": "Communication of the ACM,", "citeRegEx": "Davis et al\\.,? \\Q1962\\E", "shortCiteRegEx": "Davis et al\\.", "year": 1962}, {"title": "Finite-Model Theory - A Personal Perspective", "author": ["R. Fagin"], "venue": "Theoretical Computer Science, 116, 3\u201331.", "citeRegEx": "Fagin,? 1993", "shortCiteRegEx": "Fagin", "year": 1993}, {"title": "Decidable classes of inductive theorems", "author": ["J. Giesl", "D. Kapur"], "venue": "IJCAR, Vol. 2083 of Lecture Notes in Computer Science,", "citeRegEx": "Giesl and Kapur,? \\Q2001\\E", "shortCiteRegEx": "Giesl and Kapur", "year": 2001}, {"title": "Chapter 6: Tableau Methods for Modal and Temporal Logics", "author": ["R. Gor\u00e9"], "venue": "M D\u2019Agostino, D Gabbay, R H\u00e4hnle, J Posegga (Ed.), Handbook of Tableau Methods, pp. 297\u2013396. Kluwer Academic Publishers. http://arp.anu.edu.au/~ rpg (draft).", "citeRegEx": "Gor\u00e9,? 1999", "shortCiteRegEx": "Gor\u00e9", "year": 1999}, {"title": "Representation and symbolic manipulation of linearly inductive boolean functions", "author": ["A. Gupta", "A.L. Fisher"], "venue": "IEEE Computer Society", "citeRegEx": "Gupta and Fisher,? \\Q1993\\E", "shortCiteRegEx": "Gupta and Fisher", "year": 1993}, {"title": "Unification of Infinite Sets of Terms schematized by Primal Grammars", "author": ["M. Hermann", "R. Galbav\u00fd"], "venue": "Theoretical Computer Science,", "citeRegEx": "Hermann and Galbav\u00fd,? \\Q1997\\E", "shortCiteRegEx": "Hermann and Galbav\u00fd", "year": 1997}, {"title": "Proof analysis with HLK, CERES and ProofTool: Current status and future directions", "author": ["S. Hetzl", "A. Leitsch", "D. Weller", "B. Woltzenlogel Paleo"], "venue": "Workshop on Empirically Successful Automated Reasoning for Mathematics (ESARM),", "citeRegEx": "Hetzl et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Hetzl et al\\.", "year": 2008}, {"title": "Relational queries computable in polynomial time (Extended Abstract)", "author": ["N. Immerman"], "venue": "STOC \u201982: Proceedings of the fourteenth annual ACM symposium on Theory of computing, pp. 147\u2013152, New York, NY, USA. ACM.", "citeRegEx": "Immerman,? 1982", "shortCiteRegEx": "Immerman", "year": 1982}, {"title": "The number of proof lines and the size of proofs in first-order logic", "author": ["J. Krajicek", "P. Pudlak"], "venue": "Archive for Mathematical Logic,", "citeRegEx": "Krajicek and Pudlak,? \\Q1988\\E", "shortCiteRegEx": "Krajicek and Pudlak", "year": 1988}, {"title": "Proof schemata in Hilbert-type axiomatic theories", "author": ["V.P. Orevkov"], "venue": "Journal of Mathematical Sciences, 55 (2), 1610\u20131620.", "citeRegEx": "Orevkov,? 1991", "shortCiteRegEx": "Orevkov", "year": 1991}, {"title": "Some results on the length of proofs", "author": ["R.J. Parikh"], "venue": "Transactions of the American Mathematical Society, 177, 29\u201336.", "citeRegEx": "Parikh,? 1973", "shortCiteRegEx": "Parikh", "year": 1973}, {"title": "Finiteness is Mu-ineffable", "author": ["D.M. Park"], "venue": "Theoretical Computer Science, 3, 173\u2013181.", "citeRegEx": "Park,? 1976", "shortCiteRegEx": "Park", "year": 1976}, {"title": "Inductive Definitions in the system Coq - Rules and Properties", "author": ["C. Paulin-Mohring"], "venue": "TLCA \u201993: Proceedings of the International Conference on Typed Lambda Calculi and Applications, pp. 328\u2013345, London, UK. Springer-Verlag.", "citeRegEx": "Paulin.Mohring,? 1993", "shortCiteRegEx": "Paulin.Mohring", "year": 1993}, {"title": "First-Order Logic", "author": ["R.M. Smullyan"], "venue": "Springer.", "citeRegEx": "Smullyan,? 1968", "shortCiteRegEx": "Smullyan", "year": 1968}, {"title": "On the Structure of Inductive Reasoning: Circular and Tree-shaped Proofs in the mu-Calculus", "author": ["C. Sprenger", "M. Dam"], "venue": "In Proc. FOSSACS\u201903,", "citeRegEx": "Sprenger and Dam,? \\Q2003\\E", "shortCiteRegEx": "Sprenger and Dam", "year": 2003}, {"title": "Automated Reasoning: 33 Basic Research Problems", "author": ["L. Wos"], "venue": "Prentice Hall.", "citeRegEx": "Wos,? 1988", "shortCiteRegEx": "Wos", "year": 1988}, {"title": "Automated Reasoning: Introduction and Applications (Second edition)", "author": ["L. Wos", "R. Overbeek", "E. Lush", "J. Boyle"], "venue": null, "citeRegEx": "Wos et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Wos et al\\.", "year": 1992}], "referenceMentions": [{"referenceID": 29, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).", "startOffset": 223, "endOffset": 289}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).", "startOffset": 223, "endOffset": 289}, {"referenceID": 28, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).", "startOffset": 223, "endOffset": 289}, {"referenceID": 17, "context": "It is worth mentioning that this iteration cannot be denoted by other term schematisation languages (Chen, Hsiang, & Kong, 1990; Comon, 1995) because the inductive context is not constant.", "startOffset": 100, "endOffset": 141}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 305}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 357}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 417}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.", "startOffset": 94, "endOffset": 506}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of \u2018schema\u2019 is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given.", "startOffset": 94, "endOffset": 1152}, {"referenceID": 4, "context": "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of \u2018proof skeleton\u2019, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of \u2018schema\u2019 is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given. The authors overview the state of the art (by describing and comparing most powerful existing systems in use) but structuring proofs is not explicitly mentioned (maybe this feature can be included in what they call \u201cmathematical style\u201d or \u201csupport reasoning with gaps\u201d). In our approach to schemata it is clear that they are a way of structuring proofs and can also help to overcome one of the obstacles to the automation of reasoning pointed out by Wos (1988), i.", "startOffset": 94, "endOffset": 1692}, {"referenceID": 16, "context": "Several procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001).", "startOffset": 70, "endOffset": 201}, {"referenceID": 12, "context": "Several procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001).", "startOffset": 70, "endOffset": 201}, {"referenceID": 16, "context": "In particular, schemata may have several models, thus implicit induction (Comon, 2001) (which explicitly requires that the underlying Herbrand model is unique) cannot be (directly) used.", "startOffset": 73, "endOffset": 86}, {"referenceID": 26, "context": "Actually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables.", "startOffset": 77, "endOffset": 93}, {"referenceID": 20, "context": "Actually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables.", "startOffset": 126, "endOffset": 164}, {"referenceID": 30, "context": "In contrast with propositional \u03bccalculus, first-order \u03bc-calculus (Park, 1976) clearly embeds iterated schemata (allowing for instance the above fixed-point expression of \u2227n i=1 pi), but no published research seems to be focused on the identification of complete subclasses.", "startOffset": 65, "endOffset": 77}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers.", "startOffset": 81, "endOffset": 94}, {"referenceID": 31, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers.", "startOffset": 142, "endOffset": 164}, {"referenceID": 22, "context": ", in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992).", "startOffset": 69, "endOffset": 81}, {"referenceID": 15, "context": ", in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992).", "startOffset": 96, "endOffset": 142}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it.", "startOffset": 82, "endOffset": 338}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it. As we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction.", "startOffset": 82, "endOffset": 1170}, {"referenceID": 0, "context": "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it. As we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Gor\u00e9, 1999), or \u03bc-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction.", "startOffset": 82, "endOffset": 1199}, {"referenceID": 32, "context": "This is done by providing a set of block tableaux rules (Smullyan, 1968) that are complete w.", "startOffset": 56, "endOffset": 72}, {"referenceID": 18, "context": "This can be detected using decision procedures for arithmetic without multiplication (Cooper, 1972).", "startOffset": 85, "endOffset": 99}, {"referenceID": 11, "context": "In existing work on cyclic proofs, N \u2032 is sometimes called a bud node and N is the companion node of N \u2032 (Brotherston, 2005).", "startOffset": 105, "endOffset": 124}], "year": 2011, "abstractText": "We define a logic of propositional formula schemata adding to the syntax of propositional logic indexed propositions (e.g., pi) and iterated connectives \u2228 or \u2227 ranging over intervals parameterized by arithmetic variables (e.g., \u2227n i=1 pi, where n is a parameter). The satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called bound-linear, for which this problem becomes decidable. This result is obtained by reduction to a particular class of schemata called regular, for which we provide a sound and complete terminating proof procedure. This schemata calculus (called stab) allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. We also show that the satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound-linear schemata represent a good compromise between expressivity and decidability.", "creator": " TeX output 2011.03.21:1228"}}}