{"id": "1401.5848", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jan-2014", "title": "Algorithms and Limits for Compact Plan Representations", "abstract": "compact representations of objects ) is a common concept in computer science. automated tactical planning can be viewed as a case instance of examining this concept : either a planning instance is a compact implicit representation of a graph and the problem is to find a path ( a plan ) in this graph. theoretically while the graphs themselves are represented compactly as planning instances, the paths chosen are usually represented explicitly as sequences of actions. some cases are specifically known where the plans always have compact representations, explicitly for example, using macros. we show that these results don't significantly extend dramatically to tackle the general case, by proving a number of bounds for compact representations of plans under various criteria, serving like efficient sequential or systematic random access of actions. in addition to this, we show that precisely our results have consequences for what can be gained from reformulating dynamic planning into some other problem. as a contrast to this we also prove a number of positive results, demonstrating restricted cases precisely where explicit plans do have useful compact function representations, as well as proving that macro plans have favourable access properties. our results are finally discussed in relation to other particular relevant contexts.", "histories": [["v1", "Thu, 23 Jan 2014 02:41:51 GMT  (323kb)", "http://arxiv.org/abs/1401.5848v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["christer b\\\"ackstr\\\"om", "peter jonsson"], "accepted": false, "id": "1401.5848"}, "pdf": {"name": "1401.5848.pdf", "metadata": {"source": "CRF", "title": "Algorithms and Limits for Compact Plan Representations", "authors": ["Christer B\u00e4ckstr\u00f6m", "Peter Jonsson"], "emails": ["christer.backstrom@liu.se", "peter.jonsson@liu.se"], "sections": [{"heading": "1. Introduction", "text": "The usage and study of representations of objects that are much smaller than the objects themselves is commonplace in computer science. Most of us encounter such representations on a daily basis in the form of zipped files, mp3 files etc. For such practical cases, we usually talk about compressed objects, while the terms compact and succinct are more common in theoretical studies. The meaning of the terms vary but a common and interesting case is when the size of the representation is at most polylogarithmic in the size of the object. Sometimes it is sufficient to just compute a compact representation of an object, for instance, when archiving a file. In other cases the representation must also support various operations efficiently without first unpacking the object into an explicit representation. Performing operations on a compact representation is often harder than performing the same operation on an explicit object, but there are cases when a compact representation can make it easier by emphasising some inherent structure in the object.\nOne archetypical case of using compact representations is automated planning, although it is seldom viewed in that way. A planning instance is an implicit representation of a graph that is typically exponentially larger than its representation, the instance, and where the solutions, the plans, are paths in this graph. Consider, for example, a Strips instance with n variables. These variables implicitly define a state space with 2n states and an action with m preconditions define 2n\u2212m arcs in the graph. Similarly, we can define instances where the paths are of exponential length too. Although the planning instances themselves are already\nc\u00a92012 AI Access Foundation. All rights reserved.\ncompact representations, very little attention has been paid to compact representations of the solutions, which are usually represented explicitly. This paper introduces and analyses a number of such compact representations.\nIf we first turn to computer science in general we find that compact representations of arbitrary strings is an intensively studied field. For example, Charikar et al. (2005) and Rytter (2003) address the problem of approximating the smallest string representation using a compressed grammar. Bille et al. (2011) show that such representations permit efficient access and matching operations, while Jansson, Sadakane, and Sung (2012) demonstrate representations with efficient edit operations. More structured objects than arbitrary strings can potentially have more compact representations. The following are some examples, displaying positive as well as negative results in various areas. Both Galperin and Wigderson (1983) and Wagner (1986) study the complexity of common graph operations when the graphs are implicitly represented as circuits that tell whether two vertices are connected. Balca\u0301zar (1996) uses a variant of that approach to study the complexity of search in AI, using a circuit that generates the adjacency list for a vertex. Bulatov and Dalmau (2006) present an efficient algorithm for certain CSP problems that relies on using a compact representation of the set of solutions. Liberatore and Schaerf (2010) study preprocessing in model checking with focus on the size of the preprocessed parts. Cadoli et al. (2000) study various formalisms for knowledge representation and study when problems modelled in one formalism can be transformed into another formalism with at most a polynomially larger representation.\nOne approach to compact representations in various areas is the use of macros. This concept has been widely used for a long time also in planning, although seldom for the purpose of providing compact representations. An exception is the following case. The 3S class (Jonsson & Ba\u0308ckstro\u0308m, 1998b) of planning instances has the property that optimal plans can be of exponential length but it is always possible to decide in polynomial time if there is a plan or not. Gime\u0301nez and Jonsson (2008) showed that plans for the 3S class always have a polynomial-size representation using macros, and that macro plans can even be generated in polynomial time. That is, although the plan may be of exponential length, and thus necessarily take exponential time to generate, it is possible to generate a compact representation of it in polynomial time. Jonsson (2009) later demonstrated similar results for a number of other classes. Although these particular classes of planning instances may still be too restricted to be of much practical use, the principle of compressing the solution using macros is an interesting tool both for planning and plan explanation.\nOther approaches to compact plan representation appear only sparingly in the literature. A notable exception is Liberatore (2005a) who studies two concepts for plan representation that have efficient random access and efficient sequential access respectively. Just like macro plans these are examples of representing one long plan compactly. We might also consider representing a large set of plans compactly. For instance, plan recognition may have to simultaneously consider an exponential number of candidate plans (Geib, 2004). Although seldom viewed in that way, also a reactive plan is a representation of a large set of plans, one for each state from which the goal can be reached. It is, however, known that reactive plans cannot be both compact, efficient and correct in the general case (Jonsson, Haslum, & Ba\u0308ckstro\u0308m, 2000), although these properties are important, for instance, in spaceship applications (Williams & Pandurang Nayak, 1997). Pomdps may similarly be thought of\nas a probabilistic variant of reactive plans and compactness of representations is important also in this case (Boutilier & Poole, 1996). Yet another case is when the size of the plan is big but the plan is not necessarily long, which can occur for various types of branching plans, as in contingent planning (Bonet & Geffner, 2000). These three different concepts are not isolated from each other. For instance, Bonet (2010) casts contingent planning into the problem of conformant planning, that is, a branching plan is represented as one long non-branching plan, with the branches appearing as subplans. In all these cases, it is interesting to know if the objects in question have compact representations. Although a compact representation can save space, this may be secondary in many cases. A more important aspect is that if an object has a compact representation then the object has some inherent structure that we may exploit also for other purposes. For instance, if we represent a set of many plans then a representation using recursive macros, or similar, can emphasize the differences and similarities between the plans. This make both comparisons and other operations on the plans more efficient. Similarly, in the case of branching plans we might want to exploit a structure that clearly displays both what two branches have in common and where they differ.\nThe positive results on macro representations (Gime\u0301nez & Jonsson, 2008; Jonsson, 2009) prompt the obvious question whether long plans can always be compressed using macros (or any other method). We show in this paper that this is unlikely, no matter what type of compact representation we try to use (macro plans, finite automata or whatever). The remainder of the paper is organized as follows. Section 2 introduces basic notation and concepts as well as the planning framework used in the paper, and it also contains some useful definitions for the complexity results. We then first ask, in Section 3, whether all (optimal) plans for an instance can have compact representations. We find that the answer is no; it is not possible, neither by macros nor any other method. However, the results do not exclude that some plans for each instance can have compact solutions. In Section 4 we thus restrict the question to whether there is a uniform compact representation of one plan for each solvable instance. More precisely, we ask if there is an algorithm that corresponds to one compact representation for each solvable instance. We show that such an algorithm is unlikely to exist if it must also be able to access the actions of the plan in some useful way. In Section 5 we turn to the non-uniform case, asking if each solvable instance has at least one plan that has a compact representation. We primarily consider representations that can efficiently access the actions of the plan sequentially or randomly. We show that also this seems unlikely in the general case, but that there are interesting special cases where such representations do exist. In this section we also investigate macro representations and extend the results by Gime\u0301nez and Jonsson in two ways. We prove that all plans that have a polynomial-size macro representation can be random accessed in polynomial time without having access to the full plan. However, we also prove that we cannot always represent plans compactly using macros. In Section 6 we analyse whether we can get around the problem of long plans by reformulating planning to some other problem. Also this is answered negatively. If we actually ask for a plan for the original problem, then the problem is inherently intractable also when using reformulation. However, even if considering only the decision problem it still seems not possible to make planning simpler by reformulation. Finally, Section 7 contains a discussion of how the results in the paper are related to and relevant for various other topics like adding information to guide planners, causal graphs\nand plan explanation. The paper ends with a summary of the results together with a list of open questions.\nSome of the results in this paper have appeared in a previous conference publication (Ba\u0308ckstro\u0308m & Jonsson, 2011b)."}, {"heading": "2. Preliminaries", "text": "This section consists of three parts. The first part introduces some general notation and terminology used in the paper. The second part defines the two planning frameworks used in the paper, Finite Functional Planning and propositional Strips, and presents some constructions that will be frequently used. The third part briefly recapitulates the concept of advice-taking Turing machines and also defines the 3SAT problem that will be used on several occasions in the paper."}, {"heading": "2.1 General Notation and Terminology", "text": "A sequence of objects x1, x2, . . . , xn is written \u3008x1, x2, . . . , xn\u3009, with \u3008\u3009 denoting the empty sequence. Given a set X of objects, the set of all sequences over X, including \u3008\u3009, is denoted X\u2217. For a set, sequence or other aggregation X of objects, we write |X| to denote the cardinality (the number of objects) of x and we write ||X|| to denote the size (the number of bits of the representation) of x. The composition of two functions f and g is denoted f \u25e6 g and is defined as (f \u25e6 g)(x) = f(g(x)).\nThe negation of a propositional atom x is denoted x. A literal is either an atom or its negation and the set L(X) of literals over a set X of atoms is defined as L(X) = {x, x | x \u2208 X}. Negation is extended to literals such that ` is the same literal as `. Negation is also extended to sets such that if X is a set of literals then X = {` | ` \u2208 X}. Let Y be a subset of L(X) for some set X of atoms. Then Pos(Y ) = {x \u2208 X | x \u2208 Y } is the set of atoms that appear positive in Y , Neg(Y ) = {x \u2208 X | x \u2208 Y } is the set of atoms that appear negated in Y and Atoms(Y ) = Pos(Y )\u222aNeg(Y ). The set Y is consistent if Pos(Y )\u2229 Neg(Y ) is empty and a set Z of atoms satisfies Y if both Pos(Y ) \u2286 Z and Neg(Y )\u2229Z = \u2205. The update operator n is a binary function such that given a set X of atoms and a set Y of literals, X n Y is a set of atoms defined as X n Y = (X \u2212Neg(Y )) \u222a Pos(Y )."}, {"heading": "2.2 Planning", "text": "For positive results on compact representations, we want the results to apply to as general and powerful planning languages as possible, so the results hold also for all languages that are more restricted. Hence, we use the Finite Functional Planning formalism (Ba\u0308ckstro\u0308m & Jonsson, 2011a), which makes a minimum of assumption about the language, except that it is a ground language over state variables with finite domains.\nDefinition 1. A Finite Functional Planning (FFP) frame is a tuple \u3008V,D,A\u3009 where V is an implicitly ordered set of variables, D : V \u2192 N is a domain function that maps every variable to a finite subset of the natural numbers and A is a set of actions. The frame implicitly defines the state space S(f ) = D(v1) \u00d7 . . . \u00d7 D(vn), where v1, . . . , vn are the variables in V in order. The members of S(f ) are referred to as states. Each action a in A has two associated total functions, the precondition pre(a) : S(f ) \u2192 {0, 1} and the postcondition\npost(a) : S(f )\u2192 S(f ). For all pairs of states s, t \u2208 S(f ) and actions a \u2208 A, a is from s to t if both\n1) pre(a)(s) = 1 and 2) t = post(a)(s).\nA sequence \u03c9 = \u3008a1, . . . , a`\u3009 \u2208 A\u2217 is a plan from a state s0 \u2208 S(f ) to a state s` \u2208 S(f ) if either\n1) \u03c9 = \u3008\u3009 and s0 = s` or 2) there are states s1, . . . , s`\u22121 \u2208 S(f ) such that ai is from si\u22121 to si (for 1 \u2264 i \u2264 `).\nAn FFP instance is a tuple p = \u3008V,D,A, I,G\u3009 where f = \u3008V,D,A\u3009 is an FFP frame, I \u2208 S(f ) is a state and G : S(f ) \u2192 {0, 1} is a total function. A state s \u2208 S(f ) is a goal state for p if G(s) = 1. The goal G is reachable from a state s \u2208 S(f ) if there is a plan from s to some goal state for p. A solution for p is a plan from I to some goal state s \u2208 S(f ). A solution for p is called a plan for p.\nThe complexity of computing the pre- and postconditions of the actions and of the goal function is referred to as step complexity. In this paper, we will only consider the subclass FFP([P]) which consists of all FFP frames and instances with polynomial step complexity. We will occasionally also consider restrictions of FFP([P]) and use the notation FFP(p) for the class of all FFP frames f (and instances p) where the action pre- and postconditions (and G) can all be computed in p(||f ||) time (and in p(||p||) time), where p is a polynomial. We furthermore say that an FFP([P]) instance p = \u3008V,D,A, I,G\u3009 is deterministic if for all s \u2208 S(p) such that p has a plan from I to s, there is at most one a \u2208 A such that pre(a)(s) = 1. That is, if an instance is deterministic then the planner is never faced with a choice between two or more actions.\nWhen proving that no compact representation can exist, the result gets stronger if we use a weaker formalism. That is, we want to use the most restricted formalism possible, since the results will then automatically apply to all formalisms that are more expressive. Hence, we will use propositional Strips for such results. There are a number of common variants of propositional Strips that are known to be equivalent to each other and to the SAS+ formalism under a strong form of polynomial reduction (Ba\u0308ckstro\u0308m, 1995). What we will refer to as Strips in this paper is the variant called propositional Strips with negative goals (PSN) by Ba\u0308ckstro\u0308m. It can be defined as a special case of FFP([P]) that uses binary variables, but we define it here in a more traditional way, treating the variables as propositional atoms.\nDefinition 2. A Strips frame is a tuple f = \u3008V,A\u3009 where V is a set of propositional atoms and A is a set of actions. The state space is defined as S(f ) = 2V and states are subsets of V . Each action a in A has a precondition pre(a) and a postcondition post(a), which are both consistent sets of literals over V . For all pairs of states s, t \u2208 S(f ) and actions a \u2208 A, a is from s to t if both\n1) s satisfies pre(a) and 2) t = s n post(a).\nA sequence \u03c9 = \u3008a1, . . . , a`\u3009 \u2208 A\u2217 is a plan from a state s0 \u2208 S(f ) to a state s` \u2208 S(f ) if either\n1) \u03c9 = \u3008\u3009 and s0 = s` or 2) there are states s1, . . . , s`\u22121 \u2208 S(f ) such that ai is from si\u22121 to si (for 1 \u2264 i \u2264 `).\nA Strips instance is a tuple p = \u3008V,A, I,G\u3009 such that f = \u3008V,A\u3009 is a Strips frame, I is a state in S(f ) and G is a consistent set of literals over V . A state s \u2208 S(f ) is a goal state for p if s satisfies G. The goal G is reachable from a state s \u2208 S(f ) if there is a plan from s to some goal state for p. A solution for p is a plan from I to some goal state s \u2208 S(f ). A solution for p is called a plan for p.\nThe notation a : X \u21d2 Y will be frequently used to define an action a with precondition X and postcondition Y .\nAll negative results will be proven to hold for Strips. However, in most cases the results hold even for many restricted subclasses of Strips. It would lead too far to survey such cases in this paper so we will use the restriction to unary actions as an archetypical case throughout the paper.\nDefinition 3. A Strips action a is unary if |post(a)| = 1, a set of Strips actions is unary if all its actions are unary and a Strips frame or instance is unary if its action set is unary.\nUnary actions may seem like a very limiting restriction but has been demonstrated as sufficient in many cases for use in on-board controllers for spacecrafts (Muscettola et al., 1998; Brafman & Domshlak, 2003). This is not surprising, though, since Strips planning is PSPACE-complete and remains so even when restricted to unary actions (Bylander, 1994). Given a Strips instance it is always possible to construct a corresponding Strips instance that is unary. The following reduction to unary instances is a simplified Strips version of the reduction used for SAS+ (Ba\u0308ckstro\u0308m, 1992, proof of Theorem 6.7).\nConstruction 4. Let p = \u3008V,A, I,G\u3009 be a Strips instance. Construct a corresponding instance p \u2032 = \u3008V \u2032, A\u2032, I \u2032, G\u2032\u3009 as follows. Define Vlock = {valock | a \u2208 A}. Then let V \u2032 = V \u222a Vlock, I \u2032 = I and G\u2032 = G \u222a Vlock. Define A\u2032 such that for each a \u2208 A, it contains the following actions:\nabegin : pre(a) \u222a Vlock \u21d2 {valock}, aend : post(a) \u222a {valock} \u21d2 {valock}, ai : {valock} \u21d2 {`i}, for each `i \u2208 post(a).\nWe leave it without proof that this construction is a polynomial reduction from the class of Strips instances to the class of unary Strips instances. It is furthermore worth noting that the construction can easily be modified to use padding with redundant variables to make all original actions correspond to the same number of actions in the unary instance. Hence, it is possible to make a reduction where the plans for the unary instance are at most a constant factor longer than the corresponding plans for the original instance.\nWe will also make frequent use of Strips instances that include encodings of binary counters based on the following construction, which uses one action for each bit and can increment a non-negative integer encoded in binary.\nConstruction 5. An n-bit binary counter can be encoded in Strips as follows: let V = {x1, . . . , xn} and let A contain the n actions\nai : {xi, xi\u22121, . . . , x1} \u21d2 {xi, xi\u22121, . . . , x1} (1 \u2264 i \u2264 n).\nThe following is a plan for counting from 0 to 16 using a 5-bit counter according to Construction 5:\n\u3008a1, a2, a1, a3, a1, a2, a1, a4, a1, a2, a1, a3, a1, a2, a1, a5\u3009.\nWhile we could modify the binary counter to use only unary actions as described in Construction 4, a more direct way to get unary actions is to count in Gray code.\nConstruction 6. (Ba\u0308ckstro\u0308m & Klein, 1991) An n-bit Gray-code counter can be encoded in Strips as follows: let V = {x1, . . . , xn} and let A contain the 2n actions\nsi : {xi, xi\u22121, xi\u22122, . . . , x1} \u21d2 {xi} (1 \u2264 i \u2264 n), ri : {xi, xi\u22121, xi\u22122, . . . , x1} \u21d2 {xi} (1 \u2264 i \u2264 n).\nThe following is a plan for counting from 0 to 16 with a 5-bit Gray-code counter according to Construction 6:\n\u3008s1, s2, r1, s3, s1, r2, r1, s4, s1, s2, r1, r3, s1, r2, r1, s5\u3009."}, {"heading": "2.3 Complexity Theory", "text": "We will use the abbreviation DTM for deterministic Turing machine and NTM for nondeterministic Turing machine. In addition to these standard types, we will also use advice taking Turing machines of both deterministic and nondeterministic type.\nAn advice-taking Turing machine M has an associated sequence a1, a2, a3, . . . of advice strings, a special advice tape and an advice function a, from the natural numbers to the advice sequence, such that a(n) = an. On input x the advice tape is immediately loaded with a(||x||). After thatM continues in the normal way, except that it also has access to the advice written on the advice tape. If there exists a polynomial p such that ||a(n)|| \u2264 p(n), for all n > 0, then M is said to use polynomial advice. The complexity class P/poly is the set of all decision problems that can be solved by some advice-taking DTM that runs in polynomial time using polynomial advice. This can be extended such that, for instance, NP/poly is defined by the NTMs that run in polynomial time using polynomial advice. Note that the advice depends only on the size of the input, not on its content. Furthermore, the advice sequence must only exist; it does not need to be computable. The following two results from the literature will be used later in this paper.\nTheorem 7. a) If NP \u2286 P/poly, then the polynomial hierarchy collapses (Karp & Lipton, 1980, Theorem 6.1). b) Let k > 0 be an integer. If \u03a0pk \u2286 \u03a3 p k/poly, then the polynomial hierarchy collapses to level k + 2 (Yap, 1983, Lemma 7 combined with Theorem 2).\nThe 3SAT problem consists of instances of the form C = {c1, . . . , cm} where each ci, for 1 \u2264 i \u2264 m, is called a clause and is a set of exactly three literals over some universe of binary variables. The instance C is satisfiable if there exists some assignment of truth values to the variables used in C such that at least one literal is true in each ci \u2208 C. It is otherwise unsatisfiable. Deciding satisfiability for 3SAT is NP-complete, while deciding unsatisfiability is coNP-complete. More precisely, we will use the following definition of 3SAT in this paper.\nDefinition 8. For all integers n > 0, let Xn = {x1, . . . , xn} be a set of variables and let m(n) be the number of possible 3-literal clauses over Xn. Let c1n, c 2 n, . . . , c m(n) n be some fixed systematic enumeration of these clauses and let Cn = {c1n, c2n, . . . , c m(n) n }. Each clause cin defines three literals such that 1 cin = {`1i , `2i , `3i }. Further, let C0n, C1n, . . . , C2 m(n)\u22121 n be a fixed systematic enumeration of all subsets of Cn, and let s in = \u3008Xn, Cin\u3009, for 0 \u2264 i < 2m(n). Also implicitly define the set En = {e1n, e2n, . . . , e m(n) n } of atoms and its subsets Ein = {e j n | cjn \u2208 Cin}, for 0 \u2264 i < 2m(n).\nThe sequence s0n, s 1 n, . . . , s 2m(n)\u22121 n is a systematic enumeration of all possible 3SAT instances over n variables, and hence equivalent to the usual definition of 3SAT. Technically speaking, this is a redundant encoding of 3SAT since it allows instances that specify more variables than are used in the clauses. This is harmless, however; all non-redundant instances remain, so we still have all hard instances and neither of the redundantly encoded instances can be harder than their non-redundant counterpart. Since m(n) \u2264 8n3, the enumerations of Cn and En can be chosen such that they are polynomial-time computable, and we assume some such enumerations have been fixed from now on. We also note that a set Ein uniquely identifies the clause set Cin."}, {"heading": "3. Representing Arbitrary Plans Compactly", "text": "It is known that there are cases where planning instances have exponential-size plans but the plans always have a polynomial-size representation (Gime\u0301nez & Jonsson, 2008). An obvious question is thus whether all plans, including those of exponential length, can have polynomial representations. For one interpretation of the question the answer is trivially yes.\nObservation 9. The set of all plans for an arbitrary FFP([P]) instance p has an O(||p||) size representation, since the instance itself together with a deterministic planning algorithm that successively enumerates and outputs all plans is such a representation.\nAlthough this is a trivial and not very useful observation it highlights some fundamental issues of representations. Liberatore (2005a) discusses a similar representation, where instead of specifying an algorithm he defines a lexiographic ordering on the actions. Furthermore, he adds a plan index to be able to represent a single plan rather than just the whole set of plans. However, such an index is not unproblematic, as we will see soon.\nA more interesting interpretation of our question is whether every single plan for a particular instance can have a polynomial representation. Even more precisely, is there a polynomial p such that every plan for every planning instance has a representation of size O(p(n)), where n is the size of the planning instance? To investigate this question we consider the most simple compact notation possible, an index number i for each plan for a particular instance. Since instances may have infinitely many plans, due to cycles in the state-transition graph, we consider optimal plans only. There is, however, no guarantee that even such an index is small enough\u2014a polynomial number of bits may not be sufficient to represent it.\n1. We sometimes omit index n, when it can be assumed obvious from context, and thus write `ki rather than `kn,i.\nConstruction 10. Given an arbitrary integer n > 0, construct the Strips instance pn = \u3008Vn, An, In, Gn\u3009 such that Vn = {x1, . . . , xn, y}, In = \u2205, Gn = {x1, . . . , xn} and An contains the actions\nai : {xi, xi\u22121, . . . , x1} \u21d2 {xi, xi\u22121, . . . , x1, y} (1 \u2264 i \u2264 n) bi : {xi, xi\u22121, . . . , x1} \u21d2 {xi, xi\u22121, . . . , x1, y} (1 \u2264 i \u2264 n).\nLemma 11. For every integer n > 0, instance pn according to Construction 10 has 22 n\u22121 optimal plans.\nProof. Let n > 0 be an arbitrary integer and pn a corresponding Strips instance according to Construction 10. This instance is a binary counter over the variables x1, . . . , xn as in Construction 5, except that it has an extra variable y that can be independently set to true or false, depending on whether an action of type ai or bi is chosen. Since the variables x1, . . . , xn can be interpreted as a binary number, let the notation \u3008m, y\u3009 represent the state where x1, . . . , xn encodes the number m and y is false, and let \u3008m, y\u3009 represent the corresponding state where y is true. Whenever in a state \u3008m, y\u3009 or \u3008m, y\u3009 (wherem < 2n\u22121) it is possible to go to either of \u3008m+ 1, y\u3009 or \u3008m+ 1, y\u3009 using one action, but to no other states. The state transition graph for this instance appears in Figure 1. The initial state is \u30080, y\u3009 and the only goal states are \u30082n \u2212 1, y\u3009 and \u30082n \u2212 1, y\u3009. Hence, any plan for pn must be of length 2n\u2212 1. From every state that is not a goal state there are two different actions to choose between and they lead to different states. However, the goal is reachable from both these states so the choice of action does not matter. Hence, there are 22\nn\u22121 different plans for pn.\nAlthough the atom y is redundant in this particular example the whole construction could be a part of a larger instance, where y does have a purpose. It should also be noted that the instances used in the proof have only optimal plans; all plans have the same length. All is now set to prove the previous claim.\nTheorem 12. For every integer n > 0, it takes 2n \u2212 1 bits to index all optimal plans for instance pn according to Construction 10.\nProof. Since an m-bit number can distinguish between at most 2m different objects, it follows from Lemma 11 that at least 2n \u2212 1 bits is necessary to index the plans for pn\nThis result immediately implies that not all (optimal) plans for a Strips instance can have polynomial-size representations. This holds even under some restrictions, like unary actions. If basing Construction 10 on a Gray counter instead of a binary counter then every action has two postconditions. Rewriting this using Construction 4 yields an equivalent instance with unary actions using a block of four actions for each action in the original instance. Although the plans get 4 times longer the number of plans will remain the same. Hence, Theorem 12 still holds.\nThis theorem leaves the possibility open that some of the plans for an instance can have polynomial representations, although not all of them can. An interesting question is thus how many of the plans for an instance can have polynomial representations? To answer that question we stray into the field of information theory and Kolmogorov complexity. It is out of the scope of this paper to treat that field in detail, but loosely speaking, the Kolmogorov complexity of a string is the size of the smallest DTM that can generate the string with no input. Let K(x) denote the Kolmogorov complexity of a binary string x. The following lemma is due to Buhrman et al. (2000, Lm. 1).\nLemma 13. (Incompressibility lemma) Let c be a positive integer. Every set A of cardinality m has at least m(1\u2212 2\u2212c) + 1 elements x with K(x) \u2265 blogmc \u2212 c.\nThis lemma can be used to show that the fraction of plans that can be compactly represented approaches zero as the size of instances approaches infinity.\nTheorem 14. Let p be an arbitrary polynomial. Consider instances pn according to Construction 10 for arbitrary integers n > 0. Let t(n) be the total number of plans for pn and let s(n) be the number of plans that can be represented with at most p(n) bits. Then limn\u2192\u221e s(n) t(n) = 0.\nProof. Let p be an arbitrary polynomial. We know from Lemma 11 that t(n) = 22 n\u22121. For every n > 0, let c(n) = 2n \u2212 p(n) \u2212 2. The incompressibility lemma then says that there are at least t(n)(1 \u2212 2\u2212c(n)) + 1 plans \u03c9 such that K(\u03c9) \u2265 blog t(n)c \u2212 c(n). That is, there are at most 2\u2212c(n)t(n) \u2212 1 plans \u03c9 such that K(\u03c9) < blog t(n)c \u2212 c(n). Using the values for t(n) and c(n) above, this simplifies to say that there are at most 2p(n)+1 \u2212 1 plans \u03c9 such that K(\u03c9) \u2264 p(n). Hence, s(n) \u2264 2p(n)+1 \u2212 1. The theorem then follows since 0 \u2264 limn\u2192\u221e s(n)t(n) \u2264 limn\u2192\u221e 2p(n)+1\u22121 22n\u22121 = 0.\nThis means that even if it is the case that some plans for every solvable instance can have compact representations, the probability that a particular plan has a compact representation will be vanishingly low for large instances. Although it is not strictly necessary to use Kolmogorov complexity to prove Theorem 14 doing so makes the information-theoretic aspect of compact representations clearer."}, {"heading": "4. Uniform Compact Representations of Plans", "text": "We now know that we cannot, in general, compress arbitrary exponential plans to subexponential size. But what if we do not choose ourselves which plan to use? The previous result still leaves open for the possibility that a small fraction of solutions for a planning instance could have compact representations. However, the planner (or an oracle or whatever)\nwould then have to choose for us which plan to present us with a compact representation of. Suppose a planner could actually do this, how would we make use of it? If we still need the actual plan itself then we cannot avoid its exponential size. Hence, the interesting case seems to be if we could at least access useful information in the plan efficiently.\nThe term representation is used in a loose sense here, but need not really be precisely defined for the moment. It suffices to note that any representation needs both some kind of data structure and some kind of access algorithm, with the extreme cases being either a vector of data with the trivial access algorithm or an algorithm that embeds all the data.\nWhat could it mean to access a compact representation efficiently? We will investigate two such criteria. The first one is that we can efficiently retrieve the actions of the actual plan sequentially. Our interpretation of efficient will be that actions can be retrieved with polynomial delay (Johnson, Papadimitriou, & Yannakakis, 1988). The second criterion is that any action in the actual represented plan can be random accessed in polynomial time, in the size of the instance.\nBefore looking at explicit representations for each plan we take a look at the uniform case, where we have a single representation that covers all instances. More precisely, we consider the case of a single algorithm that works as a compact representation for some plan for every solvable instance.\nTheorem 15. If there is an algorithm that for any solvable Strips instance p can either generate some plan for p sequentially with polynomial delay or random access any action in some plan for p in polynomial time, then P = NP.\nNote that this theorem does not follow from the fact that Strips planning is PSPACEcomplete since only solvable instances are considered. Before proving the theorem we need to introduce some extra technical machinery. We start by encoding 3SAT instances according to Definition 8 in Strips as follows.\nConstruction 16. Let n > 0 and i, where 0 \u2264 i < 2m(n), be arbitrary integers. Construct the Strips instance pin = \u3008Vn, An, Ein, {goal}\u3009 such that Vn = Xn\u222aEn\u222a{cts, ctu, goal, inc}\u222a {v0, . . . , vm(n)} and An has the actions specified in Table 1.\nAs previously noted, each subset Ein of En uniquely identifies the 3SAT instance s i n by telling which clauses in Cn are \u2019enabled\u2019 in s in. That is, the initial state selects the particular nvariable instance we are interested in. The actions are partitioned into three groups. Group I contains the two actions acs and acu, which set the atoms cts and ctu respectively. These actions block each other and both cts and ctu are initially false, so only one of these atoms can be set to true in any plan. That is, cts and ctu are mutually exclusive. Group II consists of actions that all require cts true and group III consists of actions that all require ctu true. These two groups of actions are thus also mutually exclusive. Hence, every plan must start with exactly one action from group I and the rest of the plan consists only of actions from either group II or group III, depending on which the first action is. The intention of this is the following: if the plan starts with action acs then it commits to verifying that s in is satisfiable and if the plan starts with action acu then it commits to verifying that s in is not satisfiable. In either case the plan ends with an action that satisfies the goal only if the plan has verified the commitment made by the first action. This can be interpreted as viewing\nthe planner as a theorem prover which first outputs a theorem (the first action in the plan) and then a proof of the theorem (the rest of the plan).\nLemma 17. For every integer n > 0 and integer i such that 0 \u2264 i < 2m(n), the Strips instance pin according to Construction 16 has the following properties:\n1. It can be computed in polynomial time in n.\n2. It corresponds to the 3SAT instance sin such that every plan for p i n starts with action\nacs if sin is satisfiable and otherwise with action acu.\n3. It always has at least one plan.\nProof. Property 1 is trivial to prove. To prove property 2, we first note that the initial state contains only atoms from En. As previously noted, each subset Ein of En uniquely identifies the 3SAT instance s in by telling which clauses in Cn are \u2019enabled\u2019 in s i n.\nWe have two cases: if the plan starts with action acs then it commits to verifying that s in is satisfiable and if the plan starts with action acu then it commits to verifying that s i n is not satisfiable. In either case the plan ends with an action that satisfies the goal only if the plan has verified the commitment made by the first action. The details of the two cases are as follows.\nIf the plan verifies satisfiability, then it must be of the form\n\u3008acs, aseti1 , . . . , asetih\ufe38 \ufe37\ufe37 \ufe38 assign , avt0, avt k1 1 , . . . , avt km(n) m(n)\ufe38 \ufe37\ufe37 \ufe38\nverify\n, ags\u3009.\nThe assign block has h actions that set a satisfying assignment for x1, . . . , xn. The verify block consists of one action a = avtkjj for each clause c j n. If c j n is enabled (e j n true), then 1 \u2264 kj \u2264 3 and a verifies that `kj in c j n is true for the assignment. Otherwise, if c j n is\ndisabled then kj = 0, so a = avt0j which skips over c j n without verifying anything. The planner has thus\n1. committed to verify that s in is satisfiable,\n2. chosen a satisfying assignment for x1, . . . , xn and\n3. chosen one literal for each enabled clause as a witness that the clause is true under this assignment.\nThe last action ags makes the goal true if these three steps are successful. Note that this works also for the case where no clause is enabled, which corresponds to the trivially satisfiable instance with an empty set of clauses. Obviously, there is a plan of this form if and only if s in is satisfiable.\nIf the plan instead verifies unsatisfiability, then it must be of the form\n\u3008acu, b0, a1, b1, a2, b2, . . . , ah, bh, agu\u3009,\nwhere h = 2n \u2212 1. Except for the first and last actions, this plan can be viewed as two interleaved sequences\n\u03b1 = \u3008a1, . . . , ah\u3009 = \u3008aix1, aix2, aix1, aix3, . . . , aix1\u3009\nand \u03b2 = \u3008b0, b1, . . . , bh\u3009.\nThe aixi actions are increment actions that use x1, . . . , xn to form a binary counter. Since these variables correspond to the number 0 in the initial state and there are 2n\u22121 increment actions, the subplan \u03b1 enumerates all possible truth assignments for x1, . . . , xn. Sequence \u03b2 consists only of actions of the type avf j . Each avf j action verifies that the corresponding clause cjn is enabled and false under the current assignment to x1, . . . , xn. The aixi actions require inc to be true and set it false, while the avf j actions instead require inc to be false and set it true. Hence the plan is synchronised such that it alternates between actions from the two sequences. Since the first aixi action is preceeded by an avf j action and there is an avf j action after the last aixi action, it follows that there must be some unsatisfied and enabled clause for every possible truth assignment, since the synchronization will otherwise get stuck so the counter cannot increment. That is, there is a plan of this type if and only if s in is unsatisfiable. The last action agu makes the goal true if this succeeded. Note that in this case there is no need for actions to skip over disabled clauses since it is sufficient to demonstrate one enabled clause that is false for each assignment.\nIt follows that the plan is of the first form if s in is satisfiable and of the second form if s in is unsatisfiable. Furthermore, since the first action is a commitment for the rest of the plan whether to verify satisfiability or unsatisfiability, it is sufficient to check this action to decide if s in is satisfiable or not.\nProperty 3 follows immediately from property 2 since the plan must be of either of the two forms.\nWe now have the necessary tools to prove the theorem.\nProof of Theorem 15. Suppose there is an algorithm with either sequential or random access as stated in the precondition of the theorem. We can then solve any 3SAT instance s in in polynomial time by asking the algorithm for the first action of some plan for the corresponding instance pin and tell from this action whether s i n is satisfiable. However, this implies that P = NP.\nThis proof would still hold if rewriting Construction 16 as described in Construction 4, that is, Theorem 15 holds even if restricted to the set of unary Strips instances only."}, {"heading": "5. Non-Uniform Compact Representations of Plans", "text": "Theorem 15 uses a very strong criterion: it requires that one single algorithm can handle all instances. A more relaxed variant is the non-uniform case, where we allow different representations for different instances. That is, we will consider compact representations of single plans under different access criteria. In order to do so we must first define more precisely what we mean by such representations."}, {"heading": "5.1 Compact Representations and Access Mechanisms", "text": "We define the concepts Csar and Crar which are representations of action sequences characterised by their access properties2.\nDefinition 18. Let f be an arbitrary function. Let f = \u3008V,D,A\u3009 be an FFP([P]) frame and let \u03c9 \u2208 A\u2217. A representation \u03c1 of \u03c9 is a DTM. Furthermore:\n1. \u03c1 is f -compact if ||\u03c1|| \u2264 f(||f ||) and it runs in f(||f ||) space including the input and output tapes.\n2. \u03c1 is an f -compact sequential-access representation (f -Csar) of \u03c9 if it is f -compact, takes no input and generates the actions in \u03c9 sequentially in f(||f ||) time for each successive action.\n3. \u03c1 is an f -compact random-access representation (f -Crar) of \u03c9 if it is f -compact and for an arbitrary index i (where 1 \u2264 i \u2264 |\u03c9|) as input, it outputs action i of \u03c9 in f(||f ||) time.\nNote that this definition does not require that the representations are computable. We could have used two separate functions, one to bound the access time and one to bound the size, which would allow for better precision. However, we choose to use a single function for both since this makes the theory simpler and clearer while having sufficient precision for our purposes in this paper. We further consider the output tape as cleared between actions so the output is a single action, not the sequence \u03c9. Also note that the space complexity includes the input and output tapes, which implies that the longest sequence an f -Crar \u03c1\n2. Note that this definition differs slightly from our previous one (Ba\u0308ckstro\u0308m & Jonsson, 2011b). First, we have generalised the definition to allow compact representations for an arbitrary function f , not just an arbitrary polynomial. Second, in order to improve the precision we no longer use the O(\u00b7) notation but exact functions. Finally, the representations now have the same restriction for space and time. None of these changes matter for the results in our previous publication, but only for the details of proofs.\ncan represent is less than 2||\u03c1|| actions since its input is limited to ||\u03c1|| bits. A Csar has no corresponding limit since it has no input. Furthermore, the time restriction for an f -Csar can be viewed as a generalisation of the polynomial delay concept which is not restricted to polynomials. We will often apply this definition to instances rather than frames. Although this makes a slight difference technically, it is not important in principle and ignoring it allows for simpler theorems and proofs. We write only Crar and Csar when referring to the whole family of representations of a particular type."}, {"heading": "5.2 Sequential-Access Representations", "text": "For sequential access in the non-uniform case we would like to ask if all solvable Strips instances have at least one plan with a polynomial Csar. Unfortunately, that still remains an open question. Hence, we consider a more restricted case of this question where we also require that the Csar must be verifiable within some resource constraint, which we define as follows.\nDefinition 19. For every FFP([P]) plan representation type R, define the following decision problem:\nPlan Representation Verification Instance: An FFP([P]) instance p = \u3008V,D,A, I,G\u3009 and a string \u03c1. Question: Is \u03c1 an R-representation of a plan for p?\nThe complexity of verification is measured in ||p|| + ||\u03c1||. We can now state the following theorem about polynomial Csars.\nTheorem 20. Let C be an arbitrary complexity class and p an arbitrary polynomial. If p-Csar verification is in NP C and every solvable Strips instance has at least one plan with a corresponding p-Csar, then PSPACE \u2286 NP C .\nProof. Let p be an arbitrary polynomial. Suppose p-Csar verification is in NPC and every solvable Strips instance has at least one plan with a corresponding p-Csar. Let p be an arbitrary Strips instance. We can then decide if p has a plan by guessing a string of length p(||p||) bits and then check if that string is a p-Csar for some plan for p. This can be done in polynomial time (in ||p||) using an NTM with an oracle for C since p-Csar verification is in NPC . However, deciding if a Strips instance has a plan is PSPACEcomplete (Bylander, 1994, Thm. 3.1) so it follows that PSPACE \u2286 NPC , since p was chosen arbitrarily.\nThat is, a Csar for a planning instance is of limited use if we must first verify that it is correct before using it, since this verification may be as difficult as solving the instance itself. Also note that if C is a class in the polynomial hierarchy, then PSPACE \u2286 NPC implies a collapse of this hierarchy. The preceding theorem holds for the restriction to unary Strips instances, since planning is still PSPACE-complete for this restriction (Bylander, 1994, Thm. 3.3). In fact, it holds for all restrictions where planning is still PSPACE-complete, which includes several other cases in Bylander\u2019s analysis as well as many subclasses of SAS+ planning (see Ba\u0308ckstro\u0308m & Nebel, 1995; Jonsson & Ba\u0308ckstro\u0308m, 1998a, for overviews of results).\nAlthough this result may seem disapointing, it holds only under the condition that we must check whether the Csar is correct. That means, for instance, that the theorem is irrelevant if correctness of the Csar is guaranteed by design. One such case is the following.\nTheorem 21. Every Strips instance according to Construction 16 has a plan with a polynomial Csar.\nProof. Consider an arbitrary such instance pin. Add n+1 extra bits b0, . . . , bn such that b0 tells if s in is satisfiable or not. If s i n is satisfiable then the remaining bits specify a satisfying assignment such that bi gives the value for vi, and they are otherwise undefined. We claim there is a simple deterministic algorithm that uses only pin and b0, . . . , bn and generates a plan for pin with polynomial delay as follows.\nSuppose b0 says that s in is satisfiable and that h of bits b1, . . . , bn are one. Then there is a plan for pin of the form\n\u3008acs, aseti1 , . . . , asetih\ufe38 \ufe37\ufe37 \ufe38 assign , avt0, avt k1 1 , . . . , avt km(n) m(n)\ufe38 \ufe37\ufe37 \ufe38\nverify\n, ags\u3009.\nThe actions in the assign block can easily be generated from b1, . . . , bn. For the avtkj actions, output avt0j if c j n is not enabled and otherwise output avtkj for the smallest k such that ` k j is true for the specified assignment. Clearly this algorithm works with polynomial delay. Instead suppose s in is not satisfiable. Then the plan is of the second type and must cycle through all possible assignments. Doing this and generating the corresponding counting actions is trivial. For each assignment we must also output an avf j action. Determine the smallest j such that cjn is enabled but not satisfied for the current assignment, and output avf j . This can be done in polynomial time since there is only a polynomial number of clauses.\nClearly this construction is a polynomial Csar for some plan for pin.\nThe following theorem demonstrates that there are also more general and harder classes of instances where even optimal plans have polynomial Csars by design.\nTheorem 22. There is a subclass X of Strips and a polynomial p such that deciding if instances of X have a plan is PSPACE-complete and all solvable instances of X have an optimal plan with a p-Csar.\nProof. PSPACE can be characterised by the class of polynomial-space bounded DTMs. Bylander (1994, Thm. 3.1) used this fact to demonstrate a polynomial reduction from PSPACE to Strips planning. We refer to Bylander for details but in brief: given a machine M with input x he constructs a deterministic Strips instance that has a plan if and only if M(x) accepts. Hence, it is a polynomial time problem to check that we are in a valid state and then find the only action, if any, that can be applied in that state. It follows that there is some polynomial p such that every such solvable Strips instance has a plan with a p-Csar. Furthermore, since the instance is deterministic it has only one plan, which must then be optimal.\nAn even more general observation is that every deterministic FFP([P]) instance that is solvable has exactly one plan, which is thus optimal, and that this plan has a polynomial Csar. As a contrast to this we will next consider a class of instances where solvable instances always have plans with polynomial Csars but where we have no optimality guarantee. This example thus illustrates that a Csar is just a representation and that it gives no guarantees about the actual data it represents. More precisely, the example uses the class of reversible FFP([P]) instances, where the state-transition graph is symmetric.\nDefinition 23. An FFP([P]) frame f = \u3008V,D,A\u3009 is reversible if for all pairs of states s and t in S(f ), whenever there is an action a in A from s to t then there is also an action a\u2032 in A from t to s.\nNote that reversible instances are not an easy special case of planning; deciding if there is a plan or not is still PSPACE-complete (Jonsson et al., 2000, Thm. 18). That is, plans can still be of exponential length.\nTheorem 24. There is a polynomial q such that for all polynomials p, every solvable and reversible FFP(p) instance has a (q \u25e6 p)-Csar for some plan.\nProof. Let p = \u3008V,D,A, I,G\u3009 be a solvable FFP(p) instance such that f = \u3008V,D,A\u3009 is reversible. Consider the algorithm in Figure 2. Optplan is assumed to be an algorithm such that optplan(s,G) returns the length of the shortest plan from s to G.\nIf ignoring process B, it is clear that the algorithm outputs an optimal plan for p since there is a plan by assumption. Process B finds two actions a1 and a2 such that executing \u3008a1, a2\u3009 in state s ends up in state s. Such a choice of actions must exist since there is a plan from s to some goal state and f is reversible. The synchronisation between processes A and B make all such actions a1, a2 appear adjacent in that order in the output of the algorithm, and they do thus not interfere with the plan produced by process A. They just make the plan longer. Choosing actions in process B can be done by a double loop through all pairs of actions and checking them.\nIt is obvious that there is a polynomial r such that process B runs in r(||p||) time. We can choose r to also allow extra time to run process A in parallel. Let \u03c1 be p together with the algorithm. Then ||\u03c1|| \u2264 ||p||+ c for some constant c. Choose r such that it also satisfies n + c \u2264 r(n) for all n > 0. Obviously, \u03c1 is an r-Csar for some plan for p. Choose the polynomial q such that r(n) \u2264 q(p(n)) for all n > 0.\nAlgorithm Optplan must obviously run in polynomial space, but its complexity is otherwise not important. The parallel algorithm used in the proof of this theorem is to some extent a nonsense algorithm. Process A does all the job by consulting an ordinary planning algorithm (optplan) but gives no time guarantees. Process B, on the other hand, contributes nothing relevant to the plan but satisfies the access time requirement. That is, process B buys time for process A to find the plan by generating irrelevant actions frequently enough to satisfy its time requirements. The wait statements are not strictly necessary but illustrate that we can tune the step complexity of the algorithm by slowing down process B if desired.\nAlthough this example might, perhaps, be considered somewhat pathological, it clearly demonstrates that a Csar (just like a Crar) is only a representation. Just like most other data structures it has certain access properties but does not guarantee any particular\nproperties of the actual data stored. This not uncommon for plan representations either. For instance, a reactive plan could be constructed to have the same behaviour and still be considered correct and run in polynomial time and space. We can alternatively use a random walk algorithm, which will also output actions with polynomial delay. It will eventually reach the goal if there is a plan, but it will also output a lot of redundant actions. The algorithm in Figure 2 may, in a sense, be viewed as a derandomized variant of random walk."}, {"heading": "5.3 Random-Access Representations", "text": "The case of non-uniform random access is clearer than the case of sequential access. Here we can answer the question of existence for Crars without any further qualifications about verifiability.\nTheorem 25. If there is a polynomial p such that every solvable Strips instance has at least one plan with a corresponding p-Crar, then the polynomial hierarchy collapses.\nSince this theorem is not conditioned by verifiability of the representations it is a stronger result than Theorem 20. Before proving the theorem we need to introduce some additional theory.\nConstruction 26. Let n > 0 be an arbitrary integer. Construct a Strips instance pn = \u3008Vn, An,\u2205, {goal}\u3009 such that\nVn = Xn \u222a En \u222a {v0, . . . , vm(n)} \u222a {svi, sva, sia, sii, sti, t, f, goal}\nand An has the actions specified in Table 2.\nThe previous Construction 16 allows plans of two types, either choosing an assignment and then verifying all clauses by chaining, or enumerating all assignments and demonstrate one false clause for each. Construction 26 mixes these methods. To check if an instance is satisfiable the plan must enumerate all variable assignments and for each assignment it must walk through all clauses by chaining. For each enabled clause it demonstrates either a true literal or that none of the literals is true, while disabled clauses are skipped over. Atoms f and t keep track of whether all clauses were true for some assignment, in which case the instance is satisfiable. An extra counter that uses the variables e1n, . . . , e m(n) n enumerates all possible subsets Ein of En, thus implicitly enumerating all 3SAT instances s0n, . . . , s 2m(n)\u22121 n . This counter constitutes an \u2019outer loop\u2019, so for each E i n, all possible assignments for x1, . . . , xn are tested as described above. The plan can be thought of as implementing the algorithm in Figure 3.\nLemma 27. For all integers n > 0, instance pn according to Construction 26 has the following properties:\n1. It can be computed in polynomial time in n.\n2. It always has at least one plan.\n3. There exist constants an and bn such that for every i, where 0 \u2264 i < 2m(n), the action at position bni+an in any plan for pn is ais if the 3SAT instance sin is satisfiable and it is aiu if sin is unsatisfiable.\nProof. In addition to the previous explanation of the construction we note that the instance is designed to be deterministic. Setting an = 2n(m(n) + 3) + 2 and bn = an + 1 satisfies the claim, since the action at position bni+ an is ais if s in is satisfiable and it is aiu if it is unsatisfiable.\nAll is now set to prove the theorem.\nProof of Theorem 25. Suppose p is a polynomial such that all solvable Strips instances have at least one plan with a corresponding p-Crar. For each n > 0, let pn be the corresponding instance according to Construction 26 and let \u03c1n be a p-Crar for some plan \u03c9n for pn. By assumption, such \u03c9n and \u03c1n must exist for every n.\nConstruct an advice-taking DTM M which takes input of the form I in = \u3008pn, i\u3009, where n and i are integers such that n > 0 and 0 \u2264 i < 2m(n). Let i be represented in binary using exactly m(n) bits. Then, ||I in|| is strictly increasing in n and depends only on n. Let sn = ||I in|| (which is well defined since ||I in|| does not depend on i). Define the advice function a such that a(sn) = \u03c1n. The advice is thus a p-Crar for some plan for the Strips instance pn according to Construction 26. (Recall that we only need to know that the advice exists, not how to find it.) Let an and bn refer to the corresponding constants that must exist according to Lemma 27. Since M can run whatever algorithm is used to access \u03c1n, it follows from the assumptions that M can find action bni + an in \u03c9n in polynomial time in sn. Let it return yes if this action is ais and otherwise return no.\nGiven an arbitrary 3SAT instance s in, compute the corresponding input I i n for M and then run M on this instance. By construction, M answers yes if and only if s in is satisfiable. The input I in can be computed in polynomial time in ||s in|| and M runs in polynomial time using polynomial advice. Since M solves satisfiability for 3SAT it follows that NP \u2286 P/poly, which is impossible unless the polynomial hierarchy collapses at level 2 according to Theorem 7a.\nIt is further worth noting that the plans for instances according to Construction 26 contains a subplan for every 3SAT instance of a particular size. Hence, we can alternatively view such a plan as a representation of a set of exponentially many plans, which shows that representing one long plan and representing a large set of plans are not fundamentally different issues.\nAlso for Crars there are restricted cases where we can prove that they always exist. One such example is, once again, Construction 16.\nTheorem 28. Every Strips instance according to Construction 16 has a plan with a polynomial Crar.\nProof. Add n+1 extra bits b0, . . . , bn as explained in the proof of Theorem 21 and construct a polynomial-time random-access algorithm as follows.\nSuppose b0 says that s in is satisfiable and that h of bits b1, . . . , bn are one. Then there is a plan for pin of the form\n\u3008acs, aseti1 , . . . , asetih\ufe38 \ufe37\ufe37 \ufe38 assign , avt0, avt k1 1 , . . . , avt km(n) m(n)\ufe38 \ufe37\ufe37 \ufe38\nverify\n, ags\u3009.\nSince h \u2264 n we can construct the whole assign sequence and then determine a specific action in it in polynomial time. Each of the avtkj actions correspond to a specific clause c j n. Since the clauses are ordered we can compute j from the index of the action we ask for. If cjn is not enabled then output avf 0j and otherwise output avf k j for the smallest k such that ` k j is true for the specified assignment b1, . . . , bn. Instead suppose s in is not satisfiable. Then all but the first and last actions are interleaved aixi and avf j actions. The aixi actions have the function of a counter over the variables x1, . . . , xn. Let i be an arbitrary index i into the plan where i is not the first or last action. If i is odd, then ai is an aixk action and k can easily be computed from i, so output aixk. If i is even then ai is an avf j action. The value of x1, . . . , xn immediately before ai can easily be computed from i. Use this value and check all enabled clauses in order until finding a clause cjn that is not satisfied and then output avf j .\nClearly this construction is a polynomial Crar for some plan for pin.\nAnother and much larger class of instances where plans have Crars will be considered in the next section."}, {"heading": "5.4 Relationships between Compact Representations", "text": "In this section we investigate how the Crar and Csar concepts relate to each other. Since a macro plan can also be viewed as a compact representation we also investigate how macro\nplans relate to our concepts. We start by showing that if there is a polynomial Crar for a plan then there is also a polynomial Csar for that plan.\nTheorem 29. There is a polynomial q such that for all polynomials p, all FFP([P]) frames f = \u3008V,D,A\u3009 and all \u03c9 \u2208 A\u2217, if \u03c9 has a p-Crar, then it also has a (q \u25e6 p)-Csar.\nProof. Let f be arbitrary FFP([P]) instance and let \u03c1 be a p-Crar for some plan \u03c9 for f . Use an action counter that is initiated to index the first action in the plan. Generate the actions of the plan sequentially by repeatedly asking \u03c1 for the action indexed by the counter and then incrementing the counter. Let \u03c1\u2032 denote this algorithm together with \u03c1. A ||\u03c1||-bit counter is sufficient since \u03c9 must be shorter than 2||\u03c1|| actions. Suppose it takes r(m) time to increment an m-bit counter. Then there is a constant c such that ||\u03c1\u2032|| \u2264 ||\u03c1||+ c, \u03c1\u2032 runs in 2p(||f ||)+ c space and \u03c1\u2032 runs in p(||f ||)+ r(p(||f ||))+ c time. Define the polynomial q as q(n) = 2r(n)+c. Obviously, ||\u03c1\u2032|| \u2264 ||\u03c1||+c \u2264 q(||\u03c1||) \u2264 q(p(||f ||)), 2p(||f ||)+c \u2264 q(p(||f ||)) and p(||f ||) + r(p(||f ||)) + c \u2264 q(p(||f ||)) so \u03c1\u2032 is a (q \u25e6 p)-Csar for \u03c9.\nThe opposite of this does not hold, however. In particular, while not all instances according to Construction 26 have a plan with a Crar they all have a plan with a Csar, so this construction acts as a separation between the two concepts.\nTheorem 30. Unless the polynomial hierarchy collapses, there is no polynomial q such that for every polynomial p, every Strips instance p and every plan \u03c9 for p, if \u03c9 has a p-Csar then \u03c9 has a (q \u25e6 p)-Crar.\nProof. Let X denote the class of Strips instances used in the proof of Theorem 25. Since these instances are deterministic there is a polynomial p such that every solvable instance has a p-Csar for some plan. However, it follows from the same proof that there is no polynomial r such that all instances of X have a plan with an r-Crar. Hence, there is no polynomial q such that all instances have a plan with a (q \u25e6 p)-Crar.\nAlthough not previously defined in the paper, it makes sense to also have a look at macro plans in this context. A macro is a sequence of two or more actions. Macros are commonly used in planning and treated as a single action by the planner. Macros can be useful for planning if there are certain subsequences of actions that occur frequently in plans (Korf, 1987). However, macros may also be used for the purpose of representing a plan in a more compact and structured way. This is especially true if macros are allowed to also contain other macros, since this allows hierarchies of macros. For instance, it is well known that the shortest solution for the Towers-of-Hanoi problem for arbitrary number of disks can be described by a recursive schema (Gill, 1976, Ex. 3\u201319) although the plan itself is exponential in the number of disks. The 3S class of planning instances (Jonsson & Ba\u0308ckstro\u0308m, 1998b) has the property that we can always find out in polynomial time if an instance has a plan, but the plan itself may be of exponential length and thus cannot be generated in subexponential time. Gime\u0301nez and Jonsson (2008) showed that plans for 3S instances always have a polynomial-size representation using macros. In fact, such a macro plan can even be generated in polynomial time although the actual non-macro plan would take exponential time to generate. This result was later generalised to some other classes\nof planning instances by Jonsson (2009). We will show that polynomial-size macro plans have an immediate connection to compact plan representations. However, in contrast to Gime\u0301nez and Jonsson we will not discuss how to generate macro plans but only analyse some of their properties.\nMacro plans can be very powerful tools for representing plans compactly. Hence, it is interesting to identify criteria for when compact macro-plan representations exist and not. That problem is out of the scope of this paper, but we will give a partial answer to the question in the following way. It is straightforward to see that a macro plan can be viewed as a context free grammar (CFG): let the actions be the terminals, let the macros be the variables, let the macro expansions be the production rules and let the root macro be the start symbol. We note that if we use macros to represent a single plan, rather than to represent various possibilities for planning, then the macro expansions must be acyclic in order to produce a unique well-defined plan. Hence, a macro plan can be defined as an acyclic CFG. When such CFGs are used to represent a single string compactly they are often referred to as compressed grammars. Furthermore, such a compressed grammar permits efficient random access into the string it represents; both the access and the necessary preprocessing is polynomial time in the size of the grammar (Bille et al., 2011). More precisely, consider a grammar of size n that represents a string of length N with a derivation tree of maximum height h. After a polynomial time preprocessing, in the size of the grammar, it is possible to random access any symbol in the string by index in O(logN) time or, alternatively, in O(h) time. Such algorithms typically work by first computing the length of the substrings generated by each rule, the preprocessing step, and then use this information to find the symbol with a certain index by top-down search. Since the grammar is acyclic we get h \u2264 n. Hence, the following proposition is immediate from the properties of compressed grammars.\nProposition 31. There is a polynomial r such that for every FFP([P]) frame \u3008V,D,A\u3009 and every macro plan \u00b5 for a sequence \u03c9 \u2208 A\u2217, \u00b5 can be used to random access any action in \u03c9 in r(||\u00b5||) time. We thus get the following relationship between macro plans and Crars.\nTheorem 32. There is a polynomial p such that for all polynomials q, all FFP([P]) frames f = \u3008V,D,A\u3009 and all action sequences \u03c9 \u2208 A\u2217, if \u03c9 has a macro plan \u00b5 such that ||\u00b5|| \u2264 q(||f ||) then \u03c9 has a (p \u25e6 q)-Crar. Proof. Let r be a polynomial such that all macro plans \u00b5\u2032 can be random accessed in r(||\u00b5\u2032||) time. Let \u03c1 be \u00b5 together with the random access algorithm. Then ||\u03c1|| \u2264 ||\u00b5||+ c for some constant c. Define p such that p(n) = r(n) + c. We get ||\u03c1|| \u2264 ||\u00b5|| + c \u2264 q(||f ||) + c \u2264 r(q(||f ||)) + c = p(q(||f ||)). Furthermore, \u03c1 runs in r(||\u00b5||) \u2264 r(q(||f ||)) + c = p(q(||f ||)) space and time. It follows that \u03c1 is a (p \u25e6 q)-Crar for \u03c9.\nIt follows from Theorem 29 that every plan with a polynomial macro plan also has a polynomial Crar. That is, the class of polynomial macro plans is a subclass of the class of polynomial Crars, but we do not know if it is a proper subclass. In any way, these results do imply that we cannot always find a polynomial macro plan for an instance.\nCorollary 33. If there is a polynomial p such that every solvable Strips instance has at least one plan with a corresponding macro plan of size p(||p||) then the polynomial hierarchy collapses.\nProof. Immediate from Theorems 25 and 32."}, {"heading": "6. Problem Reformulation", "text": "Having now concluded that there seems to be little hope that plans can be compactly represented in the general case, we turn to the idea of problem reformulation to see if that can be of any help. While this may seem out of place in this context it is, to the contrary, a quite logical step to take. So far, we have only analysed planning problems and plans, and that is what the results hold for. It is not obvious that, or when, the results hold also when planning instances are solved by reformulating them to instances of some other problem. It is thus hypothetically possible that we could get around the problems with this approach. However, to say something useful and relevant about this, it is not sufficient to look only at naive approaches, such as polynomial reductions, so we will investigate a stronger criterion.\nThe basic idea of reformulation is to transform a planning instance to another equivalent instance, either another planning instance or an instance of some other problem. For reformulation to be useful, the solution for the new instance must be of use to solve the original instance, and something must be gained. Often, reformulation is used with the intention that the overall process is faster than solving the original instance directly. Common variants are to reformulate planning into SAT, CSP, model checking or another planning problem. Reformulation of planning into SAT was first suggested by Kautz and Selman (1992) and is still a popular approach to planning. Long, Fox, and Hamdi (2002) discuss reformulation for planning in general and Edelkamp, Leue, and Visser (2007) discuss the connections between model checking and planning.\nThe reformulation process can be viewed as shown in Figure 4. A planning instance p has a solution \u03c9 that we can find directly using ordinary planning. Solving p via reformulation instead follows the indirect path in the figure. First p is reformulated into a new instance R(p) (of some problem). Then this instance is solved which produces a solution \u03c1 for R(p). Finally, \u03c1 is transformed back into a solution \u03c9 for p.\nObviously, reformulation cannot help us when plans are exponential. Even if the first two steps of the indirect path took polynomial time and \u03c1 was of polynomial size, it would still necessarily take exponential time to transform \u03c1 into \u03c9 because \u03c9 is exponential. That\nis, the problem is inherently intractable whichever method we use to solve it. Reformulation could potentially speed things up, if \u03c1 could somehow be used directly as a solution for the original problem, but that would happen rarely, if at all.\nThe situation is different, though, if we consider the decision problem rather than the generation problem, that is, if we ask not for a plan but for whether there is a plan or not. In this case we can use the solution for R(p) directly, since decision problems have only two possible answers, yes or no. We may thus escape the inherent intractability. This variant of reformulation is shown in Figure 5. Since no exponential solution is generated in this case, reformulation could potentially be more efficient. We know that the decision problem for Strips is PSPACE-complete in the general case. If the reformulated problem were easier to solve, then it could be beneficial to first reformulate p to R(p) and ask if that instance has a solution or not. Then it would be possible to check if there is a solution at all before embarking on generating a possibly exponentially long plan. Consider, for instance, the 3S class (Jonsson & Ba\u0308ckstro\u0308m, 1998b) where plans may be of exponential size but it is always possible to decide in polynomial time if there is a plan. It thus seems like the case of reformulating decision problems is the most interesting one to look at, and if that does not give any improvement, then there can hardly be any improvement for plan generation via reformulation either.\nLet PE(Strips) denote the decision problem (that is, plan existence) for Strips. The following two results are trivial, but illustrative.\nTheorem 34. a) There exists a decision problem X and a function R such that it holds for all p \u2208 PE(Strips) that R(p) \u2208 X and that p and R(p) have the same answer. b) If there is some complexity class C, some decision problem X \u2208 C and a polynomial-time computable function R such that it holds for all p \u2208 PE(Strips) that R(p) \u2208 X and that p and R(p) have the same answer, then PSPACE \u2286 C.\nProof. a) Let X = PE(Strips) and R the identity function. b) Immediate, since R is a polynomial reduction from PE(Strips) to X.\nIn both cases we reformulate a PSPACE-complete problem into a PSPACE-complete problem, which is not very interesting. If we are to prove anything better, we must obviously look for an X and an R with more useful restrictions.\nIt is important to note that when reformulating planning into some NP-complete problem, for instance SAT, this does not magically make planning NP-complete. The reason that Strips planning is PSPACE-complete is that it allows exponential solutions. As soon as we restrict the solutions to be bounded by some fixed polynomial, planning belongs in NP. Furthermore, encodings of planning instances in SAT typically use atoms to encode what actions appear at each position in the plan, that is, an exponential number of extra atoms are required in the general case. Hence, either our original problem was already in NP or we have to blow up the instance exponentially when reformulating to SAT. In the latter case, the complexity results are no longer comparable. Also note, that if we deliberately restrict ourselves to ask only if there is a plan of a certain length or shorter, then we are actually solving a restricted version of the optimization problem, and also in this case planning itself would be no harder. In fact, it seems most unlikely that planning in general could be reformulated into a problem in NP. In order to avoid straightforward and naive approaches to reformulation we consider and analyse reformulations defined as follows.\nDefinition 35. Let p = \u3008V,A, I,G\u3009 be a Strips instance, let f = \u3008V,A\u3009 and let d = \u3008I,G\u3009. Let X be some decision problem. A reformulation of PE(Strips) into X is a pair \u3008R, r\u3009 of functions that maps every instance p = \u3008f ,d\u3009 \u2208 PE(Strips) to a corresponding instance x = R(r(f ),d) \u2208 X such that p and x have the same answer. \u3008R, r\u3009 is a polynomial reformulation if there are also some fixed polynomials p, q such that\n1) ||r(f )|| \u2208 O(p(||f ||)) and 2) R is computable in O(q(||r(f )||+ ||d ||)) time.\nWe thus consider a reformulation that involves two functions, R and r. Function r is the main reformulation function, intended to reformulate the difficult part of the instance. We do not even require this function to be computable, we only require that it exists. Function R is then used to transform the initial and goal descriptions into something similar that the new instance can use, and combine this with the result delivered by r into a proper instance of X. It should be noted that this reformulation concept is similar, although not identical, to the compilation concept used by Nebel (2000).\nTheorem 36. There is no polynomial reformulation of PE(Strips) to some X \u2208 NP, unless the polynomial hierarchy collapses.\nProof. Suppose \u3008R, r\u3009 is such a reformulation. For arbitrary integer n > 0, let f un = \u3008Vn, An\u3009 be defined as in Construction 16, but without action acs, and let d in = \u3008Ein, {goal}\u3009, for all i such that 0 \u2264 i < 2m(n). It follows trivially from the proof of Lemma 17 that instance pin = \u3008f un,d in\u3009 has a solution if and only if s in is unsatisfiable (note that the \u2018SAT part\u2019 of the instance is \u2018disarmed\u2019).\nConstruct an advice-taking NTM M with input I in = \u3008f un, i\u3009, for all n > 0 and 0 \u2264 i < 2m(n), representing i in binary using m(n) bits. Clearly, ||I in|| is strictly increasing and depends only on n, so let sn = ||I in|| (for arbitrary i). Define the advice function a such that a(sn) = r(f un). (Note that we only need to know that the advice exists, not how to find it). Let M first compute d in from I i n, and then compute x i n = R(a(sn),d i n) = R(r(f u n),d i n), both in polynomial time since a(sn) is given for free as advice. By assumption, x in \u2208 X and has answer yes if and only if pin has a solution. Also by assumption, we have X \u2208 NP so\nM can solve x in by guessing a solution and verifying it in polynomial time. Hence, deciding if pin has a solution is in NP/poly.\nFor an arbitrary 3SAT instance s in, compute I i n in polynomial time. M answers yes for I in if and only if s i n is unsatisfiable. However, unsatisfiability for 3SAT is coNP-complete so it follows that coNP \u2286 NP/poly, which is impossible unless the polynomial hierarchy collapses to level 3, according to Theorem 7b.\nThis result can be pushed arbitrarily high up in the polynomial hierarchy, thus making it unlikely that planning could be reformulated to anything simpler at all.\nCorollary 37. There is no polynomial reformulation \u3008R, r\u3009 of PE(Strips) to some decision problem X \u2208 \u03a3pk, for k > 1, unless the polynomial hierarchy collapses to level k + 2.\nProof sketch. Construction 16 demonstrates how to encode both existential quantification (choosing a truth assignment in the sat part) and universal quantification (enumerating all truth assignments in the unsat part). Hence, it is straightforward to modify it to an analogous construction for QBF formulae with k alternations. Given that, the rest of the proof is analogous to the proof of Theorem 36, but M must use an oracle for \u03a3pk\u22121. The same argument leads to\u03a0pk \u2286 \u03a3 p k/poly, which is impossible unless the polynomial hierarchy collapses to level k + 2, according to Theorem 7b.\nSince both these proofs build on Construction 16 and do not rely the exact position of actions it follows that also this Theorem and Corollary hold when restricted to unary Strips instances only."}, {"heading": "7. Discussion", "text": "This section consists of five parts. We first transfer the reformulation theorem to a more general result about adding information to guide planners, and discuss how that can explain various results in the literature. We then discuss the potential relationship between causal graphs and compact representations. This is followed by a discussion on how the results in the paper could be relevant for plan explanation. The fourth part discusses some related work on compact representations and compilation. The section ends with a summary of the results and a list of open questions."}, {"heading": "7.1 Reformulation and Additional Information", "text": "Theorem 36 has broader consequences than just for reformulation. In fact, it implies that there is no way to help a planner by adding information to a planning frame, no matter what information or how we get it, unless we accept that the amount of information is not always polynomially bounded in the frame size. In the following theorem the function g is assumed to represent the additional information, and it need not even be computable. We only require that its result is polynomially bounded.\nTheorem 38. Let p be an arbitrary polynomial. Consider a function g and an algorithm A such that\n1. g maps Strips frames to {0, 1}\u2217 such that ||g(f )|| \u2208 O(p(||f ||)) for all frames f and\n2. for all Strips instances p = \u3008f,d \u3009, algorithm A answers yes for input \u3008p, g(f )\u3009 if and only if p has a plan."}, {"heading": "If A runs in polynomial time, then the polynomial hierarchy collapses.", "text": "Proof. Assume there is a function g and an algorithm A with the properties described in the theorem. Define a function r such that r(f ) = \u3008f , g(f )\u3009 for every Strips frame f . Also define a function R such that R(\u3008f , x\u3009,d) = \u3008\u3008f ,d\u3009, x\u3009 for every Strips instance p = \u3008f ,d\u3009 and every string x. Then R(r(f ),d) = \u3008\u3008f ,d\u3009, g(f )\u3009 = \u3008p, g(f )\u3009, so \u3008R, r\u3009 is a polynomial reformulation of Strips planning into an equivalent problem that algorithm A can solve in polynomial time. However, no such reformulation can exist according to Theorem 36, unless the polynomial hierarchy collapses.\nThis result can be extended upwards in the polynomial hierarchy in the same way as Corollary 37 (no longer requiring A to be a polynomial algorithm). That means that we cannot make planning simpler by adding a polynomial amount of additional information to a frame and use a clever algorithm to use that information when planning. Planning will remain as hard as it is without that extra information. While it may sometimes help to add information to a particular instance to somehow guide the planner, there is no systematic way to add such information on the frame level if it is required to be of polynomial size.\nThe planning literature is rich with methods that are intended to make planning more efficient by adding information in one way or another, although the methods are perhaps not always thought of as doing so. A non-exhaustive list of such methods, and similar, is abstraction hierarchies, macros, case-based planning, annotated planning and landmarks.\nState space abstraction in planning goes back at least to the Abstrips planner (Sacerdoti, 1974). The main idea is to form abstraction hierarchies on the variables, and thus implicitly on the actions, such that the planner can plan for the most important goals first to get an abstract plan that can then be refined into a more detailed plan. Knoblock (1994) proposed an algorithm for automatically computing such abstraction hierarchies. While his algorithm was successful on many examples it was demonstrated to sometimes fail and produce exponential plans for instances that have a linear optimal plan (Ba\u0308ckstro\u0308m & Jonsson, 1995). This is not surprising since the use of an abstraction hierarchy can be viewed as adding information to the planning frame. Automatic generation of abstraction hierarchies is a systematic way to add information and can thus be treated as a special case of Theorem 38.\nAdding a set of macros to a planning frame is very similar to using abstraction hierarchies, as Knoblock (1993, pp. 110\u2013111) noted. A planner that uses abstraction searches for a plan in an abstract space and then tries to refine each action into a subplan on the lower lever. A planner that uses macros does not search an abstract space but instead already has a set of macros available that each correspond to a subplan. Finding a macro that works and can be expanded is thus very similar to refining an abstract action. Also the use of macros has been demonstrated to speed up planning considerably in certain cases (Korf, 1987). Macros are typically added on the frame level, and learning has been suggested as one method to create macros automatically (Korf, 1985). However, macros are typically treated as any other action by the planner and are not expanded until after finding a plan. Hence, the addition of macros may also backfire and make planning less efficient, just\nas adding redundant actions may do (Haslum & Jonsson, 2000). Once again, this is not surprising since the addition of macros is addition of information and is thus also covered by Theorem 38.\nCase based planning (see Spalazzi, 2001, for a survey) uses stored plans or plan skeletons that the planner tries to reuse by modifying and/or extending them. In one sense, this is similar to macro planning, but with more advanced macros and macro expansion methods. One can also view it as similar to abstraction, where a plan must be refined in order to work. The difference is that the abstraction planner finds the plan skeleton by planning in an abstract space while the case-based planner has a set of such plans stored in a database. These plans may be handcoded, but are usually the result of learning from previous planning situations. It is well known that also case-based planning may fail to improve efficiency and that the cases used must be similar to the actual instance at hand (Nebel & Koehler, 1995; Liberatore, 2005b). Also this can be explained as a special case of our Theorem 38.\nThe term annotated planning is sometimes used to refer to a number of similar techniques of adding control information to a planner. Examples are the Prodigy planner (Veloso et al., 1995) which allows control information like rules for goal ordering and Tlplan (Bacchus & Kabanza, 2000) which allows adding temporal-logic axioms to control the planner. While such techniques can be good if using hand-tailored control rules/axioms for a particular application domain, it is immediate from Theorem 38 that they cannot help us in the general case.\nPlanning with landmarks (Hoffmann, Porteous, & Sebastia, 2004) is the idea of adding explicit subgoals (called landmarks) to a planning instance. The intention is to tell the planner that the landmarks must be achieved by the plan in order to achieve its overall goal. Landmarks may also be ordered, to further guide the planner. However, as the authors themselves point out, deciding if a variable value (or logic formula) is a necessary subgoal is itself a PSPACE-complete problem. Hence, one usually considers incomplete sets of landmarks. More interestingly, landmarks differ from the previous methods above in a very important aspect; landmarks are added on the instance level, not on the frame level. Although this might not be quite a rigid difference in practice, it seems to be fundamental in essence. Hence, adding landmarks is a non-uniform case of adding information and it is thus not immediately covered by Theorem 38. How to meaningfully analyse the non-uniform case remains an open question."}, {"heading": "7.2 Causal Graphs", "text": "Knoblock (1994) defined an ordering on the variables of a planning instance which he used as a guidance for finding abstraction hierarchies. An ordering on the variables was fundamental also for the 3S class (Jonsson & Ba\u0308ckstro\u0308m, 1998b) and this ordering implicitly defined an abstraction hierarchy. The concept of an ordering on the variables with the intention of defining an abstraction hierarchy, define tractable subclasses etc. is nowadays usually referred to as a causal graph (see Chen & Gime\u0301nez, 2010, for a survey of using properties of the causal graph to define tractable subclasses of planning). Many papers still use Knoblock\u2019s definition, which is as follows:\nFor every Strips action a let Vpre(a) = Atoms(pre(a)) and Vpost(a) = Atoms(post(a)). Let\nf = \u3008V,A\u3009 be a Strips frame. The causal graph for f is the directed graph GCG = \u3008V,\u2264\u3009 where for all u, v \u2208 V , u \u2264 v if and only if both u 6= v and there is some a \u2208 A such that u \u2208 Vpre(a) \u222a Vpost(a) and v \u2208 Vpost(a).\nThe idea behind causal graphs is that each strongly connected component of the graph should correspond to an abstraction level. If applying this definition to examples in this paper, we find that an instance according to Construction 16 has a causal graph containing a large strongly connected component. That is, it would not be possible to form any good abstraction hierarchies for it based on such causal graphs. However, Theorem 25 says that plans for such instances seem not very likely to have useful compact representations anyway. Plans for the binary counter in Construction 5 do have polynomial Crars since they have polynomial macro plans. Yet, the whole causal graph for such an instance is also strongly connected. On the other hand, plans for the Gray counter in Construction 6 are exponential and have polynomial Crars too, but the causal graph is acyclic in this case. It thus seems that the causal graph of the type used by Knoblock and many others is not a sufficient, or even necessarily useful, tool for judging when plans have compact representations. There are other variants of causal graphs, though. One example is interaction networks (Chen & Gime\u0301nez, 2010). Another is Jonsson\u2019s (2009) refined version of Knoblock\u2019s causal graph, defined as follows:\nLet f = \u3008V,A\u3009 be a Strips frame. The refined causal graph for f is the directed graph GRCG = \u3008V,\u2264\u3009 where for all u, v \u2208 V , u \u2264 v if and only if u 6= v and either\n1) there is some a \u2208 A such that u \u2208 Vpre(a) \u2212 Vpost(a) and v \u2208 Vpost(a) or 2) there is some a \u2208 A such that u, v \u2208 Vpost(a) and either\na) there is some a\u2032 \u2208 A such that u \u2208 Vpost(a\u2032) and v 6\u2208 Vpost(a\u2032) or b) there is no a\u2032 \u2208 A such that u 6\u2208 Vpost(a\u2032) and v \u2208 Vpost(a\u2032).\nThe major difference between this variant and Knoblock\u2019s is that if two variables both appear in the postcondition of the same action, then they do not necessarily form a cycle in the graph. Hence, unary actions is no longer a prerequisite for acyclic graphs. If using the refined causal graph, then both the Gray counter and the binary counter have acyclic graphs, while Construction 16 still has a large strongly connected component. That is, in these three examples acyclicity of the refined causal graph correlates with whether plans have compact representations or not. While this correlation seems not to hold in general, the difference between the two types of causal graphs suggests that further study of variations on the concept could lead to further insight into the topic of compact representations. Should this turn out to be fruitful, then it would likely carry over also to other areas where causal graphs have been used, like model checking (Wehrle & Helmert, 2009)."}, {"heading": "7.3 Plan Explanation", "text": "The results in this paper are also important for plan explanation. Bidot et al. (2010) suggest that it is important for planning systems (and other AI systems) to be able to\nexplain their plans and decisions to the user, or else the user may not trust the system. Similarly, Southwick (1991) writes:\nThere seems to be a general agreement amongst those involved in KBS research that in order to be useful, a system must be able to explain its reasoning to a user.\nAlthough we do not consider any advanced explanation methods, as they do, our results have implications for what is possible to explain meaningfully. For plan explanation, our results are not necessarily as bad as for planning. Consider for example a plan for an instance of Construction 16. In the case where the 3SAT instance is unsatisfiable, almost the whole plan consists of an alternating sequence of the form \u3008a, b, a, b, a, b, . . .\u3009, where a denotes either of the actions aix 1, . . . , aixn and b denotes either of the actions avf 1, . . . , avf m. The first group are actions that together implement an increment function, and thus all serve the same purpose. Similarly, the second group consists of actions that all serve the purpose of verifying that some clause is false. An abstraction of this action sequence could have the form \u3008inc, vfy , inc, vfy , inc, vfy , . . .\u3009, where inc denotes any of the counting actions and vfy any of the verification actions. For the purpose of explanation, it seems useful to replace the actual actions with such abstract explanations of their functions. This abstract sequence is easier to understand, and it also allows using macros to compress it, which might further enhance its explaining power. However, in this particular case, it would probably be even more useful to abstract the whole sequence into a for loop, or similar. This essentially boils down to partitioning the set of actions into equivalence classes such that each such class consist of actions that can be meaningfully seen as implementing the same concept. It seems both interesting and important to investigate how and when one can partition the set of actions into equivalence classes useful for such abstractions.\nPlan explanation could also mean trace explanation in model checking, where we would analogously make a long trace shorter and more abstract in order to make it easier to understand. It is well known that there are close ties between planning and model checking, and that model-checking traces can be viewed as plans and vice versa (Edelkamp et al., 2007). The number of steps (or clock cycles) can be exponential in the number of state variables; even if the system is divided into subsystems, individual subsystems may have exponential behaviour which blows up when combined with other subsystems. An exponential-size plan/trace is not of much use to an engineer\u2014it is an almost impossible task to analyse and understand such a plan. If the planning/verifying system could autonomously find repetitive patterns, and even recursive repetitive patterns, in the plan and abstract these, then it would be considerably easier to understand what happens and why. In fact, it may not be interesting to execute the plan, even in a simulator, so a compact understandable explanation of the plan may be the actual goal.\nFurthermore, Geib (2004) discusses the problem of combinatorial explosion in plan recognition, where an exponential number of plans may share the plan prefix recognized so far. It could clearly be useful to have structured compact representations of plan candidates both to save space and to allow for more intelligent operations on these plans. Although this problem is slightly different from representing a single long plan, we have seen that these two problems are related.\nIn all these cases, the primary purpose of a compact representation would thus be to find and exploit some inherent structure in the plan, or set of plans, rather than to save space."}, {"heading": "7.4 Additional Related Work", "text": "Liberatore (2005a) has also studied the problem of representing plans compactly and there are similarities as well as differences between his results and ours. In contrast to us, he considers also plans represented as sequences of states, not only sequences of actions. For both cases, he considers a random access representation as well as a sequential representation. His random-access representation of action sequences (TA) is essentially the same as our Crar concept, except that he specifies that it must be implemented by a circuit. The sequential representation of action sequences (SA), on the other hand, is different from our Csar concept. It is a function that takes a state as input and returns the next state. Hence, it is more like a restricted type of reactive plan than a Csar, and his results are thus not immediately comparable to ours. For instance, contrary to our Theorem 29 he proves that a TA representation cannot be polynomially converted to an SA representation, which clearly shows that SA and Csar are quite different concepts. His proof that not all planning instances have plans with an SA representation does thus not obviously carry over also to Csars. Furthermore, he uses a planning language where actions are modelled as polynomial-size circuits. This coincides with our class FFP([P]). Hence, his hardness proofs are weaker than ours since we use the restricted Strips language in those cases. It should finally be noted that Liberatores Theorem 17 for the case of TA representations is a result similar to our Theorem 25, but we use different methods and different conditions.\nNebel (2000) defines a concept of compilation between planning languages. Although in some ways similar to our reformulation concept, there are also differences. A compilation is a function from a planning frame to another frame in a different planning language. This compilation need not be resource bounded but the resulting frame must be polynomially bounded in the original frame. The initial state and goal must then be possible to translate in polynomial time. That is, the first step corresponds to our function r while the second step essentially corresponds to our function R. However, Nebel only considers compilation between planning languages and also requires a concept of modularity that is not present in our approach. Furthermore, his focus is not on the complexity of the decision problem but on the question whether the size of solutions is preserved by compilations."}, {"heading": "7.5 Conclusions and Open Questions", "text": "The current status of our knowledge about non-uniform compact representations can be visualized as in Figure 6. The outer box represents the set of all solvable Strips instances while the inner boxes represent the subsets where at least one plan for each instance has a Csar, Crar or polynomial macro plan. We know classes where at least one plan for each instance is guaranteed to have a polynomial macro plan, like Towers of Hanoi and 3S. We also know classes where at least one plan for each instance has a Crar but we do not know if those plans also have a polynomial macro plan. Construction 16 is such an example. It is an open question if a plan can have a Crar but no polynomial macro plan. We further know classes where each instance has a plan with a Csar but where we do not know if they also have a Crar, for example, the class of reversible systems. However, Construction 26 is a class where all instances have a plan with a Csar but no plan with a Crar, so this case provides a strict separation between the Csar and Crar concepts. Whether there are classes of Strips instances where no plan has a Csar remains an open question, though.\nWe thus have the following chain of inclusions\npolynomial macro plans \u2286 Crar \u2282 Csar \u2286 Strips,\nwhere we do not know if the first and last inclusions are strict. Theorem 15 may seem weak since it is only conditioned with P 6= NP. Using similar techniques as in the proofs of Lemma 27 and Corollary 37 we could encode QBF with arbitrary number of alternating quantifiers and, hence, push the result up in the polynomial hierarchy. However, it remains an open question if the condition could be strengthened all the way to P 6= PSPACE.\nWhile we have argued that a number of results hold also when restricted to unary instances, and in some cases also other restrictions, this is otherwise a largely unexplored area. Little is currently known about how various structural and other restrictions affect the results in this paper. This applies both to whether plans have Csars and Crars and to whether they have polynomial-size macro plans.\nJust as we consider the non-uniform case of compact representations of single plans for single instances, it might also be interesting to consider the non-uniform case of reformulation and of adding information. However, this seems not straightforward since we could always reformulate an instance to a single bit telling whether the instance is solvable or not. Such a reformulation is clearly not interesting so additional criteria are necessary.\nWe have previously (Ba\u0308ckstro\u0308m & Jonsson, 2011a) defined a complexity measure based on padding which is intended to be insensitive to plan length. This concept seems related to Nebel\u2019s compilations, although the two concepts are not identical or directly comparable. It is thus reasonable to believe that also compact representations and padded complexity are somehow related, especially since padded complexity was motivated by instances with long plans. However, we do not yet know what this relationship is. Furthermore, it would\nbe interesting to consider compilations where we look at the size of compact representations of plan rather than the size of explicit plans."}, {"heading": "Acknowledgments", "text": "Malte Helmert, Anders Jonsson and the anonymous reviewers of this paper and the earlier conference version have provided valuable comments and suggestions."}], "references": [{"title": "Using temporal logics to express search control knowledge for planning", "author": ["F. Bacchus", "F. Kabanza"], "venue": "Artificial Intelligence,", "citeRegEx": "Bacchus and Kabanza,? \\Q2000\\E", "shortCiteRegEx": "Bacchus and Kabanza", "year": 2000}, {"title": "All PSPACE-complete planning problems are equal but some are more equal than others", "author": ["C. B\u00e4ckstr\u00f6m", "P. Jonsson"], "venue": "In Proceedings of the 4th International Symposium on Combinatorial Search (SoCS\u201911) Castell de Cardona, Barcelona,", "citeRegEx": "B\u00e4ckstr\u00f6m and Jonsson,? \\Q2011\\E", "shortCiteRegEx": "B\u00e4ckstr\u00f6m and Jonsson", "year": 2011}, {"title": "Limits for compact representations of plans", "author": ["C. B\u00e4ckstr\u00f6m", "P. Jonsson"], "venue": "In Proceedings of the 21st International Conference on Automated Planning and Scheduling,", "citeRegEx": "B\u00e4ckstr\u00f6m and Jonsson,? \\Q2011\\E", "shortCiteRegEx": "B\u00e4ckstr\u00f6m and Jonsson", "year": 2011}, {"title": "Computational Complexity of Reasoning about Plans", "author": ["C. B\u00e4ckstr\u00f6m"], "venue": "PhD dissertation, Link\u00f6ping University, Link\u00f6ping, Sweden.", "citeRegEx": "B\u00e4ckstr\u00f6m,? 1992", "shortCiteRegEx": "B\u00e4ckstr\u00f6m", "year": 1992}, {"title": "Expressive equivalence of planning formalisms", "author": ["C. B\u00e4ckstr\u00f6m"], "venue": "Artificial Intelligence, 76 (1-2), 17\u201334.", "citeRegEx": "B\u00e4ckstr\u00f6m,? 1995", "shortCiteRegEx": "B\u00e4ckstr\u00f6m", "year": 1995}, {"title": "Planning with abstraction hierarchies can be exponentially less efficient", "author": ["C. B\u00e4ckstr\u00f6m", "P. Jonsson"], "venue": "In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI\u201995),", "citeRegEx": "B\u00e4ckstr\u00f6m and Jonsson,? \\Q1995\\E", "shortCiteRegEx": "B\u00e4ckstr\u00f6m and Jonsson", "year": 1995}, {"title": "Planning in polynomial time: The SAS-PUBS class", "author": ["C. B\u00e4ckstr\u00f6m", "I. Klein"], "venue": "Computational Intelligence,", "citeRegEx": "B\u00e4ckstr\u00f6m and Klein,? \\Q1991\\E", "shortCiteRegEx": "B\u00e4ckstr\u00f6m and Klein", "year": 1991}, {"title": "The complexity of searching implicit graphs", "author": ["J. Balc\u00e1zar"], "venue": "Artificial Intelligence, 86 (1), 171\u2013188.", "citeRegEx": "Balc\u00e1zar,? 1996", "shortCiteRegEx": "Balc\u00e1zar", "year": 1996}, {"title": "Verbal plan explanations for hybrid planning", "author": ["J. Bidot", "S. Biundo", "T. Heinroth", "W. Minker", "F. Nothdurft", "B. Schattenberg"], "venue": "In Proceedings of the 24th MKWI related PuK-workshop: Planung/Scheduling und Konfigurieren/Entwurfen", "citeRegEx": "Bidot et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Bidot et al\\.", "year": 2010}, {"title": "Random access to grammar-compressed strings", "author": ["P. Bille", "G. Landau", "R. Raman", "K. Sadakane", "S. Satti", "O. Weimann"], "venue": "In Proceedings of the 22\u2019nd ACM-SIAM Symposium on Discrete Algorithms (SODA\u201911),", "citeRegEx": "Bille et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Bille et al\\.", "year": 2011}, {"title": "Conformant plans and beyond: Principles and complexity", "author": ["B. Bonet"], "venue": "Artificial Intelligence, 174 (3-4), 245\u2013269.", "citeRegEx": "Bonet,? 2010", "shortCiteRegEx": "Bonet", "year": 2010}, {"title": "Planning with incomplete information as heuristic search in belief space", "author": ["B. Bonet", "H. Geffner"], "venue": "In Proceedings of the 5th International Conference on Artificial Intelligence Planning Systems (AIPS\u201900),", "citeRegEx": "Bonet and Geffner,? \\Q2000\\E", "shortCiteRegEx": "Bonet and Geffner", "year": 2000}, {"title": "Computing optimal policies for partially observable decision processes using compact representations", "author": ["C. Boutilier", "D. Poole"], "venue": "In Proceedings of the 13th National Conference on Artificial Intelligence (AAAI\u201996), Portland, OR, USA,", "citeRegEx": "Boutilier and Poole,? \\Q1996\\E", "shortCiteRegEx": "Boutilier and Poole", "year": 1996}, {"title": "Structure and complexity in planning with unary operators", "author": ["R.I. Brafman", "C. Domshlak"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Brafman and Domshlak,? \\Q2003\\E", "shortCiteRegEx": "Brafman and Domshlak", "year": 2003}, {"title": "New applications of the incompressibility method: Part II", "author": ["H. Buhrman", "T. Jiang", "M. Li", "P.M.B. Vit\u00e1nyi"], "venue": "Theoretical Computer Science,", "citeRegEx": "Buhrman et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Buhrman et al\\.", "year": 2000}, {"title": "A simple algorithm for Mal\u2019tsev constraints", "author": ["A. Bulatov", "V. Dalmau"], "venue": "SIAM Journal of Computing,", "citeRegEx": "Bulatov and Dalmau,? \\Q2006\\E", "shortCiteRegEx": "Bulatov and Dalmau", "year": 2006}, {"title": "The computational complexity of propositional STRIPS planning", "author": ["T. Bylander"], "venue": "Artificial Intelligence, 69 (1-2), 165\u2013204.", "citeRegEx": "Bylander,? 1994", "shortCiteRegEx": "Bylander", "year": 1994}, {"title": "Space efficiency of propositional knowledge representation formalisms", "author": ["M. Cadoli", "F. Donini", "P. Liberatore", "M. Schaerf"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Cadoli et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Cadoli et al\\.", "year": 2000}, {"title": "The smallest grammar problem", "author": ["M. Charikar", "E. Lehman", "D. Liu", "R. Panigrahy", "M. Prabhakaran", "A. Sahai", "A. Shelat"], "venue": "IEEE Transactions on Information Theory,", "citeRegEx": "Charikar et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Charikar et al\\.", "year": 2005}, {"title": "Causal graphs and structurally restricted planning", "author": ["H. Chen", "O. Gim\u00e9nez"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Chen and Gim\u00e9nez,? \\Q2010\\E", "shortCiteRegEx": "Chen and Gim\u00e9nez", "year": 2010}, {"title": "Summary of Dagstuhl seminar 06172 on directed model checking", "author": ["S. Edelkamp", "S. Leue", "W. Visser"], "venue": "In Directed Model Checking,", "citeRegEx": "Edelkamp et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Edelkamp et al\\.", "year": 2007}, {"title": "Succinct representations of graphs", "author": ["H. Galperin", "A. Wigderson"], "venue": "Information and Control,", "citeRegEx": "Galperin and Wigderson,? \\Q1983\\E", "shortCiteRegEx": "Galperin and Wigderson", "year": 1983}, {"title": "Assessing the complexity of plan recognition", "author": ["C. Geib"], "venue": "Proceedings of the 19th National Conference on Artificial Intelligence (AAAI\u201904), San Jos\u00e9, CA, USA, pp. 507\u2013512.", "citeRegEx": "Geib,? 2004", "shortCiteRegEx": "Geib", "year": 2004}, {"title": "Applied Algebra for the Computer Sciences", "author": ["A. Gill"], "venue": "Prentice Hall. Englewood Cliffs, NJ.", "citeRegEx": "Gill,? 1976", "shortCiteRegEx": "Gill", "year": 1976}, {"title": "The complexity of planning problems with simple causal graphs", "author": ["O. Gim\u00e9nez", "A. Jonsson"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Gim\u00e9nez and Jonsson,? \\Q2008\\E", "shortCiteRegEx": "Gim\u00e9nez and Jonsson", "year": 2008}, {"title": "Planning with reduced operator sets", "author": ["P. Haslum", "P. Jonsson"], "venue": "In Proceedings of the 5th International Conference on Artificial Intelligence Planning Systems (AIPS\u201900),", "citeRegEx": "Haslum and Jonsson,? \\Q2000\\E", "shortCiteRegEx": "Haslum and Jonsson", "year": 2000}, {"title": "Ordered landmarks in planning", "author": ["J. Hoffmann", "J. Porteous", "L. Sebastia"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Hoffmann et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Hoffmann et al\\.", "year": 2004}, {"title": "Compressed random access memory. ArXiv, abs/1011.1708v2", "author": ["J. Jansson", "K. Sadakane", "Sung", "W.-K"], "venue": null, "citeRegEx": "Jansson et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Jansson et al\\.", "year": 2012}, {"title": "On generating all maximal independent sets", "author": ["D.S. Johnson", "C.H. Papadimitriou", "M. Yannakakis"], "venue": "Information Processing Letters,", "citeRegEx": "Johnson et al\\.,? \\Q1988\\E", "shortCiteRegEx": "Johnson et al\\.", "year": 1988}, {"title": "The role of macros in tractable planning", "author": ["A. Jonsson"], "venue": "Journal of Artificial Intelligence Research, 36, 471\u2013511.", "citeRegEx": "Jonsson,? 2009", "shortCiteRegEx": "Jonsson", "year": 2009}, {"title": "State-variable planning under structural restrictions: Algorithms and complexity", "author": ["P. Jonsson", "C. B\u00e4ckstr\u00f6m"], "venue": "Artificial Intelligence,", "citeRegEx": "Jonsson and B\u00e4ckstr\u00f6m,? \\Q1998\\E", "shortCiteRegEx": "Jonsson and B\u00e4ckstr\u00f6m", "year": 1998}, {"title": "Tractable plan existence does not imply tractable plan generation", "author": ["P. Jonsson", "C. B\u00e4ckstr\u00f6m"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "Jonsson and B\u00e4ckstr\u00f6m,? \\Q1998\\E", "shortCiteRegEx": "Jonsson and B\u00e4ckstr\u00f6m", "year": 1998}, {"title": "Towards efficient universal planning: A randomized approach", "author": ["P. Jonsson", "P. Haslum", "C. B\u00e4ckstr\u00f6m"], "venue": "Artificial Intelligence,", "citeRegEx": "Jonsson et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Jonsson et al\\.", "year": 2000}, {"title": "Some connections between nonuniform and uniform complexity classes", "author": ["R.M. Karp", "R.J. Lipton"], "venue": "In Proceedings of the 12th ACM Symposium on Theory of Computing (STOC\u201980),", "citeRegEx": "Karp and Lipton,? \\Q1980\\E", "shortCiteRegEx": "Karp and Lipton", "year": 1980}, {"title": "Planning as satisfiability", "author": ["H.A. Kautz", "B. Selman"], "venue": "In Proceedings of the 10th European Conference on Artificial Intelligence (ECAI\u201992), Vienna,", "citeRegEx": "Kautz and Selman,? \\Q1992\\E", "shortCiteRegEx": "Kautz and Selman", "year": 1992}, {"title": "Generating Abstraction Hierarchies: An Automated Approach to Reducing Search in Planning", "author": ["C.A. Knoblock"], "venue": "Kluwer Academic Publishers. Norwell, MA.", "citeRegEx": "Knoblock,? 1993", "shortCiteRegEx": "Knoblock", "year": 1993}, {"title": "Automatically generating abstractions for planning", "author": ["C.A. Knoblock"], "venue": "Artificial Intelligence, 68 (2), 243\u2013302.", "citeRegEx": "Knoblock,? 1994", "shortCiteRegEx": "Knoblock", "year": 1994}, {"title": "Macro-operators: A weak method for learning", "author": ["R.E. Korf"], "venue": "Artificial Intelligence, 26 (1), 35\u201377.", "citeRegEx": "Korf,? 1985", "shortCiteRegEx": "Korf", "year": 1985}, {"title": "Planning as search: A quantitative approach", "author": ["R.E. Korf"], "venue": "Artificial Intelligence, 33 (1), 65\u201388.", "citeRegEx": "Korf,? 1987", "shortCiteRegEx": "Korf", "year": 1987}, {"title": "On the size of data structures used in symbolic model checking. ArXiv, abs/1012.3018", "author": ["P. Liberatore", "M. Schaerf"], "venue": null, "citeRegEx": "Liberatore and Schaerf,? \\Q2010\\E", "shortCiteRegEx": "Liberatore and Schaerf", "year": 2010}, {"title": "Complexity issues in finding succinct solutions of PSPACE-complete problems", "author": ["P. Liberatore"], "venue": "ArXiv, abs/cs/0503043.", "citeRegEx": "Liberatore,? 2005a", "shortCiteRegEx": "Liberatore", "year": 2005}, {"title": "On the complexity of case-based planning", "author": ["P. Liberatore"], "venue": "Journal of Experimental and Theoretical Artificial Intelligence, 17 (3), 283\u2013295.", "citeRegEx": "Liberatore,? 2005b", "shortCiteRegEx": "Liberatore", "year": 2005}, {"title": "Reformulation in planning", "author": ["D. Long", "M. Fox", "M. Hamdi"], "venue": "In Proceedings of the 5th International Symposium on Abstraction, Reformulation and Approximation (SARA\u201902), Kananaskis, AB, Canada,", "citeRegEx": "Long et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Long et al\\.", "year": 2002}, {"title": "Remote agent: To boldly go where no AI system has gone before", "author": ["N. Muscettola", "P. Pandurang Nayak", "B. Pell", "B.C. Williams"], "venue": "Artificial Intelligence,", "citeRegEx": "Muscettola et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Muscettola et al\\.", "year": 1998}, {"title": "On the compilability and expressive power of propositional planning formalisms", "author": ["B. Nebel"], "venue": "Journal of Artificial Intelligence Research, 12, 271\u2013315.", "citeRegEx": "Nebel,? 2000", "shortCiteRegEx": "Nebel", "year": 2000}, {"title": "Plan reuse versus plan generation: A theoretical and empirical analysis", "author": ["B. Nebel", "J. Koehler"], "venue": "Artificial Intelligence,", "citeRegEx": "Nebel and Koehler,? \\Q1995\\E", "shortCiteRegEx": "Nebel and Koehler", "year": 1995}, {"title": "Application of Lempel-Ziv factorization to the approximation of grammar-based compression", "author": ["W. Rytter"], "venue": "Theoretical Computer Science, 302 (1-3), 211\u2013222.", "citeRegEx": "Rytter,? 2003", "shortCiteRegEx": "Rytter", "year": 2003}, {"title": "Planning in a hierarchy of abstraction spaces", "author": ["E.D. Sacerdoti"], "venue": "Artificial Intelligence, 5 (2), 115\u2013135.", "citeRegEx": "Sacerdoti,? 1974", "shortCiteRegEx": "Sacerdoti", "year": 1974}, {"title": "Explaining reasoning: An overview of explanation in knowledgebased systems", "author": ["R.W. Southwick"], "venue": "Knowledge Engineering Review, 6, 1\u201319.", "citeRegEx": "Southwick,? 1991", "shortCiteRegEx": "Southwick", "year": 1991}, {"title": "A survey on case-based planning", "author": ["L. Spalazzi"], "venue": "Artificial Intelligence Review, 16, 3\u201336.", "citeRegEx": "Spalazzi,? 2001", "shortCiteRegEx": "Spalazzi", "year": 2001}, {"title": "Integrating planning and learning: The PRODIGY architecture", "author": ["M.M. Veloso", "J.G. Carbonell", "A. P\u00e9rez", "D. Borrajo", "E. Fink", "J. Blythe"], "venue": "Journal of Experimental and Theoretical Artificial Intelligence Research,", "citeRegEx": "Veloso et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Veloso et al\\.", "year": 1995}, {"title": "The complexity of combinatorial problems with succinct input representation", "author": ["K. Wagner"], "venue": "Acta Informatica, 23 (3), 325\u2013356.", "citeRegEx": "Wagner,? 1986", "shortCiteRegEx": "Wagner", "year": 1986}, {"title": "The causal graph revisited for directed model checking", "author": ["M. Wehrle", "M. Helmert"], "venue": "In Proceedings of the 16th International Symposium on Static Analysis (SAS\u201909),", "citeRegEx": "Wehrle and Helmert,? \\Q2009\\E", "shortCiteRegEx": "Wehrle and Helmert", "year": 2009}, {"title": "A reactive planner for a model-based executive", "author": ["B. Williams", "P. Pandurang Nayak"], "venue": "In Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI\u201997),", "citeRegEx": "Williams and Nayak,? \\Q1997\\E", "shortCiteRegEx": "Williams and Nayak", "year": 1997}, {"title": "Some consequences of non-uniform conditions on uniform classes", "author": ["Yap", "C.-K."], "venue": "Theoretical Computer Science, 26, 287\u2013300.", "citeRegEx": "Yap and C..K.,? 1983", "shortCiteRegEx": "Yap and C..K.", "year": 1983}], "referenceMentions": [{"referenceID": 22, "context": "For instance, plan recognition may have to simultaneously consider an exponential number of candidate plans (Geib, 2004).", "startOffset": 108, "endOffset": 120}, {"referenceID": 12, "context": "For example, Charikar et al. (2005) and Rytter (2003) address the problem of approximating the smallest string representation using a compressed grammar.", "startOffset": 13, "endOffset": 36}, {"referenceID": 12, "context": "For example, Charikar et al. (2005) and Rytter (2003) address the problem of approximating the smallest string representation using a compressed grammar.", "startOffset": 13, "endOffset": 54}, {"referenceID": 6, "context": "Bille et al. (2011) show that such representations permit efficient access and matching operations, while Jansson, Sadakane, and Sung (2012) demonstrate representations with efficient edit operations.", "startOffset": 0, "endOffset": 20}, {"referenceID": 6, "context": "Bille et al. (2011) show that such representations permit efficient access and matching operations, while Jansson, Sadakane, and Sung (2012) demonstrate representations with efficient edit operations.", "startOffset": 0, "endOffset": 141}, {"referenceID": 6, "context": "Bille et al. (2011) show that such representations permit efficient access and matching operations, while Jansson, Sadakane, and Sung (2012) demonstrate representations with efficient edit operations. More structured objects than arbitrary strings can potentially have more compact representations. The following are some examples, displaying positive as well as negative results in various areas. Both Galperin and Wigderson (1983) and Wagner (1986) study the complexity of common graph operations when the graphs are implicitly represented as circuits that tell whether two vertices are connected.", "startOffset": 0, "endOffset": 433}, {"referenceID": 6, "context": "Bille et al. (2011) show that such representations permit efficient access and matching operations, while Jansson, Sadakane, and Sung (2012) demonstrate representations with efficient edit operations. More structured objects than arbitrary strings can potentially have more compact representations. The following are some examples, displaying positive as well as negative results in various areas. Both Galperin and Wigderson (1983) and Wagner (1986) study the complexity of common graph operations when the graphs are implicitly represented as circuits that tell whether two vertices are connected.", "startOffset": 0, "endOffset": 451}, {"referenceID": 5, "context": "Balc\u00e1zar (1996) uses a variant of that approach to study the complexity of search in AI, using a circuit that generates the adjacency list for a vertex.", "startOffset": 0, "endOffset": 16}, {"referenceID": 5, "context": "Balc\u00e1zar (1996) uses a variant of that approach to study the complexity of search in AI, using a circuit that generates the adjacency list for a vertex. Bulatov and Dalmau (2006) present an efficient algorithm for certain CSP problems that relies on using a compact representation of the set of solutions.", "startOffset": 0, "endOffset": 179}, {"referenceID": 5, "context": "Balc\u00e1zar (1996) uses a variant of that approach to study the complexity of search in AI, using a circuit that generates the adjacency list for a vertex. Bulatov and Dalmau (2006) present an efficient algorithm for certain CSP problems that relies on using a compact representation of the set of solutions. Liberatore and Schaerf (2010) study preprocessing in model checking with focus on the size of the preprocessed parts.", "startOffset": 0, "endOffset": 336}, {"referenceID": 5, "context": "Balc\u00e1zar (1996) uses a variant of that approach to study the complexity of search in AI, using a circuit that generates the adjacency list for a vertex. Bulatov and Dalmau (2006) present an efficient algorithm for certain CSP problems that relies on using a compact representation of the set of solutions. Liberatore and Schaerf (2010) study preprocessing in model checking with focus on the size of the preprocessed parts. Cadoli et al. (2000) study various formalisms for knowledge representation and study when problems modelled in one formalism can be transformed into another formalism with at most a polynomially larger representation.", "startOffset": 0, "endOffset": 445}, {"referenceID": 3, "context": "The 3S class (Jonsson & B\u00e4ckstr\u00f6m, 1998b) of planning instances has the property that optimal plans can be of exponential length but it is always possible to decide in polynomial time if there is a plan or not. Gim\u00e9nez and Jonsson (2008) showed that plans for the 3S class always have a polynomial-size representation using macros, and that macro plans can even be generated in polynomial time.", "startOffset": 24, "endOffset": 238}, {"referenceID": 3, "context": "The 3S class (Jonsson & B\u00e4ckstr\u00f6m, 1998b) of planning instances has the property that optimal plans can be of exponential length but it is always possible to decide in polynomial time if there is a plan or not. Gim\u00e9nez and Jonsson (2008) showed that plans for the 3S class always have a polynomial-size representation using macros, and that macro plans can even be generated in polynomial time. That is, although the plan may be of exponential length, and thus necessarily take exponential time to generate, it is possible to generate a compact representation of it in polynomial time. Jonsson (2009) later demonstrated similar results for a number of other classes.", "startOffset": 24, "endOffset": 601}, {"referenceID": 3, "context": "The 3S class (Jonsson & B\u00e4ckstr\u00f6m, 1998b) of planning instances has the property that optimal plans can be of exponential length but it is always possible to decide in polynomial time if there is a plan or not. Gim\u00e9nez and Jonsson (2008) showed that plans for the 3S class always have a polynomial-size representation using macros, and that macro plans can even be generated in polynomial time. That is, although the plan may be of exponential length, and thus necessarily take exponential time to generate, it is possible to generate a compact representation of it in polynomial time. Jonsson (2009) later demonstrated similar results for a number of other classes. Although these particular classes of planning instances may still be too restricted to be of much practical use, the principle of compressing the solution using macros is an interesting tool both for planning and plan explanation. Other approaches to compact plan representation appear only sparingly in the literature. A notable exception is Liberatore (2005a) who studies two concepts for plan representation that have efficient random access and efficient sequential access respectively.", "startOffset": 24, "endOffset": 1029}, {"referenceID": 10, "context": "Yet another case is when the size of the plan is big but the plan is not necessarily long, which can occur for various types of branching plans, as in contingent planning (Bonet & Geffner, 2000). These three different concepts are not isolated from each other. For instance, Bonet (2010) casts contingent planning into the problem of conformant planning, that is, a branching plan is represented as one long non-branching plan, with the branches appearing as subplans.", "startOffset": 172, "endOffset": 288}, {"referenceID": 29, "context": "The positive results on macro representations (Gim\u00e9nez & Jonsson, 2008; Jonsson, 2009) prompt the obvious question whether long plans can always be compressed using macros (or any other method).", "startOffset": 46, "endOffset": 86}, {"referenceID": 4, "context": "There are a number of common variants of propositional Strips that are known to be equivalent to each other and to the SAS+ formalism under a strong form of polynomial reduction (B\u00e4ckstr\u00f6m, 1995).", "startOffset": 178, "endOffset": 195}, {"referenceID": 43, "context": "Unary actions may seem like a very limiting restriction but has been demonstrated as sufficient in many cases for use in on-board controllers for spacecrafts (Muscettola et al., 1998; Brafman & Domshlak, 2003).", "startOffset": 158, "endOffset": 209}, {"referenceID": 16, "context": "This is not surprising, though, since Strips planning is PSPACE-complete and remains so even when restricted to unary actions (Bylander, 1994).", "startOffset": 126, "endOffset": 142}, {"referenceID": 40, "context": "Liberatore (2005a) discusses a similar representation, where instead of specifying an algorithm he defines a lexiographic ordering on the actions.", "startOffset": 0, "endOffset": 19}, {"referenceID": 38, "context": "Macros can be useful for planning if there are certain subsequences of actions that occur frequently in plans (Korf, 1987).", "startOffset": 110, "endOffset": 122}, {"referenceID": 3, "context": "The 3S class of planning instances (Jonsson & B\u00e4ckstr\u00f6m, 1998b) has the property that we can always find out in polynomial time if an instance has a plan, but the plan itself may be of exponential length and thus cannot be generated in subexponential time. Gim\u00e9nez and Jonsson (2008) showed that plans for 3S instances always have a polynomial-size representation using macros.", "startOffset": 46, "endOffset": 284}, {"referenceID": 9, "context": "Furthermore, such a compressed grammar permits efficient random access into the string it represents; both the access and the necessary preprocessing is polynomial time in the size of the grammar (Bille et al., 2011).", "startOffset": 196, "endOffset": 216}, {"referenceID": 27, "context": "of planning instances by Jonsson (2009). We will show that polynomial-size macro plans have an immediate connection to compact plan representations.", "startOffset": 25, "endOffset": 40}, {"referenceID": 34, "context": "Reformulation of planning into SAT was first suggested by Kautz and Selman (1992) and is still a popular approach to planning.", "startOffset": 58, "endOffset": 82}, {"referenceID": 34, "context": "Reformulation of planning into SAT was first suggested by Kautz and Selman (1992) and is still a popular approach to planning. Long, Fox, and Hamdi (2002) discuss reformulation for planning in general and Edelkamp, Leue, and Visser (2007) discuss the connections between model checking and planning.", "startOffset": 58, "endOffset": 155}, {"referenceID": 34, "context": "Reformulation of planning into SAT was first suggested by Kautz and Selman (1992) and is still a popular approach to planning. Long, Fox, and Hamdi (2002) discuss reformulation for planning in general and Edelkamp, Leue, and Visser (2007) discuss the connections between model checking and planning.", "startOffset": 58, "endOffset": 239}, {"referenceID": 44, "context": "It should be noted that this reformulation concept is similar, although not identical, to the compilation concept used by Nebel (2000).", "startOffset": 122, "endOffset": 135}, {"referenceID": 47, "context": "State space abstraction in planning goes back at least to the Abstrips planner (Sacerdoti, 1974).", "startOffset": 79, "endOffset": 96}, {"referenceID": 38, "context": "Also the use of macros has been demonstrated to speed up planning considerably in certain cases (Korf, 1987).", "startOffset": 96, "endOffset": 108}, {"referenceID": 37, "context": "Macros are typically added on the frame level, and learning has been suggested as one method to create macros automatically (Korf, 1985).", "startOffset": 124, "endOffset": 136}, {"referenceID": 32, "context": "Knoblock (1994) proposed an algorithm for automatically computing such abstraction hierarchies.", "startOffset": 0, "endOffset": 16}, {"referenceID": 41, "context": "It is well known that also case-based planning may fail to improve efficiency and that the cases used must be similar to the actual instance at hand (Nebel & Koehler, 1995; Liberatore, 2005b).", "startOffset": 149, "endOffset": 191}, {"referenceID": 50, "context": "Examples are the Prodigy planner (Veloso et al., 1995) which allows control information like rules for goal ordering and Tlplan (Bacchus & Kabanza, 2000) which allows adding temporal-logic axioms to control the planner.", "startOffset": 33, "endOffset": 54}, {"referenceID": 29, "context": "Another is Jonsson\u2019s (2009) refined version of Knoblock\u2019s causal graph, defined as follows:", "startOffset": 11, "endOffset": 28}, {"referenceID": 8, "context": "Bidot et al. (2010) suggest that it is important for planning systems (and other AI systems) to be able to", "startOffset": 0, "endOffset": 20}, {"referenceID": 48, "context": "Similarly, Southwick (1991) writes:", "startOffset": 11, "endOffset": 28}, {"referenceID": 20, "context": "It is well known that there are close ties between planning and model checking, and that model-checking traces can be viewed as plans and vice versa (Edelkamp et al., 2007).", "startOffset": 149, "endOffset": 172}, {"referenceID": 20, "context": "It is well known that there are close ties between planning and model checking, and that model-checking traces can be viewed as plans and vice versa (Edelkamp et al., 2007). The number of steps (or clock cycles) can be exponential in the number of state variables; even if the system is divided into subsystems, individual subsystems may have exponential behaviour which blows up when combined with other subsystems. An exponential-size plan/trace is not of much use to an engineer\u2014it is an almost impossible task to analyse and understand such a plan. If the planning/verifying system could autonomously find repetitive patterns, and even recursive repetitive patterns, in the plan and abstract these, then it would be considerably easier to understand what happens and why. In fact, it may not be interesting to execute the plan, even in a simulator, so a compact understandable explanation of the plan may be the actual goal. Furthermore, Geib (2004) discusses the problem of combinatorial explosion in plan recognition, where an exponential number of plans may share the plan prefix recognized so far.", "startOffset": 150, "endOffset": 954}], "year": 2012, "abstractText": "Compact representations of objects is a common concept in computer science. Automated planning can be viewed as a case of this concept: a planning instance is a compact implicit representation of a graph and the problem is to find a path (a plan) in this graph. While the graphs themselves are represented compactly as planning instances, the paths are usually represented explicitly as sequences of actions. Some cases are known where the plans always have compact representations, for example, using macros. We show that these results do not extend to the general case, by proving a number of bounds for compact representations of plans under various criteria, like efficient sequential or random access of actions. In addition to this, we show that our results have consequences for what can be gained from reformulating planning into some other problem. As a contrast to this we also prove a number of positive results, demonstrating restricted cases where plans do have useful compact representations, as well as proving that macro plans have favourable access properties. Our results are finally discussed in relation to other relevant contexts.", "creator": "TeX"}}}