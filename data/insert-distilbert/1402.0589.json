{"id": "1402.0589", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Protecting Privacy through Distributed Computation in Multi-agent Decision Making", "abstract": "as large - scale theft of data from corporate servers is becoming increasingly common, it becomes interesting to subtly examine different alternatives to the paradigm required of actively centralizing access sensitive data into large databases. instead, one could use cryptography and enable distributed computation so that sensitive data can be supplied and processed in encrypted form, hence and only the final result is made known. in this paper, we examine how such a paradigm can be used to implement constraint satisfaction, a technique that can solve a hypothetical broad class of ai problems such as resource allocation, planning, scheduling, and diagnosis. most previous work on privacy in constraint satisfaction only limited attempted experiments to informally protect specific types of confidential information, in particular the feasibility of particular combinations of decisions. we better formalize specifically and extend clarify these restricted notions of privacy by introducing four types of private information, including the inherent feasibility of decisions and the final decisions made, but also the spatial identities of the participants and recognizing the topology constituents of the problem. we present distributed algorithms that allow computing solutions to constraint satisfaction problems while maintaining altogether these four types of privacy. we formally prove the privacy properties proposed of these algorithms, and show experiments that compare their respective performance on particular benchmark problems.", "histories": [["v1", "Tue, 4 Feb 2014 01:44:50 GMT  (157kb)", "http://arxiv.org/abs/1402.0589v1", null], ["v2", "Sat, 12 Jul 2014 22:20:22 GMT  (2124kb)", "http://arxiv.org/abs/1402.0589v2", null]], "reviews": [], "SUBJECTS": "cs.AI cs.CR cs.MA", "authors": ["thomas leaute", "boi faltings"], "accepted": false, "id": "1402.0589"}, "pdf": {"name": "1402.0589.pdf", "metadata": {"source": "CRF", "title": "Protecting Privacy through Distributed Computation in Multi-agent Decision Making Online Appendix 3: Unique ID Generation Algorithm", "authors": ["Thomas L\u00e9aut\u00e9", "Boi Faltings"], "emails": ["thomas.leaute@a3.epfl.ch", "boi.faltings@epfl.ch"], "sections": [{"heading": "Protecting Privacy through Distributed Computation", "text": "in Multi-agent Decision Making\nOnline Appendix 3: Unique ID Generation Algorithm\nThomas Le\u0301aute\u0301 thomas.leaute@a3.epfl.ch Boi Faltings boi.faltings@epfl.ch\nThe assignment of unique IDs to n variables is an instance of the well-known renaming problem, for which multiple algorithms have been proposed in the literature on distributed algorithms. However, to our knowledge, all these algorithms focus on robustness to failures, and ignore the issue of privacy. On the contrary, in this paper we do not consider agent failures, and we rather need an algorithm that protects agent and topology privacy. To this purpose, we propose Algorithm 1, which is a modification of the pseudo-tree generation algorithm in Online Appendix 2, and is an improved version of the algorithm proposed by Le\u0301aute\u0301 and Faltings (2009). Each variable x is assigned a unique number idx that corresponds to the order in which it is first visited during the distributed traversal of the constraint graph (or, more precisely, an upper bound thereon). This is done by appending to each CHILD message the number id of variables visited so far (lines 8, 29 and 31). Each variable adds a random number to id so as not to leak any useful upper bound on its number of neighbors (lines 5 and 15). At the end of this algorithm, the root variable discovers an upper bound n+ on the total number of variables, and reveals it to everyone (lines 35 and 22 to 24).\nTheorem 1. The unique variable ID assignment algorithm guarantees full agent privacy, and partial topology privacy. The minor leaks of topology privacy lie in the fact that a variable might be able to discover:\n\u2022 upper and lower bounds on the total number of variables;\n\u2022 that there exists another branch in the constraint graph that it is not involved in.\nProof. This is a modification of the depth-first traversal of the constraint graph in Online Appendix 2, which was shown to guarantee full agent privacy and full topology privacy. One difference is that the messages now also carry an integer id that is an upper bound on the number of variables visited so far, which cannot be used to make inferences about the identities of agents, but is a source of (minor) topology privacy leaks, as described below.\n\u2022 When receiving a CHILD message from its parent, variable x discovers that there exist at most id other variables in the problem that have already been visited. These variables are either ancestors of its parent, or descendants of its parent in another branch of the pseudo-tree. To make sure this bound is loose and uninformative, each variable adds a random number in [incrmin . . . 2incrmin] to its id, where incrmin is a free parameter of the algorithm. In particular, this prevents the case id = 1, which\n\u00a92013 AI Access Foundation. All rights reserved.\nAlgorithm 1 Pseudo-tree and unique ID generation algorithm for variable x\nRequire: a root variable 1: if x has at least one neighbor then 2: openx \u2190 \u2205 3: if x has been elected as the root then 4: idx \u2190 0 5: id+x \u2190 idx + rand(incrmin . . . 2incrmin) 6: openx \u2190 all neighbors of x 7: Remove a random neighbor y0 from openx and add it to childrenx 8: Send the message (CHILD, id+x + 1) to y0 9: loop 10: Wait for an incoming message (type, id) from a neighbor yi\n11: if openx = \u2205 then // first time x is visited 12: openx \u2190 all neighbors of x except yi 13: parentx \u2190 yi 14: idx \u2190 id 15: id+x \u2190 idx + rand(incrmin . . . 2incrmin) 16: else if type = CHILD and yi \u2208 openx then 17: Remove yi from openx and add it to pseudo childrenx 18: Send message (PSEUDO, id) to yi 19: next\n20: else if type = PSEUDO then 21: Remove yi from childrenx and add it to pseudo parentsx\n22: else if type = NBRVARS then 23: n+ \u2190 id // upper bound on the true number of variables n 24: break\n25: // Forward the CHILD message to the next open neighbor: 26: Choose a random yj \u2208 openx 27: if there exists such a yj then 28: Remove yi from openx and add it to childrenx 29: Send the message (CHILD, max(id, id+x + 1)) to yj 30: else if x is not the elected root then // backtrack 31: Send message (CHILD, max(id, id+x + 1)) to parentx 32: else 33: n+ \u2190 id // upper bound on the true number of variables n 34: break 35: Send message (NBRVARS, n+) to all children of x\nwould allow x to infer that its parent is the root of the pseudo-tree, and that x is its first child. Variable x also discovers that there exist at least bid/(2incrmin)c alreadyvisited variables. Notice that these two bounds are not informative about the topology\nof the constraint graph, since the P3/2-DPOP(+) and P2-DPOP(+) algorithms leak the total number of variables anyway.\n\u2022 When receiving a CHILD message from a child y, variable x can compare the id it contains with the id it previously sent to y. The difference \u2206id \u2265 incrmin is an upper bound on the number of y\u2019s descendants; the parameter incrmin can be chosen as large as necessary to make this bound as loose as desired. Variable x also discovers that b\u2206id/(2incrmin)c is a lower bound on the number of y\u2019s descendants.\n\u2022 The id contained in a PSEUDO message does not provide any information, as it is equal to the id in the CHILD message to which the PSEUDO message is a response. In fact, id could be removed from the PSEUDO message; it has only be left in Algorithm 1 for the sake of conciseness of the pseudo-code.\nOnce all variables have been assigned unique IDs, the last such ID is revealed to all variables (and is recorded as n+). This reveals an upper bound on the total number of variables, which is useless since the exact total number of variables is later revealed anyway by the P3/2DPOP(+) and P2-DPOP(+) algorithms. However, it also reveals to each variable whether it is the last visited variable, i.e. the last leaf of the pseudo-tree. This is another, minor leak of topology privacy, since the leaves of the pseudo-tree that are not the last leaf discover that there exists at least one other branch in the pseudo-tree (and therefore in the constraint graph) that they are not involved in."}], "references": [{"title": "Privacy-preserving multi-agent constraint satisfaction", "author": ["T. L\u00e9aut\u00e9", "B. Faltings"], "venue": "In Proceedings of the 2009 IEEE International Conference on PrivAcy, Security, riSk And Trust (PASSAT\u201909),", "citeRegEx": "L\u00e9aut\u00e9 and Faltings,? \\Q2009\\E", "shortCiteRegEx": "L\u00e9aut\u00e9 and Faltings", "year": 2009}], "referenceMentions": [{"referenceID": 0, "context": "To this purpose, we propose Algorithm 1, which is a modification of the pseudo-tree generation algorithm in Online Appendix 2, and is an improved version of the algorithm proposed by L\u00e9aut\u00e9 and Faltings (2009). Each variable x is assigned a unique number idx that corresponds to the order in which it is first visited during the distributed traversal of the constraint graph (or, more precisely, an upper bound thereon).", "startOffset": 183, "endOffset": 210}], "year": 2013, "abstractText": "The assignment of unique IDs to n variables is an instance of the well-known renaming problem, for which multiple algorithms have been proposed in the literature on distributed algorithms. However, to our knowledge, all these algorithms focus on robustness to failures, and ignore the issue of privacy. On the contrary, in this paper we do not consider agent failures, and we rather need an algorithm that protects agent and topology privacy. To this purpose, we propose Algorithm 1, which is a modification of the pseudo-tree generation algorithm in Online Appendix 2, and is an improved version of the algorithm proposed by L\u00e9aut\u00e9 and Faltings (2009). Each variable x is assigned a unique number idx that corresponds to the order in which it is first visited during the distributed traversal of the constraint graph (or, more precisely, an upper bound thereon). This is done by appending to each CHILD message the number id of variables visited so far (lines 8, 29 and 31). Each variable adds a random number to id so as not to leak any useful upper bound on its number of neighbors (lines 5 and 15). At the end of this algorithm, the root variable discovers an upper bound n+ on the total number of variables, and reveals it to everyone (lines 35 and 22 to 24).", "creator": "TeX"}}}