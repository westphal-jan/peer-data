{"id": "1402.4525", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Feb-2014", "title": "Off-Policy General Value Functions to Represent Dynamic Role Assignments in RoboCup 3D Soccer Simulation", "abstract": "collecting and maintaining accurate world domination knowledge in a dynamic, complex, adversarial, and stochastic interaction environment such as the robocup 3d soccer simulation is a challenging task. knowledge should be learned in real - frame time with time constraints. we use recently and introduced off - policy gradient descent algorithms within reinforcement learning that illustrate learnable knowledge representations for dynamic role assignments. analyzing the results show that twice the agents have learned competitive policies against the top teams from the elite robocup 2008 2012 competitions for setting three vs three, at five vs five, plus and four seven vs seven agents. we have explicitly used subsets of agents to identify the external dynamics and the semantics for influencing which the agents learn to maximize their performance measures, and to gather knowledge about different objectives, so that all agents participate effectively and efficiently within or the group.", "histories": [["v1", "Tue, 18 Feb 2014 23:01:13 GMT  (1220kb,D)", "http://arxiv.org/abs/1402.4525v1", "18 pages, 8 figures"]], "COMMENTS": "18 pages, 8 figures", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["saminda abeyruwan", "andreas seekircher", "ubbo visser"], "accepted": false, "id": "1402.4525"}, "pdf": {"name": "1402.4525.pdf", "metadata": {"source": "CRF", "title": "Off-Policy General Value Functions to Represent Dynamic Role Assignments in RoboCup 3D Soccer Simulation", "authors": ["Saminda Abeyruwan", "Andreas Seekircher", "Ubbo Visser"], "emails": ["saminda@cs.miami.edu", "aseek@cs.miami.edu", "visser@cs.miami.edu"], "sections": [{"heading": null, "text": "Keywords: Dynamic Role Assignment Function, Reinforcement Learning, GQ(\u03bb), Greedy-GQ(\u03bb), Off-PAC, Off-Policy Prediction and Control, and RoboCup 3D Soccer Simulation."}, {"heading": "1 Introduction", "text": "The RoboCup 3D Soccer Simulation environment provides a dynamic, realtime, complex, adversarial, and stochastic multi-agent environment for simulated agents. The simulated agents formalize their goals in two layers: 1. the physical layers, where controls related to walking, kicking etc. are conducted; and 2. the decision layers, where high level actions are taken to emerge behaviors. In this paper, we investigate a mechanism suitable for decision layers to use recently introduced Off-Policy Gradient Decent Algorithms in Reinforcement Leaning (RL) that illustrate learnable knowledge representations to learn about a dynamic role assignment function.\nIn order to learn about an effective dynamic role assignment function, the agents need to consider the dynamics of agent-environment interactions. We consider these interactions as the agent\u2019s knowledge. If this knowledge is represented\nar X\niv :1\n40 2.\n45 25\nv1 [\ncs .A\nI] 1\n8 Fe\nb 20\n14\n2 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\nin a formalized form (e.g., first-order predicate logic) an agent could infer many aspects about its interactions consistent with that knowledge. The knowledge representational forms show different degrees of computational complexities and expressiveness [22]. The computational requirements increase with the extension of expressiveness of the representational forms. Therefore, we need to identify and commit to a representational form, which is scalable for on-line learning while preserving expressivity. A human soccer player knows a lot of information about the game before (s)he enters onto the field and this prior knowledge influences the outcome of the game to a great extent. In addition, human soccer players dynamically change their knowledge during games in order to achieve maximum rewards. Therefore, the knowledge of the human soccer player is to a certain extent either predictive or goal-oriented. Can a robotic soccer player collect and maintain predictive and goal-oriented knowledge? This is a challenging problem for agents with time constraints and limited computational resources.\nWe learn the role assignment function using a framework that is developed based on the concepts of Horde, the real-time learning methodology, to express knowledge using General Value Functions (GVFs) [22]. Similar to Horde\u2019s subagents, the agents in a team are treated as independent RL sub-agents, but the agents take actions based on their belief of the world model. The agents may have different world models due to noisy perceptions and communication delays. The GVFs are constituted within the RL framework. They are predictions or off-policy controls that are answers to questions. For example, in order to make a prediction a question must be asked of the form \u201cIf I move in this formation, would I be in a position to score a goal?\u201d, or \u201cWhat set of actions do I need to block the progress of the opponent agent with the number 3?\u201d. The question defines what to learn. Thus, the problem of prediction or control can be addressed by learning value functions. An agent obtains its knowledge from information communicated back and forth between the agents and the agent-environment interaction experiences.\nThere are primarily two algorithms to learn about the GVFs, and these algorithms are based on Off-Policy Gradient Temporal Difference (OP-GTD) learning: 1. with action-value methods, a prediction question uses GQ(\u03bb) algorithm [8], and a control or a goal-oriented question uses Greedy-GQ(\u03bb) algorithm [9]. These algorithms learned about a deterministic target policies and the control algorithm finds the greedy action with respect to the action-value function; and 2. with policy-gradient methods, a goal-oriented question can be answered using Off-Policy Actor-Critic algorithm [24], with an extended state-value function, GTD(\u03bb) [7], for GVFs. The policy gradient methods are favorable for problems having stochastic optimal policies, adversarial environments, and problems with large action spaces. The OP-GTD algorithms possess a number of properties that are desirable for on-line learning within the RoboCup 3D Soccer Simulation environment: 1. off-policy updates; 2. linear function approximation; 3. no restrictions on the features used; 4. temporal-difference learning; 5. on-line and incremental; 6. linear in memory and per-time-step computation costs; and 7. convergent to a local optimum or equilibrium point [23,9].\n3 In this paper, we present a methodology and an implementation to learn about a dynamic role assignment function considering the dynamics of agentenvironment interactions based on GVFs. The agents ask questions and approximate value functions answer to those questions. The agents independently learn about the role assignment functions in the presence of an adversary team. Based on the interactions, the agents may have to change their roles in order to continue in the formation and to maximize rewards. There is a finite number of roles that an agent can commit to, and the GVFs learn about the role assignment function. We have conducted all our experiments in the RoboCup 3D Soccer Simulation League Environment. It is based on the general purpose multi-agent simulator SimSpark1. The robot agents in the simulation are modeled based on the Aldebaran NAO2 robots. Each robot has 22 degrees of freedom. The agents communicate with the server through message passing and each agent is equipped with noise free joint perceptors and effectors. In addition to this, each agent has a noisy restricted vision cone of 120o. Every simulation cycle is limited to 20 ms, where agents perceive noise free angular measurements of each joint and the agents stimulate the necessary joints by sending torque values to the simulation server. The vision information from the server is available every third cycle (60 ms), which provides spherical coordinates of the perceived objects. The agents also have the option of communicating with each other every other simulation cycle (40 ms) by broadcasting a 20 bytes message. The simulation league competitions are currently conducted with 11 robots on each side (22 total).\nThe remainder of the paper is organized as follows: In Section 2, we briefly discuss knowledge representation forms and existing role assignment formalisms. In Section 3, we introduce GVFs within the context of robotic soccer. In Section 4, we formalize our mechanisms of dynamic role assignment functions within GVFs. In Section 5, we identify the question and answer functions to represent GVFs, and Section 6 presents the experiment results and the discussion. Finally, Section 7 contains concluding remarks, and future work."}, {"heading": "2 Related Work", "text": "One goal of multi-agent systems research is the investigation of the prospects of efficient cooperation among a set of agents in real-time environments. In our research, we focus on the cooperation of a set of agents in a real-time robotic soccer simulation environment, where the agents learn about an optimal or a near-optimal role assignment function within a given formation using GVFs. This subtask is particularly challenging compared to other simulation leagues considering the limitations of the environment, i.e. the limited locomotion capabilities, limited communication bandwidth, or crowd management rules. The role assignment is a part of the hierarchical machine learning paradigm [20,19], where a formation defines the role space. Homogeneous agents can change roles flexibly within a formation to maximize a given reward function.\n1 http://svn.code.sf.net/p/simspark/svn/trunk/ 2 http://www.aldebaran-robotics.com/\n4 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\nRL framework offerers a set of tools to design sophisticated and hard-toengineer behaviors in many different robotic domains (e.g., [4]). Within the domain of robotic soccer, RL has been successfully applied in learning the keep-away subtask in the RoboCup 2D [18] and 3D [16] Soccer Simulation Leagues. Also, in other RoboCup leagues, such as the Middle Size League, RL has been applied successfully to acquire competitive behaviors [2]. One of the noticeable impact on RL is reported by the Brainstormers team, the RoboCup 2D Simulation League team, on learning different subtasks [14]. A comprehensive analysis of a general batch RL framework for learning challenging and complex behaviors in robot soccer is reported in [15]. Despite convergence guarantees, Q(\u03bb) [21] with linear function approximation has been used in role assignment in robot soccer [5] and faster learning is observed with the introduction of heuristically accelerated methods [3]. The dynamic role allocation framework based on dynamic programming is described in [6] for real-time soccer environments. The role assignment with this method is tightly coupled with the agent\u2019s low-level abilities and does not take the opponents into consideration. On the other hand, the proposed framework uses the knowledge of the opponent positions as well as other dynamics for the role assignment function.\nSutton et al. [22] have introduced a real-time learning architecture, Horde, for expressing knowledge using General Value Functions (GVFs). Our research is built on Horde to ask a set of questions such that the agents assign optimal or near-optimal roles within formations. In addition, following researches describe methods and components to build strategic agents: [1] describes a methodology to build a cognizant robot that possesses vast amount of situated, reversible and expressive knowledge. [11] presents a methodology to \u201cnext\u201d in real time predicting thousands of features of the world state, and [10] presents methods predict about temporally extended consequences of a robot\u2019s behaviors in general forms of knowledge. The GVFs are successfully used (e.g., [13,25]) for switching and prediction tasks in assistive biomedical robots."}, {"heading": "3 Learnable knowledge representation for Robotic Soccer", "text": "Recently, within the context of the RL framework [21], a knowledge representation language has been introduced, that is expressive and learnable from sensorimotor data. This representation is directly usable for robotic soccer as agentenvironment interactions are conducted through perceptors and actuators. In this approach, knowledge is represented as a large number of approximate value functions each with its 1. own policy ; 2. pseudo-reward function; 3. pseudotermination function; and 4. pseudo-terminal-reward function [22]. In continuous state spaces, approximate value functions are learned using function approximation and using more efficient off-policy learning algorithms. First, we briefly introduce some of the important concepts related to the GVFs. The complete information about the GVFs are available in [22,8,9,7]. Second, we show its direct application to simulated robotic soccer.\n5"}, {"heading": "3.1 Interpretation", "text": "The interpretation of the approximate value function as a knowledge representation language grounded on information from perceptors and actuators is defined as:\nDefinition 1. The knowledge expressed as an approximate value function is true or accurate, if its numerical values matches those of the mathematically defined value function it is approximating.\nTherefore, according to the Definition (1), a value function asks a question, and an approximate value function is the answer to that question. Based on prior interpretation, the standard RL framework extends to represent learnable knowledge as follows. In the standard RL framework [21], let the agent and the world interact in discrete time steps t = 1, 2, 3, . . .. The agent senses the state at each time step St \u2208 S, and selects an actionAt \u2208 A. One time step later the agent receives a scalar reward Rt+1 \u2208 R, and senses the state St+1 \u2208 S. The rewards are generated according to the reward function r : St+1 \u2192 R. The objective of the standard RL framework is to learn the stochastic action-selection policy \u03c0 : S\u00d7A \u2192 [0, 1], that gives the probability of selecting each action in each state, \u03c0(s, a) = \u03c0(s|a) = P(At = a|St = s), such that the agent maximizes rewards summed over the time steps. The standard RL framework extends to include a terminal-reward-function, z : S \u2192 R, where z(s) is the terminal reward received when the termination occurs in state s. In the RL framework, \u03b3 \u2208 [0, 1) is used to discount delayed rewards. Another interpretation of the discounting factor is a constant probability of 1\u2212\u03b3 termination of arrival to a state with zero terminalreward. This factor is generalized to a termination function \u03b3 : S \u2192 [0, 1], where 1\u2212 \u03b3(s) is the probability of termination at state s, and a terminal reward z(s) is generated."}, {"heading": "3.2 Off-Policy Action-Value Methods for GVFs", "text": "The first method to learn about GVFs, from off-policy experiences, is to use action-value functions. Let Gt be the complete return from state St at time t, then the sum of the rewards (transient plus terminal) until termination at time T is:\nGt = T\u2211 k=t+1 r(Sk) + z(ST ).\nThe action-value function is:\nQ\u03c0(s, a) = E(Gt|St = s,At = a,At+1:T\u22121 \u223c \u03c0, T \u223c \u03b3),\nwhere, Q\u03c0 : S \u00d7 A \u2192 R. This is the expected return for a trajectory started from state s, and action a, and selecting actions according to the policy \u03c0, until termination occurs with \u03b3. We approximate the action-value function with Q\u0302 : S \u00d7A \u2192 R. Therefore, the action-value function is a precise grounded question,\n6 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\nAlgorithm 1 Greedy-GQ(\u03bb) with linear function approximation for GVFs learning [7].\n1: Initialize w0 to 0, and \u03b80 arbitrary. 2: Choose proper (small) positive values for \u03b1\u03b8, \u03b1w, and set values for \u03b3(.) \u2208 (0, 1], \u03bb(.) \u2208 [0, 1]. 3: repeat 4: Initialize e = 0. 5: Take At from St according to \u03c0b, and arrive at St+1. 6: Observe sample, (St, At, r(St+1), z(St+1), St+1,) at time step t (with their\ncorresponding state-action feature vectors), where \u03c6\u0302t+1 = \u03c6(St+1, A \u2217 t+1), A \u2217 t+1 = argmaxb \u03b8 T t \u03c6(St+1, b).\n7: for each observed sample do 8: \u03b4t \u2190 r(St+1) + (1\u2212 \u03b3(St+1))z(St+1) + \u03b3(St+1)\u03b8Tt \u03c6\u0302t+1 \u2212 \u03b8Tt \u03c6t. 9: If At = A\n\u2217 t , then \u03c1t \u2190 1\u03c0b(A\u2217t |St) ; otherwise \u03c1t \u2192 0.\n10: et \u2190 It\u03c6t + \u03b3(St)\u03bb(St)\u03c1tet\u22121. 11: \u03b8t+1 \u2190 \u03b8t + \u03b1\u03b8[\u03b4tet \u2212 \u03b3(St+1)(1\u2212 \u03bb(St+1))(wTt et)\u03c6\u0302t+1]. 12: wt+1 \u2190 wt + \u03b1w[\u03b4tet \u2212 (wTt \u03c6t)\u03c6t)]. 13: end for 14: until each episode.\nwhile the approximate action-value function offers the numerical answer. The complete algorithm for Greedy-GQ(\u03bb) with linear function approximation for GVFs learning is as shown in Algorithm (1).\nThe GVFs are defined over four functions: \u03c0, \u03b3, r, and z. The functions r and z act as pseudo-reward and pseudo-terminal-reward functions respectively. Function \u03b3 is also in pseudo form as well. However, \u03b3 function is more substantive than reward functions as the termination interrupts the normal flow of state transitions. In pseudo termination, the standard termination is omitted. In robotic soccer, the base problem can be defined as the time until a goal is scored by either the home or the opponent team. We can consider a pseudo-termination has occurred when the striker is changed. The GVF with respect to a state-action function is defined as:\nQ\u03c0,\u03b3,r,z(s, a) = E(Gt|St = s,At = a,At+1:T\u22121 \u223c \u03c0, T \u223c \u03b3).\nThe four functions, \u03c0, \u03b3, r, and z, are the question functions to GVFs, which in return defines the general value function\u2019s semantics. The RL agent learns an approximate action-value function, Q\u0302, using the four auxiliary functions \u03c0, \u03b3, r and z. We assume that the state space is continuous and the action space is discrete. We approximate the action-value function using a linear function approximator. We use a feature extractor \u03c6 : St \u00d7 At \u2192 {0, 1}N , N \u2208 N, built on tile coding [21] to generate feature vectors from state variables and actions. This is a sparse vector with a constant number of \u201c1\u201d features, hence, a constant norm. In addition, tile coding has the key advantage of real-time learning and to implement computationally efficient algorithms to learn approximate value functions. In linear function approximation, there exists a weight vector, \u03b8 \u2208 RN , N \u2208 N, to\n7 be learned. Therefore, the approximate GVFs are defined as:\nQ\u0302(s, a, \u03b8) = \u03b8T\u03c6(s, a),\nsuch that, Q\u0302 : S \u00d7 A \u00d7 RN \u2192 R. Weights are learned using the gradientdescent temporal-difference Algorithm (1) [7]. The Algorithm learns stably and efficiently using linear function approximation from off-policy experiences. Offpolicy experiences are generated from a behavior policy, \u03c0b, that is different from the policy being learned about named as target policy, \u03c0. Therefore, one could learn multiple target policies from the same behavior policy."}, {"heading": "3.3 Off-Policy Policy Gradient Methods for GVFs", "text": "The second method to learn about GVFs is using the off-policy policy gradient methods with actor-critic architectures that use a state-value function suitable for learning GVFs. It is defined as:\nV \u03c0,\u03b3,r,z(s) = E(Gt|St = s,At:T\u22121 \u223c \u03c0, T \u223c \u03b3),\nwhere, V \u03c0,\u03b3,r,z(s) is the true state-value function, and the approximate GVF is defined as:\nV\u0302 (s, v) = vT\u03c6(s),\nwhere, the functions \u03c0, \u03b3, r, and z are defined as in the subsection (3.2). Since our the target policy \u03c0 is discrete stochastic, we use a Gibbs distribution of the form:\n\u03c0(a|s) = e uT\u03c6(s,a)\u2211 b e uT\u03c6(s,b) ,\nwhere, \u03c6(s, a) are state-action features for state s, and action a, which are in general unrelated to state features \u03c6(s), that are used in state-value function approximation. u \u2208 RNu , Nu \u2208 N, is a weight vector, which is modified by the actor to learn about the stochastic target policy. The log-gradient of the policy at state s, and action a, is:\n\u2207u\u03c0(a|s) \u03c0(a|s) = \u03c6(s, a)\u2212 \u2211 b \u03c0(b|s)\u03c6(s, b).\nThe complete algorithm for Off-PAC with linear function approximation for GVFs learning is as shown in Algorithm (2).\nWe are interested in finding optimal policies for the dynamic role assignment, and henceforth, we use Algorithms (1), and (2) for control purposes3. We use linear function approximation for continuous state spaces, and discrete actions are used within options. Lastly, to summarize, the definitions of the question functions and the answer functions are given as:\n3 We use an C++ implementation of Algorithm (1) and (2) in all of our experiments. An implementation is available in https://github.com/samindaa/RLLib\n8 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\nAlgorithm 2 Off-PAC with linear function approximation for GVFs learning [7,24].\n1: Initialize w0 to 0, and v0 and u0 arbitrary. 2: Choose proper (small) positive values for \u03b1v, \u03b1w, \u03b1u, and set values for \u03b3(.) \u2208\n(0, 1], \u03bb(.) \u2208 [0, 1]. 3: repeat 4: Initialize ev = 0, and eu = 0. 5: Take At from St according to \u03c0b, and arrive at St+1. 6: Observe sample, (St, At, r(St+1), z(St+1), St+1) at time step t (with their cor-\nresponding state (\u03c6t, \u03c6t+1) feature vectors, where \u03c6t = \u03c6(St)). 7: for each observed sample do 8: \u03b4t \u2190 r(St+1) + (1\u2212 \u03b3(St+1))z(St+1) + \u03b3(St+1)vTt \u03c6t+1 \u2212 vTt \u03c6t. 9: \u03c1t \u2190 \u03c0(At|St)\u03c0b(At|St) .\n10: Update the critic (GTD(\u03bb) algorithm for GVFs). 11: evt \u2190 \u03c1t(\u03c6t + \u03b3(St)\u03bb(St)evt\u22121). 12: vt+1 \u2190 vt + \u03b1v[\u03b4tevt \u2212 \u03b3(St+1)(1\u2212 \u03bb(St+1))(evt Twt)\u03c6t+1]. 13: wt+1 \u2190 wt + \u03b1w[\u03b4tet \u2212 (wTt \u03c6t)\u03c6t)]. 14: Update the actor.\n15: eut \u2190 \u03c1t [ \u2207u\u03c0(At|St) \u03c0(At|St) + \u03b3(St)\u03bb(St+1)e u t\u22121 ] . 16: ut+1 \u2190 ut + \u03b1u\u03b4teut . 17: end for 18: until each episode.\nDefinition 2. The question functions are defined by:\n1. \u03c0 : St \u00d7At \u2192 [0, 1] (target policy is greedy w.r.t. learned value function); 2. \u03b3 : St \u2192 [0, 1] (termination function); 3. r : St+1 \u2192 R (transient reward function); and 4. z : St+1 \u2192 R (terminal reward function).\nDefinition 3. The answer functions are defined by:\n1. \u03c0b : St \u00d7At \u2192 [0, 1] (behavior policy); 2. It : St \u00d7At \u2192 [0, 1] (interest function); 3. \u03c6 : St \u00d7At \u2192 RN (feature-vector function); and 4. \u03bb : St \u2192 [0, 1] (eligibility-trace decay-rate function)."}, {"heading": "4 Dynamic Role Assignment", "text": "A role is a specification of an internal or an external behavior of an agent. In our soccer domain, roles select behaviors of agents based on different reference criteria: the agent close to the ball becomes the striker. Given a role space, R = {r1, . . . , rn}, of size n, the collaboration among m \u2264 n agents, A = {a1, . . . , am}, is obtained through formations. The role space consists of active and reactive roles. For example, the striker is an active role and the defender could be a reactive role. Given a reactive role, there is a function, R 7\u2192 T , that\n9 maps roles to target positions, T , on the field. These target positions are calculated with respect to a reference pose (e.g., ball position) and other auxiliary criteria such as crowd management rules. A role assignment function, R 7\u2192 A, provides a mapping from role space to agent space, while maximizing some reward function. The role assignment function can be static or dynamic. Static role assignments often provide inferior performance in robot soccer [6]. Therefore, we learn a dynamic role assignment function within the RL framework using off-policy control."}, {"heading": "4.1 Target Positions with the Primary Formation", "text": "Within our framework, an agent can choose one role among thirteen roles. These roles are part of a primary formation, and an agent calculates the respective target positions according to its belief of the absolute ball position and the rules imposed by the 3D soccer simulation server. We have labeled the role space in order to describe the behaviors associated with them. Figure (1) shows the target positions for the role space before the kickoff state. The agent closest to the ball takes the striker role (SK), which is the only active role. Let us assume that the agent\u2019s belief of the absolute ball position is given by (xb, yb). Forward left (FL) and forward right (FR) target positions are offset by (xb, yb)\u00b1(0, 2). The extended forward left (EX1L) and extended forward right ((EX1R)) target positions are offset by (xb, yb) \u00b1 (0, 4). The stopper (ST) position is given by (xb \u2212 2.0, yb). The extended middle (EX1M) position is used as a blocking position and it is calculated based on the closest opponent to the current agent. The other target positions, wing left (WL), wing right (WR), wing middle (WM), back left (BL), back right (BR), and back middle (BM) are calculated with respect to the vector from the middle of the home goal to the ball and offset by a factor which increases close to the home goal. When the ball is within the reach of goal keeper, the\n10 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\n(GK) role is changed to goal keeper striker (GKSK) role. We slightly change the positions when the ball is near the side lines, home goal, and opponent goal. These adjustments are made in order to keep the target positions inside the field. We allow target positions to be overlapping. The dynamic role assignment function may assign the same role during the learning period. In order to avoid position conflicts an offset is added; the feedback provides negative rewards for such situations."}, {"heading": "4.2 Roles to RL Action Mapping", "text": "The agent closest to the ball becomes the striker, and only one agent is allowed to become the striker. The other agents except the goalie are allowed to choose from twelve roles. We map the available roles to discrete actions of the RL algorithm. In order to use Algorithm 1, an agent must formulate a question function using a value function, and the answer function provides the solution as an approximate value function. All the agents formulate the same question: What is my role in this formation in order to maximize future rewards? All agents learn independently according to the question, while collaboratively aiding each other to maximize their future reward. We make the assumption that the agents do not communicate their current role. Therefore, at a specific step, multiple agents may commit to the same role. We discourage this condition by modifying the question as What is my role in this formation in order to maximize future rewards, while maintaining a completely different role from all teammates in all time steps?\n11"}, {"heading": "4.3 State Variables Representation", "text": "Figure 2 shows the schematic diagram of the state variable representation. All points and vectors in Figure 2 are defined with respect to a global coordinate system. h is the middle point of the home goal, while o is the middle point of the opponent goal. b is the ball position. \u2016.\u2016 represents the vector length, while \u2220pqr represents the angle among three points p, q, and r pivoted at q. ai represents the self-localized point of the i = 1, . . . , 11 teammate agent. yi is some point in the direction of the robot orientation of teammate agents. cj , j = 1, . . . , 11, represents the mid-point of the tracked opponent agent. x represents a point on a vector parallel to unit vector ex. Using these labels, we define the state variables as:\n{\u2016 vhb \u2016, \u2016 vbo \u2016,\u2220hbo, {\u2016 vaib \u2016,\u2220yiaib,\u2220aibx} nend i=nstart , {\u2016 vcjb \u2016,\u2220cjbx, } mmax j=1 }.\nnstart is the teammate starting id and nend the ending id. mmax is the number of opponents considered. Angles are normalized to [\u2212\u03c02 , \u03c0 2 ]."}, {"heading": "5 Question and Answer Functions", "text": "There are twelve actions available in each state. We have left out the striker role from the action set. The agent nearest to the ball becomes the striker. All agents communicate their belief to other agents. Based on their belief, all agents calculate a cost function and assign the closest agent as the striker. We have formulated a cost function based on relative distance to the ball, angle of the agent, number of teammates and opponents within a region near the ball, and whether the agents are active. In our formulation, there is a natural termination condition; scoring goals. With respect to the striker role assignment procedure, we define a pseudo-termination condition. When an agent becomes a striker, a pseudo-termination occurs, and the striker agent does not participate in the learning process unless it chooses another role. We define the question and answer functions as follows:"}, {"heading": "5.1 GVF Definitions for State-Action Functions", "text": "Question functions:\n1. \u03c0 = greedy w.r.t. Q\u0302, 2. \u03b3(.) = 0.8, 3. r(.) = (a) the change of x value of the absolute ball position; (b) a small\nnegative reward of 0.01 for each cycle; (c) a negative reward of 5 is given to all agents within a radius of 1.5 meters; 4. z(.) = (a) +100 for scoring against opponent; (b) \u2212100 for opponent scoring; and 5. time step = 2 seconds.\nAnswer functions:\n12 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\n1. \u03c0b = -greedy w.r.t. target state-action function, 2. = 0.05, 3. It(.) = 1, 4. \u03c6(., .) = (a) we use tile coding to formulate the feature vector. nstart = 2 and nend = 3, 5, 7. mmax = 3, 5, 7. Therefore, there are 18, 28, 30 state variables. (b) state variable is independently tiled with 16 tilings with approximately each with 116 generalization. Therefore, there are 288 + 1, 448 + 1, 608 + 1 active tiles (i.e., tiles with feature 1) hashed to a binary vector dimension 106 + 1. The bias feature is always active, and 5. \u03bb(.) = 0.8.\nParameters: 1. \u2016 \u03b8 \u2016=\u2016 w \u2016= 106 + 1; 2. \u2016 e \u2016= 2000 (efficient trace implementation); 3. \u03b1\u03b8 = 0.01 289 , 0.01 449 , 0.01 609 ; and 4. \u03b1w = 0.001\u00d7 \u03b1\u03b8."}, {"heading": "5.2 GVF for Gradient Descent Functions", "text": "Question functions:\n1. \u03c0 = Gibbs distribution, 2. \u03b3(.) = 0.9, 3. r(.) = (a) the change of x value of the absolute ball position; (b) a small\nnegative reward of 0.01 for each cycle; (c) a negative reward of 5 is given to all agents within a radius of 1.5 meters; 4. z(.) = (a) +100 for scoring against opponent; (b) \u2212100 for opponent scoring; and 5. time step = 2 seconds.\nAnswer functions:\n1. \u03c0b = the learned Gibbs distribution is used with a small perturbation. In order to provide exploration, with probability 0.01, Gibbs distribution is perturbed using some \u03b2 value. In our experiments, we use \u03b2 = 0.5. Therefore,\nwe use a behavior policy: e uT\u03c6(s,a)+\u03b2\u2211 b e uT\u03c6(s,b)+\u03b2\n2. \u03c6(.) = (a) the representations for the state-value function, we use tile coding to formulate the feature vector. nstart = 2 and nend = 3, 5, 7. mmax = 3, 5, 7. Therefore, there are 18, 28, 30 state variables. (b) state variable is independently tiled with 16 tilings with approximately each with 116 generalization. Therefore, there are 288+1, 448+1, 608+1 active tiles (i.e., tiles with feature 1) hashed to a binary vector dimension 106 + 1. The bias feature is always set to active; 3. \u03c6(., .) = (a) the representations for the Gibbs distribution, we use tile coding to formulate the feature vector. nstart = 2 and nend = 3, 5, 7. mmax = 3, 5, 7. Therefore, there are 18, 28, 30 state variables. (b) state variable is independently tiled with 16 tilings with approximately each with 116 generalization. Therefore, there are 288 + 1, 448 + 1, 608 + 1 active tiles (i.e., tiles with feature 1) hashed to a binary vector dimension 106 + 1. The hashing has also considered the given action. The bias feature is always set to active; and\n13\n4. \u03bbcritic(.) = \u03bbactor(.) = 0.3.\nParameters: 1. \u2016 u \u2016= 106 + 1; 2. \u2016 \u03b8 \u2016=\u2016 w \u2016= 106 + 1; 3. \u2016 ev \u2016=\u2016 eu \u2016= 2000 (efficient trace implementation); 4. \u03b1v = 0.01 289 , 0.01 449 , 0.01 609 ; 5. \u03b1w = 0.0001\u00d7 \u03b1v; and 6. \u03b1v = 0.001 289 , 0.001 449 , 0.001 609 ."}, {"heading": "6 Experiments", "text": "We conducted experiments against the teams Boldhearts and MagmaOffenburg, both semi-finalists of the RoboCup 3D Soccer Simulation competition in Mexico 20124. We conducted knowledge learning according to the configuration given in Section (5). Subsection (6.1) describes the performance of the Algorithm (1), and Subsection (6.2) describes the performance of the Algorithm (2) for the experiment setup."}, {"heading": "6.1 GVFs with Greedy-GQ(\u03bb)", "text": "The first experiments were done using a team size of five with the RL agents against Boldhearts. After 140 games our RL agent increased the chance to win from 30% to 50%. This number does not increase more in the next games, but after 260 games the number of lost games (initially 35%) is reduced to 15%. In the further experiments we used the goal difference to compare the performance of the RL agent. Figure (3) shows the average goal differences that the handtuned role assignment and the RL agents archive in games against Boldhearts and MagmaOffenburg using different team sizes. With only three agents per team the RL agent only needs 40 games to learn a policy that outperforms the hand-coded role selection (Figure (3(a))). Also with five agents per team, the learning agent is able to increase the goal difference against both opponents (Figure (3(b))). However, it does not reach the performance of the manually tuned role selection. Nevertheless considering the amount of time spent for fine-tuning the handcoded role selection, these results are promising. Furthermore, the outcome of the games depends a lot on the underlying skills of the agents, such as walking or dribbling. These skills are noisy, thus the results need to be averaged over many games (std. deviations in Figure (3) are between 0.5 and 1.3).\nThe results in Figure (3(c)) show a bigger gap between RL and the handcoded agent. However, using seven agents the goal difference is generally decreased, since the defense is easily improved by increasing the number of agents. Also the hand-coded role selection results in a smaller goal difference. Furthermore, considering seven agents in each team the state space is already increased significantly. Only 200 games seem to be not sufficient to learn a good policy. Sometimes the RL agents reach a positive goal difference, but it stays below the hand-coded role selection. In Section 7, we discuss some of the reasons for this\n4 The published binary of the team UTAustinVilla showed unexpected behaviors in our tests and is therefore omitted.\n14 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\ninferior performances for the team size seven. Even though the RL agent did not perform well considering only the goal difference, it has learned a moderately satisfactory policy. After 180 games the amount of games won is increased slightly from initially 10% to approximately 20%."}, {"heading": "6.2 GVFs with Off-PAC", "text": "With Off-PAC, we used a similar environment to that of Subsection (6.1), but with a different learning setup. Instead of learning individual policies for teams separately, we learned a single policy for both teams. We ran the opponent teams in a round robin fashion for 200 games and repeated complete runs for multiple times. The first experiments were done using a team size of three with RL agents against both teams. Figure (4(a)) shows the results of bins of 20 games averaged between two trials. After 20 games, the RL agents have learned a stable policy compared to the hand-tuned policy, but the learned policy bounded above the hand-tuned role assignment function. The second experiments were done using a team size of five with the RL agents against opponent teams. Figure (4(b)) shows the results of bins of 20 games averaged among three trials. After 100 games, our RL agent increased the chance of winning to 50%. This number does not increase more in the next games. As Figures (4(a)) and (4(b)) show, the\n15\nthree and five agents per team are able to increase the goal difference against both opponents. However, it does not reach the performance of the manually tuned role selection. Similar to Subsection (6.1), the amount of time spent for fine-tuning the hand-coded role selection, these results are promising, and the outcome of the experiment heavily depends on the underlying skills of the agents.\nThe final experiments were done using a team size of seven with the RL agents against opponent teams. Figure (4(c)) shows the results of bins of 20 games averaged among two trials. Similar to Subsection (6.1), with seven agents per team, the results in Figure (4(c)) show a bigger gap between RL and the hand-tuned agent. However, using seven agents the goal difference is generally decreased, since the defense is easily improved by increasing the number of agents. Also the hand-tuned role selection results in a smaller goal difference. Figure 4(c) shows an increase in the trend of winning games. As mentioned earlier, only 200 games seem to be not sufficient to learn a good policy. Even though the RL agents reach a positive goal difference, but it stays below the hand-tuned role selection method. Within the given setting, the RL agents have learned a moderately satisfactory policy. Whether the learned policy is satisfactory for other teams needs to be further investigated.\n16 Saminda Abeyruwan, Andreas Seekircher, and Ubbo Visser\nThe RoboCup 3D soccer simulation is inherently a dynamic, and a stochastic environment. There is an infinitesimal chance that a given situation (state) may occur for many games. Therefore, it is paramount important that the learning algorithms extract as much information as possible from the training examples. We use the algorithms in the on-line incremental setting, and once the experience is consumed it is discarded. Since, we learned from off-policy experiences, we can save the tuples, (St, At, St+1, r(St+1), \u03c1t, z(St+1)), and learn the policy off-line. The Greedy-GQ(\u03bb) learns a deterministic greedy policy. This may not be suitable for complex and dynamic environments such as the RoboCup 3D soccer simulation environment. The Off-PAC algorithm is designed for stochastic environment. The experiment shows that this algorithm needs careful tuning of learning rates and feature selection, as evident from Figure (4(a)) after 160 games."}, {"heading": "7 Conclusions", "text": "We have designed and experimented RL agents that learn to assign roles in order to maximize expected future rewards. All the agents in the team ask the question \u201cWhat is my role in this formation in order to maximize future rewards, while maintaining a completely different role from all teammates in all time steps?\u201d. This is a goal-oriented question. We use Greedy-GQ(\u03bb) and Off-PAC to learn experientially grounded knowledge encoded in GVFs. Dynamic role assignment function is abstracted from all other low-level components such as walking engine, obstacle avoidance, object tracking etc. If the role assignment function selects a passive role and assigns a target location, the lower-layers handle this request. If the lower-layers fail to comply to this request, for example being reactive, this feedback is not provided to the role assignment function. If this information needs to be included; it should become a part of the state representation, and the reward signal should be modified accordingly. The target positions for passive roles are created w.r.t. the absolute ball location and the rules imposed by the 3D soccer simulation league. When the ball moves relatively quickly, the target locations change more quickly. We have given positive rewards only for the forward ball movements. In order to reinforce more agents within an area close to the ball, we need to provide appropriate rewards. These are part of reward shaping [12]. Reward shaping should be handled carefully as the agents may learn sub-optimal policies not contributing to the overall goal.\nThe experimental evidences show that agents are learning competitive role assignment functions for defending and attacking. We have to emphasize that the behavior policy is -greedy with a relatively small exploration or slightly perturbed around the target policy. It is not a uniformly distributed policy as used in [22]. The main reason for this decision is that when an adversary is present with the intention of maximizing its objectives, practically the learning agent may have to run for a long period to observe positive samples. Therefore, we have used the off-policy Greedy-GQ(\u03bb) and Off-PAC algorithms for learning goal-oriented GVFs within on-policy control setting. Our hypothesis is that\n17\nwith the improvements of the functionalities of lower-layers, the role assignment function would find better policies for the given question and answer functions. Our next step is to let the RL agent learn policies against other RoboCup 3D soccer simulation league teams. Beside the role assignment, we also contributed with testing off-policy learning in high-dimensional state spaces in a competitive adversarial environment. We have conducted experiments with three, five, and seven agents per team. The full game consists of eleven agents. The next step is to extend learning to consider all agents, and to include methods that select informative state variables and features."}], "references": [{"title": "Scaling-up Knowledge for a Cognizant Robot", "author": ["T. Degris", "J. Modayily"], "venue": "In Notes of the AAAI Spring Symposium on Designing Intelligent Robots: Reintegrating AI", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Bridging the Gap: Learning in the Robocup Simulation and Midsize League", "author": ["T. Gabel", "S. Lange", "M. Lauer", "M. Riedmiller"], "venue": "Proceedings of the 7th Portuguese Conference on Automatic Control (Controlo)", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2006}, {"title": "Market-Based Dynamic Task Allocation using Heuristically Accelerated Reinforcement Learning", "author": ["Gurzoni", "J.A. Jr.", "F. Tonidandel", "R.A.C. Bianchi"], "venue": "Proceedings of the 15th Portugese Conference on Progress in Artificial Intelligence. pp. 365\u2013376. EPIA\u201911, Springer-Verlag, Berlin, Heidelberg", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2011}, {"title": "Reinforcement Learning in Robotics: A Survey", "author": ["J. Kober", "J.A.D. Bagnell", "J. Peters"], "venue": "International Journal of Robotics Research", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2013}, {"title": "Q-Learning Based Market-Driven Multi-Agent Collaboration in Robot Soccer", "author": ["H. K\u00f6se", "U. Tatladede", "C. Mericli", "K. Kaplan", "H.L. Akan"], "venue": "Proceedings of the Turkish Symposium on Artificial Intelligence and Neural Networks (TAINN). pp. 219\u2013228", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2004}, {"title": "UT Austin Villa 2011: A Champion Agent in the RoboCup 3D Soccer Simulation Competition", "author": ["P. MacAlpine", "D. Urieli", "S. Barrett", "S. Kalyanakrishnan", "F. Barrera", "A. LopezMobilia", "N. \u015etiurc\u0103", "V. Vu", "P. Stone"], "venue": "Proceedings of 11th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2012)", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2012}, {"title": "Gradient Temporal-Difference Learning Algorithms", "author": ["H.R. Maei"], "venue": "PhD Thesis, University of Alberta", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2011}, {"title": "GQ(\u03bb): A General Gradient Algorithm for TemporalDifference Prediction Learning with Eligibility Traces", "author": ["H.R. Maei", "R.S. Sutton"], "venue": "Proceedings of the 3rd Conference on Artificial General Intelligence (AGI-10) pp. 1\u20136", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Toward Off-Policy Learning Control with Function Approximation", "author": ["H.R. Maei", "C. Szepesv\u00e1ri", "S. Bhatnagar", "R.S. Sutton"], "venue": "Proceedings of the 27th International Conference on Machine Learning (ICML 2010). pp. 719\u2013726", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "Acquiring a Broad Range of Empirical Knowledge in Real Time by Temporal-Difference Learning", "author": ["J. Modayil", "A. White", "P.M. Pilarski", "R.S. Sutton"], "venue": "Proceedings of the IEEE International Conference on Systems, Man, and Cybernetics (SMC). pp. 1903\u20131910. IEEE", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Multi-timescale Nexting in a Reinforcement Learning Robot", "author": ["J. Modayil", "A. White", "R.S. Sutton"], "venue": "From Animals to Animats 12 - 12th International Conference on Simulation of Adaptive Behavior (SAB). pp. 299\u2013309", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Policy Invariance Under Reward Transformations: Theory and Application to Reward Shaping", "author": ["A.Y. Ng", "D. Harada", "S.J. Russell"], "venue": "Proceedings of the Sixteenth International Conference on Machine Learning (ICML). pp. 278\u2013287. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA", "citeRegEx": "12", "shortCiteRegEx": null, "year": 1999}, {"title": "Dynamic Switching and Real-Time Machine Learning for Improved Human Control of Assistive Biomedical Robots", "author": ["P. Pilarski", "M. Dawson", "T. Degris", "J. Carey", "R. Sutton"], "venue": "4th IEEE RAS EMBS International Conference on Biomedical Robotics and Biomechatronics (BioRob). pp. 296 \u2013302", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "On Experiences in a Complex and Competitive Gaming Domain: Reinforcement Learning Meets RoboCup", "author": ["M. Riedmiller", "T. Gabel"], "venue": "Third IEEE Symposium on Computational Intelligence and Games. pp. 17\u201323. IEEE", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2007}, {"title": "Reinforcement Learning for Robot Soccer", "author": ["M. Riedmiller", "T. Gabel", "R. Hafner", "S. Lange"], "venue": "Autonomous Robots 27, 55\u201373", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2009}, {"title": "Accurate Ball Tracking with Extended Kalman Filters as a Prerequisite for a High-Level Behavior with Reinforcement Learning", "author": ["A. Seekircher", "S. Abeyruwan", "U. Visser"], "venue": "The 6th Workshop on Humanoid Soccer Robots at Humanoid Conference, Bled (Slovenia)", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Roboviz: Programmable Visualization for Simulated Soccer", "author": ["J. Stoecker", "U. Visser"], "venue": "R\u00f6fer, T., Mayer, N.M., Savage, J., Saranli, U. (eds.) RoboCup. pp. 282\u2013 293. Lecture Notes in Computer Science, Springer", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2011}, {"title": "Reinforcement Learning for RoboCupSoccer Keepaway", "author": ["P. Stone", "R.S. Sutton", "G. Kuhlmann"], "venue": "Adaptive Behavior 13(3), 165\u2013188", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2005}, {"title": "Layered Learning", "author": ["P. Stone", "M. Veloso"], "venue": "Proceedings of the Eleventh European Conference on Machine Learning. pp. 369\u2013381. Springer Verlag", "citeRegEx": "19", "shortCiteRegEx": null, "year": 1999}, {"title": "Task Decomposition, Dynamic Role Assignment, and LowBandwidth Communication for Real-Time Strategic Teamwork", "author": ["P. Stone", "M. Veloso"], "venue": "Artificial Intelligence 110(2), 241\u2013273", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1999}, {"title": "Reinforcement Learning: An Introduction", "author": ["R.S. Sutton", "A.G. Barto"], "venue": "MIT Press", "citeRegEx": "21", "shortCiteRegEx": null, "year": 1998}, {"title": "Horde: A Scalable Real-Time Architecture for Learning Knowledge from Unsupervised Sensorimotor Interaction", "author": ["R.S. Sutton", "J. Modayil", "M. Delp", "T. Degris", "P.M. Pilarski", "A. White", "D. Precup"], "venue": "The 10th International Conference on Autonomous Agents and Multiagent Systems. pp. 761\u2013768. AAMAS \u201911, International Foundation for Autonomous Agents and Multiagent Systems", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "A Convergent O(N) Algorithm for OffPolicy Temporal-Difference Learning with Linear Function Approximation", "author": ["R.S. Sutton", "C. Szepesv\u00e1ri", "H.R. Maei"], "venue": "Advances in Neural Information Processing Systems (NIPS). pp. 1609\u20131616. MIT Press", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2008}, {"title": "Off-Policy Actor-Critic", "author": ["Thomas Degris", "R.S.S. Martha White"], "venue": "Proceedings of the Twenty-Ninth International Conference on Machine Learning (ICML)", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2012}, {"title": "Scaling Life-Long Off-Policy Learning", "author": ["A. White", "J. Modayil", "R. Sutton"], "venue": "International Conference on Development and Learning and Epigenetic Robotics (ICDL), 2012 IEEE. pp. 1\u20136", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 21, "context": "The knowledge representational forms show different degrees of computational complexities and expressiveness [22].", "startOffset": 109, "endOffset": 113}, {"referenceID": 21, "context": "We learn the role assignment function using a framework that is developed based on the concepts of Horde, the real-time learning methodology, to express knowledge using General Value Functions (GVFs) [22].", "startOffset": 200, "endOffset": 204}, {"referenceID": 7, "context": "with action-value methods, a prediction question uses GQ(\u03bb) algorithm [8], and a control or a goal-oriented question uses Greedy-GQ(\u03bb) algorithm [9].", "startOffset": 70, "endOffset": 73}, {"referenceID": 8, "context": "with action-value methods, a prediction question uses GQ(\u03bb) algorithm [8], and a control or a goal-oriented question uses Greedy-GQ(\u03bb) algorithm [9].", "startOffset": 145, "endOffset": 148}, {"referenceID": 23, "context": "with policy-gradient methods, a goal-oriented question can be answered using Off-Policy Actor-Critic algorithm [24], with an extended state-value function, GTD(\u03bb) [7], for GVFs.", "startOffset": 111, "endOffset": 115}, {"referenceID": 6, "context": "with policy-gradient methods, a goal-oriented question can be answered using Off-Policy Actor-Critic algorithm [24], with an extended state-value function, GTD(\u03bb) [7], for GVFs.", "startOffset": 163, "endOffset": 166}, {"referenceID": 22, "context": "convergent to a local optimum or equilibrium point [23,9].", "startOffset": 51, "endOffset": 57}, {"referenceID": 8, "context": "convergent to a local optimum or equilibrium point [23,9].", "startOffset": 51, "endOffset": 57}, {"referenceID": 19, "context": "The role assignment is a part of the hierarchical machine learning paradigm [20,19], where a formation defines the role space.", "startOffset": 76, "endOffset": 83}, {"referenceID": 18, "context": "The role assignment is a part of the hierarchical machine learning paradigm [20,19], where a formation defines the role space.", "startOffset": 76, "endOffset": 83}, {"referenceID": 3, "context": ", [4]).", "startOffset": 2, "endOffset": 5}, {"referenceID": 17, "context": "Within the domain of robotic soccer, RL has been successfully applied in learning the keep-away subtask in the RoboCup 2D [18] and 3D [16] Soccer Simulation Leagues.", "startOffset": 122, "endOffset": 126}, {"referenceID": 15, "context": "Within the domain of robotic soccer, RL has been successfully applied in learning the keep-away subtask in the RoboCup 2D [18] and 3D [16] Soccer Simulation Leagues.", "startOffset": 134, "endOffset": 138}, {"referenceID": 1, "context": "Also, in other RoboCup leagues, such as the Middle Size League, RL has been applied successfully to acquire competitive behaviors [2].", "startOffset": 130, "endOffset": 133}, {"referenceID": 13, "context": "One of the noticeable impact on RL is reported by the Brainstormers team, the RoboCup 2D Simulation League team, on learning different subtasks [14].", "startOffset": 144, "endOffset": 148}, {"referenceID": 14, "context": "A comprehensive analysis of a general batch RL framework for learning challenging and complex behaviors in robot soccer is reported in [15].", "startOffset": 135, "endOffset": 139}, {"referenceID": 20, "context": "Despite convergence guarantees, Q(\u03bb) [21] with linear function approximation has been used in role assignment in robot soccer [5] and faster learning is observed with the introduction of heuristically accelerated methods [3].", "startOffset": 37, "endOffset": 41}, {"referenceID": 4, "context": "Despite convergence guarantees, Q(\u03bb) [21] with linear function approximation has been used in role assignment in robot soccer [5] and faster learning is observed with the introduction of heuristically accelerated methods [3].", "startOffset": 126, "endOffset": 129}, {"referenceID": 2, "context": "Despite convergence guarantees, Q(\u03bb) [21] with linear function approximation has been used in role assignment in robot soccer [5] and faster learning is observed with the introduction of heuristically accelerated methods [3].", "startOffset": 221, "endOffset": 224}, {"referenceID": 5, "context": "The dynamic role allocation framework based on dynamic programming is described in [6] for real-time soccer environments.", "startOffset": 83, "endOffset": 86}, {"referenceID": 21, "context": "[22] have introduced a real-time learning architecture, Horde, for expressing knowledge using General Value Functions (GVFs).", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "In addition, following researches describe methods and components to build strategic agents: [1] describes a methodology to build a cognizant robot that possesses vast amount of situated, reversible and expressive knowledge.", "startOffset": 93, "endOffset": 96}, {"referenceID": 10, "context": "[11] presents a methodology to \u201cnext\u201d in real time predicting thousands of features of the world state, and [10] presents methods predict about temporally extended consequences of a robot\u2019s behaviors in general forms of knowledge.", "startOffset": 0, "endOffset": 4}, {"referenceID": 9, "context": "[11] presents a methodology to \u201cnext\u201d in real time predicting thousands of features of the world state, and [10] presents methods predict about temporally extended consequences of a robot\u2019s behaviors in general forms of knowledge.", "startOffset": 108, "endOffset": 112}, {"referenceID": 12, "context": ", [13,25]) for switching and prediction tasks in assistive biomedical robots.", "startOffset": 2, "endOffset": 9}, {"referenceID": 24, "context": ", [13,25]) for switching and prediction tasks in assistive biomedical robots.", "startOffset": 2, "endOffset": 9}, {"referenceID": 20, "context": "Recently, within the context of the RL framework [21], a knowledge representation language has been introduced, that is expressive and learnable from sensorimotor data.", "startOffset": 49, "endOffset": 53}, {"referenceID": 21, "context": "pseudo-terminal-reward function [22].", "startOffset": 32, "endOffset": 36}, {"referenceID": 21, "context": "The complete information about the GVFs are available in [22,8,9,7].", "startOffset": 57, "endOffset": 67}, {"referenceID": 7, "context": "The complete information about the GVFs are available in [22,8,9,7].", "startOffset": 57, "endOffset": 67}, {"referenceID": 8, "context": "The complete information about the GVFs are available in [22,8,9,7].", "startOffset": 57, "endOffset": 67}, {"referenceID": 6, "context": "The complete information about the GVFs are available in [22,8,9,7].", "startOffset": 57, "endOffset": 67}, {"referenceID": 20, "context": "In the standard RL framework [21], let the agent and the world interact in discrete time steps t = 1, 2, 3, .", "startOffset": 29, "endOffset": 33}, {"referenceID": 0, "context": "The objective of the standard RL framework is to learn the stochastic action-selection policy \u03c0 : S\u00d7A \u2192 [0, 1], that gives the probability of selecting each action in each state, \u03c0(s, a) = \u03c0(s|a) = P(At = a|St = s), such that the agent maximizes rewards summed over the time steps.", "startOffset": 104, "endOffset": 110}, {"referenceID": 0, "context": "This factor is generalized to a termination function \u03b3 : S \u2192 [0, 1], where 1\u2212 \u03b3(s) is the probability of termination at state s, and a terminal reward z(s) is generated.", "startOffset": 61, "endOffset": 67}, {"referenceID": 6, "context": "Algorithm 1 Greedy-GQ(\u03bb) with linear function approximation for GVFs learning [7].", "startOffset": 78, "endOffset": 81}, {"referenceID": 0, "context": ") \u2208 [0, 1].", "startOffset": 4, "endOffset": 10}, {"referenceID": 20, "context": "We use a feature extractor \u03c6 : St \u00d7 At \u2192 {0, 1} , N \u2208 N, built on tile coding [21] to generate feature vectors from state variables and actions.", "startOffset": 78, "endOffset": 82}, {"referenceID": 6, "context": "Weights are learned using the gradientdescent temporal-difference Algorithm (1) [7].", "startOffset": 80, "endOffset": 83}, {"referenceID": 6, "context": "Algorithm 2 Off-PAC with linear function approximation for GVFs learning [7,24].", "startOffset": 73, "endOffset": 79}, {"referenceID": 23, "context": "Algorithm 2 Off-PAC with linear function approximation for GVFs learning [7,24].", "startOffset": 73, "endOffset": 79}, {"referenceID": 0, "context": ") \u2208 [0, 1].", "startOffset": 4, "endOffset": 10}, {"referenceID": 0, "context": "\u03c0 : St \u00d7At \u2192 [0, 1] (target policy is greedy w.", "startOffset": 13, "endOffset": 19}, {"referenceID": 0, "context": "\u03b3 : St \u2192 [0, 1] (termination function); 3.", "startOffset": 9, "endOffset": 15}, {"referenceID": 0, "context": "\u03c0b : St \u00d7At \u2192 [0, 1] (behavior policy); 2.", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "It : St \u00d7At \u2192 [0, 1] (interest function); 3.", "startOffset": 14, "endOffset": 20}, {"referenceID": 0, "context": "\u03bb : St \u2192 [0, 1] (eligibility-trace decay-rate function).", "startOffset": 9, "endOffset": 15}, {"referenceID": 5, "context": "Static role assignments often provide inferior performance in robot soccer [6].", "startOffset": 75, "endOffset": 78}, {"referenceID": 16, "context": "1: Primary formation, [17]", "startOffset": 22, "endOffset": 26}, {"referenceID": 11, "context": "These are part of reward shaping [12].", "startOffset": 33, "endOffset": 37}, {"referenceID": 21, "context": "It is not a uniformly distributed policy as used in [22].", "startOffset": 52, "endOffset": 56}], "year": 2014, "abstractText": "Collecting and maintaining accurate world knowledge in a dynamic, complex, adversarial, and stochastic environment such as the RoboCup 3D Soccer Simulation is a challenging task. Knowledge should be learned in real-time with time constraints. We use recently introduced Off-Policy Gradient Descent algorithms within Reinforcement Learning that illustrate learnable knowledge representations for dynamic role assignments. The results show that the agents have learned competitive policies against the top teams from the RoboCup 2012 competitions for three vs three, five vs five, and seven vs seven agents. We have explicitly used subsets of agents to identify the dynamics and the semantics for which the agents learn to maximize their performance measures, and to gather knowledge about different objectives, so that all agents participate effectively and efficiently within the group.", "creator": "LaTeX with hyperref package"}}}