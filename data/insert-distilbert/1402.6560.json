{"id": "1402.6560", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Feb-2014", "title": "Even more generic solution construction in Valuation-Based Systems", "abstract": "valuation algebras abstract a hugely large number of formalisms fit for automated reasoning and enable the definition of generic inference procedures. many of these formalisms provide by some notions of stable solutions. typical examples are satisfying assignments in constraint decision systems, models in logics or solutions to linear equation systems.", "histories": [["v1", "Wed, 26 Feb 2014 14:51:57 GMT  (17kb)", "http://arxiv.org/abs/1402.6560v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["jordi roca-lacostena", "jesus cerquides"], "accepted": false, "id": "1402.6560"}, "pdf": {"name": "1402.6560.pdf", "metadata": {"source": "CRF", "title": "Even more generic solution construction in Valuation-Based Systems", "authors": ["Jordi Roca-Lacostena", "Jesus Cerquides"], "emails": ["cerquide}@iiia.csic.es"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 2.\n65 60\nv1 [\ncs .A\nI] 2\n6 Fe\nRecently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8]. Unfortunately, the formalization of Pouly and Kohlas relies on a theorem for which we provide a counter example. In spite of that, the mainline of the theory described is correct, although some of the necessary conditions to apply some of the algorithms have to be revised. To fix the theory, we generalize some of their definitions and provide correct sufficient conditions for the algorithms. As a result, we get a more general and corrected version of the theory presented at [9, 8]."}, {"heading": "1 Introduction", "text": "Solving discrete optimization problems is an important and well-studied task in computer science. One particular approach to tackle them is known as dynamic programming [2] and can be found in almost every handbook about algorithms and programming techniques. The works of Bellman [1], Nemhauser [7] and Bertel\u00e8 and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers. A more general approach was taken by Mitten [6] and further generalized by Shenoy in 1996 [10], for functions taking values in any ordered set \u2206. Shenoy introduces a set of axioms that later on will be known as valuation algebras. In those terms, Shenoy is the first one to connect the concept of solution with the marginalization operation of the valuation algebra.\nIn 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set \u2206. They present several algorithms,\n\u2217IIIA - CSIC, Campus UAB, Spain, email: {jroca, cerquide}@iiia.csic.es\nand characterize the sufficient conditions for its correctness. Pouly and Kohlas\u2019 algorithms are more general than their predecessors in the literature. This increased generality comes at no computational cost, since when applied in the previously covered scenarios, their particularization coincides exactly with the previously proposed algorithm. Furthermore, by dropping the assumption that valuations are functions, their algorithms can be applied to previously uncovered cases such as the solution of linear equation systems or the algebraic path problem. Unfortunately, one of the fundamental results in Pouly and Kohlas\u2019 theory is incorrect.\nThe contributions of this work are:\n1. We provide a counterexample that invalidates Pouly and Kohlas\u2019 results.\n2. We generalize the problem solved by Pouly and Kohlas, and provide and algorithm to solve it.\n3. We provide a new sufficient condition for the correctness of the algorithm.\nThese results provide the most general theory for dynamic programming up-todate."}, {"heading": "2 Background", "text": "In this section we start by defining valuation algebras. Later on, we introduce the marginalization problem and finally we review the Collect algorithm to solve that problem.\nThe basic elements of a valuation algebra are so-called valuations, that we subsequently denote by lower-case Greek letters such as \u03c6 or \u03c8. Let D be a lattice[4] with a partial order\u2264, two operations meet \u2227 and join \u2228, a top element \u22a4, and a bottom element \u22a5. Given a set of valuations \u03a6, and a lattice of domains D, a valuation algebras has three operations:\n1. Labeling: \u03a6 \u2192 D;\u03c6 7\u2192 d(\u03c6),\n2. Combination: \u03a6\u00d7 \u03a6 \u2192 \u03a6; (\u03c6, \u03c8) 7\u2192 \u03c6\u2297 \u03c8,\n3. Projection: \u03a6\u00d7D \u2192 \u03a6; (\u03c6, x) 7\u2192 \u03c6\u2193x for x \u2264 d(\u03c6).\nsatisfying the following axioms:\nA1 Commutative semigroup: \u03a6 is associative and commutative under \u2297.\nA2 Labeling: For \u03c8, \u03c6 \u2208 \u03a6, d(\u03c6\u2297 \u03c8) = d(\u03c6) \u2228 d(\u03c8).\nA3 Projection: For \u03c6 \u2208 \u03a6, x \u2208 D, and x \u2264 d(\u03c6), d(\u03c6\u2193x) = x.\nA4 Transitivity: For \u03c6 \u2208 \u03a6 and x \u2264 y \u2264 d(\u03c6), (\u03c6\u2193y)\u2193x = \u03c6\u2193x.\nA5 Combination: For \u03c6, \u03c8 \u2208 \u03a6 with d(\u03c6) = x, d(\u03c8) = y, and z \u2208 D such that x \u2264 z \u2264 x \u2228 y, (\u03c8 \u2297 \u03c6)\u2193z = \u03c6\u2297 \u03c8\u2193z\u2227y.\nA6 Domain: For \u03c6 \u2208 \u03a6 with d(\u03c6) = x, \u03c6\u2193x = \u03c6.\nWe say that valuation e \u2208 \u03a6 is an identity valuation provided that d(e) = \u22a5 and \u03c6 \u2297 e = \u03c6 for each \u03c6 \u2208 \u03a6. As proven in [9], any valuation algebra that does not have and identity valuation can easily be extended to have one. In the following and without loss of generality we assume that our valuation algebra has an identity valuation e.\nVariable systems, frames and tuples. In most practical applications of valuation algebras, the domains of the valuations are subsets of a given set of variables V . It is well known (e.g. [3] page 36) that for any set V, the ordered set \u3008P(V ),\u2286\u3009 is a complete lattice, referred to as the power set lattice. Thus, most of the work on valuation algebras assumes that the lattice D is the power set lattice of a set V of variables.\nLet V = {x1, . . . , xn} be a finite set of variables1. We assume that for each variable x \u2208 V we can assign a set \u2126x of possible values, called its frame. Similarly, the frame of X \u2286 V is \u2126X = \u220f\nx\u2208X \u2126x. It is mathematically convenient to include a singleton element (noted as \u22c4) in \u2126\u2205. Thus, \u2126\u2205 = {\u22c4}. A pair \u3008V,\u2126\u3009 is known as a variable system. In many cases a variable system is naturally linked to a valuation algebra. Then we say that the valuation algebra is equipped with a variable system. A typical example is when valuations are discrete real functions and the domain of a valuation is the set of discrete variables over which the function is defined.\nA tuple x with finite domain X \u2286 V is an element of \u2126X . A projection operation can be defined on tuples, unrelated to the projection operation of the valuation algebra. Given a tuple x with domain X and Y \u2286 X we define the projection of x to Y as the tuple y that results from x by discarding the values of the variables in X \u2212 Y. We note the projection of x to Y as x\u2193Y . We can write x = (x\u2193Y ,x\u2193X\u2212Y ). Furthermore, x = (x, \u22c4) = (\u22c4,x).\nExample 1. Given a set of binary variables V , we consider its power set lattice as the domain lattice of the valuation algebra. The set of valuations is composed by all the functions \u03c6 : \u2126X \u2192 {0, 1} , where X \u2286 V . The labeling operation is defined by d(\u03c6) = X . The combination of two valuations \u03c6, \u03c8, is the valuation (\u03c6\u2297\u03c8)(x) = \u03c6(x\u2193d(\u03c6))+\u03c8(x\u2193d(\u03c8)), whereas the projection of a valuation \u03c6 with d(\u03c6) = X to a domain Y \u2286 X is the valuation \u03c6\u2193Y (y) = max z\u2208\u2126X\u2212Y \u03c6(y, z). As proven in [9] the valuation algebra of Boolean functions satisfies axioms A1-A6.\nSome other relevant examples of valuation algebras are relational algebra, which is fundamental to databases, or the algebra of probability potentials, which underlies many results in probabilistic graphical models and the more abstract class of semiring induced valuation algebras [5].\n1All the definitions are correct not only for finite but also for countable V"}, {"heading": "2.1 Finding the marginal of a factorized valuation", "text": "A relevant problem in many valuation algebras in the problem of finding the marginal of a factorized valuation.\nProblem 1. Let (\u03a6, D) be a valuation algebra, and \u03c61, . . . , \u03c6n be valuations in \u03a6. Find (\u03c61 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 \u03c6n) \u2193X .\nNote that when our valuations are probability potentials, this is the well studied problem of finding the marginal of a factorized distribution, also known as Markov Random Field.\nThe Fusion algorithm [10] (a.k.a. variable elimination) or the Collect algorithm (a.k.a. junction tree or cluster tree algorithm)[9, 8] can be used to find marginals. Since our results build on top of the Collect algorithm, we provide a more accurate description below.\nA necessary condition to apply the Collect algorithm is that we can organize the valuations \u03c61, . . . , \u03c6n into a covering join tree, which we introduce next.\nDefinition 1. A labeled tree is any tree (V,E) together with a function \u03bb : V \u2192 D that links each node with a single domain in D.\nA join tree is a labeled tree T = (V,E, \u03bb,D) such that for any i, j \u2208 V it holds that \u03bb(i) \u2227 \u03bb(j) \u2264 \u03bb(k) for all nodes k on the path between i and j. In that case, we say that T satisfies the running intersection property.\nDefinition 2. Given a valuation \u03c6 = \u03c61 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 \u03c6n we say that a join tree T = (V,E, \u03bb,D) is a covering join tree for this factorization if |V | = n and for all \u03c6i there is a node j \u2208 V such that d(\u03c6i) \u2264 \u03bb(j) .\nDefinition 3. Let i be a node in a rooted junction tree whose root is r. We use p(i) to denote the parent of i in the tree. The separator of i is si = {\n\u22a5 , if i = r\n\u03bb(i) \u2227 \u03bb(p(i)) , otherwise\nAlgorithm 1 provides a description of the Collect algorithm. It is based on sending messages up the tree, through the edges of the covering join tree, until the root node is reached. The message sent from each node summarizes the information in the corresponding subtree which is relevant to its parent. The running intersection property guarantees that no information is lost.\nTheorem 1. After running the Collect algorithm (Algorithm 1) over the\nnodes of a covering join tree for \u03c6 = \u220f k \u03c6k, we have that \u03c8 \u2032 i =\n(\n\u220f\nj\u2208Ti \u03c8j\n)\u2193\u03bb(i)\n.\nIn particular, if r is the root \u03c8\u2032r = \u03c6 \u2193\u03bb(r).\nThe theorem is an adaptation of Theorem 3.6 in [9]. As a consequence of this theorem, we can use the Collect algorithm to solve problem 1 provided that we are given a covering join tree for the factorization we would like to marginalize.\nAlgorithm 1 Collect algorithm Each node i of the junction tree executes\n1: \u22b2 Assess the product of valuations assigned to i 2: \u03c8i \u2190 e\u00d7 \u220f j\u2208a\u22121(i) \u03c6j 3: From each child j of i, receive a message \u00b5j\u2192i. 4: \u22b2 Incorporate messages from children 5: \u03c8\u2032i \u2190 \u03c8i \u00d7 \u220f j \u00b5j\u2192i. 6: if i is not the root then 7: Send message \u03c8\n\u2193si i to its parent p(i)\n8: end if"}, {"heading": "3 Generic solutions in valuation algebras with", "text": "variable system\nIn the previous section we have shown that the Collect algorithm can be used to find marginals. In this section we focus on the solution finding problem (SFP).\nThe problem is of foremost importance, since it lies at the foundation of dynamic programming [10, 2]. Furthermore, problems such as satisfiability, solving Maximum a Posteriori queries in a probabilistic graphical models, or maximum likelihood decoding are particular instances of the SFP.\nWe start by formally defining the problem and then we review the results of Pouly [8] and Pouly and Kohlas [9], who give algorithms for solving those problems and establish the conditions under which those algorithms are guaranteed to work. Unfortunately, although the inspirational ideas underlying Pouly and Kohlas\u2019 work are correct, their formal development is not. Thus, we end up the section providing a counter example to one of their main theorems."}, {"heading": "3.1 The SFP for valuation algebras with variable system", "text": "Up to know, the most general formalization of the SFP is the one provided by [10] and adapted by Pouly and Kohlas to the formal framework of valuation algebras in Chapter 8 of [9]. They assume a valuation algebra \u3008\u03a6, D\u3009 equipped with a variable system \u3008V,\u2126\u3009. As in the marginal assessment problem, in the SFP, we are given a set of valuations \u03c61, . . . , \u03c6m \u2208 \u03a6 as input. However, instead of a marginal of its combination \u03c6 = \u03c61 \u00d7 . . .\u00d7 \u03c6m, we are required to provide a tuple x with domain d(\u03c6), such that x is a solution for \u03c6. In order for the previous sentence to make any sense we need to properly define our concept of solution. The most general way in which we can do this is by defining a family c = {c\u03c6|\u03c6 \u2208 \u03a6} of solution sets, such that for each valuation \u03c6 \u2208 \u03a6, the solution set c\u03c6 contains the subset of \u2126d(\u03c6) such that x \u2208 \u2126d(\u03c6) is considered a solution for \u03c6 if and only if x \u2208 c\u03c6. We say that the family of sets c is a solution concept. Now we can formally define the SFP as follows\nProblem 2 (SFP with variable system). Given a valuation algebra \u3008\u03a6, D\u3009 equipped with a variable system \u3008V,\u2126\u3009 and a solution concept c, and a set\nof valuations \u03c61, . . . , \u03c6m \u2208 \u03a6, find x \u2208 \u2126d(\u03c6) such that x is a solution for \u03c6 = \u03c61 \u00d7 . . .\u00d7 \u03c6m."}, {"heading": "3.2 Solving the solution finding problem by composing partial solutions", "text": "Several authors have provided algorithms that solve the SFP and characterized under which conditions they can be successfully applied.\nAs described in the introduction, several works have sought to provide a formal foundation to dynamic programming, which we can now identify as a particular case of the SFP. In their works in 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set \u2206. They present several algorithms, and characterize the sufficient conditions for its correctness. By dropping the assumption that valuations are functions, their algorithms can be applied to previously uncovered cases .\nEssentially, the sufficient conditions for the correctness of Pouly and Kohlas\u2019 algorithms connect the operations in the valuation algebra with the solution concept by means of a family of configuration extension sets.2A family of configuration extension sets W assigns a configuration extension set to each pair \u3008\u03c6,x\u3009 such that \u03c6 is a valuation and x is a tuple whose domain X is a subset of d(\u03c6). That is W = {W\u03c6(x) \u2286 \u2126d(\u03c6)\u2212X |\u03c6 \u2208 \u03a6, X \u2286 d(\u03c6),x \u2208 \u2126X}. Furthermore, a family of configuration extension sets has to satisfy two conditions. The first one connects the projection operation of the valuation algebra with the extension sets by imposing that every extension set can be calculated in two steps. The second one connects the set of solutions of a valuation with the set of extensions of the empty tuple \u22c4. These conditions can be stated formally as follows\n1. For each \u03c6 \u2208 \u03a6, for each X \u2286 Y \u2286 d(\u03c6) and for each x \u2208 \u2126X we have that W\u03c6(x) = {z \u2208 \u2126d(\u03c6)\u2212X | z \u2193Y\u2212X \u2208 W\u03c6\u2193Y (x) and z \u2193d(\u03c6)\u2212Y \u2208\nW\u03c6(x, z \u2193Y\u2212X)}.\n2. For each \u03c6 \u2208 \u03a6, c\u03c6 =W\u03c6(\u22c4).\nBased on this definition, Pouly and Kohlas state the following theorem\nTheorem 2 (Theorem 8.1 in [9]). For any valuation \u03c6 \u2208 \u03a6 and any X,Y \u2286 d(\u03c6), we have\nc \u2193X\u222aY\n\u03c6 = {z \u2208 \u2126X\u222aY | z \u2193Y \u2208 c\u2193Y \u03c6 and z \u2193X\u2212Y \u2208 W\u03c6\u2193X (z \u2193X\u2229Y )}. (1)\nUnfortunately, the theorem is not correct. We will use the valuation algebra on Boolean functions from example 1to build a counterexample for it. Pouly and Kohlas (equation 8.19) defined the extension sets for the algebra of Boolean lattices as W\u03c6(x) = {y \u2208 \u2126d(\u03c6)\u2212X | \u03c6(x,y) = \u03c6\n\u2193X(x)}, where X \u2286 d(\u03c6), x \u2208 \u2126X .\n2Although they do never formally introduce families of configuration extension sets, we have introduced the concept here for mathematical correctness and so that the reader can easily follow the generalization that will come later on.\nCounterexample 1. Taking \u03c6 as the Boolean function \u03c6(x,y) =\n{\n1 if x = y, 0 otherwise ,\nX = {x}, and Y = {y} the result in theorem 2 does not hold.\nTo see why, we can assess both sides of equation 1 and see that they are not the same. For the left hand side, note that c\u2193X\u222aY\u03c6 = c\u03c6 = W\u03c6(\u22c4). Thus, c\u03c6 = {(x,y) \u2208 \u2126X\u222aY | \u03c6(x,y) = \u03c6\u2193\u2205(\u22c4)}. We can assess \u03c6\u2193\u2205(\u22c4) = maxx.y \u03c6(\u22c4, (x,y)) = maxx,y \u03c6(x,y) = 1. Hence, c \u2193X\u222aY \u03c6 = c\u03c6 = {(0, 0), (1, 1)}.\nLet A denote the set at the r.h.s. of equation 1. SinceX\u2229Y = \u2205 andX\u2212Y = X, we have that A = {z \u2208 \u2126X\u222aY | z\u2193Y \u2208 c \u2193Y \u03c6 and z \u2193X\u2212Y \u2208 W\u03c6\u2193X (z \u2193X\u2229Y )} = {z \u2208 \u2126X\u222aY | z\u2193Y \u2208 c \u2193Y \u03c6 and z \u2193X \u2208 W\u03c6\u2193X (\u22c4)}. We can assess c \u2193Y \u03c6 = {z \u2193Y | z \u2208 c\u03c6} = {(0), (1)}. Furthermore, we have that W\u03c6\u2193X (\u22c4) = {x \u2208 \u2126X | | \u03c6 \u2193X(x) = (\u03c6\u2193X)\u2193\u2205(\u22c4)} = {x \u2208 \u2126X | \u03c6\u2193X(x) = \u03c6\u2193\u2205(\u22c4)} = {x \u2208 \u2126X | \u03c6\u2193X(x) = 1}. We have that for all x \u2208 X, \u03c6\u2193X(x) = maxy \u03c6(x,y) = 1 , and thus, W\u03c6\u2193X (\u22c4) = \u2126X = {0, 1}. Hence, A = {z \u2208 \u2126X\u222aY | z\u2193Y \u2208 \u2126Y and z\u2193X \u2208 \u2126X} = \u2126X\u222aY = {(0, 0), (0, 1), (1, 0), (1, 1)}} 6= cX\u222aY\u03c6 , contradicting equation 1.\nSummarizing, in their works [8, 9] in 2011, Pouly and Kohlas make an attempt to generalize the results of Shenoy to valuation algebras equipped with a variable system, not restricting the valuations to be functions into a value set \u2206. However, as proved by counterexample 1, one of the key results in their development is not correct. Since the correctness proofs provided by Pouly and Kohlas for their algorithms rely on this result, what could be a minor technical detail ends up having strong consequences for the validity of the theory as a whole.\nThe main objective of the next section is to identify necessary conditions for the application of the algorithms presented by Pouly and Kohlas and to prove that their correctness under those conditions."}, {"heading": "4 Even more generic solutions in valuation alge-", "text": "bras\nDuring our efforts to identify the necessary conditions for the application of the algorithms presented by Pouly and Kohlas we realized that nothing in the theory we were building required that the valuation algebra was equipped with a variable system. Thus, as a byproduct of the correction effort, the resulting theory is the first one that proposes a generic algorithm, the so-called Collect+Extend algorithm, to solve the SFP for valuation algebras which are not necessarily equipped with a variable system. The generality of the Collect+Extend algorithm allows it to be applied to valuation algebras such as the algebra of sparse potentials, an example that until now was not covered by any previous formalization.\nWe start this section by generalizing the definition of the SFP problem so that it does not enforces the valuation algebra to be equipped with a variable system. Then, we introduce the concept of piecewise extensibility, and we prove\nthat it is a sufficient condition for the correctness of the Collect+Extend. Finally, we introduce the Collect+ExtendAll algorithm, whose objective is obtaining not a single solution to the SFP, but every solution. We introduced fully piecewise extensibility and prove that it is a sufficient condition for the correctness of the Collect+ExtendAll algorithm."}, {"heading": "4.1 A more general solution finding problem", "text": "We start by introducing the concept of configuration system, a generalization of the concept of variable system that does not enforce tuples to be members of a Cartesian product. Then we generalize the SFP to configuration systems.\nConfiguration systems, compatibility and merge-friendliness. We start by relating each element of the domain lattice with a set of configurations, and then we impose a minimal constraint among those sets of configurations, resulting in the notion of configuration system.\nDefinition 4 (Configuration system). Given a lattice D, a configuration system \u3008\u0393, \u03c0\u3009 is composed of (i) a set of configurations \u0393s for each s \u2208 D and (ii) for each pair of domains s, t \u2208 D such that s \u2264 t, a surjective mapping \u03c0t\u2192s : \u0393t \u2192 \u0393s. Without loss of generality, the configuration sets are assumed to be mutually exclusive. Furthermore, \u0393\u22a5 = {\u2666}.\nWhenever x \u2208 \u0393t, we say that x is a configuration with scope t. Given x \u2208 \u0393t, we note xs = \u03c0t\u2192s(x).\nIt is easy to see that any variable system is a configuration system. However, there are configuration systems which do not have an equivalent variable system.\nA relevant concept in a configuration system is that of compatibility between configurations.\nDefinition 5 (Compatibility, merger, merge-friendly). Let s, t \u2208 D and let x \u2208 \u0393s, and y \u2208 \u0393t. We say that x and y are compatible whenever there is z \u2208 \u0393s\u2228t such that zs = x and zt = y. We say that such a z is a merger of x and y. The definitions of compatibility and merger can be easily extended to a set of configurations instead of two. A configuration system is merge-friendly if for any s, t \u2208 D, any x \u2208 \u0393s, and any y \u2208 \u0393t whenever xs\u2227t = ys\u2227t, we have that x and y are compatible.\nWe are interested in merge-friendly configuration systems where a merger of a set of compatible configurations can be efficiently found. For example, in variable systems we can understand each tuple as restricting the values of some variables. Two tuples are compatible when there is no variable to which they assign a different value, and a merger can be easily obtained by imposing simultaneously the restrictions of both tuples.\nThe solution finding problem for valuation algebras with configuration systems. The definition of solution concept can be migrated from variable\nsystem to configuration system. In the latter case, a configuration system is a family c = {c\u03c6|\u03c6 \u2208 \u03a6} of solution sets, such that for each valuation \u03c6 \u2208 \u03a6, the solution set c\u03c6 contains the subset of \u0393d(\u03c6) such that x \u2208 \u0393d(\u03c6) is considered a solution for \u03c6 if and only if x \u2208 c\u03c6. The generalization of the solution finding problem is as follows\nProblem 3 (SFP). Given a valuation algebra \u3008\u03a6, D\u3009 equipped with a configuration system \u3008\u0393, \u03c0\u3009, and a solution concept c, and a set of valuations \u03c61, . . . , \u03c6m \u2208 \u03a6, find x \u2208 \u0393d(\u03c6) such that x is a solution for \u03c6 = \u03c61 \u00d7 . . .\u00d7 \u03c6m.\nFollowing Pouly and Kohlas, in order to be able to state the algorithms that solve the SFP we need the solution concept to lie inside a family of configuration extension sets. This connects the configuration system of the domain lattice with the marginalization operation of the valuation algebra and with the solution concept.\nDefinition 6 (Family of configuration extension sets). Given a valuation algebra \u3008\u03a6, D\u3009, and a configuration system \u3008\u0393, \u03c0\u3009 over D, and a solution concept c, a family of configuration extension sets is a family of sets E = {E\u03c6(x)|d \u2208 D,\u03c6 \u2208 \u03a6,x \u2208 \u0393d}, that\n1. For all \u03c6 \u2208 \u03a6, for all x \u2208 \u0393d(\u03c6) ,\nE\u03c6(x) = {x}. (2)\n2. For all \u03c6 \u2208 \u03a6, for all s, t \u2208 D such that s 6= t and s \u2264 t \u2264 d(\u03c6), and for all x \u2208 \u0393s ,\nE\u03c6(x) = {y \u2208 \u0393d(\u03c6)|yt \u2208 E\u03c6\u2193t(x) and y \u2208 E\u03c6(yt)}. (3)\n3. For all \u03c6 \u2208 \u03a6, c\u03c6 = E\u03c6(\u22c4). (4)\nWhenever y \u2208 E\u03c6(x) we say that y is an extension of x to \u03c6. Note that in order for y to be an extension of x, the scope s of x must be smaller than the scope of y. We can extend the definition of extension to a scope u whatsoever: given x \u2208 \u0393u we say that y \u2208 \u0393t is an extension of x to \u03c6 if y \u2208 E\u03c6(xt\u2227u). This states that y is an extension of x if it y is an extension of that part of x which is of interest to \u03c6.\nNext, we introduce the Collect+Extend algorithm. The algorithm can be run on any valuation algebra equipped with a configuration system and a family of configuration extension sets. As the Collect algorithm, the Collect+Extend algorithm requires the existence of a covering join tree for the factorization. It has two different phases. During the first phase, the Collect algorithm is used to obtain the marginal of \u03c6 at the root of the tree. After that, during the second phase, the root starts from an empty configuration (\u22c4), and selects a configuration that belongs to the set of extensions of \u22c4 to his marginal. From there on, each node i of the tree receives from his parent p(i) enough\nAlgorithm 2 Extend algorithm Each node i of the junction tree executes\n1: if i is the root then 2: \u03bdi \u2190 \u22c4 3: else 4: From its parent pa(i), receive a message \u03bdi. 5: end if 6: \u22b2 Extend the parent solution to i\u2019s scope. 7: Select \u03b7i \u2208 E\u03c8\u2032\ni (\u03bdi).\n8: for all j children of i do 9: Send message \u03bdj = \u03c0di\u2192s(j)(\u03b7i) to children j. 10: end for\ninformation from the configuration selected by p(i) so that i can successfully extend it to his domain configuration set. We call this second phase the Extend phase. Algorithm 2 describes it in a more precise way. At the end of the Extend phase, each node i of the tree has a configuration \u03b7i over its domain. Provided that these configurations are compatible, we get a single configuration in \u0393d(\u03c6) by assessing its merger.\n4.2 Sufficient conditions for the correctness of the Col-\nlect+Extend algorithm\nIn this section we consider the problem of determining under which conditions the configuration assessed by the Collect+Extend algorithm is a solution to the SFP problem. The main result is the following theorem\nTheorem 3 (Collect+Extend suff. cond.). Let \u3008\u03a6, D\u3009 be a valuation algebra equipped with a merge-friendly configuration system \u3008\u0393, \u03c6\u3009, and a solution concept c. Let E be a piecewise extensible family of configuration extension sets. After running the Collect algorithm followed by the Extend algorithm (Algorithms 1 and 2) over the nodes of a covering join tree T for \u03c6 = \u220fn\nk=1 \u03c6k, we have that there is at least a merger z of {\u03b7i|i \u2208 V }, and that z is a solution of \u03c6.\nThe theorem requires the family of configuration extension sets E to be piecewise extensible. Next, we define piecewise extensibility and then we prove that it is a sufficient condition for the correctness of the Collect+Extend algorithm.\nPiecewise extensibility Intuitively, this means requiring that whenever a configuration z independently belongs to the set of extensions of two different valuations \u03c61 and \u03c62, then it does belong to the set of extensions to its product.\nDefinition 7. A configuration x (with scope s) is extensible to a valuation \u03c6 (with domain t) whenever E\u03c6(xs\u2227t) 6= \u2205. For any z \u2208 E\u03c6(xs\u2227t), we say that z is an extension of x to \u03c6.\nA family of configuration extension sets E is piecewise extensible when for any two valuations \u03c61, \u03c62 \u2208 \u03a6 with d1 = d(\u03c61) and d2 = d(\u03c62), any t \u2208 D, d1 \u2228 d2 \u2265 t \u2265 d1 \u2227 d2, any x \u2208 \u0393t and any extension z of x to both \u03c61 and \u03c62 , we have that z is an extension of x to \u03c61 \u00d7 \u03c62.\nNote that the piecewise extensibility requirement is defined only for pairs of valuations \u03c61 and \u03c62. The following lemma shows that provided that we have piecewise extensibility for two valuations, we can extend it to products of m valuations.\nLemma 1. Let (i) E be a piecewise extensible family of configuration extension sets, (ii) \u03c61, . . . , \u03c6m \u2208 \u03a6, and \u03c6 = \u220fm i=1 \u03c6i, and (iii) t \u2208 D, such that \u2228m i=1 di \u2265 t \u2265 \u2228m\ni=1 ri, where ri = di\u2227 ( \u2228 j 6=i dj ) , and di = d(\u03c6i). For any x \u2208 \u0393t and any\nextension z of x to \u03c61, . . . , \u03c6m we have that z is an extension of x to \u03c6.\nProof. By induction on the number of terms m. If m = 2, the result follows directly from the definition of piecewise extensible. Assume it is true for m < M, and prove it for m = M. We have that \u03c6 = \u220fM\ni=1 \u03c6i.We can break it as \u03c6 = \u03c61\u00d7 \u220fM i=2 \u03c6i = \u03c61\u00d7\u03be, making \u03be = \u220fM i=2 \u03c6i. We know z is an extension of x to \u03c61.We can apply the induction hypothesis to \u03be = \u220fM\ni=2 \u03c6i, to show that z is also an extension of x to \u03be and then we apply piecewise extensibility to conclude that z is an extension of x to \u03c6.\nIn order to apply the induction hypothesis, we take \u03be = \u220fM i=2 \u03c6i, and t \u2032 =\nt\u2227d(\u03be). It is easy to see that \u2228M i=2 di = d(\u03be) \u2265 t\u2227d(\u03be) = t \u2032. On the other hand, t\u2032 \u2265 \u2228M i=2 ri. Since z is an extension of xt\u2032 to \u03c62, . . . , \u03c6M , we have that for each i, z \u2208 E\u03c6i(xsi), where si = t \u2227 di.\nNote that d(\u03be) = \u2228M i=2 di. Take t \u2032 = t \u2227 d(\u03be). We can see that \u2228M i=2 di \u2265\nt\u2032 \u2265 \u2228M i=2 ri. Furthermore, for i 6= 1, we have that s \u2032 i = t \u2032 \u2227 di = t \u2227 d(\u03be) \u2227 di = t \u2227 ( \u2228M\ni=2 di) \u2227 di = t \u2227 di = si, and hence z is an extension of z \u2208 E\u03c6i(xs\u2032i ). Applying the induction hypothesis we have that zd(\u03be) \u2208 E\u03be(xt\u2032) = E\u03be(xt\u2227d(\u03be)).\nThe conditions to apply piecewise extensibility to \u03c61 \u00d7 \u03be are now in place.\nObserve that d1 \u2228 d(\u03be) \u2265 t \u2265 ( \u2228M\ni=2 di\n)\n\u2227 d1 = d(\u03be) \u2227 d1, that zd1 \u2208 E\u03c61(xs1 ),\nand that zd(\u03be) \u2208 E\u03be(xt\u2227d(\u03be)). Since E is piecewise extensible we have that z is an extension of x to \u03c6.\nSufficient condition for the correctness of Collect+Extend. Next, we see that on piecewise extensible family of configuration extension sets, it is possible to take benefit of the factorization of the valuation to find a solution by merging partial solutions to the different factors which are coherent between them. We start by proving this for a product of two valuations and a product of m valuations. Then we apply those results to prove that the Collect+Extend algorithm is correct.\nWe start proving the following lemma, that shows that provided we have piecewise extensibility, for any valuation that is the product of two factors, if\nwe are given a solution to the projection of the product to the domain of one of the factors and an extension of that solution to the second factor, the merger of these two is a solution to the product.\nLemma 2. Let E be a piecewise extensible family of configuration extension sets. Let \u03c61, \u03c62 \u2208 \u03a6, and let d1 = d(\u03c61), d2 = d(\u03c62), and \u03c6 = \u03c61 \u00d7 \u03c62. For any x \u2208 c\u03c6\u2193d1 ,any extension y of x to \u03c62, and any merger z of x and y, we have that z \u2208 c\u03c6.\nProof. First, we will use piecewise extensibility to prove that z \u2208 E\u03c6(x). To do that we apply definition 7 with t = d1. By hypothesis, we have that zd2 = y \u2208 E\u03c62(xd2\u2227d1). From equation 2, we have that E\u03c61(x) = {x}. Hence, zd1 = x \u2208 E\u03c61(x). Thus, z is a coherent extension of x to both \u03c61 and \u03c62 and we can apply piecewise extensibility to conclude that z \u2208 E\u03c6(x).\nThen, we can jointly apply equations 4 and 3 to conclude that z \u2208 c\u03c6 = E\u03c6(\u22c4).\nAs in the previous section, we can generalize this result to products of m valuations.\nLemma 3. Let E be a piecewise extensible family of configuration extension sets. Let \u03c6 = \u03c6\u03c1 \u00d7 \u220fm i=1 \u03c6i, with di = d(\u03c6i), d\u03c1 = d(\u03c6\u03c1), ri = di\u2227 ( \u2228 j 6=i dj ) , and d\u03c1 \u2265 \u2228m\ni=1 ri. Given x \u2208 c\u03c6\u2193d\u03c1 , for each 1 \u2264 i \u2264 m, yi an extension of x to \u03c6i, and any merger z of x and y1, . . . ,ym, we have that z \u2208 c\u03c6.\nProof. Let By induction on m. If m = 1, we can directly apply Lemma 2. Assume it is true form < M.We have to prove that it is true form =M. Let \u03be = \u220fm i=1 \u03c6i. First, we will prove that zd\u03be \u2208 E\u03be(xd\u03c1\u2227d\u03be) and then we will apply Lemma 2. To see that zd\u03be \u2208 E\u03be(xd\u03c1\u2227d\u03be), we apply Lemma 1 with t = d\u03c1 \u2227 d\u03be. We need to verify that \u2228m\ni=1 di \u2265 t \u2265 \u2228m\ni=1 ri. The left inequality is satisfied since t = d\u03c1\u2227d\u03be = d\u03c1\u2227( \u2228m i=1 di) \u2264 \u2228m i=1 di. Since for all i, ri \u2264 d\u03be, we have that \u2228m\ni=1 ri \u2264 d\u03be. Since by hypothesis we have that d\u03c1 \u2265 \u2228m\ni=1 ri, we can conclude that d\u03c1 \u2227 d\u03be \u2265 \u2228m\ni=1 ri.\nFurthermore we can verify that for each i \u2208 {1, . . . ,m}, zdi = yi \u2208 E\u03c6i(xt\u2227di). Note that t\u2227di = d\u03c1 \u2227d\u03be \u2227di = d\u03c1 \u2227 ( \u2228m\ni=1 di)\u2227di = d\u03c1 \u2227di, and by hypothesis we have that zdi = yi \u2208 E\u03c6i(xd\u03c1\u2227di,).\nApplying Lemma 1, we get that zd\u03be \u2208 E\u03be(xd\u03c1\u2227d\u03be) and since by hypothesis we have that x \u2208 c\u03c6\u2193d\u03c1 , we can conclude from Lemma 2 that z \u2208 c\u03c6\u03c1\u00d7\u03c6\u03be = c\u03c6.\nThe former results allow us to state the following theorem (the main result of the section) proving that when a valuation breaks as a product of smaller valuations, the Collect+Extend algorithm can be used to assess a solution to it.\nTheorem 3 (Collect+Extend suff. cond.). Let \u3008\u03a6, D\u3009 be a valuation algebra equipped with a merge-friendly configuration system \u3008\u0393, \u03c6\u3009, and a solution concept c. Let E be a piecewise extensible family of configuration extension\nsets. After running the Collect algorithm followed by the Extend algorithm (Algorithms 1 and 2) over the nodes of a covering join tree T for \u03c6 = \u220fn\nk=1 \u03c6k, we have that there is at least a merger z of {\u03b7i|i \u2208 V }, and that z is a solution of \u03c6.\nProof. By induction on the number of nodes of the junction tree. If the junction tree has only one node then the proof is trivial.\nAssume that the junction tree has m > 1 nodes. We can see that the conditions to apply Lemma 3 are satisfied at the root.\n1. \u03c6 = \u03c8\u03c1 \u00d7 \u220f i\u2208Children(\u03c1) \u03bei, where \u03bei = \u220f j\u2208Ti \u03c8i. Let d \u2032 i = d(\u03bei)\n2. For each i, j \u2208 Children(\u03c1) such that i 6= j, due to the running intersection\nproperty we have that d\u03c1 \u2265 d\u2032i \u2227 ( \u2228 j 6=i d \u2032 j ) .\n3. x \u2208 c\u03c6\u2193d\u03c1 .\n4. For each i \u2208 Children(\u03c1), yi \u2208 E\u03bei(xd\u03c1\u2227d\u2032i)\n5. z is a merger of x and each of the y\u2032is\nAs a consequence of lemma 3, we can conclude that z \u2208 c\u03c6.\nFully piecewise extensibility and assessing all solutions. By strengthening the concept of piecewise extensibility, we can use an algorithm similar to Collect+Extend to assess all solutions instead of only one. The strengthening is named fully piecewise extensibility.\nDefinition 8. A family of configuration extension sets E is fully piecewise extensible when for any two valuations \u03c61, \u03c62 \u2208 \u03a6 with d1 = d(\u03c61) and d2 = d(\u03c62), any t \u2208 D, d1 \u2228 d2 \u2265 t \u2265 d1 \u2227 d2, any x \u2208 \u0393t and any z, we have that z is an extension of x to both \u03c61 and \u03c62 , if and only if z is an extension of x to \u03c61 \u00d7 \u03c62.\nThe algorithm and the theorem that shows that this is a sufficient condition are omitted due to lack of space but can be derived without effort."}, {"heading": "5 Conclusions", "text": "We have corrected and generalized the theory and algorithms for the generic construction of solutions in valuation based systems. To the best of our knowledge, these results provide the most general theory for dynamic programming up-to-date, covering commonly used examples such as finding the maximum of a combination of sparse functions, which the current theory did not cover."}], "references": [{"title": "Dynamic Programming", "author": ["R.E. Bellman"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1957}, {"title": "Nonserial Dynamic Programming, volume 91 of Mathematics in Science and Engineering", "author": ["Umberto Bertel\u00e8", "Francesco Brioschi"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1972}, {"title": "Introduction to lattices and order", "author": ["B.A. Davey", "H.A. Priestley"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2008}, {"title": "Lattice Theory: Foundation", "author": ["George Gr\u00e4tzer"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2011}, {"title": "Semiring induced valuation algebras: Exact and approximate local computation algorithms", "author": ["J Kohlas", "N Wilson"], "venue": "Artificial Intelligence,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "Composition Principles for Synthesis of Optimal Multistage Processes", "author": ["L.G. Mitten"], "venue": "Operations Research,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1964}, {"title": "Introduction to Dynamic Programming", "author": ["George L. Nemhauser"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1966}, {"title": "Generic solution construction in valuation-based systems", "author": ["Marc Pouly"], "venue": "Advances in Artificial Intelligence,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2011}, {"title": "Generic Inference", "author": ["Marc Pouly", "J\u00fcrg Kohlas"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Axioms for Dynamic Programming", "author": ["Prakash P Shenoy"], "venue": "Computational Learning and Probabilistic Reasoning,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1996}], "referenceMentions": [{"referenceID": 8, "context": "Recently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8].", "startOffset": 192, "endOffset": 198}, {"referenceID": 7, "context": "Recently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8].", "startOffset": 192, "endOffset": 198}, {"referenceID": 8, "context": "As a result, we get a more general and corrected version of the theory presented at [9, 8].", "startOffset": 84, "endOffset": 90}, {"referenceID": 7, "context": "As a result, we get a more general and corrected version of the theory presented at [9, 8].", "startOffset": 84, "endOffset": 90}, {"referenceID": 1, "context": "One particular approach to tackle them is known as dynamic programming [2] and can be found in almost every handbook about algorithms and programming techniques.", "startOffset": 71, "endOffset": 74}, {"referenceID": 0, "context": "The works of Bellman [1], Nemhauser [7] and Bertel\u00e8 and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers.", "startOffset": 21, "endOffset": 24}, {"referenceID": 6, "context": "The works of Bellman [1], Nemhauser [7] and Bertel\u00e8 and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers.", "startOffset": 36, "endOffset": 39}, {"referenceID": 1, "context": "The works of Bellman [1], Nemhauser [7] and Bertel\u00e8 and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers.", "startOffset": 65, "endOffset": 68}, {"referenceID": 5, "context": "A more general approach was taken by Mitten [6] and further generalized by Shenoy in 1996 [10], for functions taking values in any ordered set \u2206.", "startOffset": 44, "endOffset": 47}, {"referenceID": 9, "context": "A more general approach was taken by Mitten [6] and further generalized by Shenoy in 1996 [10], for functions taking values in any ordered set \u2206.", "startOffset": 90, "endOffset": 94}, {"referenceID": 8, "context": "In 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set \u2206.", "startOffset": 26, "endOffset": 32}, {"referenceID": 7, "context": "In 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set \u2206.", "startOffset": 26, "endOffset": 32}, {"referenceID": 3, "context": "Let D be a lattice[4] with a partial order\u2264, two operations meet \u2227 and join \u2228, a top element \u22a4, and a bottom element \u22a5.", "startOffset": 18, "endOffset": 21}, {"referenceID": 8, "context": "As proven in [9], any valuation algebra that does not have and identity valuation can easily be extended to have one.", "startOffset": 13, "endOffset": 16}, {"referenceID": 2, "context": "[3] page 36) that for any set V, the ordered set \u3008P(V ),\u2286\u3009 is a complete lattice, referred to as the power set lattice.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "As proven in [9] the valuation algebra of Boolean functions satisfies axioms A1-A6.", "startOffset": 13, "endOffset": 16}, {"referenceID": 4, "context": "Some other relevant examples of valuation algebras are relational algebra, which is fundamental to databases, or the algebra of probability potentials, which underlies many results in probabilistic graphical models and the more abstract class of semiring induced valuation algebras [5].", "startOffset": 282, "endOffset": 285}, {"referenceID": 9, "context": "The Fusion algorithm [10] (a.", "startOffset": 21, "endOffset": 25}, {"referenceID": 8, "context": "junction tree or cluster tree algorithm)[9, 8] can be used to find marginals.", "startOffset": 40, "endOffset": 46}, {"referenceID": 7, "context": "junction tree or cluster tree algorithm)[9, 8] can be used to find marginals.", "startOffset": 40, "endOffset": 46}, {"referenceID": 8, "context": "6 in [9].", "startOffset": 5, "endOffset": 8}, {"referenceID": 9, "context": "The problem is of foremost importance, since it lies at the foundation of dynamic programming [10, 2].", "startOffset": 94, "endOffset": 101}, {"referenceID": 1, "context": "The problem is of foremost importance, since it lies at the foundation of dynamic programming [10, 2].", "startOffset": 94, "endOffset": 101}, {"referenceID": 7, "context": "We start by formally defining the problem and then we review the results of Pouly [8] and Pouly and Kohlas [9], who give algorithms for solving those problems and establish the conditions under which those algorithms are guaranteed to work.", "startOffset": 82, "endOffset": 85}, {"referenceID": 8, "context": "We start by formally defining the problem and then we review the results of Pouly [8] and Pouly and Kohlas [9], who give algorithms for solving those problems and establish the conditions under which those algorithms are guaranteed to work.", "startOffset": 107, "endOffset": 110}, {"referenceID": 9, "context": "Up to know, the most general formalization of the SFP is the one provided by [10] and adapted by Pouly and Kohlas to the formal framework of valuation algebras in Chapter 8 of [9].", "startOffset": 77, "endOffset": 81}, {"referenceID": 8, "context": "Up to know, the most general formalization of the SFP is the one provided by [10] and adapted by Pouly and Kohlas to the formal framework of valuation algebras in Chapter 8 of [9].", "startOffset": 176, "endOffset": 179}, {"referenceID": 8, "context": "In their works in 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set \u2206.", "startOffset": 41, "endOffset": 47}, {"referenceID": 7, "context": "In their works in 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set \u2206.", "startOffset": 41, "endOffset": 47}, {"referenceID": 8, "context": "1 in [9]).", "startOffset": 5, "endOffset": 8}, {"referenceID": 7, "context": "Summarizing, in their works [8, 9] in 2011, Pouly and Kohlas make an attempt to generalize the results of Shenoy to valuation algebras equipped with a variable system, not restricting the valuations to be functions into a value set \u2206.", "startOffset": 28, "endOffset": 34}, {"referenceID": 8, "context": "Summarizing, in their works [8, 9] in 2011, Pouly and Kohlas make an attempt to generalize the results of Shenoy to valuation algebras equipped with a variable system, not restricting the valuations to be functions into a value set \u2206.", "startOffset": 28, "endOffset": 34}], "year": 2014, "abstractText": "Valuation algebras abstract a large number of formalisms for automated reasoning and enable the definition of generic inference procedures. Many of these formalisms provide some notions of solutions. Typical examples are satisfying assignments in constraint systems, models in logics or solutions to linear equation systems. Recently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8]. Unfortunately, the formalization of Pouly and Kohlas relies on a theorem for which we provide a counter example. In spite of that, the mainline of the theory described is correct, although some of the necessary conditions to apply some of the algorithms have to be revised. To fix the theory, we generalize some of their definitions and provide correct sufficient conditions for the algorithms. As a result, we get a more general and corrected version of the theory presented at [9, 8].", "creator": "LaTeX with hyperref package"}}}