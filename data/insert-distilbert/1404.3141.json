{"id": "1404.3141", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Apr-2014", "title": "Datalog Rewritability of Disjunctive Datalog Programs and its Applications to Ontology Reasoning", "abstract": "we fundamentally study the problem of similarly rewriting a disjunctive datalog c program indexed into plain rectangular datalog. we show that a disjunctive program is rewritable similarly if and only if it properly is equivalent to a linear disjunctive regular program, thus providing a novel characterisation of datalog rewritability. motivated by this result, we propose weakly linear disjunctive datalog - - - a novel rule - based kr language that equally extends both datalog structure and linear disjunctive composite datalog and for which reasoning structure is tractable in data complexity. we then explore applications of weakly linear programs to ontology reasoning and propose rendering a tractable extension of global owl 2 query rl with disjunctive axioms. our empirical testing results suggest that many non - horn ontologies can be comfortably reduced to weakly linear programs and that query answering over such generic ontologies using a datalog engine is feasible in practice.", "histories": [["v1", "Fri, 11 Apr 2014 15:47:40 GMT  (56kb,D)", "http://arxiv.org/abs/1404.3141v1", "14 pages. To appear at AAAI-14"]], "COMMENTS": "14 pages. To appear at AAAI-14", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["mark kaminski", "yavor nenov", "bernardo cuenca grau"], "accepted": true, "id": "1404.3141"}, "pdf": {"name": "1404.3141.pdf", "metadata": {"source": "CRF", "title": "Datalog Rewritability of Disjunctive Datalog Programs and its Applications to Ontology Reasoning", "authors": ["Mark Kaminski", "Yavor Nenov", "Bernardo Cuenca Grau"], "emails": [], "sections": [{"heading": null, "text": "1 Introduction Disjunctive datalog, which extends plain datalog by allowing disjunction in the head of rules, is a prominent KR formalism that has found many applications in the areas of deductive databases, information integration and ontological reasoning (Eiter, Gottlob, and Mannila 1997; Dantsin et al. 2001).1 Disjunctive datalog is a powerful language, which can model incomplete information. Expressiveness comes, however, at the expense of computational cost: fact entailment is co-NEXPTIME-complete in combined complexity and co-NP-complete w.r.t. data (Eiter, Gottlob, and Mannila 1997). Thus, even with the development of optimised implementations (Leone et al. 2006), robust behaviour of reasoners in data-intensive applications cannot be guaranteed.\nPlain datalog offers more favourable computational properties (EXPTIME-completeness in combined complexity and PTIME-completeness w.r.t. data) at the expense of a loss in expressive power (Dantsin et al. 2001). Tractability in data complexity is an appealing property for data-intensive KR; in particular, the RL profile of the ontology language OWL 2 was designed such that each ontology corresponds to a datalog program (Motik et al. 2009). Furthermore, datalog programs obtained from RL ontologies contain rules of a restricted shape, and they can be evaluated in polynomial time also in combined complexity, thus providing the ground\n1 Disjunctive datalog typically allows for negation-as-failure, which we don\u2019t consider since we focus on monotonic reasoning.\nfor robust implementations. The standardisation of OWL 2 RL has spurred the development of reasoning engines within industry and academia, such as OWLim (Bishop et al. 2011), Oracle\u2019s Semantic Data Store (Wu et al. 2008), and RDFox (Motik et al. 2014).\nWe study the problem of rewriting a disjunctive datalog program into an equivalent datalog program (i.e., one that entails the same facts for every dataset). By computing such rewritings, we can ensure tractability w.r.t. data and exploit reasoning infrastructure available for datalog. Not every disjunctive datalog program is, however, datalog rewritable (Afrati, Cosmadakis, and Yannakakis 1995).\nOur first contribution is a novel characterisation of datalog rewritability based on linearity: a restriction that requires each rule to contain at most one body atom with an IDB predicate (i.e., a predicate occurring in head position). For plain datalog, linearity is known to limit the effect of recursion and lead to reduced data and combined complexity (Dantsin et al. 2001). For disjunctive programs the effects of the linearity restriction are, to the best of our knowledge, unknown. In Section 3, we show that every linear disjunctive program can be polynomially transformed into an equivalent datalog program; conversely, we also provide a polynomial transformation from datalog into linear disjunctive datalog. Thus, linear disjunctive datalog and datalog have the same computational properties, and linearisability of disjunctive programs is equivalent to rewritability into datalog.\nMotivated by our characterisation, in Section 4 we propose weakly linear disjunctive datalog: a rule language that extends both datalog and linear disjunctive datalog. In a weakly linear (WL for short) program, the linearity requirement is relaxed: instead of applying to all IDB predicates, it applies only to those that \u201cdepend\u201d on a disjunctive rule. Analogously to linear disjunctive programs, WL programs can be polynomially rewritten into datalog. Thus, our language captures disjunctive information while leaving the favourable computational properties of datalog intact.\nIn Section 5, we propose a linearisation procedure based on unfolding transformations. Our procedure picks a nonWL rule and a \u201cculprit\u201d body atom and replaces it with WL rules by \u201cunfolding\u201d the selected atom. Our procedure is incomplete: if it succeeds, it outputs a WL program, which is rewritten into datalog; if it fails, no conclusion can be drawn.\nIn Section 6, we focus on ontology reasoning. We pro-\nar X\niv :1\n40 4.\n31 41\nv1 [\ncs .A\nI] 1\n1 A\npr 2\n01 4\npose an extension of OWL 2 RL with disjunctive axioms such that each ontology in our extended profile maps to a WL program. We show that the resulting programs can be evaluated in polynomial time in combined complexity; thus, fact entailment in our language is no harder than in OWL 2 RL. Finally, we argue that the algorithm in (Hustadt, Motik, and Sattler 2007) can be combined with our techniques to rewrite a SHIQ ontology into a plain datalog program.\nWe have evaluated our techniques on a large ontology repository. Our results show that many non-Horn ontologies can be rewritten into WL programs, and thus into datalog. We have tested the scalability of query answering using our approach, with promising results. Proofs of our technical results are delegated to the appendix.\n2 Preliminaries We use standard first-order syntax and semantics and assume all formulae to be function-free. We assume that equality \u2248 is an ordinary predicate and that every set of set of formulae contains the standard explicit axiomatisation of \u2248 as a congruence relation for its signature.\nA fact is a ground atom and a dataset is a finite set of facts. A rule r is a sentence of the form \u2200~x\u2200~z.[\u03d5(~x, ~z)\u2192 \u03c8(~x)], where tuples of variables ~x and ~z are disjoint, \u03d5(~x, ~z) is a conjunction of distinct equality-free atoms, and \u03c8(~x) is a disjunction of distinct atoms. Formula \u03d5 is the body of r, and \u03c8 is the head. Quantifiers in rules are omitted. We assume that rules are safe, i.e., all variables in the head occur in the body. A rule is datalog if \u03c8(~x) has at most one atom, and it is disjunctive otherwise. A program P is a finite set of rules; it is datalog if it consists only of datalog rules, and disjunctive otherwise. We assume that rules in P do not share variables.\nFor convenience, we treat > and\u22a5 in a non-standard way as a unary and a nullary predicate, respectively. Given a program P , P> is the program with a rule Q(x1, . . . , xn) \u2192 >(xi) for each predicate Q in P and each 1 \u2264 i \u2264 n, and a rule \u2192 >(a) for each constant a in P . We assume that P> \u2286 P and > does not occur in head position in P \\ P>. We define P\u22a5 as consisting of a rule with \u22a5 as body and empty head. We assume P\u22a5 \u2286 P and no rule in P \\ P\u22a5 has an empty head or \u22a5 in the body. Thus, P \u222a D |= >(a) for every a in P \u222aD, and P \u222aD is unsatisfiable iff P \u222aD |= \u22a5.\nHead predicates in P \\ P> are intensional (or IDB) in P . All other predicates (including >) are extensional (EDB). An atom is intensional (extensional) if so is its predicate. A rule is linear if it has at most one IDB body atom. A program P is linear if all its rules are. In contrast to KR, in logic programming it is often assumed that IDB predicates do not occur in datasets. This assumption can be lifted (see, e.g., (Bry et al. 2007)): for every P and IDB predicate Q in P , let Q\u2032 be a fresh predicate; the IDB expansion Pe of P is obtained from P by renaming each IDB predicate Q in P with Q\u2032 and adding a rule Q(~x) \u2192 Q\u2032(~x), with ~x distinct variables. Then, for each D and each fact \u03b1 over the signature of P we have P \u222aD |= \u03b1 iff Pe \u222aD |= \u03b1\u03b8, where \u03b8 is the predicate substitution mapping each IDB predicate Q to Q\u2032.\nThe evaluation ofP over a datasetD is the set Eval(P,D) which comprises \u22a5 if P \u222a D is unsatisfiable and all facts entailed by P \u222a D otherwise. For a set of predicates S,\nEval(P,D)|S consists of those facts in Eval(P,D) involving predicates in S \u222a {\u22a5}. Program P \u2032 is a rewriting of P w.r.t. a set of predicates S if there is an injective predicate renaming \u03b8 such that (Eval(P,D)|S)\u03b8 = Eval(P \u2032,D)|S\u03b8 for every dataset D over the signature of P . The program P \u2032 is a rewriting of P if P \u2032 is a rewriting of P w.r.t. the set of all predicates in P . Clearly, Pe is a rewriting of P .\n3 Characterisation of Datalog Rewritability In this section, we establish a strong correspondence between linear disjunctive datalog and plain datalog. We show that every linear disjunctive program can be polynomially rewritten into datalog and, conversely, every datalog program is polynomially rewritable to a linear disjunctive program. Consequently, we not only can conclude that fact entailment over linear programs has exactly the same data and combined complexity as over plain datalog programs, but also that a disjunctive program is datalog rewritable if and only if it is linearisable. Thus, datalog rewritability and linearisability of disjunctive programs are equivalent problems.\nFrom Linear Programs to Datalog We first show that linear disjunctive programs can be polynomially rewritten into datalog. Let us consider the following program P1, which we want to rewrite into a datalog program \u039e(P1):\nP1 = {V (x)\u2192 B(x) \u2228G(x) (1) G(y) \u2227 E(x, y)\u2192 B(x) (2) B(y) \u2227 E(x, y)\u2192 G(x) } (3)\nPredicates V and E are EDB, so their extension depends solely on D. To prove facts about IDB predicates G and B we introduce fresh binary predicates BG, BB , GB , and GG. Intuitively, if a fact BG(c, d) holds in \u039e(P1) \u222a D then proving B(c) suffices for proving G(d) in P1 \u222a D. To \u201cinitialise\u201d the extension of these fresh predicates we need rules >(x) \u2192 XX(x, x) with X \u2208 {G,B}. The key step is then to \u201cflip\u201d the direction of all rules in P1 involving G or B by moving all IDB atoms from the head to the body and viceversa while at the same time replacing their predicates with the relevant auxiliary predicates. Thus, Rule (2) leads to the following rules in \u039e(P1) for each IDB predicate X:\nBX(x, z) \u2227 E(x, y)\u2192 GX(y, z) These rules are natural consequences of Rule (2) under the intended meaning of the auxiliary predicates: if we can prove a goal X(z) by proving first B(x), and E(x, y) holds, then by Rule (2) we deduce that proving G(y) suffices to prove X(z). In contrast to (2), Rule (1) contains no IDB body atoms. We \u201cflip\u201d this rule as follows, with X IDB:\nV (x) \u2227BX(x, z) \u2227GX(x, z)\u2192 X(z) Similarly to the previous case, this rule follows from Rule (1): if V (x) holds and we can establish that X(z) can be proved from B(x) and also from G(x), then X(z) must hold. Finally, we introduce rules that allow us to derive facts about the IDB predicates G and B from facts derived about the auxiliary predicates. For example, the rule B(x) \u2227 BX(x, z) \u2192 X(z) states that if B(x) holds and is sufficient to prove X(z), then X(z) must also hold.\nDefinition 1. Let P be a linear program and let \u03a3 be the set of IDB predicates in P \\ P>. For each (P,Q) \u2208 \u03a32, let PQ be a fresh predicate unique to (P,Q) where arity(PQ) = arity(P )+arity(Q). Then \u039e(P) is the datalog program containing the rules given next, where \u03d5 is the conjunction of all EDB atoms in a rule, \u03d5> is the least conjunction of>-atoms needed to make a rule safe, all predicates Pi are in \u03a3, and ~y, ~z are disjoint vectors of distinct fresh variables: 1. a rule \u03d5> \u2192 RR(~y, ~y) for every R \u2208 \u03a3; 2. a rule \u03d5>\u2227\u03d5\u2227 \u2227n i=1 P R i (~si, ~y)\u2192 QR(~t, ~y) for every rule\n\u03d5 \u2227Q(~t)\u2192 \u2228n i=1 Pi(~si) \u2208 P \\ P> and every R \u2208 \u03a3;\n3. a rule \u03d5 \u2227 \u2227n i=1 P R i (~si, ~y) \u2192 R(~y) for every rule \u03d5 \u2192\u2228n i=1 Pi(~si) \u2208 P \\ P> and every R \u2208 \u03a3; 4. a rule Q(~z)\u2227QR(~z, ~y)\u2192R(~y) for every (Q,R)\u2208\u03a32.\nThis transformation is quadratic and the arity of predicates is at most doubled. For P1, we obtain the following datalog program, where each rule mentioning X stands for one rule where X = B and one where X = G:\n\u039e(P1) = {V (x) \u2227BX(x, z) \u2227GX(x, z)\u2192 X(z) (1\u2019) BX(x, z) \u2227 E(x, y)\u2192 GX(y, z) (2\u2019) GX(x, z) \u2227 E(x, y)\u2192 BX(y, z) (3\u2019) >(x)\u2192 XX(x, x) (4) B(x) \u2227BX(x, z)\u2192 X(z) (5) G(x) \u2227GX(x, z)\u2192 X(z) } (6)\nCorrectness of \u039e is established by the following theorem. Theorem 2. If P is linear, then \u039e(P) is a polynomial datalog rewriting of P .\nThus, fact entailment over linear programs is no harder than in datalog: PTIME w.r.t. data and EXPTIME in combined complexity. Formally, Theorem 2 is shown by induction on hyperresolution derivations of facts entailed by the rules in P from a given dataset D (see Appendix). We next sketch the intuitions on P1 and D1 = {V (a), V (b), V (c), E(a, b), E(b, c), E(a, c)}.\nFigure 1, Part (a) shows a linear (hyperresolution) derivation \u03c11 of B(a) from P1\u222aD1 while Part (b) shows a derivation \u03c12 of the same fact from \u039e(P1) \u222a D1. We represent derivations as trees whose nodes are labeled with disjunctions of facts and where every inner node is derived from its children using a rule of the program (initialisation rules in \u03c12 are omitted for brevity). We first show that if B(a) is provable in P1 \u222a D1, then it is entailed by \u039e(P1) \u222a D1. From the premise, a linear derivation such as \u03c11 exists. The crux of the proof is to show that each disjunction of facts in \u03c11 corresponds to a set of facts over the auxiliary predicates entailed by \u039e(P1)\u222aD1. Furthermore, these facts must be of the form XB(u, a), where B(a) is the goal, u is a constant, and X \u2208 {B,G}. For example, B(c) \u2228 G(c) in \u03c11 corresponds to facts BB(c, a) and GB(c, a), which are provable from \u039e(P1) \u222a D1, as witnessed by \u03c12. Since \u03c11 is linear, it has a unique rule application that has only EDB atoms as premises, i.e., the application of (1), which generatesB(c)\u2228G(c). SinceBB(c, a) andGB(c, a) are provable from \u039e(P1) \u222a D1, we can apply (1\u2019) to derive B(a).\nFinally, we show the converse: if B(a) is provable from \u039e(P1) \u222aD1 then it follows from P1 \u222aD1. For this, we take a derivation such as \u03c12, and show that each fact in \u03c12 about an auxiliary predicate carries the intended meaning, e.g., for GB(b, a) we must have P1 \u222a D1 |= G(b)\u2192 B(a). From Datalog to Linear Programs The transformation from datalog to linear disjunctive datalog is based on the same ideas, but it is simpler in that we no longer distinguish between EDB and IDB atoms: a rule in P is now \u201cflipped\u201d by moving all its atoms from the head to the body and viceversa. Moreover, we make use of the IDB expansion Pe of P to ensure linearity of the resulting disjunctive program. Definition 3. Let P be a datalog program. For each pair (P,Q) of predicates in P , let PQ be a fresh predicate unique to (P,Q) where arity(PQ) = arity(P ) + arity(Q). Furthermore, let Pe be the IDB expansion of P . Then, \u03a8(P) is the linear disjunctive program containing, for each IDB predicate R in Pe the rules given next, where \u03d5> is the least conjunction of >-atoms making a rule safe and ~y = y1 . . . yarity(R) is a vector of distinct fresh variables:\n1. a rule \u03d5> \u2227 QR(~t, ~y) \u2192 \u2228n i=1 P\nR i (~si, ~y) for every rule\u2227n\ni=1 Pi(~si) \u2192 Q(~t) \u2208 Pe \\ Pe>, where Q(~t) 6= \u22a5 and\u2228n i=1 P R i (~si, ~y) is interpreted as \u22a5 if n = 0;\n2. a rule \u03d5> \u2192 \u2228n i=1 P R i (~si, ~y) for every \u2227n i=1 Pi(~si) \u2192\n\u22a5 \u2208 Pe \\ Pe>; 3. a rule \u03d5> \u2192 RR(~y, ~y); 4. a rule Q(~z)\u2227QR(~z, ~y)\u2192 R(~y) for every EDB predicate Q inPe, where ~z is a vector of distinct fresh variables. Again, the transformation is quadratic and the arity of\npredicates is at most doubled. Example 4. Consider P2, which encodes path system accessibility (a canonical PTIME-complete problem):\nP2 = {R(x, y, z) \u2227A(y) \u2227A(z)\u2192 A(x) } (7) Linear datalog is NLOGSPACE, and cannot capture P2. However, we can rewrite P2 into linear disjunctive datalog:\n\u03a8(P2) = {>(y) \u2227 >(z) \u2227A\u2032 A\u2032 (x, u) (7\u2019)\n\u2192 RA \u2032 (x, y, z, u) \u2228A\u2032A\n\u2032 (y, u) \u2228A\u2032A \u2032 (z, u)\nA\u2032 A\u2032 (x, y)\u2192 AA \u2032 (x, y) (8)\n>(x)\u2192 A\u2032A \u2032 (x, x) (9)\nA(x) \u2227AA \u2032 (x, y)\u2192 A\u2032(y) (10)\nR(x, y, z) \u2227RA \u2032 (x, y, z, u)\u2192 A\u2032(u) } (11)\nRule (7) yields Rule (7\u2019) in \u03a8(P2). Rule (8) is obtained from A(x) \u2192 A\u2032(x) \u2208 Pe. To see why we need the IDB expansion Pe, suppose we replaced Pe by P in Definition 3. Rule (8) would not be produced and A\u2032 would be replaced by A elsewhere. Then the rule A(x) \u2227 AA(x, y) \u2192 A(y) would not be linear since both A and AA would be IDB.\nCorrectness of \u03a8 is established by the following theorem. Theorem 5. If P is datalog, then \u03a8(P) is a polynomial rewriting of P into a linear disjunctive program.\nFrom Theorems 2 and 5 we obtain the following results. Corollary 6. A disjunctive program P is datalog rewritable iff it is rewritable into a linear disjunctive program. Corollary 7. Checking P \u222aD |= \u03b1 for P a linear program, D a dataset and \u03b1 a fact is PTIME-complete w.r.t. data complexity and EXPTIME-complete w.r.t. combined complexity.\n4 Weakly Linear Disjunctive Datalog In this section, we introduce weakly linear programs: a new class of disjunctive datalog programs that extends both datalog and linear disjunctive datalog. The main idea is simple: instead of requiring the body of each rule to contain at most one occurrence of an IDB predicate, we require at most one occurrence of a disjunctive predicate\u2014a predicate whose extension for some dataset could depend on the application of a disjunctive rule. This intuition is formalised as given next. Definition 8. The dependency graph GP = (V,E, \u00b5) of a program P is the smallest edge-labeled digraph such that:\n1. V contains every predicate occurring in P; 2. r \u2208 \u00b5(P,Q) whenever P,Q \u2208 V , r \u2208 P \\ P>, P occurs\nin the body of r, and Q occurs in the head of r; and 3. (P,Q) \u2208 E whenever \u00b5(P,Q) is nonempty. A predicate Q depends on a rule r \u2208 P if GP has a path that ends in Q and involves an r-labeled edge. Predicate Q is datalog if it only depends on datalog rules; otherwise, Q is disjunctive. Program P is weakly linear (WL for short) if every rule in P has at most one occurrence of a disjunctive predicate in the body.\nChecking whether P is WL is clearly feasible in polynomial time. If P is datalog, then all its predicates are datalog and P is WL. Furthermore, every disjunctive predicate is IDB and hence every linear program is also WL. There are, however, WL programs that are neither datalog nor linear. Consider P3, which extends P1 with the following rule:\nE(y, x)\u2192 E(x, y) (12) SinceE is IDB inP3, Rules (2) and (3) have two IDB atoms. Thus, P3 is not linear. The graph GP3 looks as follows.\nB\n> V E \u22a5\nG\n(1)\n(1)\n(2)\n(3)\n(3)(2) (12)\nPredicate V is EDB and hence does not depend on any rule. Predicates B and G depend on Rule (1) and hence are disjunctive. Finally, predicateE depends only on Rule (12) and hence it is a datalog predicate. Thus, P3 is WL. Definition 9. For P WL, let \u039e\u2032(P) be defined as \u039e(P) in Definition 1 but where: (i) \u03a3 is the set of all disjunctive predicates in P\\P>; (ii) \u03d5 denotes the conjunction of all datalog atoms in a rule; and (iii) in addition to rules (1)\u2013(4), \u039e\u2032(P) contains every rule in P with no disjunctive predicates.\nBy adapting the proof of Theorem 2 we obtain: Theorem 10. If P is WL, then \u039e\u2032(P) is a polynomial datalog rewriting of P .\nThus, fact entailment over WL programs has the same data and combined complexity as for datalog. Furthermore, \u039e\u2032(P) is a rewriting of P and hence it preserves the extension of all predicates. If, however, we want to query a specific predicate Q, we can compute a smaller program, which is linear in the size of P and preserves the extension of Q. Indeed, if Q is datalog, each proof in P of a fact about Q involves only datalog rules, and if Q is disjunctive, each such proof involves only auxiliary predicates XQ. Thus, in \u039e\u2032 we can dispense with all rules involving auxiliary predicates XR for R 6= Q. In particular, if Q is datalog, the rewriting contains no auxiliary predicates. Theorem 11. Let P be WL, S a set of predicates in P , and P \u2032 obtained from \u039e\u2032(P) by removing all rules with a predicate XR for R 6\u2208 S. Then P \u2032 is a rewriting of P w.r.t. S.\n5 Rewriting Programs via Unfolding Although WL programs can be rewritten into datalog, not all datalog rewritable programs are WL. Let P4 be as follows:\nP4 = {A(x) \u2227B(x)\u2192 C(x) \u2228D(x) (13) E(x)\u2192 A(x) \u2228 F (x) (14) C(x) \u2227R(x, y)\u2192 B(y) } (15)\nProgram P4 is not WL since both body atoms in (13) are disjunctive. However, P4 is datalog rewritable.\nWe now present a rewriting procedure that combines our results in Section 4 with the work of Gergatsoulis (1997) on program transformation for disjunctive logic programs. Our procedure iteratively eliminates non-WL rules by \u201cunfolding\u201d the culprit atoms w.r.t. the other rules in the program. It stops when the program becomes WL, and outputs a datalog program as in Section 4. The procedure is sound: if it\nProcedure 1 Rewrite Input: P: a disjunctive program Output: a datalog rewriting of P 1: P \u2032 := Pe 2: while P \u2032 not WL do 3: select r\u2208P \u2032 with more than one disjunctive body atom 4: select a disjunctive body atom \u03b1 \u2208 r 5: P \u2032 := Unfold(P \u2032, r, \u03b1) 6: return \u039e\u2032(P \u2032)\nsucceeds, the output is a datalog rewriting. It is, however, both incomplete (linearisability cannot be semi-decided just by unfolding) and non-terminating. Nevertheless, our experiments suggest that unfolding can be effective in practice since some programs obtained from realistic ontologies can be rewritten into datalog after a few unfolding steps.\nUnfolding We start by recapitulating (Gergatsoulis 1997). Given a disjunctive program P , a rule r in P , and a body atom \u03b1 of r, Gergatsoulis defines the unfolding of r at \u03b1 in P as a transformation of P that replaces r with a set of resolvents of r with rules in P at \u03b1 (see Appendix). We denote the resulting program by Unfold(P, r, \u03b1). Unfolding preserves all entailed disjunctions \u03d5 of facts: P |= \u03d5 iff Unfold(P, r, \u03b1) |= \u03d5 for all P , r, \u03b1, and \u03d5. However, to ensure that unfolding produces a rewriting we need a stronger correctness result that is dataset independent. Theorem 12. Let P0 be a disjunctive program and let P be a rewriting of P0 such that no IDB predicate in P occurs in P0. Let r be a rule in P and \u03b1 be an IDB body atom of r. Then Unfold(P, r, \u03b1) is a rewriting of P0. Moreover, no IDB predicate in Unfold(P, r, \u03b1) occurs in P0. The Rewriting Procedure Procedure 1 attempts to eliminate rules with several disjunctive body atoms by unfolding one such atom. Note that to satisfy the premise of Theorem 12, unfolding is applied to Pe rather than P . Correctness of Procedure 1 is established by the following theorem. Theorem 13. Let P be a disjunctive program. If Rewrite terminates on P with output P \u2032, then P \u2032 is a rewriting of P . Rewrite first transforms our example program P4 to P \u20324 = {A\u2032(x) \u2227B\u2032(x)\u2192 C \u2032(x) \u2228D\u2032(x) (16)\nE(x)\u2192 A\u2032(x) \u2228 F \u2032(x) (17) C \u2032(x) \u2227R(x, y)\u2192 B\u2032(y) } \u222a Paux (18)\nwhere Paux = {P (x) \u2192 P \u2032(x) | P \u2208 {A,B,C,D, F} } and A\u2032, B\u2032, C \u2032, D\u2032, F \u2032 are fresh. Rule (16) is not WL in P \u20324, and needs to be unfolded. We choose to unfold (16) on A\u2032(x). Thus, in Step 5, Rule (16) is replaced by the rules\nA(x) \u2227B\u2032(x)\u2192 C \u2032(x) \u2228D\u2032(x) (19) E(x) \u2227B\u2032(x)\u2192 C \u2032(x) \u2228D\u2032(x) \u2228 F \u2032(x) (20)\nThe resulting P \u2032\u20324 is WL, and Rewrite returns \u039e\u2032(P \u2032\u20324 ).\n6 Application to OWL Ontologies The RL profile is a fragment of OWL 2 for which reasoning is tractable and practically realisable by means of rule-based\ntechnologies. RL is also a fragment of datalog: each RL ontology can be normalised to a datalog program.\nWe next show how to extend RL with disjunctions while retaining tractability of consistency checking and fact entailment in combined complexity. We first recapitulate the kinds of normalised axioms that can occur in an RL ontology. We assume familiarity with Description Logic (DL) notation.\nA (normalised) RL ontology is a finite set of DL axioms of the form 1-10 in Table 1. The table also provides the translation of DL axioms into rules. We define RLt as the extension of RL with axioms capturing disjunctive knowledge.\nDefinition 14. An RLt ontology is a finite set of DL axioms of the form 1-11 in Table 1.\nFact entailment in RLt is co-NP-hard since RLt can encode non-3-colourability. Membership in co-NP holds since rules have bounded number of variables, and hence programs can be grounded in polynomial time (see Appendix). Tractability can be regained if we restrict ourselves to RLt ontologies corresponding to WL programs. WL programs P obtained from RLt ontologies have bounded number of variables, and thus variables in \u039e\u2032(P) are also bounded. Theorem 15. CheckingO\u222aD |= \u03b1, for O an RLt ontology that corresponds to a WL program, is PTIME-complete.\nThus, fact entailment in RLt is no harder than in RL, and one can use scalable engines such as RDFox. Our experiments indicate that many ontologies captured by RLt are either WL or can be made WL via unfolding, which makes data reasoning over such ontologies feasible.2\nDealing with Expressive Ontology Languages Hustadt, Motik, and Sattler (2007) developed an algorithm for transforming SHIQ ontologies into an equivalent disjunctive datalog program. Cuenca Grau et al. (2013) combined this algorithm with a knowledge compilation procedure (called Compile-Horn) obtaining a sound but incomplete and nonterminating datalog rewriting procedure for SHIQ. Our procedure Rewrite provides an alternative to Compile-Horn\n2For CQ answering, our language becomes co-NP-hard w.r.t. data, whereas RL is tractable. This follows from (Lutz and Wolter 2012) already for a single axiom of type 11.\nfor SHIQ. The classes of ontologies rewritable by the two procedures can be shown incomparable (e.g., Compile-Horn may not terminate on WL programs).\n7 Related Work Complexity of disjunctive datalog with negation as failure has been extensively studied (Ben-Eliyahu-Zohary and Palopoli 1997; Eiter, Gottlob, and Mannila 1997). The class of head-cycle free programs was studied in Ben-EliyahuZohary and Palopoli; Ben-Eliyahu-Zohary, Palopoli, and Zemlyanker (1997; 2000), where it was shown that certain reasoning problems are tractable for such programs (fact entailment, however, remains intractable w.r.t. data).\nGottlob et al. (2012) investigated complexity of disjunctive TGDs and showed tractability (w.r.t. data complexity) of fact entailment for a class of linear disjunctive TGDs. Such rules allow for existential quantifiers in the head, but require single-atom bodies; thus, they are incomparable to WL rules. Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013).\nLutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI.\nThe procedure in (Cuenca Grau et al. 2013), mentioned in Section 6, is used by Kaminski and Cuenca Grau (2013) to show first-order/datalog rewritability of two fragments of ELU . Notably, both fragments yield linear programs. Finally, our unfolding-based rewriting procedure is motivated by the work of Afrati, Gergatsoulis, and Toni (2003) on linearisation of plain datalog programs by means of program transformation techniques (Tamaki and Sato 1984; Proietti and Pettorossi 1993; Gergatsoulis 1997).\n8 Evaluation Rewritability Experiments. We have evaluated whether realistic ontologies can be rewritten to WL (and hence to datalog) programs. We analysed 118 non-Horn ontologies from BioPortal, the Prote\u0301ge\u0301 library, and the corpus in (Gardiner, Tsarkov, and Horrocks 2006). To transform ontologies into disjunctive datalog we used KAON2 (Motik 2006).3 KAON2 succeeded to compute disjunctive programs for 103 ontologies. On these, Rewrite succeeded in 35 cases: 8 programs were already datalog after CNF normalisation, 12 were linear, 12 were WL, and 3 required unfolding. Rewrite was limited to 1,000 unfolding steps, but all successful cases required at most 11 steps. On average, 73% of the predicates in ontologies were datalog, and so could be queried using a datalog engine (even if the disjunctive program could not\n3We doctored the ontologies to remove constructs outside SHIQ, and hence not supported by KAON2. The modified ontologies can be found on http://csu6325.cs.ox.ac.uk/WeakLinearity/\nbe rewritten). We identified 15 RLt ontologies and obtained WL programs for 13 of them. For comparison, we implemented the procedure Compile-Horn in (Cuenca Grau et al. 2013), which succeeded on 18 ontologies, only one of which could not be rewritten by our approach. Query Answering. We tested scalability of instance query answering using datalog programs obtained by our approach. For this, we used UOBM and DBpedia, which come with large datasets. UOBM (Ma et al. 2006) is a standard benchmark for which synthetic data is available (Zhou et al. 2013). We denote the dataset for k universities by Uk. We considered the RLt subset of UOBM (which is rewritable using Rewrite but not using Compile-Horn), and generated datasets U01, U04, U07, U10. DBpedia4 is a realistic ontology with a large dataset from Wikipedia. Since DBpedia is Horn, we extended it with reasonable disjunctive axioms. We used RDFox as a datalog engine. Performance was measured against HermiT (Motik, Shearer, and Horrocks 2009) and Pellet (Sirin et al. 2007). We used a server with two Intel Xeon E5-2643 processors and 128GB RAM. Timeouts were 10min for one query and 30min for all queries; a limit of 100GB was allocated to each task. We ran RDFox on 16 threads. Systems were compared on individual queries, and on precomputing answers to all queries. All systems succeeded to answer all queries for U01: HermiT required 890s, Pellet 505s, and we 52s. Table 2 depicts average times for datalog and disjunctive predicates, and number of queries on which a system failed.5 Pellet only succeeded to answer queries on U01. HermiT\u2019s performance was similar for datalog and disjunctive predicates. In our case, queries over the 130 datalog predicates in UOBM (88% of all predicates) were answered instantaneously (<1s); queries over disjunctive predicates were harder, since the rewritings expanded the dataset quadratically in some cases. Finally, due to its size, DBpedia\u2019s dataset cannot even be loaded by HermiT or Pellet. Using RDFox, our rewriting precomputed the answers for all DBpedia predicates in 48s.\n9 Conclusion We have proposed a characterisation of datalog rewritability for disjunctive datalog programs, as well as tractable fragments of disjunctive datalog. Our techniques can be applied to rewrite OWL ontologies into datalog, which enables the use of scalable datalog engines for data reasoning. Furthermore, our approach is not \u201call or nothing\u201d: even if an ontology cannot be rewritten, we can still answer queries over most (i.e., datalog) predicates using a datalog reasoner.\n4http://dbpedia.org/About 5Average times do not reflect queries on which a system failed.\nAcknowledgements This work was supported by the Royal Society, the EPSRC projects Score!, Exoda, and MaSI3, and the FP7 project OPTIQUE.\nReferences [Afrati, Cosmadakis, and Yannakakis 1995] Afrati, F.; Cosmadakis, S. S.; and Yannakakis, M. 1995. On datalog vs. polynomial time. J. Comput. System Sci. 51(2):177\u2013196.\n[Afrati, Gergatsoulis, and Toni 2003] Afrati, F.; Gergatsoulis, M.; and Toni, F. 2003. Linearisability of datalog programs. Theor. Comput. Sci. 308(1-3):199\u2013 226.\n[Artale et al. 2009] Artale, A.; Calvanese, D.; Kontchakov, R.; and Zakharyaschev, M. 2009. The DL-Lite family and relations. J. Artif. Intell. Res. 36:1\u201369.\n[Ben-Eliyahu-Zohary and Palopoli 1997] Ben-EliyahuZohary, R., and Palopoli, L. 1997. Reasoning with minimal models: Efficient algorithms and applications. Artif. Intell. 96(2):421\u2013449.\n[Ben-Eliyahu-Zohary, Palopoli, and Zemlyanker 2000] Ben-Eliyahu-Zohary, R.; Palopoli, L.; and Zemlyanker, V. 2000. More on tractable disjunctive datalog. J. Log. Programming 46(1-2):61\u2013101.\n[Bienvenu et al. 2013] Bienvenu, M.; ten Cate, B.; Lutz, C.; and Wolter, F. 2013. Ontology-based data access: A study through disjunctive datalog, CSP, and MMSNP. In PODS, 213\u2013224. arXiv:1301.6479.\n[Bishop et al. 2011] Bishop, B.; Kiryakov, A.; Ognyanoff, D.; Peikov, I.; Tashev, Z.; and Velkov, R. 2011. OWLim: A family of scalable semantic repositories. Semantic Web J. 2(1):33\u201342.\n[Bourhis, Morak, and Pieris 2013] Bourhis, P.; Morak, M.; and Pieris, A. 2013. The impact of disjunction on query answering under guarded-based existential rules. In IJCAI.\n[Bry et al. 2007] Bry, F.; Eisinger, N.; Eiter, T.; Furche, T.; Gottlob, G.; Ley, C.; Linse, B.; Pichler, R.; and Wei, F. 2007. Foundations of rule-based query answering. In Reasoning Web, 1\u2013153.\n[Cuenca Grau et al. 2013] Cuenca Grau, B.; Motik, B.; Stoilos, G.; and Horrocks, I. 2013. Computing datalog rewritings beyond Horn ontologies. In IJCAI. arXiv:1304.1402.\n[Dantsin et al. 2001] Dantsin, E.; Eiter, T.; Gottlob, G.; and Voronkov, A. 2001. Complexity and expressive power of logic programming. ACM Comput. Surv. 33(3):374\u2013425.\n[Eiter, Gottlob, and Mannila 1997] Eiter, T.; Gottlob, G.; and Mannila, H. 1997. Disjunctive datalog. ACM Trans. Database Syst. 22(3):364\u2013418.\n[Gardiner, Tsarkov, and Horrocks 2006] Gardiner, T.; Tsarkov, D.; and Horrocks, I. 2006. Framework for an automated comparison of description logic reasoners. In ISWC, 654\u2013667.\n[Gergatsoulis 1997] Gergatsoulis, M. 1997. Unfold/fold transformations for disjunctive logic programs. Inf. Process. Lett. 62(1):23\u201329.\n[Gottlob et al. 2012] Gottlob, G.; Manna, M.; Morak, M.; and Pieris, A. 2012. On the complexity of ontological reasoning under disjunctive existential rules. In MFCS, 1\u201318.\n[Hustadt, Motik, and Sattler 2007] Hustadt, U.; Motik, B.; and Sattler, U. 2007. Reasoning in Description Logics by a Reduction to Disjunctive Datalog. J. Autom. Reasoning 39(3):351\u2013384.\n[Kaminski and Cuenca Grau 2013] Kaminski, M., and Cuenca Grau, B. 2013. Sufficient conditions for first-order and datalog rewritability in ELU. In DL, 271\u2013293.\n[Leone et al. 2006] Leone, N.; Pfeifer, G.; Faber, W.; Eiter, T.; Gottlob, G.; Perri, S.; and Scarcello, F. 2006. The DLV system for knowledge representation and reasoning. ACM Trans. Comput. Log. 7(3):499\u2013562.\n[Lutz and Wolter 2012] Lutz, C., and Wolter, F. 2012. Nonuniform data complexity of query answering in description logics. In KR.\n[Ma et al. 2006] Ma, L.; Yang, Y.; Qiu, Z.; Xie, G. T.; Pan, Y.; and Liu, S. 2006. Towards a complete OWL ontology benchmark. In ESWC, 125\u2013139.\n[Motik et al. 2009] Motik, B.; Cuenca Grau, B.; Horrocks, I.; Wu, Z.; Fokoue, A.; and Lutz, C. 2009. OWL 2 Web Ontology Language Profiles. W3C Recommendation.\n[Motik et al. 2014] Motik, B.; Nenov, Y.; Piro, R.; Horrocks, I.; and Olteanu, D. 2014. Parallel materialisation of datalog programs in centralised, main-memory rdf systems. In AAAI.\n[Motik, Shearer, and Horrocks 2009] Motik, B.; Shearer, R.; and Horrocks, I. 2009. Hypertableau Reasoning for Description Logics. J. Artif. Intell. Res. 36:165\u2013228.\n[Motik 2006] Motik, B. 2006. Reasoning in Description Logics using Resolution and Deductive Databases. Ph.D. Dissertation, Univesita\u0308t Karlsruhe (TH), Karlsruhe, Germany.\n[Proietti and Pettorossi 1993] Proietti, M., and Pettorossi, A. 1993. The loop absorption and the generalization strategies for the development of logic programs and partial deduction. J. Log. Programming 16(1):123\u2013161.\n[Sirin et al. 2007] Sirin, E.; Parsia, B.; Cuenca Grau, B.; Kalyanpur, A.; and Katz, Y. 2007. Pellet: A practical OWLDL reasoner. J. Web Sem. 5(2):51\u201353.\n[Tamaki and Sato 1984] Tamaki, H., and Sato, T. 1984. Unfold/fold transformation of logic programs. In ICLP, 127\u2013 138.\n[Wu et al. 2008] Wu, Z.; Eadon, G.; Das, S.; Chong, E. I.; Kolovski, V.; Annamalai, M.; and Srinivasan, J. 2008. Implementing an inference engine for RDFS/OWL constructs and user-defined rules in Oracle. In ICDE, 1239\u20131248.\n[Zhou et al. 2013] Zhou, Y.; Cuenca Grau, B.; Horrocks, I.; Wu, Z.; and Banerjee, J. 2013. Making the most of your triple store: query answering in OWL 2 using an RL reasoner. In WWW, 1569\u20131580.\nA Proofs for Section 3 Definition 16. Let r = \u2227n i=1 \u03b2i \u2192 \u03d5 be a rule and, for each 1 \u2264 i \u2264 n, let \u03c8i be a disjunction of facts \u03c8i = \u03c7i \u2228 \u03b1i with \u03b1i a single fact. Let \u03c3 be an MGU of each \u03b2i, \u03b1i. Then the following disjunction of facts \u03d5\u2032 is a hyperresolvent of r and \u03c81, . . . , \u03c8n: \u03d5\u2032 = \u03d5\u03c3 \u2228 \u03c71 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c7n.6 Definition 17. Let P be a program, let D be a dataset, and let \u03d5 be a disjunction of facts. A (hyperresolution) derivation of \u03d5 from P \u222a D is a pair \u03c1 = (T, \u03bb) where T is a tree, \u03bb a labeling function mapping each node in T to a disjunction of facts, and the following properties hold for each v \u2208 T :\n1. \u03bb(v) = \u03d5 if v is the root; 2. \u03bb(v) \u2208 P \u222a D if v is a leaf; and 3. if v has children w1, . . . , wn, then \u03bb(v) is a hyperresolvent of a rule r \u2208 P and \u03bb(w1), . . . , \u03bb(wn).\nWe write P \u222a D ` \u03d5 to denote that \u03d5 has a derivation from P \u222a D. Hyperresolution is sound and complete in the following sense: If P \u222a D is unsatisfiable, then P \u222a D ` \u22a5, and otherwise P \u222a D ` \u03b1 iff \u03b1 \u2208 Eval(P,D).7\nDefinition 18. Let P be a (disjunctive) program and D be a dataset. A >-stub is a one-step derivation of a fact >(a) (for some a) from D using a rule in P>. A derivation \u03c1 = (T, \u03bb) from P \u222aD is normal if every node whose label involves > is the root of a >-stub. Proposition 19. Let P be a disjunctive program, let D be a dataset, and let \u03d5 be a nonempty disjunction of facts. For every derivation of \u03d5 from P \u222a D there is a normal derivation of a nonempty subset of \u03d5 from P \u222a D or a normal derivation of \u22a5 from P \u222a D.\nProof. Let \u03c1 = (T, \u03bb) be a derivation of \u03d5 from P \u222a D and let v be the root of T . We proceed by induction on the size of T . If >(a) \u2208 \u03bb(v) for some a, then a must occur in P \u222a D, and hence we can derive >(a) in one step with a rule P (x1, . . . , xn)\u2192 >(xi) \u2208 P> (if P (a1, . . . , ai\u22121, a, ai+1, . . . , an) \u2208 D) or with the rule (\u2192 >(a)) \u2208 P> (if a occurs in P).\nIf > does not occur in \u03bb(v), we proceed as follows. Let v1, . . . , vn be the successors of v in T (n = 0 if v is a leaf in T ), let r \u2208 P be the rule used to derive \u03bb(v) from \u03bb(v1), . . . , \u03bb(vn), and let \u03c3 be the substitution used in the corresponding hyperresolution step. By the inductive hypothesis, for every i \u2208 [1, n] there is some \u03c8i such that \u03c8i is a nonempty subset of \u03bb(vi) or \u03c8i = \u22a5 and \u03c8i has a normal derivation from P \u222a D. W.l.o.g., let \u03c8i 6= \u22a5 for every i \u2208 [1, n] (otherwise, the claim is immediate). We then distinguish two cases. If r applies to \u03c81, . . . , \u03c8n with substitution \u03c3, then the hyperresolvent \u03d5\u2032 of r and \u03c81, . . . , \u03c8n is a nonempty subset of \u03d5 (\u03d5\u2032 is nonempty since the only rule inP with an empty head is (\u22a5 \u2192) but, by assumption, \u03d51 6= \u22a5). If r does not apply to \u03c81, . . . , \u03c8n with substitution \u03c3, the claim follows since, for some i, we have \u03c8i \u2286 \u03d5.\nProposition 19 allows us to consider only normal derivations. In the following, without loss of generality, we assume every derivation to be normal.\nProposition 20. Let P be a disjunctive program, let D be a dataset, let \u03c1 = (T, \u03bb) be a derivation from P \u222a D, and let v be a node in T . If \u03bb(v) contains an EDB atom, then \u03bb(v) is a singleton.\nProof. The claim follows since whenever \u03bb(v) contains an EDB atom, we either have that v is a leaf in T , and thus \u03bb(v) \u2208 D, or that v is the root of a >-stub (since \u03c1 is implicitly assumed to be normal), and thus \u03bb(v) = >(a) for some individual a.\nDefinition 21. A nonempty tree T \u2032 = (V \u2032, E\u2032) is an upper portion of a tree T = (V,E) if the following conditions hold: \u2022 V \u2032 \u2286 V and E\u2032 is the restriction of E to V \u2032. \u2022 T and T \u2032 have the same root. \u2022 If v is an internal node in T \u2032, then every child of v in T is contained in V \u2032. Let P be a (disjunctive) datalog program, D a dataset, and \u03c1 = (T, \u03bb) a derivation of a fact P (~a) from P \u222a D where P 6= >. An upper portion of \u03c1 is a pair \u03c1\u2032 = (T \u2032, \u03bb\u2032) such that:\n\u2022 T \u2032 is an upper portion of T ; \u2022 \u03bb\u2032 is the restriction of \u03bb to the nodes in T \u2032; \u2022 If \u03bb\u2032(v) = >(b) for some v \u2208 T \u2032 and some individual b, then v is a leaf in T \u2032. Theorem 2. If P is linear, then \u039e(P) is a polynomial datalog rewriting of P .\nProof. Analogous to the proof of Theorem 10 in Appendix B (but simpler).\n6We view disjunctions as sets of formulae. 7This implies that P \u222a D ` \u22a5 iff Eval(P,D) = {\u22a5}.\nLemma 22. Let P be a datalog program, let D be a dataset, let P be an IDB predicate in Pe, and let \u03c1 = (T, \u03bb) be a derivation of a fact P (~a) from Pe \u222aD. Given a tree T \u2032, let leaves(T \u2032) be the set of leaves of T \u2032 and, given a set of nodes S, let \u03bb(S) = \u22c3 {\u03bb(t) | t \u2208 S }. For every upper portion \u03c1\u2032 = (T \u2032, \u03bb\u2032) of \u03c1 we have \u03a8(P) \u222a D |= \u2228 Q(~b)\u2208\u03bb(leaves(T \u2032))Q P (~b,~a).\nProof. Let \u03c1\u2032 = (T \u2032, \u03bb\u2032) be an upper portion of \u03c1 and let v be the root of T \u2032. In particular, we have \u03bb(v) = P (~a). We proceed by induction on the size of T \u2032. If v is the only node in T \u2032, the claim reduces to \u03a8(P) \u222a D |= PP (~a,~a). This follows since \u03d5> \u2192 PP (~x, ~x) \u2208 \u03a8(P) and \u03a8(P)> \u222a D |= \u03d5>(~a).\nNow suppose T \u2032 contains more than one node and let leaves(T \u2032) = {v1, . . . , vn}. Since T \u2032 is a tree, it has a node w of height 1. W.l.o.g., let v1, . . . , vk (1 \u2264 k \u2264 n) be the children of w in T \u2032, let r = \u2227k i=1Qi(~si)\u2192 R(~t) \u2208 Pe be the rule used to derive \u03bb(w) from \u03bb(s1), . . . , \u03bb(sk), and let \u03c3 be the substitution used in the corresponding hyperresolution step. Since w is an internal node in T \u2032, we have R 6= >, and hence r /\u2208 Pe>. Then:\n1. S = {w, vk+1, . . . , vn} is the set of leaves of an upper portion of \u03c1 that is strictly smaller than \u03c1\u2032; 2. \u03bb(w) = R(~t\u03c3) and \u03bb(vi) = Q(~si\u03c3) for every i \u2208 [1, k]; 3. (\u03bb(S) \\ {R(~t\u03c3)}) \u222a {Q1(~s1\u03c3), . . . , Qk(~sk\u03c3)} \u2286 \u03bb(leaves(T \u2032)); 4. RP (~t, ~y)\u2192 \u2228k i=1Q P i (~si, ~y) \u2208 \u03a8(P).\nBy (1), (2), and the inductive hypothesis, \u03a8(P) \u222a D |= RP (~t\u03c3,~a) \u2228 \u2228 Q(~b)\u2208\u03bb({vk+1,...,vn})Q P (~b,~a). Hence by (3), it suffices\nto show \u03a8(P) \u222a D |= RP (~t\u03c3,~a)\u2192 \u2228k i=1Q P i (~si\u03c3,~a), which follows by (4).\nLemma 23. Let P be a datalog program. For every dataset D over the signature of P and every fact \u03b1 such that Pe \u222aD |= \u03b1 we have \u03a8(P) \u222a D |= \u03b1.\nProof. LetD be a dataset and P (~a) a fact such that Pe\u222aD |= P (~a). W.l.o.g., let P be IDB in Pe. We show \u03a8(P)\u222aD |= P (~a). By completeness of hyperresolution, P (~a) has a derivation \u03c1 = (T, \u03bb) from Pe \u222a D. Let \u03c1\u2032 = (T \u2032, \u03bb\u2032) be the largest upper portion of \u03c1. By Lemma 22, \u03a8(P) \u222a D |= \u2228 Q(~b)\u2208\u03bb(leaves(T \u2032))Q\nP (~b,~a). Therefore, it suffices to show that \u03a8(P) \u222a D \u222a {QP (~b,~a)} |= P (~a) for every Q(~b) \u2208 \u03bb(leaves(T \u2032)). Since \u03c1\u2032 is maximal, we distinguish the following three cases for Q(~b):\n\u2022 Q(~b) \u2208 D. Then Q is EDB in Pe (since D only contains facts about predicates in P and every predicate in P is EDB in Pe). Hence Q(~z) \u2227QP (~z, ~y)\u2192 P (~y) \u2208 \u03a8(P). The claim follows.\n\u2022 Q(~b) is ground and (\u2192 Q(~b)) \u2208 Pe \\ Pe>. Hence QP (~b, ~y)\u2192 \u22a5 \u2208 \u03a8(P), and consequently \u03a8(P) \u222aD \u222a {QP (~b,~a)} |= \u22a5. The claim follows.\n\u2022 Q(~b) = >(b). Then the claim follows since >(z) \u2227 >P (z, ~y)\u2192 P (~y) \u2208 \u03a8(P) and \u03a8(P) \u222a D |= >(b).\nDefinition 24. Let P be a datalog program and let Q(~b) be a fact where Q is IDB in P . A disjunction \u03d5 of facts is focused on Q(~b) w.r.t. P if every disjunct \u03b1 \u2208 \u03d5 has one of the following forms: \u2022 \u03b1 = P (~a) where P is EDB in P; \u2022 \u03b1 = \u22a5; \u2022 \u03b1 = Q(~b); \u2022 \u03b1 = PQ(~a,~b) for some P and ~a.\nLet \u03c1 = (T, \u03bb) be a derivation (not necessarily from P). We call \u03c1 focused on Q(~b) w.r.t. P if so is the label of every node in T . Given a node v \u2208 T , we define \u03bbbase(v) := {P (~a) | PQ(~a,~b) \u2208 \u03bb(v) }. Lemma 25. Let P be a datalog program and let D be a dataset over the signature of P . Every derivation from \u03a8(P) \u222a D is focused on some fact \u03b1 w.r.t. Pe.\nProof. Let \u03c1 = (T, \u03bb) be a derivation from \u03a8(P) \u222a D and let v be the root of T . We show that \u03c1 is focused on some \u03b1 by induction on the size of T . If v is the only node in T , we distinguish the following cases:\n\u2022 \u03bb(v) \u2208 D. Then \u03bb(v) = P (~a) where P is EDB in Pe, and thus \u03c1 is focused on every IDB predicate in Pe. \u2022 arity(Q) = 0 and \u03bb(v) is obtained by a rule of the form (\u2192 \u2228n i=1 P Q i (~si)) \u2208 \u03a8(P) for some IDB predicate Q in Pe. Then\n\u03bb(v) = \u2228n i=1 P Q i (~si), meaning \u03c1 is focused on Q.\nIf v has successors v1, . . . , vm, we distinguish the following cases depending on the shape of the rule r \u2208 \u03a8(P) used to obtain \u03bb(v) from \u03bb(v1), . . . , \u03bb(vm).\n\u2022 r \u2208 \u03a8(P)>. Then m = 1 and \u03bb(v) = >(a) for some a. By the inductive hypothesis, \u03bb(v1) is focused on a fact w.r.t. Pe. The claim follows since > is EDB in Pe.\n\u2022 r = \u03d5>\u2227PQ(~t, ~y)\u2192 \u2228n i=1R\nQ(~si, ~y). Let \u03c3 be the substitution used in the hyperresolution step. W.l.o.g., let PQ(~t\u03c3, ~y\u03c3) \u2208 \u03bb(v1). Then, by Proposition 20, \u03bb(vj) \u2208 \u03d5> for j \u2208 [2,m]. Hence, \u03bb(v) \u2286 \u03bb(v1) \u222a {\u22a5}. The claim follows since, by the inductive hypothesis, the subderivation rooted at v1 is focused onQ(~b) (so, in particular, ~y\u03c3 = ~b), and v2, . . . , vm are focused on every IDB predicate in Pe.\n\u2022 r = (\u22a5 \u2192) or r = \u03d5> \u2192 \u2228n i=1R Q i (~si,\n~b) for some R and ~s1, . . . , ~sn. In both cases, the argument proceeds analogously to the preceding case (but simpler).\n\u2022 r = P (~z) \u2227 PQ(~z, ~y) \u2192 Q(~y). Then m = 2. Let \u03c3 be the substitution used in the hyperresolution step and, w.l.o.g., let PQ(~z\u03c3, ~y\u03c3) \u2208 \u03bb(v1). Then, by Proposition 20, \u03bb(v2) = P (~z\u03c3). Hence, \u03bb(v) \u2286 \u03bb(v1) \u222a {Q(~y\u03c3)}. The claim follows since, by the inductive hypothesis, the subderivation rooted at v1 is focused on Q(~b) and \u03bb(v2) is focused on every IDB predicate in Pe.\nSince the root of a derivation of a fact \u03b1 has to be labeled with \u03b1, Lemma 25 implies the following corollary.\nCorollary 26. Let P be a datalog program, let D be a dataset over the signature of P , and let Q(~b) be a fact where Q is IDB in Pe. Every derivation of Q(~b) from \u03a8(P) \u222a D is focused on Q(~b) w.r.t. Pe.\nLemma 27. Let P be a datalog program, let D be a dataset over the signature of P , and let \u03c1 = (T, \u03bb) be a derivation of a fact Q(~b) from \u03a8(P) \u222a D, where Q is IDB in Pe. For every node v in T whose label contains an IDB atom in \u03a8(P), we have Pe \u222a D |= ( \u2227 \u03b1\u2208\u03bbbase(v) \u03b1)\u2192 Q(~b).\nProof. We proceed by induction on the height of v in T . Let v1, . . . , vm be the successors of v in T (where m = 0 if v is a leaf in T ). If Q(~b) \u2208 D, the claim is vacuous since D contains only facts about predicates in P , every predicate in P is EDB in Pe, and every EDB predicate in Pe is EDB in \u03a8(P). Otherwise, we distinguish the following cases depending on the shape of the rule r \u2208 \u03a8(P) \\\u03a8(P)> used to obtain \u03bb(v) from \u03bb(v1), . . . , \u03bb(vm) (by Corollary 26, we only need to consider cases that can occur in a derivation focused on Q(~b) w.r.t. Pe): \u2022 r = \u03d5> \u2227 PQ(~t, ~y) \u2192 \u2228n i=1R Q i (~si, ~y) such that r \u2032 = \u2227n i=1Ri(~si) \u2192 P (~t) \u2208 Pe. Let \u03c3 be the substitution used in the\ncorresponding hyperresolution step and let, w.l.o.g., PQ(~t\u03c3, ~y\u03c3) \u2208 \u03bb(v1). Then, by the inductive hypothesis, Pe \u222a D |= ( \u2227 \u03b1\u2208\u03bbbase(v1) \u03b1)\u2192 Q(~b). Moreover, (\u03bb(v1) \\ {P Q(~t\u03c3, ~y\u03c3)}) \u222a \u22c3n i=1R Q i (~si\u03c3, ~y\u03c3) \u2286 \u03bb(v). The claim follows since, by r\u2032,\nPe |= ( \u2227 \u03b1\u2208\u03bbbase(v) \u03b1)\u2192 P (~t\u03c3).\n\u2022 r = \u03d5> \u2192 \u2228n i=1R Q i (~si, ~y) such that r \u2032 = \u2227n i=1Ri(~si) \u2192 \u22a5 \u2208 Pe. Let \u03c3 be the substitution used in the corresponding\nhyperresolution step. Then \u22c3n i=1R Q i (~si\u03c3, ~y\u03c3) \u2286 \u03bb(v), and hence, by r\u2032, Pe |= ( \u2227 \u03b1\u2208\u03bbbase(v) \u03b1)\u2192 \u22a5. The claim follows.\n\u2022 r = \u03d5> \u2192 QQ(~y, ~y). Since \u03c1 is focused on Q(~b), we have \u03bb(v) = QQ(~b,~b), and the claim (Pe \u222a D |= Q(~b) \u2192 Q(~b)) is immediate.\n\u2022 r = P (~z) \u2227 PQ(~z, ~y) \u2192 Q(~y) for some EDB predicate P in Pe. Let \u03c3 be the substitution used in the corresponding hyperresolution step (in particular, ~y\u03c3 = ~b). Let, w.l.o.g., PQ(~z\u03c3,~b) \u2208 \u03bb(v1) and \u03bb(v2) = P (~z\u03c3) (Proposition 20). Since P is EDB in Pe and hence in \u03a8(P), we have P (~z\u03c3) \u2208 D. By the inductive hypothesis, Pe \u222a D |= ( \u2227 \u03b1\u2208\u03bbbase(v1) \u03b1) \u2192 Q(~b),\nand therefore Pe \u222a D |= ( \u2227 \u03b1\u2208\u03bbbase(v1)\\{P (~z\u03c3)} \u03b1)\u2192 Q(~b). The claim follows since \u03bb(v1) \\ {P Q(~z\u03c3,~b)} \u2286 \u03bb(v).\nBy completeness of hyperresolution and the observation that \u03bbbase(v) = \u2205 whenever \u03bb(v) contains no facts of the form PQ(~a), we obtain the following corollary.\nCorollary 28. Let P be a datalog program. For every dataset D over the signature of P and every atom \u03b1 over the signature of Pe such that \u03a8(P) \u222a D |= \u03b1 we have Pe \u222a D |= \u03b1. Theorem 5. If P is datalog, then \u03a8(P) is a polynomial rewriting of P into a linear disjunctive program.\nProof. By construction, \u03a8(P) is a linear disjunctive program of size quadratic in the size of P . Since Pe is a rewriting of P , to prove that \u03a8(P) is a rewriting of P it suffices to show that Eval(Pe,D)|S = Eval(\u03a8(P),D)|S for every dataset D over the signature of P and every set S of predicates in Pe. This follows by Lemma 23 and Corollary 28.\nB Proofs for Section 4 We begin by generalising Proposition 20 as follows. Proposition 29. Let P be a disjunctive program, let D be a dataset, let \u03c1 = (T, \u03bb) be a derivation from P \u222a D, and let v be a node in T . If \u03bb(v) contains a datalog atom, then \u03bb(v) is a singleton.\nProof. Straightforward induction on the height of v in \u03c1. The case where \u03bb(v) contains an atom of the form >(a) follows by the implicit assumption that \u03c1 is normal.\nProposition 30. Let P be a disjunctive program, let Q be a datalog predicate in P , and let PQ be the set of all rules in P on which Q depends. For every dataset D and vector of individuals ~a = a1 . . . aarity(Q): P \u222a D ` Q(~a) iff PQ \u222a D ` Q(~a).\nProof. The inclusion from right to left is immediate. The inclusion from left to right follows by a straightforward induction on the derivation of a fact Q(~a) from P \u222a D exploiting the implicit normality assumption.\nSince datalog predicates only depend on rules that contain no disjunctive predicates, and a WL program P coincides with \u039e\u2032(P) on rules that contain no disjunctive predicates, we obtain (by correctness of hyperresolution): Corollary 31. Let P be a WL program and let Q be a datalog predicate in P . For every dataset D and vector of individuals ~a = a1 . . . aarity(Q): P \u222a D |= Q(~a) iff \u039e\u2032(P) \u222a D |= Q(~a).\nLemma 32. LetP be a WL program, letD be a dataset, let P be a disjunctive predicate inP , and let \u03c1 = (T, \u03bb) be a derivation of a fact P (~a) from P \u222a D. Then for every node v \u2208 T in an upper portion of \u03c1 and every disjunct Q(~b) \u2208 \u03bb(v) where Q is disjunctive in P , we have \u039e\u2032(P) \u222a D |= QP (~b,~a).\nProof. Let v \u2208 T and Q(~b) \u2208 \u03bb(v) be as required. We show the claim by induction on the distance of v from the root of T . If v is the root of T , then Q(~b) = P (~a) and the claim (\u039e\u2032(P) \u222a D |= PP (~a,~a)) follows since >(y1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 >(yarity(P )) \u2192 PP (~y, ~y) \u2208 \u039e\u2032(P) and \u039e\u2032(P)> \u222a D |= >(ai) for every ai \u2208 ~a.\nIf v is not the root of T , then it must have a predecessor w and siblings v1, . . . , vn (n \u2265 0) in T such that either (a) Q(~b) \u2208 \u03bb(w) or (b) \u03bb(w) is a hyperresolvent of \u03bb(v), \u03bb(v1), . . . , \u03bb(vn) and some rule Q(~s) \u2227 \u2227n i=1Ri(~si)\u2192 \u2228m j=1 Sj(~tj) \u2208 P \\ P>, where the atom Q(~s) is resolved with \u03bb(v) and the atoms Ri(~si) are resolved with \u03bb(vi). If Q(~b) \u2208 \u03bb(w), the claim follows by the inductive hypothesis so, w.l.o.g., suppose we are in Case (b). Since, by assumption, Q is disjunctive and P is WL, all Ri are datalog. Hence, \u039e\u2032(P) contains a rule r = \u03d5> \u2227 ( \u2227m j=1 S P j (~tj , ~y)) \u2227 \u2227n i=1Ri(~si) \u2192 QP (~s, ~y). Let \u03c3 be the substitution used in the hyperresolution step deriving \u03bb(w). Then ~s\u03c3 = ~b, \u03bb(vi) = Ri(~si\u03c3) for every i \u2208 [1, n] (by Proposition 29), and\u2228m j=1 Sj(~tj\u03c3) \u2286 \u03bb(w). By the inductive hypothesis, we then have \u039e\u2032(P)\u222aD |= SPj (~tj\u03c3,~a) for every j \u2208 [1,m]. Moreover, by Corollary 31, \u039e\u2032(P)\u222aD |= Ri(~si\u03c3) for every i \u2208 [1, n]. Finally, we have \u039e\u2032(P)> \u222aD |= \u03d5>\u03c3. The claim follows with r.\nLemma 33. Let P be a WL program. For every dataset D and every fact \u03b1 such that P \u222a D |= \u03b1 we have \u039e\u2032(P) \u222a D |= \u03b1.\nProof. Let P \u222a D |= P (~a). We show that \u039e\u2032(P) \u222a D |= P (~a). W.l.o.g., P (~a) /\u2208 D (otherwise, the claim is trivial) and P is disjunctive (otherwise, the claim follows by Corollary 31). By completeness of hyperresolution, there is a derivation \u03c1 = (T, \u03bb) of P (~a) from P \u222a D. Since P (~a) /\u2208 D and P is disjunctive, there is an upper portion \u03c1\u2032 of \u03c1 and a node v in \u03c1\u2032 such that:\n1. \u03bb(v) contains a disjunctive predicate; 2. v has no successor w in T such that \u03bb(w) contains a disjunctive predicate.\nWe distinguish two cases. If \u03bb(v) \u2208 D, then \u03bb(v) = Q(~b) for some Q and~b. By Lemma 32, we have \u039e\u2032(P) \u222a D |= QP (~b,~a). The claim follows since Q(~z) \u2227QP (~z, ~y)\u2192 P (~y) \u2208 \u039e\u2032(P).\nIf \u03bb(v) /\u2208 D, then v has successors v1, . . . , vn (n \u2265 0) in T such that \u03bb(v) is a hyperresolvent of \u03bb(v1), . . . , \u03bb(vn) and a rule in P \\ P> of the form \u2227n i=1Ri(~si) \u2192 \u2228m j=1 Sj(~tj), where the atoms Ri(~si) are resolved with \u03bb(vi). Since, by assumption,\nall Ri are datalog, \u039e\u2032(P) contains a rule r = ( \u2227m j=1 S P j (~tj , ~y)) \u2227 \u2227n i=1Ri(~si) \u2192 P (~y). Let \u03c3 be the substitution used in the hyperresolution step deriving \u03bb(v). By Lemma 32, we then have \u039e\u2032(P) \u222a D |= SPj (~tj\u03c3,~a) for every j \u2208 [1,m]. By Proposition 29, we have \u03bb(vi) = Ri(~si\u03c3), and hence, by Corollary 31, \u039e\u2032(P) \u222a D |= Ri(~si\u03c3) for every i \u2208 [1, n]. The claim follows with r.\nLemma 34. Let P be a WL program, let D be a dataset over the signature of P , and let \u03c1 = (T, \u03bb) be a derivation of a fact \u03b1 from \u039e\u2032(P) \u222a D where \u03b1 is not of the form >(a). Then:\n1. For every v \u2208 T , \u03bb(v) = P (~a) where P occurs in P , or \u03bb(v) = PQ(~a,~b) where P,Q are disjunctive in P . 2. If \u03b1 = P (~a) where P occurs in P , then P \u222a D |= P (~a).\n3. If \u03b1 = PQ(~a,~b), then P \u222a D |= P (~a)\u2192 Q(~b).\nProof. We begin by showing (1). Since \u039e\u2032(P) is datalog, \u03bb(v) contains only one atom for every v \u2208 T . The claim follows since D contains only predicates in P and the rules of \u039e\u2032(P) can only infer facts of the form P (~a) where P occurs in P or PQ(~a,~b) where P,Q are disjunctive in P .\nWe now show (2) and (3) by simultaneous induction on the height n of T . If n = 0, we distinguish three cases:\n\u2022 \u03b1 \u2208 D. Then D |= \u03b1 and the claim is immediate. \u2022 \u03b1 = P (~a) where P is datalog in P and r = (\u2192 P (~a)) \u2208 \u039e\u2032(P). Then r \u2208 P and the claim is immediate. \u2022 \u03b1 = \u22a5Q, arity(Q) = 0, and (\u2192 \u22a5Q) \u2208 \u039e\u2032(P). Then, since (\u22a5 \u2192) \u2208 P , we have P |= \u22a5 \u2192 Q for every predicate Q. \u2022 \u03b1 = PP where P is disjunctive in P and arity(P ) = 0. The claim (P \u222a D |= P \u2192 P ) is immediate.\nIf n > 0, the root v of T has children v1, . . . , vn and \u03b1 is a hyperresolvent of \u03bb(v1), . . . , \u03bb(vn) and a rule r \u2208 \u039e\u2032(P) \\\u039e\u2032(P)>. We distinguish five cases:\n\u2022 r contains no disjunctive predicates. Then \u03b1 is a datalog atom and the claim follows by Corollary 31. \u2022 r = \u03d5> \u2192 PP (~y, ~y) where P is disjunctive in P . Then \u03b1 = PP (~a,~a) for some ~a, and the claim (P \u222a D |= P (~a)\u2192 P (~a))\nis immediate. \u2022 r = Q(~z) \u2227 QP (~z, ~y) \u2192 P (~y). Then \u03b1 = P (~a) for some ~a. By the Corollary 31, we have P \u222a D |= Q(~b), and by the\ninductive hypothesis, P \u222a D |= Q(~b)\u2192 P (~a) for some~b. Hence P \u222a D |= P (~a). \u2022 r = \u03d5> \u2227 \u03d5 \u2227 \u2227n i=1R\nQ i (~si, ~y) \u2192 PQ(~t, ~y) where \u03d5 is the conjunction of all datalog atoms in r and r\u2032 = \u03d5 \u2227 P (~t) \u2192\u2228n\ni=1Ri(~si) \u2208 P . Then \u03b1 = PQ(~a,~b) for some ~a and ~b. By Corollary 31, for every i \u2208 [1, n] there is some ~ci such that P \u222aD |= \u03d5|~a~b~c1...~cn~t~y~s1...~sn , and by the inductive hypothesis, P \u222aD |= Ri(~ci)\u2192 Q( ~b). With r\u2032, we obtain P \u222aD |= P (~a)\u2192 Q(~b).\n\u2022 r = \u03d5 \u2227 \u2227n i=1R P i (~si, ~y) \u2192 P (~y) where \u03d5 is the conjunction of all datalog atoms in r and r\u2032 = \u03d5 \u2192 \u2228n i=1Ri(~si) \u2208 P .\nThen \u03b1 = P (~a) for some ~a. By Corollary 31, for every i \u2208 [1, n] there is some ~bi such that P \u222a D |= \u03d5|~a ~b1...~bn ~y~s1...~sn , and by the inductive hypothesis, P \u222a D |= Ri(~bi)\u2192 P (~a). With r\u2032, we obtain P \u222a D |= P (~a).\nBy completeness of hyperresolution (and Corollary 31 for facts of the form >(a)), Lemma 34(2) implies: Corollary 35. Let P be a WL program. For every dataset D and atom \u03b1 over the signature of P such that \u039e\u2032(P) \u222a D |= \u03b1 we have P \u222a D |= \u03b1. Theorem 10. If P is WL, then \u039e\u2032(P) is a polynomial datalog rewriting of P .\nProof. By construction, \u039e\u2032(P) is a datalog program of size quadratic in the size of P . Correctness of the transformation (i.e., \u039e\u2032(P) being a rewriting of P) follows with Lemma 33 and Corollary 35.\nTheorem 11. Let P be WL, S a set of predicates in P , and P \u2032 obtained from \u039e\u2032(P) by removing all rules with a predicate XR for R 6\u2208 S. Then P \u2032 is a rewriting of P w.r.t. S.\nProof. Follows analogously to Theorem 10 with minor adaptations of the relevant lemmas.\nC Proofs for Section 5 Definition 36. Let r = \u03b1 \u2227 \u03d5r \u2192 \u03c8r and s = \u03d5s \u2192 \u03b2 \u2228 \u03c8s be rules such that atom \u03b1 is unifiable with \u03b2 with MGU \u03b8. The elementary unfolding ElemUnfold(r, \u03b1, s, \u03b2) of r at \u03b1 using s at \u03b2 is the pair ((\u03d5r \u2227 \u03d5s \u2192 \u03c8r \u2228 \u03c8s)\u03b8, \u03b8).\nAn elementary unfolding step thus amounts to resolving the relevant rules over the given predicates. Unfolding is then a transformation that allows us to replace a rule in a program with a sequence of elementary unfoldings in such a way that equivalence is preserved.\nDefinition 37. Let P be a disjunctive program, let r \u2208 P and let \u03b1 be a body atom in r; then, the unfolding of r at \u03b1 in P , denoted Unfold(P, r, \u03b1), is the result of applying Procedure 2 to P , r, and \u03b1.\nProposition 38. Let P be a disjunctive program, r a rule in P , and \u03b1 a body atom of r. Then P |= Unfold(P, r, \u03b1).\nProof. The claim follows by soundness of resolution since every clause in Unfold(P, r, \u03b1) \\ P is obtained by resolution from clauses in P .\nLemma 39. Let P be a disjunctive program, let r = \u2227n i=1 \u03b1i \u2192 \u03c8 (n \u2265 1) be a rule in P where \u03b11 is IDB in P , let D be a dataset containing no occurrences of IDB predicates in P , and let \u03c3 be a ground substitution. If Unfold(P, r, \u03b11) \u222a D |= \u03b1i\u03c3\u2228\u03c7\u03b1i for every i \u2208 [1, n] (where each \u03c7\u03b1i is a ground disjunction of facts), then Unfold(P, r, \u03b11)\u222aD |= \u03c8\u03c3\u2228\u03c7\u03b11\u2228\u00b7 \u00b7 \u00b7\u2228\u03c7\u03b1n .\nProcedure 2 Unfold Input: P: a disjunctive program; r: a rule; \u03b1: a body atom of r Output: the unfolding of r at \u03b1 by P 1: S0 := { (s, \u03b2) | s \u2208 P, \u03b2 a head atom in s unifiable with \u03b1 } 2: i := 0 3: repeat 4: Si+1 := \u2205 5: for each (s, \u03b2) \u2208 Si do 6: (s\u2032, \u03b8) := ElemUnfold(r, \u03b1, s, \u03b2) 7: Si+1 := Si+1 \u222a { (s\u2032, \u03b2\u2032\u03b8) | (s, \u03b2\u2032) \u2208 Si, \u03b2 6= \u03b2\u2032 } 8: i := i+ 1 9: until Si 6= \u2205 10: return (P \\ {r}) \u222a { s | (s, \u03b2) \u2208 Sj , for 1 \u2264 j < i }\nProof. For every i \u2208 [1, n], let Unfold(P, r, \u03b11) \u222a D |= \u03b1i\u03c3 \u2228 \u03c7\u03b1i . Let \u03c1 = (T, \u03bb) be a derivation of \u03b11\u03c3 \u2228 \u03c7\u2032\u03b11 from Unfold(P, r, \u03b11) \u222a D for some \u03c7\u2032\u03b11 \u2286 \u03c7\u03b11 (existence of \u03c1 follows by completeness of hyperresolution). Let s be the rule used to derive the label of the root v of \u03c1 (i.e., \u03b11\u03c3 \u2228 \u03c7\u2032\u03b11 ) from the labels of its children v1, . . . , vm (s must exist since \u03b11 is an IDB predicate and hence, by assumption, \u03b11 /\u2208 D), and let \u03c4 be substitution used in the corresponding hyperresolution step. Then s = \u2227m j=1 \u03b2j \u2192 \u03b1\u20321 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03b1\u2032l \u2228 \u03c8\u03b1\u2032 such that \u03bb(vj) = \u03b2j\u03c4 \u2228 \u03c7\u03b2j for every j \u2208 [1,m], \u03b11\u03c3 = \u03b1\u20321\u03c4 = \u00b7 \u00b7 \u00b7 = \u03b1\u2032l\u03c4 and \u03c7\u2032\u03b11 = \u03c8\u03b1\u2032\u03c4 \u2228 \u03c7\u03b21 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c7\u03b2m . Let r1 be the rule obtained by elementary unfolding of r at \u03b11 using s at \u03b1 \u2032 1, and let rk\n(2 \u2264 k \u2264 l) be the rule obtained by elementary unfolding of r at \u03b11 using rk\u22121 at \u03b1\u2032k. Then ( \u2227m j=1 \u03b2j\u03c4) \u2227 ( \u2227n i=2 \u03b1i\u03c3) is a substitution instance of the body of rl and \u03c8\u03b1\u2032\u03c4 \u2228 \u03c8\u03c3 is the corresponding instance of the head of rl. Hence, the claim follows from the assumption (Unfold(P, r, \u03b11)\u222aD |= \u03b1i\u03c3\u2228\u03c7\u03b1i for every i \u2208 [2, n]) and soundness of hyperresolution (which implies Unfold(P, r, \u03b11) \u222aD |= \u03b2j\u03c4 \u2228 \u03c7\u03b2j for every j \u2208 [1,m]) with rl: we obtain Unfold(P, r, \u03b11) \u222aD |= \u03c8\u03b1\u2032\u03c4 \u2228 \u03c8\u03c3 \u2228 \u03c7\u03b21 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c7\u03b2m \u2228 \u03c7\u03b12 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c7\u03b1n = \u03c8\u03c3 \u2228 \u03c7\u2032\u03b11 \u2228 \u03c7\u03b12 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c7\u03b1n \u2286 \u03c8\u03c3 \u2228 \u03c7\u03b11 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u03c7\u03b1n .\nLemma 40. LetP be a disjunctive program, letD be a dataset containing no occurrences of IDB predicates inP , let r be a rule inP , and let \u03b1 be an IDB body atom of r. For every disjunction of facts \u03d5 such thatP\u222aD ` \u03d5we have Unfold(P, r, \u03b1)\u222aD |= \u03d5.\nProof. Let \u03c1 = (T, \u03bb) be a derivation of \u03d5 from P \u222a D and let v be the root of T . We proceed by induction on the size of T . If \u03bb(v) \u2208 D, the claim is immediate. Otherwise, let v1, . . . , vn be the successors of v in T (n = 0 if v is a leaf in T ). By the inductive hypothesis, we have Unfold(P, r, \u03b1) \u222a D |= \u03bb(vi) for every i \u2208 [1, n]. We distinguish two cases, depending on the rule s \u2208 P used to derive \u03bb(v) from \u03bb(v1), . . . , \u03bb(vn). If s 6= r, we have s \u2208 Unfold(P, r, \u03b1), and the claim follows with s. If s = r, the claim follows by Lemma 39.\nTheorem 12. Let P0 be a disjunctive program and let P be a rewriting of P0 such that no IDB predicate in P occurs in P0. Let r be a rule in P and \u03b1 be an IDB body atom of r. Then Unfold(P, r, \u03b1) is a rewriting of P0. Moreover, no IDB predicate in Unfold(P, r, \u03b1) occurs in P0.\nProof. Since P is a rewriting of P0, for the first claim it suffices to show Eval(P,D) = Eval(Unfold(P, r, \u03b1),D) for datasetsD over the signature of P0. This follows by Proposition 38 and Lemma 40 since P0 contains no occurrences of IDB predicates in P , and hence neither do datasets over the signature of P0. The second claim is immediate since all rules in Unfold(P, r, \u03b1) \\ P are obtained by resolution from those in P , and the set of IDB predicates in a program is closed under resolution.\nD Proofs for Section 6 Proposition 41. Checking O \u222aD |= \u03b1 for O an RLt ontology, D a dataset, and \u03b1 a fact is co-NP-complete.\nProof. Membership in co-NP follows from the fact that both the rules in Table 1 and the rules axiomatising equality and > contain a bounded number of variables and atoms; hence, the corresponding programs can be grounded in polynomial time and entailment in the resulting propositional program can be checked in co-NP. For hardness, it suffices to provide a straightforward encoding of non-3-colorability. The following DL ontology O can be normalised into an RLt ontology\nV v R tG tB B u \u2203edge.B v \u22a5 B uG v \u22a5 G u \u2203edge.G v \u22a5 G uR v \u22a5 R u \u2203edge.R v \u22a5 B uR v \u22a5\nGiven an undirected graph G = (V,E), the dataset DG contains a fact V (a) for each node a \u2208 V and facts edge(a, b) and edge(b, a) for each edge connecting a and b in E. Then, G is non-3-colorable iff O \u222aDG is unsatisfiable.\nTheorem 15. Checking O \u222aD |= \u03b1, for O an RLt ontology that corresponds to a WL program, is PTIME-complete.\nProof. Hardness follows directly from the fact that the problem is already PTIME-hard if O is an OWL 2 RL ontology; thus, we focus on proving membership in PTIME. By Theorem 2 we have that O \u222a D |= \u03b1 iff \u039e(O) \u222a D |= \u03b1\u03b8 for some injective predicate renaming \u03b8. Thus, it suffices to show that the evaluation of \u039e(O) over D can be computed in polynomial time in the size of O and D. First, \u039e(O) is of size at most quadratic in the size of O, and the arity of a predicate in \u039e(O) is at most double the arity of a predicate in O. As we can see in Table 1, the rules corresponding to Axioms 1-11 contain a bounded number of variables and atoms in the body, and hence the number of variables in the body of each rule and the arity of predicates in \u039e(O) is bounded as well, as required.\nLet us fix an arbitrary SHIQ ontologyO, and let \u2126O be obtained fromO by first removing all axioms of the form 5 and then adding the relevant axioms to preserve fact entailment as described in (Cuenca Grau et al. 2013). Furthermore, let us denote with RO the subset of all axioms in O of the form 5, 4, and 8. Finally, let DD(\u2126O) be the result of applying the algorithm in (Hustadt, Motik, and Sattler 2007) to \u2126O. The following lemma summarises the results in (Hustadt, Motik, and Sattler 2007; Cuenca Grau et al. 2013) that are relevant to us. Lemma 42. The following properties hold:\n1. \u2126O is a model conservative extension of O. 2. \u2126O |= DD(\u2126O). 3. For each dataset D and each fact \u03b1 the following holds:\nO \u222aD |= \u03b1 iff \u2126O \u222a Eval(RO,D) |= \u03b1 (21) \u2126O \u222a D |= \u03b1 iff DD(\u2126O) \u222a D |= \u03b1 (22)\nThen, the following theorem states that the program obtained from \u2126O by applying the algorithm in (Hustadt, Motik, and Sattler 2007) and then adding the rules inRO entails the same facts as O w.r.t. all datasets. Theorem 43. O \u222aD |= \u03b1 iff DD(\u2126O) \u222aRO \u222a D |= \u03b1, for every dataset D and fact \u03b1 about individuals in D.\nProof. Assume that O \u222a D |= \u03b1. By Lemma 42, Condition (21) we have \u2126O \u222a Eval(RO,D) |= \u03b1. Since Eval(RO,D) is a dataset, by Lemma 42, Condition (22) we also have DD(\u2126O)\u222aEval(RO,D) |= \u03b1, which then implies DD(\u2126O)\u222aRO\u222aD |= \u03b1, as required.\nAssume that O\u222aD 6|= \u03b1. Since, by Lemma 42, \u2126O is a conservative extension of O andRO \u2286 O we have that \u2126O \u222aRO \u222a D 6|= \u03b1. Again, by Lemma 42, we have that \u2126O |= DD(\u2126O) and hence DD(\u2126O) \u222aRO \u222a D 6|= \u03b1.\nWe define a program P to be a rewriting of an ontology O if P is a rewriting of DD(\u2126O) \u222a RO. By Theorems 43 and 13, we then obtain the following. Theorem 44. Let O be an ontology. If Rewrite terminates on DD(\u2126O)\u222aRO with a datalog program P , then P is a rewriting of O.\nProof. Immediate by Theorems 43 and 13."}], "references": [{"title": "On datalog vs. polynomial time", "author": ["Cosmadakis Afrati", "F. Yannakakis 1995] Afrati", "S.S. Cosmadakis", "M. Yannakakis"], "venue": "J. Comput. System Sci", "citeRegEx": "Afrati et al\\.,? \\Q1995\\E", "shortCiteRegEx": "Afrati et al\\.", "year": 1995}, {"title": "Linearisability of datalog programs", "author": ["F.", "M. Gergatsoulis", "F. Toni"], "venue": "Theor. Comput. Sci. 308(1-3):199\u2013 226.", "citeRegEx": "F. et al\\.,? 2003", "shortCiteRegEx": "F. et al\\.", "year": 2003}, {"title": "The DL-Lite family and relations", "author": ["Artale"], "venue": "J. Artif. Intell. Res", "citeRegEx": "Artale,? \\Q2009\\E", "shortCiteRegEx": "Artale", "year": 2009}, {"title": "Reasoning with minimal models: Efficient algorithms and applications", "author": ["Ben-Eliyahu-Zohary", "L. Palopoli"], "venue": null, "citeRegEx": "Ben.Eliyahu.Zohary et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Ben.Eliyahu.Zohary et al\\.", "year": 1997}, {"title": "Ontology-based data access: A study through disjunctive datalog, CSP, and MMSNP", "author": ["Bienvenu"], "venue": "In PODS,", "citeRegEx": "Bienvenu,? \\Q2013\\E", "shortCiteRegEx": "Bienvenu", "year": 2013}, {"title": "OWLim: A family of scalable semantic repositories", "author": ["Bishop"], "venue": "Semantic Web J. 2(1):33\u201342", "citeRegEx": "Bishop,? \\Q2011\\E", "shortCiteRegEx": "Bishop", "year": 2011}, {"title": "The impact of disjunction on query answering under guarded-based existential rules", "author": ["Morak Bourhis", "P. Pieris 2013] Bourhis", "M. Morak", "A. Pieris"], "venue": "In IJCAI", "citeRegEx": "Bourhis et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bourhis et al\\.", "year": 2013}, {"title": "Foundations of rule-based query answering", "author": ["Bry"], "venue": "In Reasoning", "citeRegEx": "Bry,? \\Q2007\\E", "shortCiteRegEx": "Bry", "year": 2007}, {"title": "Computing datalog rewritings beyond Horn ontologies", "author": ["Cuenca Grau"], "venue": "In IJCAI", "citeRegEx": "Grau,? \\Q2013\\E", "shortCiteRegEx": "Grau", "year": 2013}, {"title": "Complexity and expressive power of logic programming", "author": ["Dantsin"], "venue": "ACM Comput. Surv", "citeRegEx": "Dantsin,? \\Q2001\\E", "shortCiteRegEx": "Dantsin", "year": 2001}, {"title": "Framework for an automated comparison of description logic reasoners", "author": ["Tsarkov Gardiner", "T. Horrocks 2006] Gardiner", "D. Tsarkov", "I. Horrocks"], "venue": "In ISWC,", "citeRegEx": "Gardiner et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gardiner et al\\.", "year": 2006}, {"title": "On the complexity of ontological reasoning under disjunctive existential rules", "author": ["Gottlob"], "venue": "In MFCS,", "citeRegEx": "Gottlob,? \\Q2012\\E", "shortCiteRegEx": "Gottlob", "year": 2012}, {"title": "Reasoning in Description Logics by a Reduction to Disjunctive Datalog", "author": ["Motik Hustadt", "U. Sattler 2007] Hustadt", "B. Motik", "U. Sattler"], "venue": "J. Autom. Reasoning", "citeRegEx": "Hustadt et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2007}, {"title": "Sufficient conditions for first-order and datalog rewritability in ELU", "author": ["Kaminski", "M. Cuenca Grau 2013] Kaminski", "B. Cuenca Grau"], "venue": "In DL,", "citeRegEx": "Kaminski et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Kaminski et al\\.", "year": 2013}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["Leone"], "venue": "ACM Trans. Comput", "citeRegEx": "Leone,? \\Q2006\\E", "shortCiteRegEx": "Leone", "year": 2006}, {"title": "Nonuniform data complexity of query answering in description logics. In KR", "author": ["Lutz", "C. Wolter 2012] Lutz", "F. Wolter"], "venue": null, "citeRegEx": "Lutz et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2012}, {"title": "Towards a complete OWL ontology", "author": ["Ma"], "venue": null, "citeRegEx": "Ma,? \\Q2006\\E", "shortCiteRegEx": "Ma", "year": 2006}, {"title": "OWL 2 Web Ontology Language Profiles", "author": ["Motik"], "venue": null, "citeRegEx": "Motik,? \\Q2009\\E", "shortCiteRegEx": "Motik", "year": 2009}, {"title": "Parallel materialisation of datalog programs in centralised, main-memory rdf systems", "author": ["Motik"], "venue": null, "citeRegEx": "Motik,? \\Q2014\\E", "shortCiteRegEx": "Motik", "year": 2014}, {"title": "Hypertableau Reasoning for Description Logics", "author": ["Shearer Motik", "B. Horrocks 2009] Motik", "R. Shearer", "I. Horrocks"], "venue": "J. Artif. Intell. Res", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "The loop absorption and the generalization strategies for the development of logic programs and partial deduction", "author": ["Proietti", "M. Pettorossi 1993] Proietti", "A. Pettorossi"], "venue": "J. Log. Programming", "citeRegEx": "Proietti et al\\.,? \\Q1993\\E", "shortCiteRegEx": "Proietti et al\\.", "year": 1993}, {"title": "Unfold/fold transformation of logic programs", "author": ["Tamaki", "H. Sato 1984] Tamaki", "T. Sato"], "venue": "In ICLP,", "citeRegEx": "Tamaki et al\\.,? \\Q1984\\E", "shortCiteRegEx": "Tamaki et al\\.", "year": 1984}, {"title": "Implementing an inference engine for RDFS/OWL constructs and user-defined rules in Oracle", "author": ["Wu"], "venue": null, "citeRegEx": "Wu,? \\Q2008\\E", "shortCiteRegEx": "Wu", "year": 2008}, {"title": "Making the most of your triple store: query answering in OWL 2 using an RL reasoner", "author": ["Zhou"], "venue": null, "citeRegEx": "Zhou,? \\Q2013\\E", "shortCiteRegEx": "Zhou", "year": 2013}], "referenceMentions": [{"referenceID": 19, "context": "Tractability in data complexity is an appealing property for data-intensive KR; in particular, the RL profile of the ontology language OWL 2 was designed such that each ontology corresponds to a datalog program (Motik et al. 2009).", "startOffset": 211, "endOffset": 230}, {"referenceID": 16, "context": "Dealing with Expressive Ontology Languages Hustadt, Motik, and Sattler (2007) developed an algorithm for transforming SHIQ ontologies into an equivalent disjunctive datalog program.", "startOffset": 52, "endOffset": 78}, {"referenceID": 8, "context": "Cuenca Grau et al. (2013) combined this algorithm with a knowledge compilation procedure (called Compile-Horn) obtaining a sound but incomplete and nonterminating datalog rewriting procedure for SHIQ.", "startOffset": 7, "endOffset": 26}, {"referenceID": 8, "context": "Complexity of disjunctive datalog with negation as failure has been extensively studied (Ben-Eliyahu-Zohary and Palopoli 1997; Eiter, Gottlob, and Mannila 1997). The class of head-cycle free programs was studied in Ben-EliyahuZohary and Palopoli; Ben-Eliyahu-Zohary, Palopoli, and Zemlyanker (1997; 2000), where it was shown that certain reasoning problems are tractable for such programs (fact entailment, however, remains intractable w.r.t. data). Gottlob et al. (2012) investigated complexity of disjunctive TGDs and showed tractability (w.", "startOffset": 134, "endOffset": 472}, {"referenceID": 2, "context": "Artale et al. (2009) showed tractability of fact entailment w.", "startOffset": 0, "endOffset": 21}, {"referenceID": 2, "context": "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.", "startOffset": 0, "endOffset": 339}, {"referenceID": 2, "context": "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.", "startOffset": 0, "endOffset": 363}, {"referenceID": 2, "context": "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI.", "startOffset": 0, "endOffset": 563}, {"referenceID": 2, "context": "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI. The procedure in (Cuenca Grau et al. 2013), mentioned in Section 6, is used by Kaminski and Cuenca Grau (2013) to show first-order/datalog rewritability of two fragments of ELU .", "startOffset": 0, "endOffset": 778}, {"referenceID": 2, "context": "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI. The procedure in (Cuenca Grau et al. 2013), mentioned in Section 6, is used by Kaminski and Cuenca Grau (2013) to show first-order/datalog rewritability of two fragments of ELU . Notably, both fragments yield linear programs. Finally, our unfolding-based rewriting procedure is motivated by the work of Afrati, Gergatsoulis, and Toni (2003) on linearisation of plain datalog programs by means of program transformation techniques (Tamaki and Sato 1984; Proietti and Pettorossi 1993; Gergatsoulis 1997).", "startOffset": 0, "endOffset": 1008}], "year": 2014, "abstractText": "We study the problem of rewriting a disjunctive datalog program into plain datalog. We show that a disjunctive program is rewritable if and only if it is equivalent to a linear disjunctive program, thus providing a novel characterisation of datalog rewritability. Motivated by this result, we propose weakly linear disjunctive datalog\u2014a novel rule-based KR language that extends both datalog and linear disjunctive datalog and for which reasoning is tractable in data complexity. We then explore applications of weakly linear programs to ontology reasoning and propose a tractable extension of OWL 2 RL with disjunctive axioms. Our empirical results suggest that many non-Horn ontologies can be reduced to weakly linear programs and that query answering over such ontologies using a datalog engine is feasible in practice.", "creator": "LaTeX with hyperref package"}}}