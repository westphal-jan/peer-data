{"id": "1405.0805", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-May-2014", "title": "On the Relative Expressiveness of Argumentation Frameworks, Normal Logic Programs and Abstract Dialectical Frameworks", "abstract": "we analyse the expressiveness of the two - valued semantics of abstract argumentation frameworks, normal logic programs and alternative abstract dialectical frameworks. often by designing expressiveness we mean the ability to encode a desired set combination of two - valued interpretations over a given propositional signature using only atoms from that simple signature. while the computational statistical complexity of answering the two - valued model existence problem for all these languages is ( almost ) the same, we show otherwise that the languages form through a neat hierarchy with respect to their expressiveness.", "histories": [["v1", "Mon, 5 May 2014 07:39:50 GMT  (30kb,D)", "http://arxiv.org/abs/1405.0805v1", "Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)"]], "COMMENTS": "Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["hannes strass"], "accepted": false, "id": "1405.0805"}, "pdf": {"name": "1405.0805.pdf", "metadata": {"source": "CRF", "title": "On the Relative Expressiveness of Argumentation Frameworks, Normal Logic Programs and Abstract Dialectical Frameworks", "authors": ["Hannes Strass"], "emails": [], "sections": [{"heading": "Introduction", "text": "More often than not, different knowledge representation languages have conceptually similar and partially overlapping intended application areas. What are we to do if faced with an application and a choice of several possible knowledge representation languages which could be used for the application? One of the first axes along which to compare different formalisms that comes to mind is computational complexity: if a language is computationally too expensive when considering the problem sizes typically encountered in practice, then this is a clear criterion for exclusion.\nBut what if the available language candidates have the same computational complexity? If their expressiveness in the computational-complexity sense of \u201cWhat kinds of problems can the formalism solve?\u201d is the same, we need a more fine-grained notion of expressiveness. In this paper, we use such an alternative notion and perform an exemplary study of the relative expressiveness of several different knowledge representation languages: argumentation frameworks (AFs) (Dung, 1995), normal logic programs (LPs), abstract dialectical frameworks (ADFs) (Brewka and Woltran, 2010) and propositional logic.\nThis choice of languages is largely motivated by the similar intended application domains of argumentation frameworks and abstract dialectical frameworks and the close relation of the latter to normal logic programs. We add propositional logic to have a well-known reference point. Furthermore, the computational complexity of their respective model existence problems is the same (with one exception):\n\u2022 for AFs, deciding stable extension existence is NPcomplete (Dimopoulos, Nebel, and Toni, 2002);\n\u2022 for LPs, deciding the existence of supported/stable models is NP-complete (Bidoit and Froidevaux, 1991; Marek and Truszczyn\u0301ski, 1991);\n\u2022 for ADFs, deciding the existence of models is NPcomplete (Brewka et al., 2013), deciding the existence of stable models is \u03a3P2 -complete for general ADFs (Brewka et al., 2013) and NP-complete for the subclass of bipolar ADFs (Strass and Wallner, 2014);\n\u2022 the satisfiability problem of propositional logic is NPcomplete. In view of these almost identical complexities, we use an alternative measure of the expressiveness of a knowledge representation language L: \u201cGiven a set of two-valued interpretations, is there a knowledge base in L that has this exact model set?\u201d This notion lends itself straightforwardly to compare different formalisms (Gogic et al., 1995):\nFormalism L2 is at least as expressive as formalism L1 if and only if every knowledge base in L1 has an equivalent knowledge base in L2.\nSo here expressiveness is understood in terms of realisability, \u201cWhat kinds of model sets can the formalism express?\u201d\nIt is easy to see that propositional logic can express any set of two-valued interpretations. The same is easy (but less easy) to see for logic programs under supported model semantics. For logic programs under stable model semantics, it is clear that not all model sets can be expressed, since two different stable models are always incomparable with respect to the subset relation. In this paper, we study such expressiveness properties for all the mentioned formalisms under different semantics. It will turn out that the languages form a more or less strict expressiveness hierarchy, with AFs at the bottom, ADFs and LPs under stable semantics higher up and ADFs and LPs under supported model semantics at the top together with propositional logic.\nTo show that a language L2 is at least as expressive as a language L1 we will mainly use two different techniques. In the best case, we can use a syntactic compact and faithful translation from knowledge bases of L1 to those of L2. Compact means that the translation does not change the vocabulary, that is, does not introduce new atoms. Faithful means that the translation exactly preserves the models of the knowledge base for respective semantics of the two languages. In the second best case, we assume given the\nar X\niv :1\n40 5.\n08 05\nv1 [\ncs .A\nI] 5\nM ay\n2 01\n4\nknowledge base of L1 in the form of a setX of desired models and construct a semantic realisation ofX in L2, that is, a knowledge base in L2 whose model set corresponds exactly to X . To show that language L2 is strictly more expressive than L1, we additionally have to present a knowledge base K from L2 of which we prove that L1 cannot express the model set of K.\nFor all methods, we can make use of several recent works on the formalisms we study here. First of all, we [2013] studied the syntactic intertranslatability of ADFs and LPs, but did not look at expressiveness or realisability. The latter was recently studied for argumentation frameworks by Dunne et al. (2014). They allow to extend the vocabulary in order to realise a given model set, as long as the new vocabulary elements are evaluated to false in all models. For several semantics of AFs, Dunne et al. found necessary (and sufficient) conditions for realisability. While their sufficient conditions are not applicable to our setting, they discovered a necessary condition for realisability with stable extension semantics that we will make use of in this paper. There has also been work on translating ADFs into AFs for the ADF model and AF stable extension semantics (Brewka, Dunne, and Woltran, 2011), however this translation introduces additional arguments and is therefore not compact.\nThe gain that is achieved by our results is not only that of increased clarity about fundamental properties of these knowledge representation languages \u2013 What can these formalisms express, actually? \u2013 but has several further applications. As Dunne et al. (2014) remarked, a major application is in constructing knowledge bases with the aim of encoding a certain model set. As a necessary prerequisite to this, it must be known that the intended model set is realisable in the first place. For example, in a recent approach to revising argumentation frameworks (Coste-Marquis et al., 2013), the authors avoid this problem by assuming to produce a collection of AFs whose model sets in union produce the desired model set. While the work of Dunne et al. (2014) showed that this is indeed necessary in the case of AFs and stable extension semantics (that is, there are model sets that a single AF just cannot express), our work shows that for ADFs under the model semantics, a single knowledge base (ADF) is always enough to realise any given model set.\nOf course, the fact that the languages we study have the same computational complexity means that there in principle exist polynomial intertranslations for the respective decision problems. But such intertranslations may involve the introduction of new atoms. In theory, a polynomial blowup from n atoms to nk atoms for some k is of no consequence. In practice, it has a profound impact: the number n of atoms directly influences the search space that any implementation potentially has to cover. There, an increase from 2n to 2n k is no longer polynomial, but exponential, and accordingly makes itself felt. Being able to realise a model set compactly, without new atoms, therefore attests that a language L has a certain basic kind of efficiency property, in the sense that the L-realisation of a model set does not unnecessarily enlarge the search space of algorithms operating on it.\nThe paper proceeds as follows. We first define the notion of expressiveness formally and then introduce the languages\nwe will study. After reviewing several intertranslatability results for these languages, we stepwise obtain the results that lead to the expressiveness hierarchy. We conclude with a discussion of avenues for future work."}, {"heading": "Background", "text": "We assume given a finite set A of atoms (statements, arguments), the vocabulary. A knowledge representation language interpreted over A is then some set L; a (two-valued) semantics for L is a mapping \u03c3 : L\u2192 22A that assigns sets of two-valued models to the language elements. (So A is implicit in L.) Strictly speaking, a two-valued interpretation is a mapping from the set of atoms into the two truth values true and false, but for technical ease we represent two-valued interpretations by the sets containing the atoms that are true.\nFor a language L, we denote the range of the semantics \u03c3 by \u03c3(L). Intuitively, \u03c3(L) is the set of models that language L can express, with any knowledge base over vocabulary A whatsoever. For example, for L = PL propositional logic and \u03c3 = mod the usual model semantics, we have \u03c3(PL) = 22 A\nsince obviously any set of models is realisable in propositional logic.1 This leads us to compare different pairs of languages and semantics with respect to the semantics\u2019 range of models. Our concept of \u201clanguage\u201d concentrates on semantics and decidedly remains abstract.\nDefinition 1. Let A be a finite vocabulary, L1, L2 be languages that are interpreted over A and \u03c31 : L1 \u2192 22 A\nand \u03c32 : L2 \u2192 22 A be two-valued semantics. We define\nL\u03c311 \u2264e L \u03c32 2 iff \u03c31(L1) \u2286 \u03c32(L2)\nIntuitively, language L2 under semantics \u03c32 is at least as expressive as language L1 under semantics \u03c31, because all models that L1 can express under \u03c31 are also contained in those that L2 can produce under \u03c32. (If the semantics are clear from the context we will omit them; this holds in particular for argumentation frameworks and propositional logic, where we only look at a single semantics.) As usual,\n\u2022 L1 <e L2 iff L1 \u2264e L2 and L2 6\u2264e L1; \u2022 L1 \u223c=e L2 iff L1 \u2264e L2 and L2 \u2264e L1. The relation \u2264e is reflexive and transitive by definition, but not necessarily antisymmetric. That is, there might different languages L1 6= L2 that are equally expressive: L1 \u223c=e L2.\nWe next introduce the particular knowledge representation languages we study in this paper. All will make use of a vocabulary A; the results of the paper are all considered parametric in such a given vocabulary."}, {"heading": "Logic Programs", "text": "For a vocabulary A define not A = {not a | a \u2208 A} and the set of literals over A as A\u00b1 = A \u222a not A. A normal logic program rule over A is then of the form a\u2190 B where a \u2208 A and B \u2286 A\u00b1. The rule can be read as logical consequence, \u201ca is true if all literals in B are true.\u201d The set B\n1For a set X \u2286 2A we can simply define \u03d5X = \u2228\nM\u2208X \u03d5M with \u03d5M = \u2227 a\u2208M a \u2227 \u2227 a\u2208A\\M \u00aca and clearly mod(\u03d5X) = X .\nis called the body of the rule, we denote by B+ = B \u2229A and B\u2212 = {a \u2208 A | not a \u2208 B} the positive and negative body atoms, respectively. A rule is definite if B\u2212 = \u2205. For singletonB = {b}we denote the rule just by a\u2190 b. A logic program (LP) P over A is a set of logic program rules over A, and it is definite if all rules in it are definite.\nAt first, logic programs were restricted to definite programs, whose semantics was defined through the prooftheoretic procedure of SLD resolution. The meaning of negation not was only defined operationally through negation as failure. Clark (1978) gave the first declarative semantics for normal logic programs via a translation to classical logic that will be recalled shortly. This leads to the supported model semantics for logic programs: A rule a\u2190 B \u2208 P is active in a set M \u2286 A iff B+ \u2286M and B\u2212 \u2229M = \u2205 imply a \u2208M . M is a supported model for P iff M = {a \u2208 A | a\u2190 B \u2208 P is active in M}. For a logic program P we denote the set of its supported models by su(P ). The intuition behind this semantics is that everything that is true in a model has some kind of support.\nHowever, this support might be cyclic self-support. For instance, the logic program {a\u2190 a} has two supported models, \u2205 and {a}, where the latter is undesired in many application domains. As an alternative, Gelfond and Lifschitz (1988) proposed the stable model semantics, a declarative semantics for negation as failure that does not allow selfsupport: M \u2286 A is a stable model for P iff M is the\u2286-least supported model of PM , where the definite program PM is obtained from P by (1) eliminating each rule whose body contains a literal not a with a \u2208M , and (2) deleting all literals of the form not a from the bodies of the remaining rules. We write st(P ) for the set of stable models of P . It follows from the definition of stable models that st(P ) is a \u2286-antichain: for all M1 6= M2 \u2208 st(P ) we have M1 6\u2286M2."}, {"heading": "Argumentation Frameworks", "text": "Dung (1995) introduced argumentation frameworks as pairs F = (A,R) whereA is a set andR \u2286 A\u00d7A a relation. The intended reading of an AF F is that the elements of A are arguments whose internal structure is abstracted away. The only information about the arguments is given by the relation R encoding a notion of attack: a pair (a, b) \u2208 R expresses that argument a attacks argument b in some sense.\nThe purpose of semantics for argumentation frameworks is to determine sets of arguments (called extensions) which are acceptable according to various standards. For a given extension S \u2286 A, the arguments in S are considered to be accepted, those that are attacked by some argument in S are considered to be rejected, and all others are neither, their status is undecided. We will only be interested in so-called stable extensions, sets S of arguments that do not attack each other and attack all arguments not in the set. For stable extensions, each argument is either accepted or rejected by definition, thus the semantics is two-valued. More formally, a set S \u2286 A of arguments is conflict-free iff there are no a, b \u2208 S with (a, b) \u2208 R. A set S is a stable extension for (A,R) iff it is conflict-free and for all a \u2208 A \\ S there is a b \u2208 S with (b, a) \u2208 R. For an AF F , we denote the set of its stable extensions by st(F ). Again, it follows from the\ndefinition of a stable extension that the set st(F ) is always a \u2286-antichain."}, {"heading": "Abstract Dialectical Frameworks", "text": "An abstract dialectical framework (ADF) is a directed graph whose nodes represent statements or positions which can be accepted or not. The links represent dependencies: the status of a node a only depends on the status of its parents (denoted par(a)), that is, the nodes with a direct link to a. In addition, each node a has an associated acceptance condition Ca specifying the exact conditions under which a is accepted. Ca is a function assigning to each subset of par(a) one of the truth values t or f . Intuitively, if for some R \u2286 par(a) we have Ca(R) = t, then a will be accepted provided the nodes in R are accepted and those in par(a) \\R are not accepted.\nMore formally, an abstract dialectical framework is a tuple D = (A,L,C) where\n\u2022 A is a set of statements, \u2022 L \u2286 A\u00d7A is a set of links, \u2022 C = {Ca}a\u2208A is a collection of total functions Ca : 2\npar(a) \u2192 {t, f}, one for each statement a. The function Ca is called acceptance condition of a.\nIt is often convenient to represent acceptance conditions by propositional formulas. In particular, we will do so for several results of this paper. There, each Ca is represented by a propositional formula \u03d5a over par(a). Then, clearly, Ca(R \u2229 par(a)) = t iff R is a model for \u03d5a, R |= \u03d5a.\nBrewka and Woltran (2010) introduced a useful subclass of ADFs: an ADF D = (A,L,C) is bipolar iff all links in L are supporting or attacking (or both). A link (b, a) \u2208 L is supporting in D iff for all R \u2286 par(a), we have that Ca(R) = t impliesCa(R \u222a {b}) = t. Symmetrically, a link (b, a) \u2208 L is attacking in D iff for all R \u2286 par(a), we have that Ca(R \u222a {b}) = t implies Ca(R) = t. If a link (b, a) is both supporting and attacking then b has no influence on a, the link is redundant (but does not violate bipolarity). We will sometimes use this circumstance when searching for ADFs; there we simply assume that L = A\u00d7A, then links that are actually not needed can be expressed by acceptance conditions that make them redundant.\nThere are numerous semantics for ADFs; we will only be interested in two of them, (supported) models and stable models. A set M \u2286 A is a model of D iff for all a \u2208 A we find that a \u2208M iff Ca(M) = t. The definition of stable models is inspired by logic programming and slightly more complicated (Brewka et al., 2013). Define an operator by \u0393D(Q,R) = (acc(Q,R), rej (Q,R)) for Q,R \u2286 A, where\nacc(Q,R) = {a \u2208 A | for all Q \u2286 Z \u2286 (A \\R), we have Ca(Z) = t}\nrej (Q,R) = {a \u2208 A | for all Q \u2286 Z \u2286 (A \\R), we have Ca(Z) = f}\nThe intuition behind the operator is as follows: A pair (Q,R) represents a partial interpretation of the set of statements where those in Q are accepted (true), those in R are rejected (false), and those in S \\ (Q \u222a R) are neither.\nThe operator checks for each statement a whether all total interpretations that can possibly arise from (Q,R) agree on their truth value for the acceptance condition for a. That is, if a has to be accepted no matter how the statements in S \\ (Q \u222aR) are interpreted, then a \u2208 acc(Q,R). The set rej (Q,R) is computed symmetrically, so the pair (acc(Q,R), rej (Q,R)) constitutes a refinement of (Q,R).\nFor M \u2286 A, the reduced ADF DM = (M,LM , CM ) is defined by LM = L \u2229M \u00d7M and for each a \u2208M setting \u03d5Ma = \u03d5a[b/f : b /\u2208M ], that is, replacing all b /\u2208M by false in the acceptance formula of a. A modelM forD is a stable model ofD iff the least fixpoint of the operator \u0393DM is given by (M, \u2205). As usual, su(D) and st(D) denote the model sets of the two semantics. While ADF models can be subsets of one another, ADF stable models cannot."}, {"heading": "Translations between the formalisms", "text": "From AFs to BADFs Brewka and Woltran (2010) showed how to translate AFs into ADFs: For an AF F = (A,R), define the ADF associated to F as D(F ) = (A,R,C) with C = {\u03d5a}a\u2208A and \u03d5a = \u2227 (b,a)\u2208R \u00acb for a \u2208 A. Clearly, the resulting ADF is bipolar; parents are always attacking. Brewka and Woltran (2010) proved that this translation is faithful for the AF stable extension and ADF model semantics (Proposition 1). Brewka et al. (2013) later proved the same for the AF stable extension and ADF stable model semantics (Theorem 4). It is easy to see that the translation can be computed in polynomial time.\nFrom ADFs to PL Brewka and Woltran (2010) also showed that ADFs under supported model semantics can be faithfully translated into propositional logic: When acceptance conditions of statements a \u2208 A are represented by propositional formulas \u03d5a, then the supported models of an ADF D over A are given by the classical models of the formula set {a\u2194 \u03d5a | a \u2208 A}. From AFs to PL In combination, the previous two translations yield a polynomial and faithful translation chain from AFs into propositional logic.\nFrom ADFs to LPs In recent work we showed that ADFs can be faithfully translated into normal logic programs (Strass, 2013). For an ADF D = (A,L,C), its standard logic program P (D) is given by\n{a\u2190 (M \u222a not (par(a) \\M)) | a \u2208 A,Ca(M) = t}\nIt is an easy consequence of Lemma 3.14 in (Strass, 2013) that this translation preserves the supported model semantics. For complexity reasons, we cannot expect that this translation is also faithful for the stable semantics. And indeed, the ADF D = ({a} , {(a, a)} , {\u03d5a = a \u2228 \u00aca}) has a stable model {a} while its standard logic program P (D) = {a\u2190 a, a\u2190 not a} has no stable model. From AFs to LPs The translation chain from AFs to ADFs to LPs is compact, and faithful for AF stable semantics and LP stable semantics (Osorio et al., 2005), and AF stable semantics and LP supported semantics (Strass, 2013).\nFrom LPs to PL It is well-known that normal logic programs under supported model semantics can be translated to propositional logic (Clark, 1978). There, a logic program P is translated to a propositional theory \u03a6P = {a\u2194 \u03d5a | a \u2208 A} where\n\u03d5a = \u2228\na\u2190B\u2208P ( \u2227 b\u2208B+ b \u2227 \u2227 b\u2208B\u2212 \u00acb )\nfor a \u2208 A. For the stable model semantics, additional formulas have to be added, but the extended translation works all the same (Lin and Zhao, 2004).\nFrom LPs to ADFs The Clark completion of a normal logic program directly yields an equivalent ADF over the same signature (Brewka and Woltran, 2010). Clearly the translation is computable in polynomial time and the blowup (with respect to the original logic program) is at most linear. The resulting translation is faithful for the supported model semantics, which is a straightforward consequence of Lemma 3.16 in (Strass, 2013)."}, {"heading": "Relative Expressiveness", "text": "We now analyse and compare the relative expressiveness of argumentation frameworks \u2013 AFs \u2013, (bipolar) abstract dialectical frameworks \u2013 (B)ADFs \u2013, normal logic programs \u2013 LPs \u2013 and propositional logic \u2013 PL. We first look at the different families of semantics \u2013 supported and stable models \u2013 in isolation and afterwards combine the two. For the languages L \u2208 {ADF,LP} that have both supported and stable semantics, we will indicate the semantics \u03c3 via a superscript as in Definition 1. For AFs we only consider the stable extension semantics, as this is (to date) the only two-valued semantics for AFs. For propositional logic PL we consider the usual model semantics.\nWith the syntactic translations we reviewed in the previous section, we currently have the following relationships. For the supported semantics,\nAF \u2264e BADFsu \u2264e ADFsu \u223c=e LPsu \u2264e PL and for the stable semantics,\nAF \u2264e BADFst \u2264e ADFst <e PL AF \u2264e LPst <e PL\nNote that ADFst <e PL and LPst <e PL hold since sets of stable models have an antichain property, in contrast to model sets of propositional logic."}, {"heading": "Supported semantics", "text": "As depicted above, we know that expressiveness from AFs to propositional logic does not decrease. However, it is not yet clear if any of the relationships is strict.\nWe first show that ADFs can realise any set of models. To show this, we first make a case distinction whether the desired-model set is empty. If there should be no model, we construct an ADF without models. If the set of desired models is nonempty, we construct acceptance conditions directly from the set of desired interpretations. The construction is\nsimilar in design to the one we reviewed for propositional logic, but takes into account the additional interaction between statements and their acceptance conditions. Theorem 1. PL \u2264e ADFsu\nProof. Consider a vocabularyA and a setX \u2286 2A. We construct an ADF DsuX with su(D su X ) = X as follows.\n1. X = \u2205. We choose some a \u2208 A and set DsuX = ({a} , {(a, a)} , {Ca}) with Ca(\u2205) = t and Ca({a}) = f . It is easy to see that DsuX has no model. 2. X 6= \u2205. Define DsuX = (A,L,C) where L = A\u00d7A and for each a \u2208 A and M \u2286 A, we set Ca(M) = t iff\n(M \u2208 X and a \u2208M) or (M /\u2208 X and a /\u2208M) We have to show that M \u2208 X iff M is a model for DsuX . \u201cif\u201d: Let M be a model of DsuX . (a) M = \u2205. Pick any a \u2208 A. Since M is a model of\nDsuX , we have Ca(M) = f . So either (A) M \u2208 X and a /\u2208M or (B) M /\u2208 X and a \u2208M , by definition of Ca. By assumption M = \u2205, thus a /\u2208M and M \u2208 X . (b) M 6= \u2205. Let a \u2208M . Then Ca(M) = t since M is a model of DsuX . By definition of Ca, M \u2208 X . \u201conly if\u201d: Let M \u2208 X . (a) M = \u2205. Choose any a \u2208 A. By assumption, a /\u2208M\nandM \u2208 X , whenceCa(M) = f by definition. Since a \u2208 A was chosen arbitrarily, we have Ca(M) = f iff a /\u2208M . Thus M is a model of DsuX . (b) M 6= \u2205. Let a \u2208 A. If a \u2208M , then by assumption and definition of Ca we have Ca(M) = t. Conversely, if a /\u2208M , then by definition Ca(M) = f . Since a \u2208 A was arbitrary, M is a model of DsuX .\nWhen the acceptance conditions are written as propositional formulas, the construction in Theorem 1 simply sets\n\u03d5a = \u2228\nM\u2208X,a\u2208M \u03d5M \u2228 \u2228 M\u2286A,M /\u2208X,a/\u2208M \u03d5M\n\u03d5M = \u2227 a\u2208M a \u2227 \u2227 a\u2208A\\M \u00aca\nSince ADFs under supported semantics can be faithfully translated into logic programs, which can be likewise further translated to propositional logic, we have the following. Corollary 2. ADFsu \u223c=e LPsu \u223c=e PL\nWhile general ADFs under the supported model semantics can realise any set of models, the subclass of bipolar ADFs turns out to be less expressive. This is shown using the next result, which allows us to decide realisability of a given model set X \u2286 2A in non-deterministic polynomial time. We assume that the size of the input is in the order of\u2223\u22232A\u2223\u2223, that is, the input set X is represented directly. The decision procedure then basically uses the construction of Theorem 1 and an additional encoding of bipolarity to define a reduction to the satisfiability problem in propositional logic.\nTheorem 3. Let X \u2286 2A be a set of sets. It is decidable in non-deterministic polynomial time whether there exists a bipolar ADF D with su(D) = X .\nProof. We construct a propositional formula \u03c6X that is satisfiable if and only if X is bipolarly realisable. The propositional signature we use is the following: For each a \u2208 A and M \u2286 A, there is a propositional variable pMa that expresses whether Ca(M) = t. This allows to encode all possible acceptance conditions for the statements in A. To enforce bipolarity, we use additional variables to model supporting and attacking links: for all a, b \u2208 A, there is a variable pa,bsup saying that a supports b, and a variable pa,batt saying that a attacks b. So the vocabulary of \u03c6X is given by\nP = { pMa , p a,b sup , p a,b att \u2223\u2223\u2223M \u2286 A, a \u2208 A, b \u2208 A} To guarantee the desired set of models, we constrain the acceptance conditions as dictated by X: For any desired set M and statement a, the containment of a in M must correspond exactly to whether Ca(M) = t; this is encoded in \u03c6\u2208X . Conversely, for any undesired set M and statement a, there must not be any such correspondence, which \u03c6/\u2208X expresses.\n\u03c6\u2208X = \u2227 M\u2208X  \u2227 a\u2208M pMa \u2227 \u2227 a\u2208A\\M \u00acpMa  \u03c6/\u2208X =\n\u2227 M\u2286A,M /\u2208X  \u2228 a\u2208M \u00acpMa \u2228 \u2228 a\u2208A\\M pMa  To enforce bipolarity, we state that each link must be supporting or attacking. To model the meaning of support and attack, we encode all ground instances of their definitions.\n\u03c6bipolar = \u2227 a,b\u2208A (( pa,bsup \u2228 p a,b att ) \u2227 \u03c6a,bsup \u2227 \u03c6 a,b att ) \u03c6a,bsup = p a,b sup \u2192\n\u2227 M\u2286A ( pMb \u2192 p M\u222a{a} b ) \u03c6a,batt = p a,b att \u2192\n\u2227 M\u2286A ( p M\u222a{a} b \u2192 p M b )\nThe overall formula is given by \u03c6X = \u03c6\u2208X \u2227 \u03c6 /\u2208 X \u2227 \u03c6bipolar . The rest of the proof \u2013 showing thatX is bipolarly realisable if and only if \u03c6X is satisfiable \u2013 is delegated to Lemma 12 in the Appendix.\nRemarkably, the decision procedure does not only give an answer, but in the case of a positive answer we can read off the BADF realisation from the satisfying evaluation of the constructed formula. We illustrate the construction with an example that will subsequently be used to show that general ADFs are strictly more expressive than bipolar ADFs.\nExample 1. Consider A = {x, y, z} and this model set:\nX1 = {\u2205, {x, y} , {x, z} , {y, z}}\nThe construction of Theorem 3 yields these formulas:\n\u03c6\u2208X1 = \u00acp \u2205 x \u2227 \u00acp\u2205y \u2227 \u00acp\u2205z \u2227\np{x,y}x \u2227 p{x,y}y \u2227 \u00acp{x,y}z \u2227\np{x,z}x \u2227 \u00acp{x,z}y \u2227 p{x,z}z \u2227\n\u00acp{y,z}x \u2227 p{y,z}y \u2227 p{y,z}z \u03c6/\u2208X1 = (\u00acp {x} x \u2228 p{x}y \u2228 p{x}z ) \u2227\n(p{y}x \u2228 \u00acp{y}y \u2228 p{y}z ) \u2227\n(p{z}x \u2228 p{z}y \u2228 \u00acp{z}z ) \u2227\n(\u00acp{x,y,z}x \u2228 \u00acp{x,y,z}y \u2228 \u00acp{x,y,z}z ) The remaining formulas about bipolarity are independent of X1, we do not show them here. We have implemented the translation of Theorem 3 and used the solver clasp (Gebser et al., 2011) to verify that \u03c6X1 is unsatisfiable.\nA manual proof of bipolar non-realisability of X1 seems to amount to a laborious case distinction that explores the mutual incompatibility of the disjunctions in \u03c6/\u2208X1 and bipolarity, a task that is better left to machines. Together with the straightforward statement of fact that X1 can be realised by a non-bipolar ADF, the example leads to the next result. Theorem 4. BADFsu <e ADFsu\nProof. The model set from Example 1 is realisable under model semantics by ADF DX1 with acceptance conditions\n\u03d5x = (y = z), \u03d5y = (x= z), \u03d5z = (x= y) where \u201c=\u201d denotes exclusive disjunction XOR. However, there is no bipolar ADF realising the model set X1, as is witnessed by unsatisfiability of \u03c6X1 and Theorem 3. Clearly ADF DX1 is not bipolar since in all acceptance formulas, all statements are neither supporting nor attacking. It is not the only realisation, some alternatives are given by\nD\u2032X1 : \u03d5x = (y = z), \u03d5y = y, \u03d5z = z D\u2032\u2032X1 : \u03d5x = x, \u03d5y = (x= z), \u03d5z = z D\u2032\u2032\u2032X1 : \u03d5x = x, \u03d5y = y, \u03d5z = (x= y)\nThis shows that we cannot necessarily use the model set X1 to determine a single reason for bipolar non-realisability, that is, a single link (b, a) that is neither supporting nor attacking in all realisations. Rather, the culprit(s) might be different in each realisation, and to show bipolar nonrealisability, we have to prove that for all realisations, there necessarily exists some reason for non-bipolarity. And the number of different ADF realisations of a given model set X can be considerable, as our next result shows. Proposition 5. Let |A| = n, X \u2286 2A with\n\u2223\u22232A \\X\u2223\u2223 = m. The number of distinct ADFs D with su(D) = X is\nr(n,m) = (2n \u2212 1)m\nProof. We have to count the number of distinct models of the formula \u03c6\u2032X = \u03c6 \u2208 X \u2227 \u03c6 /\u2208 X from the proof of Theorem 3. We first observe that for each a \u2208 A and M \u2286 A, the propositional variable pMa occurs exactly once in \u03c6 \u2032 X . Formula \u03c6\u2208X is a conjunction of literals and does not contribute\nto combinatorial explosion. Formula \u03c6/\u2208X contains m conjuncts. Each of the conjuncts is a disjunction of n distinct literals. There are 2n \u2212 1 ways to satisfy such a disjunction. The claim now follows since for each of m conjuncts, we can choose one of 2n \u2212 1 different ways to satisfy it.\nSo the main contributing factor is the number m of interpretations that are excluded from the desired model set X . For Example 1, for instance, there are (23 \u2212 1)4 = 74 = 2401 ADFs with the model set X1. According to Theorem 4, none of them is bipolar. Obviously, the maximal number of realisations is achieved by X = \u2205 whence r(n, 2n) = (2n \u2212 1)2n . On the other hand, the model set X = 2A has exactly one realisation, r(n, 0) = 1.\nIt is comparably easy to show that BADF models are strictly more expressive than AFs, since sets of supported models of bipolar ADFs do not have the antichain property.\nProposition 6. AF <e BADFsu\nProof. Consider the vocabulary A = {a} and the BADF D = (A, {(a, a)} , {\u03d5a}) with \u03d5a = a. It is straightforward to check that its model set is su(D) = {\u2205, {a}}. Since model sets of AFs under stable extension semantics satisfy the antichain property, there is no equivalent AF over A.\nThis yields the following overall relationships:\nAF <e BADFsu <e ADFsu \u223c=e LPsu \u223c=e PL"}, {"heading": "Stable semantics", "text": "As before, we recall the current state of knowledge:\nAF \u2264e BADFst \u2264e ADFst <e PL and AF \u2264e LPst <e PL\nWe first show that BADFs are strictly more expressive than AFs.\nProposition 7. AF <e BADFst\nProof. Consider the BADF from Proposition 6, where the acceptance formula of the single statement a is given by \u03d5a = a. Its only stable model is \u2205. However there is no AF with a single argument with the same set of stable extensions: the only candidates are ({a} , \u2205) and ({a} , {(a, a)}); their respective stable-extension sets are {{a}} and \u2205.\nEven if we discount for this special case of realising the empty stable extension, there are non-trivial extension-sets that AFs cannot realise.\nExample 2 ((Dunne et al., 2014)). Consider the model set X2 = {{x, y} , {x, z} , {y, z}}. Dunne et al. (2014) proved that X2 is not realisable with stable AF semantics. Intuitively, the argument is as follows: Since x and y occur in an extension together, there can be no attack between them. The same holds for the pairs x, z and y, z. But then the set {x, y, z} is conflict-free and thus there must be a stable extension containing all three arguments, which is not allowed by X2. The reason is AFs\u2019 restriction to individual attack, as set attack (also called joint or collective attack) suffices to realise X2 with BADF D under stable model semantics:\n\u03d5x = \u00acy \u2228 \u00acz, \u03d5y = \u00acx \u2228 \u00acz, \u03d5z = \u00acx \u2228 \u00acy\nLet us exemplarily show that M = {x, y} is a stable model (the other cases are completely symmetric): The reduct DM is characterised by the two acceptance formulas \u03d5x = \u00acy \u2228 \u00acf and \u03d5y = \u00acx \u2228 \u00acf . We then easily find that \u0393DM (\u2205, \u2205) = (M, \u2205) = \u0393DM (M, \u2205).\nThe construction from the previous example model set comes from logic programming (Eiter et al., 2013) and can be generalised to realise any non-empty model set satisfying the antichain property. Definition 2. Let X \u2286 2A. Define the following BADF DstX = (A,L,C) where Ca for a \u2208 A is given by\n\u03d5a = \u2228\nM\u2208X,a\u2208M  \u2227 b\u2208A\\M \u00acb  and thus L = {(b, a) |M \u2208 X, a \u2208M, b \u2208 A \\M}.\nWe next show that the construction indeed works. Theorem 8. LetX with \u2205 6= X \u2286 2A be a\u2286-antichain. We find that st(DstX) = X . Proof. Let M \u2286 A. \u201c\u2286\u201d: Let M /\u2208 X . We show that M /\u2208 su(DstX) \u2287 st(DstX).\n1. There is an N \u2208 X with M ( N . Then there is an a \u2208 N \\M . Consider its acceptance formula \u03d5a. Since a \u2208 N and N \u2208 X , the formula \u03d5a has a disjunct \u03c8a,N = \u2227 b\u2208A\\N \u00acb. Now M \u2286 N im-\nplies A \\N \u2286 A \\M and M is a model for \u03c8a,N . Thus M is a model for \u03d5a although a /\u2208M , hence M /\u2208 su(DstX). 2. For all N \u2208 X , we have M 6\u2286 N . Obviously M 6= \u2205 since X 6= \u2205. Let a \u2208M . For each N \u2208 X with a \u2208 N , the acceptance formula \u03d5a contains a disjunct \u03c8a,N = \u2227 b\u2208A\\N \u00acb. By assumption, for each N \u2208 X\nthere is a bN \u2208M \\N . Clearly bN \u2208 A \\N and bN is evaluated to true by M . Hence for each N \u2208 X with a \u2208 N , the disjunct \u03c8a,N is evaluated to false by M . Thus \u03d5a is false under M and M /\u2208 su(DstX). \u201c\u2287\u201d: Let M \u2208 X . We first show that M is a model of DstX , that is: for all a \u2208 A, a \u2208M iff M is a model for \u03d5a.\n1. Let a \u2208M . By construction, we have that \u03d5a in DstX contains a disjunct of the form \u03c8a,M = \u2227 b\u2208A\\M \u00acb.\nAccording to the interpretation M , all such b \u2208 A \\M are false and thus \u03c8a,M is true whence \u03d5a is true. 2. Let a \u2208 A \\M and consider its acceptance formula \u03d5a. Assume to the contrary that M is a model for \u03d5a. Then there is some N \u2208 X with a \u2208 N such that M is a model for \u03c8a,N = \u2227 b\u2208A\\N \u00acb, that is,\nA \\N \u2286 A \\M . Hence M \u2286 N and X is not a \u2286- antichain. Contradiction. Thus M is no model for \u03d5a. Now consider the reduct DM of DstX with respect to M . There, \u03d5Ma contains the disjunct \u03c8Ma,M = \u03c8a,M [b/f : b /\u2208M ] where all b \u2208 A \\M have been replaced by false, whence \u03c8Ma,M = \u00acf \u2227 . . . \u2227 \u00acf and \u03d5Ma is equivalent to true. Thus each a \u2208M is true in the least fixpoint of \u0393DM and thus M \u2208 st(DstX).\nThe restriction to non-empty model sets is immaterial, since we can use the construction of Theorem 1 to realise the empty model set.\nSince the stable model semantics for both ADFs and normal logic programs have the antichain property, the following is clear. Corollary 9. ADFst \u2264e BADFst and LPst \u2264e BADFst\nFor the family of stable semantics, this leads to the following overall expressiveness relationships:\nAF <e BADFst \u223c=e ADFst \u223c=e LPst <e PL"}, {"heading": "Supported vs. stable semantics", "text": "Now we put the supported and stable pictures together. From the proof of Theorem 8, we can read off that for the canonical realisation DstX of an antichain X , the supported and stable semantics coincide, that is, su(DstX) = st(D st X) = X . With this observation, also bipolar ADFs under the supported semantics can realise any antichain, and we have this: Proposition 10. BADFst \u2264e BADFsu\nAs we have seen in Proposition 6, there are bipolar ADFs with supported-model sets that are not antichains. Thus we get the following result. Corollary 11. BADFst <e BADFsu\nThis result allows us to close the last gap and put together the big picture in Figure 1 below."}, {"heading": "Discussion", "text": "We compared the expressiveness of abstract argumentation frameworks, abstract dialectical frameworks, normal logic programs and propositional logic. We showed that expressiveness under different semantics varies for the formalisms and obtained a neat expressiveness hierarchy. These results inform us about the capabilities of these languages to encode sets of two-valued interpretations, and help us decide which languages to use for specific applications.\nFor instance, if we wish to encode arbitrary model sets, for example when using model-based revision, then ADFs\nand logic programs under supported semantics are a good choice. If we are happy with the restricted class of model sets having the antichain property, then we would be illadvised to use general ADFs under stable model semantics with their \u03a3P2 -hard stable model existence problem; to realise an antichain, it suffices to use bipolar ADFs or normal logic programs, where stable model existence is in NP.\nThere is much potential for further work. First of all, for results on non-realisability, it would be better to have necessary conditions than having to use a non-deterministic decision procedure. For this, we need to obtain general criteria that all model sets of a given formalism must obey, given the formalism is not universally expressive. This is nontrivial in general, and for AFs it constitutes a major open problem (Dunne et al., 2014; Baumann et al., 2014). Likewise, we sometimes used semantical realisations instead of syntactic ones; for example, to show universal realisability of ADFs under supported models we started out with model sets. It is an interesting question whether a realising ADF can be constructed from a given propositional formula without computing the models of the formula first. Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2014) already analyse many of them for argumentation frameworks. This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013). Third, there are further formalisms in abstract argumentation (Brewka, Polberg, and Woltran, 2013) whose expressiveness is by and large unexplored to the best of our knowledge. Fourth, the requirement that realisations may only use a fixed vocabulary without any additional symbols is quite restrictive. Intuitively, it should be allowed to add a reasonable number of additional atoms, for example a constant number or one that is linear in the original vocabulary. Finally, our study only considered if a language can express a model set, but not to what cost in terms of representation size. So the natural next step is to consider the succinctness of formalisms, \u201cHow large is the smallest knowledge base expressing a given model set?\u201d (Gogic et al., 1995). A landmark result in this direction has been obtained by Lifschitz and Razborov (2006), who have shown that logic programs (with respect to two-valued stable models) are exponentially more succinct than propositional logic. That is, there are logic programs whose respective sets of stable models cannot be expressed by a propositional formula whose size is at most polynomial in the size of the logic program, unless a certain widely believed assumption of complexity theory is false. With the results of the present paper, we have laid the groundwork for a similar analysis of the other knowledge representation languages considered here, perhaps working towards a \u201cmap\u201d of these languages in the sense of Darwiche and Marquis\u2019 knowledge compilation map [2002]. Acknowledgements. The author wishes to thank Stefan Woltran for providing a useful pointer to related work on realisability in logic programming, and Frank Loebe for several informative discussions. This research was partially supported by DFG (project BR 1817/7-1)."}, {"heading": "Appendix", "text": "Lemma 12. X is bipolarly realisable if and only if the formula \u03c6X from Theorem 3 is satisfiable.\nProof. \u201cif\u201d: Let I \u2286 P be a model for \u03c6X . For each a \u2208 A, we define an acceptance condition as follows: for M \u2286 A, set Ca(M) = t iff pMa \u2208 I . It is easy to see that \u03c6bipolar guarantees that these acceptance conditions are all bipolar. The ADF is now given by DsuX = (A,A\u00d7A,C). It remains to show that any M \u2286 A is a model of DsuX if and only if M \u2208 X . \u201cif\u201d: Let M \u2208 X . We have to show that M is a model of DsuX . Consider any a \u2208 A.\n1. a \u2208M . Since I is a model of \u03c6\u2208X , we have pMa \u2208 I and thus by definition Ca(M) = t. 2. a \u2208 A \\M . Since I is a model of \u03c6\u2208X , we have pMa /\u2208 I and thus by definition Ca(M) = f .\n\u201conly if\u201d: LetM /\u2208 X . Since I is a model of \u03c6/\u2208X , there is an a \u2208M such that Ca(M) = f or an a /\u2208M such that Ca(M) = t. In any case, M is not a model of DsuX . \u201conly if\u201d: Let D be a bipolar ADF with su(D) = X . We use D to define a model I for \u03c6X . First, for M \u2286 A and a \u2208 A, set pMa \u2208 I iff Ca(M) = t. Since D is bipolar, each link is supporting or attacking and for all a, b \u2208 A we can find a valuation for pa,bsup and p a,b att . It remains to\nshow that I is a model for \u03c6X . 1. I is a model for \u03c6\u2208X : Since D realises X , each M \u2208 X\nis a model of D and thus for all a \u2208 A we have Ca(M) = t iff a \u2208M . 2. I is a model for \u03c6/\u2208X : Since D realises X , each M \u2286 A with M /\u2208 X is not a model of D. Thus for each such M , there is an a \u2208 A witnessing that M is not a model of D: (1) a \u2208M and Ca(M) = f , or (2) a /\u2208M and Ca(M) = t. 3. I is a model for \u03c6bipolar : This is straightforward since D is bipolar by assumption."}], "references": [{"title": "Compact argumentation frameworks", "author": ["R. Baumann", "W. Dvo\u0159\u00e1k", "T. Linsbichler", "H. Strass", "S. Woltran"], "venue": "Konieczny, S., and Tompits, H., eds., Proceedings of the Fifteenth International Workshop on Non-Monotonic Reasoning (NMR).", "citeRegEx": "Baumann et al\\.,? 2014", "shortCiteRegEx": "Baumann et al\\.", "year": 2014}, {"title": "Negation by default and unstratifiable logic programs", "author": ["N. Bidoit", "C. Froidevaux"], "venue": "Theoretical Computer Science 78(1):85\u2013112.", "citeRegEx": "Bidoit and Froidevaux,? 1991", "shortCiteRegEx": "Bidoit and Froidevaux", "year": 1991}, {"title": "Abstract Dialectical Frameworks", "author": ["G. Brewka", "S. Woltran"], "venue": "Proceedings of the Twelfth International Conference on the Principles of Knowledge Representation and Reasoning (KR), 102\u2013111.", "citeRegEx": "Brewka and Woltran,? 2010", "shortCiteRegEx": "Brewka and Woltran", "year": 2010}, {"title": "Abstract Dialectical Frameworks Revisited", "author": ["G. Brewka", "S. Ellmauthaler", "H. Strass", "J.P. Wallner", "S. Woltran"], "venue": "Proceedings of the Twenty-Third International Joint Conference on Artificial Intelligence (IJCAI), 803\u2013 809. IJCAI/AAAI.", "citeRegEx": "Brewka et al\\.,? 2013", "shortCiteRegEx": "Brewka et al\\.", "year": 2013}, {"title": "Relating the Semantics of Abstract Dialectical Frameworks and Standard AFs", "author": ["G. Brewka", "P.E. Dunne", "S. Woltran"], "venue": "Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence (IJCAI), 780\u2013785. IJCAI/AAAI.", "citeRegEx": "Brewka et al\\.,? 2011", "shortCiteRegEx": "Brewka et al\\.", "year": 2011}, {"title": "Generalizations of Dung frameworks and their role in formal argumentation", "author": ["G. Brewka", "S. Polberg", "S. Woltran"], "venue": "IEEE Intelligent Systems PP(99). Special Issue on Representation and Reasoning. In press.", "citeRegEx": "Brewka et al\\.,? 2013", "shortCiteRegEx": "Brewka et al\\.", "year": 2013}, {"title": "Negation as Failure", "author": ["K.L. Clark"], "venue": "Gallaire, H., and Minker, J., eds., Logic and Data Bases, 293\u2013322. Plenum Press.", "citeRegEx": "Clark,? 1978", "shortCiteRegEx": "Clark", "year": 1978}, {"title": "On the revision of argumentation systems: Minimal change of arguments status", "author": ["S. Coste-Marquis", "S. Konieczny", "J.-G. Mailly", "P. Marquis"], "venue": "Proceedings of TAFA.", "citeRegEx": "Coste.Marquis et al\\.,? 2013", "shortCiteRegEx": "Coste.Marquis et al\\.", "year": 2013}, {"title": "A Knowledge Compilation Map", "author": ["A. Darwiche", "P. Marquis"], "venue": "Journal of Artificial Intelligence Research (JAIR) 17:229\u2013264.", "citeRegEx": "Darwiche and Marquis,? 2002", "shortCiteRegEx": "Darwiche and Marquis", "year": 2002}, {"title": "On the computational complexity of assumption-based argumentation for default reasoning", "author": ["Y. Dimopoulos", "B. Nebel", "F. Toni"], "venue": "Artificial Intelligence 141(1/2):57\u201378.", "citeRegEx": "Dimopoulos et al\\.,? 2002", "shortCiteRegEx": "Dimopoulos et al\\.", "year": 2002}, {"title": "On the Acceptability of Arguments and its Fundamental Role in Nonmonotonic Reasoning, Logic Programming and n-Person Games", "author": ["P.M. Dung"], "venue": "Artificial Intelligence 77:321\u2013358.", "citeRegEx": "Dung,? 1995", "shortCiteRegEx": "Dung", "year": 1995}, {"title": "Characteristics of Multiple Viewpoints in Abstract Argumentation", "author": ["P.E. Dunne", "W. Dvo\u0159\u00e1k", "T. Linsbichler", "S. Woltran"], "venue": "Proceedings of the Fourteenth International Conference on the Principles of Knowledge Representation and Reasoning (KR). To appear.", "citeRegEx": "Dunne et al\\.,? 2014", "shortCiteRegEx": "Dunne et al\\.", "year": 2014}, {"title": "Model-based recasting in answer-set programming", "author": ["T. Eiter", "M. Fink", "J. P\u00fchrer", "H. Tompits", "S. Woltran"], "venue": "Journal of Applied Non-Classical Logics 23(1\u2013 2):75\u2013104.", "citeRegEx": "Eiter et al\\.,? 2013", "shortCiteRegEx": "Eiter et al\\.", "year": 2013}, {"title": "Potassco: The Potsdam Answer Set Solving Collection", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider"], "venue": "AI Communications 24(2):105\u2013124. Available at http://potassco.sourceforge.net.", "citeRegEx": "Gebser et al\\.,? 2011", "shortCiteRegEx": "Gebser et al\\.", "year": 2011}, {"title": "The Stable Model Semantics for Logic Programming", "author": ["M. Gelfond", "V. Lifschitz"], "venue": "Proceedings of the International Conference on Logic Programming (ICLP), 1070\u20131080. The MIT Press.", "citeRegEx": "Gelfond and Lifschitz,? 1988", "shortCiteRegEx": "Gelfond and Lifschitz", "year": 1988}, {"title": "The comparative linguistics of knowledge representation", "author": ["G. Gogic", "H. Kautz", "C. Papadimitriou", "B. Selman"], "venue": "Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence (IJCAI), 862\u2013 869. Morgan Kaufmann.", "citeRegEx": "Gogic et al\\.,? 1995", "shortCiteRegEx": "Gogic et al\\.", "year": 1995}, {"title": "Why are there so many loop formulas", "author": ["V. Lifschitz", "A. Razborov"], "venue": "ACM Transactions on Computational Logic 7(2):261\u2013268", "citeRegEx": "Lifschitz and Razborov,? \\Q2006\\E", "shortCiteRegEx": "Lifschitz and Razborov", "year": 2006}, {"title": "ASSAT: Computing Answer Sets of a Logic Program by SAT Solvers", "author": ["F. Lin", "Y. Zhao"], "venue": "Artificial Intelligence 157(1-2):115\u2013137.", "citeRegEx": "Lin and Zhao,? 2004", "shortCiteRegEx": "Lin and Zhao", "year": 2004}, {"title": "Autoepistemic logic", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": "Journal of the ACM 38(3):587\u2013618.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1991", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1991}, {"title": "Inferring acceptable arguments with answer set programming", "author": ["M. Osorio", "C. Zepeda", "J.C. Nieves", "U. Cort\u00e9s"], "venue": "Proceedings of the Sixth Mexican International Conference on Computer Science (ENC), 198\u2013205. IEEE Computer Society.", "citeRegEx": "Osorio et al\\.,? 2005", "shortCiteRegEx": "Osorio et al\\.", "year": 2005}, {"title": "Analyzing the Computational Complexity of Abstract Dialectical Frameworks via Approximation Fixpoint Theory", "author": ["H. Strass", "J.P. Wallner"], "venue": "Proceedings of the Fourteenth International Conference on the Principles of Knowledge Representation and Reasoning (KR). To ap-", "citeRegEx": "Strass and Wallner,? 2014", "shortCiteRegEx": "Strass and Wallner", "year": 2014}, {"title": "Approximating operators and semantics for abstract dialectical frameworks", "author": ["H. Strass"], "venue": "Artificial Intelligence 205:39\u201370.", "citeRegEx": "Strass,? 2013", "shortCiteRegEx": "Strass", "year": 2013}], "referenceMentions": [{"referenceID": 10, "context": "In this paper, we use such an alternative notion and perform an exemplary study of the relative expressiveness of several different knowledge representation languages: argumentation frameworks (AFs) (Dung, 1995), normal logic programs (LPs), abstract dialectical frameworks (ADFs) (Brewka and Woltran, 2010) and propositional logic.", "startOffset": 199, "endOffset": 211}, {"referenceID": 2, "context": "In this paper, we use such an alternative notion and perform an exemplary study of the relative expressiveness of several different knowledge representation languages: argumentation frameworks (AFs) (Dung, 1995), normal logic programs (LPs), abstract dialectical frameworks (ADFs) (Brewka and Woltran, 2010) and propositional logic.", "startOffset": 281, "endOffset": 307}, {"referenceID": 1, "context": "\u2022 for AFs, deciding stable extension existence is NPcomplete (Dimopoulos, Nebel, and Toni, 2002); \u2022 for LPs, deciding the existence of supported/stable models is NP-complete (Bidoit and Froidevaux, 1991; Marek and Truszczy\u0144ski, 1991);", "startOffset": 174, "endOffset": 233}, {"referenceID": 18, "context": "\u2022 for AFs, deciding stable extension existence is NPcomplete (Dimopoulos, Nebel, and Toni, 2002); \u2022 for LPs, deciding the existence of supported/stable models is NP-complete (Bidoit and Froidevaux, 1991; Marek and Truszczy\u0144ski, 1991);", "startOffset": 174, "endOffset": 233}, {"referenceID": 3, "context": "\u2022 for ADFs, deciding the existence of models is NPcomplete (Brewka et al., 2013), deciding the existence of stable models is \u03a32 -complete for general ADFs (Brewka et al.", "startOffset": 59, "endOffset": 80}, {"referenceID": 3, "context": ", 2013), deciding the existence of stable models is \u03a32 -complete for general ADFs (Brewka et al., 2013) and NP-complete for the subclass of bipolar ADFs (Strass and Wallner, 2014);", "startOffset": 82, "endOffset": 103}, {"referenceID": 20, "context": ", 2013) and NP-complete for the subclass of bipolar ADFs (Strass and Wallner, 2014);", "startOffset": 57, "endOffset": 83}, {"referenceID": 15, "context": "In view of these almost identical complexities, we use an alternative measure of the expressiveness of a knowledge representation language L: \u201cGiven a set of two-valued interpretations, is there a knowledge base in L that has this exact model set?\u201d This notion lends itself straightforwardly to compare different formalisms (Gogic et al., 1995):", "startOffset": 324, "endOffset": 344}, {"referenceID": 7, "context": "For example, in a recent approach to revising argumentation frameworks (Coste-Marquis et al., 2013), the authors avoid this problem by assuming to produce a collection of AFs whose model sets in union produce the desired model set.", "startOffset": 71, "endOffset": 99}, {"referenceID": 10, "context": "The latter was recently studied for argumentation frameworks by Dunne et al. (2014). They allow to extend the vocabulary in order to realise a given model set, as long as the new vocabulary elements are evaluated to false in all models.", "startOffset": 64, "endOffset": 84}, {"referenceID": 10, "context": "The latter was recently studied for argumentation frameworks by Dunne et al. (2014). They allow to extend the vocabulary in order to realise a given model set, as long as the new vocabulary elements are evaluated to false in all models. For several semantics of AFs, Dunne et al. found necessary (and sufficient) conditions for realisability. While their sufficient conditions are not applicable to our setting, they discovered a necessary condition for realisability with stable extension semantics that we will make use of in this paper. There has also been work on translating ADFs into AFs for the ADF model and AF stable extension semantics (Brewka, Dunne, and Woltran, 2011), however this translation introduces additional arguments and is therefore not compact. The gain that is achieved by our results is not only that of increased clarity about fundamental properties of these knowledge representation languages \u2013 What can these formalisms express, actually? \u2013 but has several further applications. As Dunne et al. (2014) remarked, a major application is in constructing knowledge bases with the aim of encoding a certain model set.", "startOffset": 64, "endOffset": 1031}, {"referenceID": 7, "context": "For example, in a recent approach to revising argumentation frameworks (Coste-Marquis et al., 2013), the authors avoid this problem by assuming to produce a collection of AFs whose model sets in union produce the desired model set. While the work of Dunne et al. (2014) showed that this is indeed necessary in the case of AFs and stable extension semantics (that is, there are model sets that a single AF just cannot express), our work shows that for ADFs under the model semantics, a single knowledge base (ADF) is always enough to realise any given model set.", "startOffset": 72, "endOffset": 270}, {"referenceID": 6, "context": "Clark (1978) gave the first declarative semantics for normal logic programs via a translation to classical logic that will be recalled shortly.", "startOffset": 0, "endOffset": 13}, {"referenceID": 6, "context": "Clark (1978) gave the first declarative semantics for normal logic programs via a translation to classical logic that will be recalled shortly. This leads to the supported model semantics for logic programs: A rule a\u2190 B \u2208 P is active in a set M \u2286 A iff B \u2286M and B\u2212 \u2229M = \u2205 imply a \u2208M . M is a supported model for P iff M = {a \u2208 A | a\u2190 B \u2208 P is active in M}. For a logic program P we denote the set of its supported models by su(P ). The intuition behind this semantics is that everything that is true in a model has some kind of support. However, this support might be cyclic self-support. For instance, the logic program {a\u2190 a} has two supported models, \u2205 and {a}, where the latter is undesired in many application domains. As an alternative, Gelfond and Lifschitz (1988) proposed the stable model semantics, a declarative semantics for negation as failure that does not allow selfsupport: M \u2286 A is a stable model for P iff M is the\u2286-least supported model of P , where the definite program P is obtained from P by (1) eliminating each rule whose body contains a literal not a with a \u2208M , and (2) deleting all literals of the form not a from the bodies of the remaining rules.", "startOffset": 0, "endOffset": 772}, {"referenceID": 2, "context": "Brewka and Woltran (2010) introduced a useful subclass of ADFs: an ADF D = (A,L,C) is bipolar iff all links in L are supporting or attacking (or both).", "startOffset": 0, "endOffset": 26}, {"referenceID": 3, "context": "The definition of stable models is inspired by logic programming and slightly more complicated (Brewka et al., 2013).", "startOffset": 95, "endOffset": 116}, {"referenceID": 2, "context": "From AFs to BADFs Brewka and Woltran (2010) showed how to translate AFs into ADFs: For an AF F = (A,R), define the ADF associated to F as D(F ) = (A,R,C) with", "startOffset": 18, "endOffset": 44}, {"referenceID": 2, "context": "Brewka and Woltran (2010) proved that this translation is faithful for the AF stable extension and ADF model semantics (Proposition 1).", "startOffset": 0, "endOffset": 26}, {"referenceID": 2, "context": "Brewka and Woltran (2010) proved that this translation is faithful for the AF stable extension and ADF model semantics (Proposition 1). Brewka et al. (2013) later proved the same for the AF stable extension and ADF stable model semantics (Theorem 4).", "startOffset": 0, "endOffset": 157}, {"referenceID": 2, "context": "From ADFs to PL Brewka and Woltran (2010) also showed that ADFs under supported model semantics can be faithfully translated into propositional logic: When acceptance conditions of statements a \u2208 A are represented by propositional formulas \u03c6a, then the supported models of an ADF D over A are given by the classical models of the formula set {a\u2194 \u03c6a | a \u2208 A}.", "startOffset": 16, "endOffset": 42}, {"referenceID": 21, "context": "From ADFs to LPs In recent work we showed that ADFs can be faithfully translated into normal logic programs (Strass, 2013).", "startOffset": 108, "endOffset": 122}, {"referenceID": 21, "context": "14 in (Strass, 2013) that this translation preserves the supported model semantics.", "startOffset": 6, "endOffset": 20}, {"referenceID": 19, "context": "From AFs to LPs The translation chain from AFs to ADFs to LPs is compact, and faithful for AF stable semantics and LP stable semantics (Osorio et al., 2005), and AF stable semantics and LP supported semantics (Strass, 2013).", "startOffset": 135, "endOffset": 156}, {"referenceID": 21, "context": ", 2005), and AF stable semantics and LP supported semantics (Strass, 2013).", "startOffset": 60, "endOffset": 74}, {"referenceID": 6, "context": "From LPs to PL It is well-known that normal logic programs under supported model semantics can be translated to propositional logic (Clark, 1978).", "startOffset": 132, "endOffset": 145}, {"referenceID": 17, "context": "For the stable model semantics, additional formulas have to be added, but the extended translation works all the same (Lin and Zhao, 2004).", "startOffset": 118, "endOffset": 138}, {"referenceID": 2, "context": "From LPs to ADFs The Clark completion of a normal logic program directly yields an equivalent ADF over the same signature (Brewka and Woltran, 2010).", "startOffset": 122, "endOffset": 148}, {"referenceID": 21, "context": "16 in (Strass, 2013).", "startOffset": 6, "endOffset": 20}, {"referenceID": 13, "context": "We have implemented the translation of Theorem 3 and used the solver clasp (Gebser et al., 2011) to verify that \u03c6X1 is unsatisfiable.", "startOffset": 75, "endOffset": 96}, {"referenceID": 11, "context": "Example 2 ((Dunne et al., 2014)).", "startOffset": 11, "endOffset": 31}, {"referenceID": 11, "context": "Example 2 ((Dunne et al., 2014)). Consider the model set X2 = {{x, y} , {x, z} , {y, z}}. Dunne et al. (2014) proved that X2 is not realisable with stable AF semantics.", "startOffset": 12, "endOffset": 110}, {"referenceID": 12, "context": "The construction from the previous example model set comes from logic programming (Eiter et al., 2013) and can be generalised to realise any non-empty model set satisfying the antichain property.", "startOffset": 82, "endOffset": 102}, {"referenceID": 11, "context": "This is nontrivial in general, and for AFs it constitutes a major open problem (Dunne et al., 2014; Baumann et al., 2014).", "startOffset": 79, "endOffset": 121}, {"referenceID": 0, "context": "This is nontrivial in general, and for AFs it constitutes a major open problem (Dunne et al., 2014; Baumann et al., 2014).", "startOffset": 79, "endOffset": 121}, {"referenceID": 21, "context": "This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013).", "startOffset": 188, "endOffset": 223}, {"referenceID": 3, "context": "This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013).", "startOffset": 188, "endOffset": 223}, {"referenceID": 15, "context": "So the natural next step is to consider the succinctness of formalisms, \u201cHow large is the smallest knowledge base expressing a given model set?\u201d (Gogic et al., 1995).", "startOffset": 145, "endOffset": 165}, {"referenceID": 0, "context": ", 2014; Baumann et al., 2014). Likewise, we sometimes used semantical realisations instead of syntactic ones; for example, to show universal realisability of ADFs under supported models we started out with model sets. It is an interesting question whether a realising ADF can be constructed from a given propositional formula without computing the models of the formula first. Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2014) already analyse many of them for argumentation frameworks.", "startOffset": 8, "endOffset": 508}, {"referenceID": 0, "context": ", 2014; Baumann et al., 2014). Likewise, we sometimes used semantical realisations instead of syntactic ones; for example, to show universal realisability of ADFs under supported models we started out with model sets. It is an interesting question whether a realising ADF can be constructed from a given propositional formula without computing the models of the formula first. Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2014) already analyse many of them for argumentation frameworks. This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013). Third, there are further formalisms in abstract argumentation (Brewka, Polberg, and Woltran, 2013) whose expressiveness is by and large unexplored to the best of our knowledge. Fourth, the requirement that realisations may only use a fixed vocabulary without any additional symbols is quite restrictive. Intuitively, it should be allowed to add a reasonable number of additional atoms, for example a constant number or one that is linear in the original vocabulary. Finally, our study only considered if a language can express a model set, but not to what cost in terms of representation size. So the natural next step is to consider the succinctness of formalisms, \u201cHow large is the smallest knowledge base expressing a given model set?\u201d (Gogic et al., 1995). A landmark result in this direction has been obtained by Lifschitz and Razborov (2006), who have shown that logic programs (with respect to two-valued stable models) are exponentially more succinct than propositional logic.", "startOffset": 8, "endOffset": 1640}, {"referenceID": 0, "context": ", 2014; Baumann et al., 2014). Likewise, we sometimes used semantical realisations instead of syntactic ones; for example, to show universal realisability of ADFs under supported models we started out with model sets. It is an interesting question whether a realising ADF can be constructed from a given propositional formula without computing the models of the formula first. Second, there are further semantics for abstract dialectical frameworks whose expressiveness could be studied; Dunne et al. (2014) already analyse many of them for argumentation frameworks. This work is thus only a start and the same can be done for the remaining semantics, for example admissible, complete, preferred and others, which are all defined for AFs, (B)ADFs and LPs (Strass, 2013; Brewka et al., 2013). Third, there are further formalisms in abstract argumentation (Brewka, Polberg, and Woltran, 2013) whose expressiveness is by and large unexplored to the best of our knowledge. Fourth, the requirement that realisations may only use a fixed vocabulary without any additional symbols is quite restrictive. Intuitively, it should be allowed to add a reasonable number of additional atoms, for example a constant number or one that is linear in the original vocabulary. Finally, our study only considered if a language can express a model set, but not to what cost in terms of representation size. So the natural next step is to consider the succinctness of formalisms, \u201cHow large is the smallest knowledge base expressing a given model set?\u201d (Gogic et al., 1995). A landmark result in this direction has been obtained by Lifschitz and Razborov (2006), who have shown that logic programs (with respect to two-valued stable models) are exponentially more succinct than propositional logic. That is, there are logic programs whose respective sets of stable models cannot be expressed by a propositional formula whose size is at most polynomial in the size of the logic program, unless a certain widely believed assumption of complexity theory is false. With the results of the present paper, we have laid the groundwork for a similar analysis of the other knowledge representation languages considered here, perhaps working towards a \u201cmap\u201d of these languages in the sense of Darwiche and Marquis\u2019 knowledge compilation map [2002].", "startOffset": 8, "endOffset": 2316}], "year": 2014, "abstractText": "We analyse the expressiveness of the two-valued semantics of abstract argumentation frameworks, normal logic programsargumentation frameworks, normal logic programs and abstract dialectical frameworks. By expressiveness we mean the ability to encode a desired set of two-valued interpretations over a given propositional signature using only atoms from that signature. While the computational complexity of the two-valued model existence problem for all these languages is (almost) the same, we show that the languages form a neat hierarchy with respect to their expressiveness.", "creator": "LaTeX with hyperref package"}}}