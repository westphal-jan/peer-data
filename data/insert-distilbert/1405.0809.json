{"id": "1405.0809", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "5-May-2014", "title": "Implementing Default and Autoepistemic Logics via the Logic of GK", "abstract": "the logic of knowledge and justified assumptions, also known alternately as logic of grounded knowledge ( gk ), was proposed by lin and shoham kato as a general logic for nonmonotonic reasoning. to date, it has been used to embed in it default logic ( propositional proof case ), autoepistemic stable logic, turner'usual s logic of universal causation, and general logic programming under stable model semantics. besides effectively showing the generality of finite gk as a logic for nonmonotonic reasoning, these embeddings shed light on the relationships among these include other logics. in this paper, \" for the marked first time, we show how the logic of gk can be embedded into disjunctive logic programming in a weakly polynomial but non - modular rational translation with new variables. the result library can then variously be used to compute the extension / partial expansion semantics operations of that default logic, autoepistemic weak logic and turner's logic of universal generic causation by disjunctive circuit asp solvers such as claspd ( - 2 ), modular dlv, gnt and cmodels.", "histories": [["v1", "Mon, 5 May 2014 07:45:30 GMT  (39kb,D)", "http://arxiv.org/abs/1405.0809v1", "Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)"]], "COMMENTS": "Proceedings of the 15th International Workshop on Non-Monotonic Reasoning (NMR 2014)", "reviews": [], "SUBJECTS": "cs.AI cs.LO", "authors": ["jianmin ji", "hannes strass"], "accepted": false, "id": "1405.0809"}, "pdf": {"name": "1405.0809.pdf", "metadata": {"source": "CRF", "title": "Implementing Default and Autoepistemic Logics via the Logic of GK", "authors": ["Jianmin Ji", "Hannes Strass"], "emails": [], "sections": [{"heading": "Introduction", "text": "Lin and Shoham [1992] proposed a logic with two modal operators K and A, standing for knowledge and assumption, respectively. The idea is that one starts with a set of assumptions (those true under the modal operator A), computes the minimal knowledge under this set of assumptions, and then checks to see if the assumptions were justified in that they agree with the resulting minimal knowledge. For instance, consider the GK formula Ap \u2283 Kp. If we assume p, then we can conclude that we know p, thus the assumption that p holds is justified, and we get a GK model where both Ap and Kp are true. (There is another GK model where we do not assume p and hence do not know p.) However, there is no GK model of \u00acAp \u2283 Kp: if we do not assume p, we are forced to conclude Kp, but then knowledge and assumptions do not coincide; if we do assume p, we cannot conclude that we know p and thus assuming p was not justified.\nTo date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011]. Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in\nlogic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.\nIn this paper, for the first time, we consider computing models of GK theories by disjunctive logic programs. We shall propose a polynomial translation from a (pure) GK theory to a disjunctive logic program such that there is a one-to-one correspondence between GK models of the GK theory and answer sets of the resulting disjunctive logic program. The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner\u2019s logic of universal causation by disjunctive ASP solvers such as GNT [Janhunen and Niemela\u0308, 2004], cmodels [Giunchiglia, Lierler, and Maratea, 2006], DLV [Leone et al., 2006], claspD [Drescher et al., 2008] and claspD-2 [Gebser, Kaufmann, and Schaub, 2013]. In particular, the recent advances in disjunctive answer set solving [Gebser, Kaufmann, and Schaub, 2013] open up promising research avenues towards applications of expressive nonmonotonic knowledge representation languages.\nTo substantiate this claim, we have implemented the translation and report on some preliminary experiments that we conducted on the special case of computing extensions for Reiter\u2019s default logic [Reiter, 1980]. The implementation, called gk2dlp, is available for download from the second author\u2019s home page.1\nProviding implementations for theoretical formalisms has a long tradition in nonmonotonic reasoning, for an overview see [Dix, Furbach, and Niemela\u0308, 2001]. In fact, nonmonotonic reasoning itself originated from a desire to more accurately model the way humans reason, and was since its conception driven by applications in commonsense reasoning [McCarthy, 1980, 1986]. Today, thanks to extensive research efforts, we know how closely interrelated the different formalisms for nonmonotonic reasoning are, and can use this knowledge to improve the scope of implementations.\nThis paper is organized as follows. Section 2 reviews logic programs, the logic of GK and default and autoepistemic logics. Section 3 presents our main result, the map-\n1http://informatik.uni-leipzig.de/\u02dcstrass/ gk2dlp/\nar X\niv :1\n40 5.\n08 09\nv1 [\ncs .A\nI] 5\nM ay\n2 01\n4\nping from GK to disjunctive logic programming. Section 4 presents our prototypical implementation, several experiments we conducted to analyze the translation, possible applications for it, and a comparison with previous and related work. Section 5 concludes with ideas for future work."}, {"heading": "Preliminaries", "text": "We assume a propositional language with two zero-place logical connectives > for tautology and \u22a5 for contradiction. We denote by Atom the set of atoms, the signature of our language, and Lit the set of literals: Lit = Atom \u222a {\u00acp | p \u2208 Atom}. A set I of literals is called complete if for each atom p, exactly one of {p,\u00acp} is in I .\nIn this paper, we identify an interpretation with a complete set of literals. If I is a complete set of literals, we use it as an interpretation when we say that it is a model of a formula, and we use it as a set of literals when we say that it entails a formula. In particular, we denote by Th(I) the logical closure of I (considered to be a set of literals)."}, {"heading": "Logic Programming", "text": "A nested expression is built from literals using the 0-place connectives > and \u22a5, the unary connective \u201cnot\u201d and the binary connectives \u201c,\u201d and \u201c;\u201d for conjunction and disjunction. A logic program with nested expressions is a finite set of rules of the form F \u2190 G, where F and G are nested expressions. The answer set of a logic program with nested expressions is defined as in [Lifschitz, Tang, and Turner, 1999]. Given a nested expression F and a set S of literals, we define when S satisfies F , written S |= F below, recursively as follows (l is a literal):\n\u2022 S |= l if l \u2208 S, \u2022 S |= > and S 6|= \u22a5, \u2022 S |= not F if S 6|= F , \u2022 S |= F,G if S |= F and S |= G, and \u2022 S |= F ;G if S |= F or S |= G. S satisfies a rule F \u2190 G if S |= F whenever S |= G. S satisfies a logic program P , written S |= P , if S satisfies all rules in P .\nThe reduct PS of P related to S is the result of replacing every maximal subexpression of P that has the form not F with \u22a5 if S |= F , and with > otherwise. For a logic program P without not, the answer set of P is any minimal consistent subset S of Lit that satisfies P . We use \u0393P (S) to denote the set of answer sets of PS . Now a consistent set S of literals is an answer set of P iff S \u2208 \u0393P (S). Every logic program with nested expressions can be equivalently translated to disjunctive logic programs with disjunctive rules of the form\nl1; \u00b7 \u00b7 \u00b7 ; lk \u2190lk+1, . . . , lt, not lt+1, . . . , not lm, not not lm+1, . . . , not not ln\nwhere n \u2265 m \u2265 t \u2265 k \u2265 0 and l1, . . . , ln are propositional literals."}, {"heading": "Default Logic", "text": "Default logic [Reiter, 1980] is for making and withdrawing assumptions in the light of incomplete knowledge. This is done by defaults, that allow to express rules of thumb such as \u201cbirds usually fly\u201d and \u201ctools usually work.\u201d For a given logical language, a default is any expression of the form \u03c6 : \u03c81, . . . , \u03c8n/\u03d5 where \u03c6, \u03c81, . . . , \u03c8n, \u03d5 are formulas of the underlying language. A default theory is a pair (W,D), where W is a set of formulas and D is a set of defaults. The meaning of default theories is given through the notion of extensions. An extension of a default theory (W,D) is \u201cinterpreted as an acceptable set of beliefs that one may hold about the incompletely specified world W \u201d [Reiter, 1980]. For a default theory (W,D) and any set S of formulas let \u0393(S) be the smallest set satisfying (1) W \u2286 \u0393(S), (2) Th(\u0393(S)) = \u0393(S), (3) If \u03c6 : \u03c81, . . . , \u03c8n/\u03d5 \u2208 D, \u03c6 \u2208 \u0393(S) and \u00ac\u03c81, . . . ,\u00ac\u03c8n /\u2208 S, then \u03d5 \u2208 \u0393(S). A set E of formulas is called an extension for (W,D) iff \u0393(E) = E."}, {"heading": "Autoepistemic Logic", "text": "Moore [1985] strives to formalize an ideally rational agent reasoning about its own beliefs. He uses a belief modality L to explicitly refer to the agent\u2019s belief within the language. Given a set A of formulas (the initial beliefs), a set T is an expansion of A if it coincides with the deductive closure of the set A \u222a {L\u03d5 | \u03d5 \u2208 T} \u222a {\u00acL\u03d5 | \u03d5 /\u2208 T}. In words, T is an expansion if it equals what can be derived using the initial beliefs A and positive and negative introspection with respect to T itself. It was later discovered that this definition of expansions allows unfounded, self-justifying beliefs. Such beliefs are however not always desirable when representing the knowledge of agents."}, {"heading": "The Logic of GK", "text": "The language of GK proposed by Lin and Shoham [1992] is a modal propositional language with two modal operators, K, for knowledge, and A, for assumption. GK formulas \u03d5 are propositional formulas with K and A, that is,\n\u03d5 ::= \u22a5 | p | \u00ac\u03d5 | \u03d5 \u2227 \u03d5 | \u03d5 \u2228 \u03d5 | K\u03d5 | A\u03d5\nwhere p is an atom. A GK theory is a set of GK formulas. GK is a nonmonotonic logic, and its semantics is defined using the standard Kripke possible world interpretations. Informally speaking, a GK model is a Kripke interpretation where what is true under K is minimal and exactly the same as what is true under A. The intuition here is that given a GK formula, one first makes some assumptions (those true under A), then one minimizes the knowledge thus entailed, and finally checks to make sure that the initial assumption is justified in the sense that the minimal knowledge is the same as the initial assumption.\nFormally, a Kripke interpretation M is a tuple \u3008W,\u03c0,RK , RA, s\u3009, where W is a nonempty set of possible worlds, \u03c0 a function that maps a possible world to an interpretation, RK and RA binary relations over W representing the accessibility relations for K and A, respectively, and s \u2208W , called the actual world of M . The satisfaction relation |= between a Kripke interpretation\nM = \u3008W,\u03c0,RK , RA, s\u3009 and a GK formula \u03d5 is defined in a standard way:\n\u2022 M 6|= \u22a5, \u2022 M |= p iff p \u2208 \u03c0(s), where p is an atom, \u2022 M |= \u00ac\u03d5 iff M 6|= \u03d5, \u2022 M |= \u03d5 \u2227 \u03c8 iff M |= \u03d5 and M |= \u03c8, \u2022 M |= \u03d5 \u2228 \u03c8 iff M |= \u03d5 or M |= \u03c8, \u2022 M |= K\u03d5 iff \u3008W,\u03c0,RK , RA, w\u3009 |= \u03d5 for any w \u2208 W\nsuch that (s, w) \u2208 RK , \u2022 M |= A\u03d5 iff \u3008W,\u03c0,RK , RA, w\u3009 |= \u03d5 for any w \u2208 W\nsuch that (s, w) \u2208 RA. Note that for any w \u2208W , \u03c0(w) is an interpretation. We say that a Kripke interpretationM is a model of a GK formula \u03d5 if M satisfies \u03d5, M is a model of a GK theory T if M satisfies every GK formula in T . In the following, given a Kripke interpretation M , we let\nK(M) = {\u03c6 | \u03c6 is a propositional formula and M |= K\u03c6 }, A(M) = {\u03c6 | \u03c6 is a propositional formula and M |= A\u03c6 }.\nNotice that K(M) and A(M) are always closed under classical logical entailment \u2013 they are propositional theories.\nGiven a GK formula T , a Kripke interpretation M is a minimal model of T ifM is a model of T and there does not exist another model M1 of T such that A(M1) = A(M) and K(M1) ( K(M). We say that M is a GK model of T if M is a minimal model of T and K(M) = A(M).\nIn this paper, we consider only GK formulas that do not contain nested occurrences of modal operators. Specifically, an A-atom is a formula of the form A\u03c6 and a K-atom is a formula of the form K\u03c6, where \u03c6 is a propositional formula. A GK formula is called a pure GK formula if it is formed from A-atoms, K-atoms and propositional connectives. Similarly, a pure GK theory is a set of pure GK formulas. Given a pure GK formula F , we denote\nAtomK(F ) = {\u03c6 | K\u03c6 is a K-atom occurring in F }, AtomA(F ) = {\u03c6 | A\u03c6 is an A-atom occurring in F }.\nFor a pure GK theory T , we use AtomK(T ) =\u22c3 F\u2208T AtomK(F ) and AtomA(T ) = \u22c3 F\u2208T AtomA(F ) to denote their modal atoms. So far, the applications of the logic of GK only ever use pure GK formulas. We now present some embeddings of well-known nonmonotonic knowledge representation languages into the logic of GK.\nDefault logic A (propositional) default theory \u2206 = (W,D) (under extension semantics) is translated into pure GK formulas in the following way: (1) Translate each \u03c6 \u2208 W to K\u03c6; (2) translate each (\u03c6 : \u03c81, . . . , \u03c8n/\u03d5) \u2208 D to K\u03c6 \u2227 \u00acA\u00ac\u03c81 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acA\u00ac\u03c8n \u2283 K\u03d5. For the weak extension semantics, a default (\u03c6 : \u03c81, . . . , \u03c8n/\u03d5) \u2208 D is translated to A\u03c6 \u2227 \u00acA\u00ac\u03c81 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acA\u00ac\u03c8n \u2283 K\u03d5. Autoepistemic logic An L-sentence of autoepistemic logic that is in normal form [Konolige, 1988], that is, a disjunction of the form \u00acL\u03c6 \u2228 L\u03c81 \u2228 \u00b7 \u00b7 \u00b7 \u2228 L\u03c8n \u2228 \u03d5,\nis (under expansion semantics) expressed as A\u03c6 \u2227 \u00acA\u03c81 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acA\u03c8n \u2283 K\u03d5. For strong expansion semantics, it becomes K\u03c6 \u2227 \u00acA\u03c81 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acA\u03c8n \u2283 K\u03d5.\nNotice that the translation of default and autoepistemic theories into the logic of GK is compatible with Konolige\u2019s translation from default logic into autoepistemic logic [Konolige, 1988]. Indeed, Konolige\u2019s translation perfectly aligns the weak extension semantics of default logic with expansion semantics for autoepistemic logic, and likewise for extension and strong expansion semantics [Denecker, Marek, and Truszczyn\u0301ski, 2003].\nLogic of universal causation The logic of universal causation is a nonmonotonic propositional modal logic with one modality C [Turner, 1999]. A formula of this logic is translated to the pure logic of GK by replacing every occurrence of C by K, adding A before each atom which is not in the range of C in it, and adding Ap\u2228A\u00acp for each atom p. For example, if a UCL formula is (p \u2227 \u00acq) \u2283 C(p \u2227 \u00acq) and Atom = {p, q}, then the corresponding pure GK formula is ((Ap \u2227 \u00acAq) \u2283 K(p \u2227 \u00acq))\u2227(Ap\u2228A\u00acp)\u2227(Aq\u2228A\u00acq). Disjunctive logic programs A disjunctive LP rule\np1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 pk \u2190 pk+1, . . . , pl, not pl+1, . . . , not pm,\nwhere p\u2019s are atoms, corresponds to the pure GK formula:\nKpk+1\u2227\u00b7 \u00b7 \u00b7\u2227Kpl\u2227\u00acApl+1\u2227\u00b7 \u00b7 \u00b7\u2227\u00acApm \u2283 Kp1\u2228\u00b7 \u00b7 \u00b7\u2228Kpk"}, {"heading": "Main Result: From Pure GK to Disjunctive ASP", "text": "Before presenting the translation, we introduce some notations. Let F be a pure GK formula, we use trp(F ) to denote the propositional formula obtained from F by replacing each occurrence of a K-atom K\u03c6 by k\u03c6 and each occurrence of an A-atom A\u03c8 by a\u03c8 , where k\u03c6 and a\u03c8 are new atoms with respect to \u03c6 and \u03c8 respectively. For a pure GK theory T , we define trp(T ) = \u2227 F\u2208T trp(F ). To illustrate these and the definitions that follow, we use a running example.\nExample 1 (Normal Reiter default) Consider the pure GK theory {F} with F = \u00acA\u00acp \u2283 Kp corresponding to the default > : p/p, and another pure GK theory {F,G} with G = K\u00acp corresponding to the default > : >/\u00acp. Then trp({F}) = \u00aca\u00acp \u2283 kp and trp({F,G}) = (\u00aca\u00acp \u2283 kp) \u2227 k\u00acp, where a\u00acp, kp, and k\u00acp are new atoms.\nHere we introduce a set of new atoms k\u03c6 and a\u03c8 for each formula \u03c6 \u2208 AtomK(T ) and \u03c8 \u2208 AtomA(T ). Intuitively, the new atom k\u03c6 (resp. a\u03c8) will be used to encode containment of the formula \u03c6 in K(M) (resp. A(M)) of a GK model M for T .\nGiven a propositional formula \u03c6 and an atom a, we use \u03c6a to denote the propositional formula obtained from \u03c6 by replacing each occurrence of an atom p with a new atom pa with respect to a. These formulas and new atoms will later be used in our main translation to perform the minimality check of the logic of GK\u2019s semantics.\nWe now stepwise work our way towards the main result. We start out with a result that relates a pure GK theory to\na propositional formula that will later reappear in our main translation. Proposition 1 Let T be a pure GK theory. A Kripke interpretation M is a model of T if and only if there exists a model I\u2217 of the propositional formula \u03a6T where\n\u03a6T = trp(T ) \u2227 \u03a6snd \u2227 \u03a6Kwit \u2227 \u03a6Awit with \u03a6snd = \u2227\n\u03c6\u2208AtomK(T )\n(k\u03c6 \u2283 \u03c6k) \u2227 \u2227\n\u03c6\u2208AtomA(T )\n(a\u03c6 \u2283 \u03c6a)\n\u03a6Kwit = \u2227\n\u03c8\u2208AtomK(T )\n( \u00ack\u03c8 \u2283 \u03a6K\u03c8 ) \u03a6Awit =\n\u2227 \u03c8\u2208AtomA(T ) ( \u00aca\u03c8 \u2283 \u03a6A\u03c8 ) \u03a6K\u03c8 = \u00ac\u03c8k\u03c8 \u2227\n\u2227 \u03c6\u2208AtomK(T ) (k\u03c6 \u2283 \u03c6k\u03c8 )\n\u03a6A\u03c8 = \u00ac\u03c8a\u03c8 \u2227 \u2227\n\u03c6\u2208AtomA(T )\n(a\u03c6 \u2283 \u03c6a\u03c8 )\nsuch that \u2022 K(M)\u2229AtomK(T ) = {\u03c6 | \u03c6 \u2208 AtomK(T ), I\u2217 |= k\u03c6}; \u2022 A(M)\u2229AtomA(T ) = {\u03c6 | \u03c6 \u2208 AtomA(T ), I\u2217 |= a\u03c6}.\nThe proposition examines the relationship between models of a pure GK theory and particular models of the propositional formula \u03a6T . The first conjunct trp(T ) of the formula \u03a6T indicates that the k-atoms and a-atoms in it can be interpreted in accordance with K(M) and A(M) such that I\u2217 |= trp(T ) iff M is a model of T . The soundness formula \u03a6snd achieves that the sets {\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6} and {\u03c6 | \u03c6 \u2208 AtomA(T ) and I\u2217 |= a\u03c6} are consistent. The witness formulas \u03a6wit indicate that, if I\u2217 |= \u00ack\u03c8 for some \u03c8 \u2208 AtomK(T ) (resp. \u03c8 \u2208 AtomA(T )) then there exists a model I \u2032 of K(M) (resp. A(M)) such that I \u2032 |= \u00ac\u03c8, where I \u2032 is explicitly indicated by newly introduced pk\u03c8 (resp. pa\u03c8 ) atoms. So intuitively, if a formula is not known (or not assumed), then there must be a witness for that. This condition is necessary: for instance, the set {kp, kq,\u00ackp\u2227q} satisfies the formula (kp\u2227q \u2283 kp) \u2227 (kp\u2227q \u2283 kq), however, since K(M) is a theory there does not exist a Kripke interpretationM such that p \u2208 K(M), q \u2208 K(M) and p\u2227q /\u2208 K(M). Example 1 (Continued) Formula \u03a6{F} is given by:\ntrp({F}) = \u00aca\u00acp \u2283 kp \u03a6snd({F}) = (kp \u2283 pk) \u2227 (a\u00acp \u2283 \u00acpa) \u03a6Kwit({F}) = \u00ackp \u2283 (\u00acpkp \u2227 (kp \u2283 pkp)) \u03a6Awit({F}) = \u00aca\u00acp \u2283 (\u00ac\u00acpa\u00acp \u2227 (a\u00acp \u2283 \u00acpa\u00acp))\nFormula \u03a6{F,G} is given by: trp({F,G}) = (\u00aca\u00acp \u2283 kp) \u2227 k\u00acp\n\u03a6snd({F,G}) = \u03a6snd({F}) \u2227 (k\u00acp \u2283 \u00acpk) \u03a6Kwit({F,G}) = (\u00ackp \u2283 \u03a6Kp ) \u2227 (\u00ack\u00acp \u2283 \u03a6K\u00acp) \u03a6Awit({F,G}) = \u03a6Awit({F})\n\u03a6Kp = \u00acpkp \u2227 (kp \u2283 pkp) \u2227 (k\u00acp \u2283 \u00acpkp) \u03a6K\u00acp = \u00ac\u00acpk\u00acp \u2227 (kp \u2283 pk\u00acp) \u2227 (k\u00acp \u2283 \u00acpk\u00acp)\nwhere pk , pa , pkp , pa\u00acp , and pk\u00acp are new atoms. Note that formula \u03a6snd({F,G}) prevents a model that satisfies both kp and k\u00acp.\nWhile Proposition 1 aligns Krikpe models and propositional models of the translation, there is yet no mention of GK\u2019s typical minimization step. This is the task of the next result, which extends the above relationship to GK models.\nProposition 2 Let T be a pure GK theory. A Kripke interpretation M is a GK model of T if and only if there exists a model I\u2217 of the propositional formula \u03a6T such that \u2022 K(M) = A(M) = Th ( {\u03c6 | \u03c6 \u2208 AtomK(T ), I\u2217 |= k\u03c6} ); \u2022 for each \u03c8 \u2208 AtomA(T ), I\u2217 |= a\u03c8 iff \u03c8 \u2208 Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6})\n\u2022 there does not exist another model I\u2217\u2032 such that I\u2217\u2032 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} = I\u2217 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )}, I\u2217\u2032 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} ( I\u2217 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )}. Example 1 (Continued) Clearly the intended reading of our running example {F} is that there is no reason to assume that p is false, and the default lets us conclude that we know p. This is testified by the partial interpretation I\u2217 = {\u00aca\u00acp, kp, pk , pa\u00acp} (the remaining atoms are not relevant). It is easy to see that I\u2217 is a model for \u03a6{F} and there is no model I\u2217\u2032 with the properties above. Now kp \u2208 I\u2217 shows that p is known in the corresponding GK model.\nSimilarly, G provides a reason to assume that p is false and {F,G} concludes that we know \u00acp. Consider the partial interpretation I\u2217 = {a\u00acp,\u00ackp, k\u00acp,\u00acpk ,\u00acpa ,\u00acpkp}, it specifies a model for \u03a6{F,G} and there is no model I\u2217\u2032 with the properties above. In particular, k\u00acp \u2208 I\u2217 shows that \u00acp is known in the corresponding GK model.\nIn Proposition 2, we only need to consider a Kripke interpretation M such that A(M) \u222a K(M) is consistent. This means that formula \u03a6T can be modified to \u03a8T where\n\u03a8T = trp(T ) \u2227\u03a8snd \u2227\u03a8Kwit \u2227\u03a8Awit with \u03a8snd = \u2227\n\u03c6\u2208AtomK(T )\n(k\u03c6 \u2283 \u03c6) \u2227 \u2227\n\u03c6\u2208AtomA(T )\n(a\u03c6 \u2283 \u03c6)\n\u03a8Kwit = \u2227\n\u03c8\u2208AtomK(T )\n( \u00ack\u03c8 \u2283 \u03a8K\u03c8 )\n\u03a8Awit = \u2227\n\u03c8\u2208AtomA(T )\n( \u00aca\u03c8 \u2283 \u03a8A\u03c8 )\n\u03a8K\u03c8 = \u00ac\u03c8k\u03c8 \u2227 \u2227\n\u03c6\u2208AtomK(T )\n(k\u03c6 \u2283 \u03c6k\u03c8 ) \u2227\n\u2227 \u03c6\u2208AtomA(T ) (a\u03c6 \u2283 \u03c6k\u03c8 )\n\u03a8A\u03c8 = \u00ac\u03c8a\u03c8 \u2227 \u2227\n\u03c6\u2208AtomK(T )\n(k\u03c6 \u2283 \u03c6a\u03c8 ) \u2227\n\u2227 \u03c6\u2208AtomA(T ) (a\u03c6 \u2283 \u03c6a\u03c8 )\nSo the soundness formula \u03a8snd actually becomes easier, since soundness of knowledge and assumptions is enforced for one and the same vocabulary (the one from the original theory). The witness formulas become somewhat more complicated, as the witnesses have to respect both the knowledge as well as the assumptions of the theory. This is best explained by consulting our running example again.\nExample 1 (Continued) While F \u2019s propositionalization trp({F}) stays the same, the soundness and witness formulas change in the step from formula \u03a6{F} to formula \u03a8{F}. We only show the first conjunct of the witness formula \u03a8wit , which is given by\n\u00ackp \u2283 ( \u00acpkp \u2227 ( kp \u2283 pkp ) \u2227 ( a\u00acp \u2283 \u00acpkp )) Intuitively, the formula expresses that whenever p is not known, then there must be a witness, that is, an interpretation where p is false. Since the witnessing interpretations could in principle be distinct for each K-atom, they have to be indexed by the respective K-atom they refer to, as in pkp . Of course, the witnesses have to obey all that is known and assumed, which is guaranteed in the last two conjuncts.\nUsing this new formula, the result of Proposition 2 can be restated.\nProposition 3 Let T be a pure GK theory. A Kripke interpretation M is a GK model of T if and only if there exists a model I\u2217 of the propositional formula \u03a8T such that \u2022 K(M) = A(M) = Th ({\u03c6 | \u03c6 \u2208 AtomK(T ), I\u2217 |= k\u03c6}); \u2022 for each \u03c8 \u2208 AtomA(T ), we have that I\u2217 |= a\u03c8 implies\n\u03c8 \u2208 Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6})\n\u2022 there does not exist another model I\u2217\u2032 of \u03a6T such that\nI\u2217\u2032 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} = I\u2217 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} I\u2217\u2032 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} ( I\u2217 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )}\nWe are now ready for our main result, translating a pure GK theory to a disjunctive logic program. First, we introduce some notations. Let T be a pure GK theory, we use trne(T ) to denote the nested expression obtained from \u03a8T by first converting it to negation normal form2, then replacing \u201c\u2227\u201d by \u201c,\u201d and \u201c\u2228\u201d by \u201c;\u201d. A propositional formula \u03c6 can be equivalently translated to conjunctive normal form (involving at most linear blowup)\n(p1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 pt \u2228 \u00acpt+1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00acpm) \u2227 . . . \u2227 (q1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 qk \u2228 \u00acqk+1 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \u00acqn)\nwhere p\u2019s and q\u2019s are atoms; we use tr c(\u03c6) to denote the set of rules\np1; . . . ; pt \u2190 pt+1, . . . , pm . . . q1; . . . ; qk \u2190 qk+1, . . . , qn\nWe use \u03c6\u0302 to denote the propositional formula obtained from \u03c6 by replacing each occurrence of an atom p by a new atom p\u0302.\n2A propositional formula is in Negation Normal Form (NNF) if negation occurs only immediately above atoms, and {\u22a5,>,\u00ac,\u2227,\u2228} are the only allowed connectives.\nWe use T \u2217 to denote the propositional formula obtained from the formula \u03a6T by replacing each occurrence of an atom p (except atoms in {a\u03c6 | \u03c6 \u2208 AtomA(T )}) by a new atom p\u2217. Intuitively, each atom that is not an a-atom is replaced by a new atom.\nNotice that trne(T ) is obtained from \u03a8T while T \u2217 is obtained from \u03a6T . Intuitively, by Proposition 3, trne(T ) is used to restrict interpretations for introduced k-atoms and a-atoms so that these interpretations serve as candidates for GK models, and by Proposition 1, T \u2217 constructs possible models of the GK theory which are later used to test whether these models prevent the candidate to be a GK model.\nInspired by the linear translation from parallel circumscription into disjunctive logic programs by Janhunen and Oikarinen [2004], we have the following theorem. Theorem 1 Let T be a pure GK theory. A Kripke interpretation M is a GK model of T if and only if there exists an answer set S of the logic program tr lp(T ) in Figure 1 with K(M) = A(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and k\u03c6 \u2208 S}).\nThe intuition behind the construction is as follows: \u2022 (1) and (2) in tr lp(T ): I\u2217 is a model of the formula \u03a8T . \u2022 (3\u20138): if there exists a model I\u2217\u2032 of the formula \u03a6T with I\u2217 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} = I\u2217\u2032 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} I\u2217\u2032 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} ( I\u2217 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )},\nthen there exists a set S\u2217 constructed from new atoms in tr c(T \u2217) (which is a copy of the formula \u03a6T with same a\u03c6 for each \u03c6 \u2208 AtomA(T )) and c\u03c6 for some \u03c6 \u2208 AtomK(T ) such that S\u2217 satisfies rules (3) to (8) and u /\u2208 S\u2217.\n\u2022 (9) and (10): if there is such a set S\u2217 then it is the least set containing u, all p\u2217\u2019s and c-atoms.\n\u2022 (11): such a set S\u2217 should not exist. (See item 3 in Proposition 3.) \u2022 (12) and (13): if there exists a model of the formula\u2227 \u03c6\u2208AtomK(T )(k\u03c6 \u2283 \u03c6\u0302)\u2227\u00ac \u2227 \u03c6\u2208AtomA(T )(a\u03c6 \u2283 \u03c6\u0302), then\nv should not occur in the minimal model of the program. \u2022 (14): \u2227 \u03c6\u2208AtomK(T )(k\u03c6 \u2283 \u03c6\u0302)\u2227\u00ac \u2227 \u03c6\u2208AtomA(T )(a\u03c6 \u2283 \u03c6\u0302)\nshould not be consistent. (This is necessary by item 2 in Proposition 3.) Given a model S of the logic program tr lp(T ), the new atom u is used to indicate that the model I\u2217 of \u03a8T w.r.t. S (specified by (1) and (2)) satisfies item 3 in Proposition 3. Specifically, if I\u2217 does not satisfy item 3, then there exists a subset S\u2217 of p\u2217\u2019s and c-atoms that satisfies (3) to (8). If in addition u /\u2208 S\u2217, then there exists a subset of S that satisfies all rules in tr lp(T ) except (11), thus S cannot be an answer set of tr lp(T ). Similarly, v is used to indicate that I\u2217 satisfies item 2 in Proposition 3. Specifically, if I\u2217 does not satisfy item 2, then the propositional formula\u2227 \u03c6\u2208AtomK(T )(k\u03c6 \u2283 \u03c6\u0302) \u2227 \u00ac \u2227 \u03c6\u2208AtomA(T )(a\u03c6 \u2283 \u03c6\u0302) is satisfiable, thus there exists a subset S\u0302 of p\u0302\u2019s that satisfies (12). If in addition v /\u2208 S\u0302, then there exists a subset of S that satisfies all rules in tr lp(T ) except (14), thus S cannot be an answer set of tr lp(T ).\nExample 1 (Continued) For our running example theory {F} with F = \u00acA\u00acp \u2283 Kp, we find that the logic program translation tr lp({F}) has a single answer set S with kp \u2208 S Thus by Theorem 1 we can conclude that the GK theory {F} has a single GK model M in which K(M) = Th({p}). Likewise, the logic program tr lp({F,G}) has a single answer set S\u2032 with k\u00acp \u2208 S\u2032, whence {F,G} has a single GK model M \u2032 in which K(M \u2032) = Th({\u00acp}).\nComputational complexity We have seen in the preliminaries section that disjunctive logic programs can be modularly and equivalently translated into pure formulas of the logic of GK. Conversely, Theorem 1 shows that pure GK formulas can be equivalently translated into disjunctive logic programs. Eiter and Gottlob showed that the problem of deciding whether a disjunctive logic program has an answer set is \u03a3P2 -complete [Eiter and Gottlob, 1995]. In combination, these results yield the following straightforward complexity result for the satisfiability of pure GK. Proposition 4 Let T be a pure GK theory. The problem of deciding whether T has a GK model is \u03a3P2 -complete. We remark that the hardness of disjunctive logic programs stems from so-called head cycles (at least two atoms that mutually depend on each other and occur jointly in some rule head). It is straightforwardly checked that our encoding creates such head cycles, for example the head of rule (8) contains the cycle induced by rules (7) and (10)."}, {"heading": "Implementation", "text": "We have implemented the translation of Theorem 1 into a working prototype gk2dlp. The program is written in Prolog and uses the disjunctive ASP solver claspD-2 [Gebser, Kaufmann, and Schaub, 2013], which was ranked first place in the 2013 ASP competition.3\nOur prototype is the first implementation of the (pure) logic of GK to date. The restriction to pure formulas seems harmless since all known applications of the logic of GK use only pure formulas. We remark that gk2dlp implements default and autoepistemic logics such that input and target language are of the same complexity.\nEvaluation To have a scalable problem domain and inspired by dl2asp [Chen et al., 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation. An instance of the fair division problem consists of a set of agents, a set of goods, and for each agent a set of constraints that intuitively express which sets of goods the agent is willing to accept. A solution is then an assignment of goods to agents that is a partition of all goods and satisfies all agents\u2019 constraints. Bouveret and Lang [2008] showed that the problem is \u03a3P2 -complete, and can be naturally encoded in default logic.\n3http://www.mat.unical.it/ianni/storage/ aspcomp-2013-lpnmrtalk.pdf\nWe created random instances of the fair division problem with increasing numbers of agents and goods. We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.0.3 and claspD version 2 (revision 6814) to compute all answer sets of these programs, thus all extensions of the original default theory corresponding to all solutions of the problem instance. The experiments were conducted on a Lenovo laptop with an Intel Core i3 processor with 4 cores and 4GB of RAM running Ubuntu 12.04. We recorded the size of the default theory, the size of the translated logic program, the translation time and the solving time, as well as the number of solutions obtained. We started out with 2 agents and 2 goods, and stepwise increased these numbers towards 6. For each combination in (a, g) \u2208 {2, . . . , 6} \u00d7 {2, . . . , 6}, we tested 20 randomly generated instances. Random generation here means that we create agents\u2019 preferences by iteratively drawing random subsets of goods to add to an agent\u2019s acceptable subsets with probability P , where P is initialized with 1 and discounted by the factor g\u22121g for each subset that has been drawn.\nIn accordance with our theoretical predictions, we observed that the increase in size from GK formula to logic program is indeed polynomial (albeit with a low exponent). The plot on the right (Figure 2) shows the solving time in relation to the size of the default theory, where the time axis is logarithmic. We can see that the runtime behavior of gk2dlp is satisfactory. We acknowledge however that the runtimes we measured are not competitive with those reported by Chen et al. [2010] for dl2asp. However, a direct comparison of the two systems is problematic for a number of reasons. First of all, the system dl2asp is not publicly available to the best of our knowledge. Furthermore, Chen et al. [2010] do not describe how they create random instances of the fair division problem, so we cannot compare the runtimes they report and the ones we measured. Finally, dl2asp is especially engineered for default logic, and it is not clear how their approach can be generalized to other languages, for example Turner\u2019s logic of universal causation. In general, the approaches to translation that are followed by dl2asp and gk2dlp are completely different: dl2asp translates a \u03a3P2 -complete problem to an NP-complete problem using a translation in \u2206P2 . Our system gk2dlp translates a \u03a3P2 -complete problem into another \u03a3 P 2 -complete problem using a translation that can be computed in polynomial time.\nApplications We see immediate applicability of the translation of the present paper to several areas. Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device. Cadoli, Eiter, and Gottlob [1994] proposed to use default logic as an expressive query language on top of relational databases, and gave an example of achieving strategic behavior in an economic setting. In reasoning about actions, Thielscher [1996] used default logic to solve the qualification problem of dealing with unexpected action failures. Martin and Thielscher [2001] later provided an implementation of that approach where extensions are enumer-\nated in Prolog. Recently, Baumann et al. [2010] introduced a method for default reasoning in action theories, that is, an approach to the question what normally holds in a dynamic domain. Our translation yields an implementation of their approach, something that they stated as future work and later achieved to a limited extent (for a restricted sublanguage of their framework [Strass, 2012]). In a similar vein, Pagnucco et al. [2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].\nRelated work The translation presented in this paper is a generalization of the one presented for Turner\u2019s logic of universal causation by Ji and Lin [2013]. We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemela\u0308 [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz\u2019 logic of minimal belief and negation as failure [1994]. Other approaches are restricted to specific languages, where default logic seems to be most popular. The recent system dl2asp [Chen et al., 2010] translates default theories to normal (non-disjunctive) logic programs; the translation figures out all implication relations between formulas occurring in the default theory, just as Junker and Konolige [1990] did. The authors of dl2asp [Chen et al., 2010] already observed that default logic and disjunctive logic programs are of the same complexity; they even stated the search for a polynomial translation from the former to the latter (that we achieved in this paper) as future work. Gadel [Nicolas, Saubion, and Ste\u0301phan,\n2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewin\u0301ski et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics. Risch and Schwind [1994] describe a tableauxbased algorithm for computing all extensions of general default theories, but do not report runtimes for their Prologbased implementation. For autoepistemic logic, Marek and Truszczyn\u0301ski [1991] investigate sceptical reasoning with respect to Moore\u2019s expansion semantics."}, {"heading": "Discussion", "text": "We have presented the first translation of pure formulas of the logic of GK to disjunctive answer set programming. Among other things, this directly leads to implementations of Turner\u2019s logic of universal causation as well as implementations of default and autoepistemic logics under different semantics. We have prototypically implemented the translation and experimentally analysed its performance, which we found to be satisfactory given the system\u2019s generality.\nIn the future, we plan to integrate further nonmonotonic reasoning formalisms. This is more or less straightforward due to the generality of this work: to implement a language, it suffices to provide a translation into pure formulas of GK, then Theorem 1 of this paper does the rest. Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005]. It also seems worthwhile to check whether our translation can be adapted to the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994; Truszczyn\u0301ski, 2007], that has only one modality instead of two. We finally plan to study the approaches mentioned as applications in the previous section to try out our translation and implementation on agentoriented AI problems."}, {"heading": "Appendix", "text": ""}, {"heading": "Proof of Proposition 1:", "text": "\u21d2: Let M be a model of T , I1 \u2286 Lit a model of K(M), and I2 \u2286 Lit a model of A(M). Clearly, for each \u03c6 \u2208 AtomK(T ), if \u03c6 \u2208 K(M) then I1 |= \u03c6; if \u03c6 /\u2208 K(M) then there exists a model I \u2032 of K(M) such that I \u2032 |= \u00ac\u03c6. Same results are established for each \u03c6 \u2208 AtomA(T ).\nThen, we can create an interpretation I\u2217 such that\nI\u2217 = {lk | l \u2208 I1} \u222a {la | l \u2208 I2} \u222a {k\u03c6 | \u03c6 \u2208 AtomK(T ) \u2229K(M)} \u222a {a\u03c6 | \u03c6 \u2208 AtomA(T ) \u2229A(M)}\n\u222a {\u00ack\u03c6 | \u03c6 \u2208 AtomK(T ) and \u03c6 /\u2208 K(M)} \u222a {\u00aca\u03c6 | \u03c6 \u2208 AtomA(T ) and \u03c6 /\u2208 A(M)}\n\u222a \u22c3\n\u03c8\u2208AtomK(T ) \u03c8\u2208K(M)\n{lk\u03c8 | l \u2208 I1} \u222a \u22c3\n\u03c8\u2208AtomA(T ) \u03c8\u2208A(M)\n{la\u03c8 | l \u2208 I2}\n\u222a \u22c3\n\u03c8\u2208AtomK(T ) \u03c8/\u2208K(M)\n{ lk\u03c8 | l \u2208 I \u2032, I \u2032 is a model of K(M) \u222a {\u00ac\u03c8} } \u222a\n\u22c3 \u03c8\u2208AtomA(T ) \u03c8/\u2208A(M) {la\u03c8 | l \u2208 I \u2032, I \u2032 is a model of A(M) \u222a {\u00ac\u03c8}} .\nIt is easy to verify that I\u2217 is a model of \u03a6T and\n\u2022 K(M)\u2229AtomK(T ) = {\u03c6 | \u03c6 \u2208 AtomK(T ), I\u2217 |= k\u03c6}; \u2022 A(M)\u2229AtomA(T ) = {\u03c6 | \u03c6 \u2208 AtomA(T ), I\u2217 |= a\u03c6}. \u21d0: Let I\u2217 be a model of \u03a6T . We can create a Kripke interpretation M such that\n\u2022 K(M) = Th ( {\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6} ); \u2022 A(M) = Th ( {\u03c6 | \u03c6 \u2208 AtomA(T ) and I\u2217 |= a\u03c6} ).\nNote that, {l \u2208 Lit | I\u2217 |= lk} is a model of K(M) and {l \u2208 Lit | I\u2217 |= la} is a model of A(M), then both K(M) and A(M) are consistent.\nFor each \u03c6 \u2208 AtomK(T ), if I\u2217 |= k\u03c6 then \u03c6 \u2208 K(M); if I\u2217 |= \u00ack\u03c6 then there exists a model I \u2032 = {l \u2208 Lit | I\u2217 |= lk\u03c6} such that I \u2032 is a model of K(M) and I \u2032 |= \u00ac\u03c6, thus \u03c6 /\u2208 K(M). So I\u2217 |= k\u03c6 iff \u03c6 \u2208 K(M). The same result is established for each \u03c6 \u2208 AtomA(T ). Note that, I\u2217 |= trp(T ) then M is a model of T ."}, {"heading": "Proof of Proposition 2:", "text": "\u21d2: LetM be a GK model of T . From the proof of Proposition 1, we can create a model I\u2217 of \u03a6T . Now we want to prove that I\u2217 satisfies all conditions in the proposition.\nFrom Theorem 3.5 in [Lin and Shoham, 1992], K(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) \u2229 K(M)}), then K(M) = A(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}).\nAssume that there exists another model I\u2217\u2032 of \u03a6T with\nI\u2217\u2032 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} = I\u2217 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} I\u2217\u2032 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} ( I\u2217 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )}\nThen, from Proposition 1, there exists a Kripke interpretation M \u2032 such that K(M \u2032) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217\u2032 |= k\u03c6}), A(M \u2032) = A(M), and M \u2032 is a model of T . Note that, for each \u03c6 \u2208 AtomK(T ), I\u2217\u2032 |= \u00ack\u03c6 implies K(M \u2032) 6|= \u03c6, then K(M \u2032) ( K(M). From the definition of GK models, there does not exist such a model M \u2032, which conflicts to the assumption, then there does not exist such a model I\u2217\u2032.\nFrom the construction of I\u2217, for each \u03c8 \u2208 AtomA(T ), I\u2217 |= a\u03c8 iff \u03c8 \u2208 A(M). Note that, K(M) = A(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}), then I\u2217 |= a\u03c8 iff \u03c8 \u2208 Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}).\nSo I\u2217 is a model of \u03a6T which satisfies all conditions in the proposition. \u21d0: Let I\u2217 be a model of \u03a6T which satisfies corresponding conditions in the proposition. We can create a Kripke interpretation M such that K(M) = A(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}).\nFrom the third condition in the proposition, I\u2217 |= a\u03c6 iff \u03c6 \u2208 K(M) for each \u03c6 \u2208 AtomA(T ). Then A(M) \u2229 AtomA(T ) = {\u03c6 | \u03c6 \u2208 AtomA(T ) and I\u2217 |= a\u03c6}. From the proof of Proposition 1, M is a model of T and I\u2217 |= k\u03c6 (resp. I\u2217 |= a\u03c6) iff \u03c6 \u2208 K(M) for each \u03c6 \u2208 AtomK(T ) (resp. \u03c6 \u2208 AtomA(T )). Now we want to prove that M is a GK model of T .\nAssume that there exists another model M \u2032 of T such that A(M \u2032) = A(M) and K(M \u2032) ( K(M). Note that K(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}), then K(M \u2032) \u2229AtomK(T ) ( K(M) \u2229AtomK(T ).\nLet I = I\u2217 \u2229 {lk | l \u2208 Lit}, clearly, I is a model of K(M), A(M), and K(M \u2032). We can construct another model I\u2217\u2032 of \u03a6T as\nI\u2217\u2032 = {lk | l \u2208 I} \u222a {la | l \u2208 I} \u222a {k\u03c6 | \u03c6 \u2208 AtomK(T ) \u2229K(M \u2032)} \u222a {a\u03c6 | \u03c6 \u2208 AtomA(T ) \u2229A(M)}\n\u222a {\u00ack\u03c6 | \u03c6 \u2208 AtomK(T ) and \u03c6 /\u2208 K(M \u2032)} \u222a {\u00aca\u03c6 | \u03c6 \u2208 AtomA(T ) and \u03c6 /\u2208 A(M)}\n\u222a \u22c3\n\u03c8\u2208AtomK(T ) \u03c8\u2208K(M\u2032)\n{lk\u03c8 | l \u2208 I} \u222a \u22c3\n\u03c8\u2208AtomA(T ) \u03c8\u2208A(M)\n{la\u03c8 | l \u2208 I}\n\u222a \u22c3\n\u03c8\u2208AtomK(T ) \u03c8/\u2208K(M\u2032)\n{ lk\u03c8 | l \u2208 I \u2032, I \u2032 is a model of K(M \u2032) \u222a {\u00ac\u03c8} } \u222a\n\u22c3 \u03c8\u2208AtomA(T ) \u03c8/\u2208A(M) {la\u03c8 | l \u2208 I \u2032, I \u2032 is a model of A(M) \u222a {\u00ac\u03c8}} .\nFrom the proof of Proposition 1, I\u2217\u2032 is a model of \u03a6T , and\nI\u2217\u2032 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} = I\u2217 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} I\u2217\u2032 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} ( I\u2217 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )}\nThis conflicts to the second condition in the proposition, then the assumption is not valid. So there does not exist another model M \u2032 of T such that A(M \u2032) = A(M) and K(M \u2032) ( K(M), thus M is a GK model of T ."}, {"heading": "Proof of Theorem 1:", "text": "\u21d2: Let M be a GK model of T . From Proposition 3, there exists a model I\u2217 of \u03a8T such that K(M) = A(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}). We can create a set S of literals as S = I\u2217 \u222a {u, v} \u222a {p\u2217 | for each new atom p\u2217 occurring in tr c(T \u2217)} \u222a {c\u03c6 | \u03c6 \u2208 AtomK(T )} \u222a {p\u0302 | p \u2208 Atom}.\nClearly, S satisfies each rule in tr lp(T ). Now we want to prove that S is an answer set of the program.\nAssume that S is not an answer set of tr lp(T ), then there exists another set S\u2032 ( S such that S\u2032 satisfies each rule in the reduct tr lp(T )S . Note that, I\u2217 \u2286 S\u2032, u implies {p\u2217 | for each new atom p\u2217 occurring in tr c(T \u2217)} \u222a {c\u03c6 | \u03c6 \u2208 AtomK(T )} and v implies {p\u0302 | p \u2208 Atom}. Then there are only two possible cases: u /\u2208 S\u2032 or v /\u2208 S\u2032.\nCase 1: u /\u2208 S\u2032, then there exists a set\nT = S\u2032 \u2229 ( {p\u2217 | p\u2217 is a new atom occurring in tr c(T \u2217)}\n\u222a {a\u03c6 | \u03c6 \u2208 AtomA(T )} )\nsuch that T satisfies tr c(T \u2217). For each \u03c6 \u2208 AtomK(T ), \u2022 by the rule u\u2190 c\u03c6, not k\u03c6, I\u2217 |= \u00ack\u03c6 implies c\u03c6 /\u2208 S\u2032; \u2022 by the rule u\u2190 k\u2217\u03c6, not k\u03c6, I\u2217 |= \u00ack\u03c6 implies k\u2217\u03c6 /\u2208 S\u2032; \u2022 by rules u \u2190 c\u03c6, k\u2217\u03c6, not\u00ack\u03c6 and u; c\u03c6; k\u2217\u03c6 \u2190 not\u00ack\u03c6, I\u2217 |= k\u03c6 implies either c\u03c6 or k\u2217\u03c6 is in S\u2032 but not both; \u2022 by the rule u; c\u03c61 ; \u00b7 \u00b7 \u00b7 ; c\u03c6m \u2190 >, there exists c\u03c8 \u2208 S\u2032 for some \u03c8 \u2208 AtomK(T ).\nSo there exists \u03c8 \u2208 AtomK(T ) such that k\u03c8 \u2208 S\u2032, c\u03c8 \u2208 S\u2032 and k\u2217\u03c8 /\u2208 S\u2032. Then we could create an interpretation I\u2217\u2032 as\nI\u2217\u2032 = {p | p \u2208 Atom and p\u2217 \u2208 S\u2032} \u222a {\u00acp | p \u2208 Atom and p\u2217 /\u2208 S\u2032}\n\u222a {k\u03c6 | \u03c6 \u2208 AtomK(T ) and k\u2217\u03c6 \u2208 S\u2032} \u222a {\u00ack\u03c6 | \u03c6 \u2208 AtomK(T ) and k\u2217\u03c6 /\u2208 S\u2032} \u222a {a\u03c6 | \u03c6 \u2208 AtomA(T ) and a\u03c6 \u2208 S\u2032} \u222a {\u00aca\u03c6 | \u03c6 \u2208 AtomA(T ) and a\u03c6 /\u2208 S\u2032}\n\u222a \u22c3\n\u03c8\u2208AtomK(T )\n{pk\u03c8 | pk\u03c8\u2217 \u2208 S\u2032}\u222a \u22c3\n\u03c8\u2208AtomK(T )\n{\u00acpk\u03c8 | pk\u03c8\u2217 /\u2208 S\u2032}\n\u222a \u22c3\n\u03c8\u2208AtomA(T )\n{pa\u03c8 | pa\u03c8\u2217 \u2208 S\u2032}\u222a \u22c3\n\u03c8\u2208AtomA(T )\n{\u00acpa\u03c8 | pa\u03c8\u2217 /\u2208 S\u2032}.\nClearly, I\u2217\u2032 is a model of \u03a8T . From the above results, \u2022 I\u2217\u2032 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} = I\u2217 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )}, and \u2022 I\u2217\u2032 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} ( I\u2217 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )}. From Proposition 3, such I\u2217\u2032 does not exist. This conflicts to the assumption, then Case 1 is impossible.\nCase 2: v /\u2208 S\u2032, then there exists a set U = S\u2032 \u2229 ( {a\u0302 | a \u2208 Atom} \u222a {k\u03c6 | \u03c6 \u2208 AtomK(T )}\n\u222a {a\u03c6 | \u03c6 \u2208 AtomA(T )} )\nsuch that U satisfies each rule in tr c( \u2227 \u03c6\u2208AtomK(T )(k\u03c6 \u2283 \u03c6\u0302) \u2227 \u00ac \u2227 \u03c8\u2208AtomA(T )(a\u03c8 \u2283 \u03c8\u0302)).\nThen there exists \u03c8 \u2208 AtomA(T ) such that I\u2217 |= a\u03c8 and there exists an interpretation I \u2286 Lit such that I |=\u2227 \u03c6\u2208AtomK(T ),I\u2217|=k\u03c6 \u03c6 \u2227 \u00ac\u03c8, thus \u03c8 /\u2208 Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}). From Proposition 3, such \u03c8 does not exist. This conflicts to the assumption, then Case 2 is impossible. So both cases are impossible, then S\u2032 does not exist and S is an answer set of tr lp(T ). \u21d0: Let S be an answer set of tr lp(T ). We can create an interpretation I\u2217 as the intersection of S with the set of atoms occurring in \u03a8T . Clearly, I\u2217 is a model of \u03a8T .\nSimilar to the above proof: If there exists another model I\u2217\u2032 of \u03a8T such that I\u2217\u2032 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} = I\u2217 \u2229 {a\u03c6 | \u03c6 \u2208 AtomA(T )} I\u2217\u2032 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} ( I\u2217 \u2229 {k\u03c6 | \u03c6 \u2208 AtomK(T )} then there exists another set S\u2032 such that S\u2032 satisfies each rule in the reduct tr lp(T )S and u /\u2208 S\u2032, thus S\u2032 ( S. This conflicts to the precondition that S is an answer set, then such a model I\u2217\u2032 does not exist.\nIf there exists \u03c8 \u2208 AtomA(T ) such that I\u2217 |= a\u03c8 and \u03c8 /\u2208 Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and I\u2217 |= k\u03c6}), then there exists another set S\u2032 such that S\u2032 satisfies each rule in the reduct tr lp(T )S and v /\u2208 S\u2032, thus S\u2032 ( S. This conflicts to the precondition that S is an answer set, then such \u03c8 does not exist.\nFrom Proposition 3, a Kripke interpretation M such that K(M) = A(M) = Th({\u03c6 | \u03c6 \u2208 AtomK(T ) and k\u03c6 \u2208 S}) is a GK models of T ."}], "references": [{"title": "State Defaults and Ramifications in the Unifying Action Calculus", "author": ["R. Baumann", "G. Brewka", "H. Strass", "M. Thielscher", "V. Zaslawski"], "venue": "KR, 435\u2013444.", "citeRegEx": "Baumann et al\\.,? 2010", "shortCiteRegEx": "Baumann et al\\.", "year": 2010}, {"title": "Efficiency and envy-freeness in fair division of indivisible goods: Logical representation and complexity", "author": ["S. Bouveret", "J. Lang"], "venue": "JAIR 32:525\u2013564.", "citeRegEx": "Bouveret and Lang,? 2008", "shortCiteRegEx": "Bouveret and Lang", "year": 2008}, {"title": "Adding Priorities and Specificity to Default Logic", "author": ["G. Brewka"], "venue": "JELIA, 247\u2013260.", "citeRegEx": "Brewka,? 1994", "shortCiteRegEx": "Brewka", "year": 1994}, {"title": "Default logic as a query language", "author": ["M. Cadoli", "T. Eiter", "G. Gottlob"], "venue": "KR, 99\u2013108.", "citeRegEx": "Cadoli et al\\.,? 1994", "shortCiteRegEx": "Cadoli et al\\.", "year": 1994}, {"title": "dl2asp: Implementing Default Logic via Answer Set Programming", "author": ["Y. Chen", "H. Wan", "Y. Zhang", "Y. Zhou"], "venue": "JELIA, volume 6341, 104\u2013116.", "citeRegEx": "Chen et al\\.,? 2010", "shortCiteRegEx": "Chen et al\\.", "year": 2010}, {"title": "Computing with default logic", "author": ["P. Cholewi\u0144ski", "V.W. Marek", "M. Truszczy\u0144ski", "A. Mikitiuk"], "venue": "AIJ 112(1):105\u2013146.", "citeRegEx": "Cholewi\u0144ski et al\\.,? 1999", "shortCiteRegEx": "Cholewi\u0144ski et al\\.", "year": 1999}, {"title": "Expressing Preferences in Default Logic", "author": ["J.P. Delgrande", "T. Schaub"], "venue": "AIJ 123(1\u20132):41\u201387.", "citeRegEx": "Delgrande and Schaub,? 2000", "shortCiteRegEx": "Delgrande and Schaub", "year": 2000}, {"title": "Uniform Semantic Treatment of Default and Autoepistemic Logics", "author": ["M. Denecker", "V.W. Marek", "M. Truszczy\u0144ski"], "venue": "AIJ 143(1):79\u2013122.", "citeRegEx": "Denecker et al\\.,? 2003", "shortCiteRegEx": "Denecker et al\\.", "year": 2003}, {"title": "Nonmonotonic reasoning: Towards efficient calculi and implementations", "author": ["J. Dix", "U. Furbach", "I. Niemel\u00e4"], "venue": "Handbook of Automated Reasoning 2(18):1121\u20131234.", "citeRegEx": "Dix et al\\.,? 2001", "shortCiteRegEx": "Dix et al\\.", "year": 2001}, {"title": "Conflict-Driven Disjunctive Answer Set Solving", "author": ["C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. K\u00f6nig", "M. Ostrowski", "T. Schaub"], "venue": "KR, 422\u2013432.", "citeRegEx": "Drescher et al\\.,? 2008", "shortCiteRegEx": "Drescher et al\\.", "year": 2008}, {"title": "On the computational cost of disjunctive logic programming: Propositional case", "author": ["T. Eiter", "G. Gottlob"], "venue": "AMAI 15(3\u20134):289\u2013323.", "citeRegEx": "Eiter and Gottlob,? 1995", "shortCiteRegEx": "Eiter and Gottlob", "year": 1995}, {"title": "Answer sets for propositional theories", "author": ["P. Ferraris"], "venue": "LPNMR, 119\u2013131.", "citeRegEx": "Ferraris,? 2005", "shortCiteRegEx": "Ferraris", "year": 2005}, {"title": "Advanced conflictdriven disjunctive answer set solving", "author": ["M. Gebser", "B. Kaufmann", "T. Schaub"], "venue": "IJCAI.", "citeRegEx": "Gebser et al\\.,? 2013", "shortCiteRegEx": "Gebser et al\\.", "year": 2013}, {"title": "Answer Set Programming Based on Propositional Satisfiability", "author": ["E. Giunchiglia", "Y. Lierler", "M. Maratea"], "venue": "J. Autom. Reasoning 36(4):345\u2013377.", "citeRegEx": "Giunchiglia et al\\.,? 2006", "shortCiteRegEx": "Giunchiglia et al\\.", "year": 2006}, {"title": "Die formalen Regeln der intuitionistischen Logik", "author": ["A. Heyting"], "venue": "Sitzungsberichte der preu\u00dfischen Akademie der Wissenschaften, 42\u2013 65, 57\u201371, 158\u2013169. Physikalisch-mathematische Klasse.", "citeRegEx": "Heyting,? 1930", "shortCiteRegEx": "Heyting", "year": 1930}, {"title": "GnT \u2013 A Solver for Disjunctive Logic Programs", "author": ["T. Janhunen", "I. Niemel\u00e4"], "venue": "LPNMR, 331\u2013335.", "citeRegEx": "Janhunen and Niemel\u00e4,? 2004", "shortCiteRegEx": "Janhunen and Niemel\u00e4", "year": 2004}, {"title": "Capturing parallel circumscription with disjunctive logic programs", "author": ["T. Janhunen", "E. Oikarinen"], "venue": "Logics in Artificial Intelligence. 134\u2013146.", "citeRegEx": "Janhunen and Oikarinen,? 2004", "shortCiteRegEx": "Janhunen and Oikarinen", "year": 2004}, {"title": "From Turner\u2019s Logic of Universal Causation to the Logic of GK", "author": ["J. Ji", "F. Lin"], "venue": "Correct Reasoning, volume 7265, 380\u2013385.", "citeRegEx": "Ji and Lin,? 2012", "shortCiteRegEx": "Ji and Lin", "year": 2012}, {"title": "Turner\u2019s logic of universal causation, propositional logic, and logic programming", "author": ["J. Ji", "F. Lin"], "venue": "LPNMR, 401\u2013413.", "citeRegEx": "Ji and Lin,? 2013", "shortCiteRegEx": "Ji and Lin", "year": 2013}, {"title": "Computing the Extensions of Autoepistemic and Default Logics with a Truth Maintenance System", "author": ["U. Junker", "K. Konolige"], "venue": "AAAI, 278\u2013283.", "citeRegEx": "Junker and Konolige,? 1990", "shortCiteRegEx": "Junker and Konolige", "year": 1990}, {"title": "On the Relation Between Default and Autoepistemic Logic", "author": ["K. Konolige"], "venue": "AIJ 35(3):343\u2013382.", "citeRegEx": "Konolige,? 1988", "shortCiteRegEx": "Konolige", "year": 1988}, {"title": "Only-knowing: Taking it beyond autoepistemic reasoning", "author": ["G. Lakemeyer", "H.J. Levesque"], "venue": "AAAI, 633\u2013638.", "citeRegEx": "Lakemeyer and Levesque,? 2005", "shortCiteRegEx": "Lakemeyer and Levesque", "year": 2005}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic 7(3):499\u2013 562.", "citeRegEx": "Leone et al\\.,? 2006", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "Nested expressions in logic programs", "author": ["V. Lifschitz", "L.R. Tang", "H. Turner"], "venue": "AMAI 25(3-4):369\u2013389.", "citeRegEx": "Lifschitz et al\\.,? 1999", "shortCiteRegEx": "Lifschitz et al\\.", "year": 1999}, {"title": "Minimal belief and negation as failure", "author": ["V. Lifschitz"], "venue": "AIJ 70(1\u2013 2):53\u201372.", "citeRegEx": "Lifschitz,? 1994", "shortCiteRegEx": "Lifschitz", "year": 1994}, {"title": "A logic of knowledge and justified assumptions", "author": ["F. Lin", "Y. Shoham"], "venue": "AIJ 57(2-3):271\u2013289.", "citeRegEx": "Lin and Shoham,? 1992", "shortCiteRegEx": "Lin and Shoham", "year": 1992}, {"title": "From answer set logic programming to circumscription via logic of GK", "author": ["F. Lin", "Y. Zhou"], "venue": "AIJ 175(1):264\u2013277.", "citeRegEx": "Lin and Zhou,? 2011", "shortCiteRegEx": "Lin and Zhou", "year": 2011}, {"title": "Reducing strong equivalence of logic programs to entailment in classical propositional logic", "author": ["F. Lin"], "venue": "KR, 170\u2013176.", "citeRegEx": "Lin,? 2002", "shortCiteRegEx": "Lin", "year": 2002}, {"title": "Computing intersection of autoepistemic expansions", "author": ["V.W. Marek", "M. Truszczy\u0144ski"], "venue": "LPNMR, 37\u201350.", "citeRegEx": "Marek and Truszczy\u0144ski,? 1991", "shortCiteRegEx": "Marek and Truszczy\u0144ski", "year": 1991}, {"title": "Addressing the Qualification Problem in FLUX", "author": ["Y. Martin", "M. Thielscher"], "venue": "KI/\u00d6GAI, 290\u2013304.", "citeRegEx": "Martin and Thielscher,? 2001", "shortCiteRegEx": "Martin and Thielscher", "year": 2001}, {"title": "Circumscription \u2013 a form of non-monotonic reasoning", "author": ["J. McCarthy"], "venue": "AIJ 13:295\u2013323.", "citeRegEx": "McCarthy,? 1980", "shortCiteRegEx": "McCarthy", "year": 1980}, {"title": "Applications of circumscription to formalizing commonsense knowledge", "author": ["J. McCarthy"], "venue": "AIJ 28:89\u2013118.", "citeRegEx": "McCarthy,? 1986", "shortCiteRegEx": "McCarthy", "year": 1986}, {"title": "Semantical considerations on nonmonotonic logic", "author": ["R. Moore"], "venue": "AIJ 25(1):75\u201394.", "citeRegEx": "Moore,? 1985", "shortCiteRegEx": "Moore", "year": 1985}, {"title": "Gadel: a genetic algorithm to compute default logic extensions", "author": ["P. Nicolas", "F. Saubion", "I. St\u00e9phan"], "venue": "ECAI, 484\u2013490.", "citeRegEx": "Nicolas et al\\.,? 2000", "shortCiteRegEx": "Nicolas et al\\.", "year": 2000}, {"title": "A decision method for nonmonotonic reasoning based on autoepistemic reasoning", "author": ["I. Niemel\u00e4"], "venue": "J. Autom. Reasoning 14(1):3\u201342.", "citeRegEx": "Niemel\u00e4,? 1995", "shortCiteRegEx": "Niemel\u00e4", "year": 1995}, {"title": "Implementing Belief Change in the Situation Calculus and an Application", "author": ["M. Pagnucco", "D. Rajaratnam", "H. Strass", "M. Thielscher"], "venue": "LPNMR, volume 8148, 439\u2013451.", "citeRegEx": "Pagnucco et al\\.,? 2013", "shortCiteRegEx": "Pagnucco et al\\.", "year": 2013}, {"title": "A logic for default reasoning", "author": ["R. Reiter"], "venue": "AIJ 13(1-2):81\u2013132.", "citeRegEx": "Reiter,? 1980", "shortCiteRegEx": "Reiter", "year": 1980}, {"title": "A theory of diagnosis from first principles", "author": ["R. Reiter"], "venue": "AIJ 32(1):57\u201395.", "citeRegEx": "Reiter,? 1987", "shortCiteRegEx": "Reiter", "year": 1987}, {"title": "Tableaux-based characterization and theorem proving for default logic", "author": ["V. Risch", "C. Schwind"], "venue": "J. Autom. Reasoning 13(2):223\u2013 242.", "citeRegEx": "Risch and Schwind,? 1994", "shortCiteRegEx": "Risch and Schwind", "year": 1994}, {"title": "Reasoning about minimal belief and negation as failure", "author": ["R. Rosati"], "venue": "JAIR 11:277\u2013300.", "citeRegEx": "Rosati,? 1999", "shortCiteRegEx": "Rosati", "year": 1999}, {"title": "An implementation platform for queryanswering in default logics: The XRay system, its implementation and evaluation", "author": ["T. Schaub", "P. Nicolas"], "venue": "LPNMR. 441\u2013452.", "citeRegEx": "Schaub and Nicolas,? 1997", "shortCiteRegEx": "Schaub and Nicolas", "year": 1997}, {"title": "Minimal knowledge problem: A new approach", "author": ["G. Schwarz", "M. Truszczynski"], "venue": "AIJ 67(1):113\u2013141.", "citeRegEx": "Schwarz and Truszczynski,? 1994", "shortCiteRegEx": "Schwarz and Truszczynski", "year": 1994}, {"title": "The draculasp system: Default reasoning about actions and change using logic and answer set programming", "author": ["H. Strass"], "venue": "NMR.", "citeRegEx": "Strass,? 2012", "shortCiteRegEx": "Strass", "year": 2012}, {"title": "Causality and the Qualification Problem", "author": ["M. Thielscher"], "venue": "KR, 51\u201362.", "citeRegEx": "Thielscher,? 1996", "shortCiteRegEx": "Thielscher", "year": 1996}, {"title": "The modal logic S4F, the default logic, and the logic here-and-there", "author": ["M. Truszczy\u0144ski"], "venue": "AAAI, 508\u2013514.", "citeRegEx": "Truszczy\u0144ski,? 2007", "shortCiteRegEx": "Truszczy\u0144ski", "year": 2007}, {"title": "Logic of universal causation", "author": ["H. Turner"], "venue": "AIJ 113(1):87\u2013123.", "citeRegEx": "Turner,? 1999", "shortCiteRegEx": "Turner", "year": 1999}], "referenceMentions": [{"referenceID": 36, "context": "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].", "startOffset": 55, "endOffset": 69}, {"referenceID": 32, "context": "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].", "startOffset": 94, "endOffset": 107}, {"referenceID": 25, "context": "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].", "startOffset": 127, "endOffset": 149}, {"referenceID": 45, "context": "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].", "startOffset": 194, "endOffset": 208}, {"referenceID": 17, "context": "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].", "startOffset": 228, "endOffset": 246}, {"referenceID": 11, "context": "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].", "startOffset": 287, "endOffset": 303}, {"referenceID": 26, "context": "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner\u2019s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].", "startOffset": 323, "endOffset": 343}, {"referenceID": 27, "context": "Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in logic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.", "startOffset": 170, "endOffset": 201}, {"referenceID": 26, "context": "Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in logic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.", "startOffset": 170, "endOffset": 201}, {"referenceID": 25, "context": "Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in logic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.", "startOffset": 258, "endOffset": 280}, {"referenceID": 15, "context": "The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner\u2019s logic of universal causation by disjunctive ASP solvers such as GNT [Janhunen and Niemel\u00e4, 2004], cmodels [Giunchiglia, Lierler, and Maratea, 2006], DLV [Leone et al.", "startOffset": 192, "endOffset": 220}, {"referenceID": 22, "context": "The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner\u2019s logic of universal causation by disjunctive ASP solvers such as GNT [Janhunen and Niemel\u00e4, 2004], cmodels [Giunchiglia, Lierler, and Maratea, 2006], DLV [Leone et al., 2006], claspD [Drescher et al.", "startOffset": 277, "endOffset": 297}, {"referenceID": 9, "context": ", 2006], claspD [Drescher et al., 2008] and claspD-2 [Gebser, Kaufmann, and Schaub, 2013].", "startOffset": 16, "endOffset": 39}, {"referenceID": 36, "context": "To substantiate this claim, we have implemented the translation and report on some preliminary experiments that we conducted on the special case of computing extensions for Reiter\u2019s default logic [Reiter, 1980].", "startOffset": 196, "endOffset": 210}, {"referenceID": 36, "context": "Default logic [Reiter, 1980] is for making and withdrawing assumptions in the light of incomplete knowledge.", "startOffset": 14, "endOffset": 28}, {"referenceID": 36, "context": "An extension of a default theory (W,D) is \u201cinterpreted as an acceptable set of beliefs that one may hold about the incompletely specified world W \u201d [Reiter, 1980].", "startOffset": 148, "endOffset": 162}, {"referenceID": 25, "context": "The language of GK proposed by Lin and Shoham [1992] is a modal propositional language with two modal operators, K, for knowledge, and A, for assumption.", "startOffset": 31, "endOffset": 53}, {"referenceID": 20, "context": "Autoepistemic logic An L-sentence of autoepistemic logic that is in normal form [Konolige, 1988], that is, a disjunction of the form \u00acL\u03c6 \u2228 L\u03c81 \u2228 \u00b7 \u00b7 \u00b7 \u2228 L\u03c8n \u2228 \u03c6, is (under expansion semantics) expressed as A\u03c6 \u2227 \u00acA\u03c81 \u2227 \u00b7 \u00b7 \u00b7 \u2227 \u00acA\u03c8n \u2283 K\u03c6.", "startOffset": 80, "endOffset": 96}, {"referenceID": 20, "context": "Notice that the translation of default and autoepistemic theories into the logic of GK is compatible with Konolige\u2019s translation from default logic into autoepistemic logic [Konolige, 1988].", "startOffset": 173, "endOffset": 189}, {"referenceID": 45, "context": "Logic of universal causation The logic of universal causation is a nonmonotonic propositional modal logic with one modality C [Turner, 1999].", "startOffset": 126, "endOffset": 140}, {"referenceID": 16, "context": "Inspired by the linear translation from parallel circumscription into disjunctive logic programs by Janhunen and Oikarinen [2004], we have the following theorem.", "startOffset": 100, "endOffset": 130}, {"referenceID": 10, "context": "Eiter and Gottlob showed that the problem of deciding whether a disjunctive logic program has an answer set is \u03a32 -complete [Eiter and Gottlob, 1995].", "startOffset": 124, "endOffset": 149}, {"referenceID": 4, "context": "Evaluation To have a scalable problem domain and inspired by dl2asp [Chen et al., 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation.", "startOffset": 68, "endOffset": 87}, {"referenceID": 1, "context": ", 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation.", "startOffset": 44, "endOffset": 69}, {"referenceID": 1, "context": ", 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation. An instance of the fair division problem consists of a set of agents, a set of goods, and for each agent a set of constraints that intuitively express which sets of goods the agent is willing to accept. A solution is then an assignment of goods to agents that is a partition of all goods and satisfies all agents\u2019 constraints. Bouveret and Lang [2008] showed that the problem is \u03a32 -complete, and can be naturally encoded in default logic.", "startOffset": 45, "endOffset": 451}, {"referenceID": 1, "context": "We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.", "startOffset": 35, "endOffset": 60}, {"referenceID": 1, "context": "We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.0.3 and claspD version 2 (revision 6814) to compute all answer sets of these programs, thus all extensions of the original default theory corresponding to all solutions of the problem instance. The experiments were conducted on a Lenovo laptop with an Intel Core i3 processor with 4 cores and 4GB of RAM running Ubuntu 12.04. We recorded the size of the default theory, the size of the translated logic program, the translation time and the solving time, as well as the number of solutions obtained. We started out with 2 agents and 2 goods, and stepwise increased these numbers towards 6. For each combination in (a, g) \u2208 {2, . . . , 6} \u00d7 {2, . . . , 6}, we tested 20 randomly generated instances. Random generation here means that we create agents\u2019 preferences by iteratively drawing random subsets of goods to add to an agent\u2019s acceptable subsets with probability P , where P is initialized with 1 and discounted by the factor g\u22121 g for each subset that has been drawn. In accordance with our theoretical predictions, we observed that the increase in size from GK formula to logic program is indeed polynomial (albeit with a low exponent). The plot on the right (Figure 2) shows the solving time in relation to the size of the default theory, where the time axis is logarithmic. We can see that the runtime behavior of gk2dlp is satisfactory. We acknowledge however that the runtimes we measured are not competitive with those reported by Chen et al. [2010] for dl2asp.", "startOffset": 36, "endOffset": 1664}, {"referenceID": 1, "context": "We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.0.3 and claspD version 2 (revision 6814) to compute all answer sets of these programs, thus all extensions of the original default theory corresponding to all solutions of the problem instance. The experiments were conducted on a Lenovo laptop with an Intel Core i3 processor with 4 cores and 4GB of RAM running Ubuntu 12.04. We recorded the size of the default theory, the size of the translated logic program, the translation time and the solving time, as well as the number of solutions obtained. We started out with 2 agents and 2 goods, and stepwise increased these numbers towards 6. For each combination in (a, g) \u2208 {2, . . . , 6} \u00d7 {2, . . . , 6}, we tested 20 randomly generated instances. Random generation here means that we create agents\u2019 preferences by iteratively drawing random subsets of goods to add to an agent\u2019s acceptable subsets with probability P , where P is initialized with 1 and discounted by the factor g\u22121 g for each subset that has been drawn. In accordance with our theoretical predictions, we observed that the increase in size from GK formula to logic program is indeed polynomial (albeit with a low exponent). The plot on the right (Figure 2) shows the solving time in relation to the size of the default theory, where the time axis is logarithmic. We can see that the runtime behavior of gk2dlp is satisfactory. We acknowledge however that the runtimes we measured are not competitive with those reported by Chen et al. [2010] for dl2asp. However, a direct comparison of the two systems is problematic for a number of reasons. First of all, the system dl2asp is not publicly available to the best of our knowledge. Furthermore, Chen et al. [2010] do not describe how they create random instances of the fair division problem, so we cannot compare the runtimes they report and the ones we measured.", "startOffset": 36, "endOffset": 1884}, {"referenceID": 34, "context": "Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device.", "startOffset": 0, "endOffset": 14}, {"referenceID": 34, "context": "Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device. Cadoli, Eiter, and Gottlob [1994] proposed to use default logic as an expressive query language on top of relational databases, and gave an example of achieving strategic behavior in an economic setting.", "startOffset": 0, "endOffset": 172}, {"referenceID": 34, "context": "Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device. Cadoli, Eiter, and Gottlob [1994] proposed to use default logic as an expressive query language on top of relational databases, and gave an example of achieving strategic behavior in an economic setting. In reasoning about actions, Thielscher [1996] used default logic to solve the qualification problem of dealing with unexpected action failures.", "startOffset": 0, "endOffset": 388}, {"referenceID": 27, "context": "In reasoning about actions, Thielscher [1996] used default logic to solve the qualification problem of dealing with unexpected action failures. Martin and Thielscher [2001] later provided an implementation of that approach where extensions are enumer0.", "startOffset": 106, "endOffset": 173}, {"referenceID": 42, "context": "Our translation yields an implementation of their approach, something that they stated as future work and later achieved to a limited extent (for a restricted sublanguage of their framework [Strass, 2012]).", "startOffset": 190, "endOffset": 204}, {"referenceID": 2, "context": "[2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].", "startOffset": 128, "endOffset": 170}, {"referenceID": 6, "context": "[2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].", "startOffset": 128, "endOffset": 170}, {"referenceID": 0, "context": "Recently, Baumann et al. [2010] introduced a method for default reasoning in action theories, that is, an approach to the question what normally holds in a dynamic domain.", "startOffset": 10, "endOffset": 32}, {"referenceID": 0, "context": "Recently, Baumann et al. [2010] introduced a method for default reasoning in action theories, that is, an approach to the question what normally holds in a dynamic domain. Our translation yields an implementation of their approach, something that they stated as future work and later achieved to a limited extent (for a restricted sublanguage of their framework [Strass, 2012]). In a similar vein, Pagnucco et al. [2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].", "startOffset": 10, "endOffset": 421}, {"referenceID": 24, "context": "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].", "startOffset": 137, "endOffset": 154}, {"referenceID": 14, "context": "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].", "startOffset": 184, "endOffset": 199}, {"referenceID": 41, "context": "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].", "startOffset": 236, "endOffset": 268}, {"referenceID": 4, "context": "The recent system dl2asp [Chen et al., 2010] translates default theories to normal (non-disjunctive) logic programs; the translation figures out all implication relations between formulas occurring in the default theory, just as Junker and Konolige [1990] did.", "startOffset": 25, "endOffset": 44}, {"referenceID": 4, "context": "The authors of dl2asp [Chen et al., 2010] already observed that default logic and disjunctive logic programs are of the same complexity; they even stated the search for a polynomial translation from the former to the latter (that we achieved in this paper) as future work.", "startOffset": 22, "endOffset": 41}, {"referenceID": 15, "context": "Related work The translation presented in this paper is a generalization of the one presented for Turner\u2019s logic of universal causation by Ji and Lin [2013]. We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].", "startOffset": 139, "endOffset": 157}, {"referenceID": 13, "context": "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemel\u00e4 [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz\u2019 logic of minimal belief and negation as failure [1994].", "startOffset": 185, "endOffset": 491}, {"referenceID": 13, "context": "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemel\u00e4 [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz\u2019 logic of minimal belief and negation as failure [1994].", "startOffset": 185, "endOffset": 611}, {"referenceID": 13, "context": "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemel\u00e4 [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz\u2019 logic of minimal belief and negation as failure [1994].", "startOffset": 185, "endOffset": 752}, {"referenceID": 13, "context": "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemel\u00e4 [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz\u2019 logic of minimal belief and negation as failure [1994]. Other approaches are restricted to specific languages, where default logic seems to be most popular.", "startOffset": 185, "endOffset": 847}, {"referenceID": 4, "context": "The recent system dl2asp [Chen et al., 2010] translates default theories to normal (non-disjunctive) logic programs; the translation figures out all implication relations between formulas occurring in the default theory, just as Junker and Konolige [1990] did.", "startOffset": 26, "endOffset": 256}, {"referenceID": 5, "context": "2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewi\u0144ski et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics.", "startOffset": 100, "endOffset": 126}, {"referenceID": 40, "context": ", 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics.", "startOffset": 97, "endOffset": 123}, {"referenceID": 5, "context": "2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewi\u0144ski et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics. Risch and Schwind [1994] describe a tableauxbased algorithm for computing all extensions of general default theories, but do not report runtimes for their Prologbased implementation.", "startOffset": 101, "endOffset": 320}, {"referenceID": 5, "context": "2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewi\u0144ski et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics. Risch and Schwind [1994] describe a tableauxbased algorithm for computing all extensions of general default theories, but do not report runtimes for their Prologbased implementation. For autoepistemic logic, Marek and Truszczy\u0144ski [1991] investigate sceptical reasoning with respect to Moore\u2019s expansion semantics.", "startOffset": 101, "endOffset": 533}, {"referenceID": 2, "context": "Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005].", "startOffset": 76, "endOffset": 118}, {"referenceID": 6, "context": "Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005].", "startOffset": 76, "endOffset": 118}, {"referenceID": 21, "context": "Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005].", "startOffset": 149, "endOffset": 179}, {"referenceID": 41, "context": "It also seems worthwhile to check whether our translation can be adapted to the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994; Truszczy\u0144ski, 2007], that has only one modality instead of two.", "startOffset": 109, "endOffset": 161}, {"referenceID": 44, "context": "It also seems worthwhile to check whether our translation can be adapted to the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994; Truszczy\u0144ski, 2007], that has only one modality instead of two.", "startOffset": 109, "endOffset": 161}], "year": 2014, "abstractText": "The logic of knowledge and justified assumptions, also known as the logic of grounded knowledge (GK), was proposed by Lin and Shoham as a general logic for nonmonotonic reasoning. To date, it has been used to embed in it default logic (propositional case), autoepistemic logic, Turner\u2019s logic of universal causation, and general logic programming under stable model semantics. Besides showing the generality of GK as a logic for nonmonotonic reasoning, these embeddings shed light on the relationships among these other logics. In this paper, for the first time, we show how the logic of GK can be embedded into disjunctive logic programming in a polynomial but non-modular translation with new variables. The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner\u2019s logic of universal causation by disjunctive ASP solvers such as GNT, cmodels, DLV, and claspD(-2).", "creator": "LaTeX with hyperref package"}}}