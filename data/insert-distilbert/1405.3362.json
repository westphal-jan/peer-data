{"id": "1405.3362", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "14-May-2014", "title": "Grounding Bound Founded Answer Set Programs", "abstract": "to appear in database theory and practice of logic programming ( tplp )", "histories": [["v1", "Wed, 14 May 2014 05:06:55 GMT  (38kb)", "http://arxiv.org/abs/1405.3362v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["rehan abdul aziz", "geoffrey chu", "peter james stuckey"], "accepted": false, "id": "1405.3362"}, "pdf": {"name": "1405.3362.pdf", "metadata": {"source": "CRF", "title": "Grounding Bound Founded Answer Set Programs", "authors": ["Rehan Abdul Aziz", "Geoffrey Chu", "Peter J. Stuckey"], "emails": ["raziz@student.unimelb.edu.au,", "gchu@csse.unimelb.edu.au,", "pjs@csse.unimelb.edu.au"], "sections": [{"heading": null, "text": "ar X\niv :1\n40 5.\n33 62\nv1 [\ncs .A\nI] 1\nBound Founded Answer Set Programming (BFASP) is an extension of Answer Set Programming (ASP) that extends stable model semantics to numeric variables. While the theory of BFASP is defined on ground rules, in practice BFASP programs are written as complex non-ground expressions. Flattening of BFASP is a technique used to simplify arbitrary expressions of the language to a small and well defined set of primitive expressions. In this paper, we first show how we can flatten arbitrary BFASP rule expressions, to give equivalent BFASP programs. Next, we extend the bottom-up grounding technique and magic set transformation used by ASP to BFASP programs. Our implementation shows that for BFASP problems, these techniques can significantly reduce the ground program size, and improve subsequent solving.\nKEYWORDS: Answer Set Programming, Grounding, Flattening, Constraint ASP, Magic Sets"}, {"heading": "1 Introduction", "text": "Many problems in the areas of planning or reasoning can be efficiently expressed using Answer Set Programming (ASP) (Baral 2003). ASP enforces stable model semantics (Gelfond and Lifschitz 1988) on the program, which disallows solutions representing circular reasoning. For example, given only rules b \u2190 a and a \u2190 b, the assignment a = true, b = true would be a solution under the logical semantics normally used by Boolean Satisfiability (SAT) (Mitchell 2005) solvers or Constraint Programming (CP) (Marriott and Stuckey 1998) solvers, but would not be a solution under the stable model semantics used by ASP solvers.\nBound Founded Answer Set Programming (BFASP) (Aziz et al. 2013) is an extension of ASP to allow founded integer and real variables. This makes it possible to concisely express and efficiently solve problems involving inductive definitions of numeric variables where we want to disallow circular reasoning. As an example consider the Road Construction problem (RoadCon). We wish to decide which roads to build such that the shortest paths between various cities are acceptable, with the minimal total cost. This can be modeled as:\n\u2217 NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence program.\nminimize \u2211\ne\u2208Edge built [e]\u00d7 cost [e]\n\u2200y \u2208 Node : sp[y, y] \u2264 0 \u2200y \u2208 Node, e \u2208 Edge : sp[from [e], y] \u2264 len[e] + sp[to[e], y]\u2190 built [e]\n\u2200y \u2208 Node, e \u2208 Edge : sp[to[e], y] \u2264 len [e] + sp[from[e], y]\u2190 built [e]\n\u2200p \u2208 Demand : sp[d from[p], d to[p]] \u2264 demand [p]\nThe decisions are which edges e are built (built [e]). The aim is to minimize the total cost of the edges cost [e] built. The first rule is a base case that says that shortest path from a node to itself is 0. The second constraint defines the shortest path sp[x, y] from x to y: the path from x to y is no longer than from x to z along edge e if it is built plus the shortest path from z to y; and the third constraint is similar for the other direction of the edge. The last constraint ensures that the shortest path for each of a given set of paths p \u2208 Demand is no longer than its maximal allowed distance demand [p]. The above model has a trivial solution with cost 0 by setting sp[x, y] = 0 for all x, y. In order to avoid this, we require that the sp variables are (upper-bound) founded variables, that is they take the largest possible justified value. The first three constraints are actually rules which justify upper bounds on sp, the last constraint is a restriction that needs to be met and cannot be used to justify upper bounds. Solving such a BFASP is challenging, mapping to CP models leads to inefficient solving, and hence we need a BFASP solver which can reason directly about unfounded sets (Van Gelder et al. 1988) of numeric assumptions. Note that Constraint ASP (CASP) and hybrid systems such as those given by (Mellarkod et al. 2008; Gebser et al. 2009; Drescher and Walsh 2012; Liu et al. 2012; Balduccini 2009; Aziz et al. 2013a) cannot solve the above problem without grounding the numeric domain to propositional variables and running into the grounding bottleneck. BFASP has been shown to subsume CP, ASP, CASP and Fuzzy ASP (Nieuwenborgh et al. 2006; Blondeel et al. 2013), see (Aziz et al. 2013) for details.\nThe above encoding for Road Construction problem is a non-ground BFASP since it is parametric in the data: Node , Edge , Demand , cost , from , to, len , d from , d to and demand . In this paper we consider how to efficiently create a ground BFASP from a non-ground BFASP given the data. This is analogous to flattening (Stuckey and Tack 2013) of constraint models and grounding (Syrjanen 2009; Gebser et al. 2007; Perri et al. 2007) of ASP programs. The contributions of this paper are: a flattening algorithm that transforms complex expressions to primitive forms while preserving the stable model semantics, a generalization of bottom-up grounding for normal logic programs to BFASPs and a generalization of the magic set transformation (Bancilhon et al. 1985; Beeri and Ramakrishnan 1991) for normal logic programs to BFASPs."}, {"heading": "2 Preliminaries", "text": ""}, {"heading": "2.1 Constraints and Answer Set Programming", "text": "We consider three types of variables: integer, real, and Boolean. Let V be a set of variables. A domain D maps each variable x \u2208 V to a set of constant values D(x). A valuation (or assignment) \u03b8 over variables vars(\u03b8) \u2286 V maps each variable x \u2208 vars(\u03b8) to a value \u03b8(x). A restriction of assignment \u03b8 to variables V , \u03b8|V , is the the assignment \u03b8\u2032 over V \u2229 vars(\u03b8) where \u03b8\u2032(v) = \u03b8(v). A constraint c is a set of assignments over the variables vars(c), representing the solutions of the constraint. A constraint c is monotonically increasing (resp. decreasing) w.r.t. a variable y \u2208 vars(c) if for all solutions \u03b8 that satisfy c, increasing (resp. decreasing) the value of y also creates a solution, that is \u03b8\u2032 where \u03b8\u2032(y) > \u03b8(y) (resp. \u03b8\u2032(y) < \u03b8(y)), and\n\u03b8\u2032(x) = \u03b8(x), x \u2208 vars(c)\u2212 {y}, is also a solution of c. A constraint program (CP) is a collection of variables V and constraints C on those variables (vars(c) \u2286 V , c \u2208 C). A positive-CP P is a CP where each constraint is increasing in exactly one variable and decreasing in the rest. The minimal solution of a positive-CP is an assignment \u03b8 that satisfies P s.t. there is no other assignment \u03b8\u2032 that also satisfies P and there exists a variable v for which \u03b8\u2032(v) < \u03b8(v). Note that for Booleans, true > false . A positive-CP P always has a unique minimal solution. If we have bounds consistent propagators for all the constraints in the program, then this unique minimal solution can be found simply by performing bounds propagation on all constraints until a fixed point is reached, and then setting all variables to their lowest values.\nA normal logic program P is a collection of rules of the form: b0 \u2190 b1 \u2227 . . . \u2227 bn \u2227 \u00acb\u20321 \u2227 . . . \u2227 \u00acb\u2032m where {b0, b1, . . . , bn, b \u2032 1, . . . , b \u2032 m} are Boolean variables. b0 is the head of the rule while the RHS of the reverse implication is the body of the rule. A rule without any negative literals is a positive rule. A positive program is a collection of positive rules. The least model of a positive program is an assignment \u03b8 that assigns true to the minimum number of variables. The reduct of P w.r.t. an assignment \u03b8 is written P \u03b8 and is a positive program obtained by transforming each rule r of P as follows: if there exists an i for which \u03b8(b\u2032i) = true, discard the rule, otherwise, discard all negative literals {b\u20321, . . . , b \u2032 m} from the rule. The stable models of P are all assignments \u03b8 for which the least model of P \u03b8 is equal to \u03b8. Note that if we consider a logic program as a constraint program, then a positive program is a positive-CP and the least model of that program is equivalent to the minimal solution defined above."}, {"heading": "2.2 Bound Founded Answer Set Programs (BFASP)", "text": "BFASP is an extension of ASP that extends its semantics over integer and real variables. In BFASP, the set of variables is a union of two disjoint sets: standard S and founded variables F .1 A rule r is a pair (c, y) where c is a constraint, y \u2208 F is the head of the rule and it is increasing in c. A bound founded answer set program (BFASP) P is a tuple (S,F , C,R) where C and R are sets of constraints and rules respectively (also accessed as constraints(P ) and rules(P ) resp.). Given a variable y \u2208 F , rules(y) is the set of rules with y as their heads. Each standard variable s is associated with a lower and an upper bound, written lb(s) and ub(s) respectively.\nThe reduct of a BFASP P w.r.t. an assignment \u03b8 is a positive-CP made from each rule r = (c, y) by replacing in c every variable x \u2208 vars(c) \u2212 {y} s.t. x is a standard variable or c is not decreasing in x, by its value \u03b8(x) to create a positive-CP constraint c\u2032. Let r\u03b8 denote this constraint. If r\u03b8 is not a tautology, it is included in the reduct P \u03b8 . An assignment \u03b8 is a stable solution of P iff i) it satisfies all the constraints in P and ii) it is the minimal solution that satisfies P \u03b8. For a variable y \u2208 F , the unconditionally justified bound of y, written ujb(y), is a value that is unconditionally justified by the rules of the program regardless of what the standard variables are fixed to. E.g. if we have a rule: (y \u2265 3 + x, y) where x is a standard variable with domain [0, 10], then we can set ujb(y) = 3. For any Boolean, we assume that ujb is fixed to false .\nExample 1 Consider a BFASP with standard variable s, integer founded variables a, b, Boolean founded variables x and y, and the rules: (a \u2265 0, a), (b \u2265 0, b), (a \u2265 b + s, a), (b \u2265 8 \u2190 x, b),\n1 For the rest of this paper we only consider lower bound founded variables, analogous to founded Booleans. Upper bound founded variables can be implemented as negated lower bound founded variables, e.g. replace sp[x, y] in the Road Construction example by \u2212nsp[x, y] where nsp[x, y] is lower bound founded.\n(x \u2190 \u00acy \u2227 (a \u2265 5), x). Consider an assignment \u03b8 s.t. \u03b8(x) = true, \u03b8(y) = false , \u03b8(b) = 8, \u03b8(s) = 9 and \u03b8(a) = 17. The reduct of \u03b8 is the positive-CP: a \u2265 0, b \u2265 0, a \u2265 b+9, b \u2265 8\u2190 x, x \u2190 a \u2265 5. The minimal solution that satisfies the reduct is equal to \u03b8, therefore, \u03b8 is a stable solution of the program. Consider another assignment \u03b8\u2032 where all values are the same as in \u03b8, but \u03b8\u2032(s) = 3. Then, P \u03b8 \u2032\nis the positive-CP: a \u2265 0, b \u2265 0, a \u2265 b + 3, b \u2265 8 \u2190 x, x \u2190 a \u2265 5. The minimal solution that satisfies this positive-CP is M where M(a) = 3, M(b) = 0, M(x) = M(y) = false . Therefore, \u03b8\u2032 is not a stable solution of the program.\nThe focus of this paper is BFASPs where every rule is written in the form (y \u2265 f(x1, . . . , xn), y). Recall that we consider the domains of Boolean variables to be ordered such that true > false . So for example, an ASP rule such as a\u2190 b\u2227 c can equivalently be written as: a \u2265 f(b, c) where f is a Boolean that returns the value of b \u2227 c. f(x1, . . . , xn) is essentially an expression tree where the leaf nodes are the variables x1, . . . , xn.\nExample 2 The function f(x1, . . . , x5) = x1+min(x2, x3\u2212x4)\u2212 (x5)2 can be described by the tree given below.\nsum\n\u2767\u2767 \u2767\u2767 \u2767\u2767\n\u276f\u276f \u276f\u276f\n\u276f\u276f \u276f\u276f\nx1 min\n\u2660\u2660 \u2660\u2660 \u2660\u2660\n\u2212\nx2 sum\n\u2660\u2660 \u2660\u2660 \u2660\u2660\nproduct\n\u2759\u2759 \u2759\u2759\n\u2759\u2759\nx3 \u2212 x5 x5\nx4\nThe local dependency graph for a BFASP P is defined over founded variables. For each rule r = (y \u2265 f(x1, . . . , xn), y), there is an edge from y to all founded xi. Each edge is marked increasing, decreasing, or non-monotonic, depending on whether f is increasing, decreasing, or non-monotonic in xi. A BFASP is locally valid iff no edge within an SCC is marked nonmonotonic. A program is locally stratified if all the edges between any two nodes in the same component are marked increasing. For example, if x and y are in the same SCC, then y \u2265 sin(x1) where x1 has initial domain (\u2212\u221e,\u221e) is not locally valid since the sin function is not monotonic over this domain, but y \u2265 sin(x1) where x1 has initial domain [0, \u03c0/2] is valid."}, {"heading": "2.3 Non-ground BFASPs", "text": "A non-ground BFASP is a BFASP where sets of variables are grouped together in variable arrays, and sets of ground rules are represented by non-ground rules via universal quantification over index variables. For example, if we have arrays of variables a, b, c, then we can represent the ground rules: (a[1] \u2265 b[1] + c[1], a[1]), (a[2] \u2265 b[2] + c[2], a[2]), (a[3] \u2265 b[3] + c[3], a[3]) by \u2200i \u2208 [1, 3] : (a[i] \u2265 b[i]+c[i], a[i]). Variables can be grouped together in arrays of any dimension and non-ground BFASP rules have the following form: \u2200i\u0304 \u2208 D\u0304 where con(\u0304i) : (y[l0(\u0304i)] \u2265 f(x1[l1(\u0304i)], . . . , xn[ln(\u0304i)]), y[l0(\u0304i)]), where i\u0304 is a set of index variables i1, . . . , im, D\u0304 is a set of domains D1, . . . , Dm, con is a constraint over the index variables which constrains these variables, l0, . . . , ln are functions over the index variables which return a tuple of array indices, y, x1, . . . , xn are arrays of variables and f is a function over the xi variables. Let gen(r) \u2261 i\u0304 \u2208 D\u0304 \u2227 con(\u0304i) denote the generator constraint for a non-ground rule r. Note that we require the generator constraint in each rule to constrain the index variables so that f is always defined.\nVariable arrays can contain either founded variables, standard variables, or parameters (which can simply be considered fixed standard variables), although all variables in a variable array must be of the same type. Note that the array names in our notation correspond to predicate names in standard ASP syntax, and our index variables correspond to ASP \u201clocal variables.\u201d Given a nonground rule r, let grnd(r) be the set of ground rules obtained by substituting all possible values of the index variables that satisfy gen(r) into the quantified expression. Similarly given a nonground BFASP P , let grnd(P ) be the grounded BFASP that contains the grounding of all its rules and constraints. The predicate dependency graph, validity and stratification are defined similarly for array variables and non-ground rules as the local dependency graph, local validity and local stratification respectively are defined for ground variables and ground rules. All our subsequent discussion is restricted to valid BFASPs."}, {"heading": "3 Flattening", "text": "A ground BFASP may contain constraints and rules whose expressions are not flat, i.e., they are expression trees with height greater than one. Such expressions are not supported by constraint solvers and we need to flatten these expressions to primitive forms. We omit consideration of flattening constraints since this is the same as in standard CP (Stuckey and Tack 2013). Consider the expression tree in Example 2, if it were a constraint, we would introduce variables i1, . . . , i5 to decompose the given function into the following set of equalities: f = x1 + i1 + i2, i1 = min(x2, i3), i3 = x3 + i4, i4 = \u2212x4, i2 = \u2212i5, i5 = x5 \u00d7 x5. It can be shown that the standard CP flattening approach in which a subexpression is replaced with a standard variable and a constraint is added that equates the introduced variable with the subexpression, does not preserve stable model semantics.\nExample 3 Consider a BFASP with rules: (x1 \u2265 max(x2, x3)\u22122, x1), (x2 \u2265 x1+1, x2), (x3 \u2265 x1+2, x3), (x1 \u2265 3, x1) where x1, x2, x3 are all founded variables. The only stable solution of this program is x1 = 3, x2 = 4, x3 = 5. Suppose we introduced a standard variable i1 to represent the subexpressionmax(x2, x3), so that the first rule in the program is replaced by: (x1 \u2265 i1\u22122, x1) and i1 = max(x2, x3). Now, due to the introduction of the standard variable i1, the new program has many new spurious stable solutions such as i1 = 6, x1 = 4, x2 = 5, x3 = 6.\nTo preserve the stable model semantics, it is necessary to use introduced founded variables to represent subexpressions containing founded variables. We now describe the central result used in our flattening algorithm.\nTheorem 1 Let P be a BFASP containing a rule r = (y \u2265 f1(x1, . . . , xk, f2(xk+1, . . . , xn)), y) where f1 is increasing in the argument where f2 appears, and where if a variable occurs among both x1, . . . , xk and xk+1, . . . , xn, then f1 and f2 have the same monotonicity w.r.t. it. Let P \u2032 be P with r replaced by the two rules: r1 = (y \u2265 f1(x1, . . . , xk, y\u2032), y) and r2 = (y\u2032 \u2265 f2(xk+1, . . . , xn), y\u2032) where y\u2032 is an introduced founded variable. Then the stable solutions of P \u2032 restricted to the variables of P are equivalent to the stable solutions of P .\nAs a corollary, if f1 is decreasing in the argument where f2 appears, we can replace f2 by a founded variable \u2212y\u2032 and add the rule (y\u2032 \u2265 \u2212f2(xk, . . . , xn), y\u2032) instead. Not all valid rule forms are supported by Theorem 1, because we require that multiple occurrences of the same\nflat(P ) Pflat := \u2205 R := rules(P ) T := constraints(P ) for(r \u2208 R)\nR := R \\ {r} flatRule(r, R, T ) r := simplify(r) Pflat \u222a={r}\nfor(c \u2208 T ) Pflat \u222a= cp flat(c) return Pflat\nflatRule(r = (y \u2265 f(e1, . . . , en), y),R, T ) for(each non-terminal ei)\nif(ei does not contain founded vars) replace ei with standard var y\n\u2032 in r T \u222a={y\u2032 = ei}\nelif(f is increasing in ei) replace ei with founded var y\n\u2032 in r R\u222a={(y\u2032 \u2265 ei, y\n\u2032)} elif(f is decreasing in ei)\nreplace ei with founded var \u2212y \u2032 in r R\u222a={(y\u2032 \u2265 \u2212ei, y \u2032)}\nvariable in the expression must have the same monotonicity w.r.t. the root expression. Note that if a subexpression does not contain any founded variables at all, i.e., only contains standard variables, parameters or constants, then a standard CP flattening step is sufficient. Let us now describe our flattening algorithm flat for ground BFASPs and later extend it to non-ground BFASPs. We put all the rules and constraints of the program in sets R and T respectively. For every rule r = (y \u2265 f(e1, . . . , en), y) \u2208 R, where f is the top level function in that rule, and e1, . . . , en are the expressions which form f \u2019s arguments, we call flatRule which works as follows. If there is some ei which is not a terminal, i.e., not a constant, parameter or variable, then we have two cases. If ei does not contain any founded variables, we simply replace it with standard variable y\u2032 and add the constraint y\u2032 = ei to T . Otherwise, we apply the transformation described in Theorem 1. After flatRule, we simplify r as much as possible through the subroutine simplify, e.g., by getting rid of double negations, pushing negations inside the expressions as much as possible etc. Finally, we flatten all the constraints in T using the standard CP flattening algorithm cp flat as described in (Stuckey and Tack 2013). Since we replace all decreasing subexpressions by negated introduced variables and simplify expressions by pushing negations towards the variables, we handle negation through simple rule forms like (y \u2265 \u2212x, y), (y \u2265 1x , y), (y \u2265 \u00acx, y) etc.\nExample 4 Consider the rule: (y \u2265 x1 + min(x2, x3 \u2212 x4) \u2212 (x5)2, y) where x1, x2, x5 are founded and x3, x4 are standard variables. Using our flattening algorithm, we can break the rule into: (y \u2265 x1 + i1 + i2, y), (i1 \u2265 min(x2, x3 \u2212 x4), i1), (i2 \u2265 \u2212(x5)2, i2) where i1, i2 are founded variables. The rule (i1 \u2265 min(x2, x3\u2212x4), i1) is further flattened to (i1 \u2265 min(x2, i3), i1) and a constraint i3 = x3 \u2212 x4 where i3 is a standard variable.\nThe algorithm can be extended to non-ground rules by defining the index set of the introduced variables to be equal to the domain of index variables as given in the generator of the rule in which they replace an expression. Moreover, the generator expression of an intermediate rule stays the same as that of the original rule from which it is derived."}, {"heading": "4 Grounding", "text": "ASP grounders keep track of variables that have been created and instantiate further rules based on that. For example, if the variables b and c have been created, then the rule a\u2190 b\u2227 c justifies a bound on a and therefore, must be included in the final program. The justification of all positive literals in a rule potentially justify its head. However, for a rule, if any one positive variable in its body does not have any rule supporting it, then that rule can safely be ignored until a justification for that variable has been found. In case a justification is never found for that variable, then the rule is useless, i.e., excluding the rule from the program does not change its stable solutions.\nWe propose a simple grounding algorithm for non-ground BFASPs which can be implemented by simply maintaining a set of ground rules and variables as done in ASP grounders, but which may generate useless rules in addition to all the useful ones. The idea is that for each variable v, we only keep track of whether v can potentially be justified above its ujb value, rather than keeping track of whether it can be justified above each value in its domain. If it can be justified above its ujb, then when v appears in the body of a rule, we assume that v can be justified to any possible bound for the purpose of calculating what bound can be justified on the head. This clearly over-estimates the bounds which can be justified on the variables, and thus the algorithm generates all the useful rules and possibly some useless ones.\nWe refer to a variable x as being created, written cr(x), if it can go above its ujb value. More formally, cr(x) is a founded Boolean with a rule: cr(x) \u2190 x > ujb(x). While that is how we define cr(x), we do not explicitly have a variable cr(x) or the above rule in our implementation. Instead, we implement it by maintaining a set Q of variables that have been created. Initially, Q is empty. We recursively look at each non-ground rule to see if the newly created variables make it possible for more head variables to be justified above their ujb values. If so, we create those variables and add them to Q. In order to do this, we need to find necessary conditions under which the head variable can be justified above its ujb. In order to simplify the presentation, we are going to define ujb for constants, standard variables and parameters as well. For a constant x, we define ujb(x) to be the value of x. For parameters and standard variables x, we define ujb(x) = ub(x).2 Note that for soundness, the ujb values of founded variables only have to be correct (e.g. \u2212\u221e for all variables) although tighter ujb values can improve the efficiency of our algorithm. Table 1 gives a non-exhaustive list of necessary conditions for the head variable to be justified above its ujb value for different rule forms.\nLet us now make a few observations about the conditions given in Table 1. A key point is that for many rule forms \u03c6r can evaluate to true, even without any variable in the body getting created. All such rules that evaluate to true give us a starting point for initializing Q in our implementation. The linear case (sum) deserves some explanation. It is made up of two disjuncts, the first of which is an evaluation of the initial condition, i.e., whether the sum of ujb values of all variables is greater than the ujb of the head. If this condition is true, then the rule needs to be grounded unconditionally. If this is false, then the second disjunct becomes important. The second disjunct itself is a conjunction of two more conditions. The first one says that all variables must be greater than \u2212\u221e in order for the rule to justify a finite value on the head. In\n2 Upper and lower bounds for a parametric array can be established by simply parsing the array.\ncreateCPs(P )\nfor(r \u2208 rules(P ) : \u03c6r = n\u2227\ni=1\ncr(xi[l\u0304i]))\ncp[r] := true % new constraint program cp[r] := cp[r] \u2227 gen(r) for(i \u2208 1 . . . n)\nset[r, i] := \u2205 cp[r] := cp[r] \u2227 l\u0304i \u2208\u226aset[r, i]\u226b\nfor(r \u2208 rules(P ) : \u03c6r = n\u2228\ni=1\ncr(xi[l\u0304i]))\nfor(i \u2208 1 . . . n) cp[r, i] := true % new constraint program cp[r, i] := cp[r, i] \u2227 gen(r) set[r, i] := \u2205 cp[r, i] := cp[r, i] \u2227 l\u0304i \u2208\u226aset[r, i]\u226b\nground(P ) C := {groundAll(c) : c \u2208 constraints(P )} R\u2032 := {groundAll(r) : r \u2208 rules(P ) : \u03c6r = true} while(R\u2032 6= \u2205)\nH := heads(R\u2032) Q\u222a=H R\u2032 := \u2205 for(r \u2208 rules(P ) : H \u2229 vars(\u03c6r) 6= \u2205)\nif(\u03c6r = n\u2227\ni=1\ncr(xi[l\u0304i]) \u2228 \u03c6r = n\u2228\ni=1\ncr(xi[l\u0304i]))\nfor(i \u2208 1 . . . n) dom := {m\u0304 | x[m\u0304] \u2208 Q} set[r, i] := dom \\ set[r, i] if(\u03c6r is conj) R\u2032 \u222a= search(cp[r]) \\ R if(\u03c6r is disj) R\u2032 \u222a= search(cp[r,i]) \\ R R\u222a=R\u2032\nset[r, i] := dom for(y \u2208 vars(R) \u2229 F ) R\u222a=(y \u2265 ujb(y), y)\nthe case where all variables already have a finite ujb, the second conjunct says that at least one of them must be created for the rule to be grounded (given the initial condition failed) . Finally, observe that after plugging all values of ujb, all conditions given in the table simplify to one of the following four forms: true, false , \u2228icr(xi) or \u2227icr(xi). Note that the grounding conditions are significantly more sophisticated than the simple conjunctive condition for normal rules. More specifically, after simplification, we can get a disjunctive condition which has no analog in ASP.\nExample 5 Consider a BFASP with the following two non-ground rules:\u2200i \u2208 [1, 10] : a[i] \u2265 b[i] + x[i] and \u2200i \u2208 [1, 10] : x[i] \u2265 min(c[i], d[i]). Say ujb(a) = 5, ujb(b) = 2, ujb(c) = 7, ujb(d) = 1 and ujb(x) = 1. For the first rule, the initial condition evaluates to false. Moreover, since both b and x have ujb greater than \u2212\u221e, we get cr(b[i]) \u2228 cr(x[i]). For the second rule, since ujb(c[i]) > ujb(x[i]) and ujb(d[i]) is not greater than ujb(x[i]), we get the condition: cr(d[i]).\nWe are now ready to present the main bottom-up grounding algorithm. Logically, our grounding algorithm starts with ujb(x) for all x, adds (x \u2265 ujb(x), x) to the program and then finds all the ground rules that are not made redundant by these rules. createCPs is a preprocessing step that creates constraint programs for rules in a BFASP P whose conditions are either conjunctions or disjunctions. For a rule with a conjunctive condition, it only creates one program, while for one with a disjunctive condition, it creates one constraint program for each variable in the condition. Each program is initialized with the gen(r) which defines the variables and some initial constraints given in the where clause in the generator of non-ground rule. Furthermore, for each array literal in \u03c6r, a constraint is posted on its literal (which is a function of index variables in the rule), to be in the domain given by the current value of the set variable (the reason for the Quine quotes) which is initially set to empty. ground is called after preprocessing. Q and R are sets of ground variables and rules respectively. groundAll is a function that grounds a non-ground rule or constraint completely, and returns the set of all rules and constraints respectively. Initially, we ground all constraints in P and rules for which \u03c6r evaluates to true. R\u2032 is a temporary variable that represents the set of new ground rules from the last iteration. In each iteration, we only look for non-ground rules that have some variable in their conditions that is created in the previous iteration. heads takes a set of ground rules as its input and returns their heads. In each iteration, through Q, we manipulate the set constraint to get new rule instantiations. For each variable in the clause, we make set equal to the new index values created for that variable. For both the conjunctive and the disjunctive case, this optimization only tries out new values of recently created variables to instantiate new rules. search takes a constraint program as its input, finds all its solutions, instantiates the non-ground rule for each solution, and returns the set of these ground\nrules. After creating new rules due to the new values in set , we make it equal to all values of the variable in Q. The fixed point calculation stops when no new rules are created. Finally, for every founded variable y, we add (y \u2265 ujb(y), y) as a rule so that if the ujb relied on some rules that were ignored during grounding, then this ensures that ujb(y) is always justified."}, {"heading": "5 Magic set transformation", "text": "Let us first define the query of a BFASP. To build the query Q for a BFASP P , we ground all its constraints and its objective function, and put all the variables that appear in them in Q.3 Note that our query does not have any free variables and only contains ground variables. Therefore, we do not need adornment strings to propagate binding information as in the original magic set technique. The original magic set technique has three stages: adorn, generate and modify. For the reason described above, we only describe the latter two.\nThe purpose of the magic set technique is to simulate a top-down computation through bottomup grounding. For every variable a in the original program, we create a magic variable m a that represents whether we care about a. Additionally, there are magic rules that specify when a magic variable should be created. Consider a simple rule (a \u2265 b + c, a) where ujb of all variables is equal to \u2212\u221e. Suppose we are interested in computing a, we model this by setting m a to true. Since b is required to compute the value of a, we add a magic rule m b \u2190 m a. We do not care about c until a finite bound on b is justified (until b is created), so we generate a tighter magic rule for c: m c\u2190 m a \u2227 cr(b).\nWe can utilize the necessary conditions for a useful grounding of a rule r as given by \u03c6r. Recall that after evaluating the initial conditions, \u03c6r reduces to true, false, a conjunction or a disjunction. The above generation of magic rules for the rule (a \u2265 b + c, a) is an example of the conjunctive case. For a disjunction, the magic rules are even simpler. For every cr(x) in the disjunction, we create the magic rule m x \u2190 m a. Note that not all variables in the original rule appear in the condition; some might get removed in the simplification or not be included in the original condition at all. We can ignore them for grounding, but we are interested in their values as soon as we know that the rule can be useful. Therefore, as soon as the magic variable for the head is created, and \u03c6r is satisfied, we are interested in all the variables in the rule that do not appear in \u03c6r. Finally, we define the modification step for a rule r = (y \u2265 f(x\u0304), y), written modify(r), as changing it to r = (y \u2265 f(x\u0304)\u2190 my, y). The pseudo-code for generation of magic rules and modification of the original rule is given as the function magic that takes a rule as its input. It adds magic rules for a rule to a set P . The first two if conditions handle the disjunctive and conjunctive case respectively. The for loop that follows generates magic rules for variables that are not in \u03c6r.\nThe entire bottom-up calculation with magic sets is as follows. First, create magic variables for all the variables in the program and call magic for every rule in the program. If the magic rules generated and/or the original rule after modification are not primitive expressions, flatten them. Then, call ground on the resulting program. While grounding the constraints, build the query by including m v in Q for every ground variable v that is in some ground constraint. After grounding, filter all the magic variables from Q, and magic rules from R.\n3 Technically if the problem has output variables, whose value will be printed, they too need to be added to Q.\nmagic(r) a := head(r)\nif(\u03c6r = n\u2228\ni=1\ncr(xi))\nfor(i \u2208 1 . . . n) P \u222a= gen(r) : (m xi \u2190 m a,m xi)\nif(\u03c6r = n\u2227\ni=1\ncr(xi))\nfor(i \u2208 1 . . . n) b := m a P \u222a= gen(r) : (m xi \u2190 b,m xi) b := b \u2227 cr(xi)\nfor(v \u2208 vars(r) \\ (vars(\u03c6r) \u222a {a})) P \u222a= gen(r) : (m v \u2190 m a \u2227 \u03c6r ,m v) modify(r)\nExample 6 Consider a BFASP with the following rules:\nR1 \u2200i \u2208 [2, 30] where i mod 2 = 0 : R2 \u2200i \u2208 [2, 30] where i mod 2 = 0 : (a[i] \u2265 b[i\u2212 1] + y[i], a[i]) (y[i] \u2265 max(c[2i], d[i+ 1]), y[i])\nR3 \u2200i \u2208 [1, 10] : (c[i] \u2265 10\u2190 s1[i], c[i]) R4 \u2200i \u2208 [1, 10] : (b[i] \u2265 s2[i+ 1], b[i])\nwhere a, b, c, d, y are arrays of founded integers with ujb of \u2212\u221e, s2 is an array of standard Booleans and s1 is an array of standard integers with domains (\u2212\u221e,\u221e), and the index set of all arrays is equal to [1, 100]. Let us compute \u03c6r for each rule. \u03c6R1 = cr(b[i \u2212 1]) \u2227 cr(y[i]), \u03c6R2 = cr (c[2i]) \u2228 cr(d[i + 1]), and \u03c6R3 = \u03c6R4 = true. We get the following magic rules (a rule (m y \u2190 body,m y) is written as m y \u2190 body for compactness):\nM1 gen(R1) : m b[i\u2212 1]\u2190 m a[i] M2 gen(R1) : m y[i]\u2190 m a[i] \u2227 cr(b[i \u2212 1])\nM3 gen(R2) : m c[2i]\u2190 m y[i] M4 gen(R2) : m d[i+ 1]\u2190 m y[i]\nM5 gen(R3) : m s1[i]\u2190 m c[i] M6 gen(R4) : m s2[i+ 1]\u2190 m b[i]\nLet us say we are given the constraint: a[2] + a[5] \u2265 10. Processing this, we initialize Q with the set {m a[2],m a[5]}. Running ground procedure extends Q with the following variables, the rule used to derived a variable is given in brackets: m b[1](M1), m s2[2](M6), b[1](R4), m y[2](M2), m c[4](M3), m d[3](M4), c[4](R3), m s1[4](M5), y[2](R2), a[2](R1). Filtering magic rules, the following ground rules are generated during the grounding (the ujb of variables that are not created are plugged in as constants in rules where they appear): (a[2] \u2190 b[1] + y[2], a[2]), (y[2] \u2265 max(c[4],\u2212\u221e), y[2]), (c[4] \u2265 10 \u2190 s1[4], c[4]) and (b[1] \u2265 s2[2], b[1]). It can be shown that the number of rules with exhaustive and bottom-up only (without magic sets) grounding is 48 and 26 respectively!\nIf a given BFASP program is unstratified, then the algorithm described above is not sound. There might be parts of the program that are unreachable from the founded atoms appearing in the query but are inconsistent. We refer the reader to (Faber et al. 2007) for further details. We overcome this by including in the query all ground magic variables of all array variables that are part of a component in the dependency graph in which there is some decreasing (negative) edge between any two of its nodes. The following result establishes correctness of our approach.\nTheorem 2 Given a BFASP P , let G be equal to grnd(P ) and M be a ground BFASP produced by running the magic set transformation after including the unstratified parts of the program in the initial query for a given non-ground BFASP P . The stable solutions of G restricted to the variables vars(M) are equivalent to the stable solutions of M . That is, if \u03b8\u2032 is a stable solution of G, then"}, {"heading": "100 5 4.25 3.34 1.37 .64 .27 .04", "text": ""}, {"heading": "300 15 39.02 \u2014 4.19 1.25 .41 .07", "text": ""}, {"heading": "600 20 237.97 \u2014 19.70 22.56 .83 .96", "text": ""}, {"heading": "900 30 \u2014 \u2014 30.44 127.90 1.17 4.74", "text": "Instance Bottom-up Magic C P Cr Pr Flat Solve Flat Solve\n50 100 5 5 2.02 1.90 .48 .01 100 300 10 30 16.62 91.66 2.97 .07 100 500 10 30 24.78 \u2014 4.39 .09 250 350 105 105 83.45 \u2014 35.16 18.40 250 400 110 110 88.61 \u2014 39.32 452.17 300 400 125 150 140.36 \u2014 57.09 \u2014\nTable 3. UtilPol\nInstance Bottom-up Magic C Cr Flat Solve Flat Solve\n1000 15 24.27 5.20 .79 .70 1500 25 53.66 17.52 1.39 2.07 2000 35 94.38 66.81 2.31 8.75 3000 50 209.70 86.35 1.71 17.87 3500 60 \u2014 \u2014 5.58 19.18 5000 80 \u2014 \u2014 9.63 51.45\nTable 4. CompanyCon\n\u03b8\u2032|vars(M) is a stable solution of M and if \u03b8 is a stable solution of M , then there exists \u03b8\u2032 s.t. \u03b8\u2032 is a stable solution of G and \u03b8\u2032|vars(M) = \u03b8."}, {"heading": "6 Experiments", "text": "We show the benefits of bottom-up grounding and magic sets for computing with BFASPs on a number of benchmarks: RoadCon, UtilPol and CompanyCon.4 In utilitarian policies (UtilPol ), a government decides a set of policies to enact while minimizing the cost. Additionally, there are different citizens and each citizen\u2019s happiness depends on the enacted policies and happiness of other citizens. There is a citizen t whose happiness should be above a given value. Company controls (CompanyCon) is a problem related to stock markets. The parameters of the problem are the number of companies, each company\u2019s ownership of stocks in other companies, and a source company that wants to control a destination company. The decision variables are the number of stocks that the source company buys in every other company. A company c controls a company d if the number of stocks that c owns in d plus the number of stocks that other companies that c controls own in d is greater than 50 percent of total number of stocks of company d. The objective is to minimize the total cost of stocks bought. All experiments were performed on a machine running Ubuntu 12.04.1 LTS with 8 GB of physical memory and Intel(R) Core(TM) i7-2600 3.4 GHz processor. Our implementation extends MiniZinc 2.0 (LIBMZN) and uses the solver CHUFFED extended with founded variables and rules as described in our previous work (Aziz et al. 2013). Each time in the tables is the median time in seconds of 10 different instances.\nTable 2 shows the results for RoadCon. N is the number of nodes, and SCCs is the minimum\n4 All problem encodings and instances can be found at: www.cs.mu.oz.au/\u02dcpjs/bound founded/\nnumber of strongly connected components in the graph. We compare exhaustive grounding (simply creating grnd(P )) against bottom-up grounding, and bottom-up grounding with magic set transformation. A \u2014 represents either the flattener/solver did not finish in 10 minutes or that it ran out of memory. Using bottom-up grounding, the founded variables representing shortest paths between two nodes that are not in the same SCC and the corresponding useless rules are not created. Clearly bottom-up grounding is far superior to naively grounding everything, and magic sets substantially improves on this. Tables 3 and 4 show the results for utilitarian policies and company controls respectively. The running time for exhaustive and bottom-up for these benchmark are similar, therefore, the comparison is only given for bottom-up vs. magic sets. For UtilPol, C and P represent the number of citizens and policies respectively, Cr represents the maximum number of relevant citizens on which the happiness of t directly or indirectly depends and Pr is the maximum number of policies on which the happiness of t and other citizens in Cr depends. This is the part of the instance that is relevant to the query and the rest is ignored when magic sets are enabled. It can be seen that magic sets outperform regular bottom-up grounding, especially when the relevant part of the instance is small compared to the entire instance. Note that when Pr is small, the flattening time for magic sets is greater that the solving time since the resulting set of rules is actually simple. This changes, however, as Pr is increased. For CompanyCon, C is the number of total companies while Cr is the maximum number of companies reachable from the destination in the given ownership graph. The table shows that if Cr is small compared to C, magic sets can give significant advantages. The unnecessary founded variables and rules can make solving time considerably higher if magic sets optimization is not used."}, {"heading": "7 Conclusion", "text": "Bound Founded Answer Set Programming extends ASP to disallow circular reasoning over numeric entities. While the semantics of BFASP is a simple generalization of the semantics of ASP, to be practically useful we must be able to model non-ground BFASPs in a high level way. In this paper, we show how we can flatten and ground a non-ground BFASP while preserving its semantics, thus creating an executable specification of the BFASP problem. We show that using bottom-up grounding and magic sets transformation we can significantly improve the efficiency of computing BFASPs. The existing magic set techniques are only defined for the normal rule form, involving only founded Boolean variables. We have extended magic sets to BFASP, a formalism that has significantly more sophisticated rule forms and has both standard and founded variables, that can moreover be Boolean or numeric."}], "references": [{"title": "Stable model semantics for founded bounds", "author": ["R.A. AZIZ", "G. CHU", "P.J. STUCKEY"], "venue": "Theory and Practice of Logic Programming 13, 4\u20135, 517\u2013532. Proceedings of the 29th International Conference on Logic Programming.", "citeRegEx": "AZIZ et al\\.,? 2013", "shortCiteRegEx": "AZIZ et al\\.", "year": 2013}, {"title": "Inductive definitions in constraint programming", "author": ["R.A. AZIZ", "P.J. STUCKEY", "Z. SOMOGYI"], "venue": "Proceedings of the Thirty-Sixth Australasian Computer Science Conference, B. Thomas, Ed. CRPIT, vol. 135. ACS, 41\u201350.", "citeRegEx": "AZIZ et al\\.,? 2013a", "shortCiteRegEx": "AZIZ et al\\.", "year": 2013}, {"title": "Representing constraint satisfaction problems in answer set programming", "author": ["M. BALDUCCINI"], "venue": "In ICLP09 Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP09).", "citeRegEx": "BALDUCCINI,? 2009", "shortCiteRegEx": "BALDUCCINI", "year": 2009}, {"title": "Magic sets and other strange ways to implement logic programs", "author": ["F. BANCILHON", "D. MAIER", "Y. SAGIV", "J.D. ULLMAN"], "venue": "Proceedings of the fifth ACM SIGACT-SIGMOD symposium on Principles of database systems. ACM, 1\u201315.", "citeRegEx": "BANCILHON et al\\.,? 1985", "shortCiteRegEx": "BANCILHON et al\\.", "year": 1985}, {"title": "Knowledge representation, reasoning and declarative problem solving", "author": ["C. BARAL"], "venue": "Cambridge University Press.", "citeRegEx": "BARAL,? 2003", "shortCiteRegEx": "BARAL", "year": 2003}, {"title": "On the power of magic", "author": ["C. BEERI", "R. RAMAKRISHNAN"], "venue": "The Journal of Logic Programming 10, 255 \u2013 299.", "citeRegEx": "BEERI and RAMAKRISHNAN,? 1991", "shortCiteRegEx": "BEERI and RAMAKRISHNAN", "year": 1991}, {"title": "Fuzzy answer set programming: An introduction", "author": ["M. BLONDEEL", "S. SCHOCKAERT", "D. VERMEIR", "M. DE COCK"], "venue": "Soft Computing: State of the Art Theory and Novel Applications. Springer, 209\u2013222.", "citeRegEx": "BLONDEEL et al\\.,? 2013", "shortCiteRegEx": "BLONDEEL et al\\.", "year": 2013}, {"title": "Answer set solving with lazy nogood generation", "author": ["C. DRESCHER", "T. WALSH"], "venue": "Technical Communications of the 28th International Conference on Logic Programming. 188\u2013200.", "citeRegEx": "DRESCHER and WALSH,? 2012", "shortCiteRegEx": "DRESCHER and WALSH", "year": 2012}, {"title": "Magic sets and their application to data integration", "author": ["W. FABER", "G. GRECO", "N. LEONE"], "venue": "Journal of Computer and System Sciences 73, 4, 584\u2013609.", "citeRegEx": "FABER et al\\.,? 2007", "shortCiteRegEx": "FABER et al\\.", "year": 2007}, {"title": "Constraint answer set solving", "author": ["M. GEBSER", "M. OSTROWSKI", "T. SCHAUB"], "venue": "Proceedings of the 25th International Conference on Logic Programming. Springer, 235\u2013249.", "citeRegEx": "GEBSER et al\\.,? 2009", "shortCiteRegEx": "GEBSER et al\\.", "year": 2009}, {"title": "Gringo : A new grounder for answer set programming", "author": ["M. GEBSER", "T. SCHAUB", "S. THIELE"], "venue": "LPNMR. 266\u2013271.", "citeRegEx": "GEBSER et al\\.,? 2007", "shortCiteRegEx": "GEBSER et al\\.", "year": 2007}, {"title": "The stable model semantics for logic programming", "author": ["M. GELFOND", "V. LIFSCHITZ"], "venue": "Proceedings of the Fifth International Conference on Logic Programming. MIT Press, 1070\u20131080.", "citeRegEx": "GELFOND and LIFSCHITZ,? 1988", "shortCiteRegEx": "GELFOND and LIFSCHITZ", "year": 1988}, {"title": "Answer set programming via mixed integer programming", "author": ["G. LIU", "T. JANHUNEN", "I. NIEMELA"], "venue": "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning. AAAI Press, 32\u201342.", "citeRegEx": "LIU et al\\.,? 2012", "shortCiteRegEx": "LIU et al\\.", "year": 2012}, {"title": "Programming with Constraints: an Introduction", "author": ["K. MARRIOTT", "P. STUCKEY"], "venue": "MIT Press.", "citeRegEx": "MARRIOTT and STUCKEY,? 1998", "shortCiteRegEx": "MARRIOTT and STUCKEY", "year": 1998}, {"title": "Integrating answer set programming and constraint logic programming", "author": ["V.S. MELLARKOD", "M. GELFOND", "Y. ZHANG"], "venue": "Annals of Mathematics and Artificial Intelligence 53, 1-4, 251\u2013287.", "citeRegEx": "MELLARKOD et al\\.,? 2008", "shortCiteRegEx": "MELLARKOD et al\\.", "year": 2008}, {"title": "A SAT solver primer", "author": ["D.G. MITCHELL"], "venue": "Bulletin of the EATCS 85, 112\u2013132.", "citeRegEx": "MITCHELL,? 2005", "shortCiteRegEx": "MITCHELL", "year": 2005}, {"title": "Fuzzy answer set programming", "author": ["D.V. NIEUWENBORGH", "M.D. COCK", "D. VERMEIR"], "venue": "Proceedings of Logics in Artificial Intelligence, 10th European Conference, JELIA 2006. Springer Berlin Heidelberg, 359\u2013372.", "citeRegEx": "NIEUWENBORGH et al\\.,? 2006", "shortCiteRegEx": "NIEUWENBORGH et al\\.", "year": 2006}, {"title": "Enhancing DLV instantiator by backjumping techniques", "author": ["S. PERRI", "F. SCARCELLO", "G. CATALANO", "N. LEONE"], "venue": "Annals of Mathematics and Artificial Intelligence 51, 2-4, 195\u2013228.", "citeRegEx": "PERRI et al\\.,? 2007", "shortCiteRegEx": "PERRI et al\\.", "year": 2007}, {"title": "Minizinc with functions", "author": ["P.J. STUCKEY", "G. TACK"], "venue": "Proceedings of the 10th International Conference on Integration of Artificial Intelligence (AI) and Operations Research (OR) techniques in Constraint Programming. Number 7874 in LNCS. Springer, 268\u2013283.", "citeRegEx": "STUCKEY and TACK,? 2013", "shortCiteRegEx": "STUCKEY and TACK", "year": 2013}, {"title": "Logic programs and cardinality constraints \u2013 theory and practice", "author": ["T. SYRJANEN"], "venue": "Ph.D. thesis, Faculty of Information and Natural Sciences, Aalto University.", "citeRegEx": "SYRJANEN,? 2009", "shortCiteRegEx": "SYRJANEN", "year": 2009}, {"title": "Unfounded sets and well-founded semantics for general logic programs", "author": ["A. VAN GELDER", "K.A. ROSS", "J.S. SCHLIPF"], "venue": "Proceedings of the ACM Symposium on Principles of Database Systems. ACM, 221\u2013230.", "citeRegEx": "GELDER et al\\.,? 1988", "shortCiteRegEx": "GELDER et al\\.", "year": 1988}], "referenceMentions": [{"referenceID": 4, "context": "Many problems in the areas of planning or reasoning can be efficiently expressed using Answer Set Programming (ASP) (Baral 2003).", "startOffset": 116, "endOffset": 128}, {"referenceID": 11, "context": "ASP enforces stable model semantics (Gelfond and Lifschitz 1988) on the program, which disallows solutions representing circular reasoning.", "startOffset": 36, "endOffset": 64}, {"referenceID": 15, "context": "For example, given only rules b \u2190 a and a \u2190 b, the assignment a = true, b = true would be a solution under the logical semantics normally used by Boolean Satisfiability (SAT) (Mitchell 2005) solvers or Constraint Programming (CP) (Marriott and Stuckey 1998) solvers, but would not be a solution under the stable model semantics used by ASP solvers.", "startOffset": 175, "endOffset": 190}, {"referenceID": 13, "context": "For example, given only rules b \u2190 a and a \u2190 b, the assignment a = true, b = true would be a solution under the logical semantics normally used by Boolean Satisfiability (SAT) (Mitchell 2005) solvers or Constraint Programming (CP) (Marriott and Stuckey 1998) solvers, but would not be a solution under the stable model semantics used by ASP solvers.", "startOffset": 230, "endOffset": 257}, {"referenceID": 0, "context": "Bound Founded Answer Set Programming (BFASP) (Aziz et al. 2013) is an extension of ASP to allow founded integer and real variables.", "startOffset": 45, "endOffset": 63}, {"referenceID": 14, "context": "Note that Constraint ASP (CASP) and hybrid systems such as those given by (Mellarkod et al. 2008; Gebser et al. 2009; Drescher and Walsh 2012; Liu et al. 2012; Balduccini 2009; Aziz et al. 2013a) cannot solve the above problem without grounding the numeric domain to propositional variables and running into the grounding bottleneck.", "startOffset": 74, "endOffset": 195}, {"referenceID": 9, "context": "Note that Constraint ASP (CASP) and hybrid systems such as those given by (Mellarkod et al. 2008; Gebser et al. 2009; Drescher and Walsh 2012; Liu et al. 2012; Balduccini 2009; Aziz et al. 2013a) cannot solve the above problem without grounding the numeric domain to propositional variables and running into the grounding bottleneck.", "startOffset": 74, "endOffset": 195}, {"referenceID": 7, "context": "Note that Constraint ASP (CASP) and hybrid systems such as those given by (Mellarkod et al. 2008; Gebser et al. 2009; Drescher and Walsh 2012; Liu et al. 2012; Balduccini 2009; Aziz et al. 2013a) cannot solve the above problem without grounding the numeric domain to propositional variables and running into the grounding bottleneck.", "startOffset": 74, "endOffset": 195}, {"referenceID": 12, "context": "Note that Constraint ASP (CASP) and hybrid systems such as those given by (Mellarkod et al. 2008; Gebser et al. 2009; Drescher and Walsh 2012; Liu et al. 2012; Balduccini 2009; Aziz et al. 2013a) cannot solve the above problem without grounding the numeric domain to propositional variables and running into the grounding bottleneck.", "startOffset": 74, "endOffset": 195}, {"referenceID": 2, "context": "Note that Constraint ASP (CASP) and hybrid systems such as those given by (Mellarkod et al. 2008; Gebser et al. 2009; Drescher and Walsh 2012; Liu et al. 2012; Balduccini 2009; Aziz et al. 2013a) cannot solve the above problem without grounding the numeric domain to propositional variables and running into the grounding bottleneck.", "startOffset": 74, "endOffset": 195}, {"referenceID": 1, "context": "Note that Constraint ASP (CASP) and hybrid systems such as those given by (Mellarkod et al. 2008; Gebser et al. 2009; Drescher and Walsh 2012; Liu et al. 2012; Balduccini 2009; Aziz et al. 2013a) cannot solve the above problem without grounding the numeric domain to propositional variables and running into the grounding bottleneck.", "startOffset": 74, "endOffset": 195}, {"referenceID": 16, "context": "BFASP has been shown to subsume CP, ASP, CASP and Fuzzy ASP (Nieuwenborgh et al. 2006; Blondeel et al. 2013), see (Aziz et al.", "startOffset": 60, "endOffset": 108}, {"referenceID": 6, "context": "BFASP has been shown to subsume CP, ASP, CASP and Fuzzy ASP (Nieuwenborgh et al. 2006; Blondeel et al. 2013), see (Aziz et al.", "startOffset": 60, "endOffset": 108}, {"referenceID": 0, "context": "2013), see (Aziz et al. 2013) for details.", "startOffset": 11, "endOffset": 29}, {"referenceID": 18, "context": "This is analogous to flattening (Stuckey and Tack 2013) of constraint models and grounding (Syrjanen 2009; Gebser et al.", "startOffset": 32, "endOffset": 55}, {"referenceID": 19, "context": "This is analogous to flattening (Stuckey and Tack 2013) of constraint models and grounding (Syrjanen 2009; Gebser et al. 2007; Perri et al. 2007) of ASP programs.", "startOffset": 91, "endOffset": 145}, {"referenceID": 10, "context": "This is analogous to flattening (Stuckey and Tack 2013) of constraint models and grounding (Syrjanen 2009; Gebser et al. 2007; Perri et al. 2007) of ASP programs.", "startOffset": 91, "endOffset": 145}, {"referenceID": 17, "context": "This is analogous to flattening (Stuckey and Tack 2013) of constraint models and grounding (Syrjanen 2009; Gebser et al. 2007; Perri et al. 2007) of ASP programs.", "startOffset": 91, "endOffset": 145}, {"referenceID": 3, "context": "The contributions of this paper are: a flattening algorithm that transforms complex expressions to primitive forms while preserving the stable model semantics, a generalization of bottom-up grounding for normal logic programs to BFASPs and a generalization of the magic set transformation (Bancilhon et al. 1985; Beeri and Ramakrishnan 1991) for normal logic programs to BFASPs.", "startOffset": 289, "endOffset": 341}, {"referenceID": 5, "context": "The contributions of this paper are: a flattening algorithm that transforms complex expressions to primitive forms while preserving the stable model semantics, a generalization of bottom-up grounding for normal logic programs to BFASPs and a generalization of the magic set transformation (Bancilhon et al. 1985; Beeri and Ramakrishnan 1991) for normal logic programs to BFASPs.", "startOffset": 289, "endOffset": 341}, {"referenceID": 18, "context": "We omit consideration of flattening constraints since this is the same as in standard CP (Stuckey and Tack 2013).", "startOffset": 89, "endOffset": 112}, {"referenceID": 18, "context": "Finally, we flatten all the constraints in T using the standard CP flattening algorithm cp flat as described in (Stuckey and Tack 2013).", "startOffset": 112, "endOffset": 135}, {"referenceID": 8, "context": "We refer the reader to (Faber et al. 2007) for further details.", "startOffset": 23, "endOffset": 42}, {"referenceID": 0, "context": "0 (LIBMZN) and uses the solver CHUFFED extended with founded variables and rules as described in our previous work (Aziz et al. 2013).", "startOffset": 115, "endOffset": 133}], "year": 2014, "abstractText": "Bound Founded Answer Set Programming (BFASP) is an extension of Answer Set Programming (ASP) that extends stable model semantics to numeric variables. While the theory of BFASP is defined on ground rules, in practice BFASP programs are written as complex non-ground expressions. Flattening of BFASP is a technique used to simplify arbitrary expressions of the language to a small and well defined set of primitive expressions. In this paper, we first show how we can flatten arbitrary BFASP rule expressions, to give equivalent BFASP programs. Next, we extend the bottom-up grounding technique and magic set transformation used by ASP to BFASP programs. Our implementation shows that for BFASP problems, these techniques can significantly reduce the ground program size, and improve subsequent solving.", "creator": "LaTeX with hyperref package"}}}