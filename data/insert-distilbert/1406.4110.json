{"id": "1406.4110", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Feb-2014", "title": "Acyclicity Notions for Existential Rules and Their Application to Query Answering in Ontologies", "abstract": "answering conjunctive queries ( cqs ) over a set of facts extended with existential rules is a prominent problem in knowledge representation and databases. this algorithm problem can presumably be solved using the extended chase algorithm, which extends the incomplete given set matrix of facts with fresh facts in order to satisfy effectively the rules. if the chase terminates, then cqs can probably be evaluated directly in the resulting set of facts. the oracle chase, however, does not terminate necessarily, and checking whether the chase terminates on a given set composed of rules and facts is undecidable. numerous acyclicity notions were proposed as sufficient conditions for chase termination. in this paper, we present two new acyclicity notions called model - faithful computational acyclicity ( mfa ) and global model - summarising acyclicity ( msa ). furthermore, lastly we investigate the landscape of the known acyclicity notions simultaneously and establish a complete taxonomy of above all notions known to involve us. now finally, we show precisely that mfa algorithm and msa generalise most strongly of structurally these notions.", "histories": [["v1", "Tue, 4 Feb 2014 01:44:16 GMT  (595kb)", "http://arxiv.org/abs/1406.4110v1", null]], "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["bernardo cuenca grau", "ian horrocks", "markus kr\\\"otzsch", "clemens kupke", "despoina magka", "boris motik", "zhe wang"], "accepted": false, "id": "1406.4110"}, "pdf": {"name": "1406.4110.pdf", "metadata": {"source": "CRF", "title": "Acyclicity Notions for Existential Rules and Their Application to Query Answering in Ontologies", "authors": ["Bernardo Cuenca Grau", "Ian Horrocks", "Markus Kr\u00f6tzsch", "Despoina Magka", "Boris Motik", "Zhe Wang"], "emails": ["bernardo.cuenca.grau@cs.ox.ac.uk", "ian.horrocks@cs.ox.ac.uk", "markus.kroetzsch@cs.ox.ac.uk", "clemens.kupke@cs.ox.ac.uk", "despoina.magka@cs.ox.ac.uk", "boris.motik@cs.ox.ac.uk", "zhe.wang@cs.ox.ac.uk"], "sections": [{"heading": null, "text": "Existential rules are closely related to the Horn fragments of the OWL 2 ontology language; furthermore, several prominent OWL 2 reasoners implement CQ answering by using the chase to materialise all relevant facts. In order to avoid termination problems, many of these systems handle only the OWL 2 RL profile of OWL 2; furthermore, some systems go beyond OWL 2 RL, but without any termination guarantees. In this paper we also investigate whether various acyclicity notions can provide a principled and practical solution to these problems. On the theoretical side, we show that query answering for acyclic ontologies is of lower complexity than for general ontologies. On the practical side, we show that many of the commonly used OWL 2 ontologies are MSA, and that the number of facts obtained by materialisation is not too large. Our results thus suggest that principled development of materialisation-based OWL 2 reasoners is practically feasible."}, {"heading": "1. Introduction", "text": "Existential rules are first-order implications between conjunctions of function-free atoms that may contain existentially quantified variables in the implication\u2019s consequent (Baget, Lecle\u0300re, Mugnier, & Salvat, 2011a; Cal\u0300\u0131, Gottlob, Lukasiewicz, Marnette, & Pieris, 2010a). Such rules are used in a variety of ways in databases, knowledge representation, and logic programming. In database theory, existential rules are known as tuple-generating dependencies (Abiteboul, Hull, & Vianu, 1995) and are used to capture a wide range of schema\nc\u00a92013 AI Access Foundation. All rights reserved.\nconstraints. Furthermore, they are also used as declarative data transformation rules in data exchange\u2014the process of transforming a database structured according to a source schema into a database structured according to a target schema (Fagin, Kolaitis, Miller, & Popa, 2005). Existential rules also provide the foundation for several prominent knowledge representation formalisms, such as Datalog\u00b1 (Cal\u0300\u0131, Gottlob, & Pieris, 2010b; Cal\u0300\u0131 et al., 2010a), and they are also closely related to logic programs with function symbols in the head. Practical applications of existential rules range from bioinformatics (Mungall, 2009) to modelling complex structures of chemical compounds (Magka, Motik, & Horrocks, 2012; Hastings, Magka, Batchelor, Duan, Stevens, Ennis, & Steinbeck, 2012).\nAnswering conjunctive queries (CQs) over a set of facts extended with existential rules is a fundamental, yet undecidable (Beeri & Vardi, 1981) reasoning problem for existential rules. The problem can be characterised using chase (Johnson & Klug, 1984; Maier, Mendelzon, & Sagiv, 1979)\u2014a technique closely related to the hypertableau calculus (Motik, Shearer, & Horrocks, 2009b; Baumgartner, Furbach, & Niemela\u0308, 1996). In a forward-chaining manner, the chase extends the original set of facts with facts that can be derived using the rules. The result of the chase is a universal model, in the sense that an arbitrary CQ over the original facts and rules can be answered by evaluating the query in this model."}, {"heading": "1.1 Chase Termination and Acyclicity Notions", "text": "Rules with existentially quantified variables in the head\u2014so-called generating rules\u2014require the introduction of fresh individuals. Cyclic applications of generating rules may prevent the chase from terminating, and in fact determining whether chase terminates on a set of rules and facts is undecidable (Deutsch, Nash, & Remmel, 2008). However, several decidable classes of existential rules have been identified, and the existing proposals can be classified into two main groups. In the first group, rules are restricted such that their possibly infinite universal models can be represented using finitary means. This group includes rules with universal models of bounded treewidth (Baget et al., 2011a), guarded rules (Cal\u0300\u0131 et al., 2010a), and \u2018sticky\u2019 rules (Cal\u0300\u0131, Gottlob, & Pieris, 2011). In the second group, one uses a sufficient (but not necessary) acyclicity notion that ensures chase termination.\nRoughly speaking, acyclicity notions analyse the information flow between rules to ensure that no cyclic applications of generating rules are possible. Weak acyclicity (WA) (Fagin et al., 2005) was one of the first such notions, and it was extended to notions such as safety (Meier, Schmidt, & Lausen, 2009), stratification (Deutsch et al., 2008), acyclicity of a graph of rule dependencies (aGRD) (Baget, Mugnier, & Thomazo, 2011b), joint acyclicity (JA) (Kro\u0308tzsch & Rudolph, 2011), and super-weak acyclicity (SWA) (Marnette, 2009). Syntactic acyclicity criteria have also been investigated in the context of logic programs with function symbols in the rule heads, where the goal is to recognise logic programs with finite stable models. Several such notions have been implemented in state of the art logic programming engines, such as omega-restrictedness (Syrja\u0308nen, 2001) from the Smodels system (Syrja\u0308nen & Niemela\u0308, 2001), lambda-restrictedness from the ASP grounder GrinGo (Gebser, Schaub, & Thiele, 2007), argument-restrictedness (Lierler & Lifschitz, 2009) from the DLV system (Leone, Pfeifer, Faber, Eiter, Gottlob, Perri, & Scarcello, 2006), and many others (Calimeri, Cozza, Ianni, & Leone, 2008; Greco, Spezzano, & Trubitsyna, 2012; De Schreye & Decorte, 1994)."}, {"heading": "1.2 Applications of Acyclicity Notions", "text": "Acyclicity notions are interesting for several reasons. First, unlike guarded rules, acyclic rules can axiomatise structures of arbitrary shapes, as long as these structures are bounded in size. Second, the result of the chase for acyclic rules can be stored and manipulated as if it were a database; this is important, for example, in data exchange, where the goal is to materialise the transformed database.\nIn this paper, we further argue that acyclicity notions are also relevant to description logics (DLs)\u2014knowledge representation formalisms underpinning the OWL 2 ontology language (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider, & Sattler, 2008). CQ answering over DL ontologies is a key reasoning service in many DL applications, and the problem was studied for numerous different DLs (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; Kro\u0308tzsch, Rudolph, & Hitzler, 2007; Glimm, Horrocks, Lutz, & Sattler, 2008; Ortiz, Calvanese, & Eiter, 2008; Lutz, Toman, & Wolter, 2009; Pe\u0301rez-Urbina, Motik, & Horrocks, 2009; Rudolph & Glimm, 2010; Kontchakov, Lutz, Toman, Wolter, & Zakharyaschev, 2011). Answering CQs over ontologies, however, is quite technical and often of high computational complexity. Therefore, practical OWL 2 reasoners frequently solve this problem using materialisation\u2014a reasoning technique in which the relevant consequences of the ontology are precomputed using chase, allowing queries to be directly evaluated in the materialised set of facts. Examples of materialisation-based systems include Oracle\u2019s Semantic Data Store (Wu, Eadon, Das, Chong, Kolovski, Annamalai, & Srinivasan, 2008), Sesame (Broekstra, Kampman, & van Harmelen, 2002), OWLIM (Kiryakov, Ognyanov, & Manov, 2005), Jena (Carroll, Dickinson, Dollin, Reynolds, Seaborne, & Wilkinson, 2004), and DLE-Jena (Meditskos & Bassiliades, 2008). Such reasoning is possible if (i) the ontology is Horn (Hustadt, Motik, & Sattler, 2005) and thus does not require disjunctive reasoning, and (ii) the chase is guaranteed to terminate. To satisfy the second assumption, reasoners often consider only axioms in the OWL 2 RL profile (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2009a); this systematically excludes generating rules and thus trivially ensures chase termination, but it also makes the approach incomplete. Generating rules are partially supported in systems such as OWLim (Bishop & Bojanov, 2011) and Jena, but such support is typically ad hoc and provides no completeness and/or termination guarantees. Acyclicity notions can be used to address these issues: if an ontology is Horn and acyclic, a complete materialisation can be computed without the risk of non-termination."}, {"heading": "1.3 Our Contributions", "text": "Motivated by the practical importance of chase termination, in this paper we present two new acyclicity notions: model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA). Roughly speaking, these acyclicity notions use a particular model of the rules to analyse the implications between existential quantifiers, which is why we call them model based. In particular, MFA uses the actual \u2018canonical\u2019 model induced by the facts and the rules, which makes the notion very general. We prove that checking whether a set of existential rules is MFA is 2ExpTime-complete, and it becomes ExpTime-complete if the predicates in the rules are of bounded arity. Due to the high complexity, MFA may be unsuitable for practical application. Thus, we introduce MSA, which can be understood as MFA in which the analysis is performed over models that \u2018summarise\u2019 (or overestimate) the\nactual models. Checking MSA of existential rules can be realised via checking entailment of ground atoms in datalog programs. We use this close connection between MSA and datalog to prove that checking MSA is ExpTime-complete for general existential rules, and that it becomes coNP-complete if the arity of rule predicates is bounded.\nWe next conduct a detailed investigation of the landscape of known acyclicity notions, augmented with MFA and MSA. For the class of logic programs that correspond to existential rules with skolemised existential quantifiers, we show that MSA and MFA strictly subsume existing acyclicity notions known from logic programming. We also show that MSA is strictly more general than SWA\u2014one of the most general acyclicity notions known in database theory. Furthermore, we investigate the relationship between the known notions and thus complete the picture with respect to their relative expressiveness.\nBoth MSA and MFA can be applied to general existential rules without equality. Equality can be incorporated via singularisation\u2014a technique proposed by Marnette (2009) that transforms the rules to encode the effects of equality. Singularisation is orthogonal to acyclicity: after computing the transformed rules, one can use MFA, MSA, or in fact any notion to check whether the result is acyclic; if so, the chase of the signularised rules terminates, and the chase result can be used in a particular way to answer arbitrary CQs. Unfortunately, singularisation is nondeterministic: some ways of transforming the rules may produce acyclic rule sets, but not all ways are guaranteed to do so. In this paper, we refine singularisation to obtain practically useful upper and lower bounds for acyclicity. We also show that, when used with JA, our lower bound actually coincides with WA.\nWe next turn our attention to theoretical and practical issues of using acyclicity for materialisation-based CQ answering over ontologies. On the theoretical side, we show that checking MFA and MSA of Horn-SROIF ontologies is ExpTime- and PTime-complete, respectively, and that answering CQs over acyclic Horn-SROIF ontologies is ExpTimecomplete as well. Furthermore, we show that, for Horn-SHIF ontologies, the complexity of checking MFA and of answering CQs drops to PSpace. Answering CQs is ExpTimecomplete for general (i.e., not acyclic) Horn-SHIF ontologies (Eiter, Gottlob, Ortiz, & Simkus, 2008; Ortiz, Rudolph, & Simkus, 2011), so acyclicity makes this problem easier. Furthermore, Horn ontologies can be extended with arbitrary SWRL rules (Horrocks & Patel-Schneider, 2004) without affecting decidability or worst-case complexity, provided that the union of the ontology and SWRL rules is acyclic; this is in contrast to the general case, where SWRL extensions of DLs easily lead to undecidability.\nOn the practical side, we explore the limits of reasoning with acyclic OWL 2 ontologies via materialisation. We checked MFA, MSA, and JA for 336 Horn ontologies; furthermore, to estimate the impact of materialisation, we compared the size of the materialisation with the number of facts in the original ontologies. Our experiments revealed that many ontologies are MSA, and that some complex ones are MSA but not JA; furthermore, the universal models obtained via materialisation are typically not too large. Thus, our results suggest that principled, materialisation-based reasoning for ontologies beyond the OWL 2 RL profile may be practically feasible.\nThis is an extended version of a paper by Cuenca Grau, Horrocks, Kro\u0308tzsch, Kupke, Magka, Motik, and Wang (2012) published at KR 2012."}, {"heading": "2. Preliminaries", "text": "In this section we introduce definitions and notation used in the rest of our paper."}, {"heading": "2.1 First-Order Logic", "text": "We use the standard notions of constants, function symbols, and predicate symbols, where \u2248 is the equality predicate, > is universal truth, and \u22a5 is universal falsehood. Each function or predicate symbol is associated with a nonnegative integer arity. Variables, terms, substitutions, atoms, first-order formulae, sentences, interpretations (i.e., structures), and models are defined as usual. By a slight abuse of notation, we often identify a conjunction with the set of its conjuncts. Furthermore, we often abbreviate a vector of terms t1, . . . , tn as ~t; we define |~t| = n; and we often identify ~t with the set of indexed terms {t1, . . . , tn}. With \u03d5(~x) we stress that ~x = x1, . . . , xn are the free variables of a formula \u03d5, and with \u03d5\u03c3 we denote the result of applying a substitution \u03c3 to \u03d5. A term, atom, or formula is ground if it does not contain variables; a fact is a ground atom. The depth dep(t) of a term t is defined as 0 if t is a constant or a variable, and dep(t) = 1 + maxni=1 dep(ti) if t = f(t1, . . . , tn). A term t\u2032 is a subterm of a term t if t\u2032 = t or t = f(~s) and t\u2032 is a subterm of some si \u2208 ~s; if additionally t\u2032 6= t, then t\u2032 is a proper subterm of t. A term s is contained in an atom P (~t) if s \u2208 ~t, and s occurs in P (~t) if s is a subterm of some term ti \u2208 ~t; thus, if s is contained in P (~t), then s also occurs in P (~t), but the converse may not hold. A term s is contained (resp. occurs) in a set of atoms I if s is contained (resp. occurs) in some atom in I.\nIn first-order logic, the equality predicate \u2248 is commonly assumed to have a predefined interpretation\u2014that is, every first-order interpretation is required to interpret \u2248 as the smallest reflexive relation over the domain. Satisfaction of a sentence \u03d5 in an interpretation I where \u2248 is interpreted in this way is written I |= \u03d5, and entailment of a sentence \u03c8 from a sentence \u03d5 is written \u03d5 |= \u03c8. Unless otherwise stated, we use this standard interpretation of equality throughout this paper.\nEquality, however, can also be treated as an ordinary predicate with an explicit axiomatisation. Let \u03a3 be an arbitrary set of function-free first-order formulae. Then, \u03a3\u2248 = \u2205 if \u2248 does not occur in \u03a3; otherwise, \u03a3\u2248 contains formulae (1)\u2013(3) and an instance of formula (4) for each n-ary predicate P occurring in \u03a3 different from \u2248, and for each 1 \u2264 i \u2264 n. Note that all variables in all of these formulae are (implicitly) universally quantified.\n\u2192 x \u2248 x (1) x1 \u2248 x2 \u2192 x2 \u2248 x1 (2)\nx1 \u2248 x2 \u2227 x2 \u2248 x3 \u2192 x1 \u2248 x3 (3) P (x1, . . . , xi, . . . , xn) \u2227 xi \u2248 x\u2032i \u2192 P (x1, . . . , x\u2032i, . . . , xn) (4)\nIf \u2248 is treated as an ordinary predicate, satisfaction of a formula \u03d5 in a model I is written I |=\u2248 \u03d5, and entailment of a formula \u03c8 from formula \u03d5 is written \u03d5 |=\u2248 \u03c8. Please note that, according to our definitions, I |=\u2248 \u03d5 can hold even if interpretation I interprets predicate \u2248 in an arbitrary way; in contrast, I |= \u03d5 can hold only if interpretation I interprets predicate \u2248 as the identity relation on the model\u2019s domain. The consequences of \u03a3 w.r.t. |= and of \u03a3 \u222a \u03a3\u2248 w.r.t. |=\u2248 coincide\u2014that is, for each first-order sentence \u03c8 constructed using the symbols from \u03a3, we have \u03a3 |= \u03c8 if and only if \u03a3 \u222a \u03a3\u2248 |=\u2248 \u03c8."}, {"heading": "2.2 Rules and Queries", "text": "An instance is a finite set of function-free facts. An existential rule (or just rule) is a function-free sentence of the form\n\u2200~x\u2200~z.[\u03d5(~x, ~z)\u2192 \u2203~y.\u03c8(~x, ~y)] (5)\nwhere \u03d5(~x, ~z) and \u03c8(~x, ~y) are conjunctions of atoms, and tuples of variables ~x, ~y, and ~z are pairwise disjoint. Formula \u03d5 is the body and formula \u03c8 is the head of the rule. For brevity, quantifiers \u2200~x\u2200~z are often omitted. For convenience, we sometimes identify a rule body or head with the set of the respective conjuncts. A datalog rule is a rule where ~y is empty. A rule is equality-free if it does not contain the equality predicate \u2248. A term s occurs in an existential rule if s occurs in a head or body atom of the rule, and these definitions are extended to a set of rules in the obvious way; existential rules do not contain function symbols, so an analogous notion of s being contained in a rule coincides with this one. Two variables are directly connected in a rule if they occur together in a body atom of the rule; furthermore, connected is the transitive closure of directly connected ; finally, a rule of the form (5) is connected if all pairs of variables w,w\u2032 \u2208 ~x \u222a ~z are connected in the rule.\nA conjunctive query (CQ) is a formula of the form Q(~x) = \u2203~y.\u03d5(~x, ~y), where \u03d5(~x, ~y) is a conjunction of atoms; the query is Boolean if ~x is empty. A substitution \u03b8 mapping ~x to constants is an answer to Q(~x) w.r.t. a set of rules \u03a3 and instance I if \u03a3 \u222a I |= Q(~x)\u03b8. Answering CQs is the core reasoning problem in many applications of existential rules.\nWhen answering a conjunctive query Q(~x) over a set of rules \u03a3 and an instance I, in the rest of this paper we implicitly assume that Q(~x) and I contain only the predicates from \u03a3. This simplifies the presentation since it allows us to define various transformations of \u03a3 without having to take into account possible predicates that occur in Q(~x) or I only. This assumption is w.l.o.g., as we can always extend \u03a3 with tautological rules of the form P (~x)\u2192 P (~x) for each predicate P occurring in Q(~x) or I but not in \u03a3.\nFurthermore, we assume that \u2248 does not occur in the body of any rule in \u03a3 or in the query Q(~x). This is w.l.o.g. since we can eliminate each atom of the form x \u2248 t in a rule body and further replace x with t in the rest of the rule; furthermore, to eliminate body atoms of the form a \u2248 b with a and b constants, we can introduce a fresh predicate Oa, add a new rule \u2192 Oa(a), replace each body atom a \u2248 b with conjunction Oa(x) \u2227 x \u2248 b in which x is a fresh variable, and finally eliminate atom x \u2248 b as before. Similarly, we do not provide an explicit support for the inequality predicate 6\u2248. Inequality in rule heads can be simulated using an ordinary predicate: each atom of the form s 6\u2248 t occurring in a rule head can be replaced with NotEqual(s, t), where NotEqual is a fresh ordinary predicate that is explicitly axiomatised as irreflexive; note that, if \u2248 is handled as a regular predicate explicitly axiomatised by rules (1)\u2013(4), then the replacement axioms (4) must be instantiated for P = NotEqual as well. In contrast, atoms involving the inequality predicate occurring in rule bodies generally require disjunctive reasoning, which is not supported by existential rules.\nFinally, we assume that conjunctions \u03d5(~x, ~z) and \u03c8(~x, ~y) in each rule of the form (5) are both not empty. We also assume that > and \u22a5 are treated as ordinary unary predicates, and that the semantics of > is captured explicitly in \u03a3 by instantiating the following rule for each n-ary predicate P occurring in \u03a3:\nP (x1, . . . , xn)\u2192 >(x1) \u2227 . . . \u2227 >(xn) (6)\nThese assumptions ensure that I \u222a \u03a3 is always satisfiable, but that \u03a3 \u222a I |= \u2203y.\u22a5(y) if and only if I \u222a \u03a3 is unsatisfiable w.r.t. the conventional treatment of > and \u22a5. By allowing body atoms of the form >(x), without loss of generality we can require each existential rule to be safe (i.e., that each universally quantified variable occurring in a head atom also occurs in a body atom of the rule), which greatly simplifies many of our definitions.\nIn database theory, satisfaction and entailment are often considered only w.r.t. finite interpretations under the unique name assumption (UNA); the latter ensures that distinct constants are interpreted as distinct elements. In contrast, such assumptions are not customary in ontology-based KR. In this paper, we do not assume UNA, as UNA can be axiomatised explicitly if needed using the inequality predicate (or a simulation thereof). Furthermore, in this paper we investigate theories that are satisfiable in finite models (i.e., for which the chase is finite); thus, the difference between finite and infinite satisfiability is immaterial to our results.\nWe frequently use skolemisation to interpret rules in Herbrand interpretations, which are defined as possibly infinite sets of ground atoms. In particular, for each rule r of the form (5) and each variable yi \u2208 ~y, let f ir be a function symbol globally unique for r and yi of arity |~x|; furthermore, let \u03b8sk be the substitution such that \u03b8sk(yi) = f ir(~x) for each yi \u2208 ~y. Then, the skolemisation sk(r) of r is the following rule:\n\u03d5(~x, ~z)\u2192 \u03c8(~x, ~y)\u03b8sk (7)\nThe skolemisation sk(\u03a3) of a set of rules \u03a3 is obtained by skolemising each rule in \u03a3. Skolemisation does not affect the answers to CQs\u2014that is, for each conjunctive query Q(~x) formed from only the predicates in \u03a3, each instance I, and each substitution \u03c3, we have \u03a3 \u222a I |= Q(~x)\u03c3 if and only if sk(\u03a3) \u222a \u03a3\u2248 \u222a I |=\u2248 Q(~x)\u03c3."}, {"heading": "2.3 The Skolem Chase", "text": "Answering CQs can be characterised using chase, and in this paper we use the skolem chase variant (Marnette, 2009). Let r = \u03d5\u2192 \u03c8 be a skolemised rule and let I be a set of ground atoms. A set of ground atoms S is a consequence of r on I if substitution \u03c3 exists mapping the variables in r to the terms occurring in I such that \u03d5\u03c3 \u2286 I and S \u2286 \u03c8\u03c3. The result of applying r to I, written r(I), is the union of all consequences of r on I. For \u2126 a set of skolemised rules, \u2126(I) = \u22c3 r\u2208\u2126 r(I). Let I be a finite set of ground atoms, let \u03a3 be a set of rules, let \u03a3\u2032 = sk(\u03a3) \u222a \u03a3\u2248, and let \u03a3\u2032f and \u03a3\u2032n be the subsets of \u03a3\u2032 containing rules with and without function symbols, respectively. The chase sequence for I and \u03a3 is a sequence of sets of facts I0\u03a3, I 1 \u03a3, . . . where I 0 \u03a3 = I and, for each i > 0, set I i \u03a3 is defined as follows:\n\u2022 if \u03a3\u2032n(Ii\u22121\u03a3 ) 6\u2286 I i\u22121 \u03a3 , then I i \u03a3 = I i\u22121 \u03a3 \u222a \u03a3\u2032n(I i\u22121 \u03a3 ), \u2022 otherwise Ii\u03a3 = I i\u22121 \u03a3 \u222a \u03a3\u2032f (I i\u22121 \u03a3 ).\nThe chase of I and \u03a3 is defined as I\u221e\u03a3 = \u22c3 i I i \u03a3; note that I \u221e \u03a3 can be infinite. The chase can be used as a \u2018database\u2019 for answering CQs: a substitution \u03c3 is an answer to Q over \u03a3 and I if and only if I\u221e\u03a3 |=\u2248 Q\u03c3. The chase of I and \u03a3 terminates if i \u2265 0 exists such that Ii\u03a3 = I j \u03a3 for each j \u2265 i; the chase of \u03a3 terminates universally if the chase of I and \u03a3 terminates for each I. If the skolem chase of I and \u03a3 terminates, then both the nonoblivious chase (Fagin et al., 2005) and the core chase (Deutsch et al., 2008) of I and \u03a3 terminate as well.\nThe critical instance I\u2217\u03a3 for a set of rules \u03a3 contains all facts that can be constructed using all predicates occurring in \u03a3, all constants occurring in the body of a rule in \u03a3, and one special fresh constant \u2217. The skolem chase for I\u2217\u03a3 and \u03a3 terminates if and only if the skolem chase of \u03a3 terminates universally (Marnette, 2009)."}, {"heading": "2.4 Acyclicity Notions", "text": "Checking whether the skolem chase terminates on a given instance is undecidable, and checking universal skolem chase termination is conjectured to be undecidable as well. Consequently, various sufficient acyclicity notions have been proposed in the literature. Formally, an acyclicity notion X is a class of finite sets of rules; such a definition allows us to talk about (proper) containment between acyclicity notions. We sometimes write \u2018\u03a3 is X\u2019, by which we mean \u2018\u03a3 \u2208 X\u2019. We next introduce weak and joint acyclicity: the former is one of the first such notions considered in the literature; and as we show in Section 3, the latter notion is relatively powerful, yet still easy to understand. We use these two notions throughout the paper to present examples and state various technical claims. In Section 3 we present the definitions of many other acyclicity notions known in the literature.\nIn the following, let \u03a3 be a set of rules where no variable occurs in more than one rule. A position is an expression of the form P |i where P is an n-ary predicate and i is an integer with 1 \u2264 i \u2264 n. Given a rule r of the form (5) and a variable w occurring in r, the set PosB(w) of body positions of w contains each position P |i such that P (t1, . . . , tn) \u2208 \u03d5(~x, ~z) and ti = w for some vector ~t of terms. The set PosH(w) of head positions is defined analogously, but w.r.t. the head atoms of r. Note that, since each variable occurs in at most one rule in \u03a3, sets PosB(w) and PosH(w) are (indirectly) associated with the rule that contains w. In the rest of this paper, whenever we use notation such as PosH(w) or PosB(w), we silently assume that no variable occurs in more than one rule and so the notation is unambiguous. This is clearly w.l.o.g. as one can always arbitrarily rename variables in different rules.\nWeak acyclicity (WA) (Fagin et al., 2005) can be applied to existential rules that contain the equality predicate. The WA dependency graph WA(\u03a3) for \u03a3 contains positions as vertices; furthermore, for each rule r \u2208 \u03a3 of the form (5), each variable x \u2208 ~x, each position P |i \u2208 PosB(x), and each variable y \u2208 ~y, graph WA(\u03a3) contains\n\u2022 a regular edge from P |i to each Q|j \u2208 PosH(x) such that Q 6= \u2248 and,\n\u2022 a special edge from P |i to each Q|j \u2208 PosH(y) such that Q 6= \u2248.\nSet \u03a3 is WA if WA(\u03a3) does not contain a cycle that involves a special edge. Equality atoms are effectively ignored by WA.\nJoint acyclicity (JA) (Kro\u0308tzsch & Rudolph, 2011) generalises WA, but it is applicable only to equality-free rules. For an existentially quantified variable y in \u03a3, let Move(y) be the smallest set of positions such that\n\u2022 PosH(y) \u2286 Move(y), and\n\u2022 for each existential rule r \u2208 \u03a3 and each universally quantified variable x occurring in r, if PosB(x) \u2286 Move(y), then PosH(x) \u2286 Move(y).\nThe JA dependency graph JA(\u03a3) of \u03a3 is defined as follows. The vertices of JA(\u03a3) are the existentially quantified variables occurring in \u03a3. Given arbitrary two such variables y1 and y2, the JA dependency graph JA(\u03a3) contains an edge from y1 to y2 whenever the rule that contains y2 also contains a universally quantified variable x such that PosH(x) 6= \u2205 and PosB(x) \u2286 Move(y1). Set \u03a3 is JA if JA(\u03a3) does not contain a cycle."}, {"heading": "2.5 Rule Normalisation", "text": "Existential rules can often be transformed into other existential rules by replacing parts of the rule head or body with atoms involving fresh predicates. Such a transformation is called normalisation, and is often used as a preprocessing step to bring the rules into a suitable form. For example, Horn OWL 2 axioms can be translated into existential rules by using the well known transformations of first-order logic, and the latter can then be normalised to a form we describe in Section 6. In this section we introduce a definition of rule normalisation that captures all similar methods known to us.\nLet r be a rule of the form (8), where \u03d51, \u03d52, \u03c81, and \u03c82 are conjunctions of atoms satisfying ~x1 \u222a ~x2 = ~x3 \u222a ~x4, ~z2 \u2229 ~z3 = \u2205, and ~y2 \u2229 ~y3 = \u2205.\n\u03d51(~x1, ~z1, ~z2) \u2227 \u03d52(~x2, ~z1, ~z3)\u2192 \u2203~y1, ~y2, ~y3.[\u03c81(~x3, ~y1, ~y2) \u2227 \u03c82(~x4, ~y1, ~y3)] (8)\nA normalisation step replaces a conjunction in either the head or the body of the rule with an atom involving a fresh predicate. More precisely, a head normalisation step replaces \u03c81(~x3, ~y1, ~y2) with atom Q(~x3, ~y1) where Q is a fresh predicate, thus replacing r with rule (9), and it adds rule (10).\n\u03d51(~x1, ~z1, ~z2) \u2227 \u03d52(~x2, ~z1, ~z3)\u2192 \u2203~y1, ~y3.[Q(~x3, ~y1) \u2227 \u03c82(~x4, ~y1, ~y3)] (9) Q(~x3, ~y1)\u2192 \u2203~y2.\u03c81(~x3, ~y1, ~y2) (10)\nAlternatively, a body normalisation step replaces \u03d51(~x1, ~z1, ~z2) with atom Q(~x1, ~z1) where Q is a fresh predicate, thus replacing r with rule (11), and it adds rule (12).\nQ(~x1, ~z1) \u2227 \u03d52(~x2, ~z1, ~z3)\u2192 \u2203~y1, ~y2, ~y3.[\u03c81(~x3, ~y1, ~y2) \u2227 \u03c82(~x4, ~y1, ~y3)] (11) \u03d51(~x1, ~z1, ~z2)\u2192 Q(~x1, ~z1) (12)\nGiven a set of existential rules \u03a3, normalisation steps are often applied to \u03a3 iteratively. If the predicate Q introduced in each step is always fresh, we call such normalisation without structure sharing. In contrast, normalisation with structure sharing allows the predicate Q to be reused across different normalisation steps. For example, once a predicate Q is introduced in a head normalisation step to replace \u03d51(~x1, ~z1, ~z2), then a conjunction of the form \u03d51(~x \u2032 1, ~z \u2032 1, ~z \u2032 2) where ~x \u2032 1, ~z \u2032 1, ~z \u2032 2 are renamings of ~x1, ~z1, ~z2 can be replaced with Q(~x \u2032 3, ~y \u2032 1) without introducing the corresponding rule (10). An analogous optimisation can be used in a body normalisation step.\nLet \u03a3\u2032 be a set of rules obtained via normalisation (with or without structure sharing) from \u03a3. It is well known that \u03a3\u2032 is a conservative extension of \u03a3. Consequently, for each instance I and each BCQ Q that does not use the freshly introduced predicates, we have \u03a3 \u222a I |= Q if and only if \u03a3\u2032 \u222a I |= Q."}, {"heading": "3. Novel Acyclicity Notions", "text": "Weak acyclicity has considerably influenced the field of data exchange in databases, but it is a rather strict notion and so it may not be sufficient in many applications of existential rules. Joint acyclicity significantly relaxes weak acyclicity and was developed mainly for rule based knowledge representation applications.\nIn Section 3.1 we show that even joint acyclicity\u2014one of the most general acyclicity notions developed so far\u2014does not capture rules corresponding to axioms commonly found in ontologies for which the chase terminates universally. To address this important limitation, we propose in Section 3.2 model-faithful acyclicity (MFA)\u2014a novel, very general, notion that can be used to successfully ensure chase termination for many ontologies used in practice. The computational cost of checking MFA is, however, rather high; hence, in Section 3.3 we introduce model-summarising acyclicity (MSA)\u2014a more strict notion that is easier to check and produces the same results as MFA on most existing ontologies."}, {"heading": "3.1 Limitations of Existing Acyclicity Notions", "text": "To motivate our new acyclicity notions, we first present an example that shows how known acyclicity notions, such as JA, are not satisfied by rules that are equivalent to very simple axioms that abound in OWL ontologies.\nExample 1. Let \u03a3 be the set of rules (13)\u2013(17).\nr1 = A(x1)\u2192 \u2203y1.R(x1, y1) \u2227B(y1) (13) r2 = R(x2, z1) \u2227B(z1)\u2192 A(x2) (14) r3 = B(x3)\u2192 \u2203y2.R(x3, y2) \u2227 C(y2) (15) r4 = C(x4)\u2192 D(x4) (16) r5 = R(x5, z2) \u2227D(z2)\u2192 B(x5) (17)\nRules r1 and r2 correspond to the description logic axiom A \u2261 \u2203R.B, rule r3 corresponds to axiom B v \u2203R.C, rule r4 corresponds to axiom C v D, and rule r5 corresponds to axiom \u2203R.D v B. Such axioms are very common in OWL ontologies.\nBy the definition of JA from Section 2, we have Move(y1) = {R|2, B|1, R|1, A|1}. Thus, the JA dependency graph contains an edge from y1 to itself, so the set of axioms \u03a3 is not JA. In contrast, the following table shows the chase sequence for I\u2217\u03a3 and \u03a3.\nA(\u2217) R(\u2217, f(\u2217)) R(f(\u2217), g(f(\u2217))) D(g(f(\u2217))) B(\u2217) B(f(\u2217)) C(g(f(\u2217))) C(\u2217) R(\u2217, g(\u2217)) D(g(\u2217)) D(\u2217) C(g(\u2217))\nR(\u2217, \u2217)\nRule r2 is not applicable to R(f(\u2217), g(f(\u2217))) since I3 does not contain the fact B(g(f(\u2217))) necessary to match the atom B(z1) from the rule. Thus, the chase terminates. \u2666\nAll existing acyclicity notions essentially try to estimate whether an application of a rule can produce facts that can (possibly by applying chase to other rules) repeatedly\ntrigger the same rule in an infinite manner. The key difference between various notions is how rule applicability is determined. In particular, JA considers each variable in a rule in isolation and does not check satisfaction of all body atoms at once; for example, rule (14) is not applicable to the facts generated by rule (15), but this can be determined only by considering variables x2 and z1 in rule (14) simultaneously. These notions thus overestimate rule applicability and, as a result, they can fail to detect chase termination."}, {"heading": "3.2 Model-Faithful Acyclicity (MFA)", "text": "Our main intuition for addressing this problem is that more precise chase termination guarantees can be obtained by tracking rule applicability more \u2018faithfully\u2019. A simple solution is to be completely precise about rule applicability: one can run the skolem chase and then use sufficient checks to identify cyclic computations. Since no sufficient, necessary, and computable test can be given for the latter, we must adopt a practical approach. For example, we can \u2018raise the alarm\u2019 and stop the process if the chase derives a \u2018cyclic\u2019 term f(~t), where f occurs in ~t. This idea can be further refined; for example, one could stop only if f occurs nested in a term some fixed number of times. The choice of the appropriate test thus depends on an application; however, as our experiments show, checking only for one level of nesting suffices in many cases. In particular, no term f(~t) with f occurring in ~t is generated in the chase of the set of rules \u03a3 from Example 1.\nDefinition 2. A term t is cyclic if a function symbol f exists such that some term f(~s) is a subterm of t, and some term f(~u) is a proper subterm of f(~s).\nOur notion of acyclicity is declarative: the given set of rules \u03a3 is transformed into a new set of rules \u03a3\u2032 that tracks rule dependencies using fresh predicates; then, \u03a3 is identified as being acyclic if \u03a3\u2032 does not entail a special nullary predicate C. Since acyclicity is defined via entailment, it can be decided using any theorem proving procedure for existential rules that is sound and complete. Acyclicity guarantees termination of the skolem chase, which also guarantees termination of nonoblivious chase and core chase. We call our notion modelfaithful acyclicity because it estimates rule application precisely, by examining the actual structure of the universal model of \u03a3.\nDefinition 3. For each rule r = \u03d5(~x, ~z)\u2192 \u2203~y.\u03c8(~x, ~y) and each variable yi \u2208 ~y, let Fir be a fresh unary predicate unique for r and yi; furthermore, let S and D be fresh binary predicates, and let C be a fresh nullary predicate. Then, MFA(r) is the following rule:\n\u03d5(~x, ~z)\u2192 \u2203~y. \u03c8(~x, ~y) \u2227 \u2227 yi\u2208~y Fir(yi) \u2227 \u2227 xj\u2208~x S(xj , yi)  For a set \u03a3 of rules, MFA(\u03a3) is the smallest set that contains MFA(r) for each rule r \u2208 \u03a3, rules (18)\u2013(19), and rule (20) instantiated for each Fir corresponding to some r \u2208 \u03a3:\nS(x1, x2)\u2192 D(x1, x2) (18) D(x1, x2) \u2227 S(x2, x3)\u2192 D(x1, x3) (19)\nFir(x1) \u2227 D(x1, x2) \u2227 Fir(x2)\u2192 C (20)\nThe set \u03a3 is model-faithful acyclic (MFA) w.r.t. an instance I if I \u222aMFA(\u03a3) 6|= C; furthermore, \u03a3 is universally MFA1 if \u03a3 is MFA w.r.t. I\u2217\u03a3.\nExample 4. Let \u03a3 be the set of rules from Example 1. Then, MFA(r1) and MFA(r3) are given by (21) and (22), respectively; since r1 and r3 contain a single existentially quantified variable each, we omit the superscripts in Fr1 and Fr3 for the sake of clarity. Thus, MFA(\u03a3) consists of rules (14), (16), and (17), rules (21)\u2013(22), rules (18)\u2013(19), and rule (20) instantiated for Fr1 and Fr3.\nA(x1)\u2192 \u2203y1.R(x1, y1) \u2227B(y1) \u2227 Fr1(y1) \u2227 S(x1, y1) (21) B(x3)\u2192 \u2203y2.R(x3, y2) \u2227 C(y2) \u2227 Fr3(y2) \u2227 S(x3, y2) (22)\nIt is straightforward to see that the chase of I\u2217\u03a3 and MFA(\u03a3) consists of the facts presented in Example 1, augmented with the following facts:\nS(\u2217, f(\u2217)) D(\u2217, f(\u2217)) D(f(\u2217), g(f(\u2217))) S(\u2217, g(\u2217)) D(\u2217, g(\u2217)) D(\u2217, g(f(\u2217))) Fr1(f(\u2217)) S(f(\u2217), g(f(\u2217))) Fr3(g(\u2217)) Fr3(g(f(\u2217)))\nThe chase of I\u2217\u03a3 and MFA(\u03a3) does not contain C, which implies that I \u222aMFA(\u03a3) 6|= C. As a result, \u03a3 is universally MFA. \u2666\nMFA is formulated as a semantic, rather than a syntactic notion, and is thus mainly independent from algorithmic details: entailment I \u222aMFA(\u03a3) 6|= C can be checked using an arbitrary sound and complete first-order calculus. In Section 4 we discuss the relationship between MFA and existing notions, and we show that MFA generalises most of them.\nThe following proposition shows that MFA characterises the derivations of the skolem chase in which no cyclic terms occur.\nProposition 5. A set \u03a3 of rules is not MFA w.r.t. an instance I if and only if I\u221eMFA(\u03a3) contains a cyclic term.\nProof. Let \u03a3\u2032 = MFA(\u03a3), and let I0\u03a3\u2032 , I 1 \u03a3\u2032 , . . . be the chase sequence for I and \u03a3 \u2032. Moreover, let f ir be the function symbol used to skolemise the i-th existentially quantified variable in rule r, as defined in Section 2.2. We next prove that the following claims hold for all terms t and t\u2032 occurring in Ik\u03a3\u2032 , each rule r, each integer i, and each integer k, as well as k =\u221e.\n1. Term t is of the form f ir(~u) if and only if F i r(t) \u2208 Ik\u03a3\u2032 .\n2. Term t is of the form f ir(~u) and t \u2032 \u2208 ~u if and only if S(t\u2032, t) \u2208 Ik\u03a3\u2032 .\n3. If t\u2032 is a proper subterm of t, then D(t\u2032, t) \u2208 Ik+2\u03a3\u2032 ; furthermore, D(t \u2032, t) \u2208 I\u221e\u03a3\u2032 if and\nonly if t\u2032 is a proper subterm of t.\n1. In the rest of this paper we often omit \u2018universally\u2019; furthermore, when used as an acyclicity notion, MFA means \u2018universally MFA\u2019.\n(Claims 1 and 2, direction \u21d2) The proof is by induction on k. Set I0\u03a3\u2032 does not contain functional terms, and so it clearly satisfies both claims. For the induction step, assume that both claims hold for Ik\u22121\u03a3\u2032 and consider I k \u03a3\u2032 . Since I k\u22121 \u03a3\u2032 \u2286 I k \u03a3\u2032 , both claims clearly hold for each term t that occurs in Ik\u22121\u03a3\u2032 . Consider an arbitrary term t of the form f i r(~u) that does not occur in Ik\u22121\u03a3\u2032 , and an arbitrary term t \u2032 \u2208 ~u. Clearly, t is introduced into Ik\u03a3\u2032 by an application of the skolemisation of MFA(r) for some rule r \u2208 \u03a3. Since the head of MFA(r) contains atoms Fir(yi) and S(xj , yi) for each xj \u2208 ~x, we have Fir(t) \u2208 Ik\u03a3\u2032 and S(t\u2032, t) \u2208 Ik\u03a3\u2032 for each t\u2032 \u2208 ~u, and so we have Fir(t) \u2208 I\u221e\u03a3\u2032 and S(t\u2032, t) \u2208 I\u221e\u03a3\u2032 for each t\u2032 \u2208 ~u as well. Finally, since I\u221e\u03a3\u2032 = \u22c3 k I k \u03a3\u2032 , these claims clearly hold for k =\u221e.\n(Claims 1 and 2, direction\u21d0) Predicate S and each predicate Fir occur in \u03a3\u2032 only in head atoms of the form Fir(yi) and S(xj , yi); hence, the skolemised rules contain these predicates only in head atoms of the form Fir(f i r(~x)) and S(xj , f i r(~x)), which clearly implies our claim.\n(Claim 3, the first part for k 6=\u221e) The proof is by induction on k. The base case holds vacuously since I0\u03a3\u2032 does not contain functional terms. Assume now that the claim holds for some k \u2212 1, and consider an arbitrary term t = f ir(~u) occurring in Ik\u03a3\u2032 such that t\u2032 is a subterm of some ti \u2208 ~u. By Claim 2, we have S(ti, t) \u2208 Ik\u03a3\u2032 ; furthermore, ti occurs in Ik\u22121\u03a3\u2032 , so by the induction assumption we have D(t\n\u2032, ti) \u2208 Ik+1\u03a3\u2032 . Finally, the rules without functional terms are applied before the rules with functional terms; hence, by rule (19) we have D(t\u2032, t) \u2208 Ik+2\u03a3\u2032 , as required.\n(Claim 3, the second part) The \u2018proper subterm\u2019 relation is transitive, and rules (18) and (19) effectively define D as the transitive closure of S, which clearly implies this claim.\nAssume now that I\u221e\u03a3\u2032 contains a cyclic term t. Then, some term t1 = f i r(~s) is a subterm of t and some term t2 = f i r(~u) is a proper subterm of t1. By Claims 1 and 3, then we have {Fir(t2),D(t2, t1),Fir(t1)} \u2286 I\u221e\u03a3\u2032 . But then, since \u03a3\u2032 contains rule (20), we have C \u2208 I\u221e\u03a3\u2032 , so \u03a3 is not MFA. For the converse claim, assume that \u03a3 is not MFA w.r.t. an instance I. Then, by Definition 3 we have that I \u222aMFA(\u03a3) |= C. Since the special nullary predicate C occurs only on the right-hand side of rule (20), there exist terms t1 and t2, a rule r \u2208 \u03a3, and a predicate Fir such that {Fir(t1),D(t1, t2),Fir(t2)} \u2286 I\u221e\u03a3\u2032 . Since Fir(t1) and Fir(t2) are contained in I\u221e\u03a3\u2032 , Claim 1 implies that t1 and t2 are of the form t1 = f i r( ~u1) and t2 = f i r( ~u2), respectively. Finally, D(t1, t2) \u2208 I\u221e\u03a3\u2032 and Claim 3 imply that t1 is a proper subterm of t2, so I\u221e\u03a3\u2032 contains a cyclic term.\nThis characterisation implies termination of skolem chase of MFA rules \u03a3 in 2ExpTime. In particular, a term t derived by the skolem chase of \u03a3\u2032 = MFA(\u03a3) cannot be cyclic by Proposition 5; such t can then be seen as a tree with branching factor bounded by the maximum arity of a function symbol in sk(\u03a3\u2032) and with depth bounded by the number of function symbols in sk(\u03a3\u2032). The chase can thus generate at most a doubly exponential number of different terms and atoms. The 2ExpTime bound already holds if the rules are WA (Cal\u0300\u0131 et al., 2010b), so CQ answering for MFA rules is not harder than for WA rules.\nProposition 6. If a set of rules \u03a3 is MFA w.r.t. an instance I, then the skolem chase for I and \u03a3 terminates in double exponential time.\nProof. Let \u03a3\u2032 = MFA(\u03a3), let c, f , and p be the number of constants, function symbols, and predicate symbols, respectively, occurring in sk(\u03a3\u2032), let ` be the maximum arity of a function symbol, and let a be the maximum arity of a predicate symbol in sk(\u03a3\u2032). Consider\nnow an arbitrary term t occurring in I\u221e\u03a3\u2032 ; clearly, t can be seen as a tree with branching factor ` containing constants in the leaf nodes and function symbols in the internal nodes; furthermore, since t is not cyclic, dep(t) \u2264 f , the number of leaves is bounded by `f , and the total number of nodes is bounded by f \u00b7 `f . Each node is assigned a constant or a function symbol, so the number of different terms occurring in I\u221e\u03a3\u2032 is bounded by \u2118 = (c+ f)\nf \u00b7`f , and the number of different atoms in I\u221e\u03a3\u2032 is bounded by p \u00b7 \u2118a, which is clearly doubly exponential in \u03a3 and I. Consequently, the size of I\u221e\u03a3\u2032 is at most doubly exponential in \u03a3 and I. Furthermore, for an arbitrary set of facts I \u2032 and rule r, the set r(I \u2032) can be computed by examining all mappings of the variables in r to the terms occurring in I \u2032, which requires exponential time in the size of r and polynomial time in the size of I \u2032. Consequently, I\u221e\u03a3\u2032 can be computed in time that is double exponential in I and \u03a3. Finally, it is straightforward to see that I\u221e\u03a3 \u2286 I\u221e\u03a3\u2032 , so I\u221e\u03a3 can be computed in double exponential time as well.\nBy Proposition 6, answering a BCQ over MFA rules is in 2ExpTime. We next prove that checking MFA w.r.t. a specific instance I is also in 2ExpTime, and that checking universal MFA is 2ExpTime-hard. This provides tight complexity bounds for both problems. Towards this goal, we first establish in Lemma 7 a relationship between answering certain kinds of queries over certain kinds of rules and checking whether a related set of rules is universally MFA; we use this relationship in several hardness proofs in the rest of this paper. Then, in Theorem 8 we present our main complexity result.\nLemma 7. Let \u03a3 be a set of weakly acyclic, constant-free, equality-free, and connected rules with predicates of nonzero arity, let A and B be unary predicates, let R be a fresh binary predicate, let a be a constant, and let \u2126 be \u03a3 extended with rule (23).\nR(z, x) \u2227B(x)\u2192 \u2203y.[R(x, y) \u2227A(y)] (23)\nThen, we have {A(a)} \u222a \u03a3 6|= B(a) if and only if \u2126 is universally MFA.\nProof. Let I = {A(a)}, and let I0\u03a3, I1\u03a3, . . . be the chase sequence for I and \u03a3. Furthermore, let \u2126\u2032 = MFA(\u2126), let J = I\u2217\u2126, let J 0 \u2126\u2032 , J 1 \u2126\u2032 , . . . be the chase sequence for J and \u2126\n\u2032, and let f be the function symbol used to skolemise the existential quantifier in rule (23). Set \u03a3 is constant-free, so a is the only constant occurring in each set Ii\u03a3.\nWe next show that the facts in J j\u2126\u2032 are of a certain form. To this end, for each ` \u2265 0, let t` = f(. . . f(\u2217) . . .) where the function symbol f is repeated ` times (by this definition, we have t0 = \u2217); also, each term or fact obtained from t` by zero or more applications of predicates or function symbols not in {f,D, S,C, R} is of level `. By induction on the chase sequence for J and \u2126\u2032, we next prove that the sequence satisfies the following property ( ):\nfor each fact F \u2208 J j\u2126\u2032 , some integer ` exists such that F is of the form R(\u2217, \u2217) or R(t`, t`+1), or the predicate of F is contained in {D, S,C}, or F is an `-level fact and the predicate of F is not contained in {D, S,C, R}.\nSet J0\u2126\u2032 = J clearly satisfies property ( ) since each fact in it is clearly of level 0. Now assume that J j\u2126\u2032 satisfies property ( ) for some j, and consider an application of a rule r \u2208 \u2126\n\u2032. If r corresponds to rule (18), (19), (20), or (23), then the result of the rule application clearly satisfies property ( ). Otherwise, r is safe and no body atom contains a predicate in\n{D, S,C, R}; by induction assumption, then some atom is matched to a fact of some level `; the body atoms of r are connected, so all body atoms are matched to facts of the same level; finally, the head atoms of r contain function symbols different from f , but no constants or predicates of zero arity, so each fact derived by an atom in the head of r either contains predicate S or is of level `.\nWe next show that the chase sequences for I and \u03a3, and for J and \u2126\u2032 are related by the following property (\u2666):\nfor each fact F \u2032 of level 1 and the fact F obtained by replacing each t1 in F \u2032 with a, we have F \u2208 Ii\u03a3 for some i if and only if F \u2032 \u2208 J j \u2126\u2032 \\ J for some j.\nThe proof of (\u2666) is straightforward: J contains R(\u2217, \u2217) and B(\u2217), so J1\u2126\u2032 contains R(\u2217, f(\u2217)) and A(f(\u2217)); moreover, due to ( ), term t1 plays in the chase sequence for J and \u2126\u2032 the \u2018same role\u2019 as constant a in the chase sequence for I and \u03a3, so the rule applications to facts of level 1 in the former chase sequence correspond one-to-one with rule applications in the latter chase sequence. We omit the formal details for the sake brevity.\nNow assume that {A(a)} \u222a \u03a3 |= B(a). Then, B(a) \u2208 Ii\u03a3 holds for some i. By property (\u2666), then integer j exists such that B(f(\u2217)) \u2208 J j\u2126\u2032 . But then, due to rule (23), some ` \u2265 j exists such that A(f(f(\u2217))) \u2208 J `\u2126\u2032 . By Proposition 5, then \u2126 is not universally MFA.\nConversely, assume that {A(a)} \u222a \u03a3 6|= B(a). Since \u03a3 is weakly acyclic and equalityfree, \u03a3 is super-weakly acyclic (Marnette, 2009); as we will show in Section 4 (see Theorem 19), \u03a3 is then MFA as well. Now consider an arbitrary integer j and fact F \u2208 J j\u2126\u2032 . If F is of level 0 or 1, since \u03a3 is MFA, fact F does not contain a cyclic term. Furthermore, B(a) 6\u2208 I\u221e\u03a3 so, by property (\u2666), fact F is not of the form B(f(\u2217)); thus, rule (23) does not \u2018fire\u2019 to introduce facts of level greater than 1. Consequently, F does not contain a cyclic term, and so, by Proposition 5, the set \u2126 is universally MFA.\nTheorem 8. Given a set of rules \u03a3, deciding whether \u03a3 is MFA w.r.t. an instance I is in 2ExpTime, and deciding whether \u03a3 is universally MFA is 2ExpTime-hard. Both results hold even if the arity of predicates in \u03a3 is bounded.\nProof. (Membership) Let \u03a3\u2032 = MFA(\u03a3), let I0\u03a3\u2032 , I 1 \u03a3\u2032 , . . . be the chase sequence for I and \u03a3 \u2032, and let \u2118, p, and a be as stated in the proof of Proposition 6. The number of different atoms that can be constructed from \u2118 terms is bounded by k = p \u00b7 \u2118a; note that this is double exponential even if a is bounded. Let k\u2032 = k + 4; we next show that whether \u03a3 is MFA w.r.t. I can be decided by constructing Ik\n\u2032 \u03a3\u2032 and then checking whether C \u2208 Ik \u2032 \u03a3\u2032 . As in\nthe proof of Proposition 6, the latter can be done in double exponential time. If Ik\u03a3\u2032 = I k\u2032 \u03a3\u2032 , then I \u221e \u03a3\u2032 = I k \u03a3\u2032 , so \u03a3 is not MFA if and only if C \u2208 Ik\u03a3\u2032 . Otherwise, we have Ik\u03a3\u2032 ( I k\u2032 \u03a3\u2032 ; but then, I k+1 \u03a3\u2032 clearly contains at least one cyclic term t = f i r(~t) such that t\u2032 = f ir(~s) is a subterm of some ti \u2208 ~t. Since Ik+1\u03a3\u2032 satisfies Claims 1\u20133 from the proof of Proposition 5, we have D(ti, t) \u2208 Ik+3\u03a3\u2032 ; by rule (20) and the fact that rules without functional terms are applied before rules with functional terms, we have C \u2208 Ik\u2032\u03a3\u2032 ; thus, C \u2208 I\u221e\u03a3\u2032 , so \u03a3 is not MFA by Proposition 5.\n(Hardness) We prove the claim by a reduction from the problem of checking I \u222a \u03a3 |= Q, where \u03a3 is a weakly acyclic set of equality-free rules and with predicates of bounded arity,\nI is an instance, and Q = \u2203~y.\u03be(~y) is a Boolean conjunctive query. Cal\u0300\u0131 et al. (2010b) show that, for such I, \u03a3, and Q, deciding I \u222a \u03a3 |= Q is 2ExpTime-complete. We next transform I, \u03a3, and Q so that we can apply Lemma 7, which proves our claim.\nLet \u03a31 = \u03a3 \u222a {\u03be(~y)\u2192 B} where B is a fresh predicate of zero arity; clearly, I \u222a \u03a3 |= Q holds if and only if I \u222a \u03a31 |= B holds.\nLet \u03a32 and I2 be obtained by eliminating constants from the rules in \u03a31; that is, we initially set I2 = I and then, for each rule r \u2208 \u03a3 and each constant c occurring in r, we replace all occurrences in c with a fresh variable wc, add an atom Oc(wc) to the body of r where Oc is a fresh predicate uniquely associated with c, and add a fact Oc(c) to I2. It is straightforward to see that I \u222a \u03a31 |= B if and only if I2 \u222a \u03a32 |= B.\nFinally, to transform \u03a32 and I2 into \u03a33, we define some notation. Let P\u0302 be a fresh n+1ary predicate unique for each n-ary predicate P , and let w be a fresh variable not occurring in \u03a32. For a conjunction of atoms \u03d5, let \u03d5\u0302 = \u2227 P (~t)\u2208\u03d5 P\u0302 (~t, w). Rule (24) is obtained from I2 as specified below, where A is a fresh unary predicate, each constant c occurring in I2 is associated with a distinct, fresh variable vc, and ~vc is the vector of all such variables:\nA(w)\u2192 \u2203~vc. \u2227\nP (c1,...,ck)\u2208I2\nP\u0302 (vc1 , . . . , vck , w) (24)\nFinally, the set \u03a33 contains rule (24) and a rule\n\u03d5\u0302(~x, ~z, w)\u2192 \u2203~y.\u03c8\u0302(~x, ~y, w) for each rule \u03d5(~x, ~z)\u2192 \u2203~y.\u03c8(~x, ~y) in \u03a32. (25)\nClearly, all predicates in \u03a33 are of nonzero arity; all rules in \u03a33 are constant-free and connected; and A occurs only in the body of rule (24) and \u03a32 is WA, so \u03a33 is WA as well. Finally, let I3 = {A(a)} where a is a fresh constant; by induction on the chase sequences for \u03a32 and I2, and \u03a33 and I3, it is straightforward to show that, for each integer i and each fact P (c1, . . . , ck), we have P (c1, . . . , ck) \u2208 (I2)i\u03a32 if and only if P\u0302 (fc1(a), . . . , fck(a), a) \u2208 (I3) i+1 \u03a33\n, where fc1 , . . . , fck are the skolem functions used to skolemise vc1 , . . . , vck in rule (24). Thus, I2 \u222a \u03a32 |= B if and only if I3 \u222a \u03a33 |= B\u0302(a), which by Lemma 7 implies our claim.\nThe results of Theorem 8 are somewhat discouraging: known acyclicity notions can typically be checked in PTime or in NP. We consider MFA to be an \u2018upper bound\u2019 of practically useful acyclicity notions. We see two possibilities for improving these results. In Section 3.3 we introduce an approximation of MFA that is easier to check; our experiments (see Section 7) show that this notion often coincides with MFA in practice. Furthermore, we show next that the complexity is lower for rules of the following shape.\nDefinition 9. A rule r of the form (5) is an \u2203-1 rule if ~y is empty or ~x contains at most one variable.\nAs we discuss in the following sections, \u2203-1 rules capture (extensions of) Horn DLs. We next show that BCQ answering and MFA checking for \u2203-1 rules is easier than for general rules. Intuitively, if \u03a3 is MFA and contains only \u2203-1 rules, then all functional terms in sk(MFA(\u03a3)) are unary and hence the number of different terms and atoms derivable by chase becomes exponentially bounded, as shown by the following theorem.\nTheorem 10. Let \u03a3 be a set of \u2203-1 rules, and let I be an instance. Checking whether \u03a3 is MFA w.r.t. I is in ExpTime, and checking whether \u03a3 is universally MFA is ExpTime-hard. Moreover, if \u03a3 is MFA w.r.t. I, then answering a BCQ over \u03a3 and I is ExpTime-complete.\nProof. We defer the proof of both hardness claims to Section 6, which deals with an even smaller class of rules that correspond to Horn description logic ontologies. In particular, we prove hardness of BCQ answering in Lemma 59, and hardness of checking whether \u03a3 is MFA w.r.t. I in Lemma 60. In the rest of this proof, we show both membership results.\nLet \u03a3\u2032 = MFA(\u03a3); let c be the number of constants in an instance; and let f be the number of function symbols in the rules. Since \u03a3 contains only \u2203-1 rules, \u03a3\u2032 also contains only \u2203-1 rules; consequently, all functional terms in sk(\u03a3\u2032) are of arity 1. Hence, each noncyclic term can be understood as a sequence of at most f function symbols, so the total number of different noncyclic terms is bounded by \u2118 = c \u00b7 (f + 1)f . The total number of atoms is bounded by p \u00b7 \u2118a, where p is the number of predicates and a is the maximum arity of a predicate in \u03a3\u2032. Note that this is exponential even if a is fixed. As in the proof of Proposition 6, we can now show that either the chase for \u03a3\u2032 and I terminates or a cyclic term is derived in exponential time, which proves that the complexity of checking whether \u03a3 is MFA w.r.t. I is in ExpTime.\nFinally, since I\u221e\u03a3 \u2286 I\u221e\u03a3\u2032 , if \u03a3 is MFA, then I\u221e\u03a3 can be computed in exponential time, so a BCQ over \u03a3 and I can be answered in ExpTime."}, {"heading": "3.3 Model-Summarising Acyclicity (MSA)", "text": "The high cost of checking MFA of \u03a3 arises because the arity of function symbols in sk(\u03a3) is unbounded and the depth of cyclic terms can be linear in \u03a3. To obtain an acyclicity notion that is easier to check, we must coarsen the structure used for cycle analysis. We thus next introduce model-summarising acyclicity, which \u2018summarises\u2019 the models of \u03a3 by reusing the same constant to satisfy an existential quantifier, instead of introducing \u2018deep\u2019 terms.\nDefinition 11. Let S, D, and Fir be as specified in Definition 3; furthermore, for each rule r = \u03d5(~x, ~z)\u2192 \u2203~y.\u03c8(~x, ~y) and each variable yi \u2208 ~y, let cir be a fresh constant unique for r and yi. Then, MSA(r) is the following rule, where \u03b8MSA is the substitution that maps each variable yi \u2208 ~y to cir:\n\u03d5(~x, ~z)\u2192 \u03c8(~x, ~y)\u03b8MSA \u2227 \u2227 yi\u2208~y Fir(yi)\u03b8MSA \u2227 \u2227 xj\u2208~x S(xj , yi)\u03b8MSA  For a set \u03a3 of rules, MSA(\u03a3) is the smallest set that contains MSA(r) for each rule r \u2208 \u03a3, rules (18)\u2013(19), and rule (20) instantiated for each predicate Fir. Set \u03a3 is modelsummarising acyclic (MSA) w.r.t. an instance I if I \u222aMSA(\u03a3) 6|= C; furthermore, \u03a3 is universally MSA if \u03a3 is MSA w.r.t. I\u2217\u03a3.\nExample 12. Consider again the set of rules \u03a3 from Example 1. MSA(r1) and MSA(r3) are given by rules (26) and (27), respectively; since r1 and r3 contain a single existentially quantified variable each, we omit the superscripts in Fr1, Fr3, cr1, and cr3 for the sake of\nclarity. Thus, MSA(\u03a3) consists of rules (14), (16), and (17), rules (26)\u2013(27), rules (18)\u2013 (19), and rule (20) instantiated for Fr1 and Fr3.\nA(x1)\u2192 R(x1, cr1) \u2227B(cr1) \u2227 Fr1(cr1) \u2227 S(x1, cr1) (26) B(x3)\u2192 R(x3, cr3) \u2227 C(cr3) \u2227 Fr3(cr3) \u2227 S(x3, cr3) (27)\nThe following table shows the chase sequence for I\u2217\u03a3 and MSA(\u03a3).\nA(\u2217) R(\u2217, cr1) R(cr1 , cr3) D(cr1 , cr3) B(\u2217) R(\u2217, cr3) D(cr3) C(\u2217) B(cr1) S(cr1 , cr3) D(\u2217) C(cr3) D(\u2217, cr3)\nR(\u2217, \u2217) S(\u2217, cr1) D(\u2217, cr1) S(\u2217, cr3) Fr1(cr1)\nFr3(cr3)\nThe result of the chase does not contain C, and so \u03a3 is universally MSA. \u2666\nNote that MSA(\u03a3) is equivalent to a set of datalog rules: the only minor difference is that the rules in MSA(\u03a3) can contain several head atoms, but such rules can clearly be transformed into equivalent datalog rules. Thus, MSA can be checked using a datalog reasoner. This connection with datalog and the complexity results by Dantsin, Eiter, Gottlob, and Voronkov (2001) for checking entailment of a ground atom in a datalog program provide us with the upper complexity bound for checking MSA in Theorem 13. The complexity of datalog reasoning is O(r \u00b7 nv) where r is the number of rules, v is the maximum number of variables in a rule, and n is the size of the set of facts that the rules are applied to; thus, checking MSA should be feasible if the rules in \u03a3 are \u2018short\u2019 and so v is \u2018small\u2019.\nTheorem 13. For \u03a3 a set of rules, deciding whether \u03a3 is MSA w.r.t. an instance I is in ExpTime, and deciding whether \u03a3 is universally MSA is ExpTime-hard. The two problems are in coNP and coNP-hard, respectively, if the arity of the predicates in \u03a3 is bounded.\nProof. (Membership) Let \u03a3\u2032 = MSA(\u03a3), and note that \u03a3 is MSA w.r.t. I if and only if I \u222a \u03a3\u2032 6|= C if and only if C 6\u2208 I\u221e\u03a3\u2032 . The total number of atoms occurring in I\u221e\u03a3\u2032 is p \u00b7ca, where p is the number of predicates, c is the number of constants, and a is the maximum arity of the predicates in \u03a3\u2032; this number is clearly exponential if a is not bounded. The rest of the proof is the same as in Theorem 8.\nAssume now that a is bounded; then the number of ground atoms in I\u221e\u03a3\u2032 becomes polynomial. Furthermore, by the definition of the chase, C \u2208 I\u221e\u03a3\u2032 if and only if there exist a sequence of rules r1, . . . , rn of the form ri = \u03d5i \u2192 \u03c8i and a sequence of substitutions \u03c31, . . . , \u03c3n such that \u03d5\u03c3i \u2286 I \u222a {\u03c8j\u03c3j | j < i} \u2286 I\u221e\u03a3\u2032 for each 1 \u2264 i \u2264 n and \u03c8n\u03c3n = C. Clearly, we can assume that n \u2264 p \u00b7 ca, which is polynomial. Thus, we can guess the two sequences in nondeterministic polynomial time, and we can check the required property in polynomial time. Thus, I \u222a \u03a3\u2032 |= C can be checked in nondeterministic polynomial time, so checking whether \u03a3 is MSA w.r.t. I is in coNP.\n(Hardness) Let \u03a3 be a set of datalog rules, let I be an instance, and let Q be ground atom. Checking whether I \u222a \u03a3 |= Q is ExpTime-complete in general (Dantsin et al., 2001). Furthermore, the problem is NP-hard if the arity of predicates is bounded: a rule in \u03a3 can encode an arbitrary Boolean conjunctive query with atoms of bounded arity but arbitrarily many variables, for which answering is well known to be NP-hard.\nLet \u03a34 and I4 be obtained from \u03a3 as in the proof of Theorem 8; then, I \u222a \u03a3 |= Q if and only if I4 \u222a \u03a34 |= B(a), and the set of rules \u2126 obtained from \u03a34 as specified in Lemma 7 is universally MFA if and only if I4 \u222a \u03a34 6|= B(a). Finally, the only existential variable in \u2126 occurs in a rule of the form (23), so it is straightforward to see that \u2126 is universally MFA if and only if T \u2032 is universally MSA.\nBefore concluding this section, we present Theorem 14 and Example 15, which together show that MFA is strictly more general than MSA.\nTheorem 14. If a set of rules \u03a3 is MSA (w.r.t. an instance I), then \u03a3 is MFA (w.r.t. I) as well.\nProof. Let \u03a31 = MFA(\u03a3) and let \u03a32 = MSA(\u03a3). Furthermore, let h be the mapping of ground terms to constants defined such that h(t) = cir if t is of the form f i r(. . .), and h(t) = t if t is a constant; for an atom A = P (t1, . . . , tn), let h(A) = P (h(t1), . . . , h(tn)); and for an instance I, let h(I) = {h(A) | A \u2208 I}. Finally, let I0\u03a31 , I 1 \u03a31 , . . . be the chase sequence for I and \u03a31, and let I 0 \u03a32 , I1\u03a32 , . . . be the chase sequence for I and \u03a32. Note that sk(\u03a32) = \u03a32 differs from sk(\u03a31) only in that the former contains the constant c i r in place of each functional term f ir(~x). Please note that, although our definition of the chase applies rules with function symbols after rules without function symbols, one can clearly construct the chase of the function-free set of rules \u03a32 using any order of rule applications, including the one corresponding to the order of rule applications in the chase of \u03a31. Assuming this slight modification, one can show by a straightforward induction on i that h(Ii\u03a31) \u2286 I i \u03a32\nfor each i; this implies h(I\u221e\u03a31) \u2286 I \u221e \u03a32 . Consequently, C 6\u2208 I\u221e\u03a32 clearly implies C 6\u2208 I \u221e \u03a31\n; hence, if \u03a3 is MSA, then \u03a3 is MFA as well, as required.\nExample 15. Let \u03a3 be the set of rules (28)\u2013(31).\nr1 = A(x)\u2192 \u2203y.R(x, y) \u2227B(y) (28) r2 = B(x)\u2192 \u2203y.S(x, y) \u2227 T (y, x) (29) r3 = A(z) \u2227 S(z, x)\u2192 C(x) (30) r4 = C(z) \u2227 T (z, x)\u2192 A(x) (31)\nIt is straightforward to check that \u03a3 is universally MFA, but not universally MSA. \u2666"}, {"heading": "3.4 Acyclicity Notions and Normalisation", "text": "As mentioned in Section 2.5, existential rules are often normalised into a particular form; however, this cannot destroy acyclicity: if a set of rules \u03a3 is MFA, then each set of rules obtained from \u03a3 by normalisation is MFA as well. This claim involves certain technical assumptions about the treatment of equality, which is why we postpone a formal proof of this statement until Section 5. Next, however, we show that normalisation can have a positive effect on acyclicity.\nExample 16. Let \u03a3 be the set containing only the following rule:\nA(x)\u2192 \u2203y.[B(x) \u2227A(y)] (32)\nAs specified in Section 2.2, this rule is skolemised as follows, which causes that the skolem chase of \u03a3 and instance I = {A(a)} does not terminate.\nA(x)\u2192 B(x) \u2227A(f(x)) (33)\nNote, however, that atoms B(x) and A(y) in the head of the rule do not share variables, so we can normalise this rule as follows, where Q is a fresh predicate of zero arity:\nA(x)\u2192 B(x) \u2227Q (34) Q\u2192 \u2203y.A(y) (35)\nIt is straightforward to check that this normalised set of rules is MFA; in fact, the normalised set of rules is even JA. Intuitively, normalisation, as defined in Section 2.5, ensures that each functional symbol introduced during normalisation depends on as few variables in the rule as possible. \u2666\nNormalisation, however, can have a negative effect on universal termination, as shown by the following example.\nExample 17. Let \u03a3 be the set containing only the following rule:\nC(z) \u2227R(z, x) \u2227B(x)\u2192 \u2203y1\u2203y2.[R(x, y1) \u2227R(y1, y2) \u2227B(y2)] (36)\nOne can readily check that \u03a3 is universally MFA. Now let \u03a3\u2032 be the following set of rules, which is obtained by replacing conjunction R(y1, y2) \u2227B(y2) in the rule head with Q(y1):\nC(z) \u2227R(z, x) \u2227B(x)\u2192 \u2203y1.[R(x, y1) \u2227Q(y1)] (37) Q(y1)\u2192 \u2203y2.[R(y1, y2) \u2227B(y2)] (38)\nLet f1 and f2 be function symbols used to skolemise the existential quantifier in rule (37) and (38), respectively. Since Q(\u2217) \u2208 I\u2217\u03a3\u2032, the chase of \u03a3\u2032 and I\u2217\u03a3\u2032 derives R(\u2217, f2(\u2217)) and B(f2(\u2217)); but then, these facts, C(\u2217), and rule (37) derive Q(f1(f2(\u2217))), after which rule (38) derives R(f1(f2(\u2217)), f2(f1(f2(\u2217)))) and B(f2(f1(f2(\u2217)))). The chase of \u03a3\u2032 and I\u2217\u03a3\u2032 thus contains a cyclic term, so \u03a3\u2032 is not universally MFA.\nIntuitively, this problem occurs because the critical instance I\u2217\u03a3\u2032 for \u03a3 \u2032 also instantiates the predicate Q introduced during normalisation. Such predicates, however, cannot occur in arbitrary input instances, so we can use the critical instance for \u03a3. Since Q(\u2217) 6\u2208 I\u2217\u03a3, the skolem chase of \u03a3\u2032 and I\u2217\u03a3 does not derive a cyclic term, from which we can conclude that the skolem chase of \u03a3\u2032 terminates on each instance I that contains facts constructed using only the predicates occurring in \u03a3. \u2666"}, {"heading": "4. Relationship with Known Acyclicity Notions", "text": "Many acyclicity notions have been proposed in the literature, but the relationships between them have been only partially investigated. We next investigate the relationship between MFA, MSA, and the acyclicity notions known to us, and we produce a detailed picture of their relative expressiveness. We show that MFA and MSA generalise most of these notions."}, {"heading": "4.1 Acyclicity in Databases", "text": "Acyclicity notions have been considered in databases in data integration and data exchange scenarios. Weak acyclicity (Fagin et al., 2005) was one of the first such notions, and it has spurred on the research into more sophisticated notions for ensuring chase termination."}, {"heading": "4.1.1 Super-Weak Acyclicity", "text": "Marnette (2009) proposed super-weak acyclicity (SWA), which generalises weak acyclicity provided that the rules are equality-free. We next recapitulate the definition of SWA, and then we show that MSA and MFA are strictly more general than SWA.\nDefinition 18. Let \u03a3 be a set of existential rules in which no variable occurs in more than one rule, and let \u03b8sk be the substitution used to skolemise the rules in \u03a3.\n2 A place is a pair \u3008A, i\u3009 where A is an n-ary atom occurring in a rule in \u03a3 and 1 \u2264 i \u2264 n. A set of places P \u2032 covers a set of places P if, for each place \u3008A, i\u3009 \u2208 P , a place \u3008A\u2032, i\u2032\u3009 \u2208 P \u2032 and substitutions \u03c3 and \u03c3\u2032 exist such that A\u03c3 = A\u2032\u03c3\u2032 and i = i\u2032. Given a variable w occurring in a rule r = \u03d5\u2192 \u2203~y.\u03c8, sets of places In(w), Out(w), and Move(w) are defined as follows:\n\u2022 set In(w) contains each place \u3008R(~t), i\u3009 such that R(~t) \u2208 \u03d5 and ti = w;\n\u2022 set Out(w) contains each place \u3008R(~t)\u03b8sk, i\u3009 such that R(~t) \u2208 \u03c8 and ti = w; and\n\u2022 set Move(w) is the smallest set of places such that\n\u2013 Out(w) \u2286 Move(w) and \u2013 Out(w\u2032) \u2286 Move(w) for each variable w\u2032 that is universally quantified in some\nrule in \u03a3 such that Move(w) covers In(w\u2032).\nThe SWA dependency graph SWA(\u03a3) of \u03a3 contains a vertex for each rule of \u03a3, and an edge from a rule r \u2208 \u03a3 to a rule r\u2032 \u2208 \u03a3 if a variable x\u2032 occurring in both the body and the head of r\u2032 and an existentially quantified variable y occurring in the head of r exists such that Move(y) covers In(x\u2032). Set \u03a3 is super-weakly acyclic (SWA) if SWA(\u03a3) is acyclic.\nMarnette (2009) uses a slightly different definition: the notation for places is the same as our notation for positions; a variable may occur in more than one rule so sets In(w), Out(w), and Move(w) are defined w.r.t. a rule and a variable; and a rule trigger relation is used instead of the SWA dependency graph. For simplicity, Definition 18 introduces SWA in the same style as JA; however, both definitions capture the same class of rules.\nThe following theorem shows that MSA is more general than SWA. Furthermore, in Example 12 we argued that the set of rules \u03a3 from Example 1 is MSA, and one can readily check that \u03a3 is not SWA. Consequently, MSA is strictly more general than SWA.\nTheorem 19. If a set of rules \u03a3 is SWA, then \u03a3 is universally MSA.\n2. Substitution \u03b8sk is unique for each rule in Section 2.2; however, since each variable in \u03a3 occurs in at most one rule, w.l.o.g. we can take \u03b8sk as the substitution used to skolemise all the rules in \u03a3.\nProof. Let \u03a3\u2032 = MSA(\u03a3), let I0, I1, . . . be the chase sequence for I\u2217\u03a3 and \u03a3 \u2032, and let I\u221e be the chase of I\u2217\u03a3 and \u03a3 \u2032. Furthermore, let \u03c1 be the function that maps constants to themselves and that maps ground functional terms as \u03c1(f ir(~t)) = c i r, where f i r and c i r were introduced in Section 2.2 and Definition 11, respectively. Finally, let \u03c1(P (t1, . . . , tn)) = P (\u03c1(t1), . . . , \u03c1(tn)). We next prove the following property ( ): for each rule r \u2208 \u03a3, each existentially quantified variable yi occurring in r, each P (~t) \u2208 I\u221e where P 6\u2208 {S,D,C}, and each tj \u2208 ~t such that tj = c i r, a substitution \u03c4 and a place \u3008A, j\u3009 \u2208 Move(yi) exist such that P (~t) = \u03c1(A\u03c4). The proof is by induction on the length of the chase. Since I0 = I\u2217\u03a3 does not contain a constant of the form cir, property ( ) holds vacuously for I\n0. Assume now that property ( ) holds for some Ik\u22121, and consider an arbitrary rule r \u2208 \u03a3, an existentially quantified variable yi in r, a fact P (~t) \u2208 Ik \\ Ik\u22121 with P 6\u2208 {S,D,C}, and a term tj \u2208 ~t such that tj = cir. Fact P (~t) is derived in Ik from the head atom H of some rule r1 \u2208 MSA(\u03a3). Let \u03c3 be the substitution used in the rule application; clearly, we have H\u03c3 = P (~t). Furthermore, let r2 \u2208 \u03a3 be the rule such that r1 = MSA(r2), let r3 = sk(r2), and let H3 be the head atom of r3 that corresponds to H; clearly, we have \u03c1(H3\u03c3) = P (~t). Now if H has cir in position j, then r = r 1 since r1 is the only rule that contains cir; thus, \u3008H3, j\u3009 \u2208 Out(yi) \u2286 Move(yi), so property ( ) holds. Otherwise, H contains at position j a universally quantified variable x such that \u03c3(x) = cir. Let B1, . . . , Bn be the body atoms of r\n1 that contain x; clearly, {B1\u03c3, . . . , Bn\u03c3} \u2286 Ik\u22121. All these atoms satisfy the induction assumption, so for each Bm \u2208 {B1, . . . , Bn} and each ` such that Bm contains variable x at position `, a place \u3008B\u2032m, `\u3009 \u2208 Move(yi) and substitution \u03c4m exist such that Bm\u03c3 = \u03c1(B \u2032 m\u03c4\nm). Let \u03c3\u2032 be the substitution obtained from \u03c3 by setting \u03c3\u2032(w) = \u03c4m(w) for each variable w for which \u03c4m(w) is a functional term; clearly, Bm\u03c3 \u2032 = B\u2032m\u03c4 m. But then, Move(yi) covers In(x); hence, by the definition of Move, we have that \u3008H3, j\u3009 \u2208 Move(yi), so property ( ) holds. We additionally prove the following property (\u2666): if S(cir, c i\u2032 r\u2032) \u2208 I\u221e for some i and i\u2032, then SWA(\u03a3) contains an edge from r to r\u2032. Consider an arbitrary such fact, let yi be the existentially quantified variable of r corresponding to cir, and let k be the smallest integer such that S(cir, c i\u2032 r\u2032) \u2208 Ik. Clearly, S(cir, ci \u2032 r\u2032) is derived in I k from the head atom S(x, ci \u2032 r\u2032) of rule r\u2032. Let \u03c3 be the substitution used in the rule application; thus, \u03c3(x) = cir. Let B1, . . . , Bn be the body atoms of r that contain x; clearly, we have {B1\u03c3, . . . , Bn\u03c3} \u2286 Ik\u22121. All these atoms satisfy property ( ), so for each Bm \u2208 {B1, . . . , Bn} and each ` such that Bm contains variable x at position `, a place \u3008B\u2032m, `\u3009 \u2208 Move(yi) and substitution \u03c4m exist such that Bm\u03c3 = \u03c1(B \u2032 m\u03c4\nm). But then, as in the previous paragraph we have that Move(yi) covers In(x), so SWA(\u03a3) contains an edge from r to r\u2032.\nAssume now that \u03a3 is not MSA, so C \u2208 I\u221e; then {Fir(t),D(t, t\u2032),Fir(t\u2032)} \u2286 I\u221e holds for some Fir due to rules (20). But then, since predicate F i r occurs in \u03a3 \u2032 only in an atom Fir(c i r), we have t = t\u2032 = cir. Finally, since D is axiomatised in \u03a3 \u2032 as the transitive closure of S, clearly SWA(\u03a3) contains a path from r to itself, and so \u03a3 is not SWA.\nThe rule set in Example 1 is MSA but not SWA. Furthermore, it is known that SWA is more general than JA, and the two notions differ only if at least one rule contains a body atom in which at least one variable occurs more than once (Kro\u0308tzsch & Rudolph, 2013). The following example shows that SWA is strictly more general than JA.\nExample 20. Let \u03a3 be the set of the following rules:\nr1 = A(x1)\u2192 \u2203y.R(x1, y) \u2227R(y, x1) \u2227R(x1, x1) (39)\nr2 = R(x2, x2)\u2192 B(x2) (40) r3 = B(x3)\u2192 A(x3) (41)\nOne can readily verify that \u03a3 is SWA, but not JA. \u2666\nTheorem 19 holds even if \u03a3 contains the equality predicate, but provided that the axiomatisation of equality (cf. Section 2) is taken as part of the input. On such rule sets, however, SWA, JA, MSA, and MFA are not strictly more general than WA. We discuss the underlying problems, as well as possible solutions, in Section 5."}, {"heading": "4.1.2 Acyclicity by Rewriting", "text": "Spezzano and Greco (2010) proposed an acyclicity notion called Adn-WA. Roughly speaking, one first rewrites a set of rules \u03a3 into another set of rules \u03a3\u2032 by adorning the positions in the predicates that can contain infinitely many terms during the chase; then, one checks whether \u03a3\u2032 is WA. The rewriting algorithm is rather involved, so we do not recapitulate its definition; instead, we discuss it by means of an example. Spezzano and Greco used this example to show that Adn-WA is not subsumed by SWA, but the same example also shows that Adn-WA is not subsumed by MFA either.\nExample 21. Let \u03a3 be the set containing the following rules:\nA(x)\u2192 \u2203y.R(x, y) (42) B(z) \u2227R(z, x)\u2192 A(x) (43)\nThe transformation by Spezzano and Greco (2010) produces a set \u03a3\u2032 that consists of three groups of rules. The first group contains rules (44)\u2013(47).\nAb(x)\u2192 \u2203y.Rbf (x, y) (44) Bb(z) \u2227Rbb(z, x)\u2192 Ab(x) (45) Bb(z) \u2227Rbf (z, x)\u2192 Af (x) (46)\nAf (x)\u2192 \u2203y.Rff (x, y) (47)\nFor each n-ary predicate P , the transformation introduces predicates of the form Pm , where m is an adornment\u2014a string of length n of letters b or f . Intuitively, if m contains letter b at position i, then during the chase construction the i-th position of Pm can contain only constants occurring in an instance. Rules (44)\u2013(47) were derived as follows. Rule (44) is obtained from rule (42) by marking all positions of variable x with b, which effectively creates a variant of the rule whose body is applicable only to constants. Variable y in the head of rule (44) occurs under an existential quantifier, so the corresponding position is marked with f . Rule (45) is obtained from rule (43) in an analogous way. But then, since facts introduced by rule (44) can trigger an application of rule (43), the latter rule is marked as rule (46); predicate Af in the head of rule (46) reflects the fact that variable x in the rule body is instantiated by atom Rbf (z, x). Finally, facts derived by rule (46) can trigger an application of rule (42), so the latter rule is instantiated as (47). At this point the algorithm terminates: since no rule was instantiated with a marking Bf in the head, it is not possible to use predicate Rff to mark the body of rule (43) in a consistent way.\nThe second group consists of rules (48)\u2013(50), which \u2018populate\u2019 the adorned predicates with the contents of an instance.\nR(x1, x2)\u2192 Rbb(x1, x2) (48) A(x)\u2192 Ab(x) (49) B(x)\u2192 Bb(x) (50)\nThe third group consists of rules (51)\u2013(56), which \u2018gather\u2019 the content of each adorned predicate Pm into a fresh output predicates P\u0302 .\nRbb(x1, x2)\u2192 R\u0302(x1, x2) (51) Rbf (x1, x2)\u2192 R\u0302(x1, x2) (52) Rff (x1, x2)\u2192 R\u0302(x1, x2) (53)\nAb(x)\u2192 A\u0302(x) (54) Af (x)\u2192 A\u0302(x) (55) Bb(x)\u2192 B\u0302(x) (56)\nIt is straightforward to check that \u03a3 is not MFA. In contrast, \u03a3\u2032 is WA; furthermore, Spezzano and Greco (2010) show that, for each instance I and each vector of ground terms ~t, we have P\u0302 (~t) \u2208 I\u221e\u03a3\u2032 if and only if P (~t) \u2208 I\u221e\u03a3 . Since \u03a3\u2032 is WA, I\u221e\u03a3\u2032 is finite, and, by the previously mentioned property, I\u221e\u03a3 is finite as well. \u2666\nThe following example shows that MFA is not subsumed by Adn-WA, which indicates that MFA and Adn-WA are incomparable.\nExample 22. Let \u03a3 be the set containing the following rules:\nr1 = A(x)\u2192 \u2203y.R(x, y) \u2227B(y) (57) r2 = S(z, x) \u2227B(x)\u2192 \u2203y.S(x, y) (58)\nThe rules in the first group of the set \u03a3\u2032 obtained by the transformation are shown below; we do not show the rules in the second and the third group for the sake of brevity.\nAb(x)\u2192 \u2203y.Rbf (x, y) \u2227Bf (y) (59) Sbb(z, x) \u2227Bb(x)\u2192 \u2203y.Sbf (x, y) (60) Sbf (z, x) \u2227Bf (x)\u2192 \u2203y.Sff (x, y) (61) Sff (z, x) \u2227Bf (x)\u2192 \u2203y.Sff (x, y) (62)\nThe last rule ensures that the WA dependency graph for \u03a3\u2032 contains a special edge from position Sff |2 to itself; thus, \u03a3\u2032 is not WA, and therefore \u03a3 is not Adn-WA. In contrast, one can readily verify that \u03a3 is MFA. \u2666\nSpezzano and Greco (2010) also proposed several optimisations of this transformation, the discussion of which is out of scope of this paper. All of them can be seen as \u2018unfolding\u2019 the rules in \u03a3 up to a certain number of chase steps. This seems close to an idea by Baget\net al. (2011b), who propose to run the chase for some fixed number of steps before checking for potential cycles. A similar effect could be obtained by extending the notion of MFA to check for terms that contain a function symbol nested some fixed number of times.\nFinally, note that the transformation by Spezzano and Greco (2010) is independent from the notion used to check the acyclicity of the transformed rule set; hence, given an arbitrary acyclicity notion X, one can define Adn-X in the obvious way. Given arbitrary notions X and Y such that X \u2286 Y , it is obvious that Adn-X \u2286 Adn-Y ; consequently, we have Adn-X 6\u2286 MFA for each X such that WA \u2286 X. In contrast, however, it not obvious whether the inclusion between Adn-X and Adn-Y is strict whenever the inclusion between X and Y is strict, or whether MFA is contained in Adn-X for some X with WA \u2286 X. Finally, we conjecture that X \u2286 Adn-X holds for an arbitrary notion X, but we do not have a formal proof of this conjecture. Due to the complex nature of the rewriting, we refrain from further analysis of these relationships."}, {"heading": "4.1.3 Monitor Graph", "text": "Meier et al. (2009) propose an idea that is similar in spirit to MFA. The idea is to track each chase step in an additional data structure called the monitor graph. If the chase is infinite, then the monitor graph contains cycles of arbitrary length; conversely, if one can show that the monitor graph does not contain a cycle of some fixed length, then the chase is guaranteed to terminate. While this idea is closely related to MFA, note that the definition of MFA is semantic; hence, one can use an arbitrary theorem proving technique to check whether MFA(\u03a3) |= C. In contrast, the notion of a monitor graph is specifically tied to the nonoblivious chase. It is well known that the result of the nonoblivious chase depends on the order in which the rules applied; consequently, a set of rules can be identified as cyclic or acyclic depending on the selected rule application strategy. Because of this dependence, it is difficult to compare the monitor graph approach with other acyclicity notions."}, {"heading": "4.2 Acyclicity in Knowledge Representation", "text": "Existential rules can capture knowledge representation formalisms such as Horn fragments of description logics (see Section 6), conceptual graphs (Baget, 2004; Baget et al., 2011a), and datalog\u00b1 rules (Cal\u0300\u0131 et al., 2010a), and so acyclicity notions allow for materialisationbased query answering over knowledge bases. In this context, Baget (2004) and Baget et al. (2011a) proposed the notion of acyclic graph rule dependencies (aGRD). Intuitively, aGRD introduces a rule dependency relation \u227a for which r1 \u227a r2 means that an application of rule r1 on an instance I can subsequently trigger an application of rule r2. If the relation \u227a is acyclic, then no rule can trigger itself so the skolem chase terminates on an arbitrary instance. This can be formalised as follows.\nDefinition 23. The rule dependency relation \u227a \u2286 \u03a3\u00d7 \u03a3 on a set of rules \u03a3 is defined as follows. Let r1 = \u03d51 \u2192 \u2203~y1.\u03c81 and r2 = \u03d52 \u2192 \u2203~y2.\u03c82 be arbitrary rules in \u03a3, and let sk(r1) = \u03d51 \u2192 \u03c8\u20321 and sk(r2) = \u03d52 \u2192 \u03c8\u20322. Then, r1 \u227a r2 if and only if there exist an instance I, a substitution \u03c31 for all variables in sk(r1), and a substitution \u03c32 for all variables in sk(r2) such that \u03d51\u03c31 \u2286 I, \u03d52\u03c32 6\u2286 I, \u03d52\u03c32 \u2286 I \u222a \u03c8\u20321\u03c31, and \u03c8\u20322\u03c32 6\u2286 I \u222a \u03c8\u20321\u03c31. Set \u03a3 has an acyclic graph of rules dependencies (aGRD) if the relation \u227a on \u03a3 is acyclic.\nDefinition 23 differs from the original definition by Baget (2004) in several ways. First, Baget uses fresh nulls to capture the effect of existential quantifiers, whereas Definition 23 uses skolem functions; however, this does not change the resulting relation \u227a in any way. Second, Baget does not require \u03c8\u20322\u03c32 6\u2286 I \u222a \u03c8\u20321\u03c31. This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al. (2012). It should be clear that Definition 23 is stronger than the one by Baget. To unify the notions used in various parts of this paper, we included this optimisation into Definition 23; however, we nevertheless call the resulting stronger notion aGRD.\nThe following example shows that aGRD, even in its weaker form as originally proposed by Baget (2004), is not contained in SWA.\nExample 24. Let \u03a3 be the set consisting of the following rule:\nr = A(z1, x, z2) \u2227B(z2)\u2192 \u2203y1\u2203y2.A(x, y1, y2) (63)\nTo see that r \u227a r does not hold, consider the skolemisation r\u2032 of r:\nsk(r) = A(z1, x, z2) \u2227B(z2)\u2192 A(x, f1(x), f2(x)) (64)\nNow let I be an arbitrary instance, and let \u03c31 and \u03c32 be arbitrary substitutions such that {A(z1, x, z2)\u03c31, B(z2)\u03c31} \u2286 I and {A(z1, x, z2)\u03c32, B(z2)\u03c32} 6\u2286 I. Since instance I contains only constants, atom A(x, f1(x), f2(x))\u03c31 is of the form A(a, f1(a), f2(a)); but then, for {A(z1, x, z2)\u03c32, B(z2)\u03c32} \u2286 I \u222a {A(a, f1(a), f2(a))} to hold, it must be that \u03c32(z2) = f2(a); thus, B(z2)\u03c32 = B(f2(a)) should be contained in I, which is impossible since I is an instance and thus does not contain functional terms. Note that the additional condition by Greco et al. (2012) plays no role here. Thus, we have r 6\u227a r, so \u03a3 is aGRD even in the weaker form by Baget (2004). However, one can easily check that \u03a3 is not SWA. \u2666\nHowever, aGRD seems to be a rather weak notion: as the following example shows, even a set of rules without existential quantifiers can be cyclic according to this criterion.\nExample 25. Let \u03a3 be the set consisting of the following rules:\nr1 = A(x)\u2192 B(x) (65) r2 = B(x)\u2192 C(x) (66) r3 = C(x)\u2192 A(x) (67)\nTo see that r1 \u227a r2, let I = {A(a)}, let \u03c3 = {x 7\u2192 a}, and note that A(x)\u03c3 \u2208 I, B(x)\u03c3 6\u2208 I, B(x)\u03c3 \u2208 I \u222a {B(x)\u03c3}, and C(x)\u03c3 6\u2208 I \u222a {B(x)\u03c3}. Analogously, by taking I = {B(a)} we get r2 \u227a r3, and by taking I = {C(a)} we get r3 \u227a r1. Consequently, \u03a3 is not aGRD. However, \u03a3 is obviously WA since it does not contain existentially quantified variables. \u2666\nBaget et al. (2011a) suggested that rule dependencies become more powerful if they are combined with an arbitrary acyclicity notion X. Intuitively, the main idea is to use \u227a to partition a set of rules into strongly connected components, and then check whether each component is X; we call this notion X\u227a. This idea can be formalised as follows.\nDefinition 26. Let \u03a3 be a set of existential rules, and let \u227a be the rule dependency relation on \u03a3. Relation \u227a is extended to arbitrary sets C \u2286 \u03a3 and C \u2032 \u2286 \u03a3 such that C \u227a C \u2032 if and only if rules r \u2208 C and r\u2032 \u2208 C \u2032 exist such that r \u227a r\u2032. A dependency partition of \u03a3 is a sequence of sets \u03a31, . . . ,\u03a3n such that \u03a3 = \u22c3n i=1 \u03a3i, each \u03a3i is a strongly connected component of \u227a, and \u03a3j 6\u227a \u03a3i for all i and j such that 1 \u2264 i < j \u2264 n. Let X be an arbitrary acyclicity notion. Then, \u03a3 \u2208 X\u227a if a dependency partition \u03a31, . . . ,\u03a3n of \u03a3 exists such that, for each 1 \u2264 i \u2264 n, we have \u03a3i \u2208 X, or \u03a3i consists of a single rule ri such that ri 6\u227a ri.\nIf \u03a3 is aGRD, then each strongly connected component \u03a3i contains a single rule ri such that ri 6\u227a ri. Now if Definition 26 did not consider the special case where \u03a3i consists of a single rule that does not depend on itself, then SWA\u227a would not extend aGRD; for example, the rule in Example 24 would not be in SWA\u227a. The extra condition in Definition 26 thus ensures that aGRD is contained in X\u227a regardless of the choice of X, and that aGRD can be understood as \u2205\u227a\u2014the acyclicity notion obtained by extending the empty notion (i.e., the notion under which no rule set is acyclic) with rule dependencies.\nWe next present two simple results. Proposition 27 precludes inclusions between certain acyclicity notions and will thus help us establish proper inclusions between many acyclicity notions. Furthermore, Proposition 28 shows that combining an acyclicity notion contained in SWA with rule dependencies creates a strictly stronger acyclicity notion; note that this holds even for the weaker form of rule dependencies originally proposed by Baget (2004).\nProposition 27. Let X and Y be acyclicity notions such that X \u2286 Y . Then, X\u227a \u2286 Y \u227a. Furthermore, if there exists a set \u03a3 \u2208 Y \\X whose rule dependency relation has a cycle containing all the rules from \u03a3, then Y 6\u2286 X\u227a, Y \u227a 6\u2286 X\u227a, and X\u227a ( Y \u227a.\nProof. Relationship X\u227a \u2286 Y \u227a is immediate from Definition 26. Assume now that there exists a set of rules \u03a3 \u2208 Y \\X whose rule dependency relation has a cycle containing all the rules from \u03a3. By Definition 26, \u03a3 6\u2208 X implies \u03a3 6\u2208 X\u227a, and \u03a3 \u2208 Y implies \u03a3 \u2208 Y \u227a. But then, we clearly have Y 6\u2286 X\u227a and Y \u227a 6\u2286 X\u227a, and the latter clearly implies X\u227a ( Y \u227a.\nProposition 28. For each acyclicity notion X such that X \u2286 SWA, we have X ( X\u227a and aGRD 6\u2286 X.\nProof. Set \u03a3 from Example 24 is in aGRD and thus in X\u227a; however, \u03a3 is not in SWA and hence not in X either.\nMSA also does not contain aGRD; however, unlike for SWA, our claim depends on the optimisation in Definition 23. An analysis of the relationship between MSA and the version of rule dependencies originally proposed by Baget (2004) is out of scope of this paper.\nExample 29. Let \u03a3 be the set consisting of the following rules:\nr1 = R(x1, x1) \u2227 U(x1, z) \u2227 U(x2, z)\u2192 R(x1, x2) (68) r2 = R(z, x)\u2192 \u2203y.T (x, y) (69) r3 = T (z, x)\u2192 \u2203y.U(x, y) (70)\nIt is obvious that r1 \u227a r2, r1 6\u227a r3, r2 6\u227a r1, r2 6\u227a r2, r2 \u227a r3, r3 6\u227a r2, and r3 6\u227a r3. We next argue that r1 6\u227a r1 and r3 6\u227a r1, which implies that \u03a3 is aGRD.\nTo see that r1 6\u227a r1, assume that an application of r1 to an instance I produces an atom of the form R(a, b); due to atom R(x1, x1) in the body of r1, we have R(a, a) \u2208 I. Now let I \u2032 = I \u222a {R(a, b)}; since R(a, a) \u2208 I, the rule application derives \u2018something new\u2019 only if a 6= b. Now assume that a substitution \u03c32 exists that makes r1 applicable to I \u2032 but not to I; this rule application must \u2018use\u2019 the fact R(a, b), which implies that R(x1, x1)\u03c32 = R(a, b); however, this is impossible since a 6= b. Consequently, we have r1 6\u227a r1, and this holds even for the version of rule dependencies by Baget (2004).\nFurthermore, to see that r3 6\u227a r1, assume that r3 is applicable to an instance I, and that the rule application derives a fact of the form U(a, f(a)). Now let I \u2032 = I \u222a {U(a, f(a))}, and assume that a substitution \u03c32 exists that makes r1 applicable to I\n\u2032 but not to I; this rule application must \u2018use\u2019 the fact U(a, f(a)), which implies that \u03c32(x1) = \u03c32(x2) = a and \u03c32(z) = f(a). Furthermore, rule r1 is applicable only if R(a, a) \u2208 I; but then, the rule application does not derive \u2018something new\u2019 since R(x1, x2)\u03c32 = R(a, a). Consequently, we have r3 6\u227a r1; however, unlike in the previous paragraph, this claim depends on the optimisation in Definition 23.\nConsider now the chase of I\u2217\u03a3 and MSA(\u03a3) as shown below (facts involving the predicates D, Fr2, and Fr3 are omitted for clarity). The chase result contains C, so \u03a3 is not in MSA, and thus aGRD 6\u2286 MSA; as a corollary, we also get MSA ( MSA\u227a.\nR(\u2217, \u2217) T (\u2217, cr2) U(cr2 , cr3) R(\u2217, cr2) T (cr2 , cr2) C T (\u2217, \u2217) U(\u2217, cr3) S(cr2 , cr3) S(cr2 , cr2) U(\u2217, \u2217) S(\u2217, cr2)\nS(\u2217, cr3)\nNote that R(\u2217, cr2) is derived from R(\u2217, \u2217), U(\u2217, cr3), and U(cr2 , cr3), where the latter two facts are obtained from distinct instantiations of MSA(r3). Rule dependencies, however, analyse rule applicability w.r.t. sk(r3), which is closer to the actual skolem chase. \u2666\nIn contrast to this result, in Theorem 32 we will show that extending MFA with rule dependencies does not create a stronger notion: MFA\u227a coincides with MFA, which implies that X\u227a \u2286 MFA for each notion X such that X \u2286 MFA. Towards this goal, we show in Lemma 30 that independent rule sets can be evaluated independently, and in Lemma 31 that a single rule that does not depend on itself can be applied only once.\nLemma 30. Let \u03a31 and \u03a32 be sets of existential rules such that \u03a32 6\u227a \u03a31, and let F be a set of ground facts not containing a function symbol in sk(\u03a32). Then, F \u221e \u03a31\u222a\u03a32 = (F \u221e \u03a31 )\u221e\u03a32.\nProof. Let F0 = F \u221e \u03a31\n; let F0, F1, . . . be the chase sequence for F0 and \u03a32 where, for convenience, we assume each Fi to be obtained from Fi\u22121 by a single rule application (this assumption is clearly w.l.o.g.); and let F \u2032 = (F0) \u221e \u03a32\n. By the definition of the skolem chase, we clearly have F \u2032 \u2286 F\u221e\u03a31\u222a\u03a32 . Furthermore, assume that F \u221e \u03a31\u222a\u03a32 6\u2286 F\n\u2032; then, a skolemised rule r1 \u2208 sk(\u03a31) of the form r1 = \u03d51(~x1)\u2192 \u03c81(~x1) exists such that F \u2032 ( r1(F \u2032). Fix the smallest i such that Fi ( r1(Fi) (we clearly have i > 0), and let \u03c31 be the substitution used in the application of r1. Furthermore, let r2 \u2208 sk(\u03a32) be the skolemised rule of the form\nr2 = \u03d52(~x2)\u2192 \u03c82(~x2) that is used to derive Fi from Fi\u22121, and let \u03c32 be the substitution used in the application of r2. Now consider an arbitrary term f(~x2) in the head of r2 and assume that f(~x2)\u03c32 occurs in Fi\u22121; since the function symbol f is \u2018private\u2019 to r2, the head of r2 must have been already instantiated for \u03c32; but then, \u03c82\u03c32 \u2286 Fi\u22121, which contradicts our assumption that \u03c82\u03c32 \u2208 Fi \\ Fi\u22121. Thus, we have the following property (?):\nfor each term f(~x2) occurring in the head of r2, ground term f(~x2)\u03c32 does not occur in Fi\u22121.\nFinally, let \u03b4 be a function that maps each ground term in Fi\u22121 to a fresh distinct constant; let I = \u03b4(Fi\u22121); let \u03c3 \u2032 2 be the substitution defined by \u03c3 \u2032 2(w) = \u03b4(\u03c32(w)) for each variable w in r2; and let \u03c3 \u2032 1 be the substitution defined as follows for each variable w in r1:\n\u2022 \u03c3\u20321(w) = f(\u03b4(~t)) if \u03c31(w) = f(~t) for f a function symbol \u2018private\u2019 to r2; and\n\u2022 \u03c3\u20321(w) = \u03b4(\u03c31(w)) otherwise.\nWe clearly have \u03d52\u03c3 \u2032 2 \u2286 I and \u03c82\u03c3\u20322 6\u2286 I; furthermore, by (?), we also have \u03d51\u03c3\u20321 \u2286 I \u222a \u03c82\u03c3\u20322 and \u03c81\u03c3 \u2032 1 6\u2286 I \u222a \u03c82\u03c3\u20322. Moreover, \u03d51\u03c3\u20321 6\u2286 I follows from our assumption that i is the smallest integer such that Fi ( r1(Fi). But then, by Definition 23, we have r2 \u227a r1 and, consequently, \u03a32 \u227a \u03a31 as well, which is a contradiction.\nLemma 31. Let \u03a3 = {r} be a singleton rule set such that r 6\u227a r, and let F be a set of facts not containing a function symbol in sk(\u03a3). Then, F\u221e\u03a3 = \u03a3(F ).\nProof. Let F0 = F , and let F0, F1, . . . be sets of facts such that each Fi+1 is the union of Fi with the result of a distinct single application of r to F0; clearly, \u22c3 i Fi = \u03a3(F0). Now\nassume that \u22c3 i Fi ( \u03a3( \u22c3 i Fi); then analogously to the proof of Lemma 30, one can show that r \u227a r, which is a contradiction; we omit the details for the sake of brevity.\nTheorem 32. Let \u03a3 be an arbitrary set of rules and let I be an arbitrary instance. If \u03a3 is MFA\u227a w.r.t. I, then \u03a3 is also MFA w.r.t. I.\nProof. Assume that \u03a3 is in MFA\u227a; let I be an arbitrary instance; let \u03a31, . . . ,\u03a3n be a dependency partition of \u03a3; let \u03a50 = \u2205 and I0 = I; and, for each 1 \u2264 i \u2264 n, let \u03a5i = \u22c3i `=1 \u03a3` and Ii = (Ii\u22121) \u221e \u03a3i\n. By the definition of dependency partitions, we have that \u03a3i 6\u227a \u03a5i\u22121 holds for each 1 \u2264 i \u2264 n. We next show that, for each 0 \u2264 i \u2264 n, the following two properties hold:\n(a) Ii = (I0) \u221e \u03a5i , and\n(b) Ii does not contain a cyclic term.\nSet I0 does not contain functional terms and hence it trivially satisfies (a) and (b). Now consider arbitrary 0 < i < n such that Ii\u22121 satisfies (a) and (b). By the induction assumption, Lemma 30, \u03a3i 6\u227a \u03a5i\u22121, and \u03a5i = \u03a3i \u222a\u03a5i\u22121, we have that (I0)\u221e\u03a5i = ((I0) \u221e \u03a5i\u22121\n)\u221e\u03a3i ; thus, Ii satisfies (a). To see that Ii satisfies (b), note that no function symbol used to skolemise the rules in \u03a3i is used to skolemise the rules in \u03a5i\u22121; we call this property (?). Now there are two ways to compute Ii.\n\u2022 Assume that \u03a3i = {ri} such that ri 6\u227a ri. By Lemma 31, we have Ii = ri(Ii\u22121); but then, Ii does not contain a cyclic term due to (?).\n\u2022 If \u03a3i is MFA, then Ii does not contain a cyclic term due to (?) and Proposition 5.\nFrom the above claim we have that In = I \u221e \u03a5n = I\u221e\u03a3 and that In does not contain a cyclic term; but then, \u03a3 is MFA w.r.t. I by Proposition 5.\nCombinations of rule dependencies with acyclicity notions have also been considered in databases: Deutsch et al. (2008) proposed a notion of stratification, and Meier et al. (2009) further developed this idea and proposed a notion of c-stratification. Roughly speaking, each such notion checks whether all strongly connected components of a certain rule dependency graph are WA. The rule dependency notions, however, were developed for the nonoblivious chase and are thus different from Definition 23, as illustrated by the following rule:\nr = R(z, x)\u2192 \u2203y.R(x, y) \u2227R(y, y) (71)\nThe skolem chase on the critical instance for r is infinite, and r \u227a r by Definition 23. In contrast, rule r does not pose problems for the nonoblivious chase. In particular, assume that the rule is matched to an atom R(t1, t2), and that it derives R(t2, t3) and R(t3, t3). Then, rule r is not applicable to R(t2, t3) or R(t3, t3) since in either case the head atom is satisfied; hence, the rule dependency graphs by Deutsch et al. and Meier et al. are both empty. These results can be summarised as follows: if a rule set \u03a3 satisfies the notion by Deutsch et al., then for each instance I there exists a finite nonoblivious chase sequence; furthermore, if \u03a3 satisfies the notion by Meier et al., then for each instance I all chase sequences (regardless of the rule application strategy) are finite. Meier (2010) discusses in detail the subtle differences between these notions. Since these notions consider a different chase variant, we do not discuss them any further in this paper."}, {"heading": "4.3 Acyclicity and Logic Programming", "text": "Acyclicity notions have also been considered in the context of disjunctive logic programs with function symbols under the answer set semantics, with the goal of ensuring that a given program has finitely many answer sets, all of which are finite. All of these notions must deal with disjunction and nonmonotonic negation, which is one of the main differences to the notions considered thus far. All notions from logic programming, however, are applicable to rules without disjunction and nonmonotonic negation, in which case they ensure termination of the skolem chase. Therefore, in this section we compare such specialisations of the acyclicity notions from logic programming with aGRD, WA, JA, SWA, MSA, and MFA. We simplify all definitions so that they apply only to skolemised existential rules\u2014that is, we do not present parts of definitions that handle disjunctions in the head and nonmonotonic negation and function symbols in the body."}, {"heading": "4.3.1 Finite Domain Notion", "text": "Calimeri et al. (2008) proposed a finite domain (FD) notion. We next recapitulate this definition, but we do so in the style of Greco et al. (2012), which will come useful in Section 4.3.3 when we introduce \u0393-acyclicity. Both approaches use an argument graph to determine possible ways for propagating ground terms between positions during chase. The definition of the argument graph is the same as that of the WA dependency graph (see Section 2.4),\nbut without the distinction between regular and special edges. To simplify the presentation, we consistently use the WA dependency graph instead of the argument graph.\nDefinition 33. Let \u03a3 be a set of rules. A position P |i is \u03a3-recursive with a position Q|j if the WA dependency graph WA(\u03a3) contains a cycle (consisting of regular and/or special edges) going through P |i and Q|j. The set PosFD(\u03a3) of finite domain positions of \u03a3 is the largest set of positions in \u03a3 such that, for each position P |i \u2208 PosFD(\u03a3), each rule r \u2208 \u03a3 of the form r = \u03d5(~x, ~z)\u2192 \u2203~y.\u03c8(~x, ~y), and each head atom of r of the form P (~t), the following conditions are satisfied:\n\u2022 if the i-th component of ~t is a variable x \u2208 ~x, then PosB(x) \u2229 PosFD(\u03a3) 6= \u2205; and\n\u2022 if the i-th component of ~t is a variable y \u2208 ~y, then, for each variable x \u2208 ~x, some position Q|j \u2208 PosB(x) \u2229 PosFD(\u03a3) exists that is not \u03a3-recursive with P |i.\nSet \u03a3 is FD if PosFD(\u03a3) coincides with the set of all positions in \u03a3.\nNote that the notion of \u03a3-recursive positions introduced above is symmetric: if P |i is \u03a3-recursive with Q|j , then Q|j is also \u03a3-recursive with P |i. Furthermore, note that Calimeri et al. (2008) defined FD as follows:\nA set of rules \u03a3 is FD if, for each rule r = \u03d5(~x, ~z)\u2192 \u2203~y.\u03c8(~x, ~y) in \u03a3, each atom Q(~t) in the head of r, each j-th term of ~t that is an existential variable y, and each variable x \u2208 ~x, there exists a position P |i \u2208 PosB(x) such that Q|j is not \u03a3-recursive with P |i.\nConditions in the above definition clearly correspond to the conditions in Definition 33; but then, since PosFD(\u03a3) was defined as the maximal set satisfying these conditions, the two definitions of FD coincide.\nWe next show that WA is strictly contained in FD. To this end, we first prove that WA is contained in FD, and then we present an example showing that the inclusion is strict.\nProposition 34. If a set of rules \u03a3 is WA, then \u03a3 is FD.\nProof. Let \u03a3 be a set of rules that is not FD. Then, there exist a rule r \u2208 \u03a3, an atom Q(~t) in the head of r, a j-th term of ~t equal to an existential variable y, and a variable x \u2208 ~x such that each position P |i \u2208 PosB(x) is \u03a3-recursive with Q|j . The set PosB(x) is not empty (~x contains precisely those variables occurring both in the body and the head of the rule), so choose an arbitrary position P |i \u2208 PosB(x). The WA dependency graph WA(\u03a3) then contains a special edge from P |i to Q|j . Furthermore, since Q|j is \u03a3-recursive with P |i, graph WA(\u03a3) contains a cycle going through P |i and Q|j . Thus, WA(\u03a3) clearly contains a cycle containing a special edge, so \u03a3 is not WA.\nExample 35. Let \u03a3 be the set containing rules (72) and (73).\nr1 = R(z, x) \u2227A(x)\u2192 \u2203y.S(x, y) (72) r2 = S(x1, x2)\u2192 R(x1, x2) (73)\nSet \u03a3 is not WA since the WA dependency graph contains a special edge from R|2 to S|2 and a regular edge from S|2 to R|2. However, \u03a3 is FD because position S|2 is not \u03a3-recursive with A|1 \u2208 PosB(x). Together with Proposition 34, we can conclude that WA ( FD.\nIn addition, we have r1 \u227a r2 and r2 \u227a r1. In Section 4.3.2 we will prove that FD \u2286 JA; hence, FD ( FD\u227a, WA\u227a ( FD\u227a, and FD 6\u2286WA\u227a from Propositions 27, 28, and 34. \u2666"}, {"heading": "4.3.2 Argument-Restricted Rule Sets", "text": "Lierler and Lifschitz (2009) proposed the notion of argument-restricted rule sets, whose definition we summarise next.\nDefinition 36. An argument ranking for a set of rules \u03a3 is a function \u03b1 that assigns a nonnegative integer to each position in \u03a3 such that the following conditions are satisfied for each rule r \u2208 \u03a3, each universally quantified variable x in r, and each existentially quantified variable y in r:\n1. for each P |i \u2208 PosH(x), some Q|j \u2208 PosB(x) exists such that \u03b1(P |i) \u2265 \u03b1(Q|j); and\n2. for each P |i \u2208 PosH(y), some Q|j \u2208 PosB(x) exists such that \u03b1(P |i) > \u03b1(Q|j).\nSet \u03a3 is argument restricted (AR) if an argument ranking for \u03a3 exists.\nAn argument-restricted set of rules has a finite skolem chase on an arbitrary instance: by a straightforward induction on the chase sequence, one can show that dep(ti) \u2264 \u03b1(P |i) for each ground fact P (t1, . . . , tn) derived by the chase and each 1 \u2264 i \u2264 n.\nWe next show that JA is strictly more general than AR. Towards this goal, we first prove an auxiliary lemma that establishes a relationship between the set Move from the definition of JA and an argument ranking; next, we use this lemma to prove that AR \u2286 JA; and finally we present an example that shows this inclusion to be proper.\nLemma 37. Let \u03a3 be a set of rules, let \u03b1 be an argument ranking for \u03a3, let y be an existentially quantified variable in \u03a3, and let Move(y) be the set of positions used in the definition of JA. For each position P |i \u2208 Move(y), some position Q|j \u2208 PosH(y) exists such that \u03b1(P |i) \u2265 \u03b1(Q|j) holds.\nProof. Let y be an existentially quantified variable occurring in some rule r \u2208 \u03a3, and consider an arbitrary position P |i \u2208 Move(y). We prove the claim by induction on the definition of Move(y). The base case when P |i \u2208 PosH(y) is trivial. Assume now that P |i \u2208 PosH(x) for some variable x occurring in a rule r\u2032 \u2208 \u03a3, and that PosB(x) \u2286 Move(y), so P |i needs to be added to Move(y). By the definition of an argument ranking and since P |i \u2208 PosH(x), position P \u2032|` \u2208 PosB(x) exists such that \u03b1(P |i) \u2265 \u03b1(P \u2032|`). But then, since P \u2032|` \u2208 PosB(x) \u2286 Move(y), by the induction hypothesis we have that position Q|j \u2208 PosH(y) exists such that \u03b1(P \u2032|`) \u2265 \u03b1(Q|j). Thus, \u03b1(P |i) \u2265 \u03b1(Q|j) holds, as required.\nTheorem 38. If a set of rules \u03a3 is AR, then \u03a3 is JA.\nProof. Assume that \u03a3 is AR, let \u03b1 be an argument ranking for \u03a3, and let JA(\u03a3) be the JA dependency graph for \u03a3. We next prove the following claim: for each edge in JA(\u03a3) from a variable y1 to a variable y2, and for each position Q|j \u2208 PosH(y2), there exists a position\nP |i \u2208 PosH(y1) such that \u03b1(P |i) < \u03b1(Q|j). Consider an arbitrary edge from y1 to y2 in JA(\u03a3) and an arbitrary position Q|j \u2208 PosH(y2). By the definition of the JA dependency graph, then the rule r that contains y2 also contains a universally quantified variable x such that x occurs in the head of r and PosB(x) \u2286 Move(y1). Since \u03b1 is an argument ranking for \u03a3, some position P \u2032|` \u2208 PosB(x) exists such that \u03b1(P \u2032|`) < \u03b1(Q|j). Since P \u2032|` \u2208 Move(y1), by Lemma 37 position P |i \u2208 PosH(y1) exists such that \u03b1(P |i) \u2264 \u03b1(P \u2032|`). Thus, we have \u03b1(P |i) < \u03b1(Q|j), and so our claim holds. But then, this claim clearly implies that the JA dependency graph JA(\u03a3) is acyclic, and therefore \u03a3 is JA.\nExample 39. Let \u03a3 be the set consisting of the following rules:\nr1 = R(z1, x1)\u2192 \u2203y1.S(x1, y1) (74) r2 = R(z2, x2)\u2192 \u2203y2.S(y2, x2) (75) r3 = S(x3, x4)\u2192 T (x3, x4) (76) r4 = T (x5, x6) \u2227 T (x6, x5)\u2192 R(x5, x6) (77)\nLet \u03b1 be an argument ranking for \u03a3. Then, \u03b1(R|2) < \u03b1(S|2) due to (74); \u03b1(R|2) < \u03b1(S|1) due to (75); \u03b1(S|1) \u2264 \u03b1(T |1) and \u03b1(S|2) \u2264 \u03b1(T |2) due to (76); and \u03b1(T |2) \u2264 \u03b1(R|2) or \u03b1(T |1) \u2264 \u03b1(R|2) due to (77). Together, these observations are contradictory, so such \u03b1 cannot exist and \u03a3 is not AR. In contrast, Move(y1) = {S|2, T |2} and Move(y2) = {S|1, T |1}, and so \u03a3 is JA.\nIn addition, we have r1 \u227a r3, r2 \u227a r3, r3 \u227a r4, r4 \u227a r1, and r4 \u227a r2; hence, we have AR ( AR\u227a, AR\u227a ( JA\u227a, and JA 6\u2286 AR\u227a from Theorem 38 and Propositions 27 and 28. \u2666\nLierler and Lifschitz (2009, Thm. 4) proved that AR is strictly more general than FD. We next present an example that shows FD ( AR, but that also settles the relationships between FD\u227a and AR\u227a.\nExample 40. Let \u03a3 be the set consisting of the following rules:\nr1 = A(x)\u2192 \u2203y.R(x, y) (78) r2 = R(x1, x2)\u2192 S(x1, x2) (79) r3 = S(z, x) \u2227B(x)\u2192 A(x) (80)\nThe WA dependency graph for \u03a3 contains a special edge from A|1 to R|2, as well as regular edges from R|2 to S|2 and from S|2 to A|1; thus, R|2 is \u03a3-recursive with A|1. Consequently, rule (78) cannot satisfy the conditions in Definition 33, so we have R|2 6\u2208 PosFD(\u03a3), and thus \u03a3 is not FD. In contrast, \u03a3 is AR, as evidenced by the following argument ranking:\n\u03b1 = {A|1 7\u2192 0, B|1 7\u2192 0, R|1 7\u2192 0, R|2 7\u2192 1, S|1 7\u2192 0, S|2 7\u2192 1}\nIn addition, we have r1 \u227a r2, r2 \u227a r3, and r3 \u227a r1; hence, FD ( FD\u227a, FD\u227a ( AR\u227a, and AR 6\u2286 FD\u227a from Propositions 27 and 28. \u2666\nFinally, we note that \u03bb-restricted programs by Gebser et al. (2007) and \u03c9-restricted programs by Syrja\u0308nen (2001) are both included in FD and AR; thus, when restricted to skolemised existential rules, these notions are also included in JA."}, {"heading": "4.3.3 \u0393-Acyclicity", "text": "Greco et al. (2012) recently proposed the notion of \u0393-acylicity for logic programs with function symbols. The original definition of \u0393-acyclicity is rather complex, so we next present a simplified version of \u0393-acyclicity that is applicable to existential rules. To unify the naming style for the notions in this paper, we often write \u0393-acyclicity as \u0393A.\nGreco et al. (2012) introduce a notion of an activation graph, which tracks whether a rule can trigger another rule. This notion is closely related to the notion of rule dependencies from Definition 23, but with the requirement that I is an arbitrary finite set of ground facts (possibly containing functional terms). To understand why the latter is needed in logic programming, consider the following logic program:\nr1 = A(x) \u2227B(x)\u2192 A(f(x)) (81) r2 = A(x) \u2227B(x)\u2192 B(f(x)) (82)\nIf we restrict the set I in Definition 23 to be an instance, then r1 6\u227a r2 and r2 6\u227a r1; however, the skolem chase of r1, r2, and facts A(a) and B(a) is infinite. Intuitively, r1 and r2 contain the same function symbol f , so to determine whether an application of r1 can trigger an application of r2, we must allow the set I in Definition 23 to contain facts such as B(f(a)). In our setting, however, function symbols are introduced by skolemisation and are thus \u2018private\u2019 to each rule, which allows us to restrict the set I in Definition 23 to facts without functional terms. Thus, in the rest of this section, we simply reuse the rule dependency relation \u227a from Definition 23, which gives us a slightly stronger version of \u0393A for existential rules than the one proposed by Greco et al. (2012).\nFurthermore, Greco et al. (2012) handle logic programming rules with functional terms in the body. Such rules, however, are not considered in this paper, which allows us to omit the definition of a labelled argument graph and simplify the notion of a propagation graph to a subset of the WA dependency graph.\nWe are now ready to present a simplified version of \u0393-acyclicity that is applicable to existential rules.\nDefinition 41. Let \u03a3 be a set of rules. The rule dependency relation \u227a is taken from Definition 23, and the set of finite domain positions PosFD(\u03a3) is taken from Definition 33.\nThe set of safe positions of \u03a3, written PosS(\u03a3), is the least set of the positions of \u03a3 such that PosFD(\u03a3) \u2286 PosS(\u03a3), and P |i \u2208 PosS(\u03a3) if and only if, for each rule r \u2208 \u03a3, at least one of the following conditions is satisfied:\n\u2022 if P occurs in the head of r, then \u227a does not contain a cycle going through r, or\n\u2022 for each atom P (~t) in the head of sk(r) and each variable x that occurs in i-th component of ~t, we have PosB(x) \u2229 PosS(\u03a3) 6= \u2205.\nA position is affected if it is not safe. The propagation graph PG(\u03a3) for \u03a3 has the affected positions of \u03a3 as vertices, and the edges of PG(\u03a3) are defined as in weak acyclicity, but restricted to affected positions. The set \u03a3 is \u0393-acyclic (\u0393A) if PG(\u03a3) does not contain a cycle that involves a special edge.\nIn order to relate \u0393A to the notions considered thus far, we first establish some containment relationships. It is obvious from Definition 41 that FD \u2286 \u0393A: if all positions in \u03a3 are finite domain, then they are also safe and so the propagation graph is empty. Furthermore, the set of rules in Example 40 is actually \u0393A (all positions are safe), but not FD; hence, by Proposition 27, we have that FD ( \u0393A, FD\u227a ( \u0393A\u227a, and \u0393A 6\u2286 FD\u227a. Next, Proposition 42 observes that aGRD is contained in \u0393A, and Theorem 43 shows that, perhaps somewhat surprisingly, \u0393A\u227a is contained in AR\u227a.\nProposition 42. If a set of rules \u03a3 is aGRD, then \u03a3 is \u0393A.\nProof. If the rule dependency relation \u227a on \u03a3 is acyclic, then by the first safety condition in Definition 41 all positions in \u03a3 are safe; but then, PG(\u03a3) is empty, and so \u03a3 is \u0393A.\nTheorem 43. If a set of rules \u03a3 is \u0393A\u227a, then \u03a3 is AR\u227a.\nProof. The claim clearly follows from the following property: if the rule dependency relation \u227a for \u03a3 has just one strongly connected component and \u03a3 is \u0393A, then \u03a3 is AR. Thus, assume that each rule r \u2208 \u03a3 occurs on a cycle of \u227a. We next construct a mapping \u03b1 that assigns a nonnegative integer to each position in \u03a3, and then we show that \u03b1 is an argument ranking for \u03a3. In the rest of this proof, we write p1 p2 if WA(\u03a3) (see Section 2.4) contains a path (consisting of regular and/or special edges) from position p1 to position p2.\nDue to our assumption on \u03a3, the first item in Definition 41 never applies. Furthermore, let \u03a8 be the function that maps a set S of positions into another set of positions as follows:\n\u03a8(S) = S \u222a {P |i | PosB(x) \u2229 S 6= \u2205 for each r \u2208 \u03a3, each atom P (~t) in the head of sk(r), and each variable x occurring in the i-th component of ~t}\nLet \u03a80(S) = S, \u03a8k(S) = \u03a8(\u03a8k\u22121(S)) for each k > 0, and \u03a8\u221e(S) = \u22c3\n\u03a8k(S). From Definition 41 it is obvious that PosS(\u03a3) = \u03a8\n\u221e(PosFD(\u03a3)). We next define the mapping \u03b1. In the rest of this proof, let Y be the set containing each position p \u2208 PosFD(\u03a3) for which an existentially quantified variable y in \u03a3 exists such that p \u2208 PosH(y). Furthermore, we use a convention that max \u2205 = 0.\n\u2022 For each position p \u2208 PosFD(\u03a3), we define \u03b1(p) as follows:\n\u03b1(p) = { |{p\u2032 \u2208 Y | p\u2032 p and p\u2032 6= p}|+ 1 if p \u2208 Y |{p\u2032 \u2208 Y | p\u2032 p}| if p 6\u2208 Y\n\u2022 For each position p \u2208 PosS(\u03a3) \\ PosFD(\u03a3), we define \u03b1(p) as follows: \u03b1(p) = [ min{k | p \u2208 \u03a8k(PosFD(\u03a3))} ] + [max{\u03b1(q) | q \u2208 PosFD(\u03a3)}]\n\u2022 For each position p in \u03a3 with p 6\u2208 PosS(\u03a3), we define \u03b1(p) as follows, where m(p) is the maximum number of special edges occurring in PG(\u03a3) on a path ending at p:\n\u03b1(p) = m(p) + 1 + [max{\u03b1(q) | q \u2208 PosS(\u03a3)}]\nSince \u03a3 is \u0393A\u227a, PG(\u03a3) does not contain a cycle involving a special edge, so m(p) is always a nonnegative integer and \u03b1(p) is correctly defined.\nWe next show that \u03b1 is an argument ranking\u2014that is, that it satisfies all conditions of Definition 36. To this end, consider an arbitrary rule r \u2208 \u03a3, an arbitrary existentially quantified variable y in r, an arbitrary universally quantified variable x in r, and an arbitrary position P |i \u2208 PosH(y); we have the following cases.\n\u2022 P |i \u2208 PosFD(\u03a3). By Definition 33, position Q|j \u2208 PosB(x) \u2229 PosFD(\u03a3) exists that is not \u03a3-recursive with P |i. Thus, we have P |i 6 Q|j ; furthermore, Q|j P |i by the definition of WA(\u03a3). Together, the latter two properties imply the following:\n{p\u2032 \u2208 Y | p\u2032 Q|j and p\u2032 6= Q|j} \u2286 {p\u2032 \u2208 Y | p\u2032 P |i and p\u2032 6= P |i}\nIf Q|j \u2208 Y , this inclusion is strict since Q|j is contained in the set on the righthand side, but not in the set on the left-hand side; thus, \u03b1(Q|j) < \u03b1(P |i) holds, as required. If Q|j 6\u2208 Y , then \u03b1(Q|j) < \u03b1(P |i) holds since the definition of \u03b1 ensures that \u03b1(P |i)\u2212 \u03b1(Q|j) is at least 1.\n\u2022 P |i \u2208 PosS(\u03a3) \\ PosFD(\u03a3). Let k be the smallest number with P |i \u2208 \u03a8k(PosFD(\u03a3)). By the definition of \u03a8, there exists a position Q|j \u2208 PosB(x) \u2229\u03a8k\u22121(PosFD(\u03a3)), so k \u2212 1 \u2265 \u03b1(Q|j) by the definition of \u03b1. Thus, \u03b1(P |i) > \u03b1(Q|j) holds, as required.\n\u2022 P |i 6\u2208 PosS(\u03a3). The first possibility is that some position Q|j \u2208 PosB(x) \u2229 PosS(\u03a3) exists; but then, by the definition of \u03b1, we have \u03b1(Q|j) < \u03b1(P |i), as required. The second possibility is that there exists some affected position Q|j \u2208 PosB(x); but then, Q|j has at least one less incoming special edge in PG(\u03a3) than P |i; thus, we also have \u03b1(Q|j) < \u03b1(P |i), as required.\nTo complete the proof, we must also consider an arbitrary position P |i \u2208 PosH(x); however, the cases are analogous as above, so we omit them for the sake of brevity.\nTo place \u0393A precisely in the landscape of acyclicity notions, we present three examples that disprove relevant containment relationships. Greco et al. (2012) stated that AR is strictly contained in \u0393A, but we were unable to find a formal proof of that statement; in fact, Example 44 shows that this is not the case, and that actually \u0393A\u227a ( AR\u227a holds. Moreover, Example 45 shows that \u0393A 6\u2286 MSA. Finally, Example 46 shows that WA\u227a 6\u2286 \u0393A.\nExample 44. Let \u03a3 be the set consisting of the following rules:\nr1 = A(x)\u2192 \u2203y.R(x, y) (83) r2 = R(x1, x2)\u2192 S(x1, x2) (84) r3 = S(z, x) \u2227B(x)\u2192 A(x) (85) r4 = R(z, x)\u2192 T (x, x) (86) r5 = T (x, z)\u2192 R(x, x) (87) r6 = T (z1, x) \u2227R(z2, x)\u2192 \u2203y.T (x, y) (88)\nOne can readily verify that the following mapping of positions to nonnegative integers is an argument ranking for \u03a3:\n\u03b1 = {A|1 7\u2192 0, B|1 7\u2192 0, R|1 7\u2192 1, R|2 7\u2192 1, S|1 7\u2192 1, S|2 7\u2192 1, T |1 7\u2192 1, T |2 7\u2192 2}\nWe next argue that \u03a3 is not \u0393A. First, the rule dependency relation in \u03a3 holds (at least) between the pairs of rules shown below. Thus, each rule in \u03a3 occurs in \u227a on a cycle, and so \u03a3 is the only strongly connected component of \u227a.\nr1 \u227a r2 r2 \u227a r3 r3 \u227a r1 r1 \u227a r4 r4 \u227a r5 r5 \u227a r2 r5 \u227a r6 r6 \u227a r5\nSecond, the WA dependency graph for \u03a3 contains a special edge from A|1 to R|2 due to rule r1, a regular edge from R|2 to S|2 due to rule r2, and a regular edge from S|2 to A|1due to rule r3; consequently, R|2 is \u03a3-recursive with A|1; but then, rule r1 does not satisfy the conditions in Definition 33, and so R|2 6\u2208 PosFD(\u03a3). Furthermore, due to rule r4, we have T |1 6\u2208 PosFD(\u03a3) and T |2 6\u2208 PosFD(\u03a3) as well. Finally, R|1 6\u2208 PosFD(\u03a3) due to rule r5. Consequently, the set of finite domain positions is given by PosFD(\u03a3) = {A|1, B|1, S|1}.\nThird, we argue that PosS(\u03a3) = PosFD(\u03a3). In particular, there is no need to extend PosS(\u03a3) with R|2: position R|2 occurs in the head of rule r5, but since T |2 is not a finite domain position and r5 occurs on a cycle of \u227a, neither condition from Definition 41 holds. Analogously, positions T |1 and T |2 do not need to be added to PosS(\u03a3) either.\nFourth, since positions R|2, T |1, and T |2 are all affected, the propagation graph PG(\u03a3) contains a special edge from T |2 to itself due to rule r6. Consequently, \u03a3 is not \u0393A.\nFinally, since \u03a3 is the only strongly connected component of \u227a, this example also shows that AR 6\u2286 \u0393A\u227a and AR\u227a 6\u2286 \u0393A\u227a; but then, by Theorem 43, we have \u0393A\u227a ( AR\u227a. \u2666\nExample 45. Let \u03a3 be the set of rules from Example 29. As explained in the example, \u03a3 is aGRD, but not MSA and thus also not JA, AR, or FD. By Proposition 42, \u03a3 is \u0393A, which implies \u0393A 6\u2286 MSA, and thus \u0393A 6\u2286 SWA, \u0393A 6\u2286 JA, \u0393A 6\u2286 AR, and \u0393A 6\u2286 FD. \u2666\nExample 46. Let \u03a3 be the set consisting of the following rules:\nr1 = R(x1, x1)\u2192 \u2203y1\u2203y2.[A(x1) \u2227 S(y1, x1) \u2227 S(x1, y2)] (89) r2 = A(x2)\u2192 B(x2) (90) r3 = B(x3)\u2192 R(x3, x3) (91) r4 = S(x4, x4)\u2192 \u2203y3\u2203y4.[C(x4) \u2227R(y3, x4) \u2227R(x4, y4)] (92) r5 = C(x5)\u2192 D(x5) (93) r6 = D(x6)\u2192 S(x6, x6) (94)\nNote that r1 6\u227a r4 and r4 6\u227a r1, so the rule dependency relation \u227a in \u03a3 has two strongly connected components: the first one consists of r1, r2, and r3, and the second one consists of r4, r5, and r6. Moreover, each strongly connected component is WA, so \u03a3 is WA\n\u227a. In contrast, each position in \u03a3 is \u03a3-recursive with itself, so PosFD(\u03a3) = \u2205. Moreover, each position in \u03a3 occurs in the head of a rule that (i) appears in \u227a in a cycle and (ii) does not satisfy the second safety condition in Definition 41; hence, PosS(\u03a3) = \u2205, and all positions are affected. But then, PG(\u03a3) = WA(\u03a3), and so \u03a3 is not \u0393A. \u2666\nIt may seem counterintuitive that AR 6\u2286 \u0393A, but \u0393A\u227a ( AR\u227a. Intuitively, the notion of safe positions from Definition 41 uses the rule dependency relation, which allows us to construct an example that is in \u0393A but not in AR. In \u0393A\u227a, this extra condition is always applied to rules that occur in \u227a on a cycle; thus, the notion of safe positions collapses to a notion weaker than AR, which in turn allows \u0393A\u227a to be subsumed by AR\u227a."}, {"heading": "4.4 The Landscape of Acyclicity Notions", "text": "To obtain a complete picture of the relative expressiveness of the acyclicity notions considered in this paper, we make the following observations.\n\u2022 The rule set from Example 15 is MFA but not MSA, and one can readily verify that r1 \u227a r2 \u227a r3 \u227a r4 \u227a r1; but then, MSA\u227a ( MFA\u227a = MFA by Proposition 27.\n\u2022 The rule set from Example 20 is SWA but not JA, and one can readily verify that r1 \u227a r2 \u227a r3 \u227a r1; but then, JA\u227a ( SWA\u227a and SWA 6\u2286 JA\u227a by Proposition 27.\n\u2022 The rule set from Example 1 is MSA but not SWA, and one can readily verify that r1 \u227a r3 \u227a r4 \u227a r5 \u227a r2 \u227a r1; but then, SWA\u227a ( MSA\u227a and MSA 6\u2286 SWA\u227a by Proposition 27.\n\u2022 The rule set from Example 22 is aGRD: we have r1 6\u227a r1, r1 6\u227a r2, r2 6\u227a r1, and r2 6\u227a r2. Thus, aGRD 6\u2286 Adn-WA.\n\u2022 The rule set from Example 22 is FD: we can assume all positions in the rule set to be finite domain without violating conditions of Definition 33. Thus, FD 6\u2286 Adn-WA.\nThe landscape of the acyclicity notions considered in this paper is shown in Figure 1. All inclusions between notions shown in the figure are strict: if a notion X is reachable from a notion Y via one or more (directed) arcs, then X is strictly more general than Y . Furthermore, all inclusions are also complete: if a notion X is not reachable from a notion Y via one or more (directed) arcs, then X does not contain Y ."}, {"heading": "5. Handling Equality via Singularisation", "text": "Most acyclicity notions presented so far provide no special provision for the equality predicate. If a set of rules \u03a3 contains the equality predicate, one can always axiomatise equality explicitly and then check acyclicity. More precisely, the acyclicity of \u03a3 \u222a \u03a3\u2248 (under any notion introduced thus far) guarantees termination of the skolem chase of \u03a3. Furthermore, note that MFA and MSA are defined as entailment checks in first-order logic with equality, which effectively incorporates the rules of equality into these checks even if rules (1)\u2013(4) are not explicitly given; however, the effect of such a definition is the same.\nWhile handling equality explicitly may be simple, such an approach does not ensure termination of the skolem chase in many practically relevant cases. In particular, the following example shows that the equalities between terms tend to proliferate during skolem chase, which can lead to non-termination.\nExample 47. Consider the set of rules \u03a3 containing rules (95)\u2013(96).\nA(x) \u2227B(x)\u2192 \u2203y.[R(x, y) \u2227B(y)] (95) R(z, x1) \u2227R(z, x2)\u2192 x1 \u2248 x2 (96)\nThe skolem chase of I\u2217\u03a3 and \u03a3 derives the following infinite set of facts:\nR(\u2217, f(\u2217)) B(f(\u2217)) \u2217 \u2248 f(\u2217) A(f(\u2217)) R(f(\u2217), f(f\u2217))) B(f(f(\u2217))) . . .\nThus, \u03a3 is not universally MFA by Proposition 5, and by Theorem 14 it is not universally MSA either. \u2666\nIt is worth noticing that in the presence of equality WA is no longer subsumed by MFA and hence both notions become incomparable. As explained in Section 2.4, WA can be applied to rules containing the equality predicate (and without an explicit axiomatisation of equality). Under such a treatment, the rules in Example 47 are WA. This, however, does not contradict the results from Section 4: WA does not require an explicit axiomatisation of equality because it ensures termination of nonoblivious chase\u2014an optimised chase variant that expands existential quantifiers only if necessary and that handles equality by replacing equal terms with canonical representatives. In contrast, the results in Section 4 ensure termination of the skolem chase; since this chase variant uses an explicit axiomatisation of equality, all of our results hold only for equality-free rules (or, equivalently, for the rules containing an explicit axiomatisation of equality). The rules in Example 47 are not WA if equality is axiomatised explicitly, which explains the apparent mismatch with Section 4.\nIn order to use the skolem chase with rule sets such as the ones in Example 47, Marnette (2009) proposed the singularisation technique. Roughly speaking, singularisation replaces the equality predicate \u2248 with a fresh binary predicate Eq to clarify that the two are to be treated differently; furthermore, it axiomatises Eq as reflexive, symmetric, and transitive, but it does not introduce replacement rules analogous to (4); finally, it modifies the rules in \u03a3 to take the lack of the replacement rules into account. The chase of the transformed rule set is not a model of \u03a3, but it can be used to answer queries over \u03a3 in a particular welldefined way. The modification of \u03a3, however, is nondeterministic: there are many ways to modify \u03a3 and, while some may ensure termination of the skolem chase, not all are required to do so. We next recapitulate the definition of singularisation by Marnette (2009).\nDefinition 48. A marking Mr of a rule r of the form (5) is a mapping that assigns to each variable w \u2208 ~x \u222a ~z a single occurrence of w in \u03d5; the marked occurrence of w in a rule is written w . All other occurrences of w are unmarked, and all occurrences of constants are unmarked as well. For \u03a3 a set of rules, a marking M of \u03a3 contains exactly one marking Mr for each r \u2208 \u03a3. Let Eq be a fresh binary predicate not occurring in \u03a3. The singularisation of \u03a3 under M is the set Sing(\u03a3,M) that contain rules\n\u2192 Eq(x, x) (97) Eq(x1, x2)\u2192 Eq(x2, x1) (98)\nEq(x1, x2) \u2227 Eq(x2, x3)\u2192 Eq(x1, x3) (99)\nand, for each rule r \u2208 \u03a3, the rule obtained from r by replacing each atom s \u2248 t with atom Eq(s, t), and by replacing each unmarked occurrence of a term t in a body atom with a fresh variable z\u2032 and then adding atom Eq(t, z\u2032) to the rule body.\nNote that Sing(\u03a3,M) is unique up to the renaming of the fresh variables. Furthermore, note that rule (97) can be transformed into a safe rule as explained in Section 2.2. Finally, note that Sing(\u03a3,M) is equality-free (since \u2248 and Eq are different predicates); therefore, no specific treatment of equality is needed when computing its chase or checking its acyclicity.\nExample 49. Singularisation of the marked rule (100) produces rule (101).\nA(x ) \u2227B(x) \u2227R(x, z )\u2192 C(x) (100) A(x) \u2227B(x1) \u2227R(x2, z) \u2227 Eq(x, x1) \u2227 Eq(x, x2)\u2192 C(x) (101)\nNote that singularisation should be applied \u2018globally\u2019 to all rules, including the ones that do not contain the equality predicate. \u2666\nThe properties of singularisation can be summarised as follows. Let \u03a3 be a set of rules, let I be an instance, and let M be a marking for \u03a3. Furthermore, let \u03a3\u2032 = Sing(\u03a3,M), and let I \u2032 = I\u221e\u03a3\u2032 be the chase of I and \u03a3\n\u2032. Finally, note that predicate Eq is interpreted in I \u2032 as an equivalence relation, so let \u03c1 be a function that maps each term t occurring in I \u2032 to an arbitrarily chosen representative from the equivalence class of t. The first-order interpretation \u03c1(I \u2032) is defined as follows, where rng(\u03c1) is the range of the mapping \u03c1, the set 4\u03c1(I\u2032) is the universe of \u03c1(I \u2032), and (P )\u03c1(I\u2032) is the interpretation of a predicate P :\n4\u03c1(I\u2032) = rng(\u03c1) (P )\u03c1(I\n\u2032) = {\u3008\u03c1(t1), . . . , \u03c1(tn)\u3009 | P (t1, . . . , tn) \u2208 I} for each P different from Eq (Eq)\u03c1(I \u2032) = {\u3008x, x\u3009 | x \u2208 4\u03c1(I\u2032)}\nNote that \u03c1(I \u2032) interprets \u2248 as true equality\u2014that is, each term t is interpreted in \u03c1(I \u2032) as a representative of the equivalence class that contains t; hence, \u03c1(I \u2032) is not a Herbrand interpretation. Marnette (2010) showed that, for an arbitrary \u03c1, interpretation \u03c1(I \u2032) is a universal model of \u03a3 and I\u2014that is, \u03c1(I \u2032) can be homomorphically embedded into an arbitrary model of \u03a3 and I. Thus, \u03c1(I) can be used for query answering: for a Boolean conjunctive query Q, we have I \u222a \u03a3 |= Q if and only if \u03c1(I \u2032) |= Q.\nThis result can be reformulated as follows. Let \u03a3, I, M , and I \u2032 be as specified above, and let us assume that Q is of the form Q = \u2203~y.\u03d5(~y). Furthermore, let r be the following rule, and let M \u2032 be an arbitrary marking of r:\nr = \u03d5(~y)\u2192 H (102)\nThen, the above characterisation of singularisation implies that\nI \u222a \u03a3 |= Q if and only if I \u222a Sing(\u03a3 \u222a {r},M \u222aM \u2032) |= H if and only if\nI \u2032 \u222a Sing({r},M \u2032) |= H.\nHence, we can answer Q w.r.t. \u03a3 and I by evaluating Sing({r},M \u2032) in the chase of I and Sing(\u03a3,M). It is straightforward to generalise this approach to non-Boolean queries.\nThe absence of replacement rules (4) often allows the skolem chase to terminate on Sing(\u03a3,M), but this may depend on the selected marking.\nExample 50. Rule (95) from Example 47 admits the following two markings:\nA(x ) \u2227B(x)\u2192 \u2203y.[R(x, y) \u2227B(y)] (103) A(x) \u2227B(x )\u2192 \u2203y.[R(x, y) \u2227B(y)] (104)\nThe skolem chase does not universally terminate for the singularisation obtained from (104) and (96). In contrast, the singularisation obtained from (103) and (96) is JA. \u2666\nDefinition 51. For X \u2208 {MFA,MSA, JA}, acyclicity notion X\u2203 (resp. X\u2200) contains each finite set of rules \u03a3 such that Sing(\u03a3,M) \u2208 X for some (resp. each) marking M of \u03a3.\nClearly, X\u2200 \u2286 X\u2203 for each X \u2208 {MFA,MSA, JA}, and Example 50 shows this inclusion to be proper. We next show that JA\u2200 actually coincides with WA.\nTheorem 52. For \u03a3 an arbitrary finite set of rules, \u03a3 is JA\u2200 if and only if \u03a3 is WA.\nProof. (JA\u2200 \u2286WA) We prove the contrapositive, so let \u03a3 be an arbitrary set of rules that is not WA; w.l.o.g. we assume that each variable in \u03a3 occurs in at most one rule. We consider each edge from p to q in the WA dependency graph WA(\u03a3) to be a triple e = \u3008p, q, t\u3009, where t = \u00b7 if the edge is regular and t = \u2217 if the edge is special. By the definition of WA, for each such e, a rule r \u2208 \u03a3 and universally quantified variable x occurring in the head and the body of r exist such that p \u2208 PosB(x), so let xe be one such arbitrarily chosen but fixed variable; furthermore, if edge e is special, then an existentially quantified variable y exists such that q \u2208 PosH(y), so let ye be one such arbitrarily chosen but fixed variable.\nA cycle in WA(\u03a3) is a sequence of edges e1, . . . , en of the form ei = \u3008pi, qi, ti\u3009 such that qi = pi+1 for each 1 \u2264 i < n and and qn = p1. Such a cycle is dangerous if an edge ek exists that is special; and such a cycle is simple if xei 6= xej for all 1 \u2264 i < j \u2264 n.3\nNow let \u03a0\u2032 = e1, . . . , en be an arbitrary dangerous cycle in WA(\u03a3). If \u03a0 \u2032 is not simple, we show how to transform \u03a0\u2032 to a shorter dangerous cycle. Towards this goal, assume that \u03a0\u2032 contains edges ei = \u3008pi, qi, ti\u3009 and ej = \u3008pj , qj , tj\u3009 such that 1 \u2264 i < j \u2264 n and xei = xej ; hence, some rule r \u2208 \u03a3 contains body atoms in which xei occurs at positions pi and pj . Furthermore, let ek be an arbitrarily chosen, but fixed special edge in \u03a0\n\u2032; such ek exists since \u03a0\u2032 is dangerous. We have the following possibilities.\n3. Note that a cycle of length one is always simple.\n\u2022 If i \u2264 k < j, let \u03a0\u2032\u2032 = e, ei+1, . . . , ej\u22121 where e = \u3008pj , qi, ti\u3009. If ei is regular, then xei occurs in a head atom of r at position qi; furthermore, if ei is special, then some head atom of r contains an existentially quantified variable at position qi. Either way, e is an edge of WA(\u03a3), so \u03a0\u2032\u2032 is a cycle in WA(\u03a3). Furthermore, e is special if k = i, and \u03a0\u2032\u2032 contains ek otherwise; hence, \u03a0 \u2032\u2032 is dangerous.\n\u2022 Otherwise, let \u03a0\u2032\u2032 = e1, . . . , ei\u22121, e, ej+1, . . . , en where e = \u3008pi, qj , tj\u3009. Edges e and ej are of the same type, so e is an edge of WA(\u03a3) and \u03a0\u2032\u2032 is a cycle in WA(\u03a3). Furthermore, e is special if k = j, and \u03a0\u2032\u2032 contains ek otherwise; hence, \u03a0 \u2032\u2032 is dangerous.\nIn both cases, \u03a0\u2032\u2032 contains at least one edge less than \u03a0\u2032. Thus, we can iteratively transform an arbitrary dangerous cycle in WA(\u03a3) to a simple dangerous cycle \u03a0.\nNow let M be a marking for \u03a3 that marks each variable w occurring in the body of a rule r \u2208 \u03a3 as follows.\n\u2022 If an edge e = \u3008p, q, t\u3009 in \u03a0 exists such that w = xe, then M marks an occurrence of w in r at position p (if there are multiple such occurrences, one is chosen arbitrarily). Since \u03a0 is simple, edge e is unique, and so M is correctly defined.\n\u2022 Otherwise, M marks an arbitrarily chosen occurrence of w in r.\nLet \u03a3\u2032 = Sing(\u03a3,M), and let JA(\u03a3\u2032) be the JA dependency graph for \u03a3\u2032. To show that JA(\u03a3\u2032) contains a cycle, we first prove the following property (?).\nFor each subpath e1, . . . , ek of \u03a0 where edge e1 is special and each edge ei with 1 < i \u2264 k is regular, we have {qi, Eq|1} \u2286 Move(ye1) for each 1 \u2264 i \u2264 k.4\nSince \u03a3\u2032 contains rule (97), we clearly have Eq|1 \u2208 Move(ye1). We next prove (?) by induction on k. For the base case k = 1, we have q1 \u2208 Move(ye1) by the definition of JA. For the induction step, assume that the claim holds for all subpaths of length k, and consider a subpath e1, . . . , ek, ek+1. By the induction assumption and the fact that qk = pk+1, we have pk+1 \u2208 Move(ye1). Furthermore, variable xek+1 occurs in the body and the head atom of some rule r \u2208 \u03a3\u2032 at positions pk+1 and qk+1, respectively. Finally, by the definition of M and the properties of singularisation, we have that PosB(xek+1) contains pk+1 and possibly Eq|1. But then, by the definition of JA, we have qk+1 \u2208 Move(ye1), as required.\nTo complete the proof, consider now an arbitrary subpath e1, . . . , e` of \u03a0 where edges e1 and e` are special and each edge ei with 1 < i < k is regular. By (?) and the fact that q`\u22121 = p`, we have {p`, Eq|1} \u2286 Move(ye1). Furthermore, as in the previous paragraph, PosB(xe`) contains p` and possibly Eq|1; but then, JA(\u03a3\u2032) contains an edge from ye1 to ye` . Since \u03a0 is a cycle, JA(\u03a3\u2032) clearly contains a cycle, so \u03a3\u2032 is not JA, as required.\n(JA\u2200 \u2287WA) Assume that \u03a3 6\u2208 JA\u2200, so there exists a marking M for \u03a3 such that \u03a3\u2032 = Sing(\u03a3,M) is not JA. We assume that \u03a3 does not contain an existentially quantified variable that occurs in an equality atom; this is w.l.o.g. as we can always replace each equality atom y \u2248 t with an atom R(x, t) and add a rule R(x1, x2)\u2192 x1 \u2248 x2 for R a fresh binary predicate, and such a transformation clearly does not affect the membership of the\n4. The notion of a subpath is defined in the obvious way; however, please note that, although \u03a0 is defined as a sequence of edges, subpaths of \u03a0 can \u2018wrap around\u2019 this sequence as \u03a0 is a cycle.\nrule set in JA\u2200 and WA. Now consider an arbitrary existentially quantified variable y, and arbitrary positions p \u2208 PosH(y) and q \u2208 Move(y) that do not involve Eq (both sets are w.r.t. \u03a3\u2032); by induction on the construction of Move(v), one can prove that WA(\u03a3) then contains a sequence of regular edges from p to q. The proof is straightforward, and we omit the details for the sake of brevity. Similarly, consider an arbitrary edge from y1 to y2 in JA(\u03a3\n\u2032), and arbitrary positions p \u2208 PosH(y1) and q \u2208 PosH(y2) that do not involve Eq; by the definition of JA, a variable x occurring in the rule of y2 and a position s not involving Eq exist such that s \u2208 Move(y1) and s \u2208 PosB(x). But then WA(\u03a3) contains a path consisting of regular edges from p to s, as well as a special edge from s to q. Since JA(\u03a3\u2032) is cyclic, WA(\u03a3) clearly contains a cycle involving a special edge.\nChecking all possible markings may be infeasible: the number of candidates is exponential in the total number of variables that occur more than once in a rule body. Theorem 52 shows that JA\u2200 can be decided using WA. For the other cases, the following simple observation shows how to reduce the number of markings.\nDefinition 53. A variable x is relevant for a rule r \u2208 \u03a3 if x occurs more than once in the body of r, and the head of r contains an atom P (~t) such that x \u2208 ~t and P is not \u2248.\nProposition 54. Let M and M \u2032 be markings for \u03a3 such that, for each rule r \u2208 \u03a3, the markings for r in M and M \u2032 coincide on each relevant variable in r. Then, for each instance I, the result of the skolem chase for I and Sing(\u03a3,M) coincides with the result of the skolem chase for I and Sing(\u03a3,M \u2032); furthermore, Sing(\u03a3,M) is JA/MSA/MFA if and only if Sing(\u03a3,M \u2032) is JA/MSA/MFA.\nProof. Consider an arbitrary rule r \u2208 \u03a3. If a variable x occurs only in the body of r, then marking various occurrences of x in r clearly produces rules equivalent up to the renaming of variables. Furthermore, assume that a variable x occurs in the head of r only in an equality atom of the form x \u2248 t, and that the markings of x differ. Then, the rules obtained from r by singularisation will all have the same body (up to the renaming of variables); furthermore, the bodies contain atoms Eq(xi, x), and the rule heads are of the form Eq(x, t). Since Sing(\u03a3,M) and Sing(\u03a3,M \u2032) contain rules (97)\u2013(99), the skolem chase for I and Sing(\u03a3,M) clearly derives the same ground atoms as the skolem chase for I and Sing(\u03a3,M \u2032).\nDespite this optimisation, the number of markings to check can still be exponential in the size of \u03a3, so we next describe a useful approximation. LetM be a maximal set of markings for \u03a3 such that, for all M1,M2 \u2208M, each rule r \u2208 \u03a3, and each variable x that is not relevant in r, the markings of x in r under M1 and M2 coincide. Intuitively, such M contains all possible markings of the relevant variables, but the markings of all other variables coincide. By Proposition 54 it is clear that, given two such sets M1 and M2, the skolem chase of\u22c3 M\u2208M1 Sing(\u03a3,M) and \u22c3 M\u2208M2 Sing(\u03a3,M) coincides for an arbitrary instance I; thus, let\nM be one arbitrarily chosen such set of markings. Also, let Sing\u222a(\u03a3) = \u22c3 M\u2208M Sing(\u03a3,M), let MFA\u222a be the class containing each rule set \u03a3 such that Sing\u222a(\u03a3) \u2208 MFA, and let MSA\u222a and JA\u222a be defined analogously. As the following proposition shows, Sing\u222a(\u03a3) provides a \u2018lower bound\u2019 on acyclicity that can be obtained via singularisation.\nProposition 55. For each X \u2208 {MFA,MSA, JA}, we have that X\u222a \u2286 X\u2200. Furthermore, the size of Sing\u222a(\u03a3) is exponential in the maximal number of relevant variables in a rule in \u03a3, and it is linear in the number of rules in \u03a3.\nProof. The first claim follows from the fact that all considered notions of acyclicity are monotone in the sense that every subset of an acyclic rule set is also acyclic. The second claim follows from the fact that, if a rule r exists that contains k relevant variables and each variable occurs m times in r, then M contains mk different markings for r.\nThis result is interesting when dealing with rules that are obtained from DLs, where each rule has at most one relevant variable: on such rule sets, the size of Sing\u222a(\u03a3) is linear in the size of \u03a3. For the general case, the complexity of acyclicity checking does not increase despite the exponential increase in the number of rules.\nTheorem 56. Deciding whether \u03a3 is in MFA\u222a (MFA\u2203, MFA\u2200) is 2ExpTime-complete. Deciding whether \u03a3 is in MSA\u222a (MSA\u2203, MSA\u2200) is ExpTime-complete.\nProof. If \u03a3 contains no equality, it is easy to see that \u03a3 is in MFA\u222a (MFA\u2203, MFA\u2200) if and only if it is in MFA. The same can be observed for MSA. Thus, hardness follows from Theorems 8 and 13.\nFor membership, we first consider the cases of MFA\u2203, MFA\u2200, MSA\u2203, and MSA\u2200. Each of these properties can be decided by considering all of the at most exponentially many markings. Since Sing(\u03a3,M) is linear in the size of \u03a3, the property can be checked for each marking for MFA in 2ExpTime (cf. Theorem 8) and for MSA in ExpTime (cf. Theorem 13). This yields the required bound since an exponential factor is not significant for the considered complexity classes.\nFor MFA\u222a and MSA\u222a, membership follows by observing that the membership of MFA and MSA in 2ExpTime and ExpTime, respectively, is obtained from the double/single exponential bound on the number of ground facts that potentially need to be derived in order to decide the required property. While Sing\u222a(\u03a3) is exponentially larger than \u03a3, the maximal number of relevant ground facts is still the same since no new predicates or constant symbols are introduced. The increased number of rules leads to an exponential increase of the time to check applicability of all rules in each of the doubly/singly exponentially many steps, but this exponential factor does not affect membership of the decision problem in 2ExpTime/ExpTime.\nWe finish this section by examining the interaction between rule normalisation and singularisation. Note that normalisation reduces the number of variables in a rule, which at least at first sight suggests that normalisation could prevent one from finding a marking that ensures acyclicity of the singularised rules. We next show that this cannot happen if normalisation is used without structure sharing: if the original set of rules is MFA w.r.t. some set of markings, then the transformed set of rules is MFA w.r.t. a set of markings as well. Furthermore, we show that this does not hold if normalisation is used with structure sharing; hence, normalisation should be applied with care when used with singularisation.\nTheorem 57. Let \u03a3 be a set of existential rules, let \u03a3\u2032 be obtained from \u03a3 by applying a single normalisation step without structure sharing, and let I be an instance. Then each\nmarking M of \u03a3 for which Sing(\u03a3,M) is MFA w.r.t. I can be extended to a marking M \u2032 of \u03a3\u2032 such that Sing(\u03a3\u2032,M \u2032) is MFA w.r.t. I.\nProof. Let M be a marking of \u03a3 such that Sing(\u03a3,M) is MFA, let r \u2208 \u03a3 be the rule of the form (8) to which the normalisation step is applied, and let \u03a3\u2032 be the set of rules obtained from \u03a3 after the application of a normalisation step to r. We next prove that the claim holds for both a head and a body normalisation step.\n(Head Normalisation) Assume that the set of rules \u03a3\u2032 is obtained by replacing a rule r \u2208 \u03a3 with rules r1 and r2 of the following forms, where ~x = ~x3 \u222a ~x4:\nr = \u03d5(~x, ~z)\u2192 \u2203~y1, ~y2, ~y3.[\u03c81(~x3, ~y1, ~y2) \u2227 \u03c82(~x4, ~y1, ~y3)] r1 = \u03d5(~x, ~z)\u2192 \u2203~y1, ~y3.[Q(~x3, ~y1) \u2227 \u03c82(~x4, ~y1, ~y3)] r2 = Q(~x3, ~y1)\u2192 \u2203~y2.\u03c81(~x3, ~y1, ~y2)\nLet M \u2032 be a marking that coincides with M on all rules different from r, that marks r1 in the same way as M marks r, and that marks r2 in the only possible way (note that the body of this rule does not contain repeated occurrences of variables); furthermore, let \u2126 = Sing(\u03a3,M) and \u03a5 = Sing(\u03a3\u2032,M \u2032). We assume that rule r is skolemised by replacing each variable y \u2208 ~y1 with gy1(~x), each variable y \u2208 ~y2 with g y 2(~x), and each variable y \u2208 ~y3 with gy3(~x); rule r1 is skolemised as r; and rule r2 is skolemised by replacing each variable y \u2208 ~y2 with hy(~x3, ~y1). Thus, the skolemised and singularised rules have the following form; formula \u03d5\u2032 is a singularisation of \u03d5, and all freshly introduced variables are contained in ~z1:\n\u03d5\u2032(~x, ~z1)\u2192 \u03c81(~x3, ~g1(~x), ~g2(~x)) \u2227 \u03c82(~x4, ~g1(~x), ~g3(~x)) \u03d5\u2032(~x, ~z1)\u2192 Q(~x3, ~g1(~x)) \u2227 \u03c82(~x4, ~g1(~x), ~g3(~x))\nQ(~x3, ~y1)\u2192 \u03c81(~x3, ~y1,~h(~x3, ~y1))\nFinally, we inductively define a partial mapping \u00b5 from terms to terms as follows:\n\u2022 \u00b5(c) = c for each constant c,\n\u2022 \u00b5(f(~t)) = f(\u00b5(~t)) for each function symbol f not of the form hy or gy1 and all terms ~t such that \u00b5(~t) is defined, and\n\u2022 \u00b5(hy(~s,~g1(~s,~t))) = gy2(\u00b5(~s), \u00b5(~t)) for each function symbols of the form hy, the corresponding symbol gy2 , and all terms ~s and ~t such that \u00b5(~s) and \u00b5(~t) are defined.\nWe next show the following property (?): for each A(~t) \u2208 I\u221e\u03a5 where A is a predicate occurring in \u2126 (i.e., A was not introduced by the normalisation step), \u00b5(t) is defined and A(\u00b5(~t)) \u2208 I\u221e\u2126 . The proof is by induction on the chase sequence I0\u03a5, I1\u03a5, . . . for I and \u03a5. The base case holds trivially. Furthermore, since \u2126 and \u03a5 coincide on all rules apart from r, r1, and r2, the proof of the claim is trivial for each conclusion of a rule different from r1 or r2. For the remaining cases, we can assume w.l.o.g. that I i+1 \u03a5 is obtained from I i \u03a5 by a single application of r1 of substitution \u03c3 and an application of r2 to the result; thus, the rules together derive the following facts:\nQ(~x3\u03c3,~g1(~x\u03c3))\n\u03c81(~x3\u03c3,~g1(~x\u03c3),~h(~x3\u03c3,~g1(~x\u03c3))) \u03c82(~x4\u03c3,~g1(~x\u03c3), ~g3(~x\u03c3))\nBy the induction assumption, \u03d5\u2032(\u00b5(~x\u03c3), \u00b5(~z\u03c3)) \u2286 I\u221e\u2126 , and so I\u221e\u2126 contains the following facts:\n\u03c81(\u00b5(~x3\u03c3), ~g1(\u00b5(~x\u03c3)), ~g2(\u00b5(~x\u03c3))) \u03c82(\u00b5(~x4\u03c3), ~g1(\u00b5(~x\u03c3)), ~g3(\u00b5(~x\u03c3)))\nClearly, each term hy(~x3\u03c3,~g1(~x\u03c3)) is of the form h y(~s,~g1(~s,~t)), so the mapping \u00b5 is defined on the term. Furthermore, by the definition of \u00b5, it is clear that property (?) holds. The proof of (?) also reveals that functions symbols hy occur in I\u221e\u03a5 always in (sub)terms of the form hy(~s,~g1(~s,~t)), and that \u00b5(u) is defined for each term u occurring in I \u221e \u03a5 . This observation and the following property of \u00b5 clearly imply the claim of this theorem: if u is a cyclic term and \u00b5(u) is defined, then \u00b5(u) is cyclic as well. To prove the latter, it suffices to consider the following two cases.\n\u2022 Assume that u is cyclic due to the repetition of a function symbol f not of the form hy. Thus, u contains a subterm of the form f(~s), and some si \u2208 ~s contains a subterm of the form f(~t). By the definition of \u00b5, then \u00b5(u) contains a term of the form f(\u00b5(~s)), and some s\u2032i \u2208 \u00b5(~s) contains a subterm of the form f(\u00b5(~t)). Clearly, \u00b5(u) is cyclic.\n\u2022 Assume that u is cyclic due to the repetition of a function symbol of the form hy. By the above observation, then u contains a subterm of the form hy(~s,~g1(~s,~t)), and some si \u2208 ~s \u222a ~t contains a subterm of the form hy(~v,~g1(~v, ~w)). By the definition of \u00b5, then \u00b5(u) contains a subterm of the form gy2(\u00b5(~s), \u00b5(~t)), and some s \u2032 i \u2208 \u00b5(~s) \u222a \u00b5(~t) contains\na subterm of the form gy2(\u00b5(~v), \u00b5(~w)). Clearly, u is cyclic.\n(Body Normalisation) Assume that the set of rules \u03a3\u2032 is obtained by replacing a rule r \u2208 \u03a3 with rules r1 and r2 of the following forms, where ~x = ~x1 \u222a ~x2 \u222a ~x3, and ~x1, ~x2, ~x3, ~z1, ~z2, and ~z3 are all pairwise disjoint:\nr = \u03d51(~x1, ~x2, ~z1, ~z2) \u2227 \u03d52(~x1, ~x3, ~z1, ~z3)\u2192 \u2203~y.\u03c8(~x, ~y) r1 = \u03d51(~x1, ~x2, ~z1, ~z2)\u2192 Q(~x1, ~x2, ~z1) r2 = Q(~x1, ~x2, ~z1) \u2227 \u03d52(~x1, ~x3, ~z1, ~z3)\u2192 \u2203~y.\u03c8(~x, ~y)\nFor each marked variable v, let ~uv be the variables used to replace v in singularisation. Then, the singularised rule r can be represented as follows, where for clarity we do not show the free variables of various formulae, \u03d5\u20321 and \u03d5 \u2032 2 do not contain atoms with predicate Eq, and \u03931 and \u03932 are the conjunctions of atoms with predicate Eq obtained by renaming unmarked occurrences of the variables in \u03d51(~x1, ~x2, ~z1, ~z2) and \u03d52(~x1, ~x3, ~z1, ~z3), respectively:\n\u03d5\u20321 \u2227 \u03d5\u20322 \u2227 \u03931 \u2227 \u03932 \u2192 \u2203~y.\u03c8(~x, ~y)\nNow let M \u2032 be a marking that coincides with M on all rules different from r, and that, for each marked occurrence of a variable w \u2208 ~x1 \u222a ~x2 \u222a ~z1 in r, marks r1 and r2 as follows.\n\u2022 If the marked occurrence of w appears in \u03d51(~x1, ~x2, ~z1, ~z2), then the corresponding occurrence of w is marked in r1; in addition, if w \u2208 ~x1 \u222a ~x2 \u222a ~z1, then the occurrence of w in atom Q(~x1, ~x2, ~z1) is marked in r2.\n\u2022 If the marked occurrence of w appears in \u03d52(~x1, ~x3, ~z1, ~z3), then the corresponding occurrence of w is marked in r2; in addition, if w \u2208 ~x1 \u222a ~x2 \u222a ~z1, then an arbitrary occurrence of w is marked in r1.\nSince there is no structure sharing, \u03a3 does not contain r1, so the above definition is wellformed. The singularisation of r1 and r2 under M \u2032 can be represented as follows:\n\u03d5\u2032\u20321 \u2227 \u0393\u2032\u20321 \u2192 Q(~x1, ~x2, ~z1) Q(~x\u20321, ~x2, ~z \u2032 1) \u2227 \u03d5\u20322 \u2227 \u0393\u20322 \u2192 \u2203~y.\u03c8(~x, ~y)\nBy the definition of M \u2032, it should be clear that \u03d5\u2032\u20321 \u2227 \u0393\u2032\u20321 is isomorphic to a subset of \u03d5\u20321 \u2227 \u0393\u20321. Based on this observation, it is now routine to prove that, if A(~t) \u2208 I\u221eSing(\u03a3,M) and A is different from the newly introduced predicate Q, then A(~t) \u2208 I\u221eSing(\u03a3\u2032,M \u2032), which clearly implies our claim.\nIn contrast to Theorem 57, the following example shows that normalisation with structure sharing can prevent one from finding a marking that makes the normalised rules acyclic. This example shows that normalisation must be used with care in applications that use singularisation to deal with equality.\nExample 58. Let \u03a3 be the following set of rules marked by a marking M shown below.\nA(x) \u2227 T (x , z) \u2227B(z )\u2192 \u2203y.[R(x, y) \u2227A(y)] (105) A(x ) \u2227 T (x, z) \u2227 C(z )\u2192 \u2203y1\u2203y2.[S(x, y1) \u2227 T (y1, y2)] (106)\nR(z , x 1) \u2227R(z, x 2)\u2192 x1 \u2248 x2 (107) S(z , x 1) \u2227 S(z, x 2)\u2192 x1 \u2248 x2 (108) T (z , x 1) \u2227 T (z, x 2)\u2192 x1 \u2248 x2 (109)\nOne can show that Sing(\u03a3,M) is MFA w.r.t. the instance I given below.\nI = {A(a), R(a, a), T (a, b), B(b), A(a\u2032), S(a\u2032, a\u2032), T (a\u2032, b\u2032), C(b\u2032)}\nFurthermore, let M1 be a marking identical to M but which marks A(x ) in rule (105), and let M2 be a marking identical to M but which marks T (x , z) in rule (106). One can show that neither Sing(\u03a3,M1) nor Sing(\u03a3,M2) is MFA w.r.t. I. Now let \u03a3\u2032 be obtained from \u03a3 by applying normalisation with structure sharing to rules (105) and (106); thus, rules (105) and (106) are replaced with the following rules:\nQ(x, z) \u2227B(z)\u2192 \u2203y.[R(x, y) \u2227A(y)] (110) Q(x, z) \u2227 C(z)\u2192 \u2203y1\u2203y2.[S(x, y1) \u2227 T (y1, y2)] (111) A(x) \u2227 T (x, z)\u2192 Q(x, z) (112)\nNote that conjunction A(x) \u2227 T (x, z) occurs in \u03a3\u2032 only in rule (112); therefore, variable x in this conjunction can be marked in only one way. This, however, has the same effect as choosing M1 or M2 for \u03a3: no possible marking M\n\u2032 will make Sing(\u03a3\u2032,M \u2032) MFA w.r.t. I. Intuitively, normalisation with structure sharing reduces the space of available markings, due to which it may be impossible to find a marking that makes the rules acyclic. \u2666"}, {"heading": "6. Applying Acyclicity to Horn Description Logics", "text": "In this section we apply various acyclicity notions to reasoning problems in description logic (DL) ontologies. Description logics are knowledge representation formalisms that underpin the Web Ontology Language (OWL). DL ontologies are constructed from atomic concepts (i.e., unary predicates), atomic roles (i.e., binary predicates), and individuals (i.e., constants). Special atomic concepts > and \u22a5 denote universal truth and falsehood, respectively. For each atomic role R, expression R\u2212 is an inverse role; furthermore, a role is an atomic or an inverse role. DLs provide a rich set of constructors for building concepts (first-order formulae with one free variable) from atomic concepts and roles. A description logic TBox is a set of axioms, which correspond to first-order sentences. In this paper we consider only Horn description logics, in which TBoxes can be translated into existential rules. Furthermore, in this paper we will consider only normalised TBoxes, in which concepts do not occur nested in other concepts. The latter assumption is without loss of generality as each Horn description logic TBox can be normalised in linear time, and the normalised ontology is a model-conservative extension of the original one.\nIn this paper we consider several logics all of which are fragments of the description logic Horn-SROIF , which provides the formal underpinning for a prominent subset of OWL. A normalised Horn-SROIF TBox T consists of axioms shown on the left-hand side of Table 1; in the table, A, B, and C are atomic concepts (including possibly > and \u22a5), R, S, and T are (not necessarily atomic) roles, and a is an individual. To guarantee decidability of reasoning, T must satisfy certain global conditions (Kutz, Horrocks, & Sattler, 2006), which we omit for the sake of brevity. Roughly speaking, only so-called simple roles are allowed to occur in axioms of Type 2, and axioms of Type 6 must be regular according to a particular condition that allows such axioms to be represented using a nondeterministic finite automaton. We also consider the following fragments of Horn-SROIF .\n\u2022 Horn-SRI TBoxes are not allowed to contain axioms of Type 2 or 7.\n\u2022 Horn-SHIF TBoxes are not allowed to contain axioms of Type 7, and all axioms of Type 6 satisfy R = S = T . Note that all Horn-SHIF TBoxes are regular.\n\u2022 Horn-SHI TBoxes inherit the restrictions from Horn-SHIF and are further not allowed to contain axioms of type 2.\nTo simplify the presentation, we do not consider general at-least number restrictions\u2014 that is, concepts of the form \u2265nR.A with n > 1. The translation of such concepts into rules would require an explicit inequality predicate. As explained in Section 2.2, the inequality predicate can be simulated using an ordinary predicate, and so the extension of our results to general at-least number restrictions is straightforward.\nIn the rest of this paper we allow inverse roles to occur in atoms, so we take an atom of the form R\u2212(t1, t2) with R an atomic role as an abbreviation for R(t2, t1). Then, each Horn-SROIF axiom corresponds to an existential rule as shown in Table 1. As explained in Section 2.2, we treat > and \u22a5 as ordinary unary predicates where > is explicitly axiomatised. Thus, we can take a substitution \u03b8 to be an answer to a CQ Q(~x) w.r.t. a T and I if T \u222a I |= Q(~x)\u03b8 or I \u222a T |= \u2203y.\u22a5(y); the latter condition takes into account that an unsatisfiable theory entails all possible formulae. Due to this close correspondence between\ndescription logic axioms and existential rules, in the rest of this paper we identify a TBox T with the corresponding set of rules.\nThe complexity of answering Boolean conjunctive queries over general (i.e., not acyclic) DL TBoxes is 2ExpTime- and ExpTime-complete for Horn-SROIF (Ortiz et al., 2011) and Horn-SHIF (Eiter et al., 2008), respectively. In the rest of this section we investigate the complexity of this problem on acyclic ontologies, as well as the complexity of acyclicity checking. In particular, in Section 6.1 we consider the case when the TBox is expressed in Horn-SROIF , for which we show that both BCQ answering and MFA checking are ExpTime-complete. Then, in Section 6.2 we consider Horn-SHIF TBoxes, for which we show that the complexity of these problems drops to PSpace.\n6.1 Acyclic Horn-SROIF TBoxes\nWe start by showing that BCQ answering for WA Horn-SRI TBoxes is ExpTime-hard. Intuitively, this is due to the axioms of Type 6, which can be used to axiomatise existence of non-tree-like structures. Although regularity ensures that axioms of Type 6 can be represented by a nondeterministic finite automaton, this automaton can be exponential; as a consequence, axioms of Type 6 can axiomatise exponential non-tree-like structures, which is the main source of complexity.\nLemma 59. Let T be a WA Horn-SRI TBox, let I be an instance, and let F be a fact. Then, checking whether I \u222a T |= F is ExpTime-hard.\nProof. LetM = (S,Q, \u03b4, Q0, Qa) be a deterministic Turing machine, where S is a finite set of symbols, Q is a finite set of states, \u03b4 : Q\u00d7 S \u2192 Q\u00d7 S \u00d7 {\u2190,\u2192} is a transition function, Q0 \u2208 Q is the initial state, and Qa the accepting state. Furthermore, assume that an integer k exists such thatM halts on each input of length n in time 2nk . Given an arbitrary input Si1 , . . . , Sin , we construct an MFA set of Horn-SRI rules T and an instance I such that I \u222a T |= Qa(a) if and only ifM accepts the input. To simplify the presentation, we will use a slightly more general rule syntax than what is allowed by Table 1; however, all such rules can be brought into the required form by renaming parts of the rules with fresh predicates.\nLet ` = nk; since k is a constant, ` is polynomial in n. Our construction uses a unary predicate for each symbol and state; for simplicity, we do not distinguish between the predicate and the symbol/state. In addition, the construction also uses binary predicates Li, Ri, Ti, Ui, Di, Hi, and Vi for 1 \u2264 i \u2264 `, unary predicates Ai and Bi for 0 \u2264 i \u2264 `, and unary predicates O1, . . . , On+1, N1, and N2. Instance I contains only the fact A0(a). We\nnext present the rules of T . The set T will contain only Horn rules without empty heads, so it will be satisfiable in a minimal Herbrand model. For readability, we divide T into groups of rules and prove for each group various facts about this minimal Herbrand model of T \u222a I, which is shown schematically in Figure 2. The construction of T proceeds along the following lines.\n\u2022 The first, the second, and the third group of rules construct the exponential grid shown at the bottom of Figure 2, whose edges are labelled with H` and V`. Each sequence of V`-edges will be used to encode the contents of the tape of the Turing machine at some point in time; furthermore, precisely one vertex in each such sequence will be labelled with a state, thus representing the position of the head. In contrast, H`-edges will connect different points in time and will be used to encode the transitions of the Turing machine.\n\u2022 The fourth group labels the right-most V`-chain with Si1 , . . . , Sin , St, St, . . . , St, St, where St represents the empty tape symbol.\n\u2022 The fifth and the sixth groups ensure that the symbols on the tape that are not modified by a move of a Turing machine are propagated between time points.\n\u2022 The seventh and the eighth group encode the transitions of the Turing machine.\n\u2022 The ninth group propagates the acceptance condition to the top of the figure by labelling the individual a with the accepting state Qa.\nWe next present the rules of T in detail.\nThe first group of rules in T contains rules (113)\u2013(115) for each 0 < i \u2264 `, and rule (116) for each 1 < i \u2264 `.\nAi\u22121(x)\u2192 \u2203y.[Li(x, y) \u2227Ai(y)] (113) Ai\u22121(x)\u2192 \u2203y.[Ri(x, y) \u2227Ai(y)] (114) Ri(z, x) \u2227 Li(z, x\u2032)\u2192 Ti(x, x\u2032) (115)\nLi(z, x) \u2227 Ti\u22121(z, z\u2032) \u2227Ri(z\u2032, x\u2032)\u2192 Ti(x, x\u2032) (116)\nOn I, these rules axiomatise existence of a triangular structure in the top part of Figure 2 containing Ti links.\nThe second group of rules in T contains rule (117), rules (118)\u2013(120) for each 0 < i \u2264 `, and rule (121) for each 1 < i \u2264 `.\nA`(x)\u2192 B0(x) (117) Bi\u22121(x)\u2192 \u2203y.[Ui(x, y) \u2227Bi(y)] (118) Bi\u22121(x)\u2192 \u2203y.[Di(x, y) \u2227Bi(y)] (119) Ui(z, x) \u2227Di(z, x\u2032)\u2192 Vi(x, x\u2032) (120)\nDi(z, x) \u2227 Vi\u22121(z, z\u2032) \u2227 Ui(z\u2032, x\u2032)\u2192 Vi(x, x\u2032) (121)\nThese rules axiomatise existence of triangular structures in the bottom part of Figure 2 containing Vi links.\nThe third group of rules in T contains rule (122), and rules (123) and (124) for each 0 < i \u2264 `.\nT`(x, x \u2032)\u2192 H0(x, x\u2032) (122)\nUi(z, x) \u2227Hi\u22121(z, z\u2032) \u2227 Ui(z\u2032, x\u2032)\u2192 Hi(x, x\u2032) (123) Di(z, x) \u2227Hi\u22121(z, z\u2032) \u2227Di(z\u2032, x\u2032)\u2192 Hi(x, x\u2032) (124)\nThese rules axiomatise existence of Hi links, which with Vi links form a grid of size 2 i \u00d7 2i shown in Figure 2. In the rest of this proof, for variables w0 and w`, we use R\n`(w0, w`) as an abbreviation for R1(w0, w1) \u2227 . . . \u2227R`(w`\u22121, w`), where each wi with 0 < i < m is a variable not occurring outside the conjunction. Furthermore, we analogously use U `(w0, w`) as an abbreviation for U1(w0, w1) \u2227 . . . \u2227 U`(w`\u22121, w`).\nThe fourth group of rules in T contains rule (125), rules (126) and (127) for each 1 \u2264 j \u2264 n, and rules (128)\u2013(129), where St is the empty tape symbol. Remember that Si1 , . . . , Sin encodes the input to M.\nA0(z) \u2227R`(z, z\u2032) \u2227 U `(z\u2032, x)\u2192 O1(x) \u2227Q0(x) (125) Oj(z) \u2227 V`(z, x)\u2192 Oj+1(x) (126)\nOj(x)\u2192 Sij (127) On+1(z) \u2227 V`(z, x)\u2192 On+1(x) (128)\nOn+1(x)\u2192 St(x) (129)\nRule (125) labels the grid origin and sets the initial state as shown in Figure 2. Rules (126) ensure that the n subsequent nodes are labelled with O2, . . . , On+1, and rule (128) propagates On+1 to the rest of the V`-chain. Finally, rules (127) and (129) ensure that nodes labelled with Oj are also labelled with Sij , and that nodes labeled with On+1 are labeled with St. Thus, this group of rules in T ensures that the right-most V`-chain in the grid contains the initial state of the tape of M.\nThe fifth group of rules in T contains rules (130)\u2013(131) for each state Qk \u2208 Q, and rules (132)\u2013(133). These rules essentially ensure that all nodes before and after a node labelled with some state Qk \u2208 Q are labeled with N1 and N2, respectively, thus indicating that the head is not above the node.\nQk(z) \u2227 V`(x, z)\u2192 N1(x) (130) Qk(z) \u2227 V`(z, x)\u2192 N2(x) (131) N1(z) \u2227 V`(x, z)\u2192 N1(x) (132) N2(z) \u2227 V`(z, x)\u2192 N2(x) (133)\nThe sixth group of rules in T contains rules (134)\u2013(135) instantiated for each symbol Sk \u2208 S; these rules ensure that the contents of the tape is copied between successive time points for all points in the grid not containing the head.\nN1(z) \u2227 Sk(z) \u2227H`(z, x)\u2192 Sk(x) (134) N2(z) \u2227 Sk(z) \u2227H`(z, x)\u2192 Sk(x) (135)\nThe seventh group of rules in T contains rules (136)\u2013(137) instantiated for each symbol Sk \u2208 S and each state Qk \u2208 Q such that \u03b4(Qk, Sk) = (Qk\u2032 , Sk\u2032 ,\u2190). These rules encode moves of M where the head moves left.\nQk(z) \u2227 Sk(z) \u2227H`(z, x)\u2192 Sk\u2032(x) (136) Qk(z) \u2227 Sk(z) \u2227H`(z, z\u2032) \u2227 V`(x, z\u2032)\u2192 Qk\u2032(x) (137)\nThe eighth group of rules in T contains rules (138)\u2013(139) instantiated for each symbol Sk \u2208 S and each state Qk \u2208 Q such that \u03b4(Qk, Sk) = (Qk\u2032 , Sk\u2032 ,\u2192). These rules encode moves of M where the head moves right.\nQk(z) \u2227 Sk(z) \u2227H`(z, x)\u2192 Sk\u2032(x) (138) Qk(z) \u2227 Sk(z) \u2227H`(z, z\u2032) \u2227 V`(z\u2032, x)\u2192 Qk\u2032(x) (139)\nThe ninth group of rules in T contains rules (140)\u2013(143) for each 1 \u2264 i \u2264 `; these rules simply ensure that acceptance is propagated back to the root of the upper tree.\nQa(z) \u2227 Ui(x, z)\u2192 Qa(x) (140) Qa(z) \u2227Di(x, z)\u2192 Qa(x) (141) Qa(z) \u2227 Li(x, z)\u2192 Qa(x) (142) Qa(z) \u2227Ri(x, z)\u2192 Qa(x) (143)\nThe above discussion shows that labelling of the nodes in the grid shown in Figure 2 simulates the execution ofM on input Si1 , . . . , Sin , where the contents of the tape at some time instant is represented by a V`-chain, and H`-links connect tape cells at successive time instants. Thus, I \u222a T |= Qa(a) if and only if M accepts Si1 , . . . , Sin in time 2`. It is straightforward to see that T is WA, so the claim of this theorem holds.\nThe proof of Lemma 59 can be adapted to obtain the lower bound for checking MFA of Horn-SRI rules.\nLemma 60. Checking whether a Horn-SRI TBox is universally MFA is ExpTime-hard.\nProof. LetM be an arbitrary deterministic Turing machine and let Si1 , . . . , Sin be an input string on which M terminates in time 2nk . For such M and Si1 , . . . , Sin , let T be as in the proof of Lemma 59. TBox T is WA, it contains only constant-free, equality-free, and connected rules, and no predicate in T is of zero arity; hence, by Lemma 7, a Horn-SRI TBox T \u2032 exists such thatM accepts Si1 , . . . , Sin if and only if T \u2032 is not universally MFA.\nNote that Lemmas 59 and 60 apply to Horn-SRI and thus do not rely on a particular treatment of equality. We can deal with the equality predicate in Horn-SROIF TBoxes using singularisation as described in Section 5, which leads us to the following result.\nTheorem 61. Let T be a Horn-SROIF TBox, let M be a marking of T , let I be an instance, and let Q be a BCQ. Then, checking whether Sing(T ,M) is MFA w.r.t. I is ExpTime-complete. Furthermore, if Sing(T ,M) is MFA w.r.t. I, then checking whether I \u222a T |= Q holds is ExpTime-complete as well.\nProof. Note that all rules in Table 1 are \u2203-1 rules. Since all rules in Sing(T ,M) are \u2203-1 rules as well, Theorem 10 gives us an ExpTime upper bound for both of our problems. The matching lower bounds follow from Lemmas 59 and 60 (note that every Horn-SRI TBox is also a Horn-SROIF TBox) and the fact that their proofs do not use predicate \u2248.\nIn fact, Theorem 10 provides us with even stronger complexity bounds. In particular, even if T does not satisfy all the required global conditions, and even if T is extended with SWRL rules (Horrocks, Patel-Schneider, Bechhofer, & Tsarkov, 2005), the rules in T are all still \u2203-1 rules. Thus, one can decide whether such T is MFA (universally or w.r.t. an instance) in ExpTime, and if that is the case, one can answer BCQs in ExpTime as well. Consequently, ontology-based applications can freely use the expressivity beyond what is currently available in OWL without an increase in the complexity of reasoning, assuming that the resulting TBox is acyclic.\nWe conclude this section by observing that MSA provides us with a tractable notion for Horn-SROIF rules. Intuitively, all rules in MSA(T ) have a bounded number of variables and all predicates in MSA(T ) are of bounded arity, which eliminates all sources of intractability in datalog reasoning. We prove the matching lower bound in Section 6.2 for the more specific case of Horn-SHIF ontologies.\nTheorem 62. Let T be Horn-SROIF TBox, let M be a marking, and let I be an instance. Then, checking whether Sing(T ,M) is MSA w.r.t. I is in PTime.\nProof. As one can see in Table 1, the rules in T all contain a bounded number of variables and atoms in the body, and so the number of variables in the body of each rule in MSA(Sing(T ,M)) is bounded as well. Furthermore, the datalog program MSA(Sing(T ,M)) contains predicates of bounded arity, so its chase w.r.t. I is polynomial in size. Thus, the chase of I and MSA(T ) can be computed in polynomial time, which implies our claim.\n6.2 Acyclic Horn-SHIF TBoxes\nThe exponential lower bound of Lemmas 59 and 60 critically depend on axioms of Type 6, which can be used to encode exponential structures; furthermore, a combination of inverse roles and axioms of Types 2 and 7 (i.e., of inverse roles, number restrictions, and nominals) is also well known to be problematical (Horrocks & Sattler, 2007). In practice, however, TBoxes are often expressed in Horn-SHIF , which disallows such axioms in TBoxes. We next show that, for such TBoxes, the complexity of both problems drops to PSpace.\nWe first prove PSpace-hardness for both problems. Note that the PSpace-hardness proof of concept satisfiability checking by Baader, Calvanese, McGuinness, Nardi, and PatelSchneider (2007) is not applicable to Horn ontologies since it uses disjunctive concepts. Nonetheless, PSpace-hardness can be proved by a reduction from checking QBF validity.\nLemma 63. Let T be a WA Horn-SHI TBox, let I be an instance, and let F be a fact. Then, checking whether I \u222a T |= F is PSpace-hard.\nProof. Let \u03d5 = Q1x1 . . . Qnxn.C1 \u2227 . . . \u2227 Ck be an arbitrary quantified Boolean formula defined over variables x1, . . . , xn, where each Qi \u2208 {\u2203,\u2200}, 1 \u2264 i \u2264 n is a quantifier, and each Cj , 1 \u2264 j \u2264 k is a clause of the form Cj = Lj,1 \u2228 Lj,2 \u2228 Lj,3. Checking validity of \u03d5 is the canonical PSpace-hard problem.\nIn the rest of this proof, for a binary predicate P and variables w0 and wm, we use Pm(w0, wm) as an abbreviation for P (w0, w1) \u2227 . . . \u2227 P (wm\u22121, wm), where each wi with 0 < i < m is a variable not occurring outside the conjunction. Let T be the Horn-SHI TBox containing rules (144)\u2013(147) for each 1 \u2264 i \u2264 n, rule (148) for each clause Cj and each literal Lj,m = x` occurring in Cj , rule (149) for each clause Cj and each literal Lj,m = \u00acx` occurring in Cj , rule (150), rule (151) for each 1 \u2264 i \u2264 n such that Qi = \u2203, and rule (152) for each 1 \u2264 i \u2264 n such that Qi = \u2200.\nAi\u22121(x)\u2192 \u2203y.[X+i (x, y) \u2227Ai(y)] (144) Ai\u22121(x)\u2192 \u2203y.[X\u2212i (x, y) \u2227Ai(y)] (145)\nX+i (x, x \u2032)\u2192 P (x, x\u2032) (146) X\u2212i (x, x \u2032)\u2192 P (x, x\u2032) (147)\nX+` (z \u2032, z) \u2227 Pn\u2212`(z, x) \u2227An(x)\u2192 Cj(x) (148) X\u2212` (z \u2032, z) \u2227 Pn\u2212`(z, x) \u2227An(x)\u2192 Cj(x) (149)\nC1(x) \u2227 . . . \u2227 Ck(x)\u2192 Fn(x) (150) P (x, z) \u2227 Fi(z)\u2192 Fi\u22121(x) (151)\nX+i (x, z) \u2227 Fi(z) \u2227X \u2212 i (x, z \u2032) \u2227 Fi(z\u2032)\u2192 Fi\u22121(x) (152)\nStrictly speaking, rules (148), (149), (150), and (152) are not Horn-SHI rules, but they can be transformed into Horn-SHI rules by replacing parts of their bodies with fresh concepts. It is straightforward to see that T is WA.\nLet I = {A0(a)}, and let I\u221eT be the chase of I and T . Due to rules (144)\u2013(145), I\u221eT contains a binary tree of depth n in which each leaf node is reachable from a via a path that, for each 1 \u2264 i \u2264 n, contains either X+i or X \u2212 i . If we interpret the presence of X + i and X\u2212i as assigning variable xi to t and f, respectively, then each leaf node corresponds to one possible assignment of x1, . . . , xn. Rules (148) and (149) then clearly label each leaf node with the clauses that are true in the node, and rule (150) labels each leaf node with Fn for which all clauses are true. Finally, rules (151) and (152) label each interior node of the tree with Fi\u22121 according to the semantics of the appropriate quantifier of \u03d5. Clearly, \u03d5 is valid if and only if I \u222a T |= F0(a), which implies our claim.\nWe next turn our attention to the upper bounds on the complexity of answering a BCQ over an MFA TBox, and checking whether a TBox is MFA. While in Section 6.1 we considered a TBox T singularised according to some marking M , in this section we assume that equality in T is handled by means of an explicit axiomatisation T\u2248. As we explain next, this is because singularised rules are not \u2018local\u2019, which makes a PSpace membership proof quite difficult. For example, consider the following singularised rule:\nA(x) \u2227 x \u2248 x\u2032 \u2227B(x\u2032)\u2192 C(x) (153)\nAtoms A(x) and B(x\u2032) in the rule do not share variables and therefore need not be matched \u2018locally\u2019 in the chase of Sing(T ,M) and I; furthermore, the chase can be exponential in size, so it is not trivial to see how it can be explored using polynomial space. Nevertheless, we conjecture that it is possible to extend our proof to singularised rules as well; however, the details involved seem quite technical, without explaining much about the nature of BCQ answering under equality. Therefore, we leave this problem open and restrict ourselves to the technically simpler case when equality in T is encoded explicitly using T\u2248.\nWe next show that answering a BCQ Q over an MFA Horn-SHIF TBox T and an instance I can be performed in polynomial space. The proof uses the well-known tracing technique of inspecting a model of T \u222a I using polynomial space. The key aspect of this result, however, is dealing with the transitive roles in the query, which allow the query to be embedded non-locally into the chase of T and I. Note, however, that we can guess an embedding of Q into the result of I\u221eT using nondeterministic polynomial time; furthermore, since I\u221eT is a minimal Herbrand model of T (i.e., since T is Horn), we can check the entailment of each mapped atom of Q separately, and in doing so we can use the wellknown encoding by Demri and de Nivelle (2005) to handle transitive roles.\nTheorem 64. Let T be Horn-SHIF TBox, let I be an instance such that T is MFA w.r.t. I, and let Q be a BCQ. Then, checking whether I \u222a T |= Q is PSpace-complete.\nProof. Hardness follows from Lemma 63. We next present a nondeterministic polynomial space algorithm that decides I \u222a T |= Q; by Savitch\u2019s Theorem, this algorithm can be transformed into a deterministic polynomial space algorithm, which proves our claim.\nAssume that BCQ Q is of the form Q = \u2203~y.B1 \u2227 . . . \u2227Bn. Furthermore, let \u03a5 = sk(T ). Since \u22a5 is just a regular atomic concept, I \u222a T is always satisfiable in the chase I\u221eT of I\nand T . Furthermore, I \u222a T |= Q if and only if a substitution \u03b8 from the variables in ~y to the terms in I\u221eT exists such that Bi\u03b8 \u2208 I\u221eT for each 1 \u2264 i \u2264 n; the latter clearly holds if and only if I \u222a\u03a5 |= Bi\u03b8. As shown in the proof of Theorem 10, each term in I\u221eT is of the form g1(. . . g`(a) . . .), where ` is less than or equal to the number of function symbols in \u03a5. Thus, the first step in deciding I \u222a T |= Q is to examine all possible \u03b8 and then check I \u222a\u03a5 |= Bi\u03b8 for each 1 \u2264 i \u2264 n; this can clearly be done using a deterministic Turing machine that uses polynomial space to store \u03b8, provided that each individual check I \u222a\u03a5 |= Bi\u03b8 can also be decided in polynomial space.\nIf Bi\u03b8 is of the form C(t), then let \u03a5 \u2032 = \u03a5, and let D = C. Alternatively, if Bi\u03b8 is of the form R(t\u2032, t), then let \u03a5\u2032 be \u03a5 extended with the following rules, where D and E are fresh concepts not occurring in \u03a5 and I:\n\u2192 E(t\u2032) (154) E(z) \u2227R(z, x)\u2192 D(x) (155)\nIt is straightforward to see that I \u222a\u03a5 |= R(t\u2032, t) if and only if I \u222a\u03a5\u2032 |= D(t). Let \u03a5\u2032\u2032 be obtained from \u03a5\u2032 by deleting each rule in \u03a5\u2032 of the form\nR(x1, z) \u2227R(z, x2)\u2192 R(x1, x2) (156)\nand, for each role R occurring in such a rule, replacing each rule of the form\nA(z) \u2227R(z, x)\u2192 B(x) (157)\nwith the following rules, where QA,R,B is a fresh concept unique for A, R, and B:\nA(z) \u2227R(z, x)\u2192 QA,R,B(x) (158) QA,R,B(z) \u2227R(z, x)\u2192 QA,R,B(x) (159)\nQA,R,B(x)\u2192 B(x) (160)\nThis transformation corresponds to the well-known elimination of transitivity by Demri and de Nivelle (2005), so I \u222a\u03a5\u2032 |= D(t) if and only if I \u222a\u03a5\u2032\u2032 |= D(t); the proof of this claim is straightforward and we omit it for the sake of brevity.\nLet \u039e be \u03a5\u2032\u2032 extended with the equality axioms (2) and (4). Since \u2248 does not occur in the body of the rules in \u03a5\u2032\u2032, we have that I \u222a\u03a5\u2032\u2032 6|= D(t) if and only if I \u222a \u039e 6|=\u2248 D(t). Let I\u221e\u039e be the chase for I and \u039e; then I \u222a \u039e 6|=\u2248 D(t) if and only if D(t) 6\u2208 I\u221e\u039e . Note that \u039e contains rules of Types 1\u20135 from Table 1, rules (2) and (4), and possibly rules of the form \u2192 E(t1). These facts can be used to show that each assertion in I\u221e\u039e is of one of the following forms, where a and b are constants, t is a constant or a term that contains only unary function symbols, f and g are unary function symbols, C is an atomic concept, and R is an atomic role:\n\u2022 C(t),\n\u2022 R(a, b), R(a, f(b)), R(f(b), a), R(t, f(t)), R(f(t), t), or\n\u2022 t \u2248 f(g(t)), f(t) \u2248 g(t), a \u2248 b, a \u2248 f(b), or an equality symmetric to these ones.\nThe proof is by induction on the length of the chase sequence for I and \u039e, and the claim follows straightforwardly from the I\u221e\u039e form of rules of Types 1\u20135. Motik et al. (2009b) prove an analogous claim for a more general description logic, and their proof carries over to the above setting with only syntactic changes.\nWe say that x is the central variable in a rule of Type 1 or 3, and that z is the central variable in a rule of Type 2 or 4. W.l.o.g. we assume that the body of a rule of Type 5 does not contain inverse roles; then, x1 is the central variable of a rule of Type 5. Finally, in the equality replacement rules (4), the central variable is the variable being replaced.\nClearly, D(t) 6\u2208 I\u221e\u039e if and only if a Herbrand interpretation J exists in which all assertions are of the form mentioned above, such that I\u221e\u039e \u2286 J , J |=\u2248 \u039e, and D(t) 6\u2208 J . We next show how to check the existence of such J using a nondeterministic Turing machine that runs in polynomial space.\nLet f1, . . . , fm be all function symbols occurring in \u039e. We first guess a Herbrand interpretation J0 over the constants of I satisfying I \u2286 J0, and we check whether all rules in \u039e not of Type 1 are satisfied in J0. If that is the case, we consider each constant c in J0 and call the following procedure for s = c and i = 1:\n1. If i = m+ 1 return true.\n2. Guess a Herbrand interpretation J i such that each assertion in J i is of a form as specified earlier and involves at least one term among f1(s), . . . , fm(s).\n3. If D(t) \u2208 J i, return false.\n4. Check whether the equality symmetry rule (4) is satisfied in J i; if not, return false.\n5. Check whether J i \u222a J i\u22121 \u222a . . . \u222a J0 satisfies each rule in \u039e if the central variable of the rule is mapped to s; if this is not the case for each rule, return false.\n6. For each 1 \u2264 k \u2264 m, recursively call this procedure for fk(s) and i+ 1; if one of this calls returns false, return false as well.\n7. Return true.\nAssume that this procedure returns true for each constant c, and let J be the union of all J i considered in the process. It is straightforward to see that I \u2286 J and D(t) 6\u2208 J ; furthermore, J |=\u2248 \u039e holds since the satisfaction of each rule r \u2208 \u039e in J can be ascertained \u2018locally\u2019, by inspecting the vicinity of the ground term that is mapped to the central variable of r. Furthermore, the recursion depth of our algorithm is m and at each recursion level we need to keep a polynomially sized interpretation J i, so our algorithm can be implemented using a nondeterministic Turing machine that uses polynomial space.\nTheorem 65. Let T be Horn-SHIF TBox, and let I be an instance. Then, deciding whether T is MFA w.r.t. I is in PSpace, and deciding whether T is universally MFA is PSpace-hard.\nProof. (Membership) Rules in MFA(T ) are \u2018almost\u2019 Horn-SHIF rules: rule (19) can be made a Horn-SHIF rule by replacing S in the body with D (which clearly does not affect the consequences of the rule), and the fact that rule (20) contains a nullary atom in the\nhead is immaterial. Thus, the claim can be proved by a straightforward adaptation of the membership proof of Theorem 64. The main difference in the algorithm is that, with n function symbols, we need to examine the models to depth n+1; however, such an algorithm still uses polynomial space.\n(Hardness) Let \u03d5 be an arbitrary QBF, and let T be as in the hardness proof of Lemma 63. TBox T is WA; it contains only constant-free, equality-free, and connected rules; and it does not contain a predicate of zero arity. Hence, by Lemma 7, a Horn-SHI TBox T \u2032 exists such that \u03d5 is valid if and only if T \u2032 is not universally MFA.\nWe finish this section by proving that checking whether a set of Horn-SHI rules is universally MSA is PTime-hard; in this way, we also obtain a matching lower bound for theorem Theorem 62 from Section 6.1.\nTheorem 66. Checking whether a Horn-SHI TBox T is universally MSA is PTime-hard.\nProof. Let N be a set of Horn propositional clauses of the form \u00acv1 \u2228 . . . \u2228 \u00acvn \u2228 vn+1 and let v be a propositional variable; deciding N |= v is well known to be PTime-hard. Let Vi be a concept uniquely associated with each propositional variable vi; let A be a fresh concept; and let T be the TBox obtained by transforming each propositional clause in N of the above form into rule (161).\nA(x) \u2227 V1(x) \u2227 . . . \u2227 Vn(x)\u2192 Vn+1(x) (161)\nFinally, let I = {A(a)}. Clearly, N |= v holds if and only if I \u222a T |= V (a) holds. TBox T is WA, it contains only constant-free, equality-free, and connected rules, and no predicate in T is of zero arity; hence, by Lemma 7, a Horn-SHI TBox T \u2032 exists such that N 6|= v holds if and only if T \u2032 is universally MFA. Finally, the only existential variable in T \u2032 occurs in a rule of the form (23), so it is straightforward to see that T \u2032 is universally MFA if and only if T \u2032 is universally MSA."}, {"heading": "7. Experiments", "text": "To estimate the extent to which various acyclicity notions can be used in practice, we conducted two sets of experiments. First, we implemented MFA, MSA, JA, and WA checkers, and we used them to check acyclicity of a large corpus of Horn ontologies. Our goal was to see how many ontologies are acyclic and could thus be used with (suitably extended) materialisation-based OWL reasoners. Second, we computed the materialisation of the acyclic Horn ontologies and compared the number of facts before and after materialisation. The goal of these tests was to see whether materialisation-based reasoning with acyclic ontologies is practically feasible.\nTests were performed on a Windows R2 Server with two Intel Xeon 3.06GHz processors. We used a repository of 336 OWL ontologies whose TBox axioms can be transformed into existential rules where at least one rule contains an existential quantifier in the head. These ontologies include a large subset of the Gardiner ontology corpus (Gardiner, Tsarkov, & Horrocks, 2006), the LUBM ontology, several Phenoscape ontologies, and a number of ontologies from two versions of the Open Biomedical Ontology (OBO) corpus. Please note\nthat no test ontology has been obtained from conceptual models (e.g., the ER models or UML diagrams): due to the specific modelling patterns used in conceptual modelling, such ontologies are less likely to be acyclic. Each test ontology can be accessed online from our ontology repository by means of a unique ID.5 Each ID identifies one self-contained OWL ontology \u2018frozen in time\u2019 with all of its imports resolved at the time the ontology was added to the repository; furthermore, any possible future version of the ontology will be assigned a fresh ID. These measures should ensure that our experiments can be independently repeated at any point in the future."}, {"heading": "7.1 Acyclicity Tests", "text": "We implemented all acyclicity checks by adapting the HermiT reasoner.6 HermiT was used to transform an ontology into DL-clauses\u2014formulae quite close to existential rules. In the result, at-least number restrictions in head atoms were replaced with existential quantification, atoms involving datatypes were eliminated, and the DL-clauses with no head atoms were removed: datatypes and empty heads can cause inconsistencies, but they cannot prevent the skolem chase from terminating.\nEach set of rules \u03a3 obtained by the above preprocessing steps was considered in combination with each acyclicity notion X \u2208 {WA, JA,MSA,MFA} as follows. If \u03a3 did not contain the equality predicate, we simply checked whether \u03a3 \u2208 X. If \u03a3 contained the equality predicate, we checked whether \u03a3 \u2208 X\u222a, and we also checked whether \u03a3\u2032 \u2208 X for \u03a3\u2032 \u2286 \u03a3 the set of all rules of \u03a3 that do not contain the equality predicate; these tests provided us with a \u2018lower\u2019 and an \u2018upper\u2019 bound for acyclicity, respectively. Each acyclicity test was performed by modifying \u03a3 (or \u03a3\u2032) as required by X and then running HermiT to check for a particular logical entailment on the critical instance.\nOur tests revealed MFA and MSA to be indistinguishable for all 336 test ontologies; that is, all MFA ontologies were found to be MSA as well (the converse holds per Theorem 14). A total of 213 (63.4%) ontologies were found to be MSA, including 43 of the 49 (87.8%) ontologies from the Gardiner corpus, 164 of the 208 (78.8%) OBO ontologies, and the LUBM ontology. In contrast, the GALEN ontology and its variants, the GO ontology and its extensions, and the 55 Phenoscape ontologies were found not to be MFA. These results are summarised in Table 2. Given the large number of ontologies tested, it would be impractical to present the results for each ontology individually. Instead, the ontologies are grouped by number of generating rules (G-rules), which are the rules containing an existential quantifier; for each group, Table 2 shows the total number of ontologies, as well as the numbers of ontologies found to be MSA, JA, and WA. Of the 123 ontologies that are not MFA, seven ontologies are in ELHr, so CQ answering over these ontologies can be realised using the combined approaches by Lutz et al. (2009) and Kontchakov et al. (2011).\nThe five older versions of OBO ontologies (IDs 00359, 00374, 00376, 00382, and 00486) are MSA, whereas their newer versions (IDs 00360, 00375, 00377, 00383, and 00487) are not MFA. In contrast, two older versions of OBO ontologies are not MFA (IDs 00432 and 00574), but their newer versions (IDs 00433 and 00575) are MSA.\n5. URL http://www.cs.ox.ac.uk/isg/ontologies/UID/xxxxx.owl can be used to download an ontology that has been assigned ID \u2018xxxxx\u2019. 6. http://www.hermit-reasoner.com/\nFinally, we found 15 large OBO ontologies (including different versions of the same ontologies) that are MSA but not JA. Thus, MSA seems to be particularly useful on complex ontologies since it analyses implications between existentially quantified variables more precisely than the previously known notions. Table 3 shows for each of these ontologies the number of generating rules (G-rules), whether the ontology uses the equality predicate (Eq), the ontology expressivity in the description logic family of languages (DL), and the number of classes (C), properties (P), and axioms (A) that the ontology contains. Different versions of the same ontology are distinguished in the table as \u2018old\u2019 and \u2018new\u2019. Two further ontologies (IDs 00762 and 00766) containing the equality predicate are MSA\u222a, but their status regarding joint acyclicity is unknown: they are JA when the rules involving the equality predicate are deleted, but are not JA\u222a."}, {"heading": "7.2 Materialisation Tests", "text": "To estimate the practicability of materialisation in acyclic ontologies, we measured the maximal depth of function symbol nesting in terms generated by materialisation on critical instances. This measure, which we call ontology depth, is of interest as it provides us with a bound on the size of the materialisation. Out of the 213 MSA ontologies, our test succeeded on 207 of them (tests were aborted if they did not finish in three hours). On the latter ontologies, depth was distributed as follows:\n\u2022 123 (59.4%) ontologies have depth less than 5;\n\u2022 30 (14.5%) ontologies have depth between 5 and 9;\n\u2022 47 (22.7%) ontologies have depth between 10 to 19;\n\u2022 5 (2.4%) ontologies have depth between 20 and 49; and\n\u2022 2 (1.0%) ontologies have depth between 50 to 70.\nThese results leads us to believe that many (but clearly not all) ontologies have manageable depths, which should allow for successful materialisation-based query answering.\nWe also computed the materialisation for several acyclic ontologies. As our implementation is prototypical, our primary goal was not to evaluate the performance of computing the materialisation, but rather to estimate the blowup in the number of facts. We clearly do\nnot expect this blowup to depend linearly on size of the input number of facts; however, our results should provide us with a rough estimate of the performance of materialisation-based reasoning in practice. Most of our test ontologies, however, do not contain many facts: ontologies are often constructed as general vocabularies, while facts are often applicationspecific and are thus not publicly available. To overcome this problem, we conducted two kinds of experiments.\nFirst, we computed the materialisation of two ontologies that contain facts: LUBM with one university (ID 00347), and the \u2018kmi-basic-portal\u2019 ontology (ID 00078). The TBox of LUBM has eight generating rules and depth one, and there are 100, 543 facts before ma-"}, {"heading": "10\u201370 54 9396 1807 1286 175 1297 189", "text": "terialisation. Materialisation took only 2 seconds, and it produced 231, 200 new facts, of which 97, 860 were added by the generating rules. The \u2018kmi-basic-portal\u2019 ontology has ten generating rules and depth two, and there were 198 facts before materialisation. Materialisation took only 0.03 seconds, and it produced 744 new facts, of which 145 were added by the generating rules.\nSecond, for each of the ontologies identified as MSA, we instantiated each class and each property with fresh individuals. We then computed the materialisation and measured the generated size (the number of facts introduced by the generating rules divided by the number of facts before materialisation), the materialisation size (the number of facts after materialisation divided by the number of facts before materialisation), and the time needed to compute the materialisation. Since most generating rules in these ontologies have singleton body atoms (i.e., they are of the form A(x)\u2192 \u2203R.C(x)), these measures should provide a reasonable estimate of the increase in the number of facts during materialisation. Table 4 summarises the results of our tests for the 207 ontologies on which the test succeeded. Ontologies are grouped by their depth, and each group shows the number of ontologies (#), and the maximal and average materialisation time, generated size, and materialisation size.\nThus, materialisation seems practically feasible for many ontologies: for 123 ontologies with depth less than 5, materialisation increases the ontology size by a factor of 8. This suggests that principled, materialisation-based reasoning for ontologies beyond the OWL 2 RL profile may be feasible, especially for ontologies with relatively small depths."}, {"heading": "8. Conclusions", "text": "In this paper, we investigated acyclicity notions\u2014sufficient conditions that ensure termination for skolem chase on existential rules. We proposed two novel notions, called MFA and MSA, for which we determined tight complexity bounds for membership checking, as well as for conjunctive query answering over acyclic existential rules.\nWe also conducted a thorough investigation of the acyclicity notions known in the literature, and we produced a complete taxonomy of their relative expressiveness. Our results show that MFA and MSA generalise most of the previously considered notions.\nWe next investigated ways to ensure acyclicity of existential rules that contain the equality predicate. To this end, we presented several optimisations of the singularisation technique by Marnette (2009). Our optimisations can often reduce the number of acyclicity checks needed, thus making the singularisation technique more suitable for practical use.\nFinally, we studied the problem of answering conjunctive queries over acyclic DL ontologies. On the theoretical side, we showed that acyclicity can make this problem computation-\nally easier; furthermore, provided that the result is acyclic, one can extend Horn ontologies with arbitrary SWRL rules without affecting decidability and the worst-case complexity of query answering. On the practical side, we investigated the extent to which acyclicity notions enable principled extensions of materialisation-based ontology reasoners with support for existential quantification. Our tests show that many ontologies commonly used in practice are acyclic, and that the blowup in the number of facts due to materialisation is manageable. This suggests that principled extensions of materialisation-based ontology reasoners are practically feasible and useful.\nAn interesting topic for future work is to see whether our acyclicity notions can be used in a more general logic programming setting. We see several main sources of technical difficulties towards this goal. First, general logic programs can contain functional terms in body atoms. Such terms can \u2018cancel out\u2019 function symbols introduced by head atoms, and it is not clear how to take this into account in an acyclicity test. Second, logic programs can contain atoms under nonmonotonic negation, which are likely to need special treatment; Magka, Kro\u0308tzsch, and Horrocks (2013) recently made a first step in that direction. Third, it might be desirable to modularise the ways in which these different concerns are handled and thus arbitrarily combine the approaches for handling function symbols in the body and/or the head with the approaches for dealing with nonmonotonic negation."}, {"heading": "Acknowledgments", "text": "This work was supported by the Royal Society, the Seventh Framework Program (FP7) of the European Commission under Grant Agreement 318338, \u2018Optique\u2019, and the EPSRC projects ExODA, Score!, and MaSI3."}], "references": [{"title": "The Description Logic Handbook: Theory, Implementation and Applications (2nd edition)", "author": ["F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": null, "citeRegEx": "Baader et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baader et al\\.", "year": 2007}, {"title": "Improving the Forward Chaining Algorithm for Conceptual Graphs Rules", "author": ["Baget", "J.-F"], "venue": "Proc. of the 9th Int. Conf. on Principles of Knowledge Representation and Reasoning", "citeRegEx": "Baget and J..F.,? \\Q2004\\E", "shortCiteRegEx": "Baget and J..F.", "year": 2004}, {"title": "On rules with existential variables: Walking the decidability line", "author": ["Baget", "J.-F", "M. Lecl\u00e8re", "Mugnier", "M.-L", "E. Salvat"], "venue": "Artificial Intelligence,", "citeRegEx": "Baget et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Baget et al\\.", "year": 2011}, {"title": "Towards Farsighted Dependencies for Existential Rules", "author": ["Baget", "J.-F", "Mugnier", "M.-L", "M. Thomazo"], "venue": "Proc. of the 5th Int. Conf. on Web Reasoning and Rule Systems (RR 2011),", "citeRegEx": "Baget et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Baget et al\\.", "year": 2011}, {"title": "Hyper Tableaux", "author": ["P. Baumgartner", "U. Furbach", "I. Niemel\u00e4"], "venue": "In Proc. of the European Workshop on Logics in Artificial Intelligence (JELIA \u201996),", "citeRegEx": "Baumgartner et al\\.,? \\Q1996\\E", "shortCiteRegEx": "Baumgartner et al\\.", "year": 1996}, {"title": "The Implication Problem for Data Dependencies", "author": ["C. Beeri", "M.Y. Vardi"], "venue": "Proc. of the 8th Colloquium on Automata, Languages and Programming (ICALP 1981),", "citeRegEx": "Beeri and Vardi,? \\Q1981\\E", "shortCiteRegEx": "Beeri and Vardi", "year": 1981}, {"title": "Implementing OWL 2 RL and OWL 2 QL rule-sets for OWLIM", "author": ["B. Bishop", "S. Bojanov"], "venue": "Proc. of the OWL: Expreiences and Directions Workshop (OWLED 2011),", "citeRegEx": "Bishop and Bojanov,? \\Q2011\\E", "shortCiteRegEx": "Bishop and Bojanov", "year": 2011}, {"title": "Sesame: A Generic Architecture for Storing and Querying RDF and RDF Schema", "author": ["J. Broekstra", "A. Kampman", "F. van Harmelen"], "venue": "Proc. of the 1st Int. Semantic Web Conf. (ISWC 2002),", "citeRegEx": "Broekstra et al\\.,? \\Q2002\\E", "shortCiteRegEx": "Broekstra et al\\.", "year": 2002}, {"title": "Query Answering under Non-guarded Rules in Datalog\u00b1", "author": ["A. Cal\u0300\u0131", "G. Gottlob", "A. Pieris"], "venue": "Proc. of the 4th Int. Conf. on Web Reasoning and Rule Systems (RR 2010),", "citeRegEx": "Cal\u0300\u0131 et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Cal\u0300\u0131 et al\\.", "year": 2010}, {"title": "New Expressive Languages for Ontological Query Answering", "author": ["A. Cal\u0300\u0131", "G. Gottlob", "A. Pieris"], "venue": "Proc. of the 25th National Conference on Artificial Intelligence (AAAI", "citeRegEx": "Cal\u0300\u0131 et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Cal\u0300\u0131 et al\\.", "year": 2011}, {"title": "Computable Functions in ASP: Theory and Implementation", "author": ["F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone"], "venue": "Proc. of the 24th Int. Conf. on Logic Programming (ICLP 2008),", "citeRegEx": "Calimeri et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Calimeri et al\\.", "year": 2008}, {"title": "Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family", "author": ["D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Calvanese et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Calvanese et al\\.", "year": 2007}, {"title": "Jena: Implementing the Semantic Web Recommendations", "author": ["J.J. Carroll", "I. Dickinson", "C. Dollin", "D. Reynolds", "A. Seaborne", "K. Wilkinson"], "venue": "Proc. of the 13th Int. Conf. on World Wide Web (WWW 2004)\u2014Alternate Track,", "citeRegEx": "Carroll et al\\.,? \\Q2004\\E", "shortCiteRegEx": "Carroll et al\\.", "year": 2004}, {"title": "Acyclicity Conditions and their Application to Query Answering in Description Logics", "author": ["B. Cuenca Grau", "I. Horrocks", "M. Kr\u00f6tzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang"], "venue": "Proc. of the 13th Int", "citeRegEx": "Grau et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2012}, {"title": "OWL 2: The next step for OWL", "author": ["B. Cuenca Grau", "I. Horrocks", "B. Motik", "B. Parsia", "P. Patel-Schneider", "U. Sattler"], "venue": "Journal of Web Semantics: Science, Services and Agents on the World Wide Web,", "citeRegEx": "Grau et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Grau et al\\.", "year": 2008}, {"title": "Complexity and expressive power of logic programming", "author": ["E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov"], "venue": "ACM Computing Surveys,", "citeRegEx": "Dantsin et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Dantsin et al\\.", "year": 2001}, {"title": "Termination of Logic Programs: The Never-Ending Story", "author": ["D. De Schreye", "S. Decorte"], "venue": "Journal of Logic Programming,", "citeRegEx": "Schreye and Decorte,? \\Q1994\\E", "shortCiteRegEx": "Schreye and Decorte", "year": 1994}, {"title": "Deciding Regular Grammar Logics with Converse Through First-Order Logic", "author": ["S. Demri", "H. de Nivelle"], "venue": "Journal of Logic, Language and Information,", "citeRegEx": "Demri and Nivelle,? \\Q2005\\E", "shortCiteRegEx": "Demri and Nivelle", "year": 2005}, {"title": "The chase revisited", "author": ["A. Deutsch", "A. Nash", "J.B. Remmel"], "venue": "Proc. of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS", "citeRegEx": "Deutsch et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Deutsch et al\\.", "year": 2008}, {"title": "Query Answering in the Description Logic Horn-SHIQ", "author": ["T. Eiter", "G. Gottlob", "M. Ortiz", "M. Simkus"], "venue": "Proc. of the 11th European Conference on Logics in Artificial Intelligence (JELIA 2008),", "citeRegEx": "Eiter et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Eiter et al\\.", "year": 2008}, {"title": "Data exchange: semantics and query answering", "author": ["R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa"], "venue": "Theoretical Computer Science,", "citeRegEx": "Fagin et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Fagin et al\\.", "year": 2005}, {"title": "Framework for an Automated Comparison of Description Logic Reasoners", "author": ["T. Gardiner", "D. Tsarkov", "I. Horrocks"], "venue": "Proc. of the 5th Int. Semantic Web Conference (ISWC 2006),", "citeRegEx": "Gardiner et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Gardiner et al\\.", "year": 2006}, {"title": "GrinGo: A New Grounder for Answer Set Programming", "author": ["M. Gebser", "T. Schaub", "S. Thiele"], "venue": "Proc. of the 9th Int. Conf. on Logic Programming and Nonmonotonic Reasoning (LPNMR 2007),", "citeRegEx": "Gebser et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Gebser et al\\.", "year": 2007}, {"title": "Conjunctive Query Answering for the Description Logic SHIQ", "author": ["B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Glimm et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Glimm et al\\.", "year": 2008}, {"title": "On the Termination of Logic Programs with Function Symbols", "author": ["S. Greco", "F. Spezzano", "I. Trubitsyna"], "venue": "Proc. of the 8th Int. Conf. on Logic Programming (ICLP 2012),", "citeRegEx": "Greco et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Greco et al\\.", "year": 2012}, {"title": "Structure-based classification and ontology in chemistry", "author": ["J. Hastings", "D. Magka", "C. Batchelor", "L. Duan", "R. Stevens", "M. Ennis", "C. Steinbeck"], "venue": "Journal of Cheminformatics,", "citeRegEx": "Hastings et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hastings et al\\.", "year": 2012}, {"title": "A Proposal for an OWL Rules Language", "author": ["I. Horrocks", "P.F. Patel-Schneider"], "venue": "In Proc. of the 13th Int. World Wide Web Conference (WWW", "citeRegEx": "Horrocks and Patel.Schneider,? \\Q2004\\E", "shortCiteRegEx": "Horrocks and Patel.Schneider", "year": 2004}, {"title": "A Tableau Decision Procedure for SHOIQ", "author": ["I. Horrocks", "U. Sattler"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Horrocks and Sattler,? \\Q2007\\E", "shortCiteRegEx": "Horrocks and Sattler", "year": 2007}, {"title": "Owl rules: A proposal and prototype implementation", "author": ["I. Horrocks", "P.F. Patel-Schneider", "S. Bechhofer", "D. Tsarkov"], "venue": "J. Web Sem.,", "citeRegEx": "Horrocks et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Horrocks et al\\.", "year": 2005}, {"title": "Data Complexity of Reasoning in Very Expressive Description Logics", "author": ["U. Hustadt", "B. Motik", "U. Sattler"], "venue": "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Hustadt et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Hustadt et al\\.", "year": 2005}, {"title": "Testing Containment of Conjunctive Queries under Functional and Inclusion Dependencies", "author": ["D.S. Johnson", "A.C. Klug"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "Johnson and Klug,? \\Q1984\\E", "shortCiteRegEx": "Johnson and Klug", "year": 1984}, {"title": "OWLIM \u2013 A Pragmatic Semantic Repository for OWL", "author": ["A. Kiryakov", "D. Ognyanov", "D. Manov"], "venue": "Proc. of the Int. Workshop on Web Information Systems Engineering (WISE 2005),", "citeRegEx": "Kiryakov et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Kiryakov et al\\.", "year": 2005}, {"title": "The Combined Approach to Ontology-Based Data Access", "author": ["R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev"], "venue": "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Kontchakov et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Kontchakov et al\\.", "year": 2011}, {"title": "Extending Decidable Existential Rules by Joining Acyclicity and Guardedness", "author": ["M. Kr\u00f6tzsch", "S. Rudolph"], "venue": "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Kr\u00f6tzsch and Rudolph,? \\Q2011\\E", "shortCiteRegEx": "Kr\u00f6tzsch and Rudolph", "year": 2011}, {"title": "On the Relationship of Joint Acyclicity and SuperWeak Acyclicity", "author": ["M. Kr\u00f6tzsch", "S. Rudolph"], "venue": "Tech. rep. 3037,", "citeRegEx": "Kr\u00f6tzsch and Rudolph,? \\Q2013\\E", "shortCiteRegEx": "Kr\u00f6tzsch and Rudolph", "year": 2013}, {"title": "Conjunctive Queries for a Tractable Fragment of OWL", "author": ["M. Kr\u00f6tzsch", "S. Rudolph", "P. Hitzler"], "venue": "Proc. of the 6th Int. Semantic Web Conference (ISWC 2007),", "citeRegEx": "Kr\u00f6tzsch et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Kr\u00f6tzsch et al\\.", "year": 2007}, {"title": "The Even More Irresistible SROIQ", "author": ["O. Kutz", "I. Horrocks", "U. Sattler"], "venue": "Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR", "citeRegEx": "Kutz et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Kutz et al\\.", "year": 2006}, {"title": "The DLV system for knowledge representation and reasoning", "author": ["N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello"], "venue": "ACM Transactions on Computational Logic,", "citeRegEx": "Leone et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Leone et al\\.", "year": 2006}, {"title": "One More Decidable Class of Finitely Ground Programs", "author": ["Y. Lierler", "V. Lifschitz"], "venue": "Proc. of the 25th Int. Conf. on Logic Programming (ICLP 2009),", "citeRegEx": "Lierler and Lifschitz,? \\Q2009\\E", "shortCiteRegEx": "Lierler and Lifschitz", "year": 2009}, {"title": "Conjunctive Query Answering in the Description Logic EL Using a Relational Database System", "author": ["C. Lutz", "D. Toman", "F. Wolter"], "venue": null, "citeRegEx": "Lutz et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Lutz et al\\.", "year": 2009}, {"title": "Computing Stable Models for Nonmonotonic Existential Rules", "author": ["D. Magka", "M. Kr\u00f6tzsch", "I. Horrocks"], "venue": "In Proc. of the 23rd Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Magka et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Magka et al\\.", "year": 2013}, {"title": "Modelling Structured Domains Using Description Graphs and Logic Programming", "author": ["D. Magka", "B. Motik", "I. Horrocks"], "venue": "Proc. of the 9th Extended Semantic Web Conference (ESWC 2012),", "citeRegEx": "Magka et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Magka et al\\.", "year": 2012}, {"title": "Testing Implications of Data Dependencies", "author": ["D. Maier", "A.O. Mendelzon", "Y. Sagiv"], "venue": "ACM Transactions on Database Systems,", "citeRegEx": "Maier et al\\.,? \\Q1979\\E", "shortCiteRegEx": "Maier et al\\.", "year": 1979}, {"title": "Generalized schema-mappings: from termination to tractability", "author": ["B. Marnette"], "venue": "Proc. of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS", "citeRegEx": "Marnette,? \\Q2009\\E", "shortCiteRegEx": "Marnette", "year": 2009}, {"title": "Tractable Schema Mappings Under Oblivious Termination", "author": ["B. Marnette"], "venue": "Ph.D. thesis,", "citeRegEx": "Marnette,? \\Q2010\\E", "shortCiteRegEx": "Marnette", "year": 2010}, {"title": "Combining a DL Reasoner and a Rule Engine for Improving Entailment-Based OWL Reasoning", "author": ["G. Meditskos", "N. Bassiliades"], "venue": "International Semantic Web Conference,", "citeRegEx": "Meditskos and Bassiliades,? \\Q2008\\E", "shortCiteRegEx": "Meditskos and Bassiliades", "year": 2008}, {"title": "On the Termination of the Chase Algorithm", "author": ["M. Meier"], "venue": "Ph.D. thesis, Universita\u0308t Freiburg", "citeRegEx": "Meier,? \\Q2010\\E", "shortCiteRegEx": "Meier", "year": 2010}, {"title": "On Chase Termination Beyond Stratification", "author": ["M. Meier", "M. Schmidt", "G. Lausen"], "venue": "Proceedings of the VLDB Endowment,", "citeRegEx": "Meier et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Meier et al\\.", "year": 2009}, {"title": "OWL 2 Web Ontology Language: Profiles, W3C Recommendation", "author": ["B. Motik", "B. Cuenca Grau", "I. Horrocks", "Z. Wu", "A. Fokoue", "C. Lutz"], "venue": null, "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "Hypertableau Reasoning for Description Logics", "author": ["B. Motik", "R. Shearer", "I. Horrocks"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Motik et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Motik et al\\.", "year": 2009}, {"title": "Experiences Using Logic Programming in Bioinformatics", "author": ["C. Mungall"], "venue": "Proc.o\u0301f the 25th Int. Conf. on Logic Programming (ICLP 2009),", "citeRegEx": "Mungall,? \\Q2009\\E", "shortCiteRegEx": "Mungall", "year": 2009}, {"title": "Data Complexity of Query Answering in Expressive Description Logics via Tableaux", "author": ["M. Ortiz", "D. Calvanese", "T. Eiter"], "venue": "Journal of Automated Reasoning,", "citeRegEx": "Ortiz et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2008}, {"title": "Query Answering in the Horn Fragments of the Description Logics SHOIQ and SROIQ", "author": ["M. Ortiz", "S. Rudolph", "M. Simkus"], "venue": "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI", "citeRegEx": "Ortiz et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Ortiz et al\\.", "year": 2011}, {"title": "Tractable Query Answering and Rewriting under Description Logic Constraints", "author": ["H. P\u00e9rez-Urbina", "B. Motik", "I. Horrocks"], "venue": "Journal of Applied Logic,", "citeRegEx": "P\u00e9rez.Urbina et al\\.,? \\Q2009\\E", "shortCiteRegEx": "P\u00e9rez.Urbina et al\\.", "year": 2009}, {"title": "Nominals, Inverses, Counting, and Conjunctive Queries or: Why Infinity is your Friend", "author": ["S. Rudolph", "B. Glimm"], "venue": "Journal of Artificial Intelligence Research,", "citeRegEx": "Rudolph and Glimm,? \\Q2010\\E", "shortCiteRegEx": "Rudolph and Glimm", "year": 2010}, {"title": "Chase Termination: A Constraints Rewriting Approach", "author": ["F. Spezzano", "S. Greco"], "venue": "Proceedings of the VLDB Endownment,", "citeRegEx": "Spezzano and Greco,? \\Q2010\\E", "shortCiteRegEx": "Spezzano and Greco", "year": 2010}, {"title": "Omega-Restricted Logic Programs", "author": ["T. Syrj\u00e4nen"], "venue": "Proc. of the 6th Int. Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2001),", "citeRegEx": "Syrj\u00e4nen,? \\Q2001\\E", "shortCiteRegEx": "Syrj\u00e4nen", "year": 2001}, {"title": "The Smodels System", "author": ["T. Syrj\u00e4nen", "I. Niemel\u00e4"], "venue": "Proc. of the 6th Int. Conf. on Logic Programming and Nonmonotonic Reasoning (LPNMR 2001),", "citeRegEx": "Syrj\u00e4nen and Niemel\u00e4,? \\Q2001\\E", "shortCiteRegEx": "Syrj\u00e4nen and Niemel\u00e4", "year": 2001}, {"title": "Implementing an Inference Engine for RDFS/OWL Constructs and UserDefined Rules in Oracle", "author": ["Z. Wu", "G. Eadon", "S. Das", "E.I. Chong", "V. Kolovski", "M. Annamalai", "J. Srinivasan"], "venue": "Proc. of the 24th Int. Conf. on Data Engineering (ICDE", "citeRegEx": "Wu et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Wu et al\\.", "year": 2008}], "referenceMentions": [{"referenceID": 50, "context": "Practical applications of existential rules range from bioinformatics (Mungall, 2009) to modelling complex structures of chemical compounds (Magka, Motik, & Horrocks, 2012; Hastings, Magka, Batchelor, Duan, Stevens, Ennis, & Steinbeck, 2012).", "startOffset": 70, "endOffset": 85}, {"referenceID": 20, "context": "Weak acyclicity (WA) (Fagin et al., 2005) was one of the first such notions, and it was extended to notions such as safety (Meier, Schmidt, & Lausen, 2009), stratification (Deutsch et al.", "startOffset": 21, "endOffset": 41}, {"referenceID": 18, "context": ", 2005) was one of the first such notions, and it was extended to notions such as safety (Meier, Schmidt, & Lausen, 2009), stratification (Deutsch et al., 2008), acyclicity of a graph of rule dependencies (aGRD) (Baget, Mugnier, & Thomazo, 2011b), joint acyclicity (JA) (Kr\u00f6tzsch & Rudolph, 2011), and super-weak acyclicity (SWA) (Marnette, 2009).", "startOffset": 138, "endOffset": 160}, {"referenceID": 43, "context": ", 2008), acyclicity of a graph of rule dependencies (aGRD) (Baget, Mugnier, & Thomazo, 2011b), joint acyclicity (JA) (Kr\u00f6tzsch & Rudolph, 2011), and super-weak acyclicity (SWA) (Marnette, 2009).", "startOffset": 177, "endOffset": 193}, {"referenceID": 56, "context": "Several such notions have been implemented in state of the art logic programming engines, such as omega-restrictedness (Syrj\u00e4nen, 2001) from the Smodels system (Syrj\u00e4nen & Niemel\u00e4, 2001), lambda-restrictedness from the ASP grounder GrinGo (Gebser, Schaub, & Thiele, 2007), argument-restrictedness (Lierler & Lifschitz, 2009) from the DLV system (Leone, Pfeifer, Faber, Eiter, Gottlob, Perri, & Scarcello, 2006), and many others (Calimeri, Cozza, Ianni, & Leone, 2008; Greco, Spezzano, & Trubitsyna, 2012; De Schreye & Decorte, 1994).", "startOffset": 119, "endOffset": 135}, {"referenceID": 43, "context": "Equality can be incorporated via singularisation\u2014a technique proposed by Marnette (2009) that transforms the rules to encode the effects of equality.", "startOffset": 73, "endOffset": 89}, {"referenceID": 43, "context": "Equality can be incorporated via singularisation\u2014a technique proposed by Marnette (2009) that transforms the rules to encode the effects of equality. Singularisation is orthogonal to acyclicity: after computing the transformed rules, one can use MFA, MSA, or in fact any notion to check whether the result is acyclic; if so, the chase of the signularised rules terminates, and the chase result can be used in a particular way to answer arbitrary CQs. Unfortunately, singularisation is nondeterministic: some ways of transforming the rules may produce acyclic rule sets, but not all ways are guaranteed to do so. In this paper, we refine singularisation to obtain practically useful upper and lower bounds for acyclicity. We also show that, when used with JA, our lower bound actually coincides with WA. We next turn our attention to theoretical and practical issues of using acyclicity for materialisation-based CQ answering over ontologies. On the theoretical side, we show that checking MFA and MSA of Horn-SROIF ontologies is ExpTime- and PTime-complete, respectively, and that answering CQs over acyclic Horn-SROIF ontologies is ExpTimecomplete as well. Furthermore, we show that, for Horn-SHIF ontologies, the complexity of checking MFA and of answering CQs drops to PSpace. Answering CQs is ExpTimecomplete for general (i.e., not acyclic) Horn-SHIF ontologies (Eiter, Gottlob, Ortiz, & Simkus, 2008; Ortiz, Rudolph, & Simkus, 2011), so acyclicity makes this problem easier. Furthermore, Horn ontologies can be extended with arbitrary SWRL rules (Horrocks & Patel-Schneider, 2004) without affecting decidability or worst-case complexity, provided that the union of the ontology and SWRL rules is acyclic; this is in contrast to the general case, where SWRL extensions of DLs easily lead to undecidability. On the practical side, we explore the limits of reasoning with acyclic OWL 2 ontologies via materialisation. We checked MFA, MSA, and JA for 336 Horn ontologies; furthermore, to estimate the impact of materialisation, we compared the size of the materialisation with the number of facts in the original ontologies. Our experiments revealed that many ontologies are MSA, and that some complex ones are MSA but not JA; furthermore, the universal models obtained via materialisation are typically not too large. Thus, our results suggest that principled, materialisation-based reasoning for ontologies beyond the OWL 2 RL profile may be practically feasible. This is an extended version of a paper by Cuenca Grau, Horrocks, Kr\u00f6tzsch, Kupke, Magka, Motik, and Wang (2012) published at KR 2012.", "startOffset": 73, "endOffset": 2579}, {"referenceID": 43, "context": "Answering CQs can be characterised using chase, and in this paper we use the skolem chase variant (Marnette, 2009).", "startOffset": 98, "endOffset": 114}, {"referenceID": 20, "context": "If the skolem chase of I and \u03a3 terminates, then both the nonoblivious chase (Fagin et al., 2005) and the core chase (Deutsch et al.", "startOffset": 76, "endOffset": 96}, {"referenceID": 18, "context": ", 2005) and the core chase (Deutsch et al., 2008) of I and \u03a3 terminate as well.", "startOffset": 27, "endOffset": 49}, {"referenceID": 43, "context": "The skolem chase for I\u2217 \u03a3 and \u03a3 terminates if and only if the skolem chase of \u03a3 terminates universally (Marnette, 2009).", "startOffset": 103, "endOffset": 119}, {"referenceID": 20, "context": "Weak acyclicity (WA) (Fagin et al., 2005) can be applied to existential rules that contain the equality predicate.", "startOffset": 21, "endOffset": 41}, {"referenceID": 43, "context": "Since \u03a3 is weakly acyclic and equalityfree, \u03a3 is super-weakly acyclic (Marnette, 2009); as we will show in Section 4 (see Theorem 19), \u03a3 is then MFA as well.", "startOffset": 70, "endOffset": 86}, {"referenceID": 8, "context": "Cal\u0300\u0131 et al. (2010b) show that, for such I, \u03a3, and Q, deciding I \u222a \u03a3 |= Q is 2ExpTime-complete.", "startOffset": 0, "endOffset": 21}, {"referenceID": 15, "context": "Checking whether I \u222a \u03a3 |= Q is ExpTime-complete in general (Dantsin et al., 2001).", "startOffset": 59, "endOffset": 81}, {"referenceID": 20, "context": "Weak acyclicity (Fagin et al., 2005) was one of the first such notions, and it has spurred on the research into more sophisticated notions for ensuring chase termination.", "startOffset": 16, "endOffset": 36}, {"referenceID": 55, "context": "The transformation by Spezzano and Greco (2010) produces a set \u03a3\u2032 that consists of three groups of rules.", "startOffset": 22, "endOffset": 48}, {"referenceID": 55, "context": "In contrast, \u03a3\u2032 is WA; furthermore, Spezzano and Greco (2010) show that, for each instance I and each vector of ground terms ~t, we have P\u0302 (~t) \u2208 I\u221e \u03a3\u2032 if and only if P (~t) \u2208 I\u221e \u03a3 .", "startOffset": 36, "endOffset": 62}, {"referenceID": 55, "context": "Finally, note that the transformation by Spezzano and Greco (2010) is independent from the notion used to check the acyclicity of the transformed rule set; hence, given an arbitrary acyclicity notion X, one can define Adn-X in the obvious way.", "startOffset": 41, "endOffset": 67}, {"referenceID": 2, "context": "Existential rules can capture knowledge representation formalisms such as Horn fragments of description logics (see Section 6), conceptual graphs (Baget, 2004; Baget et al., 2011a), and datalog\u00b1 rules (Cal\u0300\u0131 et al., 2010a), and so acyclicity notions allow for materialisationbased query answering over knowledge bases. In this context, Baget (2004) and Baget et al.", "startOffset": 160, "endOffset": 349}, {"referenceID": 2, "context": "Existential rules can capture knowledge representation formalisms such as Horn fragments of description logics (see Section 6), conceptual graphs (Baget, 2004; Baget et al., 2011a), and datalog\u00b1 rules (Cal\u0300\u0131 et al., 2010a), and so acyclicity notions allow for materialisationbased query answering over knowledge bases. In this context, Baget (2004) and Baget et al. (2011a) proposed the notion of acyclic graph rule dependencies (aGRD).", "startOffset": 160, "endOffset": 374}, {"referenceID": 18, "context": "This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al.", "startOffset": 143, "endOffset": 165}, {"referenceID": 18, "context": "This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al. (2012). It should be clear that Definition 23 is stronger than the one by Baget.", "startOffset": 143, "endOffset": 189}, {"referenceID": 18, "context": "This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al. (2012). It should be clear that Definition 23 is stronger than the one by Baget. To unify the notions used in various parts of this paper, we included this optimisation into Definition 23; however, we nevertheless call the resulting stronger notion aGRD. The following example shows that aGRD, even in its weaker form as originally proposed by Baget (2004), is not contained in SWA.", "startOffset": 143, "endOffset": 539}, {"referenceID": 24, "context": "Note that the additional condition by Greco et al. (2012) plays no role here.", "startOffset": 38, "endOffset": 58}, {"referenceID": 24, "context": "Note that the additional condition by Greco et al. (2012) plays no role here. Thus, we have r 6\u227a r, so \u03a3 is aGRD even in the weaker form by Baget (2004). However, one can easily check that \u03a3 is not SWA.", "startOffset": 38, "endOffset": 153}, {"referenceID": 18, "context": "Combinations of rule dependencies with acyclicity notions have also been considered in databases: Deutsch et al. (2008) proposed a notion of stratification, and Meier et al.", "startOffset": 98, "endOffset": 120}, {"referenceID": 18, "context": "Combinations of rule dependencies with acyclicity notions have also been considered in databases: Deutsch et al. (2008) proposed a notion of stratification, and Meier et al. (2009) further developed this idea and proposed a notion of c-stratification.", "startOffset": 98, "endOffset": 181}, {"referenceID": 18, "context": "Then, rule r is not applicable to R(t2, t3) or R(t3, t3) since in either case the head atom is satisfied; hence, the rule dependency graphs by Deutsch et al. and Meier et al. are both empty. These results can be summarised as follows: if a rule set \u03a3 satisfies the notion by Deutsch et al., then for each instance I there exists a finite nonoblivious chase sequence; furthermore, if \u03a3 satisfies the notion by Meier et al., then for each instance I all chase sequences (regardless of the rule application strategy) are finite. Meier (2010) discusses in detail the subtle differences between these notions.", "startOffset": 143, "endOffset": 539}, {"referenceID": 10, "context": "Furthermore, note that Calimeri et al. (2008) defined FD as follows:", "startOffset": 23, "endOffset": 46}, {"referenceID": 22, "context": "Finally, we note that \u03bb-restricted programs by Gebser et al. (2007) and \u03c9-restricted programs by Syrj\u00e4nen (2001) are both included in FD and AR; thus, when restricted to skolemised existential rules, these notions are also included in JA.", "startOffset": 47, "endOffset": 68}, {"referenceID": 22, "context": "Finally, we note that \u03bb-restricted programs by Gebser et al. (2007) and \u03c9-restricted programs by Syrj\u00e4nen (2001) are both included in FD and AR; thus, when restricted to skolemised existential rules, these notions are also included in JA.", "startOffset": 47, "endOffset": 113}, {"referenceID": 24, "context": "Thus, in the rest of this section, we simply reuse the rule dependency relation \u227a from Definition 23, which gives us a slightly stronger version of \u0393A for existential rules than the one proposed by Greco et al. (2012). Furthermore, Greco et al.", "startOffset": 198, "endOffset": 218}, {"referenceID": 24, "context": "Thus, in the rest of this section, we simply reuse the rule dependency relation \u227a from Definition 23, which gives us a slightly stronger version of \u0393A for existential rules than the one proposed by Greco et al. (2012). Furthermore, Greco et al. (2012) handle logic programming rules with functional terms in the body.", "startOffset": 198, "endOffset": 252}, {"referenceID": 24, "context": "Greco et al. (2012) stated that AR is strictly contained in \u0393A, but we were unable to find a formal proof of that statement; in fact, Example 44 shows that this is not the case, and that actually \u0393A\u227a ( AR\u227a holds.", "startOffset": 0, "endOffset": 20}, {"referenceID": 43, "context": "In order to use the skolem chase with rule sets such as the ones in Example 47, Marnette (2009) proposed the singularisation technique.", "startOffset": 80, "endOffset": 96}, {"referenceID": 43, "context": "In order to use the skolem chase with rule sets such as the ones in Example 47, Marnette (2009) proposed the singularisation technique. Roughly speaking, singularisation replaces the equality predicate \u2248 with a fresh binary predicate Eq to clarify that the two are to be treated differently; furthermore, it axiomatises Eq as reflexive, symmetric, and transitive, but it does not introduce replacement rules analogous to (4); finally, it modifies the rules in \u03a3 to take the lack of the replacement rules into account. The chase of the transformed rule set is not a model of \u03a3, but it can be used to answer queries over \u03a3 in a particular welldefined way. The modification of \u03a3, however, is nondeterministic: there are many ways to modify \u03a3 and, while some may ensure termination of the skolem chase, not all are required to do so. We next recapitulate the definition of singularisation by Marnette (2009).", "startOffset": 80, "endOffset": 904}, {"referenceID": 43, "context": "Marnette (2010) showed that, for an arbitrary \u03c1, interpretation \u03c1(I \u2032) is a universal model of \u03a3 and I\u2014that is, \u03c1(I \u2032) can be homomorphically embedded into an arbitrary model of \u03a3 and I.", "startOffset": 0, "endOffset": 16}, {"referenceID": 52, "context": ", not acyclic) DL TBoxes is 2ExpTime- and ExpTime-complete for Horn-SROIF (Ortiz et al., 2011) and Horn-SHIF (Eiter et al.", "startOffset": 74, "endOffset": 94}, {"referenceID": 19, "context": ", 2011) and Horn-SHIF (Eiter et al., 2008), respectively.", "startOffset": 22, "endOffset": 42}, {"referenceID": 48, "context": "Motik et al. (2009b) prove an analogous claim for a more general description logic, and their proof carries over to the above setting with only syntactic changes.", "startOffset": 0, "endOffset": 21}, {"referenceID": 38, "context": "Of the 123 ontologies that are not MFA, seven ontologies are in ELH, so CQ answering over these ontologies can be realised using the combined approaches by Lutz et al. (2009) and Kontchakov et al.", "startOffset": 156, "endOffset": 175}, {"referenceID": 32, "context": "(2009) and Kontchakov et al. (2011). The five older versions of OBO ontologies (IDs 00359, 00374, 00376, 00382, and 00486) are MSA, whereas their newer versions (IDs 00360, 00375, 00377, 00383, and 00487) are not MFA.", "startOffset": 11, "endOffset": 36}, {"referenceID": 43, "context": "To this end, we presented several optimisations of the singularisation technique by Marnette (2009). Our optimisations can often reduce the number of acyclicity checks needed, thus making the singularisation technique more suitable for practical use.", "startOffset": 84, "endOffset": 100}], "year": 2013, "abstractText": "Answering conjunctive queries (CQs) over a set of facts extended with existential rules is a prominent problem in knowledge representation and databases. This problem can be solved using the chase algorithm, which extends the given set of facts with fresh facts in order to satisfy the rules. If the chase terminates, then CQs can be evaluated directly in the resulting set of facts. The chase, however, does not terminate necessarily, and checking whether the chase terminates on a given set of rules and facts is undecidable. Numerous acyclicity notions were proposed as sufficient conditions for chase termination. In this paper, we present two new acyclicity notions called model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA). Furthermore, we investigate the landscape of the known acyclicity notions and establish a complete taxonomy of all notions known to us. Finally, we show that MFA and MSA generalise most of these notions. Existential rules are closely related to the Horn fragments of the OWL 2 ontology language; furthermore, several prominent OWL 2 reasoners implement CQ answering by using the chase to materialise all relevant facts. In order to avoid termination problems, many of these systems handle only the OWL 2 RL profile of OWL 2; furthermore, some systems go beyond OWL 2 RL, but without any termination guarantees. In this paper we also investigate whether various acyclicity notions can provide a principled and practical solution to these problems. On the theoretical side, we show that query answering for acyclic ontologies is of lower complexity than for general ontologies. On the practical side, we show that many of the commonly used OWL 2 ontologies are MSA, and that the number of facts obtained by materialisation is not too large. Our results thus suggest that principled development of materialisation-based OWL 2 reasoners is practically feasible.", "creator": "TeX"}}}