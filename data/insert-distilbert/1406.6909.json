{"id": "1406.6909", "review": {"conference": "nips", "VERSION": "v1", "DATE_OF_SUBMISSION": "26-Jun-2014", "title": "Discriminative Unsupervised Feature Learning with Exemplar Convolutional Neural Networks", "abstract": "current methods for training convolutional neural networks principally depend on large amounts of labeled neurons samples for supervised training. in this paper we present an approach for training a thoroughly convolutional neural network analyst using only unlabeled data. we train the network to discriminate between a set of surrogate classes. each surrogate class is formed by applying a variety of transformations to achieve a randomly sampled'seed'image memory patch. we find that this simple feature learning algorithm is definitely surprisingly successful when applied to abstract visual object recognition. the complexity feature representation learned quickly by our algorithm achieves earlier classification results than matching or outperforming the current state - scenario of - the - art for unsupervised learning agents on several popular datasets ( stl - 10, cifar - tc 10, caltech - 101 ).", "histories": [["v1", "Thu, 26 Jun 2014 15:07:14 GMT  (667kb,D)", "http://arxiv.org/abs/1406.6909v1", null], ["v2", "Fri, 19 Jun 2015 11:43:36 GMT  (7431kb,D)", "http://arxiv.org/abs/1406.6909v2", "PAMI submission. Includes matching experiments as inarXiv:1405.5769v1. Also includes new network architectures, experiments on Caltech-256, experiment on combining Exemplar-CNN with clustering"]], "reviews": [], "SUBJECTS": "cs.LG cs.CV cs.NE", "authors": ["alexey dosovitskiy", "philipp fischer", "jost tobias springenberg", "martin riedmiller", "thomas brox"], "accepted": true, "id": "1406.6909"}, "pdf": {"name": "1406.6909.pdf", "metadata": {"source": "CRF", "title": "Discriminative Unsupervised Feature Learning with Convolutional Neural Networks", "authors": ["Alexey Dosovitskiy", "Jost Tobias Springenberg", "Martin Riedmiller"], "emails": ["dosovits@cs.uni-freiburg.de", "springj@cs.uni-freiburg.de", "riedmiller@cs.uni-freiburg.de", "brox@cs.uni-freiburg.de"], "sections": [{"heading": "1 Introduction", "text": "Convolutional neural networks (CNNs) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories [1, 2]. While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5]. The capability to generalize to new datasets makes supervised CNN training an attractive approach for generic visual feature learning.\nThe downside of this approach is the need for expensive labeling, as the amount of required labeled samples grows quickly the larger the model gets. The large performance increase achieved by methods based on the work of Krizhevsky et al. [1] was only possible due to massive efforts on manually annotating millions of images. For this reason, unsupervised learning \u2013 although currently underperforming \u2013 remains an appealing paradigm, since it can make use of raw unlabeled images and videos. Furthermore, on vision tasks outside classification it is not even sure, if training based on object class labels is advantageous. For example, unsupervised feature learning is known to be beneficial for image restoration [6] and recent results show that it outperforms supervised feature learning also on descriptor matching [7].\nIn this work we combine the power of a discriminative objective with the major advantage of unsupervised feature learning: cheap data acquisition. We introduce a novel training procedure for convolutional neural networks that does not require any labeled data. It rather relies on an automatically generated surrogate task. The task is created by taking the idea of data augmentation \u2013 which is commonly used in supervised learning \u2013 to the extreme. Starting with trivial surrogate classes consisting of one random image patch each, we augment the data by applying a random set of transformations to each patch. Then we train a CNN to classify these surrogate classes.\nar X\niv :1\n40 6.\n69 09\nv1 [\ncs .L\nG ]\n2 6\nJu n\nThe feature representation learned by the network is, by construction, discriminative and invariant to typical transformations. We confirm this both theoretically and empirically, showing that this approach matches or outperforms all previous unsupervised feature learning methods on the standard image classification benchmarks STL-10, CIFAR-10, and Caltech-101."}, {"heading": "1.1 Related Work", "text": "Our approach is related to a large body of work on unsupervised learning of invariant features and training of convolutional neural networks.\nConvolutional training is commonly used in both supervised and unsupervised methods to utilize the invariance of image statistics to translations (e.g. LeCun et al. [3], Kavukcuoglu et al. [8], Krizhevsky et al. [1]). Similar to our approach the current surge of successful methods employing convolutional neural networks for object recognition often rely on data augmentation to generate additional training samples for their classification objective (e.g. Krizhevsky et al. [1], Zeiler and Fergus [2]). While we share the architecture (a convolutional neural network) with these approaches, our method does not rely on any labeled training data.\nIn unsupervised learning, several studies on learning invariant representations exist. Denoising autoencoders [9], for example, learn features that are robust to noise by trying to reconstruct data from randomly perturbed input samples. Similarly, contractive autoencoders [10] penalize the sensitivity of the feature representation to small changes in the input. Zou et al. [11] learn invariant features from video by enforcing a temporal slowness constraint on the feature representation learned by a linear autoencoder. Sohn and Lee [12] and Hui [13] learn features invariant to local image transformations. In contrast to our discriminative approach, all these methods rely on directly modeling the input distribution and are typically hard to use for jointly training multiple layers of a CNN.\nThe idea of learning features that are invariant to transformations has also been explored for supervised training of neural networks. The research most similar to ours is early work on tangent propagation [14] (and the related double backpropagation [15]) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations. In contrast, our algorithm does not regularize the derivative explicitly. Thus it is less sensitive to the magnitude of the applied transformation.\nThis work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training [16] or entropy regularization [17]. In contrast to these semi-supervised methods, our network training does not require any labeled data.\nFinally, the idea of creating an auxiliary task in order to learn a good data representation was used by Ahmed et al. [18], Collobert et al. [19]."}, {"heading": "2 Creating Surrogate Training Data", "text": "The input to the training procedure is a set of unlabeled images, which come from roughly the same distribution as the images to which we later aim to apply the learned features. We randomly sample N \u2208 [50, 32000] patches of size 32\u00d732 pixels from different images at varying positions and scales forming the initial training set X = {x1, . . .xN}. We are interested in patches containing objects or parts of objects, hence we sample only from regions containing considerable gradients.\nWe define a family of transformations {T\u03b1|\u03b1 \u2208 A} parameterized by vectors \u03b1 \u2208 A, where A is the set of all possible parameter vectors. Each transformation T\u03b1 is a composition of elementary transformations from the following list:\n\u2022 translation: vertical or horizontal translation by a distance within 0.2 of the patch size; \u2022 scaling: multiplication of the patch scale by a factor between 0.7 and 1.4; \u2022 rotation: rotation of the image by an angle up to 20 degrees; \u2022 contrast 1: multiply the projection of each patch pixel onto the principal components of the\nset of all pixels by a factor between 0.5 and 2 (factors are independent for each principal component and the same for all pixels within a patch);\n\u2022 contrast 2: raise saturation and value (S and V components of the HSV color representation) of all pixels to a power between 0.25 and 4 (same for all pixels within a patch), multiply these values by a factor between 0.7 and 1.4, add to them a value between \u22120.1 and 0.1; \u2022 color: add a value between \u22120.1 and 0.1 to the hue (H component of the HSV color representation) of all pixels in the patch (the same value is used for all pixels within a patch).\nAll numerical parameters of elementary transformations, when concatenated together, form a single parameter vector \u03b1. For each initial patch xi \u2208 X we sample K \u2208 [1, 300] random parameter vectors {\u03b11i , . . . , \u03b1Ki } and apply the corresponding transformations Ti = {T\u03b11i , . . . , T\u03b1Ki } to the patch xi. This yields the set of its transformed versions Sxi = Tixi = {Txi|T \u2208 Ti}. Afterwards we subtract the mean of each pixel over the whole resulting dataset. We do not apply any other preprocessing. Exemplary patches sampled from the STL-10 unlabeled dataset are shown in Fig. 1. Examples of transformed versions of one patch are shown in Fig. 2 ."}, {"heading": "3 Learning Algorithm", "text": "Given the sets of transformed image patches, we declare each of these sets to be a class by assigning label i to the class Sxi . We next train a CNN to discriminate between these surrogate classes. Formally, we minimize the following loss function:\nL(X) = \u2211 xi\u2208X \u2211 T\u2208Ti l(i, Txi), (1)\nwhere l(i, Txi) is the loss on the transformed sample Txi with (surrogate) true label i. We use a CNN with a softmax output layer and optimize the multinomial negative log likelihood of the network output, hence in our case\nl(i, Txi) =M(ei, f(Txi)), M(y, f) = \u2212\u3008y, log f\u3009 = \u2212 \u2211 k yk log fk, (2)\nwhere f(\u00b7) denotes the function computing the values of the output layer of the CNN given the input data, and ei is the ith standard basis vector. We note that in the limit of an infinite number of transformations per surrogate class, the objective function (1) takes the form\nL\u0302(X) = \u2211 xi\u2208X E\u03b1[l(i, T\u03b1xi)], (3)\nwhich we shall analyze in the next section.\nIntuitively, the classification problem described above serves to ensure that different input samples can be distinguished. At the same time, it enforces invariance to the specified transformations. In the following sections we provide a foundation for this intuition. We first present a formal analysis of the objective, separating it into a well defined classification problem and a regularizer that enforces invariance (resembling the analysis in Wager et al. [20]). We then discuss the derived properties of this classification problem and compare it to common practices for unsupervised feature learning."}, {"heading": "3.1 Formal Analysis", "text": "We denote by \u03b1 \u2208 A the random vector of transformation parameters, by g(x) the vector of activations of the second-to-last layer of the network when presented the input patch x, by W the matrix of the weights of the last network layer, by h(x) = Wg(x) the last layer activations before applying the softmax, and by f(x) = softmax (h(x)) the output of the network. By plugging in the definition of the softmax activation function\nsoftmax (z) = exp(z)/\u2016 exp(z)\u20161 (4)\nthe objective function (3) with loss (2) takes the form\u2211 xi\u2208X E\u03b1 [ \u2212\u3008ei, h(T\u03b1xi)\u3009+ log \u2016 exp(h(T\u03b1xi))\u20161 ] . (5)\nWith g\u0302i = E\u03b1 [g(T\u03b1xi)] being the average feature representation of transformed versions of the image patch xi we can rewrite Eq. (5) as\u2211\nxi\u2208X\n[ \u2212\u3008ei, Wg\u0302i\u3009+ log \u2016 exp(Wg\u0302i)\u20161 ] + \u2211 xi\u2208X [ E\u03b1 [log \u2016 exp(h(T\u03b1xi))\u20161]\u2212 log \u2016 exp(Wg\u0302i)\u20161 ] .\n(6)\nThe first sum is the objective function of a multinomial logistic regression problem with input-target pairs (g\u0302i, ei). This objective falls back to the transformation-free instance classification problem L(X) = \u2211 xi\u2208X l(i, xi) if g(xi) = E\u03b1[g(T\u03b1x)]. In general, this equality does not hold and thus the first sum enforces correct classification of the average representation E\u03b1[g(T\u03b1xi)] for a given input sample. For a truly invariant representation, however, the equality is achieved. Similarly, if we suppose that T\u03b1x = x for \u03b1 = 0, that for small values of \u03b1 the feature representation g(T\u03b1xi) is approximately linear with respect to \u03b1 and that the random variable \u03b1 is centered, i.e. E\u03b1 [\u03b1] = 0, then g\u0302i = E\u03b1 [g(T\u03b1xi)] \u2248 E\u03b1 [g(xi) + \u2207\u03b1(g(T\u03b1xi))|\u03b1=0 \u03b1] = g(xi). The second sum in Eq. (6) can be seen as a regularizer enforcing all h(T\u03b1xi) to be close to their average value, i.e., the feature representation is sought to be approximately invariant to the transformations T\u03b1. To show this we use the convexity of the function log \u2016 exp(\u00b7)\u20161 and Jensen\u2019s inequality, which yields (proof in supplementary material)\nE\u03b1 [log \u2016 exp(h(T\u03b1xi))\u20161]\u2212 log \u2016 exp(Wg\u0302i)\u20161 \u2265 0. (7)\nIf the feature representation is perfectly invariant, then h(T\u03b1xi) = Wg\u0302i and inequality (12) turns to equality, meaning that the regularizer reaches its global minimum."}, {"heading": "3.2 Conceptual Comparison to Previous Unsupervised Learning Methods", "text": "Suppose we want to unsupervisedly learn a feature representation useful for a recognition task, for example classification. The mapping from input images x to a feature representation g(x) should then satisfy two requirements: (1) there must be at least one feature that is similar for images of the same category y (invariance); (2) there must be at least one feature that is sufficiently different for images of different categories (ability to discriminate).\nMost unsupervised feature learning methods aim to learn such a representation by modeling the input distribution p(x). This is based on the assumption that a good model of p(x) contains information about the category distribution p(y|x). That is, if a representation is learned, from which a given sample can be reconstructed perfectly, then the representation is expected to also encode information about the category of the sample (ability to discriminate). Additionally, the learned representation should be invariant to variations in the samples that are irrelevant for the classification task, i.e., it should adhere to the manifold hypothesis (see e.g. Rifai et al. [21] for a recent discussion). Invariance is classically achieved by regularization of the latent representation, e.g., by enforcing sparsity [8] or robustness to noise [9].\nIn contrast, the discriminative objective in Eq. (1) does not directly model the input distribution p(x) but learns a representation that discriminates between input samples. The representation is not\nrequired to reconstruct the input, which is unnecessary in a recognition or matching task. This leaves more degrees of freedom to model the desired variability of a sample. As shown in our analysis (see Eq. (12)), we achieve partial invariance to transformations applied during surrogate data creation by forcing the representation g(T\u03b1xi) of the transformed image patch to be predictive of the surrogate label assigned to the original image patch xi.\nAn assumption of our approach is that the transformations T\u03b1 do not change the identity of the image content. Imagine a task that mainly relies on color information, as differentiating black panthers from pumas. If we use a color transformation, we will force the network to be invariant to this change and cannot expect the extracted features to perform well in this task1."}, {"heading": "4 Experiments", "text": "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [22], CIFAR-10 [23] and Caltech-101 [24] datasets. Moreover, we assess the influence of the augmentation parameters on the classification performance and study the invariance properties of the network."}, {"heading": "4.1 Experimental Setup", "text": "The datasets we test on differ in the number of classes (10 for CIFAR and STL, 101 for Caltech) and the number of samples per class. STL is especially well suited for unsupervised learning as it contains a large set of 100,000 unlabeled samples. In all experiments (except for the dataset transfer experiment in the supplementary material) we extracted surrogate training data from the unlabeled subset of STL-10. When testing on CIFAR-10, we resized the images from 32\u00d732 pixels to 64\u00d764 pixels so that the scale of depicted objects roughly matches the two other datasets.\nWe worked with two network architectures. A \u201csmall\u201d network was used to evaluate the influence of different components of the augmentation procedure on classification performance. It consists of two convolutional layers with 64 filters each followed by a fully connected layer with 128 neurons. This last layer is succeeded by a softmax layer, which serves as the network output. A \u201clarge\u201d network, consisting of three convolutional layers with 64, 128 and 256 filters respectively followed by a fully connected layer with 512 neurons, was trained to compare our method to the state-ofthe-art. In both models all convolutional filters are connected to a 5 \u00d7 5 region of their input. 2\u00d7 2 max-pooling was performed after the first and second convolutional layers. Dropout [25] was applied to the fully connected layers. We trained the networks using an implementation based on Caffe [26]. Details on the training procedure, the hyperparameter settings, and an analysis of the performance depending on the network architecture is provided in the supplementary material.\nWe applied the feature representation to images of arbitrary size by convolutionally computing the responses of all the network layers except the top softmax. To each feature map, we applied the pooling method that is commonly used on the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure on STL-10 and CIFAR-10 [27, 11, 28, 13]; 2) 3-layer spatial pyramid, i.e. max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 \u00d7 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard on Caltech-101 [29, 11, 30]. Finally, we trained a linear support vector machine (SVM) on the pooled features.\nOn all datasets we used the standard training and test protocols. On STL-10 the SVM was trained on 10 pre-defined folds of the training data. We report the mean and standard deviation achieved on the fixed test set. For CIFAR-10 we report two results: (1) training the SVM on the whole CIFAR10 training set (\u2019CIFAR-10\u2019); (2) the average over 10 random selections of 400 training samples per class (\u2019CIFAR-10(400)\u2019). For Caltech-101 we follow the usual protocol of selecting 30 random samples per class for training and not more than 50 samples per class for testing. This is repeated 10 times.\n1Such cases could be covered either by careful selection of applied transformations or by combining features from multiple networks trained with different sets of transformations and letting the final classifier choose which features to use."}, {"heading": "4.2 Classification Results", "text": "In Table 1 we compare our method to several unsupervised feature learning methods, including the current state-of-the-art on each dataset. We do not compare to supervised methods which use class labels for learning feature representations. Additionally we show the dimensionality of the feature vectors produced by each method before final pooling. The small network was trained on 8000 surrogate classes containing 150 samples each and the large one on 16000 classes with 100 samples each.\nThe features extracted from the larger network match or outperform the best prior result on all datasets. This is despite the fact that the dimensionality of the feature vector is smaller than that of most other approaches and that the networks are trained on the STL-10 unlabeled dataset (i.e. they are used in a transfer learning manner when applied to CIFAR-10 and Caltech 101). The increase in performance is especially pronounced when only few labeled samples are available for training the SVM (as is the case for all the datasets except full CIFAR-10). This is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an SVM typically becomes less dependent on the quality of the extracted features [27, 13]. Remarkably, on STL-10 we achieve an accuracy of 72.8% \u00b1 0.4%, which is a large improvement over all previously reported results."}, {"heading": "4.3 Detailed Analysis", "text": "Apart from the overall classification results, we studied the effect of three design choices in our approach and validate the invariance properties of the learned features. Additional experiments on the influence of the dataset, from which the \u2019seed\u2019 patches are sampled, can be found in the supplementary material. We used the \u201csmall\u201d network in all experiments reported below."}, {"heading": "4.3.1 Number of Surrogate Classes", "text": "We varied the number N of surrogate classes between 50 and 32000. As a sanity check, we also tried classification with random filters. The results are shown in Fig. 3.\nClearly, the classification accuracy increases with the number of surrogate classes until it reaches an optimum for about 8000 surrogate classes after which it did not change or even decreased. This is to be expected: the larger the number of surrogate classes, the more likely it is to draw very similar or even identical samples, which are hard or impossible to discriminate. Few such cases are not detrimental to the classification performance, but as soon as such collisions dominate the set of surrogate labels, the discriminative loss is no longer reasonable. The classification problem becomes too difficult and adapting the network to the surrogate task no longer succeeds. To check the validity of this explanation we also plot in Fig. 3 the classification error on the validation set (taken from the surrogate data) computed after training the network. It rapidly grows as the number of surrogate classes increases. We also observed that the optimal number of surrogate classes increases with\n2 There are two ways to compute the test accuracy on Caltech-101: average accuracy over all samples (average overall accuracy) or calculate the accuracy for each class separately and then average these values (average per-class accuracy). These differ, as some classes contain fewer than 50 test samples. We found that most researchers in machine learning use average overall accuracy, hence this is what we report in the tables.\nthe size of the network (not shown in the figure), but eventually saturates. This demonstrates the main limitation of our current approach of randomly sampling \u2019seed\u2019 patches: it does not scale to arbitrarily large amounts of unlabeled data. However, we do not see this as a fundamental restriction and discuss possible solutions in Section 5 ."}, {"heading": "4.3.2 Number of Samples per Surrogate Class", "text": "Fig. 4 shows the classification accuracy when the number K of training samples per surrogate class varies between 1 and 300. The performance improves with more samples per surrogate class and saturates at around 100 samples. This indicates that this amount is sufficient to approximate the formal objective from Eq. (3), hence further increasing the number of samples does not significantly change the optimization problem. On the other hand, if the number of samples is too small, there is insufficient data to learn the desired invariance properties.\n4.3.3 Types of Transformations\nWe varied the transformations used for creating the surrogate data to analyze their influence on the final classification performance. The set of \u2019seed\u2019 patches was fixed. The result is shown in Fig. 5. The value \u20190\u2019 corresponds to applying random compositions of all elementary transformations: scaling, rotation, translation, color variation, and contrast variation. Different columns of the plot show the difference in classification accuracy as we discarded some types of elementary transformations.\nSeveral tendencies can be observed. First, rotation and scaling have only a minor impact on the performance, while translations, color variations and contrast variations are significantly more important. Secondly, the results on STL-\n10 and CIFAR-10 consistently show that spatial invariance and color-contrast invariance are approximately of equal importance for the classification performance. This indicates that variations in color and contrast, though often neglected, may also improve performance in a supervised learning scenario. Thirdly, on Caltech-101 color and contrast transformations are much more important compared to spatial transformations than on the two other datasets. This is not surprising, since Caltech-101 images are often well aligned, and this dataset bias makes spatial invariance less useful."}, {"heading": "4.3.4 Invariance Properties of the Learned Representation", "text": "In a final experiment, we analyzed to which extent the representation learned by the network is invariant to the transformations applied during training. We randomly sampled 500 images from the\nSTL-10 test set and applied a range of transformations (translation, rotation, contrast, color) to each image. To avoid empty regions beyond the image boundaries when applying spatial transformations, we cropped the central 64\u00d764 pixel sub-patch from each 96\u00d796 pixel image. We then applied two measures of invariance to these patches.\nFirst, as an explicit measure of invariance, we calculated the normalized Euclidean distance between normalized feature vectors of the original image patch and the transformed one [11] (see the supplementary material for details). The downside of this approach is that the distance between extracted features does not take into account how informative and discriminative they are.\nWe therefore evaluated a second measure \u2013 classification performance depending on the magnitude of the transformation applied to the classified patches \u2013 which does not come with this problem. To compute the classification accuracy, we trained an SVM on the central 64 \u00d7 64 pixel patches from one fold of the STL-10 training set and measured classification performance on all transformed versions of 500 samples from the test set.\nThe results of both experiments are shown in Fig. 6 . Due to space restrictions we show only few representative plots. Overall the experiment empirically confirms that our objective function leads to learning invariant features. Features in the third layer and the final pooled feature representation compare favorably to a HOG baseline (Fig. 6 (a)). Furthermore, adding stronger transformations in the surrogate training data leads to more invariant classification with respect to these transformations (Fig. 6 (b)-(d)). However, adding too much contrast variation may deteriorate classification performance (Fig. 6 (d)). One possible reason is that level of contrast can be a useful feature: for example, strong edges in an image are usually more important than weak ones."}, {"heading": "5 Discussion", "text": "We have proposed a way to use a discriminative objective for unsupervised feature learning by training a CNN without class labels. The core idea is to generate a set of surrogate labels via data augmentation. The features learned by the network yield a large improvement in classification accuracy compared to features obtained with previous unsupervised methods. These results strongly indicate that a discriminative objective is superior to objectives previously used for unsupervised feature learning.\nOne potential shortcoming of the proposed method is that in its current state it does not scale to arbitrarily large datasets. Two probable reasons for this are that (1) as the number of surrogate classes grows larger, many of them become similar, which contradicts the discriminative objective, and (2) the surrogate task we use is relatively simple and does not allow the network to learn invariance to complex variations, such as 3D viewpoint changes or inter-instance variation. We hypothesize that the presented approach could learn more powerful higher-level features, if the surrogate data were more diverse. This could be achieved by using additional weak supervision, for example, by means of video or a small number of labeled samples. Another possible way of obtaining richer surrogate training data and at the same time avoiding similar surrogate classes would be (unsupervised) merging of similar surrogate classes. We see these as interesting directions for future work."}, {"heading": "Acknowledgements", "text": "We acknowledge funding by the ERC Starting Grant VideoLearn (279401); the work was also partly supported by the BrainLinks-BrainTools Cluster of Excellence funded by the German Research Foundation (DFG, grant number EXC 1086)."}, {"heading": "1 Formal Analysis", "text": "In this section we present the proofs for the formal analysis from Section 3.1 of our paper.\nProposition 1 The function Z(x) = log \u2016 exp(x)\u20161, x \u2208 Rn is convex. Moreover, for any x \u2208 Rn the kernel of its Hessian matrix\u22072Z(x) is given by span (1)\nProof Since\nZ(x) = log \u2016 exp(x)\u20161 = log n\u2211 i=1 exp(xi) (8)\nwe need to prove the convexity of the log-sum-exp function. The Hessian \u22072 of this function is given as\n\u22072Z(x) = 1 (1Tu)2 ((1Tu) diag (u)\u2212 uuT ), (9)\nwith u = exp(x) and 1 \u2208 Rn being a vector of ones. To show the convexity we must prove that zT\u22072Z(x)z \u2265 0 for all x, z \u2208 Rn. From (10) we get\nzT \u22072Z(x) z = 1 (1Tu)2 ((1Tu) zT diag (u) z\u2212 zTuuT z)\n= ( \u2211n k=1 ukz 2 k)( \u2211n k=1 uk)\u2212 ( \u2211n k=1 ukzk) 2\n( \u2211n k=1 uk) 2 \u2265 0 (10)\nsince ( \u2211n k=1 uk) 2 \u2265 0 and ( \u2211n k=1 zkuk) 2 \u2264 ( \u2211n k=1 ukz 2 k)( \u2211n k=1 uk) due to the Cauchy-Schwarz inequality.\nInequality (10) only turns to equality if \u221a ukzk = c \u221a uk, (11)\nwhere the constant c does not depend on k. This immediately gives z = c1, which proves the second statement of the proposition.\nProposition 2 Let \u03b1 \u2208 A be a random vector with values in a bounded setA \u2282 Rk. Let x(\u00b7) : A \u2192 Rn be a continuous function. Then inequality\nE\u03b1 [log \u2016 exp(x(\u03b1))\u20161]\u2212 log \u2016 exp(E\u03b1[x(\u03b1)])\u20161 \u2265 0 (12) holds and only turns to equality if for all \u03b11, \u03b12 \u2208 A: (x(\u03b11)\u2212 x(\u03b12)) \u2208 span (1) .\nProof Inequality (12) immediately follows from convexity of the function log \u2016 exp(\u00b7)\u20161 and Jensen\u2019s inequality.\nJensen\u2019s inequality only turns to equality if the function it is applied to is affine-linear on the convex hull of the integration region. In particular this implies\n(x(\u03b11)\u2212 x(\u03b12))T \u22072Z(x(\u03b11)) (x(\u03b11)\u2212 x(\u03b12)) = 0 (13) for all \u03b11, \u03b12 \u2208 A. The second statement of Proposition 1 thus immediately gives x(\u03b11)\u2212x(\u03b12) = c1, Q.E.D."}, {"heading": "2 Details on Training Procedure", "text": "We describe here in detail which network architectures we tried and explain the network training procedure."}, {"heading": "2.1 Network Architecture", "text": "We tested various network architectures in combination with our training procedure. They are coded as follows: NcF stands for a convolutional layer with N filters of size F \u00d7 F pixels, Nf stands for a fully connected layer with N neurons. For example, 64c5-64c5-128f denotes a network with two convolutional layers containing 64 filters spanning 5\u00d7 5 pixels each followed by a fully connected layer with 128 neurons. The last specified layer is always succeeded by a softmax layer, which serves as the network output. We applied 2 \u00d7 2 max-pooling to the outputs of the first and second convolutional layers.\nAs stated in the paper we used a 64c5-64c5-128f architecture in our experiments to evaluate the influence of different components of the augmentation procedure (we refer to this architecture as the \u2019small\u2019 network). A large network, coded as 64c5-128c5-256c5-512f, was then used to achieve better classification performance.\nAll considered networks contained rectified linear units in each layer but the softmax layer. Dropout was applied to the fully connected layer."}, {"heading": "2.2 Training the Networks", "text": "We adopted the common practice of training the network with stochastic gradient descent with a fixed momentum of 0.9. We started with a learning rate of 0.01 and gradually decreased the learning rate during training. That is, we trained until there was no improvement in validation error, then decreased the learning rate by a factor of 3, and repeated this procedure until convergence."}, {"heading": "3 Experiments", "text": "We report here two additional experiments studying influence of different aspects of the algorithm on the quality of the learned features. We also give the details on how we measure invariance of feature representations in Section 4.3.4 of the paper."}, {"heading": "3.1 Influence of the Network Architecture on Classification Performance", "text": "We perform an additional experiment to evaluate the influence of the network architecture on classification performance. The results of this experiment are shown in Table 2. All networks were trained using a surrogate training set containing either 8000 classes with 150 samples each or 16000 classes with 100 samples each (for larger networks). We vary the number of layers, layer sizes and filter sizes. Classification accuracy generally improves with the network size indicating that our classification problem scales well to relatively large networks without overfitting."}, {"heading": "3.2 Influence of the Dataset", "text": "We applied our feature learning algorithm to images sampled from three datasets \u2013 STL-10 unlabeled dataset, CIFAR-10 and Caltech-101 \u2013 and evaluated the performance of the learned feature representations on classification tasks on these datasets. We used the \u201csmall\u201d network (64c5-64c5128f) for this experiment.\nWe show first layer filters learned from the three datasets in Fig. 7. Note how filters qualitatively differ depending on the dataset they were trained on.\nClassification results are shown in Table 3. The best classification results for each dataset are obtained when training on the patches extracted from the dataset itself. However, the difference is not drastic, indicating that the learned features generalize well to other datasets."}, {"heading": "3.3 Details of computing the measure of invariance", "text": "We now explain in detail and motivate computation of the normalized Euclidean distance used as a measure of invariance in the paper.\nFirst we compute feature vectors of all image patches and their transformed versions. We next normalize each feature vector to unit Euclidean norm and compute Euclidean distances between each original patch and all of its transformed versions. For each transformation and magnitude we average these distances over all patches. Finally, we divide the resulting curves by their maximal values (typically it is the value for the maximum magnitude of the transformation).\nThe normalizations are performed to compensate for possibly different scales of different features. Normalizing feature vectors to unit length ensures that the values are in the same range for different features. The final normalization of the curves by the maximal value allows to compensate for different variation of different features: as an extreme, a constant feature would be considered perfectly invariant without this normalization, which is certainly not desirable.\nThe resulting curves show how quickly the feature representation changes when an image is transformed more and more. A representation for which the curve steeply goes up and then remains constant cannot be considered invariant to the transformation: the feature vector of the transformed patch becomes completely uncorrelated with the original feature vector even for small magnitudes of the transformation. On the other hand, if the curve grows gradually, this indicates that the feature representation changes slowly when the transformation is applied, meaning invariance or, rather, covariance of the representation."}], "references": [{"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "NIPS, pages 1106\u20131114,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2012}, {"title": "Visualizing and understanding convolutional networks", "author": ["M.D. Zeiler", "R. Fergus"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "Backpropagation applied to handwritten zip code recognition", "author": ["Y. LeCun", "B. Boser", "J.S. Denker", "D. Henderson", "R.E. Howard", "W. Hubbard", "L.D. Jackel"], "venue": "Neural Computation, 1(4):541\u2013551,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1989}, {"title": "Decaf: A deep convolutional activation feature for generic visual recognition", "author": ["J. Donahue", "Y. Jia", "O. Vinyals", "J. Hoffman", "N. Zhang", "E. Tzeng", "T. Darrell"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2013}, {"title": "Rich feature hierarchies for accurate object detection and semantic segmentation", "author": ["R. Girshick", "J. Donahue", "T. Darrell", "J. Malik"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2013}, {"title": "Simple sparsification improves sparse denoising autoencoders in denoising highly corrupted images", "author": ["K. Cho"], "venue": "ICML. JMLR Workshop and Conference Proceedings,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2013}, {"title": "Descriptor matching with convolutional neural networks: a comparison to SIFT", "author": ["P. Fischer", "A. Dosovitskiy", "T. Brox"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2014}, {"title": "Learning convolutional feature hierachies for visual recognition", "author": ["K. Kavukcuoglu", "P. Sermanet", "Y. Boureau", "K. Gregor", "M. Mathieu", "Y. LeCun"], "venue": "NIPS,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "Extracting and composing robust features with denoising autoencoders", "author": ["P. Vincent", "H. Larochelle", "Y. Bengio", "P.-A. Manzagol"], "venue": "ICML, pages 1096\u20131103,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2008}, {"title": "A generative process for contractive auto-encoders", "author": ["S. Rifai", "Y. Dauphin", "P. Vincent", "Y. Bengio"], "venue": "ICML,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Deep learning of invariant features via simulated fixations in video", "author": ["W.Y. Zou", "A.Y. Ng", "S. Zhu", "K. Yu"], "venue": "NIPS, pages 3212\u20133220,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Learning invariant representations with local transformations", "author": ["K. Sohn", "H. Lee"], "venue": "ICML,", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "Direct modeling of complex invariances for visual object features", "author": ["K.Y. Hui"], "venue": "ICML,", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2013}, {"title": "Tangent prop - a formalism for specifying selected invariances in an adaptive network", "author": ["P. Simard", "B. Victorri", "Y. LeCun", "J.S. Denker"], "venue": "NIPS,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 1992}, {"title": "Improving generalization performance using double backpropagation", "author": ["H. Drucker", "Y. LeCun"], "venue": "IEEE Transactions on Neural Networks, 3(6):991\u2013997,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1992}, {"title": "Semi supervised logistic regression", "author": ["M.-R. Amini", "P. Gallinari"], "venue": "ECAI, pages 390\u2013394,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2002}, {"title": "Entropy regularization", "author": ["Y. Grandvalet", "Y. Bengio"], "venue": "Semi-Supervised Learning, pages 151\u2013168.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Training hierarchical feed-forward visual recognition models using transfer learning from pseudo-tasks", "author": ["A. Ahmed", "K. Yu", "W. Xu", "Y. Gong", "E. Xing"], "venue": "ECCV (3), pages 69\u201382,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2008}, {"title": "Natural language processing (almost) from scratch", "author": ["R. Collobert", "J. Weston", "L. Bottou", "M. Karlen", "K. Kavukcuoglu", "P. Kuksa"], "venue": "Journal of Machine Learning Research, 12:2493\u20132537,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Dropout training as adaptive regularization", "author": ["S. Wager", "S. Wang", "P. Liang"], "venue": "NIPS.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2013}, {"title": "The manifold tangent classifier", "author": ["S. Rifai", "Y.N. Dauphin", "P. Vincent", "Y. Bengio", "X. Muller"], "venue": "NIPS.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2011}, {"title": "An analysis of single-layer networks in unsupervised feature learning", "author": ["A. Coates", "H. Lee", "A.Y. Ng"], "venue": "AISTATS,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2011}, {"title": "Learning multiple layers of features from tiny images", "author": ["A. Krizhevsky", "G. Hinton"], "venue": "Master\u2019s thesis, Department of Computer Science, University of Toronto,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2009}, {"title": "Learning Generative Visual Models from Few Training Examples: An Incremental Bayesian Approach Tested on 101 Object Categories", "author": ["L. Fei-Fei", "R. Fergus", "P. Perona"], "venue": "CVPR WGMBV,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2004}, {"title": "Improving neural networks by preventing co-adaptation of feature detectors", "author": ["G.E. Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R.R. Salakhutdinov"], "venue": null, "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2012}, {"title": "Caffe: An open source convolutional architecture for fast feature embedding", "author": ["Y. Jia"], "venue": "http://caffe. berkeleyvision.org/,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2013}, {"title": "Selecting receptive fields in deep networks", "author": ["A. Coates", "A.Y. Ng"], "venue": "NIPS, pages 2528\u20132536,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2011}, {"title": "Unsupervised Feature Learning for RGB-D Based Object Recognition", "author": ["L. Bo", "X. Ren", "D. Fox"], "venue": "ISER, June", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2012}, {"title": "Ask the locals: multi-way local pooling for image recognition", "author": ["Y. Boureau", "N. Le Roux", "F. Bach", "J. Ponce", "Y. LeCun"], "venue": "ICCV\u201911. IEEE,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2011}, {"title": "Multipath sparse coding using hierarchical matching pursuit", "author": ["L. Bo", "X. Ren", "D. Fox"], "venue": "CVPR, pages 660\u2013667,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2013}], "referenceMentions": [{"referenceID": 0, "context": "Convolutional neural networks (CNNs) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories [1, 2].", "startOffset": 192, "endOffset": 198}, {"referenceID": 1, "context": "Convolutional neural networks (CNNs) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories [1, 2].", "startOffset": 192, "endOffset": 198}, {"referenceID": 2, "context": "While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5].", "startOffset": 120, "endOffset": 123}, {"referenceID": 1, "context": "While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5].", "startOffset": 386, "endOffset": 392}, {"referenceID": 3, "context": "While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5].", "startOffset": 386, "endOffset": 392}, {"referenceID": 1, "context": "While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5].", "startOffset": 405, "endOffset": 408}, {"referenceID": 3, "context": "While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5].", "startOffset": 437, "endOffset": 440}, {"referenceID": 3, "context": "While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5].", "startOffset": 477, "endOffset": 480}, {"referenceID": 4, "context": "While CNNs have been known to yield good results on supervised image classification tasks such as MNIST for a long time [3], the feature representation learned by the recent networks achieves stateof-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 4], Caltech256 [2], Caltech-UCSD birds dataset [4], SUN-397 scene recognition database [4]; detection on PASCAL VOC dataset [5].", "startOffset": 514, "endOffset": 517}, {"referenceID": 0, "context": "[1] was only possible due to massive efforts on manually annotating millions of images.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "For example, unsupervised feature learning is known to be beneficial for image restoration [6] and recent results show that it outperforms supervised feature learning also on descriptor matching [7].", "startOffset": 91, "endOffset": 94}, {"referenceID": 6, "context": "For example, unsupervised feature learning is known to be beneficial for image restoration [6] and recent results show that it outperforms supervised feature learning also on descriptor matching [7].", "startOffset": 195, "endOffset": 198}, {"referenceID": 2, "context": "[3], Kavukcuoglu et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8], Krizhevsky et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "[1]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "[1], Zeiler and Fergus [2]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[1], Zeiler and Fergus [2]).", "startOffset": 23, "endOffset": 26}, {"referenceID": 8, "context": "Denoising autoencoders [9], for example, learn features that are robust to noise by trying to reconstruct data from randomly perturbed input samples.", "startOffset": 23, "endOffset": 26}, {"referenceID": 9, "context": "Similarly, contractive autoencoders [10] penalize the sensitivity of the feature representation to small changes in the input.", "startOffset": 36, "endOffset": 40}, {"referenceID": 10, "context": "[11] learn invariant features from video by enforcing a temporal slowness constraint on the feature representation learned by a linear autoencoder.", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "Sohn and Lee [12] and Hui [13] learn features invariant to local image transformations.", "startOffset": 13, "endOffset": 17}, {"referenceID": 12, "context": "Sohn and Lee [12] and Hui [13] learn features invariant to local image transformations.", "startOffset": 26, "endOffset": 30}, {"referenceID": 13, "context": "The research most similar to ours is early work on tangent propagation [14] (and the related double backpropagation [15]) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations.", "startOffset": 71, "endOffset": 75}, {"referenceID": 14, "context": "The research most similar to ours is early work on tangent propagation [14] (and the related double backpropagation [15]) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations.", "startOffset": 116, "endOffset": 120}, {"referenceID": 15, "context": "This work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training [16] or entropy regularization [17].", "startOffset": 129, "endOffset": 133}, {"referenceID": 16, "context": "This work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training [16] or entropy regularization [17].", "startOffset": 160, "endOffset": 164}, {"referenceID": 17, "context": "[18], Collobert et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[19].", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "For each initial patch xi \u2208 X we sample K \u2208 [1, 300] random parameter vectors {\u03b1 i , .", "startOffset": 44, "endOffset": 52}, {"referenceID": 19, "context": "[20]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[21] for a recent discussion).", "startOffset": 0, "endOffset": 4}, {"referenceID": 7, "context": ", by enforcing sparsity [8] or robustness to noise [9].", "startOffset": 24, "endOffset": 27}, {"referenceID": 8, "context": ", by enforcing sparsity [8] or robustness to noise [9].", "startOffset": 51, "endOffset": 54}, {"referenceID": 21, "context": "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [22], CIFAR-10 [23] and Caltech-101 [24] datasets.", "startOffset": 137, "endOffset": 141}, {"referenceID": 22, "context": "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [22], CIFAR-10 [23] and Caltech-101 [24] datasets.", "startOffset": 152, "endOffset": 156}, {"referenceID": 23, "context": "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [22], CIFAR-10 [23] and Caltech-101 [24] datasets.", "startOffset": 173, "endOffset": 177}, {"referenceID": 24, "context": "Dropout [25] was applied to the fully connected layers.", "startOffset": 8, "endOffset": 12}, {"referenceID": 25, "context": "We trained the networks using an implementation based on Caffe [26].", "startOffset": 63, "endOffset": 67}, {"referenceID": 26, "context": "To each feature map, we applied the pooling method that is commonly used on the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure on STL-10 and CIFAR-10 [27, 11, 28, 13]; 2) 3-layer spatial pyramid, i.", "startOffset": 221, "endOffset": 237}, {"referenceID": 10, "context": "To each feature map, we applied the pooling method that is commonly used on the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure on STL-10 and CIFAR-10 [27, 11, 28, 13]; 2) 3-layer spatial pyramid, i.", "startOffset": 221, "endOffset": 237}, {"referenceID": 27, "context": "To each feature map, we applied the pooling method that is commonly used on the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure on STL-10 and CIFAR-10 [27, 11, 28, 13]; 2) 3-layer spatial pyramid, i.", "startOffset": 221, "endOffset": 237}, {"referenceID": 12, "context": "To each feature map, we applied the pooling method that is commonly used on the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure on STL-10 and CIFAR-10 [27, 11, 28, 13]; 2) 3-layer spatial pyramid, i.", "startOffset": 221, "endOffset": 237}, {"referenceID": 28, "context": "max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 \u00d7 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard on Caltech-101 [29, 11, 30].", "startOffset": 191, "endOffset": 203}, {"referenceID": 10, "context": "max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 \u00d7 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard on Caltech-101 [29, 11, 30].", "startOffset": 191, "endOffset": 203}, {"referenceID": 29, "context": "max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 \u00d7 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard on Caltech-101 [29, 11, 30].", "startOffset": 191, "endOffset": 203}, {"referenceID": 26, "context": "Algorithm STL-10 CIFAR-10(400) CIFAR-10 Caltech-101 #features Convolutional K-means Network [27] 60.", "startOffset": 92, "endOffset": 96}, {"referenceID": 28, "context": "0 \u2014 8000 Multi-way local pooling [29] \u2014 \u2014 \u2014 77.", "startOffset": 33, "endOffset": 37}, {"referenceID": 10, "context": "6 1024\u00d7 64 Slowness on videos [11] 61.", "startOffset": 30, "endOffset": 34}, {"referenceID": 27, "context": "6 556 Hierarchical Matching Pursuit (HMP) [28] 64.", "startOffset": 42, "endOffset": 46}, {"referenceID": 29, "context": "5\u00b1 1 \u2014 \u2014 \u2014 1000 Multipath HMP [30] \u2014 \u2014 \u2014 82.", "startOffset": 30, "endOffset": 34}, {"referenceID": 12, "context": "5 5000 View-Invariant K-means [13] 63.", "startOffset": 30, "endOffset": 34}, {"referenceID": 26, "context": "This is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an SVM typically becomes less dependent on the quality of the extracted features [27, 13].", "startOffset": 216, "endOffset": 224}, {"referenceID": 12, "context": "This is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an SVM typically becomes less dependent on the quality of the extracted features [27, 13].", "startOffset": 216, "endOffset": 224}, {"referenceID": 10, "context": "First, as an explicit measure of invariance, we calculated the normalized Euclidean distance between normalized feature vectors of the original image patch and the transformed one [11] (see the supplementary material for details).", "startOffset": 180, "endOffset": 184}], "year": 2014, "abstractText": "Current methods for training convolutional neural networks depend on large amounts of labeled samples for supervised training. In this paper we present an approach for training a convolutional neural network using only unlabeled data. We train the network to discriminate between a set of surrogate classes. Each surrogate class is formed by applying a variety of transformations to a randomly sampled \u2019seed\u2019 image patch. We find that this simple feature learning algorithm is surprisingly successful when applied to visual object recognition. The feature representation learned by our algorithm achieves classification results matching or outperforming the current state-of-the-art for unsupervised learning on several popular datasets (STL-10, CIFAR-10, Caltech-101).", "creator": "LaTeX with hyperref package"}}}