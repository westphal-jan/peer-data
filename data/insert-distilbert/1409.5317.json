{"id": "1409.5317", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "18-Sep-2014", "title": "A Bayesian model for recognizing handwritten mathematical expressions", "abstract": "recognizing handwritten mathematics is a challenging classification problem, requiring simultaneous identification mapping of all the symbols comprising an input as well as the complex two - dimensional relationships between symbols and subexpressions. because of the ambiguity present in handwritten algorithm input, it is often unrealistic how to hope searching for consistently perfect recognition accuracy. we present a system which captures all recognizable interpretations of the input and organizes them in a parse forest from which individual parse trees may be extracted and otherwise reported. if the top - ranked interpretation is incorrect, the user may request alternates and select the recognition result they desire. the tree extraction step uses a novel probabilistic tree scoring strategy in which a bayesian network is individually constructed based on calculating the structure of the input, and each joint variable assignment corresponds to a different parse tree. parse trees are then reported in certain order of decreasing probability. two accuracy evaluations demonstrate that the resulting recognition alignment system is comparatively more accurate than previous versions ( which used non - probabilistic methods ) and other academic math recognizers.", "histories": [["v1", "Thu, 18 Sep 2014 14:45:24 GMT  (141kb,D)", "http://arxiv.org/abs/1409.5317v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["scott maclean", "george labahn"], "accepted": false, "id": "1409.5317"}, "pdf": {"name": "1409.5317.pdf", "metadata": {"source": "CRF", "title": "A Bayesian model for recognizing handwritten mathematical expressions", "authors": ["Scott MacLean", "George Labahn"], "emails": ["smaclean@uwaterloo.ca", "glabahn@uwaterloo.ca"], "sections": [{"heading": "1 Introduction", "text": "Many software packages exist which operate on mathematical expressions. Such software is generally produced for one of two purposes: either to create two-dimensional renderings of mathematical expressions for printing or on-screen display (e.g., LATEX, MathML), or to perform mathematical operations on the expressions (e.g., Maple, Mathematica, Sage, and various numeric and symbolic calculators). In both cases, the mathematical expressions themselves must be entered by the user in a linearized, textual format specific to each software package.\nThis method of inputting math expressions is unsatisfactory for two main reasons. First, it requires users to learn a different syntax for each software package they use. Second, the linearized text formats obscure the two-dimensional structure that is present in the typical way users draw math expressions on paper. This is demonstrated with some absurdity by software designed to render math expressions, for which one must linearize a two-dimensional expression and input it as a text string, only to have the software re-create and display the expression\u2019s original two-dimensional structure.\nMathematical software is typically used as a means to accomplish a particular goal that the user has in mind, whether it is creating a web site with mathematical content, calculating a sum, or integrating a complex expression. The requirement to input math expressions in a unique, unnatural format is therefore an obstacle that must be overcome, not something learned for its own sake. As such, it is desirable for users to input mathematics by drawing expressions in two dimensions as they do with pen and paper.\nar X\niv :1\n40 9.\n53 17\nv1 [\ncs .A\nI] 1\n8 Se\nAcademic interest in the problem of recognizing hand-drawn math expressions originated with Anderson\u2019s doctoral research in the late 1960\u2019s [2]. Interest has waxed and waned in the intervening decades, and recent years have witnessed renewed attention to the topic, potentially spurred on by the nascent Competition on Recognition of Handwritten Mathematical Expressions (CROHME) [11, 12].\nHowever, math expressions have proved difficult to recognize effectively. Even the best state of the art systems (as measured by CROHME) are not sufficiently accurate for everyday use by nonspecialists. The recognition problem is complex as it requires not only symbols to be recognized, but also arrangements of symbols, and the semantic content that those arrangements represent. Matters are further complicated by the large symbol set and the ambiguous nature of both handwritten input and mathematical syntax."}, {"heading": "1.1 MathBrush", "text": "Our work is done in the context of the MathBrush pen-based math system [5]. Using MathBrush, one draws an expression, which is recognized incrementally as it is drawn (Fig. 1a). At any point, the user may correct erroneous recognition results by selecting part or all of the expression and choosing an alternative recognition from a drop-down list (Fig. 1b). Once the expression is completely recognized, it is embedded into a worksheet interface through which the user may manipulate and work with the expression via computer algebra system commands (Fig. 1c).\nFor our purposes, the crucial element of this description is that the user may at any point request alternative interpretations of any portion of their input. This behaviour differs from that of most other recognition systems, which present the user with a single, potentially incorrect result. We instead acknowledge the fact that recognition will not be perfect all of the time, and endeavour to make the correction process as fast and simple as possible. Much of our work is motivated by the necessity of maintaining multiple interpretations of the input so that lists of alternative recognition results can be populated if the need arises.\nWe have previously reported techniques for capturing and reporting these multiple interpretations [9], and some of those ideas remain the foundation of the work presented in this paper. In particular, the two-dimensional syntax of mathematics is organized and understood through the formalism of relational context-free grammars (RCFGs), a multi-dimensional generalization of traditional contextfree grammars. It is necessary to place restrictions on the structure of the input so that parsing with RCFGs takes a reasonable amount of time, but once this is done it is fairly straightforward to adapt existing parsing algorithms to RCFGs so that they produce a data structure called a parse forest which simultaneously represents all recognizable interpretations of an input. The parse forest is the primary tool we use to organize alternative recognition results in case the user desires to see them. When it does become necessary to populate drop-down lists in MathBrush with recognition results, individual parse trees \u2013 each representing a different interpretation of the input \u2013 must be extracted from the parse forest. As with parsing, some restrictions are necessary in this step to achieve reasonable performance.\nOur previous work formalized the notion of ambiguity in terms of fuzzy sets and represented portions of the input as fuzzy sets of math expressions. In this paper, we abandon the language of fuzzy sets, develop a more general notion of how recognition processes interact with the grammar model, and introduce a Bayesian scoring model for parse trees. The scoring model incorporates results from recognition systems as well as \u201ccommon-sense\u201d knowledge drawn from training corpora. The recognition systems contributing to the model include a novel stroke grouping system, a combination symbol classifier based on quantile-mapped distance functions, and a naive Bayesian relation classifier. An algebraic technique eliminates many model variables from tree probability calculations, yielding an efficiently computable probability function. The resulting recognition system is significantly more accurate than other academic math recognizers, including the fuzzy variant we used previously.\nThe rest of this paper is organized as follows. Section 2 summarizes some recent probabilistic approaches to the math recognition problem and points out some of the issues that arise in practice when applying standard probabilistic models to this problem. Section 3 summarizes the theory and algorithms behind our RCFG variant, describing how to construct and extract trees from a parse\nforest for a given input. This section also states the restrictions and assumptions we use to attain reasonable recognition speeds. Section 4 is devoted to the new probabilistic tree scoring function we have devised for MathBrush, based on constructing a Bayesian network for a given input. Finally, Section 5 replicates the 2011 and 2012 CROHME accuracy evaluations, demonstrating the effectiveness of the probabilistic scoring framework, and Section 6 concludes the paper with a summary and some promising directions for future research."}, {"heading": "2 Existing research", "text": "There is a significant and expanding literature concerning the math recognition problem. Many recent systems and approaches are summarized in the CROHME reports [11, 12]. We will comment directly on a few recent approaches using probabilistic methods."}, {"heading": "2.1 Alvaro et al", "text": "The system developed by Alvaro et al [1] placed first in the CROHME 2011 recognition contest [11]. It is based on earlier work of Yamamoto et al [18]. A grammar models the formal structure of math expressions. Symbols and the relations between them are modeled stochastically using manuallydefined probability functions. The symbol recognition probabilities are used to seed a parsing table on which a CYK-style parsing algorithm proceeds to obtain an expression tree representing the entire input.\nIn this scheme, writing is considered to be a generative stochastic process governed by the grammar rules and probability distributions. That is, one stochastically generates a bounding box for the entire expression, chooses a grammar rule to apply, and stochastically generates bounding boxes for each of the rule\u2019s RHS elements according to the relation distribution. This process continues recursively until a grammar rule producing a terminal symbol is selected, at which point a stroke (or, more properly, a collection of stroke features) is stochastically generated.\nGiven a particular set of input strokes, Alvaro et al find the sequence of stochastic choices most likely to have generated the input. However, stochastic grammars are known to biased toward short parse trees (those containing few derivation steps) [10]. In our own experiments with such approaches, we encountered difficulties in particular with recognizing multi-stroke symbols in the context of full expressions. The model has no intrinsic notion of symbol segmentation, and the bias toward short parse trees caused the recognizer to consistently report symbols with many strokes even when they had poor recognition scores. Yet to introduce symbol segmentation scores in a straightforward way causes probability distributions to no longer sum to one. Alvaro et al allude to similar difficulties when they mention that their symbol recognition probabilities had to be rescaled to account for multi-stroke symbols.\nIn Section 4, we propose a different solution. We abandon the generative model in favour of one that explicitly reflects the stroke-based nature of the input, and furthermore include a nil value to account for groups of strokes that are not, in fact, symbols."}, {"heading": "2.2 Awal et al", "text": "While the system described by Awal et al [3] was included in the CROHME 2011 contest, its developers were directly associated with the contest and were thus not official participants. However, their system scored higher than the winning system of Alvaro et al, so it is worthwhile to examine its construction.\nA dynamic programming algorithm first proposes likely groupings of strokes into symbols, although it is not clear what cost function the dynamic program is minimizing. Each of the symbol groups is recognized using neural networks whose outputs are converted into a probability distribution over symbol classes.\nMath expression structure is modeled by a context-free grammar in which each rule is linear in either the horizontal of vertical direction. Spatial relationships between symbols and subexpressions are\nmodeled as two independent Gaussians on position and size difference between subexpression bounding boxes. These probabilities along with those from symbol recognition are treated as independent variables, and the parse tree minimizing a cost function defined in terms of weighted negative log likelihoods is reported as the final parse.\nThis method as a whole is not probabilistic as the variables are not combined in a coherent model. Instead, probability distributions are used as components of a scoring function. This pattern is common in the math recognition literature: distribution functions are used when they are useful, but the overall strategy remains ad hoc. Vestiges of this may be seen in our own work throughout Section 4; however in this paper we take the next step and re-combine scoring functions into a coherent probabilistic model."}, {"heading": "2.3 Shi, Li, and Soong", "text": "Working with Microsoft Research Asia, Shi, Li, and Soong proposed a unified HMM-based method for recognizing math expressions [14]. Treating the input strokes as a temporally-ordered sequence, they use dynamic programming to determine the most likely points at which to split the sequence into distinct symbol groups, the most likely symbols each of those groups represent, and the most likely spatial relation between temporally-adjacent symbols. Some local context is taken into account by treating symbol and relation sequences as Markov chains. This process results in a DAG, which may be easily converted to an expression tree.\nTo compute symbol likelihoods, a grid-based method measuring point density and stroke direction is used to obtain a feature vector. These vectors are assumed to be generated by a mixture of Gaussians with one component for each known symbol type. Relation likelihoods are also treated as Gaussian mixtures of extracted bounding-box features. Group likelihoods are computed by manually-defined probability functions.\nThis approach is elegant in its unity of symbol, relation, and expression recognition. The reduction of the input to a linear sequence of strokes dramatically simplifies the parsing problem. But this assumption of linearity comes at the expense of generality. The HMM structure strictly requires strokes to be drawn in a pre-determined linear sequence. That is, the model accounts for ambiguity in symbol and relation identities, but not for the two-dimensional structure of mathematics. As such, the method is unsuitable for applications such as MathBrush, in which the user may draw, erase, move, or otherwise edit any part of their input at any time."}, {"heading": "3 Relational grammars and parsing", "text": "Relational grammars are the primary means by which the MathBrush recognizer associates mathematical semantics with portions of the input. We previously described a fuzzy relational grammar formalism which explicitly modeled recognition as a process by which an observed, ambiguous input is interpreted as a certain, structured expression [9]. In this work, we define the grammar slightly more abstractly so that it has no intrinsic tie to fuzzy sets and may be used with a variety of scoring functions. Interested readers are referred to [9] and [7] for more details."}, {"heading": "3.1 Grammar definition and terminology", "text": "Relational context-free grammars are defined as follows.\nDefinition 1. A relational context-free grammar G is a tuple (\u03a3, N, S,O,R, P ), where\n\u2022 \u03a3 is a set of terminal symbols,\n\u2022 N is a set of non-terminal symbols,\n\u2022 S \u2208 N is the start symbol,\n\u2022 O is a set of observables,\n\u2022 R is a set of relations on I, the set of interpretations of G (described below),\n\u2022 P is a set of productions, each of the form A0 r\u21d2 A1A2 \u00b7 \u00b7 \u00b7Ak, where A0 \u2208 N, r \u2208 R, and\nA1, . . . , Ak \u2208 N \u222a \u03a3,\nThe basic elements of a CFG are present in this definition as \u03a3, N, S, and P , though the form of an RCFG production is slightly more complex than that of a CFG production. However, there are several less familiar components as well."}, {"heading": "3.1.1 Observables, Expressions and interpretations", "text": "The set O of observables is the set of all possible inputs \u2013 in our case each observable is a set of ink strokes, and each ink stroke is an ordered sequence of points in R2.\nAn expression is the generalization of a string to the RCFG case. The form of an expression reflects the relational form of the grammar productions. Any terminal symbol \u03b1 \u2208 \u03a3 is a terminal expression. An expression e may also be formed by concatenating several expressions e1, . . . , ek by a relation r \u2208 R. Such an r-concatenation is written e1r \u00b7 \u00b7 \u00b7 rek.\nThe representable set of G, written L(G), is the set of all expressions formally derivable using the nonterminal, terminals, and productions of a grammar G. L(G) generalizes the notion of the language generated by a grammar to RCFGs.\nAn interpretation, then, is a pair (e, o), where e \u2208 L(G) is a representable expression and o is an observable.This definition links the formal structure of the grammar with the geometric structure of the input \u2013 an interpretation is essentially a parse of o where the structure of e encodes the hierarchical structure of the parse. The set of interpretations I referenced in the RCFG definition is just the set of all possible interpretations:\nI = {(e, o) : e \u2208 L(G), o \u2208 O} . In our previous work with fuzzy sets, the set of interpretations was fuzzy. This required a scoring model to be embedded into the grammar\u2019s structure and added otherwise unnecessary components to the grammar definition. The present formalism is slightly more abstract. It loses no expressive power but leaves scoring models and data organization as implementation details, rather than as fundamental grammar components."}, {"heading": "3.1.2 Relations and productions", "text": "The relations in R model the spatial relationships between subexpressions. In mathematics, these relationships often determine the semantic interpretation of an expression (e.g., a and x written sideby-side as ax means something quite different from the diagonal arrangement ax). An important feature of these grammar relations is that they act on interpretations \u2013 pairs of expressions and observables. This enables relation classifiers to use knowledge about how particular expressions or symbols fit together when interpreting geometric features of observables. By doing so, an expression like the one shown in Figure 2 may be interpreted as either P x+a or px+ a depending on the identity of its symbols.\nWe use five relations, denoted \u2192 ,\u2197 ,\u2198 , \u2193 , . The four arrows indicate the general writing direction between two subexpressions, and indicates containment notation, as used in square roots.\nThe productions in P are similar to context-free grammar productions. The relation r appearing above the production symbol (\nr\u21d2) indicates that r must be satisfied by adjacent elements of the RHS. Formally, given a production A0\nr\u21d2 A1A2 \u00b7 \u00b7 \u00b7Ak, if oi (i = 1, . . . , k) denotes an observable interpretable as an expression ei, and each ei is itself derivable from a nonterminal Ai, then for the observable o1\u222a\u00b7 \u00b7 \u00b7\u222aok to be interpretable as the r-concatenation e1r \u00b7 \u00b7 \u00b7 rek requires that ((ei, oi) , (ei+1, oi+1)) \u2208 r for i = 1, . . . , k\u22121. That is, all adjacent pairs of sub-interpretations must satisfy the grammar relation for them to be combinable into a larger interpretation.\nIn this example, the production for [ADD] models the syntax for infix addition: two expressions joined by the addition symbol, written from left to right. The production for [FRAC] has a similar structure \u2013 two expressions joined by the fraction bar symbol \u2013 but specifies that its components should be organized from top to bottom using the \u2193 relation. The production for [MULT] illustrates the ease with which different relations and writing directions may be combined together to form larger expressions. The [LEAD-TERM] term may be a superscript (using the \u2197 relation), a fraction (using the \u2193 relation), or a symbol, but no matter which of those subexpressions appears as the leading term, it must satisfy the left-to-right relation \u2192 when combined with the training term."}, {"heading": "3.2 Parsing with Unger\u2019s method", "text": "Compared with traditional CFGs, there are two main sources of ambiguity and difficulty when parsing RCFGs: the symbols in the input are unknown, both in the sense of what parts of the input constitute a symbol, and what the identity of each symbol is; and because the input is two-dimensional, there is no straightforward linear order in which to traverse the input strokes. Additionally, there may be ambiguity arising from relation classification uncertainty: we may not know for certain which grammar relation links two subexpressions together.\nWe manage and organize these sources of uncertainty by using a data structure called a parse forest to simultaneously represent all recognizable parses of the input. A parse forest is a graphical structure in which each node represents all of the parses of a particular subset of the input using a particular grammar nonterminal or production. There are two types of nodes:\n1. OR nodes. Each of an OR node\u2019s parse trees is taken directly from one of the node\u2019s children. There are two types of OR nodes:\n(a) Nonterminal nodes of the form (A, o), representing the parses of a nonterminal A on a subset\no of the input. The parse tree of A on o is just the parse tree of some production with LHS A on o.\n(b) Production nodes of the form (p, o), representing the parses of a production p of the form\nA0 r\u21d2 A1 \u00b7 \u00b7 \u00b7Ak on a subset o of the input. Each such parse tree arises by parsing p on some partition of o into k subsets.\n2. AND nodes. Each of an AND node\u2019s parse trees is an r-concatenation to which each of the node\u2019s children contributes one subexpression. AND nodes have the form (p; (o1, . . . , ok)), representing the parses of a production p of the form above on a partition o1, . . . , ok of some subset o1\u222a\u00b7 \u00b7 \u00b7\u222aok of the input. Each subexpression ei is itself a parse of Ai on the partition subset oi.\nParsing an RCFG may be divided into two steps: forest construction, in which a shared parse forest is created that represents all recognizable parses of the input, and tree extraction, in which individual parse trees are extracted from the forest in decreasing order of tree score."}, {"heading": "3.2.1 Restricting feasible partitions", "text": "To obtain reasonable performance when parsing with RCFGs, it is necessary to restrict the ways in which input observables may be partitioned and recombined (otherwise, partitions of the input using all 2n subsets would need to be considered). We choose to restrict partitions to horizontal and vertical concatenations, as follows.\nEach of the five grammar relations is associated with either the x direction of y direction (\u2192 ,\u2197 , with x, \u2198 , \u2193 with y). Then when parsing an observable o using a production A0\nr\u21d2 A1 \u00b7 \u00b7 \u00b7Ak, o is partitioned by either horizontal or vertical cuts based on the directionality of the relation r. For example, when parsing the production [ADD]\n\u2192\u21d2 [TERM] + [EXPR] on the input from Figure 2, we would note that the relation \u2192 requires horizontal concatenations, and so split the input into three horizontally-concatenated subsets using two vertical cuts. In general, there are ( n k\u22121 )\nways to partition n input strokes into k concatenated subsets.\nThe restriction to horizontal and vertical concatenations is quite severe, but it reduces the worstcase number of subsets of the input which may need to be considered during parsing from 2n to O(n4). Furthermore, the restriction effectively linearizes the input in either the x or y dimension, depending on which grammar relation is being considered. This linearity is sufficiently similar to the implicit linearity of traditional CFG parsing that one may adapt CFG parsing algorithms to the relational grammar case without much difficulty."}, {"heading": "3.2.2 Unger\u2019s method", "text": "Unger\u2019s method is a fairly brute-force algorithm for parsing CFGs [17]. It is easily extended to become a tabular RCFG parser as follows.\nFirst, the grammar is re-written so that each production is either terminal (of the form A0 \u21d2 \u03b1, where \u03b1 \u2208 \u03a3), or nonterminal (of the form A0\nr\u21d2 A1 \u00b7 \u00b7 \u00b7Ak, where each Ai \u2208 N), so there is no mixing of terminal and non-terminal symbols within productions. Then our variant of Unger\u2019s method constructs a parse forest by recursively applying the following rules, where p is a production and o is an input observable:\n1. If p is a terminal production, A0 \u21d2 \u03b1, then check if o is recognizable as \u03b1 according to a symbol recognizer. If it is, then add the interpretation (o, \u03b1) to table entry (o, \u03b1); otherwise parsing fails.\n2. Otherwise, p is of the form A0 r\u21d2 A1 \u00b7 \u00b7 \u00b7Ak. For every relevant partition o into subsets o1, . . . , ok\n(either a horizontal or vertical concatenation, as appropriate), parse each nonterminal Ai on oi. If all of the sub-parses succeed, then add (p; (o1, . . . , ok)) to table entry (o,A0).\nNaively, O(|o|k\u22121) partitions must be considered in step 2. But since Unger\u2019s method explicitly enumerates these partitions, we may easily optimize the algorithm by restricting which partitions are\nexplored, thereby avoiding the recursive part of step 2 when possible. In bottom-up algorithms like CYK or Earley\u2019s method, such optimizations are not possible (or are at least much more difficult to implement) because the subdivision of the input into subexpressions is determined implicitly from the bottom up.\nThe output of this variant of Unger\u2019s method is a parse forest containing every parse of the input which could be recognized. The next step is to extract individual parse trees from the parse forest in decreasing score order. The first, highest-scoring tree is presented to the user as they are writing (see Figure 1a). If the user selects a portion of the expression and requests alternative recognition results, then further parse trees are extracted and displayed in the drop-down lists."}, {"heading": "3.3 Parse tree extraction", "text": "To find a parse tree of the entire input observable o, we need only start at the root node (S, o) of the parse forest (S being the grammar\u2019s start symbol) and, whenever we are at an OR node, follow the link to one of the node\u2019s children. Whenever we are at an AND node, follow the links to all of the node\u2019s children simultaneously. Once all branches of such a path reach terminal expressions, we have found a parse tree. Moreover, any combination of choices at OR nodes that yields such a branching path gives a valid parse tree.\nThe problem, then, is how to enumerate those paths in such a way that the most reasonable parse is found first, then the next most reasonable, and so on. Our approach is to equip each of the nodes in the parse forest with a priority queue ordered by parse tree score. Tree extraction is then treated as an iteration problem. Initially, we insert the highest-scoring parse tree of a node into the node\u2019s priority queue. Then, whenever a tree is required from that node, it is obtained by popping the highest-scoring tree from the queue. The queue is then prepared for subsequent iteration by pushing in some more trees in such a way that the next-highest-scoring tree is guaranteed to be present.\nMore specifically, to find the highest-scoring tree at an OR node N , we recursively find the highestscoring trees at all of the node\u2019s children and add them to the queue. Then the highest-scoring tree at N is just the highest-scoring tree out of those options. When a tree is popped from the priority queue, it was obtained from a child node of N (call it C) as, say, the ith highest-scoring tree at C. To prepare for the next iteration step, we obtain the i + 1st highest-scoring tree at C and add that into the priority queue of N .\nTo find the highest-scoring tree at an AND node N representing parses of A0 r\u21d2 A1 \u00b7 \u00b7 \u00b7Ak on a partition o1, . . . , ok, we again recursively find the highest-scoring parses of the node\u2019s children \u2013 in this case the OR nodes (A1, o1), . . . , (Ak, ok). Calling these expressions e1, . . . , ek, the r-concatenation e1r \u00b7 \u00b7 \u00b7 rek is the highest-scoring tree at N . Now, any r-concatenation obtained from the k child nodes of N can be represented by a k-tuple (n1, . . . , nk), where each ni indicates the rank of ei in the iteration over trees from node (Ai, oi). (The first, highest-scoring tree has rank 1, the secondhighest-scoring tree has rank 2, etc.) The first tree is therefore represented by the tuple (1, 1, . . . , 1). Whenever we report a tree from node N , we prepare for the next iteration step by examining the tuple (n1, . . . , nk) corresponding to the tree just reported, creating k parse trees corresponding to the tuples (n1 + 1, n2, . . . , nk), (n1, n2 + 1, . . . , nk), . . . , (n1, . . . , nk\u22121, nk + 1) by requesting the relevant subexpression trees from the child nodes of N , and pushing those k trees into the priority queue of N .\nThese procedures for obtaining the best and next-best parse trees at OR- and AND-nodes are similar to those we described previously [9]. In that description, we required the implementation of the grammar relations to satisfy certain properties in order for the tree exraction algorithms to succeed. Here, similarly to the grammar definition, we reformulate our assumptions more abstractly to promote independence between theory and implementation.\nThe tree extraction algorithm is guaranteed to enumerate parse trees in strictly decreasing order of any parse-tree scoring function sc(e, o) (for e an expression and o an observable) that satisfies the following assumptions. In the assumptions, S(\u03b1, o) is a symbol recognition score for recognizing the observable o as the terminal symbol \u03b1, G(o) is a stroke grouping score indicating the extent to which an observable o is considered to be a symbol, and Rr((e1, o1), (e2, o2)) is a relation score indicating the\nextent to which the grammar relation r is satisfied between the interpretations (e1, o1) and (e2, o2). Larger values of these scoring functions indicate higher recognition confidence.\n1. The score of a terminal interpretation (\u03b1, t) is some function g of the symbol and grouping scores,\nsc(\u03b1, t) = g(S(\u03b1, t), G(t)),\nand g increases monotonically with S(\u03b1, o).\n2. The score of a nonterminal interpretation (e, t) = (e1r \u00b7 \u00b7 \u00b7 rek, (t1, . . . , tk)) is some function fk of the sub-interpretation scores and the relation scores between adjacent sub-interpretations,\nsc(e, t) = fk( sc(e1, t1), . . . , sc(ek, tk),\nRr((e1, t1), (e2, t2)), . . . , Rr((ek\u22121, tk\u22121), (ek, tk))).\nand fk increases monotonically with all of its parameters.\nThese assumptions admit a number of reasonable underlying scoring and combination functions. The next section will develop concrete scoring functions based on Bayesian probability theory and some underlying low-level classification techniques."}, {"heading": "4 A Bayesian scoring function", "text": "At a high level, the scoring function sc(e, o) of an interpretation of some subset o of the entire input o\u0302 is organized as a Bayesian network which is constructed specifically for o\u0302."}, {"heading": "4.1 Model organization", "text": "Given an input observable o\u0302, the Bayesian scoring model includes several families of variables:\n\u2022 An expression variable Eo \u2208 L(G) \u222a {nil} for each o \u2286 o\u0302, distributed over representable expressions. Eo = nil indicates that the subset o has no meaningful interpretation.\n\u2022 A symbol variable So \u2208 \u03a3 \u222a {nil} for each o \u2286 o\u0302 indicating what terminal symbol o represents. So = nil indicates that o is not a symbol. (o could be a larger subexpression, or could have Eo = nil as well.)\n\u2022 A relation variable Ro1,o2 \u2208 R \u222a {nil} indicating which grammar relation joins the subsets o1, o2 \u2282 o\u0302. Ro1,o2 = nil indicates that the subsets are not directly connected by a relation.\n\u2022 A vector of grouping-oriented features go for each o \u2286 o\u0302.\n\u2022 A vector of symbol-oriented features so for each o \u2286 o\u0302.\n\u2022 A vector of relation-oriented features fo for each o \u2282 o\u0302.\n\u2022 A \u201csymbol-bag\u201d variable Bo distributed over \u03a3 \u222a {nil} for each o \u2286 o\u0302.\nAt any point in the parse tree extraction algorithm, a particular interpretation (e, o) of a subset of the input is under consideration and must be scored. Each such interpretation corresponds to a joint assignment to all of these variables, so our task is to define the joint probability function\nP \u2227 o\u2286o\u0302 Eo, \u2227 o\u2286o\u0302 So, \u2227 o1,o2\u2282o\u0302 Ro1,o2 , \u2227 o\u2286o\u0302 go, \u2227 o\u2286o\u0302 so, \u2227 o\u2282o\u0302 fo, \u2227 o\u2286o\u0302 Bo  .\nin such a way that it may be calculated quickly. The fact that joint variable assignments arise from parse trees imposes severe constraints on which variables can simultaneously be assigned non-nil values. For example, if Eo = nil, then So = nil, and any Ro,\u2217 or R\u2217,o is also nil. Also, Eo is a terminal expression iff So 6= nil. In general, only those variables representing meaningful subexpressions in the parse tree \u2013 or relationships between those subexpression \u2013 will be non-nil. In all valid assignments, Bo = So for all o; however the distribution of So reflects recognition, while that of Bo reflects prior domain knowledge.\nWe take advantage of these constraints to achieve efficient calculation of the joint probability. First, we factor the joint distribution as a Bayesian network,\nP \u2227 o\u2286o\u0302 Eo, \u2227 o\u2286o\u0302 So, \u2227 o1,o2\u2282o\u0302 Ro1,o2 , \u2227 o\u2286o\u0302 go, \u2227 o\u2286o\u0302 so, \u2227 o\u2282o\u0302 fo, \u2227 o\u2282o\u0302 Bo  = \u220f o\u2032\u2282o\u0302 P Eo\u2032 | \u2227 o\u2282o\u2032 Eo, \u2227 o\u2286o\u2032 So, \u2227 o1,o2\u2282o\u2032 Ro1,o2 , \u2227 o\u2286o\u2032 go, \u2227 o\u2286o\u2032 so, \u2227 o\u2282o\u2032 fo\n \u00d7 \u220f o\u2286o\u0302 P (So | go, so)\n\u00d7 \u220f\no1,o2\u2282o\u0302\nP (Ro1,o2 | Eo1 , Eo2 , fo1 , fo2)\n\u00d7 \u220f o\u2032\u2286o\u0302 P Bo\u2032 | \u2227 o\u2286o\u0302 So  \u00d7 \u220f o\u2286o\u0302 go \u220f o\u2286o\u0302 so \u220f o\u2282o\u0302 fo.\nBecause of the number of variables, it is not feasible to compute this product directly. Instead, we remove the feature variables as they are functions only of the input, and factor out the product\nZ = \u220f o\u2286o\u0302 P (So = nil | go, so)\u00d7 \u220f o1,o2\u2282o\u0302 P (Ro1,o2 = nil | Eo1 , Eo2 , fo1 , fo2) .\nThis division leaves\nP \u2227 o\u2286o\u0302 Eo, \u2227 o\u2286o\u0302 So, \u2227 o1,o2\u2282o\u0302 Ro1,o2 , \u2227 o\u2286o\u0302 go, \u2227 o\u2286o\u0302 so, \u2227 o\u2282o\u0302 fo, \u2227 o\u2208O\u0302 Bo  \u221d\n\u220f o\u2032\u2282o\u0302,Eo\u2032 6=nil P Eo\u2032 | \u2227 o\u2282o\u2032 Eo, \u2227 o\u2286o\u2032 So, \u2227 o1,o2\u2282o\u2032 Ro1,o2 , \u2227 o\u2286o\u2032 go, \u2227 o\u2286o\u2032 so, \u2227 o\u2282o\u2032 fo  \u00d7\n\u220f o\u2286o\u0302,So 6=nil P (So | go, so) P (So = nil | go, so)\n\u00d7 \u220f\no1,o2\u2282o\u0302,Ro1,o2 6=nil\nP (Ro1,o2 | Eo1 , Eo2 , fo1 , fo2) P (Ro1,o2 = nil | Eo1 , Eo2 , fo1 , fo2)\n\u00d7 \u220f o\u2032\u2282o\u0302 P Bo\u2032 | \u2227 o\u2286o\u0302 So\u2032  . Suppose our entire input observable contains n strokes. Since the joint assignment to these variables originates with an interpretation \u2013 an expression e along with an observable o \u2013 at most n symbol\nvariables may be non-nil. An expression variable Eo is only non-nil when o is a subset of the input corresponding to a subexpression of e. A relation variable Ro1,o2 is only non-nil when both Eo1 and Eo2 are non-nil and correspond to adjacent subexpressions of e. There are thus O(n) non-nil variables in any joint assignment, so the adjusted product may be calculated quickly. The RHS of the above expression is the scoring function used during parse tree extraction.\nTo meaningfully compare the scores of different parse trees, the constant of proportionality in this expression must be equal across all parse trees. Thus, the probabilities P (So = nil | go, so) and P (Ro1,o2 = nil | Eo1 , Eo2 , fo1 , fo2) must be functions only of the input. To achieve this in practice, we fix Eo1 = Eo2 = gen when computing P (Ro1,o2 = nil | Eo1 , Eo2 , fo1 , fo2).\nDividing out Z leaves four families of probability distributions which must be defined. We will consider each of them in turn."}, {"heading": "4.2 Expression variables", "text": "The distribution of expression variables, Eo\u2032 | \u2227 o\u2282o\u2032 Eo, \u2227 o\u2286o\u2032 So, \u2227 o1,o2\u2282o\u2032 Ro1,o2 , \u2227 o\u2286o\u2032 go, \u2227 o\u2286o\u2032 so, \u2227 o\u2282o\u2032 fo,\nis deterministic. In a valid joint assignment (i.e., one derived from a parse tree), each non-nil conditional expression variable Eo is a subexpression of Eo\u2032 , and the non-nil relation variables indicate how these subexpressions are joined together. This information completely determines what expression Eo\u2032 must be, so that expression is assigned probability 1."}, {"heading": "4.3 Symbol variables", "text": "The distribution of symbol variables, So | go, so, is based on the stroke grouping score G(o) and the symbol recognition scores S(\u03b1, o) (These scores are described below.)\nThe nil probability of So is allocated as\nP (So = nil | go, so) = 1\u2212 N\nN + 1 ,\nwhere N = log(1 + G(o) max\u03b1{S(\u03b1, o)}), and the remaining probability mass is distributed proportionally to S(o, \u03b1):\nP (So = \u03b1 | go, so) \u221d S(\u03b1, o)\u2211 \u03b2\u2208\u03a3 S(\u03b2, o) ."}, {"heading": "4.3.1 Stroke grouping score", "text": "The stroke grouping function G(o) is based on intuitions about what characteristics of a group of strokes indicate that the strokes belong to the same symbol. These intuitions may be summarized by the following logical predicate using the variables defined in Table 1:\nG = (Din \u2228 (Lin \u2227 \u00acCin)) \u2227 (\u00acLout \u2228 Cout) .\nUsing DeMorgan\u2019s law, this predicate may be re-written as\nG = \u00ac (\u00acDin \u2227 \u00ac (Lin \u2227 \u00acCin)) \u2227 \u00ac (Lout \u2227 \u00acCout) = \u00ac (\u00acDin \u2227 \u00acXin) \u2227 \u00acXout,\nwhere X\u2217 = L\u2217 \u2227 \u00acC\u2217. To make this approach quantitative, we measure several aspects of o, one for each of the RHS variables defined above:\n\u2022 d = min {dist(s\u2032, s) : s\u2032 \u2208 g}, where dist(s1, s2) is the minimal distance between the curves traced by s1 and s2;\n\u2022 `in = overlap(g, s), where overlap(g, s) is the area of the intersection of the bounding boxes of g and s divided by the area of the smaller of the two boxes;\n\u2022 cin = max (C(s),max {C (s\u2032) : s\u2032 \u2208 g}), where C (s) is the extent to which the stroke s resembles a containment notation, as described below;\n\u2022 `out = max {overlap(g \u222a {s}, s\u2032) : s\u2032 \u2208 S \\ (g \u222a {s})};\n\u2022 cout = max (cin, C (s\u2032)), where s\u2032 is the maximizer for `out.\nTogether, these five measurements form the grouping-oriented feature vector go. The grouping function G(o) is defined as a conditional probability:\nG(o) = P (G | d, `in, cin, `out, cout)\n= (1\u2212 P (\u00acDin | d)P (\u00acXin | `in, cin))\u03b2 P (\u00acXout | `out, cin, cout)1\u2212\u03b2\nwhere we set\nP (\u00acDin | d) = ( 1\u2212 e\u2212d/\u03bb )\u03b1\nP (\u00acXin | `in, cin) = (1\u2212 `in (1\u2212 cin))(1\u2212\u03b1)\nP (\u00acXout | `out, cout, cin) = 1\u2212 `out (1\u2212max (cin, cout)) .\nThis definition is loosely based on treating the boolean variables from our logical predicate as random and independent. \u03bb is estimated from training data, while \u03b1, \u03b2 were both fixed via experiments at 9/10.\nTo account for containment notations in the calculation of cin and cout, we annotate each symbol supported by the symbol recognizer with a flag indicating whether it is used to contain other symbols. (Currently only the \u221a symbol has this flag set.) Then the symbol recognizer is invoked to measure how closely a stroke or group of strokes resembles a container symbol."}, {"heading": "4.3.2 Symbol recognition score", "text": "The symbol recognition score S(\u03b1, o) for recognizing an input subset o as a terminal symbol \u03b1 uses a combination of four distance-based matching techniques within a template-matching scheme. In this scheme, the input strokes in o are matched against model strokes taken from a stored training example of \u03b1, yielding a match distance. This process is repeated for each of the training examples of \u03b1, and the two smallest match distances are averaged for each technique, giving four minimal distances d1, d2, d3, d4. The distances are then combined in a weighted sum\ns\u03b1 = 4\u2211 i=1 wiQi(di),\nwhere Qi : R\u2192 [0, 1] is the quantile function for the distribution of values emitted by the ith technique. These quantiles are approximated by piecewise linear functions and serve to normalize the outputs of the various distance functions so that they may be meaningfully arithmetically combined. The weights are optimized from training data. Finally, S(\u03b1, o) = s\u22122\u03b1 so that small distances correspond to large scores. The symbol recognition feature vector so in the Bayesian model contains the values S(\u03b1, o) for all terminals \u03b1.\nThe four distance-based techniques used are as follows:\n\u2022 A fast elastic matching variant [8] which finds a matching between the points of the input and model strokes and minimizes the sum of distances between matched points.\n\u2022 A functional approximation technique [4] which models stroke coordinates as parametric functions expressed as truncated Legendre-Sobolev series. The match distance is the 2-norm between coefficient vectors.\n\u2022 An offline technique [16] based on rasterizing strokes, treating filled pixels as points in Euclidean space, and computing the Hausdorff distance between those point sets.\n\u2022 A feature-vector method using the 2-norm between vectors containing the following normalized measurements of the input and model strokes: bounding box position and size, first and last point coordinates, and total arclength."}, {"heading": "4.4 Relation variables", "text": "The distribution of relation variables, Ro1,o2 | Eo1 , Eo2 , fo1 , fo2 , is similar to the symbol variable case in that it is based on the output of a lower-level recognition method, with some of the probability mass being reserved for the nil assignment. In particular, let R(r) denote the extent to which the observables o1 and o2 appear to satisfy the grammar relation r. Then we put\nP (Ro1,o2 = nil | Eo1 , Eo2 , fo1 , fo2) = 1\u2212 N\nN + 1 ,\nwhere N = log(1 + maxr R(r)), and distribute the remaining probability mass proportionally to R(r):\nP (Ro1,o2 = r | Eo1 , Eo2 , fo1 , fo2) \u221d R(r)\u2211 u\u2208RR(u) .\nR(r) is determined using two sources of information. The first is geometric information about the bounding boxes of o1 and o2. Let `(o), r(o), t(o), and b(o) respectively denote the left-, right-, top-, and bottom-most coordinates of an observable o. These four values form the relation-oriented feature vector fo in the Bayesian model. From two such vectors fo1 and fo2 , the following relation classification features are obtained (N is a normalization factor based on the sizes of o1 and o2):\nf1 = `(o2)\u2212 `(S1)\nN\nf2 = r(o2)\u2212 r(o1)\nN\nf3 = `(o2)\u2212 r(o1)\nN\nf4 = b(o2)\u2212 b(o1)\nN\nf5 = t(o2)\u2212 t(o1)\nN\nf6 = t(o2)\u2212 b(o1) N f7 = overlap(o1, o2)\nThe second type of information is prior knowledge about how two types of expressions are arranged when placed in each grammar relation. To represent this, each expression e is associated with one or more relational classes by a function c`(e). Each terminal symbol is itself a relational class (e.g., \u222b , x,+). Several more classes represent symbol stereotypes, as summarized in Table 2. Finally, there are three generic classes: sym (any symbol), expr (any multi-symbol expression), and gen (for \u201cgeneric\u201d; any expression whatsoever).\nThese labels are hierarchical with respect to specificity. For example, the symbol c is also a baseline symbol, any baseline symbol is also a sym expression, and any sym expression is also a gen expression.\nWe construct a classed scoring function Rc1,c2 for every pair c1, c2 of classes. Then, to evaluate R(r), we first try the most specific relevant classed scoring function. If, due to a lack of training data, it is unable to report a result, we fall back to a less-specific classed function. This process of gradually reducing the specificity of class labels continues until a score is obtained or both labels are the generic label gen.\nEach of the classed scoring functions is a naive Bayesian model that treats each of the features fi as drawn from independent normally-distributed variables Fi. So\nRc1,c2(r) = P (R = r) 7\u220f i=1 P (Fi = fi | R = r) ,\nwhere R is a categorical random variable distributed over the grammar relations. The parameters of these distributions are estimated from training data.\nWhen calculating a product of the form above, we check whether the true mean of each distribution lies within a 95% confidence interval of the training data\u2019s sample mean. If not, then the classed scoring function Rc1,c2(r) reports failure, and we fall back to less-specific relational class labels as described above."}, {"heading": "4.5 \u201cSymbol-bag\u201d variables", "text": "The role of the symbol-bag variables Bo is to apply a prior distribution to the terminal symbols appearing in the input, and to adapt that distribution based on which symbols are currently present. Because those symbols are not known with certainty, such adaptation may only be done imperfectly.\nWe collected symbol occurence and co-occurence rates from the Infty project corpus [15] as well as from the LATEX sources of University of Waterloo course notes for introductory algebra and calculus courses. The symbol occurence rate r(\u03b1) is the number of expressions in which the symbol \u03b1 appeared and the co-occurence rate c(\u03b1, \u03b2) is the number of expressions containing both \u03b1 and \u03b2.\nIn theory, each Bo variable is identically distributed and satisfies\nP Bo = nil | So = nil, \u2227 o\u2032\u2286o\u0302 So\u2032  = 1 and\nP Bo = \u03b1 | So = \u03b4, \u2227 o\u2032\u2286o\u0302 So\u2032  \u221d r(\u03b1) + \u2211 \u03b2\u2208\u03a3 P (So\u2032 = \u03b2 for some o \u2032 \u2286 o\u0302) c(\u03b1, \u03b2) r(\u03b2) ,\nfor any non-nil \u03b4 \u2208 \u03a3 (recall that o\u0302 is the entire input observable). The trivial nil case allows us to remove all terms with Bo\u2032 = nil from the product\n\u220f o\u2032\u2282o\u0302 P Bo\u2032 | \u2227 o\u2286o\u0302 So  in our scoring function.\nIn the non-nil case, note that for any subset o\u2032 of the input for which the grouping score G(o\u2032) is 0, we have So\u2032 = nil with probability one; thus in the P (So\u2032 = \u03b2 for some o\n\u2032 \u2286 o) term, we need only consider those subsets of o with a non-zero grouping score. Rather than assuming independence and iterating over all such subsets, or developing a more complex model, we simply approximate this probability by\nmax o\u2032\u2286o,G(o\u2032)>0\nP (So\u2032 = \u03b2 | go\u2032 , so\u2032) .\nEvaluation of these symbol-bag probabilities proceeds as follows. Starting with an empty input, only the r(\u03b1) term is used. The distribution is updated incrementally each time symbol recognition is performed on a candidate stroke group. The set of candidate groups is updated each time a new stroke is drawn by the user. When a group corresponding to an observable o is identified, the symbol recognition and stroke grouping processes induce the distribution of So, which we use to update the distribution of the B\u2217 variables by checking whether any of the max expressions need to be revised. Intuitively, B\u2217 treats the \u201cnext\u201d symbol to be recognized as being drawn from a bag full of symbols. If a previously-unseen symbol \u03b2 is drawn, then more symbols are added to the bag based on the co-occurence counts of \u03b2.\nThis process is similar to updating the parameter vector of a Dirichlet distribution, except that the number of times a given symbol appears within an expression is irrelevant. We are concerned only with how likely it is that the symbol appears at all."}, {"heading": "5 Accuracy evaluation", "text": "We performed two accuracy evaluations of the MathBrush recognizer. The first replicates the 2011 and 2012 CROHME evaluations [11, 12], which focus on the top-ranked expression only. To evaluate the efficacy of our recognizer\u2019s correction mechanism, we also replicated a user-focused evaluation which was initially developed to test an earlier version of the recognizer [9]."}, {"heading": "5.1 CROHME evaluation", "text": "Since 2011, the CROHME math recognition competition has invited researchers to submit recognition systems for comparative accuracy evaluation. In previous work, we compared the accuracy of a version of the MathBrush recognizer against that of the 2011 entrants [9]. We also participated in the 2012 competition, placing second behind a corporate entrant [12]. In this section we will evaluate the current MathBrush recognizer described by this paper against its previous versions as well as the other CROHME entrants.\nThe 2011 CROHME data is divided into two parts, each of which includes training and testing data. The first part includes a relatively small selection of mathematical notation, while the second includes a larger selection. For details, refer to the competition paper [11]. The 2012 data is similarly divided, but also includes a third part, which we omit from this evaluation as it included notations not used by MathBrush.\nFor each part of this evaluation, we trained our symbol recognizer on the same base data set as in the previous evaluation and augmented that training data with all of the symbols appearing in the appropriate part of the CROHME training data. The relation and grouping systems were trained on the 2011 Waterloo corpus. We used the grammars provided in the competition documentation.\nThe accuracy of our recognizer was measured using a perl script provided by the competition organizers. In this evaluation, only the top-ranked parse was considered. There are four accuracy measurements: stroke reco. indicates the percentage of input strokes which were correctly recognized and placed in the parse tree; symbol seg. indicates the percentage of symbols for which the correct strokes were properly grouped together; symbol reco. indicates the percentage of symbol recognized correctly, out of those correctly grouped; finally, expression reco. indicates the percentage of expressions for which the top-ranked parse tree was exactly correct.\nIn these tables, \u201cUniversity of Waterloo (prob.)\u201d refers to the recognizer described in this paper, \u201cUniversity of Waterloo (2012)\u201d refers to the version submitted to the CROHME 2012 competition, and \u201cUniversity of Waterloo (2011)\u201d refers to the version used for a previous publication [9]. Both of these previous versions used a fuzzy set formalism to capture and manage ambiguous interpretations. The remaining rows are reproduced from the CROHME reports [11, 12].\nThese results indicate that the MathBrush recognizer is significantly more accurate than all other CROHME entrants except for Vision Objects recognizer, which is much more accurate again. Moreover, the performance of the current version of the MathBrush recognizer is a significant improvement over previous versions, except in the case of symbol segmentation (stroke grouping) on part 2 of the 2012 data set. This is possibly because the MathBrush 2012 recognizer submitted to CROHME was fairly well-tuned to the 2012 training data, whereas we did not adjust any recognition parameters for the evaluation presented in this paper.\nWith respect to the Vision Objects recognizer, a short description may be found in the CROHME reports [12, 13]. Many similarities exist between their methods and our own: notably, a systematic\ncombination of the stroke grouping, symbol recognition, and relation classifiaction problems, relational grammars in which each production is associated with a single geometric relationship, and a combination of online and offline methods for symbol recognition. The main significant difference between our approaches appears to be the statistical language model of Vision Objects and their use of very large private training corpora (hundreds of thousands for the language model, with 30000 used for training the CROHME 2013 system \u2013 the precise distinction between these training sets is unclear)."}, {"heading": "5.2 Evaluation on Waterloo corpus", "text": "In previous work, we proposed a user-oriented accuracy metric that measured how accurate an expression was recognized by counting how many corrections needed to be made to the results [9]. This metric is similar to a tree-based edit distance in that each edit operation corresponds to selecting one of the alternative recognition results offered by the recognizer on a particular subset of the input.\nTo facilitate meaningful comparison with our previous results, we have replicated the same evaluation as closely as possible. The evaluation consists of two scenarios. In the first (\u201cdefault\u201d) scenario, the 1536 corpus transcriptions containing fewer than four symbols were used as a training set, with the remainder of the 3674-transcription corpus used as a testing set. Each symbol in the training set was extracted and added to the library of training examples. This library also contained roughly 5-15 samples of each symbol collected from writers not appearing in the corpus, which ensured that all symbols possessed an adequate number of training examples. Because the training transcriptions contained only a few symbols each, they did not yield sufficient data to adequately train the relation classifier. We therefore augmented the relation classifier training data with larger transcriptions from a 2011 collection study [6]. (The symbol recognizer was not trained on this data.)\nThe second (\u201cperfect\u201d) scenario disregarded stroke grouping and symbol recognition results, which are the largest sources of ambiguity in our recognizer, and evaluated the quality of expression parsing and relation classification. The training and testing sets for this scenario were identical to those for the default scenario, but terminal symbol identities were extracted directly from transcription ground truth prior to recognition, bypassing the stroke grouping and symbol recognition systems altogether.\nFollowing recognition, each transcription is assigned to one of the following classes:\n1. Correct : No corrections were required. The top-ranked interpretation was correct.\n2. Attainable: The correct interpretation was obtained from the recognizer after one or more corrections.\n3. Incorrect : The correct interpretation could not be obtained from the recognizer.\nIn the original experiment, the \u201cincorrect\u201d class was divided into both \u201cincorrect\u201d and \u201cinfeasible\u201d. The infeasible class counted transcriptions for which the correct symbols were not identified by the symbol recognizer, making it easier to distinguish between symbol recognition failures and relation classification failures. In the current version of the system, many symbols are recognized through a combination of symbol and relation classification, so the distinction between feasible and infeasible is no longer useful. We have therefore merged the infeasible and incorrect classes for this experiment. Table 5 summarizes the recognizer\u2019s accuracy and the average number of symbol and structural corrections required in each of these scenarios.\nIn the default scenario, the rates of attainability (i.e., the sum of correct and attainable columns) and correctness were both significantly higher for the recognizer described in this paper than for our earlier system, which was based on fuzzy sets. The average number of corrections required to obtain the correct interpretation was also lower for the new recognizer.\nIn the perfect scenario, the rates were much closer. The probabilistic system achieved a somewhat higher correctness rate, but in this scenario had a slightly lower attainability rate than the fuzzy variant. Rather than this indicating a problem with the probabilistic recognizer, it likely indicates that the hand-coded rules of the fuzzy relation classifier were too highly tuned for the 2009 training data. Further evidence of this \u201cover-training\u201d of the 2011 system is pointed out by MacLean [7]."}, {"heading": "6 Conclusions and future work", "text": "As shown in the evaluation above, the MathBrush recognizer is competitive with other state-of-the-art academic recognition systems, and its accuracy is improving over time as work continues on the project. At a high level, the recognizer organizes its input via relational context-free grammars, which represent the concept of recognition quite naturally via interpretations \u2013 a grammar-derivable expression paired with an observable set of input strokes.\nBy introducing some constraints on how inputs may be partitioned, we derived an efficient parsing algorithm derived from Unger\u2019s method. The output of this algorithm is a parse forest, which simultaneously represents all recognizable parses of the input in a fairly compact data structure. From the parse forest, individual parse trees may be obtained by the extraction algorithm described in Section 3.3, subject to some abstract restrictions on how parse trees are scored.\nThe tree scoring function is the primary novel contribution of this paper. We construct a Bayesian network based on the input and use the fact that variable assignments are derived from parse trees to eliminate the majority of variables from probability calculations. Three of the five remaining families of distributions \u2013 stroke grouping, symbol identity, and relation identity \u2013 are based on the results of lower-level classification systems. The remaining distribution families (expressions and symbol priors) are respectively derived from the grammar structure and training data.\nThe Bayesian network approach provides a systematic and extensible foundation for scoring parse trees. It is straightforward to combine underlying scoring systems in a well-specified way, and it is easy to modify those underlying systems without disrupting the model as a whole. However, some improvements are still desirable.\nIn particular, we wish to allow score interactions between sibling nodes in a parse tree, not just between parents and children. This would, for example, let cos\u03c9 be assigned a higher score than cosw even if w had a higher symbol recognition score than \u03c9, provided that the combination of cos and \u03c9 was more prevalent in training data than the combination of cos and w. There are a few ways in which such information may be included in the Bayesian model, although we currently lack a sufficiently large set of training expressions to effectively train the result.\nMore importantly, such a change to the Bayesian model would also necessitate an adjustment of our parsing methods, since the example just mentioned violates the restrictions on scoring functions required by the parse tree extraction algorithm. How to permit more flexibility in subexpression combinations while maintaining reasonable speed and keeping track of multiple interpretations is our main focus for future research."}], "references": [{"title": "Recognition of printed mathematical expressions using two-dimensional stochastic context-free grammars", "author": ["Francisco \u00c1lvaro", "Joan-Andreu S\u00e1nchez", "Jos\u00e9-Miguel Bened\u0301\u0131"], "venue": "In Proc. of the Int\u2019l. Conf. on Document Analysis and Recognition,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2011}, {"title": "Syntax-Directed Recognition of Hand-Printed Two-Dimensional Mathematics", "author": ["Robert H. Anderson"], "venue": "PhD thesis, Harvard University,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1968}, {"title": "The problem of handwritten mathematical expression recognition evaluation", "author": ["A.-M. Awal", "H. Mouch\u00e8re", "C. Viard-Gaudin"], "venue": "In Proc. of the Int\u2019l. Conf. on Frontiers in Handwriting Recognition,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2010}, {"title": "Online computation of similarity between handwritten characters", "author": ["Oleg Golubitsky", "Stephen M. Watt"], "venue": "In Proc. Document Recognition and Retrieval XVI,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2009}, {"title": "Mathbrush: A system for doing math on pen-based devices", "author": ["G. Labahn", "E. Lank", "S. MacLean", "M. Marzouk", "D. Tausky"], "venue": "In Proc. of the Eighth IAPR Workshop on Document Analysis Systems,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "Is the ipad useful for sketch input?: a comparison with the tablet pc", "author": ["S. MacLean", "D. Tausky", "G. Labahn", "E. Lank", "M. Marzouk"], "venue": "In Proceedings of the Eighth Eurographics Symposium on Sketch-Based Interfaces and Modeling,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2011}, {"title": "Automated recognition of handwritten mathematics", "author": ["Scott MacLean"], "venue": "PhD thesis, University of Waterloo,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2014}, {"title": "Elastic matching in linear time and constant space", "author": ["Scott MacLean", "George Labahn"], "venue": "In Proc., Ninth IAPR Int\u2019l. Workshop on Document Analysis Systems,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2010}, {"title": "A new approach for recognizing handwritten mathematics using relational grammars and fuzzy sets", "author": ["Scott MacLean", "George Labahn"], "venue": "International Journal on Document Analysis and Recognition (IJDAR),", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "Foundations of Statistical Natural Language Processing", "author": ["Christopher D. Manning", "Hinrich Schuetze"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1999}, {"title": "CROHME2011: Competition on recognition of online handwritten mathematical expressions", "author": ["H. Mouch\u00e8re", "C. Viard-Gaudin", "U. Garain", "D.H. Kim", "J.H. Kim"], "venue": "In Proc. of the 11th Int\u2019l. Conference on Document Analysis and Recognition,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2011}, {"title": "Competition on recognition of online mathematical expressions (CROHME 2012)", "author": ["H. Mouch\u00e8re", "C. Viard-Gaudin", "U. Garain", "D.H. Kim", "J.H. Kim"], "venue": "In Proc. of the 13th Int\u2019l. Conference on Frontiers in Handwriting Recognition,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2012}, {"title": "CROHME \u2013 Third international competition on recognition of online mathematical expressions", "author": ["H. Mouch\u00e8re", "C. Viard-Gaudin", "R. Zanibbi", "U. Garain", "D.H. Kim", "J.H. Kim"], "venue": "In Proc. of the 12th Int\u2019l. Conference on Document Analysis and Recognition,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2013}, {"title": "A unified framework for symbol segmentation and recognition of handwritten mathematical expressions", "author": ["Yu Shi", "HaiYang Li", "F.K. Soong"], "venue": "In Document Analysis and Recognition, Ninth International Conference on,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2007}, {"title": "A ground-truthed mathematical character and symbol image database", "author": ["Masakazu Suzuki", "Seiichi Uchida", "Akihiro Nomura"], "venue": "Document Analysis and Recognition, International Conference on,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2005}, {"title": "A neural network model for online handwritten mathematical symbol recognition", "author": ["Arit Thammano", "Sukhumal Rugkunchon"], "venue": "Lecture Notes in Computer Science,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2006}, {"title": "A global parser for context-free phrase structure grammars", "author": ["Stephen H. Unger"], "venue": "Commun. ACM,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 1968}, {"title": "On-line recognition of handwritten mathematical expression based on stroke-based stochastic context-free grammar", "author": ["R. Yamamoto", "S. Sako", "T. Nishimoto", "S. Sagayama"], "venue": "In The Tenth International Workshop on Frontiers in Handwriting Recognition,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2006}], "referenceMentions": [{"referenceID": 1, "context": "Academic interest in the problem of recognizing hand-drawn math expressions originated with Anderson\u2019s doctoral research in the late 1960\u2019s [2].", "startOffset": 140, "endOffset": 143}, {"referenceID": 10, "context": "Interest has waxed and waned in the intervening decades, and recent years have witnessed renewed attention to the topic, potentially spurred on by the nascent Competition on Recognition of Handwritten Mathematical Expressions (CROHME) [11, 12].", "startOffset": 235, "endOffset": 243}, {"referenceID": 11, "context": "Interest has waxed and waned in the intervening decades, and recent years have witnessed renewed attention to the topic, potentially spurred on by the nascent Competition on Recognition of Handwritten Mathematical Expressions (CROHME) [11, 12].", "startOffset": 235, "endOffset": 243}, {"referenceID": 4, "context": "1 MathBrush Our work is done in the context of the MathBrush pen-based math system [5].", "startOffset": 83, "endOffset": 86}, {"referenceID": 8, "context": "We have previously reported techniques for capturing and reporting these multiple interpretations [9], and some of those ideas remain the foundation of the work presented in this paper.", "startOffset": 98, "endOffset": 101}, {"referenceID": 10, "context": "Many recent systems and approaches are summarized in the CROHME reports [11, 12].", "startOffset": 72, "endOffset": 80}, {"referenceID": 11, "context": "Many recent systems and approaches are summarized in the CROHME reports [11, 12].", "startOffset": 72, "endOffset": 80}, {"referenceID": 0, "context": "1 Alvaro et al The system developed by Alvaro et al [1] placed first in the CROHME 2011 recognition contest [11].", "startOffset": 52, "endOffset": 55}, {"referenceID": 10, "context": "1 Alvaro et al The system developed by Alvaro et al [1] placed first in the CROHME 2011 recognition contest [11].", "startOffset": 108, "endOffset": 112}, {"referenceID": 17, "context": "It is based on earlier work of Yamamoto et al [18].", "startOffset": 46, "endOffset": 50}, {"referenceID": 9, "context": "However, stochastic grammars are known to biased toward short parse trees (those containing few derivation steps) [10].", "startOffset": 114, "endOffset": 118}, {"referenceID": 2, "context": "2 Awal et al While the system described by Awal et al [3] was included in the CROHME 2011 contest, its developers were directly associated with the contest and were thus not official participants.", "startOffset": 54, "endOffset": 57}, {"referenceID": 13, "context": "3 Shi, Li, and Soong Working with Microsoft Research Asia, Shi, Li, and Soong proposed a unified HMM-based method for recognizing math expressions [14].", "startOffset": 147, "endOffset": 151}, {"referenceID": 8, "context": "We previously described a fuzzy relational grammar formalism which explicitly modeled recognition as a process by which an observed, ambiguous input is interpreted as a certain, structured expression [9].", "startOffset": 200, "endOffset": 203}, {"referenceID": 8, "context": "Interested readers are referred to [9] and [7] for more details.", "startOffset": 35, "endOffset": 38}, {"referenceID": 6, "context": "Interested readers are referred to [9] and [7] for more details.", "startOffset": 43, "endOffset": 46}, {"referenceID": 16, "context": "2 Unger\u2019s method Unger\u2019s method is a fairly brute-force algorithm for parsing CFGs [17].", "startOffset": 83, "endOffset": 87}, {"referenceID": 8, "context": "These procedures for obtaining the best and next-best parse trees at OR- and AND-nodes are similar to those we described previously [9].", "startOffset": 132, "endOffset": 135}, {"referenceID": 0, "context": "where Qi : R\u2192 [0, 1] is the quantile function for the distribution of values emitted by the ith technique.", "startOffset": 14, "endOffset": 20}, {"referenceID": 7, "context": "The four distance-based techniques used are as follows: \u2022 A fast elastic matching variant [8] which finds a matching between the points of the input and model strokes and minimizes the sum of distances between matched points.", "startOffset": 90, "endOffset": 93}, {"referenceID": 3, "context": "\u2022 A functional approximation technique [4] which models stroke coordinates as parametric functions expressed as truncated Legendre-Sobolev series.", "startOffset": 39, "endOffset": 42}, {"referenceID": 15, "context": "\u2022 An offline technique [16] based on rasterizing strokes, treating filled pixels as points in Euclidean space, and computing the Hausdorff distance between those point sets.", "startOffset": 23, "endOffset": 27}, {"referenceID": 14, "context": "We collected symbol occurence and co-occurence rates from the Infty project corpus [15] as well as from the LTEX sources of University of Waterloo course notes for introductory algebra and calculus courses.", "startOffset": 83, "endOffset": 87}, {"referenceID": 10, "context": "The first replicates the 2011 and 2012 CROHME evaluations [11, 12], which focus on the top-ranked expression only.", "startOffset": 58, "endOffset": 66}, {"referenceID": 11, "context": "The first replicates the 2011 and 2012 CROHME evaluations [11, 12], which focus on the top-ranked expression only.", "startOffset": 58, "endOffset": 66}, {"referenceID": 8, "context": "To evaluate the efficacy of our recognizer\u2019s correction mechanism, we also replicated a user-focused evaluation which was initially developed to test an earlier version of the recognizer [9].", "startOffset": 187, "endOffset": 190}, {"referenceID": 8, "context": "In previous work, we compared the accuracy of a version of the MathBrush recognizer against that of the 2011 entrants [9].", "startOffset": 118, "endOffset": 121}, {"referenceID": 11, "context": "We also participated in the 2012 competition, placing second behind a corporate entrant [12].", "startOffset": 88, "endOffset": 92}, {"referenceID": 10, "context": "For details, refer to the competition paper [11].", "startOffset": 44, "endOffset": 48}, {"referenceID": 8, "context": ")\u201d refers to the recognizer described in this paper, \u201cUniversity of Waterloo (2012)\u201d refers to the version submitted to the CROHME 2012 competition, and \u201cUniversity of Waterloo (2011)\u201d refers to the version used for a previous publication [9].", "startOffset": 239, "endOffset": 242}, {"referenceID": 10, "context": "The remaining rows are reproduced from the CROHME reports [11, 12].", "startOffset": 58, "endOffset": 66}, {"referenceID": 11, "context": "The remaining rows are reproduced from the CROHME reports [11, 12].", "startOffset": 58, "endOffset": 66}, {"referenceID": 11, "context": "With respect to the Vision Objects recognizer, a short description may be found in the CROHME reports [12, 13].", "startOffset": 102, "endOffset": 110}, {"referenceID": 12, "context": "With respect to the Vision Objects recognizer, a short description may be found in the CROHME reports [12, 13].", "startOffset": 102, "endOffset": 110}, {"referenceID": 8, "context": "2 Evaluation on Waterloo corpus In previous work, we proposed a user-oriented accuracy metric that measured how accurate an expression was recognized by counting how many corrections needed to be made to the results [9].", "startOffset": 216, "endOffset": 219}, {"referenceID": 5, "context": "We therefore augmented the relation classifier training data with larger transcriptions from a 2011 collection study [6].", "startOffset": 117, "endOffset": 120}, {"referenceID": 6, "context": "Further evidence of this \u201cover-training\u201d of the 2011 system is pointed out by MacLean [7].", "startOffset": 86, "endOffset": 89}], "year": 2014, "abstractText": "Recognizing handwritten mathematics is a challenging classification problem, requiring simultaneous identification of all the symbols comprising an input as well as the complex two-dimensional relationships between symbols and subexpressions. Because of the ambiguity present in handwritten input, it is often unrealistic to hope for consistently perfect recognition accuracy. We present a system which captures all recognizable interpretations of the input and organizes them in a parse forest from which individual parse trees may be extracted and reported. If the top-ranked interpretation is incorrect, the user may request alternates and select the recognition result they desire. The tree extraction step uses a novel probabilistic tree scoring strategy in which a Bayesian network is constructed based on the structure of the input, and each joint variable assignment corresponds to a different parse tree. Parse trees are then reported in order of decreasing probability. Two accuracy evaluations demonstrate that the resulting recognition system is more accurate than previous versions (which used non-probabilistic methods) and other academic math recognizers.", "creator": "LaTeX with hyperref package"}}}