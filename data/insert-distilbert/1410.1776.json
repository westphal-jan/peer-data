{"id": "1410.1776", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-Oct-2014", "title": "Ontology-based Representation and Reasoning on Process Models: A Logic Programming Approach", "abstract": "we propose a framework grounded in logic programming for representing and reasoning about business processes from both the procedural and ontological point of views. : in particular, our goal is threefold : ( 1 ) define a logical design language and a formal semantics for process models enriched with language ontology - based annotations ; ( 2 ) provide an increasingly effective inference mechanism that supports the combination of reasoning services dealing with the structural definition of a process model, its behavior, and the facial domain knowledge related to the participating business entities ; ( 3 ) implement such a theoretical framework into a process modeling and reasoning platform. to this end we define a process ontology coping with a relevant fragment of the popular bpmn modeling notation. the behavioral semantics of a process is defined as a state transition system by following an approach similar to the fluent calculus, and allows us to specify state change in terms of preconditions and indirect effects of the enactment of activities. then we show how the procedural process knowledge can be seamlessly integrated with the physical domain knowledge specified by using the owl 2 rl rule - based ontology language. our framework membership provides a wide range of reasoning services, including ctl model checking, which routinely can be performed by using standard logic programming inference engines through a goal - oriented, efficient, sound and complete evaluation procedure. we also present a software environment implementing the proposed framework, and we report on an experimental evaluation of the system, whose results are equally encouraging and show the viability of the approach.", "histories": [["v1", "Tue, 7 Oct 2014 15:39:03 GMT  (928kb,D)", "http://arxiv.org/abs/1410.1776v1", null]], "reviews": [], "SUBJECTS": "cs.AI", "authors": ["fabrizio smith", "maurizio proietti"], "accepted": false, "id": "1410.1776"}, "pdf": {"name": "1410.1776.pdf", "metadata": {"source": "CRF", "title": "Ontology-based Representation and Reasoning on Process Models: A Logic Programming Approach", "authors": ["Fabrizio Smith"], "emails": ["maurizio.proietti}@iasi.cnr.it"], "sections": [{"heading": null, "text": "Keywords: Business Processes, Ontologies, Logic Programming, Knowledge Representation, Verification."}, {"heading": "1 Introduction", "text": "The adoption of structured and systematic approaches for the management of Business Processes (BPs) that operate within an organization is constantly gaining popularity, especially in medium to large organizations such as manufacturing enterprises, service providers, and public administrations. The core of such approaches is the development of BP models that represent the knowledge about processes in machine accessible form. One of the main advantages of process modeling is that it enables automated analysis facilities, such as the verification that the requirements specified over the models are enforced. The automated analysis issue is addressed in the BP Management (BPM) community mainly from a control flow perspective, with the aim of verifying whether the behavior of the modeled system presents logical errors (see, for instance, the notion of soundness [64]).\nar X\niv :1\n41 0.\n17 76\nv1 [\ncs .A\nI] 7\nO ct\n2 01\nUnfortunately, standard BP modeling languages are not fully adequate to capture process knowledge in all its aspects. While their focus is on the procedural representation of a BP as a workflow graph that specifies the planned order of operations, the domain knowledge regarding the entities involved in such a process, i.e., the business environment in which processes are carried out, is often left implicit. This kind of knowledge is typically expressed through natural language comments and labels attached to the models, which constitute very limited, informal and ambiguous pieces of information. The lack of a formal representation of the domain knowledge within process models is widely recognized as an obstacle for the further automation of BPM tools and methodologies that effectively support process analysis, retrieval, and reuse [32].\nIn order to overcome this limitation, the application of well-established techniques stemming from the area of Knowledge Representation in the domains of BP modeling [32, 17, 36, 66] and Web Services [12, 22] has been shown to be a promising approach. In particular, the use of computational ontologies is the most established approach for representing in a machine processable way the knowledge about the domain where business processes operate, providing formal definitions for the basic entities involved in a process, such as activities, actors, data items, and the relations between them. However, there are still several open issues regarding the combination of BP modeling languages (with their execution semantics) and ontologies, and the accomplishment of behavioral reasoning tasks involving both these components. Indeed, most of the approaches developed for the semantic enrichment of process models or Web Services (such as the above cited ones) do not provide an adequate model theory nor an axiomatization to capture and reasoning on dynamic aspects of process descriptions. On the other hand, approaches based on action languages developed in AI (e.g., [57, 6, 44]) are very expressive formalisms that can be used to simultaneously capture the process and the domain knowledge, but they are too general to be applied to BP modeling, and must be suitably restricted not only towards decidability of reasoning but also to reflect the peculiarities of processes. Indeed, action languages provide a limited support for process definition, in terms of workflow constructs, and they lack a clear mapping from standard (ontology and process) modeling languages.\nThe main objective of this paper is to design a framework for representing and reasoning about business process knowledge from both the procedural and ontological point of views. To achieve this goal, we do not propose yet another business process modeling language, but we provide a framework based on Logic Programming (LP) [38] for reasoning about process-related knowledge expressed by means of de-facto standards for BP modeling, like BPMN [46], and ontology definition, like OWL [43]. We define a rule-based procedural semantics for a relevant fragment of BPMN, by following an approach inspired by the Fluent Calculus [61], and we extend it in order to take into account OWL annotations that describe preconditions and effects of activities and events occurring within a BP. In particular, we integrate our procedural BP semantics with the OWL 2 RL profile thanks to a common grounding in LP. OWL 2 RL is indeed a fragment of the OWL ontology language that has a suitable rule-based presentation, thus constituting an excellent compromise between expressivity and efficiency.\nThe contributions of this paper can be summarized as follows. After presenting the preliminaries in Section 2, we propose, in Section 3, a revised and extended version of the Business Process Abstract Language (BPAL) [16, 56], a process ontology for modeling the procedural semantics of a BP regarded as a workflow. To this end we introduce an axiomatization to cope with a relevant fragment of the BPMN 2.0 specification, allowing us to deal with a large class of process models.\nWe then propose, in Section 4, an approach for the semantic annotation of BP models, where BP elements are described by using an OWL 2 RL ontology.\nIn Section 5 we provide a general verification mechanism by integrating the temporal logic CTL [15] within our framework, in order to analyze properties of the states that the system can reach, by taking into account both the control-flow and the semantic annotation.\nIn Section 6 we show how a repository of semantically enriched BPs can be organized in a Business Process Knowledge Base (BPKB), which, due to the common representation of its components in LP, provides a uniform and formal framework that enables logical inference. We then discuss how, by using state-of-the-art LP systems, we can perform some very sophisticated reasoning tasks, such as verification, querying and trace compliance checking, that combine both the procedural and the domain knowledge relative to a BP.\nIn Section 7 we provide the computational characterization of the reasoning services that can be performed on top of a BPKB, showing in particular that, for a large class of them, advanced resolution strategies (such as SLG-Resolution [14]) guarantee an efficient, sound and complete procedure.\nIn Section 8 we describe the implemented tool, which provides a graphical user interface to support the semantic BP design, and a reasoner, developed in XSB Prolog [58], able to operate on the BPKB. We also report on an evaluation of the system performance, demonstrating that complex reasoning tasks can be performed on business process of small-to-medium size in an acceptable amount of time and memory resources.\nIn Section 9 we compare our work to related approaches and in the concluding section we give a critical discussion of our approach, along with directions for future work."}, {"heading": "2 Preliminaries", "text": "In order to clarify the terminology and the notation used throughout this paper, in this section we recall some basic notions related to the BPMN notation [46], Description Logics [4] as well as foundations of the OWL [43] standard, and Logic Programming [38]."}, {"heading": "2.1 BPMN", "text": "Business Process Modeling and Notation (BPMN) [46] is a graphical language for BP modeling, standardized by the OMG (http://www.omg.org). The primary goal of BPMN is to provide a standard notation readily understandable by all business stakeholders, which include the business analysts who create and refine the processes, the technical developers responsible for their implementation, and the business managers who monitor and manage them.\nA BPMN model is defined through a Business Process Diagram (BPD), which is a kind of flowchart incorporating constructs to represents the control flow, data flow, resource allocation (i.e., how the work is assigned to the participants), and exception handling (i.e., how erroneous behavior can be handled and compensated). We will briefly overview the core BPMN constructs referring to the example in Figure 1.\nThe constructs of BPMN are classified as flow objects, artifacts, connecting objects, and swimlanes.\nFlow objects are partitioned into activities (represented as rounded rectangles), events (represented as circles), and gateways (represented as diamonds). Activities are a generic way of representing some kind of work performed within the process, and can be tasks (i.e.,\natomic activities such as create order) or compound activities corresponding to the execution of entire sub-processes (e.g., create order). Events denote something that \u201chappens\u201d during the enactment of a business process, and are classified as start events, intermediate events, and end events which can start (e.g., s), suspend (e.g., ex), or end (e.g., e) the process enactment. An intermediate event, such as ex, attached to the boundary of an activity models exception handling. Gateways model the branching and merging of the control flow. There are several types of gateways in BPMN, each of which may be used as a branch gateway if it has multiple outgoing flows, or a merge gateway if it has multiple incoming flows. The split and join behavior depends on the semantics associated to each type of gateway. Exclusive branch gateways (e.g., g1 ) are decision points where exactly one of a set of mutually exclusive alternative flows is selected, while an exclusive merge gateway (e.g., g2 ) merges two incoming flows into a single one. Parallel branch gateways (e.g., g7 ) create parallel threads of execution, while parallel merge gateways (e.g., g8 ) synchronize concurrent flows. Inclusive branch gateways (e.g., g3 ) are decision points where at least one of a set of non-exclusive alternative flows is selected, while an inclusive merge gateway (e.g., g4 ) is supposed to be able to synchronize a varying number of threads, i.e., it is executed only when at least one of its predecessors has been executed and no other will be eventually executed1.\nConnecting objects are sequence flows (e.g., the directed edge between g1 and g3 ) and associations (e.g., the dashed edge between create order and order). A sequence flow links two flow objects and denotes a control flow relation, i.e., it states that the control flow can pass from the source to the target object. An association is used to associate artifacts (i.e., data objects) with flow objects, and its direction defines if a data object is used as an input (e.g., order is an input of accept order) or it is an output (e.g., order is an output of create order) of some flow element.\nSwimlanes are used to model participants, i.e., a generic notion representing a role within a company (e.g., Sales Clerk), a department (e.g., Finance) or a business partner (e.g., Courier), which is assigned to the execution of a collection of activities."}, {"heading": "2.2 Description Logics and Rule-based OWL Ontologies", "text": "Description Logics (DLs) [4] are a family of knowledge representation languages that can be used to represent the knowledge of an application domain in a structured and formally well-understood way. DLs are typically adopted for the definition of ontologies since on the one hand, the important notions of the domain are described by concept descriptions, i.e., expressions that are built from atomic concepts (usually thought as sets of individuals, e.g., Person) and atomic roles (relations between concepts, e.g., worksFor) using the concept and role constructors provided by the particular DL (e.g., Personu\u2203worksFor.Company, that is, the set of persons who work for a company). On the other hand, DLs correspond to decidable fragments of classical first-order logic (FOL), and thus are equipped with a formal, logic-based semantics that makes such languages suitable for automated reasoning.\nTypically, Description Logics are used for representing a TBox (terminological box) and the ABox (Assertional Box). The TBox describes concept (and role) hierarchies, (e.g., Employee v Person u \u2203worksFor.Company), while the ABox contains assertions about individuals (e.g., john : Employee).\n1For sake of completeness, BPMN provides two more types of gateways, which we do not exemplify, namely, the event-based and the complex gateway.\nThe growing interest in the Semantic Web vision [7], where Knowledge Representation techniques are adopted to make resources machine-interpretable by \u201cintelligent agents\u201d, has pushed the standardization of languages for ontology and meta-data sharing over the (semantic) web. Among these, one of the most promising standards is the Ontology Web Language (OWL) [43], formally grounded in DLs, proposed by the Web Ontology Working Group of W3C. OWL is syntactically layered on RDF [34] and RDFS [10], and can be considered as an extension of RDFS in terms of modeling capabilities and reasoning facilities. The underlying data model (derived from RDF) is based on statements (or RDF triples) of the form < subject, property, object >, which allow us to describe a resource (subject) in terms of named relations (properties). Values of named relations (i.e. objects) can be URIrefs of Web resources or literals, i.e., representations of data values (such as integers and strings).\nTable 1 shows, for some OWL statements, the corresponding DL notations and FOL formulae, where C and D are concepts (OWL classes), P and Q are roles (OWL properties), a and b are constants, and x and y are variables.\nThe recent OWL 2 specification defines profiles that correspond to syntactic subsets of OWL, each of which is designed to trade some expressive power for efficiency of reasoning. In particular, we consider OWL 2 RL, closely related to the Horn fragment of FOL, which is based on Description Logic Programs [28] and pD* [59]. The use of OWL 2 RL allows us to take advantage of the efficient resolution strategies developed for logic programs, in order to perform the reasoning tasks typically supported by Description Logics reasoning systems, such as concept subsumption and ontology consistency. Indeed, the semantics of OWL 2 RL is defined through a partial axiomatization of the OWL 2 RDF-Based\nSemantics in the form of first-order implications (OWL 2 RL/RDF rules), and constitutes an upward-compatible extension of RDF and RDFS.\nOWL 2 RL ontologies are modeled by means of the ternary predicate t(s, p, o) representing an OWL statement with subject s, predicate p and object o. For instance, the assertion t(a, rdfs:subClassOf, b) represents the inclusion axiom a v b. Reasoning on triples is supported by OWL 2 RL/RDF rules of the form t(s, p, o) \u2190 t(s1, p1, o1) \u2227 \u00b7 \u00b7 \u00b7 \u2227 t(sn, pn, on). Table 2 shows some of the rules of the OWL 2 RL/RDF rule-set. According to the terminology we will introduce in the next section, this rule set is a definite logic program."}, {"heading": "2.3 Logic programming", "text": "We briefly recall the basic notions of Logic Programming. In particular, we will consider the class of locally stratified logic programs, or stratified programs, for short, and their standard semantics defined by the perfect model. (Recall that all major declarative semantics of logic programs coincide on stratified programs.) This class of logic programs is expres-\nsive enough to represent several complementary pieces of knowledge related to business processes, such as the syntactic structure of the control flow, the operational semantics, the ontology-based properties, and the temporal properties of the execution. For more details about LP we refer to [38, 2].\nA term is either a constant, or a variable, or an expression of the form f(t1, . . . , tm), where f is a function symbol and t1, . . . , tm are terms. An atom is a formula of the form p(t1, . . . , tm), where p is a predicate symbol and t1, . . . , tm are terms. A literal is either an atom or a negated atom. A rule is a formula of the form A\u2190 L1 \u2227 . . .\u2227Ln, where A is an atom (the head of the rule) and L1 \u2227 . . . \u2227 Ln is a conjunction of literals (the body of the rule). If n = 0 we call the rule a fact. A rule (term, atom, literal) is ground if no variables occur in it. A logic program is a set of rules. A definite program is a logic program with no negated atoms in the body of its rules. For a logic program P , by ground(P ) we denote the set of ground instances of rules in P .\nLet BP denote the Herbrand base for P , that is, the set of ground atoms that can be constructed in the language of program P . An (Herbrand) interpretation I is a subset of BP . A ground atom A is true in I if A \u2208 I. A ground negated atom \u00acA is true in I if A 6\u2208 I. A ground rule A \u2190 L1 \u2227 . . . \u2227 Ln is true in I if either A is true in I or, for some i \u2208 {1, . . . , n}, Li is not true in I. An interpretation is a model of P if all rules in ground(P ) are true in I. Every definite program has a least Herbrand model. However, this property does not hold for general logic programs.\nA (local) stratification is a function \u03c3 from the Herbrand base BP to the set of all countable ordinals [2, 50]. However, for the purposes of this paper it will be enough to consider stratification functions from BP to the set N of the natural numbers. For a ground atom A, \u03c3(A) is called the stratum of A. A stratification \u03c3 extends to negated atoms by taking \u03c3(\u00acA)=\u03c3(A) + 1. A ground rule A \u2190 L1 \u2227 . . . \u2227 Ln is stratified with respect to \u03c3 if, for i = 1, . . . , n, \u03c3(A)\u2265\u03c3(Li). A program P is stratified with respect to \u03c3 if every rule in ground(P ) is. Finally, a logic program is stratified if it is stratified with respect to some stratification function.\nThe perfect model of P , denoted Perf(P ), is defined as follows. Let P be stratified with respect to \u03c3. For every n \u2208 N, let Sn be the set of rules in ground(P ) whose head has stratum n. Thus, ground(P ) = \u22c3 n\u2208N Sn. We define a sequence of interpretations as follows: (i) M0 is the least model of S0 (note that S0 is a definite program), and (ii) Mn+1 is the least model of Sn that contains Mn. The perfect model of P , is defined as Perf(P ) = \u22c3 n\u2208NMn. (Here we are using the simplifying assumption that the codomain of the stratification function is N.) The operational semantics of logic programs is based on the notion of derivation, which is constructed by SLD-resolution augmented with the Negation as Failure rule [38]. Given a stratified program P , we will define below the one-step derivation relation Q1 \u03b8\u2212\u2192 Q2, where Q1, Q2 are queries, that is, conjunctions of literals, and \u03b8 is a substitution. The definition of one-step derivation relation depends on the following notions. A derivation for a query Q0 with respect to P is a sequence Q0 \u03b81\u2212\u2192 . . . \u03b8n\u2212\u2192 Qn (n \u2265 1). We will omit the reference to P when clear from the context. A derivation is successful if its last query is the empty conjunction true. A query succeeds if there exists a successful derivation for it. A query fails if it does not succeed. The one-step derivation relation is defined by the following two derivation rules.\n(P) Let A\u2227Q be a query, where A is an atom. Suppose that H \u2190 K1\u2227 . . .\u2227Km (m \u2265 0) is a rule in P such that A is unifiable with H via a most general unifier \u03b8 [38]. Then\nA \u2227Q \u03b8\u2212\u2192 (K1 \u2227 . . . \u2227Km \u2227Q)\u03b8.\n(N) Let \u00acA \u2227 Q be a query, where A is a ground atom. Suppose that A fails. Then \u00acA \u2227Q \u2212\u2192 Q, where is the identity substitution.\nNote that in the definition of a derivation we assume the left-to-right selection rule for literals. Note also that, in rule (N) the one-step derivation from \u00acA \u2227Q refers to the set of all derivations from A (to show that A fails). However, this definition is well-founded because the program P is stratified. We say that a query Q is generable from a query Q0 if there exists either a derivation Q0 \u03b81\u2212\u2192 . . . \u03b8n\u2212\u2192 Q or a derivation Q0\n\u03b81\u2212\u2192 . . . \u03b8n\u2212\u2192 \u00acA\u2227Qn and Q is generable from A. An answer for a query Q0 is a substitution \u03b8 such that there exists a successful derivation Q0 \u03b81\u2212\u2192 . . . \u03b8n\u2212\u2192 true and \u03b8 is the restriction of the composition \u03b81 . . . \u03b8n to the variables occurring in Q0. A query Q0 flounders if there exists a query Q generable from Q0 such that the leftmost literal of Q is a non ground negated atom.\nThe operational semantics is sound and complete with respect to the perfect model semantics for queries that do not flounder. Indeed, it can be shown that (see, for instance, [50, 2]), given a program P and an atom A0 that does not flounder with respect to P , then: (1) if A0 succeeds with answer \u03b8, then every ground instance of A0\u03b8 belongs to Perf(P ), and (2) if A0\u03b8 belongs to Perf(P ) for some substitution \u03b8, then A0 succeeds with an answer which is more general than \u03b8.\nThe definition of a derivation given above is quite abstract and not fully constructive. In particular, the application of rule (N) requires to test that an atom has no successful derivations, and this property is undecidable in the general case. Thus, an effective query evaluation strategy depends on the concrete way derivations are constructed.\nA well-known difficulty of the evaluation strategy based on depth-first search is that infinite derivations may be constructed, even in cases where a finite set of atoms (modulo variants) is derived from a given initial query. In particular, this nonterminating behavior can occur for stratified Datalog programs, that is, function free stratified programs.\nIn order to avoid this difficulty, in this paper we adopt SLG-resolution, a query evaluation mechanism that implements SLD resolution with Negation as Failure by means of tabling [14]. During the construction of the derivations for a given atom A0, a table is maintained to record the answers to A0 and to the atoms generated from A0. The tabled answers are used the next time an atom is generated, and hence no atom is evaluated more than once. Thus, SLG-resolution is able to compute in finite time all answers to a query, if a finite set of atoms is generated and a finite set of answers for those atoms exists. In particular, SLG-resolution always terminates and is able to compute all answers for queries to stratified Datalog programs."}, {"heading": "3 Rule-based Representation of BP Schemas", "text": "In this section we introduce a formal representation of business processes by means of the notion of Business Process Schema (BPS). A BPS, its meta-model, and its procedural (or behavioral) semantics will all be specified by sets of rules, for which we adopt the standard notation and semantics of LP (see Section 2.3)."}, {"heading": "3.1 Introducing BPAL", "text": "The Business Process Abstract Language (BPAL) introduces a language conceived to provide a declarative modeling method capable of fully capturing procedural knowledge in a business process. BPAL constructs are common to the most used and widely accepted BP modeling languages (e.g., BPMN [46], UML activity diagrams [47], EPC [33]) and, in particular, it is based on the BPMN 2.0 specification [46].\nFormally, a (set of) BPS(s) B is specified by a set of ground facts of the form p(c1, . . . , cn), where c1, . . . , cn are constants denoting flow elements (e.g., activities, events, and gateways) and p is a predicate symbol. In Table 3 we list some of the BPAL predicates, and in Table 4 we exemplify their usage reporting the translation of the Handle Order process (ho for short) depicted in Figure 1 as a BPAL BPS. An extended discussion can be found in [16, 55].\nOur formalization also includes in B a set of rules that represents the meta-model, defining i) hierarchical relationships among the BPAL predicates, e.g., activity(x)\u2190 task(x); ii) disjointness relationships among BPAL elements, e.g., \u22a5 \u2190 activity(x)\u2227 event(x); iii) structural properties which regard a BPS as a directed graph, where edges correspond to sequence and item flow relations. A first set of structural properties represents constraints that should be verified by a well-formed BPS, i.e., syntactically correct BPS: (1) every process is assigned to a unique start event and to a unique end event; (2) every flow element occurs on a path from the start event to the end event; (3) start events have no predecessors and end events have no successors; (4) branch gateways have exactly one predecessor and at least two successors, while merge gateways have at least two predecessors and exactly one successor; (5) activities and intermediate events have exactly one predecessor and one successor; (6) there are no cycles in the hierarchy of compound activities.\nFinally, other meta-model properties are related to the notions of path and reachability between flow elements, such as the following ones, which will be used in the sequel: seq+(E1, E2, P ), representing the transitive closure of the sequence flow relation, and n reachable(E1, E2, E3, P ), which holds if there is a path in P between E1 and E2 not including E3, i.e.: n reachable(X,Y,N, P )\u2190 seq(X,Y, P ) \u2227 \u00acY = N n reachable(X,Y,N, P )\u2190 seq(X,Z, P ) \u2227 \u00acZ = N \u2227 n reachable(Z, Y,N, P )\nWith respect to the framework introduced in [16, 55], here we consider unstructured cyclic workflows whose behavioral semantics will be introduced in the following."}, {"heading": "3.2 Behavioral Semantics", "text": "Now we present a formal definition of the behavioral semantics, or enactment, of a BPS, by following an approach inspired by the Fluent Calculus, a well-known calculus for action and change (see [61] for an introduction), which is formalized in Logic Programming.\nIn the Fluent Calculus, the state of the world is represented as a collection of fluents, i.e., terms representing atomic properties that hold at a given instant of time. An action, also represented as a term, may cause a change of state, i.e., an update of the collection of fluents associated with it. Finally, a plan is a sequence of actions that leads from the initial to the final state. For states we use set notation (here we depart from [61], where an associative-commutative operator is used for representing collections of fluents). A fluent is an expression of the form f(a1, . . . , an), where f is a fluent symbol and a1, . . . , an are constants or variables. In order to model the behavior of a BPS, we represent states as finite sets of ground fluents. We take a closed-world interpretation of states, that is, we assume that a fluent F , different from true, holds in a state S iff F \u2208 S. Our set-based representation of states relies on the assumption that the BPS is safe, that is, during its enactment there are no concurrent executions of the same flow element [64]. This assumption enforces that the set of states reachable by a given BPS is finite. A fluent expression is built inductively from fluents, the binary function symbol and, and the unary function symbol not. The satisfaction relation assigns a truth value to a fluent expression with respect to a state. This relation is encoded by a predicate holds(F, S), which holds if the fluent expression F is true in the state S. We also introduce a constant symbol true, such that holds(true, S) holds for every state S. Accordingly to the closed-world interpretation given to states, the satisfaction relation is defined by the following rules:\nholds(F, S)\u2190 F = true holds(F, S)\u2190 F \u2208 S holds(not(F ), S)\u2190 \u00acholds(F, S) holds(and(F1, F2), S)\u2190 holds(F1, S) \u2227 holds(F2, S) Note that, by the perfect model semantics, reflecting the closed-world assumption, for any fluent F different from true, not(F ) holds in a state S iff F 6\u2208 S.\nWe will consider the following two kinds of fluents:\n\u2022 cf(E1, E2, P ), which means that the flow element E1 has been executed and the successor flow element E2 is waiting for execution, during the enactment of the process P (cf stands for control flow);\n\u2022 en(A,P ), which means that the activity A is being executed during the enactment of the process P (en stands for enacting).\nTo clarify our terminology note that, when a flow element E2 is waiting for execution, E2 might not be enabled to execute, because other conditions need to be fulfilled, such as those depending on the synchronization with other flow elements (see, in particular, the semantics of merging behaviors below).\nWe assume that the execution of an activity has a beginning and a completion (although we do not associate a duration with activity execution), while the other flow elements execute instantaneously. Thus, we will consider two kinds of actions: begin(A) which starts the execution of an activity A, and complete(E), which represents the completion of the execution of a flow element E (possibly, an activity). The change of state determined by the execution of an action will be formalized by a relation result(S1, A, S2), which holds if action A can be executed in state S1 leading to state S2. For defining the relation result(S1, A, S2) the following auxiliary predicates will be used: (i) update(S1, T, U, S2), which holds if S2 = (S1 \u2212 T ) \u222a U , where S1, T, U, and S2 are sets of fluents, and (ii) setof(F,C, S), which holds if S is the set of ground instances of fluent F such that condition C holds.\nThe relation r(S1, S2) holds if a state S2 is immediately reachable from a state S1, that is, some action A can be executed in state S1 leading to state S2: r(S1, S2)\u2190 result(S1, A, S2) We say that a state S2 is reachable from a state S1 if there is a finite, possibly empty, sequence of actions from S1 to S2, that is, reachable state(S1, S2) holds, where the relation reachable state is is the reflexive-transitive closure of r.\nIn the rest of this section we present a fluent-based formalization of the behavioral semantics of a BPS as a set of rules T , partially reported in Table 5. The proposed formal semantics is focused on a core of the BPMN language and it mainly refers to its semantics, as described (informally) in the most recent specification of the language [46]. Most of the constructs considered here (e.g., parallel or exclusive branching/merging) have the same interpretation in most workflow languages. However, when different interpretations are given, e.g., in the case of inclusive merge, we stick to the BPMN one."}, {"heading": "3.2.1 Activity and Event Execution", "text": "The enactment of a process P begins with the execution of the associated start event E in a state where the fluent cf(start, E, P ) holds, being start a reserved constant. After the execution of the start event, its unique successor waits for execution (Rule E1). The\nexecution of an end event leads to the final state of a process execution, in which the fluent cf(E, end, P ) holds, where E is the end event associated with the process P and end is a reserved constant (Rule E2).\nAccording to the informal semantics of BPMN, intermediate events are intended as instantaneous patterns of behavior that are registered at a given time point. Thus, we formally model the execution of an intermediate event as a single state transition, as defined in Rule E3. Intermediate events in BPMN can also be attached to activity boundaries to model exceptional flows. Upon occurrence of an exception, the execution of the activity is interrupted, and the control flow moves along the sequence flow that leaves the event (Rule E4).\nThe execution of an activity is enabled to begin after the completion of its unique predecessor flow element. The effects of the execution of an activity vary depending on its type (i.e., atomic task or compound activity). The beginning of an atomic task A is modeled by adding the en(A,P ) fluent to the state (Rule A1). At the completion of A, the en(A,P ) fluent is removed and the control flow moves on to the unique successor of A (Rule A2). The execution of a compound activity, whose internal structure is defined as a process itself, begins by enabling the execution of the associated start event (Rule A3), and completes after the execution of the associated end event (Rule A4)."}, {"heading": "3.2.2 Branching Behaviors", "text": "When a branch gateway is executed, a subset of its successors is selected for execution. We consider here exclusive, inclusive, and parallel branch gateways.\nAn exclusive branch leads to the execution of exactly one successor (Rule B1), while an inclusive branch leads to the concurrent execution of a non-empty subset of its successors (Rule B2). The set of successors of exclusive or inclusive decision points may depend on guards, i.e., conditions that usually take the form of tests on the value of the items that are passed between the activities. While Rules B1-B2 formalize a nondeterministic choice among the successors of a decision point, in Section 4.3 guard expressions will be included in the framework in the form of fluent expressions whose truth value is tested with respect to the current state. Finally, a parallel branch leads to the concurrent execution of all its successors (Rule B3)."}, {"heading": "3.2.3 Merging Behaviors", "text": "An exclusive merge can be executed whenever at least one of its predecessors has been executed (Rule X1).\nFor the inclusive merge several operational semantics have been proposed, due to the complexity of its non-local semantics (see e.g., [33, 65]). An inclusive merge is supposed to be able to synchronize a varying number of threads, i.e., it is executed only when n(\u2265 1) predecessors have been executed and no other will be eventually executed. Here we refer to the semantics described in [65] adopted by BPMN, stating that (Rule O1) an inclusive merge M can be executed if the following two conditions hold (Rules O2, O3):\n(1) at least one of its predecessors has been executed,\n(2) for each non-executed predecessor X, there is no flow element U which is waiting for execution and is upstream X. The notion of being upstream captures the fact that U may lead to the execution of X, and is defined as follows. A flow element U is\nupstream X if (Rules O4, O5): a) there is a path from U to X not including M, and b) there is no path from U to an executed predecessor of M not including M.\nFinally, a parallel merge can be executed if all its predecessors have been executed as defined in Rule P1, where exists non executed pred(M,P, S1) holds if there exists no predecessor of M which has not been executed in state S1 (Rule P2)."}, {"heading": "3.2.4 Item Flow", "text": "BP modeling must be able to represent the physical and the information items that are produced and consumed by the various activities during the execution of a process. For the formalization of the item flow semantics, we commit to the BPMN standard, where the so-called data objects are used to store information created and read by activities.\nIn our approach items are essentially regarded as variables, and hence there is a single instance of a given item any time during the execution that may be (over-)written by some activity. We consider two main types of relations between activities and items. First of all, an activity may use a particular item (input relation). This implies that the item is\nexpected to hold a value before the activity is executed. Second, an activity may produce a particular value (output relation), causing the item to get a new value. If it has no value yet, it is created, otherwise it is overwritten. It is worth noting that the item flow is not necessarily imposed over the control flow, but they interact for the definition of the process behavior. For instance, an activity expecting a value from a given item, may also cause a deadlock if this condition is never satisfied.\nThe item flow is modeled through the fluent wrtn(A, It, P ) (wrtn stands for \u201cwritten\u201d) representing the situation in which the item It has been produced by the activity A in the enactment of the process P. In order to handle item manipulation, the semantics of task enactment (Rules A1, A2) is extended as follows:\nresult(S1, begin(A), S2)\u2190 task(A) \u2227 holds(cf(X,A, P ), S1) \u2227 \u00acblocked input(A,P, S1) \u2227 input(A, It, P ) \u2227 update(S1, {cf(X,A, P )}, {en(A,P )}, S2) result(S1, complete(A), S2)\u2190 task(A) \u2227 holds(en(A,P ), S1) \u2227 seq(A, Y, P ) \u2227 setof(wrtn(A, It, P ), output(A, It, P ), U) \u2227 update(S1, {en(A,P )}, {cf(A, Y, P )} \u222a U, S2)\nwhere blocked input(A,P, S1) holds if, at a state S1 during the enactment of process P , there exists some input item It for A that has not been produced. Thus,\nblocked input(A,P, S1)\u2190 input(A, It, P ) \u2227 \u00acupdated item(It, P, S1) updated item(It, P, S1)\u2190 holds(wrtn(B, It, P ), S1)) The case of compound activities can be treated in a similar way and is omitted."}, {"heading": "4 Semantic Annotation", "text": "In the previous section we have shown how a procedural representation of a BPS can be modeled in our rule-based framework as an activity workflow. However, not all the relevant knowledge regarding process enactment is captured by a workflow model, which defines the planned order of operations but does not provide an explicit representation of the domain knowledge regarding the entities involved in such a process, i.e., the business environment in which processes are carried out.\nSimilarly to proposals like Semantic BPM [32] and Semantic Web Services [22], we will make use of semantic annotations to enrich the procedural knowledge specified by a BPS with domain knowledge expressed in terms of a given business reference ontology. Annotations provide two kinds of ontology-based information: (i) formal definitions of the basic entities involved in a process (e.g., activities, actors, items) to specify their meaning in an unambiguous way (terminological annotations), and (ii) specifications of preconditions and effects of the enactment of flow elements (functional annotations)."}, {"heading": "4.1 Reference Ontology", "text": "A business reference ontology is intended to capture the semantics of a business scenario in terms of the relevant vocabulary plus a set of axioms (TBox) that define the intended meaning of the vocabulary terms. In order to represent the semantic annotations of a BPAL BPS in a uniform way, we will consider ontologies falling within the OWL 2 RL profile (See Section 2.2), and hence expressible as sets of rules. An OWL 2 RL ontology is represented as a set O of rules, consisting of a set of facts of the form t(s, p, o), called triples, encoding the specific OWL TBox, along with the rules that are common to all OWL 2 RL ontologies, such as the ones of Table 2.\nIn Table 6 we show an example of business reference ontology for the annotation of the Handle Order process depicted in Figure 1. For the sake of conciseness and clarity, the axioms of ontology are represented as DL expressions, instead of sets of triples. The translation into triple form can be done automatically as shown in [28, 59]."}, {"heading": "4.2 Terminological Annotation", "text": "A terminological annotation associates elements of a BPS with concepts of a reference ontology, in order to describe the former in terms of a suitable conceptualization of the underlying business domain provided by the latter. This association is specified by a set of OWL assertions of the form BpsEl : \u2203termRef.Concept, where:\n\u2022 BpsEl is an element of a BPS; \u2022 Concept is either i) a named concept defined in the ontology, e.g., Purchase Order, or\nii) a complex concept, defined by a class expression, e.g., Rejecting u \u2203content.Purchase Order ;\n\u2022 termRef is an OWL property name.\nWe do not assume that every BPS element is annotated, nor that every concept is the meaning associated with some BPS element. Furthermore, different BPS elements could be annotated with respect to the same concept, to provide an alignment of the different terminologies and conceptualizations used in different BP schemas. E.g., the activities bill client and issue invoice occurring in different processes may actually refer to the same notion, suitably defined in the ontology.\nExample 1. Examples of annotations related to the Handle Order process (Figure 1) are listed below. The item order is annotated with the Purchase Order concept, while the participant shipper with the concept Carrier, which can be either an internal Department or a Business Partner. A sales clerk is defined as an Employee, which is part of the Order Mgt Dpt . The task delivering is defined as a Transportation related to some sort of Product. Finally, notify rejection represents a Communication with a Corporate Customer, and in particular, a Refuse related to Purchase Order.\norder : \u2203termRef.Purchase Order shipper : \u2203termRef.Carrier sales clerk : \u2203termRef.(Employee u \u2203member.Order Mgt Dpt) delivering : \u2203termRef.(Transportation u \u2203related.Product) notify rejection : \u2203termRef.(Refuse u \u2203content.Purchase Order u\n\u2203destination.Corporate Customer)"}, {"heading": "4.3 Functional Annotation", "text": "By using the ontology vocabulary and axioms, we define semantic annotations for modeling the behavior of individual process elements in terms of preconditions under which a flow element can be executed, and effects on the state of the world after its execution. Preconditions and effects, collectively called functional annotations, can be used, for instance, to model input/output relations of activities with business entities. Fluents can represent the properties of a business entity affected by the execution of an activity at a given time during the execution of the process. A precondition specifies the properties a business entity must posses when an activity is enabled to start, and an effect specifies the properties of a business entity after having completed an activity. These aspects are only partially supported by current BP modeling notations, such as BPMN, in terms of data objects representing information storage during the BP enactment.\nFunctional annotations are formulated by means of the following relations:\n\u2022 pre(A,C, P ), which specifies a fluent expression C, called enabling condition, that must hold to execute an element A in the process P ;\n\u2022 eff(A,Q,E\u2212, E+, P ), which specifies the set E\u2212 of fluents, called negative effects, that do not hold after the execution of A and the set of fluents E+, called positive effects, that hold after the execution of A in the process P . Q is a fluent expression that must hold to complete the activity A. We assume that E\u2212 and E+ are disjoint sets of fluents, and the variables occurring in them also occur in Q.\n\u2022 c seq(G,B, Y, P ), which models a conditional sequence flow used to select the set of successors of decision points. G is a guard associated to the exclusive or inclusive branch gateway B, i.e., a fluent expressions that must hold in order to enable the flow element Y , successor of B in the process P . We also have the rule seq(B, Y, P ) \u2190 c seq(G,B, Y, P ).\nThe enabling conditions, the guards and the negative and positive effects occurring in functional annotations are fluent expressions built from fluents of the form tf (s, p, o), corresponding to the OWL statement t(s, p, o), where we adopt the usual rdf, rdfs, and owl prefixes for names in the OWL vocabulary, and the bro prefix for names relative to our specific examples. We assume that the fluents appearing in functional annotations are\neither of the form tf (a, rdf:type, c), corresponding to the unary atom c(a), or of the form tf (a, p, b), corresponding to the binary atom p(a, b), where a and c are individuals, while c and p are concepts and properties, respectively, defined in the reference ontology O. Thus, fluents correspond to assertions about individuals, i.e., assertions belonging to the ABox of the ontology, and hence the ABox may change during process enactment due to the effects specified by the functional annotations, while O, providing the ontology definitions and axioms, i.e., the TBox of the ontology, does not change.\nLet us now present an example of specification of functional annotations. In particular, our example shows nondeterministic effects, that is, a case where a flow element A is associated with more than one pair (E\u2212, E+) of negative and positive effects.\nExample 2. Consider again the Handle Order process shown in Figure 1. After the execution of create order, a purchase order is issued. This order can be approved or canceled upon execution of the activities accept order and cancel order, respectively. Depending on the inventory capacity checked during the check inventory task, the requisition of parts performed by an external supplier is performed (parts auction). Once that all the order parts are available, the order can be fulfilled and an invoice is associated with the order. This behavior is specified by the functional annotations reported in Table 7."}, {"heading": "4.3.1 Formal Semantics of Functional Annotations", "text": "In the presence of functional annotations, the enactment of a BPS is modeled by extending the result relation so as to take into account the pre and eff relations. We only consider the case of task execution. The other cases are similar and will be omitted.\nGiven a state S1, a flow element A can be enacted if A is waiting for execution according to the control flow semantics, and its enabling condition C is satisfied, i.e., holds(C, S1) is true. Moreover, given an annotation eff(A,Q,E\u2212, E+, P ), when A is completed in a given state S1, then a new state S2 is obtained by taking out from S1 the set E\n\u2212 of fluents and then adding the set E+ of fluents. The execution of tasks considering functional annotations is then defined as:\nresult(S1, begin(A), S2) \u2190 task(A)\u2227 holds(cf(B,A, P ), S1) \u2227 pre(A,C, P ) \u2227 holds(C, S1)\u2227 update(S1, {cf(B,A, P )}, {en(A,P )}, S2) result(S1, complete(A), S2)\u2190 task(A)\u2227 holds(en(A,P ), S1) \u2227 eff(A,Q,E\u2212, E+, P )\u2227 holds(Q,S1) \u2227 seq(A,B, P ) \u2227 update(S1, {en(A,P )} \u222a E\u2212, {cf(A,B, P )} \u222a E+, S2) Note that, since the variables occurring in E+ and E\u2212 are included in those of Q , the evaluation of holds(Q,S1) binds these variables to constants.\nSimilarly, the semantics of inclusive and exclusive branches is extended to evaluate the associated guard expressions, in order to determine the set of successors to be enabled. The execution of decision points is then defined as:\nresult(S1, complete(B), S2)\u2190 inc branch(B) \u2227 holds(cf(A,B, P ), S1)\u2227 setof(cf(B,C, P ), (c seq(G,B,C, P ) \u2227 holds(G,S1)),Succ)\u2227 update(I, {cf(A,B, P )},Succ, S2) result(S1, complete(B), S2)\u2190 exc branch(B) \u2227 holds(cf(A,B, P ), S1) \u2227 c seq(G,B,C, P )\u2227 holds(G,S1) \u2227 update(S1, {cf(A,B, P )}, {cf(B,C, P )}, S2)\nIn order to evaluate a statement of the form holds(tf (s, p, o), X), where tf (s, p, o) is a fluent and X is a state, the definition of the holds predicate given previously must be extended to take into account the axioms belonging to the reference ontology O. Indeed, we want that a fluent of the form tf (s, p, o) be true in state X not only if it belongs to X, but also if it can be inferred from the fluents in X and the axioms of the ontology.\nFor instance, let us consider the fluent f = tf (o, rdf:type, bro:CancelledPO). We can easily infer that f holds in a state that contains {tf (o, rdf:type, bro:CancelledPO)} (e.g., reachable after the execution of cancel order) by using the rule holds(F,X) \u2190 F \u2208 X. However, by taking into account the ontology excerpt given in Table 6, we also want to be able to infer that f holds in a state that contains {tf (o, rdf:type, bro:Purchase Order), tf (o, bro:related, pl), tf (pl, rdf:type, bro:UnavailablePL)} (e.g., a state reachable after the execution of parts auction).\nIn our framework the inference of new fluents from fluents belonging to states is performed by including extra rules derived by translating the OWL 2 RL/RDF entailment rules as follows: every triple of the form t(s, p, o), where s refers to an individual, is replaced by the atom holds(tf (s, p, o), X). Below we show exemplary rules (in particular, those required by our running example) for concept subsumption (1), role subsumption (2), domain restriction (3), transitive property (4), concept intersection2 (5), existentially quantified formulae (6), and concept disjointness (7) . We refer the reader to [43] for the complete list of rules and the discussion of the OWL 2 RL rule-based semantics.\n2Without loss of generality, unlike [43], we encode binary intersection instead of a general n-ary operator.\n1. holds(tf (S, rdf:type, C), X)\u2190 holds(tf (S, rdf:type, B), X) \u2227 t(B, rdfs:subClassOf, C) 2. holds(tf (S, P,O), X)\u2190 holds(tf (S, P1, O), X) \u2227 t(P1, rdfs:subPropertyOf, P ) 3. holds(tf (S, rdf:type, C), X)\u2190 holds(tf (S, P,O), X) \u2227 t(P, rdfs:domain, C) 4. holds(tf (S, P,O), X)\u2190 holds(tf (S, P,O1), X) \u2227 holds(tf (O1, P,O), X) \u2227\nt(P, rdf:type, owl:TransitiveProperty) 5. holds(tf (S, rdf:type, C), X)\u2190 t(C, owl:intersectionOf, (C1, C2)) \u2227\nholds(tf (S, rdf:type, C1), X) \u2227 holds(tf (S, rdf:type, C2), X) 6. holds(tf (S, rdf:type, C), X) \u2190 t(S, owl:someValuesFrom,R) \u2227 t(R, owl:onProperty, P ) \u2227\nholds(and(tf (S, P, I), tf (I, rdf:type, R)), X) 7. holds(false, X)\u2190 holds(tf (I1, rdf:type, A), X) \u2227 holds(tf (I2, rdf:type, B), X) \u2227\nt(A, owl:disjointWith, B)\nwhere false is a term representing \u22a5. We denote by A the set of rules that encode the terminological and functional annotations, that is, (1) the OWL assertions of the form BpsEl : \u2203termRef.Concept; (2) the facts defining the relations pre(A,C, P ), eff(A,Q,E\u2212, E+, P ), c seq(G,B, Y, P ); (3) the rules for evaluating holds(tf (s, p, o), X) atoms (such as rules 1\u20137 above)."}, {"heading": "4.3.2 Change, Ramification and Consistency", "text": "The logical formalization of activity preconditions and effects given above has to be compared with various solutions to the Frame and Ramification problems proposed by the various AI formalisms for representing action and change.\nThe Frame Problem was formulated in [40] as the problem of \u201cexpressing a dynamical domain in logic without explicitly specifying which conditions are not affected by an action\u201d. Basically, it is concerned with representational issues, related to the effort needed to specify non-effects of actions, and inferential issues, related to the effort needed to actually compute these non-effects.\nThe Fluent Calculus addresses both the representational and inferential aspects of the Frame Problem [62] by modeling change as the difference between two states, caused by actions that deterministically result in a bounded number of direct (positive and negative) effects. These effects are captured by state update axioms specifying the fluents that are added or removed from a state. The rules defining the result relation introduced in Section 3.2 can be viewed as a specialized form of state update axioms.\nThe Ramification Problem [26] is the problem of representing and inferring information about indirect effects of actions. Indirect effects are not explicitly represented in action specifications, but follow from general laws (domain axioms) describing dependencies among fluents. In our framework, general laws are specified in the reference ontology TBox, whose axioms, as discussed in the previous section, are used in the derivation of additional tf fluents from those belonging to a given state. Indirect effects may lead to undesired consequences when performing state update. For instance, let us consider the fluent f = tf (o, rdf:type, bro:FulfilledPO). If we consider the ontology O given in Table 6, we can infer that f holds in a state S which contains tf (o, rdf:type, bro:Purchase Order), tf (o, bro:related, i), and tf (i, rdf:type, bro:Invoice). Now, assume that the set of negative effects of the subsequent activity a includes the fluent f . Then, after the state update determined by a, f still holds, in contrast with the intended meaning of negative effects.\nMany approaches have been proposed to handle such a situation. Some of them are based on the computation of all the possible states si caused by the execution of action a in state s, such that: i) they comply with the domain axioms and the negative effects of a,\nii) they differ minimally from s (see, e.g., the Possible Model Approach - PMA [67]). This approach introduces a nondeterministic behavior in the state update that appears to be in contrast with the strong prescriptive nature of procedural BP models. Considering again the example above, the execution of a according to the PMA would result in three states: s\u2212{tf (o, rdf:type, bro:Order)}, s\u2212{tf (o, bro:related, i)}, and s\u2212{tf (i, rdf:type, bro:Invoice)}.\nAnother solution proposed in the context of the Fluent Calculus, is based on causal propagations regulated by causal relationships [60], which specify how indirect effects are derived from direct effects and domain axioms. Causal relationships are then included in the state update axioms and applied until a fix-point is reached. This approach requires an additional formalism for the definition of causal relationships, and the burden for users of providing additional domain-dependent assertions, which cannot be represented within the ontology.\nHere we follow a different approach based on the following consistency condition, which has to be enforced by every reachable state of a BPS: (i) no contradiction can be derived from the fluents belonging to the state by using the state independent axioms of the reference ontology, and (ii) no negative effect of an activity holds after its execution. Formally, we say that eff is consistent with process P if, for every flow element A and states S1, S2, the following implication is true:\nIf S1 is reachable from the initial state of P and the relations result(S1, complete(A), S2) and eff(A,E\u2212, E+, P ) hold, Then O\u222aA\u222a{\u00acholds(false, S2)} is consistent and, for all F \u2208 E\u2212, O\u222aA\u222a{\u00acholds(F, S2)} is consistent.\nThis condition takes into account that, since O \u222a A is a definite logic program, it only allows the derivation of positive indirect effects, and thus, for all F \u2208 E+, O \u222a A \u222a {holds(F, S2)} is consistent. We will show in Section 6 how the consistency condition can be checked by using the rule-based temporal logic we will present in the next section.\nFrom a pragmatic perspective, the modeler is asked to refine the annotation of a BPS until a consistent description of the effects is achieved, possibly disambiguating the situations where underspecified effects may lead to hidden flaws."}, {"heading": "5 Temporal Reasoning", "text": "In order to provide a general verification mechanism for behavioral properties, in this section we propose a model checking methodology based on a formalization of the temporal logic CTL (Computation Tree Logic, see [15] for a comprehensive overview) as a set of rules. Model checking is a widely accepted technique for the formal verification of BP schemas, as their execution semantics is usually defined in terms of states and state transitions, and hence the use of temporal logics for the specification and verification of properties is a very natural choice [24, 37].\nCTL is a propositional temporal logic introduced for reasoning about the behavior of reactive systems. The behavior is represented as the tree of states that the system can reach, and each path of this tree is called a computation path. CTL formulas are built from: the constants true and false; a given set Elem of elementary properties; the connectives: \u00ac (\u2018not\u2019) and \u2227 (\u2018and\u2019); the linear-time operators along a computation path: G (\u2018globally\u2019 or \u2018always\u2019), F (\u2018finally\u2019 or \u2018sometimes\u2019), X (\u2018next-time\u2019), and U (\u2018until\u2019); the quantifiers over computation paths: A (\u2018for all paths\u2019) and E (\u2018for some path\u2019). The abstract syntax of CTL is defined as follows.\nDefinition 1 (CTL formulas). A CTL formula F has the following syntax:\nF ::=e | true | false | \u00acF | F1 \u2227 F2 | EX(F ) | EU(F1, F2) | EG(F ) where e belongs to a given set Elem of elementary properties.\nOther operators can be defined in terms of the ones given in Definition 1, e.g., EF(F ) \u2261 EU(true, F ) and AG(F ) \u2261 \u00acEF(\u00acF ) [15].\nUsually, the semantics of CTL formulas is defined by introducing a Kripke structure K, which represents the state space and the state transition relation, and by defining the satisfaction relation K, s |= F , which denotes that a formula F holds in a state s of K [15]. In order to verify temporal properties of the behavior of a BPS P , we define a Kripke structure associated with P . The states are defined as finite sets of ground fluents and the state transition relation is based on the immediate reachability relation r between states defined in Section 3.2. The Kripke structure and the satisfaction relation will be encoded by sets of rules, hence providing a uniform framework for reasoning about the ontological properties and the behavioral properties of business processes.\nA Kripke structure is a four-tuple K = \u3008S, I,R,L\u3009 defined as follows.\n1. S is the finite set of all states, where a state is a finite set of ground fluents.\n2. I is the initial state of BPS P , encoded by the rule:\ninitial(I, P )\u2190 bp(P, S,E) \u2227 I = {cf(start, S, P )}\n3. R is the transition relation, which is defined as follows: R(X,Y ) holds iff r(X,Y ) holds, where r is the predicate defined in Section 3.2, i.e., R(X,Y ) holds iff there exists an action A that can be executed in state X leading to state Y .\n4. L is the labeling function, which associates with each state X the set of fluents F such that O \u222aA |= holds(F,X).\nIn the definition of Kripke structure given in [15], the transition relation R is assumed to be total, that is, every state S1 has at least one successor state S2 for which R(S1, S2) holds. This assumption is justified by the fact that reactive systems can be thought as ever running processes. However, this assumption is not realistic in the case of business processes, for which there is always at least one state with no successors, namely one where the end event of a BPS has been completed. For this reason the semantics of the temporal operators given in [15], which refers to infinite paths of the Kripke structure, is suitably changed here, according to [3], by taking into consideration maximal paths, i.e., paths that are either infinite or end with a state that has no successors, called a sink.\nDefinition 2 (Maximal Path). A maximal path in K starting from a state S0 is either\n\u2022 an infinite sequence of states S0 S1 . . . such that SiRSi+1, for every i\u22650; or \u2022 a finite sequence of states S0 S1 . . . Sk, with k \u2265 0, such that:\n1. SiRSi+1, for every 0 \u2264 i < k, and 2. there exists no state Sk+1 \u2208 S such that SkRSk+1.\nThe semantics of CTL operators can be encoded by extending the definition of the predicate holds. Below we list the semantics of those operators and the corresponding rule-based formalization.\nEX(F ) holds in state S0 if F holds in a successor state of S0: holds(ex (F ), S0)\u2190 r(S0, S1) \u2227 holds(F, S1) EU(F1, F2) holds in state S0 if there exists a maximal path \u03c0: S0 S1 . . . such that for some Sn in \u03c0 we have that F2 holds in Sn and, for j = 0, . . . , n\u22121, F1 holds in Sj : holds(eu(F1, F2), S0)\u2190 holds(F2, S0) holds(eu(F1, F2), S0)\u2190 holds(F1, S0) \u2227 r(S0, S1) \u2227 holds(eu(F1, F2), S1) EG(F ) holds in a state S0 if there exists a maximal path \u03c0 starting from S0 such that F holds in each state of \u03c0. Since the set of states is finite, EG(F ) holds in S0 if there exists a finite path S0 . . . Sk such that, for i = 0, . . . , k, F holds in Si, and either (1) Sj = Sk, for some 0 \u2264 j < k, or (2) Sk is a sink state. Thus, the semantics of the operator EG is encoded by the following rules:\nholds(eg(F ), S0)\u2190 fpath(F, S0, S0) holds(eg(F ), S0)\u2190 holds(F, S0) \u2227 r(S0, S1) \u2227 holds(eg(F ), S1) holds(eg(F ), S0)\u2190 sink(S0) \u2227 holds(F, S0) where: (i) the predicate fpath(F,X,X) holds if there exists a path from X to X itself, consisting of at least one r arc, such that F holds in every state on the path:\nfpath(F,X, Y )\u2190 holds(F,X) \u2227 r(X,Y ) fpath(F,X,Z)\u2190 holds(F,X) \u2227 r(X,Y ) \u2227 fpath(F, Y, Z) and (ii) the predicate sink(X) holds if X has no successor state.\nFinally, the following rules define the properties characterizing the initial and the final state of a process:\nholds(F, s0(P ))\u2190 initial(I, P ) \u2227 holds(F, I) holds(final(P ), X)\u2190 bp(P, S,E) \u2227 holds(cf(E, end, P ), X) The rules defining the semantics of the operator EG are similar to the constraint logic programming definition proposed in [45]. However, as already mentioned, in this paper we refer to the notion of maximal path instead of infinite path. Similarly to [45], our definition of the semantics of EG avoids the introduction of greatest fixed points of operators on sets of states which are often required by the approach described in [15]. Indeed, the rules defining holds(eg(F ), S0) are interpreted according to the usual least fixpoint semantics (i.e., the least Herbrand model [38]).\nThe encoding of the satisfaction relation for other CTL operators, e.g, EF and AG, follows from the equivalences defining them [15]. It is worth noting that in some special cases the assumption that paths are maximal, but not necessarily infinite, matters [3]. For instance, if S0 is a sink state, then holds(ag(F ), S0) is true iff holds(F, S0) is true, since the only maximal path starting from S0 is the one constituted by S0 only. Finally, we would like to note that the definition of the CTL semantics given here is equivalent to the one in [15] in the presence of infinite computation paths only."}, {"heading": "6 Reasoning Services", "text": "Our rule-based framework supports several reasoning services that can combine complex knowledge about business processes from different perspectives, such as the workflow structure, the ontological description, and the behavioral semantics. In this section we will illustrate three such services: verification, querying, and trace compliance checking.\nLet us consider the following sets of rules: (1) B, representing a set of BP schemas and the BP meta-model defined in Section 3.1, (2) T , defining the behavioral semantics\npresented in Section 3.2, (3) O, collecting the OWL triples and rules that represent the business reference ontology defined in Section 4.1, (4) A, encoding the annotations defined in Sections 4.2 and 4.3, and (5) CTL, defining the semantics of CTL presented in Section 5.\nLet KB be the set of rules B \u222a T \u222a O \u222a A \u222a CTL. KB is called a Business Process Knowledge Base (BPKB). It is straightforward to show that KB is stratified, and hence its semantics is unambiguously defined by its perfect model Perf(KB) (see Section 2.3)."}, {"heading": "6.1 Verification", "text": "In the following we present some examples of properties that can be specified and verified in our framework. A property is specified by a predicate prop defined by a rule C in terms of the predicates defined in KB. The verification task is performed by checking whether or not prop \u2208 Perf(KB \u222a {C}). (1) A very relevant behavioral property of a BP p is that from any reachable state, it is possible to complete the process, i.e., reach the final state. This property, also known as option to complete [64], can be specified by the following rule, stating that the property opt com holds if the CTL property AG(EF(final(p))) holds in the initial state of p:\nopt com\u2190 holds(ag(ef (final(p))), s0(p)) (2) Temporal queries allow us to verify the consistency condition for effects introduced in Section 4.3. In particular, given a BPS p, inconsistencies due to the violation of some integrity constraint defined in the ontology by rules of the form \u22a5 \u2190 G (e.g., concept disjointness) can be verified by defining the inconsistency property as follows:\ninconsistency\u2190 holds(ef (false), s0(p)) (3) Another relevant property of a BPS is executability [66], according to which no activity reached by the control flow should be unable to execute due to some unsatisfied enabling condition. In our framework we can specify non-executability by defining a predicate n exec which holds if it can be reached a state where some activity A is waiting for execution but is not possible to start its enactment.\nn exec\u2190 holds(ef (and(cf(A1, A, p),not(ex (en(A, p))))), s0(p)) \u2227 activity(A) (4) Temporal queries can also be used for the verification of compliance rules, i.e., directives expressing internal policies and regulations aimed at specifying the way an enterprise operates. In our Handle Order example, one such compliance rule may be that every order is eventually closed. In order to verify whether this property holds or not, we can define a noncompliance property which holds if it is possible to reach the final state of the process where, for some O, it can be inferred that O is an order which is not closed. In our example noncompliance is satisfied, and thus the compliance rule is not enforced. In particular, if the exception attached to the accept order task is triggered, the enactment continues with the notify rejection task (due to the guards associated to g1), and the order is never canceled nor fulfilled.\nnoncompliance\u2190 holds(ef (and(tf (O, rdf:type, bro:Purchase Order), and(not(tf (O, rdf:type, bro:ClosedPO)),final(p))), s0(ho))"}, {"heading": "6.2 Retrieval", "text": "The inference mechanism based on SLG-resolution can be used for computing boolean answers to ground queries, but also for computing, via unification, substitutions for variables occurring in non-ground queries. By exploiting this query answering mechanism we\ncan easily provide, besides the verification service described in the previous section, also reasoning services for the retrieval of process fragments.\nThe following queries show how process fragments can be retrieved according to different criteria. For sake of readability, we introduce the relation \u03c3(A,C) as an abbreviations for the OWL expression A : \u2203termRef.C encoding terminological annotations.\nQuery q1 computes every activity A performed by a Carrier and realizing a Transportation (e.g., delivering) ; q2 computes every decision point (exclusive branch) G occurring along a path of a BPS P delimited by two activities A and B, where the former operates on orders (e.g., create order) and the latter is included in the results of q1; finally, q3 retrieve all the activities operating on orders which precede (in every possible execution) a Transportation performed by a Carrier (e.g., create order).\nq1(A)\u2190 activity(A) \u2227 assigned(A,C, P ) \u2227 \u03c3(C, bro:Carrier) \u2227 \u03c3(A, bro:Transportation) q2(A,G,B, P )\u2190 q1(B)\u2227output(A, I, P )\u2227\u03c3(I, bro:Purchase Order)\u2227reachable(A,G, P )\u2227 reachable(G,B, P ) q3(A,B, P ) \u2190 q1(B) \u2227 output(A, I, P ) \u2227 \u03c3(I, bro:Purchase Order) \u2227 reachable(A,B, P ) \u2227 holds(not(eu(not(en(A,P )), en(B,P ))), s0(P ))"}, {"heading": "6.3 Trace Compliance", "text": "The execution of a process is modeled as an execution trace (corresponding to a plan in the Fluent Calculus), i.e., a sequence of actions of the form [act(a1), . . . , act(an)] where act is either begin or complete. The predicate trace(S1,T, S2) defined below holds if T is a sequence of actions that lead from state S1 to state S2: trace(S1, [ ], S2)\u2190 S1 = S2 trace(S1, [A|T], S2)\u2190result(S1, A, U)\u2227trace(U,T, S2)\nA correct trace T of a BPS P is a trace that leads from the initial state to the final state of P , that is:\nctrace(T, P )\u2190 initial(I, P ) \u2227 trace(I, T, Z) \u2227 holds(final(P ), Z) Execution traces are commonly stored by BPM systems as process logs, representing the evolution of the BP instances that have been enacted. The correctness of a trace t with respect to a given BPS p can be verified by evaluating a query of the form ctrace(t, p) where t is a ground list and p is a process name.\nThe rules defining the predicate ctrace can also be used to generate the correct traces of a process p that satisfy some given property. This task is performed by evaluating a query of the form ctrace(T, p) \u2227 cond(T ), where T is a free variable and cond(T ) is a property that T must enforce. For instance, we may want to generate traces where the execution of a flow element a is followed by the execution of a flow element b:\ncond(T )\u2190 concat(T1, T2, T ) \u2227 complete(a) \u2208 T1 \u2227 complete(b) \u2208 T2"}, {"heading": "7 Computational Properties", "text": "In this section we prove the soundness, completeness, and termination of query evaluation using SLG-resolution. We also provide an upper bound to the time complexity of query evaluation.\nAs mentioned in Section 2.3, the soundness and completeness of SLG-resolution with respect to the perfect model semantics is guaranteed for the class of queries that do not\nflounder. In [38] a sufficient condition ensuring that a query does not flounder is based on the notion of allowed query and rule. In particular, a query is allowed if every variable occurring in it also occurs in one of its positive literals. Similarly, a rule is allowed if every variable occurring in it also occurs in a positive literal in its body. Unfortunately, not all rules in KB are allowed in the sense of [38]. For instance, the variables F and S occurring in the rule holds(not(F ), S) \u2190 \u00acholds(F, S), do not occur in any positive literal of the body.\nWe will now define a subclass of the allowed queries whose evaluation with respect to KB does not flounder. The definition of this subclass also takes into account the leftto-right selection strategy for literals. For any predicate defined in KB, each argument denoting a state (i.e., a set of fluents) can be classified either as an input argument or as an output argument. This classification is often called a mode [1]. In particular, it can be shown that we can classify the arguments such that the following property holds: if a predicate is evaluated with all its input arguments bound to ground sets of fluents, then whenever the predicate succeeds all variables occurring in output arguments are bound to ground sets of fluents. For instance, for the predicate result(S1, A, S2) the first argument is an input argument and the third argument is an output argument. For reasons of space we do not list here, for each predicate defined in KB, the input or output classification of its arguments. The following notion is adapted from [1].\nDefinition 3. A query L1 \u2227 . . . \u2227 Ln is well-moded if, for i = 1, . . . , n, every variable occurring in an input argument in Li occurs in an output argument in Lj, for some j \u2208 {1, . . . , i\u2212 1}.\nDefinition 4. Let f be (a term representing) a CTL formula. A subformula e of f is grounding if e is a fluent and one of the following conditions hold: (i) f is a fluent and e is f , (ii) f is and(f1, f2) and e is a grounding subformula of either f1 or f2, (iii) f is ex (f1) and e is a grounding subformula of f1, (iv) f is eu(f1, f2) (or, in particular, f is ef (f2)) and e is a grounding subformula of f2, (v) f is eg(f1) and e is a grounding subformula of f1.\nDefinition 5. A query Q of the form L1 \u2227 . . . \u2227 Ln is an NF-query (short for NonFloundering query) if the following conditions hold:\n(1) Q is well-moded,\n(2) for i = 1, . . . , n, if Li is of the form holds(f, S), then all variables of f occur in fluents that are subformulas of f , and\n(3) for each variable X of Q, the leftmost occurrence Xl of X in Q appears in a positive literal Lj, with 1 \u2264 j \u2264 n, such that either (3.1) Lj has predicate different from \u2018holds\u2019 or (3.2) Lj = holds(f, S) and Xl appears in a grounding subformula of f .\nA rule of the form A\u2190 L1 \u2227 . . . \u2227 Ln is an NF-rule, if the following conditions hold: (4) no variable ranging over states occurs in A,\n(5) every variable occurring in A also occurs in L1 \u2227 . . . \u2227 Ln, and (6) L1 \u2227 . . . \u2227 Ln is an NF-query.\nFor example, the queries and rules presented in Sections 6.1 and 6.2 are all NF. The query holds(eu(en(A, p), true), s0(p)) \u2227 \u00actask(A) is not an NF-query, because en(A, p) is not a grounding subformula of eu(en(A, p), true). This query flounders, as the non-ground negative literal \u00actask(A) will be selected after the success of holds(eu(en(A, p), true), s0(p)).\nWe assume that the query Q is defined by a single NF-rule Q \u2190 B, where B is a conjunction of literals. The extension to the case where Q is defined by a set of NF-rules (like in Section 6.2) is straightforward.\nProposition 1. Let Q\u2190 B be an NF-rule such that the predicate of Q does not occur in KB. Then we have the following properties. (1) The query Q does not flounder with respect to KB \u222a {Q\u2190 B}. (2) Every answer for Q with respect to KB \u222a {Q \u2190 B} is a ground substitution for the variables in Q.\nProof. (Sketch) (1) Let us consider a one-step derivation L\u2227Q1 \u03b8\u2212\u2192 Q2. By cases on the form of L one can show that if L \u2227Q1 is an NF-query, then Q2 is an NF-query. Thus, by also using the fact that every ground atom is an NF-query, if \u00acA\u2227Qn is a query generable from Q in any number of steps, then \u00acA \u2227 Qn is an NF-query. Therefore, all variables occurring in \u00acA must also occur in a positive literal to the left of \u00acA, and hence \u00acA is a ground atom.\n(2) Suppose, by contradiction, that an answer \u03b8 for Q is not a ground substitution. Let us consider the rule Q\u2190 B\u2227\u00acR, where R is any atom containing one of the variables that are not bound to a ground term in \u03b8. Q\u2190 B\u2227\u00acR is an NF-rule. We can construct a derivation from Q that eventually selects the non-ground literal \u00acR\u03b8, and hence the query Q flounders with respect to KB \u222a {Q\u2190 B \u2227 \u00acR}.\nLet us now show that the evaluation of every NF-query terminates by using SLG resolution. Given an atomic query Q, we define:\n\u2022 CallsQ as the least set of atoms satisfying the following properties:\n(1) Q \u2208 CallsQ;\n(2) if A \u2208 CallsQ and either A \u03b81\u2212\u2192 . . . \u03b8n\u2212\u2192 A\u2032 \u2227Q\u2032 or A \u03b81\u2212\u2192 . . . \u03b8n\u2212\u2192 \u00acA\u2032 \u2227Q\u2032,\nthen A\u2032 \u2208 CallsQ;\n\u2022 AnswersQ as the set of atoms A\u03b8 such that A \u2208 CallsQ and \u03b8 is an answer for A;\n\u2022 \u2206Q as CallsQ \u222aAnswersQ.\nThe termination proof is based on the property that, for any query Q, \u2206Q is a finite set of atoms. This property is equivalent to the bounded-term-size property that in [14] has been shown to be a sufficient condition for termination of SLG-resolution [14].\nGiven a set S, by |S| we denote the cardinality of S. Let P be a logic program, by \u03a0P we denote the maximum number of literals in the body of a rule in P . The following result is an adaptation of Theorem 5.4.3 in [14].\nTheorem 1 (Termination of SLG-resolution). Let P be a logic program and Q be an atomic query. Suppose that there exists a finite set D of atoms such that \u2206Q \u2286 D. Then all answers for Q can be computed by SLG-resolution in O(|P | \u00d7 |D|\u03a0P +1) steps.\nBy applying Theorem 1 to the case where P is of the form KB \u222a {q(X)\u2190 B}, we get the following result.\nProposition 2. Suppose that q(X) \u2190 B is an NF-rule, where X is a tuple of k \u2265 0 variables and the predicates of B are defined in KB. Then, all answers for q(X) can be computed by SLG-resolution in O(|KB| \u00d7 (|F|k + (||B|| \u00d7 |F|v \u00d7 |S|) + |S|m)r+1) steps, where: (i) F is the set of ground fluents that can be defined in KB, (ii) S is the set of possible states, that is, the powerset of F , (iii) ||B|| denotes the size (that is, the number of symbols) of B, (iv) v is the largest number of variables in a CTL formula in B, (v) m is the largest arity of a predicate in KB, and (vi) r is the largest number of literals in the body of a rule in KB \u222a {q(X)\u2190 B}.\nProof. Suppose that Q is the query q(X) defined by the NF-rule q(X) \u2190 B, where X is tuple of k \u2265 0 variables and the predicates of B are defined in KB. Let us define the following set D of atoms, where V is a finite, sufficiently large set of variables, and E is the set of flow elements in KB. D ={q(t) | t \u2208 (E \u222a F \u222a V)k} \u222a {holds(f, s) | f = f \u2032\u03b8, for some CTL-formula f \u2032 occurring as a subformula in a literal\nof B and substitution \u03b8 from variables to fluents, and s \u2208 S} \u222a {p(u) | p ( 6= holds) is an m-ary predicate defined in KB and u \u2208 (E \u222a F \u222a S \u222a V)m}\nAdditionally, we assume that no two atoms in D are variants of each other. We have that |D| \u2264 (|E|+ |F|+ 1)k + (||B|| \u00d7 |F|v \u00d7 |S|) + (|E|+ |F|+ |S|+ 1)m. The fluents in F are defined by using the elements in E , the constants from the ontology (which also occur in KB), and the function symbols cf, en, tf , and wrtn, and hence |E| \u2264 |F|. Moreover, |S| = 2|F|. Thus, |D| \u2208 O(|F|k + (||B|| \u00d7 |F|v \u00d7 |S|) + |S|m). By Theorem 1, we get the thesis.\nBy using Propositions 1 and 2, we get the following result.\nTheorem 2 (Termination, Soundness, and Completeness of Query Evaluation in KB). Let Q\u2190 B be an NF-rule such that the predicate of Q does not occur in KB. Then: (1) the evaluation of Q with respect to KB \u222a {Q\u2190 B} using SLG-resolution terminates; (2) Q succeeds with answer \u03b8 iff Q\u03b8 \u2208 Perf(KB \u222a {Q\u2190 B}); (3) for a ground rule of the form prop \u2190 holds(f, s), the evaluation of prop by using SLG-resolution terminates in polynomial time in ||f || \u00d7 |S|.\nProof. (1) The termination of query evaluation has been proved in Proposition 2.\n(2) The soundness and completeness of query evaluation follows from Proposition 1 and from the soundness and completeness of SLG-resolution for non-floundering queries recalled in Section 2.3.\n(3) If we consider the ground rule prop \u2190 holds(f, s), then in Proposition 2 we have k = v = 0. Since m and r do not depend on f or S, we get the thesis.\nProposition 2 above only gives a loose upper bound on the complexity of query evaluation. However, it is sufficient for showing that, in line with the complexity of the CTL verification problem [15], our verification method has polynomial running time with respect to the number of states that are potentially reachable during process enactment. Moreover, Theorem 2 shows that the use of OWL 2 RL elementary properties does not add more than polynomial complexity. A tighter complexity analysis could be done by directly analyzing the evaluation of queries with respect to KB, instead of relying, as done above, on the general results provided by [14].\nIn practice, our fluent-based representation of the behavioral semantics determines a running time which is polynomial in the number of flow elements that are concurrently enacted plus the number of fluents that are added to states by functional annotations. Usually, this number is much smaller than the cardinality of the powerset of F . Indeed, the experimental results reported in Section 8.2 show that verification and querying are feasible for medium sized, non-trivial processes.\nThe termination of trace correctness checking can be proved under assumptions similar to the ones of Theorem 2. However, stronger assumptions are needed for the termination of trace generation in the case where we want to compute the set of all correct traces satisfying a given condition, as this set may be infinite in the presence of cycles."}, {"heading": "8 Implementation", "text": "In the following we describe the BPAL Platform, a prototypical implementation of the framework discussed so far (Section 8.1), and we then discuss an experimental evaluation of the reasoner performances (Section 8.2)."}, {"heading": "8.1 Tool Description", "text": "The BPAL platform3 is implemented as an Eclipse Plug-in4, whose main components are depicted in the functional view in Figure 2. It provides the BPKB Editor to assist the user through a graphical interface in the definition of a BPKB, and the BPAL Reasoner, based on an LP engine, able to operate on the BPKB through the query language QuBPAL, designed for interrogating a repository of semantically enriched BPs."}, {"heading": "8.1.1 Query Language", "text": "QuBPAL is an expressive query language for a BPKB based on the theoretical framework presented in this paper (a preliminary specification has been discussed in [55]). It does not require the user to understand the technicalities of the underlying LP platform,\n3A video demonstration is available at http://www.youtube.com/watch?v=xQkapzjhO7g 4http://www.eclipse.org/\nsince QuBPAL queries are SELECT-WHERE statements intended to be automatically translated to logic programs, and then evaluated by using standard LP engines.\nThe SELECT statement defines the output of the query evaluation, which can be a boolean value, variables occurring in the WHERE statement, and a process selector representing either a BPS or a BPS fragment. The WHERE statement specifies an expression that restricts the set of data returned by the query, built from the set of the predicates defined in the BPKB (including CTL operators) and the connectives AND, OR, NOT, and the predicate = with the standard logic semantics. In the queries we use question mark to denote variables (e.g., ?x ), and we use the notation ?x::C to indicate the terminological annotation of a variable, i.e., x : \u2203termRef.C.\nIt is worth noting that the representation of OWL/RDFS resources as sets of triples, which directly encode the underlining RDF graph, allows us to pose queries over the ontology in a form very close to the SPARQL (SPARQL Protocol and RDF Query Language) standard [49], defined by the World Wide Web Consortium and widely accepted in the Semantic Web community. SPARQL is in fact designed to query RDF resources, that essentially are organized as directed and labeled graphs, by matching graph pattern over RDF graphs. Graph patterns are in turn specified as triples where variables can occur in every position (i.e., atoms of the form t(a1, a2, a3)), along with their conjunctions and disjunctions. In this sense, while providing additional primitives to be used specifically for querying BPs, the ontology-related reasoning is specified in a QuBPAL query accordingly to consolidated Semantic Web standards.\nTo provide some insights about the language, we report in the following two examples of QuBPAL queries. The first one represents the formulation of the verification criteria for the compliance rule discussed at Point (4) of Section 6.1. The second one is the QuBPAL translation of the query q3 discussed in Section 6.2.\nSELECT <> WHERE [EF (final(ho) AND t(?o, rdf : type, bro : PurchaseOrder) AND NOT t(?o, rdf : type, bro : ClosedPO)| ho]\nSELECT ?a ?p WHERE output(?a, ?i :: bro : Purchase Order, ?p) AND reachable(?a, ?b, ?p) AND activity(?b :: bro : Transportation) AND assigned(?b, ?c :: bro : Carrier, ?p) AND [ NOT EU ( NOT en(?a, ?p), en(?b, ?p) ) | ?p]"}, {"heading": "8.1.2 BPKB Editor", "text": "This component provides a graphical user interface to define a BPKB and to interact with the BPAL Reasoner. A screen-shot of the main components of the GUI is depicted in Figure 3.\n\u2022 The left panel (Figure 3.a) is the Package Explorer, providing a tree view of the resources available in the workspace, including BP schemas and ontologies.\n\u2022 The central panel (Figure 3.b) is the BP Modeling View, based on the STP BPMN Modeler5, comprising an editor and a set of tools to model business process diagrams using the BPMN notation.\n\u2022 On the left (Figure 3.c), the Ontology View allows for the visualization of OWL ontologies, published on the Internet or locally stored.\n5http://www.eclipse.org/soa\n\u2022 The bottom panel (Figure 3.d) is the Annotation View, an editor for the annotation of process elements with respect to the reference ontology.\n\u2022 The top-central panel (Figure 3.e) is the QuBPAL View, that provides a query prompt to access the BPAL reasoner through the query mechanism. Results can be consulted in the result panel (Figure 3.f)."}, {"heading": "8.1.3 BPAL Reasoner", "text": "This component implements the reasoning methods described in Section 6 by using the XSB Prolog6 system [58], which is a Logic Programming system based on the SLGresolution inference strategy recalled in Section 2.3. As proved in Section 7, the tabling mechanism guarantees the termination of query evaluation and the polynomial time (in the size of the state space) verification of CTL properties.\nProcess schemas are imported into the BPKB from BPMN process models via the BPMN2BPAL interface. In order to ease the sharing and re-use of semantic meta-data, semantic information used and produced during the annotation process (i.e., reference ontologies and semantic annotations) can be exported and imported from OWL/RDF files by means of the RDF I/O module. The underlying XSB Prolog implementation of the rule-based reasoner can deal with either RDF, RDFS or OWL 2 RL ontologies. The BPKB Manager handles the set-up and the interaction with the LP engine by initializing and updating a BPKB. After populating the BPKB, inference is essentially performed by posing queries to the XSB Prolog engine, connected through a Java/Prolog interface. To this end, the Query Manager exposes functionalities to translate QuBPAL queries into LP queries, evaluate them, and collect the results in a textual form or export them in an XML serialization.\n6http://xsb.sourceforge.net/"}, {"heading": "8.2 Experimentation", "text": "The approach has been applied to real-world scenarios coming from end-users involved in the European Project BIVEE7 and from the pilot conducted within a collaboration between the Italian CNR and SOGEI (ICT Company of the Italian Ministry of Finance). The former is related to the modeling of production processes in manufacturing oriented networked-enterprises, while the latter regards the procedural modeling of legislative decrees in the tax domain. The experiments we have conducted are encouraging and revealed the practical usability of the tool and its acceptance by business experts.\nOn a more technical side, the LP reasoner based on the XSB system shown a significant efficiency, since very sophisticated reasoning tasks have been performed on BPs of small-tomedium size (about one hundred of activities and several thousands of reachable states) in an acceptable amount of time and memory resources. Some empirical results are reported in the following, related to a dataset described in Table 8. We started by adapting a real world process, dealing with eProcurement, obtaining the BPS P , for which we report: the size, in terms of the number of flow elements; the number of reachable states; the number of exclusive, parallel, and inclusive gateways. As summarized in the table, the considered BPS does not contain logical errors (e.g., deadlocks) and is characterized by a considerable number of gateways, that is, branching/merging points (about 45% of the total number of elements). We then annotated in three different ways the process, obtaining P1, P2, P3. For each one, in Table 8 we report: the number of reachable states; the coverage of the annotation, in terms of the percentage of the annotated flow elements; the average size of each state, in terms of the number of ontological assertions (i.e., tf fluents) occurring in each state; the average size of the annotation, in terms of the number of tf fluents occurring in the precondition/effect descriptions of the annotated flow elements; the errors exhibited by the BPS. In particular, P1 has been annotated without preventing logical errors induced by the annotation, P2 presents a revised version of P1 annotation, further extended in P3.\nFor the annotation of the BPS we adapted an ontology covering documents and production-related activities in the context of eProcurement and eBusiness, developed within the BIVEE project, comprising about 100 concepts.\nThe experiments have been performed on an Intel laptop, with a 3 GHz Core 4 CPU, 8 GB RAM and Windows operating system. For each BPS we first tested the set-up of the reasoner, which include the translation of the BPKB into LP rules, their loading into the XSB reasoner, and the computation of the state space, i.e., the transitive closure of the result relation. Timing (measured in milliseconds) and memory occupation (measured in\n7BIVEE: Business Innovation and Virtual Enterprise Environment (FoF-ICT-2011.7.3-285746)\nmegabytes) are reported in Table 9. We then run the queries presented in Section 6.1 and the last presented in Section 6.2, representing respectively: the verification of the option to complete (Q1), consistency condition (Q2), and executability (Q3) properties, an exemplary compliance rule (Q4) and a retrieval query (Q5). For each query, the average timing obtained in 10 runs is reported.\nTo better understand the performed tests, additional considerations are needed. Firstly, the above CTL queries have been executed after the computation of the state space, which, due to the SLG-resolution strategy implemented by XSB, causes the population of the tables storing the intermediate results. The tables are then available in the subsequent queries, speeding up the computation. Secondly, to stress the engine, the evaluation of the performed queries requires the verification of ontology-based properties for each reachable state. Finally, the amount of required memory depends on the strategy adopted by the engine for the management of the tables. In the above experiments the default behavior has been adopted and, according to that, every intermediate result is materialized. This explains the large memory consumption, which, if needed, can be strongly reduced by introducing specific configurations to limit the use of tables, trading space for time.\nIt is also worth noting that no code optimization has been performed, since the executed Prolog program is the direct translation of the rules presented in this paper. Another remark regards the overhead introduced by the Java/Prolog bridge, which does not introduce a relevant performance degradation. Indeed, by running the same tests directly on XSB, without the Java infrastructure, the timings differ (up to a 10%) only in the presence of a large amount of results, mainly due to the inter-process data exchange."}, {"heading": "9 Related Work", "text": "BP Modeling and Analysis. Among several mathematical formalisms proposed for defining a formal semantics of BP models, Petri nets [64] are the most used paradigm to capture the execution semantics of graph-based procedural languages (the BPMN case is discussed in [20]). Petri net models enable a large number of techniques for the control flow analysis of processes, but they do not provide a suitable basis to represent and reason about additional domain knowledge. In our framework we are able to capture the token game semantics underlying workflow models, and we can also declaratively represent constructs, such as exception handling behavior or synchronization of active branches only (inclusive merge), which, due to their non-local semantics, are cumbersome to capture in standard Petri nets. Furthermore, the logical grounding of our framework makes it easy to deal with the modeling of domain knowledge and the integration of reasoning services.\nProgram analysis and verification techniques have been largely applied to the analysis of process behavior, e.g., [24, 37]. These papers are based on the analysis of finite\nstate models through model checking techniques [15], where queries, formulated in some temporal logics, specify properties of process executions. However, these approaches are restricted to properties regarding the control flow only (e.g., properties of the ordering, presence, or absence of tasks in process executions), and severe limitations arise when ontology-related properties are included as part of the model to be checked.\nOther approaches based on Logic Programming that are worth mentioning are [27, 53, 42]. [27] presents an approach to BP verification based on an extension of answer set programming with temporal logic and constraints, where the compliance of business rules is checked by bounded model checking techniques extended with constraint solving for dealing with conditions on numeric data. [53, 42] mainly focus on the analysis and on the enactment of flow models representing service choreographies, while we are not aware of specific extensions that deal with the semantic annotation of procedural process models with respect to domain ontologies.\nSemantic Verification of BPs. There is a growing body of contributions beyond pure control flow verification [66, 25, 41, 19]. In [66] the authors introduce the notion of Semantic Business Process Validation, which aims at verifying properties related to the absence of logical errors which extend the notion of workflow soundness [64]. Validation is based on an execution semantics where token passing control flow is combined with the AI notion of state change induced by domain-related logical preconditions/effects. The main result is constituted by a validation algorithm that runs in polynomial time in the size of the workflow graph, under some restrictions on its structure and on the expressivity of the logic underlying the domain axiomatization, i.e., binary Horn clauses. This approach is focused on providing efficient techniques for the verification of specific properties, while the verification of arbitrary behavioral properties, such as the CTL formulae allowed in our framework, is not addressed. Moreover, our language for annotations, encompassing OWL 2 RL, is more expressive than binary Horn clauses. BP analysis techniques based on logical descriptions of effects of task execution are also proposed in [25, 41], but they introduce algorithms in an informal way, since a formal execution semantics is not provided, and a background ontology is not considered.\nIn [19] the authors discuss a CTL model checking method for annotated state transition systems, encoding the procedural behavior of Web Services interactions. Given a query, in the form of a CTL formula containing conjunctive subqueries, a boolean answer is computed in two steps: (1) a ground transition system is produced where each state contains all and only the description logic assertions relevant to the input query; (2) the grounded model is checked by a traditional propositional model checking algorithm. In contrast to our approach, the generation of the annotated transition system from a workflow model is neglected, and thus a semantics for activity preconditions/effects dealing also with the problems related to the state update is not given. Furthermore, our framework allows much more expressive reasoning services, since it is not limited to the boolean verification of CTL queries. On the technical side, our approach avoids the burden of integrating several tools, since both the temporal and ontological reasoning are performed by the LP inference engine. One relevant advantage of the LP translation is the possibility of computing answers according to a pure top-down, goal-oriented strategy, which avoids the need of preliminary grounding the model and possibly performing a large number of inferences that are not necessary for answering a given query.\nFinally, we would like to mention a related research area, dealing with the verification of temporal properties in databases that evolve over time due to execution of actions operating on data (see [13] for a survey). Recently, [30] proposed Knowledge and Action\nBases (KABs), where actions, encoded as condition/action rules, modify the ABox of an ontology, encoded in a variant of the OWL 2 QL language. Under suitable restrictions, properties of KABs specified in the \u00b5-calculus are shown to be decidable, and their verification can be reduced to finite-state model checking. KABs describe systems that may reach an infinite number of states, unlike our setting, where data are partially abstracted away8, hence enforcing the reachable states to be a finite set. However, our framework is expressive enough to capture complex workflow specifications enriched with fluent expressions stated in terms of a background OWL 2 RL ontology. While the main goal of [30] is to provide theoretical results that characterize the decidability and (very high) complexity of KAB reasoning, our objective is more pragmatic and our formalization enables the implementation, through standard LP engines, of a wider set of (polynomial time) reasoning services, besides the verification of temporal properties.\nProcess Ontologies. The Process Specification Language (PSL) [9] is an ontology designed to formalize reasoning about processes in first-order logic. The basic structure that characterizes the behavior of a process in PSL is the occurrence tree (whose model is inspired by the Situation Calculus [51]), which contains all (infinite) sequences of occurrences of atomic activities starting from an initial state. Many extensions of PSL have been proposed to deal with time points, objects, agents, and resources. Although PSL is defined in first-order logic, which in principle makes behavioral specifications in PSL amenable to automated reasoning, it is mostly intended as a means to facilitate correct and complete exchange of process information among manufacturing systems, rather then for computation. Indeed, it is a very expressive framework whose associated reasoning tasks are intractable even for simple definitions, and undecidable in general, due to the adoption of unrestricted first-order logic. Furthermore, the systematic translation of procedural workflow descriptions into PSL has not been addressed, hence limiting its usability.\nSeveral papers proposed the extension to BP management of techniques developed in the context of the Semantic Web9. To this end several meta-model process ontologies have been proposed, with the aim of specifying in a declarative, formal, and explicit way the modeling constructs, and enabling the use of domain ontologies for the semantic reconciliation of model contents. Some of them are derived from BP modeling notations (e.g., BPMN [17]), EPC [63], XPDL [29], Petri nets [11], while others have been designed in the context of interoperability, to overcome heterogeneities deriving from the adoption of different languages by mapping them to one common process ontology (e.g., GPO [36], BPMO [21]). The above approaches share some common features and goals: (1) they are based on standardized Web ontology languages; (2) they allow a machine-processable representation of BP models; (3) they enable query and search facilities; (4) they provide the means for relating BP models to existing business dictionaries and background knowledge. While a BPAL BPKB provides all the above features, supporting OWL 2 RL for ontological modeling, it also integrates behavioral modeling and a more expressive verification mechanism.\nSemantic Web Services. Another stream of related papers regards the semantic enrichment of Web Services, where relevant work has been done within the OWL-S [12] and WSMO [52] initiatives. Both make an essential use of ontologies in order to facilitate the automation of discovering, combining and invoking electronic services over the Web. To\n8basically, the set of individuals in the ontology is bounded and fixed a-priori; new values cannot be introduced during the enactment (e.g., by function terms)\n9See the work conducted within the SUPER project: http://www.ip-super.org/\nthis end they describe services from two perspectives: from a functional perspective a service is described in terms of its functionality, preconditions and effects, input and output; from a process perspective, the service behavior is modeled as an orchestration of other services. However, in the above approaches the behavioral aspects are abstracted away, thus hampering the availability of reasoning services related to the execution of BPs. To overcome such limitations, several solutions for the representation of service compositions propose to translate the relevant aspects of the aforementioned service ontologies into a more expressive language, such as first-order logic. Among them, [57] adopts the high-level agent programming language Golog [51], [6, 44] rely on Situation Calculus variants, while [8, 5] are based on a direct translation of OWL-based service description into a Fluent Calculus theory. However, such approaches are mainly tailored to automated service composition (i.e., finding a sequence of service invocations such that a given goal is satisfied). Thus, the support provided for process definition, in terms of workflow constructs, is very limited and they lack a clear mapping from standard modeling notations. Furthermore, the adoption of a state-independent domain axiomatization (i.e., a DL TBOX) is not considered in the aforementioned approaches. In contrast, our framework allows a much richer procedural description of processes, directly corresponding to BPMN diagrams. Moreover, a reference ontology can be used to \u201cenrich\u201d process descriptions by means of annotations written in OWL 2 RL, one of the most widespread languages for ontology representation."}, {"heading": "10 Conclusions", "text": "Summary\nIn this paper we discussed a methodological framework and a technical solution for the semantic enrichment of BP models, based on the synergic use of BPAL, a rule-based language adopted to provide a declarative representation of the procedural knowledge of a BP, and business ontologies, to capture the semantics of a business scenario. The resulting knowledge base provides a uniform and formal representation framework, suited for automated reasoning and equipped with a powerful inference mechanism supported by the programming systems developed in the area of Logic Programming.\nBPAL is a rule-based formalism for modeling the structure and the behavior of a business process represented accordingly to a workflow perspective. It is essentially a process ontology, which provides a vocabulary, derived from BPMN, for specifying BPs, and an explicit description of its meta-model and execution semantics in terms of two core first-order logic theories which give formal definitions to the constructs of the language. In particular, from a control flow perspective, BPAL supports a relevant fragment of the BPMN standard, allowing us to deal with a large class of process models.\nWe then proposed an approach for the semantic enrichment of BPs, where BPAL BP schemas are related through a semantic annotation to a conceptualization of the business scenario formalized in a computational ontology. By integrating the rule-based ontology language OWL 2 RL with the structural and behavioral specification provided by BPAL, we are able to define a Business Process Knowledge Base (BPKB), as a collection of logical theories that provide a declarative representation of a repository of semantically enriched BPs.\nOn top of this knowledge representation framework, we built a number of reasoning services which allow the user to formulate complex queries that combine properties related to the structure, the behavioral semantics, and the ontological description of the BPs. We\nshowed how advanced resolution strategies, such as the tabled resolution implemented in the XSB Logic Programming system, guarantee a terminating, sound, and complete evaluation of the queries that can be issued over a BPKB.\nDiscussion\nThe rule-based approach followed in our framework offers several advantages. First of all, it enables the combination of the procedural and ontological perspectives in a very smooth and natural way, thus providing a uniform framework for reasoning on properties that depend on the sequence of operations that occur during process enactment and also on the domain where the process operates. Another advantage is the generality of the approach, which is open to further extensions, since other knowledge representation applications can easily be integrated, by providing a suitable translation to Logic Programming rules.\nFurthermore, our approach does not introduce a new business process modeling language, but provides a framework where one can map and integrate knowledge represented by means of existing formalisms. This is very important from a pragmatic point of view, as one can express process-related knowledge by using standard modeling languages, while adding extra reasoning services. We have adopted BPMN as a graphical modeling notation, and its XML linear form to import and manipulate BP models, possibly designed through external BP Management Systems. For what concerns the ontology representation, we have committed to OWL, the current de-facto standard for ontology modeling and meta-data exchange. In essence, we have proposed a progressive approach, tailored to enhanced adaptability, where a business expert can start with the (commercial) tool and notation of his/her choice, and then enrich its functionalities with the formal framework we provide.\nFinally, since our rule-based representation can be directly mapped to a class of logic programs, we can use standard Logic Programming systems to perform reasoning tasks such as verification and querying through a goal-oriented, efficient sound and complete evaluation procedure.\nThere are two main assumptions related to the practical applicability of our approach: the availability of ontologies and the willingness of an organization to describe their processes with semantic information. Clearly, enabling additional reasoning services comes at the price of additional modeling efforts, which may seriously hamper the adoption of our solution; this is a problem shared by many approaches based on Knowledge Representation techniques, in the Semantic Web related-research in particular. We now briefly discuss the impact of the above issues on the proposed approach.\nThe development of an ontology is a very complex task that requires the expertise of knowledge engineers and domain experts, and hence, high costs. Nevertheless, industrial products and services categorization standards, such as RosettaNet (http: //www.rosettanet.org/) or eClass (http://www.eclass-online.com/), and libraries of standard business documents, such as UBL (http://ubl.xml.org/), reflect some degree of community consensus, and can thus be valuable input for creating business domain ontologies [31]. Also the growing interest for the publication of open data and their organization according to the Linked Data paradigm10 increase the availability of publicly accessible terminological resources. Moreover, emerging methodologies for collaborative ontology building may be adopted here to lift existing resources (e.g., glossaries, organizational and data models) into formal theories [39]. That said, it should be noticed that\n10http://linkeddata.org/\nour framework does not require a heavy-weight, richly axiomatized ontology to work. The query capabilities can be still exploited even in the presence of a thesaurus only, which defines a set of terms whose meaning is agreed upon, possibly arranged in hierarchical structures. In this case, the annotation is reduced to tags taken from such a common glossary, but still retrieval and verification tasks with a practical relevance can be performed.\nAlso the semantic annotation is a time-consuming and error-prone task, which does not pay off if a small number of BPs has to be managed. However, in situations where hundreds of process models are available within an organization, and many collaborations with other departments or companies take place, the alignment of the adopted terminology and the reasoning facilities enabled by the semantic annotation may create a significant added-value11. Furthermore, once the ontologies are available, the effort required to the user for creating annotations amounts to browsing and selecting ontology concepts (see Section 8.1). In addition, we do not require that every BP is fully annotated; in many situations only parts of the model may be of interest for specific querying or verification tasks. Finally, approaches based on information retrieval and linguistic analysis can also be applied to support the annotation, suggesting correspondences between activity labels and terms defined in an ontology [18].\nFuture Work\nThe results presented in this paper leave several directions open for future research. First of all, we plan to push forward the empirical investigation of the impact of our proposal in each application scenario we are addressing, as reported in Section 8.2.\nOn the technical level, a relevant aspect to be further elaborated regards the adoption of query optimization techniques to enhance the reasoning approach. As it stands, the reasoner performs only simple optimizations based on the re-ordering of literals, and all the queries are evaluated with a pure goal-oriented, top-down approach, without any pre-processing of the knowledge base. We are confident that the query evaluation process can be strongly improved through more sophisticated query rewriting and program transformation techniques [48], which have been largely investigated in the area of Logic Programming.\nWe are also interested in applying the proposed framework in other phases of the BP life-cycle. In particular, the trace semantics of BPAL appears a suitable starting point to support: (i) querying at run-time, i.e., performed over a running instance of the process during its enactment; (ii) a-posteriori, i.e., over the execution logs of completed enactments, by adopting Inductive Logic Programming techniques, such as the ones presented in [35]; (iii) verification techniques for BPs in the presence of data constraints, by following approaches based on Constraint Logic Programming such as, for instance, the one proposed in [23].\nFinally, we plan to extend the framework to also represent the execution-level process knowledge, and support the transition between conceptual and executable processes from a service-oriented perspective. That is, given a conceptual process model, Web services available in a repository are selected and possibly orchestrated to implement the process activities. The query-based support to process composition discussed in [54] represents a first contribution in that direction.\n11See, e.g., the EU projects SUPER (http://www.ip-super.org/), Plug-it (http://plug-it-project.eu), COIN (http://www.coin-ip.eu/) and BIVEE (http://www.bivee.eu/)."}], "references": [{"title": "From Logic Programming to Prolog", "author": ["K.R. Apt"], "venue": "Prentice Hall, London, UK", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1997}, {"title": "Logic Programming and Negation: A Survey", "author": ["K.R. Apt", "R.N. Bol"], "venue": "Journal of Logic Programming, 19/20:9\u201371", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1994}, {"title": "Finite transition systems: semantics of communicating systems", "author": ["A. Arnold"], "venue": "chapter Transition System Logics. Prentice Hall International (UK) Ltd., Hertfordshire, UK, UK", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1994}, {"title": "editors", "author": ["F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider"], "venue": "The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2003}, {"title": "WSSL: A Fluent Calculus-Based Language for Web Service Specifications", "author": ["G. Baryannis", "D. Plexousakis"], "venue": "CAiSE 2013, volume 7908 of LNCS, pages 256\u2013271. Springer", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2013}, {"title": "Semantic Web Services Ontology", "author": ["S. Battle"], "venue": "www.daml.org/services/swsf/1. 0/swso/,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2005}, {"title": "The semantic web", "author": ["T. Berners-Lee", "J. Hendler", "O. Lassila"], "venue": "Scientific American,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2001}, {"title": "Applying Fluent Calculus for Automated and Dynamic Semantic Web Service Composition", "author": ["A. Bhuvaneswari", "G.R. Karpagam"], "venue": "Proc. of the 1st Int. Conf. on Intelligent Semantic Web-Services and Applications, pages 16:1\u201316:6. ACM", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2010}, {"title": "PSL: A Semantic Domain for Flow Models", "author": ["C. Bock", "M. Gruninger"], "venue": "Software and Systems Modeling Journal, 4:209\u2013231", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2004}, {"title": "RDF Vocabulary Description Language 1.0: RDF Schema", "author": ["D. Brickley", "R.V. Guha"], "venue": "W3C Recommendation,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2004}, {"title": "Semantic Alignment Of Business Processes", "author": ["S. Brockmans", "M. Ehrig", "A. Koschmider", "A. Oberweis", "R. Studer"], "venue": "8th Int. Conf. on Enterprise Information Systems, pages 191\u2013196. INSTICC Press", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2006}, {"title": "OWL-S: Semantic Markup for Web Services", "author": ["M. Burstein"], "venue": "W3C Member Submission,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2004}, {"title": "Foundations of data-aware process analysis: A database theory perspective", "author": ["D. Calvanese", "G. De Giacomo", "M. Montali"], "venue": "Proceedings of the 32nd Symposium on Principles of Database Systems, PODS \u201913, pages 1\u201312. ACM", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2013}, {"title": "Tabled Evaluation with Delaying for General Logic Programs", "author": ["W. Chen", "D.S. Warren"], "venue": "J. ACM,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 1996}, {"title": "Model Checking", "author": ["E.M. Clarke", "O. Grumberg", "D.A. Peled"], "venue": "The MIT Press", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1999}, {"title": "An Open Platform for Business Process Modeling and Verification", "author": ["A. De Nicola", "M. Missikoff", "M. Proietti", "F. Smith"], "venue": "Database and Expert Systems Applications, 21st International Conference, volume 6261 of LNCS, pages 76\u201390. Springer", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2010}, {"title": "Semantically-Aided Business Process Modeling", "author": ["C. Di Francescomarino", "C. Ghidini", "M. Rospocher", "L. Serafini", "P. Tonella"], "venue": "International Semantic Web Conference, LNCS 5823, pages 114\u2013129. Springer", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2009}, {"title": "Supporting Ontology-Based Semantic Annotation of Business Processes with Automated Suggestions", "author": ["C. Di Francescomarino", "P. Tonella"], "venue": "IJISMD, 1(2):59\u201384", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2010}, {"title": "Model Checking Semantically Annotated Services", "author": ["I. Di Pietro", "F. Pagliarecci", "L. Spalazzi"], "venue": "IEEE Trans. Software Eng., 38(3):592\u2013608", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2012}, {"title": "Semantics and Analysis of Business Process Models in BPMN", "author": ["R.M. Dijkman", "M. Dumas", "C. Ouyang"], "venue": "Inf. Softw. Technol.,", "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2008}, {"title": "A BPMO Based Semantic Business Process Modelling Environment", "author": ["M. Dimitrov", "A. Simov", "S. Stein", "M. Konstantinov"], "venue": "Semantic Business Process Modeling, volume 251 of CEUR-WS Proceedings. CEUR-WS.org", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2007}, {"title": "Enabling Semantic Web Services: The Web Service Modeling Ontology", "author": ["D. Fensel"], "venue": null, "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2006}, {"title": "Generalization strategies for the verification of infinite state systems", "author": ["F. Fioravanti", "A. Pettorossi", "M. Proietti", "V. Senni"], "venue": "Theory and Practice of Logic Programming, 13(2):175\u2013199", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2013}, {"title": "Analysis of Interacting BPEL Web Services", "author": ["X. Fu", "T. Bultan", "J. Su"], "venue": "Proc. of the Int. Conf. on World Wide Web, pages 621\u2013630. ACM", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2004}, {"title": "Auditing Business Process Compliance", "author": ["A. Ghose", "G. Koliadis"], "venue": "Proc. of Int. Conf. on Service-Oriented Computing, volume 4749 of LNCS, pages 169\u2013180. Springer", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2007}, {"title": "Reasoning about action II: The qualification problem", "author": ["M.L. Ginsberg", "D.E. Smith"], "venue": "Artificial Intelligence, 35(3):311\u2013342", "citeRegEx": "26", "shortCiteRegEx": null, "year": 1988}, {"title": "Business process verification with constraint temporal answer set programming", "author": ["L. Giordano", "A. Martelli", "M. Spiotta", "D.T. Dupr\u00e9"], "venue": "TPLP, 13(4-5):641\u2013655", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2013}, {"title": "Description Logic Programs: Combining Logic Programs with Description Logic", "author": ["B.N. Grosof", "I. Horrocks", "R. Volz", "S. Decker"], "venue": "Proc. of the 12th Int. Conf. on World Wide Web, WWW \u201903, pages 48\u201357. ACM", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2003}, {"title": "Towards an XPDL Compliant Process Ontology", "author": ["A. Haller", "W. Gaaloul", "M. Marmolowski"], "venue": "Proc. of the IEEE Congress on Services, pages 83\u201386. IEEE Computer Society", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2008}, {"title": "Description logic knowledge and action bases", "author": ["B.B. Hariri", "D. Calvanese", "M. Montali", "G.D. Giacomo", "R.D. Masellis", "P. Felli"], "venue": "J. Artif. Intell. Res. (JAIR), 46:651\u2013 686", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2013}, {"title": "Products and Services Ontologies: A Methodology for Deriving OWL Ontologies from Industrial Categorization Standards", "author": ["M. Hepp"], "venue": "Int. J. Semantic Web Inf. Syst., 2(1):72\u201399", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2006}, {"title": "Semantic Business Process Management: A Vision Towards Using Semantic Web Services for Business Process Management", "author": ["M. Hepp"], "venue": "In Proc. of Int. Conf. on e-Business Engineering. IEEE Computer Society,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2005}, {"title": "On the Semantics of EPCs: Resolving the Vicious Circle", "author": ["E. Kindler"], "venue": "Data Knowl. Eng., 56(1):23\u201340", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2006}, {"title": "Resource Description Framework (RDF): Concepts and Abstract Syntax", "author": ["G. Klyne", "J.J. Carroll"], "venue": "W3C Recommendation,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2004}, {"title": "Applying Inductive Logic Programming to Process Mining", "author": ["E. Lamma", "P. Mello", "F. Riguzzi", "S. Storari"], "venue": "Inductive Logic Programming, volume 4894 of LNCS, pages 132\u2013146. Springer", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2007}, {"title": "Semantic Annotation for Process Models: Facilitating Process Knowledge Management via Semantic Interoperability", "author": ["Y. Lin"], "venue": "PhD thesis, Norwegian University of Science and Technology", "citeRegEx": "36", "shortCiteRegEx": null, "year": 2008}, {"title": "A Static Compliance-Checking Framework for Business Process Models", "author": ["Y. Liu", "S. M\u00fcller", "K. Xu"], "venue": "IBM Syst. J.,", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2007}, {"title": "Foundations of logic programming", "author": ["J.W. Lloyd"], "venue": "Springer-Verlag New York, Inc.", "citeRegEx": "38", "shortCiteRegEx": null, "year": 1987}, {"title": "Collaborative Ontology Building in Virtual Innovation Factories", "author": ["V. Ludovici", "F. Smith", "F. Taglino"], "venue": "2013 Int. Conf. on Collaboration Technologies and Systems, pages 443\u2013450. IEEE", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2013}, {"title": "Some Philosophical Problems from the Standpoint of Artificial Intelligence", "author": ["J. McCarthy", "P.J. Hayes"], "venue": "Machine Intelligence, volume 4, pages 463\u2013502", "citeRegEx": "40", "shortCiteRegEx": null, "year": 1969}, {"title": "On the Semantics of Service Compositions", "author": ["H. Meyer"], "venue": "Proc. of the 1st Int. Conf. on Web Reasoning and Rule Systems, volume 4524 of LNCS, pages 31\u201342. Springer", "citeRegEx": "41", "shortCiteRegEx": null, "year": 2007}, {"title": "Declarative specification and verification of service choreographies", "author": ["M. Montali", "M. Pesic", "W.M.P. van der Aalst", "F. Chesani", "P. Mello", "S. Storari"], "venue": "ACM Trans. Web,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2010}, {"title": "OWL 2 Web Ontology Language Profiles (Second Edition)", "author": ["B. Motik"], "venue": "W3C Recommendation,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2012}, {"title": "Analysis and Simulation of Web Services", "author": ["S. Narayanan", "S. McIlraith"], "venue": "Comp. Networks,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2003}, {"title": "Constraint Logic Programming for Local and Symbolic Model-checking", "author": ["U. Nilsson", "J. L\u00fcbcke"], "venue": "Computational Logic, LNAI 1861. Springer", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2000}, {"title": "Business Modeling With UML: Business Patterns at Work", "author": ["M. Penker", "H.-E. Eriksson"], "venue": null, "citeRegEx": "47", "shortCiteRegEx": "47", "year": 2000}, {"title": "Transformation of logic programs: Foundations and techniques", "author": ["A. Pettorossi", "M. Proietti"], "venue": "J. Log. Program., 19/20:261\u2013320", "citeRegEx": "48", "shortCiteRegEx": null, "year": 1994}, {"title": "SPARQL Query Language for RDF", "author": ["E. Prud\u2019hommeaux", "A. Seaborne"], "venue": "W3C Recommendation,", "citeRegEx": "49", "shortCiteRegEx": "49", "year": 2008}, {"title": "On the Declarative Semantics of Deductive Databases and Logic Programs", "author": ["T.C. Przymusinski"], "venue": "Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann Publishers", "citeRegEx": "50", "shortCiteRegEx": null, "year": 1988}, {"title": "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems", "author": ["R. Reiter"], "venue": null, "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2001}, {"title": "J", "author": ["D. Roman", "U. Keller", "H. Lausen"], "venue": "de Bruijn, R. Lara, M. Stollberg, Polleres, C. Feier, C. Bussler, and D. Fensel. Web Service Modeling Ontology. Applied Ontology, 1(1):77\u2013 106", "citeRegEx": "52", "shortCiteRegEx": null, "year": 2005}, {"title": "Semantic Web Service Choreography: Contracting and Enactment", "author": ["D. Roman", "M. Kifer"], "venue": "Proc. of International Semantic Web Conference, LNCS 5318, pages 550\u2013566", "citeRegEx": "53", "shortCiteRegEx": null, "year": 2008}, {"title": "Semi-Automatic Process Composition via Semantics- Enabled Sub-Process Selection and Ranking", "author": ["F. Smith", "D. Bianchini"], "venue": "Enterprise Interoperability V, Shaping Enterprise Interoperability in the Future Internet, Proc. of I-ESA 2012, pages 177\u2013187. Springer", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2012}, {"title": "Ontology-Based Querying of Composite Services", "author": ["F. Smith", "M. Missikoff", "M. Proietti"], "venue": "Business System Management and Engineering, volume 7350 of LNCS, pages 159\u2013180. Springer", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2010}, {"title": "Rule-based Behavioral Reasoning on Semantic Business Processes", "author": ["F. Smith", "M. Proietti"], "venue": "ICAART (2), pages 130\u2013143. SciTePress", "citeRegEx": "56", "shortCiteRegEx": null, "year": 2013}, {"title": "Web Service Composition via the Customization of Golog Programs with User Preferences", "author": ["S. Sohrabi", "N. Prokoshyna", "S.A. McIlraith"], "venue": "Conceptual Modeling: Foundations and Applications, pages 319\u2013334. Springer", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2009}, {"title": "XSB: Extending the power of Prolog using tabling", "author": ["T. Swift", "D. Warren"], "venue": "12(1- 2):157\u2013187", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2012}, {"title": "Extending the RDFS Entailment Lemma", "author": ["H. ter Horst"], "venue": "Proc. of the 3rd Int. Semantic Web Conf., LNCS. Springer,", "citeRegEx": "59", "shortCiteRegEx": "59", "year": 2004}, {"title": "Ramification and Causality", "author": ["M. Thielscher"], "venue": "Artificial Intelligence, 89:317\u2013364", "citeRegEx": "60", "shortCiteRegEx": null, "year": 1997}, {"title": "Introduction to the Fluent Calculus", "author": ["M. Thielscher"], "venue": "Electron. Trans. Artif. Intell., 2:179\u2013192", "citeRegEx": "61", "shortCiteRegEx": null, "year": 1998}, {"title": "From Situation Calculus to Fluent Calculus: State Update Axioms as a Solution to the Inferential Frame Problem", "author": ["M. Thielscher"], "venue": "Artificial Intelligence,", "citeRegEx": "62", "shortCiteRegEx": "62", "year": 1999}, {"title": "Semantic EPC: Enhancing Process Modeling Using Ontology Languages", "author": ["O. Thomas", "M. Fellmann"], "venue": "Semantic Business Process Modeling, volume 251 of CEUR- WS Proceedings. CEUR-WS.org", "citeRegEx": "63", "shortCiteRegEx": null, "year": 2007}, {"title": "The Application of Petri Nets to Workflow Management", "author": ["W.M.P. van der Aalst"], "venue": "Journal of Circuits, Systems, and Computers,", "citeRegEx": "64", "shortCiteRegEx": "64", "year": 1998}, {"title": "A New Semantics for the Inclusive Converging Gateway in Safe Processes", "author": ["H. V\u00f6lzer"], "venue": "Proc. of Int. Conf. on Business Process Management, LNCS 6336, pages 294\u2013309. Springer", "citeRegEx": "65", "shortCiteRegEx": null, "year": 2010}, {"title": "Beyond Soundness: on the Verification of Semantic Business", "author": ["I. Weber", "J. Hoffmann", "J. Mendling"], "venue": "Process Models. Distrib. Parallel Databases,", "citeRegEx": "66", "shortCiteRegEx": "66", "year": 2010}, {"title": "Reasoning about Action Using a Possible Models Approach", "author": ["M. Winslett"], "venue": "AAAI, pages 89\u201393. The MIT Press", "citeRegEx": "67", "shortCiteRegEx": null, "year": 1988}], "referenceMentions": [{"referenceID": 62, "context": "from a control flow perspective, with the aim of verifying whether the behavior of the modeled system presents logical errors (see, for instance, the notion of soundness [64]).", "startOffset": 170, "endOffset": 174}, {"referenceID": 31, "context": "The lack of a formal representation of the domain knowledge within process models is widely recognized as an obstacle for the further automation of BPM tools and methodologies that effectively support process analysis, retrieval, and reuse [32].", "startOffset": 240, "endOffset": 244}, {"referenceID": 31, "context": "In order to overcome this limitation, the application of well-established techniques stemming from the area of Knowledge Representation in the domains of BP modeling [32, 17, 36, 66] and Web Services [12, 22] has been shown to be a promising approach.", "startOffset": 166, "endOffset": 182}, {"referenceID": 16, "context": "In order to overcome this limitation, the application of well-established techniques stemming from the area of Knowledge Representation in the domains of BP modeling [32, 17, 36, 66] and Web Services [12, 22] has been shown to be a promising approach.", "startOffset": 166, "endOffset": 182}, {"referenceID": 35, "context": "In order to overcome this limitation, the application of well-established techniques stemming from the area of Knowledge Representation in the domains of BP modeling [32, 17, 36, 66] and Web Services [12, 22] has been shown to be a promising approach.", "startOffset": 166, "endOffset": 182}, {"referenceID": 64, "context": "In order to overcome this limitation, the application of well-established techniques stemming from the area of Knowledge Representation in the domains of BP modeling [32, 17, 36, 66] and Web Services [12, 22] has been shown to be a promising approach.", "startOffset": 166, "endOffset": 182}, {"referenceID": 11, "context": "In order to overcome this limitation, the application of well-established techniques stemming from the area of Knowledge Representation in the domains of BP modeling [32, 17, 36, 66] and Web Services [12, 22] has been shown to be a promising approach.", "startOffset": 200, "endOffset": 208}, {"referenceID": 21, "context": "In order to overcome this limitation, the application of well-established techniques stemming from the area of Knowledge Representation in the domains of BP modeling [32, 17, 36, 66] and Web Services [12, 22] has been shown to be a promising approach.", "startOffset": 200, "endOffset": 208}, {"referenceID": 55, "context": ", [57, 6, 44]) are very expressive formalisms that can be used to simultaneously capture the process and the domain knowledge, but they are too general to be applied to BP modeling, and must be suitably restricted not only towards decidability of reasoning but also to reflect the peculiarities of processes.", "startOffset": 2, "endOffset": 13}, {"referenceID": 5, "context": ", [57, 6, 44]) are very expressive formalisms that can be used to simultaneously capture the process and the domain knowledge, but they are too general to be applied to BP modeling, and must be suitably restricted not only towards decidability of reasoning but also to reflect the peculiarities of processes.", "startOffset": 2, "endOffset": 13}, {"referenceID": 43, "context": ", [57, 6, 44]) are very expressive formalisms that can be used to simultaneously capture the process and the domain knowledge, but they are too general to be applied to BP modeling, and must be suitably restricted not only towards decidability of reasoning but also to reflect the peculiarities of processes.", "startOffset": 2, "endOffset": 13}, {"referenceID": 37, "context": "To achieve this goal, we do not propose yet another business process modeling language, but we provide a framework based on Logic Programming (LP) [38] for reasoning about process-related knowledge expressed by means of de-facto standards for BP", "startOffset": 147, "endOffset": 151}, {"referenceID": 42, "context": "modeling, like BPMN [46], and ontology definition, like OWL [43].", "startOffset": 60, "endOffset": 64}, {"referenceID": 59, "context": "We define a rule-based procedural semantics for a relevant fragment of BPMN, by following an approach inspired by the Fluent Calculus [61], and we extend it in order to take into account OWL annotations that describe preconditions and effects of activities and events occurring within a BP.", "startOffset": 134, "endOffset": 138}, {"referenceID": 15, "context": "extended version of the Business Process Abstract Language (BPAL) [16, 56], a process ontology for modeling the procedural semantics of a BP regarded as a workflow.", "startOffset": 66, "endOffset": 74}, {"referenceID": 54, "context": "extended version of the Business Process Abstract Language (BPAL) [16, 56], a process ontology for modeling the procedural semantics of a BP regarded as a workflow.", "startOffset": 66, "endOffset": 74}, {"referenceID": 14, "context": "In Section 5 we provide a general verification mechanism by integrating the temporal logic CTL [15] within our framework, in order to analyze properties of the states that the system can reach, by taking into account both the control-flow and the semantic annotation.", "startOffset": 95, "endOffset": 99}, {"referenceID": 13, "context": "In Section 7 we provide the computational characterization of the reasoning services that can be performed on top of a BPKB, showing in particular that, for a large class of them, advanced resolution strategies (such as SLG-Resolution [14]) guarantee an efficient, sound and complete procedure.", "startOffset": 235, "endOffset": 239}, {"referenceID": 56, "context": "In Section 8 we describe the implemented tool, which provides a graphical user interface to support the semantic BP design, and a reasoner, developed in XSB Prolog [58], able to operate on the BPKB.", "startOffset": 164, "endOffset": 168}, {"referenceID": 3, "context": "In order to clarify the terminology and the notation used throughout this paper, in this section we recall some basic notions related to the BPMN notation [46], Description Logics [4] as well as foundations of the OWL [43] standard, and Logic Programming [38].", "startOffset": 180, "endOffset": 183}, {"referenceID": 42, "context": "In order to clarify the terminology and the notation used throughout this paper, in this section we recall some basic notions related to the BPMN notation [46], Description Logics [4] as well as foundations of the OWL [43] standard, and Logic Programming [38].", "startOffset": 218, "endOffset": 222}, {"referenceID": 37, "context": "In order to clarify the terminology and the notation used throughout this paper, in this section we recall some basic notions related to the BPMN notation [46], Description Logics [4] as well as foundations of the OWL [43] standard, and Logic Programming [38].", "startOffset": 255, "endOffset": 259}, {"referenceID": 3, "context": "Description Logics (DLs) [4] are a family of knowledge representation languages that can be used to represent the knowledge of an application domain in a structured and formally well-understood way.", "startOffset": 25, "endOffset": 28}, {"referenceID": 6, "context": "The growing interest in the Semantic Web vision [7], where Knowledge Representation techniques are adopted to make resources machine-interpretable by \u201cintelligent agents\u201d, has pushed the standardization of languages for ontology and meta-data sharing over the (semantic) web.", "startOffset": 48, "endOffset": 51}, {"referenceID": 42, "context": "Among these, one of the most promising standards is the Ontology Web Language (OWL) [43], formally grounded in DLs, proposed by the Web Ontology Working Group of W3C.", "startOffset": 84, "endOffset": 88}, {"referenceID": 33, "context": "OWL is syntactically layered on RDF [34] and RDFS [10], and can be considered as an extension of RDFS in terms of modeling capabilities and reasoning facilities.", "startOffset": 36, "endOffset": 40}, {"referenceID": 9, "context": "OWL is syntactically layered on RDF [34] and RDFS [10], and can be considered as an extension of RDFS in terms of modeling capabilities and reasoning facilities.", "startOffset": 50, "endOffset": 54}, {"referenceID": 27, "context": "In particular, we consider OWL 2 RL, closely related to the Horn fragment of FOL, which is based on Description Logic Programs [28] and pD* [59].", "startOffset": 127, "endOffset": 131}, {"referenceID": 57, "context": "In particular, we consider OWL 2 RL, closely related to the Horn fragment of FOL, which is based on Description Logic Programs [28] and pD* [59].", "startOffset": 140, "endOffset": 144}, {"referenceID": 37, "context": "For more details about LP we refer to [38, 2].", "startOffset": 38, "endOffset": 45}, {"referenceID": 1, "context": "For more details about LP we refer to [38, 2].", "startOffset": 38, "endOffset": 45}, {"referenceID": 1, "context": "A (local) stratification is a function \u03c3 from the Herbrand base BP to the set of all countable ordinals [2, 50].", "startOffset": 104, "endOffset": 111}, {"referenceID": 48, "context": "A (local) stratification is a function \u03c3 from the Herbrand base BP to the set of all countable ordinals [2, 50].", "startOffset": 104, "endOffset": 111}, {"referenceID": 37, "context": "is constructed by SLD-resolution augmented with the Negation as Failure rule [38].", "startOffset": 77, "endOffset": 81}, {"referenceID": 37, "context": "\u2227Km (m \u2265 0) is a rule in P such that A is unifiable with H via a most general unifier \u03b8 [38].", "startOffset": 88, "endOffset": 92}, {"referenceID": 48, "context": "Indeed, it can be shown that (see, for instance, [50, 2]), given a program P and an atom A0 that does not flounder with respect to P , then: (1) if A0 succeeds with answer \u03b8, then every ground instance of A0\u03b8 belongs to Perf(P ), and (2) if A0\u03b8 belongs to Perf(P ) for some substitution \u03b8, then A0 succeeds with an answer which is more general than \u03b8.", "startOffset": 49, "endOffset": 56}, {"referenceID": 1, "context": "Indeed, it can be shown that (see, for instance, [50, 2]), given a program P and an atom A0 that does not flounder with respect to P , then: (1) if A0 succeeds with answer \u03b8, then every ground instance of A0\u03b8 belongs to Perf(P ), and (2) if A0\u03b8 belongs to Perf(P ) for some substitution \u03b8, then A0 succeeds with an answer which is more general than \u03b8.", "startOffset": 49, "endOffset": 56}, {"referenceID": 13, "context": "In order to avoid this difficulty, in this paper we adopt SLG-resolution, a query evaluation mechanism that implements SLD resolution with Negation as Failure by means of tabling [14].", "startOffset": 179, "endOffset": 183}, {"referenceID": 45, "context": ", BPMN [46], UML activity diagrams [47], EPC [33]) and, in particular, it is based on the BPMN 2.", "startOffset": 35, "endOffset": 39}, {"referenceID": 32, "context": ", BPMN [46], UML activity diagrams [47], EPC [33]) and, in particular, it is based on the BPMN 2.", "startOffset": 45, "endOffset": 49}, {"referenceID": 15, "context": "An extended discussion can be found in [16, 55].", "startOffset": 39, "endOffset": 47}, {"referenceID": 53, "context": "An extended discussion can be found in [16, 55].", "startOffset": 39, "endOffset": 47}, {"referenceID": 15, "context": "With respect to the framework introduced in [16, 55], here we consider unstructured cyclic workflows whose behavioral semantics will be introduced in the following.", "startOffset": 44, "endOffset": 52}, {"referenceID": 53, "context": "With respect to the framework introduced in [16, 55], here we consider unstructured cyclic workflows whose behavioral semantics will be introduced in the following.", "startOffset": 44, "endOffset": 52}, {"referenceID": 59, "context": "Now we present a formal definition of the behavioral semantics, or enactment, of a BPS, by following an approach inspired by the Fluent Calculus, a well-known calculus for action and change (see [61] for an introduction), which is formalized in Logic Programming.", "startOffset": 195, "endOffset": 199}, {"referenceID": 59, "context": "For states we use set notation (here we depart from [61], where an associative-commutative operator is used for representing collections of fluents).", "startOffset": 52, "endOffset": 56}, {"referenceID": 62, "context": "Our set-based representation of states relies on the assumption that the BPS is safe, that is, during its enactment there are no concurrent executions of the same flow element [64].", "startOffset": 176, "endOffset": 180}, {"referenceID": 32, "context": ", [33, 65]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 63, "context": ", [33, 65]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 63, "context": "Here we refer to the semantics described in [65] adopted by BPMN, stating that (Rule O1) an inclusive merge M can be executed if the following two conditions hold (Rules O2, O3):", "startOffset": 44, "endOffset": 48}, {"referenceID": 31, "context": "Similarly to proposals like Semantic BPM [32] and Semantic Web Services [22], we will make use of semantic annotations to enrich the procedural knowledge specified by a BPS with domain knowledge expressed in terms of a given business reference ontology.", "startOffset": 41, "endOffset": 45}, {"referenceID": 21, "context": "Similarly to proposals like Semantic BPM [32] and Semantic Web Services [22], we will make use of semantic annotations to enrich the procedural knowledge specified by a BPS with domain knowledge expressed in terms of a given business reference ontology.", "startOffset": 72, "endOffset": 76}, {"referenceID": 27, "context": "The translation into triple form can be done automatically as shown in [28, 59].", "startOffset": 71, "endOffset": 79}, {"referenceID": 57, "context": "The translation into triple form can be done automatically as shown in [28, 59].", "startOffset": 71, "endOffset": 79}, {"referenceID": 42, "context": "We refer the reader to [43] for the", "startOffset": 23, "endOffset": 27}, {"referenceID": 42, "context": "Without loss of generality, unlike [43], we encode binary intersection instead of a general n-ary operator.", "startOffset": 35, "endOffset": 39}, {"referenceID": 39, "context": "The Frame Problem was formulated in [40] as the problem of \u201cexpressing a dynamical domain in logic without explicitly specifying which conditions are not affected by an action\u201d.", "startOffset": 36, "endOffset": 40}, {"referenceID": 60, "context": "The Fluent Calculus addresses both the representational and inferential aspects of the Frame Problem [62] by modeling change as the difference between two states, caused by actions that deterministically result in a bounded number of direct (positive and negative) effects.", "startOffset": 101, "endOffset": 105}, {"referenceID": 25, "context": "The Ramification Problem [26] is the problem of representing and inferring informa-", "startOffset": 25, "endOffset": 29}, {"referenceID": 65, "context": ", the Possible Model Approach - PMA [67]).", "startOffset": 36, "endOffset": 40}, {"referenceID": 58, "context": "Another solution proposed in the context of the Fluent Calculus, is based on causal propagations regulated by causal relationships [60], which specify how indirect effects are derived from direct effects and domain axioms.", "startOffset": 131, "endOffset": 135}, {"referenceID": 14, "context": "section we propose a model checking methodology based on a formalization of the temporal logic CTL (Computation Tree Logic, see [15] for a comprehensive overview) as a set of rules.", "startOffset": 128, "endOffset": 132}, {"referenceID": 23, "context": "a very natural choice [24, 37].", "startOffset": 22, "endOffset": 30}, {"referenceID": 36, "context": "a very natural choice [24, 37].", "startOffset": 22, "endOffset": 30}, {"referenceID": 14, "context": ", EF(F ) \u2261 EU(true, F ) and AG(F ) \u2261 \u00acEF(\u00acF ) [15].", "startOffset": 46, "endOffset": 50}, {"referenceID": 14, "context": "Usually, the semantics of CTL formulas is defined by introducing a Kripke structure K, which represents the state space and the state transition relation, and by defining the satisfaction relation K, s |= F , which denotes that a formula F holds in a state s of K [15].", "startOffset": 264, "endOffset": 268}, {"referenceID": 14, "context": "In the definition of Kripke structure given in [15], the transition relation R is assumed to be total, that is, every state S1 has at least one successor state S2 for which R(S1, S2) holds.", "startOffset": 47, "endOffset": 51}, {"referenceID": 14, "context": "For this reason the semantics of the temporal operators given in [15], which refers to infinite paths of the Kripke structure, is suitably changed here, according to [3], by taking into consideration maximal paths, i.", "startOffset": 65, "endOffset": 69}, {"referenceID": 2, "context": "For this reason the semantics of the temporal operators given in [15], which refers to infinite paths of the Kripke structure, is suitably changed here, according to [3], by taking into consideration maximal paths, i.", "startOffset": 166, "endOffset": 169}, {"referenceID": 44, "context": "The rules defining the semantics of the operator EG are similar to the constraint logic programming definition proposed in [45].", "startOffset": 123, "endOffset": 127}, {"referenceID": 44, "context": "Similarly to [45], our definition of the semantics of EG avoids the introduction of greatest fixed points of operators on sets of states which are often required by the approach described in [15].", "startOffset": 13, "endOffset": 17}, {"referenceID": 14, "context": "Similarly to [45], our definition of the semantics of EG avoids the introduction of greatest fixed points of operators on sets of states which are often required by the approach described in [15].", "startOffset": 191, "endOffset": 195}, {"referenceID": 37, "context": ", the least Herbrand model [38]).", "startOffset": 27, "endOffset": 31}, {"referenceID": 14, "context": "g, EF and AG, follows from the equivalences defining them [15].", "startOffset": 58, "endOffset": 62}, {"referenceID": 2, "context": "It is worth noting that in some special cases the assumption that paths are maximal, but not necessarily infinite, matters [3].", "startOffset": 123, "endOffset": 126}, {"referenceID": 14, "context": "Finally, we would like to note that the definition of the CTL semantics given here is equivalent to the one in [15] in the presence of infinite computation paths only.", "startOffset": 111, "endOffset": 115}, {"referenceID": 62, "context": "This property, also known as option to complete [64], can be specified by the following rule, stating that the property opt com holds if the CTL property AG(EF(final(p))) holds in the initial state of p:", "startOffset": 48, "endOffset": 52}, {"referenceID": 64, "context": "(3) Another relevant property of a BPS is executability [66], according to which no activity reached by the control flow should be unable to execute due to some unsatisfied enabling condition.", "startOffset": 56, "endOffset": 60}, {"referenceID": 37, "context": "In [38] a sufficient condition ensuring that a query does not flounder is based on the notion of allowed query and rule.", "startOffset": 3, "endOffset": 7}, {"referenceID": 37, "context": "Unfortunately, not all rules in KB are allowed in the sense of [38].", "startOffset": 63, "endOffset": 67}, {"referenceID": 0, "context": "This classification is often called a mode [1].", "startOffset": 43, "endOffset": 46}, {"referenceID": 0, "context": "The following notion is adapted from [1].", "startOffset": 37, "endOffset": 40}, {"referenceID": 13, "context": "This property is equivalent to the bounded-term-size property that in [14] has been shown to be a sufficient condition for termination of SLG-resolution [14].", "startOffset": 70, "endOffset": 74}, {"referenceID": 13, "context": "This property is equivalent to the bounded-term-size property that in [14] has been shown to be a sufficient condition for termination of SLG-resolution [14].", "startOffset": 153, "endOffset": 157}, {"referenceID": 13, "context": "3 in [14].", "startOffset": 5, "endOffset": 9}, {"referenceID": 14, "context": "However, it is sufficient for showing that, in line with the complexity of the CTL verification problem [15], our verification method has polynomial running time with respect to the number of states that are potentially reachable during process enactment.", "startOffset": 104, "endOffset": 108}, {"referenceID": 13, "context": "A tighter complexity analysis could be done by directly analyzing the evaluation of queries with respect to KB, instead of relying, as done above, on the general results provided by [14].", "startOffset": 182, "endOffset": 186}, {"referenceID": 53, "context": "QuBPAL is an expressive query language for a BPKB based on the theoretical framework presented in this paper (a preliminary specification has been discussed in [55]).", "startOffset": 160, "endOffset": 164}, {"referenceID": 47, "context": "It is worth noting that the representation of OWL/RDFS resources as sets of triples, which directly encode the underlining RDF graph, allows us to pose queries over the ontology in a form very close to the SPARQL (SPARQL Protocol and RDF Query Language) standard [49], defined by the World Wide Web Consortium and widely accepted in the Semantic Web community.", "startOffset": 263, "endOffset": 267}, {"referenceID": 56, "context": "This component implements the reasoning methods described in Section 6 by using the XSB Prolog6 system [58], which is a Logic Programming system based on the SLGresolution inference strategy recalled in Section 2.", "startOffset": 103, "endOffset": 107}, {"referenceID": 62, "context": "defining a formal semantics of BP models, Petri nets [64] are the most used paradigm to capture the execution semantics of graph-based procedural languages (the BPMN case is discussed in [20]).", "startOffset": 53, "endOffset": 57}, {"referenceID": 19, "context": "defining a formal semantics of BP models, Petri nets [64] are the most used paradigm to capture the execution semantics of graph-based procedural languages (the BPMN case is discussed in [20]).", "startOffset": 187, "endOffset": 191}, {"referenceID": 23, "context": ", [24, 37].", "startOffset": 2, "endOffset": 10}, {"referenceID": 36, "context": ", [24, 37].", "startOffset": 2, "endOffset": 10}, {"referenceID": 14, "context": "state models through model checking techniques [15], where queries, formulated in some temporal logics, specify properties of process executions.", "startOffset": 47, "endOffset": 51}, {"referenceID": 26, "context": "Other approaches based on Logic Programming that are worth mentioning are [27, 53, 42].", "startOffset": 74, "endOffset": 86}, {"referenceID": 51, "context": "Other approaches based on Logic Programming that are worth mentioning are [27, 53, 42].", "startOffset": 74, "endOffset": 86}, {"referenceID": 41, "context": "Other approaches based on Logic Programming that are worth mentioning are [27, 53, 42].", "startOffset": 74, "endOffset": 86}, {"referenceID": 26, "context": "[27] presents an approach to BP verification based on an extension of answer set programming with temporal logic and constraints, where the compliance of business rules is checked by bounded model checking techniques extended with constraint solving for dealing with conditions on numeric data.", "startOffset": 0, "endOffset": 4}, {"referenceID": 51, "context": "[53, 42] mainly focus on the analysis and on the enactment of flow models representing service choreographies, while we are not aware of specific extensions that deal with the semantic annotation of procedural process models with respect to domain ontologies.", "startOffset": 0, "endOffset": 8}, {"referenceID": 41, "context": "[53, 42] mainly focus on the analysis and on the enactment of flow models representing service choreographies, while we are not aware of specific extensions that deal with the semantic annotation of procedural process models with respect to domain ontologies.", "startOffset": 0, "endOffset": 8}, {"referenceID": 64, "context": "There is a growing body of contributions beyond pure control flow verification [66, 25, 41, 19].", "startOffset": 79, "endOffset": 95}, {"referenceID": 24, "context": "There is a growing body of contributions beyond pure control flow verification [66, 25, 41, 19].", "startOffset": 79, "endOffset": 95}, {"referenceID": 40, "context": "There is a growing body of contributions beyond pure control flow verification [66, 25, 41, 19].", "startOffset": 79, "endOffset": 95}, {"referenceID": 18, "context": "There is a growing body of contributions beyond pure control flow verification [66, 25, 41, 19].", "startOffset": 79, "endOffset": 95}, {"referenceID": 64, "context": "In [66] the authors introduce the notion of Semantic Business Process Validation, which aims at verifying properties related to the absence of logical errors which extend the notion of workflow soundness [64].", "startOffset": 3, "endOffset": 7}, {"referenceID": 62, "context": "In [66] the authors introduce the notion of Semantic Business Process Validation, which aims at verifying properties related to the absence of logical errors which extend the notion of workflow soundness [64].", "startOffset": 204, "endOffset": 208}, {"referenceID": 24, "context": "BP analysis techniques based on logical descriptions of effects of task execution are also proposed in [25, 41], but they introduce algorithms in an informal way, since a formal execution semantics is not provided, and a background ontology is not considered.", "startOffset": 103, "endOffset": 111}, {"referenceID": 40, "context": "BP analysis techniques based on logical descriptions of effects of task execution are also proposed in [25, 41], but they introduce algorithms in an informal way, since a formal execution semantics is not provided, and a background ontology is not considered.", "startOffset": 103, "endOffset": 111}, {"referenceID": 18, "context": "In [19] the authors discuss a CTL model checking method for annotated state transition systems, encoding the procedural behavior of Web Services interactions.", "startOffset": 3, "endOffset": 7}, {"referenceID": 12, "context": "Finally, we would like to mention a related research area, dealing with the verification of temporal properties in databases that evolve over time due to execution of actions operating on data (see [13] for a survey).", "startOffset": 198, "endOffset": 202}, {"referenceID": 29, "context": "Recently, [30] proposed Knowledge and Action", "startOffset": 10, "endOffset": 14}, {"referenceID": 29, "context": "While the main goal of [30] is to provide theoretical results that characterize the decidability and (very high) complexity of KAB reasoning, our objective is more pragmatic and our formalization enables the implementation, through standard LP engines, of a wider set of (polynomial time) reasoning services, besides the verification of temporal properties.", "startOffset": 23, "endOffset": 27}, {"referenceID": 8, "context": "The Process Specification Language (PSL) [9] is an ontology designed to formalize reasoning about processes in first-order logic.", "startOffset": 41, "endOffset": 44}, {"referenceID": 49, "context": "The basic structure that characterizes the behavior of a process in PSL is the occurrence tree (whose model is inspired by the Situation Calculus [51]), which contains all (infinite) sequences of occurrences of atomic activities starting from an initial state.", "startOffset": 146, "endOffset": 150}, {"referenceID": 16, "context": ", BPMN [17]), EPC [63], XPDL [29], Petri nets [11], while others have been designed in the context of interoperability, to overcome heterogeneities deriving from the adoption of different languages by mapping them to one common process ontology (e.", "startOffset": 7, "endOffset": 11}, {"referenceID": 61, "context": ", BPMN [17]), EPC [63], XPDL [29], Petri nets [11], while others have been designed in the context of interoperability, to overcome heterogeneities deriving from the adoption of different languages by mapping them to one common process ontology (e.", "startOffset": 18, "endOffset": 22}, {"referenceID": 28, "context": ", BPMN [17]), EPC [63], XPDL [29], Petri nets [11], while others have been designed in the context of interoperability, to overcome heterogeneities deriving from the adoption of different languages by mapping them to one common process ontology (e.", "startOffset": 29, "endOffset": 33}, {"referenceID": 10, "context": ", BPMN [17]), EPC [63], XPDL [29], Petri nets [11], while others have been designed in the context of interoperability, to overcome heterogeneities deriving from the adoption of different languages by mapping them to one common process ontology (e.", "startOffset": 46, "endOffset": 50}, {"referenceID": 35, "context": ", GPO [36], BPMO [21]).", "startOffset": 6, "endOffset": 10}, {"referenceID": 20, "context": ", GPO [36], BPMO [21]).", "startOffset": 17, "endOffset": 21}, {"referenceID": 11, "context": "Another stream of related papers regards the semantic enrichment of Web Services, where relevant work has been done within the OWL-S [12] and WSMO [52] initiatives.", "startOffset": 133, "endOffset": 137}, {"referenceID": 50, "context": "Another stream of related papers regards the semantic enrichment of Web Services, where relevant work has been done within the OWL-S [12] and WSMO [52] initiatives.", "startOffset": 147, "endOffset": 151}, {"referenceID": 55, "context": "Among them, [57] adopts the high-level agent programming language Golog [51], [6, 44] rely on Situation Calculus variants, while [8, 5] are based on a direct translation of OWL-based service description into a Fluent Calculus theory.", "startOffset": 12, "endOffset": 16}, {"referenceID": 49, "context": "Among them, [57] adopts the high-level agent programming language Golog [51], [6, 44] rely on Situation Calculus variants, while [8, 5] are based on a direct translation of OWL-based service description into a Fluent Calculus theory.", "startOffset": 72, "endOffset": 76}, {"referenceID": 5, "context": "Among them, [57] adopts the high-level agent programming language Golog [51], [6, 44] rely on Situation Calculus variants, while [8, 5] are based on a direct translation of OWL-based service description into a Fluent Calculus theory.", "startOffset": 78, "endOffset": 85}, {"referenceID": 43, "context": "Among them, [57] adopts the high-level agent programming language Golog [51], [6, 44] rely on Situation Calculus variants, while [8, 5] are based on a direct translation of OWL-based service description into a Fluent Calculus theory.", "startOffset": 78, "endOffset": 85}, {"referenceID": 7, "context": "Among them, [57] adopts the high-level agent programming language Golog [51], [6, 44] rely on Situation Calculus variants, while [8, 5] are based on a direct translation of OWL-based service description into a Fluent Calculus theory.", "startOffset": 129, "endOffset": 135}, {"referenceID": 4, "context": "Among them, [57] adopts the high-level agent programming language Golog [51], [6, 44] rely on Situation Calculus variants, while [8, 5] are based on a direct translation of OWL-based service description into a Fluent Calculus theory.", "startOffset": 129, "endOffset": 135}, {"referenceID": 30, "context": "gree of community consensus, and can thus be valuable input for creating business domain ontologies [31].", "startOffset": 100, "endOffset": 104}, {"referenceID": 38, "context": "zational and data models) into formal theories [39].", "startOffset": 47, "endOffset": 51}, {"referenceID": 17, "context": "Finally, approaches based on information retrieval and linguistic analysis can also be applied to support the annotation, suggesting correspondences between activity labels and terms defined in an ontology [18].", "startOffset": 206, "endOffset": 210}, {"referenceID": 46, "context": "We are confident that the query evaluation process can be strongly improved through more sophisticated query rewriting and program transformation techniques [48], which have been largely investigated in the area of Logic Programming.", "startOffset": 157, "endOffset": 161}, {"referenceID": 34, "context": "in [35]; (iii) verification techniques for BPs in the presence of data constraints, by following approaches based on Constraint Logic Programming such as, for instance, the one proposed in [23].", "startOffset": 3, "endOffset": 7}, {"referenceID": 22, "context": "in [35]; (iii) verification techniques for BPs in the presence of data constraints, by following approaches based on Constraint Logic Programming such as, for instance, the one proposed in [23].", "startOffset": 189, "endOffset": 193}, {"referenceID": 52, "context": "The query-based support to process composition discussed in [54] represents a first contribution in that direction.", "startOffset": 60, "endOffset": 64}], "year": 2014, "abstractText": "We propose a framework grounded in Logic Programming for representing and reasoning about business processes from both the procedural and ontological point of views. In particular, our goal is threefold: (1) define a logical language and a formal semantics for process models enriched with ontology-based annotations; (2) provide an effective inference mechanism that supports the combination of reasoning services dealing with the structural definition of a process model, its behavior, and the domain knowledge related to the participating business entities; (3) implement such a theoretical framework into a process modeling and reasoning platform. To this end we define a process ontology coping with a relevant fragment of the popular BPMN modeling notation. The behavioral semantics of a process is defined as a state transition system by following an approach similar to the Fluent Calculus, and allows us to specify state change in terms of preconditions and effects of the enactment of activities. Then we show how the procedural process knowledge can be seamlessly integrated with the domain knowledge specified by using the OWL 2 RL rule-based ontology language. Our framework provides a wide range of reasoning services, including CTL model checking, which can be performed by using standard Logic Programming inference engines through a goal-oriented, efficient, sound and complete evaluation procedure. We also present a software environment implementing the proposed framework, and we report on an experimental evaluation of the system, whose results are encouraging and show the viability of the approach.", "creator": "LaTeX with hyperref package"}}}