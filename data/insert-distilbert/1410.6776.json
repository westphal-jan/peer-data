{"id": "1410.6776", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Oct-2014", "title": "Online and Stochastic Gradient Methods for Non-decomposable Loss Functions", "abstract": "modern applications in sensitive domains such as biometrics and medicine frequently require careful the use of non - decomposable loss functions such as estimated precision @ k, f - stat measure etc. again compared to point loss functions such as hinge - loss, these features offer much more fine grained accuracy control over prediction, but at the same time present novel research challenges in terms of reverse algorithm design and analysis. in this work we initiate a study of online learning techniques for such non - decomposable loss functions with an aim to dramatically enable incremental learning as well as facilitate design scalable solvers for batch problems. to this end, we propose an online immersion learning framework for such loss functions. our model enjoys several nice properties, chief amongst them being the existence of efficient integrated online classical learning algorithms with sublinear difficulty regret and online to batch conversion bounds. our resulting model then is a provable extension of existing online learning models for point loss functions. we instantiate two popular losses, below prec @ k and pauc, in particular our learning model and prove sublinear regret bounds for both of them. our proofs require a novel structural lemma derived over ranked lists inputs which may be of independent interest. we then develop scalable stochastic gradient descent random solvers for non - decomposable loss functions. likewise we show that for scaling a large family of cumulative loss functions simultaneously satisfying a certain uniform convergence property ( that includes prec @ k, pauc, and f - measure ), our methods provably converge to the empirical risk minimizer. such uniform convergence bias results were not known for these losses and we establish below these using novel proof techniques. we nevertheless then use extensive cognitive experimentation on real life patterns and benchmark datasets to establish that our method can be orders of relative magnitude consistently faster than a small recently proposed cutting plane method.", "histories": [["v1", "Fri, 24 Oct 2014 18:45:23 GMT  (50kb,D)", "http://arxiv.org/abs/1410.6776v1", "25 pages, 3 figures, To appear in the proceedings of the 28th Annual Conference on Neural Information Processing Systems, NIPS 2014"]], "COMMENTS": "25 pages, 3 figures, To appear in the proceedings of the 28th Annual Conference on Neural Information Processing Systems, NIPS 2014", "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["purushottam kar", "harikrishna narasimhan", "prateek jain 0002"], "accepted": true, "id": "1410.6776"}, "pdf": {"name": "1410.6776.pdf", "metadata": {"source": "CRF", "title": "Online and Stochastic Gradient Methods for Non-decomposable Loss Functions", "authors": ["Purushottam Kar", "Harikrishna Narasimhan", "Prateek Jain"], "emails": ["t-purkar@microsoft.com,", "prajain@microsoft.com,", "harikrishna@csa.iisc.ernet.in", "precision@k,", "Prec@k", "Prec@k,", "Precision@k,"], "sections": [{"heading": "1 Introduction", "text": "Modern learning applications frequently require a level of fine-grained control over prediction performance that is not offered by traditional \u201cper-point\u201d performance measures such as hinge loss. Examples include datasets with mild to severe label imbalance such as spam classification wherein positive instances (spam emails) constitute a tiny fraction of the available data, and learning tasks such as those in medical diagnosis which make it imperative for learning algorithms to be sensitive to class imbalances. Other popular examples include ranking tasks where precision in the top ranked results is valued more than overall precision/recall characteristics. The performance measures of choice in these situations are those that evaluate algorithms over the entire dataset in a holistic manner. Consequently, these measures are frequently non-decomposable over data points.\nar X\niv :1\n41 0.\n67 76\nv1 [\ncs .L\nG ]\n2 4\nO ct\nMore specifically, for these measures, the loss on a set of points cannot be expressed as the sum of losses on individual data points (unlike hinge loss, for example). Popular examples of such measures include F-measure, Precision@k, (partial) area under the ROC curve etc.\nDespite their success in these domains, non-decomposable loss functions are not nearly as well understood as their decomposable counterparts. The study of point loss functions has led to a deep understanding about their behavior in batch and online settings and tight characterizations of their generalization abilities. The same cannot be said for most non-decomposable losses. For instance, in the popular online learning model, it is difficult to even instantiate a non-decomposable loss function as defining the per-step penalty itself becomes a challenge."}, {"heading": "1.1 Our Contributions", "text": "Our first main contribution is a framework for online learning with non-decomposable loss functions. The main hurdle in this task is a proper definition of instantaneous penalties for non-decomposable losses. Instead of resorting to canonical definitions, we set up our framework in a principled way that fulfills the objectives of an online model. Our framework has a very desirable characteristic that allows it to recover existing online learning models when instantiated with point loss functions. Our framework also admits online-to-batch conversion bounds.\nWe then propose an efficient Follow-the-Regularized-Leader [1] algorithm within our framework. We show that for loss functions that satisfy a generic \u201cstability\u201d condition, our algorithm is able to offer vanishing O (\n1\u221a T\n) regret. Next, we instantiate within our framework, convex surrogates\nfor two popular performances measures namely, Precision at k (Prec@k) and partial area under the ROC curve (pAUC) [2] and show, via a stability analysis, that we do indeed achieve sublinear regret bounds for these loss functions. Our stability proofs involve a structural lemma on sorted lists of inner products which proves Lipschitz continuity properties for measures on such lists (see Lemma 2) and might be useful for analyzing non-decomposable loss functions in general.\nA key property of online learning methods is their applicability in designing solvers for offline/batch problems. With this goal in mind, we design a stochastic gradient-based solver for non-decomposable loss functions. Our methods apply to a wide family of loss functions (including Prec@k, pAUC and F-measure) that were introduced in [3] and have been widely adopted [4, 5, 6] in the literature. We design several variants of our method and show that our methods provably converge to the empirical risk minimizer of the learning instance at hand. Our proofs involve uniform convergence-style results which were not known for the loss functions we study and require novel techniques, in particular the structural lemma mentioned above.\nFinally, we conduct extensive experiments on real life and benchmark datasets with pAUC and Prec@k as performance measures. We compare our methods to state-of-the-art methods that are based on cutting plane techniques [7]. The results establish that our methods can be significantly faster, all the while offering comparable or higher accuracy values. For example, on a KDD 2008 challenge dataset, our method was able to achieve a pAUC value of 64.8% within 30ms whereas it took the cutting plane method more than 1.2 seconds to achieve a comparable performance."}, {"heading": "1.2 Related Work", "text": "Non decomposable loss functions such as Prec@k, (partial) AUC, F-measure etc, owing to their demonstrated ability to give better performance in situations with label imbalance etc, have generated significant interest within the learning community. From their role in early works as indicators\nof performance on imbalanced datasets [8], their importance has risen to a point where they have become the learning objectives themselves. Due to their complexity, methods that try to indirectly optimize these measures are very common e.g. [9], [10] and [11] who study the F-measure. However, such methods frequently seek to learn a complex probabilistic model, a task arguably harder than the one at hand itself. On the other hand are algorithms that perform optimization directly via structured losses. Starting from the seminal work of [3], this method has received a lot of interest for measures such as the F-measure [3], average precision [4], pAUC [7] and various ranking losses [5, 6]. These formulations typically use cutting plane methods to design dual solvers.\nWe note that the learning and game theory communities are also interested in non-additive notions of regret and utility. In particular [12] provides a generic framework for online learning with non-additive notions of regret with a focus on showing regret bounds for mixed strategies in a variety of problems. However, even polynomial time implementation of their strategies is difficult in general. Our focus, on the other hand, is on developing efficient online algorithms that can be used to solve large scale batch problems. Moreover, it is not clear how (if at all) can the loss functions considered here (such as Prec@k) be instantiated in their framework.\nRecently, online learning for AUC maximization has received some attention [13, 14]. Although AUC is not a point loss function, it still decomposes over pairs of points in a dataset, a fact that [13] and [14] crucially use. The loss functions in this paper do not exhibit any such decomposability."}, {"heading": "2 Problem Formulation", "text": "Let x1:t := {x1, . . . ,xt}, xi \u2208 Rd and y1:t := {y1, . . . , yt}, yi \u2208 {\u22121, 1} be the observed data points and true binary labels. We will use y\u03021:t := {y\u03021, . . . , y\u0302t}, y\u0302i \u2208 R to denote the predictions of a learning algorithm. We shall, for sake of simplicity, restrict ourselves to linear predictors y\u0302i = w\n>xi for parameter vectors w \u2208 Rd. A performance measure P : {\u22121, 1}t \u00d7 Rt \u2192 R+ shall be used to evaluate the the predictions of the learning algorithm against the true labels. Our focus shall be on non-decomposable performance measures such as Prec@k, partial AUC etc.\nSince these measures are typically non-convex, convex surrogate loss functions are used instead (we will use the terms loss function and performance measure interchangeably). A popular technique for constructing such loss functions is the structural SVM formulation [3] given below. For simplicity, we shall drop mention of the training points and use the notation `P(w) := `P(x1:T , y1:T ,w).\n`P(w) = max y\u0304\u2208{\u22121,+1}T T\u2211 i=1 (y\u0304i \u2212 yi)x>i w \u2212 P(y\u0304,y). (1)\nPrecision@k. The Prec@k measure ranks the data points in order of the predicted scores y\u0302i and then returns the number of true positives in the top ranked positions. This is valuable in situations where there are very few positives. To formalize this, for any predictor w and set of points x1:t, define S(x,w) := {j : w>x > w>xj} to be the set of points which w ranks above x. Then define\nT\u03b2,t(x,w) = { 1, if |S(x,w)| < d\u03b2te, 0, otherwise.\n(2)\ni.e. T\u03b2,t(x,w) is non-zero iff x is in the top-\u03b2 fraction of the set. Then we define1\nPrec@k(w) := \u2211\nj:Tk,t(xj ,w)=1\nI [yj = 1] .\nThe structural surrogate for this measure is then calculated as 2\n`Prec@k(w) = max y\u0304\u2208{\u22121,+1}t\u2211 i(y\u0304i+1)=2kt\nt\u2211 i=1 (y\u0304i \u2212 yi)xTi w \u2212 t\u2211 i=1 yiy\u0304i. (3)\nPartial AUC. This measures the area under the ROC curve with the false positive rate restricted to the range [0, \u03b2]. This is in contrast to AUC that allows false positive range in [0, 1]. pAUC is useful in medical applications such as cancer detection where a small false positive rate is desirable. Let us extend notation to use T\u2212\u03b2,t(x,w) to denote the indicator that selects the top \u03b2 fraction of the negatively labeled points i.e. T\u2212\u03b2,t(x,w) = 1 iff\n\u2223\u2223{j : yj < 0,w>x > w>xj}\u2223\u2223 \u2264 d\u03b2t\u2212e where t\u2212 is the number of negatives. Then we define\npAUC(w) = \u2211 i:yi>0 \u2211 j:yj<0 T\u2212\u03b2,t(xj ,w) \u00b7 I[x > i w \u2265 x>j w]. (4)\nThe structural surrogate for this performance measure can be equivalently expressed in a simpler form by replacing the indicator functions I [\u00b7] with hinge loss as follows (see [7], Theorem 4)\n`pAUC(w) = \u2211 i:yi>0 \u2211 j:yj<0 T\u2212\u03b2,t(xj ,w) \u00b7 h(x > i w \u2212 x>j w), (5)\nwhere h(c) = max(0, 1\u2212 c) is the hinge loss function. In the next section we will develop an online learning framework for non-decomposable performance measures and instantiate our framework with the above mentioned loss functions `Prec@k and `pAUC. Then in Section 4, we will develop stochastic gradient methods for non-decomposable loss functions and prove error bounds for the same. There we will focus on a much larger family of loss functions including Prec@k, pAUC and F-measure."}, {"heading": "3 Online Learning with Non-decomposable Loss Functions", "text": "We now present our online learning framework for non-decomposable loss functions. Traditional online learning takes place in several rounds, in each of which the player proposes some wt \u2208 W while the adversary responds with a penalty function Lt : W \u2192 R and a loss Lt(wt) is incurred. The goal is to minimize the regret i.e. \u2211T t=1 Lt(wt) \u2212 arg minw\u2208W \u2211T t=1 Lt(w). For point loss functions, the instantaneous penalty Lt(\u00b7) is encoded using a data point (xt, yt) \u2208 Rd \u00d7 {\u22121, 1} as Lt(w) = `P(xt, yt,w). However, for (surrogates of) non-decomposable loss functions such as `pAUC and `Prec@k the definition of instantaneous penalty itself is not clear and remains a challenge.\nTo guide us in this process we turn to some properties of standard online learning frameworks. For point losses, we note that the best solution in hindsight is also the batch optimal solution. This\n1An equivalent definition considers k to be the number of top ranked points instead. 2[3] uses a slightly modified, but equivalent, definition that considers labels to be Boolean.\nis equivalent to the condition arg minw\u2208W \u2211T\nt=1 Lt(w) = arg minw\u2208W `P(x1:T , y1:T ,w) for nondecomposable losses. Also, since the batch optimal solution is agnostic to the ordering of points, we should expect \u2211T t=1 Lt(w) to be invariant to permutations within the stream. By pruning away several naive definitions of Lt using these requirements, we arrive at the following definition:\nLt(w) = `P(x1:t, y1:t,w)\u2212 `P(x1:(t\u22121), y1:(t\u22121),w). (6)\nIt turns out that the above is a very natural penalty function as it measures the amount of \u201cextra\u201d penalty incurred due to the inclusion of xt into the set of points. It can be readily verified that \u2211T t=1 Lt(w) = `P(x1:T , y1:T ,w) as required. Also, this penalty function seamlessly generalizes\nonline learning frameworks since for point losses, we have `P(x1:t, y1:t,w) = \u2211t\ni=1 `P(xi, yi,w) and thus Lt(w) = `P(xt, yt,w). We note that our framework also recovers the model for online AUC maximization used in [13] and [14]. The notion of regret corresponding to this penalty is\nR(T ) = 1\nT T\u2211 t=1 Lt(wt)\u2212 arg min w\u2208W 1 T `P(x1:T , y1:T ,w).\nWe note that Lt, being the difference of two loss functions, is non-convex in general and thus, standard online convex programming regret bounds cannot be applied in our framework. Interestingly, as we show below, by exploiting structural properties of our penalty function, we can still get efficient low-regret learning algorithms, as well as online-to-batch conversion bounds in our framework."}, {"heading": "3.1 Low Regret Online Learning", "text": "We propose an efficient Follow-the-Regularized-Leader (FTRL) style algorithm in our framework. Let w1 = arg minw\u2208W \u2016w\u201622 and consider the following update:\nwt+1 = arg min w\u2208W t\u2211 t=1 Lt(w) + \u03b7 2 \u2016w\u201622 = arg min w\u2208W `P(x1:t, yt:t,w) + \u03b7 2 \u2016w\u201622 (FTRL)\nWe would like to stress that despite the non-convexity of Lt, the FTRL objective is strongly convex if `P is convex and thus the update can be implemented efficiently by solving a regularized batch problem on x1:t. We now present our regret bound analysis for the FTRL update given above.\nTheorem 1. Let `P(\u00b7,w) be a convex loss function and W \u2286 Rd be a convex set. Assume w.l.o.g. \u2016xt\u20162 \u2264 1,\u2200t. Also, for the penalty function Lt in (6), let |Lt(w) \u2212 Lt(w\u2032)| \u2264 Gt \u00b7 \u2016w \u2212w\u2032\u20162, for all t and all w,w\u2032 \u2208 W for some Gt > 0. Suppose we use the update step given in ((FTRL)) to obtain wt+1, 0 \u2264 t \u2264 T \u2212 1. Then for all w\u2217, we have\n1\nT T\u2211 t=1 Lt(wt) \u2264 1 T `P(x1:T , y1:T ,w \u2217) + \u2016w\u2217\u20162\n\u221a 2 \u2211T\nt=1G 2 t\nT .\nSee Appendix A for a proof. The above result requires the penalty function Lt to be Lipschitz continuous i.e. be \u201cstable\u201d w.r.t. w. Establishing this for point losses such as hinge loss is relatively straightforward. However, the same becomes non-trivial for non-decomposable loss functions as Lt\nis now the difference of two loss functions, both of which involve \u2126 (t) data points. A naive argument would thus, only be able to show Gt \u2264 O(t) which would yield vacuous regret bounds.\nInstead, we now show that for the surrogate loss functions for Prec@k and pAUC, this Lipschitz continuity property does indeed hold. Our proofs crucially use a structural lemma given below that shows that sorted lists of inner products are Lipschitz at each fixed position.\nLemma 2 (Structural Lemma). Let x1, . . . ,xt be t points with \u2016xi\u20162 \u2264 1 \u2200t. Let w,w\u2032 \u2208 W be any two vectors. Let zi = \u3008w,xi\u3009 \u2212 ci and z\u2032i = \u3008w\u2032,xi\u3009 \u2212 ci, where ci \u2208 R are constants independent of w,w\u2032. Also, let {i1, . . . , it} and {j1, . . . , jt} be ordering of indices such that zi1 \u2265 zi2 \u2265 \u00b7 \u00b7 \u00b7 \u2265 zit and z\u2032j1 \u2265 z \u2032 j2 \u2265 \u00b7 \u00b7 \u00b7 \u2265 z\u2032jt. Then for any 1-Lipschitz increasing function g : R\u2192 R (i.e. |g(u)\u2212 g(v)| \u2264 |u\u2212 v| and u \u2264 v \u21d4 g(u) \u2264 g(v)), we have, \u2200k |g(zik)\u2212 g(z\u2032jk)| \u2264 3\u2016w \u2212w \u2032\u20162.\nSee Appendix B for a proof. Using this lemma we can show that the Lipschitz constant for `Prec@k is bounded by Gt \u2264 8 which gives us a O (\u221a 1 T ) regret bound for Prec@k (see Appendix C for the proof). In Appendix D, we show that the same technique can be used to prove a stability result for the structural SVM surrogate of the Precision-Recall Break Even Point (PRBEP) performance measure [3] as well. The case of pAUC is handled similarly. However, since pAUC discriminates between positives and negatives, our previous analysis cannot be applied directly. Nevertheless, we can obtain the following regret bound for pAUC (a proof will appear in the full version of the paper).\nTheorem 3. Let T+ and T\u2212 resp. be the number of positive and negative points in the stream and let wt+1, 0 \u2264 t \u2264 T \u2212 1 be obtained using the FTRL algorithm ((FTRL)). Then we have\n1\n\u03b2T+T\u2212 T\u2211 t=1 Lt(wt) \u2264 min w\u2208W\n1\n\u03b2T+T\u2212 `pAUC(x1:T , y1:T ,w) +O\n(\u221a 1\nT+ +\n1\nT\u2212\n) .\nNotice that the above regret bound depends on both T+ and T\u2212 and the regret becomes large even if one of them is small. This is actually quite intuitive because if, say T+ = 1 and T\u2212 = T \u2212 1, an adversary may wish to provide the lone positive point in the last round. Naturally the algorithm, having only seen negatives till now, would not be able to perform well and would incur a large error."}, {"heading": "3.2 Online-to-batch Conversion", "text": "To present our bounds we generalize our framework slightly: we now consider the stream of T points to be composed of T/s batches Z1, . . . ,ZT/s of size s each. Thus, the instantaneous penalty is now defined as Lt(w) = `P(Z1, . . . ,Zt,w)\u2212 `P(Z1, . . . ,Zt\u22121,w) for t = 1 . . . T/s and the regret becomes R(T, s) = 1T \u2211T/s t=1 Lt(wt)\u2212arg minw\u2208W 1T `P(x1:T , y1:T ,w). Let RP denote the population risk for the (normalized) performance measure P. Then we have:\nTheorem 4. Suppose the sequence of points (xt, yt) is generated i.i.d. and let w1,w2, . . . ,wT/s be an ensemble of models generated by an online learning algorithm upon receiving these T/s batches. Suppose the online learning algorithm has a guaranteed regret bound R(T, s). Then for\nw = 1T/s \u2211T/s t=1 wt, any w \u2217 \u2208 W, \u2208 (0, 0.5] and \u03b4 > 0, with probability at least 1\u2212 \u03b4,\nRP(w) \u2264 (1 + )RP(w\u2217) + R(T, s) + e\u2212\u2126(s 2) + O\u0303\n(\u221a s ln(1/\u03b4)\nT\n) .\nAlgorithm 1 1PMB: Single-Pass with Mini-batches Input: Step length scale \u03b7, Buffer B of size s Output: A good predictor w \u2208 W\n1: w0 \u2190 0, B \u2190 \u03c6, e\u2190 0 2: while stream not exhausted do 3: Collect s data points (xe1, y e 1), . . . , (x e s, y e s) in buffer B 4: Set step length \u03b7e \u2190 \u03b7\u221ae 5: we+1 \u2190 \u03a0W [we + \u03b7e\u2207w`P(xe1:s, ye1:s,we)] //\u03a0W projects onto the set W 6: Flush buffer B 7: e\u2190 e+ 1 //start a new epoch 8: end while 9: return w = 1e \u2211e i=1 wi\nAlgorithm 2 2PMB: Two-Passes with Mini-batches Input: Step length scale \u03b7, Buffers B+, B\u2212 of size s Output: A good predictor w \u2208 W\nPass 1: B+ \u2190 \u03c6 1: Collect random sample of pos. x+1 , . . . ,x + s in B+\nPass 2: w0 \u2190 0, B\u2212 \u2190 \u03c6, e\u2190 0 2: while stream of negative points not exhausted do 3: Collect s negative points xe\u22121 , . . . ,x e\u2212 s in B\u2212 4: Set step length \u03b7e \u2190 \u03b7\u221ae 5: we+1 \u2190 \u03a0W [ we + \u03b7e\u2207w`P(xe\u22121:s,x + 1:s,we)\n] 6: Flush buffer B\u2212 7: e\u2190 e+ 1 //start a new epoch 8: end while 9: return w = 1e \u2211e i=1 wi\nIn particular, setting s = O\u0303( \u221a T ) and = 4 \u221a 1/T gives us, with probability at least 1\u2212 \u03b4,\nRP(w) \u2264 RP(w\u2217) + R(T, \u221a T ) + O\u0303\n( 4 \u221a ln(1/\u03b4)\nT\n) .\nWe conclude by noting that for Prec@k and pAUC, R(T, \u221a T ) \u2264 O\n( 4 \u221a\n1/T ) (see Appendix E)."}, {"heading": "4 Stochastic Gradient Methods for Non-decomposable Losses", "text": "The online learning algorithms discussed in the previous section present attractive guarantees in the sequential prediction model but are required to solve batch problems at each stage. This rapidly becomes infeasible for large scale data. To remedy this, we now present memory efficient stochastic gradient descent methods for batch learning with non-decomposable loss functions. The motivation for our approach comes from mini-batch methods used to make learning methods for point loss functions amenable to distributed computing environments [15, 16], we exploit these techniques to offer scalable algorithms for non-decomposable loss functions."}, {"heading": "4.1 Single-pass Method with Mini-batches", "text": "The method assumes access to a limited memory buffer and takes a pass over the data stream. The stream is partitioned into epochs. In each epoch, the method accumulates points in the stream, uses them to form gradient estimates and takes descent steps. The buffer is flushed after each epoch. Algorithm 1 describes the 1PMB method. Gradient computations can be done using Danskin\u2019s theorem (see Appendix H)."}, {"heading": "4.2 Two-pass Method with Mini-batches", "text": "The previous algorithm is unable to exploit relationships between data points across epochs which may help improve performance for loss functions such as pAUC. To remedy this, we observe that several real life learning scenarios exhibit mild to severe label imbalance (see Table 1 in Appendix H) which makes it possible to store all or a large fraction of points of the rare label. Our two pass\nmethod exploits this by utilizing two passes over the data: the first pass collects all (or a random subset of) points of the rare label using some stream sampling technique [13]. The second pass then goes over the stream, restricted to the non-rare label points, and performs gradient updates. See Algorithm 2 for details of the 2PMB method."}, {"heading": "4.3 Error Bounds", "text": "Given a set of n labeled data points (xi, yi), i = 1 . . . n and a performance measure P, our goal is to approximate the empirical risk minimizer w\u2217 = arg min\nw\u2208W `P(x1:n, y1:n,w) as closely as possible. In\nthis section we shall show that our methods 1PMB and 2PMB provably converge to the empirical risk minimizer. We first introduce the notion of uniform convergence for a performance measure.\nDefinition 5. We say that a loss function ` demonstrates uniform convergence with respect to a set of predictors W if for some \u03b1(s, \u03b4) = poly ( 1 s , log 1 \u03b4 ) , when given a set of s points x\u03041, . . . , x\u0304s chosen randomly from an arbitrary set of n points {(x1, y1), . . . , (xn, yn)} then w.p. at least 1\u2212 \u03b4, we have\nsup w\u2208W\n|`P(x1:n, y1:n,w)\u2212 `P(x\u03041:s, y\u03041:s,w)| \u2264 \u03b1(s, \u03b4).\nSuch uniform convergence results are fairly common for decomposable loss functions such as the squared loss, logistic loss etc. However, the same is not true for non-decomposable loss functions barring a few exceptions [17, 10]. To bridge this gap, below we show that a large family of surrogate loss functions for popular non decomposable performance measures does indeed exhibit uniform convergence. Our proofs require novel techniques and do not follow from traditional proof progressions. However, we first show how we can use these results to arrive at an error bound.\nTheorem 6. Suppose the loss function ` is convex and demonstrates \u03b1(s, \u03b4)-uniform convergence. Also suppose we have an arbitrary set of n points which are randomly ordered, then the predictor w returned by 1PMB with buffer size s satisfies w.p. 1\u2212 \u03b4,\n`P(x1:n, y1:n,w) \u2264 `P(x1:n, y1:n,w\u2217) + 2\u03b1 ( s, s\u03b4\nn\n) +O (\u221a s\nn ) We would like to stress that the above result does not assume i.i.d. data and works for arbitrary datasets so long as they are randomly ordered. We can show similar guarantees for the two pass method as well (see Appendix F). Using regularized formulations, we can also exploit logarithmic regret guarantees [18], offered by online gradient descent, to improve this result - however we do not explore those considerations here. Instead, we now look at specific instances of loss functions that posses the desired uniform convergence properties. As mentioned before, due to the combinatorial nature of these performance measures, our proofs do not follow from traditional methods.\nTheorem 7 (Partial Area under the ROC Curve). For any convex, monotone, Lipschitz, classification surrogate \u03c6 : R \u2192 R+, the surrogate loss function for the (0, \u03b2)-partial AUC performance measure defined as follows exhibits uniform convergence at the rate \u03b1(s, \u03b4) = O (\u221a log(1/\u03b4)/s ) :\n1\nd\u03b2n\u2212en+ \u2211 i:yi>0 \u2211 j:yj<0 T\u2212\u03b2,t(xj ,w) \u00b7 \u03c6(x > i w \u2212 x>j w)\nSee Appendix G for a proof sketch. This result covers a large family of surrogate loss functions such as hinge loss (5), logistic loss etc. Note that the insistence on including only top ranked negative points introduces a high degree of non-decomposability into the loss function. A similar result for the special case \u03b2 = 1 is due to [17]. We extend the same to the more challenging case of \u03b2 < 1.\nTheorem 8 (Structural SVM loss for Prec@k). The structural SVM surrogate for the Prec@k performance measure (see (3)) exhibits uniform convergence at the rate \u03b1(s, \u03b4) = O (\u221a log(1/\u03b4)/s ) .\nWe defer the proof to the full version of the paper. The above result can be extended to a large family of performances measures introduced in [3] that have been widely adopted [10, 19, 8] such as F-measure, G-mean, and PRBEP. The above indicates that our methods are expected to output models that closely approach the empirical risk minimizer for a wide variety of performance measures. In the next section we verify that this is indeed the case for several real life and benchmark datasets."}, {"heading": "5 Experimental Results", "text": "We evaluate the proposed stochastic gradient methods on several real-world and benchmark datasets.\nPerformance measures: We consider three measures, 1) partial AUC in the false positive range [0, 0.1], 2) Prec@k with k set to the proportion of positives (PRBEP), and 3) F-measure.\nAlgorithms: For partial AUC, we compare against the state-of-the-art cutting plane (CP) and projected subgradient methods (PSG) proposed in [7]; unlike the (online) stochastic methods\nMeasure 1PMB 2PMB CP\npAUC 0.10 (68.2) 0.15 (69.6) 0.39 (62.5) Prec@k 0.49 (42.7) 0.55 (38.7) 23.25 (40.8)\nTable 2: Comparison of training time (secs) and accuracies (in brackets) of 1PMB, 2PMB and cutting plane methods for pAUC (in [0, 0.1]) and Prec@k maximization tasks on the KDD Cup 2008 dataset.\n10 0\n10 2\n10 4\n0.42 0.44 0.46 0.48 0.5\n0.52 0.54\nEpoch length\nA ve\nra ge\np A\nU C\n1PMB\n10 0\n10 2\n10 4\n0.45\n0.5\n0.55\n0.6\nEpoch length\nA ve\nra ge\np A\nU C\n2PMB\nFigure 3: Performance of 1PMB and 2PMB on the PPI dataset with varying epoch/buffer sizes for pAUC tasks.\nconsidered in this work, the PSG method is a \u2018batch\u2019 algorithm which, at each iteration, computes a subgradient-based update over the entire training set. For Prec@k and F-measure, we compare our methods against cutting plane methods from [3]. We used structural SVM surrogates for all the measures.\nDatasets: We used several data sets for our experiments (see Table 1); of these, KDDCup08 is from the KDD Cup 2008 challenge and involves a breast cancer detection task [20], PPI contains data for a protein-protein interaction prediction task [21], and the remaining datasets are taken from the UCI repository [22].\nParameters: We used 70% of the data set for training and the remaining for testing, with the results averaged over 5 random train-test splits. Tunable parameters such as step length scale were chosen using a small validation set. All experiments used a buffer of size 500. Epoch lengths were set equal to the buffer size. Since a single iteration of the proposed stochastic methods is very fast in practice, we performed multiple passes over the training data (see Appendix H for details).\nResults: The results for pAUC and Prec@k maximization tasks are shown in the Figures 1 and 2. We found the proposed stochastic gradient methods to be several orders of magnitude faster than the baseline methods, all the while achieving comparable or better accuracies. For example, for the pAUC task on the KDD Cup 2008 dataset, the 1PMB method achieved an accuracy of 64.81% within 0.03 seconds, while even after 0.39 seconds, the cutting plane method could only achieve an accuracy of 62.52% (see Table 2). As expected, the (online) stochastic gradient methods were faster than the \u2018batch\u2019 projected subgradient descent method for pAUC as well. We found similar trends on Prec@k (see Figure 2) and F-measure maximization tasks as well. For F-measure tasks, on the KDD Cup 2008 dataset, for example, the 1PMB method achieved an accuracy of 35.92 within 12 seconds whereas, even after 150 seconds, the cutting plane method could only achieve an accuracy of 35.25.\nThe proposed stochastic methods were also found to be robust to changes in epoch lengths\n(buffer sizes) till such a point where excessively long epochs would cause the number of updates as well as accuracy to dip (see Figure 3). The 2PMB method was found to offer higher accuracies for pAUC maximization on several datasets (see Table 2 and Figure 1), as well as be more robust to changes in buffer size (Figure 3). We defer results on more datasets and performance measures to the full version of the paper.\nThe cutting plane methods were generally found to exhibit a zig-zag behaviour in performance across iterates. This is because these methods solve the dual optimization problem for a given performance measure; hence the intermediate models do not necessarily yield good accuracies. On the other hand, (stochastic) gradient based methods directly offer progress in terms of the primal optimization problem, and hence provide good intermediate solutions as well. This can be advantageous in scenarios with a time budget in the training phase."}, {"heading": "Acknowledgements", "text": "The authors thank Shivani Agarwal for helpful comments. They also thank the anonymous reviewers for their suggestions. HN thanks support from a Google India PhD Fellowship."}, {"heading": "A Proof of Theorem 1", "text": "Broadly, we follow the proof structure of FTRL given in [1, 23]. We first observe that the \u201cforward regret\u201d analysis follows easily despite the non-convexity of Lt. That is,\nT\u2211 t=1 Lt(wt+1) \u2264 x1:T , y1:T ,w\u2217) + \u03b7 2 \u2016w\u2217\u201622, (7)\nwhere w\u2217 = arg minw\u2208W x1:T , y1:T ,w). The proof of this statement can be found in [23, Theorem 7] and is reproduced below as Lemma 9 for completeness. Next, using strong convexity of the regularizer \u2016w\u201622 and optimality of wt and wt+1 for their respective update steps, we get:\n`P(x1:t, y1:t,wt+1) + \u03b7\n2 \u2016wt+1 \u2212wt\u201622 \u2264 `P(x1:t, y1:t,wt)\n`P(x1:t\u22121, y1:t\u22121,wt+1) \u2265 `P(x1:t\u22121, y1:t\u22121,wt) + \u03b7\n2 \u2016wt+1 \u2212wt\u201622,\nwhich when subtracted, give us\n\u03b7\u2016wt+1 \u2212wt\u201622 \u2264 Lt(wt)\u2212 Lt(wt+1) \u2264 Gt\u2016wt+1 \u2212wt\u20162, (8)\nwhere the last inequality follows using the Lipschitz continuity of Lt. We now use the fact that\nT\u2211 t=1 Lt(wt) = T\u2211 t=1 Lt(wt+1) + T\u2211 t=1 (Lt(wt)\u2212 Lt(wt+1)),\nalong with (7) and (8) to get\nT\u2211 t=1 Lt(wt) \u2264 x1:T , y1:T ,w\u2217) + \u03b7 2 \u2016w\u2217\u201622 + \u2211T t=1G 2 t \u03b7 .\nThe result now follows by selecting \u03b7 = \u221a 2 \u2211T\nt=1G 2 t / \u2016w\u2217\u2016 2 2.\nLemma 9. For the setting described in Theorem 1, we have\nT\u2211 t=1 Lt(wt+1) \u2264 x1:T , y1:T ,w\u2217) + \u03b7 2 \u2016w\u2217\u201622\nProof. Let L0(w) := \u03b72 \u2016w\u2016 2 2. Thus, we can equivalently write the FTRL update in (FTRL) as\nwt+1 = arg min w\u2208W t\u2211 \u03c4=0 L\u03c4 (w).\nNow, using the optimality of wt+1 at time t, we get\nt\u2211 \u03c4=0 L\u03c4 (wt+1) \u2264 t\u2211 \u03c4=0 L\u03c4 (w\u2217) (9)\nCombining this with the optimality of wt at time t\u2212 1, we get t\u22121\u2211 \u03c4=0 L\u03c4 (wt) + Lt(wt+1) \u2264 t\u2211 \u03c4=0 L\u03c4 (wt+1) \u2264 t\u2211 \u03c4=0 L\u03c4 (w\u2217) (10)\nRepeating this argument gives us\nt\u2211 \u03c4=0 L\u03c4 (w\u03c4+1) \u2264 t\u2211 \u03c4=0 L\u03c4 (w\u2217),\nwhich proves the result."}, {"heading": "B Proof of Lemma 2", "text": "We consider the following four exhaustive cases in turn:\nCase 1. zik \u2265 zjk and z\u2032jk \u2265 z \u2032 ik\nWe have the following set of inequalities\ng(zik) = g(\u3008w,xik\u3009 \u2212 ci) \u2264 g( \u2329 w\u2032,xik \u232a \u2212 ci) + \u2223\u2223\u2329w \u2212w\u2032,xik\u232a\u2223\u2223 \u2264 g( \u2329 w\u2032,xik \u232a \u2212 ci) + \u2225\u2225w \u2212w\u2032\u2225\u2225 2\n= g(z\u2032ik) + \u2225\u2225w \u2212w\u2032\u2225\u2225 2\n\u2264 g(z\u2032jk) + \u2225\u2225w \u2212w\u2032\u2225\u2225 2 ,\nwhere the first inequality follows by the Lipschitz assumption, the second follows by Cauchy-Schwartz inequality and the last follows by the case assumption z\u2032jk \u2265 z \u2032 ik\nand the fact that g is an increasing function. By renaming i \u2194 j and w \u2194 w\u2032, we also have g(z\u2032jk) \u2264 g(zik) + \u2016w \u2212w \u2032\u20162. This establishes the result for the specific case.\nCase 2. zik \u2264 zjk and z\u2032jk \u2264 z \u2032 ik\nThis case follows similar to the case above.\nCase 3. zik \u2265 zjk and z\u2032jk \u2264 z \u2032 ik\nUsing the above conditions zjk does not belong to the top k elements of z1, . . . , zt, but both z\u2032ik and z \u2032 jk belong to the top k elements of z\u20321, . . . , z \u2032 t. Using the pigeonhole principle, there exists an index s such that zs \u2265 zik but zs \u2264 z\u2032jk . Hence, using arguments similar to Case 1, we get the following two bounds:\n|g(z\u2032ik)\u2212 g(zs)| \u2264 \u2016w \u2212w \u2032\u20162, |g(zs)\u2212 g(z\u2032jk)| \u2264 \u2016w \u2212w \u2032\u20162.\nWe also have \u2223\u2223g(z\u2032ik)\u2212 g(zik)\u2223\u2223 \u2264 |\u3008w \u2212w\u2032,xik\u3009| \u2264 \u2016w \u2212w\u2032\u20162. Adding these three inequalities gives us the desired result.\nCase 4. zik \u2264 zjk and z\u2032jk \u2265 z \u2032 ik\nThis case follows similar to the case above.\nThese cases are exhaustive and we thus conclude the proof.\nC Stability result for Prec@k\nLemma 10. Let `Prec@k be the surrogate for Prec@k as defined in (3), \u2016xt\u20162 \u2264 1,\u2200t and Lt be defined as in (6). Then \u2200w,w\u2032 \u2208 W, |Lt(w)\u2212 Lt(w\u2032)| \u2264 8\u2016w \u2212w\u2032\u20162.\nProof. Recall that, the loss function corresponding to Prec@k is defined as:\n`Prec@k(x1:t, y1:t,w) = max q\u2208{\u22121,1}t\u2211 i(qi+1)=2dkte\nt\u2211 i=1 (qi \u2212 yi)xTi w \u2212 t\u2211 i=1 qiyi (11)\n= max q\u2208{\u22121,1}t\u2211 i(qi+1)=2dkte\nt\u2211 i=1 qix T i w \u2212 t\u2211 i=1 qiyi\n\ufe38 \ufe37\ufe37 \ufe38 A(x1:t,y1:t,w)\n\u2212 t\u2211 i=1 yix T i w\ufe38 \ufe37\ufe37 \ufe38\nB(x1:t,y1:t,w)\n(12)\nSince B(x1:t, y1:t,w) is a decomposable loss function, it can at most add a constant (because of the assumptions made by us, that constant can be shown to be no bigger than 1) to the Lipschitz constant of Lt. Hence we concentrate on bounding the contribution of A(x1:t, y1:t,w) to the Lipschitz constant of Lt. Define zi = \u3008w,xi\u3009 \u2212 yi and z\u2032i = \u3008w\u2032,xi\u3009 \u2212 yi. It will be useful to rewrite A(x1:t, y1:t,w) as follows (and drop mentioning the dependence on x1:t for notational simplicity):\npt(w) = 2 max q\u2208{1,0}t\u2211 i qi=dkte\nt\u2211 i=1 qizi \u2212 t\u2211 i=1 zi. (13)\nSimilarly, we can define pt\u22121(w) as well. Now we have\nLt(w)\u2212 Lt(w\u2032) = pt(w)\u2212 pt\u22121(w)\u2212 pt(w\u2032) + pt\u22121(w\u2032) + ytxt(w\u2032 \u2212w) \u2264 pt(w)\u2212 pt\u22121(w)\u2212 pt(w\u2032) + pt\u22121(w\u2032)\ufe38 \ufe37\ufe37 \ufe38\n\u2206t(w,w\u2032)\n+ \u2225\u2225w \u2212w\u2032\u2225\u2225\n2\nOur mail goal in the sequel will be to show that \u2206t(w,w \u2032) \u2264 O (\u2016w \u2212w\u2032\u20162) which shall establish the desired Lipschitz continuity result. Now for both vectors w,w\u2032 and time instances t\u2212 1, t, let us denote the optimal assignments as follows:\nat = arg max q\u2208{1,0}t\u2211 i qi=dkte\nt\u2211 i=1 qizi, b t = arg max\nq\u2208{1,0}t\u2211 i qi=dkte\nt\u2211 i=1 qiz \u2032 i,\nat\u22121 = arg max q\u2208{1,0}(t\u22121)\u2211 i qi=dk(t\u22121)e\nt\u22121\u2211 i=1 qizi, b t\u22121 = arg max\nq\u2208{1,0}(t\u22121)\u2211 i qi=dk(t\u22121)e\nt\u22121\u2211 i=1 qiz \u2032 i.\nAlso, define indices 1 \u2264 ir \u2264 t\u2212 1 and 1 \u2264 js \u2264 t\u2212 1 as:\nzi1 \u2265 zi2 \u00b7 \u00b7 \u00b7 \u2265 zit\u22121 , z\u2032j1 \u2265 z \u2032 j2 \u00b7 \u00b7 \u00b7 \u2265 z \u2032 jt\u22121 .\nNow, note that (13) involves maximization of a linear function, hence the optimizing assignment q will always lie on the boundary of the Boolean hypercube with the cardinality constraint. Hence, at can be obtained by setting atir = 1, \u22001 \u2264 r \u2264 dkte and a t ir\n= 0, \u2200r > dkte, similarly for bt. We consider the following two cases and within each, four subcases which establish the result.\nIn the rest of the proof, all invocations of Lemma 2 shall use the identity function for g(\u00b7) and ci = yi. Clearly this satisfies the prerequisites of Lemma 2 since the identity function is 1-Lipschitz and increasing.\nCase 1 dkte = dk(t\u2212 1)e = \u03b1 Within this, we have the following four exhaustive subcases:\nCase 1.1 zt \u2264 zi\u03b1 and z\u2032t \u2264 z\u2032j\u03b1 The above condition implies that both att = 0 and b t t = 0. Furthermore, a t 1:(t\u22121) = a t\u22121\nand bt1:(t\u22121) = b t\u22121. As a result we have\n\u2206t(w,w \u2032) = \u2212zt + z\u2032t = \u2212\u3008w,xt\u3009+ \u2329 w\u2032,xt \u232a \u2264 \u2016w \u2212w\u2032\u20162.\nCase 1.2 zt > zi\u03b1 and z \u2032 t \u2264 z\u2032j\u03b1\nThe above condition implies that att = 1 and b t t = 0. Hence, b t 1:(t\u22121) = b t\u22121. Also, as att is turned on, the cardinality constraint dictates that one previously positive index should be turned off. That is, ati\u03b1 = 0, but a t\u22121 i\u03b1 = 1. Finally, atir = a t\u22121 ir\n, r 6= \u03b1 and r < t. Using the above observations, we have the following sequence of inequalities:\n\u2206t(w,w \u2032) = (2(zt \u2212 zi\u03b1)\u2212 zt)\u2212 (0\u2212 z\u2032t)\n= (zt \u2212 zi\u03b1) + (z\u2032t \u2212 zi\u03b1) = (zt \u2212 z\u2032t) + 2(z\u2032t \u2212 zi\u03b1) \u2264 (zt \u2212 z\u2032t) + 2(z\u2032j\u03b1 \u2212 zi\u03b1) \u2264 7 \u2225\u2225w \u2212w\u2032\u2225\u2225 2 ,\nwhere the third inequality follows from the case assumptions and the final inequality follows from an application of Cauchy Schwartz inequality and Lemma 2.\nCase 1.3 zt \u2264 zi\u03b1 and z\u2032t > z\u2032j\u03b1 In this case, we can analyze similarly to get\n\u2206t(w,w \u2032) = (0\u2212 zt)\u2212 (2(z\u2032t \u2212 z\u2032j\u03b1)\u2212 z \u2032 t)\n= (z\u2032j\u03b1 \u2212 zt) + (z \u2032 j\u03b1 \u2212 z \u2032 t) = (z\u2032t \u2212 zt) + 2(z\u2032j\u03b1 \u2212 z \u2032 t) \u2264 (z\u2032t \u2212 zt) \u2264 3 \u2225\u2225w \u2212w\u2032\u2225\u2225 2 .\nCase 1.4 zt > zi\u03b1 and z \u2032 t > z \u2032 j\u03b1\nIn this case, both att = 1 and b t t = 1. Hence, both a t i\u03b1 = 0 and btj\u03b1 = 0. The remaining terms of at and at\u22121 (similarly for bt and bt\u22121) remain the same. That is, we have\n\u2206t(w,w \u2032) = (2(zt \u2212 zi\u03b1)\u2212 zt)\u2212 (2(z\u2032t \u2212 z\u2032j\u03b1)\u2212 z \u2032 t)\n= (zt \u2212 z\u2032t)\u2212 2(zi\u03b1 \u2212 z\u2032j\u03b1) \u2264 7 \u2225\u2225w \u2212w\u2032\u2225\u2225 2 .\nCase 2 dkte = dk(t\u2212 1)e+ 1 = \u03b1 Here again, we consider the following four exhaustive subcases:\nCase 2.1 zt \u2264 zi\u03b1 and z\u2032t \u2264 z\u2032j\u03b1 The above condition implies that att = 0 and b t t = 0. Also, one new positive is included\nin both at and bt, i.e., ati\u03b1 = 1 and b t j\u03b1 = 1. The remaining entries of at and bt remains the same. Hence,\n\u2206t(w,w \u2032) = (2zi\u03b1 \u2212 zt)\u2212 (2z\u2032j\u03b1 \u2212 z \u2032 t) = 2(zi\u03b1 \u2212 z\u2032j\u03b1)\u2212 (zt \u2212 z \u2032 t) \u2264 9 \u2225\u2225w \u2212w\u2032\u2225\u2225 2 .\nCase 2.2 zt > zi\u03b1 and z \u2032 t \u2264 z\u2032j\u03b1\nThe above condition implies that att = 1 and b t t = 0. Also, b t j\u03b1\n= 1. The remaining entries of at and bt remains the same. Hence we have\n\u2206t(w,w \u2032) = (2zt \u2212 zt)\u2212 (2z\u2032j\u03b1 \u2212 z \u2032 t)\n= (zt \u2212 z\u2032j\u03b1) + (z \u2032 t \u2212 z\u2032j\u03b1) = (zt \u2212 z\u2032t) + 2(z\u2032t \u2212 z\u2032j\u03b1) \u2264 3 \u2225\u2225w \u2212w\u2032\u2225\u2225 2 .\nCase 2.3 zt \u2264 zi\u03b1 and z\u2032t > z\u2032j\u03b1 In this case we have\n\u2206t(w,w \u2032) = (2zi\u03b1 \u2212 zt)\u2212 (2z\u2032t \u2212 z\u2032t)\n= (zi\u03b1 \u2212 zt) + (zi\u03b1 \u2212 z\u2032t) = (z\u2032t \u2212 zt) + 2(zi\u03b1 \u2212 z\u2032t) \u2264 (z\u2032t \u2212 zt) + 2(zi\u03b1 \u2212 z\u2032j\u03b1) \u2264 7 \u2225\u2225w \u2212w\u2032\u2225\u2225 2 .\nCase 2.4 zt > zi\u03b1 and z \u2032 t > z \u2032 j\u03b1\nThe above condition implies that att = 1 and b t t = 1. The remaining entries of a t and bt remains the same. Hence,\n\u2206t(w,w \u2032) = (2zt \u2212 zt)\u2212 (2z\u2032t \u2212 z\u2032t) = zt \u2212 z\u2032t \u2264 3 \u2225\u2225w \u2212w\u2032\u2225\u2225 2 .\nTaking the worst case Lipschitz constants from these 8 subcases and adding the contribution of B(x1:t, y1:t,w) concludes the proof."}, {"heading": "D Extension to Precision-Recall Break Even Point (PRBEP)", "text": "We note that the above discussion can easily be extended to prove stability results for the structural surrogate loss for the PRBEP performance measure [3]. Recall that the PRBEP measure essentially measures the precision (equivalently recall) of a predictor when thresholded at a point that equates\nthe precision and recall. Since we have Prec = TPTP+FP and Rec = TP\nTP+FN , the break even point is reached at a threshold where TP + FP = TP + FN. Notice that the left hand side equals the number of points that are predicted as positive whereas the right hand side equals the number of points that are actual positives.\nThus, the PRBEP is achieved at a threshold that predicts as many points as positive as there are actual positives which gives us the formal definition of this performance measure\nPRBEP(w) := \u2211\nj:T( t+ t ,t\n)(xj ,w)=1 I [yj = 1] . (14)\nNote that this is equivalent to the definition of Prec@k with k = t+ t . Correspondingly, we can also define the structural SVM surrogate for this performance measure as\n`PRBEP(w) = max y\u0304\u2208{\u22121,+1}t\u2211 i(y\u0304i+1)=2t+\nt\u2211 i=1 (y\u0304i \u2212 yi)xTi w \u2212 t\u2211 i=1 yiy\u0304i. (15)\nGiven this, it is easy to see that the proof of Lemma 10 would apply to this case as well. The only difference in applying the analysis would be that Case 1 and its subcases would apply when yt < 0 which is when the incoming point is negative and hence the number of actual positives in the stream does not go up. Case 2 and its subcases would apply when yt > 0 in which case the number of points to be considered while calculating precision would have to be increased by 1."}, {"heading": "E Online-to-batch Conversion", "text": "This section presents a proof of the regret bound in the batch model considered in Theorem 4 and a proof sketch of the online-to-batch conversion result. The full proof shall appear in the full version of the paper. We will consider in this section, the pAUC measure in the 2PMB setting wherein positives are assumed to reside in the buffer and negatives are streaming in. The case of the Prec@k measure in the usual 1PMB setting can be handled similarly. Additionally, we will show in Appendix G that for the case of pAUC, the contributions from a large enough buffer of randomly chosen positive points mimics the contributions of the entire population of positive points. Thus, for pAUC, it suffices to show the online-to-batch conversion bounds just with respect to the negatives. We clarify this further in the discussion.\nE.1 Regret Bounds in the Modified Framework\nWe prove the following lemma which will help us in instantiating our online-to-batch conversion proofs. Lemma 11. For the surrogate losses of Prec@k and pAUC, we have R(T, s) \u2264 \u221a s \u00b7R(T )\nProof. The only thing we need to do is analyze one time step for changes in the Lipschitz constant. Fix a time step t and let Zt = {xt,1,xt,2, . . . ,xt,s}. Also, let gt(w, i) := `P(Z1, . . . ,Zt\u22121,xt,1:i,w) for any i = 1 . . . s (note that this gives us gt(w, s) = `P(Z1, . . . ,Zt,w)). Also let us abuse notation to denote gt(w, 0) := `P(Z1, . . . ,Zt\u22121,w) = gt\u22121(w, s). Let the Lipschitz constant in the model\nwith batch size s be denoted as Gst . Thus, we have G 1 t = Gt, the Lipschitz constant for the problem in the original model (i.e. for s = 1). Then we have, for any w,w\u2032 \u2208 W,\u2223\u2223Lt(w)\u2212 Lt(w\u2032)\u2223\u2223 = \u2223\u2223`P(Z1:t,w)\u2212 `P(Z1:t\u22121,w)\u2212 `P(Z1:t,w\u2032) + `P(Z1:t\u22121,w\u2032)\u2223\u2223 =\n\u2223\u2223gt(w, s)\u2212 gt(w, 0)\u2212 gt(w\u2032, s) + gt(w\u2032, 0)\u2223\u2223 =\n\u2223\u2223\u2223\u2223\u2223 s\u2211 i=1 gt(w, i)\u2212 gt(w, i\u2212 1)\u2212 gt(w\u2032, i) + gt(w\u2032, i\u2212 1) \u2223\u2223\u2223\u2223\u2223 \u2264\ns\u2211 i=1 \u2223\u2223gt(w, i)\u2212 gt(w, i\u2212 1)\u2212 gt(w\u2032, i) + gt(w\u2032, i\u2212 1)\u2223\u2223 \u2264\ns\u2211 i=1 Gt \u2225\u2225w \u2212w\u2032\u2225\u2225 = Gt \u00b7 s\u2225\u2225w \u2212w\u2032\u2225\u2225 ,\nwhere the first inequality follows by triangle inequality and the second inequality follows by a repeated application of the Lipschitz property of these loss functions in the original online model (i.e. with batch size s = 1). This establishes the Lipschitz constant in this model as Gst \u2264 s \u00b7 Gt. Now, the usual FTRL analysis gives us the following (note that there are only T/s time steps now)\nT/s\u2211 t=1 Lt(wt) \u2264 `P(x1:T , y1:T ,w\u2217) + \u03b7 2 \u2016w\u2217\u201622 + \u2211T/s t=1(G s t ) 2 \u03b7 \u2264 `P(x1:T , y1:T ,w\u2217) + 2s\u2016w\u2217\u20162 \u221a\u221a\u221a\u221aT/s\u2211 t=1 G2t ,\nby setting \u03b7 appropriately. Now, for Prec@k, Gt \u2264 8. Thus, we have\n1\nT T/s\u2211 t=1 Lt(wt) \u2264 1 T `P(x1:T , y1:T ,w\u2217) + 6\u2016w\u2217\u20162 \u221a s T ,\nwhich establishes the result for Prec@k. Similarly, for pAUC, we can show that the regret in the batch model does not worsen by more than a factor of \u221a s.\nE.2 Online-to-batch Conversion for pAUC\nWe will consider the 2PMB setting where negative points come as a stream and positive points reside in an in-memory buffer. At each trial t, the learner receives a batch of s negative points Z\u2212t = {x \u2212 t,1, . . . ,x \u2212 t,s} (we shall assume throughout, for simplicity, that s\u03b2 is an integer). Let us denote the loss w.r.t all the positive points in the buffer by \u03c6+ : W \u00d7 R \u2192 [0, B]. \u03c6+ is defined using a loss function g(\u00b7) such as hinge loss or logistic loss as\n\u03c6+(w, c) = 1\nB B\u2211 i=1 g(w>x+i \u2212 c)\nFor sake of brevity, we will abbreviate \u03c6+(w, c) as \u03c6+(c), the reference to w being clear from context. We assume that \u03c6+ is monotonically increasing (as is the case for hinge loss and logistic regression) and bounded i.e. for some fixed B > 0, we have, for all w \u2208 W, c \u2208 R, 0 \u2264 \u03c6+(w, c) \u2264 B.\nThe empirical (unnormalized) partial AUC loss for a model w \u2208 W \u2286 Rd over the negative points received in t trials is then given by\n\u02dc\u0300 pAUC(Z \u2212 1:t,w) = t\u2211 \u03c4=1 s\u2211 q=1 T\u2212\u03b2,t(x \u2212 \u03c4,q,w)\u03c6+(w >x\u2212\u03c4,q),\nwhere T\u2212\u03b2,t(x \u2212,w) is the (empirical) indicator function that is turned on whenever x\u2212 appears in the top-\u03b2 fraction of all the negatives seen till now, ordered by w, i.e. T\u2212\u03b2,t(x \u2212,w) = 1 when-\never \u2223\u2223{\u03c4 \u2208 [t], q \u2208 [s] : w>x\u2212 > w>x\u2212\u03c4,q}\u2223\u2223 \u2264 ts\u03b2. We similarly define a population version of this empirical loss function as\nR\u0303pAUC(w) = Ex\u2212 r T\u2212\u03b2 (x \u2212,w)\u03c6+(w >x\u2212) z ,\nwhere T\u2212\u03b2 (x \u2212,w) is the population indicator function with T\u2212\u03b2 (x \u2212,w) = 1 whenever Px\u0303\u2212 ( w>x\u0303\u2212 >\nw>x\u2212 ) \u2264 \u03b2. Also, we define Lt(w) = `pAUC(Z\u22121:t,w) \u2212 `pAUC(Z \u2212 1:t\u22121,w), with the regret of a learning algorithm that generates an ensemble of models w1,w2, . . . ,wT/s \u2208 W \u2286 Rd upon receiving T/s batches of negative points Z\u22121:T/s defined as:\nR(T, s) = 1\nT T/s\u2211 t=1 Lt(wt)\u2212 arg min w\u2208W 1 T \u02dc\u0300 pAUC(Z \u2212 1:T/s,w).\nDefine \u03b2t = Ex\u2212 r T\u2212\u03b2,t\u22121(x \u2212,wt) z as the fraction of the population that can appear in the top \u03b2 fraction of the set of points seen till now, i.e. the fraction of the population for which the empirical indicator function is turned on, and\nQt(w) = Ex\u2212 r T\u2212\u03b2,t\u22121(x \u2212,w)\u03c6+(w >x\u2212) z\nas the population partial AUC computed with respect to the empirical indicator function T\u2212\u03b2,t\u22121 (note that the population risk functional R\u0303pAUC(w) is computed with respect to T\u2212\u03b2 (x\n\u2212,w), the population indicator function instead). We will also find it useful to define the following conditional expectation.\nL\u0303t(w) = EZ\u2212t q Lt(w) |Z\u22121:t\u22121 y .\nWe now present a proof sketch of the online-to-batch conversion result in Theorem 4 for pAUC.\nTheorem 12 (Online-to-batch Conversion for pAUC). Suppose the sequence of negative points x\u22121 , . . . ,x \u2212 T is generated i.i.d.. Let us partition this sequence into T/s batches of size s and let w1,w2, . . . ,wT/s be an ensemble of models generated by an online learning algorithm upon receiving these T/s batches. Suppose the online learning algorithm has a guaranteed regret bound R(T, s).\nThen for w = 1T/s \u2211T/s t=1 wt, any w \u2217 \u2208 W \u2286 Rd, \u2208 (0, 1] and \u03b4 > 0, with probability at least 1\u2212 \u03b4,\nR\u0303pAUC(w) \u2264 (1 + )R\u0303pAUC(w\u2217) + 1 \u03b2 R(T, s) + e\u2212\u2126(s 2) + O\u0303\n(\u221a s ln(1/\u03b4)\nT\n) .\nIn particular, setting s = O\u0303( \u221a T ) and = 4 \u221a 1/T gives us, with probability at least 1\u2212 \u03b4,\nR\u0303pAUC(w) \u2264 R\u0303pAUC(w\u2217) + 1\n\u03b2 R(T,\n\u221a T ) + O\u0303\n( 4 \u221a ln(1/\u03b4)\nT\n) .\nProof (Sketch). Fix \u2208 (0, 0.5]. We wish to bound the difference\n(1\u2212 )s\u03b2 T/s\u2211 t=1 R\u0303pAUC(wt) \u2212 T\u03b2R\u0303pAUC(w\u2217) (16)\nand do so by decomposing (16) into four terms as shown below.\n(16) \u2264 T/s\u2211 t=1 REt(wt) + MC(w1:T/s) + R(w1:T/s) + UC(w\u2217),\nwhere we have\nUC(w\u2217) = \u02dc\u0300pAUC(Z \u2212 1:T/s,w\u2217) \u2212 T\u03b2R\u0303pAUC(w\u2217) (Uniform Convergence Term)\nR(w1:T/s) =\nT/s\u2211 t=1 Lt(wt) \u2212 T/s\u2211 t=1 Lt(w\u2217) (Regret Term)\nMC(w1:T/s) =\nT/s\u2211 t=1 L\u0303t(wt) \u2212 T/s\u2211 t=1 Lt(wt) (Martingale Convergence Terms)\nREt(wt) = (1\u2212 )s\u03b2R\u0303pAUC(wt) \u2212 L\u0303t(wt) (Residual Error Terms)\nNote that the above has used the fact that \u02dc\u0300pAUC(Z \u2212 1:T/s,w\u2217) = \u2211T/s t=1 Lt(w\u2217).\nWe will bound these terms in order below. First we look at the term UC(w\u2217). Bounding this simply requires a batch generalization bound of the form we prove in Theorem 7. Thus, we can show, that with probability 1\u2212 \u03b4/3, we have\nUC(w\u2217) \u2264 O (\u221a T log(1/\u03b4) ) .\nWe now move on the term R(w1:T/s). This is simply bounded by the regret of the ensemble w1:T/s. This gives us\nR(w1:T/s) \u2264 T \u00b7R(T, s).\nThe next term we bound is MC(w1:T/s). Note that by definition of L\u0303t(w), if we define\nvt = L\u0303t(wt)\u2212 Lt(wt), then the terms {vt} form a martingale difference sequence. Since \u2223\u2223L\u0303t(wt) \u2212 Lt(wt)\u2223\u2223 \u2264 O (s), we get, by an application of the Azuma-Hoefding inequality, with probability at least 1\u2212 \u03b4/3,\nMC(w1:T/s) \u2264 O\n( s \u221a T\ns ln\n1\n\u03b4\n) = O (\u221a sT ln(1/\u03b4) ) .\nThe last step requires us to bound the residual term REt(wt) which will again require uniform convergence techniques. We shall show, that with probability, at least 1\u2212 (\u03b4 \u00b7 s/3T ), we have\n\u03b2t \u2265 \u03b2 \u2212 O\u0303 \u221a log 1\u03b4 s(t\u2212 1)  .\nThis shall allow us to show that with the same probability, we have\nQt(wt)\u2212 R\u0303pAUC(wt) \u2264 O\u0303 \u221a log 1\u03b4 s(t\u2212 1)  . The last ingredient in the proof shall involve showing that the following holds for any > 0\nL\u0303t(wt) \u2265 (1\u2212 )s\u03b2tQt(wt)\u2212 \u2126 ( s exp(\u2212s\u03b22t 2) ) Combining the above with a union bound will show us that, with probability at least 1\u2212 \u03b4/3,\nT/s\u2211 i=1 REt(wt) \u2264 O ( T exp(\u2212s 2) ) + O\u0303 (\u221a sT log(1/\u03b4) ) A final union bound and some manipulations would then establish the claimed result."}, {"heading": "F Proof of Theorem 6", "text": "The proof proceeds in two parts: the first part uses the fact that the 1PMB method essentially simulates the GIGA method of [24] with the non-decomposable loss function and the second part uses the uniform convergence properties of the loss function to establish the error bound. To proceed, let us set up some notation. Consider the eth epoch of the 1PMB algorithm. Let us denote the set of points considered in this epoch by Xe = {xe1, . . . , xes}. With this notation it is clear that the 1PMB algorithm can be said to be performing online gradient descent with respect to the instantaneous loss functions Le(w) = L(Xe,w) := `P(xe1:s, ye1:s,w).\nSince the loss function Le(w) is convex, the standard analysis for online convex optimization would apply under mild boundedness assumptions on the domain and the (sub)gradients of the loss function. Since there are n/s epochs (assuming for simplicity that n is a multiple of s), this allows us to use the standard regret bounds [24] to state the following:\ns\nn n/s\u2211 e=1 Le(we) \u2264 s n n/s\u2211 e=1 Le(w\u2217) +O (\u221a s n ) .\nNow we will invoke uniform convergence properties of the loss function. However, doing so requires clarifying certain aspects of the problem setting. The statement of Theorem 6 assumes only a random ordering of training data points whereas uniform convergence properties typically require i.i.d. samples. We reconcile this by noticing that all our uniform convergence proofs use the Hoeffding\u2019s lemma to establish statistical convergence and that the Hoeffding\u2019s lemma holds when random variables are sampled without replacement as well (e.g. see [25]). Since a random ordering of the data provides, for each epoch, a uniformly random sample without replacement, we are able to invoke the uniform convergence proofs.\nThus, if we denote L(w) := `P(x1:n, y1:n,w), then by using the uniform convergence properties of the loss function, for every e, with probability at least 1\u2212 s\u03b4n , we have Le(we) \u2265 L(we)\u2212\u03b1 ( s, s\u03b4n ) as well as Le(w\u2217) \u2264 L(w\u2217) +\u03b1 ( s, s\u03b4n ) . Applying the union bound and Jensen\u2019s inequality gives us, with probability at least 1\u2212 \u03b4, the desired result:\nL(w) \u2264 s n n/s\u2211 e=1 L(we) \u2264 L(w\u2217) + 2\u03b1 ( s, s\u03b4 n ) +O (\u221a s n ) .\nWe note that we can use similar arguments as above to give error bounds for the 2PMB procedure as well. Suppose x\u0304+1:s+ and x\u0304 \u2212 1:s\u2212\nare the positive and negative points sampled in the process (note that here the number of positive and negatives points (i.e. s+ and s\u2212 respectively) are random quantities as well). Also suppose x+1:n+ and x \u2212 1:n\u2212\nare the positive and negative points in the population. Then recall that Definition 5 requires, for a uniform (but possibly without replacement) sample,\nsup w\u2208W \u2223\u2223\u2223`P(x+1:n+ ,x\u22121:n\u2212 ,w)\u2212 `P(x\u0304+1:s+ , x\u0304\u22121:s\u2212 ,w)\u2223\u2223\u2223 \u2264 O\u0303 (\u03b1(s, \u03b4)) . To prove bounds for 2PMB, we require that for arbitrary choice of s+, s\u2212 \u2265 \u2126 (s), when x\u0304+1:s+ and x\u0304\u22121:s\u2212 are chosen separately and uniformly (but yet again possibly without replacement) from x+1:n+ and x \u2212 1:n\u2212\nrespectively, we still obtain a similar result as above. Since the first pass and each epoch of the second pass provide such a sample, we can use this result to prove error bounds for the 2PMB procedure. We defer the detailed arguments for such results to the full version of the paper.\nWe however note that the proof of Theorem 7 below does indeed prove such a result for the pAUC loss function by effectively proving (see Section G.1) the following two results\nsup w\u2208W \u2223\u2223\u2223`P(x+1:n+ , x\u0304\u22121:s\u2212 ,w)\u2212 `P(x\u0304+1:s+ , x\u0304\u22121:s\u2212 ,w)\u2223\u2223\u2223 \u2264 O\u0303 (\u03b1(s, \u03b4)) sup w\u2208W\n\u2223\u2223\u2223`P(x+1:n+ ,x\u22121:n\u2212 ,w)\u2212 `P(x+1:n+ , x\u0304\u22121:s\u2212 ,w)\u2223\u2223\u2223 \u2264 O\u0303 (\u03b1(s, \u03b4)) ."}, {"heading": "G Uniform Convergence Bounds for Partial Area under the ROC", "text": "Curve\nIn this section we present a proof sketch of Theorem 7 which we restate below for convenience.\nTheorem 13. Consider any convex, monotonic and Lipschitz classification surrogate \u03c6 : R\u2192 R+. Then the loss function for the (0, \u03b2)-partial AUC performance measure defined as follows exhibits uniform convergence at the rate \u03b1(s) = O\u0303 (1/ \u221a s):\n`P(x1:n, y1:n,w) = 1\n\u03b2n+n\u2212 n\u2211 i=1 I [yi > 0] n\u2211 j=1 I [yj < 0]T\u2212\u03b2,n(xj ,w)\u03c6 ( w>(xi \u2212 xj) ) ,\nwhere n+ = |{i : yi > 0}| and n\u2212 = |{i : yi < 0}|. Proof (Sketch). We shall use the notation T\u0302\u2212\u03b2,s to denote the indicator function for the top \u03b2 fraction of the negative elements in the smaller sample of size s. Thus, over the smaller sample (x\u03041, y\u03041) . . . (x\u0304s, y\u0304s), the pAUC is calculated as\n`P(x\u03041:s, y\u03041:s,w) = 1\n\u03b2s+s\u2212 s\u2211 i=1 I [y\u0304i > 0] s\u2211 j=1 I [y\u0304j < 0] T\u0302\u2212\u03b2,s(x\u0304j ,w)\u03c6 ( w>(x\u0304i \u2212 x\u0304j) ) .\nOur goal would be to show that with probability at least 1\u2212 \u03b4, for all w \u2208 W |`P(x1:n, y1:n,w)\u2212 `P(x\u03041:s, y\u03041:s,w)| \u2264 O\u0303 (\n1\u221a s ) We shall demonstrate this by establishing the following three statements:\n1. For any fixed w \u2208 W, w.h.p., we have |`P(x1:n, y1:n,w)\u2212 `P(x\u03041:s, y\u03041:s,w)| \u2264 O\u0303 (\n1\u221a s ) 2. For any two w,w\u2032 \u2208 W, we have |`P(x1:n, y1:n,w)\u2212 `P(x1:n, y1:n,w\u2032)| \u2264 O (\u2016w \u2212w\u2032\u20162)\n3. For any two w,w\u2032 \u2208 W, we have |`P(x\u03041:s, y\u03041:s,w)\u2212 `P(x\u03041:s, y\u03041:s,w\u2032)| \u2264 O (\u2016w \u2212w\u2032\u20162) With these three results established, we would be able to conclude the proof by an application of a standard covering number argument. We now prove these three statements in parts.\nG.1 Part 1: Pointwise Convergence for pAUC\nFix a predictor w \u2208 W and S+ and S\u2212 denote the set of positive and negative samples. We shall assume that s+, s\u2212 \u2265 \u2126 (s) which holds with high probability. Denote, for any xi such that yi > 0,\n`+(xi,w) = 1\n\u03b2n\u2212 n\u2211 j=1 I [yj < 0]T\u2212\u03b2,n(xj ,w)\u03c6 ( w>(xi \u2212 xj) ) ,\nand for any x\u0304i \u2208 S+,\n`+S\u2212(x\u0304i,w) = 1\n\u03b2s\u2212 s\u2211 j=1 I [y\u0304j < 0] T\u0302\u2212\u03b2,s(x\u0304j ,w)\u03c6 ( w>(x\u0304i \u2212 x\u0304j) ) .\nNotice that `P(x\u03041:s, y\u03041:s,w) = 1 n+ \u2211n i=1 I [yi > 0] `+(xi,w) and `P(x\u03041:s, y\u03041:s,w) = 1 s+ \u2211s i=1 I [y\u0304i > 0] ` + S\u2212\n(x\u0304i,w). We shall now show the following holds w.h.p. over S\u2212:\n1. For any xi such that yi > 0, \u2223\u2223\u2223`+(xi,w)\u2212 `+S\u2212(xi,w)\u2223\u2223\u2223 \u2264 O\u0303 ( 1\u221as).\n2. 1n+ \u2223\u2223\u2223\u2211ni=1 I [yi > 0] `+(xi,w)\u2212 I [yi > 0] `+S\u2212(xi,w)\u2223\u2223\u2223 \u2264 O\u0303 ( 1\u221as). 3. \u2223\u2223\u2223 1n+ \u2211ni=1 I [yi > 0] `+S\u2212(xi,w)\u2212 1s+ \u2211si=1 I [y\u0304i > 0] `+S\u2212(x\u0304i,w)\u2223\u2223\u2223 \u2264 O\u0303 ( 1\u221as).\nThe second part follows from the first part by an application of the triangle inequality. The third part also can be shown to hold by an application of Hoeffding\u2019s inequality and other arguments. This leaves the first part for which we provide a proof in the full version of the paper.\nG.2 Parts 2 and 3: Establishing an -net for pAUC\nFor simplicity, we assume that the domain is finite. This does not affect the proof in any way since it still allows the domain to be approximated arbitrary closely by an -net of (arbitrarily) large size. However, we note that we can establish the same result for infinite domains as well, but choose not to for sake of simplicity. We prove the second part, the proof of the first part being similar. We have\u2223\u2223`P(x1:n, y1:n,w)\u2212 `P(x1:n, y1:n,w\u2032)\u2223\u2223 = 1\ns+ \u2223\u2223\u2223\u2223\u2223 s\u2211 i=1 I [y\u0304i > 0] `+S\u2212(xi,w)\u2212 I [y\u0304i > 0] ` + S\u2212 (xi,w \u2032) \u2223\u2223\u2223\u2223\u2223 \u2264 1\ns+ s\u2211 i=1 \u2223\u2223\u2223I [y\u0304i > 0](`+S\u2212(xi,w)\u2212 `+S\u2212(xi,w\u2032))\u2223\u2223\u2223 \u2264 O (\u2225\u2225w \u2212w\u2032\u2225\u2225 2 ) ,\nusing Lemma 2 with g(a) = \u03c6(w>xi \u2212 a) and ci = 0. This concludes the proof."}, {"heading": "H Methodology for implementing 1PMB and 2PMB for pAUC", "text": "tasks\nIn this section we clarify the mechanisms used to implement the 1PMB and 2PMB routines. Going as per the dataset statistics (see Table 1), we will consider the variant of the 2PMB routine with the positive class as the rare class. Recall the definition of the surrogate loss function for pAUC (5)\n`pAUC(w) = \u2211 i:yi>0 \u2211 j:yj<0 T\u2212\u03b2,t(xj ,w) \u00b7 h(x > i w \u2212 x>j w).\nWe now rewrite this in a slightly different manner. Define, for any i : yi > 0 `+S\u2212(xi,w) = \u2211 j:yj<0 T\u2212\u03b2,t(xj ,w) \u00b7 h(x > i w \u2212 x>j w),\nso that we can write `pAUC(w) = \u2211\ni:yi>0 `+S\u2212(xi,w). This shows that a subgradient to `pAUC(w)\ncan be found by simply finding and summing up, subgradients for `+S\u2212(xi,w). For now, fix an i such that yi > 0 and define g(a) = h(x > i w \u2212 a). Using the properties of the hinge loss function, it is clear that g(a) is an increasing function of a. Since `+S\u2212(xi,w) is defined on the top ranked d\u03b2t\u2212e negatives, we can, using the monotonicity of g(\u00b7), equivalently write it as follows. Let Z\u03b2 = ( S\u2212 d\u03b2t\u2212e\n) be the set of all sets of negative points of negative training points of size d\u03b2t\u2212e. Then we can write\n`+S\u2212(xi,w) = maxS\u2208Z\u03b2 \u2211 x\u2212\u2208S g(x\u2212>w)\nSince the maximum in the above formulation is achieved at S = { j : yj < 0,T\u2212\u03b2,t(xj ,w) = 1 } , by Danskin\u2019s theorem (see, for example [26]), we get the following result: let vij \u2208 \u03b4h(x>i w \u2212 x>j w) be a subgradient to the hinge loss function, then for the following vector\nvi := \u2211 j:yj<0 T\u2212\u03b2,t(xj ,w) \u00b7 vij ,\nwe have vi \u2208 \u03b4`+S\u2212(xi,w) and consequently, for v := \u2211 i:yi>0 vi, we have v \u2208 \u03b4`pAUC(w). This gives us a straightforward way to implement 1PMB: for each epoch, we take all the negatives in that epoch, filter out the top \u03b2 fraction of them according to the scores assigned to them by the current iterate we and then calculate the (sub)gradients between all the positives in that epoch and these filtered negatives. This takes at most O (s log s) time per epoch."}], "references": [{"title": "A Structural SVM Based Approach for Optimizing Partial AUC", "author": ["Harikrishna Narasimhan", "Shivani Agarwal"], "venue": "In 30th International Conference on Machine Learning (ICML),", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2013}, {"title": "A Support Vector Method for Multivariate Performance Measures", "author": ["Thorsten Joachims"], "venue": "In ICML,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2005}, {"title": "A Support Vector Method for Optimizing Average Precision", "author": ["Yisong Yue", "Thomas Finley", "Filip Radlinski", "Thorsten Joachims"], "venue": "In SIGIR,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2007}, {"title": "Structured Learning for Non-Smooth Ranking Losses", "author": ["Soumen Chakrabarti", "Rajiv Khanna", "Uma Sawant", "Chiru Bhattacharyya"], "venue": "In KDD,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2008}, {"title": "Metric Learning to Rank", "author": ["Brian McFee", "Gert Lanckriet"], "venue": "In ICML,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2010}, {"title": "SVM  pAUC: A New Support Vector Method for Optimizing Partial AUC Based on a Tight Convex Upper Bound", "author": ["Harikrishna Narasimhan", "Shivani Agarwal"], "venue": "In KDD,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2013}, {"title": "Addressing the Curse of Imbalanced. Training Sets: One- Sided Selection", "author": ["Miroslav Kubat", "Stan Matwin"], "venue": "In 24th International Conference on Machine Learning (ICML),", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 1997}, {"title": "An Exact Algorithm for F-Measure Maximization", "author": ["Krzysztof Dembczy\u0144ski", "Willem Waegeman", "Weiwei Cheng", "Eyke H\u00fcllermeier"], "venue": "In NIPS,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2011}, {"title": "Optimizing F-Measures: A Tale of Two Approaches", "author": ["Nan Ye", "Kian Ming A. Chai", "Wee Sun Lee", "Hai Leong Chieu"], "venue": "In 29th International Conference on Machine Learning (ICML),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2012}, {"title": "Optimizing the F-Measure in Multi-Label Classification: Plug-in Rule Approach versus Structured Loss Minimization", "author": ["Krzysztof Dembczy\u0144ski", "Arkadiusz Jachnik", "Wojciech Kotlowski", "Willem Waegeman", "Eyke H\u00fcllermeier"], "venue": "In 30th International Conference on Machine Learning (ICML),", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2013}, {"title": "Online Learning: Beyond Regret", "author": ["Alexander Rakhlin", "Karthik Sridharan", "Ambuj Tewari"], "venue": "In 24th Annual Conference on Learning Theory (COLT),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "On the Generalization Ability of Online Learning Algorithms for Pairwise Loss Functions", "author": ["Purushottam Kar", "Bharath K Sriperumbudur", "Prateek Jain", "Harish Karnick"], "venue": "In ICML,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2013}, {"title": "Online AUC Maximization", "author": ["Peilin Zhao", "Steven C.H. Hoi", "Rong Jin", "Tianbao Yang"], "venue": "In ICML,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "Optimal Distributed Online Prediction Using Mini-Batches", "author": ["Ofer Dekel", "Ran Gilad-Bachrach", "Ohad Shamir", "Lin Xiao"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}, {"title": "Communication-Efficient Algorithms for Statistical Optimization", "author": ["Yuchen Zhang", "John C. Duchi", "Martin J. Wainwright"], "venue": "Journal of Machine Learning Research,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2013}, {"title": "Ranking and empirical minimization of U-statistics", "author": ["St\u00e9phan Cl\u00e9men\u00e7on", "G\u00e1bor Lugosi", "Nicolas Vayatis"], "venue": "Annals of Statistics,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "Logarithmic Regret Algorithms for Online Convex Optimization", "author": ["Elad Hazan", "Adam Kalai", "Satyen Kale", "Amit Agarwal"], "venue": "In COLT,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2006}, {"title": "Evaluation of Classifiers for an Uneven Class Distribution Problem", "author": ["Sophia Daskalaki", "Ioannis Kopanas", "Nikolaos Avouris"], "venue": "Applied Artificial Intelligence,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2006}, {"title": "Oksana Yakhnenko", "author": ["R. Bharath Rao"], "venue": "and Balaji Krishnapuram. KDD Cup 2008 and the Workshop on Mining Medical Data. SIGKDD Explorations Newsletter, 10(2):34\u201338", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2008}, {"title": "Evaluation of Different Biological Data and Computational Classification Methods for Use in Protein Interaction", "author": ["Yanjun Qi", "Ziv Bar-Joseph", "Judith Klein-Seetharaman"], "venue": "Prediction. Proteins,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2006}, {"title": "The UCI Machine Learning Repository", "author": ["A. Frank", "Arthur Asuncion"], "venue": "http://archive. ics.uci.edu/ml,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2010}, {"title": "The interplay between stability and regret in online learning", "author": ["Ankan Saha", "Prateek Jain", "Ambuj Tewari"], "venue": "CoRR, abs/1211.6158,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2012}, {"title": "Online Convex Programming and Generalized Infinitesimal Gradient Ascent", "author": ["Martin Zinkevich"], "venue": "In ICML, pages 928\u2013936,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2003}, {"title": "Probability Inequalities for the Sum in Sampling without Replacement", "author": ["Robert J. Serfling"], "venue": "Annals of Statistics,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 1974}], "referenceMentions": [{"referenceID": 0, "context": "Next, we instantiate within our framework, convex surrogates for two popular performances measures namely, Precision at k (Prec@k) and partial area under the ROC curve (pAUC) [2] and show, via a stability analysis, that we do indeed achieve sublinear regret bounds for these loss functions.", "startOffset": 175, "endOffset": 178}, {"referenceID": 1, "context": "Our methods apply to a wide family of loss functions (including Prec@k, pAUC and F-measure) that were introduced in [3] and have been widely adopted [4, 5, 6] in the literature.", "startOffset": 116, "endOffset": 119}, {"referenceID": 2, "context": "Our methods apply to a wide family of loss functions (including Prec@k, pAUC and F-measure) that were introduced in [3] and have been widely adopted [4, 5, 6] in the literature.", "startOffset": 149, "endOffset": 158}, {"referenceID": 3, "context": "Our methods apply to a wide family of loss functions (including Prec@k, pAUC and F-measure) that were introduced in [3] and have been widely adopted [4, 5, 6] in the literature.", "startOffset": 149, "endOffset": 158}, {"referenceID": 4, "context": "Our methods apply to a wide family of loss functions (including Prec@k, pAUC and F-measure) that were introduced in [3] and have been widely adopted [4, 5, 6] in the literature.", "startOffset": 149, "endOffset": 158}, {"referenceID": 5, "context": "We compare our methods to state-of-the-art methods that are based on cutting plane techniques [7].", "startOffset": 94, "endOffset": 97}, {"referenceID": 6, "context": "of performance on imbalanced datasets [8], their importance has risen to a point where they have become the learning objectives themselves.", "startOffset": 38, "endOffset": 41}, {"referenceID": 7, "context": "[9], [10] and [11] who study the F-measure.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9], [10] and [11] who study the F-measure.", "startOffset": 5, "endOffset": 9}, {"referenceID": 9, "context": "[9], [10] and [11] who study the F-measure.", "startOffset": 14, "endOffset": 18}, {"referenceID": 1, "context": "Starting from the seminal work of [3], this method has received a lot of interest for measures such as the F-measure [3], average precision [4], pAUC [7] and various ranking losses [5, 6].", "startOffset": 34, "endOffset": 37}, {"referenceID": 1, "context": "Starting from the seminal work of [3], this method has received a lot of interest for measures such as the F-measure [3], average precision [4], pAUC [7] and various ranking losses [5, 6].", "startOffset": 117, "endOffset": 120}, {"referenceID": 2, "context": "Starting from the seminal work of [3], this method has received a lot of interest for measures such as the F-measure [3], average precision [4], pAUC [7] and various ranking losses [5, 6].", "startOffset": 140, "endOffset": 143}, {"referenceID": 5, "context": "Starting from the seminal work of [3], this method has received a lot of interest for measures such as the F-measure [3], average precision [4], pAUC [7] and various ranking losses [5, 6].", "startOffset": 150, "endOffset": 153}, {"referenceID": 3, "context": "Starting from the seminal work of [3], this method has received a lot of interest for measures such as the F-measure [3], average precision [4], pAUC [7] and various ranking losses [5, 6].", "startOffset": 181, "endOffset": 187}, {"referenceID": 4, "context": "Starting from the seminal work of [3], this method has received a lot of interest for measures such as the F-measure [3], average precision [4], pAUC [7] and various ranking losses [5, 6].", "startOffset": 181, "endOffset": 187}, {"referenceID": 10, "context": "In particular [12] provides a generic framework for online learning with non-additive notions of regret with a focus on showing regret bounds for mixed strategies in a variety of problems.", "startOffset": 14, "endOffset": 18}, {"referenceID": 11, "context": "Recently, online learning for AUC maximization has received some attention [13, 14].", "startOffset": 75, "endOffset": 83}, {"referenceID": 12, "context": "Recently, online learning for AUC maximization has received some attention [13, 14].", "startOffset": 75, "endOffset": 83}, {"referenceID": 11, "context": "Although AUC is not a point loss function, it still decomposes over pairs of points in a dataset, a fact that [13] and [14] crucially use.", "startOffset": 110, "endOffset": 114}, {"referenceID": 12, "context": "Although AUC is not a point loss function, it still decomposes over pairs of points in a dataset, a fact that [13] and [14] crucially use.", "startOffset": 119, "endOffset": 123}, {"referenceID": 1, "context": "A popular technique for constructing such loss functions is the structural SVM formulation [3] given below.", "startOffset": 91, "endOffset": 94}, {"referenceID": 5, "context": "The structural surrogate for this performance measure can be equivalently expressed in a simpler form by replacing the indicator functions I [\u00b7] with hinge loss as follows (see [7], Theorem 4) `pAUC(w) = \u2211", "startOffset": 177, "endOffset": 180}, {"referenceID": 1, "context": "[3] uses a slightly modified, but equivalent, definition that considers labels to be Boolean.", "startOffset": 0, "endOffset": 3}, {"referenceID": 11, "context": "We note that our framework also recovers the model for online AUC maximization used in [13] and [14].", "startOffset": 87, "endOffset": 91}, {"referenceID": 12, "context": "We note that our framework also recovers the model for online AUC maximization used in [13] and [14].", "startOffset": 96, "endOffset": 100}, {"referenceID": 1, "context": "In Appendix D, we show that the same technique can be used to prove a stability result for the structural SVM surrogate of the Precision-Recall Break Even Point (PRBEP) performance measure [3] as well.", "startOffset": 189, "endOffset": 192}, {"referenceID": 13, "context": "The motivation for our approach comes from mini-batch methods used to make learning methods for point loss functions amenable to distributed computing environments [15, 16], we exploit these techniques to offer scalable algorithms for non-decomposable loss functions.", "startOffset": 164, "endOffset": 172}, {"referenceID": 14, "context": "The motivation for our approach comes from mini-batch methods used to make learning methods for point loss functions amenable to distributed computing environments [15, 16], we exploit these techniques to offer scalable algorithms for non-decomposable loss functions.", "startOffset": 164, "endOffset": 172}, {"referenceID": 11, "context": "method exploits this by utilizing two passes over the data: the first pass collects all (or a random subset of) points of the rare label using some stream sampling technique [13].", "startOffset": 174, "endOffset": 178}, {"referenceID": 15, "context": "However, the same is not true for non-decomposable loss functions barring a few exceptions [17, 10].", "startOffset": 91, "endOffset": 99}, {"referenceID": 8, "context": "However, the same is not true for non-decomposable loss functions barring a few exceptions [17, 10].", "startOffset": 91, "endOffset": 99}, {"referenceID": 16, "context": "Using regularized formulations, we can also exploit logarithmic regret guarantees [18], offered by online gradient descent, to improve this result - however we do not explore those considerations here.", "startOffset": 82, "endOffset": 86}, {"referenceID": 15, "context": "A similar result for the special case \u03b2 = 1 is due to [17].", "startOffset": 54, "endOffset": 58}, {"referenceID": 1, "context": "The above result can be extended to a large family of performances measures introduced in [3] that have been widely adopted [10, 19, 8] such as F-measure, G-mean, and PRBEP.", "startOffset": 90, "endOffset": 93}, {"referenceID": 8, "context": "The above result can be extended to a large family of performances measures introduced in [3] that have been widely adopted [10, 19, 8] such as F-measure, G-mean, and PRBEP.", "startOffset": 124, "endOffset": 135}, {"referenceID": 17, "context": "The above result can be extended to a large family of performances measures introduced in [3] that have been widely adopted [10, 19, 8] such as F-measure, G-mean, and PRBEP.", "startOffset": 124, "endOffset": 135}, {"referenceID": 6, "context": "The above result can be extended to a large family of performances measures introduced in [3] that have been widely adopted [10, 19, 8] such as F-measure, G-mean, and PRBEP.", "startOffset": 124, "endOffset": 135}, {"referenceID": 5, "context": "Algorithms: For partial AUC, we compare against the state-of-the-art cutting plane (CP) and projected subgradient methods (PSG) proposed in [7]; unlike the (online) stochastic methods", "startOffset": 140, "endOffset": 143}, {"referenceID": 1, "context": "For Prec@k and F-measure, we compare our methods against cutting plane methods from [3].", "startOffset": 84, "endOffset": 87}, {"referenceID": 18, "context": "Datasets: We used several data sets for our experiments (see Table 1); of these, KDDCup08 is from the KDD Cup 2008 challenge and involves a breast cancer detection task [20], PPI contains data for a protein-protein interaction prediction task [21], and the remaining datasets are taken from the UCI repository [22].", "startOffset": 169, "endOffset": 173}, {"referenceID": 19, "context": "Datasets: We used several data sets for our experiments (see Table 1); of these, KDDCup08 is from the KDD Cup 2008 challenge and involves a breast cancer detection task [20], PPI contains data for a protein-protein interaction prediction task [21], and the remaining datasets are taken from the UCI repository [22].", "startOffset": 243, "endOffset": 247}, {"referenceID": 20, "context": "Datasets: We used several data sets for our experiments (see Table 1); of these, KDDCup08 is from the KDD Cup 2008 challenge and involves a breast cancer detection task [20], PPI contains data for a protein-protein interaction prediction task [21], and the remaining datasets are taken from the UCI repository [22].", "startOffset": 310, "endOffset": 314}], "year": 2014, "abstractText": "Modern applications in sensitive domains such as biometrics and medicine frequently require the use of non-decomposable loss functions such as precision@k, F-measure etc. Compared to point loss functions such as hinge-loss, these offer much more fine grained control over prediction, but at the same time present novel challenges in terms of algorithm design and analysis. In this work we initiate a study of online learning techniques for such non-decomposable loss functions with an aim to enable incremental learning as well as design scalable solvers for batch problems. To this end, we propose an online learning framework for such loss functions. Our model enjoys several nice properties, chief amongst them being the existence of efficient online learning algorithms with sublinear regret and online to batch conversion bounds. Our model is a provable extension of existing online learning models for point loss functions. We instantiate two popular losses, Prec@k and pAUC, in our model and prove sublinear regret bounds for both of them. Our proofs require a novel structural lemma over ranked lists which may be of independent interest. We then develop scalable stochastic gradient descent solvers for non-decomposable loss functions. We show that for a large family of loss functions satisfying a certain uniform convergence property (that includes Prec@k, pAUC, and F-measure), our methods provably converge to the empirical risk minimizer. Such uniform convergence results were not known for these losses and we establish these using novel proof techniques. We then use extensive experimentation on real life and benchmark datasets to establish that our method can be orders of magnitude faster than a recently proposed cutting plane method.", "creator": "LaTeX with hyperref package"}}}