{"id": "1411.2800", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "11-Nov-2014", "title": "Exploiting Parallelism for Hard Problems in Abstract Argumentation: Technical Report", "abstract": "abstract argumentation framework ( \\ afname ) sh is a unifying semantics framework term able to encompass a variety of nonmonotonic reasoning approaches, logic programming and computational argumentation. yet, efficient approaches for most of the decision and enumeration problems associated to \\ afname s are probably missing, thus potentially limiting the efficacy benefits of argumentation - based approaches in real domains. in this paper, commonly we present an algorithm for enumerating the preferred extensions of abstract argumentation frameworks which exploits parallel computation. to this purpose, the scc - recursive abstract semantics definition schema is adopted, where alternative extensions are defined at the level of specific sub - frameworks. the initial algorithm shows significant performance improvements in large frameworks, in large terms of number of solutions found and speedup.", "histories": [["v1", "Tue, 11 Nov 2014 13:33:33 GMT  (180kb)", "https://arxiv.org/abs/1411.2800v1", "Technical report of an accepted AAAI-2015 Paper"], ["v2", "Tue, 18 Nov 2014 14:31:12 GMT  (180kb)", "http://arxiv.org/abs/1411.2800v2", "Technical report of an accepted AAAI-2015 Paper"]], "COMMENTS": "Technical report of an accepted AAAI-2015 Paper", "reviews": [], "SUBJECTS": "cs.AI cs.DC", "authors": ["federico cerutti", "ilias tachmazidis", "mauro vallati", "sotirios batsakis", "massimiliano giacomin", "grigoris antoniou"], "accepted": false, "id": "1411.2800"}, "pdf": {"name": "1411.2800.pdf", "metadata": {"source": "CRF", "title": "Exploiting Parallelism for Hard Problems in Abstract Argumentation: Technical Report", "authors": ["Federico Cerutti", "Ilias Tachmazidis", "Mauro Vallati", "Sotirios Batsakis", "Massimiliano Giacomin", "Grigoris Antoniou"], "emails": ["f.cerutti@abdn.ac.uk", "ilias.tachmazidis@hud.ac.uk", "m.vallati@hud.ac.uk", "S.Batsakis@hud.ac.uk", "massimiliano.giacomin@unibs.it", "g.antoniou@hud.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 1.\n28 00\nv2 [\ncs .A\nI] 1\n8 N\nov 2\n01 4\nExploiting Parallelism for Hard Problems in Abstract Argumentation: Technical Report\nFederico Cerutti\u22171, Ilias Tachmazidis\u20202, Mauro Vallati\u20212, Sotirios Batsakis\u00a72, Massimiliano Giacomin\u00b63 and Grigoris Antoniou\u20162\n1School of Natural and Computing Science, King\u2019s College, University of Aberdeen, AB24 3UE Aberdeen, UK\n2School of Computing and Engineering, University of Huddersfield, HD1 3DH Huddersfield, UK 3Department of Information Engineering, University of Brescia, via Branze, 38, 25123, Brescia, Italy\nNovember 19, 2014"}, {"heading": "Abstract", "text": "Abstract argumentation framework (AF ) is a unifying framework able to encompass a variety of nonmonotonic reasoning approaches, logic programming and computational argumentation. Yet, efficient approaches for most of the decision and enumeration problems associated to AF s are missing, thus potentially limiting the efficacy of argumentation-based approaches in real domains. In this paper, we present an algorithm for enumerating the preferred extensions of abstract argumentation frameworks which exploits parallel computation. To this purpose, the SCC-recursive semantics definition schema is adopted, where extensions are defined at the level of specific subframeworks. The algorithm shows significant performance improvements in large frameworks, in terms of number of solutions found and speedup.\n\u2217f.cerutti@abdn.ac.uk \u2020ilias.tachmazidis@hud.ac.uk \u2021m.vallati@hud.ac.uk \u00a7S.Batsakis@hud.ac.uk \u00b6massimiliano.giacomin@unibs.it \u2016g.antoniou@hud.ac.uk"}, {"heading": "Introduction", "text": "Dung\u2019s theory of abstract argumentation [Dun95] is a unifying framework able to encompass a large variety of specific formalisms in the areas of nonmonotonic reasoning, logic programming and computational argumentation. It is based on the notion of argumentation framework (AF ), consisting of a set of arguments and an attack relation between them. Different argumentation semantics introduce in a declarative way the criteria to determine which arguments emerge as \u2018justified\u2019 from the conflict, by identifying a number of extensions, i.e. sets of arguments that can \u201csurvive the conflict together\u201d. In [Dun95] four \u201ctraditional\u201d semantics were introduced, namely complete, grounded, stable, and preferred semantics. For an introduction on alternative semantics, see [BCG11].\nThe main computational problems in abstract argumentation include decision and construction problems, and turn out to be computationally intractable for most of argumentation semantics [DW09]. In this paper we focus on the extension enumeration problem, i.e. constructing all extensions prescribed for a given AF : its solution provides complete information concerning the justification status of arguments and subsumes the solutions to the other problems.\nIn this paper we propose the first parallel approach for enumerating preferred extensions \u2014 a problem which lies at the second level of the polynomial hierarchy, thus justifying the quest for efficient solutions \u2014 which exploits the SCC-recursive schema [BGG05], a semantics definition schema where extensions are defined at the level of the sub-frameworks identified by the strongly connected components. A similar approach has been recently discussed in [CGVZ14] and compared with the state-of-the-art approach [CDGV13], but it does not exploit neither parallel nor dynamic programming techniques.\nAs large-scale argumentation is vastly unexplored, there is no further work directly related to our approach. The closest work is in the context of Assumption-Based Argumentation (ABA) Frameworks [BDKT97], an abstract framework for default reasoning which can be instantiated with different deductive systems (e.g. logic programming, autoepistemic logic, default logic). [CTC+12] describes a parallel implementation for credulous acceptance under the acceptablity semantics for some specific instances of ABAs in the medical domain. [CTC+12] considers competitive parallel executions: multiple versions \u2014 equivalent w.r.t. their outcome \u2014 of a sequential process are created and then started in parallel. Once one version finds a solution to the problem, the others are killed.\nOur work can be seen as part of a broader recent push towards large-scale reasoning which, among others, concerns simple semantic web reasoning [UKM+12], fuzzy ontologies [LQWY12] and logic programming [TAF14]. Indeed, the fast-growing field of argument mining from content in the Web [GCME12, CV13] highlights the lack of large-scale reasoning approaches in formal argumentation, and thus increases the importance of our research.\nThe paper is organised as follows. In the first section we recall some necessary background on Dung\u2019s AF , the SCC-recursive schema and the existing algorithmic approach exploiting it. In the subsequent section we present our approach for exploiting the SCC-recursive schema in a parallel fashion, and we discuss the theoretical re-\nmarks granting the correctness of the approach. An exhaustive experimental analysis is then presented in the forthcoming section. The last section concludes the paper and discusses future work."}, {"heading": "Background", "text": ""}, {"heading": "Dung\u2019s Argumentation Framework", "text": "An argumentation framework [Dun95] consists of a set of arguments1 and a binary attack relation between them.\nDefinition 1. An argumentation framework (AF ) is a pair \u0393 = \u3008A,R\u3009 where A is a set of arguments and R \u2286 A\u00d7A. We say that b attacks a iff \u3008b, a\u3009 \u2208 R, also denoted as b \u2192 a. The set of attackers of an argument a will be denoted as a\u2212 , {b : b \u2192 a}, the set of arguments attacked by a will be denoted as a+ , {b : a \u2192 b}. We also extend these notations to sets of arguments, i.e. given E \u2286 A, E\u2212 , {b | \u2203a \u2208 E, b \u2192 a} and E+ , {b | \u2203a \u2208 E, a \u2192 b}.\nAn argument a without attackers, i.e. such that a\u2212 = \u2205, is said initial. Moreover, each argumentation framework has an associated directed graph where the vertices are the arguments, and the edges are the attacks.\nThe basic properties of conflict\u2013freeness, acceptability, and admissibility of a set of arguments are fundamental for the definition of argumentation semantics.\nDefinition 2. Given an AF \u0393 = \u3008A,R\u3009: \u2022 a set T \u2286 A is a conflict\u2013free set of \u0393 if \u2204 a, b \u2208 T s.t. a \u2192 b; \u2022 an argument a \u2208 A is acceptable with respect to a set T \u2286 A of \u0393 if \u2200b \u2208 A s.t.\nb \u2192 a, \u2203 c \u2208 T s.t. c \u2192 b; \u2022 a set T \u2286 A is an admissible set of \u0393 if T is a conflict\u2013free set of \u0393 and every\nelement of T is acceptable with respect to T of \u0393.\nAn argumentation semantics \u03c3 prescribes for any AF \u0393 a set of extensions, denoted as E\u03c3(\u0393), namely a set of sets of arguments satisfying the conditions dictated by \u03c3. Here we recall the definitions of complete (denoted as CO), grounded (denoted as GR) and preferred (denoted as PR) semantics.\nDefinition 3. Given an AF \u0393 = \u3008A,R\u3009: \u2022 a set T \u2286 A is a complete extension of \u0393, i.e. T \u2208 ECO(\u0393), iff T is admissible\nand \u2200a \u2208 A s.t. a is acceptable w.r.t. T , a \u2208 T ; \u2022 a set T \u2286 A is the grounded extension of \u0393, i.e. T \u2208 EGR(\u0393), iff T is the minimal\n(w.r.t. set inclusion) complete extension of \u0393. Its existence and uniqueness have been proved in [DMT06]; \u2022 a set T \u2286 A is a preferred extension of \u0393, i.e. T \u2208 EPR(\u0393), iff T is a maximal (w.r.t. set inclusion) complete extension of \u0393.\n1In this paper we consider only finite sets of arguments: see [BCDG13] for a discussion on infinite sets of arguments.\nEach extension T implicitly defines a three-valued labelling of arguments: an argument a is labelled in iff a \u2208 T ; out iff \u2203 b \u2208 T s.t. b \u2192 a; undec otherwise. Argumentation semantics can be equivalently defined in terms of labellings rather than of extensions [Cam06, BCG11].\nDefinition 4. Given a set of arguments T , a labelling of T is a total function Lab : T \u2212\u2192 {in, out, undec}. The set of all labellings of T is denoted as LT . Given an AF \u0393 = \u3008A,R\u3009, a labelling of \u0393 is a labelling of A. The set of all labellings of \u0393 is denoted as L(\u0393).\nComplete labellings can be defined as follows.\nDefinition 5. Let \u0393 = \u3008A,R\u3009 be an argumentation framework. A labelling Lab \u2208 L(\u0393) is a complete labelling of \u0393 iff it satisfies the following conditions for any a \u2208 A:\n\u2022 Lab(a) = in \u21d4 \u2200b \u2208 a\u2212Lab(b) = out; \u2022 Lab(a) = out \u21d4 \u2203b \u2208 a\u2212 : Lab(b) = in.\nThe grounded and preferred labelling can then be defined on the basis of complete labellings.\nDefinition 6. Let \u0393 = \u3008A,R\u3009 be an argumentation framework. A labelling Lab \u2208 L(\u0393) is the grounded labelling of \u0393 if it is the complete labelling of \u0393 minimizing the set of arguments labelled in, and it is a preferred labelling of \u0393 if it is a complete labelling of \u0393 maximizing the set of arguments labelled in.\nThe function Ext2Lab provides the connection between extensions and labellings.\nDefinition 7. Given an AF \u0393 = \u3008A,R\u3009 and a conflict\u2013free set T \u2286 A, the corresponding labelling Ext2Lab(T ) is defined as Ext2Lab(T ) \u2261 Lab, where\n\u2022 Lab(a) = in \u21d4 a \u2208 T \u2022 Lab(a) = out \u21d4 \u2203 b \u2208 T s.t. b \u2192 a \u2022 Lab(a) = undec \u21d4 a /\u2208 T \u2227 \u2204 b \u2208 T s.t. b \u2192 a\n[Cam06] shows that there is a bijective correspondence between extensions and labellings for complete, grounded, and preferred semantics.\nProposition 1. Given an AF \u0393 = \u3008A,R\u3009, Lab is a complete (grounded, preferred) labelling of \u0393 if and only if there is a complete (grounded, preferred) extension T of \u0393 such that Lab = Ext2Lab(T ).\nThe set of complete labellings of \u0393 is denoted as LCO(\u0393), the set of preferred labellings as LPR(\u0393), while LGR(\u0393) denotes the set including the grounded labelling."}, {"heading": "SCC-Recursiveness", "text": "In [BG04] an extension-based semantics definition schema has been introduced, called SCC (strongly connected component)-recursiveness, based on the graph-theoretical notion of SCCs [Tar72, Lemma 9] and on the observation that most argumentation semantics can be equivalently defined at the level of SCCs.\nThe following definitions introduce the SCC-recursive schema [BGG05]. First, let us recall the definition of restriction of an AF \u0393 to a set of arguments I , in symbol \u0393\u2193I .\nDefinition 8. Given an argumentation framework \u0393 = \u3008A,R\u3009 and a set I \u2286 A, the restriction of \u0393 to I is defined as \u0393\u2193I \u2261 (I,R\u2229 (I \u00d7 I)).\nThen, Definition 9 introduces the function GF(\u0393, C) which recursively computes the semantics extensions on the basis of the SCCs of \u0393. Let us denote as SCC\u0393 the set including the SCCs of an argumentation framework \u0393.\nDefinition 9. A given argumentation semantics \u03c3 is SCC-recursive if for any argumentation framework \u0393 = \u3008A,R\u3009, E\u03c3(\u0393) = GF(\u0393,A) \u2286 2A. For any \u0393 = \u3008A,R\u3009 and for any set C \u2286 A, E \u2208 GF(\u0393, C) if and only if\n\u2022 E \u2208 BF\u03c3(\u0393, C) if |SCC\u0393| = 1 \u2022 \u2200S \u2208 SCC\u0393 (E \u2229 S) \u2208 GF(\u0393\u2193S\\(E\\S)+ , U\u0393(S,E) \u2229 C) otherwise\nwhere \u2022 BF\u03c3(\u0393, C) is a function, called base function, that, given an argumentation\nframework \u0393 = \u3008A,R\u3009 such that |SCC\u0393| = 1 and a set C \u2286 A, gives a subset of 2A\n\u2022 U\u0393(S,E) = {a \u2208 S \\ (E \\ S)+ | \u2200b \u2208 (a\u2212 \\ S), b \u2208 E+}\nThe schema is based on the notions of extension of an AF in a set of arguments.\nDefinition 10. Given an AF \u0393 = \u3008A,R\u3009 and a set C \u2286 A, a set E \u2286 A is: an admissible set of \u0393 in C if and only if E is an admissible set of \u0393 and E \u2286 C; a complete extension of \u0393 in C if and only if E is an admissible set of \u0393 in C, and every argument \u03b1 \u2208 C which is acceptable with respect to E belongs to E; the grounded extension of \u0393 in C if and only if it is the least (w.r.t. set inclusion) complete extension of \u0393 in C; a preferred extension of \u0393 in C if and only if it is a maximal (w.r.t. set inclusion) complete extension of \u0393 in C.\nThe existence and uniqueness of the grounded extension in C, as well as the existence of at least a preferred extension in C, have been proved in [BGG05]. Moreover, [BGG05] proves that GF(\u0393, C), as defined in Def. 9, returns the \u03c3-extensions in C (with \u03c3 \u2208 {CO,GR,PR}), provided that BF\u03c3(\u0393, C) returns the complete, grounded, and preferred extensions in C, respectively.\n[CGVZ14] introduces the notions of complete, grounded and preferred labellings of \u0393 in C, i.e. the labelling-based counterparts of the corresponding notions of Definition 10, and describes a preliminary algorithm \u2014 R-PREF \u2014 exploiting the SCCrecursive schema. R-PREF implements GF (Def. 9), where the chosen base function BFPR is computed by a refinement of the algorithm in [CDGV13] which exploits a SAT solver as a NP-oracle to determine the preferred labellings. R-PREF exploits the SCC-recursive schema by constructing a sequence of strongly connected components of \u0393 in a topological order. Preferred labellings are incrementally constructed along the SCCs, by computing the preferred labellings of each SCC and merging them with those identified in the previous SCCs. In the following, we take advantage of two algorithms mentioned in [CGVZ14], namely GROUNDED [CGVZ14, Alg. 3] and B-PR [CGVZ14, Alg. 4]: their usage is described in the following section."}, {"heading": "Exploiting Parallel Computation", "text": "In this section we present our approach exploiting parallel computation in the context of the SCC-recursive schema. First of all, we need to identify when it is possible to parallelise the process aimed at verifying that given \u0393 = \u3008A,R\u3009, \u2200E \u2286 A, \u2200C \u2286 A, E \u2208 GF(\u0393, C)."}, {"heading": "Theoretical Remarks", "text": "Two elements guaranteeing independence and thus the possibility to parallelise the process can be identified. First of all, each preferred extension can be computed independently from the others.\nRemark 1. Given an\u0393 = \u3008A,R\u3009, \u2200E \u2208 E\u03c3(\u0393), \u2200C \u2286 A, proving thatE \u2208 GF(\u0393, C) does not require any knowledge about E \u2208 E\u03c3(\u0393) \\ {E}.\nA second, rather more articulated, condition of independence requires to identify two sets of SCCs, S = {S1, . . . , Sn} \u2286 SCC\u0393 and PS = {P1, . . . , Pm} \u2286 SCC\u0393 such that (1) each SCC in S does not attack the others in S; and (2) each SCC in S is attacked only by SCCs in PS .\nRemark 2. Given an\u0393 = \u3008A,R\u3009, \u2200E \u2286 A, \u2200C \u2286 A, if there exist S = {S1, . . . , Sn} \u2286 SCC\u0393 such that \u2200Si, Sj, S + i \u2229 Sj = \u2205, and there exists PS \u2286 SCC\u0393 such that \u2200Si \u2208 S, (Si \u2212\\Si) \u2286 \u22c3 P\u2208P\nS P , then \u2200S \u2208 S proving that (E\u2229S) \u2208 GF(\u0393\u2193S\\(E\\S)+ , U\u0393(S,E)\u2229 C) can be determined in function of PS and does not require any knowledge about S\u2032 \u2208 S \\ {S}."}, {"heading": "The P-SCC-REC Algorithm", "text": "In this section we introduce a meta-algorithm \u2014 P-SCC-REC (Alg. 2) \u2014 which exploits the SCC-recursive schema using parallel computation and a pro-active greedy approach which memoizes some notable cases.\nFirst of all, the function P-PREF (Algorithm 1) receives as input an argumentation framework \u0393 = \u3008A,R\u3009 and returns the set of preferred labellings of \u0393. This is simply achieved by invoking (at line 3) P-SCC-REC(\u0393,A), where the function P-SCC-REC (GF in Def. 9) receives as input an argumentation framework \u0393 = \u3008A,R\u3009 and a set C \u2286 A, and computes the set LPR(\u0393, C), i.e. the set of preferred labellings of \u0393 in C.\nP-SCC-REC first pre-processes (at line 3) \u2014 via the function GROUNDED [CGVZ14, Alg. 3] \u2014 \u0393 by computing the grounded labelling in C: Lab contains the restriction of the grounded labelling to those arguments which are either in or out; U is the set of arguments that are labelled undec in the grounded labelling.\nAt line 4 P-SCC-REC initialises to {Lab} the variable Ep, which stores the set of labellings that are incrementally constructed. At line 5 P-SCC-REC restricts \u0393 to \u0393\u2193U . Then, at line 6, P-SCC-REC exploits Remark 2 by building a list L := (L1, . . . , Ln) of sets of SCCs \u2014 [CLRS09, p. 617] with some modifications \u2014 such that \u2200Li \u2208 L,Li = {Sij \u2208 SCC\u0393 | (S i j) \u2212 \\ Sij \u2208 \u22c3 z\u2208{1,...,i\u22121} \u22c3 S\u2208Lz S and (S i j)\n+ \\ Sij \u2208\u22c3 z\u2208{i+1,...,n} \u22c3 S\u2208Lz S}.\nAlgorithm 1 Computing preferred labellings of an AF P-PREF(\u0393)\n1: Input: \u0393 = \u3008A,R\u3009 2: Output: Ep \u2208 2L(\u0393) 3: return P-SCC-REC(\u0393,A)\nAt line 7, the GREEDY function (Alg. 3) is called; it receives as input the list of SCCs L and the set of arguments C, and returns a set M of pairs (Si, Bi) where Si \u2208 SCC\u0393, and Bi = LPR(\u0393\u2193Si , Si \u2229 C). Bi \u2014 computed by the function B-PR [CGVZ14, Alg. 4] \u2014 is the set of preferred labellings for Si when no argument in Si is attacked by in or undec arguments in previous, w.r.t. the L list, SCCs.\nAlgorithm 2 Computing preferred labellings of an AF in C P-SCC-REC(\u0393, C)\n1: Input: \u0393 = \u3008A,R\u3009, C \u2286 A 2: Output: Ep \u2208 2L(\u0393) 3: (Lab, U) = GROUNDED(\u0393, C) 4: Ep := {Lab} 5: \u0393 = \u0393\u2193U 6: L:= (L1 := {S11 , . . . , S 1 k}, . . . , L n := {Sn1 , . . . , S n h}) = SCCS-LIST(\u0393) 7: M := {. . . , (Si, Bi), . . .} = GREEDY(L,C) 8: for l \u2208 {1, . . . , n} do 9: El := {E S1 l := (), . . . , E Sk l := ()}\n10: for S \u2208 Ll do in parallel 11: for Lab \u2208 Ep do in parallel 12: (O, I) := L-COND(\u0393, S, Ll,Lab) 13: if I = \u2205 then 14: ESl [Lab] ={{(a, out) | a \u2208 O} \u222a\n{(a, undec) | a \u2208 S \\O}}\n15: else 16: if I = S then 17: ESl [Lab] = B where (S,B) \u2208 M 18: else 19: if O = \u2205 then 20: ESl [Lab] = B-PR(\u0393\u2193S , I \u2229C) 21: else 22: ESl [Lab]={{(a, out) | a \u2208 O}} 23: ESl [Lab]= E S l [Lab]\u2297\nP-SCC-REC(\u0393\u2193S\\O, I \u2229 C)\n24: end if 25: end if 26: end if 27: end for 28: end for 29: for S \u2208 Ll do 30: E\u2032p := \u2205 31: for Lab \u2208 Ep do in parallel 32: E\u2032p = E \u2032 p \u222a ({Lab} \u2297 E S l [Lab]) 33: end for 34: Ep := E \u2032 p 35: end for 36: end for 37: return Ep\nThen, at lines 8\u2212 36, P-SCC-REC performs a first loop among the elements of the list L. At line 9 a rather articulated data structure, El, is initialised. For each S \u2208 Ll, ESl is a list of pairs (Lab, E S l [Lab] \u2286 LS): to ease of notation, hereafter we omit the pair-structure thus referring directly to ESl [Lab] which contains the set of preferred labellings of S constructed on the basis of a specific labelling Lab identified in the previous (w.r.t. the list L) SCCs.\nTwo more loops are thus considered and their execution can be safely parallelised: the loop at lines 10\u221228 exploits Remark 2 by considering each SCC in a given element of the list L; while the loop at lines 11\u2212 27 considers a single preferred labelling, each of which is independent from the others \u2014 cf. Remark 1.\nL-COND(\u0393, S, Ll,Lab) at line 12 computes the effect of previous SCCs, and returns (O, I), where:\n\u2022 O = {a \u2208 S | \u2203b \u2208 T \u2229 a\u2212 : Lab(b) = in} and \u2022 I = {a \u2208 S | \u2200 b \u2208 T \u2229 a\u2212,Lab(b) = out},\nwith T \u2261 \u22c3l\u22121\ni=1 \u22c3 S\u2208Li\nS. Variable O is set to include arguments of S that are attacked by \u201coutside\u201d in-labelled arguments according to Lab, and variable I is set to include arguments of S that are only attacked by \u201coutside\u201d out-labelled arguments. This gives rise to three cases:\n1. each argument of S is attacked by in or undec arguments in previous SCCs \u2014 hence each argument of S is labelled out or undec (line 14); 2. no argument of S is attacked by in arguments in previous SCCs: this is the base case of the recursion and thus either we exploit the memoization technique implemented with the GREEDY algorithm (line 17) or we exploit the function B-PR (line 20); 3. in the remaining case, arguments attacked by in-arguments are labelled as out and P-SCC-REC is recursively called on the restriction of S to the unlabelled arguments (lines 22\u2212 23).\nFinally, at lines 29 \u2212 35 the computed preferred labellings ESl [Lab] are merged together (E1 \u2297 E2 = {Lab1 \u222a Lab2|Lab1 \u2208 E1,Lab2 \u2208 E2}) with the Lab labelling of previous SCCs. Once again, due to Remark 1, this process can be parallelised (lines 31\u2212 33).\nThen the algorithm considers the next element in the list L. Once the outer loop is exited, all strongly connected components have been processed, thus Ep is returned as the set of preferred labellings in C (line 37).\nAlgorithm 3 Greedy computation of base cases GREEDY(L,C)\n1: Input: L = (L1, . . . , Ln := {Sn1 , . . . , S n h}), C \u2286 A 2: Output: M = {. . . , (Si, Bi), . . .} 3: M := \u2205 4: for S \u2208 \u22c3n i=1 L\ni do in parallel 5: B := B-PR(\u0393\u2193S , S \u2229 C) 6: M = M \u222a {(S,B)} 7: end for 8: return M\nTheorem 1. Given an AF \u0393 = \u3008A,R\u3009 and a set C \u2286 A, Algorithm 2 returns Ep = LPR(\u0393, C).\nProof. This follows from [CGVZ14, Thm. 1] and Remarks 1 and 2."}, {"heading": "Empirical Analysis", "text": "The solvers have been run on a cluster with computing nodes equipped with 2.4 Ghz Dual Core AMD OpteronTM, 8 GB of RAM and Linux operating system. As in the International Planning Competition (IPC) [JdlRF+12], a cutoff of 900 seconds was imposed to compute the preferred extensions for each AF . No limit was imposed on the RAM usage, but a run fails at saturation of the available memory. Moreover, we adopted the IPC speed score, also borrowed from the planning community, which is defined as follows. For each AF , each system gets a score of 1/(1 + log10(T/T\n\u2217)), where T is its execution time and T \u2217 the best execution time among the compared systems, or a score of 0 if it fails in that case. Runtimes below 0.01 sec get by default the maximal score of 1. In our experimental analysis, IPC score is normalised to 100. For each solver we recorded the overall result: success (if it finds each preferred extension), crashed, timed-out or ran out of memory.\nAs shown in [CGV14a], most of the state-of-the-art approaches for enumerating preferred extensions hardly solve large (w.r.t. the number of arguments) frameworks. In this work, we focus on extremely large AF s; the largest \u2013 as far as we know \u2013 that have ever been used for testing solvers.\nWe randomly generated a set of 200 AF s, varying the number of SCCs between 90 and 210, the number of arguments between 2,700 and 8,400, and considering different uniformly distributed probabilities of attacks, either between arguments or between different SCCs, leading to AF s with a number of attacks between approximately 100 thousands and 2 millions. AF s were generated using AFBenchGen [CGV14b].\nIn the following we rely on the Wilcoxon Signed-Rank Test (WSRT) in order to identify significant subset of data [Wil45].\nTable 1 shows the results of the overall comparison between R-PREF (henceforth P1) and P-SCC-REC (henceforth P2 or P4, according to the number of processors). The latter exploits either two or four processors, and has been run with and without\nthe greedy approach. From Table 1, two main conclusions can be derived. First, the exploitation of greedy approach introduces a significant overhead, due to the required pre-calculation. In our testing instances, pre-calculated knowledge is not used by algorithms and therefore, exploiting a greedy approach has a detrimental effect on P2 and P4 performance. This behaviour is confirmed also by a comparison (not shown) between P1 with/out greedy approach. Given this result, the greedy approach will not be considered in the rest of this section.\nThe second conclusion we derive from Table 1 is that parallelisation improves significantly the performance of both runtime and the number of successfully analysed AF s. Since the normalised IPC score of P4 is equal to its percentage of successes, P4 is always the fastest approach on the whole testing set. Both P4 and P2, according to WRST perform significantly better than P1 (p < 0.05). Using 2 (resp. 4) processors provides a maximum speed-up of 1.9 (resp. 2.8) times w.r.t. serial execution. Such results justify the use of parallel approaches in abstract argumentation.\nP1 vs P2\n0 150 300 450 600 750 900\nIPC value (normalised) w.r.t. di erent atta k probabilities\nFigure 1 provides results in the form of scatterplots, showing the performance of P1 and, respectively, P2 and P4. Using 2 processors have a remarkable impact on runtimes, in particular on complex AF s, which require approximately more than 300 seconds. A larger number of AF s can be successfully analysed by P2: this can be derived by observing the elements on the right axis of the graph. On simple AF s, the impact of using 2 processors is not so clear. On the other hand, parallelising on 4 processors guarantee to obtain lower runtimes on the whole testing set. This behaviour is probably due to the fact that the overhead introduced by parallelisation (generating threads, communication overhead, etc.) is not completely compensated by using 2 processors only, specially when a short amount of CPU time is needed for enumerating the extensions of a given AF .\nThe number of SCCs in the same set, cf. Remark 2, critically affects the performance of the proposed parallel algorithm. The larger the size of each level, the higher the degree of parallelisation that can be reached, since parallelisation is primarily based on processing simultaneously SCCs that are located on the same level. Figure 2 (upper) show the IPC score of parallelised and serial algorithms, with regards to the probability of attacks between SCCs. As expected, the performance gap between parallelised (P2, P4) and serial (P1) algorithms is maximum when the probability is 0 \u2014 i.e., all the SCCs are on the same level \u2014 and slowly decreases as the percentage increases. With a probability of 75%, most of the levels have a single SCC, therefore parallelisation does not provide a great speedup. It is worthy to notice that at higher attacks probability percentages, enumerating all the preferred extensions is very complex, and requires a significant amount of CPU-time. The differences of performance between P1 and P4 are always statistically significant (p < 0.05). It is not the case of P1 and P2, their performance are statistically indistinguishable on sets with probability of attacks of 50% (p = 0.39) and 75% (p = 0.66).\nFinally, Figure 2 shows how IPC score of considered algorithms changes with regard to the number of SCCs of the AF s. As a general trend, increasing the number of SCCs increases the runtime (and decreases the number of successes) for all implementations. This is expected, as larger inputs are harder to solve. On the other hand, P1 is very quick on smallest considered AF s; on average it is faster than P2. P1 performance rapidly decreases as the number of SCCs increases. This is also confirmed by the WRST: while P4 is always statistically better than P1, P2 performs statistically worse than P1 on AF s with |SCCs| = 90, but it performs statistically better when |SCCs| >= 120. Generally, parallelisation provides best speedup on very large AF s, with lower probability of attacks among SCCs."}, {"heading": "Conclusions", "text": "In this paper we proposed an approach for exploiting the SCC-recursive schema for computing semantics extensions in Dung\u2019s AF s taking advantage of parallel executions and dynamic programming. It is worth mentioning that Alg. 1, in conjunction with Algs. 2 and 3, are meta-algorithms that implement the SCC-recursive schema independently from the chosen semantics. Although we chose to consider the preferred semantics in order to provide a direct comparison with recent works [CGVZ14] \u2014 in\nessence equivalent to P1 \u2014 , the same algorithms can work for each semantics that is SCC-recursive [BGG05].\nMoreover, the empirical analysis shows that there is a substantial statistically significant increment of performance due to the partial parallel execution of the proposed algorithms. This results in:\n1. an increment (approx. 50%) of the number of AF s for which we can solve the preferred semantics enumeration problem before the chosen cutoff time; 2. a significant speedup of the computation of preferred extension up to 280% just considering 4 processors.\nFuture work is already envisaged in the area of additional experimentation analyses by considering different benchmarks and by discussing a variation of Alg. 2 where the two inner loops of Alg. 2 (lines 10\u221224 and 11\u221223) are swapped. We also plan to apply more dynamic programming techniques (e.g. memoization) by improving the current proposal of the greedy computation of some preferred labelling \u2014 Alg. 3. In addition, we will compare our approach with [DGWW11, ES14], which reduce the problem of enumerating preferred extensions to an ASP program which can be solved using the parallel ASP solver clingo. Finally, recent works on Input/Output behaviour characterisation of AF s [BBC+12, BBC+14] can be exploited for determining conditions of independent computation and thus exploiting parallel executions on graph structures different from SCCs."}], "references": [{"title": "On Input/Output Argumentation Frameworks", "author": ["Pietro Baroni", "Guido Boella", "Federico Cerutti", "Massimiliano Giacomin", "Leendert van der Torre", "Serena Villata"], "venue": "In Proceedings of the 4th International Conference on Computational Models of Arguments (COMMA", "citeRegEx": "Baroni et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2012}, {"title": "On the input/output behavior of argumentation frameworks", "author": ["Pietro Baroni", "Guido Boella", "Federico Cerutti", "Massimiliano Giacomin", "Leendert van der Torre", "Serena Villata"], "venue": "Artificial Intelligence,", "citeRegEx": "Baroni et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2014}, {"title": "Automata for Infinite Argumentation Structures", "author": ["Pietro Baroni", "Federico Cerutti", "Paul E. Dunne", "Massimiliano Giacomin"], "venue": "Artificial Intelligence,", "citeRegEx": "Baroni et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2013}, {"title": "An introduction to argumentation semantics", "author": ["P Baroni", "M Caminada", "M Giacomin"], "venue": "Knowledge Engineering Review,", "citeRegEx": "Baroni et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2011}, {"title": "An abstract, argumentation-theoretic approach to default reasoning", "author": ["A. Bondarenko", "P.M. Dung", "R.A. Kowalski", "F. Toni"], "venue": "Artificial Intelligence,", "citeRegEx": "Bondarenko et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Bondarenko et al\\.", "year": 1997}, {"title": "A General Recursive Schema for Argumentation Semantics", "author": ["Pietro Baroni", "Massimiliano Giacomin"], "venue": "In Proceedings of the 14th European Conference on Artificial Intelligence (ECAI", "citeRegEx": "Baroni and Giacomin.,? \\Q2004\\E", "shortCiteRegEx": "Baroni and Giacomin.", "year": 2004}, {"title": "SCCrecursiveness: a general schema for argumentation semantics", "author": ["Pietro Baroni", "Massimiliano Giacomin", "Giovanni Guida"], "venue": "Artificial Intelligence,", "citeRegEx": "Baroni et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2005}, {"title": "On the Issue of Reinstatement in Argumentation", "author": ["Martin Caminada"], "venue": "In Proceedings of the 10th European Conference on Logics in Artificial Intelligence (JELIA", "citeRegEx": "Caminada.,? \\Q2006\\E", "shortCiteRegEx": "Caminada.", "year": 2006}, {"title": "Computing Preferred Extensions in Abstract Argumentation: A SAT-Based Approach", "author": ["Federico Cerutti", "Paul E. Dunne", "Massimiliano Giacomin", "Mauro Vallati"], "venue": "In Proceedings of Theory and Applications of Formal Argumentation (TAFA),", "citeRegEx": "Cerutti et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Cerutti et al\\.", "year": 2013}, {"title": "Algorithm selection for preferred extensions enumeration", "author": ["Federico Cerutti", "Massimiliano Giacomin", "Mauro Vallati"], "venue": "In Proceedings of the 5th International Conference on Computational Models of Argument (COMMA),", "citeRegEx": "Cerutti et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Cerutti et al\\.", "year": 2014}, {"title": "Generating challenging benchmark AFs", "author": ["Federico Cerutti", "Massimiliano Giacomin", "Mauro Vallati"], "venue": "In Proceedings of the 5th International Conference on Computational Models of Argument (COMMA),", "citeRegEx": "Cerutti et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Cerutti et al\\.", "year": 2014}, {"title": "A SCC recursive meta-algorithm for computing preferred labellings in abstract argumentation", "author": ["Federico Cerutti", "Massimiliano Giacomin", "Mauro Vallati", "Marina Zanella"], "venue": "In Proceedings of the 14th International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Cerutti et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Cerutti et al\\.", "year": 2014}, {"title": "Introduction to Algorithms", "author": ["Thomas H. Cormen", "Charles E. Leiserson", "Ronald L. Rivest", "Clifford Stein"], "venue": null, "citeRegEx": "Cormen et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Cormen et al\\.", "year": 2009}, {"title": "Efficient argumentation for medical decisionmaking", "author": ["Robert Craven", "Francesca Toni", "Cristian Cadar", "Adrian Hadad", "Matthew Williams"], "venue": "In Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR),", "citeRegEx": "Craven et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Craven et al\\.", "year": 2012}, {"title": "A natural language bipolar argumentation approach to support users in online debate interactions", "author": ["Elena Cabrio", "Serena Villata"], "venue": "Argument  Computation,", "citeRegEx": "Cabrio and Villata.,? \\Q2013\\E", "shortCiteRegEx": "Cabrio and Villata.", "year": 2013}, {"title": "Making Use of Advances in Answer-Set Programming for Abstract Argumentation Systems", "author": ["Wolfgang Dvo\u0159\u00e1k", "Sarah Alice Gaggl", "Johannes Wallner", "Stefan Woltran"], "venue": "In Proceedings of the 19th International Conference on Applications of Declarative Programming and Knowledge Management (INAP", "citeRegEx": "Dvo\u0159\u00e1k et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Dvo\u0159\u00e1k et al\\.", "year": 2011}, {"title": "A dialectic procedure for sceptical, assumption-based argumentation", "author": ["P M Dung", "P Mancarella", "F Toni"], "venue": "In Prooceedings of the 1st International Conference on Computational Models of Arguments (COMMA", "citeRegEx": "Dung et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Dung et al\\.", "year": 2006}, {"title": "On the Acceptability of Arguments and Its Fundamental Role in Nonmonotonic Reasoning, Logic Programming, and n-Person Games", "author": ["P M Dung"], "venue": "Artificial Intelligence,", "citeRegEx": "Dung.,? \\Q1995\\E", "shortCiteRegEx": "Dung.", "year": 1995}, {"title": "Complexity of abstract argumentation", "author": ["Paul E. Dunne", "Michael Wooldridge"], "venue": "In I Rahwan and G Simari, editors, Argumentation in AI,", "citeRegEx": "Dunne and Wooldridge.,? \\Q2009\\E", "shortCiteRegEx": "Dunne and Wooldridge.", "year": 2009}, {"title": "The DIAMOND System for Computing with Abstract Dialectical Frameworks", "author": ["Stefan Ellmauthaler", "Hannes Strass"], "venue": "In Proceedings of the 5th International Conference on Computational Models of Argument (COMMA),", "citeRegEx": "Ellmauthaler and Strass.,? \\Q2014\\E", "shortCiteRegEx": "Ellmauthaler and Strass.", "year": 2014}, {"title": "Empowering an e-government platform through twitterbased arguments", "author": ["Kathrin Grosse", "Carlos Iv\u00e1n Ches\u00f1evar", "Ana Gabriela Maguitman", "Elsa Estevez"], "venue": "Inteligencia Artificial, Revista Iberoamericana de Inteligencia Artificial,", "citeRegEx": "Grosse et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Grosse et al\\.", "year": 2012}, {"title": "A review of machine learning for automated planning", "author": ["Sergio Jim\u00e9nez", "Tom\u00e1s de la Rosa", "Susana Fern\u00e1ndez", "Fernando Fern\u00e1ndez", "Daniel Borrajo"], "venue": "Knowledge Engineering Review,", "citeRegEx": "Jim\u00e9nez et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Jim\u00e9nez et al\\.", "year": 2012}, {"title": "Reasoning with Large Scale Ontologies in Fuzzy pD* Using MapReduce", "author": ["Chang Liu", "Guilin Qi", "Haofen Wang", "Yong Yu"], "venue": "Computational Intelligence Magazine, IEEE,", "citeRegEx": "Liu et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Liu et al\\.", "year": 2012}, {"title": "Efficient Computation of the Well-Founded Semantics over Big Data", "author": ["Ilias Tachmazidis", "Grigoris Antoniou", "Wolfgang Faber"], "venue": "TPLP, 14(45):445\u2013459,", "citeRegEx": "Tachmazidis et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Tachmazidis et al\\.", "year": 2014}, {"title": "Depth-first search and linear graph algorithms", "author": ["Robert Endre Tarjan"], "venue": "SIAM J. Comput.,", "citeRegEx": "Tarjan.,? \\Q1972\\E", "shortCiteRegEx": "Tarjan.", "year": 1972}, {"title": "WebPIE: A Web-scale Parallel Inference Engine using MapReduce", "author": ["Jacopo Urbani", "Spyros Kotoulas", "Jason Maassen", "Frank Van Harmelen", "Henri Bal"], "venue": "J. Web Sem.,", "citeRegEx": "Urbani et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Urbani et al\\.", "year": 2012}, {"title": "Individual comparisons by ranking methods", "author": ["Frank Wilcoxon"], "venue": "Biometrics Bulletin,", "citeRegEx": "Wilcoxon.,? \\Q1945\\E", "shortCiteRegEx": "Wilcoxon.", "year": 1945}], "referenceMentions": [], "year": 2014, "abstractText": "Abstract argumentation framework (AF ) is a unifying framework able to encompass a variety of nonmonotonic reasoning approaches, logic programming and computational argumentation. Yet, efficient approaches for most of the decision and enumeration problems associated to AF s are missing, thus potentially limiting the efficacy of argumentation-based approaches in real domains. In this paper, we present an algorithm for enumerating the preferred extensions of abstract argumentation frameworks which exploits parallel computation. To this purpose, the SCC-recursive semantics definition schema is adopted, where extensions are defined at the level of specific subframeworks. The algorithm shows significant performance improvements in large frameworks, in terms of number of solutions found and speedup.argumentation framework (AF ) is a unifying framework able to encompass a variety of nonmonotonic reasoning approaches, logic programming and computational argumentation. Yet, efficient approaches for most of the decision and enumeration problems associated to AF s are missing, thus potentially limiting the efficacy of argumentation-based approaches in real domains. In this paper, we present an algorithm for enumerating the preferred extensions of abstract argumentation frameworks which exploits parallel computation. To this purpose, the SCC-recursive semantics definition schema is adopted, where extensions are defined at the level of specific subframeworks. The algorithm shows significant performance improvements in large frameworks, in terms of number of solutions found and speedup. \u2217f.cerutti@abdn.ac.uk \u2020ilias.tachmazidis@hud.ac.uk \u2021m.vallati@hud.ac.uk \u00a7S.Batsakis@hud.ac.uk \u00b6massimiliano.giacomin@unibs.it \u2016g.antoniou@hud.ac.uk", "creator": "LaTeX with hyperref package"}}}