{"id": "1411.7812", "review": {"conference": "AAAI", "VERSION": "v1", "DATE_OF_SUBMISSION": "28-Nov-2014", "title": "Elections with Few Voters: Candidate Control Can Be Easy", "abstract": "we study the adaptive computational complexity of candidate turnout control in elections with few voters ( that is,... we take the number of voters as a primitive parameter ). we consider both the standard problem scenario of adding and deleting candidates, where one asks if a given candidate can become a winner ( or, in the destructive case, can be precluded from winning ) by adding / deleting some candidates, and a combinatorial scenario analogous where adding / deleting a candidate automatically means adding / deleting a virtually whole group of candidates. our results show that achieving the parameterized complexity of candidate control ( with the number of voters as the basic parameter ) is much longer more varied than control in the current setting with over many voters.", "histories": [["v1", "Fri, 28 Nov 2014 11:09:04 GMT  (81kb)", "http://arxiv.org/abs/1411.7812v1", "52 pages. to appear in th\u007fe Twenty-Ninth AAAI Conference on Artificial Intelligence (AAAI-15)"], ["v2", "Sat, 18 Mar 2017 11:32:11 GMT  (66kb)", "http://arxiv.org/abs/1411.7812v2", "56 pages, short version presented at AAAI-2015"]], "COMMENTS": "52 pages. to appear in th\u007fe Twenty-Ninth AAAI Conference on Artificial Intelligence (AAAI-15)", "reviews": [], "SUBJECTS": "cs.AI cs.GT cs.MA", "authors": ["jiehua chen", "piotr faliszewski", "rolf niedermeier", "nimrod talmon"], "accepted": true, "id": "1411.7812"}, "pdf": {"name": "1411.7812.pdf", "metadata": {"source": "CRF", "title": "Elections with Few Voters: Candidate Control Can Be Easy", "authors": ["Jiehua Chen", "Piotr Faliszewski", "Rolf Niedermeier"], "emails": ["jiehua.chen@tu-berlin.de", "faliszew@agh.edu.pl", "rolf.niedermeier@tu-berlin.de", "nimrodtalmon77@gmail.com"], "sections": [{"heading": null, "text": "ar X\niv :1\n41 1.\n78 12\nv1 [\ncs .A"}, {"heading": "1 Introduction", "text": "Election control problems model the issue of affecting the result of an election by either introducing some new candidates/voters or by removing some of them from the election. We study the complexity of election control by adding and deleting candidates, for the case where the election involves a few voters only. We focus on very simple, practical voting rules such as Plurality, Veto, and t-Approval, but we also discuss some more involved ones. To analyze the effect of a small number of voters, we use the formal tools of parameterized complexity theory.\nFrom the point of view of classical complexity theory, candidate control is NP-hard for almost all typically studied voting rules (even for the Plurality rule; though some natural examples of polynomial-time candidate control problems exist as well). It turns out that for the case of elections with few voters (i.e., for control problems parameterized by the number of\n\u2217PF was supported by the DFG project PAWS (NI 369/10) and by AGH University grant 11.11.230.124 (statutory research). NT was supported by the DFG Research Training Group \u201cMethods for Discrete Structures\u201d (GRK 1408). This work has been partly supported by COST Action IC1205 on Computational Social Choice. To appear in the Twenty-Ninth AAAI Conference on Artificial Intelligence (AAAI-15).\n\u2020jiehua.chen@tu-berlin.de \u2021faliszew@agh.edu.pl \u00a7rolf.niedermeier@tu-berlin.de \u00b6nimrodtalmon77@gmail.com\nvoters), the landscape of the complexity of candidate control is quite varied and, indeed, sometimes quite surprising (see Table 1 for an overview of our results). In addition to the standard candidate control problems, we also study their combinatorial variants, where it is possible to add or delete whole groups of candidates at unit cost. In this we follow the path initiated by Chen et al. [9], who introduced combinatorial voter control.\nMotivation. There is a number of settings in which it is most natural to consider elections with few voters (and, typically, many candidates). Let us look at several examples.\nHiring committee. Consider a university department which is going to hire a new faculty member. Typically the committee consists of relatively few faculty members, but it may consider hundreds of applications for a position.\nHoliday planning. Consider a group of people who are planning to spend holidays together. The group typically would consist of no more than a dozen persons, but\u2014technically\u2014 they have to choose from all the possible options provided by the travel offices, hotels,\nairlines, etc. This example is particularly relevant to the case of multi-agent systems: One may foresee that in the future we will delegate the task of finding the most satisfying holiday location to our personal software agents that will negotiate with travel offices and other travelers on our behalf.\nMeta-search engine. Dwork et al. [12] argued that one can build a web meta-search engine that queries several other search engines (the few voters) regarding a given query, aggregates their rankings of the web pages (the many candidates), and outputs the consensus ranking.\nIn all these examples, it is clear that before we actually hold an election, the voters (or, some particular individual) first shrink the set of candidates. In the case of the hiring committee, most of the applications are removed from the considerations early in the evaluation process. The people planning holidays first, implicitly, remove most of possible holiday options and, then, remove those candidates that do not fit their preferences completely (e.g., too expensive offers). The search engines usually disregard those web pages that appear completely irrelevant to a given query.\nThis natural process of modifying the candidate set, however, creates a natural opportunity for manipulating the result. A particularly crafty agent may remove those candidates that prevent his or her favorite one from winning. Similarly, after the initial process of thinning down the candidate set, a voter may request that some candidates are added back into consideration, possibly to help his or her favorite candidate. More importantly, it is quite realistic to assume that the voters in a small group know each other so well as to reliably predict each others\u2019 votes (this is particularly applicable to the example of the hiring committee). Thus, we believe that it is natural and relevant to study the complexity of candidate control parameterized by the number of voters. While control problems do not model the full game-theoretic process of adding/deleting candidates, they allow agents to compute what effects they might be able to achieve.\nFinally, it is quite natural to consider the case where deleting (adding) a particular candidate means also deleting (adding) a number of other ones. For example, if a hiring committee removes some candidate from consideration, it might have to also remove all those with weaker publication records; if people planning holidays disregard some expensive hotel, they might also want to remove those that cost more. Thus, we also study combinatorial variants of candidate control problems that model such settings.\nMain contributions. Our research has shown some surprising patterns that were not (nearly as) visible in the context of classical complexity analysis of election control:\n1. (Non-combinatorial) destructive candidate control is easy for all our voting rules, either in the fixed-parameter tractability sense or via outright polynomial-time algorithms.\n2. In the combinatorial setting, control by deleting candidates appears to be computationally harder than control by adding candidates.\nWe also found an interesting difference in the complexity of non-combinatorial constructive control by deleting candidates between Plurality and Veto rules (this is especially interesting since there is no such difference for the adding candidates case).\nOur results (see Table 1; formal definitions follow in the next section) are of four types (with the exception of t-Veto-Comb-DCAC which is only in XP): for each of our problems we show that it either is in P, is in FPT, is W[1]-hard but has an XP-algorithm, or is paraNP-hard (in each case the parameter is the number of voters). Naturally, the first type of\nresults is the most positive1 (unconditionally efficient algorithms) and the second type is quite positive too (the exponential part of the running time of an algorithm depends only on the number of voters). The third kind is less positive (W[1]-hardness precludes existence of FPT algorithms, but membership in XP means that there are algorithms that are polynomial-time if the number of voters is a constant). The last kind is the most negative (NP-hardness even for a constant number of voters; this precludes membership in XP).2 We introduce several new proof techniques to establish our results. For clarity of reading, we only sketch some of our proofs in the main text. Complete formal proofs are given in the Appendix.\nRelated Work. The complexity study of election control was introduced by Bartholdi et al. [1], who were later followed by numerous researchers, including, e.g., Hemaspaandra et al. [18], Meir et al. [26], and many others (we point the reader to the survey by Faliszewski et al. [15] and to several recent papers on the topic Parkes and Xia [29], Erde\u0301lyi et al. [13], Rothe and Schend [30]). Briefly put, it turns out that for standard voting rules, control problems are typically NP-hard.\nThere is a growing body of research regarding the parameterized complexity of voting problems (see, e.g., the survey by Betzler et al. [4]), where typical parameters include the solution size (e.g., the number of candidates that can be added) and the election size (i.e., the number of candidates or the number of voters). For the solution size as the parameter, control problems usually turn out to be hard Betzler and Uhlmann [2], Liu et al. [23], Liu and Zhu [22]. On the contrary, taking the number of candidates as the parameter almost always leads to FPT (fixed-parameter tractability) results (see, e.g., the papers by Faliszewski et al. [16] and by Hemaspaandra et al. [19]). However, so far, only Betzler and Uhlmann [2] considered a control problem parameterized by the number of voters (for the Copeland rule), and Brandt et al. [7] showed NP-hardness results of several winner determination problems even for constant number of voters. The parameter \u201cnumber of voters\u201d also received some limited attention in other voting settings ( Betzler et al. [3]; Dorn and Schlotter [10] Dorn and Schlotter [10]; Bredereck et al. [8] Bredereck et al. [8]).\nThe study of combinatorial control was recently initiated by Chen et al. [9], who focused on voter control. We stress that our combinatorial view of control is different from the studies of combinatorial voting domains Boutilier et al. [6], Xia and Conitzer [32], Mattei et al. [25]."}, {"heading": "2 Preliminaries", "text": "Elections. An election E = (C, V ) consists of a set of candidates C = {c1, . . . , cm} and a collection V = (v1, . . . , vn) of voters. Each voter v\u2113 has a preference order (vote), often denoted \u227b\u2113, which ranks the candidates from the one that v\u2113 likes most to the one that v\u2113 likes least. For example, if C = {c1, c2, c3} then a voter with preference order c1 \u227b c2 \u227b c3 would most like c1 to be a winner, then c2, and then c3. For a voter v\u2113 and two candidates ci, cj , we sometimes write v\u2113 : ci \u227b cj to indicate that v\u2113 prefers ci to cj . If A is some subset of candidates, then writing A within a preference order description (e.g.,A \u227b a \u227b b, where a and b are some candidates) means listing members of A in some arbitrary, but fixed, order. Writing \u2190\u2212 A means listing the candidates in the reverse of this order. Given an election E = (C, V ), for each two candidates ci, cj \u2208 C, we define NE(ci, cj) := \u2016{v\u2113 | v\u2113 : ci \u227b cj}\u2016.\n1We note that we evaluate the results from the computational complexity perspective and, hence, regard computational efficiency as positive.\n2Naturally, we use the standard complexity-theoretic assumptions that P 6= NP and FPT 6= W[1].\nA voting ruleR is a function that given an electionE = (C, V ) outputs a set R(E) \u2286 C of candidates that tie as winners (i.e., we use the non-unique-winner model, where the candidates in R(E) are equally successful). We study the following standard voting rules (in each case, the candidates who receive the highest number of points are the winners):\nt-Approval and t-Veto. Under t-Approval (where t \u2265 1 is an integer), each candidate gets a point for each voter that ranks him or her among the top t positions. For m candidates, t-Veto is a nickname for (m \u2212 t)-Approval (we often view the score of a candidate under t-Veto as the number of vetoes, i.e., the number of times he or she is ranked among bottom t positions). We refer to 1-Approval and 1-Veto as the Plurality rule and the Veto rule, respectively, and we jointly refer to the voting rules in this group as approval-based rules.\nBorda rule and Maximin rule. Under the Borda rule, in election E = (C, V ) each candidate c \u2208 C receives \u2211\nd\u2208C\\{c}NE(c, d) points. (It is also convenient to think that Borda, for each voter v, gives each candidate c as many points as the number of candidates that v ranks c ahead of.) Under Maximin, each candidate c \u2208 C receives mind\u2208C\\{c}NE(c, d) points.\nCopeland\u03b1 rule. Under the Copeland\u03b1 rule (where \u03b1 is rational, 0 \u2264 \u03b1 \u2264 1), in election E = (C, V ) each candidate c receives \u2016{d \u2208 C \\ {c} | NE(c, d) > NE(d, c)}\u2016 + \u03b1\u2016{d \u2208 C \\ {c} | NE(c, d) = NE(d, c)}\u2016 points.\nControl Problems. We study candidate control in elections, considering both constructive control (CC) and destructive control (DC), by either adding candidates (AC) or deleting candidates (DC). Following the work by Chen et al. [9], we also consider combinatorial variants of our problems, where adding/deleting a single candidate automatically adds/deletes a whole group of other candidates. In these combinatorial variants (denoted with a prefix Comb), we use bundling functions \u03ba such that for each candidate c, \u03ba(c) is a set of candidates that are also added if c is added (or, that are also deleted if c is deleted). For each candidate c, we require that c \u2208 \u03ba(c) and call \u03ba(c) the bundle of c.3 If B is some subset of candidates, by \u03ba(B) we mean \u22c3\nc\u2208B \u03ba(c). Bundling functions are encoded by explicitly listing their values for all the arguments. Formally, given a voting rule R, our problems are defined as follows.\nR-COMB-CCAC Input: An election (C, V ), a set A of unregistered candidates such that the voters from V have preference orders over C \u222a A, a preferred candidate p \u2208 C, a bundling function \u03ba, and a non-negative integer k. Question: Is there a set A\u2032 \u2286 A with \u2016A\u2032\u2016 \u2264 k such that p \u2208 R(C \u222a\u03ba(A\u2032), V )?\nR-COMB-CCDC Input: An election (C, V ), a preferred candidate p \u2208 C, a bundling function \u03ba, and a non-negative integer k. Question: Is there a set C\u2032 \u2286 C with \u2016C\u2032\u2016 \u2264 k such that p \u2208 R(C \\ C\u2032, V )?\nThe destructive variants of our problems, R-COMB-DCAC and R-COMB-DCDC, are defined analogously except that we replace the preferred candidate p with the despised candidate d, and we ask if it is possible to ensure that d is not a winner of the election. In the DCDC case,\n3Whenever we delete candidates from an election, these candidates are also implicitly deleted from the voters\u2019 preference orders.\nwe explicitly disallow deleting any bundle containing the despised candidate. In the standard, non-combinatorial, variants of control we omit the prefix \u201cComb\u201d and assume that for each candidate c we have \u03ba(c) = {c}, omitting the bundling function in discussions.\nOur model of combinatorial candidate control is about the simplest that one can think of. Indeed, in a scenario with m candidates, there are at most m corresponding bundles of candidates that can be added/deleted. In real life, one might expect many more. However, on the one hand, even such a simple model turns out to be computationally difficult and, on the other hand, we believe that it is instructive to consider such a simplified model first. In many cases (e.g., combinatorial constructive control by deleting candidates) we already obtain very strong hardness results.\nParameterized Complexity. Many of our results regard hardness with respect to the hierarchy of parameterized intractability:\nFPT \u2286 W[1] \u2286 W[2] \u2286 \u00b7 \u00b7 \u00b7 \u2286 XP.\nThe classes W[1] and W[2] can be defined, for example, through their complete problems, MULTI-COLORED CLIQUE and SET COVER: W[1] and W[2] contain those problems that reduce to, respectively, MULTI-COLORED CLIQUE and SET COVER in the parameterized sense. A parameterized reduction from a parameterized problem L to a parameterized problem L\u2032 is a function that, given an instance (I, p), computes in f(p) \u00b7 |I|O(1) time an instance (I \u2032, p\u2032), such that p\u2032 \u2264 g(p) and (I, p) \u2208 L \u21d4 (I \u2032, p\u2032) \u2208 L\u2032; indeed, in this paper all reductions can actually be performed in polynomial time.\nDefinition 1. An instance of MULTI-COLORED CLIQUE consists of a graphG = (V (G), E(G)) and a non-negative integer h. The vertex set V (G) is partitioned into h sets, V1(G), . . . , Vh(G), each one-to-one corresponding to one out of h colors. We ask if there are h vertices v1, . . . , vh such that for each i, 1 \u2264 i \u2264 h, vi \u2208 Vi(G), and each pair is connected by an edge. We call the set of these h vertices a multi-colored clique of size h.\nDefinition 2. An instance of SET COVER consists of a ground set X = {x1, . . . , xn\u2032}, a family S = {S1, . . . , Sm\u2032} of subsets of X , and a non-negative integer h (taken to be the parameter). We ask if it is possible to pick at most h sets from S so that their union is X . We call the collection these h sets a set cover of size h.\nWe say that a problem is para-NP-hard if there is a proof of its NP-hardness that produces an instance in which the value of the parameter is bounded by a constant. If a problem is paraNP-hard for some parameter, then it even cannot belong to XP for this parameter (unless P = NP). The textbooks on parameterized complexity theory offer more information [11, 17, 28]."}, {"heading": "3 Overview of Proof Techniques", "text": "We introduce several proof techniques that can be useful in studying the complexity of election problems parameterized by the number voters. We use the following techniques (the first two are, perhaps, most interesting):\nMulti-Colored Clique Technique. This is a technique used for establishing W[1]-hardness results. The idea is to give a reduction from MULTI-COLORED CLIQUE (MCC) parameterized by the clique order (a variant of the standard CLIQUE problem, better suited for the parameterized complexity results, where each vertex has one of h colors and we\nseek a clique of order h with each vertex of a different color): Given an MCC-instance, we introduce a candidate for each vertex and two candidates for each edge, and\u2014in essence\u2014we have to ensure that we add only the candidates (delete all but the candidates) that correspond to a multi-colored clique. We enforce this constraint using pairs of carefully crafted votes such that if we have two vertices but not an edge between them, then some candidate receives one more point than it should have for our preferred candidate to win. Note that the colors help to bound the number of voters needed for the construction. See Theorem 1 for a sample proof.\nCubic Vertex Cover Technique. This is a technique used for establishing para-NP-hardness results for non-combinatorial constructive candidate controls. The crucial idea of the technique is that the edges in a cubic graph can be partitioned into four disjoint matchings, which allows one to encode all the information regarding the graph in a constant number of votes, in a way that ensures that the actions of adding/deleting candidates correspond to covering edges. A sample proof is given in Theorem 5.\nSet-Embedding Technique. This is a very simple technique for showing para-NP-hardness results for combinatorial control by adding/deleting candidates. The idea is to reduce from the standard SET COVER problem using the bundling function to encode sets. Due to the power of bundling, a constant number of voters suffices for the reduction. A sample proof is given for Theorem 2.\nSignature Technique. This is a group of two very similar techniques for showing FPT results (usually for destructive control). The first technique in the group works for control by adding candidates problems and relies on the fact that often it is possible to limit the number of candidates that one has to consider by identifying their most crucial properties (such as the subsets of voters where the candidates are ranked ahead of some given candidate; we refer to these properties as signatures). The second technique applies to control by deleting candidates. A sample proof using the first technique is given in Theorem 1."}, {"heading": "4 Approval-Based Rules", "text": "In this section, we consider t-Approval and t-Veto rules. These are perhaps the simplest and most frequently used rules, so results regarding them are of particular interest.\nWe start by looking at the Plurality rule and the Veto rule. In terms of standard complexity theory, control by adding/deleting candidates (constructive and destructive) is NP-complete for both of them ( Bartholdi et al. [1]; Hemaspaandra et al. [18]). However, if we parameterize by the number of voters, the results change quite drastically. On the one hand, the results for analogous types of (non-combinatorial) control for these rules differ (for example, Plurality-CCDC is in FPT but Veto-CCDC is W[1]-hard; this is quite unexpected given the similarity and simplicity of Plurality and Veto), and, on the other hand, combinatorial and non-combinatorial control problems behave differently. For example, in combinatorial control, the deleting candidates case is para-NP-hard for all the rules, but the adding candidates case is either in FPT or W[1]-hard (but in XP).\nTheorem 1. When parameterized by the number of voters, (1) for Plurality and Veto, DCAC and DCDC are both in FPT, (2) Plurality-CCAC and Veto-CCAC are both W[1]-hard, and (3) Plurality-CCDC is in FPT, while Veto-CCDC is W[1]-hard.\nProof sketch for Plurality-DCAC. First, we guess a candidate p which is to defeat the despised candidate d (such a candidate must exist in a \u201cyes\u201d-instance; if p is an unregistered candidate, then we add it and decrease k by one).\nLet m := \u2016A\u2016+\u2016C\u2016 be the total number of candidates and n be the number of voters. For each unregistered candidate a, we define its signature to be the collection of votes restricted to candidates p, d, and a, with each occurrence of a replaced by a global symbol x. Adding a single candidate with a given signature has the same effect on the score difference of d and p as adding several candidates with the same signature. Thus, we partition the set of unregistered candidates into equivalence classes based on their signatures, and, for each signature, remove all unregistered candidates but one. We also remove all the registered candidates that do not score any points in the original election. Altogether, we are left with at most n registered candidates and at most 3n unregistered ones (the maximum number of different signatures). We solve this instance by brute-forcing all at-most-k-sized subsets of the unregistered candidates. This gives running time of the form O(3n 2\n\u00b7 poly(m,n)) since k \u2264 n. Finally, we remark that by using exponential space we can design a more complicated O(2n \u00b7m \u00b7 n)-time algorithm for Plurality-DCAC.\nProof sketch for Plurality-CCAC. We give a reduction from the W[1]-hard problem MULTICOLORED CLIQUE parameterized by the clique order. In this problem, we are given an undirected graph G = (V (G), E(G)) whose vertices are partitioned into exactly h disjoint sets, V1(G), . . . , Vh(G) such that for each i, Vi(G) consists of exactly n\u2032 vertices with color i. We ask if there is an order-h clique containing a vertex for each color. We rename the vertices so that for each i, 1 \u2264 i \u2264 h, we have Vi(G) = {v (i) 1 , . . . , v (i) n\u2032 }. W.l.o.g., we assume that G has edges between vertices of different colors only. We construct a Plurality-CCAC instance as follows: The registered candidates are p (the preferred one) and d. We have one unregistered candidate v for each vertex v, and two unregistered candidates, (u, v), (v, u), for each edge {u, v}.\nTo describe the votes, we need the following notation. Let i and j be two distinct colors. Let E(i, j) denote the set of all edge candidates (u, v), where u \u2208 Vi(G) and v \u2208 Vj(G). For each vertex v(i)z \u2208 Vi(G), let L(v (i) z , j) denote the set of all edge candidates (v (i) z , v), where v \u2208 Vj(G). Finally, let R(i, j) and R\u2032(i, j) denote the following two orders (which, indeed, are the crucial part of our construction):\nR(i, j) : v (i) 1 \u227b L(v (i) 1 , j) \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 \u227b L(v (i) n\u2032 , j),\nR\u2032(i, j) : L(v (i) 1 , j) \u227b v (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b L(v (i) n\u2032 , j) \u227b v (i) n\u2032 .\nWe construct a set V of 3h+ 2(h+ 1) \u00b7 ( h 2 ) voters as follows.\n1. For each color i, (1 \u2264 i \u2264 h), construct one voter with orders v(i)1 \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 \u227b d \u227b\n\u00b7 \u00b7 \u00b7 .\n2. For each pair of colors i, j, (1 \u2264 i 6= j \u2264 h), construct h\u22121 voters with ordersE(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 , and another two voters, one with orders R(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 and one with orders R\u2032(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 .\n3. Construct h voters with orders d \u227b \u00b7 \u00b7 \u00b7 and h voters with orders p \u227b \u00b7 \u00b7 \u00b7 .\nWe claim that p can become a winner by adding at most k := h+ 2 ( h 2 )\ncandidates if and only if G has an order-h multi-colored clique (i.e., a clique containing a vertex for each color).\nSimple calculation shows that if Q is a multi-colored clique of order h, then adding the vertex candidates and the edge candidates corresponding to Q makes p win.\nConversely, we observe that irrespective of how many candidates we add to the election, p cannot have more than h points. Thus, d and every added unregistered candidate cannot have more than h points in the final election. This implies that any size-at-most-(h + 2 (\nh 2\n)\n) set A\u2032 of unregistered candidates that we add to the election must contain exactly one vertex candidate for each color and exactly one edge candidate for each (ordered) pair of colors. Further, if A\u2032 contains two vertex candidates u, v but not the edge candidate (u, v), then, due to the orders R(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 and R\u2032(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 , either u or an edge candidate (u\u2032, v\u2032) (where u\u2032 \u2208 Vi(G), v\u2032 \u2208 Vj(G), but (u\u2032, v\u2032) 6= (u, v)) receives too many points, causing p not to win. To see why, note that R(i, j) and R\u2032(i, j) contain all the candidates from Vi(G) and E(i, j). If we restrict those two preference orders to u and (u, v), then they will become u \u227b (u, v) and the reverse one (u, v) \u227b u. However, if we restrict them to u and (u\u2032, v\u2032), then either they will both be u \u227b (u\u2032, v\u2032) or they will both be (u\u2032, v\u2032) \u227b u. This completes the proof.\nThe Veto-CCAC case is quite intriguing. To see why, let us consider the following voting rule: Under TrueVeto, a candidate c is a winner if none of the voters ranks c last. It is quite easy to show that TrueVeto-CCAC is NP-complete, but it is also in FPT (when parameterized by the number of voters; an algorithm similar to that for Plurality-DCAC works). If a Veto election contained more candidates than voters, then at least one candidate would never be vetoed and, in effect, the election would be held according to the TrueVeto rule. This means that in the proof that Veto-CCAC is W[1]-hard, the election has fewer candidates than voters, even after adding the candidates (and keep in mind that the number of voters is the parameter!). Thus, the hardness of the problem lays in picking few spoiler candidates to add from a large group of them. If we were adding more candidates than voters, the problem would be in FPT.\nIn the combinatorial setting, there is a sharp difference between control by adding and by deleting candidates.\nTheorem 2. When parameterized by the number of voters, for Plurality and Veto, (1) COMBDCAC is in FPT, (2) COMB-CCAC is W[1]-hard, and (3) COMB-CCDC and COMB-DCDC are para-NP-hard.\nProof sketch for Plurality-COMB-DCDC. We reduce from SET COVER which, given a ground set X = {x1, . . . , xn\u2032}, a family S = {S1, . . . , Sm\u2032} of subsets of X , and a non-negative integer h (taken to be the parameter), asks whether it is possible to pick at most h sets from S so that their union is X . Given an instance I of SET COVER, we create an instance of PluralityCOMB-DCDC as follows. We let the candidate set be C = {p, d}\u222aX\u222aS (note that, depending on the context, we will use the symbol Sj , 1 \u2264 j \u2264 m\u2032, to denote both the set from S and a set-candidate in the election). We introduce three voters with the following preference orders:\nv1 : X \u227b p \u227b \u00b7 \u00b7 \u00b7 ,\nv2 : d \u227b \u00b7 \u00b7 \u00b7 ,\nv3 : p \u227b d \u227b \u00b7 \u00b7 \u00b7 .\nWe set the bundling function \u03ba so that for each set-candidate Sj , we have \u03ba(Sj) := {Sj} \u222a {xi | xi \u2208 Sj}, and for every non-set candidate c, we have \u03ba(c) := {c}.\nWe claim that the candidate d can be precluded from winning by deleting at most h bundles of candidates if and only if there are h sets from S whose union is X .\nPrior to deleting candidates, d, p, and one of the candidates from X are tied as winners. Deleting p would make d a unique winner, so the only way to defeat d is to ensure that v1 gives its point to p. It is easy to see that we can assume that we only delete bundles of the set-candidates. To ensure that v1 gives a point to p, all candidates from X must be deleted and, given our bundling function, this is possible (by deleting h bundles) if and only if the union of the sets corresponding to the deleted bundles is X .\nFor t-Approval and t-Veto with t \u2265 2, there are fewer surprises and patterns are more clearly visible: In the non-combinatorial setting, constructive controls are W[1]-hard and the destructive ones are in FPT. In the combinatorial setting, we have mostly hardness results.\nTheorem 3. When parameterized by the number of voters, for each fixed integer t \u2265 2, for t-Approval and t-Veto, (1) (COMB)-CCAC, and CCDC are W[1]-hard, (2) DCAC and DCDC are in FPT, (3) COMB-CCDC and COMB-DCDC are para-NP-hard, and (4) t-ApprovalCOMB-DCAC is W[1]-hard.\nWe conclude our discussion by claiming that in each of the W[1]-hard cases discussed in this section we can, indeed, provide an XP algorithm. This means that these cases cannot be strengthened to para-NP-hardness results.\nTheorem 4. For each control type K \u2208 {CCAC, CCDC, COMB-CCAC, COMB-DCAC}, and for each fixed integer t, t \u2265 1, each of t-Approval-K and t-Veto-K is in XP, when parameterized by the number of voters."}, {"heading": "5 Other Voting Rules", "text": "We focus on the voting rules Borda, Copeland\u03b1, and Maximin. The results are quite different from those for the case of t-Approval and t-Veto. Instead of FPT and W[1]-hardness results, we obtain polynomial-time algorithms and para-NP-hardness results. Specifically, it has already been reported in the literature that there are polynomial-time algorithms for destructive candidate control in Borda Loreggia et al. [24], Copeland\u03b1 Faliszewski et al. [14], and Maximin ( Faliszewski et al. [16]). For constructive candidate control, para-NP-hardness was already known for Copeland0 and Copeland1 Betzler and Uhlmann [2] and we establish it for the remaining values of \u03b1 and for Borda and Maximin (in the latter case, only for CCAC; CCDC is known to be in P).\nTheorem 5. When parameterized by the number of voters, for Borda and Copeland\u03b1 (0 \u2264 \u03b1 \u2264 1), CCAC and CCDC are para-NP-hard, and Maximin-CCAC is para-NP-hard.\nProof sketch for Borda-CCDC. We reduce from the NP-complete problem CUBIC VERTEX COVER that given an undirected graph G, where each vertex has degree exactly three, and a non-negative integer h, asks whether there is a subset (vertex cover) of at most h vertices such that each edge is incident to at least one vertex in the subset.\nLet I = (G, h) be a CUBIC VERTEX COVER instance. We decompose E(G) into four disjoint matchings (this is possible due to the computational variant of the classic graph-coloring result by Misra and Gries [27]) and rename the edges so that for each \u2113, 1 \u2264 \u2113 \u2264 4, the \u2113\u2019th of these matchings is E(\u2113) = {e(\u2113)1 , . . . , e (\u2113) m\u2113}. We set m\n\u2032 = m1 +m2 +m3 +m4 = \u2016E(G)\u2016 and n\u2032 = \u2016V (G)\u2016. For each edge e, we arbitrarily order its vertices and we write v\u2032(e) and v\u2032\u2032(e) to refer to the first vertex and to the second vertex, respectively. For each \u2113, 1 \u2264 \u2113 \u2264 4, we write EV (\u2212\u2113) to mean the set of edges not in E(\u2113) union the set of vertices not incident to\nany of the edges in E(\u2113). For each edge e, we define the following two orders over e, v\u2032(e), and v\u2032\u2032(e):\nP (e) : e \u227b v\u2032(e) \u227b v\u2032\u2032(e) and P \u2032(e) : e \u227b v\u2032\u2032(e) \u227b v\u2032(e).\nWe form an election E = (C, V ), where C = {p, d} \u222a V (G) \u222a E(G) and the voter set includes the following voters:\n1. For each \u2113, 1 \u2264 \u2113 \u2264 4, we have the following two voters (E(\u2113) is a matching so the orders are well-defined):\n\u00b5(\u2113) : P (e (\u2113) 1 ) \u227b \u00b7 \u00b7 \u00b7 \u227b P (e (\u2113) m\u2113 ) \u227b EV (\u2212\u2113) \u227b d \u227b p, and\n\u00b5\u2032(\u2113) : p \u227b d \u227b \u2190\u2212\u2212\u2212\u2212\u2212 EV (\u2212\u2113) \u227b P \u2032(e(\u2113)m\u2113) \u227b \u00b7 \u00b7 \u00b7 \u227b P \u2032(e (\u2113) 1 ).\n2. We have two voters, one with order p \u227b d \u227b V (G) \u227b E(G) and one with order \u2190\u2212\u2212\u2212 E(G) \u227b \u2190\u2212\u2212\u2212 V (G) \u227b p \u227b d.\nWe claim that deleting at most h candidates can make p a winner if and only if there is a vertex cover of size h for G.\nInitially, we have the following scores (to calculate them, note that\u2014except for small asymmetries\u2014our pairs of votes are reverses of each other): p has 5(n\u2032 + m\u2032) + 6 points, d has 5(n\u2032 +m\u2032) + 4 points, each edge candidate has 5(n\u2032 +m\u2032) + 7 points, and each vertex candidate has 5(n\u2032 +m\u2032) + 2 points. So, p has one point fewer than each edge candidate, but more points than the other ones.\nConsider the effects of deleting candidates. Deleting d decreases the score of p by six, whereas it decreases the scores of each other candidate by five (so it is never beneficial to delete d). Further, if there is a solution that deletes some edge e, then a solution that is identical but instead of e deletes either v\u2032(e) or v\u2032\u2032(e) (it is irrelevant which one) is also correct. Now, let v be some vertex candidate. If we delete v, the score of each edge candidate e such that v = v\u2032(e) or v = v\u2032\u2032(e) decreases by six, and the score of each other remaining candidate decreases by five. Thus, there is a vertex cover of size h if and only if deleting vertices corresponding to the cover ensures p\u2019s victory.\nFor combinatorial variants of candidate control, we only have one polynomial-time algorithm (for Maximin-COMB-DCAC); all the remaining cases are para-NP-hard. Our proofs mostly rely on the set-embedding technique. In particular, we prove that for every voting rule R that satisfies the unanimity principle (that is, for each voting rule R that chooses as the unique winner the candidate that is ranked first by all the voters), R-COMB-CCDC is paraNP-hard.\nTheorem 6. Let R be a voting rule that satisfies the unanimity principle. R-COMB-CCDC is NP-hard even for the case of elections with just a single voter.\nAltogether, we have the following result.\nTheorem 7. When parameterized by the number of voters, for Borda, Copeland\u03b1 (0 \u2264 \u03b1 \u2264 1), and Maximin, COMB-K is para-NP-hard for each control type K \u2208 {CCAC, CCDC, DCDC}. For Borda and Copeland\u03b1 (0 \u2264 \u03b1 \u2264 1), COMB-DCAC is para-NP-hard. On the contrary, Maximin-COMB-DCAC is polynomial-time solvable.\nIn summary, for our more involved voting rules, constructive candidate control is hard even in the non-combinatorial setting, whereas destructive candidate control is tractable in the non-combinatorial setting, but becomes para-NP-hard in the combinatorial ones (with the exception of Maximin)."}, {"heading": "6 Outlook", "text": "Our work motivates several research directions. A particularly interesting one is to consider game-theoretic aspects of candidate control: Tractability results motivate studying more involved settings (e.g., consider a setting where two actors try to preclude two different candidates from winning; their goals might involve both cooperation and competition). Finally, taking a more general perspective, we believe that the case of few voters did not receive sufficient attention in the computational social choice literature and many other problems can (and should) be studied with respect to this parameter."}, {"heading": "A Overview", "text": "In the appendix we provide all the proofs missing from the main text. However, the appendix is organized differently than the body of the paper. Instead of ordering the results with respect to the voting rules and problems studied, rather we sort them with respect to the proof technique. We provide next a connection between the organization of the body of the text and of the appendix. That is, for each of the theorems from the body of the text, we provide, in this appendix, a proof that points the reader to appropriate lemmas, proved in the following sections. We believe that this way, on one hand, the body of the paper tells how our results relate to each other, and the appendix, on the other hand, is concise and coherent."}, {"heading": "A.1 Road Map", "text": "Below we provide a road map for the appendix. That is, for each of the theorems from the main body of the text, we list in which lemmas respective parts of the theorem are proved.\nTheorem 1. When parameterized by the number of voters, (1) for Plurality and Veto, DCAC and DCDC are both in FPT, (2) Plurality-CCAC and Veto-CCAC are both W[1]-hard, and (3) Plurality-CCDC is in FPT, while Veto-CCDC is W[1]-hard.\nProof. The proof of this theorem is divided into the following lemmas:\n(1) The FPT results for DCAC and DCDC under Plurality and Veto are given in Lemma 27, Corollary 6, Lemma 31, and Corollary 4.\n(2) The W[1]-hardness results for Plurality-CCAC and for Veto-CCAC are given in Lemmas 1 and 2.\n(3) The FPT result for Plurality-CCDC is given in Lemma 30 and the W[1]-hardness result for Veto-CCDC is given in Lemma 3.\nThe W[1]-hardness results use the multi-colored clique technique and the FPT results use the signatures technique and the brute-force technique.\nTheorem 2. When parameterized by the number of voters, for Plurality and Veto, (1) COMBDCAC is in FPT, (2) COMB-CCAC is W[1]-hard, and (3) COMB-CCDC and COMB-DCDC are para-NP-hard.\nProof. The proof of this theorem is divided into the following lemmas:\n(1) The FPT results for COMB-DCAC under Plurality and Veto are shown in Corollary 5.\n(2) The W[1]-hardness results for COMB-CCAC under Plurality and Veto follows from Lemmas 1 and 2.\n(3) The para-NP-hardness results for COMB-CCDC under Plurality and Veto follow from Corollary 3 and Lemma 15. The para-NP-hardness results for COMB-DCDC under Plurality and Veto are shown in Lemma 16 and Lemma 18.\nThe W[1]-hardness results use the multi-colored clique technique, the para-NP-hardness results use the set-embedding technique, and the FPT results use the signatures technique.\nTheorem 3. When parameterized by the number of voters, for each fixed integer t \u2265 2, for t-Approval and t-Veto, (1) (COMB)-CCAC, and CCDC are W[1]-hard, (2) DCAC and DCDC are in FPT, (3) COMB-CCDC and COMB-DCDC are para-NP-hard, and (4) t-ApprovalCOMB-DCAC is W[1]-hard.\nProof. The proof of this theorem is divided into the following lemmas:\n1. The W[1]-hardness results for t-Approval-(COMB)-CCAC (t \u2265 2) are shown in Corollary 1. The W[1]-hardness results for t-Approval-CCDC (t \u2265 2) are shown in Lemmas 5 and 6. The W[1]-hardness results for t-Veto-(COMB)-CCAC (t \u2265 2) are shown in Corollary 2. The W[1]-hardness results for t-Veto-CCDC (t \u2265 2) are shown in Lemma 4.\n2. The FPT results for DCAC for t-Approval and t-Veto (t \u2265 2) are shown in Lemma 28 and Corollary 4. The FPT results for DCDC for t-Approval and t-Veto (t \u2265 2) are shown in Lemma 29.\n3. The para-NP-hardness results for COMB-CCDC and COMB-DCDC are shown in Lemma 14, Lemma 17, Lemma 15, and Lemma 18.\n4. The W[1]-hardness result for t-Approval-COMB-DCAC is shown in Lemma 7.\nThe W[1]-hardness results use the multi-colored clique technique, the para-NP-hardness results use the set-embedding technique, and the FPT results use the signatures technique.\nTheorem 4. For each control type K \u2208 {CCAC, CCDC, COMB-CCAC, COMB-DCAC}, and for each fixed integer t, t \u2265 1, each of t-Approval-K and t-Veto-K is in XP, when parameterized by the number of voters.\nProof. For the non-combinatorial part, the theorem follows from Lemma 32. For the combinatorial part, it follows from Lemma 33.\nTheorem 5. When parameterized by the number of voters, for Borda and Copeland\u03b1 (0 \u2264 \u03b1 \u2264 1), CCAC and CCDC are para-NP-hard, and Maximin-CCAC is para-NP-hard.\nProof. The proof of this theorem is divided into the following lemmas:\n1. The para-NP-hardness result for Borda-CCAC is shown in Lemma 9.\n2. The para-NP-hardness result for Borda-CCDC is shown in Lemma 8.\n3. The para-NP-hardness result for Copeland\u03b1-CCAC is shown in Lemma 11.\n4. The para-NP-hardness result for Copeland\u03b1-CCDC is shown in Lemma 12.\n5. The para-NP-hardness result for Maximin-CCAC is shown in Lemma 10.\nThe results use the cubic vertex-cover technique.\nTheorem 6. Let R be a voting rule that satisfies the unanimity principle. R-COMB-CCDC is NP-hard even for the case of elections with just a single voter.\nProof. This result is shown in Lemma 13.\nTheorem 7. When parameterized by the number of voters, for Borda and Copeland\u03b1 (0 \u2264 \u03b1 \u2264 1), CCAC and CCDC are para-NP-hard, and Maximin-CCAC is para-NP-hard.\nProof. The proof of this theorem is divided into the following lemmas:\n1. The para-NP-hardness results for Borda are shown in Corollary 3, Lemma 19, and Lemma 20.\n2. The para-NP-hardness results for Copeland\u03b1 (for 0 \u2264 \u03b1 \u2264 1) are shown in Lemma 22 and Lemma 21.\n3. The para-NP-hardness results for Maximin are shown in Corollary 3, Lemma 24, and Lemma 23.\nThe results use the set-embedding technique. Finally, the polynomial-time algorithm for MaximinCOMB-DCAC is described in Theorem 8."}, {"heading": "B Multi-Colored Clique Technique", "text": "In this section, we give the proofs based on the MULTI-COLORED CLIQUE technique. Specifically, we prove the following statements (all results are for the parameterization by the number of voters):\n1. For each fixed integer t \u2265 1 and for each voting rule R \u2208 {t-Approval, t-Veto}, RCCAC (and therefore also R-COMB-CCAC) is W[1]-hard.\n2. For each fixed integer t \u2265 2 and for each voting rule R \u2208 {Veto, t-Approval, t-Veto}, R-CCDC is W[1]-hard.\n3. For each fixed integer t \u2265 2 and for each voting rule R \u2208 {t-Approval, t-Veto}, RCOMB-DCAC is W[1]-hard.\nAll the proofs follow by reductions from MULTI-COLORED CLIQUE (hence the name of the technique) and are quite similar in spirit. Thus we start by providing some common notation and observations for all of them.\nLet I = (G, h) be a MULTI-COLORED CLIQUE instance with graph G and non-negative integer h. The vertices of G are partitioned into h sets, V1(G), . . . , Vh(G), each containing the vertices with a given color. Without loss of generality, we assume that each Vi(G) contains the same number of vertices, denoted by n\u2032, and we rename the vertices so that for each color i, 1 \u2264 i \u2264 h, we have Vi(G) = {v (i) 1 , . . . , v (i) n\u2032 }. The task is to decide if there is a clique of order h where each vertex comes from a different set Vi(G). Without loss of generality, we assume that each edge in G connects vertices with different colors and that the input graph contains at least two vertices.\nIn our reductions, given an instance I = (G, h), we build elections with the following candidates related to the graph G (in addition to the candidates specific to a particular reduction). For each vertex v \u2208 V (G), we introduce a candidate denoted by the same symbol. For each edge e = {u, v}, we introduce two candidates (u, v) and (v, u) (while our original graph is undirected, for our construction we treat each undirected edge as two directed ones, one in each direction).\nIn the description of our preference orders, we will use the following orders over subsets of candidates. For each vertex v(i)t \u2208 Vi(G) of color i and each color j, j 6= i, we write L(v (i) t , j) to denote the order obtained from\n(v (i) t , v (j) 1 ) \u227b \u00b7 \u00b7 \u00b7 \u227b (v (i) t , v (j) n\u2032 )\nby removing those items (candidates) (v(i)t , v (j) h ) for which there is no edge {v (i) t , v (j) h } in the graph. Intuitively, L(v(i)t , j) lists all the edge candidates for edges that include v (i) t and go to vertices of color j (the particular order of these edges in L(v(i)t , j) is irrelevant for our constructions).\nSimilarly, for each two colors i, j, 1 \u2264 i, j \u2264 h, i 6= j, we write E(i, j) to mean the order\nL(v (i) 1 , j) \u227b L(v (i) 2 , j) \u227b \u00b7 \u00b7 \u00b7 \u227b L(v (i) n\u2032 , j).\nIntuitively, E(i, j) lists all the edge candidates between the vertices from Vi(G) and the vertices from Vj(G) (note, however, that E(i, j) and E(j, i) are different).\nThe following two preference orders are crucial for the MULTI-COLORED CLIQUE technique. For each two colors, i, j, 1 \u2264 i, j \u2264 h, i 6= j, we define R(i, j) and R\u2032(i, j) as follows:\nR(i, j) : v (i) 1 \u227b L(v (i) 1 , j) \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 \u227b L(v (i) n\u2032 , j)\nR\u2032(i, j) : L(v (i) 1 , j) \u227b v (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b L(v (i) n\u2032 , j) \u227b v (i) n\u2032\nThe idea behind R(i, j) and R\u2032(i, j) is as follows. Consider a setting where u is a vertex of color i and v is a vertex of color j (i.e., u \u2208 Vi(G) and v \u2208 Vj(G)). Note that R(i, j) and R\u2032(i, j) contain all the candidates from Vi(G) and E(i, j). If we restrict these two preference orders to candidates u and (u, v), then they will become u \u227b (u, v) and (u, v) \u227b u. That is, in this case they are reverses of each other. However, if we restrict them to u and some candidate (u\u2032, v\u2032) different than (u, v), then either they will be both u \u227b (u\u2032, v\u2032) or they will be both (u\u2032, v\u2032) \u227b u. Using this effect is at the heart of our constructions.\nWith the above setup, we are ready to prove the results of this section. We start with the adding candidates case and then, continue with the deleting candidates case.\nLemma 1. Plurality-CCAC is W[1]-hard, when parameterized by the number of voters.\nProof. This is the first proof in which we employ the MULTI-COLORED CLIQUE technique. Let I = (G, h) be our input instance of MULTI-COLORED CLIQUE with graph G and nonnegative integer h. Let the notation be the same as described just prior to the lemma. We form an instance I \u2032 of Plurality-CCAC as follows. We let the registered candidate set C consist of two candidates, p and d, and we let the set A of unregistered candidates contain all the vertex candidates and all the edge candidates for G. We let p to be the preferred candidate. And we construct the election such that the current winner will be d. We introduce the following voters.\n1. For each color i, 1 \u2264 i \u2264 h, we have one voter with preference order of the form\nv (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 \u227b d \u227b \u00b7 \u00b7 \u00b7 \u227b p.\n2. For each pair of colors i, j (1 \u2264 i, j \u2264 h, i 6= j), we have h\u2212 1 voters with preference order of the form\nE(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 \u227b p.\n3. For each pair of colors i, j (1 \u2264 i, j \u2264 h, i 6= j), we have two voters, one with preference order of the form\nR(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 \u227b p,\nand one with preference order of the form\nR\u2032(i, j) \u227b d \u227b \u00b7 \u00b7 \u00b7 \u227b p.\n4. We have h voters with preference order of the form\nd \u227b \u00b7 \u00b7 \u00b7 \u227b p,\nand h voters with preference order of the form\np \u227b \u00b7 \u00b7 \u00b7 \u227b d.\nWe set k := h+2 ( h 2 )\n. This complete the construction. Note that the total number of voters is 3h+ 2(h+ 1) \u00b7 (\nh 2\n) and the current winner is d having (2h+ 2(h+ 1) \u00b7 ( h 2 )\n) points. We claim that it is possible to ensure that p becomes a winner by adding at most k candidates if and only if I is a \u201cyes\u201d-instance. First, assume that I is a \u201cyes\u201d-instance of MULTI-COLORED CLIQUE and let Q be a sizeh subset of vertices that forms a multi-colored clique in I . It is easy to see that if we add to our election the h candidates from Q and all the edge-candidates that correspond to edges between the candidates from Q, then, in the resulting election, each candidate (including p and d) will have h points (for example, each of the added vertex candidates will receive one point from the first group of voters and h\u2212 1 points from the third group of voters). Thus everyone will win.\nNow, assume that it is possible to ensure p\u2019s victory by adding at most k candidates. Let A\u2032 be a subset of candidates such that |A\u2032| \u2264 h + 2 (\nh 2\n)\nand adding the candidates from A\u2032 to the election ensures that p is a winner. Irrespective of the contents of the set A\u2032, in the resulting election p will have h points. Thus, it follows that d must lose all points from the first three groups of voters implying that for each color i, 1 \u2264 i \u2264 h, A\u2032 contains exactly one candidate from Vi(G) and for each pair of colors i, j (1 \u2264 i, j \u2264 h, i 6= j), A\u2032 contains exactly one edge candidate (u, v) such that u \u2208 Vi(G) and v \u2208 Vj(G) (The fact that A\u2032 contains at least one candidate of each type follows because otherwise d would have more than h points; the fact that it contains exactly one of each type follows by a simple counting argument).\nNow it suffices to prove that for each two vertex candidates u, v \u2208 A\u2032, we also have (u, v) \u2208 A\u2032. To show this, first observe there is a total of h + 2(h + 1) \u00b7 (\nh 2\n)\n= h \u00b7 (h +\n2 ( h 2 )\n) = h \u00b7 k voters from the first three groups that will give points to the newly added candidates. Since each added candidate can have at most h points, it follows that \u2016A\u2032\u2016 = k and each added candidate receives exactly h points. By the observations regarding preference orders R(i, j) and R\u2032(i, j), (u, v) /\u2208 A\u2032, then, some vertex candidate or some edge candidate would be ranked first by at least two voters from the third group. If this were the case for an edge candidate, then\u2014including the votes from the second group\u2014this candidate would have more than h points and p would not be a winner. If this were the case for a vertex candidate (and neither of the edge candidates were ranked first by more than one of the voters in the third group), then this vertex candidate would receive at least h points from the voters in the third group and one point from the voters in the first group. Again, p would not be a winner. Thus, it must be that (u, v) \u2208 A\u2032. However, this proves that G has a multi-colored clique of order h.\nCorollary 1. For each fixed integer t, t \u2265 2, t-Approval-CCAC is W[1]-hard, when parameterized by the number of voters.\nProof. It suffices to use the same proof as in the case of Lemma 1, but where for each voter, we introduce additional t \u2212 1 registered dummy candidates which this voter ranks first (each voter ranks all the remaining dummy candidates last). In this way, each dummy candidate has exactly one point. The reasoning for the correctness proof works in the same way.\nLemma 2. Veto-CCAC is W[1]-hard, when parameterized by the number of voters.\nProof. It suffices to use the same construction (and proof) as for the Plurality-CCAC case (Lemma 1), but with the following changes (notice that the order is important, that is, we perform the second modification only after we perform the first modification):\n1. we swap the occurrences of p and d in every vote, and\n2. we reverse each vote.\nIn effect, prior to adding candidates, p is vetoed by all but h voters and d is vetoed by exactly h voters. It is easy to verify that if we add vertex candidates and edge candidates that correspond to a multi-colored clique, then every candidate in the election is vetoed by exactly h voters and all the candidates are winners.\nFor the reverse direction, analogously as in the Plurality case, we note that we have to add exactly one vertex candidate of each color and exactly one edge candidate for each (ordered) pair of colors (otherwise p would receive more than h vetoes). To argue that for each two vertex candidates u and v that we add, we also have to add edge candidate (u, v), we use the same reasoning as in the Plurality case, but pointing out that if some candidate receives two vetoes from the third group of voters, then some other one, altogether, receives fewer than h vetoes and p is not a winner.\nCorollary 2. For each fixed integer t, t \u2265 2, t-Veto-CCAC is W[1]-hard, when parameterized by the number of voters.\nProof. It suffices to use the same proof as in Lemma 2, but we introduce t \u2212 1 additional registered dummy candidates whose every voter ranks last. In this way, each dummy candidate receives exactly one veto from each voter, while p and d receive the same number of vetoes as in the election constructed in the proof for Lemma 2.\nIt is easy to verify that the arguments from that proof applies here as well.\nNow, we move on to the deleting candidates case. We assume, without loss of generality, that the input graph is connected and contains at least two vertices\nLemma 3. Veto-CCDC is W[1]-hard, when parameterized by the number of voters.\nProof. The proof follows by a reduction from the MULTI-COLORED CLIQUE problem. Let I = (G, h) be our input instance with graph G and non-negative integer h and let the notation be as described in the introduction to the MULTI-COLORED CLIQUE technique section. We form an instance I \u2032 of Veto-CCDC as follows. We let the registered candidate set C consists all the vertex candidates and all the edge candidates for G, and the preferred candidate p. We construct the following groups of voters (set H = 2 (\nh 2\n)\n= h \u00b7 (h\u2212 1)):\n1. For each color i, 1 \u2264 i \u2264 h, we introduce 2H \u2212 (h\u2212 1) voters with preference order of the form\n\u00b7 \u00b7 \u00b7 \u227b p \u227b v (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 .\n2. For each two colors i, j, 1 \u2264 i, j \u2264 h, i 6= j, we introduce 2H\u22121 voters with preference order of the form\n\u00b7 \u00b7 \u00b7 \u227b p \u227b E(i, j).\n3. For each two colors, i, j, 1 \u2264 i, j \u2264 h, i 6= j, we introduce two voters, one with preference order of the form\n\u00b7 \u00b7 \u00b7 \u227b p \u227b R(i, j),\nand one with preference order of the form\n\u00b7 \u00b7 \u00b7 \u227b p \u227b R\u2032(i, j).\n4. We introduce 2H voters with preference order of the form \u00b7 \u00b7 \u00b7 \u227b p.\nWe set the number k of candidates that can be deleted to \u2016V (G)\u2016\u2212h+2\u2016E(G)\u2016\u22122 ( h 2 )\n(with the intention that one should delete all the candidates in the election except for the candidates corresponding to the vertices and edges of the multi-colored clique of order h). This completes the construction. Note that the total number of voters is\n(2H \u2212 (h\u2212 1)) \u00b7 h+ (2H \u2212 1) \u00b7H + 2H + 2H\n= 2H \u00b7 (H + h+ 1)\n= 2(h\u2212 1) \u00b7 h \u00b7 (h2 + 1).\nSince the input graph is connected and contains at least two vertices, there is at least one candidate, either a vertex candidate or an edge candidate, which has fewer than 2H vetoes. Thus, p is currently not a winner.\nWe claim that p can becomes a winner by deleting at most k candidates if and only if I is a \u201cyes\u201d-instance.\nFirst, it is easy to see that if G contains an order-h multi-colored clique and Q is the set of h vertices that form such a clique, then we can ensure that p is a winner. It suffices to delete all candidates from V (G) \\ Q and all the edge candidates except the ones of the form (u, v), where both u and v belong to Q. In effect, each remaining candidate will have 2H vetoes and all the candidates will tie for victory. To see this, note that after deleting the candidates, p still receives 2H vetoes from the last group of voters. Now, for each color i, 1 \u2264 i \u2264 h, consider the remaining vertex candidate of color i (call this vertex v(i)). This candidate receives 2H \u2212 (h \u2212 1) vetoes from the first group of voters. Further, there are exactly h\u2212 1 voters in the third group that give one veto to v(i) each (these are the voters that correspond to the edges that connect v(i) with the other vertices of the clique). No other voter vetoes v(i). Now, for each two colors i and j, 1 \u2264 i, j \u2264 h, i 6= j, consider the two edge candidates, call them (u, v) and (v, u), whose corresponding edges are incident to vertices of color i (candidate u) and color j (candidate v). Both (u, v) and (v, u) still get 2H \u2212 1 vetoes from the second group of voters. It is also easy to see that each of them receives one veto from the third group of voters (for the case of (u, v), this veto comes from the first voter corresponding to color choice (i, j), and in the case of v, this veto comes from the first voter corresponding to color choice (j, i)).\nNow, let us take care of the other direction. Assume that it is possible to ensure p\u2019s victory be deleting at most k candidates. Prior to deleting any candidates, p has 2H vetoes and, of course, deleting candidates cannot decrease this number. Thus, we have to ensure that each non-deleted candidate has at least 2H vetoes.\nConsider some two colors i and j (1 \u2264 i, j \u2264 h, i 6= j). Each edge candidate (u, v) (where the corresponding vertex u has color i and the corresponding vertex v has color j) appears below p in 2H \u2212 1 votes from the second group of voters and in 2 votes from the third one. If we keep two edge candidates, say (u\u2032, v\u2032) and (u\u2032\u2032, v\u2032\u2032) (where u\u2032, u\u2032\u2032 \u2208 Vi(G) and v\u2032, v\u2032\u2032 \u2208 Vj(G)), then they are both ranked below p in the same 2H \u2212 1 votes from the second group and in the same two votes from the third one. If neither (u\u2032, v\u2032) nor (u\u2032\u2032, v\u2032\u2032) is deleted, then one of them will receive fewer than 2H vetoes. This means that for each two colors i and j, we have to delete all except possibly one edge candidate of the form (u, v), where u \u2208 Vi(G) and v \u2208 Vj(G).\nSimilarly, for each color i, 1 \u2264 i \u2264 h, each vertex-candidate from Vi(G) appears below p in 2H \u2212 (h \u2212 1) vetoes from the first group of voters and in 2(h\u2212 1) votes from the third group. Each two candidates of the same color are ranked below p in the same votes in the first group. Thus, if two vertex-candidates of the same color were left in the election (after deleting candidates), then at least one of them would have fewer than 2H vetoes.\nIn consequence, and since we can delete at most k = \u2016V (G)\u2016 \u2212 h + 2\u2016E(G)\u2016 \u2212 2 ( h 2 ) candidates which means at least h+H candidates except p must remain in the final election, if p is to become a winner, then after deleting the candidates the election must contain exactly one vertex candidate of each color, and exactly one edge-candidate for each ordered pair of colors.\nAssume that p is among the winners after deleting candidates and consider two remaining vertex candidates u and v, u \u2208 Vi(G) and v \u2208 Vj(G) (i 6= j); they must exist by the previous observation. We claim that edge candidates (u, v) and (v, u) also must be remaining as well. Due to symmetry, it suffices to consider (u, v). Careful inspection of voters in the third group shows that if (u, v) is not among the remaining candidates, then (using the observation regarding orders R(i, j) and R\u2032(i, j)) we have that the two voters from the third group that correspond to the color pair (i, j) either both rank u last or both rank the same edge candidate last. In either case, a simple counting argument shows that either u has fewer than 3H vetoes or the edge candidate corresponding to the ordered color pair (i, j) has fewer than 3H vetoes. In either case, p is not a winner. This shows that the remaining candidates correspond to an order-h multi-colored clique.\nLemma 4. For each fixed integer t \u2265 1, t-Veto-CCDC is W[1]-hard, when parameterized by the number of voters.\nProof. We use almost the same proof as in Lemma 3, but we add sufficiently many padding candidates to ensure that we can only delete vertex and edge candidates. Let I = (G, h) be an input instance of MULTI-COLORED CLIQUE. Let E\u2032 = (C\u2032, V \u2032) be the election created by the reduction from the proof of Lemma 3 on input I and set k := \u2016V (G)\u2016\u2212h+2\u2016E(G)\u2016\u22122 (\nh 2\n)\n. We modify this election by extending C\u2032 to contain a set D of t dummy candidates, D = {d1, . . . , dt}, and modifying the voter collection V \u2032 as follows (recall that the number \u2016V \u2032\u2016 of voters is a function polynomially bounded by h; set n\u2032 := \u2016V \u2032\u2016.):\n1. For each voter v in V \u2032 except the last group of voters, we modify v\u2019s preference order to rank the dummies d1, . . . , dt\u22121 last and dt first.\n2. For each voter v in the last group of V \u2032, we rank all candidates from D such that v will have a preference order of the form\ndt \u227b \u00b7 \u00b7 \u00b7 \u227b (D \\ {dt}) \u227b p.\n3. We add n\u2032 voters, all with preference order of the form\n\u00b7 \u00b7 \u00b7 \u227b p \u227b D.\nIt is easy to verify that each newly added candidate di, 1 \u2264 i \u2264 t \u2212 1, has 2n\u2032 vetoes and dt has n\u2032 vetoes. Since we assume the input graph to be connected and to have at least two vertices, at least one candidate from the edge and vertex candidates receives fewer vetoes than p. Thus, p is not a winner initially.\nWe claim that p (the preferred candidate from the proof of Lemma 3) can become a winner by deleting at most k candidates if and only if I is a \u201cyes\u201d-instance.\nFirst, we note that if we delete any of the new dummy candidates from D \\ {dt}, then p certainly does not become a winner since p will have at least n\u2032 + 2H vetoes and dt will have exactly n\u2032 vetoes. If we delete dummy candidate dt, then p will receive 2n\u2032 vetoes, but there is at least one remaining vertex or edge candidate which is not vetoed by the last group of voters and has hence, less than 2n\u2032 vetoes. In consequence, no dummy candidate can be deleted. Thus, neither of them will have fewer vetoes than p and (ignoring the dummy candidates) the election will behave as if it was held according to the Veto rule. The argument from the proof of correctness in Lemma 3 holds.\nLemma 5. 2-Approval-CCDC is W[1]-hard, when parameterized by the number of voters.\nProof. The proof is quite similar to that for the case of Veto-CCDC, but now the construction is a bit more involved. We give a reduction from the MULTI-COLORED CLIQUE problem. Let I = (G, h) be our input instance with graph G and non-negative integer h, and let the notation be as described in the introduction to the MULTI-COLORED CLIQUE technique section. We form an instance I \u2032 of 2-Approval-CCDC based on I . We build our candidate set C as follows (we set T = \u2016V (G)\u2016 + \u2016E(G)\u2016 with the intended meaning that T is an integer larger than the number of candidates that we can delete; we set H := 2 (\nh 2\n)\n= (h\u2212 1) \u00b7 h):\n1. We introduce the preferred candidate p.\n2. We introduce T candidates b1, . . . , bT (these are the blocker candidates whose role, on one hand, is to ensure that p has to obtain a given number of points and, on the other hand, who prevent deleting too many candidates of other types).\n3. For each vertex v \u2208 V (G), we introduce candidate v.\n4. For each edge {u, v} \u2208 E(G), we introduce two candidates, (u, v), and (v, u).\n5. We introduce two sets D = {d1, . . . dh} and F = {f(i,j) | 1 \u2264 i 6= j \u2264 h} of dummy candidates.\nThe set of voters consists of the following groups (we write B to refer to the preference order b1 \u227b b2 \u227b \u00b7 \u00b7 \u00b7 \u227b bT ):\n1. We have h+ 3H voters, each with preference order of the form\nB \u227b \u00b7 \u00b7 \u00b7 \u227b p.\n2. For each color i, 1 \u2264 i \u2264 h, there are 3H + 1 voters, where the first of them has preference order of the form\nv (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 \u227b p \u227b B \u227b \u00b7 \u00b7 \u00b7 ,\nand the remaining ones have preference order of the form\nv (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 \u227b di \u227b B \u227b \u00b7 \u00b7 \u00b7 .\n3. For each pair i, j of distinct colors (1 \u2264 i, j \u2264 h, i 6= j), there are 3H + h\u2212 1 voters, where the first of them has preference order of the form\nE(i, j) \u227b p \u227b B \u227b \u00b7 \u00b7 \u00b7 ,\nand the remaining ones have preference order of the form\nE(i, j) \u227b f(i,j) \u227b B \u227b \u00b7 \u00b7 \u00b7 .\n4. For each pair i, j of distinct colors (1 \u2264 i, j \u2264 h, i 6= j), we introduce two voters with the following preference orders of the forms\np \u227b R(i, j) \u227b B \u227b \u00b7 \u00b7 \u00b7\np \u227b R\u2032(i, j) \u227b B \u227b \u00b7 \u00b7 \u00b7\nNote that the total number of constructed voters is polynomially bounded by h:\nh+ 3H + (3H + 1) \u00b7 h+ (3H + h\u2212 1) \u00b7H + 2H\n= 2h+ 4H + 4H \u00b7 h+ 3H2.\nWe set the number of candidates that can be deleted to k := \u2016V (G)\u2016\u2212h+2\u2016E(G)\u2016\u22122 ( h 2 )\n, with the intention that p can become a winner if and only if it is possible to delete all of the vertex candidates and all of the edge candidates except for the ones corresponding to a multicolored clique of order h. We notice that if G indeed contains an order-h multi-colored clique Q, then deleting all the candidates in V (G) \\Q and all the edge candidates of the form (u, v) where either u /\u2208 Q or v /\u2208 Q indeed ensures that p is a winner (in this case p, and all of the vertex and edge candidates have h+3H points each, and all of the blocker candidates have at most h+ 3H points each).\nOn the other hand, let us assume that it is possible to ensure p\u2019s victory by deleting at most k candidates and let C\u2032 \u2286 C be a set of at most k candidate such that p is a winner of E\u2032 = (C \\ C\u2032, V ). Notice that k < T \u2212 1 and so there are at least two blocker candidates that receive h + 3H points each from the first group of voters. The only voters from whom p can obtain points after deleting at most k candidates are the ones in the second and third group and there are exactly h+H of them (h in the second group and H in the third group). However, p can obtain the points from the second and the third groups of voters without, at the same time, increasing the score of the highest-scoring blocker candidate if and only if: (a) we delete all-but-one vertex-candidates of each color, and (b) for each pair i, j of distinct colors (1 \u2264 i, j \u2264 h, i 6= j) all-but-one edge-candidates of the form (u, v), where u \u2208 Vi(G) and v \u2208 Vj(G). This means deleting exactly k candidates. Further, we claim that if p is a winner of E\u2032, then for each two not-deleted vertex-candidates u and v, it must be the case that\nboth edge-candidates (u, v) and (v, u) are still in the election, meaning that there is an edge between u and v in the original graph. It suffices to consider the case of (u, v) (the case of (v, u) is symmetric). If instead of (u, v) the only not-deleted edge candidate for the pair of colors of u and v is some edge candidate (u\u2032, v\u2032) (where (u\u2032, v\u2032) 6= (u, v)), then one of the two following cases must happen: either u and v would receive more than h \u2212 1 points from the fourth group, therefore would have more than h+ 2 (\nh 2\n)\n, causing p not be a winner, or (u\u2032, v\u2032) would receive more than 1 point from the fourth group, again causing p to not be a winner. Thus p can become a winner by deleting at most H candidates if and only if G contains a multi-colored clique of order h.\nIt is clear that the given reduction can be computed in polynomial time and the proof is complete.\nLemma 6. For each fixed integer t, t \u2265 3, t-Approval-CCDC is W[1]-hard, when parameterized by the number of voters.\nProof. Let E\u2032 = (C\u2032, V \u2032) be the election constructed in the proof for Lemma 5. It suffices to use the same proof as for Lemma 5 except that now for each voter vi \u2208 V \u2032 we introduce a group of t \u2212 2 new dummy candidates, di1, d i 2, . . . , d i t\u22122, that are ranked first, and for each such introduced group, we introduce one yet two new dummies, ci1 and c i 2, and \u2016V\n\u2032\u2016\u22121 voters with preference order of the form (we write Di to refer to the preference order di1 \u227b d i 2 \u227b . . . \u227b dit\u22122): Di \u227b c i 1 \u227b c i 2 \u227b B \u227b \u00b7 \u00b7 \u00b7 .\nThese voters ensure that none of the new dummy candidates can be deleted without increasing the score of the highest-scoring blocker candidate. If a score of a highest-scoring blocker candidate increases, then the preferred candidate has no longer any chance of winning. If none of the new dummy candidate can be deleted, then the correctness proof works the same as the one given for Lemma 5.\nThe number of voters is still polynomially bounded by the clique order h.\nWe now move on to the combinatorial variant of destructive control by adding candidates, for t-Approval and t-Veto (for t \u2265 2). In this case we still use a technique very similar to the proofs we have seen so far, but since we are in the combinatorial setting, the proofs can rely on the bundling function to ensure consistency between the added edge candidates and vertex candidates (indeed, for these cases, the analogous non-combinatorial problem is fixedparameter tractable).\nLemma 7. For each fixed integer t \u2265 2, t-Approval-COMB-DCAC is W[1]-hard, when parameterized by the number of voters.\nProof. Given an instance of MULTI-COLORED CLIQUE, we construct an instance of t-ApprovalCOMB-DCAC. For this proof, it is more natural to create only one candidate for each edge, and not two \u201cdirected\u201d ones. We let the set of registered candidates be of the form C = {p, d}\u222aD, where D is the following sets of dummy candidates:\nD = {d{i,j}z | i 6= j \u2208 [h], z \u2208 [t\u2212 1]}\n\u222a {d(i)z | i \u2208 [h], z \u2208 [t\u2212 1]} \u222a {e(i)z | i \u2208 [h], z \u2208 [t\u2212 1]}.\nCandidate d is the despised one whose victory we want to preclude. We let the set of additional (unregistered) candidates be\nA = V (G) \u222aE(G).\nThat is, A contains all the vertex candidates and all the edge candidates. We set the bundling function \u03ba so that for each edge candidate e = (u, v), we have \u03ba(e) = {e, u, v}, and for each vertex candidate v we have \u03ba(v) = {v}. We introduce the following voters:\n1. For each pair {i, j} \u2282 [h], i 6= j, of distinct colors, we have one voter with the following preference order, we write E({i, j}) to mean an arbitrarily chosen order over the edge candidates that link vertices of color i with those of color j):\nE({i, j}) \u227b d {i,j} 1 \u227b \u00b7 \u00b7 \u00b7 \u227b d {i,j} t\u22121 \u227b d \u227b \u00b7 \u00b7 \u00b7 .\nNote that in the initial election, d gets a point from this voter, but it is sufficient (and we will make sure that it is also necessary) to add one candidate from E({i, j}) to prevent d from getting this point.\n2. For each color i, 1 \u2264 i \u2264 h, we have a voter with the following preference order:\nv (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b v (i) n\u2032 \u227b d (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b d (i) t\u22122 \u227b p \u227b d (i) t\u22121 \u227b \u00b7 \u00b7 \u00b7 .\nNote that in the initial election p gets a point from this voter, but if more than one candidate from Vi(G) is added, then p does not gain this point.\n3. For each number i \u2208 [h], we have a voter with the following preference order:\nd \u227b e (i) 1 \u227b \u00b7 \u00b7 \u00b7 \u227b e (i) t\u22121 \u227b \u00b7 \u00b7 \u00b7 .\nNote that d gets one point from this voter.\nFirst, prior to adding any candidates, d has h+ ( h 2 )\npoints while p has h points and each of the dummy candidates has one point. We claim that it is possible to ensure that d is not a winner of this election by adding at most k := (\nh 2\n)\ncandidates if and only if G has a multi-colored clique of order h.\nOn one hand, easy calculation shows that if there is a multi-colored clique in G, then adding the edge-candidates corresponding to the edges of this clique ensures that d is not a winner.\nFor the other direction, let us assume that it is possible to ensure that d is not a winner by adding at most (\nh 2\n)\ncandidates. It is easy to see that p is the only candidate that can reach score higher than d this way. For this to happen, d must lose all the points that d initially got from the first group of voters, and p must still get all the points from the second group of voters. Moreover, adding voters corresponding to vertices does not help. Thus, this must correspond to adding (\nh 2\n)\nedge candidates whose bundles do not add two vertices of the same color. That is, these (\nh 2\n)\nadded edge candidates must correspond to a multi-colored clique."}, {"heading": "C Cubic Vertex Cover Technique", "text": "In this section we give the proofs based on the CUBIC VERTEX COVER technique. The idea is to prove para-NP-hardness via reductions from the CUBIC VERTEX COVER problem, using the fact that cubic graphs (that is, graphs where each vertex has degree three) can be easily encoded using a fixed number of votes. Formally, the CUBIC VERTEX COVER is defined as follows.\nDefinition 3. An instance of CUBIC VERTEX COVER consists of a graphG = (V (G), E(G)), where each vertex of G has degree exactly three, and a non-negative integer h. We ask if there is a subset (vertex cover) of at most h vertices such that each edge is incident to at least one vertex in the subset.\nAll our reductions in this section will use the following common setup. Let I be an instance of CUBIC VERTEX COVER with a graph G and non-negative integer h. By the classic result of Vizing, we know that there is an edge-coloring of G with four colors (that is, it is possible to assign one out of four colors to each edge so that no two edges incident to the same vertex have the same color). Further, it is possible to compute this coloring in polynomial time Misra and Gries [27]. This is equivalent to saying that it is possible to decompose the set of G\u2019s edges into four disjoint matchings. Our reductions start by computing this decomposition and we rename the edges of G so that these four disjoint matchings are:\nE(1) = {e (1) 1 , . . . , e (1) m1 } E(2) = {e (2) 1 , . . . , e (2) m2 } E(3) = {e (3) 1 , . . . , e (3) m3 } E(4) = {e (4) 1 , . . . , e (4) m4 }\nWe set m\u2032 = m1+m2+m3+m4 = \u2016E(G)\u2016 and n\u2032 = \u2016V (G)\u2016. For each edge e of the graph, we arbitrarily order its vertices and we write v\u2032(e) and v\u2032\u2032(e) to refer to the first vertex and to the second vertex, respectively. For each \u2113, 1 \u2264 \u2113 \u2264 4, we write E(\u2212\u2113) to mean E(G) \\ E(\u2113). We write V (\u2212\u2113) to mean the set of vertices that are not incident to any of the edges in E(\u2113).\nThe crucial point of our approach is to use the above decomposition to create eight votes (two for each matching) that encode the graph. We will now provide useful notation for describing these eight votes. For each edge e of the graph, we define the following four orders over e, v\u2032(e), and v\u2032\u2032(e):\nP (e) : e \u227b v\u2032(e) \u227b v\u2032\u2032(e),\nP \u2032(e) : e \u227b v\u2032\u2032(e) \u227b v\u2032(e),\nQ(e) : v\u2032(e) \u227b v\u2032\u2032(e) \u227b e,\nQ\u2032(e) : v\u2032\u2032(e) \u227b v\u2032(e) \u227b e.\nFor each \u2113, 1 \u2264 \u2113 \u2264 4, we define the following orders over V (G) \u222a E(G):\nA(\u2113) : P (e (\u2113) 1 ) \u227b P (e (\u2113) 2 ) \u227b \u00b7 \u00b7 \u00b7 \u227b P (e (\u2113) m\u2113 ),\nA\u2032(\u2113) : P \u2032(e(\u2113)m\u2113) \u227b \u00b7 \u00b7 \u00b7 \u227b P \u2032(e (\u2113) 2 ) \u227b \u00b7 \u00b7 \u00b7 \u227b P \u2032(e (\u2113) 1 ),\nB(\u2113) : Q(e (\u2113) 1 ) \u227b Q(e (\u2113) 2 ) \u227b \u00b7 \u00b7 \u00b7 \u227b Q(e (\u2113) m\u2113 ),\nB\u2032(\u2113) : Q\u2032(e(\u2113)m\u2113) \u227b \u00b7 \u00b7 \u00b7 \u227b Q \u2032(e (\u2113) 2 ) \u227b \u00b7 \u00b7 \u00b7 \u227b Q \u2032(e (\u2113) 1 ).\n(Note that since each E(\u2113) is a matching, each of the above orders is well-defined.) The first two of these families of orders (i.e., A(\u2113) and A\u2032(\u2113)) will be useful in the hardness proofs for the cases of deleting candidates and the latter two (i.e., B(\u2113) and B\u2032(\u2113)) in the hardness proofs for the cases of adding candidates. The intuitive idea behind orders A(\u2113) and A\u2032(\u2113) (B(\u2113) and B\u2032(\u2113)) is that, at a high level, they are reverses of each other, but they treat edges and their endpoints in a slightly asymmetric way (we will describe this in detail in respective proofs).\nLemma 8. Borda-CCDC is NP-hard, even for elections with only ten voters.\nProof. We give a reduction from CUBIC VERTEX COVER (we use the notation as provided at the beginning of this section). Let I be our input instance that contains graphG = (V (G), E(G)) and non-negative integer h. We use the notation introduced in the beginning of the section. We form an election E = (C, V ), where C = {p, d}\u222aV (G)\u222aE(G). We introduce the following ten voters:\n1. For each \u2113, 1 \u2264 \u2113 \u2264 4, we have the following two voters:\n\u00b5(\u2113) : A(\u2113) \u227b E(\u2212\u2113) \u227b V (\u2212\u2113) \u227b d \u227b p,\n\u00b5\u2032(\u2113) : p \u227b d \u227b \u2190\u2212\u2212\u2212 V (\u2212\u2113) \u227b \u2190\u2212\u2212\u2212 E(\u2212\u2113) \u227b A\u2032(\u2113).\n2. We have one voter with preference order p \u227b d \u227b V (G) \u227b E(G) and one voter with\npreference order \u2190\u2212\u2212\u2212 E(G) \u227b \u2190\u2212\u2212\u2212 V (G) \u227b p \u227b d.\nWe claim that p can become a winner of this election by deleting at most k := h candidates if and only if there is a vertex cover of size h for G.\nLet us first calculate the scores of all the candidates:\n1. Candidate p has 5(n\u2032+m\u2032)+6 points (that is, 4(n\u2032+m\u2032+1) points from the first eight voters and n\u2032 +m\u2032 + 2 points from the last two voters).\n2. Each vertex candidate v has 5(n\u2032 +m\u2032) + 2 points (for each of the three pairs of voters \u00b5(\u2113), \u00b5\u2032(\u2113), 1 \u2264 \u2113 \u2264 4, such that v is incident to some edge in E(\u2113), v gets n\u2032 + m\u2032\npoints; v gets n\u2032+m\u2032+1 points from the remaining pair of voters in the first group and, additional, n\u2032 +m\u2032 + 1 points from the last two voters).\n3. Each edge candidate e has 5(n\u2032+m\u2032)+7 points (that is, n\u2032+m\u2032+3 points from the pair of voters \u00b5(\u2113), \u00b5(\u2113) such that e \u2208 E(\u2113), n\u2032 +m\u2032 + 1 points from each of the remaining voters in the first group, and n\u2032 +m\u2032 + 1 points from the last two voters.\n4. Candidate d has 5(n\u2032 +m\u2032) + 4 points (that is, 4(n\u2032 +m\u2032 + 1) points from the voters in the first group and n\u2032 +m\u2032 points from the last two voters.\nClearly, prior to deleting any of the candidates, p is not a winner because edge candidates have higher scores. However, the score of p is higher than the score of the vertex candidates and the score of d.\nWe now describe how deleting candidates affect the scores of the candidates. Let v be some vertex candidate. Deleting v from our election causes the following effects: The score of each edge candidate e such that v = v\u2032(e) or v = v\u2032\u2032(e) decreases by six; the score of each other remaining candidate decreases by five. This means that if we delete h vertex candidates that correspond to a vertex cover of G, then the scores of p, d, and all the vertex candidates decrease by 5h, while the scores of all the edge candidates decrease by at least 5h + 1. As a result, we have p as a winner of the election.\nOn the other hand, assume that it is possible to ensure p\u2019s victory by deleting at most h candidates. Deleting candidate d decreases the score of p by six, whereas it decreases the scores of each other candidate by five. Thus, we can assume that there is a solution that does not delete d. Similarly, it is easy to note that if there is a solution that deletes some edge e, then a solution that is identical but instead of e deletes either v\u2032(e) or v\u2032\u2032(e) (it is irrelevant which\none) is also correct. We conclude that it is possible to ensure p\u2019s victory by deleting at most h vertex candidates. However, by the discussion of the effects of deleting vertex candidates and the fact that prior to any deleting each edge candidate has one point more than p, we have that these at-most-h deleted vertex candidates must correspond to a vertex cover of G. This completes the proof.\nLemma 9. Borda-CCAC is NP-hard, even for elections with only ten voters.\nProof. We give a reduction from CUBIC VERTEX COVER (we use the notation as provided at the beginning of this section). Given an instance (G, h) for CUBIC VERTEX COVER, we construct an instance for Borda-CCAC. We let the registered candidate set C be {p, d}\u222aE(G), and we let V (G) be the set of unregistered candidates. We construct the following voters:\n1. For each \u2113, 1 \u2264 \u2113 \u2264 3, we have the following two voters:\n\u00b5(\u2113) : B(\u2113) \u227b E(\u2212\u2113) \u227b V (\u2212\u2113) \u227b d \u227b p,\n\u00b5\u2032(\u2113) : p \u227b d \u227b \u2190\u2212\u2212\u2212 V (\u2212\u2113) \u227b \u2190\u2212\u2212\u2212 E(\u2212\u2113) \u227b B\u2032(\u2113).\n2. For \u2113 = 4, we have the following two voters:\n\u00b5(\u2113) : B(\u2113) \u227b E(\u2212\u2113) \u227b V (\u2212\u2113) \u227b d \u227b p,\n\u00b5\u2032(\u2113) : d \u227b p \u227b \u2190\u2212\u2212\u2212 V (\u2212\u2113) \u227b \u2190\u2212\u2212\u2212 E(\u2212\u2113) \u227b B\u2032(\u2113).\n3. We have two voters with preference orders\nE(G) \u227b p \u227b d \u227b V (G)\np \u227b \u2190\u2212\u2212\u2212 E(G) \u227b d \u227b \u2190\u2212\u2212\u2212 V (G).\nWe claim that it is possible to ensure p\u2019s victory by adding h candidates if and only if there is a vertex cover of size k := h for G.\nNote that at the beginning, p has 5m\u2032+5 points, d has 4m\u2032+5 points, and each edge candidate has 5m+6 points. Thus p is not a winner. Adding each unregistered vertex candidate v causes the scores of all the candidates to increase: For the edge candidates that include v as an endpoint this increase is by five points, whereas for all the other candidates this increase is by six points. Note that the last two voters always prefer the registered candidates to any vertex candidate. Thus, by simple counting, each of these h vertex candidates may obtain at most 4m\u2032 + 5h+ 7 points and will never obtain more points than p as long as m\u2032 + h \u2265 2.\nThus, if we have a vertex cover of size h, then it is possible to ensure p\u2019s victory by adding all the vertex candidates that correspond to this vertex cover. For the other direction, assume that it is possible to ensure p\u2019s victory by adding at most h candidates and let S be such a set of candidates. For the sake of contradiction, assume that there is an edge candidate e which is not covered by some vertex candidate in S. It follows that the score of e is greater than the score of p, which is a contradiction. Thus S must correspond to a vertex cover in G.\nLemma 10. Maximin-CCAC is NP-hard, even for elections with only ten voters.\nProof. We give a reduction from CUBIC VERTEX COVER (we use the notation as provided at the beginning of this section). Given an instance (G, h) for CUBIC VERTEX COVER, we construct an instance for Maximin-CCAC. We let the registered candidate set C be {p} \u222a E(G), and we let V (G) be the set of unregistered candidates. We construct the following voters:\n1. For each \u2113, 1 \u2264 \u2113 \u2264 4, we have the following two voters:\n\u00b5(\u2113) : B(\u2113) \u227b E(\u2212\u2113) \u227b V (\u2212\u2113) \u227b p,\n\u00b5\u2032(\u2113) : p \u227b \u2190\u2212\u2212\u2212 V (\u2212\u2113) \u227b \u2190\u2212\u2212\u2212 E(\u2212\u2113) \u227b B\u2032(\u2113).\n2. We have one voter with preference order E(G) \u227b p \u227b V (G) and one voter with\npreference order \u2190\u2212\u2212\u2212 E(G) \u227b p \u227b \u2190\u2212\u2212\u2212 V (G).\nLet E be the thus-constructed election (including all the registered and unregistered candidates). We have the following values of the NE(\u00b7, \u00b7) function:\n1. For each vertex v \u2208 V (G), we have NE(p, v) = 6 (so NE(v, p) = 4).\n2. For each edge e \u2208 E(G), we have NE(p, e) = 4 (so NE(e, p) = 6).\n3. For each vertex v \u2208 V (G) and each edge e \u2208 E(G) we have the following: If v is an endpoint of e, then NE(v, e) = 6 (so NE(e, v) = 4), and otherwise we have NE(v, e) = 5 (so NE(e, v) = 5).\n4. For each two vertices, v\u2032, v\u2032\u2032 \u2208 V (G), NE(v\u2032, v\u2032\u2032) = 5.\n5. For each two edges, e\u2032, e\u2032\u2032 \u2208 E(G), NE(e\u2032, e\u2032\u2032) = 5.\nIn effect, prior to adding the candidates, the score of p is four and the score of each edge candidate is five. Adding a vertex candidate v to the election does not change the score of p, but decreases the score of each edge candidate that has v as an endpoint to four. Further, this added vertex candidate has score four as well. Thus, it is easy to see that it is possible to ensure p\u2019s victory by adding at most h candidates if and only if there is a size-h vertex cover for G.\nLemma 11. For each rational number \u03b1, 0 \u2264 \u03b1 \u2264 1, Copeland\u03b1-CCAC is NP-hard, even for elections with only twenty voters.\nProof. We give a reduction from CUBIC VERTEX COVER (we use the notation as provided at the beginning of this section). Given an instance (G, h) for CUBIC VERTEX COVER, we construct an instance for Copeland\u03b1-CCAC. We let the registered candidate set C be {p, d} \u222a E(G), and we let V (G) be the set of unregistered candidates. We introduce the following voters:\n1. For each \u2113, 1 \u2264 \u2113 \u2264 4, we construct four voters, two voters with the following preference order:\nB(\u2113) \u227b E(\u2212\u2113) \u227b V (\u2212\u2113) \u227b d \u227b p,\nand two voters with the following preference order:\np \u227b d \u227b \u2190\u2212\u2212\u2212 V (\u2212\u2113) \u227b \u2190\u2212\u2212\u2212 E(\u2212\u2113) \u227b B\u2032(\u2113).\n2. One voter with the preference order E \u227b V \u227b d \u227b p, and one voter with the preference order d \u227b p \u227b \u2190\u2212 E \u227b \u2190\u2212 V .\n3. One voter with the preference order p \u227b V \u227b E \u227b d, and one voter with the preference order \u2190\u2212 E \u227b d \u227b p \u227b \u2190\u2212 V .\nWe illustrate the results of head-to-head contests between the candidates in Figure 1. We claim that there is a vertex cover of size at most h for G if and only if p can become a winner of the election by adding at most k := h candidates.\nConsider a situation where we have added some subset A\u2032 of k candidates (k \u2264 h; take k = 0 to see the situation prior to adding any of the unregistered candidates). The candidates have the following scores:\n1. p has score \u03b1m\u2032 + k (p ties head-to-head contests with all the edge candidates and wins all the head-to-head contests with the vertex candidates).\n2. d has score 1+\u03b1k (d wins the head-to-head contest with p and ties all the head-to-head contests with the vertex candidates).\n3. Each added vertex candidate v has score 3+\u03b1k (v ties the head-to-head contests with d and the remaining k \u2212 1 vertex candidates and wins the head-to-head contests with the three edge candidates that are adjacent to v).\n4. Each edge candidate e has score \u03b1m\u2032+k+1\u2212c(e), where c(e) is the number of vertices fromA\u2032 that are adjacent to e (e ties head-to-head contests with p and the remaining edge candidates and wins head-to-head contests with d and all the added vertex candidates except those that are adjacent to e).\nIn effect, it is easy to see that p is a winner of the election if and only if A\u2032 corresponds to a vertex cover of G.\nLemma 12. For each rational number \u03b1, 0 \u2264 \u03b1 \u2264 1, Copeland\u03b1-CCDC is NP-hard, even for elections with only twenty six voters.\nProof. We give a reduction from CUBIC VERTEX COVER (we use the notation as provided at the beginning of this section). Given an instance for CUBIC VERTEX COVER (G, h), we construct an instance for Copeland\u03b1-CCDC. The candidate set contains the edge candidates,\nthe vertex candidate, the preferred candidate p, the dummy candidate d, and a set of further dummy candidates Z = {z1, . . . , zm\u2032+n\u2032}. We construct the following voters:\n1. For each \u2113, 1 \u2264 \u2113 \u2264 4, we construct two voters with preference order:\nA(\u2113) \u227b E(\u2212\u2113) \u227b V (\u2212\u2113) \u227b Z \u227b d \u227b p,\nand two voters with preference order:\np \u227b d \u227b \u2190\u2212 Z \u227b \u2190\u2212\u2212\u2212 V (\u2212\u2113) \u227b \u2190\u2212\u2212\u2212 E(\u2212\u2113) \u227b A\u2032(\u2113).\n2. We also construct the following ten voters:\nv1 : V \u227b E \u227b Z \u227b d \u227b p, v\u20321 : p \u227b d \u227b \u2190\u2212 Z \u227b \u2190\u2212 V \u227b \u2190\u2212 E ,\nv2 : V \u227b p \u227b d \u227b E \u227b Z, v\u20322 : \u2190\u2212 E \u227b \u2190\u2212 Z \u227b \u2190\u2212 V \u227b p \u227b d,\nv3 : p \u227b Z \u227b d \u227b V \u227b E, v\u20323 : \u2190\u2212 E \u227b \u2190\u2212 V \u227b p \u227b \u2190\u2212 Z \u227b d,\nv4 : d \u227b E \u227b Z \u227b V \u227b p, v\u20324 : p \u227b \u2190\u2212 V \u227b \u2190\u2212 Z \u227b d \u227b \u2190\u2212 E ,\nv5 : Z \u227b V \u227b E \u227b d \u227b p, v\u20325 : p \u227b d \u227b \u2190\u2212 E \u227b \u2190\u2212 Z \u227b \u2190\u2212 V .\nFigure 2 illustrates the results of the head-to-head contests among the candidates. Prior to deleting any of the candidates, we have the following scores:\n1. each edge candidate e has m\u2032 + n\u2032 + \u03b1m\u2032 + 2 points (e wins head-to-head contests against all candidates in Z due to voters v2 and v\u20322, wins head-to-head contests against its \u201cincident\u201d vertex candidates due to the first group of voters, and ties with p and the remaining edge candidates),\n2. each vertex candidate u has \u03b1(n\u2032 \u2212 1) +m\u2032 \u2212 1 points (u wins head-to-head contests against all edge candidates that are not \u201cincident\u201d to u due to voters from the first group, and ties with the remaining vertex candidates),\n3. each candidate z from Z has n\u2032 + 1 + \u03b1(m\u2032 + n\u2032 \u2212 1) points (z wins head-to-head contests against all vertex candidates and d due to voters v3, v\u20323, v5, v \u2032 5, and ties with the\nremaining candidates from Z),\n4. d has m\u2032 points (d wins head-to-head contests against all edge candidates due to voters v4 and v\u20324), and\n5. p has m\u2032 + n\u2032 + \u03b1m\u2032 + 1 points (p wins head-to-head contests against all candidates from Z due to voters v3 and v\u20323, wins head-to-head contests against d due to voters v2, v\u20322, v3, v \u2032 3, and ties with all edge candidates).\nThus, all edge candidates are co-winners, and p is not a winner because each edge candidate has one point more than it. However, p has more points than any other non-edge candidate. Note that in the input graph it holds that m\u2032 = 3n\u2032/2\nWe claim that it is possible to ensure that p is a winner by deleting at most k := h candidates if and only if there is a vertex cover of size h for G.\nIf there is a vertex cover for G of size h, then deleting the corresponding h vertices ensures that p is a winner. To see why this is the case, note that after deleting vertices corresponding to a vertex cover the score of p does not change, but the score of each edge candidate decreases by at least one. The scores of other candidates cannot increase, so p is a winner.\nOn the other hand, assume that it is possible to ensure that p is a winner by deleting at most h candidates. Deleting candidates cannot increase p\u2019s score, so it must be the case that each edge candidate loses at least one point.\nObserve that deleting candidates other the vertex candidates will not make the edge candidates lose more than one point than p. The only possibility of deleting a candidate such that an edge candidate e loses a point but p does not is by deleting one of the vertex candidates, v\u2032(e) or v\u2032\u2032(e). Thus, if it is possible to ensure that p is a winner, we must delete vertices that correspond to a vertex cover."}, {"heading": "D Set-Embedding Technique for Combinatorial Variants", "text": "In this section we give the proofs based on the Set-Embedding Technique for the combinatorial variants of our control problems. Specifically, we prove the following statements (all results are for the parameterization by the number of voters):\n1. For each fixed integer t \u2265 1 and for each voting rule R \u2208 {t-Approval, t-Veto, Borda, Copeland\u03b1 (for 0 \u2264 \u03b1 \u2264 1), Maximin}, R-COMB-DCDC is para-NP-hard.\n2. For each fixed integer t \u2265 1 and for each voting rule R \u2208 {t-Approval, t-Veto, Borda, Maximin}, R-COMB-CCDC is para-NP-hard.\n3. For each voting rule R \u2208 {Borda, Maximin}, R-COMB-CCAC is para-NP-hard.\n4. For each voting rule R \u2208 {Borda, Copeland\u03b1 (for 0 \u2264 \u03b1 \u2264 1)}, R-COMB-DCAC is para-NP-hard.\nAll proofs follow by reductions from SET COVER and use the bundling function to encode the sets from the SET COVER instances (hence the name of the technique). We start by providing some common notation and observations for all of them.\nLet I be an input instance of SET COVER (which is NP-hard) with a ground set X = {x1, . . . , xn\u2032}, a family S = {S1, . . . , Sm\u2032} of subsets of X , and a non-negative integer h. The task is to decide whether it is possible to pick at most h sets from S so that their union is X . We assume that for each xi there is some set Sj such that xi \u2208 Sj .\nIn our reductions we build elections with candidate sets that include the elements from X and the sets from S. Specifically, for each element xi \u2208 X , we introduce a candidate with the same name, and for each set Sj \u2208 S, we introduce candidate sj . We denote the set of all element candidates by Xcand and denote the set of all set candidates by Scand. Further, we will typically have candidates p and d. For the constructive cases, p will be the preferred candidate while for the destructive cases, d will be the despised one.\nUnless we say otherwise, in each of our proofs we use a bundling function \u03ba defined as follows: For each set candidate sj , we have \u03ba(sj) = {sj} \u222a {xi | xi \u2208 Sj}, and for each non-set-candidate c, we have \u03ba(c) = {c}. We refer to this bundling function as set-embedding bundling function.\nThe general idea of our proofs is that to ensure p\u2019s victory (for the constructive cases) or d\u2019s defeat (for the destructive cases), one has to add/delete all the candidates from Xcand, and due to the bound on the number of candidates that we can add/delete, this has to be achieved by deleting the candidates from Scand and relying on the bundling function.\nWith the above setup ready, we move on to proving our results."}, {"heading": "D.1 Approval-Based Voting Rules", "text": "Constructive Control by Deleting Candidates. We first prove a general result which applies to all voting rules which satisfy the unanimity principle. A rule satisfies the unanimity principle if in each election where a unique candidate c is ranked first by all the voters, this candidate c is the unique winner.\nLemma 13. Let R be a voting rule that satisfies the unanimity principle. R-COMB-CCDC is NP-hard even for the case of elections with just a single voter.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER, we create an instance I \u2032 of R-COMB-CCDC as follows. We construct an election E = (C, V ) where C = {p} \u222a Xcand \u222a Scand and where V contains a single voter with the following preference order:\nXcand \u227b p \u227b Scand.\nWe use the set-embedding bundling function. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to ensure p\u2019s victory by deleting at most h (bundles of) candidates.\nOn one hand, if I is a \u201cyes\u201d-instance of SET COVER, then I \u2032 is a \u201cyes\u201d-instance of RCOMB-CCDC. Indeed, if S \u2032 is a subfamily of S such that |S \u2032| \u2264 h and \u22c3\nSj\u2208S\u2032 Sj = X , then\nit suffices to delete the candidates C\u2032 that correspond to the sets in S \u2032 from the election to ensure that p is ranked first (and, by the unanimity of R, is a winner).\nOn the other hand, assume that I \u2032 is a \u201cyes\u201d-instance ofR-COMB-CCDC. Since R satisfies the unanimity property, the candidate ranked first by the only voter in our election is always\nthe unique winner. This means that if I \u2032 is a \u201cyes\u201d-instance of R-COMB-CCDC, then there is a subset C\u2032 of candidates such that p\u2032 /\u2208 C\u2032 and X \u2286 \u22c3\nc\u2208C\u2032 \u03ba(c). Without loss of generality, we can assume that C\u2032 contains only candidates from the set {s1, . . . , sm} (if C\u2032 contained some candidate xi, we could replace xi with an arbitrary candidate sj such that xi \u2208 Sj). However, this immediately implies that setting S \u2032 := {Sj | sj \u2208 C\u2032} results in a set cover of size at most h. Therefore I is a \u201cyes\u201d-instance of I .\nAs Plurality, Borda, Copeland\u03b1, and Maximin all satisfy the unanimity property, we conclude the following.\nCorollary 3. For each voting rule R \u2208 {Plurality, Borda, Copeland\u03b1, Maximin}, R-COMBCCDC is NP-hard even for the elections with only a single voter.\nWe can slightly modify the reduction used in the proof of Lemma 13 to work for tApproval (for t \u2265 2).\nLemma 14. For each fixed integer t \u2265 2, t-Approval-COMB-CCDC is NP-hard even for elections with only a single voter.\nProof. We build upon the proof of Lemma 13, but add t\u2212 1 dummy candidates. Specifically, given an instance I := (X,S, h) for SET COVER, we create an instance I \u2032 of t-ApprovalCOMB-CCDC as follows. We construct an election E = (C, V ) where C = {p} \u222a Xcand \u222a Scand\u222aD, where D = {d1, . . . , dt\u22121}, and where V contains a single voter with the following preference order:\nD \u227b Xcand \u227b p \u227b Scand.\nWe use the bundling function as described in the introduction to the set-embedding section. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to ensure p\u2019s victory by deleting at most h (bundles of) candidates.\nTo see the correctness of the argument, note that if there is a solution that ensures p by deleting a specific number of candidates, then there is also a solution that achieves the same and does not delete any of the dummy candidates (it is always at least as useful to delete one of the set candidates instead of a dummy one).\nWe can apply the same general reduction from Lemma 13 to t-Veto (for t \u2265 1).\nLemma 15. For each fixed integer t \u2265 1, t-Veto-COMB-CCDC is NP-hard even for elections with only a single voter.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER, we create an instance I \u2032 of t-Veto-COMB-CCDC as follows. We construct an election E = (C, V ) with candidate set:\nC = {p, z} \u222aXcand \u222a Scand \u222aD,\nwhere D = {d1, . . . , dt\u22121} is a set of dummy candidates (indeed, for t = 1, that is, for Veto, D = \u2205), and with the voter collection V containing a single voter with the following preference order:\nz \u227b Xcand \u227b Scand \u227b D \u227b p.\nWe use the set-embedding bundling function, with the added feature that \u03ba(z) = Scand. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to ensure p\u2019s victory by deleting at most h+ 1 bundles.\nUsing similar reasoning as used in Lemma 14, it is easy to see that the only way of ensuring that p is a winner is to let all the remaining candidates receive no points at all. The only way to achieve this is to first delete up to h candidates from {s1, . . . , sm} that correspond to a cover of the ground set and then to delete z.\nDestructive Control by Deleting Candidates. We can also slightly modify the reductions from the previous section to work for the combinatorial destructive control case, although at the price of using more than one voter (indeed, this is unavoidable, because a candidate which is a t-Approval winner in an election with only one voter cannot be made a non-winner by deleting candidates). We first consider Plurality (we give a proof that uses three voters and this is, indeed, the smallest possible number of voters for which the proof works; if a candidate is a Plurality winner in a two-voter election, this candidate remains a winner irrespective which other candidates we delete).\nLemma 16. Plurality-COMB-DCDC is NP-hard even for election with only three voters.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER, we create an instance I \u2032 of Plurality-COMB-DCDC as follows. We construct an election E = (C, V ) where C = {p, d}\u222aXcand \u222aScand, and where V contains three voters with the following preference orders:\nXcand \u227b p \u227b Scand \u227b d,\nd \u227b Xcand \u227b p \u227b Scand, and\np \u227b d \u227b Xcand \u227b Scand.\nWe use the set-embedding bundling function. We claim that the despised candidate d can be precluded from winning by deleting at most h (bundles of) candidates if and only if there is a set cover of size h for I .\nPrior to deleting any of the candidates, d, p, and one of the candidates from X are tied as winners. Since deleting candidates cannot make any candidate lose points and since deleting p will make d a unique winner, the only way of defeating d is by ensuring that the first voter gives its point to p. This means that all element candidates have to be removed from the election. By the same argument as in the previous proofs, doing so by deleting at most h candidates is possible if and only if I is a \u201cyes\u201d-instance of SET COVER.\nWe move on to consider t-Approval (for t \u2265 2).\nLemma 17. For each fixed integer t \u2265 2, t-Approval-COMB-DCDC is NP-hard even for elections with only two voters.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER, we create an instance I \u2032 of t-Approval-COMB-DCDC as follows. We construct an election E = (C, V ) with candidate set:\nC = {p, d} \u222aXcand \u222a Scand \u222aD \u222a F,\nwhere D = {d1, . . . , dt\u22122} and F = {f1, f2, . . . , ft\u22121} are two sets of dummy candidates (note that D can be empty), and with the voter collection V containing two voters with the following preference orders:\nd \u227b Xcand \u227b D \u227b p \u227b Scand \u227b F and\np \u227b F \u227b d \u227b Xcand \u227b Scand \u227b D.\nWe use the set-embedding bundling function. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to preclude d from winning by deleting at most h (bundles of) candidates.\nAt the beginning, both d and p are winners (as well as some members of Xcand \u222a F ). Deleting p will make d gain one more point (from the second voter), making it impossible for d to lose. The same holds for the dummy candidates from set F . In other words, if we change the set of candidates that gain a point from the second voter, then d will obtain two points and will certainly be a winner. This implies that the only way of making d lose is to let either p or at least one candidate from F gain one point from the first voter. By construction of the first voter\u2019s preference order, this is possible only for p, if and only if we delete all members of Xcand. As in the previous proofs, deleting them (through deleting at most h bundles of candidates) is possible if and only if I is a \u201cyes\u201d-instance of SET COVER.\nWe can also slightly modify the reduction from Lemma 14 to work for t-Veto.\nLemma 18. For each fixed integer t \u2265 1, t-Veto-COMB-DCDC is NP-hard even for elections with only a single voter.\nProof. We use the same construction as used in Lemma 14 for t-Approval-COMB-CCDC but we reverse the preference order and swap p with d, the despised candidate:\nScand \u227b d \u227b Xcand \u227b D.\nThe crucial observation here is that with only one voter, the only way of preventing d from winning is to rank her within the last t positions. This means that all element candidates have to \u201cdisappear\u201d from the election (one could also try deleting the dummy candidates, but it is never a mistake to \u201cmake disappear\u201d the members of Xcand instead, through deleting the appropriate candidates in Scand). Thus we can conclude that the set of deleted candidates contains the set candidates only. Clearly, if d is to be precluded from winning by deleting at most h candidates, this set must correspond to a set cover of size h. Since we assume that h < \u2016Scand\u2016, there is at least one set element not deleted, and this will be a winner."}, {"heading": "D.2 Borda Voting Rule", "text": "We now move on to considering Borda rule. Our proof approaches remain very similar to those used so far.\nLemma 19. Borda-COMB-DCDC is NP-hard even for elections with only two voters.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER, we create an instance I \u2032 of Borda-COMB-DCDC as follows. We construct an election E = (C, V ) where C = {p, d, z} \u222a Xcand \u222a Scand and where V contains two voters with the following preference orders:\nd \u227b Xcand \u227b p \u227b Scand \u227b z and p \u227b z \u227b d \u227b \u2190\u2212\u2212\u2212 Xcand \u227b \u2190\u2212\u2212\u2212 Scand.\nWe use the set-embedding bundling function. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to preclude d from winning by deleting at most h (bundles of) candidates.\nFor convenience, we calculate the scores of all the candidates:"}, {"heading": "1. d has 2\u2016Scand\u2016+ 2\u2016Xcand\u2016+ 2 points.", "text": "2. p has 2\u2016Scand\u2016+ \u2016Xcand\u2016+ 3 points.\n3. each element candidate xi has 2\u2016Scand\u2016+ \u2016Xcand\u2016+ 1 points.\n4. z has \u2016Scand\u2016+ \u2016Xcand\u2016+ 1 points.\n5. each set candidate sj has \u2016Scand\u2016 points.\nClearly, d has the highest number of points and, thus, is a winner. Since both voters rank d ahead of the candidates in the set Xcand \u222a Scand, no member of this set can have the score higher than d, irrespective which other candidates we delete. Similarly, irrespective which candidates we delete, z will never have score higher than d. We conclude that the only candidate that has a chance of defeating d, is p.\nSince deleting candidates does not increase the scores of any of the remaining candidates, to ensure that d is not a winner, we have to guarantee that he or she loses at least \u2016Xcand\u2016 points (relative to p). This means that it is possible to ensure that d is not a winner if and only if it is possible to remove all the candidates from Xcand. However, this is possible if and only if I is a \u201cyes\u201d-instance of SET COVER.\nLemma 20. Borda-COMB-CCAC and Borda-COMB-DCAC are both NP-hard even for elections with only two voters.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER with n := \u2016Xcand\u2016, we create an instance I \u2032 of BordaCOMB-CCAC as follows. We construct the set of registered candidates C = {d, p}\u222aD, where D = {d1, . . . , dn}. We construct the set of the unregistered candidates A = Xcand \u222a Scand. We construct two voters with the following preference order:\nd \u227b D \u227b p \u227b Scand \u227b Xcand \u227b \u00b7 \u00b7 \u00b7 and p \u227b \u2190\u2212\u2212\u2212 Xcand \u227b d \u227b Scand \u227b \u2190\u2212 D \u227b \u00b7 \u00b7 \u00b7 .\nWe use the set-embedding bundling function. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to preclude d from winning by adding at most h (bundles of) candidates.\nnote that d gets n points more than p from the first voter. Given a set cover of size h, we add the corresponding sj\u2019s to the election. Simple calculation shows that in this case p and d tie as winners.\nFor the other direction, note that the relative scores of p and d in the first vote do not change irrespective which candidates we add. On the other hand, the relatives scores of p and d to change in the second vote in the following way: For each unregistered candidate xi added to the election, p\u2019s score increases by one but d\u2019s score remains unchanged. Thus, the only way to ensure that p is a winner is by bringing all the candidates from Xcand to the election. Doing so by adding at most h candidates is possible only if there is a size-h cover for I .\nThe construction for Borda-COMB-DCAC is the same, except that: First, we do not want p to win but d to lose (that is, we define d to be the despised candidate. Second, we define D to have only n\u2212 1 dummy candidates."}, {"heading": "D.3 Copeland\u03b1 and Maximin Voting Rules", "text": "We now move on to the cases of Copeland and Maximin voting rules. The flavor of our proofs changes a bit, albeit we still reduce from SET COVER.\nWe give the proofs for the case of Copeland\u03b1 rule even though, technically, they already follow from the non-combinatorial results. The reason is that this time we can give proofs that use much fewer voters.\nLemma 21. Copeland\u03b1-COMB-DCAC and Copeland\u03b1-COMB-CCAC are NP-hard even for elections with only three voters.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER with n := \u2016Xcand\u2016, we construct an instance for Copeland\u03b1-COMB-DCAC. Since our reduction will produce an instance with an odd number of voters, the particular value of \u03b1 is immaterial. We form the set of registered candidates:\nC = {d, p} \u222aD \u222a F,\nwhere d is the despised candidate (and we will want to ensure that p wins over d), and where D := {d1, . . . , dn\u22122} and F := {f1, . . . , fn\u22121} are two sets of dummy candidates. We let the set of of unregistered candidates be A = Xcand \u222aScand. Finally, we construct three voters with the following preference orders:\nd \u227b D \u227b p \u227b F \u227b Xcand \u227b Scand, p \u227b \u2190\u2212 F \u227b \u2190\u2212\u2212\u2212 Xcand \u227b \u2190\u2212 D \u227b d \u227b \u2190\u2212\u2212\u2212 Scand, and\nXcand \u227b d \u227b D \u227b F \u227b p \u227b Scand.\nWe use the set-embedding bundling function. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to preclude d\u2019s victory by adding at most h (bundles of) candidates.\nPrior to adding any of the candidates, we have the following scores:\n1. d receives 2n\u2212 2 points (d wins head-to-head contests with all the remaining registered candidates).\n2. p receives n\u2212 1 points (p wins head-to-head contests with the members of F ).\n3. every dummy candidate di \u2208 D receives at most 2n \u2212 3 points (di wins head-to-head contests with all the members of F , with p, and\u2014at most\u2014all the remaining members of D).\n4. every dummy candidate fi \u2208 F receives at most n \u2212 2 points (fi wins head-to-head contests with\u2014at most\u2014the remaining members of F ).\nIt is easy to verify through simple calculation that if there is a set cover for I of size at most h, then adding the members of Scand that correspond to the cover ensures that d is not a winner (relative to d, p gets additional n points).\nFor the other direction, note that adding candidates to the election cannot decrease the score of any existing candidate. Thus, in order to beat d, we must add candidates to increase (relative to d) the score of some candidate. We make several observations:\n1. The candidates in Scand themselves do not contribute to the increase of a score of any candidate relative to p because all the other candidates (including d) win head-to-head contests against them.\n2. The scores of the members of D do not change relative to the score of d irrespective which other candidates join the election.\n3. By the first observation in this enumeration, the maximum possible increase of a score of candidate is by n points (if this candidate defeats all members of Xcand and members of Xcand join the election). Since all members of set F have score at most n\u22122, neither of them can obtain score higher than d, irrespective which candidates we add.\nAs a final conclusion, we have that the only candidate that can possibly defeat d is p, and this happens only if all members of Xcand join the election. It is possible to ensure that this happens by adding at most h bundles of candidates if and only if there is a set cover for I of size at most h.\nWe use the same construction for the case of Copeland\u03b1-CCAC, except that now p is the preferred candidate and we increase the size of D by one.\nLemma 22. Copeland\u03b1-COMB-DCDC is NP-hard even for elections with only three voters.\nProof. The reduction is almost the same as the one given for Copeland\u03b1-COMB-DCAC in Lemma 21, but even simpler. The candidate set is C := {p, d} \u222aXcand \u222a Scand.\nWe have three voters with the following preference orders (note that these are the same votes as in the proof of Lemma 21, restricted to the candidates present in our reduction, and with p and d swapped in each vote):\np \u227b d \u227b Xcand \u227b Scand,\nd \u227b Xcand \u227b p \u227b Scand, and \u2190\u2212\u2212\u2212 Xcand \u227b p \u227b d \u227b \u2190\u2212\u2212\u2212 Scand.\nWe use the set-embedding bundling function. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to preclude d\u2019s victory by deleting at most h (bundles of) candidates.\nThe initial scores are:\n1. d receives \u2016Scand\u2016+\u2016Xcand\u2016 points (d wins head-to-head contests against all the other candidates but p);\n2. p receives \u2016Scand\u2016+1 point (p wins head-to-head contests against d and all the members of Scand);\n3. each member xi of Xcand receives at most \u2016Scand\u2016 + \u2016Xcand\u2016 (from head-to-head contests with p, all members of Scand, and the other members of Xcand) ;\n4. each member sj of Scand receives at most \u2016Scand\u2016 \u2212 1 points (from head-to-head contests with the other members of Scand).\nSince deleting candidates cannot make any candidate gain more points, the only way of ensuring that d is not a winner is to make sure that d\u2019s score decreases relative to some other candidate. By the above list of scores, it is easy to see that the only candidate that may end\nup with a score higher than d is p. This happens only if we remove all the members of Xcand. As in the previous proofs using the set-embedding technique, doing so by deleting at most h candidates is possible if and only if there is a set cover of size at most h for I .\nLemma 23. Maximin-COMB-CCAC is NP-hard even for elections with only six voters.\nProof. Let the notation be as in the introduction to the set-embedding section. Given an instance I := (X,S, h) for SET COVER with n := \u2016Xcand\u2016, we construct an instance for Maximin-COMB-CCAC. We let the set of registered candidates be C := {d, p} \u222a D, where p is the preferred candidate and where D := {d1, . . . , dn} is a set of dummy candidates. The unregistered candidate set is A := Xcand \u222a Scand. We construct six voters with the following preference orders:\nv1 : p \u227b x1 \u227b d1 \u227b \u00b7 \u00b7 \u00b7 \u227b xn \u227b dn \u227b Scand,\nv2 : p \u227b xn \u227b dn \u227b \u00b7 \u00b7 \u00b7 \u227b x1 \u227b d1 \u227b Scand,\nv3 : x1 \u227b \u00b7 \u00b7 \u00b7 \u227b xn \u227b d1 \u227b \u00b7 \u00b7 \u00b7 \u227b dn \u227b p \u227b Scand,\nv4 : dn \u227b \u00b7 \u00b7 \u00b7 \u227b d1 \u227b p \u227b xn \u227b \u00b7 \u00b7 \u00b7x1 \u227b Scand,\nv5 : x1 \u227b \u00b7 \u00b7 \u00b7 \u227b xn \u227b d1 \u227b \u00b7 \u00b7 \u00b7 \u227b dn \u227b p \u227b Scand, and\nv6 : dn \u227b \u00b7 \u00b7 \u00b7 \u227b d1 \u227b p \u227b xn \u227b \u00b7 \u00b7 \u00b7 \u227b x1 \u227b Scand.\n(Note that the v3 and v5 have the same preference order and that v4 and v6 have the same preference order.) We use the set-embedding bundling function. We claim that I is a \u201cyes\u201dinstance of SET COVER if and only if it is possible to ensure p\u2019s victory by adding at most h (bundles of) candidates.\nPrior to adding any of the candidates, p has two points and each candidate in D has three points. All the voters rank the members of Scand last, so the presence of these candidates in the election does not change the scores of p and members of D. More so, member of Scand themselves receive zero points each. On the other hand, if some candidate xi appears in the election, then we have the following effects:\n1. This candidate\u2019s score is at most two (because only voters v3 and v5 prefer xi to p).\n2. The score of di becomes at most two (because only voters v4 and v6 prefer di to xi).\n3. The score of p does not change (because already v1 and v2 prefer p to xi).\nThis means that if there is a set cover of size at most h for I , then adding the set candidates that correspond to this cover will bring all members of Xcand to the election and p will be among the winners.\nFor the other direction, note that on one hand, it is impossible to increase the score of p by adding candidates, and that for each di, the only way to decrease its score to at most two is to being xi into the election.\nFor the other direction, notice that in order to let p, we must add candidates to the election to decrease the score of every element candidate xi. and the only way to achieve this with adding at most k bundles is by adding the sj corresponding to the set cover. This means that if it is possible to ensure p\u2019s victory by adding at most h candidates, it must be possible to add all members of Xcand into the election, and this means that there is a set cover of size at most h.\nLemma 24. Maximin-COMB-DCDC is NP-hard, even for elections with only five voters.\nProof. The proof is similar to the one given for Maximin-COMB-CCAC. Given an instance (X,S, h) for SET COVER, we construct an instance for Maximin-COMB-DCDC. We construct a set of candidates C := {p, d, e} \u222aXcand \u222a Scand. We construct the following five voters:\none voter : p \u227b d \u227b Xcand \u227b e \u227b Scand,\ntwo voters : d \u227b Xcand \u227b p \u227b e \u227b Scand, two voters : e \u227b \u2190\u2212\u2212\u2212 Xcand \u227b p \u227b d \u227b \u2190\u2212\u2212\u2212 Scand.\nWe use the set-embedding bundling functions. We claim that I is a \u201cyes\u201d-instance of SET COVER if and only if it is possible to ensure that d is not a winner by deleting at most h (bundles of) candidates.\nLet E be our election prior to deleting any of the candidates. The values of the NE(\u00b7, \u00b7) function are given in the table below (the entry for row a and column b gives the value of NE(a, b); we assume i\u2032 6= i\u2032\u2032 and j\u2032 6= j\u2032\u2032).\np d e xi\u2032 sj\u2032\np - 3 3 1 5 d 2 - 3 3 5 e 2 2 - 2 5 xi\u2032\u2032 4 2 3 2 or 3 5 sj\u2032\u2032 0 0 0 0 2 or 3\nWe have the following scores of the candidates: p has one point (because of the members of Xcand), d has two points (because of p), e has two points (because of p, d, and the members of Xcand), the members of Xcand have two points each (because of d), and the members of Scand have zero points each (because of all the other candidates).\nIt is easy to verify that if there is a set cover for I of size h, then deleting the set candidates corresponding to the cover deletes all the members of Xcand and ensures that p has three points, whereas d has only two. In effect, d certainly is not a winner.\nNow consider the other direction. Since deleting a candidate can never decrease the score of any remaining candidate, the only way of making d lose is to increase some remaining candidate\u2019s score.\nSince for each candidate other than p, at least three voters prefer d to this candidate, only p has any chance of getting score higher than d. For this to happen, we need to ensure that all members of Xcand disappear. As in the previous set-embedding proofs, this is possible to do by deleting at most h candidates only if there is a set cover of size at most h for I ."}, {"heading": "E Signature Technique for Destructive Control", "text": "We now move on to our positive results obtained via the signatures technique. In this section we consider t-Approval and t-Veto elections only. We let d denote the despised candidate which we want to preclude from winning the election. Without loss of generality, we assume that d is a winner in the original election.\nWe observe that for given a candidate p 6= d, for a specific vote, an arbitrary candidate c /\u2208 {p, d} has only three possible relative positions compared to the candidates d and p (typically, the goal of candidate p will be to defeat the despised candidate): either c is in front of both, behind both, or in between them. Thus, given an election with n voters, each candidate can be characterized by a vector in [3]n. We call such vectors signatures. Let C\u2032 \u2286 C \u222aA be a subset\nof candidates (where C is the set of registered candidates and A is the set of unregistered ones; for the case of control by deleting candidates, we take A = \u2205).\nDefinition 4 (C\u2032-Signature). Consider an election (C \u222a A, V ) with n := \u2016V \u2016 and a set C\u2032 \u2286 C \u222a A of candidates. A size-n vector ~\u03b3 = (\u03b31, \u03b32, . . . , \u03b3n) \u2208 [3]n is a signature of candidate c \u2208 (C \u222a A) \\ C\u2032 if and only if for each voter vi \u2208 V , it holds that:\n\u03b3i =\n\n \n \n3 if for each c\u2032 \u2208 C\u2032, vi : c \u227b c\u2032, 1 if for each c\u2032 \u2208 C\u2032, vi : c\u2032 \u227b c,\n2 otherwise.\nWe will typically use {d, p}-signatures. In this context, the above definition might be somewhat confusing, especially that value 2 of a signature vector can come both from voters with preference orders satisfying p \u227b c \u227b d and from voters with preference orders satisfying d \u227b c \u227b p (where c is the candidate in whose signature we are interested). However, note that for a given i\u2019th voter, if \u03b3i = 2, then this i\u2019th voter ranks p, d, c (where c is an arbitrary candidate with signature ~\u03b3) always in the same way. This will be a key observation in the proof of Lemma 25.\nUsing the signature technique, we will see that for the non-combinatorial destructive cases, all our control problems under approval-based election rules are fixed parameter tractable (when parameterized by the number of voters). We remark that the techniques used here also work for Plurality and Veto rules, but both rules are simple enough that brute-force approaches can be used to show their fixed-parameter tractability (Corollary 6). However, we do use the signature technique to obtain fixed-parameter tractability results for the combinatorial destructive control by adding candidates under both Plurality and Veto (Corollary 5)."}, {"heading": "E.1 Adding Candidates", "text": "To obtain fixed-parameter tractability results for the case where candidates are added (with the parameterization by the number n of voters), we use the following general scheme:\n1. We guess one of the candidates and denote it by p. The role of this candidate is to defeat d, i.e., to obtain more points than d. Altogether there are m := \u2016C\u2016 + \u2016A\u2016 candidates and we repeat our algorithm for each possible choice of p.\n2. For each choice of p, we \u201ckernelize\u201d the input instance, that is, we bound the number of \u201crelevant\u201d candidates (or bundles) by a function of the parameter n, and search for an optimal solution in a brute-force manner over this \u201ckernel\u201d. This kind of kernelization is called Turing kernelization Binkele-Raible et al. [5], Scha\u0308fer et al. [31].\nThe idea of the kernelization is as follows. Say that we are dealing with destructive control by adding candidates under t-Approval (or t-Veto). For a given choice of p, adding exactly t (bundles of) candidates with the same {p, d}-signature has the same effect on the relative scores of p and d as adding more than t such (bundles of) candidates. In effect, it suffices to keep at most t (bundles of) candidates with each signature. This results in having at most t \u00b73n (bundles of) candidates. Before we proceed with the formal presentation of the fixed-parameter algorithms, we introduce some notions and some basic observations.\nDefinition 5 (Relevant registered candidates). Consider an instance of t-Approval-DCAC. We call a registered candidate relevant if this candidate receives at least one point. For the case of t-Veto-DCAC, we call a registered candidate relevant if this candidate receives at least one veto. We refer to those candidates that are not relevant as irrelevant.\nWe observe that for the case of adding candidates (in contrast to the case of deleting candidates), under t-Approval, an irrelevant registered candidate can never beat the despised candidate d, irrespective of our actions. Thus we remove the irrelevant candidates.\nAs for the case of t-Veto, it suffices to focus on the case where d receives at least one veto and so do all the other registered candidates (in effect, all candidates are relevant). This is so for two reasons: First, if d were not vetoed by any voter, d would be a winner irrespective of our actions (we would have a trivial \u201cno\u201d-instance). Second, if d were vetoed by some voter but some registered candidate c was not vetoed by anyone, d already would not be a winner of the election (we would have a trivial \u201cyes\u201d-instance). All in all, we have the following observation.\nObservation 1. For each fixed t, t \u2265 1, in nontrivial instances of t-Approval-DCAC and t-Veto-DCAC all the registered candidates are relevant.\nFor each t-Approval-DCAC instance (t-Veto-DCAC instance) with n voters, at most t \u00b7 n candidates are relevant. In the following sections we will show how to bound the number of unregistered candidates (separately for the non-combinatorial and combinatorial variants), using the notion of a signature. In effect, we will derive appropriate FPT algorithms.\nNon-Combinatorial Variant. We note that if there is a way to preclude the despised candidate from being a winner in a given t-Approval or t-Veto election, it suffices to consider settings where we add at most t candidates with each given signature. This is formalized in the following lemma.\nLemma 25. Consider an instance I := ((C, V ), A, d \u2208 C, k) of t-Approval-DCAC (of tVeto-DCAC), with the despised candidate d, and with some arbitrarily selected candidate p \u2208 C \u222aA. Let ~\u03b3 be some {d, p}-signature for this election. Adding t unregistered candidates with signature ~\u03b3 has the same effect on the relative scores of p and d as adding more than t candidates with this signature.\nProof. Let us focus on the case of t-Approval-DCAC. Let n be the number of voters in instance I . We have ~\u03b3 = (\u03b31, . . . , \u03b3n). Consider the i\u2019th voter.\n1. If \u03b3i = 3, then after adding t candidates with signature ~\u03b3, the i\u2019th voter will give 0 points to both p and d.\n2. If \u03b3i = 1, then the i\u2019th voter will give the same number of points to p (resp. to d) as prior to adding candidates, irrespective how many candidates with signature ~\u03b3 we add.\n3. If \u03b3i = 2, then either for each candidate c with signature ~\u03b3, the i\u2019th voter has preference order p \u227b c \u227b d, or for each candidate c with signature ~\u03b3, the i\u2019th voter has preference order d \u227b c \u227b p. In the first case, adding t (or more) candidates with signature ~\u03b3 will ensure that the i\u2019th voter gives zero points to d and gives the same number of points to p as prior adding the candidates. In the second case, the situation is the same, but with the roles of p and d swapped.\nSumming over the points provided by all the voters, this proves that adding t candidates with a given signature ~\u03b3 has the same effect on the relative scores of p and d as adding any more such candidates. The argument for the case of t-Veto-DCAC is analogous.\nUsing this lemma, we can bound the number of unregistered candidates by a function depending only on n.\nLemma 26. For each fixed integer t \u2265 1, t-Approval-DCAC and t-Veto-DCAC admit Turing kernels of size O(t \u00b7 3n).\nProof. Consider an instance I of t-Approval-DCAC (of t-Veto-DCAC). Let n be the number of voters in the instance. As per our previous discussion, w.l.o.g., we can assume that the instances are nontrivial and that all the registered candidates are relevant. Thus, there are at most t \u00b7 n registered candidates. By Lemma 25, for each choice of p it suffices to consider 3n {d, p}-signatures, and for each signature at most t candidates (the despised candidate d is given as part of the input). Altogether, for each choice of candidate p among the registered and unregistered candidates, we produce an instance of t-Approval-DCAC (of t-Veto-DCAC), with at most t \u00b7 n registered candidates and at most t \u00b7 3n unregistered ones (for each possible signature we keep up to t arbitrarily chosen unregistered candidates); in each instance we can add either the same number of candidates as in I , or one less, if p is an \u201cadded\u201d candidate already. It is possible to preclude d from winning in the original instance if and only if it is possible to do so in one of the produced instances.\nUsing a brute-force approach on top of the kernelization given by Lemma 26, it is possible to solve both t-Approval-DCAC and t-Veto-DCAC in FPT time. Straightforward application of a brute-force search to each instance produced by Lemma 26 gives running time O\u2217( ( 3n\nk\n)\n). However, it is easy to see that it never makes sense to add more than t\u00b7n candidates (intuitively, if we added more than t \u00b7 n candidates, at least one would be irrelevant and we could as well not add him or her). Thus we can assume that k \u2264 t \u00b7 n. In effect, the straight-forward bruteforce algorithm running on top of Lemma 26 has running time O\u2217((3n)t\u00b7n). However, if we are willing to sacrifice more space, then we can obtain significantly better running times.\nLemma 27. Plurality-DCAC can be solved in time O(m \u00b7 n \u00b7 2n), using O\u2217(2n) space.\nProof. Our algorithm uses a similar general structure as we used before. We assume that we are given a nontrivial instance, where all the registered candidates are relevant. First, we guess a candidate p whose goal is to defeat d and from now on we focus on a situation where we have both p and d, and the goal is to ensure that p gets more points than d. (If p is an unregistered candidate, we add p to the election, decrease the number of candidates that we can add by one, and proceed as if p was a registered candidate to begin with.)\nWe define a simplified notion of a candidate\u2019s signature. A signature for an unregistered candidate a is a size-n binary vector ~\u03c4 = (\u03c4i)i \u2208 {0, 1}n, such that:\n1. We have \u03c4i = 1 if the i\u2019th voter ranks a ahead of all the registered candidates.\n2. We have \u03c4i = 0 if the i\u2019th voter ranks a below some registered candidate.\nWe define the signature of a set A\u2032 of unregistered candidates analogously: Value 1 at a given position means that some candidate from A\u2032 is ranked ahead of all the registered candidates and value 0 means that some registered candidate is ranked ahead all members of A\u2032.\nThe crucial point of our algorithm is to compute a size-2n table ~Z := (Z~\u03c4 ) \u2208 [k + 1]2 n\n, such that for each signature ~\u03c4 \u2208 {0, 1}n, the Z~\u03c4 entry in the table is the size of the smallest subset A~\u03c4 of unregistered candidates whose signature is ~\u03c4 .\nWith this new notion of signatures, we maintain a size-2n table ~Z := (Z~\u03c4 ) \u2208 [k + 1]2 n which, for each signature ~\u03c4 \u2208 {0, 1}n, stores the minimum number Z~\u03c4 of unregistered candidates (k + 1 indicates impossibility), such that there is a size-Z~\u03c4 subset A(~\u03c4) \u2286 A \\ {p} with signature ~\u03c4 . We compute this table as follows (our algorithm is slightly more complicated than necessary for the case of Plurality rule, but we will also use it as a base for more involved settings):\n1. We initiate the table by setting Z~\u03c4 := 1 if there is at least one unregistered candidate with signature ~\u03c4 , and we set Z~\u03c4 := k + 1 otherwise (value k + 1 models the fact that it is impossible to achieve a given signature with at most k candidates).\n2. For each unregistered candidate a we perform the following operations (for each two signatures ~\u03c4 and ~\u03c4 \u2032, we define a \u201cmerged\u201d signature ~\u03c4\u2295~\u03c4 \u2032 so that ~\u03c4\u2295~\u03c4 \u2032 = (max{\u03c4i, \u03c4 \u2032i})i\u2208[n]; in other words, we apply the coordinate-wise max operator):\n(a) We compute a\u2019s signature ~\u03c4a.\n(b) We compute a new table Z \u2032, by setting, for each signature ~\u03c4 :\nZ \u2032~\u03c4 = min({Z~\u03c4} \u222a {Z~\u03c4 \u2032 + 1 | ~\u03c4 = ~\u03c4 \u2032 \u2295 ~\u03c4a}).\n(c) We copy the contents of Z \u2032 to Z. (At this point, for each signature ~\u03c4 , Z~\u03c4 is the number of candidates in the smallest set composed of the so-far processed candidates that jointly have this signature.)\n3. We pick a signature ~\u03c4 such that Z~\u03c4 has a minimum value and adding the candidate set A~\u03c4 that implements this signature ensures that p has more points that d (note that this last condition is easy to check: Given a signature ~\u03c4 , if the i\u2019th component \u03c4i is zero, then the i\u2019th voter gives one point to whoever this voter ranks first among the registered candidates; if \u03c4i is zero then the point goes to a candidate from A~\u03c4 , that is, neither to p or d). If Z~\u03c4 is smaller than the number of candidates that we can add, then we accept. Otherwise we reject (for this choice of p).\nLet us first consider the algorithm\u2019s running time. The most time-consuming part of the algorithm is the loop in the second step of the procedure computing the table Z. For each out of at most m candidates, computing Z \u2032 requires filling in O(2n) entries of the table. If we first copy the then-current contents of Z to Z \u2032, and then perform the remaining updates, this can be done in time O(m \u00b7 n \u00b7 2n). This dominates the running time of the remaining parts of the algorithm.\nNow let us consider the correctness of the algorithm. Assume that we have guessed the correct candidate p and that there is subset of unregistered candidates A\u2032 = {a1, . . . , a\u2113} such that p has more points than d after we add candidate from A\u2032, and \u2113 is smaller or equal to the number of candidates that we can add. If ~\u03c4 is the signature of the set A\u2032, it is easy to verify that the algorithm indeed computes value Z~\u03c4 \u2264 \u2113. Further, if the algorithm accepts, then it is only by finding a verified solution. Thus the algorithm is correct.\nWe can apply the above ideas to the case of t-Approval and t-Veto as well.\nLemma 28. For each fixed integer t \u2265 2, t-Approval-DCAC can be solved in min{O(t \u00b7 (3n)t\u00b7n), O(m \u00b7 n \u00b7 t \u00b7 (t+ 1)t\u00b7n)} time.\nProof. There are two means of solving our problem. We can either run the brute-force algorithm on top of Lemma 26, obtaining running time O(t \u00b7 3n t\u00b7n\n), or we can use a variant of the algorithm from Lemma 27. Below we describe how to adapt the algorithm from Lemma 27.\nWe use the same algorithm as in Lemma 27, but we use a somewhat more involved notion of a signature and of the merging operator \u2295. If we have n voters, then an unbounded signature of a set A\u2032 of unregistered candidates is an n-dimensional vector ~\u03c4 , whose i\u2019th entrance is a t-dimensional vector \u03c4i defined as follows: The j\u2019th entry of \u03c4i contains the number of candidates in A\u2032 that the i\u2019th voter prefers to all but j \u2212 1 registered candidates. Now a signature of a set A\u2032 is its unbounded signature where all entries greater than t are replaced by t. Altogether, there are (t+ 1)t\u00b7n signatures.\nGiven two signatures, ~\u03c4 \u2032 and ~\u03c4 \u2032\u2032, we define their merge, ~\u03c4 = ~\u03c4 \u2032 \u2295 ~\u03c4 \u2032\u2032, as follows: For each i, 1 \u2264 i \u2264 n, vector \u03c4i is computed by first calculating the component-wise sum of vectors \u03c4\u2032 i and \u03c4 \u2032\u2032 i, and then replacing with t each entry greater than t. It is easy to see that if A\u2032 and A\u2032\u2032 are two disjoint sets of candidates with signatures ~\u03c4A\u2032 and ~\u03c4A\u2032\u2032, then ~\u03c4A\u2032 \u2295 ~\u03c4A\u2032\u2032 is a signature of their union. (Note that In our algorithm we apply operator \u2295 to \u201csignatures of disjoint sets of candidates\u201d only.)\nIt is straightforward to verify that given a signature of a subset A\u2032 of unregistered candidates, we can compute the scores of candidates p and d. This suffices to describe our algorithm and to justify its correctness. The running time is O(m \u00b7 n \u00b7 t \u00b7 (t + 1)t\u00b7n) (it is calculated in the same way as in the proof of Lemma 27, except now we have more signatures and the components of the signatures are t-dimensional vectors).\nAdapting the algorithms in a straight-forward way (basically by inverting, or reversing, the signatures) used for Lemma 27 and Lemma 28, we can show a similar statement for veto-based voting rules.\nCorollary 4. For each fixed integer t \u2265 1, t-Veto-DCAC can be solved in min{O(t \u00b7 (3n)t\u00b7n), O(m \u00b7 n \u00b7 t \u00b7 (t+ 1)t\u00b7n)} time.\nCombinatorial Variant. The situation changes a little bit when instead of adding candidates we are adding bundles of candidates. We cannot bound the number of bundles for general approval-based (or veto-based) voting rules (where t \u2265 2) by using the signature techniques since bundles with the same signature but with different sizes may have different effects on the score difference between the despised candidate d and a specific guessed candidate p (indeed, the corresponding combinatorial variants are computationally intractable, as shown in Theorem 3). However, for Plurality and for Veto, only the first (or the last) position gets a point. This allows us to use our non-combinatorial algorithms.\nCorollary 5. Plurality-COMB-DCAC and Veto-COMB-DCAC are fixed-parameter tractable.\nProof. For the case of Plurality, it suffices to use, for example, the same algorithm as in Lemma 27, but with the following changes:\n1. For each choice of candidate p, we also consider each way of adding p to the election, if p was unregistered (p might belong to several different bundles and we try each possibility).\n2. Each unregistered candidate\u2019s signature is replaced by the signature of the set of candidates in its bundle.\nSince under Plurality each voter gives a point only to whoever this voter ranks first, this strategy suffices. The case of Veto rule is handled analogously."}, {"heading": "E.2 Deleting Candidates", "text": "The (Turing) kernelization approach for the case of adding candidates cannot be easily transferred to the case of deleting candidates. This is because we cannot upper-bound the number of candidates that have to be deleted in terms of the number n of the voters. However, applying our signature technique followed by casting the remaining task as an integer linear program (ILP), we can show fixed-parameter tractability (for our parameterization by the number of voters).\nWe now describe our approach. Let us fix a positive integer t and let ((C, V ), d, k) be an instance of t-Approval-DCDC, where V = (v1, v2, . . . , vn). (We focus on the case of tApproval and later we will argue how to adapt the results to apply to the case of t-Veto.) We guess a candidate p, whose role is to defeat the despised candidate d. For each such candidate p we do the following. First, we make an initial brute-force search: For each voter, we \u201cguess\u201d one of at most four possible choices of how d and p would gain points after our action of deleting candidates:\n1. choice one: only d receives one point,\n2. choice two: only p receives one point,\n3. choice three: both candidates receive one point, and\n4. choice four: neither p or d receive a point.\nWe record our guesses in vector ~\u03b4. For each guessed p and ~\u03b4, we check if giving the points according to our guesses in ~\u03b4 guarantees that p has more points than d. If so, we run an integer linear program to verify if it is at all possible to ensure that every voter gives points to candidate p and d as described by vector ~\u03b4, and to compute the smallest number of candidates we have to delete to ensure this. The complete procedure, for the case of t-Approval-DCDC, is given as Algorithm 1.\nLemma 29. For each fixed integer t \u2265 1, t-Approval-DCDC and t-Veto are both fixedparameter tractable when parameterized by the number of voters.\nProof. We start by considering the case of t-Approval-DCDC. The running time for Algorithm 1 is easy to verify: we guess a candidate p and a possible way of giving p and d points, followed by running an ILP. Therefore, the running time is O(m \u00b7 4n) times the cost of running the ILP. The ILP has 3n variables and (3n+2n) constraints. Thus, employing the famous result by Lenstra, Jr. [21], our algorithm runs in O\u2217(4n \u00b7 f(n)) where f is a function that describes the running time of the ILP solver and solely depends on n Lenstra, Jr. [21], Kannan [20].\nTo prove the correctness of the algorithm, it suffices to show the correctness of the ILP program for a given guess of p and ~\u03b4. First, the constraint in Line 25 ensures that we do not delete more candidates with a given {d, p}-signature than there are present in the election. The remaining signature verify that we can implement vector ~\u03b4. For each i, 1 \u2264 i \u2264 n, we verify if it is possible to implement guess \u03b4i:\nAlgorithm 1: FPT algorithm for t-Approval-DCDC. Input: ((C, V ), d, k) \u2014 input: an instance of t-Approval-DCDC p \u2014 a guessed candidate who is to defeat d\n1 foreach ~\u03b4 = (\u03b41, \u03b42, . . . , \u03b4n) \u2208 [4]n with |{i | \u03b4i = 1}| < |{i | \u03b4i = 2}| do 2 \u2014 Run ILP for each sane ~\u03b4 such that p beats d. 3 foreach i \u2208 [n] do 4 if SanityCheck (\u03b4i) = false then 5 Next ~\u03b4;\n6 if p has more points than d when p and d receive points as described by ~\u03b4 and there is a solution for ILP (~\u03b4) then 7 accept;\n8 reject;\n9 SanityCheck(\u03b4i)\n10 if \u03b4i = 1 and (vi : p \u227b d) then 11 \u2014 \u03b4i = 1: only d gains one point. 12 return false;\n13 if \u03b4i = 2 and (vi : d \u227b p) then 14 \u2014 \u03b4i = 2: only p gains one point. 15 return false;\n16 return true;\n17 ILP(~\u03b4 = (\u03b41, \u03b42, . . . , \u03b4n)): 18 Variables 19 \u2200~\u03b3 \u2208 [3]n : x~\u03b3 \u2014 # deleted candidates with {d, p}-signature ~\u03b3 20 Constants 21 \u2200~\u03b3 \u2208 [3]n : z~\u03b3 \u2014 # existing candidates with {d, p}-signature ~\u03b3 22 Objective 23\n\u2211 ~\u03b3 x~\u03b3 \u2264 k\n24 Constraints 25 \u2200~\u03b3 \u2208 [3]n : x~\u03b3 \u2264 z~\u03b3 26 \u2200i \u2208 [n] : 27 if \u03b4i = 1 or \u03b4i = 2 then 28 \u2014 vi : d \u227b p and only d gains one point, or 29 \u2014 vi : p \u227b d and only p gains one point 30\n\u2211 \u2200~\u03b3:\u03b3i=3 (z~\u03b3 \u2212 x~\u03b3) \u2264 t\u2212 1\n31 \u2211\n\u2200~\u03b3:\u03b3i=3\u2228\u03b3i=2 (z~\u03b3 \u2212 x~\u03b3) \u2265 t\u2212 1\n32 else if \u03b4i = 3 then 33 \u2014 Both d and p gain one point each 34\n\u2211 \u2200~\u03b3:\u03b3i=3\u2228\u03b3i=2 (z~\u03b3 \u2212 x~\u03b3) + 2 \u2264 t\n35 else 36 \u2014 No one gains one point 37\n\u2211 \u2200~\u03b3:\u03b3i=3 (z~\u03b3 \u2212 x~\u03b3) \u2265 t\n1. If \u03b4i = 1 (i.e., d gains a point from the i\u2019th voter but p does not) then according to our sanity check (SanityCheck) we have that vi prefers d over p. Thus, after the candidate deletion, d must be ranked in the first t positions (Line 30) and p must be ranked behind the t\u2019th position (Line 31).\nAlgorithm 2: A generic brute-force search algorithm for the FPT results. Input: (C, V ) \u2014 an election\n1 BruteForceSearch(a): 2 foreach~b \u2208 [2]n do 3 Delete all candidates in CollectCands (~b, a); 4 Do appropriate task;\n5 CollectCands(~b := (b1, b2, . . . , bn), a): 6 C\u2032 \u2190 \u2205; 7 foreach i \u2208 [n] do 8 if bi = 1 then 9 C\u2032 \u2190 C\u2032 \u222a {c \u2208 C \\ C\u2032 | vi : c \u227b a};\n10 return C\u2032;\n2. If \u03b4i = 2 which means that only p gains one point, then vi prefers p over d. Thus, after the candidate deletion, p must be ranked in the first t positions (Line 30) and d must be ranked behind the t\u2019th position (Line 31).\n3. If \u03b4i = 3, then both candidates gain one point each and must be ranked in the first t positions (Line 34) after the candidate deletion.\n4. Otherwise, both gain zero points and must be ranked behind the t\u2019th position (Line 37) after the candidate deletion.\nThis justifies the correctness of the ILP and completes the proof for the case of t-Approval. For the case of t-Veto, it suffices to use the same approach as for t-Approval, provided that we first reverse all preference orders and consider that a candidate is a winner if this candidate\u2019s score is the lowest (in essence, this is equivalent to replacing \u201cpoints\u201d with \u201cvetoes\u201d in the above reasoning)."}, {"heading": "F Brute-Force Search", "text": "In this section, we use brute-force search to obtain all of the XP results in this paper and some other FPT results. We note that all these algorithms can be easily adapted to solve the optimization versions of the corresponding problems."}, {"heading": "F.1 FPT Results", "text": "Let us now focus on Plurality and Veto rules. The main idea for the fixed-parameter tractability results in this section is to guess a subset of voters that will give a specific candidate one point under either Plurality or Veto. The point is that in the case of deleting candidates, after guessing this subset of voters, it is trivial to find the set of candidates to delete to \u201cimplement\u201d this guess. This is illustrated in the procedure CollectCands(\u00b7) given in Algorithm 2.\nLemma 30. Plurality-CCDC can be solved in O(m \u00b7 n \u00b7 2n) time, where n is the number of voters and m is the number of candidates in the input election.\nProof. Let I := ((C, V ), p, k) be a Plurality-CCDC instance. If I is a yes-instance, then after deleting at most k candidates, there must be a subset of voters who each give p one point, and no other candidate has more points than p. Observe that in order to let p gain one point from a voter, one has to delete all the candidates this voter prefers to p. Our algorithm, based on these observations, proceeds as follows.\nWe consider all 2n subsets of n voters. For each considered set V \u2032 of voters we do the following: For each voter v\u2032 in V \u2032, we delete all the candidates that v\u2032 prefers to p. In effect, all members of V \u2032 rank p first. Then, we keep on deleting all the candidates that have more than \u2016V \u2032\u2016 points (note that deleting some candidate that has more than \u2016V \u2032\u2016 may result in some other candidate exceeding this bound). If in the end no candidate has more than \u2016V \u2032\u2016 points and we deleted at most k candidates, we accept. Otherwise, we proceed to the next subset of voters. If we did not accept after going over all subsets of voters, we reject.\nTo see why the algorithm is correct, note that whenever it accepts, it has just constructed a correct solution. On the other hand, if there is a correct solution in which, after deleting the candidates, p gets points exactly from the voters in some subset V \u2032, then it is easy to see that the algorithm will accept when considering this subset. Establishing the running time is straightforward.\nIt is straightforward to see how to adapt the algorithm from the proof of Lemma 30 to the destructive case. In essence, it suffices to try all choices of a candidate p whose goal is to defeat the despised candidate d and for each such choice guess a subset of voters that are to give points to p. If after deleting the candidates that these voters prefer to p (assuming that neither of them prefers d to p) the despised candidate d has fewer points than p, then we accept. In the destructive case there is no need to have the final loop of deleting candidates scoring higher than p.\nCorollary 6. Plurality-DCDC can be solved in O(m2 \u00b7 n \u00b7 2n) time, where n is the number of voters and m is the number of candidates in the input election.\nLemma 31. Veto-DCDC can be solved in O(m \u00b7n \u00b7 2n) time, where n is the number of voters and m is the number of candidates in the input election.\nProof. We use almost the same approach as for Lemma 30. First, we guess candidate p whose goal is to have fewer vetoes than d. Deleting candidates can only increase the number of vetoes a remaining candidate has. Thus, our algorithm proceeds as follows.\nWe consider every subset V \u2032 of voters that prefer p to d in the election. For each voter v\u2032 in the guessed subset, we delete all the candidates that this voter ranks below d (by choice of V \u2032, p is never deleted). If in effect d has more vetoes than p, we accept. Otherwise we try the next subset of voters. If we do not accept after processing all subsets of voters, we reject.\nVerifying the running time and the correctness of this algorithm is immediate.\nF.2 XP Results\nIn this section, we establish XP results for all our W[1]-hard problems. This implies that if the number of voters is a constant, the problems are polynomial-time solvable.\nLemma 32. For each fixed integer t, t \u2265 1, and for each control type K \u2208 {CCAC,CCDC}, t-Approval-K and t-Veto-K can be solved in time O\u2217(mtn), where m is the number of candidates and n is the number of voters.\nProof. We consider the CCAC and the CCDC cases jointly, in parallel for both t-Approval and t-Veto. Our algorithm first guesses for each voter the set of t candidates that this voter will rank first (for the case of t-Approval) or last (for the case of t-Veto). There are O(mtn) possible different guesses. For each guess, for each voter we verify which candidates have to be added (for the case of CCAC) or deleted (for the case of DCAC) to ensure that the voter ranks the guessed t candidates on top. If it suffices to add/delete k candidates to implement the guess, and in effect of implementing the guess our preferred candidate is a winner, we accept. Otherwise we proceed to the next guess. If no guess leads to acceptance, we reject.\nEstablishing the correctness and the running time of the algorithm is immediate.\nLemma 33. For each fixed integer t, t \u2265 1, and each control type K \u2208 {CCAC,DCAC}, t-Approval-K and t-Veto-K can be solved in time O\u2217(m2tn), where m is the number of candidates and n is the number of voters.\nProof. We use the same approach as described in the proof of Lemma 32, but in addition to guessing the first t candidates for each vote, we also guess for each added candidate c the candidate to whose bundle c belongs."}, {"heading": "G Miscellaneous Results", "text": "Theorem 8. Maximin-COMB-DCAC is polynomial-time solvable.\nProof. It was shown by Faliszewski et al. [16] that Maximin-DCAC is polynomial-time solvable. The same strategy can be applied for the combinatorial case as well.\nThe algorithm is very simple, and can be described as follows: We guess up to two bundles of candidates, add them to the election, and check if the despised candidate d is no longer a winner, if so, we accept and otherwise we reject.\nTo see why this simple algorithm is correct, consider a solution. If the solution consists of at most two bundles, then we are done. Otherwise, let us take a closer look at the solution. It is clear that in the solution d is not a winner, therefore, there must be at least one other candidate p that has higher score than d. Consider some bundle bp in the solution which includes p (indeed, there might be several such bundles, and we can choose any one of them arbitrarily; it is also possible that p is present in the original election, in which case we take bp to be an \u201cempty\u201d bundle). Further, consider some candidate z such that the Maximin score of candidate d in the election E\u2032 resulting from adding candidates is exactly NE\u2032(d, z). There may be several such candidates and we choose one arbitrarily. Finally, we choose an arbitrary bundle bz from the solution that includes z (in fact, it is possible that z is present in the original election, in which case we take bz to be an \u201cempty\u201d bundle).\nIt is clear that p defeats d in the solution containing only bundles bp and bz (if either of these bundles is \u201cempty\u201d, we simply disregard it). Thus each \u201cyes\u201d-instance of MaximinDCAC has a solution that consists of at most two bundles and, so, it is enough to guess and test add at most two bundles."}], "references": [{"title": "How hard is it to control an election", "author": ["III J. Bartholdi", "C. Tovey", "M. Trick"], "venue": "Mathematical and Computer Modeling,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1992}, {"title": "Parameterized complexity of candidate control in elections and related digraph problems", "author": ["N. Betzler", "J. Uhlmann"], "venue": "Theoretical Computer Science, 410(52):43\u201353,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2009}, {"title": "Parameterized computational complexity of Dodgson and Young elections", "author": ["N. Betzler", "J. Guo", "R. Niedermeier"], "venue": "Information and Computation, 208(2):165\u2013177,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "Studies in computational aspects of voting\u2014a parameterized complexity perspective", "author": ["N. Betzler", "R. Bredereck", "J. Chen", "R. Niedermeier"], "venue": "The Multivariate Algorithmic Revolution and Beyond, volume 7370 of LNCS, pages 318\u2013363. Springer-Verlag,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2012}, {"title": "Kernel(s) for problems with no kernel: On out-trees with many leaves", "author": ["D. Binkele-Raible", "H. Fernau", "F.V. Fomin", "D. Lokshtanov", "S. Saurabh", "Y. Villanger"], "venue": "ACM Transactions on Algorithms, 8(4):38,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2012}, {"title": "CP-nets: A tool for representing and reasoning with conditional ceteris paribus preference statements", "author": ["C. Boutilier", "R. Brafman", "C. Domshlak", "H. Hoos", "D. Poole"], "venue": "Journal of Artificial Intelligence Research, 21:135\u2013191,", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2004}, {"title": "It only takes a few: on the hardness of voting with a constant number of agents", "author": ["F. Brandt", "P. Harrenstein", "K. Kardel", "H.G. Seedig"], "venue": "Proceedings of the 12th International Conference on Autonomous Agents and Multiagent Systems (AAMAS \u201913), pages 375\u2013 382,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2013}, {"title": "Prices matter for the parameterized complexity of shift bribery", "author": ["R. Bredereck", "J. Chen", "P. Faliszewski", "A. Nichterlein", "R. Niedermeier"], "venue": "Proceedings of the 28th AAAI Conference on Artificial Intelligence (AAAI \u201914), pages 1398\u20131404, July", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2014}, {"title": "Combinatorial voter control in elections", "author": ["J. Chen", "P. Faliszewski", "R. Niedermeier", "N. Talmon"], "venue": "Proceedings of the 39th International Symposium on Mathematical Foundations of Computer Science, pages 153\u2013164, Aug.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2014}, {"title": "Multivariate complexity analysis of swap bribery", "author": ["B. Dorn", "I. Schlotter"], "venue": "Algorithmica, 64(1):126\u2013151,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2012}, {"title": "Fundamentals of Parameterized Complexity", "author": ["R.G. Downey", "M.R. Fellows"], "venue": "Springer- Verlag,", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2013}, {"title": "Rank aggregation methods for the web", "author": ["C. Dwork", "R. Kumar", "M. Naor", "D. Sivakumar"], "venue": "Proceedings of World Wide Web Conference (WWW-2001), pages 613\u2013622, Mar.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2001}, {"title": "Control complexity in Bucklin and Fallback voting", "author": ["G. Erd\u00e9lyi", "M. Fellows", "J. Rothe", "L. Schend"], "venue": "Technical Report arXiv:1103.2230 [cs.CC], Aug.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Llull and Copeland voting computationally resist bribery and constructive control", "author": ["P. Faliszewski", "E. Hemaspaandra", "L. Hemaspaandra", "J. Rothe"], "venue": "Journal of Artificial Intelligence Research, 35:275\u2013341,", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2009}, {"title": "Using complexity to protect elections", "author": ["P. Faliszewski", "E. Hemaspaandra", "L. Hemaspaandra"], "venue": "Communications of the ACM, 53(11):74\u201382,", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2010}, {"title": "Multimode control attacks on elections", "author": ["P. Faliszewski", "E. Hemaspaandra", "L. Hemaspaandra"], "venue": "Journal of Artificial Intelligence Research, 40:305\u2013351,", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2011}, {"title": "Parameterized Complexity Theory", "author": ["J. Flum", "M. Grohe"], "venue": "Springer-Verlag,", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2006}, {"title": "Anyone but him: The complexity of precluding an alternative", "author": ["E. Hemaspaandra", "L. Hemaspaandra", "J. Rothe"], "venue": "Artificial Intelligence, 171(5\u20136):255\u2013285,", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2007}, {"title": "Schulze and ranked-pairs voting are fixedparameter tractable to bribe, manipulate, and control", "author": ["L. Hemaspaandra", "R. Lavaee", "C. Menton"], "venue": "Proceedings of the 12th International Conference on Autonomous Agents and Multiagent Systems (AAMAS \u201913), pages 1345\u20131346, May", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2013}, {"title": "Minkowski\u2019s convex body theorem and integer programming", "author": ["R. Kannan"], "venue": "Mathematics of Operations Research, 12(3):415\u2013440,", "citeRegEx": "20", "shortCiteRegEx": null, "year": 1987}, {"title": "Integer programming with a fixed number of variables", "author": ["H. Lenstra", "Jr."], "venue": "Mathematics of Operations Research,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 1983}, {"title": "Parameterized complexity of control problems in Maximin election", "author": ["H. Liu", "D. Zhu"], "venue": "Information Processing Letters, 110(10):383\u2013388,", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2010}, {"title": "Parameterized computational complexity of control problems in voting systems", "author": ["H. Liu", "H. Feng", "D. Zhu", "J. Luan"], "venue": "Theoretical Computer Science, 410(27\u201329):2746\u20132753,", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2009}, {"title": "Controlling elections by replacing candidates: Theoretical and experimental results", "author": ["A. Loreggia", "N. Narodytska", "F. Rossi", "K. Venable", "T. Walsh"], "venue": "Proceedings of the 8th Multidisciplinary Workshop on Advances in Preference Handling, pages 61\u201366,", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2014}, {"title": "Bribery in voting over combinatorial domains is easy", "author": ["N. Mattei", "M. Pini", "F. Rossi", "K. Venable"], "venue": "Proceedings of the 11th International Conference on Autonomous Agents and Multiagent Systems (AAMAS \u201912), pages 1407\u20131408, June", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2012}, {"title": "The complexity of strategic behavior in multi-winner elections", "author": ["R. Meir", "A. Procaccia", "J. Rosenschein", "A. Zohar"], "venue": "Journal of Artificial Intelligence Research, 33:149\u2013178,", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2008}, {"title": "A constructive proof of Vizing\u2019s theorem", "author": ["J. Misra", "D. Gries"], "venue": "Information Processing Letters, 41(3):131\u2013133,", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1992}, {"title": "Invitation to Fixed-Parameter Algorithms", "author": ["R. Niedermeier"], "venue": "Oxford University Press,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2006}, {"title": "A complexity-of-strategic-behavior comparison between Schulze\u2019s rule and ranked pairs", "author": ["D. Parkes", "L. Xia"], "venue": "Proceedings of the 26th AAAI Conference on Artificial Intelligence (AAAI \u201912), pages 1429\u20131435, July", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2012}, {"title": "Challenges to complexity shields that are supposed to protect elections against manipulation and control: a survey", "author": ["J. Rothe", "L. Schend"], "venue": "Annals of Mathematics and Artificial Intelligence, 68(1\u20133):161\u2013193,", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2013}, {"title": "Parameterized computational complexity of finding small-diameter subgraphs", "author": ["A. Sch\u00e4fer", "C. Komusiewicz", "H. Moser", "R. Niedermeier"], "venue": "Optimization Letters, 6(5): 883\u2013891,", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2012}, {"title": "Strategy-proof voting rules over multi-issue domains with restricted preferences", "author": ["L. Xia", "V. Conitzer"], "venue": "Proceedings of the 6th International Workshop On Internet And Network Economics (WINE \u201910), pages 402\u2013414, Dec.", "citeRegEx": "32", "shortCiteRegEx": null, "year": 2010}], "referenceMentions": [{"referenceID": 0, "context": "Problem Plurality Veto t-Approval t-Veto R-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-CCDC FPT W[1]-h / XP W[1]-h / XP W[1]-h / XP R-DCAC FPT FPT FPT FPT R-DCDC FPT FPT FPT FPT", "startOffset": 49, "endOffset": 52}, {"referenceID": 0, "context": "Problem Plurality Veto t-Approval t-Veto R-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-CCDC FPT W[1]-h / XP W[1]-h / XP W[1]-h / XP R-DCAC FPT FPT FPT FPT R-DCDC FPT FPT FPT FPT", "startOffset": 61, "endOffset": 64}, {"referenceID": 0, "context": "Problem Plurality Veto t-Approval t-Veto R-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-CCDC FPT W[1]-h / XP W[1]-h / XP W[1]-h / XP R-DCAC FPT FPT FPT FPT R-DCDC FPT FPT FPT FPT", "startOffset": 73, "endOffset": 76}, {"referenceID": 0, "context": "Problem Plurality Veto t-Approval t-Veto R-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-CCDC FPT W[1]-h / XP W[1]-h / XP W[1]-h / XP R-DCAC FPT FPT FPT FPT R-DCDC FPT FPT FPT FPT", "startOffset": 85, "endOffset": 88}, {"referenceID": 0, "context": "Problem Plurality Veto t-Approval t-Veto R-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-CCDC FPT W[1]-h / XP W[1]-h / XP W[1]-h / XP R-DCAC FPT FPT FPT FPT R-DCDC FPT FPT FPT FPT", "startOffset": 108, "endOffset": 111}, {"referenceID": 0, "context": "Problem Plurality Veto t-Approval t-Veto R-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-CCDC FPT W[1]-h / XP W[1]-h / XP W[1]-h / XP R-DCAC FPT FPT FPT FPT R-DCDC FPT FPT FPT FPT", "startOffset": 120, "endOffset": 123}, {"referenceID": 0, "context": "Problem Plurality Veto t-Approval t-Veto R-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-CCDC FPT W[1]-h / XP W[1]-h / XP W[1]-h / XP R-DCAC FPT FPT FPT FPT R-DCDC FPT FPT FPT FPT", "startOffset": 132, "endOffset": 135}, {"referenceID": 0, "context": "R-COMB-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-COMB-CCDC para-NP-h (1) para-NP-h (1) para-NP-h (1) para-NP-h (1) R-COMB-DCAC FPT FPT W[1]-h / XP ? / XP R-COMB-DCDC para-NP-h (3) para-NP-h (1) para-NP-h (2) para-NP-h (1)", "startOffset": 13, "endOffset": 16}, {"referenceID": 0, "context": "R-COMB-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-COMB-CCDC para-NP-h (1) para-NP-h (1) para-NP-h (1) para-NP-h (1) R-COMB-DCAC FPT FPT W[1]-h / XP ? / XP R-COMB-DCDC para-NP-h (3) para-NP-h (1) para-NP-h (2) para-NP-h (1)", "startOffset": 25, "endOffset": 28}, {"referenceID": 0, "context": "R-COMB-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-COMB-CCDC para-NP-h (1) para-NP-h (1) para-NP-h (1) para-NP-h (1) R-COMB-DCAC FPT FPT W[1]-h / XP ? / XP R-COMB-DCDC para-NP-h (3) para-NP-h (1) para-NP-h (2) para-NP-h (1)", "startOffset": 37, "endOffset": 40}, {"referenceID": 0, "context": "R-COMB-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-COMB-CCDC para-NP-h (1) para-NP-h (1) para-NP-h (1) para-NP-h (1) R-COMB-DCAC FPT FPT W[1]-h / XP ? / XP R-COMB-DCDC para-NP-h (3) para-NP-h (1) para-NP-h (2) para-NP-h (1)", "startOffset": 49, "endOffset": 52}, {"referenceID": 0, "context": "R-COMB-CCAC W[1]-h / XP W[1]-h / XP W[1]-h / XP W[1]-h / XP R-COMB-CCDC para-NP-h (1) para-NP-h (1) para-NP-h (1) para-NP-h (1) R-COMB-DCAC FPT FPT W[1]-h / XP ? / XP R-COMB-DCDC para-NP-h (3) para-NP-h (1) para-NP-h (2) para-NP-h (1)", "startOffset": 149, "endOffset": 152}, {"referenceID": 1, "context": "Table 1: The complexity of candidate control (constructive (CC) and destructive (DC), adding candidates (AC) and deleting candidates (DC)) problems for varying voting rules R parameterized by the number of voters (for t-Approval and t-Veto we mean t \u2265 2; for Copeland, we mean 0 \u2264 \u03b1 \u2264 1; notice that the results by Betzler and Uhlmann [2] hold only for \u03b1 \u2208 {0, 1}).", "startOffset": 335, "endOffset": 338}, {"referenceID": 15, "context": "[16, 14], those marked with \u2665 are due to Loreggia et al.", "startOffset": 0, "endOffset": 8}, {"referenceID": 13, "context": "[16, 14], those marked with \u2665 are due to Loreggia et al.", "startOffset": 0, "endOffset": 8}, {"referenceID": 23, "context": "[24], and those marked with \u2660 follow from the work of Betzler and Uhlmann for \u03b1 \u2208 {0, 1} and are due to this paper for the remaining values.", "startOffset": 0, "endOffset": 4}, {"referenceID": 8, "context": "[9], who introduced combinatorial voter control.", "startOffset": 0, "endOffset": 3}, {"referenceID": 11, "context": "[12] argued that one can build a web meta-search engine that queries several other search engines (the few voters) regarding a given query, aggregates their rankings of the web pages (the many candidates), and outputs the consensus ranking.", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "Our results (see Table 1; formal definitions follow in the next section) are of four types (with the exception of t-Veto-Comb-DCAC which is only in XP): for each of our problems we show that it either is in P, is in FPT, is W[1]-hard but has an XP-algorithm, or is paraNP-hard (in each case the parameter is the number of voters).", "startOffset": 225, "endOffset": 228}, {"referenceID": 0, "context": "The third kind is less positive (W[1]-hardness precludes existence of FPT algorithms, but membership in XP means that there are algorithms that are polynomial-time if the number of voters is a constant).", "startOffset": 34, "endOffset": 37}, {"referenceID": 0, "context": "[1], who were later followed by numerous researchers, including, e.", "startOffset": 0, "endOffset": 3}, {"referenceID": 17, "context": "[18], Meir et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "[26], and many others (we point the reader to the survey by Faliszewski et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[15] and to several recent papers on the topic Parkes and Xia [29], Erd\u00e9lyi et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "[15] and to several recent papers on the topic Parkes and Xia [29], Erd\u00e9lyi et al.", "startOffset": 62, "endOffset": 66}, {"referenceID": 12, "context": "[13], Rothe and Schend [30]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 29, "context": "[13], Rothe and Schend [30]).", "startOffset": 23, "endOffset": 27}, {"referenceID": 3, "context": "[4]), where typical parameters include the solution size (e.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "For the solution size as the parameter, control problems usually turn out to be hard Betzler and Uhlmann [2], Liu et al.", "startOffset": 105, "endOffset": 108}, {"referenceID": 22, "context": "[23], Liu and Zhu [22].", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[23], Liu and Zhu [22].", "startOffset": 18, "endOffset": 22}, {"referenceID": 15, "context": "[16] and by Hemaspaandra et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[19]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "However, so far, only Betzler and Uhlmann [2] considered a control problem parameterized by the number of voters (for the Copeland rule), and Brandt et al.", "startOffset": 42, "endOffset": 45}, {"referenceID": 6, "context": "[7] showed NP-hardness results of several winner determination problems even for constant number of voters.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3]; Dorn and Schlotter [10] Dorn and Schlotter [10]; Bredereck et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "[3]; Dorn and Schlotter [10] Dorn and Schlotter [10]; Bredereck et al.", "startOffset": 24, "endOffset": 28}, {"referenceID": 9, "context": "[3]; Dorn and Schlotter [10] Dorn and Schlotter [10]; Bredereck et al.", "startOffset": 48, "endOffset": 52}, {"referenceID": 7, "context": "[8] Bredereck et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8]).", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9], who focused on voter control.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6], Xia and Conitzer [32], Mattei et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 31, "context": "[6], Xia and Conitzer [32], Mattei et al.", "startOffset": 22, "endOffset": 26}, {"referenceID": 24, "context": "[25].", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "2Naturally, we use the standard complexity-theoretic assumptions that P 6= NP and FPT 6= W[1].", "startOffset": 90, "endOffset": 93}, {"referenceID": 8, "context": "[9], we also consider combinatorial variants of our problems, where adding/deleting a single candidate automatically adds/deletes a whole group of other candidates.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "FPT \u2286 W[1] \u2286 W[2] \u2286 \u00b7 \u00b7 \u00b7 \u2286 XP.", "startOffset": 7, "endOffset": 10}, {"referenceID": 1, "context": "FPT \u2286 W[1] \u2286 W[2] \u2286 \u00b7 \u00b7 \u00b7 \u2286 XP.", "startOffset": 14, "endOffset": 17}, {"referenceID": 0, "context": "The classes W[1] and W[2] can be defined, for example, through their complete problems, MULTI-COLORED CLIQUE and SET COVER: W[1] and W[2] contain those problems that reduce to, respectively, MULTI-COLORED CLIQUE and SET COVER in the parameterized sense.", "startOffset": 13, "endOffset": 16}, {"referenceID": 1, "context": "The classes W[1] and W[2] can be defined, for example, through their complete problems, MULTI-COLORED CLIQUE and SET COVER: W[1] and W[2] contain those problems that reduce to, respectively, MULTI-COLORED CLIQUE and SET COVER in the parameterized sense.", "startOffset": 22, "endOffset": 25}, {"referenceID": 0, "context": "The classes W[1] and W[2] can be defined, for example, through their complete problems, MULTI-COLORED CLIQUE and SET COVER: W[1] and W[2] contain those problems that reduce to, respectively, MULTI-COLORED CLIQUE and SET COVER in the parameterized sense.", "startOffset": 125, "endOffset": 128}, {"referenceID": 1, "context": "The classes W[1] and W[2] can be defined, for example, through their complete problems, MULTI-COLORED CLIQUE and SET COVER: W[1] and W[2] contain those problems that reduce to, respectively, MULTI-COLORED CLIQUE and SET COVER in the parameterized sense.", "startOffset": 134, "endOffset": 137}, {"referenceID": 10, "context": "The textbooks on parameterized complexity theory offer more information [11, 17, 28].", "startOffset": 72, "endOffset": 84}, {"referenceID": 16, "context": "The textbooks on parameterized complexity theory offer more information [11, 17, 28].", "startOffset": 72, "endOffset": 84}, {"referenceID": 27, "context": "The textbooks on parameterized complexity theory offer more information [11, 17, 28].", "startOffset": 72, "endOffset": 84}, {"referenceID": 0, "context": "This is a technique used for establishing W[1]-hardness results.", "startOffset": 43, "endOffset": 46}, {"referenceID": 0, "context": "[1]; Hemaspaandra et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 17, "context": "[18]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "On the one hand, the results for analogous types of (non-combinatorial) control for these rules differ (for example, Plurality-CCDC is in FPT but Veto-CCDC is W[1]-hard; this is quite unexpected given the similarity and simplicity of Plurality and Veto), and, on the other hand, combinatorial and non-combinatorial control problems behave differently.", "startOffset": 160, "endOffset": 163}, {"referenceID": 0, "context": "For example, in combinatorial control, the deleting candidates case is para-NP-hard for all the rules, but the adding candidates case is either in FPT or W[1]-hard (but in XP).", "startOffset": 155, "endOffset": 158}, {"referenceID": 0, "context": "When parameterized by the number of voters, (1) for Plurality and Veto, DCAC and DCDC are both in FPT, (2) Plurality-CCAC and Veto-CCAC are both W[1]-hard, and (3) Plurality-CCDC is in FPT, while Veto-CCDC is W[1]-hard.", "startOffset": 146, "endOffset": 149}, {"referenceID": 0, "context": "When parameterized by the number of voters, (1) for Plurality and Veto, DCAC and DCDC are both in FPT, (2) Plurality-CCAC and Veto-CCAC are both W[1]-hard, and (3) Plurality-CCDC is in FPT, while Veto-CCDC is W[1]-hard.", "startOffset": 210, "endOffset": 213}, {"referenceID": 0, "context": "We give a reduction from the W[1]-hard problem MULTICOLORED CLIQUE parameterized by the clique order.", "startOffset": 30, "endOffset": 33}, {"referenceID": 0, "context": "This means that in the proof that Veto-CCAC is W[1]-hard, the election has fewer candidates than voters, even after adding the candidates (and keep in mind that the number of voters is the parameter!).", "startOffset": 48, "endOffset": 51}, {"referenceID": 0, "context": "When parameterized by the number of voters, for Plurality and Veto, (1) COMBDCAC is in FPT, (2) COMB-CCAC is W[1]-hard, and (3) COMB-CCDC and COMB-DCDC are para-NP-hard.", "startOffset": 110, "endOffset": 113}, {"referenceID": 0, "context": "For t-Approval and t-Veto with t \u2265 2, there are fewer surprises and patterns are more clearly visible: In the non-combinatorial setting, constructive controls are W[1]-hard and the destructive ones are in FPT.", "startOffset": 164, "endOffset": 167}, {"referenceID": 0, "context": "When parameterized by the number of voters, for each fixed integer t \u2265 2, for t-Approval and t-Veto, (1) (COMB)-CCAC, and CCDC are W[1]-hard, (2) DCAC and DCDC are in FPT, (3) COMB-CCDC and COMB-DCDC are para-NP-hard, and (4) t-ApprovalCOMB-DCAC is W[1]-hard.", "startOffset": 132, "endOffset": 135}, {"referenceID": 0, "context": "When parameterized by the number of voters, for each fixed integer t \u2265 2, for t-Approval and t-Veto, (1) (COMB)-CCAC, and CCDC are W[1]-hard, (2) DCAC and DCDC are in FPT, (3) COMB-CCDC and COMB-DCDC are para-NP-hard, and (4) t-ApprovalCOMB-DCAC is W[1]-hard.", "startOffset": 250, "endOffset": 253}, {"referenceID": 0, "context": "We conclude our discussion by claiming that in each of the W[1]-hard cases discussed in this section we can, indeed, provide an XP algorithm.", "startOffset": 60, "endOffset": 63}, {"referenceID": 0, "context": "Instead of FPT and W[1]-hardness results, we obtain polynomial-time algorithms and para-NP-hardness results.", "startOffset": 20, "endOffset": 23}, {"referenceID": 23, "context": "[24], Copeland Faliszewski et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "[14], and Maximin ( Faliszewski et al.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[16]).", "startOffset": 0, "endOffset": 4}, {"referenceID": 1, "context": "For constructive candidate control, para-NP-hardness was already known for Copeland and Copeland Betzler and Uhlmann [2] and we establish it for the remaining values of \u03b1 and for Borda and Maximin (in the latter case, only for CCAC; CCDC is known to be in P).", "startOffset": 117, "endOffset": 120}, {"referenceID": 26, "context": "We decompose E(G) into four disjoint matchings (this is possible due to the computational variant of the classic graph-coloring result by Misra and Gries [27]) and rename the edges so that for each l, 1 \u2264 l \u2264 4, the l\u2019th of these matchings is E = {e 1 , .", "startOffset": 154, "endOffset": 158}, {"referenceID": 0, "context": "[1] J.", "startOffset": 0, "endOffset": 3}, {"referenceID": 1, "context": "[2] N.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] N.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[4] N.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5] D.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6] C.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7] F.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8] R.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9] J.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "[10] B.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[11] R.", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[12] C.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[13] G.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "[14] P.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[15] P.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[16] P.", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "[17] J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[18] E.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[19] L.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[20] R.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[21] H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[22] H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "[23] H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[24] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "[25] N.", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "[26] R.", "startOffset": 0, "endOffset": 4}, {"referenceID": 26, "context": "[27] J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 27, "context": "[28] R.", "startOffset": 0, "endOffset": 4}, {"referenceID": 28, "context": "[29] D.", "startOffset": 0, "endOffset": 4}, {"referenceID": 29, "context": "[30] J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 30, "context": "[31] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 31, "context": "[32] L.", "startOffset": 0, "endOffset": 4}, {"referenceID": 0, "context": "When parameterized by the number of voters, (1) for Plurality and Veto, DCAC and DCDC are both in FPT, (2) Plurality-CCAC and Veto-CCAC are both W[1]-hard, and (3) Plurality-CCDC is in FPT, while Veto-CCDC is W[1]-hard.", "startOffset": 146, "endOffset": 149}, {"referenceID": 0, "context": "When parameterized by the number of voters, (1) for Plurality and Veto, DCAC and DCDC are both in FPT, (2) Plurality-CCAC and Veto-CCAC are both W[1]-hard, and (3) Plurality-CCDC is in FPT, while Veto-CCDC is W[1]-hard.", "startOffset": 210, "endOffset": 213}, {"referenceID": 0, "context": "(2) The W[1]-hardness results for Plurality-CCAC and for Veto-CCAC are given in Lemmas 1 and 2.", "startOffset": 9, "endOffset": 12}, {"referenceID": 0, "context": "(3) The FPT result for Plurality-CCDC is given in Lemma 30 and the W[1]-hardness result for Veto-CCDC is given in Lemma 3.", "startOffset": 68, "endOffset": 71}, {"referenceID": 0, "context": "The W[1]-hardness results use the multi-colored clique technique and the FPT results use the signatures technique and the brute-force technique.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "When parameterized by the number of voters, for Plurality and Veto, (1) COMBDCAC is in FPT, (2) COMB-CCAC is W[1]-hard, and (3) COMB-CCDC and COMB-DCDC are para-NP-hard.", "startOffset": 110, "endOffset": 113}, {"referenceID": 0, "context": "(2) The W[1]-hardness results for COMB-CCAC under Plurality and Veto follows from Lemmas 1 and 2.", "startOffset": 9, "endOffset": 12}, {"referenceID": 0, "context": "The W[1]-hardness results use the multi-colored clique technique, the para-NP-hardness results use the set-embedding technique, and the FPT results use the signatures technique.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "When parameterized by the number of voters, for each fixed integer t \u2265 2, for t-Approval and t-Veto, (1) (COMB)-CCAC, and CCDC are W[1]-hard, (2) DCAC and DCDC are in FPT, (3) COMB-CCDC and COMB-DCDC are para-NP-hard, and (4) t-ApprovalCOMB-DCAC is W[1]-hard.", "startOffset": 132, "endOffset": 135}, {"referenceID": 0, "context": "When parameterized by the number of voters, for each fixed integer t \u2265 2, for t-Approval and t-Veto, (1) (COMB)-CCAC, and CCDC are W[1]-hard, (2) DCAC and DCDC are in FPT, (3) COMB-CCDC and COMB-DCDC are para-NP-hard, and (4) t-ApprovalCOMB-DCAC is W[1]-hard.", "startOffset": 250, "endOffset": 253}, {"referenceID": 0, "context": "The W[1]-hardness results for t-Approval-(COMB)-CCAC (t \u2265 2) are shown in Corollary 1.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "The W[1]-hardness results for t-Approval-CCDC (t \u2265 2) are shown in Lemmas 5 and 6.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "The W[1]-hardness results for t-Veto-(COMB)-CCAC (t \u2265 2) are shown in Corollary 2.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "The W[1]-hardness results for t-Veto-CCDC (t \u2265 2) are shown in Lemma 4.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "The W[1]-hardness result for t-Approval-COMB-DCAC is shown in Lemma 7.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "The W[1]-hardness results use the multi-colored clique technique, the para-NP-hardness results use the set-embedding technique, and the FPT results use the signatures technique.", "startOffset": 5, "endOffset": 8}, {"referenceID": 0, "context": "For each fixed integer t \u2265 1 and for each voting rule R \u2208 {t-Approval, t-Veto}, RCCAC (and therefore also R-COMB-CCAC) is W[1]-hard.", "startOffset": 123, "endOffset": 126}, {"referenceID": 0, "context": "For each fixed integer t \u2265 2 and for each voting rule R \u2208 {Veto, t-Approval, t-Veto}, R-CCDC is W[1]-hard.", "startOffset": 97, "endOffset": 100}, {"referenceID": 0, "context": "For each fixed integer t \u2265 2 and for each voting rule R \u2208 {t-Approval, t-Veto}, RCOMB-DCAC is W[1]-hard.", "startOffset": 95, "endOffset": 98}, {"referenceID": 0, "context": "Plurality-CCAC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 19, "endOffset": 22}, {"referenceID": 0, "context": "For each fixed integer t, t \u2265 2, t-Approval-CCAC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 53, "endOffset": 56}, {"referenceID": 0, "context": "Veto-CCAC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 14, "endOffset": 17}, {"referenceID": 0, "context": "For each fixed integer t, t \u2265 2, t-Veto-CCAC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 49, "endOffset": 52}, {"referenceID": 0, "context": "Veto-CCDC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 14, "endOffset": 17}, {"referenceID": 0, "context": "For each fixed integer t \u2265 1, t-Veto-CCDC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 46, "endOffset": 49}, {"referenceID": 0, "context": "2-Approval-CCDC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 20, "endOffset": 23}, {"referenceID": 0, "context": "For each fixed integer t, t \u2265 3, t-Approval-CCDC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 53, "endOffset": 56}, {"referenceID": 0, "context": "For each fixed integer t \u2265 2, t-Approval-COMB-DCAC is W[1]-hard, when parameterized by the number of voters.", "startOffset": 55, "endOffset": 58}, {"referenceID": 26, "context": "Further, it is possible to compute this coloring in polynomial time Misra and Gries [27].", "startOffset": 84, "endOffset": 88}, {"referenceID": 2, "context": "Thus, given an election with n voters, each candidate can be characterized by a vector in [3].", "startOffset": 90, "endOffset": 93}, {"referenceID": 2, "context": ", \u03b3n) \u2208 [3] is a signature of candidate c \u2208 (C \u222a A) \\ C if and only if for each voter vi \u2208 V , it holds that:", "startOffset": 8, "endOffset": 11}, {"referenceID": 4, "context": "[5], Sch\u00e4fer et al.", "startOffset": 0, "endOffset": 3}, {"referenceID": 30, "context": "[31].", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[21], our algorithm runs in O(4 \u00b7 f(n)) where f is a function that describes the running time of the ILP solver and solely depends on n Lenstra, Jr.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[21], Kannan [20].", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[21], Kannan [20].", "startOffset": 13, "endOffset": 17}, {"referenceID": 3, "context": ", \u03b4n) \u2208 [4]n with |{i | \u03b4i = 1}| < |{i | \u03b4i = 2}| do 2 \u2014 Run ILP for each sane ~\u03b4 such that p beats d.", "startOffset": 8, "endOffset": 11}, {"referenceID": 2, "context": ", \u03b4n)): 18 Variables 19 \u2200~\u03b3 \u2208 [3] : x~\u03b3 \u2014 # deleted candidates with {d, p}-signature ~\u03b3 20 Constants 21 \u2200~\u03b3 \u2208 [3] : z~\u03b3 \u2014 # existing candidates with {d, p}-signature ~\u03b3 22 Objective 23 \u2211 ~\u03b3 x~\u03b3 \u2264 k 24 Constraints 25 \u2200~\u03b3 \u2208 [3]n : x~\u03b3 \u2264 z~\u03b3 26 \u2200i \u2208 [n] : 27 if \u03b4i = 1 or \u03b4i = 2 then 28 \u2014 vi : d \u227b p and only d gains one point, or 29 \u2014 vi : p \u227b d and only p gains one point 30 \u2211 \u2200~\u03b3:\u03b3i=3 (z~\u03b3 \u2212 x~\u03b3) \u2264 t\u2212 1 31 \u2211 \u2200~\u03b3:\u03b3i=3\u2228\u03b3i=2 (z~\u03b3 \u2212 x~\u03b3) \u2265 t\u2212 1", "startOffset": 30, "endOffset": 33}, {"referenceID": 2, "context": ", \u03b4n)): 18 Variables 19 \u2200~\u03b3 \u2208 [3] : x~\u03b3 \u2014 # deleted candidates with {d, p}-signature ~\u03b3 20 Constants 21 \u2200~\u03b3 \u2208 [3] : z~\u03b3 \u2014 # existing candidates with {d, p}-signature ~\u03b3 22 Objective 23 \u2211 ~\u03b3 x~\u03b3 \u2264 k 24 Constraints 25 \u2200~\u03b3 \u2208 [3]n : x~\u03b3 \u2264 z~\u03b3 26 \u2200i \u2208 [n] : 27 if \u03b4i = 1 or \u03b4i = 2 then 28 \u2014 vi : d \u227b p and only d gains one point, or 29 \u2014 vi : p \u227b d and only p gains one point 30 \u2211 \u2200~\u03b3:\u03b3i=3 (z~\u03b3 \u2212 x~\u03b3) \u2264 t\u2212 1 31 \u2211 \u2200~\u03b3:\u03b3i=3\u2228\u03b3i=2 (z~\u03b3 \u2212 x~\u03b3) \u2265 t\u2212 1", "startOffset": 110, "endOffset": 113}, {"referenceID": 2, "context": ", \u03b4n)): 18 Variables 19 \u2200~\u03b3 \u2208 [3] : x~\u03b3 \u2014 # deleted candidates with {d, p}-signature ~\u03b3 20 Constants 21 \u2200~\u03b3 \u2208 [3] : z~\u03b3 \u2014 # existing candidates with {d, p}-signature ~\u03b3 22 Objective 23 \u2211 ~\u03b3 x~\u03b3 \u2264 k 24 Constraints 25 \u2200~\u03b3 \u2208 [3]n : x~\u03b3 \u2264 z~\u03b3 26 \u2200i \u2208 [n] : 27 if \u03b4i = 1 or \u03b4i = 2 then 28 \u2014 vi : d \u227b p and only d gains one point, or 29 \u2014 vi : p \u227b d and only p gains one point 30 \u2211 \u2200~\u03b3:\u03b3i=3 (z~\u03b3 \u2212 x~\u03b3) \u2264 t\u2212 1 31 \u2211 \u2200~\u03b3:\u03b3i=3\u2228\u03b3i=2 (z~\u03b3 \u2212 x~\u03b3) \u2265 t\u2212 1", "startOffset": 222, "endOffset": 225}, {"referenceID": 1, "context": "1 BruteForceSearch(a): 2 foreach~b \u2208 [2] do", "startOffset": 37, "endOffset": 40}, {"referenceID": 0, "context": "In this section, we establish XP results for all our W[1]-hard problems.", "startOffset": 54, "endOffset": 57}, {"referenceID": 15, "context": "[16] that Maximin-DCAC is polynomial-time solvable.", "startOffset": 0, "endOffset": 4}], "year": 2017, "abstractText": "We study the computational complexity of candidate control in elections with few voters (that is, we take the number of voters as a parameter). We consider both the standard scenario of adding and deleting candidates, where one asks if a given candidate can become a winner (or, in the destructive case, can be precluded from winning) by adding/deleting some candidates, and a combinatorial scenario where adding/deleting a candidate automatically means adding/deleting a whole group of candidates. Our results show that the parameterized complexity of candidate control (with the number of voters as the parameter) is much more varied than in the setting with many voters.", "creator": "LaTeX with hyperref package"}}}