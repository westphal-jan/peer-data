{"id": "1501.01086", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "6-Jan-2015", "title": "A Novel Design of a Parallel Machine Learnt Generational Garbage Collector", "abstract": "the generational garbage collection involves organizing the heap into different divisions of memory space in - order to filter long - lived objects arising from short - lived objects precisely through moving upwards the surviving object of each generation garbage tree collection cycle to another memory space continuously updating its age and reclaiming space quickly from the succeeding dead ones. the stated problem in this method is that the two longer an object is alive during its initial 50 generations the longer the resident garbage collector will have to deal with it by checking for its reachability from the root and promoting it, to incorporate other space divisions where as the ultimate goal of routing the garbage collector is to reclaim memory from unreachable objects at a minimal geologic time possible. this paper is a proposal developer of a method where the lifetime of every object getting into the heap will be predicted and will be placed in heap accordingly for the garbage collector to deal more with reclaiming space from dead garbage objects and less in promoting rescuing the live ones to the higher level.", "histories": [["v1", "Tue, 6 Jan 2015 06:04:45 GMT  (229kb)", "http://arxiv.org/abs/1501.01086v1", null]], "reviews": [], "SUBJECTS": "cs.PL cs.AI", "authors": ["vasanthakumar soundararajan"], "accepted": false, "id": "1501.01086"}, "pdf": {"name": "1501.01086.pdf", "metadata": {"source": "CRF", "title": "A Novel Design of a Parallel Machine Learnt Generational Garbage Collector", "authors": ["Vasanthakumar .S"], "emails": ["thisisvasanths@gmail.com"], "sections": [{"heading": null, "text": "DOI : 10.5121/cseij.2014.4602 11\nThe Generational Garbage collection involves organizing the heap into different divisions of memory space in-order to filter long-lived objects from short-lived objects through moving the surviving object of each generation\u2019s GC cycle to another memory space, updating its age and reclaiming space from the dead ones. The problem in this method is that, the longer an object is alive during its initial generations, the longer the garbage collector will have to deal with it by checking for its reachability from the root and promoting it to other space divisions, where as the ultimate goal of the GC is to reclaim memory from unreachable objects at a minimal time possible. This paper is a proposal of a method where the lifetime of every object getting into the heap will be predicted and will be placed in heap accordingly for the garbage collector to deal more with reclaiming space from dead object and less in promoting the live ones to the higher level."}, {"heading": "1. INTRODUCTION", "text": "The currently well-established generational garbage collector works in a way to filter the longlived objects in the heap from the short-lived ones, since 80-98% of the newly allocated objects will be dead within a few million instructions or before they meet their first GC cycle [2]. The Generational GC attains this by dividing the heap into different regions of memory spaces called generations. All newly created objects will be allocated with space in the generational space division meant for the new objects, which is comparatively very small to the generational space division for the old objects, in order to have a Young generation GC which will be faster and frequent. As the GC cycles occur, whenever the space in this young generation is filled up, the surviving objects from this GC will be promoted to another space division meant for the surviving objects. This space acts like a buffer space where the objects are aged by swapping live objects between sub-divisions and clearing the dean objects through each GC cycle. Ones the objects have attained a certain age they are moved from here to the space division meant for the old objects. By this way the heap will have a group of filtered objects which have survived to the old space and will be expected to age here. This space for Old objects is bigger than the other two and the garbage collection will take place here less frequently and takes more time comparatively.\nThe problem with this method is that the garbage collections here are focused on filtering out the longer living objects from the short-lived ones and so ends up spending considerable amount of time in dealing with the live objects. The ultimate goal of the garbage collection is to reclaim the space allocated to objects which are dead to get the space ready for newer objects. So every encounter with a live object is waste of computational time since these activities are carried out as\ngarbage collection is done. As the number of program threads increases, the delay due to garbage collection also increases, and the time spent in checking reachability for live objects and promoting them can turn to be a counter-productive activity.\nThis scenario of entities being created, aged and reclaimed when dead, caries the computational advantages of a quintessential subject for the heuristic prediction over the lifetime of entities in a particular domain [1, 39]. This paper is a proposal of a method in which the expected life time of the objects getting created in the heap can be calculated in parallel to the application and sorted in the live data structure from the root, so that when a garbage collection cycle is initiated, the GC will encounter only with dead objects almost all the time and comparatively a very less number of live objects. The objects which the GC would not encounter will be promoted in parallel, to generation spaces where they are highly likely to die. By this way the pause times can be greatly reduced at situations where the application usually has a large number of long-living objects in its heap."}, {"heading": "2. ASSUMPTIONS", "text": "Many different languages use automatic garbage collection as an integrated part of them. The Generational Garbage collection method has been implemented as a part of the JVM the .Net Framework and as part of many other languages as well. For feasibility of explanations, in this paper we will consider a java application running in a Sun JDK to be our subject. All our terminologies, and implementation details shall be in accordance to the JVM\u2019s Generation Garbage collection and JVM\u2019s Heap related for the rest of the paper. We will be using a sample java application named java2demo.jar as our subject to discuss the feasibility of prediction as the control flows for this application is very limited. Let us assume to have a JVM whose Garbage Collector code has been modified to inject a data retrieval module, which can log the details regarding objects creation, space allocation, current generation of an object, and reclamation. This particular injected module can be turn on or off when required by specifying the same as JVM arguments."}, {"heading": "3. SOLUTION PROPOSAL", "text": "There are three important phases in the solution proposed through this paper. They are, Prediction of object life time in heap, structuring of data to hold dead objects first and reclamation of space parallel to promotion of objects."}, {"heading": "3.1 Prediction", "text": "Computer programs are highly structured set of instructions and so a fully functional software application would have only a few finite different flows of execution. In the case of Object Oriented Programming, these control flows will determine which objects will be instantiated and which object\u2019s scope will be exited. These characteristics of software applications written in object oriented programming languages makes their objects creation pattern to be predictable in a given flow of execution. In this proposed method, the important module happens to be the prediction module. This a module which will run in parallel to the application threads and collects objects creation detail for a few initial test runs by injecting a data set retrieval code into the\ninjector codes will be purely testing intended and so the application\u2019s performance will be impacted due to the data collection retrieval for every object creation, promotion and reclamation. Once we have the test set in hand, the machine learning module will go through the test set and generates prediction data for each object, which will be the expected life time for the object in heap."}, {"heading": "3.2 Structuring Reachability Data", "text": "The traditional approach by which the garbage collector in JVM will differentiate the dead objects from the lives one is based on their reachability form the root. Thus for each object, the GC will be traversing from the root until it either encounters the object or reaches the point where further traversal is not possible. According to this proposed model, the Root will hold only two children. One child will serve as the root for all the objects which are highly like to die before they meet their first GC cycle and the other child will be serving as the root for all the objects highly like to live longer or at the least long enough to survive their first GC encounter."}, {"heading": "3.3 Parallel Reclamation and Promotion", "text": "Now, since we have two sub-roots under the main root, only one will be of the interest of the GC where objects residing are highly likely to be reclaimed of their space. Thus there will be one GC cycle running in parallel with another thread, which we shall call as the Object Promoter (OP). The OP will run through every child from its root where all the objects are expected to be alive. Here the OP will check for the expected life time of each object and will promote them accordingly to the respective generation space. If the OP encounters a dead object (which will occur often during the initial test runs to obtain the data set), the OP will act like a GC and reclaim its space."}, {"heading": "4. DATA COLLECTION AND ANALYSIS", "text": "In order to verify how feasible the prediction phase of this model can be implemented, we can use the java2demo.jar application, as our subject and collect data during its runtime regarding its objects lifetime and analyze it. Using the jmap tool which is an integrated part of Sun JDK we can retrieve the histogram of the heap at any point during the runtime of the application. Further using the JvisualVM tool which also an integral part of the JDk with its plugin visualGC, we can have a graphical depiction of the GC cycles and the objects promotion.\nThe jmap\u2019s \u2013histo and \u2013histo:live options can be used to get the list of class names, number of instances for each class name and their size in bytes for all the objects and only the live objects respectively. Using the jvisualVM we can learn when the GC cycle is taking place. A \u2013histo from jmap after each GC cycle, followed by a \u2013histo:live can give us enough data to understand that the number of live instances of a particular class after a particular GC cycle happens to be almost the same every other time we run the application with minor variation which is due to the interruptions from our jmap commands and jvisualvm.\nThe difference between two \u2013histo:live lists taken in consecutive GC , (i.e.) removing the old list\u2019s number of instances from the new list\u2019s number of instances will give us the number of\nfor every other run of the application. As an example, running the jmap \u2013histo after the first GC cycle gave me a set of results, a very few of them for comparison are as follows,\nAnd running jmap-histo after the first GC cycle during the second run of the application gave me the another set of results and the data for the same five classes are as follows,\nNow from the above data we can infer that the number of objects that are being formed, and number of objects surviving the Eden space will be the same for every run of the application at a given instance. Here, it happens to have a slight variation in the number of instances for classes which has huge number of instances and that is due to our interruptions, as mentioned earlier. On the other hand, the similarity is also mainly because the application has only minimal number of control flows in which it can progress. Hence the prediction of objects life time over these applications can be simple. Further for applications which are widely dynamic in their flow of control, for example an application that reacts in a different way to each different input from the user, the prediction can get tougher but still possible. The only difference will be the effect of presence of one object over the other will have to be taken into consideration. By which the presence of a given number of different instances can be used to predict the control flow of the application and then the creation and deletion of objects in that control flow. Such a scenario where one feature of an entity has a direct influence on another feature of the same entity, or another entity in the same domain, the prediction of data can be performed through probabilistic\ntheorems such as the Bayesian Network discussed in the next section."}, {"heading": "5. BAYESIAN NETWORK", "text": "Bayes' Theorem is a theorem of probability theory which can be seen as a way of understanding how, the probability that a theory is true; is affected by a given piece of evidence. It has been used in a wide variety of contexts, ranging from marine biology to the development of \"Bayesian\" spam blockers for email systems. The Bayesian network will be the right approach to this scenario, since our prediction in here is based on conditional probability (i.e.) the probability of event B to occur given that the an event A has occurred [5]. Here the event B refers to the survival of an object for a specific time, given that a number objects from another class already exist or the number of GC cycles spent or the same object has survived the Eden space etc."}, {"heading": "5.1 Features and Probability", "text": "Bayes' theorem expresses the conditional probability, or 'posterior probability', of an event A after B is observed in terms of the 'prior probability' of A, prior probability of B, and the conditional probability of B given A, denoted B |A. Bayes' theorem is valid in all common interpretations of probability.[6]\nBayes' theorem provides an expression for the conditional probability of A given B, which is\nThe features based on which the probability has to be calculated will depend on the feature data that can be retrieved from the heap during the run time of the application. As per our earlier assumption, let us assume that there are \u2018n\u2019 different features which can be recorded or calculated, during or after the runtime of the application from the data our injected code can retrieve during the initial few test runs. The features set will include features like the object\u2019s class name, depth of hierarchy from the root parent, number of same class\u2019s objects formed, number of same class\u2019s objects surviving the Eden space, size of the object, etc. For each of these features, the Bayes theorem will be used to calculate the posterior probability of the particular object to survive the generation is currently in.\nHere, Pr(Y|Fn) is the probability of an object to survive given that a feature meets a condition. Pr(Fn|Y) is the probability of the feature to meet the condition given that the object has survived.\nprobability of the feature to meet the conditions.\nFor example, taking each of the feature into consideration such as,\nF1 = depth of hierarchy F2 = className . . Fn = size\nThe probability of the object to survive this generation given that the feature Fx holds this\nparticular value can be calculated.\nFor features that hold static value such as the class name and depth of hierarchy, the\nprobability can be calculated just once, whereas for the dynamic ones such as the number\nof instances will have to be calculated for every GC cycle.\nHere, \u03c0(Xi) stands for the set of parents (direct ancestors) of Xi.\nBy constructing a Bayesian Network as proposed above, we will arrive at a Directed Acyclic Graph where nodes are variables and edges indicate casual influences. A Bayesian network implicitly defines a joint distribution.\nparticular generational space. On the whole for our implementation we will need to calculate this for an object only twice, i.e. the probability that an object will survive the Eden space, and the probability of an object to reach the tenured space."}, {"heading": "5.2 Threshold and Decision making", "text": "Since the Bayesian network will give us a probability of an object to survive a particular generation space or reach a particular generation space, the output will be a value between 0 and 1, inclusive. Now, we will have to find a threshold value which will be the deciding factor above which the object will be surviving or moving to a space, below which the object won\u2019t. This value can be a tunable factor which can be set, based on the performance of the algorithm over the application for improved results. But we need to consider the fact that a false prediction of an object to not to survive a generational space can be tolerated as the GC will anyway promote the object to the next generation of buffer space, But a false prediction of an object to survive a generation space cannot be tolerated as an \u2018about to be dead\u2019 object will be promoted which will cause further computational expenses. And so the threshold for this scenario will have to be generally high, for instance a threshold value of 0.8 will perform better than the threshold 0.55."}, {"heading": "6. PRECISION AND RECALL TRADE OFF", "text": "This prediction method proposed for the scenario has two cases of false predictions. One is a False Positive, which is that the algorithm predicts that the object in question will survive the space but it would turn out to die due to which we would promote a dead object. The second case\ncycle, in which case the GC will promote the object. Considering both the cases we can clearly decide that a False Negative is a tolerable scenario where as the False Positive cannot be tolerated. Thus we will have to tune the prediction module to have absolutely no False Positive which might give space to a few false negative. Such a prediction system is High Precision Classifier system.\nThis will be a tradeoff between the precision and recall of the classifier where we will choose to have higher Precision which will result in less recall. In order to set a classifier system to have higher precision we will have to assign a higher value to the threshold. For example, setting up the threshold to have a value of 0.8, the system will be a high precision classifier. By which the prediction module\u2019s confidence will be higher for a Positive prediction (i.e.) an object will survive the current GC cycle. This confidence will increase the reliability over the prediction module to predict objects survival."}, {"heading": "7. DATA STRUCTURING", "text": "This method of garbage collection with predicted life time of objects will need to have a slightly different implementation of the data structure used for to detect the dead objects from the live one. The traditional Generational GC will do this by checking the reachability of an object from the root. But in this case we will maintain a root node which has two child nodes, each one acting as a root for a map. One child will act as the root for objects which are highly likely to die in this current GC cycle, whereas the other child will act as the root for the objects which are highly likely to survive the current GC cycle. The child holding the objects which are about to die will be acting as the root for the GC , whereas the other child holding the objects about to be promoted will act as the root for the OP. This way, the GC will use a root where a very small set of objects are reachable, which are the ones predicted to die in the GC cycle and in turn survived (False Negatives). The OP will deal with the root from where almost all the reachable objects are. This will result in a big cut down of the GC cycle pauses which runs as a \u2018stop-the-world\u2019 process.\nOP\u2019s root. The OP will go through each object from the root and predict the life time of the objects. As the OP moves through the tree every object whose probability to survive the upcoming GC cycle is low will be made available from the GC root and removed reference from the OP root. Every dead object that the OP faces will be reclaimed of memory and every object which is likely to survive the GC cycle will be marked with its expected life time. The objects will also be sorted in a way that the ones with higher life time expectancy will be closer to the root than the ones which have less life time expectancy. During the GC cycle , the OP will run through the reachable objects from the OP root and promote the objects to their respective generational spaces where they are likely to die. Things under the GC root will be the same process as the traditional Generational Garbage Collection process."}, {"heading": "8. PARALLELIZATION OF PROCESSES", "text": "This Garbage Collection method has been designed to be suitable for implementation on multiple processor machines. For each application for which we plan to use this Predictive GC, we need to get a number of initial trial runs to obtain the data set to work on which number will be based on the complexity of the application. Once the data set has been acquired and processed, apart from the heavily reduced GC pause times, every other action in this proposed method of GC can be parallelized and performed with-out disturbing the run of the application threads. The OP can run in parallel with the GC since they don\u2019t share the same root and can promote the objects to the expected generational spaces where they are highly likely to be reclaimed of their spaces. The OP can also predict the life time of objects in parallel to the application threads."}, {"heading": "9. CONCLUSION", "text": "I have proposed the description of a Parallelized Machine Learnt Generational Garbage Collector which uses Bayesian Network to predict and manage the objects in the heap accordingly to reduce the time spent by the GC in dealing with live objects. This proposed model, when implemented is highly likely to result in reducing the work load of the GC in each generational phase as it will not deal with the live objects if the prediction is 100% accurate. The pause times will be greatly reduced in applications containing a large amount of live objects in their Eden and Survivor spaces. Since the Generational Garbage Collection is used along with many programming languages which are being used widely across the globe for application engineering, such a model can improve the performance of the GCs which in turn will reflect as a performance increment over the application. This model is based on the assumption that the application taken as a subject doesn\u2019t have much different control flows which affects the objects creation pattern. As a future enhancement to this paper, I will be carrying out a research to amend this model to be fit for predicting objects lifetime in a highly complex application with a large number of different control flows."}], "references": [{"title": "Infant mortality and generational garbage collection in SIGPLAN Notices", "author": ["Henry G. Baker"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 1993}, {"title": "Controlling garbage collection and heap growth to reduce the execution time of java applications in Proceedings of the OOPSLA\u201901", "author": ["Tim Brecht", "Eshrat Arjomandi", "Chang Li", "Hang Pham"], "venue": "Conference on Object Oriented Programming Systems Languages and Applications,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2001}, {"title": "Garbage collection in an uncooperative environment in Software\u2014Practice and Experience", "author": ["Hans-Juergen Boehm", "Mark Weiser"], "venue": null, "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1988}, {"title": "A novel design of a generational garbage collector", "author": ["W.U. Zaman", "S.A. Ahmad", "A. Abbas", "A. Qadeer"], "venue": "in Students Conference,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2002}, {"title": "A real-time garbage collector based on the lifetime of objects", "author": ["H. Lieberman", "C. Hewitt"], "venue": "Communications of the ACM 26, pp 419-429, June 1983.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1983}, {"title": "Learning Bayesian Network Classifier Based on Dependency Analysis and Hypothesis Testing in Intelligent Human-Machine Systems and Cybernetics (IHMSC)", "author": ["Sun Wenjing"], "venue": "Xidian Univ.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}], "referenceMentions": [{"referenceID": 0, "context": "This scenario of entities being created, aged and reclaimed when dead, caries the computational advantages of a quintessential subject for the heuristic prediction over the lifetime of entities in a particular domain [1, 39].", "startOffset": 217, "endOffset": 224}], "year": 2014, "abstractText": "The Generational Garbage collection involves organizing the heap into different divisions of memory space in-order to filter long-lived objects from short-lived objects through moving the surviving object of each generation\u2019s GC cycle to another memory space, updating its age and reclaiming space from the dead ones. The problem in this method is that, the longer an object is alive during its initial generations, the longer the garbage collector will have to deal with it by checking for its reachability from the root and promoting it to other space divisions, where as the ultimate goal of the GC is to reclaim memory from unreachable objects at a minimal time possible. This paper is a proposal of a method where the lifetime of every object getting into the heap will be predicted and will be placed in heap accordingly for the garbage collector to deal more with reclaiming space from dead object and less in promoting the live ones to the higher level.", "creator": "PScript5.dll Version 5.2.2"}}}