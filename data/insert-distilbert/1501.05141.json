{"id": "1501.05141", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "21-Jan-2015", "title": "An Algebra to Merge Heterogeneous Classifiers", "abstract": "in distributed classification, each learner observes its environment and deduces a classifier. as a learner has only a local view of its environment, classifiers can be exchanged among the learners and integrated, or merged, to improve accuracy. however, the operation of merging is not defined for most classifiers. furthermore, the classifiers that have preferred to be merged may be of different types in behavioral settings such as ad - hoc networks in which several generations of sensors may be creating classifiers. we introduce decision plan spaces as a framework for merging as possibly different classifiers. we formally study the merging operation as an algebra, and prove that it satisfies a desirable set of properties. the impact of time is discussed for the two main data mining settings. firstly, decision spaces can naturally potentially be found used with non - stationary distributions, such as the larger data collected by sensor networks, as the impact of a model decays over time. secondly, we introduce an approach for stationary distributions, such example as homogeneous databases partitioned over different learners, which ensures that all models have the same impact. we also present a method that uses storage flexibly to best achieve different types of decay for non - stationary distributions. finally, we show that the current algebraic approach developed for merging can also be used to analyze the behaviour of other operators.", "histories": [["v1", "Wed, 21 Jan 2015 11:42:58 GMT  (1076kb)", "https://arxiv.org/abs/1501.05141v1", "19 pages, 8 figures"], ["v2", "Thu, 22 Jan 2015 12:18:56 GMT  (1076kb)", "http://arxiv.org/abs/1501.05141v2", "19 pages, 8 figures"]], "COMMENTS": "19 pages, 8 figures", "reviews": [], "SUBJECTS": "cs.DM cs.LG", "authors": ["philippe j giabbanelli", "joseph g peters"], "accepted": false, "id": "1501.05141"}, "pdf": {"name": "1501.05141.pdf", "metadata": {"source": "CRF", "title": "An Algebra to Merge Heterogeneous Classifiers", "authors": ["Philippe J. Giabbanellia", "Joseph G. Petersb"], "emails": [], "sections": [{"heading": null, "text": "ar X\niv :1\n50 1.\n05 14\n1v 2\n[ cs\n.D M\n] 2\n2 Ja\nn 20\n15\nIn distributed classification, each learner observes its environment and deduces a classifier. As a learner has only a local view of its environment, classifiers can be exchanged among the learners and integrated, or merged, to improve accuracy. However, the operation of merging is not defined for most classifiers. Furthermore, the classifiers that have to be merged may be of different types in settings such as ad-hoc networks in which several generations of sensors may be creating classifiers. We introduce decision spaces as a framework for merging possibly different classifiers. We formally study the merging operation as an algebra, and prove that it satisfies a desirable set of properties. The impact of time is discussed for the two main data mining settings. Firstly, decision spaces can naturally be used with non-stationary distributions, such as the data collected by sensor networks, as the impact of a model decays over time. Secondly, we introduce an approach for stationary distributions, such as homogeneous databases partitioned over different learners, which ensures that all models have the same impact. We also present a method that uses storage flexibly to achieve different types of decay for non-stationary distributions. Finally, we show that the algebraic approach developed for merging can also be used to analyze the behaviour of other operators.\nKeywords: Model combination; Non-stationary distributions; Unsupervised meta-learning"}, {"heading": "1. Introduction", "text": "A wide variety of systems, such as sensor and peer-to-peer networks, are composed of independent entities. These entities record observations from their local environments, for example as databases of observed tuples. The entities often have to adapt to future changes, but their local views may be too restricted to compute classifiers that can make accurate predictions. Therefore, a global classifier that can be used to predict global trends is often desirable. Entities might not compute a global classifier by exchanging their datasets directly, because of security concerns, or because the large quantity of information could overwhelm limited resources such as local storage or battery power. Thus, the global classifier has to be realized by combining the classifiers deduced by the entities. The need to combine classifiers also arises in other situations. Several examples illustrate the need to combine classifiers in Section 2, and others can be found in the series of annual International Workshops on Multiple Classifier Systems [1].\nDifferent ways have been proposed to realize a global classifier (e.g., ensemble classifiers, meta-learning). These ways have been grouped differently, but a key distinction can be found between fusion and selection ( [17], p. 106). Intuitively, classifiers are specialized when they are restricted to instances with specific features: when a new instance comes in, the appropriate classifier is thus selected. Alternatively, classifiers may be designed for instances with the same features, and they are then fused. In this paper, we are concerned with the intermediate case: classifiers can have an overlapping feature space, but some may be more competent in parts of that space than others. This is typically reflected in approaches that weight the outputs of the classifiers depending on the instance being classified [17]. To emphasize that our approach is intermediate, we say that we merge classifiers instead of selecting or fusing them.\nMerging classifiers is a complicated operation for several reasons. Firstly, classifiers can be of different structures, such as decision trees and support vector machines. Secondly, conflicts arise when classifiers differ on their predictions. Solving these conflicts either uses heuristics (e.g., pure meta-learning [6, 28, 12]), or requires access to the\n\u2217Corresponding author. Phone: +44 (0)1223 330315, FAX: +44 (0)1223 330316 Email addresses: pg438@cam.ac.uk (Philippe J. Giabbanelli), peters@cs.sfu.ca (Joseph G. Peters)\ndataset used to train the classifiers, which is undesirable in settings such as sensor networks due to the high cost of transmission. In this paper, we consider the case of meta-learning in which the classifiers are potentially of different types. The concept of meta-learning and the precise types are described in Section 3.\nMost of the previously proposed solutions have been application-specific and were validated through experiments, leading researchers to suggest that questions about combining classifiers are (still) open \u201cbecause we do not yet have a scientific understanding of the classifier combination mechanisms\u201d [16]. Consequently, our approach emphasizes the formal aspects. In Section 4, we introduce decision spaces as an algebraic framework to investigate the behaviour of distributed data mining algorithms in which learners propagate only local models and not local observations. This framework can be used in a large variety of cases since it allows the combination of different models (e.g., decision trees, rule sets, support vector machines with linear kernels) and does not rely on homogeneous observations. In Section 5, we present a heuristic merge operator that solves all conflicts between models without using their observations. We use the algebra to prove that the operator satisfies a set of desirable properties, such as commutativity: when two models are merged, the result does not depend on which model comes first. However, the operator is not associative: if three or more models have to be merged, then the order in which the operator is applied affects the result. This can be a desirable behaviour in settings such as data streams [20], in which the distribution changes over time and the most recently received data is considered to be the most representative of current trends.\nIn other situations, such as homogeneous distributions, this behaviour is not appropriate. For example, a massive homogeneous database could be partitioned among computation units for the sake of efficiency, and the contribution of each unit to the final result should not depend on the time at which it sends its model. In Section 6, we develop two protocols, or schemes. The first one uses storage flexibly to achieve several types of decay in a data stream setting, and can be used for the case of a homogeneous database. The second scheme uses no storage space and has no decay.\nOur formal framework can also be used to characterize other common, yet difficult, problems of data mining. For example, a learner can generate a sequence of models and analyze this sequence to find patterns of changes in the underlying system. In a data stream setting, this is referred to as a blind method operating over a sliding window. In Section 7, we define a reduction operator that reduces a sequence of models to a single model to permit easier analysis of the sequence, and we characterize its properties using an algebraic approach. We also briefly discuss how more complex operators can be defined using compositions of the reduction and merge operators."}, {"heading": "2. Applications", "text": ""}, {"heading": "2.1. Combining maps", "text": "Let us consider that we are monitoring the incidence of a chronic disease in a city. For each part of the city, we want to know whether the incidence is high enough to prompt a specific action. Different groups provide maps of the disease, but these groups might not use the same spatial unit. One group may have divided the city into blocks while another one uses administrative borders. Furthermore, reports may have been released in different months, and administrative borders may have evolved. Thus, we need to merge maps reporting on the incidence with different units. Specifically, we do not have access to individual data (i.e., the data points upon which the maps are based), and we must guarantee that all maps have the same impact in our composite picture. The decision space framework that we propose is able to handle these requirements, and the algebra can be used to prove properties of the composite map. Our framework can also handle the situation in which the monitoring would be done over a long period of time, and more recent maps need to have a higher impact in the composite map. Note that, in our framework, each element of the map has to be a polygon; if a region is delimited by curves then it will have to be approximated."}, {"heading": "2.2. Map algebras", "text": "The problem of combining maps is classically faced by geographical information systems (GIS). In the early 1980s, Tomlin proposed to consider maps as two-dimensional arrays and to design script-like languages to manipulate them in GIS [26]. These languages allow operations such as the selection of areas (e.g., Schoolarea = distance(SCHOOLS) < 300m), as well as the combination of selected areas using numerical operations. Thus, map algebras are specialized programming languages for manipulating the cells of grids, which now offer the possibility to process maps within GIS using cellular automata or image-processing techniques [7, 22]. While these algebras can be used to combine maps [9], there is no (mathematically proven) control of the impact that each map has on the final combination.\n2"}, {"heading": "2.3. Wireless sensor networks", "text": "Wireless sensor networks [2] are a natural application for our approach. They can be found in applications such as forest fire detection, where temperature sensors measure the current temperature and its rate of change. They are also used to study earthquake activity by measuring the strength and duration of seismic waves in the earth\u2019s crust. The measurements are forwarded to collection nodes, which forward the data to a base station for processing. A typical sensor has a modest battery life which can be quickly drained by the transceiver when sending large amounts of data. Thus it is infeasible to forward all of the collected data to the base station. However, sensors have the computing capabilities to perform summaries such as averages and standard deviations which can then be sent to the base station.\nIn our approach, each sensor can construct a classifier based on its local observations, and send it as a summary. This summary is richer than a simple average when the goal is to make predictions. This richness may come at a cost in some classifiers: for example, a model derived using random forest classifiers [5] may be heavier than its training data, and would not be appropriate for wireless sensor networks. However, the model is usually lighter when it simplifies the data (e.g., using pruning in decision trees), and we focus on classifiers that lead to such models. Once a classifier is sent by each sensor, a collection node can merge the classifiers that it receives to form a model of a region before forwarding it toward the base station. The merging of classifiers provides a trade-off between battery consumption and prediction accuracy. The merging improves the accuracy of predictions compared to sending simple averages in exchange for an increase in battery consumption. The merging also provides a transparent means to give greater weight to the most recent observations when the network is deployed over a long time."}, {"heading": "3. Background", "text": "Our work focuses on classifiers. A classifier learns from a dataset of example instances about how target attributes are based on the values of predictive attributes. Then, it can address the classification problem of predicting the target attributes of a new instance based on the values of its predictive attributes. Without loss of generality, we explain our framework by focussing on one target attribute, but the operations can be applied for any number of target attributes.\nFormally, an instance has the form (a1, . . . , am, y) where ai is the value of the i-th attribute, and y is a class label for this data. For example, suppose that there are two instances (a1 = 30, y = No) and (a1 = 70, y = Yes) where attribute a1 is an age in [0, 125] and the class label is either Yes or No, corresponding to an individual being classified as old or not. The goal is to find the best approximation to the function f (a1, . . . , am) = y that determines the label of an unclassified instance given the values of its attributes. Three of the most commonly used techniques to train a classifier, i.e., to deduce an approximation of f given a set of instances, are [15, 14]\n\u2022 A Support Vector Machine (SVM) classifies the instances into two classes by separating them with the (m \u2212 1)- dimensional hyperplane that leaves the maximum margin between the two classes [25]. It is also possible to obtain non-linear classifications using the kernel method [4].\n\u2022 One of the most popular classifiers is the decision tree. A decision tree learner [23] applies a divide-andconquer technique to recursively split the data using the value of an attribute while maximizing a metric such as the information gain or Gini index. Each split is represented as a node and the recursive procedure yields a tree. Thus, a path in the tree corresponds to a set of conditions on the values of the attributes, and leads to a class distribution vector expressing the percentage of instances in each class.\n\u2022 A classifier can also be a set of rules based on the values of the attributes. This is commonly referred to as a rule set [8]. A rule is a conjunction of conditions on the attributes that results in a class distribution vector as in a decision tree. An attribute can be repeated at most twice in a rule, to specify a lower bound and an upper bound of an interval.\nIn meta-learning, each learner builds a classifier using only its own data. For example, each unit in a network of radar sensors can collect data about the movements of targets within its radius. Then, each sensor uses its own data to deduce a classifier such as a decision tree. In such an environment, all sensors may want to have a classifier that is as accurate as possible and thus they exchange their classifiers and merge them. In another setting, one may want to achieve a speedup by using parallel algorithms and thus a homogeneous database is partitioned among different\n3\ncomputation units, either by providing them with subsets of observations or subsets of attributes (vertical partitioning [24]). Then, the units send their classifiers to common sources in charge of merging. In both homogeneous databases and distributed environments, the problem is to merge a set of classifiers to create a single classifier.\nA number of researchers have focussed on merging decision trees: it was noted in [3] that \u201ca kind of decision tree induction [that is] efficient in a wide area system employs meta-learning, [in which] each computer induces a decision tree based on its local data and then the different models are merged to form the final tree\u201d. For example, it has been proposed [13] to transform decision trees into the sets of rules that they represent and to merge those sets. A rule not in conflict with other rules is kept intact and otherwise the conflicts are resolved using a heuristic. However, there are two potential problems with the design of the heuristic proposed in [13]. Firstly, the authors argue that conflicts that are not handled by the heuristic are \u201cunlikely if the training sets contain similar distributions of examples from a coherent larger training set\u201d, thus the approach is limited to homogeneous data bases. Secondly, their algorithm could ask a learner to send all of the data on which there is a conflict in order to perform data mining again, and this prevents uses in settings such as sensor networks.\nThe requirement that the data needs to be examined in case of conflicts is found in several other approaches. For example, arbiter meta-learning [27] is a technique that merges classifiers in a hierarchical way. This technique has been designed for homogeneous databases, and parts of the data must be propagated during the combination process. Ganti and colleagues [11] focused on a different problem: they examined how one could quantify the difference between two datasets by analyzing their models, which can be used to determine whether a model should be updated. Their concepts are similar to ours in that they considered a model as a geometrical space divided into units, each of which is assigned a value, and combining two models requires scanning the data. The key difference of our framework, introduced in the next section, is its ability to merge potentially heterogeneous classifiers without requiring any data besides the models."}, {"heading": "4. A framework: decision spaces", "text": ""}, {"heading": "4.1. Introducing the structure", "text": "Intuitively, a decision space is an m-dimensional space, in which each dimension corresponds to one of the m attributes. It contains a set of non-overlapping elements which, if they cover all the space, form a partition of the space. A geometrical interpretation of an element is a subspace defined by an m-polytope. Thus, the only requirement for the classifiers considered in this paper is that their elements have to be polytopes, which is the case for SVMs with linear kernels, decision trees, and rule sets. Our study of polytopes is a first step to investigating the theoretical behaviour of pure meta-learning. Further research could remove the restriction to polytopes to generalize our approach to handle other classifiers such as SVMs with non-linear kernels [4]. Informally, non-linear kernels can define shapes in terms of curves whereas polytopes can only use lines.\nEach element, or polytope, has a class distribution vector that specifies the percentage of instances within the covered space that are assigned to each class. Determining the percentages by enumerating the instances is straightforward for the three classifiers considered here. An example of a decision space is shown in Figure 1(a): it has two attributes, degree and age, and three elements, each with a class distribution vector of size 2 (with classes Yes and No). Any classifier is capable of producing a label for a given instance, and can be repeteadly prompted for labels over a discrete space. Therefore, any classifier can provide a class distribution vector. In Xu\u2019s categorization of the outputs used to combine classifiers, our requirement is the most universal (Type 1) [29]. These concepts are formalized in Definitions 1 and 2.\nDefinition 1. A decision space is an m-dimensional (product) space Dattr1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Dattri \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Dattrm where m is the number of attributes and Dattri is the space covered by the i-th attribute specified as a bounded poset (i.e., a partially ordered set with a least and a greatest element).\nDefinition 2. An element of an m-dimensional decision space D is a subspace of D, i.e., an m-dimensional polytope (m-polytope). It is identified by a set of coordinates for each attribute, and has a class distribution vector V with c components, where c is the number of classes. The i-th component of the vector is the percentage of instances in class i, which is obtained by counting all instances that have class i and are within the element\u2019s space. Thus, the content of the vector sums to 100%. We will refer to the vector V as the value of the element.\n4"}, {"heading": "4.2. Conversions", "text": "The constraints on the structure of a classifier are used by a data mining algorithm to guide the search. A decision space is a framework and does not result directly from a data mining algorithm, thus its structure is less constrained than classifiers such as decision trees. This ensures that elements from several kinds of classifiers can be converted to elements of a decision space with no loss of information. To convert a classifier into a decision space, the only data required besides the classifier itself are the ranges of attributes for the dataset on which the classifier was trained. These ranges can be deduced in one pass over the dataset by scanning for the maximum and minimum values. The ranges can also be user-supplied, but should not be smaller than what is found in the dataset for consistency sake. Thus, given a classifier and the ranges of the attributes, the main task of the conversion is to extract the individual elements, or polytopes. The polytopes for elements of the three classifiers defined in Section 3, in order of increasing constraints on the shapes, are as follows:\n(1) The elements in an SVM can have the most general shapes because the data can be assigned into regions.\n(2) A rule in a rule set defines an axis-parallel rectangle.\n(3) Each path of a decision tree (Figure 1(b)) can be converted to a rule, and this rule defines an axis-parallel rectangle (Figure 1(a)).\nA decision tree cannot generate all axis-parallel rectangles. Indeed, a decision tree belongs to the data mining family of divide-and-conquer algorithms that imposes constraints on the search. Intuitively, a cut in the space along the border of an element, either vertical or horizontal, should not cut any element [10]. An example of a set of rules that violates this constraint is given below, and shown in Figure 2.\nIF age \u2265 0 and age < 4 and degree \u2265 0 and degree < 2 THEN A IF age \u2265 4 and age < 6 and degree \u2265 0 and degree < 4 THEN B IF age \u2265 0 and age < 2 and degree \u2265 2 and degree < 6 THEN C IF age \u2265 2 and age < 6 and degree \u2265 4 and degree < 6 THEN D IF age \u2265 2 and age < 4 and degree \u2265 2 and degree < 4 THEN E\nThe elements of rule sets and decision trees can be converted to elements of a decision space using Algorithm 1. The algorithm uses pattern-matching. For example, in line 4, attrk OP1 = {<,\u2264} valkup is a pattern for which the value of an attribute has to be lower or strictly lower than the value valkup . If the pattern is found, then attrk, OP1, and valkup are bound to the actual values. For example, a pattern age < 5 will result in the binding attrk = age, OP1 = \u201c < \u201d, valkup = 5.\nFor each rule, the algorithm considers all patterns that specify an upper bound (line 4). If there is also a pattern specifying a lower bound for the same attribute (line 6), then the range of the attribute can be specified. If no pattern is found for the lower bound of an attribute attrk (line 15), then we use the lower bound of the attribute\u2019s range which we denote min(Dattrk ). Finally, if no upper bound is found for attrk (line 20), we use the upper bound of the attribute\u2019s range which we denote max(Dattrk ).\n5\nConverting elements from a support vector machine follows a simpler process: each element of the decision space corresponds to exactly one element of the SVM with the same distribution vector and the same coordinates specifying the space spanned.\nAlgorithm 1 RulesToSpaces(Ruleset R, Attribute ranges Dattr1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 DattrM)\nRequire: Rules are expressed in the following form: r := IF attr1 \u224d val1 AND \u00b7 \u00b7 \u00b7 AND attrm \u224d valm THEN class = X\n1. Decision space S \u2190 \u2205 // Initially, the decision space is empty 2. for r \u2208 R do // Each rule of the rule set is converted to one element 3. element e.value \u2190 r.X // The elements value is the one predicted by the rule 4. P \u2190 all patterns attrk OP1 = {<,\u2264} valkup in R // A rule is a conjunction of patterns, each delimiting a bound 5. for p \u2208 P do // Use each upper bound to find the elements space 6. if \u2203 a pattern attrk OP2 = {>,\u2265} valklow in R then // Check if there is a lower bound on the same variable 7. if OP1 is < and OP2 is > then // The two bounds do not include the endpoints 8. e.space \u2190 e.space \u222a (valklow , valkup) 9. else if OP1 is < and OP2 is \u2265 then // Only the upper endpoint of the bound is included\n10. e.space \u2190 e.space \u222a (valklow , valkup] 11. else if OP1 is \u2264 and OP2 is > then // Only the lower endpoint of the bound is included 12. e.space \u2190 e.space \u222a [valklow , valkup) 13. else // Both endpoints of the bound are included 14. e.space \u2190 e.space \u222a [valklow , valkup] 15. else // We only have an upper bound on the element 16. if OP1 is < then 17. e.space \u2190 e.space \u222a [min(Dattrk ), valkup) 18. else 19. e.space \u2190 e.space \u222a [min(Dattrk ), valkup] 20. if P = \u2205 then // If there was no upper bound 21. P \u2190 all patterns attrk OP = {>,\u2265} valklow in R // Then access the lower bound 22. for p \u2208 P do 23. if OP2 is > then // The lower bound is excluded 24. e.space \u2190 e.space \u222a (valklow ,max(Dattrk )] 25. else 26. e.space \u2190 e.space \u222a [valklow ,max(Dattrk )] // The lower bound is included 27. S \u2190 S \u222a e // Add the element to the decision space\n6"}, {"heading": "5. Merge operator", "text": ""}, {"heading": "5.1. Preliminary definitions", "text": "The most fundamental operation on decision spaces is merge. In the following, we use the term \u201celement\u201d to refer to a geometrical space spanned, and \u201cvalue\u201d to refer to a class distribution vector. Given two decision spaces X and Y, we merge them into Z using the following principles:\nMerge principles\n(1) If an element (subspace) x \u2208 X does not intersect with any element y \u2208 Y, then the prediction represented by x has no conflicts and can be added to Z. An element y \u2208 Y with no conflicts is treated similarly.\n(2) If an element y \u2208 Y is strictly contained within an element x \u2208 X with the same value (i.e., the same class distribution vector V), then we consider y to be too specialized (as explained in Definition 5) and delete it.\n(3) If neither of the first two conditions is satisfied, then the element x \u2208 X intersects with at least one element of Y and conflicts must be resolved.\nPrior to establishing the algorithm to merge elements, we introduce the formal notation on which it relies, and specify the ways that elements can intersect. From here on, we use the following notation for an element x \u2208 X:\n\u2022 x has a set of attributes A(x).\n\u2022 Each attribute a \u2208 A(x) covers a (one-dimensional) space S (x, a). It can be an interval such as [8, 10], or a union of intervals.\n\u2022 The size of the space covered by x for the attribute a is denoted |S (x, a)|.\n\u2022 x has a class distribution vector V(x).\nDefinition 3. An element x \u2208 X subsumes an element y \u2208 Y, denoted y x, if A(x) = A(y) and \u2200a \u2208 A(x), S (y, a) \u2286 S (x, a).\nIn other words, an element y is subsumed by an element x when the space covered by y is included in the space covered by x. We denote strict subsumption by \u227a when \u2200a \u2208 A(x), S (y, a) \u2282 S (x, a). The main property of subsumption is established by Theorem 1.\nTheorem 1. Let X and Y be two decision spaces. For each y \u2208 Y, there is at most one x \u2208 X such that y x.\nProof. The elements of X and Y partition the spaces formed by X and Y, respectively. Thus, one element (i.e., component of a partition) can be completely included in at most one other element.\nDefinition 4. The intersection of an element x \u2208 X with a decision space Y is denoted x \u228e Y and is the largest subset of elements I = {y1, . . . , yn} \u2286 Y such that for each yi \u2208 I, \u2203a \u2208 (A(x) \u2229 A(yi)) such that S (x, a) \u2229 S (yi, a) , \u2205. Subsumption is a special case of intersection.\nThe first two principles of merging can be handled by the notions in Definitions 3 and 4. For the third principle, we resolve each conflict between two elements x \u2208 X and y \u2208 Y by creating a new element z for each intersection. A simple approach would be to assign to z a value that is the average of the values of x and y, but it would not take into consideration the spaces covered by x and y (i.e., their regions of competence). Consequently, Definition 5 specifies how to measure the space covered by an element, which we call its specialization (also known as competence). Then, Definition 6 calculates the value of z is calculated as a weighted average based on the spaces covered by x and y. It should be noted that Definition 6 is a classical combination scheme intermediate between classifier fusion and selection (cf. Introduction). In these schemes, all classifiers contribute to the outcome of a given space space with weights based on their competence for that space [17].\nDefinition 5. The specialization of an element x \u2208 X is M(x) = \u2211 a\u2208A(X)|S (x, a)|\n|A(X)| .\n7\nIntuitively, we sum the sizes of the spaces of the attributes characterizing x and we normalize by the number of attributes. Small values of M indicate specialized predictions based on small spaces. Other possible metrics could take into account the number of instances, or the class distribution vector. However, in the case of pure meta-learning investigated in this paper, we cannot use the number of instances or the class distribution vector in a specific part of an element. This could only be done by requiring the original classifier to perform an exhaustive search in its dataset, and repeated use of such an operation could lead to significant overhead. Therefore, such alternative metrics are not considered here.\nDefinition 6. The value of the intersection of two elements x \u2208 X and y \u2208 Y based on their specializations is the class distribution vector\nV(x \u2297 y) = V(x) \u00d7 M(x)\nM(x) + M(y) + V(y) \u00d7 M(y) M(x) + M(y) .\nIf the elements predict several attributes, then the class distribution vector for each attribute is computed using the above formula. Other formulae for V(x \u2297 y) could be designed to suit application-specific needs. Indeed, both the element\u2019s space and its value must be taken into account, but specific applications may require that the specialization be normalized differently. However, care should be taken to ensure that custom formulae satisfy the commutativity, idempotency, and unique identity properties. Indeed, such properties are critical for proving that the merge algorithm behaves appropriately, as will be shown in Section 5.3."}, {"heading": "5.2. Merging algorithm", "text": "The merge operator \u2297 : (X, Y) 7\u2192 Z is defined in an algorithmic way by Algorithm 2 and is illustrated in Figure 3. First, we apply Merge principle (1): all elements with no intersection are added. Then, we apply principle (2): each element x \u2208 X that is strictly contained in an element y \u2208 Y with the same value is deleted. Finally, principle (3) is applied as follows:\n8\nAlgorithm 2 \u2297 : (X, Y) 7\u2192 Z\n1. Z \u2190 new decision space 2. H \u2190 \u2205 // Hash map: set (y, y\u2032) of keys y and associated values y\u2032 3. for x \u2208 X do // For each element x 4. if \u2204y \u2208 Y such that x \u227a y and V(x) = V(y) then // If there is no y that subsumes it with the same value, then process it 5. if x \u228e Y = \u2205 then // If x does not conflict with any element of Y, then add it to the result 6. Z \u2190 Z \u222a x 7. else // Otherwise, resolve the conflicts 8. tmp \u2190 x.space // The initial space of x is saved 9. for y \u2208 x \u228e Y do // Create an element z to handle each conflict 10. z \u2190 new element 11. z.space \u2190 tmp \u2229 y.space // zs space is the one initially shared by x and the conflicting element 12. z.value \u2190 V(x \u2297 y) // zs value (class distribution vector) is based on both xs and ys 13. Z \u2190 Z \u222a z // z is added to the resulting decision space 14. if \u2204(y, y\u2032) \u2208 H then // If we never registered a conflict with y then register it 15. H \u2190 H \u222a (y, y.space \\ z.space) // Register that the space of y that conflicted has been handled 16. else // Otherwise update the previous record 17. H \u2190 H \\ (y, y\u2032) 18. H \u2190 H \u222a (y, y\u2032.space \\ z.space) 19. x.space \u2190 x.space \\ z.space // Also update that some of xs conflicting space was handled 20. if x.space , \u2205 then // If, after solving the conflicts, x has (non conflicting) space then we keep it"}, {"heading": "21. Z \u2190 Z \u222a x", "text": "22. for y \u2208 Y such that \u2204(y, y\u2032) \u2208 H do // If some elements y have never found to be in a conflict . . . 23. if \u2204x \u2208 X such that y \u227a x and V(y) = V(x) then // . . . and that they are not subsumed by an element x with the same value 24. Z \u2190 Z \u222a y // Then we add them to the result 25. for (y, y\u2032) \u2208 H do // For each element y that was found to be in a conflict 26. if y\u2032 , \u2205 then // If some of this element was free of conflict 27. Z \u2190 Z \u222a y\u2032 // Then we add it 28. return Z\n\u2022 We consider all possible intersections x \u228e Y and handle them sequentially.\n\u2022 For each y \u2208 (x \u228e Y), we create an element z. The space covered by z is the intersection of the spaces covered by x and y, and the value is V(x \u2297 y) (Definition 6).\n\u2022 There will be a \u201cremainder\u201d when the process is finished if x only has a partial intersection with Y. Thus, we remove from x the space of each z resulting from the intersection, and we add the remainder, if any, to the result.\nAfter applying all three merge principles for each element x \u2208 X, we process the elements y \u2208 Y. Merge principles (1) and (2) have to be applied to these elements, but principle (3) can be partially avoided. Indeed, the elements in the intersection of X and Y have already been computed when processing X. We use a hash map H as a cache, in which the element y is used as a key and its corresponding value y\u2032 in the hash map is the space that is updated throughout the process. When an intersection between x and y is found, the part in the intersection is virtually removed from y by changing the value for y in H. After all of the intersections have been computed, H contains the remainder of each element of Y and thus it can be added directly to the result.\nExample. In Figure 3, the left decision tree was trained on a dataset with the degree ranging from 0 to 15, and the age ranging from 0 to 8. The right decision tree was trained on a dataset with the degree ranging from 0 to 11, and\n9\nthe age ranging from 0 to 9. The light grey element in the left decision space and the element with the checkerboard pattern in the right decision space intersect. As two elements converted from decision trees only intersect in one contiguous space, the result is the new space z whose age ranges from 7 to 8, and whose degree ranges from 3 to 10. Using Definition 6, the percentage for the class Yes is ( 152 \u00d7 40)/( 15 2 + 13 2 ) + ( 13 2 \u00d7 0)/( 15 2 + 13 2 ) \u2248 21, and since there are only two classes in this example, the percentage for the class No is 100 \u2212 21 = 79. The intersection of rectangles in m-dimensions (for m attributes) can result in spaces that are not rectangles. For example, Figure 4 shows the intersection of two decision spaces X and Y. Decision space X contains four rectangular elements and Y contains one rectangular element, but the intersection of the element of Y with any element of X leaves a non-rectangular remainder of Y. Constraining elements to be rectangles requires a heuristic that can bias the result since rectangles are only an approximation of the element\u2019s actual specialization. We avoid this problem by using polytopes instead of rectangles to provide an exact algebra. The possibility that elements may have to be constrained to simple polytopes (e.g., rectangles) for computational reasons is discussed in the Conclusions."}, {"heading": "5.3. Algebraic properties", "text": "The goal of a merge operator \u2297 is to merge the information of two decision spaces, resolving any conflicts that arise. Thus, it has to obey a set of algebraic properties in order to be consistent:\n10\n\u2022 Commutativity: merging a decision space with another one should not depend on which one is first but only on the information.\n\u2022 Identity element: merging a decision space with a decision space that does not contain any elements should not change anything because there is no new information.\n\u2022 Idempotence: merging a decision space with itself should not change anything, as there are neither conflicts nor new information.\nTheorems 2, 3, and 4 prove that our merge operator satisfies these three algebraic properties. Intuitively, the algorithmic construction of the merge operator is based on unions of geometric spaces and the resolution of conflicts encountered for non-empty intersections. Both the union of spaces (i.e., the intersection of geometrical elements) and the resolution of conflicts (i.e., the weighted average of values) satisfy the three algebraic properties. Therefore, we show that they are combined \u201cappropriately\u201d by the merge operator. We then show in Theorem 6 that the operator is not associative, which is the subject of the next section.\nDefinition 7. The set of all decision spaces is denoted by D.\nTheorem 2. The \u2297 operator is commutative, i.e., \u2200X, Y \u2208 D, X \u2297 Y = Y \u2297 X.\nProof. Suppose that there is a z \u2208 X \u2297 Y. We prove that it also has to be in Y \u2297 X. We consider all possible cases from which such a z could result:\n(1) z results from an x \u2208 X that has no intersection. We show that if a y \u2208 Y has no intersection it will also be kept in the result Z.\n(2) z results from the intersection of an x \u2208 X with a y \u2208 Y. We will show that there are no changes if we consider it as the intersection of a y \u2208 Y with an x \u2208 X.\n(3) z is the remainder of an element x \u2208 X. We show that the remainder of an element y \u2208 Y will also be kept in the result Z.\n(1) As x \u2208 X has no intersection, it will be added to the result (line 6). If a y \u2208 Y has no intersection, it will not be in any x\u228eY and thus we will not create a (y, y\u2032) \u2208 H in line 15. As (y, y\u2032) < H in line 22, y will be considered unchanged. Given that y has no intersection, it will be added to the result in line 24. (2) As x intersects with a y, the operator \u228e relates x to y (line 9) and an element z will be created, its space being the intersection of the spaces of x and y, and its value being V(x \u2297 y). Each operation involved is commutative, thus the overall process is commutative.\n11\n(3) For an x \u2208 X, we consider each y \u2208 Y with which it intersects (line 9): an element z is created for each intersection, and its space is taken out of the space of x (line 19); once the spaces of all intersections have been taken out of x, the remainder is added to the result if it is not empty (line 21). The same process takes place for the remainder of a y \u2208 Y: all the x \u2208 X with which it intersects are considered (lines 3 and 9), an element z is created for each intersection, and we keep track of the remainder of y by updating its associated value in H or creating it for the first intersection (lines 14\u201318). An element y will not be considered anymore if it intersected with some x \u2208 X (line 25), and instead its remainder is added to the result (line 27).\nDefinition 8. A decision space E \u2208 D is called an identity of D with respect to the \u2297 operator if and only if \u2200D \u2208 D, E \u2297 D = D \u2297 E = D.\nTheorem 3. There exists a unique identity E \u2208 D with respect to the \u2297 operator, and it is an empty set of polytopes (i.e., the empty space).\nProof. Let X and E be two decision spaces and E = \u2205. We first prove that \u2200X \u2208 D, X \u2297 E = X, which leads to E \u2297 X = X using Theorem 2, hence E is an identity element. No element x is subsumed by an element e \u2208 E, and x \u228e E = \u2205, thus all elements x \u2208 X are added to the result (line 6). As there is no e \u2208 E, the loops in lines 22\u201327 are not executed and so the final result is equal to X.\nWe complete the proof by showing that Y \u2208 D cannot be an identity for any X \u2208 D if Y , E. As Y , E = \u2205, there is at least one y \u2208 Y. Let us consider X \u2208 D such that y \u228e X = \u2205. As y has no intersection with any x \u2208 X, it will be ignored by the main for loop (lines 3\u201321), thus \u2204(y, y\u2032) \u2208 H. As a consequence, it will be considered by the second loop (line 22) and, as it is not subsumed by any x \u2208 X, it will be added to the result in line 24; thus, the result is X \u222a y , X because y < X. Similarly, for the case y \u228e X , \u2205, the element y is processed by the main loop (lines 8\u201321). For any such y, \u2203X \u2208 D with an element x \u2208 X intersecting with y such that x and y cover a different space. This results in dividing x into new elements (line 11) and thus the result of X \u2297 Y is different from X.\nTheorem 4. The \u2297 operator is idempotent as X \u2297 X = X.\nProof. Let X and Y be two decision spaces such that X = Y:\n\u2022 There is no x \u2208 X strictly contained in an y \u2208 Y. The use of strict subsumption \u227a instead of , in the definition of \u2297, is particularly important at this point. Indeed, if X = Y and we were using , then all elements in X would be discarded because they are subsumed by the same value in Y, and similarly for Y. Thus, X \u2297 X would lead to the incorrect result \u2205.\n\u2022 Each element x intersects with exactly one y. As they are the same, we will add one element to the result with the following value for each component of the vector (lines 8\u201313):\nV(x) \u00d7 M(x)M(x)+M(y) + V(y) \u00d7 M(y) M(x)+M(y) = V(x) \u00d7 M(x) 2\u00d7M(x) + V(x) \u00d7 M(x) 2\u00d7M(x) = V(x).\n12\n\u2022 x will be added to the result for all x \u2208 X (line 13). For all y \u2208 Y, we added a pair (y, z) \u2208 H such that z.space = x.space \\ y.space = \u2205 (line 15). Thus, all elements of y \u2208 Y are skipped because they are in H (line 22), and because the associated value is empty (line 26). Therefore the resulting decision space contains each x \u2208 X exactly once.\nCorollary 5. The binary operator\u2297 : (D,D) 7\u2192 D is idempotent, commutative, and contains a unique identity element for the set D of all decision spaces. Therefore, (D,\u2297) is a unital, idempotent, and commutative magma (see [19] for a brief review of algebraic structures such as magmas).\nTheorem 6. The \u2297 operator is not associative: \u2203X, Y, Z \u2208 D such that (X \u2297 Y) \u2297 Z , X \u2297 (Y \u2297 Z).\nProof. In Figure 5, if we first merge x with y, then the value of the intersection will depend on all of x and y, and we get the shaded remainder of y. Then, if we merge with z, the value of the resulting intersection will depend on the shaded remainder and z. However, if we first merge y with z, then the part of y that intersects with z is removed from y, resulting in a remainder y\u2032. Then, if we merge with x, the value depends on x and y\u2032 which covers a smaller space than y. It follows that its intersection with x will have a different value. Thus, the values change with the order in which elements are merged, while the spaces covered do not (as they result from the intersection of geometrical spaces which is an associative operation)."}, {"heading": "6. The impact of merge order", "text": "According to Theorem 6, the \u2297 operator is not associative, so the result of merging more than two decision spaces depends on the order in which they are merged. We refer to a merge order as a merging scheme. Note that a scheme is not necessarily a simple sequence: a merging scheme can specify that large groupings of decision spaces have to be merged first, and then merged together. Its representation is defined below.\nDefinition 9. A merging scheme specifies the order in which a set of decision spaces is merged. It can be represented as a tree, in which a leaf represents a decision space, an intermediate node represents the application of the \u2297 operator (hence an intermediate decision space), and the root represents the final result.\nTwo merging schemes are shown in Figure 6. In the merging scheme in 6(a), the decision spaces are merged pairwise (bottom layer of the tree), then the resulting decision spaces are merged pairwise, and so on, until a single decision space W is obtained. We can describe this merging scheme as (((X1 \u2297 X2) \u2297 (X3 \u2297 X4)) \u00b7 \u00b7 \u00b7 ((Xm\u22123 \u2297 Xm\u22122) \u2297 (Xm\u22121 \u2297 Xm))), where m = 2k. As we will demonstrate in Corollary 8, this merge order does not introduce any bias into the calculation of the value of W. Any differences in the impacts of the decision spaces on the value of W are based on their relative specializations. In contrast, the merging scheme in Figure 6(b) will lead to a bias in the result. In this scheme, the first two decision spaces are merged, then the result is merged with the third decision space, and so on, until W is obtained. We can describe this merging scheme as (((X1 \u2297 X2) \u2297 X3) \u00b7 \u00b7 \u00b7 \u2297 Xm). This merge order does introduce bias into the calculation of the value of W. Each decision space is merged with the result of merging its predecessors, it\u2019s impact is the same as all of its predecessors combined. So, the impact of earlier decision spaces is reduced each time that a new decision space arrives. This effect can be desirable. If the underlying distribution is changing, then we often want recent decision spaces to have a larger impact on the result because they represent recent trends.\nBoth merging schemes can be desirable depending on the setting. The merging scheme shown in Figure 6(a) can be used when a homogeneous database has been partitioned among several computation units. Indeed, the model produced by each unit should have the same impact on the final result as the underlying distribution is homogeneous. The merging scheme shown in Figure 6(b) can be used for time-changing distributions, for example data streams. In this setting, learners can deduce models at different times, and we may want to favour the most recent models as they represent recent trends. The situation in which decision spaces are merged as soon as they are received is depicted in Figure 6(b): the decision space received at time t is merged with everything that was received up to time t \u2212 1. Note that we could also have an online setting such as in data streams, but we might not want the time at which models are received to have an impact. In this case, the scheme in Figure 6(a) can also be used, and it specifies that some decision\n13\nspaces will have to be stored temporarily: large groupings of decision spaces must be formed before the merging operation can take place to guarantee an equal impact on the final result.\nHowever, the framework developed so far has limitations that can prevent unbiased results. Indeed, the merging operator is binary and thus an unbiased result can only be achieved if the number of decision spaces to merge is a power of 2. Furthermore, using powers of 2, the impact of decision spaces over time can only decay exponentially, whereas other types of decays may be needed. We will generalize the merge operator to overcome these limitations in the next two subsections."}, {"heading": "6.1. m-ary merging", "text": "Consider a set {X1, . . . , Xm} of decision spaces. We extend Algorithm 2 from a binary operator to an m-ary operator. Increasing the number of geometrical objects that are intersected does not affect the operator, since the intersection of geometrical objects is associative. Thus, the extension only involves the computation of the value, which is extended in Definition 10.\nDefinition 10. The value of the intersection of m elements x1 \u2208 X1, x2 \u2208 X2, . . . , xm \u2208 Xm based on their specializations is a vector\nV(x1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 xm) = V(x1) \u00d7 M(x1)\nM(x1) + \u00b7 \u00b7 \u00b7 + M(xm) + \u00b7 \u00b7 \u00b7 + V(xm) \u00d7 M(xm) M(x1) + \u00b7 \u00b7 \u00b7 + M(xm) .\nThe combination of the handling of geometrical spaces and the computation of the value is similar to the merging algorithm introduced in Section 5.2:\n(1) If an element is strictly included within another one and has the same value, discard it.\n(2) Otherwise, for each intersection, create a new element z with a value that is computed using the formula in Definition 10.\nWe assume in Theorem 7 and its corollaries that the decision spaces to be merged all cover the same space so that we can concentrate on the impact of merge order.\nTheorem 7. In a merging scheme for m decision spaces X1, . . . , Xm, all of which cover the same space, the impact of a decision space Xi on the value of the final result is proportional to the product of the numbers of operands of the \u2297 operators on the path from the leaf representing Xi to the root of the merging scheme.\nProof. In a merging scheme, each internal node is an m-ary \u2297 operator and each leaf is a decision space. Consider an internal node u with k operands T1, T2, . . . , Tk. Each T j is either a decision space or a subtree of the merging scheme and each T j accounts for a fraction 1/k of the value of the subtree rooted at u. Consider two internal nodes u1 and\n14\nu2 with k1 and k2 operands, respectively, and suppose that u2 is an operand of u1 in the merging scheme. Then each operand of u2 accounts for 1/k2 of its value and u2 accounts for 1/k1 of the value of u1, so each operand of u2 accounts for a fraction 1/(k1 \u00d7 k2) of the value of u1. If the numbers of operands of u1 and u2 are exchanged, then each operand of u2 contributes the same fraction 1/(k2 \u00d7 k1) of the value of u1. Thus, the contribution of a decision space to the value of the root of the merging scheme depends only on the final product of the numbers of operands of the m-ary \u2297 operators on the leaf to root path.\nFigure 7 shows an example of a merging scheme for twelve decision spaces in which the impacts of all of the decision spaces on the value of W are the same.\nCorollary 8. In the merging scheme (((X1 \u2297 X2) \u2297 (X3 \u2297 X4)) \u00b7 \u00b7 \u00b7 ((Xn\u22123 \u2297 Xn\u22122) \u2297 (Xn\u22121 \u2297 Xm))), where m = 2k (Figure 6(a)), each decision space accounts for 2\u2212k of the value of W.\nCorollary 9. In the merging scheme (((X1 \u2297 X2) \u2297 X3) \u00b7 \u00b7 \u00b7 \u2297 Xm) (Figure 6(b)), decision space Xi accounts for 2\u2212m+i\u22121 of the value of W if i > 1, and 2\u2212m+1 if i = 1."}, {"heading": "6.2. Adjusting the bias", "text": "As explained earlier in this section, when decision spaces are merged over time as in a data stream setting, then their impacts decay exponentially. In the previous sub-section, we used extra storage to change the impacts. In this sub-section, we introduce an approach that uses no extra storage and provides decision spaces with the same impact. Furthermore, this approach does not require prior knowledge of the number m of decision spaces to be merged. In contrast, the approach in the previous sub-section requires m to design a merging scheme.\nDefinition 11. The \u03b2-weighted value of the intersection of two elements x \u2208 X and y \u2208 Y is the class distribution vector V(x \u2297 y) = V(x) \u00d7 \u03b2 + V(y) \u00d7 (1 \u2212 \u03b2), 0 < \u03b2 < 1.\nThe value produced by the formula in Definition 6 is a \u03b2-weighted value with \u03b2 = M(x1)M(x1)+M(x2) and V(x\u2297 y) depends only on the specializations of x and y. If x and y have the same specialization, then each accounts for half of the value of the result. The bias in a merging scheme like the one in Figure 6(b) is entirely the result of the merge order when \u03b2 = M(x1)M(x1)+M(x2) is used. We can use different values of \u03b2 with this scheme to produce the final value V(((x1 \u2297 x2) \u2297 x3) \u00b7 \u00b7 \u00b7 \u2297 xm) = V(x1) \u00d7 M(x1)\nM(x1)+\u00b7\u00b7\u00b7+M(xm) + \u00b7 \u00b7 \u00b7 + V(xm) \u00d7 M(xm) M(x1)+\u00b7\u00b7\u00b7+M(xm) , the same as an m-ary merge.\nTheorem 10. Let \u03b2i = M(x1)+\u00b7\u00b7\u00b7+M(xi)\nM(x1)+\u00b7\u00b7\u00b7+M(xi+1) be the weight used to compute the value of the i-th merge, i = 1, 2, . . . ,m \u2212 1,\nin the merging scheme (((X1 \u2297 X2) \u2297 X3) \u00b7 \u00b7 \u00b7 \u2297 Xm). Then the resulting value of the intersection of m elements x1 \u2208 X1, x2 \u2208 X2, . . . , xm \u2208 Xm based on their specializations is V(((x1 \u2297 x2) \u2297 x3) \u00b7 \u00b7 \u00b7 \u2297 xm) = V(x1) \u00d7\nM(x1) M(x1)+\u00b7\u00b7\u00b7+M(xm) + \u00b7 \u00b7 \u00b7 +\nV(xm) \u00d7 M(xm)\nM(x1)+\u00b7\u00b7\u00b7+M(xm) .\n15\nProof. We prove this result by induction on m. If m = 1, then two decision spaces are merged using \u03b21 = M(x1)\nM(x1)+M(x2)\nand V(x1\u2297x2) = V(x1)\u00d7 M(x1)\nM(x1)+M(x2) +V(x2)\u00d7(1\u2212 M(x1) M(x1)+M(x2) ) = V(x1)\u00d7 M(x1) M(x1)+M(x2) +V(x2)\u00d7 M(x2) M(x1)+M(x2) . Assume that the\ntheorem is true for m = j\u22121 \u2265 2, so that V((((x1\u2297 x2)\u2297 x3) \u00b7 \u00b7 \u00b7\u2297 x j) = V(x1)\u00d7 M(x1)\nM(x1)+\u00b7\u00b7\u00b7+M(x j) + \u00b7 \u00b7 \u00b7+V(x j)\u00d7 M(x j) M(x1)+\u00b7\u00b7\u00b7+M(x j) .\nThe j-th merge uses \u03b2 j = M(x1)+\u00b7\u00b7\u00b7+M(x j)\nM(x1)+\u00b7\u00b7\u00b7+M(x j+1) . Then V((x1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 x j) \u2297 x j+1) = (V(x1) \u00d7 M(x1) M((((x1\u2297x2)\u2297x3)\u00b7\u00b7\u00b7\u2297x j))\u2297x j+1 + \u00b7 \u00b7 \u00b7 +\nV(x j) \u00d7 M(x j) M(x1)+\u00b7\u00b7\u00b7+M(x j) ) \u00d7 M(x1)+\u00b7\u00b7\u00b7+M(x j)M(x1)+\u00b7\u00b7\u00b7+M(x j+1) + V(x j+1) \u00d7 (1 \u2212 M(x1)+\u00b7\u00b7\u00b7+M(x j) M(x1)+\u00b7\u00b7\u00b7+M(x j+1) ) = V(x1) \u00d7 M(x1) M(x1)+\u00b7\u00b7\u00b7+M(x j+1) + \u00b7 \u00b7 \u00b7 + V(x j+1) \u00d7\nM(x j+1) M(x1)+\u00b7\u00b7\u00b7+M(x j+1) ."}, {"heading": "7. Developing an algebra", "text": ""}, {"heading": "7.1. Restriction operator", "text": "In a time-varying environment, the accuracy of the predictions decreases over time, so new decision spaces must be created regularly. A sequence of decision spaces carries information about changes in the environment over time, so techniques such as time series analysis potentially could be used. While time series analysis considers a sequence of vectors of fixed size, decision spaces can be of varying size: for example the values of attributes can evolve over time to cover a broader space. A restriction operator can be used to simplify the decision spaces of a time series so that they all have same size. We introduce this operator in Definition 12, and define it formally in Algorithm 3. Then, we apply the algebraic approach in a similar way to the merging operator: we study identity elements (Theorem 11), idempotency (Theorem 12), and associativity (Theorem 13).\nDefinition 12. The restriction of a decision space X by a decision space Y is the decision space Z that only retains elements of X that intersect with elements of Y. The corresponding operator is denoted \u2299.\nAlgorithm 3 \u2299 : (X, Y) 7\u2192 Z\n1. Z \u2190 new decision space 2. for x \u2208 X such that x \u228e Y , \u2205 do 3. z \u2190 new element 4. for y \u2208 x \u228e Y do 5. z.space \u2190 z.space \u222a (x.space \u2229 y.space) 6. z.value \u2190 x.value 7. Z \u2190 Z \u222a z 8. returnZ\nBy definition, we only consider the elements x \u2208 X that intersect with some elements y \u2208 Y (line 2). For each such element x, we create an element z with the same value (line 6) but with a space restricted to the intersection between x and all y \u2208 Y (lines 4\u20135). Intuitively, restriction is the intersection of geometrical spaces, and it leaves the values unchanged. Thus, the algebraic properties of restriction are derived only from the properties of intersection of spaces.\nTheorem 11. Let Fv be a family of decision spaces such that for every X \u2208 Fv, there is exactly one element x \u2208 X such that V(x) = v and \u2200a \u2208 A(x), S (x, a) = \u221e. Then, every identity element E \u2208 D such that X \u2299 E = E \u2299 X = X is generated by Fv. The number of elements of Fv is infinite.\nProof. A decision space X is not restricted by a decision space Y only if all elements in Y cover a space at least as large as the space covered by X, so a trivial identity is the decision space with only one element covering an infinite space. As the value of this element does not matter, we can define a family taking its value v as a parameter. The set of all possible values v can be infinite because the values are taken from a continuous range; thus, Fv contains an unbounded number of identity decision spaces.\nTheorem 12. The \u2299 operator is idempotent as X \u2299 X = X.\n16\nProof. Let X and Y be two decision spaces. If X = Y then \u2200x \u2208 X, x\u228eY = y such that \u2200a \u2208 A(x), low(a, x) = low(a, y) and up(a, x) = up(a, y). Thus, each element z is created with exactly the space and value of an x (lines 4\u20137), and only one z is created for each x (line 2). Hence the result Z is the same as X.\nTheorem 13. The operator \u2299 : (D,D) 7\u2192 D is associative: (X \u2299 Y) \u2299 Z = X \u2299 (Y \u2299 Z) for all decision spaces X, Y, Z \u2208 D.\nProof. As the values do not matter, the restriction can be considered to be an intersection of spaces, which is associative."}, {"heading": "7.2. Composite operators", "text": "The merge (\u2297) and restriction (\u2299) operators can be composed to create a variety of useful operators. When the merge operator creates an element z \u2208 Z = X \u2297 Y, z can be created from an x \u2208 X, a y \u2208 Y, or both an x \u2208 X and a y \u2208 Y. The \u2299 operator can be used to restrict the results of a merge operation to include only elements z \u2208 Z that are created from both an x \u2208 X and a y \u2208 Y. This change has a significant impact: an element derived from only one element is not as precise as an element derived from two, because in the latter case a consensus is obtained through a weighted formula. Thus, this restricted form of merging is less sensitive to noise and, as we know that all elements in Z are derived from exactly two elements, we can have the same confidence in the predictions of all elements in Z. A merge that provides the same confidence in the prediction of each element is obtained through the following composite operator \u2295.\nDefinition 13. The operator \u2295 : (X, Y) 7\u2192 Z is defined by X \u2295 Y = (X \u2297 Y) \u2299 X \u2299 Y.\nThis definition ensures that the values are correctly computed based on the specialization of each element of X and Y, and then the overall space is reduced to the intersections with X and Y. A stricter definition is given by the following composite operator \u2299\u0304 that not only restricts the merging to the elements that intersect, but computes the values using only common spaces of attributes. Any part of an element that lies outside the intersection will be ignored by \u2299\u0304 when measuring the specialization, and the values are computed based on the same space.\nDefinition 14. The operator \u2299\u0304 : (X, Y) 7\u2192 Z is defined by X\u2299\u0304Y = (X \u2299 Y) \u2297 (Y \u2299 X).\nThe choice between \u2299\u0304 and \u2295 can be based on the application. Both \u2299\u0304 and \u2295 have the properties of idempotency, associativity, non-commutativity, and unique identity element."}, {"heading": "8. Conclusions", "text": "Classifiers are found in a variety of settings, such as sensor networks. In these settings, each entity (e.g., a sensor) deduces a classifier from its observations (i.e., a dataset of example instances). These classifiers must be merged to obtain a global view. However, merging has not been defined for several types of classifiers, such as decision trees. Furthermore, the classifiers that have to be merged can be of different types, for example, when several generations of sensors are creating classifiers.\nIn this paper, we introduced decision spaces as a framework for examining the properties of operations over classifiers, and we defined a merge operation that handles possibly different classifiers. Our methods are designed for a pure meta-learning framework in which classifiers are merged instead of being stored separately, and observations are never exchanged. We use algebraic methods to prove several desirable properties of the merge operator. We also show that the operator is not associative: the result of merging several classifiers depends on the order that the merge operator is applied. This can be the desired behaviour in a situation such as a data-stream: if the operator is applied as soon as a classifier is received, then the result will be biased in favour of recent trends. However, other types of biases may be needed, and no bias should also be possible for an application such as a distributed database in which the underlying data is homogeneous. We introduced two approaches to achieve different biases. The first one uses storage space flexibly to customize the bias. The second approach results in no bias, thereby making the operator associative, and uses no space.\n17\nWe showed that other operators can be defined in our framework, and used algebraic methods to establish their behaviours. In particular, we defined a restriction operator, which can be used for time series to analyze a sequence of classifiers, and can be used in combination with the merge operator for application-specific needs.\nThe decision space framework relies on the intersection of geometrical elements. However, intricate shapes can result from the intersections of large numbers of attributes and/or classifiers. This can affect the space complexity since the shapes may require more coordinates to be described, and it can affect the time complexity as the shapes become harder to intersect. One direction for further research is the use of simplified shapes to reduce the time and space complexities. This suggests several interesting questions: how do the time and space complexities depend on the type of geometrical elements that are allowed? How does the accuracy of the results depend on the simplification that is chosen and when it is applied?\nFurther questions arise when considering that uncertainty is found at many levels in real-world scenarios. We distinguish three broad types of uncertainty. Firstly, there can be uncertainty about the concept that the elements are predicting. For example, consider the task of predicting the literary genre of an author based on dimensions measuring cultural features. Since the definition of a genre may not be clear, fuzzy values may have to be assigned to elements, and the problem becomes one of combining fuzzy values.\nSecondly, there can be uncertainty about the value contained in one element (i.e., its class distribution vector). Consider the case in which two elements A and B are merged: element A predicts classes Yes and No with the same probability, and element B predicts the class Yes with 80% probability and No with 20% probability. A mechanism is needed to detect that element A cannot make a reliable prediction, so the contribution of element B should be increased. Confidence transformations provide such a mechanism by transforming a class distribution vector into a measure representing its confidence [18]. There are several approaches to using these transformations when combining two elements in this framework. In Figure 8(a), two values (i.e., class distribution vectors) are combined based solely on the space of the elements to which they belong, ignoring their confidence measures. In Figure 8(b), the values are transformed to confidence measures which are then used to generate the combined value. Another possibility is to use the confidence measures to supplement the raw values (Figure 8(c)).\nA confidence transformation can be specific to a given classifier (i.e., we interpret the reliability of a value differently depending on the type of model that generated it). However, that specificity is lost when we combine a set of classifiers: how should we interpret the result coming from a classifier that combines a C4.5 decision tree with a support vector machine? If one general confidence transformation is used for such models, then how does the performance change when a large number of models are combined based on initially large groupings (so that specific transformations can be used)? Is it possible to not only combine models, but also combine the transformations associated with them?\nThirdly, there can be uncertainty about the space covered by an element. For example, consider the classification of soil types on a map. In one area, samples have been taken and the category has been determined. It is known that beyond that area, there are no geological faults and it can thus be speculated that the category does not change for a few dozen meters beyond the sampled area. This type of spatial vagueness is essential in geographical information systems, and frameworks have been proposed to address it. We can adopt the idea of an algebra for vague spatial data from [21] (which further highlights the connection of our approach with spatial algebras), by tagging each element of a decision space as being either guaranteed or conjectured. The tag for elements resulting from the union, intersection, or difference of two elements can be determined by using the same tables as in [21]. However, what should we do when merging an uncertain element with a guaranteed element? Should we omit the value from the uncertain element, or should we produce a weighted combination giving more weight to the value from the guaranteed element? The answers to these questions are application-specific, and the important advantage of our framework lies in its ability to mathematically express the consequences of each choice.\n18"}, {"heading": "Acknowledgements", "text": "We would like to thank Martin Ester, Binay Bhattacharya, and Oliver Schulte for helpful discussions. This research was supported by NSERC of Canada."}], "references": [{"title": "Wireless sensor networks: A survey", "author": ["I.F. Akyildiz", "W. Su", "Y. Sankarasubramaniam", "E. Cayirci"], "venue": "Computer Networks 38 ", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2002}, {"title": "Hierarchical decision tree induction in distributed genomic databases", "author": ["A. Bar-Or", "D. Keren", "A. Schuster", "R. Wolff"], "venue": "IEEE Trans. Knowl. Data Eng. 17 ", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2005}, {"title": "A training algorithm for optimal margin classifiers", "author": ["B.E. Boser", "I.M. Guyon", "V.N. Vapnik"], "venue": "in: D. Haussler (Ed.), 5th Annual ACM Workshop on COLT, ACM Press, Pittsburgh, PA", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1992}, {"title": "Random forests", "author": ["L. Breiman"], "venue": "Machine Learning 45 ", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2001}, {"title": "Toward parallel and distributed learning by meta-learning - working notes", "author": ["P. Chan", "S.J. Stolfo"], "venue": "in: AAAI Workshop on Knowledge Discovery in Databases, AAAI", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1993}, {"title": "G", "author": ["J.P.C. Cordeiro"], "venue": "Camara, U.M. de Freitas, F. Almeida, Yet another map algebra, Geoinformatica 13 ", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2009}, {"title": "Incremental rule learning and border examples selection from numerical data streams", "author": ["F.J. Ferrer-Troyano", "J.S. Aguilar-Ruiz", "J.C.R. Santos"], "venue": "J. UCS 11 ", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2005}, {"title": "Map algebra extended with functors for temporal data", "author": ["A.U. Frank"], "venue": "Perspectives in Conceptual Modeling (Lecture Notes in Computer Science) 3770 ", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2005}, {"title": "Separate-and-conquer rule learning", "author": ["J. F\u00fcrnkranz"], "venue": "Artificial Intelligence Review 13 ", "citeRegEx": "10", "shortCiteRegEx": null, "year": 1999}, {"title": "A framework for measuring differences in data characteristics", "author": ["V. Ganti", "J. Gehrke", "R. Ramakrishnan", "W.Y. Loh"], "venue": "Journal of Computer and System Sciences 64 ", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2002}, {"title": "Introduction to the special issue on meta-learning", "author": ["C. Giraud-Carrier", "R. Vilalta", "P. Brazdil"], "venue": "Machine Learning 54 ", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2004}, {"title": "Decision tree learning on very large data sets", "author": ["L.O. Hall", "N. Chawla", "K.W. Bowyer"], "venue": "in: Proc. of the International Conference on Systems, Man, and Cybernetics, volume 3, IEEE", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1998}, {"title": "Knowledge Discovery with Support Vector Machines", "author": ["L.H. Hamel"], "venue": "Wiley-Interscience", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2009}, {"title": "Data Mining: Concepts and Techniques", "author": ["J. Han", "M. Kamber"], "venue": "2nd edition, Morgan Kaufmann", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2006}, {"title": "Multiple classifier combination: Lessons and the next steps", "author": ["T.K. Ho"], "venue": "Multiple classifier combination: Lessons and the next steps, World Scientific Publishing", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2002}, {"title": "Combining pattern classifiers: methods and algorithms", "author": ["L.I. Kuncheva"], "venue": "John Wiley and Sons", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2004}, {"title": "Confidence transformation for combining classifiers", "author": ["C.L. Liu", "H. Hao", "H. Sako"], "venue": "Pattern Anal Applic 7 ", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2004}, {"title": "Symbolic computation and automated reasoning", "author": ["A. Meier", "V. Sorge"], "venue": "Symbolic computation and automated reasoning, A. K. Peters, Ltd.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2001}, {"title": "Data Streams: Algorithms and Applications", "author": ["S. Muthukrishnan"], "venue": "volume 1:2, Now Publishers", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2005}, {"title": "Vasa: An algebra for vague spatial data in databases", "author": ["A. Pauly", "M. Schneider"], "venue": "Information Systems 35 ", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2010}, {"title": "Mapscript: a map algebra programming language incorporating neighborhood analysis", "author": ["D. Pullar"], "venue": "Geoinformatica 5 ", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2001}, {"title": "Improved use of continuous attributes in c4.5", "author": ["J. Quinlan"], "venue": "Journal of Artificial Intelligence Research", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 1996}, {"title": "Distributed prediction from vertically partitioned data", "author": ["D.B. Skillicorn", "S.M. McConnell"], "venue": "J. Parallel. Distrib. Comput. 68 ", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2008}, {"title": "A map algebra", "author": ["C.D. Tomlin"], "venue": "in: Proceedings of the 1983 Harvard Computer Graphics Conference,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 1983}, {"title": "Arbiter meta-learning with dynamic selection of classifiers and its experimental investigation", "author": ["A. Tsymbal", "S. Puuronen", "V. Terziyan"], "venue": "in: J. Eder, I. Rozman, T. Welzer (Eds.), Advances in Databases and Information Systems, Third East European Conference, volume 1691 of Lecture Notes in Computer Science, Springer", "citeRegEx": "27", "shortCiteRegEx": null, "year": 1999}, {"title": "A perspective view and survey of metalearning", "author": ["R. Vilalta", "Y. Drissi"], "venue": "Artificial Intelligence Review 18 ", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2002}, {"title": "Methods of combining multiple classifiers and their application to handwriting recognition", "author": ["L. Xu", "A. Krzyzak", "C.Y. Suen"], "venue": "IEEE Transactions on Systems, Man, and Cybernetics 22 ", "citeRegEx": "29", "shortCiteRegEx": null, "year": 1992}], "referenceMentions": [{"referenceID": 15, "context": "These ways have been grouped differently, but a key distinction can be found between fusion and selection ( [17], p.", "startOffset": 108, "endOffset": 112}, {"referenceID": 15, "context": "This is typically reflected in approaches that weight the outputs of the classifiers depending on the instance being classified [17].", "startOffset": 128, "endOffset": 132}, {"referenceID": 4, "context": ", pure meta-learning [6, 28, 12]), or requires access to the", "startOffset": 21, "endOffset": 32}, {"referenceID": 25, "context": ", pure meta-learning [6, 28, 12]), or requires access to the", "startOffset": 21, "endOffset": 32}, {"referenceID": 10, "context": ", pure meta-learning [6, 28, 12]), or requires access to the", "startOffset": 21, "endOffset": 32}, {"referenceID": 14, "context": "Most of the previously proposed solutions have been application-specific and were validated through experiments, leading researchers to suggest that questions about combining classifiers are (still) open \u201cbecause we do not yet have a scientific understanding of the classifier combination mechanisms\u201d [16].", "startOffset": 301, "endOffset": 305}, {"referenceID": 18, "context": "This can be a desirable behaviour in settings such as data streams [20], in which the distribution changes over time and the most recently received data is considered to be the most representative of current trends.", "startOffset": 67, "endOffset": 71}, {"referenceID": 23, "context": "In the early 1980s, Tomlin proposed to consider maps as two-dimensional arrays and to design script-like languages to manipulate them in GIS [26].", "startOffset": 141, "endOffset": 145}, {"referenceID": 5, "context": "Thus, map algebras are specialized programming languages for manipulating the cells of grids, which now offer the possibility to process maps within GIS using cellular automata or image-processing techniques [7, 22].", "startOffset": 208, "endOffset": 215}, {"referenceID": 20, "context": "Thus, map algebras are specialized programming languages for manipulating the cells of grids, which now offer the possibility to process maps within GIS using cellular automata or image-processing techniques [7, 22].", "startOffset": 208, "endOffset": 215}, {"referenceID": 7, "context": "While these algebras can be used to combine maps [9], there is no (mathematically proven) control of the impact that each map has on the final combination.", "startOffset": 49, "endOffset": 52}, {"referenceID": 0, "context": "Wireless sensor networks [2] are a natural application for our approach.", "startOffset": 25, "endOffset": 28}, {"referenceID": 3, "context": "This richness may come at a cost in some classifiers: for example, a model derived using random forest classifiers [5] may be heavier than its training data, and would not be appropriate for wireless sensor networks.", "startOffset": 115, "endOffset": 118}, {"referenceID": 13, "context": ", to deduce an approximation of f given a set of instances, are [15, 14]", "startOffset": 64, "endOffset": 72}, {"referenceID": 12, "context": ", to deduce an approximation of f given a set of instances, are [15, 14]", "startOffset": 64, "endOffset": 72}, {"referenceID": 2, "context": "It is also possible to obtain non-linear classifications using the kernel method [4].", "startOffset": 81, "endOffset": 84}, {"referenceID": 21, "context": "A decision tree learner [23] applies a divide-andconquer technique to recursively split the data using the value of an attribute while maximizing a metric such as the information gain or Gini index.", "startOffset": 24, "endOffset": 28}, {"referenceID": 6, "context": "This is commonly referred to as a rule set [8].", "startOffset": 43, "endOffset": 46}, {"referenceID": 22, "context": "computation units, either by providing them with subsets of observations or subsets of attributes (vertical partitioning [24]).", "startOffset": 121, "endOffset": 125}, {"referenceID": 1, "context": "A number of researchers have focussed on merging decision trees: it was noted in [3] that \u201ca kind of decision tree induction [that is] efficient in a wide area system employs meta-learning, [in which] each computer induces a decision tree based on its local data and then the different models are merged to form the final tree\u201d.", "startOffset": 81, "endOffset": 84}, {"referenceID": 11, "context": "For example, it has been proposed [13] to transform decision trees into the sets of rules that they represent and to merge those sets.", "startOffset": 34, "endOffset": 38}, {"referenceID": 11, "context": "However, there are two potential problems with the design of the heuristic proposed in [13].", "startOffset": 87, "endOffset": 91}, {"referenceID": 24, "context": "For example, arbiter meta-learning [27] is a technique that merges classifiers in a hierarchical way.", "startOffset": 35, "endOffset": 39}, {"referenceID": 9, "context": "Ganti and colleagues [11] focused on a different problem: they examined how one could quantify the difference between two datasets by analyzing their models, which can be used to determine whether a model should be updated.", "startOffset": 21, "endOffset": 25}, {"referenceID": 2, "context": "Further research could remove the restriction to polytopes to generalize our approach to handle other classifiers such as SVMs with non-linear kernels [4].", "startOffset": 151, "endOffset": 154}, {"referenceID": 26, "context": "In Xu\u2019s categorization of the outputs used to combine classifiers, our requirement is the most universal (Type 1) [29].", "startOffset": 114, "endOffset": 118}, {"referenceID": 8, "context": "Intuitively, a cut in the space along the border of an element, either vertical or horizontal, should not cut any element [10].", "startOffset": 122, "endOffset": 126}, {"referenceID": 6, "context": "It can be an interval such as [8, 10], or a union of intervals.", "startOffset": 30, "endOffset": 37}, {"referenceID": 8, "context": "It can be an interval such as [8, 10], or a union of intervals.", "startOffset": 30, "endOffset": 37}, {"referenceID": 15, "context": "In these schemes, all classifiers contribute to the outcome of a given space space with weights based on their competence for that space [17].", "startOffset": 137, "endOffset": 141}, {"referenceID": 17, "context": "Therefore, (D,\u2297) is a unital, idempotent, and commutative magma (see [19] for a brief review of algebraic structures such as magmas).", "startOffset": 69, "endOffset": 73}, {"referenceID": 16, "context": "Confidence transformations provide such a mechanism by transforming a class distribution vector into a measure representing its confidence [18].", "startOffset": 139, "endOffset": 143}, {"referenceID": 19, "context": "We can adopt the idea of an algebra for vague spatial data from [21] (which further highlights the connection of our approach with spatial algebras), by tagging each element of a decision space as being either guaranteed or conjectured.", "startOffset": 64, "endOffset": 68}, {"referenceID": 19, "context": "The tag for elements resulting from the union, intersection, or difference of two elements can be determined by using the same tables as in [21].", "startOffset": 140, "endOffset": 144}], "year": 2015, "abstractText": "In distributed classification, each learner observes its environment and deduces a classifier. As a learner has only a local view of its environment, classifiers can be exchanged among the learners and integrated, or merged, to improve accuracy. However, the operation of merging is not defined for most classifiers. Furthermore, the classifiers that have to be merged may be of different types in settings such as ad-hoc networks in which several generations of sensors may be creating classifiers. We introduce decision spaces as a framework for merging possibly different classifiers. We formally study the merging operation as an algebra, and prove that it satisfies a desirable set of properties. The impact of time is discussed for the two main data mining settings. Firstly, decision spaces can naturally be used with non-stationary distributions, such as the data collected by sensor networks, as the impact of a model decays over time. Secondly, we introduce an approach for stationary distributions, such as homogeneous databases partitioned over different learners, which ensures that all models have the same impact. We also present a method that uses storage flexibly to achieve different types of decay for non-stationary distributions. Finally, we show that the algebraic approach developed for merging can also be used to analyze the behaviour of other operators.", "creator": "LaTeX with hyperref package"}}}