{"id": "1505.01620", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "7-May-2015", "title": "Structure Formation in Large Theories", "abstract": "structuring theories is one of the main approaches to reduce the combinatorial explosion associated with reasoning systems and exploring large difference theories. in the past we initially developed the notion of development graphs as a means to represent and maintain structured cultivation theories. later in this empirical paper we present a methodology and a resulting linguistic implementation to reveal the hidden structure of flat mat theories by transforming them into detailed development graphs. we review our approach using plain tstp - representations resulting of mizar articles obtaining more structured and also more concise theories.", "histories": [["v1", "Thu, 7 May 2015 08:16:19 GMT  (37kb,D)", "http://arxiv.org/abs/1505.01620v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI", "authors": ["serge autexier", "dieter hutter"], "accepted": false, "id": "1505.01620"}, "pdf": {"name": "1505.01620.pdf", "metadata": {"source": "CRF", "title": "Structure Formation in Large Theories", "authors": ["Serge Autexier", "Dieter Hutter"], "emails": ["serge.autexier@dfki.de", "dieter.hutter@dfki.de"], "sections": [{"heading": "1 Introduction", "text": "It has been long recognized that the modularity of specifications is an indispensable prerequisite for an efficient reasoning in complex domains. Algebraic specification techniques provide appropriate frameworks for structuring complex specifications and the authors introduced the notion of an development graph [5,1,6] as a technical means to work with and reason about such structured specifications. While its use presupposes the development of theories having the intended structures already in mind, there are various applications of Formal Methods in which theories are automatically generated in an entirely unstructured representation. Thus, there is a need for a computer-aided structure formation for large theories, which allows for an efficient reasoning in such theories.\nIn this paper we present an initial approach to support structure formations in large unstructured specifications. The idea is to provide a calculus and a corresponding methodology to crystalize intrinsic structures hidden in a specification and represent them explicitly in terms of development graphs. Step by step, the specification is split into different nodes resulting in increasingly richer development graphs. On the opposite, common concepts that are scattered in different specifications are identified and unified in a common theory.\nWe start with a discussion on syntactical properties to measure the appropriateness of a structuring and specify invariants underlying a structure formation process. Based on this general framework we present a calculus (and heuristics to guide this calculus) to transform development graphs in order to enrich the explicitly given structure. We review our framework with the help of the Mizar Mathematical Library (http://www.mizar.org/) providing hundreds of articles which are subject to our structure formation process.\n? The final publication is available at http://link.springer.com as part of the proceedings of the Conference on Intelligent Computer Mathematics 2015.\nar X\niv :1\n50 5.\n01 62\n0v 1\n[ cs\n.L O\n] 7\nM ay\n2 01\n5"}, {"heading": "2 Development Graphs for Structure Formation", "text": "We base our framework on the notions of development graphs (and thus on the notion of institutions [4]) to specify and reason about structured specifications. Development graphs D are acyclic, directed graphs \u3008N ,L\u3009, the nodes N denote individual theories and the links L indicate theory inclusions with respect to signature morphisms attached to the links. Each node N \u2208 N of the graph is a tuple (sigN , axN , lemN ) such that sigN is called the local signature of N , axN a set of local axioms of N , and lemN a set of local lemmas of N . L is a set of global definition links M\n\u03c3 +3 N. Each link imports the mapped theory of M (by the signature morphism \u03c3) as part of the theory of N . A node N is globally reachable from a node M via a signature morphism \u03c3, D `M _? \u03c3 +3 N for short, iff 1. either M = N and \u03c3 = id, or 2. M \u03c3\u2032 +3 K \u2208 L, and D ` K _? \u03c3 \u2032\u2032 +3 N , with \u03c3 = \u03c3\u2032\u2032 \u25e6 \u03c3\u2032. The global signature (global axioms and global lemmata, respectively) of a node N \u2208 N is the union of its local signature (local axioms and local lemmata) and the mapped global signatures of all nodes from which N is globally reachable. A node is valid if all signature symbols occurring in its global axioms and lemmata are declared in its global signature. A development graph is well-defined, if all its nodes are valid.\nThe maximal nodes (root nodes) dDe of a graph D are all nodes without outgoing links. DomD(N) := SigD(N) \u222a AxD(N) \u222a LemD(N) is the set of all signature symbols, axioms and lemmata visible in a node N . The local domain of N , domN := sigN \u222a axN \u222a lemN is the set of all local signature symbols, axioms and lemmata of N . The imported domain ImportsD(N) of N in D is the set of all signature symbols, axioms and lemmata imported via incoming definition links. DomD = \u22c3 N\u2208N DomD(N) is the set of all signature symbols, axioms and lemmata occurring in D. Analogously we define SigD, AxD, and LemD. DomdDe = \u22c3 N\u2208dDeDomD(N) is the set of all signature symbols, axioms and lemmata occurring in the maximal nodes of D. Given a node N \u2208 N its associated class ModD(N) of models (or N -models for short) consists of those SigD(N)-models n for which (i) n satisfies the local axioms axN , and (ii) for each K \u03c3 +3 N \u2208 S, n|\u03c3 is a K-model. In the following we denote the class of \u03a3-models that fulfill the \u03a3-sentences \u03a8 by Mod\u03a3(\u03a8). Given a signature \u03a3 and Ax,Lem \u2286 Sen(\u03a3), a support mapping Supp for Ax and Lem assigns each lemma \u03d5 \u2208 Lem a subset H \u2286 Ax \u222a Lem such that (i) Mod\u3008sym(H)\u222asym(\u03d5)\u3009\u03a3 (H) |= \u03d5 1 (ii) The relation @\u2286 (Ax\u222aLem)\u00d7Lem with \u03a6 @ \u03d5 \u21d4 (\u03a6 \u2208 Supp(\u03d5) \u2228 \u2203\u03c8.\u03a6 \u2208 Supp(\u03c8) \u2227 \u03c8 @ \u03d5) is a well-founded strict partial order. If D is a development graph, then a support mapping Supp is a support mapping for D iff for all N \u2208 D Supp is a support mapping for AxD(N) and LemD(N).\nWe will now formalize the requirements on development graphs that reflect our intuition of an appropriate structuring for formal specifications in the following principles.\n1 where \u3008S\u3009\u03a3 denotes the smallest valid sub-signature of \u03a3 containing S.\nThe first principle is semantic appropriateness, saying that the structure of the development graph should be a syntactical reflection of the relations between the various concepts in our specification. This means that different basic specifications are located in different nodes of the graph and the links of the graph reflect the logical relations between these specifications. The second principle is closure saying, for instance, that deduced knowledge should be located close to the axioms guaranteeing the proofs. Also the specification defined by the theory of an individual node of a development graph should have a meaning of its own and provide some source of deduced knowledge. The third principle is minimality saying that each concept (or part of it) is only represented once in the graph. When splitting a monolithic theory into different theories common foundations for these theories should be (syntactically) shared between them by being located at a unique node of the graph.\nWe now translate these principles into syntactical criteria on development graphs and into procedures of how to transform or refactor development graphs. In a first step we formalize technical requirements to enforce the minimalityprinciple in terms of development graphs. Technically, we demand that each signature symbol, each axiom and each lemma has a unique location in the development graph. When we enrich a development graph with more structure we forbid to have multiple copies of the same definition in different nodes. We therefore require that we can identify for a given signature entry, axiom or lemma a minimal theory in a development graph and that this minimal theory is unique. We define:\nDefinition 1 (Providing Nodes). Let \u3008N ,L\u3009 be a development graph. An entity e is provided in N \u2208 N iff e \u2208 Dom\u3008N ,L\u3009(N) and \u2200M\n\u03c3 +3 N. e 6\u2208"}, {"heading": "Dom\u3008N ,L\u3009(M). Furthermore,", "text": "1. e is locally provided in N iff additionally e \u2208 domN holds. 2. e is provided by a link l : M\n\u03c3 +3 N iff e is not locally provide in N and \u2203e\u2032 \u2208 Dom\u3008N ,L\u3009(M). \u03c3(e\u2032) = e holds. In this case we say that l provides e from e\u2032. e is exclusively provided by l iff e is not provided by any other link l\u2032 \u2208 L.\nThe closure-principle demands that there are no spurious nodes in the graph not contributing anything new. We combine these requirements into the notion of location mappings:\nDefinition 2 (Location Mappings). Let D = \u3008N ,L\u3009 be a development graph. A mapping locD : DomD \u2192 N is a location mapping for D iff 1. locD is surjective (closure) 2. \u2200N \u2208 N . \u2200e \u2208 domN . locD(e) = N 3. \u2200e \u2208 DomD. locD(e) is the only node providing e (minimality) For a given locD we define loc \u22121 D : N \u2192 2DomD by\nloc\u22121D (N) := {e \u2208 DomD|locD(e) = N}. We write loc and loc\u22121 instead of locD and loc \u22121 D if D is clear from the context.\nBased on the notion of location mappings we formalize our intuition of a structuring. The idea is that the notion of being a structuring constitutes the\ninvariant of the structure formation process and guarantees both, requirements imposed by the minimality-principle as well as basic conditions on a development graph to reflect a given formal specification.\nDefinition 3 (Structuring). Let D = \u3008N ,L\u3009 be a valid development graph, loc : DomD \u2192 N , \u03a3 \u2208 |Sign|, Ax,Lem \u2286 Sen(\u03a3) and Supp be a support mapping for D. Then (D, loc,Supp) is a structuring of (\u03a3,Ax,Lem) iff 1. loc is a location mapping for D. 2. let DomdDe = \u03a3\n\u2032 \u222aAx\u2032 \u222a Lem\u2032 then \u03a3 = \u03a3\u2032, Ax = Ax\u2032 and Lem \u2286 Lem\u2032. 3. \u2200\u03c6 \u2208 LemD . \u2200\u03c8 \u2208 Supp(\u03c6). \u2203\u03c3. loc(\u03c8) _? \u03c3 +3 loc(\u03c6) \u2227 \u03c3(\u03c8) = \u03c8"}, {"heading": "3 Refactoring Rules", "text": "In the following we present the transformation rules on development graphs that transform a structuring again into a structuring. Using these rules we are able to structure the initially trivial development graph consisting of exactly one node that comprises all given concepts step by step. This initial development graph consisting of exactly one node satisfies the condition of a structuring provided that we have an appropriate support mapping at hand.\nWe define four types of structuring-invariant transformations: (i) horizontal splitting and merging of development graph nodes, (ii) vertical splitting and merging of development graph nodes, (iii) factorization and multiplication of development graph nodes, and (iv) removal and insertion of specific links. Splitting and merging as well as factorization and multiplication are dual operations. For lack of space and because we are mainly interested in rules increasing the structure of a development graph we will omit the formal specification of the merging and multiplication rules here.\nHorizontal Split. The first refactoring rule aims at the separation of specifications in independent theories. In terms of the development graph a node is replaced by a series of independent nodes; each of them contains a distinct part from a partitioning of the specification of the original node. In order to ensure a valid new development graph, each of the new nodes imports the same theories as the old node and contributes to the same theories as the old node did. To formalize this rule we need constraints on how to split a specification in different chunks such that local lemmata are always located in a node which provides also the necessary axioms and lemmata to prove it.\nDefinition 4. Let S = (D, loc,Supp) be a structuring of (\u03a3,Ax,Lem) and N \u2208 ND. A partitioning P for N is a set {N1, . . . , Nk} with k > 1 such that 1. sigN = sigN1 ] . . . ] sigNk , axN = axN1 ] . . . ] axNk , lemN = lemN1 ] . . . ] lemNk 2. sigNi\u222aaxNi\u222alemNi 6= \u2205 for i = 1, . . . , k. A node Ni \u2208 P is lemma independent iff Supp(\u03c8) \u2229 (axN \u222a lemN ) \u2286 (axNi \u222a lemNi) for all \u03c8 \u2208 lemNi .\nDefinition 5 (Horizontal Split). Let S = (\u3008N ,L\u3009, loc,Supp) be a structuring of (\u03a3,Ax,Lem), P = {N1, . . . , Nk} be a partitioning for some node N \u2208 N such\nthat each Ni \u2208 P is lemma independent and loc\u22121(N) = domN . The horizontal split of S wrt. N and P is S \u2032 = (D\u2032, loc\u2032,Supp) with D\u2032 = \u3008N \u2032,L\u2032\u3009 where 1. N \u2032 := {N1, . . . , Nk} ] (N \\N) 2. L\u2032 := {M \u03c3 +3 M \u2032 \u2208 L|M 6= N \u2227M \u2032 6= N}\n\u222a {M \u03b8 +3 Ni|M \u03b8 +3 N \u2208 L, i \u2208 {1, . . . , k}} \u222a {Ni \u03c4|DomNi+3 M|N \u03c4 +3 M \u2208 L, i \u2208 {1, . . . , k}}\n3. loc\u2032(e) := Ni if e \u2208 domNi for some i \u2208 {1, . . . , k} and loc\u2032(e) := loc(e) otherwise. such that SigD\u2032(Ni) are valid signatures and axi, lemi \u2286 Sen(SigD\u2032(Ni)) for i = 1, . . . , k.\nVertical Split. Similar to a horizontal split we introduce a vertical split which divides a node into two nodes and locates one node on top of the other. While all outgoing links start at the top node, we are free to reallocate incoming links to either node.\nDefinition 6 (Vertical Split). Let S = (\u3008N ,L\u3009, loc,Supp) be a structuring of (\u03a3,Ax,Lem) and P = {N1, N2} be a partitioning for some N \u2208 N such that N1 is lemma independent. Then, the vertical split S wrt. N and P is S \u2032 = (D\u2032, loc\u2032,Supp) with D\u2032 = \u3008N \u2032,L\u2032\u3009 where\nN \u2032 :={N1, N2} ] (N \\N)\nL\u2032 :={M \u03c3 +3 M \u2032 \u2208 L|M 6= N \u2227M \u2032 6= N} \u222a {N1 id +3 N2}\n\u222a {M \u03c3 +3 N1 | M \u03c3 +3 N \u2208 L} \u222a {N2 \u03c3 +3 M | N \u03c3 +3 M \u2208 L}\nloc\u2032(e) = N2 if loc(e) = N and e \u2208 DomD \u2032(N2)\nN1 if loc(e) = N and e 6\u2208 DomD\u2032(N2) loc(e) otherwise\nsuch that SigD\u2032(Ni), i = 1, 2, are valid signatures and axi, lemi \u2286 Sen(SigD\u2032(Ni)), i = 1, 2. Conversely, S is a vertical merge of N1 and N2 in S \u2032."}, {"heading": "Vertical Split", "text": ""}, {"heading": "Vertical Merge", "text": "Example 1. We illustrate the horizontal and vertical split rules by considering a single theory axiomatizing a Field with binary operations + and \u00d7 consisting of a Distributivity axiom (\u03a6D := \u2200x, y, z.x\u00d7(y+z) = x\u00d7y+x\u00d7z) and the axioms of an Abelian Group for + and \u00d7, respectively (\u03a6+AG := \u2200x, y, z . x+(y+ z) = (x+ y) + z,\u2200x, y . x+ y = y+x, \u2200x . x+ 0 = x, \u2200x . x+ -(x) = 0 and \u03a6\u00d7AG := \u2200x, y, z . x\u00d7(y\u00d7 z) = (x\u00d7 y)\u00d7 z,\u2200x, y . x\u00d7 y = y\u00d7x, \u2200x . x\u00d7 1 = x, \u2200x . x\u00d7 inv(x) = 1). Assume axioms are contained in a single node Field, which forms a trivial structuring. In a first step we can split that node vertically by separating the distributivity axiom from the other axioms. In a second step we can separate the Abelian Group axioms for + and \u00d7 by a horizontal split. This is shown in the following Figure:\n\u03a6D \u03a6+AG \u03a6\u00d7AG\n(0) (1) Vertical Split\n(2) Horizontal Split\n\u03a6D\n\u03a6+AG, \u03a6 \u00d7 AG\nid\n\u03a6D\n\u03a6+AG \u03a6 \u00d7 AG\nid id\nFactorization. The factorization rule allows one to merge equivalent specifications into a single generalized specification and then to represent the individual ones as instantiations of the generalized specification. A precondition of this rule is that all individual specifications inherit the same (underlying) theories.\nDefinition 7 (Factorization). Let S = (\u3008N ,L\u3009, loc,Supp) be a structuring of (\u03a3,Ax,Lem). Let K1, . . . ,Kn,M1, . . . ,Mp \u2208 N with p > 1 such that sigMj \u222a axMj 6= \u2205 and \u2203\u03c3i,j . Ki \u03c3i,j +3 Mj \u2208 L for i = 1, . . . , n, j = 1, . . . , p.\nSuppose there are sets sig, ax and lem with (sig\u222a ax\u222a lem)\u2229DomD = \u2205 and signature morphisms \u03b81, . . . , \u03b8p and \u03c31, . . . , \u03c3n such that - \u2200e \u2208 DomD(Ki). \u03b8j(\u03c3i(e)) = \u03c3i,j(e) and \u03c3i,j(e) = e \u2228 \u03c3i,j(e) 6\u2208 DomD\n- sigMj \u2286 \u03b8j(sig) \u2286 DomD(Mj), axMj \u2286 \u03b8j(ax) \u2286 DomD(Mj) - \u2200e \u2208 lem holds \u2203l \u2208 {1, . . . p}. \u03b8l(e) \u2208 lemMl , \u03b8i(e) = \u03b8j(e) implies i = j and \u03b8j(e) \u2208 DomD implies loc(\u03b8j(e)) \u2208Mj\n- there is a support mapping SuppN for ax \u222a \u22c3 i=1,...,n \u03c3i(DomD(Ki)) and lem. Then S \u2032 = (\u3008N \u2032,L\u2032\u3009, loc\u2032,Supp\u2032) is a factorization of S wrt. M1, . . ., Mp and SuppN iff\nN \u2032 :={N} \u222a {Nj |j \u2208 {1, . . . p}} \u222a N \\ {M1, . . .Mp} with N = \u3008sig, ax, lem\u3009, Nj = \u3008\u2205, \u2205, lemMj \\ \u03b8j(lem)\u3009\nL\u2032 :={K \u03c3 +3 K \u2032 \u2208 L|K,K \u2032 6\u2208 {M1, . . .Mp}\n\u222a {Ki \u03c3i +3 N|Ki \u03c3i,j +3 Mj, j \u2208 {1, . . . p}, i \u2208 {1, . . . n}}\n\u222a {N \u03b8j +3 Nj|j \u2208 {1, . . . p}}\n\u222a {K \u03c4 +3 Nj|K \u03c4 +3 Mj \u2227 (\u2200i \u2208 {1, . . . n}.K 6= Ki \u2227 \u03c4 6= \u03c3i,j)\n\u222a {Nj \u03c4 +3 K|Mj \u03c4 +3 K \u2208 L, j \u2208 {1, . . . p}}\nloc\u2032(x) :=  N if x \u2208 DomD\u2032(N) \\ \u22c3 i=1,...,n DomD\u2032(Ki) Nj if x \u2208 DomD(Nj) and \u2200K \u03c3 +3 Nj. x 6\u2208 DomD\u2032(K)\nloc(x) otherwise.\nSupp\u2032 :=Supp \u222a SuppN .\nExample 2. Consider again our example a Field axioms, which we have transformed into the structuring (3) (p. 6). On the last structuring (3) we can apply the factorization rule to extract the general abelian group axioms (\u03a6\u25e6AG := \u2200x, y, z . x \u25e6(y \u25e6 z) = (x \u25e6 y) \u25e6 z,\u2200x, y . x \u25e6 y = y \u25e6x, \u2200x . x \u25e6 e = x, \u2200x . x \u25e6 i(x) = e) and obtain the respective axioms for + and \u00d7 by morphisms \u03c31 := \u25e6 7\u2192 +, e 7\u2192 0, i 7\u2192 \u2212 and \u03c32 := \u25e6 7\u2192 \u00d7, e 7\u2192 1, i 7\u2192 inv. This is illustrated in the following diagram and the final structuring contains 5 axioms and the initial structuring contained 9 axioms.\n\u03a6D\n\u03a6+AG \u03a6 \u00d7 AG\nid id\n\u03a6D\n\u2205 \u2205 id id\n\u03a6\u25e6AG\n\u03c31 \u03c32\n(3) (4) Factorization\nThe factorization rule only covers a sufficient criterion demanding that each theory imported by a definition link to one specification is also imported via definition links by all other specifications. The more complex case in which a theory is imported via a path of links can be handled by allowing one to shortcut a path in a single global link. This results in the following rule.\nDefinition 8 (Transitive Enrichment). Let S = (\u3008N ,L\u3009, loc,Supp) be a structuring of (\u03a3,Ax,Lem), K,N \u2208 N and there is a path K _? \u03c3 +3 N between both. Then, S \u2032 = (\u3008N ,L \u222a {K \u03c3 +3 N}\u3009, loc,Supp) is a transitive enrichment of D.\nDefinition links in a development graph can be redundant, if there are alternatives paths which have the same morphisms or if they are not used in any reachable node of the target. We formalize these notions as follows:\nDefinition 9 (Removable Link). Let S = (D, loc,Supp) (D = \u3008N ,L\u3009) be a structuring of (\u03a3,Ax,Lem). Let l \u2208 L and D\u2032 = \u3008N ,L\\{l}\u3009. l is removable from S and S \u2032 = (D\u2032, loc,Supp) is a reduction of S iff 1. \u2200l\u2032 : M \u03c3 +3 N. if l\u2032 provides exclusively \u03c3(e) from some e \u2208 DomD(M)\nthen e \u2208 DomD\u2032(N) and l 6= l\u2032; 2. \u2200e \u2208 DomD.\u2200M \u2208 dDe. if loc(e) _?\n\u03c3 +3M then there exists M \u2032 \u2208 dD\u2032e such that loc(e) _?\n\u03c3 +3M \u2032; 3. \u2200\u03c6 \u2208 LemD. Supp(\u03c6) \u2286 DomD\u2032(N) and \u2200SiglocD (N) \u2286 DomD\u2032(N).\nTheorem 1 (Structuring Preservation). Let S := (D, loc,Supp) (D = \u3008N ,L\u3009) be a structuring of (\u03a3,Ax,Lem). Then\n1. every horizontal split of S wrt. some N \u2208 N and partitioning P of N , 2. every vertical split of S wrt. some N \u2208 N and partitioning P of N , 3. every factorization of S wrt. nodes M1, . . .Mp \u2208 N , 4. every transitive enrichment of S, and 5. every reduction of S\nis a structuring of (\u03a3,Ax,Lem).\nThe theorem follows from the soundness proofs for each rule given in Appendix 6."}, {"heading": "4 Refactoring Process", "text": "In order to evaluate the refactoring rules on real theories we have implemented the development graphs and the rules in Scala2 and added support to read formulas in TSTP format [9] using the Java parser from [8]. The support mapping is given as an extra datastructure representing the information which formula has been used in the proof of a theorem. In the case of TSTP we extract that information from the files by using the names of the formulas. Since the TSTP format does not include signature declarations, we add declarations for all occurring symbols in a TSTP file in an initialization step. We used the untyped part of TSTP and hence the declarations only contain arity information but no types.\nThe refactoring rules are parameterized over the theories and possibly the subsets of the local signature, axioms and lemmata to split over. To compute the parametric information we provided some basic heuristic tactics. Using the support mapping, we define that an axiom (resp. lemma) depends on a symbol declaration, if the symbol occurs in the axiom (resp. lemma) and a lemma depends on another axiom or lemma, if the latter is in its support mapping. A symbol declaration is always independent. This dependency relation induces a partial order on the local domain of each node in a development graph.\nTactic for horizontal split. This rule requires the partitioning of the local signature, axioms and lemmas for a given theory into independent parts such that given the same imports than the original node, each part is a valid theory and lemma independent of the other part. We implemented a heuristic that given a local domain of some node, searches for a largest subset which has a non-empty intersection of its occurring symbols and supporting axioms and lemmata. If such a set exists, the largest such set is used to split the theory horizontally into that set and the rest.\nTactics for vertical split. The rule requires to find a subset of the local domain, which is independent of the rest and use it as the content of the lower theory. We implemented two heuristics to search for this subset. First, we consider all maximal elements wrt. the dependency relation and use that as content for the new upper theory constructed by vertical split. Second, we consider all minimal elements and use it as content for the lower theory constructed by vertical split. These two tactics allow one to incrementally split a theory into layered slices of the dependency relation.\nTactic for factorization. This rule requires to find isomorphic subsets in two different theories to factorize over. The notion of isomorphism between formulas is very strict, as we only search for renamings. Furthermore, we extended the isomorphism to the support mapping such that lemmata can only be identified with isomorphic lemmata which supporting axioms and lemmata are also isomorphic wrt. the same renaming. Thus, an axiom can never be factorized with a\n2 http://www.scala-lang.org/\nlemma and vice-versa. Even with that strict notion, computation of such subsets is already expensive. If the entire local domain of a given node is isomorphic to the local domain of the second node, both nodes are factorized according the definition of the factorization rule. If the identified subset in the first node does not cover the complete second node, we first try to split the second node to isolate the subset. To this end we first try to split the second node horizontally using the identified subset. If that fails, we first try to split vertically using the subset for the upper part and finally as the lower part. If one of these splittings was successful, the factorization is applied on the isolated part. Otherwise the factorization fails.\nIn addition to these main tactics, we have implemented the tactics to delete superfluous links as well as deletion of empty nodes which technically corresponds to vertically merging the empty node with their importing theories.\nAutomatic Procedure. In order to automate the theory formation process we have implemented the usual tacticals to describe more complex search behaviors. The tactic language is defined as follows starting from the basic tactics described above:\nT ::= SplitHorizontal |SplitV erticallyMaximal |SplitV erticallyMinimal | Factorize |RemoveSuperfluousEmptyTheories | T \u2217 |T + |T ;T |T onfail T\nThe tactics take as argument a structuring and if they could be applied, return a new structuring and otherwise fail. The tacticals for as many as possible iteration (\u2217), as many as possible but at least one (+) and sequencing (;) are standard. The tactical onfail executes the second tactic expression only if the first failed. Using this language we have implemented the following automatic procedure. The goal of the procedure is starting from an unstructured graph, i.e. a single theory containing all declarations, axioms and lemmata, to search for possibilities to factorize common patterns. Factorization is only possible if at least one application of the horizontal split rule was possible, which in turn may require the application of a preparatory vertical split. Following that initial part, we try to split further vertically using the maximal elements of the theory and finally removing the superfluous links and empty theories. Hence, the initial phase of the automation consists of\ninittac \u2261\u0307 ((SplitV erticallyMinimalEntries+;SplitHorizontally\u2217) onfail SplitHorizontally+); SplitV erticallyMaximalEntries\u2217; RemoveSuperfluousEmptyTheories\u2217\nThat initialization tactic succeeds only if at least one vertical split or one horizontal split could be done. Following that, we start to factorize. If at least one factorization was possible, we first clean up the structuring by removing superfluous links and empty theories before trying again to split vertically. The overall\ntactic is thus\ninittac; (Factorize+;RemoveSuperfluousEmptyTheories\u2217; SplitV erticallyMinimalEntries\u2217)\u2217"}, {"heading": "5 Evaluation", "text": "We have applied the factorization procedure presented in the previous section to TSTP versions of the Mizar library articles www.mizar.org, which have been created by Joseph Urban and are available at http://www.cs.miami.edu/~tptp/ MizarTPTP/TPTPArticles/. This is a collection of 922 files in TSTP format (www.cs.miami.edu/~tptp/TSTP) where theorems are annotated by information which theorems and axioms have been used in their proofs. The files consist of the axioms and theorems of each article including all directly included articles, but without transitive expansion of all inclusions. Hence, the knowledge in each file is already quite tailored to the knowledge necessary to define the additional mathematical concepts and to enable the proofs of the theorems. We have run the procedure on all examples with a timeout of 5 minutes each. The environment was a virtual machine with 4 virtual CPUs, 16GB RAM, under openSuSE 12.2 64-bit, running on a host with 2 Intel Xeon Westmere E5620 QuadCore CPUs, 2,4GHz, 96GB RAM and VMware ESXi 4.1.\nFor most articles no factorization has been found. However, there are 13 articles where factorization was possible, which are presented in the table Fig. 5. The results are summarized in the following format: for each file we indicate in the Axioms column the number of axioms in the initial development graph and the final development graph. Analogously, the Theorems column indicates the number of theorems respectively in the initial and the final development graph. The Reduction column indicates how much the factorization reduced the overall number of axioms and theorems. The last column indicates if the\nautomatic procedure had terminated within the 5 minutes time frame or timeout was reached.\nWhile reducing the number of axioms by factorization is already interesting in order to reduce the search space for automatic provers, reducing the number of theorems is more interesting as it means less theorems to prove. For all but one file where factorizations have been found, only axiom factorization have been found. However, in the article membered. top.rated obtained from the Mizar article [10] \u201cOn the Sets Inhabited by Numbers\u201d we could factorize 36 theorems into 16 theorems. On closer inspection this is not surprising because it concerned theorems about sets of reals, sets of rationals, sets of integers, sets of naturals and sets of complex numbers, all defined and proved according to the same schema. The resulting development graph is shown on the right side of Fig. 5, and the factor theory containing the 5 theorems, from which all others are obtained by renaming, is node 9 in gray/orange. The factorization is visible via\nthe 5 outgoing edges towards node 11 which are annotated with the respective morphisms."}, {"heading": "6 Related Work and Conclusion", "text": "Related to the structuring of theories, there is a large work on anti-unification, i.e. computing common generalizations of different formuala or theories (e.g. [2,7,3]). The resulting structuring approach is primarily botton-up and driven by the pure existence of anti-unifiers. In contrast, our approach is top-down as it introduces measures for the intended structuring (i.e. semantic appropriateness, closure and minimality) to guide the formation process. For example, we split up theories in smaller ones but that are still self-contained in the sense that each theorem of the original theory can be proven in one of the new (smaller) ones. Anti-unification is an important technique to test the applicability of the factorization rule, for instance, but applicability of a rule is not the driving force of the formation process.\nIn this paper we were concerned with trying to reveal shared definitions, axiomatizations and theorems in a given formal theory. Based on structurings which extend development graphs with notions to exclude redundancies and include dependency information, we presented a set of rules on structurings. We implemented the rules with simple heuristics to detect isomorphic subsets which are sufficient to find simple factorization and applied it to the TSTP formulations of the Mizar articles. Not surprisingly, not many factorizations could be found, which is due to Mizar\u2019s non-transitive reuse principle of other articles and the fact\nthat these were chosen carefully by the authors of the Mizar article. Moreover, the heuristics to compute isomorphic axioms and theorems was very restricted. However, a few factorizations could be found, and especially one were the number of theorems could be halved. This indicates that adding theory morphisms to the Mizar language may be useful, but that needs to be confirmed by further analysis of larger subsets. On the other hand the non-transitive import mechanisms of Mizar already seems to allow for a good organization of the knowledge. That kind of mechanism is typically not implemented in specification languages, but exists in development graphs in form of local axiom links.\nFuture work will consist of analyzing larger subsets of the whole Mizar library, i.e. sets of Mizar articles, for possible factorizations. We also plan to apply it to libraries of other proof assistants assuming we can get the dependency information which axioms/theorems have been used in which proof. Also other automation tactics and especially heuristics to identify isomorphic formulas need to be explored, as well as heuristics to identify subsets for horizontal and vertical splits. On a more theoretical level, we will investigate how axioms and theorems could be identified, in order to allow to factorize alternative axiomatizations of the same theory without losing information, such as, e.g., alternative forms to axiomatize groups. Finally, the whole system can be applied to any untyped first-order subset of TPTP theories to search for redundancies. However, the resulting development graphs cannot be saved as TPTP theories, as it does not support renaming. Hence, we propose to extend the TPTP language in that respect."}, {"heading": "Proof of Theorem 1 (Structure Preservation)", "text": ""}, {"heading": "Horizontal Split", "text": "It holds trivially that DomD = DomD\u2032 .\n\u2013 loc\u2032 is surjective because by construction each Ni, i = 1, . . . , k has a local entity. Furthermore, for each Ni and each e \u2208 domNi holds loc\u2032(e) = Ni by construction. Furthermore, since loc\u22121(N) = domN , none of the incoming links into N provided any entity, and consequently none of the incoming links into N1, . . . , Nk do. Hence, loc \u2032\u22121(Ni) = dom Ni , i = 1, 2 and since\ndomN := domN1 ] . . . ] domNk , loc\u2032(e) is unique for e \u2208 domN . \u2013 If N is not a top-level node in D, then DomdD\u2032e = DomdDe = \u03a3 ]Ax ]Lem\nbecause the domains of nodes reachable from N are not affected by the horizontal split. If N is a top-level node, then all Ni with 1 \u2264 i \u2264 k are top-level nodes. Since domN = domN1 ] . . . ] domNk and ImportsD(N) = ImportsD\u2032(N1) = . . . = ImportsD\u2032(Nk), it holds\nDomD(N) = dom N \u222a ImportsD(N) = dom N1 \u222a . . . domNk \u222a ImportsD(N) = domN1 \u222a . . . domNk \u222a ImportsD\u2032(N1) \u222a . . . \u222a ImportsD\u2032(Nk) = domN1 \u222a ImportsD\u2032(N1) \u222a . . . \u222a dom\nNk \u222a ImportsD\u2032(Nk) = DomD\u2032(N1) \u222a . . . \u222aDomD\u2032(Nk)\nThus, DomdD\u2032e = DomdDe = \u03a3 ]Ax ] Lem. \u2013 Assume \u03c6 \u2208 LemD and \u03c8 \u2208 Supp(\u03c6). If locD(\u03c8) 6= N and locD(\u03c6) 6= N , then\nboth locD(\u03c8), locD(\u03c6) are in D\u2032 and we consider p : locD(\u03c8) _? \u03c3 +3 locD(\u03c6). If N \u2208 p then p := [p1, M \u03b8 +3 N \u03c4 +3 M \u2032, p2] and by construction the path\n[p1, M \u03b8 +3 Ni \u03c4|DomNi+3 M \u2032, p2] are in D\u2032 for 1 \u2264 i \u2264 k. Since locD(\u03c8) 6= N , each \u03c4|DomNi behaves equivalently on the image of \u03c8 imported in Ni and hence locD\u2032(\u03c8) _? \u03c3\u2032 +3 locD\u2032(\u03c6) for some \u03c3\u2032 such that \u03c3\u2032(\u03c8) = \u03c3(\u03c8). If N 6\u2208 p, then p is also a path in D\u2032 and locD\u2032(\u03c8) _? \u03c3 +3 locD\u2032(\u03c6) holds trivially. If locD(\u03c6) = N then since all Ni are mutually lemma independent, without loss of generality we can assume \u03c6 \u2208 axN1 \u222a lemN1 and this loc\u2032D\u2032(\u03c6) = N1. If locD(\u03c8) = N , then \u03c8\n\u2032 \u2208 axN1 \u222a lemN1 because N1 is lemma independent. Thus, loc\u2032D\u2032(\u03c8) = N1 and loc \u2032 D\u2032(\u03c8) = N1 _? id +3 N1 = loc \u2032 D\u2032(\u03c6) holds trivially. Otherwise, locD(\u03c8) = loc \u2032 D\u2032(\u03c8) and since N was reachable from locD(\u03c8) by construction N1 is also reachable from loc \u2032 D\u2032(\u03c8)."}, {"heading": "Vertical Split", "text": "\u2013 First, we have to prove that loc\u2032 is a location mapping. loc\u2032 is surjective because by construction each node Ni (with i = 1, 2) has some local entity e \u2208 domNi . Thus loc\u2032(e) = Ni and Ni is in the range of loc\u2032. Furthermore, \u2200e \u2208 domNi . loc\u2032(e) = Ni holds by definition. Finally, let e \u2208 DomD\u2032 = DomD: loc \u2032(e) = Ni implies loc(e) = N and therefore there is no node in\nN \\ {N} which provides e. Furthermore, since N1 id +3 N2 \u2208 L\u2032, N1 and\nN2 cannot provide the same entity e. \u2013 By definition \u2200e \u2208 domNi implies loc\u2032(e) = Ni for i = 1, 2 in D\u2032. For all\nother nodes in D\u2032 \\{N1, N2} the property is inherited by (D, loc,Supp) being a structuring and loc(e) = loc\u2032(e) if loc(e) 6= N .\n\u2013 Since DomD(N) = DomD\u2032(N2) and N _? \u03c3 +3M \u2208 D iff N2 _? \u03c3 +3M \u2208 D\u2032 DomdDe = DomdD\u2032e. \u2013 Suppose \u03c6 \u2208 LemD, \u03c8 \u2208 Supp(\u03c6) with loc(\u03c6) = M and loc(\u03c8) = M \u2032. If N 6\u2208 {M,M \u2032} then loc\u2032(\u03c6) = M , loc\u2032(\u03c8) = M \u2032 and M _? \u03c3 +3M \u2032 in D\u2032 trivially. If M = N and M \u2032 6= N then loc\u2032(\u03c6) \u2208 {N1, N2}, and again Ni _?\n\u03c3 +3M \u2032 in D\u2032. The case of M 6= N and M \u2032 = N is proven analogously. We are left with the case of M = M \u2032 = N . SinceN1 is independent ofN2 , it holds that for all \u03c6\n\u2032 \u2208 axN1\u222alemN1 . Supp(\u03c6)\u2229 (axN2 \u222a lemN2) = \u2205. Thus \u03c6 \u2208 axN1\u222alemN1 implies that \u03c8 \u2208 axN1\u222alemN1 as well andN1 _?\nid +3 N1 holds trivially. ut"}, {"heading": "Factorization", "text": "\u2013 We have to prove that loc\u2032 is a location mapping. First, we prove that loc\u2032\nis surjective. For any node K \u2208 N \u2032 \\ {N,N1, . . . Np} loc\u22121(K) = loc\u22121(K) holds. Since sigN \u222a axN 6= \u2205 but (sigN \u222a axN ) \u2229 DomD = \u2205 it holds that sigN \u222a axN \u2286 loc\u2032\u22121(N). Furthermore, sigMj \u222a axMj \u2286 loc\u2032\u22121(Nj) since sigMj \u222a axMj \u2286 \u03b8j(sigN \u222a axN ) and \u03b8j(sigN \u222a axN ) \u2229 (sigN \u222a axN ) = \u2205. Second we have to prove \u2200K \u2208 N \u2032. \u2200e \u2208 domK . loc\u2032(e) = K holds. If K 6\u2208 {N,N1, . . . Np} then loc\u2032(e) = loc(e) = K. If K = N then domN \u2208 DomD\u2032(N) and dom\nN 6\u2208 DomD(Ki) for i = 1, . . . , n because domN \u2229 DomD = \u2205. Thus \u2200e \u2208 domN . loc\u2032D\u2032(e) = N . Finally, if K = Nj then domNj = lemMj \\ \u03b8j(lem) In particular, domNj \u2229 DomD\u2032(N) = \u2205 implying that loc\u2032D\u2032(e) = Nj for all e \u2208 domNj . Third, we prove that all e \u2208 DomDG\u2032 are provided by a unique node. The only interesting case is that e is provided by N or some Nj . In case of N both domN and also entries provided by some link from Ki are by definition not in DomD and thus not provided by any node already in D but by definition also not provided by Nj . It remains the case that an entry e is provided by two nodes Ni and Nj . Since all e \u2208 DomDG were provided by a unique node, this implies that e has to be a mapped lemma of N but that violates the precondition that each \u03b8i has to map e into a different entity.\n\u2013 Next we prove that D and D\u2032 coincide in the entities they provide at their maximal nodes. Since N is not a maximal node, it is sufficient to prove that Nj and Mj coincide in their provided entities:"}, {"heading": "DomD\u2032(Nj) = lem", "text": "Mj \\ \u03b8j(lem) \u222a \u22c3 {\u03c3(DomD\u2032(K)) | K \u03c3 +3 Nj}\n= lemMj \\ \u03b8j(lem) \u222a \u22c3 {\u03c3(DomD\u2032(K)) | K \u03c3 +3 Nj,K 6= N}\n\u222a \u03b8j(sig) \u222a \u03b8j(ax) \u222a \u03b8j(lem) \u222a \u22c3 {\u03c3i,j(DomD(Ki,j))|i = 1...n}\n= lemMj \u222a sigMj \u222a axMj \u222a \u22c3 {\u03c3(DomD(K)) | K \u03c3 +3 Mj,K 6= Ki, \u03c3 6= \u03c3i,j}\n\u222a \u22c3 {\u03c3i,j(DomD(Ki,j)) | i = 1...n} \u222a \u03b8j(lem)\n= DomD(Mj) \u222a \u03b8j(lem).\n\u2013 Suppose \u03c6 \u2208 LemD\u2032 and \u03c8 \u2208 SuppD\u2032(\u03c6). If loc \u2032(\u03c6), loc\u2032(\u03c8) 6\u2208 {N,N1, . . . Np}\nthen loc\u2032(\u03c6) = loc(\u03c6) and loc\u2032(\u03c8) = loc(\u03c8) and therefore, \u2203\u03c3. loc(\u03c8) _? \u03c3 +3 loc(\u03c6) with \u03c3(\u03c8) = \u03c8 in D. Since D\u2032 inherits all links away from M1, . . .Mp and paths travesing some Ki and Mj can be mapped to paths traversing Ki, N , and Nj . \u2203\u03c3. loc\u2032(\u03c8) _? \u03c3 +3 loc\u2032(\u03c6) with \u03c3(\u03c8) = \u03c8 also in D\u2032- Next, let loc\u2032(\u03c6) = Nj : by definition we know that \u03c6 \u2208Mj and Supp(\u03c6) \u2286 DomD(Mj). Since DomD(Mj) \u2286 DomD\u2032(Nj) we know that Supp\u2032(\u03c6) = Supp(\u03c6) \u2286 DomD\u2032(Nj) and thus \u2200\u03c8 \u2208 Supp\u2032(\u03c6). loc\u2032(\u03c8) _?\n\u03c3 +3 Nj with \u03c3(\u03c8) = \u03c8. Finally, let loc\u2032(\u03c6) = N . Then SuppN \u2286 Supp\u2032 is a support mapping for \u03c6 in particular."}, {"heading": "Transitive enrichment", "text": "Obviously, the inclusion of the global link does not affect the visibility (e.g. Dom ) of any node in N nor the local entities provided by the individual nodes (i.e. dom). Hence, all properties of a structuring are trivially forwarded to the enriched structuring."}, {"heading": "Removable link", "text": "\u2013 We have to prove that loc is also a location mapping for D\u2032. It holds that \u2200N \u2208 N . locD(N) = locD\u2032(N) since dom(N) remains unchanged and also all e \u2208 locD(N) that are exclusively provided by some link in D are still provided exclusively in D\u2032. Thus, loc is also surjective in D\u2032, also \u2200N \u2208 N .\u2200e \u2208 domN . locD\u2032(e) = locD(e) = N and \u2200e \u2208 DomD\u2032 . locD\u2032(e) is the only node providing e. \u2013 D\u2032 and D\u2032 coincide in the entities they provide at their maximal nodes, which is an immediate consequence of condition (2) of Def. 9. \u2013 Also \u2200\u03c6 \u2208 LemD\u2032 . \u2200\u03c8 \u2208 Supp(\u03c6). \u2203\u03c3. loc(\u03c8) _? \u03c3 +3 loc(\u03c6) \u2227 \u03c3(\u03c8) = \u03c8 is\nimplied by condition (3) of Def. 9. ut"}], "references": [{"title": "Mind the gap - maintaining formal developments in MAYA", "author": ["S. Autexier", "D. Hutter"], "venue": "In Festschrift in Honor of J.H. Siekmann. Springer, LNCS 2605,", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2005}, {"title": "Generalization with taxonomic information", "author": ["A.M. Frisch", "C.D.P. Jr"], "venue": "In 8th National Conference on Artificial Intelligence, pages 775\u2013761. AAAI-Press,", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1990}, {"title": "Matching concepts across HOL libraries", "author": ["T. Gauthier", "C. Kaliszyk"], "venue": "In Intelligent Computer Mathematics, pages 267\u2013281. Springer, LNAI 8543,", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2014}, {"title": "Institutions: Abstract model theory for specification and programming", "author": ["J.A. Goguen", "R.M. Burstall"], "venue": "Journal of the Association for Computing Machinery, 39:95\u2013146, 1992. Predecessor in: LNCS 164, 221\u2013256,", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1984}, {"title": "Management of change in verification systems", "author": ["D. Hutter"], "venue": "In Proceedings 15th IEEE International Conference on Automated Software Engineering, ASE-2000, pages 23\u201334. IEEE Computer Society,", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2000}, {"title": "Development graphs - proof management for structured specifications", "author": ["T. Mossakowski", "S. Autexier", "D. Hutter"], "venue": "Journal of Logic and Algebraic Programming, special issue on Algebraic Specification and Development Techniques, 67(1-2):114\u2013 145, april", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2006}, {"title": "Extended formula normalization for -retrieval and sharing of mathematical knowledge", "author": ["I. Normann", "M. Kohlhase"], "venue": "In Towards Mechanized Mathematical Assistants (Calculemus/MKM). Springer, LNCS 4573,", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "Reusable tptp parser in java", "author": ["A. Riazanov", "A. Tchaltsev"], "venue": "http://www. freewebs.com/andrei_ch/TPTP_2007.01.30.tgz,", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2007}, {"title": "The TPTP World - Infrastructure for Automated Reasoning", "author": ["G. Sutcliffe"], "venue": "In E. Clarke and A. Voronkov, editors, Proceedings of the 16th International Conference on Logic for Programming Artificial Intelligence and Reasoning, number 6355 in LNAI, pages 1\u201312. Springer-Verlag,", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2010}, {"title": "On the sets inhabited by numbers", "author": ["A. Trybulec"], "venue": "Journal of Formalized Mathematics, 15,", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2003}], "referenceMentions": [{"referenceID": 4, "context": "Algebraic specification techniques provide appropriate frameworks for structuring complex specifications and the authors introduced the notion of an development graph [5,1,6] as a technical means to work with and reason about such structured specifications.", "startOffset": 167, "endOffset": 174}, {"referenceID": 0, "context": "Algebraic specification techniques provide appropriate frameworks for structuring complex specifications and the authors introduced the notion of an development graph [5,1,6] as a technical means to work with and reason about such structured specifications.", "startOffset": 167, "endOffset": 174}, {"referenceID": 5, "context": "Algebraic specification techniques provide appropriate frameworks for structuring complex specifications and the authors introduced the notion of an development graph [5,1,6] as a technical means to work with and reason about such structured specifications.", "startOffset": 167, "endOffset": 174}, {"referenceID": 3, "context": "We base our framework on the notions of development graphs (and thus on the notion of institutions [4]) to specify and reason about structured specifications.", "startOffset": 99, "endOffset": 102}, {"referenceID": 8, "context": "In order to evaluate the refactoring rules on real theories we have implemented the development graphs and the rules in Scala and added support to read formulas in TSTP format [9] using the Java parser from [8].", "startOffset": 176, "endOffset": 179}, {"referenceID": 7, "context": "In order to evaluate the refactoring rules on real theories we have implemented the development graphs and the rules in Scala and added support to read formulas in TSTP format [9] using the Java parser from [8].", "startOffset": 207, "endOffset": 210}, {"referenceID": 9, "context": "rated obtained from the Mizar article [10] \u201cOn the Sets Inhabited by Numbers\u201d we could factorize 36 theorems into 16 theorems.", "startOffset": 38, "endOffset": 42}, {"referenceID": 1, "context": "[2,7,3]).", "startOffset": 0, "endOffset": 7}, {"referenceID": 6, "context": "[2,7,3]).", "startOffset": 0, "endOffset": 7}, {"referenceID": 2, "context": "[2,7,3]).", "startOffset": 0, "endOffset": 7}], "year": 2015, "abstractText": "Structuring theories is one of the main approaches to reduce the combinatorial explosion associated with reasoning and exploring large theories. In the past we developed the notion of development graphs as a means to represent and maintain structured theories. In this paper we present a methodology and a resulting implementation to reveal the hidden structure of flat theories by transforming them into detailed development graphs. We review our approach using plain TSTPrepresentations of MIZAR articles obtaining more structured and also more concise theories.", "creator": "LaTeX with hyperref package"}}}