{"id": "1505.05366", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-May-2015", "title": "Multi-Context Systems for Reactive Reasoning in Dynamic Environments", "abstract": "we show in course this paper how managed human multi - task context systems ( mmcss ) can be turned into acting a reactive formalism suitable for continuous reasoning in dynamic environments. we extend mmcss with ( specifically abstract ) sensors and define the ethical notion of a manual run of addressing the extended systems. we then show how typical problems arising in online reasoning can be addressed : handling potentially inconsistent sensor input, modeling intelligent cognitive forms of forgetting, selective integration of knowledge, and controlling the reasoning effort spent by contexts, like setting contexts to an idle mode. we also investigate the complexity of some important related decision problems and seriously discuss different design choices which are simply given to the knowledge systems engineer.", "histories": [["v1", "Wed, 20 May 2015 13:28:11 GMT  (30kb)", "http://arxiv.org/abs/1505.05366v1", "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 23-29, technical report, ISSN 1430-3701, Leipzig University, 2014.this http URL"]], "COMMENTS": "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 23-29, technical report, ISSN 1430-3701, Leipzig University, 2014.this http URL", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["gerhard brewka", "stefan ellmauthaler", "j\\\"org p\\\"uhrer"], "accepted": false, "id": "1505.05366"}, "pdf": {"name": "1505.05366.pdf", "metadata": {"source": "CRF", "title": "Multi-Context Systems for Reactive Reasoning in Dynamic Environments", "authors": ["Gerhard Brewka", "J\u00f6rg P\u00fchrer"], "emails": ["brewka@informatik.uni-leipzig.de", "ellmauthaler@informatik.uni-leipzig.de", "puehrer@informatik.uni-leipzig.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 5.\n05 36\n6v 1\n[ cs\n.A I]\n2 0\nM ay\n2 01\n5"}, {"heading": "1 Introduction", "text": "Research in knowledge representation (KR) faces two major problems. First of all, a large variety of different languages for representing knowledge - each of them useful for particular types of problems - has been produced. There are many situations where the integration of the knowledge represented in diverse formalisms is crucial, and principled ways of achieving this integration are needed. Secondly, most of the tools providing reasoning services for KR languages were developed for offline usage: given a knowledge base (KB) computation is one-shot, triggered by a user, through a specific query or a request to compute, say, an answer set. This is the right thing for specific types of applications where a specific answer to a particular problem instance is needed at a particular point in time. However, there are different kinds of applications where a reasoning system is continuously online and receives information about a particular system it observes. Consider an assisted living scenario where people in need of support live in an apartment equipped with various sensors, e.g., smoke detectors, cameras, and body sensors measuring relevant body functions (e.g., pulse, blood pressure). A reasoning system continuously receives sensor information. The task is to detect emergencies (health problems, forgotten medication, overheating stove,...) and cause adequate reactions (e.g., turning off the electricity, calling the ambulance, ringing an alarm). The system is continuously online and has to process a continuous stream of information rather than a fixed KB.\nThis poses new challenges on KR formalisms. Most importantly, the available information continuously grows. This obviously cannot go on forever as the KB needs to be kept in a manageable size. We thus need principled ways of forgetting/disregarding information. In\n1 A former version [8] of this paper has been accepted for publication in the Procs. of ECAI-14. This work has been partially supported by the German Research Foundation (DFG) under grants BR-1817/7-1 and FOR 1513. 2 Institute of Computer Science, Leipzig University, Germany, email: {brewka,ellmauthaler,puehrer}@informatik.uni-leipzig.de\nthe literature one often finds sliding window techniques [13] where information is kept for a specific, predefined period of time and forgotten if it falls out of this time window. We believe this approach is far too inflexible. What is needed is a dynamic, situation dependent way of determining whether information needs to be kept or can be given up. Ideally we would like our online KR system to guarantee specific response times; although it may be very difficult to come up with such guarantees, it is certainly necessary to find means to identify and focus on relevant parts of the available information. Moreover, although the definition of the semantics of the underlying KR formalism remains essential, we also need to impose procedural aspects reflecting the necessary modifications of the KB. This leads to a new, additional focus on runs of the system, rather than single evaluations.\nNonmonotonic multi-context systems (MCSs) [5] were explicitly developed to handle the integration problem. In a nutshell, an MCS consists of reasoning units - called contexts for historical reasons [15] - where each unit can be connected with other units via so-called bridge rules. The collection of bridge rules associated with a context specifies additional beliefs the context is willing to accept depending on what is believed by connected contexts. The semantics of the MCS is then defined in terms of equilibria. Intuitively, an equilibrium is a collection of belief sets, one for each context, which fit together in the sense that the beliefs of each context adequately take into account what the other contexts believe.\nThe original framework was aimed at modeling the flow of information among contexts, consequently the addition of information to a context was the only possible operation on KBs. To capture more general forms of operations MCSs were later generalized to so called managed MCSs (mMCSs) [7]. The main goal of this paper is to demonstrate that this additional functionality makes managed MCSs particularly well-suited as a basis for handling the mentioned problems of online reasoning systems as well. The main reason is that the operations on the knowledge bases allow us to control things like KB size, handling of inconsistent observations, focus of attention, and even whether a particular context should be idle for some time.\nHowever, to turn mMCSs into a reactive online formalism we first need to extend the framework to accommodate observations. We will do so by generalizing bridge rules so that they have access not only to belief sets of other contexts, but also to sensor data. This allows systems to become reactive, that is, to take information about a dynamically changing world into account and to modify themselves to keep system performance up.\nThe rest of the paper is organized as follows. We first give the necessary background on mMCSs. We then extend the framework to make it suitable for dynamic environments, in particular we show\nhow observations can be accommodated, and we define the notion of a run of an MCS based on a sequence of observations. The subsequent sections address the following issues: handling time and the frame problem; dynamic control of KB size; focus of attention; control of computation (idle contexts). We finally discuss the complexity of some important decision problems.3"}, {"heading": "2 Background: Multi-Context Systems", "text": "We now give the necessary background on managed MCSs [7] which provides the basis for our paper. We present a slightly simplified variant of mMCSs here as this allows us to better highlight the issues relevant for this paper. However, if needed it is rather straightforward (albeit technically somewhat involved) to extend all our results to the full version of mMCSs. More specifically we make two restrictions: 1) we assume all contexts have a single logic rather than a logic suite as in [7]; 2) we assume that management functions are deterministic.\nIn addition we will slightly rearrange the components of an mMCS which makes them easier to use for our purposes. In particular, we will keep bridge rules and knowledge bases separate from their associated contexts. The latter will change dynamically during updates, as we will see later, and it is thus convenient to keep them separate. Bridge rules will be separated due to technical reasons (i.e., better presentation of the later introduced notion of a run).\nAn mMCS builds on an abstract notion of a logic L as a triple (KBL,BSL,ACCL), where KBL is the set of admissible knowledge bases (KBs) of L, which are sets of KB-elements (\u201cformulas\u201d); BSL is the set of possible belief sets, whose elements are beliefs; and ACCL : KBL \u2192 2BSL is a function describing the semantics of L by assigning to each KB a set of acceptable belief sets.\nDefinition 1 A context is of the form C = \u3008L, ops,mng\u3009 where\n\u2022 L is a logic, \u2022 ops is a set of operations, \u2022 mng : 2ops \u00d7KBL \u2192 KBL is a management function.\nFor an indexed context Ci we will write Li, opsi, and mngi to denote its components.\nDefinition 2 Let C = \u3008C1, . . . , Cn\u3009 be a tuple of contexts. A bridge rule for Ci over C (1 \u2264 i \u2264 n) is of the form\nop \u2190a1, . . . , aj ,not aj+1, . . . ,not am, (1)\nsuch that op \u2208 opsi and every a\u2113 (1 \u2264 \u2113 \u2264 m) is an atom of form c:b, where c\u2208{1, . . . , n}, and b is a belief for Cc, i.e., b \u2208 S for some S \u2208 BSLc .\nFor a bridge rule r, the operation hd(r) = op is the head of r, while bd(r) = {a1, . . . , aj ,not aj+1, . . . ,not am} is the body of r.\nDefinition 3 A managed multi-context system (mMCS) M = \u3008C,BR,KB\u3009 is a triple consisting of\n1. a tuple of contexts C = \u3008C1, . . . , Cn\u3009, 2. a tuple BR = \u3008br1, . . . , brn\u3009, where each bri is a set of bridge\nrules for Ci over C, 3. a tuple of KBs KB = \u3008kb1, . . . , kbn\u3009 such that kbi \u2208 KBLi .\n3 The paper is based on preliminary ideas described in the extended abstract [4] and in [12]. However, the modeling techniques as well as the formalization presented here are new. A key difference in this respect is the handling of sensor data by means of bridge rules.\nA belief state S = \u3008S1, . . . , Sn\u3009 for M consists of belief sets Si \u2208 BSLi , 1 \u2264 i \u2264 n. Given a bridge rule r, an atom c:p \u2208 bd(r) is satisfied by S if p \u2208 Sc and a negated atom not c:p \u2208 bd(r) is satisfied by S if p 6\u2208 Sc. A literal is an atom or a negated atom. We say that r is applicable wrt. S, denoted by S |= bd(r), if every literal l \u2208 bd(r) is satisfied by S. We use appi(S) = {hd(r) | r \u2208 bri \u2227 S |= bd(r)} to denote the heads of all applicable bridge rules of context Ci wrt. S.\nThe semantics of an mMCS M is then defined in terms of equilibria, where an equilibrium is a belief state S = \u3008S1, . . . , Sn\u3009 satisfying the following condition: the belief set chosen for each context must be acceptable for the KBs obtained by applying the management function to the heads of applicable bridge rules and the KB associated with the context. More formally, for all contexts Ci = \u3008Li, opsi,mngi\u3009: let Si be the belief set chosen for Ci. Then S is an equilibrium if, for 1 \u2264 i \u2264 n,\nSi \u2208 ACCi(kb \u2032) for kb\u2032 = mngi(appi(S), kbi).\nManagement functions allow us to model all sorts of modifications of a context\u2019s KB and thus make mMCSs a powerful tool for describing the influence contexts can have on each other."}, {"heading": "3 Reactive Multi-Context Systems", "text": "To make an mMCS M suitable for reactive reasoning in dynamic environments, we have to accomplish two tasks:\n1. we must provide means for the MCS to obtain information provided by sensors, and 2. we have to formally describe the behavior of the MCS over time.\nLet us first show how sensors can be modeled abstractly. We assume that a sensor \u03a0 is a device which is able to provide new information in a given language L\u03a0 specific to the sensor. From an abstract point of view, we can identify a sensor with its observation language and a current sensor reading, that is, \u03a0 = \u3008L\u03a0, \u03c0\u3009 where \u03c0 \u2286 L\u03a0. Given a tuple of sensors \u03a0 = \u3008\u03a01, . . . ,\u03a0k\u3009, an observation Obs for \u03a0 (\u03a0-observation for short) consists of a sensor reading for each sensor, that is, Obs = \u3008\u03c01, . . . , \u03c0k\u3009 where for 1 \u2264 i \u2264 k, \u03c0i \u2286 L\u03a0i .\nEach context must have access to its relevant sensors. Contexts already have means to obtain information from outside, namely the bridge rules. This suggests that the simplest way to integrate sensors is via an extension of the bridge rules: we will assume that bridge rules in their bodies can not only refer to contexts, but also to sensors.\nDefinition 4 A reactive multi-context system (rMCS) over sensors \u03a0 = \u3008\u03a01, . . . ,\u03a0k\u3009 is a tuple M = \u3008C,BR,KB\u3009, as in Def. 3 except that the atoms a\u2113 (1 \u2264 \u2113 \u2264 m) of bridge rules in BR for context Ci of form (1) can either be a context atom of form c:b as in Def. 2, or a sensor atom of form o@s, where s is an index determining a sensor (1 \u2264 s \u2264 k) and o \u2208 L\u03a0s is a piece of sensor data.\nThe applicability of bridge rules now also depends on an observation:\nDefinition 5 Let \u03a0 be a tuple of sensors and Obs = \u3008\u03c01, . . . , \u03c0k\u3009 a \u03a0-observation. A sensor atom o@s is satisfied by Obs if o \u2208 \u03c0s; a literal not o@s is satisfied by Obs if o 6\u2208 \u03c0s.\nLet M = \u3008C,BR,KB\u3009 be an rMCS with sensors \u03a0 and S a belief state for M . A bridge rule r in BR is applicable wrt. S and Obs, symbolically S |=Obs bd(r), if every context literal in bd(r) is satisfied by S and every sensor literal in bd(r) is satisfied by Obs.\nInstead of appi(S) we use appi(S, Obs) = {hd(r) | r \u2208 bri \u2227 S |=Obs bd(r)} to define an equilibrium of an rMCS in a similar way as for an mMCS:\nDefinition 6 Let M = \u3008C,BR,KB\u3009 be an rMCS with sensors \u03a0 and Obs a \u03a0-observation. A belief state S = \u3008S1, . . . , Sn\u3009 for M is an equilibrium of M under Obs if, for 1 \u2264 i \u2264 n,\nSi \u2208 ACCi(mngi(appi(S,Obs), kbi)).\nDefinition 7 Let M = \u3008C,BR,KB\u3009 be an rMCS with sensors \u03a0, Obs a \u03a0-observation, and S = \u3008S1, . . . , Sn\u3009 an equilibrium of M under Obs. The tuple of KBs generated by S is defined as KBS = \u3008mng1(app1(S,Obs), kb1), . . . ,mngn(appn(S,Obs), kbn)\u3009. The pair \u3008S,KBS\u3009 is called full equilibrium of M under Obs.\nWe now introduce the notion of a run of an rMCS induced by a sequence of observations:\nDefinition 8 Let M = \u3008C,BR,KB\u3009 be an rMCS with sensors \u03a0 and O = (Obs0, Obs1, . . .) a sequence of \u03a0-observations. A run of M induced by O is a sequence of pairs R = (\u3008S0,KB0\u3009, \u3008S1,KB1\u3009, . . .) such that\n\u2022 \u3008S0,KB0\u3009 is a full equilibrium of M under Obs0, \u2022 for \u3008Si,KBi\u3009 with i > 0, \u3008Si,KBi\u3009 is a full equilibrium of\n\u3008C,BR,KBi\u22121\u3009 under Obsi.\nTo illustrate the notion of a run, let\u2019s discuss a simple example. We want to model a clock which allows other contexts to add time stamps to sensor information they receive. We consider two options. We will first show how a clock can be realized which generates time internally by increasing a counter whenever a new equilibrium is computed. We later discuss a clock based on a sensor having access to \u201cobjective\u201d time. In both cases we use integers as time stamps.\nExample 1 Consider a context Cc whose KBs (and belief sets) are of the form {now(t)} for some integer t. Let kb0 = {now(0 )}. Assume the single bridge rule of the context is incr \u2190, which intuitively says time should be incremented whenever an equilibrium is computed. The management function is thus defined as\nmngc({incr}, {now(t)}) = {now(t + 1 )}\nfor each t. Since the computation of the (full) equilibrium is independent of any other contexts and observations, the context just increments its current time whenever a new equilibrium is computed. Each run of an rMCS with context Cc will thus contain for Cc the sequence of belief sets {now(1 )}, {now(2 )}, {now(3 )}, . . . . The example illustrates that the system may evolve over time even if there is no observation made at all.\nIt is illustrative to compare this with a context Cc\u2032 which is like the one we discussed except for the bridge rules which now are the instances of the schema\nset(now(T + 1 )) \u2190 c\u2032:now(T ).\nThe management function correspondingly becomes\nmngc\u2032({set(now(t + 1 ))}, {now(t)}) = {now(t + 1 )}\nfor all t. Note that in this case no equilibrium exists! The reason for this is that by replacing now(0 ) with now(1 ) the precondition for the rule sanctioning this operation goes away. Special care thus needs to be taken when defining the operations.\nIn the rest of the paper we will often use an alternative approach where \u201cobjective\u201d time is entered into the system by a particular sensor \u03a0t. In this case each update of the system makes time available to each context via the current sensor reading of \u03a0t.\nIn Example 1 we already used a bridge rule schema, that is, a bridge rule where some of the parts are described by parameters (denoted by uppercase letters). We admit such schemata to allow for more compact representations. A bridge rule schema is just a convenient abbreviation for the set of its ground instances. The ground instances are obtained by replacing parameters by adequate ground terms. We will admit parameters for integers representing time, but also for formulas and even contexts. In most cases it will be clear from the discussion what the ground instances are, in other cases we will define them explicitly. We will also admit some kind of basic arithmetic in the bridge rules and assume the operations to be handled by grounding, as is usual, say, in answer set programming. For instance, the bridge rule schema\nadd(p(T + 1 )) \u2190 c:p(T ),not c:\u00acp(T + 1 )\nwhich we will use to handle the frame problem in the next section has ground instances add(p(1 )) \u2190 c:p(0 ),not c:\u00acp(1 ), add(p(2 )) \u2190 c:p(1 ),not c:\u00acp(2 ), etc.\nAlthough in principle parameters for integers lead to an infinite set of ground instances, in our applications only ground instances up to the current time (or current time plus a small constant, see Sect. 6) are needed, so the instantiations of time points remain finite.\nIn the upcoming sections we describe different generic modeling techniques for rMCSs. For concrete applications, these techniques can be refined and tailored towards the specific needs of the problem domain at hand. To demonstrate this aspect, we provide a more specific example from an assisted living application.\nExample 2 Although Bob suffers from dementia, he is able to live in his own apartment as it is equipped with an assisted living system that we model by means of an rMCS. Assume Bob starts to prepare his meal. He leaves the kitchen to go to the bathroom. After that, he forgets he has been cooking, goes to bed and falls asleep. The rMCS should be able to recognize a potential emergency based on the data of different sensors in the flat that monitor, e.g., the state of the kitchen equipment and track Bob\u2019s position.\nOur rMCS M has three contexts C = \u3008Ckt, Chu, Cig\u3009 and sensors \u03a0 = \u3008\u03a0pow,\u03a0tmp,\u03a0pos\u3009. Ckt is the kitchen equipment context that monitors Bob\u2019s stove. Its formulas and beliefs are atoms from atkt = {pw(on),pw(off ), tm(cold), tm(hot)} representing the stove\u2019s power status (on/off) and a qualitative value for its temperature (cold/hot). The logic Lkt = \u30082atkt , 2atkt , ACCid\u3009 of Ckt has a very simple semantics ACCid in which every knowledge base kb has only one accepted belief set coinciding with the formulas of kb, i.e., ACCid(kb) = {kb}. The bridge rules for Ckt over C are\nsetPower(P) \u2190switch(P)@pow. setTemp(cold) \u2190T@tmp, T \u2264 45. setTemp(hot) \u2190T@tmp, 45 < T.\nthat react to switching the stove on or off, registered by sensor \u03a0pow, respectively read numerical temperature values from sensor \u03a0tmp and classify the temperature value as cold or hot. The management\nfunction mngkt(app, kb) =\n{pw(on) | setPower(on) \u2208 app\u2228 (pw(on) \u2208 kb \u2227 setPower(off ) 6\u2208 app)}\u222a {pw(off ) |setPower(on) 6\u2208 app\u2227 (pw(on) 6\u2208 kb \u2228 setPower(off ) \u2208 app)}\u222a {tm(t) | setTemp(t) \u2208 app}\nensures that the stove is considered on when it is switched on or when it is not being switched off and already considered on in the old knowledge base kb. Otherwise, the KB constructed by the management function contains the atom pw(off ). Context Chu keeps track of Bob\u2019s position. The language of sensor \u03a0pos is given by L\u03a0pos = {enters(kitchen), enters(bathroom), enters(bedroom)} and nonempty sensor readings of \u03a0pos signal when Bob has changed rooms. The semantics of Chu is also ACCid and its bridge rules are given by the schema\nsetPos(P) \u2190 enters(P)@pos.\nThe management function writes Bob\u2019s new position into the KB whenever he changes rooms and keeps the previous position, otherwise. Cig = \u3008Lig, opsi,mngig\u3009 is the context for detecting emergencies. It is implemented as an answer-set program, hence the acceptable belief sets of Lig are the answer sets of its KBs. The bridge rules of Cig do not refer to sensor data but query other contexts:\nextVal(oven(P ,T )) \u2190 kt:pw(P), kt:tm(T ). extVal(humanPos(P)) \u2190 hu:pos(P).\nThe answer-set program kbig is given by the rule\nemergency \u2190 oven(on, hot),not humanPos(kitchen).\nThe management function of Cig that adds information from the bridge rules temporarily as input facts to the context\u2019s KB is given by mngig(app, kb) =\n(kb\\({oven(P ,T ) \u2190| P \u2208 {on , off }, T \u2208 {cold , hot}}\u222a {humanPos(R) \u2190| enters(R) \u2208 L\u03a0pos}))\u222a {oven(p, t) \u2190| extVal(oven(p, t)) \u2208 app}\u222a {humanPos(r) \u2190| extVal(humanPos(r)) \u2208 app}.\nConsider the sequence O = (Obs0, Obs1) of \u03a0-observations with Obsi = \u3008\u03c0ipow, \u03c0 i tmp, \u03c0 i pos\u3009 for 0 \u2264 i \u2264 1, \u03c0 0 pow = {switch(on)}, \u03c00tmp = {16}, \u03c0 1 tmp = {81}, \u03c0 0 pos = {enters(kitchen)}, \u03c0 1 pos = {enters(bathroom)}, and \u03c0is = \u2205 for all other \u03c0 i s. Then, \u3008S\n0,KB0\u3009 is a full equilibrium of M under Obs0, where\nS0 = \u3008{pw(on), tm(cold)}, {pos(kitchen)}, {oven(on, cold),humanPos(kitchen)}\u3009.\nand KB0 equals S0 except for the last component which is kbig \u222a {oven(on, cold) \u2190,humanPos(kitchen) \u2190}. Moreover, (\u3008S0,KB0\u3009, \u3008S1,KB1\u3009) is a run of M induced by O, where\nS1 = \u3008{pw(on), tm(hot)}, {pos(bathroom)}, {oven(on, hot),humanPos(bathroom), emergency}\u3009."}, {"heading": "4 Handling sensor data", "text": "In this section we discuss how to model an rMCS where possibly inconsistent sensor data can be integrated into a context Cj . To this\nend, we add a time tag to the sensor information and base our treatment of time on the second option discussed in the last section, that is, we assume a specific time sensor \u03a0t that yields a reading \u03c0t of the actual time of the form now(t) where t is an integer.\nLet \u03a0j1 , . . . ,\u03a0jm be the sensors which provide relevant information for Cj in addition to \u03a0t. Then Cj will have bridge rules of the form\nadd(P,T , jr ) \u2190 P@jr, now(T )@t\nwhere the operation add is meant to add new, time tagged information to the context.\nWe assume the readings of a single sensor at a particular time point to be consistent. However, it is a common problem that the readings of different sensors may be inconsistent with each other wrt. some context-dependent notion of inconsistency. To handle this we foresee a management function mngj that operates based on a total preference ranking of the available sensors. The third argument of the add operation provides information about the source of sensor information and thus a way of imposing preferences on the information to be added. Without loss of generality assume j1 > . . . > jm, that is, sensor \u03a0j1 has highest priority.\nNow let add(S) be the set of add-operations in the heads of bridge rules active in belief state S. We define\nAddj1(S) = {(p, t) | add(p, t , j1 ) \u2208 add(S)}\nand for 1 < i \u2264 m we let Addji(S) = Addji\u22121(S)\u222a\n{(p, t) | add(p, t , ji) \u2208 add(S), (p, t) consistent with Addji\u22121(S)}.\nFinally, we define mngj(add(S), kb) = kb \u222a Addjm(S). This shows how the management function can solve conflicts among inconsistent sensor readings based on preferences among the sensors. Of course, many more strategies of integrating inconsistent sensor data can be thought of which we are not going to discuss in the paper. Please also note that the bridge rules do not necessarily have to pass on sensor information as is to the context. They may as well provide the context with some abstraction of the actual readings. For instance, the sensor temperature information temp = 55 may be transformed into qualitative information by a rule schema like\nadd(temp = high ,T , jr ) \u2190temp = x@jr, 45 \u2264 x \u2264 65, now(T )@t.\nWe next present a way to address the frame problem using bridge rules when sensors are not guaranteed to provide complete information about the state of the environment in each step. In this case we want to assume, at least for some of the atoms or literals observed at time T \u2212 1 which we call persistent, that they also hold at time T .\nAssume p is some persistent observable property. Persistence of p is achieved by the following bridge rule schema:\nadd(p(T )) \u2190 now(T )@t, j:p(T \u2212 1 ),not j:\u00acp(T ).\nPlease note that in order to avoid non-existence of equilibria as discussed at the end of Sect. 3 the use of this rule schema for the frame problem presupposes that information about p valid at time T \u2212 1 remains available and is not deleted by any other bridge rule."}, {"heading": "5 Selective forgetting and data retention", "text": "To illustrate our approach we discuss in this section a context Cd which can be used for emergency detection in dynamic environments. Assume there are m potential emergencies E1, . . . , Em we\nwant the context to handle. The role of Cd is to check, based on the observations made, whether one or more of the emergencies Ei are suspected or confirmed. Based on information about potential emergencies Cd adjusts the time span observations are kept. This is the basis for intelligent forgetting based on dynamic windows.\nWe do not make any assumption about how Cd works internally apart from the following:\n\u2022 Cd may signal that emergency Ei is suspected (susp(Ei)) or confirmed (conf(Ei)). \u2022 Cd has information about default, respectively actual window sizes for different observations (def.win(p, x), win(p, x)), and \u2022 about the number of time steps observations are relevant for particular emergencies (rel(p, e, x)).\nGiven facts of the form mentioned above, here is a possible collection of bridge rules for the task. The operation set sets the window size to a new value, deleting the old one. To signal an alarm, information is added to the context KB via the operation alarm.\nset(win(P ,X ))\u2190 d:def.win(P ,X ),not d:susp(E ) set(win(P ,Y ))\u2190 d:rel(P ,E ,Y ), d:susp(E ) alarm(E ) \u2190 d:conf(E )\nFinally, we have to make sure deletions of observations are performed in accordance with the determined window sizes:\ndel(p(T \u2032)) \u2190 now(T )@t, d:win(P ,Z ), T \u2032 < T \u2212 Z.\nThe management function just performs additions and deletions on the context KB. Since additions always are tagged with the current time, whereas deletions always refer to an earlier time, there can never be a conflict.\nWe have so far described a form of focusing where a time window is extended based on a specific suspected event. The next example shows a different form of focusing where specific information is generated and kept only during there is a potential danger in a particular room.\nExample 3 Continuing Example 2 we show how context Cig can focus on specific rooms if there is a potential emergency. For the kitchen there is a threat if the stove is on, and it then becomes important to track whether someone is in the kitchen. Assume Cig has a potential belief pw(on,T ) expressing the stove is on since T . Focusing on the kitchen can be modeled by following the ASP-rule in Cig\u2019s KB:\nfocus(kitchen) \u2190 pw(on,T ).\nIn addition we will need a bridge rule, which keeps track whether Bob is absent from a room in case that room is in the current focus:\nadd(absence(R,T )) \u2190now(T )@t, ig:focus(R),\nnot ig:humanpos(R),\nnot ig:absence(R,T \u2032), T \u2032 < T.\nas well as a bridge rule to forget the absence in a room if it is no longer necessary. There the delAll operator removes all occurrences of absence with respect to a given room R from the KB of the context.\ndelAll(absence,R) \u2190 ig:humanpos(R).\ndelAll(absence,R) \u2190 not ig:focus(R).\nWith those modifications it is possible to generate an alert if Bob was too long away from the kitchen although the stove is active."}, {"heading": "6 Control of computation", "text": "In this section we show how it is possible - at least to some extent - to control the effort spent on the computation of particular contexts. We introduce a specific control context C0 which decides whether a context it controls should be idle for some time. An idle context just buffers sensor data it receives, but does not use the data for any other computations.\nLet\u2019s illustrate this continuing the discussion of Sect. 5. Assume there are k different contexts for detecting potential emergencies as described earlier. The rMCS we are going to discuss is built on an architecture where each detector context Ci, 1 \u2264 i \u2264 k is connected via bridge rules with the control context. C0 receives information about suspected emergencies and decides, based on this information, whether it is safe to let a context be idle for some time.\nWe now address the question what it means for a detector context to be idle. A detector context Ci receives relevant observations to reason whether an emergency is suspected or confirmed. In case Ci is idle, we cannot simply forget about new sensor information as it may become relevant later on, but we can buffer it so that it does not have an effect on the computation of a belief set, besides the fact that a buffered information shows up as an additional atom in the belief set which does not appear anywhere in the context\u2019s background knowledge.\nTo achieve this we have to modify Ci\u2019s original bridge rules by adding, to the body of each rule, the context literal not 0:idle(i). This means that the bridge rules behave exactly as before whenever the control context does not decide to let Ci be idle.\nFor the case where Ci is idle, i.e. where the belief set of C0 contains idle(i), we just make sure that observations are buffered. This means that for each rule of the form\nadd(P,T , jr ) \u2190 P@jr, now(T )@t\nin the original set of bridge rules we add\nbf(P,T , jr ) \u2190 P@jr,now(T )@t, 0:idle(I ).\nThe operation bf just adds the atom bf(p, t , jr ) to the context (we assume here that the language of the context contains constructs of this form). As mentioned above, this information is not used anywhere in the rest of the context\u2019s KB, it just sits there for later use.\nThe only missing piece is a bridge rule bringing back information from the buffer when the context is no longer idle. This can be done using the bridge rule empty.buffer \u2190 not 0:idle(I ). Whenever the management function has to execute this operation, it takes all information out of the buffer, checks whether it is still within the relevant time window, and if this is the case adds it to the KB, handling potential inconsistencies the way discussed in Sect. 4.\nThe control context uses formulas of the form idle(i , t) to express context i is idle until time t. We intend here to give a proof of concept, not a sophisticated control method. For this reason we simply assume the control context lets a detector context be idle for a specific constant time span c whenever the detector does not suspect an emergency. This is achieved by the following bridge rule schemata:\nadd(suspicion(K )) \u2190K:susp(E ) add(idle(K ,T + c)) \u2190 now(T )@t,not 0:suspicion(K ),\nnot 0:idle(K ,T \u2032), T \u2032 < T + c\nProvided information of the form idle(i , t) is kept until the actual time is t + 2, the last 2 conditions in the second rule schema guarantee that after being idle for period c the context must check at\nleast once whether some emergency is suspected. To avoid a context staying idle forever, we assume the management function deletes information of this form whenever t is smaller than the current time minus 1. One more rule schema to make sure information about idle contexts is available in the form used by detector contexts:\nadd(idle(K )) \u2190 now(T )@t, 0:idle(K ,T \u2032), T \u2264 T \u2032."}, {"heading": "7 Complexity", "text": "We want to analyze the complexity of queries on runs of rMCSs. For simplicity we do not consider parametrized bridge rules here, and assume that all knowledge bases in rMCSs are finite and all management functions can be evaluated in polynomial time.\nDefinition 9 The problem Q\u2203, respectively Q\u2200, is deciding whether for a given rMCS M with sensors \u03a0, a context Ci of M , a belief b for Ci, and a finite sequence of \u03a0-observations O it holds that b \u2208 Si for some Sj = \u3008S1, . . . , Sn\u3009 (0 \u2264 j \u2264 n) for some run, respectively all runs, R = (\u3008S0,KB0\u3009, . . . , \u3008Sm,KBm\u3009) of M induced by O.\nAs the complexity of an rMCS depends on that of its individual contexts we introduce the notion of context complexity along the lines of Eiter et al. [10]. To do so, we need to focus on relevant parts of belief sets by means of projection. Intuitively, among all beliefs, we only need to consider belief b that we want to query and beliefs that contribute to the application of bridge rules for deciding Q\u2203 and Q\u2200. Given M , \u03a0, Ci, and b as in Definition 9, the set of relevant beliefs for a context Cj of M is given by RBj(M, i:b) = {b \u2032 | r \u2208 brj , h:b \u2032 \u2208 bd(r) \u2228 not h:b\u2032 \u2208 bd(r)} \u222a {b | i = j}. A projected belief state for M and i:b is a tuple Si:b|M = \u3008S1 \u2229 RB1(M, i:b), . . . , Sn \u2229 RBn(M, i:b)\u3009 where S = \u3008S1, . . . , Sn\u3009 is a belief state for M . The context complexity of Cj in M wrt. i:b for a fixed \u03a0-observation Obs is the complexity of deciding whether for a given projected belief state S for M and i:b, there is some belief state S\u2032 = \u3008S\u20321, . . . , S \u2032 n\u3009 for M with S \u2032i:b |M = S and S\u2032j \u2208 ACCj(mngj(appj(S, Obs), kbj)) for all 1 \u2264 j \u2264 n. The system\u2019s context complexity CC(M, i:b) is a (smallest) upper bound for the context complexity classes of its contexts. Our complexity results are summarized in Table 1.\nMembership for Q\u2203: a non-deterministic Turing machine can guess a projected belief state Sj = \u3008S1, . . . , Sn\u3009 for all m observations in O in polynomial time. Then, iteratively for each of the consecutive observations obsj , first the context problem can be solved polynomially or using an oracle (the guess of Sj and the oracle guess can be combined which explains that we stay on the same complexity level for higher context complexity). If the answer is \u2019yes\u2019, Sj is a projected equilibrium. We can check whether b \u2208 Si, compute the updated knowledge bases and continue the iteration until reaching the last observation. The argument is similar for the co-problem of Q\u2200. Hardness: holds by a reduction from deciding equilibrium existence for an MCS when CC(M, i:b) is polynomial and by a reduction from the context complexity problem for the other results.\nNote that Q\u2203 and Q\u2200 are undecidable if we allow for infinite observations. The reason is that rMCSs are expressive enough (even with very simple context logics) to simulate a Turing machine such that deciding Q\u2203 or Q\u2200 for infinite runs solves the halting problem."}, {"heading": "8 Discussion", "text": "In this paper we introduced reactive MCSs, an extension of managed MCSs for online reasoning, and showed how they allow us to handle typical problems arising in this area. Although we restricted our discussion to deterministic management functions, two sources of non-determinism can be spotted by the attentive reader. On the one hand, we allow for semantics that return multiple belief sets for the same knowledge base, and, on the other hand, non-determinism can be introduced through bridge rules.\nThe simplest example is guessing via positive support cycles, e.g., using bridge rules like add(a) \u2190 c:a that allow (under the standard interpretation of add) for belief sets with and without formula a. Multiple equilibria may lead to an exponential number of runs. In practice, non-determinism will have to be restricted. A simple yet practical solution is to focus on a single run, disregarding alternative equilibria. Here, one might ask which is the best full equilibrium to proceed with. In this respect, it makes sense to differentiate between non-deterministic contexts and non-determinism due to bridge rules. In the first case, it is reasonable to adopt the point of view of the answer-set programming (ASP) paradigm, i.e., the knowledge bases of a context can be seen as an encoding of a problem such that the resulting belief sets correspond to the problem solutions. Hence, as every belief set is a solution it does not matter which one to choose. Thus, if the problem to be solved is an optimisation problem that has better and worse solutions, this could be handled by choosing a context formalism able to express preferences so that the semantics only returns sufficiently good solutions. For preferences between equilibria that depend on the belief sets of multiple contexts, one cannot rely on intra-context preference resolution. Here, we refer the reader to preference functions as proposed by Ellmauthaler [12]. One might also adopt language constructs for expressing preferences in ASP such as optimization statements [14] or weak constraints [9]. Essentially, these assign a quality measure to an equilibrium. With such additional quality measures at hand, the best equilibrium can be chosen for the run.\nAs to related work, there is quite some literature on MCSs by now, for an overview see [6]. Recently an interesting approach to belief change in MCSs has been proposed [18]. Other related work concerns stream reasoning in ASP [13] and in databases: a continuous version of SPARQL [3] exists, and logical considerations about continuous query languages [19] were investigated. Kowalski\u2019s logicbased framework for computing [17] is an approach which utilizes first order logic and concepts of the situation- and event-calculus in response to observations. Updates on knowledge-bases, based upon the outcome of a given semantics where also facilitated for other formalisms, like logic programming in general. There the iterative approaches of EPI [11] and EVOLP [1] are the most prominent. Note that none of these related approaches combines a solution to both knowledge integration and online reasoning, as we do.\nThe idea of updates to the knowledge-base was also formalised for database systems [2].\nFor a related alternative approach using an operator for directly manipulating KBs without contributing to the current equilibrium, we refer to the work by Gonc\u0327alves, Knorr, and Leite [16]."}], "references": [{"title": "Evolving logic programs", "author": ["Jos\u00e9 J\u00falio Alferes", "Antonio Brogi", "Jo\u00e3o Alexandre Leite", "Lu\u0131\u0301s Moniz Pereira"], "venue": "European Conference on Logics in Artificial Intelligence (JELIA", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2002}, {"title": "Formal characterizations of active databases: Part ii", "author": ["Chitta Baral", "Jorge Lobo", "Goce Trajcevski"], "venue": "International Conference on Deductive and Object-Oriented Databases (DOOD", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 1997}, {"title": "C-SPARQL: a continuous query language for RDF data streams", "author": ["D.F. Barbieri", "D. Braga", "S. Ceri", "E.D. Valle", "M. Grossniklaus"], "venue": "International Journalof Semantic Computing, 4(1), 3\u201325, ", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2010}, {"title": "Towards reactive multi-context systems", "author": ["G. Brewka"], "venue": "12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2013), pp. 1\u201310, ", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2013}, {"title": "Equilibria in heterogeneous nonmonotonic multi-context systems", "author": ["G. Brewka", "T. Eiter"], "venue": "AAAI\u201907, pp. 385\u2013390, ", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2007}, {"title": "Nonmonotonic multi-context systems: A flexible approach for integrating heterogeneous knowledge sources", "author": ["G. Brewka", "T. Eiter", "M. Fink"], "venue": "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning, 233\u2013258, Springer, ", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2011}, {"title": "Managed multi-context systems", "author": ["G. Brewka", "T. Eiter", "M. Fink", "A. Weinzierl"], "venue": "IJCAI\u201911, pp. 786\u2013791, ", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2011}, {"title": "and P", "author": ["F. Buccafurri", "N. Leone"], "venue": "Rullo, \u2018Strong and weak constraints in disjunctive datalog.\u2019, in 4th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 1997), pp. 2\u201317, ", "citeRegEx": "9", "shortCiteRegEx": null, "year": 1997}, {"title": "Finding explanations of inconsistency in multi-context systems", "author": ["T. Eiter", "M. Fink", "P. Sch\u00fcller", "A. Weinzierl"], "venue": "Proc. KR\u201910, ", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2010}, {"title": "A framework for declarative update specifications in logic programs", "author": ["Thomas Eiter", "Michael Fink", "Guiliana Sabbatini", "Hans Tompits"], "venue": "Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2001}, {"title": "Generalizing multi-context systems for reactive stream reasoning applications", "author": ["S. Ellmauthaler"], "venue": "Proceedings of the 2013 Imperial College Computing Student Workshop (ICCSW 2013), pp. 17\u201324, ", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2013}, {"title": "Stream reasoning with answer set programming: Preliminary report", "author": ["M. Gebser", "T. Grote", "R. Kaminski", "P. Obermeier", "O. Sabuncu", "T. Schaub"], "venue": "Proceedings of the 13th International Conference on the Principles of Knowledge Representation and Reasoning (KR 2012), ", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "A users guide to gringo", "author": ["M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "S. Thiele"], "venue": "clasp, clingo, and iclingo, Potassco Team", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2010}, {"title": "Multilanguage hierarchical logics or: How we can do without modal logics", "author": ["F. Giunchiglia", "L. Serafini"], "venue": "Artif. Intell., 65(1), 29\u201370, ", "citeRegEx": "15", "shortCiteRegEx": null, "year": 1994}, {"title": "Evolving multi-context systems", "author": ["R. Gon\u00e7alves", "M. Knorr", "J. Leite"], "venue": "21st European Conference on Artificial Intelligence (ECAI 2014), ", "citeRegEx": "16", "shortCiteRegEx": null, "year": 2014}, {"title": "Towards a logic-based unifying framework for computing", "author": ["R.A. Kowalski", "F. Sadri"], "venue": "CoRR, abs/1301.6905, ", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2013}, {"title": "Belief change in nonmonotonic multi-context systems", "author": ["Y. Wang", "Z. Zhuang", "K. Wang"], "venue": "12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2013), pp. 543\u2013555, ", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2013}, {"title": "Logical foundations of continuous query languages for data streams", "author": ["C. Zaniolo"], "venue": "2nd International Workshop on Datalog in Academia and Industry (Datalog 2.0), pp. 177\u2013189, ", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2012}], "referenceMentions": [{"referenceID": 11, "context": "de the literature one often finds sliding window techniques [13] where information is kept for a specific, predefined period of time and forgotten if it falls out of this time window.", "startOffset": 60, "endOffset": 64}, {"referenceID": 4, "context": "Nonmonotonic multi-context systems (MCSs) [5] were explicitly developed to handle the integration problem.", "startOffset": 42, "endOffset": 45}, {"referenceID": 13, "context": "In a nutshell, an MCS consists of reasoning units - called contexts for historical reasons [15] - where each unit can be connected with other units via so-called bridge rules.", "startOffset": 91, "endOffset": 95}, {"referenceID": 6, "context": "To capture more general forms of operations MCSs were later generalized to so called managed MCSs (mMCSs) [7].", "startOffset": 106, "endOffset": 109}, {"referenceID": 6, "context": "We now give the necessary background on managed MCSs [7] which provides the basis for our paper.", "startOffset": 53, "endOffset": 56}, {"referenceID": 6, "context": "More specifically we make two restrictions: 1) we assume all contexts have a single logic rather than a logic suite as in [7]; 2) we assume that management functions are deterministic.", "startOffset": 122, "endOffset": 125}, {"referenceID": 3, "context": "3 The paper is based on preliminary ideas described in the extended abstract [4] and in [12].", "startOffset": 77, "endOffset": 80}, {"referenceID": 10, "context": "3 The paper is based on preliminary ideas described in the extended abstract [4] and in [12].", "startOffset": 88, "endOffset": 92}, {"referenceID": 8, "context": "[10].", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "Here, we refer the reader to preference functions as proposed by Ellmauthaler [12].", "startOffset": 78, "endOffset": 82}, {"referenceID": 12, "context": "One might also adopt language constructs for expressing preferences in ASP such as optimization statements [14] or weak constraints [9].", "startOffset": 107, "endOffset": 111}, {"referenceID": 7, "context": "One might also adopt language constructs for expressing preferences in ASP such as optimization statements [14] or weak constraints [9].", "startOffset": 132, "endOffset": 135}, {"referenceID": 5, "context": "As to related work, there is quite some literature on MCSs by now, for an overview see [6].", "startOffset": 87, "endOffset": 90}, {"referenceID": 16, "context": "Recently an interesting approach to belief change in MCSs has been proposed [18].", "startOffset": 76, "endOffset": 80}, {"referenceID": 11, "context": "Other related work concerns stream reasoning in ASP [13] and in databases: a continuous version of SPARQL [3] exists, and logical considerations about continuous query languages [19] were investigated.", "startOffset": 52, "endOffset": 56}, {"referenceID": 2, "context": "Other related work concerns stream reasoning in ASP [13] and in databases: a continuous version of SPARQL [3] exists, and logical considerations about continuous query languages [19] were investigated.", "startOffset": 106, "endOffset": 109}, {"referenceID": 17, "context": "Other related work concerns stream reasoning in ASP [13] and in databases: a continuous version of SPARQL [3] exists, and logical considerations about continuous query languages [19] were investigated.", "startOffset": 178, "endOffset": 182}, {"referenceID": 15, "context": "Kowalski\u2019s logicbased framework for computing [17] is an approach which utilizes first order logic and concepts of the situation- and event-calculus in response to observations.", "startOffset": 46, "endOffset": 50}, {"referenceID": 9, "context": "There the iterative approaches of EPI [11] and EVOLP [1] are the most prominent.", "startOffset": 38, "endOffset": 42}, {"referenceID": 0, "context": "There the iterative approaches of EPI [11] and EVOLP [1] are the most prominent.", "startOffset": 53, "endOffset": 56}, {"referenceID": 1, "context": "The idea of updates to the knowledge-base was also formalised for database systems [2].", "startOffset": 83, "endOffset": 86}, {"referenceID": 14, "context": "For a related alternative approach using an operator for directly manipulating KBs without contributing to the current equilibrium, we refer to the work by Gon\u00e7alves, Knorr, and Leite [16].", "startOffset": 184, "endOffset": 188}], "year": 2015, "abstractText": "We show in this paper how managed multi-context systems (mMCSs) can be turned into a reactive formalism suitable for continuous reasoning in dynamic environments. We extend mMCSs with (abstract) sensors and define the notion of a run of the extended systems. We then show how typical problems arising in online reasoning can be addressed: handling potentially inconsistent sensor input, modeling intelligent forms of forgetting, selective integration of knowledge, and controlling the reasoning effort spent by contexts, like setting contexts to an idle mode. We also investigate the complexity of some important related decision problems and discuss different design choices which are given to the knowledge engineer.", "creator": "LaTeX with hyperref package"}}}