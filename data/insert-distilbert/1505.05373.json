{"id": "1505.05373", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-May-2015", "title": "Towards a Simulation-Based Programming Paradigm for AI applications", "abstract": "we present initial ideas for a programming paradigm based effectively on simulation that is targeted towards applications of 3d artificial intelligence ( compare ai ). for the approach aims at integrating techniques from different areas of ai and is based on the idea that certain simulated entities may freely exchange data and behavioural patterns. finally we define basic notions of a simulation - based programming analytic paradigm and show how it can be used for implementing ai applications.", "histories": [["v1", "Wed, 20 May 2015 13:34:34 GMT  (30kb)", "http://arxiv.org/abs/1505.05373v1", "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 55-61, technical report, ISSN 1430-3701, Leipzig University, 2014"]], "COMMENTS": "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 55-61, technical report, ISSN 1430-3701, Leipzig University, 2014", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["j\\\"org p\\\"uhrer"], "accepted": false, "id": "1505.05373"}, "pdf": {"name": "1505.05373.pdf", "metadata": {"source": "CRF", "title": "Towards a Simulation-Based Programming Paradigm for AI applications", "authors": ["J\u00f6rg P\u00fchrer"], "emails": ["puehrer@informatik.uni-leipzig.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 5.\n05 37\n3v 1\n[ cs\n.A I]\n2 0\nM ay\n2 01\n5"}, {"heading": "1 Introduction", "text": "Artificial intelligence (AI) is a wide field of research in which many different outstanding techniques have been developed and refined over the last decades [15]. Naturally, the question arises how to couple or integrate different subsets of these accomplishments. Besides many approaches to couple specific individual methods, a need for a wider integration of different AI techniques has been identified in the area of artificial general intelligence [16, 10]. Here, the goal is to build strong AI systems, i.e., reach human level intelligence. Arguably, integration of existing techniques is also desirable for less ambitious AI applications (that we aim for), consider for instance the realisation of intelligent opponents in computer games as a motivating example. As a side remark, note that current solutions for game AI rarely make use of techniques from reseach in AI but are often ad-hoc, based on hardcoded strategies, and incapable of learning.\nSimulation has been used in different fields of AI (such as agentbased systems [12, 18] or evolutionary computation [4]) for achieving intelligent behaviour. The rationale is that many aspects of intelligent behaviour are complex and not well understood but can be observed to emerge when the environment in which they occur is simulated adequately. In this work, we propose to use a simulation environment for realising AI applications that offers an easy way to integrate existing methods from different areas of AI such as computational intelligence, symbolic AI, or statistical methods. In particular, we present the basic cornerstones of a simulation-based programming paradigm (SBP) and demonstrate how it can be used to model different use cases for intelligent systems. The basic idea of SBP is to simulate an environment of interacting entities driven by concurrent processes. Entities are not grouped in types or classes and contain data as well as transition descriptions that define possible behaviour. Both, the behaviour and data associated to entities are subject to change which allows for learning techniques.\nIn the proposed approach, different points of views, hypothetical reasoning, or different granularities of simulation can be addressed\n1 This work has been partially supported by the German Research Foundation (DFG) under grants BR-1817/7-1 and FOR 1513. 2 Institute of Computer Science, Leipzig University, Germany, email: puehrer@informatik.uni-leipzig.de\nby using multiple worlds refering to (not necessarily) the same entities. For example, the beliefs of an agent which is modelled by an entity can be represented by a world that might differ from the data available in another world that represents an objective reality. This gives rise for epistemic reasoning capabilities, where e.g., an agent A thinks about what agent B thinks and acts upon these beliefs.\nThe remainder of the paper is organised as follows. Next, we introduce the basic notions of a simulation-based programming paradigm. Section 3 discusses how to model different scenarios of AI applications in the approach. We show how behaviour can be exchanged between entities and discuss how evolutionary processes can emerge. Moreover, we demonstrate the use of different worlds for hypothetical reasoning, expressing and exchanging different beliefs about facts and processes, and for using different granularities of simulation. In Section 4 we discuss interface considerations for transition descriptions. After that, Section 5 addresses the issue of maintaining consistency when data is updated by concurrent processes. Section 6 discusses the relation to existing techniques including differences to agent-based approaches and object-oriented programming. The paper is concluded in Section 7 with a short summary and an outlook on future work."}, {"heading": "2 Simulation-Based Programming", "text": "In this section we explain the architecture of the proposed simulationbased programming paradigm on an abstract level.\nAn SBP system deals with different worlds, each of which can be seen as a different point of view. The meaning of these worlds is not pre-defined by SBP, e.g., the programmer can decide to take an objectivistic setting and consider one world the designated real one or treat all worlds alike. Different worlds allow for example to model the beliefs of an agent as in an agent-based approach. Other applications are hypothetical reasoning or realising different granularities of abstraction for efficiency, e.g., parts of the simulation that are currently in focus can be manipulated by a world that offers a more precise simulation whereas parts out of focus are handled by another world that implements an approximation (see Section 3).\nA world contains a set of named entities which are the primary artifacts of SBP. Entities may have two sorts of named attributes: data entries which correspond to arbitrary data (including references to other entities) and transition descriptions which define the behaviour of the entities over time. The name of an entity has to be unique with respect to a world and serves as a means to reference the entity, however the same entity may appear in different worlds with potentially different attributes and attribute values. Transition descriptions can be seen as the main source code elements in the approach and they are, similar to the data entries, subject to change during runtime. This\nallows for a dynamic setting in which the behaviour of entities can change over time, e.g., new behaviour can be learned, acquired from other entities, or shaped by evolutionary processes. We do not propose a particular language or programming paradigm for specifying transition descriptions. It might, on the contrary, be beneficial to allow for different languages for different transition descriptions even within the same simulation. For instance, a transition description implementing sorting can be realised by some efficient standard algorithm in an imperative language, while another transition description that deals with a combinatorial problem with many side constraints uses a declarative knowledge representation approach like answerset programming (ASP) [8, 13] in which the problem can be easily modelled. Declarative languages are also quite useful in settings where the transition description should be modified at runtime (as mentioned above) as they often allow for easy changes. That is, because problem descriptions in these languages are typically concise and many declarative languages offer high elaboration tolerance [9], i.e., little changes of the problem statement require only few adaptations of the source code that solves the problem.\nWe require transition descriptions\u2014in whatever language they are written\u2014to comply to a specific interface that allows us to execute them in asynchronous processes. In particular, the output of a transition contains a set of updates to be performed on worlds, entities, data entries, and transition descriptions. When a transition has finished, per entity, these changes are applied in an atomic transaction that should leave the entity in a consistent state (provided that the transition description is well designed).\nAs mentioned, transition descriptions are executed in processes. Each process is associated with some entity and runs a transition description of this entity in a loop. A process can however decide to terminate itself or other processes at any time, initiate other processes, and wait for their results before finishing their own iteration.\nWe assume an infinite set N of names and say that a concept c is named if it has an associated name nc \u2208 N . We frequently use the data structure of a map, which is a set M of pairs \u3008n, v\u3009 such that v is a named object, n = nv , and \u3008n, v1\u3009, \u3008n, v2\u3009 \u2208 M implies v1 = v2. With slight abuse of notation we write v \u2208 M for \u3008nv, v\u3009 \u2208 M . In the following we describe how the concepts discussed above are related more formally. To this end, we assume the availability of a set \u03a3 of semantics for transition functions that will be explained later on.\nDefinition 1\n\u2022 A transition description is a pair t = \u3008sc, \u03c3\u3009, where sc is a piece of source code, and \u03c3 \u2208 \u03a3 is a semantics. \u2022 A process is a tuple p = \u3008t, tb\u3009, where t is a transition description and tb is a timestamp marking the begin of the current transition. \u2022 An entity is a tuple e = \u3008D,T, P \u3009, where D is a map of named data, T is a map of named transition descriptions, and P is a map of named processes. Entries of D,T , and P are called properties of e. \u2022 A world is a map of named entities. \u2022 An SBP configuration is a map of named worlds.\nWe assume a pre-specified set \u03a5 of updates which are descriptions of what changes should be made to an SBP configuration together with a fixed update function \u03c5 that maps an SBP configuration, an entity name, the name of a world, and a set of updates, to a new SBP configuration.\nDefinition 2 A result structure for a process p is a tuple r = \u3008U, bc\u3009, where U \u2286 \u03a5 is a set of updates and bc is one of the boolean values\ntrue or false that decides whether process p should continue with another transition.\nA semantics \u03c3 \u2208 \u03a3 is a function that maps a piece of source code, an SBP configuration, the name of a world, the name of an entity, and a timestamp to a result structure.\nDynamic Behaviour For presentational reasons we forgo giving a precise definition of the runtime semantics of an SBP system that would require heavy notation but describe the behaviour of the system on a semi-formal level using the concepts introduced above.\nFor running an SBP system we need an initial collection of worlds. Thus, let c0 be an SBP configuration.3 We assume a discrete notion of time where a run of the system starts at time 0, and that ct denotes the SBP configuration of each point in time t during a run.\nAt every time t during the run of an SBP system the following conditions hold or changes are performed:\n\u2022 for each process p such that p = \u3008t, tb\u3009 \u2208 P for some entity e = \u3008D,T, P \u3009 in some world w of ct there are three options:\n(i) p continues, i.e., p \u2208 P \u2032 for entity e\u2032 = \u3008D\u2032, T \u2032, P \u2032\u3009 with ne\u2032 = ne in world w \u2032 \u2208 ct+1 with nw\u2032 = nw;\n(ii) p can be cancelled, i.e., p 6\u2208 P \u2032 for P \u2032 as in Item (i);\n(iii) p has finished its computation, i.e., the result of p, namely\nrp = \u03c3(sc, c0,nw,ne, t) = \u3008U, bc\u3009\nis computed for t = \u3008sc, \u03c3\u3009. The updates that were computed by p are added to a set U t\nne,nw of updates for entity e in world w, i.e., U \u2286 U t\nne,nw .\nThe original process p is deleted similar as in Case (ii). However, if bc = true then, at time point t+1 after t, a new iteration of the process starts, i.e., if there is an entity e\u2032 = \u3008D\u2032, T \u2032, P \u2032\u3009 with ne\u2032 = ne in world w\n\u2032 \u2208 ct+1 with nw\u2032 = nw and there is a transition description t\u2032 \u2208 T \u2032 such that nt\u2032 = nt, then P \u2032 contains a new process p\u2032 = \u3008t\u2032, t+ 1\u3009 with np\u2032 = np.\nWhy and when a process continues, is cancelled, or finishes is not further specified at this point because, intuitively, in an SBP system this depends on decisions within the process itself, other processes, and the available computational resources. \u2022 starting with c\u20321 = c t, iteratively, for every item e in some world\nw of ct where the set U t ne,nw of collected updates is non-empty, a new SBP configuration is computed by the update function:\nc \u2032 i+1 = \u03c5(c \u2032 i, ne,nw, U t ne,nw )\nThe SBP configuration c\u2032n computed in the last iteration becomes the new configuration ct+1 of the system for the next point in time. We do not make assumptions about the order in which updates are applied for now and discuss the related topic of consistency handling in Section 5.\nUsing names (for worlds, entities, and properties) allows us to speak about concepts that change over time. For example, if e0 is an entity e0 = \u3008D, T, P \u3009 in some world at time 0 and some data is added to D for time 1 then, technically, this results in another entity e1 = \u3008D\n\u2032, T, P \u3009. As our intention is to consider e1 an updated version of e0 we use the same names for both, i.e., ne0 = ne1 . In the subsequent work we will sometimes refer to concepts by their names.\n3 In practice, c0 could by convention consist of a single world with a process running a transition description for initialisation, similar to a main function.\nAlong these lines, we introduce the following path-like notation using the .-operator for referring to SBP concepts in a run. Assuming a sequence of SBP configurations c0, c1, . . . in a run as above, we refer to\n\u2022 the world wi \u2208 ct by n twi , \u2022 the entity e = \u3008D,T, P \u3009 \u2208 wi by n twi .ne, \u2022 the property x in D, T , or P by n twi .ne.nx (we assume that no en-\ntity has multiple data entries, transition descriptions, or processes of the same name).\nIf clear from the context, we drop the name of the world or entity and apply the timestamp directly to entities or properties, or also drop the timestamp if not needed or clear."}, {"heading": "3 Modelling AI Applications in SBP", "text": "The concepts introduced in the previous section provide an abstract computation framework for SBP. Next, we demonstrate how to use it for modelling AI scenarios. Note that in this section we will use highlevel pseudo code for expressing the source code of transition descriptions and emphasise that in an implementation we suggest to use different high-level programming languages tailored to the specific needs of the task handled by the transition description. We discuss interface considerations for these embeddings of other formalisms in Section 4.\nFollowing the basic idea, i.e., simulating an intended scenario on the level of the programming language, entities in SBP are meant to reflect real world entities. In contrast to objects as in object-oriented programming (cf. Section 6), entities are not grouped in a hierarchy of classes. Classes are a valuable tool in settings that require clear structures and rigorously defined behaviour. However, in the scenarios we target, the nature of entities may change over time and the focus is on emerging rather than predictable behaviour. For example, in a real-world simulation, a town may become a city and a caterpillar a butterfly, etc., or, in fictional settings (think of a computer game) a stone could turn into a creature or vice versa. We want to directly support metamorphoses of this kind, letting entities transform completely over time regarding their data as well as their behaviour (represented by transition descriptions). Instead of using predefined classes, type membership is expressed by means of properties in SBP, e.g., each entity ne may have a data entry ne.types that contains a list of types that ne currently belongs to.\nExample 1 We deal with a scenario of a two-dimensional area, represented by a single SBP world w, where each entity nw.ne may have a property ne.loc with values of form \u3008X,Y \u3009 determining the location of ne to be at coordinates \u3008X,Y \u3009. The area is full of chickens running around, each of which is represented by an entity. In the beginning, every chicken ch has a transition description ch.mvRand that allows the chicken to move around with the pseudo code:\nwait(randomValue(1..5000)) dir = randomValue(1..4) switch{dir} case 1: return {\u2019mv_up\u2019} case 2: return {\u2019mv_right\u2019} case 3: return {\u2019mv_down\u2019} case 4: return {\u2019mv_left\u2019}\nThe transition first waits for a random amount of time and chooses a random direction for the move, represented by the updates\nmv up,mv right, \u00b7 \u00b7 \u00b7 \u2286 \u03a5. The semantics of mvRand always returns \u3008U, true\u3009, where U contains the update (the direction to move) and true indicates that after the end of the transition there should be a new one. When the update function \u03c5 is called with one of the mv updates it changes the value of ch.loc, e.g., if cht.loc has value \u30083, 5\u3009 and the update is mv left then cht+1.loc has value \u30082, 5\u3009.\nBesides randomly walking chickens, the area is sparsely strewn with corn. Corn does not move but it is eaten by chicken. Hence, each chicken ch has another transition description eat with the code:\nif there is some entity en in myworld with en.loc = my.loc and en.types contains \u2019corn\u2019 then return {\u2019eatCorn(en)\u2019}\nHere, we assume that using the keyword my we can refer to properties of the entity to which the transition description belongs (ch in this case). Furthermore, myworld refers to the world in which this entity appears. Also here, every iteration of eat automatically starts another one. For an update eatCorn(en), the update function\n\u2022 deletes the location entry en.loc of the corn and \u2022 notifies the corn entity that it was eaten by setting the data entry\nen.eatenBy to ch (we will need the information which chicken ate the corn later) and adding a process to the corn entity with the transition description en.beenEaten that is specified by the following pseudo code:\nreturn {\u2019delete_me\u2019}\nthat causes the corn to delete itself from the area. Unlike for the other transition descriptions, a process with en.beenEaten lasts for only a single iteration.\nAssume we have an initial SBP configuration c0 = \u3008w\u3009, where every chicken entity in w has an active process named move with transition description mvRand and a process with transition description eat. Then, a run simulates chickens that run around randomly and eat corn on their way.\nWhile Example 1 illustrates how data is changed over time and new processes can be started by means of updates, the next example enriches the scenario with functionality for learning new behaviour.\nExample 2 We extend the scenario of Example 1 to a fairy tale the setting by assuming that among all the corn entities, there is one dedicated corn named cornOfWisdom that has the power to make chickens smarter if they eat it.\nThis cornOfWisdom has a transition description cornOfWisdom.mvSmart:\nwait(randomValue(1..1000)) en is an entity in myworld where en.types contains \u2019corn\u2019 and there is no other entity en\u2019\nin myworld where en\u2019.types contains \u2019corn\u2019 and distance(en\u2019.loc,my.loc) <\ndistance(en.loc,my.loc) let my.loc=(myX,myY) let en.loc=(otherX,otherY) distX = otherX - myX distY = otherY - myY\nif |distX| > |distY| then if distX > 0 then return {\u2019mv_right\u2019}\nelse return {\u2019mv_left\u2019} else if distY > 0 then return {\u2019mv_down\u2019}\nelse return {\u2019mv_up\u2019}\nIntuitively, this transition causes an entity to move towards the closest corn rather than walking randomly as in mvRand. Another difference is that mvSmart processes have shorter iterations on average as the range of the random amount of time to wait is smaller. The cornOfWisdom does not have active processes for this transition definition itself but can pass it on to everyone who eats it. This is defined in the transition cornOfWisdom.beenEaten that differs from the beenEaten transition description of other corn:\nch = my.eatenBy return {\u2019delete_me\u2019,\n\u2019copyTransition(mvSmart,ch)\u2019, \u2019changeTransition(ch.move,mvSmart)\u2019}\nBesides issueing the delete me update as it is the case for normal corn, the update copyTransition(mvSmart, ch) copies the mvSmart transition description from the cornOfWisdom to the chicken by which it was eaten. The update changeTransition(ch.move,mvSmart) changes the move process of the chicken to use its new mvSmart transition description instead of mvRand. Thus, if a chicken happens to eat the cornOfWisdom it will subsequently have a better than random strategy to catch some corn.\nHaving means to replace individual behavioural patterns, as in the example allows for modelling evolutionary processes in an easy way. For example, if the chicken scenario is modified in a way that chicken which do not eat corn regularly will die, a chicken that ate the cornOfWisdom has good chances to survive for a long period of time. Further processes could allow chickens to reproduce when they meet such that baby chicken may inherit which transition description to use for moving from one of the parents. Then, most likely, chicken using mvSmart will be predominant soon.\nThe next example illustrates the use of worlds for hypothetical reasoning.\nExample 3 Entity barker represents a waiter of an international restaurant in a tourist area trying to talk people on the street into having dinner in his restaurant. To this end, barker guesses what food they could like and makes offers accordingly. We assume an SBP configuration in which for every entity h that represents a human, there is a world wh that represents the view of the world of this human. The following transition description barker.watchPeople allows barker to set the eating habits of passer-by in his world wbarker using country stereotypes.\nwait(randomValue(50)) let en be an entity in myworld where en.loc near my.loc en.types contains \u2019human\u2019 en.eatingHabits = unknown country = guess most likely\nhome country of en prototype = myworld.country.inhPrototype return {\u2019setEatingHabits(en,propotype)\u2019,\n\u2019setPotentialCustomer(en)\u2019}\nFor every country, wbarker contains a reference inhPrototype to an entity representing a typical person from this country. The update setEatingHabits(p1, p2) copies transition descriptions and data properties that are related with food from person p2 to person p1. Moreover, the update setPotentialCustomer(p) lets barker consider entity p to be a potential customer. In order to choose what to offer a potential customer, the waiter thinks about what kind of food the person would choose (based on his stereotypes). This is modelled via the following transition barker.makeOffer:\nlet cus be a potential customer in myworld w\u2019 = copy of myworld w\u2019.cus.availableFood = restaurant.availableFood w\u2019.cus.hungry = true intermediate return {addWorld(w\u2019), startProcess(w\u2019.cus.startDinner)} when process w\u2019.cus.foodSelected is finished food = w\u2019.cus.selectedFood return {praiseFood(food), deleteWorld(w\u2019)}\nTo allow for hypothetical reasoning by the waiter, a temporary copy w\u2032 of the world wbarker is created. The sole purpose of this world is to simulate the customer dining. We use a temporary world since the simulation uses the same transition descriptions that drive the overall simulation. For example, if we would use wbarker instead, this would mean that barker thinks that the customer is actually having dinner. If we would use the world of the customer that would mean that the customer thinks she is having dinner and so on.\nAfter creating w\u2032, the transition description defines that the food available to the version of the customer in w\u2032 is exactly the food that is on the menu of the restaurant and the customer is set to be hungry in the imagination of the waiter. Then, w\u2032 is added to the SBP configuration and a process for w\u2032.cus is started using the transition description startDinner that lets enitity cus start dining in w\u2032. Note that the keyword intermediate return in the pseudo code is a convenience notation that allows for manipulating the SBP configuration during a transition which is strictly speaking not allowed in the formal framework of Section 2. Nevertheless, the same behaviour could be accomplished in a conformant way by splitting barker.makeOffer into two separate transition descriptions that are used in an alternating scheme. As soon as the customer chooses some food in the simulation, transition barker.makeOffer is notified. It continues with reading which food has been chosen in the hypothetical setting. Finally, the update praiseFood(food) causes the waiter to make an offer for the chosen food in the subsequent computation, whereas deleteWorld(w\u2032) deletes the temporary world.\nNote that copying worlds as done in Example 3 does not necessarily imply copying all of the resources in this world within an implementation of an SBP runtime engine (cf. the final discussion in Section 7). Moreover, it will sometimes be useful to adjust transition definitions in the copied world. For instance, when a transition definition deliberately slows down the pace of the simulation as it is done in Examples 1 and 2 using the wait statement, it would make sense to reduce the waiting time in a world for hypothetical reasoning. Another need for adapting a copied world is mentioned in Section 4 in the context of externally controlled processes.\nExample 4 We continue Example 3 by assuming an SBP configuration where a tourist, Ada, passes by the waiter. His process for transition barker.watchPeople classifies Ada by her looks to be an Englishwoman. After that, the process for barker.makeOffer starts hypothetical reasoning about Ada having dinner. Following the stereotypes of barker about English eating habits, the process reveals that Ada would go for blood pudding which he offers her subsequently. However, Ada is not interested in this dish as she is vegetarian. She explains her eating habits to the waiter, modelled by the following transition description ada.explainEatingHabits:\nlet pers be current discussion partner in myworld if pers offers food containing meat then let w_pers be the world of pers return {\u2019setEatingHabits(w_pers.me,\nmyworld.me)\u2019}\nHere, the update setEatingHabits that we used also in the previous example, the transition will overwrite the food related properties of the entity representing Ada in the world of barker with her actual eating habits. If barker runs the dining simulation again for making another offer the result will match the real choices of Ada.\nThe last two examples showed how worlds can be used to express different modalities like individual points of views or hypothetical scenarios. Next, we sketch a setting where different worlds represent the same situation at different granularities.\nExample 5 Consider a computer game in which the player controls a character in an environment over which different villages are distributed. Whenever the character is close to or in a village the inhabitants of the village should be simulated following their daily routines and interacting with the player. However, as the game environment is huge, simulating all inhabitants of each village at all times is too costly. The problem can be addressed by an SBP configuration that has two worlds, w(v)act and w(v)apx for each village v. Intuitively, w(v)act simulates the village and its people in all details but has only active processes while the player is closeby. The world w(v)apx approximates the behaviour of the whole village, e.g., increasing or shrinking of the population, economic output and input, or relations to neighbour villages, based on statistics and it has only active processes whenever the player is not around. Whenever the player enters a village, a process is started that synchronises the world w(v)act with the current state of the village in w(v)apx, e.g., by deleting or adding new inhabitants or shops. Moreover, it starts processes in w(v)act and cancels processes in w(v)apx. Another type of process is started when the player leaves again, that performs an opposite switch from w(v)apx to w(v)apx being active.\nWhile learning by simply copying transition descriptions from different other entities as shown earlier already allows for many different behaviour patterns to emerge, an SBP system can also be designed such that new transition descriptions are created at runtime. For example, by implementing mutation or crossing-over operators for decision descriptions, it is easy to realise genetic programming [6] principles in SBP. Another source for new transition descriptions is related to an important challenge in AI: learning behaviour by watching the environment. In an SBP framework it is easy to incorporate existing learning techniques [14, 1] by means of transition descriptions. Behaviour acquired by processes executing such transitions can then also be represented by means of transition descriptions and distributed to entities."}, {"heading": "4 Interface Considerations for Transition Descriptions", "text": "As we want to allow for different formalisms to be used for transition descriptions it is important that they are able to interact smoothly. This is essentially already reached if their semantics respects the interface of Definition 2. As different transitions communicate by reading and writing from and to the SBP configuration their formalisms do not need to be aligned in a different way. It is certainly necessary, however, that they use the same format for property values.\nThe examples in the previous section already show some of the features that we think are useful in a language realising a transition description. For one, it is valuable to have generic keywords standing for the name of the entity to which the transition belongs to and its world, like me and myworld in the examples. This way, if the transition description is copied to another entity or the same entity in another world it dynamically works with the other entity or world.\nWe do not define an explicit user interface for SBP systems but suggest that interaction of the user or another external source with an SBP system by means of externally controlled processes: A transition description can use a dedicated \u2019external semantics\u2019 where the result structure returned for every transition is provided by the user or an external system. Following this approach, an SBP system acts as a reactive approach that is influenced by events from its environment. By having the decision which parts are controlled externally and which ones within the system on the level of transition descriptions allows for having parts of the behaviour of an entity partially controlled by the user and partially by the system. Moreover, as decisions descriptions can be replaced at runtime it is also possible to take control over aspects previously handled by the system and, conversely, formerly externally controlled transitions can be automatised. This way one can replace, e.g., a human player in a computer game by an AI player or vice versa. Naturally, this requires a proper modelling. For instance, in a simulation where worlds are copied for hypothetical reasoning like in the restaurant examples, a modeller would probably want to replace human controlled processes by automated ones in the copied world. Otherwise, the user would have to provide additional input for the hypothetical scenario.\nIn the context of the model-view-controller pattern, an SBP configuration represents the model and an SBP runtime engine corresponds to the controller. We suggest to handle the view outside of SBP, although it would be interesting to explore whether it is beneficial to also model graphical user interfaces inside SBP."}, {"heading": "5 Consistency of Data", "text": "A key element of SBP is concurrent programming. Thus, a natural question is how problems regarding concurrent access on data and consistency of data are handled in the approach. Conceptionally, conflicting updates that occur at the same time instant do not cause a technical problem as the update function \u03c5 resolves an arbitrary set of updates to a valid follow-up SBP configuration. In practice, however, the functionality of this function has to be implemented and conflicts (e.g., deleting and changing a property of the same name at the same time) have to be addressed. Here, techniques for concurrency control in databases [2] could be useful. Moreover, it might be worthwhile to give the modeller means for specifying how to resolve individual conclicts by a dedicated language. Besides technically conflicting updates on data, another issue are semantical inconsistencies, i.e., data whose meaning with respect to the modelled problem domain is conflicting. As an example, consider an SBP configuration modelling a\nbanana and two monkeys and assume that each monkey has a transition description that lets him grab the banana whenever it is laying on the ground. Now suppose that both monkeys detect the banana at slightly different times and their grabbing processes start. Then, after the first monkey has taken the banana, the process of the other monkey is still going on and, depending on the concrete modelling, it could happen that the system is in a state where each monkey is believed to have the banana. We argue that consistency problems of this kind should be tackled on the level of modelling rather than by the underlying computational framework as there are many types of issues that have to be addressed in different ways and also in the real world two monkeys could believe that they succeeded in getting a banana for a short period of time. One solution in the example could be that the successful grabbing process of the first monkey cancels that of the other or that the grabbing update is implemented in a conditional way such that grabbing takes only place if the banana is still in place at the time instant when the process has finished. Although one cannot expect that problems of this kind are handled automatically, a concurrent formalism should allow for addressing them in an easy way. A major point for future work on SBP is to explore best practices for avoiding inconsistencies in the first place by adequate modelling. Moreover, situations should be singled out in which inconsistency avoidance requires much modelling effort but the respective problem could be handled by adding features to the framework."}, {"heading": "6 Influences and Relation to Existing Approaches", "text": "A goal of our approach is to integrate the use of different AI techniques in a dynamic framework. Here, a main mechanism of integration is using existing AI formalisms (e.g., ASP, planning techniques, etc.) for solving subproblems by means of transitions descriptions. This is similar in spirit to the use of different context formalisms in recent reactive forms of heterogenous multi-context systems [3, 5].\nThe idea of using multiple worlds for different points of view and modalities is loosely related to the possible world semantics of modal logics [7].\nEvolutionary processes are intrinsic to many types of simulation. In, genetic algorithms [11] the fitness of individuals is typically rated by a dedicated fitness function, whereas the most obvious approach in SBP is simulating natural selection by competition in the simulated environment, as discussed in the context of the chicken scenario after Example 2. The evolution of behaviour is related to genetic programming [6] where computer programs are shaped by evolutionary processes. Besides processes for the evolution of data and behaviour also other techniques that are frequently used in meta-heuristics, like swarm intelligence methods can be modelled and mixed in SBP in a natural way.\nAgent-based systems (ABS) [12, 18] share several aspects with SBP like the significance of emerging behaviour when entities are viewed as agents. This view, however, is not adequate for all types of entities in the SBP setting as an entity could also represent objects like stones, collections of entities, or intangible concepts like \u2019the right to vote\u2019 which should not be seen as agents. Moreover, agents interact via explicit acts of communication that can but need not be modelled in an SBP configuration. Thus, we see SBP conceptionally one level below ABS, i.e., SBP languages can be used for implementing ABSs rather than being ABSs themselves.\nFocuses of integration efforts in artificial general intelligence are communication APIs [19] and design methodology [17].\nThe shift of paradigm from procedural to object-oriented programming (OOP) can be seen as a step towards structuring programming\nto be more like the real world: in OOP, a world of objects of defined types. In particular, objects are instances of classes that are organised in a hierachy of classes in which data structures and behaviour can be inherited from top to bottom. While classes are well-suited for applications that require a clear structuring of data, they also impose a rigid corset on their instances: the data and behaviour of objects is in essence limited to what is pre-defined in their class. Moreover, the type of object is defined on instantiation and does not change during runtime. In contrast, the behaviour and data of entities in SBP can be changed over time. Inheritance in SBP works on the individual level: entities can pass their transition descriptions and data entries to fellow entities. Thus, compared to OOP, inheritance is not organised in a hierarchical way. The underlying motivation is to follow the main idea of simulating real world objects, taking the stance that entities in nature are individuals that are not structured into distinct classes per se. Instead of the instantiation of classes for generating new objects, an important strategy for obtaining new entities in SBP is the prototype pattern: copying an entity that is closest to how the new entity should be like. As discussed in Section 3, other techniques for creating new objects are sexual reproduction or random mutation.\nAnother difference between typical object-oriented languages and the SBP approach is related to the control flow. Like procedural programming, OOP programs are executed in an imperative way. Typically, a run of a program in OOP starts with an entry method executed in a main thread from which child threads can be spawned in order to obtain concurrency. When a method calls another, it is per default executed in the same thread, i.e., the execution of the calling method is paused until the called method has finished. In SBP, there is no main thread and each transition runs in an independent process. Thereby, the approach exploits the trend to concurrent computing due to which simulation became feasible for many applications."}, {"heading": "7 Conclusion", "text": "In this work we proposed an approach for using simulation as a programming paradigm. The cornerstones of the approach are\n\u2022 typeless entities \u2022 different worlds for different views on reality \u2022 behaviour defined by heterogenous concurrent services \u2022 exchange of behavioural patterns and individual inheritance\nThe main contribution of the paper is not a ready-to-use language but an initial idea for an architecture to combine these principles in a simulation-based programming paradigm. Clearly, there are many important aspects that need to be addressed when putting SBP in practice. Examples are the choice of data structures for entities, their interface when using different formalisms in transition definitions, and consistency of data as discussed in Section 5.\nAs a next step we want to explore the capabilities of different formalisms as a transition description language starting with ASP and identify different modelling patterns for important problems. A major goal is the development of a prototype SBP runtime engine which opens a wide field for further research: An important point is how to manage resources in SBP systems in which multiple worlds and entities share identical or slightly different data and processes. Efficiency requirements could necessitate mechanisms for sharing resources, e.g., by only keeping track of differences when a world or entity is cloned."}], "references": [{"title": "A survey of robot learning from demonstration", "author": ["Brenna Argall", "Sonia Chernova", "Manuela M. Veloso", "Brett Browning"], "venue": "Robotics and Autonomous Systems,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "Artificial intelligence through simulated evolution", "author": ["L.J. Fogel", "A.J. Owens", "M.J. Walsh"], "venue": null, "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1966}, {"title": "Evolving multi-context systems", "author": ["R. Gon\u00e7alves", "M. Knorr", "J. Leite"], "venue": "in Proc. ECAI\u201914,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Genetic Programming: On the Programming of Computers by Means of Natural Selection", "author": ["John R. Koza"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 1992}, {"title": "A completeness theorem in modal logic", "author": ["Saul Kripke"], "venue": "J. Symb. Log.,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1959}, {"title": "Elaboration tolerance", "author": ["John McCarthy"], "venue": "Proceedings of the 4th Symposium on Logical Formalizations of Commonsense Reasoning (Common Sense", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 1998}, {"title": "The st. thomas common sense symposium: Designing architectures for human-level intelligence", "author": ["Marvin Minsky", "Push Singh", "Aaron Sloman"], "venue": "AI Magazine,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2004}, {"title": "An introduction to genetic algorithms", "author": ["Melanie Mitchell"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1998}, {"title": "Agent-based computing from multiagent systems to agent-based models: a visual survey", "author": ["Muaz Niazi", "Amir Hussain"], "venue": "Scientometrics, 89(2),", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2011}, {"title": "Logic programs with stable model semantics as a constraint programming paradigm", "author": ["Ilkka Niemel\u00e4"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1999}, {"title": "A dynamic-bayesian network framework for modeling and evaluating learning from observation", "author": ["Santiago Onta\u00f1\u00f3n", "Jos\u00e9 L. Monta\u00f1a", "Avelino J. Gonzalez"], "venue": "Expert Syst. Appl.,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "Artificial Intelligence - A Modern Approach (3", "author": ["Stuart J. Russell", "Peter Norvig"], "venue": "internat. ed.), Pearson Education,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2010}, {"title": "An Introduction to MultiAgent Systems (2", "author": ["Michael J. Wooldridge"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2009}, {"title": "NetP: A network API for building heterogeneous modular intelligent systems", "author": ["Kai yuh Hsiao", "Peter Gorniak", "Deb Roy"], "venue": "Proceedings of the AAAI 2005 Workshop on Modular Construction of Human-Like Intelligence,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2005}], "referenceMentions": [{"referenceID": 11, "context": "Artificial intelligence (AI) is a wide field of research in which many different outstanding techniques have been developed and refined over the last decades [15].", "startOffset": 158, "endOffset": 162}, {"referenceID": 6, "context": "Besides many approaches to couple specific individual methods, a need for a wider integration of different AI techniques has been identified in the area of artificial general intelligence [16, 10].", "startOffset": 188, "endOffset": 196}, {"referenceID": 8, "context": "Simulation has been used in different fields of AI (such as agentbased systems [12, 18] or evolutionary computation [4]) for achieving intelligent behaviour.", "startOffset": 79, "endOffset": 87}, {"referenceID": 12, "context": "Simulation has been used in different fields of AI (such as agentbased systems [12, 18] or evolutionary computation [4]) for achieving intelligent behaviour.", "startOffset": 79, "endOffset": 87}, {"referenceID": 1, "context": "Simulation has been used in different fields of AI (such as agentbased systems [12, 18] or evolutionary computation [4]) for achieving intelligent behaviour.", "startOffset": 116, "endOffset": 119}, {"referenceID": 9, "context": "For instance, a transition description implementing sorting can be realised by some efficient standard algorithm in an imperative language, while another transition description that deals with a combinatorial problem with many side constraints uses a declarative knowledge representation approach like answerset programming (ASP) [8, 13] in which the problem can be easily modelled.", "startOffset": 330, "endOffset": 337}, {"referenceID": 5, "context": "That is, because problem descriptions in these languages are typically concise and many declarative languages offer high elaboration tolerance [9], i.", "startOffset": 143, "endOffset": 146}, {"referenceID": 3, "context": "For example, by implementing mutation or crossing-over operators for decision descriptions, it is easy to realise genetic programming [6] principles in SBP.", "startOffset": 134, "endOffset": 137}, {"referenceID": 10, "context": "In an SBP framework it is easy to incorporate existing learning techniques [14, 1] by means of transition descriptions.", "startOffset": 75, "endOffset": 82}, {"referenceID": 0, "context": "In an SBP framework it is easy to incorporate existing learning techniques [14, 1] by means of transition descriptions.", "startOffset": 75, "endOffset": 82}, {"referenceID": 2, "context": "This is similar in spirit to the use of different context formalisms in recent reactive forms of heterogenous multi-context systems [3, 5].", "startOffset": 132, "endOffset": 138}, {"referenceID": 4, "context": "The idea of using multiple worlds for different points of view and modalities is loosely related to the possible world semantics of modal logics [7].", "startOffset": 145, "endOffset": 148}, {"referenceID": 7, "context": "In, genetic algorithms [11] the fitness of individuals is typically rated by a dedicated fitness function, whereas the most obvious approach in SBP is simulating natural selection by competition in the simulated environment, as discussed in the context of the chicken scenario after Example 2.", "startOffset": 23, "endOffset": 27}, {"referenceID": 3, "context": "The evolution of behaviour is related to genetic programming [6] where computer programs are shaped by evolutionary processes.", "startOffset": 61, "endOffset": 64}, {"referenceID": 8, "context": "Agent-based systems (ABS) [12, 18] share several aspects with SBP like the significance of emerging behaviour when entities are viewed as agents.", "startOffset": 26, "endOffset": 34}, {"referenceID": 12, "context": "Agent-based systems (ABS) [12, 18] share several aspects with SBP like the significance of emerging behaviour when entities are viewed as agents.", "startOffset": 26, "endOffset": 34}, {"referenceID": 13, "context": "Focuses of integration efforts in artificial general intelligence are communication APIs [19] and design methodology [17].", "startOffset": 89, "endOffset": 93}], "year": 2015, "abstractText": "We present initial ideas for a programming paradigm based on simulation that is targeted towards applications of artificial intelligence (AI). The approach aims at integrating techniques from different areas of AI and is based on the idea that simulated entities may freely exchange data and behavioural patterns. We define basic notions of a simulation-based programming paradigm and show how it can be used for implementing AI applications.", "creator": "LaTeX with hyperref package"}}}