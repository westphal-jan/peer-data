{"id": "1505.05502", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-May-2015", "title": "Towards Efficient Evolving Multi-Context Systems (Preliminary Report)", "abstract": "managed multi - context programming systems ( mmcss ) provide a general framework for integrating knowledge represented in heterogeneous kr model formalisms. recently, evolving multi - context data systems ( emcss ) have been introduced as an extension consisting of adaptive mmcss that add the ability to both react to, and reason in the presence of socially commonly temporary dynamic numerical observations, and evolve regularly by incorporating new knowledge. nevertheless however, the general complexity of attempting such an expressive formalism may simply be too high in cases where huge amounts of information have to be somehow processed within often a limited short, amount of time, or even instantaneously. in essentially this paper, then we investigate under which conditions emcss may scale in such situations and we show that such polynomial emcss can be applied in a practical use case.", "histories": [["v1", "Wed, 20 May 2015 13:33:52 GMT  (31kb)", "http://arxiv.org/abs/1505.05502v1", "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 39-45, technical report, ISSN 1430-3701, Leipzig University, 2014.this http URL. arXiv admin note: substantial text overlap witharXiv:1505.05368"]], "COMMENTS": "International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), co-located with the 21st European Conference on Artificial Intelligence (ECAI 2014). Proceedings of the International Workshop on Reactive Concepts in Knowledge Representation (ReactKnow 2014), pages 39-45, technical report, ISSN 1430-3701, Leipzig University, 2014.this http URL. arXiv admin note: substantial text overlap witharXiv:1505.05368", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["ricardo gon\\c{c}alves", "matthias knorr", "jo\\~ao leite"], "accepted": false, "id": "1505.05502"}, "pdf": {"name": "1505.05502.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Jo\u00e3o Leite"], "emails": ["rjrg@fct.unl.pt"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 5.\n05 50\n2v 1\n[ cs\n.A I]\n2 0\nM ay\n2 01\n5"}, {"heading": "1 Introduction", "text": "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms. Intuitively, instead of designing a unifying language (see e.g., [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf. [1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).\nMore specifically, an MCS consists of a set of contexts, each of which is a knowledge base in some KR formalism, such that each context can access information from the other contexts using socalled bridge rules. Such non-monotonic bridge rules add its head to the context\u2019s knowledge base provided the queries (to other contexts) in the body are successful. Managed Multi-Context Systems (mMCSs) were introduced in [8] to provide an extension of MCSs by allowing operations, other than simple addition, to be expressed in the heads of bridge rules. This allows mMCSs to properly deal with the problem of consistency management within contexts.\nOne recent challenge for KR languages is to shift from static application scenarios which assume a one-shot computation, usually triggered by a user query, to open and dynamic scenarios where there is a need to react and evolve in the presence of incoming information. Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.\nWhereas mMCSs are quite general and flexible to address the problem of integration of different KR formalisms, they are essentially static in the sense that the contexts do not evolve to incorporate\n1 CENTRIA & Departamento de Informa\u0301tica, Faculdade Cie\u0302ncias e Tecnologia, Universidade Nova de Lisboa, email: rjrg@fct.unl.pt\nthe changes in the dynamic scenarios. In such scenarios, new knowledge and information is dynamically produced, often from several different sources \u2013 for example a stream of raw data produced by some sensors, new ontological axioms written by some user, newly found exceptions to some general rule, etc.\nTo address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motivation of designing general and flexible frameworks inheriting from mMCSs the ability to integrate and manage knowledge represented in heterogeneous KR formalisms, and at the same time be able to incorporate knowledge obtained from dynamic observations.\nWhereas some differences set eMCSs and rMCSs apart (see related work in Sec. 6), the definition of eMCSs is presented in a more general way. That, however, means that, as shown in [19], the worstcase complexity is in general high, which may be problematic in dynamic scenarios where the overall system needs to evolve and react interactively. This is all the more true for huge amounts of data \u2013 for example raw sensor data is likely to be constantly produced in large quantities \u2013 and systems that are capable of processing and reasoning with such data are required.\nAt the same time, eMCSs inherit from MCSs the property that models, i.e., equilibria, may be non-minimal, which potentially admits that certain pieces of information are considered true based solely on self-justification. As argued in [7], minimality may not always be desired, which can in principle be solved by indicating for each context whether it requires minimality or not. Yet, avoiding selfjustifications for those contexts where minimality is desired has not been considered in eMCSs.\nIn this paper, we tackle these problems and, in particular, consider under which conditions reasoning with evolving Multi-Context Systems can be done in polynomial time. For that purpose, we base our work on a number of notions studied in the context of MCSs that solve these problems in this case [7]. Namely, we adapt the notions of minimal and grounded equilibria to eMCSs, and subsequently a well-founded semantics, which indeed paves the way to the desired result.\nThe remainder of this paper is structured as follows. After introducing the main concepts regarding mMCSs in Sect. 2, in Sect. 3 we recall with more detail the framework of eMCSs already introducing adjustments to achieve polynomial reasoning. Then, in Sect. 4 we present an example use case, before we adapt and generalize notions from MCSs in Sect. 5 as outlined. We conclude in Sect. 6 with discussing related work and possible future directions."}, {"heading": "2 Preliminaries: Managed Multi-Context Systems", "text": "Following [7], a multi-context system (MCS) consists of a collection of components, each of which contains knowledge represented in some logic, defined as a triple L = \u3008KB,BS,ACC\u3009 where KB is the set of well-formed knowledge bases of L, BS is the set of possible belief sets, and ACC : KB \u2192 2BS is a function describing the semantics of L by assigning to each knowledge base a set of acceptable belief sets. We assume that each element of KB and BS is a set, and define F = {s : s \u2208 kb \u2227 kb \u2208 KB}.\nIn addition to the knowledge base in each component, bridge rules are used to interconnect the components, specifying what knowledge to assert in one component given certain beliefs held in the components of the MCS. Bridge rules in MCSs only allow adding information to the knowledge base of their corresponding context. In [8], an extension, called managed Multi-Context Systems (mMCSs), is introduced in order to allow other types of operations to be performed on a knowledge base. For that purpose, each context of an mMCS is associated with a management base, which is a set of operations that can be applied to the possible knowledge bases of that context. Given a management base OP and a logic L, let OF = {op(s) : op \u2208 OP \u2227 s \u2208 F} be the set of operational formulas that can be built from OP and F. Each context of an mMCS gives semantics to operations in its management base using a management function over a logic L and a management base OP , mng : 2OF \u00d7KB \u2192 KB, i.e., mng(op, kb) is the knowledge base that results from applying the operations in op to the knowledge base kb. Note that this is already a specific restriction in our case, as mng commonly returns a (non-empty) set of possible knowledge bases for mMCS (and eMCS). We also assume that mng(\u2205, kb) = kb. Now, for a sequence of logics L = \u3008L1, . . . , Ln\u3009 and a management base OPi, an Li-bridge rule \u03c3 over L, 1 \u2264 i \u2264 n, is of the form H(\u03c3) \u2190 B(\u03c3) where H(\u03c3) \u2208 OFi and B(\u03c3) is a set of bridge literals of the forms (r : b) and not (r : b), 1 \u2264 r \u2264 n, with b a belief formula of Lr .\nA managed Multi-Context System (mMCS) is a sequence M = \u3008C1, . . . , Cn\u3009, where each Ci, i \u2208 {1, . . . , n}, called a managed context, is defined as Ci = \u3008Li, kbi, br i, OPi,mngi\u3009 where Li = \u3008KBi,BSi,ACCi\u3009 is a logic, kbi \u2208 KBi, br i is a set of Li-bridge rules, OPi is a management base, and mngi is a management function over Li and OPi. Note that, for the sake of readability, we consider a slightly restricted version of mMCSs where ACCi is still a function and not a set of functions as for logic suites [8].\nFor an mMCS M = \u3008C1, . . . , Cn\u3009, a belief state of M is a sequence S = \u3008S1, . . . , Sn\u3009 such that each Si is an element of BSi. For a bridge literal (r : b), S |= (r : b) if b \u2208 Sr and S |= not (r : b) if b /\u2208 Sr; for a set of bridge literals B, S |= B if S |= L for every L \u2208 B. We say that a bridge rule \u03c3 of a context Ci is applicable given a belief state S of M if S satisfies B(\u03c3). We can then define appi(S), the set of heads of bridge rules of Ci which are applicable in S, by setting appi(S) = {H(\u03c3) : \u03c3 \u2208 br i \u2227 S |= B(\u03c3)}.\nEquilibria are belief states that simultaneously assign an acceptable belief set to each context in the mMCS such that the applicable operational formulas in bridge rule heads are taken into account. Formally, a belief state S = \u3008S1, . . . , Sn\u3009 of an mMCS M is an equilibrium of M if, for every 1 \u2264 i \u2264 n, Si \u2208 ACCi(mngi(appi(S), kbi))."}, {"heading": "3 Evolving Multi-Context Systems", "text": "In this section, we recall evolving Multi-Context Systems as introduced in [19] including some alterations that are in line with our intentions to achieve polynomial reasoning. As indicated in [19], we consider that some of the contexts in the MCS become so-called observation contexts whose knowledge bases will be constantly changing over time according to the observations made, similar, e.g., to streams of data from sensors.2\nThe changing observations then will also affect the other contexts by means of the bridge rules. As we will see, such effect can either be instantaneous and temporary, i.e., limited to the current time instant, similar to (static) mMCSs, where the body of a bridge rule is evaluated in a state that already includes the effects of the operation in its head, or persistent, but only affecting the next time instant. To achieve the latter, we extend the operational language with a unary meta-operation next that can only be applied on top of operations.\nDefinition 1 Given a management base OP and a logic L, we define eOF , the evolving operational language, as eOF = OF \u222a {next(op(s)) : op(s) \u2208 OF}.\nWe can now define evolving Multi-Context Systems.\nDefinition 2 An evolving Multi-Context System (eMCS) is a sequence Me = \u3008C1, . . . , Cn\u3009, where each evolving context Ci, i \u2208 {1, . . . , n} is defined as Ci = \u3008Li, kbi, br i, OPi,mngi\u3009 where\n\u2022 Li = \u3008KBi,BSi,ACCi\u3009 is a logic \u2022 kbi \u2208 KBi \u2022 br i is a set of Li-bridge rules s.t. H(\u03c3) \u2208 eOFi \u2022 OPi is a management base \u2022 mngi is a management function over Li and OPi.\nAs already outlined, evolving contexts can be divided into regular reasoning contexts and special observation contexts that are meant to process a stream of observations which ultimately enables the entire eMCS to react and evolve in the presence of incoming observations. To ease the reading and simplify notation, w.l.o.g., we assume that the first \u2113 contexts, 0 \u2264 \u2113 \u2264 n, in the sequence \u3008C1, . . . , Cn\u3009 are observation contexts, and, whenever necessary, such an eMCS can be explicitly represented by \u3008Co1 , . . . , C o \u2113 , C\u2113+1, . . . , Cn\u3009.\nAs for mMCSs, a belief state for Me is a sequence S = \u3008S1, . . . , Sn\u3009 such that, for each 1 \u2264 i \u2264 n, we have Si \u2208 BSi.\nRecall that the heads of bridge rules in an eMCS are more expressive than in an mMCS, since they may be of two types: those that contain next and those that do not. As already mentioned, the former are to be applied to the current knowledge base and not persist, whereas the latter are to be applied in the next time instant and persist. Therefore, we distinguish these two subsets.\nDefinition 3 Let Me = \u3008C1, . . . , Cn\u3009 be an eMCS and S a belief state for Me. Then, for each 1 \u2264 i \u2264 n, consider the following sets:\n\u2022 appnexti (S) = {op(s) : next(op(s)) \u2208 appi(S)} \u2022 appnowi (S) = {op(s) : op(s) \u2208 appi(S)}\nNote that if we want an effect to be instantaneous and persistent, then this can also be achieved using two bridge rules with identical body, one with and one without next in the head.\nSimilar to equilibria in mMCS, the (static) equilibrium is defined to incorporate instantaneous effects based on appnowi (S) alone.\n2 For simplicity of presentation, we consider discrete steps in time here.\nDefinition 4 Let Me = \u3008C1, . . . , Cn\u3009 be an eMCS. A belief state S = \u3008S1, . . . , Sn\u3009 for Me is a static equilibrium of Me iff, for each 1 \u2264 i \u2264 n, we have Si \u2208 ACCi(mngi(appnowi (S), kbi)).\nNote the minor change due to mng now only returning one kb. To be able to assign meaning to an eMCS evolving over time, we introduce evolving belief states, which are sequences of belief states, each referring to a subsequent time instant.\nDefinition 5 Let Me = \u3008C1, . . . , Cn\u3009 be an eMCS. An evolving belief state of size s for Me is a sequence Se = \u3008S1, . . . , Ss\u3009 where each Sj , 1 \u2264 j \u2264 s, is a belief state for Me.\nTo enable an eMCS to react to incoming observations and evolve, an observation sequence defined in the following has to be processed. The idea is that the knowledge bases of the observation contexts Coi change according to that sequence.\nDefinition 6 Let Me = \u3008Co1 , . . . , C o \u2113 , C\u2113+1, . . . , Cn\u3009 be an eMCS. An observation sequence for Me is a sequence Obs = \u3008O1, . . . ,Om\u3009, such that, for each 1 \u2264 j \u2264 m, Oj = \u3008oj1, . . . , o j\n\u2113\u3009 is an instant observation with oji \u2208 KBi for each 1 \u2264 i \u2264 \u2113.\nTo be able to update the knowledge bases in the evolving contexts, we need one further notation. Given an evolving context Ci and k \u2208 KBi, we denote by Ci[k] the evolving context in which kbi is replaced by k, i.e., Ci[k] = \u3008Li, k, br i, OPi,mngi\u3009.\nWe can now define that certain evolving belief states are evolving equilibria of an eMCS Me = \u3008Co1 , . . . , C o \u2113 , C\u2113+1, . . . , Cn\u3009 given an observation sequence Obs = \u3008O1, . . . ,Om\u3009 for Me. The intuitive idea is that, given an evolving belief state Se = \u3008S1, . . . , Ss\u3009 for Me, in order to check if Se is an evolving equilibrium, we need to consider a sequence of eMCSs, M1, . . . ,Ms (each with \u2113 observation contexts), representing a possible evolution of Me according to the observations in Obs, such that Sj is a (static) equilibrium of M j . The knowledge bases of the observation contexts in M j are exactly their corresponding elements oji in O\nj . For each of the other contexts Ci, \u2113 + 1 \u2264 i \u2264 n, its knowledge base in M j is obtained from the one in M j\u22121 by applying the operations in appnexti (S j\u22121).\nDefinition 7 Let Me = \u3008Co1 , . . . , C o \u2113 , C\u2113+1, . . . , Cn\u3009 be an eMCS, Se = \u3008S 1, . . . , Ss\u3009 an evolving belief state of size s for Me, and Obs = \u3008O1, . . . ,Om\u3009 an observation sequence for Me such that m \u2265 s. Then, Se is an evolving equilibrium of size s of Me given Obs iff, for each 1 \u2264 j \u2264 s, Sj is an equilibrium of M j = \u3008Co1 [o j 1], . . . , C o \u2113 [o j \u2113 ], C\u2113+1[k j \u2113+1], . . . , Cn[k j n]\u3009 where, for each \u2113+ 1 \u2264 i \u2264 n, kji is defined inductively as follows: \u2022 k1i = kbi \u2022 kj+1i = mngi(app next i (S j), kji )\nNote that next in bridge rule heads of observation contexts are thus without any effect, in other words, observation contexts can indeed be understood as managed contexts whose knowledge base changes with each time instant.\nThe essential difference to [19] is that the kj+1i can be effectively computed (instead of picking one of several options), simply because mng always returns one knowledge base. The same applies in Def. 4.\nAs shown in [19], two consequences of the previous definitions are that any subsequence of an evolving equilibrium is also an evolving equilibrium, and mMCSs are a particular case of eMCSs."}, {"heading": "4 Use Case Scenario", "text": "In this section, we illustrate eMCSs adapting a scenario on cargo shipment assessment taken from [32].\nThe customs service for any developed country assesses imported cargo for a variety of risk factors including terrorism, narcotics, food and consumer safety, pest infestation, tariff violations, and intellectual property rights.3 Assessing this risk, even at a preliminary level, involves extensive knowledge about commodities, business entities, trade patterns, government policies and trade agreements. Some of this knowledge may be external to a given customs agency: for instance the broad classification of commodities according to the international Harmonized Tariff System (HTS), or international trade agreements. Other knowledge may be internal to a customs agency, such as lists of suspected violators or of importers who have a history of good compliance with regulations. While some of this knowledge is relatively stable, much of it changes rapidly. Changes are made not only at a specific level, such as knowledge about the expected arrival date of a shipment; but at a more general level as well. For instance, while the broad HTS code for tomatoes (0702) does not change, the full classification and tariffs for cherry tomatoes for import into the US changes seasonally.\nHere, we consider an eMCS Me = \u3008Co1 , C o 2 , C3, C4\u3009 composed of two observation contexts Co1 and C o 2 , and two reasoning contexts C3 and C4. The first observation context is used to capture the data of passing shipments, i.e., the country of their origination, the commodity they contain, their importers and producers. Thus, the knowledge base and belief set language of Co1 is composed of all the ground atoms over ShpmtCommod/2, ShpmtDeclHTSCode/2, ShpmtImporter/2, ShpmtCountry/2, ShpmtProducer/2, and also GrapeTomato/1 and CherryTomato/1. The second observation context Co2 serves to insert administrative information and data from other institutions. Its knowledge base and belief set language is composed of all the ground atoms over NewEUMember/1, Misfiling/1, and RandomInspection/1. Neither of the two observation contexts has any bridge rules.\nThe reasoning context C3 is an ontological Description Logic (DL) context that contains a geographic classification, along with information about producers who are located in various countries. It also contains a classification of commodities based on their harmonized tariff information (HTS chapters, headings and codes, cf. http://www.usitc.gov/tata/hts). We refer to [11] and [8] for the standard definition of L3; kb3 is given as follows:\nCommodity \u2261 (\u2203HTSCode.\u22a4) EdibleVegetable \u2261 (\u2203HTSChapter. { \u201807\u2019 }) CherryTomato \u2261 (\u2203HTSCode. { \u201807020020\u2019 }) Tomato \u2261 (\u2203HTSHeading. { \u20180702\u2019 }) GrapeTomato \u2261 (\u2203HTSCode. { \u201807020010\u2019 }) CherryTomato \u2291 Tomato CherryTomato \u2293 GrapeTomato \u2291 \u22a5 GrapeTomato \u2291 Tomato Tomato \u2291 EdibleVegetable EURegisteredProducer \u2261 (\u2203RegisteredProducer.EUCountry) LowRiskEUCommodity \u2261 (\u2203ExpeditableImporter.\u22a4)\u2293 (\u2203CommodCountry.EUCountry) EUCountry(portugal ) RegisteredProducer(p1 , portugal ) EUCountry(slovakia) RegisteredProducer(p2 , slovakia)\nOP3 contains a single add operation to add factual knowledge. The bridge rules br3 are given as follows:\n3 The system described here is not intended to reflect the policies of any country or agency.\nadd(CherryTomato(x)) \u2190 (1 :CherryTomato(x)) add(GrapeTomato(x)) \u2190 (1 :GrapeTomato(x)) next(add(EUCountry(x))) \u2190 (2 :NewEUMember(x)) add(CommodCountry(x,y)) \u2190 (1 :ShpmtCommod(z,x)),\n(1 :ShpmtCountry(z,y)) add(ExpeditableImporter(x,y)) \u2190 (1 :ShpmtCommod(z,x)),\n(1 :ShpmtImporter(z,y)), (4 :AdmissibleImporter(y)), (4 :ApprovedImporterOf(y,x))\nNote that kb3 can indeed be expressed in the DL EL++ [4] for which standard reasoning tasks, such as subsumption, can be computed in PTIME.\nFinally, C4 is a logic programming (LP) indicating information about importers, and about whether to inspect a shipment either to check for compliance of tariff information or for food safety issues. For L4 we consider that KBi the set of normal logic programs over a signature \u03a3, BSi is the set of atoms over \u03a3, and ACCi(kb) returns returns a singleton set containing only the set of true atoms in the unique well-founded model. The latter is a bit unconventional, since this way undefinedness under the well-founded semantics [15] is merged with false information. However, as long as no loops over negation occur in the LP context (in combination with its bridge rules), undefinedness does not occur, and the obvious benefit of this choice is that computing the well-founded model is PTIME-datacomplete [10]. We consider OP4 = OP3, and kb4 and br4 are given as follows:\nAdmissibleImporter(x) \u2190 \u223cSuspectedBadGuy(x). PartialInspection(x) \u2190 RandomInspection(x). FullInspection(x) \u2190 \u223cCompliantShpmt(x). SuspectedBadGuy(i1 ).\nnext((SuspectedBadGuy(x)) \u2190 (2 :Misfiling(x)) add(ApprovedImporterOf(i2 ,x)) \u2190 (3 :EdibleVegetable(x)) add(ApprovedImporterOf(i3 ,x)) \u2190 (1 :GrapeTomato(x)) add(CompliantShpmt(x)) \u2190 (1 :ShpmtCommod(x,y)),\n(3 :HTSCode(y,z)), (1 :ShpmtDeclHTSCode(x, z)) add(RandomInspection(x)) \u2190 (1 :ShpmtCommod(x,y)),\n(2 :Random(y)) add(PartialInspection(x)) \u2190 (1 :ShpmtCommod(x,y)),\nnot (3 :LowRiskEUCommodity(y)) add(FullInspection(x)) \u2190 (1 :ShpmtCommod(x,y)),\n(3 :Tomato(y)), (1 :ShpmtCountry(x, slovakia))\nNow consider the observation sequence Obs = \u3008O1,O2,O3\u3009 where o11 consists of the following atoms on s1 (where s in s1 stands for shipment, c for commodity, and i for importer):\nShpmtCommod(s1 , c1 ) ShpmtDeclHTSCode(s1 , \u201807020010\u2019) ShpmtImporter(s1 , i1 ) CherryTomato(c1 )\no21 of the following atoms on s2 :\nShpmtCommod(s2 , c2 ) ShpmtDeclHTSCode(s2 , \u201807020020\u2019) ShpmtImporter(s2 , i2 ) ShpmtCountry(s2 , portugal ) CherryTomato(c2 )\nand o31 of the following atoms on s3 :\nShpmtCommod(s3 , c3 ) ShpmtDeclHTSCode(s3 , \u201807020010\u2019) ShpmtImporter(s3 , i3 ) ShpmtCountry(s3 , portugal ) GrapeTomato(c3 ) ShpmtProducer(s3 , p1 )\nwhile o12 = o 3 2 = \u2205 and o 2 2 = {Misfiling(i3 )}. Then, an evolving equilibrium of size 3 of Me given Obs is the sequence Se = \u3008S1, S2, S3\u3009 such that, for each 1 \u2264 j \u2264 3, Sj = \u3008Sj1, S j 2 , S j 3 , S j 4\u3009. Since it is not feasible to present the entire Se, we just highlight some interesting parts related to the evolution of the system. E.g., we have that FullInspection(s1 ) \u2208 S14 since the HTS code does not correspond to the cargo; no inspection on s2 in S24 since the shipment is compliant, c2 is a EU commodity, and s2 was not picked for random inspection; and PartialInspection(s3 ) \u2208 S34 , even though s3 comes from a EU country, because i3 has been identified at time instant 2 for misfiling, which has become permanent info available at time 3."}, {"heading": "5 Grounded Equilibria and Well-founded Semantics", "text": "Even if we only consider MCSs M , which are static and where an implicit mng always returns precisely one knowledge base, such that reasoning in all contexts can be done in PTIME, then deciding whether M has an equilibrium is in NP [7, 8]. The same result necessarily also holds for eMCSs, which can also be obtained from the considerations on eMCSs [19].\nA number of special notions were studied in the context of MCSs that tackle this problem [7]. In fact, the notion of minimal equilibria was introduced with the aim of avoiding potential self-justifications. Then, grounded equilibria as a special case for so-called reducible MCSs were presented for which the existence of minimal equilibria can be effectively checked. Subsequently, a well-founded semantics for such reducible MCSs was defined under which an approximation of all grounded equilibria can be computed more efficiently. In the following, we transfer these notions from static MCSs in [7] to dynamic eMCSs and discuss under which (non-trivial) conditions they can actually be applied.\nGiven an eMCS Me = \u3008C1, . . . , Cn\u3009, we say that a static equilibrium S = \u3008S1, . . . , Sn\u3009 is minimal if there is no equilibrium S\u2032 = \u3008S\u20321, . . . , S \u2032 n\u3009 such that S \u2032 i \u2286 Si for all i with 1 \u2264 i \u2264 n and S\u2032j ( Sj for some j with 1 \u2264 j \u2264 n. This notion of minimality ensures the avoidance of selfjustifications in evolving equilibria. The problem with this notion in terms of computation is that such minimization in general adds an additional level in the polynomial hierarchy. Therefore, we now formalize conditions under which minimal equilibria can be effectively checked. The idea is that the grounded equilibrium will be assigned to an eMCS Me if all the logics of all its contexts can be reduced to special monotonic ones using a so-called reduction function. In the case where the logics of all contexts in Me turn out to be monotonic, the minimal equilibrium will be unique.\nFormally, a logic L = (KB,BS,ACC) is monotonic if\n1. ACC(kb) is a singleton set for each kb \u2208 KB, and\n2. S \u2286 S\u2032 whenever kb \u2286 kb \u2032, ACC(kb) = {S }, and ACC(kb\u2032) = {S\u2032 }.\nFurthermore, L = (KB,BS,ACC) is reducible if for some KB\u2217 \u2286 KB and some reduction function red : KB \u00d7 BS \u2192 KB\u2217,\n1. the restriction of L to KB\u2217 is monotonic,\n2. for each kb \u2208 KB, and all S, S\u2032 \u2208 BS:\n\u2022 red(kb, S) = kb whenever kb \u2208 KB\u2217,\n\u2022 red(kb, S) \u2286 red(kb, S\u2032) whenever S\u2032 \u2286 S,\n\u2022 S \u2208 ACC(kb) iff ACC(red(kb, S)) = {S }.\nThen, an evolving context C = (L, kb, br , OP,mng) is reducible if its logic L is reducible and, for all op \u2208 FOPL and all belief sets S, red(mng(op, kb), S) = mng(op, red(kb, S)).\nAn eMCS is reducible if all of its contexts are. Note that a context is reducible whenever its logic L is monotonic. In this case KB\u2217 coincides with KB and red is the identity with respect to the first argument.\nAs pointed out in [7], reducibility is inspired by the reduct in (nonmonotonic) answer set programming. The crucial and novel condition in our case is the one that essentially says that the reduction function red and the management function mng can be applied in an arbitrary order. This may restrict to some extent the sets of operations OP and mng, but in our use case scenario in Sect. 4, all contexts are indeed reducible.\nA particular case of reducible eMCSs, definite eMCSs, does not require the reduction function and admits the polynomial computation of minimal evolving equilibria as we will see next. Namely, a reducible eMCS Me = \u3008C1, . . . , Cn\u3009 is definite if\n1. none of the bridge rules in any context contains not ,\n2. for all i and all S \u2208 BSi, kbi = red i(kbi, S).\nIn a definite eMCS, bridge rules are monotonic, and knowledge bases are already in reduced form. Inference is thus monotonic and a unique minimal equilibrium exists. We take this equilibrium to be the grounded equilibrium. Let Me be a definite eMCS. A belief state S of Me is the grounded equilibrium of Me, denoted by GE(Me), if S is the unique minimal (static) equilibrium of Me. This notion gives rise to evolving grounded equilibria.\nDefinition 8 Let Me = \u3008C1, . . . , Cn\u3009 be a definite eMCS, Se = \u3008S1, . . . , Ss\u3009 an evolving belief state of size s for Me, and Obs = \u3008O1, . . . ,Om\u3009 an observation sequence for Me such that m \u2265 s. Then, Se is the evolving grounded equilibrium of size s of Me given Obs iff, for each 1 \u2264 j \u2264 s, Sj is a grounded equilibrium of M j defined as in Definition 7.\nGrounded equilibria for definite eMCSs can indeed be efficiently computed following [7]. The only additional requirement is that all operations op \u2208 OP are monotonic, i.e., for kb, we have that kb \u2286 mng(op(s), kb). Note that this is indeed a further restriction and not covered by reducible eMCSs. Now, for 1 \u2264 i \u2264 n, let kb0i = kbi and define, for each successor ordinal \u03b1+ 1,\nkb \u03b1+1 i = mng(app now i (E \u03b1), kb\u03b1i ),\nwhere E\u03b1 = (E\u03b11 , . . . , E \u03b1 n) and ACCi(kb \u03b1 i ) = {E \u03b1 i }. Furthermore, for each limit ordinal \u03b1, define kb\u03b1i = \u22c3 \u03b2\u2264\u03b1 kb \u03b2 i , and let kb\u221ei = \u22c3 \u03b1>0 kb\u03b1i . Then Proposition 1 [7] can be adapted:\nProposition 1 Let Me = \u3008C1, . . . , Cn\u3009 be a definite eMCS s.t. all OPi are monotonic. A belief state S = \u3008S1, . . . , Sn\u3009 is the grounded equilibrium of Me iff ACCi(kb\u221ei ) = {Si}, for 1 \u2264 i \u2264 n.\nAs pointed out in [7], for many logics, kb\u221ei = kb \u03c9 i holds, i.e., the iteration stops after finitely many steps. This is indeed the case for the use case scenario in Sect. 4.\nFor evolving belief states Se of size s and an observation sequence Obs for Me, this proposition yields that the evolving grounded equilibrium for definite eMCSs can be obtained by simply applying this iteration s times.\nGrounded equilibria for general eMCSs are defined based on a reduct which generalizes the Gelfond-Lifschitz reduct to the multicontext case:\nDefinition 9 Let Me = \u3008C1, . . . , Cn\u3009 be a reducible eMCS and S = \u3008S1, . . . , Sn\u3009 a belief state of Me. The Sreduct of Me is defined as MSe = \u3008C S 1 , . . . , C S n \u3009 where, for each Ci = \u3008Li, kbi, br i, OPi,mngi\u3009, we define CSi = (Li, red i(kbi, Si), br S i , OPi, mngi). Here, br S i results from br i by deleting all\n1. rules with not (r : p) in the body such that S |= (r : p), and\n2. not literals from the bodies of remaining rules.\nFor each reducible eMCS Me and each belief set S, the S-reduct of Me is definite. We can thus check whether S is a grounded equilibrium in the usual manner:\nDefinition 10 Let Me be a reducible eMCS such that all OPi are monotonic. A belief state S of Me is a grounded equilibrium of Me if S is the grounded equilibrium of MSe , that is S = GE(M S e ).\nThe following result generalizes Proposition 2 from [7].\nProposition 2 Every grounded equilibrium of a reducible eMCS Me such that all OPi are monotonic is a minimal equilibrium of Me.\nThis can again be generalized to evolving grounded equilibria.\nDefinition 11 Let Me = \u3008C1, . . . , Cn\u3009 be a normal, reducible eMCS such that all OPi are monotonic, Se = \u3008S1, . . . , Ss\u3009 an evolving belief state of size s for Me, and Obs = \u3008O1, . . . ,Om\u3009 an observation sequence for Me such that m \u2265 s. Then, Se is the evolving grounded equilibrium of size s of Me given Obs iff, for each 1 \u2264 j \u2264 s, Sj is the grounded equilibrium of (M j)S j\nwith M j defined as in Definition 7.\nThis computation is still not polynomial, since, intuitively, we have to guess and check the (evolving) equilibrium, which is why the well-founded semantics for reducible eMCSs Me is introduced following [7]. Its definition is based on the operator \u03b3Me(S) = GE(MSe ), provided BSi for each logic Li in all the contexts of Me has a least element S\u2217. Such eMCSs are called normal.\nThe following result can be straightforwardly adopted from [7].\nProposition 3 Let Me = \u3008C1, . . . , Cn\u3009 be a reducible eMCS such that all OPi are monotonic. Then \u03b3Me is antimonotone.\nAs usual, applying \u03b3Me twice yields a monotonic operator. Hence, by the Knaster-Tarski theorem, (\u03b3Me)\n2 has a least fixpoint which determines the well-founded semantics.\nDefinition 12 Let Me = \u3008C1, . . . , Cn\u3009 be a normal, reducible eMCS such that all OPi are monotonic. The well-founded semantics of Me, denoted WFS(M), is the least fixpoint of (\u03b3Me) 2.\nStarting with the least belief state S\u2217 = \u3008S\u22171 , . . . , S \u2217 n\u3009, this fixpoint can be iterated, and the following correspondence between WFS(Me) and the grounded equilibria of Me can be shown.\nProposition 4 Let Me = \u3008C1, . . . , Cn\u3009 be a normal, reducible eMCS such that all OPi are monotonic, WFS(Me) = \u3008W1, . . .Wn\u3009, and S = \u3008S1, . . . , Sn\u3009 a grounded equilibrium of Me. Then Wi \u2286 Si for 1 \u2264 i \u2264 n.\nThe well-founded semantics can thus be viewed as an approximation of the belief state representing what is accepted in all grounded\nequilibria, even though WFS(Me) may itself not necessarily be an equilibrium. Yet, if all ACCi deterministically return one element of BSi and the eMCS is acyclic (i.e., no cyclic dependencies over bridge rules exist between beliefs in the eMCS see [19]), then the grounded equilibrium is unique and identical to the well-founded semantics. This is indeed the case for the use case in Sect. 4.\nAs before, the well-founded semantics can be generalized to evolving belief states.\nDefinition 13 Let Me = \u3008C1, . . . , Cn\u3009 be a normal, reducible eMCS such that all OPi are monotonic, and Obs = \u3008O1, . . . ,Om\u3009 an observation sequence for Me such that m \u2265 s. The evolving well-founded semantics of Me, denoted WFSe(M), is the evolving belief state Se = \u3008S1, . . . , Ss\u3009 of size s for Me such that Sj is the well-founded semantics of M j defined as in Definition 7.\nFinally, as intended, we can show that computing the evolving well-founded semantics of Me can be done in polynomial time under the restrictions established so far. For analyzing the complexity in each time instant, we can utilize output-projected belief states [11]. The idea is to consider only those beliefs that appear in some bridge rule body. Formally, given an evolving context Ci within Me = \u3008C1, . . . , Cn\u3009, we can define OUTi to be the set of all beliefs of Ci occurring in the body of some bridge rule in Me. The output-projection of a belief state S = \u3008S1, . . . , Sn\u3009 of Me is the belief state S\u2032 = \u3008S\u20321, . . . , S \u2032 n\u3009, S \u2032 i = Si \u2229OUTi, for 1 \u2264 i \u2264 n.\nFollowing [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:\n(CC) Decide, given Opi \u2286 OFi and S\u2032i \u2286 OUTi, if exist kb \u2032 i =\nmngi(Opi, kbi) and Si \u2208 ACCi(kb\u2032i) s.t. S \u2032 i = Si \u2229OUTi.\nProblem (CC) can intuitively be divided into two subproblems: (MC) compute some kb\u2032i = mngi(Opi, kbi) and (EC) decide whether Si \u2208 ACC(kb\u2032i) exists s.t. S \u2032 i = Si\u2229OUTi. Here, (MC) is trivial for monotonic operations, so (EC) determines the complexity of (CC).\nTheorem 1 Let Me = \u3008C1, . . . , Cn\u3009 be a normal, reducible eMCS such that all OPi are monotonic, Obs = \u3008O1, . . . ,Om\u3009 an observation sequence for Me, and (CC) is in PTIME for all Ci. Then, for s \u2264 m, computing WFSse(Me) is in PTIME.\nThis, together with the observation that WFSe(Me) coincides with the unique grounded equilibrium, allows us to verify that computing the results in our use case scenario can be done in polynomial time."}, {"heading": "6 Related and Future Work", "text": "In this paper we have studied how eMCSs can be revised in such a way that polynomial reasoning is possible, and we have discussed an example use case to which this result applies. We have also investigated the adaptation of notions concerning minimality of (evolving) equilibria, and we observe that the notion of reducible eMCSs is considerably restricted, but not to the same extent as the efficient computation of the well-founded semantics requires. An open question is whether a more refined computation eventually tailored to less restrictive operations than considered here can be used to achieve similar results.\nAs mentioned in the Introduction, eMCSs share the main ideas of reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations. Three main differences distinguish them. First, whereas eMCSs rely\non a sequence of observations, each independent from the previous ones, rMCSs encode such sequences within the same observation contexts, with its elements being explicitly timestamped. This means that with rMCSs it is perhaps easier to write bridge rules that refer, e.g., to specific sequences of observations, which in eMCSs would require explicit timestamps and storing the observations in some context, although at the cost that rMCSs need to deal with explicit time which adds an additional overhead. Second, since in rMCSs the contexts resulting from the application of the management operations are the ones that are used in the subsequent state, difficulties may arise in separating non-persistent and persistent effects, for example, allowing an observation to override some fact in some context while the observation holds, but without changing the context itself \u2013 such separation is easily encodable in eMCSs given the two kinds of bridge rules, i.e., with or without operator next. Finally, bridge rules with next allow for the specification of transitions based on the current state, such as the one encoded by the rule next(add(p)) \u2190 not p, which do not seem possible in rMCSs. Overall, these differences indicate that an interesting future direction would be to merge both approaches, exploring a combination of explicitly timestamped observations with the expressiveness provided by operator next.\nAnother framework that aims at modeling the dynamics of knowledge is that of evolving logic programs EVOLP [2] focusing on updates of generalized logic programs. It is possible to show that EVOLP can be seen as a particular case of eMCSs, using the operator next to capture the operator assert of EVOLP. We leave the details for an extended version. Closely related to EVOLP, hence to eMCS, are the two frameworks of reactive ASP, one implemented as a solver clingo [14] and one described in [6]. The system oclingo extends an ASP solver for handling external modules provided at runtime by a controller. The output of these external modules can be seen as the observations of EVOLP. Unlike the observations in EVOLP, which can be rules, external modules in oclingo are restricted to produce atoms so the evolving capabilities are very restricted. On the other hand, clingo permits committing to a specific answer-set at each state, a feature that is not part of EVOLP, nor of eMCS. Reactive ASP as described in [6] can be seen as a more straightforward generalization of EVOLP where operations other than assert for self-updating a program are permitted. Given the above mentioned embedding of EVOLP in eMCS, and the fact that eMCSs permit several (evolution) operations in the head of bridge rules, it is also not difficult to show that Reactive ASP as described in [6] can be captured by eMCSs.\nAlso, as already outlined in [20], an important non-trivial topic is the study of the notion of minimal change within an evolving equilibrium. Whereas minimal change may be desirable to obtain more coherent evolving equilibria, there are also arguments against adopting a one-size-fits-all approach embedded in the semantics. Different contexts, i.e., KR formalisms, may require different notions of minimal change, or even require to avoid it \u2013 e.g., suppose we want to represent some variable that can non-deterministically takes one of two values at each time instant: minimal change could force a constant value.\nAnother important issue open for future work is a more finegrained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].\nAlso interesting is to study how to perform AGM style belief revision at the (semantic) level of the equilibria, as in Wang et al [33], though different since knowledge is not incorporated in the contexts."}, {"heading": "ACKNOWLEDGEMENTS", "text": "We would like to thank the referees for their comments, which helped improve this paper considerably. Matthias Knorr and Joa\u0303o Leite were partially supported by FCT under project \u201cERRO \u2013 Efficient Reasoning with Rules and Ontologies\u201d (PTDC/EIACCO/121823/2010). Ricardo Gonc\u0327alves was supported by FCT grant SFRH/BPD/47245/2008 and Matthias Knorr was also partially supported by FCT grant SFRH/BPD/86970/2012."}], "references": [{"title": "Normative systems represented as hybrid knowledge bases", "author": ["M. Alberti", "A.S. Gomes", "R. Gon\u00e7alves", "J. Leite", "M. Slota"], "venue": "CLIMA, eds., J. Leite, P. Torroni, T. \u00c5gotnes, G. Boella, and L. van der Torre, volume 6814 of LNCS, pp. 330\u2013346. Springer, ", "citeRegEx": "1", "shortCiteRegEx": null, "year": 2011}, {"title": "Evolving logic programs", "author": ["J. Alferes", "A. Brogi", "J. Leite", "L. Pereira"], "venue": "JELIA, eds., S. Flesca, S. Greco, N. Leone, and G. Ianni, volume 2424 of LNCS, pp. 50\u201361. Springer, ", "citeRegEx": "2", "shortCiteRegEx": null, "year": 2002}, {"title": "Stream reasoning and complex event processing in ETALIS", "author": ["D. Anicic", "S. Rudolph", "P. Fodor", "N. Stojanovic"], "venue": "Semantic Web, 3(4), 397\u2013 407, ", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2012}, {"title": "Pushing the el envelope", "author": ["Franz Baader", "Sebastian Brandt", "Carsten Lutz"], "venue": "Professional Book Center,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2005}, {"title": "C- SPARQL: a continuous query language for RDF data streams", "author": ["D. Barbieri", "D. Braga", "S. Ceri", "E. Valle", "M. Grossniklaus"], "venue": "Int. J. Semantic Computing, 4(1), 3\u201325, ", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2010}, {"title": "Towards reactive multi-context systems", "author": ["G. Brewka"], "venue": "LPNMR, eds., P. Cabalar and T. C. Son, volume 8148 of LNCS, pp. 1\u201310. Springer, ", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2013}, {"title": "Equilibria in heterogeneous nonmonotonic multi-context systems", "author": ["G. Brewka", "T. Eiter"], "venue": "AAAI, pp. 385\u2013390. AAAI Press, ", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2007}, {"title": "Managed multi-context systems", "author": ["G. Brewka", "T. Eiter", "M. Fink", "A. Weinzierl"], "venue": "IJCAI, ed., T. Walsh, pp. 786\u2013791. IJCAI/AAAI, ", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2011}, {"title": "Multi-context systems for reactive reasoning in dynamic environments", "author": ["G. Brewka", "S. Ellmauthaler", "J. P\u00fchrer"], "venue": "ECAI, eds., T. Schaub, G. Friedrich, and B. O\u2019Sullivan. IOS Press, ", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2014}, {"title": "Complexity and expressive power of logic programming", "author": ["Evgeny Dantsin", "Thomas Eiter", "Georg Gottlob", "Andrei Voronkov"], "venue": "ACM Comput. Surv.,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2001}, {"title": "Finding explanations of inconsistency in multi-context systems", "author": ["T. Eiter", "M. Fink", "P. Sch\u00fcller", "A. Weinzierl"], "venue": "KR, eds., F. Lin, U. Sattler, and M. Truszczynski. AAAI Press, ", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2010}, {"title": "Generalizing multi-context systems for reactive stream reasoning applications", "author": ["S. Ellmauthaler"], "venue": "ICCSW, eds., A. V. Jones and N. Ng, volume 35 of OASICS, pp. 19\u201326. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, Germany, ", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2013}, {"title": "Stream reasoning with answer set programming: Preliminary report", "author": ["M. Gebser", "T. Grote", "R. Kaminski", "P. Obermeier", "O. Sabuncu", "T. Schaub"], "venue": "KR, eds., G Brewka, T. Eiter, and S. A. McIlraith. AAAI Press, ", "citeRegEx": "13", "shortCiteRegEx": null, "year": 2012}, {"title": "Reactive answer set programming", "author": ["M. Gebser", "T. Grote", "R. Kaminski", "T. Schaub"], "venue": "LPNMR, eds., J. P. Delgrande and W. Faber, volume 6645 of LNCS, pp. 54\u201366. Springer, ", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2011}, {"title": "The wellfounded semantics for general logic programs", "author": ["Allen Van Gelder", "Kenneth A. Ross", "John S. Schlipf"], "venue": "J. ACM,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1991}, {"title": "Multilanguage hierarchical logics or: How we can do without modal logics", "author": ["F. Giunchiglia", "L. Serafini"], "venue": "Artif. Intell., 65(1), 29\u201370, ", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1994}, {"title": "Parametrized logic programming", "author": ["R. Gon\u00e7alves", "J. Alferes"], "venue": "JELIA, eds., T. Janhunen and I. Niemel\u00e4, volume 6341 of LNCS, pp. 182\u2013194. Springer, ", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2010}, {"title": "Evolving bridge rules in evolving multi-context systems", "author": ["R. Gon\u00e7alves", "M. Knorr", "J. Leite"], "venue": "CLIMA XV, eds., N. Bulling, L. van der Torre, S. Villata, W. Jamroga, and W. Vasconcelos, ", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2014}, {"title": "Evolving multi-context systems", "author": ["R. Gon\u00e7alves", "M. Knorr", "J. Leite"], "venue": "ECAI, eds., T. Schaub, G. Friedrich, and B. O\u2019Sullivan. IOS Press, ", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2014}, {"title": "On minimal change in evolving multi-context systems (preliminary report)", "author": ["R. Gon\u00e7alves", "M. Knorr", "J. Leite"], "venue": "ReactKnow 2014, ", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2014}, {"title": "MKNF knowledge bases in multi-context systems", "author": ["M. Homola", "M. Knorr", "J. Leite", "M. Slota"], "venue": "CLIMA, eds., M. Fisher, L. van der Torre, M. Dastani, and G. Governatori, volume 7486 of LNCS, pp. 146\u2013162. Springer, ", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2012}, {"title": "A query tool for EL with nonmonotonic rules", "author": ["V. Ivanov", "M. Knorr", "J. Leite"], "venue": "ISWC, eds., H. Alani, L. Kagal, A. Fokoue, P. T. Groth, C. Biemann, J. Parreira, L. Aroyo, N. F. Noy, C. Welty, and K. Janowicz, volume 8218 of LNCS, pp. 216\u2013231. Springer, ", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2013}, {"title": "Local closed world reasoning with description logics under the well-founded semantics", "author": ["M. Knorr", "J. Alferes", "P. Hitzler"], "venue": "Artif. Intell., 175(9-10), 1528\u20131554, ", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2011}, {"title": "What if no hybrid reasoner is available? Hybrid MKNF in multi-context systems", "author": ["M. Knorr", "M. Slota", "J. Leite", "M. Homola"], "venue": "J. Log. Comput., ", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2013}, {"title": "Predicting knowledge in an ontology stream", "author": ["F. L\u00e9cu\u00e9", "J. Pan"], "venue": "IJCAI, ed., F. Rossi. IJCAI/AAAI, ", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2013}, {"title": "Reconciling description logics and rules", "author": ["B. Motik", "R. Rosati"], "venue": "J. ACM, 57(5), ", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2010}, {"title": "Minimal and absent information in contexts", "author": ["F. Roelofsen", "L. Serafini"], "venue": "IJCAI, eds., L. Kaelbling and A. Saffiotti, pp. 558\u2013563. Professional Book Center, ", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2005}, {"title": "On semantic update operators for answer-set programs", "author": ["M. Slota", "J. Leite"], "venue": "ECAI, eds., H. Coelho, R. Studer, and M. Wooldridge, volume 215 of Frontiers in Artificial Intelligence and Applications, pp. 957\u2013962. IOS Press, ", "citeRegEx": "28", "shortCiteRegEx": null, "year": 2010}, {"title": "Robust equivalence models for semantic updates of answer-set programs", "author": ["M. Slota", "J. Leite"], "venue": "KR, eds., G. Brewka, T. Eiter, and S. A. McIlraith. AAAI Press, ", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2012}, {"title": "A unifying perspective on knowledge updates", "author": ["M. Slota", "J. Leite"], "venue": "JELIA, eds., L. del Cerro, A. Herzig, and J. Mengin, volume 7519 of LNCS, pp. 372\u2013384. Springer, ", "citeRegEx": "30", "shortCiteRegEx": null, "year": 2012}, {"title": "The rise and fall of semantic rule updates based on SE-models", "author": ["M. Slota", "J. Leite"], "venue": "TPLP, ", "citeRegEx": "31", "shortCiteRegEx": null, "year": 2014}, {"title": "Splitting and updating hybrid knowledge bases", "author": ["Martin Slota", "Jo\u00e3o Leite", "Terrance Swift"], "venue": "TPLP, 11(4-5),", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2011}, {"title": "Belief change in nonmonotonic multi-context systems", "author": ["Y. Wang", "Z. Zhuang", "K. Wang"], "venue": "LPNMR, eds., P. Cabalar and T. C. Son, volume 8148 of LNCS, pp. 543\u2013555. Springer, ", "citeRegEx": "33", "shortCiteRegEx": null, "year": 2013}], "referenceMentions": [{"referenceID": 6, "context": "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms.", "startOffset": 48, "endOffset": 51}, {"referenceID": 15, "context": "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms.", "startOffset": 77, "endOffset": 85}, {"referenceID": 26, "context": "Multi-Context Systems (MCSs) were introduced in [7], building on the work in [16, 27], to address the need for a general framework that integrates knowledge bases expressed in heterogeneous KR formalisms.", "startOffset": 77, "endOffset": 85}, {"referenceID": 16, "context": ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.", "startOffset": 2, "endOffset": 10}, {"referenceID": 25, "context": ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.", "startOffset": 2, "endOffset": 10}, {"referenceID": 22, "context": ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.", "startOffset": 16, "endOffset": 20}, {"referenceID": 21, "context": ", [17, 26], and [23] with its reasoner NoHR [22]) to which other languages could be translated, in an MCS the different formalisms and knowledge bases are considered as modules, and means are provided to model the flow of information between them (cf.", "startOffset": 44, "endOffset": 48}, {"referenceID": 0, "context": "[1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).", "startOffset": 0, "endOffset": 11}, {"referenceID": 20, "context": "[1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).", "startOffset": 0, "endOffset": 11}, {"referenceID": 23, "context": "[1, 21, 24] and references therein for further motivation on hybrid languages and their connection to MCSs).", "startOffset": 0, "endOffset": 11}, {"referenceID": 7, "context": "Managed Multi-Context Systems (mMCSs) were introduced in [8] to provide an extension of MCSs by allowing operations, other than simple addition, to be expressed in the heads of bridge rules.", "startOffset": 57, "endOffset": 60}, {"referenceID": 1, "context": "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.", "startOffset": 23, "endOffset": 26}, {"referenceID": 13, "context": "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.", "startOffset": 41, "endOffset": 49}, {"referenceID": 12, "context": "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.", "startOffset": 41, "endOffset": 49}, {"referenceID": 4, "context": "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.", "startOffset": 60, "endOffset": 63}, {"referenceID": 24, "context": "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.", "startOffset": 82, "endOffset": 86}, {"referenceID": 2, "context": "Examples include EVOLP [2], Reactive ASP [14, 13], C-SPARQL [5], Ontology Streams [25] and ETALIS [3], to name only a few.", "startOffset": 98, "endOffset": 101}, {"referenceID": 18, "context": "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-", "startOffset": 84, "endOffset": 88}, {"referenceID": 5, "context": "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-", "startOffset": 132, "endOffset": 142}, {"referenceID": 11, "context": "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-", "startOffset": 132, "endOffset": 142}, {"referenceID": 8, "context": "To address this issue, two recent frameworks, evolving MultiContext Systems (eMCSs) [19] and reactive Multi-Context Systems (rMCSs) [6, 12, 9] have been proposed sharing the broad motiva-", "startOffset": 132, "endOffset": 142}, {"referenceID": 18, "context": "That, however, means that, as shown in [19], the worstcase complexity is in general high, which may be problematic in dynamic scenarios where the overall system needs to evolve and react interactively.", "startOffset": 39, "endOffset": 43}, {"referenceID": 6, "context": "As argued in [7], minimality may not always be desired, which can in principle be solved by indicating for", "startOffset": 13, "endOffset": 16}, {"referenceID": 6, "context": "For that purpose, we base our work on a number of notions studied in the context of MCSs that solve these problems in this case [7].", "startOffset": 128, "endOffset": 131}, {"referenceID": 6, "context": "Following [7], a multi-context system (MCS) consists of a collec-", "startOffset": 10, "endOffset": 13}, {"referenceID": 7, "context": "In [8], an extension, called managed Multi-Context Systems (mMCSs), is introduced in order to allow other types of operations to be performed on a knowledge base.", "startOffset": 3, "endOffset": 6}, {"referenceID": 7, "context": "Note that, for the sake of readability, we consider a slightly restricted version of mMCSs where ACCi is still a function and not a set of functions as for logic suites [8].", "startOffset": 169, "endOffset": 172}, {"referenceID": 18, "context": "duced in [19] including some alterations that are in line with our intentions to achieve polynomial reasoning.", "startOffset": 9, "endOffset": 13}, {"referenceID": 18, "context": "As indicated in [19], we consider that some of the contexts in the MCS become so-called ob-", "startOffset": 16, "endOffset": 20}, {"referenceID": 18, "context": "The essential difference to [19] is that the k i can be effectively computed (instead of picking one of several options), simply because mng always returns one knowledge base.", "startOffset": 28, "endOffset": 32}, {"referenceID": 18, "context": "As shown in [19], two consequences of the previous definitions are that any subsequence of an evolving equilibrium is also an evolving equilibrium, and mMCSs are a particular case of eMCSs.", "startOffset": 12, "endOffset": 16}, {"referenceID": 31, "context": "In this section, we illustrate eMCSs adapting a scenario on cargo shipment assessment taken from [32].", "startOffset": 97, "endOffset": 101}, {"referenceID": 10, "context": "We refer to [11] and [8] for the standard definition of L3; kb3 is given as follows:", "startOffset": 12, "endOffset": 16}, {"referenceID": 7, "context": "We refer to [11] and [8] for the standard definition of L3; kb3 is given as follows:", "startOffset": 21, "endOffset": 24}, {"referenceID": 3, "context": "Note that kb3 can indeed be expressed in the DL EL [4] for which standard reasoning tasks, such as subsumption, can be computed in PTIME.", "startOffset": 51, "endOffset": 54}, {"referenceID": 14, "context": "The latter is a bit unconventional, since this way undefinedness under the well-founded semantics [15] is merged with false information.", "startOffset": 98, "endOffset": 102}, {"referenceID": 9, "context": "complete [10].", "startOffset": 9, "endOffset": 13}, {"referenceID": 6, "context": "ing whether M has an equilibrium is in NP [7, 8].", "startOffset": 42, "endOffset": 48}, {"referenceID": 7, "context": "ing whether M has an equilibrium is in NP [7, 8].", "startOffset": 42, "endOffset": 48}, {"referenceID": 18, "context": "The same result necessarily also holds for eMCSs, which can also be obtained from the considerations on eMCSs [19].", "startOffset": 110, "endOffset": 114}, {"referenceID": 6, "context": "A number of special notions were studied in the context of MCSs that tackle this problem [7].", "startOffset": 89, "endOffset": 92}, {"referenceID": 6, "context": "In the following, we transfer these notions from static MCSs in [7] to dynamic eMCSs and discuss under which (non-trivial) conditions they can actually be applied.", "startOffset": 64, "endOffset": 67}, {"referenceID": 6, "context": "As pointed out in [7], reducibility is inspired by the reduct in (nonmonotonic) answer set programming.", "startOffset": 18, "endOffset": 21}, {"referenceID": 6, "context": "Grounded equilibria for definite eMCSs can indeed be efficiently computed following [7].", "startOffset": 84, "endOffset": 87}, {"referenceID": 6, "context": "Then Proposition 1 [7] can be adapted:", "startOffset": 19, "endOffset": 22}, {"referenceID": 6, "context": "As pointed out in [7], for many logics, kbi = kb \u03c9 i holds, i.", "startOffset": 18, "endOffset": 21}, {"referenceID": 6, "context": "The following result generalizes Proposition 2 from [7].", "startOffset": 52, "endOffset": 55}, {"referenceID": 6, "context": "This computation is still not polynomial, since, intuitively, we have to guess and check the (evolving) equilibrium, which is why the well-founded semantics for reducible eMCSs Me is introduced following [7].", "startOffset": 204, "endOffset": 207}, {"referenceID": 6, "context": "The following result can be straightforwardly adopted from [7].", "startOffset": 59, "endOffset": 62}, {"referenceID": 18, "context": ", no cyclic dependencies over bridge rules exist between beliefs in the eMCS see [19]), then the grounded equilibrium is unique and identical to the well-founded semantics.", "startOffset": 81, "endOffset": 85}, {"referenceID": 10, "context": "For analyzing the complexity in each time instant, we can utilize output-projected belief states [11].", "startOffset": 97, "endOffset": 101}, {"referenceID": 10, "context": "Following [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:", "startOffset": 10, "endOffset": 17}, {"referenceID": 7, "context": "Following [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:", "startOffset": 10, "endOffset": 17}, {"referenceID": 18, "context": "Following [11, 8], we can adapt the context complexity of Ci from [19] as the complexity of the following problem:", "startOffset": 66, "endOffset": 70}, {"referenceID": 5, "context": "reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations.", "startOffset": 43, "endOffset": 53}, {"referenceID": 11, "context": "reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations.", "startOffset": 43, "endOffset": 53}, {"referenceID": 8, "context": "reactive Multi-Context Systems sketched in [6, 12, 9] inasmuch as both aim at extending mMCSs to cope with dynamic observations.", "startOffset": 43, "endOffset": 53}, {"referenceID": 1, "context": "Another framework that aims at modeling the dynamics of knowledge is that of evolving logic programs EVOLP [2] focusing on updates of generalized logic programs.", "startOffset": 107, "endOffset": 110}, {"referenceID": 13, "context": "Closely related to EVOLP, hence to eMCS, are the two frameworks of reactive ASP, one implemented as a solver clingo [14] and one described in [6].", "startOffset": 116, "endOffset": 120}, {"referenceID": 5, "context": "Closely related to EVOLP, hence to eMCS, are the two frameworks of reactive ASP, one implemented as a solver clingo [14] and one described in [6].", "startOffset": 142, "endOffset": 145}, {"referenceID": 5, "context": "Reactive ASP as described in [6] can be seen as a more straightforward generalization of EVOLP where operations other than assert for self-updating a program are permitted.", "startOffset": 29, "endOffset": 32}, {"referenceID": 5, "context": "operations in the head of bridge rules, it is also not difficult to show that Reactive ASP as described in [6] can be captured by eMCSs.", "startOffset": 107, "endOffset": 110}, {"referenceID": 19, "context": "Also, as already outlined in [20], an important non-trivial topic is the study of the notion of minimal change within an evolving equilibrium.", "startOffset": 29, "endOffset": 33}, {"referenceID": 17, "context": "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].", "startOffset": 86, "endOffset": 90}, {"referenceID": 27, "context": "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].", "startOffset": 152, "endOffset": 164}, {"referenceID": 28, "context": "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].", "startOffset": 152, "endOffset": 164}, {"referenceID": 30, "context": "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].", "startOffset": 152, "endOffset": 164}, {"referenceID": 28, "context": "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].", "startOffset": 220, "endOffset": 228}, {"referenceID": 29, "context": "grained characterization of updating bridge rules (and knowledge bases) as studied in [18] in light of the encountered difficulties when updating rules [28, 29, 31] and the combination of updates over various formalisms [29, 30].", "startOffset": 220, "endOffset": 228}, {"referenceID": 32, "context": "Also interesting is to study how to perform AGM style belief revision at the (semantic) level of the equilibria, as in Wang et al [33], though different since knowledge is not incorporated in the contexts.", "startOffset": 130, "endOffset": 134}], "year": 2015, "abstractText": "Managed Multi-Context Systems (mMCSs) provide a general framework for integrating knowledge represented in heterogeneous KR formalisms. Recently, evolving Multi-Context Systems (eMCSs) have been introduced as an extension of mMCSs that add the ability to both react to, and reason in the presence of commonly temporary dynamic observations, and evolve by incorporating new knowledge. However, the general complexity of such an expressive formalism may simply be too high in cases where huge amounts of information have to be processed within a limited short amount of time, or even instantaneously. In this paper, we investigate under which conditions eMCSs may scale in such situations and we show that such polynomial eMCSs can be applied in a practical use case.", "creator": "LaTeX with hyperref package"}}}