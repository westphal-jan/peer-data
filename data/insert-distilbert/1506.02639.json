{"id": "1506.02639", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "8-Jun-2015", "title": "New Limits for Knowledge Compilation and Applications to Exact Model Counting", "abstract": "... we show new limits on the hardware efficiency of implementation using current techniques to make exact probabilistic inference for large classes of natural problems. in particular we show new lower bounds on knowledge compilation to sdd and dnnf forms. we give strong lower bounds on the complexity of sdd representations by inference relating sdd size to maximal best - partition communication complexity. we use this relationship factor to prove exponential lower bounds on the sdd size estimation for representing a large data class of problems that occur naturally as logic queries over probabilistic databases. a consequence observed is that for representing unions of conjunctive queries, sdds are not qualitatively more concise than obdds. we also derive simple examples for which additive sdds must be exponentially less concise than fbdds. finally, accordingly we derive exponential lower planck bounds on recognizing the sizes of certain dnnf crystal representations computation using a new quasipolynomial simulation of dnnfs calculations by combining nondeterministic fbdds.", "histories": [["v1", "Mon, 8 Jun 2015 19:52:43 GMT  (234kb,D)", "https://arxiv.org/abs/1506.02639v1", "Full version of paper to appear at UAI 2015"], ["v2", "Wed, 19 Aug 2015 19:13:38 GMT  (235kb,D)", "http://arxiv.org/abs/1506.02639v2", "Full version of paper appearing UAI 2015 updated to include new references to related work"]], "COMMENTS": "Full version of paper to appear at UAI 2015", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["paul beame", "vincent liew"], "accepted": false, "id": "1506.02639"}, "pdf": {"name": "1506.02639.pdf", "metadata": {"source": "CRF", "title": "New Limits for Knowledge Compilation and Applications to Exact Model Counting", "authors": ["Paul Beame", "Vincent Liew"], "emails": ["beame@cs.washington.edu", "vliew@cs.washington.edu"], "sections": [{"heading": "1 Introduction", "text": "Weighted model counting is a fundamental problem in probabilistic inference that captures the computation of probabilities of complex predicates over independent random events (Boolean variables). Although the problem is #P-hard in general, there are a number of practical algorithms for model counting based on DPLL algorithms and on knowledge compilation techniques. The knowledge compilation approach, though more space intensive, can be much more convenient since it builds a representation for an input predicate independent of its weights that allows the count to evaluated easily given a particular choice of weights; that representation also can be re-used to analyze more complicated predicates. Moreover, with only a constant-factor increase in time, the methods using DPLL algorithms can be easily extended to be knowledge compilation algorithms [Huang and Darwiche, 2007]. (See [Gomes et al., 2009] for a survey.)\nThe representation to be used for knowledge compilation is an important key to the utility of these methods in practice; the best methods are based on restricted classes of circuits and on decision diagrams. All of the ones considered to date can be seen as natural sub-classes of the class of Decomposable Negation Normal Form (DNNF) formulas/circuits introduced in [Darwiche, 2001], though it is not known how to do model counting efficiently for the full class of DNNF formulas/circuits. One sub-class for which model counting is efficient given the representation is that of d-DNNF formulas, though there is no efficient algorithm known to recognize whether a DNNF formula is d-DNNF.\nA special case of d-DNNF formulas (with a minor change of syntax) that is easy to recognize is that of decision-DNNF formulas. This class of representations captures all of the practical model counting algorithms discussed in [Gomes et al., 2009] including those based on DPLL algorithms. Decision-DNNFs include\n\u2217 Research supported by NSF grant CCF-1217099.\nar X\niv :1\n50 6.\n02 63\n9v 2\n[ cs\n.A I]\n1 9\nA ug\nOrdered Binary Decision Diagrams (OBDDs), which are canonical and have been highly effective representations for verification, and also Free BDDs (FBDDs), which are also known as read-once branching programs. Using a quasi-polynomial simulation of decision-DNNFs by FBDDs, [Beame et al., 2013, Beame et al., 2014] showed that the best decision-DNNF representations must be exponential even for many very simple 2-DNF predicates that arise in probabilistic databases.\nRecently, [Darwiche, 2011] introduced another subclass of d-DNNF formulas called Sentential Decision Diagrams (SDDs). This class is strictly more general than OBDDs and (in its basic form) is similarly canonical. (OBDDs use a fixed ordering of variables, while SDDs use a fixed binary tree of variables, known as a vtree.) There has been substantial development and growing application of SDDs to knowledge representation problems, including a recently released SDD software package [SDD, 2014]. Indeed, SDDs hold potential to be more concise than OBDDs. [Van den Broeck and Darwiche, 2015] showed that compressing an SDD with a fixed vtree so that it is canonical can lead to an exponential blow-up in size, but much regarding the complexity of SDD representations has remained open.\nIn this paper we show the limitations both of general DNNFs and especially of SDDs. We show that the simulation of decision-DNNFs by FBDDs from [Beame et al., 2013] can be extended to yield a simulation of general DNNFs by OR-FBDDs, the nondeterministic extension of FBDDs, from which we can derive exponential lower bounds for DNNF representations of some simple functions. This latter simulation, as well as that of [Beame et al., 2013], is tight, since [Razgon, 2015a] (see also [Razgon, 2014]) shows a quasipolynomial separation between DNNF and OR-FBDD size using parameterized complexity.\nFor SDDs we obtain much stronger results. In particular, we relate the SDD size required to represent predicate f to the \u201dbest-case partition\u201d communication complexity [Kushilevitz and Nisan, 1997] of f . Using this, together with reductions to the communication complexity of disjointness (set intersection), we derive the following results: (1) There are simple predicates given by 2-DNF formulas for which FBDD size is polynomial but for which SDD size must be exponential. (2) For a natural, widely-studied class of database queries known as Unions of Conjunctive Queries (UCQ), the SDD size is linear iff the OBDD size is linear and is exponential otherwise (which corresponds to a query that contains an inversion [Jha and Suciu, 2013]). (3) Similar lower bounds apply to the dual of UCQ, which consists of universal, positive queries.\nTo prove our SDD results, we show that for any predicate f given by an SDD of size S, using its associated vtree we can partition the variables of f between two players, Alice and Bob, in a nearly balanced way so that they only need to send log2 S bits of communication to compute f . The characterization goes through an intermediate step involving unambiguous communication protocols and a clever deterministic simulation of such protocols from [Yannakakis, 1991].\nRelated work: The quasi-polynomial simulation of DNNFs by OR-FBDDs that we give was also shown independently in [Razgon, 2015b]. Beyond the lower bounds for decision-DNNFs in [Beame et al., 2013, Beame et al., 2014] which give related analyses for decision-DNNFs, the work of [Pipatsrisawat and Darwiche, 2010] on structured DNNFs is particularly relevant to this paper1. [Pipatsrisawat and Darwiche, 2010] show how sizes of what they term (deterministic) X-decompositions can yield lower bounds on the sizes of structured (deterministic) DNNFs, which include SDDs as a special case. [Pipatsrisawat, 2010] contains the full details of how this can be applied to prove lower bounds for specific predicates. These bounds are actually equivalent to lower bounds exponential in the best-partition nondeterministic (respectively, unambiguous) communication complexity of the given predicates. Our paper derives this lower bound for SDDs directly but, more importantly, provides the connection to best-partition deterministic communication complexity, which allows us to have a much wider range of application; this strengthening is necessary for our applications. Finally, we note that [Razgon, 2014] showed that SDDs can be powerful by finding examples where OBDDs using any order are quasipolynomially less concise than SDDs.\n1We thank the conference reviewers for bringing this work to our attention.\nRoadmap: We give the background and some formal definitions including some generalization required for this work in Section 2. We prove our characterization of SDDs in terms of best-partition communication complexity in Section 3 and derive the resulting bounds for SDDs for natural predicates in Section 4. We describe the simulation of DNNFs by OR-FBDDs, and its consequences, in Section 5."}, {"heading": "2 Background and Definitions", "text": "We first give some basic definitions of DNNFs and decision diagrams.\nDefinition 2.1. A Negation Normal Form (NNF) circuit is a Boolean circuit with \u00ac gates, which may only be applied to inputs, and \u2228 and \u2227 gates. Further, it is Decomposable (DNNF) iff the children of each \u2227 gate are reachable from disjoint sets of input variables. (Following convention, we call this circuit a \u201cDNNF formula\u201d, though it is not a Boolean formula in the usual sense of circuit complexity.) A DNNF formula is deterministic (d-DNNF) iff the functions computed at the children of each \u2228 gate are not simultaneously satisfiable.\nDefinition 2.2. A Free Binary Decision Diagram (FBDD) is a directed acyclic graph with a single source (the root) and two specified sink nodes, one labeled 0 and the other 1. Every non-sink node is labeled by a Boolean variable and has two out-edges, one labeled 0 and the other 1. No path from the root to either sink is labeled by the same variable more than once. It is an OBDD if the order of variable labels is the same on every path. The Boolean function computed by an FBDD is 1 on input a iff there is a path from the root to the sink labeled 1 so that for every node label Xi on the path, ai is the label of the out-edge taken by the path. An OR-FBDD is an FBDD augmented with additional nodes of arbitrary fan-out labeled \u2228. The function value for the OR-FBDD follows the same definition as for FBDDs; the \u2228-nodes simply make more than one path possible for a given input. (See [Wegener, 2000].)\nWe now define sentential decision diagrams as well as a small generalization that we will find useful.\nDefinition 2.3. For a set X, let > : {0, 1}X \u2192 {0, 1} and \u22a5 : {0, 1}X \u2192 {0, 1} denote the constant 1 function and constant 0 function, respectively.\nDefinition 2.4. We say that a set of Boolean functions {p1, p2, . . . , p`}, where each pi has domain {0, 1}X, is disjoint if for each i 6= j, pi\u2227pj = \u22a5. We call {p1, p2, . . . , p`} a partition if it is disjoint and \u2228` i=1 pi = >.\nDefinition 2.5. A vtree for variables X is a full binary tree whose leaves are in one-to-one correspondence with the variables in X.\nWe define Sentential Decision Diagrams (SDDs) together with the Boolean functions they represent and use \u3008.\u3009 to denote the mapping from SDDs into Boolean functions. (This notation is extended to sets of SDDs yielding sets of Boolean functions.) At the same time, we also define a directed acyclic graph (DAG) representation of the SDD.\nDefinition 2.6. \u03b1 is an SDD that respects vtree v rooted at v iff:\n\u2022 \u03b1 = > or \u03b1 = \u22a5. Semantics: \u3008>\u3009 = > and \u3008\u22a5\u3009 = \u22a5. G(\u03b1) consists of a single leaf node labeled with \u3008\u03b1\u3009.\n\u2022 \u03b1 = X or \u03b1 = \u00acX and v is a leaf with variable X. Semantics: \u3008X\u3009 = X and \u3008\u00acX\u3009 = \u00acX G(\u03b1) consists of a single leaf node labeled with \u3008\u03b1\u3009.\n\u2022 \u03b1 = {(p1, s1), . . . , (p`, s`)}, v is an internal vertex with children vL and vR, p1, . . . , p` are SDDs that respect the subtree rooted at vL, s1, . . . , s` are SDDs that respect the subtree rooted at vR, and \u3008p1\u3009, . . . , \u3008p`\u3009 is a partition.\nSemantics: \u3008\u03b1\u3009 = \u2228n i=1 ( \u3008pi\u3009 \u2227 \u3008si\u3009\n) G(\u03b1) has a circle node for \u03b1 labeled v with ` child box nodes labeled by the pairs (pi, si). A box node labeled (pi, si) has a left child that is the root of G(pi) and and a right child that is the root of G(si). The rest of G(\u03b1) is the (non-disjoint) union of graphs G(p1), . . . , G(p`) and G(s1), . . . , G(s`) with common sub-DAGs merged. (See Figure 1.)\nEach circle node \u03b1\u2032 in G(\u03b1) itself represents an SDD that respects a subtree of v rooted at some vertex v\u2032 of v; We say that \u03b1\u2032 is in \u03b1 and use Sdds(v\u2032, \u03b1) to denote the collection of \u03b1\u2032 in \u03b1 that respect the subtree rooted at v\u2032. The size of an SDD \u03b1 is the number of nodes in G(\u03b1).\nCircle nodes in G(\u03b1) may be interpreted as OR gates and paired box nodes may be interpreted as AND gates. In the rest of this paper, we will view SDDs as a class of Boolean circuit. The vtree property and partition property of SDDs together ensure that this resulting circuit is a d-DNNF.\nWe define a small generalization of vtrees which will be useful for describing SDDs with respect to a partial assignment of variables.\nDefinition 2.7. A pruned vtree for variables X is a full binary tree whose leaves are either marked stub or by a variable in X, and whose leaves marked by variables are in one-to-one correspondence with the variables in X.\nWe generalize SDDs so that they can respect pruned vtrees. The definition is almost identical to that for regular SDDs so we only point out the differences.\nDefinition 2.8. The definition of a pruned SDD \u03b1 respecting a pruned vtree v, its semantics, and its graph G(\u03b1), are identical to those of an SDD except that\n\u2022 if the root vertex v of v is a stub then \u3008\u03b1\u3009 must be \u22a5 or >, and\n\u2022 if the root vertex v of v is internal then we only require that \u3008p1\u3009, . . . , \u3008p`\u3009 are disjoint but not necessarily that they form a partition.\nWe now sketch a very brief overview of the communication complexity we will need. Many more details may be found in [Kushilevitz and Nisan, 1997]. Given a Boolean function f on {0, 1}X \u00d7 {0, 1}Y, one can define two-party protocols in which two players, Alice, who receives x \u2208 {0, 1}X and Bob, who receives y \u2208 {0, 1}Y exchange a sequence of messages m1, . . . ,mC = f(x, y) \u2208 {0, 1} to compute f . (After each bit, the player to send the next bit must be determined from previous messages.) The (deterministic) communication complexity of f , CC(f(X,Y)), is the minimum value C over all protocols computing f such that all message sequences are of length at most C. The one-way deterministic communication complexity of f , CCX\u2192Y(f(X,Y)) is the minimum value of C over all protocols where Alice may send messages to Bob, but Bob cannot send messages to Alice.\nFor nondeterministic protocols, Alice simply guesses a string based on her input x and sends the resulting message m to Bob, who uses m together with y to verify whether or not f(x, y) = 1. The communication complexity in this case is the minimum |m| over all protocols. Such a protocol is unambiguous iff for each (x, y) pair such that f(x, y) = 1 there is precisely one message m that will cause Bob to output 1. A set of the form A\u00d7B for A \u2286 {0, 1}X, B \u2286 {0, 1}Y is called a rectangle. The minimum of |m| over all unambiguous\nprotocols is the unambiguous communication complexity of f ; it is known to be the logarithm base 2 of the minimum number of rectangles into which one can partition the set of inputs on which f is 1.\nA canonical hard problem for communication complexity is the two-party disjointness (set intersection) problem, \u2228n i=1 xi \u2227 yi where x and y are indicator vectors of sets in [n]. It has deterministic communication complexity n+ 1 (and requires \u2126(n) bits be sent even with randomness, but that is beyond what we need). We will need a variant of the \u201cbest partition\u201d version of communication complexity in which the protocol includes a choice of the best split of input indices X and Y between Alice and Bob.\nA typical method for proving lower bounds on OBDD size for a Boolean function f begins by observing that a size s OBDD may be simulated by a log s-bit one-way communication protocol where Alice holds the first half of the variables read by the OBDD and Bob holds the second half. In this protocol, Alice starts at the root of the OBDD and follows the (unique) OBDD path determined by her half of the input until she reaches a node v querying a variable held by Bob. She then sends the identity of the node v to Bob, who can finish the computation starting from v. Thus, if we show that f has one-way communication complexity CCX\u2192Y(f(X,Y)) at least C in the best split {X,Y} of its input variables, then any OBDD computing f must have at least 2C nodes.\nOur lower bound for SDDs uses related ideas but in a more sophisticated way, and instead of providing a one-way deterministic protocol, we give an unambiguous protocol that simulates the SDD computation. In particular, the conversion to deterministic protocols requires two-way communication."}, {"heading": "3 SDDs and Best-Partition Communication Complexity", "text": "In this section, we show how we can use any small SDD representing a function f to build an efficient communication protocol for f given an approximately balanced partition of input variables that is determined by its associated vtree. As a consequence, any function requiring large communication complexity under all such partitions requires large SDDs. To begin this analysis, we consider how an SDD simplifies under a partial assignment to its input variables."}, {"heading": "3.1 Pruning SDDs Using Restrictions", "text": "Definition 3.1. Suppose that v is a pruned vtree for a set of variables X, and that v is a vertex in v. Let Vars(v) denote the set of variables that are descendants of v in v and Shell(v) = X \\ Vars(v). Also let Parent(v) denote the (unique) vertex in v that has v as a child.\nWe define a construction to capture what happens to an SDD under a partial assignment of its variables.\nDefinition 3.2. Let \u03b1 be an SDD that respects v, a vtree for the variables X, and suppose that \u03b1 computes the function f . Let B \u2286 X and A = X \\B and let \u03c1 : A \u2192 {0, 1} be an assignment to the variables in A. Let \u03b1|\u03c1 be Boolean circuit remaining after plugging the partial assignment \u03c1 into the SDD \u03b1 and making the following simplifications:\n1. If a gate computes a constant c \u2208 {>,\u22a5} under the partial assignment \u03c1, we can replace that gate and its outgoing edges with c.\n2. Remove any children of OR-gates that compute \u22a5.\n3. Remove any nodes disconnected from the root.\nFor each vtree vertex v \u2208 v that was not removed in this process, we denote its counterpart in the pruned vtree v|A by v|A.\nConstruct the pruned vtree v|A from v as follows: for each vertex v, if Vars(v) \u2286 A and Vars(Parent(v)) 6\u2286 A, replace v and its subtree by a stub. We say that we have pruned the subtree rooted at v. (See Figure 2 for an example of an SDD and its vtree both before and after pruning.)\nFor A \u2286 X, we call {A,X \\ A} a shell partition for X if there is a vtree vertex v \u2208 v such that Shell(v) = A. We call A the shell. If, for a restriction \u03c1 : A\u2192 {0, 1}, there exists a vtree vertex v \u2208 v such that Shell(v) = A, we call \u03c1 a shell restriction.\nProposition 3.3. Let \u03b1 be an SDD that respects v, a vtree for the variables X, and suppose that \u03b1 computes the function f . Let A \u2286 X and \u03c1 : A \u2192 {0, 1} be a partial assignment of the variables in A. The pruned SDD \u03b1|\u03c1 has the following properties: (a) \u3008\u03b1|\u03c1\u3009 = f |\u03c1. (b) \u03b1|\u03c1 is a pruned SDD respecting v|A. (c) G(\u03b1|\u03c1) is a subgraph of G(\u03b1).\nProof. (a): An SDD may be equivalently described as a Boolean circuit of alternating OR and AND gates. For any Boolean circuit in the variables X that computes f , plugging in the values for the restriction \u03c1 yields a circuit computing f |\u03c1. Furthermore, the simplification steps do not change the function computed.\n(b): For each v such that Vars(v) \u2286 A and Vars(Parent(v)) 6\u2286 A, we have replaced the subtree rooted at v by a stub and replaced the SDDs in \u03b1 respecting v by either > or \u22a5. Thus \u03b1|\u03c1 respects v|A.\nWe now check that \u03b1|\u03c1 is a pruned SDD. In particular we need to ensure that for each SDD \u03b1\u2032 = {(p1, s1), . . . , (p`, s`)} in \u03b1, the corresponding pruned SDDs that remain from p1, . . . , p` in its pruned counterpart \u03b1\u2032|\u03c1 represent a collection of disjoint functions. From the first part of this proposition, these are \u3008pi1\u3009|\u03c1, . . . , \u3008pik\u3009|\u03c1 for some k \u2264 n, where we have only included those SDDs that are consistent under \u03c1. Since the original set of SDDs was a partition and thus disjoint, this set of restricted (pruned) SDDs is also disjoint.\n(c): The process in Definition 3.2 only removes nodes from G(\u03b1) to construct G(\u03b1|\u03c1). Further, it does not change the label of any SDD that was not removed."}, {"heading": "3.2 Unambiguous Communication Protocol for SDDs", "text": "The way that we will partition the input variables to an SDD between the parties Alice and Bob in the communication protocol will respect the structure of its associated vtree. The restrictions will correspond to assignments that reflect Alice\u2019s knowledge of the input and will similarly respect that structure.\nNotice that a vtree cut along an edge (u, v) (where u is the parent of v) induces a shell partition for X consisting of the set B = Vars(v), and the shell A = X \\B.\nProposition 3.4. Let \u03b1 be an SDD of size s computing a function f : {0, 1}X \u2192 {0, 1} that respects a vtree v. Suppose that {A,B} is a shell partition for X and that A is its shell. Let b be the vertex in v for which Vars(b) = B and Vars(Parent(b)) 6\u2286 B.\nFor any shell restriction \u03c1 : A\u2192 {0, 1}, the set \u3008Sdds\u03b1|\u03c1(b|A)\u3009 is a disjoint collection of functions.\nProof. For non-shell restrictions \u03c1\u2032, the collection of functions \u3008Sdds\u03b1|\u03c1\u2032 (v)\u3009 for a vtree node v is not disjoint; we need to use the specific properties of A and b. Since \u03c1 was a shell restriction, the pruned vtree v|A takes the form of a path v1|A, . . . , vk|A of internal vertices, where v1 is the root of v, and vk|A = b|A, with the other child of each of v1|A, . . . , vk\u22121|A being a stub, together with a vtree for the variables B rooted at b. We will show that if \u3008Sdds\u03b1|\u03c1(vi|A)\u3009 is disjoint then so is \u3008Sdds\u03b1|\u03c1(vi+1|A)\u3009. This will prove the proposition since \u3008Sdds\u03b1|\u03c1(v1|A)\u3009 only contains the function \u3008\u03b1|\u03c1\u3009 and is therefore trivially disjoint.\nWe will use the fact that every pruned-SDD from Sdds\u03b1|\u03c1(vi+1|A) is contained in some SDD from Sdds\u03b1|\u03c1(vi|A). We have two cases to check: vi+1|A is either a left child or a right child of vi|A.\nIf vi+1|A was a right child then each pruned-SDD \u03b7|\u03c1 contained in Sdds\u03b1|\u03c1(vi|A) takes the form \u03b7|\u03c1 = {(>, s|\u03c1)}. Then \u3008Sdds\u03b1|\u03c1(vi+1|A)\u3009 = \u3008Sdds\u03b1|\u03c1(vi|A)\u3009 and is therefore disjoint by assumption.\nOtherwise suppose that vi+1|A is the left child of vi|A. Let \u03b7|\u03c1 \u2208 Sdds\u03b1|\u03c1(vi|A). Let \u03b7|\u03c1 = {(\u03b71|\u03c1,>), . . . , (\u03b7k|\u03c1),>)} where \u2228k i=1\u3008\u03b7i|\u03c1\u3009 = \u3008\u03b7|\u03c1\u3009 and {\u3008\u03b71|\u03c1\u3009, . . . , \u3008\u03b7k|\u03c1\u3009} , being a collection of primes for \u03b7|\u03c1, is disjoint. By assumption \u3008Sdds\u03b1|\u03c1(vi|A)\u3009 is disjoint, so for any other \u03b7\u2032|\u03c1 = {(\u03b7\u20321|\u03c1,>), . . . , (\u03b7\u2032k\u2032 |\u03c1,>)} \u2208 Sdds\u03b1|\u03c1(vi|A)} distinct from \u03b7|\u03c1, we have \u3008\u03b7|\u03c1\u3009 \u2227 \u3008\u03b7\u2032|\u03c1\u3009 = \u22a5. Then for any i \u2208 [k] and j \u2208 [k\u2032], we have \u3008\u03b7i|\u03c1\u3009 \u2227 \u3008\u03b7\u2032j |\u03c1\u3009 = \u22a5. Thus \u3008Sdds\u03b1|\u03c1(vi+1|A)\u3009 is disjoint.\nTheorem 3.5. Let \u03b1 be an SDD of size s that respects a vtree v and suppose that it computes the function f : {0, 1}X \u2192 {0, 1}. Suppose that {A,B} is a shell partition for X and that A is the shell. Let b be the vertex in v for which Vars(b) = B and Vars(Parent(b)) 6\u2286 B.\nConsider the communication game where Alice has the variables A, Bob has the variables B, and they are trying to compute f(A,B). There is a log s-bit unambiguous communication protocol computing f .\nProof. Suppose that Alice and Bob both know the SDD \u03b1. Let \u03c1 : A \u2192 {0, 1} be the partial assignment corresponding to Alice\u2019s input. This is a shell restriction. Alice may then privately construct the pruned SDD \u03b1|\u03c1, which computes f |\u03c1 by Proposition 3.3. Further, \u03b1|\u03c1 evaluates to 1 under Bob\u2019s input \u03c6 : B\u2192 {0, 1} if and only if there exists a pruned-SDD \u03b7|\u03c1 \u2208 Sdds\u03b1|\u03c1(b|A) such that \u3008\u03b7|\u03c1\u3009(\u03c6) = 1.\nBy Proposition 3.4, \u3008Sdds\u03b1|\u03c1(b|A)\u3009 is disjoint. Also, since \u03c1 is a shell restriction with shell A, and Vars(b) = B = X \\ A, every SDD in Sdds\u03b1|\u03c1(b|A) was unchanged by \u03c1. In particular, this means that Sdds\u03b1|\u03c1(b|A) \u2286 Sdds\u03b1(b) and any pruned-SDD \u03b7|\u03c1 can be viewed as some \u03b7 \u2208 Sdds\u03b1(b) that is also in Sdds\u03b1|\u03c1(b|A).\nFor the protocol Alice nondeterministically selects an \u03b7 from Sdds\u03b1|\u03c1(b|A) and then sends its identity as a member of Sdds\u03b1(b) to Bob. This requires at most log s bits. Bob will output 1 on his input \u03c6 if and only if \u3008\u03b7\u3009(\u03c6) = 1, which he can test since he knows \u03b1 and b. This protocol is unambiguous since the fact that \u3008Sdds\u03b1|\u03c1(b|A)\u3009 is disjoint means means that for any input \u03c6 to Bob there is at most one \u03b7 \u2208 Sdds\u03b1|\u03c1(b|A) such that \u3008\u03b7\u3009(\u03c6) = 1. Since Bob knows \u03b1, he also knows \u03b7 and can therefore compute \u3008\u03b7\u3009(\u03c6). Since \u03b1 computes f , if \u3008\u03b7\u3009(\u03c6) = 1 then f(\u03c6, \u03c1) = 1. Otherwise all of the functions in \u3008Sdds\u03b1|\u03c1(b|A)\u3009 evaluate to 0 on input \u03c6 so f(\u03c6, \u03c1) = 0.\nWe can relate the deterministic and unambiguous communication complexities of a function using the following result from [Yannakakis, 1991]. We include a proof of this result in the appendix for completeness.\nTheorem 3.6 (Yannakakis). If there is an g-bit unambiguous communication protocol for a function f : {0, 1}A \u00d7 {0, 1}B \u2192 {0, 1}, then there is a (g + 1)2-bit deterministic protocol for f .\nThe following 1/3-2/3 lemma is standard.\nLemma 3.7. For a vtree v for L variables, if a vertex b satisfies 13L \u2264 |Vars(b)| \u2264 2 3L, we call it a (1/3, 2/3) vertex. Every vtree contains a (1/3, 2/3) vertex.\nDefinition 3.8. Let X be a set of variables and (A,B) a partition of X. We call the partition (A,B) a (\u03b4, 1 \u2212 \u03b4)-partition for \u03b4 \u2208 [0, 1/2] if min(|A|, |B|) \u2265 \u03b4|X|. That is, the minimum size of one side of the partition is at least a \u03b4-fraction of the total number of variables.\nThe best (\u03b4, 1 \u2212 \u03b4)-partition communication complexity of a Boolean function f : {0, 1}X \u2192 {0, 1} is min(CC(f(A,B))) where the minimum is taken over all (\u03b4, 1\u2212 \u03b4)-partitions (A,B).\nTheorem 3.9. If the best (1/3, 2/3)-partition communication complexity of a Boolean function f : {0, 1}X \u2192 {0, 1} is C, then an SDD computing f has size at least 2 \u221a C\u22121.\nProof. Suppose that \u03b1 is an SDD of size s respecting the vtree v for variables X, and that \u03b1 computes f . From Lemma 3.7 the vtree v contains a (1/3, 2/3) vertex b. This (1/3, 2/3) vertex b induces a (1/3, 2/3)- partition of the variables {A,B} where B = Vars(b) and A = Shell(b). Further, this partition {A,B} is a shell partition. By Theorem 3.5, there exists a log s-bit unambiguous communication protocol for f(A,B). Then by Theorem 3.6, there exists a (log(s) + 1)2-bit deterministic communication protocol for f(A,B). Since the best (1/3, 2/3)-partition communication complexity of f is C, we have that C \u2264 (log(s) + 1)2 which implies that s \u2265 2 \u221a C\u22121 as stated."}, {"heading": "4 Lower Bounds for SDDs", "text": "There are a large number of predicates f : {0, 1}n \u2192 {0, 1} for which the (1/3, 2/3)-partition communication complexity is \u2126(n) and by Theorem 3.9 each of these requires SDD size 2\u2126( \u221a n). The usual best-partition communication complexity is (1/2, 1/2)-partition communication complexity. For example, the function ShiftedEQ which takes as inputs x, y \u2208 {0, 1}n and z \u2208 {0, 1}dlog2 ne and tests whether or not y = SHIFT (x, z) where SHIFT (x, z) is the cyclic shift of x by (z)2 positions. However, as is typical of these functions, the same proof which shows that the (1/2, 1/2)-partition communication complexity of ShiftedEQ is \u2126(n) also shows that its (1/3, 2/3)-partition communication complexity is \u2126(n). However, most of these functions are not typical of predicates to which one might want to apply weighted model counting. Instead we analyze SDDs for formulas derived from a natural class of database queries. We are able to characterize SDD size for these queries, proving exponential lower bounds for every such query that cannot already be represented in linear size by an OBDD. This includes an example of a query called QV for which FBDDs are polynomial size but the best SDD requires exponential size."}, {"heading": "4.1 SDD Knowledge Compilation for Database Query Lineages", "text": "We analyze SDDs for a natural class of database queries called the union of conjunctive queries (UCQ). This includes all queries given by the grammar\nq ::= R(x) | \u2203xq | q \u2227 q | q \u2228 q\nwhere R(x) is an elementary relation and x is a variable. For each such query q, given an input database D, the query\u2019s lineage, \u03a6Dq , is a Boolean expression for q over Boolean variables that correspond to tuples in D. In general, one thinks of the query size as fixed and considers the complexity of query evaluation as a function of the size of the database. The following formulas are lineages (or parts thereof) of well-known queries that that are fundamental for probabilistic databases [Dalvi and Suciu, 2012, Jha and Suciu, 2013]\nover a particular database D0 (called the complete bipartite graph of size m in [Jha and Suciu, 2013]): H0 = \u2228\ni,j\u2208[m]\nRiSijTj\nQV = \u2228\ni,j\u2208[m]\nRiSij \u2228 SijTj \u2228RiTj\nH1 = \u2228\ni,j\u2208[m]\nRiSij \u2228 SijTj\nHk0 = \u2228 i\u2208[m] RiS 1 ij for k \u2265 1\nHk` = \u2228\ni,j\u2208[m]\nS`ijS `+1 ij for 0 < ` < k\nHkk = \u2228 i\u2208[m] SkijTj for k \u2265 1.\n(The corresponding queries are represented using lower case letters h0, qV , h1, hk0, . . . , hkk and involve unary relations R and T , as well as binary relations S and Sk. For example, h0 = \u2203x0\u2203y0R(x0)S(x0, y0)T (y0).) The following lemma will be useful in identifying subformulas of the above query lineages that can be used to compute the set disjointness function.\nProposition 4.1. Let the elements of [m] \u00d7 [m] be partitioned into two sets A and B, each of size at least \u03b4m2. Let Row(i) denote {i} \u00d7 [m] and Col(j) denote [m] \u00d7 {j}. Define WRow = {i \u2208 [m] | \u2205 6= Row(i) \u2229 A and \u2205 6= Row(i) \u2229 B}. That is, Row(i) for i \u2208 WRow is split into two nonempty pieces by the partition. Similarly, define WCol = {i \u2208 [m] | \u2205 6= Col(j) \u2229A and \u2205 6= Col(j) \u2229B}. Then\nmax(|WRow|, |WCol|) \u2265 \u221a \u03b4 \u00b7m.\nProof. Suppose that both |WRow| < m and |WCol| < m. By definition, if i /\u2208 WRow then one of A or B contains an entire row, Row(i), say A without loss of generality. This implies that no column Col(j) is entirely contained in B. Since |WCol| < m, there is some column Col(j) that is entirely contained in A. This in turn implies that B does not contain any full row. In particular, we have that A contains all rows in [m] \\WRow and all columns in [m] \\WCol and thus B \u2286 WRow \u00d7WCol and so |B| \u2264 |WRow| \u00b7 |WCol|. By assumption, |B| \u2265 \u03b4m2. Hence |WRow| \u00b7 |WCol| \u2265 \u03b4m2 and so max{|wRow|, |wCol|} \u2265 \u221a \u03b4 \u00b7m.\nTheorem 4.2. For m \u2265 6, the best (1/3, 2/3)-partition communication complexity of QV , H0, and of H1 is at least m/3.\nProof. Let X be the set of variables appearing inQV (orH1) and let (A,B) be a (1/3, 2/3)-partition of X. Let (A,B) be the partition of [m]\u00d7[m] induced by (A,B) and define WRow and WCol as in Proposition 4.1. Since |X| = m2 +2m and only elements of [m]\u00d7 [m] are relevant, |A|, |B| \u2265 (m2 +2m)/3\u22122m = (1\u22124/m)m2/3 \u2265 m2/9 for m \u2265 6 and hence max(|WRow|, |WCol|) \u2265 m/3. We complete the proof by showing that computing QV (A,B) and H1(A,B) each require at least max(|WRow|, |WCol|) bits of communication between Alice and Bob. We will do this by showing that for a particular subset of inputs, QV is equivalent to the disjointness function for a max(|WRow|, |WCol|) size set.\nSuppose without loss of generality that |WRow| \u2265 |WCol|. Set all Tj = 0 and for each i /\u2208 WRow set Ri = 0. For each i \u2208WRow for which Ri \u2208 A, set all Sij \u2208 A to 0, let ji be minimal such that Siji \u2208 B, and set Sij \u2208 B to 0 for all j > ji. (Such an index ji must exist since i \u2208 WRow.) Similarly, For each i \u2208 WRow for which Ri \u2208 B, set all Sij \u2208 B to 0, let ji be minimal such that Siji \u2208 A, and set Sij \u2208 A to 0 for all j > ji. In particular, under this partial assignment, we have\nQV = H1 = \u2228\ni\u2208WRow\nRiSiji\nand for each i \u2208WRow, Alice holds one of Ri or Siji and Bob holds the other. We can reduce H0 to the same quantity by setting all Tj = 1. This is precisely the set disjointness problem on two sets of size |WRow| where membership of i in each player\u2019s set is determined by the value of the unset bit indexed by i that player holds. Therefore, computing QV or H1 requires at least |WRow| bits of communication, as desired.\nCombining this with Theorem 3.9, we immediately obtain the following:\nTheorem 4.3. For m \u2265 6, any SDD representing QV or H1 requires size at least 2 \u221a m/3\u22121.\nAs [Jha and Suciu, 2013] has shown that QV has FBDD size O(m 2), we obtain the following separation.\nCorollary 4.4. FBDDs can be exponentially more succinct than SDDs. In particular, QV has FBDD size\nO(m2) but every SDD for QV requires size 2 \u221a m/3\u22121 for m \u2265 6.\nWe now consider the formulas Hki above. Though they seem somewhat specialized, these formulas are fundamental to UCQ queries: [Jha and Suciu, 2013] define the notion of an inversion in a UCQ query and use it to characterize the OBDD size of UCQ queries. In particular they show that if a query q is inversionfree then the OBDD size of its lineage Q is linear and if q has an minimum inversion length k \u2265 1 then it requires OBDD size 2\u2126(n/k) where n is the domain size of all attributes. Jha and Suciu obtain this lower bound by analyzing the Hki we defined above. (We will not define the notion of inversions, or their lengths, and instead use the definition as a black box. However, as an example, the query associated with H1 has an inversion of length 1 so its OBDD size is 2\u2126(m).)\nProposition 4.5. [Jha and Suciu, 2013] Let q be a query with a length k \u2265 1 inversion. Let D0 be the complete bipartite graph of size m. There exists a database D for q, along with variable restrictions \u03c1i for all i \u2208 [0, k], such that |D| = O(|D0|) and \u03a6Dq |\u03c1i = \u03a6 D0 hki = Hki\nTheorem 4.6. Let k \u2265 2 and assume that m \u2265 6. Let q be a query with a length k \u2265 2 inversion. Then there exists a database D for which any SDD for Q = \u03a6Dq has size at least 2 \u221a m/k/3\u22121. Proof. Given a query q, let D be the database for q constructed in Proposition 4.5. Fix the vtree v over Xk respected by an SDD \u03b1 for \u03a6 D q . By Lemma 3.7, there exists a (1/3, 2/3) node b in the vtree v that gives a (1/3, 2/3) partition {A,B} of Xk. By Proposition 4.5, there are restrictions \u03c10, . . . , \u03c1k such that \u03a6Dq |\u03c1i = Hki for all i. Thus \u03b1|\u03c1i is a (pruned) SDD, of size \u2264 that of \u03b1, respecting v|\u03c1i and computing Hki. Observe that the restriction of {A,B} to the variables of Xki is also shell partition of v|\u03c1i at node b.\nWe will show that there must exist an Hki for which CC(Hki(A,B)) \u2265 m/(9k) and therefore by Theorem 3.6, this implies that the unambiguous communication complexity of Hki is at least 1 3 \u221a m/k \u2212 1 Then by Theorem 3.5, any SDD respecting v that computes Hki has size at least 2 1 3 \u221a m/k\u22121.\nLet WChain contain all pairs (i, j) for which both A \u2229 \u22c3k `=1{S`ij} 6= \u2205 and B \u2229 \u22c3k `=1{S`ij} 6= \u2205 and Let \u03b3 = 1/9. We will consider two cases: either |WChain| \u2265 \u03b3 \u00b7m or |WChain| < \u03b3 \u00b7m. In the first case, since |WChain| \u2265 \u03b3 \u00b7m, there must exist at least \u03b3 \u00b7m tuples (i, j, `) for which either S`ij \u2208 A and S`+1ij \u2208 B or vice-versa. Call the set of these tuples T. Then, since there are k \u2212 1 choices of ` < k, there exists some `\u2217 such that the set T`\u2217 := T \u2229 [m]\u00d7 [m]\u00d7 {`\u2217} contains at least \u03b3 \u00b7m/(k \u2212 1) > m/(9k) elements. If we set all variables of Xk`\u2217 outside of T`\u2217 to 0, the function Hk`\u2217 corresponds to solving a disjointness problem between Alice and Bob on the elements of T`\u2217 . Thus the communication complexity of Hk`\u2217 under the partition {A,B} is at least m/(9k).\nIn the second case, consider the largest square submatrix M of [m] \u00d7 [m] that does not contain any member of WChain. We mimic the argument of Theorem 4.2 on this submatrix M . By definition, M has side m\u2032 \u2265 (1 \u2212 \u03b3)m. For every (i, j) in M , either A or B contains all S`ij ; let A be those (i, j) such that these are in A and B be those (i, j) for which they are in B. Since |A|, |B| \u2265 |Xk|/3 = (km2 + 2m)/3 and there are at most 2m+ (\u03b32 + 2\u03b3)km2 variables not in M ,\n|A|, |B| \u2265 [(km2 + 2m)/3\u2212 2m+ (\u03b32 + 2\u03b3)km2]/k = [(1\u2212 \u03b3)2 \u2212 2/3\u2212 4/(3km)]m2 > (m/18)2)\nsince k \u2265 2. Applying Proposition 4.1, we see that max(|WRow|, |WCol|) \u2265 m/18 \u2265 m/(9k). By the same argument presented in the proof of Theorem 4.2, we have both CC(Hk0(A,B)) \u2265 |WRow| and CC(Hkk(A,B)) \u2265 |WCol| so at least one of these is at least m/(9k) and the theorem follows.\nIt follows that for inversion-free UCQ queries, both SDD and OBDD sizes of any lineage are linear, while UCQ queries with inversions (of length k) have worse-case lineage size that is exponential (2\u2126(m/k) for OBDDs and 2\u2126( \u221a m/k) for SDDs). Note that the same SDD size lower bound for UCQ query lineage Q = \u03a6Dq applies to its dual Q \u2217 = \u03a6Dq\u2217 as follows: Flipping the signs on the variables in Q\n\u2217 yields a function equivalent to \u00acQ. So flipping the variable signs at the leaves of an SDD for Q\u2217 we obtain an SDD of the same size for \u00acQ and hence a deteministic protocol that also can compute Q."}, {"heading": "5 Simulating DNNFs by OR-FBDDs", "text": "In this section, we extend the simulation of decision-DNNFs by FBDDs from [Beame et al., 2013] to obtain a simulation of general DNNFs by OR-FBDDs with at most a quasipolynomial increase in size. This simulation yields lower bounds on DNNF size from OR-FBDD lower bounds. This simulation is also tight, since [Razgon, 2015a, Razgon, 2014] has shown a quasipolynomial separation between the sizes of DNNFs and OR-FBDDs.\nDefinition 5.1. For each AND node u in a DNNF D, let Mu be the number of AND nodes in the subgraph Du. We call u\u2019s left child ul and its right child ur. We will assume Mul \u2264Mur (otherwise we swap ul and ur).\nFor each AND node u, we classify the edge (u, ul) as a light edge and the edge (u, ur) a heavy edge. We classify every other edge in D as a neutral edge.\nFor a DNNF D or an OR-FBDD F , we denote the functions that D and F compute as \u03a6D and \u03a6F .\nConstructing the OR-FBDD\nFor a DNNF D, we will treat a leaf labeled by the variable X as a decision node that points to a 0-sink node if X = 0 and a 1-sink node if X = 1, and vice-versa for a leaf labeled by \u00acX. We also assume that each AND node has just two children, which only affects the DNNF size by at most polynomially.\nDefinition 5.2. Fix a DNNF D. For a node u in D and a path P from the root to u, let S(P ) be the set of light edges along P and S(u) = {S(P ) | P is a path from the root to u}.\nWe will construct an OR-FBDD F that computes the same boolean function as D. Its nodes are pairs (u, s) where u is a node in D and the set of light edges s belongs to S(u). Its root is (root(D), \u2205). The edges in F are of three types:\nType 1: For each light edge e = (u, v) in D and s \u2208 S(u), add the edge ((u, s), (v, s \u222a {e})) to F . Type 2: For each neutral edge e = (u, v) in D and s \u2208 S(u), add the edge ((u, s), (v, s)) to F . Type 3: For each heavy edge (u, vr), let e = (u, vl) be its sibling light edge. For each s \u2208 S(u) and 1-sink node w in Dvl , add the edge ((w, s \u222a {e}), (vr, s)) to F . We label the nodes u\u2032 = (u, s) as follows: (1) if u is a decision node in D for the variable X then u\u2032 is a decision node in F testing the same variable X, (2) if u is an AND-node, then u\u2032 is a no-op node, (3) if u is an OR node it remains an OR node. (4) if u is a 0-sink node, then u\u2032 is a 0-sink node, (5) if u is a 1-sink node, then: if s = \u2205 then u\u2032 is a 1-sink node, otherwise it is a no-op node.\nWe show an example of this construction in Figure 3.\nSize and Correctness\nLemma 5.3. For the DNNF D let L denote the maximum number of light edges from the root to a leaf, M the number of AND nodes and N the total number of nodes. Then F has at most NML nodes. Further, this is N \u00b7 2log2N .\nProof. The nodes in F are labeled (u, s). There are N possible nodes u and at most ML choices for the set s, as each path to u has at most L light edges.\nConsider a root to leaf path with L light edges. As we traverse this path, every time we cross a light edge, we decrease the number of descendant AND nodes by more than half. Thus we must have begun with more than 2L descendant AND nodes at the root so that N \u2265 M > 2L. This implies that NML is quasipolynomial in N ,\nThis upper bound is quasipolynomial in N , we will show that M > 2L. Then, since N \u2265 M , NML \u2264 N2log 2M \u2264 N2log2N .\nThe proof of the following lemma is in the full paper.\nLemma 5.4. F is a correct OR-FBDD with no-op nodes that computes the same function as D.\nUsing the quasipolynomial simulation of DNNFs by OR-FBDDs, we obtain DNNF lower bounds from OR-FBDD lower bounds.\nDefinition 5.5. Function PERMn takes an n\u00d7n boolean matrix M as input and outputs 1 if and only if M is a permutation matrix. The function ROW-COLn takes an n\u00d7 n boolean matrix M as input and outputs 1 if and only if M has an all-0 row or an all-0 column.\nTheorem 5.6. Any OR-FBDD computing PERMn or ROW-COL, must have size 2 \u2126(n) [Wegener, 2000]. Corollary 5.7. Any DNNF computing PERMn or ROW-COL has size at least 2 \u2126( \u221a n)"}, {"heading": "6 Discussion", "text": "We have made the first significant progress in understanding the complexity of general DNNF representations. We have also provided a new connection between SDD representations and best-partition communication complexity. Best-partition communication complexity is a standard technique used to derive lower bounds on OBDD size, where it often yields asymptotically tight results. For communication lower bound C, the lower bound for OBDD size is 2C and the lower bound we have shown for SDD size is 2 \u221a C \u2212 1. This is a quasipolynomial difference and matches the quasipolynomial separation between OBDD and SDD size shown in [Razgon, 2014]. Is there always a quasipolynomial simulation of SDDs by OBDDs in general, matching the quasipolynomial simulation of decision-DNNFs by FBDDs? Our separation result shows an example for which SDDs are sometimes exponentially less concise than FBDDs, and hence decision-DNNFs also. Are SDDs ever more concise than decision-DNNFs?\nBy plugging in the arguments of [Pipatsrisawat and Darwiche, 2010, Pipatsrisawat, 2010] in place of Theorem 3.5, all of our lower bounds immediately extend to size lower bounds for structured deterministic DNNFs (d-DNNFs), of which SDDs are a special case. It remains open whether structured d-DNNFs are strictly more concise than SDDs. [Pipatsrisawat and Darwiche, 2008, Pipatsrisawat, 2010] have proved an exponential separation between structured d-DNNFs and OBDDs using the Indirect Storage Access (ISA) function [Breitbart et al., 1995], but the small structured d-DNNF for this function is very far from an SDD.\nIt is immediate that, under any variable partition, the ISAn function has an O(log n)-bit two-round deterministic communication protocol. On the other hand, efficient one-round (i.e., one-way) communication protocols yield small OBDDs so there are two possibilities if SDDs and structured d-DNNFs have different power. Either (1) communication complexity considerations on their own are not enough to derive a separation between SDDs and structured d-DNNFs, or (2) every SDD can be simulated by an efficient one-way communication protocol, in which case SDDs can be simulated efficiently by OBDDs (though the ordering cannot be the same as the natural traversal of the associated vtree, as shown by [Xue et al., 2012])."}, {"heading": "Acknowledgements", "text": "We thank Dan Suciu and Guy Van den Broeck for helpful comments and suggestions."}, {"heading": "A Proof of Theorem 3.6", "text": "Let f(A,B) be a function with unambiguous communication complexity g and let Mf be its communication matrix. Then there exists a set D of 2g disjoint monochromatic rectangles that cover the 1\u2019s of Mf .\nLet G be a graph whose nodes are the rectangles in D and which has an edge connecting two rectangles if they share some row of Mf . Then each row r of Mf corresponds to a clique Kr containing the rectangles intersecting r. Similarly, every column c corresponds to an independent set Ic containing the rectangles intersecting c. For each row r and column c, the corresponding entry Mf (r, c) is 1 if and only if Kr \u2229 Ic 6= \u2205. Thus for proving the theorem, it suffices to give a g2 deterministic protocol for solving the Clique vs Independent set problem on a graph G with 2g vertices.\nThe protocol reduces the graph in each step. Suppose that Alice holds a clique K of an n vertex graph G and Bob holds an independent set I. In each round Alice sends a node u \u2208 K that is adjacent to fewer than half the nodes of G, or if no such node exists, she notifies Bob.\nIf Alice sent the node u, then Bob responds with whether (i) u \u2208 I, in which case K \u2229 I 6= \u2205, or (ii) that u is not adjacent to any node of I, in which case K \u2229 I = \u2205. If neither (i) nor (ii) occur then the nodes not adjacent to u are removed from G as they cannot be in K and the protocol repeats.\nOtherwise, if every u \u2208 K is adjacent to over half the nodes of G, Bob sends a node v \u2208 I that is adjacent to at least half the nodes in G if such a v exists. In this case Alice tells Bob that (i) v \u2208 K so that K \u2229I 6= \u2205, or (ii) v is adjacent to all nodes in K so that K \u2229 I = \u2205. Otherwise, Bob says he has no such v \u2208 I and the nodes adjacent to v are removed from G and the protocol repeats.\nEach iteration of this protocol removes at least half the nodes so that there are at most g iterations. The communication per iteration is at most g + 1 (to either send one of 2g nodes or that no good node exists)."}, {"heading": "B Proof of Lemma 5.4", "text": "Lemma B.1. F is a correct OR-FBDD with no-op nodes.\nProof. We need to show that F is acyclic and that every path reads a variable at most once. These two properties follow from the lemma:\nLemma B.2. If u is a leaf node in D labeled by the variable X and there exists a non-trivial path (with at least one edge) between the nodes (u, s), (v, s\u2032) in F , then the variable X does not occur in Dv.\nThis lemma implies that F is acyclic: a cycle in F implies a non-trivial path from some node (u, s) to itself, but X \u2208 Du. It also implies that every path in F is read-once: if a path tests a variable X twice, first at (u, s) and again at (u1, s1), then X \u2208 Du1 contradicting the claim.\nTo prove the lemma, suppose to the contrary that there exists an OR-FBDD node (u, s) such that u is a leaf labeled with X and that there exists a path from (u, s) to (v, s\u2032) in F such that X occurs in Dv. Choose v such that D is maximal; i.e. there is no path from (u, s) to some (v\u2032, s\u2032\u2032) such that Dv \u2282 Dv\u2032 and X occurs in Dv\u2032 . Consider the last edge on the path from (u, s) to (v, s\u2032) in F :\n(u, s), ..., (w, s\u2032\u2032), (v, s\u2032).\nObserve that (w, v) is not an edge in D since Dv is maximal, and (u, v) is not an edge in D since u was a leaf. Therefore the edge from (w, s\u2032\u2032) to (v, s\u2032) is Type 3. So D has an AND-node z with children vl, v and the last path edge is of the form (w, s\u2032 \u222a {e}), (v, s\u2032) where e = (z, vl) is the light edge of z. We claim that e 6\u2208 s, so that it is not present at the beginning of the path. If e \u2208 s then, since s \u2208 S(u), we have u, which queries X, in Dvl . Together with the assumption that some node in Dv queries X, we see that descendants of the two children vl, v of AND-node z query the same variable which contradicts that D is a DNNF. On the other hand, e \u2208 s\u2032\u2032. Now, the first node on the path where e was introduced must have an edge of the form (z, s1), (vl, s1 \u222a {e}). But now we have a path from (u, s) to (z, s1) with X \u2208 Dz \u2283 Dv, contradicting the maximality of v.\nThe next proposition says that on accepting paths P = {(u1, s1), (u2, s2), . . . (u`, s`)} in the constructed OR-FBDD F , the sequence of sets (s1, . . . , s`) behaves like the sequence of states of a stack. We will use this characterization of paths in the proof of Lemma B.4.\nProposition B.3. Suppose that F has been constructed from a DNNF D and that P = {(u1, s1), (u2, s2), . . . (u`, s`)} is a path in F consistent with a variable assignment \u03b8. If, for j < i, we have e1 \u2208 sj, e1 \u2208 si, and e2 \u2208 si \\ sj, then for no k > i do we have both e2 \u2208 sk and e1 6\u2208 sk.\nProof. Suppose the statement is false. Then there must exist a Type 3 edge ((w, s\u222a{e1, e2}), (vr, s\u222a{e2})) in the path P , where w \u2208 vl. However, we cannot have e2 \u2208 S(vr): e2 was an edge in Dvl because (w, s\u222a{e1, e2}) was reachable in F meaning that e2 \u2208 S(w).\nLemma B.4. F computes the same function as D. That is, \u03a6F [\u03b8] = \u03a6D[\u03b8] for all variable assignments \u03b8.\nProof. Suppose that \u03a6F [\u03b8] = 1. Then there exists a path P in F consistent with \u03b8 that ends in a 1-sink node.\nIf P = {(u1, s1), (u2, s2), . . . (u`, s`)} has no Type 1 edges then it also has no Type 3 edges. Therefore (u1, . . . , u`) is a path of neutral edges in D consistent with \u03b8 to a 1-sink with no AND-nodes along the way, thus \u03a6D[\u03b8] = 1.\nOtherwise, let S = {(ui, si), (ui+1, si+1), . . . , (ui+j , si+j)}\nbe a sub-path of P . We say that S corresponds to an accepting sub-DAG rooted at u if there is a sub-DAG of D rooted at the node u whose OR nodes have fanout 1, AND nodes have full fanout, leaves are all 1-sinks under \u03b8, and whose edges are ui, ui+1, . . . , ui+j .\nStarting from an empty path in F , we will work backwards from the end of P , adding two possible kinds of sub-path: with all Type 2 edges removed, the first contains exactly one Type 1 edge followed by one or more Type 3 edges. The second kind, with all Type 2 edges removed, contains only one Type 1 edge and no Type 3 edges. It is possible to construct P using these two types of subpath by Proposition B.3, which says that\ns1, s2 . . . s`\nis the sequence of states of a stack where, as we traverse the path P , its Type 1 edges push light edges while its Type 3 edges pop them. As P is an accepting path, we also have that s` = \u2205. We will show that both\nof these types of additions give a path corresponding to an accepting sub-DAG rooted at all AND nodes mentioned in the Type 1 edges of the sub-path.\nIn the first case, say we add the sub-path Sh to the tail path St to form S = ShSt. Suppose Sh contains the Type 1 edge ((uh, s), (vl, s\u222a{e})), and that St corresponds to an accepting sub-DAG respecting the first AND node in St, which we call ut. We wish to show that S corresponds to an accepting sub-DAG rooted at uh. Sh must contain a Type 3 edge popping e, hence there is a path in D from vl to a 1-sink that is consistent with \u03b8. Therefore Sh corresponds to an accepting sub-DAG rooted at vl (there are no AND-nodes along the way so the sub-DAG is the path). Further, since we can find a path of neutral edges in D from the sibling node of vl, vr, to ut (these come from the portion of P between the Type 3 edge popping e and the Type 1 edge ((uh, s), (vl, s \u222a {e}))), S corresponds to an accepting sub-DAG rooted at vr. Therefore, S corresponds to an accepting sub-DAG rooted at uh.\nIn the second case, we add a Type 1 edge ((uh, s), (vl, s \u222a {e})) to the tail path St, which corresponds to an accepting sub-DAG rooted at ut, the first AND node in St. Then ut must appear in Dvl . Otherwise the first Type 1 edge in St comes after we pop e, but then St began with the Type 3 edge popping e. This cannot happen because of our inductive assumption that we add sub-paths that begin with a Type 1 edge. So St gives a path of neutral edges in D from vl to ut (this is the sub-path in between the added Type 1 edge and the first Type 1 edge in St). Since St corresponds to an accepting sub-DAG rooted at ut, it also corresponds to an accepting sub-DAG rooted at vl. Similarly, St gives a neutral edge path in D from vr to the first AND node mentioned after popping e. Again, from our inductive hypothesis, St thus corresponds to an accepting sub-DAG rooted at vr. Therefore S corresponds to an accepting sub-DAG rooted at uh.\nNow suppose \u03a6D[\u03b8] = 1. Then D has an accepting sub-DAG D\u03b8 respecting \u03b8. We can find an accepting path in F from edges coming from D\u03b8. This path will follow a left-to-right traversal of D\u03b8, keeping track of light edges pushed and popped. The Type 1 and Type 2 edge portions of this traversal (moving left down the tree) directly translate to the appropriate edges in F . The necessary Type 3 edges for this traversal also exist in F since D\u03b8 only has 1-sinks. At the end of the traversal we will have popped all light edges and be at a 1-sink in D\u03b8 so we will be at a 1-sink for F ."}], "references": [{"title": "Lower bounds for exact model counting and applications in probabilistic databases", "author": ["Beame et al", "P. 2013] Beame", "J. Li", "S. Roy", "D. Suciu"], "venue": "In UAI,", "citeRegEx": "al. et al\\.,? \\Q2013\\E", "shortCiteRegEx": "al. et al\\.", "year": 2013}, {"title": "Counting of query expressions: Limitations of propositional methods", "author": ["Beame et al", "P. 2014] Beame", "J. Li", "S. Roy", "D. Suciu"], "venue": "In ICDT,", "citeRegEx": "al. et al\\.,? \\Q2014\\E", "shortCiteRegEx": "al. et al\\.", "year": 2014}, {"title": "On the size of binary decision diagrams representing boolean functions", "author": ["Breitbart et al", "Y. 1995] Breitbart", "H.B. Hunt III", "D.J. Rosenkrantz"], "venue": null, "citeRegEx": "al. et al\\.,? \\Q1995\\E", "shortCiteRegEx": "al. et al\\.", "year": 1995}, {"title": "The dichotomy of probabilistic inference for unions of conjunctive queries", "author": ["Dalvi", "Suciu", "N.N. 2012] Dalvi", "D. Suciu"], "venue": "J. ACM,", "citeRegEx": "Dalvi et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Dalvi et al\\.", "year": 2012}, {"title": "Knowledge compilation meets database theory: Compiling queries to decision diagrams", "author": ["Jha", "Suciu", "A.K. 2013] Jha", "D. Suciu"], "venue": "Theory Comput. Syst.,", "citeRegEx": "Jha et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Jha et al\\.", "year": 2013}, {"title": "Communication Complexity", "author": ["Kushilevitz", "Nisan", "E. 1997] Kushilevitz", "N. Nisan"], "venue": null, "citeRegEx": "Kushilevitz et al\\.,? \\Q1997\\E", "shortCiteRegEx": "Kushilevitz et al\\.", "year": 1997}, {"title": "New compilation languages based on structured decomposability", "author": ["Pipatsrisawat", "Darwiche", "K. 2008] Pipatsrisawat", "A. Darwiche"], "venue": "In AAAI,", "citeRegEx": "Pipatsrisawat et al\\.,? \\Q2008\\E", "shortCiteRegEx": "Pipatsrisawat et al\\.", "year": 2008}, {"title": "A lower bound on the size of Decomposable Negation Normal Form", "author": ["Pipatsrisawat", "Darwiche", "K. 2010] Pipatsrisawat", "A. Darwiche"], "venue": "In AAAI,", "citeRegEx": "Pipatsrisawat et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Pipatsrisawat et al\\.", "year": 2010}, {"title": "I", "author": ["Razgon"], "venue": "(2014). On obdds for cnfs of bounded treewidth. In Baral, C., Giacomo, G. D., and Eiter, T., editors, Principles of Knowledge Representation and Reasoning: Proceedings of the Fourteenth International Conference, KR 2014, Vienna, Austria, July 20-24,", "citeRegEx": "Razgon. 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "On the role of canonicity in knowledge compilation", "author": ["Van den Broeck", "Darwiche", "G. 2015] Van den Broeck", "A. Darwiche"], "venue": "In AAAI,", "citeRegEx": "Broeck et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Broeck et al\\.", "year": 2015}, {"title": "Basing decisions on sentences in decision diagrams", "author": ["Xue et al", "Y. 2012] Xue", "A. Choi", "A. Darwiche"], "venue": "In AAAI,", "citeRegEx": "al. et al\\.,? \\Q2012\\E", "shortCiteRegEx": "al. et al\\.", "year": 2012}], "referenceMentions": [{"referenceID": 8, "context": ", 2013], is tight, since [Razgon, 2015a] (see also [Razgon, 2014]) shows a quasipolynomial separation between DNNF and OR-FBDD size using parameterized complexity.", "startOffset": 51, "endOffset": 65}, {"referenceID": 8, "context": "Finally, we note that [Razgon, 2014] showed that SDDs can be powerful by finding examples where OBDDs using any order are quasipolynomially less concise than SDDs.", "startOffset": 22, "endOffset": 36}, {"referenceID": 8, "context": "This is a quasipolynomial difference and matches the quasipolynomial separation between OBDD and SDD size shown in [Razgon, 2014].", "startOffset": 115, "endOffset": 129}], "year": 2015, "abstractText": "We show new limits on the efficiency of using current techniques to make exact probabilistic inference for large classes of natural problems. In particular we show new lower bounds on knowledge compilation to SDD and DNNF forms. We give strong lower bounds on the complexity of SDD representations by relating SDD size to best-partition communication complexity. We use this relationship to prove exponential lower bounds on the SDD size for representing a large class of problems that occur naturally as queries over probabilistic databases. A consequence is that for representing unions of conjunctive queries, SDDs are not qualitatively more concise than OBDDs. We also derive simple examples for which SDDs must be exponentially less concise than FBDDs. Finally, we derive exponential lower bounds on the sizes of DNNF representations using a new quasipolynomial simulation of DNNFs by nondeterministic FBDDs.", "creator": "LaTeX with hyperref package"}}}