{"id": "1506.06256", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Jun-2015", "title": "Collective Mind, Part II: Towards Performance- and Cost-Aware Software Engineering as a Natural Science", "abstract": "nowadays, engineers have to develop software often without even knowing which hardware projects it will essentially eventually run, on in numerous mobile phones, tablets, desktops, laptops, data centers, supercomputers and cloud services.! unfortunately, optimizing compilers are not keeping pace with ever increasing computing complexity of computer systems anymore worldwide and may produce severely underperforming executable codes while wasting sufficiently expensive resources and significant energy.", "histories": [["v1", "Sat, 20 Jun 2015 15:34:39 GMT  (4858kb,D)", "http://arxiv.org/abs/1506.06256v1", "Presented at the 18th International Workshop on Compilers for Parallel Computing (CPC'15), London, UK"]], "COMMENTS": "Presented at the 18th International Workshop on Compilers for Parallel Computing (CPC'15), London, UK", "reviews": [], "SUBJECTS": "cs.SE cs.LG cs.PF", "authors": ["grigori fursin", "abdul memon", "christophe guillon", "anton lokhmotov"], "accepted": false, "id": "1506.06256"}, "pdf": {"name": "1506.06256.pdf", "metadata": {"source": "CRF", "title": "Collective Mind, Part II: Towards Performance- and Cost-Aware Software Engineering as a Natural Science", "authors": ["Grigori Fursin", "Abdul Memon", "Christophe Guillon", "Anton Lokhmotov"], "emails": [], "sections": [{"heading": null, "text": "We present the first to our knowledge practical, collaborative and publicly available solution to this problem. We help the software engineering community gradually implement and share light-weight wrappers around any software piece with more than one implementation or optimization choice available. These wrappers are connected with a public Collective Mind autotuning infrastructure and repository of knowledge to continuously monitor all important characteristics of these pieces (computational species) across numerous existing hardware configurations in realistic environments together with randomly selected optimizations. At the same time, Collective Mind Node) allows to easily crowdsource time-consuming autotuning across existing Android-based mobile device including commodity mobile phones and tables.\nSimilar to natural sciences, we can now continuously track all winning solutions (optimizations for a given hardware such as compiler flags, OpenCL/CUDA/OpenMP/MPI/skeleton parameters, number of threads and any other exposed by users) that minimize all costs of a computation (execution time, energy spent, code size, failures, memory and storage footprint, optimization time, faults, contentions, inaccuracy and so on) of a given species on a Pareto frontier along with any unexpected behavior at c-mind.org/repo . Furthermore, the community can continuously classify solutions, prune redundant ones, and correlate them with various features of software, its inputs (data sets) and used hardware either manually (similar to Wikipedia) or using available big data analytics and machine learning techniques.\nOur approach can also help computer engineering community create the first public, realistic, large, diverse, distributed, representative, and continuously evolving benchmark with related optimization knowledge while gradually covering all possible software and hardware to be able to predict best optimizations and improve compilers depending on usage scenarios and requirements. Such continuously growing collective knowledge accessible via simple web service can become an integral part of the practical software and hardware co-design of self-tuning computer systems as we demonstrate in several real usage scenarios validated in industry.2.\nKeywords: knowledge management, collaborative experimentation, collaborative knowledge discovery, reproducible experimentation, crowdsourcing experimentation, machine learning, data mining, big data analytics, active learning, compiler tuning, feature selection, natural science, systematic benchmarking, hardware validation, computational species, performance tracking, experiment buildbot, JSON API, agile methodology, unexpected behavior, multi-objective autotuning, Pareto frontier, statistical analysis, code and data sharing, reusable components, interactive articles\n1We are now developing a smaller, simpler and faster version of our collaborative infrastructure and repository (Collective Knowledge or CK). Preview is available at http://github.com/ctuning/ck and http://cknowledge.org/repo.\n2Corresponding author\u2019s email: Grigori.Fursin@cTuning.org\nar X\niv :1\n50 6.\n06 25\n6v 1\n[ cs\n.S E\n] 2\n0 Ju"}, {"heading": "1 Introduction and Related Work", "text": "There is an impressive and ever increasing number of diverse computer systems available nowadays on the market. They all vary in performance, size, power consumption, reliability, price and other characteristics depending on numerous available hardware features such as processor architecture, number of cores, availability of specialized hardware accelerators, working frequency, memory hierarchy and available storage. As a result, engineers often have to develop software that may end up running across different, heterogeneous and possibly virtualized hardware in multiple mobile devices, desktops, HPC servers, data centers and cloud services. Such a rising complexity of computer systems and limited development time usually force software engineers to rely almost exclusively on existing compilers, operating systems and run-time libraries in a hope to deliver the fastest, smallest, most power efficient, scalable and reliable executable code across all available hardware. Unfortunately, this complexity of ever changing hardware also made development of compilers very challenging. They nowadays include hundreds of optimizations and often fail to produce efficient code while wasting expensive resources and energy [72, 18, 20, 43, 40].\nNumerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58]. These techniques usually demonstrate that it is possible to improve various characteristics of existing software by automatically and empirically searching and predicting better combinations of optimizations. Such optimizations typically include compiler flags, optimization parameters and their orders, different algorithm implementations, run-time scheduling policies, working frequency among many other choices. The resulting 10% to 10x performance improvements of frequently executed programs can already reduce usage costs of large data centers and supercomputer operators by thousands of dollars per year. These improvements can also considerably improve overall performance, battery life and storage space in mobile devices.\nNevertheless, in spite of so many promising results and research advances in the past twenty years, we still witness the rising number of reports, complaints, public discussions and research articles showing that existing compilers are missing many optimization opportunities for popular software [10, 8, 14]. This is caused by a fundamental and yet unsolved problem - design and optimization spaces are already too large and continue growing. Therefore, exhaustive exploration of the whole space to find the best solution is simply impossible. Practically all recent long-term research visions acknowledge above problem [21, 30, 15, 43, 17]. They even advocate that some radically new approaches should be invented to be able to continue building faster, more power efficient and reliable software and hardware by 2020 while somehow decreasing all development, optimization and usage costs.\nIndeed, hardware and compiler designers can afford to explore only a tiny fraction of the whole optimization space together with a few ad-hoc benchmarks and data sets on a few architectures when tuning optimization and run-time adaptation heuristics or training predictive models. However, this simply can not anymore represent a vast amount of real-world software and hardware thus explaining why more and more optimization opportunities are so easily missed. Furthermore, static compilers often lack data set specific information and run-time adaptation mechanisms meaning that costly optimization process has to be restarted for practically every program input. Dynamic compilers and run-time autotuning techniques were not able to solve the problem either. Such just-intime frameworks always have a very limited time budget to be able to react to varying execution contexts, and hence can not explore many aggressive optimizations. Worse, almost all vast practical optimization knowledge and experience from the software engineering community during their own attempts to analyze and tune program behavior is often wasted instead of helping to improve compilers and run-time systems as conceptually shown in Figure 1a.\nRather than waiting until 2020 in a hope that compiler and hardware designers will somehow find a \u201dholy grail\u201d solution, we propose an alternative and collaborative solution based on our interdisciplinary background in physics and AI. With the help of the software engineering community, we started gradually identifying real and frequently used software pieces ranging from the whole application to jut a few lines of code when more than one optimization (or implementation) choice is available. Performance and associated usage costs of such software pieces usually heavily depend on different optimizations for a given input (data set), utilized hardware, environment state, and possible end-user requirements (such as algorithm precision versus energy usage and performance).\nWe then propose to use our recent Collective Mind framework and Hadoop-based repository of knowledge (cM for short) [40, 4] to extract and share such open source software pieces together with various possible inputs and meta data at c-mind.org/repo. This meta data is gradually extended by the community via popular, human readable and easily extensible JSON format [12] currently describing how to build and run shared pieces together with all dependencies on the specific hardware and software including compilers, operating systems and run-time libraries. All these shared software pieces are then continuously and randomly optimized and executed with different data sets using distributed cM buildbot for Linux and Windows-based devices [4] or cM node for Android devices [3]\nacross shared computational resources provided by volunteers. Such resources range from mobile phones, tablets, laptops and desktops to data centers, supercomputers and cloud services gradually covering all existing hardware configurations and environments. Furthermore, the community can use light weight cM wrappers around identified software pieces within a real and possibly proprietary applications to continuously monitor their behavior and interactions in the whole software project. Similar to nature and biological species, such approach treats all exposed and shared software pieces as computational species while continuously tracking and learning their behavior versus different optimizations across numerous hardware configurations, realistic software environments and runtime conditions. cM infrastructure then continuously records only the winning solutions (optimizations for a given data set and hardware) that minimize all or only monitored costs (execution time, power consumption, code size, failures, memory and storage footprint, and optimization time) of a given software piece on a Pareto frontier [53] in our public cM repository.\nSoftware engineers can now assemble their projects from the cM plugins with continuously optimized computational species. Such software projects can continuously and collaboratively achieve better performance while reducing all costs across all hardware thus making software engineering performance- and cost-aware. Furthermore, software developers are now able to practically help compiler and hardware designers improve their technology as conceptually shown in Figure 1b. Indeed, our approach helps create the first to our knowledge public, realistic, large, diverse, distributed, evolving and continuously optimized benchmark with related optimization knowledge while gradually covering all possible software and hardware.\nAt the same time, we can also apply an extensible, top down methodology originating from physics when learning behavior of complex systems. The compiler community first learns and optimizes coarse grain behavior of large shared software pieces including whole applications, library functions, kernels and most time consuming loops versus global compiler optimization flags or other coarse-grain optimizations. After enough knowledge is collected, the community can gradually move to finer grain levels including just a few source lines or binary instructions versus all internal and individual compiler optimization decisions via our Interactive Compilation Interface. This plugin-based interface is already available in mainline GCC [39], and we plan to add it to LLVM in the future [40].\nMore importantly, our approach helps considerably improve existing methodology on optimization and run-time adaptation prediction using machine learning. Current methodology (used in most of the papers including ours and referenced at the beginning of this section) usually focuses on showing that it is possible to predict one or several\noptimizations to improve execution time, power consumption or some other characteristics using some off-the-shelf machine learning techniques such as SVM, (deep) neural networks or KNN [23, 45, 55] combined with a few ad-hoc program or architecture features. In contrast, our growing, large and diverse benchmark allows the community for the first time to apply methodology from sciences such as biology, medicine and AI based on big data predictive analytics [44]. For this purpose, cM infrastructure continuously classifies all winning species in terms of distinct optimizations and exposes them to the community in a unified and reproducible way through the public repository. This, in turn, allows our colleagues with interdisciplinary background to help the software engineering community find best predictive models for these optimization classes together with relevant features from software species, hardware, data set and environment state either manually or automatically. Such features (including extraction tool) and predictive models are continuously added to the species using cM wrappers and their meta-data thus practically enabling self-tuning software automatically adaptable to any hardware and environment.\nImportantly, cM continues tracking unexpected behavior (abnormal variation of characteristics of species such as execution time, or mispredictions from current classification) in a reproducible way in order to allow the community improve predictive models and find missing features that can explain such behavior. Also, in contrast with using more and more complex and computationally intensive machine learning techniques to predict optimizations such as deep neural networks [23, 45, 55], we decided to provide a new manual option useful for compiler and hardware designers. This option allows the community to combine existing predictive techniques as a cheap way to quickly analyze large amount of data, with manually crafted human-readable, simple, compact and fast rules-based models (decision trees) that can explain and predict optimizations for a given computational species. Thus, we are collaboratively building a giant optimization advice web service that links together all shared software species, optimizations and hardware configurations while resembling Wikipedia, IBM Watson advice engine [33], Google knowledge graph [9] and a brain.\nWe understand, that the success of our approach will depend on the active involvement from the community. Therefore, we tried to make our approach as simple and transparent to use as possible. For example, our light-weight cM version for Android mobile systems [3] is a \u201done-button approach\u201d allowing anyone to share their computational resources and tune shared computational species. At the same time, extraction of software pieces from large applications is still semi-manual and may incur some costs. Therefore we are gradually working on automating this process using plugin-based capabilities in GCC and LLVM. Furthermore, together with participating companies and volunteers, we already extracted, described and partially shared 285 computational species together with around 500 input samples 1 from major benchmarks and software projects. We then validated our approach in STMicroelectronics during 3 months to help our colleagues tune their production GCC compiler and improve real customer software. During that time, we continuously optimized execution time, code size, compilation time and power consumption of all shared computational species using at least 5000 random combinations of compiler optimization flags on spare private cloud servers and mobile phones. We also managed to derive 79 distinct optimization optimization classes covering all shared species (small real applications or hotspot kernels extracted from large applications with their run-time data set either manually as we did in [37], or using Codelet Finder from CAPS Entreprise as we did om the MILEPOST project [39], or using semi-manual extraction of OpenCL/CUDA kernels combined with OpenME plugin interface to extract run-time state [40]) that we correlated with program semantic and dynamic features using SVM and other predictive analytics techniques. With the help of domain specialists (compiler engineers), we then analyzed predictive models for end-user software, found meaningless correlations, manually isolated problems 2, prepared and shared counter-example code sample, found missing program and input features to fix wrong classifications, and developed adaptive, self-tuning and statically compiled code. Finally, we managed to substitute ad-hoc benchmark used at the architecture verification department of our industrial partners with the minimal and realistic one based on derived optimization classes that helped to dramatically reduce development and testing time.\nThese positive outcomes demonstrate how our approach can help eventually involve the software engineering community into development and improvement of compilers and hardware. We also show how continuously growing collective knowledge repository accessible via unified web service can become an integral part of the practical software and hardware co-design of self-tuning computer systems while decreasing all development costs and time-to-market for new products. More importantly, the side effect of our approach to share code and data in a reproducible way\n0We can not share extracted pieces from proprietary software but we still use them internally for research purposes. 1We currently have more than 15000 input samples collected in our past projects for our shared computational species [36, 11, 27]. However since they require more than 17GB of storage, at the moment we decided to share only representative ones, i.e. which require distinct compiler optimization.\n2In spite of many papers presents some simple automatic optimization predictions, our practical and industrial experience with large data sets shows that it is currently not possible to fully automate this process. Therefore, manual analysis is still often required similar to other natural sciences as will be shown later in this paper.\nhelp support recent international initiatives on reproducible research and sustainable software engineering [2]. Our paper is organized as follows. This section has introduced the problem, related work and our novel community-driven approach for performance- and cost-aware software engineering. It is followed by Section 2 presenting our personal and real-life motivating software engineering example for neural networks with some of the encountered optimization issues during past 15 years. Next section 3 briefly introduces our recent open source Collective Mind infrastructure and repository to enable sharing of computational species and collaborative tracking and tuning of their performance together with all associated costs across voluntarily provided computer systems. Section 4 demonstrates how we continuously systematize \u201dbig performance data\u201d collected by cM, classify species, and predict optimizations while creating a realistic and representative benchmark. It is followed by Section 5 which demonstrates how to understand machine learning and improve optimization predictions. Section 6 demonstrates how to find missing features to explain unexpected behavior of computational species and improve optimization predictions. It also shows how to build adaptive and self-tuning applications assembled from available computational species as plugins. Finally, we conclude paper and describe future research and development directions in Section 7."}, {"heading": "2 Real-life motivating example", "text": "One of the authors original research started more than twenty years ago was to develop and analyze various artificial neural networks as a part of a possible non-traditional and brain-inspired computer. Such networks can mimic brain functions and are often used for machine learning and data mining [23]. For example, Figure 2 shows one of the oldest and well-known one-layer, fully interconnected, recurrent (with feedback connections) Hopfield neural network [46]. It is a popular choice for function modeling, pattern recognition and image filtering tasks including noise reduction. Implemented as a software, this neural network has a fairly simple and regular code where each neuron receives a weighted sum of all inputs of an image as well as outputs of all other neurons. This sum is then processed using some neuron activation function including sigmoid or linear ones to calculate the output value. The small and simple C kernel presented in above Figure 2 is one of many possible implementations of a threshold filter we used as a part of a linear activation function, i.e. switching neuron output from 0 to 1 when its input meets a given threshold.\nVery simplistically, the quality of a neural network is usually determined by its processing speed as well as capacity (maximum amount of patterns or information that can be stored in such networks) and recognition accuracy (correct predictions versus failures). It heavily depends on the total number of neurons, connections and layers [48], and is primarily limited by the speed and resources of the available hardware including specialized accelerators.\nHence, neural network software/hardware co-design process always involves careful balancing of performance versus all associated costs including storage size, memory footprint, energy consumption, development time and hardware price depending on usage scenarios and required time to market. Indeed, our research on improving neural networks requires many iterative runs of a slightly evolving modeling software with varying parameters to maximize prediction accuracy. In this case, our main concern is about minimizing compilation and execution time of each execution across available hardware. However, when the best found network is found and deployed in a large data center or cloud service (for example, for big data analysis), end users would like to minimize all additional costs including energy and storage consumption across all provided computer systems. Finally, when deploying neural networks in small, autonomic and possibly mass-produced devices such as surveillance cameras and mobile phones or future robots and Internet of Things objects, more strict requirements are placed on software and hardware size, memory footprint, real time processing, and the cost of the whole system.\nTwenty years ago, our software engineering of neural networks was relatively straightforward. We did not have a choice but to simply select the latest hardware with the accompanying and highly tuned compiler to achieve nearly peak performance for our software including for the code shown in Figure 2. Therefore, in order to innovate and process more neurons and their configurations, we usually had to wait for more than a year until arrival of a new hardware. This hardware would likely double performance of our software and provide more memory and permanent storage but often at a cost of higher power consumption and thus dramatically rising electricity bill.\nIn contrast, we now have an impressive choice of hardware of all flavors which our software can be executed on. Each year, there are numerous variations of processors appearing on the market with different features (properties) including frequency, number of cores, cache size, ISA extensions, specialized hardware accelerators (such as GPU and even revived semiconductor neural networks), power consumption and price. Furthermore, we can now have an easy access to large-scale parallel resources from home via gaining popularity virtualized cloud services from Amazon, Google, Microsoft and others. Therefore, the number of experiments we can now run is mainly limited by the price we can afford to pay for computing services. At the same time, we also enjoy continuous community-driven improvements of operating systems together with numerous free or proprietary libraries and software development tools including popular optimizing compilers such as GCC and LLVM. One may expect that with so many advances in the computer technology, practically any recent compiler would generate the fastest and most energy efficient code for such an old, simple, small and frequently used software piece shown in Figure 2 across existing hardware. Nevertheless, since we pay for our experiments, we eventually decided to validate their performance/cost efficiency.\nFor the sake of accountability and reproducibility, we started gradually collecting at c-mind.org/nnet-tuningmotivation various information about several computer systems we used including their price, cost, available operating systems, compilers and optimizations. Figure 3a shows a tiny subset of this multidimensional space of design and optimization choices. At the same time, whenever running real experiments, we also started recording their execution time 3 and all associated costs including compilation time, code size, energy usage, software/hardware price and utility bill. Furthermore, we decided to perform a simple and well-known optimization compiler flag autotuning [1, 39] with at least 100 iterations to see whether there is still room for improvement over the fastest default compiler optimization level (-O3). Figure 3b shows one of many possible 2D projections of the multidimensional space of characteristics (which we consider as costs of running our experiments or tasks). We then gradually track the winning solutions that maximize performance and at the same time minimize all costs using our experience in physics and electronics, namely by applying Pareto frontier filter [53].\nWe quickly realized that in contrast to the traditional wisdom, the latest technology is not necessarily the fastest or most energy efficient and further optimization is always required. For example, when moving from GCC 4.1.1 (released in 2006) to GCC 4.9.1 (released in 2014), we observed a modest 4% improvement 4 in single core execution time of our neural network and 2% degradation in a code size on Intel E6320 based system (released in 2008). However, 8 years old GCC 4.1.1 can achieve 27% improvement in execution time after autotuning (which comes at cost of 100 recompilations and executions as well as increasing binary size by 34%)! Interestingly, 8 years old PathScale 2.3.1 produces faster code than the latest version of GCC 4.9.1 and LLVM 3.4.2! Furthermore, when using internal parallelization, LLVM 3.4.2 beats GCC 4.9.1 by about 23% but has a sub-linear scaling versus number of threads. In contrast, 2 years old GCC 4.6.3 achieves the best result and linear scaling versus number of threads when using both parallelization and autotuning!\nWhen running the same code on cheap, commodity mobile phones with ARM architecture, the execution time\n3In this paper, for the sake of simplicity and without loosing generality, when speaking about performance tuning, we mean reducing execution time. However, on modern out-of-order processors with complex memory hierarchy, the dependency between performance (speed of execution) and total execution time may be non-linear. Thus, depending on user requirements, these characteristics have to be tuned separately.\n4Similar to physics, we execute optimized code many times, check distribution of characteristics for normality [32], and report expected value if variation is less than 3%\nP1) Intel Core i5-2540M, 2.60GHz, 2 cores D1) grayscale image 1, size=1536x1536 P2) Qualcomm MSM7625A FFA, ARM Cortex A5, 1 GHz, 1 core D2) grayscale image 2, size=1536x1536 P3) Allwinner A20 (sun7i), ARM Cortex A7, 1.6GHz, Mali400 GPU, 2 core P4) NVidia Quadro NVS 135M, 400MHz, 16 cores O1) Windows 7 Pro SP1, cost~170 euros\nT1) 7.2E10 O2) O1 with MinGW32\nW1) 32 bit processor mode T2) 9.6E9 O3) OpenSuse 12.1, Kernel 3.1.10 W2) 64 bit processor mode T3) 2.4E9 O4) Android 4.1.2, Kernel 3.4.0\nT4) 1.0E9 O5) Android 4.2.2, Kernel 3.3.0\nX1) GCC 4.1.1, opt.flags~190, release date=2006 X2) GCC 4.4.1, opt.flags~270, release date=2009 S1) Dell Laptop Latitude E6320, Mem=8Gb, 52W, 1200 euro X3) GCC 4.4.4, opt.flags~270, release date=2010 S2) Samsung Mobile GT-S6312, Mem=0.8Gb, 5W, 200 euros X4) GCC 4.6.3, opt.flags~320, release date=2012 S3) Polaroid Tablet MID0927, Mem=1Gb, 13W, 100 euros X5) GCC 4.7.2, opt.flags~340, release date=2012 S4) Semiconductor neural network,1.5years development X6) GCC 4.8.3, opt.flags~350, release date=2014 X7) GCC 4.9.1, opt.flags~357, release date=2014 Y1) Performance (usually -O3) X8) LLVM 3.1, release date=2012 Y2) Size (usually -Os) X9) LLVM 3.4.2, release date=2014 Y3) -O3 -fmodulo-sched -funroll-all-loops X10) Open64 5.0, release date=2011 Y4) -O3 -funroll-all-loops X11) PathScale 2.3.1, release date=2006 Y5) -O3 -fprefecth-loop-arrays X12) NVidia CUDA Toolkit 5.0, release date=2012 Y6) -O3 -fno-if-conversion X13) Intel Composer XE 2011, cost = ~800euro Y7) Auto-tuning with more than 6 flags (-fif-conversion) X14) Microsoft Visual Studio 2013 Y8) Auto-tuning with more than 6 flags (-fno-if-conversion) (a)\n0\n5\n10\n15\n20\n25\n30\n35\n5000 10000 15000 20000 25000 30000\nP ro\ng ra\nm e\nx e\nc u\nti o\nn t\nim e (\ns e c .)\nProgram binary size (bytes)\n1 2 3\n4 5\n9\n6 7 8\nA B\nC\nD E\nI\nF\nII\n1) P1 O3 W2 X1 Y1 T2 D1 A) P3 O5 W1 X1 Y1 T4 D1 2) P1 O3 W2 X7 Y1 T2 D1 B) P3 O5 W1 X4 Y1 T4 D1 3) P1 O3 W2 X1 Y7 T2 D1 C) P3 O5 W1 X4 Y7 T4 D1 4) P1 O3 W2 X7 Y5 T2 D1 D) P3 O5 W1 X6 Y1 T4 D1 5) P1 O3 W2 X11 Y1 T2 D1 E) P3 O5 W1 X6 Y7 T4 D1 6) P1 O3 W2 X9 Y1 T2 D1 F) P3 O5 W1 X9 Y1 T4 D1 7) P1 O3 W2 X3 Y7 T2 D1 8) P1 O3 W2 X4 Y8 T2 D2 I) P2 O4 W1 X1 Y1 T4 D1 9) P1 O1 W1 X14 Y1 T3 D1 II) P2 O4 W1 X6 Y1 T4 D1 10) P1 O1 W1 X13 Y1 T2 D1 11) P1 O3 W2 X7 Y8 T2 D2 $) P4 O3 W1 X12 Y1 T1 D1\n10 Available resource: P1, one core\nAvailable resource: P1, two cores\n$ 11\n(b)\nFigure 3: (a) A small subset of various hardware, software, development tools and optimizations used in our research on neural networks in the past 20 years (P - processors, W - processor mode, X - compiler, O - operating system, S - system, T - total number of processed pixels or neurons, D - software data set, Y - compiler optimization used) (b) 2D projection of the multidimensional space of characteristics together with winning solutions on the Pareto frontier (all data and interactive graphs are available at c-mind.org/nnet-tuning-motivation).\nincreased dramatically by around 5 times! However, the power consumption dropped by about 10 times! When trying to use specialized hardware (GPUs or our semiconductor neural networks), we could increase execution time by about tens to hundreds of times, but at a considerable development cost and time to market. Furthermore, with time, we discovered that the same best found optimization for one class of images can considerably degrade performance on another class of images (as we explain in Section 6). We also encountered problems with cache contentions on multi-core systems, sub-linear scaling on many core systems, unexpected frequency scaling, nondeterministic IO for large images, and many other problems that had to be addressed by new optimizations. These issues can not be easily solved by static compilers due to a fundamental problem of a lack of run-time information at compile time. Therefore, we even tried to move to dynamic and possibly adaptive languages including Java and Python but were not yet able to achieve similar performance while spending even more energy and storage during just-in-time compilation.\nSadly and similar to many other scientists and software engineers, we now have to waste considerable amount of our time on a tedious and ad-hoc navigation through the current technological chaos to find some good hardware, software and optimization solutions that can speed up our programs and reduce costs instead of innovating as conceptually summarized in Figure 4. Worse, software engineers are often not even aware of all available design\nand optimization choices they have to improve performance of their software and reduce development and usage costs. Furthermore, costs that has to be minimized depend on usage scenarios: in mobile systems running out of battery, one may want to fix a power budget and then balance execution time and algorithm accuracy; in embedded devices, code size and consumed energy may be more important that execution time; JIT may require careful balancing of compilation and optimization times versus potential performance gains, while users of data centers and supercomputers may care primarily about both execution time and the price of computation. Therefore, we strongly believe that current performance- and cost-blind software engineering has be changed to improve productivity and boost innovation in science and technology."}, {"heading": "3 Public and Open Source Collective Mind Infrastructure and Repos-", "text": "itory\nEventually, we started searching for a possible solution that could liberate software developers from the tedious and not necessarily relevant job of continuous optimization and accounting while gradually making existing software performance- and cost-aware. At first, we tried to create a simple database of optimizations and connect it to some existing benchmarking and autotuning tools to keep track of all optimizations [35, 39]. However, when trying to implement it within production environments of our industrial partners, we faced several severe problems including difficulty to expose all design and optimization choices from continuously evolving software, and difficulty to reproduce performance numbers collected from different machines. This eventually pushed us to develop a fullfledged repository of knowledge with unified web services (Collective Mind or cM for short) similar to ones that helped successfully systematize research and experimentation in biology, genomics and other natural sciences. Such repository should be able to keep the whole autotuning setups with all dependencies including optimized software, data sets and autotuning tools. This, in turn, should allow us to distribute the whole autotuning setups among many users to crowdsource software optimization (or any other experimentation) in a reproducible way while considerably reducing usage costs.\nBriefly 5, cM helps decompose software into standalone pieces interconnected through cM wrappers. Such\n5Though we provide minimal information about Collective Mind framework in this paper, it should be enough to understand proposed\nlight-weight wrappers currently support major languages including C, C++, Fortran, Python, PHP and Java, and allow the community to gradually expose various design and optimization choices c, features f, dependencies on other software and hardware, monitored characteristics (costs) b and environment state s in a unified way through extensible JSON format [12]. This allowed us to formalize almost all existing autotuning techniques as finding a function of a behavior of a given software piece B running on a given computer system with a given data set, selected hardware design and software optimization choices c, and a system state s ([40]):\nb = B(c, s)\nFurthermore, software pieces can be extracted and then shared together with their wrappers and data sets samples in the Hadoop-enabled [7] cM repository. For example, with the help of our colleagues and supporters, we already gradually and semi-automatically extracted and shared 285 software pieces together with several thousand data set pairs from several real software projects as well as 8 popular benchmark suits including NAS, MiBench, SPEC2000, SPEC2006, Powerstone, UTDSP and SNU-RT. This can liberate software engineers from developing their own adhoc and complex tuning setups in favor of implementing common autotuning pipelines consisting of shared software pieces, data sets, tools and optimization space exploration modules. Such pipelines can then be easily shared and distributed across a large number of diverse computer systems either using open source cM buildbot or a small cM node that can deploy experiments on Android-based devices [3]. cM will then continuously \u201dcrawl\u201d for better optimizations for all shared software pieces, data sets and compilers, while recording experiments in a reproducible way in the public cM repository c-mind.org/repo.\nAs requested by our industrial partners, we first used cM to implement compiler optimization flag autotuning pipeline. Though this pipeline continues growing and now supports other optimizations including polyhedral sourceto-source transformations, MPI/OpenMP tuning and fine-grain compiler transformations as can be seen at cmind.org/ctuning-pipeline, compiler flag optimization problem remains critical for new hardware and unsolved for several decades due to growing optimization spaces. Indeed, latest GCC, LLVM and Intel compilers feature hundreds of optimizations which have to be carefully orchestrated for all existing software and hardware. At the same time, it should be simple enough to demonstrate the concepts of our approach which follows top-down optimization methodology. Therefore, we start from coarse-grain optimizations and gradually move to finer-grain levels motivated by our experience in physics when gradually moving from three Newton laws to quantum mechanics.\nconcepts. However, in case of further interest, more details can be found in [40, 4]\nOur autotuning pipeline randomly selects a software piece from all shared ones, builds it with randomly generated combinations of compiler optimization flags of format -O3 -f(no-)optimization flag \u2013parameter param = random number from range, and runs it on a randomly selected spare computer system with a randomly selected shared data set. Measured characteristics (costs) are then processed using Pareto frontier filter to record or update the winning solution for a given software piece (optimization versus hardware, compiler and data set) in the cM repository. For example, table 1 presents some of the winning combinations of flags for GCC 4.6.3 used in the production environment by one of our industrial partners. Note that meta flag -fno-ALL means that all other optimization flags have been gradually switched off to leave only the influential ones and thus help compiler designers understand missed optimization opportunities. This allows developers to continuously monitor and reuse best solutions for shared software pieces through unified cM web services depending on their further intended usage. For example, the fastest and energy efficient solution is often used for HPC systems, the smallest - for computer systems with very limited resources such as credit card chips or the future \u201dInternet of Things\u201d devices, or balanced for both speed and size when used in phones, tablets and other mobile devices."}, {"heading": "4 Classifying computational species", "text": "Though cM helped simplify, unify, automate, speed up and preserve a tedious process of hardware benchmarking and software autotuning, it also encountered a new serious problem. Even with a modest number of 400 volunteers participated in our project since the beginning of 2014 to crowdsource compiler autotuning using our Androidbased cM node [3], we immediately faced a big data problem - too much collected statistics that our repository and infrastructure can process. However, we have already faced a similar problem in natural sciences and AI for many years and managed to effectively tackle it using predictive analytics (statistical analysis, data mining and machine learning) [23, 45, 55, 44]. For example, we used to classify numerous physical objects or biological species in terms of behavior and features while leaving only representative classes and thus considerably reducing analysis time and required storage.\nWe propose a similar approach for software engineering. Collective Mind Framework, Repository and mathematical formalization allows us to treat all shared software pieces as computational species running across numerous hardware configurations. Naturally, these species will behave differently depending on their data sets, hardware used and environment state (which includes the state of the species, Operating System and hardware as well as interaction with other species). Since our main goal is to help software engineers find better optimizations that improve overall behavior of their software pieces under all usage conditions (reduce execution time and all other costs), we implemented continuous clustering of all available species that share the same top performing optimizations such as ones shown in Table 1. Our expectation is that software pieces belonging to the same cluster, i.e. share similar optimizations, will also share some features describing their semantics, data set and run-time behavior. This, in turn, would allow us to automatically classify previously unseen computational species from the community and relate them to existing optimization cluster based on their features thus effecitvely predicting optimizations and dramatically reducing tuning time and storage size.\nHowever, the major challenge with such approaches is to assemble a large and diverse enough training set, and to find meaningful features that can correctly separate optimization clusters. Collective Mind Repository helps solve the first problem by collecting a large number of real and diverse software pieces from the community. At the same time, from our practical experience in using machine learning for program optimization and hardware designs [39, 31], we believe that it is not currently possible to fully automate this process due to a practically infinite feature space. Instead, we propose to use a collaborative approach similar to ones currently used in many natural sciences. We expose optimization clusters together with software species and data sets through our public cM repository in a reproducible way to let the interdisciplinary community find and share meaningful features and correlations similar to ones shown in Figure 4. This approach contrasts with some existing works on machine learning for compilation and architecture. They were referenced in the related work section and mainly focus on showing that machine learning can be used to predict optimizations while using just a few benchmarks, data sets and ad-hoc features.\nOur approach helped our industrial partners tune and cluster all shared software species across several production compilers and architectures. Next, we present a small subset of our experimental results for GCC 4.6.3 and Intel E5520. All other results are continuously updated at our public cM repository at c-mind.org/repo. By now, cM has found a pool of 79 distinct combinations of optimization flags (clusters) for this compiler covering all shared software pieces and data set samples. Figure 6 shows maximum speedups achieved for each top performing and representative optimization across all benchmarks together with the number of benchmarks which achieve highest speedup using this optimization (or at least more than 1.1 ) and the number of benchmarks with speedups less than 0.96 (slowdown) for the same optimization. For example, distinct combination of optimizations -O3 -fifconversion -fno-ALL achieved maximum speedup on 7 benchmarks (including 1.17 speedup on at least one of these benchmarks) and slowdowns for 11 benchmarks. In case some optimization cluster does not have slowdowns across\nall shared software pieces, it can help automatically substitute a best and often manually crafted default compiler optimization level such as -O3, thus practically helping to improve existing compilers."}, {"heading": "5 Understanding and improving machine learning to predict optimiza-", "text": "tions\nAs the first approximation, we decided to reuse existing machine learning techniques and build a predictive model (classifier) that can associate any previously unseen species with a unique optimization cluster based on some software features. We also decided to reuse and validate already available semantic and dynamic features from our previous work on machine learning based compiler [39]. For this purpose, we generated and shared in the cM repository a feature vector f for each software species using 56 semantic program features from the MILEPOST GCC [39] (extracted during compilation at -O1 optimization level after pre pass)). In addition, we collected 29 following dynamic features (hardware counters collected by default using standard performance monitoring tool perf when running unoptimized software piece on a shared computing resource with Linux-based OS): \u201dcycles\u201d, \u201dinstructions\u201d, \u201dcache-references\u201d, \u201dcache-misses\u201d, \u201dL1-dcache-loads\u201d, \u201dL1-dcache-load-misses\u201d, \u201dL1-dcacheprefetches\u201d, \u201dL1-dcache-prefetch-misses\u201d, \u201dLLC-prefetches\u201d, \u201dLLC-prefetch-misses\u201d, \u201ddTLB-stores\u201d, \u201ddTLB-store-misses\u201d, \u201dbranches\u201d, \u201dbranch-misses\u201d, \u201dbus-cycles\u201d, \u201dL1-dcache-stores\u201d, \u201dL1-dcache-store-misses\u201d, \u201dL1-icache-loads\u201d, \u201dL1-icacheload-misses\u201d, \u201dLLC-loads\u201d, \u201dLLC-load-misses\u201d, \u201dLLC-stores\u201d, \u201dLLC-store-misses\u201d, \u201ddTLB-loads\u201d, \u201ddTLB-load-misses\u201d, \u201diTLB-loads\u201d, \u201diTLB-load-misses\u201d, \u201dbranch-loads\u201d, \u201dbranch-load-misses\u201d . We then passed 79 optimization clusters, 86 features and either all 285 shared species or a small subset of 12 ones used in some of our past works through a standard SVM classifier from R package [23, 16] with full cross-validation as described in [39, 26].\nResults shown in Table 2 demonstrate that we can obtain a relatively high prediction accuracy when using just a few software species thus supporting findings from similar works on machine learning for autotuning, i.e. that it is possible to predict optimizations using machine learning. However, with a new opportunity provided by cM to use a much larger training set of shared software species from the community, prediction accuracy dramatically dropped exhibiting close to random behavior (50%), i.e. with no meaningful predictions. At the same time, Collective Mind approach can now help understand such a variation in prediction accuracy by exposing all optimization and modeling results in a reproducible way to experts. Our colleagues and compiler specialists from STMicroelectronics analyzed one of the simplest optimization clusters -O3 -fif-conversion -fno-ALL which has a relatively high prediction rate when using a few or all shared programs, i.e. only 3 mispredictions out of a pool of 17 optimization clusters (7 positive speedups and 10 negative ones) as shown in Figure 6. We then incrementally removed all unrelated features that did not influence predictions leaving only one semantic feature from MILEPOST GCC (ft29) that counts the number of basic blocks where the number of phi-nodes is greater than 3. Visualization of the predictive model at Figure 7 shows that SVM derived a decision ft29 \u3009 0 to effectively separate two classes with only 3 mispredictions out of 17.\nAt this stage, many existing academic works will conclude that relevant feature is found and it is possible to use machine learning to predict optimization. However, compiler or hardware designers also need to understand whether this feature makes sense in order to improve their technology. Since our colleagues did not manage to explain this feature, they decided to try to find a counter example to invalidate this correlation. Therefore, they selected a simple blocksort function from the shared bzip2 species that has 0 phi-nodes and tried to manually add phi-nodes by converting source code as following (added lines are highlighted):\nvolatile int sum, value = 3; int sumA = 0; int sumB = 0; int sumC = 0; for (j = ftab[ss \u3008\u3008 8] & ( ((1 \u3008\u3008 21))) ; j \u3008 copyStart[ss] ; j++) { k = ptr[j] - 1; sumA += value; sumB += value; sumC += value;\nThis manual transformation added 3 PHI nodes to the code changing MILEPOST feature ft29 from 0 to 1, but without any effect on the speedup. We then performed similar transformation in a few other species that did not influence the original speedup while changing ft29 to non-zero value and thus invalidating original decision, i.e. showing that ft29 is not relevant to a given optimization cluster.\nWhen exposing this problem to machine learning specialists, we realized that a high prediction accuracy can be explained by finding meaningless correlations in a very large and sparse feature space for just a few species that are invalidated on a very large and diverse training set. Though relatively naive, this example highlights the importance of creating a common repository of software species together with their features. Furthermore, this example shows that negative results (mispredictions or unexpected behavior), usually overlooked by our community, are very important in practice and should also be reported, shared and published to improve machine learning techniques. For example, our colleagues from STMicroelectronics shared their counter examples as new software species thus contributing to a public and realistic benchmark.\nFinally, cM allows to share various machine learning models thus helping researchers switch from showing that it is possible to predict some optimizations based on some features to sharing best performing predictive models and classifiers, and focusing on finding why they are mispredicting together with missing features. It is even possible to perform continuous competitions between shared models to balance prediction accuracy, size and speed or reduce complexity depending on usage scenarios. For example, deep neural networks can be very good in terms of prediction accuracy, but are also very large, costly, and, unlike simpler decision trees, do not necessarily help software or hardware designers understand and solve their performance problems (i.e. black box approach)."}, {"heading": "6 Learning data set features to enable adaptive software", "text": "Though we demonstrated how our approach and methodology can help automate classification of shared software species to improve optimization predictions, it still did not solve another fundamental problem of static compilation - lack of run-time information. On the other hand, since cM continuously records unexpected behavior, it helped to automatically detect that one of the real customer\u2019s software species (image B&W threshold filter from a surveillance camera application similar to one shown in Figure 2) requires two distinct optimizations with around 20% improvement in execution time on Intel Core i5-2540M across all shared images (data set samples) as shown in Figure 8.\nIn order to understand such behavior, we can now reuse the same clustering methodology to classify available\ndata sets and detect their features that can explain such behavior and separate optimization classes. Compiler designers again helped us analyze this software species and gradually identified a suspicious \u201dsub-species\u201d causing unusual behavior: (temp1 \u3009 T) ? 255 : 0. One optimization class included \u201dif conversion\u201d transformation which added several predicated statements that may degrade performance if additional branches are rarely taken due to a few additional useless cycles to check branch condition. At this stage, compiler designers concluded that it is a well-known run-time dependency which is difficult or even impossible to solve in static compilers. Nevertheless, one of the volunteers noticed that some images shown in Figure 8 where taken during the day and some during the night. This helped us find new, simple and relevant feature related to both data set and the environment state \u201dtime of the day\u201d that effectively separated two optimization classes.\nThis real example demonstrates how our approach can help collaboratively find missing and nontrivial features that may not be even exist and have to be exposed to improve optimization prediction. Furthermore, our approach helped substitute the threshold filter in the customer\u2019s real software by a shared cM plugin consisting of two differently optimized clones of this filter and a compact decision tree. This decision tree selects an appropriate clone at run-time based on features of a used data set, hardware and environment state. Therefore, our Collective Mind approach can also help make statically compiled software easily adaptable to different contexts as conceptually shown in Figure 9. Moreover, such software will be continuously optimized with the help of the community while maximizing its performance, minimizing development costs, improving productivity of software engineers and reducing time to market. Interestingly, cM approach can also help solve \u201dbig data problem\u201d that we experienced in our first public cTuning framework [35, 39]. Rather than collecting and preserving all possible information from participating users, we can validate incoming data against existing models and save only unexpected behavior.\nWe believe that presented approach can eventually enable performance- and cost-aware software engineering. We envision that instead of struggling integrating various ad-hoc optimization heuristics to their software projects similar to one shown in Figure 4, engineers will simply need to expose various features from data sets, software, hardware and environment state for their software pieces. These features will be then correlated with the winning optimizations either automatically or with the help of the community to gradually minimize execution time, power consumption, code size, compilation time, faults, and other costs."}, {"heading": "7 Conclusions and Future Work", "text": "The computer engineering community has been desperately trying to find some practical ways to automatically improve software performance while reducing power consumption and other usage costs across numerous and rapidly evolving computer systems for several decades [21, 30, 15, 43, 17]. In this paper, we presented a novel and practical approach inspired by natural sciences and Wikipedia that may help collaboratively solve this problem while improving productivity of software developers. The biggest challenge in this approach is to connect together, systematize and make practical various techniques and tools from different interdisciplinary domains often overlooked by our community into a coherent, extensible and top-down optimization and classification methodology.\nThe backbone of our approach is a public repository of optimization knowledge at c-mind.org/repo. It allows the software engineering community to gradually share their most frequently used software pieces (computational species) together with various possible inputs and features. All shared species are then continuously and randomly optimized and executed with randomly selected inputs either as standalone pieces or within real software across numerous mobile phones, laptops and data centers provided by volunteers using our recent Collective Mind framework (cM). In contrast with a very few existing public repositories, notably SPEC and Phoronix benchmarking platforms [69, 13], cM also continuously classifies best found optimizations while exposing unexpected behavior in a reproducible way. This, in turn, allows the interdisciplinary community to collaboratively correlate found classes with gradually exposed features from the software, hardware, data sets and environment state either manually or using popular big data predictive analytics [23, 44]. Resulting predictive models are then integrated into cM plugins together with several pre-optimized (specialized) versions of a given species that maximize performance and minimize costs across as many inputs, hardware and environment states as possible, as described in [57]\nSoftware engineers can now assemble self-tuning applications just like \u201dLEGO\u201d from the shared cM plugins with continuously optimized species. Such software not only can adapt to the running hardware and context, but also continue improving its performance and minimize usage costs when more collective knowledge is available. This can help change current computer engineering methodology since software engineers do not have to wait anymore until hardware or compilers become better. Instead, the software engineering community gradually creates a large, diverse and realistic benchmark together with a public and continuously improving optimization advice system that helps improve and validate future compilers and hardware. For example, we envision that our approach will also help simplify compilers and convert them into generic libraries of code analysis, optimization and generation routines orchestrated by cM-like frameworks.\nTo avoid the fate of many projects that vanish shortly after publication, we agreed with our partners to share most of the related code and data at our public optimization repository to continue further community-driven developments. For example, with the help of our supporters, we already shared around 300 software species and\ncollected around 15000 possible data sets. At the same time, we also shared various features as cM meta-data from our past research on machine learning based optimization including MILEPOST semantic code properties [39], code patterns and control flow graph extracted by our GCC/LLVM Alchemist plugin [40], image and matrix dimensions together with data set sizes from [57], OS parameters, system descriptions, hardware performance counters, CPU frequency and many other.\nPublic availability of such a repository and open source cM infrastructure allowed us to validate our approach in several major companies. For example, we demonstrated how our industry colleagues managed to enhance their in-house benchmarking suites to considerably improve optimization heuristics of their production GCC compiler for a number of ARM and Intel based processors while detecting several architectural errors during validation of new hardware configurations. Finally, presented approach helped to convert an important customer statically compiled image processing application into a self-tuning one that maximizes performance to reach real time constraints and minimize all other costs including energy, overall development and tuning effort, and time to market.\nAs a part of the future work, we plan to simplify as much as possible the experience of software engineers and volunteers wishing to participate in our project. Therefore, we are currently extending our cM framework to automate identification, extraction and sharing of the frequently used and most time consuming software pieces and their features in real programs. For this purpose, we plan to use and extend our Interactive Compilation Interface for GCC and LLVM while connecting cM framework with Eclipse IDE [6] to simplify integration of our cM wrappers and performance/cost monitoring plugins with real applications, with Docker [5] and CARE [49] to automatically detect all software dependencies for sharing, and with Phoronix open benchmarking infrastructure [13] to add even more realistic software pieces to our repository.\nAt the same time, our top-down methodology originating from physics allows the software engineering community benefit from all existing optimizations including powerful polyhedral source-to-source code restructuring and parallelization [24] by gradually adding them to our cM performance tracking and tuning framework [40]. Furthermore, researchers now have an opportunity to immediately validate their novel or existing optimization techniques across a realistic benchmark and a large number of participating computer systems. Unified \u201dbig data\u201d repository of optimization knowledge also helped us initiate collaboration with AI and physics departments to gradually characterize complex interactions between shared software pieces inside large applications using agent based techniques [67]. We are also actively working with the academic and industrial community through the cTuning foundation to continue adding more coarse-grain and fine-grain species to our repository to gradually cover all possible and frequently used software. For example, we would like to add algorithmic species from [64] to our system and continuously optimize and characterize them. We hope, that in a longer term, our approach will help software and hardware engineers boost innovation and focus on implementing new ideas and functionality rather than worrying about performance regressions and costs. It should also help make machine learning for compilation and architecture practical (including autotuning and run-time adaptation particularly important nowadays for mobile devices and data centers) while avoiding common pitfalls such as using a small subset of non-representative data sets and features. Interestingly, our approach may also eventually help make brain inspired computing practical since we can continuously collect large number of realistic data sets, continuously improve predictive models and collaboratively find missing features (to some extent enabling large and distributed brain). Finally, we plan to use our public repository to promote and support initiatives on artifact evaluation as a part of reproducible and sustainable software engineering [38]."}, {"heading": "8 Acknowledgments", "text": "Presented work was supported by the HiPEAC, STMicroelectronics, cTuning foundation, EU FP7 609491 TETRACOM project and ARM. We would like to thank Ed Plowman (ARM), Marco Cornero (ARM) and Sergey Yakushkin (Synopsys) for interesting feedback and discussions."}, {"heading": "9 Appendix: Collective Knowledge \u2013 a customizable knowledge man-", "text": "agement framework for systematic and collaborative experimentation\nOver the past two years, we have collected considerable feedback from academic and industrial users about Collective Mind, the third version of the cTuning technology.\nPositive feedback highlighted considerable improvements over the previous versions of the cTuning technology [35] for sharing experimental artifacts such as programs, data sets, graphs and models within work groups (e.g. at the same institution) and with a wider community (e.g. alongside publications). Users particularly appreciated the flexibility and ease of organizing their knowledge using an open JSON-based repository format and API rather than being forced to use rigid and possibly closed database schemas. Users were also intrigued by the possibilities for crowdsourcing exploration of large multi-dimensional optimization spaces and applying machine-learning techniques to generate and reuse knowledge across many platforms (phones, tablets, laptops, cloud services and supercomputers).\nOn the other hand, users disliked having to download over 20 MB to obtain the framework with all components, having to use the web service instead of plain command line, slow invocation and slow processing when ElasticSearch indexing was unavailable.\nAfter carefully considering this feedback and available options, we decided to develop a new version from scratch while keeping the original open JSON-based repository format and API. Thanks to the 6-months grant from the EU FP7 609491 TETRACOM project, we have developed Collective Knowledge (or CK for short), the fourth version of the cTuning technology, publicly available at http://github.com/ctuning/ck under permissive BSD license. The main focus was to make the core of Collective Knowledge as small, fast, simple and command-line-oriented as possible, while moving all additional functionality such as predictive analytics, autotuning, statistical analysis and web services into separate CK plugins shared via GitHub, Bitbucket or similar public services as conceptually shown in Figure 10.\nThe Collective Knowledge core works about 10 times faster than Collective Mind, is only around 100 KB in size, has minimal dependencies (mainly Python and Git), can be installed as a standard Python package and can be easily integrated with IPython Notebook. Furthermore, users can download only needed packages (while automatically resolving dependencies on other repositories) using only one shell command ck pull repo:[repo alias] (\u2013url=[Git url]). It is also possible to update the whole framework and all shared repositories at any time using ck pull all.\nWe believe this has considerably simplified using the cTuning technology and methodology for collaborative projects, including sharing of experimental artifacts, interactive reports and publications. (Examples are available at http://cknowledge.org/repo.)\nFor example, as a part of our long-term and continuing effort to share all code, data, models and interactive graphs from our research in a reproducible way [35], we are gradually converting all our past experiments and related artifacts to the new CK format. Our current focus is to use CK to solve old but still acute problems of hardware benchmarking, program autotuning, and run-time adaptation using collective knowledge and predictive models. Some artifacts from this paper are already available in the shared CK repository which can be obtained via ck pull repo:reproduce-ck-paper. For example, we have reproduced our past work on adaptive CPU/GPU scheduling [50] for an OpenCL-based video processing kernel on the Samsung Chromebook 2 powered by the ARM Cortex-A15 CPU and ARM Mali-T628 MP6 GPU. This includes continuous and online exploration and tuning of OpenCL parameters such as the local work size versus the computational intensity, video frame features, and processor frequencies. At the same time, we have applied active learning as in [50] to build and gradually refine a decision tree (shown in Figure 11 and shared at http://cknowledge.org/repo/web.php?wcid=84e27ad9dd12e734:f4b5b8fded3ce933) that could effectively predict whether to schedule the main kernel on the GPU (true) or the CPU (false) to minimize the overall execution time (improve the number of frames per second).\nWe believe that CK will improve support for our long-term vision towards collaborative, systematic, and reproducible computer engineering combined with statistical (\u201cmachine learning\u201d) techniques from physics [35, 40] and powerful predictive analytics frameworks such as SciPy, R, IBM Watson, Google Brain or similar. Furthermore, we envision that our approach will allow engineers to focus on quick prototyping of ideas, knowledge discovery and innovation, while helping them to get right complex, time-consuming and error-prone issues of experimental design.\nTo some extent our approach is similar to Wikipedia allowing users to share and continuously improve knowledge and experience while collaboratively extending meta-data, stabilizing API, fixing errors, improving predictive models, finding missing features and many more. In fact, all CK entries can be referenced by a unique collective identifier CID similar to DOI (repository UID or alias:module UID or alias:data UID or alias), and already include a dedicated wiki page (thus allowing researchers to collect feedback about their shared artifacts and engage in discussions with the community).\nFinally, we promote CK to enable Artifact Evaluation initiatives at leading academic conferences and communitydriven reviewing [38], along with other useful tools such as Docker.\nFurther information about CK is available at http://github.com/ctuning/ck/wiki and http://github.com/ ctuning/ck."}], "references": [{"title": "OCEANS: Optimizing compilers for embedded applications", "author": ["B. Aarts", "et.al"], "venue": "In Proc. Euro-Par 97,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 1997}, {"title": "Petabricks: a language and compiler for algorithmic choice", "author": ["J. Ansel", "C. Chan", "Y.L. Wong", "M. Olszewski", "Q. Zhao", "A. Edelman", "S. Amarasinghe"], "venue": "Proceedings of the 2009 ACM SIGPLAN conference on Programming language design and implementation, PLDI \u201909, pages 38\u201349, New York, NY, USA,", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2009}, {"title": "The landscape of parallel computing research: a view from Berkeley", "author": ["K. Asanovic", "R. Bodik", "B.C. Catanzaro", "J.J. Gebis", "P. Husbands", "K. Keutzer", "D.A. Patterson", "W.L. Plishker", "J. Shalf", "S.W. Williams", "K.A. Yelick"], "venue": "Technical Report UCB/EECS-2006-183, Electrical Engineering and Computer Sciences, University of California at Berkeley, Dec.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2006}, {"title": "The landscape of parallel computing research: a view from Berkeley", "author": ["K. Asanovic et.al"], "venue": "Technical Report UCB/EECS-2006-183, Electrical Engineering and Computer Sciences,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2006}, {"title": "Pattern Recognition and Machine Learning (Information Science and Statistics)", "author": ["C.M. Bishop"], "venue": "Springer, 1st ed. 2006. corr. 2nd printing 2011 edition, Oct.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2007}, {"title": "A practical automatic polyhedral program optimization system", "author": ["U. Bondhugula", "A. Hartono", "J. Ramanujam", "P. Sadayappan"], "venue": "ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), June", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2008}, {"title": "Evidence-based static branch prediction using machine learning", "author": ["B. Calder", "D. Grunwald", "M. Jones", "D. Lindsay", "J. Martin", "M. Mozer", "B. Zorn"], "venue": "ACM Transactions on Programming Languages and Systems (TOPLAS),", "citeRegEx": "25", "shortCiteRegEx": null, "year": 1997}, {"title": "Rapidly selecting good compiler optimizations using performance counters", "author": ["J. Cavazos", "G. Fursin", "F. Agakov", "E. Bonilla", "M. O\u2019Boyle", "O. Temam"], "venue": "In Proceedings of the International Symposium on Code Generation and Optimization (CGO),", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2007}, {"title": "Evaluating iterative optimization across 1000 data sets", "author": ["Y. Chen", "Y. Huang", "L. Eeckhout", "G. Fursin", "L. Peng", "O. Temam", "C. Wu"], "venue": "Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), June", "citeRegEx": "27", "shortCiteRegEx": null, "year": 2010}, {"title": "Optimizing for reduced code space using genetic algorithms", "author": ["K. Cooper", "P. Schielke", "D. Subramanian"], "venue": "Proceedings of the Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES), pages 1\u20139,", "citeRegEx": "28", "shortCiteRegEx": null, "year": 1999}, {"title": "Active harmony: towards automated performance tuning", "author": ["C. \u0162\u0103pu\u015f", "I.-H. Chung", "J.K. Hollingsworth"], "venue": "Proceedings of the 2002 ACM/IEEE conference on Supercomputing, Supercomputing \u201902, pages 1\u201311, Los Alamitos, CA, USA,", "citeRegEx": "29", "shortCiteRegEx": null, "year": 2002}, {"title": "The international exascale software project roadmap", "author": ["J. Dongarra et.al"], "venue": "Int. J. High Perform. Comput. Appl.,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 2011}, {"title": "Portable compiler optimization across embedded programs and microarchitectures using machine learning", "author": ["C. Dubach", "T.M. Jones", "E.V. Bonilla", "G. Fursin", "M.F. O\u2019Boyle"], "venue": "In Proceedings of the IEEE/ACM International Symposium on Microarchitecture (MICRO),", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2009}, {"title": "A test for normality based on the empirical characteristic function", "author": ["T.W. Epps", "L.B. Pulley"], "venue": "Biometrika, 70(3):pp. 723\u2013726,", "citeRegEx": "32", "shortCiteRegEx": null, "year": 1983}, {"title": "Building Watson: An Overview of the DeepQA Project", "author": ["D. Ferrucci et.al"], "venue": "AI Magazine,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2010}, {"title": "Probabilistic source-level optimisation of embedded programs", "author": ["B. Franke", "M. O\u2019Boyle", "J. Thomson", "G. Fursin"], "venue": "In Proceedings of the Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES),", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2005}, {"title": "Collective Tuning Initiative: automating and accelerating development and optimization of computing systems", "author": ["G. Fursin"], "venue": "Proceedings of the GCC Developers\u2019 Summit, June", "citeRegEx": "35", "shortCiteRegEx": null, "year": 2009}, {"title": "MiDataSets: Creating the conditions for a more realistic evaluation of iterative optimization", "author": ["G. Fursin", "J. Cavazos", "M. O\u2019Boyle", "O. Temam"], "venue": "In Proceedings of the International Conference on High Performance Embedded Architectures & Compilers (HiPEAC", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2007}, {"title": "A practical method for quickly evaluating program optimizations", "author": ["G. Fursin", "A. Cohen", "M. O\u2019Boyle", "O. Temam"], "venue": "In Proceedings of the International Conference on High Performance Embedded Architectures & Compilers (HiPEAC", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2005}, {"title": "Experience report: community-driven reviewing and validation of publications", "author": ["G. Fursin", "C. Dubach"], "venue": "Proceedings of the 1st Workshop on Reproducible Research Methodologies and New Publication Models in Computer Engineering (ACM SIGPLAN TRUST\u201914). ACM,", "citeRegEx": "38", "shortCiteRegEx": null, "year": 2014}, {"title": "Milepost gcc: Machine learning enabled self-tuning compiler", "author": ["G. Fursin", "Y. Kashnikov", "A.W. Memon", "Z. Chamski", "O. Temam", "M. Namolaru", "E. Yom-Tov", "B. Mendelson", "A. Zaks", "E. Courtois", "F. Bodin", "P. Barnard", "E. Ashton", "E. Bonilla", "J. Thomson", "C. Williams", "M.F.P. OBoyle"], "venue": "International Journal of Parallel Programming, 39:296\u2013327,", "citeRegEx": "39", "shortCiteRegEx": null, "year": 2011}, {"title": "Collective mind: Towards practical and collaborative auto-tuning", "author": ["G. Fursin", "R. Miceli", "A. Lokhmotov", "M. Gerndt", "M. Baboulin", "D. Malony", "Allen", "Z. Chamski", "D. Novillo", "D.D. Vento"], "venue": "Scientific Programming,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2014}, {"title": "Evaluating iterative compilation", "author": ["G. Fursin", "M. O\u2019Boyle", "P. Knijnenburg"], "venue": "In Proceedings of the Workshop on Languages and Compilers for Parallel Computers (LCPC),", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2002}, {"title": "Compiler research: The next 50 years", "author": ["M. Hall", "D. Padua", "K. Pingali"], "venue": "Commun. ACM, 52(2):60\u201367, Feb.", "citeRegEx": "43", "shortCiteRegEx": null, "year": 2009}, {"title": "The Fourth Paradigm: Data-Intensive Scientific Discovery", "author": ["T. Hey", "S. Tansley", "K.M. Tolle", "editors"], "venue": "Microsoft Research,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 2009}, {"title": "A fast learning algorithm for deep belief nets", "author": ["G.E. Hinton", "S. Osindero"], "venue": "Neural Computation, 18:2006,", "citeRegEx": "45", "shortCiteRegEx": null, "year": 2006}, {"title": "Neural networks and physical systems with emergent collective computational abilities", "author": ["J.J. Hopfield"], "venue": "Proceedings of the National Academy of Sciences, 79(8):2554\u20132558,", "citeRegEx": "46", "shortCiteRegEx": null, "year": 1982}, {"title": "Cole: Compiler optimization level exploration", "author": ["K. Hoste", "L. Eeckhout"], "venue": "Proceedings of the International Symposium on Code Generation and Optimization (CGO),", "citeRegEx": "47", "shortCiteRegEx": null, "year": 2008}, {"title": "Eye, Brain, and Vision (Scientific American Library, No 22)", "author": ["D.H. Hubel"], "venue": "W. H. Freeman, 2nd edition, May", "citeRegEx": "48", "shortCiteRegEx": null, "year": 1995}, {"title": "Care, the comprehensive archiver for reproducible execution", "author": ["Y. Janin", "C. Vincent", "R. Duraffort"], "venue": "Proceedings of the 1st ACM SIGPLAN Workshop on Reproducible Research Methodologies and New Publication Models in Computer Engineering, TRUST \u201914, pages 1:1\u20131:7, New York, NY, USA,", "citeRegEx": "49", "shortCiteRegEx": null, "year": 2014}, {"title": "Predictive runtime code scheduling for heterogeneous architectures", "author": ["V. Jimenez", "I. Gelado", "L. Vilanova", "M. Gil", "G. Fursin", "N. Navarro"], "venue": "Proceedings of the International Conference on High Performance Embedded Architectures & Compilers (HiPEAC 2009), January", "citeRegEx": "50", "shortCiteRegEx": null, "year": 2009}, {"title": "Combined selection of tile sizes and unroll factors using iterative compilation", "author": ["T. Kisuki", "P. Knijnenburg", "M. O\u2019Boyle"], "venue": "In Proceedings of the International Conference on Parallel Architectures and Compilation Techniques (PACT),", "citeRegEx": "51", "shortCiteRegEx": "51", "year": 2000}, {"title": "Finding effective optimization phase sequences", "author": ["P. Kulkarni", "W. Zhao", "H. Moon", "K. Cho", "D. Whalley", "J. Davidson", "M. Bailey", "Y. Paek", "K. Gallivan"], "venue": "Proceedings of the Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES), pages 12\u201323,", "citeRegEx": "52", "shortCiteRegEx": null, "year": 2003}, {"title": "On finding the maxima of a set of vectors", "author": ["H.T. Kung", "F. Luccio", "F.P. Preparata"], "venue": "J. ACM, 22(4):469\u2013476, Oct.", "citeRegEx": "53", "shortCiteRegEx": null, "year": 1975}, {"title": "LLVM: A compilation framework for lifelong program analysis & transformation", "author": ["C. Lattner", "V. Adve"], "venue": "Proceedings of the 2004 International Symposium on Code Generation and Optimization (CGO\u201904), Palo Alto, California, March", "citeRegEx": "54", "shortCiteRegEx": null, "year": 2004}, {"title": "Building high-level features using large scale unsupervised learning", "author": ["Q. Le", "M. Ranzato", "R. Monga", "M. Devin", "K. Chen", "G. Corrado", "J. Dean", "A. Ng"], "venue": "International Conference in Machine Learning,", "citeRegEx": "55", "shortCiteRegEx": null, "year": 2012}, {"title": "Design and implementation of a lightweight dynamic optimization system", "author": ["J. Lu", "H. Chen", "P.-C. Yew", "W.-C. Hsu"], "venue": "Journal of Instruction-Level Parallelism, volume 6,", "citeRegEx": "56", "shortCiteRegEx": null, "year": 2004}, {"title": "Finding representative sets of optimizations for adaptive multiversioning applications", "author": ["L. Luo", "Y. Chen", "C. Wu", "S. Long", "G. Fursin"], "venue": "3rd Workshop on Statistical and Machine Learning Approaches Applied to Architectures and Compilation (SMART\u201909), colocated with HiPEAC\u201909 conference, January", "citeRegEx": "57", "shortCiteRegEx": null, "year": 2009}, {"title": "Seeds: A software engineer\u2019s energy-optimization decision support framework", "author": ["I. Manotas", "L. Pollock", "J. Clause"], "venue": "Proceedings of the 36th International Conference on Software Engineering, ICSE 2014, pages 503\u2013514, New York, NY, USA,", "citeRegEx": "58", "shortCiteRegEx": null, "year": 2014}, {"title": "Contention aware execution: Online contention detection and response", "author": ["J. Mars", "N. Vachharajani", "R. Hundt", "M.L. Soffa"], "venue": "Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization, CGO \u201910, pages 257\u2013265, New York, NY, USA,", "citeRegEx": "59", "shortCiteRegEx": null, "year": 2010}, {"title": "FFTW: An adaptive software architecture for the FFT", "author": ["F. Matteo", "S. Johnson"], "venue": "Proceedings of the IEEE International Conference on Acoustics, Speech, and Signal Processing, volume 3, pages 1381\u20131384, Seattle, WA, May", "citeRegEx": "60", "shortCiteRegEx": null, "year": 1998}, {"title": "Autotune: A plugin-driven approach to the automatic tuning of parallel applications", "author": ["R. Miceli et.al"], "venue": "In Proceedings of the 11th International Conference on Applied Parallel and Scientific Computing,", "citeRegEx": "61", "shortCiteRegEx": "61", "year": 2013}, {"title": "Automatic generation of program affinity policies using machine learning", "author": ["R.W. Moore", "B.R. Childers"], "venue": "CC, pages 184\u2013203,", "citeRegEx": "62", "shortCiteRegEx": null, "year": 2013}, {"title": "Iterative feedback directed parallelisation using genetic algorithms", "author": ["A. Nisbet"], "venue": "Proceedings of the Workshop on Profile and Feedback Directed Compilation in conjunction with International Conference on Parallel Architectures and Compilation Technique (PACT),", "citeRegEx": "63", "shortCiteRegEx": null, "year": 1998}, {"title": "Algorithmic species: A classification of affine loop nests for parallel programming", "author": ["C. Nugteren", "P. Custers", "H. Corporaal"], "venue": "ACM Transactions on Architecture and Code Optimization, 9(4):Article\u201340,", "citeRegEx": "64", "shortCiteRegEx": null, "year": 2013}, {"title": "Fast and effective orchestration of compiler optimizations for automatic performance tuning", "author": ["Z. Pan", "R. Eigenmann"], "venue": "Proceedings of the International Symposium on Code Generation and Optimization (CGO), pages 319\u2013332,", "citeRegEx": "65", "shortCiteRegEx": null, "year": 2006}, {"title": "Glinda: a framework for accelerating imbalanced applications on heterogeneous platforms", "author": ["J. Shen", "A.L. Varbanescu", "H.J. Sips", "M. Arntzen", "D.G. Simons"], "venue": "Conf. Computing Frontiers, page 14,", "citeRegEx": "66", "shortCiteRegEx": null, "year": 2013}, {"title": "Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations", "author": ["Y. Shoham", "K. Leyton-Brown"], "venue": "Cambridge University Press, New York, NY, USA,", "citeRegEx": "67", "shortCiteRegEx": null, "year": 2008}, {"title": "Learning to predict performance from formula modeling and training data", "author": ["B. Singer", "M. Veloso"], "venue": "Proceedings of the Conference on Machine Learning,", "citeRegEx": "68", "shortCiteRegEx": null, "year": 2000}, {"title": "Meta optimization: Improving compiler heuristics with machine learning", "author": ["M. Stephenson", "S. Amarasinghe", "M. Martin", "U.-M. O\u2019Reilly"], "venue": "In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation", "citeRegEx": "70", "shortCiteRegEx": "70", "year": 2003}, {"title": "ADAPT: Automated de-coupled adaptive program transformation", "author": ["M. Voss", "R. Eigenmann"], "venue": "Proceedings of International Conference on Parallel Processing,", "citeRegEx": "71", "shortCiteRegEx": null, "year": 2000}, {"title": "Automatically tuned linear algebra software", "author": ["R. Whaley", "J. Dongarra"], "venue": "Proceedings of the Conference on High Performance Networking and Computing,", "citeRegEx": "72", "shortCiteRegEx": null, "year": 1998}], "referenceMentions": [{"referenceID": 51, "context": "They nowadays include hundreds of optimizations and often fail to produce efficient code while wasting expensive resources and energy [72, 18, 20, 43, 40].", "startOffset": 134, "endOffset": 154}, {"referenceID": 0, "context": "They nowadays include hundreds of optimizations and often fail to produce efficient code while wasting expensive resources and energy [72, 18, 20, 43, 40].", "startOffset": 134, "endOffset": 154}, {"referenceID": 2, "context": "They nowadays include hundreds of optimizations and often fail to produce efficient code while wasting expensive resources and energy [72, 18, 20, 43, 40].", "startOffset": 134, "endOffset": 154}, {"referenceID": 23, "context": "They nowadays include hundreds of optimizations and often fail to produce efficient code while wasting expensive resources and energy [72, 18, 20, 43, 40].", "startOffset": 134, "endOffset": 154}, {"referenceID": 21, "context": "They nowadays include hundreds of optimizations and often fail to produce efficient code while wasting expensive resources and energy [72, 18, 20, 43, 40].", "startOffset": 134, "endOffset": 154}, {"referenceID": 51, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 0, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 6, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 43, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 40, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 9, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 50, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 31, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 22, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 49, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 10, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 32, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 48, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 36, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 34, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 15, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 45, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 27, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 30, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 1, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 39, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 42, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 46, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 41, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 38, "context": "Numerous autotuning, run-time adaptation, genetic and machine learning techniques (including our own) have been introduced in the past two decades to help software engineers optimize their applications for rapidly evolving hardware [72, 18, 25, 63, 60, 28, 71, 51, 41, 70, 29, 52, 68, 56, 54, 34, 65, 47, 22, 50, 19, 59, 62, 66, 61, 58].", "startOffset": 232, "endOffset": 336}, {"referenceID": 3, "context": "Practically all recent long-term research visions acknowledge above problem [21, 30, 15, 43, 17].", "startOffset": 76, "endOffset": 96}, {"referenceID": 11, "context": "Practically all recent long-term research visions acknowledge above problem [21, 30, 15, 43, 17].", "startOffset": 76, "endOffset": 96}, {"referenceID": 23, "context": "Practically all recent long-term research visions acknowledge above problem [21, 30, 15, 43, 17].", "startOffset": 76, "endOffset": 96}, {"referenceID": 21, "context": "We then propose to use our recent Collective Mind framework and Hadoop-based repository of knowledge (cM for short) [40, 4] to extract and share such open source software pieces together with various possible inputs and meta data at c-mind.", "startOffset": 116, "endOffset": 123}, {"referenceID": 33, "context": "cM infrastructure then continuously records only the winning solutions (optimizations for a given data set and hardware) that minimize all or only monitored costs (execution time, power consumption, code size, failures, memory and storage footprint, and optimization time) of a given software piece on a Pareto frontier [53] in our public cM repository.", "startOffset": 320, "endOffset": 324}, {"referenceID": 20, "context": "This plugin-based interface is already available in mainline GCC [39], and we plan to add it to LLVM in the future [40].", "startOffset": 65, "endOffset": 69}, {"referenceID": 21, "context": "This plugin-based interface is already available in mainline GCC [39], and we plan to add it to LLVM in the future [40].", "startOffset": 115, "endOffset": 119}, {"referenceID": 4, "context": "optimizations to improve execution time, power consumption or some other characteristics using some off-the-shelf machine learning techniques such as SVM, (deep) neural networks or KNN [23, 45, 55] combined with a few ad-hoc program or architecture features.", "startOffset": 185, "endOffset": 197}, {"referenceID": 25, "context": "optimizations to improve execution time, power consumption or some other characteristics using some off-the-shelf machine learning techniques such as SVM, (deep) neural networks or KNN [23, 45, 55] combined with a few ad-hoc program or architecture features.", "startOffset": 185, "endOffset": 197}, {"referenceID": 35, "context": "optimizations to improve execution time, power consumption or some other characteristics using some off-the-shelf machine learning techniques such as SVM, (deep) neural networks or KNN [23, 45, 55] combined with a few ad-hoc program or architecture features.", "startOffset": 185, "endOffset": 197}, {"referenceID": 24, "context": "In contrast, our growing, large and diverse benchmark allows the community for the first time to apply methodology from sciences such as biology, medicine and AI based on big data predictive analytics [44].", "startOffset": 201, "endOffset": 205}, {"referenceID": 4, "context": "Also, in contrast with using more and more complex and computationally intensive machine learning techniques to predict optimizations such as deep neural networks [23, 45, 55], we decided to provide a new manual option useful for compiler and hardware designers.", "startOffset": 163, "endOffset": 175}, {"referenceID": 25, "context": "Also, in contrast with using more and more complex and computationally intensive machine learning techniques to predict optimizations such as deep neural networks [23, 45, 55], we decided to provide a new manual option useful for compiler and hardware designers.", "startOffset": 163, "endOffset": 175}, {"referenceID": 35, "context": "Also, in contrast with using more and more complex and computationally intensive machine learning techniques to predict optimizations such as deep neural networks [23, 45, 55], we decided to provide a new manual option useful for compiler and hardware designers.", "startOffset": 163, "endOffset": 175}, {"referenceID": 14, "context": "Thus, we are collaboratively building a giant optimization advice web service that links together all shared software species, optimizations and hardware configurations while resembling Wikipedia, IBM Watson advice engine [33], Google knowledge graph [9] and a brain.", "startOffset": 222, "endOffset": 226}, {"referenceID": 18, "context": "We also managed to derive 79 distinct optimization optimization classes covering all shared species (small real applications or hotspot kernels extracted from large applications with their run-time data set either manually as we did in [37], or using Codelet Finder from CAPS Entreprise as we did om the MILEPOST project [39], or using semi-manual extraction of OpenCL/CUDA kernels combined with OpenME plugin interface to extract run-time state [40]) that we correlated with program semantic and dynamic features using SVM and other predictive analytics techniques.", "startOffset": 236, "endOffset": 240}, {"referenceID": 20, "context": "We also managed to derive 79 distinct optimization optimization classes covering all shared species (small real applications or hotspot kernels extracted from large applications with their run-time data set either manually as we did in [37], or using Codelet Finder from CAPS Entreprise as we did om the MILEPOST project [39], or using semi-manual extraction of OpenCL/CUDA kernels combined with OpenME plugin interface to extract run-time state [40]) that we correlated with program semantic and dynamic features using SVM and other predictive analytics techniques.", "startOffset": 321, "endOffset": 325}, {"referenceID": 21, "context": "We also managed to derive 79 distinct optimization optimization classes covering all shared species (small real applications or hotspot kernels extracted from large applications with their run-time data set either manually as we did in [37], or using Codelet Finder from CAPS Entreprise as we did om the MILEPOST project [39], or using semi-manual extraction of OpenCL/CUDA kernels combined with OpenME plugin interface to extract run-time state [40]) that we correlated with program semantic and dynamic features using SVM and other predictive analytics techniques.", "startOffset": 446, "endOffset": 450}, {"referenceID": 17, "context": "1We currently have more than 15000 input samples collected in our past projects for our shared computational species [36, 11, 27].", "startOffset": 117, "endOffset": 129}, {"referenceID": 8, "context": "1We currently have more than 15000 input samples collected in our past projects for our shared computational species [36, 11, 27].", "startOffset": 117, "endOffset": 129}, {"referenceID": 4, "context": "Such networks can mimic brain functions and are often used for machine learning and data mining [23].", "startOffset": 96, "endOffset": 100}, {"referenceID": 26, "context": "For example, Figure 2 shows one of the oldest and well-known one-layer, fully interconnected, recurrent (with feedback connections) Hopfield neural network [46].", "startOffset": 156, "endOffset": 160}, {"referenceID": 28, "context": "It heavily depends on the total number of neurons, connections and layers [48], and is primarily limited by the speed and resources of the available hardware including specialized accelerators.", "startOffset": 74, "endOffset": 78}, {"referenceID": 20, "context": "Furthermore, we decided to perform a simple and well-known optimization compiler flag autotuning [1, 39] with at least 100 iterations to see whether there is still room for improvement over the fastest default compiler optimization level (-O3).", "startOffset": 97, "endOffset": 104}, {"referenceID": 33, "context": "We then gradually track the winning solutions that maximize performance and at the same time minimize all costs using our experience in physics and electronics, namely by applying Pareto frontier filter [53].", "startOffset": 203, "endOffset": 207}, {"referenceID": 13, "context": "4Similar to physics, we execute optimized code many times, check distribution of characteristics for normality [32], and report expected value if variation is less than 3%", "startOffset": 111, "endOffset": 115}, {"referenceID": 16, "context": "At first, we tried to create a simple database of optimizations and connect it to some existing benchmarking and autotuning tools to keep track of all optimizations [35, 39].", "startOffset": 165, "endOffset": 173}, {"referenceID": 20, "context": "At first, we tried to create a simple database of optimizations and connect it to some existing benchmarking and autotuning tools to keep track of all optimizations [35, 39].", "startOffset": 165, "endOffset": 173}, {"referenceID": 21, "context": "It was developed to unify and systematize software autotuning, make it practical and reproducible, and distribute it among numerous computing resources such as mobile phones and data centers shared by volunteers [40, 4].", "startOffset": 212, "endOffset": 219}, {"referenceID": 21, "context": "This allowed us to formalize almost all existing autotuning techniques as finding a function of a behavior of a given software piece B running on a given computer system with a given data set, selected hardware design and software optimization choices c, and a system state s ([40]):", "startOffset": 277, "endOffset": 281}, {"referenceID": 21, "context": "However, in case of further interest, more details can be found in [40, 4]", "startOffset": 67, "endOffset": 74}, {"referenceID": 4, "context": "However, we have already faced a similar problem in natural sciences and AI for many years and managed to effectively tackle it using predictive analytics (statistical analysis, data mining and machine learning) [23, 45, 55, 44].", "startOffset": 212, "endOffset": 228}, {"referenceID": 25, "context": "However, we have already faced a similar problem in natural sciences and AI for many years and managed to effectively tackle it using predictive analytics (statistical analysis, data mining and machine learning) [23, 45, 55, 44].", "startOffset": 212, "endOffset": 228}, {"referenceID": 35, "context": "However, we have already faced a similar problem in natural sciences and AI for many years and managed to effectively tackle it using predictive analytics (statistical analysis, data mining and machine learning) [23, 45, 55, 44].", "startOffset": 212, "endOffset": 228}, {"referenceID": 24, "context": "However, we have already faced a similar problem in natural sciences and AI for many years and managed to effectively tackle it using predictive analytics (statistical analysis, data mining and machine learning) [23, 45, 55, 44].", "startOffset": 212, "endOffset": 228}, {"referenceID": 20, "context": "At the same time, from our practical experience in using machine learning for program optimization and hardware designs [39, 31], we believe that it is not currently possible to fully automate this process due to a practically infinite feature space.", "startOffset": 120, "endOffset": 128}, {"referenceID": 12, "context": "At the same time, from our practical experience in using machine learning for program optimization and hardware designs [39, 31], we believe that it is not currently possible to fully automate this process due to a practically infinite feature space.", "startOffset": 120, "endOffset": 128}, {"referenceID": 20, "context": "Number of species Prediction accuracy 12 from prior work [39] 87% 285 from current work 56%", "startOffset": 57, "endOffset": 61}, {"referenceID": 20, "context": "We also decided to reuse and validate already available semantic and dynamic features from our previous work on machine learning based compiler [39].", "startOffset": 144, "endOffset": 148}, {"referenceID": 20, "context": "For this purpose, we generated and shared in the cM repository a feature vector f for each software species using 56 semantic program features from the MILEPOST GCC [39] (extracted during compilation at -O1 optimization level after pre pass)).", "startOffset": 165, "endOffset": 169}, {"referenceID": 4, "context": "We then passed 79 optimization clusters, 86 features and either all 285 shared species or a small subset of 12 ones used in some of our past works through a standard SVM classifier from R package [23, 16] with full cross-validation as described in [39, 26].", "startOffset": 196, "endOffset": 204}, {"referenceID": 20, "context": "We then passed 79 optimization clusters, 86 features and either all 285 shared species or a small subset of 12 ones used in some of our past works through a standard SVM classifier from R package [23, 16] with full cross-validation as described in [39, 26].", "startOffset": 248, "endOffset": 256}, {"referenceID": 7, "context": "We then passed 79 optimization clusters, 86 features and either all 285 shared species or a small subset of 12 ones used in some of our past works through a standard SVM classifier from R package [23, 16] with full cross-validation as described in [39, 26].", "startOffset": 248, "endOffset": 256}, {"referenceID": 16, "context": "Interestingly, cM approach can also help solve \u201dbig data problem\u201d that we experienced in our first public cTuning framework [35, 39].", "startOffset": 124, "endOffset": 132}, {"referenceID": 20, "context": "Interestingly, cM approach can also help solve \u201dbig data problem\u201d that we experienced in our first public cTuning framework [35, 39].", "startOffset": 124, "endOffset": 132}, {"referenceID": 3, "context": "The computer engineering community has been desperately trying to find some practical ways to automatically improve software performance while reducing power consumption and other usage costs across numerous and rapidly evolving computer systems for several decades [21, 30, 15, 43, 17].", "startOffset": 266, "endOffset": 286}, {"referenceID": 11, "context": "The computer engineering community has been desperately trying to find some practical ways to automatically improve software performance while reducing power consumption and other usage costs across numerous and rapidly evolving computer systems for several decades [21, 30, 15, 43, 17].", "startOffset": 266, "endOffset": 286}, {"referenceID": 23, "context": "The computer engineering community has been desperately trying to find some practical ways to automatically improve software performance while reducing power consumption and other usage costs across numerous and rapidly evolving computer systems for several decades [21, 30, 15, 43, 17].", "startOffset": 266, "endOffset": 286}, {"referenceID": 4, "context": "This, in turn, allows the interdisciplinary community to collaboratively correlate found classes with gradually exposed features from the software, hardware, data sets and environment state either manually or using popular big data predictive analytics [23, 44].", "startOffset": 253, "endOffset": 261}, {"referenceID": 24, "context": "This, in turn, allows the interdisciplinary community to collaboratively correlate found classes with gradually exposed features from the software, hardware, data sets and environment state either manually or using popular big data predictive analytics [23, 44].", "startOffset": 253, "endOffset": 261}, {"referenceID": 37, "context": "Resulting predictive models are then integrated into cM plugins together with several pre-optimized (specialized) versions of a given species that maximize performance and minimize costs across as many inputs, hardware and environment states as possible, as described in [57] Software engineers can now assemble self-tuning applications just like \u201dLEGO\u201d from the shared cM plugins with continuously optimized species.", "startOffset": 271, "endOffset": 275}, {"referenceID": 20, "context": "At the same time, we also shared various features as cM meta-data from our past research on machine learning based optimization including MILEPOST semantic code properties [39], code patterns and control flow graph extracted by our GCC/LLVM Alchemist plugin [40], image and matrix dimensions together with data set sizes from [57], OS parameters, system descriptions, hardware performance counters, CPU frequency and many other.", "startOffset": 172, "endOffset": 176}, {"referenceID": 21, "context": "At the same time, we also shared various features as cM meta-data from our past research on machine learning based optimization including MILEPOST semantic code properties [39], code patterns and control flow graph extracted by our GCC/LLVM Alchemist plugin [40], image and matrix dimensions together with data set sizes from [57], OS parameters, system descriptions, hardware performance counters, CPU frequency and many other.", "startOffset": 258, "endOffset": 262}, {"referenceID": 37, "context": "At the same time, we also shared various features as cM meta-data from our past research on machine learning based optimization including MILEPOST semantic code properties [39], code patterns and control flow graph extracted by our GCC/LLVM Alchemist plugin [40], image and matrix dimensions together with data set sizes from [57], OS parameters, system descriptions, hardware performance counters, CPU frequency and many other.", "startOffset": 326, "endOffset": 330}, {"referenceID": 29, "context": "For this purpose, we plan to use and extend our Interactive Compilation Interface for GCC and LLVM while connecting cM framework with Eclipse IDE [6] to simplify integration of our cM wrappers and performance/cost monitoring plugins with real applications, with Docker [5] and CARE [49] to automatically detect all software dependencies for sharing, and with Phoronix open benchmarking infrastructure [13] to add even more realistic software pieces to our repository.", "startOffset": 282, "endOffset": 286}, {"referenceID": 5, "context": "At the same time, our top-down methodology originating from physics allows the software engineering community benefit from all existing optimizations including powerful polyhedral source-to-source code restructuring and parallelization [24] by gradually adding them to our cM performance tracking and tuning framework [40].", "startOffset": 236, "endOffset": 240}, {"referenceID": 21, "context": "At the same time, our top-down methodology originating from physics allows the software engineering community benefit from all existing optimizations including powerful polyhedral source-to-source code restructuring and parallelization [24] by gradually adding them to our cM performance tracking and tuning framework [40].", "startOffset": 318, "endOffset": 322}, {"referenceID": 47, "context": "Unified \u201dbig data\u201d repository of optimization knowledge also helped us initiate collaboration with AI and physics departments to gradually characterize complex interactions between shared software pieces inside large applications using agent based techniques [67].", "startOffset": 259, "endOffset": 263}, {"referenceID": 44, "context": "For example, we would like to add algorithmic species from [64] to our system and continuously optimize and characterize them.", "startOffset": 59, "endOffset": 63}, {"referenceID": 19, "context": "Finally, we plan to use our public repository to promote and support initiatives on artifact evaluation as a part of reproducible and sustainable software engineering [38].", "startOffset": 167, "endOffset": 171}], "year": 2015, "abstractText": "Nowadays, engineers have to develop software often without even knowing which hardware it will eventually run on in numerous mobile phones, tablets, desktops, laptops, data centers, supercomputers and cloud services. Unfortunately, optimizing compilers are not keeping pace with ever increasing complexity of ever changing computer systems anymore and may produce severely underperforming executable codes while wasting expensive resources and energy. We present the first to our knowledge practical, collaborative and publicly available solution to this problem. We help the software engineering community gradually implement and share light-weight wrappers around any software piece with more than one implementation or optimization choice available. These wrappers are connected with a public Collective Mind autotuning infrastructure and repository of knowledge to continuously monitor all important characteristics of these pieces (computational species) across numerous existing hardware configurations in realistic environments together with randomly selected optimizations. At the same time, Collective Mind Node) allows to easily crowdsource time-consuming autotuning across existing Android-based mobile device including commodity mobile phones and tables. Similar to natural sciences, we can now continuously track all winning solutions (optimizations for a given hardware such as compiler flags, OpenCL/CUDA/OpenMP/MPI/skeleton parameters, number of threads and any other exposed by users) that minimize all costs of a computation (execution time, energy spent, code size, failures, memory and storage footprint, optimization time, faults, contentions, inaccuracy and so on) of a given species on a Pareto frontier along with any unexpected behavior at c-mind.org/repo . Furthermore, the community can continuously classify solutions, prune redundant ones, and correlate them with various features of software, its inputs (data sets) and used hardware either manually (similar to Wikipedia) or using available big data analytics and machine learning techniques. Our approach can also help computer engineering community create the first public, realistic, large, diverse, distributed, representative, and continuously evolving benchmark with related optimization knowledge while gradually covering all possible software and hardware to be able to predict best optimizations and improve compilers depending on usage scenarios and requirements. Such continuously growing collective knowledge accessible via simple web service can become an integral part of the practical software and hardware co-design of self-tuning computer systems as we demonstrate in several real usage scenarios validated in industry..", "creator": "LaTeX with hyperref package"}}}