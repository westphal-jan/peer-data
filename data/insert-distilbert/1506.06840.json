{"id": "1506.06840", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "23-Jun-2015", "title": "On Variance Reduction in Stochastic Gradient Descent and its Asynchronous Variants", "abstract": "we study precision optimization algorithms usually based on variance function reduction for stochastic gradient descent ( sgd ). remarkable recent progress has been significantly made in this direction through sequential development of generic algorithms like sag, reverse svrg, saga. these algorithms have been shown to outperform sgd, significantly both theoretically and empirically. however, alternative asynchronous swarm versions of these algorithms - - - a crucial requirement for modern large - scale applications - - - have not been studied. we bridge this gap by presenting a unifying framework for many global variance reduction techniques. subsequently, we propose generating an asynchronous survival algorithm grounded only in our theoretical framework, and prove its fast convergence. an important consequence note of our general approach is importantly that it yields asynchronous versions of variance reduction algorithms such as svrg and saga as a byproduct. our method achieves near linear speedup in sparse settings common to robust machine learning. we demonstrate the empirical measurement performance of our method through a concrete realization of asynchronous svrg.", "histories": [["v1", "Tue, 23 Jun 2015 01:57:19 GMT  (1467kb,D)", "http://arxiv.org/abs/1506.06840v1", null], ["v2", "Mon, 25 Jan 2016 01:12:06 GMT  (396kb,D)", "http://arxiv.org/abs/1506.06840v2", null]], "reviews": [], "SUBJECTS": "cs.LG stat.ML", "authors": ["sashank j reddi", "ahmed hefny", "suvrit sra", "barnab\u00e1s p\u00f3czos", "alexander j smola"], "accepted": true, "id": "1506.06840"}, "pdf": {"name": "1506.06840.pdf", "metadata": {"source": "CRF", "title": "On Variance Reduction in Stochastic Gradient Descent and its Asynchronous Variants", "authors": ["Sashank J. Reddi", "Ahmed Hefny"], "emails": ["sjakkamr@cs.cmu.edu", "ahefny@cs.cmu.edu", "suvrit@mit.edu", "bapoczos@cs.cmu.edu", "alex@smola.org"], "sections": [{"heading": "1 Introduction", "text": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:\nmin x\u2208Rd\nf(x) := 1n \u2211n i=1 fi(x). (1.1)\nUnder strong convexity assumptions such variance reduced (VR) stochastic algorithms attain better convergence rates (in expectation) than stochastic gradient descent (SGD) [17, 22], both in theory and practice.1 The key property of these VR algorithms is that by exploiting problem structure and by making suitable space-time tradeoffs, they reduce the variance incurred due to stochastic gradients. This variance reduction has powerful consequences: it bestows VR stochastic methods with linear convergence rates, and thereby circumvents slowdowns that usually hit SGD.\n1Though we should note that SGD also applies to the harder stochastic optimization problem min F (x) = E[f(x; \u03be)], which need not be a finite-sum.\nar X\niv :1\n50 6.\n06 84\n0v 1\n[ cs\n.L G\nAlthough these advances have great value in general, for large-scale problems we still require parallel or distributed processing. And in this setting, asynchronous variants of SGD remain indispensable [2, 7, 12, 20, 26, 28]. Therefore, a key question is how to extend the synchronous finite-sum VR algorithms to asynchronous parallel and distributed settings.\nWe answer one part of this question by developing new asynchronous parallel stochastic gradient methods that provably converge at a linear rate for smooth strongly convex finite-sum problems. Our methods are inspired by the influential SVRG [9], S2GD [11], SAG [23] and SAGA [5] family of algorithms. We list our contributions more precisely below.\nContributions. Our paper has two core components: (i) a formal general framework for variance reduced stochastic methods based on discussions in [5]; and (ii) asynchronous parallel VR algorithms within the framework. The general framework presents a formal unifying view of several VR methods (e.g., it includes SAGA and SVRG as special cases) while expressing key algorithmic and practical tradeoffs concisely. Thus, it yields a broader understanding of VR methods, which helps us obtain asynchronous parallel variants of VR methods. Under settings common to machine learning problems, our parallel algorithms attain speedups that scale near linearly with the number of processors.\nAs a concrete illustration, we present a specialization to an asynchronous SVRG-like method. We compare this specialization with non-variance reduced asynchronous SGD methods, and observe strong empirical speedups that agree with the theory.\nRelated work. As already mentioned, our work is closest to (and generalizes) SAG [23], SAGA [5], SVRG [9] and S2GD [11], which are primal methods. Also closely related are dual methods such as SDCA [25] and Finito [6], and in its convex incarnation MISO [15]; a more precise relation between these dual methods and VR stochastic methods is described in Defazio\u2019s thesis [4]. By their algorithmic structure, these VR methods trace back to classical non-stochastic incremental gradient algorithms [3], but by now it is well-recognized that randomization helps obtain much sharper convergence results (in expectation). Proximal [27] and accelerated VR methods have also been proposed [19, 24]; we leave a study of such variants of our framework as future work. Finally, there is recent work on lower-bounds for finite-sum problems [1].\nWithin asynchronous SGD algorithms, both parallel [20] and distributed [2, 16] variants are known. In this paper, we focus our attention on the parallel setting. A different line of methods is that of (primal) coordinate descent methods, and their parallel and distributed variants [13, 14, 18, 21]. Our asynchronous methods share some structural assumptions with these methods. Finally, the recent work [10] generalizes S2GD to the mini-batch setting, thereby also permitting parallel processing, albeit with more synchronization and allowing only small mini-batches."}, {"heading": "2 A General Framework for VR Stochastic Methods", "text": "We focus on instances of (1.1) where the cost function f(x) has an L-Lipschitz gradient, so that \u2016\u2207f(x)\u2212\u2207f(y)\u2016 \u2264 L\u2016x\u2212 y\u2016, and it is \u03bb-strongly convex, i.e., for all x, y \u2208 Rd,\nf(x) \u2265 f(y) + \u3008\u2207f(y), x\u2212 y\u3009+ \u03bb2 \u2016x\u2212 y\u2016 2. (2.1)\nWhile our analysis focuses on strongly convex functions, we can extend it to just smooth convex functions along the lines of [27].\nInspired by the discussion on a general view of variance reduced techniques in [5], we now describe a formal general framework for variance reduction in stochastic gradient descent. We denote the collection {fi}ni=1 of functions that make up f in (1.1) by F . For our algorithm, we maintain an additional parameter \u03b1ti \u2208 Rd for each fi \u2208 F . We use At to denote {\u03b1ti}ni=1. The general iterative framework for updating the parameters is presented as Algorithm 1. Observe that the algorithm is still abstract, since it does not specify the subroutine SCHEDULEUPDATE. This subroutine determines the crucial update mechanism of {\u03b1ti} (and thereby ofAt). As we will see different schedules give rise to different fast first-order methods proposed in the literature. The part of the update based on At is the key for these approaches and is responsible for variance reduction.\nNext, we provide different instantiations of the framework and construct a new algorithm derived from it. In particular, we consider incremental methods SAG [23], SVRG [9] and SAGA [5], and classic gradient descent GRADIENTDESCENT for demonstrating our framework.\nALGORITHM 1: GENERIC STOCHASTIC VARIANCE REDUCTION ALGORITHM Data: x0 \u2208 Rd, \u03b10i = x0 \u2200i \u2208 [n] , {1, . . . , n}, step size \u03b7 > 0 Randomly pick a IT = {i0, . . . , iT } where it \u2208 {1, . . . , n} \u2200 t \u2208 {0, . . . , T} ; for t = 0 to T do\nUpdate iterate as xt+1 \u2190 xt \u2212 \u03b7 ( \u2207fit(xt)\u2212\u2207fit(\u03b1tit) + 1 n \u2211 i fi(\u03b1 t i) )\n; At+1 = SCHEDULEUPDATE({xi}t+1i=0, At, t, IT ) ;\nend return xT\nFigure 1 shows the schedules for the aforementioned algorithms. In case of SVRG, SCHEDULEUPDATE is triggered every m iterations (here m denotes precisely the number of inner iterations used in [9]); so At remains unchanged for the m iterations and all \u03b1ti are updated to the current iterate at the mth iteration. For SAGA, unlike SVRG, At changes at the tth iteration for all t \u2208 [T ]. This change is only to a single element of At, and is determined by the index it (the function chosen at iteration t). The update of SAG is similar to SAGA insofar that only one of the \u03b1i is updated at each iteration. However, the update for At+1 is based on it+1 rather than it. This results in a biased estimate of the gradient, unlike SVRG and SAGA. Finally, the schedule for gradient descent is similar to SAG, except that all the \u03b1i\u2019s are updated at each iteration. Due to the full update we end up with the exact gradient at each iteration. This discussion highlights how the scheduler determines the resulting gradient method.\nTo motivate the design of another schedule, let us consider the computational and storage costs of each of these algorithms. For SVRG, since we update At after every m iterations, it is enough to store a full gradient, and hence, the storage cost is O(d). However, the running time is O(nd) at each epoch and O(d) at each iteration since we have to calculate the full gradient at end of each epoch. In contrast, both SAG and SAGA have high storage costs of O(nd) and running time of O(d) per iteration. Finally, GRADIENTDESCENT has low storage cost since it needs to store the gradient at O(d) cost, but very high computational costs of O(nd) at each iteration.\nIt is interesting to note that when m is high (say greater than n), SVRG has low computational cost per iteration. However, as we will later see, this comes at the expense of slower convergence to the optimal solution. SAG and SAGA can converge faster by allowing us to update At more frequently, but at the cost of additional storage. The tradeoffs between the epoch size m, additional storage, frequency of updates, and the convergence to the optimal solution are still not completely resolved.\nA straightforward approach to design a new scheduler is to combine the schedules of the above algorithms. We call this schedule hybrid stochastic average gradient (HSAG). Specifically, we use the schedules of SVRG and SAGA to develop HSAG. Consider S \u2286 [n], the indices that follow SAGA schedule. We assume that rest of the indices follow an SVRG-like schedule with schedule frequency si for all i \u2208 S , [n] \\S. Figure 2 shows the corresponding update schedule of HSAG. If\nThis algorithm assumes access to the index set S and the schedule frequency vector s.\nS = [n] then HSAG is equivalent to SAGA, while at the other extreme, for S = \u2205 and si = m for all i \u2208 [n], it corresponds to SVRG. HSAG exhibits interesting storage, computational and convergence trade-offs that depend on S. In general, while large cardinality of S likely incurs high storage costs, the computational cost per iteration is relatively low. On the other hand, when cardinality of S is small and si\u2019s are large, storage costs are low but the convergence typically slows down.\nBefore concluding our discussion on the general framework, we would like to draw the reader\u2019s attention to the advantages of studying Algorithm 1. First, note that Algorithm 1 provides a unifying framework for many incremental/stochastic gradient methods proposed in the literature. Second, and more importantly, it provides a generic platform for analyzing this class of algorithms. As we will see in Section 3, this helps us develop and analyze asynchronous versions for different finite-sum algorithms under a common umbrella. Finally, it provides a mechanism to derive new algorithms by designing more sophisticated schedules; as noted above, one such construction gives rise to HSAG."}, {"heading": "2.1 Convergence Analysis", "text": "In this section, we provide convergence analysis for Algorithm 1 with HSAG schedules. As observed earlier, SVRG and SAGA are special cases of this setup. Our analysis assumes unbiasedness of the gradient estimates at each iteration, so it does not encompass SAG. For ease of exposition, we assume that all si = m for all i \u2208 [n]. Since HSAG is epoch-based, our analysis focuses on the iterates obtained after each epoch. Similar to [9] (see Option II of SVRG in [9]), our analysis will be for the case where the iterate at the end of (k + 1)st epoch, xkm+m, is replaced with an element chosen randomly from {xkm, . . . , xkm+m\u22121} with probability {p1, \u00b7 \u00b7 \u00b7 , pm}. For brevity, we use x\u0303k to denote the iterate chosen at the kth epoch. We also need the following quantity for our analysis:\nG\u0303k , 1\nn \u2211 i\u2208S ( fi(\u03b1 km i )\u2212 fi(x\u2217)\u2212 \u3008\u2207fi(x\u2217), \u03b1kmi \u2212 x\u2217\u3009 ) .\nTheorem 1. For any positive parameters c, \u03b2, \u03ba > 1, step size \u03b7 and epoch size m, we define the following quantities:\n\u03b3 = \u03ba [ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]( 2c\u03b7(1\u2212 L\u03b7(1 + \u03b2))\u2212 1\nn \u2212 2c \u03ba\u03bb ) \u03b8 = max {[ 2c\n\u03b3\u03bb\n( 1\u2212 1\n\u03ba\n)m + 2Lc\u03b72\n\u03b3\n( 1 + 1\n\u03b2\n) \u03ba [ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]] , ( 1\u2212 1\n\u03ba\n)m} ."}, {"heading": "Suppose the probabilities pi \u221d (1\u2212 1\u03ba )", "text": "m\u2212i, and that c, \u03b2, \u03ba, step size \u03b7 and epoch sizem are chosen such that the following conditions are satisfied:\n1 \u03ba + 2Lc\u03b72\n( 1 + 1\n\u03b2 ) \u2264 1 n , \u03b3 > 0, \u03b8 < 1.\nThen, for iterates of Algorithm 1 under the HSAG schedule, we have E [ f(x\u0303k+1)\u2212 f(x\u2217) + 1\n\u03b3 G\u0303k+1\n] \u2264 \u03b8 E [ f(x\u0303k)\u2212 f(x\u2217) + 1\n\u03b3 G\u0303k\n] .\nAs a corollary, we immediately obtain an expected linear rate of convergence for HSAG.\nCorollary 1. Note that G\u0303k \u2265 0 and therefore, under the conditions specified in Theorem 1 and \u03b8\u0304 = \u03b8 (1 + 1/\u03b3) < 1 we have\nE [ f(x\u0303k)\u2212 f(x\u2217) ] \u2264 \u03b8\u0304k [ f(x0)\u2212 f(x\u2217) ] .\nWe emphasize that there exist values of the parameters for which the conditions in Theorem 1 and Corollary 1 are easily satisfied. For instance, setting \u03b7 = 1/16(\u03bbn + L), \u03ba = 4/\u03bb\u03b7, \u03b2 = (2\u03bbn + L)/L and c = 2/\u03b7n, the conditions in Theorem 1 are satisfied for sufficiently large m. Additionally, in the high condition number regime of L/\u03bb = n, we can obtain constant \u03b8 < 1 (say 0.5) with m = O(n) epoch size (similar to [5, 9]). This leads to accuracy in the objective function after n log(1/ ) number of iterations."}, {"heading": "3 Asynchronous Stochastic Variance Reduction", "text": "We are now ready to present asynchronous versions of the algorithms captured by our general framework. We first describe our setup before delving into the details of these algorithms. Our model of computation is similar to the ones used in Hogwild! [20] and AsySCD [14]. We assume a multicore architecture where each core makes stochastic gradient updates to a centrally stored vector x in an asynchronous manner. There are four key components in our asynchronous algorithm; these are briefly described below.\n1. Read: Read the iterate x and compute the gradient\u2207fit(x) for a randomly chosen it. 2. Read schedule iterate: Read the schedule iterate A and compute the gradients required\nfor update in Algorithm 1 3. Update: Update the iterate x with the computed incremental update in Algorithm 1. 4. Schedule Update: Run a scheduler update for updating A.\nEach processor repeatedly runs these procedures concurrently, without any synchronization. Hence, x may change in between Step 1 and Step 3. Similarly, A may change in between Steps 2 and 4. In fact, the states of iterates x and A can correspond to different time-stamps. We maintain a global counter t to track the number of updates successfully executed. We use D(t) \u2208 [t] and D\u2032(t) \u2208 [t] to denote the particular x-iterate and A-iterate used for evaluating the update at the tth iteration. We assume that the delay in between the time of evaluation and updating is bounded by a non-negative integer \u03c4 , i.e., t\u2212D(t) \u2264 \u03c4 and t\u2212D\u2032(t) \u2264 \u03c4 . The bound on the staleness captures the degree of parallelism in the method: such parameters are typical in asynchronous systems (see e.g., [14, 20]).\nWe assume a read consistent model for our analysis. In particular, our analysis requires that the vector x used for evaluation of gradients be a valid iterate that existed at some point in time. However, like Hogwild! our implementation is lock-free. We will revisit this point in Section 4."}, {"heading": "3.1 Convergence Analysis", "text": "The key ingredients to the success of asynchronous algorithms for multicore stochastic gradient descent are sparsity and \u201cdisjointness\u201d of the data matrix [20]. We also exploit these properties of the data for our convergence analysis. More formally, let \u2016x\u2016i denote the norm of x with respect to non-zero coordinates of function fi; then, the convergence depends on \u2206, the smallest constant such that Ei[\u2016x\u20162i ] \u2264 \u2206\u2016x\u20162. Intuitively, \u2206 denotes the average frequency with which a feature appears in the data matrix. We are interested in situations where \u2206 1. As a warm up, let us first discuss convergence analysis for asynchronous SVRG. The general case is similar, but much more involved. Hence, it is instructive to first go through the analysis of asynchronous SVRG. Theorem 2. Suppose step size \u03b7, epoch size m are chosen such that the following condition holds:\n0 < \u03b8s :=\n( 1 \u03bb\u03b7m + 4L ( \u03b7+L\u2206\u03c42\u03b72 1\u22122L2\u2206\u03b72\u03c42 )) (\n1\u2212 4L ( \u03b7+L\u2206\u03c42\u03b72\n1\u22122L2\u2206\u03b72\u03c42 )) < 1. Then, for the iterates of an asynchronous variant of Algorithm 1 with SVRG schedule and probabilities pi = 1/m for all i \u2208 [m], we have\nE[f(x\u0303k+1)\u2212 f(x\u2217)] \u2264 \u03b8s E[f(x\u0303k)\u2212 f(x\u2217)].\nThe bound obtained in Theorem 2 is useful when \u2206 is small. To see this, as earlier, consider the indicative case where L/\u03bb = n. The synchronous version of SVRG obtains a convergence rate of \u03b8 = 0.5 for step size \u03b7 = 0.1/L and epoch size m = O(n). For the asynchronous variant of SVRG, by setting \u03b7 = 0.1/2(max{1,\u22061/2\u03c4}L), we obtain a similar rate with m = O(n + \u22061/2\u03c4n). To obtain this, set \u03b7 = \u03c1/L where \u03c1 = 0.1/2(max{1,\u22061/2\u03c4}) and \u03b8s = 0.5. Then, a simple calculation gives the following:\nm n = 2 \u03c1\n( 1\u2212 2\u2206\u03c42\u03c12\n1\u2212 12\u03c1\u2212 14\u2206\u03c42\u03c12\n) \u2264 c\u2032max{1,\u22061/2\u03c4},\nwhere c\u2032 is some constant. This follows from the fact that \u03c1 = 0.1/2(max{1,\u22061/2\u03c4}). Suppose \u03c4 < 1/\u22061/2. Then we can achieve nearly the same guarantees as the synchronous version, but \u03c4 times faster since we are running the algorithm asynchronously. For example, consider the sparse setting where \u2206 = o(1/n); then it is possible to get near linear speedup when \u03c4 = o(n1/2). On the other hand, when \u22061/2\u03c4 > 1, we can obtain a theoretical speedup of 1/\u22061/2.\nWe finally provide the convergence result for the asynchronous algorithm in the general case. The proof is complicated by the fact that set A, unlike in SVRG, changes during the epoch. The key idea is that only a single element of A changes at each iteration. Furthermore, it can only change to one of the iterates in the epoch. This control provides a handle on the error obtained due to the staleness. Due to space constraints, the proof is relegated to the appendix. Theorem 3. For any positive parameters c, \u03b2, \u03ba > 1, step size \u03b7 and epoch size m, we define the following quantities:\n\u03b6 = ( c\u03b72 + ( 1\u2212 1\n\u03ba\n)\u2212\u03c4 cL\u2206\u03c42\u03b73 ) ,\n\u03b3a = \u03ba\n[ 1\u2212 ( 1\u2212 1\n\u03ba\n)m][ 2c\u03b7 \u2212 8\u03b6L(1 + \u03b2)\u2212 2c\n\u03ba\u03bb \u2212 96\u03b6L\u03c4 n\n( 1\u2212 1\n\u03ba )\u2212\u03c4 \u2212 1 n ] ,\n\u03b8a = max   2c \u03b3a\u03bb ( 1\u2212 1 \u03ba )m + 8\u03b6L ( 1 + 1\u03b2 ) \u03b3a \u03ba [ 1\u2212 ( 1\u2212 1 \u03ba )m] ,(1\u2212 1 \u03ba )m ."}, {"heading": "Suppose probabilities pi \u221d (1\u2212 1\u03ba )", "text": "m\u2212i, parameters \u03b2, \u03ba, step-size \u03b7, and epoch size m are chosen such that the following conditions are satisfied:\n1 \u03ba + 8\u03b6L\n( 1 + 1\n\u03b2\n) + 96\u03b6L\u03c4\nn\n( 1\u2212 1\n\u03ba )\u2212\u03c4 \u2264 1 n , \u03b72 \u2264 ( 1\u2212 1 \u03ba )m\u22121 1 12L2\u2206\u03c42 , \u03b3a > 0, \u03b8a < 1.\nThen, for the iterates of asynchronous variant of Algorithm 1 with HSAG schedule we have E [ f(x\u0303k+1)\u2212 f(x\u2217) + 1\n\u03b3a G\u0303k+1\n] \u2264 \u03b8aE [ f(x\u0303k)\u2212 f(x\u2217) + 1\n\u03b3a G\u0303k\n] .\nCorollary 2. Note that G\u0303k \u2265 0 and therefore, under the conditions specified in Theorem 3 and \u03b8\u0304a = \u03b8a (1 + 1/\u03b3a) < 1, we have\nE [ f(x\u0303k)\u2212 f(x\u2217) ] \u2264 \u03b8\u0304ka [ f(x0)\u2212 f(x\u2217) ] .\nBy using step size normalized by \u22061/2\u03c4 (similar to Theorem 2) and parameters similar to the ones specified after Theorem 1 we can show speedups similar to the ones obtained in Theorem 2.\nBefore ending our discussion on the theoretical analysis, we would like to highlight an important point. Our emphasis throughout the paper was on generality. While Theorem 1 and Theorem 3 are presented here in full generality, one can obtain stronger results in specific cases. For example, in the case of SAGA, one can obtain per iteration convergence guarantees (see [5]) rather than those corresponding to per epoch presented in the paper. However, there is no qualitative difference in these guarantees accumulated over the epoch. Furthermore, in this case, our analysis for both synchronous and asynchronous cases can be easily modified to obtain convergence properties similar to the ones obtained in [5]."}, {"heading": "4 Experiments", "text": "We present our empirical results in this section. For our experiments, we study the problem of binary classification via l2-regularized logistic regression. More formally, we are interested in the following optimization problem:\nmin x\n1\nn n\u2211 i=1 ( log(1 + exp(yiz > i x)) + \u03bb\u2016x\u20162 ) , (4.1)\nwhere zi \u2208 Rd and yi is the corresponding label for each i \u2208 [n]. In all our experiments, we set \u03bb = 1/n. Note that such a choice leads to high condition number.\nSince we are interested in sparse datasets, simply taking fi(x) = log(1+exp(yiz>i x))+\u03bb\u2016x\u20162 is not efficient as it requires updating the whole vector x at each iteration. This is due to the regularization term in each of the fi\u2019s. Instead, similar to [20], we rewrite problem in (4.1) as follows:\nmin x\n1\nn n\u2211 i=1 log(1 + exp(yiz>i x)) + \u03bb \u2211 j\u2208nz(zi) \u2016xj\u20162 dj  , where nz(z) represents the non-zero components of vector z, and dj = \u2211 i 1(j \u2208 nz(zi)). While this leads to sparse gradients at each iteration, updates in SVRG are still dense due to the part of the update that contains \u2211 i\u2207fi(\u03b1i)/n. This problem can be circumvented by using a \u2018just-in-time\u2019\nupdate scheme similar to the one mentioned in [23]. First, recall that for SVRG, \u2211 i\u2207fi(\u03b1i)/n does not change during an epoch (see Figure 1). Therefore, during the (k + 1)st epoch we have the following relationship:\nxt = x\u0303k \u2212 \u03b7 t\u22121\u2211 j=km (fij (x j)\u2212 fij (x\u0303k)) \u2212 [\u03b7(t\u2212 km) n n\u2211 i=1 fi(x\u0303 k) ] .\nWe maintain each bracketed term separately. The updates to the first term in the above equation are sparse while those to the second term are just a simple scalar addition, since we already maintain the average gradient \u2211n i=1 fi(x\u0303 k)/n. When the gradient of fit at x t is needed, we only calculate components of xt required for fit by aggregating these two terms. Hence, each step of this update procedure can be implemented in a way that respects sparsity of the data.\nWe evaluate the following algorithms for our experiments:\n\u2022 Lock-Free SVRG: This is the lock-free asynchronous variant of Algorithm 1 using SVRG schedule; all threads can read and update the parameters with any synchronization. Parameter updates are performed through atomic compare-and-swap instruction facilitated by modern processors [20]. A constant step size that gives the best convergence is chosen for the dataset.\n\u2022 Locked SVRG: This is the locked version of the asynchronous variant of Algorithm 1 using SVRG schedule. In particular, we use a concurrent read exclusive write locking model, where all threads can read the parameters but only one threads can update the parameters at a given time. The step size is chosen similar to Lock-Free SVRG.\n\u2022 Lock-Free SGD: This is the lock-free asynchronous variant of the SGD algorithm (see [20]). We compare two different versions of this algorithm: (i) SGD with constant step size (referred to as CSGD). (ii) SGD with decaying step size \u03b70 \u221a \u03c30/(t+ \u03c30) (referred to as DSGD), where\nconstants \u03b70 and \u03c30 specify the scale and speed of decay. For each of these versions, step size is tuned for each dataset to give the best convergence progress.\nAll the algorithms were implemented in C++. The linear algebra operations are mainly performed using eigen32. We run our experiments on datasets from LIBSVM website3. Similar to [27], we normalize each example in the dataset so that \u2016zi\u20162 = 1 for all i \u2208 [n]. Such a normalization leads to an upper bound of 0.25 on the Lipschitz constant of the gradient of fi. The epoch size m is chosen as 2n (as recommended in [9]) in all our experiments. In the first experiment, we compare the speedup achieved by our asynchronous algorithm. To this end, for each dataset we first measure the time required for the algorithm to each an accuracy of 10\u221210 (i.e., f(x)\u2212 f(x\u2217) < 10\u221210). The speedup with P threads is defined as the ratio of the runtime with a single thread to the runtime with P threads. Results in Figure 3 show the speedup on various datasets. As seen in the figure, we achieve significant speedups for all the datasets. Not surprisingly, the speedup achieved by Lock-free SVRG is much higher than ones obtained by locking. Furthermore, the lowest speedup is achieved for rcv1 dataset. Similar speedup behavior was reported for this dataset in [20]. It should be noted that this dataset is not sparse and hence, is a bad case for the algorithm (similar to [20]).\nFor the second set of experiments we compare the performance of Lock-Free SVRG with stochastic gradient descent. In particular, we compare with the variants of stochastic gradient descent, DSGD and CSGD, described earlier in this section. It is well established that the performance of variance reduced stochastic methods is better than that of SGD. We would like to empirically verify that such benefits carry over to the asynchronous variants of these algorithms. Figure 4 shows the performance of Lock-Free SVRG, DSGD and CSGD. Since the computation complexity of each epoch of these algorithms is different, we directly plot the objective value versus the runtime for each of these algorithms. We use 10 cores for comparing the algorithms in this experiment. As seen in the figure, Lock-Free SVRG outperforms both DSGD and CSGD. The performance gains are qualitatively similar to those reported in [9] for the synchronous versions of these algorithms. It can also be seen that the DSGD, not surprisingly, outperforms CSGD in all the cases. In our experiments, we observed that Lock-Free SVRG, in comparison to SGD, is relatively much less sensitive to the step size and more robust to increasing threads."}, {"heading": "5 Discussion & Future Work", "text": "In this paper, we presented a unifying framework based on [5], that captures many popular variance reduction techniques for stochastic gradient descent. We use this framework to develop a simple hybrid variance reduction method. The primary purpose of the framework, however, was to provide a common platform to analyze various variance reduction techniques. To this end, we provided convergence analysis for the framework under certain conditions. More importantly, we propose an asynchronous algorithm for the framework with provable convergence guarantees. The key consequence of our approach is that we obtain asynchronous variants of several algorithms like SVRG,\n2http://eigen.tuxfamily.org/ 3http://www.csie.ntu.edu.tw/\u02dccjlin/libsvmtools/datasets/binary.html\nSAGA and S2GD. Our asynchronous algorithms exploits sparsity in the data to obtain near linear speedup in settings that are typically encountered in machine learning.\nFor future work, it would be interesting to perform an empirical comparison of various schedules. In particular, it would be worth exploring the space-time-accuracy tradeoffs of these schedules. We would also like to analyze the effect of these tradeoffs on the asynchronous variants."}, {"heading": "A Appendix", "text": "Notation: We use Df to denote the Bregman divergence (defined below) for function f .\nDf (x, y) = f(x)\u2212 f(y)\u2212 \u3008\u2207f(y), x\u2212 y\u3009.\nFor ease of exposition, we use E[X] to denote the expectation the random variable X with respect to indices {i1, . . . , it} when X depends on just these indices up to step t. This dependence will be clear from the context. We use 1 to denote the indicator function."}, {"heading": "Proof of Theorem 1", "text": "Proof. We expand function f as f(x) = g(x) + h(x) where g(x) = 1n \u2211 i\u2208S fi(x) and g(x) = 1 n \u2211 i/\u2208S fi(x). Let the present epoch be k + 1. We define the following:\nvt = 1\n\u03b7 (xt+1 \u2212 xt) = \u2212\n[ \u2207fit(xt)\u2212\u2207fit(\u03b1tit) + 1\nn \u2211 i fi(\u03b1 t i)\n]\nGt = 1\nn \u2211 i\u2208S ( fi(\u03b1 t i)\u2212 fi(x\u2217)\u2212 \u3008\u2207fi(x\u2217), \u03b1ti \u2212 x\u2217\u3009 ) Rt = E [ c\u2016xt \u2212 x\u2217\u20162 +Gt ] .\nWe first observe that E[vt] = \u2212\u2207f(xt). This follows from the unbiasedness of the gradient at each iteration. Using this observation, we have the following:\nE[Rt+1] = E[c\u2016xt+1 \u2212 x\u2217\u20162 +Gt+1] = E[c\u2016xt + \u03b7vt \u2212 x\u2217\u20162 +Gt+1] = cE [ \u2016xt \u2212 x\u2217\u20162 ] + c\u03b72E [ \u2016vt\u20162 ] + 2c\u03b7E [ \u3008xt \u2212 x\u2217, vt\u3009 ] + E[Gt+1]\n\u2264 cE [ \u2016xt \u2212 x\u2217\u20162 ] + c\u03b72E [ \u2016vt\u20162 ] \u2212 2c\u03b7E [ f(xt)\u2212 f(x\u2217) ] + E[Gt+1]. (A.1)\nThe last step follows from convexity of f and the unbiasedness of vt. We have the following relationship between Gt+1 and Gt.\nE[Gt+1] = (\n1\u2212 1 n\n) E [Gt] + 1\nn E\n[ 1\nn \u2211 i\u2208S ( fi(x\nt)\u2212 fi(x\u2217)\u2212 \u3008\u2207fi(x\u2217), xt \u2212 x\u2217\u3009 )]\n= ( 1\u2212 1\nn\n) E [Gt] + 1\nn E[Dg(xt, x\u2217)]. (A.2)\nThis follows from the definition of the schedule of HSAG for indices in S. Substituting the above relationship in Equation (A.1) we get the following.\nRt+1 \u2264 Rt + c\u03b72E [ \u2016vt\u20162 ] \u2212 2c\u03b7E [ f(xt)\u2212 f(x\u2217) ] \u2212 1 n E[Gt] + 1 n E[Dg(xt, x\u2217)]\n\u2264 (\n1\u2212 1 \u03ba\n) Rt + c\nk E[\u2016xt \u2212 x\u2217\u20162] + c\u03b72E\n[ \u2016vt\u20162 ] \u2212 2c\u03b7E [ f(xt)\u2212 f(x\u2217) ] + ( 1\n\u03ba \u2212 1 n\n) E[Gt] + 1\nn E[Dg(xt, x\u2217)]\n:= ( 1\u2212 1\n\u03ba\n) Rt + bt.\nWe describe the bounds for bt (defined below).\nbt = c \u03ba E[\u2016xt \u2212 x\u2217\u20162]\ufe38 \ufe37\ufe37 \ufe38\nT1\n+c\u03b72 E [ \u2016vt\u20162 ]\ufe38 \ufe37\ufe37 \ufe38 T2 \u22122c\u03b7E [ f(xt)\u2212 f(x\u2217) ] + ( 1\n\u03ba \u2212 1 n\n) E[Gt] + 1\nn E[Dg(xt, x\u2217)].\nThe terms T1 and T2 can be bounded in the following fashion:\nT1 = E[\u2016xt \u2212 x\u2217\u20162] \u2264 2\n\u03bb E[f(xt)\u2212 f(x\u2217)]\nT2 = E [ \u2016vt\u20162 ] \u2264 ( 1 + 1\n\u03b2\n) E [ \u2016\u2207fit(\u03b1tit)\u2212\u2207fit(x \u2217)\u20162 ] + (1 + \u03b2)E [ \u2016\u2207fit(xt)\u2212\u2207fit(x\u2217)\u20162 ] \u2264 2L\nn\n( 1 + 1\n\u03b2 ) E \u2211 i [ fi(\u03b1 t i)\u2212 f(x\u2217)\u2212 \u2329 \u2207fi(x\u2217), \u03b1ti \u2212 x\u2217 \u232a] + 2L\nn (1 + \u03b2)E \u2211 i [ fi(x t)\u2212 f(x\u2217) ]\n\u2264 2L ( 1 + 1\n\u03b2\n)[ Gt +Dh(x\u0303 k, x\u2217) ] + 2L(1 + \u03b2)E[f(xt)\u2212 f(x\u2217)].\nThe bound on T1 is due to strong convexity nature of function f . The first inequality and second inequalities on T2 directly follows from Lemma 3 of [5] and simple application of Lemma 1 respectively. The third inequality follows from the definition of Gt and the fact that \u03b1ti = x\u0303\nk for all i /\u2208 S and t \u2208 {km, . . . , km+m}. Substituting these bounds T1 and T2 in bt, we get\nbt \u2264 \u2212 [ 2c\u03b7 \u2212 2cL\u03b72(1 + \u03b2)\u2212 2c\n\u03ba\u03bb\n] E [ f(xt)\u2212 f(x\u2217) ] + ( 1\n\u03ba + 2cL\u03b72\n( 1 + 1\n\u03b2 ) \u2212 1 n ) E[Gt] + 1 n E[Dg(xt, x\u2217)]\n+ 2cL\u03b72 ( 1 + 1\n\u03b2\n)[ Dh(x\u0303 k, x\u2217) ]\n\u2264 \u2212 [ 2c\u03b7 \u2212 2cL\u03b72(1 + \u03b2)\u2212 1\nn \u2212 2c \u03ba\u03bb\n] E [ f(xt)\u2212 f(x\u2217) ] + ( 1\n\u03ba + 2cL\u03b72\n( 1 + 1\n\u03b2 ) \u2212 1 n ) E[Gt] + 2cL\u03b72 ( 1 + 1 \u03b2 )[ Dh(x\u0303 k, x\u2217) ]\n\u2264 \u2212 [ 2c\u03b7 \u2212 2cL\u03b72(1 + \u03b2)\u2212 1\nn \u2212 2c \u03ba\u03bb\n] E [ f(xt)\u2212 f(x\u2217) ] + 2cL\u03b72 ( 1 + 1\n\u03b2\n)[ Dh(x\u0303 k, x\u2217) ] .\n(A.3)\nThe second inequality follows from Lemma 2. In particular, we use the fact that f(x) \u2212 f(x\u2217) = Df (x, x\n\u2217) and Df (x, x\u2217) = Dg(x, x\u2217) + Dh(x, x\u2217) \u2265 Dg(x, x\u2217). The third inequality follows from the following for the choice of our parameters:\n1 \u03ba + 2Lc\u03b72\n( 1 + 1\n\u03b2 ) \u2264 1 n .\nApplying the recursive relationship on Rt+1 for m iterations, we get\nRkm+m \u2264 (\n1\u2212 1 \u03ba\n)m R\u0303k + m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j bk+j\nwhere\nR\u0303k = E [ c\u2016x\u0303k \u2212 x\u2217\u20162 + G\u0303k ] .\nSubstituting the bound on bt from Equation (A.3) in the above equation we get the following inequality:\nRkm+m \u2264 (\n1\u2212 1 \u03ba\n)m R\u0303k+\n+ m\u22121\u2211 j=0 ( 2c\u03b7(1\u2212 L\u03b7(1 + \u03b2))\u2212 1 n \u2212 2c \u03ba\u03bb )( 1\u2212 1 \u03ba )m\u22121\u2212j E [ f(xk+j)\u2212 f(x\u2217) ] +\nm\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j 2Lc\u03b72 ( 1 + 1 \u03b2 ) E [ h(x\u0303k)\u2212 h(x\u2217)\u2212 \u3008\u2207h(x\u2217), x\u0303k \u2212 x\u2217\u3009 ] .\nWe now use the fact that x\u0303k+1 is chosen randomly from {xkm, . . . , xkm+m\u22121} with probabilities proportional to {(1\u2212 1/\u03ba)m\u22121, . . . , 1} we have the following consequence of the above inequality.\nRkm+m + \u03ba\n[ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]( 2c\u03b7(1\u2212 L\u03b7(1 + \u03b2))\u2212 1\nn \u2212 2c \u03ba\u03bb\n) E [ f(x\u0303k+1)\u2212 f(x\u2217) ] \u2264 2c\n\u03bb\n( 1\u2212 1\n\u03ba\n)m E [ f(x\u0303k)\u2212 f(x\u2217) ] + ( 1\u2212 1\n\u03ba\n)m E [ G\u0303k ] + 2Lc\u03b72\u03ba [ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]( 1 + 1\n\u03b2\n) E [ Dh(x\u0303 k, x\u2217) ] .\nFor obtaining the above inequality, we used the strongly convex nature of function f . Again, using the Bregman divergence based inequality (see Lemma 2)\nf(x)\u2212 f(x\u2217) = Df (x, x\u2217) = Dg(x, x\u2217) +Dh(x, x\u2217) \u2265 Dh(x, x\u2217), we have the following inequality\nRkm+m + \u03ba\n[ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]( 2c\u03b7(1\u2212 L\u03b7(1 + \u03b2))\u2212 1\nn \u2212 2c \u03ba\u03bb\n) E [ f(x\u0303k+1)\u2212 f(x\u2217) ] \u2264 [ 2c\n\u03bb\n( 1\u2212 1\n\u03ba\n)m + 2Lc\u03b72\u03ba [ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]] [ f(x\u0303k)\u2212 f(x\u2217) ] + ( 1\u2212 1\n\u03ba\n)m E [ G\u0303k ] .\n(A.4)\nWe use the following notation:\n\u03b3 = \u03ba [ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]( 2c\u03b7(1\u2212 L\u03b7(1 + \u03b2))\u2212 1\nn \u2212 2c \u03ba\u03bb ) \u03b8 = max {[ 2c\n\u03b3\u03bb\n( 1\u2212 1\n\u03ba\n)m + 2Lc\u03b72\n\u03b3\n( 1 + 1\n\u03b2\n) \u03ba [ 1\u2212 ( 1\u2212 1\n\u03ba\n)m]] , ( 1\u2212 1\n\u03ba\n)m} .\nUsing the above notation, we have the following inequality from Equation (A.4). E [ f(x\u0303k+1)\u2212 f(x\u2217) + 1\n\u03b3 G\u0303k+1\n] \u2264 \u03b8 E [ f(x\u0303k)\u2212 f(x\u2217) + 1\n\u03b3 G\u0303k\n] ,\nwhere \u03b8 < 1 is a constant that depends on the parameters used in the algorithm."}, {"heading": "Proof of Theorem 2", "text": "Proof. Let the present epoch be k + 1. Recall that D(t) denotes the iterate used in the tth iteration of the algorithm. We define the following:\nut = \u2212 [ \u2207fit(xD(t))\u2212\u2207fit(x\u0303k) +\u2207f(x\u0303k) ] vt = \u2212 [ \u2207fit(xt)\u2212\u2207fit(x\u0303k) +\u2207f(x\u0303k) ] .\nWe have the following: E\u2016xt+1 \u2212 x\u2217\u20162 = E\u2016xt + \u03b7ut \u2212 x\u2217\u20162 = E [ \u2016xt \u2212 x\u2217\u20162 + \u03b72\u2016ut\u20162 + 2\u03b7\u3008xt \u2212 x\u2217, ut\u3009 ] . (A.5)\nWe first bound the last term of the above inequality. We expand the term in the following manner: E\u3008xt \u2212 x\u2217, ut\u3009 = E [ \u3008x\u2217 \u2212 xt,\u2207fit(xD(t))\u3009 ] = E [ \u3008x\u2217 \u2212 xD(t),\u2207fit(xD(t))\u3009\n] \ufe38 \ufe37\ufe37 \ufe38\nT3\n+ t\u22121\u2211 d=D(t) E [ \u3008xd \u2212 xd+1,\u2207fit(xd)\u3009 ] \ufe38 \ufe37\ufe37 \ufe38\nT4\n+ t\u22121\u2211 d=D(t) E [ \u3008xd \u2212 xd+1,\u2207fit(xD(t))\u2212\u2207fit(xd)\u3009 ] \ufe38 \ufe37\ufe37 \ufe38\nT5\n.\n(A.6) The first equality directly follows from the definition of ut and its property of unbiasedness. The second step follows from simple algebraic calculations. Terms T3 and T4 can be bounded in the following way:\nT3 \u2264 E[fit(x\u2217)\u2212 fit(xD(t))]. (A.7) This bound directly follows from convexity of function fit .\nT4 = t\u22121\u2211 d=D(t) E [ \u3008xd \u2212 xd+1,\u2207fit(xd)\u3009 ] \u2264\nt\u22121\u2211 d=D(t) E [ fit(x d)\u2212 fit(xd+1) + L 2 \u2016xd+1 \u2212 xd\u20162it ]\n\u2264 E [ fit(x D(t))\u2212 fit(xt) ] + L\u2206\n2 t\u22121\u2211 d=D(t) E [ \u2016xd+1 \u2212 xd\u20162 ] . (A.8)\nThe first inequality follows from lipschitz continuous nature of the gradient of function fit . The second inequality follows from the definition of \u2206. The last term T5 can be bounded in the following manner.\nT5 = E  t\u22121\u2211 d=D(t) \u3008xd \u2212 xd+1,\u2207fit(xD(t))\u2212\u2207fit(xd)\u3009  \u2264 E\n t\u22121\u2211 d=D(t) \u2016xd+1 \u2212 xd\u2016it\u2016\u2207fit(xD(t))\u2212\u2207fit(xd)\u2016  \u2264 E\n t\u22121\u2211 d=D(t) \u2016xd+1 \u2212 xd\u2016it d\u22121\u2211 j=D(t) \u2016\u2207fit(xj+1)\u2212\u2207fit(xj)\u2016  \u2264 E\n t\u22121\u2211 d=D(t) d\u22121\u2211 j=D(t) L 2 ( \u2016xd+1 \u2212 xd\u20162it + \u2016x j+1 \u2212 xj\u20162it )\n\u2264 L\u2206(\u03c4 \u2212 1) 2\nE t\u22121\u2211\nd=D(t)\n\u2016xd+1 \u2212 xd\u20162. (A.9)\nThe first inequality follows from Cauchy-Schwartz inequality. The second inequality follows from repeated application of triangle inequality. The third step is a simple application of AM-GM inequality and the fact that gradient of the function fit is lipschitz continuous. Finally, the last step can be obtained from the fact that the staleness in gradient is at most \u03c4 and the definition of \u2206.\nBy combining the bounds on T3, T4 and T5 in Equations (A.7), (A.8) and (A.9) respectively and substituting the sum in Equation (A.6), we get\nE\u3008xt \u2212 x\u2217, ut\u3009 \u2264 E f(x\u2217)\u2212 f(xt) + L\u2206\u03c4 2 t\u22121\u2211 d=D(t) \u2016xd+1 \u2212 xd\u20162  . (A.10)\nBy substituting the above inequality in Equation (A.5), we get\nE [ \u2016xt+1 \u2212 x\u2217\u20162 ] \u2264 E [ \u2016xt \u2212 x\u2217\u20162 + \u03b72\u2016ut\u20162 \u2212 2\u03b7(f(xt)\u2212 f(x\u2217)) + L\u2206\u03c4\u03b73\nt\u22121\u2211 d=D(t)\n\u2016ud\u20162 ] .\n(A.11) We next bound the term E[\u2016ut\u20162] in terms of E [ \u2016vt\u20162 ] in the following way:\nE [ \u2016ut\u20162 ] \u2264 2E [ \u2016ut \u2212 vt\u20162 + \u2016vt\u20162 ] \u2264 2E [ \u2016\u2207fit(xt)\u2212\u2207fit(xD(t))\u20162 ] + 2E\n\u2225\u2225vt\u20162] \u2264 2L2E [ \u2016xd+1 \u2212 xd\u20162it ] + 2E [ \u2016vt\u20162\n] \u2264 2L2\u03c4\nt\u22121\u2211 d=D(t) E [ \u2016xt \u2212 xD(t)\u20162it ] + 2E [ \u2016vt\u20162 ] \u2264 2L2\u2206\u03b72\u03c4\nt\u22121\u2211 d=D(t) E [ \u2016ud\u20162 ] + 2E [ \u2016vt\u20162 ] .\nThe first step follows from AM-GM inequality. The second inequality follows from the lipschitz continuous nature of the gradient. The third step follows from simple application of CauchySchwartz inequality. Adding the above inequalities from t = km to t = km+m\u2212 1, we get\nkm+m\u22121\u2211 t=km E [ \u2016ut\u20162 ] \u2264 km+m\u22121\u2211 t=km 2L2\u2206\u03b72\u03c4 t\u22121\u2211 d=D(t) E [ \u2016ud\u20162 ] + 2E [ \u2016vt\u20162 ] \u2264 2L2\u2206\u03b72\u03c42\nkm+m\u22121\u2211 t=km E [ \u2016ut\u20162 ] + 2 km+m\u22121\u2211 t=km E [ \u2016vt\u20162 ] .\nHere we again used the fact that the delay in the gradients is at most \u03c4 . From the above inequality, we get\nkm+m\u22121\u2211 t=km E [ \u2016ut\u20162 ] \u2264 2 (1\u2212 2L2\u2206\u03b72\u03c42) km+m\u22121\u2211 t=km E [ \u2016vt\u20162 ] . (A.12)\nAdding Equation (A.11) from t = km to t = km + m \u2212 1 and substituting Equation (A.12) in the resultant, we get E [ \u2016xkm+m \u2212 x\u2217\u20162 ] \u2264 E [ \u2016x\u0303k \u2212 x\u2217\u20162 + (\u03b72 + L\u2206\u03c42\u03b73)\nkm+m\u22121\u2211 t=km \u2016ut\u20162 \u2212 km+m\u22121\u2211 t=km 2\u03b7(f(xt)\u2212 f(x\u2217))\n]\n\u2264 E [ \u2016x\u0303k \u2212 x\u2217\u20162 + 2 ( \u03b72 + L\u2206\u03c42\u03b73\n1\u2212 2L2\u2206\u03b72\u03c42 ) km+m\u22121\u2211 t=km \u2016vt\u20162 \u2212 km+m\u22121\u2211 t=km 2\u03b7(f(xt)\u2212 f(x\u2217)) ] .\nThe first step follows from telescopy sum and the definition of x\u0303k. From Lemma 3 of [5] (also see [9]), we have E[\u2016vt\u20162] \u2264 4LE [ f(xt)\u2212 f(x\u2217) + f(x\u0303k)\u2212 f(x\u2217) ] .\nSubstituting this in the inequality above, we get the following bound:( 2\u03b7 \u2212 8L ( \u03b72 + L\u2206\u03c42\u03b73\n1\u2212 2L2\u2206\u03b72\u03c42\n)) mE[f(x\u0303k+1)\u2212 f(x\u2217)]\n\u2264 ( 2\n\u00b5 + 8L\n( \u03b72 + L\u2206\u03c42\u03b73\n1\u2212 2L2\u2206\u03b72\u03c42\n) m ) E[f(x\u0303k)\u2212 f(x\u2217)]."}, {"heading": "Proof of Theorem 3", "text": "Proof. Let the present epoch be k+1. For simplicity, we assume that the iterates x andA used in the each iteration are from the same time step (index) i.e., D(t) = D\u2032(t) for all t \u2208 T . Recall that D(t) and D\u2032(t) denote the index used in the tth iteration of the algorithm. Our analysis can be extended to the case ofD(t) 6= D\u2032(t) in a straightforward manner. We expand function f as f(x) = g(x)+h(x) where g(x) = 1n \u2211 i\u2208S fi(x) and g(x) = 1 n \u2211 i/\u2208S fi(x). We define the following:\nut = 1\n\u03b7 (xt+1 \u2212 xt) = \u2212\n[ \u2207fit(xD(t))\u2212\u2207fit(\u03b1 D(t) it ) + 1\nn \u2211 i fi(\u03b1 D(t) i )\n]\nvt = 1\n\u03b7 (xt+1 \u2212 xt) = \u2212\n[ \u2207fit(xt)\u2212\u2207fit(\u03b1tit) + 1\nn \u2211 i fi(\u03b1 t i)\n] .\nWe use the same Lyapunov function used in Theorem 1. We recall the following definitions:\nGt = 1\nn \u2211 i\u2208S ( fi(\u03b1 t i)\u2212 fi(x\u2217)\u2212 \u3008\u2207fi(x\u2217), \u03b1ti \u2212 x\u2217\u3009 ) Rt = E [ c\u2016xt \u2212 x\u2217\u20162 +Gt ] .\nUsing unbiasedness of the gradient we have E[ut] = \u2212\u2207f(xD(t)) and E[vt] = \u2212\u2207f(xt). Using this observation, we have the following:\ncE[\u2016xt+1 \u2212 x\u2217\u20162] = cE[\u2016xt + \u03b7ut \u2212 x\u2217\u20162] = cE [ \u2016xt \u2212 x\u2217\u20162 ] + c\u03b72 E [ \u2016ut\u20162 ]\ufe38 \ufe37\ufe37 \ufe38 T6 +2c\u03b7 E [ \u3008xt \u2212 x\u2217, ut\u3009 ]\ufe38 \ufe37\ufe37 \ufe38 T7 . (A.13)\nThe last step follows from convexity of f and the unbiasedness of vt. We further bound term T6 in the following manner:\nT6 = E [ \u2016ut\u20162 ] \u2264 2E [ \u2016ut \u2212 vt\u20162 ] + 2E[\u2016vt\u20162]. (A.14)\nThe first term can be bounded in the following manner: E [ \u2016ut \u2212 vt\u20162 ] \u2264 E [\u2225\u2225\u2225(\u2207fit(xt)\u2212\u2207fit(xD(t)))\u2212 (\u2207fit(\u03b1D(t)it )\u2212\u2207fit(\u03b1tit)) + 1\nn \u2211 i (\u2207fi(\u03b1ti)\u2212\u2207fi(\u03b1 D(t) i )) \u2225\u2225\u22252] \u2264 3E [\u2225\u2225\u2225\u2207fit(xt)\u2212\u2207fit(xD(t))\u2225\u2225\u22252]+ 3E [\u2225\u2225\u2225\u2207fit(\u03b1D(t)it )\u2212\u2207fit(\u03b1tit)\u2225\u2225\u22252]\n+ 3E \u2225\u2225\u2225\u2225\u2225 1n\u2211 i (\u2207fi(\u03b1ti)\u2212\u2207fi(\u03b1 D(t) i )) \u2225\u2225\u2225\u2225\u2225 2 \n\u2264 3E [\u2225\u2225\u2225\u2207fit(xt)\u2212\u2207fit(xD(t))\u2225\u2225\u22252]+ 3E [\u2225\u2225\u2225\u2207fit(\u03b1D(t)it )\u2212\u2207fit(\u03b1tit)\u2225\u2225\u22252]\n+ 3\nn \u2211 i E [\u2225\u2225\u2225\u2207fi(\u03b1ti)\u2212\u2207fi(\u03b1D(t)i )\u2225\u2225\u22252] . (A.15)\nThe second step follows from the inequality (a+ b+ c)2 \u2264 3(a2 + b2 + c2). The last step follows from simple application of Jensen\u2019s inequality. The first term can be bounded easily in the following manner:\nE [ \u2016\u2207fit(xt)\u2212\u2207fit(xD(t))\u20162 ] \u2264 L2\u03c4 t\u22121\u2211 d=D(t) E [ \u2016xd+1 \u2212 xd\u20162it ] \u2264 L2\u2206\u03b72\u03c4\nt\u22121\u2211 d=D(t) E [ \u2016ud\u20162 ] .\nThe second and third terms need more delicate analysis. The key insight for our analysis is that at most \u03c4 \u03b1i\u2019s differ from time step D(t) to t. This is due to the fact that the delay is bounded by \u03c4 and at most one \u03b1i changes at each iteration. Furthermore, whenever there is a change in \u03b1i, it changes to one of the iterates xj for some j = {t\u2212 \u03c4, . . . , t}. With this intuition we bound the second term in the following fashion.\nE [\u2225\u2225\u2225\u2207fit(\u03b1D(t)i )\u2212\u2207fit(\u03b1tit)\u2225\u2225\u22252] \u2264 1n t\u22121\u2211 j=D(t) \u2211 i\u2208S E [ 1(i = ij) \u2225\u2225\u2225\u2207fi(xj)\u2212\u2207fi(\u03b1D(t)i )\u2225\u2225\u22252]\n\u2264 2 n t\u22121\u2211 j=D(t) \u2211 i\u2208S E [ 1(i = ij) (\u2225\u2225\u2207fi(xj)\u2212\u2207fi(x\u2217)\u2225\u22252 + \u2225\u2225\u2225\u2207fi(\u03b1D(t)i )\u2212\u2207fi(x\u2217)\u2225\u2225\u22252)]\n\u2264 2 n2 t\u22121\u2211 j=D(t) \u2211 i\u2208S E [\u2225\u2225\u2207fi(xj)\u2212\u2207fi(x\u2217)\u2225\u22252]+ 2 n2 t\u22121\u2211 j=D(t) \u2211 i\u2208S E [\u2225\u2225\u2225\u2207fi(\u03b1D(t)i )\u2212\u2207fi(x\u2217)\u2225\u2225\u22252]\n\u2264 4L n t\u22121\u2211 j=D(t) E\n[ 1\nn \u2211 i\u2208S fi(x j)\u2212 fi(x\u2217)\u2212 \u3008\u2207fi(x\u2217), xj \u2212 x\u2217\u3009)\n]\n+ 4L\u03c4\nn E\n[ 1\nn \u2211 i\u2208S fi(\u03b1 D(t) i )\u2212 fi(x \u2217)\u2212 \u3008\u2207fi(x\u2217), \u03b1D(t)i \u2212 x \u2217\u3009\n] .\nThe second inequality follows from the fact that \u2016a + b\u20162 \u2264 2\u2016a\u20162 + 2\u2016b\u20162. The last step directly follows from Lemma 1. Note that sum is over indices in S since \u03b1i\u2019s for i /\u2208 S do not change during the epoch.\nThe third term in Equation A.15 can be bounded by exactly the same technique we used for the second term. The bound, in fact, turns out to identical to second term since it is chosen uniformly random. Combining all the terms we have\nT6 \u2264 2E[\u2016vt\u20162] + 6L2\u2206\u03b72\u03c4 t\u22121\u2211\nd=D(t)\nE [ \u2016ud\u20162 ] + 48L\nn t\u22121\u2211 j=D(t) E [ Dg(x j , x\u2217) ] + 48L\u03c4 n E [ GD(t) ] .\nThe term T7 can be bounded in a manner similar to one in Theorem 2 to obtain the following (see proof of Theorem 2 for details):\nE\u3008xt \u2212 x\u2217, ut\u3009 \u2264 E f(x\u2217)\u2212 f(xt) + L\u2206\u03c4\u03b72 2 t\u22121\u2211 d=D(t) \u2016ud\u20162  . (A.16)\nWe need the following bound for our analysis: m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E[\u2016ukm+j\u20162] \u2264 2 m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E[\u2016vkm+j\u20162]\n+ km+m\u22121\u2211 t=km 6L2\u2206\u03b72\u03c4 t\u22121\u2211 d=D(t) E [ \u2016ud\u20162 ] +\nkm+m\u22121\u2211 t=km 48L n t\u22121\u2211 j=D(t) E [ Dg(x j , x\u2217) ]\n+ km+m\u22121\u2211 t=km 48L\u03c4 n E [ GD(t) ] .\nThe above inequality follows directly from the bound on T6. Under the condition \u03b72 \u2264 (\n1\u2212 1 \u03ba\n)m\u22121 1\n12L2\u2206\u03c42 .\nwe have the following inequality m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E[\u2016ukm+j\u20162] \u2264 4 m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E[\u2016vkm+j\u20162]\n+ km+m\u22121\u2211 t=km 96L n t\u22121\u2211 j=D(t) E [ Dg(x j , x\u2217) ]\n+ km+m\u22121\u2211 t=km 96L\u03c4 n E [ GD(t) ] . (A.17)\nThis follows from that fact that km+m\u22121\u2211 t=km 6L2\u2206\u03b72\u03c4 t\u22121\u2211 d=D(t) E [ \u2016ud\u20162 ] \u2264 1 2 m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E[\u2016ukm+j\u20162].\nunder the condition mentioned above. We have the following: Rt+1 = cE [ \u2016xt \u2212 x\u2217\u20162 ] + c\u03b72E [ \u2016ut\u20162 ] + 2c\u03b7E [ \u3008xt \u2212 x\u2217, ut\u3009 ] + E [Gt+1]\n:= ( 1\u2212 1\n\u03ba\n) Rt + et. (A.18)\nWe bound et in the following manner:\net = c \u03ba \u2016xt \u2212 x\u2217\u20162 + 1 \u03ba E[Gt] + c\u03b72E\n[ \u2016ut\u20162 ] + 2c\u03b7E [ \u3008xt \u2212 x\u2217, ut\u3009 ] + E [Gt+1]\n= c\n\u03ba \u2016xt \u2212 x\u2217\u20162 +\n( 1\n\u03ba \u2212 1 n\n) E[Gt] + c\u03b72E [ \u2016ut\u20162 ] + 2c\u03b7E [ \u3008xt \u2212 x\u2217, ut\u3009 ] + 1\nn E[Dg(xt, x\u2217)]\n\u2264 \u2212 (\n2c\u03b7 \u2212 2c \u03ba\u03bb\n) E [ f(xt)\u2212 f(x\u2217) ] + ( 1\n\u03ba \u2212 1 n\n) E[Gt] + c\u03b72E[\u2016ut\u20162]\n+ cL\u2206\u03c4\u03b73 t\u22121\u2211\nd=D(t)\nE [ \u2016ud\u20162 ] + 1\nn E[Dg(xt, x\u2217)].\nThe second equality follows from the definition of Gt+1 (see Equation (A.2)). E[Gt+1] = (\n1\u2212 1 n\n) E [Gt] + 1\nn E[Dg(xt, x\u2217)].\nApplying the recurrence relationship in Equation (A.18) with the derived bound on et, we have Rkm+m \u2264 (\n1\u2212 1 \u03ba\n)m R\u0303k + m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j ekm+j\n\u2264 (\n1\u2212 1 \u03ba\n)m R\u0303k + m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j ekm+j\n\u2264 (\n1\u2212 1 \u03ba\n)m R\u0303k + m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j e\u2032km+j ,\nwhere e\u2032t is defined as follows R\u0303k = E [ c\u2016x\u0303k \u2212 x\u2217\u20162 + G\u0303k ] e\u2032t = \u2212 ( 2c\u03b7 \u2212 2c\n\u03ba\u03bb\n) E [ f(xt)\u2212 f(x\u2217) ] + ( 1\n\u03ba \u2212 1 n\n) E[Gt]\n+ ( c\u03b72 + ( 1\u2212 1\n\u03ba\n)\u2212\u03c4 cL\u2206\u03c42\u03b73 ) E[\u2016ut\u20162] + 1\nn E[Dg(xt, x\u2217)].\nWe use the following notation for ease of exposition:\n\u03b6 = ( c\u03b72 + ( 1\u2212 1\n\u03ba\n)\u2212\u03c4 cL\u2206\u03c42\u03b73 ) .\nThis last inequality follows from that fact that the delay is at most \u03c4 . In particular, each index j \u2208 {D(t) . . . , t} for at most \u03c4 times. Substituting the bound in Equation (A.17), we get the following:\nRkm+m \u2264 (\n1\u2212 1 \u03ba\n)m R\u0303k \u2212 ( 2c\u03b7 \u2212 2c\n\u03ba\u03bb )m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E [ f(xkm+j)\u2212 f(x\u2217) ] + 4\u03b6\nm\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E[\u2016vkm+j\u20162]\n+\n[ 96\u03b6L\u03c4\nn\n( 1\u2212 1\n\u03ba\n)\u2212\u03c4 + 1\nn ] m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E [ Dg(x km+j , x\u2217) ]\n+\n[ 1\n\u03ba +\n96\u03b6L\u03c4\nn\n( 1\u2212 1\n\u03ba )\u2212\u03c4 \u2212 1 n ] m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E [ GD(km+j) ] . (A.19)\nWe now use the following previously used bound on vt (see bound T2 in the proof of Theorem 1). E[\u2016vt\u20162] \u2264 2L ( 1 + 1\n\u03b2\n)[ Gt +Dh(x\u0303 k, x\u2217) ] + 2L(1 + \u03b2)E[f(xt)\u2212 f(x\u2217)].\nSubstituting the above bound on vt in Equation (A.19), we get the following: Rkm+m \u2264 (\n1\u2212 1 \u03ba\n)m R\u0303k\n\u2212 [ 2c\u03b7 \u2212 8\u03b6L(1 + \u03b2)\u2212 2c\n\u03ba\u03bb \u2212 96\u03b6L\u03c4 n\n( 1\u2212 1\n\u03ba )\u2212\u03c4 \u2212 1 n ] \u00d7\nm\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E [ f(xkm+j)\u2212 f(x\u2217) ] + [ 1\n\u03ba + 8\u03b6L\n( 1 + 1\n\u03b2\n) + 96\u03b6L\u03c4\nn\n( 1\u2212 1\n\u03ba )\u2212\u03c4 \u2212 1 n ] \u00d7\nm\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E [ GD(km+j) ] + 8\u03b6L ( 1 + 1\n\u03b2 )m\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E [ Dh(x\u0303 k, x\u2217) ]\n\u2264 2c \u03bb\n( 1\u2212 1\n\u03ba\n)m E [ f(x\u0303k)\u2212 f(x\u2217) ] + ( 1\u2212 1\n\u03ba\n)m E [ G\u0303k ] \u2212 [ 2c\u03b7 \u2212 8\u03b6L(1 + \u03b2)\u2212 2c\n\u03ba\u03bb \u2212 96\u03b6L\u03c4 n\n( 1\u2212 1\n\u03ba )\u2212\u03c4 \u2212 1 n ] \u00d7\nm\u22121\u2211 j=0 ( 1\u2212 1 \u03ba )m\u22121\u2212j E [ f(xkm+j)\u2212 f(x\u2217) ] + 8\u03b6L ( 1 + 1\n\u03b2\n) \u03ba [ 1\u2212 ( 1\u2212 1\n\u03ba\n)m] E [ Dh(x\u0303 k, x\u2217) ] . (A.20)\nThe first step is due to the Bregman divergence based inequality Df (x, x\u2217) \u2265 Dg(x, x\u2217). The second step follows from the expanding R\u0303k and using the strong convexity of function f . We now use the fact that x\u0303k+1 is chosen randomly from {xkm, . . . , xkm+m\u22121} with probabilities proportional to {(1 \u2212 1/\u03ba)m\u22121, . . . , 1} we have the following consequence of the above inequality. We use the following notation:\n\u03b3a = \u03ba\n[ 1\u2212 ( 1\u2212 1\n\u03ba\n)m][ 2c\u03b7 \u2212 8\u03b6L(1 + \u03b2)\u2212 2c\n\u03ba\u03bb \u2212 96\u03b6L\u03c4 n\n( 1\u2212 1\n\u03ba )\u2212\u03c4 \u2212 1 n ]\n\u03b8a = max   2c \u03b3a\u03bb ( 1\u2212 1 \u03ba )m + 8\u03b6L ( 1 + 1\u03b2 ) \u03b3a \u03ba [ 1\u2212 ( 1\u2212 1 \u03ba )m] ,(1\u2212 1 \u03ba )m . Using the above notation, we have the following inequality from Equation (A.4).\nE [ f(x\u0303k+1)\u2212 f(x\u2217) + 1\n\u03b3a G\u0303k+1\n] \u2264 \u03b8a E [ f(x\u0303k)\u2212 f(x\u2217) + 1\n\u03b3a G\u0303k\n] .\nwhere \u03b8 < 1 is a constant that depends on the parameters used in the algorithm."}, {"heading": "Other Lemmatta", "text": "Lemma 1. [9] For any \u03b1i \u2208 Rd where i \u2208 [n] and x\u2217, we have\nE [ \u2016\u2207fit(\u03b1it)\u2212\u2207fit(x\u2217)\u20162 ] \u2264 2L\nn \u2211 i [fi(\u03b1i)\u2212 f(x\u2217)\u2212 \u3008\u2207fi(x\u2217), \u03b1i \u2212 x\u2217\u3009] .\nLemma 2. Suppose f : Rd \u2192 R and f = g+ h where f, g and h are convex and differentiable. x\u2217 is the optimal solution to arg minx f(x) then we have the following\nDf (x, x \u2217) = f(x)\u2212 f(x\u2217) Df (x, x \u2217) = Dg(x, x \u2217) +Dh(x, x \u2217) Df (x, x \u2217) \u2265 Dg(x, x\u2217).\nProof. The proof follows trivially from the fact that x\u2217 is the optimal solution and linearity and non-negative properties of Bregman divergence."}], "references": [{"title": "A lower bound for the optimization of finite sums", "author": ["Alekh Agarwal", "Leon Bottou"], "venue": null, "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2014}, {"title": "Distributed delayed stochastic optimization", "author": ["Alekh Agarwal", "John C Duchi"], "venue": "In Advances in Neural Information Processing Systems,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2011}, {"title": "Incremental gradient, subgradient, and proximal methods for convex optimization: A survey", "author": ["Dimitri P Bertsekas"], "venue": "Optimization for Machine Learning,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2011}, {"title": "New Optimization Methods for Machine Learning", "author": ["Aaron Defazio"], "venue": "PhD thesis, Australian National University,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "SAGA: A fast incremental gradient method with support for non-strongly convex composite objectives", "author": ["Aaron Defazio", "Francis Bach", "Simon Lacoste-Julien"], "venue": "In NIPS", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2014}, {"title": "Finito: A faster, permutable incremental gradient method for big data problems", "author": ["Aaron J Defazio", "Tib\u00e9rio S Caetano", "Justin Domke"], "venue": null, "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2014}, {"title": "Optimal distributed online prediction using mini-batches", "author": ["Ofer Dekel", "Ran Gilad-Bachrach", "Ohad Shamir", "Lin Xiao"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2012}, {"title": "A globally convergent incremental Newton method", "author": ["M. G\u00fcrb\u00fczbalaban", "A. Ozdaglar", "P. Parrilo"], "venue": "Mathematical Programming,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2015}, {"title": "Accelerating stochastic gradient descent using predictive variance reduction", "author": ["Rie Johnson", "Tong Zhang"], "venue": "In NIPS", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2013}, {"title": "Mini-Batch Semi-Stochastic Gradient Descent in the Proximal Setting", "author": ["Jakub Kone\u010dn\u00fd", "Jie Liu", "Peter Richt\u00e1rik", "Martin Tak\u00e1\u010d"], "venue": null, "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2015}, {"title": "Communication Efficient Distributed Machine Learning with the Parameter Server", "author": ["Mu Li", "David G Andersen", "Alex J Smola", "Kai Yu"], "venue": "In NIPS", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2014}, {"title": "Asynchronous stochastic coordinate descent: Parallelism and convergence properties", "author": ["Ji Liu", "Stephen J. Wright"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2015}, {"title": "An asynchronous parallel stochastic coordinate descent algorithm", "author": ["Ji Liu", "Steve Wright", "Christopher R\u00e9", "Victor Bittorf", "Srikrishna Sridhar"], "venue": "ICML", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2014}, {"title": "Optimization with first-order surrogate functions", "author": ["Julien Mairal"], "venue": null, "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2013}, {"title": "Distributed asynchronous incremental subgradient methods", "author": ["A Nedi\u0107", "Dimitri P Bertsekas", "Vivek S Borkar"], "venue": "Studies in Computational Mathematics,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2001}, {"title": "Robust stochastic approximation approach to stochastic programming", "author": ["A. Nemirovski", "A. Juditsky", "G. Lan", "A. Shapiro"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2009}, {"title": "Efficiency of coordinate descent methods on huge-scale optimization problems", "author": ["Yu Nesterov"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2012}, {"title": "Stochastic Proximal Gradient Descent with Acceleration Techniques", "author": ["Atsushi Nitanda"], "venue": "In NIPS", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2014}, {"title": "Hogwild!: A Lock-Free Approach to Parallelizing Stochastic Gradient Descent", "author": ["Benjamin Recht", "Christopher Re", "Stephen Wright", "Feng Niu"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2011}, {"title": "Iteration complexity of randomized block-coordinate descent methods for minimizing a composite function", "author": ["Peter Richt\u00e1rik", "Martin Tak\u00e1\u010d"], "venue": "Mathematical Programming,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2014}, {"title": "A stochastic approximation method", "author": ["H. Robbins", "S. Monro"], "venue": "Annals of Mathematical Statistics,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1951}, {"title": "Minimizing Finite Sums with the Stochastic Average Gradient", "author": ["Mark W. Schmidt", "Nicolas Le Roux", "Francis R. Bach"], "venue": null, "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2013}, {"title": "Accelerated mini-batch stochastic dual coordinate ascent", "author": ["Shai Shalev-Shwartz", "Tong Zhang"], "venue": "In NIPS", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2013}, {"title": "Stochastic dual coordinate ascent methods for regularized loss", "author": ["Shai Shalev-Shwartz", "Tong Zhang"], "venue": "The Journal of Machine Learning Research,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2013}, {"title": "On distributed stochastic optimization and learning", "author": ["Ohad Shamir", "Nathan Srebro"], "venue": "In Proceedings of the 52nd Annual Allerton Conference on Communication, Control, and Computing,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2014}, {"title": "A proximal stochastic gradient method with progressive variance reduction", "author": ["Lin Xiao", "Tong Zhang"], "venue": "SIAM Journal on Optimization,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2014}], "referenceMentions": [{"referenceID": 4, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 5, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 7, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 8, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 9, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 21, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 23, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 25, "context": "There has been a steep rise in recent work [5, 6, 8\u201311, 23, 25, 27] on \u201cvariance reduced\u201d stochastic gradient algorithms for convex problems of the finite-sum form:", "startOffset": 43, "endOffset": 67}, {"referenceID": 15, "context": "Under strong convexity assumptions such variance reduced (VR) stochastic algorithms attain better convergence rates (in expectation) than stochastic gradient descent (SGD) [17, 22], both in theory and practice.", "startOffset": 172, "endOffset": 180}, {"referenceID": 20, "context": "Under strong convexity assumptions such variance reduced (VR) stochastic algorithms attain better convergence rates (in expectation) than stochastic gradient descent (SGD) [17, 22], both in theory and practice.", "startOffset": 172, "endOffset": 180}, {"referenceID": 1, "context": "And in this setting, asynchronous variants of SGD remain indispensable [2, 7, 12, 20, 26, 28].", "startOffset": 71, "endOffset": 93}, {"referenceID": 6, "context": "And in this setting, asynchronous variants of SGD remain indispensable [2, 7, 12, 20, 26, 28].", "startOffset": 71, "endOffset": 93}, {"referenceID": 10, "context": "And in this setting, asynchronous variants of SGD remain indispensable [2, 7, 12, 20, 26, 28].", "startOffset": 71, "endOffset": 93}, {"referenceID": 18, "context": "And in this setting, asynchronous variants of SGD remain indispensable [2, 7, 12, 20, 26, 28].", "startOffset": 71, "endOffset": 93}, {"referenceID": 24, "context": "And in this setting, asynchronous variants of SGD remain indispensable [2, 7, 12, 20, 26, 28].", "startOffset": 71, "endOffset": 93}, {"referenceID": 8, "context": "Our methods are inspired by the influential SVRG [9], S2GD [11], SAG [23] and SAGA [5] family of algorithms.", "startOffset": 49, "endOffset": 52}, {"referenceID": 21, "context": "Our methods are inspired by the influential SVRG [9], S2GD [11], SAG [23] and SAGA [5] family of algorithms.", "startOffset": 69, "endOffset": 73}, {"referenceID": 4, "context": "Our methods are inspired by the influential SVRG [9], S2GD [11], SAG [23] and SAGA [5] family of algorithms.", "startOffset": 83, "endOffset": 86}, {"referenceID": 4, "context": "Our paper has two core components: (i) a formal general framework for variance reduced stochastic methods based on discussions in [5]; and (ii) asynchronous parallel VR algorithms within the framework.", "startOffset": 130, "endOffset": 133}, {"referenceID": 21, "context": "As already mentioned, our work is closest to (and generalizes) SAG [23], SAGA [5], SVRG [9] and S2GD [11], which are primal methods.", "startOffset": 67, "endOffset": 71}, {"referenceID": 4, "context": "As already mentioned, our work is closest to (and generalizes) SAG [23], SAGA [5], SVRG [9] and S2GD [11], which are primal methods.", "startOffset": 78, "endOffset": 81}, {"referenceID": 8, "context": "As already mentioned, our work is closest to (and generalizes) SAG [23], SAGA [5], SVRG [9] and S2GD [11], which are primal methods.", "startOffset": 88, "endOffset": 91}, {"referenceID": 23, "context": "Also closely related are dual methods such as SDCA [25] and Finito [6], and in its convex incarnation MISO [15]; a more precise relation between these dual methods and VR stochastic methods is described in Defazio\u2019s thesis [4].", "startOffset": 51, "endOffset": 55}, {"referenceID": 5, "context": "Also closely related are dual methods such as SDCA [25] and Finito [6], and in its convex incarnation MISO [15]; a more precise relation between these dual methods and VR stochastic methods is described in Defazio\u2019s thesis [4].", "startOffset": 67, "endOffset": 70}, {"referenceID": 13, "context": "Also closely related are dual methods such as SDCA [25] and Finito [6], and in its convex incarnation MISO [15]; a more precise relation between these dual methods and VR stochastic methods is described in Defazio\u2019s thesis [4].", "startOffset": 107, "endOffset": 111}, {"referenceID": 3, "context": "Also closely related are dual methods such as SDCA [25] and Finito [6], and in its convex incarnation MISO [15]; a more precise relation between these dual methods and VR stochastic methods is described in Defazio\u2019s thesis [4].", "startOffset": 223, "endOffset": 226}, {"referenceID": 2, "context": "By their algorithmic structure, these VR methods trace back to classical non-stochastic incremental gradient algorithms [3], but by now it is well-recognized that randomization helps obtain much sharper convergence results (in expectation).", "startOffset": 120, "endOffset": 123}, {"referenceID": 25, "context": "Proximal [27] and accelerated VR methods have also been proposed [19, 24]; we leave a study of such variants of our framework as future work.", "startOffset": 9, "endOffset": 13}, {"referenceID": 17, "context": "Proximal [27] and accelerated VR methods have also been proposed [19, 24]; we leave a study of such variants of our framework as future work.", "startOffset": 65, "endOffset": 73}, {"referenceID": 22, "context": "Proximal [27] and accelerated VR methods have also been proposed [19, 24]; we leave a study of such variants of our framework as future work.", "startOffset": 65, "endOffset": 73}, {"referenceID": 0, "context": "Finally, there is recent work on lower-bounds for finite-sum problems [1].", "startOffset": 70, "endOffset": 73}, {"referenceID": 18, "context": "Within asynchronous SGD algorithms, both parallel [20] and distributed [2, 16] variants are known.", "startOffset": 50, "endOffset": 54}, {"referenceID": 1, "context": "Within asynchronous SGD algorithms, both parallel [20] and distributed [2, 16] variants are known.", "startOffset": 71, "endOffset": 78}, {"referenceID": 14, "context": "Within asynchronous SGD algorithms, both parallel [20] and distributed [2, 16] variants are known.", "startOffset": 71, "endOffset": 78}, {"referenceID": 11, "context": "A different line of methods is that of (primal) coordinate descent methods, and their parallel and distributed variants [13, 14, 18, 21].", "startOffset": 120, "endOffset": 136}, {"referenceID": 12, "context": "A different line of methods is that of (primal) coordinate descent methods, and their parallel and distributed variants [13, 14, 18, 21].", "startOffset": 120, "endOffset": 136}, {"referenceID": 16, "context": "A different line of methods is that of (primal) coordinate descent methods, and their parallel and distributed variants [13, 14, 18, 21].", "startOffset": 120, "endOffset": 136}, {"referenceID": 19, "context": "A different line of methods is that of (primal) coordinate descent methods, and their parallel and distributed variants [13, 14, 18, 21].", "startOffset": 120, "endOffset": 136}, {"referenceID": 9, "context": "Finally, the recent work [10] generalizes S2GD to the mini-batch setting, thereby also permitting parallel processing, albeit with more synchronization and allowing only small mini-batches.", "startOffset": 25, "endOffset": 29}, {"referenceID": 25, "context": "1) While our analysis focuses on strongly convex functions, we can extend it to just smooth convex functions along the lines of [27].", "startOffset": 128, "endOffset": 132}, {"referenceID": 4, "context": "Inspired by the discussion on a general view of variance reduced techniques in [5], we now describe a formal general framework for variance reduction in stochastic gradient descent.", "startOffset": 79, "endOffset": 82}, {"referenceID": 21, "context": "In particular, we consider incremental methods SAG [23], SVRG [9] and SAGA [5], and classic gradient descent GRADIENTDESCENT for demonstrating our framework.", "startOffset": 51, "endOffset": 55}, {"referenceID": 8, "context": "In particular, we consider incremental methods SAG [23], SVRG [9] and SAGA [5], and classic gradient descent GRADIENTDESCENT for demonstrating our framework.", "startOffset": 62, "endOffset": 65}, {"referenceID": 4, "context": "In particular, we consider incremental methods SAG [23], SVRG [9] and SAGA [5], and classic gradient descent GRADIENTDESCENT for demonstrating our framework.", "startOffset": 75, "endOffset": 78}, {"referenceID": 8, "context": "In case of SVRG, SCHEDULEUPDATE is triggered every m iterations (here m denotes precisely the number of inner iterations used in [9]); so A remains unchanged for the m iterations and all \u03b1 i are updated to the current iterate at the mth iteration.", "startOffset": 129, "endOffset": 132}, {"referenceID": 8, "context": "Similar to [9] (see Option II of SVRG in [9]), our analysis will be for the case where the iterate at the end of (k + 1)st epoch, x, is replaced with an element chosen randomly from {x, .", "startOffset": 11, "endOffset": 14}, {"referenceID": 8, "context": "Similar to [9] (see Option II of SVRG in [9]), our analysis will be for the case where the iterate at the end of (k + 1)st epoch, x, is replaced with an element chosen randomly from {x, .", "startOffset": 41, "endOffset": 44}, {"referenceID": 4, "context": "5) with m = O(n) epoch size (similar to [5, 9]).", "startOffset": 40, "endOffset": 46}, {"referenceID": 8, "context": "5) with m = O(n) epoch size (similar to [5, 9]).", "startOffset": 40, "endOffset": 46}, {"referenceID": 18, "context": "Our model of computation is similar to the ones used in Hogwild! [20] and AsySCD [14].", "startOffset": 65, "endOffset": 69}, {"referenceID": 12, "context": "Our model of computation is similar to the ones used in Hogwild! [20] and AsySCD [14].", "startOffset": 81, "endOffset": 85}, {"referenceID": 12, "context": ", [14, 20]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 18, "context": ", [14, 20]).", "startOffset": 2, "endOffset": 10}, {"referenceID": 18, "context": "1 Convergence Analysis The key ingredients to the success of asynchronous algorithms for multicore stochastic gradient descent are sparsity and \u201cdisjointness\u201d of the data matrix [20].", "startOffset": 178, "endOffset": 182}, {"referenceID": 4, "context": "For example, in the case of SAGA, one can obtain per iteration convergence guarantees (see [5]) rather than those corresponding to per epoch presented in the paper.", "startOffset": 91, "endOffset": 94}, {"referenceID": 4, "context": "Furthermore, in this case, our analysis for both synchronous and asynchronous cases can be easily modified to obtain convergence properties similar to the ones obtained in [5].", "startOffset": 172, "endOffset": 175}, {"referenceID": 18, "context": "Instead, similar to [20], we rewrite problem in (4.", "startOffset": 20, "endOffset": 24}, {"referenceID": 21, "context": "This problem can be circumvented by using a \u2018just-in-time\u2019 update scheme similar to the one mentioned in [23].", "startOffset": 105, "endOffset": 109}, {"referenceID": 18, "context": "Parameter updates are performed through atomic compare-and-swap instruction facilitated by modern processors [20].", "startOffset": 109, "endOffset": 113}, {"referenceID": 18, "context": "\u2022 Lock-Free SGD: This is the lock-free asynchronous variant of the SGD algorithm (see [20]).", "startOffset": 86, "endOffset": 90}, {"referenceID": 25, "context": "Similar to [27], we normalize each example in the dataset so that \u2016zi\u20162 = 1 for all i \u2208 [n].", "startOffset": 11, "endOffset": 15}, {"referenceID": 8, "context": "The epoch size m is chosen as 2n (as recommended in [9]) in all our experiments.", "startOffset": 52, "endOffset": 55}, {"referenceID": 18, "context": "Similar speedup behavior was reported for this dataset in [20].", "startOffset": 58, "endOffset": 62}, {"referenceID": 18, "context": "It should be noted that this dataset is not sparse and hence, is a bad case for the algorithm (similar to [20]).", "startOffset": 106, "endOffset": 110}, {"referenceID": 8, "context": "The performance gains are qualitatively similar to those reported in [9] for the synchronous versions of these algorithms.", "startOffset": 69, "endOffset": 72}, {"referenceID": 4, "context": "In this paper, we presented a unifying framework based on [5], that captures many popular variance reduction techniques for stochastic gradient descent.", "startOffset": 58, "endOffset": 61}, {"referenceID": 0, "context": "Bibliography [1] Alekh Agarwal and Leon Bottou.", "startOffset": 13, "endOffset": 16}, {"referenceID": 1, "context": "[2] Alekh Agarwal and John C Duchi.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] Dimitri P Bertsekas.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "[4] Aaron Defazio.", "startOffset": 0, "endOffset": 3}, {"referenceID": 4, "context": "[5] Aaron Defazio, Francis Bach, and Simon Lacoste-Julien.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6] Aaron J Defazio, Tib\u00e9rio S Caetano, and Justin Domke.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[7] Ofer Dekel, Ran Gilad-Bachrach, Ohad Shamir, and Lin Xiao.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8] M.", "startOffset": 0, "endOffset": 3}, {"referenceID": 8, "context": "[9] Rie Johnson and Tong Zhang.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "[10] Jakub Kone\u010dn\u00fd, Jie Liu, Peter Richt\u00e1rik, and Martin Tak\u00e1\u010d.", "startOffset": 0, "endOffset": 4}, {"referenceID": 10, "context": "[12] Mu Li, David G Andersen, Alex J Smola, and Kai Yu.", "startOffset": 0, "endOffset": 4}, {"referenceID": 11, "context": "[13] Ji Liu and Stephen J.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "[14] Ji Liu, Steve Wright, Christopher R\u00e9, Victor Bittorf, and Srikrishna Sridhar.", "startOffset": 0, "endOffset": 4}, {"referenceID": 13, "context": "[15] Julien Mairal.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "[16] A Nedi\u0107, Dimitri P Bertsekas, and Vivek S Borkar.", "startOffset": 0, "endOffset": 4}, {"referenceID": 15, "context": "[17] A.", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "[18] Yu Nesterov.", "startOffset": 0, "endOffset": 4}, {"referenceID": 17, "context": "[19] Atsushi Nitanda.", "startOffset": 0, "endOffset": 4}, {"referenceID": 18, "context": "[20] Benjamin Recht, Christopher Re, Stephen Wright, and Feng Niu.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "[21] Peter Richt\u00e1rik and Martin Tak\u00e1\u010d.", "startOffset": 0, "endOffset": 4}, {"referenceID": 20, "context": "[22] H.", "startOffset": 0, "endOffset": 4}, {"referenceID": 21, "context": "[23] Mark W.", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "[24] Shai Shalev-Shwartz and Tong Zhang.", "startOffset": 0, "endOffset": 4}, {"referenceID": 23, "context": "[25] Shai Shalev-Shwartz and Tong Zhang.", "startOffset": 0, "endOffset": 4}, {"referenceID": 24, "context": "[26] Ohad Shamir and Nathan Srebro.", "startOffset": 0, "endOffset": 4}, {"referenceID": 25, "context": "[27] Lin Xiao and Tong Zhang.", "startOffset": 0, "endOffset": 4}, {"referenceID": 4, "context": "The first inequality and second inequalities on T2 directly follows from Lemma 3 of [5] and simple application of Lemma 1 respectively.", "startOffset": 84, "endOffset": 87}, {"referenceID": 4, "context": "From Lemma 3 of [5] (also see [9]), we have E[\u2016v\u2016] \u2264 4LE [ f(x)\u2212 f(x\u2217) + f(x\u0303)\u2212 f(x\u2217) ] .", "startOffset": 16, "endOffset": 19}, {"referenceID": 8, "context": "From Lemma 3 of [5] (also see [9]), we have E[\u2016v\u2016] \u2264 4LE [ f(x)\u2212 f(x\u2217) + f(x\u0303)\u2212 f(x\u2217) ] .", "startOffset": 30, "endOffset": 33}, {"referenceID": 8, "context": "[9] For any \u03b1i \u2208 R where i \u2208 [n] and x\u2217, we have E [ \u2016\u2207fit(\u03b1it)\u2212\u2207fit(x)\u2016 ] \u2264 2L n \u2211", "startOffset": 0, "endOffset": 3}], "year": 2015, "abstractText": "We study optimization algorithms based on variance reduction for stochastic gradient descent (SGD). Remarkable recent progress has been made in this direction through development of algorithms like SAG, SVRG, SAGA. These algorithms have been shown to outperform SGD, both theoretically and empirically. However, asynchronous versions of these algorithms\u2014a crucial requirement for modern large-scale applications\u2014have not been studied. We bridge this gap by presenting a unifying framework for many variance reduction techniques. Subsequently, we propose an asynchronous algorithm grounded in our framework, and prove its fast convergence. An important consequence of our general approach is that it yields asynchronous versions of variance reduction algorithms such as SVRG and SAGA as a byproduct. Our method achieves near linear speedup in sparse settings common to machine learning. We demonstrate the empirical performance of our method through a concrete realization of asynchronous SVRG.", "creator": "LaTeX with hyperref package"}}}