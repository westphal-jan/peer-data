{"id": "1509.01007", "review": {"conference": "acl", "VERSION": "v1", "DATE_OF_SUBMISSION": "3-Sep-2015", "title": "Encoding Prior Knowledge with Eigenword Embeddings", "abstract": "canonical correlation sentiment analysis ( cca ) technology is a method for considerably reducing successively the dimension of data represented using two views. it has been previously used twice to derive word embeddings, where one view indicates a word, and the preferred other view indicates its context. we describe a way to incorporate prior knowledge involved into cca, give a purely theoretical justification for it, and test evaluating it by deriving word embeddings and evaluating them on a myriad of datasets.", "histories": [["v1", "Thu, 3 Sep 2015 09:39:36 GMT  (42kb)", "https://arxiv.org/abs/1509.01007v1", null], ["v2", "Tue, 8 Mar 2016 10:54:17 GMT  (49kb)", "http://arxiv.org/abs/1509.01007v2", null], ["v3", "Wed, 27 Jul 2016 12:46:39 GMT  (49kb)", "http://arxiv.org/abs/1509.01007v3", "in Transactions of the Association of Computational Linguistics (TACL), 2016"]], "reviews": [], "SUBJECTS": "cs.CL", "authors": ["dominique osborne", "shashi narayan", "shay b cohen"], "accepted": true, "id": "1509.01007"}, "pdf": {"name": "1509.01007.pdf", "metadata": {"source": "CRF", "title": null, "authors": ["Shashi Narayan"], "emails": ["dominique.osborne.13@uni.strath.ac.uk", "snaraya2@inf.ed.ac.uk", "scohen@inf.ed.ac.uk"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 9.\n01 00\n7v 3\n[ cs\n.C L\n] 2\n7 Ju\nl 2 01"}, {"heading": "1 Introduction", "text": "In recent years there has been an immense interest in representing words as low-dimensional continuous real-vectors, namely word embeddings. Word embeddings aim to capture lexico-semantic information such that regularities in the vocabulary are topologically represented in a Euclidean space. Such word embeddings have achieved state-of-theart performance on many natural language processing (NLP) tasks, e.g., syntactic parsing (Socher et al., 2013), word or phrase similarity (Mikolov et al., 2013b), dependency parsing (Bansal et al., 2014), unsupervised learning (Parikh et al., 2014) and others. Since the discovery that word embeddings are useful as features for various NLP tasks, research on word embeddings has taken on a life of its own, with a vibrant community searching for better word representations in a variety of problems and datasets.\nThese word embeddings are often induced from large raw text capturing distributional co-occurrence information via neural networks (Bengio et al., 2003; Mikolov et al., 2013b; Mikolov et al., 2013c) or spectral methods (Deerwester et al., 1990; Dhillon et al., 2015). While these general purpose word embeddings have achieved significant im-\nprovement in various tasks in NLP, it has been discovered that further tuning of these continuous word representations for specific tasks improves their performance by a larger margin. For example, in dependency parsing, word embeddings could be tailored to capture similarity in terms of context within syntactic parses (Bansal et al., 2014) or they could be refined using semantic lexicons such as WordNet (Miller, 1995), FrameNet (Baker et al., 1998) and the Paraphrase Database (Ganitkevitch et al., 2013) to improve various similarity tasks (Yu and Dredze, 2014; Faruqui et al., 2015; Rothe and Schu\u0308tze, 2015). This paper proposes a method to encode prior semantic knowledge in spectral word embeddings (Dhillon et al., 2015).\nSpectral learning algorithms are of great interest for their speed, scalability, theoretical guarantees and performance in various NLP applications. These algorithms are no strangers to word embeddings either. In latent semantic analysis (LSA, (Deerwester et al., 1990; Landauer et al., 1998)), word embeddings are learned by performing SVD on the word by document matrix. Recently, Dhillon et al. (2015) have proposed to use canonical correlation analysis (CCA) as a method to learn lowdimensional real vectors, called Eigenwords. Unlike LSA based methods, CCA based methods are scale invariant and can capture multiview information such as the left and right contexts of the words. As a result, the eigenword embeddings of Dhillon et al. (2015) that were learned using the simple linear methods give accuracies comparable to or better than state of the art when compared with highly nonlinear deep learning based approaches (Collobert and Weston, 2008; Mnih and Hinton, 2007; Mikolov et al., 2013b; Mikolov et al., 2013c).\nThe main contribution of this paper is a technique\nto incorporate prior knowledge into the derivation of canonical correlation analysis. In contrast to previous work where prior knowledge is introduced in the off-the-shelf embeddings as a post-processing step (Faruqui et al., 2015; Rothe and Schu\u0308tze, 2015), our approach introduces prior knowledge in the CCA derivation itself. In this way it preserves the theoretical properties of spectral learning algorithms for learning word embeddings. The prior knowledge is based on lexical resources such as WordNet, FrameNet and the Paraphrase Database.\nOur derivation of CCA to incorporate prior knowledge is not limited to eigenwords and can be used with CCA for other problems. It follows a similar idea to the one proposed by Koren and Carmel (2003) for improving the visualization of principal vectors with principal component analysis (PCA). Our derivation represents the solution to CCA as that of an optimization problem which maximizes the distance between the two view projections of training examples, while weighting these distances using the external source of prior knowledge. As such, our approach applies to other uses of CCA in the NLP literature, such as the one of Jagarlamudi and Daume\u0301 (2012), who used CCA for transliteration, or the one of Silberer et al. (2013), who used CCA for semantically representing visual attributes."}, {"heading": "2 Background and Notation", "text": "For an integer n, we denote by [n] the set of integers {1, . . . , n}. We assume the existence of a vocabulary of words, usually taken from a corpus. This set of words is denoted by H = {h1, . . . , h|H|}. For a square matrix A, we denote by diag(A) a diagonal matrix B which has the same dimensions as A such that Bii = Aii for all i. For vector v \u2208 Rd, we denote its \u21132 norm by ||v||, i.e. ||v|| = \u221a \u2211d i=1 v 2 i . We also denote by vj or [v]j the jth coordinate of v. For a pair of vectors u and v, we denote their dot product by \u3008u, v\u3009.\nWe define a word embedding as a function f from H to Rm for some (relatively small) m. For example, in our experiments we vary m between 50 and 300. The word embedding function maps the word to some real-vector representation, with the intention to capture regularities in the vocabulary that are topologically represented in the corresponding Eu-\nclidean space. For example, all vocabulary words that correspond to city names could be grouped together in that space.\nResearch on the derivation of word embeddings that capture various regularities has greatly accelerated in recent years. Various methods used for this purpose range from low-rank approximations of co-occurrence statistics (Deerwester et al., 1990; Dhillon et al., 2015) to neural networks jointly learning a language model (Bengio et al., 2003; Mikolov et al., 2013a) or models for other NLP tasks (Collobert and Weston, 2008)."}, {"heading": "3 Canonical Correlation Analysis for Deriving Word Embeddings", "text": "One recent approach to derive word embeddings, developed by Dhillon et al. (2015), is through the use of canonical correlation analysis, resulting in socalled \u201ceigenwords.\u201d CCA is a technique for multiview dimensionality reduction. It assumes the existence of two views for a set of data, similarly to co-training (Yarowsky, 1995; Blum and Mitchell, 1998), and then projects the data in the two views in a way that maximizes the correlation between the projected views.\nDhillon et al. (2015) used CCA to derive word embeddings through the following procedure. They first break each document in a corpus of documents into n sequences of words of a fixed length 2k + 1, where k is a window size. For example, if k = 2, the short document \u201cHarry Potter has been a bestseller\u201d would be broken into \u201cHarry Potter has been a\u201d and \u201cPotter has been a best-seller.\u201d In each such sequence, the middle word is identified as a pivot.\nThis leads to the construction of the following training set from a set of documents: {(w\n(i) 1 , . . . , w (i) k , w (i), w (i) k+1, . . . , w (i) 2k ) | i \u2208 [n]}. With abuse of notation, this is a multiset, as certain words are expected to appear in certain contexts multiple times. Each w(i) is a pivot word, and the rest of the elements are words in the sequence called \u201cthe context words.\u201d With this training set in mind, the two views for CCA are defined as following.\nWe define the first view through a sparse \u201ccontext matrix\u201d C \u2208 Rn\u00d72k|H| such that each row in the matrix is a vector, consisting of 2k one-hot vectors, each of length |H|. Each such one-hot vector corre-\nsponds to a word that fired in a specific index in the context. In addition, we also define a second view through a matrix W \u2208 Rn\u00d7|H| such that Wij = 1 if w(i) = hj . We present both views of the training set in Figure 1.\nNote that now the matrix M = W\u22a4C is in R |H|\u00d7(2k|H|) such that each element Mij gives the count of times that hi appeared with the corresponding context word and context index encoded by j.\nSimilarly, we define a matrix D1 = diag(W\u22a4W ) and D2 = diag(C\u22a4C). Finally, to get the word embeddings, we perform singular value decomposition (SVD) on the matrix D\u22121/21 MD \u22121/2 2 . Note that in its original form, CCA requires use of W\u22a4W and C\u22a4C in their full form, and not just the corresponding diagonal matrices D1 and D2; however, in practice, inverting these matrices can be quite intensive computationally and can lead to memory issues. As such, we approximate CCA by using the diagonal matrices D1 and D2.\nFrom the SVD step, we get two projections U \u2208\nR |H|\u00d7m and V \u2208 R2k|H|\u00d7m such that\nD \u22121/2 1 MD \u22121/2 2 \u2248 U\u03a3V \u22a4\nwhere \u03a3 \u2208 Rm\u00d7m is a diagonal matrix with \u03a3ii > 0 being the ith largest singular value of D\n\u22121/2 1 MD \u22121/2 2 . In order to get the final word embeddings, we calculate D\u22121/21 U \u2208 R |H|\u00d7m. Each row in this matrix corresponds to an m-dimensional vector for the corresponding word in the vocabulary. This means that f(hi) for hi \u2208 H is the ith row of the matrix D\u22121/21 U . The projection V can be used to get \u201ccontext embeddings.\u201d See more about this in Dhillon et al. (2015).\nThis use of CCA to derive word embeddings follows the usual distributional hypothesis (Harris, 1957) that most word embeddings techniques rely on. In the case of CCA, this hypothesis is translated into action in the following way. CCA finds projections for the contexts and for the pivot words which are most correlated. This means that if a word co-occurs in a specific context many times (either directly, or transitively through similarity to other words), then this context is expected to be projected to a point \u201cclose\u201d to the point to which the word is projected. As such, if two words occur in a specific context many times, these two words are expected to be projected to points which are close to each other.\nFor the next section, we denote X = WD\u22121/21 and Y = CD\u22121/22 . To refer to the dimensions of X and Y generically, we denote d = |H| and d\u2032 = 2k|H|. In addition, we refer to the column vectors of U and V as u1, . . . , um and v1, . . . , vm.\nMathematical Intuition Behind CCA The procedure that CCA follows finds a projection of the two views in a shared space, such that the correlation between the two views is maximized at each coordinate, and there is minimal redundancy between the coordinates of each view. This means that CCA solves the following sequence of optimization problems for j \u2208 [m] where aj \u2208 R1\u00d7d and bj \u2208 R1\u00d7d \u2032 :\nargmax aj ,bj\ncorr(ajW \u22a4, bjC \u22a4)\nsuch that corr(ajW \u22a4, akW \u22a4) = 0, k < j\ncorr(bjC \u22a4, bkC \u22a4) = 0, k < j\nwhere corr is a function that accepts two vectors and return the Pearson correlation between the pairwise elements of the two vectors. The approximate solution to this optimization problem (when using diagonal D1 and D2) is a\u0302\u22a4i = D \u22121/2 1 ui and b\u0302\u22a4i = D \u22121/2 2 vi for i \u2208 [m].\nCCA also has a probabilistic interpretation as a maximum likelihood solution of a latent variable model for two normal random vectors, each drawn based on a third latent Gaussian vector (Bach and Jordan, 2005).\nThe way we describe CCA for deriving word embeddings is related to Latent Semantic Indexing (LSI), which performs singular value decomposition on the matrix M directly, without doing any kind of variance normalization. Dhillon et al. (2015) describe some differences between LSI and CCA. The extra normalization step decreases the importance of frequent words when doing SVD."}, {"heading": "4 Incorporating Prior Knowledge into Canonical Correlation Analysis", "text": "In this section, we detail the technique we use to incorporate prior knowledge into the derivation of canonical correlation analysis. The main motivation behind our approach is to improve the optimization of correlation between the two views by weighing them using the external source of prior knowledge. The prior knowledge is based on lexical resources such as WordNet, FrameNet and the Paraphrase Database. Our approach follows a similar idea to the one proposed by Koren and Carmel (2003) for improving the visualization of principal vectors with principal component analysis (PCA). It is also related to Laplacian manifold regularization (Belkin et al., 2006).\nAn important notion in our derivation is that of a Laplacian matrix. The Laplacian of an undirected weighted graph is an n \u00d7 n matrix where n is the number of nodes in the graph. It equals D\u2212A where A is the adjacency matrix of the graph (so that Aij is the weight for the edge (i, j) in the graph, if it exists, and 0 otherwise) and D is a diagonal matrix such that Dii = \u2211\nj Aij . The Laplacian is always a symmetric square matrix such that the sum over rows (or columns) is 0. It is also positive semi-definite.\nWe propose a generalization of CCA, in which we\nintroduce a Laplacian matrix into the derivation of CCA itself, as shown in Figure 2. We encode prior knowledge about the distances between the projections of two views into the Laplacian. The Laplacian allows us to improve the optimization of the correlation between the two views by weighing them using the external source of prior knowledge."}, {"heading": "4.1 Generalization of CCA", "text": "We present three lemmas (proofs are given in Appendix A), followed by our main proposition. These three lemmas are useful to prove our final proposition.\nThe main proposition shows that CCA maximizes the distance between the two view projections for any pair of examples i and j, i 6= j, while minimizing the two view projection distance for the two views of an example i. The two views we discuss here in practice are the view of the word through a one-hot representation, and the view which represents the context words for a specific word token. The distance between two view projections is defined in Eq. 2.\nLemma 1. LetX and Y be two matrices of size n\u00d7d and n \u00d7 d\u2032, respectively, for example, as defined in \u00a73. Assume that\n\u2211n i=1 Xij = 0 for j \u2208 [d] and\u2211n\ni=1 Yij = 0 for j \u2208 [d \u2032]. Let L be an n \u00d7 n\nLaplacian matrix such that\nLij =\n{\nn\u2212 1 if i = j \u22121 if i 6= j. (1)\nThen X\u22a4LY equals X\u22a4Y up to a multiplication by a positive constant.\nLemma 2. Let A \u2208 Rd\u00d7d \u2032\n. Then the rank m thinSVD of A can be found by solving the following optimization problem:\nmax u1, . . . , um, v1, . . . , vm\nm\u2211\ni=1\nu\u22a4i Avi\nsuch that ||ui|| = ||vi|| = 1 i \u2208 [m]\n\u3008ui, uj\u3009 = \u3008vi, vj\u3009 = 0 i 6= j\nwhere ui \u2208 Rd\u00d71 denote the left singular vectors, and vi \u2208 Rd \u2032\u00d71 denote the right singular vectors.\nThe last utility lemma we describe shows that interjecting the Laplacian between the two views can be expressed as a weighted sum of the distances between the projections of the two views (these distances are given in Eq. 2), where the weights come from the Laplacian.\nLemma 3. Let u1, . . . , um and v1, . . . , vm be two sets of vectors of length d and d\u2032 respectively. Let L \u2208 Rn\u00d7n be a Laplacian and X \u2208 Rn\u00d7d and Y \u2208 R n\u00d7d\u2032 . Then:\nm\u2211\nk=1\n(Xuk) \u22a4L (Y vk) =\n\u2211\ni,j\n\u2212Lij ( dmij )2 ,\nwhere\ndmij =\n\u221a \u221a \u221a \u221a 1\n2\n( m\u2211\nk=1\n([Xuk]i \u2212 [Y vk]j) 2\n)\n. (2)\nThe following proposition is our main result for this section.\nProposition 4. The matrices U \u2208 Rd\u00d7m and V \u2208 R d\u2032\u00d7m that CCA computes are the m-dimensional\nprojections that maximize\n\u2211\ni,j\n( dmij )2 \u2212 n\nn\u2211\ni=1\n(dmii ) 2 , (3)\nwhere dmij is defined as in Eq. 2 for u1, . . . , um being the columns of U and v1, . . . , vm being the columns of V .\nProof. According to Lemma 3, the objective in Eq. 3 equals\n\u2211m k=1(Xuk)\n\u22a4L(Y vk) where L is defined as in Eq. 1. Therefore, maximizing Eq. 3 corresponds to maximization of\n\u2211m k=1(Xuk)\n\u22a4L(Y vk) under the constraints that the U and V matrices have orthonormal vectors. Using Lemma 2, it can be shown that the solution to this maximization is done by doing singular value decomposition on X\u22a4LY . According to Lemma 1, this corresponds to finding U and V by doing singular value decomposition on X\u22a4Y , because a multiplicative constant does not change the value of the right/left singular vectors.\nThe above proposition shows that CCA tries to find projections of both views such that the distances between the two views for pairs of examples with indices i 6= j are maximized (first term in Eq. 3), while\nminimizing the distance between the projections of the two views for a specific example (second term in Eq. 3). Therefore, CCA tries to project a context and a word in that context to points that are close to each other in a shared space, while maximizing the distance between a context and a word which do not often co-occur together.\nAs long as L is a Laplacian, Proposition 4 is still true, only with the maximization of the objective\n\u2211\ni,j\n\u2212Lij ( dmij )2 , (4)\nwhere Lij \u2264 0 for i 6= j and Lii \u2265 0. This result lends itself to a generalization of CCA, in which we use predefined weights for the Laplacian that encode some prior knowledge about the distances that the projections of two views should satisfy.\nIf the weight \u2212Lij is large for a specific (i, j), then we will try harder to maximize the distance between one view of example i and the other view of example j (i.e. we will try to project the word w(i) and the context of example j into distant points in the space).\nThis means that in the current formulation, \u2212Lij plays the role of a dissimiliarity indicator between pairs of words. The more dissimilar words are, the larger the weight, and then the more distant the projections are for the contexts and the words."}, {"heading": "4.2 From CCA with Dissimilarities to CCA with Similarities", "text": "It is often more convenient to work with similarity measures between pairs of words. To do that, we can retain the same formulation as before with the Laplacian, where \u2212Lij now denotes a measure of similarity. Now, instead of maximizing the objective in Eq. 4, we are required to minimize it.\nIt can be shown that such mirror formulation can be done with an algorithm similar to CCA, leading to a proposition in the style of Proposition 4. To solve this minimization formulation, we just need to choose the singular vectors associated with the smallest m singular values (instead of the largest).\nOnce we change the CCA algorithm with the Laplacian to choose these projections, we can define L, for example, based on a similarity graph. The graph is an undirected graph that has |H| nodes, for\neach word in the vocabulary, and there is an edge between a pair of words whenever the two words are similar to each other based on some external source of information, such as WordNet (for example, if they are synonyms).\nWe then define the Laplacian L such that Lij = \u22121 if i and j are adjacent in the graph (and i 6= j), Lii is the degree of the node i and Lij = 0 in all other cases. By using this variant of CCA, we strive to maximize the distance of the two views between words which are adjacent in the graph (or continuing the example above, maximize the distance between words which are not synonyms). In addition, the fewer adjacent nodes a word has (or the more synonyms it has), the less important it is to minimize the distance between the two views of that given word."}, {"heading": "4.3 Final Algorithm", "text": "In order to use an arbitrary Laplacian matrix with CCA, we require that the data is centered, i.e. that the average over all examples of each of the coordinates of the word and context vectors is 0. However, such a prerequisite would make the matrices C and W dense (with many non-zero values), and hard to maintain in memory, and would also make singular value decomposition inefficient.\nAs such, we do not center the data to keep it sparse, and as such, use a matrix L which is not strictly a Laplacian, but that behaves better in practice.1 Given the graph mentioned in \u00a74 which is extracted from an external source of information, we use L such that Lij = \u03b1 for an \u03b1 \u2208 (0, 1) which is treated as a smoothing factor for the graph (see below the choices of \u03b1) if i and j are not adjacent in the graph, Lij = 0 if i 6= j are adjacent, and finally Lii = 1 for all i \u2208 [n]. Therefore, this matrix is symmetric, and the only constraint it does not satisfy is that of rows and columns summing to 0.\nScanning the documents and calculating the statistic matrix with the Laplacian is computationally infeasible with a large number of tokens given as input. It is quadratic in that number. As such, we make another modification to the algorithm, and calculate a \u201clocal\u201d Laplacian. The modification requires an integer N as input (we use N = 12), and then it makes updates to pairs of word tokens only if they are within an N -sized window of each. The final algorithm we use is described in Figure 3. The algorithm works by directly computing the cooccurrence matrix M (instead of maintaining W and C). It does so by increasing by 1 any cells corresponding to word-context co-occurrence in the documents and by \u03b1 any cells corresponding to word and contexts that are connected in the graph."}, {"heading": "5 Experiments", "text": "In this section we describe our experiments."}, {"heading": "5.1 Experimental Setup", "text": "Training Data We used three datasets, WIKI1, WIKI2 and WIKI5, all based on the first 1, 2 and\n1We note that other decompositions, such as PCA, also require centering of the data, but in case of sparse data matrix, this step is not performed.\n5 billion words from Wikipedia respectively.2 Each dataset is broken into chunks of length 13 (window sizes of 6), corresponding to a document. The above Laplacian L is calculated within each document separately. This means that \u2212Lij is 1 only if i and j denote two words that appear in the same document. This is done to make the calculations computationally feasible. We calculate word embeddings for the top most frequent 200K words.\nPrior Knowledge Resources We consider three sources of prior knowledge: WordNet (Miller, 1995), the Paraphrase Database of Ganitkevitch et al. (2013), abbreviated as PPDB,3 and FrameNet (Baker et al., 1998). Since FrameNet and WordNet index words in their base form, we use WordNet\u2019s stemmer to identify the base form for the text in our corpora whenever we calculate the Laplacian graph. For WordNet, we have an edge in the graph if one word is a synonym, hypernym or hyponym of the other. For PPDB, we have an edge if one word is a paraphrase of the other, according to the database. For FrameNet, we connect two words in the graph if they appear in the same frame.\nSystem Implementation We modified the implementation of the SWELL Java package4 of Dhillon et al. (2015). Specifically, we needed to modify the loop that iterates over words in each document to a nested loop that iterates over pairs of words, in order to compute a sum of the form \u2211\nij XriLijYjs. 5\nDhillon et al. (2015) use window size k = 2, which we retain in our experiments.6"}, {"heading": "5.2 Baselines", "text": "Off-the-shelf Word Embeddings We compare our word embeddings with existing state-of-the-\n2We downloaded the data from https://dumps. wikimedia.org/, and preprocessed it using the tool available at http://mattmahoney.net/dc/textdata. html.\n3We use the XL subset of the PPDB. 4https://github.com/paramveerdhillon/\nswell. 5Our implementation and the word embeddings that we calculated are available at http://cohort.inf.ed.ac. uk/cohort/eigen/.\n6We also use the square-root transformation as mentioned in Dhillon et al. (2015) which controls the variance in the counts accumulated from the corpus. See a justification for this transform in Stratos et al. (2015).\nart word embeddings, such as Glove (Pennington et al., 2014), Skip-Gram (Mikolov et al., 2013b), Global Context (Huang et al., 2012) and Multilingual (Faruqui and Dyer, 2014). We also compare our word embeddings with the Eigen word embeddings of Dhillon et al. (2015) without any prior knowledge.\nRetrofitting for Prior Knowledge We compare our approach of incorporating prior knowledge into the derivation of CCA against the previous works where prior knowledge is introduced in the off-theshelf embeddings as a post-processing step (Faruqui et al., 2015; Rothe and Schu\u0308tze, 2015). In this paper, we focus on the retrofitting approach of Faruqui et al. (2015).\nRetrofitting works by optimizing an objective function which has two terms: one that tries to keep the distance between the word vectors close to the original distances, and the other which enforces the vectors of words which are adjacent in the prior knowledge graph to be close to each other in the new\nembedding space. We use the retrofitting package7 to compare our results in different settings against the results of retrofitting of Faruqui et al. (2015)."}, {"heading": "5.3 Evaluation Benchmarks", "text": "We evaluated the quality of our eigenword embeddings on three different tasks: word similarity, geographic analogies and NP bracketing.\nWord Similarity For the word similarity task we experimented with 11 different widely used benchmarks. The WS-353-ALL dataset (Finkelstein et al., 2002) consists of 353 pairs of English words with their human similarity ratings. Later, Agirre et al. (2009) re-annotated WS-353-ALL for similarity (WS-353-SIM) and relatedness (WS-353-REL) with specific distinctions between them. The SimLex999 dataset (Hill et al., 2015) was built to measure how well models capture similarity, rather than relatedness or association. The MEN-TR-3000 dataset (Bruni et al., 2014) consists of 3000 word pairs\n7https://github.com/mfaruqui/ retrofitting.\nsampled from words that occur at least 700 times in a large web corpus. The datasets, MTurk-287 (Radinsky et al., 2011) and MTurk-771 (Halawi et al., 2012), were scored by Amazon Mechanical Turk workers for relatedness of English word pairs. The YP-130 (Yang and Powers, 2005) and Verb-143 (Baker et al., 2014) datasets were developed for verb similarity predictions. The last two datasets, MC-30 (Miller and Charles, 1991) and RG-65 (Rubenstein and Goodenough, 1965) consist of 30 and 65 noun pairs respectively.\nFor each dataset, we calculate the cosine similarity between the vectors of word pairs and measure Spearman\u2019s rank correlation coefficient between the scores produced by the embeddings and human ratings. We report the average of the correlations on all 11 datasets. Each word similarity task in the above list represents a different aspect of word similarity, and as such, averaging the results points to the quality of the word embeddings on several tasks. We later analyze specific datasets.\nGeographic Analogies Mikolov et al. (2013c) created a test set of analogous word pairs such as a:b c:d raising the analogy question of the form \u201ca is to b as c is to \u201d where d is unknown. We report results on a subset of this dataset which focuses on finding capitals of common countries, e.g., Greece is to Athens as Iraq is to . This dataset consists of 506 word pairs. For given word pairs, a:b c:d where d is unknown, we use the vector offset method (Mikolov et al., 2013b), i.e., we compute a vector v = vb \u2212 va + vc where va, vb and vc are vector representations of the words a, b and c respectively; we then return the word d with the greatest cosine similarity to v.\nNP Bracketing Here the goal is to identify the correct bracketing of a three-word noun (Lazaridou et al., 2013). For example, the bracketing of annual (price growth) is \u201cright,\u201d while the bracketing of (entry level) machine is \u201cleft.\u201d Similarly to Faruqui and Dyer (2015), we concatenate the word vectors of the three words, and use this vector for binary classification into left or right.\nSince most of the datasets that we evaluate on in this paper are not standardly separated into development and test sets, we report all results we calculated (with respect to hyperparameter differences) and do\nnot select just a subset of the results."}, {"heading": "5.4 Evaluation", "text": "Preliminary Experiments In our first set of experiments, we vary the dimension of the word embedding vectors. We try m \u2208 {50, 100, 200, 300}. Our experiments showed that the results consistently improve when the dimension increases for all the different datasets. For example, for m = 50 and WIKI1, we get an average of 46.4 on the word similarity tasks, 50.1 for m = 100, 53.4 for m = 200 and 54.2 for m = 300. The more data are available, the more likely larger dimension will improve the quality of the word embeddings. Indeed, for WIKI5, we get an average of 49.4, 54.9, 57.0 and 59.5 for each of the dimensions. The improvements with respect to the dimension are consistent across all of our results, so we fix m at 300.\nWe also noticed a consistent improvement in accuracy when using more data from Wikipedia. For example, for m = 300, using WIKI1 gives an average of 54.1, while using WIKI2 gives an average of 54.9 and finally, using WIKI5 gives an average of 59.5. We fix the dataset we use to be WIKI5.\nResults Table 1 describes the results from our first set of experiments. (Note that the table is divided into 9 distinct blocks, labeled A through I.) In general, adding prior knowledge to eigenword embeddings does improve the quality of word vectors for the word similarity, geographic analogies and NP bracketing tasks on several occasions (blocks D\u2013F compared to last row in blocks A\u2013C). For example, our eigenword vectors encoded with prior knowledge (CCAPrior) consistently perform better than the eigenword vectors that do not have any prior knowledge for the word similarity task (59.5, Eigen in the first row under NPK column, versus block D). The only exceptions are for \u03b1 = 0.1 with WordNet (59.1), for \u03b1 = 0.7 with PPDB (59.3) and for \u03b1 = 0.9 with FrameNet (58.9), where \u03b1 denotes the smoothing factor.\nIn several cases, running the retrofitting algorithm of Faruqui et al. (2015) on top of our word embeddings helps further, as if \u201cadding prior knowledge twice is better than once.\u201d Results for these word embeddings (CCAPrior+RF) are shown in Table 1. Adding retrofitting to our encoding of prior knowl-\nedge often performs better for word similarity and NP bracketing tasks (block D versus G and block F versus I). Interestingly, CCAPrior+RF embeddings also often perform better than eigenword vectors (Eigen) of Dhillon et al. (2015) when retrofitted using the method of Faruqui et al. (2015). For example, in the word similarity task, eigenwords retrofitted with WordNet get an accuracy of 62.2 whereas encoding prior knowledge using both CCA and retrofitting gets a maximum accuracy of 63.3. We see the same pattern for PPDB, with 63.6 for \u201cEigen\u201d and 64.9 for \u201cCCAPrior+RF\u201d. We hypothesize that the reason for these changes is that the two methods for encoding prior knowledge maximize different objective functions.\nThe performance with FrameNet is weaker, in some cases leading to worse performance (e.g., with Glove and SG vectors). We believe that FrameNet does not perform as well as the other lexicons because it groups words based on very abstract concepts; often words with seemingly distantly related meanings (e.g., push and growth) can evoke the same frame. This also supports the findings of Faruqui et al. (2015), who noticed that the use of FrameNet as a prior knowledge resource for improving the quality of word embeddings is not as helpful as other resources such as WordNet and PPDB.\nWe note that CCA works especially well for the geographic analogies dataset. The quality of eigenword embeddings (and the other embeddings) degrades when we encode prior knowledge using the method of Faruqui et al. (2015). Our method improves the quality of eigenword embeddings.\nGlobal Picture of the Results When comparing retrofitting to CCA with prior knowledge, there is a noticable difference. Retrofitting performs well or badly, depending on the dataset, while the results with CCA are more stable. We attribute this to the difference between how our algorithm and retrofitting work. Retrofitting makes a direct use of the source of prior knowledge, by adding a regularization term that enforces words which are similar according to the prior knowledge to be closer in the embedding space. Our algorithm, on the other hand, makes a more indirect use of the source of prior knowledge, by changing the co-occurence matrix on which we do singular value decomposition.\nSpecifically, we believe that our algorithm is more stable to cases in which words for the task at hand are unknown words with respect to the source of prior knowledge. This is demonstrated with the geographical analogies task: in that case, retrofitting lowers the results in most cases. The city and country names do not appear in the sources of prior knowledge we used.\nFurther Analysis We further inspected the results on the word similarity tasks for the RG-65 and WS353-ALL datasets. Our goal was to find cases in which either CCA embeddings by themselves outperform other types of embeddings or that encoding prior knowledge into CCA the way we describe significantly improves the results.\nFor the WS-353-ALL dataset, the eigenword embeddings get a correlation of 69.6. The next best performing word embeddings are the multilingual word embeddings (68.0) and skip-gram (58.3). Interestingly enough, the multilingual word embeddings also use CCA to project words into a lowdimensional space using a linear transformation, suggesting that linear projections are a good fit for the WS-353-ALL dataset. The dataset itself includes pairs of common words with a corresponding similarity score. The words that appear in the dataset are actually expected to occur in similar contexts, a property that CCA directly encodes when deriving word embeddings.\nThe best performance on the RG-65 dataset is with the Glove word embeddings (76.6). CCA embeddings give an accuracy of 69.7 on that dataset. However, with this dataset, we observe significant improvement when encoding prior knowledge using our method. For example, using WordNet with this dataset improves the results by 4.2 points (73.9). Using the method of Faruqui et al. (2015) (with WordNet) on top of our CCA word embeddings improves the results even further by 8.7 points (78.4).\nThe Role of Prior Knowledge We also designed an experiment to test whether using distributional information is necessary for having well-performing word embeddings, or whether it is sufficient to rely on the prior knowledge resource. In order to test this, we created a sparse matrix that corresponds to the graph based on the external resource graph. We then follow up with singular value decomposition on\nthat graph, and get embeddings of size 300. Table 2 gives the results when using these embeddings. We see that the results are consistently lower than the results that appear in Table 1, implying that the use of prior knowledge comes hand in hand with the use of distributional information. When using the retrofitting method by Faruqui et al. on top of these word embeddings, the results barely improved."}, {"heading": "6 Related Work", "text": "Our ideas in this paper for encoding prior knowledge in eigenword embeddings relate to three main threads in existing literature.\nOne of the threads focuses on modifying the objective of word vector training algorithms. Yu and Dredze (2014), Xu et al. (2014), Fried and Duh (2015) and Bian et al. (2014) augment the training objective in neural language models of Mikolov et al. (2013a) to encourage semantically related word vectors to come closer to each other. Wang et al. (2014) propose a method for jointly embedding entities (from FreeBase, a large community-curated knowledge base) and words (from Wikipedia) into the same continuous vector space. Chen and de Melo (2015) propose a similar joint model to improve the word embeddings, but rather than using structured knowledge sources their model focuses on discovering stronger semantic connections in specific contexts in a text corpus.\nAnother research thread relies on post-processing steps to encode prior knowledge from semantic lexicons in off-the-shelf word embeddings. The main intuition behind this trend is to update word vectors by running belief propagation on a graph extracted from the relation information in semantic lexicons. The retrofitting approach of Faruqui et al. (2015) uses such techniques to obtain higher\nquality semantic vectors using WordNet, FrameNet, and the Paraphrase Database. They report on how retrofitting helps improve the performance of various off-the-shelf word vectors such as Glove, SkipGram, Global Context, and Multilingual, on various word similarity tasks. Rothe and Schu\u0308tze (2015) also describe how standard word vectors can be extended to various data types in semantic lexicons, e.g., synsets and lexemes in WordNet.\nMost of the standard word vector training algorithms use co-occurrence within window-based contexts to measure relatedness among words. Several studies question the limitations of defining relatedness in this way and investigate if the word co-occurrence matrix can be constructed to encode prior knowledge directly to improve the quality of word vectors. Wang et al. (2015) investigate the notion of relatedness in embedding models by incorporating syntactic and lexicographic knowledge. In spectral learning, Yih et al. (2012) augment the word co-occurrence matrix on which LSA operates with relational information such that synonyms will tend to have positive cosine similarity, and antonyms will tend to have negative similarities. Their vector space representation successfully projects synonyms and antonyms on opposite sides in the projected space. Chang et al. (2013) further generalize this approach to encode multiple relations (and not just opposing relations, such as synonyms and antonyms) using multi-relational LSA.\nIn spectral learning, most of the studies on incorporating prior knowledge in word vectors focus on LSA based word embeddings (Yih et al., 2012; Chang et al., 2013; Turney and Littman, 2005; Turney, 2006; Turney and Pantel, 2010).\nFrom the technical perspective, our work is also related to that of Jagarlamudi et al. (2011), who showed how to generalize CCA so that it uses locality preserving projections (He and Niyogi, 2004). They also assume the existence of a weight matrix in a multi-view setting that describes the distances between pairs of points in the two views.\nMore generally, CCA is an important component for spectral learning algorithms in the unsupervised setting and with latent variables (Cohen et al., 2014; Narayan and Cohen, 2016; Stratos et al., 2016). Our method for incorporating prior knowledge into CCA could potentially be transferred to these algorithms."}, {"heading": "7 Conclusion", "text": "We described a method for incorporating prior knowledge into CCA. Our method requires a relatively simple change to the original canonical correlation analysis, where extra counts are added to the matrix on which singular value decomposition is performed. We used our method to derive word embeddings in the style of eigenwords, and tested them on a set of datasets. Our results demonstrate several advantages of encoding prior knowledge into eigenword embeddings."}, {"heading": "Acknowledgements", "text": "The authors would like to thank Paramveer Dhillon for his help with running the SWELL package. The authors would also like to thank Manaal Faruqui and Sujay Kumar Jauhar for their help and technical assistance with the retrofitting package and the word embedding evaluation suite. Thanks also to Ankur Parikh for early discusions on this project. This work was completed while the first author was an intern at the University of Edinburgh, as part of the Equate Scotland program. This research was supported by an EPSRC grant (EP/L02411X/1) and an EU H2020 grant (688139/H2020-ICT-2015; SUMMA)."}, {"heading": "Appendix A: Proofs", "text": "Proof of Lemma 1. The proof is similar to the one that appears in Koren and Carmel (2003) for Lemma 3.1. The only difference is the use of two views. Note that [X\u22a4LY ]ij = \u2211 k,k\u2032 XkiLkk\u2032Yk\u2032j . As such,\n[X\u22a4LY ]ij = \u2211\nk,k\u2032\n(n\u03b4kk\u2032 \u2212 1)XkiYk\u2032j\n=\nn\u2211\nk=1\nnXkiYkj \u2212\n( n\u2211\nk=1\nXki\n)\n\ufe38 \ufe37\ufe37 \ufe38 0\n\u00d7\n( n\u2211\nk\u2032=1\nYk\u2032j\n)\n\ufe38 \ufe37\ufe37 \ufe38 0\n= n[X\u22a4Y ]ij ,\nwhere \u03b4kk\u2032 = 1 iff k = k\u2032 and 0 otherwise, and the second equality relies on the assumption of the data being centered.\nProof of Lemma 2. Without loss of generality, assume d \u2264 d\u2032. Let u\u20321, . . . , u \u2032 d be the left singular vectors of A and v\u20321, . . . , v \u2032 d\u2032 be the right ones, and \u03c31, . . . , \u03c3d be the singular values. Therefore A = \u2211d\nj=1 \u03c3ju \u2032 j(v \u2032 j) \u22a4. In addition, the objective equals (after substituting A):\nm\u2211\ni=1\nd\u2211\nj=1\n\u03c3j\u3008ui, u \u2032 j\u3009\u3008vi, v \u2032 j\u3009 =\nd\u2211\nj=1\n\u03c3j\n( m\u2211\ni=1\n\u3008ui, u \u2032 j\u3009\u3008vi, v \u2032 j\u3009\n)\n(5)\nNote that by the Cauchy-Schwartz inequality:\nd\u2211\nj=1\nm\u2211\ni=1\n\u3008ui, u \u2032 j\u3009\u3008vi, v \u2032 j\u3009 =\nm\u2211\ni=1\nd\u2211\nj=1\n\u3008ui, u \u2032 j\u3009\u3008vi, v \u2032 j\u3009\n\u2264 m\u2211\ni=1\n\u221a \u221a \u221a \u221a d\u2211\nj=1\n|\u3008ui, u\u2032j\u3009| 2\n\u221a \u221a \u221a \u221a d\u2211\nj=1\n|\u3008vi, v\u2032j\u3009| 2 \u2264 m\nIn addition, note that if we choose ui = u\u2032i and vi = v\u2032i, then the inequality above becomes an equality, and in addition, the objective in Eq. 5 will equal the sum of the m largest singular vectors\n\u2211m j=1 \u03c3j . As such, this\nassignment to ui and vi maximizes the objective.\nProof of Lemma 3. First, by definition of matrix multiplication,\nm\u2211\nk=1\n(Xuk) \u22a4L (Y vk) =\n\u2211\ni,j\nLij\n( m\u2211\nk=1\n[Xuk]i[Y vk]j\n)\n.\n(6)\nAlso,\n( dmij )2 = 1\n2\n( m\u2211\nk=1\n[Xuk] 2 i \u2212 2[Xuk]i[Y vk]j + [Y vk] 2 j\n)\n.\nTherefore,\n2 \u2211\ni,j\n\u2212Lij ( dmij )2\n= \u2211\ni,j\n\u2212Lij\n( m\u2211\nk=1\n\u22122[Xuk]i[Y vk]j\n)\n+ \u2211\ni,j\n\u2212Lij\n( m\u2211\nk=1\n[Xuk] 2 i + [Y vk] 2 j\n)\n\ufe38 \ufe37\ufe37 \ufe38 0\n= 2 \u2211\ni,j\nLij\n( m\u2211\nk=1\n[Xuk]i[Y vk]j ,\n)\n(7)\nwhere the first two terms disappear because of the definition of the Laplacian. The comparison of Eq. 6 to Eq. 7 gives us the necessary result."}], "references": [], "referenceMentions": [], "year": 2016, "abstractText": "Canonical correlation analysis (CCA) is a method for reducing the dimension of data represented using two views. It has been previously used to derive word embeddings, where one view indicates a word, and the other view indicates its context. We describe a way to incorporate prior knowledge into CCA, give a theoretical justification for it, and test it by deriving word embeddings and evaluating them on a myriad of datasets.", "creator": "LaTeX with hyperref package"}}}