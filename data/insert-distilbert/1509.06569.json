{"id": "1509.06569", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Sep-2015", "title": "Tensorizing Neural Networks", "abstract": "deep neural networks currently demonstrate state - of - the - art performance in several domains. at the same time, models of this class diagram are very demanding computational in terms of computational machine resources. in particular, a large amount of memory is required by commonly used fully - connected layers, making this it hard to use the models on low - end devices and stopping the further increase of keeping the model size. in this paper we convert the dense weight input matrices of the fully - connected layers to the tensor train format such that the number of output parameters is reduced by a huge factor and here at the same time the expressive power of the layer is preserved. in particular, for the very deep vgg networks we report the compression factor of the dense weight matrix of a fully - layered connected transmission layer up to 200000 times leading to the compression factor of the whole network up to 7 times.", "histories": [["v1", "Tue, 22 Sep 2015 12:31:03 GMT  (21kb)", "http://arxiv.org/abs/1509.06569v1", null], ["v2", "Sun, 20 Dec 2015 11:44:05 GMT  (21kb)", "http://arxiv.org/abs/1509.06569v2", null]], "reviews": [], "SUBJECTS": "cs.LG cs.NE", "authors": ["alexander novikov", "dmitry podoprikhin", "anton osokin", "dmitry p vetrov"], "accepted": true, "id": "1509.06569"}, "pdf": {"name": "1509.06569.pdf", "metadata": {"source": "CRF", "title": "Tensorizing Neural Networks", "authors": ["Alexander Novikov", "Dmitry Podoprikhin", "Anton Osokin", "Dmitry Vetrov"], "emails": ["novikov@bayesgroup.ru", "podoprikhin.dmitry@gmail.com", "anton.osokin@inria.fr", "vetrovd@yandex.ru"], "sections": [{"heading": null, "text": "ar X\niv :1\n50 9.\n06 56\n9v 1\n[ cs\n.L G\n] 2\n2 Se"}, {"heading": "1 Introduction", "text": "Deep neural networks currently demonstrate state-of-the-art performance in many domains of largescale machine learning, such as computer vision, speech recognition, text processing, etc. These advances have become possible because of algorithmic advances, large amounts of available data, and modern hardware. For example, convolutional neural networks (CNNs) [11, 19] show by a large margin superior performance on the task of image classification. These models have thousands of nodes and millions of learnable parameters and are trained using millions of images [17] on powerful Graphics Processing Units (GPUs).\nThe necessity of expensive hardware and long processing time are the factors that complicate the application of such models on conventional desktops and portable devices. Consequently, there have been a large number of works trying different approaches to reduce both hardware requirements (e. g. memory demands) and running times (see Sec. 2).\nIn this paper we consider probably the most frequently used layer of the neural networks: the fullyconnected layer. This layer consists in a linear transformation of a high-dimensional input signal to a high-dimensional output signal with a large dense matrix defining the transformation. For example, in modern CNNs the dimensionalities of the input and output signals of the fully-connected layers are of the order of thousands, bringing the number of parameters of the fully-connected layers up to millions.\nWe represent the dense weight matrix of the fully-connected layers in a compact multi-linear format, Tensor Train (TT-format) [15]. The TT-format allows us to store large dense matrices using very few parameters while keeping enough flexibility to perform signal transformations. The resulting layer is compatible with the existing training algorithms for neural networks because all the derivatives required by the back-propagation algorithm [16] can be computed using the properties of the TTformat. We call the resulting layer a TT-layer and refer to a network with one or more TT-layers as TensorNet.\nWe apply our method to popular network architectures proposed for several datasets of different scales: MNIST [13], CIFAR-10 [10], ImageNet [11]. We experimentally show that the networks with the TT-layers match the performance of their uncompressed counterparts but require up to 200 000 times less of parameters, decreasing the size of the whole network by a factor of 7.\nThe rest of the paper is organized as follows. We start with a review of the related work in Sec. 2. We introduce necessary notation and review the Tensor Train (TT) format in Sec. 3. In Sec. 4 we apply the TT-format to the weight matrix of a fully-connected layer and in Sec. 5 derive all the equations necessary for applying the back-propagation algorithm. In Sec. 6 we present the experimental evaluation of our ideas followed by a discussion in Sec. 7."}, {"heading": "2 Related work", "text": "With sufficient amount of training data, big models usually outperform smaller ones. However stateof-the-art neural networks reached the hardware limits both in terms the computational power and the memory.\nIn particular, modern networks reached the memory limit with 89% [19] or even 100% [22] memory occupied by the weights of the fully-connected layers so it is not surprising that numerous attempts have been made to make the fully-connected layers more compact. One of the most straightforward approaches is to use a low-rank representation of the weight matrices. Recent studies show that the weight matrix of the fully-connected layer is highly redundant and by restricting its matrix rank it is possible to greatly reduce the number of parameters without significant drop in the predictive accuracy [5, 18, 22].\nAn alternative approach to the problem of model compression is to tie random subsets of weights using special hashing techniques [3]. The authors reported the compression factor of 8 for a twolayered network on the MNIST dataset without loss of accuracy. Memory consumption can also be reduced by using lower numerical precision [1, 9] or allowing fewer possible carefully chosen parameter values [7].\nIn our paper we generalize the low-rank ideas. Instead of searching for low-rank approximation of the weight matrix we treat it as multi-dimensional tensor and apply the Tensor Train decomposition algorithm [15]. This framework has already been successfully applied to several data-processing tasks, e. g. [14, 24].\nAnother possible advantage of our approach is the ability to use more hidden units than was available before. A recent work [2] shows that it is possible to construct wide and shallow (i. e. not deep) neural networks with performance close to the state-of-the-art deep CNNs by training a shallow network on the outputs of a trained deep network. They report the improvement of performance with the increase of the layer size and used up to 30 000 hidden units while restricting the matrix rank of the weight matrix in order to be able to keep and to update it during the training. Restricting the TT-ranks of the weight matrix (in contrast to the matrix rank) allows to use much wider layers potentially leading to the greater expressive power of the model. We demonstrate this effect by training a very wide model (262 144 hidden units) on the CIFAR-10 dataset that outperforms other non-convolutional networks.\nMatrix and tensor decompositions were recently used to speed up the inference time of CNNs [6, 12]. While we focus on fully-connected layers, Lebedev et al. [12] used the CP-decomposition to compress a 4-dimensional convolution kernel and then used the properties of the decomposition to speed up the inference time. This work shares the same spirit with our method and the approaches can be readily combined."}, {"heading": "3 TT-format", "text": "Throughout this paper we work with arrays of different dimensionality. We refer to the onedimensional arrays as vectors, the two-dimensional arrays \u2013 matrices, the arrays of higher dimensions \u2013 tensors. Bold lower case letters (e. g. a) denote vectors, ordinary lower case letters (e. g. a(i) = ai) \u2013 vector elements, bold upper case letters (e. g. A) \u2013 matrices, ordinary upper case letters (e. g. A(i, j)) \u2013 matrix elements, calligraphic bold upper case letters (e. g. A) \u2013 for tensors and ordinary calligraphic upper case letters (e. g. A(i) = A(i1, . . . , id)) \u2013 tensor elements, where d is the dimensionality of the tensor A.\nWe will call arrays explicit to highlight cases when they are stored explicitly, i. e. by enumeration of all the elements.\nA d-dimensional array (tensor) A is said to be represented in the TT-format [15] if for each dimension k = 1, . . . , d and for each possible value of the k-th dimension index jk = 1, . . . , nk there exists a matrix Gk[jk] such that all the elements of A can be computed as the following matrix product: A(j1, . . . , jd) = G1[j1]G2[j2] \u00b7 \u00b7 \u00b7Gd[jd]. (1) All the matrices Gk[jk] related to the same dimension k are restricted to be of the same size rk\u22121 \u00d7 rk. The values r0 and rd equal 1 in order to keep the matrix product (1) of size 1\u00d7 1. In what follows we refer to the representation of a tensor in the TT-format as the TT-representation or the TT-decomposition. The sequence {rk} d\nk=0 is referred to as the TT-ranks of the TT-representation of A (or the ranks for short), its maximum \u2013 as the maximal TT-rank of the TT-representation of A: r = maxk=0,...,d rk. The collections of the matrices (Gk[jk])\nnk jk=1\ncorresponding to the same dimension (technically, 3-dimensional arrays Gk) are called the cores.\nOseledets [15, Th. 2.1] shows that for an arbitrary tensor A a TT-representation exists but is not unique. The ranks among different TT-representations can vary and it\u2019s natural to seek a representation with the lowest ranks.\nWe use the symbols Gk[jk](\u03b1k\u22121, \u03b1k) to denote the element of the matrix Gk[jk] in the position (\u03b1k\u22121, \u03b1k), where \u03b1k\u22121 = 1, . . . , rk\u22121, \u03b1k = 1, . . . , rk. Equation (1) can be equivalently rewritten as the sum of the products of the elements of the cores:\nA(j1, . . . , jd) = \u2211\n\u03b10,...,\u03b1d\nG1[j1](\u03b10, \u03b11) . . .Gd[jd](\u03b1d\u22121, \u03b1d). (2)\nThe representation of a tensor A via the explicit enumeration of all its elements requires to store \u220fd\nk=1 nk numbers compared with \u2211d\nk=1 nk rk\u22121 rk numbers if the tensor is stored in the TT-format. Thus, the TT-format is very efficient in terms of memory if the ranks are small.\nAn attractive property of the TT-decomposition is the ability to efficiently perform several types of operations on tensors if they are in the TT-format: basic linear algebra operations, such as the addition of a constant and the multiplication by a constant, the summation and the entrywise product of tensors (the results of these operations are tensors in the TT-format generally with the increased ranks); computation of global characteristics of a tensor, such as the sum of all elements and the Frobenius norm. See [15] for a detailed description of all the supported operations."}, {"heading": "3.1 TT-representations for vectors and matrices", "text": "The direct application of the TT-decomposition to a matrix (2-dimensional tensor) coincides with the low-rank matrix format and the direct TT-decomposition of a vector is equivalent to explicitly storing its elements. To be able to efficiently work with large vectors and matrices the TT-format for them is defined in a special manner. Consider a vector b \u2208 RN , where N =\n\u220fd k=1 nk. We\ncan establish a bijection \u00b5 between the coordinate \u2113 \u2208 {1, . . . , N} of b and a d-dimensional vectorindex \u00b5(\u2113) = (\u00b51(\u2113), . . . , \u00b5d(\u2113)) of the corresponding tensor B, where \u00b5k(\u2113) \u2208 {1, . . . , nk}. The tensor B is then defined by the corresponding vector elements: B(\u00b5(\u2113)) = b\u2113. Building a TTrepresentation of B allows us to establish a compact format for the vector b. We refer to it as a TT-vector. Now we define a TT-representation of a matrix W \u2208 RM\u00d7N , where M = \u220fd\nk=1 mk and\nN = \u220fd\nk=1 nk. Let bijections \u03bd(t) = (\u03bd1(t), . . . , \u03bdd(t)) and \u00b5(\u2113) = (\u00b51(\u2113), . . . , \u00b5d(\u2113)) map row and column indices t and \u2113 of the matrix W to the d-dimensional vector-indices whose k-th dimensions are of length mk and nk respectively, k = 1, . . . , d. From the matrix W we can form a d-dimensional tensor W whose k-th dimension is of length mknk and is indexed by the tuple (\u03bdk(t), \u00b5k(\u2113)). The tensor W can then be converted into the TT-format:\nW (t, \u2113) = W((\u03bd1(t), \u00b51(\u2113)), . . . , (\u03bdd(t), \u00b5d(\u2113))) = G1[\u03bd1(t), \u00b51(\u2113)] . . .Gd[\u03bdd(t), \u00b5d(\u2113)], (3)\nwhere the matrices Gk[\u03bdk(t), \u00b5k(\u2113)], k = 1, . . . , d, serve as the cores with tuple (\u03bdk(t), \u00b5k(\u2113)) being an index. Note that a matrix in the TT-format is not restricted to be square. Although indexvectors \u03bd(t) and \u00b5(\u2113) are of the same length d, the sizes of the domains of the dimensions can vary. We call a matrix in the TT-format a TT-matrix.\nAll operations available for the TT-tensors are applicable to the TT-vectors and the TT-matrices as well (for example one can efficiently sum two TT-matrices and get the result in the TT-format). Additionally, the TT-format allows to efficiently perform the matrix-by-vector (matrix-by-matrix) product. If only one of the operands is in the TT-format, the result would be an explicit vector (matrix); if\nboth operands are in the TT-format, the operation would be even more efficient and the result would be given in the TT-format as well (generally with the increased ranks). For the case of the TT-matrixby-explicit-vector product c = Wb, the computational complexity is O(d r2 mmax{M,N}), where d is the number of the cores of the TT-matrix W , m = maxk=1,...,dmk, r is the maximal rank and N =\n\u220fd k=1 nk is the length of the vector b.\nThe ranks and, correspondingly, the efficiency of the TT-format for a vector (matrix) depend on the choice of the mapping \u00b5(\u2113) (mappings \u03bd(t) and \u00b5(\u2113)) between vector (matrix) elements and the underlying tensor elements. In what follows we use a column-major MATLAB reshape command 1 to form a d-dimensional tensor from the data (e. g. from a multichannel image), but one can choose a different mapping."}, {"heading": "4 TT-layer", "text": "In this section we introduce the TT-layer of a neural network. In short, the TT-layer is a fullyconnected layer with the weight matrix stored in the TT-format. We will refer to a neural network with one or more TT-layers as TensorNet.\nFully-connected layers apply a linear transformation to an N -dimensional input vector x:\ny = Wx+ b, (4)\nwhere the weight matrix W \u2208 RM\u00d7N and the bias vector b \u2208 RM define the transformation.\nA TT-layer consists in storing the weights W of the fully-connected layer in the TT-format, allowing to use hundreds of thousands (or even millions) of hidden units while having moderate number of parameters. To control the number of parameters one can vary the number of hidden units as well as the TT-ranks of the weight matrix.\nA TT-layer transforms a d-dimensional tensor X (formed from the corresponding vector x) to the ddimensional tensor Y (which correspond to the output vector y). We assume that the weight matrix W is represented in the TT-format with the cores Gk[ik, jk]. The linear transformation (4) of a fully-connected layer can be expressed in the tensor form:\nY(i1, . . . , id) = \u2211\nj1,...,jd\nG1[i1, j1] . . .Gd[id, jd]X (j1, . . . , jd) + B(i1, . . . , id). (5)\nDirect application of the TT-matrix-by-vector operation for the Eq. (5) yields the computational complexity of the forward pass O(dr2mmax{m,n}d) = O(dr2mmax{M,N})."}, {"heading": "5 Learning", "text": "Neural networks are usually trained with the stochastic gradient descent algorithm where the gradient is computed using the back-propagation procedure [16]. Back-propagation allows to compute the gradient of a loss-function L with respect to all the parameters of the network. The method starts with the computation of the gradient of L w.r.t. the output of the last layer and proceeds sequentially through the layers in the reversed order while computing the gradient w.r.t. the parameters and the input of the layer making use of the gradients computed earlier. Applied to the fully-connected layers (4) the back-propagation method computes the gradients w.r.t. the input x and the parameters W and b given the gradients \u2202L\n\u2202y w.r.t to the output y:\n\u2202L \u2202x = W \u22ba \u2202L \u2202y ,\n\u2202L\n\u2202W =\n\u2202L \u2202y x\u22ba,\n\u2202L \u2202b = \u2202L \u2202y . (6)\nIn what follows we derive the gradients required to use the back-propagation algorithm with the TTlayer. To compute the gradient of the loss function w.r.t. the bias vector b and w.r.t. the input vector x one can use equations (6). The latter can be applied using the matrix-by-vector product (where the matrix is in the TT-format) with the complexity of O(dr2nmax{m,n}d) = O(dr2nmax{M,N}).\nTo perform a step of stochastic gradient descent one can use equation (6) to compute the gradient of the loss function w.r.t. the weight matrix W , convert the gradient matrix into the TT-format\n1http://www.mathworks.com/help/matlab/ref/reshape.html\n(with the TT-SVD algorithm [15]) and then add this gradient (multiplied by a step size) to the current estimate of the weight matrix: Wk+1 = Wk + \u03b3k \u2202L\u2202W . However, the direct computation of \u2202L \u2202W\nrequires O(MN) memory. A better way to learn the TensorNet parameters is to compute the gradient of the loss function directly w.r.t. the cores of the TT-representation of W .\nIn what follows we use shortened notation for prefix and postfix sequences of indices: i\u2212k := (i1, . . . , ik\u22121), i + k := (ik+1, . . . , id), i = (i \u2212 k , ik, i + k ). We also introduce notations for partial core products: P\u2212k [i \u2212 k , j \u2212 k ] := G1[i1, j1] . . .Gk\u22121[ik\u22121, jk\u22121],\nP+k [i + k , j + k ] := Gk+1[ik+1, jk+1] . . .Gd[id, jd].\n(7)\nWe now rewrite the definition of the TT-layer transformation (5) for any k = 2, . . . , d\u2212 1:\nY(i) = Y(i\u2212k , ik, i + k ) =\n\u2211\nj \u2212 k ,jk,j\n+ k\nP\u2212k [i \u2212 k , j \u2212 k ]Gk[ik, jk]P + k [i + k , j + k ]X (j \u2212 k , jk, j + k ) + B(i). (8)\nThe gradient of the loss function L w.r.t. to the k-th core in the position [\u0303ik, j\u0303k] can be computed using the chain rule:\n\u2202L\n\u2202Gk [\u0303ik, j\u0303k] \ufe38 \ufe37\ufe37 \ufe38\nrk\u22121 \u00d7 rk\n= \u2211\ni\n\u2202L\n\u2202Y(i)\n\u2202Y(i)\n\u2202Gk [\u0303ik, j\u0303k] . (9)\nGiven the gradient matrices \u2202Y(i) \u2202Gk [\u0303ik,j\u0303k] the summation (9) can be done explicitly in O(M rk\u22121 rk) time, where M is the length of the output vector y.\nWe now show how to compute the matrix \u2202Y(i) \u2202Gk [\u0303ik,j\u0303k] for any values of the core index k \u2208 {1, . . . , d} and i\u0303k \u2208 {1, . . . ,mk}, j\u0303k \u2208 {1, . . . , nk}. For any i = (i1, . . . , id) such that ik 6= i\u0303k the value of Y(i) doesn\u2019t depend on the elements of Gk [\u0303ik, j\u0303k] making the corresponding gradient \u2202Y(i)\n\u2202Gk [\u0303ik,j\u0303k]\nequal zero. Similarly, any summand in the Eq. (8) such that jk 6= j\u0303k doesn\u2019t affect the gradient \u2202Y(i) \u2202Gk [\u0303ik,j\u0303k] . These observations allow us to consider only ik = i\u0303k and jk = j\u0303k.\nY(i\u2212k , i\u0303k, i + k ) is a linear function of the core Gk [\u0303ik, j\u0303k] and its gradient equals the following expression:\n\u2202Y(i\u2212k , i\u0303k, i + k )\n\u2202Gk [\u0303ik, j\u0303k] =\n\u2211\nj\u2212 k ,j+ k\n( P\u2212k [i \u2212 k , j \u2212 k ] )\u22ba \ufe38 \ufe37\ufe37 \ufe38\nrk\u22121 \u00d71\n( P+k [i + k , j + k ] )\u22ba \ufe38 \ufe37\ufe37 \ufe38\n1\u00d7rk\nX (j\u2212k , j\u0303k, j + k ). (10)\nWe denote the partial sum vector as Rk[j \u2212 k , j\u0303k, i + k ] \u2208 R rk :\nRk[j1, . . . , jk\u22121, j\u0303k, ik+1, . . . , id] = Rk[j \u2212 k , j\u0303k, i + k ] =\n\u2211\nj +\nk\nP+k [i + k , j + k ] X (j \u2212 k , j\u0303k, j + k ).\nVectors Rk[j \u2212 k , j\u0303k, i + k ] for all the possible values of k, j \u2212 k , j\u0303k and i + k can be computed via dynamic programming (by pushing sums w.r.t. each jk+1, . . . , jd inside the equation and summing out one index at a time) in O(dr2mmax{M,N}). Substituting these vectors into (10) and using (again) dynamic programming yields us all the necesary matrices for summation (9). The overall computational complexity of the backward pass is O(d2 r4 mmax{M,N}).\nThe presented algorithm reduces to a sequence of matrix-by-matrix products and permutations of dimensions and thus can be accelerated on a GPU device."}, {"heading": "6 Experiments", "text": ""}, {"heading": "6.1 Parameters of the TT-layer", "text": "In this experiment we investigate the properties of the TT-layer and compare different strategies for setting its parameters: dimensions of the tensors representing the input/output of the layer and the TT-ranks of the compressed weight matrix. We run the experiment on the MNIST dataset [13] for the task of handwritten-digit recognition. As a baseline we use a neural network with two fullyconnected layers (1024 hidden units) and rectified linear unit (ReLU) achieving 1.9% error on the test set. For more reshaping options we resize the original 28\u00d7 28 images to 32\u00d7 32.\nWe train several networks differing in the parameters of the single TT-layer. The networks contain the following layers: the TT-layer with weight matrix of size 1024\u00d71024, ReLU, the fully-connected layer with the weight matrix of size 1024\u00d7 10. We test different ways of reshaping the input/output tensors and try different ranks of the TT-layer. As a simple compression baseline in the place of the TT-layer we use the fully-connected layer such that the rank of the weight matrix is bounded (implemented as follows: the two consecutive fully-connected layers with weight matrices of sizes 1024\u00d7 r and r\u00d71024, where r controls the matrix rank and the compression factor). The results of the experiment are shown in Figure 1. We conclude that the TT-ranks provide much better flexibility than the matrix rank when applied at the same compression level. In addition, we observe that the TT-layers with too small number of values for each tensor dimension and with too few dimensions perform worse than their more balanced counterparts.\nComparison with HashedNet [3]. We consider a two-layered neural network with 1024 hidden units and replace both fully-connected layers by the TT-layers. By setting all the TT-ranks in the network to 8 we achieved the test error of 1.6% with 12 602 parameters in total and by setting all the TT-ranks to 6 the test error of 1.9% with 7 698 parameters. Chen et al. [3] report results on the same architecture. By tying random subsets of weights they compressed the network by the factor of 64 to the 12 720 parameters in total with the test error equal 2.79%."}, {"heading": "6.2 CIFAR-10", "text": "CIFAR-10 dataset [10] consists of 32 \u00d7 32 3-channel images assigned to 10 different classes: airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck. The dataset contains 50000 train and 10000 test images. Following [8] we preprocess the images by subtracting the mean and performing global contrast normalization and ZCA whitening.\nAs a baseline we use the CIFAR-10 Quick [20] CNN, which consists of convolutional, pooling and non-linearity layers followed by two fully-connected layers of sizes 1024\u00d7 64 and 64\u00d7 10. We fix the convolutional part of the network and substitute the fully-connected part by a 1024\u00d7N TT-layer followed by ReLU and by a N \u00d7 10 fully-connected layer. With N = 3125 hidden units (contrary to 64 in the original network) we achieve the test error of 23.13% without fine-tuning which is slightly better than the test error of the baseline (23.25%). The TT-layer treated input and output vectors as 4 \u00d7 4 \u00d7 4 \u00d7 4 \u00d7 4 and 5 \u00d7 5 \u00d7 5 \u00d7 5 \u00d7 5 tensors respectively. All the TT-ranks equal 8, making the number of the parameters in the TT-layer equal 4 160. The compression rate of the TensorNet compared with the baseline w.r.t. all the parameters is 1.24. In addition, substituting the\nboth fully-connected layers by the TT-layers yields the test error of 24.39% and reduces the number of parameters of the fully-connected layer matrices by the factor of 11.9 and the total parameter number by the factor of 1.7.\nFor comparison, in [5] the fully-connected layers in a CIFAR-10 CNN were compressed by the factor of at most 4.7 times with the loss of about 2% in accuracy."}, {"heading": "6.2.1 Wide and shallow network", "text": "With sufficient amount of hidden units, even a neural network with two fully-connected layers and sigmoid non-linearity can approximate any decision boundary [4]. Traditionally, very wide shallow networks are not considered because of high computational and memory demands and the overfitting risk. TensorNet can potentially address both issues. We use a three-layered TensorNet of the following architecture: the TT-layer with the weight matrix of size 3 072\u00d7 262 144, ReLU, the TT-layer with the weight matrix of size 262 144\u00d7 4 096, ReLU, the fully-connected layer with the weight matrix of size 4 096 \u00d7 10. We report the test error of 31.47% which is (to the best of our knowledge) the best result achieved by a non-convolutional neural network."}, {"heading": "6.3 ImageNet", "text": "In this experiment we evaluate the TT-layers on a large scale task. We consider the 1000-class ImageNet ILSVRC-2012 dataset [17], which consist of 1.2 million training images and 50 000 validation images. We use deep the CNNs vgg-16 and vgg-19 [19] as the reference models2. Both networks consist of the two parts: the convolutional and the fully-connected parts. In the both networks the second part consist of 3 fully-connected layers with weight matrices of sizes 25088\u00d7 4096, 4096\u00d7 4096 and 4096\u00d7 1000.\nIn each network we substitute the first fully-connected layer with the TT-layer. To do this we reshape the 25088-dimensional input vectors to the tensors of the size 2\u00d7 7\u00d7 8\u00d7 8 \u00d7 7\u00d7 4 and the 4096- dimensional output vectors to the tensors of the size 4 \u00d7 4 \u00d7 4 \u00d7 4 \u00d7 4 \u00d7 4. The remaining fullyconnected layers are initialized randomly. The parameters of the convolutional parts are kept fixed as trained by Simonyan and Zisserman [19]. We train the TT-layer and the fully-connected layers on the training set. In Table 2 we vary the ranks of the TT-layer and report the compression factor of the TT-layers (vs. the original fully-connected layer), the resulting compression factor of the whole network, and the top 1 and top 5 errors on the validation set. In addition, we substitute the second fully-connected layer with the TT-layer. As a baseline compression method we constrain the matrix rank of the weight matrix of the first fully-connected layer using the approach of [2].\nIn Table 2 we observe that the TT-layer in the best case manages to reduce the number of the parameters in the matrixW of the largest fully-connected layer by a factor of 194 622 (from 25088\u00d7 4096 parameters to 528) while increasing the top 5 error from 11.2 to 11.5. The compression factor of the whole network remains at the level of 3.9 because the TT-layer stops being the storage bottleneck. By compressing the largest of the remaining layers the compression factor goes up\n2After we had started to experiment on the vgg-16 network the vgg-* networks have been improved by the authors. Thus, we report the results on a slightly outdated version of vgg-16 and the up-to-date version of vgg-19.\nto 7.4. The baseline method when providing similar compression rates significantly increases the error.\nFor comparison, consider the results of [23] obtained for the compression of the fully-connected layers of the Krizhevsky-type network [11] with the Fastfood method. The model achieves compression factors of 2-3 without decreasing the network error."}, {"heading": "6.4 Implementation details", "text": "In all experiments we use our MATLAB extension of the MatConvNet framework3 [21]. For the operations related to the TT-format we use the TT-Toolbox4 implemented in MATLAB as well. The experiments were performed on a computer with a quad-core Intel Core i5-4460 CPU, 16 GB RAM and a single NVidia Geforce GTX 980 GPU. We report the running times and the memory usage at the forward pass of the TT-layer and the baseline fully-connected layer in Table 3.\nWe train all the networks with stochastic gradient descent with momentum (coefficient 0.9). We initialize all the parameters of the TT- and fully-connected layers with a Gaussian noise and put L2-regularization (weight 0.0005) on them.\nThe source code of our method is publicly available5."}, {"heading": "7 Discussion and future work", "text": "Recent studies indicate high redundancy in the current neural network parametrization. To exploit this redundancy we propose to use the TT-decomposition framework on the weight matrix of a fully-connected layer and to use the cores of the decomposition as the parameters of the layer. This allows us to train the fully-connected layers compressed by up to 200 000\u00d7 compared with the explicit parametrization without significant error increase. Our experiments show that it is possible to capture complex dependencies within the data by using much more compact representations. On the other hand it becomes possible to use much wider layers than was available before and the preliminary experiments on the CIFAR-10 dataset show that wide and shallow TensorNets achieve promising results (setting new state-of-the-art for non-convolutional neural networks).\nAnother appealing property of the TT-layer is faster inference time (compared with the corresponding fully-connected layer). All in all a wide and shallow TensorNet can become a time and memory efficient model to use in real time applications and on mobile devices.\nThe main limiting factor for an M \u00d7 N fully-connected layer size is its parameters number MN . The limiting factor for an M\u00d7N TT-layer is the maximal linear size max{M,N}. As a future work we plan to consider the inputs and outputs of layers in the TT-format thus completely eliminating the dependency on M and N and allowing billions of hidden units in a TT-layer.\nAcknowledgements. We would like to thank Ivan Oseledets for valuable discussions. A. Novikov, D. Podoprikhin, D. Vetrov were supported by RFBR project No. 15-31-20596 (mol-a-ved) and by Microsoft: Moscow State University Joint Research Center (RPD 1053945). A. Osokin was supported by the MSR-INRIA Joint Center. The results of the tensor toolbox application are supported by Russian Science Foundation No. 14-11-00659.\n3http://www.vlfeat.org/matconvnet/ 4https://github.com/oseledets/TT-Toolbox 5https://github.com/Bihaqo/TensorNet"}], "references": [{"title": "Experimental determination of precision requirements for back-propagation training of artificial neural networks", "author": ["K. Asanovi", "N. Morgan"], "venue": "International Computer Science Institute, Tech. Rep., 1991.", "citeRegEx": "1", "shortCiteRegEx": null, "year": 1991}, {"title": "Do deep nets really need to be deep?", "author": ["J. Ba", "R. Caruana"], "venue": "Advances in Neural Information Processing Systems", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2014}, {"title": "Compressing neural networks with the hashing trick", "author": ["W. Chen", "J.T. Wilson", "S. Tyree", "K.Q. Weinberger", "Y. Chen"], "venue": "International Conference on Machine Learning (ICML), 2015, pp. 2285\u20132294.", "citeRegEx": "3", "shortCiteRegEx": null, "year": 2015}, {"title": "Approximation by superpositions of a sigmoidal function", "author": ["G. Cybenko"], "venue": "Mathematics of control, signals and systems, pp. 303\u2013314, 1989.", "citeRegEx": "4", "shortCiteRegEx": null, "year": 1989}, {"title": "Predicting parameters in deep learning", "author": ["M. Denil", "B. Shakibi", "L. Dinh", "M. Ranzato", "N. de Freitas"], "venue": "Advances in Neural Information Processing Systems 26 (NIPS), 2013, pp. 2148\u20132156.", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2013}, {"title": "Exploiting linear structure within convolutional networks for efficient evaluation", "author": ["E. Denton", "W. Zaremba", "J. Bruna", "Y. LeCun", "R. Fergus"], "venue": "Advances in Neural Information Processing Systems 27 (NIPS), 2014, pp. 1269\u20131277.", "citeRegEx": "6", "shortCiteRegEx": null, "year": 2014}, {"title": "Compressing deep convolutional networks using vector quantization", "author": ["Y. Gong", "L. Liu", "M. Yang", "L. Bourdev"], "venue": "arXiv preprint, no. 1412.6115, 2014.", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2014}, {"title": "Maxout networks", "author": ["I.J. Goodfellow", "D. Warde-Farley", "M. Mirza", "A. Courville", "Y. Bengio"], "venue": "International Conference on Machine Learning (ICML), 2013, pp. 1319\u20131327.", "citeRegEx": "8", "shortCiteRegEx": null, "year": 2013}, {"title": "Deep learning with limited numerical precision", "author": ["S. Gupta", "A. Agrawal", "K. Gopalakrishnan", "P. Narayanan"], "venue": "International Conference on Machine Learning (ICML), 2015, pp. 1737\u20131746.", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2015}, {"title": "Learning multiple layers of features from tiny images", "author": ["A. Krizhevsky"], "venue": "Master\u2019s thesis, Computer Science Department, University of Toronto, 2009.", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "Imagenet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"], "venue": "Advances in Neural Information Processing Systems 25 (NIPS), 2012, pp. 1097\u20131105.", "citeRegEx": "11", "shortCiteRegEx": null, "year": 2012}, {"title": "Speeding-up convolutional neural networks using fine-tuned CP-decomposition", "author": ["V. Lebedev", "Y. Ganin", "M. Rakhuba", "I. Oseledets", "V. Lempitsky"], "venue": "International Conference on Learning Representations (ICLR), 2014.", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2014}, {"title": "The MNIST database of handwritten digits", "author": ["Y. LeCun", "C. Cortes", "C.J.C. Burges"], "venue": "1998.", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1998}, {"title": "Putting MRFs on a Tensor Train", "author": ["A. Novikov", "A. Rodomanov", "A. Osokin", "D. Vetrov"], "venue": "International Conference on Machine Learning (ICML), 2014, pp. 811\u2013819.", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2014}, {"title": "Tensor-Train decomposition", "author": ["I.V. Oseledets"], "venue": "SIAM J. Scientific Computing, vol. 33, no. 5, pp. 2295\u2013 2317, 2011.", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2011}, {"title": "Learning representations by back-propagating errors", "author": ["D.E. Rumelhart", "G.E. Hinton", "R.J. Williams"], "venue": "Nature, vol. 323, no. 6088, pp. 533\u2013536, 1986.", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1986}, {"title": "Imagenet large scale visual recognition challenge", "author": ["O. Russakovsky", "J. Deng", "H. Su", "J. Krause", "S. Satheesh", "S. Ma", "Z. Huang", "A. Karpathy", "A. Khosla", "M. Bernstein", "A.C. Berg", "L. Fei-Fei"], "venue": "International Journal of Computer Vision (IJCV), 2015.", "citeRegEx": "17", "shortCiteRegEx": null, "year": 2015}, {"title": "Low-rank matrix factorization for deep neural network training with high-dimensional output targets", "author": ["T.N. Sainath", "B. Kingsbury", "V. Sindhwani", "E. Arisoy", "B. Ramabhadran"], "venue": "International Conference of Acoustics, Speech, and Signal Processing (ICASSP), 2013, pp. 6655\u20136659.", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2013}, {"title": "Very deep convolutional networks for large-scale image recognition", "author": ["K. Simonyan", "A. Zisserman"], "venue": "International Conference on Learning Representations (ICLR), 2015.", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2015}, {"title": "Practical bayesian optimization of machine learning algorithms", "author": ["J. Snoek", "H. Larochelle", "R.P. Adams"], "venue": "Advances in Neural Information Processing Systems 25 (NIPS), 2012, pp. 2951\u20132959.", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2012}, {"title": "MatConvNet \u2013 convolutional neural networks for MATLAB", "author": ["A. Vedaldi", "K. Lenc"], "venue": "CoRR, vol. abs/1412.4564, 2014.", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2014}, {"title": "Restructuring of deep neural network acoustic models with singular value decomposition", "author": ["J. Xue", "J. Li", "Y. Gong"], "venue": "Interspeech, 2013, pp. 2365\u20132369.", "citeRegEx": "22", "shortCiteRegEx": null, "year": 2013}, {"title": "Deep fried convnets", "author": ["Z. Yang", "M. Moczulski", "M. Denil", "N. de Freitas", "A. Smola", "L. Song", "Z. Wang"], "venue": "arXiv preprint, no. 1412.7149, 2014.", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2014}, {"title": "Enabling high-dimensional hierarchical uncertainty quantification by ANOVA and tensor-train decomposition", "author": ["Z. Zhang", "X. Yang", "I.V. Oseledets", "G.E. Karniadakis", "L. Daniel"], "venue": "Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on, pp. 63\u201376, 2014. 9", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2014}], "referenceMentions": [{"referenceID": 14, "context": "In this paper we convert the dense weight matrices of the fully-connected layers to the Tensor Train [15] format such that the number of parameters is reduced by a huge factor and at the same time the expressive power of the layer is preserved.", "startOffset": 101, "endOffset": 105}, {"referenceID": 18, "context": "In particular, for the Very Deep VGG networks [19] we report the compression factor of the dense weight matrix of a fully-connected layer up to 200000 times leading to the compression factor of the whole network up to 7 times.", "startOffset": 46, "endOffset": 50}, {"referenceID": 10, "context": "For example, convolutional neural networks (CNNs) [11, 19] show by a large margin superior performance on the task of image classification.", "startOffset": 50, "endOffset": 58}, {"referenceID": 18, "context": "For example, convolutional neural networks (CNNs) [11, 19] show by a large margin superior performance on the task of image classification.", "startOffset": 50, "endOffset": 58}, {"referenceID": 16, "context": "These models have thousands of nodes and millions of learnable parameters and are trained using millions of images [17] on powerful Graphics Processing Units (GPUs).", "startOffset": 115, "endOffset": 119}, {"referenceID": 14, "context": "We represent the dense weight matrix of the fully-connected layers in a compact multi-linear format, Tensor Train (TT-format) [15].", "startOffset": 126, "endOffset": 130}, {"referenceID": 15, "context": "The resulting layer is compatible with the existing training algorithms for neural networks because all the derivatives required by the back-propagation algorithm [16] can be computed using the properties of the TTformat.", "startOffset": 163, "endOffset": 167}, {"referenceID": 12, "context": "We apply our method to popular network architectures proposed for several datasets of different scales: MNIST [13], CIFAR-10 [10], ImageNet [11].", "startOffset": 110, "endOffset": 114}, {"referenceID": 9, "context": "We apply our method to popular network architectures proposed for several datasets of different scales: MNIST [13], CIFAR-10 [10], ImageNet [11].", "startOffset": 125, "endOffset": 129}, {"referenceID": 10, "context": "We apply our method to popular network architectures proposed for several datasets of different scales: MNIST [13], CIFAR-10 [10], ImageNet [11].", "startOffset": 140, "endOffset": 144}, {"referenceID": 18, "context": "In particular, modern networks reached the memory limit with 89% [19] or even 100% [22] memory occupied by the weights of the fully-connected layers so it is not surprising that numerous attempts have been made to make the fully-connected layers more compact.", "startOffset": 65, "endOffset": 69}, {"referenceID": 21, "context": "In particular, modern networks reached the memory limit with 89% [19] or even 100% [22] memory occupied by the weights of the fully-connected layers so it is not surprising that numerous attempts have been made to make the fully-connected layers more compact.", "startOffset": 83, "endOffset": 87}, {"referenceID": 4, "context": "Recent studies show that the weight matrix of the fully-connected layer is highly redundant and by restricting its matrix rank it is possible to greatly reduce the number of parameters without significant drop in the predictive accuracy [5, 18, 22].", "startOffset": 237, "endOffset": 248}, {"referenceID": 17, "context": "Recent studies show that the weight matrix of the fully-connected layer is highly redundant and by restricting its matrix rank it is possible to greatly reduce the number of parameters without significant drop in the predictive accuracy [5, 18, 22].", "startOffset": 237, "endOffset": 248}, {"referenceID": 21, "context": "Recent studies show that the weight matrix of the fully-connected layer is highly redundant and by restricting its matrix rank it is possible to greatly reduce the number of parameters without significant drop in the predictive accuracy [5, 18, 22].", "startOffset": 237, "endOffset": 248}, {"referenceID": 2, "context": "An alternative approach to the problem of model compression is to tie random subsets of weights using special hashing techniques [3].", "startOffset": 129, "endOffset": 132}, {"referenceID": 0, "context": "Memory consumption can also be reduced by using lower numerical precision [1, 9] or allowing fewer possible carefully chosen parameter values [7].", "startOffset": 74, "endOffset": 80}, {"referenceID": 8, "context": "Memory consumption can also be reduced by using lower numerical precision [1, 9] or allowing fewer possible carefully chosen parameter values [7].", "startOffset": 74, "endOffset": 80}, {"referenceID": 6, "context": "Memory consumption can also be reduced by using lower numerical precision [1, 9] or allowing fewer possible carefully chosen parameter values [7].", "startOffset": 142, "endOffset": 145}, {"referenceID": 14, "context": "Instead of searching for low-rank approximation of the weight matrix we treat it as multi-dimensional tensor and apply the Tensor Train decomposition algorithm [15].", "startOffset": 160, "endOffset": 164}, {"referenceID": 13, "context": "[14, 24].", "startOffset": 0, "endOffset": 8}, {"referenceID": 23, "context": "[14, 24].", "startOffset": 0, "endOffset": 8}, {"referenceID": 1, "context": "A recent work [2] shows that it is possible to construct wide and shallow (i.", "startOffset": 14, "endOffset": 17}, {"referenceID": 5, "context": "Matrix and tensor decompositions were recently used to speed up the inference time of CNNs [6, 12].", "startOffset": 91, "endOffset": 98}, {"referenceID": 11, "context": "Matrix and tensor decompositions were recently used to speed up the inference time of CNNs [6, 12].", "startOffset": 91, "endOffset": 98}, {"referenceID": 11, "context": "[12] used the CP-decomposition to compress a 4-dimensional convolution kernel and then used the properties of the decomposition to speed up the inference time.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "A d-dimensional array (tensor) A is said to be represented in the TT-format [15] if for each dimension k = 1, .", "startOffset": 76, "endOffset": 80}, {"referenceID": 14, "context": "See [15] for a detailed description of all the supported operations.", "startOffset": 4, "endOffset": 8}, {"referenceID": 15, "context": "Neural networks are usually trained with the stochastic gradient descent algorithm where the gradient is computed using the back-propagation procedure [16].", "startOffset": 151, "endOffset": 155}, {"referenceID": 14, "context": "(with the TT-SVD algorithm [15]) and then add this gradient (multiplied by a step size) to the current estimate of the weight matrix: Wk+1 = Wk + \u03b3k \u2202L \u2202W .", "startOffset": 27, "endOffset": 31}, {"referenceID": 12, "context": "We run the experiment on the MNIST dataset [13] for the task of handwritten-digit recognition.", "startOffset": 43, "endOffset": 47}, {"referenceID": 2, "context": "Comparison with HashedNet [3].", "startOffset": 26, "endOffset": 29}, {"referenceID": 2, "context": "[3] report results on the same architecture.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "CIFAR-10 dataset [10] consists of 32 \u00d7 32 3-channel images assigned to 10 different classes: airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck.", "startOffset": 17, "endOffset": 21}, {"referenceID": 7, "context": "Following [8] we preprocess the images by subtracting the mean and performing global contrast normalization and ZCA whitening.", "startOffset": 10, "endOffset": 13}, {"referenceID": 19, "context": "As a baseline we use the CIFAR-10 Quick [20] CNN, which consists of convolutional, pooling and non-linearity layers followed by two fully-connected layers of sizes 1024\u00d7 64 and 64\u00d7 10.", "startOffset": 40, "endOffset": 44}, {"referenceID": 4, "context": "For comparison, in [5] the fully-connected layers in a CIFAR-10 CNN were compressed by the factor of at most 4.", "startOffset": 19, "endOffset": 22}, {"referenceID": 3, "context": "With sufficient amount of hidden units, even a neural network with two fully-connected layers and sigmoid non-linearity can approximate any decision boundary [4].", "startOffset": 158, "endOffset": 161}, {"referenceID": 16, "context": "We consider the 1000-class ImageNet ILSVRC-2012 dataset [17], which consist of 1.", "startOffset": 56, "endOffset": 60}, {"referenceID": 18, "context": "We use deep the CNNs vgg-16 and vgg-19 [19] as the reference models2.", "startOffset": 39, "endOffset": 43}, {"referenceID": 18, "context": "The parameters of the convolutional parts are kept fixed as trained by Simonyan and Zisserman [19].", "startOffset": 94, "endOffset": 98}, {"referenceID": 1, "context": "As a baseline compression method we constrain the matrix rank of the weight matrix of the first fully-connected layer using the approach of [2].", "startOffset": 140, "endOffset": 143}, {"referenceID": 22, "context": "For comparison, consider the results of [23] obtained for the compression of the fully-connected layers of the Krizhevsky-type network [11] with the Fastfood method.", "startOffset": 40, "endOffset": 44}, {"referenceID": 10, "context": "For comparison, consider the results of [23] obtained for the compression of the fully-connected layers of the Krizhevsky-type network [11] with the Fastfood method.", "startOffset": 135, "endOffset": 139}, {"referenceID": 20, "context": "In all experiments we use our MATLAB extension of the MatConvNet framework3 [21].", "startOffset": 76, "endOffset": 80}], "year": 2015, "abstractText": "Deep neural networks currently demonstrate state-of-the-art performance in several domains. At the same time, models of this class are very demanding in terms of computational resources. In particular, a large amount of memory is required by commonly used fully-connected layers, making it hard to use the models on low-end devices and stopping the further increase of the model size. In this paper we convert the dense weight matrices of the fully-connected layers to the Tensor Train [15] format such that the number of parameters is reduced by a huge factor and at the same time the expressive power of the layer is preserved. In particular, for the Very Deep VGG networks [19] we report the compression factor of the dense weight matrix of a fully-connected layer up to 200000 times leading to the compression factor of the whole network up to 7 times.", "creator": "LaTeX with hyperref package"}}}