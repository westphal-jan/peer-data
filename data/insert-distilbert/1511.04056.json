{"id": "1511.04056", "review": {"conference": "NIPS", "VERSION": "v1", "DATE_OF_SUBMISSION": "12-Nov-2015", "title": "Efficient Non-greedy Optimization of Decision Trees", "abstract": "decision trees branching and randomized forests are both widely used algorithms in computer vision and machine learning. standard algorithms for algorithms decision tree induction optimize the split functions one node at a time according to some splitting criteria. this evolutionary greedy procedure often also leads to suboptimal evolutionary trees. in this paper, we might present an algorithm for partly optimizing the split functions at all levels of the tree ordering jointly with the leaf parameters, based on performing a branching global objective. we systematically show that the problem of finding optimal linear - combination ( oblique ) splits for decision trees is related to structured prediction with latent variables, and we formulate a convex - concave upper bound on the tree's respective empirical loss. the run - clock time of computing the gradient of the proposed surrogate objective with respect to each training exemplar is termed quadratic in the the estimate tree depth, and thus training deep trees is feasible. the use of stochastic gradient descent for optimization programs enables effective training with large matching datasets. experiments on several fuzzy classification benchmarks demonstrate that the resulting non - greedy decision trees outperform greedy filtered decision tree baselines.", "histories": [["v1", "Thu, 12 Nov 2015 20:32:28 GMT  (3503kb,D)", "http://arxiv.org/abs/1511.04056v1", "in NIPS 2015"]], "COMMENTS": "in NIPS 2015", "reviews": [], "SUBJECTS": "cs.LG cs.CV", "authors": ["mohammad norouzi 0002", "maxwell d collins", "matthew a johnson", "david j fleet", "pushmeet kohli"], "accepted": true, "id": "1511.04056"}, "pdf": {"name": "1511.04056.pdf", "metadata": {"source": "CRF", "title": "Efficient Non-greedy Optimization of Decision Trees", "authors": ["Mohammad Norouzi", "Maxwell D. Collins", "Matthew Johnson", "David J. Fleet", "Pushmeet Kohli"], "emails": [], "sections": [{"heading": "1 Introduction", "text": "Decision trees and forests [6, 22, 5] have a long and rich history in machine learning [10, 7]. Recent years have seen an increase in their popularity, owing to their computational efficiency and applicability to large-scale classification and regression tasks. A case in point is Microsoft Kinect where decision trees are trained on millions of exemplars to enable real-time human pose estimation from depth images [23].\nConventional algorithms for decision tree induction are greedy. They grow a tree one node at a time following procedures laid out decades ago by frameworks such as ID3 [22] and CART [6]. While recent work has proposed new objective functions to guide greedy algorithms [21, 12], it continues to be the case that decision tree applications (e.g., [9, 14]) utilize the same dated methods of tree induction. Greedy decision tree induction builds a binary tree via a recursive procedure as follows: beginning with a single node, indexed by i, a split function si is optimized based on a corresponding subset of the training data Di such that Di is split into two subsets, which in turn define the training data for the two children of the node i. The intrinsic limitation of this procedure is that the optimization of si is solely conditioned on Di, i.e., there is no ability to fine-tune the split function si based on the results of training at lower levels of the tree. This paper addresses this limitation by proposing a general framework for non-greedy learning of the split parameters for tree-based methods. We focus on binary trees, while extension to n-ary trees is possible. We show that our joint optimization of the split functions at different levels of the tree under a global objective not only promotes cooperation between the split nodes to create more compact trees, but also leads to better generalization performance.\n\u2217Part of this work was done while M. Norouzi and M. D. Collins were at Microsoft Research, Cambridge.\nar X\niv :1\n51 1.\n04 05\n6v 1\n[ cs\n.L G\n] 1\n2 N\nov 2\nOne of the key contributions of this work is establishing a link between the decision tree optimization problem and the problem of structured prediction with latent variables [26]. We present a novel formulation of the decision tree learning that associates a binary latent decision variable with each split node in the tree and uses such latent variables to formulate the tree\u2019s empirical loss. Inspired by advances in structured prediction [24, 25, 26], we propose a convex-concave upper bound on the empirical loss. This bound acts as a surrogate objective that is optimized using stochastic gradient descent (SGD) to find a locally optimal configuration of the split functions. One complication introduced by this particular formulation is that the number of latent decision variables grows exponentially with the tree depth d. As a consequence, each gradient update will have a complexity of O(2dp) for p-dimensional inputs. One of our technical contributions is showing how this complexity can be reduced to O(d2p) by modifying the surrogate objective, thereby enabling efficient training of deep trees."}, {"heading": "2 Related work", "text": "Finding optimal split functions at different levels of a decision tree according to some global objective, such as a regularized empirical risk, is NP-complete [11] due to the discrete and sequential nature of the decisions in a tree. Thus, finding an efficient alternative to the greedy approach has remained a difficult objective despite many prior attempts.\nBennett [2] proposes a non-greedy multi-linear programming based approach for global tree optimization and shows that the method produces trees that have higher classification accuracy than standard greedy trees. However, their method is limited to binary classification with 0-1 loss and has a high computation complexity, making it only applicable to trees with few nodes.\nThe work in [15] proposes a means for training decision forests in an online setting by incrementally extending the trees as new data points are added. As opposed to a naive incremental growing of the trees, this work models the decision trees with Mondrian Processes.\nThe Hierarchical Mixture of Experts model [13] uses soft splits rather than hard binary decisions to capture situations where the transition from low to high response is gradual. The use of soft splits at internal nodes of the tree yields a probabilistic model in which the log-likelihood is a smooth function of the unknown parameters. Hence, training based on log-likelihood is amenable to numerical optimization via methods such as expectation maximization (EM). That said, the soft splits necessitate the evaluation of all or most of the experts for each data point, so much of the computational advantage of the decision trees are lost.\nMurthy and Salzburg [17] argue that non-greedy tree learning methods that work by looking ahead are unnecessary and sometimes harmful. This is understandable since their methods work by minimizing empirical loss without any regularization, which is prone to overfitting. To avoid this problem, it is a common practice (see Breiman [5] or Criminisi and Shotton [7] for an overview) to limit the tree depth and introduce limits on the number of training instances below which a tree branch is not extended, or to force a diverse ensemble of trees (i.e., a decision forest) through the use of bagging [5] or boosting [8]. Bennett and Blue [3] describe a different way to overcome overfitting by using max-margin framework and the Support Vector Machines (SVM) at the split nodes of the tree. Subsequently, Bennett et al. [4] show how enlarging the margin of decision tree classifiers results in better generalization performance.\nOur formulation for decision tree induction improves on prior art in a number of ways. Not only does our latent variable formulation of decision trees enable efficient learning, but it also handles any general loss function while not sacrificing the O(dp) complexity of inference imparted by the tree structure. Further, our surrogate objective provides a natural way to regularize the joint optimization of tree parameters to discourage overfitting."}, {"heading": "3 Problem formulation", "text": "For ease of exposition, this paper focuses on binary classification trees, withm internal (split) nodes, and m+ 1 leaf (terminal) nodes. Note that in a binary tree the number of leaves is always one more than the number of internal (non-leaf) nodes. An input, x \u2208 Rp, is directed from the root of the tree down through internal nodes to a leaf node. Each leaf node specifies a distribution over k class labels. Each internal node, indexed by i \u2208 {1, . . . ,m}, performs a binary test by evaluating a node-\nspecific split function si(x) : Rp \u2192 {\u22121,+1}. If si(x) evaluates to \u22121, then x is directed to the left child of node i. Otherwise, x is directed to the right child. And so on down the tree. Each split function si(\u00b7), parameterized by a weight vector wi, is assumed to be a linear threshold function, i.e., si(x) = sgn(wiTx). We incorporate an offset parameter to obtain split functions of the form sgn(wi\nTx\u2212 bi) by appending a constant \u201c\u22121\u201d to the input feature vector. Each leaf node, indexed by j \u2208 {1, . . . ,m+ 1}, specifies a conditional probability distribution over class labels, l \u2208 {1, . . . , k}, denoted p(y = l | j). Leaf distributions are parametrized with a vector of unnormalized predictive log-probabilities, denoted \u03b8j \u2208 Rk, and a softmax function; i.e.,\np(y = l | j) = exp\n{ \u03b8j[l] }\u2211k \u03b1=1 exp { \u03b8j[\u03b1]\n} , (1) where \u03b8j[\u03b1] denotes the \u03b1th element of vector \u03b8j .\nThe parameters of the tree comprise the m internal weight vectors, {wi}mi=1, and the m+ 1 vectors of unnormalized log-probabilities, one for each leaf node, {\u03b8j}m+1j=1 . We pack these parameters into two matrices W \u2208 Rm\u00d7p and \u0398 \u2208 R(m+1)\u00d7k whose rows comprise weight vectors and leaf parameters, i.e., W \u2261 [w1, . . . ,wm]T and \u0398 \u2261 [\u03b81, . . . ,\u03b8m+1]T. Given a dataset of input-output pairs, D \u2261 {xz, yz}nz=1, where yz \u2208 {1, . . . , k} is the ground truth class label associated with input xz \u2208 Rp, we wish to find a joint configuration of oblique splits W and leaf parameters \u0398 that minimize some measure of misclassification loss on the training dataset. Joint optimization of the split functions and leaf parameters according to a global objective is known to be extremely challenging [11] due to the discrete and sequential nature of the splitting decisions within the tree.\nOne can evaluate all of the split functions, for every internal node of the tree, on an input x by computing sgn(Wx), where sgn(\u00b7) is the element-wise sign function. One key idea that helps linking decision tree learning to latent structured prediction is to think of anm-bit vector of potential split decisions, e.g., h = sgn(Wx) \u2208 {\u22121,+1}m, as a latent variable. Such a latent variable determines the leaf to which a data point is directed, and then classified using the leaf parameters. To formulate the loss for an input-output pair, (x, y), we introduce a tree navigation function f : Hm \u2192 Im+1 that maps an m-bit sequence of split decisions (Hm \u2261 {\u22121,+1}m) to an indicator vector that specifies a 1-of-(m+ 1) encoding. Such an indicator vector is only non-zero at the index of the selected leaf. Fig. 1 illustrates the tree navigation function for a tree with 3 internal nodes.\nUsing the notation developed above, \u03b8 = \u0398Tf(sgn(Wx)) represents the parameters corresponding to the leaf to which x is directed by the split functions in W . A generic loss function of the form `(\u03b8, y) measures the discrepancy between the model prediction based on \u03b8 and an output y. For the softmax model given by (1), a natural loss is the negative log probability of the correct label, referred to as log loss,\n`(\u03b8, y) = `log(\u03b8, y) = \u2212 \u03b8[y] + log ( k\u2211 \u03b2=1 exp(\u03b8[\u03b2]) ) . (2)\nFor regression tasks, when y \u2208 Rq , and the value of \u03b8 \u2208 Rq is directly emitted as the model prediction, a natural choice of ` is squared loss,\n`(\u03b8,y) = `sqr(\u03b8,y) = \u2016\u03b8 \u2212 y\u20162 . (3) One can adopt other forms of loss within our decision tree learning framework as well. The goal of learning is to find W and \u0398 that minimize empirical loss, for a given training set D, that is,\nL(W,\u0398;D) = \u2211\n(x,y)\u2208D\n` ( \u0398Tf(sgn(Wx)), y ) . (4)\nDirect global optimization of empirical loss L(W,\u0398;D) with respect to W is challenging. It is a discontinuous and piecewise-constant function of W . Furthermore, given an input x, the navigation function f(\u00b7) yields a leaf parameter vector based on a sequence of binary tests, where the results of the initial tests determine which subsequent tests are performed. It is not clear how this dependence of binary tests should be formulated."}, {"heading": "4 Decision trees and structured prediction", "text": "To overcome the intractability in the optimization of L, we develop a piecewise smooth upper bound on empirical loss. Our upper bound is inspired by the formulation of structured prediction with latent variables [26]. A key observation that links decision tree learning to structured prediction, is that one can re-express sgn(Wx) in terms of a latent variable h. That is,\nsgn(Wx) = argmax h\u2208Hm\n(hTWx) . (5)\nIn this form, decision tree\u2019s split functions implicitly map an input x to a binary vector h by maximizing a score function hTWx, the inner product of h and Wx. One can re-express the score function in terms of a more familiar form of a joint feature space on h and x, as wT\u03c6(h,x), where \u03c6(h,x) = vec (hxT), and w = vec (W ). Previously, Norouzi et al. [19, 20] used the same reformulation (5) of linear threshold functions to learn binary similarity preserving hash functions.\nGiven (5), we re-express empirical loss as, L(W,\u0398;D) = \u2211\n(x,y)\u2208D\n`(\u0398Tf(h\u0302(x)), y) ,\nwhere h\u0302(x) = argmax h\u2208Hm\n(hTWx) . (6)\nThis objective resembles the objective functions used in structured prediction, and since we do not have a priori access to the ground truth split decisions, h\u0302(x), this problem is a form of structured prediction with latent variables."}, {"heading": "5 Upper bound on empirical loss", "text": "We develop an upper bound on loss for an input-output pair, (x, y), which takes the form,\n`(\u0398Tf(sgn(Wx)), y) \u2264 max g\u2208Hm\n( gTWx + `(\u0398Tf(g), y) ) \u2212 max\nh\u2208Hm (hTWx) . (7)\nTo validate the bound, first note that the second term on the RHS is maximized by h = h\u0302(x) = sgn(Wx). Second, when g = h\u0302(x), it is clear that the LHS equals the RHS. For all other values of g, the RHS can only get larger than when g = h\u0302(x) because of the max operator. Hence, the inequality holds. An algebraic proof of (7) is presented in the Appendix.\nIn the context of structured prediction, the first term of the upper bound, i.e., the maximization over g, is called loss-augmented inference, as it augments the standard inference problem, i.e., the maximization over h, with a loss term. Fortunately, the loss-augmented inference for our decision tree learning formulation can be solved exactly, as discussed below.\nIt is also notable that the loss term on the LHS of (7) is invariant to the scale of W , but the upper bound on the right side of (7) is not. As a consequence, as with binary SVM and margin-rescaling formulations of structural SVM [25], we introduce a regularizer on the norm of W when optimizing the bound. To justify the regularizer, we discuss the effect of the scale of W on the bound.\nProposition 1. The upper bound on the loss becomes tighter as a constant multiple of W increases, i.e., for a > b > 0:\nmax g\u2208Hm\n( agTWx + `(\u0398Tf(g), y) ) \u2212 max\nh\u2208Hm (ahTWx) \u2264\nmax g\u2208Hm\n( bgTWx + `(\u0398Tf(g), y) ) \u2212 max\nh\u2208Hm (bhTWx).\n(8)\nProof. Please refer to the Appendix for the proof.\nIn the limit, as the scale of W approach +\u221e, the loss term `(\u0398Tf(g), y) becomes negligible compared to the score term gTWx. Thus, the solutions to loss-augmented inference and inference become almost identical, except when an element of Wx is very close to 0. Thus, even though a larger \u2016W\u2016 yields a tighter bound, it makes the bound approach the loss itself, and therefore becomes nearly piecewise-constant, which is hard to optimize. In fact, based on Proposition 1, one easy way to decrease the upper bound is to increase the norm of W , which does not affect the loss.\nOur experiments indicate that when the norm of W is regularized, a lower value of the loss at both training and validation time can be achieved. We therefore constrain the norm of W to obtain an objective with better behavior and generalization. Since each row of W acts independently in a decision tree in the split functions, it is reasonable to constrain the norm of each row independently. Summing over the bounds for different training pairs and constraining the norm of rows of W , we obtain the following optimization problem, called the surrogate objective:\nminimize L\u2032(W,\u0398;D) = \u2211\n(x,y)\u2208D\n( max g\u2208Hm ( gTWx + `(\u0398Tf(g), y) ) \u2212 max h\u2208Hm (hTWx) ) s.t. \u2016wi\u20162 \u2264 \u03bd for all i \u2208 {1, . . . ,m} ,\n(9)\nwhere \u03bd \u2208 R+ is a regularization parameter and wi is the i row of W . For all values of \u03bd, we have L(W,\u0398;D) \u2264 L\u2032(W,\u0398;D). Instead of using the typical Lagrange form for regularization, we employ hard constraints to enable sparse gradient updates of the rows of W , since as explained below, the gradients for most rows of W are zero at each step of training."}, {"heading": "6 Optimizing the surrogate objective", "text": "Even though minimizing the surrogate objective of (9) entails non-convex optimization, L\u2032(W,\u0398;D) is much better behaved than empirical loss in (4). L\u2032(W,\u0398;D) is piecewise linear and convex-concave in W , and the constraints on W define a convex set.\nLoss-augmented inference. To evaluate and use the surrogate objective in (9) for optimization, we must solve a loss-augmented inference problem to find the binary code that maximizes the sum of the score and loss terms:\ng\u0302(x) = argmax g\u2208Hm\n( gTWx + `(\u0398Tf(g), y) ) . (10)\nAn observation that makes this optimization tractable is that f(g) can only take on m+1 distinct values, which correspond to terminating at one of the m+1 leaves of the tree and selecting a leaf parameter from {\u03b8j}m+1j=1 . Fortunately, for any leaf index j \u2208 {1, . . . ,m+1}, we can solve\nargmax g\u2208Hm\n( gTWx + `(\u03b8j , y) ) s. t. f(g) = 1j , (11)\nefficiently. Note that if f(g) = 1j , then \u0398Tf(g) equals the j row of \u0398, i.e., \u03b8j . To solve (11) we need to set all of the binary bits in g corresponding to the path from the root to the leaf j to be consistent with the path direction toward the leaf j. However, bits of g that do not appear on this path have no effect on the output of f(g), and all such bits should be set based on g[i] = sgn(wi\nTx) to obtain maximum gTWx. Accordingly, we can essentially ignore the off-the-path bits by subtracting sgn(Wx) T Wx from (11) to obtain,\nargmax g\u2208Hm\n( gTWx + `(\u03b8j , y) ) = argmax\ng\u2208Hm\n(( g \u2212 sgn(Wx) )T Wx + `(\u03b8j , y) ) . (12)\nAlgorithm 1 Stochastic gradient descent (SGD) algorithm for non-greedy decision tree learning. 1: Initialize W (0) and \u0398(0) using greedy procedure 2: for t = 0 to \u03c4 do 3: Sample a pair (x, y) uniformly at random from D 4: h\u0302\u2190 sgn(W (t)x) 5: g\u0302\u2190 argmaxg\u2208Hm { gTW (t)x + `(\u0398Tf(g), y)\n} 6: W (tmp) \u2190W (t) \u2212 \u03b7 g\u0302xT + \u03b7 h\u0302xT\n7: for i = 1 to m do 8: W (t+1)i, . \u2190 min { 1, \u221a \u03bd /\u2225\u2225W (tmp)i, . \u2225\u22252}W (tmp)i, .\n9: end for 10: \u0398(t+1) \u2190 \u0398(t) \u2212 \u03b7 \u2202\u2202\u0398`(\u0398 Tf(g\u0302), y) \u2223\u2223 \u0398=\u0398(t) 11: end for\nNote that sgn(Wx)TWx is constant in g, and this subtraction zeros out all bits in g that are not on the path to the leaf j. So, to solve (12), we only need to consider the bits on the path to the leaf j for which sgn(wiTx) is not consistent with the path direction. Using a single depth-first search on the decision tree, we can solve (11) for every j, and among those, we pick the one that maximizes (11).\nThe algorithm described above is O(mp) \u2286 O(2dp), where d is the tree depth, and we require a multiple of p for computing the inner product wix at each internal node i. This algorithm is not efficient for deep trees, especially as we need to perform loss-augmented inference once for every stochastic gradient computation. In what follows, we develop an alternative more efficient formulation and algorithm with time complexity of O(d2p).\nFast loss-augmented inference. To develop a faster loss-augmented inference algorithm, we formulate a slightly different upper bound on the loss, i.e.,\n`(\u0398Tf(sgn(Wx)), y) \u2264 max g\u2208B1(sgn(Wx))\n( gTWx + `(\u0398Tf(g), y) ) \u2212 max\nh\u2208Hm\n( hTWx ) , (13)\nwhere B1(sgn(Wx)) denotes the Hamming ball of radius 1 around sgn(Wx), i.e., B1(sgn(Wx)) \u2261 {g \u2208 Hm | \u2016g \u2212 sgn(Wx)\u2016H \u2264 1}, hence g \u2208 B1(sgn(Wx)) implies that g and sgn(Wx) differ in at most one bit. The proof of (13) is identical to the proof of (7). The key benefit of this new formulation is that loss-augmented inference with the new bound is computationally efficient. Since g\u0302 and sgn(Wx) differ in at most one bit, then f(g\u0302) can only take d + 1 distinct values. Thus we need to evaluate (12) for at most d+ 1 values of j, requiring a running time of O(d2p).\nStochastic gradient descent (SGD). A reasonable approach to minimizing (9) uses stochastic gradient descent (SGD), the steps of which are outlined in Alg 1. Here, \u03b7 denotes the learning rate, and \u03c4 is the number of optimization steps. Line 6 corresponds to a gradient update in W , which is supported by the fact that \u2202\u2202W h\nTWx = hxT. Line 8 performs projection back to the feasible region of W , and Line 10 updates \u0398 based on the gradient of the loss. Our implementation modifies Alg 1 by adopting common SGD tricks, including the use of momentum and mini-batches.\nStable SGD (SSGD). Even though Alg 1 achieves good training and test accuracy relatively quickly, we observe that after several gradient updates some of the leaves may end up not being assigned to any data points and hence the full tree capacity may not be exploited. We call such leaves inactive as opposed to active leaves that are assigned to at least one training data point. An inactive leaf may become active again, but this rarely happens given the form of gradient updates. To discourage abrupt changes in the number of inactive leaves, we introduce a variant of SGD, in which the assignments of data points to leaves are fixed for a number of gradient update steps. Thus, the bound is optimized with respect to a set of data point to leaf assignment constraints. When the improvement in the bound becomes negligible the leaf assignment variables are updated, followed by another round of optimization of the bound. We call this algorithm Stable SGD (SSGD) because it changes the assignment of data points to leaves more conservatively than SGD. Let a(x) denote the 1-of-(m+ 1) encoding of the leaf to which a data point x should be assigned to. Then, SSGD with\nfast loss-augmented inference relies on the following upper bound on loss,\n`(\u0398Tf(sgn(Wx)), y) \u2264 max g\u2208B1(sgn(Wx))\n( gTWx + `(\u0398Tf(g), y) ) \u2212 max\nh\u2208Hm|f(h)=a(x)\n( hTWx ) .\n(14) One can easily verify that the RHS of (14) is larger than the RHS of (13), hence the inequality.\nComputational complexity. To analyze the computational complexity of each SGD and SSGD step, we note that Hamming distance between g\u0302 (defined in (10)) and h\u0302 = sgn(Wx) is bounded above by the depth of the tree d. This is because only those elements of g\u0302 corresponding to the path to a selected leaf can differ from sgn(Wx). Thus, for SGD the expression (g\u0302 \u2212 h\u0302)xT needed for Line 6 of Alg 1 can be computed in O(dp), if we know which bits of h\u0302 and g\u0302 differ. Accordingly, Lines 6 and 7 can be performed in O(dp). The computational bottleneck is the loss augmented inference in Line 5. When fast loss-augmented inference is performed inO(d2p) time, the total time complexity of gradient update for both SGD and SSGD becomesO(d2p+k), where k is the number of labels."}, {"heading": "7 Experiments", "text": "Experiments are conducted on several benchmark datasets from LibSVM [1] for multi-class classification, namely SensIT, Connect4, Protein, and MNIST. We use the provided train, validation, test sets when available. If such splits are not provided, we use a random 80%/20% split of the training data for train and validation sets and a random 64%/16%/20% split for train, validation, test sets.\nWe compare our method for non-greedy learning of oblique trees with several greedy baselines, including conventional axis-aligned trees based on information gain, OC1 oblique trees [17] that use coordinate descent for optimization of the splits, and random oblique trees that select the best split function from a set of randomly generated hyperplanes based on information gain. We also compare with the results of CO2 [18], which is a special case of our upper bound approach applied greedily to trees of depth 1, one node at a time. Any base algorithm for learning decision trees can be augmented by post-training pruning [16], or building ensembles with bagging [5] or boosting [8]. However, the key differences between non-greedy trees and baseline greedy trees become most apparent when analyzing individual trees. For a single tree the major determinant of accuracy is the size of the tree, which we control by changing the maximum tree depth.\nFig. 2 depicts test and training accuracy for non-greedy trees and four other baselines as function of tree depth. We evaluate trees of depth 6 up to 18 at depth intervals of 2. The hyper-parameters for each method are tuned for each depth independently. While the absolute accuracy of our non-greedy\ntrees varies between datasets, a few key observations hold for all cases. First, we observe that nongreedy trees achieve the best test performance across tree depths across multiple datasets. Second, trees trained using our non-greedy approach seem to be less susceptible to overfitting and achieve better generalization performance at various tree depths. As described below, we think that the norm regularization provides a principled way to tune the tightness of the tree\u2019s fit to the training data. Finally, the comparison between non-greedy and CO2 [18] trees concentrates on the non-greediness of the algorithm, as it compares our method with its simpler variant, which is applied greedily one node at a time. We find that in most cases, the non-greedy optimization helps by improving upon the results of CO2.\nA key hyper-parameter of our method is the regularization constant \u03bd in (9), which controls the tightness of the upper bound. With a small \u03bd, the norm constraints force the method to choose a W with a large margin at each internal node. The choice of \u03bd is therefore closely related to the generalization of the learned trees. As shown in Fig. 3, \u03bd also implicitly controls the degree of pruning of the leaves of the tree during training. We train multiple trees for different values of \u03bd \u2208 {0.1, 1, 4, 10, 43, 100}, and we pick the value of \u03bd that produces the tree with minimum validation error. We also tune the choice of the SGD learning rate, \u03b7, in this step. Such \u03bd and \u03b7 are used to build a tree using the union of both the training and validation sets, which is evaluated on the test set.\nTo build non-greedy trees, we initially build an axis-aligned tree with split functions that threshold a single feature, optimized using conventional procedures that maximize information gain. The axisaligned split is used to initialize a greedy variant of the tree training procedure, called CO2 [18]. This provides initial values for W and \u0398 for the non-greedy procedure.\nFig. 4 shows an empirical comparison of training time for SGD with loss-augmented inference and fast loss-augmented inference. As expected, run-time of SGD with loss-augmented inference exhibits exponential growth with deep trees whereas its fast variant is much more scalable. We expect to see better speedup factors for larger datasets. Connect4 only has 55, 000 training points."}, {"heading": "8 Conclusion", "text": "We present a non-greedy method for learning decision trees using stochastic gradient descent to optimize an upper bound on the tree\u2019s empirical loss on a training dataset. Our model poses the global training of decision trees in a well-characterized optimization framework. This makes it simpler to pose extensions that could be considered in future work. Efficiency gains could be achieved by learning sparse split functions via sparsity-inducing regularization onW . Further, the core optimization problem permits applying the kernel trick to the linear split parameters W , making our overall model applicable to learning higher-order split functions or training decision trees on examples in arbitrary reproducing kernel Hilbert spaces.\nAcknowledgment. MN was financially supported in part by a Google fellowship. DF was financially supported in part by NSERC Canada and the NCAP program of the CIFAR.\nReferences\n[1] http://www.csie.ntu.edu.tw/c\u0303jlin/libsvmtools/datasets/.\n[2] K. P. Bennett. Global tree optimization: A non-greedy decision tree algorithm. Computing Science and Statistics, pages 156\u2013156, 1994.\n[3] K. P. Bennett and J.A. Blue. A support vector machine approach to decision trees. In Department of Mathematical Sciences Math Report No. 97-100, Rensselaer Polytechnic Institute, pages 2396\u20132401, 1997.\n[4] K. P. Bennett, N. Cristianini, J. Shawe-Taylor, and D. Wu. Enlarging the margins in perceptron decision trees. Machine Learning, 41(3):295\u2013313, 2000.\n[5] L. Breiman. Random forests. Machine Learning, 45(1):5\u201332, 2001.\n[6] L. Breiman, J. Friedman, R. A. Olshen, and C. J. Stone. Classification and regression trees. Chapman & Hall/CRC, 1984.\n[7] A. Criminisi and J. Shotton. Decision Forests for Computer Vision and Medical Image Analysis. Springer, 2013.\n[8] Jerome H Friedman. Greedy function approximation: a gradient boosting machine. Annals of Statistics, pages 1189\u20131232, 2001.\n[9] J. Gall, A. Yao, N. Razavi, L. Van Gool, and V. Lempitsky. Hough forests for object detection, tracking, and action recognition. IEEE Trans. PAMI, 33(11):2188\u20132202, 2011.\n[10] T. Hastie, R. Tibshirani, and J. Friedman. The elements of statistical learning (Ed. 2). Springer, 2009.\n[11] L. Hyafil and R. L. Rivest. Constructing optimal binary decision trees is NP-complete. Information Processing Letters, 5(1):15\u201317, 1976.\n[12] J. Jancsary, S. Nowozin, and C. Rother. Loss-specific training of non-parametric image restoration models: A new state of the art. ECCV, 2012.\n[13] M. I. Jordan and R. A. Jacobs. Hierarchical mixtures of experts and the em algorithm. Neural Comput., 6(2):181\u2013214, 1994.\n[14] E. Konukoglu, B. Glocker, D. Zikic, and A. Criminisi. Neighbourhood approximation forests. In Medical Image Computing and Computer-Assisted Intervention\u2013MICCAI 2012, pages 75\u201382. Springer, 2012.\n[15] B. Lakshminarayanan, D. M. Roy, and Y. H. Teh. Mondrian forests: Efficient online random forests. In Advances in Neural Information Processing Systems, pages 3140\u20133148, 2014.\n[16] J. Mingers. An empirical comparison of pruning methods for decision tree induction. Machine Learning, 4(2):227\u2013243, 1989.\n[17] S. K. Murthy and S. L. Salzberg. On growing better decision trees from data. PhD thesis, John Hopkins University, 1995.\n[18] M. Norouzi, M. D. Collins, D. J. Fleet, and P. Kohli. Co2 forest: Improved random forest by continuous optimization of oblique splits. arXiv:1506.06155, 2015.\n[19] M. Norouzi and D. J. Fleet. Minimal Loss Hashing for Compact Binary Codes. ICML, 2011.\n[20] M. Norouzi, D. J. Fleet, and R. Salakhutdinov. Hamming Distance Metric Learning. NIPS, 2012.\n[21] S. Nowozin. Improved information gain estimates for decision tree induction. ICML, 2012.\n[22] J. R. Quinlan. Induction of decision trees. Machine learning, 1(1):81\u2013106, 1986.\n[23] J. Shotton, R. Girshick, A. Fitzgibbon, T. Sharp, M. Cook, M. Finocchio, R. Moore, P. Kohli, A. Criminisi, A. Kipman, et al. Efficient human pose estimation from single depth images. IEEE Trans. PAMI, 2013.\n[24] B. Taskar, C. Guestrin, and D. Koller. Max-margin Markov networks. NIPS, 2003.\n[25] I. Tsochantaridis, T. Hofmann, T. Joachims, and Y. Altun. Support vector machine learning for interdependent and structured output spaces. ICML, 2004.\n[26] C. N. J. Yu and T. Joachims. Learning structural SVMs with latent variables. ICML, 2009."}, {"heading": "A Proofs", "text": "Upper bound on loss. For any pair (x, y), the loss `(\u0398Tf(sgn(Wx)), y) is upper bounded by:\n`(\u0398Tf(sgn(Wx)), y) \u2264 max g\u2208Hm\n{ gTWx + `(\u0398Tf(g), y) } \u2212 max\nh\u2208Hm\n{ hTWx } . (15)\nProof.\nRHS = max g\u2208Hm\n{ gTWx + `(\u0398Tf(g), y) } \u2212 max\nh\u2208Hm\n{ hTWx } = max\ng\u2208Hm\n{ gTWx + `(\u0398Tf(g), y) } \u2212 sgn(Wx)TWx\n\u2265 max g\u2208{sgn(Wx)}\n{ gTWx + `(\u0398Tf(g), y) } \u2212 sgn(Wx)TWx\n= sgn(Wx)TWx + `(\u0398Tf(sgn(Wx)), y)\u2212 sgn(Wx)TWx = `(\u0398Tf(sgn(Wx)), y)\n= LHS\nProposition 2. The upper bound on the loss becomes tighter as a constant multiple of W gets larger. More formally, for any \u03b1 > \u03b2 > 0, we have:\nmax g\u2208Hm\n{ \u03b1gTWx + `(\u0398Tf(g), y) } \u2212 max\nh\u2208Hm\n{ \u03b1hTWx } \u2264\nmax g\u2032\u2208Hm\n{ \u03b2g\u2032 T Wx + `(\u0398Tf(g\u2032), y) } \u2212 max\nh\u2032\u2208Hm\n{ \u03b2h\u2032 T Wx } . (16)\nProof. Let\ng\u0302\u03b1 = argmax g\u2208Hm\n{ \u03b1gTWx + `(\u0398Tf(g), y) } , g\u0302\u03b2 = argmax\ng\u2208Hm\n{ \u03b2 gTWx + `(\u0398Tf(g), y) } ,\nthen we have: \u03b2 g\u0302T\u03b1Wx + `(\u0398 Tf(g\u0302\u03b1), y) \u2264 \u03b2 g\u0302 T \u03b2Wx + `(\u0398 Tf(g\u0302\u03b2), y) . (17)\nWe also have:\nmax h\u2208Hm\n{ \u03b1 hTWx } = \u03b1 sgn(Wx)TWx , and max\nh\u2208Hm\n{ \u03b2 hTWx } = \u03b2 sgn(Wx)TWx . (18)\nMoreover,\ng\u0302T\u03b1Wx \u2264 sgn(Wx) TWx =\u21d2\n(\u03b1\u2212 \u03b2) g\u0302T\u03b1Wx \u2264 (\u03b1\u2212 \u03b2) sgn(Wx) TWx =\u21d2\n(\u03b1\u2212 \u03b2) g\u0302T\u03b1Wx\u2212 \u03b1 sgn(Wx) TWx \u2264 \u2212\u03b2 sgn(Wx)TWx . (19)\nNow, summing the two sides of (17) and (19), and using (18), the inequality is proved."}], "references": [{"title": "Global tree optimization: A non-greedy decision tree algorithm", "author": ["K.P. Bennett"], "venue": "Computing Science and Statistics, pages 156\u2013156", "citeRegEx": "2", "shortCiteRegEx": null, "year": 1994}, {"title": "A support vector machine approach to decision trees", "author": ["K.P. Bennett", "J.A. Blue"], "venue": "Department of Mathematical Sciences Math Report No. 97-100, Rensselaer Polytechnic Institute, pages 2396\u20132401", "citeRegEx": "3", "shortCiteRegEx": null, "year": 1997}, {"title": "Enlarging the margins in perceptron decision trees", "author": ["K.P. Bennett", "N. Cristianini", "J. Shawe-Taylor", "D. Wu"], "venue": "Machine Learning, 41(3):295\u2013313", "citeRegEx": "4", "shortCiteRegEx": null, "year": 2000}, {"title": "Random forests", "author": ["L. Breiman"], "venue": "Machine Learning, 45(1):5\u201332", "citeRegEx": "5", "shortCiteRegEx": null, "year": 2001}, {"title": "Classification and regression trees", "author": ["L. Breiman", "J. Friedman", "R.A. Olshen", "C.J. Stone"], "venue": "Chapman & Hall/CRC", "citeRegEx": "6", "shortCiteRegEx": null, "year": 1984}, {"title": "Decision Forests for Computer Vision and Medical Image Analysis", "author": ["A. Criminisi", "J. Shotton"], "venue": "Springer", "citeRegEx": "7", "shortCiteRegEx": null, "year": 2013}, {"title": "Greedy function approximation: a gradient boosting machine", "author": ["Jerome H Friedman"], "venue": "Annals of Statistics,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2001}, {"title": "Hough forests for object detection", "author": ["J. Gall", "A. Yao", "N. Razavi", "L. Van Gool", "V. Lempitsky"], "venue": "tracking, and action recognition. IEEE Trans. PAMI, 33(11):2188\u20132202", "citeRegEx": "9", "shortCiteRegEx": null, "year": 2011}, {"title": "The elements of statistical learning (Ed", "author": ["T. Hastie", "R. Tibshirani", "J. Friedman"], "venue": "2). Springer", "citeRegEx": "10", "shortCiteRegEx": null, "year": 2009}, {"title": "Constructing optimal binary decision trees is NP-complete", "author": ["L. Hyafil", "R.L. Rivest"], "venue": "Information Processing Letters, 5(1):15\u201317", "citeRegEx": "11", "shortCiteRegEx": null, "year": 1976}, {"title": "Loss-specific training of non-parametric image restoration models: A new state of the art", "author": ["J. Jancsary", "S. Nowozin", "C. Rother"], "venue": "ECCV", "citeRegEx": "12", "shortCiteRegEx": null, "year": 2012}, {"title": "Hierarchical mixtures of experts and the em algorithm", "author": ["M.I. Jordan", "R.A. Jacobs"], "venue": "Neural Comput., 6(2):181\u2013214", "citeRegEx": "13", "shortCiteRegEx": null, "year": 1994}, {"title": "Neighbourhood approximation forests", "author": ["E. Konukoglu", "B. Glocker", "D. Zikic", "A. Criminisi"], "venue": "Medical Image Computing and Computer-Assisted Intervention\u2013MICCAI 2012, pages 75\u201382. Springer", "citeRegEx": "14", "shortCiteRegEx": null, "year": 2012}, {"title": "Mondrian forests: Efficient online random forests", "author": ["B. Lakshminarayanan", "D.M. Roy", "Y.H. Teh"], "venue": "Advances in Neural Information Processing Systems, pages 3140\u20133148", "citeRegEx": "15", "shortCiteRegEx": null, "year": 2014}, {"title": "An empirical comparison of pruning methods for decision tree induction", "author": ["J. Mingers"], "venue": "Machine Learning, 4(2):227\u2013243", "citeRegEx": "16", "shortCiteRegEx": null, "year": 1989}, {"title": "On growing better decision trees from data", "author": ["S.K. Murthy", "S.L. Salzberg"], "venue": "PhD thesis, John Hopkins University", "citeRegEx": "17", "shortCiteRegEx": null, "year": 1995}, {"title": "Co2 forest: Improved random forest by continuous optimization of oblique splits", "author": ["M. Norouzi", "M.D. Collins", "D.J. Fleet", "P. Kohli"], "venue": "arXiv:1506.06155", "citeRegEx": "18", "shortCiteRegEx": null, "year": 2015}, {"title": "Minimal Loss Hashing for Compact Binary Codes", "author": ["M. Norouzi", "D.J. Fleet"], "venue": "ICML", "citeRegEx": "19", "shortCiteRegEx": null, "year": 2011}, {"title": "Hamming Distance Metric Learning", "author": ["M. Norouzi", "D.J. Fleet", "R. Salakhutdinov"], "venue": "NIPS", "citeRegEx": "20", "shortCiteRegEx": null, "year": 2012}, {"title": "Improved information gain estimates for decision tree induction", "author": ["S. Nowozin"], "venue": "ICML", "citeRegEx": "21", "shortCiteRegEx": null, "year": 2012}, {"title": "Induction of decision trees", "author": ["J.R. Quinlan"], "venue": "Machine learning, 1(1):81\u2013106", "citeRegEx": "22", "shortCiteRegEx": null, "year": 1986}, {"title": "et al", "author": ["J. Shotton", "R. Girshick", "A. Fitzgibbon", "T. Sharp", "M. Cook", "M. Finocchio", "R. Moore", "P. Kohli", "A. Criminisi", "A. Kipman"], "venue": "Efficient human pose estimation from single depth images. IEEE Trans. PAMI", "citeRegEx": "23", "shortCiteRegEx": null, "year": 2013}, {"title": "Max-margin Markov networks", "author": ["B. Taskar", "C. Guestrin", "D. Koller"], "venue": "NIPS", "citeRegEx": "24", "shortCiteRegEx": null, "year": 2003}, {"title": "Support vector machine learning for interdependent and structured output spaces", "author": ["I. Tsochantaridis", "T. Hofmann", "T. Joachims", "Y. Altun"], "venue": "ICML", "citeRegEx": "25", "shortCiteRegEx": null, "year": 2004}, {"title": "Learning structural SVMs with latent variables", "author": ["C.N.J. Yu", "T. Joachims"], "venue": "ICML", "citeRegEx": "26", "shortCiteRegEx": null, "year": 2009}], "referenceMentions": [{"referenceID": 4, "context": "Decision trees and forests [6, 22, 5] have a long and rich history in machine learning [10, 7].", "startOffset": 27, "endOffset": 37}, {"referenceID": 20, "context": "Decision trees and forests [6, 22, 5] have a long and rich history in machine learning [10, 7].", "startOffset": 27, "endOffset": 37}, {"referenceID": 3, "context": "Decision trees and forests [6, 22, 5] have a long and rich history in machine learning [10, 7].", "startOffset": 27, "endOffset": 37}, {"referenceID": 8, "context": "Decision trees and forests [6, 22, 5] have a long and rich history in machine learning [10, 7].", "startOffset": 87, "endOffset": 94}, {"referenceID": 5, "context": "Decision trees and forests [6, 22, 5] have a long and rich history in machine learning [10, 7].", "startOffset": 87, "endOffset": 94}, {"referenceID": 21, "context": "A case in point is Microsoft Kinect where decision trees are trained on millions of exemplars to enable real-time human pose estimation from depth images [23].", "startOffset": 154, "endOffset": 158}, {"referenceID": 20, "context": "They grow a tree one node at a time following procedures laid out decades ago by frameworks such as ID3 [22] and CART [6].", "startOffset": 104, "endOffset": 108}, {"referenceID": 4, "context": "They grow a tree one node at a time following procedures laid out decades ago by frameworks such as ID3 [22] and CART [6].", "startOffset": 118, "endOffset": 121}, {"referenceID": 19, "context": "While recent work has proposed new objective functions to guide greedy algorithms [21, 12], it continues to be the case that decision tree applications (e.", "startOffset": 82, "endOffset": 90}, {"referenceID": 10, "context": "While recent work has proposed new objective functions to guide greedy algorithms [21, 12], it continues to be the case that decision tree applications (e.", "startOffset": 82, "endOffset": 90}, {"referenceID": 7, "context": ", [9, 14]) utilize the same dated methods of tree induction.", "startOffset": 2, "endOffset": 9}, {"referenceID": 12, "context": ", [9, 14]) utilize the same dated methods of tree induction.", "startOffset": 2, "endOffset": 9}, {"referenceID": 24, "context": "One of the key contributions of this work is establishing a link between the decision tree optimization problem and the problem of structured prediction with latent variables [26].", "startOffset": 175, "endOffset": 179}, {"referenceID": 22, "context": "Inspired by advances in structured prediction [24, 25, 26], we propose a convex-concave upper bound on the empirical loss.", "startOffset": 46, "endOffset": 58}, {"referenceID": 23, "context": "Inspired by advances in structured prediction [24, 25, 26], we propose a convex-concave upper bound on the empirical loss.", "startOffset": 46, "endOffset": 58}, {"referenceID": 24, "context": "Inspired by advances in structured prediction [24, 25, 26], we propose a convex-concave upper bound on the empirical loss.", "startOffset": 46, "endOffset": 58}, {"referenceID": 9, "context": "Finding optimal split functions at different levels of a decision tree according to some global objective, such as a regularized empirical risk, is NP-complete [11] due to the discrete and sequential nature of the decisions in a tree.", "startOffset": 160, "endOffset": 164}, {"referenceID": 0, "context": "Bennett [2] proposes a non-greedy multi-linear programming based approach for global tree optimization and shows that the method produces trees that have higher classification accuracy than standard greedy trees.", "startOffset": 8, "endOffset": 11}, {"referenceID": 13, "context": "The work in [15] proposes a means for training decision forests in an online setting by incrementally extending the trees as new data points are added.", "startOffset": 12, "endOffset": 16}, {"referenceID": 11, "context": "The Hierarchical Mixture of Experts model [13] uses soft splits rather than hard binary decisions to capture situations where the transition from low to high response is gradual.", "startOffset": 42, "endOffset": 46}, {"referenceID": 15, "context": "Murthy and Salzburg [17] argue that non-greedy tree learning methods that work by looking ahead are unnecessary and sometimes harmful.", "startOffset": 20, "endOffset": 24}, {"referenceID": 3, "context": "To avoid this problem, it is a common practice (see Breiman [5] or Criminisi and Shotton [7] for an overview) to limit the tree depth and introduce limits on the number of training instances below which a tree branch is not extended, or to force a diverse ensemble of trees (i.", "startOffset": 60, "endOffset": 63}, {"referenceID": 5, "context": "To avoid this problem, it is a common practice (see Breiman [5] or Criminisi and Shotton [7] for an overview) to limit the tree depth and introduce limits on the number of training instances below which a tree branch is not extended, or to force a diverse ensemble of trees (i.", "startOffset": 89, "endOffset": 92}, {"referenceID": 3, "context": ", a decision forest) through the use of bagging [5] or boosting [8].", "startOffset": 48, "endOffset": 51}, {"referenceID": 6, "context": ", a decision forest) through the use of bagging [5] or boosting [8].", "startOffset": 64, "endOffset": 67}, {"referenceID": 1, "context": "Bennett and Blue [3] describe a different way to overcome overfitting by using max-margin framework and the Support Vector Machines (SVM) at the split nodes of the tree.", "startOffset": 17, "endOffset": 20}, {"referenceID": 2, "context": "[4] show how enlarging the margin of decision tree classifiers results in better generalization performance.", "startOffset": 0, "endOffset": 3}, {"referenceID": 9, "context": "Joint optimization of the split functions and leaf parameters according to a global objective is known to be extremely challenging [11] due to the discrete and sequential nature of the splitting decisions within the tree.", "startOffset": 131, "endOffset": 135}, {"referenceID": 24, "context": "Our upper bound is inspired by the formulation of structured prediction with latent variables [26].", "startOffset": 94, "endOffset": 98}, {"referenceID": 17, "context": "[19, 20] used the same reformulation (5) of linear threshold functions to learn binary similarity preserving hash functions.", "startOffset": 0, "endOffset": 8}, {"referenceID": 18, "context": "[19, 20] used the same reformulation (5) of linear threshold functions to learn binary similarity preserving hash functions.", "startOffset": 0, "endOffset": 8}, {"referenceID": 23, "context": "As a consequence, as with binary SVM and margin-rescaling formulations of structural SVM [25], we introduce a regularizer on the norm of W when optimizing the bound.", "startOffset": 89, "endOffset": 93}, {"referenceID": 15, "context": "We compare our method for non-greedy learning of oblique trees with several greedy baselines, including conventional axis-aligned trees based on information gain, OC1 oblique trees [17] that use coordinate descent for optimization of the splits, and random oblique trees that select the best split function from a set of randomly generated hyperplanes based on information gain.", "startOffset": 181, "endOffset": 185}, {"referenceID": 16, "context": "We also compare with the results of CO2 [18], which is a special case of our upper bound approach applied greedily to trees of depth 1, one node at a time.", "startOffset": 40, "endOffset": 44}, {"referenceID": 14, "context": "Any base algorithm for learning decision trees can be augmented by post-training pruning [16], or building ensembles with bagging [5] or boosting [8].", "startOffset": 89, "endOffset": 93}, {"referenceID": 3, "context": "Any base algorithm for learning decision trees can be augmented by post-training pruning [16], or building ensembles with bagging [5] or boosting [8].", "startOffset": 130, "endOffset": 133}, {"referenceID": 6, "context": "Any base algorithm for learning decision trees can be augmented by post-training pruning [16], or building ensembles with bagging [5] or boosting [8].", "startOffset": 146, "endOffset": 149}, {"referenceID": 16, "context": "Finally, the comparison between non-greedy and CO2 [18] trees concentrates on the non-greediness of the algorithm, as it compares our method with its simpler variant, which is applied greedily one node at a time.", "startOffset": 51, "endOffset": 55}, {"referenceID": 16, "context": "The axisaligned split is used to initialize a greedy variant of the tree training procedure, called CO2 [18].", "startOffset": 104, "endOffset": 108}], "year": 2015, "abstractText": "Decision trees and randomized forests are widely used in computer vision and machine learning. Standard algorithms for decision tree induction optimize the split functions one node at a time according to some splitting criteria. This greedy procedure often leads to suboptimal trees. In this paper, we present an algorithm for optimizing the split functions at all levels of the tree jointly with the leaf parameters, based on a global objective. We show that the problem of finding optimal linear-combination (oblique) splits for decision trees is related to structured prediction with latent variables, and we formulate a convex-concave upper bound on the tree\u2019s empirical loss. The run-time of computing the gradient of the proposed surrogate objective with respect to each training exemplar is quadratic in the the tree depth, and thus training deep trees is feasible. The use of stochastic gradient descent for optimization enables effective training with large datasets. Experiments on several classification benchmarks demonstrate that the resulting non-greedy decision trees outperform greedy decision tree baselines.", "creator": "LaTeX with hyperref package"}}}