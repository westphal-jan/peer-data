{"id": "1511.07710", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "24-Nov-2015", "title": "Searching for Objects using Structure in Indoor Scenes", "abstract": "to identify the object location of objects of a particular class, a passive computer vision system generally processes all the regions in an image to finally output at few regions. however, we can use structure in the scene to search for objects without processing the entire image. we propose a search technique that sequentially processes image regions such that the regions that are more likely to correspond to the query class object are explored thus earlier. we frame the problem as a markov decision process and use an imitation learning algorithm to learn a search strategy. since structure in the scene is essential characteristic for search, frequently we work with simple indoor scene images as they contain both unary scene context information and object - object context in the scene. ultimately we perform experiments on the nyu - depth v2 dataset and show that the unary location scene context features alone can achieve a significantly high average precision while processing only 20 - 25 \\ % of the regions for classes like bed and sofa. by considering object - object context along with the downstairs scene view context features, the performance is further improved for classes like counter, lamp, pillow and sofa.", "histories": [["v1", "Tue, 24 Nov 2015 14:05:28 GMT  (11596kb,D)", "http://arxiv.org/abs/1511.07710v1", "Appeared in British Machine Vision Conference (BMVC) 2015"]], "COMMENTS": "Appeared in British Machine Vision Conference (BMVC) 2015", "reviews": [], "SUBJECTS": "cs.CV cs.AI", "authors": ["varun k nagaraja", "vlad i morariu", "larry s davis"], "accepted": false, "id": "1511.07710"}, "pdf": {"name": "1511.07710.pdf", "metadata": {"source": "CRF", "title": "NAGARAJA et al.: SEARCHING FOR OBJECTS USING STRUCTURE IN INDOOR SCENES 1 Searching for Objects using Structure in Indoor Scenes", "authors": ["Varun K. Nagaraja", "Vlad I. Morariu", "Larry S. Davis"], "emails": ["varun@umiacs.umd.edu", "morariu@umiacs.umd.edu", "lsd@umiacs.umd.edu"], "sections": [{"heading": "1 Introduction", "text": "The current prevalent object detection framework [7] is a pipeline of two main stages: the object proposal stage and the feature extraction/classification stage. Object proposals are image regions that with high probability significantly overlap with an object, irrespective of object class. Features are extracted from object proposals and then a label is predicted. Even with high quality object proposals, the typical number of proposals considered by the feature extraction stage ranges from hundreds to tens of thousands for high resolution imagery.\nConsider the situation where a computer vision system needs to identify the presence or location of a particular object in an image. In a passive computer vision system, if we ask a specific question like \u201cWhere is the table in this room?\", it would process all the region proposals in the image to detect a table instance. Such a vision system does not exploit the structure in the scene to efficiently process the image. Our goal is to locate objects of interest in an image by processing as few image regions as possible using scene structure. We build on a region proposal module that generates candidate regions and a region classification module that predicts the class label for a region. The generic strategy is to sequentially\nc\u00a9 2015. The copyright of this document resides with its authors. It may be distributed unchanged freely in print or electronic forms.\nar X\niv :1\n51 1.\n07 71\n0v 1\n[ cs\n(a) Ranked sequence obtained from an object proposal technique.\n(b) Sequence obtained from a search strategy that uses structure in the scene.\nFigure 1: Searching for a table. Each step in the above sequence shows exploration of three additional regions in the image. The search strategy learned using our method utilizes the room structure and the presence of other objects in the image to discover the table region much earlier than using the ranked sequence from an object proposal technique.\nprocess image regions such that the regions that are more likely to correspond to the object of interest are explored earlier. At each step, we use the labels of the explored regions and spatial context to predict the likelihood that each unexplored region is an instance of the target class. We then select a few regions with highest likelihood, obtain the class label from the region classification module and add them to the explored set. The process is repeated with the updated set of explored regions.\nWe frame our sequential exploration problem as a Markov Decision Process (MDP) and use a reinforcement learning technique to learn an optimal search policy. However, it is challenging to manually specify a reward function for the search policy. The true reward function is unknown for our sequential exploration problem since the underlying distribution from which a spatial arrangement of objects in an image is generated is unknown, analogous to a game generated by a hidden emulator [12]. But we have access to an oracle\u2019s actions in the individual images. Learning an optimal policy in such situations is known as imitation learning [1] where an oracle predicts the actions it would take at a state and the search policy learns to imitate the oracle and predict similar actions. The oracle in our image exploration problem selects the next set of regions to explore based on the groundtruth labels. We use the DAgger algorithm of Ross et al. [14] that trains a classifier as the search policy on a dataset of features extracted at states and actions taken by the oracle (labels), where the states are generated by running the policy iteratively over the training data.\nIntelligent search strategies can be learned only in domains that contain sufficient structure in the scenes. Frequently recurring patterns between the constituent objects of a scene are essential to learn powerful strategies and predict exploration paths with high confidence. Such structures can be found in indoor scenes of houses, stores and buildings. Hence we illustrate our technique on the indoor scene dataset, NYU depth v2 [15]. The other advantage of indoor scenes is the availability of depth data. Gupta et al. [9] showed that RCNN [7] trained with depth information greatly improved object detection performance. Apart from improving detection performance, depth information provides spatial context that is highly informative for efficient localization of objects. Our experiments show that given a fixed number of regions that can be processed, our sequential exploration technique provides a\nbetter average precision than using a ranked sequence provided by the object proposal technique. Figure 1 shows a sequence of regions explored by a strategy trained to detect a table. We compare the search sequence produced by our technique to the ranked sequence provided by the region proposal technique. Our technique is able to utilize the room structure and the presence of other objects in the image to explore the table region much earlier than the object proposal ranking."}, {"heading": "2 Related Work", "text": "Many techniques reduce the number of image windows to limit computation time for object detection. For example, object proposal techniques [4, 16] rank regions in an image based on their likelihood of containing an object. The ranking can be used to prioritize regions for running an object classifier depending on the available computation budget. Such object proposal techniques use only low level image information and do not exploit scene structure.\nSome techniques iteratively run the classifier on a few windows and find the next set of windows to be processed based on feedback from the classifier scores and/or spatial context. Lampert et al. [11] prune the space of windows using a branch and bound algorithm. Butko and Movellan [5] use a Partially Observable Markov Decision Process to sequentially place a digital fovea (a center of fixation) to detect a single target in an image. Neither of these techniques make use of spatial context between objects to improve window selection. Alexe et al. [2] use only spatial context to choose a set of windows to be processed. The classifier is run at the end of window set selection and the maximum scoring window is output as the object location. Gonzalez-Garcia et al. [8] use both spatial context and the classifier scores of previously explored regions. While their output during the testing stage is a sequence of regions, the training is performed without taking into consideration the states (set of objects explored until a step) encountered in a sequence. Hence, they can only model pairwise constraints between an unexplored region and an object. Our technique models relationships between an unexplored region and all the explored objects. Unlike existing work, we use a framework that allows training and testing using the same procedure, thus reducing the burden of tuning many modules in the system.\nThe idea of sequentially processing an image by exploiting structure is not just relevant to object localization. Sequential processing has also been explored for video event detection, where running a multitude of detectors at all spatio-temporal scales is very expensive. Amer et al. [3] propose an explore-exploit strategy that schedules processes of top-down inference using activity context and bottom-up inference using activity parts. They use a Q-learning algorithm to learn the optimal actions to perform at a state. However, the learning algorithm needs the specification of a reward function which is difficult to obtain in many domains. We use an imitation learning algorithm that alleviates the problem of choosing a reward function."}, {"heading": "3 Sequential Exploration", "text": "The most common formalism for sequential decision making is the Markov Decision Process (MDP). An MDP is characterized by a set of states S, a set of actions A, transition probabilities P and a reward function G (or equivalently a loss function). A policy \u03c0 is a function that maps states to actions \u03c0(s). The goal is to find a policy that will maximize a cumulative function of the reward. When the transition probabilities are unknown, rein-\nforcement learning techniques are used to interact with the problem domain and sample the probabilities.\nOur problem is to locate objects of a query class (q) by exploring as few image regions as possible. Let R be the set of indices of the regions in the image and t correspond to a step index. Let Rte be the set of indices of the explored image regions and R t u = R\\Rte be the set of indices of the unexplored image regions at a step t. To state our problem in the reinforcement learning setting, a state st is the set of all the image regions (r) explored until that step.\nst = {ri|i \u2208 Rte} (1)\nAn action corresponds to selecting the next image region to explore, at = r j where j\u2208Rtu. The reward function is difficult to specify for our image exploration problem. If we assume that spatial arrangements of objects in images are generated from a hidden distribution similar to games generated by a hidden emulator, a true reward function will allow the policy to learn a predictor that can replicate the behavior of the hidden distribution. For example, if we are searching for a chair, by setting the reward values higher for regions near a table than those far away from it, the policy assigns a greater importance to table proximity feature. Since images contain samples of spatial arrangements from the hidden distribution and the true reward values are unknown, an imitation learning algorithm can be used to learn the optimal policy. In imitation learning [1], rather than specifying a reward function, an oracle demonstrates the action to take and the policy learns to imitate the oracle. For us, the oracle selects the next region to explore based on the groundtruth labels. Hence, the policy is trained to predict labels similar to the groundtruth.\nImitation learning algorithms usually learn a strategy by training a classifier on the dataset of state features and actions (labels) obtained by sampling sequences produced by an oracle policy. They make an i.i.d assumption about the states encountered during the execution of a learned policy which does not hold for our problem since the policy\u2019s prediction affects future states. During the test stage, if the policy encounters a state that was not generated by the oracle policy, it could predict an incorrect action that can lead to compounding of errors. Ross et al. [14] propose an imitation learning algorithm called DAgger (Dataset Aggregation) that does not make the i.i.d assumption about the states. DAgger finds a policy \u03c0\u0302 which minimizes the observed surrogate loss `(s,\u03c0) under its induced distribution of states,\n\u03c0\u0302 = argmin \u03c0\u2208\u03a0 Es\u223cd\u03c0 [`(s,\u03c0)] (2)\nwhere d\u03c0 = 1T \u2211 T t=1 d t \u03c0 is the average distribution of states if we follow policy \u03c0 for T steps. Since d\u03c0 is dependent on the policy \u03c0 , this is a non-i.i.d supervised learning problem. In our work, `(s,\u03c0) is the Hamming loss of \u03c0 with respect to \u03c0\u2217 - the oracle policy. At a given state, the policy is penalized for what it predicts for all the regions in the unexplored set. Let\np = (pi)i\u2208Rtu (3)\nbe a list of the predicted labels where each label pi \u2208 {0,1} indicates whether the corresponding region is predicted to contain an object of the queried class or not. The oracle policy produces a list the same length as p with groundtruth labels. The Hamming loss is measured between the list of predicted labels and groundtruth labels. When the policy labels more than one region for exploration, we select the region with the highest belief as the next region to explore.\nAlgorithm 1 Sequential Exploration\n1: function SEQ_EXPLORE(ob j_proposals,N) 2: explored_list\u2190\u2205 3: curr_regions\u2190 ob j_proposals[0] 4: unexplored_regions\u2190 ob j_proposals[1 : end] 5: i\u2190 0 6: while i < N and curr_regions 6=\u2205 do 7: i\u2190 i+1 8: rcurr \u2190 POP(curr_regions) 9: PUSH(explored_list, rcurr)\n10: for r j \u2208 unexplored_regions do 11: score j = CLASSIFY(r j,explored_list) 12: end for 13: next\u2190 argmax j score j 14: PUSH(curr_regions,rnext ) 15: REMOVE(unexplored_regions,rnext ) 16: end while 17: return explored_list 18: end function\n1: function CLASSIFY(r j,explored_list) 2: f eatures\u2190\u2205 3: unary j \u2190 UNARY_FEATURES(r j) 4: APPEND( f eatures,unary j) 5: NON_MAXIMAL_SUPRESS(explored_list) 6: pairs\u2190\u2205 7: for rk \u2208 explored_list do 8: label\u2190 QUERY_LABEL(r j) 9: if label 6= bgnd then\n10: pairr j ,rk \u2190 PAIR_FEATURES(r j,rk) 11: APPEND(pairs, pairr j ,rk ) 12: end if 13: end for 14: agg_pair_ f eatures\u2190 AGG_STATS(pairs) 15: APPEND( f eatures,agg_pair_ f eatures) 16: (label,score)\u2190DAGGER_PREDICT( f eatures) 17: if training then 18: DAGGER_SETLOSS(label,groundtruth) 19: end if 20: return score 21: end function\nDAgger trains a single cost sensitive classifier for policy \u03c0\u0302 that considers features extracted from a state and predicts labels to determine the next action. During training, it starts with an initial classifier and runs through the states, predicting labels for each state. Based on its predictions, it is assigned a loss value at each state. At the end of an iteration, all the features, the predicted labels and the loss values for all states are collected. The aggregate of all the collected datasets until the current iteration is used to train a cost sensitive classifier, which becomes the policy for the next iteration. DAgger is available through a simple interface in the Vowpal Wabbit1 library. It contains a new programming abstraction proposed by Daum\u00e9 III et al. [6] where a developer writes a single predict function that encodes the algorithm for the testing stage and the training is done by making repeated calls to this predict function.\nThe function SEQ_EXPLORE shown in Algorithm 1 is substituted for the predict function in the programming abstraction of Daum\u00e9 III et al. [6]. The input to the algorithm is a list of object proposals and the number of regions that we are allowed to process. We use a modified MCG [4, 9] for region proposal generation and RCNN-depth [9] for region classification. The unary features used for classification are objectness score, proposal rank, mean depth of the region, mean distance from the back of the room, minimum height from the ground and maximum height from the ground. The pairwise features are 2D area overlap, 2D size ratio, distance between centroids, difference in mean distance from the back of the room, difference in minimum heights from the ground and the difference in maximum heights from the ground. Most of these features were used by Silberman et al. [15] for performing support inference. The aggregate feature set is constructed by performing minpooling for each class and each pairwise feature. For example, one of the aggregate features would be constructed by collecting all the distances between centroids of the current region and the regions of table class, and then taking the minimum of those distances. This feature measures \"how far is the closest table (and every other class) from the current region?\"\n1https://github.com/JohnLangford/vowpal_wabbit\nThe computational complexity of our algorithm in the worst case scenario of exploring all regions is O(n2) where we perform classification for every unexplored region at every step after adding one region. However, we do not repeat the classification if a newly explored region is marked as background since it does not change the context features at that step. Hence the number of iterations where we classify the unexplored regions is dependent on the number of foreground regions (k) in the image and the complexity is O(nk). Since there are very few foreground regions in an image, k is usually small."}, {"heading": "3.1 Data subset selection", "text": "Due to the presence of a large number of background regions, the training process can become very slow. Hence we need to select a subset of the background regions such that the training time becomes tractable while maintaining performance. A popular approach to background set collection is hard negative mining, an iterative process where the training data is progressively augmented with the false positive examples produced by the classifier in an iteration. Hard negative mining is a computationally expensive technique which is exacerbated in our case by the already expensive training process for a search strategy. Instead we use a data subset selection technique motivated by the theory of Optimal Experiment Design (OED) [13]. Given a linear regression model, the goal of OED is to select samples such that the variance in the regression coefficients is minimized. A smaller variance in the coefficients indicates that the prediction error on the test set is low and hence the linear regression model trained with such a subset does not overfit the training data. Since DAgger uses a linear classifier to predict actions, we employ an OED criterion to select a subset of the background samples.\nLet X be a matrix of n samples with p features. Let \u03a0 be a row selection matrix of size k\u00d7n. Each row of \u03a0 contains a value of one in exactly one column and zeros otherwise. Let Y be the vector of predicted labels. A linear regression model can be written as\nYk\u00d71 = \u03a0k\u00d7nXn\u00d7p\u03b2p\u00d71 + \u03b5k\u00d71 (4)\n\u03b5 is the noise vector with mean zero and variance \u03c32Ik. In ordinary least squares regression, the prediction error is directly proportional to the variance of the regression coefficients. The variance is given by\nvar(\u03b2\u0302 ) = \u03c32(XT \u03a0T \u03a0X)\u22121 (5)\nOptimal Experiment Design suggests many criteria that optimize the eigenvalues of the inverse covariance matrix as a way to minimize the variance in the regression coefficients. The A-optimal criterion minimizes the trace of the inverse covariance matrix and the D-optimal criterion minimizes the determinant of the inverse covariance matrix. The D-optimal criterion [10] is more popular due to the availability of off-the-shelf implementations and also, it simplifies the determinant minimization of an inverse to maximizing the determinant of the covariance matrix. Since we want to select only a subset of the negative samples, we fix the selection variables for the positive samples. We use a row exchange algorithm2 that iteratively adds and removes rows based on the increments in the determinant. The features we use in the data matrix for subset selection are only the mean centered unary features, since the pairwise features are constructed dynamically and they are difficult to know beforehand.\n2The row exchange algorithm is available as part of the Statistics Toolbox in MATLAB."}, {"heading": "4 Experiments and Results", "text": ""}, {"heading": "4.1 Dataset", "text": "We demonstrate our approach on the NYU depth v2 dataset [15]. We use the RCNN-Depth module of Gupta et al. [9] for the region classification. Their region proposal module is a modified Multiscale Combinatorial Grouping (MCG) [4] technique that incorporates depth features. Their feature extraction module is RCNN [7] which includes CNNs fine-tuned on the depth images. The dataset is split into three partitions - 381 images for training, 414 images for validation and 654 images for testing. Since RCNN is trained on the training split, the performance of the detectors on the training set images is extremely good and does not reflect the behavior of the detectors on the test set. Hence we run the detectors on the validation set, obtain groundtruth labels for the detections and this set forms the training set for learning search strategies. The thresholds for the detectors are set based on the best F1 point on the validation set PR curves. We work with 18 categories and do not include the box category as its performance values are very low with an average precision of 1.4%. The operating characteristics of RCNN-depth can be found in the supplementary material. We consider the top 100 regions obtained from the region proposal module. One of the reasons we use only 100 regions is that as we increase the number of regions, the amount of variation in the background regions increases, making the classification boundaries highly nonlinear given our feature set. Since the number of available positive samples is not sufficiently large, it is difficult to train a nonlinear classifier."}, {"heading": "4.2 Sequential Exploration", "text": "Given a sequence of processed image regions, we measure the performance by the average precision (AP) of object detection performance versus the number of regions processed. Specifically, we measure the average precision at intervals of 10 image regions until we reach 100 image regions. Since our goal is to search for an object of a query class, the sequence of regions produced by our sequential exploration technique is different for different query classes. Figure 2 shows average precision as the number of processed regions increases. Each figure compares various sequences produced for a particular query class. The baseline technique we compare with is the rank sequence obtained from the region proposal technique. The sequence is usually rank diversified and not necessarily sorted by objectness scores. Since the region proposal technique is not aware of the query class, it produces only one sequence for an image.\nFirst, we train a classifier with the query class as the label and just the unary scene context features (see Sec. 3). Since the scene context features do not change based on the regions explored, we obtain scores from this classifier in a single step. The scores are then used to rank the regions to obtain a sequence. Our results indicate that the scene context features alone can achieve a significantly high average precision by using very few regions - for some classes (Ex: bed, nightstand, sofa) almost 20-25% of the regions when compared with the proposal ranking sequence. Next, we perform a sequential search using strategies trained with object-object context features along with the scene context features. The results indicate that for classes like counter, lamp, pillow and sofa, object-object context improves the average precision over using just the scene context features. While we see improvement in the dresser class as well, the number of test samples are too few to determine the significance of the improvement. Figure 3 shows examples of search results for different query classes.\n10 20 30 40 50 60 70 80 90 100\n0.05\n0.1\n0.15\n0.2\n0.25\nbathtub\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.3\n0.35\n0.4\n0.45\n0.5\n0.55\nbed\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.1\n0.15\n0.2\n0.25\n0.3\nbookshelf\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.05\n0.1\n0.15\n0.2\nchair\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.1\n0.15\n0.2\n0.25\n0.3\ncounter\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n\u22120.04\n\u22120.02\n0\n0.02\n0.04\n0.06\n0.08\ndesk\nNumber of Image Regions\nA v e\nra g\ne P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100 0.04\n0.06\n0.08\n0.1\n0.12\n0.14\n0.16\n0.18\ndoor\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100 0.04\n0.06\n0.08\n0.1\n0.12\n0.14\n0.16\n0.18\ndresser\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.05\n0.1\n0.15\n0.2\ngarbage\u2212bin\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100 \u22120.05\n0\n0.05\n0.1\n0.15 lamp\nNumber of Image Regions\nA v e\nra g\ne P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.02\n0.04\n0.06\n0.08\n0.1\n0.12\n0.14\n0.16\nmonitor\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0\n0.02\n0.04\n0.06\n0.08\n0.1\n0.12\n0.14\n0.16\nnight\u2212stand\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.05\n0.1\n0.15\n0.2\n0.25\n0.3\npillow\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.05\n0.1\n0.15\n0.2\n0.25\nsink\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0.15\n0.2\n0.25\n0.3\n0.35\nsofa\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100 0\n0.02\n0.04\n0.06\n0.08\n0.1\n0.12\n0.14\n0.16\ntable\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100 0.08\n0.1\n0.12\n0.14\n0.16\n0.18\n0.2\n0.22\n0.24\ntelevision\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\n10 20 30 40 50 60 70 80 90 100\n0\n0.05\n0.1\n0.15\n0.2\n0.25\n0.3\ntoilet\nNumber of Image Regions\nA v e ra\ng e P\nre c is\nio n\nProposal Rank Scene Context Scene+Objects Context\nFigure 2: Average Precision (AP) vs. number of processed regions. A classifier trained for a query class with unary scene context features alone can achieve a significantly high average precision by processing very few regions. Classes like bed, nightstand and sofa need only 20-25% of the regions when compared to the proposal ranking sequence. A search strategy trained for a query class using both object-object context and scene-context features further improves the performance for classes like counter, lamp, pillow and sofa. While the plots show sequential processing of all 100 regions, the stopping criterion for practical situations can be chosen based on the number of regions at which we obtain the maximum AP.\nThe examples show that our strategy which uses both scene context and object-object context can locate objects of the query class earlier than the other methods.\nThe supplementary material contains plots that compares our technique trained with a randomly selected background subset against our technique trained with the determinant maximization based background subset. The plots show that our determinant maximization based subset selection technique performs better or equally well with the random subset on most of the classes. But the main advantage of our subset selection technique is the repeatability of experiments unlike the one with random subset selection.\nComputation time: On a single core of an Intel 4.0GHz processor, it takes only 20ms on average for the search process in an image with 100 region proposals. The time taken for extracting CNN features is 5ms per region on a GPU. Since our results show that for most of the classes we can achieve a high average precision at around 25 to 50 regions\nGroundtruth Proposal Rank Scene Context Scene+Objects Context\nchair\nchairchair chairchairchairchairchair\nchair\ndoor\nchair\nchair table\ndoor\nchair\nchair\ntable\ndoor\nchair\nchair\nchair\n(a) Searching for chair. Number of regions processed = 15\nlamp\nlamp\npillow pillow\npillow\nbed\npillow\nbed\npillow lamp\nbed\n(b) Searching for lamp. Number of regions processed = 35\npillow pillow\npillow\npillow pillowbed\npillow bed pillow pillow\npillow\nbed\n(c) Searching for pillow. Number of regions processed = 15\nsofa\nsofa\nsofa\npillow\ndoor\nsofa\nchair\nsofa\nsofa\npillow\n(d) Searching for sofa. Number of regions processed = 20\nFigure 3: Search results for different queries. We compare three strategies - ranked sequence obtained from the region proposal technique (unaware of query class), ranked sequence obtained from a classifier trained for a query class using scene context features alone and sequence produced by a search strategy trained for a query class using both scene context and object-object context features. Red boxes indicate regions labeled as query class, yellow boxes indicate regions other than the query class and blue boxes indicate regions labeled as background. The images show a state in the search sequence of different methods at a certain number of regions processed. We can see that our strategy which uses both scene context and object-object context can locate an object of the query class earlier than the other methods.\ninstead of evaluating all 100 regions, the total time taken for feature extraction and search overhead is 0.145s and 0.27s for 25 and 50 regions respectively. This shows that the search overhead is negligible compared to the total time and the reduction in number of regions directly translates to 2 to 4 times speedup in computation time while still achieving a high average precision. The time for context feature extraction is negligible because the necessary information is already extracted by the region proposal module."}, {"heading": "5 Conclusion", "text": "We have proposed a search technique for detecting objects of a particular class in an image by processing as few image regions as possible. The search strategy is framed as a Markov decision process learned using an imitation learning algorithm, which sequentially explores\nregions based on structure in the scene. Our experiments show that unary scene context features of regions can alone achieve a significantly high average precision after processing only 20-25% of the regions for classes like bed, night-stand and sofa. By incorporating object-object context, the performance is further improved for classes like counter, lamp, pillow and sofa. Our sequential search process adds a negligible overhead when compared to the time spent on extracting CNN features, hence the reduction in number of regions leads directly to a gain in computation speed of the object detection process."}, {"heading": "6 Acknowledgements", "text": "This research was supported by contract N00014-13-C-0164 from the Office of Naval Research through a subcontract from the United Technologies Research Center. The GPUs used in this research were generously donated by the NVIDIA Corporation. We thank Hal Daum\u00e9 III for helping us with the Vowpal Wabbit code and Saurabh Gupta for helping us with his RCNN-depth code."}], "references": [{"title": "Apprenticeship learning via inverse reinforcement learning", "author": ["Pieter Abbeel", "Andrew Y Ng"], "venue": "In ICML,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2004}, {"title": "Searching for objects driven by context", "author": ["Bogdan Alexe", "Nicolas Heess", "YW Teh", "Vittorio Ferrari"], "venue": null, "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Cost-Sensitive Top-down / Bottom-up Inference for Multiscale Activity Recognition", "author": ["Mohamed R Amer", "Dan Xie", "Mingtian Zhao", "Sinisa Todorovic", "Song-Chun Zhu"], "venue": null, "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2012}, {"title": "Multiscale Combinatorial Grouping", "author": ["Pablo Arbelaez", "Jordi Pont-Tuset", "Jonathan T Barron", "Ferran Marques", "Jitendra Malik"], "venue": "In CVPR,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "Optimal scanning for faster object detection", "author": ["Nicholas J. Butko", "Javier R. Movellan"], "venue": null, "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2009}, {"title": "Efficient programmable learning to search", "author": ["Hal Daum\u00e9 III", "John Langford", "Stephane Ross"], "venue": "arXiv preprint arXiv:1406.1837,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2014}, {"title": "Rich feature hierarchies for accurate object detection and semantic segmentation", "author": ["Ross Girshick", "Jeff Donahue", "Trevor Darrell", "Jitendra Malik"], "venue": "In CVPR,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2014}, {"title": "An active search strategy for efficient object detection", "author": ["Abel Gonzalez-Garcia", "Alexander Vezhnevets", "Vittorio Ferrari"], "venue": "In CVPR,", "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2015}, {"title": "Learning Rich Features from RGB-D Images for Object Detection and Segmentation", "author": ["Saurabh Gupta", "Ross Girshick", "P Arbel\u00e1ez", "J Malik"], "venue": "In ECCV,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2014}, {"title": "D-Optimality for Regression Designs: A Review", "author": ["R.C. St. John", "N.R. Draper"], "venue": "NAGARAJA et al.: SEARCHING FOR OBJECTS USING STRUCTURE IN INDOOR SCENES", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 1975}, {"title": "Beyond sliding windows: Object localization by efficient subwindow search", "author": ["Christoph H Lampert", "Matthew B Blaschko", "Thomas Hofmann"], "venue": "In CVPR,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2008}, {"title": "Human-level control through deep reinforcement learning", "author": ["Volodymyr Mnih", "Koray Kavukcuoglu", "David Silver", "Andrei a Rusu", "Joel Veness", "Marc G Bellemare", "Alex Graves", "Martin Riedmiller", "Andreas K Fidjeland", "Georg Ostrovski", "Stig Petersen", "Charles Beattie", "Amir Sadik", "Ioannis Antonoglou", "Helen King", "Dharshan Kumaran", "Daan Wierstra", "Shane Legg", "Demis Hassabis"], "venue": "Nature, 518(7540):529\u2013533,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2015}, {"title": "Optimal Design of Experiments", "author": ["Friedrich Pukelsheim"], "venue": "Society for Industrial and Applied Mathematics,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 1993}, {"title": "A Reduction of Imitation Learning and Structured Prediction", "author": ["St\u00e9phane Ross", "Geoffrey J Gordon", "J Andrew Bagnell"], "venue": "In AISTATS,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2011}, {"title": "Indoor Segmentation and Support Inference from RGBD Images", "author": ["Nathan Silberman", "Pushmeet Kohli", "Derek Hoiem", "Rob Fergus"], "venue": "In ECCV,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2012}], "referenceMentions": [{"referenceID": 6, "context": "The current prevalent object detection framework [7] is a pipeline of two main stages: the object proposal stage and the feature extraction/classification stage.", "startOffset": 49, "endOffset": 52}, {"referenceID": 11, "context": "The true reward function is unknown for our sequential exploration problem since the underlying distribution from which a spatial arrangement of objects in an image is generated is unknown, analogous to a game generated by a hidden emulator [12].", "startOffset": 241, "endOffset": 245}, {"referenceID": 0, "context": "Learning an optimal policy in such situations is known as imitation learning [1] where an oracle predicts the actions it would take at a state and the search policy learns to imitate the oracle and predict similar actions.", "startOffset": 77, "endOffset": 80}, {"referenceID": 13, "context": "[14] that trains a classifier as the search policy on a dataset of features extracted at states and actions taken by the oracle (labels), where the states are generated by running the policy iteratively over the training data.", "startOffset": 0, "endOffset": 4}, {"referenceID": 14, "context": "Hence we illustrate our technique on the indoor scene dataset, NYU depth v2 [15].", "startOffset": 76, "endOffset": 80}, {"referenceID": 8, "context": "[9] showed that RCNN [7] trained with depth information greatly improved object detection performance.", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "[9] showed that RCNN [7] trained with depth information greatly improved object detection performance.", "startOffset": 21, "endOffset": 24}, {"referenceID": 3, "context": "For example, object proposal techniques [4, 16] rank regions in an image based on their likelihood of containing an object.", "startOffset": 40, "endOffset": 47}, {"referenceID": 10, "context": "[11] prune the space of windows using a branch and bound algorithm.", "startOffset": 0, "endOffset": 4}, {"referenceID": 4, "context": "Butko and Movellan [5] use a Partially Observable Markov Decision Process to sequentially place a digital fovea (a center of fixation) to detect a single target in an image.", "startOffset": 19, "endOffset": 22}, {"referenceID": 1, "context": "[2] use only spatial context to choose a set of windows to be processed.", "startOffset": 0, "endOffset": 3}, {"referenceID": 7, "context": "[8] use both spatial context and the classifier scores of previously explored regions.", "startOffset": 0, "endOffset": 3}, {"referenceID": 2, "context": "[3] propose an explore-exploit strategy that schedules processes of top-down inference using activity context and bottom-up inference using activity parts.", "startOffset": 0, "endOffset": 3}, {"referenceID": 0, "context": "In imitation learning [1], rather than specifying a reward function, an oracle demonstrates the action to take and the policy learns to imitate the oracle.", "startOffset": 22, "endOffset": 25}, {"referenceID": 13, "context": "[14] propose an imitation learning algorithm called DAgger (Dataset Aggregation) that does not make the i.", "startOffset": 0, "endOffset": 4}, {"referenceID": 5, "context": "[6] where a developer writes a single predict function that encodes the algorithm for the testing stage and the training is done by making repeated calls to this predict function.", "startOffset": 0, "endOffset": 3}, {"referenceID": 5, "context": "[6].", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "We use a modified MCG [4, 9] for region proposal generation and RCNN-depth [9] for region classification.", "startOffset": 22, "endOffset": 28}, {"referenceID": 8, "context": "We use a modified MCG [4, 9] for region proposal generation and RCNN-depth [9] for region classification.", "startOffset": 22, "endOffset": 28}, {"referenceID": 8, "context": "We use a modified MCG [4, 9] for region proposal generation and RCNN-depth [9] for region classification.", "startOffset": 75, "endOffset": 78}, {"referenceID": 14, "context": "[15] for performing support inference.", "startOffset": 0, "endOffset": 4}, {"referenceID": 12, "context": "Instead we use a data subset selection technique motivated by the theory of Optimal Experiment Design (OED) [13].", "startOffset": 108, "endOffset": 112}, {"referenceID": 9, "context": "The D-optimal criterion [10] is more popular due to the availability of off-the-shelf implementations and also, it simplifies the determinant minimization of an inverse to maximizing the determinant of the covariance matrix.", "startOffset": 24, "endOffset": 28}, {"referenceID": 14, "context": "1 Dataset We demonstrate our approach on the NYU depth v2 dataset [15].", "startOffset": 66, "endOffset": 70}, {"referenceID": 8, "context": "[9] for the region classification.", "startOffset": 0, "endOffset": 3}, {"referenceID": 3, "context": "Their region proposal module is a modified Multiscale Combinatorial Grouping (MCG) [4] technique that incorporates depth features.", "startOffset": 83, "endOffset": 86}, {"referenceID": 6, "context": "Their feature extraction module is RCNN [7] which includes CNNs fine-tuned on the depth images.", "startOffset": 40, "endOffset": 43}], "year": 2015, "abstractText": "To identify the location of objects of a particular class, a passive computer vision system generally processes all the regions in an image to finally output few regions. However, we can use structure in the scene to search for objects without processing the entire image. We propose a search technique that sequentially processes image regions such that the regions that are more likely to correspond to the query class object are explored earlier. We frame the problem as a Markov decision process and use an imitation learning algorithm to learn a search strategy. Since structure in the scene is essential for search, we work with indoor scene images as they contain both unary scene context information and object-object context in the scene. We perform experiments on the NYU-depth v2 dataset and show that the unary scene context features alone can achieve a significantly high average precision while processing only 20-25% of the regions for classes like bed and sofa. By considering object-object context along with the scene context features, the performance is further improved for classes like counter, lamp, pillow and sofa.", "creator": "LaTeX with hyperref package"}}}