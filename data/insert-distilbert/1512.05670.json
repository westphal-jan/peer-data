{"id": "1512.05670", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "17-Dec-2015", "title": "Towards automating the generation of derivative nouns in Sanskrit by simulating Panini", "abstract": "furthermore about 1115 rules in astadhyayi are from a. 4. 1. 76 to a. 5. 4. 160 deal with generation of derivative chemicals nouns, making it about one of firstly the largest topical sections in astadhyayi, called as well the systematic taddhita section owing to the head class rule a. 25 4. 1. 76. this section is solely a hypothetical systematic arrangement subdivision of rules that enumerates various affixes that are used in the derivation under specific semantic relations. \u2022 we propose a system that automates the process of generation of derivative compounds nouns nationwide as per the nomenclature rules in astadhyayi. the proposed system nowadays follows entirely a completely object oriented sorting approach, that models each rule as a class of its own and then groups them locally as rule groups. the rule sequence groups are decided on the basis of selective grouping of rules by virtue of universal anuvrtti. the grouping of rules results in creating an inheritance network of rules which is a directed acyclic graph. every associated rule group has a head rule and the head rule usually notifies all the direct member rules of the group knowledge about the environment which contains all the details about data entities, participating in proceeding the derivation process. the system implements this mechanism using multilevel inheritance and observer design patterns. the constructed system focuses not only on generation of the lowest desired final form, but also on the correctness of sequence sort of rules applied carefully to make sure that starting the derivation has taken place in strict adherence to astadhyayi. the proposed system's design allows to collectively incorporate similarly various conflict resolution identification methods mentioned in authentic texts and hence the effectiveness of those rules can be validated with the results from the system. we also present cases where we have checked the applicability of the system with the rules which are not specifically applicable to derivation of derivative nouns, in any order to see the effectiveness of the proposed schema as a generic system for modeling astadhyayi.", "histories": [["v1", "Thu, 17 Dec 2015 16:55:57 GMT  (565kb)", "http://arxiv.org/abs/1512.05670v1", "16th World Sanskrit Conference, Bangkok June 28th - July 02 2016"], ["v2", "Tue, 22 Dec 2015 10:07:35 GMT  (565kb)", "http://arxiv.org/abs/1512.05670v2", "16th World Sanskrit Conference, Bangkok June 28th - July 02 2015"]], "COMMENTS": "16th World Sanskrit Conference, Bangkok June 28th - July 02 2016", "reviews": [], "SUBJECTS": "cs.CL", "authors": ["amrith krishna", "pawan goyal"], "accepted": false, "id": "1512.05670"}, "pdf": {"name": "1512.05670.pdf", "metadata": {"source": "CRF", "title": "Towards automating the generation of derivative nouns in Sanskrit by simulating Pa\u0304n\u0323ini", "authors": ["Amrith Krishna", "Pawan Goyal"], "emails": ["amrith@iitkgp.ac.in", "pawang@cse.iitkgp.ernet.in"], "sections": [{"heading": null, "text": "Towards automating the generation of derivative nouns in Sanskrit by simulating P\u0101\u1e47ini\nAmrith Krishna Department of CSE,\nIndian Institute of Technology, Kharagpur, India\namrith@iitkgp.ac.in\nPawan Goyal Department of CSE,\nIndian Institute of Technology, Kharagpur, India pawang@cse.iitkgp.ernet.in\n(Presented at the 16th World Sanskrit Conference, Bangkok June 28th - July 02 2016) Abstract\nAbout 1115 rules in A\u1e63\u1e6d\u0101dhy\u0101y\u012b from A.4.1.76 to A.5.4.160 deal with generation of derivative nouns, making it one of the largest topical sections in A\u1e63\u1e6d\u0101dhy\u0101y\u012b, called as the Taddhita section owing to the head rule A.4.1.76. This section is a systematic arrangement of rules that enumerates various affixes that are used in the derivation under specific semantic relations. We propose a system that automates the process of generation of derivative nouns as per the rules in A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The proposed system follows a completely object oriented approach, that models each rule as a class of its own and then groups them as rule groups. The rule groups are decided on the basis of selective grouping of rules by virtue of anuv\u1e5btti. The grouping of rules results in an inheritance network of rules which is a directed acyclic graph. Every rule group has a head rule and the head rule notifies all the direct member rules of the group about the environment which contains all the details about data entities, participating in the derivation process. The system implements this mechanism using multilevel inheritance and observer design patterns. The system focuses not only on generation of the desired final form, but also on the correctness of sequence of rules applied to make sure that the derivation has taken place in strict adherence to A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The proposed system\u2019s design allows to incorporate various conflict resolution methods mentioned in authentic texts and hence the effectiveness of those rules can be validated with the results from the system. We also present cases where we have checked the applicability of the system with the rules which are not specifically applicable to derivation of derivative nouns, in order to see the effectiveness of the proposed schema as a generic system for modeling A\u1e63\u1e6d\u0101dhy\u0101y\u012b."}, {"heading": "1 Introduction", "text": "A\u1e63\u1e6d\u0101dhy\u0101y\u012b, the central part of P\u0101\u1e47ini\u2019s grammar, is a classic and seminal work on descriptive linguistics. A\u1e63\u1e6d\u0101dhy\u0101y\u012b provided a complete description of the Sanskrit language spoken at that time period, and is also often praised for the computational principles and programming concepts used in it. Approximately one fourth (about 1115) of rules in A\u1e63\u1e6d\u0101dhy\u0101y\u012b deal with generation of derivative nouns (and adjectives), which are derived by affixation from other nouns (or adjectives). The affixes that are used for derivation of derivative nouns are enumerated in the Taddhita section of A\u1e63\u1e6d\u0101dhy\u0101y\u012b and hence the affixes that come under this section are called Taddhita. Taddhita section starts with rule A.4.1.76 \u0924\u093f\u0924\u093e\u0903 of A\u1e63\u1e6d\u0101dhy\u0101y\u012b which is an adhik\u0101ra rule and its influence is till the end of fifth chapter i.e. A.5.4.160 \u093f\u0928\u0935\u093e\u093f\u0923\u0903 \u091a. Though P\u0101\u1e47ini did not provide any semantic definition for Taddhita, it is based on rule A.5.1.5 \u0924\u0948 \u093f\u0939\u0924\u092e \u094dwhich means \u201cbeneficial to that\u201d (Bhate, 1989), where \u201cthat\u201d(\u0924)\u0948 is intended for the base nominal from which the derivation will take place. A\u1e63\u1e6d\u0101dhy\u0101y\u012b considers both nouns and adjectives as a single category called as Pr\u0101tipadika (\u093e\u093f\u0924\u092a\u093f\u0926\u0915), and hence the affixes used in Taddhita are not category changing affixes (Deo, 2007).\nThough A\u1e63\u1e6d\u0101dhy\u0101y\u012b was intended for human understanding and usage, our work attempts to automate the process of deriving Taddhitas in complete adherence to A\u1e63\u1e6d\u0101dhy\u0101y\u012b. Our work, not only aims to generate the correct final form from any given nominal but also to follow the sequence of rules applied as per A\u1e63\u1e6d\u0101dhy\u0101y\u012b in the derivation process. Hence the work requires to automate rules in A\u1e63\u1e6d\u0101dhy\u0101y\u012b that deal with Taddhita section as well as other associated rules, which help in the derivation process. The proposed system adopts a completely object oriented approach in modeling A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The rules of A\u1e63\u1e6d\u0101dhy\u0101y\u012b are modeled as classes and so is the environment that contains the entities for derivation. The rules are then grouped based on the notion of topicality by virtue of anuv\u1e5btti. In our proposed system the rule group formation is achieved through formation of inheritance network i.e. multilevel inheritance formed between individual rule classes, which has been inspired from the inheritance network that P\u0101\u1e47ini used in A\u1e63\u1e6d\u0101dhy\u0101y\u012b (Deo, 2007). P\u0101\u1e47ini uses anuv\u1e5btti to carry forward the inherited components to child rules, though it needs to be noted that signifying of the inheritance is one of the aspects of anuv\u1e5btti, and hence our proposed model does not form the inheritance network over all the usages of anuv\u1e5btti, but rather a subset of it. The principles discussed in A\u1e63\u1e6d\u0101dhy\u0101y\u012b that enable rule selection and rule application like A.1.4.2 \u093f\u0935\u093f\u0924\u0937\u0927\u0947 \u0947 \u092a\u0930\u0902 \u0915\u093e\u092f \u092e \u094d, siddha and asiddha are built right into the core architecture of proposed system. In addition to these principles, the system provides a functionality to adopt different conflict resolution methods that are discussed outside of A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The system does not restrict itself by adopting any particular conflict resolution method, instead it facilitates to try out various methods that have been mentioned in various scholarly works. This will thus help to evaluate various methods and report on their accuracy as no single set of conflict resolution methods has gained consensus among the scholars. The rest of the paper is organized as follows. In Section 2, we will be discussing about various attempts towards formalizing rules of A\u1e63\u1e6d\u0101dhy\u0101yi, and modeling A\u1e63\u1e6d\u0101dhy\u0101yi in part or full to a automated system. In Section 3, we will look into the linguistic and structural features of Taddhita section. We will be discussing about various linguistic characteristics that the affixes in the domain possess. We will also be looking into the arrangement of rules in Taddhita section and how the arrangement forms an inheritance hierarchy. In Section 4 we will be describing the working of the proposed system, tools and techniques used for the implementation and also modeling of data environment and rule classes. Section 5 will show a step by step derivation of a nominal from another base noun. Section 6 will show the applicability of the proposed schema as a general framework to model entire A\u1e63\u1e6d\u0101dhy\u0101yi by considering how the proposed system handles rules that are not specific to the derivation of a derivative noun. Section 7 details about the evaluation framework and results. The section also presents some analysis of incorrect cases and other special instances that we encountered in our system. Finally, Section 8 discusses the bottlenecks in automating the A\u1e63\u1e6d\u0101dhy\u0101yi that we encountered during the implementation of our system, salient features and application domains of the system along with directions for future work."}, {"heading": "2 Related Work", "text": "A\u1e63\u1e6d\u0101dhy\u0101yi has received much attention from computational linguists from the latter half of 20th century. A\u1e63\u1e6d\u0101dhy\u0101yi was much lauded for its brevity, completeness and computational insights it provides. There have been works from eminent scholars about the formalism of P\u0101\u1e47ini\u2019s Grammar, its expressive power, and the derivation process (prakriy\u0101) it follows. Seminal works from Cardona (1965) and Staal (1965) on formalizing rules of the grammar with stress on the meta-rules that state about the context sensitive aspects was a starting point with further enhancements from Cardona (1969) where he applies his formalization for more rules that is related to phonetic changes.\nCardona (2009) highlights the relevance of affixation and how it is well integrated with\nsyntax as a continuum in P\u0101\u1e47ini\u2019s derivational system. He points out the contrast that P\u0101\u1e47ini\u2019s system bears with the system that western grammarians follow, where morphology and syntax are treated as independent components in derivation. Penn and Kiparsky (2012) focus on the expressive power of A\u1e63\u1e6d\u0101dhy\u0101yi rules and also the expressive power of formalism that P\u0101\u1e47ini used to design A\u1e63\u1e6d\u0101dhy\u0101yi. They demonstrate that the formalism of the grammar has far more expressive power than that of regular languages and Context Free Languages. Their work emphasizes on the power of formalism that has built-in capacity for disambiguation at syntactic level. Hyman (2009) developed a finite state transducer after re-framing individual rules in A\u1e63\u1e6d\u0101dhy\u0101yi, resulting in generation of strings that belong to regular languages and performs sandhi (\u0938\u093f) at word boundaries for any two given word combinations. Hyman had introduced an XML vocabulary for encoding rules in A\u1e63\u1e6d\u0101dhy\u0101yi that helped him in implementing the finite state transducer. Scharf (2009) discusses about Scharf\u2019s and Hyman\u2019s combined efforts in developing XML formalization that not only deals with sandhi but also with nominal declensions and verb conjugations.\nThere have been various attempts to automate A\u1e63\u1e6d\u0101dhy\u0101yi in parts as well as modeling it entirely. Goyal et al. (2009) implemented an inflectional morphology generator that takes as input a noun from the user and then generates all 21 forms of noun declensions, known as vibhakti system in Sanskrit grammar. The authors talk about the programming perspectives that need to be considered when encoding rules in A\u1e63\u1e6d\u0101dhy\u0101yi, and various computational aspects that A\u1e63\u1e6d\u0101dhy\u0101yi possesses. They also talk about the need of conflict resolution methods for competing rules that can be applied in the same context. Jha et al. (2009) have developed a system that is an inflectional morphology analyser. They have developed independent systems for verb and noun forms and their corresponding inflections. Though their work was not related to simulating A\u1e63\u1e6d\u0101dhy\u0101yi, but they claim that they take into account the P\u0101\u1e47inian way of analysis. Satuluri and Kulkarni (2014) takes on generation of Sanskrit compounds called as sam\u0101sa that deals with about 400 rules of A\u1e63\u1e6d\u0101dhy\u0101yi which helps them to form compound words from independent words in Sanskrit. Their work talks about various kinds of semantic features that act as the constraints governing compound formation.\nSubbanna and Varakhedi (2009) have talked in length about the Computational Structure of the A\u1e63\u1e6d\u0101dhy\u0101yi, and introduced the concept of rules that continuously observe the environment or the subject to which modifications are to be made. They have also talked about Siddha,Assidhavat and Asiddha principles used in A\u1e63\u1e6d\u0101dhy\u0101yi.There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied. Subbanna and Varakhedi (2009) mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked. They also talk about various conflict resolution methods that are mentioned in the s\u016btras as well as in other v\u0101rttikas. Subbanna and Varakhedi (2010) presented a computational model based on the principle of asiddhatva, an improvised model over the one discussed in Subbanna and Varakhedi (2009). Mishra (2009) talks of the nature of grammar which performs the analysis of constituent elements and then its reconstitution using various set of operational rules as mentioned in A\u1e63\u1e6d\u0101dhy\u0101yi. Mishra (2010) in his work discusses about ved\u0101\u1e45ga principles and extends his work by considering the common methodological approach of ancillary disciplines for rule application. His work provides a good walk-through for the entire derivation process that begins with introduction of atomic elements to coming up with the desired final form. Kulkarni (2009) establishes the issue with phonological over-generation that can occur, if one is to strictly adhere to the rules defined by P\u0101\u1e47ini. Jha and Mishra (2009) sheds some light in formalizing semantic categorization rules when he deals with k\u0101raka systems. These kind of issues have been a matter of debate among linguists for quite long. Many principles that are not stated in A\u1e63\u1e6d\u0101dhy\u0101y\u012b but in other texts written at various points of time have surfaced to\ndeal with such issues, mainly those which concern about conflict resolution in rule selection. Cardona (1997) discusses about various principles like utsarga-ap\u0101vada, antara\u1e45ga-bahira\u1e45ga, nitya-anitya etc. in detail.\nWhen it comes to automating Taddhitas, the Sanskrit Heritage System is an existing system that can recognize taddhitas and perform the analysis, but it does not generate the Taddhitas and only the lexicalized Taddhitas are recognized during the analysis (Goyal and Huet, 2013). To the best of the authors\u2019 knowledge, the system which we are going to propose is the first of its kind, that is focused specifically on generation of derivative nouns (Taddhitas). The proposed system embraces a unique approach of forming rule groups where similar rules are grouped together to form a Directed Acyclic Graph (DAG). The similarity of rules is based on the notion of topicality present among the rules by virtue of usage of anuv\u1e5btti. The approach can be treated as analogous to the model, what is proposed in Subbanna and Varakhedi (2009), but they propose the formation of similar topic DAG through utsarga-ap\u0101vada relations. One cannot comment on the similarity of the approaches without a proper comparison of DAGs formed from both of them. Moreover Subbanna and Varakhedi (2009) mentioned that they had not checked the feasibility of automating their notion of rule group formation. Another important feature that our system uses is that it automatically notifies the relevant rule classes whenever the data environment state changes. This eliminates the overhead of linear searching over each rule, or each rule polling the environment to find its application. Instead the mechanism allows the rules to be updated about environment state changes whenever there is one and yet the rule classes can refrain from state dependency issues with the environment (Szallies, 1997)."}, {"heading": "3 Linguistic and Structural aspects of Taddhita Section", "text": "In the Taddhita section, P\u0101\u1e47ini identifies about 300 semantic relations under which Pr\u0101tipadikas can be generated with Taddhita affixes. It is mentioned as a sub-section to pratyay\u0101dhik\u0101ra that deals with all kinds of affixes. The rules in Taddhita section deal with three entities namely semantic relations, affixes and stems or collection of stems from ga\u1e47ap\u0101\u1e6dha. The rules are defined in such a way so as to facilitate affixation of the proper Taddhita affix with respect to semantic relation intended. The rules often deal with properties of the entities involved at various levels from phonological, morphological, syntactic and semantic levels. There are two types of derivations possible that involve Taddhita affixes (Sharma, 2002).\nPr\u0101tipadika + Taddhita-affix Pr\u0101tipadika + Taddhita-affix + str\u012b-affix"}, {"heading": "3.1 Linguistic Phenomena in Derivational Morphology", "text": "Derivational morphology in Sanskrit, like in many other languages poses some of the well known facts about many to many correspondences between forms and affixes. Taddhita affixes exhibit affix polysemy, homonymy, synonymy and non-compositionality. In affix polysemy, the same affix is used to denote related senses like in the case of patronymic and provenance relation. In affix homonymy the same affix is used in distinct and unrelated semantic contexts like in the case of personal nouns or abstract nouns. Affix synonymy deals with the same semantic sense but uses different affixes. For example, for the patronymic relation \u0905\u092a\u092e \u094d, multiple affixes can be used, like \u0905(\u0923)\u094d, \u0905\u092f\u0928(\u092b\u0915)\u094d, \u0907(\u091e)\u094d depending on the stems used (Deo, 2007)."}, {"heading": "3.2 Organization of Taddhita rules", "text": "Taddhita section is primarily subdivided into five pratyay\u0101dhik\u0101ras or domain of control of five pratyayas.\n\u25a0 The five rules are:\nI A.4.1.83 \u093e\u0915 \u094d \u0926\u0940\u0924\u0903 \u0905\u0923 \u094d - \u0905\u0923 \u094d suffix is the default affix to be used for affixation for all the rules till A.4.4.1. The influence of A.4.1.83 is till the term \u0926\u0940\u093f\u0924 is found (or till another pratyay\u0101dhik\u0101ra is found) and \u0926\u0940\u093f\u0924 appears in rule A.4.4.2 \u0924\u0928\u0947 \u0926\u0940\u093f\u0924 \u0916\u0928\u093f\u0924 \u091c\u092f\u093f\u0924 \u093f\u091c\u0924\u092e \u094d. II A.4.4.1 \u093e\u0915 \u094d \u0935\u0939\u0924\u0903\u0947 \u0920\u0915 \u094d \u0964 - \u0920\u0915 \u094d suffix is the default affix to be used for affixation for all the rules till A.4.4.76. \u0935\u0939\u093f\u0924 appears in rule A.4.4.76 \u0924\u0924 \u0935\u094d\u0939\u093f\u0924 \u0930\u0925\u092f\u0917\u0941\u093e\u0938\u092e \u094d. III 4.4.75 \u093e\u0915 \u094d \u093f\u0939\u0924\u093e\u0924 \u092f\u094d\u0924 \u094d - \u092f\u0924 \u094d is the default affix to be used for affixation for all the rules till A.5.1.5.\u093f\u0939\u0924\u092e \u094dappears in rule 5.1.5 \u0924\u0948 \u093f\u0939\u0924\u092e \u094d.\nIV 5.1.1 \u093e\u0915 \u094d \u0940\u0924\u093e\u0924 \u091b\u094d\u0903 - \u091b\u0903 is the default affix to be used for affixation for all the rules till A.5.1.37 \u0940\u0924\u092e \u094dappears in rule 5.1.37 \u0924\u0928\u0947 \u0940\u0924\u092e \u094d.\nV 5.1.18 \u093e\u0917 \u0935\u094d\u0924\u0903\u0947 \u0920\u091e \u094d - \u0920\u091e i\u094ds the default affix to be used for affixation for all the rules till A.5.1.115. \u0935\u093f\u0924\u0903 appears in rule 5.1.115 \u0924\u0928\u0947 \u0924\u0941\u0902 \u093f\u092f\u093e \u091a\u0924\u0947 \u0935\u094d\u093f\u0924\u0903 .\nNow each of the above given rules, which can be called as the pratyay\u0101dhik\u0101ra rules, specifies what is the most prominent affix or the default case affix that can be applied to all the rules which are under its domain. For the set of rules under a single pratyay\u0101dhik\u0101ra, they are further categorized on the basis of arth\u0101dhik\u0101ra rules. Each arth\u0101dhik\u0101ra heads a set of rules which are a proper subset of rules that come under the pratyay\u0101dhik\u0101ra. The arth\u0101dhik\u0101ra rules state the semantic conditions or the semantic rules under which the default affix can be attached. Arth\u0101dhik\u0101ra rules serve the purpose of a topic head that groups a set of rules as a rule group based on a topic, which is a semantic relation here and it also acts as an operational rule (\u093f\u0935\u093f\u0927), as it carries the semantic sense under which the affix can be attached. Rules A.4.1.92 \u0924 \u0905\u092a\u092e \u094d, A.4.2.1 \u0924\u0928\u0947 \u0930\u0902 \u0930\u093e\u0917\u093e\u0924 \u094d, A.4.2.69 \u0924 \u093f\u0928\u0935\u093e\u0938\u0903 etc. denote the semantic senses such as patronymic, \u201ccoloured by means of that\u201d and provenance respectively. This kind of arrangement handles affix polysemy and affix homonymy. But to handle affix synonymy, there are other operational rules, that come under the domain of arth\u0101dhik\u0101ra rules. They can be seen as exception rules or rules to handle special cases. These rules limit the application of default affix specified in pratyay\u0101dhik\u0101ra and mention what other affixes can be used instead, under special conditions. In this way, affix synonymy and non-compositionality is taken care of. Deo (2007) calls this form of arrangement as constrained separationism, where the rules form\na multilevel single inheritance network. The template for the multilevel inheritance network will be of the type, \u201cDefault Affix rule\u201d -\u201cSemantic Sense rule\u201d - \u201cSpecial case rules\u201d. Figure 1 shows an instance of how the hierarchy in Taddhita works. As already discussed, A.4.1.83 states about the default affix \u0905\u0923 \u094d for rules under its domain, A.4.1.92 states about the patronymic relation under which a nominal will get the default affix. Now rule A.4.1.128 states about a special case when the stem \u091a\u091f\u0915\u093e is used with the patronymic relation. In such a case the suffix \u0910\u0930\u0915 \u094d needs to be attached. This rule overrides the default case rule. Now consider rule A.4.4.25. This rule talks about usage of \u0905\u0923 \u094das an exception or special case when a stem \u092e\u0941 is used. The rule has A.4.4.1 as its default affix rule and the default affix for the domain is \u0920\u0915.\u094d The rule\u2019s semantic sense is \u0938\u0938\u0902\u0943,\u0947 which means \u2018properly mixed with\u2019. Here the rule A.4.4.25 accounts for the non-compositionality of the affix \u0905\u0923 \u094dand is not specified in its domain but as an exception rule in another default affix domain. It is to be noted that there are some more rules in the Taddhita section which do not come under any of the five pratyayadhik\u0101ra rules. Those rules have arth\u0101dhik\u0101ras of their own but has no default affix to be attached. This group of rules is treated as extraneous to otherwise systematic network of the section (Bhate, 1989). As we will be discussing about the implementation schema of proposed generation system in the subsequent section, it will become evident that this anomaly in no way is going to affect the system."}, {"heading": "4 Implementation", "text": ""}, {"heading": "4.1 Derivational Process", "text": "In order to discuss about the derivation process or (\u093f\u092f\u093e) of a derivative noun, let us take the derivation of derivative noun\u0914\u092a\u0917\u0935 from the nominal \u0909\u092a\u0917 \u0941, which can be considered as the \u201cHello world\u201d in Taddhita section. The essential steps in the derivation process are shown in Table 1. \u0914\u092a\u0917\u0935 which means son of upagu, comes from the semantic sense \u0905\u092a\u0902 by the rule 4.1.92 \u0924 \u0905\u092a\u092e \u094d, and the correct Taddhita affix \u0905\u0923 \u094d is introduced to the environment. Once the Taddhita affix is introduced, what remains is a series of operations on the environment that results in a final form. The rules so triggered may be seen as a continuous iteration of two sub-processes. One is identification and assignment of technical terms (\u0938\u0902\u093e) to the environment string or to a relevant substring of it. By this, the environment does not get modified but gains the technical term as an attribute. The interpretive rules assign the technical terms to the environment and those rules are shown in the first column of Table 1. Now, by virtue of these attributes, the environment gets modified through operational rules that come within the domain of attributes as shown in the third column of Table 1. The effect of the rule on the environment can be seen in the second column. Triggering of operational rules is the second sub-process in the iteration and the derivation process stops when no more attributes can be attributed to the environment. Ideally, by that time the desired form must be derived."}, {"heading": "4.2 Overview of the Implementation System", "text": "For automating the derivation process, we suggest the following method which is based on object oriented concepts. Each rule forms a class and each instance of the rule class (henceforth to be referenced as rule itself) is registered with the environment, such that whenever there is a change in the environment, the rules are notified. Each rule checks for the possibility of it being applied on the environment and for a rule, if all its conditions are satisfied, ideally the rule can be applied on the environment. However, in a general scenario multiple rules may claim their competency for application on the environment. To handle such scenarios we keep those competing rules in a list called candidate list. Then a conflict resolution method is employed which decides the winner rule. The winner rule gets to apply on the environment and other rules are removed from list. By removal of rules other than the winner rule, we mean that the removed ones are not applied on the present instance of environment, although they are notified when the environment change happens again. Figure 2 shows the schema of the implementation\nsystem. As it is evident from discussion about Taddhita section, P\u0101\u1e47ini among various applications of anuv\u1e5btti, uses it for carrying the topicality between different rules as well. It is to be noted that adhik\u0101ra rules are rules whose sole purpose is mentioning the topicality of the rules under its domain of influence. But even for adhik\u0101ra rules, anuv\u1e5btti itself is used for carrying the domain\u2019s influence to other rules. Apart from the adhik\u0101ra rules, there are other rules as well in which anuv\u1e5btti is used to carry the topicality. For example consider the rules concerning \u0907\u0924 \u094d, i.e. rules from 1.3.2 to 1.3.8. Here \u0909\u092a\u0926\u0936\u0947 \u0947 and \u0907\u0924 \u094dare being carried forward to other rules as well. \u0909\u092a\u0926\u0936\u0947,\u0947 which means \u2018when an upade\u015ba is encountered\u2019, perform some action. This condition leads to a common topicality for all the rules under the anuv\u1e5btti. This is similar to the notion of arth\u0101dhik\u0101ra rules in Taddhita where the notion of semantic sense is being carried forward to subsequent rules through anuv\u1e5btti. Both the techniques, anuv\u1e5btti and adhik\u0101ra are employed in the entire A\u1e63\u1e6d\u0101dhy\u0101y\u012b and are not unique to the Taddhita section. We can infer that a subset of the anuv\u1e5btti rules, mostly the ones which carry the notion of topicality can be used to design an inheritance hierarchy of classes. For the implementation we will be using this notion of topicality via anuv\u1e5btti, in grouping of rules to form rule groups which is an inheritance hi-\nerarchy among rules and the rule in which the portion of anuv\u1e5btti appears, becomes the head rule."}, {"heading": "4.3 Tools and Techniques Used", "text": "We are following a completely object oriented approach for the implementation of the system. The following tools and techniques will be employed to achieve the principles discussed in section 4.2"}, {"heading": "4.3.1 Observer Design Patern", "text": "Observer design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically (Gamma et al., 1994). The object on which the state changes occur is called subject and it maintains a list of its dependents, called observers. As shown in Figure 3, each observer object which is the s\u016btra or rule in our case, is registered to an object called as \u201cSubject\u201d class which represents the environment in our case. Subject class has a method to register the observers. Whenever a change in value of some attribute of subject occurs, it calls the method \u2018notify\u2019 of observer abstract class, which is implemented for each object of the Observer."}, {"heading": "4.3.2 Multilevel Inheritance", "text": "To form rule groups i.e. inheritance network among rules we use multilevel inheritance between the rules. Though multilevel inheritance is allowed, multiple inheritance is not allowed in the system and hence no single rule will inherit from two distinct rules directly. Figure 4 shows\nthe inheritance achieved for each class in A\u1e63\u1e6d\u0101dhy\u0101y\u012b. All classes inherit from a base class called \u201cs\u016btra\u201d, which is a generic class that defines all possible features that a rule or s\u016btra can possess. All other rules inherit from it. The adhik\u0101ra rules, anuv\u1e5btti of interpretive rules, default condition rules etc. form super class for other operational rule classes."}, {"heading": "4.4 Rule Triggering and Propagation", "text": "The environment forms the subject class for the observer design pattern. However, not all rules are observing the environment but only those rules that do not come under the domain of any adhik\u0101ra rules or a controlling head of a rule group through anuv\u1e5btti (which are mostly rules that assigns the technical terms to assignments). Those are represented by classes R1, R2 and so on in Figure 5. Then there are rule groups as represented by RG1, RG2 and so on. These are collections of rules with same head. The rule classes that come under the same head in the group, inherit from the head rule class. The head rule object, as per observer design pattern registers the inherited classes\u2019 objects as observers. Now the head class notifies the observers whenever the environment satisfies the head rule\u2019s conditions. The conditions checked are those conditions that need to be satisfied by all the rules registered under the head. Here, by \u2018head\u2019, we mean either an adhik\u0101ra or a component passed on by anuv\u1e5btti. Now top level rules are those rules which observe the environment directly and get notified whenever the environment changes. For a rule, if the environment satisfies its conditions, it will be added to the candidate list. But if the environment satisfies the conditions that is applicable to an entire rule group, then the environment object is passed on to the next level and this continues till an exception or specific rule is encountered or else returns back to where the default rule resides. By this model, we can employ conflict resolution at each level, and resolve some of them locally and only rules that have no common head at any level come to the candidate list at top-most level, from where the winner rule will be selected. Once a winner rule is selected, the rule\u2019s intended action is executed first and then its parent object is called which performs its relevant portion in execution, if any. This continues until all the rules in hierarchy are called. It is to be noted that many a times certain rules like the adhik\u0101ra rules do not have anything to execute of their own; in such cases the rule object just passes on the environment to its parent object. By this design, redundancy of hard coding the same rules again and again per rule object is saved, just like the way anuv\u1e5btti helps a person to avoid repeating the rules when reciting A\u1e63\u1e6d\u0101dhy\u0101y\u012b."}, {"heading": "4.4.1 Working", "text": "Let us consider the working of the system with reference to affixation for semantic relation \u0905\u092a\u092e \u094d, i.e. the patronymic relation. Figure 6 shows the trace for the affixation process of Taddhita affix when the semantic relation is patronymic and the stem is \u091a\u091f\u0915\u093e. In Figure 6, the solid lines show inheritance hierarchy between the rule classes. The dashed line on the left of each block shows traversing of the hierarchy by triggering of rules from head to specific rules. The traversal checks for eligible rule to apply on environment within the rule group, and this can be called as the checking phase. The dotted lines on the right of each block show the trace of rules that get executed. The starting node, i.e. the node that heads the dotted edge with label 1 is the exact rule that gets executed and other nodes in the path show those rules that have been executed due to anuvrtti. This can be called as the execution phase. As an example let us consider the case where the environment is initialized with \u091a\u091f\u0915\u093e\u092f\u093e\u0903 \u0905\u092a\u092e \u094d. The triggering starts from head rule at the top level i.e. from A.3.1.1 to rule A.4.1.128 as shown in Figure 3. Here in rule A.3.1.1, it does not have any condition to check, so it directly notifies all of its direct descendants. Now among the direct descendants, rule A.4.1.1 checks for presence of any of the two affixes \u093f\u0919, \u0906\u092a \u094d or if the environment has a pr\u0101tipadika in it, i.e. it checks for conditions mentioned directly in the rule. As it is a pr\u0101tipadika, the condition will evaluate to \u2018true\u2019,and all its descendants are notified. In due course, A.4.1.76, A.4.1.83 are also notified. These rules as well do not have any extra checks as they are adhik\u0101ra rules and hence all its direct descendants are notified. When A.4.1.92 is notified, it checks for semantic condition and the checking turns out to be true for A.4.1.92, while the checking will evaluate to \u2018false\u2019 for all of its sister nodes, i.e. other direct descendants of A.4.1.83. The special case rules registered under A.4.1.92 are notified, of which A.4.1.128 satisfies the remaining conditions. As it does not have any rules registered to it, it becomes the terminal node and hence it is added to the candidate list. Since for this case no other rule is contesting, the rule emerges winner and starts its execution from A.4.1.128.\nThe rule adds the affix \u0910\u0930\u0915 \u094d to environment, and passes the environment to its parent class i.e. A.4.1.92. A.4.1.92 does not have anything to execute of its own, so it simply passes environment to A.4.1.83, which checks if any affix is already attached, as the affix \u2018\u0910\u0930\u0915\u2019\u094d is attached in this case, no action is performed. The environment gets passed to parent node of each rule finally this terminates at top level rule A.3.1.1. Now consider the derivation of \u0909\u092a\u0917\u094b\u0903 \u0905\u092a.\u0902 As with the case of \u091a\u091f\u0915\u093e\u092f\u093e\u0903 \u0905\u092a,\u0902 the path of the rules checked for eligibility of rule application remains the same till rule A.4.1.92 is reached. Once A.4.1.92 is reached it will notify all of its descendants as well. But since no rule will find its application, A.4.1.92 will become the final node of the path here. It is added to candidate list, which while executing will simply call the parent rule A.4.1.83. A.4.1.83 checks for presence of any new Taddhita affix in the environment. If the check evaluates to false, i.e. if no new Taddhita affix is found, A.4.1.83 treats this as default case scenario and attaches \u0905\u0923 \u094d, the default case affix to environment. After each execution of a rule, the system checks for presence of any new assignment of \u2018technical term\u2019 or else all rules in the top level are notified as discussed in Section 4.1.\nThe arth\u0101dhik\u0101ra rules inherit from its corresponding pratyay\u0101dhik\u0101ra rules, apart from the ones already mentioned in Section 3.2. When it comes to affixation, during the checking for eligibility of a rule to apply i.e at the checking phase, we need to traverse the pratyay\u0101dhik\u0101ra rule, before an arth\u0101dhik\u0101ra rule is reached. Though a pratyay\u0101dhik\u0101ra rule is visited during checking, no action is taken there. The pratyay\u0101dhik\u0101ra rule simply passes the environment to all arth\u0101dhik\u0101ra rules which are its direct descendants. In fact for a single affixation, all the pratyay\u0101dhik\u0101ra rules get notified from its parent rule, and those rules in turn notify all their direct descendants as there is not enough information to select a single pratyay\u0101dhik\u0101ra at during the checking phase. So in effect, the process of affixation for taddhita starts by checking for the right semantic condition i.e at the arth\u0101dhik\u0101ra rules as it is in the case of traditional system of derivation. Before that, the other rules either simply pass on the environment to\ntheir descendants or check for conditions that is necessary for the process to qualify as a case for affixation under taddhita. The effect of pratyay\u0101dhik\u0101ra rule comes during the execution phase i.e at the applying of affix phase and not on the checking phase. During the execution phase the pratyay\u0101dhik\u0101ra which is parent to the winner arth\u0101dhik\u0101ra rule acts as the final gate that makes sure that the environment has the valid taddhita affix added to the environment before it reaches its parent. The rule checks if any taddhita affix is introduced by virtue of special case rules, and if no such execution has taken place, then the default affix is added to the environment. The environment is then passed on to higher level rules that takes care of other generic aspects about the environment."}, {"heading": "4.5 Environment Representation", "text": "The environment is an object which contains the data entities that take part in the derivation process. Entities can be stems, affixes, augments, characters or any of their properties. The most basic and atomic entity in the environment is another object called \u2018\u015babda\u2019. The environment also contains various instances of the class \u2018\u015babda collection\u2019 , which contains a sequence of references to \u015babda objects along with a set of attributes that belongs to the collection. Instances of \u2018\u015babda collection\u2019 are used to represent various technical terms that may be attributed to environment or a part of it. Figure 7 shows how the environment is set up. Figure 7 shows the environment after the affixation of Taddhita affix \u0905\u0923 .\u094d As already seen in Section 4.4.1, the Taddhita affixation happened due to presence of technical term pr\u0101tipadika. Now the technical term pr\u0101tipadika is modeled as an attribute of the environment object, and it is an object itself of the class \u2018\u015babda collection\u2019. It contains references to sequence of all the \u015babda objects, which is collectively eligible for the technical term pr\u0101tipadika. Similarly inside \u2018pratyaya\u2019 object, it has an attribute \u2018it marker\u2019 which also is an object of \u2018\u015babda collection\u2019 class called \u2018it\u2019. If you notice though the it (\u0907\u0924)\u094d marker is \u0923 \u094din \u0905\u0923 \u094d, it is not the \u015babda\u2019s property that it is an it marker. It is the property of pratyaya that gives the \u015babda \u0923 \u094d, the property of it marker. This notion is captured very well in the system. It is essential that we store them as attributes separately for further\nreference and usage in the derivation process. For example, consider the derivation process for \u0101\u015bval\u0101yana. The term \u0101\u015bval\u0101yana is formed from a\u015bvala by affixing \u2018phak\u2019 pratyaya. Here the \u2018it\u2019 marker is \u2018k\u2019, which will be stored in \u2018it marker\u2019 object, and later it will be elided, and hence be removed from the \u2018text value\u2019 of pratyaya object by application of rules A.1.3.3 and A.1.3.9 . In due course of derivation the pratyaya object will get a substitution of \u2018\u0101yana\u2019 for the remaining \u2018pha\u2019 by rule A.7.1.2. Now in order to complete the derivation process, rule A.7.2.118 should stand valid in one of the subsequent steps. RuleA.7.2.118 requires a Taddhita affix with k as \u2018it\u2019 marker. If we had not stored this information as a separate attribute earlier, we would have lost this information and derivation would not have completed. In case of asiddhavat rules as discussed in Subbanna and Varakhedi (2009), the environment makes a complete copy of itself; one object is used for checking the conditions while in the other object, all the operations are applied. Once the system returns back to siddha section, the copy used for checking the conditions is discarded. It is also to be noted that in the representation the space between entities are also \u015babda objects, representing the vir\u0101ma (\u093f\u0935\u0930\u093e\u092e) as per the rule A.1.4.110 \u093f\u0935\u0930\u093e\u092e\u0903 \u0905\u0935\u0938\u093e\u0928\u092e \u094d."}, {"heading": "4.6 Rule Selection and Conflict Resolution", "text": "There are instances in A\u1e63\u1e6d\u0101dhy\u0101yi where multiple rules, which we call as candidate rules, find their suitability to be applied on the derivation environment. In such cases, we need to employ mechanisms that help us in resolving the conflicts. There is little information about conflict resolution among candidate rules in A\u1e63\u1e6d\u0101dhy\u0101yi, though commentaries on A\u1e63\u1e6d\u0101dhy\u0101yi by other scholars do mention about such mechanisms. It may be the case that P\u0101\u1e47ini had assumed those principles which were prevalent in his time as a prerequisite to understand his treatise on grammar. But this has led to debates among the scholars resulting in different schools of thought. In the wake of such a scenario, we have decided to implement the conflict resolution module as a separate pluggable module in our system, so that we can try out different methods\non which the scholars in general have come to a consensus. But our system internalizes one concept as a default standard, the rule A.1.4.2 \u093f\u0935\u093f\u0924\u0937\u0927\u0947 \u0947 \u092a\u0930\u0902 \u0915\u093e\u092f \u092e \u094d. The rule is discussed in A\u1e63\u1e6d\u0101dhy\u0101yi itself and the details of how it works is discussed in Section 6. From various commentaries on Sanskrit grammar, we have also considered the mechanism described in \u2018paribh\u0101\u1e63en\u1e0du\u015bekhara\u2019 of \u2018N\u0101ge\u015ba\u2019 as \u2018p\u016brvaparanity\u0101ntara\u1e45g\u0101pava\u1e0d\u0101n\u0101muttarottaram bal\u012bya\u1e25\u2019 which is generally accepted among the scholsrs. This gives the following linear order.\nprior (p\u016brva) < subsequent (para) < obligatory (nitya) < internally conditioned (antara\u1e45ga) < exception (apav\u0101da)\nAs it is evident from our discussions, we have centered our system design based on the notion of topicality, and the multilevel inheritance network is formed on the basis of topical head rules and the corresponding child nodes. This makes it possible for us to adopt the utsarga-apav\u0101da principle of conflict resolution without any extra efforts. But when it comes to rules which do not fall under similar topical heads, it can be observed that sometimes proper rule selection does not take place. There are some instances in Taddhita section itself, where utsarga-apav\u0101da principle is not sufficient to resolve rule selection conflict . To resolve such a scenario, we have applied the specificity hierarchy as mentioned in Scharf (2010). Specificity hierarchy deals with a priority wise ordering of rules based on the linguistic features present in the rule (or a combination of the same, if multiple entities are present) from the most concrete to the most abstract features. The linear ordering is as follows:\nPhonetics < Phonology < Morphological < Semantic\nThe specificity of a rule is determined by the individual specificity aspects of entities that are present in a rule as pre-conditions to be satisfied. It is also to be noted that within the entities with the same specificity, finer granularity may be present. For instance, in the apatya semantic sense in the Taddhita section, there are rules that state conditions for the presence of semantic sense of three varying degree of specificity, apatyam, gotra and yuv\u0101m, and it goes without saying that all the three fall under the same specificity hierarchy of \u2018semantic\u2019. But amongst these, gotra is more specific than apatyam, and yuv\u0101m is more specific than gotra. Hence when two rules find their application in an environment, where one has apatyam as semantic sense and the other has gotra as the semantic sense, the one with gotra specification will emerge as the winner rule even if the former rule comes after the later rule as per the A\u1e63\u1e6d\u0101dhy\u0101yi s\u016btra ordering. Just like in the case of topicality, there are no explicit markings available in A\u1e63\u1e6d\u0101dhy\u0101yi to identify the specificity. We need to encode the same in our rule classes explicitly, similar to the treatment given to topicality in our implementation. We have implemented specificity hierarchy for the apatya section in our prototype system and that has improved the results substantially which will be discussed in Section 7.\nWe will be discussing the effect of applying these conflict resolution methods in Taddhita section and in other specific instances which are outside the scope of Taddhita in Section 6, to establish the system\u2019s effectiveness as an automated system for simulation of the entire A\u1e63\u1e6d\u0101dhy\u0101yi."}, {"heading": "5 Derivation of a Derivative Noun", "text": "In this section we will show how the nominal stem\u0914\u092a\u0917\u0935 is derived in the system. In section 4.4.1, the affixation is already shown. However, some of the finer details regarding post processing after execution of the rule are not discussed, which we will be doing in this step by step walkthrough of the derivation. Please refer to Table 1 for state of environment after each rule is applied.\n\u25a0 Affixation as shown in section 4.4.1. Here the user input \u201c\u0909\u092a\u0917 \u0941\u0919\u0938 \u0905\u094d\u092a\u201d\u0902, has led to affixation of desired affix \u0909\u092a\u0917 \u0941 \u0919\u0938 \u094d\u0905\u0923 \u094d. As the affix got added to the environment in the form of\n\u2018pratyaya\u2019 object as shown in Figure 7, two more attributes were also added to the \u2018pratyaya\u2019 object. The two attributes are \u2018upade\u015ba\u2019 and \u2018Taddhita\u2019. Contrary to as discussed in section 4.4.1, the attributes are not objects by themselves. This is because the pratyaya object bears reference to the exact sequence of \u015babda objects as these two attributes and hence separate object instantiation is not required. The pr\u0101tipadika object which is an attribute of the environment, but signifying the base nominal \u0909\u092a\u0917 \u0941\u0919\u0938 \u094d, i.e. the stem upagu in genitive case, goes to \u201cprocessed\u201d state.\n\u25a0 Since there are two new attributes that are not yet in processed state in one of the objects of environment, instead of notifying the top level rules, system takes in the attribute upade\u015ba which is a technical term and is assigned to pratyaya object, and triggers corresponding rule group (in this case the rule group headed by A 1.3.2). This leads to instantiation of \u2018it marker\u2019 object as shown in Figure 7 and subsequently to rule 1.3.9 that leads to elision of the it marker. Though the marker is elided, neither the object reference nor the \u015babda object, the marker is referring to, is removed from the environment. In fact the \u015babda object keeps the marker information (\u093f\u0923\u0924)\u094d as a separate attribute.\n\u25a0 Now since no more rules can be triggered automatically, the system notifies all the top level rules of which, top level rule A.1.2.46 finds its eligibility due to presence of attribute \u2018Taddhita\u2019. Though A.1.2.46 gets Pr\u0101tipadikam \u093e\u093f\u0924\u092a\u093f\u0926\u0915\u092e \u094d from A.1.2.45 as anuv\u1e5btti, still it is not modeled as a descendant of A.1.2.45, as it does not represent topicality or common condition. The effect of the anuv\u1e5btti passed on here is that of assigning of the term, which is an effect on the rule, not a cause or condition on the rule. Environment gets a new attribute Pr\u0101tipadika.\n\u25a0 No specific rule group can be invoked by Pr\u0101tipadika attribute. All top level rules are notified, of which only A.2.4.71 finds its eligibility, which also happens to be a top level rule. This results in removal of \u0919\u0938 \u094d\n\u25a0 Similarly, the system will get the object \u2018a\u1e45ga\u2019 (for the technical term a\u1e45ga) as an attribute to environment, after the rule A.1.4.13 find its eligibility, and the system will directly notify the rule group headed by A.6.4.1 \u0905. A.7.2.117 will find its eligibility to apply. The exact same steps are executed for subsequent operations, where the technical terms \u092d and \u0938\u093f\u0902\u0939\u0924\u093e are assigned due to the rules A.1.4.18 and A.1.4.109 respectively and by virtue of those attributes to environment, rules A.6.4.146 and A.6.1.78 respectively are executed resulting in the desired final form \u0914\u092a\u0917\u0935."}, {"heading": "6 The Schema as a General Schema for Modelling A\u1e63\u1e6d\u0101dhy\u0101y\u012b", "text": "In section 5, we have seen the working of the system. In this section we will be considering rules that are outside of Taddhita section. Scharf (2010) discusses five cases in which conflict of application occurs between two competing rules. In his paper, Scharf talks about conflict between rules A.6.1.87 and A.6.1.88 where the domain of application of A.6.1.88 is properly contained within the domain of application of rule A.6.1.87. Here A.6.1.88 should emerge as the winner rule, or else 6.1.88 will never be applied to any context. In our system A.6.1.87 is a direct descendant of A.6.1.84 which is a direct descendant of A.6.1.77. The only aspect that is passed from A.6.1.77 as part of inheritance is \u0905\u093f\u091a, which is nothing but checking for a vowel as a right context. One might argue that A.6.1.84 does not have any relevance for this checking, but A.6.1.84 is an adhik\u0101ra rule and hence the execution will never stop at the rule; instead it will surely traverse down to one of the descendant rules. Also, its domain of influence is completely within the set of rules which is under the influence of rule A.6.1.77. Now A.6.1.87 is one such rule. It is also evident from this instance as to how the rule is inheriting a set of mutually exclusive features and conditions by multilevel inheritance, avoiding the need for multiple inheritance. A.6.1.88 is also one such rule, but it needs an additional checking of\ncondition which is checked also at A.6.1.87. So in our system A.6.1.88 inherits from A.6.1.87 and becomes descendant of 6.1.87 by virtue of the anuv\u1e5btti of \u0906\u0926.\u094d So whenever environment object is passed on to A.6.1.87, it first checks presence of \u0905 or \u0906 as the left context and then notifies all its registered rules including A.6.1.88. If the rule is applicable to A.6.1.88, i.e., if the environment satisfies all the conditions as demanded by 6.1.88 then it gets activated. So in addition to check for left context as per A.6.1.87, A.6.1.88 also checks for \u090f\u091a \u094das right context, which is applicable only to itself. This check is further restricting the scope of application to what occurred at rule A.6.1.77 where the checking was for \u0905\u091a \u094d. If this evaluates to \u2018true\u2019, it will block the direct application of A.6.1.87 i.e. gu\u1e47a will not happen there, but instead v\u1e5bddhi will take place. If no rules turn out to be eligible for application, then only A.6.1.87 will perform the application of gu\u1e47a over the environment. Please note that the checking of other conditions that are applicable to these rules are not discussed here as those conditions are obtained by virtue of anuv\u1e5btti and are being checked in the parent rules. Now let us consider a case where partial blocking occurs when the rules A.6.1.77 and A.6.1.101 are in conflict. Our system deals with this in the same manner as we dealt with simple blocking. Rule A.6.1.101 inherits \u0905\u093f\u091a, i.e. element of ac praty\u0101h\u0101ra, as right context. One thing to notice here is that the rule A.6.1.77 also checks for \u0907\u0915\u0903, i.e., element of ik praty\u0101h\u0101ra in the context. But this is not carried forward as anuv\u1e5btti. Now this rule is modeled as follows. The environment is passed onto A.6.1.77 and then it first checks for \u0905\u093f\u091a. Since only this is carried as anuv\u1e5btti, once this condition evaluates to \u2018true\u2019, the rule notifies all rules registered with it. It waits for any of its descendants to claim eligibility. If no rule claims eligibility then the rule checks for additional condition of \u0907\u0915\u0903 and if the condition evaluates to \u2018true\u2019, it claims the eligibility. In case of conflict between A.6.1.77 and A.6.1.101, the desired rule is A.6.1.101, but A.6.1.101 is a descendant of A.6.1.77, so it will claim its eligibility and hence A.6.1.77 will be blocked from claiming its eligibility as per our system. From these examples it is evident that the system, without even using any extra conflict resolution techniques, can resolve the conflicts here. These examples demonstrate that the system internalizes rule A.1.4.2 \u093f\u0935\u093f\u0924\u0937\u0927\u0947 \u0947 \u092a\u0930\u0902 \u0915\u093e\u092f \u092e \u094d. Now consider the case when there is a conflict between the rules A.7.3.111 and A.7.1.73. Here both the rules belong to domain of a\u1e45ga, i.e., rule A.6.4.1. Neither of the rules inherit from the other, and hence both of them are at sibling level and have a common parent at rule A.6.4.1. In such a case where both the rules claim eligibility, the conflict which is at the level of rule A.6.4.1, needs to be resolved. The desired rule in such a case is A.7.1.73. The important point to be noted here is that though the system internalizes the concept of A.1.4.2, it still does not claim A.7.3.111 as the winner rule. Instead the system will pass both the rules to the conflict resolution method coded as a separate function in the system, once it reaches the object for the rule A.6.4.1. We will be trying out different conflict resolution methods mentioned in authentic texts and will be reporting the accuracy of each method or various combinations of these methods on different data samples. Other conflict cases discussed in Scharf (2010) are not discussed here as those fall into one of the scenarios already discussed."}, {"heading": "7 Evaluation Results", "text": ""}, {"heading": "7.1 Evaluation Framework", "text": "For the evaluation, we have implemented the entire apatya section in the A\u1e63\u1e6d\u0101dhy\u0101yi. The apatya section consists of rules from A.4.1.92 to A.4.176 which deal with the affixation rules for stems that need to be used along with semantic sense of apatyam (with its subtypes gotra, yuv\u0101m) or \u2018the descendant of\u2019 semantic relation. For the proper execution of these rules, we were required to implement other rules that come in the multilevel inheritance hierarchy like the pratyay\u0101dhik\u0101ra rule A.4.1.83 and its exceptions as well as those outside the Taddhita section like v\u1e5bddhi, gu\u1e47a and other associated rules. We have selected 60 input cases that cover the whole span of \u2018apatya\u2019 section and obtained the output after affixation from the system.\nA web based survey interface was used for the human judgment experiment.1. We divided our inputs into sets of 3, each set having 20 input cases. We then reached out to the experts from Sanskrit linguistics to participate by evaluating one or more of these sets. A total of five experts from the linguistics and Sanskrit computational linguistics fields participated in the evaluation. For a given input case, the following details were provided to the experts: the input string, conditions and assumptions that were required for the correct derivation, winner rule number and the s\u016btra contents, candidate rules which had conflicts and finally the output form. The experts were asked to do a binary evaluation of the correctness of output, based on the input and other constraints provided. In case of difference of opinion among the experts, we took the majority opinion as the truth value after weighing in the remarks provided by all the experts.\nThe results of the evaluation are shown in Table 2. From among the 60 input cases, a total of 10 cases were evaluated as incorrect. As already discussed in Section 4.6, the system has internalized viprati\u1e63edha as its default conflict resolution mechanism. The outputs were obtained with no other conflict resolution mechanism being employed. 10 cases resulted in wrong output. We later implemented the specificity hierarchy for conflict resolution and then obtained the outputs again for the same set of input cases. This time, the number of incorrect output cases were reduced to 4. We will be discussing some of the wrong output cases in Section 7.2.\n7.2 Analysis of Wrong Cases and Other Special Cases. \u25a0 For inputs \u0909 \u0919\u0938 \u094d\u0905\u092a\u092e \u094d, \u093f\u0926\u093f\u0924 \u0919\u0938 \u094d\u0905\u092a\u092e \u094d, the rules that got applied were A.4.1.95 and\nA.4.1.122 respectively which essentially look for the phonological properties. The correct rules to be applied for the instances are A.4.1.86 and A.4.1.85 respectively. Though these rules have the same topical heads, they are specified before the current winner rules in\n1The evaluation URLs are :- Set 1 - http://goo.gl/forms/Lj5z3UzUr9, Set 2 - http://goo.gl/forms/2O31D6gF83, Set 3 - http://goo.gl/forms/goWgwMnYct"}, {"heading": "8 Discussion and Conclusion", "text": ""}, {"heading": "8.1 Bottlenecks in Automating the Astadhyayai", "text": "Our attempt was to automate the Taddhita section in Astadhyayai which primarily deals with affixation of derivational nouns. It is evident from the discussions so far, that P\u0101\u1e47ini uses a rich set of linguistic features in formulating rules and conditions to check for, before affixation. From the discussion about specificty hierearchy, we can see that the entire A\u1e63\u1e6d\u0101dhy\u0101yi has used variety of linguistic features ranging from phonetic to semantic features. Along with such features, P\u0101\u1e47ini occasionally used the intention of the speaker as a condition to be satisfied as well. For example, if we consider the rule 4-1-147 \u0917\u094b\u093f\u092f\u093e\u0903 \u0915\u0941\u0928 \u0947 \u0923 \u091a , the term \u0915\u0941\u0928 signifies \u2018reproach\u2019. It is the intention of speaker whether or not to address someone by referring through the \u2018descendant of\u2019 relation in a disrespectful way. Such an aspect cannot be captured beforehand. So while implementing the automated system, we either had to generate all the alternatives, whenever the condition to be satisfied is an intention, or else ask for human intervention to clarify the intention. We proceeded with the later method as the former strictly does not adhere to the intended output derivation of the grammar.\nIn Section 7.2, the first case can raise a question about our assumption in the specificity hierarchy. The desired rule for the instance discussed is A.4.1.86 and the conflicting rule is A.4.1.95. Now if we look into the rule contents, we can find that rule A.4.1.86 does not come under any \u2018arth\u0101dhik\u0101ra\u2019, and only comes under a \u2018pratyay\u0101dhik\u0101ra\u2019 and A.4.1.95 has an \u2018arth\u0101dhik\u0101ra\u2019. It can be argued that A.4.1.95 has a higher priority as per specificity hierarchy as it has a semantic condition, but the desired rule does not have a semantic condition, but only a morphological condition. These observations motivated us for the existing assumption. The linguistically motivated counter argument is that if we go by the former argument, then the rule A.4.1.86 will never find its applicability. From the implementation aspect of view, the default affix rule A.4.1.83 and its exceptions which include A.4.1.86 as well, get to apply the prefix after a suitable semantic relation is found, which are later rules like A.4.1.92, which is in fact a semantic condition and this nullifies the effect. The assumption still needs to be validated in other similar rule conflict cases outside of Taddhita section.\nIn Section 6, we have talked in length about how the system has internalized the rule A.1.4.2. Among different type of rules that P\u0101\u1e47ini had formualted in his treatise, A.1.4.2 is a metarule, that describes about how other rules are to be interpreted. There are many such metarules in A\u1e63\u1e6d\u0101dhy\u0101yi like A.1.1.66, A.1.1.49 etc. In our system we have internalised those concepts and directly applied those in our implementation logic. So in our implementation the metarules are assumed to be known and the metarules are followed, but there is no explicit entity defined for the same. Further research is required to code meta-rules as separate entities, to have their presence stated explicitly."}, {"heading": "8.2 Conclusions and Future directions", "text": "The proposed schema, which is primarily aimed at the automated generation of derivative nouns, or what is called as Taddhita section, adopts a completely object oriented approach in modeling the system. To the best of the authors\u2019 knowledge, the system is first of its kind that focuses specifically on modeling Taddhita section of A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The system not only focuses on generation of correct final forms but also in producing the correct sequence of rules applied for the entire derivation process. This approach doubles the system as a tool for pedagogy, where a learner can use the system to learn about the derivation process by trying out nominal of his choice, rather than restricting himself to a fixed set of textbook examples or a set of stored samples. As already discussed, the system facilitates in adopting and trying out various conflict resolution methods for rule selection, which can be programmed separately and then invoked from the system. As there is no consensus over one correct set of resolution methods,\nthe proposed system can be used as a validation tool for verifying the accuracy of different conflict resolution methods that have been mentioned in various scholarly works. In fact, we have not yet mentioned about one of the major areas of application for the proposed system. Since the system is essentially generating nouns (or adjectives) from other nouns (or adjectives) based on semantic relations, the system can be used to obtain relations between different nominals in an automated way. This kind of information can be used to supplement available lexical resources like IndoWordNet for sanskrit (Bhattacharyya, 2010) and also to provide supplementary information in dictionary entries for lexical databases as described in Huet (2004).\nOur system forms rule groups as Directed Acyclic Graphs (DAG), analogous to as Subbanna and Varakhedi (2009) suggests. But our notion of topical rule groups arises from the notion of topicality by virtue of anuv\u1e5btti, while Subbanna and Varakhedi (2009) attempts to form the topical rule groups from general-exception rule concepts. The approaches in group formation need to be studied further, in order to comment on the commonality of the DAGs so formed, but Subbanna and Varakhedi (2009) do not talk about the attempts to model their concept in implementation. As each rule class implements precisely what is mentioned in the rule, and the implied portion is inherited by virtue of anuv\u1e5btti from the parent class, the system can keep a trace of all the parent rules that have acted upon the environment, due to triggering of a particular rule. This gives the learner a much more detailed view of triggering of rules. The environment data structure is also an object based implementation, environment mostly stores properties and does not have methods or functions that model any aspect of A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The functions or methods implemented in environment are mostly for programmatic conveniences or adding functionality to the system front-end. This makes the set up of environment comparable to the set up as in Scharf et al. (2015) which is primarily an XML representation. The conversion of Objects to XML schema is a well addressed task in IT World (Jain and Thakur, 2002). Hence one can also think of developing a schema to transfer the data entities used in one system to the other, as Scharf et al. (2015) tries to model the entire A\u1e63\u1e6d\u0101dhy\u0101y\u012b."}, {"heading": "Acknowledgments", "text": "We would like to extend our gratitude towards Dr. G\u00e9rard Huet, Dr. Peter Scharf and Dr. Amba Kulkarni for their support and valuable inputs from the discussions we had related to the work. We would also like to thank the experts, Ms. Sukhada, Ms. Anuja Ajotikar, Ms. Tanuja Ajotikar, Mr. Pavankumar Satuluri and Mr. P Sanjeev for participating in the system evaluation we had conducted and also for sharing their valuable comments."}], "references": [{"title": "Panini\u2019s Taddhita rules", "author": ["Saroja Bhate."], "venue": "University of Poona, Pune.", "citeRegEx": "Bhate.,? 1989", "shortCiteRegEx": "Bhate.", "year": 1989}, {"title": "Indowordnet", "author": ["Pushpak Bhattacharyya."], "venue": "proceedings of LREC-10. Citeseer.", "citeRegEx": "Bhattacharyya.,? 2010", "shortCiteRegEx": "Bhattacharyya.", "year": 2010}, {"title": "On translating and formalizing p\u0101\u1e47inian rules", "author": ["George Cardona."], "venue": "Journal of the Oriental Institute of Baroda, volume 14, pages 306\u201314.", "citeRegEx": "Cardona.,? 1965", "shortCiteRegEx": "Cardona.", "year": 1965}, {"title": "Studies in indian grammarians i: the method of description reflected in the \u015bivas\u016btras", "author": ["George Cardona."], "venue": "Transactions of the American Philosophical Society, pages 3\u201348. JSTOR.", "citeRegEx": "Cardona.,? 1969", "shortCiteRegEx": "Cardona.", "year": 1969}, {"title": "Panini: His work and its traditions vol 1", "author": ["George Cardona."], "venue": "Background and Introduction. 2nd ed. Motilal Banarsidass.", "citeRegEx": "Cardona.,? 1997", "shortCiteRegEx": "Cardona.", "year": 1997}, {"title": "On the structure of p\u0101\u1e47ini\u2019s system", "author": ["George Cardona."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 1\u201332. Springer.", "citeRegEx": "Cardona.,? 2009", "shortCiteRegEx": "Cardona.", "year": 2009}, {"title": "Derivational morphology in inheritance-based lexica: Insights from p\u0101\u1e47ini", "author": ["Ashwini Deo."], "venue": "Lingua, volume 117.1, pages 175\u2013201. Elsevier.", "citeRegEx": "Deo.,? 2007", "shortCiteRegEx": "Deo.", "year": 2007}, {"title": "Design Patterns: Elements of Reusable Object-Oriented Software", "author": ["Erich Gamma", "Richard Helm", "Ralph Johnson", "John Vlissides."], "venue": "Addison Wesley.", "citeRegEx": "Gamma et al\\.,? 1994", "shortCiteRegEx": "Gamma et al\\.", "year": 1994}, {"title": "Completeness analysis of a sanskrit reader", "author": ["Pawan Goyal", "G\u00e9rard Huet."], "venue": "Proceedings, 5th International Symposium on Sanskrit Computational Linguistics. DK Printworld (P) Ltd, pages 130\u2013171.", "citeRegEx": "Goyal and Huet.,? 2013", "shortCiteRegEx": "Goyal and Huet.", "year": 2013}, {"title": "Computer simulation of a\u1e63\u1e6d\u0101dhy\u0101y\u012b: Some insights", "author": ["Pawan Goyal", "Amba Kulkarni", "Laxmidhar Behera."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 139\u2013161. Springer.", "citeRegEx": "Goyal et al\\.,? 2009", "shortCiteRegEx": "Goyal et al\\.", "year": 2009}, {"title": "Design of a lexical database for sanskrit", "author": ["G\u00e9rard Huet."], "venue": "Proceedings of the Workshop on Enhancing and Using Electronic Dictionaries, pages 8\u201314. Association for Computational Linguistics.", "citeRegEx": "Huet.,? 2004", "shortCiteRegEx": "Huet.", "year": 2004}, {"title": "From p\u0101\u1e47inian sandhi to finite state calculus", "author": ["Malcolm D. Hyman."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 253\u2013265. Springer.", "citeRegEx": "Hyman.,? 2009", "shortCiteRegEx": "Hyman.", "year": 2009}, {"title": "Xml to object translation, June 13", "author": ["S. Jain", "S. Thakur."], "venue": "US Patent App. 09/755,501.", "citeRegEx": "Jain and Thakur.,? 2002", "shortCiteRegEx": "Jain and Thakur.", "year": 2002}, {"title": "Semantic processing in p\u0101\u1e47ini\u2019s k\u0101raka system", "author": ["Girish Nath Jha", "Sudhir K. Mishra."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 239\u2013252. Springer.", "citeRegEx": "Jha and Mishra.,? 2009", "shortCiteRegEx": "Jha and Mishra.", "year": 2009}, {"title": "Inflectional morphology analyzer for sanskrit", "author": ["Girish Nath Jha", "Muktanand Agrawal", "Subash", "Sudhir K. Mishra", "Diwakar Mani", "Diwakar Mishra", "Manji Bhadra", "Surjit K. Singh."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 219\u2013238. Springer.", "citeRegEx": "Jha et al\\.,? 2009", "shortCiteRegEx": "Jha et al\\.", "year": 2009}, {"title": "On siddha, asiddha and sth\u0100nivat", "author": ["S.D. johshi", "J.A.F. Roodbergen."], "venue": "Annals of the Bhandarkar Oriental Research Institute, volume 68, pages 541\u2013549. Bhandarkar Oriental Research Institute.", "citeRegEx": "johshi and Roodbergen.,? 1987", "shortCiteRegEx": "johshi and Roodbergen.", "year": 1987}, {"title": "Phonological overgeneration in p\u0101\u1e47inian system", "author": ["Malhar Kulkarni."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 306\u2013319. Springer.", "citeRegEx": "Kulkarni.,? 2009", "shortCiteRegEx": "Kulkarni.", "year": 2009}, {"title": "Simulating the p\u0101\u1e47inian system of sanskrit grammar", "author": ["Anand Mishra."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 127\u2013138. Springer.", "citeRegEx": "Mishra.,? 2009", "shortCiteRegEx": "Mishra.", "year": 2009}, {"title": "Modelling a\u1e63\u1e6d\u0101dhy\u0101y\u012b: An approach based on the methodology of ancillary disciplines (vedanga)", "author": ["Anand Mishra."], "venue": "Sanskrit Computational Linguistics, Fourth International Symposium, Delhi, India, pages 239\u2013258. Springer.", "citeRegEx": "Mishra.,? 2010", "shortCiteRegEx": "Mishra.", "year": 2010}, {"title": "On p\u0101\u1e47ini and the generative capacity of contextualized replacement systems", "author": ["Gerald Penn", "Paul Kiparsky."], "venue": "Proceedings of COLING 2012: Posters, pages 943\u2013950.", "citeRegEx": "Penn and Kiparsky.,? 2012", "shortCiteRegEx": "Penn and Kiparsky.", "year": 2012}, {"title": "Extra linguistic information needed for automatic generation of sanskrit compounds: A study", "author": ["Pawankumar Satuluri", "Amba Kulkarni."], "venue": "The recent developments in Sanskrit Computational Linguistics\u2019, at SALA-30, Hyderabad.", "citeRegEx": "Satuluri and Kulkarni.,? 2014", "shortCiteRegEx": "Satuluri and Kulkarni.", "year": 2014}, {"title": "Voice, preverb, and transitivity restrictions in sanskrit verb use", "author": ["Peter Scharf", "Pawan Goyal", "Anuja Ajotika", "Tanuja Ajotikar."], "venue": "Sanskrit Syntax, Selected papers presented at the seminar on sanskrit syntax and discouse structures, pages 157\u2013202.", "citeRegEx": "Scharf et al\\.,? 2015", "shortCiteRegEx": "Scharf et al\\.", "year": 2015}, {"title": "Modeling p\u0101\u1e47inian grammar", "author": ["Peter Scharf."], "venue": "Sanskrit Computational Linguistics, First and Second International Symposia, Rocquencourt, France, pages 95\u2013126. Springer.", "citeRegEx": "Scharf.,? 2009", "shortCiteRegEx": "Scharf.", "year": 2009}, {"title": "Rule selection in the a\u1e63\u1e6d\u0101dhy\u0101y\u012b, or is p\u0101\u1e47ini\u2019s grammar mechanistic? In Studies in Sanskrit Grammars", "author": ["Peter M Scharf"], "venue": "Proceedings of the Vyakarana Section of the 14th World Sanskrit Conference", "citeRegEx": "Scharf.,? \\Q2010\\E", "shortCiteRegEx": "Scharf.", "year": 2010}, {"title": "The A\u1e63\u1e6d\u0101dhy\u0101yi of P\u0101\u1e47ini - Vol.1 : Introduction to the A\u1e63\u1e6d\u0101dhy\u0101yi as a Grammatical Device", "author": ["Rama Nath Sharma"], "venue": "Munshiram Manoharlal Publishers Pvt. Ltd.,", "citeRegEx": "Sharma.,? \\Q2002\\E", "shortCiteRegEx": "Sharma.", "year": 2002}, {"title": "Context-sensitive rules in p\u0101\u1e47ini", "author": ["J. Frits Staal."], "venue": "Foundations of Language 1, pages 63\u201372.", "citeRegEx": "Staal.,? 1965", "shortCiteRegEx": "Staal.", "year": 1965}, {"title": "Computational structure of the a\u1e63\u1e6d\u0101dhy\u0101y\u012b and conflict resolution techniques", "author": ["Sridhar Subbanna", "Shrinivasa Varakhedi."], "venue": "Sanskrit Computational Linguistics, Third International Symposium, Hyderabad, India, pages 56\u201365. Springer.", "citeRegEx": "Subbanna and Varakhedi.,? 2009", "shortCiteRegEx": "Subbanna and Varakhedi.", "year": 2009}, {"title": "Asiddhatva principle in computational model of a\u1e63\u1e6d\u0101dhy\u0101y\u012b", "author": ["Sridhar Subbanna", "Shrinivasa Varakhedi."], "venue": "Sanskrit Computational Linguistics, Fourth International Symposium, Delhi, India, pages 231\u2013238. Springer.", "citeRegEx": "Subbanna and Varakhedi.,? 2010", "shortCiteRegEx": "Subbanna and Varakhedi.", "year": 2010}, {"title": "On using the observer design pattern", "author": ["Constantin Szallies."], "venue": "XP-002323533,(Aug. 21, 1997), 9.", "citeRegEx": "Szallies.,? 1997", "shortCiteRegEx": "Szallies.", "year": 1997}], "referenceMentions": [{"referenceID": 0, "context": "5 \u0924\ue27b\u0948 \u093f\u0939\u0924\u092e \u094dwhich means \u201cbeneficial to that\u201d (Bhate, 1989), where \u201cthat\u201d(\u0924\ue27b)\u0948 is intended for the base nominal from which the derivation will take place.", "startOffset": 45, "endOffset": 58}, {"referenceID": 6, "context": "A\u1e63\u1e6d\u0101dhy\u0101y\u012b considers both nouns and adjectives as a single category called as Pr\u0101tipadika (\ue38e\u093e\u093f\u0924\u092a\u093f\u0926\u0915), and hence the affixes used in Taddhita are not category changing affixes (Deo, 2007).", "startOffset": 175, "endOffset": 186}, {"referenceID": 6, "context": "multilevel inheritance formed between individual rule classes, which has been inspired from the inheritance network that P\u0101\u1e47ini used in A\u1e63\u1e6d\u0101dhy\u0101y\u012b (Deo, 2007).", "startOffset": 147, "endOffset": 158}, {"referenceID": 2, "context": "Seminal works from Cardona (1965) and Staal (1965) on formalizing rules of the grammar with stress on the meta-rules that state about the context sensitive aspects was a starting point with further enhancements from Cardona (1969) where he applies his formalization for more rules that is related to phonetic changes.", "startOffset": 19, "endOffset": 34}, {"referenceID": 2, "context": "Seminal works from Cardona (1965) and Staal (1965) on formalizing rules of the grammar with stress on the meta-rules that state about the context sensitive aspects was a starting point with further enhancements from Cardona (1969) where he applies his formalization for more rules that is related to phonetic changes.", "startOffset": 19, "endOffset": 51}, {"referenceID": 2, "context": "Seminal works from Cardona (1965) and Staal (1965) on formalizing rules of the grammar with stress on the meta-rules that state about the context sensitive aspects was a starting point with further enhancements from Cardona (1969) where he applies his formalization for more rules that is related to phonetic changes.", "startOffset": 19, "endOffset": 231}, {"referenceID": 19, "context": "Penn and Kiparsky (2012) focus on the expressive power of A\u1e63\u1e6d\u0101dhy\u0101yi rules and also the expressive power of formalism that P\u0101\u1e47ini", "startOffset": 0, "endOffset": 25}, {"referenceID": 11, "context": "Hyman (2009) developed a finite state transducer after re-framing individual rules in A\u1e63\u1e6d\u0101dhy\u0101yi, resulting in generation of strings that belong to regular languages and performs sandhi (\u0938\u093f\ue18f) at word boundaries for any two given word combinations.", "startOffset": 0, "endOffset": 13}, {"referenceID": 11, "context": "Hyman (2009) developed a finite state transducer after re-framing individual rules in A\u1e63\u1e6d\u0101dhy\u0101yi, resulting in generation of strings that belong to regular languages and performs sandhi (\u0938\u093f\ue18f) at word boundaries for any two given word combinations. Hyman had introduced an XML vocabulary for encoding rules in A\u1e63\u1e6d\u0101dhy\u0101yi that helped him in implementing the finite state transducer. Scharf (2009) discusses about Scharf\u2019s and Hyman\u2019s combined efforts in developing XML formalization that not only deals with sandhi but also with nominal declensions and verb conjugations.", "startOffset": 0, "endOffset": 395}, {"referenceID": 9, "context": "Goyal et al. (2009) implemented an inflectional morphology generator that takes as input a noun from the user and then generates all 21 forms of noun declensions, known as vibhakti system in Sanskrit grammar.", "startOffset": 0, "endOffset": 20}, {"referenceID": 9, "context": "Goyal et al. (2009) implemented an inflectional morphology generator that takes as input a noun from the user and then generates all 21 forms of noun declensions, known as vibhakti system in Sanskrit grammar. The authors talk about the programming perspectives that need to be considered when encoding rules in A\u1e63\u1e6d\u0101dhy\u0101yi, and various computational aspects that A\u1e63\u1e6d\u0101dhy\u0101yi possesses. They also talk about the need of conflict resolution methods for competing rules that can be applied in the same context. Jha et al. (2009) have developed a system that is an inflectional morphology analyser.", "startOffset": 0, "endOffset": 524}, {"referenceID": 9, "context": "Goyal et al. (2009) implemented an inflectional morphology generator that takes as input a noun from the user and then generates all 21 forms of noun declensions, known as vibhakti system in Sanskrit grammar. The authors talk about the programming perspectives that need to be considered when encoding rules in A\u1e63\u1e6d\u0101dhy\u0101yi, and various computational aspects that A\u1e63\u1e6d\u0101dhy\u0101yi possesses. They also talk about the need of conflict resolution methods for competing rules that can be applied in the same context. Jha et al. (2009) have developed a system that is an inflectional morphology analyser. They have developed independent systems for verb and noun forms and their corresponding inflections. Though their work was not related to simulating A\u1e63\u1e6d\u0101dhy\u0101yi, but they claim that they take into account the P\u0101\u1e47inian way of analysis. Satuluri and Kulkarni (2014) takes on generation of Sanskrit compounds called as sam\u0101sa that deals with about 400 rules of A\u1e63\u1e6d\u0101dhy\u0101yi which helps them to form compound words from independent words in Sanskrit.", "startOffset": 0, "endOffset": 856}, {"referenceID": 14, "context": "There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied.", "startOffset": 69, "endOffset": 98}, {"referenceID": 14, "context": "There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied. Subbanna and Varakhedi (2009) mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked.", "startOffset": 69, "endOffset": 196}, {"referenceID": 14, "context": "There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied. Subbanna and Varakhedi (2009) mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked. They also talk about various conflict resolution methods that are mentioned in the s\u016btras as well as in other v\u0101rttikas. Subbanna and Varakhedi (2010) presented a computational model based on the principle of asiddhatva, an improvised model over the one discussed in Subbanna and Varakhedi (2009).", "startOffset": 69, "endOffset": 553}, {"referenceID": 14, "context": "There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied. Subbanna and Varakhedi (2009) mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked. They also talk about various conflict resolution methods that are mentioned in the s\u016btras as well as in other v\u0101rttikas. Subbanna and Varakhedi (2010) presented a computational model based on the principle of asiddhatva, an improvised model over the one discussed in Subbanna and Varakhedi (2009). Mishra (2009) talks of the nature of grammar which performs the analysis of constituent elements and then its reconstitution using various set of operational rules as mentioned in A\u1e63\u1e6d\u0101dhy\u0101yi.", "startOffset": 69, "endOffset": 699}, {"referenceID": 14, "context": "There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied. Subbanna and Varakhedi (2009) mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked. They also talk about various conflict resolution methods that are mentioned in the s\u016btras as well as in other v\u0101rttikas. Subbanna and Varakhedi (2010) presented a computational model based on the principle of asiddhatva, an improvised model over the one discussed in Subbanna and Varakhedi (2009). Mishra (2009) talks of the nature of grammar which performs the analysis of constituent elements and then its reconstitution using various set of operational rules as mentioned in A\u1e63\u1e6d\u0101dhy\u0101yi.", "startOffset": 69, "endOffset": 714}, {"referenceID": 14, "context": "There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied. Subbanna and Varakhedi (2009) mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked. They also talk about various conflict resolution methods that are mentioned in the s\u016btras as well as in other v\u0101rttikas. Subbanna and Varakhedi (2010) presented a computational model based on the principle of asiddhatva, an improvised model over the one discussed in Subbanna and Varakhedi (2009). Mishra (2009) talks of the nature of grammar which performs the analysis of constituent elements and then its reconstitution using various set of operational rules as mentioned in A\u1e63\u1e6d\u0101dhy\u0101yi. Mishra (2010) in his work discusses about ved\u0101\u1e45ga principles and extends his work by considering the common methodological approach of ancillary disciplines for rule application.", "startOffset": 69, "endOffset": 906}, {"referenceID": 14, "context": "There has been an in-depth study on siddha and asiddha principles by johshi and Roodbergen (1987), where they talk about the order in which rules need to be applied. Subbanna and Varakhedi (2009) mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked. They also talk about various conflict resolution methods that are mentioned in the s\u016btras as well as in other v\u0101rttikas. Subbanna and Varakhedi (2010) presented a computational model based on the principle of asiddhatva, an improvised model over the one discussed in Subbanna and Varakhedi (2009). Mishra (2009) talks of the nature of grammar which performs the analysis of constituent elements and then its reconstitution using various set of operational rules as mentioned in A\u1e63\u1e6d\u0101dhy\u0101yi. Mishra (2010) in his work discusses about ved\u0101\u1e45ga principles and extends his work by considering the common methodological approach of ancillary disciplines for rule application. His work provides a good walk-through for the entire derivation process that begins with introduction of atomic elements to coming up with the desired final form. Kulkarni (2009) establishes the issue with phonological over-generation that can occur, if one is to strictly adhere to the rules defined by P\u0101\u1e47ini.", "startOffset": 69, "endOffset": 1250}, {"referenceID": 13, "context": "Jha and Mishra (2009) sheds some light in formalizing semantic categorization rules when he deals with k\u0101raka systems.", "startOffset": 0, "endOffset": 22}, {"referenceID": 2, "context": "Cardona (1997) discusses about various principles like utsarga-ap\u0101vada, antara\u1e45ga-bahira\u1e45ga, nitya-anitya etc.", "startOffset": 0, "endOffset": 15}, {"referenceID": 8, "context": "When it comes to automating Taddhitas, the Sanskrit Heritage System is an existing system that can recognize taddhitas and perform the analysis, but it does not generate the Taddhitas and only the lexicalized Taddhitas are recognized during the analysis (Goyal and Huet, 2013).", "startOffset": 254, "endOffset": 276}, {"referenceID": 28, "context": "Instead the mechanism allows the rules to be updated about environment state changes whenever there is one and yet the rule classes can refrain from state dependency issues with the environment (Szallies, 1997).", "startOffset": 194, "endOffset": 210}, {"referenceID": 8, "context": "When it comes to automating Taddhitas, the Sanskrit Heritage System is an existing system that can recognize taddhitas and perform the analysis, but it does not generate the Taddhitas and only the lexicalized Taddhitas are recognized during the analysis (Goyal and Huet, 2013). To the best of the authors\u2019 knowledge, the system which we are going to propose is the first of its kind, that is focused specifically on generation of derivative nouns (Taddhitas). The proposed system embraces a unique approach of forming rule groups where similar rules are grouped together to form a Directed Acyclic Graph (DAG). The similarity of rules is based on the notion of topicality present among the rules by virtue of usage of anuv\u1e5btti. The approach can be treated as analogous to the model, what is proposed in Subbanna and Varakhedi (2009), but they propose the formation of similar topic DAG through utsarga-ap\u0101vada relations.", "startOffset": 255, "endOffset": 833}, {"referenceID": 8, "context": "When it comes to automating Taddhitas, the Sanskrit Heritage System is an existing system that can recognize taddhitas and perform the analysis, but it does not generate the Taddhitas and only the lexicalized Taddhitas are recognized during the analysis (Goyal and Huet, 2013). To the best of the authors\u2019 knowledge, the system which we are going to propose is the first of its kind, that is focused specifically on generation of derivative nouns (Taddhitas). The proposed system embraces a unique approach of forming rule groups where similar rules are grouped together to form a Directed Acyclic Graph (DAG). The similarity of rules is based on the notion of topicality present among the rules by virtue of usage of anuv\u1e5btti. The approach can be treated as analogous to the model, what is proposed in Subbanna and Varakhedi (2009), but they propose the formation of similar topic DAG through utsarga-ap\u0101vada relations. One cannot comment on the similarity of the approaches without a proper comparison of DAGs formed from both of them. Moreover Subbanna and Varakhedi (2009) mentioned that they had not checked the feasibility of automating their notion of rule group formation.", "startOffset": 255, "endOffset": 1077}, {"referenceID": 24, "context": "There are two types of derivations possible that involve Taddhita affixes (Sharma, 2002).", "startOffset": 74, "endOffset": 88}, {"referenceID": 6, "context": "For example, for the patronymic relation \u0905\u092a\ue11a\u092e \u094d , multiple affixes can be used, like \u0905(\u0923)\u094d, \u0905\u092f\u0928(\u092b\u0915)\u094d, \u0907(\u091e)\u094d depending on the stems used (Deo, 2007).", "startOffset": 136, "endOffset": 147}, {"referenceID": 6, "context": "Deo (2007) calls this form of arrangement as constrained separationism, where the rules form", "startOffset": 0, "endOffset": 11}, {"referenceID": 0, "context": "This group of rules is treated as extraneous to otherwise systematic network of the section (Bhate, 1989).", "startOffset": 92, "endOffset": 105}, {"referenceID": 7, "context": "Observer design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically (Gamma et al., 1994).", "startOffset": 170, "endOffset": 190}, {"referenceID": 26, "context": "In case of asiddhavat rules as discussed in Subbanna and Varakhedi (2009), the environment makes a complete copy of itself; one object is used for checking the conditions while in the other object, all the operations are applied.", "startOffset": 44, "endOffset": 74}, {"referenceID": 22, "context": "To resolve such a scenario, we have applied the specificity hierarchy as mentioned in Scharf (2010). Specificity hierarchy deals with a priority wise ordering of rules based on the linguistic features present in the rule (or a combination of the same, if multiple entities are present) from the most concrete to the most abstract features.", "startOffset": 86, "endOffset": 100}, {"referenceID": 22, "context": "Scharf (2010) discusses five cases in which conflict of application occurs between two competing rules.", "startOffset": 0, "endOffset": 14}, {"referenceID": 22, "context": "Other conflict cases discussed in Scharf (2010) are not discussed here as those fall into one of the scenarios already discussed.", "startOffset": 34, "endOffset": 48}, {"referenceID": 24, "context": "133 implies that the affix \u0922\u0915 \u094d should be introduced (Sharma, 2002).", "startOffset": 53, "endOffset": 67}, {"referenceID": 1, "context": "This kind of information can be used to supplement available lexical resources like IndoWordNet for sanskrit (Bhattacharyya, 2010) and also to provide supplementary information in dictionary entries for lexical databases as described in Huet (2004).", "startOffset": 109, "endOffset": 130}, {"referenceID": 1, "context": "This kind of information can be used to supplement available lexical resources like IndoWordNet for sanskrit (Bhattacharyya, 2010) and also to provide supplementary information in dictionary entries for lexical databases as described in Huet (2004).", "startOffset": 110, "endOffset": 249}, {"referenceID": 12, "context": "The conversion of Objects to XML schema is a well addressed task in IT World (Jain and Thakur, 2002).", "startOffset": 77, "endOffset": 100}, {"referenceID": 22, "context": "Our system forms rule groups as Directed Acyclic Graphs (DAG), analogous to as Subbanna and Varakhedi (2009) suggests.", "startOffset": 79, "endOffset": 109}, {"referenceID": 22, "context": "Our system forms rule groups as Directed Acyclic Graphs (DAG), analogous to as Subbanna and Varakhedi (2009) suggests. But our notion of topical rule groups arises from the notion of topicality by virtue of anuv\u1e5btti, while Subbanna and Varakhedi (2009) attempts to form the topical rule groups from general-exception rule concepts.", "startOffset": 79, "endOffset": 253}, {"referenceID": 22, "context": "Our system forms rule groups as Directed Acyclic Graphs (DAG), analogous to as Subbanna and Varakhedi (2009) suggests. But our notion of topical rule groups arises from the notion of topicality by virtue of anuv\u1e5btti, while Subbanna and Varakhedi (2009) attempts to form the topical rule groups from general-exception rule concepts. The approaches in group formation need to be studied further, in order to comment on the commonality of the DAGs so formed, but Subbanna and Varakhedi (2009) do not talk about the attempts to model their concept in implementation.", "startOffset": 79, "endOffset": 490}, {"referenceID": 20, "context": "This makes the set up of environment comparable to the set up as in Scharf et al. (2015) which is primarily an XML representation.", "startOffset": 68, "endOffset": 89}, {"referenceID": 12, "context": "The conversion of Objects to XML schema is a well addressed task in IT World (Jain and Thakur, 2002). Hence one can also think of developing a schema to transfer the data entities used in one system to the other, as Scharf et al. (2015) tries to model the entire A\u1e63\u1e6d\u0101dhy\u0101y\u012b.", "startOffset": 78, "endOffset": 237}], "year": 2015, "abstractText": "About 1115 rules in A\u1e63\u1e6d\u0101dhy\u0101y\u012b from A.4.1.76 to A.5.4.160 deal with generation of derivative nouns, making it one of the largest topical sections in A\u1e63\u1e6d\u0101dhy\u0101y\u012b, called as the Taddhita section owing to the head rule A.4.1.76. This section is a systematic arrangement of rules that enumerates various affixes that are used in the derivation under specific semantic relations. We propose a system that automates the process of generation of derivative nouns as per the rules in A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The proposed system follows a completely object oriented approach, that models each rule as a class of its own and then groups them as rule groups. The rule groups are decided on the basis of selective grouping of rules by virtue of anuv\u1e5btti. The grouping of rules results in an inheritance network of rules which is a directed acyclic graph. Every rule group has a head rule and the head rule notifies all the direct member rules of the group about the environment which contains all the details about data entities, participating in the derivation process. The system implements this mechanism using multilevel inheritance and observer design patterns. The system focuses not only on generation of the desired final form, but also on the correctness of sequence of rules applied to make sure that the derivation has taken place in strict adherence to A\u1e63\u1e6d\u0101dhy\u0101y\u012b. The proposed system\u2019s design allows to incorporate various conflict resolution methods mentioned in authentic texts and hence the effectiveness of those rules can be validated with the results from the system. We also present cases where we have checked the applicability of the system with the rules which are not specifically applicable to derivation of derivative nouns, in order to see the effectiveness of the proposed schema as a generic system for modeling A\u1e63\u1e6d\u0101dhy\u0101y\u012b.", "creator": " XeTeX output 2015.12.17:2032"}}}