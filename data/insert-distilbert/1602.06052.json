{"id": "1602.06052", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "19-Feb-2016", "title": "Strong Backdoors for Default Logic", "abstract": "in this paper, consider we introduce a notion of backdoors to reiter's propositional default logic and study two structural properties of it. since also we consider the problems of backdoor detection ( parameterised by the solution size ) as well as backdoor evaluation ( parameterised further by determine the size of the given backdoor ), for various kinds of complex target classes ( cnf, horn, krom, monotone, sql identity ). we simultaneously show that backdoor detection is fixed - parameter tractable for the carefully considered target classes, procedure and backdoor evaluation is not either likewise fixed - parameter tractable, in para - dp2, or then in para - np, depending on the target class.", "histories": [["v1", "Fri, 19 Feb 2016 06:42:48 GMT  (61kb)", "http://arxiv.org/abs/1602.06052v1", null]], "reviews": [], "SUBJECTS": "cs.LO cs.AI cs.CC", "authors": ["johannes k fichte", "arne meier", "irina schindler"], "accepted": false, "id": "1602.06052"}, "pdf": {"name": "1602.06052.pdf", "metadata": {"source": "CRF", "title": "Strong Backdoors for Default Logic", "authors": ["Johannes K. Fichte", "Arne Meier", "Irina Schindler"], "emails": ["jfichte@dbai.tuwien.ac.at", "meier.schindler@thi.uni-hannover.de"], "sections": [{"heading": null, "text": "ar X\niv :1\n60 2.\n06 05\n2v 1\n[ cs\n.L O\n] 1\n9 Fe\nb 20"}, {"heading": "1 Introduction", "text": "In the area of non-monotonic logic one aims to find formalisms that model human-sense reasoning. It turned out that this kind of reasoning is quite different from classical deductive reasoning as in the classical approach the addition of information always leads to an increase of derivable knowledge. Yet, intuitively, human-sense reasoning does not work in that way: the addition of further facts might violate previous assumptions and can therefore significantly decrease the amount of derivable conclusions. Hence, in contrast to the classical process the behaviour of human-sense reasoning is non-monotonic. In the 1980s, several kinds of formalisms have been introduced, most notably, circumscription [27], default logic [34], autoepistemic logic [30], and non-monotonic logic [28]. A good introduction into this field is given by Marek and Truszczyns\u0301ki [26].\nIn this paper, we focus on Reiter\u2019s Default Logic (DL), which has been introduced in 1980 [34] and is one of the most fundamental formalism for modelling human-sense reasoning. DL extends the usual logical derivations by rules of default assumptions (default rules). Informally, default rules follow the format \u201cin the absence of contrary information, assume . . .\u201d. Technically, these patterns are taken up in triples of formulas \u03b1:\u03b2\n\u03b3 , which express \u201cif prerequisite \u03b1 can be deduced and justification \u03b2 is never\nviolated then assume conclusion \u03b3\u201d. Default rules can be used to enrich calculi in different kinds of logics. Here, we consider a variant of propositional formulas, namely, formulas in conjunctive normal form (cnf). A key concept of DL is that an application of default rules must not lead to an inconsistency if conflicting rules are present, instead such rules should be avoided if possible. This concept results in the notion of stable extensions, which can be seen as a maximally consistent view of an agent with respect to his knowledge base together in combination with its set of default rules. The corresponding decision problem, i.e., the extension existence problem, then asks whether a given default theory has a consistent stable extension, and is the problem of our interest. The computationally hard part of this problem lies in the detection of the order and \u201capplicability\u201d of default rules, which is a quite challenging task as witnessed by its \u03a3p2-completeness. In 1992, Gottlob showed that many important decision problems, beyond the extension existence problem, of non-monotonic logics are complete for the second level of the polynomial hierarchy [22] and thus are of high intractability.\nA prominent approach to understand the intractability of a problem is to use the framework of parameterised complexity, which was introduced by Downey and Fellows [12, 11]. The main idea of parameterised complexity is to fix a certain structural property (the parameter) of a problem instance and to consider the computational complexity of the problem in dependency of the parameter. Then ideally, the complexity drops and the problem becomes solvable in polynomial time when the parameter is fixed. Such problems are called fixed-parameter tractable and the corresponding parameterised complexity class, which contains all fixed-parameter tractable problems, is called FPT. For instance, for the propositional satisfiability problem (Sat) one (na\u0308\u0131ve) parameter is the number of variables of the given formula. Then, for a given formula \u03d5 of size n and k variables its satisfiability can be decided in time O(n \u00b7 2k), i.e., polynomial (even linear) runtime in n if k is considered to be fixed.\nThe invention of new parameters can be quite challenging, however, Sat has so far been considered under many different parameters [41, 36, 5, 31]. A concept that provides a parameter and has been widely used in theoretical investigations of propositional satisfiability are backdoors [42, 21, 25]. The size of a backdoor can be seen as a parameter with which one tries to exploit a small distance of a formula from being tractable. More detailed, given a class F of formulas and a formula \u03d5, a subset B of its variables is a strong F-backdoor if the formula \u03d5 under every truth assignment over B yields a formula that belongs to the class F . Using backdoors usually consists of two phases: (i) finding a backdoor (backdoor detection) and (ii) using the backdoor to solve the problem (backdoor evaluation). If F is a class where Sat is tractable and backdoor detection is fixed-parameter tractable for this class, like the class of all Horn or Krom formulas, we can immediately conclude that Sat is fixed-parameter tractable when parameterised by the size of a smallest strong F -backdoor.\nRelated Work. Backdoors for propositional satisfiability have been introduced by Williams, Gomes, and Selman [42, 43]. The concept of backdoors has recently been lifted to some non-monotonic formalisms as abduction [33], answer set programming [18, 17], and argumentation [13]. Beyond the classification of Gottlob [22], the complexity of fragments, in the sense of Post\u2019s lattice, has been considered by Beyersdorff et al. extensively for default logic [2], and for autoepistemic logic by Creignou et al. [9]. Also parameterised analyses of non-monotonic logics in the spirit of Courcelle\u2019s theorem [7, 8] have recently been considered by Meier et al. [29]. Further, Gottlob et al. studied treewidth as a parameter for various non-monotonic logics [23] and also considered a more CSP focused non-monotonic context within the parameterised complexity setting [24].\nContribution. In this paper, we introduce a notion of backdoors to propositional default logic and study structural properties therein. Then we investigate the parameterised complexity of the problems of backdoor detection (parameterised by the solution size) and evaluation (parameterised by the size of the given backdoor), with respect to the most important classes of CNF formulas, e.g., cnf, krom, horn, monotone, and positive-unit. Informally, given a formula \u03d5 and an integer k, the detection problem asks whether there exists a backdoor of size k for \u03d5. Backdoor evaluation then exploits the distance k for a target formula class to solve the problem for the starting formula class with a \u201csimpler\u201d complexity. Our classification shows that detection is fixed-parameter tractable for all considered target classes. However, for backdoor evaluation starting at cnf the parameterised complexity depends, as expected, on the target class: the parameterised complexity then varies between para-\u2206p2 (monotone), para-NP (krom,horn), and FPT (positive-unit)."}, {"heading": "2 Preliminaries", "text": "We assume familiarity with standard notions in computational complexity, the complexity classes P and NP as well as the polynomial hierarchy. For more detailed information, we refer to other standard sources [32, 20, 12].\nParameterised Complexity. We follow the notion by Flum and Grohe [19]. A parameterised (decision) problem L is a subset of \u03a3\u2217 \u00d7N for some finite alphabet \u03a3. Let C be a classical complexity class,\nthen para-C consists of all parameterised problems L \u2286 \u03a3\u2217 \u00d7 N, for which there exists an alphabet \u03a3\u2032, a computable function f : N \u2192 \u03a3\u2032\u2217, and a (classical) problem L\u2032 \u2286 \u03a3\u2217 \u00d7 \u03a3\u2032\u2217 such that (i) L\u2032 \u2208 C, and (ii) for all instances (x, k) \u2208 \u03a3\u2217 \u00d7 N of L we have (x, k) \u2208 L if and only if (x, f(k)) \u2208 L\u2032. For the complexity class P, we write FPT instead of para-P. We call a problem in FPT fixed-parameter tractable and the runtime f(k) \u00b7 |x|O(1) also fpt-time. Additionally, the parameterised counterparts of NP and \u2206p2 = P NP, which are denoted by para-NP and para-\u2206p2 , are relevant in this paper.\nPropositional Logic. Next, we provide some notions from propositional logic. We consider a finite set of propositional variables and use the symbols \u22a4 and \u22a5 in the standard way. A literal is a variable x (positive literal) or its negation \u00acx (negative literal). A clause is a finite set of literals, interpreted as the disjunction of these literals. A propositional formula in conjunctive normal form (CNF) is a finite set of clauses, interpreted as the conjunction of its clauses. We denote the class of all CNF formulas by cnf. A clause is Horn if it contains at most one positive literal, Krom if it contains two literals, monotone if it contains only positive literals, and positive-unit if it contains at most one positive literal. We say that a CNF formula has a certain property if all its clause have the property. We consider several classes of formulas in this paper. Table 1 gives an overview on these classes and defines clause forms for these classes.\nA formula \u03d5\u2032 is a subformula of a cnf formula \u03d5 (in symbols \u03d5\u2032 \u2286 \u03d5) if for each clause C\u2032 \u2208 \u03d5\u2032 there is some clause C \u2208 \u03d5 such that C\u2032 \u2286 C. We call a class F of cnf formulas clause-induced if whenever F \u2208 F , all subformulas F \u2032 \u2286 F belong to F . Note that all considered target classes in this paper are clause-induced.\nGiven a formula \u03d5 \u2208 cnf, and a subsetX \u2286 Vars(\u03d5), then a (truth) assignment is a mapping \u03b8 : X \u2192 {0, 1}. The truth (evaluation) of propositional formulas is defined in the standard way, in particular, \u03b8(\u22a5) = 0 and \u03b8(\u22a4) = 1. We extend \u03b8 to literals by setting \u03b8(\u00acx) = 1 \u2212 \u03b8(x) for x \u2208 X . By A(X) we denote the set of all assignments \u03b8 : X \u2192 {0, 1}. For simplicity of presentation, we sometimes identify the set of all assignments by its corresponding literals, i.e., A(X) = { {\u21131, . . . , \u2113|X|} | x \u2208 X, \u2113i \u2208 {x,\u00acx} }. We write \u03d5[\u03b8] for the reduct of \u03d5 where every literal \u2113 \u2208 X is replaced by \u22a4 if \u03b8(\u2113) = 1, then all clauses that contain a literal \u2113 with \u03b8(\u2113) = 1 are removed and from the remaining clauses all literals \u2113\u2032 with \u03b8(\u2113\u2032) = 0 are removed. We say \u03b8 satisfies \u03d5 if \u03d5[\u03b8] \u2261 \u22a4, \u03d5 is satisfiable if there exists an assignment that satisfies \u03d5, and \u03d5 is tautological if all assignments \u03b8 \u2208 A(X) satisfy \u03d5. Let \u03d5, \u03c8 \u2208 cnf and X = Vars(\u03d5) \u222a Vars(\u03c8). We write \u03d5 |= \u03c8 if and only if for all assignments \u03b8 \u2208 A(X) it holds that all assignments \u03b8 that satisfy \u03d5 also satisfy \u03c8. Further, we define Th(\u03d5) := {\u03c8 \u2208 cnf | \u03d5 |= \u03c8 }.\nNote that any assignment \u03b8 : Vars(\u03d5) \u2192 {0, 1} can be also represented by the CNF formula \u2227\n\u03b8(x)=1 x \u2227 \u2227 \u03b8(x)=0 \u00acx. Therefore, we often write \u03b8 |= \u03d5 if \u03d5[\u03b8] \u2261 \u22a4 holds.\nWe denote with Sat(F) the problem, given a propositional formula \u03d5 \u2208 F asking whether \u03d5 is satisfiable. The problem Taut(F) is defined over a given formula \u03d5 \u2208 F asking whether \u03d5 tautological."}, {"heading": "2.1 Default Logic", "text": "We follow notions by Reiter [34] and define a default rule \u03b4 as a triple \u03b1:\u03b2 \u03b3 ; \u03b1 is called the prerequisite, \u03b2 is called the justification, and \u03b3 is called the conclusion; we set prereq(\u03b4) := \u03b1, just(\u03b4) := \u03b2, and concl(\u03b4) := \u03b3. If F is a class of formulas, then \u03b1:\u03b2\n\u03b3 is an F -default rule if \u03b1, \u03b2, \u03b3 \u2208 F . An F -default\ntheory \u3008W,D\u3009 consists of a set of propositional formulas W \u2208 F and a set D of F -default rules. We sometimes call W the knowledge base of \u3008W,D\u3009. Whenever we do not explicitly state the class F , we assume it to be cnf.\nDefinition 1 (Fixed point semantics, [34]). Let \u3008W,D\u3009 be a default theory and E be a set of formulas. Then \u0393(E) is the smallest set of formulas such that:\n1. W \u2286 \u0393(E),\n2. \u0393(E) = Th(\u0393(E)), and\n3. for each \u03b1:\u03b2 \u03b3 \u2208 D with \u03b1 \u2208 \u0393(E) and \u00ac\u03b2 /\u2208 E, it holds that \u03b3 \u2208 \u0393(E).\nE is a stable extension of \u3008W,D\u3009, if E = \u0393(E). An extension is inconsistent if it contains \u22a5, otherwise it is called consistent.\nA definition for stable extensions beyond fixed point semantics, which has been introduced by Reiter [34] as well, uses the principle of a stage construction.\nProposition 1 (Stage construction, [34]). Let \u3008W,D\u3009 be a default theory and E be a set of formulas. Then define E0 := W and\nEi+1 := Th(Ei) \u222a\n{\n\u03b3\n\u2223 \u2223 \u2223 \u2223 \u2223 \u03b1 : \u03b2 \u03b3 \u2208 D,\u03b1 \u2208 Ei and \u00ac\u03b2 /\u2208 E } .\nE is a stable extension of \u3008W,D\u3009 if and only if E = \u22c3\ni\u2208N Ei. The set\nG =\n{\n\u03b1 : \u03b2\n\u03b3 \u2208 D\n\u2223 \u2223 \u2223 \u2223 \u2223 \u03b1 \u2208 E \u2227 \u00ac\u03b2 /\u2208 E }\nis called the set of generating defaults. If E is a stable extension of \u3008W,D\u3009, then E = Th(W\u222a{ concl(\u03b4) | \u03b4 \u2208 G }).\nExample 1. Let W = \u2205, W \u2032 = {x}, D1 = { x:y \u00acy , \u00acx:y \u00acy }, and D2 = { x:z \u00acy , x:y \u00acz }. The default theory \u3008W,D1\u3009 has only the stable extension Th(W ). The default theory \u3008{x}, D1\u3009 has no stable extension. The default theory \u3008{x}, D2\u3009 has the stable extensions Th({x,\u00acy}) and Th({x,\u00acz}).\nThe following example illustrates that a default theory might contain \u201ccontradicting\u201d default rules that cannot be avoided in the process of determining extension existence. Informally, such default rules prohibit stable extensions. Note that there are also less obvious situations where \u201cchains\u201d of such default rules interact with each other.\nExample 2. Consider W \u2032 and D2 from Example 1 and let D \u2032 2 = D2 \u222a { \u22a4:\u03b2 \u00ac\u03b2 } for some formula \u03b2. The default theory \u3008W \u2032, D\u20322\u3009 has no stable extension Th(W ) unless W \u222a {\u00acy} |= \u00ac\u03b2 or W \u222a {\u00acz} |= \u00ac\u03b2.\nTechnically, the definition of stable extensions allows inconsistent stable extensions. However, Marek and Truszczyn\u0301ski have shown that inconsistent extensions only occur if the set W is already inconsistent where \u3008W,D\u3009 is the theory of interest [26, Corollary 3.60]. An immediate consequence of this result explains the interplay between consistency and stability of extensions more subtle: (i) If W is consistent, then every stable extension of \u3008W,D\u3009 is consistent, and (ii) If W is inconsistent, then \u3008W,D\u3009 has a stable extension. In Case (2) the stable extension consists of all formulas L. Hence, it makes sense to consider\nonly consistent stable extensions as the relevant ones. Moreover, we refer by SE(\u3008W,D\u3009) to the set of all consistent stable extensions of \u3008W,D\u3009.\nA main computational problem for DL is the extension existence problem, defined as follows where F is a class of propositional formulas:\nProblem: Ext(F) Input: An F -default theory \u3008W,D\u3009.\nQuestion: Does \u3008W,D\u3009 have a consistent stable extension?\nThe following proposition summarises relevant results for the extension existence problem for certain classes of formulas.\nProposition 2.\n1. Ext(cnf) is \u03a3p2-complete [22].\n2. Ext(horn) is NP-complete [39, 40].\n3. Ext(positive-unit) \u2208 P [2]."}, {"heading": "2.2 The Implication Problem", "text": "The implication problem is an important (sub-)problem when reasoning with default theories. In the following, we first formally introduce the implication problem for classes of propositional formulas, and then state its (classical) computational complexity for the classes horn and krom.\nProblem: Imp(F)\nInput: A set \u03a6 of F -formulas and a formula \u03c8 \u2208 F . Question: Does \u03a6 |= \u03c8 hold?\nBeyersdorff et al. [2] have considered all Boolean fragments of Imp(F) and completely classified its computational complexity concerning the framework of Post\u2019s lattice. However, Post\u2019s lattice talks only about restrictions on allowed Boolean functions. Since several subclasses of cnf, like horn or krom, use the Boolean functions \u201c\u2227\u201d,\u201d\u00ac\u201d, and \u201c\u2228\u201d, such classes are unrestricted from the perspective of Post\u2019s lattice. Still, efficient algorithms are known for such classes from propositional satisfiability. The next results state a similar behaviour for the implication problem.\nLemma 1. Imp(krom) \u2208 P.\nProof. Given a set \u03a6 of krom-formulas and a formula \u03c8 \u2208 krom. Without loss of generality assume that \u2227\n\u03d5\u2208\u03a6 \u03d5 = \u2227m i=1 Ci, and \u03d5 = \u2227n i=1 C \u2032 i. Then it holds that\n\u3008\u03a6, \u03c8\u3009 \u2208 Imp(krom) \u21d4\n(\nm \u2227\ni=1\nCi,\nn \u2227\ni=1\nC\u2032i\n)\n\u2208 Imp(krom) (1)\n\u21d4\n(\nm \u2227\ni=1\nCi\n)\n\u2192\n(\nn \u2227\ni=1\nC\u2032i\n)\n\u2208 Taut (2)\n\u21d4 n \u2227\ni=1\n\n\nm \u2227\nj=1\nCj \u2192 C \u2032 i\n\n \u2208 Taut (3)\n\u21d4 \u2200 1 \u2264 i \u2264 n\n\n\nm \u2227\nj=1\nCj \u2192 C \u2032 i\n\n \u2208 Taut (4)\n\u21d4 \u00ac\u2203 1 \u2264 i \u2264 n\n\n\nm \u2227\nj=1\nCj \u2192 C \u2032 i\n\n 6\u2208 Taut (5)\n(1) definition of the implication problem. (2) expressing implication through the propositional function \u2192. (3) \u03b1 \u2192 \u03b2 \u2227 \u03b3 is a tautology if and only if (\u03b1 \u2192 \u03b2) \u2227 (\u03b1 \u2192 \u03b3) is a tautology. (4) separated to separate tautology questions. (5) \u03b1 \u2227 \u03b2 is a tautology if neither \u03b1 nor \u03b2 is not a tautology.\nNow, we can check the last n problems separately by\n(\nm \u2227\ni=1\nCi \u2192 (\u2113 \u2228 \u2113 \u2032)\n)\n6\u2208 Taut \u21d4\n(\nm \u2227\ni=1\nCi\n)\n[\u03b80] \u2208 Sat(krom),\nwhere \u03b80 is the assignment such that \u03b80(\u2113) := 0 and \u03b80(\u2113 \u2032) := 0. Observe that, if \u2113 \u2261\u223c\u2113\u2032 then the implication on the left part of the equivalence is always a tautology.\nSimilar to the proof of Lemma 1 one can show the same complexity for the implication problem of horn formulas. However, its complexity is already known from the work by Stillman [39].\nProposition 3 ([39, Lemma 2.3]). Imp(horn) \u2208 P."}, {"heading": "3 Strong Backdoors", "text": "In this section, we lift the concept of backdoors to the world of default logic. First, we review backdoors from the propositional setting [42, 43], where a backdoor is a subset of the variables of a given formula. Formally, for a class F of formulas and a formula \u03d5, a strong F-backdoor is a set B of variables such that for all assignments \u03b8 \u2208 A(B), it holds that \u03d5[\u03b8] \u2208 F .\nBackdoors in propositional satisfiability follow the binary character of truth assignments. Each variable of a given formula is considered to be either true or false. However, reasoning in default logic has a ternary character. When we consider consistent stable extensions of a given default theory then one of the following three cases holds for some formula \u03d5 with respect to an extension E: (i) \u03d5 is contained in E, (ii) the negation \u00ac\u03d5 is contained in E, or (iii) neither \u03d5 nor \u00ac\u03d5 is contained in E (e.g., for the theory \u3008{x}, D2\u3009, from Example 1, neither b nor \u00acb is contained in any of the two stable extensions, where b is a variable). Since we need to weave this trichotomous point of view into a backdoor definition for default logic, the original definition of backdoors cannot immediately be transferred (from the SAT setting) to the scene of default logic. The first step is a notion of extended literals and reducts. The latter step can be seen as a generalisation of assignment functions to our setting.\nDefinition 2 (Extended literals and reducts). An extended literal is a literal or a fresh variable x\u03b5. For convenience, we further define \u223c\u2113 = x if \u2113 = \u00acx and \u223c\u2113 = \u00acx if \u2113 = x. Given a formula \u03d5 and an extended literal \u2113, then the reduct \u03c1\u2113(\u03d5) is obtained from \u03d5 such that\n1. if \u2113 is a literal: then all clauses that contain \u2113 are deleted and all literals \u223c\u2113 are deleted from all clauses,\n2. if \u2113 is x\u03b5: then all occurrences of literals \u00acx, x are deleted from all clauses.\nLet \u3008W,D\u3009 be a default theory and \u2113 an extended literal, then\n\u03c1\u2113(W,D) :=\n(\n\u03c1\u2113(W ),\n{\n\u03c1\u2113(\u03b1) : \u03c1x(\u03b2)\n\u03c1\u2113(\u03b3) \u2227 yi\n\u2223 \u2223 \u2223 \u2223 \u03b4i = \u03b1 : \u03b2\n\u03b3 \u2208 D\n})\n,\nwhere yi is a fresh proposition, and \u03c1\u2113(W ) is \u22c3 \u03c9\u2208W \u03c1\u2113(\u03c9).\nLater (in the proof of Lemma 4), we will see why we need the yis. In the next step, we incorporate the notion of extended literals into sets of assignments. Therefore,\nwe introduce threefold assignment sets. Let X be a set of variables, then we define\nT(X) := {{a1, . . . , a|X|} | x \u2208 X and ai \u2208 {x,\u00acx, x\u03b5}}.\nTechnically, A(X) ( T(X) holds. However, T(X) additionally contains variables x\u03b5 that will behave as \u201cdon\u2019t care\u201d variables encompassing the trichotomous reasoning approach explained above. For Y \u2208 T(X) the reduct \u03c1Y (W,D) is the consecutive application of all \u03c1y(\u00b7) for y \u2208 Y to \u3008W,D\u3009. Observe that the order in which we apply the reducts to \u3008W,D\u3009 is not important.\nThe following proposition states that implication of formulas is invariant under adding conjuncts of fresh variables to the premise.\nProposition 4. Let \u03d5, \u03c8 \u2208 cnf be two formulas and y /\u2208 Vars(\u03d5) \u222a Vars(\u03c8). Then \u03d5 |= \u03c8 if and only if \u03d5 \u2227 y |= \u03c8.\nNow we show that implication for cnf formulas that do not contain tautological clauses is invariant under the application of \u201cdeletion reducts\u201d \u03c1x\u03b5(\u00b7).\nLemma 2. Let \u03c8, \u03d5 \u2208 cnf be two formulas that do not contain tautological clauses. If \u03c8 |= \u03d5, then \u03c1x\u03b5(\u03c8) |= \u03c1x\u03b5(\u03d5) for every variable x \u2208 Vars(\u03d5) \u222a Vars(\u03c8).\nProof. Assume for contradiction that \u03c1x\u03b5(\u03c8) 6|= \u03c1x\u03b5(\u03d5). Then there exists an assignment \u03b8 : Vars(\u03c1x\u03b5(\u03c8)) \u222a Vars(\u03c1x\u03b5(\u03d5)) \u2192 {0, 1} such that \u03b8 |= \u03c1x\u03b5(\u03c8) but \u03b8 6|= \u03c1x\u03b5(\u03d5). As \u03b8 |= \u03c1x\u03b5(\u03c8) every arbitrary extension of \u03b8 satisfies \u03c8, in particular also any extension on {x}\u222aVars(\u03c1x\u03b5(\u03c8))\u222aVars(\u03c1x\u03b5(\u03d5)). Denote such an extension by \u03b8x. Yet, by \u03c8 |= \u03d5 we get \u03b8x |= \u03d5. As this holds for any arbitrary such \u03b8x the satisfiability of \u03d5 is independent of setting x wherefore \u03b8x |= \u03c1x\u03b5(\u03d5) as well. (Note that here it is crucial that we require \u03d5 contain no tautological clauses.) As x /\u2208 Vars(\u03c1x\u03b5(\u03d5)) holds we get \u03b8 |= \u03c1x\u03b5(\u03d5) which is a contradiction. Thus \u03c1x\u03b5(\u03c8) |= \u03c1x\u03b5(\u03d5).\nThe next lemma shows that implication for cnf formulas is invariant under the application of reducts over A.\nLemma 3. Let \u03c8, \u03d5 be two cnf formulas, and X \u2286 Vars(\u03c8)\u222aVars(\u03d5). If \u03c8 |= \u03d5, then \u03c1Y (\u03c8) |= \u03c1Y (\u03d5) holds for every set Y \u2208 A(X).\nProof. Let \u03c8, \u03d5, and X be as in the formulation of the lemma and assume that \u03c8 |= \u03d5 holds. Now fix an arbitrary Y \u2208 A(X) and consider every assignment \u03c4Y : Vars(\u03c1Y (\u03c8)) \u222a Vars(\u03c1Y (\u03d5)) \u2192 {0, 1}. Note that \u03c4Y is defined on (Vars(\u03c8) \u222a Vars(\u03d5)) \\ Y . Define \u03c4 \u21be Y as the assignment \u03c4 extended by setting \u03c4(x) := 1 if x \u2208 Y , and \u03c4(x) := 0 if \u00acx \u2208 Y . Thus \u03c4 \u21be Y completely agrees with \u03c4 on the variables in Y .\nThen \u03c4 \u21be Y |= \u00ac\u03c8 \u2228 \u03d5 holds by assumption as \u03c8 |= \u03d5. Then by an easy induction we get \u03c4 \u21be Y |= \u03d5 if and only if \u03c4 |= \u03c1Y (\u03d5), and \u03c4 \u21be Y |= \u03c8 if and only if \u03c4 |= \u03c1Y (\u03c8). Thus we get\n\u03c4 |= \u03c1Y (\u03c8) \u21d0\u21d2 \u03c4 \u21be Y |= \u03c8 =\u21d2 \u03c4 \u21be Y |= \u03d5 \u21d0\u21d2 \u03c4 |= \u03c1Y (\u03d5)\nand the lemma follows.\nWe denote by BD-Imp(cnf \u2192 F) the parameterised version of the problem Imp(cnf) where additionally a strong F -backdoor is given and the parameter is the size of the strong F -backdoor.\nCorollary 1. Given a class F \u2208 {positive-unit,horn,krom} of CNF formulas. Then BD-Imp(cnf \u2192 F) \u2208 FPT.\nProof. Let W,\u03d5,X be the given input instance. Then the following FPT algorithm decides the problem BD-Imp(cnf \u2192 F). For every assignment Y \u2208 A(X) check if \u03c1Y (W ) |= \u03c1Y (\u03d5). For the corresponding classes F these implication problems are all decidable in polynomial time; for krom see Lemma 1, for horn see Proposition 3, and positive-unit is a special case of horn. The correctness follows from Lemma 3. Hence the corollary applies.\nA combination of Lemma 2 and Lemma 3 yields a generalisation for CNF formulas that do not contain tautological clauses. Note that the crucial difference is the use of T instead of A in the claim of the result.\nCorollary 2. Let \u03c8, \u03d5 be two cnf formulas that do not contain tautological clauses, and X \u2286 Vars(E)\u222a Vars(\u03d5) be a set of variables. If \u03c8 |= \u03d5 then for every set Y \u2208 T(X) it holds \u03c1Y (\u03c8) |= \u03c1Y (\u03d5).\nThe following lemma is an important cornerstone for the upcoming section. It intuitively states that we do not loose any stable extensions under the application of reducts. Before we can start with the lemma we need to introduce a bit of notion. For a set D = {\u03b41, . . . , \u03b4n} of default rules and a set E of formulas we define y-concl(D,E) := {concl(\u03b4i) | 1 \u2264 i \u2264 n, \u03b4i \u2208 D,E |= yi}, that is, the set of conclusions of default rules \u03b4i such that yi is implied by all formulas in E. Further, for a set X of variables, we will extend the notion for SE(\u00b7) as follows:\nSE(\u3008W,D\u3009 , X) := \u22c3\nY \u2208T(X)\n{Th(W \u222a y-concl(D,E)) | E \u2208 SE(\u03c1Y (W,D))}.\nLemma 4. Let \u3008W,D\u3009 be a cnf default theory with formulas that do not contain tautological clauses, and X be a set of variables from Vars(W,D). Then SE(\u3008W,D\u3009) \u2286 SE(\u3008W,D\u3009 , X).\nProof. Let \u3008W,D\u3009 be the given default theory, X \u2286 Vars(W,D), and E \u2208 SE(\u3008W,D\u3009) be a consistent stable extension of \u3008W,D\u3009.\nNow suppose for contradiction that E /\u2208 SE(\u3008W,D\u3009 , X). Further, let G be the set of generating defaults of E by Proposition 1, and w.l.o.g. let G := {\u03b41, . . . , \u03b4k} also denote the order in which these defaults are applied. Thus it holds that E = Th(W \u222a{concl(\u03b4) | \u03b4 \u2208 G}). Hence, W |= prereq(\u03b41) holds and further fix a Y \u2208 T(X) which agrees with E on the implied literals from Vars(W,D), i.e., x \u2208 Y if E |= x for x \u2208 Vars(W,D), \u00acx \u2208 Y if |= \u00acx, and x\u03b5 \u2208 Y otherwise. Then, by Corollary 2 we know that also \u2227\n\u03c9\u2208W \u03c1Y (\u03c9) |= \u03c1Y (prereq(\u03b41)) is true. Furthermore, we get that\n\u2227\n\u03c9\u2208W\n\u03c1Y (\u03c9) \u2227 \u2227\n1\u2264j\u2264i\n\u03c1Y (concl(\u03b4j)) |= \u03c1Y (prereq(\u03b4i+1))\nholds for i < k. Thus, by definition of \u03c1Y (W,D), the reducts of the knowledge base W and the derived conclusions together trivially imply the yis, i.e., it holds that\n\u2227\n\u03c9\u2208W\n\u03c1Y (\u03c9) \u2227 \u2227\n1\u2264i\u2264k\n\u03c1Y (concl(\u03b4i)) |= \u2227\n1\u2264i\u2264k\nyi.\nAs neither E |= prereq(\u03b4) holds for some \u03b4 \u2208 D \\G, nor E \u222a {concl(\u03b4) | \u03b4 \u2208 G} |= \u03b4\u2032 is true for some \u03b4\u2032 \u2208 D \\ G, E is a consistent set, and Y agrees with E on the implied variables from Vars(W,D), we get that no further default rule \u03b4 is triggered by \u03c1Y (W ) or \u03c1Y (W \u222a {concl(\u03b4) | \u03b4 \u2208 D \\G}).\nFurther, it holds that no justification is violated as E |= \u00ac\u03b2 for some \u03b2 \u2208 \u22c3\n\u03b4\u2208G just(\u03b4) would imply that \u03c1Y (E) |= \u00ac\u03c1Y (\u03b2) also holds by Corollary 2. Thus, eventually E\u2032 = Th(\u03c1Y (W ) \u222a {\u03c1Y (concl(\u03b4)) | \u03b4 \u2208 G}) is a stable extension with respect to \u03c1Y (W,D). But, the set of conclusions of G coincides with y-concl(D,E\u2032) wherefore\nE = Th(W \u222a {concl(\u03b4) | \u03b4 \u2208 G})\n= Th(W \u222a y-concl(D,E\u2032)) \u2208 SE(\u3008W,D\u3009 , X)\nholds, which contradicts our assumption. Thus, the lemma applies.\nWe have seen that it is important to disallow tautological clauses. However, the detection of this kind of clauses is possible in polynomial time. Therefore, we assume in the following that a given theory contains no tautological clauses. This is not a very weak restriction as (i) \u03d5\u2227C \u2261 \u03d5 for any tautological clause C, and (ii) C \u2261 \u22a4 for any tautological clause C.\nThe following example illustrates how reducts maintain existence of stable extensions.\nExample 3. The default theory \u3008W,D\u3009 = {{x}, { x:y\u00acy\u2228x}} has the extension E := Th(x,\u00acy \u2228 x) and yields the following cases for the backdoor B = {x}: \u03c1x(W,D) = \u3008{\u22a4}, { \u22a4:z y1 }\u3009, yielding SE(\u03c1x(W,D)) = {Th(y1)}, and, both, \u03c1\u00acx(W,D) and \u03c1x\u03b5(W,D) yield an empty set of stable extensions. Thus, with y-concl(D,Th(y1)) = {\u00acy \u2228 x} we get Th({\u00acy \u2228 x} \u222a {x}) which is equivalent to the extension E of \u3008W,D\u3009.\nNow, we are in the position to present a definition of strong backdoors for default logic.\nDefinition 3 (Strong Backdoors for Default Logic). Given a cnf default theory \u3008W,D\u3009, a set B \u2286 Vars(W,D) of variables, and a class F of formulas. We say that B is a strong F -backdoor if for each Y \u2208 T(B) the reduct \u03c1Y (W,D) is a F default theory."}, {"heading": "4 Backdoor Evaluation", "text": "In this section, we investigate the evaluation of strong backdoors for the extension existence problem in default logic with respect to different classes of CNF formulas. Formally, the problem of strong backdoor evaluation for extension existence is defined as follows.\nProblem: EvalExt(F \u2192 F \u2032) Input: An F -default theory \u3008W,D\u3009 and a strong F \u2032-backdoor B \u2286 Vars(W ) \u222a Vars(D).\nParameter: The size of the backdoor B.\nQuestion: Does \u3008W,D\u3009 have a stable extension?\nFirst, we study the complexity of the \u201cextension checking problem\u201d, which is a main task we need to accomplish when using backdoors as our approach following Lemma 4 yields only \u201cstable extension candidates\u201d. Formally, given a default theory \u3008W,D\u3009 and a finite set \u03a6 of formulas, EC asks whether Th(\u03a6) \u2208 SE(\u3008W,D\u3009) holds.\nRosati [35] classified the extension checking problem as complete for the complexity class \u0398P2 = \u2206p2 [log], which allows only logarithmic many oracle questions to an NP oracle. For further information on the complexity class \u0398P2 we refer the reader to the survey article of Eiter and Gottlob [15].We will later see that a simpler version suffices for our complexity analysis. Therefore, we state in Algorithm 1 an adaption of Rosatis algorithm [35, Figure 1] to our notation showing containment (only) in \u2206p2 .\nProposition 5 ([35, Figure 1, Theorem 4]). EC \u2208 \u2206p2 .\nIn a way, extension checking can be compared to model checking in logic. In default logic the complexity of the extension existence problem Ext is twofold: using the approach of Proposition 1 (i) one has to non-deterministically guess the set (and ordering) of the generating defaults, and (ii) one has to verify whether the generating defaults lead to an extension. For (ii), one needs to answer quadratic many implication questions. Hence, the problem is in NPNP. Thus, a straightforward approach for EC omits the non-determinism in (i) and achieves the result in PNP.\nTheorem 1. EvalExt(cnf \u2192 horn) \u2208 para-NP.\nProof. Let \u3008W,D\u3009 be a given cnf default theory and B \u2286 Vars(W,D) be the given backdoor. In order to evaluate the backdoor we have to consider the |T(X)| = 3|B| many different reducts to horn default theories. For each of them we have to non-deterministically guess a set of generating defaults G. Then, we use Algorithm 1 to verify whether W \u2227 \u2227\ng\u2208G g is a stable extension (extensions can be represented by generating defaults; see Proposition 1). Imp(horn) \u2208 P by Proposition 3. Hence, stable extension checking is in P for horn formulas. Then, after finding an extension E with respect to the reduct default theory \u03c1Y (W,D), we need to compute the corresponding extension E\n\u2032 with respect to the original default theory. Here we just need to verify simple implication questions of the form E |= yi for 1 \u2264 i \u2264 |D|. Next, we need to verify whether E\u2032 is a valid extension for \u3008W,D\u3009 using Algorithm 1. Note that Corollary 1 shows that the implication problem of propositional formulas parameterised by the size of the backdoor is in FPT, hence we can compute the implication questions inline. As the\nAlgorithm 1: Extension checking algorithm [35, Theorem 4]\nInput: Set E of formulas and a default theory \u3008W,D\u3009 Output: True iff E is a stable extension of \u3008W,D\u3009\n1 D\u2032 := \u2205 2 forall \u03b1:\u03b2 \u03b3 \u2208 D do // (1) Classify unviolated justifications. 3 if E 6|= \u00ac\u03b2 then D\u2032 := D\u2032 \u222a {\u03b1: \u03b3 }\n// (2) Compute extension candidate of justification-free theory.\n4 E\u2032 := W 5 while E\u2032 did change in the last iteration do 6 forall \u03b1:\n\u03b3 \u2208 D\u2032 do\n7 if E\u2032 |= \u03b1 then E\u2032 := E\u2032 \u2227 \u03b3\n// (3) Does the candidate match the extension?\n8 if E |= E\u2032 and E\u2032 |= E then return true else return false\nAlgorithm 2: Generic algorithm for EvalExt(F \u2192 F \u2032)\nInput: F -default theory \u3008W,D\u3009, backdoor B \u2286 Vars(W,D) 1 for Y \u2208 T(X) do 2 construct set of generating defaults G for F \u2032 default theory \u03c1Y (W,D) 3 if E := \u2227\nw\u2208\u03c1Y (W ) w \u2227\n\u2227\n\u03b1:\u03b2 \u03b3\n\u2208G \u03b3 is extension for \u03c1Y (W,D) then\n4 E\u2032 := \u2227 \u03c9\u2208W \u03c9 \u2227 \u2227 c\u2208y-concl(D,E\u2032) c // always in P by construction 5 if E\u2032 is extension for \u3008W,D\u3009 then return true\n6 return false\nlength of the used formulas is bounded by the input size and the relevant parameter is the same as for the input this runs in fpt-time.\nTogether this yields a para-NP algorithm. Algorithm 2 depicts a generic algorithm in pseudocode.\nCorollary 3. EvalExt(cnf \u2192 krom) \u2208 para-NP.\nProof. The implication problem of krom formulas is in P due to Lemma 1. Thus under a similar argumentation as in the proof of Theorem 1 we can construct a para-NP algorithm.\nCorollary 4. EvalExt(cnf \u2192 monotone) \u2208 para-\u2206p2 .\nProof. For a monotone formula \u03d5 its negation is not any longer monotone unless \u03d5 \u2208 {\u22a4,\u22a5}. This observation is important for such \u03d5 occurring as justifications. If \u03d5 /\u2208 {\u22a4,\u22a5} then this justification can be deleted as its negation will not be inferable whence the default rule is applicable whenever its prerequisite is met. If \u03d5 \u2208 {\u22a4,\u22a5} then either it is only applicable in an inconsistent case or always. Hence we can distinct between these cases in polynomial time. Further observe that because of the previous argumentation there exists a unique stable extension if any. Thus the construction of the set of generating defaults and also the extension is achievable in para-\u2206p2 as we have to do quadratic many implication questions, and the implication problem for monotone formulas has the same upper bound as the unrestricted one, hence coNP. Step (5) of Algorithm 2 is then just uses Algorithm 2 for implication questions which are solved via the standard algorithm (which is possible as we use a para-\u2206p2 algorithm).\nThe following corollary shows that the consideration of backdoor evaluation for the extension existence problem starting from krom default theories is interesting.\nCorollary 5. Ext(krom) is NP-complete.\nProof. As Lemma 1 shows that Imp(krom) \u2208 P we get that the extension checking problem for krom default theories is in P with the help of Proposition 5. In order to show the NP upper bound, on input \u3008W,D\u3009 the algorithm just guesses the set of generating defaults G \u2286 D and then verifies if W \u2227 \u2227\n\u03b1:\u03b2 \u03b3\n\u2208G \u03b3 is an extension with respect to \u3008W,D\u3009.\nFor the lower bound observe that the default theory constructed by Beyersdorff et al. [2, Lemma 5.6] consists only of krom formulas settling the lower bound by an reduction from 3Sat.\nCorollary 6. EvalExt(cnf \u2192 positive-unit) \u2208 FPT.\nProof. The implication problem for positive-unit formulas is in AC0 by Beyersdorff et al. who showed this result for formulas using only conjunctions [1, Theorem 4.1(4)]. Hence, Algorithm 1 runs in polynomial time. Thus we achieve the FPT upper bound by a similar argumentation is the proof of Theorem 1."}, {"heading": "5 Backdoor Detection", "text": "In this section, we study the problem of finding backdoors, formalised in terms of the following parameterised problem:\nProblem: BdDetect(cnf \u2192 F)\nInput: A cnf default theory T and an integer k.\nParameter: The integer k.\nQuestion: Does T have a strong F -backdoor of size at most k?\nIf the target class F \u2032 is clause-induced, we can use a decision algorithm for BdDetect(F \u2192 F \u2032) to find the backdoor using self-reduction [38, 12].\nLemma 5. Let F be a clause-induced class of cnf formulas. If BdDetect(cnf \u2192 F) is fixedparameter tractable, then also computing a strong F-backdoor of size at most k of a given default theory T is fixed-parameter tractable (for parameter k).\nProof. Let T = \u3008W,D\u3009 be a default theory. We proceed by induction on k. If k = 0 the statement is clearly true. Let k > 0. Given (T, k) we check for all v \u2208 Vars(W ) \u222a Vars(D) whether \u03c1Y (W,D), \u03c1Y \u2032(W,D), and \u03c1Y \u2032\u2032(W,D) have a strong F -backdoor of size at most k \u2212 1 where Y = {v}, Y \u2032 = {\u00acv}, and Y \u2032\u2032 = {v\u03b5}. If the answer is No for all v, then T has no strong F -backdoor of size k. If the answer is Yes for v, then by induction hypothesis we can compute a strong F -backdoor B of size at most k\u2212 1 of \u03c1Y (W,D), \u03c1Y \u2032(W,D), and \u03c1Y \u2032\u2032(W,D) and B \u222a {v} is a strong F -backdoor of T .\nThe following theorem provides interesting target classes, where we can determining backdoors in fpt-time.\nTheorem 2. Let C \u2208 {horn, positive-unit, krom, monotone}, then BdDetect(cnf \u2192 C) \u2208 FPT.\nProof. Let \u3008W,D\u3009 be a cnf default theory and F := W \u222a { prereq(\u03b4), just(\u03b4), concl(\u03b4) | \u03b4 \u2208 D }. Since each class C \u2208 {horn, positive-unit, krom, monotone} is clause-induced and then obviously \u03c1Z(\u03d5) \u2286 \u03c1Y (\u03d5) holds for any Z \u2208 T(X), we have to consider only the case Y = { x\u03b5 | x \u2208 X } to construct a strongC-backdoor of \u3008W,D\u3009. Thus let Y = { x\u03b5 | x \u2208 X }in the following..\nC = monotone: A cnf formula \u03d5 is monotone if every literal appears only positively in any clause C \u2208 \u03d5 where \u03d5 \u2208 F. We can trivially construct a smallest strong monotone-backdoor by taking all negative literals of clauses in formulas of F in linear time. Hence, the claim holds.\nFor C \u2208 {horn, positive-unit,krom} we follow known constructions from the propositional setting [36]. Therefore, we consider certain (hyper-)graph representations of the given theory and establish\nthat a set B \u2286 Vars(F) is a strong C-backdoor of \u3008W,D\u3009 if and only if B is a d-hitting set of the respective (hyper-)graph representation of \u3008W,D\u3009 where d depends on the class of formulas, i.e., d = 2 for horn and positive-unit and d = 3 for krom. A 2-hitting set (vertex cover) of a graph G = (V,E) is a set S \u2286 V such that for every edge uv \u2208 E we have {u, v} \u2229 S 6= \u2205. A 3-hitting set of a hypergraph H = (V,E), with E \u2208 E and |E| \u2264 3, is a set S \u2286 V such that for every hyperedge E \u2208 E we have E \u2229 S 6= \u2205. Then, a vertex cover of size at most k, if it exists, can be found in time O(1.2738k + kn) [6] and a 3-hitting set of size at most k, if it exists, can be found in time O(2.179k + n3) [16], which gives us then a strong C-backdoor of \u3008W,D\u3009. It remains to define the specific graph representations and to establish the connection to strong C-backdoors.\nDefinition of the various (hyper-)graphs: For C = horn we define a graph G+T on the set of variables of F, where two distinct variables x and y are joined by an edge if there is a formula \u03d5 \u2208 F and some clause C \u2208 \u03d5 with x, y \u2208 C. For C = positive-unit we define a graph GT on the set of variables of F, where two distinct variables x and y are joined by an edge if there is a formula \u03d5 \u2208 F and some clause C \u2208 \u03d5 with lx, ly \u2208 C where lx \u2208 {x,\u00acx} and ly \u2208 {y,\u00acy}. For C = krom we define a hypergraph HT on the variables Vars(F) where distinct variables x, y, z are joined by a hyperedge if there is a formula \u03d5 \u2208 F and some clause C \u2208 \u03d5 with {x, y, z} \u2286 Vars(C).\nNext, we establish the only-if direction of the claim: Let B \u2286 Vars(F) be a strong C-backdoor of \u3008W,D\u3009. Consider an edge uv of G. By construction of G+T , GT , and HT there is a corresponding clause C \u2208 \u03d5 for some formula \u03d5 \u2208 F with u, v \u2208 C. By assumption, we construct \u03c1Y (\u03d5) from \u03d5 by deleting all occurrences of literals \u00acx and x from clauses in \u03d5. Since each clause in \u03c1Y (\u03d5) contains at most one positive literal (horn), or only positive unit clauses (positive-unit), or at most one variable (krom), respectively, we have {u, v}\u2229X 6= \u2205. We conclude that B is a vertex cover of G+T , vertex cover of GT , or 3-hitting set of HT , respectively, which establishes the only-if direction of the claim.\nFinally, we establish the if direction of the claim: Therefore, assume that B is a d-hitting set of the graph respective (hyper-)graph representation (d = 2 for horn and positive-unit and d = 3 for krom). Consider a clause C \u2208 \u03c1Y (\u03d5) for some \u03d5 \u2208 F. For proof by contradiction assume that C is not Horn, or not positive unit, or not Krom, respectively. Then there is a set S \u2286 C (|V | = 2 for horn and positive-unit and |V | = 3 for krom) and an edge S of G such that S \u2229X = \u2205, contradicting the assumption that B is a vertex cover or 3-hitting set, respectively. Hence the if direction of the claim holds, which establishes the theorem.\nNow, we can use Theorem 2 to strengthen the results of Theorem 1 and Corollaries 3 and 4 by dropping the assumption that the backdoor is given.\nCorollary 7. Let C \u2208 {horn, krom, monotone}, then the problem EvalExt(cnf \u2192 C) is in para-NP when parameterised by the size of a smallest strong C-backdoor of the given theory. Further, the problem EvalExt(cnf \u2192 positive-unit) is in FPT when parameterised by the size of a smallest strong positive-unit-backdoor of the given theory."}, {"heading": "6 Conclusion", "text": "We have introduced a notion of strong backdoors for propositional default logic. In particular, we investigated on the parameterised decision problems backdoor detection and backdoor evaluation. We have established that backdoor detection for the classes cnf, horn, krom, monotone, and positive-unit are fixed-parameter tractable whereas for evaluation the classification is more complex. If cnf is the starting class and horn or krom is the target class, then backdoor evaluation is in para-NP. If monotone is the target class, then backdoor evaluation is in para-\u2206p2 , which is can be solved by an fptalgorithm that can query a SAT solver multiple times [10]. For positive-unit as target class backdoor evaluation is fixed-parameter tractable.\nAn interesting task for future research is to consider the remaining Schaefer classes [37], e.g., dualHorn, 1- and 0-valid, as well as the classes renamable-Horn and QHorn [3, 4], and investigate whether we can generalise Algorithm 2.We have established for backdoor evaluation the upper bounds para-NP and para-\u2206p2 , respectively. We think that it would also be interesting to establish corresponding lower\nbounds. Finally, a direct application of quantified Boolean formulas in the context of propositional default logic, for instance, via the work of Egly et al. [14] or exploiting backdoors similar to results by Fichte and Szeider [17], might yield new insights."}, {"heading": "Acknowledgements", "text": "The first author gratefully acknowledges support by the Austrian Science Fund (FWF), Grant Y698. He is also affiliated with the Institute of Computer Science and Computational Science at University of Potsdam, Germany. The second and third author gratefully acknowledge support by the German Research Foundation (DFG), Grant ME 4279/1-1. The authors thank Jonni Virtema for pointing out Lemma 1 and Sebastian Ordyniak for discussions on Lemma 2."}], "references": [{"title": "The Complexity of Propositional Implication", "author": ["Olaf Beyersdorff", "Arne Meier", "Michael Thomas", "Heribert Vollmer"], "venue": "Information Processing Letters,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "The complexity of reasoning for fragments of default logic", "author": ["Olaf Beyersdorff", "Arne Meier", "Michael Thomas", "Heribert Vollmer"], "venue": "Journal of Logic and Computation,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2012}, {"title": "Polynomial-time inference of all valid implications for horn and related formulae", "author": ["Endre Boros", "Yves Crama", "Peter L. Hammer"], "venue": "Ann. Math. Artif. Intell.,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 1990}, {"title": "Recognition of q-Horn formulae in linear time", "author": ["Endre Boros", "Peter L. Hammer", "Xiaorong Sun"], "venue": "Discr. Appl. Math.,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 1994}, {"title": "Tight lower bounds for certain parameterized NP-hard problems", "author": ["Jianer Chen", "Benny Chor", "Michael R. Fellows", "Xiuzhen Huang", "David W. Juedes", "Iyad A. Kanji", "Ge Xia"], "venue": "Information and Computation,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2005}, {"title": "Improved upper bounds for vertex cover", "author": ["Jianer Chen", "Iyad A. Kanj", "Ge Xia"], "venue": "Theoretical Computer Science,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2010}, {"title": "Graph rewriting: An algebraic and logic approach", "author": ["Bruno Courcelle"], "venue": null, "citeRegEx": "7", "shortCiteRegEx": "7", "year": 1990}, {"title": "Graph structure and monadic second-order logic, a language theoretic approach", "author": ["Bruno Courcelle", "Joost Engelfriet"], "venue": null, "citeRegEx": "8", "shortCiteRegEx": "8", "year": 2012}, {"title": "The complexity of reasoning for fragments of autoepistemic logic", "author": ["Nadia Creignou", "Arne Meier", "Michael Thomas", "Heribert Vollmer"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2012}, {"title": "Fixed-parameter tractable reductions to SAT", "author": ["Ronald DeHaan", "Stefan Szeider"], "venue": "Proceedings of the 17th International Conference on Theory and Applications of Satisfiability Testing (SAT\u201914),", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2014}, {"title": "Parameterized Complexity. Monographs in Computer Science", "author": ["Rodney G. Downey", "Michael R. Fellows"], "venue": null, "citeRegEx": "11", "shortCiteRegEx": "11", "year": 1999}, {"title": "Fundamentals of Parameterized Complexity. Texts in Computer Science", "author": ["Rodney G. Downey", "Michael R. Fellows"], "venue": null, "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "Augmenting tractable fragments of abstract argumentation", "author": ["Wolfgang Dvo\u0159\u00e1k", "Sebastian Ordyniak", "Stefan Szeider"], "venue": "Artificial Intelligence,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2012}, {"title": "Solving advanced reasoning tasks using quantified boolean formulas", "author": ["Uwe Egly", "Thomas Eiter", "Hans Tompits", "Stefan Woltran"], "venue": "Proceedings of the 17th Conference on Artificial Intelligence", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2000}, {"title": "The complexity class", "author": ["Thomas Eiter", "Georg Gottlob"], "venue": "Proceedings of the 11th International Symposium on Fundamentals of Computation Theory (FCT\u201997),", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 1997}, {"title": "A top-down approach to search-trees: Improved algorithmics for 3-hitting", "author": ["Henning Fernau"], "venue": "set. Algorithmica,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2010}, {"title": "Backdoors to normality for disjunctive logic programs", "author": ["Johannes K. Fichte", "Stefan Szeider"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2015}, {"title": "Backdoors to tractable answer-set programming", "author": ["Johannes K. Fichte", "Stefan Szeider"], "venue": "Artificial Intelligence,", "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2015}, {"title": "Describing parameterized complexity classes", "author": ["J\u00f6rg Flum", "Martin Grohe"], "venue": "Information and Computation,", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2003}, {"title": "Parameterized Complexity Theory, volume XIV of Theoretical Computer Science", "author": ["J\u00f6rg Flum", "Martin Grohe"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2006}, {"title": "Backdoors to satisfaction", "author": ["Serge Gaspers", "Stefan Szeider"], "venue": "Essays Dedicated to Michael R. Fellows on the Occasion of His 60th Birthday,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2012}, {"title": "Complexity results for nonmonotonic logics", "author": ["Georg Gottlob"], "venue": "J. Logic Comput.,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 1992}, {"title": "Bounded treewidth as a key to tractability of knowledge representation and reasoning", "author": ["Georg Gottlob", "Reinhard Pichler", "Fang Wei"], "venue": "Artificial Intelligence,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2010}, {"title": "Fixed-parameter complexity in AI and nonmonotonic reasoning", "author": ["Georg Gottlob", "Francesco Scarcello", "Martha Sideri"], "venue": "Artificial Intelligence,", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2002}, {"title": "Fixed-parameter algorithms for artificial intelligence, constraint satisfaction, and database problems", "author": ["Georg Gottlob", "Stefan Szeider"], "venue": "The Computer Journal,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2006}, {"title": "Circumscription \u2013 A form of non-monotonic reasoning", "author": ["John McCarthy"], "venue": "Artificial Intelligence,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 1980}, {"title": "Non-montonic logic I", "author": ["Drew McDermott", "Jon Doyle"], "venue": "Artificial Intelligence,", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1980}, {"title": "On the parameterized complexity of non-monotonic logics", "author": ["Arne Meier", "Irina Schindler", "Johannes Schmidt", "Michael Thomas", "Heribert Vollmer"], "venue": "Archive for Mathematical Logic,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2015}, {"title": "Semantical considerations on modal logic", "author": ["Robert C. Moore"], "venue": "Artificial Intelligence,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1985}, {"title": "Satisfiability of acyclic and almost acyclic CNF formulas", "author": ["Sebastian Ordyniak", "Daniel Paulusma", "Stefan Szeider"], "venue": "Theoretical Computer Science,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2013}, {"title": "Backdoors to abduction", "author": ["Andreas Pfandler", "Stefan R\u00fcmmele", "Stefan Szeider"], "venue": "Proceedings of the 23rd International Joint Conference on Artificial Intelligence", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 2013}, {"title": "A logic for default reasoning", "author": ["Raymond Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 1980}, {"title": "Model checking for nonmonotonic logics: Algorithms and complexity", "author": ["Riccardo Rosati"], "venue": "Proceedings of the 16th International Joint Conference on Artificial Intelligence (IC- JAI\u201999),", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 1999}, {"title": "Fixed-parameter tractability", "author": ["Marko Samer", "Stefan Szeider"], "venue": "Handbook of Satisfiability,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2009}, {"title": "The complexity of satisfiability problems", "author": ["Thomas J. Schaefer"], "venue": "Proceedings of the 10th Annual ACM Symposium on Theory of Computing", "citeRegEx": "37", "shortCiteRegEx": "37", "year": 1978}, {"title": "On self-transformable combinatorial problems", "author": ["Claus-Peter Schnorr"], "venue": "Mathematical Programming at Oberwolfach,", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 1981}, {"title": "It\u2019s not my default: The complexity of membership problems in restricted propositional default logics", "author": ["Jonathan P. Stillman"], "venue": "Proceedings of the 8th National conference on Artificial Intelligence (AAAI\u201990),", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 1990}, {"title": "The Complexity of Horn Theories with Normal Unary Defaults", "author": ["Jonathan P. Stillman"], "venue": "In Proceedings of the 8th Canadian Artificial Intelligence Conference", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 1990}, {"title": "On fixed-parameter tractable parameterizations of SAT", "author": ["Stefan Szeider"], "venue": "Proceedings of the 6th International Conference Theory and Applications of Satisfiability (SAT\u201903),", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 2004}, {"title": "Backdoors to typical case complexity", "author": ["Ryan Williams", "Carla Gomes", "Bart Selman"], "venue": "Proceedings of the 18th International Joint Conference on Artificial Intelligence", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 2003}, {"title": "On the connections between backdoors, restarts, and heavy-tailedness in combinatorial search", "author": ["Ryan Williams", "Carla Gomes", "Bart Selman"], "venue": "In Informal Proceedings of the 6th International Conference on Theory and Applications of Satisfiability Testing", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2003}], "referenceMentions": [{"referenceID": 25, "context": "In the 1980s, several kinds of formalisms have been introduced, most notably, circumscription [27], default logic [34], autoepistemic logic [30], and non-monotonic logic [28].", "startOffset": 94, "endOffset": 98}, {"referenceID": 31, "context": "In the 1980s, several kinds of formalisms have been introduced, most notably, circumscription [27], default logic [34], autoepistemic logic [30], and non-monotonic logic [28].", "startOffset": 114, "endOffset": 118}, {"referenceID": 28, "context": "In the 1980s, several kinds of formalisms have been introduced, most notably, circumscription [27], default logic [34], autoepistemic logic [30], and non-monotonic logic [28].", "startOffset": 140, "endOffset": 144}, {"referenceID": 26, "context": "In the 1980s, several kinds of formalisms have been introduced, most notably, circumscription [27], default logic [34], autoepistemic logic [30], and non-monotonic logic [28].", "startOffset": 170, "endOffset": 174}, {"referenceID": 31, "context": "In this paper, we focus on Reiter\u2019s Default Logic (DL), which has been introduced in 1980 [34] and is one of the most fundamental formalism for modelling human-sense reasoning.", "startOffset": 90, "endOffset": 94}, {"referenceID": 21, "context": "In 1992, Gottlob showed that many important decision problems, beyond the extension existence problem, of non-monotonic logics are complete for the second level of the polynomial hierarchy [22] and thus are of high intractability.", "startOffset": 189, "endOffset": 193}, {"referenceID": 11, "context": "A prominent approach to understand the intractability of a problem is to use the framework of parameterised complexity, which was introduced by Downey and Fellows [12, 11].", "startOffset": 163, "endOffset": 171}, {"referenceID": 10, "context": "A prominent approach to understand the intractability of a problem is to use the framework of parameterised complexity, which was introduced by Downey and Fellows [12, 11].", "startOffset": 163, "endOffset": 171}, {"referenceID": 38, "context": "The invention of new parameters can be quite challenging, however, Sat has so far been considered under many different parameters [41, 36, 5, 31].", "startOffset": 130, "endOffset": 145}, {"referenceID": 33, "context": "The invention of new parameters can be quite challenging, however, Sat has so far been considered under many different parameters [41, 36, 5, 31].", "startOffset": 130, "endOffset": 145}, {"referenceID": 4, "context": "The invention of new parameters can be quite challenging, however, Sat has so far been considered under many different parameters [41, 36, 5, 31].", "startOffset": 130, "endOffset": 145}, {"referenceID": 29, "context": "The invention of new parameters can be quite challenging, however, Sat has so far been considered under many different parameters [41, 36, 5, 31].", "startOffset": 130, "endOffset": 145}, {"referenceID": 39, "context": "A concept that provides a parameter and has been widely used in theoretical investigations of propositional satisfiability are backdoors [42, 21, 25].", "startOffset": 137, "endOffset": 149}, {"referenceID": 20, "context": "A concept that provides a parameter and has been widely used in theoretical investigations of propositional satisfiability are backdoors [42, 21, 25].", "startOffset": 137, "endOffset": 149}, {"referenceID": 24, "context": "A concept that provides a parameter and has been widely used in theoretical investigations of propositional satisfiability are backdoors [42, 21, 25].", "startOffset": 137, "endOffset": 149}, {"referenceID": 39, "context": "Backdoors for propositional satisfiability have been introduced by Williams, Gomes, and Selman [42, 43].", "startOffset": 95, "endOffset": 103}, {"referenceID": 40, "context": "Backdoors for propositional satisfiability have been introduced by Williams, Gomes, and Selman [42, 43].", "startOffset": 95, "endOffset": 103}, {"referenceID": 30, "context": "The concept of backdoors has recently been lifted to some non-monotonic formalisms as abduction [33], answer set programming [18, 17], and argumentation [13].", "startOffset": 96, "endOffset": 100}, {"referenceID": 17, "context": "The concept of backdoors has recently been lifted to some non-monotonic formalisms as abduction [33], answer set programming [18, 17], and argumentation [13].", "startOffset": 125, "endOffset": 133}, {"referenceID": 16, "context": "The concept of backdoors has recently been lifted to some non-monotonic formalisms as abduction [33], answer set programming [18, 17], and argumentation [13].", "startOffset": 125, "endOffset": 133}, {"referenceID": 12, "context": "The concept of backdoors has recently been lifted to some non-monotonic formalisms as abduction [33], answer set programming [18, 17], and argumentation [13].", "startOffset": 153, "endOffset": 157}, {"referenceID": 21, "context": "Beyond the classification of Gottlob [22], the complexity of fragments, in the sense of Post\u2019s lattice, has been considered by Beyersdorff et al.", "startOffset": 37, "endOffset": 41}, {"referenceID": 1, "context": "extensively for default logic [2], and for autoepistemic logic by Creignou et al.", "startOffset": 30, "endOffset": 33}, {"referenceID": 8, "context": "[9].", "startOffset": 0, "endOffset": 3}, {"referenceID": 6, "context": "Also parameterised analyses of non-monotonic logics in the spirit of Courcelle\u2019s theorem [7, 8] have recently been considered by Meier et al.", "startOffset": 89, "endOffset": 95}, {"referenceID": 7, "context": "Also parameterised analyses of non-monotonic logics in the spirit of Courcelle\u2019s theorem [7, 8] have recently been considered by Meier et al.", "startOffset": 89, "endOffset": 95}, {"referenceID": 27, "context": "[29].", "startOffset": 0, "endOffset": 4}, {"referenceID": 22, "context": "studied treewidth as a parameter for various non-monotonic logics [23] and also considered a more CSP focused non-monotonic context within the parameterised complexity setting [24].", "startOffset": 66, "endOffset": 70}, {"referenceID": 23, "context": "studied treewidth as a parameter for various non-monotonic logics [23] and also considered a more CSP focused non-monotonic context within the parameterised complexity setting [24].", "startOffset": 176, "endOffset": 180}, {"referenceID": 19, "context": "For more detailed information, we refer to other standard sources [32, 20, 12].", "startOffset": 66, "endOffset": 78}, {"referenceID": 11, "context": "For more detailed information, we refer to other standard sources [32, 20, 12].", "startOffset": 66, "endOffset": 78}, {"referenceID": 18, "context": "We follow the notion by Flum and Grohe [19].", "startOffset": 39, "endOffset": 43}, {"referenceID": 31, "context": "1 Default Logic We follow notions by Reiter [34] and define a default rule \u03b4 as a triple \u03b1:\u03b2 \u03b3 ; \u03b1 is called the prerequisite, \u03b2 is called the justification, and \u03b3 is called the conclusion; we set prereq(\u03b4) := \u03b1, just(\u03b4) := \u03b2, and concl(\u03b4) := \u03b3.", "startOffset": 44, "endOffset": 48}, {"referenceID": 31, "context": "Definition 1 (Fixed point semantics, [34]).", "startOffset": 37, "endOffset": 41}, {"referenceID": 31, "context": "A definition for stable extensions beyond fixed point semantics, which has been introduced by Reiter [34] as well, uses the principle of a stage construction.", "startOffset": 101, "endOffset": 105}, {"referenceID": 31, "context": "Proposition 1 (Stage construction, [34]).", "startOffset": 35, "endOffset": 39}, {"referenceID": 21, "context": "Ext(cnf) is \u03a3p2-complete [22].", "startOffset": 25, "endOffset": 29}, {"referenceID": 36, "context": "Ext(horn) is NP-complete [39, 40].", "startOffset": 25, "endOffset": 33}, {"referenceID": 37, "context": "Ext(horn) is NP-complete [39, 40].", "startOffset": 25, "endOffset": 33}, {"referenceID": 1, "context": "Ext(positive-unit) \u2208 P [2].", "startOffset": 23, "endOffset": 26}, {"referenceID": 1, "context": "[2] have considered all Boolean fragments of Imp(F) and completely classified its computational complexity concerning the framework of Post\u2019s lattice.", "startOffset": 0, "endOffset": 3}, {"referenceID": 36, "context": "However, its complexity is already known from the work by Stillman [39].", "startOffset": 67, "endOffset": 71}, {"referenceID": 39, "context": "First, we review backdoors from the propositional setting [42, 43], where a backdoor is a subset of the variables of a given formula.", "startOffset": 58, "endOffset": 66}, {"referenceID": 40, "context": "First, we review backdoors from the propositional setting [42, 43], where a backdoor is a subset of the variables of a given formula.", "startOffset": 58, "endOffset": 66}, {"referenceID": 32, "context": "Rosati [35] classified the extension checking problem as complete for the complexity class \u03982 = \u2206p2 [log], which allows only logarithmic many oracle questions to an NP oracle.", "startOffset": 7, "endOffset": 11}, {"referenceID": 14, "context": "For further information on the complexity class \u03982 we refer the reader to the survey article of Eiter and Gottlob [15].", "startOffset": 114, "endOffset": 118}, {"referenceID": 35, "context": "Question: Does T have a strong F -backdoor of size at most k? If the target class F \u2032 is clause-induced, we can use a decision algorithm for BdDetect(F \u2192 F ) to find the backdoor using self-reduction [38, 12].", "startOffset": 200, "endOffset": 208}, {"referenceID": 11, "context": "Question: Does T have a strong F -backdoor of size at most k? If the target class F \u2032 is clause-induced, we can use a decision algorithm for BdDetect(F \u2192 F ) to find the backdoor using self-reduction [38, 12].", "startOffset": 200, "endOffset": 208}, {"referenceID": 33, "context": "For C \u2208 {horn, positive-unit,krom} we follow known constructions from the propositional setting [36].", "startOffset": 96, "endOffset": 100}, {"referenceID": 5, "context": "2738 + kn) [6] and a 3-hitting set of size at most k, if it exists, can be found in time O(2.", "startOffset": 11, "endOffset": 14}, {"referenceID": 15, "context": "179 + n) [16], which gives us then a strong C-backdoor of \u3008W,D\u3009.", "startOffset": 9, "endOffset": 13}, {"referenceID": 9, "context": "If monotone is the target class, then backdoor evaluation is in para-\u2206p2 , which is can be solved by an fptalgorithm that can query a SAT solver multiple times [10].", "startOffset": 160, "endOffset": 164}, {"referenceID": 34, "context": "An interesting task for future research is to consider the remaining Schaefer classes [37], e.", "startOffset": 86, "endOffset": 90}, {"referenceID": 2, "context": ", dualHorn, 1- and 0-valid, as well as the classes renamable-Horn and QHorn [3, 4], and investigate whether we can generalise Algorithm 2.", "startOffset": 76, "endOffset": 82}, {"referenceID": 3, "context": ", dualHorn, 1- and 0-valid, as well as the classes renamable-Horn and QHorn [3, 4], and investigate whether we can generalise Algorithm 2.", "startOffset": 76, "endOffset": 82}, {"referenceID": 13, "context": "[14] or exploiting backdoors similar to results by Fichte and Szeider [17], might yield new insights.", "startOffset": 0, "endOffset": 4}, {"referenceID": 16, "context": "[14] or exploiting backdoors similar to results by Fichte and Szeider [17], might yield new insights.", "startOffset": 70, "endOffset": 74}], "year": 2016, "abstractText": "In this paper, we introduce a notion of backdoors to Reiter\u2019s propositional default logic and study structural properties of it. Also we consider the problems of backdoor detection (parameterised by the solution size) as well as backdoor evaluation (parameterised by the size of the given backdoor), for various kinds of target classes (cnf, horn, krom, monotone, positive-unit). We show that backdoor detection is fixed-parameter tractable for the considered target classes, and backdoor evaluation is either fixed-parameter tractable, in para-\u2206P2 , or in para-NP, depending on the target class.", "creator": "dvips(k) 5.991 Copyright 2011 Radical Eye Software"}}}