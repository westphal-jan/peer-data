{"id": "1602.06458", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "20-Feb-2016", "title": "Causes for Query Answers from Databases, Datalog Abduction and View-Updates: The Presence of Integrity Constraints", "abstract": "causality has been better recently systematically introduced in vector databases, to model, easily characterize and perhaps possibly compute causes for query results ( answers ). connections between queryanswer causality, consistency - based diagnosis, internal database repairs ( wrt. integrity constraint violations ), abductive diagnosis and the view - update problem have been established. primarily in this work we just further investigate connections originating between query - answer pattern causality and abductive diagnosis and the view - update problem. in this context, we also define and investigate the notion of query - answer causality in the meaningful presence of integrity constraints.", "histories": [["v1", "Sat, 20 Feb 2016 20:57:59 GMT  (36kb,D)", "http://arxiv.org/abs/1602.06458v1", "To appear in Proceedings Flairs, 2016"]], "COMMENTS": "To appear in Proceedings Flairs, 2016", "reviews": [], "SUBJECTS": "cs.DB cs.AI", "authors": ["babak salimi", "leopoldo bertossi"], "accepted": false, "id": "1602.06458"}, "pdf": {"name": "1602.06458.pdf", "metadata": {"source": "CRF", "title": "Causes for Query Answers from Databases, Datalog Abduction and View-Updates: The Presence of Integrity Constraints", "authors": ["Babak Salimi", "Leopoldo Bertossi"], "emails": ["bsalimi@cs.washington.edu.", "bertossi@scs.carleton.ca."], "sections": [{"heading": null, "text": "possibly compute causes for query results (answers). Connections between queryanswer causality, consistency-based diagnosis, database repairs (wrt. integrity constraint violations), abductive diagnosis and the view-update problem have been established. In this work we further investigate connections between query-answer causality and abductive diagnosis and the view-update problem. In this context, we also define and investigate the notion of query-answer causality in the presence of integrity constraints."}, {"heading": "1 Introduction", "text": "Causality is a deep subject that appears at the foundations of many scientific disciplines; and also something we want to represent and compute to deal with uncertainty of data, information and theories. In data management in particular, there is a need to represent, characterize and compute causes that explain why certain query results are obtained or not, or why natural semantic conditions, such as integrity constraints, are not satisfied. Causality can also be used to explain the contents of a view, i.e. of a predicate with virtual contents that is defined in terms of other physical, materialized relations (tables).\nMost of the work on causality by the computer science community has been done in the context of knowledge representation, but little has been said about causality in data management. This work is about causality as defined for queries posed to relational databases.\nThe notion of causality-based explanation for a query result was introduced in [Meliou et al., 2010], on the basis of the deeper concepts of counterfactual and actual causation. This approach can be traced back to [Halpern & Pearl, 2005]. We will refer to this notion as query-answer causality (or simply, QA-causality). Under this approach, \u2217bsalimi@cs.washington.edu. Now at University of Washington. This work was done while at Carleton University. \u2020bertossi@scs.carleton.ca. Contact author.\nar X\niv :1\n60 2.\n06 45\n8v 1\n[ cs\n.D B\n] 2\n0 Fe\nexplanations for query answers are provided in terms causes for query answers; and these causes are ranked according to their degree of responsibility, which quantifies the extent by which a QA-cause contributes to an answer. In [Meliou et al., 2011], viewconditioned causality (vc-causality) was proposed as a restricted form of QA-causality, to determine causes for unexpected query results, but conditioned to the correctness of prior knowledge that cannot be altered by counterfactual tuple-deletions.\nIn [Salimi & Bertossi, 2015a], connections were established between QA-causality and database repairs [Bertossi, 2011], which allowed to obtain several complexity results for QA-causality related problems. A connection between QA-causality and consistency-based diagnosis [Reiter, 1987] was established in [Salimi & Bertossi, 2015a], characterizing causes and responsibilities in terms of diagnoses, and leading to new results for QA-causality. In [Salimi & Bertossi, 2015b] connections between QAcausality and abductive diagnosis [Console et al., 1991; Eiter et al., 1997] were presented.\nThe definition of QA-causality applies to monotone queries [Meliou et al., 2010], but all complexity and algorithmic results in [Meliou et al., 2010; Salimi & Bertossi, 2015a] have been for first-order monotone queries, mainly conjunctive queries. However, QA-causality can be applied to Datalog queries [Abiteboul et al., 1995], which are also monotone, but may contain recursion. Oh the other hand, abductive diagnosis can be done on top of Datalog specifications, leading to Datalog-abduction, for which there are known complexity results [Eiter et al., 1997]. Actually, in [Salimi & Bertossi, 2015b] computational and complexity results were obtained for Datalog QA-causality from a connection with Datalog-abduction. In this work we further exploit this connection to obtain new complexity results for Datalog QA-causality.\nIn [Salimi & Bertossi, 2015b], connections are reported between QA-causality and the classical view-update problem in databases, which is about updating a database through views [Abiteboul et al., 1995]. One wants the base relations (also called \u201cthe source database\u201d) to change in a minimal way while still producing the view updates. When only deletions are performed on monotone views, we have the deletepropagation problem, from views to base relations [Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012]. This is the one considered in this work.\nIn [Salimi & Bertossi, 2015b], several connections between QA-causality and the delete-propagation problem were established and used to obtain new results for the former. In this work we obtain new results for view-conditioned causality from this connection.\nWe define and investigate the notion of query-answer causality in the presence of integrity constraints. The latter are logical dependencies between database tuples that, under the assumption that they are satisfied, should have an effect on determining causes for a query answer. We propose a notion of cause that takes them into account.\nA slightly extended version of this work, with more examples, can be found in [Salimi & Bertossi, 2016]."}, {"heading": "2 Preliminaries", "text": "We consider relational database schemas, S = (U,P), with U a possibly infinite data domain, and P a finite set of database predicates of fixed arities. We may use implicit built-in predicates, e.g. 6=. Schema S determines a language, L(S), of first-order (FO) predicate logic. An instance D for S is a finite set of ground atomic formulas, a.k.a. tuples, P (c1, ..., cn), with ci \u2208 U , and P \u2208 P is not a built-in.\nA conjunctive query (CQ) is a formula of L(S) of the form Q(x\u0304) : \u2203y\u0304(P1(s\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227Pm(s\u0304m)), with the Pi(s\u0304i) atomic formulas, i.e. Pi \u2208 P or is a built-in, and the s\u0304i are sequences of terms, i.e. variables or constants of U . The x\u0304 in Q(x\u0304) shows all the free variables in the formula, i.e. those not appearing in y\u0304. A sequence c\u0304 of constants is an answer to query Q(x\u0304) if D |= Q[c\u0304], i.e. the query becomes true in D when the variables are replaced by the corresponding constants in c\u0304. We denote the set of all answers to a query Q(x\u0304) with Q(D). A conjunctive query is Boolean (a BCQ), if x\u0304 is empty, i.e. the query is a sentence, in which case, it is true or false in D, denoted by D |= Q (or Q(D) = {true}) and D 6|= Q (or Q(D) = {false}), respectively.\nQuery Q is monotone if for any instances D1 \u2286 D2, Q(D1) \u2286 Q(D2). CQs and unions of CQs (UCQs) are monotone, so as (possibly not FO) Datalog queries [Abiteboul et al., 1995]. We consider only monotone queries.\nAn integrity constraint (IC) is a sentence \u03d5 \u2208 L(S). Then, given an instance D for schema S, it may be true or false in D (denoted D |= \u03d5, resp. D 6|= \u03d5). Given a set \u03a3 of ICs, a database instance D is consistent if D |= \u03a3; otherwise it is said to be inconsistent. In this work we assume that sets of ICs are always finite and logically consistent.\nA particular class of ICs is formed by inclusion dependencies ( INDs), which are sentences of the form \u2200x\u0304(Pi(x\u0304) \u2192 \u2203y\u0304Pj(x\u0304\u2032, y\u0304)), with x\u0304\u2032 \u2229 y\u0304 = \u2205, x\u0304\u2032 \u2286 x\u0304. Another special class of ICs is formed by functional dependencies (FDs). For example, \u03c8 : \u2200x\u2200y\u2200z(P (x, y)\u2227 P (x, z)\u2192 y = z) specifies that the second attribute of P functionally depends upon the first. Notice that it can be written as the negation of a BCQ: \u00ac\u2203x\u2203y\u2203z(P (x, y) \u2227 P (x, z) \u2227 y 6= z).\nA Datalog query (DQ) Q(x\u0304) is a program \u03a0, consisting of positive definite rules of the form P (t\u0304) \u2190 P1(t\u03041), . . . , Pn(t\u0304n), with the Pi(t\u0304i) atomic formulas, that accesses an underlying extensional database D (the facts). In particular, \u03a0 defines an answer-collecting predicate Ans(x\u0304) by means of a top rule of the form Ans(x\u0304) \u2190 P1(s\u03041), . . . , Pm(s\u0304m), where the Pi on the RHS are defined by other rules in \u03a0 or are database predicates for D. Here, the s\u0304i are lists of variables or constants, and x\u0304 \u2286 \u22c3 i s\u03041.\nWhen \u03a0 \u222a D |= Ans(a\u0304), a\u0304 is an answer to query \u03a0 on D. Here, |= means that the RHS belongs to the minimal model of \u03a0 \u222a D. The Datalog query is Boolean (a BDQ) if the top answer-predicate is propositional, with a definition of the form ans \u2190 P1(s\u03041), . . . , Pm(s\u0304m) [Abiteboul et al., 1995]. CQs can be expressed as DQs."}, {"heading": "3 QA-Causality and its Decision Problems", "text": "Following [Meliou et al., 2010], in the rest of this work, unless otherwise stated, we assume that a relational database instanceD is split in two disjoint sets,D = Dn\u222aDx, where Dn and Dx are the sets of endogenous and exogenous tuples, respectively. The former are admissible, interesting potential causes for query answers; but not the latter. In the rest of this work, whenever a database instance is not explicitly partitioned, we assume all tuples are endogenous.\nA tuple \u03c4 \u2208 Dn is a counterfactual cause for an answer a\u0304 to Q(x\u0304) in D if D |= Q(a\u0304), but D r {\u03c4} 6|= Q(a\u0304). A tuple \u03c4 \u2208 Dn is an actual cause for a\u0304 if there exists \u0393 \u2286 Dn, called a contingency set, such that \u03c4 is a counterfactual cause for a\u0304 in D r \u0393. Causes(D,Q(a\u0304)) denotes the set of actual causes for a\u0304. If Q is Boolean, Causes(D,Q) contains the causes for answer true . We collect all minimal contingency sets associated with \u03c4 \u2208 Dn: Cont(D,Q(a\u0304), \u03c4) := {\u0393 \u2286 Dn | D r \u0393 |= Q(a\u0304), D r (\u0393 \u222a {\u03c4}) 6|= Q(a\u0304), and for all \u0393\u2032 $ \u0393, D r (\u0393\u2032 \u222a {\u03c4}) |= Q(a\u0304)}.\nThe causal responsibility of a tuple \u03c4 for answer a\u0304 is \u03c1Q(a\u0304)(\u03c4) := 1 1+|\u0393| , with \u0393 a smallest contingency set for \u03c4 . When \u03c4 is not an actual cause for a\u0304, \u03c1Q(a\u0304)(\u03c4) := 0.\nQA-causality can be applied to DQs, denoting with Causes(D,\u03a0(a\u0304)) the set of causes for answer a\u0304.\nExample 1. Consider the instance D with a single binary relation E as below. t1-t7 are tuple identifiers (ids). Assume all tuples are endogenous.\nE A B t1 a b t2 b e t3 e d t4 d b t5 c a t6 c b t7 c d\nInstance D can be represented as the directed graph G(V, E) in Figure 1, where V coincides with the active domain of D (i.e. the set of constants in E), and E contains an edge\n(v1, v2) iff E(v1, v2) \u2208 D. Tuple ids are used as labels for the edges in the graph. For simplicity, we refer to the tuples by their ids. Consider the DQ \u03a0 that collects pairs of vertices of G that are connected through a path, and is formed by the rules: Ans(x, y)\u2190 P (x, y). P (x, y)\u2190 E(x, y). and P (x, y)\u2190 P (x, z), E(z, y).\nIt is easy to see that, \u3008c, e\u3009 is an answer to query \u03a0 on D. That is, \u03a0 \u222a D |= Ans(c, e). This is because there are three distinct paths between c and e in G. All tuples except for t3 are actual causes: Causes(E,\u03a0(c, e)) = {t1, t2, t4, t5, t6, t7}, because all of them contribute to at least one path between c and e. Among them, t2 has the highest responsibility, because, t2 is a counterfactual cause for the answer, i.e. it has an empty contingency set.\nThe complexity of the computational and decision problems that arise in QAcausality have been investigated in [Meliou et al., 2010; Salimi & Bertossi, 2015a]. For a Boolean monotone query Q, the causality decision problem (CDP) is (deciding about membership of): CDP(Q) := {(D, \u03c4) | \u03c4 \u2208 Dn, and \u03c4 \u2208 Causes(D,Q)}. It is tractable for UCQs [Salimi & Bertossi, 2015a].\nFor a Boolean monotone query Q, the responsibility decision problem (RDP) is (deciding about membership of): RDP(Q) = {(D, \u03c4, v) | \u03c4 \u2208 Dn, v \u2208 {0} \u222a\n{ 1k | k \u2208 N +}, D |= Q and \u03c1Q(\u03c4) > v}. It is NP-complete for UCQs [Salimi & Bertossi, 2015a].1"}, {"heading": "3.1 View-conditioned causality", "text": "Consider a queryQ withQ(D) = {a\u03041, . . . , a\u0304n}. Fix an answer, say a\u03041 \u2208 Q(D), while the other answers will be used as a condition on a\u03041\u2019s causality. Intuitively, a\u03041 is somehow unexpected, we look for causes, but considering the other answers as \u201ccorrect\u201d, which has the effect of reducing the spectrum of contingency sets, by keeping Q(D)\u2019s extension fixed, as a view extension, modulo a\u03041 [Meliou et al., 2011]. More precisely, if V := Q(D) r {a\u03041}: (a) Tuple \u03c4 \u2208 Dn is a view-conditioned counterfactual cause (vcc-cause) for a\u03041 (in D wrt. V ) if D r {\u03c4} 6|= Q(a\u03041), but Q(D r {\u03c4}) = V . (b) Tuple \u03c4 \u2208 Dn is a view-conditioned actual cause (vc-cause) for a\u03041 if there exists a contingency set, \u0393 \u2286 Dn, such that \u03c4 is a vcc-cause for a\u03041 in D r \u0393 wrt. V . (c) vc-Causes(D,Q(a\u03041)) denotes the set of all vc-causes for a\u03041. (d) The vc-causal responsibility of a tuple \u03c4 for answer a\u03041 is vc-\u03c1Q(a\u03041)(\u03c4) := 1 1+|\u0393| , where |\u0393| is the size of the smallest contingency set that makes \u03c4 a vc-cause for a\u03041. Clearly, vc-Causes(D,Q(a\u0304)) \u2286 Causes(D,Q(a\u0304)), but not necessarily the other way around.\nDefinition 1. (a) The vc-causality decision problem (VCDP) is about membership of VCDP(Q) = {(D, a\u0304, \u03c4) | a\u0304 \u2208 Q(D) and \u03c4 \u2208 vc-Causes(D,Q(a\u0304)) }. (b) The vccausal responsibility decision problem is about membership of VRDP(Q) = {(D, a\u0304, \u03c4, v) | \u03c4 \u2208 Dn, v \u2208 {0} \u222a { 1k | k \u2208 N\n+}, D |= Q(a\u0304) and vc-\u03c1Q(\u03c4) > v}.\nSince leaving the other answers fixed is a strong condition, it makes sense to study the complexity of deciding whether a query answer has a vc-cause or not.\nDefinition 2. For a monotone query Q, the vc-cause existence problem is (deciding about membership of): VCEP(Q) = {(D, a\u0304) | a\u0304 \u2208 Q(D) and vc-Causes(D,Q(a\u0304)) 6= \u2205 }.\n1All the results are in data complexity."}, {"heading": "4 Causality and Abduction", "text": "An abductive explanation for an observation is a formula that, together with a background logical theory (a system description), entails the observation. In database causality we do not have an explicit system description, but just a set of tuples. Something like a system description emerges with a query, and causal relationships between tuples are captured by the combination of atoms in it. With a DQ , we have a specification in terms of positive definite rules.\nA Datalog abduction problem [Eiter et al., 1997] is of the formAP = \u3008\u03a0, E,Hyp, Obs\u3009, where: (a) \u03a0 is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), (c) the hypothesis, Hyp, is a finite set of ground atoms, the abducible atoms,2 and (d) Obs , the observation, is a finite conjunction of ground atoms.\nThe abduction problem is about computing a subset-minimal \u2206 \u2286 Hyp, such that \u03a0 \u222a E \u222a \u2206 |= Obs . In this case, \u2206 is called an abductive diagnosis. So, no proper subset of \u2206 is an abductive diagnosis. Sol(AP) denotes the set of abductive diagnoses for problem AP . Now, a hypothesis h \u2208 Hyp is relevant for AP if h contained in at least one diagnosis of AP , otherwise it is irrelevant. Rel(AP) collects all relevant hypothesis for AP . A hypothesis h \u2208 Hyp is necessary for AP if h contained in all diagnosis of AP . Ness(AP) collects all the necessary hypothesis for AP .\nThe relevance decision problem (RLDP) is about deciding the membership of: RLDP(\u03a0) = {(E ,Hyp,Obs, h) | h \u2208 Rel(AP),with AP = \u3008\u03a0, E,Hyp,Obs\u3009}. The necessity decision problem (NDP) is about deciding the membership of: NDP(\u03a0) = {(E ,Hyp,Obs, h) | h \u2208 Ness(AP),with AP = \u3008\u03a0, E,Hyp,Obs\u3009}. The following results can be obtained adapting results in [Eiter et al., 1997, the. 26] and [Friedrich et al., 1990]: For every Datalog program \u03a0, NDP(\u03a0) is in PTIME (in data); and, for Datalog programs, \u03a0,RLDP(\u03a0) is NP-complete.\nFor a BDQ \u03a0 with \u03a0 \u222a D |= ans , the causality decision problem takes the form: CDP(\u03a0) := {(D, \u03c4) | \u03c4 \u2208 Dn, and \u03c4 \u2208 Causes(D,\u03a0)}. It turns out that, for Datalog system specifications, actual causes for ans can be obtained from abductive diagnoses of the associated causal Datalog abduction problem (CDAP): APc := \u3008\u03a0, Dx, Dn, ans\u3009, where Dx takes the role of the extensional database for \u03a0. Accordingly, \u03a0\u222aDx becomes the background theory, Dn becomes the set of hypothesis, and atom ans is the observation. Proposition 1. For an instance D = Dx \u222aDn and a BDQ \u03a0, with \u03a0\u222aD |= ans , and its associated CDAP APc, the following hold: (a) \u03c4 \u2208 Dn is an counterfactual cause for ans iff \u03c4 \u2208 Ness(APc). (b) \u03c4 \u2208 Dn is an actual cause for ans iff \u03c4 \u2208 Rel(APc).\nExample 2. Consider the instance D with relations R and S as below, and the query \u03a0: ans \u2190 R(x, y), S(y), which is true in D. Assume all tuples are endogenous.\nR A B a1 a4 a2 a1 a3 a3\nS A a1 a2 a3\n2The hypothesis can be all the possible ground instantiations of abducible predicates, which do not appear in rule\u2019s LHSs.\nHere, APc = \u3008\u03a0, \u2205, D, ans\u3009, which has two (minimal) abductive diagnoses: \u22061 = {S(a1), R(a2, a1)} and \u22062 = {S(a3), R(a3, a3)}. Then, Rel(APc) = {S(a3), R(a3, a3), S(a1), R(a2, a1)}. It is clear that the relevant hypothesis are actual causes for ans .\nWe can use the results mentioned above to obtain new complexity results for Datalog QA-causality. First, for the problem of deciding if a tuple is a counterfactual cause for a query answer. This is a tuple that, when removed from the database, undermines the query-answer, without having to remove other tuples, as is the case for actual causes. Actually, for each of the latter there may be an exponential number of contingency sets [Salimi & Bertossi, 2015a]. A counterfactual cause is an actual cause with responsibility 1. The complexity of this problem can be obtained from the connection between counterfactual causation and the necessity of hypothesis in Datalog abduction.\nProposition 2. For BDQs \u03a0, CFDP(\u03a0) := {(D, \u03c4) | \u03c4 \u2208 Dn and \u03c1Q(\u03c4) = 1}. is in PTIME (in data).\nFor BDQs \u03a0, deciding actual causality, i.e. the problem CDP(\u03a0), is NP-complete (in data) [Salimi & Bertossi, 2015b]. The same problem is tractable for UCQs [Salimi & Bertossi, 2015a]. Finally, we establish the complexity of the responsibility problem for DQs.\nProposition 3. For BDQs \u03a0,RDP(\u03a0) is NP-complete."}, {"heading": "5 Causality and View-Updates", "text": "There is a close relationship between QA-causality and the view-update problem in the form of delete-propagation [Abiteboul et al., 1995].\nLet D be a database instance, and Q a monotone query. For a\u0304 \u2208 Q(D), the minimal-source-side-effect deletion-problem is about computing a subset-minimal \u039b \u2286 D, such that a\u0304 /\u2208 Q(D r \u039b).\nNow, following [Buneman et al., 2002], let D be a database instance D, and Q a monotone query: (a) For a\u0304 \u2208 Q(D), the view-side-effect-free deletion-problem is about computing a \u039b \u2286 D, such thatQ(D)r{a\u0304} = Q(Dr\u039b). (b) The view-side-effect-free decision problem is (deciding about the membership of): VSEFP(Q) = {(D, a\u0304) | a\u0304 \u2208 Q(D), and exists D\u2032 \u2286 D with Q(D) r {a\u0304} = Q(D\u2032)}. The latter decision problem is NP-complete for conjunctive queries [Buneman et al., 2002, theorem 2.1].\nConsider a relational instance D, a view V defined by a monotone query Q. Then, the virtual view extension, V(D), is Q(D). For a tuple a\u0304 \u2208 Q(D), the deletepropagation problem, in its most general form, is about deleting a set of tuples from D, and so obtaining a subinstance D\u2032 of D, such that a\u0304 /\u2208 Q(D\u2032). It is natural to expect that the deletion of a\u0304 from Q(D) can be achieved through deletions from D of actual causes for a\u0304 (to be in the view extension). However, to obtain solutions to the different variants of this problem, different combinations of actual causes must be considered [Salimi & Bertossi, 2015b].\nIn particular, in [Salimi & Bertossi, 2015b], it has been shown that actual causes of a\u0304 with their minimal contingency sets are in correspondence with the solutions to the minimal-source-side-effect deletion-problem of a\u0304.\nNow, in order to check if there exists a solution to the view-side-effect-free deletionproblem for a\u0304 \u2208 V(D), it is good enough to check if a\u0304 has a view-conditioned cause. Actually, it holds [Salimi & Bertossi, 2015b]: For an instance D, a view V defined by a monotone query Q with Q(D) = {a\u03041, . . . , a\u0304n}, and a\u0304k \u2208 Q(D), (D, a\u0304k) \u2208 VSEFP(Q) iff vc-Causes(D,Q(a\u0304k)) 6= \u2205.\nWe now consider the complexity of the view-conditioned causality problem (cf. Definition 1). By appealing to the connection between vc-causality and delete-propagation, we obtain for the vc-cause existence problem (cf. Definition 2): For CQs Q, VCEP(Q) is NP-complete (in data) [Salimi & Bertossi, 2015b]. A polynomial-time Turing (or Cook) reduction from this problem allows us to obtain the next result about deciding vc-causality (cf. Definition 1).\nProposition 4. For CQs Q, VCDP(Q) is NP-complete. By a (Karp) reduction from this problem, we settle the complexity of the vccausality responsibility problem for conjunctive queries.\nProposition 5. For CQs Q, VRDP(Q) is NP-complete. These results on vc-causality also hold for UCQs."}, {"heading": "6 QA-Causality under Integrity Constraints", "text": "To motivate a definition of QA-causality in the presence of integrity constraints (ICs), we start with some remarks.\nInterventions are at the base of Halpern & Pearl\u2019s approach to causality [Halpern & Pearl, 2005], i.e. actions on the model that define counterfactual scenarios. In databases, they take the form of tuple deletions. If a database D satisfies a prescribed set of integrity constraints (ICs), the instances obtained from D by tuple deletions, as used to determine causes, should be expected to satisfy the ICs.\nOn a different side, QA-causality in [Meliou et al., 2010] is insensitive to equivalent query rewriting (as first pointed out in [Glavic & Miller, 2011]): QA-causes coincide for logically equivalent queries. However, QA-causality might be sensitive to equivalent query rewritings in the presence of ICs, as the following example shows.\nExample 3. Let S = {Dep(DName, TStaff ), Course(CName,LName,DName)} be relational schema with inclusion dependency\nI : \u2200x\u2200y (Dep(x, y)\u2192 \u2203u Course(u, y, x));\nand instance D for S:\nDep DName TStaff t1 Computing John t2 Philosophy Patrick t3 Math Kevin\nCourse CName LName DName t4 Com08 John Computing t5 Math01 Kevin Math t6 Hist02 Patrick Philosophy t7 Math08 Eli Math t8 Com01 John Computing\nClearly, D |= I . Now, consider the CQ that collects the teaching staff who are lecturing in the department they are associated with:\nQ(TStaff ) \u2190 Dep(DName,TStaff ), (1) Course(CName,TStaff ,DName).\nHere, Q(D) = {John,Patrick ,Kevin}. Answer \u3008John\u3009 has the actual causes: t1, t4 and t8. t1 is a counterfactual cause, t4 has a single minimal contingency set \u03931 = {t8}; and t8 has a single minimal contingency set \u03932 = {t4}.\nNow, in the presence of IC I ,Q is equivalent with the following queryQ\u2032: (denoted Q \u2261{I} Q\u2032, and meaning they give the same answers for every instance that satisfies I)\nQ\u2032(TStaff ) \u2190 Dep(DName,TStaff )). In particular, \u3008John\u3009 is still an answer to Q\u2032 from D. However, on the basis of query Q\u2032 and instance D alone, there is single cause, t1, which is also a counterfactual cause.\nDefinition 3. Given an instanceD = Dn\u222aDx that satisfies a set \u03a3 of ICs, i.e. D |= \u03a3, and a monotone query Q with D |= Q(a\u0304), a tuple \u03c4 \u2208 Dn is an actual cause for a\u0304 under \u03a3 if there is \u0393 \u2286 Dn, such that: (a) D r \u0393 |= Q(a\u0304), and (b) D r \u0393 |= \u03a3. (c) D r (\u0393 \u222a {t}) 6|= Q(a\u0304), and (d) D r (\u0393 \u222a {t}) |= \u03a3.\nCauses(D,Q(a\u0304),\u03a3) denotes the set of actual causes for a\u0304 under \u03a3.\nExample 4. (ex. 3 cont.) Consider answer \u3008John\u3009 toQ, for which t4 was a cause with minimal contingency set \u03931 = {t8}. It holds D r \u03931 |= I , but D r (\u03931 \u222a {t2}) 6|= I . So, the new definition does not allow t4 to be an actual cause for answer \u3008John\u3009 to Q. Actually, Q and Q\u2032 have the same actual causes for answer \u3008John\u3009 under I , namely t1.\nSince functional dependencies (FDs) are never violated by tuple deletions, they have no effect on the set of causes for a query answer. Actually, this applies to all denial constraints (DCs), i.e. of the form \u00ac\u2200x\u0304(A1(x\u03041) \u2227 \u00b7 \u00b7 \u00b7 \u2227 An(x\u0304n)), with Ai a database predicate or a built-in.\nProposition 6. Given an instance D, a monotone query Q, and a set of ICs \u03a3, the following hold: (a) Causes(D,Q(a\u0304),\u03a3) \u2286 Causes(D,Q(a\u0304)). (b) Causes(D,Q(a\u0304), \u2205) = Causes(D,Q(a\u0304)). (c) When \u03a3 consists of DCs, Causes(D,Q(a\u0304),\u03a3) = Causes(D,Q(a\u0304)). (d) For a monotone query Q\u2032 with Q\u2032 \u2261\u03a3 Q: Causes(D,Q(a\u0304),\u03a3) = Causes(D, Q\u2032(a\u0304),\u03a3).\n(e) For a monotone query Q\u2032 which is minimally contained in Q with Q\u2032 \u2261\u03a3 Q:3 Causes(D,Q(a\u0304),\u03a3) = Causes(D,Q\u2032(a\u0304)).\n3This meansQ\u2032 \u2286 Q and there is noQ\u2032\u2032 withQ\u2032\u2032 $ Q\u2032 andQ\u2032\u2032 \u2261\u03a3 Q.\nNotice that item (e) here relates to the rewriting of the query in Example 3. Notice that this rewriting resembles the resolution-based rewritings used in semantic query optimization [Chakravarthy et al., 1990].\nSince FDs have no effect on causes, the causality decision problems in the presence of FDs have the same complexity upper bound as causality without FDs. For example, for \u03a3 a set of FDs, RDP(Q,\u03a3), the responsibility problem now under FDs, is NP-complete (as it was without ICs [Salimi & Bertossi, 2015a]). However, when an instance satisfies a set of FDs, the decision problems may become tractable depending on the query structure. For example, for the class of key-preserving CQs, deciding responsibility over instances that satisfy the key constraints (KCs) is in PTIME [Cibele et al., 2016]. A KC is a particular kind of FD where some of the predicate attributes functionally determine all the others. Given a set \u03ba of KCs, a CQ is key-preserving if, whenever an instance D satisfies \u03ba, all key attributes of base relations involved in Q are included among the attributes of Q.\nBy appealing to the connection between vc-causality and delete-propagation [Salimi & Bertossi, 2015b], vc-responsibility under KCs is tractable (being intractable in general, because the problem without KCs already is, as shown in Proposition 5):\nProposition 7. Given a set \u03ba of KCs, and a key-preserving CQ query Q, deciding VRDP(Q, \u03ba) is in PTIME.\nNew subclasses of (view-defining) CQs for which different variants of delete-propagation are tractable are introduced in [Kimelfeld, 2012; Kimelfeld et al., 2012] (generalizing those in [Cong et al., 2006]). The established connections between deletepropagation and causality should allow us to adopt them for the latter.\nQA-causality under ICs can capture vc-causality:\nProposition 8. For a conjunctive query Q(x\u0304) \u2208 L(S), and an instance D for S, with Q(D) = {a\u03041, . . . , a\u0304n} and a fixed k \u2208 {1, . . . , n}, there is a set of inclusion dependencies \u03a3 over schema S\u222a{V }, with V a fresh |x\u0304|-ary predicate, and an instance D\u2032 for S \u222a {V }, such that vc-Causes(D,Q(a\u0304k)) = Causes(D\u2032,Q(a\u0304),\u03a3).\nDeciding causality in the absence of ICs is tractable, but their presence has an impact on this problem. The following is obtained from Propositions 4 and 8.\nProposition 9. For CQs Q and a set \u03a3 of inclusion dependencies, Q, CDP(Q,\u03a3) is NP-complete.\nSome ICs may be implicative, which makes it tempting to give them a causal semantics. For example, in [Roy & Suciu, 2014] and more in the context of interventions for explanations, a ground instantiation, Pi(t\u0304i) \u2192 Pj(t\u0304j), of an inclusion dependency is regarded a causal dependency of Pj(t\u0304j) upon Pi(t\u0304i). On this basis, a valid intervention removes Pj(t\u0304j) whenever Pi(t\u0304i) is removed from the instance.\nGiving to ICs a causal connotation is controversial. Actually, according to [Halpern & Hitchcock, 2010] logical dependencies are not causal dependencies per se. Our approach is consistent with this view. Even more, we should point out that there are different ways of seeing ICs, and they could have an impact on the notion of cause. For example, according to [Reiter, 1992], ICs are \u201cepistemic in nature\u201d, in the sense that rather than being statements about the domain represented by a database (or knowledge\nbase), they are statement about the contents of the database, or about what it knows (cf. [Reiter, 1992] for a discussion).\nAbduction has been applied to view-updates [Kakas & Mancarella, 1990], with ICs on the base relations [Console et al., 1995]. On the other side, we have connected QAcausality with both abduction and view-updates. We briefly illustrate using our ongoing example how the approach in [Console et al., 1995] can be used to determine viewupdates in the presence of ICs, which should have an impact on the characterization and computation of causes, now under ICs.\nExample 5. (ex. 3 cont.) Formulated as a view-update problem on a Datalog setting, we have the query (1) defining an intensional predicate, Q(TStaff ). The tuples in the underlying database are all considered to be abducible. The view-update request is the deletion of Q(John).\nAccording to [Console et al., 1995], the potential abductive explanations are maximal subsets E of the original instance D, such that R plus rule (1) does not entail Q(John) anymore. They are: E1 = D r {t1}, and E2 = D r {t4, t8}, and are determined by finding minimal abductive explanations for Q(John). However, without considering the IC I .\nNow, these explanations have to be examined at the light of the ICs. In this case, E1 does satisfy I , but this is not the case for E2. So, the latter is rejected. As a consequence, the only admissible update is the deletion of t1 from D.\nThe admissible (and minimal) view-updates could be used to define actual causes under ICs. In this case, and according to Section 5, the admissible view-update (under ICs) should be in correspondence, by definition, with an admissible and minimal combination of an actual cause and one of its contingency sets. This would make t1 the only actual cause (also counterfactual) for \u3008John\u3009 under I , which corresponds with the result obtained following our direct definition."}, {"heading": "7 Conclusions", "text": "In combination with the results reported in [Salimi & Bertossi, 2015a], we can see that there are deeper and multiple connections between the areas of QA-causality, abductive and consistency-based diagnosis, view updates, and database repairs. Abduction has also been explicitly applied to database repairs [Arieli et al., 2004]. The idea, again, is to \u201cabduce\u201d possible repair updates that bring the database to a consistent state. Connections between consistency-based and abductive diagnosis have been established, e.g. in [Console & Torasso, 1991]. Exploring and exploiting all the possible connections is matter of ongoing and future research.\nAcknowledgments: Research funded by NSERC DG (250279), and the NSERC Strategic Network on Business Intelligence (BIN)."}], "references": [{"title": "Coherent Integration of Databases by Abductive Logic Programming", "author": ["Arieli et al", "O. 2004] Arieli", "M. Denecker", "B. Van Nuffelen", "M. Bruynooghe"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "al. et al\\.,? \\Q2004\\E", "shortCiteRegEx": "al. et al\\.", "year": 2004}, {"title": "On Propagation of Deletions and Annotations Through Views", "author": ["Buneman et al", "P. 2002] Buneman", "S. Khanna", "W.C. Tan"], "venue": "Proc. PODS,", "citeRegEx": "al. et al\\.,? \\Q2002\\E", "shortCiteRegEx": "al. et al\\.", "year": 2002}, {"title": "A Characterization of the Complexity of Resilience and Responsibility for Conjunctive Queries", "author": ["Cibele et al", "F. 2016] Cibele", "W. Gatterbauer", "N. Immerman", "Meliou A"], "venue": "PVLDB, 2016,", "citeRegEx": "al. et al\\.,? \\Q2016\\E", "shortCiteRegEx": "al. et al\\.", "year": 2016}, {"title": "A Spectrum of Logical Definitions of Model-Based Diagnosis", "author": ["Console", "Torasso", "L. 1991] Console", "P. Torasso"], "venue": "Comput. Intell.,", "citeRegEx": "Console et al\\.,? \\Q1991\\E", "shortCiteRegEx": "Console et al\\.", "year": 1991}, {"title": "Annotation Propagation Revisited for Key Preserving Views", "author": ["Cong et al", "G. 2006] Cong", "W. Fan", "F. Geerts"], "venue": "Proc. CIKM,", "citeRegEx": "al. et al\\.,? \\Q2006\\E", "shortCiteRegEx": "al. et al\\.", "year": 2006}, {"title": "On the Relationship between Abduction and Deduction", "author": ["Console et al", "L. 1991] Console", "D. Theseider-Dupre", "P. Torasso"], "venue": "J. Log. Comput.,", "citeRegEx": "al. et al\\.,? \\Q1991\\E", "shortCiteRegEx": "al. et al\\.", "year": 1991}, {"title": "The Role of Abduction in Database View Updating", "author": ["Console et al", "L. 1995] Console", "Sapino M. L", "D. Theseider-Dupre"], "venue": "J. Intell. Inf. Syst.,", "citeRegEx": "al. et al\\.,? \\Q1995\\E", "shortCiteRegEx": "al. et al\\.", "year": 1995}, {"title": "Abduction from Logic Programs: Semantics and Complexity", "author": ["Eiter et al", "T. 1997] Eiter", "G. Gottlob", "N. Leone"], "venue": "Theor. Comput. Sci.,", "citeRegEx": "al. et al\\.,? \\Q1997\\E", "shortCiteRegEx": "al. et al\\.", "year": 1997}, {"title": "Hypothesis Classification, Abductive Diagnosis and Therapy", "author": ["Friedrich et al", "G. 1990] Friedrich", "Gottlob. G", "W. Nejdl"], "venue": "Proc. Internat. Workshop on Expert Systems in Engineering,", "citeRegEx": "al. et al\\.,? \\Q1990\\E", "shortCiteRegEx": "al. et al\\.", "year": 1990}, {"title": "Reexamining Some Holy Grails of Data Provenance", "author": ["Glavic", "Miller", "B. 2011] Glavic", "R.J. Miller"], "venue": "Proc. Theory and Practice of Provenance (TaPP),", "citeRegEx": "Glavic et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Glavic et al\\.", "year": 2011}, {"title": "Causes and Explanations: A Structural-Model Approach: Part 1", "author": ["Halpern", "Pearl", "Y.J. 2005] Halpern", "J. Pearl"], "venue": "British J. Philosophy of Science,", "citeRegEx": "Halpern et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Halpern et al\\.", "year": 2005}, {"title": "Actual Causation and The Art of Modelling. In Causality, Probability, and Heuristics: A Tribute to Judea Pearl", "author": ["Halpern", "Hitchcock", "J.Y. 2010] Halpern", "C.R. Hitchcock"], "venue": "College Publications,", "citeRegEx": "Halpern et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Halpern et al\\.", "year": 2010}, {"title": "Database Updates through Abduction", "author": ["Kakas", "Mancarella", "1990] Kakas A. C", "P. Mancarella"], "venue": "Proc. VLDB,", "citeRegEx": "Kakas et al\\.,? \\Q1990\\E", "shortCiteRegEx": "Kakas et al\\.", "year": 1990}, {"title": "A Dichotomy in the Complexity of Deletion Propagation with Functional Dependencies", "author": ["B. Kimelfeld"], "venue": "[Kimelfeld,", "citeRegEx": "Kimelfeld,? \\Q2012\\E", "shortCiteRegEx": "Kimelfeld", "year": 2012}, {"title": "Maximizing Conjunctive Views in Deletion Propagation", "author": ["Kimelfeld et al", "B. 2012] Kimelfeld", "J. Vondrak", "R. Williams"], "venue": "ACM TODS,", "citeRegEx": "al. et al\\.,? \\Q2012\\E", "shortCiteRegEx": "al. et al\\.", "year": 2012}, {"title": "The Complexity of Causality and Responsibility for Query Answers and Non-Answers", "author": ["Meliou et al", "A. 2010] Meliou", "Gatterbauer", "K.F.W. Moore", "D. Suciu"], "venue": "Proc. VLDB,", "citeRegEx": "al. et al\\.,? \\Q2010\\E", "shortCiteRegEx": "al. et al\\.", "year": 2010}, {"title": "Tracing Data Errors with View-Conditioned Causality", "author": ["Meliou et al", "A. 2011] Meliou", "Gatterbauer", "S. Nath", "D. Suciu"], "venue": "Proc. SIGMOD,", "citeRegEx": "al. et al\\.,? \\Q2011\\E", "shortCiteRegEx": "al. et al\\.", "year": 2011}, {"title": "Logic-Based Approach to Semantic Query Optimization", "author": ["Chakravarthy et al", "U.S. 1990] Chakravarthy", "J. John Grant", "J. Minker"], "venue": "ACM Trans. Database Syst.,", "citeRegEx": "al. et al\\.,? \\Q1990\\E", "shortCiteRegEx": "al. et al\\.", "year": 1990}, {"title": "A Theory of Diagnosis from First Principles", "author": ["Reiter", "R. 1987] Reiter"], "venue": "Artificial Intelligence,", "citeRegEx": "Reiter and Reiter,? \\Q1987\\E", "shortCiteRegEx": "Reiter and Reiter", "year": 1987}, {"title": "A Formal Approach to Finding Explanations for Database Queries", "author": ["Roy", "Suciu", "S. 2014] Roy", "D. Suciu"], "venue": "Proc. SIGMOD,", "citeRegEx": "Roy et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Roy et al\\.", "year": 2014}, {"title": "From Causes for Database Queries to Repairs and Model-Based Diagnosis and Back", "author": ["Salimi", "Bertossi", "B. 2015a] Salimi", "L. Bertossi"], "venue": "Proc. ICDT,", "citeRegEx": "Salimi et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Salimi et al\\.", "year": 2015}, {"title": "Query-Answer Causality in Databases: Abductive Diagnosis and View-Updates", "author": ["Salimi", "Bertossi", "B. 2015b] Salimi", "L. Bertossi"], "venue": "Proc. UAI\u201915 Workshop on Causal Inference, CEUR-WS Proc.,", "citeRegEx": "Salimi et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Salimi et al\\.", "year": 2015}], "referenceMentions": [{"referenceID": 3, "context": "In [Salimi & Bertossi, 2015b] connections between QAcausality and abductive diagnosis [Console et al., 1991; Eiter et al., 1997] were presented.", "startOffset": 86, "endOffset": 128}, {"referenceID": 13, "context": "When only deletions are performed on monotone views, we have the deletepropagation problem, from views to base relations [Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012].", "startOffset": 121, "endOffset": 184}, {"referenceID": 13, "context": "New subclasses of (view-defining) CQs for which different variants of delete-propagation are tractable are introduced in [Kimelfeld, 2012; Kimelfeld et al., 2012] (generalizing those in [Cong et al.", "startOffset": 121, "endOffset": 162}], "year": 2016, "abstractText": "Causality has been recently introduced in databases, to model, characterize and possibly compute causes for query results (answers). Connections between queryanswer causality, consistency-based diagnosis, database repairs (wrt. integrity constraint violations), abductive diagnosis and the view-update problem have been established. In this work we further investigate connections between query-answer causality and abductive diagnosis and the view-update problem. In this context, we also define and investigate the notion of query-answer causality in the presence of integrity constraints.", "creator": "LaTeX with hyperref package"}}}