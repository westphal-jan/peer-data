{"id": "1603.09502", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "31-Mar-2016", "title": "Verifiability of Argumentation Semantics", "abstract": "dung's abstract argumentation theory is a widely used formalism to model conflicting information and to draw conclusions in explicitly such situations. hereby, the knowledge is represented by so - called argumentation frameworks ( afs ) informally and afterwards the reasoning is done via semantics extracting acceptable sets. all their reasonable semantics are based on the notion of conflict - freeness which means that arguments are only jointly partly acceptable when they are not linked within the af. in this paper, we study the question which information on top of conflict - free sets is needed to compute extensions of a semantics criterion at hand. we introduce a hierarchy calculus of so - called verification classes thus specifying the required amount of information. we show that certainly well - known standard semantics are exactly verifiable through a certain such class. our framework also gives a means to study semantics lying inbetween known semantics, thus contributing to a more abstract understanding of the different features general argumentation semantics offer.", "histories": [["v1", "Thu, 31 Mar 2016 09:29:02 GMT  (102kb,D)", "http://arxiv.org/abs/1603.09502v1", "Contribution to the 16h International Workshop on Non-Monotonic Reasoning, 2016, Cape Town"]], "COMMENTS": "Contribution to the 16h International Workshop on Non-Monotonic Reasoning, 2016, Cape Town", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["ringo baumann", "thomas linsbichler", "stefan woltran"], "accepted": false, "id": "1603.09502"}, "pdf": {"name": "1603.09502.pdf", "metadata": {"source": "CRF", "title": "Verifiability of Argumentation Semantics\u2217", "authors": ["Ringo Baumann", "Thomas Linsbichler", "Stefan Woltran"], "emails": [], "sections": [{"heading": "Introduction", "text": "In the late 1980s the idea of using argumentation to model nonmonotonic reasoning emerged (see (Loui 1987; Pollock 1987) as well as (Prakken and Vreeswijk 2002) for excellent overviews). Nowadays argumentation theory is a vibrant subfield of Artificial Intelligence, covering aspects of knowledge representation, multi-agent systems, and also philosophical questions. Among other approaches which have been proposed for capturing representative patterns of inference in argumentation theory (Besnard et al. 2014), Dung\u2019s abstract argumentation frameworks (AFs) (Dung 1995) play an important role within this research area. At the heart of Dung\u2019s approach lie the so-called argumentation semantics (cf. (Baroni, Caminada, and Giacomin 2011) for an excellent overview). Given an AF F , which is set-theoretically just a directed graph encoding arguments and attacks between them, a certain argumentation semantics \u03c3 returns acceptable sets of arguments \u03c3(F ), so-called \u03c3-extensions. Each of these sets represents a reasonable position w.r.t. F and \u03c3.\nOver the last 20 years a series of abstract argumentation semantics were introduced. The motivations of these semantics range from the desired treatment of specific examples to \u2217This research has been supported by DFG (project BR 1817/7- 1) and FWF (projects I1102 and P25521).\nfulfilling a number of abstract principles. The comparison via abstract criteria of the different semantics available is a topic which emerged quite recently in the community ((Baroni and Giacomin 2007b) can be seen as the first paper in this line). Our work takes a further step towards a comprehensive understanding of argumentation semantics. In particular, we study the following question: Do we really need the entire AF F to compute a certain argumentation semantics \u03c3? In other words, is it possible to unambiguously determine acceptable sets w.r.t. \u03c3, given only partial information of the underlying framework F . In order to solve this problem let us start with the following reflections:\n1. As a matter of fact, one basic requirement of almost all existing semantics1 is that of conflict-freeness, i.e. arguments within a reasonable position are not allowed to attack each other. Consequently, knowledge about conflict-free sets is an essential part for computing semantics.\n2. The second step is to ask the following: Which information on top on conflict-free sets has to be added? Imagine the set of conflict-free sets given by {\u2205, {a}, {b}}. Consequently, there has to be at least one attack between a and b. Unfortunately, this information is not sufficient to compute any standard semantics (except naive extensions, which are defined as \u2286-maximal conflict-free sets) since we know nothing precise about the neighborhood of a and b. The following three AFs possess exactly the mentioned conflict-free sets, but differ with respect to other\naF : b aG : b aH : b\n3. The final step is to try to minimize the added information. That is, which kind of knowledge about the neighborhood is somehow dispensable in the light of computation? Clearly, this will depend on the considered semantics. For instance, in case of stage semantics (Verheij 1996), which requests conflict-free sets of maximal range, we do not need any information about incoming attacks. This information can not be omitted in case of admissible-based semantics since incoming attacks require counterattacks.\nThe above considerations motivate the introduction of socalled verification classes specifying a certain amount of\n1See (Jakobovits and Vermeir 1999; Arieli 2012; Grossi and Modgil 2015) for exemptions.\nar X\niv :1\n60 3.\n09 50\n2v 1\n[ cs\n.A I]\n3 1\nM ar\n2 01\n6\ninformation. In a first step, we study the relation of these classes to each other. We therefore introduce the notion of being more informative capturing the intuition that a certain class can reproduce the information of an other. We present a hierarchy w.r.t. this ordering. The hierarchy contains 15 different verification classes only. This is due to the fact that many syntactically different classes collapse to the same amount of information.\nWe then formally define the essential property of a semantics \u03c3 being verifiable w.r.t. a certain verification class. We present a general theorem stating that any rational semantics is exactly verifiable w.r.t. one of the 15 different verification classes. Roughly speaking, a semantics is rational if attacks inbetween two self-loops can be omitted without affecting the set of extensions. An important aside hereby is that even the most informative class contains indeed less information than the entire framework by itself.\nIn this paper we consider a representative set of standard semantics. All of them satisfy rationality and thus, are exactly verifiable w.r.t. a certain class. Since the theorem does not provide an answer to which verification class perfectly matches a certain rational semantics we study this problem one by one for any considered semantics. As a result, only 6 different classes are essential to classify the considered standard semantics.\nIn the last part of the paper we study an application of the concept of verifiability. More precisely, we address the question of strong equivalence for semantics lying inbetween known semantics, so-called intermediate semantics. Strong equivalence is the natural counterpart to ordinary equivalence in monotonic theories (see (Oikarinen and Woltran 2011; Baumann 2016) for abstract argumentation and (Maher 1986; Lifschitz, Pearce, and Valverde 2001; Turner 2004; Truszczynski 2006) for other nonmonotonic theories). We provide characterization theorems relying on the notion of verifiability and thus, contributing to a more abstract understanding of the different features argumentation semantics offer. Besides these main results, we also give new characterizations for strong equivalence with respect to naive extensions and strong admissible sets."}, {"heading": "Preliminaries", "text": "An argumentation framework (AF) F = (A,R) is a directed graph whose nodes A \u2286 U (with U being an infinite set of arguments, so-called universe) are interpreted as arguments and whose edges R \u2286 A \u00d7 A represent conflicts between them. We assume that all AFs possess finitely2 many arguments only and denote the collection of all AFs by A . If (a, b) \u2208 R we say that a attacks b. Alternatively, we write a b as well as, for some S \u2286 A, a S or S b if there is some c \u2208 S attacked by a or attacking b, respectively. An argument a \u2208 A is defended by a set S \u2286 A if for each b \u2208 A with b a, S b. We define the range of S (in F ) as S+F = S \u222a {a | S a}. Similarly, we use S \u2212 F to denote the anti-range of S (in F ) as S \u222a {a | a S}. Furthermore, 2Finiteness of AFs is a common assumption in argumentation papers. A systematic study of the infinite case has begun quite recently (cf. (Baumann and Spanring 2015) for an overview).\nwe say that a set S is conflict-free (in F ) if there is no argument a \u2208 S s.t. S a. The set of all conflict-free sets of an AF F is denoted by cf(F ). For an AF F = (B,S) we use A(F ) and R(F ) to refer to B and S, respectively. Furthermore, we use L(F ) = {a | (a, a) \u2208 R(F )} for the set of all self-defeating arguments. Finally, we introduce the union of AFs F and G as F \u222aG = (A(F ) \u222aA(G), R(F ) \u222aR(G))."}, {"heading": "Semantics", "text": "A semantics \u03c3 assigns to each F = (A,R) a set \u03c3(F ) \u2286 2A where the elements are called \u03c3-extensions. Numerous semantics are available. Each of them captures different intuitions about how to reason about conflicting knowledge. We consider \u03c3 \u2208 {ad, na, stb, pr, co, gr, ss, stg, id, eg} for admissible, naive, stable, preferred, complete, grounded, semi-stable, stage, ideal, and eager semantics (Dung 1995; Caminada, Carnielli, and Dunne 2012; Verheij 1996; Dung, Mancarella, and Toni 2007; Caminada 2007).\nDefinition 1. Given an AF F = (A,R) and let S \u2286 A. 1. S \u2208 ad(F ) iff S \u2208 cf(F ) and each a \u2208 S is defended\nby S, 2. S \u2208 na(F ) iff S \u2208 cf(F ) and there is no S\u2032 \u2208 cf(F ) s.t. S ( S\u2032,\n3. S \u2208 stb(F ) iff S \u2208 cf(F ) and S+F = A, 4. S \u2208 pr(F ) iff S \u2208 ad(F ) and there is no S\u2032 \u2208 ad(F ) s.t. S ( S\u2032,\n5. S \u2208 co(F ) iff S \u2208 ad(F ) and for any a \u2208 A defended by S, a \u2208 S, 6. S \u2208 gr(F ) iff S \u2208 co(F ) and there is no S\u2032 \u2208 co(F ) s.t. S\u2032 ( S, 7. S \u2208 ss(F ) iff S \u2208 ad(F ) and there is no S\u2032 \u2208 ad(F ) s.t. S+F ( S \u2032+ F , 8. S \u2208 stg(F ) iff S \u2208 cf(F ) and there is no S\u2032 \u2208 cf(F ) s.t. S+F ( S \u2032+ F ,\n9. S \u2208 id(F ) iff S \u2208 ad(F ), S \u2286 \u22c2 pr(F ) and there is no\nS\u2032 \u2208 ad(F ) satisfying S\u2032 \u2286 \u22c2 pr(F ) s.t. S ( S\u2032,\n10. S \u2208 eg(F ) iff S \u2208 ad(F ), S \u2286 \u22c2\nss(F ) and there is no S\u2032 \u2208 ad(F ) satisfying S\u2032 \u2286 \u22c2 ss(F ) s.t. S ( S\u2032.\nFor two semantics \u03c3, \u03c4 we use \u03c3 \u2286 \u03c4 to indicate that \u03c3(F ) \u2286 \u03c4(F ) for each AF F \u2208 A . If we have \u03c1 \u2286 \u03c3 and \u03c3 \u2286 \u03c4 for semantics \u03c1, \u03c3, \u03c4 , we say that \u03c3 is \u03c1-\u03c4 -intermediate. Well-known relations between semantics are stb \u2286 ss \u2286 pr \u2286 co \u2286 ad, meaning, for instance, that ss is stb-pr - intermediate.\nDefinition 2. We call a semantics \u03c3 rational if self-loopchains are irrelevant. That is, for every AF F it holds that \u03c3(F ) = \u03c3(F l), where F l = (A(F ), R(F ) \\ {(a, b) \u2208 R(F ) | (a, a), (b, b) \u2208 R(F ), a 6= b}).\nIndeed, all semantics introduced in Definition 1 are rational. A prominent semantics that is based on conflict-free sets, but is not rational is the cf2-semantics (Baroni, Giacomin, and Guida 2005), since here chains of self-loops can have an influence on the SCCs of an AF (see also (Gaggl and Woltran 2013))."}, {"heading": "Equivalence and Kernels", "text": "The following definition captures the two main notions of equivalence available for non-monotonic formalisms, namely ordinary (or standard) equivalence and strong (or expansion) equivalence. A detailed overview of equivalence notion including their relations to each other can be found in (Baumann and Brewka 2013; Baumann and Brewka 2015).\nDefinition 3. Given a semantics \u03c3. Two AFs F and G are\n\u2022 standard equivalent w.r.t. \u03c3 (F \u2261\u03c3 G) iff \u03c3(F ) = \u03c3(G), \u2022 expansion equivalent w.r.t. \u03c3 (F \u2261\u03c3E G) iff for all AFs H : F \u222aH \u2261\u03c3 G \u222aH Expansion equivalence can be decided syntactically via so-called kernels (Oikarinen and Woltran 2011). A kernel is a function k : A 7\u2192 A mapping each AF F to another AF k(F ) (which we may also denote as F k ). Consider the following definitions.\nDefinition 4. Given an AF F = (A,R) and a semantics \u03c3. We define \u03c3-kernels F k(\u03c3) = ( A,Rk(\u03c3) ) whereby\nRk(stb) = R \\ {(a, b) | a 6= b, (a, a) \u2208 R}, Rk(ad) = R \\ {(a, b) | a 6= b, (a, a) \u2208 R, {(b, a), (b, b)} \u2229R 6= \u2205}, Rk(gr) = R \\ {(a, b) | a 6= b, (b, b) \u2208 R, {(a, a), (b, a)} \u2229R 6= \u2205}, Rk(co) = R \\ {(a, b) | a 6= b, (a, a), (b, b) \u2208 R}.\nWe say that a relation \u2261 \u2286 A \u00d7 A is characterizable through kernels if there is a kernel k , s.t. F \u2261 G iff F k = Gk. Moreover, we say that a semantics \u03c3 is compatible with a kernel k if F \u2261\u03c3E G iff F k = Gk. All semantics (except naive semantics) considered in this paper are compatible with one of the four kernels introduced above. In the next section, we will complete these results taking naive semantics and strong admissible sets into account.\nTheorem 1. (Oikarinen and Woltran 2011; Baumann and Woltran 2014) For any AFs F and G ,\n1. F \u2261\u03c3E G \u21d4 F k(\u03c3) = Gk(\u03c3) with \u03c3 \u2208 {stb, ad, co, gr}, 2. F \u2261\u03c4E G \u21d4 F k(ad) = Gk(ad) with \u03c4 \u2208 {pr , id , ss, eg}, 3. F \u2261stgE G \u21d4 F k(stb) = Gk(stb)."}, {"heading": "Complementing Previous Results", "text": "In order to provide an exhaustive analysis of intermediate semantics (confer penultimate section) we provide missing kernels for naive semantics as well as strongly admissible sets. We start with the so-called naive kernel characterizing expansion equivalence w.r.t. naive semantics. As an aside, the following kernel is the first one which adds attacks to the former attack relation.\nDefinition 5. Given an AF F = (A,R). We define the naive kernel F k(na) = ( A,Rk(na) ) whereby Rk(na) = R \u222a {(a, b) | a 6= b, {(a, a), (b, a), (b, b)} \u2229R 6= \u2205} . The following example illustrates the definition above.\nExample 1. Consider the AFs F and G . Note that na(F ) = na (G) = {{a, c}, {a, d}}. Consequently, F \u2261na G .\naF : b c d\naG : b c d\nIn accordance with Definition 5 we observe that both AFs possess the same naive kernel H = F k(na) = Gk(na).\naH : b c d\nThe following theorem proves that possessing the same kernels is necessary as well as sufficient for being strongly equivalent, i.e. F \u2261naE G . Theorem 2. For all AFs F ,G ,\nF \u2261naE G \u21d4 F k(na) = Gk(na). Proof. In (Baumann and Woltran 2014) it was already shown that F \u2261naE G iff jointly A(F ) = A(G) and na(F ) = na(G). Consequently, it suffices to prove that F k(na) = Gk(na) implies A(F ) = A(G) as well as na(F ) = na(G) and vice versa.\n(\u21d0) Given F k(na) = Gk(na). By Definition 5 we immediately haveA(F ) = A(G). Assume now that na(F ) 6= na(G) and without loss of generality let S \u2208 na(F ) \\ na(G). Obviously, for any AF H , cf(H ) = cf ( H k(na) ) . Hence, there is an S\u2032, s.t. S ( S\u2032 \u2208 cf(G) \\ cf(F ). Thus, there are a, b \u2208 S\u2032 \\ S, s.t. (a, b) \u2208 R(F ) \\ R(G). Furthermore, (a, a), (b, b) /\u2208 R(G) and since for any AF H , L(H ) = L ( H k(na) ) we obtain (a, a), (b, b) /\u2208 R(F ). Consequently, we have to consider a 6= b. Since (a, b) \u2208 R(F ) \\ R(G), we obtain (a, b), (b, a) \u2208 R ( F k(na) ) . Since F k(na) = Gk(na)\nis assumed we derive (a, b), (b, a) \u2208 R ( Gk(na) ) . By Definition 5 we must have (b, a) \u2208 R(G) contradicting the conflict-freeness of S\u2032 in G .\n(\u21d2) We show the contrapositive, i.e. F k(na) 6= Gk(na) implies A(F ) 6= A(G) or na(F ) 6= na(G). Observe that for any AF H , A(H ) = A ( H k(na) ) . Consequently, if\nA ( F k(na) ) 6= A ( Gk(na) ) , then A(F ) 6= A(G). Assume\nnow R ( F k(na) ) 6= R ( Gk(na) ) . Without loss of general-\nity let (a, b) \u2208 R ( F k(na) ) \\ R ( Gk(na) ) . Since for any AF\nH , L(H ) = L ( H k(na) ) we obtain a 6= b. Furthermore,\n(a, b) \u2208 R ( F k(na) ) implies {(a, a), (a, b), (b, a), (b, b)} \u2229 R (F ) 6= \u2205 and consequently, for any S \u2208 na(F ), {a, b} 6\u2286 S. Since (a, b) /\u2208 R ( Gk(na) ) we deduce {(a, a), (a, b), (b, a), (b, b)} \u2229 R (F ) = \u2205. Hence, {a, b} \u2208 cf(G) and thus, there exists a set S \u2208 na(G), s.t. {a, b} \u2286 S (compare (Baumann and Spanring 2015, Lemma 3)) witnessing na(F ) 6= na(G).\nWe turn now to strongly admissible sets (for short, sad) (Baroni and Giacomin 2007b). We will show that, beside grounded (Oikarinen and Woltran 2011) and resolution based grounded semantics (Baroni, Dunne, and Giacomin 2011; Dvor\u030ca\u0301k et al. 2014), strongly admissible sets are characterizable through the grounded kernel. Consider the following self-referential definition taken from (Caminada 2014).\nDefinition 6. Given an AF F = (A,R). A set S \u2286 A is strongly admissible, i.e. S \u2208 sad(F ) iff any a \u2208 S is defended by a strongly admissible set S\u2032 \u2286 S \\ {a}.\nThe following properties are needed to prove the characterization theorem. The first two of them are already shown in (Baroni and Giacomin 2007a). The third statement is an immediate consequence of the former.\nProposition 1. Given two AFs F and G , then 1. gr(F ) \u2286 sad(F ) \u2286 ad(F ), 2. if S \u2208 gr(F ) we have: S\u2032 \u2286 S for all S\u2032 \u2208 sad(F ), and 3. sad(F ) = sad(G) implies gr(F ) = gr(G).\nThe following definition provides us with an alternative criterion for being a strong admissible set. In contrast to the former it allows one to construct strong admissible sets step by step. Thus, a construction method is given.\nDefinition 7. Given an AF F = (A,R). A set S \u2286 A is strongly admissible, i.e. S \u2208 sad(F ) iff there are finitely many and pairwise disjoint sets A1, ..., An, s.t. S = \u22c3 1\u2264i\u2264nAi and A1 \u2286 \u0393F (\u2205)3 and furthermore,\u22c3\n1\u2264i\u2264j Ai defends Aj+1 for 1 \u2264 j \u2264 n\u2212 1. Proposition 2. Definitions 6 and 7 are equivalent.\nProof. For the proof we use S \u2208 sadk(F ) as a shorthand for S \u2208 sad(F ) in the sense of Definition k. (\u21d0) Given S \u2208 sad7(F ). Hence, there is a finite partition, s.t. S = \u22c3 1\u2264i\u2264nAi, A1 \u2286 \u0393F (\u2205) and\u22c3\n1\u2264i\u2264j Ai defends Aj+1 for 1 \u2264 j \u2264 n \u2212 1. Observe that\u22c3 1\u2264i\u2264j Ai \u2208 sad7(F ) for any j \u2264 n. Let a \u2208 S. Consequently, there is an index i\u2217, s.t. a \u2208 Ai\u2217 . Furthermore, since \u22c3 1\u2264i\u2264i\u2217\u22121Ai defends Ai\u2217 by definition, we deduce\nthat \u22c3\n1\u2264i\u2264i\u2217\u22121Ai \u2286 S \\ {a} defends a. We have to show now that (the smaller set w.r.t. \u2286) \u22c3 1\u2264i\u2264i\u2217\u22121Ai \u2208 sad6(F ).\nNote that \u22c3\n1\u2264i\u2264i\u2217\u22121Ai \u2208 sad7(F ). Since we are dealing with finite AFs we may iterate our construction. Hence, no matter which elements are chosen we end up with a \u2286-chain, s.t. \u2205 \u2286 \u22c3 1\u2264i\u2264ie Ai \u2286 Se \\ ae and \u2205 defends ae for some index ie, set Se and element ae. This means, the question whether S \u2208 sad6(F ) can be decided positively by proving \u2205 \u2208 sad6(F ). Since the empty set does not contain any elements we find \u2205 \u2208 sad6(F ) concluding sad7 \u2286 sad6. (\u21d2) Given S \u2208 sad6(F ), consider the following sets Si: S1 = (\u0393(\u2205) \\ \u2205) \u2229 S, S2 = (\u0393(S1) \\ S1) \u2229 S, S3 = ( \u0393( \u22c32 i=1 Si) \\ \u22c32 i=1 Si ) \u2229 S, . . . , Sn =(\n\u0393( \u22c3n\u22121 i=1 Si) \\ \u22c3n\u22121 i=1 Si ) \u2229 S. Since we are dealing with finite AFs there has to be a natural n \u2208 N, s.t. Sn = Sn+1 = Sn+2 = . . . . Consider now the union of these sets, i.e. \u22c3n i=1 Si. We show now that \u22c3n i=1 Si \u2208\nsad7(F ) and \u22c3n i=1 Si = S. By construction we have\nS1 \u2286 \u0393(\u2205). Moreover, \u22c3\n1\u2264i\u2264j Si defends Sj+1 for 1 \u2264 j \u2264 n \u2212 1. This can be seen as follows. By definition\n3Hereby, \u0393 is the so-called characteristic function (Dung 1995) with \u0393F (S) = {a \u2208 A | a is defended by S in F}. The term \u0393F (\u2205) can be equivalently replaced by {a \u2208 A | a is unattacked}.\nSj+1 = ( \u0393( \u22c3j i=1 Si) \\ \u22c3j i=1 Si ) \u2229 S. This means, Sj+1 \u2286\n\u0393( \u22c3j i=1 Si). Since \u0393( \u22c3j i=1 Si) contains all elements de-\nfended by \u22c3j i=1 Si we obtain \u22c3n i=1 Si \u2208 sad7(F ). Obvi-\nously, \u22c3j i=1 Si \u2286 S. In order to derive a contradiction we sup-\npose S 6\u2286 \u22c3n i=1 Si. This means there is a nonempty set S\n\u2217, s.t. S = S\u2217 \u222a \u22c3n i=1 Si. Let S\n\u2217 = {s1, . . . , sk}. Observe that no element si is defended by \u22c3n i=1 Si (*). Since S \u2208 sad6(F ) we obtain a set S\u22171 \u2286 S \\ {s1}, s.t. S\u22171 \u2208 sad6(F ) and S\u22171 defends s1. We now iterate this procedure ending up with a set S\u2217k \u2286 S\u2217k\u22121 \\ {sk} \u2286 \u22c3n i=1 Si, s.t. S \u2217 k \u2208 sad6(F ) and S\u2217k defends sk contradicting (*) and concluding the proof.\nThe following example shows how to use the new construction method. Example 2. Consider the following AF F .\naF : b\nc\nd\ne f\nWe have \u0393F (\u2205) = {a, d}. Hence, for all S \u2286 {a, d}, S \u2208 sad(F ). Furthermore, \u0393F ({a}) = {a, c}, \u0393F ({d}) = {d, f} and \u0393F ({a, d}) = {a, d, c, f}. This means, additionally {a, c}, {d, f}, {a, d, c}, {a, d, f}, {a, d, c, f} \u2208 sad(F ). Finally, \u0393F ({a, c}) = {a, c, f} justifying the last missing set {a, c, f} \u2208 sad(F ).\nThe following corollary is an immediate consequence of Definition 7. It is essential to prove the characterization theorem for strongly admissible sets. Corollary 1. Given an AF F and two sets B,B\u2032 \u2286 A(F ). If B defends B\u2032, then B \u222aB\u2032 is strong admissible if B is.\nThe following lemma shows that the grounded kernel is insensitive w.r.t. strong admissible sets.\nLemma 1. For any AF F , sad (F ) = sad ( F k(gr) ) .\nProof. The grounded kernel is node- and loop-preserving, i.e. A(F ) = A ( F k(gr) ) and L(F ) = L ( F k(gr) ) . Furthermore,\ncf(F ) = cf ( F k(gr) ) and \u0393F (\u2205) = \u0393Fk(gr)(\u2205) as shown in (Oikarinen and Woltran 2011, Lemma 6). (\u2286) Given S \u2208 sad (F ). The proof is by induction on n indicating the number of sets forming a suitable (according to Definition 7) partition of S. Let n = 1. In consideration of the grounded kernel we observe \u0393F (\u2205) = \u0393Fk(gr)(\u2205), i.e. the set of unattacked arguments does not change. Since S \u2286 \u0393F (\u2205) is assumed we are done. Assume now that the assertion is proven for any k-partition. Let S be a (k + 1)-partition, i.e. S = \u22c3k+1 i=1 Ai. According to induction hypothesis as well\nas Corollary 1 it suffices to prove \u22c3k i=1Ai defends Ak+1 in F k(gr). Assume not, i.e. there are arguments b \u2208 A(F ) \\ S, c \u2208 Ak+1 s.t. (b, c) \u2208 R ( F k(gr)\n) \u2286 R(F ) and for all a \u2208\u22c3k\ni=1Ai, (a, b) /\u2208 R ( F k(gr) ) (*). Since \u22c3k i=1Ai defends\nAk+1 in F we deduce the existence of an argument a \u2208\u22c3k i=1Ai s.t. (a, b) \u2208 R (F ). Thus, (a, b) is redundant w.r.t. the grounded kernel. According to Definition 4 and due to\nthe conflict-freeness of \u22c3k i=1Ai we have (a, a) /\u2208 R (F ) and (b, a), (b, b) \u2208 R (F ). Consequently, (b, a) \u2208 F k(gr). Since\u22c3k i=1Ai is a strong admissible k-partition in F we obtain\nby induction hypothesis that \u22c3k i=1Ai is strong admissible in F k(gr) and therefore, admissible in F k(gr) (Proposition 1). Hence there has to be an argument a \u2208 \u22c3k i=1Ai, s.t. (a, b) \u2208\nR ( F k(gr) ) , contradicting (*).\n(\u2287) Assume S \u2208 sad ( F k(gr) ) . We show S \u2208 sad (F ) by\ninduction on n indicating that S is a n-partition in F k(gr). Due to \u0393F (\u2205) = \u0393Fk(gr)(\u2205) the base case is immediately clear. For the induction step let S be a (k + 1)-partition, i.e. S = \u22c3k+1 i=1 Ai. By induction hypothesis we may assume\nthat \u22c3k i=1Ai is strongly admissible in F . Using Corollary 1\nit suffices to prove \u22c3k i=1Ai defends Ak+1 in F . Assume not, i.e. there are arguments b \u2208 A(F ) \\ S, c \u2208 Ak+1 s.t. (b, c) \u2208 R (F ) and for all a \u2208 \u22c3k i=1Ai, (a, b) /\u2208 R (F ). We\neven have (a, b) /\u2208 R ( F k(gr) ) since R ( F k(gr) ) \u2286 R (F ).\nConsequently, (b, c) has to be deleted in F k(gr). Definition 4 requires (c, c) \u2208 R ( F k(gr) ) contradicting the conflict-\nfreeness of S in F k(gr).\nTheorem 3. For any two AFs F and G we have,\nF \u2261sadE G \u21d4 F k(gr) = Gk(gr)\nProof. (\u21d2) We show the contrapositive, i.e. F k(gr) 6= Gk(gr) \u21d2 F 6\u2261sadE G . Assuming F k(gr) 6= Gk(gr) implies F 6\u2261grE G (Theorem 1). This means, there is an AF H , s.t. gr(F \u222a H) 6= gr(G \u222a H). Due to statement 3 of Proposition 1, we deduce sad(F \u222a H) 6= sad(G \u222a H) proving F 6\u2261sadE G . (\u21d0) Given F k(gr) = Gk(gr). Since expansion equivalence is a congruence w.r.t. \u222a we obtain (F \u222aH )k(gr) = (G \u222aH )k(gr)\nfor any AF H . Consequently, sad ( (F \u222aH )k(gr) ) =\nsad ( (G \u222aH )k(gr) )\n. Due to Lemma 1 we deduce sad(F \u222a H ) = sad(G \u222aH ), concluding the proof."}, {"heading": "Verifiability", "text": "In this section we study the question whether we really need the entire AF F to compute the extensions of a given semantics. Let us consider naive semantics. Obviously, in order to determine naive extensions it suffices to know all conflictfree sets. Conversely, knowing cf(F ) only does not allow to reconstruct F unambiguously. This means, knowledge about cf(F ) is indeed less information than the entire AF by itself. In fact, most of the existing semantics do not need information of the entire framework. We will categorize the amount of information by taking the conflict-free sets as a basis and distinguish between different amounts of knowledge about the neighborhood, that is range and anti-range, of these sets.\nDefinition 8. We call a function rx : 2U \u00d7 2U \u2192 ( 2U )n (n > 0) which is expressible via basic set operations only neighborhood function. A neighborhood function rx induces\nthe verification class mapping each AF F to\nF\u0303x = {(S, rx(S+F , S \u2212 F )) | S \u2208 cf(F )}.\nWe coined the term neighborhood function because the induced verification classes apply these functions to the neighborhoods, i.e. range and anti-range of conflict-free sets. The notion of expressible via basic set operations simply means that (in case of n = 1) the expression rx(A,B) is in the language generated by the following BNF:\nX ::= A | B | (X \u222aX) | (X \u2229X) | (X \\X). Consequently, in case of n = 1, we may distinguish eight set theoretically different neighborhood functions, namely\nr (S, S\u2032) = \u2205 r+(S, S\u2032) = S\nr\u2212(S, S\u2032) = S\u2032\nr\u2213(S, S\u2032) = S\u2032 \\ S r\u00b1(S, S\u2032) = S \\ S\u2032\nr\u2229(S, S\u2032) = S \u2229 S\u2032\nr\u222a(S, S\u2032) = S \u222a S\u2032\nr\u2206(S, S\u2032) = (S \u222a S\u2032) \\ (S \u2229 S\u2032) A verification class encapsulates a certain amount of infor-\nmation about an AF, as the following example illustrates. Example 3. Consider the following AF F :\naF : b c\nNow take, for instance, the verification class induced by r+, that is F\u0303+ = {(S, r+(S+F , S \u2212 F )) | S \u2208 cf(F )} = {(S, S+F ) | S \u2208 cf(F )}, storing information about conflictfree sets together with their associated ranges w.r.t. F . It contains the following tuples: (\u2205, \u2205), ({a}, {b}), ({c}, {b}), and ({a, c}, {b}). The verification class induced by r\u00b1 contains the same tuples but ({a}, \u2205) instead of ({a}, {b}).\nIntuitively, it should be clear that the set F\u0303+ suffices to compute stage extensions (i.e., range-maximal conflict-free sets) of F . This intuitive understanding of verifiability will be formally specified in Definition 10. Note that a neighborhood function rx may return n-tuples. Consequently, in consideration of the eight listed basic function we obtain (modulo reordering, duplicates, empty set) 27 + 1 syntactically different neighborhood functions and therefore the same number of verification classes. As usual, we will denote the n-ary combination of basic functions (rx1(S, S\u2032), . . . , rxn(S, S\u2032)) as rx(S, S\u2032) with x = x1 . . . xn.\nWith the following definition we can put neighborhood functions into relation w.r.t. their information. This will help us to show that actually many of the induced classes collapse to the same amount of information. Definition 9. Given neighborhood functions rx and ry returning n-tuples and m-tuples, respectively, we say that rx is more informative than ry, for short rx ry, iff there is a function \u03b4 : ( 2U )n \u2192 (2U)m such that for any two sets of arguments S, S\u2032 \u2286 U , we have \u03b4 (rx(S, S\u2032)) = ry (S, S\u2032).\nWe will denote the strict part of by , i.e. rx ry iff rx ry and ry 6 rx. Moreover rx \u2248 ry in case rx ry and ry rx, we say that rx represents ry and vice versa. Lemma 2. All neighborhood functions are represented by the ones depicted in Figure 1 and the \u227a-relation represented by arcs in Figure 1 holds.\nProof. We begin by showing that all neighborhood functions are represented in Figure 1. Clearly, each neighborhood function rx represents itself, i.e. rx \u2248 rx. All neighborhood functions for n = 1 are are depicted in Figure 1. We turn to n = 2. Consider the neighborhood functions r+\u00b1, r+\u2229, and r\u00b1\u2229, defined as r+\u00b1(S, S\u2032) = (S, S \\S\u2032), r+\u2229(S, S\u2032) = (S, S\u2229S\u2032), and r\u00b1\u2229(S, S\u2032) = (S \\ S\u2032, S \u2229 S\u2032) for S, S\u2032 \u2286 U . Observe that S = (S \\ S\u2032) \u222a (S \u2229 S\u2032). Hence, we can easily define functions in the spirit of Definition 9 mapping the images of the function to one another:\n\u2022 \u03b41(r+\u00b1(S, S\u2032)) = \u03b41(S, S \\S\u2032) =def (S, S \\ (S \\S\u2032)) = (S, S \u2229 S\u2032) = r+\u2229(S, S\u2032); \u2022 \u03b42(r+\u2229(S, S\u2032)) = \u03b42(S, S \u2229 S\u2032) =def (S \\ (S \u2229 S\u2032), S \u2229 S\u2032) = (S \\ S\u2032, S \u2229 S\u2032) = r\u00b1\u2229(S, S\u2032);\n\u2022 \u03b43(r\u00b1\u2229(S, S\u2032)) = \u03b43(S \\ S\u2032, S \u2229 S\u2032) =def ((S \\ S\u2032) \u222a (S \u2229 S\u2032), S \\ S\u2032) = (S, S \\ S\u2032) = r+\u00b1(S, S\u2032).\nTherefore, r+\u00b1 \u2248 r+\u2229 \u2248 r\u00b1\u2229. In particular, they are all represented by r\u00b1. We can apply the same reasoning to other combinations of neighborhood functions and get the following equivalences w.r.t. information content: r+\u2213 \u2248 r+\u222a \u2248 r\u2213\u222a; r\u00b1\u2213 \u2248 r\u00b1\u2206 \u2248 r\u2213\u2206; r\u2229\u222a \u2248 r\u2229\u2206 \u2248 r\u222a\u2206; r\u2212\u00b1 \u2248 r\u2212\u222a \u2248 r\u00b1\u222a; and r\u2212\u2213 \u2248 r\u2212\u2229 \u2248 r\u2213\u2229, with the functions stated first acting as representatives in Figure 1.\nFor the remaining functions returning 2-tuples we get r+\u2212 \u2248 r+\u2206 \u2248 r\u2212\u2206 by\n\u2022 \u03b44(r+\u2212(S, S\u2032)) = \u03b44(S, S\u2032) =def (S, (S \u222a S\u2032) \\ (S \u2229 S\u2032)) = r+\u2206(S, S\u2032);\n\u2022 \u03b45(r+\u2206(S, S\u2032)) = \u03b45(S, (S \u222a S\u2032) \\ (S \u2229 S\u2032)) =def ((S \\ ((S \u222a S\u2032) \\ (S \u2229 S\u2032))) \u222a ((S \u222a S\u2032) \\ (S \u2229 S\u2032)) \\ S, (S \u222a S\u2032) \\ (S \u2229S\u2032)) = (S\u2032, (S \u222aS\u2032) \\ (S \u2229S\u2032)) = r\u2212\u2229(S, S\u2032);\n\u2022 \u03b46(r\u2212\u2206(S, S\u2032)) = \u03b46(S\u2032, (S\u222aS\u2032)\\ (S\u2229S\u2032)) =def ((S\u2032 \\ ((S \u222aS\u2032) \\ (S \u2229S\u2032)))\u222a ((S \u222aS\u2032) \\ (S \u2229S\u2032)) \\S\u2032, S\u2032) = (S, S\u2032) = r+\u2212(S, S\u2032).\nFinally, every neighborhood function rx1...xn with n \u2265 3 is represented by r+\u2212 since we can compute all possible sets from S and S\u2032.\nNow consider two functions rx and ry such that there is an arrow from x to y in Figure 1. It is easy to see that ry rx since, for sets of arguments S and S\u2032, rx(S, S\u2032) is either contained in ry(S, S\u2032) or obtainable from ry(S, S\u2032) by basic set operations. The fact that rx 6 ry, entailing ry rx, follows from the impossibility of finding a function \u03b4 such that \u03b4(rx(S, S\u2032)) = ry(S, S\u2032).\nIf the information provided by a neighborhood function is sufficient to compute the extensions, we say the semantics is verifiable by the class induced by the neighborhood function. Definition 10. A semantics \u03c3 is verifiable by the verification class induced by the neighborhood function rx returning ntuples (or simply, x-verifiable) iff there is a function (also called criterion) \u03b3\u03c3 : ( 2U )n \u00d7 2U \u2192 22U s.t. for every AF F \u2208 A we have: \u03b3\u03c3 ( F\u0303x, A(F ) ) = \u03c3(F ).\nMoreover, \u03c3 is exactly x-verifiable iff \u03c3 is x-verifiable and there is no verification class induced by ry with ry \u227a rx such that \u03c3 is y-verifiable.\nObserve that if a semantics \u03c3 is x-verifiable then for any two AFs F and G with F\u0303x = G\u0303x andA(F ) = A(G) it must hold that \u03c3(F ) = \u03c3(G).\nWe proceed with a list of criteria showing that any semantics mentioned in Definition 1 is verifiable by a verification class induced by a certain neighborhood function. In the following, we abbreviate the tuple (F\u0303x, A(F )) by F\u0303xA.\n\u03b3na(F\u0303 A) = {S | S \u2208 F\u0303 , S is \u2286 -maximal in F\u0303};\n\u03b3stg(F\u0303 + A ) = {S | (S, S +) \u2208 F\u0303+, S+ is \u2286 -maximal in\n{C+ | (C,C+) \u2208 F\u0303+}};\n\u03b3stb(F\u0303 + A ) = {S | (S, S +) \u2208 F\u0303+, S+ = A}; \u03b3ad(F\u0303 \u2213 A ) = {S | (S, S \u2213) \u2208 F\u0303\u2213, S\u2213 = \u2205}; \u03b3pr(F\u0303 \u2213 A ) = {S | S \u2208 \u03b3ad(F\u0303 \u2213 A ), S is \u2286 -maximal in \u03b3ad(F\u0303 \u2213 A )};\n\u03b3ss(F\u0303 +\u2213 A ) = {S | S \u2208 \u03b3ad(F\u0303 \u2213 A ), S + is \u2286 -maximal in\n{C+ | (C,C+, C\u2213) \u2208 F\u0303+\u2213, C \u2208 \u03b3ad(F\u0303\u2213A )}};\n\u03b3id(F\u0303 \u2213 A ) = {S | S is \u2286 -maximal in {C | C \u2208 \u03b3ad(F\u0303\u2213A ), C \u2286 \u22c2 \u03b3pr(F\u0303 \u2213 A )}};\n\u03b3eg(F\u0303 +\u2213 A ) = {S | S is \u2286 -maximal in {C | C \u2208 \u03b3ad(F\u0303\u2213A ), C \u2286 \u22c2 \u03b3ss(F\u0303 +\u2213 A )}};\n\u03b3sad(F\u0303 \u2212\u00b1 A ) = {S | (S, S \u2212, S\u00b1) \u2208 F\u0303\u2212\u00b1,\n\u2203(S0, S\u22120 , S \u00b1 0 ), . . . , (Sn, S \u2212 n , S \u00b1 n ) \u2208 F\u0303\u2212\u00b1 : (\u2205 = S0 \u2282 \u00b7 \u00b7 \u00b7 \u2282 Sn = S\u2227 \u2200i \u2208 {1, . . . , n} : S\u2212i \u2286 S \u00b1 i\u22121)};\n\u03b3gr(F\u0303 \u2212\u00b1 A ) = {S | S \u2208 \u03b3sad(F\u0303 \u2212\u00b1 A ),\n\u2200(S\u0304, S\u0304\u2212, S\u0304\u00b1) \u2208 F\u0303\u2212\u00b1 : S\u0304\u2283S \u21d2 (S\u0304\u2212\\S\u00b1) 6=\u2205)};\n\u03b3co(F\u0303 +\u2212 A ) = {S | (S, S +, S\u2212) \u2208 F\u0303+\u2212, (S\u2212 \\ S+) = \u2205,\n\u2200(S\u0304, S\u0304+, S\u0304\u2212) \u2208 F\u0303+\u2212 : S\u0304\u2283S \u21d2 (S\u0304\u2212\\S+)6=\u2205)}.\nInstead of a formal proof we give the following explanations. First of all it is easy to see that the naive semantics is verifiable by the verification class induced by r since the naive extensions can be determined by the conflict-free sets. Stable and stage semantics, on the other hand, utilize the range of each conflict-free set in addition. Hence they are verifiable by the verification class induced by r+. Now consider admissible sets. Recall that a conflict-free S set is admissible if and only if it attacks all attackers. This is captured exactly by the condition S\u2213 = \u2205, hence admissible sets are verifiable by the verification class induced by r\u2213. The same holds for preferred semantics, since we just have to determine the maximal conflict-free sets with S\u2213 = \u2205. Semi-stable semantics, however, needs the range of each conflict-free set in addition, see \u03b3ss, which makes it verifiable by the verification class induced by r+\u2213. Finally consider the criterion \u03b3co. The first two conditions for a set of arguments S stand for conflict-freeness and admissibility, respectively. Now assume the third condition does not hold, i.e., there exists a tuple (S\u0304, S\u0304+, S\u0304\u2212) \u2208 F\u0303+\u2212 with S\u0304 \u2283 S and S\u0304\u2212 \\ S+ = \u2205. This means that every argument attacking S\u0304 is attacked by S, i.e., S\u0304 is defended by S. Hence S is not a complete extension, showing that \u03b3co(F\u0303+\u2212A ) = co(F ) for each F \u2208 A . One can verify that all criteria from the list are adequate in the sense that they describe the extensions of the corresponding semantics.\nWe show now that the formal concepts of verifiability and being more informative behave correctly in the sense that the use of more informative neighborhood functions do not lead to a loss of verification capacity. Proposition 3. If a semantics \u03c3 is x-verifiable, then \u03c3 is verifiable by all verification classes induced by some ry with ry rx.\nProof. As \u03c3 is verifiable by the verification class induced by rx it holds that there is some \u03b3\u03c3 such that for all F \u2208 A , \u03b3\u03c3(F\u0303\nx, A(F )) = \u03c3(F ). Now let ry rx, meaning that there is some \u03b4 such that \u03b4(ry(S, S\u2032)) = rx. We define \u03b3\u2032\u03c3(F\u0303\ny, A(F )) = \u03b3\u03c3({(S, \u03b4(S)) | (S,S) \u2208 F\u0303 y}, A(F )) and observe that {(S, \u03b4(S)) | (S,S) \u2208 F\u0303 y} = F\u0303x, hence \u03b3\u2032\u03c3(F\u0303 y, A(F )) = \u03c3(F ) for each F \u2208 A .\nIn order to prove unverifiability of a semantics \u03c3 w.r.t. a class induced by a certain rx it suffices to present two AFs F and G such that \u03c3(F ) 6= \u03c3(G) but, F\u0303x = G\u0303x and A(F ) = A(G). Then the verification class induced by rx does not provide enough information to verify \u03c3.\nIn the following we will use this strategy to show exact verifiability. Consider a semantics \u03c3 which is verifiable by a class induced by rx. If \u03c3 is unverifiable by all verifiability\nclasses induced by ry with ry \u227a rx we have that \u03c3 is exactly verifiable by rx. The following examples study this issue for the semantics under consideration. Example 4. The complete semantics is +\u2212-verifiable as seen before. The following AFs show that it is even exactly verifiable by that class.\naF1 : b aF \u2032 1 : b\naF2 : b c aF \u2032 2 : b c\naF3 : b aF \u2032 3 : b\naF4 : b aF \u2032 4 : b\naF5 : b aF \u2032 5 : b\naF6 : b aF \u2032 6 : b\nFirst consider the AFs F1 and F \u20321, and observe that F\u03031 +\u00b1 = {(\u2205, \u2205, \u2205), ({a}, \u2205, \u2205)} = F\u0303 \u20321 +\u00b1\n. On the other hand F1 and F \u20321 differ in their complete extensions since co(F1) = {\u2205} but co(F \u20321) = {{a}}. Therefore complete semantics is unverifiable by the verification class induced by r+\u00b1. Likewise, this can be shown for the classes induced by r\u2212\u2213, r\u00b1\u2213, r\u2212\u00b1, r+\u2213, and r\u2229\u222a, respectively:\n\u2022 F\u03032 \u2212\u2213\n= {(\u2205, \u2205, \u2205), ({a}, \u2205, \u2205), ({a, c}, {b}, \u2205), ({c}, {b}, \u2205)} = F\u0303 \u20322 \u2212\u2213 , but co(F2) = {{a}, {a, c}} 6=\n{{a, c}} = co(F \u20322). \u2022 F\u03033 \u00b1\u2213 = F\u0303 \u20323 \u00b1\u2213 , but co(F3) = {\u2205, {a}} 6= {{a}} = co(F \u20323). \u2022 F\u03034 \u2212\u00b1 = F\u0303 \u20324 \u2212\u00b1\n, but co(F4) = {\u2205, {a}} 6= {\u2205} = co(F \u20324). \u2022 F\u03035 +\u2213 = F\u0303 \u20325 +\u2213 , but co(F5) = {\u2205, {a}} 6= {{a}} = co(F \u20325). \u2022 F\u03036 \u2229\u222a = F\u0303 \u20326 \u2229\u222a , but co(F6) = {{a}} 6= {\u2205} = co(F \u20326).\nHence the complete semantics is exactly verifiable by the verification class induced by r+\u2212. Example 5. Consider the semi-stable and eager semantics and recall that they are +\u2213-verifiable In order to show exact verifiability it suffices to show unverifiability by the classes induced by r+, r\u222a, and r\u2213 (cf. Figure 1); F1 and F6 are taken from Example 4 above.\n\u2022 F\u03031 + = F\u0303 \u20321 +\n, but ss(F1) = eg(F1) = {\u2205} 6= {{a}} = ss(F \u20321) = eg(F \u2032 1).\n\u2022 F\u03036 \u222a = F\u0303 \u20326 \u222a\n, but ss(F6) = eg(F6) = {{a}} 6= {\u2205} = ss(F \u20326) = eg(F \u2032 6).\n\u2022 F\u03037 \u2213 = F\u0303 \u20327 \u2213\n, but ss(F7) = {{b}} 6= {{a}, {b}} = ss(F \u20327) and eg(F7) = {{b}} 6= {\u2205} = eg(F \u20327).\naF7 : b c aF \u2032 7 : b c\nHence, both the semi-stable and eager semantics are exactly verifiable by the verification class induced by r+\u2213.\nExample 6. Now consider the grounded and strong admissible semantics and recall that they are \u2212\u00b1-verifiable In order to show exact verifiability we have to show unverifiability by the classes induced by r\u00b1, r\u2212, and r\u222a (cf. Figure 1); again, the AFs from Example 4 can be reused.\n\u2022 F\u03031 \u00b1 = F\u0303 \u20321 \u00b1\n, but gr(F1) = {\u2205} 6= {{a}} = gr(F \u20321) and sad(F1) = {\u2205} 6= {\u2205, {a}} = sad(F \u20321).\n\u2022 F\u03032 \u2212 = F\u0303 \u20322 \u2212\n, but gr(F2) = {{a}} 6= {a, c} = gr(F \u20322) and sad(F2) = {\u2205, {a}} 6= {\u2205, {a}, {a, c}} = sad(F \u20322)\n\u2022 F\u03036 \u222a = F\u0303 \u20326 \u222a\n, but gr(F6) = {{a}} 6= {\u2205} = gr(F \u20326) and sad(F6) = {\u2205, {a}} 6= {\u2205} = sad(F \u20326).\nHence, both the grounded and strong admissible semantics are exactly verifiable by the verification class induced by r+\u2213.\nExample 7. Finally consider stable, stage, admissible, preferred and ideal semantics. They are either +-verifiable (stb and stg) or \u2213-verifiable (ad, pr , and id ). In order to show that these verification classes are exact we have to show unverifiability w.r.t. the verification class induced by r . Consider, for instance, the AFs F4 and F \u20324 from Example 4. We have F\u03034 = F\u0303 \u20324 , but ad(F4) = {\u2205, {a}} 6= {\u2205} = ad(F \u20324), stb(F4) = {{a}} 6= \u2205 = stb(F \u20324), and \u03c3(F4) = {{a}} 6= {\u2205} = \u03c3(F \u20324) for \u03c3 \u2208 {stg , pr , id}, showing exactness of the respective verification classes.\nThe insights obtained through Examples 4, 5, 6, and 7 show that the verification classes obtained from the criteria given above are indeed exact. Figure 2 shows the relation between the semantics under consideration with respect to their exact verification classes.\nWe turn now to the main theorem stating that any rational semantics (recall that all semantics we consider in this paper are rational) is exactly verifiable by one of the 15 different verification classes.\nTheorem 4. Every semantics which is rational is exactly verifiable by a verification class induced by one of the neighborhood functions presented in Figure 1.\nProof. First of all note that by Lemma 2, r is the least informative neighborhood function and for every other neighborhood function rx it holds that r r\u2212. Therefore, if a semantics is verifiable by the verification class induced by any rx then it is exactly verifiable by a verification class induced by some ry with r ry rx. Moreover, if a semantics is exactly verifiable by a class, then it is by definition also verifiable by this class. Hence it remains to show that every\nsemantics which is rational is verifiable by a verification class presented in Figure 1.\nWe show the contrapositive, i.e., if a semantics is not verifiable by a verification class induced by one of the neighborhood functions presented in Figure 1 then it is not rational.\nAssume a semantics \u03c3 is not verifiable by one of the verification classes. This means \u03c3 is not verifiable by the verification class induced by r+\u2212. Hence there exist two AFs F and G such that F\u0303+\u2212 = G\u0303+\u2212 and A(F ) = A(G), but \u03c3(F ) 6= \u03c3(G). For every argument a which is not selfattacking, a tuple ({a}, {a}+, {a}\u2212) is contained in F\u0303+\u2212 (and in G\u0303+\u2212). Hence F and G have the same not-selfattacking arguments and, moreover these arguments have the same ingoing and outgoing attacks in F and G . This, together with A(F ) = A(G) implies that F l = G l (see Definition 2) holds. But since \u03c3(F ) 6= \u03c3(G) we get that \u03c3 is not rational, which was to show.\nNote that the criterion giving evidence for verifiability of a semantics by a certain class has access to the set of arguments of a given framework. In fact, only the criterion for stable semantics makes use of that. Indeed, stable semantics needs this information since it is not verifiable by any class when using a weaker notion of verifiability, which rules out the usage of A(F ).\nIntermediate Semantics A type of semantics which has aroused quite some interest in the literature (see e.g. (Baroni and Giacomin 2007a) and (Nieves, Osorio, and Zepeda 2011)) are intermediate semantics, i.e. semantics which yield results lying between two existing semantics. The introduction of \u03c3-\u03c4 -intermediate semantics can be motivated by deleting undesired (or add desired) \u03c4 -extensions while guaranteeing all reasonable positions w.r.t. \u03c3. In other words, \u03c3-\u03c4 -intermediate semantics can be seen as sceptical or credulous acceptance shifts within the range of \u03c3 and \u03c4 .\nA natural question is whether we can make any statements about compatible kernels of intermediate semantics. In particular, if semantics \u03c3 and \u03c4 are compatible with some kernel k , is then every \u03c3-\u03c4 -intermediate semantics k -compatible. The following example answers this question negatively.\nExample 8. Recall from Theorem 1 that both stable and stage semantics are compatible with k(stb), i.e. F \u2261stbE G \u21d4 F \u2261stgE G \u21d4 F k(stb) = Gk(stb). Now we define the following stb-stg-intermediate semantics, say stagle semantics: Given an AF F = (A,R), S \u2208 sta(F ) iff S \u2208 cf(F ), S+F \u222a S \u2212 F = A and for every T \u2208 cf(F ) we have S + F 6\u2282 T + F . Obviously, it holds that stb \u2286 sta \u2286 stg and stb 6= sta as well as sta 6= stg, as witnessed by the following AF F :\naF : b c\nIt is easy to verify that stb(F ) = \u2205 \u2282 sta(F ) = {{b}} \u2282 stg(F ) = {{b}, {c}}. We proceed by showing that stagle semantics is not compatible with k(stb). To this end consider F k(stb), which is depicted below.\naF k(stb) : b c\nNow, sta ( F k(stb) ) = {{b}, {c}} witnesses F 6\u2261sta F k(stb)\nand therefore, F 6\u2261staE F k(stb). Since F k(stb) = ( F k(stb) )k(stb) we are done, i.e. stagle semantics is indeed not compatible with the stable kernel.\nIt is the main result of this section that compatibility of intermediate semantics w.r.t. a certain kernel can be guaranteed if verifiability w.r.t. a certain class is presumed. The provided characterization theorems generalize former results presented in (Oikarinen and Woltran 2011). Moreover, due to the abstract character of the theorems the results are applicable to semantics which may be defined in the future.\nBefore turning to the characterization theorems we state some implications of verifiability. In particular, under the assumption that \u03c3 is verifiable by a certain class, equality of certain kernels implies expansion equivalence w.r.t. \u03c3.\nProposition 4. For any +-verifiable semantics \u03c3 we have\nF k(stb) = Gk(stb) \u21d2 F \u2261\u03c3E G .\nProof. In (Oikarinen and Woltran 2011) it was shown that F k(stb) = Gk(stb) \u21d2 (F \u222aH )k(stb) = (G \u222aH )k(stb) (i). Consider now a +-verifiable semantics \u03c3. In order to show\n\u03c3 (F ) = \u03c3 ( F k(stb) ) (ii) we prove F\u0303+ = F\u0303 k(stb) +\n(*) first. It is easy to see that S \u2208 cf(F ) iff S \u2208 cf ( F k(stb) ) . Fur-\nthermore, since k(stb) deletes an attack (a, b) only if a is self-defeating we deduce that ranges does not change as long as conflict-free sets are considered. Thus, \u03c3(F ) = (Def.)\n\u03b3\u03c3(F\u0303 +) = (*) \u03b3\u03c3(F\u0303 k(stb)\n+\n) = (Def.) \u03c3(F k(stb)).\nNow assume that F k(stb) = Gk(stb) and let S \u2208 \u03c3(F \u222a H ) for some AF H . We have to show that S \u2208 \u03c3(G \u222a H ). Applying (ii) we obtain S \u2208 \u03c3 ( (F \u222aH )k(stb) ) . Furthermore,\nusing (i) we deduce S \u2208 \u03c3 ( (G \u222aH )k(stb) ) . Finally, S \u2208 \u03c3 (G \u222aH ) by applying (ii), which concludes the proof.\nThe following results can be shown in a similar manner.\nProposition 5. For any +\u2213-verifiable semantics \u03c3 we have\nF k(ad) = Gk(ad) \u21d2 F \u2261\u03c3E G .\nProposition 6. For any +\u2212-verifiable semantics \u03c3 we have\nF k(co) = Gk(co) \u21d2 F \u2261\u03c3E G .\nProposition 7. For any \u2212\u00b1-verifiable semantics \u03c3 we have\nF k(gr) = Gk(gr) \u21d2 F \u2261\u03c3E G .\nProposition 8. For any -verifiable semantics \u03c3 we have\nF k(na) = Gk(na) \u21d2 F \u2261\u03c3E G .\nWe proceed with general characterization theorems. The first one states that stb-stg-intermediate semantics are compatible with stable kernel if +-verifiability is given. Consequently, stagle semantics as defined in Example 8 can not be +-verifiable.\nTheorem 5. Given a semantics \u03c3 which is +-verifiable and stb-stg-intermediate, it holds that\nF k(stb) = Gk(stb) \u21d4 F \u2261\u03c3E G .\nProof. (\u21d2) Follows directly from Proposition 4. (\u21d0) We show the contrapositive, i.e. F k(stb) 6= Gk(stb) \u21d2 F 6\u2261\u03c3E G . Assuming F k(stb) 6= Gk(stb) implies F 6\u2261 stg E G , i.e. there exists an AF H such that stg(F \u222a H ) 6= stg(G \u222a H ) and therefore, stb(F \u222aH ) 6= stb(G \u222aH ). Let B = A(F ) \u222a A(G)\u222aA(H ) and H \u2032 = (B \u222a{a}, {(a, b), (b, a) | b \u2208 B}). It is easy to see that stb(F \u222a H \u2032) = stb(F \u222a H ) \u222a {{a}} and stb(G \u222a H \u2032) = stb(G \u222a H ) \u222a {{a}}. Since now both stb(F \u222aH \u2032) 6= \u2205 and stb(G \u222aH \u2032) 6= \u2205 it holds that stb(F \u222a H \u2032) = stg(F \u222aH \u2032) and stb(G \u222aH \u2032) = stg(G \u222aH \u2032). Hence \u03c3(F \u222aH \u2032) 6= \u03c3(F \u222aH \u2032), showing that F 6\u2261stbE G .\nThe following theorems can be shown in a similar manner.\nTheorem 6. Given a semantics \u03c3 which is +\u2213-verifiable and \u03c1-ad-intermediate with \u03c1 \u2208 {ss, id, eg}, it holds that\nF k(ad) = Gk(ad) \u21d4 F \u2261\u03c3E G .\nRemember that complete semantics is a ss-ad-intermediate semantics. Furthermore, it is not characterizable by the admissible kernel as already observed in (Oikarinen and Woltran 2011). Consequently, complete semantics is not +\u2213- verifiable (as we have shown in Example 4 with considerable effort).\nTheorem 7. Given a semantics \u03c3 which is \u2212\u00b1-verifiable and gr-sad-intermediate, it holds that\nF k(gr) = Gk(gr) \u21d4 F \u2261\u03c3E G .\nConclusions In this work we have contributed to the analysis and comparison of abstract argumentation semantics. The main idea of our approach is to provide a novel categorization in terms of the amount of information required for testing whether a set of arguments is an extension of a certain semantics. The resulting notion of verifiability classes allows us to categorize any new semantics (given it is \u201crational\u201d) with respect to the information needed and compare it to other semantics. Thus our work is in the tradition of the principle-based evaluation due to Baroni and Giacomin (2007b) and paves the way for a more general view on argumentation semantics, their common features, and their inherent differences.\nUsing our notion of verifiability, we were able to show kernel-compatibility for certain intermediate semantics. Concerning concrete semantics, our results yield the following observation: While preferred, semi-stable, ideal and eager semantics coincide w.r.t. strong equivalence, verifiability of these semantics differs. In fact, preferred and ideal semantics manage to be verifiable with strictly less information.\nFor future work we envisage an extension of the notion of verifiability classes in order to categorize semantics not captured by the approach followed in this paper, such as cf2 (Baroni, Giacomin, and Guida 2005)."}], "references": [{"title": "Comparing argumentation semantics with respect to skepticism", "author": ["Baroni", "P. Giacomin 2007a] Baroni", "M. Giacomin"], "venue": "Computer Science,", "citeRegEx": "Baroni et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2007}, {"title": "On principle-based evaluation of extension-based argumentation semantics", "author": ["Baroni", "P. Giacomin 2007b] Baroni", "M. Giacomin"], "venue": null, "citeRegEx": "Baroni et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2007}, {"title": "An introduction to argumentation semantics", "author": ["Caminada Baroni", "P. Giacomin 2011] Baroni", "M. Caminada", "M. Giacomin"], "venue": "Knowledge Eng. Review 26(4):365\u2013410", "citeRegEx": "Baroni et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2011}, {"title": "P", "author": ["Baroni, P.", "Dunne"], "venue": "E.; and Giacomin, M.", "citeRegEx": "Baroni. Dunne. and Giacomin 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "SCC-Recursiveness: A general schema for argumentation", "author": ["Giacomin Baroni", "P. Guida 2005] Baroni", "M. Giacomin", "G. Guida"], "venue": null, "citeRegEx": "Baroni et al\\.,? \\Q2005\\E", "shortCiteRegEx": "Baroni et al\\.", "year": 2005}, {"title": "and Brewka", "author": ["R. Baumann"], "venue": "G.", "citeRegEx": "Baumann and Brewka 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "and Brewka", "author": ["R. Baumann"], "venue": "G.", "citeRegEx": "Baumann and Brewka 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "and Spanring", "author": ["R. Baumann"], "venue": "C.", "citeRegEx": "Baumann and Spanring 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "and Woltran", "author": ["R. Baumann"], "venue": "S.", "citeRegEx": "Baumann and Woltran 2014", "shortCiteRegEx": null, "year": 2014}, {"title": "Special issue: Tutorials on structured argumentation. Argument and Computation 5(1):1\u2013117", "author": ["Besnard"], "venue": null, "citeRegEx": "Besnard,? \\Q2014\\E", "shortCiteRegEx": "Besnard", "year": 2014}, {"title": "P", "author": ["M. Caminada", "W.A. Carnielli", "Dunne"], "venue": "E.", "citeRegEx": "Caminada. Carnielli. and Dunne 2012", "shortCiteRegEx": null, "year": 2012}, {"title": "P", "author": ["Dung"], "venue": "M.; Mancarella, P.; and Toni, F.", "citeRegEx": "Dung. Mancarella. and Toni 2007", "shortCiteRegEx": null, "year": 2007}, {"title": "P", "author": ["Dung"], "venue": "M.", "citeRegEx": "Dung 1995", "shortCiteRegEx": null, "year": 1995}, {"title": "Resolution-based grounded semantics revisited", "author": ["Dvo\u0159\u00e1k"], "venue": "In Computational Models of Argument - Proceedings of COMMA 2014,", "citeRegEx": "Dvo\u0159\u00e1k,? \\Q2014\\E", "shortCiteRegEx": "Dvo\u0159\u00e1k", "year": 2014}, {"title": "and Woltran", "author": ["S.A. Gaggl"], "venue": "S.", "citeRegEx": "Gaggl and Woltran 2013", "shortCiteRegEx": null, "year": 2013}, {"title": "and Modgil", "author": ["D. Grossi"], "venue": "S.", "citeRegEx": "Grossi and Modgil 2015", "shortCiteRegEx": null, "year": 2015}, {"title": "and Vermeir", "author": ["H. Jakobovits"], "venue": "D.", "citeRegEx": "Jakobovits and Vermeir 1999", "shortCiteRegEx": null, "year": 1999}, {"title": "Strongly equivalent logic programs", "author": ["Pearce Lifschitz", "V. Valverde 2001] Lifschitz", "D. Pearce", "A. Valverde"], "venue": "ACM Transactions on Computational Logic 2(4):526\u2013541", "citeRegEx": "Lifschitz et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Lifschitz et al\\.", "year": 2001}, {"title": "R", "author": ["Loui"], "venue": "P.", "citeRegEx": "Loui 1987", "shortCiteRegEx": null, "year": 1987}, {"title": "M", "author": ["Maher"], "venue": "J.", "citeRegEx": "Maher 1986", "shortCiteRegEx": null, "year": 1986}, {"title": "J", "author": ["Nieves"], "venue": "C.; Osorio, M.; and Zepeda, C.", "citeRegEx": "Nieves. Osorio. and Zepeda 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "and Woltran", "author": ["E. Oikarinen"], "venue": "S.", "citeRegEx": "Oikarinen and Woltran 2011", "shortCiteRegEx": null, "year": 2011}, {"title": "J", "author": ["Pollock"], "venue": "L.", "citeRegEx": "Pollock 1987", "shortCiteRegEx": null, "year": 1987}, {"title": "and Vreeswijk", "author": ["H. Prakken"], "venue": "G.", "citeRegEx": "Prakken and Vreeswijk 2002", "shortCiteRegEx": null, "year": 2002}], "referenceMentions": [], "year": 2016, "abstractText": "Dung\u2019s abstract argumentation theory is a widely used formalism to model conflicting information and to draw conclusions in such situations. Hereby, the knowledge is represented by so-called argumentation frameworks (AFs) and the reasoning is done via semantics extracting acceptable sets. All reasonable semantics are based on the notion of conflict-freeness which means that arguments are only jointly acceptable when they are not linked within the AF. In this paper, we study the question which information on top of conflict-free sets is needed to compute extensions of a semantics at hand. We introduce a hierarchy of so-called verification classes specifying the required amount of information. We show that well-known standard semantics are exactly verifiable through a certain such class. Our framework also gives a means to study semantics lying inbetween known semantics, thus contributing to a more abstract understanding of the different features argumentation semantics offer.", "creator": "LaTeX with hyperref package"}}}