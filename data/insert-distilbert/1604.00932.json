{"id": "1604.00932", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "4-Apr-2016", "title": "Asking the metaquestions in constraint tractability", "abstract": "the constraint satisfaction problem ( fc csp ) involves deciding, given a set of variables and a minimum set of constraints on the variables, whether or not there is an assignment to the variables satisfying all of the constraints. one formulation of the csp is as the problem of deciding, given a pair ( g, h ) locus of various relational structures, whether or not there is a homomorphism from the first structure to the second structure. the csp is in general np - hard ; a common way to restrict this problem is to fix the second structure h, so that each structure h gives significant rise explicitly to a problem csp ( h ). the problem family csp ( h ) has been studied using purely an algebraic approach, which links the algorithmic and complexity properties of each problem csp ( h ) to a set of operations, the so - called polymorphisms of query h. certain types of polymorphisms are known to imply the polynomial - shortest time tractability of $ csp ( h ) $, and others are conjectured to do so. this article systematically studies - - - for various classes of polymorphisms - - - the computational complexity of deciding whether or not a given structure h admits a polymorphism from the class. among other results, we prove the np - completeness of deciding a condition conjectured to characterize the tractable problems csp ( ` h ), as well as the np - completeness of deciding if csp ( h ) has bounded width.", "histories": [["v1", "Mon, 4 Apr 2016 16:18:16 GMT  (953kb,D)", "https://arxiv.org/abs/1604.00932v1", null], ["v2", "Fri, 6 Jan 2017 02:55:16 GMT  (958kb,D)", "http://arxiv.org/abs/1604.00932v2", null]], "reviews": [], "SUBJECTS": "cs.CC cs.AI", "authors": ["hubie chen", "benoit larose"], "accepted": false, "id": "1604.00932"}, "pdf": {"name": "1604.00932.pdf", "metadata": {"source": "CRF", "title": "ASKING THE METAQUESTIONS IN CONSTRAINT TRACTABILITY", "authors": ["HUBIE CHEN", "BENOIT LAROSE"], "emails": [], "sections": [{"heading": "1. Introduction", "text": "The constraint satisfaction problem (CSP) involves deciding, given a set of variables and a set of constraints on the variables, whether or not there is an assignment to the variables satisfying all of the constraints. Cases of the constraint satisfaction problem appear in many fields of study, including artificial intelligence, spatial and temporal reasoning, logic, combinatorics, and algebra. Indeed, the constraint satisfaction problem is flexible in that it admits a number of equivalent formulations. In this paper, we work with the well-known formulation as the relational homomorphism problem, namely: given two similar relational structures G and H, does there exist a homomorphism from G to H? In this formulation, one can view each relation of G as containing variable tuples that are constrained together, and the corresponding relation of H as containing the permissible values for the variable tuples. In this article, we assume that all structures under discussion are finite, that is, have finite universe.\nThe constraint satisfaction problem is in general NP-hard; this general intractability has motivated the study of restricted versions of the CSP that have various desirable complexity and algorithmic properties. A natural and well-studied way to restrict the CSP is to fix the second structure H (often referred to as the right-hand side structure), which amounts to restricting the relations that can be used to specify permissible value tuples. Each structure H then gives rise to a problem CSP(H): given a structure G, decide if it has\n1\nar X\niv :1\n60 4.\n00 93\n2v 2\n[ cs\n.C C\n] 6\nJ an\n2 01\n7\na homomorphism to H; and, the resulting family of problems is a rich one that includes Boolean satisfiability problems, graph homomorphism problems, and satisfiability problems on algebraic equations. While each problem CSP(H) is in NP, for certain structures H it can be shown that the problem CSP(H) is polynomial-time decidable. Indeed, in a nowclassic result from 1978, Schaefer [42] presented a classification theorem, showing that for each structure H having a two-element universe, the problem CSP(H) is either polynomialtime decidable, or is NP-hard. Schaefer left open and suggested the research program of classifying structures having finite universe of size strictly greater than two.\nOver the past two decades, an algebraic approach to studying complexity aspects of the problem family CSP(H) has emerged. A polymorphism of a structure H with universe H is defined as a finitary operation f : Hk \u2192 H that is a homomorphism from Hk to H; note that a polymorphism of arity k = 1 is precisely an endomorphism. A cornerstone of the algebraic approach is a theorem stating that when two structures H, H\u2032 have the same polymorphisms, the problems CSP(H) and CSP(H\u2032) are polynomial-time interreducible [13].1 Intuitively, this theorem can be read as saying that the polymorphisms of a structure contain all of the information one needs to know to understand the complexity of CSP(H), at least up to polynomial-time computation. At the present, it is well-known that certain types of polymorphisms are desirable in that they guarantee polynomial-time tractability of CSP(H). As an example, it is now a classic theorem in the area that, for any structure H having a semilattice polymorphism, the problem CSP(H) is polynomial-time decidable; a semilattice polymorphism is, by definition, an arity 2 polymorphism that is associative, commutative and idempotent. Here, it should be further pointed out that a conjecture known as the algebraic dichotomy conjecture [13] predicts the polynomial-time tractability of each problem CSP(H) not satisfying a known sufficient condition for NPcompleteness, and that this conjecture can be formulated as predicting the tractability of each problem CSP(H) where H admits a certain type of polymorphism (see Conjecture 3.1 and the surrounding discussion).\nIn this article, we systematically study\u2014for various classes of polymorphisms\u2014the computational problem of deciding whether or not a given structure H admits a polymorphism from the class. This form of decision problem is often popularly referred to as a metaquestion. All of the polymorphisms that we study are either known to guarantee tractability of CSP(H), or predicted to do so by the algebraic dichotomy conjecture (see the discussion in Section 2).\nLet us overview our principal technical results.\n\u2022 We formalize and demonstrate a connection between the polynomial-time tractability of a particular type of metaquestion and the existence of a so-called uniform polynomial-time algorithm for the condition that the metaquestion asks about (Section 4).\n1In fact, under the stated assumption, the problems CSP(H) and CSP(H\u2032) are logarithmic-space interreducible [39]. Let us mention here that, under the assumption, one also has interreducibility for some other computational problems of interest, such as the quantified CSP [11, 22, 23] and various comparison problems involving primitive positive formulas [12].\n\u2022 On the positive side, we prove that the metaquestion for conservative binary commutative polymorphisms is solvable in NL, non-deterministic logspace (Section 5.2). \u2022 We prove a generic NP-hardness result that applies to the metaquestions corre-\nsponding to a range of Maltsev conditions (Section 6.1). One consequence of this result is that deciding if a given structure gives rise to a CSP with bounded width is NP-complete (Corollary 6.8); this answers a question of L. Barto [3]. Another consequence of this result is the NP-completeness of deciding if a given structure satisfies an algebraic condition which has been conjectured to characterize the structures having a tractable CSP (see Corollary 6.9). \u2022 We provide a simple proof that the metaquestion for semilattice polymorphisms is\nNP-complete (Section 6.2). \u2022 We give a general hardness result showing that, for a number of types of conserva-\ntive polymorphisms, the metaquestion is NL-hard (Section 6.3). In particular, this result applies to the metaquestion for conservative binary commutative polymorphisms, and hence provides a hardness result tightly complementing the positive result for such polymorphisms.\nWe summarize some consequences both of our results and known results in Table 1. We view the complexity study of metaquestions as a naturally motivated research topic. In general, an instance (G,H) of the CSP encountered in the wild or on the street does not, of course, come with any guarantee about the properties of the right-hand side structure H; in order to know if any of the polymorphism-based tractability results can be exploited to solve the instance, one must first detect if H has a relevant polymorphism. From this perspective, the present study can thus be viewed as an effort to bridge practice and the algebraic theory of tractability."}, {"heading": "2. Definitions, Notation and Terminology", "text": "A relational structure is a tuple H = \u3008H; \u03b81, . . . , \u03b8s\u3009 where H is a non-empty finite set and each \u03b8i is a relation of arity ri on H; the sequence r1, . . . , rs is the type of H. A relational structure is at most binary if the arity of each relation is less than or equal to 2. In this article, most of the computational problems considered take as input a relational structure; as is quite standard in the literature, we always assume that each relation of a relational structure is specified by an explicit listing of its tuples. Two structures with the same type are said to be similar. If G, H, K, ... are relational structures, we denote their respective universes by G, H, K, ... The product of similar structures is the usual one, viz. if G = \u3008G; \u03b81, . . . , \u03b8s\u3009 and H = \u3008H; \u03c11, . . . , \u03c1s\u3009 then G\u00d7H = \u3008G\u00d7H,\u03c31, . . . , \u03c3s\u3009 where \u03c3i = {((g1, h1), . . . , (gr, hr)) : (g1, . . . , gr) \u2208 \u03b8i, (h1, . . . , hr) \u2208 \u03c1i}. We denote the product of the structure H with itself k times by Hk. Given a map f : G \u2192 H and a k-tuple u = (u1, . . . , uk) \u2208 Gk, let f(u) = (f(u1), . . . , f(uk)); if \u03b8 is a k-ary relation on G then f(\u03b8) = {(f(u) : u \u2208 \u03b8}. A map f : G\u2192 H is a homomorphism from G to H if f(\u03b8i) \u2286 \u03c1i for all i = 1, . . . , s. For an integer k \u2265 1, a k-ary operation on H is a map from Hk to H.\nDefinition 2.1. Let H be a relational structure. A k-ary operation f on H is a polymorphism of H if f is a homomorphism from Hk to H; in this case, we also say that f preserves H.\nWe are concerned with polymorphisms obeying various interesting identities. In order to avoid undue algebraic technicalities, we present certain concepts in a slightly unorthodox way (for the standard equivalents, see for instance [37].)\nAn expression E of the form\nf(x1, . . . , xk) \u2248 g(y1, . . . , yn)\nis a linear identity; it is satisfied by two interpretations for f and g on a set H if, for any assignment to the variables, it holds that both sides of the identity evaluate to the same value. Without fear of confusion, we shall usually make no distinction between the operation symbols used in an identity and the actual operations satisfying it, for example, we will simply write that f and g satisfy E and so on. Note that we allow linear identities of the form f(x1, . . . , xk) \u2248 yi that is, containing only one operation symbol; such an identity can be formally viewed as an expression of the above form where one of the operations is a projection. Following [6], if a linear identity is not of this form, i.e. has explicit operation symbols on both sides, we say it has height 1.\nA strong linear Maltsev condition is a finite set of linear identities {E1, . . . , Er}. A sequence of operations f1, . . . , fm satisfies the strong Maltsev condition if it satisfies each identity Ei.2\nDefinition 2.2. Let H be a relational structure. We say that H satisfies a strong linear Maltsev condition if there exist polymorphisms of H that satisfy it.\nWe now present some strong Maltsev conditions we shall investigate. A k-ary operation f (with k \u2265 1) is idempotent if it satisfies\nf(x, x, . . . , x) \u2248 x.\nThe operation f is cyclic if it obeys\nf(x1, . . . , xk) \u2248 f(xk, x1, . . . , xk\u22121).\nIt is symmetric if, for every permutation \u03c3 of the set {1, . . . , k}, it obeys the identities\nf(x1, . . . , xk) \u2248 f(x\u03c3(1), . . . , x\u03c3(k)).\nIt is totally symmetric (TS) if, whenever {x1, . . . , xk} = {y1, . . . , yk}, it satisfies the identity\nf(x1, . . . , xk) \u2248 f(y1, . . . , yk).\n2 The standard definition of Maltsev conditions concerns varieties of algebras. The modifier \u201cstrong\u201d refers to the fact that set of identities is finite, as opposed to a condition as in Lemma 3.9 below.\nNotice that f TS \u21d2 f symmetric \u21d2 f cyclic\nand that, for a binary operation, the properties of being commutative, TS, symmetric, and cyclic all coincide.\nFor k \u2265 3, the operation f is a near-unanimity (NU) operation if it obeys the identities f(x, . . . , x, y, x, . . . , x) \u2248 x\nfor any position of the lone y. A 3-ary NU operation is called a majority operation. A 3-ary operation f is Maltsev if it obeys the identities\nf(y, y, x) \u2248 f(x, y, y) \u2248 x. A 4-ary operation f is Siggers if it is idempotent and satisfies the identity\nf(a, r, e, a) \u2248 f(r, a, r, e). We shall also require the following conditions on operations, which are not presented by\nlinear identities. The k-ary operation f is conservative if it satisfies\nf(x1, . . . , xk) \u2208 {x1, . . . , xk} for all xi. A semilattice operation is an associative, idempotent, commutative binary operation.\nWe now gather some well-known implications involving the special polymorphisms defined here; as some of these results are folklore, we give general references only [18, 43, 36, 37].\nProposition 2.3. If a structure admits an idempotent polymorphism f which is cyclic, TS, symmetric, NU, or Maltsev then it admits a Siggers polymorphism; moreover, in each case, if f is conservative, so is the Siggers polymorphism."}, {"heading": "3. Known/Preliminary Results", "text": "Let H be a relational structure. We denote by CSP(H) the set of finite structures that admit a homomorphism to H. The problem CSP(H) is clearly in NP. The dichotomy conjecture of Feder and Vardi, that states that every CSP(H) is either tractable or NPcomplete, has been the source of intense scrutiny over the past two decades, see for instance [2, 7] and the surveys [17, 18]. A very deep theory has been developed, relating the nature of the identities satisfied by the polymorphisms of the structure H and the complexity of the associated constraint satisfaction problem. Simplifiying to the extreme, the theory states that, the nicer the identities, the easier the problem is.\nWe say the structure R is a retract of the structure H if there exist homomorphisms r : H\u2192 R and e : R\u2192 H such that r \u25e6 e is the identity on R. A structure H is a core if the only homomorphisms from H to itself are automorphisms, or equivalently, if the structure has no proper retract. The retracts of minimal size of a finite relational structure H are cores, and are all isomorphic to each other; we refer to these retracts as the cores of H, and due to their being mutually isomorphic, by a slight abuse we speak of the core of a structure. Obviously if H\u2032 is the core of H then CSP(H) = CSP(H\u2032). It is known that\nfor a core H, the problem CSP(H) is interreducible with the problem CSP(H\u0302) where the structure H\u0302 is obtained by expanding the structure H with all one-element unary relations (sometimes called constants in this context). Here, interreducibility can actually be proved with respect to first-order reductions [39]. As such a structure H\u0302 has only idempotent polymorphisms (indeed, it is straightforwardly verified that the polymorphisms of H\u0302 are precisely the idempotent polymorphisms of H), for many complexity issues on the problem family CSP(G), one can restrict attention to idempotent algebras, which are known to have good behavior. Note also that, up to logspace interreducibility, we can assume the equality relation is also a relation of a structure H where CSP(H) is under study [13]. Finally, the following is immediate: a structure H admits a conservative operation f satisfying some identities if and only if the structure H\u2032 obtained from H by adding all non-empty subsets as basic relations admits an operation satisfying those same identities.\nThe following is one of many possible formulations of a refinement of the dichotomy conjecture, due to Bulatov, Jeavons and Krokhin [13] (see also [37]):\nConjecture 3.1. If the core of a relational structure H admits a Siggers polymorphism, then CSP(H) is tractable.\nA form of converse to this statement is known to hold, namely, it holds that a structure whose core has no Siggers polymorphism has an NP-complete CSP [13].\nLet us remark here that the conservative case was completely settled by Bulatov:\nTheorem 3.2. [16] If a relational structure admits a conservative Siggers polymorphism then its CSP is tractable.\nIn the rest of this section, we will focus on CSP\u2019s satisfying a condition called bounded width. Most known tractable CSP\u2019s can be grouped roughly into two distinct families: bounded width and few subpowers. Few subpowers problems [21, 32] generalize linear equations and are solvable by an algorithm with many properties in common with Gaussian elimination. In particular, structures admitting a Maltsev or near-unanimity polymorphism have this property. However, in general, the algorithms involved require explicit knowledge of the polymorphisms that witness the condition of few subpowers. In contrast, recent results on CSPs of bounded width show that they are actually solvable by an algorithm that is uniform in the sense that it needs no such explicit knowledge of the polymorphisms. This form of uniformity has important consequences for the metaproblem. We now discuss this in more detail.\nIn order to present the required algorithm, it will convenient to view CSPs in a slightly different way; the fact that both approaches are equivalent is well-known and easy to verify. We essentially follow [3]. Let us introduce some notation. If f is a function with domain D and W \u2286 D, let f |W denote the restriction of f to W . Similarly, if C \u2286 HD is a family of functions with domain D, let C|W = {f |W : f \u2208 C}.\nAn instance of the CSP is a triple I = (V,H, C) where \u2022 V is a non-empty, finite set of variables,\n\u2022 H is a nonempty finite set of values, \u2022 C is a finite nonempty set of constraints, where each constraint is a subset C of HW ; W is a subset of V called the scope of the constraint, and |W | is called the arity of the constraint.\nA solution of the instance is a map f : V \u2192 H such that, for every constraint C with scope W , we have f |W \u2208 C.\nIf W = {x1, . . . , xk} we can associate naturally a k-ary relation \u03b8 to each subset C of HW by setting \u03b8 = {f(x1), . . . , f(xk)) : f \u2208 C} (this depends of course on the ordering of W chosen.) In this way, one can restrict the nature of the constraints involved in instances by stipulating that their associated relations belong to some fixed set; it follows that we can view the problem CSP(H) as a set of instances of the form just described.\nLet 1 \u2264 k \u2264 l. Consider the following polynomial-time algorithm that transforms an instance into a so-called (k, l)-minimal instance: The (k, l)-minimality algorithm.\n\u2022 For each l-element set W \u2286 V , add a \u201cdummy\u201d constraint HW (this is to ensure every l-element set of variables is contained in the scope of some constraint); \u2022 Repeat the following process until it stabilises: for every subset W \u2286 V of size at\nmost k, and every pair of constraints C1 and C2 whose scope contains W , remove from C1 and C2 any function such that f |W 6\u2208 C1|W \u2229 C2|W .\nIt is easy to see that the instance obtained is equivalent to the original, in the sense that they have the same solutions. In particular, if the output instance has an empty constraint then the original instance had no solution. On the other hand, if one does not obtain an empty constraint, there is no guarantee the original instance has a solution.\nDefinition 3.3. The problem CSP(H) has relational width (k, l) if the (k, l)-minimality algorithm correctly decides it, that is, if the (k, l)-minimality algorithm detects an empty constraint whenever the input is a no instance. We say the problem CSP(H) has bounded width if it has relational width (k, l) for some 1 \u2264 k \u2264 l.\nThe cores H whose CSP have bounded width were characterized by Barto and Kozik [4]; the following description is known.\nDefinition 3.4. Let us say that a pair of operations v, w are BW operations if v is 3-ary, w is 4-ary, and they satisfy the following identities:\n\u2022 v(y, x, x) \u2248 w(y, x, x, x) \u2022 v(y, x, x) \u2248 v(x, y, x) \u2248 v(x, x, y) \u2022 w(y, x, x, x) \u2248 w(x, y, x, x) \u2248 w(x, x, y, x) \u2248 w(x, x, x, y)\nTheorem 3.5. [4, 37] Let H be a core. The problem CSP(H) has bounded width if and only if H has idempotent polymorphisms v and w that are BW operations.\nIt turns out that problems of bounded width are precisely those solvable by a Datalog program; and the problems solvable by a monadic Datalog program are precisely those of relational width (1, l) for some l, i.e. problems of width 1. Let us here observe the following fact.\nProposition 3.6. Let H and H\u2032 be homomorphically equivalent structures. The problem CSP(H) has bounded width if and only if the problem CSP(H\u2032) does. In particular, for any structure H, let C denote its core; the problem CSP(H) has bounded width if and only if the problem CSP(C) does.\nOne way to prove this fact is to use the just-mentioned characterization of bounded width via Datalog programs; a Datalog program only processes the input structure G (and not the right-hand side structure), so the fact follows from this characterization and the fact that CSP(H) = CSP(H\u2032) (when H,H\u2032 are homomorphically equivalent).\nThe following result due to Barto also implies the Datalog hierarchy collapses, in that every problem of bounded width can be solved using the (2, 3)-minimality algorithm.\nTheorem 3.7 ([3]). For every relational structure H, exactly one of the following holds: (1) CSP(H) has width 1; (2) CSP(H) has relational width (2, 3) but not width 1; (3) CSP(H) does not have bounded width.\nThe next result is a slight generalisation of Corollary 8.4 of [3]; we include its proof here as it is quite simple, clever and instructive. Recall from Section 3 that the structure H\u0302 is obtained by expanding the structure H with all one-element unary relations.\nLemma 3.8. (Barto, Kozik, Maroti, unpublished) Let {E1, . . . , Er} be a strong linear Maltsev condition and let C be a class of structures such that, if H \u2208 C is a structure satisfying {E1, . . . , Er} then CSP(H\u0302) has bounded width. There exists a polynomial-time algorithm that, given as input a structure in C, decides if the structure satisfies {E1, . . . , Er}.\nProof. Given a structure H \u2208 C, we set up an instance of CSP(H\u0302) to encode the existence of the required polymorphisms as follows: the universe of our instance is the disjoint union of Hr1 , . . . ,Hrs where the ri are the arities of the different operation symbols in the Maltsev condition. We add equality constraints for the required identities, i.e. if f(x1, . . . , xk) \u2248 g(y1, . . . , yn) is an identity of our condition, we identify every pair of tuples satisfying it in the copies corresponding to f and g. Similarly, we add the necessary unary constraints corresponding to identities of the form f(x1, . . . , xk) \u2248 yi. Now we run the (2,3)-consistency algorithm on this instance. If it answers no, then H does not satisfy the condition (since by hypothesis if it did the consistency algorithm could not give a false positive). Otherwise, select an element of the instance, and a value of H, fixing the value of the solution on the element to this value. We run the (2,3)-consistency algorithm on this new instance. Looping on all possible values of H, we reject if there is no satisfying value. Otherwise, we keep this value, and repeat the procedure with all other elements of the instance. If this process terminates without rejecting, we have a fully-defined sequence of operations satisfying the condition.\nWe observe the following corollaries of the preceding lemma, combined with the following result.\nLet t be a k-ary operation on the set H and let A be a k \u00d7 k matrix with entries in H. We write t[A] to denote the k \u00d7 1 matrix whose entry on the i-th row is the value of f applied to row i of A.\nLemma 3.9 ([5], Theorem 1.3). Let t be a k-ary idempotent polymorphism of H satisfying: t[A] = t[B] where A and B are k \u00d7 k matrices with entries in {x, y} such that aii = x and bii = y for all i and aij = bij for all i 6= j. Then CSP(H\u0302) has bounded width.\nCorollary 3.10. There exists a polynomial-time algorithm that, given a core structure H, decides if CSP(H) has bounded width.\nProof. Let M be the strong linear Maltsev condition that asserts that v and w are idempotent BW operations. Note that for any core H, the structure H\u0302 is also a core, and that H satisfies M if and only if H\u0302 satisifes M. Let C be the class of all cores. Then, the hypothesis of Lemma 3.8 is satisfied: for any core H satisfying M, it holds that H\u0302 is also a core that satisfies M, and thus that CSP(H\u0302) has bounded width by Theorem 3.5. The result of Lemma 3.8 thus gives the desired algorithm, since a core has bounded width if and only if it satisfies M, by Theorem 3.5.\nCorollary 3.11. For each k \u2265 3, there exists a polynomial-time algorithm that decides if a given structure has a k-near unanimity polymorphism.\nProof. The presence of such a polymorphism is formulable as a strong linear Maltsev condition. If a structure H has a k-near unanimity polymorphism, so does H\u0302 (as such a polymorphism is idempotent by definition); in this case, it is known that CSP(H\u0302) has bounded width. This was proved first in [33], and also follows from Lemma 3.8, using the following matrices: A is the matrix with all x\u2019s, and B is obtained from A by placing y\u2019s on the diagonal. The result thus follows from Lemma 3.8.\nCorollary 3.12. Let k \u2265 3. Deciding if a structure admits a k-ary idempotent TS polymorphism is in P.\nProof. Let f be a k-ary idempotent TS operation, k \u2265 3. Then it satisfies the following identities:\nf(x, y, x, . . . , x) \u2248 f(y, y, x, . . . , x) f(x, x, y, . . . , x) \u2248 f(x, y, y, x, . . . , x)\n\u00b7 \u00b7 \u00b7 f(y, x, . . . , x, x) \u2248 f(y, x, . . . , x, y)\nand hence by the last lemma the conditions of Lemma 3.8 are satisfied.\nThe following lemma was first proved by Bulatov and Jeavons. We include a streamlined proof, as we believe that it may be of independent interest.\nLemma 3.13. [15] Let H be a relational structure that admits a binary conservative commutative polymorphism. Then CSP(H) has bounded width.\nProof. The proof follows the very same strategy as case (2) of Theorem 4.1 of [39]; we refer the reader to this proof for full details. Suppose H has a binary conservative commutative polymorphism t but CSP(H) does not have bounded width. Combining the results of [2], [45], and [46], there exists a subset C of H, |C| \u2265 2, such that that every polymorphism of H restricted to C preserves the relation \u03c1 = {(a, b, c) : a + b = c} for some Abelian group structure on C. Pick an element c 6= 0 in C. Then (0, c, c), (c, 0, c) \u2208 \u03c1 implies that t(0, c) + t(c, 0) = t(c, c) = c. Since c 6= 0 and t is commutative and conservative it follows that t(0, c) = t(c, 0) = c. But then c+ c = c which implies c = 0, a contradiction.\nCorollary 3.14. Let k be a positive even integer. There is a polynomial-time algorithm to decide whether a relational structure H admits a conservative, cyclic polymorphism of arity k; the same result holds for conservative, symmetric polymorphisms.\nProof. We prove the result for cyclic polymorphisms; the symmetric case is identical. Determining if a structure H admits a conservative cyclic polymorphism of arity k is clearly equivalent to determining if the structure H\u2032 obtained from H by adding all non-empty subsets of the universe as unary relations admits a k-ary cyclic polymorphism. Furthermore, notice that if a structure admits a conservative cyclic polymorphism f of even arity, then it admits one of arity 2 by identifying variables: g(x, y) = f(x, . . . , x, y, . . . , y) in the obvious way. Thus by Lemma 3.13, we can apply Lemma 3.8 with C the class of conservative structures.\nIt is interesting to note the following consequence of Lemma 3.8: on the class of digraphs, deciding the existence of a Maltsev polymorphism is tractable. Indeed, by a result of Kazda [35], if a digraph admits a Maltsev polymorphism it also has a majority polymorphism; since the existence of a near-unanimity polymorphism implies the CSP has bounded width (this is as an easy exercise using Lemma 3.9), the result follows from Lemma 3.8.\nAs another example of a class of structures where Lemma 3.8 can be invoked, consider the class of conservative, at most binary structures, i.e. structures whose basic relations are at most binary and include all non-empty subsets of the universe as unary relations. Kazda has proved [34] that if such a structure admits a Siggers polymorphism (i.e. if the CSP is tractable), then in fact the CSP has bounded width; the following is a consequence of this and Lemma 3.8.\nTheorem 3.15. Let M be a strong linear Maltsev condition such that, if a structure H admits a conservative polymorphism satisfying M then H admits a Siggers polymorphism. Then it is polynomial-time decidable if an at most binary structure admits a conservative polymorphism satisfying M."}, {"heading": "4. Uniformity and metaquestions", "text": "We saw in the previous section that (2, 3)-consistency is a generic polynomial-time algorithm that uniformly solves all problems CSP(H) of bounded width. In this section, we formalize and study notions of uniform polynomial-time algorithms, for a Maltsev condition, and observe a direct relationship between the existence of a uniform polynomial-time algorithm, for a Maltsev condition, and the corresponding metaquestion for the condition\n(see Theorem 4.7 for a precise statement). This relationship, as will be made evident, generalizes Lemma 3.8 in a certain sense. We also mention that it seems to have been a matter of folklore that such a relationship held; in particular, the consequence noted in Example 4.8 below was previously communicated to us by M. Valeriote.\nDefinition 4.1. Let C be a class of finite structures. A uniform polynomial-time algorithm for C is a polynomial-time algorithm that, for each CSP instance (G,H) with H \u2208 C, correctly decides the instance.\nExample 4.2. Barto\u2019s collapse result (Theorem 3.7) shows that the (2,3)-minimality algorithm is a uniform polynomial-time algorithm for the class C of structures H such that CSP(H) has bounded width.\nDefinition 4.3. Let M be a strong linear Maltsev condition. \u2022 A uniform polynomial-time algorithm for M is a uniform polynomial-time algo-\nrithm for the class of structures satisfying M. \u2022 A semiuniform polynomial-time algorithm for M is a polynomial-time algorithm\nthat, when given as input a CSP instance (G,H) and polymorphisms f1, . . . , fm of H that satisfy M, correctly decides the CSP instance.\nExample 4.4. Let M be the strong linear Maltsev condition {f(y, y, x) = x, f(x, y, y) = x}, which asserts that f is a Maltsev operation. The algorithm due to [14] is readily verified to be a semiuniform polynomial-time algorithm for M.\nDefinition 4.5. Let M be a strong linear Maltsev condition. \u2022 Define the metaquestion for M to be the problem of deciding, given a structure H,\nwhether or not H satisfies M. \u2022 Define the creation-metaquestion for M to be the problem where the input is a\nstructure H, and the output is a sequence f1, . . . , fm of polymorphisms of H that satisfy M in the case that H satisfies M, and \u201cno\u201d otherwise.\nWe note the following observation.\nProposition 4.6. LetM be a strong linear Maltsev condition. If the creation-metaquestion for M is polynomial-time computable, then so is the metaquestion for M.\nThe following theorem is the main theorem of this section. It connects the existence of a uniform polynomial-time algorithm for a Maltsev condition to the existence of a semiuniform polynomial-time algorithm and the tractability of the creation-metaquestion. We say that a strong linear Maltsev condition M is idempotent if if it contains or entails the identity f(x, . . . , x) = x for each operation symbol f appearing in M.\nTheorem 4.7. Let M be a strong linear Maltsev condition. \u2022 If the creation-metaquestion for M is polynomial-time computable and M has\na semiuniform polynomial-time algorithm, then the condition M has a uniform polynomial-time algorithm. \u2022 When M is idempotent, the converse of the previous statement holds.\nProof. For the first claim, the polynomial-time algorithm is this. Given a pair (G,H), invoke the algorithm for the creation-metaquestion; if a sequence f1, . . . , fm of polymorphisms is returned, then invoke the semiuniform polynomial-time algorithm on the pair (G,H) and the polymorphisms f1, . . . , fm, and output the result.\nWe now prove the second claim. Assume that M is idempotent and has a uniform polynomial-time algorithm. It follows immediately thatM has a semiuniform polynomialtime algorithm. The algorithm for the creation-metaquestion (for M) is the algorithm of Lemma 3.8, but where instead of invoking the (2, 3)-consistency algorithm, one invokes the uniform polynomial-time algorithm for M.\nExample 4.8. Consider, as an example, the condition M from Example 4.4. Theorem 4.7 implies that, for this condition, the existence of a polynomial-time algorithm for the creation-metaquestion is equivalent to the existence of a uniform polynomial-time algorithm.\nThe following corollary, which exhibits a hypothesis under which a uniform polynomialtime algorithm immediately implies tractability of a metaquestion, is immediate from Theorem 4.7 and Proposition 4.6.\nCorollary 4.9. Let M be a strong linear Maltsev condition that is idempotent. If M has a uniform polynomial-time algorithm, then the metaquestion for M is polynomial-time computable."}, {"heading": "5. Positive complexity results", "text": "5.1. Set polymorphisms. We begin by studying set polymorphisms.\nDefinition 5.1. Let H be a relational structure. Define on P(H)\\\u2205 a relational structure, the power structure P(H), of the same type as follows: if \u03b8 is a basic relation of H of arity k, declare (X1, . . . , Xk) \u2208 \u03b8\u2032 if, for every 1 \u2264 i \u2264 k and every a \u2208 Xi, there exists a tuple (x1, . . . , xk) \u2208 \u03b8 \u2229 \u220fk i=1Xi such that xi = a. A homomorphism from this structure to H is called a set polymorphism of H. We\u2019ll say a set polymorphism f is idempotent if f({x}) = x for all x \u2208 H.\nThe presence of a set polymorphism admits multiple characterizations.\nLemma 5.2. [28, 30] Let H be a relational structure. Then, the following are equivalent: (1) H has a set polymorphism; (2) there is a map f : P(H) \\ \u2205 \u2192 H such that, for every m \u2265 1, the operation defined\nby fm(x1, . . . , xm) = f({x1, . . . , xm}) is a polymorphism of H. (3) H admits TS polymorphisms of all arities. (4) CSP(H) has width 1.\nWe now observe that detecting a set polymorphism can be performed in EXPTIME. Note that this improves the naive complexity upper bound of NEXPTIME, which is obtained by constructing the structure defined in Definition 5.1, nondeterministically guessing a map to the given structure H, and then checking if the map is a homomorphism.\nProposition 5.3. Deciding if a relational structure admits a set polymorphism is in EXPTIME.\nProof. Notice that a structure H has a set polymorphism if and only if its core has an idempotent set polymorphism (see also the proof of Lemma 6.4). Indeed, let R denote the core of H, with R \u2286 H, and let r be a retraction of H onto R, i.e. r is an onto homomorphism and r(x) = x for all x \u2208 R. If f is a set polymorphism of H, then it is easy to see that the restriction g of r\u25e6f to subsets of R is a set polymorphism for R. Notice also that the one element sets {x} with x \u2208 R induce an isomorphic copy of R in P(R); since R is a core the restriction of g to this substructure induces an automorphism \u03c3 of R; then \u03c3\u22121 \u25e6 g is an idempotent set polymorphism of R. Conversely, if g is a set polymorphism of R, then define a set function f on H by f(X) = g ({r(x) : x \u2208 X}). It is straightforward to verify that f is a set polymorphism for H.\nSo now we proceed as follows: we first find the core of H. Loop over all mappings f : H \u2192 H, but in a fashion that increases the cardinality of the size of the image of f . Check each mapping for being an endomorphism; once an endomorphism is found, the image of the original structure under the endomorphism is a core. This computation can be done in PSPACE and hence in EXPTIME.\nNow that we have the core R of H, we can test, in EXPTIME, if it admits an idempotent set polymorphism, in the manner of Lemma 3.8: indeed, if the set polymorphism exists, and since R is a core, then CSP(R\u0302) has bounded width; using the power structure P(R) as our instance, and fixing values one at a time, we shall either reject or eventually obtain a candidate set function which we can test for being a polymorphism.\nAs seen (Lemma 5.2), detecting for a set polymorphism is equivalent to checking for the presence of TS polymorphisms of all arities. In the quest to improve the complexity upper bound just given, a natural question that one might ask is whether or not it suffices to check for TS polymorphisms up to some bounded arity, in order to ensure TS polymorphisms of all arities. The following proposition answers this question in the negative.\nProposition 5.4. For every prime p \u2265 3, there exists a digraph H with p vertices that admits TSI polymorphisms of all arities strictly less than p but no TS (in fact, no cyclic) polymorphism of arity p.\nProof. Consider the directed cycle of length p, i.e. vertices {0, 1, . . . , p\u22121} and arcs (i, i+1) for all i (modulo p). Since this digraph has no loop, it cannot admit a cyclic polymorphism of arity p because there is an arc from f(0, 1, \u00b7 \u00b7 \u00b7 , p \u2212 1) to f(1, 2, \u00b7 \u00b7 \u00b7 , p \u2212 1, 0). On the other hand, if 2 \u2264 k < p, define an operation f as follows: given a tuple (x1, . . . , xk), let xi1 , . . . , xit be the distinct representatives of the set {x1, . . . , xk}. Since 1 \u2264 t < p, it admits a multiplicative inverse t\u22121 modulo p. Then set\nf(x1, \u00b7 \u00b7 \u00b7 , xk) = t\u22121(xi1 + \u00b7 \u00b7 \u00b7+ xit)\nwhere the sum is modulo p. It is straightforward to verify that this is a TSI polymorphism of the cycle.\n5.2. Conservative commutative polymorphisms. We now prove an NL upper bound on the detection of conservative commutative polymorphisms. Note that detecting such polymorphisms can be performed in polynomial time, by Corollary 3.14. However, the algorithm thusly given itself relies on the fact that a CSP having a commutative conservative polymorphism is decidable in polynomial-time; note that such a CSP can be complete for polynomial time (this occurs even in the case of the polymorphisms \u2227 and \u2228 on the domain {0, 1}, see for example [1]). We believe that the present result is thus interesting as it improves this polynomial-time upper bound.\nTheorem 5.5. Deciding if a structure admits a conservative binary commutative polymorphism is solvable in non-deterministic logspace.\nIn the scope of this proof, we refer to a conservative binary commutative function as a cc-operation. For a binary operation f : D2 \u2192 D, and a 2-element subset C = {c, c\u2032} of D, we will use the notation f(C) = d to indicate that f(c, c\u2032) = f(c\u2032, c) = d; also, if f is a cc-operation, we will use f(C) to denote the value f(c, c\u2032) = f(c\u2032, c).\nProof. Throughout, S will denote a relation of the structure, and D will denote the domain of the structure. For each relation S of the structure and each pair of tuples s, s\u2032 \u2208 S, define Ss,s\n\u2032 to be the relation {t \u2208 S | ti \u2208 {si, s\u2032i} for all i }. We claim that for a relation S of the structure, a cc-operation f preserves S if and only if, for each s, s\u2032 \u2208 S, it preserves Ss,s \u2032 . For the forward direction, let r, r\u2032 \u2208 Ss,s\u2032 . It holds that f(r, r\u2032) \u2208 S. But since ri, r \u2032 i \u2208 {si, s\u2032i} for all i, it holds by the conservativity of f that f(ri, r\u2032i) \u2208 {si, s\u2032i} for all i, and so f(r, r\u2032) \u2208 Ss,s\u2032 . For the backward direction, suppose that r, r\u2032 \u2208 S. It holds, by assumption, that f(r, r\u2032) \u2208 Sr,r\u2032 . But since Sr,r\u2032 \u2286 S, we have f(r, r\u2032) \u2208 S.\nNow define Ss,s \u2032,\u2212 to be the relation obtained from Ss,s \u2032 by projecting out each coordinate i such that the projection \u03c0i(S s,s\u2032) contains just one element. Let s\u2212, s\u2032\u2212 be the tuples in Ss,s \u2032,\u2212 corresponding to s and s\u2032, respectively; so, for each i it holds that \u03c0i(S\ns,s\u2032,\u2212) = {s\u2212i , s \u2032\u2212 i }. As any cc-operation is idempotent, we have that a cc-operation preserves all of the relations Ss,s \u2032 if and only if it preserves all of the relations Ss,s \u2032,\u2212. By the claim of the previous paragraph, we obtain: Claim 1: A cc-operation preserves the relations of the structure if and only if it preserves all of the relations Ss,s \u2032,\u2212.\nFor each relation Ss,s \u2032,\u2212 and each tuple r \u2208 Ss,s\u2032,\u2212, define gr : D2 \u2192 D to be the partial operation where gr(\u03c0i(S s,s\u2032,\u2212)) = ri for each i, and gr(d, d) = d for each d \u2208 D. Each cc-operation f that preserves Ss,s \u2032,\u2212 must map the tuples s\u2212, s\u2032\u2212 to a tuple r \u2208 Ss,s\u2032,\u2212; hence, we obtain that such an f must be an extension of gr, for some tuple r \u2208 Ss,s \u2032,\u2212. But observe that when such an f extends such a gr, it holds that the partial operation gr itself preserves Ss,s \u2032,\u2212. Define [Ss,s \u2032,\u2212] to be the subset of Ss,s \u2032,\u2212 which contains a tuple r \u2208 Ss,s\u2032,\u2212 if and only if gr preserves Ss,s \u2032,\u2212. We thus obtain the following.\nClaim 2: A cc-operation f preserves Ss,s \u2032,\u2212 if and only if there exists a tuple r \u2208 [Ss,s\u2032,\u2212] such that f extends gr. Suppose, for the remainder of the proof, that the domain D of the structure is a subset of the integers. Consider a relation [Ss,s \u2032,\u2212] of arity k. Each tuple r \u2208 [Ss,s\u2032,\u2212] can be\nnaturally mapped to a tuple r\u2217 in {n, x}k, where r\u2217i is equal to n or x depending on whether or not ri is the min or max of \u03c0i(S s,s\u2032,\u2212). Define [Ss,s \u2032,\u2212]\u2217 = {r\u2217 | r \u2208 Ss,s\u2032,\u2212}. In an analogous fashion, each cc-operation f : D2 \u2192 D can be naturally viewed as an operation f\u2217 : ( D 2 ) \u2192 {n, x}, defined, for each C \u2208 ( D 2 ) , by f\u2217(C) = n or x depending on whether f(C) = min(C) or f(C) = max(C). From this discussion and the first two claims, we obtain the following. Claim 3: A cc-operation f preserves the structure if and only if it holds that, for each relation Ss,s \u2032,\u2212 (of arity k), the tuple (f\u2217(\u03c01(S s,s\u2032,\u2212)), . . . , f\u2217(\u03c0k(S s,s\u2032,\u2212))) is in [Ss,s\n\u2032,\u2212]\u2217. We now observe the following. Claim 4: Each relation of the form [Ss,s\n\u2032,\u2212]\u2217 is closed under the majority operation m on {n, x}.\nWe prove this claim as follows. Set (C1, . . . , Ck) = (\u03c01(S s,s\u2032,\u2212), . . . , \u03c0k(S s,s\u2032,\u2212)). Let t1, t2, t3 be arbitrary tuples in [Ss,s \u2032,\u2212]\u2217, and let r1, r2, r3 be the corresponding tuples in [Ss,s \u2032,\u2212]. Set t = m(t1, t2, t3), and let r be the tuple over D that corresponds to t. We show that for any Cj , it holds that gr(Cj) = gr3(gr1(Cj), gr2(Cj)), which suffices (via the definition of [Ss,s \u2032,\u2212]): gr is then obtainable by composing the gri , implying that gr preserves Ss,s \u2032,\u2212. We verify the identity as follows.\n\u2022 If t1j = t2j , then tj = t1j = t2j and gr(Cj) = gr1(Cj) = gr2(Cj); thus this last value is equal to gr3(gr1(Cj), gr2(Cj)), by the idempotence of gr3 . \u2022 If t1j 6= t2j , then tj = t3j . We have {gr1(Cj), gr2(Cj))} = Cj , and so gr3(gr1(Cj), gr2(Cj)) = g3r (Cj).\nTo determine whether or not there exists a cc-operation f that preserves the original structure, by Claim 3, one may determine whether or not the following CSP instance has a solution. The variable set is {XC | C \u2208 ( D 2 ) }, where the variable XC represents the value f\u2217(C); for each relation of the form Ss,s \u2032,\u2212 (of arity k), there is a constraint stating that the variable tuple (X\u03c01(Ss,s\u2032,\u2212), . . . , X\u03c0k(Ss,s\u2032,\u2212)) must be mapped to a value in [S s,s\u2032,\u2212]\u2217. By Claim 4, each of these relations is preserved by the majority operation m, and it is known that one can decide in NL all CSP instances on a two-element domain with a majority polymorphism [1].\nHence, it suffices to argue that each of the relations [Ss,s \u2032,\u2212]\u2217 can be computed in logspace. To compute these relations, the algorithm loops over each relation S and each pair s, s\u2032 \u2208 S. For each tuple t \u2208 S, it checks to see if the tuple t\u2212 \u2208 Ss,s\u2032,\u2212 corresponding to t has the property that gt\u2212 preserves S\ns,s\u2032,\u2212; in the affirmative case, it holds that t\u2212 is in [Ss,s\n\u2032,\u2212], and so the algorithm outputs (t\u2212)\u2217. The check can be carried out in logspace as follows. Let k denote the arity of S. The algorithm loops over all pairs of tuples u, u\u2032 in Ss,s \u2032 ; for each such pair, the algorithm loops on i = 1, . . . , k; for each value of i, it attempts to find a tuple in Ss,s \u2032 that is equal to gt\u2212(u, u \u2032) on the first i coordinates, and store a pointer to such a tuple. For a particular value of i, it can loop over all tuples in Ss,s \u2032\nand, for those having the correct value in the ith coordinate, it can check for correctness in the first i\u2212 1 coordinates by comparing with the tuple obtained after the i\u2212 1th iteration."}, {"heading": "6. Complexity hardness results", "text": "In this section we prove various hardness results for the existence of \u201cgood\u201d polymorphisms on finite structures.\n6.1. A generic NP-hardness result for Maltsev conditions. We here give a rather general result that applies to a wide range of Maltsev conditions. In order to present the theorem statement, we introduce the following definitions.\nDefinition 6.1. Let M be a strong, linear Maltsev condition. \u2022 We say that M is non-trivial if, on a domain with at least 2 elements, no tuple of\nprojections can satisfy it. \u2022 M is of height 1 if its identities all have height 1. \u2022 We\u2019ll sayM is consistent if for every non-empty finite set D, there exist idempotent\noperations on D that satisfy M.\nThe following is the statement of the main theorem proved in this subsection.\nTheorem 6.2. LetM be a non-trivial, consistent, strong linear Maltsev condition of height 1. The problem of deciding if a relational structure satisfies M is NP-complete (even when restricted to at most binary relational structures).\nIn order to present some examples of Maltsev conditions to which Theorem 6.2 applies, we introduce the following definition.\nDefinition 6.3. LetM be a strong, linear Maltsev condition. LetMq be the strong, linear Maltsev condition obtained fromM by replacing every identity of the form f(xi1 , . . . , xin) \u2248 xij by the identity f(xi1 , . . . , xin) \u2248 f(xij , . . . , xij ).\nIf M is the Maltsev condition defining Siggers (Maltsev, k-NU, ...), we\u2019ll say that an operation satisfying Mq is quasi-Siggers (Maltsev, k-NU, ...).\nOur reason for introducing (for example) quasi-Maltsev operations is this. As mentioned, it is known that a structure H and its core H\u2032 each give rise to the same CSP, that is, CSP(H) = CSP (H\u2032). Hence, if the core H\u2032 has a polymorphism known to imply tractability of CSP(H\u2032), such as a Maltsev polymorphism, it follows that the problem CSP(H) is also tractable. As the following lemma implies, the assertion that a structure has a quasiMaltsev polymorphism characterizes precisely when its core has a Maltsev polymorphism, and hence precisely characterizes the sufficient condition for tractability just described. We remark that the notion of quasi- versions of operations has been previously considered in the literature, in particular, within the context of infinite-domain constraint satisfaction; see for example [8, 9].\nIt is probable that some version of the following lemma is implicit in the literature (see also [6]). At any rate, its proof is straightforward.\nLemma 6.4. Let B be a relational structure and letM be a strong linear Maltsev condition. The following are equivalent:\n(1) B satisfies Mq;\n(2) The core of B satisfies M; (3) The core of B satisfies M via idempotent operations.\nProof. Let C denote the core of B and let r be a retraction of B onto C. (1) =\u21d2 (3): Let f1, . . . , fs be polymorphisms of B that satisfy Mq. For each i = 1, . . . , s let gi denote the restriction of r \u25e6 fi to C and let \u03c3i(c) = gi(c, . . . , c) for all c \u2208 C. Since C is a core, each \u03c3i is an automorphism of C; we claim that the polymorphisms \u03c3\u22121i \u25e6 gi of C are idempotent and satisfy M. The first claim is immediate. Let fi(xi1 , . . . , xin) \u2248 fj(xj1 , . . . , xjm) be in M. Notice first that, if we fix c \u2208 C and set xk = c for all k, then fi(c, . . . , c) = fj(c, . . . , c), so \u03c3i = \u03c3j . It follows that if aik , ajl are elements of C then \u03c3\u22121i \u25e6gi(ai1 , . . . , ain) = \u03c3 \u22121 i \u25e6r\u25e6fi(ai1 , . . . , ain) = \u03c3 \u22121 j \u25e6r\u25e6fj(aj1 , . . . , ajm) = \u03c3 \u22121 i \u25e6gj(aj1 , . . . , ajm).\nNow consider an identity of M of the form fi(xi1 , . . . , xin) \u2248 xij . Since the fi satisfy Mq, if we set xik = aik \u2208 C we have that\nfi(ai1 , . . . , ain) = fi(aij , . . . , aij )\nand hence we obtain\n\u03c3\u22121i \u25e6gi(ai1 , . . . , ain) = \u03c3 \u22121 i \u25e6r\u25e6fi(ai1 , . . . , ain) = \u03c3 \u22121 i \u25e6r\u25e6fi(aij , . . . , aij ) = \u03c3 \u22121 i \u25e6\u03c3i(aij ) = aij .\n(3) =\u21d2 (2) is trivial. (2) =\u21d2 (1): If g1, . . . , gs are polymorphisms of C satisfying M, for each i = 1, . . . , s let fi = gi(r(x1), . . . , r(xn)) (where n is the arity of gi). Clearly these are polymorphisms of B, and it is immediate that they satisfy every identity in Mq which belongs to M. Now consider an identity of Mq of the form fi(xi1 , . . . , xin) \u2248 fi(xij , \u00b7 \u00b7 \u00b7 , xij ), obtained from the identity fi(xi1 , . . . , xin) \u2248 xij inM. Since gi satisfiesM we get in particular that gi(x, x, . . . , x) = x for all x \u2208 C and thus, if we set xik = aik \u2208 B, we obtain\nfi(ai1 , . . . , ain) = gi(r(ai1), . . . , r(ain)) = r(aij ) = gi(r(aij ), \u00b7 \u00b7 \u00b7 , r(aij )) = fi(aij , \u00b7 \u00b7 \u00b7 , aij ).\nDefine MBW to be the strong linear Maltsev condition that asserts that v and w are BW operations (recall Definition 3.4).\nExample 6.5. The following strong linear Maltsev conditions are non-trivial, consistent and of height 1 (and hence satisfy the hypothesis of Theorem 6.2):\n(1) k-cyclic, (2) k-symmetric, (3) k-TS, (4) Quasi-k-NU, (5) Quasi-Maltsev, (6) Quasi-Siggers, (7) The conditionMBW; recall that idempotent polymorphisms satisfying this condition\ncharacterise cores whose CSP has bounded width (Theorem 3.5)\nThe main technical tool needed for the proof of Theorem 6.2 is the following lemma.\nLemma 6.6. Let G be a connected, undirected graph without loops and with at least 2 vertices. Then there exists a finite, binary relational structure B, first order definable from G, with the following properties:\n(1) G admits a 3-colouring if and only if B is not a core; (2) if G admits a 3-colouring, the core C of B satisfies the following: every idempotent\noperation on C is a polymorphism of C; (3) there exists a 3-element subset S of B such that the restriction of any idempotent\npolymorphism f of B to S is a projection.\nProof. The universe of our structure is B = V (G) \u00d7 {1, 2, 3}; for convenience we denote (u, i) by ui. Choose an arbitrary orientation of the edges of G, and for each arc e = (u, v), let Re be the following binary relation on B:\nRe = {(ui, vj) : i 6= j}.\nThen B = \u3008B;Re (e \u2208 E(G)\u3009. It is easy to see that B if first-order definable from G.\nClaim 1. If G admits a 3-colouring then B is not a core. Let \u03c6 be a 3-colouring of G. Consider the self-map r of B defined by r(ui) = u\u03c6(u) for all 1 \u2264 i \u2264 3. Then r preserves every Re, since, if e = (u, v), then (r(ui), r(vj)) = (u\u03c6(u), v\u03c6(v)) \u2208 Re.\nNotice that the map r above is a proper retraction of B onto the substructure C induced by C = {u\u03c6(u) : u \u2208 V (G)}. This structure is a (rigid) core: indeed, for every e = (u, v), the relation Re restricted to C\n2 is the singleton {(u\u03c6(u), v\u03c6(v))}; since G is connected and has at least 2 vertices, it means that every unary polymorphism of C must fix every element\nof C.\nClaim 2. If B is not a core then G admits a 3-colouring. Let\u2019s suppose that B is not a core, and hence admits some unary, non injective polymorphism f . Notice that for each u \u2208 V (G), the set {u1, u2, u3} is preserved by the polymorphisms of B, as it is the projection on some coordinate of any Re such that u is incident to e. Since the sets {u1, u2, u3} are pairwise disjoint, the image of f on some set W = {w1, w2, w3} has size at most 2.\nFact 1. Let e = (u, v) be an arc of G, and let {i, j, k} = {1, 2, 3}. (1) If ui and uj are in the image of f , then so is vk; (2) If ui is in the image of f , then vj or vk is in the image of f .\nWe prove the first statement, the second is similar. By hypothesis there exist distinct s, t such that f(us) = ui and f(ut) = uj . Since there exists some r such that (us, vr), (ut, vr) \u2208 Re, we have (ui, f(vr)), (uj , f(vr)) \u2208 Re so f(vr) = vk.\nFor a vertex u \u2208 V (G) let F (u) denote the set of indices that appear in the image of f on {u1, u2, u3}. It is immediate from the previous fact that, if e = (u, v) is an arc of G and the image of f restricted to {v1, v2, v3} has at most 2 elements, then the same holds for the set {u1, u2, u3}. By connectedness of G and the fact that the image of f on at least one set W has size at most 2, it follows that |F (u)| \u2264 2 for all u \u2208 V (G). Define a map \u03c6 : V (G)\u2192 {1, 2, 3} as follows:\n\u03c6(u) =  1, if F (u) \u2208 {{1}, {1, 3}},2, if F (u) \u2208 {{2}, {1, 2}}, 3, if F (u) \u2208 {{3}, {2, 3}}.\nFact 2. \u03c6 is a proper 3-colouring of G.\nLet e = (u, v) and let \u03c6(u) = i. Suppose first that F (u) = {i}. Then by Fact 1 (2) F (v) cannot contain i. Inspection of the definition of \u03c6 shows that in this case \u03c6(v) 6= i. If on the other hand F (u) = {i, j}, then by Fact 1 (1) F (v) must contain the unique k 6\u2208 {i, j}; it is then immediate by the definition of \u03c6 that \u03c6(v) 6= \u03c6(u).\nIt follows from the preceding proofs that there are only two possibilities: either G is 3-colourable and the core of B is C, or otherwise B itself is a core. To finish the proof of the theorem, it thus suffices to prove the following facts:\nFact 3. Assume G is 3-colourable. Then every idempotent operation on C is a polymorphism of C.\nThis is obvious: each basic relation of C has a single tuple.\nFact 4. The restriction of any idempotent polymorphism of B to a set {u1, u2, u3} is a projection.\n(This construction is essentially due to Feder, [29]) Suppose without loss of generality that e = (u, v) is an arc (otherwise we just reverse all the arcs in the gadgets). First define the relation \u03b8 = {(ui, vi) : i = 1, 2, 3} by the gadget in Figure 2, where the arcs in the gadget denote the relation Re. Since our pp-definition uses only constants and Re, the idempotent polymorphisms of B preserve \u03b8. Then define the relation {(s, t) : \u2203z (s, z) \u2208 \u03b8, (t, z) \u2208 Re}. This pp-defines the complete graph on {u1, u2, u3}, which is well-known to support no idempotent polymorphisms other than projections.\nProof. (Proof of Theorem 6.2) We reduce from 3-colourability, restricted to the types of graphs considered in Lemma 6.6. Consider the structure B associated to the graph G in Lemma 6.6: we prove that B satisfies M if and only if G is 3-colourable. We first make the trivial observation that Mq =M since M has height 1. Suppose first that B satisfies M. By Lemma 6.4, its core satisfies M with idempotent polymorphisms. Since M is\nnon-trivial, the idempotent operations that witness it on the core of B cannot all restrict to projections on a set with 2 or more elements; thus by Lemma 6.6 (3) B is not a core so G is 3-colourable. Conversely, if B does not satisfy M, then by Lemma 6.4 its core does not satisfy M with idempotent polymorphisms; since M is consistent, it follows from Lemma 6.6 (2) that the core of B is B itself, and hence G is not 3-colourable. Thus the problem is NP-hard.\nTo see that the problem is in NP: it suffices to guess the polymorphisms that satisfy M.\nWe now turn to consider the complexity of deciding if a structure has bounded width. We first note the following fact, which is now folklore (we present it here, as we do not know of an explicit reference).\nProposition 6.7. A structure H has bounded width if and only if it satisfies MBW.\nProof. LetM be the strong linear Maltsev condition obtained by takingMBW and adding the requirements that v and w are idempotent. We have that a structure satisfies Mq if and only if it satisfies MBW. Hence, by Lemma 6.4 a structure H satisfies MBW if and only if the core of H satisfiesM. The core of H has bounded width if and only if it satisfies M, by Theorem 3.5. By Proposition 3.6, H has bounded width if and only if its core does, yielding the proposition.\nThe following result settles the complexity of the just-mentioned decision problem, and answers a question of L. Barto (see [3], just after Corollary 8.5).\nCorollary 6.8. Deciding, given a structure H, whether or not CSP(H) has bounded width is NP-complete.\nProof. This follows directly from Proposition 6.7 and Theorem 6.2.\nRecall that the algebraic dichotomy conjecture (Conjecture 3.1) predicts that the relational structures H for which CSP(H) is tractable are precisely those whose core admits a Siggers polymorphism; by Lemma 6.4 those are precisely the structures that admit a quasi-Siggers polymorphism. By the last theorem, this condition is also NP-complete.\nCorollary 6.9. Deciding if a relational structure admits a quasi-Siggers polymorphism is NP-complete.\nThe property of admitting k-symmetric polymorphisms of all arities k \u2265 2 characterises structures whose CSP admits a special kind of approximation algorithm based on linear programming [38], see also [27] and [20] Remark 5. For the purposes of the next result, we call a structure all-k-symmetric if it has this property. Notice that Lemma 6.6 has consequences slightly stronger than those stated in Theorem 6.2 as it shows NP-hardness of various Maltsev conditions (not necessarily strong ones):\nCorollary 6.10. Let k \u2265 2. Deciding if a relational structure admits any of the following polymorphisms is NP-complete:\n(1) a k-ary totally symmetric polymorphism, (2) a k-ary symmetric polymorphism, (3) a k-ary cyclic polymorphism.\nFurthermore, deciding the existence of a set polymorphism, or if a structure is all-k-symmetric is NP-hard.\nProof. Statements (1)-(3) follow directly from Theorem 6.2 and Example 6.5. To prove that the problem of deciding if a structure is all-k-symmetric, we also invoke Example 6.5 and then proceed as in the proof of Theorem 6.2 simply noticing that if G is 3-colourable then the core of the associated structure B admits idempotent k-symmetric polymorphisms for all k, and if G is not 3-colourable, then the core of B is B itself, and admits no k-symmetric polymorphism for any k. For the last statement, we also proceed exactly as in the proof of Theorem 6.2: by the proof of Proposition 5.3, the structure B associated to the graph G in Lemma 6.6 admits a set polymorphism precisely when its core admits an idempotent set polymorphism. It is easy to see that the TS polymorphisms guaranteed by Lemma 5.2 are idempotent if the core admits an idempotent set polymorphism; since no TS operation can be a projection when restricted to a non-trivial set, by Lemma 6.6, if the core of B has an idempotent set polymorphism then B is not a core and so G is 3-colourable. Conversely, since every non-trivial set admits an idempotent set function (take for instance the union operation), if the core of B does not admit an idempotent set polymorphism then B is not a core, and so G is 3-colourable.\n6.2. Semilattice polymorphisms. A known sufficient condition for a structure to have a set polymorphism is that the structure has a semilattice polymorphism [28]. We show that detecting this sufficient condition (that is, for a semilattice polymorphism) is NP-hard, even in the case where one restricts attention to conservative polymorphisms (see [31] for related results.)\nTheorem 6.11. Deciding if a relational structure admits any of the following is NPcomplete (even when restricted to at most binary relational structures):\n(1) a semilattice polymorphism, (2) a conservative semilattice polymorphism, (3) a commutative, associative polymorphism (that is, a commutative semigroup poly-\nmorphism).\nProof. Inclusion in NP holds, as one may guess the operation and verify that it has the desired form. For NP-hardness, we use a reduction from the classical NP-complete problem betweenness [41]:\n\u2022 Input: A list of triples (i, j, k) of distinct integers in {1, . . . , n}; \u2022 Question: is there a linear ordering of {1, . . . , n} such that for each triple (i, j, k)\nin the list, j is between i and k ?\nFor a given list of triples, construct the following relational structure H: its universe is H = {1, . . . , n}; each non-empty subset of H having size less than or equal to 2 is a\nrelation; and, for each triple (i, j, k) in the list, we have the relation {(i, j), (j, k)}. We claim that the following are equivalent:\n(1) there exists a linear ordering satisfying the betweenness condition; (2) H admits a conservative semilattice polymorphism; (3) H admits a semilattice polymorphism; (4) H admits a commutative, associative polymorphism.\nFor (1)\u21d2 (2), if there is such an ordering, it is easily verified that the maximum operation of the ordering preserves every relation; this is a conservative semilattice polymorphism of H. The implications (2) \u21d2 (3) \u21d2 (4) are immediate. For the implication (4) \u21d2 (1), suppose H has a commutative, associative polymorphism f . Notice that we can induce a partial ordering of {1, . . . , n} by setting, for distinct u, v, u < v \u21d0\u21d2 f(u, v) = v. Indeed, the associative condition guarantees this relation is transitive. Choose any linear extension of this partial ordering; it is immediate that it satisfies the in-betweenness condition.\n6.3. An NL-hardness result for certain conservative polymorphisms. The remainder of this section focuses on the proof of the following theorem, which establishes an NLhardness result for a number of different types of conservative polymorphisms, in the case of at most binary structures.\nTheorem 6.12. Deciding if a relational structure admits any of the following polymorphisms is NL-hard, under first-order reductions, even in the case of at most binary structures.\n\u2022 a commutative conservative binary polymorphism, \u2022 a conservative k-ary TS polymorphism (for any k \u2265 2), \u2022 a conservative set polymorphism, \u2022 a conservative k-ary symmetric polymorphism (for any even k \u2265 2), \u2022 a conservative k-ary cyclic polymorphism (for any even k \u2265 2).\nBefore launching into the proof of the result we require some preparation. Given a set T of triples (i, j, k) of distinct integers in {1, ..., n}, let H(T ) denote the relational structure defined as follows (note that this is a slight variant of the structures used in Theorem 6.11 above): its universe is {1, . . . , n}, and for each triple (a, b, c) \u2208 T we introduce a relation {(a, b), (b, b), (b, c)}. Furthermore, let D(T ) denote the following digraph: its vertices are the pairs (a, b) of distinct integers that appear consecutively in some triple of T , and we have an arc (a, b)\u2192 (b\u2032, c) iff b = b\u2032 and either (a, b, c) \u2208 T or (c, b, a) \u2208 T .\nLemma 6.13. Let T be a set of triples, and let k \u2265 2. Then the following are equivalent: (1) For all a, b, (a, b) and (b, a) lie in different strong components of D(T ); (2) H(T ) admits a conservative commutative binary polymorphism; (3) H(T ) admits a conservative k-ary TS polymorphism; (4) H(T ) admits a conservative set polymorphism.\nIf k \u2265 2 is even, then these conditions are equivalent to the following: (5) H(T ) admits a conservative k-ary symmetric polymorphism; (6) H(T ) admits a conservative k-ary cyclic polymorphism.\nProof. Let D = D(T ) and H = H(T ). First notice that, since the projection of any basic relation of H on any one coordinate has size 2, the value of a polymorphism on tuples with at least 3 distinct entries is irrelevant; thus from a commutative binary polymorphism we can trivially build a TS polymorphism of any arity, and it follows that (2), (3) and (4) are equivalent. It is immediate that (3) implies (5) and (5) implies (6) for all k; finally if k = 2n then (6) implies (2): if t is a conservative cyclic polymorphism of arity 2n then f(x, y) = t(x, \u00b7 \u00b7 \u00b7 , x, y, \u00b7 \u00b7 \u00b7 , y) is a conservative, commutative polymorphism, where we identified the first n variables and the last n respectively.\nSuppose (2) holds and let f denote the polymorphism witnessing this. By definition of H, it is easy to see that, if (x, y) \u2192 (u, v) in D, then f(x, y) = x implies that f(u, v) = u. Suppose for a contradiction that (1) does not hold; then there is a pair (a, b) with a directed path to (b, a), thus if f(a, b) = a then f(b, a) = b, a contradiction. Hence f(a, b) = b; by commutativity we get f(b, a) = b; using the path from (b, a) back to (a, b) we force f(a, b) = a, again a contradiction.\nSuppose that (1) holds. By our previous arguments it suffices to prove (2), and by definition of H, to do this it suffices to define the polymorphism only on pairs that are vertices of D (the polymorphism can be defined arbitrarily on all other pairs of distinct elements). Notice that, by definition, the map (a, b) 7\u2192 (b, a) is an edge-reversing bijection of D, i.e. (a, b)\u2192 (c, d) if and only if (d, c)\u2192 (b, a). Let F be a down set of D (i.e. y \u2208 F and x \u2192 y implies x \u2208 F ) which is maximal for the property (a, b) \u2208 F \u21d2 (b, a) 6\u2208 F . There is at least one such non-empty set: indeed, by hypothesis all strong components of D satisfy the property and at least one strong component is a down set (if a vertex does not lie in a directed cycle we consider it to be a strong component). We claim that every (x, y) 6\u2208 F satisfies (y, x) \u2208 F . Indeed, if this is not the case, then there exists (x, y) 6\u2208 F with (y, x) 6\u2208 F and such that the strong component S of (x, y) is minimal for this property, with respect to the ordering induced on strong components by H. Let (u, v) admit a directed path to (x, y); then we obtain a directed path from (y, x) to (v, u), and since (y, x) 6\u2208 F we conclude that (v, u) 6\u2208 F . By minimality of S, it follows that (u, v) \u2208 S or (u, v) \u2208 F . Hence F \u2032 = F \u222a S is a downset. By maximality of F , it follows there must exist some (c, d) \u2208 F with (d, c) \u2208 S. But then (d, c) admits a directed path to (x, y) and (c, d) \u2208 F , again a contradiction. By the just-proved claim and the definition of F , for each pair (x, y) of D, we have that exactly one of (x, y), (y, x) is in F . Define f(x, y) = y for (x, y) \u2208 F and f(x, y) = x otherwise. By our previous remark f is commutative, and it is obviously conservative. Finally, we must show that f is a polymorphism of H. Fix a triple (a, b, c) \u2208 T . It is easy to see that, since f is conservative and commutative, it suffices to prove that (f(a, b), f(b, c)) \u2208 R = {(a, b), (b, b), (b, c)}. The only bad case is if f(a, b) = a and f(b, c) = c; by definition of f this can only happen if (b, c) \u2208 F and (a, b) 6\u2208 F , but since (a, b)\u2192 (b, c) this is impossible.\nProof. (of Theorem 6.12)\nOur goal is to reduce the following (or rather, the negation of this decision problem), via a first-order reduction, to our problem of deciding the existence of a conservative 2-TS polymorphism:\n\u2022 Input: a digraph K with two specified, distinct vertices s and t; \u2022 Question: are s and t in the same strong component of K ?\nThis problem is easily seen to be NL-hard, as we can restrict it to digraphs with an arc from t to s to obtain the standard directed reachability problem (here we use the fact that NL = co \u2212 NL). Let K be our input digraph: we may assume without loss of generality that K has no isolated vertices and no loops. It is clear that, if we construct a new digraph G by replacing every arc e = (u, v) of K by a directed path of length 3, e1 = (u, x), e2 = (x, y), e3 = (y, v), then there are directed paths from s to t and back in G if and only if the same holds in K; notice also that the construction is clearly first order.\nOur overall strategy is the following: we will first exhibit a set of triples T whose associated digraph D(T ) is isomorphic to the disjoint union of G and G, this last digraph being obtained from G by flipping all its arcs. We can then throw in a few other triples to glue these copies together so that the resulting digraph D(T \u2032) contains pairs (a, b) and (b, a) that lie on a directed cycle if and only if s and t have the same property in G. The construction of the set T is fairly straightforward, it consists of the following triples: for each arc \u03b1 = (u, v) of K, we have the triples (u1, u2, \u03b1), (u2, \u03b1, v1), (\u03b1, v1, v2).\nClaim 1. The digraph D(T ) is isomorphic to the disjoint union of G and G.\nIndeed, let \u0393 be the set of pairs (c, d) such that (c, d, e) or (e, c, d) is in T for some e, and let \u0393 = {(y, x) : (x, y) \u2208 \u0393}. It is clear that these sets are disjoint and their union equals the vertex set of D(T ); furthermore no arc of D(T ) connects vertices from \u0393 and \u0393. To complete the proof, it suffices to prove that the subdigraph of D(T ) induced by \u0393 is isomorphic to G. Indeed, the pairs (u1, u2) constitute a copy of the set K \u2282 G; given an arc \u03b1 = (u, v) in K, we have a path e1 = (u, x), e2 = (x, y), e3 = (y, v) in G, which corresponds exactly to the arcs induced by the triples associated to \u03b1 with x mapped to (u2, \u03b1) and y to (\u03b1, v1); and obviously every vertex and arc of the subdigraph induced by \u0393 is of this form.\nWe are now ready to define the structure we need (see Figure 3.) Let H be the disjoint union of the underlying set of the triples T and {a, b} where a and b are two new distinct elements. Let T \u2032 be the following set of triples on H: T \u2032 = T \u222a L where\nL = {(a, b, s1), (b, s1, s2), (s1, s2, a), (s2, a, b), (t1, a, b), (t2, t1, a), (b, t2, t1), (a, b, t2)} .\nFor convenience in the proof, let u = (y, x) if u = (x, y) is any vertex of D(T \u2032), and extend this notation to subgraphs in the obvious way. Let L (for left) be the set of pairs (x, y) such that (x, y, e) or (e, x, y) is in L for some e, and let R = L. By the last claim, we may view D(T ) as the disjoint union of G and G; notice that this is an induced subdigraph of D(T \u2032), since every triple of L contains an occurrence of a or b.\nClaim 2. There exists a pair (x, y) in the same strong component of D(T \u2032) as (y, x) if and only if s and t are in the same strong component of G.\nThe following observations are immediate:\n(i) s = (s1, s2), t = (t2, t1) and L lie in the same strong component of D(T \u2032); similarly t, s and R lie in the same strong component of D(T \u2032); (ii) any directed path connecting G and G must pass through s and t (i.e. through L) or through t and s (i.e. through R). (iii) In D(T \u2032), there is a directed path from u to v if and only if there is a directed path from v to u; if the first path lies in G (G) the the second lies in G (G respectively).\nSuppose there exists a pair u such that u and u are in the same strong component of D(T \u2032). By the preceding observations, we may safely assume that u is a vertex of G (and thus u is a vertex of G.) There are, without loss of generality, only two cases to consider:\n(1) The directed paths joining u to u and back both go through L: then u and s lie in the same strong component of G and u lies in the strong component of t in G. By observation (iii), we obtain that u is in the strong component of t in G and we are done. (2) One directed path goes through L and the other through R. If this is the case there is (without loss of generality) a directed path in G from s to t, and a directed path in G from s to t; by (iii), we obtain a directed path in G from t to s and we are done.\nThe converse is immediate: if s and t are in the same strong component of G then by observation (i) t = (t1, t2) and t = (t2, t1) are in the same strong component of D(T \u2032).\nIt follows from Claim 2 and Lemma 6.13 that the structure H(T \u2032) admits no conservative, commutative binary polymorphism if and only if there are paths in G from s to t and from t to s. To complete the proof, we briefly outline why the reduction is first order. It is very easy to define the triples of T from the digraph K, one may use the constants s and t to play the role of the indices 1 and 2. Finally, rewriting the triples as a binary relation is obviously no problem."}, {"heading": "7. Discussion", "text": "In this section, we place in context some of the main themes of this article. Let us first collect together some known relationships among the polymorphisms and\nconditions that were considered. Concerning idempotent polymorphisms, we have the following chain of implications.\nsemilattice polymorphism \u21d2 idempotent set polymorphism \u21d2 idempotent k-totally symmetric polymorphism \u21d2 idempotent k-symmetric polymorphism \u21d2 idempotent\nk-cyclic polymorphism \u21d2 Siggers polymorphism By X \u21d2 Y , we mean to indicate that if a structure has a polymorphism of type X, then it also has a polymorphism of type Y . The first two implications here follow from [28, 30]; the next two are direct; and, the last follows from Proposition 2.3.\nConcerning general polymorphisms, we have the following chain of implications.\nset polymorphism \u21d2 k-totally symmetric polymorphism \u21d2 k-symmetric polymorphism \u21d2 k-cyclic polymorphism \u21d2 quasi-Siggers polymorphism\nThe first implication follows from [30], the next two are direct, and the last can be argued in the following way, via Lemma 6.4: if a structure H has a k-cyclic polymorphism, then its core has an idempotent k-cyclic polymorphism and hence a Siggers polymorphism; it follows that H has a quasi-Siggers polymorphism. Also, the two chains so far are related in the following way: an idempotent set polymorphism is a particular type of set polymorphism, so an idempotent set polymorphism directly implies a set polymorphism; an analogous statement holds for k-totally symmetric polymorphisms, k-symmetric polymorphisms, and k-cyclic polymorphisms. It is readily verified that a Siggers polymorphism implies a quasiSiggers polymorphism.\nAs discussed earlier, bounded width is a general known sufficient condition for tractability of CSP(H). It is known that if H has a k-totally symmetric polymorphism, then H has bounded width; this is because, via Lemma 6.4, under the assumption, the core of H has an idempotent k-totally symmetric polymorphism, implying (by the proof of Corollary 3.12) that this core has bounded width, which in turn implies that H has bounded width (via Proposition 3.6).\nAnother general known sufficient condition for the tractability of CSP(H) is few subpowers, studied by [7, 32]. It is known that either the presence of a Maltsev polymorphism or a k-near unanimity polymorphism implies few subpowers [7] (although the metaquestion for k-near unanimity operations is tractable, recall Theorem 3.11).\nWe gave a general hardness result, Theorem 6.2, showing that, for a number of the quasi-versions of polymorphisms and of the polymorphism types where idempotentcy is not required, the metaquestion is hard (recall Example 6.5 and Corollary 6.10).\nConcerning the applicability of the developed theory, one can ask the following question. In the case that a structure H is known to have polymorphisms of some type that guarantee tractability of CSP(H), in which cases can instances of CSP(H) be solved efficiently? In the case of polymorphisms that imply bounded width, the (2, 3)-minimality algorithm can be employed to efficiently solve the named instances (recall Theorem 3.7). Otherwise, the notion of uniform polynomial-time algorithm from Section 4 formalizes the efficient solvability of CSP(H) over structures H having desirable polymorphisms of some type. In the case of idempotent polymorphisms, Theorem 4.7 gives a characterization of the existence of a uniform polynomial-time algorithm."}, {"heading": "8. Open issues", "text": "We end by discussing a number of open issues and posing further questions about metaquestions.\n\u2022 A perusal of the table yields that, for some of the polymorphism types studied, no complexity hardness result has yet been presented. In particular, this is the case for k-symmetric and k-cyclic polymorphisms with odd k \u2265 3, Maltsev polymorphisms, and Siggers polymorphisms. Can such hardness results be given?\n\u2022 Glancing at the table again, in all of the cases where a set polymorphism was considered, there is a wide gap between the upper bound of EXPTIME and the lower bound of NP-hard or NL-hard. Can the gap be narrowed? A possible next question could be to determine if deciding the presence of a general set polymorphism is coNP-hard or not. \u2022 A number of solution procedures that extend arc consistency have been proposed\nin the literature [25]. For one of them, look-ahead arc consistency [24, 25], the metaquestion of deciding whether or not the procedure solves CSP(H) is known to be in polynomial time (see footnote 2 in [24]). One can inquire about the complexity of the corresponding metaquestion for other such extensions, such as peek arc consistency [10, 25]. \u2022 A coset-generating operation on a set H is an operation of the form f(x, y, z) = xy\u22121z, where the multiplication and inverse are relative to a group structure on H. Can anything be said about the complexity of deciding the presence of cosetgenerating polymorphism? Such polymorphisms are known to imply tractability of the CSP; indeed, each coset-generating operation is a Maltsev operation.\nRelatedly, a structure H having a group polymorphism (that is, a polymorphism that is a binary operation giving a group structure on H) can be readily verified to have a coset-generating polymorphism. What is the complexity of deciding if a structure H has a group polymorphism?\nOne can also ask these questions for restricted classes of groups. \u2022 Let us here say that a polymorphism is non-trivial if it is not a projection. What\nis the complexity of deciding if a given structure has a non-trivial polymorphism? The following observations can be made.\nLemma 8.1. It is decidable to determine if a structure has a non-trivial idempotent polymorphism.\nProof. Let H be a finite structure. We show that if it admits a non-trivial idempotent polymorphism, it has one of arity at most max(3, |H|). Let f be such a polymorphism with minimal arity. Then if we identify any two variables, we obtain a projection. By Swierczkowski\u2019s lemma [44], if f has arity 4 or more, then in fact, there exists a unique i such that f projects onto the i-th coordinate when we apply it to a tuple containing a repetition. In particular, if the arity is greater than |H|, f is a projection, a contradiction.\nObserve that this lemma implies the decidability of determining presence of a non-trivial polymorphism: one can first check for a non-trivial polymorphism of arity 1; if there is none, then every polymorphism is idempotent, and one can then invoke the algorithm of this lemma.\nRelatedly, one can inquire about the complexity of deciding if a given structure has a polymorphism that is not essentially unary.\n\u2022 In this article, we focused on the explicit representation of relational structures, where each relation is specified by an explicit listing of its tuples. In some contexts, however, it is natural to assume that the second structure H of each CSP instance (G,H) has its relations specified according to other representations (see the discussion in [26]). Alternative representations have been considered in the literature; for example, Marx [40] studied truth table representation, and Chen and Grohe [26] studied two representations which they called generalized DNF representation and decision diagram representation. The latter two representations are more succinct than the explicit representation, and many of the questions that we have studied and discussed can be investigated for these representations. For instance, for each of these representations, one can consider the complexity of any metaquestion where the input is a structure H under the representation. One can also investigate whether or not uniform polynomial-time algorithms exist for various classes of structures, under these succinct representations; this was considered briefly by Chen and Grohe [26, Section 5], but it seems that the theory could be developed much further.\nAcknowledgements. The authors wish to express their gratitude to Matt Valeriote for numerous useful discussions and comments. The first author was supported by the Spanish Project MINECO COMMAS TIN2013-46181-C2-R, Basque Project GIU15/30, and Basque Grant UFI11/45. The second author acknowledges the support of FRQNT and NSERC. The authors are also grateful to the anonymous referees for their judicious comments."}], "references": [{"title": "The Complexity of Satisfiability Problems: Refining Schaefer\u2019s Theorem", "author": ["E. Allender", "M. Bauland", "N. Immerman", "H. Schnoor", "H. Vollmer"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "1", "shortCiteRegEx": "1", "year": 2009}, {"title": "Constraint satisfaction problems of bounded width", "author": ["L. Barto", "M. Kozik"], "venue": "In Proceedings of FOCS\u201909,", "citeRegEx": "2", "shortCiteRegEx": "2", "year": 2009}, {"title": "The collapse of the bounded width hierarchy", "author": ["Libor Barto"], "venue": "Journal of Logic and Computation,", "citeRegEx": "3", "shortCiteRegEx": "3", "year": 2014}, {"title": "Constraint satisfaction problems solvable by local consistency methods", "author": ["Libor Barto", "Marcin Kozik"], "venue": "J. ACM,", "citeRegEx": "4", "shortCiteRegEx": "4", "year": 2014}, {"title": "Mal\u2019tsev conditions, lack of absorption, and solvability", "author": ["Libor Barto", "Marcin Kozik", "David Stanovsk\u00fd"], "venue": "Algebra universalis,", "citeRegEx": "5", "shortCiteRegEx": "5", "year": 2015}, {"title": "The wonderland of reflections", "author": ["Libor Barto", "Jakub Oprsal", "Michael Pinsker"], "venue": "CoRR, abs/1510.04521,", "citeRegEx": "6", "shortCiteRegEx": "6", "year": 2015}, {"title": "Varieties with few subalgebras of powers", "author": ["J. Berman", "P. Idziak", "P. Markovic", "R. McKenzie", "M. Valeriote", "R. Willard"], "venue": "Transactions of the American Mathematical Society,", "citeRegEx": "7", "shortCiteRegEx": "7", "year": 2010}, {"title": "Qualitative temporal and spatial reasoning revisited", "author": ["Manuel Bodirsky", "Hubie Chen"], "venue": "Journal of Logic and Computation,", "citeRegEx": "9", "shortCiteRegEx": "9", "year": 2009}, {"title": "Peek arc consistency", "author": ["Manuel Bodirsky", "Hubie Chen"], "venue": "Theoretical Computer Science,", "citeRegEx": "10", "shortCiteRegEx": "10", "year": 2010}, {"title": "The complexity of constraint satisfaction games and QCSP", "author": ["Ferdinand B\u00f6rner", "Andrei A. Bulatov", "Hubie Chen", "Peter Jeavons", "Andrei A. Krokhin"], "venue": "Information and Computation,", "citeRegEx": "11", "shortCiteRegEx": "11", "year": 2009}, {"title": "Generic expression hardness results for primitive positive formula comparison", "author": ["Simone Bova", "Hubie Chen", "Matthew Valeriote"], "venue": "Inf. Comput.,", "citeRegEx": "12", "shortCiteRegEx": "12", "year": 2013}, {"title": "Classifying the Complexity of Constraints using Finite Algebras", "author": ["A. Bulatov", "P. Jeavons", "A. Krokhin"], "venue": "SIAM Journal on Computing,", "citeRegEx": "13", "shortCiteRegEx": "13", "year": 2005}, {"title": "A Simple Algorithm for Mal\u2019tsev Constraints", "author": ["Andrei Bulatov", "Victor Dalmau"], "venue": "SIAM Journal of Computing,", "citeRegEx": "14", "shortCiteRegEx": "14", "year": 2006}, {"title": "Tractable constraints closed under a binary operation", "author": ["Andrei Bulatov", "Peter Jeavons"], "venue": "Technical Report PRG-TR-12-00, Oxford University Computing Laboratory,", "citeRegEx": "15", "shortCiteRegEx": "15", "year": 2000}, {"title": "Complexity of conservative constraint satisfaction problems", "author": ["Andrei A. Bulatov"], "venue": "ACM Trans. Comput. Log.,", "citeRegEx": "16", "shortCiteRegEx": "16", "year": 2011}, {"title": "Dualities for constraint satisfaction problems. In Complexity of Constraints - An Overview of Current Research Themes [Result of a Dagstuhl Seminar]", "author": ["Andrei A. Bulatov", "Andrei A. Krokhin", "Benoit Larose"], "venue": null, "citeRegEx": "17", "shortCiteRegEx": "17", "year": 2008}, {"title": "Recent results on the algebraic approach to the CSP. In Complexity of Constraints - An Overview of Current Research Themes [Result of a Dagstuhl Seminar]", "author": ["Andrei A. Bulatov", "Matthew Valeriote"], "venue": null, "citeRegEx": "18", "shortCiteRegEx": "18", "year": 2008}, {"title": "The meta-problem for conservative mal\u2019tsev constraints", "author": ["C. Carbonnel"], "venue": "In Proceedings of the Thirtieth AAAI Conference on Artificial Intelligence", "citeRegEx": "19", "shortCiteRegEx": "19", "year": 2016}, {"title": "On algebras with many symmetric operations, 2016", "author": ["Catarina Carvalho", "Andrei Krokhin"], "venue": null, "citeRegEx": "20", "shortCiteRegEx": "20", "year": 2016}, {"title": "The expressive rate of constraints", "author": ["Hubie Chen"], "venue": "Annals of Mathematics and Artificial Intelligence,", "citeRegEx": "21", "shortCiteRegEx": "21", "year": 2005}, {"title": "Quantified constraint satisfaction and the polynomially generated powers property", "author": ["Hubie Chen"], "venue": "Algebra Universalis,", "citeRegEx": "22", "shortCiteRegEx": "22", "year": 2011}, {"title": "Meditations on quantified constraint satisfaction", "author": ["Hubie Chen"], "venue": "Logic and Program Semantics,", "citeRegEx": "23", "shortCiteRegEx": "23", "year": 2012}, {"title": "Smart) Look-Ahead Arc Consistency and the Pursuit of CSP Tractability", "author": ["Hubie Chen", "Victor Dalmau"], "venue": "In Principles and Practice of Constraint Programming - CP", "citeRegEx": "24", "shortCiteRegEx": "24", "year": 2004}, {"title": "Gru\u00dfien. Arc consistency and friends", "author": ["Hubie Chen", "V\u0131\u0301ctor Dalmau", "Berit"], "venue": "J. Log. Comput.,", "citeRegEx": "25", "shortCiteRegEx": "25", "year": 2013}, {"title": "Constraint satisfaction with succinctly specified relations", "author": ["Hubie Chen", "Martin Grohe"], "venue": "Journal of Computer and System Sciences,", "citeRegEx": "26", "shortCiteRegEx": "26", "year": 2010}, {"title": "Robust satisfiability for CSPs: hardness and algorithmic results", "author": ["V\u0131\u0301ctor Dalmau", "Andrei Krokhin"], "venue": "ACM Trans. Comput. Theory, 5(4):Art. 15,", "citeRegEx": "27", "shortCiteRegEx": "27", "year": 2013}, {"title": "Closure Functions and Width 1 Problems", "author": ["Victor Dalmau", "Justin Pearson"], "venue": "In CP", "citeRegEx": "28", "shortCiteRegEx": "28", "year": 1999}, {"title": "Classification of homomorphisms to oriented cycles and k-partite satisfiability", "author": ["T. Feder"], "venue": "SIAM J. Discrete Math,", "citeRegEx": "29", "shortCiteRegEx": "29", "year": 2001}, {"title": "The computational structure of monotone monadic SNP and constraint satisfaction: A study through Datalog and group theory", "author": ["T. Feder", "M. Vardi"], "venue": "SIAM Journal on Computing,", "citeRegEx": "30", "shortCiteRegEx": "30", "year": 1999}, {"title": "Domain permutation reduction for constraint satisfaction problems", "author": ["Martin J. Green", "David A. Cohen"], "venue": "Artif. Intell.,", "citeRegEx": "31", "shortCiteRegEx": "31", "year": 2008}, {"title": "Tractability and learnability arising from algebras with few subpowers", "author": ["P. Idziak", "P. Markovic", "R. McKenzie", "M. Valeriote", "R. Willard"], "venue": "SIAM J. Comput.,", "citeRegEx": "32", "shortCiteRegEx": "32", "year": 2010}, {"title": "Constraints, consistency, and closure", "author": ["P. Jeavons", "D. Cohen", "M. Cooper"], "venue": "Artificial Intelligence,", "citeRegEx": "33", "shortCiteRegEx": "33", "year": 1998}, {"title": "Csp for binary conservative relational structures", "author": ["Alexandr Kazda"], "venue": "arXiv, abs/1112.1099,", "citeRegEx": "34", "shortCiteRegEx": "34", "year": 2011}, {"title": "Maltsev digraphs have a majority polymorphism", "author": ["Alexandr Kazda"], "venue": "European Journal of Combinatorics,", "citeRegEx": "35", "shortCiteRegEx": "35", "year": 2011}, {"title": "Optimal strong mal\u2019cev conditions for omitting type 1 in locally finite varieties", "author": ["Keith Kearnes", "Petar Markovi\u0107", "Ralph McKenzie"], "venue": "Algebra universalis,", "citeRegEx": "36", "shortCiteRegEx": "36", "year": 2014}, {"title": "Characterizations of several maltsev conditions", "author": ["Marcin Kozik", "Andrei Krokhin", "Matt Valeriote", "Ross Willard"], "venue": null, "citeRegEx": "37", "shortCiteRegEx": "37", "year": 2015}, {"title": "Linear programming, width-1 csps, and robust satisfaction", "author": ["G\u00e1bor Kun", "Ryan O\u2019Donnell", "Suguru Tamaki", "Yuichi Yoshida", "Yuan Zhou"], "venue": "In Innovations in Theoretical Computer Science", "citeRegEx": "38", "shortCiteRegEx": "38", "year": 2012}, {"title": "Universal algebra and hardness results for constraint satisfaction problems", "author": ["Benoit Larose", "Pascal Tesson"], "venue": "Theoretical Computer Science,", "citeRegEx": "39", "shortCiteRegEx": "39", "year": 2009}, {"title": "Tractable structures for constraint satisfaction with truth tables", "author": ["D\u00e1niel Marx"], "venue": "Theory of Computing Systems,", "citeRegEx": "40", "shortCiteRegEx": "40", "year": 2011}, {"title": "Total ordering problem", "author": ["Jaroslav Opatrny"], "venue": "SIAM J. Comput.,", "citeRegEx": "41", "shortCiteRegEx": "41", "year": 1979}, {"title": "The complexity of satisfiability problems", "author": ["T.J. Schaefer"], "venue": "In Proceedings of STOC\u201978,", "citeRegEx": "42", "shortCiteRegEx": "42", "year": 1978}, {"title": "A strong mal\u2019cev condition for locally finite varieties omitting the unary type", "author": ["Mark H. Siggers"], "venue": "Algebra universalis,", "citeRegEx": "43", "shortCiteRegEx": "43", "year": 2010}, {"title": "Algebras which are independently generated by every n elements", "author": ["S \u015awierczkowski"], "venue": "Fund. Math. 49,", "citeRegEx": "44", "shortCiteRegEx": "44", "year": 1961}, {"title": "A survey on strictly simple algebras and minimal varieties", "author": ["A. Szendrei"], "venue": "In Research and Exposition in Mathematics, Heldermann Verlag,", "citeRegEx": "45", "shortCiteRegEx": "45", "year": 1992}, {"title": "A subalgebra intersection property for congruence distributive varieties", "author": ["M. Valeriote"], "venue": "Canadian Journal of Mathematics,", "citeRegEx": "46", "shortCiteRegEx": "46", "year": 2009}], "referenceMentions": [{"referenceID": 40, "context": "Indeed, in a nowclassic result from 1978, Schaefer [42] presented a classification theorem, showing that for each structure H having a two-element universe, the problem CSP(H) is either polynomialtime decidable, or is NP-hard.", "startOffset": 51, "endOffset": 55}, {"referenceID": 11, "context": "A cornerstone of the algebraic approach is a theorem stating that when two structures H, H\u2032 have the same polymorphisms, the problems CSP(H) and CSP(H\u2032) are polynomial-time interreducible [13].", "startOffset": 188, "endOffset": 192}, {"referenceID": 11, "context": "Here, it should be further pointed out that a conjecture known as the algebraic dichotomy conjecture [13] predicts the polynomial-time tractability of each problem CSP(H) not satisfying a known sufficient condition for NPcompleteness, and that this conjecture can be formulated as predicting the tractability of each problem CSP(H) where H admits a certain type of polymorphism (see Conjecture 3.", "startOffset": 101, "endOffset": 105}, {"referenceID": 37, "context": "1In fact, under the stated assumption, the problems CSP(H) and CSP(H\u2032) are logarithmic-space interreducible [39].", "startOffset": 108, "endOffset": 112}, {"referenceID": 9, "context": "Let us mention here that, under the assumption, one also has interreducibility for some other computational problems of interest, such as the quantified CSP [11, 22, 23] and various comparison", "startOffset": 157, "endOffset": 169}, {"referenceID": 20, "context": "Let us mention here that, under the assumption, one also has interreducibility for some other computational problems of interest, such as the quantified CSP [11, 22, 23] and various comparison", "startOffset": 157, "endOffset": 169}, {"referenceID": 21, "context": "Let us mention here that, under the assumption, one also has interreducibility for some other computational problems of interest, such as the quantified CSP [11, 22, 23] and various comparison", "startOffset": 157, "endOffset": 169}, {"referenceID": 10, "context": "problems involving primitive positive formulas [12].", "startOffset": 47, "endOffset": 51}, {"referenceID": 2, "context": "Barto [3].", "startOffset": 6, "endOffset": 9}, {"referenceID": 17, "context": "Maltsev (*) (*) P [19] P", "startOffset": 18, "endOffset": 22}, {"referenceID": 17, "context": "The P containment result for conservative Maltsev comes from [19].", "startOffset": 61, "endOffset": 65}, {"referenceID": 35, "context": "In order to avoid undue algebraic technicalities, we present certain concepts in a slightly unorthodox way (for the standard equivalents, see for instance [37].", "startOffset": 155, "endOffset": 159}, {"referenceID": 5, "context": "Following [6], if a linear identity is not of this form, i.", "startOffset": 10, "endOffset": 13}, {"referenceID": 16, "context": "We now gather some well-known implications involving the special polymorphisms defined here; as some of these results are folklore, we give general references only [18, 43, 36, 37].", "startOffset": 164, "endOffset": 180}, {"referenceID": 41, "context": "We now gather some well-known implications involving the special polymorphisms defined here; as some of these results are folklore, we give general references only [18, 43, 36, 37].", "startOffset": 164, "endOffset": 180}, {"referenceID": 34, "context": "We now gather some well-known implications involving the special polymorphisms defined here; as some of these results are folklore, we give general references only [18, 43, 36, 37].", "startOffset": 164, "endOffset": 180}, {"referenceID": 35, "context": "We now gather some well-known implications involving the special polymorphisms defined here; as some of these results are folklore, we give general references only [18, 43, 36, 37].", "startOffset": 164, "endOffset": 180}, {"referenceID": 1, "context": "The dichotomy conjecture of Feder and Vardi, that states that every CSP(H) is either tractable or NPcomplete, has been the source of intense scrutiny over the past two decades, see for instance [2, 7] and the surveys [17, 18].", "startOffset": 194, "endOffset": 200}, {"referenceID": 6, "context": "The dichotomy conjecture of Feder and Vardi, that states that every CSP(H) is either tractable or NPcomplete, has been the source of intense scrutiny over the past two decades, see for instance [2, 7] and the surveys [17, 18].", "startOffset": 194, "endOffset": 200}, {"referenceID": 15, "context": "The dichotomy conjecture of Feder and Vardi, that states that every CSP(H) is either tractable or NPcomplete, has been the source of intense scrutiny over the past two decades, see for instance [2, 7] and the surveys [17, 18].", "startOffset": 217, "endOffset": 225}, {"referenceID": 16, "context": "The dichotomy conjecture of Feder and Vardi, that states that every CSP(H) is either tractable or NPcomplete, has been the source of intense scrutiny over the past two decades, see for instance [2, 7] and the surveys [17, 18].", "startOffset": 217, "endOffset": 225}, {"referenceID": 37, "context": "Here, interreducibility can actually be proved with respect to first-order reductions [39].", "startOffset": 86, "endOffset": 90}, {"referenceID": 11, "context": "Note also that, up to logspace interreducibility, we can assume the equality relation is also a relation of a structure H where CSP(H) is under study [13].", "startOffset": 150, "endOffset": 154}, {"referenceID": 11, "context": "The following is one of many possible formulations of a refinement of the dichotomy conjecture, due to Bulatov, Jeavons and Krokhin [13] (see also [37]):", "startOffset": 132, "endOffset": 136}, {"referenceID": 35, "context": "The following is one of many possible formulations of a refinement of the dichotomy conjecture, due to Bulatov, Jeavons and Krokhin [13] (see also [37]):", "startOffset": 147, "endOffset": 151}, {"referenceID": 11, "context": "A form of converse to this statement is known to hold, namely, it holds that a structure whose core has no Siggers polymorphism has an NP-complete CSP [13].", "startOffset": 151, "endOffset": 155}, {"referenceID": 14, "context": "[16] If a relational structure admits a conservative Siggers polymorphism then its CSP is tractable.", "startOffset": 0, "endOffset": 4}, {"referenceID": 19, "context": "Few subpowers problems [21, 32] generalize linear equations and are solvable by an algorithm with many properties in common with Gaussian elimination.", "startOffset": 23, "endOffset": 31}, {"referenceID": 30, "context": "Few subpowers problems [21, 32] generalize linear equations and are solvable by an algorithm with many properties in common with Gaussian elimination.", "startOffset": 23, "endOffset": 31}, {"referenceID": 2, "context": "We essentially follow [3].", "startOffset": 22, "endOffset": 25}, {"referenceID": 3, "context": "The cores H whose CSP have bounded width were characterized by Barto and Kozik [4]; the following description is known.", "startOffset": 79, "endOffset": 82}, {"referenceID": 3, "context": "[4, 37] Let H be a core.", "startOffset": 0, "endOffset": 7}, {"referenceID": 35, "context": "[4, 37] Let H be a core.", "startOffset": 0, "endOffset": 7}, {"referenceID": 2, "context": "7 ([3]).", "startOffset": 3, "endOffset": 6}, {"referenceID": 2, "context": "4 of [3]; we include its proof here as it is quite simple, clever and instructive.", "startOffset": 5, "endOffset": 8}, {"referenceID": 4, "context": "9 ([5], Theorem 1.", "startOffset": 3, "endOffset": 6}, {"referenceID": 31, "context": "This was proved first in [33], and also follows from Lemma 3.", "startOffset": 25, "endOffset": 29}, {"referenceID": 13, "context": "[15] Let H be a relational structure that admits a binary conservative commutative polymorphism.", "startOffset": 0, "endOffset": 4}, {"referenceID": 37, "context": "1 of [39]; we refer the reader to this proof for full details.", "startOffset": 5, "endOffset": 9}, {"referenceID": 1, "context": "Combining the results of [2], [45], and [46], there exists a subset C of H, |C| \u2265 2, such that that every polymorphism of H restricted to C preserves the relation \u03c1 = {(a, b, c) : a + b = c} for some Abelian group structure on C.", "startOffset": 25, "endOffset": 28}, {"referenceID": 43, "context": "Combining the results of [2], [45], and [46], there exists a subset C of H, |C| \u2265 2, such that that every polymorphism of H restricted to C preserves the relation \u03c1 = {(a, b, c) : a + b = c} for some Abelian group structure on C.", "startOffset": 30, "endOffset": 34}, {"referenceID": 44, "context": "Combining the results of [2], [45], and [46], there exists a subset C of H, |C| \u2265 2, such that that every polymorphism of H restricted to C preserves the relation \u03c1 = {(a, b, c) : a + b = c} for some Abelian group structure on C.", "startOffset": 40, "endOffset": 44}, {"referenceID": 33, "context": "Indeed, by a result of Kazda [35], if a digraph admits a Maltsev polymorphism it also has a majority polymorphism; since the existence of a near-unanimity polymorphism implies the CSP has bounded width (this is as an easy exercise using Lemma 3.", "startOffset": 29, "endOffset": 33}, {"referenceID": 32, "context": "Kazda has proved [34] that if such a structure admits a Siggers polymorphism (i.", "startOffset": 17, "endOffset": 21}, {"referenceID": 12, "context": "The algorithm due to [14] is readily verified to be a semiuniform polynomial-time algorithm for M.", "startOffset": 21, "endOffset": 25}, {"referenceID": 26, "context": "[28, 30] Let H be a relational structure.", "startOffset": 0, "endOffset": 8}, {"referenceID": 28, "context": "[28, 30] Let H be a relational structure.", "startOffset": 0, "endOffset": 8}, {"referenceID": 0, "context": "However, the algorithm thusly given itself relies on the fact that a CSP having a commutative conservative polymorphism is decidable in polynomial-time; note that such a CSP can be complete for polynomial time (this occurs even in the case of the polymorphisms \u2227 and \u2228 on the domain {0, 1}, see for example [1]).", "startOffset": 307, "endOffset": 310}, {"referenceID": 0, "context": "By Claim 4, each of these relations is preserved by the majority operation m, and it is known that one can decide in NL all CSP instances on a two-element domain with a majority polymorphism [1].", "startOffset": 191, "endOffset": 194}, {"referenceID": 7, "context": "We remark that the notion of quasi- versions of operations has been previously considered in the literature, in particular, within the context of infinite-domain constraint satisfaction; see for example [8, 9].", "startOffset": 203, "endOffset": 209}, {"referenceID": 5, "context": "It is probable that some version of the following lemma is implicit in the literature (see also [6]).", "startOffset": 96, "endOffset": 99}, {"referenceID": 27, "context": "(This construction is essentially due to Feder, [29]) Suppose without loss of generality that e = (u, v) is an arc (otherwise we just reverse all the arcs in the gadgets).", "startOffset": 48, "endOffset": 52}, {"referenceID": 2, "context": "Barto (see [3], just after Corollary 8.", "startOffset": 11, "endOffset": 14}, {"referenceID": 36, "context": "The property of admitting k-symmetric polymorphisms of all arities k \u2265 2 characterises structures whose CSP admits a special kind of approximation algorithm based on linear programming [38], see also [27] and [20] Remark 5.", "startOffset": 185, "endOffset": 189}, {"referenceID": 25, "context": "The property of admitting k-symmetric polymorphisms of all arities k \u2265 2 characterises structures whose CSP admits a special kind of approximation algorithm based on linear programming [38], see also [27] and [20] Remark 5.", "startOffset": 200, "endOffset": 204}, {"referenceID": 18, "context": "The property of admitting k-symmetric polymorphisms of all arities k \u2265 2 characterises structures whose CSP admits a special kind of approximation algorithm based on linear programming [38], see also [27] and [20] Remark 5.", "startOffset": 209, "endOffset": 213}, {"referenceID": 26, "context": "A known sufficient condition for a structure to have a set polymorphism is that the structure has a semilattice polymorphism [28].", "startOffset": 125, "endOffset": 129}, {"referenceID": 29, "context": "We show that detecting this sufficient condition (that is, for a semilattice polymorphism) is NP-hard, even in the case where one restricts attention to conservative polymorphisms (see [31] for related results.", "startOffset": 185, "endOffset": 189}, {"referenceID": 39, "context": "For NP-hardness, we use a reduction from the classical NP-complete problem betweenness [41]: \u2022 Input: A list of triples (i, j, k) of distinct integers in {1, .", "startOffset": 87, "endOffset": 91}, {"referenceID": 26, "context": "The first two implications here follow from [28, 30]; the next two are direct; and, the last follows from Proposition 2.", "startOffset": 44, "endOffset": 52}, {"referenceID": 28, "context": "The first two implications here follow from [28, 30]; the next two are direct; and, the last follows from Proposition 2.", "startOffset": 44, "endOffset": 52}, {"referenceID": 28, "context": "The first implication follows from [30], the next two are direct, and the last can be argued in the following way, via Lemma 6.", "startOffset": 35, "endOffset": 39}, {"referenceID": 6, "context": "Another general known sufficient condition for the tractability of CSP(H) is few subpowers, studied by [7, 32].", "startOffset": 103, "endOffset": 110}, {"referenceID": 30, "context": "Another general known sufficient condition for the tractability of CSP(H) is few subpowers, studied by [7, 32].", "startOffset": 103, "endOffset": 110}, {"referenceID": 6, "context": "It is known that either the presence of a Maltsev polymorphism or a k-near unanimity polymorphism implies few subpowers [7] (although the metaquestion for k-near unanimity operations is tractable, recall Theorem 3.", "startOffset": 120, "endOffset": 123}, {"referenceID": 23, "context": "\u2022 A number of solution procedures that extend arc consistency have been proposed in the literature [25].", "startOffset": 99, "endOffset": 103}, {"referenceID": 22, "context": "For one of them, look-ahead arc consistency [24, 25], the metaquestion of deciding whether or not the procedure solves CSP(H) is known to be in polynomial time (see footnote 2 in [24]).", "startOffset": 44, "endOffset": 52}, {"referenceID": 23, "context": "For one of them, look-ahead arc consistency [24, 25], the metaquestion of deciding whether or not the procedure solves CSP(H) is known to be in polynomial time (see footnote 2 in [24]).", "startOffset": 44, "endOffset": 52}, {"referenceID": 22, "context": "For one of them, look-ahead arc consistency [24, 25], the metaquestion of deciding whether or not the procedure solves CSP(H) is known to be in polynomial time (see footnote 2 in [24]).", "startOffset": 179, "endOffset": 183}, {"referenceID": 8, "context": "One can inquire about the complexity of the corresponding metaquestion for other such extensions, such as peek arc consistency [10, 25].", "startOffset": 127, "endOffset": 135}, {"referenceID": 23, "context": "One can inquire about the complexity of the corresponding metaquestion for other such extensions, such as peek arc consistency [10, 25].", "startOffset": 127, "endOffset": 135}, {"referenceID": 42, "context": "By Swierczkowski\u2019s lemma [44], if f has arity 4 or more, then in fact, there exists a unique i such that f projects onto the i-th coordinate when we apply it to a tuple containing a repetition.", "startOffset": 25, "endOffset": 29}, {"referenceID": 24, "context": "In some contexts, however, it is natural to assume that the second structure H of each CSP instance (G,H) has its relations specified according to other representations (see the discussion in [26]).", "startOffset": 192, "endOffset": 196}, {"referenceID": 38, "context": "Alternative representations have been considered in the literature; for example, Marx [40] studied truth table representation, and Chen and Grohe [26] studied two representations which they called generalized DNF representation and decision diagram representation.", "startOffset": 86, "endOffset": 90}, {"referenceID": 24, "context": "Alternative representations have been considered in the literature; for example, Marx [40] studied truth table representation, and Chen and Grohe [26] studied two representations which they called generalized DNF representation and decision diagram representation.", "startOffset": 146, "endOffset": 150}], "year": 2017, "abstractText": "The constraint satisfaction problem (CSP) involves deciding, given a set of variables and a set of constraints on the variables, whether or not there is an assignment to the variables satisfying all of the constraints. One formulation of the CSP is as the problem of deciding, given a pair (G,H) of relational structures, whether or not there is a homomorphism from the first structure to the second structure. The CSP is in general NP-hard; a common way to restrict this problem is to fix the second structure H, so that each structure H gives rise to a problem CSP(H). The problem family CSP(H) has been studied using an algebraic approach, which links the algorithmic and complexity properties of each problem CSP(H) to a set of operations, the so-called polymorphisms of H. Certain types of polymorphisms are known to imply the polynomial-time tractability of CSP(H), and others are conjectured to do so. This article systematically studies\u2014for various classes of polymorphisms\u2014the computational complexity of deciding whether or not a given structure H admits a polymorphism from the class. Among other results, we prove the NP-completeness of deciding a condition conjectured to characterize the tractable problems CSP(H), as well as the NP-completeness of deciding if CSP(H) has bounded width.", "creator": "LaTeX with hyperref package"}}}