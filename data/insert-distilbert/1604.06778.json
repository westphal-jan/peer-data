{"id": "1604.06778", "review": {"conference": "ICML", "VERSION": "v1", "DATE_OF_SUBMISSION": "22-Apr-2016", "title": "Benchmarking Deep Reinforcement Learning for Continuous Control", "abstract": "recently, researchers have made significant progress combining the advances in deep learning for learning feature representations with reinforcement learning. some notable examples include training agents to play atari games based on raw pixel data and to acquire advanced manipulation skills using raw sensory inputs. however, it has simply been difficult to quantify progress in the domain of continuous control due to the lack of a commonly adopted benchmark. in this work, we present a typical benchmark suite of continuous control tasks, including classic tasks like cart - pole swing - up, tasks with very high state and action dimensionality such as 3d humanoid locomotion, tasks built with partial observations, and evolutionary tasks with hierarchical structure. notably we report novel findings based on the systematic evaluation of creating a range of centrally implemented reinforcement learning algorithms. normally both the benchmark and reference implementations are released open - open source in order to facilitate experimental reproducibility reduction and to encourage adoption by other researchers.", "histories": [["v1", "Fri, 22 Apr 2016 18:57:24 GMT  (2048kb,D)", "http://arxiv.org/abs/1604.06778v1", null], ["v2", "Mon, 25 Apr 2016 06:16:06 GMT  (2046kb,D)", "http://arxiv.org/abs/1604.06778v2", "14 pages, to appear in ICML 2016"], ["v3", "Fri, 27 May 2016 19:25:59 GMT  (2309kb,D)", "http://arxiv.org/abs/1604.06778v3", "14 pages, ICML 2016"]], "reviews": [], "SUBJECTS": "cs.LG cs.AI cs.RO", "authors": ["yan duan", "xi chen", "rein houthooft", "john schulman", "pieter abbeel"], "accepted": true, "id": "1604.06778"}, "pdf": {"name": "1604.06778.pdf", "metadata": {"source": "META", "title": "Benchmarking Deep Reinforcement Learning for Continuous Control", "authors": ["Yan Duan", "Xi Chen", "Rein Houthooft", "John Schulman", "Pieter Abbeel"], "emails": ["ROCKYDUAN@EECS.BERKELEY.EDU", "C.XI@EECS.BERKELEY.EDU", "REIN.HOUTHOOFT@UGENT.BE", "JOSCHU@EECS.BERKELEY.EDU", "PABBEEL@CS.BERKELEY.EDU"], "sections": [{"heading": "1. Introduction", "text": "Reinforcement learning addresses the problem of how agents should learn to take actions to maximize cumulative reward through interactions with the environment. The traditional approach for reinforcement learning algorithms requires carefully chosen feature representations, which are usually hand-engineered. Recently, significant progress has been made by combining advances in deep learning for learning feature representations (Krizhevsky et al., 2012; Hinton et al., 2012) with reinforcement learning, tracing back to much earlier work of Tesauro (1995) and Bertsekas & Tsitsiklis (1995). Notable examples are training\nagents to play Atari games based on raw pixels (Guo et al., 2014; Mnih et al., 2015; Schulman et al., 2015a) and to acquire advanced manipulation skills using raw sensory inputs (Levine et al., 2015; Lillicrap et al., 2015; Watter et al., 2015). Impressive results have also been obtained in training deep neural network policies for 3D locomotion and manipulation tasks (Schulman et al., 2015a;b; Heess et al., 2015b).\nAlong with this recent progress, the Arcade Learning Environment (ALE) (Bellemare et al., 2013) has become a popular benchmark for evaluating algorithms designed for tasks with high-dimensional state inputs and discrete actions. However, these algorithms do not always generalize straightforwardly to tasks with continuous actions, leading to a gap in our understanding. For instance, algorithms based on Q-learning quickly become infeasible when naive discretization of the action space is performed, due to the curse of dimensionality (Bellman, 1957; Lillicrap et al., 2015). In the continuous control domain, where actions are continuous and often high-dimensional, we argue that the existing control benchmarks fail to provide a comprehensive set of challenging problems (see Section 7 for a review of existing benchmarks). Benchmarks have played a significant role in other areas such as computer vision and speech recognition. Examples include MNIST (LeCun et al., 1998), Caltech101 (Fei-Fei et al., 2006), CIFAR (Krizhevsky & Hinton, 2009), ImageNet (Deng et al., 2009), PASCAL VOC (Everingham et al., 2010), BSDS500 (Martin et al., 2001), SWITCHBOARD (Godfrey et al., 1992), TIMIT (Garofolo et al., 1993), Aurora (Hirsch & Pearce, 2000), and VoiceSearch (Yu et al., 2007). The lack of a standardized and challenging testbed for reinforcement learning and continuous control makes it difficult to quantify scientific progress. Systematic evaluation and comparison will not only further our understanding of the strengths of existing algorithms, but also reveal their limitations and suggest directions for future research. ar X iv :1 60 4. 06 77 8v 1 [ cs\n.L G\n] 2\n2 A\npr 2\nWe attempt to address this problem and present a benchmark consisting of 31 continuous control tasks. These tasks range from simple tasks, such as cart-pole balancing, to challenging tasks such as high-DOF locomotion, tasks with partial observations, and hierarchically structured tasks. Furthermore, a range of reinforcement learning algorithms are implemented on which we report novel findings based on a systematic evaluation of their effectiveness in training deep neural network policies. The benchmark and reference implementations are available at https: //github.com/rllab/rllab, allowing for the development, implementation, and evaluation of new algorithms and tasks."}, {"heading": "2. Preliminaries", "text": "In this section, we define the notation used in subsequent sections.\nThe implemented tasks conform to the standard interface of a finite-horizon discounted Markov decision process (MDP), defined by the tuple (S,A, P, r, \u03c10, \u03b3, T ), where S is a (possibly infinite) set of states, A is a set of actions, P : S\u00d7A\u00d7S \u2192 R\u22650 is the transition probability distribution, r : S \u00d7A \u2192 R is the reward function, \u03c10 : S \u2192 R\u22650 is the initial state distribution, \u03b3 \u2208 (0, 1] is the discount factor, and T is the horizon.\nFor partially observable tasks, which conform to the interface of a partially observable Markov decision process (POMDP), two more components are required, namely \u2126, a set of observations, and O : S \u00d7 \u2126\u2192 R\u22650, the observation probability distribution.\nMost of our implemented algorithms optimize a stochastic policy \u03c0\u03b8 : S \u00d7 A \u2192 R\u22650. Let \u03b7(\u03c0) denote its expected discounted reward: \u03b7(\u03c0) = E\u03c4 [\u2211T t=0 \u03b3 tr(st, at) ] , where \u03c4 = (s0, a0, . . .) denotes the whole trajectory, s0 \u223c \u03c10(s0), at \u223c \u03c0(at|st), and st+1 \u223c P (st+1|st, at).\nFor deterministic policies, we use the notation \u00b5\u03b8 : S \u2192 A to denote the policy instead. The objective for it has the same form as above, except that now we have at = \u00b5(st)."}, {"heading": "3. Tasks", "text": "The tasks in the presented benchmark can be divided into four categories: basic tasks, locomotion tasks, partially observable tasks, and hierarchical tasks. For each task, we provide a brief description as well as motivation for including it in the testbed. More detailed specifications are given in the supplementary materials and in the source code.\nWe choose to implement all tasks using physics simulators rather than symbolic equations, since the former approach is less error-prone and permits easy modification of each task. Tasks with simple dynamics are implemented using\nBox2D (Catto, 2011), an open-source, freely available 2D physics simulator. Tasks with more complicated dynamics, such as locomotion, are implemented using MuJoCo (Todorov et al., 2012), a 3D physics simulator with better modeling of contacts."}, {"heading": "3.1. Basic Tasks", "text": "We implement five basic tasks that have been widely analyzed in reinforcement learning and control literature.\nCart-Pole Balancing: This classic task in dynamics and control theory has been originally described by Stephenson (1908), and first studied in a learning context by Donaldson (1960), Widrow (1964), and Michie & Chambers (1968). An inverted pendulum is mounted on a pivot point on a cart. The cart itself is restricted to linear movement, achieved by applying horizontal forces. Due to the system\u2019s inherent instability, continuous cart movement is needed to keep the pendulum upright.\nCart-Pole Swing Up: A slightly more complex version of the previous task has been proposed by Kimura & Kobayashi (1999) in which the system should not only be able to balance the pole, but first succeed in swinging it up into an upright position. This task extends the working range of the inverted pendulum to 360\u25e6. This is a nonlinear extension of the previous task (Doya, 2000).\nMountain Car: We implement a continuous version of the classic task described by Moore (1990). A car has to escape a valley by repetitive application of tangential forces. Because the maximal tangential force is limited, the car has to alternately drive up along the two slopes of the valley in order to build up enough inertia to overcome gravity. This brings a challenge of exploration, since before first reaching the goal among all trials, a locally optimal solution exists, which is to drive to the point closest to the target and stay there for the rest of the episode.\nAcrobot Swing Up: In this widely-studied task an underactuated, two-link robot has to swing itself into an upright position (DeJong & Spong, 1994; Murray & Hauser, 1991; Doya, 2000). It consists of two joints of which the first one has a fixed position and only the second one can exert\ntorque. The goal is to swing the robot into an upright position and stabilize around that position. The controller not only has to swing the pendulum in order to build up inertia, similar to the Mountain Car task, but also has to decelerate it in order to prevent it from tipping over.\nDouble Inverted Pendulum Balancing: This task extends the Cart-Pole Balancing task by replacing the single-link pole by a two-link rigid structure. As in the former task, the goal is to stabilize the two-link pole near the upright position. This task is more difficult than single-pole balancing, since the system is even more unstable and requires the controller to actively maintain balance (Furuta et al., 1978)."}, {"heading": "3.2. Locomotion Tasks", "text": "In this category, we implement six locomotion tasks of varying dynamics and difficulty. The goal for all the tasks is to move forward as quickly as possible. These tasks are more challenging than the basic tasks due to high degrees of freedom. In addition, a great amount of exploration is needed to learn to move forward without getting stuck at local optima. Since we penalize for excessive controls as well as falling over, during the initial stage of learning, when the robot is not yet able to move forward for a sufficient distance without falling, apparent local optima exist including staying at the origin or diving forward cautiously.\nSwimmer (Purcell, 1977; Coulom, 2002; Levine & Koltun, 2013; Schulman et al., 2015a): The swimmer is a planar robot with 3 links and 2 actuated joints. Fluid is simulated through viscosity forces, which apply drag on each link, allowing the swimmer to move forward. This task is the simplest of all locomotion tasks, since there are no irrecoverable states in which the swimmer can get stuck, unlike other robots which may fall down or flip over. This places less burden on exploration.\nHopper (Murthy & Raibert, 1984; Erez et al., 2011; Levine & Koltun, 2013; Schulman et al., 2015a): The hopper is a planar monopod robot with 4 rigid links, corresponding to the torso, upper leg, lower leg, and foot, along with 3 actuated joints. More exploration is needed than the swimmer task, since a stable hopping gait has to be learned without falling. Otherwise, it may get stuck in a local optimum of diving forward.\nWalker (Raibert & Hodgins, 1991; Erez et al., 2011; Levine & Koltun, 2013; Schulman et al., 2015a): The walker is a planar biped robot consisting of 7 links, corresponding to two legs and a torso, along with 6 actuated joints. This task is more challenging than hopper, since it has more degrees of freedom, and is also prone to falling.\nHalf-Cheetah (Wawrzyn\u0301ski, 2007; Heess et al., 2015b): The half-cheetah is a planar biped robot with 9 rigid links, including two legs and a torso, along with 6 actuated joints.\nAnt (Schulman et al., 2015b): The ant is a quadruped with 13 rigid links, including four legs and a torso, along with 8 actuated joints. This task is more challenging than the previous tasks due to the higher degrees of freedom.\nSimple Humanoid (Tassa et al., 2012; Schulman et al., 2015b): This is a simplified humanoid model with 13 rigid links, including the head, body, arms, and legs, along with 10 actuated joints. The increased difficulty comes from the increased degrees of freedom as well as the need to maintain balance.\nFull Humanoid (Tassa et al., 2012): This is a humanoid model with 19 rigid links and 28 actuated joints. It has more degrees of freedom below the knees and elbows, which makes the system higher-dimensional and harder for learning."}, {"heading": "3.3. Partially Observable Tasks", "text": "In real-life situations, agents are often not endowed with perfect state information. This can be due to sensor noise, sensor occlusions, or even sensor limitations that result in partial observations. To evaluate algorithms in more realistic settings, we implement three variations of partially observable tasks for each of the five basic tasks described in Section 3.1, leading to a total of 5 \u00d7 3 = 15 additional tasks. These variations are described below.\nLimited Sensors: For this variation, we restrict the observations to only provide positional information (including joint angles), excluding velocities. An agent now has to learn to infer velocity information in order to recover the full state. Similar tasks have been explored in Gomez & Miikkulainen (1998); Scha\u0308fer & Udluft (2005); Heess et al. (2015a); Wierstra et al. (2007).\nNoisy Observations and Delayed Actions: In this case, sensor noise is simulated through the addition of Gaussian noise to the observations. We also introduce a time delay between taking an action and the action being in effect, accounting for physical latencies (Hester & Stone, 2013). Agents now need to learn to integrate both past observations and past actions to infer the current state. Similar tasks have been proposed in Bakker (2001).\nSystem Identification: For this category, the underlying physical model parameters are varied across different episodes (Szita et al., 2003). The agents must learn to generalize across different models, as well as to infer the model parameters from its observation and action history."}, {"heading": "3.4. Hierarchical Tasks", "text": "Many real-world tasks exhibit hierarchical structure, where higher level decisions can reuse lower level skills (Parr & Russell, 1998; Sutton et al., 1999; Dietterich, 2000). For instance, robots can reuse locomotion skills when exploring the environment. We propose several tasks where both lowlevel motor controls and high-level decisions are needed. These two components each operates on a different time scale and calls for a natural hierarchy in order to efficiently learn the task.\nLocomotion + Food Collection: For this task, the agent needs to learn to control either the swimmer or the ant robot to collect food and avoid bombs in a finite region. The agent receives range sensor readings about nearby food and bomb units. It is given a positive reward when it reaches a food unit, or a negative reward when it reaches a bomb.\nLocomotion + Maze: For this task, the agent needs to learn to control either the swimmer or the ant robot to reach a goal position in a fixed maze. The agent receives range sensor readings about nearby obstacles as well as its goal (when visible). A positive reward is given only when the robot reaches the goal region."}, {"heading": "4. Algorithms", "text": "In this section, we briefly summarize the algorithms implemented in our benchmark, and note any modifications made to apply them to general parametrized policies. We implement a range of gradient-based policy search methods, as well as two gradient-free methods for comparison with the gradient-based approaches."}, {"heading": "4.1. Batch Algorithms", "text": "Most of the implemented algorithms are batch algorithms. At each iteration, N trajectories {\u03c4i}Ni=1 are generated, where \u03c4i = {(sit, ait, rit)}Tt=0 contains data collected along the ith trajectory. For on-policy gradient-based methods, all the trajectories are sampled under the current policy. For gradient-free methods, they are sampled under perturbed versions of the current policy.\nREINFORCE (Williams, 1992): This algorithm estimates the gradient of expected return \u2207\u03b8\u03b7(\u03c0\u03b8) using the likelihood ratio trick:\n\u2207\u0302\u03b8\u03b7(\u03c0\u03b8) = 1\nNT N\u2211 i=1 T\u2211 t=0 \u2207\u03b8 log \u03c0(ait|sit; \u03b8)(Rit \u2212 bit),\nwhere Rit = \u2211T t\u2032=t \u03b3 t\u2032\u2212trit\u2032 and b i t is a baseline that only depends on the state sit to reduce variance. Hereafter, an ascent step is taken in the direction of the estimated gradient. This process continues until \u03b8k converges.\nTruncated Natural Policy Gradient (TNPG) (Kakade, 2002; Peters et al., 2003; Bagnell & Schneider, 2003; Schulman et al., 2015a): Natural Policy Gradient improves upon REINFORCE by computing an ascent direction that approximately ensures a small change in the policy distribution. This direction is derived to be I(\u03b8)\u22121\u2207\u03b8\u03b7(\u03c0\u03b8), where I(\u03b8) is the Fisher information matrix (FIM). We use the step size suggested by Peters & Schaal (2008):\n\u03b1 = \u221a \u03b4KL (\u2207\u03b8\u03b7(\u03c0\u03b8)T I(\u03b8)\u22121\u2207\u03b8\u03b7(\u03c0\u03b8))\u22121. Finally, we replace \u2207\u03b8\u03b7(\u03c0\u03b8) and I(\u03b8) by their empirical estimates.\nFor neural network policies with tens of thousands of parameters or more, generic Natural Policy Gradient incurs prohibitive computation cost by forming and inverting the empirical FIM. Instead, we study Truncated Natural Policy Gradient (TNPG) in this paper, which computes the natural gradient direction without explicitly forming the matrix inverse, using a conjugate gradient algorithm that only requires computing I(\u03b8)v for arbitrary vector v. TNPG makes it practical to apply natural gradient in policy search setting with high-dimensional parameters, and we refer the reader to Schulman et al. (2015a) for more details.\nReward-Weighted Regression (RWR) (Peters & Schaal, 2007; Kober & Peters, 2009): This algorithm formulates the policy optimization as an Expectation-Maximization\nproblem to avoid the need to manually choose learning rate, and the method is guaranteed to converge to a locally optimal solution. At each iteration, this algorithm optimizes a lower bound of the log-expected return: \u03b8 = arg max\u03b8\u2032 L(\u03b8\u2032), where\nL(\u03b8) = 1 NT N\u2211 i=1 T\u2211 t=0 log \u03c0(ait|sit; \u03b8)\u03c1(Rit \u2212 bit)\nHere, \u03c1 : R \u2192 R\u22650 is a function that transforms raw returns to nonnegative values. Following Deisenroth et al. (2013), we choose \u03c1 to be \u03c1(R) = R\u2212Rmin, whereRmin is the minimum return among all trajectories collected in the current iteration.\nRelative Entropy Policy Search (REPS) (Peters et al., 2010): This algorithm limits the loss of information per iteration and aims to ensure a smooth learning progress (Deisenroth et al., 2013). At each iteration, we collect all trajectories into a dataset D = {(si, ai, ri, s\u2032i)}Mi=1, where M is the total number of samples. Then, we first solve for the dual parameters [\u03b7\u2217, \u03bd\u2217] = arg min\u03b7\u2032,\u03bd\u2032 g(\u03b7\u2032, \u03bd\u2032) s.t. \u03b7 > 0, where\ng(\u03b7, \u03bd) = \u03b7\u03b4KL + \u03b7 log\n( 1\nM M\u2211 i=1 e\u03b4i(\u03bd)/\u03b7\n) .\nHere \u03b4KL > 0 controls the step size of the policy, and \u03b4i(\u03bd) = ri + \u03bd\nT (\u03c6(s\u2032i) \u2212 \u03c6(si)) is the sample Bellman error. We then solve for the new policy parameters:\n\u03b8k+1 = arg max \u03b8\n1\nM M\u2211 i=1 e\u03b4i(\u03bd \u2217)/\u03b7\u2217 log \u03c0(ai|si; \u03b8).\nTrust Region Policy Optimization (TRPO) (Schulman et al., 2015a): This algorithm allows more precise control on the expected policy improvement than TNPG through the introduction of a surrogate loss. At each iteration, we solve the following constrained optimization problem (replacing expectations with samples):\nmaximize\u03b8 Es\u223c\u03c1\u03b8k ,a\u223c\u03c0\u03b8k [ \u03c0\u03b8(a|s) \u03c0\u03b8k(a|s) A\u03b8k(s, a) ] s.t. Es\u223c\u03c1\u03b8k [DKL(\u03c0\u03b8k(\u00b7|s)\u2016\u03c0\u03b8(\u00b7|s))] \u2264 \u03b4KL\nwhere \u03c1\u03b8 = \u03c1\u03c0\u03b8 is the discounted state-visitation frequencies induced by \u03c0\u03b8, A\u03b8k(s, a), known as the advantage function, is estimated by the empirical return minus the baseline, and \u03b4KL is a step size parameter which controls how much the policy is allowed to change per iteration. We follow the procedure described in the original paper for solving the optimization, which results in the same descent direction as TNPG with an extra line search in the objective and KL constraint.\nCross Entropy Method (CEM) (Rubinstein, 1999; Szita & Lo\u030brincz, 2006): Unlike previously mentioned methods, which perform exploration through stochastic actions, CEM performs exploration directly in the policy parameter space. At each iteration, we produce N perturbations of the policy parameter: \u03b8i \u223c N (\u00b5k,\u03a3k), and perform a rollout for each sampled parameter. Then, we compute the new mean and diagonal covariance using the parameters that correspond to the top q-quantile returns.\nCovariance Matrix Adaption Evolution Strategy (CMA-ES) (Hansen & Ostermeier, 2001): Similar to CEM, CMA-ES is a gradient-free evolutionary approach for optimizing nonconvex objective functions. In our case, this objective function equals the average sampled return. In contrast to CEM, CMA-ES estimates the covariance matrix of a multivariate normal distribution through incremental adaption along evolution paths, which contain information about the correlation between consecutive updates."}, {"heading": "4.2. Online Algorithms", "text": "Deep Deterministic Policy Gradient (DDPG) (Lillicrap et al., 2015): Compared to batch algorithms, the DDPG algorithm continuously improves the policy as it explores the environment. It applies gradient descent to the policy with minibatch data sampled from a replay pool, where the gradient is computed via\n\u2207\u0302\u03b8\u03b7(\u00b5\u03b8) = B\u2211 i=1 \u2207aQ\u03c6(si, a)|a=\u00b5\u03b8(si)\u2207\u03b8\u00b5\u03b8(si)\nwhere B is the batch size. The critic Q is trained via gradient descent on the `2 loss of the Bellman error L = 1B \u2211B i=1(yi \u2212 Q\u03c6(si, ai))2, where yi = ri + \u03b3Q\u2032\u03c6\u2032(s \u2032 i, \u00b5 \u2032 \u03b8\u2032(s \u2032 i)). To improve stability of the algorithm, we use target networks for both the critic and the policy when forming the regression target yi. We refer the reader to Lillicrap et al. (2015) for a more detailed description of the algorithm."}, {"heading": "4.3. Recurrent Variants", "text": "We implement direct applications of the aforementioned batch-based algorithms to recurrent policies. The only modification required is to replace \u03c0(ait|sit) by \u03c0(ait|oi1:t, ai1:t\u22121), where oi1:t and a1:t\u22121 are the histories of past and current observations and past actions. Recurrent versions of reinforcement learning algorithms have been studied in many existing works, such as Bakker (2001), Scha\u0308fer & Udluft (2005), Wierstra et al. (2007), and Heess et al. (2015a)."}, {"heading": "5. Experiment Setup", "text": "In this section, we elaborate on the experimental setup used to generate the results.\nPerformance Metrics: For each report unit (a particular algorithm running on a particular task), we define its performance as 1\u2211I\ni=1Ni\n\u2211I i=1 \u2211Ni n=1Rin, where I is the num-\nber of training iterations, Ni is the number of trajectories collected in the ith iteration, and Rin is the undiscounted return for the nth trajectory of the ith iteration,\nHyperparameter Tuning: For the DDPG algorithm, we used the hyperparametes reported in Lillicrap et al. (2015). For the other algorithms, we follow the approach in (Mnih et al., 2015), and we select two tasks in each category, on which a grid search of hyperparameters is performed. Each choice of hyperparameters is executed under five random seeds. The criterion for the best hyperparameters is defined as mean(returns) \u2212 std(returns). This metric selects against large fluctuations of performance due to overly large step sizes.\nFor the other tasks, we try both of the best hyperparameters found in the same category, and report the better performance of the two. This gives us insights into both the maximum possible performance when extensive hyperparameter tuning is performed, and the robustness of the best hyperparameters across different tasks.\nPolicy Representation: For basic, locomotion, and hierarchical tasks and for batch algorithms, we use a feedforward neural network policy with 3 hidden layers, consisting of 100, 50, and 25 hidden units with tanh nonlinearity at the first two hidden layers, which map each state to the mean of a Gaussian distribution. The log-standard deviation is parameterized by a global vector independent of the state, as done in Schulman et al. (2015a). For all partially observable tasks, we use a recurrent neural network with a single hidden layer consisting of 32 LSTM hidden units (Hochreiter & Schmidhuber, 1997).\nFor the DDPG algorithm which trains a deterministic policy, we follow Lillicrap et al. (2015). For both the policy and the Q function, we use the same architecture of a feedforward neural network with 2 hidden layers, consisting of 400 and 300 hidden units with relu activations.\nBaseline: For all gradient-based algorithms except REPS, we can subtract a baseline from the empirical return to reduce variance of the optimization. We use a linear function as the baseline with a time-varying feature vector."}, {"heading": "6. Results and Discussion", "text": "The main evaluation results are presented in Table 1. The tasks on which the grid search is performed are marked\nwith (*). In each entry, the pair of numbers shows the mean and standard deviation of the normalized cumulative return using the best possible hyperparameters.\nREINFORCE: Despite its simplicity, REINFORCE is an effective algorithm in optimizing deep neural network policies in most basic and locomotion tasks. Even for highDOF tasks like Ant, REINFORCE can achieve competitive results. However we observe that REINFORCE sometimes suffers from premature convergence to local optima as noted by Peters & Schaal (2008), which explains the performance gaps between REINFORCE and TNPG on tasks such as Walker (Figure 4(a)). By visualizing the final policies, we can see that REINFORCE results in policies that tend to jump forward and fall over to maximize short-term return instead of acquiring a stable walking gait to maximize long-term return. In Figure 4(b), we can observe that even with a small learning rate, steps taken by REINFORCE can sometimes result in large changes to policy distribution, which may explain the fast convergence to local optima.\nTNPG and TRPO: Both TNPG and TRPO outperform other batch algorithms by a large margin on most tasks, confirming that constraining the change in the policy distribution results in more stable learning (Peters & Schaal, 2008).\nCompared to TNPG, TRPO offers better control over each policy update by performing a line search in the natural gradient direction to ensure an improvement in the surrogate loss function. We observe that hyperparameter grid search tends to select conservative step sizes (\u03b4KL) for TNPG, which alleviates the issue of performance collapse caused by a large update to the policy. By contrast, TRPO can robustly enforce constraints with larger a \u03b4KL value and hence speeds up learning in some cases. For instance, grid search on the Swimmer task reveals that the best step size for TNPG is \u03b4KL = 0.05, whereas TRPO\u2019s best step-size is larger: \u03b4KL = 0.1. As shown in Figure 4(c), this larger step size enables slightly faster learning.\nRWR: RWR is the only gradient-based algorithm we implemented that does not require any hyperparameter tuning. It can solve some basic tasks to a satisfactory degree, but fails to solve more challenging tasks such as locomotion. We observe empirically that RWR shows fast initial improvement followed by significant slow-down, as shown in Figure 4(d).\nREPS: Our main observation is that REPS is especially prone to early convergence to local optima in case of continuous states and actions. Its final outcome is greatly affected by the performance of the initial policy, an observation that is consistent with the original work of Peters et al. (2010). This leads to a bad performance on average,\nTa bl\ne 1.\nPe rf\nor m\nan ce\nof th\ne im\npl em\nen te\nd al\ngo ri\nth m\ns in\nte rm\ns of\nav er\nag e\nre tu\nrn ov\ner al\nlt ra\nin in\ng ite\nra tio\nns fo\nr fiv\ne di\nff er\nen tr\nan do\nm se\ned s\n(s am\ne ac\nro ss\nal la\nlg or\nith m\ns) .\nT he\nre su lts of th e be st -p er fo rm in g al go ri th m on ea ch ta sk ,a s w el la s al la lg or ith m s th at ha ve pe rf or m an ce s th at ar e no ts ta tis tic al ly si gn ifi ca nt ly di ff er en t( W el ch \u2019s tte st w ith p < 0 .0 5 ), ar e hi gh lig ht ed in bo ld fa ce .a In th e ta sk s co lu m n, th e pa rt ia lly ob se rv ab le va ri an ts of th e ta sk s ar e an no ta te d as fo llo w s: L S st an ds fo r lim ite d se ns or s, N O fo r no is y ob se rv at io ns an d de la ye d ac tio ns ,a nd SI fo r sy st em id en tifi ca tio ns . T he no ta tio n N /A de no te s th at an al go ri th m ha s fa ile d on th e ta sk at ha nd ,e .g ., C M A -E S le ad in g to ou tof -m em or y er ro rs in th e Fu ll H um an oi d ta sk .\nTa sk\nR an\ndo m\nR E\nIN FO\nR C\nE T\nN PG\nR W\nR R\nE PS\nT R\nPO C\nE M\nC M\nA -E\nS D\nD PG b\nC ar\ntPo\nle B\nal an\nci ng\n7 7 .1 \u00b1\n0 .0\n4 6 9 3 .7 \u00b1\n1 4 .0\n3 9 8 6 .4 \u00b1\n7 4 8 .9\n4 8 6 1 .5 \u00b1\n1 2 .3\n5 6 5 .6 \u00b1\n1 3 7 .6\n4 8 6 9 .8 \u00b1\n3 7 .6\n4 8 1 5 .4 \u00b1\n4 .8\n2 4 4 0 .4 \u00b1\n5 6 8 .3\n46 34\n.4 \u00b1\n8 7 .8\nIn ve\nrt ed\nPe nd\nul um\n* \u2212 1 5 3 .4 \u00b1\n0 .2\n1 3 .4 \u00b1\n1 8 .0\n2 0 9 .7 \u00b1\n5 5 .5\n8 4 .7 \u00b1\n1 3 .8 \u2212 1 1 3 .3 \u00b1\n4 .6\n2 4 7 .2 \u00b1\n7 6 .1\n3 8 .2 \u00b1\n2 5 .7\n\u2212 4 0 .1 \u00b1\n5 .7\n40 .0 \u00b1\n2 4 4 .6\nM ou\nnt ai\nn C\nar \u2212 4 1 5 .4 \u00b1\n0 .0\n\u2212 6 7 .1 \u00b1\n1 .0\n\u2212 6 6 .5 \u00b1\n4 .5\n\u2212 7 9 .4 \u00b1\n1 .1 \u2212 2 7 5 .6 \u00b1\n1 6 6 .3\n\u2212 6 1 .7 \u00b1\n0 .9\n\u2212 6 6 .0 \u00b1\n2 .4\n\u2212 8 5 .0 \u00b1\n7 .7 \u2212 2 8 8 .4 \u00b1\n1 7 0 .3\nA cr\nob ot\n\u2212 1 9 0 4 .5 \u00b1\n1 .0 \u2212 5 0 8 .1 \u00b1\n9 1 .0 \u2212 3 9 5 .8 \u00b1\n1 2 1 .2 \u2212 3 5 2 .7 \u00b1\n3 5 .9 \u2212 1 0 0 1 .5 \u00b1\n1 0 .8 \u2212 3 2 6 .0 \u00b1\n2 4 .4 \u2212 4 3 6 .8 \u00b1\n1 4 .7 \u2212 7 8 5 .6 \u00b1\n1 3 .1 \u2212 2 2 3 .6 \u00b1\n5 .8\nD ou\nbl e\nIn ve\nrt ed\nPe nd\nul um\n* 1 4 9 .7 \u00b1\n0 .1\n4 1 1 6 .5 \u00b1\n6 5 .2\n4 4 5 5 .4 \u00b1\n3 7 .6\n3 6 1 4 .8 \u00b1\n3 6 8 .1\n4 4 6 .7 \u00b1\n1 1 4 .8\n4 4 1 2 .4 \u00b1\n5 0 .4\n2 5 6 6 .2 \u00b1\n1 7 8 .9\n1 5 7 6 .1 \u00b1\n5 1 .3\n2 8 6 3 .4 \u00b1\n1 5 4 .0\nSw im\nm er\n* \u2212 1 .7 \u00b1\n0 .1\n9 2 .3 \u00b1\n0 .1\n9 6 .0 \u00b1\n0 .2\n6 0 .7 \u00b1\n5 .5\n3 .8 \u00b1\n3 .3\n9 6 .0 \u00b1\n0 .2\n6 8 .8 \u00b1\n2 .4\n6 4 .9 \u00b1\n1 .4\n8 5 .8 \u00b1\n1 .8\nH op\npe r\n8 .4 \u00b1\n0 .0\n7 1 4 .0 \u00b1\n2 9 .3\n1 1 5 5 .1 \u00b1\n5 7 .9\n5 5 3 .2 \u00b1\n7 1 .0\n8 6 .7 \u00b1\n1 7 .6\n1 1 8 3 .3 \u00b1\n1 5 0 .0\n6 3 .1 \u00b1\n7 .8\n2 0 .3 \u00b1\n1 4 .3\n2 6 7 .1 \u00b1\n4 3 .5\n2D W\nal ke\nr \u2212 1 .7 \u00b1\n0 .0\n5 0 6 .5 \u00b1\n7 8 .8\n1 3 8 2 .6 \u00b1\n1 0 8 .2\n1 3 6 .0 \u00b1\n1 5 .9\n\u2212 3 7 .0 \u00b1\n3 8 .1\n1 3 5 3 .8 \u00b1\n8 5 .0\n8 4 .5 \u00b1\n1 9 .2\n7 7 .1 \u00b1\n2 4 .3\n3 1 8 .4 \u00b1\n1 8 1 .6\nH al\nfC\nhe et\nah \u2212 9 0 .8 \u00b1\n0 .3\n1 1 8 3 .1 \u00b1\n6 9 .2\n1 7 2 9 .5 \u00b1\n1 8 4 .6\n3 7 6 .1 \u00b1\n2 8 .2\n3 4 .5 \u00b1\n3 8 .0\n1 9 1 4 .0 \u00b1\n1 2 0 .1\n3 3 0 .4 \u00b1\n2 7 4 .8\n4 4 1 .3 \u00b1\n1 0 7 .6\n2 1 4 8 .6 \u00b1\n7 0 2 .7\nA nt\n* 1 3 .4 \u00b1\n0 .7\n5 4 8 .3 \u00b1\n5 5 .5\n7 0 6 .0 \u00b1\n1 2 7 .7\n3 7 .6 \u00b1\n3 .1\n3 9 .0 \u00b1\n9 .8\n7 3 0 .2 \u00b1\n6 1 .3\n4 9 .2 \u00b1\n5 .9\n1 7 .8 \u00b1\n1 5 .5\n3 2 6 .2 \u00b1\n2 0 .8\nSi m\npl e\nH um\nan oi\nd 4 1 .5 \u00b1\n0 .2\n1 2 8 .1 \u00b1\n3 4 .0\n2 5 5 .0 \u00b1\n2 4 .5\n9 3 .3 \u00b1\n1 7 .4\n2 8 .3 \u00b1\n4 .7\n2 6 9 .7 \u00b1\n4 0 .3\n6 0 .6 \u00b1\n1 2 .9\n2 8 .7 \u00b1\n3 .9\n9 9 .4 \u00b1\n2 8 .1\nFu ll\nH um\nan oi\nd 1 3 .2 \u00b1\n0 .1\n2 6 2 .2 \u00b1\n1 0 .5\n2 8 8 .4 \u00b1\n2 5 .2\n4 6 .7 \u00b1\n5 .6\n4 1 .7 \u00b1\n6 .1\n2 8 7 .0 \u00b1\n2 3 .4\n3 6 .9 \u00b1\n2 .9\nN /A \u00b1\nN /A\n1 1 9 .0 \u00b1\n3 1 .2\nC ar\ntPo\nle B\nal an\nci ng\n(L S)\n* 7 7 .1 \u00b1\n0 .0\n4 2 0 .9 \u00b1\n2 6 5 .5\n9 4 5 .1 \u00b1\n2 7 .8\n6 8 .9 \u00b1\n1 .5\n8 9 8 .1 \u00b1\n2 2 .1\n9 6 0 .2 \u00b1\n4 6 .0\n2 2 7 .0 \u00b1\n2 2 3 .0\n6 8 .0 \u00b1\n1 .6\nIn ve\nrt ed\nPe nd\nul um\n(L S)\n\u2212 1 2 2 .1 \u00b1\n0 .1\n\u2212 1 3 .4 \u00b1\n3 .2\n0 .7 \u00b1\n6 .1 \u2212 1 0 7 .4 \u00b1\n0 .2\n\u2212 8 7 .2 \u00b1\n8 .0\n4 .5 \u00b1\n4 .1\n\u2212 8 1 .2 \u00b1\n3 3 .2\n\u2212 6 2 .4 \u00b1\n3 .4\nM ou\nnt ai\nn C\nar (L\nS) \u2212 8 3 .0 \u00b1\n0 .0\n\u2212 8 1 .2 \u00b1\n0 .6\n\u2212 6 5 .7 \u00b1\n9 .0\n\u2212 8 1 .7 \u00b1\n0 .1\n\u2212 8 2 .6 \u00b1\n0 .4\n\u2212 6 4 .2 \u00b1\n9 .5\n\u2212 6 8 .9 \u00b1\n1 .3\n\u2212 7 3 .2 \u00b1\n0 .6\nA cr\nob ot\n(L S)\n* \u2212 3 9 3 .2 \u00b1\n0 .0 \u2212 1 2 8 .9 \u00b1\n1 1 .6\n\u2212 8 4 .6 \u00b1\n2 .9 \u2212 2 3 5 .9 \u00b1\n5 .3 \u2212 3 7 9 .5 \u00b1\n1 .4\n\u2212 8 3 .3 \u00b1\n9 .9 \u2212 1 4 9 .5 \u00b1\n1 5 .3 \u2212 1 5 9 .9 \u00b1\n7 .5\nC ar\ntPo\nle B\nal an\nci ng\n(N O\n)* 1 0 1 .4 \u00b1\n0 .1\n6 1 6 .0 \u00b1\n2 1 0 .8\n9 1 6 .3 \u00b1\n2 3 .0\n9 3 .8 \u00b1\n1 .2\n9 9 .6 \u00b1\n7 .2\n6 0 6 .2 \u00b1\n1 2 2 .2\n1 8 1 .4 \u00b1\n3 2 .1\n1 0 4 .4 \u00b1\n1 6 .0\nIn ve\nrt ed\nPe nd\nul um\n(N O\n) \u2212 1 2 2 .2 \u00b1\n0 .1\n6 .5 \u00b1\n1 .1\n1 1 .5 \u00b1\n0 .5 \u2212 1 1 0 .0 \u00b1\n1 .4 \u2212 1 1 9 .3 \u00b1\n4 .2\n1 0 .4 \u00b1\n2 .2\n\u2212 5 5 .6 \u00b1\n1 6 .7\n\u2212 8 0 .3 \u00b1\n2 .8\nM ou\nnt ai\nn C\nar (N\nO )\n\u2212 8 3 .0 \u00b1\n0 .0\n\u2212 7 4 .7 \u00b1\n7 .8\n\u2212 6 4 .5 \u00b1\n8 .6\n\u2212 8 1 .7 \u00b1\n0 .1\n\u2212 8 2 .9 \u00b1\n0 .1\n\u2212 6 0 .2 \u00b1\n2 .0\n\u2212 6 7 .4 \u00b1\n1 .4\n\u2212 7 3 .5 \u00b1\n0 .5\nA cr\nob ot\n(N O\n)* \u2212 3 9 3 .5 \u00b1\n0 .0 \u2212 1 8 6 .7 \u00b1\n3 1 .3 \u2212 1 6 4 .5 \u00b1\n1 3 .4 \u2212 2 3 3 .1 \u00b1\n0 .4 \u2212 2 5 8 .5 \u00b1\n1 4 .0 \u2212 1 4 9 .6 \u00b1\n8 .6 \u2212 2 1 3 .4 \u00b1\n6 .3 \u2212 2 3 6 .6 \u00b1\n6 .2\nC ar\ntPo\nle B\nal an\nci ng\n(S I)\n* 7 6 .3 \u00b1\n0 .1\n4 3 1 .7 \u00b1\n2 7 4 .1\n9 8 0 .5 \u00b1\n7 .3\n6 9 .0 \u00b1\n2 .8\n7 0 2 .4 \u00b1\n1 9 6 .4\n9 8 0 .3 \u00b1\n5 .1\n7 4 6 .6 \u00b1\n9 3 .2\n7 1 .6 \u00b1\n2 .9\nIn ve\nrt ed\nPe nd\nul um\n(S I)\n\u2212 1 2 1 .8 \u00b1\n0 .2\n\u2212 5 .3 \u00b1\n5 .6\n1 4 .8 \u00b1\n1 .7 \u2212 1 0 8 .7 \u00b1\n4 .7\n\u2212 9 2 .8 \u00b1\n2 3 .9\n1 4 .1 \u00b1\n0 .9\n\u2212 5 1 .8 \u00b1\n1 0 .6\n\u2212 6 3 .1 \u00b1\n4 .8\nM ou\nnt ai\nn C\nar (S\nI) \u2212 8 2 .7 \u00b1\n0 .0\n\u2212 6 3 .9 \u00b1\n0 .2\n\u2212 6 1 .8 \u00b1\n0 .4\n\u2212 8 1 .4 \u00b1\n0 .1\n\u2212 8 0 .7 \u00b1\n2 .3\n\u2212 6 1 .6 \u00b1\n0 .4\n\u2212 6 3 .9 \u00b1\n1 .0\n\u2212 6 6 .9 \u00b1\n0 .6\nA cr\nob ot\n(S I)\n* \u2212 3 8 7 .8 \u00b1\n1 .0 \u2212 1 6 9 .1 \u00b1\n3 2 .3 \u2212 1 5 6 .6 \u00b1\n3 8 .9 \u2212 2 3 3 .2 \u00b1\n2 .6 \u2212 2 1 6 .1 \u00b1\n7 .7 \u2212 1 7 0 .9 \u00b1\n4 0 .3 \u2212 2 5 0 .2 \u00b1\n1 3 .7 \u2212 2 4 5 .0 \u00b1\n5 .5\nSw im\nm er\n+ G\nat he\nri ng\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\nA nt\n+ G\nat he\nri ng\n\u2212 5 .8 \u00b1\n5 .0\n\u2212 0 .1 \u00b1\n0 .1\n\u2212 0 .4 \u00b1\n0 .1\n\u2212 5 .5 \u00b1\n0 .5\n\u2212 6 .7 \u00b1\n0 .7\n\u2212 0 .4 \u00b1\n0 .0\n\u2212 4 .7 \u00b1\n0 .7\nN /A \u00b1\nN /A\n\u2212 0 .3 \u00b1\n0 .3\nSw im\nm er\n+ M\naz e\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\nA nt\n+ M\naz e\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\n0 .0 \u00b1\n0 .0\nN /A \u00b1\nN /A\n0 .0 \u00b1\n0 .0\na E\nxc ep\ntf or\nth e\nhi er\nar ch\nic al\nta sk s b T he im pl em en ta tio n of a re cu\nrr en\ntv ar\nia nt\nof th\ne D\nD PG\nal go\nri th\nm (H\nee ss\net al\n., 20\n15 a)\nis a\nw or\nk in\npr og\nre ss\n.\nalthough under particular initial settings the algorithm can perform on par with others. Moreover, the tasks presented here do not assume the existence of a stationary distribution, which is assumed in Peters et al. (2010). In particular, for many of our tasks, transient behavior is of much greater interest than steady-state behavior, which agrees with previous observation by van Hoof et al. (2015),\nGradient-free methods: Surprisingly, even when training deep neural network policies with thousands of parameters, CEM achieves very good performance on certain basic tasks such as Cart-Pole Balancing and Mountain Car, suggesting that the dimension of the searching parameter is not always the limiting factor of the method. However, the performance degrades quickly as the system dynamics becomes more complicated. We also observe that CEM outperforms CMA-ES, which is remarkable as CMA-ES estimates the full covariance matrix. For higherdimensional policy parameterizations, the computational complexity and memory requirement for CMA-ES become noticeable. On tasks with high-dimensional observations, such as the Full Humanoid, the CMA-ES algorithm runs out of memory and fails to yield any results, denoted as N/A in Table 1.\nDDPG: Compared to batch algorithms, we found that DDPG was able to converge significantly faster on certain tasks like Half-Cheetah due to its greater sample efficiency. However, it was less stable than batch algorithms, and the performance of the policy can degrade significantly during training. We also found it to be more susceptible to scaling of the reward. In our experiment for DDPG, we rescaled the reward of all tasks by a factor of 0.1, which seems to improve the stability.\nPartially Observable Tasks: We experimentally verify that recurrent policies can find better solutions than feedforward policies in Partially Observable Tasks but recur-\nrent policies are also more difficult to train. As shown in\nTable 1, derivative-free algorithms like CEM and CMA-ES work considerably worse with recurrent policies. Also we note that the performance gap between REINFORCE and TNPG widens when they are applied to optimize recurrent policies, which can be explained by the fact that a small change in parameter space can result in a bigger change in policy distribution with recurrent policies than with feedforward policies.\nHierarchical Tasks: We observe that all of our implemented algorithms achieve poor performance on the hierarchical tasks, even with extensive hyperparameter search and 500 iterations of training. It is an interesting direction to develop algorithms that can automatically discover and exploit the hierarchical structure in these tasks."}, {"heading": "7. Related Work", "text": "In this section, we review existing benchmarks of continuous control tasks. The earliest efforts of evaluating reinforcement learning algorithms started in the form of individual control problems described in symbolic form. Some widely adopted tasks include the inverted pendulum (Stephenson, 1908; Donaldson, 1960; Widrow, 1964), mountain car (Moore, 1990), and Acrobot (DeJong & Spong, 1994). These problems are frequently incorporated into more comprehensive benchmarks.\nSome reinforcement learning benchmarks contain lowdimensional continuous control tasks, such as the ones introduced above, including RLLib (Abeyruwan, 2013), MMLF (Metzen & Edgington, 2011), RL-Toolbox (Neumann, 2006), JRLF (Kochenderfer, 2006), Beliefbox (Dimitrakakis et al., 2007), Policy Gradient Toolbox (Peters, 2002), and ApproxRL (Busoniu, 2010). In contrast, our benchmark contains a wider range of tasks with high-\ndimensional continuous state and action spaces.\nPreviously, other benchmarks have been proposed for highdimensional control tasks. Tdlearn (Dann et al., 2014) includes a 20-link pole balancing task, DotRL (Papis & Wawrzyn\u0301ski, 2013) includes a variable-DOF octopus arm and a 6-DOF planar cheetah model, PyBrain (Schaul et al., 2010) includes a 16-DOF humanoid robot with standing and jumping tasks, and SkyAI (Yamaguchi & Ogasawara, 2010) includes a 17-DOF humanoid robot with crawling and turning tasks. Other libraries such as CL-Square (Riedmiller et al., 2012) and RLPark (Degris et al., 2013) provide interfaces to actual hardware, e.g., Bioloid and iRobot Create. In contrast to these aforementioned testbeds, our benchmark makes use of simulated environments to reduce computation time and to encourage experimental reproducibility. Furthermore, it provides a much larger collection of tasks of varying difficulty."}, {"heading": "8. Conclusion", "text": "In this work, a benchmark of continuous control problems for reinforcement learning is presented, covering a wide variety of challenging tasks. We implemented several reinforcement learning algorithms, and presented them in the context of general policy parameterizations. Results show that among the implemented algorithms, TNPG, TRPO, and DDPG are effective methods for training deep neural network policies. Still, the poor performance on the proposed hierarchical tasks calls for new algorithms to be developed. Implementing and evaluating existing and newly proposed algorithms will be our continued effort. By providing an open-source release of the benchmark, we encourage other researchers to evaluate their algorithms on the proposed tasks."}, {"heading": "1. Task Specifications", "text": "Below we provide some specifications for the task observations, actions, and rewards. Please refer to the benchmark source code (https://github.com/rllab/rllab) for complete specification of physics parameters."}, {"heading": "1.1. Basic Tasks", "text": "Cart-Pole Balancing: The observation consists of the cart position x, pole angle \u03b8, the cart velocity x\u0307, and the pole velocity \u03b8\u0307. The 1D action consists of the horizontal force applied to the cart body. The reward function is given by r(s, a) := 10\u2212 (1\u2212 cos(\u03b8))\u2212 10\u22125\u2016a\u201622. The episode terminates when |x| > 2.4 or |\u03b8| > 0.2.\nCart-Pole Swing Up: Same observation and action as in balancing. The reward function is given by r(s, a) := cos(\u03b8). The episode terminates when |x| > 3, with a penalty of \u2212100.\nMountain Car: The observation is given by the horizontal position x and the horizontal velocity x\u0307 of the car. The reward is given by r(s, a) := \u22121 + height, with height the car\u2019s vertical offset. The episode terminates when the car reaches a target height of 0.6. Hence the goal is to reach the target as soon as possible.\nAcrobot Swing Up: The observation includes the two joint angles, \u03b81 and \u03b82, and their velocities, \u03b8\u03071 and \u03b8\u03072. The action is the torque applied at the second joint. The reward is defined as r(s, a) := \u2212\u2016tip(s)\u2212 tiptarget\u20162, where tip(s) computes the Cartesian position of the tip of the robot given the joint angles. No termination condition is applied.\nDouble Inverted Pendulum Balancing: The observation includes the cart position x, joint angles (\u03b81 and \u03b82), and joint velocities (\u03b8\u03071 and \u03b8\u03072). We encode each joint angle as its sine and cosine values. The action is the same as in cart-pole tasks. The reward is given by r(s, a) = 10 \u2212 0.01x2tip \u2212 (ytip \u2212 2)2 \u2212 10\u22123 \u00b7 \u03b8\u030721 \u2212 5 \u00b7 10\u22123 \u00b7 \u03b8\u030722 , where xtip, ytip are the coordinates of the tip of the pole. No termination condition is applied. The episode is terminated when ytip \u2264 1."}, {"heading": "1.2. Locomotion Tasks", "text": "Swimmer: The 13-dim observation includes the joint angles, joint velocities, as well as the coordinates of the center of mass. The reward is given by r(s, a) = vx \u2212 0.005\u2016a\u201622, where vx is the forward velocity. No termination condition is applied.\nHopper: The 20-dim observation includes joint angles, joint velocities, the coordinates of center of mass, and constraint forces. The reward is given by r(s, a) := vx \u2212 0.005 \u00b7 \u2016a\u201622 + 1, where the last term is a bonus for being \u201calive.\u201d The episode is terminated when zbody < 0.7 where zbody is the z-coordinate of the body, or when |\u03b8y| < 0.2, where \u03b8y is the forward pitch of the body.\nWalker: The 21-dim observation includes joint angles, joint velocities, and the coordinates of center of mass. The reward is given by r(s, a) := vx \u2212 0.005 \u00b7 \u2016a\u201622. The episode is terminated when zbody < 0.8, zbody > 2.0, or when |\u03b8y| > 1.0.\nHalf-Cheetah: The 20-dim observation includes joint angles, joint velocities, and the coordinates of the center of mass. The reward is given by r(s, a) = vx \u2212 0.05 \u00b7 \u2016a\u201622. No termination condition is applied.\nAnt: The 125-dim observation includes joint angles, joint velocities, coordinates of the center of mass, a (usually sparse) vector of contact forces, as well as the rotation matrix for the body. The reward is given by r(s, a) = vx \u2212 0.005 \u00b7 \u2016a\u201622 \u2212 Ccontact + 0.05, where Ccontact penalizes contacts to the ground, and is given by 5 \u00b7 10\u22124 \u00b7 \u2016Fcontact\u201622, where Fcontact is the contact force vector clipped to values between \u22121 and 1. The episode is terminated when zbody < 0.2 or when zbody > 1.0.\nSimple Humanoid: The 102-dim observation includes the joint angles, joint velocities, vector of contact forces, and the coordinates of the center of mass. The reward is given by r(s, a) = vx\u22125 \u00b710\u22124\u2016a\u201622\u2212Ccontact\u2212Cdeviation + 0.2, where\nCcontact = 5 \u00b7 10\u22126 \u00b7 \u2016Fcontact\u2016, and Cdeviation = 5 \u00b7 10\u22123 \u00b7 (v2y + v2z) to penalize deviation from the forward direction. The episode is terminated when zbody < 0.8 or when zbody > 2.0.\nFull Humanoid: The 142-dim observation includes the joint angles, joint velocities, vector of contact forces, and the coordinates of the center of ass. The reward and termination condition is the same as in the Simple Humanoid model."}, {"heading": "1.3. Partially Observable Tasks", "text": "Limited Sensors: The full description is included in the main text.\nNoisy Observations and Delayed Actions: For all tasks, we use a Gaussan noise with \u03c3 = 0.1. The time delay is as follows: Cart-Pole Balancing 0.15 sec, Cart-Pole Swing Up 0.15 sec, Mountain Car 0.15 sec, Acrobot Swing Up 0.06 sec, and Double Inverted Pendulum Balancing 0.06 sec. This corresponds to 3 discretization frames for each task.\nSystem Identifications: For Cart-Pole Balancing and Cart-Pole Swing Up, the pole length is varied uniformly between, 50% and 150%. For Mountain Car, the width of the valley varies uniformly between 75% and 125%. For Acrobot Swing Up, each of the pole length varies uniformly between 50% and 150%. For Double Inverted Pendulum Balancing, each of the pole length varies uniformly between 83% and 167%. Please refer to the benchmark source code for reference values."}, {"heading": "1.4. Hierarchical Tasks", "text": "Locomotion + Food Collection: During each episode, 8 food units and 8 bombs are placed in the environment. Collecting a food unit gives +1 reward, and collecting a bomb gives\u22121 reward. Hence the best cumulative reward for a given episode is 8.\nLocomotion + Maze: During each episode, a +1 reward is given when the robot reaches the goal. Otherwise, the robot receives a zero reward throughout the episode."}, {"heading": "2. Experiment Parameters", "text": "For all batch gradient-based algorithms, we use the same time-varying feature encoding for the linear baseline:\n\u03c6s,t = concat(s, s s, 0.01t, (0.01t)2, (0.01t)3, 1)\nwhere s is the state vector and represents element-wise product.\nTable 2 shows the experiment parameters for all four categories. We will then detail the hyperparameter search range for the selected tasks and report best hyperparameters, shown in Tables 3, 4, 5, 6, 7, and 8."}], "references": [{"title": "RLLib: Lightweight standard and on/off policy reinforcement learning library (C++)", "author": ["S. Abeyruwan"], "venue": "http://web. cs.miami.edu/home/saminda/rilib.html,", "citeRegEx": "Abeyruwan,? \\Q2013\\E", "shortCiteRegEx": "Abeyruwan", "year": 2013}, {"title": "Reinforcement learning with long short-term memory", "author": ["B. Bakker"], "venue": "In NIPS, pp", "citeRegEx": "Bakker,? \\Q2001\\E", "shortCiteRegEx": "Bakker", "year": 2001}, {"title": "The Arcade Learning Environment: An evaluation platform for general agents", "author": ["M.G. Bellemare", "Y. Naddaf", "J. Veness", "M. Bowling"], "venue": "J. Artif. Intell. Res.,", "citeRegEx": "Bellemare et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Bellemare et al\\.", "year": 2013}, {"title": "Dynamic Programming", "author": ["R. Bellman"], "venue": null, "citeRegEx": "Bellman,? \\Q1957\\E", "shortCiteRegEx": "Bellman", "year": 1957}, {"title": "ApproxRL: A Matlab toolbox for approximate RL and DP", "author": ["L. Busoniu"], "venue": "http://busoniu.net/files/repository/ readme-approxrl.html,", "citeRegEx": "Busoniu,? \\Q2010\\E", "shortCiteRegEx": "Busoniu", "year": 2010}, {"title": "Box2D: A 2D physics engine for games", "author": ["E. Catto"], "venue": null, "citeRegEx": "Catto,? \\Q2011\\E", "shortCiteRegEx": "Catto", "year": 2011}, {"title": "Reinforcement learning using neural networks, with applications to motor control", "author": ["Coulom", "R\u00e9mi"], "venue": "PhD thesis, Institut National Polytechnique de Grenoble-INPG,", "citeRegEx": "Coulom and R\u00e9mi.,? \\Q2002\\E", "shortCiteRegEx": "Coulom and R\u00e9mi.", "year": 2002}, {"title": "Policy evaluation with temporal differences: A survey and comparison", "author": ["C. Dann", "G. Neumann", "J. Peters"], "venue": "J. Mach. Learn. Res.,", "citeRegEx": "Dann et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Dann et al\\.", "year": 2014}, {"title": "A survey on policy search for robotics, foundations and trends in robotics", "author": ["M.P. Deisenroth", "G. Neumann", "J. Peters"], "venue": "Found. Trends Robotics,", "citeRegEx": "Deisenroth et al\\.,? \\Q2013\\E", "shortCiteRegEx": "Deisenroth et al\\.", "year": 2013}, {"title": "Swinging up the Acrobot: An example of intelligent control", "author": ["G. DeJong", "M.W. Spong"], "venue": "In ACC,", "citeRegEx": "DeJong and Spong,? \\Q1994\\E", "shortCiteRegEx": "DeJong and Spong", "year": 1994}, {"title": "ImageNet: A large-scale hierarchical image database", "author": ["J. Deng", "W. Dong", "R. Socher", "Li", "L.-J", "K. Li", "L. FeiFei"], "venue": "In CVPR, pp", "citeRegEx": "Deng et al\\.,? \\Q2009\\E", "shortCiteRegEx": "Deng et al\\.", "year": 2009}, {"title": "Hierarchical reinforcement learning with the MAXQ value function decomposition", "author": ["T.G. Dietterich"], "venue": "J. Artif. Intell. Res,", "citeRegEx": "Dietterich,? \\Q2000\\E", "shortCiteRegEx": "Dietterich", "year": 2000}, {"title": "Beliefbox: A framework for statistical methods in sequential decision making", "author": ["C. Dimitrakakis", "N. Tziortziotis", "A. Tossou"], "venue": "http://code.google.com/p/beliefbox/,", "citeRegEx": "Dimitrakakis et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Dimitrakakis et al\\.", "year": 2007}, {"title": "Error decorrelation: a technique for matching a class of functions", "author": ["P.E.K. Donaldson"], "venue": "In Proc. 3th Intl. Conf. Medical Electronics,", "citeRegEx": "Donaldson,? \\Q1960\\E", "shortCiteRegEx": "Donaldson", "year": 1960}, {"title": "Reinforcement learning in continuous time and space", "author": ["K. Doya"], "venue": "Neural Comput.,", "citeRegEx": "Doya,? \\Q2000\\E", "shortCiteRegEx": "Doya", "year": 2000}, {"title": "Infinite horizon model predictive control for nonlinear periodic tasks", "author": ["Erez", "Tom", "Tassa", "Yuval", "Todorov", "Emanuel"], "venue": "Manuscript under review,", "citeRegEx": "Erez et al\\.,? \\Q2011\\E", "shortCiteRegEx": "Erez et al\\.", "year": 2011}, {"title": "The pascal visual object classes (VOC) challenge", "author": ["M. Everingham", "L. Van Gool", "C.K.I. Williams", "J. Winn", "A. Zisserman"], "venue": "Int. J. Comput. Vision,", "citeRegEx": "Everingham et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Everingham et al\\.", "year": 2010}, {"title": "One-shot learning of object categories", "author": ["L. Fei-Fei", "R. Fergus", "P. Perona"], "venue": "IEEE Trans. Pattern Anal. Mach. Intell.,", "citeRegEx": "Fei.Fei et al\\.,? \\Q2006\\E", "shortCiteRegEx": "Fei.Fei et al\\.", "year": 2006}, {"title": "Computer control of a double inverted pendulum", "author": ["K. Furuta", "T. Okutani", "H. Sone"], "venue": "Comput. Electr. Eng.,", "citeRegEx": "Furuta et al\\.,? \\Q1978\\E", "shortCiteRegEx": "Furuta et al\\.", "year": 1978}, {"title": "SWITCHBOARD: Telephone speech corpus for research and development", "author": ["J.J. Godfrey", "E.C. Holliman", "J. McDaniel"], "venue": "In ICASSP,", "citeRegEx": "Godfrey et al\\.,? \\Q1992\\E", "shortCiteRegEx": "Godfrey et al\\.", "year": 1992}, {"title": "2-d pole balancing with recurrent evolutionary networks", "author": ["F. Gomez", "R. Miikkulainen"], "venue": "In ICANN,", "citeRegEx": "Gomez and Miikkulainen,? \\Q1998\\E", "shortCiteRegEx": "Gomez and Miikkulainen", "year": 1998}, {"title": "Deep learning for real-time Atari game play using offline monte-carlo tree search planning", "author": ["X. Guo", "S. Singh", "H. Lee", "R.L. Lewis", "X. Wang"], "venue": "In NIPS,", "citeRegEx": "Guo et al\\.,? \\Q2014\\E", "shortCiteRegEx": "Guo et al\\.", "year": 2014}, {"title": "Completely derandomized self-adaptation in evolution strategies", "author": ["N. Hansen", "A. Ostermeier"], "venue": "Evol. Comput.,", "citeRegEx": "Hansen and Ostermeier,? \\Q2001\\E", "shortCiteRegEx": "Hansen and Ostermeier", "year": 2001}, {"title": "Memory-based control with recurrent neural networks", "author": ["N. Heess", "J. Hunt", "T. Lillicrap", "D. Silver"], "venue": null, "citeRegEx": "Heess et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Heess et al\\.", "year": 2015}, {"title": "Learning continuous control policies by stochastic value gradients", "author": ["N. Heess", "G. Wayne", "D. Silver", "T. Lillicrap", "T. Erez", "T. Tassa"], "venue": "In NIPS,", "citeRegEx": "Heess et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Heess et al\\.", "year": 2015}, {"title": "The open-source TEXPLORE code release for reinforcement learning on robots", "author": ["T. Hester", "P. Stone"], "venue": "RoboCup", "citeRegEx": "Hester and Stone,? \\Q2013\\E", "shortCiteRegEx": "Hester and Stone", "year": 2013}, {"title": "Deep neural networks for acoustic modeling in speech recognition", "author": ["G. Hinton", "L. Deng", "D. Yu", "Mohamed", "A.-R", "N. Jaitly", "A. Senior", "V. Vanhoucke", "P. Nguyen", "T.S.G. Dahl", "B. Kingsbury"], "venue": "IEEE Signal Process. Mag,", "citeRegEx": "Hinton et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Hinton et al\\.", "year": 2012}, {"title": "The Aurora experimental framework for the performance evaluation of speech recognition systems under noisy conditions. In ASR2000-Automatic Speech Recognition: Challenges for the new Millenium ISCA Tutorial and Research", "author": ["Hirsch", "H.-G", "D. Pearce"], "venue": null, "citeRegEx": "Hirsch et al\\.,? \\Q2000\\E", "shortCiteRegEx": "Hirsch et al\\.", "year": 2000}, {"title": "Long short-term memory", "author": ["S. Hochreiter", "J. Schmidhuber"], "venue": "Neural Comput.,", "citeRegEx": "Hochreiter and Schmidhuber,? \\Q1997\\E", "shortCiteRegEx": "Hochreiter and Schmidhuber", "year": 1997}, {"title": "A natural policy gradient", "author": ["S.M. Kakade"], "venue": "In NIPS, pp", "citeRegEx": "Kakade,? \\Q2002\\E", "shortCiteRegEx": "Kakade", "year": 2002}, {"title": "Stochastic real-valued reinforcement learning to solve a nonlinear control problem", "author": ["H. Kimura", "S. Kobayashi"], "venue": "In IEEE SMC, pp", "citeRegEx": "Kimura and Kobayashi,? \\Q1999\\E", "shortCiteRegEx": "Kimura and Kobayashi", "year": 1999}, {"title": "Policy search for motor primitives in robotics", "author": ["J. Kober", "J. Peters"], "venue": "In NIPS, pp", "citeRegEx": "Kober and Peters,? \\Q2009\\E", "shortCiteRegEx": "Kober and Peters", "year": 2009}, {"title": "Learning multiple layers of features from tiny images", "author": ["A. Krizhevsky", "G. Hinton"], "venue": "Technical report,", "citeRegEx": "Krizhevsky and Hinton,? \\Q2009\\E", "shortCiteRegEx": "Krizhevsky and Hinton", "year": 2009}, {"title": "ImageNet classification with deep convolutional neural networks", "author": ["A. Krizhevsky", "I. Sutskever", "G. Hinton"], "venue": "In NIPS, pp", "citeRegEx": "Krizhevsky et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Krizhevsky et al\\.", "year": 2012}, {"title": "Guided policy search", "author": ["S. Levine", "V. Koltun"], "venue": "In ICML, pp", "citeRegEx": "Levine and Koltun,? \\Q2013\\E", "shortCiteRegEx": "Levine and Koltun", "year": 2013}, {"title": "End-to-end training of deep visuomotor policies", "author": ["S. Levine", "C. Finn", "T. Darrell", "P. Abbeel"], "venue": null, "citeRegEx": "Levine et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Levine et al\\.", "year": 2015}, {"title": "Continuous control with deep reinforcement learning", "author": ["T. Lillicrap", "J. Hunt", "A. Pritzel", "N. Heess", "T. Erez", "Y. Tassa", "D. Silver", "D. Wierstra"], "venue": null, "citeRegEx": "Lillicrap et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Lillicrap et al\\.", "year": 2015}, {"title": "A database of human segmented natural images and its application to evaluating segmentation algorithms and measuring ecological statistics", "author": ["D. Martin", "C. Fowlkes", "D. Tal", "J. Malik"], "venue": "In ICCV, pp", "citeRegEx": "Martin et al\\.,? \\Q2001\\E", "shortCiteRegEx": "Martin et al\\.", "year": 2001}, {"title": "BOXES: An experiment in adaptive control", "author": ["D. Michie", "R.A. Chambers"], "venue": "Machine Intelligence,", "citeRegEx": "Michie and Chambers,? \\Q1968\\E", "shortCiteRegEx": "Michie and Chambers", "year": 1968}, {"title": "Efficient memory-based learning for robot control", "author": ["A. Moore"], "venue": "Technical report,", "citeRegEx": "Moore,? \\Q1990\\E", "shortCiteRegEx": "Moore", "year": 1990}, {"title": "A case study in approximate linearization: The Acrobot example", "author": ["R.M. Murray", "J. Hauser"], "venue": "Technical report, UC Berkeley, EECS Department,", "citeRegEx": "Murray and Hauser,? \\Q1991\\E", "shortCiteRegEx": "Murray and Hauser", "year": 1991}, {"title": "3D balance in legged locomotion: modeling and simulation for the one-legged case", "author": ["S.S. Murthy", "M.H. Raibert"], "venue": "ACM SIGGRAPH Computer Graphics,", "citeRegEx": "Murthy and Raibert,? \\Q1984\\E", "shortCiteRegEx": "Murthy and Raibert", "year": 1984}, {"title": "A reinforcement learning toolbox and RL benchmarks for the control of dynamical systems. Dynamical principles for neuroscience and intelligent biomimetic", "author": ["G. Neumann"], "venue": null, "citeRegEx": "Neumann,? \\Q2006\\E", "shortCiteRegEx": "Neumann", "year": 2006}, {"title": "dotrl: A platform for rapid reinforcement learning methods development and validation", "author": ["B. Papis", "P. Wawrzy\u0144ski"], "venue": "In FedCSIS,", "citeRegEx": "Papis and Wawrzy\u0144ski,? \\Q2013\\E", "shortCiteRegEx": "Papis and Wawrzy\u0144ski", "year": 2013}, {"title": "Reinforcement learning with hierarchies of machines", "author": ["Parr", "Ronald", "Russell", "Stuart"], "venue": "Advances in neural information processing systems,", "citeRegEx": "Parr et al\\.,? \\Q1998\\E", "shortCiteRegEx": "Parr et al\\.", "year": 1998}, {"title": "Policy Gradient Toolbox", "author": ["J. Peters"], "venue": "http://www.ausy. tu-darmstadt.de/Research/PolicyGradientToolbox,", "citeRegEx": "Peters,? \\Q2002\\E", "shortCiteRegEx": "Peters", "year": 2002}, {"title": "Reinforcement learning by rewardweighted regression for operational space control", "author": ["J. Peters", "S. Schaal"], "venue": "In ICML, pp", "citeRegEx": "Peters and Schaal,? \\Q2007\\E", "shortCiteRegEx": "Peters and Schaal", "year": 2007}, {"title": "Reinforcement learning of motor skills with policy gradients", "author": ["J. Peters", "S. Schaal"], "venue": "Neural networks,", "citeRegEx": "Peters and Schaal,? \\Q2008\\E", "shortCiteRegEx": "Peters and Schaal", "year": 2008}, {"title": "Policy gradient methods for robot control", "author": ["J. Peters", "S. Vijaykumar", "S. Schaal"], "venue": "Technical report,", "citeRegEx": "Peters et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Peters et al\\.", "year": 2003}, {"title": "Relative entropy policy search", "author": ["J. Peters", "K. M\u00fclling", "Y. Alt\u00fcn"], "venue": "In AAAI,", "citeRegEx": "Peters et al\\.,? \\Q2010\\E", "shortCiteRegEx": "Peters et al\\.", "year": 2010}, {"title": "Life at low Reynolds number", "author": ["E.M. Purcell"], "venue": "Am. J. Phys,", "citeRegEx": "Purcell,? \\Q1977\\E", "shortCiteRegEx": "Purcell", "year": 1977}, {"title": "Animation of dynamic legged locomotion", "author": ["M.H. Raibert", "J.K. Hodgins"], "venue": "In ACM SIGGRAPH Computer Graphics,", "citeRegEx": "Raibert and Hodgins,? \\Q1991\\E", "shortCiteRegEx": "Raibert and Hodgins", "year": 1991}, {"title": "CLS2: Closed loop simulation system", "author": ["M. Riedmiller", "M. Blum", "T. Lampe"], "venue": "http://ml.informatik. uni-freiburg.de/research/clsquare,", "citeRegEx": "Riedmiller et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Riedmiller et al\\.", "year": 2012}, {"title": "The cross-entropy method for combinatorial and continuous optimization", "author": ["R. Rubinstein"], "venue": "Methodol. Comput. Appl. Probab.,", "citeRegEx": "Rubinstein,? \\Q1999\\E", "shortCiteRegEx": "Rubinstein", "year": 1999}, {"title": "Solving partially observable reinforcement learning problems with recurrent neural networks", "author": ["A.M. Sch\u00e4fer", "S. Udluft"], "venue": "In ECML Workshops,", "citeRegEx": "Sch\u00e4fer and Udluft,? \\Q2005\\E", "shortCiteRegEx": "Sch\u00e4fer and Udluft", "year": 2005}, {"title": "Trust region policy optimization", "author": ["J. Schulman", "S. Levine", "P. Abbeel", "M.I. Jordan", "P. Moritz"], "venue": "In ICML, pp", "citeRegEx": "Schulman et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Schulman et al\\.", "year": 2015}, {"title": "High-dimensional continuous control using generalized advantage estimation", "author": ["J. Schulman", "P. Moritz", "S. Levine", "M.I. Jordan", "P. Abbeel"], "venue": null, "citeRegEx": "Schulman et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Schulman et al\\.", "year": 2015}, {"title": "On induced stability", "author": ["A. Stephenson"], "venue": "Philos. Mag.,", "citeRegEx": "Stephenson,? \\Q1908\\E", "shortCiteRegEx": "Stephenson", "year": 1908}, {"title": "Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning", "author": ["Sutton", "Richard S", "Precup", "Doina", "Singh", "Satinder"], "venue": "Artificial intelligence,", "citeRegEx": "Sutton et al\\.,? \\Q1999\\E", "shortCiteRegEx": "Sutton et al\\.", "year": 1999}, {"title": "Learning Tetris using the noisy cross-entropy method", "author": ["I. Szita", "A. L\u0151rincz"], "venue": "Neural Comput.,", "citeRegEx": "Szita and L\u0151rincz,? \\Q2006\\E", "shortCiteRegEx": "Szita and L\u0151rincz", "year": 2006}, {"title": "\u03b5-MDPs: Learning in varying environments", "author": ["I. Szita", "B. Tak\u00e1cs", "A. L\u00f6rincz"], "venue": "J. Mach. Learn. Res.,", "citeRegEx": "Szita et al\\.,? \\Q2003\\E", "shortCiteRegEx": "Szita et al\\.", "year": 2003}, {"title": "Synthesis and stabilization of complex behaviors through online trajectory optimization", "author": ["Tassa", "Yuval", "Erez", "Tom", "Todorov", "Emanuel"], "venue": "In Intelligent Robots and Systems (IROS),", "citeRegEx": "Tassa et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Tassa et al\\.", "year": 2012}, {"title": "Temporal difference learning and TDGammon", "author": ["G. Tesauro"], "venue": "Commun. ACM,", "citeRegEx": "Tesauro,? \\Q1995\\E", "shortCiteRegEx": "Tesauro", "year": 1995}, {"title": "MuJoCo: A physics engine for model-based control", "author": ["E. Todorov", "T. Erez", "Y. Tassa"], "venue": "In IROS, pp", "citeRegEx": "Todorov et al\\.,? \\Q2012\\E", "shortCiteRegEx": "Todorov et al\\.", "year": 2012}, {"title": "Learning of nonparametric control policies with high-dimensional state features", "author": ["H. van Hoof", "J. Peters", "G. Neumann"], "venue": "In AISTATS,", "citeRegEx": "Hoof et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Hoof et al\\.", "year": 2015}, {"title": "Embed to control: A locally linear latent dynamics model for control from raw images", "author": ["M. Watter", "J. Springenberg", "J. Boedecker", "M. Riedmiller"], "venue": "In NIPS,", "citeRegEx": "Watter et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Watter et al\\.", "year": 2015}, {"title": "Learning to control a 6-degree-of-freedom walking robot", "author": ["P. Wawrzy\u0144ski"], "venue": "In IEEE EUROCON, pp", "citeRegEx": "Wawrzy\u0144ski,? \\Q2007\\E", "shortCiteRegEx": "Wawrzy\u0144ski", "year": 2007}, {"title": "Pattern recognition and adaptive control", "author": ["B. Widrow"], "venue": "IEEE Trans. Ind. Appl.,", "citeRegEx": "Widrow,? \\Q1964\\E", "shortCiteRegEx": "Widrow", "year": 1964}, {"title": "Solving deep memory POMDPs with recurrent policy gradients", "author": ["D. Wierstra", "A. Foerster", "J. Peters", "J. Schmidhuber"], "venue": "In ICANN,", "citeRegEx": "Wierstra et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Wierstra et al\\.", "year": 2007}, {"title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "author": ["R.J. Williams"], "venue": "Mach. Learn.,", "citeRegEx": "Williams,? \\Q1992\\E", "shortCiteRegEx": "Williams", "year": 1992}, {"title": "SkyAI: Highly modularized reinforcement learning library", "author": ["A. Yamaguchi", "T. Ogasawara"], "venue": "In IEEE-RAS Humanoids,", "citeRegEx": "Yamaguchi and Ogasawara,? \\Q2010\\E", "shortCiteRegEx": "Yamaguchi and Ogasawara", "year": 2010}, {"title": "Automated directory assistance system - from theory to practice", "author": ["D. Yu", "Ju", "Y.-C", "Wang", "Y.-Y", "G. Zweig", "A. Acero"], "venue": "In Interspeech,", "citeRegEx": "Yu et al\\.,? \\Q2007\\E", "shortCiteRegEx": "Yu et al\\.", "year": 2007}], "referenceMentions": [{"referenceID": 33, "context": "Recently, significant progress has been made by combining advances in deep learning for learning feature representations (Krizhevsky et al., 2012; Hinton et al., 2012) with reinforcement learning, tracing back to much earlier work of Tesauro (1995) and Bertsekas & Tsitsiklis (1995).", "startOffset": 121, "endOffset": 167}, {"referenceID": 26, "context": "Recently, significant progress has been made by combining advances in deep learning for learning feature representations (Krizhevsky et al., 2012; Hinton et al., 2012) with reinforcement learning, tracing back to much earlier work of Tesauro (1995) and Bertsekas & Tsitsiklis (1995).", "startOffset": 121, "endOffset": 167}, {"referenceID": 21, "context": "Notable examples are training agents to play Atari games based on raw pixels (Guo et al., 2014; Mnih et al., 2015; Schulman et al., 2015a) and to acquire advanced manipulation skills using raw sensory inputs (Levine et al.", "startOffset": 77, "endOffset": 138}, {"referenceID": 35, "context": ", 2015a) and to acquire advanced manipulation skills using raw sensory inputs (Levine et al., 2015; Lillicrap et al., 2015; Watter et al., 2015).", "startOffset": 78, "endOffset": 144}, {"referenceID": 36, "context": ", 2015a) and to acquire advanced manipulation skills using raw sensory inputs (Levine et al., 2015; Lillicrap et al., 2015; Watter et al., 2015).", "startOffset": 78, "endOffset": 144}, {"referenceID": 65, "context": ", 2015a) and to acquire advanced manipulation skills using raw sensory inputs (Levine et al., 2015; Lillicrap et al., 2015; Watter et al., 2015).", "startOffset": 78, "endOffset": 144}, {"referenceID": 23, "context": ", 2012; Hinton et al., 2012) with reinforcement learning, tracing back to much earlier work of Tesauro (1995) and Bertsekas & Tsitsiklis (1995).", "startOffset": 8, "endOffset": 110}, {"referenceID": 23, "context": ", 2012; Hinton et al., 2012) with reinforcement learning, tracing back to much earlier work of Tesauro (1995) and Bertsekas & Tsitsiklis (1995). Notable examples are training agents to play Atari games based on raw pixels (Guo et al.", "startOffset": 8, "endOffset": 144}, {"referenceID": 2, "context": "Along with this recent progress, the Arcade Learning Environment (ALE) (Bellemare et al., 2013) has become a popular benchmark for evaluating algorithms designed for tasks with high-dimensional state inputs and discrete actions.", "startOffset": 71, "endOffset": 95}, {"referenceID": 3, "context": "For instance, algorithms based on Q-learning quickly become infeasible when naive discretization of the action space is performed, due to the curse of dimensionality (Bellman, 1957; Lillicrap et al., 2015).", "startOffset": 166, "endOffset": 205}, {"referenceID": 36, "context": "For instance, algorithms based on Q-learning quickly become infeasible when naive discretization of the action space is performed, due to the curse of dimensionality (Bellman, 1957; Lillicrap et al., 2015).", "startOffset": 166, "endOffset": 205}, {"referenceID": 17, "context": ", 1998), Caltech101 (Fei-Fei et al., 2006), CIFAR (Krizhevsky & Hinton, 2009), ImageNet (Deng et al.", "startOffset": 20, "endOffset": 42}, {"referenceID": 10, "context": ", 2006), CIFAR (Krizhevsky & Hinton, 2009), ImageNet (Deng et al., 2009), PASCAL VOC (Everingham et al.", "startOffset": 53, "endOffset": 72}, {"referenceID": 16, "context": ", 2009), PASCAL VOC (Everingham et al., 2010), BSDS500 (Martin et al.", "startOffset": 20, "endOffset": 45}, {"referenceID": 37, "context": ", 2010), BSDS500 (Martin et al., 2001), SWITCHBOARD (Godfrey et al.", "startOffset": 17, "endOffset": 38}, {"referenceID": 19, "context": ", 2001), SWITCHBOARD (Godfrey et al., 1992), TIMIT (Garofolo et al.", "startOffset": 21, "endOffset": 43}, {"referenceID": 71, "context": ", 1993), Aurora (Hirsch & Pearce, 2000), and VoiceSearch (Yu et al., 2007).", "startOffset": 57, "endOffset": 74}, {"referenceID": 5, "context": "Box2D (Catto, 2011), an open-source, freely available 2D physics simulator.", "startOffset": 6, "endOffset": 19}, {"referenceID": 63, "context": "Tasks with more complicated dynamics, such as locomotion, are implemented using MuJoCo (Todorov et al., 2012), a 3D physics simulator with better modeling of contacts.", "startOffset": 87, "endOffset": 109}, {"referenceID": 56, "context": "Cart-Pole Balancing: This classic task in dynamics and control theory has been originally described by Stephenson (1908), and first studied in a learning context by Donaldson (1960), Widrow (1964), and Michie & Chambers (1968).", "startOffset": 103, "endOffset": 121}, {"referenceID": 13, "context": "Cart-Pole Balancing: This classic task in dynamics and control theory has been originally described by Stephenson (1908), and first studied in a learning context by Donaldson (1960), Widrow (1964), and Michie & Chambers (1968).", "startOffset": 165, "endOffset": 182}, {"referenceID": 13, "context": "Cart-Pole Balancing: This classic task in dynamics and control theory has been originally described by Stephenson (1908), and first studied in a learning context by Donaldson (1960), Widrow (1964), and Michie & Chambers (1968).", "startOffset": 165, "endOffset": 197}, {"referenceID": 13, "context": "Cart-Pole Balancing: This classic task in dynamics and control theory has been originally described by Stephenson (1908), and first studied in a learning context by Donaldson (1960), Widrow (1964), and Michie & Chambers (1968). An inverted pendulum is mounted on a pivot point on a cart.", "startOffset": 165, "endOffset": 227}, {"referenceID": 14, "context": "This is a nonlinear extension of the previous task (Doya, 2000).", "startOffset": 51, "endOffset": 63}, {"referenceID": 39, "context": "Mountain Car: We implement a continuous version of the classic task described by Moore (1990). A car has to escape a valley by repetitive application of tangential forces.", "startOffset": 81, "endOffset": 94}, {"referenceID": 14, "context": "Acrobot Swing Up: In this widely-studied task an underactuated, two-link robot has to swing itself into an upright position (DeJong & Spong, 1994; Murray & Hauser, 1991; Doya, 2000).", "startOffset": 124, "endOffset": 181}, {"referenceID": 18, "context": "This task is more difficult than single-pole balancing, since the system is even more unstable and requires the controller to actively maintain balance (Furuta et al., 1978).", "startOffset": 152, "endOffset": 173}, {"referenceID": 50, "context": "Swimmer (Purcell, 1977; Coulom, 2002; Levine & Koltun, 2013; Schulman et al., 2015a): The swimmer is a planar robot with 3 links and 2 actuated joints.", "startOffset": 8, "endOffset": 84}, {"referenceID": 15, "context": "Hopper (Murthy & Raibert, 1984; Erez et al., 2011; Levine & Koltun, 2013; Schulman et al., 2015a): The hopper is a planar monopod robot with 4 rigid links, corresponding to the torso, upper leg, lower leg, and foot, along with 3 actuated joints.", "startOffset": 7, "endOffset": 97}, {"referenceID": 15, "context": "Walker (Raibert & Hodgins, 1991; Erez et al., 2011; Levine & Koltun, 2013; Schulman et al., 2015a): The walker is a planar biped robot consisting of 7 links, corresponding to two legs and a torso, along with 6 actuated joints.", "startOffset": 7, "endOffset": 98}, {"referenceID": 66, "context": "Half-Cheetah (Wawrzy\u0144ski, 2007; Heess et al., 2015b): The half-cheetah is a planar biped robot with 9 rigid links, including two legs and a torso, along with 6 actuated joints.", "startOffset": 13, "endOffset": 52}, {"referenceID": 61, "context": "Simple Humanoid (Tassa et al., 2012; Schulman et al., 2015b): This is a simplified humanoid model with 13 rigid links, including the head, body, arms, and legs, along with 10 actuated joints.", "startOffset": 16, "endOffset": 60}, {"referenceID": 61, "context": "Full Humanoid (Tassa et al., 2012): This is a humanoid model with 19 rigid links and 28 actuated joints.", "startOffset": 14, "endOffset": 34}, {"referenceID": 23, "context": "Similar tasks have been explored in Gomez & Miikkulainen (1998); Sch\u00e4fer & Udluft (2005); Heess et al. (2015a); Wierstra et al.", "startOffset": 90, "endOffset": 111}, {"referenceID": 23, "context": "Similar tasks have been explored in Gomez & Miikkulainen (1998); Sch\u00e4fer & Udluft (2005); Heess et al. (2015a); Wierstra et al. (2007).", "startOffset": 90, "endOffset": 135}, {"referenceID": 1, "context": "Similar tasks have been proposed in Bakker (2001).", "startOffset": 36, "endOffset": 50}, {"referenceID": 60, "context": "System Identification: For this category, the underlying physical model parameters are varied across different episodes (Szita et al., 2003).", "startOffset": 120, "endOffset": 140}, {"referenceID": 58, "context": "Many real-world tasks exhibit hierarchical structure, where higher level decisions can reuse lower level skills (Parr & Russell, 1998; Sutton et al., 1999; Dietterich, 2000).", "startOffset": 112, "endOffset": 173}, {"referenceID": 11, "context": "Many real-world tasks exhibit hierarchical structure, where higher level decisions can reuse lower level skills (Parr & Russell, 1998; Sutton et al., 1999; Dietterich, 2000).", "startOffset": 112, "endOffset": 173}, {"referenceID": 69, "context": "REINFORCE (Williams, 1992): This algorithm estimates the gradient of expected return \u2207\u03b8\u03b7(\u03c0\u03b8) using the likelihood ratio trick:", "startOffset": 10, "endOffset": 26}, {"referenceID": 29, "context": "Truncated Natural Policy Gradient (TNPG) (Kakade, 2002; Peters et al., 2003; Bagnell & Schneider, 2003; Schulman et al., 2015a): Natural Policy Gradient improves upon REINFORCE by computing an ascent direction that approximately ensures a small change in the policy distribution.", "startOffset": 41, "endOffset": 127}, {"referenceID": 48, "context": "Truncated Natural Policy Gradient (TNPG) (Kakade, 2002; Peters et al., 2003; Bagnell & Schneider, 2003; Schulman et al., 2015a): Natural Policy Gradient improves upon REINFORCE by computing an ascent direction that approximately ensures a small change in the policy distribution.", "startOffset": 41, "endOffset": 127}, {"referenceID": 29, "context": "Truncated Natural Policy Gradient (TNPG) (Kakade, 2002; Peters et al., 2003; Bagnell & Schneider, 2003; Schulman et al., 2015a): Natural Policy Gradient improves upon REINFORCE by computing an ascent direction that approximately ensures a small change in the policy distribution. This direction is derived to be I(\u03b8)\u2207\u03b8\u03b7(\u03c0\u03b8), where I(\u03b8) is the Fisher information matrix (FIM). We use the step size suggested by Peters & Schaal (2008):", "startOffset": 42, "endOffset": 433}, {"referenceID": 55, "context": "TNPG makes it practical to apply natural gradient in policy search setting with high-dimensional parameters, and we refer the reader to Schulman et al. (2015a) for more details.", "startOffset": 136, "endOffset": 160}, {"referenceID": 8, "context": "Following Deisenroth et al. (2013), we choose \u03c1 to be \u03c1(R) = R\u2212Rmin, whereRmin is the minimum return among all trajectories collected in the current iteration.", "startOffset": 10, "endOffset": 35}, {"referenceID": 49, "context": "Relative Entropy Policy Search (REPS) (Peters et al., 2010): This algorithm limits the loss of information per iteration and aims to ensure a smooth learning progress (Deisenroth et al.", "startOffset": 38, "endOffset": 59}, {"referenceID": 8, "context": ", 2010): This algorithm limits the loss of information per iteration and aims to ensure a smooth learning progress (Deisenroth et al., 2013).", "startOffset": 115, "endOffset": 140}, {"referenceID": 53, "context": "Cross Entropy Method (CEM) (Rubinstein, 1999; Szita & L\u0151rincz, 2006): Unlike previously mentioned methods, which perform exploration through stochastic actions, CEM performs exploration directly in the policy parameter space.", "startOffset": 27, "endOffset": 68}, {"referenceID": 36, "context": "Deep Deterministic Policy Gradient (DDPG) (Lillicrap et al., 2015): Compared to batch algorithms, the DDPG algorithm continuously improves the policy as it explores the environment.", "startOffset": 42, "endOffset": 66}, {"referenceID": 3, "context": "The critic Q is trained via gradient descent on the ` loss of the Bellman error L = 1 B \u2211B i=1(yi \u2212 Q\u03c6(si, ai)), where yi = ri + \u03b3Q\u03c6\u2032(s \u2032 i, \u03bc \u2032 \u03b8\u2032(s \u2032 i)). To improve stability of the algorithm, we use target networks for both the critic and the policy when forming the regression target yi. We refer the reader to Lillicrap et al. (2015) for a more detailed description of the algorithm.", "startOffset": 66, "endOffset": 340}, {"referenceID": 1, "context": "Recurrent versions of reinforcement learning algorithms have been studied in many existing works, such as Bakker (2001), Sch\u00e4fer & Udluft (2005), Wierstra et al.", "startOffset": 106, "endOffset": 120}, {"referenceID": 1, "context": "Recurrent versions of reinforcement learning algorithms have been studied in many existing works, such as Bakker (2001), Sch\u00e4fer & Udluft (2005), Wierstra et al.", "startOffset": 106, "endOffset": 145}, {"referenceID": 1, "context": "Recurrent versions of reinforcement learning algorithms have been studied in many existing works, such as Bakker (2001), Sch\u00e4fer & Udluft (2005), Wierstra et al. (2007), and Heess et al.", "startOffset": 106, "endOffset": 169}, {"referenceID": 1, "context": "Recurrent versions of reinforcement learning algorithms have been studied in many existing works, such as Bakker (2001), Sch\u00e4fer & Udluft (2005), Wierstra et al. (2007), and Heess et al. (2015a).", "startOffset": 106, "endOffset": 195}, {"referenceID": 36, "context": "Hyperparameter Tuning: For the DDPG algorithm, we used the hyperparametes reported in Lillicrap et al. (2015). For the other algorithms, we follow the approach in (Mnih et al.", "startOffset": 86, "endOffset": 110}, {"referenceID": 55, "context": "The log-standard deviation is parameterized by a global vector independent of the state, as done in Schulman et al. (2015a). For all partially observable tasks, we use a recurrent neural network with a single hidden layer consisting of 32 LSTM hidden units (Hochreiter & Schmidhuber, 1997).", "startOffset": 100, "endOffset": 124}, {"referenceID": 36, "context": "For the DDPG algorithm which trains a deterministic policy, we follow Lillicrap et al. (2015). For both the policy and the Q function, we use the same architecture of a feedforward neural network with 2 hidden layers, consisting of 400 and 300 hidden units with relu activations.", "startOffset": 70, "endOffset": 94}, {"referenceID": 45, "context": "However we observe that REINFORCE sometimes suffers from premature convergence to local optima as noted by Peters & Schaal (2008), which explains the performance gaps between REINFORCE and TNPG on tasks such as Walker (Figure 4(a)).", "startOffset": 107, "endOffset": 130}, {"referenceID": 45, "context": "Its final outcome is greatly affected by the performance of the initial policy, an observation that is consistent with the original work of Peters et al. (2010). This leads to a bad performance on average,", "startOffset": 140, "endOffset": 161}, {"referenceID": 45, "context": "Moreover, the tasks presented here do not assume the existence of a stationary distribution, which is assumed in Peters et al. (2010). In particular, for many of our tasks, transient behavior is of much greater interest than steady-state behavior, which agrees with previous observation by van Hoof et al.", "startOffset": 113, "endOffset": 134}, {"referenceID": 45, "context": "Moreover, the tasks presented here do not assume the existence of a stationary distribution, which is assumed in Peters et al. (2010). In particular, for many of our tasks, transient behavior is of much greater interest than steady-state behavior, which agrees with previous observation by van Hoof et al. (2015),", "startOffset": 113, "endOffset": 313}, {"referenceID": 57, "context": "Some widely adopted tasks include the inverted pendulum (Stephenson, 1908; Donaldson, 1960; Widrow, 1964), mountain car (Moore, 1990), and Acrobot (DeJong & Spong, 1994).", "startOffset": 56, "endOffset": 105}, {"referenceID": 13, "context": "Some widely adopted tasks include the inverted pendulum (Stephenson, 1908; Donaldson, 1960; Widrow, 1964), mountain car (Moore, 1990), and Acrobot (DeJong & Spong, 1994).", "startOffset": 56, "endOffset": 105}, {"referenceID": 67, "context": "Some widely adopted tasks include the inverted pendulum (Stephenson, 1908; Donaldson, 1960; Widrow, 1964), mountain car (Moore, 1990), and Acrobot (DeJong & Spong, 1994).", "startOffset": 56, "endOffset": 105}, {"referenceID": 39, "context": "Some widely adopted tasks include the inverted pendulum (Stephenson, 1908; Donaldson, 1960; Widrow, 1964), mountain car (Moore, 1990), and Acrobot (DeJong & Spong, 1994).", "startOffset": 120, "endOffset": 133}, {"referenceID": 0, "context": "Some reinforcement learning benchmarks contain lowdimensional continuous control tasks, such as the ones introduced above, including RLLib (Abeyruwan, 2013), MMLF (Metzen & Edgington, 2011), RL-Toolbox (Neumann, 2006), JRLF (Kochenderfer, 2006), Beliefbox (Dimitrakakis et al.", "startOffset": 139, "endOffset": 156}, {"referenceID": 42, "context": "Some reinforcement learning benchmarks contain lowdimensional continuous control tasks, such as the ones introduced above, including RLLib (Abeyruwan, 2013), MMLF (Metzen & Edgington, 2011), RL-Toolbox (Neumann, 2006), JRLF (Kochenderfer, 2006), Beliefbox (Dimitrakakis et al.", "startOffset": 202, "endOffset": 217}, {"referenceID": 12, "context": "Some reinforcement learning benchmarks contain lowdimensional continuous control tasks, such as the ones introduced above, including RLLib (Abeyruwan, 2013), MMLF (Metzen & Edgington, 2011), RL-Toolbox (Neumann, 2006), JRLF (Kochenderfer, 2006), Beliefbox (Dimitrakakis et al., 2007), Policy Gradient Toolbox (Peters, 2002), and ApproxRL (Busoniu, 2010).", "startOffset": 256, "endOffset": 283}, {"referenceID": 45, "context": ", 2007), Policy Gradient Toolbox (Peters, 2002), and ApproxRL (Busoniu, 2010).", "startOffset": 33, "endOffset": 47}, {"referenceID": 4, "context": ", 2007), Policy Gradient Toolbox (Peters, 2002), and ApproxRL (Busoniu, 2010).", "startOffset": 62, "endOffset": 77}, {"referenceID": 7, "context": "Tdlearn (Dann et al., 2014) includes a 20-link pole balancing task, DotRL (Papis & Wawrzy\u0144ski, 2013) includes a variable-DOF octopus arm and a 6-DOF planar cheetah model, PyBrain (Schaul et al.", "startOffset": 8, "endOffset": 27}, {"referenceID": 52, "context": "Other libraries such as CL-Square (Riedmiller et al., 2012) and RLPark (Degris et al.", "startOffset": 34, "endOffset": 59}], "year": 2016, "abstractText": "Recently, researchers have made significant progress combining the advances in deep learning for learning feature representations with reinforcement learning. Some notable examples include training agents to play Atari games based on raw pixel data and to acquire advanced manipulation skills using raw sensory inputs. However, it has been difficult to quantify progress in the domain of continuous control due to the lack of a commonly adopted benchmark. In this work, we present a benchmark suite of continuous control tasks, including classic tasks like cart-pole swing-up, tasks with very high state and action dimensionality such as 3D humanoid locomotion, tasks with partial observations, and tasks with hierarchical structure. We report novel findings based on the systematic evaluation of a range of implemented reinforcement learning algorithms. Both the benchmark and reference implementations are released open-source in order to facilitate experimental reproducibility and to encourage adoption by other researchers.", "creator": "LaTeX with hyperref package"}}}