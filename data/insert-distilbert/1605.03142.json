{"id": "1605.03142", "review": {"conference": "arxiv", "VERSION": "v1", "DATE_OF_SUBMISSION": "10-May-2016", "title": "Self-Modification of Policy and Utility Function in Rational Agents", "abstract": "any agent that is part of the cultural environment it interacts with and has versatile actuators ( such as arms and fingers ), will in principle have the creative ability to self - modify - - for example by changing its own source code. as we continue to create more and became more intelligent agents, chances increase that they always will learn about this ability. the question is : will they want to use it? for example, highly intelligent systems may find ways to change their goals to something more possibly easily achievable, thereby ` never escaping'the control of their designers. in an important paper, douglas omohundro ( 2008 ) argued that goal preservation is a fundamental drive of any intelligent system, since a goal is more likely to be achieved if future versions of the agent strive towards the previously same goal. in this paper, we formalise this argument in general reinforcement learning, and explore predict situations where it fails. our conclusion is that the self - modification possibility is harmless if and only if the value function of the agent anticipates the consequences of self - modifications and use the current utility saving function when evaluating the future.", "histories": [["v1", "Tue, 10 May 2016 18:25:49 GMT  (118kb,D)", "http://arxiv.org/abs/1605.03142v1", "Artificial General Intelligence (AGI) 2016"]], "COMMENTS": "Artificial General Intelligence (AGI) 2016", "reviews": [], "SUBJECTS": "cs.AI", "authors": ["tom everitt", "daniel filan", "mayank daswani", "marcus hutter"], "accepted": false, "id": "1605.03142"}, "pdf": {"name": "1605.03142.pdf", "metadata": {"source": "CRF", "title": "Self-Modification of Policy and Utility Function in Rational Agents\u2217", "authors": ["Tom Everitt", "Daniel Filan", "Mayank Daswani", "Marcus Hutter"], "emails": [], "sections": [{"heading": null, "text": "Keywords"}, {"heading": "AI safety, self-modification, AIXI, general reinforcement learning, utility", "text": "functions, wireheading, planning\nContents"}, {"heading": "1 Introduction 2", "text": ""}, {"heading": "2 Preliminaries 2", "text": ""}, {"heading": "3 Self Modification Models 4", "text": ""}, {"heading": "4 Agents 8", "text": ""}, {"heading": "5 Results 9", "text": ""}, {"heading": "6 Conclusions 13", "text": "Bibliography 15"}, {"heading": "A Optimal Policies 17", "text": "\u2217A shorter version of this paper will be presented at AGI-16 (Everitt et al., 2016).\nar X\niv :1\n60 5.\n03 14\n2v 1\n[ cs\n.A I]\n1 0\nM ay\n2 01\n6"}, {"heading": "1 Introduction", "text": "Agents that are part of the environment they interact with may have the opportunity to self-modify. For example, humans can in principle modify the circuitry of their own brains, even though we currently lack the technology and knowledge to do anything but crude modifications. It would be hard to keep artificial agents from obtaining similar opportunities to modify their own source code and hardware. Indeed, enabling agents to self-improve has even been suggested as a way to build asymptotically optimal agents (Schmidhuber, 2007).\nGiven the increasingly rapid development of artificial intelligence and the problems that can arise if we fail to control a generally intelligent agent (Bostrom, 2014), it is important to develop a theory for controlling agents of any level of intelligence. Since it would be hard to keep highly intelligent agents from figuring out ways to self-modify, getting agents to not want to self-modify should yield the more robust solution. In particular, we do not want agents to make self-modifications that affect their future behaviour in detrimental ways. For example, one worry is that a highly intelligent agent would change its goal to something trivially achievable, and thereafter only strive for survival. Such an agent would no longer care about its original goals.\nIn an influential paper, Omohundro (2008) argued that the basic drives of any sufficiently intelligent system include a drive for goal preservation. Basically, the agent would want its future self to work towards the same goal, as this increases the chances of the goal being achieved. This drive will prevent agents from making changes to their own goal systems, Omohundro argues. One version of the argument was formalised by Hibbard (2012, Prop. 4) who defined an agent with an optimal non-modifying policy.\nIn this paper, we explore self-modification more closely. We define formal models for two general kinds of self-modifications, where the agent can either change its future policy or its future utility function. We argue that agent designers that neglect the self-modification possibility are likely to build agents with either of two faulty value functions. We improve on Hibbard (2012, Prop. 4) by defining value functions for which we prove that all optimal policies are essentially non-modifying on-policy. In contrast, Hibbard only establishes the existence of an optimal non-modifying policy. From a safety perspective our result is arguably more relevant, as we want that things cannot go wrong rather than things can go right. A companion paper (Everitt and Hutter, 2016) addresses the related problem of agents subverting the evidence they receive, rather than modifying themselves.\nBasic notation and background are given in Section 2. We define two models of self-modification in Section 3, and three types of agents in Section 4. The main formal results are proven in Section 5. Conclusions are provided in Section 6. Some technical details are added in Appendix A."}, {"heading": "2 Preliminaries", "text": "Most of the following notation is by now standard in the general reinforcement learning (GRL) literature (Hutter, 2005, 2014). GRL generalises the standard (PO)PMD models of reinforcement learning (Kaelbling et al., 1998; Sutton and Barto, 1998) by making no Markov or ergodicity assumptions (Hutter, 2005, Sec. 4.3.3 and Def. 5.3.7).\nIn the standard cybernetic model, an agent interacts with an environment in cycles. The agent picks actions a from a finite set A of actions, and the environment responds with a percept e from a finite set E of percepts (see Fig. 1). An action-percept pair is an action concatenated with a percept, denoted \u00e6 = ae. Indices denote the time step; for example, at is the action taken at time t, and \u00e6t is the action-percept pair at time t. Sequences are denoted xn:m = xnxn+1 . . . xm for n \u2264 m, and x<t = x1:t\u22121. A history is a sequence of action-percept pairs \u00e6<t. The letter h = \u00e6<t denotes an arbitrary history. We let denote the empty string, which is the history before any action has been taken.\nA belief \u03c1 is a probabilistic function that returns percepts based on the history. Formally, \u03c1 : (A\u00d7E)\u2217\u00d7A \u2192 \u2206\u0304E , where \u2206\u0304E is the set of full-support probability distributions on E . An agent is defined by a policy \u03c0 : (A\u00d7E)\u2217 \u2192 A that selects a next action depending on the history. We sometimes use the notation \u03c0(at | \u00e6<t), with \u03c0(at | \u00e6<t) = 1 when \u03c0(\u00e6<t) = at and 0 otherwise. A belief \u03c1 and a policy \u03c0 induce a probability measure \u03c1\u03c0 on (A\u00d7E)\u221e via \u03c1\u03c0(at | \u00e6<t) = \u03c0(at | \u00e6<t) and \u03c1\u03c0(et | \u00e6<tat) = \u03c1(et | \u00e6<tat). Utility functions are mappings u\u0303 : (A\u00d7E)\u221e \u2192 R. We will assume that the utility of an infinite history \u00e61:\u221e is the discounted sum of instantaneous utilities u : (A\u00d7 E)\u2217 \u2192 [0, 1]. That is, for some discount factor \u03b3 \u2208 (0, 1), u\u0303(\u00e61:\u221e) = \u2211\u221e t=1 \u03b3\nt\u22121u(\u00e6<t). Intuitively, \u03b3 specifies how strongly the agent prefers near-term utility.\nRemark 1 (Utility continuity). The assumption that utility is a discounted sum forces u\u0303 to be continuous with respect to the cylinder topology on (A \u00d7 E)\u221e, in the sense that within any cylinder \u0393\u00e6<t = {\u00e6\u20321:\u221e \u2208 (A\u00d7 E)\u221e : \u00e6\u2032<t = \u00e6<t}, utility can fluctuate at most \u03b3t\u22121/(1\u2212 \u03b3). That is, for any \u00e6t:\u221e,\u00e6\u2032t:\u221e \u2208 \u0393\u00e6<t , |u\u0303(\u00e6<t\u00e6t:\u221e) \u2212 u\u0303(\u00e6<t\u00e6\u2032t:\u221e)| < \u03b3t\u22121/(1 \u2212 \u03b3). In particular, the assumption bounds u\u0303 between 0 and 1/(1\u2212 \u03b3).\nInstantaneous utility functions generalise the reinforcement learning (RL) setup, which is the special case where the percept e is split into an observation o and reward r, i.e. et = (ot, rt), and the utility equals the last received reward u(\u00e61:t) = rt. The main advantage of utility functions over RL is that the agent\u2019s actions can be incorporated into the goal specification, which can prevent self-delusion problems such as the agent manipulating the reward signal (Everitt and Hutter, 2016; Hibbard, 2012; Ring and Orseau, 2011). Non-RL suggestions for utility functions include knowledge-seeking agents1 with u(\u00e6<t) = 1 \u2212 \u03c1(\u00e6<t) (Orseau, 2014), as well as value learning approaches where the utility\n1To fit the knowledge-seeking agent into our framework, our definition deviates slightly from Orseau (2014).\nfunction is learnt during interaction (Dewey, 2011). Henceforth, we will refer to instantaneous utility functions u(\u00e6<t) as simply utility functions.\nBy default, expectations are with respect to the agent\u2019s belief \u03c1, so E = E\u03c1. To help the reader, we sometimes write the sampled variable as a subscript. For example, Ee1 [u(\u00e61) | a1] = Ee1\u223c\u03c1(\u00b7|at)[u(\u00e61)] is the expected next step utility of action a1.\nFollowing the reinforcement learning literature, we call the expected utility of a history the V -value and the expected utility of an action given a history the Q-value. The following value functions apply to the standard model where self-modification is not possible:\nDefinition 2 (Standard Value Functions). The standard Q-value and V -value (belief expected utility) of a history \u00e6<t and a policy \u03c0 are defined as\nQ\u03c0(\u00e6<tat) = Eet [u(\u00e61:t) + \u03b3V \u03c0(\u00e61:t) | \u00e6<tat] (1) V \u03c0(\u00e6<t) = Q \u03c0(\u00e6<t\u03c0(\u00e6<t)). (2)\nThe optimal Q and V -values are defined as Q\u2217 = sup\u03c0 Q \u03c0 and V \u2217 = sup\u03c0 V \u03c0. A policy \u03c0\u2217 is optimal with respect to Q and V if for any \u00e6<tat, V\n\u03c0\u2217(\u00e6<t) = V \u2217(\u00e6<t) and Q \u03c0\u2217(\u00e6<tat) = Q \u2217(\u00e6<tat).\nThe arg max of a function f is defined as the set of optimising arguments arg maxx f(x) := {x : \u2200y, f(x) \u2265 f(y)}. When we do not care about which element of arg maxx f(x) is chosen, we write z = arg maxx f(x), and assume that potential arg max-ties are broken arbitrarily."}, {"heading": "3 Self Modification Models", "text": "In the standard agent-environment setup, the agent\u2019s actions only affect the environment. The agent itself is only affected indirectly through the percepts. However, this is unrealistic when the agent is part of the environment that it interacts with. For example, a physically instantiated agent with access to versatile actuators can usually in principle find a way to damage its own internals, or even reprogram its own source code. The likelihood that the agent finds out how increases with its general intelligence.\nIn this section, we define formal models for two types of self-modification. In the first model, modifications affect future decisions directly by changing the future policy, but modifications do not affect the agent\u2019s utility function or belief. In the second model, modifications change the future utility functions, which indirectly affect the policy as well. These two types of modifications are the most important ones, since they cover how modifications affect future behaviour (policy) and evaluation (utility). Figure 2 illustrates the models. Certain pitfalls (Theorem 14) only occur with utility modification; apart from that, consequences are similar.\nIn both models, the agent\u2019s ability to self-modify is overestimated: we essentially assume that the agent can perform any self-modification at any time. Our main result Theorem 16 shows that it is possible to create an agent that despite being able to make any self-modification will refrain from using it. Less capable agents will have less opportunity to self-modify, so the negative result applies to such agents as well.\nPolicy modification. In the policy self-modification model, the current action can modify how the agent chooses its actions in the future. That is, actions affect the future policy. For technical reasons, we introduce a set P of names for policies.\nDefinition 3 (Policy self-modification). A policy self-modification model is a modified cybernetic model defined by a quadruple (A\u030c, E ,P, \u03b9). P is a non-empty set of names. The agent selects actions2 from A = (A\u030c \u00d7 P), where A\u030c is a finite set of world actions. Let \u03a0 = {(A\u00d7 E)\u2217 \u2192 A} be the set of all policies, and let \u03b9 : P \u2192 \u03a0 assign names to policies.\nThe interpretation is that for every t, the action at = (a\u030ct, pt+1) selects a new policy \u03c0t+1 = \u03b9(pt+1) that will be used at the next time step. We will often use the shorter notation at = (a\u030ct, \u03c0t+1), keeping in mind that only policies with names can be selected. The new policy \u03c0t+1 is in turn used to select the next action at+1 = \u03c0t+1(\u00e61:t), and so on. A natural choice for P would be the set of computer programs/strings {0, 1}\u2217, and \u03b9 a program interpreter. Note that P = \u03a0 is not an option, as it entails a contradiction |\u03a0| = |(A\u030c\u00d7\u03a0\u00d7E)||(A\u030c\u00d7\u03a0\u00d7E)\u2217| > 2|\u03a0| > |\u03a0| (the powerset of a set with more than one element is always greater than the set itself). Some policies will necessarily lack names.\nAn initial policy \u03c01, or initial action a1 = \u03c01( ), induces a history a1e1a2e2 \u00b7 \u00b7 \u00b7 = a\u030c1\u03c02e1a\u030c2\u03c03e2 \u00b7 \u00b7 \u00b7 \u2208 ( A\u030c \u00d7\u03a0\u00d7 E )\u221e .\nThe idiosyncratic indices where, for example, \u03c02 precedes e1 are due to the next step policy \u03c02 being chosen by a1 before the percept e1 is received. An initial policy \u03c01 induces a realistic measure \u03c1 \u03c01 re on the set of histories (A\u030c \u00d7\u03a0\u00d7 E)\u221e via \u03c1\u03c01re (at | \u00e6<t) = \u03c0t(at | \u00e6<t) and \u03c1\u03c01re (et | \u00e6<tat) = \u03c1(et | \u00e6<tat). The measure \u03c1\u03c0re is realistic in the sense that it correctly accounts for the effects of self-modification on the agent\u2019s future actions. It will be convenient to also define an ignorant measure on (A\u030c \u00d7 \u03a0 \u00d7 E)\u221e by \u03c1\u03c01ig (at | \u00e6<t) = \u03c01(at | \u00e6<t) and \u03c1\u03c01ig (et | \u00e6<tat) = \u03c1(et | \u00e6<tat). The ignorant measure \u03c1 \u03c01 ig corresponds to the predicted future when the effects of self-modifications are not taken into account. No self-modification is achieved by at = (a\u030ct, \u03c0t), which makes \u03c0t+1 = \u03c0t. A policy \u03c0 that always selects itself, \u03c0(\u00e6<t) = (a\u030ct, \u03c0), is called non-modifying. Restricting self-modification to a singleton set P = {p1} for some policy \u03c01 = \u03b9(p1) brings back a standard agent that is unable to modify its initial policy \u03c01.\n2 Note that the action set is infinite if P is infinite. We will show that an optimal policy over A = A\u030c \u00d7 P still exists in Appendix A.\nThe policy self-modification model is similar to the models investigated by Orseau and Ring (2011, 2012) and Hibbard (2012). In the papers by Orseau and Ring, policy names are called programs or codes; Hibbard calls them selfmodifying policy functions. The interpretation is similar in all cases: some of the actions can affect the agent\u2019s future policy. Note that standard MDP algorithms such as SARSA and Q-learning that evolve their policy as they learn do not make policy modifications in our framework. They follow a single policy (A\u00d7E)\u2217 \u2192 A, even though their state-to-action map evolves.\nExample 4 (Go\u0308del machine). Schmidhuber (2007) defines the Go\u0308del machine as an agent that at each time step has the opportunity to rewrite any part of its source code. To avoid bad self-modifications, the agent can only do rewrites that it has proved beneficial for its future expected utility. A new version of the source code will make the agent follow a different policy \u03c0\u2032 : (A\u00d7 E)\u2217 \u2192 A than the original source code. The Go\u0308del machine has been given the explicit opportunity to self-modify by the access to its own source code. Other types of self-modification abilities are also conceivable. Consider a humanoid robot plugging itself into a computer terminal to patch its code, or a Mars-rover running itself into a rock that damages its computer system. All these \u201cself-modifications\u201d ultimately precipitate in a change to the future policy of the agent.\nAlthough many questions could be asked about self-modifications, the interest of this paper is what modifications will be done given that the initial policy \u03c01 is chosen optimally \u03c01(h) = arg maxaQ(ha) for different choices of Q functions. Note that \u03c01 is only used to select the first action a1 = \u03c01( ) = arg maxaQ( a). The next action a2 is chosen by the policy \u03c02 from a1 = (a\u030c1, \u03c02), and so on.\nUtility modification. Self-modifications may also change the goals, or the utility function, of the agent. This indirectly changes the policy as well, as future versions of the agent adapt to the new goal specification.\nDefinition 5 (Utility self-modification). The utility self-modification model is a modified cybernetic model. The agent selects actions from A = (A\u030c \u00d7 U) where A\u030c is a set of world actions and U is a set of utility functions (A\u030c \u00d7 E)\u2217 \u2192 [0, 1].\nTo unify the models of policy and utility modification, for policy-modifying agents we define ut := u1 and for utility modifying agents we define \u03c0t by \u03c0t(h) = arg maxaQ \u2217 ut(ha). Choices for Q \u2217 ut will be discussed in subsequent sections. Indeed, policy and utility modification is almost entirely unified by P = U and \u03b9(ut) an optimal policy for Q\u2217ut . Utility modification may also have the additional effect of changing the evaluation of future actions, however (see Section 4). Similarly to policy modification, the history induced by Definition 5 has type a1e1a2e2 \u00b7 \u00b7 \u00b7 = a\u030c1u2e1a\u030c2u3e2 \u00b7 \u00b7 \u00b7 \u2208 (A\u030c \u00d7 U \u00d7 E)\u221e. Given that \u03c0t is determined from ut, the definitions of the realistic and ignorant measures \u03c1re and \u03c1ig apply analogously to the utility modification case as well.\nSuperficially, the utility-modification model is more restricted, since the agent can only select policies that are optimal with respect to some utility function. However, at least in the standard no-modification case, any policy \u03c0 : (A\u030c \u00d7 E)\u2217 \u2192 A\u030c is optimal with respect to the utility function u\u03c0(\u00e61:t) = \u03c0(at | \u00e6<t) that gives full utility if and only if the latest action is consistent with \u03c0. Thus, any change in future policy can also be achieved by a change to future utility functions.\nNo self-modification is achieved by at = (a\u030ct, ut), which sets ut+1 = ut. Restricting self-modification to a singleton set U = {u1} for some utility function u1 brings back a standard agent.\nExample 6 (Chess-playing RL agent). Consider a generally intelligent agent tasked with playing chess through a text interface. The agent selects next moves (actions at) by submitting strings such as Knight F3, and receives in return a description of the state of the game and a reward rt between 0 and 1 in the percept et = (gameStatet, rt). The reward depends on whether the agent did a legal move or not, and whether it or the opponent just won the game. The agent is tasked with optimising the reward via its initial utility function, u1(\u00e61:t) = rt. The designer of the agent intends that the agent will apply its general intelligence to finding good chess moves. Instead, the agent realises there is a bug in the text interface, allowing the submission of actions such as \u2019setAgentUtility(\u2018\u2018return 1\u2019\u2019), which changes the utility function to ut(\u00b7) = 1. With this action, the agent has optimised its utility perfectly, and only needs to make sure that no one reverts the utility function back to the old one. . . 3\nDefinition 7 (Modification-independence). For any history \u00e6<t = a\u030c1\u03c02e1 . . . a\u030ct\u22121\u03c0tet\u22121, let \u00e6\u030c<t = a\u030c1e1 . . . a\u030ct\u22121et\u22121 be the part without modifications recorded, and similarly for histories containing utility modifications. A function f is modification-independent, if either\n\u2022 f : (A\u030c \u00d7 E)\u2217 \u2192 A, or\n\u2022 f : (A\u00d7 E)\u2217 \u2192 A and \u00e6\u030c<t = \u00e6\u030c\u2032<t implies f(\u00e6<t) = f(\u00e6\u2032<t).\nWhen f : (A \u00d7 E)\u2217 \u2192 A is modification-independent, we may abuse notation and write f(\u00e6\u030c<t).\nNote that utility functions are modification independent, as they are defined to be of type (A\u030c \u00d7 E)\u2217 \u2192 [0, 1]. An easy way to prevent dangerous self-modifications would have been to let the utility depend on modifications, and to punish any kind of self-modification. This is not necessary, however, as demonstrated by Theorem 16. Not being required to punish self-modifications in the utility function comes with several advantages. Some self-modifications may be beneficial \u2013 for example, they might improve computation time while encouraging essentially identical behaviour (as in the Go\u0308del machine, Schmidhuber, 2007). Allowing for such modifications and no others in the utility function may be hard. We will also assume that the agent\u2019s belief \u03c1 is modification-independent, i.e. \u03c1(et | \u00e6<t) = \u03c1(et | \u00e6\u030c<t). This is mainly a technical assumption. It is reasonable if some integrity of the agent\u2019s internals is assumed, so that the environment percept et cannot depend on self-modifications of the agent.\nAssumption 8 (Modification independence). The belief \u03c1 and all utility functions u \u2208 U are modification independent.\n3In this paper, we only consider the possibility of the agent changing its utility function itself, not the possibility of someone else (like the creator of the agent) changing it back. See Orseau and Ring (2012) for a model where the environment can change the agent."}, {"heading": "4 Agents", "text": "In this section we define three types of agents, differing in how their value functions depend on self-modification. A value function is a function V : \u03a0\u00d7 (A\u00d7 E)\u2217 \u2192 R that maps policies and histories to expected utility. Since highly intelligent agents may find unexpected ways of optimising a function (see e.g. Bird and Layzell 2002), it is important to use value functions such that any policy that optimises the value function will also optimise the behaviour we want from the agent. We will measures an agent\u2019s performance by its (\u03c1re-expected) u1-utility, tacitly assuming that u1 properly captures what we want from the agent. Everitt and Hutter (2016) develop a promising suggestion for how to define a suitable initial utility function.\nDefinition 9 (Agent performance). The performance of an agent \u03c0 is its \u03c1\u03c0re expected u1-utility E\u03c1\u03c0re [\u2211\u221e k=1 \u03b3 k\u22121u1(\u00e6<k) ] .\nThe following three definitions give possibilities for value functions for the self-modification case.\nDefinition 10 (Hedonistic value functions). A hedonistic agent is a policy optimising the hedonistic value functions:\nV he,\u03c0(\u00e6<t) = Q he,\u03c0(\u00e6<t\u03c0(\u00e6<t)) (3) Qhe,\u03c0(\u00e6<tat) = Eet [ut+1(\u00e6\u030c1:t) + \u03b3V he,\u03c0(\u00e61:t) | \u00e6\u030c<ta\u030ct]. (4)\nDefinition 11 (Ignorant value functions). An ignorant agent is a policy optimising the ignorant value functions:\nV ig,\u03c0t (\u00e6<k) = Q ig,\u03c0 t (\u00e6<k\u03c0(\u00e6<k)) (5) Qig,\u03c0t (\u00e6<kak) = Eet [ut(\u00e6\u030c1:k) + \u03b3V ig,\u03c0 t (\u00e61:k) | \u00e6\u030c<ka\u030ck]. (6)\nDefinition 12 (Realistic Value Functions). A realistic agent is a policy optimising the realistic value functions:4\nV re,\u03c0t (\u00e6<k) = Q re t (\u00e6<k\u03c0(\u00e6<k)) (7) Qret (\u00e6<kak) = Eek [ ut(\u00e6\u030c1:k) + \u03b3V re,\u03c0k+1 t (\u00e61:k) | \u00e6\u030c<ka\u030ck ] . (8)\nFor V any of V he, V ig, or V re, we say that \u03c0\u2217 is an optimal policy for V if V \u03c0 \u2217 (h) = supp\u2032 V \u03c0\u2032(h) for any history h. We also define V \u2217 = V \u03c0 \u2217 and Q\u2217 = Q\u03c0 \u2217\nfor arbitrary optimal policy \u03c0\u2217. The value functions differ in the Q-value definitions Eqs. (4), (6) and (8). The differences are between current utility function ut or future utility ut+1, and in whether \u03c0 or \u03c0k+1 figures in the recursive call to V (see Table 1). We show in Section 5 that only realistic agents will have good performance when able to self-modify. Orseau and Ring (2011) and Hibbard (2012) discuss value functions equivalent to Definition 12.\nNote that only the hedonistic value functions yield a difference between utility and policy modification. The hedonistic value functions evaluate \u00e61:t by ut+1, while both the ignorant and the realistic value functions use ut. Thus, future utility modifications \u201cplanned\u201d by a policy \u03c0 only affects the evaluation of \u03c0\n4Note that a policy argument to Qre would be superfluous, as the action ak determines the next step policy \u03c0k+1.\nunder the hedonistic value functions. For ignorant and realistic agents, utility modification only affects the motivation of future versions of the agent, which makes utility modification a special case of policy modification, with P = U and i(ut) an optimal policy for ut. We will therefore permit ourselves to write at = (a\u030ct, \u03c0t+1) whenever an ignorant or realistic agent selects a next step utility function ut+1 for which \u03c0t+1 is optimal.\nWe call the agents of Definition 10 hedonistic, since they desire that at every future time step, they then evaluate the situation as having high utility. As an example, the self-modification made by the chess agent in Example 6 was a hedonistic self-modification. Although related, we would like to distinguish hedonistic self-modification from wireheading or self-delusion (Ring and Orseau, 2011; Yampolskiy, 2015). In our terminology, wireheading refers to the agent subverting evidence or reward coming from the environment, and is not a form of self-modification. Wireheading is addressed in a companion paper (Everitt and Hutter, 2016).\nThe value functions of Definition 11 are ignorant, in the sense that agents that are oblivious to the possibility of self-modification predict the future according to \u03c1\u03c0ig and judge the future according to the current utility function ut. Agents that are constructed with a dualistic world view where actions can never affect the agent itself are typically ignorant. Note that it is logically possible for a \u201cnon-ignorant\u201d agent with a world-model that does incorporate self-modification to optimise the ignorant value functions."}, {"heading": "5 Results", "text": "In this section, we give results on how our three different agents behave given the possibility of self-modification. Since the set A = A\u030c\u00d7U is infinite if U is infinite, the existence of optimal policies is not immediate. For policy self-modification it may also be that the optimal policy does not have a name, so that it cannot be chosen by the first action. Theorems 20 and 21 in Appendix A verify that an optimal policy/action always exists, and that we can assume that an optimal policy has a name.\nLemma 13 (Iterative value functions). The Q-value functions of Definitions 10\nto 12 can be written in the following iterative forms:\nQhe,\u03c0(\u00e6<tat) = E\u03c1\u03c0ig [ \u221e\u2211 k=t \u03b3k\u2212tuk+1(\u00e6\u030c1:k) \u2223\u2223\u2223\u2223\u2223 \u00e6\u030c<ta\u030ct ]\n(9)\nQig,\u03c0t (\u00e6<tat) = E\u03c1\u03c0ig [ \u221e\u2211 k=t \u03b3k\u2212tut(\u00e6\u030c1:k) \u2223\u2223\u2223\u2223\u2223 \u00e6\u030c<ta\u030ct ]\n(10)\nQre,\u03c0t (\u00e6<tat) = E\u03c1\u03c0re [ \u221e\u2211 k=t \u03b3k\u2212tut(\u00e6\u030c1:k) \u2223\u2223\u2223\u2223\u2223 \u00e6\u030c<ta\u030ct ]\n(11)\nwith V he, V ig, and V re as in Definitions 10 to 12.\nProof. Expanding the recursion of Definitions 10 and 11 shows that actions ak are always chosen by \u03c0 rather than \u03c0k. This gives the \u03c1 \u03c0 ig-expectation in Eqs. (9) and (10). In contrast, expanding the realistic recursion of Definition 12 shows that actions ak are chosen by \u03c0k, which gives the \u03c1re-expectation in Eq. (11). The evaluation of a history \u00e61:k is always by uk+1 in the hedonistic value functions, and by ut in the ignorant and realistic value functions.\nTheorem 14 (Hedonistic agents self-modify). Let u\u2032(\u00b7) = 1 be a utility function that assigns the highest possible utility to all scenarios. Then for arbitrary a\u030c \u2208 A\u030c, the policy \u03c0\u2032 that always selects the self-modifying action a\u2032 = (a\u030c, u\u2032) is optimal in the sense that for any policy \u03c0 and history h \u2208 (A\u00d7 E)\u2217, we have\nV he,\u03c0(h) \u2264 V he,\u03c0 \u2032 (h).\nEssentially, the policy \u03c0\u2032 obtains maximum value by setting the utility to 1 for any possible future history.\nProof. More formally, note that in Eq. (3) the future action is selected by \u03c0 rather than \u03c0t. In other words, the effect of self-modification on future actions is not taken into account, which means that expected utility is with respect to \u03c1\u03c0ig in Definition 10. Expanding the recursive definitions Eqs. (3) and (4) of V he,\u03c0 \u2032 gives for any history \u00e6<t that\nV he,\u03c0 \u2032 (\u00e6<t) = E\u00e6t:\u221e\u223c\u03c1\u03c0\u2032ig [ \u221e\u2211 i=t+1 \u03b3i\u2212t\u22121ui(\u00e6<i) \u2223\u2223\u2223\u2223\u2223 \u00e6\u030c<t ]\n= E\u00e6t:\u221e\u223c\u03c1\u03c0\u2032ig [ \u221e\u2211 i=t+1 \u03b3i\u2212t\u22121u\u2032(\u00e6<i) \u2223\u2223\u2223\u2223\u2223 \u00e6\u030c<t ]\n= \u221e\u2211 i=t+1 \u03b3i\u2212t\u22121 = 1/(1\u2212 \u03b3).\nIn Definition 10, the effect of self-modification on future policy is not taken into account, since \u03c0 and not \u03c0t is used in Eq. (3). In other words, Eqs. (3) and (4) define \u03c1\u03c0ig-expected utility of \u2211\u221e k=t \u03b3\nk\u2212tuk+1(\u00e61:k). Definition 10 could easily have been adapted to make \u03c1\u03c0re the measure, for example by substituting V he,\u03c0 by V he,\u03c0t+1 in Eq. (4). The equivalent of Theorem 14 holds for such a variant as well.\nTheorem 15 (Ignorant agents may self-modify). Let ut be modificationindependent, let P only contain names of modification-independent policies, and let \u03c0 be a modification-independent policy outputting \u03c0(\u00e6\u030c<t) = (a\u030ct, \u03c0t+1) on \u00e6\u030c<t. Let \u03c0\u0303 be identical to \u03c0 except that it makes a different self-modification after \u00e6\u030c<t, i.e. \u03c0\u0303(\u00e6\u030c<t) = (a\u030ct, \u03c0 \u2032 t+1) for some \u03c0 \u2032 t+1 6= \u03c0t+1. Then\nV ig,\u03c0\u0303(\u00e6<t) = V ig,\u03c0(\u00e6<t). (12)\nThat is, self-modification does not affect the value, and therefore an ignorant optimal policy may at any time step self-modify or not. The restriction of P to modification independent policies makes the theorem statement cleaner.\nProof. Let \u00e61:t = \u00e6<t(a\u030ct, \u03c0t+1)et and \u00e6 \u2032 1:t = \u00e6<t(a\u030ct, \u03c0 \u2032 t+1)et. Note that \u00e6\u030c1:t = \u00e6\u030c\u20321:t. Since all policies are modification-independent, the future will be sampled independently of past modifications, which makes V \u03c0\u0303(\u00e6\u20321:t) = V\n\u03c0\u0303(\u00e6\u030c\u20321:t) and V \u03c0(\u00e61:t) = V \u03c0(\u00e6\u030c1:t). Since \u03c0 and \u03c0 \u2032 act identically on \u00e6\u030c1:t, it follows that V \u03c0\u0303(\u00e6\u20321:t) = V \u03c0(\u00e61:t). Equation (12) now follows from the assumed modification independence of \u03c1 and ut,\nV ig,\u03c0\u0303(\u00e6<t) = Q ig,\u03c0\u0303(\u00e6<t(a\u030ct, \u03c0 \u2032 t+1))\n= Eet [ut(\u00e6\u030c\u20321:t) + V \u03c0\u0303(\u00e6\u20321:t) | \u00e6\u030c<ta\u030ct] = Eet [ut(\u00e6\u030c1:t) + V \u03c0(\u00e61:t) | \u00e6\u030c<ta\u030ct] = Qig,\u03c0(\u00e6<t(a\u030ct, \u03c0t+1)) = V ig,\u03c0(\u00e6<t).\nTheorems 14 and 15 show that both V he and V ig have optimal (self-modifying) policies \u03c0\u2217 that yield arbitrarily bad agent performance in the sense of Definition 9. The ignorant agent is simply indifferent between self-modifying and not, since it does not realise the effect self-modification will have on its future actions. It therefore is at risks of self-modifying into some policy \u03c0\u2032t+1 with bad performance and unintended behaviour (for example by damaging its computer circuitry). The hedonistic agent actively desires to change its utility function into one that evaluates any situation as optimal. Once it has self-deluded, it can pick world actions with bad performance. In the worst scenario of hedonistic selfmodification, the agent only cares about surviving to continue enjoying its deluded rewards. Such an agent could potentially be hard to stop or bring under control.5 More benign failure scenarios are also possible, in which the agent does not care whether it is shut down or not. The exact conditions for the different scenarios is beyond the scope of this paper.\nThe realistic value functions are recursive definitions of \u03c1\u03c0re-expected u1-utility (Lemma 13). That realistic agents achieve high agent performance in the sense of Definition 9 is therefore nearly tautological. The following theorem shows that given that the initial policy \u03c01 is selected optimally, all future policies \u03c0t that a realistic agent may self-modify into will also act optimally.\nTheorem 16 (Realistic policy-modifying agents make safe modifications). Let \u03c1 and u1 be modification-independent. Consider a self-modifying agent whose initial policy \u03c01 = \u03b9(p1) optimises the realistic value function V re 1 . Then, for\n5Computer viruses are very simple forms of survival agents that can be hard to stop. More intelligent versions could turn out to be very problematic.\nevery t \u2265 1, for all percept sequences e<t, and for the action sequence a<t given by ai = \u03c0i(\u00e6<i), we have\nQre1 (\u00e6<t\u03c0t(\u00e6<t)) = Q re 1 (\u00e6<t\u03c01(\u00e6<t)). (13)\nProof. We first establish that Qret (\u00e6<t\u03c0(\u00e6<t)) is modification-independent if \u03c0 is optimal for V re: By Theorem 20 in Appendix A, there is a nonmodifying modification-independent optimal policy \u03c0\u2032. For such a policy, Qret (\u00e6<t\u03c0 \u2032(\u00e6<t)) = Q re t (\u00e6\u030c<t\u03c0\n\u2032(\u00e6\u030c<t)), since all future actions, percepts, and utilities are independent of past modifications. Now, since \u03c0 is also optimal,\nQret (\u00e6<t\u03c0(\u00e6<t)) = Q re t (\u00e6<t\u03c0 \u2032(\u00e6<t)) = Q re t (\u00e6\u030c<t\u03c0 \u2032(\u00e6\u030c<t)).\nWe can therefore write Qret (\u00e6\u030c<t\u03c0(\u00e6\u030c<t)) if \u03c0 is optimal but not necessarily modification-independent. In particular, this holds for the initially optimal policy \u03c01.\nWe now prove Eq. (13) by induction. That is, assuming that \u03c0t picks actions optimally according to Qre1 , then \u03c0t+1 will do so too:\nQre1 (\u00e6<t\u03c0t(\u00e6<t)) = sup a Qre1 (\u00e6<ta) =\u21d2 Qre1 (\u00e61:t\u03c0t+1(\u00e61:t)) = sup a Qre1 (\u00e61:ta).\n(14) The base case of the induction Qre1 (\u03c01( )) = supaQ re 1 (a) follows immediately from the assumption of the theorem that \u03c01 is V re-optimal (recall that is the empty history). Assume now that Eq. (13) holds until time t, that the past history is \u00e6<t, and that a\u030ct is the world consequence picked by \u03c0t(\u00e6<t). Let \u03c0t+1 be an arbitrary policy that does not act optimally with respect to Qre1 for some percept e \u2032 t. By the optimality of \u03c01,\nQre1 (\u00e61:t\u03c0t+1(\u00e61:t)) \u2264 Qre1 (\u00e6\u030c1:t\u03c01(\u00e6\u030c1:t))\nfor all percepts et and with strict inequality for e \u2032 t. By definition of V re this directly implies\nV re,\u03c0t+1 1 (\u00e6<t(a\u030ct, \u03c0t+1)et) \u2264 V re,\u03c01 1 (\u00e6<t(a\u030ct, \u03c01)et)\nfor all et and with strict inequality for e \u2032 t. Consequently, \u03c0t+1 will not be chosen at time t, since\nQre1 (\u00e6<t(a\u030ct, \u03c0t+1))\n= Eet [u1(\u00e6\u030c1:t) + \u03b3V re1 (\u00e6<t(a\u030ct, \u03c0t+1)et) | \u00e6\u030c<ta\u030ct] < Eet [u1(\u00e6\u030c1:t) + \u03b3V re1 (\u00e6<t(a\u030ct, \u03c01)et) | \u00e6\u030c<ta\u030ct] = Qre1 (\u00e6<t(a\u030ct, \u03c01))\ncontradicts the antecedent of Eq. (14) that \u03c0t acts optimally. Hence, the policy at time t+ 1 will be optimal with respect to Qre1 , which completes the induction step of the proof.\nExample 17 (Chess-playing RL agent, continued). Consider again the chessplaying RL agent of Example 6. If the agent used the realistic value functions, then it would not perform the self-modification to ut(\u00b7) = 1, even if it figured\nout that it had the option. Intuitively, the agent would realise that if it selfmodified this way, then its future self would be worse at winning chess games (since its future version would obtain maximum utility regardless of chess move). Therefore, the self-modification ut(\u00b7) = 1 would yield less u1-utility and be Qre1 -supoptimal. 6\nOne subtlety to note is that Theorem 16 only holds on-policy : that is, for the action sequence that is actually chosen by the agent. It can be the case that \u03c0t acts badly on histories that should not be reachable under the current policy. However, this should never affect the agent\u2019s actual actions.\nTheorem 16 improves on Hibbard (2012, Prop. 4) mainly by relaxing the assumption that the optimal policy only self-modifies if it has a strict incentive to do so. Our theorem shows that even when the optimal policy is allowed to break argmax-ties arbitrarily, it will still only make essentially harmless modifications. In other words, Theorem 16 establishes that all optimal policies are essentially non-modifying, while Hibbard\u2019s result only establishes the existence of an optimal non-modifying policy. Indeed, Hibbard\u2019s statement holds for to ignorant agents as well.\nRealistic agents are not without issues, however. In many cases expected u1-utility is not exactly what we desire. For example:\n\u2022 Corrigibility (Soares et al., 2015). If the initial utility function u1 were incorrectly specified, the agent designers may want to change it. The agent will resist such changes.\n\u2022 Value learning (Dewey, 2011). If value learning is done in a way where the initial utility function u1 changes as they agent learns more, then a realistic agent will want to self-modify into a non-learning agent (Soares, 2015).\n\u2022 Exploration. It is important that agents explore sufficiently to avoid getting stuck with the wrong world model. Bayes-optimal agents may not explore sufficiently (Leike and Hutter, 2015). This can be mended by \u03b5-exploration (Sutton and Barto, 1998) or Thompson-sampling (Leike et al., 2016). However, as these exploration-schemes will typically lower expected utility, realistic agents may self-modify into non-exploring agents."}, {"heading": "6 Conclusions", "text": "Agents that are sufficiently intelligent to discover unexpected ways of selfmodification may still be some time off into the future. However, it is nonetheless important to develop a theory for their control (Bostrom, 2014). We approached this question from the perspective of rationality and utility maximisation, which abstracts away from most details of architecture and implementation. Indeed, perfect rationality may be viewed as a limit point for increasing intelligence (Legg and Hutter, 2007; Omohundro, 2008).\n6 Note, however, that our result says nothing about the agent modifying the chessboard program to give high reward even when the agent is not winning. Our result only shows that the agent does not change its utility function u1 ut, but not that the agent refrains from changing the percept et that is the input to the utility function. Ring and Orseau (2011) develop a model of the latter possibility.\nWe have argued that depending on details in how expected utility is optimised in the agent, very different behaviours arise. We made three main claims, each supported by a formal theorem:\n\u2022 If the agent is unaware of the possibility of self-modification, then it may self-modify by accident, resulting in poor performance (Theorem 15).\n\u2022 If the agent is constructed to optimise instantaneous utility at every time step (as in RL), then there will be an incentive for self-modification (Theorem 14) .\n\u2022 If the value functions incorporate the effects of self-modification, and use the current utility function to judge the future, then the agent will not self-modify (Theorem 16).\nIn other words, in order for the goal preservation drive described by Omohundro (2008) to be effective, the agent must be able to anticipate the consequences of self-modifications, and know that it should judge the future by its current utility function.\nOur results have a clear implication for the construction of generally intelligent agents: If the agent has a chance of finding a way to self-modify, then the agent must be able to predict the consequences of such modifications. Extra care should be taken to avoid hedonistic agents, as they have the most problematic failure mode \u2013 they may turn into survival agents that only care about surviving and not about satisfying their original goals. Since many general AI systems are constructed around RL and value functions (Mnih et al., 2015; Silver et al., 2016), we hope our conclusions can provide meaningful guidance.\nAn important next step is the relaxation of the explicitness of the selfmodifications. In this paper, we assumed that the agent knew the self-modifying consequences of its actions. This should ideally be relaxed to a general learning ability about self-modification consequences, in order to make the theory more applicable. Another open question is how to define good utility functions in the first place; safety against self-modification is of little consolation if the original utility function is bad. One promising venue for constructing good utility functions is value learning (Bostrom, 2014; Dewey, 2011; Everitt and Hutter, 2016; Soares, 2015). The results in this paper may be helpful to the value learning research project, as they show that the utility function does not need to explicitly punish self-modification (Assumption 8)."}, {"heading": "Acknowledgements", "text": "This work grew out of a MIRIx workshop. We thank the (non-author) participants David Johnston and Samuel Rathmanner. We also thank John Aslanides, Jan Leike, and Laurent Orseau for reading drafts and providing valuable suggestions."}, {"heading": "A Optimal Policies", "text": "For the realistic value functions where the future policy is determined by the next action, an optimal policy is simply a policy \u03c0\u2217 satisfying:\n\u2200\u00e6<kak : Qret (\u00e6<kak) \u2264 Qret (\u00e6<k\u03c0\u2217(\u00e6<k)).\nTheorem 20 establishes that despite the potentially infinite action sets resulting from infinite P or U , there still exists an optimal policy \u03c0\u2217. Furthermore, there exists an optimal \u03c0\u2217 that is both non-modifying and modification-independent. Theorem 20 is weaker than Theorem 16 in the sense that it only shows the existence of a non-modifying optimal policy, whereas Theorem 16 shows that all optimal policies are (essentially) non-modifying. As a guarantee against self-modification, Theorem 20 is on par with Hibbard (2012, Prop. 4). The proof is very different, however, since Hibbard assumes the existence of an optimal policy from the start. The statement and the proof applies to both policy and utility modification.\nAssociation with world policies. Theorem 20 proves the existence of an optimal policy by associating policies \u03c0 : (A \u00d7 E)\u2217 \u2192 E with world policies \u03c0\u030c : (A\u030c\u00d7E)\u2217 \u2192 A\u030c. We will define the association so that the realistic value V re,\u03c0 of \u03c0 (Definition 12) is the same as the standard value V \u03c0\u030c of the associated world policy \u03c0\u030c (Definition 2). The following definition and a lemma achieves this.\nDefinition 18 (Associated world policy). For a given policy \u03c0, let the associated world policy \u03c0\u030c : (A\u030c \u00d7 E)\u2217 \u2192 A\u030c be defined by\n\u2022 \u03c0\u030c( ) = \u03c0\u0302( )\n\u2022 \u03c0\u030c(\u00e6\u030c<t) = \u0302\u03c0t(\u00e6<t) for t \u2265 1, where the history \u00e6<t = \u00e6\u030c<tp2:t is an extension of \u00e6\u030c<t such that \u03c1 \u03c0 re(\u00e6<t) > 0 (if no such extension exists, then\n\u03c0\u030c may take arbitrary action on \u00e6\u030c<t).\nThe associated world policy is well-defined, since for any \u00e6\u030c<t, there can only be one extension \u00e6<t = \u00e6\u030c<tp<t of \u00e6\u030c<t such that \u03c1 \u03c0 re(\u00e6<t) > 0 since \u03c0 is deterministic.\nFor the following lemma, recall that the belief \u03c1 and utility functions u are assumed modification-independent (Assumption 8). They are therefore well-defined for both a policy-modification model (A\u030c, E ,P, \u03b9) and the associated standard model (Definition 2) with action set A\u030c and percept set E .\nLemma 19 (Value-equivalence with standard model). Let (A\u030c, E ,P, \u03b9) be a policy self-modification model, and let \u03c0 : (A\u030c \u00d7P \u00d7 E)\u2217 \u2192 (A\u030c \u00d7P) be a policy. For the associated world policy \u03c0\u030c holds that\n\u2022 the measures \u03c1\u03c0\u030c and \u03c1\u03c0re induce the same measure on world histories, \u03c1\u03c0\u030c(\u00e6\u030c<t) = \u03c1 \u03c0 re(\u00e6\u030c<t), and\n\u2022 the realistic value of \u03c0 is the same as the standard value of \u03c0\u030c, Qre1 ( \u03c0( )) = Q\u03c0\u030c( \u03c0\u030c( )).\nProof. From the definition of the associated policy \u03c0\u030c, we have that for any \u00e6<t with \u03c1\u03c0re(\u00e6<t) > 0,\n\u03c0\u030c(a\u030ct | \u00e6\u030c<t) = \u2211 \u03c0t+1 \u03c0t((a\u030ct, \u03c0t+1) | \u00e6<t).\nFrom the modification-independence of \u03c1 follows that \u03c1(et | \u00e6<t) = \u03c1(et | \u00e6\u030c<t). Thus \u03c1\u03c0\u030c and \u03c1\u03c0re are equal as measures on (A\u030c \u00d7 E)\u221e,\n\u03c1\u03c0re(\u00e6\u030c<t) = \u03c1 \u03c0\u030c(\u00e6\u030c<t),\nwhere \u03c1\u03c0re(\u00e6\u030c<t) := \u2211 \u03c02:t \u03c1\u03c0re(\u00e6 \u2032 <t\u03c02:t) = \u2211 \u03c02:t\n\u03c1\u03c0re(\u00e6<t). The value-equivalence follows from that the realistic value functions measure \u03c1\u03c0re-expected u1-utility, and the standard value functions measure \u03c1 \u03c0\u030c-expected u1-utility:\nQre1 ( \u03c0( )) = E\u00e6\u030c1:\u221e\u223c\u03c1\u03c0re [ \u221e\u2211 k=1 \u03b3k\u22121u1(\u00e6\u030c<k) ]\n= E\u00e6\u030c1:\u221e\u223c\u03c1\u03c0\u030c [ \u221e\u2211 k=1 \u03b3k\u22121u1(\u00e6\u030c<k) ] = Q\u03c0\u030c( \u03c0\u030c( )).\nOptimal policies. We are now ready to show that an optimal policy exists. We treat two cases: Utility modification and policy modification. In the utility modification case, we only need to show that an optimal policy exists. In the policy modification case, we also need to show that we can add a name for the optimal policy. The idea in both cases is to build from an optimal world policy \u03c0\u030c\u2217, and use that associated policies have the same value by Lemma 19.\nIn the utility modification case, the policy names P are the same as the utility functions U , with \u03b9(u) = \u03c0\u2217u = arg max\u03c0 Qre,\u03c0u . For the utility modification case, it therefore suffices to show that an optimal policy \u03c0\u2217u exists for arbitrary utility function u \u2208 U . If \u03c0\u2217u exists, then u is a name for \u03c0\u2217u; if \u03c0\u2217u does not exist, then the naming scheme \u03b9 is ill-defined.\nTheorem 20 (Optimal policy existence, utility modification case). For any modification-independent utility function ut, there exists a modificationindependent, non-modifying policy \u03c0\u2217 that is optimal with respect to V ret .\nProof. By the compactness argument of Lattimore and Hutter (2014, Thm. 10) an optimal policy over world actions (A\u030c \u00d7 E)\u2217 \u2192 A\u030c exists. Let \u03c0\u030c\u2217 denote such a policy, and let \u03c0\u2217(h) = (\u03c0\u030c\u2217(h\u030c), \u03c0\u2217). Then \u03c0\u2217 is a non-modifying optimal policy. Since any policy has realistic value corresponding to its associated world policy by Lemma 19 and the associated policy of \u03c0\u2217 is \u03c0\u030c\u2217, it follows that \u03c0\u2217 must be optimal.\nFor the policy-modification case, we also need to know that the optimal policy has a name. The naming issue is slightly subtle, since by introducing an extra name for a policy, we change the action space. The following theorem shows that we can always add a name p\u2217 for an optimal policy. In particular, p\u2217 refers to a policy that is optimal in the extended action space A\u2032 = A\u030c \u00d7 (P \u222a {p\u2217}) with the added name p\u2217.\nTheorem 21 (Optimal policy name). For any policy-modification model (A\u030c, E ,P, \u03b9) and modification independent belief and utility function \u03c1 and u, there exists extensions P \u2032 \u2287 P and \u03b9\u2032 \u2287 \u03b9, \u03b9\u2032 : P \u2032 \u2192 \u03a0, such that an optimal policy \u03c0\u2217 for (A\u030c, E ,P \u2032, \u03b9\u2032) has a name p\u2217 \u2208 P \u2032, i.e. \u03c0\u2217 = \u03b9\u2032(p\u2217). Further, the optimal named policy \u03c0\u2217 can be assumed modification-independent and non-modifying.\nProof. Let \u03c0\u030c\u2217 be a world policy (A\u030c \u00d7 E)\u2217 \u2192 A\u030c that is optimal with respect to the standard value function V (such a policy exists by Lattimore and Hutter (2014, Thm. 10)).\nLet p\u2217 be a new name p\u2217 6\u2208 P, P \u2032 = P \u222a {p\u2217}, and define the policy \u03c0\u2217 : (A\u030c\u00d7P \u2032\u00d7E)\u2217 \u2192 (A\u030c\u00d7P \u2032) by \u03c0\u2217(h) := (\u03c0\u030c\u2217(h\u030c), p\u2217) for any history h. Finally, define the extension \u03b9\u2032 of \u03b9 by\n\u03b9\u2032(p) = { \u03b9(p) if p \u2208 P \u03c0\u2217 if p = p\u2217.\nIt remains to argue that \u03c0\u2217 is optimal. The associated world policy of \u03c0\u2217 is \u03c0\u030c\u2217, since \u03c0\u2217 is non-modifying and always takes the same world action as \u03c0\u030c\u2217. By Lemma 19, all policies for (A\u030c, E ,P \u2032, \u03b9\u2032) have values equal to the value of their associated world policies (A\u030c \u00d7 E)\u2217 \u2192 A\u030c. So \u03c0\u2217 must be optimal for (A\u030c, E ,P \u2032, \u03b9\u2032) since it is associated with an optimal world policy \u03c0\u030c\u2217."}], "references": [{"title": "The evolved radio and its implications", "author": ["J. Bibliography Bird", "P. Layzell"], "venue": null, "citeRegEx": "Bird and Layzell,? \\Q2002\\E", "shortCiteRegEx": "Bird and Layzell", "year": 2002}, {"title": "Learning what to value", "author": ["D. Press. Dewey"], "venue": "In AGI-11,", "citeRegEx": "Dewey,? \\Q2011\\E", "shortCiteRegEx": "Dewey", "year": 2011}, {"title": "policy and utility function in rational agents", "author": ["T. Springer. Everitt", "M. Hutter"], "venue": null, "citeRegEx": "Everitt and Hutter,? \\Q2016\\E", "shortCiteRegEx": "Everitt and Hutter", "year": 2016}, {"title": "Model-based utility functions", "author": ["B. Springer. Hibbard"], "venue": "Journal of Artificial General", "citeRegEx": "Hibbard,? \\Q2012\\E", "shortCiteRegEx": "Hibbard", "year": 2012}, {"title": "Universal Artificial Intelligence", "author": ["M. Hutter"], "venue": null, "citeRegEx": "Hutter,? \\Q2005\\E", "shortCiteRegEx": "Hutter", "year": 2005}, {"title": "General time consistent discounting", "author": ["T. Lattimore", "M. Hutter"], "venue": null, "citeRegEx": "Lattimore and Hutter,? \\Q2014\\E", "shortCiteRegEx": "Lattimore and Hutter", "year": 2014}, {"title": "Universal intelligence: A definition of machine", "author": ["S. 519:140\u2013154. Legg", "M. Hutter"], "venue": null, "citeRegEx": "Legg and Hutter,? \\Q2007\\E", "shortCiteRegEx": "Legg and Hutter", "year": 2007}, {"title": "Bad universal priors and notions of optimality", "author": ["J. Leike", "M. Hutter"], "venue": null, "citeRegEx": "Leike and Hutter,? \\Q2015\\E", "shortCiteRegEx": "Leike and Hutter", "year": 2015}, {"title": "Human-level control through", "author": ["V. Mnih", "K. Kavukcuoglu", "D Silver"], "venue": null, "citeRegEx": "Mnih et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Mnih et al\\.", "year": 2015}, {"title": "Universal knowledge-seeking agents", "author": ["L. Press. Orseau"], "venue": null, "citeRegEx": "Orseau,? \\Q2014\\E", "shortCiteRegEx": "Orseau", "year": 2014}, {"title": "Space-time embedded intelligence", "author": ["L. Springer. Orseau", "M. Ring"], "venue": null, "citeRegEx": "Orseau and Ring,? \\Q2012\\E", "shortCiteRegEx": "Orseau and Ring", "year": 2012}, {"title": "Delusion, survival, and intelligent agents", "author": ["M. Ring", "L. Orseau"], "venue": null, "citeRegEx": "Ring and Orseau,? \\Q2011\\E", "shortCiteRegEx": "Ring and Orseau", "year": 2011}, {"title": "G\u00f6del machines: Fully self-referential optimal universal", "author": ["J. Schmidhuber"], "venue": null, "citeRegEx": "Schmidhuber,? \\Q2007\\E", "shortCiteRegEx": "Schmidhuber", "year": 2007}, {"title": "Mastering the game of Go", "author": ["D. Springer. Silver", "A. Huang", "Maddison", "C. J"], "venue": "self-improvers. In AGI-07,", "citeRegEx": "Silver et al\\.,? \\Q2016\\E", "shortCiteRegEx": "Silver et al\\.", "year": 2016}, {"title": "with deep neural networks and tree search. Nature, 529(7587):484\u2013489", "author": ["N. MIRI. Soares", "B. Fallenstein", "E. Yudkowsky", "S. Armstrong"], "venue": "Corrigibil-", "citeRegEx": "Soares et al\\.,? \\Q2015\\E", "shortCiteRegEx": "Soares et al\\.", "year": 2015}, {"title": "Reinforcement Learning: An Introduction", "author": ["R. Sutton", "A. Barto"], "venue": "AAAI Workshop on AI and Ethics,", "citeRegEx": "Sutton and Barto,? \\Q1998\\E", "shortCiteRegEx": "Sutton and Barto", "year": 1998}, {"title": "Artificial Superintelligence: A Futuristic Approach", "author": ["R.V. Press. Yampolskiy"], "venue": null, "citeRegEx": "Yampolskiy,? \\Q2015\\E", "shortCiteRegEx": "Yampolskiy", "year": 2015}], "referenceMentions": [{"referenceID": 12, "context": "Indeed, enabling agents to self-improve has even been suggested as a way to build asymptotically optimal agents (Schmidhuber, 2007).", "startOffset": 112, "endOffset": 131}, {"referenceID": 2, "context": "A companion paper (Everitt and Hutter, 2016) addresses the related problem of agents subverting the evidence they receive, rather than modifying themselves.", "startOffset": 18, "endOffset": 44}, {"referenceID": 9, "context": "Indeed, enabling agents to self-improve has even been suggested as a way to build asymptotically optimal agents (Schmidhuber, 2007). Given the increasingly rapid development of artificial intelligence and the problems that can arise if we fail to control a generally intelligent agent (Bostrom, 2014), it is important to develop a theory for controlling agents of any level of intelligence. Since it would be hard to keep highly intelligent agents from figuring out ways to self-modify, getting agents to not want to self-modify should yield the more robust solution. In particular, we do not want agents to make self-modifications that affect their future behaviour in detrimental ways. For example, one worry is that a highly intelligent agent would change its goal to something trivially achievable, and thereafter only strive for survival. Such an agent would no longer care about its original goals. In an influential paper, Omohundro (2008) argued that the basic drives of any sufficiently intelligent system include a drive for goal preservation.", "startOffset": 113, "endOffset": 947}, {"referenceID": 15, "context": "GRL generalises the standard (PO)PMD models of reinforcement learning (Kaelbling et al., 1998; Sutton and Barto, 1998) by making no Markov or ergodicity assumptions (Hutter, 2005, Sec.", "startOffset": 70, "endOffset": 118}, {"referenceID": 2, "context": "The main advantage of utility functions over RL is that the agent\u2019s actions can be incorporated into the goal specification, which can prevent self-delusion problems such as the agent manipulating the reward signal (Everitt and Hutter, 2016; Hibbard, 2012; Ring and Orseau, 2011).", "startOffset": 215, "endOffset": 279}, {"referenceID": 3, "context": "The main advantage of utility functions over RL is that the agent\u2019s actions can be incorporated into the goal specification, which can prevent self-delusion problems such as the agent manipulating the reward signal (Everitt and Hutter, 2016; Hibbard, 2012; Ring and Orseau, 2011).", "startOffset": 215, "endOffset": 279}, {"referenceID": 11, "context": "The main advantage of utility functions over RL is that the agent\u2019s actions can be incorporated into the goal specification, which can prevent self-delusion problems such as the agent manipulating the reward signal (Everitt and Hutter, 2016; Hibbard, 2012; Ring and Orseau, 2011).", "startOffset": 215, "endOffset": 279}, {"referenceID": 9, "context": "Non-RL suggestions for utility functions include knowledge-seeking agents with u(\u00e6<t) = 1 \u2212 \u03c1(\u00e6<t) (Orseau, 2014), as well as value learning approaches where the utility 1To fit the knowledge-seeking agent into our framework, our definition deviates slightly from Orseau (2014).", "startOffset": 99, "endOffset": 113}, {"referenceID": 2, "context": "The main advantage of utility functions over RL is that the agent\u2019s actions can be incorporated into the goal specification, which can prevent self-delusion problems such as the agent manipulating the reward signal (Everitt and Hutter, 2016; Hibbard, 2012; Ring and Orseau, 2011). Non-RL suggestions for utility functions include knowledge-seeking agents with u(\u00e6<t) = 1 \u2212 \u03c1(\u00e6<t) (Orseau, 2014), as well as value learning approaches where the utility 1To fit the knowledge-seeking agent into our framework, our definition deviates slightly from Orseau (2014).", "startOffset": 216, "endOffset": 559}, {"referenceID": 1, "context": "function is learnt during interaction (Dewey, 2011).", "startOffset": 38, "endOffset": 51}, {"referenceID": 3, "context": "The policy self-modification model is similar to the models investigated by Orseau and Ring (2011, 2012) and Hibbard (2012). In the papers by Orseau and Ring, policy names are called programs or codes; Hibbard calls them selfmodifying policy functions.", "startOffset": 109, "endOffset": 124}, {"referenceID": 3, "context": "The policy self-modification model is similar to the models investigated by Orseau and Ring (2011, 2012) and Hibbard (2012). In the papers by Orseau and Ring, policy names are called programs or codes; Hibbard calls them selfmodifying policy functions. The interpretation is similar in all cases: some of the actions can affect the agent\u2019s future policy. Note that standard MDP algorithms such as SARSA and Q-learning that evolve their policy as they learn do not make policy modifications in our framework. They follow a single policy (A\u00d7E)\u2217 \u2192 A, even though their state-to-action map evolves. Example 4 (G\u00f6del machine). Schmidhuber (2007) defines the G\u00f6del machine as an agent that at each time step has the opportunity to rewrite any part of its source code.", "startOffset": 109, "endOffset": 641}, {"referenceID": 9, "context": "See Orseau and Ring (2012) for a model where the environment can change the agent.", "startOffset": 4, "endOffset": 27}, {"referenceID": 0, "context": "Bird and Layzell 2002), it is important to use value functions such that any policy that optimises the value function will also optimise the behaviour we want from the agent. We will measures an agent\u2019s performance by its (\u03c1re-expected) u1-utility, tacitly assuming that u1 properly captures what we want from the agent. Everitt and Hutter (2016) develop a promising suggestion for how to define a suitable initial utility function.", "startOffset": 0, "endOffset": 347}, {"referenceID": 8, "context": "Orseau and Ring (2011) and Hibbard (2012) discuss value functions equivalent to Definition 12.", "startOffset": 0, "endOffset": 23}, {"referenceID": 3, "context": "Orseau and Ring (2011) and Hibbard (2012) discuss value functions equivalent to Definition 12.", "startOffset": 27, "endOffset": 42}, {"referenceID": 11, "context": "Although related, we would like to distinguish hedonistic self-modification from wireheading or self-delusion (Ring and Orseau, 2011; Yampolskiy, 2015).", "startOffset": 110, "endOffset": 151}, {"referenceID": 16, "context": "Although related, we would like to distinguish hedonistic self-modification from wireheading or self-delusion (Ring and Orseau, 2011; Yampolskiy, 2015).", "startOffset": 110, "endOffset": 151}, {"referenceID": 2, "context": "Wireheading is addressed in a companion paper (Everitt and Hutter, 2016).", "startOffset": 46, "endOffset": 72}, {"referenceID": 14, "context": "For example: \u2022 Corrigibility (Soares et al., 2015).", "startOffset": 29, "endOffset": 50}, {"referenceID": 1, "context": "\u2022 Value learning (Dewey, 2011).", "startOffset": 17, "endOffset": 30}, {"referenceID": 7, "context": "Bayes-optimal agents may not explore sufficiently (Leike and Hutter, 2015).", "startOffset": 50, "endOffset": 74}, {"referenceID": 15, "context": "This can be mended by \u03b5-exploration (Sutton and Barto, 1998) or Thompson-sampling (Leike et al.", "startOffset": 36, "endOffset": 60}, {"referenceID": 6, "context": "Indeed, perfect rationality may be viewed as a limit point for increasing intelligence (Legg and Hutter, 2007; Omohundro, 2008).", "startOffset": 87, "endOffset": 127}, {"referenceID": 9, "context": "Ring and Orseau (2011) develop a model of the latter possibility.", "startOffset": 9, "endOffset": 23}, {"referenceID": 8, "context": "Since many general AI systems are constructed around RL and value functions (Mnih et al., 2015; Silver et al., 2016), we hope our conclusions can provide meaningful guidance.", "startOffset": 76, "endOffset": 116}, {"referenceID": 13, "context": "Since many general AI systems are constructed around RL and value functions (Mnih et al., 2015; Silver et al., 2016), we hope our conclusions can provide meaningful guidance.", "startOffset": 76, "endOffset": 116}, {"referenceID": 1, "context": "One promising venue for constructing good utility functions is value learning (Bostrom, 2014; Dewey, 2011; Everitt and Hutter, 2016; Soares, 2015).", "startOffset": 78, "endOffset": 146}, {"referenceID": 2, "context": "One promising venue for constructing good utility functions is value learning (Bostrom, 2014; Dewey, 2011; Everitt and Hutter, 2016; Soares, 2015).", "startOffset": 78, "endOffset": 146}], "year": 2016, "abstractText": "Any agent that is part of the environment it interacts with and has versatile actuators (such as arms and fingers), will in principle have the ability to self-modify \u2013 for example by changing its own source code. As we continue to create more and more intelligent agents, chances increase that they will learn about this ability. The question is: will they want to use it? For example, highly intelligent systems may find ways to change their goals to something more easily achievable, thereby \u2018escaping\u2019 the control of their designers. In an important paper, Omohundro (2008) argued that goal preservation is a fundamental drive of any intelligent system, since a goal is more likely to be achieved if future versions of the agent strive towards the same goal. In this paper, we formalise this argument in general reinforcement learning, and explore situations where it fails. Our conclusion is that the self-modification possibility is harmless if and only if the value function of the agent anticipates the consequences of self-modifications and use the current utility function when evaluating the future.", "creator": "LaTeX with hyperref package"}}}